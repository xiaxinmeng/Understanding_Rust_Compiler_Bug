{"sha": "0e2c5510e001e5ccbde9e4b7df757e2bba2fdb00", "node_id": "C_kwDOANBUbNoAKDBlMmM1NTEwZTAwMWU1Y2NiZGU5ZTRiN2RmNzU3ZTJiYmEyZmRiMDA", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-11-16T13:45:40Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-11-16T13:45:40Z"}, "message": "libstdc++: Fix up <complex> for extended floating point types [PR107649]\n\nAs filed by Jonathan in the PR, I've screwed up the requires syntax\nin the extended floating point specialization:\n-    requires(__complex_type<_Tp>::type)\n+    requires requires { typename __complex_type<_Tp>::type; }\nand doing this change resulted in lots of errors because __complex_whatever\noverfloads from extended floating point types were declared after the\ntemplates which used them.\n\nThe following patch fixes that.\n\nBootstrapped/regtested on x86_64-linux and i686-linux, additionally\nI've tested that with _GLIBCXX_HAVE_FLOAT128_MATH not being defined\nwhile __STDCPP_FLOAT128_T__ defined one can still use\nstd::complex<std::float128_t> for basic arithmetic etc., just one can't\nexpect std::sin etc. to work in that case (because we don't have any\nimplementation).\n\n2022-11-16  Jakub Jelinek  <jakub@redhat.com>\n\t    Jonathan Wakely  <jwakely@redhat.com>\n\n\tPR libstdc++/107649\n\t* include/std/complex (__complex_abs, __complex_arg, __complex_cos,\n\t__complex_cosh, __complex_exp, __complex_log, __complex_sin,\n\t__complex_sinh, __complex_sqrt, __complex_tan, __complex_tanh,\n\t__complex_pow): Move __complex__ _Float{16,32,64,128} and\n\t__complex__ decltype(0.0bf16) overloads earlier in the file.\n\t(complex): Fix up requires on the partial specialization for extended\n\tfloat types.\n\t(__complex_acos, __complex_asin, __complex_atan, __complex_acosh,\n\t__complex_asinh, __complex_atanh): Move\n\t__complex__ _Float{16,32,64,128} and __complex__ decltype(0.0bf16)\n\toverloads earlier in the file.", "tree": {"sha": "cc6cea808742a4f3edcf3a4df1de2cf61ca211be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc6cea808742a4f3edcf3a4df1de2cf61ca211be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e2c5510e001e5ccbde9e4b7df757e2bba2fdb00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e2c5510e001e5ccbde9e4b7df757e2bba2fdb00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e2c5510e001e5ccbde9e4b7df757e2bba2fdb00", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e2c5510e001e5ccbde9e4b7df757e2bba2fdb00/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf958f8f168f695d49e29297ef9fb37f6efa5d0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf958f8f168f695d49e29297ef9fb37f6efa5d0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf958f8f168f695d49e29297ef9fb37f6efa5d0f"}], "stats": {"total": 1546, "additions": 773, "deletions": 773}, "files": [{"sha": "7fed8a7757cae752d709bf0a4be6998a30ff74d5", "filename": "libstdc++-v3/include/std/complex", "status": "modified", "additions": 773, "deletions": 773, "changes": 1546, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e2c5510e001e5ccbde9e4b7df757e2bba2fdb00/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcomplex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e2c5510e001e5ccbde9e4b7df757e2bba2fdb00/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcomplex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcomplex?ref=0e2c5510e001e5ccbde9e4b7df757e2bba2fdb00", "patch": "@@ -598,746 +598,746 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     { return __z.imag(); }\n #endif\n \n-  // 26.2.7/3 abs(__z):  Returns the magnitude of __z.\n-  template<typename _Tp>\n-    inline _Tp\n-    __complex_abs(const complex<_Tp>& __z)\n-    {\n-      _Tp __x = __z.real();\n-      _Tp __y = __z.imag();\n-      const _Tp __s = std::max(abs(__x), abs(__y));\n-      if (__s == _Tp())  // well ...\n-        return __s;\n-      __x /= __s;\n-      __y /= __s;\n-      return __s * sqrt(__x * __x + __y * __y);\n-    }\n-\n #if _GLIBCXX_USE_C99_COMPLEX\n-  inline float\n-  __complex_abs(__complex__ float __z) { return __builtin_cabsf(__z); }\n+#if defined(__STDCPP_FLOAT16_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n+  inline _Float16\n+  __complex_abs(__complex__ _Float16 __z)\n+  { return _Float16(__builtin_cabsf(__z)); }\n \n-  inline double\n-  __complex_abs(__complex__ double __z) { return __builtin_cabs(__z); }\n+  inline _Float16\n+  __complex_arg(__complex__ _Float16 __z)\n+  { return _Float16(__builtin_cargf(__z)); }\n \n-  inline long double\n-  __complex_abs(const __complex__ long double& __z)\n-  { return __builtin_cabsl(__z); }\n+  inline __complex__ _Float16\n+  __complex_cos(__complex__ _Float16 __z)\n+  { return static_cast<__complex__ _Float16>(__builtin_ccosf(__z)); }\n \n-  template<typename _Tp>\n-    inline _Tp\n-    abs(const complex<_Tp>& __z) { return __complex_abs(__z.__rep()); }\n-#else\n-  template<typename _Tp>\n-    inline _Tp\n-    abs(const complex<_Tp>& __z) { return __complex_abs(__z); }\n-#endif\n+  inline __complex__ _Float16\n+  __complex_cosh(__complex__ _Float16 __z)\n+  { return static_cast<__complex__ _Float16>(__builtin_ccoshf(__z)); }\n \n+  inline __complex__ _Float16\n+  __complex_exp(__complex__ _Float16 __z)\n+  { return static_cast<__complex__ _Float16>(__builtin_cexpf(__z)); }\n \n-  // 26.2.7/4: arg(__z): Returns the phase angle of __z.\n-  template<typename _Tp>\n-    inline _Tp\n-    __complex_arg(const complex<_Tp>& __z)\n-    { return  atan2(__z.imag(), __z.real()); }\n+  inline __complex__ _Float16\n+  __complex_log(__complex__ _Float16 __z)\n+  { return static_cast<__complex__ _Float16>(__builtin_clogf(__z)); }\n \n-#if _GLIBCXX_USE_C99_COMPLEX\n-  inline float\n-  __complex_arg(__complex__ float __z) { return __builtin_cargf(__z); }\n+  inline __complex__ _Float16\n+  __complex_sin(__complex__ _Float16 __z)\n+  { return static_cast<__complex__ _Float16>(__builtin_csinf(__z)); }\n \n-  inline double\n-  __complex_arg(__complex__ double __z) { return __builtin_carg(__z); }\n+  inline __complex__ _Float16\n+  __complex_sinh(__complex__ _Float16 __z)\n+  { return static_cast<__complex__ _Float16>(__builtin_csinhf(__z)); }\n \n-  inline long double\n-  __complex_arg(const __complex__ long double& __z)\n-  { return __builtin_cargl(__z); }\n+  inline __complex__ _Float16\n+  __complex_sqrt(__complex__ _Float16 __z)\n+  { return static_cast<__complex__ _Float16>(__builtin_csqrtf(__z)); }\n \n-  template<typename _Tp>\n-    inline _Tp\n-    arg(const complex<_Tp>& __z) { return __complex_arg(__z.__rep()); }\n-#else\n-  template<typename _Tp>\n-    inline _Tp\n-    arg(const complex<_Tp>& __z) { return __complex_arg(__z); }\n+  inline __complex__ _Float16\n+  __complex_tan(__complex__ _Float16 __z)\n+  { return static_cast<__complex__ _Float16>(__builtin_ctanf(__z)); }\n+\n+  inline __complex__ _Float16\n+  __complex_tanh(__complex__ _Float16 __z)\n+  { return static_cast<__complex__ _Float16>(__builtin_ctanhf(__z)); }\n+\n+  inline __complex__ _Float16\n+  __complex_pow(__complex__ _Float16 __x, __complex__ _Float16 __y)\n+  { return static_cast<__complex__ _Float16>(__builtin_cpowf(__x, __y)); }\n #endif\n \n-  // 26.2.7/5: norm(__z) returns the squared magnitude of __z.\n-  //     As defined, norm() is -not- a norm is the common mathematical\n-  //     sense used in numerics.  The helper class _Norm_helper<> tries to\n-  //     distinguish between builtin floating point and the rest, so as\n-  //     to deliver an answer as close as possible to the real value.\n-  template<bool>\n-    struct _Norm_helper\n-    {\n-      template<typename _Tp>\n-        static inline _GLIBCXX20_CONSTEXPR _Tp _S_do_it(const complex<_Tp>& __z)\n-        {\n-          const _Tp __x = __z.real();\n-          const _Tp __y = __z.imag();\n-          return __x * __x + __y * __y;\n-        }\n-    };\n+#if defined(__STDCPP_FLOAT32_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n+  inline _Float32\n+  __complex_abs(__complex__ _Float32 __z) { return __builtin_cabsf(__z); }\n \n-  template<>\n-    struct _Norm_helper<true>\n-    {\n-      template<typename _Tp>\n-        static inline _GLIBCXX20_CONSTEXPR _Tp _S_do_it(const complex<_Tp>& __z)\n-        {\n-          //_Tp __res = std::abs(__z);\n-          //return __res * __res;\n-          const _Tp __x = __z.real();\n-          const _Tp __y = __z.imag();\n-          return __x * __x + __y * __y;\n-        }\n-    };\n+  inline _Float32\n+  __complex_arg(__complex__ _Float32 __z) { return __builtin_cargf(__z); }\n \n-  template<typename _Tp>\n-    inline _GLIBCXX20_CONSTEXPR _Tp\n-    norm(const complex<_Tp>& __z)\n-    {\n-      return _Norm_helper<__is_floating<_Tp>::__value\n-\t&& !_GLIBCXX_FAST_MATH>::_S_do_it(__z);\n-    }\n+  inline __complex__ _Float32\n+  __complex_cos(__complex__ _Float32 __z) { return __builtin_ccosf(__z); }\n \n-  template<typename _Tp>\n-    inline complex<_Tp>\n-    polar(const _Tp& __rho, const _Tp& __theta)\n-    {\n-      __glibcxx_assert( __rho >= 0 );\n-      return complex<_Tp>(__rho * cos(__theta), __rho * sin(__theta));\n-    }\n+  inline __complex__ _Float32\n+  __complex_cosh(__complex__ _Float32 __z) { return __builtin_ccoshf(__z); }\n \n-  template<typename _Tp>\n-    inline _GLIBCXX20_CONSTEXPR complex<_Tp>\n-    conj(const complex<_Tp>& __z)\n-    { return complex<_Tp>(__z.real(), -__z.imag()); }\n+  inline __complex__ _Float32\n+  __complex_exp(__complex__ _Float32 __z) { return __builtin_cexpf(__z); }\n \n-  // Transcendentals\n+  inline __complex__ _Float32\n+  __complex_log(__complex__ _Float32 __z) { return __builtin_clogf(__z); }\n \n-  // 26.2.8/1 cos(__z):  Returns the cosine of __z.\n-  template<typename _Tp>\n-    inline complex<_Tp>\n-    __complex_cos(const complex<_Tp>& __z)\n-    {\n-      const _Tp __x = __z.real();\n-      const _Tp __y = __z.imag();\n-      return complex<_Tp>(cos(__x) * cosh(__y), -sin(__x) * sinh(__y));\n-    }\n+  inline __complex__ _Float32\n+  __complex_sin(__complex__ _Float32 __z) { return __builtin_csinf(__z); }\n \n-#if _GLIBCXX_USE_C99_COMPLEX\n-  inline __complex__ float\n-  __complex_cos(__complex__ float __z) { return __builtin_ccosf(__z); }\n+  inline __complex__ _Float32\n+  __complex_sinh(__complex__ _Float32 __z) { return __builtin_csinhf(__z); }\n \n-  inline __complex__ double\n-  __complex_cos(__complex__ double __z) { return __builtin_ccos(__z); }\n+  inline __complex__ _Float32\n+  __complex_sqrt(__complex__ _Float32 __z) { return __builtin_csqrtf(__z); }\n \n-  inline __complex__ long double\n-  __complex_cos(const __complex__ long double& __z)\n-  { return __builtin_ccosl(__z); }\n+  inline __complex__ _Float32\n+  __complex_tan(__complex__ _Float32 __z) { return __builtin_ctanf(__z); }\n \n-  template<typename _Tp>\n-    inline complex<_Tp>\n-    cos(const complex<_Tp>& __z) { return __complex_cos(__z.__rep()); }\n-#else\n-  template<typename _Tp>\n-    inline complex<_Tp>\n-    cos(const complex<_Tp>& __z) { return __complex_cos(__z); }\n+  inline __complex__ _Float32\n+  __complex_tanh(__complex__ _Float32 __z) { return __builtin_ctanhf(__z); }\n+\n+  inline __complex__ _Float32\n+  __complex_pow(__complex__ _Float32 __x, __complex__ _Float32 __y)\n+  { return __builtin_cpowf(__x, __y); }\n #endif\n \n-  // 26.2.8/2 cosh(__z): Returns the hyperbolic cosine of __z.\n-  template<typename _Tp>\n-    inline complex<_Tp>\n-    __complex_cosh(const complex<_Tp>& __z)\n-    {\n-      const _Tp __x = __z.real();\n-      const _Tp __y = __z.imag();\n-      return complex<_Tp>(cosh(__x) * cos(__y), sinh(__x) * sin(__y));\n-    }\n+#if defined(__STDCPP_FLOAT64_T__) && defined(_GLIBCXX_DOUBLE_IS_IEEE_BINARY64)\n+  inline _Float64\n+  __complex_abs(__complex__ _Float64 __z) { return __builtin_cabs(__z); }\n \n-#if _GLIBCXX_USE_C99_COMPLEX\n-  inline __complex__ float\n-  __complex_cosh(__complex__ float __z) { return __builtin_ccoshf(__z); }\n+  inline _Float64\n+  __complex_arg(__complex__ _Float64 __z) { return __builtin_carg(__z); }\n \n-  inline __complex__ double\n-  __complex_cosh(__complex__ double __z) { return __builtin_ccosh(__z); }\n+  inline __complex__ _Float64\n+  __complex_cos(__complex__ _Float64 __z) { return __builtin_ccos(__z); }\n \n-  inline __complex__ long double\n-  __complex_cosh(const __complex__ long double& __z)\n-  { return __builtin_ccoshl(__z); }\n+  inline __complex__ _Float64\n+  __complex_cosh(__complex__ _Float64 __z) { return __builtin_ccosh(__z); }\n \n-  template<typename _Tp>\n-    inline complex<_Tp>\n-    cosh(const complex<_Tp>& __z) { return __complex_cosh(__z.__rep()); }\n-#else\n-  template<typename _Tp>\n-    inline complex<_Tp>\n-    cosh(const complex<_Tp>& __z) { return __complex_cosh(__z); }\n+  inline __complex__ _Float64\n+  __complex_exp(__complex__ _Float64 __z) { return __builtin_cexp(__z); }\n+\n+  inline __complex__ _Float64\n+  __complex_log(__complex__ _Float64 __z) { return __builtin_clog(__z); }\n+\n+  inline __complex__ _Float64\n+  __complex_sin(__complex__ _Float64 __z) { return __builtin_csin(__z); }\n+\n+  inline __complex__ _Float64\n+  __complex_sinh(__complex__ _Float64 __z) { return __builtin_csinh(__z); }\n+\n+  inline __complex__ _Float64\n+  __complex_sqrt(__complex__ _Float64 __z) { return __builtin_csqrt(__z); }\n+\n+  inline __complex__ _Float64\n+  __complex_tan(__complex__ _Float64 __z) { return __builtin_ctan(__z); }\n+\n+  inline __complex__ _Float64\n+  __complex_tanh(__complex__ _Float64 __z) { return __builtin_ctanh(__z); }\n+\n+  inline __complex__ _Float64\n+  __complex_pow(__complex__ _Float64 __x, __complex__ _Float64 __y)\n+  { return __builtin_cpow(__x, __y); }\n #endif\n \n-  // 26.2.8/3 exp(__z): Returns the complex base e exponential of x\n-  template<typename _Tp>\n-    inline complex<_Tp>\n-    __complex_exp(const complex<_Tp>& __z)\n-    { return std::polar<_Tp>(exp(__z.real()), __z.imag()); }\n+#if defined(__STDCPP_FLOAT128_T__) && defined(_GLIBCXX_LDOUBLE_IS_IEEE_BINARY128)\n+  inline _Float128\n+  __complex_abs(__complex__ _Float128 __z) { return __builtin_cabsl(__z); }\n+\n+  inline _Float128\n+  __complex_arg(__complex__ _Float128 __z) { return __builtin_cargl(__z); }\n+\n+  inline __complex__ _Float128\n+  __complex_cos(__complex__ _Float128 __z) { return __builtin_ccosl(__z); }\n+\n+  inline __complex__ _Float128\n+  __complex_cosh(__complex__ _Float128 __z) { return __builtin_ccoshl(__z); }\n+\n+  inline __complex__ _Float128\n+  __complex_exp(__complex__ _Float128 __z) { return __builtin_cexpl(__z); }\n+\n+  inline __complex__ _Float128\n+  __complex_log(__complex__ _Float128 __z) { return __builtin_clogl(__z); }\n+\n+  inline __complex__ _Float128\n+  __complex_sin(__complex__ _Float128 __z) { return __builtin_csinl(__z); }\n+\n+  inline __complex__ _Float128\n+  __complex_sinh(__complex__ _Float128 __z) { return __builtin_csinhl(__z); }\n \n-#if _GLIBCXX_USE_C99_COMPLEX\n-  inline __complex__ float\n-  __complex_exp(__complex__ float __z) { return __builtin_cexpf(__z); }\n+  inline __complex__ _Float128\n+  __complex_sqrt(__complex__ _Float128 __z) { return __builtin_csqrtl(__z); }\n \n-  inline __complex__ double\n-  __complex_exp(__complex__ double __z) { return __builtin_cexp(__z); }\n+  inline __complex__ _Float128\n+  __complex_tan(__complex__ _Float128 __z) { return __builtin_ctanl(__z); }\n \n-  inline __complex__ long double\n-  __complex_exp(const __complex__ long double& __z)\n-  { return __builtin_cexpl(__z); }\n+  inline __complex__ _Float128\n+  __complex_tanh(__complex__ _Float128 __z) { return __builtin_ctanhl(__z); }\n \n-  template<typename _Tp>\n-    inline complex<_Tp>\n-    exp(const complex<_Tp>& __z) { return __complex_exp(__z.__rep()); }\n-#else\n-  template<typename _Tp>\n-    inline complex<_Tp>\n-    exp(const complex<_Tp>& __z) { return __complex_exp(__z); }\n-#endif\n+  inline __complex__ _Float128\n+  __complex_pow(__complex__ _Float128 __x, __complex__ _Float128 __y)\n+  { return __builtin_cpowl(__x, __y); }\n+#elif defined(__STDCPP_FLOAT128_T__) && defined(_GLIBCXX_HAVE_FLOAT128_MATH)\n+  inline _Float128\n+  __complex_abs(__complex__ _Float128 __z) { return __builtin_cabsf128(__z); }\n \n-  // 26.2.8/5 log(__z): Returns the natural complex logarithm of __z.\n-  //                    The branch cut is along the negative axis.\n-  template<typename _Tp>\n-    inline complex<_Tp>\n-    __complex_log(const complex<_Tp>& __z)\n-    { return complex<_Tp>(log(std::abs(__z)), std::arg(__z)); }\n+  inline _Float128\n+  __complex_arg(__complex__ _Float128 __z) { return __builtin_cargf128(__z); }\n \n-#if _GLIBCXX_USE_C99_COMPLEX\n-  inline __complex__ float\n-  __complex_log(__complex__ float __z) { return __builtin_clogf(__z); }\n+  inline __complex__ _Float128\n+  __complex_cos(__complex__ _Float128 __z) { return __builtin_ccosf128(__z); }\n \n-  inline __complex__ double\n-  __complex_log(__complex__ double __z) { return __builtin_clog(__z); }\n+  inline __complex__ _Float128\n+  __complex_cosh(__complex__ _Float128 __z) { return __builtin_ccoshf128(__z); }\n \n-  inline __complex__ long double\n-  __complex_log(const __complex__ long double& __z)\n-  { return __builtin_clogl(__z); }\n+  inline __complex__ _Float128\n+  __complex_exp(__complex__ _Float128 __z) { return __builtin_cexpf128(__z); }\n \n-  template<typename _Tp>\n-    inline complex<_Tp>\n-    log(const complex<_Tp>& __z) { return __complex_log(__z.__rep()); }\n-#else\n-  template<typename _Tp>\n-    inline complex<_Tp>\n-    log(const complex<_Tp>& __z) { return __complex_log(__z); }\n-#endif\n+  inline __complex__ _Float128\n+  __complex_log(__complex__ _Float128 __z) { return __builtin_clogf128(__z); }\n \n-  template<typename _Tp>\n-    inline complex<_Tp>\n-    log10(const complex<_Tp>& __z)\n-    { return std::log(__z) / log(_Tp(10.0)); }\n+  inline __complex__ _Float128\n+  __complex_sin(__complex__ _Float128 __z) { return __builtin_csinf128(__z); }\n \n-  // 26.2.8/10 sin(__z): Returns the sine of __z.\n-  template<typename _Tp>\n-    inline complex<_Tp>\n-    __complex_sin(const complex<_Tp>& __z)\n-    {\n-      const _Tp __x = __z.real();\n-      const _Tp __y = __z.imag();\n-      return complex<_Tp>(sin(__x) * cosh(__y), cos(__x) * sinh(__y));\n-    }\n+  inline __complex__ _Float128\n+  __complex_sinh(__complex__ _Float128 __z) { return __builtin_csinhf128(__z); }\n \n-#if _GLIBCXX_USE_C99_COMPLEX\n-  inline __complex__ float\n-  __complex_sin(__complex__ float __z) { return __builtin_csinf(__z); }\n+  inline __complex__ _Float128\n+  __complex_sqrt(__complex__ _Float128 __z) { return __builtin_csqrtf128(__z); }\n \n-  inline __complex__ double\n-  __complex_sin(__complex__ double __z) { return __builtin_csin(__z); }\n+  inline __complex__ _Float128\n+  __complex_tan(__complex__ _Float128 __z) { return __builtin_ctanf128(__z); }\n \n-  inline __complex__ long double\n-  __complex_sin(const __complex__ long double& __z)\n-  { return __builtin_csinl(__z); }\n+  inline __complex__ _Float128\n+  __complex_tanh(__complex__ _Float128 __z) { return __builtin_ctanhf128(__z); }\n \n-  template<typename _Tp>\n-    inline complex<_Tp>\n-    sin(const complex<_Tp>& __z) { return __complex_sin(__z.__rep()); }\n-#else\n-  template<typename _Tp>\n-    inline complex<_Tp>\n-    sin(const complex<_Tp>& __z) { return __complex_sin(__z); }\n+  inline __complex__ _Float128\n+  __complex_pow(__complex__ _Float128 __x, __complex__ _Float128 __y)\n+  { return __builtin_cpowf128(__x, __y); }\n #endif\n \n-  // 26.2.8/11 sinh(__z): Returns the hyperbolic sine of __z.\n-  template<typename _Tp>\n-    inline complex<_Tp>\n-    __complex_sinh(const complex<_Tp>& __z)\n-    {\n-      const _Tp __x = __z.real();\n-      const _Tp  __y = __z.imag();\n-      return complex<_Tp>(sinh(__x) * cos(__y), cosh(__x) * sin(__y));\n-    }\n+#if defined(__STDCPP_BFLOAT16_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n+  inline __gnu_cxx::__bfloat16_t\n+  __complex_abs(__complex__ decltype(0.0bf16) __z)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_cabsf(__z)); }\n \n-#if _GLIBCXX_USE_C99_COMPLEX\n-  inline __complex__ float\n-  __complex_sinh(__complex__ float __z) { return __builtin_csinhf(__z); }\n+  inline __gnu_cxx::__bfloat16_t\n+  __complex_arg(__complex__ decltype(0.0bf16) __z)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_cargf(__z)); }\n \n-  inline __complex__ double\n-  __complex_sinh(__complex__ double __z) { return __builtin_csinh(__z); }\n+  inline __complex__ decltype(0.0bf16)\n+  __complex_cos(__complex__ decltype(0.0bf16) __z)\n+  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_ccosf(__z)); }\n \n-  inline __complex__ long double\n-  __complex_sinh(const __complex__ long double& __z)\n-  { return __builtin_csinhl(__z); }\n+  inline __complex__ decltype(0.0bf16)\n+  __complex_cosh(__complex__ decltype(0.0bf16) __z)\n+  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_ccoshf(__z)); }\n \n-  template<typename _Tp>\n-    inline complex<_Tp>\n-    sinh(const complex<_Tp>& __z) { return __complex_sinh(__z.__rep()); }\n-#else\n-  template<typename _Tp>\n-    inline complex<_Tp>\n-    sinh(const complex<_Tp>& __z) { return __complex_sinh(__z); }\n-#endif\n+  inline __complex__ decltype(0.0bf16)\n+  __complex_exp(__complex__ decltype(0.0bf16) __z)\n+  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_cexpf(__z)); }\n \n-  // 26.2.8/13 sqrt(__z): Returns the complex square root of __z.\n-  //                     The branch cut is on the negative axis.\n-  template<typename _Tp>\n-    complex<_Tp>\n-    __complex_sqrt(const complex<_Tp>& __z)\n-    {\n-      _Tp __x = __z.real();\n-      _Tp __y = __z.imag();\n+  inline __complex__ decltype(0.0bf16)\n+  __complex_log(__complex__ decltype(0.0bf16) __z)\n+  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_clogf(__z)); }\n \n-      if (__x == _Tp())\n-        {\n-          _Tp __t = sqrt(abs(__y) / 2);\n-          return complex<_Tp>(__t, __y < _Tp() ? -__t : __t);\n-        }\n-      else\n-        {\n-          _Tp __t = sqrt(2 * (std::abs(__z) + abs(__x)));\n-          _Tp __u = __t / 2;\n-          return __x > _Tp()\n-            ? complex<_Tp>(__u, __y / __t)\n-            : complex<_Tp>(abs(__y) / __t, __y < _Tp() ? -__u : __u);\n-        }\n-    }\n+  inline __complex__ decltype(0.0bf16)\n+  __complex_sin(__complex__ decltype(0.0bf16) __z)\n+  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_csinf(__z)); }\n \n-#if _GLIBCXX_USE_C99_COMPLEX\n-  inline __complex__ float\n-  __complex_sqrt(__complex__ float __z) { return __builtin_csqrtf(__z); }\n+  inline __complex__ decltype(0.0bf16)\n+  __complex_sinh(__complex__ decltype(0.0bf16) __z)\n+  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_csinhf(__z)); }\n \n-  inline __complex__ double\n-  __complex_sqrt(__complex__ double __z) { return __builtin_csqrt(__z); }\n+  inline __complex__ decltype(0.0bf16)\n+  __complex_sqrt(__complex__ decltype(0.0bf16) __z)\n+  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_csqrtf(__z)); }\n \n-  inline __complex__ long double\n-  __complex_sqrt(const __complex__ long double& __z)\n-  { return __builtin_csqrtl(__z); }\n+  inline __complex__ decltype(0.0bf16)\n+  __complex_tan(__complex__ decltype(0.0bf16) __z)\n+  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_ctanf(__z)); }\n \n-  template<typename _Tp>\n-    inline complex<_Tp>\n-    sqrt(const complex<_Tp>& __z) { return __complex_sqrt(__z.__rep()); }\n-#else\n-  template<typename _Tp>\n-    inline complex<_Tp>\n-    sqrt(const complex<_Tp>& __z) { return __complex_sqrt(__z); }\n-#endif\n+  inline __complex__ decltype(0.0bf16)\n+  __complex_tanh(__complex__ decltype(0.0bf16) __z)\n+  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_ctanhf(__z)); }\n \n-  // 26.2.8/14 tan(__z):  Return the complex tangent of __z.\n+  inline __complex__ decltype(0.0bf16)\n+  __complex_pow(__complex__ decltype(0.0bf16) __x,\n+\t\t__complex__ decltype(0.0bf16) __y)\n+  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_cpowf(__x,\n+\t\t\t\t\t\t\t\t      __y)); }\n+#endif\n+#endif\n \n+  // 26.2.7/3 abs(__z):  Returns the magnitude of __z.\n   template<typename _Tp>\n-    inline complex<_Tp>\n-    __complex_tan(const complex<_Tp>& __z)\n-    { return std::sin(__z) / std::cos(__z); }\n+    inline _Tp\n+    __complex_abs(const complex<_Tp>& __z)\n+    {\n+      _Tp __x = __z.real();\n+      _Tp __y = __z.imag();\n+      const _Tp __s = std::max(abs(__x), abs(__y));\n+      if (__s == _Tp())  // well ...\n+        return __s;\n+      __x /= __s;\n+      __y /= __s;\n+      return __s * sqrt(__x * __x + __y * __y);\n+    }\n \n #if _GLIBCXX_USE_C99_COMPLEX\n-  inline __complex__ float\n-  __complex_tan(__complex__ float __z) { return __builtin_ctanf(__z); }\n+  inline float\n+  __complex_abs(__complex__ float __z) { return __builtin_cabsf(__z); }\n \n-  inline __complex__ double\n-  __complex_tan(__complex__ double __z) { return __builtin_ctan(__z); }\n+  inline double\n+  __complex_abs(__complex__ double __z) { return __builtin_cabs(__z); }\n \n-  inline __complex__ long double\n-  __complex_tan(const __complex__ long double& __z)\n-  { return __builtin_ctanl(__z); }\n+  inline long double\n+  __complex_abs(const __complex__ long double& __z)\n+  { return __builtin_cabsl(__z); }\n \n   template<typename _Tp>\n-    inline complex<_Tp>\n-    tan(const complex<_Tp>& __z) { return __complex_tan(__z.__rep()); }\n+    inline _Tp\n+    abs(const complex<_Tp>& __z) { return __complex_abs(__z.__rep()); }\n #else\n   template<typename _Tp>\n-    inline complex<_Tp>\n-    tan(const complex<_Tp>& __z) { return __complex_tan(__z); }\n+    inline _Tp\n+    abs(const complex<_Tp>& __z) { return __complex_abs(__z); }\n #endif\n \n \n-  // 26.2.8/15 tanh(__z):  Returns the hyperbolic tangent of __z.\n-\n+  // 26.2.7/4: arg(__z): Returns the phase angle of __z.\n   template<typename _Tp>\n-    inline complex<_Tp>\n-    __complex_tanh(const complex<_Tp>& __z)\n-    { return std::sinh(__z) / std::cosh(__z); }\n+    inline _Tp\n+    __complex_arg(const complex<_Tp>& __z)\n+    { return  atan2(__z.imag(), __z.real()); }\n \n #if _GLIBCXX_USE_C99_COMPLEX\n-  inline __complex__ float\n-  __complex_tanh(__complex__ float __z) { return __builtin_ctanhf(__z); }\n+  inline float\n+  __complex_arg(__complex__ float __z) { return __builtin_cargf(__z); }\n \n-  inline __complex__ double\n-  __complex_tanh(__complex__ double __z) { return __builtin_ctanh(__z); }\n+  inline double\n+  __complex_arg(__complex__ double __z) { return __builtin_carg(__z); }\n \n-  inline __complex__ long double\n-  __complex_tanh(const __complex__ long double& __z)\n-  { return __builtin_ctanhl(__z); }\n+  inline long double\n+  __complex_arg(const __complex__ long double& __z)\n+  { return __builtin_cargl(__z); }\n \n   template<typename _Tp>\n-    inline complex<_Tp>\n-    tanh(const complex<_Tp>& __z) { return __complex_tanh(__z.__rep()); }\n+    inline _Tp\n+    arg(const complex<_Tp>& __z) { return __complex_arg(__z.__rep()); }\n #else\n   template<typename _Tp>\n-    inline complex<_Tp>\n-    tanh(const complex<_Tp>& __z) { return __complex_tanh(__z); }\n+    inline _Tp\n+    arg(const complex<_Tp>& __z) { return __complex_arg(__z); }\n #endif\n \n-\n-  // 26.2.8/9  pow(__x, __y): Returns the complex power base of __x\n-  //                          raised to the __y-th power.  The branch\n-  //                          cut is on the negative axis.\n-  template<typename _Tp>\n-    complex<_Tp>\n-    __complex_pow_unsigned(complex<_Tp> __x, unsigned __n)\n+  // 26.2.7/5: norm(__z) returns the squared magnitude of __z.\n+  //     As defined, norm() is -not- a norm is the common mathematical\n+  //     sense used in numerics.  The helper class _Norm_helper<> tries to\n+  //     distinguish between builtin floating point and the rest, so as\n+  //     to deliver an answer as close as possible to the real value.\n+  template<bool>\n+    struct _Norm_helper\n     {\n-      complex<_Tp> __y = __n % 2 ? __x : complex<_Tp>(1);\n+      template<typename _Tp>\n+        static inline _GLIBCXX20_CONSTEXPR _Tp _S_do_it(const complex<_Tp>& __z)\n+        {\n+          const _Tp __x = __z.real();\n+          const _Tp __y = __z.imag();\n+          return __x * __x + __y * __y;\n+        }\n+    };\n \n-      while (__n >>= 1)\n+  template<>\n+    struct _Norm_helper<true>\n+    {\n+      template<typename _Tp>\n+        static inline _GLIBCXX20_CONSTEXPR _Tp _S_do_it(const complex<_Tp>& __z)\n         {\n-          __x *= __x;\n-          if (__n % 2)\n-            __y *= __x;\n+          //_Tp __res = std::abs(__z);\n+          //return __res * __res;\n+          const _Tp __x = __z.real();\n+          const _Tp __y = __z.imag();\n+          return __x * __x + __y * __y;\n         }\n+    };\n \n-      return __y;\n+  template<typename _Tp>\n+    inline _GLIBCXX20_CONSTEXPR _Tp\n+    norm(const complex<_Tp>& __z)\n+    {\n+      return _Norm_helper<__is_floating<_Tp>::__value\n+\t&& !_GLIBCXX_FAST_MATH>::_S_do_it(__z);\n     }\n \n-  // In C++11 mode we used to implement the resolution of\n-  // DR 844. complex pow return type is ambiguous.\n-  // thus the following overload was disabled in that mode.  However, doing\n-  // that causes all sorts of issues, see, for example:\n-  //   http://gcc.gnu.org/ml/libstdc++/2013-01/msg00058.html\n-  // and also PR57974.\n   template<typename _Tp>\n     inline complex<_Tp>\n-    pow(const complex<_Tp>& __z, int __n)\n+    polar(const _Tp& __rho, const _Tp& __theta)\n     {\n-      return __n < 0\n-\t? complex<_Tp>(1) / std::__complex_pow_unsigned(__z, -(unsigned)__n)\n-        : std::__complex_pow_unsigned(__z, __n);\n+      __glibcxx_assert( __rho >= 0 );\n+      return complex<_Tp>(__rho * cos(__theta), __rho * sin(__theta));\n     }\n \n   template<typename _Tp>\n-    complex<_Tp>\n-    pow(const complex<_Tp>& __x, const _Tp& __y)\n-    {\n-#if ! _GLIBCXX_USE_C99_COMPLEX\n-      if (__x == _Tp())\n-\treturn _Tp();\n-#endif\n-      if (__x.imag() == _Tp() && __x.real() > _Tp())\n-        return pow(__x.real(), __y);\n+    inline _GLIBCXX20_CONSTEXPR complex<_Tp>\n+    conj(const complex<_Tp>& __z)\n+    { return complex<_Tp>(__z.real(), -__z.imag()); }\n \n-      complex<_Tp> __t = std::log(__x);\n-      return std::polar<_Tp>(exp(__y * __t.real()), __y * __t.imag());\n-    }\n+  // Transcendentals\n \n+  // 26.2.8/1 cos(__z):  Returns the cosine of __z.\n   template<typename _Tp>\n     inline complex<_Tp>\n-    __complex_pow(const complex<_Tp>& __x, const complex<_Tp>& __y)\n-    { return __x == _Tp() ? _Tp() : std::exp(__y * std::log(__x)); }\n+    __complex_cos(const complex<_Tp>& __z)\n+    {\n+      const _Tp __x = __z.real();\n+      const _Tp __y = __z.imag();\n+      return complex<_Tp>(cos(__x) * cosh(__y), -sin(__x) * sinh(__y));\n+    }\n \n #if _GLIBCXX_USE_C99_COMPLEX\n   inline __complex__ float\n-  __complex_pow(__complex__ float __x, __complex__ float __y)\n-  { return __builtin_cpowf(__x, __y); }\n+  __complex_cos(__complex__ float __z) { return __builtin_ccosf(__z); }\n \n   inline __complex__ double\n-  __complex_pow(__complex__ double __x, __complex__ double __y)\n-  { return __builtin_cpow(__x, __y); }\n+  __complex_cos(__complex__ double __z) { return __builtin_ccos(__z); }\n \n   inline __complex__ long double\n-  __complex_pow(const __complex__ long double& __x,\n-\t\tconst __complex__ long double& __y)\n-  { return __builtin_cpowl(__x, __y); }\n+  __complex_cos(const __complex__ long double& __z)\n+  { return __builtin_ccosl(__z); }\n \n   template<typename _Tp>\n     inline complex<_Tp>\n-    pow(const complex<_Tp>& __x, const complex<_Tp>& __y)\n-    { return __complex_pow(__x.__rep(), __y.__rep()); }\n+    cos(const complex<_Tp>& __z) { return __complex_cos(__z.__rep()); }\n #else\n   template<typename _Tp>\n     inline complex<_Tp>\n-    pow(const complex<_Tp>& __x, const complex<_Tp>& __y)\n-    { return __complex_pow(__x, __y); }\n+    cos(const complex<_Tp>& __z) { return __complex_cos(__z); }\n #endif\n \n+  // 26.2.8/2 cosh(__z): Returns the hyperbolic cosine of __z.\n   template<typename _Tp>\n     inline complex<_Tp>\n-    pow(const _Tp& __x, const complex<_Tp>& __y)\n+    __complex_cosh(const complex<_Tp>& __z)\n     {\n-      return __x > _Tp() ? std::polar<_Tp>(pow(__x, __y.real()),\n-\t\t\t\t\t   __y.imag() * log(__x))\n-\t                 : std::pow(complex<_Tp>(__x), __y);\n+      const _Tp __x = __z.real();\n+      const _Tp __y = __z.imag();\n+      return complex<_Tp>(cosh(__x) * cos(__y), sinh(__x) * sin(__y));\n     }\n \n #if _GLIBCXX_USE_C99_COMPLEX\n-#if defined(__STDCPP_FLOAT16_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n-  inline _Float16\n-  __complex_abs(__complex__ _Float16 __z)\n-  { return _Float16(__builtin_cabsf(__z)); }\n-\n-  inline _Float16\n-  __complex_arg(__complex__ _Float16 __z)\n-  { return _Float16(__builtin_cargf(__z)); }\n-\n-  inline __complex__ _Float16\n-  __complex_cos(__complex__ _Float16 __z)\n-  { return static_cast<__complex__ _Float16>(__builtin_ccosf(__z)); }\n-\n-  inline __complex__ _Float16\n-  __complex_cosh(__complex__ _Float16 __z)\n-  { return static_cast<__complex__ _Float16>(__builtin_ccoshf(__z)); }\n-\n-  inline __complex__ _Float16\n-  __complex_exp(__complex__ _Float16 __z)\n-  { return static_cast<__complex__ _Float16>(__builtin_cexpf(__z)); }\n-\n-  inline __complex__ _Float16\n-  __complex_log(__complex__ _Float16 __z)\n-  { return static_cast<__complex__ _Float16>(__builtin_clogf(__z)); }\n-\n-  inline __complex__ _Float16\n-  __complex_sin(__complex__ _Float16 __z)\n-  { return static_cast<__complex__ _Float16>(__builtin_csinf(__z)); }\n-\n-  inline __complex__ _Float16\n-  __complex_sinh(__complex__ _Float16 __z)\n-  { return static_cast<__complex__ _Float16>(__builtin_csinhf(__z)); }\n-\n-  inline __complex__ _Float16\n-  __complex_sqrt(__complex__ _Float16 __z)\n-  { return static_cast<__complex__ _Float16>(__builtin_csqrtf(__z)); }\n+  inline __complex__ float\n+  __complex_cosh(__complex__ float __z) { return __builtin_ccoshf(__z); }\n \n-  inline __complex__ _Float16\n-  __complex_tan(__complex__ _Float16 __z)\n-  { return static_cast<__complex__ _Float16>(__builtin_ctanf(__z)); }\n+  inline __complex__ double\n+  __complex_cosh(__complex__ double __z) { return __builtin_ccosh(__z); }\n \n-  inline __complex__ _Float16\n-  __complex_tanh(__complex__ _Float16 __z)\n-  { return static_cast<__complex__ _Float16>(__builtin_ctanhf(__z)); }\n+  inline __complex__ long double\n+  __complex_cosh(const __complex__ long double& __z)\n+  { return __builtin_ccoshl(__z); }\n \n-  inline __complex__ _Float16\n-  __complex_pow(__complex__ _Float16 __x, __complex__ _Float16 __y)\n-  { return static_cast<__complex__ _Float16>(__builtin_cpowf(__x, __y)); }\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    cosh(const complex<_Tp>& __z) { return __complex_cosh(__z.__rep()); }\n+#else\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    cosh(const complex<_Tp>& __z) { return __complex_cosh(__z); }\n #endif\n \n-#if defined(__STDCPP_FLOAT32_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n-  inline _Float32\n-  __complex_abs(__complex__ _Float32 __z) { return __builtin_cabsf(__z); }\n-\n-  inline _Float32\n-  __complex_arg(__complex__ _Float32 __z) { return __builtin_cargf(__z); }\n-\n-  inline __complex__ _Float32\n-  __complex_cos(__complex__ _Float32 __z) { return __builtin_ccosf(__z); }\n-\n-  inline __complex__ _Float32\n-  __complex_cosh(__complex__ _Float32 __z) { return __builtin_ccoshf(__z); }\n-\n-  inline __complex__ _Float32\n-  __complex_exp(__complex__ _Float32 __z) { return __builtin_cexpf(__z); }\n-\n-  inline __complex__ _Float32\n-  __complex_log(__complex__ _Float32 __z) { return __builtin_clogf(__z); }\n-\n-  inline __complex__ _Float32\n-  __complex_sin(__complex__ _Float32 __z) { return __builtin_csinf(__z); }\n-\n-  inline __complex__ _Float32\n-  __complex_sinh(__complex__ _Float32 __z) { return __builtin_csinhf(__z); }\n+  // 26.2.8/3 exp(__z): Returns the complex base e exponential of x\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    __complex_exp(const complex<_Tp>& __z)\n+    { return std::polar<_Tp>(exp(__z.real()), __z.imag()); }\n \n-  inline __complex__ _Float32\n-  __complex_sqrt(__complex__ _Float32 __z) { return __builtin_csqrtf(__z); }\n+#if _GLIBCXX_USE_C99_COMPLEX\n+  inline __complex__ float\n+  __complex_exp(__complex__ float __z) { return __builtin_cexpf(__z); }\n \n-  inline __complex__ _Float32\n-  __complex_tan(__complex__ _Float32 __z) { return __builtin_ctanf(__z); }\n+  inline __complex__ double\n+  __complex_exp(__complex__ double __z) { return __builtin_cexp(__z); }\n \n-  inline __complex__ _Float32\n-  __complex_tanh(__complex__ _Float32 __z) { return __builtin_ctanhf(__z); }\n+  inline __complex__ long double\n+  __complex_exp(const __complex__ long double& __z)\n+  { return __builtin_cexpl(__z); }\n \n-  inline __complex__ _Float32\n-  __complex_pow(__complex__ _Float32 __x, __complex__ _Float32 __y)\n-  { return __builtin_cpowf(__x, __y); }\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    exp(const complex<_Tp>& __z) { return __complex_exp(__z.__rep()); }\n+#else\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    exp(const complex<_Tp>& __z) { return __complex_exp(__z); }\n #endif\n \n-#if defined(__STDCPP_FLOAT64_T__) && defined(_GLIBCXX_DOUBLE_IS_IEEE_BINARY64)\n-  inline _Float64\n-  __complex_abs(__complex__ _Float64 __z) { return __builtin_cabs(__z); }\n-\n-  inline _Float64\n-  __complex_arg(__complex__ _Float64 __z) { return __builtin_carg(__z); }\n+  // 26.2.8/5 log(__z): Returns the natural complex logarithm of __z.\n+  //                    The branch cut is along the negative axis.\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    __complex_log(const complex<_Tp>& __z)\n+    { return complex<_Tp>(log(std::abs(__z)), std::arg(__z)); }\n \n-  inline __complex__ _Float64\n-  __complex_cos(__complex__ _Float64 __z) { return __builtin_ccos(__z); }\n+#if _GLIBCXX_USE_C99_COMPLEX\n+  inline __complex__ float\n+  __complex_log(__complex__ float __z) { return __builtin_clogf(__z); }\n \n-  inline __complex__ _Float64\n-  __complex_cosh(__complex__ _Float64 __z) { return __builtin_ccosh(__z); }\n+  inline __complex__ double\n+  __complex_log(__complex__ double __z) { return __builtin_clog(__z); }\n \n-  inline __complex__ _Float64\n-  __complex_exp(__complex__ _Float64 __z) { return __builtin_cexp(__z); }\n+  inline __complex__ long double\n+  __complex_log(const __complex__ long double& __z)\n+  { return __builtin_clogl(__z); }\n \n-  inline __complex__ _Float64\n-  __complex_log(__complex__ _Float64 __z) { return __builtin_clog(__z); }\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    log(const complex<_Tp>& __z) { return __complex_log(__z.__rep()); }\n+#else\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    log(const complex<_Tp>& __z) { return __complex_log(__z); }\n+#endif\n \n-  inline __complex__ _Float64\n-  __complex_sin(__complex__ _Float64 __z) { return __builtin_csin(__z); }\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    log10(const complex<_Tp>& __z)\n+    { return std::log(__z) / log(_Tp(10.0)); }\n \n-  inline __complex__ _Float64\n-  __complex_sinh(__complex__ _Float64 __z) { return __builtin_csinh(__z); }\n+  // 26.2.8/10 sin(__z): Returns the sine of __z.\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    __complex_sin(const complex<_Tp>& __z)\n+    {\n+      const _Tp __x = __z.real();\n+      const _Tp __y = __z.imag();\n+      return complex<_Tp>(sin(__x) * cosh(__y), cos(__x) * sinh(__y));\n+    }\n \n-  inline __complex__ _Float64\n-  __complex_sqrt(__complex__ _Float64 __z) { return __builtin_csqrt(__z); }\n+#if _GLIBCXX_USE_C99_COMPLEX\n+  inline __complex__ float\n+  __complex_sin(__complex__ float __z) { return __builtin_csinf(__z); }\n \n-  inline __complex__ _Float64\n-  __complex_tan(__complex__ _Float64 __z) { return __builtin_ctan(__z); }\n+  inline __complex__ double\n+  __complex_sin(__complex__ double __z) { return __builtin_csin(__z); }\n \n-  inline __complex__ _Float64\n-  __complex_tanh(__complex__ _Float64 __z) { return __builtin_ctanh(__z); }\n+  inline __complex__ long double\n+  __complex_sin(const __complex__ long double& __z)\n+  { return __builtin_csinl(__z); }\n \n-  inline __complex__ _Float64\n-  __complex_pow(__complex__ _Float64 __x, __complex__ _Float64 __y)\n-  { return __builtin_cpow(__x, __y); }\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    sin(const complex<_Tp>& __z) { return __complex_sin(__z.__rep()); }\n+#else\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    sin(const complex<_Tp>& __z) { return __complex_sin(__z); }\n #endif\n \n-#if defined(__STDCPP_FLOAT128_T__) && defined(_GLIBCXX_LDOUBLE_IS_IEEE_BINARY128)\n-  inline _Float128\n-  __complex_abs(__complex__ _Float128 __z) { return __builtin_cabsl(__z); }\n+  // 26.2.8/11 sinh(__z): Returns the hyperbolic sine of __z.\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    __complex_sinh(const complex<_Tp>& __z)\n+    {\n+      const _Tp __x = __z.real();\n+      const _Tp  __y = __z.imag();\n+      return complex<_Tp>(sinh(__x) * cos(__y), cosh(__x) * sin(__y));\n+    }\n \n-  inline _Float128\n-  __complex_arg(__complex__ _Float128 __z) { return __builtin_cargl(__z); }\n+#if _GLIBCXX_USE_C99_COMPLEX\n+  inline __complex__ float\n+  __complex_sinh(__complex__ float __z) { return __builtin_csinhf(__z); }\n \n-  inline __complex__ _Float128\n-  __complex_cos(__complex__ _Float128 __z) { return __builtin_ccosl(__z); }\n+  inline __complex__ double\n+  __complex_sinh(__complex__ double __z) { return __builtin_csinh(__z); }\n \n-  inline __complex__ _Float128\n-  __complex_cosh(__complex__ _Float128 __z) { return __builtin_ccoshl(__z); }\n+  inline __complex__ long double\n+  __complex_sinh(const __complex__ long double& __z)\n+  { return __builtin_csinhl(__z); }\n \n-  inline __complex__ _Float128\n-  __complex_exp(__complex__ _Float128 __z) { return __builtin_cexpl(__z); }\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    sinh(const complex<_Tp>& __z) { return __complex_sinh(__z.__rep()); }\n+#else\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    sinh(const complex<_Tp>& __z) { return __complex_sinh(__z); }\n+#endif\n \n-  inline __complex__ _Float128\n-  __complex_log(__complex__ _Float128 __z) { return __builtin_clogl(__z); }\n+  // 26.2.8/13 sqrt(__z): Returns the complex square root of __z.\n+  //                     The branch cut is on the negative axis.\n+  template<typename _Tp>\n+    complex<_Tp>\n+    __complex_sqrt(const complex<_Tp>& __z)\n+    {\n+      _Tp __x = __z.real();\n+      _Tp __y = __z.imag();\n \n-  inline __complex__ _Float128\n-  __complex_sin(__complex__ _Float128 __z) { return __builtin_csinl(__z); }\n+      if (__x == _Tp())\n+        {\n+          _Tp __t = sqrt(abs(__y) / 2);\n+          return complex<_Tp>(__t, __y < _Tp() ? -__t : __t);\n+        }\n+      else\n+        {\n+          _Tp __t = sqrt(2 * (std::abs(__z) + abs(__x)));\n+          _Tp __u = __t / 2;\n+          return __x > _Tp()\n+            ? complex<_Tp>(__u, __y / __t)\n+            : complex<_Tp>(abs(__y) / __t, __y < _Tp() ? -__u : __u);\n+        }\n+    }\n \n-  inline __complex__ _Float128\n-  __complex_sinh(__complex__ _Float128 __z) { return __builtin_csinhl(__z); }\n+#if _GLIBCXX_USE_C99_COMPLEX\n+  inline __complex__ float\n+  __complex_sqrt(__complex__ float __z) { return __builtin_csqrtf(__z); }\n \n-  inline __complex__ _Float128\n-  __complex_sqrt(__complex__ _Float128 __z) { return __builtin_csqrtl(__z); }\n+  inline __complex__ double\n+  __complex_sqrt(__complex__ double __z) { return __builtin_csqrt(__z); }\n \n-  inline __complex__ _Float128\n-  __complex_tan(__complex__ _Float128 __z) { return __builtin_ctanl(__z); }\n+  inline __complex__ long double\n+  __complex_sqrt(const __complex__ long double& __z)\n+  { return __builtin_csqrtl(__z); }\n \n-  inline __complex__ _Float128\n-  __complex_tanh(__complex__ _Float128 __z) { return __builtin_ctanhl(__z); }\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    sqrt(const complex<_Tp>& __z) { return __complex_sqrt(__z.__rep()); }\n+#else\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    sqrt(const complex<_Tp>& __z) { return __complex_sqrt(__z); }\n+#endif\n \n-  inline __complex__ _Float128\n-  __complex_pow(__complex__ _Float128 __x, __complex__ _Float128 __y)\n-  { return __builtin_cpowl(__x, __y); }\n-#elif defined(__STDCPP_FLOAT128_T__) && defined(_GLIBCXX_HAVE_FLOAT128_MATH)\n-  inline _Float128\n-  __complex_abs(__complex__ _Float128 __z) { return __builtin_cabsf128(__z); }\n+  // 26.2.8/14 tan(__z):  Return the complex tangent of __z.\n \n-  inline _Float128\n-  __complex_arg(__complex__ _Float128 __z) { return __builtin_cargf128(__z); }\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    __complex_tan(const complex<_Tp>& __z)\n+    { return std::sin(__z) / std::cos(__z); }\n \n-  inline __complex__ _Float128\n-  __complex_cos(__complex__ _Float128 __z) { return __builtin_ccosf128(__z); }\n+#if _GLIBCXX_USE_C99_COMPLEX\n+  inline __complex__ float\n+  __complex_tan(__complex__ float __z) { return __builtin_ctanf(__z); }\n \n-  inline __complex__ _Float128\n-  __complex_cosh(__complex__ _Float128 __z) { return __builtin_ccoshf128(__z); }\n+  inline __complex__ double\n+  __complex_tan(__complex__ double __z) { return __builtin_ctan(__z); }\n \n-  inline __complex__ _Float128\n-  __complex_exp(__complex__ _Float128 __z) { return __builtin_cexpf128(__z); }\n+  inline __complex__ long double\n+  __complex_tan(const __complex__ long double& __z)\n+  { return __builtin_ctanl(__z); }\n \n-  inline __complex__ _Float128\n-  __complex_log(__complex__ _Float128 __z) { return __builtin_clogf128(__z); }\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    tan(const complex<_Tp>& __z) { return __complex_tan(__z.__rep()); }\n+#else\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    tan(const complex<_Tp>& __z) { return __complex_tan(__z); }\n+#endif\n \n-  inline __complex__ _Float128\n-  __complex_sin(__complex__ _Float128 __z) { return __builtin_csinf128(__z); }\n \n-  inline __complex__ _Float128\n-  __complex_sinh(__complex__ _Float128 __z) { return __builtin_csinhf128(__z); }\n+  // 26.2.8/15 tanh(__z):  Returns the hyperbolic tangent of __z.\n \n-  inline __complex__ _Float128\n-  __complex_sqrt(__complex__ _Float128 __z) { return __builtin_csqrtf128(__z); }\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    __complex_tanh(const complex<_Tp>& __z)\n+    { return std::sinh(__z) / std::cosh(__z); }\n \n-  inline __complex__ _Float128\n-  __complex_tan(__complex__ _Float128 __z) { return __builtin_ctanf128(__z); }\n+#if _GLIBCXX_USE_C99_COMPLEX\n+  inline __complex__ float\n+  __complex_tanh(__complex__ float __z) { return __builtin_ctanhf(__z); }\n \n-  inline __complex__ _Float128\n-  __complex_tanh(__complex__ _Float128 __z) { return __builtin_ctanhf128(__z); }\n+  inline __complex__ double\n+  __complex_tanh(__complex__ double __z) { return __builtin_ctanh(__z); }\n \n-  inline __complex__ _Float128\n-  __complex_pow(__complex__ _Float128 __x, __complex__ _Float128 __y)\n-  { return __builtin_cpowf128(__x, __y); }\n+  inline __complex__ long double\n+  __complex_tanh(const __complex__ long double& __z)\n+  { return __builtin_ctanhl(__z); }\n+\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    tanh(const complex<_Tp>& __z) { return __complex_tanh(__z.__rep()); }\n+#else\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    tanh(const complex<_Tp>& __z) { return __complex_tanh(__z); }\n #endif\n \n-#if defined(__STDCPP_BFLOAT16_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n-  inline __gnu_cxx::__bfloat16_t\n-  __complex_abs(__complex__ decltype(0.0bf16) __z)\n-  { return __gnu_cxx::__bfloat16_t(__builtin_cabsf(__z)); }\n \n-  inline __gnu_cxx::__bfloat16_t\n-  __complex_arg(__complex__ decltype(0.0bf16) __z)\n-  { return __gnu_cxx::__bfloat16_t(__builtin_cargf(__z)); }\n+  // 26.2.8/9  pow(__x, __y): Returns the complex power base of __x\n+  //                          raised to the __y-th power.  The branch\n+  //                          cut is on the negative axis.\n+  template<typename _Tp>\n+    complex<_Tp>\n+    __complex_pow_unsigned(complex<_Tp> __x, unsigned __n)\n+    {\n+      complex<_Tp> __y = __n % 2 ? __x : complex<_Tp>(1);\n \n-  inline __complex__ decltype(0.0bf16)\n-  __complex_cos(__complex__ decltype(0.0bf16) __z)\n-  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_ccosf(__z)); }\n+      while (__n >>= 1)\n+        {\n+          __x *= __x;\n+          if (__n % 2)\n+            __y *= __x;\n+        }\n \n-  inline __complex__ decltype(0.0bf16)\n-  __complex_cosh(__complex__ decltype(0.0bf16) __z)\n-  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_ccoshf(__z)); }\n+      return __y;\n+    }\n \n-  inline __complex__ decltype(0.0bf16)\n-  __complex_exp(__complex__ decltype(0.0bf16) __z)\n-  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_cexpf(__z)); }\n+  // In C++11 mode we used to implement the resolution of\n+  // DR 844. complex pow return type is ambiguous.\n+  // thus the following overload was disabled in that mode.  However, doing\n+  // that causes all sorts of issues, see, for example:\n+  //   http://gcc.gnu.org/ml/libstdc++/2013-01/msg00058.html\n+  // and also PR57974.\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    pow(const complex<_Tp>& __z, int __n)\n+    {\n+      return __n < 0\n+\t? complex<_Tp>(1) / std::__complex_pow_unsigned(__z, -(unsigned)__n)\n+        : std::__complex_pow_unsigned(__z, __n);\n+    }\n \n-  inline __complex__ decltype(0.0bf16)\n-  __complex_log(__complex__ decltype(0.0bf16) __z)\n-  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_clogf(__z)); }\n+  template<typename _Tp>\n+    complex<_Tp>\n+    pow(const complex<_Tp>& __x, const _Tp& __y)\n+    {\n+#if ! _GLIBCXX_USE_C99_COMPLEX\n+      if (__x == _Tp())\n+\treturn _Tp();\n+#endif\n+      if (__x.imag() == _Tp() && __x.real() > _Tp())\n+        return pow(__x.real(), __y);\n \n-  inline __complex__ decltype(0.0bf16)\n-  __complex_sin(__complex__ decltype(0.0bf16) __z)\n-  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_csinf(__z)); }\n+      complex<_Tp> __t = std::log(__x);\n+      return std::polar<_Tp>(exp(__y * __t.real()), __y * __t.imag());\n+    }\n \n-  inline __complex__ decltype(0.0bf16)\n-  __complex_sinh(__complex__ decltype(0.0bf16) __z)\n-  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_csinhf(__z)); }\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    __complex_pow(const complex<_Tp>& __x, const complex<_Tp>& __y)\n+    { return __x == _Tp() ? _Tp() : std::exp(__y * std::log(__x)); }\n \n-  inline __complex__ decltype(0.0bf16)\n-  __complex_sqrt(__complex__ decltype(0.0bf16) __z)\n-  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_csqrtf(__z)); }\n+#if _GLIBCXX_USE_C99_COMPLEX\n+  inline __complex__ float\n+  __complex_pow(__complex__ float __x, __complex__ float __y)\n+  { return __builtin_cpowf(__x, __y); }\n \n-  inline __complex__ decltype(0.0bf16)\n-  __complex_tan(__complex__ decltype(0.0bf16) __z)\n-  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_ctanf(__z)); }\n+  inline __complex__ double\n+  __complex_pow(__complex__ double __x, __complex__ double __y)\n+  { return __builtin_cpow(__x, __y); }\n \n-  inline __complex__ decltype(0.0bf16)\n-  __complex_tanh(__complex__ decltype(0.0bf16) __z)\n-  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_ctanhf(__z)); }\n+  inline __complex__ long double\n+  __complex_pow(const __complex__ long double& __x,\n+\t\tconst __complex__ long double& __y)\n+  { return __builtin_cpowl(__x, __y); }\n \n-  inline __complex__ decltype(0.0bf16)\n-  __complex_pow(__complex__ decltype(0.0bf16) __x,\n-\t\t__complex__ decltype(0.0bf16) __y)\n-  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_cpowf(__x,\n-\t\t\t\t\t\t\t\t      __y)); }\n-#endif\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    pow(const complex<_Tp>& __x, const complex<_Tp>& __y)\n+    { return __complex_pow(__x.__rep(), __y.__rep()); }\n+#else\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    pow(const complex<_Tp>& __x, const complex<_Tp>& __y)\n+    { return __complex_pow(__x, __y); }\n #endif\n \n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    pow(const _Tp& __x, const complex<_Tp>& __y)\n+    {\n+      return __x > _Tp() ? std::polar<_Tp>(pow(__x, __y.real()),\n+\t\t\t\t\t   __y.imag() * log(__x))\n+\t                 : std::pow(complex<_Tp>(__x), __y);\n+    }\n+\n   /// 26.2.3  complex specializations\n   /// complex<float> specialization\n   template<>\n@@ -1835,7 +1835,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n #endif\n \n   template<typename _Tp>\n-    requires(__complex_type<_Tp>::type)\n+    requires requires { typename __complex_type<_Tp>::type; }\n     class complex<_Tp>\n     {\n     public:\n@@ -1953,73 +1953,229 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     };\n #endif\n \n-#if __cplusplus <= 202002L\n-  // These bits have to be at the end of this file, so that the\n-  // specializations have all been defined.\n-  inline _GLIBCXX_CONSTEXPR\n-  complex<float>::complex(const complex<double>& __z)\n-  : _M_value(__z.__rep()) { }\n+#if __cplusplus <= 202002L\n+  // These bits have to be at the end of this file, so that the\n+  // specializations have all been defined.\n+  inline _GLIBCXX_CONSTEXPR\n+  complex<float>::complex(const complex<double>& __z)\n+  : _M_value(__z.__rep()) { }\n+\n+  inline _GLIBCXX_CONSTEXPR\n+  complex<float>::complex(const complex<long double>& __z)\n+  : _M_value(__z.__rep()) { }\n+\n+  inline _GLIBCXX_CONSTEXPR\n+  complex<double>::complex(const complex<long double>& __z)\n+  : _M_value(__z.__rep()) { }\n+#endif\n+\n+  // Inhibit implicit instantiations for required instantiations,\n+  // which are defined via explicit instantiations elsewhere.\n+  // NB:  This syntax is a GNU extension.\n+#if _GLIBCXX_EXTERN_TEMPLATE\n+  extern template istream& operator>>(istream&, complex<float>&);\n+  extern template ostream& operator<<(ostream&, const complex<float>&);\n+  extern template istream& operator>>(istream&, complex<double>&);\n+  extern template ostream& operator<<(ostream&, const complex<double>&);\n+  extern template istream& operator>>(istream&, complex<long double>&);\n+  extern template ostream& operator<<(ostream&, const complex<long double>&);\n+\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+  extern template wistream& operator>>(wistream&, complex<float>&);\n+  extern template wostream& operator<<(wostream&, const complex<float>&);\n+  extern template wistream& operator>>(wistream&, complex<double>&);\n+  extern template wostream& operator<<(wostream&, const complex<double>&);\n+  extern template wistream& operator>>(wistream&, complex<long double>&);\n+  extern template wostream& operator<<(wostream&, const complex<long double>&);\n+#endif\n+#endif\n+\n+  /// @} group complex_numbers\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace\n+\n+#if __cplusplus >= 201103L\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  // Forward declarations.\n+  template<typename _Tp> std::complex<_Tp> acos(const std::complex<_Tp>&);\n+  template<typename _Tp> std::complex<_Tp> asin(const std::complex<_Tp>&);\n+  template<typename _Tp> std::complex<_Tp> atan(const std::complex<_Tp>&);\n+\n+  template<typename _Tp> std::complex<_Tp> acosh(const std::complex<_Tp>&);\n+  template<typename _Tp> std::complex<_Tp> asinh(const std::complex<_Tp>&);\n+  template<typename _Tp> std::complex<_Tp> atanh(const std::complex<_Tp>&);\n+  // DR 595.\n+  template<typename _Tp> _Tp               fabs(const std::complex<_Tp>&);\n+\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    __complex_acos(const std::complex<_Tp>& __z)\n+    {\n+      const std::complex<_Tp> __t = std::asin(__z);\n+      const _Tp __pi_2 = 1.5707963267948966192313216916397514L;\n+      return std::complex<_Tp>(__pi_2 - __t.real(), -__t.imag());\n+    }\n+\n+#if _GLIBCXX_USE_C99_COMPLEX_TR1\n+#if defined(__STDCPP_FLOAT16_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n+  inline __complex__ _Float16\n+  __complex_acos(__complex__ _Float16 __z)\n+  { return static_cast<__complex__ _Float16>(__builtin_cacosf(__z)); }\n+\n+  inline __complex__ _Float16\n+  __complex_asin(__complex__ _Float16 __z)\n+  { return static_cast<__complex__ _Float16>(__builtin_casinf(__z)); }\n+\n+  inline __complex__ _Float16\n+  __complex_atan(__complex__ _Float16 __z)\n+  { return static_cast<__complex__ _Float16>(__builtin_catanf(__z)); }\n+\n+  inline __complex__ _Float16\n+  __complex_acosh(__complex__ _Float16 __z)\n+  { return static_cast<__complex__ _Float16>(__builtin_cacoshf(__z)); }\n+\n+  inline __complex__ _Float16\n+  __complex_asinh(__complex__ _Float16 __z)\n+  { return static_cast<__complex__ _Float16>(__builtin_casinhf(__z)); }\n+\n+  inline __complex__ _Float16\n+  __complex_atanh(__complex__ _Float16 __z)\n+  { return static_cast<__complex__ _Float16>(__builtin_catanhf(__z)); }\n+#endif\n+\n+#if defined(__STDCPP_FLOAT32_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n+  inline __complex__ _Float32\n+  __complex_acos(__complex__ _Float32 __z)\n+  { return __builtin_cacosf(__z); }\n+\n+  inline __complex__ _Float32\n+  __complex_asin(__complex__ _Float32 __z)\n+  { return __builtin_casinf(__z); }\n+\n+  inline __complex__ _Float32\n+  __complex_atan(__complex__ _Float32 __z)\n+  { return __builtin_catanf(__z); }\n+\n+  inline __complex__ _Float32\n+  __complex_acosh(__complex__ _Float32 __z)\n+  { return __builtin_cacoshf(__z); }\n+\n+  inline __complex__ _Float32\n+  __complex_asinh(__complex__ _Float32 __z)\n+  { return __builtin_casinhf(__z); }\n+\n+  inline __complex__ _Float32\n+  __complex_atanh(__complex__ _Float32 __z)\n+  { return __builtin_catanhf(__z); }\n+#endif\n+\n+#if defined(__STDCPP_FLOAT64_T__) && defined(_GLIBCXX_DOUBLE_IS_IEEE_BINARY64)\n+  inline __complex__ _Float64\n+  __complex_acos(__complex__ _Float64 __z)\n+  { return __builtin_cacos(__z); }\n+\n+  inline __complex__ _Float64\n+  __complex_asin(__complex__ _Float64 __z)\n+  { return __builtin_casin(__z); }\n+\n+  inline __complex__ _Float64\n+  __complex_atan(__complex__ _Float64 __z)\n+  { return __builtin_catan(__z); }\n+\n+  inline __complex__ _Float64\n+  __complex_acosh(__complex__ _Float64 __z)\n+  { return __builtin_cacosh(__z); }\n+\n+  inline __complex__ _Float64\n+  __complex_asinh(__complex__ _Float64 __z)\n+  { return __builtin_casinh(__z); }\n+\n+  inline __complex__ _Float64\n+  __complex_atanh(__complex__ _Float64 __z)\n+  { return __builtin_catanh(__z); }\n+#endif\n+\n+#if defined(__STDCPP_FLOAT128_T__) && defined(_GLIBCXX_LDOUBLE_IS_IEEE_BINARY128)\n+  inline __complex__ _Float128\n+  __complex_acos(__complex__ _Float128 __z)\n+  { return __builtin_cacosl(__z); }\n+\n+  inline __complex__ _Float128\n+  __complex_asin(__complex__ _Float128 __z)\n+  { return __builtin_casinl(__z); }\n+\n+  inline __complex__ _Float128\n+  __complex_atan(__complex__ _Float128 __z)\n+  { return __builtin_catanl(__z); }\n+\n+  inline __complex__ _Float128\n+  __complex_acosh(__complex__ _Float128 __z)\n+  { return __builtin_cacoshl(__z); }\n+\n+  inline __complex__ _Float128\n+  __complex_asinh(__complex__ _Float128 __z)\n+  { return __builtin_casinhl(__z); }\n+\n+  inline __complex__ _Float128\n+  __complex_atanh(__complex__ _Float128 __z)\n+  { return __builtin_catanhl(__z); }\n+#elif defined(__STDCPP_FLOAT128_T__) && defined(_GLIBCXX_HAVE_FLOAT128_MATH)\n+  inline __complex__ _Float128\n+  __complex_acos(__complex__ _Float128 __z)\n+  { return __builtin_cacosf128(__z); }\n \n-  inline _GLIBCXX_CONSTEXPR\n-  complex<float>::complex(const complex<long double>& __z)\n-  : _M_value(__z.__rep()) { }\n+  inline __complex__ _Float128\n+  __complex_asin(__complex__ _Float128 __z)\n+  { return __builtin_casinf128(__z); }\n \n-  inline _GLIBCXX_CONSTEXPR\n-  complex<double>::complex(const complex<long double>& __z)\n-  : _M_value(__z.__rep()) { }\n-#endif\n+  inline __complex__ _Float128\n+  __complex_atan(__complex__ _Float128 __z)\n+  { return __builtin_catanf128(__z); }\n \n-  // Inhibit implicit instantiations for required instantiations,\n-  // which are defined via explicit instantiations elsewhere.\n-  // NB:  This syntax is a GNU extension.\n-#if _GLIBCXX_EXTERN_TEMPLATE\n-  extern template istream& operator>>(istream&, complex<float>&);\n-  extern template ostream& operator<<(ostream&, const complex<float>&);\n-  extern template istream& operator>>(istream&, complex<double>&);\n-  extern template ostream& operator<<(ostream&, const complex<double>&);\n-  extern template istream& operator>>(istream&, complex<long double>&);\n-  extern template ostream& operator<<(ostream&, const complex<long double>&);\n+  inline __complex__ _Float128\n+  __complex_acosh(__complex__ _Float128 __z)\n+  { return __builtin_cacoshf128(__z); }\n \n-#ifdef _GLIBCXX_USE_WCHAR_T\n-  extern template wistream& operator>>(wistream&, complex<float>&);\n-  extern template wostream& operator<<(wostream&, const complex<float>&);\n-  extern template wistream& operator>>(wistream&, complex<double>&);\n-  extern template wostream& operator<<(wostream&, const complex<double>&);\n-  extern template wistream& operator>>(wistream&, complex<long double>&);\n-  extern template wostream& operator<<(wostream&, const complex<long double>&);\n-#endif\n-#endif\n+  inline __complex__ _Float128\n+  __complex_asinh(__complex__ _Float128 __z)\n+  { return __builtin_casinhf128(__z); }\n \n-  /// @} group complex_numbers\n+  inline __complex__ _Float128\n+  __complex_atanh(__complex__ _Float128 __z)\n+  { return __builtin_catanhf128(__z); }\n+#endif\n \n-_GLIBCXX_END_NAMESPACE_VERSION\n-} // namespace\n+#if defined(__STDCPP_BFLOAT16_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n+  inline __complex__ decltype(0.0bf16)\n+  __complex_acos(__complex__ decltype(0.0bf16) __z)\n+  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_cacosf(__z)); }\n \n-#if __cplusplus >= 201103L\n+  inline __complex__ decltype(0.0bf16)\n+  __complex_asin(__complex__ decltype(0.0bf16) __z)\n+  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_casinf(__z)); }\n \n-namespace std _GLIBCXX_VISIBILITY(default)\n-{\n-_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+  inline __complex__ decltype(0.0bf16)\n+  __complex_atan(__complex__ decltype(0.0bf16) __z)\n+  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_catanf(__z)); }\n \n-  // Forward declarations.\n-  template<typename _Tp> std::complex<_Tp> acos(const std::complex<_Tp>&);\n-  template<typename _Tp> std::complex<_Tp> asin(const std::complex<_Tp>&);\n-  template<typename _Tp> std::complex<_Tp> atan(const std::complex<_Tp>&);\n+  inline __complex__ decltype(0.0bf16)\n+  __complex_acosh(__complex__ decltype(0.0bf16) __z)\n+  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_cacoshf(__z)); }\n \n-  template<typename _Tp> std::complex<_Tp> acosh(const std::complex<_Tp>&);\n-  template<typename _Tp> std::complex<_Tp> asinh(const std::complex<_Tp>&);\n-  template<typename _Tp> std::complex<_Tp> atanh(const std::complex<_Tp>&);\n-  // DR 595.\n-  template<typename _Tp> _Tp               fabs(const std::complex<_Tp>&);\n+  inline __complex__ decltype(0.0bf16)\n+  __complex_asinh(__complex__ decltype(0.0bf16) __z)\n+  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_casinhf(__z)); }\n \n-  template<typename _Tp>\n-    inline std::complex<_Tp>\n-    __complex_acos(const std::complex<_Tp>& __z)\n-    {\n-      const std::complex<_Tp> __t = std::asin(__z);\n-      const _Tp __pi_2 = 1.5707963267948966192313216916397514L;\n-      return std::complex<_Tp>(__pi_2 - __t.real(), -__t.imag());\n-    }\n+  inline __complex__ decltype(0.0bf16)\n+  __complex_atanh(__complex__ decltype(0.0bf16) __z)\n+  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_catanhf(__z)); }\n+#endif\n+#endif\n \n #if _GLIBCXX_USE_C99_COMPLEX_TR1\n   inline __complex__ float\n@@ -2247,162 +2403,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     { return __complex_atanh(__z); }\n #endif\n \n-#if _GLIBCXX_USE_C99_COMPLEX_TR1\n-#if defined(__STDCPP_FLOAT16_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n-  inline __complex__ _Float16\n-  __complex_acos(__complex__ _Float16 __z)\n-  { return static_cast<__complex__ _Float16>(__builtin_cacosf(__z)); }\n-\n-  inline __complex__ _Float16\n-  __complex_asin(__complex__ _Float16 __z)\n-  { return static_cast<__complex__ _Float16>(__builtin_casinf(__z)); }\n-\n-  inline __complex__ _Float16\n-  __complex_atan(__complex__ _Float16 __z)\n-  { return static_cast<__complex__ _Float16>(__builtin_catanf(__z)); }\n-\n-  inline __complex__ _Float16\n-  __complex_acosh(__complex__ _Float16 __z)\n-  { return static_cast<__complex__ _Float16>(__builtin_cacoshf(__z)); }\n-\n-  inline __complex__ _Float16\n-  __complex_asinh(__complex__ _Float16 __z)\n-  { return static_cast<__complex__ _Float16>(__builtin_casinhf(__z)); }\n-\n-  inline __complex__ _Float16\n-  __complex_atanh(__complex__ _Float16 __z)\n-  { return static_cast<__complex__ _Float16>(__builtin_catanhf(__z)); }\n-#endif\n-\n-#if defined(__STDCPP_FLOAT32_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n-  inline __complex__ _Float32\n-  __complex_acos(__complex__ _Float32 __z)\n-  { return __builtin_cacosf(__z); }\n-\n-  inline __complex__ _Float32\n-  __complex_asin(__complex__ _Float32 __z)\n-  { return __builtin_casinf(__z); }\n-\n-  inline __complex__ _Float32\n-  __complex_atan(__complex__ _Float32 __z)\n-  { return __builtin_catanf(__z); }\n-\n-  inline __complex__ _Float32\n-  __complex_acosh(__complex__ _Float32 __z)\n-  { return __builtin_cacoshf(__z); }\n-\n-  inline __complex__ _Float32\n-  __complex_asinh(__complex__ _Float32 __z)\n-  { return __builtin_casinhf(__z); }\n-\n-  inline __complex__ _Float32\n-  __complex_atanh(__complex__ _Float32 __z)\n-  { return __builtin_catanhf(__z); }\n-#endif\n-\n-#if defined(__STDCPP_FLOAT64_T__) && defined(_GLIBCXX_DOUBLE_IS_IEEE_BINARY64)\n-  inline __complex__ _Float64\n-  __complex_acos(__complex__ _Float64 __z)\n-  { return __builtin_cacos(__z); }\n-\n-  inline __complex__ _Float64\n-  __complex_asin(__complex__ _Float64 __z)\n-  { return __builtin_casin(__z); }\n-\n-  inline __complex__ _Float64\n-  __complex_atan(__complex__ _Float64 __z)\n-  { return __builtin_catan(__z); }\n-\n-  inline __complex__ _Float64\n-  __complex_acosh(__complex__ _Float64 __z)\n-  { return __builtin_cacosh(__z); }\n-\n-  inline __complex__ _Float64\n-  __complex_asinh(__complex__ _Float64 __z)\n-  { return __builtin_casinh(__z); }\n-\n-  inline __complex__ _Float64\n-  __complex_atanh(__complex__ _Float64 __z)\n-  { return __builtin_catanh(__z); }\n-#endif\n-\n-#if defined(__STDCPP_FLOAT128_T__) && defined(_GLIBCXX_LDOUBLE_IS_IEEE_BINARY128)\n-  inline __complex__ _Float128\n-  __complex_acos(__complex__ _Float128 __z)\n-  { return __builtin_cacosl(__z); }\n-\n-  inline __complex__ _Float128\n-  __complex_asin(__complex__ _Float128 __z)\n-  { return __builtin_casinl(__z); }\n-\n-  inline __complex__ _Float128\n-  __complex_atan(__complex__ _Float128 __z)\n-  { return __builtin_catanl(__z); }\n-\n-  inline __complex__ _Float128\n-  __complex_acosh(__complex__ _Float128 __z)\n-  { return __builtin_cacoshl(__z); }\n-\n-  inline __complex__ _Float128\n-  __complex_asinh(__complex__ _Float128 __z)\n-  { return __builtin_casinhl(__z); }\n-\n-  inline __complex__ _Float128\n-  __complex_atanh(__complex__ _Float128 __z)\n-  { return __builtin_catanhl(__z); }\n-#elif defined(__STDCPP_FLOAT128_T__) && defined(_GLIBCXX_HAVE_FLOAT128_MATH)\n-  inline __complex__ _Float128\n-  __complex_acos(__complex__ _Float128 __z)\n-  { return __builtin_cacosf128(__z); }\n-\n-  inline __complex__ _Float128\n-  __complex_asin(__complex__ _Float128 __z)\n-  { return __builtin_casinf128(__z); }\n-\n-  inline __complex__ _Float128\n-  __complex_atan(__complex__ _Float128 __z)\n-  { return __builtin_catanf128(__z); }\n-\n-  inline __complex__ _Float128\n-  __complex_acosh(__complex__ _Float128 __z)\n-  { return __builtin_cacoshf128(__z); }\n-\n-  inline __complex__ _Float128\n-  __complex_asinh(__complex__ _Float128 __z)\n-  { return __builtin_casinhf128(__z); }\n-\n-  inline __complex__ _Float128\n-  __complex_atanh(__complex__ _Float128 __z)\n-  { return __builtin_catanhf128(__z); }\n-#endif\n-\n-#if defined(__STDCPP_BFLOAT16_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n-  inline __complex__ decltype(0.0bf16)\n-  __complex_acos(__complex__ decltype(0.0bf16) __z)\n-  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_cacosf(__z)); }\n-\n-  inline __complex__ decltype(0.0bf16)\n-  __complex_asin(__complex__ decltype(0.0bf16) __z)\n-  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_casinf(__z)); }\n-\n-  inline __complex__ decltype(0.0bf16)\n-  __complex_atan(__complex__ decltype(0.0bf16) __z)\n-  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_catanf(__z)); }\n-\n-  inline __complex__ decltype(0.0bf16)\n-  __complex_acosh(__complex__ decltype(0.0bf16) __z)\n-  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_cacoshf(__z)); }\n-\n-  inline __complex__ decltype(0.0bf16)\n-  __complex_asinh(__complex__ decltype(0.0bf16) __z)\n-  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_casinhf(__z)); }\n-\n-  inline __complex__ decltype(0.0bf16)\n-  __complex_atanh(__complex__ decltype(0.0bf16) __z)\n-  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_catanhf(__z)); }\n-#endif\n-#endif\n-\n   template<typename _Tp>\n     inline _Tp\n     /// fabs(__z) [8.1.8]."}]}