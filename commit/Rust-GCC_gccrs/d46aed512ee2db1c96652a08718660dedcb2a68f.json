{"sha": "d46aed512ee2db1c96652a08718660dedcb2a68f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQ2YWVkNTEyZWUyZGIxYzk2NjUyYTA4NzE4NjYwZGVkY2IyYTY4Zg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-11-04T13:48:59Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-11-04T13:48:59Z"}, "message": "bitmap.h: Fix a comment typo.\n\n\t* bitmap.h: Fix a comment typo.  Follow spelling conventions.\n\t* tree-vectorizer.c: Fix a comment typo.\n\nFrom-SVN: r90062", "tree": {"sha": "f1785d7f60af32845cffa6c3834fee32f31633d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f1785d7f60af32845cffa6c3834fee32f31633d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d46aed512ee2db1c96652a08718660dedcb2a68f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d46aed512ee2db1c96652a08718660dedcb2a68f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d46aed512ee2db1c96652a08718660dedcb2a68f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d46aed512ee2db1c96652a08718660dedcb2a68f/comments", "author": null, "committer": null, "parents": [{"sha": "37bf6443fee7d2bde76fb491782215314e2415f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37bf6443fee7d2bde76fb491782215314e2415f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37bf6443fee7d2bde76fb491782215314e2415f9"}], "stats": {"total": 29, "additions": 17, "deletions": 12}, "files": [{"sha": "033e47b2f4b91dcf605efa09a52915c5cbbedba4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d46aed512ee2db1c96652a08718660dedcb2a68f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d46aed512ee2db1c96652a08718660dedcb2a68f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d46aed512ee2db1c96652a08718660dedcb2a68f", "patch": "@@ -1,3 +1,8 @@\n+2004-11-04  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* bitmap.h: Fix a comment typo.  Follow spelling conventions.\n+\t* tree-vectorizer.c: Fix a comment typo.\n+\n 2004-11-04  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* sdbout.c (SDB_GENERATE_FAKE): Remove."}, {"sha": "5c377cfd1870790dc91f872a9f51dbc51c615f1d", "filename": "gcc/bitmap.h", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d46aed512ee2db1c96652a08718660dedcb2a68f/gcc%2Fbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d46aed512ee2db1c96652a08718660dedcb2a68f/gcc%2Fbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.h?ref=d46aed512ee2db1c96652a08718660dedcb2a68f", "patch": "@@ -358,7 +358,7 @@ bmp_iter_and_compl_init (bitmap_iterator *bi, bitmap map1, bitmap map2,\n }\n \n /* Advance to the next bit in BI.  We don't advance to the next\n-   non-zero bit yet.  */\n+   nonzero bit yet.  */\n \n static inline void\n bmp_iter_next (bitmap_iterator *bi, unsigned *bit_no)\n@@ -367,14 +367,14 @@ bmp_iter_next (bitmap_iterator *bi, unsigned *bit_no)\n   *bit_no += 1;\n }\n \n-/* Advance to the next non-zero bit of a single bitmap, we will have\n+/* Advance to the next nonzero bit of a single bitmap, we will have\n    already advanced past the just iterated bit.  Return true if there\n    is a bit to iterate.  */\n \n static inline bool\n bmp_iter_set (bitmap_iterator *bi, unsigned *bit_no)\n {\n-  /* If our current word is non-zero, it contains the bit we want.  */\n+  /* If our current word is nonzero, it contains the bit we want.  */\n   if (bi->bits)\n     {\n     next_bit:\n@@ -395,7 +395,7 @@ bmp_iter_set (bitmap_iterator *bi, unsigned *bit_no)\n \n   while (1)\n     {\n-      /* Find the next non-zero word in this elt.  */\n+      /* Find the next nonzero word in this elt.  */\n       while (bi->word_no != BITMAP_ELEMENT_WORDS)\n \t{\n \t  bi->bits = bi->elt1->bits[bi->word_no];\n@@ -414,14 +414,14 @@ bmp_iter_set (bitmap_iterator *bi, unsigned *bit_no)\n     }\n }\n \n-/* Advance to the next non-zero bit of an intersecting pair of\n-   bitmaps.  We will have alreadt advanced past the just iterated bit.\n+/* Advance to the next nonzero bit of an intersecting pair of\n+   bitmaps.  We will have already advanced past the just iterated bit.\n    Return true if there is a bit to iterate.  */\n \n static inline bool\n bmp_iter_and (bitmap_iterator *bi, unsigned *bit_no)\n {\n-  /* If our current word is non-zero, it contains the bit we want.  */\n+  /* If our current word is nonzero, it contains the bit we want.  */\n   if (bi->bits)\n     {\n     next_bit:\n@@ -442,7 +442,7 @@ bmp_iter_and (bitmap_iterator *bi, unsigned *bit_no)\n   \n   while (1)\n     {\n-      /* Find the next non-zero word in this elt.  */\n+      /* Find the next nonzero word in this elt.  */\n       while (bi->word_no != BITMAP_ELEMENT_WORDS)\n \t{\n \t  bi->bits = bi->elt1->bits[bi->word_no] & bi->elt2->bits[bi->word_no];\n@@ -481,14 +481,14 @@ bmp_iter_and (bitmap_iterator *bi, unsigned *bit_no)\n     }\n }\n \n-/* Advance to the next non-zero bit in the intersection of\n+/* Advance to the next nonzero bit in the intersection of\n    complemented bitmaps.  We will have already advanced past the just\n    iterated bit.  */\n \n static inline bool\n bmp_iter_and_compl (bitmap_iterator *bi, unsigned *bit_no)\n {\n-  /* If our current word is non-zero, it contains the bit we want.  */\n+  /* If our current word is nonzero, it contains the bit we want.  */\n   if (bi->bits)\n     {\n     next_bit:\n@@ -509,7 +509,7 @@ bmp_iter_and_compl (bitmap_iterator *bi, unsigned *bit_no)\n \n   while (1)\n     {\n-      /* Find the next non-zero word in this elt.  */\n+      /* Find the next nonzero word in this elt.  */\n       while (bi->word_no != BITMAP_ELEMENT_WORDS)\n \t{\n \t  bi->bits = bi->elt1->bits[bi->word_no];"}, {"sha": "8e50045d435500feffce9890fdf08316a5f3cb23", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d46aed512ee2db1c96652a08718660dedcb2a68f/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d46aed512ee2db1c96652a08718660dedcb2a68f/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=d46aed512ee2db1c96652a08718660dedcb2a68f", "patch": "@@ -4426,7 +4426,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n        in code size).\n \n      The scheme we use FORNOW: peel to force the alignment of the first\n-     misaliged store in the loop.\n+     misaligned store in the loop.\n      Rationale: misaligned store are not yet supported.\n \n      TODO: Use a better cost model.  */"}]}