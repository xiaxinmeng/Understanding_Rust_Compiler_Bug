{"sha": "7042fe5ef83ff0585eb91144817105f26d566d4c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzA0MmZlNWVmODNmZjA1ODVlYjkxMTQ0ODE3MTA1ZjI2ZDU2NmQ0Yw==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2010-08-27T21:32:44Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2010-08-27T21:32:44Z"}, "message": "Improve floating point conversions on powerpc\n\nFrom-SVN: r163598", "tree": {"sha": "c876d4485888c8a83ac11e08799a3252229a51c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c876d4485888c8a83ac11e08799a3252229a51c3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7042fe5ef83ff0585eb91144817105f26d566d4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7042fe5ef83ff0585eb91144817105f26d566d4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7042fe5ef83ff0585eb91144817105f26d566d4c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7042fe5ef83ff0585eb91144817105f26d566d4c/comments", "author": null, "committer": null, "parents": [{"sha": "a3c85b749940a80efed069253b08c0673c817278", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3c85b749940a80efed069253b08c0673c817278", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3c85b749940a80efed069253b08c0673c817278"}], "stats": {"total": 1392, "additions": 1183, "deletions": 209}, "files": [{"sha": "b2410225ccb627b08a34ab9e26d20dd12d67f0b9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7042fe5ef83ff0585eb91144817105f26d566d4c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7042fe5ef83ff0585eb91144817105f26d566d4c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7042fe5ef83ff0585eb91144817105f26d566d4c", "patch": "@@ -1,3 +1,123 @@\n+2010-08-23  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000-protos.h (rs6000_address_for_fpconvert):\n+\tNew declaration.\n+\t(rs6000_allocate_stack_temp): Ditto.\n+\t(rs6000_expand_convert_si_to_sfdf): Ditto.\n+\n+\t* config/rs6000/rs6000.c (rs6000_override_options): Adjust long\n+\tline.  Update the options set if power6 or power7 server/embedded\n+\ttype options are used.  If we give a warning for no vsx under\n+\t-mcpu=power7 -mno-altivec, mark -mvsx as an explicit option.\n+\t(rs6000_allocate_stack_temp): New function to allocate a stack\n+\ttempoary and adjust the address so it meets either REG+OFFSET or\n+\tREG+REG addressing requirements.\n+\t(rs6000_address_for_fpconvert): Adjust REG+OFFSET addresses so\n+\tthat they can be used with the LFIWAX/LFIWZX instrucitons.\n+\t(rs6000_expand_convert_si_to_sfdf): New helper funciton for\n+\tconverting signed/unsigned SImode to either SFmode/DFmode.\n+\n+\t* config/rs6000/rs6000.h (TARGET_FCFID): New macros to determine\n+\twhether certain instructions can be generated.\n+\t(TARGET_FCTIDZ): Ditto.\n+\t(TARGET_STFIWX): Ditto.\n+\t(TARGET_LFIWAX): Ditto.\n+\t(TARGET_LFIWZX): Ditto.\n+\t(TARGET_FCFIDS): Ditto.\n+\t(TARGET_FCFIDU): Ditto.\n+\t(TARGET_FCFIDUS): Ditto.\n+\t(TARGET_FCTIDUZ): Ditto.\n+\t(TARGET_FCTIWUZ): Ditto.\n+\n+\t* config/rs6000/rs6000.md (UNSPEC_FCTIW): New unspec constants.\n+\t(UNSPEC_FCTID): Ditto.\n+\t(UNSPEC_LFIWAX): Ditto.\n+\t(UNSPEC_LFIWZX): Ditto.\n+\t(UNSPEC_FCTIWUZ): Ditto.\n+\t(rreg): Use correct constraints.\n+\t(SI_CONVERT_FP): New mode attribute for floating point conversion\n+\ttests.\n+\t(E500_CONVERT): Ditto.\n+\t(lfiwax): New insns for converting from integer to floating point\n+\tutilizing newer instructions.  Attempt to optimize conversions\n+\tthat come from memory so that we don't load the value into a GPR,\n+\tspill it to the stack and reload it into a FPR.\n+\t(floatsi<mode>2_lfiwax): Ditto.\n+\t(floatsi<mode>2_lfiwax_mem): Ditto.\n+\t(floatsi<mode>2_lfiwax_mem2): Ditto.\n+\t(lfiwzx): Ditto.\n+\t(floatunssi<mode>2_lfiwzx): Ditto.\n+\t(floatunssi<mode>2_lfiwzx_mem): Ditto.\n+\t(floatunssi<mode>2_lfiwzx_mem2): Ditto.\n+\t(floatdidf2_mem): Ditto.\n+\t(floatunsdidf2_fcfidu): Ditto.\n+\t(floatunsdidf2_mem): Ditto.\n+\t(floatunsdisf2): Ditto.\n+\t(floatunsdisf2_fcfidus): Ditto.\n+\t(floatunsdisf2_mem): Ditto.\n+\t(floatsidf2): Add support for LFIWAX/LFIWZX/FCFIDS/FCFIDU/FCFIDUS.\n+\tUse FCFID on 32-bit hosts that support it.\n+\t(floatsidf2_internal): Ditto.\n+\t(floatunssisf2): Ditto.\n+\t(floatunssidf2): Ditto.\n+\t(floatunssidf2_internal): Ditto.\n+\t(floatsisf2): Ditto.\n+\t(floatdidf2): Ditto.\n+\t(floatdidf2_fpr): Ditto.\n+\t(floatunsdidf2): Ditto.\n+\t(floatdisf2): Ditto.\n+\t(floatdisf2_fcfids): Ditto.\n+\t(floatdisf2_internal1): Ditto.\n+\t(fixuns_truncsfsi2): Delete, merge into common pattern for both\n+\tSF/DF.  Add power7 support.\n+\t(fix_truncsfsi2): Ditto.\n+\t(fixuns_truncdfsi2): Ditto.\n+\t(fixuns_truncdfdi2): Ditto.\n+\t(fix_truncdfsi2): Ditto.\n+\t(fix_truncdfsi2_internal): Ditto.\n+\t(fix_truncdfsi2_internal_gfxopt): Ditto.\n+\t(fix_truncdfsi2_mfpgpr): Ditto.\n+\t(fctiwz): Ditto.\n+\t(btruncdf2): Ditto.\n+\t(btruncdf2_fpr): Ditto.\n+\t(btructsf2): Ditto.\n+\t(ceildf2): Ditto.\n+\t(ceildf2_fpr): Ditto.\n+\t(ceilsf2): Ditto.\n+\t(floordf2): Ditto.\n+\t(floordf2_fpr): Ditto.\n+\t(floorsf2): Ditto.\n+\t(rounddf2): Ditto.\n+\t(rounddf2_fpr): Ditto.\n+\t(roundsf2): Ditto.\n+\t(fix_trunc<mode>si2): Combine SF/DF conversion into one insn.\n+\t(fix_trunc<mode>di2): Ditto.\n+\t(fixuns_trunc<mode>si2): Ditto.\n+\t(fixuns_trunc<mode>di2): Ditto.\n+\t(fctiwz_<mode>): Ditto.\n+\t(btrunc<mode>2): Ditto.\n+\t(btrunc<mode>2_fpr): Ditto.\n+\t(ceil<mode>2): Ditto.\n+\t(ceil<mode>2_fpr): Ditto.\n+\t(floor<mode>2): Ditto.\n+\t(float<mode>2_fpr): Ditto.\n+\t(round<mode>2): Ditto.\n+\t(round<mode>2_fpr): Ditto.\n+\t(fix_trunc<mode>si2_stfiwx): New insn for machines with STFIWX.\n+\t(fixuns_trunc<mode>si2_stfiwx): Ditto.\n+\t(fix_truncdfsi2_internal): Ditto.\n+\t(fix_trunc<mode>si2_mem): Combiner pattern to eliminate storing\n+\tconverted value on stack, loaded into GPR, and then stored into\n+\tthe final destination.\n+\t(fix_trunc<mode>di2_fctidz): New pattern for targets supporting\n+\tFCTIDZ.\n+\t(lrint<mode>di2): New insn, provide the lrint builtin functions.\n+\t(ftruncdf2): Delete, unused.\n+\t(fix_trunctfsi2_internal): Use gen_fctiwz_df, not gen_fctiwz.\n+\n+\t* config/rs6000/vsx.md (toplevel): Update copyright year.\n+\t(VSr2): Use \"ws\" contraint for DFmode, not \"!r#r\".\n+\t(VSr3): Ditto.\n \n 2010-08-27  Basile Starynkevitch  <basile@starynkevitch.net>\n             Jeremie Salvucci  <jeremie.salvucci@free.fr>"}, {"sha": "0d26511524bf0004c8031de330e1c366f34a2af0", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7042fe5ef83ff0585eb91144817105f26d566d4c/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7042fe5ef83ff0585eb91144817105f26d566d4c/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=7042fe5ef83ff0585eb91144817105f26d566d4c", "patch": "@@ -129,6 +129,9 @@ extern void rs6000_emit_parity (rtx, rtx);\n \n extern rtx rs6000_machopic_legitimize_pic_address (rtx, enum machine_mode,\n \t\t\t\t\t\t   rtx);\n+extern rtx rs6000_address_for_fpconvert (rtx);\n+extern rtx rs6000_allocate_stack_temp (enum machine_mode, bool, bool);\n+extern void rs6000_expand_convert_si_to_sfdf (rtx, rtx, bool);\n #endif /* RTX_CODE */\n \n #ifdef TREE_CODE"}, {"sha": "6bebca919fe67281329a650ad55b10473c625087", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 139, "deletions": 10, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7042fe5ef83ff0585eb91144817105f26d566d4c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7042fe5ef83ff0585eb91144817105f26d566d4c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=7042fe5ef83ff0585eb91144817105f26d566d4c", "patch": "@@ -2510,10 +2510,10 @@ rs6000_override_options (const char *default_cpu)\n \t  POWERPC_BASE_MASK | MASK_POWERPC64 | MASK_PPC_GPOPT | MASK_PPC_GFXOPT\n \t  | MASK_MFCRF | MASK_POPCNTB | MASK_FPRND | MASK_CMPB | MASK_DFP\n \t  | MASK_MFPGPR | MASK_RECIP_PRECISION},\n-\t {\"power7\", PROCESSOR_POWER7,\n+\t {\"power7\", PROCESSOR_POWER7,   /* Don't add MASK_ISEL by default */\n \t  POWERPC_7400_MASK | MASK_POWERPC64 | MASK_PPC_GPOPT | MASK_MFCRF\n \t  | MASK_POPCNTB | MASK_FPRND | MASK_CMPB | MASK_DFP | MASK_POPCNTD\n-\t  | MASK_VSX| MASK_RECIP_PRECISION},\t/* Don't add MASK_ISEL by default */\n+\t  | MASK_VSX | MASK_RECIP_PRECISION},\n \t {\"powerpc\", PROCESSOR_POWERPC, POWERPC_BASE_MASK},\n \t {\"powerpc64\", PROCESSOR_POWERPC64,\n \t  POWERPC_BASE_MASK | MASK_PPC_GFXOPT | MASK_POWERPC64},\n@@ -2550,15 +2550,19 @@ rs6000_override_options (const char *default_cpu)\n     ISA_2_1_MASKS = MASK_MFCRF,\n     ISA_2_2_MASKS = (ISA_2_1_MASKS | MASK_POPCNTB | MASK_FPRND),\n \n-    /* For ISA 2.05, do not add MFPGPR, since it isn't in ISA 2.06, and\n-       don't add ALTIVEC, since in general it isn't a win on power6.  */\n-    ISA_2_5_MASKS = (ISA_2_2_MASKS | MASK_CMPB | MASK_RECIP_PRECISION\n-\t\t     | MASK_DFP),\n+    /* For ISA 2.05, do not add MFPGPR, since it isn't in ISA 2.06, and don't\n+       add ALTIVEC, since in general it isn't a win on power6.  In ISA 2.04,\n+       fsel, fre, fsqrt, etc. were no longer documented as optional.  Group\n+       masks by server and embedded. */\n+    ISA_2_5_MASKS_EMBEDDED = (ISA_2_2_MASKS | MASK_CMPB | MASK_RECIP_PRECISION\n+\t\t\t      | MASK_PPC_GFXOPT | MASK_PPC_GPOPT),\n+    ISA_2_5_MASKS_SERVER = (ISA_2_5_MASKS_EMBEDDED | MASK_DFP),\n \n     /* For ISA 2.06, don't add ISEL, since in general it isn't a win, but\n        altivec is a win so enable it.  */\n-    ISA_2_6_MASKS = (ISA_2_5_MASKS | MASK_ALTIVEC | MASK_POPCNTD\n-\t\t     | MASK_VSX | MASK_RECIP_PRECISION)\n+    ISA_2_6_MASKS_EMBEDDED = (ISA_2_5_MASKS_EMBEDDED | MASK_POPCNTD),\n+    ISA_2_6_MASKS_SERVER = (ISA_2_5_MASKS_SERVER | MASK_POPCNTD | MASK_ALTIVEC\n+\t\t\t    | MASK_VSX)\n   };\n \n   /* Numerous experiment shows that IRA based loop pressure\n@@ -2699,15 +2703,22 @@ rs6000_override_options (const char *default_cpu)\n \t{\n \t  warning (0, msg);\n \t  target_flags &= ~ MASK_VSX;\n+\t  target_flags_explicit |= MASK_VSX;\n \t}\n     }\n \n   /* For the newer switches (vsx, dfp, etc.) set some of the older options,\n      unless the user explicitly used the -mno-<option> to disable the code.  */\n   if (TARGET_VSX)\n-    target_flags |= (ISA_2_6_MASKS & ~target_flags_explicit);\n+    target_flags |= (ISA_2_6_MASKS_SERVER & ~target_flags_explicit);\n+  else if (TARGET_POPCNTD)\n+    target_flags |= (ISA_2_6_MASKS_EMBEDDED & ~target_flags_explicit);\n   else if (TARGET_DFP)\n-    target_flags |= (ISA_2_5_MASKS & ~target_flags_explicit);\n+    target_flags |= (ISA_2_5_MASKS_SERVER & ~target_flags_explicit);\n+  else if (TARGET_CMPB)\n+    target_flags |= (ISA_2_5_MASKS_EMBEDDED & ~target_flags_explicit);\n+  else if (TARGET_POPCNTB || TARGET_FPRND)\n+    target_flags |= (ISA_2_2_MASKS & ~target_flags_explicit);\n   else if (TARGET_ALTIVEC)\n     target_flags |= (MASK_PPC_GFXOPT & ~target_flags_explicit);\n \n@@ -26959,4 +26970,122 @@ rs6000_final_prescan_insn (rtx insn, rtx *operand ATTRIBUTE_UNUSED,\n     }\n }\n \n+\f\n+/* Allocate a stack temp and fixup the address so it meets the particular\n+   memory requirements (either offetable or REG+REG addressing).  */\n+\n+rtx\n+rs6000_allocate_stack_temp (enum machine_mode mode,\n+\t\t\t    bool offsettable_p,\n+\t\t\t    bool reg_reg_p)\n+{\n+  rtx stack = assign_stack_temp (mode, GET_MODE_SIZE (mode), 0);\n+  rtx addr = XEXP (stack, 0);\n+  int strict_p = (reload_in_progress || reload_completed);\n+\n+  if (!legitimate_indirect_address_p (addr, strict_p))\n+    {\n+      if (offsettable_p\n+\t  && !rs6000_legitimate_offset_address_p (mode, addr, strict_p))\n+\tstack = replace_equiv_address (stack, copy_addr_to_reg (addr));\n+\n+      else if (reg_reg_p && !legitimate_indexed_address_p (addr, strict_p))\n+\tstack = replace_equiv_address (stack, copy_addr_to_reg (addr));\n+    }\n+\n+  return stack;\n+}\n+\n+/* Given a memory reference, if it is not a reg or reg+reg addressing, convert\n+   to such a form to deal with memory reference instructions like STFIWX that\n+   only take reg+reg addressing.  */\n+\n+rtx\n+rs6000_address_for_fpconvert (rtx x)\n+{\n+  int strict_p = (reload_in_progress || reload_completed);\n+  rtx addr;\n+\n+  gcc_assert (MEM_P (x));\n+  addr = XEXP (x, 0);\n+  if (! legitimate_indirect_address_p (addr, strict_p)\n+      && ! legitimate_indexed_address_p (addr, strict_p))\n+    x = replace_equiv_address (x, copy_addr_to_reg (addr));\n+\n+  return x;\n+}\n+\n+/* Expand 32-bit int -> floating point conversions.  Return true if\n+   successful.  */\n+\n+void\n+rs6000_expand_convert_si_to_sfdf (rtx dest, rtx src, bool unsigned_p)\n+{\n+  enum machine_mode dmode = GET_MODE (dest);\n+  rtx (*func_si) (rtx, rtx, rtx, rtx);\n+  rtx (*func_si_mem) (rtx, rtx);\n+  rtx (*func_di) (rtx, rtx);\n+  rtx reg, stack;\n+\n+  gcc_assert (GET_MODE (src) == SImode);\n+\n+  if (dmode == SFmode)\n+    {\n+      if (unsigned_p)\n+\t{\n+\t  gcc_assert (TARGET_FCFIDUS && TARGET_LFIWZX);\n+\t  func_si = gen_floatunssisf2_lfiwzx;\n+\t  func_si_mem = gen_floatunssisf2_lfiwzx_mem;\n+\t  func_di = gen_floatunsdisf2;\n+\t}\n+      else\n+\t{\n+\t  gcc_assert (TARGET_FCFIDS && TARGET_LFIWAX);\n+\t  func_si = gen_floatsisf2_lfiwax;\n+\t  func_si_mem = gen_floatsisf2_lfiwax_mem;\n+\t  func_di = gen_floatdisf2;\n+\t}\n+    }\n+\n+  else if (dmode == DFmode)\n+    {\n+      if (unsigned_p)\n+\t{\n+\t  gcc_assert (TARGET_FCFIDU && TARGET_LFIWZX);\n+\t  func_si = gen_floatunssidf2_lfiwzx;\n+\t  func_si_mem = gen_floatunssidf2_lfiwzx_mem;\n+\t  func_di = gen_floatunsdidf2;\n+\t}\n+      else\n+\t{\n+\t  gcc_assert (TARGET_FCFID && TARGET_LFIWAX);\n+\t  func_si = gen_floatsidf2_lfiwax;\n+\t  func_si_mem = gen_floatsidf2_lfiwax_mem;\n+\t  func_di = gen_floatdidf2;\n+\t}\n+    }\n+\n+  else\n+    gcc_unreachable ();\n+\n+  if (MEM_P (src))\n+    {\n+      src = rs6000_address_for_fpconvert (src);\n+      emit_insn (func_si_mem (dest, src));\n+    }\n+  else if (!TARGET_MFPGPR)\n+    {\n+      reg = gen_reg_rtx (DImode);\n+      stack = rs6000_allocate_stack_temp (SImode, false, true);\n+      emit_insn (func_si (dest, src, stack, reg));\n+    }\n+  else\n+    {\n+      if (!REG_P (src))\n+\tsrc = force_reg (SImode, src);\n+      reg = convert_to_mode (DImode, src, unsigned_p);\n+      emit_insn (func_di (dest, reg));\n+    }\n+}\n+\n #include \"gt-rs6000.h\""}, {"sha": "3ce011f2376d75d0675892c50c6182658fc3b574", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7042fe5ef83ff0585eb91144817105f26d566d4c/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7042fe5ef83ff0585eb91144817105f26d566d4c/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=7042fe5ef83ff0585eb91144817105f26d566d4c", "patch": "@@ -1,6 +1,7 @@\n /* Definitions of target machine for GNU compiler, for IBM RS/6000.\n    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n-   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n+   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,\n+   2010\n    Free Software Foundation, Inc.\n    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)\n \n@@ -554,6 +555,25 @@ extern int rs6000_vector_align[];\n #define TARGET_E500_DOUBLE 0\n #define CHECK_E500_OPTIONS do { } while (0)\n \n+/* ISA 2.01 allowed FCFID to be done in 32-bit, previously it was 64-bit only.\n+   Enable 32-bit fcfid's on any of the switches for newer ISA machines or\n+   XILINX.  */\n+#define TARGET_FCFID\t(TARGET_POWERPC64 \\\n+\t\t\t || TARGET_POPCNTB\t/* ISA 2.02 */ \\\n+\t\t\t || TARGET_CMPB\t\t/* ISA 2.05 */ \\\n+\t\t\t || TARGET_POPCNTD\t/* ISA 2.06 */ \\\n+\t\t\t || TARGET_XILINX_FPU)\n+\n+#define TARGET_FCTIDZ\tTARGET_FCFID\n+#define TARGET_STFIWX\tTARGET_PPC_GFXOPT\n+#define TARGET_LFIWAX\tTARGET_CMPB\n+#define TARGET_LFIWZX\tTARGET_POPCNTD\n+#define TARGET_FCFIDS\tTARGET_POPCNTD\n+#define TARGET_FCFIDU\tTARGET_POPCNTD\n+#define TARGET_FCFIDUS\tTARGET_POPCNTD\n+#define TARGET_FCTIDUZ\tTARGET_POPCNTD\n+#define TARGET_FCTIWUZ\tTARGET_POPCNTD\n+\n /* E500 processors only support plain \"sync\", not lwsync.  */\n #define TARGET_NO_LWSYNC TARGET_E500\n "}, {"sha": "5c68c3f89a6dc695834d52d17732d420a0411623", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 581, "deletions": 195, "changes": 776, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7042fe5ef83ff0585eb91144817105f26d566d4c/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7042fe5ef83ff0585eb91144817105f26d566d4c/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=7042fe5ef83ff0585eb91144817105f26d566d4c", "patch": "@@ -105,6 +105,11 @@\n    (UNSPEC_BPERM\t\t51)\n    (UNSPEC_COPYSIGN\t\t52)\n    (UNSPEC_PARITY\t\t53)\n+   (UNSPEC_FCTIW\t\t54)\n+   (UNSPEC_FCTID\t\t55)\n+   (UNSPEC_LFIWAX\t\t56)\n+   (UNSPEC_LFIWZX\t\t57)\n+   (UNSPEC_FCTIWUZ\t\t58)\n   ])\n \n ;;\n@@ -252,13 +257,19 @@\n \t\t\t    (DI \"di\")])\n \n (define_mode_attr rreg [(SF   \"f\")\n-\t\t\t(DF   \"Ws\")\n-\t\t\t(V4SF \"Wf\")\n-\t\t\t(V2DF \"Wd\")])\n+\t\t\t(DF   \"ws\")\n+\t\t\t(V4SF \"wf\")\n+\t\t\t(V2DF \"wd\")])\n \n (define_mode_attr rreg2 [(SF   \"f\")\n \t\t\t (DF   \"d\")])\n \n+(define_mode_attr SI_CONVERT_FP [(SF \"TARGET_FCFIDS\")\n+\t\t\t\t (DF \"TARGET_FCFID\")])\n+\n+(define_mode_attr E500_CONVERT [(SF \"!TARGET_FPRS\")\n+\t\t\t\t(DF \"TARGET_E500_DOUBLE\")])\n+\n (define_mode_attr TARGET_FLOAT [(SF \"TARGET_SINGLE_FLOAT\")\n \t\t\t\t(DF \"TARGET_DOUBLE_FLOAT\")])\n \f\n@@ -6424,29 +6435,149 @@\n \f\n ;; Conversions to and from floating-point.\n \n-(define_expand \"fixuns_truncsfsi2\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(unsigned_fix:SI (match_operand:SF 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT && !TARGET_FPRS && TARGET_SINGLE_FLOAT\"\n-  \"\")\n+; We don't define lfiwax/lfiwzx with the normal definition, because we\n+; don't want to support putting SImode in FPR registers.\n+(define_insn \"lfiwax\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=d\")\n+\t(unspec:DI [(match_operand:SI 1 \"indexed_or_indirect_operand\" \"Z\")]\n+\t\t   UNSPEC_LFIWAX))]\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_LFIWAX\"\n+  \"lfiwax %0,%y1\"\n+  [(set_attr \"type\" \"fpload\")])\n+\n+(define_insn_and_split \"floatsi<mode>2_lfiwax\"\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<rreg2>,<rreg2>\")\n+\t(float:SFDF (match_operand:SI 1 \"nonimmediate_operand\" \"Z,r\")))\n+   (clobber (match_operand:SI 2 \"indexed_or_indirect_operand\" \"=Z,Z\"))\n+   (clobber (match_operand:DI 3 \"gpc_reg_operand\" \"=d,d\"))]\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_LFIWAX\n+   && <SI_CONVERT_FP>\"\n+  \"#\"\n+  \"MEM_P (operands[1]) || reload_completed\"\n+  [(pc)]\n+  \"\n+{\n+  if (MEM_P (operands[1]))\n+    {\n+      operands[1] = rs6000_address_for_fpconvert (operands[1]);\n+      emit_insn (gen_lfiwax (operands[3], operands[1]));\n+    }\n+  else\n+    {\n+      emit_move_insn (operands[2], operands[1]);\n+      emit_insn (gen_lfiwax (operands[3], operands[2]));\n+    }\n+  emit_insn (gen_floatdi<mode>2 (operands[0], operands[3]));\n+  DONE;\n+}\"\n+  [(set_attr \"length\" \"8,12\")])\n \n-(define_expand \"fix_truncsfsi2\"\n- [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-      (fix:SI (match_operand:SF 1 \"gpc_reg_operand\" \"\")))]\n- \"TARGET_HARD_FLOAT && !TARGET_FPRS && TARGET_SINGLE_FLOAT\"\n- \"\")\n+(define_insn_and_split \"floatsi<mode>2_lfiwax_mem\"\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<rreg2>\")\n+\t(float:SFDF (match_operand:SI 1 \"memory_operand\" \"Z\")))\n+   (clobber (match_scratch:DI 2 \"=d\"))]\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_LFIWAX\n+   && <SI_CONVERT_FP>\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(pc)]\n+  \"\n+{\n+  emit_insn (gen_lfiwax (operands[2], operands[1]));\n+  emit_insn (gen_floatdi<mode>2 (operands[0], operands[2]));\n+  DONE;\n+}\"\n+  [(set_attr \"length\" \"8\")])\n \n-(define_expand \"fixuns_truncdfsi2\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(unsigned_fix:SI (match_operand:DF 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_E500_DOUBLE\"\n-  \"\")\n+(define_insn_and_split \"floatsi<mode>2_lfiwax_mem2\"\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<rreg2>\")\n+\t(float:SFDF\n+\t (sign_extend:DI\n+\t  (match_operand:SI 1 \"memory_operand\" \"Z\"))))\n+   (clobber (match_scratch:DI 2 \"=d\"))]\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_LFIWAX\n+   && <SI_CONVERT_FP>\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(pc)]\n+  \"\n+{\n+  emit_insn (gen_lfiwax (operands[2], operands[1]));\n+  emit_insn (gen_floatdi<mode>2 (operands[0], operands[2]));\n+  DONE;\n+}\"\n+  [(set_attr \"length\" \"8\")])\n \n-(define_expand \"fixuns_truncdfdi2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(unsigned_fix:DI (match_operand:DF 1 \"register_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_VSX\"\n-  \"\")\n+(define_insn \"lfiwzx\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=d\")\n+\t(unspec:DI [(match_operand:SI 1 \"indexed_or_indirect_operand\" \"Z\")]\n+\t\t   UNSPEC_LFIWZX))]\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_LFIWZX\"\n+  \"lfiwzx %0,%y1\"\n+  [(set_attr \"type\" \"fpload\")])\n+\n+(define_insn_and_split \"floatunssi<mode>2_lfiwzx\"\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<rreg2>,<rreg2>\")\n+\t(unsigned_float:SFDF (match_operand:SI 1 \"gpc_reg_operand\" \"Z,r\")))\n+   (clobber (match_operand:SI 2 \"indexed_or_indirect_operand\" \"=Z,Z\"))\n+   (clobber (match_operand:DI 3 \"gpc_reg_operand\" \"=d,d\"))]\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_LFIWZX\n+   && <SI_CONVERT_FP>\"\n+  \"#\"\n+  \"MEM_P (operands[1]) || reload_completed\"\n+  [(pc)]\n+  \"\n+{\n+  if (MEM_P (operands[1]))\n+    {\n+      operands[1] = rs6000_address_for_fpconvert (operands[1]);\n+      emit_insn (gen_lfiwzx (operands[3], operands[1]));\n+    }\n+  else\n+    {\n+      emit_move_insn (operands[2], operands[1]);\n+      emit_insn (gen_lfiwzx (operands[3], operands[2]));\n+    }\n+  emit_insn (gen_floatdi<mode>2 (operands[0], operands[3]));\n+  DONE;\n+}\"\n+  [(set_attr \"length\" \"8,12\")])\n+\n+(define_insn_and_split \"floatunssi<mode>2_lfiwzx_mem\"\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<rreg2>\")\n+\t(unsigned_float:SFDF (match_operand:SI 1 \"memory_operand\" \"Z\")))\n+   (clobber (match_scratch:DI 2 \"=d\"))]\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_LFIWZX\n+   && <SI_CONVERT_FP>\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(pc)]\n+  \"\n+{\n+  emit_insn (gen_lfiwzx (operands[2], operands[1]));\n+  emit_insn (gen_floatdi<mode>2 (operands[0], operands[2]));\n+  DONE;\n+}\"\n+  [(set_attr \"length\" \"8\")])\n+\n+(define_insn_and_split \"floatunssi<mode>2_lfiwzx_mem2\"\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<rreg2>\")\n+\t(unsigned_float:SFDF\n+\t (zero_extend:DI\n+\t  (match_operand:SI 1 \"memory_operand\" \"Z\"))))\n+   (clobber (match_scratch:DI 2 \"=d\"))]\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_LFIWZX\n+   && <SI_CONVERT_FP>\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(pc)]\n+  \"\n+{\n+  emit_insn (gen_lfiwzx (operands[2], operands[1]));\n+  emit_insn (gen_floatdi<mode>2 (operands[0], operands[2]));\n+  DONE;\n+}\"\n+  [(set_attr \"length\" \"8\")])\n \n ; For each of these conversions, there is a define_expand, a define_insn\n ; with a '#' template, and a define_split (with C code).  The idea is\n@@ -6455,7 +6586,7 @@\n \n (define_expand \"floatsidf2\"\n   [(parallel [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n-\t\t   (float:DF (match_operand:SI 1 \"gpc_reg_operand\" \"\")))\n+\t\t   (float:DF (match_operand:SI 1 \"nonimmediate_operand\" \"\")))\n \t      (use (match_dup 2))\n \t      (use (match_dup 3))\n \t      (clobber (match_dup 4))\n@@ -6467,19 +6598,31 @@\n {\n   if (TARGET_E500_DOUBLE)\n     {\n+      if (!REG_P (operands[1]))\n+\toperands[1] = force_reg (SImode, operands[1]);\n       emit_insn (gen_spe_floatsidf2 (operands[0], operands[1]));\n       DONE;\n     }\n-  if (TARGET_POWERPC64)\n+  else if (TARGET_LFIWAX && TARGET_FCFID)\n+    {\n+      rs6000_expand_convert_si_to_sfdf (operands[0], operands[1], false);\n+      DONE;\n+    }\n+  else if (TARGET_FCFID)\n     {\n-      rtx x = convert_to_mode (DImode, operands[1], 0);\n-      emit_insn (gen_floatdidf2 (operands[0], x));\n+      rtx dreg = operands[1];\n+      if (!REG_P (dreg))\n+\tdreg = force_reg (SImode, dreg);\n+      dreg = convert_to_mode (DImode, dreg, false);\n+      emit_insn (gen_floatdidf2 (operands[0], dreg));\n       DONE;\n     }\n \n+  if (!REG_P (operands[1]))\n+    operands[1] = force_reg (SImode, operands[1]);\n   operands[2] = force_reg (SImode, GEN_INT (0x43300000));\n   operands[3] = force_reg (DFmode, CONST_DOUBLE_ATOF (\\\"4503601774854144\\\", DFmode));\n-  operands[4] = assign_stack_temp (DFmode, GET_MODE_SIZE (DFmode), 0);\n+  operands[4] = rs6000_allocate_stack_temp (DFmode, true, false);\n   operands[5] = gen_reg_rtx (DFmode);\n   operands[6] = gen_reg_rtx (SImode);\n }\")\n@@ -6492,7 +6635,7 @@\n    (clobber (match_operand:DF 4 \"offsettable_mem_operand\" \"=o\"))\n    (clobber (match_operand:DF 5 \"gpc_reg_operand\" \"=&d\"))\n    (clobber (match_operand:SI 6 \"gpc_reg_operand\" \"=&r\"))]\n-  \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\"\n+  \"! TARGET_FCFID && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\"\n   \"#\"\n   \"\"\n   [(pc)]\n@@ -6518,37 +6661,79 @@\n }\"\n   [(set_attr \"length\" \"24\")])\n \n+;; If we don't have a direct conversion to single precision, don't enable this\n+;; conversion for 32-bit without fast math, because we don't have the insn to\n+;; generate the fixup swizzle to avoid double rounding problems.\n (define_expand \"floatunssisf2\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n-        (unsigned_float:SF (match_operand:SI 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT && !TARGET_FPRS && TARGET_SINGLE_FLOAT\"\n-  \"\")\n+        (unsigned_float:SF (match_operand:SI 1 \"nonimmediate_operand\" \"\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT\n+   && (!TARGET_FPRS\n+       || (TARGET_FPRS\n+\t   && ((TARGET_FCFIDUS && TARGET_LFIWZX)\n+\t       || (TARGET_DOUBLE_FLOAT && TARGET_FCFID\n+\t\t   && (TARGET_POWERPC64 || flag_unsafe_math_optimizations)))))\"\n+  \"\n+{\n+  if (!TARGET_FPRS)\n+    {\n+      if (!REG_P (operands[1]))\n+\toperands[1] = force_reg (SImode, operands[1]);\n+    }\n+  else if (TARGET_LFIWZX && TARGET_FCFIDUS)\n+    {\n+      rs6000_expand_convert_si_to_sfdf (operands[0], operands[1], true);\n+      DONE;\n+    }\n+  else\n+    {\n+      rtx dreg = operands[1];\n+      if (!REG_P (dreg))\n+\tdreg = force_reg (SImode, dreg);\n+      dreg = convert_to_mode (DImode, dreg, true);\n+      emit_insn (gen_floatdisf2 (operands[0], dreg));\n+      DONE;\n+    }\n+}\")\n \n (define_expand \"floatunssidf2\"\n   [(parallel [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n-\t\t   (unsigned_float:DF (match_operand:SI 1 \"gpc_reg_operand\" \"\")))\n+\t\t   (unsigned_float:DF (match_operand:SI 1 \"nonimmediate_operand\" \"\")))\n \t      (use (match_dup 2))\n \t      (use (match_dup 3))\n \t      (clobber (match_dup 4))\n \t      (clobber (match_dup 5))])]\n-  \"TARGET_HARD_FLOAT && ((TARGET_FPRS && TARGET_DOUBLE_FLOAT) || TARGET_E500_DOUBLE)\"\n+  \"TARGET_HARD_FLOAT\n+   && ((TARGET_FPRS && TARGET_DOUBLE_FLOAT) || TARGET_E500_DOUBLE)\"\n   \"\n {\n   if (TARGET_E500_DOUBLE)\n     {\n+      if (!REG_P (operands[1]))\n+\toperands[1] = force_reg (SImode, operands[1]);\n       emit_insn (gen_spe_floatunssidf2 (operands[0], operands[1]));\n       DONE;\n     }\n-  if (TARGET_POWERPC64)\n+  else if (TARGET_LFIWZX && TARGET_FCFID)\n     {\n-      rtx x = convert_to_mode (DImode, operands[1], 1);\n-      emit_insn (gen_floatdidf2 (operands[0], x));\n+       rs6000_expand_convert_si_to_sfdf (operands[0], operands[1], true);\n+       DONE;\n+    }\n+  else if (TARGET_FCFID)\n+    {\n+      rtx dreg = operands[1];\n+      if (!REG_P (dreg))\n+\tdreg = force_reg (SImode, dreg);\n+      dreg = convert_to_mode (DImode, dreg, true);\n+      emit_insn (gen_floatdidf2 (operands[0], dreg));\n       DONE;\n     }\n \n+  if (!REG_P (operands[1]))\n+    operands[1] = force_reg (SImode, operands[1]);\n   operands[2] = force_reg (SImode, GEN_INT (0x43300000));\n   operands[3] = force_reg (DFmode, CONST_DOUBLE_ATOF (\\\"4503599627370496\\\", DFmode));\n-  operands[4] = assign_stack_temp (DFmode, GET_MODE_SIZE (DFmode), 0);\n+  operands[4] = rs6000_allocate_stack_temp (DFmode, true, false);\n   operands[5] = gen_reg_rtx (DFmode);\n }\")\n \n@@ -6559,7 +6744,8 @@\n    (use (match_operand:DF 3 \"gpc_reg_operand\" \"d\"))\n    (clobber (match_operand:DF 4 \"offsettable_mem_operand\" \"=o\"))\n    (clobber (match_operand:DF 5 \"gpc_reg_operand\" \"=&d\"))]\n-  \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\"\n+  \"! TARGET_FCFIDU && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n+   && !(TARGET_FCFID && TARGET_POWERPC64)\"\n   \"#\"\n   \"\"\n   [(pc)]\n@@ -6583,46 +6769,85 @@\n }\"\n   [(set_attr \"length\" \"20\")])\n \n-(define_expand \"fix_truncdfsi2\"\n-  [(parallel [(set (match_operand:SI 0 \"fix_trunc_dest_operand\" \"\")\n-\t\t   (fix:SI (match_operand:DF 1 \"gpc_reg_operand\" \"\")))\n-\t      (clobber (match_dup 2))\n-\t      (clobber (match_dup 3))])]\n-  \"(TARGET_POWER2 || TARGET_POWERPC)\n-   && TARGET_HARD_FLOAT && ((TARGET_FPRS && TARGET_DOUBLE_FLOAT) || TARGET_E500_DOUBLE)\"\n+(define_expand \"fix_trunc<mode>si2\"\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n+\t(fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\" \"\")))]\n+  \"(TARGET_POWER2 || TARGET_POWERPC) && TARGET_HARD_FLOAT\n+   && ((TARGET_FPRS && <TARGET_FLOAT>) || <E500_CONVERT>)\"\n   \"\n {\n-  if (TARGET_E500_DOUBLE)\n+  if (!<E500_CONVERT>)\n     {\n-     emit_insn (gen_spe_fix_truncdfsi2 (operands[0], operands[1]));\n-     DONE;\n+      rtx tmp, stack;\n+\n+      if (TARGET_STFIWX)\n+\t{\n+\t  tmp = gen_reg_rtx (DImode);\n+\t  stack = rs6000_allocate_stack_temp (SImode, false, true);\n+\t  emit_insn (gen_fix_trunc<mode>si2_stfiwx (operands[0], operands[1],\n+\t\t\t\t\t\t    tmp, stack));\n+\t}\n+      else\n+\t{\n+\t  tmp = gen_reg_rtx (DImode);\n+\t  stack = rs6000_allocate_stack_temp (DImode, true, false);\n+\t  emit_insn (gen_fix_trunc<mode>si2_internal (operands[0], operands[1],\n+\t\t\t\t\t\t      tmp, stack));\n+\t}\n+      DONE;\n     }\n-  operands[2] = gen_reg_rtx (DImode);\n-  if (TARGET_POWERPC64 && TARGET_MFPGPR && TARGET_HARD_FLOAT && TARGET_FPRS\n-      && gpc_reg_operand(operands[0], GET_MODE (operands[0])))\n+}\")\n+\n+(define_insn_and_split \"fix_trunc<mode>si2_stfiwx\"\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n+\t(fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\" \"<rreg2>\")))\n+   (clobber (match_operand:DI 2 \"gpc_reg_operand\" \"=d\"))\n+   (clobber (match_operand:SI 3 \"indexed_or_indirect_operand\" \"=Z\"))]\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n+   && (<MODE>mode != SFmode || TARGET_SINGLE_FLOAT)\n+   && TARGET_STFIWX\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(pc)]\n+  \"\n+{\n+  emit_insn (gen_fctiwz_<mode> (operands[2], operands[1]));\n+  if (TARGET_MFPGPR && TARGET_POWERPC64 && REG_P (operands[0])\n+      && INT_REGNO_P (REGNO (operands[0])))\n     {\n-      operands[3] = gen_reg_rtx (DImode);\n-      emit_insn (gen_fix_truncdfsi2_mfpgpr (operands[0], operands[1],\n-\t\t\t\t\t    operands[2], operands[3]));\n-      DONE;\n+      rtx reg = gen_lowpart (DImode, operands[0]);\n+      emit_move_insn (reg, operands[2]);\n     }\n-  if (TARGET_PPC_GFXOPT)\n+  else\n     {\n-      rtx orig_dest = operands[0];\n-      if (! memory_operand (orig_dest, GET_MODE (orig_dest)))\n-\toperands[0] = assign_stack_temp (SImode, GET_MODE_SIZE (SImode), 0);\n-      emit_insn (gen_fix_truncdfsi2_internal_gfxopt (operands[0], operands[1],\n-\t\t\t\t\t\t     operands[2]));\n-      if (operands[0] != orig_dest)\n-\temit_move_insn (orig_dest, operands[0]);\n-      DONE;\n+      emit_insn (gen_stfiwx (operands[3], operands[2]));\n+      emit_move_insn (operands[0], operands[3]);\n     }\n-  operands[3] = assign_stack_temp (DImode, GET_MODE_SIZE (DImode), 0);\n-}\")\n+  DONE;\n+}\"\n+  [(set_attr \"length\" \"12\")])\n+\n+(define_insn_and_split \"*fix_trunc<mode>si2_mem\"\n+  [(set (match_operand:SI 0 \"memory_operand\" \"=Z\")\n+\t(fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\" \"<rreg2>\")))\n+   (clobber (match_scratch:DI 2 \"=d\"))]\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n+   && (<MODE>mode != SFmode || TARGET_SINGLE_FLOAT)\n+   && TARGET_STFIWX\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(pc)]\n+  \"\n+{\n+  emit_insn (gen_fctiwz_<mode> (operands[2], operands[1]));\n+  emit_insn (gen_stfiwx (operands[0], operands[2]));\n+  DONE;\n+}\"\n+  [(set_attr \"length\" \"8\")])\n \n-(define_insn_and_split \"*fix_truncdfsi2_internal\"\n+(define_insn_and_split \"fix_trunc<mode>si2_internal\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(fix:SI (match_operand:DF 1 \"gpc_reg_operand\" \"d\")))\n+\t(fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\" \"<rreg>\")))\n    (clobber (match_operand:DI 2 \"gpc_reg_operand\" \"=d\"))\n    (clobber (match_operand:DI 3 \"offsettable_mem_operand\" \"=o\"))]\n   \"(TARGET_POWER2 || TARGET_POWERPC) && TARGET_HARD_FLOAT && TARGET_FPRS \n@@ -6636,143 +6861,194 @@\n   gcc_assert (MEM_P (operands[3]));\n   lowword = adjust_address (operands[3], SImode, WORDS_BIG_ENDIAN ? 4 : 0);\n \n-  emit_insn (gen_fctiwz (operands[2], operands[1]));\n+  emit_insn (gen_fctiwz_<mode> (operands[2], operands[1]));\n   emit_move_insn (operands[3], operands[2]);\n   emit_move_insn (operands[0], lowword);\n   DONE;\n }\"\n   [(set_attr \"length\" \"16\")])\n \n-(define_insn_and_split \"fix_truncdfsi2_internal_gfxopt\"\n+(define_expand \"fix_trunc<mode>di2\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n+\t(fix:DI (match_operand:SFDF 1 \"gpc_reg_operand\" \"\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_FPRS\n+   && TARGET_FCFID\"\n+  \"\")\n+\n+(define_insn \"*fix_trunc<mode>di2_fctidz\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=d\")\n+\t(fix:DI (match_operand:SFDF 1 \"gpc_reg_operand\" \"d\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_FPRS\n+    && TARGET_FCFID && !VECTOR_UNIT_VSX_P (<MODE>mode)\"\n+  \"fctidz %0,%1\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_expand \"fixuns_trunc<mode>si2\"\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n+\t(unsigned_fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\" \"\")))]\n+  \"TARGET_HARD_FLOAT\n+   && ((TARGET_FPRS && <TARGET_FLOAT> && TARGET_FCTIWUZ && TARGET_STFIWX)\n+       || <E500_CONVERT>)\"\n+  \"\n+{\n+  if (!<E500_CONVERT>)\n+    {\n+      rtx tmp = gen_reg_rtx (DImode);\n+      rtx stack = rs6000_allocate_stack_temp (SImode, false, true);\n+      emit_insn (gen_fixuns_trunc<mode>si2_stfiwx (operands[0], operands[1],\n+\t\t\t\t\t\t   tmp, stack));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn_and_split \"fixuns_trunc<mode>si2_stfiwx\"\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n+\t(unsigned_fix:SI\n+\t (match_operand:SFDF 1 \"gpc_reg_operand\" \"<rreg2>\")))\n+   (clobber (match_operand:DI 2 \"gpc_reg_operand\" \"=d\"))\n+   (clobber (match_operand:SI 3 \"indexed_or_indirect_operand\" \"=Z\"))]\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS && <TARGET_FLOAT> && TARGET_FCTIWUZ\n+   && TARGET_STFIWX\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(pc)]\n+  \"\n+{\n+  emit_insn (gen_fctiwuz_<mode> (operands[2], operands[1]));\n+  if (TARGET_MFPGPR && TARGET_POWERPC64 && REG_P (operands[0])\n+      && INT_REGNO_P (REGNO (operands[0])))\n+    {\n+      rtx reg = gen_lowpart (DImode, operands[0]);\n+      emit_move_insn (reg, operands[2]);\n+    }\n+  else\n+    {\n+      emit_insn (gen_stfiwx (operands[3], operands[2]));\n+      emit_move_insn (operands[0], operands[3]);\n+    }\n+  DONE;\n+}\"\n+  [(set_attr \"length\" \"12\")])\n+\n+(define_insn_and_split \"*fixuns_trunc<mode>si2_mem\"\n   [(set (match_operand:SI 0 \"memory_operand\" \"=Z\")\n-\t(fix:SI (match_operand:DF 1 \"gpc_reg_operand\" \"d\")))\n-   (clobber (match_operand:DI 2 \"gpc_reg_operand\" \"=d\"))]\n-  \"(TARGET_POWER2 || TARGET_POWERPC) && TARGET_HARD_FLOAT && TARGET_FPRS \n-   && TARGET_DOUBLE_FLOAT \n-   && TARGET_PPC_GFXOPT\"\n+\t(unsigned_fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\" \"<rreg2>\")))\n+   (clobber (match_scratch:DI 2 \"=d\"))]\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS && <TARGET_FLOAT> && TARGET_FCTIWUZ\n+   && TARGET_STFIWX\"\n   \"#\"\n-  \"&& 1\"\n+  \"&& reload_completed\"\n   [(pc)]\n   \"\n {\n-  emit_insn (gen_fctiwz (operands[2], operands[1]));\n+  emit_insn (gen_fctiwuz_<mode> (operands[2], operands[1]));\n   emit_insn (gen_stfiwx (operands[0], operands[2]));\n   DONE;\n }\"\n-  [(set_attr \"length\" \"16\")])\n+  [(set_attr \"length\" \"8\")])\n \n-(define_insn_and_split \"fix_truncdfsi2_mfpgpr\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(fix:SI (match_operand:DF 1 \"gpc_reg_operand\" \"d\")))\n-   (clobber (match_operand:DI 2 \"gpc_reg_operand\" \"=d\"))\n-   (clobber (match_operand:DI 3 \"gpc_reg_operand\" \"=r\"))]\n-  \"TARGET_POWERPC64 && TARGET_MFPGPR && TARGET_HARD_FLOAT && TARGET_FPRS \n-   && TARGET_DOUBLE_FLOAT\"\n-  \"#\"\n-  \"&& 1\"\n-  [(set (match_dup 2) (unspec:DI [(fix:SI (match_dup 1))] UNSPEC_FCTIWZ))\n-   (set (match_dup 3) (match_dup 2))\n-   (set (match_dup 0) (subreg:SI (match_dup 3) 4))]\n-  \"\"\n-  [(set_attr \"length\" \"12\")])\n+(define_expand \"fixuns_trunc<mode>di2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(unsigned_fix:DI (match_operand:SFDF 1 \"register_operand\" \"\")))]\n+  \"TARGET_HARD_FLOAT && (TARGET_FCTIDUZ || VECTOR_UNIT_VSX_P (<MODE>mode))\"\n+  \"\")\n+\n+(define_insn \"*fixuns_trunc<mode>di2_fctiduz\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=d\")\n+\t(unsigned_fix:DI (match_operand:SFDF 1 \"gpc_reg_operand\" \"d\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_FPRS\n+    && TARGET_FCTIDUZ && !VECTOR_UNIT_VSX_P (<MODE>mode)\"\n+  \"fctiduz %0,%1\"\n+  [(set_attr \"type\" \"fp\")])\n \n ; Here, we use (set (reg) (unspec:DI [(fix:SI ...)] UNSPEC_FCTIWZ))\n ; rather than (set (subreg:SI (reg)) (fix:SI ...))\n ; because the first makes it clear that operand 0 is not live\n ; before the instruction.\n-(define_insn \"fctiwz\"\n+(define_insn \"fctiwz_<mode>\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=d\")\n-\t(unspec:DI [(fix:SI (match_operand:DF 1 \"gpc_reg_operand\" \"d\"))]\n+\t(unspec:DI [(fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\" \"d\"))]\n \t\t   UNSPEC_FCTIWZ))]\n   \"(TARGET_POWER2 || TARGET_POWERPC) && TARGET_HARD_FLOAT && TARGET_FPRS \n    && TARGET_DOUBLE_FLOAT\"\n   \"{fcirz|fctiwz} %0,%1\"\n   [(set_attr \"type\" \"fp\")])\n \n-(define_expand \"btruncdf2\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d\")\n-\t(unspec:DF [(match_operand:DF 1 \"gpc_reg_operand\" \"d\")] UNSPEC_FRIZ))]\n-  \"TARGET_FPRND && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\"\n-  \"\")\n-\n-(define_insn \"*btruncdf2_fpr\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=f\")\n-\t(unspec:DF [(match_operand:DF 1 \"gpc_reg_operand\" \"f\")] UNSPEC_FRIZ))]\n-  \"TARGET_FPRND && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n-   && !VECTOR_UNIT_VSX_P (DFmode)\"\n-  \"friz %0,%1\"\n+(define_insn \"fctiwuz_<mode>\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=d\")\n+\t(unspec:DI [(unsigned_fix:SI\n+\t\t     (match_operand:SFDF 1 \"gpc_reg_operand\" \"<rreg2>\"))]\n+\t\t   UNSPEC_FCTIWUZ))]\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS && <TARGET_FLOAT> && TARGET_FCTIWUZ\"\n+  \"fctiwuz %0,%1\"\n   [(set_attr \"type\" \"fp\")])\n \n-(define_insn \"btruncsf2\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(unspec:SF [(match_operand:SF 1 \"gpc_reg_operand\" \"f\")] UNSPEC_FRIZ))]\n-  \"TARGET_FPRND && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\"\n-  \"friz %0,%1\"\n+;; No VSX equivalent to fctid\n+(define_insn \"lrint<mode>di2\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=d\")\n+\t(unspec:DI [(match_operand:SFDF 1 \"gpc_reg_operand\" \"<rreg2>\")]\n+\t\t   UNSPEC_FCTID))]\n+  \"TARGET_FPRND && TARGET_HARD_FLOAT && TARGET_FPRS && <TARGET_FLOAT>\"\n+  \"fctid %0,%1\"\n   [(set_attr \"type\" \"fp\")])\n \n-(define_expand \"ceildf2\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n-\t(unspec:DF [(match_operand:DF 1 \"gpc_reg_operand\" \"\")] UNSPEC_FRIP))]\n-  \"TARGET_FPRND && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\"\n+(define_expand \"btrunc<mode>2\"\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"\")\n+\t(unspec:SFDF [(match_operand:SFDF 1 \"gpc_reg_operand\" \"\")]\n+\t\t     UNSPEC_FRIZ))]\n+  \"TARGET_FPRND && TARGET_HARD_FLOAT && TARGET_FPRS && <TARGET_FLOAT>\"\n   \"\")\n \n-(define_insn \"*ceildf2_fpr\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d\")\n-\t(unspec:DF [(match_operand:DF 1 \"gpc_reg_operand\" \"d\")] UNSPEC_FRIP))]\n-  \"TARGET_FPRND && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n-   && !VECTOR_UNIT_VSX_P (DFmode)\"\n-  \"frip %0,%1\"\n+(define_insn \"*btrunc<mode>2_fpr\"\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<rreg2>\")\n+\t(unspec:SFDF [(match_operand:SFDF 1 \"gpc_reg_operand\" \"<rreg2>\")]\n+\t\t     UNSPEC_FRIZ))]\n+  \"TARGET_FPRND && TARGET_HARD_FLOAT && TARGET_FPRS && <TARGET_FLOAT>\n+   && !VECTOR_UNIT_VSX_P (<MODE>mode)\"\n+  \"friz %0,%1\"\n   [(set_attr \"type\" \"fp\")])\n \n-(define_insn \"ceilsf2\"\n- [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(unspec:SF [(match_operand:SF 1 \"gpc_reg_operand\" \"f\")] UNSPEC_FRIP))]\n-  \"TARGET_FPRND && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT \"\n+(define_expand \"ceil<mode>2\"\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"\")\n+\t(unspec:SFDF [(match_operand:SFDF 1 \"gpc_reg_operand\" \"\")]\n+\t\t     UNSPEC_FRIP))]\n+  \"TARGET_FPRND && TARGET_HARD_FLOAT && TARGET_FPRS && <TARGET_FLOAT>\"\n+  \"\")\n+\n+(define_insn \"*ceil<mode>2_fpr\"\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<rreg2>\")\n+\t(unspec:SFDF [(match_operand:SFDF 1 \"gpc_reg_operand\" \"<rreg2>\")]\n+\t\t     UNSPEC_FRIP))]\n+  \"TARGET_FPRND && TARGET_HARD_FLOAT && TARGET_FPRS && <TARGET_FLOAT>\n+   && !VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"frip %0,%1\"\n   [(set_attr \"type\" \"fp\")])\n \n-(define_expand \"floordf2\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n-\t(unspec:DF [(match_operand:DF 1 \"gpc_reg_operand\" \"\")] UNSPEC_FRIM))]\n-  \"TARGET_FPRND && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\"\n+(define_expand \"floor<mode>2\"\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"\")\n+\t(unspec:SFDF [(match_operand:SFDF 1 \"gpc_reg_operand\" \"\")]\n+\t\t     UNSPEC_FRIM))]\n+  \"TARGET_FPRND && TARGET_HARD_FLOAT && TARGET_FPRS && <TARGET_FLOAT>\"\n   \"\")\n \n-(define_insn \"*floordf2_fpr\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d\")\n-\t(unspec:DF [(match_operand:DF 1 \"gpc_reg_operand\" \"d\")] UNSPEC_FRIM))]\n-  \"TARGET_FPRND && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n-   && !VECTOR_UNIT_VSX_P (DFmode)\"\n-  \"frim %0,%1\"\n-  [(set_attr \"type\" \"fp\")])\n-\n-(define_insn \"floorsf2\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(unspec:SF [(match_operand:SF 1 \"gpc_reg_operand\" \"f\")] UNSPEC_FRIM))]\n-  \"TARGET_FPRND && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT \"\n+(define_insn \"*floor<mode>2_fpr\"\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<rreg2>\")\n+\t(unspec:SFDF [(match_operand:SFDF 1 \"gpc_reg_operand\" \"<rreg2>\")]\n+\t\t     UNSPEC_FRIM))]\n+  \"TARGET_FPRND && TARGET_HARD_FLOAT && TARGET_FPRS && <TARGET_FLOAT>\n+   && !VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"frim %0,%1\"\n   [(set_attr \"type\" \"fp\")])\n \n ;; No VSX equivalent to frin\n-(define_insn \"rounddf2\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d\")\n-\t(unspec:DF [(match_operand:DF 1 \"gpc_reg_operand\" \"d\")] UNSPEC_FRIN))]\n-  \"TARGET_FPRND && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\"\n-  \"frin %0,%1\"\n-  [(set_attr \"type\" \"fp\")])\n-\n-(define_insn \"roundsf2\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(unspec:SF [(match_operand:SF 1 \"gpc_reg_operand\" \"f\")] UNSPEC_FRIN))]\n-  \"TARGET_FPRND && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT \"\n+(define_insn \"round<mode>2\"\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<rreg2>\")\n+\t(unspec:SFDF [(match_operand:SFDF 1 \"gpc_reg_operand\" \"<rreg2>\")]\n+\t\t     UNSPEC_FRIN))]\n+  \"TARGET_FPRND && TARGET_HARD_FLOAT && TARGET_FPRS && <TARGET_FLOAT>\"\n   \"frin %0,%1\"\n   [(set_attr \"type\" \"fp\")])\n \n-(define_expand \"ftruncdf2\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n-  \t(fix:DF (match_operand:DF 1 \"gpc_reg_operand\" \"\")))]\n-  \"VECTOR_UNIT_VSX_P (DFmode)\"\n-  \"\")\n-\n ; An UNSPEC is used so we don't have to support SImode in FP registers.\n (define_insn \"stfiwx\"\n   [(set (match_operand:SI 0 \"memory_operand\" \"=Z\")\n@@ -6782,76 +7058,154 @@\n   \"stfiwx %1,%y0\"\n   [(set_attr \"type\" \"fpstore\")])\n \n+;; If we don't have a direct conversion to single precision, don't enable this\n+;; conversion for 32-bit without fast math, because we don't have the insn to\n+;; generate the fixup swizzle to avoid double rounding problems.\n (define_expand \"floatsisf2\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n-        (float:SF (match_operand:SI 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT && !TARGET_FPRS\"\n-  \"\")\n+        (float:SF (match_operand:SI 1 \"nonimmediate_operand\" \"\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT\n+   && (!TARGET_FPRS\n+       || (TARGET_FPRS\n+\t   && ((TARGET_FCFIDS && TARGET_LFIWAX)\n+\t       || (TARGET_DOUBLE_FLOAT && TARGET_FCFID\n+\t\t   && (TARGET_POWERPC64 || flag_unsafe_math_optimizations)))))\"\n+  \"\n+{\n+  if (!TARGET_FPRS)\n+    {\n+      if (!REG_P (operands[1]))\n+\toperands[1] = force_reg (SImode, operands[1]);\n+    }\n+  else if (TARGET_FCFIDS && TARGET_LFIWAX)\n+    {\n+      rs6000_expand_convert_si_to_sfdf (operands[0], operands[1], false);\n+      DONE;\n+    }\n+  else\n+    {\n+      rtx dreg = operands[1];\n+      if (!REG_P (dreg))\n+\tdreg = force_reg (SImode, dreg);\n+      dreg = convert_to_mode (DImode, dreg, false);\n+      emit_insn (gen_floatdisf2 (operands[0], dreg));\n+      DONE;\n+    }\n+}\")\n \n (define_expand \"floatdidf2\"\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n \t(float:DF (match_operand:DI 1 \"gpc_reg_operand\" \"\")))]\n-  \"(TARGET_POWERPC64 || TARGET_XILINX_FPU || VECTOR_UNIT_VSX_P (DFmode))\n-   && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_FPRS\"\n+  \"TARGET_FCFID && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_FPRS\"\n   \"\")\n \n (define_insn \"*floatdidf2_fpr\"\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d\")\n-\t(float:DF (match_operand:DI 1 \"gpc_reg_operand\" \"!d#r\")))]\n-  \"(TARGET_POWERPC64 || TARGET_XILINX_FPU)\n-   && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_FPRS\n+\t(float:DF (match_operand:DI 1 \"gpc_reg_operand\" \"d\")))]\n+  \"TARGET_FCFID && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_FPRS\n    && !VECTOR_UNIT_VSX_P (DFmode)\"\n   \"fcfid %0,%1\"\n   [(set_attr \"type\" \"fp\")])\n \n+; Allow the combiner to merge source memory operands to the conversion so that\n+; the optimizer/register allocator doesn't try to load the value too early in a\n+; GPR and then use store/load to move it to a FPR and suffer from a store-load\n+; hit.  We will split after reload to avoid the trip through the GPRs\n+\n+(define_insn_and_split \"*floatdidf2_mem\"\n+  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d\")\n+\t(float:DF (match_operand:DI 1 \"memory_operand\" \"m\")))\n+   (clobber (match_scratch:DI 2 \"=d\"))]\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_FPRS && TARGET_FCFID\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 2) (match_dup 1))\n+   (set (match_dup 0) (float:DF (match_dup 2)))]\n+  \"\"\n+  [(set_attr \"length\" \"8\")])\n+\n (define_expand \"floatunsdidf2\"\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n-\t(unsigned_float:DF (match_operand:DI 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_VSX\"\n+\t(unsigned_float:DF\n+\t (match_operand:DI 1 \"gpc_reg_operand\" \"\")))]\n+  \"TARGET_FCFIDU || VECTOR_UNIT_VSX_P (DFmode)\"\n   \"\")\n \n-(define_expand \"fix_truncdfdi2\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t(fix:DI (match_operand:DF 1 \"gpc_reg_operand\" \"\")))]\n-  \"(TARGET_POWERPC64 || TARGET_XILINX_FPU || VECTOR_UNIT_VSX_P (DFmode))\n-    && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_FPRS\"\n-  \"\")\n+(define_insn \"*floatunsdidf2_fcfidu\"\n+  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d\")\n+\t(unsigned_float:DF (match_operand:DI 1 \"gpc_reg_operand\" \"d\")))]\n+  \"TARGET_FCFIDU && !VECTOR_UNIT_VSX_P (DFmode)\"\n+  \"fcfidu %0,%1\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"length\" \"4\")])\n \n-(define_insn \"*fix_truncdfdi2_fpr\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=!d#r\")\n-\t(fix:DI (match_operand:DF 1 \"gpc_reg_operand\" \"d\")))]\n-  \"(TARGET_POWERPC64 || TARGET_XILINX_FPU)\n-    && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_FPRS\n-    && !VECTOR_UNIT_VSX_P (DFmode)\"\n-  \"fctidz %0,%1\"\n-  [(set_attr \"type\" \"fp\")])\n+(define_insn_and_split \"*floatunsdidf2_mem\"\n+  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d\")\n+\t(unsigned_float:DF (match_operand:DI 1 \"memory_operand\" \"m\")))\n+   (clobber (match_scratch:DI 2 \"=d\"))]\n+  \"TARGET_FCFIDU || VECTOR_UNIT_VSX_P (DFmode)\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 2) (match_dup 1))\n+   (set (match_dup 0) (unsigned_float:DF (match_dup 2)))]\n+  \"\"\n+  [(set_attr \"length\" \"8\")])\n \n (define_expand \"floatdisf2\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n         (float:SF (match_operand:DI 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_POWERPC64 && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT \"\n+  \"TARGET_FCFID && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\n+   && (TARGET_FCFIDS || TARGET_POWERPC64 || flag_unsafe_math_optimizations)\"\n   \"\n {\n-  rtx val = operands[1];\n-  if (!flag_unsafe_math_optimizations)\n+  if (!TARGET_FCFIDS)\n     {\n-      rtx label = gen_label_rtx ();\n-      val = gen_reg_rtx (DImode);\n-      emit_insn (gen_floatdisf2_internal2 (val, operands[1], label));\n-      emit_label (label);\n+      rtx val = operands[1];\n+      if (!flag_unsafe_math_optimizations)\n+\t{\n+\t  rtx label = gen_label_rtx ();\n+\t  val = gen_reg_rtx (DImode);\n+\t  emit_insn (gen_floatdisf2_internal2 (val, operands[1], label));\n+\t  emit_label (label);\n+\t}\n+      emit_insn (gen_floatdisf2_internal1 (operands[0], val));\n+      DONE;\n     }\n-  emit_insn (gen_floatdisf2_internal1 (operands[0], val));\n-  DONE;\n }\")\n \n+(define_insn \"floatdisf2_fcfids\"\n+  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n+\t(float:SF (match_operand:DI 1 \"gpc_reg_operand\" \"d\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\n+   && TARGET_DOUBLE_FLOAT && TARGET_FCFIDS\"\n+  \"fcfids %0,%1\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn_and_split \"*floatdisf2_mem\"\n+  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n+\t(float:SF (match_operand:DI 1 \"memory_operand\" \"m\")))\n+   (clobber (match_scratch:DI 2 \"=f\"))]\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\n+   && TARGET_DOUBLE_FLOAT && TARGET_FCFIDS\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(pc)]\n+  \"\n+{\n+  emit_move_insn (operands[2], operands[1]);\n+  emit_insn (gen_floatdisf2_fcfids (operands[0], operands[2]));\n+  DONE;\n+}\"\n+  [(set_attr \"length\" \"8\")])\n+\n ;; This is not IEEE compliant if rounding mode is \"round to nearest\".\n ;; If the DI->DF conversion is inexact, then it's possible to suffer\n ;; from double rounding.\n (define_insn_and_split \"floatdisf2_internal1\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n-        (float:SF (match_operand:DI 1 \"gpc_reg_operand\" \"!d#r\")))\n+        (float:SF (match_operand:DI 1 \"gpc_reg_operand\" \"d\")))\n    (clobber (match_scratch:DF 2 \"=d\"))]\n-  \"TARGET_POWERPC64 && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\"\n+  \"TARGET_FCFID && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\"\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 2)\n@@ -6891,6 +7245,38 @@\n   operands[3] = gen_reg_rtx (DImode);\n   operands[4] = gen_reg_rtx (CCUNSmode);\n }\")\n+\n+(define_expand \"floatunsdisf2\"\n+  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n+        (unsigned_float:SF (match_operand:DI 1 \"gpc_reg_operand\" \"\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\n+   && TARGET_DOUBLE_FLOAT && TARGET_FCFIDUS\"\n+  \"\")\n+\n+(define_insn \"floatunsdisf2_fcfidus\"\n+  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n+        (unsigned_float:SF (match_operand:DI 1 \"gpc_reg_operand\" \"d\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\n+   && TARGET_DOUBLE_FLOAT && TARGET_FCFIDUS\"\n+  \"fcfidus %0,%1\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn_and_split \"*floatunsdisf2_mem\"\n+  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n+\t(unsigned_float:SF (match_operand:DI 1 \"memory_operand\" \"m\")))\n+   (clobber (match_scratch:DI 2 \"=f\"))]\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\n+   && TARGET_DOUBLE_FLOAT && TARGET_FCFIDUS\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(pc)]\n+  \"\n+{\n+  emit_move_insn (operands[2], operands[1]);\n+  emit_insn (gen_floatunsdisf2_fcfidus (operands[0], operands[2]));\n+  DONE;\n+}\"\n+  [(set_attr \"length\" \"8\")])\n \f\n ;; Define the DImode operations that can be done in a small number\n ;; of instructions.  The & constraints are to prevent the register\n@@ -9540,7 +9926,7 @@\n   gcc_assert (MEM_P (operands[5]));\n   lowword = adjust_address (operands[5], SImode, WORDS_BIG_ENDIAN ? 4 : 0);\n \n-  emit_insn (gen_fctiwz (operands[4], operands[2]));\n+  emit_insn (gen_fctiwz_df (operands[4], operands[2]));\n   emit_move_insn (operands[5], operands[4]);\n   emit_move_insn (operands[0], lowword);\n   DONE;"}, {"sha": "c6a126bb2cf00b50ed41dec59ead465fde2e0768", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7042fe5ef83ff0585eb91144817105f26d566d4c/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7042fe5ef83ff0585eb91144817105f26d566d4c/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=7042fe5ef83ff0585eb91144817105f26d566d4c", "patch": "@@ -1,5 +1,5 @@\n ;; VSX patterns.\n-;; Copyright (C) 2009\n+;; Copyright (C) 2009, 2010\n ;; Free Software Foundation, Inc.\n ;; Contributed by Michael Meissner <meissner@linux.vnet.ibm.com>\n \n@@ -73,11 +73,11 @@\n ;; Map the register class used for float<->int conversions\n (define_mode_attr VSr2\t[(V2DF  \"wd\")\n \t\t\t (V4SF  \"wf\")\n-\t\t\t (DF    \"!f#r\")])\n+\t\t\t (DF    \"ws\")])\n \n (define_mode_attr VSr3\t[(V2DF  \"wa\")\n \t\t\t (V4SF  \"wa\")\n-\t\t\t (DF    \"!f#r\")])\n+\t\t\t (DF    \"ws\")])\n \n ;; Map the register class for sp<->dp float conversions, destination\n (define_mode_attr VSr4\t[(SF\t\"ws\")"}, {"sha": "959f3fdcf37047eddb31d3e795fcf9d976541f90", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7042fe5ef83ff0585eb91144817105f26d566d4c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7042fe5ef83ff0585eb91144817105f26d566d4c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7042fe5ef83ff0585eb91144817105f26d566d4c", "patch": "@@ -1,3 +1,17 @@\n+2010-08-23  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/ppc-fpconv-1.c: New test for integer to\n+\tfloating point conversion code generation.\n+\t* gcc.target/powerpc/ppc-fpconv-2.c: Ditto.\n+\t* gcc.target/powerpc/ppc-fpconv-3.c: Ditto.\n+\t* gcc.target/powerpc/ppc-fpconv-4.c: Ditto.\n+\t* gcc.target/powerpc/ppc-fpconv-5.c: New test for floating point\n+\tto integer conversion code generation.\n+\t* gcc.target/powerpc/ppc-fpconv-6.c: Ditto.\n+\t* gcc.target/powerpc/ppc-fpconv-7.c: Ditto.\n+\t* gcc.target/powerpc/ppc-fpconv-8.c: Ditto.\n+\t* gcc.target/powerpc/ppc-fpconv-9.c: Ditto.\n+\n 2010-08-27  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \tPR fortran/32049"}, {"sha": "8a6cc08b90919d1e8b42c780c4f44f4ad62d3f4c", "filename": "gcc/testsuite/gcc.target/powerpc/ppc-fpconv-1.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7042fe5ef83ff0585eb91144817105f26d566d4c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7042fe5ef83ff0585eb91144817105f26d566d4c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-1.c?ref=7042fe5ef83ff0585eb91144817105f26d566d4c", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-O2 -mcpu=power7 -ffast-math\" } */\n+/* { dg-final { scan-assembler-times \"lfiwax\" 2 } } */\n+/* { dg-final { scan-assembler-times \"lfiwzx\" 2 } } */\n+/* { dg-final { scan-assembler-times \"fcfids\" 3 } } */\n+/* { dg-final { scan-assembler-times \"fcfidus\" 1 } } */\n+/* { dg-final { scan-assembler-times \"xscvsxddp\" 3 } } */\n+/* { dg-final { scan-assembler-times \"xscvuxddp\" 1 } } */\n+\n+void int_to_float (float *dest, int *src)\n+{\n+  *dest = (float) *src;\n+}\n+\n+void int_to_double (double *dest, int *src)\n+{\n+  *dest = (double) *src;\n+}\n+\n+void uint_to_float (float *dest, unsigned int *src)\n+{\n+  *dest = (float) *src;\n+}\n+\n+void uint_to_double (double *dest, unsigned int *src)\n+{\n+  *dest = (double) *src;\n+}\n+\n+void llong_to_float (float *dest, long long *src)\n+{\n+  *dest = (float) *src;\n+}\n+\n+void llong_to_double (double *dest, long long *src)\n+{\n+  *dest = (double) *src;\n+}\n+\n+void ullong_to_float (float *dest, unsigned long long *src)\n+{\n+  *dest = (float) *src;\n+}\n+\n+void ullong_to_double (double *dest, unsigned long long *src)\n+{\n+  *dest = (double) *src;\n+}"}, {"sha": "f90a35be6ea4840304a7858deb6fc15e49aa6cb9", "filename": "gcc/testsuite/gcc.target/powerpc/ppc-fpconv-2.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7042fe5ef83ff0585eb91144817105f26d566d4c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7042fe5ef83ff0585eb91144817105f26d566d4c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-2.c?ref=7042fe5ef83ff0585eb91144817105f26d566d4c", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-O2 -mcpu=power6 -ffast-math\" } */\n+/* { dg-final { scan-assembler-times \"lfiwax\" 1 } } */\n+/* { dg-final { scan-assembler-not \"lfiwzx\" } } */\n+/* { dg-final { scan-assembler-times \"fcfid \" 10 } } */\n+/* { dg-final { scan-assembler-not \"fcfids\" } } */\n+/* { dg-final { scan-assembler-not \"fcfidus\" } } */\n+/* { dg-final { scan-assembler-not \"xscvsxddp\" } } */\n+/* { dg-final { scan-assembler-not \"xscvuxddp\" } } */\n+\n+void int_to_float (float *dest, int *src)\n+{\n+  *dest = (float) *src;\n+}\n+\n+void int_to_double (double *dest, int *src)\n+{\n+  *dest = (double) *src;\n+}\n+\n+void uint_to_float (float *dest, unsigned int *src)\n+{\n+  *dest = (float) *src;\n+}\n+\n+void uint_to_double (double *dest, unsigned int *src)\n+{\n+  *dest = (double) *src;\n+}\n+\n+void llong_to_float (float *dest, long long *src)\n+{\n+  *dest = (float) *src;\n+}\n+\n+void llong_to_double (double *dest, long long *src)\n+{\n+  *dest = (double) *src;\n+}\n+\n+void ullong_to_float (float *dest, unsigned long long *src)\n+{\n+  *dest = (float) *src;\n+}\n+\n+void ullong_to_double (double *dest, unsigned long long *src)\n+{\n+  *dest = (double) *src;\n+}"}, {"sha": "6196162a2ff45b1a481065a86362607d6908b03a", "filename": "gcc/testsuite/gcc.target/powerpc/ppc-fpconv-3.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7042fe5ef83ff0585eb91144817105f26d566d4c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7042fe5ef83ff0585eb91144817105f26d566d4c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-3.c?ref=7042fe5ef83ff0585eb91144817105f26d566d4c", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target ilp32 } */\n+/* { dg-options \"-O2 -mcpu=power5 -ffast-math\" } */\n+/* { dg-final { scan-assembler-not \"lfiwax\" } } */\n+/* { dg-final { scan-assembler-not \"lfiwzx\" } } */\n+/* { dg-final { scan-assembler-times \"fcfid \" 10 } } */\n+/* { dg-final { scan-assembler-not \"fcfids\" } } */\n+/* { dg-final { scan-assembler-not \"fcfidus\" } } */\n+/* { dg-final { scan-assembler-not \"xscvsxddp\" } } */\n+/* { dg-final { scan-assembler-not \"xscvuxddp\" } } */\n+\n+void int_to_float (float *dest, int *src)\n+{\n+  *dest = (float) *src;\n+}\n+\n+void int_to_double (double *dest, int *src)\n+{\n+  *dest = (double) *src;\n+}\n+\n+void uint_to_float (float *dest, unsigned int *src)\n+{\n+  *dest = (float) *src;\n+}\n+\n+void uint_to_double (double *dest, unsigned int *src)\n+{\n+  *dest = (double) *src;\n+}\n+\n+void llong_to_float (float *dest, long long *src)\n+{\n+  *dest = (float) *src;\n+}\n+\n+void llong_to_double (double *dest, long long *src)\n+{\n+  *dest = (double) *src;\n+}\n+\n+void ullong_to_float (float *dest, unsigned long long *src)\n+{\n+  *dest = (float) *src;\n+}\n+\n+void ullong_to_double (double *dest, unsigned long long *src)\n+{\n+  *dest = (double) *src;\n+}"}, {"sha": "c4b9ea69bf0ff139668fe7523a5da05439f37fc0", "filename": "gcc/testsuite/gcc.target/powerpc/ppc-fpconv-4.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7042fe5ef83ff0585eb91144817105f26d566d4c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7042fe5ef83ff0585eb91144817105f26d566d4c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-4.c?ref=7042fe5ef83ff0585eb91144817105f26d566d4c", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target ilp32 } */\n+/* { dg-options \"-O2 -mcpu=750 -ffast-math\" } */\n+/* { dg-final { scan-assembler-not \"lfiwax\" } } */\n+/* { dg-final { scan-assembler-not \"lfiwzx\" } } */\n+/* { dg-final { scan-assembler-not \"fcfid \" } } */\n+/* { dg-final { scan-assembler-not \"fcfids\" } } */\n+/* { dg-final { scan-assembler-not \"fcfidus\" } } */\n+/* { dg-final { scan-assembler-not \"xscvsxddp\" } } */\n+/* { dg-final { scan-assembler-not \"xscvuxddp\" } } */\n+\n+void int_to_float (float *dest, int *src)\n+{\n+  *dest = (float) *src;\n+}\n+\n+void int_to_double (double *dest, int *src)\n+{\n+  *dest = (double) *src;\n+}\n+\n+void uint_to_float (float *dest, unsigned int *src)\n+{\n+  *dest = (float) *src;\n+}\n+\n+void uint_to_double (double *dest, unsigned int *src)\n+{\n+  *dest = (double) *src;\n+}\n+\n+void llong_to_float (float *dest, long long *src)\n+{\n+  *dest = (float) *src;\n+}\n+\n+void llong_to_double (double *dest, long long *src)\n+{\n+  *dest = (double) *src;\n+}\n+\n+void ullong_to_float (float *dest, unsigned long long *src)\n+{\n+  *dest = (float) *src;\n+}\n+\n+void ullong_to_double (double *dest, unsigned long long *src)\n+{\n+  *dest = (double) *src;\n+}"}, {"sha": "a071fc122920810d79eb0a37a4f45b9c72600ece", "filename": "gcc/testsuite/gcc.target/powerpc/ppc-fpconv-5.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7042fe5ef83ff0585eb91144817105f26d566d4c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7042fe5ef83ff0585eb91144817105f26d566d4c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-5.c?ref=7042fe5ef83ff0585eb91144817105f26d566d4c", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-O3 -mcpu=power7 -ffast-math\" } */\n+/* { dg-final { scan-assembler-times \"fctiwz\" 2 } } */\n+/* { dg-final { scan-assembler-times \"fctiwuz\" 2 } } */\n+/* { dg-final { scan-assembler-times \"fctidz\" 1 } } */\n+/* { dg-final { scan-assembler-times \"fctiduz\" 1 } } */\n+/* { dg-final { scan-assembler-times \"xscvdpsxds\" 1 } } */\n+/* { dg-final { scan-assembler-times \"xscvdpuxds\" 1 } } */\n+\n+void float_to_int  (int *dest, float  src) { *dest = (int) src; }\n+void double_to_int (int *dest, double src) { *dest = (int) src; }\n+\n+void float_to_uint  (int *dest, float  src) { *dest = (unsigned int) src; }\n+void double_to_uint (int *dest, double src) { *dest = (unsigned int) src; }\n+\n+void float_to_llong  (long long *dest, float  src) { *dest = (long long) src; }\n+void double_to_llong (long long *dest, double src) { *dest = (long long) src; }\n+\n+void float_to_ullong  (unsigned long long *dest, float  src) { *dest = (unsigned long long) src; }\n+void double_to_ullong (unsigned long long *dest, double src) { *dest = (unsigned long long) src; }"}, {"sha": "09ee1885a17d7486d09cebc30ae629a9a40ddbec", "filename": "gcc/testsuite/gcc.target/powerpc/ppc-fpconv-6.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7042fe5ef83ff0585eb91144817105f26d566d4c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7042fe5ef83ff0585eb91144817105f26d566d4c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-6.c?ref=7042fe5ef83ff0585eb91144817105f26d566d4c", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-O3 -mcpu=power6 -ffast-math\" } */\n+/* { dg-final { scan-assembler-times \"fctiwz\" 2 } } */\n+/* { dg-final { scan-assembler-not \"fctiwuz\" } } */\n+/* { dg-final { scan-assembler-times \"fctidz\" 8 } } */\n+/* { dg-final { scan-assembler-not \"fctiduz\" } } */\n+/* { dg-final { scan-assembler-not \"xscvdpsxds\" } } */\n+/* { dg-final { scan-assembler-not \"xscvdpuxds\" } } */\n+\n+void float_to_int  (int *dest, float  src) { *dest = (int) src; }\n+void double_to_int (int *dest, double src) { *dest = (int) src; }\n+\n+void float_to_uint  (int *dest, float  src) { *dest = (unsigned int) src; }\n+void double_to_uint (int *dest, double src) { *dest = (unsigned int) src; }\n+\n+void float_to_llong  (long long *dest, float  src) { *dest = (long long) src; }\n+void double_to_llong (long long *dest, double src) { *dest = (long long) src; }\n+\n+void float_to_ullong  (unsigned long long *dest, float  src) { *dest = (unsigned long long) src; }\n+void double_to_ullong (unsigned long long *dest, double src) { *dest = (unsigned long long) src; }"}, {"sha": "007c8644a0c6e22d0dbb2fa9fb513b8e1e9cf2f1", "filename": "gcc/testsuite/gcc.target/powerpc/ppc-fpconv-7.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7042fe5ef83ff0585eb91144817105f26d566d4c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7042fe5ef83ff0585eb91144817105f26d566d4c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-7.c?ref=7042fe5ef83ff0585eb91144817105f26d566d4c", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target ilp32 } */\n+/* { dg-options \"-O3 -mcpu=power5 -ffast-math\" } */\n+/* { dg-final { scan-assembler-times \"fctiwz\" 2 } } */\n+/* { dg-final { scan-assembler-not \"fctiwuz\" } } */\n+/* { dg-final { scan-assembler-times \"fctidz\" 8 } } */\n+/* { dg-final { scan-assembler-not \"fctiduz\" } } */\n+/* { dg-final { scan-assembler-not \"xscvdpsxds\" } } */\n+/* { dg-final { scan-assembler-not \"xscvdpuxds\" } } */\n+\n+void float_to_int  (int *dest, float  src) { *dest = (int) src; }\n+void double_to_int (int *dest, double src) { *dest = (int) src; }\n+\n+void float_to_uint  (int *dest, float  src) { *dest = (unsigned int) src; }\n+void double_to_uint (int *dest, double src) { *dest = (unsigned int) src; }\n+\n+void float_to_llong  (long long *dest, float  src) { *dest = (long long) src; }\n+void double_to_llong (long long *dest, double src) { *dest = (long long) src; }\n+\n+void float_to_ullong  (unsigned long long *dest, float  src) { *dest = (unsigned long long) src; }\n+void double_to_ullong (unsigned long long *dest, double src) { *dest = (unsigned long long) src; }"}, {"sha": "b5410f60ea5f871603473fea17448892df3b8206", "filename": "gcc/testsuite/gcc.target/powerpc/ppc-fpconv-8.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7042fe5ef83ff0585eb91144817105f26d566d4c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7042fe5ef83ff0585eb91144817105f26d566d4c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-8.c?ref=7042fe5ef83ff0585eb91144817105f26d566d4c", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target ilp32 } */\n+/* { dg-options \"-O3 -mcpu=750 -ffast-math\" } */\n+/* { dg-final { scan-assembler-times \"fctiwz\" 6 } } */\n+/* { dg-final { scan-assembler-not \"fctiwuz\" } } */\n+/* { dg-final { scan-assembler-not \"fctidz\" } } */\n+/* { dg-final { scan-assembler-not \"fctiduz\" } } */\n+/* { dg-final { scan-assembler-not \"xscvdpsxds\" } } */\n+/* { dg-final { scan-assembler-not \"xscvdpuxds\" } } */\n+\n+void float_to_int  (int *dest, float  src) { *dest = (int) src; }\n+void double_to_int (int *dest, double src) { *dest = (int) src; }\n+\n+void float_to_uint  (int *dest, float  src) { *dest = (unsigned int) src; }\n+void double_to_uint (int *dest, double src) { *dest = (unsigned int) src; }\n+\n+void float_to_llong  (long long *dest, float  src) { *dest = (long long) src; }\n+void double_to_llong (long long *dest, double src) { *dest = (long long) src; }\n+\n+void float_to_ullong  (unsigned long long *dest, float  src) { *dest = (unsigned long long) src; }\n+void double_to_ullong (unsigned long long *dest, double src) { *dest = (unsigned long long) src; }"}, {"sha": "836c030baa6483e7633ec62ddb8d069e03a3f7f5", "filename": "gcc/testsuite/gcc.target/powerpc/ppc-fpconv-9.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7042fe5ef83ff0585eb91144817105f26d566d4c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7042fe5ef83ff0585eb91144817105f26d566d4c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-9.c?ref=7042fe5ef83ff0585eb91144817105f26d566d4c", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-O3 -mcpu=power7 -ffast-math\" } */\n+/* { dg-final { scan-assembler-not \"lwz\" } } */\n+/* { dg-final { scan-assembler-not \"stw\" } } */\n+/* { dg-final { scan-assembler-not \"ld \" } } */\n+/* { dg-final { scan-assembler-not \"std\" } } */\n+\n+void float_to_llong  (long long *dest, float  src) { *dest = (long long) src; }\n+void double_to_llong (long long *dest, double src) { *dest = (long long) src; }"}]}