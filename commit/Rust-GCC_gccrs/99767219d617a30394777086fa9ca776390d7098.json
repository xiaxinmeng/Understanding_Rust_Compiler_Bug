{"sha": "99767219d617a30394777086fa9ca776390d7098", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTk3NjcyMTlkNjE3YTMwMzk0Nzc3MDg2ZmE5Y2E3NzYzOTBkNzA5OA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-08-30T11:12:28Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:12:28Z"}, "message": "[29/77] Make some *_loc_descriptor helpers take scalar_int_mode\n\nThe *_loc_descriptor routines for clz, popcount, bswap and rotate\nall required SCALAR_INT_MODE_P.  This patch moves the checks into\nthe caller (mem_loc_descriptor) so that the types of the mode\nparameters can be scalar_int_mode instead of machine_mode.\n\nThe MOD handling in mem_loc_descriptor is also specific to\nscalar integer modes.  Adding an explicit check allows\ntyped_binop to take a scalar_int_mode too.\n\n2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* dwarf2out.c (typed_binop): Change mode parameter to scalar_int_mode.\n\t(clz_loc_descriptor): Likewise.  Remove SCALAR_INT_MODE_P check.\n\t(popcount_loc_descriptor): Likewise.\n\t(bswap_loc_descriptor): Likewise.\n\t(rotate_loc_descriptor): Likewise.\n\t(mem_loc_descriptor): Add is_a <scalar_int_mode> checks before\n\tcalling the functions above.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r251481", "tree": {"sha": "af997f78100816cb663c1ab347f80ef1edf80c3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af997f78100816cb663c1ab347f80ef1edf80c3c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/99767219d617a30394777086fa9ca776390d7098", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99767219d617a30394777086fa9ca776390d7098", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99767219d617a30394777086fa9ca776390d7098", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99767219d617a30394777086fa9ca776390d7098/comments", "author": null, "committer": null, "parents": [{"sha": "546513775069e93d5f33f7aae5f1cb26c77ca2c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/546513775069e93d5f33f7aae5f1cb26c77ca2c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/546513775069e93d5f33f7aae5f1cb26c77ca2c9"}], "stats": {"total": 55, "additions": 33, "deletions": 22}, "files": [{"sha": "9337cdaa7d9c90a9f0946c1770050e80fdbfd784", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99767219d617a30394777086fa9ca776390d7098/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99767219d617a30394777086fa9ca776390d7098/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=99767219d617a30394777086fa9ca776390d7098", "patch": "@@ -1,3 +1,15 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* dwarf2out.c (typed_binop): Change mode parameter to scalar_int_mode.\n+\t(clz_loc_descriptor): Likewise.  Remove SCALAR_INT_MODE_P check.\n+\t(popcount_loc_descriptor): Likewise.\n+\t(bswap_loc_descriptor): Likewise.\n+\t(rotate_loc_descriptor): Likewise.\n+\t(mem_loc_descriptor): Add is_a <scalar_int_mode> checks before\n+\tcalling the functions above.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "4c840b4094c119b5757cdd09d1544a48e1c5959e", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99767219d617a30394777086fa9ca776390d7098/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99767219d617a30394777086fa9ca776390d7098/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=99767219d617a30394777086fa9ca776390d7098", "patch": "@@ -14235,7 +14235,7 @@ minmax_loc_descriptor (rtx rtl, machine_mode mode,\n \n static dw_loc_descr_ref\n typed_binop (enum dwarf_location_atom op, rtx rtl, dw_die_ref type_die,\n-\t     machine_mode mode, machine_mode mem_mode)\n+\t     scalar_int_mode mode, machine_mode mem_mode)\n {\n   dw_loc_descr_ref cvt, op0, op1;\n \n@@ -14291,7 +14291,7 @@ typed_binop (enum dwarf_location_atom op, rtx rtl, dw_die_ref type_die,\n    L4: DW_OP_nop  */\n \n static dw_loc_descr_ref\n-clz_loc_descriptor (rtx rtl, machine_mode mode,\n+clz_loc_descriptor (rtx rtl, scalar_int_mode mode,\n \t\t    machine_mode mem_mode)\n {\n   dw_loc_descr_ref op0, ret, tmp;\n@@ -14302,8 +14302,7 @@ clz_loc_descriptor (rtx rtl, machine_mode mode,\n   dw_loc_descr_ref l4jump, l4label;\n   rtx msb;\n \n-  if (!SCALAR_INT_MODE_P (mode)\n-      || GET_MODE (XEXP (rtl, 0)) != mode)\n+  if (GET_MODE (XEXP (rtl, 0)) != mode)\n     return NULL;\n \n   op0 = mem_loc_descriptor (XEXP (rtl, 0), mode, mem_mode,\n@@ -14403,15 +14402,14 @@ clz_loc_descriptor (rtx rtl, machine_mode mode,\n    L2: DW_OP_drop  */\n \n static dw_loc_descr_ref\n-popcount_loc_descriptor (rtx rtl, machine_mode mode,\n+popcount_loc_descriptor (rtx rtl, scalar_int_mode mode,\n \t\t\t machine_mode mem_mode)\n {\n   dw_loc_descr_ref op0, ret, tmp;\n   dw_loc_descr_ref l1jump, l1label;\n   dw_loc_descr_ref l2jump, l2label;\n \n-  if (!SCALAR_INT_MODE_P (mode)\n-      || GET_MODE (XEXP (rtl, 0)) != mode)\n+  if (GET_MODE (XEXP (rtl, 0)) != mode)\n     return NULL;\n \n   op0 = mem_loc_descriptor (XEXP (rtl, 0), mode, mem_mode,\n@@ -14464,17 +14462,16 @@ popcount_loc_descriptor (rtx rtl, machine_mode mode,\n    L2: DW_OP_drop DW_OP_swap DW_OP_drop  */\n \n static dw_loc_descr_ref\n-bswap_loc_descriptor (rtx rtl, machine_mode mode,\n+bswap_loc_descriptor (rtx rtl, scalar_int_mode mode,\n \t\t      machine_mode mem_mode)\n {\n   dw_loc_descr_ref op0, ret, tmp;\n   dw_loc_descr_ref l1jump, l1label;\n   dw_loc_descr_ref l2jump, l2label;\n \n-  if (!SCALAR_INT_MODE_P (mode)\n-      || BITS_PER_UNIT != 8\n+  if (BITS_PER_UNIT != 8\n       || (GET_MODE_BITSIZE (mode) != 32\n-\t  &&  GET_MODE_BITSIZE (mode) != 64))\n+\t  && GET_MODE_BITSIZE (mode) != 64))\n     return NULL;\n \n   op0 = mem_loc_descriptor (XEXP (rtl, 0), mode, mem_mode,\n@@ -14549,16 +14546,13 @@ bswap_loc_descriptor (rtx rtl, machine_mode mode,\n    [ DW_OP_swap constMASK DW_OP_and DW_OP_swap ] DW_OP_shr DW_OP_or  */\n \n static dw_loc_descr_ref\n-rotate_loc_descriptor (rtx rtl, machine_mode mode,\n+rotate_loc_descriptor (rtx rtl, scalar_int_mode mode,\n \t\t       machine_mode mem_mode)\n {\n   rtx rtlop1 = XEXP (rtl, 1);\n   dw_loc_descr_ref op0, op1, ret, mask[2] = { NULL, NULL };\n   int i;\n \n-  if (!SCALAR_INT_MODE_P (mode))\n-    return NULL;\n-\n   if (GET_MODE (rtlop1) != VOIDmode\n       && GET_MODE_BITSIZE (GET_MODE (rtlop1)) < GET_MODE_BITSIZE (mode))\n     rtlop1 = gen_rtx_ZERO_EXTEND (mode, rtlop1);\n@@ -15167,12 +15161,13 @@ mem_loc_descriptor (rtx rtl, machine_mode mode,\n       break;\n \n     case MOD:\n-      if (GET_MODE_SIZE (mode) > DWARF2_ADDR_SIZE\n-\t  && (!dwarf_strict || dwarf_version >= 5))\n+      if ((!dwarf_strict || dwarf_version >= 5)\n+\t  && is_a <scalar_int_mode> (mode, &int_mode)\n+\t  && GET_MODE_SIZE (int_mode) > DWARF2_ADDR_SIZE)\n \t{\n \t  mem_loc_result = typed_binop (DW_OP_mod, rtl,\n \t\t\t\t\tbase_type_for_mode (mode, 0),\n-\t\t\t\t\tmode, mem_mode);\n+\t\t\t\t\tint_mode, mem_mode);\n \t  break;\n \t}\n \n@@ -15524,21 +15519,25 @@ mem_loc_descriptor (rtx rtl, machine_mode mode,\n     case CLZ:\n     case CTZ:\n     case FFS:\n-      mem_loc_result = clz_loc_descriptor (rtl, mode, mem_mode);\n+      if (is_a <scalar_int_mode> (mode, &int_mode))\n+\tmem_loc_result = clz_loc_descriptor (rtl, int_mode, mem_mode);\n       break;\n \n     case POPCOUNT:\n     case PARITY:\n-      mem_loc_result = popcount_loc_descriptor (rtl, mode, mem_mode);\n+      if (is_a <scalar_int_mode> (mode, &int_mode))\n+\tmem_loc_result = popcount_loc_descriptor (rtl, int_mode, mem_mode);\n       break;\n \n     case BSWAP:\n-      mem_loc_result = bswap_loc_descriptor (rtl, mode, mem_mode);\n+      if (is_a <scalar_int_mode> (mode, &int_mode))\n+\tmem_loc_result = bswap_loc_descriptor (rtl, int_mode, mem_mode);\n       break;\n \n     case ROTATE:\n     case ROTATERT:\n-      mem_loc_result = rotate_loc_descriptor (rtl, mode, mem_mode);\n+      if (is_a <scalar_int_mode> (mode, &int_mode))\n+\tmem_loc_result = rotate_loc_descriptor (rtl, int_mode, mem_mode);\n       break;\n \n     case COMPARE:"}]}