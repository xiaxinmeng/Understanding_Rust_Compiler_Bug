{"sha": "ba8fe4b4832e30277f2e4a73b5d35b2e55074d07", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmE4ZmU0YjQ4MzJlMzAyNzdmMmU0YTczYjVkMzViMmU1NTA3NGQwNw==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-07-13T09:26:39Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-07-13T11:09:44Z"}, "message": "libstdc++: Fix istream::ignore exit conditions (PR 94749, PR 96161)\n\nMy previous fix for PR 94749 did fix the reported case, so that the next\ncharacter is not discarded if it happens to equal the delimiter when __n\ncharacters have already been read. But it introduced a new bug, which is\nthat the delimiter character would *not* be discarded if the number of\ncharacters discarded is numeric_limits<streamsize>::max() or more before\nreaching the delimiter.\n\nThe new bug happens because I changed the code to check _M_gcount < __n.\nBut when __n == numeric_limits<streamsize>::max() that is false, and so\nwe don't discard the delimiter. It's not sufficient to check for the\ndelimiter when the __large_ignore condition is true, because there's an\nedge case where the delimiter is reached when _M_gcount == __n and so\nwe break out of the loop without setting __large_ignore.\n\nPR 96161 is a similar bug to the original PR 94749 report, where eofbit\nis set after discarding __n characters if there happen to be no more\ncharacters in the stream.\n\nThis patch fixes both cases (and the regression) by checking different\nconditions for the __n == max case and the __n < max case. For the\nformer case, we know that we must have either reached the delimiter or\nEOF, and the value of _M_gcount doesn't matter (except to avoid integer\noverflow). For the latter case we need to check _M_gcount first and only\nset eofbit or discard the delimiter if it didn't reach __n. For the\nlatter case overflow can't happen because _M_gcount <= __n < max.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/94749\n\tPR libstdc++/96161\n\t* include/bits/istream.tcc (basic_istream::ignore(streamsize))\n\t[n == max]: Check overflow conditions on _M_gcount. Rely on\n\tthe fact that either EOF or the delimiter was reached.\n\t[n < max]: Check _M_gcount < n before checking for EOF or\n\tdelimiter.\n\t(basic_istream::ignore(streamsize, char_type): Likewise.\n\t* src/c++98/compatibility.cc (istream::ignore(streamsize))\n\t(wistream::ignore(streamsize)): Likewise.\n\t* src/c++98/istream.cc (istream::ignore(streamsize, char_type))\n\t(wistream::ignore(streamsize, char_type)): Likewise.\n\t* testsuite/27_io/basic_istream/ignore/char/94749.cc: Check that\n\tdelimiter is discarded if the number of characters ignored\n\tdoesn't fit in streamsize.\n\t* testsuite/27_io/basic_istream/ignore/wchar_t/94749.cc:\n\tLikewise.\n\t* testsuite/27_io/basic_istream/ignore/char/96161.cc: New test.\n\t* testsuite/27_io/basic_istream/ignore/wchar_t/96161.cc: New test.", "tree": {"sha": "04643699ec81c2b8236dbfa4f3590ab2275d191f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04643699ec81c2b8236dbfa4f3590ab2275d191f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba8fe4b4832e30277f2e4a73b5d35b2e55074d07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba8fe4b4832e30277f2e4a73b5d35b2e55074d07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba8fe4b4832e30277f2e4a73b5d35b2e55074d07", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba8fe4b4832e30277f2e4a73b5d35b2e55074d07/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b20097c65d2e74b1901fba1c55c77f0407e542d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b20097c65d2e74b1901fba1c55c77f0407e542d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b20097c65d2e74b1901fba1c55c77f0407e542d2"}], "stats": {"total": 596, "additions": 561, "deletions": 35}, "files": [{"sha": "5983e51873f5b459c2ddaab2b17592b544e370b6", "filename": "libstdc++-v3/include/bits/istream.tcc", "status": "modified", "additions": 33, "deletions": 11, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba8fe4b4832e30277f2e4a73b5d35b2e55074d07/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fistream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba8fe4b4832e30277f2e4a73b5d35b2e55074d07/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fistream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fistream.tcc?ref=ba8fe4b4832e30277f2e4a73b5d35b2e55074d07", "patch": "@@ -538,11 +538,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t    break;\n \t\t}\n \n-\t      if (__large_ignore)\n-\t\t_M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;\n+\t      if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max)\n+\t\t{\n+\t\t  if (__large_ignore)\n+\t\t    _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;\n \n-\t      if (traits_type::eq_int_type(__c, __eof))\n-                __err |= ios_base::eofbit;\n+\t\t  if (traits_type::eq_int_type(__c, __eof))\n+\t\t    __err |= ios_base::eofbit;\n+\t\t}\n+\t      else if (_M_gcount < __n)\n+\t\t{\n+\t\t  if (traits_type::eq_int_type(__c, __eof))\n+\t\t    __err |= ios_base::eofbit;\n+\t\t}\n             }\n \t  __catch(__cxxabiv1::__forced_unwind&)\n \t    {\n@@ -596,15 +604,29 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t    break;\n \t\t}\n \n-\t      if (__large_ignore)\n-\t\t_M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;\n+\t      if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max)\n+\t\t{\n+\t\t  if (__large_ignore)\n+\t\t    _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;\n \n-              if (traits_type::eq_int_type(__c, __eof))\n-                __err |= ios_base::eofbit;\n-\t      else if (_M_gcount < __n) // implies __c == __delim\n+\t\t  if (traits_type::eq_int_type(__c, __eof))\n+\t\t    __err |= ios_base::eofbit;\n+\t\t  else\n+\t\t    {\n+\t\t      if (_M_gcount != __n)\n+\t\t\t++_M_gcount;\n+\t\t      __sb->sbumpc();\n+\t\t    }\n+\t\t}\n+\t      else if (_M_gcount < __n) // implies __c == __delim or EOF\n \t\t{\n-\t\t  ++_M_gcount;\n-\t\t  __sb->sbumpc();\n+\t\t  if (traits_type::eq_int_type(__c, __eof))\n+\t\t    __err |= ios_base::eofbit;\n+\t\t  else\n+\t\t    {\n+\t\t      ++_M_gcount;\n+\t\t      __sb->sbumpc();\n+\t\t    }\n \t\t}\n             }\n \t  __catch(__cxxabiv1::__forced_unwind&)"}, {"sha": "6024bb9dd48065414490efc51c04c8b8a86b5643", "filename": "libstdc++-v3/src/c++98/compatibility.cc", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba8fe4b4832e30277f2e4a73b5d35b2e55074d07/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B98%2Fcompatibility.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba8fe4b4832e30277f2e4a73b5d35b2e55074d07/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B98%2Fcompatibility.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B98%2Fcompatibility.cc?ref=ba8fe4b4832e30277f2e4a73b5d35b2e55074d07", "patch": "@@ -107,11 +107,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t    break;\n \t\t}\n \n-\t      if (__large_ignore)\n-\t\t_M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;\n+\t      if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max)\n+\t\t{\n+\t\t  if (__large_ignore)\n+\t\t    _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;\n \n-\t      if (traits_type::eq_int_type(__c, __eof))\n-\t\t__err |= ios_base::eofbit;\n+\t\t  if (traits_type::eq_int_type(__c, __eof))\n+\t\t    __err |= ios_base::eofbit;\n+\t\t}\n+\t      else if (_M_gcount < __n)\n+\t\t{\n+\t\t  if (traits_type::eq_int_type(__c, __eof))\n+\t\t    __err |= ios_base::eofbit;\n+\t\t}\n \t    }\n \t  __catch(__cxxabiv1::__forced_unwind&)\n \t    {\n@@ -178,11 +186,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t    break;\n \t\t}\n \n-\t      if (__large_ignore)\n-\t\t_M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;\n+\t      if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max)\n+\t\t{\n+\t\t  if (__large_ignore)\n+\t\t    _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;\n \n-\t      if (traits_type::eq_int_type(__c, __eof))\n-\t\t__err |= ios_base::eofbit;\n+\t\t  if (traits_type::eq_int_type(__c, __eof))\n+\t\t    __err |= ios_base::eofbit;\n+\t\t}\n+\t      else if (_M_gcount < __n)\n+\t\t{\n+\t\t  if (traits_type::eq_int_type(__c, __eof))\n+\t\t    __err |= ios_base::eofbit;\n+\t\t}\n \t    }\n \t  __catch(__cxxabiv1::__forced_unwind&)\n \t    {"}, {"sha": "d2c6794be739308055e5b2e802da74a31b580577", "filename": "libstdc++-v3/src/c++98/istream.cc", "status": "modified", "additions": 42, "deletions": 14, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba8fe4b4832e30277f2e4a73b5d35b2e55074d07/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B98%2Fistream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba8fe4b4832e30277f2e4a73b5d35b2e55074d07/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B98%2Fistream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B98%2Fistream.cc?ref=ba8fe4b4832e30277f2e4a73b5d35b2e55074d07", "patch": "@@ -166,15 +166,29 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t    break;\n \t\t}\n \n-\t      if (__large_ignore)\n-\t\t_M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;\n+\t      if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max)\n+\t\t{\n+\t\t  if (__large_ignore)\n+\t\t    _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;\n \n-\t      if (traits_type::eq_int_type(__c, __eof))\n-\t\t__err |= ios_base::eofbit;\n-\t      else if (_M_gcount < __n) // implies __c == __delim\n+\t\t  if (traits_type::eq_int_type(__c, __eof))\n+\t\t    __err |= ios_base::eofbit;\n+\t\t  else\n+\t\t    {\n+\t\t      if (_M_gcount != __n)\n+\t\t\t++_M_gcount;\n+\t\t      __sb->sbumpc();\n+\t\t    }\n+\t\t}\n+\t      else if (_M_gcount < __n) // implies __c == __delim or EOF\n \t\t{\n-\t\t  ++_M_gcount;\n-\t\t  __sb->sbumpc();\n+\t\t  if (traits_type::eq_int_type(__c, __eof))\n+\t\t    __err |= ios_base::eofbit;\n+\t\t  else\n+\t\t    {\n+\t\t      ++_M_gcount;\n+\t\t      __sb->sbumpc();\n+\t\t    }\n \t\t}\n \t    }\n \t  __catch(__cxxabiv1::__forced_unwind&)\n@@ -406,15 +420,29 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t    break;\n \t\t}\n \n-\t      if (__large_ignore)\n-\t\t_M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;\n+\t      if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max)\n+\t\t{\n+\t\t  if (__large_ignore)\n+\t\t    _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;\n \n-\t      if (traits_type::eq_int_type(__c, __eof))\n-\t\t__err |= ios_base::eofbit;\n-\t      else if (_M_gcount < __n) // implies __c == __delim\n+\t\t  if (traits_type::eq_int_type(__c, __eof))\n+\t\t    __err |= ios_base::eofbit;\n+\t\t  else\n+\t\t    {\n+\t\t      if (_M_gcount != __n)\n+\t\t\t++_M_gcount;\n+\t\t      __sb->sbumpc();\n+\t\t    }\n+\t\t}\n+\t      else if (_M_gcount < __n) // implies __c == __delim or EOF\n \t\t{\n-\t\t  ++_M_gcount;\n-\t\t  __sb->sbumpc();\n+\t\t  if (traits_type::eq_int_type(__c, __eof))\n+\t\t    __err |= ios_base::eofbit;\n+\t\t  else\n+\t\t    {\n+\t\t      ++_M_gcount;\n+\t\t      __sb->sbumpc();\n+\t\t    }\n \t\t}\n \t    }\n \t  __catch(__cxxabiv1::__forced_unwind&)"}, {"sha": "32b604d5b15a2812e7bda9a0f2474af0eaff9678", "filename": "libstdc++-v3/testsuite/27_io/basic_istream/ignore/char/94749.cc", "status": "modified", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba8fe4b4832e30277f2e4a73b5d35b2e55074d07/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fignore%2Fchar%2F94749.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba8fe4b4832e30277f2e4a73b5d35b2e55074d07/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fignore%2Fchar%2F94749.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fignore%2Fchar%2F94749.cc?ref=ba8fe4b4832e30277f2e4a73b5d35b2e55074d07", "patch": "@@ -16,11 +16,13 @@\n // <http://www.gnu.org/licenses/>.\n \n // { dg-do run }\n+// { dg-options \"-DSIMULATOR_TEST\" { target simulator } }\n \n // PR libstdc++/94749\n // basic_istream::ignore(n, c) discards n+1 if next character is equal to c.\n \n #include <sstream>\n+#include <limits>\n #include <testsuite_hooks.h>\n \n typedef char C;\n@@ -30,8 +32,10 @@ test01()\n {\n   std::basic_istringstream<C> s(\" +   -\");\n   s.ignore(1, '+');\n+  VERIFY( s.gcount() == 1 );\n   VERIFY( s.get() == '+' );\n   s.ignore(3, '-');\n+  VERIFY( s.gcount() == 3 );\n   VERIFY( s.get() == '-' );\n }\n \n@@ -40,8 +44,10 @@ test02()\n {\n   std::basic_istringstream<C> s(\".+...-\");\n   s.ignore(1, '+');\n+  VERIFY( s.gcount() == 1 );\n   VERIFY( s.get() == '+' );\n   s.ignore(3, '-');\n+  VERIFY( s.gcount() == 3 );\n   VERIFY( s.get() == '-' );\n }\n \n@@ -50,8 +56,10 @@ test03()\n {\n   std::basic_istringstream<C, __gnu_cxx::char_traits<C> > s(\" +   -\");\n   s.ignore(1, '+');\n+  VERIFY( s.gcount() == 1 );\n   VERIFY( s.get() == '+' );\n   s.ignore(3, '-');\n+  VERIFY( s.gcount() == 3 );\n   VERIFY( s.get() == '-' );\n }\n \n@@ -60,11 +68,150 @@ test04()\n {\n   std::basic_istringstream<C, __gnu_cxx::char_traits<C> > s(\".+...-\");\n   s.ignore(1, '+');\n+  VERIFY( s.gcount() == 1 );\n   VERIFY( s.get() == '+' );\n   s.ignore(3, '-');\n+  VERIFY( s.gcount() == 3 );\n   VERIFY( s.get() == '-' );\n }\n \n+// The original fix for PR libstdc++/94749 failed to discard the delimiter\n+// if it occurred after numeric_limits<streamsize>::max() had been seen.\n+// This streambuf will keep filling the get area with zero bytes until\n+// almost numeric_limits<streamsize>::max() characters have been read,\n+// and then return one more buffer that has \"123\" at its end.\n+template<typename T>\n+struct buff : std::basic_streambuf<typename T::char_type, T>\n+{\n+  typedef typename T::char_type\t\t  char_type;\n+  typedef typename T::int_type\t\t  int_type;\n+  typedef std::streamsize\t\t  streamsize;\n+  typedef std::numeric_limits<streamsize> limits;\n+\n+  buff() : count(0), buf() { }\n+\n+  int_type underflow()\n+  {\n+    // Number of characters left until we overflow the counter\n+    const streamsize headroom = limits::max() - count;\n+\n+    if (headroom == 0)\n+      return T::eof();\n+\n+    if (bufsz < headroom)\n+    {\n+      this->setg(buf, buf, buf + bufsz);\n+      count += bufsz;\n+    }\n+    else\n+    {\n+      // write \"123\" across the 2GB boundary\n+      buf[headroom-1] = '1';\n+      buf[headroom+0] = '2';\n+      buf[headroom+1] = '3';\n+      this->setg(buf, buf, buf + headroom + 2);\n+      count = limits::max();\n+    }\n+\n+    return buf[0];\n+  }\n+\n+  streamsize count;\n+\n+  static const streamsize bufsz = 2048 << limits::digits10;\n+  char_type buf[bufsz + 2];\n+};\n+\n+void\n+test05()\n+{\n+  // Not possible to overflow 64-bit streamsize in reasonable time.\n+  if (std::numeric_limits<std::streamsize>::digits > 32)\n+    return;\n+\n+  typedef std::char_traits<C> T;\n+\n+  std::basic_istream<C, T> in(new buff<T>);\n+\n+  in.ignore(std::numeric_limits<std::streamsize>::max(), '1');\n+  VERIFY(in.good());\n+  VERIFY(in.gcount() == std::numeric_limits<std::streamsize>::max());\n+  VERIFY(in.get() == '2');\n+  VERIFY(in.get() == '3');\n+  VERIFY(in.get() == T::eof());\n+\n+  delete in.rdbuf(new buff<T>);\n+\n+  in.ignore(std::numeric_limits<std::streamsize>::max(), '2');\n+  VERIFY(in.good());\n+  // The standard doesn't say what gcount() should return in this case:\n+  VERIFY(in.gcount() == std::numeric_limits<std::streamsize>::max());\n+  VERIFY(in.get() == '3');\n+  VERIFY(in.get() == T::eof());\n+\n+  delete in.rdbuf(new buff<T>);\n+\n+  in.ignore(std::numeric_limits<std::streamsize>::max(), '3');\n+  VERIFY(in.good());\n+  // The standard doesn't say what gcount() should return in this case:\n+  VERIFY(in.gcount() == std::numeric_limits<std::streamsize>::max());\n+  VERIFY(in.get() == T::eof());\n+\n+  delete in.rdbuf(new buff<T>);\n+\n+  in.ignore(std::numeric_limits<std::streamsize>::max(), '4');\n+  VERIFY(in.eof());\n+  // The standard doesn't say what gcount() should return in this case:\n+  VERIFY(in.gcount() == std::numeric_limits<std::streamsize>::max());\n+  VERIFY(in.get() == T::eof());\n+\n+  delete in.rdbuf(nullptr);\n+}\n+\n+void\n+test06()\n+{\n+  if (std::numeric_limits<std::streamsize>::digits > 32)\n+    return;\n+\n+  typedef __gnu_cxx::char_traits<C> T;\n+\n+  std::basic_istream<C, T> in(new buff<T>);\n+\n+  in.ignore(std::numeric_limits<std::streamsize>::max(), '1');\n+  VERIFY(in.good());\n+  VERIFY(in.gcount() == std::numeric_limits<std::streamsize>::max());\n+  VERIFY(in.get() == '2');\n+  VERIFY(in.get() == '3');\n+  VERIFY(in.get() == T::eof());\n+\n+  delete in.rdbuf(new buff<T>);\n+\n+  in.ignore(std::numeric_limits<std::streamsize>::max(), '2');\n+  VERIFY(in.good());\n+  // The standard doesn't say what gcount() should return in this case:\n+  VERIFY(in.gcount() == std::numeric_limits<std::streamsize>::max());\n+  VERIFY(in.get() == '3');\n+  VERIFY(in.get() == T::eof());\n+\n+  delete in.rdbuf(new buff<T>);\n+\n+  in.ignore(std::numeric_limits<std::streamsize>::max(), '3');\n+  VERIFY(in.good());\n+  // The standard doesn't say what gcount() should return in this case:\n+  VERIFY(in.gcount() == std::numeric_limits<std::streamsize>::max());\n+  VERIFY(in.get() == T::eof());\n+\n+  delete in.rdbuf(new buff<T>);\n+\n+  in.ignore(std::numeric_limits<std::streamsize>::max(), '4');\n+  VERIFY(in.eof());\n+  // The standard doesn't say what gcount() should return in this case:\n+  VERIFY(in.gcount() == std::numeric_limits<std::streamsize>::max());\n+  VERIFY(in.get() == T::eof());\n+\n+  delete in.rdbuf(nullptr);\n+}\n \n int\n main()\n@@ -73,4 +220,8 @@ main()\n   test02();\n   test03();\n   test04();\n+  test05();\n+#ifndef SIMULATOR_TEST\n+  test06();\n+#endif\n }"}, {"sha": "c19e5f9e758862939bbe89ebfd5690e6b2f98db9", "filename": "libstdc++-v3/testsuite/27_io/basic_istream/ignore/char/96161.cc", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba8fe4b4832e30277f2e4a73b5d35b2e55074d07/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fignore%2Fchar%2F96161.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba8fe4b4832e30277f2e4a73b5d35b2e55074d07/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fignore%2Fchar%2F96161.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fignore%2Fchar%2F96161.cc?ref=ba8fe4b4832e30277f2e4a73b5d35b2e55074d07", "patch": "@@ -0,0 +1,79 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run }\n+\n+// PR libstdc++/96161\n+// basic_istream::ignore sets eofbit too soon\n+\n+#include <sstream>\n+#include <limits>\n+#include <testsuite_hooks.h>\n+\n+typedef char C;\n+\n+void\n+test01()\n+{\n+  std::basic_istringstream<C> s(\"  \");\n+  s.ignore(2, '+');\n+  VERIFY( s.gcount() == 2 );\n+  VERIFY( s.good() );\n+  VERIFY( s.get() == std::char_traits<C>::eof() );\n+  VERIFY( s.eof() );\n+}\n+\n+void\n+test02()\n+{\n+  std::basic_istringstream<C> s(\"  \");\n+  s.ignore(2);\n+  VERIFY( s.gcount() == 2 );\n+  VERIFY( s.good() );\n+  VERIFY( s.get() == std::char_traits<C>::eof() );\n+  VERIFY( s.eof() );\n+}\n+\n+void\n+test03()\n+{\n+  std::basic_istringstream<C, __gnu_cxx::char_traits<C> > s(\"  \");\n+  s.ignore(2, '+');\n+  VERIFY( s.gcount() == 2 );\n+  VERIFY( s.good() );\n+  VERIFY( s.get() == __gnu_cxx::char_traits<C>::eof() );\n+  VERIFY( s.eof() );\n+}\n+\n+void\n+test04()\n+{\n+  std::basic_istringstream<C, __gnu_cxx::char_traits<C> > s(\"  \");\n+  s.ignore(2);\n+  VERIFY( s.gcount() == 2 );\n+  VERIFY( s.good() );\n+  VERIFY( s.get() == __gnu_cxx::char_traits<C>::eof() );\n+  VERIFY( s.eof() );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+}"}, {"sha": "23d3a0ad1707c99fb68ed5a139ec3ae7f039bce4", "filename": "libstdc++-v3/testsuite/27_io/basic_istream/ignore/wchar_t/94749.cc", "status": "modified", "additions": 153, "deletions": 2, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba8fe4b4832e30277f2e4a73b5d35b2e55074d07/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fignore%2Fwchar_t%2F94749.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba8fe4b4832e30277f2e4a73b5d35b2e55074d07/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fignore%2Fwchar_t%2F94749.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fignore%2Fwchar_t%2F94749.cc?ref=ba8fe4b4832e30277f2e4a73b5d35b2e55074d07", "patch": "@@ -16,11 +16,13 @@\n // <http://www.gnu.org/licenses/>.\n \n // { dg-do run }\n+// { dg-options \"-DSIMULATOR_TEST\" { target simulator } }\n \n // PR libstdc++/94749\n // basic_istream::ignore(n, c) discards n+1 if next character is equal to c.\n \n #include <sstream>\n+#include <limits>\n #include <testsuite_hooks.h>\n \n typedef wchar_t C;\n@@ -30,8 +32,10 @@ test01()\n {\n   std::basic_istringstream<C> s(L\" +   -\");\n   s.ignore(1, L'+');\n+  VERIFY( s.gcount() == 1 );\n   VERIFY( s.get() == L'+' );\n   s.ignore(3, L'-');\n+  VERIFY( s.gcount() == 3 );\n   VERIFY( s.get() == L'-' );\n }\n \n@@ -40,8 +44,10 @@ test02()\n {\n   std::basic_istringstream<C> s(L\".+...-\");\n   s.ignore(1, L'+');\n+  VERIFY( s.gcount() == 1 );\n   VERIFY( s.get() == L'+' );\n   s.ignore(3, L'-');\n+  VERIFY( s.gcount() == 3 );\n   VERIFY( s.get() == L'-' );\n }\n \n@@ -50,8 +56,10 @@ test03()\n {\n   std::basic_istringstream<C, __gnu_cxx::char_traits<C> > s(L\" +   -\");\n   s.ignore(1, L'+');\n+  VERIFY( s.gcount() == 1 );\n   VERIFY( s.get() == L'+' );\n   s.ignore(3, L'-');\n+  VERIFY( s.gcount() == 3 );\n   VERIFY( s.get() == L'-' );\n }\n \n@@ -60,17 +68,160 @@ test04()\n {\n   std::basic_istringstream<C, __gnu_cxx::char_traits<C> > s(L\".+...-\");\n   s.ignore(1, L'+');\n+  VERIFY( s.gcount() == 1 );\n   VERIFY( s.get() == L'+' );\n   s.ignore(3, L'-');\n+  VERIFY( s.gcount() == 3 );\n   VERIFY( s.get() == L'-' );\n }\n \n+// The original fix for PR libstdc++/94749 failed to discard the delimiter\n+// if it occurred after numeric_limits<streamsize>::max() had been seen.\n+// This streambuf will keep filling the get area with zero bytes until\n+// almost numeric_limits<streamsize>::max() characters have been read,\n+// and then return one more buffer that has L\"123\" at its end.\n+template<typename T>\n+struct buff : std::basic_streambuf<typename T::char_type, T>\n+{\n+  typedef typename T::char_type\t\t  char_type;\n+  typedef typename T::int_type\t\t  int_type;\n+  typedef std::streamsize\t\t  streamsize;\n+  typedef std::numeric_limits<streamsize> limits;\n+\n+  buff() : count(0), buf() { }\n+\n+  int_type underflow()\n+  {\n+    // Number of characters left until we overflow the counter\n+    const streamsize headroom = limits::max() - count;\n+\n+    if (headroom == 0)\n+      return T::eof();\n+\n+    if (bufsz < headroom)\n+    {\n+      this->setg(buf, buf, buf + bufsz);\n+      count += bufsz;\n+    }\n+    else\n+    {\n+      // write L\"123\" across the 2GB boundary\n+      buf[headroom-1] = L'1';\n+      buf[headroom+0] = L'2';\n+      buf[headroom+1] = L'3';\n+      this->setg(buf, buf, buf + headroom + 2);\n+      count = limits::max();\n+    }\n+\n+    return buf[0];\n+  }\n+\n+  streamsize count;\n+\n+  static const streamsize bufsz = 2048 << limits::digits10;\n+  char_type buf[bufsz + 2];\n+};\n+\n+void\n+test05()\n+{\n+  // Not possible to overflow 64-bit streamsize in reasonable time.\n+  if (std::numeric_limits<std::streamsize>::digits > 32)\n+    return;\n+\n+  typedef std::char_traits<C> T;\n+\n+  std::basic_istream<C, T> in(new buff<T>);\n+\n+  in.ignore(std::numeric_limits<std::streamsize>::max(), L'1');\n+  VERIFY(in.good());\n+  VERIFY(in.gcount() == std::numeric_limits<std::streamsize>::max());\n+  VERIFY(in.get() == L'2');\n+  VERIFY(in.get() == L'3');\n+  VERIFY(in.get() == T::eof());\n+\n+  delete in.rdbuf(new buff<T>);\n+\n+  in.ignore(std::numeric_limits<std::streamsize>::max(), L'2');\n+  VERIFY(in.good());\n+  // The standard doesn't say what gcount() should return in this case:\n+  VERIFY(in.gcount() == std::numeric_limits<std::streamsize>::max());\n+  VERIFY(in.get() == L'3');\n+  VERIFY(in.get() == T::eof());\n+\n+  delete in.rdbuf(new buff<T>);\n+\n+  in.ignore(std::numeric_limits<std::streamsize>::max(), L'3');\n+  VERIFY(in.good());\n+  // The standard doesn't say what gcount() should return in this case:\n+  VERIFY(in.gcount() == std::numeric_limits<std::streamsize>::max());\n+  VERIFY(in.get() == T::eof());\n+\n+  delete in.rdbuf(new buff<T>);\n+\n+  in.ignore(std::numeric_limits<std::streamsize>::max(), L'4');\n+  VERIFY(in.eof());\n+  // The standard doesn't say what gcount() should return in this case:\n+  VERIFY(in.gcount() == std::numeric_limits<std::streamsize>::max());\n+  VERIFY(in.get() == T::eof());\n+\n+  delete in.rdbuf(nullptr);\n+}\n+\n+void\n+test06()\n+{\n+  if (std::numeric_limits<std::streamsize>::digits > 32)\n+    return;\n+\n+  typedef __gnu_cxx::char_traits<C> T;\n+\n+  std::basic_istream<C, T> in(new buff<T>);\n+\n+  in.ignore(std::numeric_limits<std::streamsize>::max(), L'1');\n+  VERIFY(in.good());\n+  VERIFY(in.gcount() == std::numeric_limits<std::streamsize>::max());\n+  VERIFY(in.get() == L'2');\n+  VERIFY(in.get() == L'3');\n+  VERIFY(in.get() == T::eof());\n+\n+  delete in.rdbuf(new buff<T>);\n+\n+  in.ignore(std::numeric_limits<std::streamsize>::max(), L'2');\n+  VERIFY(in.good());\n+  // The standard doesn't say what gcount() should return in this case:\n+  VERIFY(in.gcount() == std::numeric_limits<std::streamsize>::max());\n+  VERIFY(in.get() == L'3');\n+  VERIFY(in.get() == T::eof());\n+\n+  delete in.rdbuf(new buff<T>);\n+\n+  in.ignore(std::numeric_limits<std::streamsize>::max(), L'3');\n+  VERIFY(in.good());\n+  // The standard doesn't say what gcount() should return in this case:\n+  VERIFY(in.gcount() == std::numeric_limits<std::streamsize>::max());\n+  VERIFY(in.get() == T::eof());\n+\n+  delete in.rdbuf(new buff<T>);\n+\n+  in.ignore(std::numeric_limits<std::streamsize>::max(), L'4');\n+  VERIFY(in.eof());\n+  // The standard doesn't say what gcount() should return in this case:\n+  VERIFY(in.gcount() == std::numeric_limits<std::streamsize>::max());\n+  VERIFY(in.get() == T::eof());\n+\n+  delete in.rdbuf(nullptr);\n+}\n \n int\n main()\n {\n-  // test01();\n-  // test02();\n+  test01();\n+  test02();\n   test03();\n   test04();\n+  test05();\n+#ifndef SIMULATOR_TEST\n+  test06();\n+#endif\n }"}, {"sha": "64234426d1535c84e27988f70d2f80ea1c48be84", "filename": "libstdc++-v3/testsuite/27_io/basic_istream/ignore/wchar_t/96161.cc", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba8fe4b4832e30277f2e4a73b5d35b2e55074d07/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fignore%2Fwchar_t%2F96161.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba8fe4b4832e30277f2e4a73b5d35b2e55074d07/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fignore%2Fwchar_t%2F96161.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fignore%2Fwchar_t%2F96161.cc?ref=ba8fe4b4832e30277f2e4a73b5d35b2e55074d07", "patch": "@@ -0,0 +1,79 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run }\n+\n+// PR libstdc++/96161\n+// basic_istream::ignore sets eofbit too soon\n+\n+#include <sstream>\n+#include <limits>\n+#include <testsuite_hooks.h>\n+\n+typedef wchar_t C;\n+\n+void\n+test01()\n+{\n+  std::basic_istringstream<C> s(L\"  \");\n+  s.ignore(2, L'+');\n+  VERIFY( s.gcount() == 2 );\n+  VERIFY( s.good() );\n+  VERIFY( s.get() == std::char_traits<C>::eof() );\n+  VERIFY( s.eof() );\n+}\n+\n+void\n+test02()\n+{\n+  std::basic_istringstream<C> s(L\"  \");\n+  s.ignore(2);\n+  VERIFY( s.gcount() == 2 );\n+  VERIFY( s.good() );\n+  VERIFY( s.get() == std::char_traits<C>::eof() );\n+  VERIFY( s.eof() );\n+}\n+\n+void\n+test03()\n+{\n+  std::basic_istringstream<C, __gnu_cxx::char_traits<C> > s(L\"  \");\n+  s.ignore(2, L'+');\n+  VERIFY( s.gcount() == 2 );\n+  VERIFY( s.good() );\n+  VERIFY( s.get() == __gnu_cxx::char_traits<C>::eof() );\n+  VERIFY( s.eof() );\n+}\n+\n+void\n+test04()\n+{\n+  std::basic_istringstream<C, __gnu_cxx::char_traits<C> > s(L\"  \");\n+  s.ignore(2);\n+  VERIFY( s.gcount() == 2 );\n+  VERIFY( s.good() );\n+  VERIFY( s.get() == __gnu_cxx::char_traits<C>::eof() );\n+  VERIFY( s.eof() );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+}"}]}