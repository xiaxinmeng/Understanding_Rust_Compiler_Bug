{"sha": "598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTk4ZWM3YmRiZTBlNmUyZjdjNTg5NjFmZDBmNjFlMDg5OGEzMDgzZQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2006-11-17T11:29:17Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2006-11-17T11:29:17Z"}, "message": "tree-vrp.c (execute_vrp): Do not update current_loops.\n\n\t* tree-vrp.c (execute_vrp): Do not update current_loops.\n\t* loop-unswitch.c (unswitch_loop): Do not use loop_split_edge_with.\n\t* doc/loop.texi: Remove documentation for cancelled functions.\n\t* tree-ssa-loop-im.c (loop_commit_inserts): Removed.\n\t(move_computations, determine_lsm): Use bsi_commit_edge_inserts\n\tinstead.\n\t* cfgloopmanip.c (remove_bbs): Do not update loops explicitly.\n\t(remove_path): Ensure that in delete_basic_blocks, the loops\n\tare still allocated.\n\t(add_loop): Work on valid loop structures.\n\t(loopify): Modify call of add_loop.\n\t(mfb_update_loops): Removed.\n\t(create_preheader): Do not update loops explicitly.\n\t(force_single_succ_latches, loop_version): Do not use\n\tloop_split_edge_with.\n\t(loop_split_edge_with): Removed.\n\t* tree-ssa-loop-manip.c (create_iv, determine_exit_conditions):\n\tDo not use bsi_insert_on_edge_immediate_loop.\n\t(split_loop_exit_edge, tree_unroll_loop): Do not use\n\tloop_split_edge_with.\n\t(bsi_insert_on_edge_immediate_loop): Removed.\n\t* tree-ssa-loop-ch.c (copy_loop_headers): Use current_loops.  Do not\n\tuse loop_split_edge_with.\n\t* cfghooks.c: Include cfgloop.h.\n\t(verify_flow_info): Verify that loop_father is filled iff current_loops\n\tare available.\n\t(redirect_edge_and_branch_force, split_block, delete_basic_block,\n\tsplit_edge, merge_blocks, make_forwarder_block, duplicate_block):\n\tUpdate cfg.\n\t* cfgloopanal.c (mark_irreducible_loops): Work if the function contains\n\tno loops.\n\t* modulo-sched.c (generate_prolog_epilog, canon_loop): Do not use\n\tloop_split_edge_with.\n\t(sms_schedule): Use current_loops.\n\t* tree-ssa-dom.c (tree_ssa_dominator_optimize): Use current_loops.\n\t* loop-init.c (loop_optimizer_init, loop_optimizer_finalize): Set\n\tcurrent_loops.\n\t(rtl_loop_init, rtl_loop_done): Do not set current_loops.\n\t* tree-ssa-sink.c (execute_sink_code): Use current_loops.\n\t* ifcvt.c (if_convert): Ditto.\n\t* predict.c (predict_loops): Do not clear current_loops.\n\t(tree_estimate_probability): Use current_loops.\n\t(propagate_freq): Receive head of the region to propagate instead of\n\tloop.\n\t(estimate_loops_at_level): Do not use shared to_visit bitmap.\n\t(estimate_loops): New function.  Handle case current_loops == NULL.\n\t(estimate_bb_frequencies): Do not allocate tovisit.  Use\n\testimate_loops.\n\t* tree-ssa-loop.c (current_loops): Removed.\n\t(tree_loop_optimizer_init): Do not return loops.\n\t(tree_ssa_loop_init, tree_ssa_loop_done): Do not set current_loops.\n\t* tree-vectorizer.c (slpeel_update_phi_nodes_for_guard1,\n\tslpeel_update_phi_nodes_for_guard2, slpeel_tree_peel_loop_to_edge):\n\tDo not update loops explicitly.\n\t* function.h (struct function): Add x_current_loops field.\n\t(current_loops): New macro.\n\t* tree-if-conv.c (combine_blocks): Do not update loops explicitly.\n\t* loop-unroll.c (split_edge_and_insert): New function.\n\t(unroll_loop_runtime_iterations, analyze_insns_in_loop): Do not\n\tuse loop_split_edge_with.\n\t* loop-doloop.c (add_test, doloop_modify): Ditto.\n\t* tree-ssa-pre.c (init_pre, fini_pre): Do not set current_loops.\n\t* cfglayout.c (copy_bbs): Do not update loops explicitly.\n\t* lambda-code.c (perfect_nestify): Do not use loop_split_edge_with.\n\t* tree-vect-transform.c (vect_transform_loop): Do not update loops\n\texplicitly.\n\t* cfgloop.c (flow_loops_cfg_dump): Do not dump dfs_order and rc_order.\n\t(flow_loops_free): Do not free dfs_order and rc_order.\n\t(flow_loops_find): Do not set dfs_order and rc_order in loops\n\tstructure.  Do not call loops and flow info verification.\n\t(add_bb_to_loop, remove_bb_from_loops): Check whether the block\n\talready belongs to some loop.\n\t* cfgloop.h (struct loops): Remove struct cfg.\n\t(current_loops, loop_split_edge_with): Declaration removed.\n\t(loop_optimizer_init, loop_optimizer_finalize): Declaration changed.\n\t* tree-flow.h (loop_commit_inserts, bsi_insert_on_edge_immediate_loop):\n\tDeclaration removed.\n\t* Makefile.in (cfghooks.o): Add CFGLOOP_H dependency.\n\t* basic-block.h (split_edge_and_insert): Declare.\n\t* tree-cfg.c (remove_bb): Do not update loops explicitly.\n\nFrom-SVN: r118931", "tree": {"sha": "194dc21664ec5a698ea4824b9350190e2710fce6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/194dc21664ec5a698ea4824b9350190e2710fce6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/comments", "author": null, "committer": null, "parents": [{"sha": "31198773e456d1a8ecabdd576fa3a9d4412cbf07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31198773e456d1a8ecabdd576fa3a9d4412cbf07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31198773e456d1a8ecabdd576fa3a9d4412cbf07"}], "stats": {"total": 844, "additions": 425, "deletions": 419}, "files": [{"sha": "12c61b79200b6abaa037bfb14d6fc474ef89e9ce", "filename": "gcc/ChangeLog", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e", "patch": "@@ -1,3 +1,86 @@\n+2006-11-17  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\t* tree-vrp.c (execute_vrp): Do not update current_loops.\n+\t* loop-unswitch.c (unswitch_loop): Do not use loop_split_edge_with.\n+\t* doc/loop.texi: Remove documentation for cancelled functions.\n+\t* tree-ssa-loop-im.c (loop_commit_inserts): Removed.\n+\t(move_computations, determine_lsm): Use bsi_commit_edge_inserts\n+\tinstead.\n+\t* cfgloopmanip.c (remove_bbs): Do not update loops explicitly.\n+\t(remove_path): Ensure that in delete_basic_blocks, the loops\n+\tare still allocated.\n+\t(add_loop): Work on valid loop structures.\n+\t(loopify): Modify call of add_loop.\n+\t(mfb_update_loops): Removed.\n+\t(create_preheader): Do not update loops explicitly.\n+\t(force_single_succ_latches, loop_version): Do not use\n+\tloop_split_edge_with.\n+\t(loop_split_edge_with): Removed.\n+\t* tree-ssa-loop-manip.c (create_iv, determine_exit_conditions):\n+\tDo not use bsi_insert_on_edge_immediate_loop.\n+\t(split_loop_exit_edge, tree_unroll_loop): Do not use\n+\tloop_split_edge_with.\n+\t(bsi_insert_on_edge_immediate_loop): Removed.\n+\t* tree-ssa-loop-ch.c (copy_loop_headers): Use current_loops.  Do not\n+\tuse loop_split_edge_with.\n+\t* cfghooks.c: Include cfgloop.h.\n+\t(verify_flow_info): Verify that loop_father is filled iff current_loops\n+\tare available.\n+\t(redirect_edge_and_branch_force, split_block, delete_basic_block,\n+\tsplit_edge, merge_blocks, make_forwarder_block, duplicate_block):\n+\tUpdate cfg.\n+\t* cfgloopanal.c (mark_irreducible_loops): Work if the function contains\n+\tno loops.\n+\t* modulo-sched.c (generate_prolog_epilog, canon_loop): Do not use\n+\tloop_split_edge_with.\n+\t(sms_schedule): Use current_loops.\n+\t* tree-ssa-dom.c (tree_ssa_dominator_optimize): Use current_loops.\n+\t* loop-init.c (loop_optimizer_init, loop_optimizer_finalize): Set\n+\tcurrent_loops.\n+\t(rtl_loop_init, rtl_loop_done): Do not set current_loops.\n+\t* tree-ssa-sink.c (execute_sink_code): Use current_loops.\n+\t* ifcvt.c (if_convert): Ditto.\n+\t* predict.c (predict_loops): Do not clear current_loops.\n+\t(tree_estimate_probability): Use current_loops.\n+\t(propagate_freq): Receive head of the region to propagate instead of\n+\tloop.\n+\t(estimate_loops_at_level): Do not use shared to_visit bitmap.\n+\t(estimate_loops): New function.  Handle case current_loops == NULL.\n+\t(estimate_bb_frequencies): Do not allocate tovisit.  Use\n+\testimate_loops.\n+\t* tree-ssa-loop.c (current_loops): Removed.\n+\t(tree_loop_optimizer_init): Do not return loops.\n+\t(tree_ssa_loop_init, tree_ssa_loop_done): Do not set current_loops.\n+\t* tree-vectorizer.c (slpeel_update_phi_nodes_for_guard1,\n+\tslpeel_update_phi_nodes_for_guard2, slpeel_tree_peel_loop_to_edge):\n+\tDo not update loops explicitly.\n+\t* function.h (struct function): Add x_current_loops field.\n+\t(current_loops): New macro.\n+\t* tree-if-conv.c (combine_blocks): Do not update loops explicitly.\n+\t* loop-unroll.c (split_edge_and_insert): New function.\n+\t(unroll_loop_runtime_iterations, analyze_insns_in_loop): Do not\n+\tuse loop_split_edge_with.\n+\t* loop-doloop.c (add_test, doloop_modify): Ditto.\n+\t* tree-ssa-pre.c (init_pre, fini_pre): Do not set current_loops.\n+\t* cfglayout.c (copy_bbs): Do not update loops explicitly.\n+\t* lambda-code.c (perfect_nestify): Do not use loop_split_edge_with.\n+\t* tree-vect-transform.c (vect_transform_loop): Do not update loops\n+\texplicitly.\n+\t* cfgloop.c (flow_loops_cfg_dump): Do not dump dfs_order and rc_order.\n+\t(flow_loops_free): Do not free dfs_order and rc_order.\n+\t(flow_loops_find): Do not set dfs_order and rc_order in loops\n+\tstructure.  Do not call loops and flow info verification.\n+\t(add_bb_to_loop, remove_bb_from_loops): Check whether the block\n+\talready belongs to some loop.\n+\t* cfgloop.h (struct loops): Remove struct cfg.\n+\t(current_loops, loop_split_edge_with): Declaration removed.\n+\t(loop_optimizer_init, loop_optimizer_finalize): Declaration changed.\n+\t* tree-flow.h (loop_commit_inserts, bsi_insert_on_edge_immediate_loop):\n+\tDeclaration removed.\n+\t* Makefile.in (cfghooks.o): Add CFGLOOP_H dependency.\n+\t* basic-block.h (split_edge_and_insert): Declare.\n+\t* tree-cfg.c (remove_bb): Do not update loops explicitly.\n+\n 2006-11-17  Zdenek Dvorak <dvorakz@suse.cz>\n \n \tPR tree-optimization/29801"}, {"sha": "8136290694ee79d1d00cef5565a85e29ffdb8620", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e", "patch": "@@ -2427,7 +2427,7 @@ cfg.o : cfg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(FLAGS_H) \\\n    $(REGS_H) hard-reg-set.h output.h toplev.h $(FUNCTION_H) except.h $(GGC_H) \\\n    $(TM_P_H) $(TIMEVAR_H) $(OBSTACK_H) $(TREE_H) alloc-pool.h $(HASHTAB_H)\n cfghooks.o: cfghooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n-   $(TREE_H) $(BASIC_BLOCK_H) $(TREE_FLOW_H) $(TIMEVAR_H) toplev.h\n+   $(TREE_H) $(BASIC_BLOCK_H) $(TREE_FLOW_H) $(TIMEVAR_H) toplev.h $(CFGLOOP_H)\n cfgexpand.o : cfgexpand.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(FUNCTION_H) $(TIMEVAR_H) $(TM_H) \\\n    coretypes.h $(TREE_DUMP_H) except.h langhooks.h tree-pass.h $(RTL_H) \\"}, {"sha": "6b6820c1d0fff870fc04251a87338deee508c20a", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e", "patch": "@@ -486,6 +486,7 @@ extern void update_bb_for_insn (basic_block);\n extern void free_basic_block_vars (void);\n \n extern void insert_insn_on_edge (rtx, edge);\n+basic_block split_edge_and_insert (edge, rtx);\n \n extern void commit_edge_insertions (void);\n extern void commit_edge_insertions_watch_calls (void);"}, {"sha": "0378b13ba8007c30331f79a04ebb9d8272c27ce9", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 86, "deletions": 1, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e", "patch": "@@ -29,6 +29,7 @@ Boston, MA 02110-1301, USA.  */\n #include \"tree-flow.h\"\n #include \"timevar.h\"\n #include \"toplev.h\"\n+#include \"cfgloop.h\"\n \n /* A pointer to one of the hooks containers.  */\n static struct cfg_hooks *cfg_hooks;\n@@ -115,6 +116,18 @@ verify_flow_info (void)\n       edge e;\n       edge_iterator ei;\n \n+      if (bb->loop_father != NULL && current_loops == NULL)\n+\t{\n+\t  error (\"verify_flow_info: Block %i has loop_father, but there are no loops\",\n+\t\t bb->index);\n+\t  err = 1;\n+\t}\n+      if (bb->loop_father == NULL && current_loops != NULL)\n+\t{\n+\t  error (\"verify_flow_info: Block %i lacks loop_father\", bb->index);\n+\t  err = 1;\n+\t}\n+\n       if (bb->count < 0)\n \t{\n \t  error (\"verify_flow_info: Wrong count of block %i %i\",\n@@ -308,12 +321,19 @@ basic_block\n redirect_edge_and_branch_force (edge e, basic_block dest)\n {\n   basic_block ret;\n+  struct loop *loop;\n \n   if (!cfg_hooks->redirect_edge_and_branch_force)\n     internal_error (\"%s does not support redirect_edge_and_branch_force\",\n \t\t    cfg_hooks->name);\n \n   ret = cfg_hooks->redirect_edge_and_branch_force (e, dest);\n+  if (current_loops != NULL && ret != NULL)\n+    {\n+      loop = find_common_loop (single_pred (ret)->loop_father,\n+\t\t\t       single_succ (ret)->loop_father);\n+      add_bb_to_loop (ret, loop);\n+    }\n \n   return ret;\n }\n@@ -344,6 +364,9 @@ split_block (basic_block bb, void *i)\n       set_immediate_dominator (CDI_DOMINATORS, new_bb, bb);\n     }\n \n+  if (current_loops != NULL)\n+    add_bb_to_loop (new_bb, bb->loop_father);\n+\n   return make_single_succ_edge (bb, new_bb, EDGE_FALLTHRU);\n }\n \n@@ -381,6 +404,22 @@ delete_basic_block (basic_block bb)\n \n   cfg_hooks->delete_basic_block (bb);\n \n+  if (current_loops != NULL)\n+    {\n+      struct loop *loop = bb->loop_father;\n+\n+      /* If we remove the header or the latch of a loop, mark the loop for\n+\t removal by setting its header and latch to NULL.  */\n+      if (loop->latch == bb\n+\t  || loop->header == bb)\n+\t{\n+\t  loop->header = NULL;\n+\t  loop->latch = NULL;\n+\t}\n+\n+      remove_bb_from_loops (bb);\n+    }\n+\n   /* Remove the edges into and out of this block.  Note that there may\n      indeed be edges in, if we are removing an unreachable loop.  */\n   while (EDGE_COUNT (bb->preds) != 0)\n@@ -407,6 +446,8 @@ split_edge (edge e)\n   int freq = EDGE_FREQUENCY (e);\n   edge f;\n   bool irr = (e->flags & EDGE_IRREDUCIBLE_LOOP) != 0;\n+  struct loop *loop;\n+  basic_block src = e->src, dest = e->dest;\n \n   if (!cfg_hooks->split_edge)\n     internal_error (\"%s does not support split_edge\", cfg_hooks->name);\n@@ -455,7 +496,16 @@ split_edge (edge e)\n \t  if (!f)\n \t    set_immediate_dominator (CDI_DOMINATORS, single_succ (ret), ret);\n \t}\n-    };\n+    }\n+\n+  if (current_loops != NULL)\n+    {\n+      loop = find_common_loop (src->loop_father, dest->loop_father);\n+      add_bb_to_loop (ret, loop);\n+\n+      if (loop->latch == src)\n+\tloop->latch = ret;\n+    }\n \n   return ret;\n }\n@@ -534,6 +584,9 @@ merge_blocks (basic_block a, basic_block b)\n   if (!cfg_hooks->merge_blocks)\n     internal_error (\"%s does not support merge_blocks\", cfg_hooks->name);\n \n+  if (current_loops != NULL)\n+    remove_bb_from_loops (b);\n+\n   cfg_hooks->merge_blocks (a, b);\n \n   /* Normally there should only be one successor of A and that is B, but\n@@ -575,6 +628,7 @@ make_forwarder_block (basic_block bb, bool (*redirect_edge_p) (edge),\n   edge e, fallthru;\n   edge_iterator ei;\n   basic_block dummy, jump;\n+  struct loop *loop, *ploop, *cloop;\n \n   if (!cfg_hooks->make_forwarder_block)\n     internal_error (\"%s does not support make_forwarder_block\",\n@@ -617,6 +671,33 @@ make_forwarder_block (basic_block bb, bool (*redirect_edge_p) (edge),\n       iterate_fix_dominators (CDI_DOMINATORS, doms_to_fix, 2);\n     }\n \n+  if (current_loops != NULL)\n+    {\n+      /* If we do not split a loop header, then both blocks belong to the\n+\t same loop.  In case we split loop header and do not redirect the\n+\t latch edge to DUMMY, then DUMMY belongs to the outer loop, and\n+\t BB becomes the new header.  */\n+      loop = dummy->loop_father;\n+      if (loop->header == dummy\n+\t  && find_edge (loop->latch, dummy) == NULL)\n+\t{\n+\t  remove_bb_from_loops (dummy);\n+\t  loop->header = bb;\n+\n+\t  cloop = loop;\n+\t  FOR_EACH_EDGE (e, ei, dummy->preds)\n+\t    {\n+\t      cloop = find_common_loop (cloop, e->src->loop_father);\n+\t    }\n+\t  add_bb_to_loop (dummy, cloop);\n+\t}\n+\n+      /* In case we split loop latch, update it.  */\n+      for (ploop = loop; ploop; ploop = ploop->outer)\n+\tif (ploop->latch == dummy)\n+\t  ploop->latch = bb;\n+    }\n+\n   cfg_hooks->make_forwarder_block (fallthru);\n \n   return fallthru;\n@@ -768,6 +849,10 @@ duplicate_block (basic_block bb, edge e, basic_block after)\n   set_bb_original (new_bb, bb);\n   set_bb_copy (bb, new_bb);\n \n+  /* Add the new block to the prescribed loop.  */\n+  if (current_loops != NULL)\n+    add_bb_to_loop (new_bb, bb->loop_father->copy);\n+\n   return new_bb;\n }\n "}, {"sha": "cf76cdb4125304a8aee6b95a6d65828f6ba1305b", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e", "patch": "@@ -1230,9 +1230,7 @@ copy_bbs (basic_block *bbs, unsigned n, basic_block *new_bbs,\n       new_bb = new_bbs[i] = duplicate_block (bb, NULL, after);\n       after = new_bb;\n       bb->flags |= BB_DUPLICATED;\n-      /* Add to loop.  */\n-      add_bb_to_loop (new_bb, bb->loop_father->copy);\n-      /* Possibly set header.  */\n+      /* Possibly set loop header.  */\n       if (bb->loop_father->header == bb && bb->loop_father != base)\n \tnew_bb->loop_father->header = new_bb;\n       /* Or latch.  */"}, {"sha": "25549db5b940984555fac341e4af45104503dbdc", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 6, "deletions": 37, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e", "patch": "@@ -52,7 +52,6 @@ static bool glb_enum_p (basic_block, void *);\n static void\n flow_loops_cfg_dump (const struct loops *loops, FILE *file)\n {\n-  int i;\n   basic_block bb;\n \n   if (! loops->num || ! file)\n@@ -68,26 +67,6 @@ flow_loops_cfg_dump (const struct loops *loops, FILE *file)\n \tfprintf (file, \"%d \", succ->dest->index);\n       fprintf (file, \"}\\n\");\n     }\n-\n-  /* Dump the DFS node order.  */\n-  if (loops->cfg.dfs_order)\n-    {\n-      fputs (\";; DFS order: \", file);\n-      for (i = NUM_FIXED_BLOCKS; i < n_basic_blocks; i++)\n-\tfprintf (file, \"%d \", loops->cfg.dfs_order[i]);\n-\n-      fputs (\"\\n\", file);\n-    }\n-\n-  /* Dump the reverse completion node order.  */\n-  if (loops->cfg.rc_order)\n-    {\n-      fputs (\";; RC order: \", file);\n-      for (i = NUM_FIXED_BLOCKS; i < n_basic_blocks; i++)\n-\tfprintf (file, \"%d \", loops->cfg.rc_order[i]);\n-\n-      fputs (\"\\n\", file);\n-    }\n }\n \n /* Return nonzero if the nodes of LOOP are a subset of OUTER.  */\n@@ -208,12 +187,6 @@ flow_loops_free (struct loops *loops)\n \n       free (loops->parray);\n       loops->parray = NULL;\n-\n-      if (loops->cfg.dfs_order)\n-\tfree (loops->cfg.dfs_order);\n-      if (loops->cfg.rc_order)\n-\tfree (loops->cfg.rc_order);\n-\n     }\n }\n \n@@ -697,10 +670,6 @@ flow_loops_find (struct loops *loops)\n       rc_order = XNEWVEC (int, n_basic_blocks);\n       pre_and_rev_post_order_compute (dfs_order, rc_order, false);\n \n-      /* Save CFG derived information to avoid recomputing it.  */\n-      loops->cfg.dfs_order = dfs_order;\n-      loops->cfg.rc_order = rc_order;\n-\n       num_loops = 1;\n \n       for (b = 0; b < n_basic_blocks - NUM_FIXED_BLOCKS; b++)\n@@ -744,16 +713,14 @@ flow_loops_find (struct loops *loops)\n \n       loops->num = num_loops;\n       initialize_loops_parallel_p (loops);\n+\n+      free (dfs_order);\n+      free (rc_order);\n     }\n \n   sbitmap_free (headers);\n \n   loops->state = 0;\n-#ifdef ENABLE_CHECKING\n-  verify_flow_info ();\n-  verify_loop_structure (loops);\n-#endif\n-\n   return loops->num;\n }\n \n@@ -969,12 +936,13 @@ add_bb_to_loop (basic_block bb, struct loop *loop)\n {\n    int i;\n \n+   gcc_assert (bb->loop_father == NULL);\n    bb->loop_father = loop;\n    bb->loop_depth = loop->depth;\n    loop->num_nodes++;\n    for (i = 0; i < loop->depth; i++)\n      loop->pred[i]->num_nodes++;\n- }\n+}\n \n /* Remove basic block BB from loops.  */\n void\n@@ -983,6 +951,7 @@ remove_bb_from_loops (basic_block bb)\n    int i;\n    struct loop *loop = bb->loop_father;\n \n+   gcc_assert (loop != NULL);\n    loop->num_nodes--;\n    for (i = 0; i < loop->depth; i++)\n      loop->pred[i]->num_nodes--;"}, {"sha": "17a1cf7d9313d5952a580687eb379d09e688bd47", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 4, "deletions": 20, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e", "patch": "@@ -187,25 +187,10 @@ struct loops\n   /* Pointer to root of loop hierarchy tree.  */\n   struct loop *tree_root;\n \n-  /* Information derived from the CFG.  */\n-  struct cfg\n-  {\n-    /* The ordering of the basic blocks in a depth first search.  */\n-    int *dfs_order;\n-\n-    /* The reverse completion ordering of the basic blocks found in a\n-       depth first search.  */\n-    int *rc_order;\n-  } cfg;\n-\n   /* Headers shared by multiple loops that should be merged.  */\n   sbitmap shared_headers;\n };\n \n-/* The loop tree currently optimized.  */\n-\n-extern struct loops *current_loops;\n-\n /* Loop recognition.  */\n extern int flow_loops_find (struct loops *);\n extern void flow_loops_free (struct loops *);\n@@ -248,7 +233,6 @@ extern void remove_bb_from_loops (basic_block);\n \n extern void cancel_loop_tree (struct loops *, struct loop *);\n \n-extern basic_block loop_split_edge_with (edge, rtx);\n extern int fix_loop_placement (struct loop *);\n \n enum\n@@ -410,17 +394,17 @@ extern unsigned global_cost_for_size (unsigned, unsigned, unsigned);\n extern void init_set_costs (void);\n \n /* Loop optimizer initialization.  */\n-extern struct loops *loop_optimizer_init (unsigned);\n-extern void loop_optimizer_finalize (struct loops *);\n+extern void loop_optimizer_init (unsigned);\n+extern void loop_optimizer_finalize (void);\n \n /* Optimization passes.  */\n extern void unswitch_loops (struct loops *);\n \n enum\n {\n   UAP_PEEL = 1,\t\t/* Enables loop peeling.  */\n-  UAP_UNROLL = 2,\t/* Enables peeling of loops if it seems profitable.  */\n-  UAP_UNROLL_ALL = 4\t/* Enables peeling of all loops.  */\n+  UAP_UNROLL = 2,\t/* Enables unrolling of loops if it seems profitable.  */\n+  UAP_UNROLL_ALL = 4\t/* Enables unrolling of all loops.  */\n };\n \n extern void unroll_and_peel_loops (struct loops *, int);"}, {"sha": "9aa75e4f2d646f21e4cf8154d674ae82e4ed1963", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 34, "deletions": 29, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e", "patch": "@@ -273,8 +273,9 @@ mark_irreducible_loops (struct loops *loops)\n   edge_iterator ei;\n   int i, src, dest;\n   struct graph *g;\n-  int *queue1 = XNEWVEC (int, last_basic_block + loops->num);\n-  int *queue2 = XNEWVEC (int, last_basic_block + loops->num);\n+  int num = loops ? loops->num : 1;\n+  int *queue1 = XNEWVEC (int, last_basic_block + num);\n+  int *queue2 = XNEWVEC (int, last_basic_block + num);\n   int nq, depth;\n   struct loop *cloop;\n \n@@ -287,7 +288,7 @@ mark_irreducible_loops (struct loops *loops)\n     }\n \n   /* Create the edge lists.  */\n-  g = new_graph (last_basic_block + loops->num);\n+  g = new_graph (last_basic_block + num);\n \n   FOR_BB_BETWEEN (act, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n     FOR_EACH_EDGE (e, ei, act->succs)\n@@ -296,35 +297,38 @@ mark_irreducible_loops (struct loops *loops)\n \tif (e->dest == EXIT_BLOCK_PTR)\n \t  continue;\n \n-\t/* And latch edges.  */\n-\tif (e->dest->loop_father->header == e->dest\n-\t    && e->dest->loop_father->latch == act)\n-\t  continue;\n+\tsrc = BB_REPR (act);\n+\tdest = BB_REPR (e->dest);\n \n-\t/* Edges inside a single loop should be left where they are.  Edges\n-\t   to subloop headers should lead to representative of the subloop,\n-\t   but from the same place.\n+\tif (loops)\n+\t  {\n+\t    /* Ignore latch edges.  */\n+\t    if (e->dest->loop_father->header == e->dest\n+\t\t&& e->dest->loop_father->latch == act)\n+\t      continue;\n \n-\t   Edges exiting loops should lead from representative\n-\t   of the son of nearest common ancestor of the loops in that\n-\t   act lays.  */\n+\t    /* Edges inside a single loop should be left where they are.  Edges\n+\t       to subloop headers should lead to representative of the subloop,\n+\t       but from the same place.\n \n-\tsrc = BB_REPR (act);\n-\tdest = BB_REPR (e->dest);\n+\t       Edges exiting loops should lead from representative\n+\t       of the son of nearest common ancestor of the loops in that\n+\t       act lays.  */\n \n-\tif (e->dest->loop_father->header == e->dest)\n-\t  dest = LOOP_REPR (e->dest->loop_father);\n+\t    if (e->dest->loop_father->header == e->dest)\n+\t      dest = LOOP_REPR (e->dest->loop_father);\n \n-\tif (!flow_bb_inside_loop_p (act->loop_father, e->dest))\n-\t  {\n-\t    depth = find_common_loop (act->loop_father,\n-\t\t\t\t      e->dest->loop_father)->depth + 1;\n-\t    if (depth == act->loop_father->depth)\n-\t      cloop = act->loop_father;\n-\t    else\n-\t      cloop = act->loop_father->pred[depth];\n-\n-\t    src = LOOP_REPR (cloop);\n+\t    if (!flow_bb_inside_loop_p (act->loop_father, e->dest))\n+\t      {\n+\t\tdepth = find_common_loop (act->loop_father,\n+\t\t\t\t\t  e->dest->loop_father)->depth + 1;\n+\t\tif (depth == act->loop_father->depth)\n+\t\t  cloop = act->loop_father;\n+\t\telse\n+\t\t  cloop = act->loop_father->pred[depth];\n+\n+\t\tsrc = LOOP_REPR (cloop);\n+\t      }\n \t  }\n \n \tadd_edge (g, src, dest, e);\n@@ -339,7 +343,7 @@ mark_irreducible_loops (struct loops *loops)\n     {\n       queue1[nq++] = BB_REPR (act);\n     }\n-  for (i = 1; i < (int) loops->num; i++)\n+  for (i = 1; i < num; i++)\n     if (loops->parray[i])\n       queue1[nq++] = LOOP_REPR (loops->parray[i]);\n   dfs (g, queue1, nq, queue2, false);\n@@ -354,7 +358,8 @@ mark_irreducible_loops (struct loops *loops)\n   free (queue1);\n   free (queue2);\n \n-  loops->state |= LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS;\n+  if (loops)\n+    loops->state |= LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS;\n }\n \n /* Counts number of insns inside LOOP.  */"}, {"sha": "edb36976cc8a507ca486a7d1c163ad9038784295", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 30, "deletions": 77, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e", "patch": "@@ -40,7 +40,6 @@ static void remove_bbs (basic_block *, int);\n static bool rpe_enum_p (basic_block, void *);\n static int find_path (edge, basic_block **);\n static bool alp_enum_p (basic_block, void *);\n-static void add_loop (struct loops *, struct loop *);\n static void fix_loop_placements (struct loops *, struct loop *, bool *);\n static bool fix_bb_placement (struct loops *, basic_block);\n static void fix_bb_placements (struct loops *, basic_block, bool *);\n@@ -58,18 +57,15 @@ rpe_enum_p (basic_block bb, void *data)\n   return dominated_by_p (CDI_DOMINATORS, bb, data);\n }\n \n-/* Remove basic blocks BBS from loop structure and dominance info,\n-   and delete them afterwards.  */\n+/* Remove basic blocks BBS.  NBBS is the number of the basic blocks.  */\n+\n static void\n remove_bbs (basic_block *bbs, int nbbs)\n {\n   int i;\n \n   for (i = 0; i < nbbs; i++)\n-    {\n-      remove_bb_from_loops (bbs[i]);\n-      delete_basic_block (bbs[i]);\n-    }\n+    delete_basic_block (bbs[i]);\n }\n \n /* Find path -- i.e. the basic blocks dominated by edge E and put them\n@@ -247,9 +243,10 @@ remove_path (struct loops *loops, edge e)\n {\n   edge ae;\n   basic_block *rem_bbs, *bord_bbs, *dom_bbs, from, bb;\n-  int i, nrem, n_bord_bbs, n_dom_bbs;\n+  int i, nrem, n_bord_bbs, n_dom_bbs, nreml;\n   sbitmap seen;\n   bool deleted, irred_invalidated = false;\n+  struct loop **deleted_loop;\n \n   if (!loop_delete_branch_edge (e, 0))\n     return false;\n@@ -267,7 +264,7 @@ remove_path (struct loops *loops, edge e)\n      fix -- when e->dest has exactly one predecessor, this corresponds\n      to blocks dominated by e->dest, if not, split the edge.  */\n   if (!single_pred_p (e->dest))\n-    e = single_pred_edge (loop_split_edge_with (e, NULL_RTX));\n+    e = single_pred_edge (split_edge (e));\n \n   /* It may happen that by removing path we remove one or more loops\n      we belong to.  In this case first unloop the loops, then proceed\n@@ -311,13 +308,19 @@ remove_path (struct loops *loops, edge e)\n   dom_bbs = XCNEWVEC (basic_block, n_basic_blocks);\n \n   /* Cancel loops contained in the path.  */\n+  deleted_loop = XNEWVEC (struct loop *, nrem);\n+  nreml = 0;\n   for (i = 0; i < nrem; i++)\n     if (rem_bbs[i]->loop_father->header == rem_bbs[i])\n-      cancel_loop_tree (loops, rem_bbs[i]->loop_father);\n+      deleted_loop[nreml++] = rem_bbs[i]->loop_father;\n \n   remove_bbs (rem_bbs, nrem);\n   free (rem_bbs);\n \n+  for (i = 0; i < nreml; i++)\n+    cancel_loop_tree (loops, deleted_loop[i]);\n+  free (deleted_loop);\n+\n   /* Find blocks whose dominators may be affected.  */\n   n_dom_bbs = 0;\n   sbitmap_zero (seen);\n@@ -364,15 +367,18 @@ alp_enum_p (basic_block bb, void *alp_header)\n }\n \n /* Given LOOP structure with filled header and latch, find the body of the\n-   corresponding loop and add it to LOOPS tree.  */\n+   corresponding loop and add it to LOOPS tree.  Insert the LOOP as a son of\n+   outer.  */\n+\n static void\n-add_loop (struct loops *loops, struct loop *loop)\n+add_loop (struct loops *loops, struct loop *loop, struct loop *outer)\n {\n   basic_block *bbs;\n   int i, n;\n \n   /* Add it to loop structure.  */\n   place_new_loop (loops, loop);\n+  flow_loop_tree_node_add (outer, loop);\n   loop->level = 1;\n \n   /* Find its nodes.  */\n@@ -381,7 +387,11 @@ add_loop (struct loops *loops, struct loop *loop)\n \t\t\t  bbs, n_basic_blocks, loop->header);\n \n   for (i = 0; i < n; i++)\n-    add_bb_to_loop (bbs[i], loop);\n+    {\n+      remove_bb_from_loops (bbs[i]);\n+      add_bb_to_loop (bbs[i], loop);\n+    }\n+  remove_bb_from_loops (loop->header);\n   add_bb_to_loop (loop->header, loop);\n \n   free (bbs);\n@@ -453,10 +463,11 @@ loopify (struct loops *loops, edge latch_edge, edge header_edge,\n   set_immediate_dominator (CDI_DOMINATORS, succ_bb, switch_bb);\n \n   /* Compute new loop.  */\n-  add_loop (loops, loop);\n-  flow_loop_tree_node_add (outer, loop);\n+  add_loop (loops, loop, outer);\n \n   /* Add switch_bb to appropriate loop.  */\n+  if (switch_bb->loop_father)\n+    remove_bb_from_loops (switch_bb);\n   add_bb_to_loop (switch_bb, outer);\n \n   /* Fix frequencies.  */\n@@ -1111,21 +1122,6 @@ mfb_keep_just (edge e)\n   return e != mfb_kj_edge;\n }\n \n-/* A callback for make_forwarder block, to update data structures for a basic\n-   block JUMP created by redirecting an edge (only the latch edge is being\n-   redirected).  */\n-\n-static void\n-mfb_update_loops (basic_block jump)\n-{\n-  struct loop *loop = single_succ (jump)->loop_father;\n-\n-  if (dom_computed[CDI_DOMINATORS])\n-    set_immediate_dominator (CDI_DOMINATORS, jump, single_pred (jump));\n-  add_bb_to_loop (jump, loop);\n-  loop->latch = jump;\n-}\n-\n /* Creates a pre-header for a LOOP.  Returns newly created block.  Unless\n    CP_SIMPLE_PREHEADERS is set in FLAGS, we only force LOOP to have single\n    entry; otherwise we also force preheader block to have only one successor.\n@@ -1136,15 +1132,12 @@ create_preheader (struct loop *loop, int flags)\n {\n   edge e, fallthru;\n   basic_block dummy;\n-  struct loop *cloop, *ploop;\n   int nentry = 0;\n   bool irred = false;\n   bool latch_edge_was_fallthru;\n   edge one_succ_pred = 0;\n   edge_iterator ei;\n \n-  cloop = loop->outer;\n-\n   FOR_EACH_EDGE (e, ei, loop->header->preds)\n     {\n       if (e->src == loop->latch)\n@@ -1168,17 +1161,10 @@ create_preheader (struct loop *loop, int flags)\n \n   mfb_kj_edge = loop_latch_edge (loop);\n   latch_edge_was_fallthru = (mfb_kj_edge->flags & EDGE_FALLTHRU) != 0;\n-  fallthru = make_forwarder_block (loop->header, mfb_keep_just,\n-\t\t\t\t   mfb_update_loops);\n+  fallthru = make_forwarder_block (loop->header, mfb_keep_just, NULL);\n   dummy = fallthru->src;\n   loop->header = fallthru->dest;\n \n-  /* The header could be a latch of some superloop(s); due to design of\n-     split_block, it would now move to fallthru->dest.  */\n-  for (ploop = loop; ploop; ploop = ploop->outer)\n-    if (ploop->latch == dummy)\n-      ploop->latch = fallthru->dest;\n-\n   /* Try to be clever in placing the newly created preheader.  The idea is to\n      avoid breaking any \"fallthruness\" relationship between blocks.\n \n@@ -1197,9 +1183,6 @@ create_preheader (struct loop *loop, int flags)\n       move_block_after (dummy, e->src);\n     }\n \n-  loop->header->loop_father = loop;\n-  add_bb_to_loop (dummy, cloop);\n-\n   if (irred)\n     {\n       dummy->flags |= BB_IRREDUCIBLE_LOOP;\n@@ -1241,41 +1224,11 @@ force_single_succ_latches (struct loops *loops)\n \n       e = find_edge (loop->latch, loop->header);\n \n-      loop_split_edge_with (e, NULL_RTX);\n+      split_edge (e);\n     }\n   loops->state |= LOOPS_HAVE_SIMPLE_LATCHES;\n }\n \n-/* A quite stupid function to put INSNS on edge E. They are supposed to form\n-   just one basic block.  Jumps in INSNS are not handled, so cfg do not have to\n-   be ok after this function.  The created block is placed on correct place\n-   in LOOPS structure and its dominator is set.  */\n-basic_block\n-loop_split_edge_with (edge e, rtx insns)\n-{\n-  basic_block src, dest, new_bb;\n-  struct loop *loop_c;\n-\n-  src = e->src;\n-  dest = e->dest;\n-\n-  loop_c = find_common_loop (src->loop_father, dest->loop_father);\n-\n-  /* Create basic block for it.  */\n-\n-  new_bb = split_edge (e);\n-  add_bb_to_loop (new_bb, loop_c);\n-  new_bb->flags |= (insns ? BB_SUPERBLOCK : 0);\n-\n-  if (insns)\n-    emit_insn_after (insns, BB_END (new_bb));\n-\n-  if (dest->loop_father->latch == src)\n-    dest->loop_father->latch = new_bb;\n-\n-  return new_bb;\n-}\n-\n /* This function is called from loop_version.  It splits the entry edge\n    of the loop we want to version, adds the versioning condition, and\n    adjust the edges to the two versions of the loop appropriately.\n@@ -1424,8 +1377,8 @@ loop_version (struct loops *loops, struct loop * loop,\n   /* At this point condition_bb is loop predheader with two successors,\n      first_head and second_head.   Make sure that loop predheader has only\n      one successor.  */\n-  loop_split_edge_with (loop_preheader_edge (loop), NULL);\n-  loop_split_edge_with (loop_preheader_edge (nloop), NULL);\n+  split_edge (loop_preheader_edge (loop));\n+  split_edge (loop_preheader_edge (nloop));\n \n   return nloop;\n }"}, {"sha": "8c6f52ca95d48d4093f720fc639f0f403445275d", "filename": "gcc/doc/loop.texi", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Fdoc%2Floop.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Fdoc%2Floop.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Floop.texi?ref=598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e", "patch": "@@ -195,19 +195,11 @@ The loops tree can be manipulated using the following functions:\n @item @code{remove_bb_from_loops}: Removes a basic block from loops.\n @end itemize\n \n-The specialized versions of several low-level CFG functions that also\n-update loop structures are provided:\n+Most low-level CFG functions update loops automatically.  The following\n+functions handle some more complicated cases of CFG manipulations:\n \n @itemize\n-@item @code{loop_split_edge_with}: Splits an edge, and places a\n-specified RTL code on it.  On GIMPLE, the function can still be used,\n-but the code must be NULL.\n-@item @code{bsi_insert_on_edge_immediate_loop}: Inserts code on edge,\n-splitting it if necessary.  Only works on GIMPLE.\n @item @code{remove_path}: Removes an edge and all blocks it dominates.\n-@item @code{loop_commit_inserts}: Commits insertions scheduled on edges,\n-and sets loops for the new blocks.  This function can only be used on\n-GIMPLE.\n @item @code{split_loop_exit_edge}: Splits exit edge of the loop,\n ensuring that PHI node arguments remain in the loop (this ensures that\n loop-closed SSA form is preserved).  Only useful on GIMPLE."}, {"sha": "94c81018d83f6080f6d0db70522709849caed1f9", "filename": "gcc/function.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e", "patch": "@@ -189,6 +189,9 @@ struct function GTY(())\n   /* The control flow graph for this function.  */\n   struct control_flow_graph *cfg;\n \n+  /* The loops in this function.  */\n+  struct loops * GTY((skip)) x_current_loops;\n+\n   /* For function.c.  */\n \n   /* Points to the FUNCTION_DECL of this function.  */\n@@ -520,6 +523,7 @@ extern int trampolines_created;\n #define avail_temp_slots (cfun->x_avail_temp_slots)\n #define temp_slot_level (cfun->x_temp_slot_level)\n #define nonlocal_goto_handler_labels (cfun->x_nonlocal_goto_handler_labels)\n+#define current_loops (cfun->x_current_loops)\n \n /* Given a function decl for a containing function,\n    return the `struct function' for it.  */"}, {"sha": "ef0c51c6500e6039b803aeb6fadf65ec04b2d60e", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e", "patch": "@@ -3854,11 +3854,12 @@ if_convert (int x_life_data_ok)\n       && (!flag_reorder_blocks_and_partition || !no_new_pseudos\n \t  || !targetm.have_named_sections))\n     {\n-      struct loops loops;\n-\n-      flow_loops_find (&loops);\n-      mark_loop_exit_edges (&loops);\n-      flow_loops_free (&loops);\n+      loop_optimizer_init (0);\n+      if (current_loops)\n+\t{\n+\t  mark_loop_exit_edges (current_loops);\n+\t  loop_optimizer_finalize ();\n+\t}\n       free_dominance_info (CDI_DOMINATORS);\n     }\n "}, {"sha": "d2876a7c8a1de2c88ce2b8c8537ac8099ca75cbc", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e", "patch": "@@ -2464,7 +2464,7 @@ perfect_nestify (struct loops *loops,\n \n   /* Create the new loop.  */\n   olddest = loop->single_exit->dest;\n-  preheaderbb = loop_split_edge_with (loop->single_exit, NULL);\n+  preheaderbb = split_edge (loop->single_exit);\n   headerbb = create_empty_bb (EXIT_BLOCK_PTR->prev_bb);\n   \n   /* Push the exit phi nodes that we are moving.  */"}, {"sha": "afe65cb7d288cb65fc13c6caa6c7fcaffbdd1593", "filename": "gcc/loop-doloop.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Floop-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Floop-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-doloop.c?ref=598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e", "patch": "@@ -257,7 +257,7 @@ add_test (rtx cond, edge *e, basic_block dest)\n \n   seq = get_insns ();\n   end_sequence ();\n-  bb = loop_split_edge_with (*e, seq);\n+  bb = split_edge_and_insert (*e, seq);\n   *e = single_succ_edge (bb);\n \n   if (any_uncondjump_p (jump))\n@@ -372,9 +372,9 @@ doloop_modify (struct loop *loop, struct niter_desc *desc,\n       rtx ass = copy_rtx (desc->noloop_assumptions);\n       basic_block preheader = loop_preheader_edge (loop)->src;\n       basic_block set_zero\n-\t      = loop_split_edge_with (loop_preheader_edge (loop), NULL_RTX);\n+\t      = split_edge (loop_preheader_edge (loop));\n       basic_block new_preheader\n-\t      = loop_split_edge_with (loop_preheader_edge (loop), NULL_RTX);\n+\t      = split_edge (loop_preheader_edge (loop));\n       edge te;\n \n       /* Expand the condition testing the assumptions and if it does not pass,\n@@ -406,7 +406,6 @@ doloop_modify (struct loop *loop, struct niter_desc *desc,\n \t{\n \t  /* All the conditions were simplified to false, remove the\n \t     unreachable set_zero block.  */\n-\t  remove_bb_from_loops (set_zero);\n \t  delete_basic_block (set_zero);\n \t}\n       else"}, {"sha": "dd8eec15a68df50fd8bca25d4cbba6e1851d43f2", "filename": "gcc/loop-init.c", "status": "modified", "additions": 37, "deletions": 35, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Floop-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Floop-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-init.c?ref=598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e", "patch": "@@ -33,24 +33,27 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"flags.h\"\n \n \f\n-/* Initialize loop optimizer.  This is used by the tree and RTL loop\n+/* Initialize loop structures.  This is used by the tree and RTL loop\n    optimizers.  FLAGS specify what properties to compute and/or ensure for\n    loops.  */\n \n-struct loops *\n+void\n loop_optimizer_init (unsigned flags)\n {\n-  struct loops *loops = XCNEW (struct loops);\n   edge e;\n   edge_iterator ei;\n   static bool first_time = true;\n+  struct loops *loops;\n \n   if (first_time)\n     {\n       first_time = false;\n       init_set_costs ();\n     }\n \n+  gcc_assert (!current_loops);\n+  loops = XCNEW (struct loops);\n+\n   /* Avoid annoying special cases of edges going to exit\n      block.  */\n \n@@ -62,63 +65,64 @@ loop_optimizer_init (unsigned flags)\n \n   /* Find the loops.  */\n \n-  if (flow_loops_find (loops) <= 1)\n+  flow_loops_find (loops);\n+  current_loops = loops;\n+\n+  if (current_loops->num <= 1)\n     {\n       /* No loops.  */\n-      flow_loops_free (loops);\n-      free (loops);\n-\n-      return NULL;\n+      loop_optimizer_finalize ();\n+      return;\n     }\n \n-  /* Not going to update these.  */\n-  free (loops->cfg.rc_order);\n-  loops->cfg.rc_order = NULL;\n-  free (loops->cfg.dfs_order);\n-  loops->cfg.dfs_order = NULL;\n-\n   /* Create pre-headers.  */\n   if (flags & LOOPS_HAVE_PREHEADERS)\n-    create_preheaders (loops, CP_SIMPLE_PREHEADERS);\n+    create_preheaders (current_loops, CP_SIMPLE_PREHEADERS);\n \n   /* Force all latches to have only single successor.  */\n   if (flags & LOOPS_HAVE_SIMPLE_LATCHES)\n-    force_single_succ_latches (loops);\n+    force_single_succ_latches (current_loops);\n \n   /* Mark irreducible loops.  */\n   if (flags & LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS)\n-    mark_irreducible_loops (loops);\n+    mark_irreducible_loops (current_loops);\n \n   if (flags & LOOPS_HAVE_MARKED_SINGLE_EXITS)\n-    mark_single_exit_loops (loops);\n+    mark_single_exit_loops (current_loops);\n \n   /* Dump loops.  */\n-  flow_loops_dump (loops, dump_file, NULL, 1);\n+  flow_loops_dump (current_loops, dump_file, NULL, 1);\n \n #ifdef ENABLE_CHECKING\n   verify_dominators (CDI_DOMINATORS);\n-  verify_loop_structure (loops);\n+  verify_loop_structure (current_loops);\n #endif\n-\n-  return loops;\n }\n \n-/* Finalize loop optimizer.  */\n+/* Finalize loop structures.  */\n+\n void\n-loop_optimizer_finalize (struct loops *loops)\n+loop_optimizer_finalize (void)\n {\n   unsigned i;\n+  basic_block bb;\n \n-  if (!loops)\n+  if (!current_loops)\n     return;\n \n-  for (i = 1; i < loops->num; i++)\n-    if (loops->parray[i])\n-      free_simple_loop_desc (loops->parray[i]);\n+  for (i = 1; i < current_loops->num; i++)\n+    if (current_loops->parray[i])\n+      free_simple_loop_desc (current_loops->parray[i]);\n \n   /* Clean up.  */\n-  flow_loops_free (loops);\n-  free (loops);\n+  flow_loops_free (current_loops);\n+  free (current_loops);\n+  current_loops = NULL;\n+\n+  FOR_ALL_BB (bb)\n+    {\n+      bb->loop_father = NULL;\n+    }\n \n   /* Checking.  */\n #ifdef ENABLE_CHECKING\n@@ -173,7 +177,7 @@ rtl_loop_init (void)\n   /* Initialize structures for layout changes.  */\n   cfg_layout_initialize (0);\n \n-  current_loops = loop_optimizer_init (LOOPS_NORMAL);\n+  loop_optimizer_init (LOOPS_NORMAL);\n   return 0;\n }\n \n@@ -196,14 +200,13 @@ struct tree_opt_pass pass_rtl_loop_init =\n \n \f\n /* Finalization of the RTL loop passes.  */\n+\n static unsigned int\n rtl_loop_done (void)\n {\n   basic_block bb;\n \n-  if (current_loops)\n-    loop_optimizer_finalize (current_loops);\n-\n+  loop_optimizer_finalize ();\n   free_dominance_info (CDI_DOMINATORS);\n \n   /* Finalize layout changes.  */\n@@ -218,7 +221,6 @@ rtl_loop_done (void)\n   if (dump_file)\n     dump_flow_info (dump_file, dump_flags);\n \n-  current_loops = NULL;\n   return 0;\n }\n "}, {"sha": "49af45d4073d0d70bc9e58f4f896485ac0d8527b", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e", "patch": "@@ -899,6 +899,18 @@ decide_unroll_runtime_iterations (struct loop *loop, int flags)\n \t     loop->lpt_decision.times);\n }\n \n+/* Splits edge E and inserts INSNS on it.  */\n+\n+basic_block\n+split_edge_and_insert (edge e, rtx insns)\n+{\n+  basic_block bb = split_edge (e); \n+  gcc_assert (insns != NULL_RTX);\n+  emit_insn_after (insns, BB_END (bb));\n+  bb->flags |= BB_SUPERBLOCK;\n+  return bb;\n+}\n+\n /* Unroll LOOP for that we are able to count number of iterations in runtime\n    LOOP->LPT_DECISION.TIMES + 1 times.  The transformation does this (with some\n    extra care for case n < 0):\n@@ -1009,7 +1021,7 @@ unroll_loop_runtime_iterations (struct loops *loops, struct loop *loop)\n   end_sequence ();\n \n   /* Precondition the loop.  */\n-  loop_split_edge_with (loop_preheader_edge (loop), init_code);\n+  split_edge_and_insert (loop_preheader_edge (loop), init_code);\n \n   remove_edges = XCNEWVEC (edge, max_unroll + n_peel + 1);\n   n_remove_edges = 0;\n@@ -1033,8 +1045,7 @@ unroll_loop_runtime_iterations (struct loops *loops, struct loop *loop)\n   gcc_assert (ok);\n \n   /* Record the place where switch will be built for preconditioning.  */\n-  swtch = loop_split_edge_with (loop_preheader_edge (loop),\n-\t\t\t\tNULL_RTX);\n+  swtch = split_edge (loop_preheader_edge (loop));\n \n   for (i = 0; i < n_peel; i++)\n     {\n@@ -1053,12 +1064,12 @@ unroll_loop_runtime_iterations (struct loops *loops, struct loop *loop)\n       j = n_peel - i - (extra_zero_check ? 0 : 1);\n       p = REG_BR_PROB_BASE / (i + 2);\n \n-      preheader = loop_split_edge_with (loop_preheader_edge (loop), NULL_RTX);\n+      preheader = split_edge (loop_preheader_edge (loop));\n       branch_code = compare_and_jump_seq (copy_rtx (niter), GEN_INT (j), EQ,\n \t\t\t\t\t  block_label (preheader), p,\n \t\t\t\t\t  NULL_RTX);\n \n-      swtch = loop_split_edge_with (single_pred_edge (swtch), branch_code);\n+      swtch = split_edge_and_insert (single_pred_edge (swtch), branch_code);\n       set_immediate_dominator (CDI_DOMINATORS, preheader, swtch);\n       single_pred_edge (swtch)->probability = REG_BR_PROB_BASE - p;\n       e = make_edge (swtch, preheader,\n@@ -1071,12 +1082,12 @@ unroll_loop_runtime_iterations (struct loops *loops, struct loop *loop)\n       /* Add branch for zero iterations.  */\n       p = REG_BR_PROB_BASE / (max_unroll + 1);\n       swtch = ezc_swtch;\n-      preheader = loop_split_edge_with (loop_preheader_edge (loop), NULL_RTX);\n+      preheader = split_edge (loop_preheader_edge (loop));\n       branch_code = compare_and_jump_seq (copy_rtx (niter), const0_rtx, EQ,\n \t\t\t\t\t  block_label (preheader), p,\n \t\t\t\t\t  NULL_RTX);\n \n-      swtch = loop_split_edge_with (single_succ_edge (swtch), branch_code);\n+      swtch = split_edge_and_insert (single_succ_edge (swtch), branch_code);\n       set_immediate_dominator (CDI_DOMINATORS, preheader, swtch);\n       single_succ_edge (swtch)->probability = REG_BR_PROB_BASE - p;\n       e = make_edge (swtch, preheader,\n@@ -1717,18 +1728,12 @@ analyze_insns_in_loop (struct loop *loop)\n                                             si_info_hash, si_info_eq, free);\n   \n   /* Record the loop exit bb and loop preheader before the unrolling.  */\n-  if (!loop_preheader_edge (loop)->src)\n-    {\n-      loop_split_edge_with (loop_preheader_edge (loop), NULL_RTX);\n-      opt_info->loop_preheader = loop_split_edge_with (loop_preheader_edge (loop), NULL_RTX);\n-    }\n-  else\n-    opt_info->loop_preheader = loop_preheader_edge (loop)->src;\n+  opt_info->loop_preheader = loop_preheader_edge (loop)->src;\n   \n   if (num_edges == 1\n       && !(edges[0]->flags & EDGE_COMPLEX))\n     {\n-      opt_info->loop_exit = loop_split_edge_with (edges[0], NULL_RTX);\n+      opt_info->loop_exit = split_edge (edges[0]);\n       can_apply = true;\n     }\n   "}, {"sha": "0b378f3ffdea12be818e32c4e65d29ed119e7c9f", "filename": "gcc/loop-unswitch.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Floop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Floop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unswitch.c?ref=598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e", "patch": "@@ -480,8 +480,8 @@ unswitch_loop (struct loops *loops, struct loop *loop, basic_block unswitch_on,\n   fix_loop_placement (nloop);\n \n   /* Preserve the simple loop preheaders.  */\n-  loop_split_edge_with (loop_preheader_edge (loop), NULL_RTX);\n-  loop_split_edge_with (loop_preheader_edge (nloop), NULL_RTX);\n+  split_edge (loop_preheader_edge (loop));\n+  split_edge (loop_preheader_edge (nloop));\n \n   return nloop;\n }"}, {"sha": "62918a057ee66739c144957a4ac1c40817980bad", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e", "patch": "@@ -742,9 +742,9 @@ generate_prolog_epilog (partial_schedule_ptr ps, struct loop * loop, rtx count_r\n   for (i = 0; i < last_stage; i++)\n     duplicate_insns_of_cycles (ps, 0, i, 1);\n \n-  /* Put the prolog ,  on the one and only entry edge.  */\n+  /* Put the prolog on the entry edge.  */\n   e = loop_preheader_edge (loop);\n-  loop_split_edge_with(e , get_insns());\n+  split_edge_and_insert (e, get_insns());\n \n   end_sequence ();\n \n@@ -754,10 +754,10 @@ generate_prolog_epilog (partial_schedule_ptr ps, struct loop * loop, rtx count_r\n   for (i = 0; i < last_stage; i++)\n     duplicate_insns_of_cycles (ps, i + 1, last_stage, 0);\n \n-  /* Put the epilogue on the one and only one exit edge.  */\n+  /* Put the epilogue on the exit edge.  */\n   gcc_assert (loop->single_exit);\n   e = loop->single_exit;\n-  loop_split_edge_with(e , get_insns());\n+  split_edge_and_insert (e, get_insns());\n   end_sequence ();\n }\n \n@@ -848,15 +848,15 @@ canon_loop (struct loop *loop)\n      block.  */\n   FOR_EACH_EDGE (e, i, EXIT_BLOCK_PTR->preds)\n     if ((e->flags & EDGE_FALLTHRU) && (EDGE_COUNT (e->src->succs) > 1))\n-      loop_split_edge_with (e, NULL_RTX);\n+      split_edge (e);\n \n   if (loop->latch == loop->header\n       || EDGE_COUNT (loop->latch->succs) > 1)\n     {\n       FOR_EACH_EDGE (e, i, loop->header->preds)\n         if (e->src == loop->latch)\n           break;\n-      loop_split_edge_with (e, NULL_RTX);\n+      split_edge (e);\n     }\n }\n \n@@ -873,18 +873,17 @@ sms_schedule (void)\n   unsigned i,num_loops;\n   partial_schedule_ptr ps;\n   struct df *df;\n-  struct loops *loops;\n   basic_block bb = NULL;\n   /* vars to the versioning only if needed*/\n   struct loop * nloop;\n   basic_block condition_bb = NULL;\n   edge latch_edge;\n   gcov_type trip_count = 0;\n \n-  loops = loop_optimizer_init (LOOPS_HAVE_PREHEADERS\n-\t\t\t       | LOOPS_HAVE_MARKED_SINGLE_EXITS);\n-  if (!loops)\n-    return;  /* There is no loops to schedule.  */\n+  loop_optimizer_init (LOOPS_HAVE_PREHEADERS\n+\t\t       | LOOPS_HAVE_MARKED_SINGLE_EXITS);\n+  if (!current_loops)\n+    return;  /* There are no loops to schedule.  */\n \n   /* Initialize issue_rate.  */\n   if (targetm.sched.issue_rate)\n@@ -914,16 +913,16 @@ sms_schedule (void)\n \n   /* Allocate memory to hold the DDG array one entry for each loop.\n      We use loop->num as index into this array.  */\n-  g_arr = XCNEWVEC (ddg_ptr, loops->num);\n+  g_arr = XCNEWVEC (ddg_ptr, current_loops->num);\n \n \n   /* Build DDGs for all the relevant loops and hold them in G_ARR\n      indexed by the loop index.  */\n-  for (i = 0; i < loops->num; i++)\n+  for (i = 0; i < current_loops->num; i++)\n     {\n       rtx head, tail;\n       rtx count_reg;\n-      struct loop *loop = loops->parray[i];\n+      struct loop *loop = current_loops->parray[i];\n \n       /* For debugging.  */\n       if ((passes++ > MAX_SMS_LOOP_NUMBER) && (MAX_SMS_LOOP_NUMBER != -1))\n@@ -1018,7 +1017,7 @@ sms_schedule (void)\n   df = NULL;\n \n   /* We don't want to perform SMS on new loops - created by versioning.  */\n-  num_loops = loops->num;\n+  num_loops = current_loops->num;\n   /* Go over the built DDGs and perfrom SMS for each one of them.  */\n   for (i = 0; i < num_loops; i++)\n     {\n@@ -1027,7 +1026,7 @@ sms_schedule (void)\n       int mii, rec_mii;\n       unsigned stage_count = 0;\n       HOST_WIDEST_INT loop_count = 0;\n-      struct loop *loop = loops->parray[i];\n+      struct loop *loop = current_loops->parray[i];\n \n       if (! (g = g_arr[i]))\n         continue;\n@@ -1177,8 +1176,8 @@ sms_schedule (void)\n \t\t  rtx comp_rtx = gen_rtx_fmt_ee (GT, VOIDmode, count_reg,\n \t\t\t\t\t\t GEN_INT(stage_count));\n \n-\t\t  nloop = loop_version (loops, loop, comp_rtx, &condition_bb,\n-\t\t\t\t\ttrue);\n+\t\t  nloop = loop_version (current_loops, loop, comp_rtx,\n+\t\t\t\t\t&condition_bb, true);\n \t\t}\n \n \t      /* Set new iteration count of loop kernel.  */\n@@ -1218,7 +1217,7 @@ sms_schedule (void)\n \n   /* Release scheduler data, needed until now because of DFA.  */\n   sched_finish ();\n-  loop_optimizer_finalize (loops);\n+  loop_optimizer_finalize ();\n }\n \n /* The SMS scheduling algorithm itself"}, {"sha": "caf867ee0424d4d267a9566c4175e9b82ae56a87", "filename": "gcc/predict.c", "status": "modified", "additions": 40, "deletions": 27, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e", "patch": "@@ -74,8 +74,6 @@ static sreal real_zero, real_one, real_almost_one, real_br_prob_base,\n \n static void combine_predictions_for_insn (rtx, basic_block);\n static void dump_prediction (FILE *, enum br_predictor, int, basic_block, int);\n-static void estimate_loops_at_level (struct loop *, bitmap);\n-static void propagate_freq (struct loop *, bitmap);\n static void estimate_bb_frequencies (struct loops *);\n static void predict_paths_leading_to (basic_block, int *, enum br_predictor, enum prediction);\n static bool last_basic_block_p (basic_block);\n@@ -744,7 +742,6 @@ predict_loops (struct loops *loops_info)\n     }\n \n   scev_finalize ();\n-  current_loops = NULL;\n }\n \n /* Attempt to predict probabilities of BB outgoing edges using local\n@@ -1252,11 +1249,10 @@ static unsigned int\n tree_estimate_probability (void)\n {\n   basic_block bb;\n-  struct loops loops_info;\n \n-  flow_loops_find (&loops_info);\n+  loop_optimizer_init (0);\n   if (dump_file && (dump_flags & TDF_DETAILS))\n-    flow_loops_dump (&loops_info, dump_file, NULL, 0);\n+    flow_loops_dump (current_loops, dump_file, NULL, 0);\n \n   add_noreturn_fake_exit_edges ();\n   connect_infinite_loops_to_exit ();\n@@ -1265,8 +1261,9 @@ tree_estimate_probability (void)\n \n   tree_bb_level_predictions ();\n \n-  mark_irreducible_loops (&loops_info);\n-  predict_loops (&loops_info);\n+  mark_irreducible_loops (current_loops);\n+  if (current_loops)\n+    predict_loops (current_loops);\n \n   FOR_EACH_BB (bb)\n     {\n@@ -1328,10 +1325,10 @@ tree_estimate_probability (void)\n     combine_predictions_for_bb (bb);\n \n   strip_builtin_expect ();\n-  estimate_bb_frequencies (&loops_info);\n+  estimate_bb_frequencies (current_loops);\n   free_dominance_info (CDI_POST_DOMINATORS);\n   remove_fake_exit_edges ();\n-  flow_loops_free (&loops_info);\n+  loop_optimizer_finalize ();\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     dump_tree_cfg (dump_file, dump_flags);\n   if (profile_status == PROFILE_ABSENT)\n@@ -1437,12 +1434,12 @@ typedef struct edge_info_def\n #define EDGE_INFO(E)\t((edge_info) (E)->aux)\n \n /* Helper function for estimate_bb_frequencies.\n-   Propagate the frequencies for LOOP.  */\n+   Propagate the frequencies in blocks marked in\n+   TOVISIT, starting in HEAD.  */\n \n static void\n-propagate_freq (struct loop *loop, bitmap tovisit)\n+propagate_freq (basic_block head, bitmap tovisit)\n {\n-  basic_block head = loop->header;\n   basic_block bb;\n   basic_block last;\n   unsigned i;\n@@ -1579,7 +1576,7 @@ propagate_freq (struct loop *loop, bitmap tovisit)\n /* Estimate probabilities of loopback edges in loops at same nest level.  */\n \n static void\n-estimate_loops_at_level (struct loop *first_loop, bitmap tovisit)\n+estimate_loops_at_level (struct loop *first_loop)\n {\n   struct loop *loop;\n \n@@ -1588,25 +1585,44 @@ estimate_loops_at_level (struct loop *first_loop, bitmap tovisit)\n       edge e;\n       basic_block *bbs;\n       unsigned i;\n+      bitmap tovisit = BITMAP_ALLOC (NULL);\n \n-      estimate_loops_at_level (loop->inner, tovisit);\n+      estimate_loops_at_level (loop->inner);\n \n-      /* Do not do this for dummy function loop.  */\n-      if (EDGE_COUNT (loop->latch->succs) > 0)\n-\t{\n-\t  /* Find current loop back edge and mark it.  */\n-\t  e = loop_latch_edge (loop);\n-\t  EDGE_INFO (e)->back_edge = 1;\n-       }\n+      /* Find current loop back edge and mark it.  */\n+      e = loop_latch_edge (loop);\n+      EDGE_INFO (e)->back_edge = 1;\n \n       bbs = get_loop_body (loop);\n       for (i = 0; i < loop->num_nodes; i++)\n \tbitmap_set_bit (tovisit, bbs[i]->index);\n       free (bbs);\n-      propagate_freq (loop, tovisit);\n+      propagate_freq (loop->header, tovisit);\n+      BITMAP_FREE (tovisit);\n     }\n }\n \n+/* Propates frequencies through structure of LOOPS.  */\n+\n+static void\n+estimate_loops (struct loops *loops)\n+{\n+  bitmap tovisit = BITMAP_ALLOC (NULL);\n+  basic_block bb;\n+\n+  /* Start by estimating the frequencies in the loops.  */\n+  if (loops)\n+    estimate_loops_at_level (loops->tree_root->inner);\n+\n+  /* Now propagate the frequencies through all the blocks.  */\n+  FOR_ALL_BB (bb)\n+    {\n+      bitmap_set_bit (tovisit, bb->index);\n+    }\n+  propagate_freq (ENTRY_BLOCK_PTR, tovisit);\n+  BITMAP_FREE (tovisit);\n+}\n+\n /* Convert counts measured by profile driven feedback to frequencies.\n    Return nonzero iff there was any nonzero execution count.  */\n \n@@ -1677,7 +1693,6 @@ estimate_bb_frequencies (struct loops *loops)\n   if (!flag_branch_probabilities || !counts_to_freqs ())\n     {\n       static int real_values_initialized = 0;\n-      bitmap tovisit;\n \n       if (!real_values_initialized)\n         {\n@@ -1696,7 +1711,6 @@ estimate_bb_frequencies (struct loops *loops)\n       single_succ_edge (ENTRY_BLOCK_PTR)->probability = REG_BR_PROB_BASE;\n \n       /* Set up block info for each basic block.  */\n-      tovisit = BITMAP_ALLOC (NULL);\n       alloc_aux_for_blocks (sizeof (struct block_info_def));\n       alloc_aux_for_edges (sizeof (struct edge_info_def));\n       FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n@@ -1715,7 +1729,7 @@ estimate_bb_frequencies (struct loops *loops)\n \n       /* First compute probabilities locally for each loop from innermost\n          to outermost to examine probabilities for back edges.  */\n-      estimate_loops_at_level (loops->tree_root, tovisit);\n+      estimate_loops (loops);\n \n       memcpy (&freq_max, &real_zero, sizeof (real_zero));\n       FOR_EACH_BB (bb)\n@@ -1734,7 +1748,6 @@ estimate_bb_frequencies (struct loops *loops)\n \n       free_aux_for_blocks ();\n       free_aux_for_edges ();\n-      BITMAP_FREE (tovisit);\n     }\n   compute_function_frequency ();\n   if (flag_reorder_functions)"}, {"sha": "292fa48fb21f6b3dc2ebc40116ccd4d6da6bdff6", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e", "patch": "@@ -1998,24 +1998,15 @@ remove_bb (basic_block bb)\n \t}\n     }\n \n-  /* If we remove the header or the latch of a loop, mark the loop for\n-     removal by setting its header and latch to NULL.  */\n   if (current_loops)\n     {\n       struct loop *loop = bb->loop_father;\n \n+      /* If a loop gets removed, clean up the information associated\n+\t with it.  */\n       if (loop->latch == bb\n \t  || loop->header == bb)\n-\t{\n-\t  loop->latch = NULL;\n-\t  loop->header = NULL;\n-\n-\t  /* Also clean up the information associated with the loop.  Updating\n-\t     it would waste time. More importantly, it may refer to ssa\n-\t     names that were defined in other removed basic block -- these\n-\t     ssa names are now removed and invalid.  */\n-\t  free_numbers_of_iterations_estimates_loop (loop);\n-\t}\n+\tfree_numbers_of_iterations_estimates_loop (loop);\n     }\n \n   /* Remove all the instructions in the block.  */"}, {"sha": "2444ced0bc465ff22f87511e97e105c1916b0f18", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e", "patch": "@@ -836,13 +836,11 @@ void free_numbers_of_iterations_estimates (struct loops *);\n void free_numbers_of_iterations_estimates_loop (struct loop *);\n void rewrite_into_loop_closed_ssa (bitmap, unsigned);\n void verify_loop_closed_ssa (void);\n-void loop_commit_inserts (void);\n bool for_each_index (tree *, bool (*) (tree, tree *, void *), void *);\n void create_iv (tree, tree, tree, struct loop *, block_stmt_iterator *, bool,\n \t\ttree *, tree *);\n void split_loop_exit_edge (edge);\n unsigned force_expr_to_var_cost (tree);\n-basic_block bsi_insert_on_edge_immediate_loop (edge, tree);\n void standard_iv_increment_position (struct loop *, block_stmt_iterator *,\n \t\t\t\t     bool *);\n basic_block ip_end_pos (struct loop *);"}, {"sha": "a4daaa239c2e1c332685910c96eb7d43144a245e", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e", "patch": "@@ -949,17 +949,9 @@ combine_blocks (struct loop *loop)\n       /* Update stmt list.  */\n       last = tsi_last (merge_target_bb->stmt_list);\n       tsi_link_after (&last, bb->stmt_list, TSI_NEW_STMT);\n-      bb->stmt_list = NULL;\n+      bb->stmt_list = alloc_stmt_list ();\n \n-      /* Update dominator info.  */\n-      if (dom_computed[CDI_DOMINATORS])\n-\tdelete_from_dominance_info (CDI_DOMINATORS, bb);\n-      if (dom_computed[CDI_POST_DOMINATORS])\n-\tdelete_from_dominance_info (CDI_POST_DOMINATORS, bb);\n-\n-      /* Remove basic block.  */\n-      remove_bb_from_loops (bb);\n-      expunge_block (bb);\n+      delete_basic_block (bb);\n     }\n \n   /* Now if possible, merge loop header and block with exit edge.\n@@ -968,10 +960,7 @@ combine_blocks (struct loop *loop)\n   if (exit_bb\n       && exit_bb != loop->header\n       && can_merge_blocks_p (loop->header, exit_bb))\n-    {\n-      remove_bb_from_loops (exit_bb);\n-      merge_blocks (loop->header, exit_bb);\n-    }\n+    merge_blocks (loop->header, exit_bb);\n }\n \n /* Make new  temp variable of type TYPE. Add MODIFY_EXPR to assign EXP"}, {"sha": "4ec276d8e5c94b91a14a084336936b518ef81166", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e", "patch": "@@ -240,7 +240,6 @@ tree_ssa_dominator_optimize (void)\n {\n   struct dom_walk_data walk_data;\n   unsigned int i;\n-  struct loops loops_info;\n \n   memset (&opt_stats, 0, sizeof (opt_stats));\n \n@@ -276,9 +275,12 @@ tree_ssa_dominator_optimize (void)\n   /* We need to know which edges exit loops so that we can\n      aggressively thread through loop headers to an exit\n      edge.  */\n-  flow_loops_find (&loops_info);\n-  mark_loop_exit_edges (&loops_info);\n-  flow_loops_free (&loops_info);\n+  loop_optimizer_init (0);\n+  if (current_loops)\n+    {\n+      mark_loop_exit_edges (current_loops);\n+      loop_optimizer_finalize ();\n+    }\n \n   /* Clean up the CFG so that any forwarder blocks created by loop\n      canonicalization are removed.  */"}, {"sha": "30db10c17ebe166dbba43b856a9aadada03f1f64", "filename": "gcc/tree-ssa-loop-ch.c", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Ftree-ssa-loop-ch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Ftree-ssa-loop-ch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ch.c?ref=598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e", "patch": "@@ -123,7 +123,6 @@ do_while_loop_p (struct loop *loop)\n static unsigned int\n copy_loop_headers (void)\n {\n-  struct loops *loops;\n   unsigned i;\n   struct loop *loop;\n   basic_block header;\n@@ -132,25 +131,25 @@ copy_loop_headers (void)\n   unsigned n_bbs;\n   unsigned bbs_size;\n \n-  loops = loop_optimizer_init (LOOPS_HAVE_PREHEADERS\n-\t\t\t       | LOOPS_HAVE_SIMPLE_LATCHES);\n-  if (!loops)\n+  loop_optimizer_init (LOOPS_HAVE_PREHEADERS\n+\t\t       | LOOPS_HAVE_SIMPLE_LATCHES);\n+  if (!current_loops)\n     return 0;\n \n #ifdef ENABLE_CHECKING\n-  verify_loop_structure (loops);\n+  verify_loop_structure (current_loops);\n #endif\n \n   bbs = XNEWVEC (basic_block, n_basic_blocks);\n   copied_bbs = XNEWVEC (basic_block, n_basic_blocks);\n   bbs_size = n_basic_blocks;\n \n-  for (i = 1; i < loops->num; i++)\n+  for (i = 1; i < current_loops->num; i++)\n     {\n       /* Copy at most 20 insns.  */\n       int limit = 20;\n \n-      loop = loops->parray[i];\n+      loop = current_loops->parray[i];\n       if (!loop)\n \tcontinue;\n       header = loop->header;\n@@ -194,7 +193,7 @@ copy_loop_headers (void)\n       /* Ensure that the header will have just the latch as a predecessor\n \t inside the loop.  */\n       if (!single_pred_p (exit->dest))\n-\texit = single_pred_edge (loop_split_edge_with (exit, NULL));\n+\texit = single_pred_edge (split_edge (exit));\n \n       entry = loop_preheader_edge (loop);\n \n@@ -206,14 +205,14 @@ copy_loop_headers (void)\n \n       /* Ensure that the latch and the preheader is simple (we know that they\n \t are not now, since there was the loop exit condition.  */\n-      loop_split_edge_with (loop_preheader_edge (loop), NULL);\n-      loop_split_edge_with (loop_latch_edge (loop), NULL);\n+      split_edge (loop_preheader_edge (loop));\n+      split_edge (loop_latch_edge (loop));\n     }\n \n   free (bbs);\n   free (copied_bbs);\n \n-  loop_optimizer_finalize (loops);\n+  loop_optimizer_finalize ();\n   return 0;\n }\n "}, {"sha": "de0429e7683da0cea552da8e88579eebf5c2bee0", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 2, "deletions": 21, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e", "patch": "@@ -690,25 +690,6 @@ determine_invariantness (void)\n   fini_walk_dominator_tree (&walk_data);\n }\n \n-/* Commits edge insertions and updates loop structures.  */\n-\n-void\n-loop_commit_inserts (void)\n-{\n-  unsigned old_last_basic_block, i;\n-  basic_block bb;\n-\n-  old_last_basic_block = last_basic_block;\n-  bsi_commit_edge_inserts ();\n-  for (i = old_last_basic_block; i < (unsigned) last_basic_block; i++)\n-    {\n-      bb = BASIC_BLOCK (i);\n-      add_bb_to_loop (bb,\n-\t\t      find_common_loop (single_pred (bb)->loop_father,\n-\t\t\t\t\tsingle_succ (bb)->loop_father));\n-    }\n-}\n-\n /* Hoist the statements in basic block BB out of the loops prescribed by\n    data stored in LIM_DATA structures associated with each statement.  Callback\n    for walk_dominator_tree.  */\n@@ -778,7 +759,7 @@ move_computations (void)\n   walk_dominator_tree (&walk_data, ENTRY_BLOCK_PTR);\n   fini_walk_dominator_tree (&walk_data);\n \n-  loop_commit_inserts ();\n+  bsi_commit_edge_inserts ();\n   if (need_ssa_update_p ())\n     rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa);\n }\n@@ -1419,7 +1400,7 @@ determine_lsm (struct loops *loops)\n \t  loop = loop->outer;\n \t  if (loop == loops->tree_root)\n \t    {\n-\t      loop_commit_inserts ();\n+\t      bsi_commit_edge_inserts ();\n \t      return;\n \t    }\n \t}"}, {"sha": "68e0fa6fe492c166ce32351a6cd43acc365b0446", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 8, "deletions": 34, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e", "patch": "@@ -98,7 +98,7 @@ create_iv (tree base, tree step, tree var, struct loop *loop,\n      loop (i.e. the step should be loop invariant).  */\n   step = force_gimple_operand (step, &stmts, true, var);\n   if (stmts)\n-    bsi_insert_on_edge_immediate_loop (pe, stmts);\n+    bsi_insert_on_edge_immediate (pe, stmts);\n \n   stmt = build2 (MODIFY_EXPR, void_type_node, va,\n \t\t build2 (incr_op, TREE_TYPE (base),\n@@ -111,7 +111,7 @@ create_iv (tree base, tree step, tree var, struct loop *loop,\n \n   initial = force_gimple_operand (base, &stmts, true, var);\n   if (stmts)\n-    bsi_insert_on_edge_immediate_loop (pe, stmts);\n+    bsi_insert_on_edge_immediate (pe, stmts);\n \n   stmt = create_phi_node (vb, loop->header);\n   SSA_NAME_DEF_STMT (vb) = stmt;\n@@ -445,7 +445,7 @@ void\n split_loop_exit_edge (edge exit)\n {\n   basic_block dest = exit->dest;\n-  basic_block bb = loop_split_edge_with (exit, NULL);\n+  basic_block bb = split_edge (exit);\n   tree phi, new_phi, new_name, name;\n   use_operand_p op_p;\n \n@@ -470,32 +470,6 @@ split_loop_exit_edge (edge exit)\n     }\n }\n \n-/* Insert statement STMT to the edge E and update the loop structures.\n-   Returns the newly created block (if any).  */\n-\n-basic_block\n-bsi_insert_on_edge_immediate_loop (edge e, tree stmt)\n-{\n-  basic_block src, dest, new_bb;\n-  struct loop *loop_c;\n-\n-  src = e->src;\n-  dest = e->dest;\n-\n-  loop_c = find_common_loop (src->loop_father, dest->loop_father);\n-\n-  new_bb = bsi_insert_on_edge_immediate (e, stmt);\n-\n-  if (!new_bb)\n-    return NULL;\n-\n-  add_bb_to_loop (new_bb, loop_c);\n-  if (dest->loop_father->latch == src)\n-    dest->loop_father->latch = new_bb;\n-\n-  return new_bb;\n-}\n-\n /* Returns the basic block in that statements should be emitted for induction\n    variables incremented at the end of the LOOP.  */\n \n@@ -749,24 +723,24 @@ determine_exit_conditions (struct loop *loop, struct tree_niter_desc *desc,\n \n   cond = force_gimple_operand (unshare_expr (cond), &stmts, false, NULL_TREE);\n   if (stmts)\n-    bsi_insert_on_edge_immediate_loop (loop_preheader_edge (loop), stmts);\n+    bsi_insert_on_edge_immediate (loop_preheader_edge (loop), stmts);\n   /* cond now may be a gimple comparison, which would be OK, but also any\n      other gimple rhs (say a && b).  In this case we need to force it to\n      operand.  */\n   if (!is_gimple_condexpr (cond))\n     {\n       cond = force_gimple_operand (cond, &stmts, true, NULL_TREE);\n       if (stmts)\n-\tbsi_insert_on_edge_immediate_loop (loop_preheader_edge (loop), stmts);\n+\tbsi_insert_on_edge_immediate (loop_preheader_edge (loop), stmts);\n     }\n   *enter_cond = cond;\n \n   base = force_gimple_operand (unshare_expr (base), &stmts, true, NULL_TREE);\n   if (stmts)\n-    bsi_insert_on_edge_immediate_loop (loop_preheader_edge (loop), stmts);\n+    bsi_insert_on_edge_immediate (loop_preheader_edge (loop), stmts);\n   bound = force_gimple_operand (unshare_expr (bound), &stmts, true, NULL_TREE);\n   if (stmts)\n-    bsi_insert_on_edge_immediate_loop (loop_preheader_edge (loop), stmts);\n+    bsi_insert_on_edge_immediate (loop_preheader_edge (loop), stmts);\n \n   *exit_base = base;\n   *exit_step = bigstep;\n@@ -881,7 +855,7 @@ tree_unroll_loop (struct loops *loops, struct loop *loop, unsigned factor,\n   /* Prepare the cfg and update the phi nodes.  */\n   rest = loop_preheader_edge (new_loop)->src;\n   precond_edge = single_pred_edge (rest);\n-  loop_split_edge_with (loop_latch_edge (loop), NULL);\n+  split_edge (loop_latch_edge (loop));\n   exit_bb = single_pred (loop->latch);\n \n   new_exit = make_edge (exit_bb, rest, EDGE_FALSE_VALUE | irr);"}, {"sha": "69d353b7c15997778405d031febe3ebd21414dde", "filename": "gcc/tree-ssa-loop.c", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Ftree-ssa-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Ftree-ssa-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.c?ref=598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e", "patch": "@@ -38,26 +38,17 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"tree-inline.h\"\n #include \"tree-scalar-evolution.h\"\n \n-/* The loop tree currently optimized.  */\n-\n-struct loops *current_loops = NULL;\n-\n /* Initializes the loop structures.  */\n \n-static struct loops *\n+static void\n tree_loop_optimizer_init (void)\n {\n-  struct loops *loops;\n- \n-  loops = loop_optimizer_init (LOOPS_NORMAL\n-\t\t\t       | LOOPS_HAVE_MARKED_SINGLE_EXITS);\n-\n-  if (!loops)\n-    return NULL;\n+  loop_optimizer_init (LOOPS_NORMAL\n+\t\t       | LOOPS_HAVE_MARKED_SINGLE_EXITS);\n+  if (!current_loops)\n+    return;\n \n   rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa);\n-\n-  return loops;\n }\n \n /* The loop superpass.  */\n@@ -90,7 +81,7 @@ struct tree_opt_pass pass_tree_loop =\n static unsigned int\n tree_ssa_loop_init (void)\n {\n-  current_loops = tree_loop_optimizer_init ();\n+  tree_loop_optimizer_init ();\n   if (!current_loops)\n     return 0;\n \n@@ -487,8 +478,7 @@ tree_ssa_loop_done (void)\n \n   free_numbers_of_iterations_estimates (current_loops);\n   scev_finalize ();\n-  loop_optimizer_finalize (current_loops);\n-  current_loops = NULL;\n+  loop_optimizer_finalize ();\n   return 0;\n }\n   "}, {"sha": "2a0ac9641a476f178b1c80bdfc06188a053bbb46", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e", "patch": "@@ -4065,7 +4065,7 @@ init_pre (bool do_fre)\n \n   vn_init ();\n   if (!do_fre)\n-    current_loops = loop_optimizer_init (LOOPS_NORMAL);\n+    loop_optimizer_init (LOOPS_NORMAL);\n \n   connect_infinite_loops_to_exit ();\n   memset (&pre_stats, 0, sizeof (pre_stats));\n@@ -4169,10 +4169,7 @@ fini_pre (bool do_fre)\n \tSSA_NAME_VALUE (name) = NULL;\n     }\n   if (!do_fre && current_loops)\n-    {\n-      loop_optimizer_finalize (current_loops);\n-      current_loops = NULL;\n-    }\n+    loop_optimizer_finalize ();\n }\n \n /* Main entry point to the SSA-PRE pass.  DO_FRE is true if the caller"}, {"sha": "fa711b386430b2f921ddd775cfd99d3fde4ad9c2", "filename": "gcc/tree-ssa-sink.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Ftree-ssa-sink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Ftree-ssa-sink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sink.c?ref=598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e", "patch": "@@ -522,7 +522,7 @@ sink_code_in_bb (basic_block bb)\n static void\n execute_sink_code (void)\n {\n-  struct loops *loops = loop_optimizer_init (LOOPS_NORMAL);\n+  loop_optimizer_init (LOOPS_NORMAL);\n \n   connect_infinite_loops_to_exit ();\n   memset (&sink_stats, 0, sizeof (sink_stats));\n@@ -532,7 +532,7 @@ execute_sink_code (void)\n     fprintf (dump_file, \"Sunk statements:%d\\n\", sink_stats.sunk);\n   free_dominance_info (CDI_POST_DOMINATORS);\n   remove_fake_exit_edges ();\n-  loop_optimizer_finalize (loops);\n+  loop_optimizer_finalize ();\n }\n \n /* Gate and execute functions for PRE.  */"}, {"sha": "6091575ebc46a9f82850d1c6eae6394c9db847a6", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e", "patch": "@@ -3845,7 +3845,6 @@ vect_transform_loop (loop_vec_info loop_vinfo,\n       merge_bb = loop->single_exit->dest;\n       gcc_assert (EDGE_COUNT (merge_bb->preds) == 2);\n       new_exit_bb = split_edge (loop->single_exit);\n-      add_bb_to_loop (new_exit_bb, loop->outer);\n       new_exit_e = loop->single_exit;\n       e = EDGE_SUCC (new_exit_bb, 0);\n \n@@ -3897,8 +3896,7 @@ vect_transform_loop (loop_vec_info loop_vinfo,\n \n   gcc_assert (EDGE_COUNT (loop->header->preds) == 2);\n \n-  loop_split_edge_with (loop_preheader_edge (loop), NULL);\n-\n+  split_edge (loop_preheader_edge (loop));\n \n   /* FORNOW: the vectorizer supports only loops which body consist\n      of one basic block (header + empty latch). When the vectorizer will "}, {"sha": "8bc6885906d7ec62ba81382a68a8058e0b377a29", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e", "patch": "@@ -520,7 +520,6 @@ slpeel_update_phi_nodes_for_guard1 (edge guard_edge, struct loop *loop,\n \n   /* Create new bb between loop and new_merge_bb.  */\n   *new_exit_bb = split_edge (loop->single_exit);\n-  add_bb_to_loop (*new_exit_bb, loop->outer);\n \n   new_exit_e = EDGE_SUCC (*new_exit_bb, 0);\n \n@@ -646,7 +645,6 @@ slpeel_update_phi_nodes_for_guard2 (edge guard_edge, struct loop *loop,\n \n   /* Create new bb between loop and new_merge_bb.  */\n   *new_exit_bb = split_edge (loop->single_exit);\n-  add_bb_to_loop (*new_exit_bb, loop->outer);\n \n   new_exit_e = EDGE_SUCC (*new_exit_bb, 0);\n \n@@ -1157,9 +1155,7 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop, struct loops *loops,\n    */\n \n   bb_before_first_loop = split_edge (loop_preheader_edge (first_loop));\n-  add_bb_to_loop (bb_before_first_loop, first_loop->outer);\n   bb_before_second_loop = split_edge (first_loop->single_exit);\n-  add_bb_to_loop (bb_before_second_loop, first_loop->outer);\n \n   pre_condition =\n     fold_build2 (LE_EXPR, boolean_type_node, first_niters, \n@@ -1199,7 +1195,6 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop, struct loops *loops,\n \n   bb_between_loops = new_exit_bb;\n   bb_after_second_loop = split_edge (second_loop->single_exit);\n-  add_bb_to_loop (bb_after_second_loop, second_loop->outer);\n \n   pre_condition = \n \tfold_build2 (EQ_EXPR, boolean_type_node, first_niters, niters);"}, {"sha": "7b8996c5964560fa613c07465972c7120ebd22cc", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e", "patch": "@@ -4772,7 +4772,7 @@ execute_vrp (void)\n {\n   insert_range_assertions ();\n \n-  current_loops = loop_optimizer_init (LOOPS_NORMAL);\n+  loop_optimizer_init (LOOPS_NORMAL);\n   if (current_loops)\n     scev_initialize (current_loops);\n \n@@ -4783,8 +4783,7 @@ execute_vrp (void)\n   if (current_loops)\n     {\n       scev_finalize ();\n-      loop_optimizer_finalize (current_loops);\n-      current_loops = NULL;\n+      loop_optimizer_finalize ();\n     }\n \n   /* ASSERT_EXPRs must be removed before finalizing jump threads"}]}