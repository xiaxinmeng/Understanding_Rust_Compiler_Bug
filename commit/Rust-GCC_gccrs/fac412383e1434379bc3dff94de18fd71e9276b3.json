{"sha": "fac412383e1434379bc3dff94de18fd71e9276b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmFjNDEyMzgzZTE0MzQzNzliYzNkZmY5NGRlMThmZDcxZTkyNzZiMw==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2009-05-07T15:47:11Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2009-05-07T15:47:11Z"}, "message": "Makefile.in (OBJS-common): Add regcprop.o.\n\n2009-05-07  Paolo Bonzini  <bonzini@gnu.org>\n\n\t* Makefile.in (OBJS-common): Add regcprop.o.\n\t(regcprop.o): New.\n\t* timevar.def (TV_CPROP_REGISTERS): New.\n\t* regrename.c (regrename_optimize): Return 0.\n\t(rest_of_handle_regrename): Delete.\n\t(pass_rename_registers): Point to regrename_optimize.\n\t(struct value_data_entry, struct value_data, \n\tkill_value_one_regno, kill_value_regno, kill_value,\n\tset_value_regno, init_value_data, kill_clobbered_value,\n\tkill_set_value, kill_autoinc_value, copy_value,\n\tmode_change_ok, maybe_mode_change, find_oldest_value_reg,\n\treplace_oldest_value_reg, replace_oldest_value_addr,\n\treplace_oldest_value_mem, copyprop_hardreg_forward_1,\n\tdebug_value_data, validate_value_data): Move...\n\t* regcprop.c: ... here.\n\t(rest_of_handle_cprop): Delete.\n\t(pass_cprop_hardreg): Point to copyprop_hardreg_forward.\n\nFrom-SVN: r147243", "tree": {"sha": "d483d165b55d90513dbc2701927d1cf54f9fe41b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d483d165b55d90513dbc2701927d1cf54f9fe41b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fac412383e1434379bc3dff94de18fd71e9276b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fac412383e1434379bc3dff94de18fd71e9276b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fac412383e1434379bc3dff94de18fd71e9276b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fac412383e1434379bc3dff94de18fd71e9276b3/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "472e0df9f0f70801be6a5097799d3fefba9ad078", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/472e0df9f0f70801be6a5097799d3fefba9ad078", "html_url": "https://github.com/Rust-GCC/gccrs/commit/472e0df9f0f70801be6a5097799d3fefba9ad078"}], "stats": {"total": 2015, "additions": 1035, "deletions": 980}, "files": [{"sha": "f318d33f77fb6c1d03965995e888e53b4d8134c7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fac412383e1434379bc3dff94de18fd71e9276b3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fac412383e1434379bc3dff94de18fd71e9276b3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fac412383e1434379bc3dff94de18fd71e9276b3", "patch": "@@ -1,3 +1,23 @@\n+2009-05-07  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* Makefile.in (OBJS-common): Add regcprop.o.\n+\t(regcprop.o): New.\n+\t* timevar.def (TV_CPROP_REGISTERS): New.\n+\t* regrename.c (regrename_optimize): Return 0.\n+\t(rest_of_handle_regrename): Delete.\n+\t(pass_rename_registers): Point to regrename_optimize.\n+\t(struct value_data_entry, struct value_data, \n+\tkill_value_one_regno, kill_value_regno, kill_value,\n+\tset_value_regno, init_value_data, kill_clobbered_value,\n+\tkill_set_value, kill_autoinc_value, copy_value,\n+\tmode_change_ok, maybe_mode_change, find_oldest_value_reg,\n+\treplace_oldest_value_reg, replace_oldest_value_addr,\n+\treplace_oldest_value_mem, copyprop_hardreg_forward_1,\n+\tdebug_value_data, validate_value_data): Move...\n+\t* regcprop.c: ... here.\n+\t(rest_of_handle_cprop): Delete.\n+\t(pass_cprop_hardreg): Point to copyprop_hardreg_forward.\n+\n 2009-05-07  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/40057"}, {"sha": "556bfe3748222dab98e7b374063d5954309cb2f0", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fac412383e1434379bc3dff94de18fd71e9276b3/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fac412383e1434379bc3dff94de18fd71e9276b3/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=fac412383e1434379bc3dff94de18fd71e9276b3", "patch": "@@ -1174,6 +1174,7 @@ OBJS-common = \\\n \treal.o \\\n \trecog.o \\\n \treg-stack.o \\\n+\tregcprop.o \\\n \treginfo.o \\\n \tregmove.o \\\n \tregrename.o \\\n@@ -3050,6 +3051,10 @@ cfglayout.o : cfglayout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(DF_H)\n timevar.o : timevar.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TIMEVAR_H) $(FLAGS_H) intl.h $(TOPLEV_H) $(RTL_H) timevar.def\n+regcprop.o : regcprop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+   $(RTL_H) insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h \\\n+   output.h $(RECOG_H) $(FUNCTION_H) $(OBSTACK_H) $(FLAGS_H) $(TM_P_H) \\\n+   addresses.h reload.h $(TOPLEV_H) $(TIMEVAR_H) $(TREE_PASS_H) $(DF_H)\n regrename.o : regrename.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h \\\n    output.h $(RECOG_H) $(FUNCTION_H) $(OBSTACK_H) $(FLAGS_H) $(TM_P_H) \\"}, {"sha": "87aaf02c409a68128789b000d1c002dc5d8ef016", "filename": "gcc/regcprop.c", "status": "added", "additions": 1005, "deletions": 0, "changes": 1005, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fac412383e1434379bc3dff94de18fd71e9276b3/gcc%2Fregcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fac412383e1434379bc3dff94de18fd71e9276b3/gcc%2Fregcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregcprop.c?ref=fac412383e1434379bc3dff94de18fd71e9276b3", "patch": "@@ -0,0 +1,1005 @@\n+/* Copy propagation on hard registers for the GNU compiler.\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n+   Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"tm_p.h\"\n+#include \"insn-config.h\"\n+#include \"regs.h\"\n+#include \"addresses.h\"\n+#include \"hard-reg-set.h\"\n+#include \"basic-block.h\"\n+#include \"reload.h\"\n+#include \"output.h\"\n+#include \"function.h\"\n+#include \"recog.h\"\n+#include \"flags.h\"\n+#include \"toplev.h\"\n+#include \"obstack.h\"\n+#include \"timevar.h\"\n+#include \"tree-pass.h\"\n+#include \"df.h\"\n+\n+/* The following code does forward propagation of hard register copies.\n+   The object is to eliminate as many dependencies as possible, so that\n+   we have the most scheduling freedom.  As a side effect, we also clean\n+   up some silly register allocation decisions made by reload.  This\n+   code may be obsoleted by a new register allocator.  */\n+\n+/* For each register, we have a list of registers that contain the same\n+   value.  The OLDEST_REGNO field points to the head of the list, and\n+   the NEXT_REGNO field runs through the list.  The MODE field indicates\n+   what mode the data is known to be in; this field is VOIDmode when the\n+   register is not known to contain valid data.  */\n+\n+struct value_data_entry\n+{\n+  enum machine_mode mode;\n+  unsigned int oldest_regno;\n+  unsigned int next_regno;\n+};\n+\n+struct value_data\n+{\n+  struct value_data_entry e[FIRST_PSEUDO_REGISTER];\n+  unsigned int max_value_regs;\n+};\n+\n+static void kill_value_one_regno (unsigned, struct value_data *);\n+static void kill_value_regno (unsigned, unsigned, struct value_data *);\n+static void kill_value (rtx, struct value_data *);\n+static void set_value_regno (unsigned, enum machine_mode, struct value_data *);\n+static void init_value_data (struct value_data *);\n+static void kill_clobbered_value (rtx, const_rtx, void *);\n+static void kill_set_value (rtx, const_rtx, void *);\n+static int kill_autoinc_value (rtx *, void *);\n+static void copy_value (rtx, rtx, struct value_data *);\n+static bool mode_change_ok (enum machine_mode, enum machine_mode,\n+\t\t\t    unsigned int);\n+static rtx maybe_mode_change (enum machine_mode, enum machine_mode,\n+\t\t\t      enum machine_mode, unsigned int, unsigned int);\n+static rtx find_oldest_value_reg (enum reg_class, rtx, struct value_data *);\n+static bool replace_oldest_value_reg (rtx *, enum reg_class, rtx,\n+\t\t\t\t      struct value_data *);\n+static bool replace_oldest_value_addr (rtx *, enum reg_class,\n+\t\t\t\t       enum machine_mode, rtx,\n+\t\t\t\t       struct value_data *);\n+static bool replace_oldest_value_mem (rtx, rtx, struct value_data *);\n+static bool copyprop_hardreg_forward_1 (basic_block, struct value_data *);\n+extern void debug_value_data (struct value_data *);\n+#ifdef ENABLE_CHECKING\n+static void validate_value_data (struct value_data *);\n+#endif\n+\n+/* Kill register REGNO.  This involves removing it from any value\n+   lists, and resetting the value mode to VOIDmode.  This is only a\n+   helper function; it does not handle any hard registers overlapping\n+   with REGNO.  */\n+\n+static void\n+kill_value_one_regno (unsigned int regno, struct value_data *vd)\n+{\n+  unsigned int i, next;\n+\n+  if (vd->e[regno].oldest_regno != regno)\n+    {\n+      for (i = vd->e[regno].oldest_regno;\n+\t   vd->e[i].next_regno != regno;\n+\t   i = vd->e[i].next_regno)\n+\tcontinue;\n+      vd->e[i].next_regno = vd->e[regno].next_regno;\n+    }\n+  else if ((next = vd->e[regno].next_regno) != INVALID_REGNUM)\n+    {\n+      for (i = next; i != INVALID_REGNUM; i = vd->e[i].next_regno)\n+\tvd->e[i].oldest_regno = next;\n+    }\n+\n+  vd->e[regno].mode = VOIDmode;\n+  vd->e[regno].oldest_regno = regno;\n+  vd->e[regno].next_regno = INVALID_REGNUM;\n+\n+#ifdef ENABLE_CHECKING\n+  validate_value_data (vd);\n+#endif\n+}\n+\n+/* Kill the value in register REGNO for NREGS, and any other registers\n+   whose values overlap.  */\n+\n+static void\n+kill_value_regno (unsigned int regno, unsigned int nregs,\n+\t\t  struct value_data *vd)\n+{\n+  unsigned int j;\n+\n+  /* Kill the value we're told to kill.  */\n+  for (j = 0; j < nregs; ++j)\n+    kill_value_one_regno (regno + j, vd);\n+\n+  /* Kill everything that overlapped what we're told to kill.  */\n+  if (regno < vd->max_value_regs)\n+    j = 0;\n+  else\n+    j = regno - vd->max_value_regs;\n+  for (; j < regno; ++j)\n+    {\n+      unsigned int i, n;\n+      if (vd->e[j].mode == VOIDmode)\n+\tcontinue;\n+      n = hard_regno_nregs[j][vd->e[j].mode];\n+      if (j + n > regno)\n+\tfor (i = 0; i < n; ++i)\n+\t  kill_value_one_regno (j + i, vd);\n+    }\n+}\n+\n+/* Kill X.  This is a convenience function wrapping kill_value_regno\n+   so that we mind the mode the register is in.  */\n+\n+static void\n+kill_value (rtx x, struct value_data *vd)\n+{\n+  rtx orig_rtx = x;\n+\n+  if (GET_CODE (x) == SUBREG)\n+    {\n+      x = simplify_subreg (GET_MODE (x), SUBREG_REG (x),\n+\t\t\t   GET_MODE (SUBREG_REG (x)), SUBREG_BYTE (x));\n+      if (x == NULL_RTX)\n+\tx = SUBREG_REG (orig_rtx);\n+    }\n+  if (REG_P (x))\n+    {\n+      unsigned int regno = REGNO (x);\n+      unsigned int n = hard_regno_nregs[regno][GET_MODE (x)];\n+\n+      kill_value_regno (regno, n, vd);\n+    }\n+}\n+\n+/* Remember that REGNO is valid in MODE.  */\n+\n+static void\n+set_value_regno (unsigned int regno, enum machine_mode mode,\n+\t\t struct value_data *vd)\n+{\n+  unsigned int nregs;\n+\n+  vd->e[regno].mode = mode;\n+\n+  nregs = hard_regno_nregs[regno][mode];\n+  if (nregs > vd->max_value_regs)\n+    vd->max_value_regs = nregs;\n+}\n+\n+/* Initialize VD such that there are no known relationships between regs.  */\n+\n+static void\n+init_value_data (struct value_data *vd)\n+{\n+  int i;\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; ++i)\n+    {\n+      vd->e[i].mode = VOIDmode;\n+      vd->e[i].oldest_regno = i;\n+      vd->e[i].next_regno = INVALID_REGNUM;\n+    }\n+  vd->max_value_regs = 0;\n+}\n+\n+/* Called through note_stores.  If X is clobbered, kill its value.  */\n+\n+static void\n+kill_clobbered_value (rtx x, const_rtx set, void *data)\n+{\n+  struct value_data *const vd = (struct value_data *) data;\n+  if (GET_CODE (set) == CLOBBER)\n+    kill_value (x, vd);\n+}\n+\n+/* Called through note_stores.  If X is set, not clobbered, kill its\n+   current value and install it as the root of its own value list.  */\n+\n+static void\n+kill_set_value (rtx x, const_rtx set, void *data)\n+{\n+  struct value_data *const vd = (struct value_data *) data;\n+  if (GET_CODE (set) != CLOBBER)\n+    {\n+      kill_value (x, vd);\n+      if (REG_P (x))\n+\tset_value_regno (REGNO (x), GET_MODE (x), vd);\n+    }\n+}\n+\n+/* Called through for_each_rtx.  Kill any register used as the base of an\n+   auto-increment expression, and install that register as the root of its\n+   own value list.  */\n+\n+static int\n+kill_autoinc_value (rtx *px, void *data)\n+{\n+  rtx x = *px;\n+  struct value_data *const vd = (struct value_data *) data;\n+\n+  if (GET_RTX_CLASS (GET_CODE (x)) == RTX_AUTOINC)\n+    {\n+      x = XEXP (x, 0);\n+      kill_value (x, vd);\n+      set_value_regno (REGNO (x), Pmode, vd);\n+      return -1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Assert that SRC has been copied to DEST.  Adjust the data structures\n+   to reflect that SRC contains an older copy of the shared value.  */\n+\n+static void\n+copy_value (rtx dest, rtx src, struct value_data *vd)\n+{\n+  unsigned int dr = REGNO (dest);\n+  unsigned int sr = REGNO (src);\n+  unsigned int dn, sn;\n+  unsigned int i;\n+\n+  /* ??? At present, it's possible to see noop sets.  It'd be nice if\n+     this were cleaned up beforehand...  */\n+  if (sr == dr)\n+    return;\n+\n+  /* Do not propagate copies to the stack pointer, as that can leave\n+     memory accesses with no scheduling dependency on the stack update.  */\n+  if (dr == STACK_POINTER_REGNUM)\n+    return;\n+\n+  /* Likewise with the frame pointer, if we're using one.  */\n+  if (frame_pointer_needed && dr == HARD_FRAME_POINTER_REGNUM)\n+    return;\n+\n+  /* Do not propagate copies to fixed or global registers, patterns\n+     can be relying to see particular fixed register or users can\n+     expect the chosen global register in asm.  */\n+  if (fixed_regs[dr] || global_regs[dr])\n+    return;\n+\n+  /* If SRC and DEST overlap, don't record anything.  */\n+  dn = hard_regno_nregs[dr][GET_MODE (dest)];\n+  sn = hard_regno_nregs[sr][GET_MODE (dest)];\n+  if ((dr > sr && dr < sr + sn)\n+      || (sr > dr && sr < dr + dn))\n+    return;\n+\n+  /* If SRC had no assigned mode (i.e. we didn't know it was live)\n+     assign it now and assume the value came from an input argument\n+     or somesuch.  */\n+  if (vd->e[sr].mode == VOIDmode)\n+    set_value_regno (sr, vd->e[dr].mode, vd);\n+\n+  /* If we are narrowing the input to a smaller number of hard regs,\n+     and it is in big endian, we are really extracting a high part.\n+     Since we generally associate a low part of a value with the value itself,\n+     we must not do the same for the high part.\n+     Note we can still get low parts for the same mode combination through\n+     a two-step copy involving differently sized hard regs.\n+     Assume hard regs fr* are 32 bits bits each, while r* are 64 bits each:\n+     (set (reg:DI r0) (reg:DI fr0))\n+     (set (reg:SI fr2) (reg:SI r0))\n+     loads the low part of (reg:DI fr0) - i.e. fr1 - into fr2, while:\n+     (set (reg:SI fr2) (reg:SI fr0))\n+     loads the high part of (reg:DI fr0) into fr2.\n+\n+     We can't properly represent the latter case in our tables, so don't\n+     record anything then.  */\n+  else if (sn < (unsigned int) hard_regno_nregs[sr][vd->e[sr].mode]\n+\t   && (GET_MODE_SIZE (vd->e[sr].mode) > UNITS_PER_WORD\n+\t       ? WORDS_BIG_ENDIAN : BYTES_BIG_ENDIAN))\n+    return;\n+\n+  /* If SRC had been assigned a mode narrower than the copy, we can't\n+     link DEST into the chain, because not all of the pieces of the\n+     copy came from oldest_regno.  */\n+  else if (sn > (unsigned int) hard_regno_nregs[sr][vd->e[sr].mode])\n+    return;\n+\n+  /* Link DR at the end of the value chain used by SR.  */\n+\n+  vd->e[dr].oldest_regno = vd->e[sr].oldest_regno;\n+\n+  for (i = sr; vd->e[i].next_regno != INVALID_REGNUM; i = vd->e[i].next_regno)\n+    continue;\n+  vd->e[i].next_regno = dr;\n+\n+#ifdef ENABLE_CHECKING\n+  validate_value_data (vd);\n+#endif\n+}\n+\n+/* Return true if a mode change from ORIG to NEW is allowed for REGNO.  */\n+\n+static bool\n+mode_change_ok (enum machine_mode orig_mode, enum machine_mode new_mode,\n+\t\tunsigned int regno ATTRIBUTE_UNUSED)\n+{\n+  if (GET_MODE_SIZE (orig_mode) < GET_MODE_SIZE (new_mode))\n+    return false;\n+\n+#ifdef CANNOT_CHANGE_MODE_CLASS\n+  return !REG_CANNOT_CHANGE_MODE_P (regno, orig_mode, new_mode);\n+#endif\n+\n+  return true;\n+}\n+\n+/* Register REGNO was originally set in ORIG_MODE.  It - or a copy of it -\n+   was copied in COPY_MODE to COPY_REGNO, and then COPY_REGNO was accessed\n+   in NEW_MODE.\n+   Return a NEW_MODE rtx for REGNO if that's OK, otherwise return NULL_RTX.  */\n+\n+static rtx\n+maybe_mode_change (enum machine_mode orig_mode, enum machine_mode copy_mode,\n+\t\t   enum machine_mode new_mode, unsigned int regno,\n+\t\t   unsigned int copy_regno ATTRIBUTE_UNUSED)\n+{\n+  if (GET_MODE_SIZE (copy_mode) < GET_MODE_SIZE (orig_mode)\n+      && GET_MODE_SIZE (copy_mode) < GET_MODE_SIZE (new_mode))\n+    return NULL_RTX;\n+\n+  if (orig_mode == new_mode)\n+    return gen_rtx_raw_REG (new_mode, regno);\n+  else if (mode_change_ok (orig_mode, new_mode, regno))\n+    {\n+      int copy_nregs = hard_regno_nregs[copy_regno][copy_mode];\n+      int use_nregs = hard_regno_nregs[copy_regno][new_mode];\n+      int copy_offset\n+\t= GET_MODE_SIZE (copy_mode) / copy_nregs * (copy_nregs - use_nregs);\n+      int offset\n+\t= GET_MODE_SIZE (orig_mode) - GET_MODE_SIZE (new_mode) - copy_offset;\n+      int byteoffset = offset % UNITS_PER_WORD;\n+      int wordoffset = offset - byteoffset;\n+\n+      offset = ((WORDS_BIG_ENDIAN ? wordoffset : 0)\n+\t\t+ (BYTES_BIG_ENDIAN ? byteoffset : 0));\n+      return gen_rtx_raw_REG (new_mode,\n+\t\t\t      regno + subreg_regno_offset (regno, orig_mode,\n+\t\t\t\t\t\t\t   offset,\n+\t\t\t\t\t\t\t   new_mode));\n+    }\n+  return NULL_RTX;\n+}\n+\n+/* Find the oldest copy of the value contained in REGNO that is in\n+   register class CL and has mode MODE.  If found, return an rtx\n+   of that oldest register, otherwise return NULL.  */\n+\n+static rtx\n+find_oldest_value_reg (enum reg_class cl, rtx reg, struct value_data *vd)\n+{\n+  unsigned int regno = REGNO (reg);\n+  enum machine_mode mode = GET_MODE (reg);\n+  unsigned int i;\n+\n+  /* If we are accessing REG in some mode other that what we set it in,\n+     make sure that the replacement is valid.  In particular, consider\n+\t(set (reg:DI r11) (...))\n+\t(set (reg:SI r9) (reg:SI r11))\n+\t(set (reg:SI r10) (...))\n+\t(set (...) (reg:DI r9))\n+     Replacing r9 with r11 is invalid.  */\n+  if (mode != vd->e[regno].mode)\n+    {\n+      if (hard_regno_nregs[regno][mode]\n+\t  > hard_regno_nregs[regno][vd->e[regno].mode])\n+\treturn NULL_RTX;\n+    }\n+\n+  for (i = vd->e[regno].oldest_regno; i != regno; i = vd->e[i].next_regno)\n+    {\n+      enum machine_mode oldmode = vd->e[i].mode;\n+      rtx new_rtx;\n+\n+      if (!in_hard_reg_set_p (reg_class_contents[cl], mode, i))\n+\treturn NULL_RTX;\n+\n+      new_rtx = maybe_mode_change (oldmode, vd->e[regno].mode, mode, i, regno);\n+      if (new_rtx)\n+\t{\n+\t  ORIGINAL_REGNO (new_rtx) = ORIGINAL_REGNO (reg);\n+\t  REG_ATTRS (new_rtx) = REG_ATTRS (reg);\n+\t  REG_POINTER (new_rtx) = REG_POINTER (reg);\n+\t  return new_rtx;\n+\t}\n+    }\n+\n+  return NULL_RTX;\n+}\n+\n+/* If possible, replace the register at *LOC with the oldest register\n+   in register class CL.  Return true if successfully replaced.  */\n+\n+static bool\n+replace_oldest_value_reg (rtx *loc, enum reg_class cl, rtx insn,\n+\t\t\t  struct value_data *vd)\n+{\n+  rtx new_rtx = find_oldest_value_reg (cl, *loc, vd);\n+  if (new_rtx)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"insn %u: replaced reg %u with %u\\n\",\n+\t\t INSN_UID (insn), REGNO (*loc), REGNO (new_rtx));\n+\n+      validate_change (insn, loc, new_rtx, 1);\n+      return true;\n+    }\n+  return false;\n+}\n+\n+/* Similar to replace_oldest_value_reg, but *LOC contains an address.\n+   Adapted from find_reloads_address_1.  CL is INDEX_REG_CLASS or\n+   BASE_REG_CLASS depending on how the register is being considered.  */\n+\n+static bool\n+replace_oldest_value_addr (rtx *loc, enum reg_class cl,\n+\t\t\t   enum machine_mode mode, rtx insn,\n+\t\t\t   struct value_data *vd)\n+{\n+  rtx x = *loc;\n+  RTX_CODE code = GET_CODE (x);\n+  const char *fmt;\n+  int i, j;\n+  bool changed = false;\n+\n+  switch (code)\n+    {\n+    case PLUS:\n+      {\n+\trtx orig_op0 = XEXP (x, 0);\n+\trtx orig_op1 = XEXP (x, 1);\n+\tRTX_CODE code0 = GET_CODE (orig_op0);\n+\tRTX_CODE code1 = GET_CODE (orig_op1);\n+\trtx op0 = orig_op0;\n+\trtx op1 = orig_op1;\n+\trtx *locI = NULL;\n+\trtx *locB = NULL;\n+\tenum rtx_code index_code = SCRATCH;\n+\n+\tif (GET_CODE (op0) == SUBREG)\n+\t  {\n+\t    op0 = SUBREG_REG (op0);\n+\t    code0 = GET_CODE (op0);\n+\t  }\n+\n+\tif (GET_CODE (op1) == SUBREG)\n+\t  {\n+\t    op1 = SUBREG_REG (op1);\n+\t    code1 = GET_CODE (op1);\n+\t  }\n+\n+\tif (code0 == MULT || code0 == SIGN_EXTEND || code0 == TRUNCATE\n+\t    || code0 == ZERO_EXTEND || code1 == MEM)\n+\t  {\n+\t    locI = &XEXP (x, 0);\n+\t    locB = &XEXP (x, 1);\n+\t    index_code = GET_CODE (*locI);\n+\t  }\n+\telse if (code1 == MULT || code1 == SIGN_EXTEND || code1 == TRUNCATE\n+\t\t || code1 == ZERO_EXTEND || code0 == MEM)\n+\t  {\n+\t    locI = &XEXP (x, 1);\n+\t    locB = &XEXP (x, 0);\n+\t    index_code = GET_CODE (*locI);\n+\t  }\n+\telse if (code0 == CONST_INT || code0 == CONST\n+\t\t || code0 == SYMBOL_REF || code0 == LABEL_REF)\n+\t  {\n+\t    locB = &XEXP (x, 1);\n+\t    index_code = GET_CODE (XEXP (x, 0));\n+\t  }\n+\telse if (code1 == CONST_INT || code1 == CONST\n+\t\t || code1 == SYMBOL_REF || code1 == LABEL_REF)\n+\t  {\n+\t    locB = &XEXP (x, 0);\n+\t    index_code = GET_CODE (XEXP (x, 1));\n+\t  }\n+\telse if (code0 == REG && code1 == REG)\n+\t  {\n+\t    int index_op;\n+\t    unsigned regno0 = REGNO (op0), regno1 = REGNO (op1);\n+\n+\t    if (REGNO_OK_FOR_INDEX_P (regno1)\n+\t\t&& regno_ok_for_base_p (regno0, mode, PLUS, REG))\n+\t      index_op = 1;\n+\t    else if (REGNO_OK_FOR_INDEX_P (regno0)\n+\t\t     && regno_ok_for_base_p (regno1, mode, PLUS, REG))\n+\t      index_op = 0;\n+\t    else if (regno_ok_for_base_p (regno0, mode, PLUS, REG)\n+\t\t     || REGNO_OK_FOR_INDEX_P (regno1))\n+\t      index_op = 1;\n+\t    else if (regno_ok_for_base_p (regno1, mode, PLUS, REG))\n+\t      index_op = 0;\n+\t    else\n+\t      index_op = 1;\n+\n+\t    locI = &XEXP (x, index_op);\n+\t    locB = &XEXP (x, !index_op);\n+\t    index_code = GET_CODE (*locI);\n+\t  }\n+\telse if (code0 == REG)\n+\t  {\n+\t    locI = &XEXP (x, 0);\n+\t    locB = &XEXP (x, 1);\n+\t    index_code = GET_CODE (*locI);\n+\t  }\n+\telse if (code1 == REG)\n+\t  {\n+\t    locI = &XEXP (x, 1);\n+\t    locB = &XEXP (x, 0);\n+\t    index_code = GET_CODE (*locI);\n+\t  }\n+\n+\tif (locI)\n+\t  changed |= replace_oldest_value_addr (locI, INDEX_REG_CLASS, mode,\n+\t\t\t\t\t\tinsn, vd);\n+\tif (locB)\n+\t  changed |= replace_oldest_value_addr (locB,\n+\t\t\t\t\t\tbase_reg_class (mode, PLUS,\n+\t\t\t\t\t\t\t\tindex_code),\n+\t\t\t\t\t\tmode, insn, vd);\n+\treturn changed;\n+      }\n+\n+    case POST_INC:\n+    case POST_DEC:\n+    case POST_MODIFY:\n+    case PRE_INC:\n+    case PRE_DEC:\n+    case PRE_MODIFY:\n+      return false;\n+\n+    case MEM:\n+      return replace_oldest_value_mem (x, insn, vd);\n+\n+    case REG:\n+      return replace_oldest_value_reg (loc, cl, insn, vd);\n+\n+    default:\n+      break;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\tchanged |= replace_oldest_value_addr (&XEXP (x, i), cl, mode,\n+\t\t\t\t\t      insn, vd);\n+      else if (fmt[i] == 'E')\n+\tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t  changed |= replace_oldest_value_addr (&XVECEXP (x, i, j), cl,\n+\t\t\t\t\t\tmode, insn, vd);\n+    }\n+\n+  return changed;\n+}\n+\n+/* Similar to replace_oldest_value_reg, but X contains a memory.  */\n+\n+static bool\n+replace_oldest_value_mem (rtx x, rtx insn, struct value_data *vd)\n+{\n+  return replace_oldest_value_addr (&XEXP (x, 0),\n+\t\t\t\t    base_reg_class (GET_MODE (x), MEM,\n+\t\t\t\t\t\t    SCRATCH),\n+\t\t\t\t    GET_MODE (x), insn, vd);\n+}\n+\n+/* Perform the forward copy propagation on basic block BB.  */\n+\n+static bool\n+copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n+{\n+  bool changed = false;\n+  rtx insn;\n+\n+  for (insn = BB_HEAD (bb); ; insn = NEXT_INSN (insn))\n+    {\n+      int n_ops, i, alt, predicated;\n+      bool is_asm, any_replacements;\n+      rtx set;\n+      bool replaced[MAX_RECOG_OPERANDS];\n+\n+      if (! INSN_P (insn))\n+\t{\n+\t  if (insn == BB_END (bb))\n+\t    break;\n+\t  else\n+\t    continue;\n+\t}\n+\n+      set = single_set (insn);\n+      extract_insn (insn);\n+      if (! constrain_operands (1))\n+\tfatal_insn_not_found (insn);\n+      preprocess_constraints ();\n+      alt = which_alternative;\n+      n_ops = recog_data.n_operands;\n+      is_asm = asm_noperands (PATTERN (insn)) >= 0;\n+\n+      /* Simplify the code below by rewriting things to reflect\n+\t matching constraints.  Also promote OP_OUT to OP_INOUT\n+\t in predicated instructions.  */\n+\n+      predicated = GET_CODE (PATTERN (insn)) == COND_EXEC;\n+      for (i = 0; i < n_ops; ++i)\n+\t{\n+\t  int matches = recog_op_alt[i][alt].matches;\n+\t  if (matches >= 0)\n+\t    recog_op_alt[i][alt].cl = recog_op_alt[matches][alt].cl;\n+\t  if (matches >= 0 || recog_op_alt[i][alt].matched >= 0\n+\t      || (predicated && recog_data.operand_type[i] == OP_OUT))\n+\t    recog_data.operand_type[i] = OP_INOUT;\n+\t}\n+\n+      /* For each earlyclobber operand, zap the value data.  */\n+      for (i = 0; i < n_ops; i++)\n+\tif (recog_op_alt[i][alt].earlyclobber)\n+\t  kill_value (recog_data.operand[i], vd);\n+\n+      /* Within asms, a clobber cannot overlap inputs or outputs.\n+\t I wouldn't think this were true for regular insns, but\n+\t scan_rtx treats them like that...  */\n+      note_stores (PATTERN (insn), kill_clobbered_value, vd);\n+\n+      /* Kill all auto-incremented values.  */\n+      /* ??? REG_INC is useless, since stack pushes aren't done that way.  */\n+      for_each_rtx (&PATTERN (insn), kill_autoinc_value, vd);\n+\n+      /* Kill all early-clobbered operands.  */\n+      for (i = 0; i < n_ops; i++)\n+\tif (recog_op_alt[i][alt].earlyclobber)\n+\t  kill_value (recog_data.operand[i], vd);\n+\n+      /* Special-case plain move instructions, since we may well\n+\t be able to do the move from a different register class.  */\n+      if (set && REG_P (SET_SRC (set)))\n+\t{\n+\t  rtx src = SET_SRC (set);\n+\t  unsigned int regno = REGNO (src);\n+\t  enum machine_mode mode = GET_MODE (src);\n+\t  unsigned int i;\n+\t  rtx new_rtx;\n+\n+\t  /* If we are accessing SRC in some mode other that what we\n+\t     set it in, make sure that the replacement is valid.  */\n+\t  if (mode != vd->e[regno].mode)\n+\t    {\n+\t      if (hard_regno_nregs[regno][mode]\n+\t\t  > hard_regno_nregs[regno][vd->e[regno].mode])\n+\t\tgoto no_move_special_case;\n+\t    }\n+\n+\t  /* If the destination is also a register, try to find a source\n+\t     register in the same class.  */\n+\t  if (REG_P (SET_DEST (set)))\n+\t    {\n+\t      new_rtx = find_oldest_value_reg (REGNO_REG_CLASS (regno), src, vd);\n+\t      if (new_rtx && validate_change (insn, &SET_SRC (set), new_rtx, 0))\n+\t\t{\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file,\n+\t\t\t     \"insn %u: replaced reg %u with %u\\n\",\n+\t\t\t     INSN_UID (insn), regno, REGNO (new_rtx));\n+\t\t  changed = true;\n+\t\t  goto did_replacement;\n+\t\t}\n+\t    }\n+\n+\t  /* Otherwise, try all valid registers and see if its valid.  */\n+\t  for (i = vd->e[regno].oldest_regno; i != regno;\n+\t       i = vd->e[i].next_regno)\n+\t    {\n+\t      new_rtx = maybe_mode_change (vd->e[i].mode, vd->e[regno].mode,\n+\t\t\t\t       mode, i, regno);\n+\t      if (new_rtx != NULL_RTX)\n+\t\t{\n+\t\t  if (validate_change (insn, &SET_SRC (set), new_rtx, 0))\n+\t\t    {\n+\t\t      ORIGINAL_REGNO (new_rtx) = ORIGINAL_REGNO (src);\n+\t\t      REG_ATTRS (new_rtx) = REG_ATTRS (src);\n+\t\t      REG_POINTER (new_rtx) = REG_POINTER (src);\n+\t\t      if (dump_file)\n+\t\t\tfprintf (dump_file,\n+\t\t\t\t \"insn %u: replaced reg %u with %u\\n\",\n+\t\t\t\t INSN_UID (insn), regno, REGNO (new_rtx));\n+\t\t      changed = true;\n+\t\t      goto did_replacement;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      no_move_special_case:\n+\n+      any_replacements = false;\n+\n+      /* For each input operand, replace a hard register with the\n+\t eldest live copy that's in an appropriate register class.  */\n+      for (i = 0; i < n_ops; i++)\n+\t{\n+\t  replaced[i] = false;\n+\n+\t  /* Don't scan match_operand here, since we've no reg class\n+\t     information to pass down.  Any operands that we could\n+\t     substitute in will be represented elsewhere.  */\n+\t  if (recog_data.constraints[i][0] == '\\0')\n+\t    continue;\n+\n+\t  /* Don't replace in asms intentionally referencing hard regs.  */\n+\t  if (is_asm && REG_P (recog_data.operand[i])\n+\t      && (REGNO (recog_data.operand[i])\n+\t\t  == ORIGINAL_REGNO (recog_data.operand[i])))\n+\t    continue;\n+\n+\t  if (recog_data.operand_type[i] == OP_IN)\n+\t    {\n+\t      if (recog_op_alt[i][alt].is_address)\n+\t\treplaced[i]\n+\t\t  = replace_oldest_value_addr (recog_data.operand_loc[i],\n+\t\t\t\t\t       recog_op_alt[i][alt].cl,\n+\t\t\t\t\t       VOIDmode, insn, vd);\n+\t      else if (REG_P (recog_data.operand[i]))\n+\t\treplaced[i]\n+\t\t  = replace_oldest_value_reg (recog_data.operand_loc[i],\n+\t\t\t\t\t      recog_op_alt[i][alt].cl,\n+\t\t\t\t\t      insn, vd);\n+\t      else if (MEM_P (recog_data.operand[i]))\n+\t\treplaced[i] = replace_oldest_value_mem (recog_data.operand[i],\n+\t\t\t\t\t\t\tinsn, vd);\n+\t    }\n+\t  else if (MEM_P (recog_data.operand[i]))\n+\t    replaced[i] = replace_oldest_value_mem (recog_data.operand[i],\n+\t\t\t\t\t\t    insn, vd);\n+\n+\t  /* If we performed any replacement, update match_dups.  */\n+\t  if (replaced[i])\n+\t    {\n+\t      int j;\n+\t      rtx new_rtx;\n+\n+\t      new_rtx = *recog_data.operand_loc[i];\n+\t      recog_data.operand[i] = new_rtx;\n+\t      for (j = 0; j < recog_data.n_dups; j++)\n+\t\tif (recog_data.dup_num[j] == i)\n+\t\t  validate_unshare_change (insn, recog_data.dup_loc[j], new_rtx, 1);\n+\n+\t      any_replacements = true;\n+\t    }\n+\t}\n+\n+      if (any_replacements)\n+\t{\n+\t  if (! apply_change_group ())\n+\t    {\n+\t      for (i = 0; i < n_ops; i++)\n+\t\tif (replaced[i])\n+\t\t  {\n+\t\t    rtx old = *recog_data.operand_loc[i];\n+\t\t    recog_data.operand[i] = old;\n+\t\t  }\n+\n+\t      if (dump_file)\n+\t\tfprintf (dump_file,\n+\t\t\t \"insn %u: reg replacements not verified\\n\",\n+\t\t\t INSN_UID (insn));\n+\t    }\n+\t  else\n+\t    changed = true;\n+\t}\n+\n+    did_replacement:\n+      /* Clobber call-clobbered registers.  */\n+      if (CALL_P (insn))\n+\tfor (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\t  if (TEST_HARD_REG_BIT (regs_invalidated_by_call, i))\n+\t    kill_value_regno (i, 1, vd);\n+\n+      /* Notice stores.  */\n+      note_stores (PATTERN (insn), kill_set_value, vd);\n+\n+      /* Notice copies.  */\n+      if (set && REG_P (SET_DEST (set)) && REG_P (SET_SRC (set)))\n+\tcopy_value (SET_DEST (set), SET_SRC (set), vd);\n+\n+      if (insn == BB_END (bb))\n+\tbreak;\n+    }\n+\n+  return changed;\n+}\n+\n+/* Main entry point for the forward copy propagation optimization.  */\n+\n+static unsigned int\n+copyprop_hardreg_forward (void)\n+{\n+  struct value_data *all_vd;\n+  basic_block bb;\n+  sbitmap visited;\n+\n+  all_vd = XNEWVEC (struct value_data, last_basic_block);\n+\n+  visited = sbitmap_alloc (last_basic_block);\n+  sbitmap_zero (visited);\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      SET_BIT (visited, bb->index);\n+\n+      /* If a block has a single predecessor, that we've already\n+\t processed, begin with the value data that was live at\n+\t the end of the predecessor block.  */\n+      /* ??? Ought to use more intelligent queuing of blocks.  */\n+      if (single_pred_p (bb) \n+\t  && TEST_BIT (visited, single_pred (bb)->index)\n+\t  && ! (single_pred_edge (bb)->flags & (EDGE_ABNORMAL_CALL | EDGE_EH)))\n+\tall_vd[bb->index] = all_vd[single_pred (bb)->index];\n+      else\n+\tinit_value_data (all_vd + bb->index);\n+\n+      copyprop_hardreg_forward_1 (bb, all_vd + bb->index);\n+    }\n+\n+  sbitmap_free (visited);  \n+  free (all_vd);\n+  return 0;\n+}\n+\n+/* Dump the value chain data to stderr.  */\n+\n+void\n+debug_value_data (struct value_data *vd)\n+{\n+  HARD_REG_SET set;\n+  unsigned int i, j;\n+\n+  CLEAR_HARD_REG_SET (set);\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; ++i)\n+    if (vd->e[i].oldest_regno == i)\n+      {\n+\tif (vd->e[i].mode == VOIDmode)\n+\t  {\n+\t    if (vd->e[i].next_regno != INVALID_REGNUM)\n+\t      fprintf (stderr, \"[%u] Bad next_regno for empty chain (%u)\\n\",\n+\t\t       i, vd->e[i].next_regno);\n+\t    continue;\n+\t  }\n+\n+\tSET_HARD_REG_BIT (set, i);\n+\tfprintf (stderr, \"[%u %s] \", i, GET_MODE_NAME (vd->e[i].mode));\n+\n+\tfor (j = vd->e[i].next_regno;\n+\t     j != INVALID_REGNUM;\n+\t     j = vd->e[j].next_regno)\n+\t  {\n+\t    if (TEST_HARD_REG_BIT (set, j))\n+\t      {\n+\t\tfprintf (stderr, \"[%u] Loop in regno chain\\n\", j);\n+\t\treturn;\n+\t      }\n+\n+\t    if (vd->e[j].oldest_regno != i)\n+\t      {\n+\t\tfprintf (stderr, \"[%u] Bad oldest_regno (%u)\\n\",\n+\t\t\t j, vd->e[j].oldest_regno);\n+\t\treturn;\n+\t      }\n+\t    SET_HARD_REG_BIT (set, j);\n+\t    fprintf (stderr, \"[%u %s] \", j, GET_MODE_NAME (vd->e[j].mode));\n+\t  }\n+\tfputc ('\\n', stderr);\n+      }\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; ++i)\n+    if (! TEST_HARD_REG_BIT (set, i)\n+\t&& (vd->e[i].mode != VOIDmode\n+\t    || vd->e[i].oldest_regno != i\n+\t    || vd->e[i].next_regno != INVALID_REGNUM))\n+      fprintf (stderr, \"[%u] Non-empty reg in chain (%s %u %i)\\n\",\n+\t       i, GET_MODE_NAME (vd->e[i].mode), vd->e[i].oldest_regno,\n+\t       vd->e[i].next_regno);\n+}\n+\n+#ifdef ENABLE_CHECKING\n+static void\n+validate_value_data (struct value_data *vd)\n+{\n+  HARD_REG_SET set;\n+  unsigned int i, j;\n+\n+  CLEAR_HARD_REG_SET (set);\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; ++i)\n+    if (vd->e[i].oldest_regno == i)\n+      {\n+\tif (vd->e[i].mode == VOIDmode)\n+\t  {\n+\t    if (vd->e[i].next_regno != INVALID_REGNUM)\n+\t      internal_error (\"validate_value_data: [%u] Bad next_regno for empty chain (%u)\",\n+\t\t\t      i, vd->e[i].next_regno);\n+\t    continue;\n+\t  }\n+\n+\tSET_HARD_REG_BIT (set, i);\n+\n+\tfor (j = vd->e[i].next_regno;\n+\t     j != INVALID_REGNUM;\n+\t     j = vd->e[j].next_regno)\n+\t  {\n+\t    if (TEST_HARD_REG_BIT (set, j))\n+\t      internal_error (\"validate_value_data: Loop in regno chain (%u)\",\n+\t\t\t      j);\n+\t    if (vd->e[j].oldest_regno != i)\n+\t      internal_error (\"validate_value_data: [%u] Bad oldest_regno (%u)\",\n+\t\t\t      j, vd->e[j].oldest_regno);\n+\n+\t    SET_HARD_REG_BIT (set, j);\n+\t  }\n+      }\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; ++i)\n+    if (! TEST_HARD_REG_BIT (set, i)\n+\t&& (vd->e[i].mode != VOIDmode\n+\t    || vd->e[i].oldest_regno != i\n+\t    || vd->e[i].next_regno != INVALID_REGNUM))\n+      internal_error (\"validate_value_data: [%u] Non-empty reg in chain (%s %u %i)\",\n+\t\t      i, GET_MODE_NAME (vd->e[i].mode), vd->e[i].oldest_regno,\n+\t\t      vd->e[i].next_regno);\n+}\n+#endif\n+\f\n+static bool\n+gate_handle_cprop (void)\n+{\n+  return (optimize > 0 && (flag_cprop_registers));\n+}\n+\n+\n+struct rtl_opt_pass pass_cprop_hardreg =\n+{\n+ {\n+  RTL_PASS,\n+  \"cprop_hardreg\",                      /* name */\n+  gate_handle_cprop,                    /* gate */\n+  copyprop_hardreg_forward,             /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_CPROP_REGISTERS,                   /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_dump_func | TODO_verify_rtl_sharing /* todo_flags_finish */\n+ }\n+};"}, {"sha": "fcdaaf79e81d5a7317c6be3624c5f423191cd019", "filename": "gcc/regrename.c", "status": "modified", "additions": 4, "deletions": 980, "changes": 984, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fac412383e1434379bc3dff94de18fd71e9276b3/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fac412383e1434379bc3dff94de18fd71e9276b3/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=fac412383e1434379bc3dff94de18fd71e9276b3", "patch": "@@ -180,7 +180,7 @@ merge_overlapping_regs (basic_block b, HARD_REG_SET *pset,\n \n /* Perform register renaming on the current function.  */\n \n-static void\n+static unsigned int\n regrename_optimize (void)\n {\n   int tick[FIRST_PSEUDO_REGISTER];\n@@ -355,6 +355,8 @@ regrename_optimize (void)\n \n   if (dump_file)\n     fputc ('\\n', dump_file);\n+\n+  return 0;\n }\n \n static void\n@@ -999,966 +1001,21 @@ dump_def_use_chain (struct du_chain *chains)\n       chains = chains->next_chain;\n     }\n }\n-\f\n-/* The following code does forward propagation of hard register copies.\n-   The object is to eliminate as many dependencies as possible, so that\n-   we have the most scheduling freedom.  As a side effect, we also clean\n-   up some silly register allocation decisions made by reload.  This\n-   code may be obsoleted by a new register allocator.  */\n-\n-/* For each register, we have a list of registers that contain the same\n-   value.  The OLDEST_REGNO field points to the head of the list, and\n-   the NEXT_REGNO field runs through the list.  The MODE field indicates\n-   what mode the data is known to be in; this field is VOIDmode when the\n-   register is not known to contain valid data.  */\n-\n-struct value_data_entry\n-{\n-  enum machine_mode mode;\n-  unsigned int oldest_regno;\n-  unsigned int next_regno;\n-};\n-\n-struct value_data\n-{\n-  struct value_data_entry e[FIRST_PSEUDO_REGISTER];\n-  unsigned int max_value_regs;\n-};\n-\n-static void kill_value_one_regno (unsigned, struct value_data *);\n-static void kill_value_regno (unsigned, unsigned, struct value_data *);\n-static void kill_value (rtx, struct value_data *);\n-static void set_value_regno (unsigned, enum machine_mode, struct value_data *);\n-static void init_value_data (struct value_data *);\n-static void kill_clobbered_value (rtx, const_rtx, void *);\n-static void kill_set_value (rtx, const_rtx, void *);\n-static int kill_autoinc_value (rtx *, void *);\n-static void copy_value (rtx, rtx, struct value_data *);\n-static bool mode_change_ok (enum machine_mode, enum machine_mode,\n-\t\t\t    unsigned int);\n-static rtx maybe_mode_change (enum machine_mode, enum machine_mode,\n-\t\t\t      enum machine_mode, unsigned int, unsigned int);\n-static rtx find_oldest_value_reg (enum reg_class, rtx, struct value_data *);\n-static bool replace_oldest_value_reg (rtx *, enum reg_class, rtx,\n-\t\t\t\t      struct value_data *);\n-static bool replace_oldest_value_addr (rtx *, enum reg_class,\n-\t\t\t\t       enum machine_mode, rtx,\n-\t\t\t\t       struct value_data *);\n-static bool replace_oldest_value_mem (rtx, rtx, struct value_data *);\n-static bool copyprop_hardreg_forward_1 (basic_block, struct value_data *);\n-extern void debug_value_data (struct value_data *);\n-#ifdef ENABLE_CHECKING\n-static void validate_value_data (struct value_data *);\n-#endif\n-\n-/* Kill register REGNO.  This involves removing it from any value\n-   lists, and resetting the value mode to VOIDmode.  This is only a\n-   helper function; it does not handle any hard registers overlapping\n-   with REGNO.  */\n-\n-static void\n-kill_value_one_regno (unsigned int regno, struct value_data *vd)\n-{\n-  unsigned int i, next;\n-\n-  if (vd->e[regno].oldest_regno != regno)\n-    {\n-      for (i = vd->e[regno].oldest_regno;\n-\t   vd->e[i].next_regno != regno;\n-\t   i = vd->e[i].next_regno)\n-\tcontinue;\n-      vd->e[i].next_regno = vd->e[regno].next_regno;\n-    }\n-  else if ((next = vd->e[regno].next_regno) != INVALID_REGNUM)\n-    {\n-      for (i = next; i != INVALID_REGNUM; i = vd->e[i].next_regno)\n-\tvd->e[i].oldest_regno = next;\n-    }\n-\n-  vd->e[regno].mode = VOIDmode;\n-  vd->e[regno].oldest_regno = regno;\n-  vd->e[regno].next_regno = INVALID_REGNUM;\n-\n-#ifdef ENABLE_CHECKING\n-  validate_value_data (vd);\n-#endif\n-}\n-\n-/* Kill the value in register REGNO for NREGS, and any other registers\n-   whose values overlap.  */\n-\n-static void\n-kill_value_regno (unsigned int regno, unsigned int nregs,\n-\t\t  struct value_data *vd)\n-{\n-  unsigned int j;\n-\n-  /* Kill the value we're told to kill.  */\n-  for (j = 0; j < nregs; ++j)\n-    kill_value_one_regno (regno + j, vd);\n-\n-  /* Kill everything that overlapped what we're told to kill.  */\n-  if (regno < vd->max_value_regs)\n-    j = 0;\n-  else\n-    j = regno - vd->max_value_regs;\n-  for (; j < regno; ++j)\n-    {\n-      unsigned int i, n;\n-      if (vd->e[j].mode == VOIDmode)\n-\tcontinue;\n-      n = hard_regno_nregs[j][vd->e[j].mode];\n-      if (j + n > regno)\n-\tfor (i = 0; i < n; ++i)\n-\t  kill_value_one_regno (j + i, vd);\n-    }\n-}\n-\n-/* Kill X.  This is a convenience function wrapping kill_value_regno\n-   so that we mind the mode the register is in.  */\n-\n-static void\n-kill_value (rtx x, struct value_data *vd)\n-{\n-  rtx orig_rtx = x;\n-\n-  if (GET_CODE (x) == SUBREG)\n-    {\n-      x = simplify_subreg (GET_MODE (x), SUBREG_REG (x),\n-\t\t\t   GET_MODE (SUBREG_REG (x)), SUBREG_BYTE (x));\n-      if (x == NULL_RTX)\n-\tx = SUBREG_REG (orig_rtx);\n-    }\n-  if (REG_P (x))\n-    {\n-      unsigned int regno = REGNO (x);\n-      unsigned int n = hard_regno_nregs[regno][GET_MODE (x)];\n \n-      kill_value_regno (regno, n, vd);\n-    }\n-}\n-\n-/* Remember that REGNO is valid in MODE.  */\n-\n-static void\n-set_value_regno (unsigned int regno, enum machine_mode mode,\n-\t\t struct value_data *vd)\n-{\n-  unsigned int nregs;\n-\n-  vd->e[regno].mode = mode;\n-\n-  nregs = hard_regno_nregs[regno][mode];\n-  if (nregs > vd->max_value_regs)\n-    vd->max_value_regs = nregs;\n-}\n-\n-/* Initialize VD such that there are no known relationships between regs.  */\n-\n-static void\n-init_value_data (struct value_data *vd)\n-{\n-  int i;\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; ++i)\n-    {\n-      vd->e[i].mode = VOIDmode;\n-      vd->e[i].oldest_regno = i;\n-      vd->e[i].next_regno = INVALID_REGNUM;\n-    }\n-  vd->max_value_regs = 0;\n-}\n-\n-/* Called through note_stores.  If X is clobbered, kill its value.  */\n-\n-static void\n-kill_clobbered_value (rtx x, const_rtx set, void *data)\n-{\n-  struct value_data *const vd = (struct value_data *) data;\n-  if (GET_CODE (set) == CLOBBER)\n-    kill_value (x, vd);\n-}\n-\n-/* Called through note_stores.  If X is set, not clobbered, kill its\n-   current value and install it as the root of its own value list.  */\n-\n-static void\n-kill_set_value (rtx x, const_rtx set, void *data)\n-{\n-  struct value_data *const vd = (struct value_data *) data;\n-  if (GET_CODE (set) != CLOBBER)\n-    {\n-      kill_value (x, vd);\n-      if (REG_P (x))\n-\tset_value_regno (REGNO (x), GET_MODE (x), vd);\n-    }\n-}\n-\n-/* Called through for_each_rtx.  Kill any register used as the base of an\n-   auto-increment expression, and install that register as the root of its\n-   own value list.  */\n-\n-static int\n-kill_autoinc_value (rtx *px, void *data)\n-{\n-  rtx x = *px;\n-  struct value_data *const vd = (struct value_data *) data;\n-\n-  if (GET_RTX_CLASS (GET_CODE (x)) == RTX_AUTOINC)\n-    {\n-      x = XEXP (x, 0);\n-      kill_value (x, vd);\n-      set_value_regno (REGNO (x), Pmode, vd);\n-      return -1;\n-    }\n-\n-  return 0;\n-}\n-\n-/* Assert that SRC has been copied to DEST.  Adjust the data structures\n-   to reflect that SRC contains an older copy of the shared value.  */\n-\n-static void\n-copy_value (rtx dest, rtx src, struct value_data *vd)\n-{\n-  unsigned int dr = REGNO (dest);\n-  unsigned int sr = REGNO (src);\n-  unsigned int dn, sn;\n-  unsigned int i;\n-\n-  /* ??? At present, it's possible to see noop sets.  It'd be nice if\n-     this were cleaned up beforehand...  */\n-  if (sr == dr)\n-    return;\n-\n-  /* Do not propagate copies to the stack pointer, as that can leave\n-     memory accesses with no scheduling dependency on the stack update.  */\n-  if (dr == STACK_POINTER_REGNUM)\n-    return;\n-\n-  /* Likewise with the frame pointer, if we're using one.  */\n-  if (frame_pointer_needed && dr == HARD_FRAME_POINTER_REGNUM)\n-    return;\n-\n-  /* Do not propagate copies to fixed or global registers, patterns\n-     can be relying to see particular fixed register or users can\n-     expect the chosen global register in asm.  */\n-  if (fixed_regs[dr] || global_regs[dr])\n-    return;\n-\n-  /* If SRC and DEST overlap, don't record anything.  */\n-  dn = hard_regno_nregs[dr][GET_MODE (dest)];\n-  sn = hard_regno_nregs[sr][GET_MODE (dest)];\n-  if ((dr > sr && dr < sr + sn)\n-      || (sr > dr && sr < dr + dn))\n-    return;\n-\n-  /* If SRC had no assigned mode (i.e. we didn't know it was live)\n-     assign it now and assume the value came from an input argument\n-     or somesuch.  */\n-  if (vd->e[sr].mode == VOIDmode)\n-    set_value_regno (sr, vd->e[dr].mode, vd);\n-\n-  /* If we are narrowing the input to a smaller number of hard regs,\n-     and it is in big endian, we are really extracting a high part.\n-     Since we generally associate a low part of a value with the value itself,\n-     we must not do the same for the high part.\n-     Note we can still get low parts for the same mode combination through\n-     a two-step copy involving differently sized hard regs.\n-     Assume hard regs fr* are 32 bits bits each, while r* are 64 bits each:\n-     (set (reg:DI r0) (reg:DI fr0))\n-     (set (reg:SI fr2) (reg:SI r0))\n-     loads the low part of (reg:DI fr0) - i.e. fr1 - into fr2, while:\n-     (set (reg:SI fr2) (reg:SI fr0))\n-     loads the high part of (reg:DI fr0) into fr2.\n-\n-     We can't properly represent the latter case in our tables, so don't\n-     record anything then.  */\n-  else if (sn < (unsigned int) hard_regno_nregs[sr][vd->e[sr].mode]\n-\t   && (GET_MODE_SIZE (vd->e[sr].mode) > UNITS_PER_WORD\n-\t       ? WORDS_BIG_ENDIAN : BYTES_BIG_ENDIAN))\n-    return;\n-\n-  /* If SRC had been assigned a mode narrower than the copy, we can't\n-     link DEST into the chain, because not all of the pieces of the\n-     copy came from oldest_regno.  */\n-  else if (sn > (unsigned int) hard_regno_nregs[sr][vd->e[sr].mode])\n-    return;\n-\n-  /* Link DR at the end of the value chain used by SR.  */\n-\n-  vd->e[dr].oldest_regno = vd->e[sr].oldest_regno;\n-\n-  for (i = sr; vd->e[i].next_regno != INVALID_REGNUM; i = vd->e[i].next_regno)\n-    continue;\n-  vd->e[i].next_regno = dr;\n-\n-#ifdef ENABLE_CHECKING\n-  validate_value_data (vd);\n-#endif\n-}\n-\n-/* Return true if a mode change from ORIG to NEW is allowed for REGNO.  */\n-\n-static bool\n-mode_change_ok (enum machine_mode orig_mode, enum machine_mode new_mode,\n-\t\tunsigned int regno ATTRIBUTE_UNUSED)\n-{\n-  if (GET_MODE_SIZE (orig_mode) < GET_MODE_SIZE (new_mode))\n-    return false;\n-\n-#ifdef CANNOT_CHANGE_MODE_CLASS\n-  return !REG_CANNOT_CHANGE_MODE_P (regno, orig_mode, new_mode);\n-#endif\n-\n-  return true;\n-}\n-\n-/* Register REGNO was originally set in ORIG_MODE.  It - or a copy of it -\n-   was copied in COPY_MODE to COPY_REGNO, and then COPY_REGNO was accessed\n-   in NEW_MODE.\n-   Return a NEW_MODE rtx for REGNO if that's OK, otherwise return NULL_RTX.  */\n-\n-static rtx\n-maybe_mode_change (enum machine_mode orig_mode, enum machine_mode copy_mode,\n-\t\t   enum machine_mode new_mode, unsigned int regno,\n-\t\t   unsigned int copy_regno ATTRIBUTE_UNUSED)\n-{\n-  if (GET_MODE_SIZE (copy_mode) < GET_MODE_SIZE (orig_mode)\n-      && GET_MODE_SIZE (copy_mode) < GET_MODE_SIZE (new_mode))\n-    return NULL_RTX;\n-\n-  if (orig_mode == new_mode)\n-    return gen_rtx_raw_REG (new_mode, regno);\n-  else if (mode_change_ok (orig_mode, new_mode, regno))\n-    {\n-      int copy_nregs = hard_regno_nregs[copy_regno][copy_mode];\n-      int use_nregs = hard_regno_nregs[copy_regno][new_mode];\n-      int copy_offset\n-\t= GET_MODE_SIZE (copy_mode) / copy_nregs * (copy_nregs - use_nregs);\n-      int offset\n-\t= GET_MODE_SIZE (orig_mode) - GET_MODE_SIZE (new_mode) - copy_offset;\n-      int byteoffset = offset % UNITS_PER_WORD;\n-      int wordoffset = offset - byteoffset;\n-\n-      offset = ((WORDS_BIG_ENDIAN ? wordoffset : 0)\n-\t\t+ (BYTES_BIG_ENDIAN ? byteoffset : 0));\n-      return gen_rtx_raw_REG (new_mode,\n-\t\t\t      regno + subreg_regno_offset (regno, orig_mode,\n-\t\t\t\t\t\t\t   offset,\n-\t\t\t\t\t\t\t   new_mode));\n-    }\n-  return NULL_RTX;\n-}\n-\n-/* Find the oldest copy of the value contained in REGNO that is in\n-   register class CL and has mode MODE.  If found, return an rtx\n-   of that oldest register, otherwise return NULL.  */\n-\n-static rtx\n-find_oldest_value_reg (enum reg_class cl, rtx reg, struct value_data *vd)\n-{\n-  unsigned int regno = REGNO (reg);\n-  enum machine_mode mode = GET_MODE (reg);\n-  unsigned int i;\n-\n-  /* If we are accessing REG in some mode other that what we set it in,\n-     make sure that the replacement is valid.  In particular, consider\n-\t(set (reg:DI r11) (...))\n-\t(set (reg:SI r9) (reg:SI r11))\n-\t(set (reg:SI r10) (...))\n-\t(set (...) (reg:DI r9))\n-     Replacing r9 with r11 is invalid.  */\n-  if (mode != vd->e[regno].mode)\n-    {\n-      if (hard_regno_nregs[regno][mode]\n-\t  > hard_regno_nregs[regno][vd->e[regno].mode])\n-\treturn NULL_RTX;\n-    }\n-\n-  for (i = vd->e[regno].oldest_regno; i != regno; i = vd->e[i].next_regno)\n-    {\n-      enum machine_mode oldmode = vd->e[i].mode;\n-      rtx new_rtx;\n-\n-      if (!in_hard_reg_set_p (reg_class_contents[cl], mode, i))\n-\treturn NULL_RTX;\n-\n-      new_rtx = maybe_mode_change (oldmode, vd->e[regno].mode, mode, i, regno);\n-      if (new_rtx)\n-\t{\n-\t  ORIGINAL_REGNO (new_rtx) = ORIGINAL_REGNO (reg);\n-\t  REG_ATTRS (new_rtx) = REG_ATTRS (reg);\n-\t  REG_POINTER (new_rtx) = REG_POINTER (reg);\n-\t  return new_rtx;\n-\t}\n-    }\n-\n-  return NULL_RTX;\n-}\n-\n-/* If possible, replace the register at *LOC with the oldest register\n-   in register class CL.  Return true if successfully replaced.  */\n-\n-static bool\n-replace_oldest_value_reg (rtx *loc, enum reg_class cl, rtx insn,\n-\t\t\t  struct value_data *vd)\n-{\n-  rtx new_rtx = find_oldest_value_reg (cl, *loc, vd);\n-  if (new_rtx)\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \"insn %u: replaced reg %u with %u\\n\",\n-\t\t INSN_UID (insn), REGNO (*loc), REGNO (new_rtx));\n-\n-      validate_change (insn, loc, new_rtx, 1);\n-      return true;\n-    }\n-  return false;\n-}\n-\n-/* Similar to replace_oldest_value_reg, but *LOC contains an address.\n-   Adapted from find_reloads_address_1.  CL is INDEX_REG_CLASS or\n-   BASE_REG_CLASS depending on how the register is being considered.  */\n-\n-static bool\n-replace_oldest_value_addr (rtx *loc, enum reg_class cl,\n-\t\t\t   enum machine_mode mode, rtx insn,\n-\t\t\t   struct value_data *vd)\n-{\n-  rtx x = *loc;\n-  RTX_CODE code = GET_CODE (x);\n-  const char *fmt;\n-  int i, j;\n-  bool changed = false;\n-\n-  switch (code)\n-    {\n-    case PLUS:\n-      {\n-\trtx orig_op0 = XEXP (x, 0);\n-\trtx orig_op1 = XEXP (x, 1);\n-\tRTX_CODE code0 = GET_CODE (orig_op0);\n-\tRTX_CODE code1 = GET_CODE (orig_op1);\n-\trtx op0 = orig_op0;\n-\trtx op1 = orig_op1;\n-\trtx *locI = NULL;\n-\trtx *locB = NULL;\n-\tenum rtx_code index_code = SCRATCH;\n-\n-\tif (GET_CODE (op0) == SUBREG)\n-\t  {\n-\t    op0 = SUBREG_REG (op0);\n-\t    code0 = GET_CODE (op0);\n-\t  }\n-\n-\tif (GET_CODE (op1) == SUBREG)\n-\t  {\n-\t    op1 = SUBREG_REG (op1);\n-\t    code1 = GET_CODE (op1);\n-\t  }\n-\n-\tif (code0 == MULT || code0 == SIGN_EXTEND || code0 == TRUNCATE\n-\t    || code0 == ZERO_EXTEND || code1 == MEM)\n-\t  {\n-\t    locI = &XEXP (x, 0);\n-\t    locB = &XEXP (x, 1);\n-\t    index_code = GET_CODE (*locI);\n-\t  }\n-\telse if (code1 == MULT || code1 == SIGN_EXTEND || code1 == TRUNCATE\n-\t\t || code1 == ZERO_EXTEND || code0 == MEM)\n-\t  {\n-\t    locI = &XEXP (x, 1);\n-\t    locB = &XEXP (x, 0);\n-\t    index_code = GET_CODE (*locI);\n-\t  }\n-\telse if (code0 == CONST_INT || code0 == CONST\n-\t\t || code0 == SYMBOL_REF || code0 == LABEL_REF)\n-\t  {\n-\t    locB = &XEXP (x, 1);\n-\t    index_code = GET_CODE (XEXP (x, 0));\n-\t  }\n-\telse if (code1 == CONST_INT || code1 == CONST\n-\t\t || code1 == SYMBOL_REF || code1 == LABEL_REF)\n-\t  {\n-\t    locB = &XEXP (x, 0);\n-\t    index_code = GET_CODE (XEXP (x, 1));\n-\t  }\n-\telse if (code0 == REG && code1 == REG)\n-\t  {\n-\t    int index_op;\n-\t    unsigned regno0 = REGNO (op0), regno1 = REGNO (op1);\n-\n-\t    if (REGNO_OK_FOR_INDEX_P (regno1)\n-\t\t&& regno_ok_for_base_p (regno0, mode, PLUS, REG))\n-\t      index_op = 1;\n-\t    else if (REGNO_OK_FOR_INDEX_P (regno0)\n-\t\t     && regno_ok_for_base_p (regno1, mode, PLUS, REG))\n-\t      index_op = 0;\n-\t    else if (regno_ok_for_base_p (regno0, mode, PLUS, REG)\n-\t\t     || REGNO_OK_FOR_INDEX_P (regno1))\n-\t      index_op = 1;\n-\t    else if (regno_ok_for_base_p (regno1, mode, PLUS, REG))\n-\t      index_op = 0;\n-\t    else\n-\t      index_op = 1;\n-\n-\t    locI = &XEXP (x, index_op);\n-\t    locB = &XEXP (x, !index_op);\n-\t    index_code = GET_CODE (*locI);\n-\t  }\n-\telse if (code0 == REG)\n-\t  {\n-\t    locI = &XEXP (x, 0);\n-\t    locB = &XEXP (x, 1);\n-\t    index_code = GET_CODE (*locI);\n-\t  }\n-\telse if (code1 == REG)\n-\t  {\n-\t    locI = &XEXP (x, 1);\n-\t    locB = &XEXP (x, 0);\n-\t    index_code = GET_CODE (*locI);\n-\t  }\n-\n-\tif (locI)\n-\t  changed |= replace_oldest_value_addr (locI, INDEX_REG_CLASS, mode,\n-\t\t\t\t\t\tinsn, vd);\n-\tif (locB)\n-\t  changed |= replace_oldest_value_addr (locB,\n-\t\t\t\t\t\tbase_reg_class (mode, PLUS,\n-\t\t\t\t\t\t\t\tindex_code),\n-\t\t\t\t\t\tmode, insn, vd);\n-\treturn changed;\n-      }\n-\n-    case POST_INC:\n-    case POST_DEC:\n-    case POST_MODIFY:\n-    case PRE_INC:\n-    case PRE_DEC:\n-    case PRE_MODIFY:\n-      return false;\n-\n-    case MEM:\n-      return replace_oldest_value_mem (x, insn, vd);\n-\n-    case REG:\n-      return replace_oldest_value_reg (loc, cl, insn, vd);\n-\n-    default:\n-      break;\n-    }\n-\n-  fmt = GET_RTX_FORMAT (code);\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    {\n-      if (fmt[i] == 'e')\n-\tchanged |= replace_oldest_value_addr (&XEXP (x, i), cl, mode,\n-\t\t\t\t\t      insn, vd);\n-      else if (fmt[i] == 'E')\n-\tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t  changed |= replace_oldest_value_addr (&XVECEXP (x, i, j), cl,\n-\t\t\t\t\t\tmode, insn, vd);\n-    }\n-\n-  return changed;\n-}\n-\n-/* Similar to replace_oldest_value_reg, but X contains a memory.  */\n-\n-static bool\n-replace_oldest_value_mem (rtx x, rtx insn, struct value_data *vd)\n-{\n-  return replace_oldest_value_addr (&XEXP (x, 0),\n-\t\t\t\t    base_reg_class (GET_MODE (x), MEM,\n-\t\t\t\t\t\t    SCRATCH),\n-\t\t\t\t    GET_MODE (x), insn, vd);\n-}\n-\n-/* Perform the forward copy propagation on basic block BB.  */\n-\n-static bool\n-copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n-{\n-  bool changed = false;\n-  rtx insn;\n-\n-  for (insn = BB_HEAD (bb); ; insn = NEXT_INSN (insn))\n-    {\n-      int n_ops, i, alt, predicated;\n-      bool is_asm, any_replacements;\n-      rtx set;\n-      bool replaced[MAX_RECOG_OPERANDS];\n-\n-      if (! INSN_P (insn))\n-\t{\n-\t  if (insn == BB_END (bb))\n-\t    break;\n-\t  else\n-\t    continue;\n-\t}\n-\n-      set = single_set (insn);\n-      extract_insn (insn);\n-      if (! constrain_operands (1))\n-\tfatal_insn_not_found (insn);\n-      preprocess_constraints ();\n-      alt = which_alternative;\n-      n_ops = recog_data.n_operands;\n-      is_asm = asm_noperands (PATTERN (insn)) >= 0;\n-\n-      /* Simplify the code below by rewriting things to reflect\n-\t matching constraints.  Also promote OP_OUT to OP_INOUT\n-\t in predicated instructions.  */\n-\n-      predicated = GET_CODE (PATTERN (insn)) == COND_EXEC;\n-      for (i = 0; i < n_ops; ++i)\n-\t{\n-\t  int matches = recog_op_alt[i][alt].matches;\n-\t  if (matches >= 0)\n-\t    recog_op_alt[i][alt].cl = recog_op_alt[matches][alt].cl;\n-\t  if (matches >= 0 || recog_op_alt[i][alt].matched >= 0\n-\t      || (predicated && recog_data.operand_type[i] == OP_OUT))\n-\t    recog_data.operand_type[i] = OP_INOUT;\n-\t}\n-\n-      /* For each earlyclobber operand, zap the value data.  */\n-      for (i = 0; i < n_ops; i++)\n-\tif (recog_op_alt[i][alt].earlyclobber)\n-\t  kill_value (recog_data.operand[i], vd);\n-\n-      /* Within asms, a clobber cannot overlap inputs or outputs.\n-\t I wouldn't think this were true for regular insns, but\n-\t scan_rtx treats them like that...  */\n-      note_stores (PATTERN (insn), kill_clobbered_value, vd);\n-\n-      /* Kill all auto-incremented values.  */\n-      /* ??? REG_INC is useless, since stack pushes aren't done that way.  */\n-      for_each_rtx (&PATTERN (insn), kill_autoinc_value, vd);\n-\n-      /* Kill all early-clobbered operands.  */\n-      for (i = 0; i < n_ops; i++)\n-\tif (recog_op_alt[i][alt].earlyclobber)\n-\t  kill_value (recog_data.operand[i], vd);\n-\n-      /* Special-case plain move instructions, since we may well\n-\t be able to do the move from a different register class.  */\n-      if (set && REG_P (SET_SRC (set)))\n-\t{\n-\t  rtx src = SET_SRC (set);\n-\t  unsigned int regno = REGNO (src);\n-\t  enum machine_mode mode = GET_MODE (src);\n-\t  unsigned int i;\n-\t  rtx new_rtx;\n-\n-\t  /* If we are accessing SRC in some mode other that what we\n-\t     set it in, make sure that the replacement is valid.  */\n-\t  if (mode != vd->e[regno].mode)\n-\t    {\n-\t      if (hard_regno_nregs[regno][mode]\n-\t\t  > hard_regno_nregs[regno][vd->e[regno].mode])\n-\t\tgoto no_move_special_case;\n-\t    }\n-\n-\t  /* If the destination is also a register, try to find a source\n-\t     register in the same class.  */\n-\t  if (REG_P (SET_DEST (set)))\n-\t    {\n-\t      new_rtx = find_oldest_value_reg (REGNO_REG_CLASS (regno), src, vd);\n-\t      if (new_rtx && validate_change (insn, &SET_SRC (set), new_rtx, 0))\n-\t\t{\n-\t\t  if (dump_file)\n-\t\t    fprintf (dump_file,\n-\t\t\t     \"insn %u: replaced reg %u with %u\\n\",\n-\t\t\t     INSN_UID (insn), regno, REGNO (new_rtx));\n-\t\t  changed = true;\n-\t\t  goto did_replacement;\n-\t\t}\n-\t    }\n-\n-\t  /* Otherwise, try all valid registers and see if its valid.  */\n-\t  for (i = vd->e[regno].oldest_regno; i != regno;\n-\t       i = vd->e[i].next_regno)\n-\t    {\n-\t      new_rtx = maybe_mode_change (vd->e[i].mode, vd->e[regno].mode,\n-\t\t\t\t       mode, i, regno);\n-\t      if (new_rtx != NULL_RTX)\n-\t\t{\n-\t\t  if (validate_change (insn, &SET_SRC (set), new_rtx, 0))\n-\t\t    {\n-\t\t      ORIGINAL_REGNO (new_rtx) = ORIGINAL_REGNO (src);\n-\t\t      REG_ATTRS (new_rtx) = REG_ATTRS (src);\n-\t\t      REG_POINTER (new_rtx) = REG_POINTER (src);\n-\t\t      if (dump_file)\n-\t\t\tfprintf (dump_file,\n-\t\t\t\t \"insn %u: replaced reg %u with %u\\n\",\n-\t\t\t\t INSN_UID (insn), regno, REGNO (new_rtx));\n-\t\t      changed = true;\n-\t\t      goto did_replacement;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n-      no_move_special_case:\n-\n-      any_replacements = false;\n-\n-      /* For each input operand, replace a hard register with the\n-\t eldest live copy that's in an appropriate register class.  */\n-      for (i = 0; i < n_ops; i++)\n-\t{\n-\t  replaced[i] = false;\n-\n-\t  /* Don't scan match_operand here, since we've no reg class\n-\t     information to pass down.  Any operands that we could\n-\t     substitute in will be represented elsewhere.  */\n-\t  if (recog_data.constraints[i][0] == '\\0')\n-\t    continue;\n-\n-\t  /* Don't replace in asms intentionally referencing hard regs.  */\n-\t  if (is_asm && REG_P (recog_data.operand[i])\n-\t      && (REGNO (recog_data.operand[i])\n-\t\t  == ORIGINAL_REGNO (recog_data.operand[i])))\n-\t    continue;\n-\n-\t  if (recog_data.operand_type[i] == OP_IN)\n-\t    {\n-\t      if (recog_op_alt[i][alt].is_address)\n-\t\treplaced[i]\n-\t\t  = replace_oldest_value_addr (recog_data.operand_loc[i],\n-\t\t\t\t\t       recog_op_alt[i][alt].cl,\n-\t\t\t\t\t       VOIDmode, insn, vd);\n-\t      else if (REG_P (recog_data.operand[i]))\n-\t\treplaced[i]\n-\t\t  = replace_oldest_value_reg (recog_data.operand_loc[i],\n-\t\t\t\t\t      recog_op_alt[i][alt].cl,\n-\t\t\t\t\t      insn, vd);\n-\t      else if (MEM_P (recog_data.operand[i]))\n-\t\treplaced[i] = replace_oldest_value_mem (recog_data.operand[i],\n-\t\t\t\t\t\t\tinsn, vd);\n-\t    }\n-\t  else if (MEM_P (recog_data.operand[i]))\n-\t    replaced[i] = replace_oldest_value_mem (recog_data.operand[i],\n-\t\t\t\t\t\t    insn, vd);\n-\n-\t  /* If we performed any replacement, update match_dups.  */\n-\t  if (replaced[i])\n-\t    {\n-\t      int j;\n-\t      rtx new_rtx;\n-\n-\t      new_rtx = *recog_data.operand_loc[i];\n-\t      recog_data.operand[i] = new_rtx;\n-\t      for (j = 0; j < recog_data.n_dups; j++)\n-\t\tif (recog_data.dup_num[j] == i)\n-\t\t  validate_unshare_change (insn, recog_data.dup_loc[j], new_rtx, 1);\n-\n-\t      any_replacements = true;\n-\t    }\n-\t}\n-\n-      if (any_replacements)\n-\t{\n-\t  if (! apply_change_group ())\n-\t    {\n-\t      for (i = 0; i < n_ops; i++)\n-\t\tif (replaced[i])\n-\t\t  {\n-\t\t    rtx old = *recog_data.operand_loc[i];\n-\t\t    recog_data.operand[i] = old;\n-\t\t  }\n-\n-\t      if (dump_file)\n-\t\tfprintf (dump_file,\n-\t\t\t \"insn %u: reg replacements not verified\\n\",\n-\t\t\t INSN_UID (insn));\n-\t    }\n-\t  else\n-\t    changed = true;\n-\t}\n-\n-    did_replacement:\n-      /* Clobber call-clobbered registers.  */\n-      if (CALL_P (insn))\n-\tfor (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t  if (TEST_HARD_REG_BIT (regs_invalidated_by_call, i))\n-\t    kill_value_regno (i, 1, vd);\n-\n-      /* Notice stores.  */\n-      note_stores (PATTERN (insn), kill_set_value, vd);\n-\n-      /* Notice copies.  */\n-      if (set && REG_P (SET_DEST (set)) && REG_P (SET_SRC (set)))\n-\tcopy_value (SET_DEST (set), SET_SRC (set), vd);\n-\n-      if (insn == BB_END (bb))\n-\tbreak;\n-    }\n-\n-  return changed;\n-}\n-\n-/* Main entry point for the forward copy propagation optimization.  */\n-\n-static void\n-copyprop_hardreg_forward (void)\n-{\n-  struct value_data *all_vd;\n-  basic_block bb;\n-  sbitmap visited;\n-\n-  all_vd = XNEWVEC (struct value_data, last_basic_block);\n-\n-  visited = sbitmap_alloc (last_basic_block);\n-  sbitmap_zero (visited);\n-\n-  FOR_EACH_BB (bb)\n-    {\n-      SET_BIT (visited, bb->index);\n-\n-      /* If a block has a single predecessor, that we've already\n-\t processed, begin with the value data that was live at\n-\t the end of the predecessor block.  */\n-      /* ??? Ought to use more intelligent queuing of blocks.  */\n-      if (single_pred_p (bb) \n-\t  && TEST_BIT (visited, single_pred (bb)->index)\n-\t  && ! (single_pred_edge (bb)->flags & (EDGE_ABNORMAL_CALL | EDGE_EH)))\n-\tall_vd[bb->index] = all_vd[single_pred (bb)->index];\n-      else\n-\tinit_value_data (all_vd + bb->index);\n-\n-      copyprop_hardreg_forward_1 (bb, all_vd + bb->index);\n-    }\n-\n-  sbitmap_free (visited);  \n-  free (all_vd);\n-}\n-\n-/* Dump the value chain data to stderr.  */\n-\n-void\n-debug_value_data (struct value_data *vd)\n-{\n-  HARD_REG_SET set;\n-  unsigned int i, j;\n-\n-  CLEAR_HARD_REG_SET (set);\n-\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; ++i)\n-    if (vd->e[i].oldest_regno == i)\n-      {\n-\tif (vd->e[i].mode == VOIDmode)\n-\t  {\n-\t    if (vd->e[i].next_regno != INVALID_REGNUM)\n-\t      fprintf (stderr, \"[%u] Bad next_regno for empty chain (%u)\\n\",\n-\t\t       i, vd->e[i].next_regno);\n-\t    continue;\n-\t  }\n-\n-\tSET_HARD_REG_BIT (set, i);\n-\tfprintf (stderr, \"[%u %s] \", i, GET_MODE_NAME (vd->e[i].mode));\n-\n-\tfor (j = vd->e[i].next_regno;\n-\t     j != INVALID_REGNUM;\n-\t     j = vd->e[j].next_regno)\n-\t  {\n-\t    if (TEST_HARD_REG_BIT (set, j))\n-\t      {\n-\t\tfprintf (stderr, \"[%u] Loop in regno chain\\n\", j);\n-\t\treturn;\n-\t      }\n-\n-\t    if (vd->e[j].oldest_regno != i)\n-\t      {\n-\t\tfprintf (stderr, \"[%u] Bad oldest_regno (%u)\\n\",\n-\t\t\t j, vd->e[j].oldest_regno);\n-\t\treturn;\n-\t      }\n-\t    SET_HARD_REG_BIT (set, j);\n-\t    fprintf (stderr, \"[%u %s] \", j, GET_MODE_NAME (vd->e[j].mode));\n-\t  }\n-\tfputc ('\\n', stderr);\n-      }\n-\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; ++i)\n-    if (! TEST_HARD_REG_BIT (set, i)\n-\t&& (vd->e[i].mode != VOIDmode\n-\t    || vd->e[i].oldest_regno != i\n-\t    || vd->e[i].next_regno != INVALID_REGNUM))\n-      fprintf (stderr, \"[%u] Non-empty reg in chain (%s %u %i)\\n\",\n-\t       i, GET_MODE_NAME (vd->e[i].mode), vd->e[i].oldest_regno,\n-\t       vd->e[i].next_regno);\n-}\n-\n-#ifdef ENABLE_CHECKING\n-static void\n-validate_value_data (struct value_data *vd)\n-{\n-  HARD_REG_SET set;\n-  unsigned int i, j;\n-\n-  CLEAR_HARD_REG_SET (set);\n-\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; ++i)\n-    if (vd->e[i].oldest_regno == i)\n-      {\n-\tif (vd->e[i].mode == VOIDmode)\n-\t  {\n-\t    if (vd->e[i].next_regno != INVALID_REGNUM)\n-\t      internal_error (\"validate_value_data: [%u] Bad next_regno for empty chain (%u)\",\n-\t\t\t      i, vd->e[i].next_regno);\n-\t    continue;\n-\t  }\n-\n-\tSET_HARD_REG_BIT (set, i);\n-\n-\tfor (j = vd->e[i].next_regno;\n-\t     j != INVALID_REGNUM;\n-\t     j = vd->e[j].next_regno)\n-\t  {\n-\t    if (TEST_HARD_REG_BIT (set, j))\n-\t      internal_error (\"validate_value_data: Loop in regno chain (%u)\",\n-\t\t\t      j);\n-\t    if (vd->e[j].oldest_regno != i)\n-\t      internal_error (\"validate_value_data: [%u] Bad oldest_regno (%u)\",\n-\t\t\t      j, vd->e[j].oldest_regno);\n-\n-\t    SET_HARD_REG_BIT (set, j);\n-\t  }\n-      }\n-\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; ++i)\n-    if (! TEST_HARD_REG_BIT (set, i)\n-\t&& (vd->e[i].mode != VOIDmode\n-\t    || vd->e[i].oldest_regno != i\n-\t    || vd->e[i].next_regno != INVALID_REGNUM))\n-      internal_error (\"validate_value_data: [%u] Non-empty reg in chain (%s %u %i)\",\n-\t\t      i, GET_MODE_NAME (vd->e[i].mode), vd->e[i].oldest_regno,\n-\t\t      vd->e[i].next_regno);\n-}\n-#endif\n \f\n static bool\n gate_handle_regrename (void)\n {\n   return (optimize > 0 && (flag_rename_registers));\n }\n \n-\n-/* Run the regrename and cprop passes.  */\n-static unsigned int\n-rest_of_handle_regrename (void)\n-{\n-  regrename_optimize ();\n-  return 0;\n-}\n-\n struct rtl_opt_pass pass_regrename =\n {\n  {\n   RTL_PASS,\n   \"rnreg\",                              /* name */\n   gate_handle_regrename,                /* gate */\n-  rest_of_handle_regrename,             /* execute */\n+  regrename_optimize,                   /* execute */\n   NULL,                                 /* sub */\n   NULL,                                 /* next */\n   0,                                    /* static_pass_number */\n@@ -1972,36 +1029,3 @@ struct rtl_opt_pass pass_regrename =\n  }\n };\n \n-static bool\n-gate_handle_cprop (void)\n-{\n-  return (optimize > 0 && (flag_cprop_registers));\n-}\n-\n-\n-/* Run the regrename and cprop passes.  */\n-static unsigned int\n-rest_of_handle_cprop (void)\n-{\n-  copyprop_hardreg_forward ();\n-  return 0;\n-}\n-\n-struct rtl_opt_pass pass_cprop_hardreg =\n-{\n- {\n-  RTL_PASS,\n-  \"cprop_hardreg\",                      /* name */\n-  gate_handle_cprop,                    /* gate */\n-  rest_of_handle_cprop,                 /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_RENAME_REGISTERS,                  /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_dump_func | TODO_verify_rtl_sharing /* todo_flags_finish */\n- }\n-};"}, {"sha": "e6853756e66eb7b4276c4a7dee0542945dfa0aba", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fac412383e1434379bc3dff94de18fd71e9276b3/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fac412383e1434379bc3dff94de18fd71e9276b3/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=fac412383e1434379bc3dff94de18fd71e9276b3", "patch": "@@ -182,6 +182,7 @@ DEFTIMEVAR (TV_THREAD_PROLOGUE_AND_EPILOGUE, \"thread pro- & epilogue\")\n DEFTIMEVAR (TV_IFCVT2\t\t     , \"if-conversion 2\")\n DEFTIMEVAR (TV_PEEPHOLE2             , \"peephole 2\")\n DEFTIMEVAR (TV_RENAME_REGISTERS      , \"rename registers\")\n+DEFTIMEVAR (TV_CPROP_REGISTERS       , \"hard reg cprop\")\n DEFTIMEVAR (TV_SCHED2                , \"scheduling 2\")\n DEFTIMEVAR (TV_MACH_DEP              , \"machine dep reorg\")\n DEFTIMEVAR (TV_DBR_SCHED             , \"delay branch sched\")"}]}