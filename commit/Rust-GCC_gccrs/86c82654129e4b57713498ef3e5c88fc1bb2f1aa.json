{"sha": "86c82654129e4b57713498ef3e5c88fc1bb2f1aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODZjODI2NTQxMjllNGI1NzcxMzQ5OGVmM2U1Yzg4ZmMxYmIyZjFhYQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-05-29T08:18:30Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-05-29T08:18:30Z"}, "message": "function.c (emit_return_into_block): New line_note arg; emit it.\n\n        * function.c (emit_return_into_block): New line_note arg; emit it.\n        (thread_prologue_and_epilogue_insns): Attempt to locate a line note\n        for the close brace to accompany HAVE_return.  Move all line notes\n        following the epilogue to before the NOTE_INSN_EPILOGUE_BEG.\n\nFrom-SVN: r34251", "tree": {"sha": "110df981e31562ec8e459f9059bebb34f553d4d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/110df981e31562ec8e459f9059bebb34f553d4d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86c82654129e4b57713498ef3e5c88fc1bb2f1aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86c82654129e4b57713498ef3e5c88fc1bb2f1aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86c82654129e4b57713498ef3e5c88fc1bb2f1aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86c82654129e4b57713498ef3e5c88fc1bb2f1aa/comments", "author": null, "committer": null, "parents": [{"sha": "8f4773eae70e9869bcb5869c7073a0b8e6bc18f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f4773eae70e9869bcb5869c7073a0b8e6bc18f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f4773eae70e9869bcb5869c7073a0b8e6bc18f2"}], "stats": {"total": 78, "additions": 55, "deletions": 23}, "files": [{"sha": "f425de924e22571992f89a86196eb80096a390a5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c82654129e4b57713498ef3e5c88fc1bb2f1aa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c82654129e4b57713498ef3e5c88fc1bb2f1aa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=86c82654129e4b57713498ef3e5c88fc1bb2f1aa", "patch": "@@ -1,3 +1,10 @@\n+2000-05-29  Richard Henderson  <rth@cygnus.com>\n+\n+\t* function.c (emit_return_into_block): New line_note arg; emit it.\n+\t(thread_prologue_and_epilogue_insns): Attempt to locate a line note\n+\tfor the close brace to accompany HAVE_return.  Move all line notes\n+\tfollowing the epilogue to before the NOTE_INSN_EPILOGUE_BEG.\n+\n 2000-05-29  Richard Henderson  <rth@cygnus.com>\n \n \t* longlong.h [__alpha] (count_leading_zeros): New."}, {"sha": "1c67eec4d8fc32e3f5480d011546e473a8cd82f2", "filename": "gcc/function.c", "status": "modified", "additions": 48, "deletions": 23, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c82654129e4b57713498ef3e5c88fc1bb2f1aa/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c82654129e4b57713498ef3e5c88fc1bb2f1aa/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=86c82654129e4b57713498ef3e5c88fc1bb2f1aa", "patch": "@@ -290,7 +290,7 @@ static tree *get_block_vector   PARAMS ((tree, int *));\n static void record_insns\tPARAMS ((rtx, varray_type *)) ATTRIBUTE_UNUSED;\n static int contains\t\tPARAMS ((rtx, varray_type));\n #ifdef HAVE_return\n-static void emit_return_into_block PARAMS ((basic_block));\n+static void emit_return_into_block PARAMS ((basic_block, rtx));\n #endif\n static void put_addressof_into_stack PARAMS ((rtx, struct hash_table *));\n static boolean purge_addressof_1 PARAMS ((rtx *, rtx, int, int, \n@@ -6798,19 +6798,24 @@ sibcall_epilogue_contains (insn)\n    block_for_insn appropriately.  */\n \n static void\n-emit_return_into_block (bb)\n+emit_return_into_block (bb, line_note)\n      basic_block bb;\n+     rtx line_note;\n {\n   rtx p, end;\n \n-  end = emit_jump_insn_after (gen_return (), bb->end);\n   p = NEXT_INSN (bb->end); \n+  end = emit_jump_insn_after (gen_return (), bb->end);\n+  if (line_note)\n+    emit_line_note_after (NOTE_SOURCE_FILE (line_note),\n+\t\t\t  NOTE_LINE_NUMBER (line_note), bb->end);\n+\n   while (1)\n     {\n       set_block_for_insn (p, bb);\n-      if (p == end)\n+      if (p == bb->end)\n \tbreak;\n-      p = NEXT_INSN (p);\n+      p = PREV_INSN (p);\n     }\n   bb->end = end;\n }\n@@ -6830,6 +6835,9 @@ thread_prologue_and_epilogue_insns (f)\n #ifdef HAVE_prologue\n   rtx prologue_end = NULL_RTX;\n #endif\n+#if defined (HAVE_epilogue) || defined(HAVE_return)\n+  rtx epilogue_end = NULL_RTX;\n+#endif\n \n #ifdef HAVE_prologue\n   if (HAVE_prologue)\n@@ -6902,6 +6910,19 @@ thread_prologue_and_epilogue_insns (f)\n \n       if (last->head == label && GET_CODE (label) == CODE_LABEL)\n \t{\n+          rtx epilogue_line_note = NULL_RTX;\n+\n+\t  /* Locate the line number associated with the closing brace,\n+\t     if we can find one.  */\n+\t  for (seq = get_last_insn ();\n+\t       seq && ! active_insn_p (seq);\n+\t       seq = PREV_INSN (seq))\n+\t    if (GET_CODE (seq) == NOTE && NOTE_LINE_NUMBER (seq) > 0)\n+\t      {\n+\t\tepilogue_line_note = seq;\n+\t\tbreak;\n+\t      }\n+\n \t  for (e = last->pred; e ; e = e_next)\n \t    {\n \t      basic_block bb = e->src;\n@@ -6919,7 +6940,7 @@ thread_prologue_and_epilogue_insns (f)\n \t\t with a simple return instruction.  */\n \t      if (simplejump_p (jump))\n \t\t{\n-\t\t  emit_return_into_block (bb);\n+\t\t  emit_return_into_block (bb, epilogue_line_note);\n \t\t  flow_delete_insn (jump);\n \t\t}\n \n@@ -6951,29 +6972,17 @@ thread_prologue_and_epilogue_insns (f)\n \t\tcontinue;\n \n \t      /* Fix up the CFG for the successful change we just made.  */\n-\t      remove_edge (e);\n-\t      make_edge (NULL, bb, EXIT_BLOCK_PTR, 0);\n+\t      redirect_edge_succ (e, EXIT_BLOCK_PTR);\n \t    }\n \n \t  /* Emit a return insn for the exit fallthru block.  Whether\n \t     this is still reachable will be determined later.  */\n \n \t  emit_barrier_after (last->end);\n-\t  emit_return_into_block (last);\n-\t}\n-      else \n-\t{\n-\t  /* The exit block wasn't empty.  We have to use insert_insn_on_edge,\n-\t     as it may be the exit block can go elsewhere as well\n-\t     as exiting.  */\n-\t  start_sequence ();\n-\t  emit_jump_insn (gen_return ());\n-\t  seq = gen_sequence ();\n-\t  end_sequence ();\n-\t  insert_insn_on_edge (seq, e);\n-\t  inserted = 1;\n+\t  emit_return_into_block (last, epilogue_line_note);\n+\t  epilogue_end = last->end;\n+          goto epilogue_done;\n \t}\n-      goto epilogue_done;\n     }\n #endif\n #ifdef HAVE_epilogue\n@@ -6991,7 +7000,7 @@ thread_prologue_and_epilogue_insns (f)\n \tgoto epilogue_done;\n \n       start_sequence ();\n-      emit_note (NULL, NOTE_INSN_EPILOGUE_BEG);\n+      epilogue_end = emit_note (NULL, NOTE_INSN_EPILOGUE_BEG);\n \n       seq = gen_epilogue ();\n       emit_jump_insn (seq);\n@@ -7094,6 +7103,22 @@ thread_prologue_and_epilogue_insns (f)\n \t}\n     }\n #endif\n+#ifdef HAVE_epilogue\n+  if (epilogue_end)\n+    {\n+      rtx insn, next;\n+\n+      /* Similarly, move any line notes that appear after the epilogue.\n+         There is no need, however, to be quite so anal about the existance\n+\t of such a note.  */\n+      for (insn = epilogue_end; insn ; insn = next)\n+\t{\n+\t  next = NEXT_INSN (insn);\n+\t  if (GET_CODE (insn) == NOTE && NOTE_LINE_NUMBER (insn) > 0)\n+\t    reorder_insns (insn, insn, PREV_INSN (epilogue_end));\n+\t}\n+    }\n+#endif\n }\n \n /* Reposition the prologue-end and epilogue-begin notes after instruction"}]}