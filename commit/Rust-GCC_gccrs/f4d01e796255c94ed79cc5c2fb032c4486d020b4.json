{"sha": "f4d01e796255c94ed79cc5c2fb032c4486d020b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjRkMDFlNzk2MjU1Yzk0ZWQ3OWNjNWMyZmIwMzJjNDQ4NmQwMjBiNA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-02-03T00:52:38Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-02-03T00:52:38Z"}, "message": "(objc_condition_{,de}allocate): New functions.\n\n(objc_condition_{wait,broadcast,signal}): New functions.\n(__objc_runtime_mutex): Eliminate leading underscore from name of objc mutex\nand thread structures.\n\nFrom-SVN: r13595", "tree": {"sha": "a70c5cb2ffcb6f9f6d2e9db7d849bc91f1c3e86a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a70c5cb2ffcb6f9f6d2e9db7d849bc91f1c3e86a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f4d01e796255c94ed79cc5c2fb032c4486d020b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4d01e796255c94ed79cc5c2fb032c4486d020b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4d01e796255c94ed79cc5c2fb032c4486d020b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4d01e796255c94ed79cc5c2fb032c4486d020b4/comments", "author": null, "committer": null, "parents": [{"sha": "3136f75db4864765316286f60ffd72ba5383b594", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3136f75db4864765316286f60ffd72ba5383b594", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3136f75db4864765316286f60ffd72ba5383b594"}], "stats": {"total": 157, "additions": 131, "deletions": 26}, "files": [{"sha": "cbd997c79fbed63fd05ca356b45a504cfac77576", "filename": "gcc/objc/thr-pthreads.c", "status": "modified", "additions": 131, "deletions": 26, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4d01e796255c94ed79cc5c2fb032c4486d020b4/gcc%2Fobjc%2Fthr-pthreads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4d01e796255c94ed79cc5c2fb032c4486d020b4/gcc%2Fobjc%2Fthr-pthreads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fthr-pthreads.c?ref=f4d01e796255c94ed79cc5c2fb032c4486d020b4", "patch": "@@ -1,5 +1,5 @@\n /* GNU Objective C Runtime Thread Implementation for PCThreads under Linux.\n-   Copyright (C) 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n    Contributed by Scott Christley <scottc@net-community.com>\n \n This file is part of GNU CC.\n@@ -37,13 +37,18 @@ static pthread_key_t _objc_thread_storage;\n  *  provided by the system.  We augment it with depth and current owner id\n  *  fields to implement and re-entrant lock.\n  */\n-struct _objc_mutex \n+struct objc_mutex \n {\n-  volatile _objc_thread_t     owner;          /* Id of thread that owns.  */\n+  volatile objc_thread_t     owner;          /* Id of thread that owns.  */\n   volatile int                depth;          /* # of acquires.           */\n   pthread_mutex_t             mutex;          /* PCThread mutex           */\n };\n \n+struct objc_condition \n+{\n+  pthread_cond_t              condition;      /* cthread condition        */\n+};\n+\n /********\n  *  Initialize the threads subsystem.  Returns 0 if successful, or -1 if no\n  *  thread support is available.\n@@ -71,17 +76,17 @@ __objc_fini_thread_system(void)\n  *  Create a new thread of execution and return its id.  Return NULL if fails.\n  *  The new thread starts in \"func\" with the given argument.\n  */\n-_objc_thread_t\n+objc_thread_t\n objc_thread_create(void (*func)(void *arg), void *arg)\n {\n-  _objc_thread_t thread_id;\n+  objc_thread_t thread_id;\n   pthread_t new_thread_handle;\n \n   objc_mutex_lock(__objc_runtime_mutex);\n   \n   if ( !(pthread_create(&new_thread_handle, NULL, (void *)func, arg)) )\n     {\n-      thread_id = *(_objc_thread_t *)&new_thread_handle;\n+      thread_id = *(objc_thread_t *)&new_thread_handle;\n       __objc_runtime_threads_alive++;\n     }\n   else\n@@ -99,7 +104,7 @@ int\n objc_thread_set_priority(int priority)\n {\n   /* Not implemented yet */\n-  return -1;                                   \t/* Failed.    */\n+  return -1;                                   \t/* Failed.                  */\n }\n \n /********\n@@ -109,7 +114,7 @@ int\n objc_thread_get_priority(void)\n {\n   /* Not implemented yet */\n-  return OBJC_THREAD_INTERACTIVE_PRIORITY;      /* Highest priority.   */\n+  return OBJC_THREAD_INTERACTIVE_PRIORITY;      /* Highest priority.        */\n }\n \n /********\n@@ -134,20 +139,20 @@ objc_thread_exit(void)\n   __objc_runtime_threads_alive--;\n   objc_mutex_unlock(__objc_runtime_mutex);\n       \n-  pthread_exit(&__objc_thread_exit_status);     /* Terminate thread.  */\n+  pthread_exit(&__objc_thread_exit_status);     /* Terminate thread.        */\n   return -1;\n }\n \n /********\n  *  Returns an integer value which uniquely describes a thread.  Must not be\n  *  NULL which is reserved as a marker for \"no thread\".\n  */\n-_objc_thread_t\n+objc_thread_t\n objc_thread_id(void)\n {\n   pthread_t self = pthread_self();\n \n-  return *(_objc_thread_t *)&self;            /* Return thread handle.    */\n+  return *(objc_thread_t *)&self;            /* Return thread handle.    */\n }\n \n /********\n@@ -178,12 +183,12 @@ objc_thread_get_data(void)\n  *  Allocate a mutex.  Return the mutex pointer if successful or NULL if the\n  *  allocation failed for any reason.\n  */\n-_objc_mutex_t\n+objc_mutex_t\n objc_mutex_allocate(void)\n {\n-  _objc_mutex_t mutex;\n+  objc_mutex_t mutex;\n     \n-  if (!(mutex = (_objc_mutex_t) objc_malloc(sizeof(struct _objc_mutex))))\n+  if (!(mutex = (objc_mutex_t)objc_malloc(sizeof(struct objc_mutex))))\n     return NULL;                            /* Abort if malloc failed.  */\n \n   /* Create PCThread mutex */\n@@ -207,7 +212,7 @@ objc_mutex_allocate(void)\n  *  Returns the number of locks on the thread.  (1 for deallocate).\n  */\n int\n-objc_mutex_deallocate(_objc_mutex_t mutex)\n+objc_mutex_deallocate(objc_mutex_t mutex)\n {\n   int         depth;                          /* # of locks on mutex.     */\n \n@@ -229,9 +234,9 @@ objc_mutex_deallocate(_objc_mutex_t mutex)\n  *  Returns the lock count on the mutex held by this thread.\n  */\n int\n-objc_mutex_lock(_objc_mutex_t mutex)\n+objc_mutex_lock(objc_mutex_t mutex)\n {\n-  _objc_thread_t      thread_id;              /* Cache our thread id.     */\n+  objc_thread_t      thread_id;              /* Cache our thread id.     */\n   int status;\n \n   if (!mutex)                                 /* Is argument bad?         */\n@@ -259,9 +264,9 @@ objc_mutex_lock(_objc_mutex_t mutex)\n  *  thread has a lock on the mutex returns -1.\n  */\n int\n-objc_mutex_trylock(_objc_mutex_t mutex)\n+objc_mutex_trylock(objc_mutex_t mutex)\n {\n-  _objc_thread_t      thread_id;              /* Cache our thread id.     */\n+  objc_thread_t      thread_id;              /* Cache our thread id.     */\n   int status;\n \n   if (!mutex)                                 /* Is argument bad?         */\n@@ -280,16 +285,16 @@ objc_mutex_trylock(_objc_mutex_t mutex)\n }\n \n /********\n- * Decrements the lock count on this mutex by one.  If the lock count reaches\n- * zero, release the lock on the mutex.  Returns the lock count on the mutex.\n- * It is an error to attempt to unlock a mutex which this thread doesn't hold\n- * in which case return -1 and the mutex is unaffected.\n- * Will also return -1 if the mutex free fails.\n+ *  Decrements the lock count on this mutex by one.  If the lock count reaches\n+ *  zero, release the lock on the mutex.  Returns the lock count on the mutex.\n+ *  It is an error to attempt to unlock a mutex which this thread doesn't hold\n+ *  in which case return -1 and the mutex is unaffected.\n+ *  Will also return -1 if the mutex free fails.\n  */\n int\n-objc_mutex_unlock(_objc_mutex_t mutex)\n+objc_mutex_unlock(objc_mutex_t mutex)\n {\n-  _objc_thread_t thread_id;                   /* Cache our thread id.     */\n+  objc_thread_t thread_id;                   /* Cache our thread id.     */\n   int status;\n     \n   if (!mutex)                                 /* Is argument bad?         */\n@@ -310,4 +315,104 @@ objc_mutex_unlock(_objc_mutex_t mutex)\n   return 0;                                   /* No, return success.      */\n }\n \n+/********\n+ *  Allocate a condition.  Return the condition pointer if successful or NULL\n+ * if the allocation failed for any reason.\n+ */\n+objc_condition_t \n+objc_condition_allocate(void)\n+{\n+    objc_condition_t condition;\n+    \n+    if (!(condition = (objc_condition_t)objc_malloc(\n+                        sizeof(struct objc_condition))))\n+        return NULL;                            /* Abort if malloc failed.  */\n+\n+  \tif ( pthread_cond_init(&(condition->condition), NULL) ) {\n+\t\tobjc_free(condition);\n+\t\treturn NULL;\n+\t}\n+    \n+    return condition;                           /* Return condition handle. */\n+}\n+\n+/********\n+ *  Deallocate a condition. Note that this includes an implicit \n+ *  condition_broadcast to insure that waiting threads have the opportunity\n+ *  to wake.  It is legal to dealloc a condition only if no other\n+ *  thread is/will be using it. Here we do NOT check for other threads\n+ *  waiting but just wake them up.\n+ */\n+int\n+objc_condition_deallocate(objc_condition_t condition)\n+{\n+\tpthread_cond_broadcast(&(condition->condition));\n+\tpthread_cond_destroy(&(condition->condition));\n+\tobjc_free(condition);\n+\treturn 0;\n+}\n+\n+/********\n+ *  Wait on the condition unlocking the mutex until objc_condition_signal()\n+ *  or objc_condition_broadcast() are called for the same condition. The\n+ *  given mutex *must* have the depth set to 1 so that it can be unlocked\n+ *  here, so that someone else can lock it and signal/broadcast the condition.\n+ *  The mutex is used to lock access to the shared data that make up the\n+ *  \"condition\" predicate.\n+ */\n+int\n+objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n+{\n+    objc_thread_t    thread_id;                /* Cache our thread id.     */\n+    \n+    if (!mutex || !condition)                   /* Is argument bad?         */\n+        return -1;                              /* Yes, abort.              */\n+\n+    thread_id = objc_thread_id();               /* Get this thread's id.    */\n+    if (mutex->owner != thread_id)              /* Does some else own lock? */\n+        return -1;                              /* Yes, abort.              */\n+    if (mutex->depth > 1)                       /* Locked more than once ?  */\n+        return -1;                              /* YES, return error        */\n+                                                /* mutex will be unlocked   */\n+    mutex->depth = 0;                           /* Yes, reset depth to 0.   */\n+    mutex->owner = (objc_thread_t) -1;         /* Set owner to \"no thread\".*/\n+    \n+    pthread_cond_wait(&(condition->condition),\n+\t\t&(mutex->mutex));               /* unlock, wait ..., lock   */\n+    \n+    mutex->owner = thread_id;                   /* Mark thread as owner.    */\n+    mutex->depth = 1;                           /* Increment depth to end.  */\n+    return 0;                                   /* Return success.          */\n+}\n+\n+/********\n+ *  Wake up all threads waiting on this condition. It is recommended that \n+ *  the called would lock the same mutex as the threads in objc_condition_wait\n+ *  before changing the \"condition predicate\" and make this call and unlock it\n+ *  right away after this call.\n+ */\n+int\n+objc_condition_broadcast(objc_condition_t condition)\n+{\n+    if (!condition)\n+\t\treturn -1;\n+\tpthread_cond_broadcast(&(condition->condition));\n+\treturn 0;\n+}\n+\n+/********\n+ *  Wake up one thread waiting on this condition. It is recommended that \n+ *  the called would lock the same mutex as the threads in objc_condition_wait\n+ *  before changing the \"condition predicate\" and make this call and unlock it\n+ *  right away after this call.\n+ */\n+int\n+objc_condition_signal(objc_condition_t condition)\n+{\n+    if (!condition)\n+\t\treturn -1;\n+\tpthread_cond_signal(&(condition->condition));\n+\treturn 0;\n+}\n+\n /* End of File */"}]}