{"sha": "5906d0133520f77a2220aa61abe2ad428ac09e8f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTkwNmQwMTMzNTIwZjc3YTIyMjBhYTYxYWJlMmFkNDI4YWMwOWU4Zg==", "commit": {"author": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2004-09-02T23:22:12Z"}, "committer": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2004-09-02T23:22:12Z"}, "message": "builtins.c (expand_builtin_cabs): Delete.\n\n2004-09-02  Eric Christopher  <echristo@redhat.com>\n\n\t* builtins.c (expand_builtin_cabs): Delete.\n\t(expand_builtin): If unable to fold the values do a normal\n\tlibrary call for builtin_cab*.\n\t(fold_builtin_cabs): Depend on optimize and optimize_size.\n\t* optabs.c (expand_cmplxdiv_straight): Delete.\n\t(expand_cmplxdiv_wide): Ditto.\n\t(expand_vector_binop): Ditto.\n\t(expand_vector_unop): Ditto.\n\t(expand_complex_abs): Delete.\n\t(expand_binop): Remove calls to above functions.\n\tRemove open coding of complex arithmetic.\n\t(expand_unop): Ditto.\n\t* optabs.h: Remove prototypes.\n\nFrom-SVN: r87000", "tree": {"sha": "6ef892fb321b2f18c39b26ecd4d2c4f8925fbe8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ef892fb321b2f18c39b26ecd4d2c4f8925fbe8f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5906d0133520f77a2220aa61abe2ad428ac09e8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5906d0133520f77a2220aa61abe2ad428ac09e8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5906d0133520f77a2220aa61abe2ad428ac09e8f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5906d0133520f77a2220aa61abe2ad428ac09e8f/comments", "author": null, "committer": null, "parents": [{"sha": "3041390da7312f233009be427799cdc16a5cf9ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3041390da7312f233009be427799cdc16a5cf9ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3041390da7312f233009be427799cdc16a5cf9ce"}], "stats": {"total": 1272, "additions": 78, "deletions": 1194}, "files": [{"sha": "b6e3cb29d882d562694bbcc68d177c51e246fee5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 51, "deletions": 35, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5906d0133520f77a2220aa61abe2ad428ac09e8f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5906d0133520f77a2220aa61abe2ad428ac09e8f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5906d0133520f77a2220aa61abe2ad428ac09e8f", "patch": "@@ -1,3 +1,19 @@\n+2004-09-02  Eric Christopher  <echristo@redhat.com>\n+\n+\t* builtins.c (expand_builtin_cabs): Delete.\n+\t(expand_builtin): If unable to fold the values do a normal\n+\tlibrary call for builtin_cab*.\n+\t(fold_builtin_cabs): Depend on optimize and optimize_size.\n+\t* optabs.c (expand_cmplxdiv_straight): Delete.\n+\t(expand_cmplxdiv_wide): Ditto.\n+\t(expand_vector_binop): Ditto.\n+\t(expand_vector_unop): Ditto.\n+\t(expand_complex_abs): Delete.\n+\t(expand_binop): Remove calls to above functions.\n+\tRemove open coding of complex arithmetic.\n+\t(expand_unop): Ditto.\n+\t* optabs.h: Remove prototypes.\n+\n 2004-09-02  Ziemowit Laski  <zlaski@apple.com>\n \n \t* c-decl.c (store_parm_decls_newstyle): Make externally visible.\n@@ -133,7 +149,7 @@\n \t(struct algorithm): Change type of cost field to be mult_cost.\n \t(synth_mult): Change type of cost_limit argument to be a\n \tpointer to a mult_cost.  Update all cost comparisons to use the\n-\tnew mult_cost infrastructure.  For alg_add_factor and \n+\tnew mult_cost infrastructure.  For alg_add_factor and\n \talg_sub_factor operations, latency is lower than the rtx_cost.\n \t(choose_mult_variant):  Update calls to synth_mult.  Perform\n \tcost comparisons using the new mult_cost infrastructure.\n@@ -343,7 +359,7 @@\n \t* config/arm/arm.c (arm_cxx_export_class_data): New function.\n \t(TARGET_CXX_EXPORT_CLASS_DATA): Use it.\n \t* doc/tm.texi (TARGET_CXX_EXPORT_CLASS_DATA): Document it.\n-\t\n+\n 2004-08-31  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \t* config/sh/sh.c (output_branch): Check the insn length possibly\n@@ -384,7 +400,7 @@\n \t(TARGET_CXX_KEY_METHOD_MAY_BE_INLINE): New macro.\n \t* config/arm/bpabi.h: Use __THUMB_INTERWORK__ instead of\n \t__THUMB_INTERWORK.\n-\t\n+\n 2004-08-31  Denis Chertykov  <denisc@overta.ru>\n \n \tPR target/15417\n@@ -401,7 +417,7 @@\n \n \t* config/darwin.c (darwin_make_decl_one_only): Allocate section\n \tnames once per compilation, instead of once per symbol.\n-\t\n+\n 2004-08-31  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* Makefile.in (build_subdir): New substitution.\n@@ -420,7 +436,7 @@\n \t* fixinc.in: New, from fixinc/fixincl.sh.\n \n \t* fixinc/*: Removed.\n-\t\n+\n 2004-08-31  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \t* attribs.c (strip_attrs): Remove.\n@@ -450,12 +466,12 @@\n \n 2004-08-30  Andrew Pinski  <apinski@apple.com>\n \n-\t* hard-reg-set.h: \n+\t* hard-reg-set.h:\n \ts/HOST_BITS_PER_WIDES_FAST_INT/HOST_BITS_PER_WIDEST_FAST_INT.\n \t* ChangeLog: Fix previous ChangeLog entry.\n \n \tPR rtl-opt/13987\n-\t* config.host (use_long_long_for_widest_fast_int): New, default is \n+\t* config.host (use_long_long_for_widest_fast_int): New, default is\n \toff.\n \t(ia64-*-hpux*): Enable use_long_long_for_widest_fast_int.\n \t* configure.ac: If use_long_long_for_widest_fast_int, then\n@@ -468,7 +484,7 @@\n \t* sbitmap.h (SBITMAP_ELT_BITS): Define based on\n \tHOST_BITS_PER_WIDEST_FAST_INT.\n \t(SBITMAP_ELT_TYPE): Define based on HOST_WIDEST_FAST_INT.\n-\t* hard-reg-set.h (HARD_REG_ELT_TYPE): Define based on \n+\t* hard-reg-set.h (HARD_REG_ELT_TYPE): Define based on\n \tHOST_WIDEST_FAST_INT\n \tinstead of HOST_WIDE_INT.\n \t(HARD_REG_SET_LONGS): Likewise.\n@@ -515,7 +531,7 @@\n \n 2004-08-30  Richard Henderson  <rth@redhat.com>\n \n-\t* c-typeck.c (build_unary_op): Don't expand ADDR_EXPR of a \n+\t* c-typeck.c (build_unary_op): Don't expand ADDR_EXPR of a\n \tCOMPONENT_REF to pointer arithmetic.\n \t* varasm.c (initializer_constant_valid_p): Allow \"&(*c).f\", for\n \tconstant \"c\" as a valid constant initializer.  Allow narrowing of\n@@ -769,7 +785,7 @@\n \n 2004-08-29  Chao-ying Fu  <fu@mips.com>\n \t    James E Wilson  <wilson@specifixinc.com>\n-\t\n+\n \t* config/mips/mips-modes.def (V2SF, CCV2, CCV4): New modes. Give CCV2\n \t8 byte size and alignment.  Give CCV4 16 byte size and alignment.\n \t* config/mips/mips-ps-3d.md: New file.\n@@ -811,7 +827,7 @@\n \t(enum mips_builtins): New for MIPS builtin functions.\n \t(enum mips_function_type): New for the types of MIPS builtin functions.\n \t(enum mips_cmp_choice): New for the MIPS comparison builtin functions.\n-\t* config/mips/mips.md: New constants for paired single and MIPS-3D \n+\t* config/mips/mips.md: New constants for paired single and MIPS-3D\n \tinstructions.  Include the new mips-ps-3d.md file.\n \t(addv2sf3, subv2sf3, mulv2sf3, absv2sf2, negv2sf2, movv2sf,\n \tmovv2sf_hardfloat_64bit): New named patterns.\n@@ -976,7 +992,7 @@\n \n 2004-08-26  Fariborz Jahanian  <fjahanian@apple.com>\n \n-\t* config/rs6000/rs6000.h (HARD_REGNO_CALL_PART_CLOBBERED): Added \n+\t* config/rs6000/rs6000.h (HARD_REGNO_CALL_PART_CLOBBERED): Added\n \tTFmode as additional register mode cloberred by call.\n \n 2004-08-26  Fariborz Jahanian  <fjahanian@apple.com>\n@@ -997,7 +1013,7 @@\n \ttarget mode.\n \t* config/rs6000/rs6000.md (movdi_update): Changed to movdi_<mode>_update,\n \tto generate two versions.\n- \n+\n 2004-08-26  Daniel Berlin  <dberlin@dberlin.org>\n \n \t* Makefile.in (lambda-code.o): New.\n@@ -1016,11 +1032,11 @@\n \t* lambda-mat.c: Include tree.h\n \n 2004-08-26  Daniel Berlin <dberlin@dberlin.org>\n-\t    Sebastian Pop  <pop@cri.ensmp.fr>\t\n-\t\n-\t* tree-data-ref.h: Include lambda.h\t\n+\t    Sebastian Pop  <pop@cri.ensmp.fr>\n+\n+\t* tree-data-ref.h: Include lambda.h\n \t(free_dependence_relation): Declared here.\n-\t(free_dependence_relations): Ditto.\t\n+\t(free_dependence_relations): Ditto.\n \t(free_data_refs): Ditto.\n \t* tree-data-ref.c (free_dependence_relation): New function.\n \t(free_dependence_relations): Ditto.\n@@ -1038,7 +1054,7 @@\n \tand classic_dist vectors.\n \t(analyze_all_data_dependences): Adjusted for using the new interface of\n \tcompute_data_dependences_for_loop.  Remove the statistics dump.\n-\t\n+\n 2004-08-26  Bob Wilson  <bob.wilson@acm.org>\n \n \t* config/xtensa/xtensa.c (xtensa_ld_opcodes, xtensa_st_opcodes): Delete.\n@@ -1064,7 +1080,7 @@\n \tif the constant satisfies add_operand.\n \n 2004-08-25  Richard Henderson  <rth@redhat.com>\n- \n+\n \tPR debug/10695\n \t* config/alpha/alpha.c (emit_frame_store_1, emit_frame_store): New.\n \t(alpha_expand_prologue): Handle >32-bit frames.  Generate proper\n@@ -1134,7 +1150,7 @@\n \t(FOR_EACH_SSA_USE_OPERAND): New.  Iterate over operands as uses.\n \t(FOR_EACH_SSA_DEF_OPERAND): New.  Iterate over operands as defs.\n \t(FOR_EACH_SSA_MAYDEF_OPERAND): New.  Iterate over V_MAY_DEFs.\n-\t* tree-ssa-operands.c (NULL_DEF_OPERAND_P, NULL_USE_OPERAND_P): New. \n+\t* tree-ssa-operands.c (NULL_DEF_OPERAND_P, NULL_USE_OPERAND_P): New.\n \tEmpty operand pointers.\n \t* tree-flow-inline.h (op_iter_done): New.  Return true if finished.\n \t(op_iter_next_use): New.  Return next use_operand_p.\n@@ -1145,10 +1161,10 @@\n \t(op_iter_init_def): New.  Initialize structure and get the first def.\n \t(op_iter_init_tree): New.  Initialize structure and get the first tree.\n \t(op_iter_next_maydef): New.  Return next V_MAY_DEF operands.\n-\t(op_iter_init_maydef): New.  Initialize structure and get the first \n+\t(op_iter_init_maydef): New.  Initialize structure and get the first\n \tV_MAY_DEF operands.\n \t* tree-cfg.c (tree_duplicate_bb): Use new operand iterator.\n-\t* tree-dfa.c (compute_immediate_uses_for_stmt, \n+\t* tree-dfa.c (compute_immediate_uses_for_stmt,\n \tredirect_immediate_uses): Use new operand iterator.\n \t(v_may_defs_disappeared_p, v_must_defs_disappeared_p): Delete.\n \t(mark_new_vars_to_rename): Use new operand iterator.  Count virtual\n@@ -1159,12 +1175,12 @@\n \trewrite_trees): Use new operand iterator.\n \t* tree-pretty-print.c (dump_vops): Use new operand iterator.\n \t* tree-sra.c (mark_all_v_defs): Use new operand iterator.\n-\t* tree-ssa-alias.c (compute_points_to_and_addr_escape, \n+\t* tree-ssa-alias.c (compute_points_to_and_addr_escape,\n \tdump_points_to_info): Use new operand iterator.\n-\t* tree-ssa-ccp.c (cp_lattice_meet, visit_stmt, initialize, \n-\treplace_uses_in, replace_vuse_in, likely_value, set_rhs): Use new \n+\t* tree-ssa-ccp.c (cp_lattice_meet, visit_stmt, initialize,\n+\treplace_uses_in, replace_vuse_in, likely_value, set_rhs): Use new\n \toperand iterator.\n-\t* tree-ssa-dce.c (mark_stmt_if_obviously_necessary, \n+\t* tree-ssa-dce.c (mark_stmt_if_obviously_necessary,\n \tpropagate_necessity): Use new operand iterator.\n \t* tree-ssa-dom.c (cprop_into_stmt, optimize_stmt): Use operand iterator.\n \t(register_definitions_for_stmt): Use new operand iterator.  Take stmt as\n@@ -1173,7 +1189,7 @@\n \tbuild_tree_conflict_graph): Use new operand iterator.\n \t* tree-ssa-loop-im.c (determine_max_movement, single_reachable_address,\n \trewrite_mem_refs): Use new operand iterator.\n-\t* tree-ssa-loop-manip.c (find_uses_to_rename_stmt, \n+\t* tree-ssa-loop-manip.c (find_uses_to_rename_stmt,\n \tcheck_loop_closed_ssa_use): Use new operand iterator.\n \t* tree-ssa.c (verify_ssa, replace_immediate_uses): Use operand iterator.\n \t* tree-ssanames.c (release_defs): Use new operand iterator.\n@@ -1203,19 +1219,19 @@\n \tto comments at start of function.\n \t* cfgbuild.c (make_edges):  Add more details to hot/cold partitioning\n \tcomment.\n-\t* cfgcleanup.c (try_simplify_condjump, try_forward_edges, \n-\tmerge_blocks_move_predecessor_nojumps, \n-\tmerge_blocks_move_successor_nojumps, merge_blocks_move, \n+\t* cfgcleanup.c (try_simplify_condjump, try_forward_edges,\n+\tmerge_blocks_move_predecessor_nojumps,\n+\tmerge_blocks_move_successor_nojumps, merge_blocks_move,\n \ttry_crossjump_to_edge, try_crossjump_bb): Likewise.\n \t* cfglayout.c (fixup_reorder_chain): Likewise.\n \t* cfgrtl.c (rtl_can_merge_blocks, try_redirect_by_replacing_jump,\n \tcfg_layout_can_merge_blocks_p):  Likewise.\n \t* ifcvt.c (find_if_case_1, find_if_case_2): Likewise.\n-\t* passes.c (rest_of_compilation): Update comments for calling \n+\t* passes.c (rest_of_compilation): Update comments for calling\n \toptimization that partitions hot/cold basic blocks.\n-\t* doc/invoke.texi:  Update documentation of \n+\t* doc/invoke.texi:  Update documentation of\n \tfreorder-blocks-and-partition flag.\n-\t\n+\n 2004-08-25  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/mips/mips.md (reg): Renamed mode attribute from ccreg.\n@@ -1246,7 +1262,7 @@\n \tPR libstdc++/17005 (fix for HP-UX 11.11)\n \t* config.gcc (hppa*-*-*): Move MASK_BIG_SWITCH to target_cpu_default2.\n \t(hppa*-*-hpux*): Consolidate hppa1.0-*-* code.  Rework handling of\n-\ttm_file including pa-hpux1010.h or pa-hpux1111.h when appropriate.  \n+\ttm_file including pa-hpux1010.h or pa-hpux1111.h when appropriate.\n \t* config/pa/pa-hpux1010.h, config/pa/pa-hpux1111.h: New files.\n \t* config/pa/pa-hpux.h (TARGET_HPUX): Define.\n \t(LINK_SPEC): Handle march=1.0 option.\n@@ -1377,7 +1393,7 @@\n \tLikewise.\n \t* config/xtensa/xtensa.c (xtensa_va_start,\n \txtensa_gimplify_va_arg_expr): Likewise.\n-\t\n+\n \t* objc/objc-act.c (build_objc_string_object,\n \tbuild_objc_symtab_template, init_def_list, init_objc_symtab,\n \tinit_module_descriptor, generate_static_references,"}, {"sha": "b0d7c4c779eaa81ae0e4b6048fea84bee9a48155", "filename": "gcc/builtins.c", "status": "modified", "additions": 11, "deletions": 38, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5906d0133520f77a2220aa61abe2ad428ac09e8f/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5906d0133520f77a2220aa61abe2ad428ac09e8f/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=5906d0133520f77a2220aa61abe2ad428ac09e8f", "patch": "@@ -145,7 +145,6 @@ static bool integer_valued_real_p (tree);\n static tree fold_trunc_transparent_mathfn (tree);\n static bool readonly_data_expr (tree);\n static rtx expand_builtin_fabs (tree, rtx, rtx);\n-static rtx expand_builtin_cabs (tree, rtx);\n static rtx expand_builtin_signbit (tree, rtx);\n static tree fold_builtin_cabs (tree, tree);\n static tree fold_builtin_trunc (tree);\n@@ -377,7 +376,7 @@ c_readstr (const char *str, enum machine_mode mode)\n   unsigned int i, j;\n \n   gcc_assert (GET_MODE_CLASS (mode) == MODE_INT);\n-  \n+\n   c[0] = 0;\n   c[1] = 0;\n   ch = 1;\n@@ -391,7 +390,7 @@ c_readstr (const char *str, enum machine_mode mode)\n \tj = j + UNITS_PER_WORD - 2 * (j % UNITS_PER_WORD) - 1;\n       j *= BITS_PER_UNIT;\n       gcc_assert (j <= 2 * HOST_BITS_PER_WIDE_INT);\n-      \n+\n       if (ch)\n \tch = (unsigned char) str[i];\n       c[j / HOST_BITS_PER_WIDE_INT] |= ch << (j % HOST_BITS_PER_WIDE_INT);\n@@ -758,7 +757,7 @@ expand_builtin_longjmp (rtx buf_addr, rtx value)\n   for (insn = get_last_insn (); insn; insn = PREV_INSN (insn))\n     {\n       gcc_assert (insn != last);\n-      \n+\n       if (JUMP_P (insn))\n \t{\n \t  REG_NOTES (insn) = alloc_EXPR_LIST (REG_NON_LOCAL_GOTO, const0_rtx,\n@@ -1358,7 +1357,7 @@ expand_builtin_apply (rtx function, rtx arguments, rtx argsize)\n \tif ((mode = apply_result_mode[regno]) != VOIDmode)\n \t  {\n \t    gcc_assert (!valreg); /* HAVE_untyped_call required.  */\n-\t    \n+\n \t    valreg = gen_rtx_REG (mode, regno);\n \t  }\n \n@@ -2030,7 +2029,7 @@ expand_builtin_mathfn_3 (tree exp, rtx target, rtx subtarget)\n       if (builtin_optab == sincos_optab)\n \t{\n \t  int result;\n-\t  \n+\n \t  switch (DECL_FUNCTION_CODE (fndecl))\n \t    {\n \t    case BUILT_IN_SIN:\n@@ -4620,7 +4619,7 @@ expand_builtin_unop (enum machine_mode target_mode, tree arglist, rtx target,\n   target = expand_unop (TYPE_MODE (TREE_TYPE (TREE_VALUE (arglist))),\n \t\t\top_optab, op0, target, 1);\n   gcc_assert (target);\n-  \n+\n   return convert_to_mode (target_mode, target, 0);\n }\n \n@@ -4897,30 +4896,6 @@ expand_builtin_fabs (tree arglist, rtx target, rtx subtarget)\n   return expand_abs (mode, op0, target, 0, safe_from_p (target, arg, 1));\n }\n \n-/* Expand a call to cabs, cabsf or cabsl with arguments ARGLIST.\n-   Return 0 if a normal call should be emitted rather than expanding\n-   the function inline.  If convenient, the result should be placed\n-   in target.  */\n-\n-static rtx\n-expand_builtin_cabs (tree arglist, rtx target)\n-{\n-  enum machine_mode mode;\n-  tree arg;\n-  rtx op0;\n-\n-  if (arglist == 0 || TREE_CHAIN (arglist))\n-    return 0;\n-  arg = TREE_VALUE (arglist);\n-  if (TREE_CODE (TREE_TYPE (arg)) != COMPLEX_TYPE\n-      || TREE_CODE (TREE_TYPE (TREE_TYPE (arg))) != REAL_TYPE)\n-    return 0;\n-\n-  mode = TYPE_MODE (TREE_TYPE (arg));\n-  op0 = expand_expr (arg, NULL_RTX, VOIDmode, 0);\n-  return expand_complex_abs (mode, op0, target, 0);\n-}\n-\n /* Create a new constant string literal and return a char* pointer to it.\n    The STRING_CST value is the LEN characters at STR.  */\n static tree\n@@ -5550,15 +5525,11 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n         return target;\n       break;\n \n+      /* Just do a normal library call if we were unable to fold\n+\t the values.  */\n     case BUILT_IN_CABS:\n     case BUILT_IN_CABSF:\n     case BUILT_IN_CABSL:\n-      if (flag_unsafe_math_optimizations)\n-\t{\n-\t  target = expand_builtin_cabs (arglist, target);\n-\t  if (target)\n-\t    return target;\n-\t}\n       break;\n \n     case BUILT_IN_EXP:\n@@ -6518,7 +6489,9 @@ fold_builtin_cabs (tree arglist, tree type)\n       && real_zerop (TREE_OPERAND (arg, 1)))\n     return fold (build1 (ABS_EXPR, type, TREE_OPERAND (arg, 0)));\n \n-  if (flag_unsafe_math_optimizations)\n+  /* Don't do this when optimizing for size.  */\n+  if (flag_unsafe_math_optimizations\n+      && optimize && !optimize_size)\n     {\n       tree sqrtfn = mathfn_built_in (type, BUILT_IN_SQRT);\n "}, {"sha": "6c47b57f00159f5ba3c3245f085ec4fe625edecc", "filename": "gcc/optabs.c", "status": "modified", "additions": 15, "deletions": 1117, "changes": 1132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5906d0133520f77a2220aa61abe2ad428ac09e8f/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5906d0133520f77a2220aa61abe2ad428ac09e8f/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=5906d0133520f77a2220aa61abe2ad428ac09e8f", "patch": "@@ -92,13 +92,6 @@ static GTY(()) rtx trap_rtx;\n static int add_equal_note (rtx, rtx, enum rtx_code, rtx, rtx);\n static rtx widen_operand (rtx, enum machine_mode, enum machine_mode, int,\n \t\t\t  int);\n-static int expand_cmplxdiv_straight (rtx, rtx, rtx, rtx, rtx, rtx,\n-\t\t\t\t     enum machine_mode, int,\n-\t\t\t\t     enum optab_methods, enum mode_class,\n-\t\t\t\t     optab);\n-static int expand_cmplxdiv_wide (rtx, rtx, rtx, rtx, rtx, rtx,\n-\t\t\t\t enum machine_mode, int, enum optab_methods,\n-\t\t\t\t enum mode_class, optab);\n static void prepare_cmp_insn (rtx *, rtx *, enum rtx_code *, rtx,\n \t\t\t      enum machine_mode *, int *,\n \t\t\t      enum can_compare_purpose);\n@@ -121,9 +114,6 @@ static void emit_cmp_and_jump_insn_1 (rtx, rtx, enum machine_mode,\n \t\t\t\t      enum rtx_code, int, rtx);\n static void prepare_float_lib_cmp (rtx *, rtx *, enum rtx_code *,\n \t\t\t\t   enum machine_mode *, int *);\n-static rtx expand_vector_binop (enum machine_mode, optab, rtx, rtx, rtx, int,\n-\t\t\t\tenum optab_methods);\n-static rtx expand_vector_unop (enum machine_mode, optab, rtx, rtx, int);\n static rtx widen_clz (enum machine_mode, rtx, rtx);\n static rtx expand_parity (enum machine_mode, rtx, rtx);\n \n@@ -241,393 +231,6 @@ widen_operand (rtx op, enum machine_mode mode, enum machine_mode oldmode,\n   return result;\n }\n \f\n-/* Generate code to perform a straightforward complex divide.  */\n-\n-static int\n-expand_cmplxdiv_straight (rtx real0, rtx real1, rtx imag0, rtx imag1,\n-\t\t\t  rtx realr, rtx imagr, enum machine_mode submode,\n-\t\t\t  int unsignedp, enum optab_methods methods,\n-\t\t\t  enum mode_class class, optab binoptab)\n-{\n-  rtx divisor;\n-  rtx real_t, imag_t;\n-  rtx temp1, temp2;\n-  rtx res;\n-  optab this_add_optab = add_optab;\n-  optab this_sub_optab = sub_optab;\n-  optab this_neg_optab = neg_optab;\n-  optab this_mul_optab = smul_optab;\n-\n-  if (binoptab == sdivv_optab)\n-    {\n-      this_add_optab = addv_optab;\n-      this_sub_optab = subv_optab;\n-      this_neg_optab = negv_optab;\n-      this_mul_optab = smulv_optab;\n-    }\n-\n-  /* Don't fetch these from memory more than once.  */\n-  real0 = force_reg (submode, real0);\n-  real1 = force_reg (submode, real1);\n-\n-  if (imag0 != 0)\n-    imag0 = force_reg (submode, imag0);\n-\n-  imag1 = force_reg (submode, imag1);\n-\n-  /* Divisor: c*c + d*d.  */\n-  temp1 = expand_binop (submode, this_mul_optab, real1, real1,\n-\t\t\tNULL_RTX, unsignedp, methods);\n-\n-  temp2 = expand_binop (submode, this_mul_optab, imag1, imag1,\n-\t\t\tNULL_RTX, unsignedp, methods);\n-\n-  if (temp1 == 0 || temp2 == 0)\n-    return 0;\n-\n-  divisor = expand_binop (submode, this_add_optab, temp1, temp2,\n-\t\t\t  NULL_RTX, unsignedp, methods);\n-  if (divisor == 0)\n-    return 0;\n-\n-  if (imag0 == 0)\n-    {\n-      /* Mathematically, ((a)(c-id))/divisor.  */\n-      /* Computationally, (a+i0) / (c+id) = (ac/(cc+dd)) + i(-ad/(cc+dd)).  */\n-\n-      /* Calculate the dividend.  */\n-      real_t = expand_binop (submode, this_mul_optab, real0, real1,\n-\t\t\t     NULL_RTX, unsignedp, methods);\n-\n-      imag_t = expand_binop (submode, this_mul_optab, real0, imag1,\n-\t\t\t     NULL_RTX, unsignedp, methods);\n-\n-      if (real_t == 0 || imag_t == 0)\n-\treturn 0;\n-\n-      imag_t = expand_unop (submode, this_neg_optab, imag_t,\n-\t\t\t    NULL_RTX, unsignedp);\n-    }\n-  else\n-    {\n-      /* Mathematically, ((a+ib)(c-id))/divider.  */\n-      /* Calculate the dividend.  */\n-      temp1 = expand_binop (submode, this_mul_optab, real0, real1,\n-\t\t\t    NULL_RTX, unsignedp, methods);\n-\n-      temp2 = expand_binop (submode, this_mul_optab, imag0, imag1,\n-\t\t\t    NULL_RTX, unsignedp, methods);\n-\n-      if (temp1 == 0 || temp2 == 0)\n-\treturn 0;\n-\n-      real_t = expand_binop (submode, this_add_optab, temp1, temp2,\n-\t\t\t     NULL_RTX, unsignedp, methods);\n-\n-      temp1 = expand_binop (submode, this_mul_optab, imag0, real1,\n-\t\t\t    NULL_RTX, unsignedp, methods);\n-\n-      temp2 = expand_binop (submode, this_mul_optab, real0, imag1,\n-\t\t\t    NULL_RTX, unsignedp, methods);\n-\n-      if (temp1 == 0 || temp2 == 0)\n-\treturn 0;\n-\n-      imag_t = expand_binop (submode, this_sub_optab, temp1, temp2,\n-\t\t\t     NULL_RTX, unsignedp, methods);\n-\n-      if (real_t == 0 || imag_t == 0)\n-\treturn 0;\n-    }\n-\n-  if (class == MODE_COMPLEX_FLOAT)\n-    res = expand_binop (submode, binoptab, real_t, divisor,\n-\t\t\trealr, unsignedp, methods);\n-  else\n-    res = expand_divmod (0, TRUNC_DIV_EXPR, submode,\n-\t\t\t real_t, divisor, realr, unsignedp);\n-\n-  if (res == 0)\n-    return 0;\n-\n-  if (res != realr)\n-    emit_move_insn (realr, res);\n-\n-  if (class == MODE_COMPLEX_FLOAT)\n-    res = expand_binop (submode, binoptab, imag_t, divisor,\n-\t\t\timagr, unsignedp, methods);\n-  else\n-    res = expand_divmod (0, TRUNC_DIV_EXPR, submode,\n-\t\t\t imag_t, divisor, imagr, unsignedp);\n-\n-  if (res == 0)\n-    return 0;\n-\n-  if (res != imagr)\n-    emit_move_insn (imagr, res);\n-\n-  return 1;\n-}\n-\f\n-/* Generate code to perform a wide-input-range-acceptable complex divide.  */\n-\n-static int\n-expand_cmplxdiv_wide (rtx real0, rtx real1, rtx imag0, rtx imag1, rtx realr,\n-\t\t      rtx imagr, enum machine_mode submode, int unsignedp,\n-\t\t      enum optab_methods methods, enum mode_class class,\n-\t\t      optab binoptab)\n-{\n-  rtx ratio, divisor;\n-  rtx real_t, imag_t;\n-  rtx temp1, temp2, lab1, lab2;\n-  enum machine_mode mode;\n-  rtx res;\n-  optab this_add_optab = add_optab;\n-  optab this_sub_optab = sub_optab;\n-  optab this_neg_optab = neg_optab;\n-  optab this_mul_optab = smul_optab;\n-\n-  if (binoptab == sdivv_optab)\n-    {\n-      this_add_optab = addv_optab;\n-      this_sub_optab = subv_optab;\n-      this_neg_optab = negv_optab;\n-      this_mul_optab = smulv_optab;\n-    }\n-\n-  /* Don't fetch these from memory more than once.  */\n-  real0 = force_reg (submode, real0);\n-  real1 = force_reg (submode, real1);\n-\n-  if (imag0 != 0)\n-    imag0 = force_reg (submode, imag0);\n-\n-  imag1 = force_reg (submode, imag1);\n-\n-  /* XXX What's an \"unsigned\" complex number?  */\n-  if (unsignedp)\n-    {\n-      temp1 = real1;\n-      temp2 = imag1;\n-    }\n-  else\n-    {\n-      temp1 = expand_abs (submode, real1, NULL_RTX, unsignedp, 1);\n-      temp2 = expand_abs (submode, imag1, NULL_RTX, unsignedp, 1);\n-    }\n-\n-  if (temp1 == 0 || temp2 == 0)\n-    return 0;\n-\n-  mode = GET_MODE (temp1);\n-  lab1 = gen_label_rtx ();\n-  emit_cmp_and_jump_insns (temp1, temp2, LT, NULL_RTX,\n-\t\t\t   mode, unsignedp, lab1);\n-\n-  /* |c| >= |d|; use ratio d/c to scale dividend and divisor.  */\n-\n-  if (class == MODE_COMPLEX_FLOAT)\n-    ratio = expand_binop (submode, binoptab, imag1, real1,\n-\t\t\t  NULL_RTX, unsignedp, methods);\n-  else\n-    ratio = expand_divmod (0, TRUNC_DIV_EXPR, submode,\n-\t\t\t   imag1, real1, NULL_RTX, unsignedp);\n-\n-  if (ratio == 0)\n-    return 0;\n-\n-  /* Calculate divisor.  */\n-\n-  temp1 = expand_binop (submode, this_mul_optab, imag1, ratio,\n-\t\t\tNULL_RTX, unsignedp, methods);\n-\n-  if (temp1 == 0)\n-    return 0;\n-\n-  divisor = expand_binop (submode, this_add_optab, temp1, real1,\n-\t\t\t  NULL_RTX, unsignedp, methods);\n-\n-  if (divisor == 0)\n-    return 0;\n-\n-  /* Calculate dividend.  */\n-\n-  if (imag0 == 0)\n-    {\n-      real_t = real0;\n-\n-      /* Compute a / (c+id) as a / (c+d(d/c)) + i (-a(d/c)) / (c+d(d/c)).  */\n-\n-      imag_t = expand_binop (submode, this_mul_optab, real0, ratio,\n-\t\t\t     NULL_RTX, unsignedp, methods);\n-\n-      if (imag_t == 0)\n-\treturn 0;\n-\n-      imag_t = expand_unop (submode, this_neg_optab, imag_t,\n-\t\t\t    NULL_RTX, unsignedp);\n-\n-      if (real_t == 0 || imag_t == 0)\n-\treturn 0;\n-    }\n-  else\n-    {\n-      /* Compute (a+ib)/(c+id) as\n-\t (a+b(d/c))/(c+d(d/c) + i(b-a(d/c))/(c+d(d/c)).  */\n-\n-      temp1 = expand_binop (submode, this_mul_optab, imag0, ratio,\n-\t\t\t    NULL_RTX, unsignedp, methods);\n-\n-      if (temp1 == 0)\n-\treturn 0;\n-\n-      real_t = expand_binop (submode, this_add_optab, temp1, real0,\n-\t\t\t     NULL_RTX, unsignedp, methods);\n-\n-      temp1 = expand_binop (submode, this_mul_optab, real0, ratio,\n-\t\t\t    NULL_RTX, unsignedp, methods);\n-\n-      if (temp1 == 0)\n-\treturn 0;\n-\n-      imag_t = expand_binop (submode, this_sub_optab, imag0, temp1,\n-\t\t\t     NULL_RTX, unsignedp, methods);\n-\n-      if (real_t == 0 || imag_t == 0)\n-\treturn 0;\n-    }\n-\n-  if (class == MODE_COMPLEX_FLOAT)\n-    res = expand_binop (submode, binoptab, real_t, divisor,\n-\t\t\trealr, unsignedp, methods);\n-  else\n-    res = expand_divmod (0, TRUNC_DIV_EXPR, submode,\n-\t\t\t real_t, divisor, realr, unsignedp);\n-\n-  if (res == 0)\n-    return 0;\n-\n-  if (res != realr)\n-    emit_move_insn (realr, res);\n-\n-  if (class == MODE_COMPLEX_FLOAT)\n-    res = expand_binop (submode, binoptab, imag_t, divisor,\n-\t\t\timagr, unsignedp, methods);\n-  else\n-    res = expand_divmod (0, TRUNC_DIV_EXPR, submode,\n-\t\t\t imag_t, divisor, imagr, unsignedp);\n-\n-  if (res == 0)\n-    return 0;\n-\n-  if (res != imagr)\n-    emit_move_insn (imagr, res);\n-\n-  lab2 = gen_label_rtx ();\n-  emit_jump_insn (gen_jump (lab2));\n-  emit_barrier ();\n-\n-  emit_label (lab1);\n-\n-  /* |d| > |c|; use ratio c/d to scale dividend and divisor.  */\n-\n-  if (class == MODE_COMPLEX_FLOAT)\n-    ratio = expand_binop (submode, binoptab, real1, imag1,\n-\t\t\t  NULL_RTX, unsignedp, methods);\n-  else\n-    ratio = expand_divmod (0, TRUNC_DIV_EXPR, submode,\n-\t\t\t   real1, imag1, NULL_RTX, unsignedp);\n-\n-  if (ratio == 0)\n-    return 0;\n-\n-  /* Calculate divisor.  */\n-\n-  temp1 = expand_binop (submode, this_mul_optab, real1, ratio,\n-\t\t\tNULL_RTX, unsignedp, methods);\n-\n-  if (temp1 == 0)\n-    return 0;\n-\n-  divisor = expand_binop (submode, this_add_optab, temp1, imag1,\n-\t\t\t  NULL_RTX, unsignedp, methods);\n-\n-  if (divisor == 0)\n-    return 0;\n-\n-  /* Calculate dividend.  */\n-\n-  if (imag0 == 0)\n-    {\n-      /* Compute a / (c+id) as a(c/d) / (c(c/d)+d) + i (-a) / (c(c/d)+d).  */\n-\n-      real_t = expand_binop (submode, this_mul_optab, real0, ratio,\n-\t\t\t     NULL_RTX, unsignedp, methods);\n-\n-      imag_t = expand_unop (submode, this_neg_optab, real0,\n-\t\t\t    NULL_RTX, unsignedp);\n-\n-      if (real_t == 0 || imag_t == 0)\n-\treturn 0;\n-    }\n-  else\n-    {\n-      /* Compute (a+ib)/(c+id) as\n-\t (a(c/d)+b)/(c(c/d)+d) + i (b(c/d)-a)/(c(c/d)+d).  */\n-\n-      temp1 = expand_binop (submode, this_mul_optab, real0, ratio,\n-\t\t\t    NULL_RTX, unsignedp, methods);\n-\n-      if (temp1 == 0)\n-\treturn 0;\n-\n-      real_t = expand_binop (submode, this_add_optab, temp1, imag0,\n-\t\t\t     NULL_RTX, unsignedp, methods);\n-\n-      temp1 = expand_binop (submode, this_mul_optab, imag0, ratio,\n-\t\t\t    NULL_RTX, unsignedp, methods);\n-\n-      if (temp1 == 0)\n-\treturn 0;\n-\n-      imag_t = expand_binop (submode, this_sub_optab, temp1, real0,\n-\t\t\t     NULL_RTX, unsignedp, methods);\n-\n-      if (real_t == 0 || imag_t == 0)\n-\treturn 0;\n-    }\n-\n-  if (class == MODE_COMPLEX_FLOAT)\n-    res = expand_binop (submode, binoptab, real_t, divisor,\n-\t\t\trealr, unsignedp, methods);\n-  else\n-    res = expand_divmod (0, TRUNC_DIV_EXPR, submode,\n-\t\t\t real_t, divisor, realr, unsignedp);\n-\n-  if (res == 0)\n-    return 0;\n-\n-  if (res != realr)\n-    emit_move_insn (realr, res);\n-\n-  if (class == MODE_COMPLEX_FLOAT)\n-    res = expand_binop (submode, binoptab, imag_t, divisor,\n-\t\t\timagr, unsignedp, methods);\n-  else\n-    res = expand_divmod (0, TRUNC_DIV_EXPR, submode,\n-\t\t\t imag_t, divisor, imagr, unsignedp);\n-\n-  if (res == 0)\n-    return 0;\n-\n-  if (res != imagr)\n-    emit_move_insn (imagr, res);\n-\n-  emit_label (lab2);\n-\n-  return 1;\n-}\n-\f\n /* Return the optab used for computing the operation given by\n    the tree code, CODE.  This function is not always usable (for\n    example, it cannot give complete results for multiplication\n@@ -1586,257 +1189,6 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n       delete_insns_since (last);\n     }\n \n-  /* Open-code the vector operations if we have no hardware support\n-     for them.  */\n-  if (class == MODE_VECTOR_INT || class == MODE_VECTOR_FLOAT)\n-    return expand_vector_binop (mode, binoptab, op0, op1, target,\n-\t\t\t\tunsignedp, methods);\n-\n-  /* We need to open-code the complex type operations: '+, -, * and /' */\n-\n-  /* At this point we allow operations between two similar complex\n-     numbers, and also if one of the operands is not a complex number\n-     but rather of MODE_FLOAT or MODE_INT. However, the caller\n-     must make sure that the MODE of the non-complex operand matches\n-     the SUBMODE of the complex operand.  */\n-\n-  if (class == MODE_COMPLEX_FLOAT || class == MODE_COMPLEX_INT)\n-    {\n-      rtx real0 = 0, imag0 = 0;\n-      rtx real1 = 0, imag1 = 0;\n-      rtx realr, imagr, res;\n-      rtx seq, result;\n-      int ok = 0;\n-\n-      /* Find the correct mode for the real and imaginary parts.  */\n-      enum machine_mode submode = GET_MODE_INNER (mode);\n-\n-      if (submode == BLKmode)\n-\tabort ();\n-\n-      start_sequence ();\n-\n-      if (GET_MODE (op0) == mode)\n-\t{\n-\t  real0 = gen_realpart (submode, op0);\n-\t  imag0 = gen_imagpart (submode, op0);\n-\t}\n-      else\n-\treal0 = op0;\n-\n-      if (GET_MODE (op1) == mode)\n-\t{\n-\t  real1 = gen_realpart (submode, op1);\n-\t  imag1 = gen_imagpart (submode, op1);\n-\t}\n-      else\n-\treal1 = op1;\n-\n-      if (real0 == 0 || real1 == 0 || ! (imag0 != 0 || imag1 != 0))\n-\tabort ();\n-\n-      result = gen_reg_rtx (mode);\n-      realr = gen_realpart (submode, result);\n-      imagr = gen_imagpart (submode, result);\n-\n-      switch (binoptab->code)\n-\t{\n-\tcase PLUS:\n-\t  /* (a+ib) + (c+id) = (a+c) + i(b+d) */\n-\tcase MINUS:\n-\t  /* (a+ib) - (c+id) = (a-c) + i(b-d) */\n-\t  res = expand_binop (submode, binoptab, real0, real1,\n-\t\t\t      realr, unsignedp, methods);\n-\n-\t  if (res == 0)\n-\t    break;\n-\t  else if (res != realr)\n-\t    emit_move_insn (realr, res);\n-\n-\t  if (imag0 != 0 && imag1 != 0)\n-\t    res = expand_binop (submode, binoptab, imag0, imag1,\n-\t\t\t\timagr, unsignedp, methods);\n-\t  else if (imag0 != 0)\n-\t    res = imag0;\n-\t  else if (binoptab->code == MINUS)\n-            res = expand_unop (submode,\n-                                binoptab == subv_optab ? negv_optab : neg_optab,\n-                                imag1, imagr, unsignedp);\n-\t  else\n-\t    res = imag1;\n-\n-\t  if (res == 0)\n-\t    break;\n-\t  else if (res != imagr)\n-\t    emit_move_insn (imagr, res);\n-\n-\t  ok = 1;\n-\t  break;\n-\n-\tcase MULT:\n-\t  /* (a+ib) * (c+id) = (ac-bd) + i(ad+cb) */\n-\n-\t  if (imag0 != 0 && imag1 != 0)\n-\t    {\n-\t      rtx temp1, temp2;\n-\n-\t      /* Don't fetch these from memory more than once.  */\n-\t      real0 = force_reg (submode, real0);\n-\t      real1 = force_reg (submode, real1);\n-\t      imag0 = force_reg (submode, imag0);\n-\t      imag1 = force_reg (submode, imag1);\n-\n-\t      temp1 = expand_binop (submode, binoptab, real0, real1, NULL_RTX,\n-\t\t\t\t    unsignedp, methods);\n-\n-\t      temp2 = expand_binop (submode, binoptab, imag0, imag1, NULL_RTX,\n-\t\t\t\t    unsignedp, methods);\n-\n-\t      if (temp1 == 0 || temp2 == 0)\n-\t\tbreak;\n-\n-\t      res = (expand_binop\n-                     (submode,\n-                      binoptab == smulv_optab ? subv_optab : sub_optab,\n-                      temp1, temp2, realr, unsignedp, methods));\n-\n-\t      if (res == 0)\n-\t\tbreak;\n-\t      else if (res != realr)\n-\t\temit_move_insn (realr, res);\n-\n-\t      temp1 = expand_binop (submode, binoptab, real0, imag1,\n-\t\t\t\t    NULL_RTX, unsignedp, methods);\n-\n-\t      /* Avoid expanding redundant multiplication for the common\n-\t\t case of squaring a complex number.  */\n-\t      if (rtx_equal_p (real0, real1) && rtx_equal_p (imag0, imag1))\n-\t\ttemp2 = temp1;\n-\t      else\n-\t\ttemp2 = expand_binop (submode, binoptab, real1, imag0,\n-\t\t\t\t      NULL_RTX, unsignedp, methods);\n-\n-\t      if (temp1 == 0 || temp2 == 0)\n-\t\tbreak;\n-\n-\t      res = (expand_binop\n-                     (submode,\n-                      binoptab == smulv_optab ? addv_optab : add_optab,\n-                      temp1, temp2, imagr, unsignedp, methods));\n-\n-\t      if (res == 0)\n-\t\tbreak;\n-\t      else if (res != imagr)\n-\t\temit_move_insn (imagr, res);\n-\n-\t      ok = 1;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Don't fetch these from memory more than once.  */\n-\t      real0 = force_reg (submode, real0);\n-\t      real1 = force_reg (submode, real1);\n-\n-\t      res = expand_binop (submode, binoptab, real0, real1,\n-\t\t\t\t  realr, unsignedp, methods);\n-\t      if (res == 0)\n-\t\tbreak;\n-\t      else if (res != realr)\n-\t\temit_move_insn (realr, res);\n-\n-\t      if (imag0 != 0)\n-\t\tres = expand_binop (submode, binoptab,\n-\t\t\t\t    real1, imag0, imagr, unsignedp, methods);\n-\t      else\n-\t\tres = expand_binop (submode, binoptab,\n-\t\t\t\t    real0, imag1, imagr, unsignedp, methods);\n-\n-\t      if (res == 0)\n-\t\tbreak;\n-\t      else if (res != imagr)\n-\t\temit_move_insn (imagr, res);\n-\n-\t      ok = 1;\n-\t    }\n-\t  break;\n-\n-\tcase DIV:\n-\t  /* (a+ib) / (c+id) = ((ac+bd)/(cc+dd)) + i((bc-ad)/(cc+dd)) */\n-\n-\t  if (imag1 == 0)\n-\t    {\n-\t      /* (a+ib) / (c+i0) = (a/c) + i(b/c) */\n-\n-\t      /* Don't fetch these from memory more than once.  */\n-\t      real1 = force_reg (submode, real1);\n-\n-\t      /* Simply divide the real and imaginary parts by `c' */\n-\t      if (class == MODE_COMPLEX_FLOAT)\n-\t\tres = expand_binop (submode, binoptab, real0, real1,\n-\t\t\t\t    realr, unsignedp, methods);\n-\t      else\n-\t\tres = expand_divmod (0, TRUNC_DIV_EXPR, submode,\n-\t\t\t\t     real0, real1, realr, unsignedp);\n-\n-\t      if (res == 0)\n-\t\tbreak;\n-\t      else if (res != realr)\n-\t\temit_move_insn (realr, res);\n-\n-\t      if (class == MODE_COMPLEX_FLOAT)\n-\t\tres = expand_binop (submode, binoptab, imag0, real1,\n-\t\t\t\t    imagr, unsignedp, methods);\n-\t      else\n-\t\tres = expand_divmod (0, TRUNC_DIV_EXPR, submode,\n-\t\t\t\t     imag0, real1, imagr, unsignedp);\n-\n-\t      if (res == 0)\n-\t\tbreak;\n-\t      else if (res != imagr)\n-\t\temit_move_insn (imagr, res);\n-\n-\t      ok = 1;\n-\t    }\n-\t  else\n-\t    {\n-\t      switch (flag_complex_divide_method)\n-\t\t{\n-\t\tcase 0:\n-\t\t  ok = expand_cmplxdiv_straight (real0, real1, imag0, imag1,\n-\t\t\t\t\t\t realr, imagr, submode,\n-\t\t\t\t\t\t unsignedp, methods,\n-\t\t\t\t\t\t class, binoptab);\n-\t\t  break;\n-\n-\t\tcase 1:\n-\t\t  ok = expand_cmplxdiv_wide (real0, real1, imag0, imag1,\n-\t\t\t\t\t     realr, imagr, submode,\n-\t\t\t\t\t     unsignedp, methods,\n-\t\t\t\t\t     class, binoptab);\n-\t\t  break;\n-\n-\t\tdefault:\n-\t\t  abort ();\n-\t\t}\n-\t    }\n-\t  break;\n-\n-\tdefault:\n-\t  abort ();\n-\t}\n-\n-      seq = get_insns ();\n-      end_sequence ();\n-\n-      if (ok)\n-\t{\n-\t  rtx equiv = gen_rtx_fmt_ee (binoptab->code, mode,\n-\t\t\t\t      copy_rtx (op0), copy_rtx (op1));\n-\t  emit_no_conflict_block (seq, result, op0, op1, equiv);\n-\t  return result;\n-\t}\n-    }\n-\n   /* It can't be open-coded in this mode.\n      Use a library call if one is available and caller says that's ok.  */\n \n@@ -1952,222 +1304,6 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n   delete_insns_since (entry_last);\n   return 0;\n }\n-\n-/* Like expand_binop, but for open-coding vectors binops.  */\n-\n-static rtx\n-expand_vector_binop (enum machine_mode mode, optab binoptab, rtx op0,\n-\t\t     rtx op1, rtx target, int unsignedp,\n-\t\t     enum optab_methods methods)\n-{\n-  enum machine_mode submode, tmode;\n-  int size, elts, subsize, subbitsize, i;\n-  rtx t, a, b, res, seq;\n-  enum mode_class class;\n-\n-  class = GET_MODE_CLASS (mode);\n-\n-  size = GET_MODE_SIZE (mode);\n-  submode = GET_MODE_INNER (mode);\n-\n-  /* Search for the widest vector mode with the same inner mode that is\n-     still narrower than MODE and that allows to open-code this operator.\n-     Note, if we find such a mode and the handler later decides it can't\n-     do the expansion, we'll be called recursively with the narrower mode.  */\n-  for (tmode = GET_CLASS_NARROWEST_MODE (class);\n-       GET_MODE_SIZE (tmode) < GET_MODE_SIZE (mode);\n-       tmode = GET_MODE_WIDER_MODE (tmode))\n-    {\n-      if (GET_MODE_INNER (tmode) == GET_MODE_INNER (mode)\n-\t  && binoptab->handlers[(int) tmode].insn_code != CODE_FOR_nothing)\n-\tsubmode = tmode;\n-    }\n-\n-  switch (binoptab->code)\n-    {\n-    case AND:\n-    case IOR:\n-    case XOR:\n-      tmode = int_mode_for_mode (mode);\n-      if (tmode != BLKmode)\n-\tsubmode = tmode;\n-    case PLUS:\n-    case MINUS:\n-    case MULT:\n-    case DIV:\n-      subsize = GET_MODE_SIZE (submode);\n-      subbitsize = GET_MODE_BITSIZE (submode);\n-      elts = size / subsize;\n-\n-      /* If METHODS is OPTAB_DIRECT, we don't insist on the exact mode,\n-\t but that we operate on more than one element at a time.  */\n-      if (subsize == GET_MODE_UNIT_SIZE (mode) && methods == OPTAB_DIRECT)\n-\treturn 0;\n-\n-      start_sequence ();\n-\n-      /* Errors can leave us with a const0_rtx as operand.  */\n-      if (GET_MODE (op0) != mode)\n-\top0 = copy_to_mode_reg (mode, op0);\n-      if (GET_MODE (op1) != mode)\n-\top1 = copy_to_mode_reg (mode, op1);\n-\n-      if (!target)\n-\ttarget = gen_reg_rtx (mode);\n-\n-      for (i = 0; i < elts; ++i)\n-\t{\n-\t  /* If this is part of a register, and not the first item in the\n-\t     word, we can't store using a SUBREG - that would clobber\n-\t     previous results.\n-\t     And storing with a SUBREG is only possible for the least\n-\t     significant part, hence we can't do it for big endian\n-\t     (unless we want to permute the evaluation order.  */\n-\t  if (REG_P (target)\n-\t      && (BYTES_BIG_ENDIAN\n-\t\t  ? subsize < UNITS_PER_WORD\n-\t\t  : ((i * subsize) % UNITS_PER_WORD) != 0))\n-\t    t = NULL_RTX;\n-\t  else\n-\t    t = simplify_gen_subreg (submode, target, mode, i * subsize);\n-\t  if (CONSTANT_P (op0))\n-\t    a = simplify_gen_subreg (submode, op0, mode, i * subsize);\n-\t  else\n-\t    a = extract_bit_field (op0, subbitsize, i * subbitsize, unsignedp,\n-\t\t\t\t   NULL_RTX, submode, submode);\n-\t  if (CONSTANT_P (op1))\n-\t    b = simplify_gen_subreg (submode, op1, mode, i * subsize);\n-\t  else\n-\t    b = extract_bit_field (op1, subbitsize, i * subbitsize, unsignedp,\n-\t\t\t\t   NULL_RTX, submode, submode);\n-\n-\t  if (binoptab->code == DIV)\n-\t    {\n-\t      if (class == MODE_VECTOR_FLOAT)\n-\t\tres = expand_binop (submode, binoptab, a, b, t,\n-\t\t\t\t    unsignedp, methods);\n-\t      else\n-\t\tres = expand_divmod (0, TRUNC_DIV_EXPR, submode,\n-\t\t\t\t     a, b, t, unsignedp);\n-\t    }\n-\t  else\n-\t    res = expand_binop (submode, binoptab, a, b, t,\n-\t\t\t\tunsignedp, methods);\n-\n-\t  if (res == 0)\n-\t    break;\n-\n-\t  if (t)\n-\t    emit_move_insn (t, res);\n-\t  else\n-\t    store_bit_field (target, subbitsize, i * subbitsize, submode, res);\n-\t}\n-      break;\n-\n-    default:\n-      abort ();\n-    }\n-\n-  seq = get_insns ();\n-  end_sequence ();\n-  emit_insn (seq);\n-\n-  return target;\n-}\n-\n-/* Like expand_unop but for open-coding vector unops.  */\n-\n-static rtx\n-expand_vector_unop (enum machine_mode mode, optab unoptab, rtx op0,\n-\t\t    rtx target, int unsignedp)\n-{\n-  enum machine_mode submode, tmode;\n-  int size, elts, subsize, subbitsize, i;\n-  rtx t, a, res, seq;\n-\n-  size = GET_MODE_SIZE (mode);\n-  submode = GET_MODE_INNER (mode);\n-\n-  /* Search for the widest vector mode with the same inner mode that is\n-     still narrower than MODE and that allows to open-code this operator.\n-     Note, if we find such a mode and the handler later decides it can't\n-     do the expansion, we'll be called recursively with the narrower mode.  */\n-  for (tmode = GET_CLASS_NARROWEST_MODE (GET_MODE_CLASS (mode));\n-       GET_MODE_SIZE (tmode) < GET_MODE_SIZE (mode);\n-       tmode = GET_MODE_WIDER_MODE (tmode))\n-    {\n-      if (GET_MODE_INNER (tmode) == GET_MODE_INNER (mode)\n-\t  && unoptab->handlers[(int) tmode].insn_code != CODE_FOR_nothing)\n-\tsubmode = tmode;\n-    }\n-  /* If there is no negate operation, try doing a subtract from zero.  */\n-  if (unoptab == neg_optab && GET_MODE_CLASS (submode) == MODE_INT\n-      /* Avoid infinite recursion when an\n-\t error has left us with the wrong mode.  */\n-      && GET_MODE (op0) == mode)\n-    {\n-      rtx temp;\n-      temp = expand_binop (mode, sub_optab, CONST0_RTX (mode), op0,\n-                           target, unsignedp, OPTAB_DIRECT);\n-      if (temp)\n-\treturn temp;\n-    }\n-\n-  if (unoptab == one_cmpl_optab)\n-    {\n-      tmode = int_mode_for_mode (mode);\n-      if (tmode != BLKmode)\n-\tsubmode = tmode;\n-    }\n-\n-  subsize = GET_MODE_SIZE (submode);\n-  subbitsize = GET_MODE_BITSIZE (submode);\n-  elts = size / subsize;\n-\n-  /* Errors can leave us with a const0_rtx as operand.  */\n-  if (GET_MODE (op0) != mode)\n-    op0 = copy_to_mode_reg (mode, op0);\n-\n-  if (!target)\n-    target = gen_reg_rtx (mode);\n-\n-  start_sequence ();\n-\n-  for (i = 0; i < elts; ++i)\n-    {\n-      /* If this is part of a register, and not the first item in the\n-\t word, we can't store using a SUBREG - that would clobber\n-\t previous results.\n-\t And storing with a SUBREG is only possible for the least\n-\t significant part, hence we can't do it for big endian\n-\t (unless we want to permute the evaluation order.  */\n-      if (REG_P (target)\n-\t  && (BYTES_BIG_ENDIAN\n-\t      ?  subsize < UNITS_PER_WORD\n-\t      : ((i * subsize) % UNITS_PER_WORD) != 0))\n-\tt = NULL_RTX;\n-      else\n-\tt = simplify_gen_subreg (submode, target, mode, i * subsize);\n-      if (CONSTANT_P (op0))\n-\ta = simplify_gen_subreg (submode, op0, mode, i * subsize);\n-      else\n-\ta = extract_bit_field (op0, subbitsize, i * subbitsize, unsignedp,\n-\t\t\t       t, submode, submode);\n-\n-      res = expand_unop (submode, unoptab, a, t, unsignedp);\n-\n-      if (t)\n-\temit_move_insn (t, res);\n-      else\n-\tstore_bit_field (target, subbitsize, i * subbitsize, submode, res);\n-    }\n-\n-  seq = get_insns ();\n-  end_sequence ();\n-  emit_insn (seq);\n-\n-  return target;\n-}\n \f\n /* Expand a binary operator which has both signed and unsigned forms.\n    UOPTAB is the optab for unsigned operations, and SOPTAB is for\n@@ -2459,14 +1595,14 @@ expand_twoval_binop (optab binoptab, rtx op0, rtx op1, rtx targ0, rtx targ1,\n    mode of OP0.  Returns 1 if the call was successful.  */\n \n bool\n-expand_twoval_binop_libfunc (optab binoptab, rtx op0, rtx op1, \n+expand_twoval_binop_libfunc (optab binoptab, rtx op0, rtx op1,\n \t\t\t     rtx targ0, rtx targ1, enum rtx_code code)\n {\n   enum machine_mode mode;\n   enum machine_mode libval_mode;\n   rtx libval;\n   rtx insns;\n-  \n+\n   /* Exactly one of TARG0 or TARG1 should be non-NULL.  */\n   if (!((targ0 != NULL_RTX) ^ (targ1 != NULL_RTX)))\n     abort ();\n@@ -2477,23 +1613,23 @@ expand_twoval_binop_libfunc (optab binoptab, rtx op0, rtx op1,\n \n   /* The value returned by the library function will have twice as\n      many bits as the nominal MODE.  */\n-  libval_mode = smallest_mode_for_size (2 * GET_MODE_BITSIZE (mode), \n+  libval_mode = smallest_mode_for_size (2 * GET_MODE_BITSIZE (mode),\n \t\t\t\t\tMODE_INT);\n   start_sequence ();\n   libval = emit_library_call_value (binoptab->handlers[(int) mode].libfunc,\n-\t\t\t\t    NULL_RTX, LCT_CONST, \n+\t\t\t\t    NULL_RTX, LCT_CONST,\n \t\t\t\t    libval_mode, 2,\n-\t\t\t\t    op0, mode, \n+\t\t\t\t    op0, mode,\n \t\t\t\t    op1, mode);\n   /* Get the part of VAL containing the value that we want.  */\n   libval = simplify_gen_subreg (mode, libval, libval_mode,\n \t\t\t\ttarg0 ? 0 : GET_MODE_SIZE (mode));\n   insns = get_insns ();\n   end_sequence ();\n   /* Move the into the desired location.  */\n-  emit_libcall_block (insns, targ0 ? targ0 : targ1, libval, \n+  emit_libcall_block (insns, targ0 ? targ0 : targ1, libval,\n \t\t      gen_rtx_fmt_ee (code, mode, op0, op1));\n-  \n+\n   return true;\n }\n \n@@ -2740,48 +1876,6 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n       return target;\n     }\n \n-  /* Open-code the complex negation operation.  */\n-  else if (unoptab->code == NEG\n-\t   && (class == MODE_COMPLEX_FLOAT || class == MODE_COMPLEX_INT))\n-    {\n-      rtx target_piece;\n-      rtx x;\n-      rtx seq;\n-\n-      /* Find the correct mode for the real and imaginary parts.  */\n-      enum machine_mode submode = GET_MODE_INNER (mode);\n-\n-      if (submode == BLKmode)\n-\tabort ();\n-\n-      if (target == 0)\n-\ttarget = gen_reg_rtx (mode);\n-\n-      start_sequence ();\n-\n-      target_piece = gen_imagpart (submode, target);\n-      x = expand_unop (submode, unoptab,\n-\t\t       gen_imagpart (submode, op0),\n-\t\t       target_piece, unsignedp);\n-      if (target_piece != x)\n-\temit_move_insn (target_piece, x);\n-\n-      target_piece = gen_realpart (submode, target);\n-      x = expand_unop (submode, unoptab,\n-\t\t       gen_realpart (submode, op0),\n-\t\t       target_piece, unsignedp);\n-      if (target_piece != x)\n-\temit_move_insn (target_piece, x);\n-\n-      seq = get_insns ();\n-      end_sequence ();\n-\n-      emit_no_conflict_block (seq, target, op0, 0,\n-\t\t\t      gen_rtx_fmt_e (unoptab->code, mode,\n-\t\t\t\t\t     copy_rtx (op0)));\n-      return target;\n-    }\n-\n   /* Try negating floating point values by flipping the sign bit.  */\n   if (unoptab->code == NEG && class == MODE_FLOAT\n       && GET_MODE_BITSIZE (mode) <= 2 * HOST_BITS_PER_WIDE_INT)\n@@ -2881,9 +1975,6 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n       return target;\n     }\n \n-  if (class == MODE_VECTOR_FLOAT || class == MODE_VECTOR_INT)\n-    return expand_vector_unop (mode, unoptab, op0, target, unsignedp);\n-\n   /* It can't be done in this mode.  Can we do it in a wider mode?  */\n \n   if (class == MODE_INT || class == MODE_FLOAT || class == MODE_COMPLEX_FLOAT)\n@@ -3116,199 +2207,6 @@ expand_abs (enum machine_mode mode, rtx op0, rtx target,\n   return target;\n }\n \f\n-/* Emit code to compute the absolute value of OP0, with result to\n-   TARGET if convenient.  (TARGET may be 0.)  The return value says\n-   where the result actually is to be found.\n-\n-   MODE is the mode of the operand; the mode of the result is\n-   different but can be deduced from MODE.\n-\n-   UNSIGNEDP is relevant for complex integer modes.  */\n-\n-rtx\n-expand_complex_abs (enum machine_mode mode, rtx op0, rtx target,\n-\t\t    int unsignedp)\n-{\n-  enum mode_class class = GET_MODE_CLASS (mode);\n-  enum machine_mode wider_mode;\n-  rtx temp;\n-  rtx entry_last = get_last_insn ();\n-  rtx last;\n-  rtx pat;\n-  optab this_abs_optab;\n-\n-  /* Find the correct mode for the real and imaginary parts.  */\n-  enum machine_mode submode = GET_MODE_INNER (mode);\n-\n-  if (submode == BLKmode)\n-    abort ();\n-\n-  if (flag_force_mem)\n-    op0 = force_not_mem (op0);\n-\n-  last = get_last_insn ();\n-\n-  this_abs_optab = ! unsignedp && flag_trapv\n-                   && (GET_MODE_CLASS(mode) == MODE_INT)\n-                   ? absv_optab : abs_optab;\n-\n-  if (this_abs_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n-    {\n-      int icode = (int) this_abs_optab->handlers[(int) mode].insn_code;\n-      enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n-      rtx xop0 = op0;\n-\n-      if (target)\n-\ttemp = target;\n-      else\n-\ttemp = gen_reg_rtx (submode);\n-\n-      if (GET_MODE (xop0) != VOIDmode\n-\t  && GET_MODE (xop0) != mode0)\n-\txop0 = convert_to_mode (mode0, xop0, unsignedp);\n-\n-      /* Now, if insn doesn't accept our operand, put it into a pseudo.  */\n-\n-      if (! (*insn_data[icode].operand[1].predicate) (xop0, mode0))\n-\txop0 = copy_to_mode_reg (mode0, xop0);\n-\n-      if (! (*insn_data[icode].operand[0].predicate) (temp, submode))\n-\ttemp = gen_reg_rtx (submode);\n-\n-      pat = GEN_FCN (icode) (temp, xop0);\n-      if (pat)\n-\t{\n-\t  if (INSN_P (pat) && NEXT_INSN (pat) != NULL_RTX\n-\t      && ! add_equal_note (pat, temp, this_abs_optab->code, xop0,\n-\t\t\t\t   NULL_RTX))\n-\t    {\n-\t      delete_insns_since (last);\n-\t      return expand_unop (mode, this_abs_optab, op0, NULL_RTX,\n-\t\t\t\t  unsignedp);\n-\t    }\n-\n-\t  emit_insn (pat);\n-\n-\t  return temp;\n-\t}\n-      else\n-\tdelete_insns_since (last);\n-    }\n-\n-  /* It can't be done in this mode.  Can we open-code it in a wider mode?  */\n-\n-  for (wider_mode = GET_MODE_WIDER_MODE (mode); wider_mode != VOIDmode;\n-       wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n-    {\n-      if (this_abs_optab->handlers[(int) wider_mode].insn_code\n-\t  != CODE_FOR_nothing)\n-\t{\n-\t  rtx xop0 = op0;\n-\n-\t  xop0 = convert_modes (wider_mode, mode, xop0, unsignedp);\n-\t  temp = expand_complex_abs (wider_mode, xop0, NULL_RTX, unsignedp);\n-\n-\t  if (temp)\n-\t    {\n-\t      if (class != MODE_COMPLEX_INT)\n-\t\t{\n-\t\t  if (target == 0)\n-\t\t    target = gen_reg_rtx (submode);\n-\t\t  convert_move (target, temp, 0);\n-\t\t  return target;\n-\t\t}\n-\t      else\n-\t\treturn gen_lowpart (submode, temp);\n-\t    }\n-\t  else\n-\t    delete_insns_since (last);\n-\t}\n-    }\n-\n-  /* Open-code the complex absolute-value operation\n-     if we can open-code sqrt.  Otherwise it's not worth while.  */\n-  if (sqrt_optab->handlers[(int) submode].insn_code != CODE_FOR_nothing\n-      && ! flag_trapv)\n-    {\n-      rtx real, imag, total;\n-\n-      real = gen_realpart (submode, op0);\n-      imag = gen_imagpart (submode, op0);\n-\n-      /* Square both parts.  */\n-      real = expand_mult (submode, real, real, NULL_RTX, 0);\n-      imag = expand_mult (submode, imag, imag, NULL_RTX, 0);\n-\n-      /* Sum the parts.  */\n-      total = expand_binop (submode, add_optab, real, imag, NULL_RTX,\n-\t\t\t    0, OPTAB_LIB_WIDEN);\n-\n-      /* Get sqrt in TARGET.  Set TARGET to where the result is.  */\n-      target = expand_unop (submode, sqrt_optab, total, target, 0);\n-      if (target == 0)\n-\tdelete_insns_since (last);\n-      else\n-\treturn target;\n-    }\n-\n-  /* Now try a library call in this mode.  */\n-  if (this_abs_optab->handlers[(int) mode].libfunc)\n-    {\n-      rtx insns;\n-      rtx value;\n-\n-      start_sequence ();\n-\n-      /* Pass 1 for NO_QUEUE so we don't lose any increments\n-\t if the libcall is cse'd or moved.  */\n-      value = emit_library_call_value (abs_optab->handlers[(int) mode].libfunc,\n-\t\t\t\t       NULL_RTX, LCT_CONST, submode, 1, op0, mode);\n-      insns = get_insns ();\n-      end_sequence ();\n-\n-      target = gen_reg_rtx (submode);\n-      emit_libcall_block (insns, target, value,\n-\t\t\t  gen_rtx_fmt_e (this_abs_optab->code, mode, op0));\n-\n-      return target;\n-    }\n-\n-  /* It can't be done in this mode.  Can we do it in a wider mode?  */\n-\n-  for (wider_mode = GET_MODE_WIDER_MODE (mode); wider_mode != VOIDmode;\n-       wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n-    {\n-      if ((this_abs_optab->handlers[(int) wider_mode].insn_code\n-\t   != CODE_FOR_nothing)\n-\t  || this_abs_optab->handlers[(int) wider_mode].libfunc)\n-\t{\n-\t  rtx xop0 = op0;\n-\n-\t  xop0 = convert_modes (wider_mode, mode, xop0, unsignedp);\n-\n-\t  temp = expand_complex_abs (wider_mode, xop0, NULL_RTX, unsignedp);\n-\n-\t  if (temp)\n-\t    {\n-\t      if (class != MODE_COMPLEX_INT)\n-\t\t{\n-\t\t  if (target == 0)\n-\t\t    target = gen_reg_rtx (submode);\n-\t\t  convert_move (target, temp, 0);\n-\t\t  return target;\n-\t\t}\n-\t      else\n-\t\treturn gen_lowpart (submode, temp);\n-\t    }\n-\t  else\n-\t    delete_insns_since (last);\n-\t}\n-    }\n-\n-  delete_insns_since (entry_last);\n-  return 0;\n-}\n-\f\n /* Generate an instruction whose insn-code is INSN_CODE,\n    with two operands: an output TARGET and an input OP0.\n    TARGET *must* be nonzero, and the output is always stored there.\n@@ -4079,7 +2977,7 @@ prepare_float_lib_cmp (rtx *px, rtx *py, enum rtx_code *pcomparison,\n \t  break;\n \t}\n     }\n- \n+\n   if (mode == VOIDmode)\n     abort ();\n \n@@ -5007,7 +3905,7 @@ expand_fix (rtx to, rtx from, int unsignedp)\n       rtx insns;\n       rtx value;\n       rtx libfunc;\n-      \n+\n       convert_optab tab = unsignedp ? ufix_optab : sfix_optab;\n       libfunc = tab->handlers[GET_MODE (to)][GET_MODE (from)].libfunc;\n       if (!libfunc)\n@@ -5543,11 +4441,11 @@ init_optabs (void)\n   init_floating_libfuncs (unord_optab, \"unord\", '2');\n \n   /* Conversions.  */\n-  init_interclass_conv_libfuncs (sfloat_optab, \"float\", \n+  init_interclass_conv_libfuncs (sfloat_optab, \"float\",\n \t\t\t\t MODE_INT, MODE_FLOAT);\n-  init_interclass_conv_libfuncs (sfix_optab, \"fix\",     \n+  init_interclass_conv_libfuncs (sfix_optab, \"fix\",\n \t\t\t\t MODE_FLOAT, MODE_INT);\n-  init_interclass_conv_libfuncs (ufix_optab, \"fixuns\",  \n+  init_interclass_conv_libfuncs (ufix_optab, \"fixuns\",\n \t\t\t\t MODE_FLOAT, MODE_INT);\n \n   /* sext_optab is also used for FLOAT_EXTEND.  */\n@@ -5613,7 +4511,7 @@ debug_optab_libfuncs (void)\n   int k;\n \n   /* Dump the arithmetic optabs.  */\n-  for (i = 0; i != (int) OTI_MAX; i++) \n+  for (i = 0; i != (int) OTI_MAX; i++)\n     for (j = 0; j < NUM_MACHINE_MODES; ++j)\n       {\n \toptab o;\n@@ -5625,7 +4523,7 @@ debug_optab_libfuncs (void)\n \t  {\n \t    if (GET_CODE (h->libfunc) != SYMBOL_REF)\n \t      abort ();\n-\t    fprintf (stderr, \"%s\\t%s:\\t%s\\n\", \n+\t    fprintf (stderr, \"%s\\t%s:\\t%s\\n\",\n \t\t     GET_RTX_NAME (o->code),\n \t\t     GET_MODE_NAME (j),\n \t\t     XSTR (h->libfunc, 0));\n@@ -5646,7 +4544,7 @@ debug_optab_libfuncs (void)\n \t    {\n \t      if (GET_CODE (h->libfunc) != SYMBOL_REF)\n \t\tabort ();\n-\t      fprintf (stderr, \"%s\\t%s\\t%s:\\t%s\\n\", \n+\t      fprintf (stderr, \"%s\\t%s\\t%s:\\t%s\\n\",\n \t\t       GET_RTX_NAME (o->code),\n \t\t       GET_MODE_NAME (j),\n \t\t       GET_MODE_NAME (k),"}, {"sha": "7cf0f9a238a8759d79aac58aacfb5aba2f7c313d", "filename": "gcc/optabs.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5906d0133520f77a2220aa61abe2ad428ac09e8f/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5906d0133520f77a2220aa61abe2ad428ac09e8f/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=5906d0133520f77a2220aa61abe2ad428ac09e8f", "patch": "@@ -419,7 +419,7 @@ extern int expand_twoval_binop (optab, rtx, rtx, rtx, rtx, int);\n \n /* Generate code to perform an operation on two operands with two\n    results, using a library function.  */\n-extern bool expand_twoval_binop_libfunc (optab, rtx, rtx, rtx, rtx, \n+extern bool expand_twoval_binop_libfunc (optab, rtx, rtx, rtx, rtx,\n \t\t\t\t\t enum rtx_code);\n \n /* Expand a unary arithmetic operation given optab rtx operand.  */\n@@ -429,9 +429,6 @@ extern rtx expand_unop (enum machine_mode, optab, rtx, rtx, int);\n extern rtx expand_abs_nojump (enum machine_mode, rtx, rtx, int);\n extern rtx expand_abs (enum machine_mode, rtx, rtx, int, int);\n \n-/* Expand the complex absolute value operation.  */\n-extern rtx expand_complex_abs (enum machine_mode, rtx, rtx, int);\n-\n /* Generate an instruction with a given INSN_CODE with an output and\n    an input.  */\n extern void emit_unop_insn (int, rtx, rtx, enum rtx_code);"}]}