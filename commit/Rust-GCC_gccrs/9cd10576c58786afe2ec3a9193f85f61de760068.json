{"sha": "9cd10576c58786afe2ec3a9193f85f61de760068", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWNkMTA1NzZjNTg3ODZhZmUyZWMzYTkxOTNmODVmNjFkZTc2MDA2OA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2002-09-19T13:51:24Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-09-19T13:51:24Z"}, "message": "fp-bit.c: Follow spelling conventions.\n\n\t* config/fp-bit.c: Follow spelling conventions.\n\t* config/d30v/d30v.c: Likewise.\n\t* config/d30v/d30v.h: Likewise.\n\t* config/fr30/fr30.c: Likewise.\n\t* config/fr30/fr30.h: Likewise.\n\t* config/fr30/fr30.md: Likewise.\n\t* config/frv/frv.c: Likewise.\n\t* config/frv/frv.h: Likewise.\n\t* config/h8300/h8300.c: Likewise.\n\t* config/h8300/lib1funcs.asm: Likewise.\n\t* config/i370/i370.c: Likewise.\n\t* config/i386/i386.h: Likewise.\n\t* config/i386/i386.md: Likewise.\n\t* config/i386/pentium.md: Likewise.\n\t* config/i386/winnt.c: Likewise.\n\t* config/i960/i960.c: Likewise.\n\t* config/ia64/ia64.h: Likewise.\n\t* config/ip2k/ip2k.c: Likewise.\n\t* config/ip2k/ip2k.h: Likewise.\n\t* config/ip2k/ip2k.md: Likewise.\n\t* config/ip2k/libgcc.S: Likewise.\n\nFrom-SVN: r57303", "tree": {"sha": "ccfaa90cab6055a4c2d86909f94576ffc123b5ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ccfaa90cab6055a4c2d86909f94576ffc123b5ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9cd10576c58786afe2ec3a9193f85f61de760068", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cd10576c58786afe2ec3a9193f85f61de760068", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9cd10576c58786afe2ec3a9193f85f61de760068", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cd10576c58786afe2ec3a9193f85f61de760068/comments", "author": null, "committer": null, "parents": [{"sha": "fff08fd8dad02e4b83e37555da6acd2693ae3db7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fff08fd8dad02e4b83e37555da6acd2693ae3db7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fff08fd8dad02e4b83e37555da6acd2693ae3db7"}], "stats": {"total": 168, "additions": 96, "deletions": 72}, "files": [{"sha": "7414b3c4a57fa05ccf353e58d4bdf41ff2c56fa2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd10576c58786afe2ec3a9193f85f61de760068/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd10576c58786afe2ec3a9193f85f61de760068/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9cd10576c58786afe2ec3a9193f85f61de760068", "patch": "@@ -1,3 +1,27 @@\n+2002-09-19  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config/fp-bit.c: Follow spelling conventions.\n+\t* config/d30v/d30v.c: Likewise.\n+\t* config/d30v/d30v.h: Likewise.\n+\t* config/fr30/fr30.c: Likewise.\n+\t* config/fr30/fr30.h: Likewise.\n+\t* config/fr30/fr30.md: Likewise.\n+\t* config/frv/frv.c: Likewise.\n+\t* config/frv/frv.h: Likewise.\n+\t* config/h8300/h8300.c: Likewise.\n+\t* config/h8300/lib1funcs.asm: Likewise.\n+\t* config/i370/i370.c: Likewise.\n+\t* config/i386/i386.h: Likewise.\n+\t* config/i386/i386.md: Likewise.\n+\t* config/i386/pentium.md: Likewise.\n+\t* config/i386/winnt.c: Likewise.\n+\t* config/i960/i960.c: Likewise.\n+\t* config/ia64/ia64.h: Likewise.\n+\t* config/ip2k/ip2k.c: Likewise.\n+\t* config/ip2k/ip2k.h: Likewise.\n+\t* config/ip2k/ip2k.md: Likewise.\n+\t* config/ip2k/libgcc.S: Likewise.\n+\n 2002-09-19  Stephen Clarke <stephen.clarke@superh.com>\n \n \t* config/sh/sh.h (UNSPEC_GOTOFF_P): Define.\n@@ -70,7 +94,7 @@\n \n 2002-09-18  Kazu Hirata  <kazu@cs.umass.edu>\n \n-\t* config/s390/s390.c: Follow spelling convention.\n+\t* config/s390/s390.c: Follow spelling conventions.\n \t* config/sh/lib1funcs.asm: Likewise.\n \t* config/sh/sh.c: Likewise.\n \t* config/sh/sh.h: Likewise."}, {"sha": "8169d8ebd4f018b2d2ca929cc09735c8760416ee", "filename": "gcc/config/d30v/d30v.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd10576c58786afe2ec3a9193f85f61de760068/gcc%2Fconfig%2Fd30v%2Fd30v.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd10576c58786afe2ec3a9193f85f61de760068/gcc%2Fconfig%2Fd30v%2Fd30v.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fd30v%2Fd30v.c?ref=9cd10576c58786afe2ec3a9193f85f61de760068", "patch": "@@ -1867,7 +1867,7 @@ debug_stack_info (info)\n }\n \n \f\n-/* Return non-zero if this function is known to have a null or 1 instruction epilogue.  */\n+/* Return nonzero if this function is known to have a null or 1 instruction epilogue.  */\n \n int\n direct_return ()\n@@ -1985,7 +1985,7 @@ d30v_function_arg_boundary (mode, type)\n    You may use the macro `MUST_PASS_IN_STACK (MODE, TYPE)' in the definition of\n    this macro to determine if this argument is of a type that must be passed in\n    the stack.  If `REG_PARM_STACK_SPACE' is not defined and `FUNCTION_ARG'\n-   returns non-zero for such an argument, the compiler will abort.  If\n+   returns nonzero for such an argument, the compiler will abort.  If\n    `REG_PARM_STACK_SPACE' is defined, the argument will be computed in the\n    stack and then loaded into a register.  */\n "}, {"sha": "6045d906059964e0e642dc8872d9f920cacd7d3f", "filename": "gcc/config/d30v/d30v.h", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd10576c58786afe2ec3a9193f85f61de760068/gcc%2Fconfig%2Fd30v%2Fd30v.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd10576c58786afe2ec3a9193f85f61de760068/gcc%2Fconfig%2Fd30v%2Fd30v.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fd30v%2Fd30v.h?ref=9cd10576c58786afe2ec3a9193f85f61de760068", "patch": "@@ -880,7 +880,7 @@ extern enum reg_class reg_class_from_letter[256];\n \n /* Certain machines have the property that some registers cannot be copied to\n    some other registers without using memory.  Define this macro on those\n-   machines to be a C expression that is non-zero if objects of mode M in\n+   machines to be a C expression that is nonzero if objects of mode M in\n    registers of CLASS1 can only be copied to registers of class CLASS2 by\n    storing a register of CLASS1 into memory and loading that memory location\n    into a register of CLASS2.\n@@ -923,15 +923,15 @@ extern enum reg_class reg_class_from_letter[256];\n    few registers of certain classes that there would not be enough registers to\n    use as spill registers if this were done.\n \n-   Define `SMALL_REGISTER_CLASSES' to be an expression with a non-zero value on\n-   these machines.  When this macro has a non-zero value, the compiler allows\n+   Define `SMALL_REGISTER_CLASSES' to be an expression with a nonzero value on\n+   these machines.  When this macro has a nonzero value, the compiler allows\n    registers explicitly used in the rtl to be used as spill registers but\n    avoids extending the lifetime of these registers.\n \n-   It is always safe to define this macro with a non-zero value, but if you\n+   It is always safe to define this macro with a nonzero value, but if you\n    unnecessarily define it, you will reduce the amount of optimizations that\n    can be performed in some cases.  If you do not define this macro with a\n-   non-zero value when it is required, the compiler will run out of spill\n+   nonzero value when it is required, the compiler will run out of spill\n    registers and print a fatal error message.  For most machines, you should\n    not define this macro at all.  */\n /* #define SMALL_REGISTER_CLASSES */\n@@ -1355,7 +1355,7 @@ typedef struct d30v_stack {\n   { FRAME_POINTER_REGNUM,\tSTACK_POINTER_REGNUM }\t\t\t\\\n }\n \n-/* A C expression that returns non-zero if the compiler is allowed to try to\n+/* A C expression that returns nonzero if the compiler is allowed to try to\n    replace register number FROM-REG with register number TO-REG.  This macro\n    need only be defined if `ELIMINABLE_REGS' is defined, and will usually be\n    the constant 1, since most of the cases preventing register elimination are\n@@ -1535,7 +1535,7 @@ typedef struct d30v_stack {\n    You may use the macro `MUST_PASS_IN_STACK (MODE, TYPE)' in the definition of\n    this macro to determine if this argument is of a type that must be passed in\n    the stack.  If `REG_PARM_STACK_SPACE' is not defined and `FUNCTION_ARG'\n-   returns non-zero for such an argument, the compiler will abort.  If\n+   returns nonzero for such an argument, the compiler will abort.  If\n    `REG_PARM_STACK_SPACE' is defined, the argument will be computed in the\n    stack and then loaded into a register.  */\n \n@@ -2007,7 +2007,7 @@ typedef struct machine_function GTY(())\n   (VALIST) = d30v_build_va_list ()\n \n \n-/* Implement the stdarg/varargs va_start macro.  STDARG_P is non-zero if this\n+/* Implement the stdarg/varargs va_start macro.  STDARG_P is nonzero if this\n    is stdarg.h instead of varargs.h.  VALIST is the tree of the va_list\n    variable to initialize.  NEXTARG is the machine independent notion of the\n    'next' argument after the variable arguments.  If not defined, a standard\n@@ -2610,10 +2610,10 @@ extern const char *d30v_branch_cost_string;\n    times greater than aligned accesses, for example if they are emulated in a\n    trap handler.\n \n-   When this macro is non-zero, the compiler will act as if `STRICT_ALIGNMENT'\n-   were non-zero when generating code for block moves.  This can cause\n+   When this macro is nonzero, the compiler will act as if `STRICT_ALIGNMENT'\n+   were nonzero when generating code for block moves.  This can cause\n    significantly more instructions to be produced.  Therefore, do not set this\n-   macro non-zero if unaligned accesses only add a cycle or two to the time for\n+   macro nonzero if unaligned accesses only add a cycle or two to the time for\n    a memory access.\n \n    If the value of this macro is always zero, it need not be defined.  */\n@@ -2821,7 +2821,7 @@ extern const char *d30v_branch_cost_string;\n /* #define ASM_OUTPUT_ASCII(STREAM, PTR, LEN) */\n \n /* You may define this macro as a C expression.  You should define the\n-   expression to have a non-zero value if GNU CC should output the\n+   expression to have a nonzero value if GNU CC should output the\n    constant pool for a function before the code for the function, or\n    a zero value if GNU CC should output the constant pool after the\n    function.  If you do not define this macro, the usual case, GNU CC\n@@ -4123,7 +4123,7 @@ fprintf (STREAM, \"\\t.word .L%d\\n\", VALUE)\n /* A C expression that is nonzero if on this machine the number of bits\n    actually used for the count of a shift operation is equal to the number of\n    bits needed to represent the size of the object being shifted.  When this\n-   macro is non-zero, the compiler will assume that it is safe to omit a\n+   macro is nonzero, the compiler will assume that it is safe to omit a\n    sign-extend, zero-extend, and certain bitwise `and' instructions that\n    truncates the count of a shift operation.  On machines that have\n    instructions that act on bitfields at variable positions, which may include\n@@ -4234,7 +4234,7 @@ fprintf (STREAM, \"\\t.word .L%d\\n\", VALUE)\n    instructions.  */\n /* #define STORE_FLAG_VALUE */\n \n-/* A C expression that gives a non-zero floating point value that is returned\n+/* A C expression that gives a nonzero floating point value that is returned\n    when comparison operators with floating-point results are true.  Define this\n    macro on machine that have comparison operations that return floating-point\n    values.  If there are no such operations, do not define this macro.  */"}, {"sha": "eef3a66d74cec36450041185533b8e4499859e81", "filename": "gcc/config/fp-bit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd10576c58786afe2ec3a9193f85f61de760068/gcc%2Fconfig%2Ffp-bit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd10576c58786afe2ec3a9193f85f61de760068/gcc%2Fconfig%2Ffp-bit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffp-bit.c?ref=9cd10576c58786afe2ec3a9193f85f61de760068", "patch": "@@ -46,7 +46,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"tconfig.h\"\n #include \"fp-bit.h\"\n \n-/* The following macros can be defined to change the behaviour of this file:\n+/* The following macros can be defined to change the behavior of this file:\n    FLOAT: Implement a `float', aka SFmode, fp library.  If this is not\n      defined, then this file implements a `double', aka DFmode, fp library.\n    FLOAT_ONLY: Used with FLOAT, to implement a `float' only library, i.e."}, {"sha": "0298e7519f056471c508f66e02d71252d1d98008", "filename": "gcc/config/fr30/fr30.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd10576c58786afe2ec3a9193f85f61de760068/gcc%2Fconfig%2Ffr30%2Ffr30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd10576c58786afe2ec3a9193f85f61de760068/gcc%2Fconfig%2Ffr30%2Ffr30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.c?ref=9cd10576c58786afe2ec3a9193f85f61de760068", "patch": "@@ -89,7 +89,7 @@ struct rtx_def * fr30_compare_op1;\n                                    SP ->|                       |  /  \n                                         +-----------------------+    \n    \n-   Note, AP is a fake hard register.  It will be eliminated in favour of\n+   Note, AP is a fake hard register.  It will be eliminated in favor of\n    SP or FP as appropriate.\n \n    Note, Some or all of the stack sections above may be omitted if they "}, {"sha": "fe22224a73ff34e3733b051c3e544d7564e6b1eb", "filename": "gcc/config/fr30/fr30.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd10576c58786afe2ec3a9193f85f61de760068/gcc%2Fconfig%2Ffr30%2Ffr30.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd10576c58786afe2ec3a9193f85f61de760068/gcc%2Fconfig%2Ffr30%2Ffr30.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.h?ref=9cd10576c58786afe2ec3a9193f85f61de760068", "patch": "@@ -586,7 +586,7 @@ enum reg_class\n   {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}\t\\\n }\n \n-/* A C expression that returns non-zero if the compiler is allowed to try to\n+/* A C expression that returns nonzero if the compiler is allowed to try to\n    replace register number FROM with register number TO.  This macro\n    need only be defined if `ELIMINABLE_REGS' is defined, and will usually be\n    the constant 1, since most of the cases preventing register elimination are\n@@ -695,7 +695,7 @@ enum reg_class\n    You may use the macro `MUST_PASS_IN_STACK (MODE, TYPE)' in the definition of\n    this macro to determine if this argument is of a type that must be passed in\n    the stack.  If `REG_PARM_STACK_SPACE' is not defined and `FUNCTION_ARG'\n-   returns non-zero for such an argument, the compiler will abort.  If\n+   returns nonzero for such an argument, the compiler will abort.  If\n    `REG_PARM_STACK_SPACE' is defined, the argument will be computed in the\n    stack and then loaded into a register.  */\n      "}, {"sha": "b78e99d96a11bf493a70c8c3e56d3c9ba11f5983", "filename": "gcc/config/fr30/fr30.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd10576c58786afe2ec3a9193f85f61de760068/gcc%2Fconfig%2Ffr30%2Ffr30.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd10576c58786afe2ec3a9193f85f61de760068/gcc%2Fconfig%2Ffr30%2Ffr30.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.md?ref=9cd10576c58786afe2ec3a9193f85f61de760068", "patch": "@@ -676,7 +676,7 @@\n )\n \n ;; Do not allow an eliminable register in the source register.  It\n-;; might be eliminated in favour of the stack pointer, probably\n+;; might be eliminated in favor of the stack pointer, probably\n ;; increasing the offset, and so rendering the instruction illegal.\n (define_insn \"addsi_small_int\"\n   [(set (match_operand:SI 0 \"register_operand\"              \"=r,r\")"}, {"sha": "1b6f37b493402a0a8a83f76d7728d73c63afe1f0", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd10576c58786afe2ec3a9193f85f61de760068/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd10576c58786afe2ec3a9193f85f61de760068/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=9cd10576c58786afe2ec3a9193f85f61de760068", "patch": "@@ -595,7 +595,7 @@ frv_override_options ()\n    LEVEL is the optimization level specified; 2 if `-O2' is specified, 1 if\n    `-O' is specified, and 0 if neither is specified.\n \n-   SIZE is non-zero if `-Os' is specified, 0 otherwise.\n+   SIZE is nonzero if `-Os' is specified, 0 otherwise.\n \n    You should not use this macro to change options that are not\n    machine-specific.  These should uniformly selected by the same optimization\n@@ -3139,7 +3139,7 @@ frv_function_arg_boundary (mode, type)\n    You may use the macro `MUST_PASS_IN_STACK (MODE, TYPE)' in the definition of\n    this macro to determine if this argument is of a type that must be passed in\n    the stack.  If `REG_PARM_STACK_SPACE' is not defined and `FUNCTION_ARG'\n-   returns non-zero for such an argument, the compiler will abort.  If\n+   returns nonzero for such an argument, the compiler will abort.  If\n    `REG_PARM_STACK_SPACE' is defined, the argument will be computed in the\n    stack and then loaded into a register.  */\n \n@@ -6417,7 +6417,7 @@ frv_split_minmax (operands)\n \t\t\t\t\t  cc_reg,\n \t\t\t\t\t  const0_rtx)));\n \n-  /* If are taking the min/max of a non-zero constant, load that first, and\n+  /* If are taking the min/max of a nonzero constant, load that first, and\n      then do a conditional move of the other value.  */\n   if (GET_CODE (src2) == CONST_INT && INTVAL (src2) != 0)\n     {\n@@ -7705,7 +7705,7 @@ frv_secondary_reload_class (class, mode, x, in_p)\n \t}\n       break;\n \n-      /* Non-zero constants should be loaded into an FPR through a GPR.  */\n+      /* Nonzero constants should be loaded into an FPR through a GPR.  */\n     case QUAD_FPR_REGS:\n     case FEVEN_REGS:\n     case FPR_REGS:"}, {"sha": "d0eb6508f670c7bbab0799d5088affd372e8f8af", "filename": "gcc/config/frv/frv.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd10576c58786afe2ec3a9193f85f61de760068/gcc%2Fconfig%2Ffrv%2Ffrv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd10576c58786afe2ec3a9193f85f61de760068/gcc%2Fconfig%2Ffrv%2Ffrv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.h?ref=9cd10576c58786afe2ec3a9193f85f61de760068", "patch": "@@ -530,7 +530,7 @@ extern int target_flags;\n    LEVEL is the optimization level specified; 2 if `-O2' is specified, 1 if\n    `-O' is specified, and 0 if neither is specified.\n \n-   SIZE is non-zero if `-Os' is specified, 0 otherwise.\n+   SIZE is nonzero if `-Os' is specified, 0 otherwise.\n \n    You should not use this macro to change options that are not\n    machine-specific.  These should uniformly selected by the same optimization\n@@ -1776,7 +1776,7 @@ struct machine_function GTY(())\n   {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}\t\t\t\t\\\n }\n \n-/* A C expression that returns non-zero if the compiler is allowed to try to\n+/* A C expression that returns nonzero if the compiler is allowed to try to\n    replace register number FROM with register number TO.  This macro need only\n    be defined if `ELIMINABLE_REGS' is defined, and will usually be the constant\n    1, since most of the cases preventing register elimination are things that\n@@ -1892,7 +1892,7 @@ struct machine_function GTY(())\n    You may use the macro `MUST_PASS_IN_STACK (MODE, TYPE)' in the definition of\n    this macro to determine if this argument is of a type that must be passed in\n    the stack.  If `REG_PARM_STACK_SPACE' is not defined and `FUNCTION_ARG'\n-   returns non-zero for such an argument, the compiler will abort.  If\n+   returns nonzero for such an argument, the compiler will abort.  If\n    `REG_PARM_STACK_SPACE' is defined, the argument will be computed in the\n    stack and then loaded into a register.  */\n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)                    \\\n@@ -2202,7 +2202,7 @@ frv_asm_output_mi_thunk (FILE, THUNK_FNDECL, (long)DELTA, FUNCTION)\n   frv_setup_incoming_varargs (& ARGS_SO_FAR, (int) MODE, TYPE, \t\\\n \t\t\t      & PRETEND_ARGS_SIZE, SECOND_TIME)\n \n-/* Implement the stdarg/varargs va_start macro.  STDARG_P is non-zero if this\n+/* Implement the stdarg/varargs va_start macro.  STDARG_P is nonzero if this\n    is stdarg.h instead of varargs.h.  VALIST is the tree of the va_list\n    variable to initialize.  NEXTARG is the machine independent notion of the\n    'next' argument after the variable arguments.  If not defined, a standard"}, {"sha": "9e3b1d1238e1631c31aad26f75ed714c8f9bc52a", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd10576c58786afe2ec3a9193f85f61de760068/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd10576c58786afe2ec3a9193f85f61de760068/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=9cd10576c58786afe2ec3a9193f85f61de760068", "patch": "@@ -2366,11 +2366,11 @@ struct shift_info {\n   const char *special;\n \n   /* Insn for a one-bit shift.  Valid when ALG is either SHIFT_INLINE\n-     or SHIFT_SPECIAL, and REMAINDER is non-zero.  */\n+     or SHIFT_SPECIAL, and REMAINDER is nonzero.  */\n   const char *shift1;\n \n   /* Insn for a two-bit shift.  Valid when ALG is either SHIFT_INLINE\n-     or SHIFT_SPECIAL, and REMAINDER is non-zero.  */\n+     or SHIFT_SPECIAL, and REMAINDER is nonzero.  */\n   const char *shift2;\n \n   /* Valid CC flags.  */\n@@ -3206,7 +3206,7 @@ expand_a_rotate (code, operands)\n       tmp = gen_rtx_PLUS (QImode, counter, GEN_INT (-1));\n       emit_insn (gen_rtx_SET (VOIDmode, counter, tmp));\n \n-      /* If the loop counter is non-zero, we go back to the beginning\n+      /* If the loop counter is nonzero, we go back to the beginning\n \t of the loop.  */\n       emit_cmp_and_jump_insns (counter, GEN_INT (0), NE, NULL_RTX, QImode, 1,\n \t\t\t       start_label);"}, {"sha": "734b25d79927e3caa9529bec69e49aeb9df55491", "filename": "gcc/config/h8300/lib1funcs.asm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd10576c58786afe2ec3a9193f85f61de760068/gcc%2Fconfig%2Fh8300%2Flib1funcs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd10576c58786afe2ec3a9193f85f61de760068/gcc%2Fconfig%2Fh8300%2Flib1funcs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Flib1funcs.asm?ref=9cd10576c58786afe2ec3a9193f85f61de760068", "patch": "@@ -775,7 +775,7 @@ L_skip2:\n    space.  For the H8/300H and H8S, the C version is good enough.  */\n #ifdef __H8300__\n /* We still treat NANs different than libgcc2.c, but then, the\n-   behaviour is undefined anyways.  */\n+   behavior is undefined anyways.  */\n \t.global\t___fixunssfsi\n ___fixunssfsi:\n \tcmp.b #0x47,r0h"}, {"sha": "92d2795691ecb10067cdc46ffda936aa3cb9015f", "filename": "gcc/config/i370/i370.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd10576c58786afe2ec3a9193f85f61de760068/gcc%2Fconfig%2Fi370%2Fi370.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd10576c58786afe2ec3a9193f85f61de760068/gcc%2Fconfig%2Fi370%2Fi370.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.c?ref=9cd10576c58786afe2ec3a9193f85f61de760068", "patch": "@@ -1444,7 +1444,7 @@ i370_globalize_label (stream, name)\n    -- subtracts stackframe size from the stack pointer.\n    -- stores backpointer to old caller stack.\n   \n-   XXX hack alert -- if the global var int leaf_function is non-zero, \n+   XXX hack alert -- if the global var int leaf_function is nonzero, \n    then this is a leaf, and it might be possible to optimize the prologue\n    into doing even less, e.g. not grabbing a new stackframe or maybe just a\n    partial stack frame."}, {"sha": "2d46a9f446ae3b3cc2c504564070f35d9b6c478f", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd10576c58786afe2ec3a9193f85f61de760068/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd10576c58786afe2ec3a9193f85f61de760068/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=9cd10576c58786afe2ec3a9193f85f61de760068", "patch": "@@ -786,7 +786,7 @@ extern int x86_prefetch_sse;\n #define FUNCTION_ARG_BOUNDARY(MODE, TYPE) \\\n   ix86_function_arg_boundary ((MODE), (TYPE))\n \n-/* Set this non-zero if move instructions will actually fail to work\n+/* Set this nonzero if move instructions will actually fail to work\n    when given unaligned data.  */\n #define STRICT_ALIGNMENT 0\n \n@@ -2828,10 +2828,10 @@ do {\t\t\t\t\t\t\t\\\n    cost many times greater than aligned accesses, for example if they\n    are emulated in a trap handler.\n \n-   When this macro is non-zero, the compiler will act as if\n-   `STRICT_ALIGNMENT' were non-zero when generating code for block\n+   When this macro is nonzero, the compiler will act as if\n+   `STRICT_ALIGNMENT' were nonzero when generating code for block\n    moves.  This can cause significantly more instructions to be\n-   produced.  Therefore, do not set this macro non-zero if unaligned\n+   produced.  Therefore, do not set this macro nonzero if unaligned\n    accesses only add a cycle or two to the time for a memory access.\n \n    If the value of this macro is always zero, it need not be defined.  */\n@@ -2869,7 +2869,7 @@ do {\t\t\t\t\t\t\t\\\n \n #define SELECT_CC_MODE(OP, X, Y) ix86_cc_mode ((OP), (X), (Y))\n \n-/* Return non-zero if MODE implies a floating point inequality can be\n+/* Return nonzero if MODE implies a floating point inequality can be\n    reversed.  */\n \n #define REVERSIBLE_CC_MODE(MODE) 1"}, {"sha": "eb74fb555854fa1bab818a4f5dd39e96099e090e", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd10576c58786afe2ec3a9193f85f61de760068/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd10576c58786afe2ec3a9193f85f61de760068/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=9cd10576c58786afe2ec3a9193f85f61de760068", "patch": "@@ -7248,7 +7248,7 @@\n \t      (use (match_dup 3))\n \t      (clobber (reg:CC 17))])]\n {\n-  /* Avoid use of cltd in favour of a mov+shift.  */\n+  /* Avoid use of cltd in favor of a mov+shift.  */\n   if (!TARGET_USE_CLTD && !optimize_size)\n     {\n       if (true_regnum (operands[1]))\n@@ -7333,7 +7333,7 @@\n \t      (use (match_dup 3))\n \t      (clobber (reg:CC 17))])]\n {\n-  /* Avoid use of cltd in favour of a mov+shift.  */\n+  /* Avoid use of cltd in favor of a mov+shift.  */\n   if (!TARGET_USE_CLTD && !optimize_size)\n     {\n       if (true_regnum (operands[1]))\n@@ -16564,7 +16564,7 @@\n ;; cmpCC op0, op4   -  set op0 to 0 or ffffffff depending on the comparison\n ;; and   op2, op0   -  zero op2 if comparison was false\n ;; nand  op0, op3   -  load op3 to op0 if comparison was false\n-;; or\t op2, op0   -  get the non-zero one into the result.\n+;; or\t op2, op0   -  get the nonzero one into the result.\n (define_split\n   [(set (match_operand 0 \"register_operand\" \"\")\n \t(if_then_else (match_operator 1 \"sse_comparison_operator\""}, {"sha": "40789558458a38f1548500780548f0d7e8c90bd3", "filename": "gcc/config/i386/pentium.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd10576c58786afe2ec3a9193f85f61de760068/gcc%2Fconfig%2Fi386%2Fpentium.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd10576c58786afe2ec3a9193f85f61de760068/gcc%2Fconfig%2Fi386%2Fpentium.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpentium.md?ref=9cd10576c58786afe2ec3a9193f85f61de760068", "patch": "@@ -77,7 +77,7 @@\n ;;            |\n ;;           fpu\n ;; We add dummy \"port\" pipes allocated only first cycle of\n-;; instruction to specify this behaviour.\n+;; instruction to specify this behavior.\n \n (define_cpu_unit \"pentium-portu,pentium-portv\" \"pentium\")\n (define_cpu_unit \"pentium-u,pentium-v\" \"pentium\")"}, {"sha": "f6417aa30bff7586773492b32802f69a3a15715d", "filename": "gcc/config/i386/winnt.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd10576c58786afe2ec3a9193f85f61de760068/gcc%2Fconfig%2Fi386%2Fwinnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd10576c58786afe2ec3a9193f85f61de760068/gcc%2Fconfig%2Fi386%2Fwinnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwinnt.c?ref=9cd10576c58786afe2ec3a9193f85f61de760068", "patch": "@@ -135,7 +135,7 @@ associated_type (decl)\n   return t;\n }\n \n-/* Return non-zero if DECL is a dllexport'd object.  */\n+/* Return nonzero if DECL is a dllexport'd object.  */\n \n int\n i386_pe_dllexport_p (decl)\n@@ -162,7 +162,7 @@ i386_pe_dllexport_p (decl)\n   return 0;\n }\n \n-/* Return non-zero if DECL is a dllimport'd object.  */\n+/* Return nonzero if DECL is a dllimport'd object.  */\n \n int\n i386_pe_dllimport_p (decl)\n@@ -193,7 +193,7 @@ i386_pe_dllimport_p (decl)\n   return 0;\n }\n \n-/* Return non-zero if SYMBOL is marked as being dllexport'd.  */\n+/* Return nonzero if SYMBOL is marked as being dllexport'd.  */\n \n int\n i386_pe_dllexport_name_p (symbol)\n@@ -202,7 +202,7 @@ i386_pe_dllexport_name_p (symbol)\n   return symbol[0] == '@' && symbol[1] == 'e' && symbol[2] == '.';\n }\n \n-/* Return non-zero if SYMBOL is marked as being dllimport'd.  */\n+/* Return nonzero if SYMBOL is marked as being dllimport'd.  */\n \n int\n i386_pe_dllimport_name_p (symbol)\n@@ -583,7 +583,7 @@ i386_pe_asm_named_section (name, flags)\n /* Mark a function appropriately.  This should only be called for\n    functions for which we are not emitting COFF debugging information.\n    FILE is the assembler output file, NAME is the name of the\n-   function, and PUBLIC is non-zero if the function is globally\n+   function, and PUBLIC is nonzero if the function is globally\n    visible.  */\n \n void"}, {"sha": "7ebbb9efa179945cdd5602ccdc5e1419ec888568", "filename": "gcc/config/i960/i960.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd10576c58786afe2ec3a9193f85f61de760068/gcc%2Fconfig%2Fi960%2Fi960.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd10576c58786afe2ec3a9193f85f61de760068/gcc%2Fconfig%2Fi960%2Fi960.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.c?ref=9cd10576c58786afe2ec3a9193f85f61de760068", "patch": "@@ -321,8 +321,8 @@ bitpos (val)\n   return -1;\n }\n \n-/* Return non-zero if OP is a mask, i.e. all one bits are consecutive.\n-   The return value indicates how many consecutive non-zero bits exist\n+/* Return nonzero if OP is a mask, i.e. all one bits are consecutive.\n+   The return value indicates how many consecutive nonzero bits exist\n    if this is a mask.  This is the same as the next function, except that\n    it does not indicate what the start and stop bit positions are.  */\n "}, {"sha": "458e253592cd14b1662ae2737679e07fc72d5828", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd10576c58786afe2ec3a9193f85f61de760068/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd10576c58786afe2ec3a9193f85f61de760068/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=9cd10576c58786afe2ec3a9193f85f61de760068", "patch": "@@ -346,7 +346,7 @@ while (0)\n #define TARGET_FLOAT_FORMAT IEEE_FLOAT_FORMAT\n \n /* By default, the C++ compiler will use function addresses in the\n-   vtable entries.  Setting this non-zero tells the compiler to use\n+   vtable entries.  Setting this nonzero tells the compiler to use\n    function descriptors instead.  The value of this macro says how\n    many words wide the descriptor is (normally 2).  It is assumed\n    that the address of a function descriptor may be treated as a\n@@ -973,7 +973,7 @@ enum reg_class\n \n /* Certain machines have the property that some registers cannot be copied to\n    some other registers without using memory.  Define this macro on those\n-   machines to be a C expression that is non-zero if objects of mode M in\n+   machines to be a C expression that is nonzero if objects of mode M in\n    registers of CLASS1 can only be copied to registers of class CLASS2 by\n    storing a register of CLASS1 into memory and loading that memory location\n    into a register of CLASS2.  */\n@@ -1203,7 +1203,7 @@ enum reg_class\n   {RETURN_ADDRESS_POINTER_REGNUM, BR_REG (0)},\t\t\t\t\\\n }\n \n-/* A C expression that returns non-zero if the compiler is allowed to try to\n+/* A C expression that returns nonzero if the compiler is allowed to try to\n    replace register number FROM with register number TO.  The frame pointer\n    is automatically handled.  */\n "}, {"sha": "7730ee4438f6d5c9655b5c547d9dd19a2a24ae22", "filename": "gcc/config/ip2k/ip2k.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd10576c58786afe2ec3a9193f85f61de760068/gcc%2Fconfig%2Fip2k%2Fip2k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd10576c58786afe2ec3a9193f85f61de760068/gcc%2Fconfig%2Fip2k%2Fip2k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fip2k%2Fip2k.c?ref=9cd10576c58786afe2ec3a9193f85f61de760068", "patch": "@@ -158,7 +158,7 @@ ip2k_return_pops_args (fundecl, funtype, size)\n   return 0;\n }\n \n-/* Return non-zero if FUNC is a naked function.  */\n+/* Return nonzero if FUNC is a naked function.  */\n \n static int\n ip2k_naked_function_p (func)\n@@ -1728,7 +1728,7 @@ ip2k_gen_unsigned_comp_branch (insn, code, label)\n           goto zero;\n \n         case GTU:\t\t\t\n-          code = NE;\t\t\t/* Anything non-zero is GTU.  */\n+          code = NE;\t\t\t/* Anything nonzero is GTU.  */\n           /* fall-thru  */\n \n         case EQ:\n@@ -4118,7 +4118,7 @@ mdr_try_move_dp_reload (first_insn)\n #endif /* IP2K_MD_REORG_PASS */\n \n /* Look to see if the expression, x, can have any stack references offset by\n-   a fixed constant, offset.  If it definitely can then returns non-zero.  */\n+   a fixed constant, offset.  If it definitely can then returns nonzero.  */\n \n static int\n ip2k_check_can_adjust_stack_ref (x, offset)\n@@ -4657,7 +4657,7 @@ mdr_try_propagate_clr (first_insn)\n \n /* Look to see if the expression, x, does not make any memory references\n    via the specified register.  This is very conservative and only returns\n-   non-zero if we definitely don't have such a memory ref.  */\n+   nonzero if we definitely don't have such a memory ref.  */\n \n static int\n ip2k_xexp_not_uses_reg_for_mem (x, regno)"}, {"sha": "2f5cfbc1ffc55df98f8ff2c95fb93fd575b9e0cd", "filename": "gcc/config/ip2k/ip2k.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd10576c58786afe2ec3a9193f85f61de760068/gcc%2Fconfig%2Fip2k%2Fip2k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd10576c58786afe2ec3a9193f85f61de760068/gcc%2Fconfig%2Fip2k%2Fip2k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fip2k%2Fip2k.h?ref=9cd10576c58786afe2ec3a9193f85f61de760068", "patch": "@@ -857,7 +857,7 @@ enum reg_class {\n /* `SECONDARY_MEMORY_NEEDED (CLASS1, CLASS2, M)'\n    Certain machines have the property that some registers cannot be\n    copied to some other registers without using memory.  Define this\n-   macro on those machines to be a C expression that is non-zero if\n+   macro on those machines to be a C expression that is nonzero if\n    objects of mode M in registers of CLASS1 can only be copied to\n    registers of class CLASS2 by storing a register of CLASS1 into\n    memory and loading that memory location into a register of CLASS2.\n@@ -881,16 +881,16 @@ enum reg_class {\n    classes that there would not be enough registers to use as spill\n    registers if this were done.\n \n-   Define `SMALL_REGISTER_CLASSES' to be an expression with a non-zero\n-   value on these machines.  When this macro has a non-zero value, the\n+   Define `SMALL_REGISTER_CLASSES' to be an expression with a nonzero\n+   value on these machines.  When this macro has a nonzero value, the\n    compiler allows registers explicitly used in the rtl to be used as\n    spill registers but avoids extending the lifetime of these\n    registers.\n \n-   It is always safe to define this macro with a non-zero value, but\n+   It is always safe to define this macro with a nonzero value, but\n    if you unnecessarily define it, you will reduce the amount of\n    optimizations that can be performed in some cases.  If you do not\n-   define this macro with a non-zero value when it is required, the\n+   define this macro with a nonzero value when it is required, the\n    compiler will run out of spill registers and print a fatal error\n    message.  For most machines, you should not define this macro at\n    all.  */\n@@ -1148,7 +1148,7 @@ enum reg_class {\n    ? (flag_omit_frame_pointer && !frame_pointer_needed) : 1)\n /* Don't eliminate FP unless we EXPLICITLY_ASKED  */\n \n-/* A C expression that returns non-zero if the compiler is allowed to\n+/* A C expression that returns nonzero if the compiler is allowed to\n    try to replace register number FROM-REG with register number\n    TO-REG.  This macro need only be defined if `ELIMINABLE_REGS' is\n    defined, and will usually be the constant 1, since most of the\n@@ -1275,7 +1275,7 @@ enum reg_class {\n    You may use the macro `MUST_PASS_IN_STACK (MODE, TYPE)' in the\n    definition of this macro to determine if this argument is of a\n    type that must be passed in the stack.  If `REG_PARM_STACK_SPACE'\n-   is not defined and `FUNCTION_ARG' returns non-zero for such an\n+   is not defined and `FUNCTION_ARG' returns nonzero for such an\n    argument, the compiler will abort.  If `REG_PARM_STACK_SPACE' is\n    defined, the argument will be computed in the stack and then\n    loaded into a register.  */\n@@ -1905,10 +1905,10 @@ do {\t\t\t\t\t\t\t\t\t\\\n    cost many times greater than aligned accesses, for example if they\n    are emulated in a trap handler.\n \n-   When this macro is non-zero, the compiler will act as if\n-   `STRICT_ALIGNMENT' were non-zero when generating code for block\n+   When this macro is nonzero, the compiler will act as if\n+   `STRICT_ALIGNMENT' were nonzero when generating code for block\n    moves.  This can cause significantly more instructions to be\n-   produced.  Therefore, do not set this macro non-zero if unaligned\n+   produced.  Therefore, do not set this macro nonzero if unaligned\n    accesses only add a cycle or two to the time for a memory access.\n \n    If the value of this macro is always zero, it need not be defined."}, {"sha": "3fa272e328f3ab512a7974db8b98921c7fc12e15", "filename": "gcc/config/ip2k/ip2k.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd10576c58786afe2ec3a9193f85f61de760068/gcc%2Fconfig%2Fip2k%2Fip2k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd10576c58786afe2ec3a9193f85f61de760068/gcc%2Fconfig%2Fip2k%2Fip2k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fip2k%2Fip2k.md?ref=9cd10576c58786afe2ec3a9193f85f61de760068", "patch": "@@ -165,7 +165,7 @@\n   [(set_attr \"skip\" \"yes\")\n    (set_attr \"clobberw\" \"no\")])\n \n-;; IP isn't offsettable but we can fake this behaviour here and win if we would\n+;; IP isn't offsettable but we can fake this behavior here and win if we would\n ;; otherwise use DP and require a reload from IP.  This instruction is only\n ;; matched by peephole2 operations.\n ;;\n@@ -205,7 +205,7 @@\n     return \\\"\\\";\n   }\")\n \n-;; IP isn't offsettable but we can fake this behaviour here and win if we would\n+;; IP isn't offsettable but we can fake this behavior here and win if we would\n ;; otherwise use DP and require a reload from IP.  This instruction is only\n ;; matched by peephole2 operations.\n ;;\n@@ -6566,7 +6566,7 @@\n \n ;; Tidy up stack slot addressing where we've eliminated some registers.\n ;;   This looks like something strange going on though as gcc-2.97 didn't\n-;; exhibit this behaviour, whereas gcc-3.0.4 does.\n+;; exhibit this behavior, whereas gcc-3.0.4 does.\n ;;\n (define_peephole2\n   [(set (match_operand:HI 0 \"register_operand\" \"\")"}, {"sha": "2522a5e51c1e9fc3cbac757ad04a65ca8e6771b7", "filename": "gcc/config/ip2k/libgcc.S", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd10576c58786afe2ec3a9193f85f61de760068/gcc%2Fconfig%2Fip2k%2Flibgcc.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd10576c58786afe2ec3a9193f85f61de760068/gcc%2Fconfig%2Fip2k%2Flibgcc.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fip2k%2Flibgcc.S?ref=9cd10576c58786afe2ec3a9193f85f61de760068", "patch": "@@ -1449,7 +1449,7 @@ __movstrhi_counthi:\n \tmov\tw, 8(SP)\n \tmov\tipl, w\n \n-\ttest\t10(SP)\t\t\t; If we have a non-zero LSB then adjust the\n+\ttest\t10(SP)\t\t\t; If we have a nonzero LSB then adjust the\n \tsz\t\t\t\t; MSB of the loop count to allow us to use\n \tinc\t9(SP)\t\t\t; skip tricks!\n "}]}