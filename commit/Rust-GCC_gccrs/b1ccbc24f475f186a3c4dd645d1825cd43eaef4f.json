{"sha": "b1ccbc24f475f186a3c4dd645d1825cd43eaef4f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjFjY2JjMjRmNDc1ZjE4NmEzYzRkZDY0NWQxODI1Y2Q0M2VhZWY0Zg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-04-20T16:54:50Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-04-20T16:54:50Z"}, "message": "Cast first arg in all calls to bzero to char *.\n\n(decl_ultimate_origin): Return NULL if equal to decl.\n(constant_size): Never return more than 4.\n(value_format, case 8): New case.\n(dwarf2out_frame_debug): Use HARD_FRAME_POINTER_REGNUM.\n(based_loc_descr): Likewise.\n(add_bound_info): Delete default case.\nAdd cases for CONVERT_EXPR and NON_LVALUE_EXPR; treat like NOP_EXPR.\nChange NOP_EXPR to to recursive call.\n(add_type_attribute): Ignore unnamed subtype of integral or FP.\n(gen_subprogram_die): Use reg_loc_descriptor.\n(dwarf2out_decl): Ignore nested functions.\n\nFrom-SVN: r13939", "tree": {"sha": "3a2f9c8389608781debe2de0e1001ec26016b535", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a2f9c8389608781debe2de0e1001ec26016b535"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1ccbc24f475f186a3c4dd645d1825cd43eaef4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1ccbc24f475f186a3c4dd645d1825cd43eaef4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1ccbc24f475f186a3c4dd645d1825cd43eaef4f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1ccbc24f475f186a3c4dd645d1825cd43eaef4f/comments", "author": null, "committer": null, "parents": [{"sha": "2e3f9f3d62453b563fc0f9c4a79982ef0b03d24a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e3f9f3d62453b563fc0f9c4a79982ef0b03d24a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e3f9f3d62453b563fc0f9c4a79982ef0b03d24a"}], "stats": {"total": 135, "additions": 69, "deletions": 66}, "files": [{"sha": "4cff7c37e7feb829d3bdfb8305d164505b89de81", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 69, "deletions": 66, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1ccbc24f475f186a3c4dd645d1825cd43eaef4f/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1ccbc24f475f186a3c4dd645d1825cd43eaef4f/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=b1ccbc24f475f186a3c4dd645d1825cd43eaef4f", "patch": "@@ -132,7 +132,7 @@ typedef struct dw_separate_line_info_struct\n dw_separate_line_info_entry;\n \n /* The dw_val_node describes an attibute's value, as it is\n-   represnted internally.  */\n+   represented internally.  */\n typedef struct dw_val_struct\n   {\n     dw_val_class val_class;\n@@ -1814,7 +1814,7 @@ decl_ultimate_origin (decl)\n {\n   register tree immediate_origin = DECL_ABSTRACT_ORIGIN (decl);\n \n-  if (immediate_origin == NULL)\n+  if (immediate_origin == NULL || immediate_origin == decl)\n     return NULL;\n   else\n     {\n@@ -2403,20 +2403,23 @@ equate_decl_number_to_die (decl, decl_die)\n   register unsigned num_allocated;\n   if (decl_id >= decl_die_table_allocated)\n     {\n-      num_allocated = (((decl_id + 1)\n-\t\t\t+ DECL_DIE_TABLE_INCREMENT - 1)\n-\t\t       / DECL_DIE_TABLE_INCREMENT)\n-\t* DECL_DIE_TABLE_INCREMENT;\n-      decl_die_table = (dw_die_ref *) xrealloc (decl_die_table,\n-\t\t\t\t       sizeof (dw_die_ref) * num_allocated);\n-      bzero (&decl_die_table[decl_die_table_allocated],\n-\t  (num_allocated - decl_die_table_allocated) * sizeof (dw_die_ref));\n+      num_allocated\n+\t= ((decl_id + 1 + DECL_DIE_TABLE_INCREMENT - 1)\n+\t   / DECL_DIE_TABLE_INCREMENT)\n+\t  * DECL_DIE_TABLE_INCREMENT;\n+\n+      decl_die_table\n+\t= (dw_die_ref *) xrealloc (decl_die_table,\n+\t\t\t\t   sizeof (dw_die_ref) * num_allocated);\n+\n+      bzero ((char *) &decl_die_table[decl_die_table_allocated],\n+\t     (num_allocated - decl_die_table_allocated) * sizeof (dw_die_ref));\n       decl_die_table_allocated = num_allocated;\n     }\n+\n   if (decl_id >= decl_die_table_in_use)\n-    {\n-      decl_die_table_in_use = (decl_id + 1);\n-    }\n+    decl_die_table_in_use = (decl_id + 1);\n+\n   decl_die_table[decl_id] = decl_die;\n }\n \n@@ -2706,25 +2709,25 @@ build_abbrev_table (die)\n       if (abbrev_die_table_in_use >= abbrev_die_table_allocated)\n \t{\n \t  n_alloc = abbrev_die_table_allocated + ABBREV_DIE_TABLE_INCREMENT;\n-\t  abbrev_die_table = (dw_die_ref *)\n-\t    xmalloc (abbrev_die_table,\n-\t\t     sizeof (dw_die_ref) * n_alloc);\n-\t  bzero (&abbrev_die_table[abbrev_die_table_allocated],\n-\t      (n_alloc - abbrev_die_table_allocated) * sizeof (dw_die_ref));\n+\t  abbrev_die_table \n+\t    = (dw_die_ref *) xmalloc (abbrev_die_table,\n+\t\t\t\t      sizeof (dw_die_ref) * n_alloc);\n+\n+\t  bzero ((char *) &abbrev_die_table[abbrev_die_table_allocated],\n+\t\t (n_alloc - abbrev_die_table_allocated) * sizeof (dw_die_ref));\n \t  abbrev_die_table_allocated = n_alloc;\n \t}\n+\n       ++abbrev_die_table_in_use;\n       abbrev_die_table[abbrev_id] = die;\n     }\n+\n   die->die_abbrev = abbrev_id;\n   for (c = die->die_child; c != NULL; c = c->die_sib)\n-    {\n-      build_abbrev_table (c);\n-    }\n+    build_abbrev_table (c);\n }\n-\n \f\n-/**********************  DWARF Information Sizing *****************************/\n+/**********************  DWARF Information Sizing ****************************/\n \n /* Return the size of an unsigned LEB128 quantity.  */\n inline unsigned long\n@@ -2910,7 +2913,7 @@ constant_size (value)\n   log = log / 8;\n   log = 1 << (floor_log2 (log) + 1);\n \n-  return log;\n+  return MIN (log, 4);\n }\n \n /* Return the size of a DIE, as it is represented in the\n@@ -3273,6 +3276,8 @@ value_format (v)\n \t  return DW_FORM_data2;\n \tcase 4:\n \t  return DW_FORM_data4;\n+\tcase 8:\n+\t  return DW_FORM_data8;\n \tdefault:\n \t  abort ();\n \t}\n@@ -3982,7 +3987,8 @@ dwarf2out_frame_debug (insn)\n \tcase REG:\n \t  assert (cfa_reg == REGNO (src));\n \t  assert (REGNO (dest) == STACK_POINTER_REGNUM\n-\t\t  || frame_pointer_needed && REGNO (dest) == FRAME_POINTER_REGNUM);\n+\t\t  || (frame_pointer_needed\n+\t\t      && REGNO (dest) == HARD_FRAME_POINTER_REGNUM));\n \t  cfa_reg = REGNO (dest);\n \t  break;\n \n@@ -5344,7 +5350,7 @@ based_loc_descr (reg, offset)\n      registers, since the RTL for local variables is relative to one of\n      them.  */\n   register unsigned fp_reg = DBX_REGISTER_NUMBER (frame_pointer_needed\n-\t\t\t\t\t\t  ? FRAME_POINTER_REGNUM\n+\t\t\t\t\t\t  ? HARD_FRAME_POINTER_REGNUM\n \t\t\t\t\t\t  : STACK_POINTER_REGNUM);\n   if (reg == fp_reg)\n     {\n@@ -6066,12 +6072,12 @@ add_bound_info (subrange_die, bound_attr, bound)\n \tadd_AT_unsigned (subrange_die, bound_attr, bound_value);\n       break;\n \n-    /* Dynamic bounds may be represented by NOP_EXPR nodes containing\n-       SAVE_EXPR nodes.  */\n+    case CONVERT_EXPR:\n     case NOP_EXPR:\n-      bound = TREE_OPERAND (bound, 0);\n-      /* ... fall thru...  */\n-\n+    case NON_LVALUE_EXPR:\n+      add_bound_info (subrange_die, bound_attr, TREE_OPERAND (bound, 0));\n+      break;\n+      \n     case SAVE_EXPR:\n       /* If optimization is turned on, the SAVE_EXPRs that describe how to\n          access the upper bound values may be bogus.  If they refer to a\n@@ -6106,9 +6112,6 @@ add_bound_info (subrange_die, bound_attr, bound)\n \t}\n       /* else leave out the attribute.  */\n       break;\n-\n-    default:\n-      abort ();\n     }\n }\n \n@@ -6454,18 +6457,20 @@ add_type_attribute (object_die, type, decl_const, decl_volatile, context_die)\n   register enum tree_code code  = TREE_CODE (type);\n   register dw_die_ref type_die  = NULL;\n \n+  /* If this type is an unnamed subtype of an integral or floating-point\n+     type, use the inner type.  */\n+  if ((code == INTEGER_TYPE || code == REAL_TYPE)\n+      && TREE_TYPE (type) != 0 && TYPE_NAME (type) == 0)\n+    type = TREE_TYPE (type), code = TREE_CODE (type);\n+\n   if (code == ERROR_MARK)\n-    {\n-      return;\n-    }\n+    return;\n \n   /* Handle a special case.  For functions whose return type is void, we\n      generate *no* type attribute.  (Note that no object may have type\n      `void', so this only applies to function return types).  */\n   if (code == VOID_TYPE)\n-    {\n-      return;\n-    }\n+    return;\n \n   type_die = modified_type_die (type,\n \t\t\t\tdecl_const || TYPE_READONLY (type),\n@@ -6907,7 +6912,7 @@ gen_subprogram_die (decl, context_die)\n   register tree origin = decl_ultimate_origin (decl);\n   register dw_die_ref subr_die;\n   register dw_loc_descr_ref fp_loc = NULL;\n-  register unsigned fp_reg;\n+  register rtx fp_reg;\n   register tree fn_arg_types;\n   register tree outer_scope;\n   register dw_die_ref old_die = lookup_decl_die (decl);\n@@ -7041,12 +7046,9 @@ gen_subprogram_die (decl, context_die)\n       /* Define the \"frame base\" location for this routine.  We use the\n          frame pointer or stack pointer registers, since the RTL for local\n          variables is relative to one of them.  */\n-      fp_reg = DBX_REGISTER_NUMBER (frame_pointer_needed\n-\t\t\t\t    ? FRAME_POINTER_REGNUM\n-\t\t\t\t    : STACK_POINTER_REGNUM);\n-      assert (fp_reg >= 0 && fp_reg <= 31);\n-      fp_loc = new_loc_descr (DW_OP_reg0 + fp_reg);\n-      add_AT_loc (subr_die, DW_AT_frame_base, fp_loc);\n+      fp_reg\n+\t= frame_pointer_needed ? hard_frame_pointer_rtx : stack_pointer_rtx;\n+      add_AT_loc (subr_die, DW_AT_frame_base, reg_loc_descriptor (fp_reg));\n \n       if (current_function_needs_context)\n \tadd_AT_loc (subr_die, DW_AT_static_link,\n@@ -8168,9 +8170,7 @@ dwarf2out_decl (decl)\n          builtin function.  Explicit programmer-supplied declarations of\n          these same functions should NOT be ignored however.  */\n       if (DECL_EXTERNAL (decl) && DECL_FUNCTION_CODE (decl))\n-\t{\n-\t  return;\n-\t}\n+\treturn;\n \n       /* What we would really like to do here is to filter out all mere\n          file-scope declarations of file-scope functions which are never\n@@ -8198,15 +8198,13 @@ dwarf2out_decl (decl)\n          within include files which also contain \n \t `#pragma interface' pragmas.  */\n       if (DECL_INITIAL (decl) == NULL_TREE)\n-\t{\n-\t  return;\n-\t}\n+\treturn;\n \n-      /* If we're a nested function, initially use a parent of NULL; if we're\n-\t a plain function, this will be fixed up in decls_for_scope.  If\n-\t we're a method, it will be ignored, since we already have a DIE.  */\n+      /* Ignore nested functions, since they will be written in decl_for_scope.\n+\t ??? There was an old comment here about methods, which now need to\n+\t be handled.  */\n       if (decl_function_context (decl))\n-\tcontext_die = NULL;\n+\treturn;\n \n       break;\n \n@@ -8253,7 +8251,8 @@ dwarf2out_decl (decl)\n       /* If we're a function-scope tag, initially use a parent of NULL;\n \t this will be fixed up in decls_for_scope.  */\n       if (decl_function_context (decl))\n-\tcontext_die = NULL;\n+\treturn;\n+/*\tcontext_die = NULL; */\n \n       break;\n \n@@ -8525,30 +8524,33 @@ dwarf2out_init (asm_out_file, main_input_filename)\n \n   /* Allocate the initial hunk of the file_table.  */\n   file_table = (char **) xmalloc (FILE_TABLE_INCREMENT * sizeof (char *));\n-  bzero (file_table, FILE_TABLE_INCREMENT * sizeof (char *));\n+  bzero ((char *) file_table, FILE_TABLE_INCREMENT * sizeof (char *));\n   file_table_allocated = FILE_TABLE_INCREMENT;\n   /* skip the first entry - file numbers begin at 1 */\n   file_table_in_use = 1;\n \n   /* Allocate the initial hunk of the decl_die_table.  */\n   decl_die_table\n     = (dw_die_ref *) xmalloc (DECL_DIE_TABLE_INCREMENT * sizeof (dw_die_ref));\n-  bzero (decl_die_table, DECL_DIE_TABLE_INCREMENT * sizeof (dw_die_ref));\n+  bzero ((char *) decl_die_table,\n+\t DECL_DIE_TABLE_INCREMENT * sizeof (dw_die_ref));\n   decl_die_table_allocated = DECL_DIE_TABLE_INCREMENT;\n   decl_die_table_in_use = 0;\n \n   /* Allocate the initial hunk of the decl_scope_table.  */\n   decl_scope_table\n     = (tree *) xmalloc (DECL_SCOPE_TABLE_INCREMENT * sizeof (tree));\n-  bzero (decl_scope_table, DECL_SCOPE_TABLE_INCREMENT * sizeof (tree));\n+  bzero ((char *) decl_scope_table,\n+\t DECL_SCOPE_TABLE_INCREMENT * sizeof (tree));\n   decl_scope_table_allocated = DECL_SCOPE_TABLE_INCREMENT;\n   decl_scope_depth = 0;\n \n   /* Allocate the initial hunk of the abbrev_die_table.  */\n   abbrev_die_table\n     = (dw_die_ref *) xmalloc (ABBREV_DIE_TABLE_INCREMENT\n \t\t\t      * sizeof (dw_die_ref));\n-  bzero (abbrev_die_table, ABBREV_DIE_TABLE_INCREMENT * sizeof (dw_die_ref));\n+  bzero ((char *) abbrev_die_table,\n+\t ABBREV_DIE_TABLE_INCREMENT * sizeof (dw_die_ref));\n   abbrev_die_table_allocated = ABBREV_DIE_TABLE_INCREMENT;\n   /* zero-th entry is allocated, but unused */\n   abbrev_die_table_in_use = 1;\n@@ -8557,15 +8559,16 @@ dwarf2out_init (asm_out_file, main_input_filename)\n   line_info_table\n     = (dw_line_info_ref) xmalloc (LINE_INFO_TABLE_INCREMENT\n \t\t\t\t  * sizeof (dw_line_info_entry));\n-  bzero (line_info_table, LINE_INFO_TABLE_INCREMENT\n-\t * sizeof (dw_line_info_entry));\n+  bzero ((char *) line_info_table,\n+\t LINE_INFO_TABLE_INCREMENT * sizeof (dw_line_info_entry));\n   line_info_table_allocated = LINE_INFO_TABLE_INCREMENT;\n   /* zero-th entry is allocated, but unused */\n   line_info_table_in_use = 1;\n \n   /* Allocate the initial hunk of the fde_table.  */\n-  fde_table = (dw_fde_ref) xmalloc (FDE_TABLE_INCREMENT * sizeof (dw_fde_node));\n-  bzero (fde_table, FDE_TABLE_INCREMENT * sizeof (dw_fde_node));\n+  fde_table\n+    = (dw_fde_ref) xmalloc (FDE_TABLE_INCREMENT * sizeof (dw_fde_node));\n+  bzero ((char *) fde_table, FDE_TABLE_INCREMENT * sizeof (dw_fde_node));\n   fde_table_allocated = FDE_TABLE_INCREMENT;\n   fde_table_in_use = 0;\n "}]}