{"sha": "390f94eee1ae694901f896ac45bfb148f8126baa", "node_id": "C_kwDOANBUbNoAKDM5MGY5NGVlZTFhZTY5NDkwMWY4OTZhYzQ1YmZiMTQ4ZjgxMjZiYWE", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-08-26T19:10:57Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-08-26T19:10:57Z"}, "message": "libstdc++: Optimize std::con/disjunction, __and_/__or_, etc\n\nThe internal type-level logical operator traits __and_ and __or_ seem to\nhave high overhead for a couple of reasons:\n\n  1. They are drop-in replacements for std::con/disjunction, which\n     are rigidly specified to form a type that derives from the first\n     type argument that caused the overall computation to short-circuit.\n     In practice this inheritance property seems to be rarely needed;\n     usually all we care about is the value of the overall result.\n  2. Their recursive implementations instantiate O(N) class templates\n     and form an inheritance chain of depth O(N).\n\nThis patch gets rid of this inheritance property of __and_ and __or_\n(which seems to be unneeded in the library except indirectly by\nstd::con/disjunction) which allows us to redefine them non-recursively\nas alias templates that yield either false_type or true_type via\nenable_if_t and partial ordering of a pair of function templates\n(alternatively we could use an equivalent partially specialized class\ntemplate, but using function templates appears to be slightly more\nefficient).\n\nAs for std::con/disjunction, it seems we need to keep implementing them\nvia a recursive class template for sake of the inheritance property.\nBut instead of using inheritance recursion, use a recursive member\ntypedef that gets immediately flattened, so that specializations thereof\nnow have O(1) instead of O(N) inheritance depth.\n\nIn passing, redefine __not_ as an alias template for consistency with\n__and_ and __or_, and to remove a layer of indirection.\n\nTogether these changes have a substantial effect on compile time and\nmemory usage for code that heavily uses these internal type traits.\nFor the following example (which tests constructibility between two\ncompatible 257-element tuple types):\n\n  #include <tuple>\n\n  #define M(x) x, x\n\n  using ty1 = std::tuple<M(M(M(M(M(M(M(M(int)))))))), int>;\n  using ty2 = std::tuple<M(M(M(M(M(M(M(M(int)))))))), long>;\n\n  static_assert(std::is_constructible_v<ty2, ty1>);\n\nmemory usage improves ~27% from 440MB to 320MB and compile time improves\n~20% from ~2s to ~1.6s (with -std=c++23).\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/std/type_traits (enable_if, __enable_if_t): Define them\n\tearlier.\n\t(__detail::__first_t): Define.\n\t(__detail::__or_fn, __detail::__and_fn): Declare.\n\t(__or_, __and_): Redefine as alias templates in terms of __or_fn\n\tand __and_fn.\n\t(__not_): Redefine as an alias template.\n\t(__detail::__disjunction_impl, __detail::__conjunction_impl):\n\tDefine.\n\t(conjuction, disjunction): Redefine in terms of __disjunction_impl\n\tand __conjunction_impl.", "tree": {"sha": "563ba23364843bdc1aa9aae98490a45da484d1ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/563ba23364843bdc1aa9aae98490a45da484d1ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/390f94eee1ae694901f896ac45bfb148f8126baa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/390f94eee1ae694901f896ac45bfb148f8126baa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/390f94eee1ae694901f896ac45bfb148f8126baa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/390f94eee1ae694901f896ac45bfb148f8126baa/comments", "author": null, "committer": null, "parents": [{"sha": "1d3145360f95910f0661da0364b91dc7962d44fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d3145360f95910f0661da0364b91dc7962d44fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d3145360f95910f0661da0364b91dc7962d44fa"}], "stats": {"total": 130, "additions": 71, "deletions": 59}, "files": [{"sha": "c2f5cb9c806b98e44c91a39cc1ba4ef22c84b131", "filename": "libstdc++-v3/include/std/type_traits", "status": "modified", "additions": 71, "deletions": 59, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390f94eee1ae694901f896ac45bfb148f8126baa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390f94eee1ae694901f896ac45bfb148f8126baa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits?ref=390f94eee1ae694901f896ac45bfb148f8126baa", "patch": "@@ -100,6 +100,21 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // Metaprogramming helper types.\n \n+  // Primary template.\n+  /// Define a member typedef `type` only if a boolean constant is true.\n+  template<bool, typename _Tp = void>\n+    struct enable_if\n+    { };\n+\n+  // Partial specialization for true.\n+  template<typename _Tp>\n+    struct enable_if<true, _Tp>\n+    { typedef _Tp type; };\n+\n+  // __enable_if_t (std::enable_if_t for C++11)\n+  template<bool _Cond, typename _Tp = void>\n+    using __enable_if_t = typename enable_if<_Cond, _Tp>::type;\n+\n   template<bool>\n     struct __conditional\n     {\n@@ -127,56 +142,39 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Tp>\n     using __type_identity_t = typename __type_identity<_Tp>::type;\n \n-  template<typename...>\n-    struct __or_;\n-\n-  template<>\n-    struct __or_<>\n-    : public false_type\n-    { };\n-\n-  template<typename _B1>\n-    struct __or_<_B1>\n-    : public _B1\n-    { };\n-\n-  template<typename _B1, typename _B2>\n-    struct __or_<_B1, _B2>\n-    : public __conditional_t<_B1::value, _B1, _B2>\n-    { };\n+  namespace __detail\n+  {\n+    // A variadic alias template that resolves to its first argument.\n+    template<typename _Tp, typename...>\n+      using __first_t = _Tp;\n \n-  template<typename _B1, typename _B2, typename _B3, typename... _Bn>\n-    struct __or_<_B1, _B2, _B3, _Bn...>\n-    : public __conditional_t<_B1::value, _B1, __or_<_B2, _B3, _Bn...>>\n-    { };\n+    // These are deliberately not defined.\n+    template<typename... _Bn>\n+      auto __or_fn(int) -> __first_t<false_type,\n+\t\t\t\t     __enable_if_t<!bool(_Bn::value)>...>;\n \n-  template<typename...>\n-    struct __and_;\n+    template<typename... _Bn>\n+      auto __or_fn(...) -> true_type;\n \n-  template<>\n-    struct __and_<>\n-    : public true_type\n-    { };\n+    template<typename... _Bn>\n+      auto __and_fn(int) -> __first_t<true_type,\n+\t\t\t\t      __enable_if_t<bool(_Bn::value)>...>;\n \n-  template<typename _B1>\n-    struct __and_<_B1>\n-    : public _B1\n-    { };\n+    template<typename... _Bn>\n+      auto __and_fn(...) -> false_type;\n+  } // namespace detail\n \n-  template<typename _B1, typename _B2>\n-    struct __and_<_B1, _B2>\n-    : public __conditional_t<_B1::value, _B2, _B1>\n-    { };\n+  // Like C++17 std::dis/conjunction, but usable in C++11 and resolves\n+  // to either true_type or false_type which allows for a more efficient\n+  // implementation that avoids recursive class template instantiation.\n+  template<typename... _Bn>\n+    using __or_ = decltype(__detail::__or_fn<_Bn...>(0));\n \n-  template<typename _B1, typename _B2, typename _B3, typename... _Bn>\n-    struct __and_<_B1, _B2, _B3, _Bn...>\n-    : public __conditional_t<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>\n-    { };\n+  template<typename... _Bn>\n+    using __and_ = decltype(__detail::__and_fn<_Bn...>(0));\n \n   template<typename _Pp>\n-    struct __not_\n-    : public __bool_constant<!bool(_Pp::value)>\n-    { };\n+    using __not_ = __bool_constant<!bool(_Pp::value)>;\n   /// @endcond\n \n #if __cplusplus >= 201703L\n@@ -186,18 +184,47 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     inline constexpr bool __or_v = __or_<_Bn...>::value;\n   template<typename... _Bn>\n     inline constexpr bool __and_v = __and_<_Bn...>::value;\n+\n+  namespace __detail\n+  {\n+    template<typename /* = void */, typename _B1, typename... _Bn>\n+      struct __disjunction_impl\n+      { using type = _B1; };\n+\n+    template<typename _B1, typename _B2, typename... _Bn>\n+      struct __disjunction_impl<__enable_if_t<!bool(_B1::value)>, _B1, _B2, _Bn...>\n+      { using type = typename __disjunction_impl<void, _B2, _Bn...>::type; };\n+\n+    template<typename /* = void */, typename _B1, typename... _Bn>\n+      struct __conjunction_impl\n+      { using type = _B1; };\n+\n+    template<typename _B1, typename _B2, typename... _Bn>\n+      struct __conjunction_impl<__enable_if_t<bool(_B1::value)>, _B1, _B2, _Bn...>\n+      { using type = typename __conjunction_impl<void, _B2, _Bn...>::type; };\n+  } // namespace __detail\n   /// @endcond\n \n #define __cpp_lib_logical_traits 201510L\n \n   template<typename... _Bn>\n     struct conjunction\n-    : __and_<_Bn...>\n+    : __detail::__conjunction_impl<void, _Bn...>::type\n+    { };\n+\n+  template<>\n+    struct conjunction<>\n+    : true_type\n     { };\n \n   template<typename... _Bn>\n     struct disjunction\n-    : __or_<_Bn...>\n+    : __detail::__disjunction_impl<void, _Bn...>::type\n+    { };\n+\n+  template<>\n+    struct disjunction<>\n+    : false_type\n     { };\n \n   template<typename _Pp>\n@@ -2219,23 +2246,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     using __decay_and_strip = __strip_reference_wrapper<__decay_t<_Tp>>;\n   /// @endcond\n \n-  // Primary template.\n-  /// Define a member typedef `type` only if a boolean constant is true.\n-  template<bool, typename _Tp = void>\n-    struct enable_if\n-    { };\n-\n-  // Partial specialization for true.\n-  template<typename _Tp>\n-    struct enable_if<true, _Tp>\n-    { typedef _Tp type; };\n-\n   /// @cond undocumented\n \n-  // __enable_if_t (std::enable_if_t for C++11)\n-  template<bool _Cond, typename _Tp = void>\n-    using __enable_if_t = typename enable_if<_Cond, _Tp>::type;\n-\n   // Helper for SFINAE constraints\n   template<typename... _Cond>\n     using _Require = __enable_if_t<__and_<_Cond...>::value>;"}]}