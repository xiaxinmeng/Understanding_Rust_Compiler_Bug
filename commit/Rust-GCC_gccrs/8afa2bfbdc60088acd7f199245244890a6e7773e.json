{"sha": "8afa2bfbdc60088acd7f199245244890a6e7773e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGFmYTJiZmJkYzYwMDg4YWNkN2YxOTkyNDUyNDQ4OTBhNmU3NzczZQ==", "commit": {"author": {"name": "Sanjoy Das", "email": "thedigitalangel@gmail.com", "date": "2011-11-29T19:10:50Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-11-29T19:10:50Z"}, "message": "compiler: Define and use backend-independent Location class.\n\nFrom Sanjoy Das.\n\n\t* go-location.h: New file.\n\t* go-linemap.cc: New file.\n\t* go-gcc.cc: Change all uses of source_location to Location.\n\t* Make-lang.in (GO_OBJS): Add go/go-linemap.o.\n\t(GO_LINEMAP_H): New variable.\n\t(GO_LEX_H): Use $(GO_LINEMAP_H).\n\t(GO_GOGO_H, GO_TYPES_H, GO_IMPORT_H): Likewise.\n\t(go/go-linemap.o): New target.\n\nCo-Authored-By: Ian Lance Taylor <iant@google.com>\n\nFrom-SVN: r181813", "tree": {"sha": "f79cf7c9d2d4e5b74c516201a60c5753fe79c93f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f79cf7c9d2d4e5b74c516201a60c5753fe79c93f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8afa2bfbdc60088acd7f199245244890a6e7773e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8afa2bfbdc60088acd7f199245244890a6e7773e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8afa2bfbdc60088acd7f199245244890a6e7773e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8afa2bfbdc60088acd7f199245244890a6e7773e/comments", "author": {"login": "theDigitalAngel", "id": 95083, "node_id": "MDQ6VXNlcjk1MDgz", "avatar_url": "https://avatars.githubusercontent.com/u/95083?v=4", "gravatar_id": "", "url": "https://api.github.com/users/theDigitalAngel", "html_url": "https://github.com/theDigitalAngel", "followers_url": "https://api.github.com/users/theDigitalAngel/followers", "following_url": "https://api.github.com/users/theDigitalAngel/following{/other_user}", "gists_url": "https://api.github.com/users/theDigitalAngel/gists{/gist_id}", "starred_url": "https://api.github.com/users/theDigitalAngel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/theDigitalAngel/subscriptions", "organizations_url": "https://api.github.com/users/theDigitalAngel/orgs", "repos_url": "https://api.github.com/users/theDigitalAngel/repos", "events_url": "https://api.github.com/users/theDigitalAngel/events{/privacy}", "received_events_url": "https://api.github.com/users/theDigitalAngel/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "09ad58e618b0145ed98ee081ffc8117824390972", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09ad58e618b0145ed98ee081ffc8117824390972", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09ad58e618b0145ed98ee081ffc8117824390972"}], "stats": {"total": 2649, "additions": 1545, "deletions": 1104}, "files": [{"sha": "47910fd75a9e9fdc093d98361e2f3838600cf99a", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=8afa2bfbdc60088acd7f199245244890a6e7773e", "patch": "@@ -1,3 +1,15 @@\n+2011-11-29  Sanjoy Das  <thedigitalangel@gmail.com>\n+\t    Ian Lance Taylor  <iant@google.com>\n+\n+\t* go-location.h: New file.\n+\t* go-linemap.cc: New file.\n+\t* go-gcc.cc: Change all uses of source_location to Location.\n+\t* Make-lang.in (GO_OBJS): Add go/go-linemap.o.\n+\t(GO_LINEMAP_H): New variable.\n+\t(GO_LEX_H): Use $(GO_LINEMAP_H).\n+\t(GO_GOGO_H, GO_TYPES_H, GO_IMPORT_H): Likewise.\n+\t(go/go-linemap.o): New target.\n+\n 2011-11-02  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* Make-lang.in (gospec.o): Pass SHLIB instead of SHLIB_LINK."}, {"sha": "08aaafbe045728caafe1961f87e3713d8113fde6", "filename": "gcc/go/Make-lang.in", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FMake-lang.in?ref=8afa2bfbdc60088acd7f199245244890a6e7773e", "patch": "@@ -54,6 +54,7 @@ GO_OBJS = \\\n \tgo/go-dump.o \\\n \tgo/go-gcc.o \\\n \tgo/go-lang.o \\\n+\tgo/go-linemap.o \\\n \tgo/go-optimize.o \\\n \tgo/go.o \\\n \tgo/gogo-tree.o \\\n@@ -217,14 +218,15 @@ GO_SYSTEM_H = go/go-system.h $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n \t$(DIAGNOSTIC_CORE_H) $(INPUT_H) intl.h\n \n GO_C_H = go/go-c.h $(MACHMODE_H)\n-GO_LEX_H = go/gofrontend/lex.h go/gofrontend/operator.h\n+GO_LINEMAP_H = go/gofrontend/go-linemap.h $(GO_SYSTEM_H) go/go-location.h\n+GO_LEX_H = go/gofrontend/lex.h go/gofrontend/operator.h $(GO_LINEMAP_H)\n GO_PARSE_H = go/gofrontend/parse.h\n-GO_GOGO_H = go/gofrontend/gogo.h\n-GO_TYPES_H = go/gofrontend/types.h\n+GO_GOGO_H = go/gofrontend/gogo.h $(GO_LINEMAP_H)\n+GO_TYPES_H = go/gofrontend/types.h $(GO_LINEMAP_H)\n GO_STATEMENTS_H = go/gofrontend/statements.h go/gofrontend/operator.h\n GO_EXPRESSIONS_H = go/gofrontend/expressions.h go/gofrontend/operator.h\n GO_EXPORT_H = go/gofrontend/export.h go/gofrontend/string-dump.h\n-GO_IMPORT_H = go/gofrontend/import.h $(GO_EXPORT_H)\n+GO_IMPORT_H = go/gofrontend/import.h $(GO_EXPORT_H) $(GO_LINEMAP_H)\n GO_RUNTIME_H = go/gofrontend/runtime.h go/gofrontend/runtime.def\n GO_AST_DUMP_H = go/gofrontend/ast-dump.h go/gofrontend/string-dump.h\n \n@@ -247,6 +249,9 @@ go/go-gcc.o: go/go-gcc.cc $(GO_SYSTEM_H) $(TREE_H) tree-iterator.h \\\n \t\tgo/gofrontend/backend.h\n \t$(CXX) -c $(GOINCLUDES) $(ALL_CPPFLAGS) $(ALL_CXXFLAGS) $< $(OUTPUT_OPTION)\n \n+go/go-linemap.o: go/go-linemap.cc $(GO_SYSTEM_H) $(GO_LINEMAP_H)\n+\t$(CXX) -c $(GOINCLUDES) $(ALL_CPPFLAGS) $(ALL_CXXFLAGS) $< $(OUTPUT_OPTION)\n+\n go/%.o: go/gofrontend/%.cc\n \t$(CXX) -c $(GOINCLUDES) $(ALL_CPPFLAGS) $(ALL_CXXFLAGS) $< $(OUTPUT_OPTION)\n "}, {"sha": "f5214dbbb362711e6102594e6f7c93dd4e160db4", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 94, "deletions": 80, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=8afa2bfbdc60088acd7f199245244890a6e7773e", "patch": "@@ -156,7 +156,7 @@ class Gcc_backend : public Backend\n   function_type(const Btyped_identifier&,\n \t\tconst std::vector<Btyped_identifier>&,\n \t\tconst std::vector<Btyped_identifier>&,\n-\t\tsource_location);\n+\t\tconst Location);\n \n   Btype*\n   struct_type(const std::vector<Btyped_identifier>&);\n@@ -165,7 +165,7 @@ class Gcc_backend : public Backend\n   array_type(Btype*, Bexpression*);\n \n   Btype*\n-  placeholder_pointer_type(const std::string&, source_location, bool);\n+  placeholder_pointer_type(const std::string&, Location, bool);\n \n   bool\n   set_placeholder_pointer_type(Btype*, Btype*);\n@@ -174,20 +174,20 @@ class Gcc_backend : public Backend\n   set_placeholder_function_type(Btype*, Btype*);\n \n   Btype*\n-  placeholder_struct_type(const std::string&, source_location);\n+  placeholder_struct_type(const std::string&, Location);\n \n   bool\n   set_placeholder_struct_type(Btype* placeholder,\n \t\t\t      const std::vector<Btyped_identifier>&);\n \n   Btype*\n-  placeholder_array_type(const std::string&, source_location);\n+  placeholder_array_type(const std::string&, Location);\n \n   bool\n   set_placeholder_array_type(Btype*, Btype*, Bexpression*);\n \n   Btype*\n-  named_type(const std::string&, Btype*, source_location);\n+  named_type(const std::string&, Btype*, Location);\n \n   Btype*\n   circular_pointer_type(Btype*, bool);\n@@ -213,21 +213,21 @@ class Gcc_backend : public Backend\n   init_statement(Bvariable* var, Bexpression* init);\n \n   Bstatement*\n-  assignment_statement(Bexpression* lhs, Bexpression* rhs, source_location);\n+  assignment_statement(Bexpression* lhs, Bexpression* rhs, Location);\n \n   Bstatement*\n   return_statement(Bfunction*, const std::vector<Bexpression*>&,\n-\t\t   source_location);\n+\t\t   Location);\n \n   Bstatement*\n   if_statement(Bexpression* condition, Bblock* then_block, Bblock* else_block,\n-\t       source_location);\n+\t       Location);\n \n   Bstatement*\n   switch_statement(Bexpression* value,\n \t\t   const std::vector<std::vector<Bexpression*> >& cases,\n \t\t   const std::vector<Bstatement*>& statements,\n-\t\t   source_location);\n+\t\t   Location);\n \n   Bstatement*\n   compound_statement(Bstatement*, Bstatement*);\n@@ -239,7 +239,7 @@ class Gcc_backend : public Backend\n \n   Bblock*\n   block(Bfunction*, Bblock*, const std::vector<Bvariable*>&,\n-\tsource_location, source_location);\n+\tLocation, Location);\n \n   void\n   block_add_statements(Bblock*, const std::vector<Bstatement*>&);\n@@ -260,46 +260,46 @@ class Gcc_backend : public Backend\n \t\t  Btype* btype,\n \t\t  bool is_external,\n \t\t  bool is_hidden,\n-\t\t  source_location location);\n+\t\t  Location location);\n \n   void\n   global_variable_set_init(Bvariable*, Bexpression*);\n \n   Bvariable*\n   local_variable(Bfunction*, const std::string&, Btype*, bool,\n-\t\t source_location);\n+\t\t Location);\n \n   Bvariable*\n   parameter_variable(Bfunction*, const std::string&, Btype*, bool,\n-\t\t     source_location);\n+\t\t     Location);\n \n   Bvariable*\n   temporary_variable(Bfunction*, Bblock*, Btype*, Bexpression*, bool,\n-\t\t     source_location, Bstatement**);\n+\t\t     Location, Bstatement**);\n \n   Bvariable*\n-  immutable_struct(const std::string&, bool, Btype*, source_location);\n+  immutable_struct(const std::string&, bool, Btype*, Location);\n \n   void\n   immutable_struct_set_init(Bvariable*, const std::string&, bool, Btype*,\n-\t\t\t    source_location, Bexpression*);\n+\t\t\t    Location, Bexpression*);\n \n   Bvariable*\n-  immutable_struct_reference(const std::string&, Btype*, source_location);\n+  immutable_struct_reference(const std::string&, Btype*, Location);\n \n   // Labels.\n \n   Blabel*\n-  label(Bfunction*, const std::string& name, source_location);\n+  label(Bfunction*, const std::string& name, Location);\n \n   Bstatement*\n   label_definition_statement(Blabel*);\n \n   Bstatement*\n-  goto_statement(Blabel*, source_location);\n+  goto_statement(Blabel*, Location);\n \n   Bexpression*\n-  label_address(Blabel*, source_location);\n+  label_address(Blabel*, Location);\n \n  private:\n   // Make a Bexpression from a tree.\n@@ -432,7 +432,7 @@ Btype*\n Gcc_backend::function_type(const Btyped_identifier& receiver,\n \t\t\t   const std::vector<Btyped_identifier>& parameters,\n \t\t\t   const std::vector<Btyped_identifier>& results,\n-\t\t\t   source_location location)\n+\t\t\t   Location location)\n {\n   tree args = NULL_TREE;\n   tree* pp = &args;\n@@ -482,8 +482,8 @@ Gcc_backend::function_type(const Btyped_identifier& receiver,\n \t  if (field_type_tree == error_mark_node)\n \t    return this->error_type();\n \t  gcc_assert(TYPE_SIZE(field_type_tree) != NULL_TREE);\n-\t  tree field = build_decl(location, FIELD_DECL, name_tree,\n-\t\t\t\t  field_type_tree);\n+\t  tree field = build_decl(location.gcc_location(), FIELD_DECL,\n+                                  name_tree, field_type_tree);\n \t  DECL_CONTEXT(field) = result;\n \t  *pp = field;\n \t  pp = &DECL_CHAIN(field);\n@@ -526,7 +526,8 @@ Gcc_backend::fill_in_struct(Btype* fill,\n       tree type_tree = p->btype->get_tree();\n       if (type_tree == error_mark_node)\n \treturn this->error_type();\n-      tree field = build_decl(p->location, FIELD_DECL, name_tree, type_tree);\n+      tree field = build_decl(p->location.gcc_location(), FIELD_DECL, name_tree,\n+                              type_tree);\n       DECL_CONTEXT(field) = fill_tree;\n       *pp = field;\n       pp = &DECL_CHAIN(field);\n@@ -587,12 +588,12 @@ Gcc_backend::fill_in_array(Btype* fill, Btype* element_type,\n \n Btype*\n Gcc_backend::placeholder_pointer_type(const std::string& name,\n-\t\t\t\t      source_location location, bool)\n+\t\t\t\t      Location location, bool)\n {\n   tree ret = build_variant_type_copy(ptr_type_node);\n   if (!name.empty())\n     {\n-      tree decl = build_decl(location, TYPE_DECL,\n+      tree decl = build_decl(location.gcc_location(), TYPE_DECL,\n \t\t\t     get_identifier_from_string(name),\n \t\t\t     ret);\n       TYPE_NAME(ret) = decl;\n@@ -633,10 +634,10 @@ Gcc_backend::set_placeholder_function_type(Btype* placeholder, Btype* ft)\n \n Btype*\n Gcc_backend::placeholder_struct_type(const std::string& name,\n-\t\t\t\t     source_location location)\n+\t\t\t\t     Location location)\n {\n   tree ret = make_node(RECORD_TYPE);\n-  tree decl = build_decl(location, TYPE_DECL,\n+  tree decl = build_decl(location.gcc_location(), TYPE_DECL,\n \t\t\t get_identifier_from_string(name),\n \t\t\t ret);\n   TYPE_NAME(ret) = decl;\n@@ -660,10 +661,10 @@ Gcc_backend::set_placeholder_struct_type(\n \n Btype*\n Gcc_backend::placeholder_array_type(const std::string& name,\n-\t\t\t\t    source_location location)\n+\t\t\t\t    Location location)\n {\n   tree ret = make_node(ARRAY_TYPE);\n-  tree decl = build_decl(location, TYPE_DECL,\n+  tree decl = build_decl(location.gcc_location(), TYPE_DECL,\n \t\t\t get_identifier_from_string(name),\n \t\t\t ret);\n   TYPE_NAME(ret) = decl;\n@@ -687,13 +688,13 @@ Gcc_backend::set_placeholder_array_type(Btype* placeholder,\n \n Btype*\n Gcc_backend::named_type(const std::string& name, Btype* btype,\n-\t\t\tsource_location location)\n+\t\t\tLocation location)\n {\n   tree type = btype->get_tree();\n   if (type == error_mark_node)\n     return this->error_type();\n   type = build_variant_type_copy(type);\n-  tree decl = build_decl(location, TYPE_DECL,\n+  tree decl = build_decl(location.gcc_location(), TYPE_DECL,\n \t\t\t get_identifier_from_string(name),\n \t\t\t type);\n   TYPE_NAME(type) = decl;\n@@ -757,13 +758,14 @@ Gcc_backend::init_statement(Bvariable* var, Bexpression* init)\n \n Bstatement*\n Gcc_backend::assignment_statement(Bexpression* lhs, Bexpression* rhs,\n-\t\t\t\t  source_location location)\n+\t\t\t\t  Location location)\n {\n   tree lhs_tree = lhs->get_tree();\n   tree rhs_tree = rhs->get_tree();\n   if (lhs_tree == error_mark_node || rhs_tree == error_mark_node)\n     return this->error_statement();\n-  return this->make_statement(fold_build2_loc(location, MODIFY_EXPR,\n+  return this->make_statement(fold_build2_loc(location.gcc_location(),\n+                                              MODIFY_EXPR,\n \t\t\t\t\t      void_type_node,\n \t\t\t\t\t      lhs_tree, rhs_tree));\n }\n@@ -773,7 +775,7 @@ Gcc_backend::assignment_statement(Bexpression* lhs, Bexpression* rhs,\n Bstatement*\n Gcc_backend::return_statement(Bfunction* bfunction,\n \t\t\t      const std::vector<Bexpression*>& vals,\n-\t\t\t      source_location location)\n+\t\t\t      Location location)\n {\n   tree fntree = bfunction->get_tree();\n   if (fntree == error_mark_node)\n@@ -783,15 +785,18 @@ Gcc_backend::return_statement(Bfunction* bfunction,\n     return this->error_statement();\n   tree ret;\n   if (vals.empty())\n-    ret = fold_build1_loc(location, RETURN_EXPR, void_type_node, NULL_TREE);\n+    ret = fold_build1_loc(location.gcc_location(), RETURN_EXPR, void_type_node,\n+                          NULL_TREE);\n   else if (vals.size() == 1)\n     {\n       tree val = vals.front()->get_tree();\n       if (val == error_mark_node)\n \treturn this->error_statement();\n-      tree set = fold_build2_loc(location, MODIFY_EXPR, void_type_node,\n-\t\t\t\t result, vals.front()->get_tree());\n-      ret = fold_build1_loc(location, RETURN_EXPR, void_type_node, set);\n+      tree set = fold_build2_loc(location.gcc_location(), MODIFY_EXPR,\n+                                 void_type_node, result,\n+                                 vals.front()->get_tree());\n+      ret = fold_build1_loc(location.gcc_location(), RETURN_EXPR,\n+                            void_type_node, set);\n     }\n   else\n     {\n@@ -808,20 +813,23 @@ Gcc_backend::return_statement(Bfunction* bfunction,\n \t   p++, field = DECL_CHAIN(field))\n \t{\n \t  gcc_assert(field != NULL_TREE);\n-\t  tree ref = fold_build3_loc(location, COMPONENT_REF, TREE_TYPE(field),\n-\t\t\t\t     rettmp, field, NULL_TREE);\n+\t  tree ref = fold_build3_loc(location.gcc_location(), COMPONENT_REF,\n+                                     TREE_TYPE(field), rettmp, field,\n+                                     NULL_TREE);\n \t  tree val = (*p)->get_tree();\n \t  if (val == error_mark_node)\n \t    return this->error_statement();\n-\t  tree set = fold_build2_loc(location, MODIFY_EXPR, void_type_node,\n+\t  tree set = fold_build2_loc(location.gcc_location(), MODIFY_EXPR,\n+                                     void_type_node,\n \t\t\t\t     ref, (*p)->get_tree());\n \t  append_to_statement_list(set, &stmt_list);\n \t}\n       gcc_assert(field == NULL_TREE);\n-      tree set = fold_build2_loc(location, MODIFY_EXPR, void_type_node,\n+      tree set = fold_build2_loc(location.gcc_location(), MODIFY_EXPR,\n+                                 void_type_node,\n \t\t\t\t result, rettmp);\n-      tree ret_expr = fold_build1_loc(location, RETURN_EXPR, void_type_node,\n-\t\t\t\t      set);\n+      tree ret_expr = fold_build1_loc(location.gcc_location(), RETURN_EXPR,\n+                                      void_type_node, set);\n       append_to_statement_list(ret_expr, &stmt_list);\n       ret = stmt_list;\n     }\n@@ -832,7 +840,7 @@ Gcc_backend::return_statement(Bfunction* bfunction,\n \n Bstatement*\n Gcc_backend::if_statement(Bexpression* condition, Bblock* then_block,\n-\t\t\t  Bblock* else_block, source_location location)\n+\t\t\t  Bblock* else_block, Location location)\n {\n   tree cond_tree = condition->get_tree();\n   tree then_tree = then_block->get_tree();\n@@ -841,8 +849,8 @@ Gcc_backend::if_statement(Bexpression* condition, Bblock* then_block,\n       || then_tree == error_mark_node\n       || else_tree == error_mark_node)\n     return this->error_statement();\n-  tree ret = build3_loc(location, COND_EXPR, void_type_node, cond_tree,\n-\t\t\tthen_tree, else_tree);\n+  tree ret = build3_loc(location.gcc_location(), COND_EXPR, void_type_node,\n+                        cond_tree, then_tree, else_tree);\n   return this->make_statement(ret);\n }\n \n@@ -853,7 +861,7 @@ Gcc_backend::switch_statement(\n     Bexpression* value,\n     const std::vector<std::vector<Bexpression*> >& cases,\n     const std::vector<Bstatement*>& statements,\n-    source_location switch_location)\n+    Location switch_location)\n {\n   gcc_assert(cases.size() == statements.size());\n \n@@ -866,8 +874,8 @@ Gcc_backend::switch_statement(\n       if (pc->empty())\n \t{\n \t  source_location loc = (*ps != NULL\n-\t\t\t\t ? EXPR_LOCATION((*ps)->get_tree())\n-\t\t\t\t : UNKNOWN_LOCATION);\n+                                 ? EXPR_LOCATION((*ps)->get_tree())\n+                                 : UNKNOWN_LOCATION);\n \t  tree label = create_artificial_label(loc);\n \t  tree c = build_case_label(NULL_TREE, NULL_TREE, label);\n \t  append_to_statement_list(c, &stmt_list);\n@@ -900,8 +908,8 @@ Gcc_backend::switch_statement(\n   tree tv = value->get_tree();\n   if (tv == error_mark_node)\n     return this->error_statement();\n-  tree t = build3_loc(switch_location, SWITCH_EXPR, void_type_node,\n-\t\t      tv, stmt_list, NULL_TREE);\n+  tree t = build3_loc(switch_location.gcc_location(), SWITCH_EXPR,\n+                      void_type_node, tv, stmt_list, NULL_TREE);\n   return this->make_statement(t);\n }\n \n@@ -948,8 +956,8 @@ Gcc_backend::statement_list(const std::vector<Bstatement*>& statements)\n Bblock*\n Gcc_backend::block(Bfunction* function, Bblock* enclosing,\n \t\t   const std::vector<Bvariable*>& vars,\n-\t\t   source_location start_location,\n-\t\t   source_location)\n+\t\t   Location start_location,\n+\t\t   Location)\n {\n   tree block_tree = make_node(BLOCK);\n   if (enclosing == NULL)\n@@ -1010,8 +1018,9 @@ Gcc_backend::block(Bfunction* function, Bblock* enclosing,\n \n   TREE_USED(block_tree) = 1;\n \n-  tree bind_tree = build3_loc(start_location, BIND_EXPR, void_type_node,\n-\t\t\t      BLOCK_VARS(block_tree), NULL_TREE, block_tree);\n+  tree bind_tree = build3_loc(start_location.gcc_location(), BIND_EXPR,\n+                              void_type_node, BLOCK_VARS(block_tree),\n+                              NULL_TREE, block_tree);\n   TREE_SIDE_EFFECTS(bind_tree) = 1;\n \n   return new Bblock(bind_tree);\n@@ -1057,7 +1066,7 @@ Gcc_backend::global_variable(const std::string& package_name,\n \t\t\t     Btype* btype,\n \t\t\t     bool is_external,\n \t\t\t     bool is_hidden,\n-\t\t\t     source_location location)\n+\t\t\t     Location location)\n {\n   tree type_tree = btype->get_tree();\n   if (type_tree == error_mark_node)\n@@ -1066,7 +1075,7 @@ Gcc_backend::global_variable(const std::string& package_name,\n   std::string var_name(package_name);\n   var_name.push_back('.');\n   var_name.append(name);\n-  tree decl = build_decl(location, VAR_DECL,\n+  tree decl = build_decl(location.gcc_location(), VAR_DECL,\n \t\t\t get_identifier_from_string(var_name),\n \t\t\t type_tree);\n   if (is_external)\n@@ -1109,12 +1118,12 @@ Gcc_backend::global_variable_set_init(Bvariable* var, Bexpression* expr)\n Bvariable*\n Gcc_backend::local_variable(Bfunction* function, const std::string& name,\n \t\t\t    Btype* btype, bool is_address_taken,\n-\t\t\t    source_location location)\n+\t\t\t    Location location)\n {\n   tree type_tree = btype->get_tree();\n   if (type_tree == error_mark_node)\n     return this->error_variable();\n-  tree decl = build_decl(location, VAR_DECL,\n+  tree decl = build_decl(location.gcc_location(), VAR_DECL,\n \t\t\t get_identifier_from_string(name),\n \t\t\t type_tree);\n   DECL_CONTEXT(decl) = function->get_tree();\n@@ -1130,12 +1139,12 @@ Gcc_backend::local_variable(Bfunction* function, const std::string& name,\n Bvariable*\n Gcc_backend::parameter_variable(Bfunction* function, const std::string& name,\n \t\t\t\tBtype* btype, bool is_address_taken,\n-\t\t\t\tsource_location location)\n+\t\t\t\tLocation location)\n {\n   tree type_tree = btype->get_tree();\n   if (type_tree == error_mark_node)\n     return this->error_variable();\n-  tree decl = build_decl(location, PARM_DECL,\n+  tree decl = build_decl(location.gcc_location(), PARM_DECL,\n \t\t\t get_identifier_from_string(name),\n \t\t\t type_tree);\n   DECL_CONTEXT(decl) = function->get_tree();\n@@ -1153,7 +1162,7 @@ Bvariable*\n Gcc_backend::temporary_variable(Bfunction* function, Bblock* bblock,\n \t\t\t\tBtype* btype, Bexpression* binit,\n \t\t\t\tbool is_address_taken,\n-\t\t\t\tsource_location location,\n+\t\t\t\tLocation location,\n \t\t\t\tBstatement** pstatement)\n {\n   tree type_tree = btype->get_tree();\n@@ -1171,7 +1180,7 @@ Gcc_backend::temporary_variable(Bfunction* function, Bblock* bblock,\n   else\n     {\n       gcc_assert(bblock != NULL);\n-      var = build_decl(location, VAR_DECL,\n+      var = build_decl(location.gcc_location(), VAR_DECL,\n \t\t       create_tmp_var_name(\"GOTMP\"),\n \t\t       type_tree);\n       DECL_ARTIFICIAL(var) = 1;\n@@ -1199,12 +1208,14 @@ Gcc_backend::temporary_variable(Bfunction* function, Bblock* bblock,\n     }\n \n   if (init_tree != NULL_TREE)\n-    DECL_INITIAL(var) = fold_convert_loc(location, type_tree, init_tree);\n+    DECL_INITIAL(var) = fold_convert_loc(location.gcc_location(), type_tree,\n+                                         init_tree);\n \n   if (is_address_taken)\n     TREE_ADDRESSABLE(var) = 1;\n \n-  *pstatement = this->make_statement(build1_loc(location, DECL_EXPR,\n+  *pstatement = this->make_statement(build1_loc(location.gcc_location(),\n+                                                DECL_EXPR,\n \t\t\t\t\t\tvoid_type_node, var));\n   return new Bvariable(var);\n }\n@@ -1213,13 +1224,13 @@ Gcc_backend::temporary_variable(Bfunction* function, Bblock* bblock,\n \n Bvariable*\n Gcc_backend::immutable_struct(const std::string& name, bool, Btype* btype,\n-\t\t\t      source_location location)\n+\t\t\t      Location location)\n {\n   tree type_tree = btype->get_tree();\n   if (type_tree == error_mark_node)\n     return this->error_variable();\n   gcc_assert(TREE_CODE(type_tree) == RECORD_TYPE);\n-  tree decl = build_decl(location, VAR_DECL,\n+  tree decl = build_decl(location.gcc_location(), VAR_DECL,\n \t\t\t get_identifier_from_string(name),\n \t\t\t build_qualified_type(type_tree, TYPE_QUAL_CONST));\n   TREE_STATIC(decl) = 1;\n@@ -1241,7 +1252,7 @@ Gcc_backend::immutable_struct(const std::string& name, bool, Btype* btype,\n void\n Gcc_backend::immutable_struct_set_init(Bvariable* var, const std::string&,\n \t\t\t\t       bool is_common, Btype*,\n-\t\t\t\t       source_location,\n+\t\t\t\t       Location,\n \t\t\t\t       Bexpression* initializer)\n {\n   tree decl = var->get_tree();\n@@ -1268,13 +1279,13 @@ Gcc_backend::immutable_struct_set_init(Bvariable* var, const std::string&,\n \n Bvariable*\n Gcc_backend::immutable_struct_reference(const std::string& name, Btype* btype,\n-\t\t\t\t\tsource_location location)\n+\t\t\t\t\tLocation location)\n {\n   tree type_tree = btype->get_tree();\n   if (type_tree == error_mark_node)\n     return this->error_variable();\n   gcc_assert(TREE_CODE(type_tree) == RECORD_TYPE);\n-  tree decl = build_decl(location, VAR_DECL,\n+  tree decl = build_decl(location.gcc_location(), VAR_DECL,\n \t\t\t get_identifier_from_string(name),\n \t\t\t build_qualified_type(type_tree, TYPE_QUAL_CONST));\n   TREE_READONLY(decl) = 1;\n@@ -1290,15 +1301,16 @@ Gcc_backend::immutable_struct_reference(const std::string& name, Btype* btype,\n \n Blabel*\n Gcc_backend::label(Bfunction* function, const std::string& name,\n-\t\t   source_location location)\n+\t\t   Location location)\n {\n   tree decl;\n   if (name.empty())\n-    decl = create_artificial_label(location);\n+    decl = create_artificial_label(location.gcc_location());\n   else\n     {\n       tree id = get_identifier_from_string(name);\n-      decl = build_decl(location, LABEL_DECL, id, void_type_node);\n+      decl = build_decl(location.gcc_location(), LABEL_DECL, id,\n+                        void_type_node);\n       DECL_CONTEXT(decl) = function->get_tree();\n     }\n   return new Blabel(decl);\n@@ -1318,23 +1330,25 @@ Gcc_backend::label_definition_statement(Blabel* label)\n // Make a goto statement.\n \n Bstatement*\n-Gcc_backend::goto_statement(Blabel* label, source_location location)\n+Gcc_backend::goto_statement(Blabel* label, Location location)\n {\n   tree lab = label->get_tree();\n-  tree ret = fold_build1_loc(location, GOTO_EXPR, void_type_node, lab);\n+  tree ret = fold_build1_loc(location.gcc_location(), GOTO_EXPR, void_type_node,\n+                             lab);\n   return this->make_statement(ret);\n }\n \n // Get the address of a label.\n \n Bexpression*\n-Gcc_backend::label_address(Blabel* label, source_location location)\n+Gcc_backend::label_address(Blabel* label, Location location)\n {\n   tree lab = label->get_tree();\n   TREE_USED(lab) = 1;\n   TREE_ADDRESSABLE(lab) = 1;\n-  tree ret = fold_convert_loc(location, ptr_type_node,\n-\t\t\t      build_fold_addr_expr_loc(location, lab));\n+  tree ret = fold_convert_loc(location.gcc_location(), ptr_type_node,\n+\t\t\t      build_fold_addr_expr_loc(location.gcc_location(),\n+                                                       lab));\n   return this->make_expression(ret);\n }\n "}, {"sha": "b41559ed4ca94accbb87eae1f390af6fc5afab04", "filename": "gcc/go/go-linemap.cc", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgo-linemap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgo-linemap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-linemap.cc?ref=8afa2bfbdc60088acd7f199245244890a6e7773e", "patch": "@@ -0,0 +1,126 @@\n+// go-linemap.cc -- GCC implementation of Linemap.\n+\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include \"go-linemap.h\"\n+\n+// This class implements the Linemap interface defined by the\n+// frontend.\n+\n+class Gcc_linemap : public Linemap\n+{\n+ public:\n+  Gcc_linemap()\n+    : Linemap(),\n+      in_file_(false)\n+  { }\n+\n+  void\n+  start_file(const char* file_name, unsigned int line_begin);\n+\n+  void\n+  start_line(unsigned int line_number, unsigned int line_size);\n+\n+  Location\n+  get_location(unsigned int column);\n+\n+  void\n+  stop();\n+\n+ protected:\n+  Location\n+  get_predeclared_location();\n+\n+  Location\n+  get_unknown_location();\n+\n+  bool\n+  is_predeclared(Location);\n+\n+  bool\n+  is_unknown(Location);\n+\n+ private:\n+  // Whether we are currently reading a file.\n+  bool in_file_;\n+};\n+\n+Linemap* Linemap::instance_ = NULL;\n+\n+// Start getting locations from a new file.\n+\n+void\n+Gcc_linemap::start_file(const char *file_name, unsigned line_begin)\n+{\n+  if (this->in_file_)\n+    linemap_add(line_table, LC_LEAVE, 0, NULL, 0);\n+  linemap_add(line_table, LC_ENTER, 0, file_name, line_begin);\n+  this->in_file_ = true;\n+}\n+\n+// Stop getting locations.\n+\n+void\n+Gcc_linemap::stop()\n+{\n+  linemap_add(line_table, LC_LEAVE, 0, NULL, 0);\n+  this->in_file_ = false;\n+}\n+\n+// Start a new line.\n+\n+void\n+Gcc_linemap::start_line(unsigned lineno, unsigned linesize)\n+{\n+  linemap_line_start(line_table, lineno, linesize);\n+}\n+\n+// Get a location.\n+\n+Location\n+Gcc_linemap::get_location(unsigned column)\n+{\n+  return Location(linemap_position_for_column(line_table, column));\n+}\n+\n+// Get the unknown location.\n+\n+Location\n+Gcc_linemap::get_unknown_location()\n+{\n+  return Location(UNKNOWN_LOCATION);\n+}\n+\n+// Get the predeclared location.\n+\n+Location\n+Gcc_linemap::get_predeclared_location()\n+{\n+  return Location(BUILTINS_LOCATION);\n+}\n+\n+// Return whether a location is the predeclared location.\n+\n+bool\n+Gcc_linemap::is_predeclared(Location loc)\n+{\n+  return loc.gcc_location() == BUILTINS_LOCATION;\n+}\n+\n+// Return whether a location is the unknown location.\n+\n+bool\n+Gcc_linemap::is_unknown(Location loc)\n+{\n+  return loc.gcc_location() == UNKNOWN_LOCATION;\n+}\n+\n+// Return the Linemap to use for the gcc backend.\n+\n+Linemap*\n+go_get_linemap()\n+{\n+  return new Gcc_linemap;\n+}"}, {"sha": "f2731d96862456d46b260668a7f53deb3def3cce", "filename": "gcc/go/go-location.h", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgo-location.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgo-location.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-location.h?ref=8afa2bfbdc60088acd7f199245244890a6e7773e", "patch": "@@ -0,0 +1,45 @@\n+// go-location.h -- GCC specific Location declaration.   -*- C++ -*-\n+\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#ifndef GO_LOCATION_H\n+#define GO_LOCATION_H\n+\n+#include \"go-system.h\"\n+\n+// A location in an input source file.\n+\n+class Location\n+{\n+ public:\n+  Location()\n+    : gcc_loc_(UNKNOWN_LOCATION)\n+  { }\n+\n+  explicit Location(source_location loc)\n+    : gcc_loc_(loc)\n+  { }\n+\n+  source_location\n+  gcc_location() const\n+  { return this->gcc_loc_; }\n+\n+  // Temporary hack till error_at and warning_at can deal with a Location.\n+  operator source_location() const\n+  { return this->gcc_loc_; }\n+\n+ private:\n+  source_location gcc_loc_;\n+};\n+\n+// The Go frontend requires the ability to compare Locations.\n+\n+inline bool\n+operator<(Location loca, Location locb)\n+{\n+  return loca.gcc_location() < locb.gcc_location();\n+}\n+\n+#endif // !defined(GO_LOCATION_H)"}, {"sha": "24a0132da9933d5b1ca5bd9ce9ec515cd31d44fa", "filename": "gcc/go/gofrontend/backend.h", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fbackend.h?ref=8afa2bfbdc60088acd7f199245244890a6e7773e", "patch": "@@ -46,14 +46,14 @@ class Backend\n   {\n     std::string name;\n     Btype* btype;\n-    source_location location;\n+    Location location;\n \n     Btyped_identifier()\n       : name(), btype(NULL), location(UNKNOWN_LOCATION)\n     { }\n \n     Btyped_identifier(const std::string& a_name, Btype* a_btype,\n-\t\t     source_location a_location)\n+\t\t     Location a_location)\n       : name(a_name), btype(a_btype), location(a_location)\n     { }\n   };\n@@ -100,7 +100,7 @@ class Backend\n   function_type(const Btyped_identifier& receiver,\n \t\tconst std::vector<Btyped_identifier>& parameters,\n \t\tconst std::vector<Btyped_identifier>& results,\n-\t\tsource_location location) = 0;\n+\t\tLocation location) = 0;\n \n   // Get a struct type.\n   virtual Btype*\n@@ -121,7 +121,7 @@ class Backend\n   // parameter to set_placeholder_pointer_type or\n   // set_placeholder_function_type.\n   virtual Btype*\n-  placeholder_pointer_type(const std::string& name, source_location,\n+  placeholder_pointer_type(const std::string& name, Location,\n \t\t\t   bool for_function) = 0;\n \n   // Fill in a placeholder pointer type as a pointer.  This takes a\n@@ -141,7 +141,7 @@ class Backend\n   // Create a placeholder struct type.  This is used for a named\n   // struct type, as with placeholder_pointer_type.\n   virtual Btype*\n-  placeholder_struct_type(const std::string& name, source_location) = 0;\n+  placeholder_struct_type(const std::string& name, Location) = 0;\n \n   // Fill in a placeholder struct type.  This takes a type returned by\n   // placeholder_struct_type and arranges for it to become a real\n@@ -156,7 +156,7 @@ class Backend\n   // type, as with placeholder_pointer_type, to handle cases like\n   // type A []*A.\n   virtual Btype*\n-  placeholder_array_type(const std::string& name, source_location) = 0;\n+  placeholder_array_type(const std::string& name, Location) = 0;\n \n   // Fill in a placeholder array type.  This takes a type returned by\n   // placeholder_array_type and arranges for it to become a real array\n@@ -172,7 +172,7 @@ class Backend\n   // placeholder_array_type..  (It may be called for a pointer,\n   // struct, or array type in a case like \"type P *byte; type Q P\".)\n   virtual Btype*\n-  named_type(const std::string& name, Btype*, source_location) = 0;\n+  named_type(const std::string& name, Btype*, Location) = 0;\n \n   // Create a marker for a circular pointer type.  Go pointer and\n   // function types can refer to themselves in ways that are not\n@@ -227,18 +227,18 @@ class Backend\n   // Create an assignment statement.\n   virtual Bstatement*\n   assignment_statement(Bexpression* lhs, Bexpression* rhs,\n-\t\t       source_location) = 0;\n+\t\t       Location) = 0;\n \n   // Create a return statement, passing the representation of the\n   // function and the list of values to return.\n   virtual Bstatement*\n   return_statement(Bfunction*, const std::vector<Bexpression*>&,\n-\t\t   source_location) = 0;\n+\t\t   Location) = 0;\n \n   // Create an if statement.  ELSE_BLOCK may be NULL.\n   virtual Bstatement*\n   if_statement(Bexpression* condition, Bblock* then_block, Bblock* else_block,\n-\t       source_location) = 0;\n+\t       Location) = 0;\n \n   // Create a switch statement where the case values are constants.\n   // CASES and STATEMENTS must have the same number of entries.  If\n@@ -251,7 +251,7 @@ class Backend\n   switch_statement(Bexpression* value,\n \t\t   const std::vector<std::vector<Bexpression*> >& cases,\n \t\t   const std::vector<Bstatement*>& statements,\n-\t\t   source_location) = 0;\n+\t\t   Location) = 0;\n \n   // Create a single statement from two statements.\n   virtual Bstatement*\n@@ -276,7 +276,7 @@ class Backend\n   virtual Bblock*\n   block(Bfunction* function, Bblock* enclosing,\n \tconst std::vector<Bvariable*>& vars,\n-\tsource_location start_location, source_location end_location) = 0;\n+\tLocation start_location, Location end_location) = 0;\n \n   // Add the statements to a block.  The block is created first.  Then\n   // the statements are created.  Then the statements are added to the\n@@ -313,7 +313,7 @@ class Backend\n \t\t  Btype* btype,\n \t\t  bool is_external,\n \t\t  bool is_hidden,\n-\t\t  source_location location) = 0;\n+\t\t  Location location) = 0;\n \n   // A global variable will 1) be initialized to zero, or 2) be\n   // initialized to a constant value, or 3) be initialized in the init\n@@ -335,15 +335,15 @@ class Backend\n   // init_statement to set the initial value.\n   virtual Bvariable*\n   local_variable(Bfunction* function, const std::string& name, Btype* type,\n-\t\t bool is_address_taken, source_location location) = 0;\n+\t\t bool is_address_taken, Location location) = 0;\n \n   // Create a function parameter.  This is an incoming parameter, not\n   // a result parameter (result parameters are treated as local\n   // variables).  The arguments are as for local_variable.\n   virtual Bvariable*\n   parameter_variable(Bfunction* function, const std::string& name,\n \t\t     Btype* type, bool is_address_taken,\n-\t\t     source_location location) = 0;\n+\t\t     Location location) = 0;\n \n   // Create a temporary variable.  A temporary variable has no name,\n   // just a type.  We pass in FUNCTION and BLOCK in case they are\n@@ -358,7 +358,7 @@ class Backend\n   // *PSTATEMENT to a statement which initializes the variable.\n   virtual Bvariable*\n   temporary_variable(Bfunction*, Bblock*, Btype*, Bexpression* init,\n-\t\t     bool address_is_taken, source_location location,\n+\t\t     bool address_is_taken, Location location,\n \t\t     Bstatement** pstatement) = 0;\n \n   // Create a named immutable initialized data structure.  This is\n@@ -384,7 +384,7 @@ class Backend\n   // set_immutable_struct_initializer.\n   virtual Bvariable*\n   immutable_struct(const std::string& name, bool is_common, Btype* type,\n-\t\t   source_location) = 0;\n+\t\t   Location) = 0;\n \n   // Set the initial value of a variable created by immutable_struct.\n   // The NAME, IS_COMMON, TYPE, and location parameters are the same\n@@ -395,7 +395,7 @@ class Backend\n   // immutable_struct.\n   virtual void\n   immutable_struct_set_init(Bvariable*, const std::string& name,\n-\t\t\t    bool is_common, Btype* type, source_location,\n+\t\t\t    bool is_common, Btype* type, Location,\n \t\t\t    Bexpression* initializer) = 0;\n \n   // Create a reference to a named immutable initialized data\n@@ -405,15 +405,15 @@ class Backend\n   // corresponds to an extern const global variable in C.\n   virtual Bvariable*\n   immutable_struct_reference(const std::string& name, Btype* type,\n-\t\t\t     source_location) = 0;\n+\t\t\t     Location) = 0;\n \n   // Labels.\n   \n   // Create a new label.  NAME will be empty if this is a label\n   // created by the frontend for a loop construct.  The location is\n   // where the the label is defined.\n   virtual Blabel*\n-  label(Bfunction*, const std::string& name, source_location) = 0;\n+  label(Bfunction*, const std::string& name, Location) = 0;\n \n   // Create a statement which defines a label.  This statement will be\n   // put into the codestream at the point where the label should be\n@@ -423,13 +423,13 @@ class Backend\n \n   // Create a goto statement to a label.\n   virtual Bstatement*\n-  goto_statement(Blabel*, source_location) = 0;\n+  goto_statement(Blabel*, Location) = 0;\n \n   // Create an expression for the address of a label.  This is used to\n   // get the return address of a deferred function which may call\n   // recover.\n   virtual Bexpression*\n-  label_address(Blabel*, source_location) = 0;\n+  label_address(Blabel*, Location) = 0;\n };\n \n // The backend interface has to define this function."}, {"sha": "572ab3631cd5f579b6850918becbec498636b231", "filename": "gcc/go/gofrontend/dataflow.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Fdataflow.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Fdataflow.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fdataflow.cc?ref=8afa2bfbdc60088acd7f199245244890a6e7773e", "patch": "@@ -189,8 +189,8 @@ Dataflow::Compare_vars::operator()(const Named_object* no1,\n     return false;\n \n   // We can have two different variables with the same name.\n-  source_location loc1 = no1->location();\n-  source_location loc2 = no2->location();\n+  Location loc1 = no1->location();\n+  Location loc2 = no2->location();\n   if (loc1 < loc2)\n     return false;\n   if (loc1 > loc2)"}, {"sha": "0832055510c7c51ed98b0ead448e47a50d685947", "filename": "gcc/go/gofrontend/export.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Fexport.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Fexport.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexport.cc?ref=8afa2bfbdc60088acd7f199245244890a6e7773e", "patch": "@@ -279,7 +279,7 @@ Export::write_type(const Type* type)\n       if (named_type != NULL)\n \t{\n \t  // The builtin types should have been predefined.\n-\t  go_assert(named_type->location() != BUILTINS_LOCATION\n+\t  go_assert(!Linemap::is_predeclared_location(named_type->location())\n \t\t     || (named_type->named_object()->package()->name()\n \t\t\t == \"unsafe\"));\n \t  named_object = named_type->named_object();"}, {"sha": "a2cf33eb67b5916f63b0a8978d85405aeabcdd42", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 340, "deletions": 282, "changes": 622, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=8afa2bfbdc60088acd7f199245244890a6e7773e", "patch": "@@ -41,7 +41,7 @@ extern \"C\"\n // Class Expression.\n \n Expression::Expression(Expression_classification classification,\n-\t\t       source_location location)\n+\t\t       Location location)\n   : classification_(classification), location_(location)\n {\n }\n@@ -203,7 +203,7 @@ Expression::determine_type_no_context()\n tree\n Expression::convert_for_assignment(Translate_context* context, Type* lhs_type,\n \t\t\t\t   Type* rhs_type, tree rhs_tree,\n-\t\t\t\t   source_location location)\n+\t\t\t\t   Location location)\n {\n   if (lhs_type == rhs_type)\n     return rhs_tree;\n@@ -283,16 +283,16 @@ Expression::convert_for_assignment(Translate_context* context, Type* lhs_type,\n \t   || INTEGRAL_TYPE_P(lhs_type_tree)\n \t   || SCALAR_FLOAT_TYPE_P(lhs_type_tree)\n \t   || COMPLEX_FLOAT_TYPE_P(lhs_type_tree))\n-    return fold_convert_loc(location, lhs_type_tree, rhs_tree);\n+    return fold_convert_loc(location.gcc_location(), lhs_type_tree, rhs_tree);\n   else if (TREE_CODE(lhs_type_tree) == RECORD_TYPE\n \t   && TREE_CODE(TREE_TYPE(rhs_tree)) == RECORD_TYPE)\n     {\n       // This conversion must be permitted by Go, or we wouldn't have\n       // gotten here.\n       go_assert(int_size_in_bytes(lhs_type_tree)\n \t\t == int_size_in_bytes(TREE_TYPE(rhs_tree)));\n-      return fold_build1_loc(location, VIEW_CONVERT_EXPR, lhs_type_tree,\n-\t\t\t     rhs_tree);\n+      return fold_build1_loc(location.gcc_location(), VIEW_CONVERT_EXPR,\n+                             lhs_type_tree, rhs_tree);\n     }\n   else\n     {\n@@ -307,7 +307,7 @@ Expression::convert_for_assignment(Translate_context* context, Type* lhs_type,\n tree\n Expression::convert_type_to_interface(Translate_context* context,\n \t\t\t\t      Type* lhs_type, Type* rhs_type,\n-\t\t\t\t      tree rhs_tree, source_location location)\n+\t\t\t\t      tree rhs_tree, Location location)\n {\n   Gogo* gogo = context->gogo();\n   Interface_type* lhs_interface_type = lhs_type->interface_type();\n@@ -356,8 +356,8 @@ Expression::convert_type_to_interface(Translate_context* context,\n \tmethod_table =\n \t  rhs_named_type->interface_method_table(gogo, lhs_interface_type,\n \t\t\t\t\t\t is_pointer);\n-      first_field_value = fold_convert_loc(location, const_ptr_type_node,\n-\t\t\t\t\t   method_table);\n+      first_field_value = fold_convert_loc(location.gcc_location(),\n+                                           const_ptr_type_node, method_table);\n     }\n   if (first_field_value == error_mark_node)\n     return error_mark_node;\n@@ -371,7 +371,8 @@ Expression::convert_type_to_interface(Translate_context* context,\n   go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)),\n \t\t    (lhs_is_empty ? \"__type_descriptor\" : \"__methods\")) == 0);\n   elt->index = field;\n-  elt->value = fold_convert_loc(location, TREE_TYPE(field), first_field_value);\n+  elt->value = fold_convert_loc(location.gcc_location(), TREE_TYPE(field),\n+                                first_field_value);\n \n   elt = VEC_quick_push(constructor_elt, init, NULL);\n   field = DECL_CHAIN(field);\n@@ -392,16 +393,17 @@ Expression::convert_type_to_interface(Translate_context* context,\n   tree object_size = TYPE_SIZE_UNIT(TREE_TYPE(rhs_tree));\n \n   tree space = gogo->allocate_memory(rhs_type, object_size, location);\n-  space = fold_convert_loc(location, build_pointer_type(TREE_TYPE(rhs_tree)),\n-\t\t\t   space);\n+  space = fold_convert_loc(location.gcc_location(),\n+                           build_pointer_type(TREE_TYPE(rhs_tree)), space);\n   space = save_expr(space);\n \n-  tree ref = build_fold_indirect_ref_loc(location, space);\n+  tree ref = build_fold_indirect_ref_loc(location.gcc_location(), space);\n   TREE_THIS_NOTRAP(ref) = 1;\n-  tree set = fold_build2_loc(location, MODIFY_EXPR, void_type_node,\n-\t\t\t     ref, rhs_tree);\n+  tree set = fold_build2_loc(location.gcc_location(), MODIFY_EXPR,\n+                             void_type_node, ref, rhs_tree);\n \n-  elt->value = fold_convert_loc(location, TREE_TYPE(field), space);\n+  elt->value = fold_convert_loc(location.gcc_location(), TREE_TYPE(field),\n+                                space);\n \n   return build2(COMPOUND_EXPR, lhs_type_tree, set,\n \t\tbuild_constructor(lhs_type_tree, init));\n@@ -414,7 +416,7 @@ Expression::convert_type_to_interface(Translate_context* context,\n tree\n Expression::get_interface_type_descriptor(Translate_context*,\n \t\t\t\t\t  Type* rhs_type, tree rhs_tree,\n-\t\t\t\t\t  source_location location)\n+\t\t\t\t\t  Location location)\n {\n   tree rhs_type_tree = TREE_TYPE(rhs_tree);\n   go_assert(TREE_CODE(rhs_type_tree) == RECORD_TYPE);\n@@ -432,18 +434,20 @@ Expression::get_interface_type_descriptor(Translate_context*,\n \t     == 0);\n   go_assert(POINTER_TYPE_P(TREE_TYPE(v)));\n   v = save_expr(v);\n-  tree v1 = build_fold_indirect_ref_loc(location, v);\n+  tree v1 = build_fold_indirect_ref_loc(location.gcc_location(), v);\n   go_assert(TREE_CODE(TREE_TYPE(v1)) == RECORD_TYPE);\n   tree f = TYPE_FIELDS(TREE_TYPE(v1));\n   go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(f)), \"__type_descriptor\")\n \t     == 0);\n   v1 = build3(COMPONENT_REF, TREE_TYPE(f), v1, f, NULL_TREE);\n \n-  tree eq = fold_build2_loc(location, EQ_EXPR, boolean_type_node, v,\n-\t\t\t    fold_convert_loc(location, TREE_TYPE(v),\n-\t\t\t\t\t     null_pointer_node));\n-  tree n = fold_convert_loc(location, TREE_TYPE(v1), null_pointer_node);\n-  return fold_build3_loc(location, COND_EXPR, TREE_TYPE(v1),\n+  tree eq = fold_build2_loc(location.gcc_location(), EQ_EXPR, boolean_type_node,\n+                            v, fold_convert_loc(location.gcc_location(),\n+                                                TREE_TYPE(v),\n+                                                null_pointer_node));\n+  tree n = fold_convert_loc(location.gcc_location(), TREE_TYPE(v1),\n+                            null_pointer_node);\n+  return fold_build3_loc(location.gcc_location(), COND_EXPR, TREE_TYPE(v1),\n \t\t\t eq, n, v1);\n }\n \n@@ -454,7 +458,7 @@ tree\n Expression::convert_interface_to_interface(Translate_context* context,\n \t\t\t\t\t   Type *lhs_type, Type *rhs_type,\n \t\t\t\t\t   tree rhs_tree, bool for_type_guard,\n-\t\t\t\t\t   source_location location)\n+\t\t\t\t\t   Location location)\n {\n   Gogo* gogo = context->gogo();\n   Interface_type* lhs_interface_type = lhs_type->interface_type();\n@@ -509,7 +513,8 @@ Expression::convert_interface_to_interface(Translate_context* context,\n \treturn error_mark_node;\n       // This will panic if the interface conversion fails.\n       TREE_NOTHROW(assert_interface_decl) = 0;\n-      elt->value = fold_convert_loc(location, TREE_TYPE(field), call);\n+      elt->value = fold_convert_loc(location.gcc_location(), TREE_TYPE(field),\n+                                    call);\n     }\n   else if (lhs_is_empty)\n     {\n@@ -542,7 +547,8 @@ Expression::convert_interface_to_interface(Translate_context* context,\n \treturn error_mark_node;\n       // This will panic if the interface conversion fails.\n       TREE_NOTHROW(convert_interface_decl) = 0;\n-      elt->value = fold_convert_loc(location, TREE_TYPE(field), call);\n+      elt->value = fold_convert_loc(location.gcc_location(), TREE_TYPE(field),\n+                                    call);\n     }\n \n   // The second field is simply the object pointer.\n@@ -568,7 +574,7 @@ Expression::convert_interface_to_interface(Translate_context* context,\n tree\n Expression::convert_interface_to_type(Translate_context* context,\n \t\t\t\t      Type *lhs_type, Type* rhs_type,\n-\t\t\t\t      tree rhs_tree, source_location location)\n+\t\t\t\t      tree rhs_tree, Location location)\n {\n   Gogo* gogo = context->gogo();\n   tree rhs_type_tree = TREE_TYPE(rhs_tree);\n@@ -621,12 +627,13 @@ Expression::convert_interface_to_type(Translate_context* context,\n   // Otherwise it points to the value.\n   if (lhs_type->points_to() == NULL)\n     {\n-      val = fold_convert_loc(location, build_pointer_type(lhs_type_tree), val);\n-      val = build_fold_indirect_ref_loc(location, val);\n+      val = fold_convert_loc(location.gcc_location(),\n+                             build_pointer_type(lhs_type_tree), val);\n+      val = build_fold_indirect_ref_loc(location.gcc_location(), val);\n     }\n \n   return build2(COMPOUND_EXPR, lhs_type_tree, call,\n-\t\tfold_convert_loc(location, lhs_type_tree, val));\n+\t\tfold_convert_loc(location.gcc_location(), lhs_type_tree, val));\n }\n \n // Convert an expression to a tree.  This is implemented by the child\n@@ -748,14 +755,14 @@ Expression::complex_constant_tree(mpfr_t real, mpfr_t imag, tree type)\n \n tree\n Expression::check_bounds(tree val, tree bound_type, tree sofar,\n-\t\t\t source_location loc)\n+\t\t\t Location loc)\n {\n   tree val_type = TREE_TYPE(val);\n   tree ret = NULL_TREE;\n \n   if (!TYPE_UNSIGNED(val_type))\n     {\n-      ret = fold_build2_loc(loc, LT_EXPR, boolean_type_node, val,\n+      ret = fold_build2_loc(loc.gcc_location(), LT_EXPR, boolean_type_node, val,\n \t\t\t    build_int_cst(val_type, 0));\n       if (ret == boolean_false_node)\n \tret = NULL_TREE;\n@@ -770,23 +777,24 @@ Expression::check_bounds(tree val, tree bound_type, tree sofar,\n \t  && !TYPE_UNSIGNED(bound_type)))\n     {\n       tree max = TYPE_MAX_VALUE(bound_type);\n-      tree big = fold_build2_loc(loc, GT_EXPR, boolean_type_node, val,\n-\t\t\t\t fold_convert_loc(loc, val_type, max));\n+      tree big = fold_build2_loc(loc.gcc_location(), GT_EXPR, boolean_type_node,\n+                                 val, fold_convert_loc(loc.gcc_location(),\n+                                                       val_type, max));\n       if (big == boolean_false_node)\n \t;\n       else if (ret == NULL_TREE)\n \tret = big;\n       else\n-\tret = fold_build2_loc(loc, TRUTH_OR_EXPR, boolean_type_node,\n-\t\t\t      ret, big);\n+\tret = fold_build2_loc(loc.gcc_location(), TRUTH_OR_EXPR,\n+                              boolean_type_node, ret, big);\n     }\n \n   if (ret == NULL_TREE)\n     return sofar;\n   else if (sofar == NULL_TREE)\n     return ret;\n   else\n-    return fold_build2_loc(loc, TRUTH_OR_EXPR, boolean_type_node,\n+    return fold_build2_loc(loc.gcc_location(), TRUTH_OR_EXPR, boolean_type_node,\n \t\t\t   sofar, ret);\n }\n \n@@ -801,7 +809,7 @@ Expression::dump_expression(Ast_dump_context* ast_dump_context) const\n class Error_expression : public Expression\n {\n  public:\n-  Error_expression(source_location location)\n+  Error_expression(Location location)\n     : Expression(EXPRESSION_ERROR, location)\n   { }\n \n@@ -869,7 +877,7 @@ Error_expression::do_dump_expression(Ast_dump_context* ast_dump_context) const\n }\n \n Expression*\n-Expression::make_error(source_location location)\n+Expression::make_error(Location location)\n {\n   return new Error_expression(location);\n }\n@@ -881,7 +889,7 @@ class\n Type_expression : public Expression\n {\n  public:\n-  Type_expression(Type* type, source_location location)\n+  Type_expression(Type* type, Location location)\n     : Expression(EXPRESSION_TYPE, location),\n       type_(type)\n   { }\n@@ -925,7 +933,7 @@ Type_expression::do_dump_expression(Ast_dump_context* ast_dump_context) const\n }\n \n Expression*\n-Expression::make_type(Type* type, source_location location)\n+Expression::make_type(Type* type, Location location)\n {\n   return new Type_expression(type, location);\n }\n@@ -1037,7 +1045,7 @@ Var_expression::do_get_tree(Translate_context* context)\n     go_unreachable();\n   if (is_in_heap)\n     {\n-      ret = build_fold_indirect_ref_loc(this->location(), ret);\n+      ret = build_fold_indirect_ref_loc(this->location().gcc_location(), ret);\n       TREE_THIS_NOTRAP(ret) = 1;\n     }\n   return ret;\n@@ -1054,7 +1062,7 @@ Var_expression::do_dump_expression(Ast_dump_context* ast_dump_context) const\n // Make a reference to a variable in an expression.\n \n Expression*\n-Expression::make_var_reference(Named_object* var, source_location location)\n+Expression::make_var_reference(Named_object* var, Location location)\n {\n   if (var->is_sink())\n     return Expression::make_sink(location);\n@@ -1104,7 +1112,7 @@ Temporary_reference_expression::do_get_tree(Translate_context* context)\n     {\n       Btype* type_btype = this->type()->base()->get_backend(context->gogo());\n       tree type_tree = type_to_tree(type_btype);\n-      ret = fold_convert_loc(this->location(), type_tree, ret);\n+      ret = fold_convert_loc(this->location().gcc_location(), type_tree, ret);\n     }\n   return ret;\n }\n@@ -1122,7 +1130,7 @@ Temporary_reference_expression::do_dump_expression(\n \n Temporary_reference_expression*\n Expression::make_temporary_reference(Temporary_statement* statement,\n-\t\t\t\t     source_location location)\n+\t\t\t\t     Location location)\n {\n   return new Temporary_reference_expression(statement, location);\n }\n@@ -1132,7 +1140,7 @@ Expression::make_temporary_reference(Temporary_statement* statement,\n class Sink_expression : public Expression\n {\n  public:\n-  Sink_expression(source_location location)\n+  Sink_expression(Location location)\n     : Expression(EXPRESSION_SINK, location),\n       type_(NULL), var_(NULL_TREE)\n   { }\n@@ -1210,7 +1218,7 @@ Sink_expression::do_dump_expression(Ast_dump_context* ast_dump_context) const\n // Make a sink expression.\n \n Expression*\n-Expression::make_sink(source_location location)\n+Expression::make_sink(Location location)\n {\n   return new Sink_expression(location);\n }\n@@ -1285,7 +1293,7 @@ Func_expression::get_tree_without_closure(Gogo* gogo)\n   if (fndecl == error_mark_node)\n     return error_mark_node;\n \n-  return build_fold_addr_expr_loc(this->location(), fndecl);\n+  return build_fold_addr_expr_loc(this->location().gcc_location(), fndecl);\n }\n \n // Get the tree for a function expression.  This is used when we take\n@@ -1357,7 +1365,7 @@ Func_expression::do_dump_expression(Ast_dump_context* ast_dump_context) const\n \n Expression*\n Expression::make_func_reference(Named_object* function, Expression* closure,\n-\t\t\t\tsource_location location)\n+\t\t\t\tLocation location)\n {\n   return new Func_expression(function, closure, location);\n }\n@@ -1377,7 +1385,7 @@ Unknown_expression::name() const\n Expression*\n Unknown_expression::do_lower(Gogo*, Named_object*, Statement_inserter*, int)\n {\n-  source_location location = this->location();\n+  Location location = this->location();\n   Named_object* no = this->named_object_;\n   Named_object* real;\n   if (!no->is_unknown())\n@@ -1433,7 +1441,7 @@ Unknown_expression::do_dump_expression(Ast_dump_context* ast_dump_context) const\n // Make a reference to an unknown name.\n \n Expression*\n-Expression::make_unknown_reference(Named_object* no, source_location location)\n+Expression::make_unknown_reference(Named_object* no, Location location)\n {\n   return new Unknown_expression(no, location);\n }\n@@ -1443,7 +1451,7 @@ Expression::make_unknown_reference(Named_object* no, source_location location)\n class Boolean_expression : public Expression\n {\n  public:\n-  Boolean_expression(bool val, source_location location)\n+  Boolean_expression(bool val, Location location)\n     : Expression(EXPRESSION_BOOLEAN, location),\n       val_(val), type_(NULL)\n   { }\n@@ -1528,7 +1536,7 @@ Boolean_expression::do_import(Import* imp)\n // Make a boolean expression.\n \n Expression*\n-Expression::make_boolean(bool val, source_location location)\n+Expression::make_boolean(bool val, Location location)\n {\n   return new Boolean_expression(val, location);\n }\n@@ -1665,7 +1673,7 @@ String_expression::do_dump_expression(Ast_dump_context* ast_dump_context) const\n // Make a string expression.\n \n Expression*\n-Expression::make_string(const std::string& val, source_location location)\n+Expression::make_string(const std::string& val, Location location)\n {\n   return new String_expression(val, location);\n }\n@@ -1675,7 +1683,7 @@ Expression::make_string(const std::string& val, source_location location)\n class Integer_expression : public Expression\n {\n  public:\n-  Integer_expression(const mpz_t* val, Type* type, source_location location)\n+  Integer_expression(const mpz_t* val, Type* type, Location location)\n     : Expression(EXPRESSION_INTEGER, location),\n       type_(type)\n   { mpz_init_set(this->val_, *val); }\n@@ -1685,7 +1693,7 @@ class Integer_expression : public Expression\n \n   // Return whether VAL fits in the type.\n   static bool\n-  check_constant(mpz_t val, Type*, source_location);\n+  check_constant(mpz_t val, Type*, Location);\n \n   // Write VAL to string dump.\n   static void\n@@ -1778,7 +1786,7 @@ Integer_expression::do_determine_type(const Type_context* context)\n \n bool\n Integer_expression::check_constant(mpz_t val, Type* type,\n-\t\t\t\t   source_location location)\n+\t\t\t\t   Location location)\n {\n   if (type == NULL)\n     return true;\n@@ -1985,7 +1993,7 @@ Integer_expression::do_dump_expression(Ast_dump_context* ast_dump_context) const\n \n Expression*\n Expression::make_integer(const mpz_t* val, Type* type,\n-\t\t\t source_location location)\n+\t\t\t Location location)\n {\n   return new Integer_expression(val, type, location);\n }\n@@ -1995,7 +2003,7 @@ Expression::make_integer(const mpz_t* val, Type* type,\n class Float_expression : public Expression\n {\n  public:\n-  Float_expression(const mpfr_t* val, Type* type, source_location location)\n+  Float_expression(const mpfr_t* val, Type* type, Location location)\n     : Expression(EXPRESSION_FLOAT, location),\n       type_(type)\n   {\n@@ -2008,7 +2016,7 @@ class Float_expression : public Expression\n \n   // Return whether VAL fits in the type.\n   static bool\n-  check_constant(mpfr_t val, Type*, source_location);\n+  check_constant(mpfr_t val, Type*, Location);\n \n   // Write VAL to export data.\n   static void\n@@ -2111,7 +2119,7 @@ Float_expression::do_determine_type(const Type_context* context)\n \n bool\n Float_expression::check_constant(mpfr_t val, Type* type,\n-\t\t\t\t source_location location)\n+\t\t\t\t Location location)\n {\n   if (type == NULL)\n     return true;\n@@ -2237,7 +2245,7 @@ Float_expression::do_dump_expression(Ast_dump_context* ast_dump_context) const\n // Make a float expression.\n \n Expression*\n-Expression::make_float(const mpfr_t* val, Type* type, source_location location)\n+Expression::make_float(const mpfr_t* val, Type* type, Location location)\n {\n   return new Float_expression(val, type, location);\n }\n@@ -2248,7 +2256,7 @@ class Complex_expression : public Expression\n {\n  public:\n   Complex_expression(const mpfr_t* real, const mpfr_t* imag, Type* type,\n-\t\t     source_location location)\n+\t\t     Location location)\n     : Expression(EXPRESSION_COMPLEX, location),\n       type_(type)\n   {\n@@ -2262,7 +2270,7 @@ class Complex_expression : public Expression\n \n   // Return whether REAL/IMAG fits in the type.\n   static bool\n-  check_constant(mpfr_t real, mpfr_t imag, Type*, source_location);\n+  check_constant(mpfr_t real, mpfr_t imag, Type*, Location);\n \n   // Write REAL/IMAG to string dump.\n   static void\n@@ -2373,7 +2381,7 @@ Complex_expression::do_determine_type(const Type_context* context)\n \n bool\n Complex_expression::check_constant(mpfr_t real, mpfr_t imag, Type* type,\n-\t\t\t\t   source_location location)\n+\t\t\t\t   Location location)\n {\n   if (type == NULL)\n     return true;\n@@ -2489,7 +2497,7 @@ Complex_expression::do_dump_expression(Ast_dump_context* ast_dump_context) const\n \n Expression*\n Expression::make_complex(const mpfr_t* real, const mpfr_t* imag, Type* type,\n-\t\t\t source_location location)\n+\t\t\t Location location)\n {\n   return new Complex_expression(real, imag, type, location);\n }\n@@ -2525,7 +2533,7 @@ class Find_named_object : public Traverse\n class Const_expression : public Expression\n {\n  public:\n-  Const_expression(Named_object* constant, source_location location)\n+  Const_expression(Named_object* constant, Location location)\n     : Expression(EXPRESSION_CONST_REFERENCE, location),\n       constant_(constant), type_(NULL), seen_(false)\n   { }\n@@ -2982,7 +2990,7 @@ Const_expression::do_dump_expression(Ast_dump_context* ast_dump_context) const\n \n Expression*\n Expression::make_const_reference(Named_object* constant,\n-\t\t\t\t source_location location)\n+\t\t\t\t Location location)\n {\n   return new Const_expression(constant, location);\n }\n@@ -3028,7 +3036,7 @@ Find_named_object::expression(Expression** pexpr)\n class Nil_expression : public Expression\n {\n  public:\n-  Nil_expression(source_location location)\n+  Nil_expression(Location location)\n     : Expression(EXPRESSION_NIL, location)\n   { }\n \n@@ -3077,7 +3085,7 @@ Nil_expression::do_import(Import* imp)\n // Make a nil expression.\n \n Expression*\n-Expression::make_nil(source_location location)\n+Expression::make_nil(Location location)\n {\n   return new Nil_expression(location);\n }\n@@ -3090,7 +3098,7 @@ Expression::make_nil(source_location location)\n class Iota_expression : public Parser_expression\n {\n  public:\n-  Iota_expression(source_location location)\n+  Iota_expression(Location location)\n     : Parser_expression(EXPRESSION_IOTA, location)\n   { }\n \n@@ -3115,7 +3123,7 @@ class Iota_expression : public Parser_expression\n Expression*\n Expression::make_iota()\n {\n-  static Iota_expression iota_expression(UNKNOWN_LOCATION);\n+  static Iota_expression iota_expression(Linemap::unknown_location());\n   return &iota_expression;\n }\n \n@@ -3125,7 +3133,7 @@ class Type_conversion_expression : public Expression\n {\n  public:\n   Type_conversion_expression(Type* type, Expression* expr,\n-\t\t\t     source_location location)\n+\t\t\t     Location location)\n     : Expression(EXPRESSION_CONVERSION, location),\n       type_(type), expr_(expr), may_convert_function_types_(false)\n   { }\n@@ -3234,7 +3242,7 @@ Type_conversion_expression::do_lower(Gogo*, Named_object*,\n {\n   Type* type = this->type_;\n   Expression* val = this->expr_;\n-  source_location location = this->location();\n+  Location location = this->location();\n \n   if (type->integer_type() != NULL)\n     {\n@@ -3632,7 +3640,8 @@ Type_conversion_expression::do_get_tree(Translate_context* context)\n       tree valptr = fold_convert(const_ptr_type_node,\n \t\t\t\t a->value_pointer_tree(gogo, expr_tree));\n       tree len = a->length_tree(gogo, expr_tree);\n-      len = fold_convert_loc(this->location(), integer_type_node, len);\n+      len = fold_convert_loc(this->location().gcc_location(), integer_type_node,\n+                             len);\n       if (e->integer_type()->is_unsigned()\n \t  && e->integer_type()->bits() == 8)\n \t{\n@@ -3702,7 +3711,8 @@ Type_conversion_expression::do_get_tree(Translate_context* context)\n   else if (this->may_convert_function_types_\n \t   && type->function_type() != NULL\n \t   && expr_type->function_type() != NULL)\n-    ret = fold_convert_loc(this->location(), type_tree, expr_tree);\n+    ret = fold_convert_loc(this->location().gcc_location(), type_tree,\n+                           expr_tree);\n   else\n     ret = Expression::convert_for_assignment(context, type, expr_type,\n \t\t\t\t\t     expr_tree, this->location());\n@@ -3750,7 +3760,7 @@ Type_conversion_expression::do_dump_expression(\n // Make a type cast expression.\n \n Expression*\n-Expression::make_cast(Type* type, Expression* val, source_location location)\n+Expression::make_cast(Type* type, Expression* val, Location location)\n {\n   if (type->is_error_type() || val->is_error_expression())\n     return Expression::make_error(location);\n@@ -3763,7 +3773,7 @@ class Unsafe_type_conversion_expression : public Expression\n {\n  public:\n   Unsafe_type_conversion_expression(Type* type, Expression* expr,\n-\t\t\t\t    source_location location)\n+\t\t\t\t    Location location)\n     : Expression(EXPRESSION_UNSAFE_CONVERSION, location),\n       type_(type), expr_(expr)\n   { }\n@@ -3827,7 +3837,7 @@ Unsafe_type_conversion_expression::do_get_tree(Translate_context* context)\n   if (type_tree == error_mark_node || expr_tree == error_mark_node)\n     return error_mark_node;\n \n-  source_location loc = this->location();\n+  Location loc = this->location();\n \n   bool use_view_convert = false;\n   if (t->is_slice_type())\n@@ -3873,9 +3883,10 @@ Unsafe_type_conversion_expression::do_get_tree(Translate_context* context)\n     go_unreachable();\n \n   if (use_view_convert)\n-    return fold_build1_loc(loc, VIEW_CONVERT_EXPR, type_tree, expr_tree);\n+    return fold_build1_loc(loc.gcc_location(), VIEW_CONVERT_EXPR, type_tree,\n+                           expr_tree);\n   else\n-    return fold_convert_loc(loc, type_tree, expr_tree);\n+    return fold_convert_loc(loc.gcc_location(), type_tree, expr_tree);\n }\n \n // Dump ast representation for an unsafe type conversion expression.\n@@ -3894,7 +3905,7 @@ Unsafe_type_conversion_expression::do_dump_expression(\n \n Expression*\n Expression::make_unsafe_cast(Type* type, Expression* expr,\n-\t\t\t     source_location location)\n+\t\t\t     Location location)\n {\n   return new Unsafe_type_conversion_expression(type, expr, location);\n }\n@@ -3904,7 +3915,7 @@ Expression::make_unsafe_cast(Type* type, Expression* expr,\n class Unary_expression : public Expression\n {\n  public:\n-  Unary_expression(Operator op, Expression* expr, source_location location)\n+  Unary_expression(Operator op, Expression* expr, Location location)\n     : Expression(EXPRESSION_UNARY, location),\n       op_(op), escapes_(true), create_temp_(false), expr_(expr)\n   { }\n@@ -3940,7 +3951,7 @@ class Unary_expression : public Expression\n   // could be done, false if not.\n   static bool\n   eval_integer(Operator op, Type* utype, mpz_t uval, mpz_t val,\n-\t       source_location);\n+\t       Location);\n \n   // Apply unary opcode OP to UVAL, setting VAL.  Return true if this\n   // could be done, false if not.\n@@ -4029,7 +4040,7 @@ class Unary_expression : public Expression\n Expression*\n Unary_expression::do_lower(Gogo*, Named_object*, Statement_inserter*, int)\n {\n-  source_location loc = this->location();\n+  Location loc = this->location();\n   Operator op = this->op_;\n   Expression* expr = this->expr_;\n \n@@ -4170,7 +4181,7 @@ Unary_expression::do_is_constant() const\n \n bool\n Unary_expression::eval_integer(Operator op, Type* utype, mpz_t uval, mpz_t val,\n-\t\t\t       source_location location)\n+\t\t\t       Location location)\n {\n   switch (op)\n     {\n@@ -4470,7 +4481,7 @@ Unary_expression::do_get_tree(Translate_context* context)\n   if (expr == error_mark_node)\n     return error_mark_node;\n \n-  source_location loc = this->location();\n+  Location loc = this->location();\n   switch (this->op_)\n     {\n     case OPERATOR_PLUS:\n@@ -4482,7 +4493,7 @@ Unary_expression::do_get_tree(Translate_context* context)\n \ttree compute_type = excess_precision_type(type);\n \tif (compute_type != NULL_TREE)\n \t  expr = ::convert(compute_type, expr);\n-\ttree ret = fold_build1_loc(loc, NEGATE_EXPR,\n+\ttree ret = fold_build1_loc(loc.gcc_location(), NEGATE_EXPR,\n \t\t\t\t   (compute_type != NULL_TREE\n \t\t\t\t    ? compute_type\n \t\t\t\t    : type),\n@@ -4494,13 +4505,15 @@ Unary_expression::do_get_tree(Translate_context* context)\n \n     case OPERATOR_NOT:\n       if (TREE_CODE(TREE_TYPE(expr)) == BOOLEAN_TYPE)\n-\treturn fold_build1_loc(loc, TRUTH_NOT_EXPR, TREE_TYPE(expr), expr);\n+\treturn fold_build1_loc(loc.gcc_location(), TRUTH_NOT_EXPR,\n+                               TREE_TYPE(expr), expr);\n       else\n-\treturn fold_build2_loc(loc, NE_EXPR, boolean_type_node, expr,\n-\t\t\t       build_int_cst(TREE_TYPE(expr), 0));\n+\treturn fold_build2_loc(loc.gcc_location(), NE_EXPR, boolean_type_node,\n+                               expr, build_int_cst(TREE_TYPE(expr), 0));\n \n     case OPERATOR_XOR:\n-      return fold_build1_loc(loc, BIT_NOT_EXPR, TREE_TYPE(expr), expr);\n+      return fold_build1_loc(loc.gcc_location(), BIT_NOT_EXPR, TREE_TYPE(expr),\n+                             expr);\n \n     case OPERATOR_AND:\n       if (!this->create_temp_)\n@@ -4516,7 +4529,7 @@ Unary_expression::do_get_tree(Translate_context* context)\n       // Build a decl for a constant constructor.\n       if (TREE_CODE(expr) == CONSTRUCTOR && TREE_CONSTANT(expr))\n \t{\n-\t  tree decl = build_decl(this->location(), VAR_DECL,\n+\t  tree decl = build_decl(this->location().gcc_location(), VAR_DECL,\n \t\t\t\t create_tmp_var_name(\"C\"), TREE_TYPE(expr));\n \t  DECL_EXTERNAL(decl) = 0;\n \t  TREE_PUBLIC(decl) = 0;\n@@ -4540,13 +4553,14 @@ Unary_expression::do_get_tree(Translate_context* context)\n \t  DECL_IGNORED_P(tmp) = 1;\n \t  DECL_INITIAL(tmp) = expr;\n \t  TREE_ADDRESSABLE(tmp) = 1;\n-\t  return build2_loc(loc, COMPOUND_EXPR,\n+\t  return build2_loc(loc.gcc_location(), COMPOUND_EXPR,\n \t\t\t    build_pointer_type(TREE_TYPE(expr)),\n-\t\t\t    build1_loc(loc, DECL_EXPR, void_type_node, tmp),\n-\t\t\t    build_fold_addr_expr_loc(loc, tmp));\n+\t\t\t    build1_loc(loc.gcc_location(), DECL_EXPR,\n+                                       void_type_node, tmp),\n+\t\t\t    build_fold_addr_expr_loc(loc.gcc_location(), tmp));\n \t}\n \n-      return build_fold_addr_expr_loc(loc, expr);\n+      return build_fold_addr_expr_loc(loc.gcc_location(), expr);\n \n     case OPERATOR_MULT:\n       {\n@@ -4561,15 +4575,18 @@ Unary_expression::do_get_tree(Translate_context* context)\n \t  {\n \t    if (!DECL_P(expr))\n \t      expr = save_expr(expr);\n-\t    tree compare = fold_build2_loc(loc, EQ_EXPR, boolean_type_node,\n+\t    tree compare = fold_build2_loc(loc.gcc_location(), EQ_EXPR,\n+                                           boolean_type_node,\n \t\t\t\t\t   expr,\n \t\t\t\t\t   fold_convert(TREE_TYPE(expr),\n \t\t\t\t\t\t\tnull_pointer_node));\n \t    tree crash = Gogo::runtime_error(RUNTIME_ERROR_NIL_DEREFERENCE,\n \t\t\t\t\t     loc);\n-\t    expr = fold_build2_loc(loc, COMPOUND_EXPR, TREE_TYPE(expr),\n-\t\t\t\t   build3(COND_EXPR, void_type_node,\n-\t\t\t\t\t  compare, crash, NULL_TREE),\n+\t    expr = fold_build2_loc(loc.gcc_location(), COMPOUND_EXPR,\n+                                   TREE_TYPE(expr), build3(COND_EXPR,\n+                                                           void_type_node,\n+                                                           compare, crash,\n+                                                           NULL_TREE),\n \t\t\t\t   expr);\n \t  }\n \n@@ -4579,10 +4596,11 @@ Unary_expression::do_get_tree(Translate_context* context)\n \t  {\n \t    Type* pt = this->expr_->type()->points_to();\n \t    tree ind = type_to_tree(pt->get_backend(context->gogo()));\n-\t    expr = fold_convert_loc(loc, build_pointer_type(ind), expr);\n+\t    expr = fold_convert_loc(loc.gcc_location(),\n+                                    build_pointer_type(ind), expr);\n \t  }\n \n-\treturn build_fold_indirect_ref_loc(loc, expr);\n+\treturn build_fold_indirect_ref_loc(loc.gcc_location(), expr);\n       }\n \n     default:\n@@ -4659,7 +4677,7 @@ Unary_expression::do_dump_expression(Ast_dump_context* ast_dump_context) const\n // Make a unary expression.\n \n Expression*\n-Expression::make_unary(Operator op, Expression* expr, source_location location)\n+Expression::make_unary(Operator op, Expression* expr, Location location)\n {\n   return new Unary_expression(op, expr, location);\n }\n@@ -4807,7 +4825,7 @@ Binary_expression::compare_complex(Operator op, Type* type,\n bool\n Binary_expression::eval_integer(Operator op, Type* left_type, mpz_t left_val,\n \t\t\t\tType* right_type, mpz_t right_val,\n-\t\t\t\tsource_location location, mpz_t val)\n+\t\t\t\tLocation location, mpz_t val)\n {\n   bool is_shift_op = false;\n   switch (op)\n@@ -4947,7 +4965,7 @@ Binary_expression::eval_integer(Operator op, Type* left_type, mpz_t left_val,\n bool\n Binary_expression::eval_float(Operator op, Type* left_type, mpfr_t left_val,\n \t\t\t      Type* right_type, mpfr_t right_val,\n-\t\t\t      mpfr_t val, source_location location)\n+\t\t\t      mpfr_t val, Location location)\n {\n   switch (op)\n     {\n@@ -5030,7 +5048,7 @@ Binary_expression::eval_complex(Operator op, Type* left_type,\n \t\t\t\tType *right_type,\n \t\t\t\tmpfr_t right_real, mpfr_t right_imag,\n \t\t\t\tmpfr_t real, mpfr_t imag,\n-\t\t\t\tsource_location location)\n+\t\t\t\tLocation location)\n {\n   switch (op)\n     {\n@@ -5391,7 +5409,7 @@ Binary_expression::eval_complex(Operator op, Type* left_type,\n Expression*\n Binary_expression::do_lower(Gogo*, Named_object*, Statement_inserter*, int)\n {\n-  source_location location = this->location();\n+  Location location = this->location();\n   Operator op = this->op_;\n   Expression* left = this->left_;\n   Expression* right = this->right_;\n@@ -6048,7 +6066,7 @@ Binary_expression::do_determine_type(const Type_context* context)\n \n bool\n Binary_expression::check_operator_type(Operator op, Type* type,\n-\t\t\t\t       source_location location)\n+\t\t\t\t       Location location)\n {\n   switch (op)\n     {\n@@ -6222,7 +6240,7 @@ Binary_expression::do_check_types(Gogo*)\n \t\t{\n \t\t  this->report_error(_(\"negative shift count\"));\n \t\t  mpz_set_ui(val, 0);\n-\t\t  source_location rloc = this->right_->location();\n+\t\t  Location rloc = this->right_->location();\n \t\t  this->right_ = Expression::make_integer(&val, right_type,\n \t\t\t\t\t\t\t  rloc);\n \t\t}\n@@ -6354,12 +6372,13 @@ Binary_expression::do_get_tree(Translate_context* context)\n \t  if (eval_saved == NULL_TREE)\n \t    eval_saved = right;\n \t  else\n-\t    eval_saved = fold_build2_loc(this->location(), COMPOUND_EXPR,\n+\t    eval_saved = fold_build2_loc(this->location().gcc_location(),\n+                                         COMPOUND_EXPR,\n \t\t\t\t\t void_type_node, eval_saved, right);\n \t}\n     }\n \n-  tree ret = fold_build2_loc(this->location(),\n+  tree ret = fold_build2_loc(this->location().gcc_location(),\n \t\t\t     code,\n \t\t\t     compute_type != NULL_TREE ? compute_type : type,\n \t\t\t     left, right);\n@@ -6378,35 +6397,38 @@ Binary_expression::do_get_tree(Translate_context* context)\n       tree compare = fold_build2(LT_EXPR, boolean_type_node, right,\n \t\t\t\t build_int_cst_type(TREE_TYPE(right), bits));\n \n-      tree overflow_result = fold_convert_loc(this->location(),\n+      tree overflow_result = fold_convert_loc(this->location().gcc_location(),\n \t\t\t\t\t      TREE_TYPE(left),\n \t\t\t\t\t      integer_zero_node);\n       if (this->op_ == OPERATOR_RSHIFT\n \t  && !this->left_->type()->integer_type()->is_unsigned())\n \t{\n-\t  tree neg = fold_build2_loc(this->location(), LT_EXPR,\n-\t\t\t\t     boolean_type_node, left,\n-\t\t\t\t     fold_convert_loc(this->location(),\n-\t\t\t\t\t\t      TREE_TYPE(left),\n-\t\t\t\t\t\t      integer_zero_node));\n-\t  tree neg_one = fold_build2_loc(this->location(),\n-\t\t\t\t\t MINUS_EXPR, TREE_TYPE(left),\n-\t\t\t\t\t fold_convert_loc(this->location(),\n-\t\t\t\t\t\t\t  TREE_TYPE(left),\n-\t\t\t\t\t\t\t  integer_zero_node),\n-\t\t\t\t\t fold_convert_loc(this->location(),\n-\t\t\t\t\t\t\t  TREE_TYPE(left),\n-\t\t\t\t\t\t\t  integer_one_node));\n-\t  overflow_result = fold_build3_loc(this->location(), COND_EXPR,\n-\t\t\t\t\t    TREE_TYPE(left), neg, neg_one,\n-\t\t\t\t\t    overflow_result);\n-\t}\n-\n-      ret = fold_build3_loc(this->location(), COND_EXPR, TREE_TYPE(left),\n-\t\t\t    compare, ret, overflow_result);\n+\t  tree neg =\n+            fold_build2_loc(this->location().gcc_location(), LT_EXPR,\n+                            boolean_type_node, left,\n+                            fold_convert_loc(this->location().gcc_location(),\n+                                             TREE_TYPE(left),\n+                                             integer_zero_node));\n+\t  tree neg_one =\n+            fold_build2_loc(this->location().gcc_location(),\n+                            MINUS_EXPR, TREE_TYPE(left),\n+                            fold_convert_loc(this->location().gcc_location(),\n+                                             TREE_TYPE(left),\n+                                             integer_zero_node),\n+                            fold_convert_loc(this->location().gcc_location(),\n+                                             TREE_TYPE(left),\n+                                             integer_one_node));\n+\t  overflow_result =\n+            fold_build3_loc(this->location().gcc_location(), COND_EXPR,\n+                            TREE_TYPE(left), neg, neg_one,\n+                            overflow_result);\n+\t}\n+\n+      ret = fold_build3_loc(this->location().gcc_location(), COND_EXPR,\n+                            TREE_TYPE(left), compare, ret, overflow_result);\n \n       if (eval_saved != NULL_TREE)\n-\tret = fold_build2_loc(this->location(), COMPOUND_EXPR,\n+\tret = fold_build2_loc(this->location().gcc_location(), COMPOUND_EXPR,\n \t\t\t      TREE_TYPE(ret), eval_saved, ret);\n     }\n \n@@ -6622,7 +6644,7 @@ Binary_expression::do_dump_expression(Ast_dump_context* ast_dump_context) const\n \n Expression*\n Expression::make_binary(Operator op, Expression* left, Expression* right,\n-\t\t\tsource_location location)\n+\t\t\tLocation location)\n {\n   return new Binary_expression(op, left, right, location);\n }\n@@ -6633,7 +6655,7 @@ tree\n Expression::comparison_tree(Translate_context* context, Operator op,\n \t\t\t    Type* left_type, tree left_tree,\n \t\t\t    Type* right_type, tree right_tree,\n-\t\t\t    source_location location)\n+\t\t\t    Location location)\n {\n   enum tree_code code;\n   switch (op)\n@@ -6702,7 +6724,7 @@ Expression::comparison_tree(Translate_context* context, Operator op,\n       else if (TREE_ADDRESSABLE(TREE_TYPE(right_tree)) || DECL_P(right_tree))\n \t{\n \t  make_tmp = NULL_TREE;\n-\t  arg = build_fold_addr_expr_loc(location, right_tree);\n+\t  arg = build_fold_addr_expr_loc(location.gcc_location(), right_tree);\n \t  if (DECL_P(right_tree))\n \t    TREE_ADDRESSABLE(right_tree) = 1;\n \t}\n@@ -6714,10 +6736,10 @@ Expression::comparison_tree(Translate_context* context, Operator op,\n \t  DECL_INITIAL(tmp) = right_tree;\n \t  TREE_ADDRESSABLE(tmp) = 1;\n \t  make_tmp = build1(DECL_EXPR, void_type_node, tmp);\n-\t  SET_EXPR_LOCATION(make_tmp, location);\n-\t  arg = build_fold_addr_expr_loc(location, tmp);\n+\t  SET_EXPR_LOCATION(make_tmp, location.gcc_location());\n+\t  arg = build_fold_addr_expr_loc(location.gcc_location(), tmp);\n \t}\n-      arg = fold_convert_loc(location, ptr_type_node, arg);\n+      arg = fold_convert_loc(location.gcc_location(), ptr_type_node, arg);\n \n       tree descriptor = right_type->type_descriptor_pointer(context->gogo(),\n \t\t\t\t\t\t\t    location);\n@@ -6872,7 +6894,7 @@ Expression::comparison_tree(Translate_context* context, Operator op,\n \n   tree ret = fold_build2(code, boolean_type_node, left_tree, right_tree);\n   if (CAN_HAVE_LOCATION_P(ret))\n-    SET_EXPR_LOCATION(ret, location);\n+    SET_EXPR_LOCATION(ret, location.gcc_location());\n   return ret;\n }\n \n@@ -6972,7 +6994,7 @@ Bound_method_expression::do_dump_expression(Ast_dump_context* ast_dump_context)\n \n Bound_method_expression*\n Expression::make_bound_method(Expression* expr, Named_object* method,\n-\t\t\t      source_location location)\n+\t\t\t      Location location)\n {\n   return new Bound_method_expression(expr, method, location);\n }\n@@ -6984,7 +7006,7 @@ class Builtin_call_expression : public Call_expression\n {\n  public:\n   Builtin_call_expression(Gogo* gogo, Expression* fn, Expression_list* args,\n-\t\t\t  bool is_varargs, source_location location);\n+\t\t\t  bool is_varargs, Location location);\n \n  protected:\n   // This overrides Call_expression::do_lower.\n@@ -7097,7 +7119,7 @@ Builtin_call_expression::Builtin_call_expression(Gogo* gogo,\n \t\t\t\t\t\t Expression* fn,\n \t\t\t\t\t\t Expression_list* args,\n \t\t\t\t\t\t bool is_varargs,\n-\t\t\t\t\t\t source_location location)\n+\t\t\t\t\t\t Location location)\n   : Call_expression(fn, args, is_varargs, location),\n     gogo_(gogo), code_(BUILTIN_INVALID), seen_(false)\n {\n@@ -7209,7 +7231,7 @@ Builtin_call_expression::do_lower(Gogo* gogo, Named_object* function,\n   if (this->classification() == EXPRESSION_ERROR)\n     return this;\n \n-  source_location loc = this->location();\n+  Location loc = this->location();\n \n   if (this->is_varargs() && this->code_ != BUILTIN_APPEND)\n     {\n@@ -7369,7 +7391,7 @@ Builtin_call_expression::do_lower(Gogo* gogo, Named_object* function,\n Expression*\n Builtin_call_expression::lower_make()\n {\n-  source_location loc = this->location();\n+  Location loc = this->location();\n \n   const Expression_list* args = this->args();\n   if (args == NULL || args->size() < 1)\n@@ -7448,7 +7470,7 @@ Builtin_call_expression::lower_make()\n       return Expression::make_error(this->location());\n     }\n \n-  source_location type_loc = first_arg->location();\n+  Location type_loc = first_arg->location();\n   Expression* type_arg;\n   if (is_slice || is_chan)\n     type_arg = Expression::make_type_descriptor(type, type_loc);\n@@ -7937,7 +7959,7 @@ Builtin_call_expression::do_type()\n       return Type::make_void_type();\n \n     case BUILTIN_RECOVER:\n-      return Type::make_interface_type(NULL, BUILTINS_LOCATION);\n+      return Type::make_interface_type(NULL, Linemap::predeclared_location());\n \n     case BUILTIN_APPEND:\n       {\n@@ -8352,7 +8374,7 @@ tree\n Builtin_call_expression::do_get_tree(Translate_context* context)\n {\n   Gogo* gogo = context->gogo();\n-  source_location location = this->location();\n+  Location location = this->location();\n   switch (this->code_)\n     {\n     case BUILTIN_INVALID:\n@@ -8523,7 +8545,8 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \t\t    fnname = \"__go_print_uint64\";\n \t\t    Type* itype = Type::lookup_integer_type(\"uint64\");\n \t\t    Btype* bitype = itype->get_backend(gogo);\n-\t\t    arg = fold_convert_loc(location, type_to_tree(bitype), arg);\n+\t\t    arg = fold_convert_loc(location.gcc_location(),\n+                                           type_to_tree(bitype), arg);\n \t\t  }\n \t\telse if (type->integer_type() != NULL)\n \t\t  {\n@@ -8532,22 +8555,24 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \t\t    fnname = \"__go_print_int64\";\n \t\t    Type* itype = Type::lookup_integer_type(\"int64\");\n \t\t    Btype* bitype = itype->get_backend(gogo);\n-\t\t    arg = fold_convert_loc(location, type_to_tree(bitype), arg);\n+\t\t    arg = fold_convert_loc(location.gcc_location(),\n+                                           type_to_tree(bitype), arg);\n \t\t  }\n \t\telse if (type->float_type() != NULL)\n \t\t  {\n \t\t    static tree print_double_fndecl;\n \t\t    pfndecl = &print_double_fndecl;\n \t\t    fnname = \"__go_print_double\";\n-\t\t    arg = fold_convert_loc(location, double_type_node, arg);\n+\t\t    arg = fold_convert_loc(location.gcc_location(),\n+                                           double_type_node, arg);\n \t\t  }\n \t\telse if (type->complex_type() != NULL)\n \t\t  {\n \t\t    static tree print_complex_fndecl;\n \t\t    pfndecl = &print_complex_fndecl;\n \t\t    fnname = \"__go_print_complex\";\n-\t\t    arg = fold_convert_loc(location, complex_double_type_node,\n-\t\t\t\t\t   arg);\n+\t\t    arg = fold_convert_loc(location.gcc_location(),\n+                                           complex_double_type_node, arg);\n \t\t  }\n \t\telse if (type->is_boolean_type())\n \t\t  {\n@@ -8563,7 +8588,8 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \t\t    static tree print_pointer_fndecl;\n \t\t    pfndecl = &print_pointer_fndecl;\n \t\t    fnname = \"__go_print_pointer\";\n-\t\t    arg = fold_convert_loc(location, ptr_type_node, arg);\n+\t\t    arg = fold_convert_loc(location.gcc_location(),\n+                                           ptr_type_node, arg);\n \t\t  }\n \t\telse if (type->interface_type() != NULL)\n \t\t  {\n@@ -8626,7 +8652,8 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \ttree arg_tree = arg->get_tree(context);\n \tif (arg_tree == error_mark_node)\n \t  return error_mark_node;\n-\tType *empty = Type::make_interface_type(NULL, BUILTINS_LOCATION);\n+\tType *empty =\n+\t  Type::make_interface_type(NULL, Linemap::predeclared_location());\n \targ_tree = Expression::convert_for_assignment(context, empty,\n \t\t\t\t\t\t      arg->type(),\n \t\t\t\t\t\t      arg_tree, location);\n@@ -8658,7 +8685,8 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \tif (arg_tree == error_mark_node)\n \t  return error_mark_node;\n \n-\tType *empty = Type::make_interface_type(NULL, BUILTINS_LOCATION);\n+\tType *empty =\n+\t  Type::make_interface_type(NULL, Linemap::predeclared_location());\n \ttree empty_tree = type_to_tree(empty->get_backend(context->gogo()));\n \n \tType* nil_type = Type::make_nil_type();\n@@ -8694,8 +8722,8 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \t  }\n \tif (call == error_mark_node)\n \t  return error_mark_node;\n-\treturn fold_build3_loc(location, COND_EXPR, empty_tree, arg_tree,\n-\t\t\t       call, empty_nil_tree);\n+\treturn fold_build3_loc(location.gcc_location(), COND_EXPR, empty_tree,\n+                               arg_tree, call, empty_nil_tree);\n       }\n \n     case BUILTIN_CLOSE:\n@@ -8777,9 +8805,10 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \n \targ1_len = save_expr(arg1_len);\n \targ2_len = save_expr(arg2_len);\n-\ttree len = fold_build3_loc(location, COND_EXPR, TREE_TYPE(arg1_len),\n-\t\t\t\t   fold_build2_loc(location, LT_EXPR,\n-\t\t\t\t\t\t   boolean_type_node,\n+\ttree len = fold_build3_loc(location.gcc_location(), COND_EXPR,\n+                                   TREE_TYPE(arg1_len),\n+\t\t\t\t   fold_build2_loc(location.gcc_location(),\n+                                                   LT_EXPR, boolean_type_node,\n \t\t\t\t\t\t   arg1_len, arg2_len),\n \t\t\t\t   arg1_len, arg2_len);\n \tlen = save_expr(len);\n@@ -8790,15 +8819,18 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \tif (element_type_tree == error_mark_node)\n \t  return error_mark_node;\n \ttree element_size = TYPE_SIZE_UNIT(element_type_tree);\n-\ttree bytecount = fold_convert_loc(location, TREE_TYPE(element_size),\n-\t\t\t\t\t  len);\n-\tbytecount = fold_build2_loc(location, MULT_EXPR,\n+\ttree bytecount = fold_convert_loc(location.gcc_location(),\n+                                          TREE_TYPE(element_size), len);\n+\tbytecount = fold_build2_loc(location.gcc_location(), MULT_EXPR,\n \t\t\t\t    TREE_TYPE(element_size),\n \t\t\t\t    bytecount, element_size);\n-\tbytecount = fold_convert_loc(location, size_type_node, bytecount);\n+\tbytecount = fold_convert_loc(location.gcc_location(), size_type_node,\n+                                     bytecount);\n \n-\targ1_val = fold_convert_loc(location, ptr_type_node, arg1_val);\n-\targ2_val = fold_convert_loc(location, ptr_type_node, arg2_val);\n+\targ1_val = fold_convert_loc(location.gcc_location(), ptr_type_node,\n+                                    arg1_val);\n+\targ2_val = fold_convert_loc(location.gcc_location(), ptr_type_node,\n+                                    arg2_val);\n \n \tstatic tree copy_fndecl;\n \ttree call = Gogo::call_builtin(&copy_fndecl,\n@@ -8815,8 +8847,8 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \tif (call == error_mark_node)\n \t  return error_mark_node;\n \n-\treturn fold_build2_loc(location, COMPOUND_EXPR, TREE_TYPE(len),\n-\t\t\t       call, len);\n+\treturn fold_build2_loc(location.gcc_location(), COMPOUND_EXPR,\n+                               TREE_TYPE(len), call, len);\n       }\n \n     case BUILTIN_APPEND:\n@@ -8866,9 +8898,11 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \t     element_size = TYPE_SIZE_UNIT(element_type_tree);\n \t  }\n \n-\targ2_val = fold_convert_loc(location, ptr_type_node, arg2_val);\n-\targ2_len = fold_convert_loc(location, size_type_node, arg2_len);\n-\telement_size = fold_convert_loc(location, size_type_node,\n+\targ2_val = fold_convert_loc(location.gcc_location(), ptr_type_node,\n+                                    arg2_val);\n+\targ2_len = fold_convert_loc(location.gcc_location(), size_type_node,\n+                                    arg2_len);\n+\telement_size = fold_convert_loc(location.gcc_location(), size_type_node,\n \t\t\t\t\telement_size);\n \n \tif (arg2_val == error_mark_node\n@@ -8905,11 +8939,11 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \t  return error_mark_node;\n \tgo_assert(COMPLEX_FLOAT_TYPE_P(TREE_TYPE(arg_tree)));\n \tif (this->code_ == BUILTIN_REAL)\n-\t  return fold_build1_loc(location, REALPART_EXPR,\n+\t  return fold_build1_loc(location.gcc_location(), REALPART_EXPR,\n \t\t\t\t TREE_TYPE(TREE_TYPE(arg_tree)),\n \t\t\t\t arg_tree);\n \telse\n-\t  return fold_build1_loc(location, IMAGPART_EXPR,\n+\t  return fold_build1_loc(location.gcc_location(), IMAGPART_EXPR,\n \t\t\t\t TREE_TYPE(TREE_TYPE(arg_tree)),\n \t\t\t\t arg_tree);\n       }\n@@ -8925,7 +8959,7 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \tgo_assert(TYPE_MAIN_VARIANT(TREE_TYPE(r))\n \t\t   == TYPE_MAIN_VARIANT(TREE_TYPE(i)));\n \tgo_assert(SCALAR_FLOAT_TYPE_P(TREE_TYPE(r)));\n-\treturn fold_build2_loc(location, COMPLEX_EXPR,\n+\treturn fold_build2_loc(location.gcc_location(), COMPLEX_EXPR,\n \t\t\t       build_complex_type(TREE_TYPE(r)),\n \t\t\t       r, i);\n       }\n@@ -9013,7 +9047,7 @@ Expression*\n Call_expression::do_lower(Gogo* gogo, Named_object* function,\n \t\t\t  Statement_inserter* inserter, int)\n {\n-  source_location loc = this->location();\n+  Location loc = this->location();\n \n   // A type cast can look like a function call.\n   if (this->fn_->is_type_expression()\n@@ -9160,7 +9194,7 @@ Call_expression::lower_varargs(Gogo* gogo, Named_object* function,\n   if (this->varargs_are_lowered_)\n     return;\n \n-  source_location loc = this->location();\n+  Location loc = this->location();\n \n   go_assert(param_count > 0);\n   go_assert(varargs_type->is_slice_type());\n@@ -9211,7 +9245,7 @@ Call_expression::lower_varargs(Gogo* gogo, Named_object* function,\n \t    {\n \t      // Check types here so that we get a better message.\n \t      Type* patype = (*pa)->type();\n-\t      source_location paloc = (*pa)->location();\n+\t      Location paloc = (*pa)->location();\n \t      if (!this->check_argument_type(i, element_type, patype,\n \t\t\t\t\t     paloc, issued_error))\n \t\tcontinue;\n@@ -9410,7 +9444,7 @@ Call_expression::determining_types()\n bool\n Call_expression::check_argument_type(int i, const Type* parameter_type,\n \t\t\t\t     const Type* argument_type,\n-\t\t\t\t     source_location argument_location,\n+\t\t\t\t     Location argument_location,\n \t\t\t\t     bool issued_error)\n {\n   std::string reason;\n@@ -9559,7 +9593,7 @@ Call_expression::do_get_tree(Translate_context* context)\n     return error_mark_node;\n \n   Gogo* gogo = context->gogo();\n-  source_location location = this->location();\n+  Location location = this->location();\n \n   Func_expression* func = this->fn_->func_expression();\n   Interface_field_reference_expression* interface_method =\n@@ -9652,7 +9686,7 @@ Call_expression::do_get_tree(Translate_context* context)\n       tree fnt = type_to_tree(fntype->get_backend(gogo));\n       if (fnt == error_mark_node)\n \treturn error_mark_node;\n-      fn = fold_convert_loc(location, fnt, fn);\n+      fn = fold_convert_loc(location.gcc_location(), fnt, fn);\n     }\n \n   // This is to support builtin math functions when using 80387 math.\n@@ -9675,7 +9709,8 @@ Call_expression::do_get_tree(Translate_context* context)\n \t    excess_type = NULL_TREE;\n \t  else\n \t    {\n-\t      fn = build_fold_addr_expr_loc(location, excess_fndecl);\n+\t      fn = build_fold_addr_expr_loc(location.gcc_location(),\n+                                            excess_fndecl);\n \t      for (int i = 0; i < nargs; ++i)\n \t\targs[i] = ::convert(excess_type, args[i]);\n \t    }\n@@ -9686,7 +9721,7 @@ Call_expression::do_get_tree(Translate_context* context)\n \t\t\t      fn, nargs, args);\n   delete[] args;\n \n-  SET_EXPR_LOCATION(ret, location);\n+  SET_EXPR_LOCATION(ret, location.gcc_location());\n \n   if (has_closure)\n     {\n@@ -9702,7 +9737,7 @@ Call_expression::do_get_tree(Translate_context* context)\n   if (TREE_TYPE(ret) == ptr_type_node)\n     {\n       tree t = type_to_tree(this->type()->base()->get_backend(gogo));\n-      ret = fold_convert_loc(location, t, ret);\n+      ret = fold_convert_loc(location.gcc_location(), t, ret);\n     }\n \n   if (excess_type != NULL_TREE)\n@@ -9735,7 +9770,7 @@ Call_expression::set_results(Translate_context* context, tree call_tree)\n       return call_tree;\n     }\n \n-  source_location loc = this->location();\n+  Location loc = this->location();\n   tree field = TYPE_FIELDS(TREE_TYPE(call_tree));\n   size_t rc = this->result_count();\n   for (size_t i = 0; i < rc; ++i, field = DECL_CHAIN(field))\n@@ -9750,10 +9785,10 @@ Call_expression::set_results(Translate_context* context, tree call_tree)\n       if (temp_tree == error_mark_node)\n \tcontinue;\n \n-      tree val_tree = build3_loc(loc, COMPONENT_REF, TREE_TYPE(field),\n-\t\t\t\t call_tree, field, NULL_TREE);\n-      tree set_tree = build2_loc(loc, MODIFY_EXPR, void_type_node, temp_tree,\n-\t\t\t\t val_tree);\n+      tree val_tree = build3_loc(loc.gcc_location(), COMPONENT_REF,\n+                                 TREE_TYPE(field), call_tree, field, NULL_TREE);\n+      tree set_tree = build2_loc(loc.gcc_location(), MODIFY_EXPR,\n+                                 void_type_node, temp_tree, val_tree);\n \n       append_to_statement_list(set_tree, &stmt_list);\n     }\n@@ -9779,7 +9814,7 @@ Call_expression::do_dump_expression(Ast_dump_context* ast_dump_context) const\n \n Call_expression*\n Expression::make_call(Expression* fn, Expression_list* args, bool is_varargs,\n-\t\t      source_location location)\n+\t\t      Location location)\n {\n   return new Call_expression(fn, args, is_varargs, location);\n }\n@@ -9971,7 +10006,7 @@ Index_expression::do_traverse(Traverse* traverse)\n Expression*\n Index_expression::do_lower(Gogo*, Named_object*, Statement_inserter*, int)\n {\n-  source_location location = this->location();\n+  Location location = this->location();\n   Expression* left = this->left_;\n   Expression* start = this->start_;\n   Expression* end = this->end_;\n@@ -10051,7 +10086,7 @@ Index_expression::do_dump_expression(Ast_dump_context* ast_dump_context)\n \n Expression*\n Expression::make_index(Expression* left, Expression* start, Expression* end,\n-\t\t       source_location location)\n+\t\t       Location location)\n {\n   return new Index_expression(left, start, end, location);\n }\n@@ -10062,7 +10097,7 @@ class Array_index_expression : public Expression\n {\n  public:\n   Array_index_expression(Expression* array, Expression* start,\n-\t\t\t Expression* end, source_location location)\n+\t\t\t Expression* end, Location location)\n     : Expression(EXPRESSION_ARRAY_INDEX, location),\n       array_(array), start_(start), end_(end), type_(NULL)\n   { }\n@@ -10275,7 +10310,7 @@ tree\n Array_index_expression::do_get_tree(Translate_context* context)\n {\n   Gogo* gogo = context->gogo();\n-  source_location loc = this->location();\n+  Location loc = this->location();\n \n   Array_type* array_type = this->array_->type()->array_type();\n   if (array_type == NULL)\n@@ -10313,9 +10348,10 @@ Array_index_expression::do_get_tree(Translate_context* context)\n   bad_index = Expression::check_bounds(start_tree, length_type, bad_index,\n \t\t\t\t       loc);\n \n-  start_tree = fold_convert_loc(loc, length_type, start_tree);\n-  bad_index = fold_build2_loc(loc, TRUTH_OR_EXPR, boolean_type_node, bad_index,\n-\t\t\t      fold_build2_loc(loc,\n+  start_tree = fold_convert_loc(loc.gcc_location(), length_type, start_tree);\n+  bad_index = fold_build2_loc(loc.gcc_location(), TRUTH_OR_EXPR,\n+                              boolean_type_node, bad_index,\n+\t\t\t      fold_build2_loc(loc.gcc_location(),\n \t\t\t\t\t      (this->end_ == NULL\n \t\t\t\t\t       ? GE_EXPR\n \t\t\t\t\t       : GT_EXPR),\n@@ -10339,7 +10375,7 @@ Array_index_expression::do_get_tree(Translate_context* context)\n \t\t\t  build3(COND_EXPR, void_type_node,\n \t\t\t\t bad_index, crash, NULL_TREE),\n \t\t\t  start_tree);\n-      start_tree = fold_convert_loc(loc, sizetype, start_tree);\n+      start_tree = fold_convert_loc(loc.gcc_location(), sizetype, start_tree);\n \n       if (array_type->length() != NULL)\n \t{\n@@ -10357,9 +10393,9 @@ Array_index_expression::do_get_tree(Translate_context* context)\n \t  if (element_type_tree == error_mark_node)\n \t    return error_mark_node;\n \t  tree element_size = TYPE_SIZE_UNIT(element_type_tree);\n-\t  tree offset = fold_build2_loc(loc, MULT_EXPR, sizetype,\n+\t  tree offset = fold_build2_loc(loc.gcc_location(), MULT_EXPR, sizetype,\n \t\t\t\t\tstart_tree, element_size);\n-\t  tree ptr = fold_build2_loc(loc, POINTER_PLUS_EXPR,\n+\t  tree ptr = fold_build2_loc(loc.gcc_location(), POINTER_PLUS_EXPR,\n \t\t\t\t     TREE_TYPE(values), values, offset);\n \t  return build_fold_indirect_ref(ptr);\n \t}\n@@ -10370,7 +10406,8 @@ Array_index_expression::do_get_tree(Translate_context* context)\n   tree capacity_tree = array_type->capacity_tree(gogo, array_tree);\n   if (capacity_tree == error_mark_node)\n     return error_mark_node;\n-  capacity_tree = fold_convert_loc(loc, length_type, capacity_tree);\n+  capacity_tree = fold_convert_loc(loc.gcc_location(), length_type,\n+                                   capacity_tree);\n \n   tree end_tree;\n   if (this->end_->is_nil_expression())\n@@ -10388,18 +10425,19 @@ Array_index_expression::do_get_tree(Translate_context* context)\n       bad_index = Expression::check_bounds(end_tree, length_type, bad_index,\n \t\t\t\t\t   loc);\n \n-      end_tree = fold_convert_loc(loc, length_type, end_tree);\n+      end_tree = fold_convert_loc(loc.gcc_location(), length_type, end_tree);\n \n       capacity_tree = save_expr(capacity_tree);\n-      tree bad_end = fold_build2_loc(loc, TRUTH_OR_EXPR, boolean_type_node,\n-\t\t\t\t     fold_build2_loc(loc, LT_EXPR,\n-\t\t\t\t\t\t     boolean_type_node,\n+      tree bad_end = fold_build2_loc(loc.gcc_location(), TRUTH_OR_EXPR,\n+                                     boolean_type_node,\n+\t\t\t\t     fold_build2_loc(loc.gcc_location(),\n+                                                     LT_EXPR, boolean_type_node,\n \t\t\t\t\t\t     end_tree, start_tree),\n-\t\t\t\t     fold_build2_loc(loc, GT_EXPR,\n-\t\t\t\t\t\t     boolean_type_node,\n+\t\t\t\t     fold_build2_loc(loc.gcc_location(),\n+                                                     GT_EXPR, boolean_type_node,\n \t\t\t\t\t\t     end_tree, capacity_tree));\n-      bad_index = fold_build2_loc(loc, TRUTH_OR_EXPR, boolean_type_node,\n-\t\t\t\t  bad_index, bad_end);\n+      bad_index = fold_build2_loc(loc.gcc_location(), TRUTH_OR_EXPR,\n+                                  boolean_type_node, bad_index, bad_end);\n     }\n \n   Type* element_type = array_type->element_type();\n@@ -10408,23 +10446,25 @@ Array_index_expression::do_get_tree(Translate_context* context)\n     return error_mark_node;\n   tree element_size = TYPE_SIZE_UNIT(element_type_tree);\n \n-  tree offset = fold_build2_loc(loc, MULT_EXPR, sizetype,\n-\t\t\t\tfold_convert_loc(loc, sizetype, start_tree),\n+  tree offset = fold_build2_loc(loc.gcc_location(), MULT_EXPR, sizetype,\n+\t\t\t\tfold_convert_loc(loc.gcc_location(), sizetype,\n+                                                 start_tree),\n \t\t\t\telement_size);\n \n   tree value_pointer = array_type->value_pointer_tree(gogo, array_tree);\n   if (value_pointer == error_mark_node)\n     return error_mark_node;\n \n-  value_pointer = fold_build2_loc(loc, POINTER_PLUS_EXPR,\n+  value_pointer = fold_build2_loc(loc.gcc_location(), POINTER_PLUS_EXPR,\n \t\t\t\t  TREE_TYPE(value_pointer),\n \t\t\t\t  value_pointer, offset);\n \n-  tree result_length_tree = fold_build2_loc(loc, MINUS_EXPR, length_type,\n-\t\t\t\t\t    end_tree, start_tree);\n+  tree result_length_tree = fold_build2_loc(loc.gcc_location(), MINUS_EXPR,\n+                                            length_type, end_tree, start_tree);\n \n-  tree result_capacity_tree = fold_build2_loc(loc, MINUS_EXPR, length_type,\n-\t\t\t\t\t      capacity_tree, start_tree);\n+  tree result_capacity_tree = fold_build2_loc(loc.gcc_location(), MINUS_EXPR,\n+                                              length_type, capacity_tree,\n+                                              start_tree);\n \n   tree struct_tree = type_to_tree(this->type()->get_backend(gogo));\n   go_assert(TREE_CODE(struct_tree) == RECORD_TYPE);\n@@ -10441,13 +10481,15 @@ Array_index_expression::do_get_tree(Translate_context* context)\n   field = DECL_CHAIN(field);\n   go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__count\") == 0);\n   elt->index = field;\n-  elt->value = fold_convert_loc(loc, TREE_TYPE(field), result_length_tree);\n+  elt->value = fold_convert_loc(loc.gcc_location(), TREE_TYPE(field),\n+                                result_length_tree);\n \n   elt = VEC_quick_push(constructor_elt, init, NULL);\n   field = DECL_CHAIN(field);\n   go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__capacity\") == 0);\n   elt->index = field;\n-  elt->value = fold_convert_loc(loc, TREE_TYPE(field), result_capacity_tree);\n+  elt->value = fold_convert_loc(loc.gcc_location(), TREE_TYPE(field),\n+                                result_capacity_tree);\n \n   tree constructor = build_constructor(struct_tree, init);\n \n@@ -10456,7 +10498,8 @@ Array_index_expression::do_get_tree(Translate_context* context)\n       && TREE_CONSTANT(result_capacity_tree))\n     TREE_CONSTANT(constructor) = 1;\n \n-  return fold_build2_loc(loc, COMPOUND_EXPR, TREE_TYPE(constructor),\n+  return fold_build2_loc(loc.gcc_location(), COMPOUND_EXPR,\n+                         TREE_TYPE(constructor),\n \t\t\t build3(COND_EXPR, void_type_node,\n \t\t\t\tbad_index, crash, NULL_TREE),\n \t\t\t constructor);\n@@ -10476,7 +10519,7 @@ Array_index_expression::do_dump_expression(Ast_dump_context* ast_dump_context)\n \n Expression*\n Expression::make_array_index(Expression* array, Expression* start,\n-\t\t\t     Expression* end, source_location location)\n+\t\t\t     Expression* end, Location location)\n {\n   // Taking a slice of a composite literal requires moving the literal\n   // onto the heap.\n@@ -10494,7 +10537,7 @@ class String_index_expression : public Expression\n {\n  public:\n   String_index_expression(Expression* string, Expression* start,\n-\t\t\t  Expression* end, source_location location)\n+\t\t\t  Expression* end, Location location)\n     : Expression(EXPRESSION_STRING_INDEX, location),\n       string_(string), start_(start), end_(end)\n   { }\n@@ -10632,7 +10675,7 @@ String_index_expression::do_check_types(Gogo*)\n tree\n String_index_expression::do_get_tree(Translate_context* context)\n {\n-  source_location loc = this->location();\n+  Location loc = this->location();\n \n   tree string_tree = this->string_->get_tree(context);\n   if (string_tree == error_mark_node)\n@@ -10661,7 +10704,7 @@ String_index_expression::do_get_tree(Translate_context* context)\n   bad_index = Expression::check_bounds(start_tree, length_type, bad_index,\n \t\t\t\t       loc);\n \n-  start_tree = fold_convert_loc(loc, length_type, start_tree);\n+  start_tree = fold_convert_loc(loc.gcc_location(), length_type, start_tree);\n \n   int code = (this->end_ == NULL\n \t      ? RUNTIME_ERROR_STRING_INDEX_OUT_OF_BOUNDS\n@@ -10670,17 +10713,19 @@ String_index_expression::do_get_tree(Translate_context* context)\n \n   if (this->end_ == NULL)\n     {\n-      bad_index = fold_build2_loc(loc, TRUTH_OR_EXPR, boolean_type_node,\n-\t\t\t\t  bad_index,\n-\t\t\t\t  fold_build2_loc(loc, GE_EXPR,\n+      bad_index = fold_build2_loc(loc.gcc_location(), TRUTH_OR_EXPR,\n+                                  boolean_type_node, bad_index,\n+\t\t\t\t  fold_build2_loc(loc.gcc_location(), GE_EXPR,\n \t\t\t\t\t\t  boolean_type_node,\n \t\t\t\t\t\t  start_tree, length_tree));\n \n       tree bytes_tree = String_type::bytes_tree(context->gogo(), string_tree);\n-      tree ptr = fold_build2_loc(loc, POINTER_PLUS_EXPR, TREE_TYPE(bytes_tree),\n+      tree ptr = fold_build2_loc(loc.gcc_location(), POINTER_PLUS_EXPR,\n+                                 TREE_TYPE(bytes_tree),\n \t\t\t\t bytes_tree,\n-\t\t\t\t fold_convert_loc(loc, sizetype, start_tree));\n-      tree index = build_fold_indirect_ref_loc(loc, ptr);\n+\t\t\t\t fold_convert_loc(loc.gcc_location(), sizetype,\n+                                                  start_tree));\n+      tree index = build_fold_indirect_ref_loc(loc.gcc_location(), ptr);\n \n       return build2(COMPOUND_EXPR, TREE_TYPE(index),\n \t\t    build3(COND_EXPR, void_type_node,\n@@ -10705,7 +10750,8 @@ String_index_expression::do_get_tree(Translate_context* context)\n \t  bad_index = Expression::check_bounds(end_tree, length_type,\n \t\t\t\t\t       bad_index, loc);\n \n-\t  end_tree = fold_convert_loc(loc, length_type, end_tree);\n+\t  end_tree = fold_convert_loc(loc.gcc_location(), length_type,\n+                                      end_tree);\n \t}\n \n       static tree strslice_fndecl;\n@@ -10750,7 +10796,7 @@ String_index_expression::do_dump_expression(Ast_dump_context* ast_dump_context)\n \n Expression*\n Expression::make_string_index(Expression* string, Expression* start,\n-\t\t\t      Expression* end, source_location location)\n+\t\t\t      Expression* end, Location location)\n {\n   return new String_index_expression(string, start, end, location);\n }\n@@ -10906,14 +10952,16 @@ Map_index_expression::get_value_pointer(Translate_context* context,\n     }\n   else\n     {\n-      tmp = build_decl(this->location(), VAR_DECL, create_tmp_var_name(\"M\"),\n+      tmp = build_decl(this->location().gcc_location(), VAR_DECL,\n+                       create_tmp_var_name(\"M\"),\n \t\t       TREE_TYPE(index_tree));\n       DECL_EXTERNAL(tmp) = 0;\n       TREE_PUBLIC(tmp) = 0;\n       TREE_STATIC(tmp) = 1;\n       DECL_ARTIFICIAL(tmp) = 1;\n       if (!TREE_CONSTANT(index_tree))\n-\tmake_tmp = fold_build2_loc(this->location(), INIT_EXPR, void_type_node,\n+\tmake_tmp = fold_build2_loc(this->location().gcc_location(),\n+                                   INIT_EXPR, void_type_node,\n \t\t\t\t   tmp, index_tree);\n       else\n \t{\n@@ -10924,9 +10972,10 @@ Map_index_expression::get_value_pointer(Translate_context* context,\n \t}\n       rest_of_decl_compilation(tmp, 1, 0);\n     }\n-  tree tmpref = fold_convert_loc(this->location(), const_ptr_type_node,\n-\t\t\t\t build_fold_addr_expr_loc(this->location(),\n-\t\t\t\t\t\t\t  tmp));\n+  tree tmpref =\n+    fold_convert_loc(this->location().gcc_location(), const_ptr_type_node,\n+                     build_fold_addr_expr_loc(this->location().gcc_location(),\n+                                              tmp));\n \n   static tree map_index_fndecl;\n   tree call = Gogo::call_builtin(&map_index_fndecl,\n@@ -10954,7 +11003,8 @@ Map_index_expression::get_value_pointer(Translate_context* context,\n     return error_mark_node;\n   tree ptr_val_type_tree = build_pointer_type(val_type_tree);\n \n-  tree ret = fold_convert_loc(this->location(), ptr_val_type_tree, call);\n+  tree ret = fold_convert_loc(this->location().gcc_location(),\n+                              ptr_val_type_tree, call);\n   if (make_tmp != NULL_TREE)\n     ret = build2(COMPOUND_EXPR, ptr_val_type_tree, make_tmp, ret);\n   return ret;\n@@ -10974,7 +11024,7 @@ Map_index_expression::do_dump_expression(Ast_dump_context* ast_dump_context)\n \n Map_index_expression*\n Expression::make_map_index(Expression* map, Expression* index,\n-\t\t\t   source_location location)\n+\t\t\t   Location location)\n {\n   return new Map_index_expression(map, index, location);\n }\n@@ -11050,7 +11100,7 @@ Field_reference_expression::do_dump_expression(\n \n Field_reference_expression*\n Expression::make_field_reference(Expression* expr, unsigned int field_index,\n-\t\t\t\t source_location location)\n+\t\t\t\t Location location)\n {\n   return new Field_reference_expression(expr, field_index, location);\n }\n@@ -11207,7 +11257,7 @@ Interface_field_reference_expression::do_dump_expression(\n Expression*\n Expression::make_interface_field_reference(Expression* expr,\n \t\t\t\t\t   const std::string& field,\n-\t\t\t\t\t   source_location location)\n+\t\t\t\t\t   Location location)\n {\n   return new Interface_field_reference_expression(expr, field, location);\n }\n@@ -11219,7 +11269,7 @@ class Selector_expression : public Parser_expression\n {\n  public:\n   Selector_expression(Expression* left, const std::string& name,\n-\t\t      source_location location)\n+\t\t      Location location)\n     : Parser_expression(EXPRESSION_SELECTOR, location),\n       left_(left), name_(name)\n   { }\n@@ -11272,7 +11322,7 @@ Selector_expression::do_lower(Gogo* gogo, Named_object*, Statement_inserter*,\n Expression*\n Selector_expression::lower_method_expression(Gogo* gogo)\n {\n-  source_location location = this->location();\n+  Location location = this->location();\n   Type* type = this->left_->type();\n   const std::string& name(this->name_);\n \n@@ -11477,7 +11527,7 @@ Selector_expression::do_dump_expression(Ast_dump_context* ast_dump_context)\n \n Expression*\n Expression::make_selector(Expression* left, const std::string& name,\n-\t\t\t  source_location location)\n+\t\t\t  Location location)\n {\n   return new Selector_expression(left, name, location);\n }\n@@ -11487,7 +11537,7 @@ Expression::make_selector(Expression* left, const std::string& name,\n class Allocation_expression : public Expression\n {\n  public:\n-  Allocation_expression(Type* type, source_location location)\n+  Allocation_expression(Type* type, Location location)\n     : Expression(EXPRESSION_ALLOCATION, location),\n       type_(type)\n   { }\n@@ -11550,7 +11600,7 @@ Allocation_expression::do_dump_expression(Ast_dump_context* ast_dump_context)\n // Make an allocation expression.\n \n Expression*\n-Expression::make_allocation(Type* type, source_location location)\n+Expression::make_allocation(Type* type, Location location)\n {\n   return new Allocation_expression(type, location);\n }\n@@ -11561,7 +11611,7 @@ class Struct_construction_expression : public Expression\n {\n  public:\n   Struct_construction_expression(Type* type, Expression_list* vals,\n-\t\t\t\t source_location location)\n+\t\t\t\t Location location)\n     : Expression(EXPRESSION_STRUCT_CONSTRUCTION, location),\n       type_(type), vals_(vals)\n   { }\n@@ -11832,7 +11882,7 @@ Struct_construction_expression::do_dump_expression(\n \n Expression*\n Expression::make_struct_composite_literal(Type* type, Expression_list* vals,\n-\t\t\t\t\t  source_location location)\n+\t\t\t\t\t  Location location)\n {\n   go_assert(type->struct_type() != NULL);\n   return new Struct_construction_expression(type, vals, location);\n@@ -11847,7 +11897,7 @@ class Array_construction_expression : public Expression\n  protected:\n   Array_construction_expression(Expression_classification classification,\n \t\t\t\tType* type, Expression_list* vals,\n-\t\t\t\tsource_location location)\n+\t\t\t\tLocation location)\n     : Expression(classification, location),\n       type_(type), vals_(vals)\n   { }\n@@ -12097,7 +12147,7 @@ class Fixed_array_construction_expression :\n {\n  public:\n   Fixed_array_construction_expression(Type* type, Expression_list* vals,\n-\t\t\t\t      source_location location)\n+\t\t\t\t      Location location)\n     : Array_construction_expression(EXPRESSION_FIXED_ARRAY_CONSTRUCTION,\n \t\t\t\t    type, vals, location)\n   {\n@@ -12155,7 +12205,7 @@ class Open_array_construction_expression : public Array_construction_expression\n {\n  public:\n   Open_array_construction_expression(Type* type, Expression_list* vals,\n-\t\t\t\t     source_location location)\n+\t\t\t\t     Location location)\n     : Array_construction_expression(EXPRESSION_OPEN_ARRAY_CONSTRUCTION,\n \t\t\t\t    type, vals, location)\n   {\n@@ -12246,7 +12296,7 @@ Open_array_construction_expression::do_get_tree(Translate_context* context)\n \n   if (is_constant_initializer)\n     {\n-      tree tmp = build_decl(this->location(), VAR_DECL,\n+      tree tmp = build_decl(this->location().gcc_location(), VAR_DECL,\n \t\t\t    create_tmp_var_name(\"C\"), TREE_TYPE(values));\n       DECL_EXTERNAL(tmp) = 0;\n       TREE_PUBLIC(tmp) = 0;\n@@ -12282,7 +12332,8 @@ Open_array_construction_expression::do_get_tree(Translate_context* context)\n       space = save_expr(space);\n \n       tree s = fold_convert(build_pointer_type(TREE_TYPE(values)), space);\n-      tree ref = build_fold_indirect_ref_loc(this->location(), s);\n+      tree ref = build_fold_indirect_ref_loc(this->location().gcc_location(),\n+                                             s);\n       TREE_THIS_NOTRAP(ref) = 1;\n       set = build2(MODIFY_EXPR, void_type_node, ref, values);\n     }\n@@ -12331,7 +12382,7 @@ Open_array_construction_expression::do_get_tree(Translate_context* context)\n \n Expression*\n Expression::make_slice_composite_literal(Type* type, Expression_list* vals,\n-\t\t\t\t\t source_location location)\n+\t\t\t\t\t Location location)\n {\n   go_assert(type->is_slice_type());\n   return new Open_array_construction_expression(type, vals, location);\n@@ -12343,7 +12394,7 @@ class Map_construction_expression : public Expression\n {\n  public:\n   Map_construction_expression(Type* type, Expression_list* vals,\n-\t\t\t      source_location location)\n+\t\t\t      Location location)\n     : Expression(EXPRESSION_MAP_CONSTRUCTION, location),\n       type_(type), vals_(vals)\n   { go_assert(vals == NULL || vals->size() % 2 == 0); }\n@@ -12460,7 +12511,7 @@ tree\n Map_construction_expression::do_get_tree(Translate_context* context)\n {\n   Gogo* gogo = context->gogo();\n-  source_location loc = this->location();\n+  Location loc = this->location();\n \n   Map_type* mt = this->type_->map_type();\n \n@@ -12472,7 +12523,8 @@ Map_construction_expression::do_get_tree(Translate_context* context)\n   tree key_type_tree = type_to_tree(key_type->get_backend(gogo));\n   if (key_type_tree == error_mark_node)\n     return error_mark_node;\n-  tree key_field = build_decl(loc, FIELD_DECL, id, key_type_tree);\n+  tree key_field = build_decl(loc.gcc_location(), FIELD_DECL, id,\n+                              key_type_tree);\n   DECL_CONTEXT(key_field) = struct_type;\n   TYPE_FIELDS(struct_type) = key_field;\n \n@@ -12481,7 +12533,8 @@ Map_construction_expression::do_get_tree(Translate_context* context)\n   tree val_type_tree = type_to_tree(val_type->get_backend(gogo));\n   if (val_type_tree == error_mark_node)\n     return error_mark_node;\n-  tree val_field = build_decl(loc, FIELD_DECL, id, val_type_tree);\n+  tree val_field = build_decl(loc.gcc_location(), FIELD_DECL, id,\n+                              val_type_tree);\n   DECL_CONTEXT(val_field) = struct_type;\n   DECL_CHAIN(key_field) = val_field;\n \n@@ -12553,19 +12606,21 @@ Map_construction_expression::do_get_tree(Translate_context* context)\n \t{\n \t  tmp = create_tmp_var(array_type, get_name(array_type));\n \t  DECL_INITIAL(tmp) = init;\n-\t  make_tmp = fold_build1_loc(loc, DECL_EXPR, void_type_node, tmp);\n+\t  make_tmp = fold_build1_loc(loc.gcc_location(), DECL_EXPR,\n+                                     void_type_node, tmp);\n \t  TREE_ADDRESSABLE(tmp) = 1;\n \t}\n       else\n \t{\n-\t  tmp = build_decl(loc, VAR_DECL, create_tmp_var_name(\"M\"), array_type);\n+\t  tmp = build_decl(loc.gcc_location(), VAR_DECL,\n+                           create_tmp_var_name(\"M\"), array_type);\n \t  DECL_EXTERNAL(tmp) = 0;\n \t  TREE_PUBLIC(tmp) = 0;\n \t  TREE_STATIC(tmp) = 1;\n \t  DECL_ARTIFICIAL(tmp) = 1;\n \t  if (!TREE_CONSTANT(init))\n-\t    make_tmp = fold_build2_loc(loc, INIT_EXPR, void_type_node, tmp,\n-\t\t\t\t       init);\n+\t    make_tmp = fold_build2_loc(loc.gcc_location(), INIT_EXPR,\n+                                       void_type_node, tmp, init);\n \t  else\n \t    {\n \t      TREE_READONLY(tmp) = 1;\n@@ -12610,7 +12665,8 @@ Map_construction_expression::do_get_tree(Translate_context* context)\n   if (make_tmp == NULL)\n     ret = call;\n   else\n-    ret = fold_build2_loc(loc, COMPOUND_EXPR, type_tree, make_tmp, call);\n+    ret = fold_build2_loc(loc.gcc_location(), COMPOUND_EXPR, type_tree,\n+                          make_tmp, call);\n   return ret;\n }\n \n@@ -12649,7 +12705,7 @@ class Composite_literal_expression : public Parser_expression\n {\n  public:\n   Composite_literal_expression(Type* type, int depth, bool has_keys,\n-\t\t\t       Expression_list* vals, source_location location)\n+\t\t\t       Expression_list* vals, Location location)\n     : Parser_expression(EXPRESSION_COMPOSITE_LITERAL, location),\n       type_(type), depth_(depth), vals_(vals), has_keys_(has_keys)\n   { }\n@@ -12758,7 +12814,7 @@ Composite_literal_expression::do_lower(Gogo* gogo, Named_object* function,\n Expression*\n Composite_literal_expression::lower_struct(Gogo* gogo, Type* type)\n {\n-  source_location location = this->location();\n+  Location location = this->location();\n   Struct_type* st = type->struct_type();\n   if (this->vals_ == NULL || !this->has_keys_)\n     return new Struct_construction_expression(type, this->vals_, location);\n@@ -12924,7 +12980,7 @@ Composite_literal_expression::lower_struct(Gogo* gogo, Type* type)\n Expression*\n Composite_literal_expression::lower_array(Type* type)\n {\n-  source_location location = this->location();\n+  Location location = this->location();\n   if (this->vals_ == NULL || !this->has_keys_)\n     return this->make_array(type, this->vals_);\n \n@@ -13035,7 +13091,7 @@ Composite_literal_expression::lower_array(Type* type)\n Expression*\n Composite_literal_expression::make_array(Type* type, Expression_list* vals)\n {\n-  source_location location = this->location();\n+  Location location = this->location();\n   Array_type* at = type->array_type();\n   if (at->length() != NULL && at->length()->is_nil_expression())\n     {\n@@ -13060,7 +13116,7 @@ Composite_literal_expression::lower_map(Gogo* gogo, Named_object* function,\n \t\t\t\t\tStatement_inserter* inserter,\n \t\t\t\t\tType* type)\n {\n-  source_location location = this->location();\n+  Location location = this->location();\n   if (this->vals_ != NULL)\n     {\n       if (!this->has_keys_)\n@@ -13114,7 +13170,7 @@ Composite_literal_expression::do_dump_expression(\n Expression*\n Expression::make_composite_literal(Type* type, int depth, bool has_keys,\n \t\t\t\t   Expression_list* vals,\n-\t\t\t\t   source_location location)\n+\t\t\t\t   Location location)\n {\n   return new Composite_literal_expression(type, depth, has_keys, vals,\n \t\t\t\t\t  location);\n@@ -13298,7 +13354,7 @@ Type_guard_expression::do_dump_expression(Ast_dump_context* ast_dump_context)\n \n Expression*\n Expression::make_type_guard(Expression* expr, Type* type,\n-\t\t\t    source_location location)\n+\t\t\t    Location location)\n {\n   return new Type_guard_expression(expr, type, location);\n }\n@@ -13311,7 +13367,7 @@ Expression::make_type_guard(Expression* expr, Type* type,\n class Heap_composite_expression : public Expression\n {\n  public:\n-  Heap_composite_expression(Expression* expr, source_location location)\n+  Heap_composite_expression(Expression* expr, Location location)\n     : Expression(EXPRESSION_HEAP_COMPOSITE, location),\n       expr_(expr)\n   { }\n@@ -13367,12 +13423,13 @@ Heap_composite_expression::do_get_tree(Translate_context* context)\n \t\t\t\t\t\texpr_size, this->location());\n   space = fold_convert(build_pointer_type(TREE_TYPE(expr_tree)), space);\n   space = save_expr(space);\n-  tree ref = build_fold_indirect_ref_loc(this->location(), space);\n+  tree ref = build_fold_indirect_ref_loc(this->location().gcc_location(),\n+                                         space);\n   TREE_THIS_NOTRAP(ref) = 1;\n   tree ret = build2(COMPOUND_EXPR, TREE_TYPE(space),\n \t\t    build2(MODIFY_EXPR, void_type_node, ref, expr_tree),\n \t\t    space);\n-  SET_EXPR_LOCATION(ret, this->location());\n+  SET_EXPR_LOCATION(ret, this->location().gcc_location());\n   return ret;\n }\n \n@@ -13390,7 +13447,7 @@ Heap_composite_expression::do_dump_expression(\n // Allocate a composite literal on the heap.\n \n Expression*\n-Expression::make_heap_composite(Expression* expr, source_location location)\n+Expression::make_heap_composite(Expression* expr, Location location)\n {\n   return new Heap_composite_expression(expr, location);\n }\n@@ -13466,7 +13523,7 @@ Receive_expression::do_dump_expression(Ast_dump_context* ast_dump_context) const\n // Make a receive expression.\n \n Receive_expression*\n-Expression::make_receive(Expression* channel, source_location location)\n+Expression::make_receive(Expression* channel, Location location)\n {\n   return new Receive_expression(channel, location);\n }\n@@ -13477,7 +13534,7 @@ Expression::make_receive(Expression* channel, source_location location)\n class Type_descriptor_expression : public Expression\n {\n  public:\n-  Type_descriptor_expression(Type* type, source_location location)\n+  Type_descriptor_expression(Type* type, Location location)\n     : Expression(EXPRESSION_TYPE_DESCRIPTOR, location),\n       type_(type)\n   { }\n@@ -13522,7 +13579,7 @@ Type_descriptor_expression::do_dump_expression(\n // Make a type descriptor expression.\n \n Expression*\n-Expression::make_type_descriptor(Type* type, source_location location)\n+Expression::make_type_descriptor(Type* type, Location location)\n {\n   return new Type_descriptor_expression(type, location);\n }\n@@ -13537,7 +13594,7 @@ class Type_info_expression : public Expression\n {\n  public:\n   Type_info_expression(Type* type, Type_info type_info)\n-    : Expression(EXPRESSION_TYPE_INFO, BUILTINS_LOCATION),\n+    : Expression(EXPRESSION_TYPE_INFO, Linemap::predeclared_location()),\n       type_(type), type_info_(type_info)\n   { }\n \n@@ -13643,7 +13700,8 @@ class Struct_field_offset_expression : public Expression\n {\n  public:\n   Struct_field_offset_expression(Struct_type* type, const Struct_field* field)\n-    : Expression(EXPRESSION_STRUCT_FIELD_OFFSET, BUILTINS_LOCATION),\n+    : Expression(EXPRESSION_STRUCT_FIELD_OFFSET,\n+\t\t Linemap::predeclared_location()),\n       type_(type), field_(field)\n   { }\n \n@@ -13731,7 +13789,7 @@ Expression::make_struct_field_offset(Struct_type* type,\n class Map_descriptor_expression : public Expression\n {\n  public:\n-  Map_descriptor_expression(Map_type* type, source_location location)\n+  Map_descriptor_expression(Map_type* type, Location location)\n     : Expression(EXPRESSION_MAP_DESCRIPTOR, location),\n       type_(type)\n   { }\n@@ -13778,7 +13836,7 @@ Map_descriptor_expression::do_dump_expression(\n // Make a map descriptor expression.\n \n Expression*\n-Expression::make_map_descriptor(Map_type* type, source_location location)\n+Expression::make_map_descriptor(Map_type* type, Location location)\n {\n   return new Map_descriptor_expression(type, location);\n }\n@@ -13788,7 +13846,7 @@ Expression::make_map_descriptor(Map_type* type, source_location location)\n class Label_addr_expression : public Expression\n {\n  public:\n-  Label_addr_expression(Label* label, source_location location)\n+  Label_addr_expression(Label* label, Location location)\n     : Expression(EXPRESSION_LABEL_ADDR, location),\n       label_(label)\n   { }\n@@ -13824,7 +13882,7 @@ class Label_addr_expression : public Expression\n // Make an expression for the address of an unnamed label.\n \n Expression*\n-Expression::make_label_addr(Label* label, source_location location)\n+Expression::make_label_addr(Label* label, Location location)\n {\n   return new Label_addr_expression(label, location);\n }"}, {"sha": "74d1281e17c9fc5236ae46b4f0cf3da70e55b391", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 67, "deletions": 67, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=8afa2bfbdc60088acd7f199245244890a6e7773e", "patch": "@@ -98,81 +98,81 @@ class Expression\n     EXPRESSION_LABEL_ADDR\n   };\n \n-  Expression(Expression_classification, source_location);\n+  Expression(Expression_classification, Location);\n \n   virtual ~Expression();\n \n   // Make an error expression.  This is used when a parse error occurs\n   // to prevent cascading errors.\n   static Expression*\n-  make_error(source_location);\n+  make_error(Location);\n \n   // Make an expression which is really a type.  This is used during\n   // parsing.\n   static Expression*\n-  make_type(Type*, source_location);\n+  make_type(Type*, Location);\n \n   // Make a unary expression.\n   static Expression*\n-  make_unary(Operator, Expression*, source_location);\n+  make_unary(Operator, Expression*, Location);\n \n   // Make a binary expression.\n   static Expression*\n-  make_binary(Operator, Expression*, Expression*, source_location);\n+  make_binary(Operator, Expression*, Expression*, Location);\n \n   // Make a reference to a constant in an expression.\n   static Expression*\n-  make_const_reference(Named_object*, source_location);\n+  make_const_reference(Named_object*, Location);\n \n   // Make a reference to a variable in an expression.\n   static Expression*\n-  make_var_reference(Named_object*, source_location);\n+  make_var_reference(Named_object*, Location);\n \n   // Make a reference to a temporary variable.  Temporary variables\n   // are always created by a single statement, which is what we use to\n   // refer to them.\n   static Temporary_reference_expression*\n-  make_temporary_reference(Temporary_statement*, source_location);\n+  make_temporary_reference(Temporary_statement*, Location);\n \n   // Make a sink expression--a reference to the blank identifier _.\n   static Expression*\n-  make_sink(source_location);\n+  make_sink(Location);\n \n   // Make a reference to a function in an expression.\n   static Expression*\n-  make_func_reference(Named_object*, Expression* closure, source_location);\n+  make_func_reference(Named_object*, Expression* closure, Location);\n \n   // Make a reference to an unknown name.  In a correct program this\n   // will always be lowered to a real const/var/func reference.\n   static Expression*\n-  make_unknown_reference(Named_object*, source_location);\n+  make_unknown_reference(Named_object*, Location);\n \n   // Make a constant bool expression.\n   static Expression*\n-  make_boolean(bool val, source_location);\n+  make_boolean(bool val, Location);\n \n   // Make a constant string expression.\n   static Expression*\n-  make_string(const std::string&, source_location);\n+  make_string(const std::string&, Location);\n \n   // Make a constant integer expression.  TYPE should be NULL for an\n   // abstract type.\n   static Expression*\n-  make_integer(const mpz_t*, Type*, source_location);\n+  make_integer(const mpz_t*, Type*, Location);\n \n   // Make a constant float expression.  TYPE should be NULL for an\n   // abstract type.\n   static Expression*\n-  make_float(const mpfr_t*, Type*, source_location);\n+  make_float(const mpfr_t*, Type*, Location);\n \n   // Make a constant complex expression.  TYPE should be NULL for an\n   // abstract type.\n   static Expression*\n-  make_complex(const mpfr_t* real, const mpfr_t* imag, Type*, source_location);\n+  make_complex(const mpfr_t* real, const mpfr_t* imag, Type*, Location);\n \n   // Make a nil expression.\n   static Expression*\n-  make_nil(source_location);\n+  make_nil(Location);\n \n   // Make an iota expression.  This is used for the predeclared\n   // constant iota.\n@@ -182,7 +182,7 @@ class Expression\n   // Make a call expression.\n   static Call_expression*\n   make_call(Expression* func, Expression_list* args, bool is_varargs,\n-\t    source_location);\n+\t    Location);\n \n   // Make a reference to a specific result of a call expression which\n   // returns a tuple.\n@@ -192,7 +192,7 @@ class Expression\n   // Make an expression which is a method bound to its first\n   // parameter.\n   static Bound_method_expression*\n-  make_bound_method(Expression* object, Named_object* method, source_location);\n+  make_bound_method(Expression* object, Named_object* method, Location);\n \n   // Make an index or slice expression.  This is a parser expression\n   // which represents LEFT[START:END].  END may be NULL, meaning an\n@@ -201,84 +201,84 @@ class Expression\n   // string index, or a map index.\n   static Expression*\n   make_index(Expression* left, Expression* start, Expression* end,\n-\t     source_location);\n+\t     Location);\n \n   // Make an array index expression.  END may be NULL, in which case\n   // this is an lvalue.\n   static Expression*\n   make_array_index(Expression* array, Expression* start, Expression* end,\n-\t\t   source_location);\n+\t\t   Location);\n \n   // Make a string index expression.  END may be NULL.  This is never\n   // an lvalue.\n   static Expression*\n   make_string_index(Expression* string, Expression* start, Expression* end,\n-\t\t    source_location);\n+\t\t    Location);\n \n   // Make a map index expression.  This is an lvalue.\n   static Map_index_expression*\n-  make_map_index(Expression* map, Expression* val, source_location);\n+  make_map_index(Expression* map, Expression* val, Location);\n \n   // Make a selector.  This is a parser expression which represents\n   // LEFT.NAME.  At parse time we may not know the type of the left\n   // hand side.\n   static Expression*\n-  make_selector(Expression* left, const std::string& name, source_location);\n+  make_selector(Expression* left, const std::string& name, Location);\n \n   // Make a reference to a field in a struct.\n   static Field_reference_expression*\n-  make_field_reference(Expression*, unsigned int field_index, source_location);\n+  make_field_reference(Expression*, unsigned int field_index, Location);\n \n   // Make a reference to a field of an interface, with an associated\n   // object.\n   static Expression*\n   make_interface_field_reference(Expression*, const std::string&,\n-\t\t\t\t source_location);\n+\t\t\t\t Location);\n \n   // Make an allocation expression.\n   static Expression*\n-  make_allocation(Type*, source_location);\n+  make_allocation(Type*, Location);\n \n   // Make a type guard expression.\n   static Expression*\n-  make_type_guard(Expression*, Type*, source_location);\n+  make_type_guard(Expression*, Type*, Location);\n \n   // Make a type cast expression.\n   static Expression*\n-  make_cast(Type*, Expression*, source_location);\n+  make_cast(Type*, Expression*, Location);\n \n   // Make an unsafe type cast expression.  This is only used when\n   // passing parameter to builtin functions that are part of the Go\n   // runtime.\n   static Expression*\n-  make_unsafe_cast(Type*, Expression*, source_location);\n+  make_unsafe_cast(Type*, Expression*, Location);\n \n   // Make a composite literal.  The DEPTH parameter is how far down we\n   // are in a list of composite literals with omitted types.\n   static Expression*\n   make_composite_literal(Type*, int depth, bool has_keys, Expression_list*,\n-\t\t\t source_location);\n+\t\t\t Location);\n \n   // Make a struct composite literal.\n   static Expression*\n-  make_struct_composite_literal(Type*, Expression_list*, source_location);\n+  make_struct_composite_literal(Type*, Expression_list*, Location);\n \n   // Make a slice composite literal.\n   static Expression*\n-  make_slice_composite_literal(Type*, Expression_list*, source_location);\n+  make_slice_composite_literal(Type*, Expression_list*, Location);\n \n   // Take a composite literal and allocate it on the heap.\n   static Expression*\n-  make_heap_composite(Expression*, source_location);\n+  make_heap_composite(Expression*, Location);\n \n   // Make a receive expression.  VAL is NULL for a unary receive.\n   static Receive_expression*\n-  make_receive(Expression* channel, source_location);\n+  make_receive(Expression* channel, Location);\n \n   // Make an expression which evaluates to the address of the type\n   // descriptor for TYPE.\n   static Expression*\n-  make_type_descriptor(Type* type, source_location);\n+  make_type_descriptor(Type* type, Location);\n \n   // Make an expression which evaluates to some characteristic of a\n   // type.  These are only used for type descriptors, so there is no\n@@ -306,20 +306,20 @@ class Expression\n   // Make an expression which evaluates to the address of the map\n   // descriptor for TYPE.\n   static Expression*\n-  make_map_descriptor(Map_type* type, source_location);\n+  make_map_descriptor(Map_type* type, Location);\n \n   // Make an expression which evaluates to the address of an unnamed\n   // label.\n   static Expression*\n-  make_label_addr(Label*, source_location);\n+  make_label_addr(Label*, Location);\n \n   // Return the expression classification.\n   Expression_classification\n   classification() const\n   { return this->classification_; }\n \n   // Return the location of the expression.\n-  source_location\n+  Location\n   location() const\n   { return this->location_; }\n \n@@ -602,22 +602,22 @@ class Expression\n   // assignment.\n   static tree\n   convert_for_assignment(Translate_context*, Type* lhs_type, Type* rhs_type,\n-\t\t\t tree rhs_tree, source_location location);\n+\t\t\t tree rhs_tree, Location location);\n \n   // Return a tree converting a value of one interface type to another\n   // interface type.  If FOR_TYPE_GUARD is true this is for a type\n   // assertion.\n   static tree\n   convert_interface_to_interface(Translate_context*, Type* lhs_type,\n \t\t\t\t Type* rhs_type, tree rhs_tree,\n-\t\t\t\t bool for_type_guard, source_location);\n+\t\t\t\t bool for_type_guard, Location);\n \n   // Return a tree implementing the comparison LHS_TREE OP RHS_TREE.\n   // TYPE is the type of both sides.\n   static tree\n   comparison_tree(Translate_context*, Operator op, Type* left_type,\n \t\t  tree left_tree, Type* right_type, tree right_tree,\n-\t\t  source_location);\n+\t\t  Location);\n \n   // Return a tree for the multi-precision integer VAL in TYPE.\n   static tree\n@@ -647,7 +647,7 @@ class Expression\n   // BOUND_TYPE.  If SOFAR is not NULL, it is or'red into the result.\n   // The return value may be NULL if SOFAR is NULL.\n   static tree\n-  check_bounds(tree val, tree bound_type, tree sofar, source_location);\n+  check_bounds(tree val, tree bound_type, tree sofar, Location);\n \n   // Dump an expression to a dump constext.\n   void\n@@ -785,20 +785,20 @@ class Expression\n \n   static tree\n   convert_type_to_interface(Translate_context*, Type*, Type*, tree,\n-\t\t\t    source_location);\n+\t\t\t    Location);\n \n   static tree\n   get_interface_type_descriptor(Translate_context*, Type*, tree,\n-\t\t\t\tsource_location);\n+\t\t\t\tLocation);\n \n   static tree\n   convert_interface_to_type(Translate_context*, Type*, Type*, tree,\n-\t\t\t    source_location);\n+\t\t\t    Location);\n \n   // The expression classification.\n   Expression_classification classification_;\n   // The location in the input file.\n-  source_location location_;\n+  Location location_;\n };\n \n // A list of Expressions.\n@@ -900,7 +900,7 @@ class Parser_expression : public Expression\n {\n  public:\n   Parser_expression(Expression_classification classification,\n-\t\t    source_location location)\n+\t\t    Location location)\n     : Expression(classification, location)\n   { }\n \n@@ -929,7 +929,7 @@ class Parser_expression : public Expression\n class Var_expression : public Expression\n {\n  public:\n-  Var_expression(Named_object* variable, source_location location)\n+  Var_expression(Named_object* variable, Location location)\n     : Expression(EXPRESSION_VAR_REFERENCE, location),\n       variable_(variable)\n   { }\n@@ -977,7 +977,7 @@ class Temporary_reference_expression : public Expression\n {\n  public:\n   Temporary_reference_expression(Temporary_statement* statement,\n-\t\t\t\t source_location location)\n+\t\t\t\t Location location)\n     : Expression(EXPRESSION_TEMPORARY_REFERENCE, location),\n       statement_(statement), is_lvalue_(false)\n   { }\n@@ -1026,7 +1026,7 @@ class Temporary_reference_expression : public Expression\n class String_expression : public Expression\n {\n  public:\n-  String_expression(const std::string& val, source_location location)\n+  String_expression(const std::string& val, Location location)\n     : Expression(EXPRESSION_STRING, location),\n       val_(val), type_(NULL)\n   { }\n@@ -1086,7 +1086,7 @@ class Binary_expression : public Expression\n {\n  public:\n   Binary_expression(Operator op, Expression* left, Expression* right,\n-\t\t    source_location location)\n+\t\t    Location location)\n     : Expression(EXPRESSION_BINARY, location),\n       op_(op), left_(left), right_(right)\n   { }\n@@ -1112,23 +1112,23 @@ class Binary_expression : public Expression\n   // if this could be done, false if not.\n   static bool\n   eval_integer(Operator op, Type* left_type, mpz_t left_val,\n-\t       Type* right_type, mpz_t right_val, source_location,\n+\t       Type* right_type, mpz_t right_val, Location,\n \t       mpz_t val);\n \n   // Apply binary opcode OP to LEFT_VAL and RIGHT_VAL, setting VAL.\n   // Return true if this could be done, false if not.\n   static bool\n   eval_float(Operator op, Type* left_type, mpfr_t left_val,\n \t     Type* right_type, mpfr_t right_val, mpfr_t val,\n-\t     source_location);\n+\t     Location);\n \n   // Apply binary opcode OP to LEFT_REAL/LEFT_IMAG and\n   // RIGHT_REAL/RIGHT_IMAG, setting REAL/IMAG.  Return true if this\n   // could be done, false if not.\n   static bool\n   eval_complex(Operator op, Type* left_type, mpfr_t left_real,\n \t       mpfr_t left_imag, Type* right_type, mpfr_t right_real,\n-\t       mpfr_t right_imag, mpfr_t real, mpfr_t imag, source_location);\n+\t       mpfr_t right_imag, mpfr_t real, mpfr_t imag, Location);\n \n   // Compare integer constants according to OP.\n   static bool\n@@ -1149,7 +1149,7 @@ class Binary_expression : public Expression\n   // Report an error if OP can not be applied to TYPE.  Return whether\n   // it can.\n   static bool\n-  check_operator_type(Operator op, Type* type, source_location);\n+  check_operator_type(Operator op, Type* type, Location);\n \n  protected:\n   int\n@@ -1214,7 +1214,7 @@ class Call_expression : public Expression\n {\n  public:\n   Call_expression(Expression* fn, Expression_list* args, bool is_varargs,\n-\t\t  source_location location)\n+\t\t  Location location)\n     : Expression(EXPRESSION_CALL, location),\n       fn_(fn), args_(args), type_(NULL), results_(NULL), tree_(NULL),\n       is_varargs_(is_varargs), are_hidden_fields_ok_(false),\n@@ -1352,7 +1352,7 @@ class Call_expression : public Expression\n \n  private:\n   bool\n-  check_argument_type(int, const Type*, const Type*, source_location, bool);\n+  check_argument_type(int, const Type*, const Type*, Location, bool);\n \n   tree\n   interface_method_function(Translate_context*,\n@@ -1397,7 +1397,7 @@ class Func_expression : public Expression\n {\n  public:\n   Func_expression(Named_object* function, Expression* closure,\n-\t\t  source_location location)\n+\t\t  Location location)\n     : Expression(EXPRESSION_FUNC_REFERENCE, location),\n       function_(function), closure_(closure)\n   { }\n@@ -1461,7 +1461,7 @@ class Func_expression : public Expression\n class Unknown_expression : public Parser_expression\n {\n  public:\n-  Unknown_expression(Named_object* named_object, source_location location)\n+  Unknown_expression(Named_object* named_object, Location location)\n     : Parser_expression(EXPRESSION_UNKNOWN_REFERENCE, location),\n       named_object_(named_object), is_composite_literal_key_(false)\n   { }\n@@ -1512,7 +1512,7 @@ class Index_expression : public Parser_expression\n {\n  public:\n   Index_expression(Expression* left, Expression* start, Expression* end,\n-\t\t   source_location location)\n+\t\t   Location location)\n     : Parser_expression(EXPRESSION_INDEX, location),\n       left_(left), start_(start), end_(end), is_lvalue_(false)\n   { }\n@@ -1574,7 +1574,7 @@ class Map_index_expression : public Expression\n {\n  public:\n   Map_index_expression(Expression* map, Expression* index,\n-\t\t       source_location location)\n+\t\t       Location location)\n     : Expression(EXPRESSION_MAP_INDEX, location),\n       map_(map), index_(index), is_lvalue_(false),\n       is_in_tuple_assignment_(false)\n@@ -1682,7 +1682,7 @@ class Bound_method_expression : public Expression\n {\n  public:\n   Bound_method_expression(Expression* expr, Named_object* method,\n-\t\t\t  source_location location)\n+\t\t\t  Location location)\n     : Expression(EXPRESSION_BOUND_METHOD, location),\n       expr_(expr), expr_type_(NULL), method_(method)\n   { }\n@@ -1753,7 +1753,7 @@ class Field_reference_expression : public Expression\n {\n  public:\n   Field_reference_expression(Expression* expr, unsigned int field_index,\n-\t\t\t     source_location location)\n+\t\t\t     Location location)\n     : Expression(EXPRESSION_FIELD_REFERENCE, location),\n       expr_(expr), field_index_(field_index)\n   { }\n@@ -1824,7 +1824,7 @@ class Interface_field_reference_expression : public Expression\n  public:\n   Interface_field_reference_expression(Expression* expr,\n \t\t\t\t       const std::string& name,\n-\t\t\t\t       source_location location)\n+\t\t\t\t       Location location)\n     : Expression(EXPRESSION_INTERFACE_FIELD_REFERENCE, location),\n       expr_(expr), name_(name)\n   { }\n@@ -1890,7 +1890,7 @@ class Interface_field_reference_expression : public Expression\n class Type_guard_expression : public Expression\n {\n  public:\n-  Type_guard_expression(Expression* expr, Type* type, source_location location)\n+  Type_guard_expression(Expression* expr, Type* type, Location location)\n     : Expression(EXPRESSION_TYPE_GUARD, location),\n       expr_(expr), type_(type)\n   { }\n@@ -1945,7 +1945,7 @@ class Type_guard_expression : public Expression\n class Receive_expression : public Expression\n {\n  public:\n-  Receive_expression(Expression* channel, source_location location)\n+  Receive_expression(Expression* channel, Location location)\n     : Expression(EXPRESSION_RECEIVE, location),\n       channel_(channel), for_select_(false)\n   { }"}, {"sha": "ffbcbe7781b2003dbc29e2ef7f9a515b5aeff11c", "filename": "gcc/go/gofrontend/go-linemap.h", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Fgo-linemap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Fgo-linemap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgo-linemap.h?ref=8afa2bfbdc60088acd7f199245244890a6e7773e", "patch": "@@ -0,0 +1,131 @@\n+// go-linemap.h -- interface to location tracking   -*- C++ -*-\n+\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#ifndef GO_LINEMAP_H\n+#define GO_LINEMAP_H\n+\n+#include \"go-system.h\"\n+\n+// The backend must define a type named Location which holds\n+// information about a location in a source file.  The only thing the\n+// frontend does with instances of Location is pass them back to the\n+// backend interface.  The Location type must be assignable, and it\n+// must be comparable: i.e., it must support operator= and operator<.\n+// The type is normally passed by value rather than by reference, and\n+// it should support that efficiently.  The type should be defined in\n+// \"go-location.h\".\n+\n+#include \"go-location.h\"\n+\n+// The Linemap class is a pure abstract interface, plus some static\n+// convenience functions.  The backend must implement the interface.\n+\n+class Linemap\n+{\n+ public:\n+  Linemap()\n+  {\n+    // Only one instance of Linemap is allowed to exist.\n+    go_assert(Linemap::instance_ == NULL);\n+    Linemap::instance_ = this;\n+  }\n+\n+  virtual\n+  ~Linemap() { Linemap::instance_ = NULL; }\n+\n+  // Subsequent Location values will come from the file named\n+  // FILE_NAME, starting at LINE_BEGIN.  Normally LINE_BEGIN will be\n+  // 0, but it will be non-zero if the Go source has a //line comment.\n+  virtual void\n+  start_file(const char* file_name, unsigned int line_begin) = 0;\n+\n+  // Subsequent Location values will come from the line LINE_NUMBER,\n+  // in the current file.  LINE_SIZE is the size of the line in bytes.\n+  // This will normally be called for every line in a source file.\n+  virtual void\n+  start_line(unsigned int line_number, unsigned int line_size) = 0;\n+\n+  // Get a Location representing column position COLUMN on the current\n+  // line in the current file.\n+  virtual Location\n+  get_location(unsigned int column) = 0;\n+\n+  // Stop generating Location values.  This will be called after all\n+  // input files have been read, in case any cleanup is required.\n+  virtual void\n+  stop() = 0;\n+\n+ protected:\n+  // Return a special Location used for predeclared identifiers.  This\n+  // Location should be different from that for any actual source\n+  // file.  This location will be used for various different types,\n+  // functions, and objects created by the frontend.\n+  virtual Location\n+  get_predeclared_location() = 0;\n+\n+  // Return a special Location which indicates that no actual location\n+  // is known.  This is used for undefined objects and for errors.\n+  virtual Location\n+  get_unknown_location() = 0;\n+\n+  // Return whether the argument is the Location returned by\n+  // get_predeclared_location.\n+  virtual bool\n+  is_predeclared(Location) = 0;\n+\n+  // Return whether the argument is the Location returned by\n+  // get_unknown_location.\n+  virtual bool\n+  is_unknown(Location) = 0;\n+\n+  // The single existing instance of Linemap.\n+  static Linemap *instance_;\n+\n+ public:\n+  // Following are convenience static functions, which allow us to\n+  // access some virtual functions without explicitly passing around\n+  // an instance of Linemap.\n+\n+  // Return the special Location used for predeclared identifiers.\n+  static Location\n+  predeclared_location()\n+  {\n+    go_assert(Linemap::instance_ != NULL);\n+    return Linemap::instance_->get_predeclared_location();\n+  }\n+\n+  // Return the special Location used when no location is known.\n+  static Location\n+  unknown_location()\n+  {\n+    go_assert(Linemap::instance_ != NULL);\n+    return Linemap::instance_->get_unknown_location();\n+  }\n+\n+  // Return whether the argument is the special location used for\n+  // predeclared identifiers.\n+  static bool\n+  is_predeclared_location(Location loc)\n+  {\n+    go_assert(Linemap::instance_ != NULL);\n+    return Linemap::instance_->is_predeclared(loc);\n+  }\n+\n+  // Return whether the argument is the special location used when no\n+  // location is known.\n+  static bool\n+  is_unknown_location(Location loc)\n+  {\n+    go_assert(Linemap::instance_ != NULL);\n+    return Linemap::instance_->is_unknown(loc);\n+  }\n+};\n+\n+// The backend interface must define this function.  It should return\n+// a fully implemented instance of Linemap.\n+extern Linemap* go_get_linemap();\n+\n+#endif // !defined(GO_LINEMAP_H)"}, {"sha": "39af54999ed386c974fbdc68f0f04796389b81c1", "filename": "gcc/go/gofrontend/go.cc", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Fgo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Fgo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgo.cc?ref=8afa2bfbdc60088acd7f199245244890a6e7773e", "patch": "@@ -28,7 +28,8 @@ void\n go_create_gogo(int int_type_size, int pointer_size)\n {\n   go_assert(::gogo == NULL);\n-  ::gogo = new Gogo(go_get_backend(), int_type_size, pointer_size);\n+  Linemap* linemap = go_get_linemap();\n+  ::gogo = new Gogo(go_get_backend(), linemap, int_type_size, pointer_size);\n   if (!unique_prefix.empty())\n     ::gogo->set_unique_prefix(unique_prefix);\n \n@@ -64,6 +65,7 @@ go_parse_input_files(const char** filenames, unsigned int filename_count,\n \t\t     bool only_check_syntax, bool require_return_statement)\n {\n   go_assert(filename_count > 0);\n+\n   for (unsigned int i = 0; i < filename_count; ++i)\n     {\n       if (i > 0)\n@@ -80,7 +82,7 @@ go_parse_input_files(const char** filenames, unsigned int filename_count,\n \t    fatal_error(\"cannot open %s: %m\", filename);\n \t}\n \n-      Lex lexer(filename, file);\n+      Lex lexer(filename, file, ::gogo->linemap());\n \n       Parse parse(&lexer, ::gogo);\n       parse.program();\n@@ -89,6 +91,8 @@ go_parse_input_files(const char** filenames, unsigned int filename_count,\n \tfclose(file);\n     }\n \n+  ::gogo->linemap()->stop();\n+\n   ::gogo->clear_file_scope();\n \n   // If the global predeclared names are referenced but not defined,"}, {"sha": "0e77f5dcd61f483036b75ce6c0e79fdbc1d00515", "filename": "gcc/go/gofrontend/gogo-tree.cc", "status": "modified", "additions": 69, "deletions": 52, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc?ref=8afa2bfbdc60088acd7f199245244890a6e7773e", "patch": "@@ -336,8 +336,9 @@ Gogo::register_gc_vars(const std::vector<Named_object*>& var_gc,\n   rest_of_decl_compilation(decl, 1, 0);\n \n   static tree register_gc_fndecl;\n-  tree call = Gogo::call_builtin(&register_gc_fndecl, BUILTINS_LOCATION,\n-\t\t\t\t \"__go_register_gc_roots\",\n+  tree call = Gogo::call_builtin(&register_gc_fndecl,\n+                                 Linemap::predeclared_location(),\n+                                 \"__go_register_gc_roots\",\n \t\t\t\t 1,\n \t\t\t\t void_type_node,\n \t\t\t\t build_pointer_type(root_list_type),\n@@ -746,8 +747,9 @@ Gogo::write_globals()\n \t      else if (is_sink)\n \t\tvar_init_tree = init;\n \t      else\n-\t\tvar_init_tree = fold_build2_loc(no->location(), MODIFY_EXPR,\n-\t\t\t\t\t\tvoid_type_node, vec[i], init);\n+\t\tvar_init_tree = fold_build2_loc(no->location().gcc_location(),\n+                                                MODIFY_EXPR, void_type_node,\n+                                                vec[i], init);\n \t    }\n \t  else\n \t    {\n@@ -843,7 +845,7 @@ Named_object::get_id(Gogo* gogo)\n       && !this->func_declaration_value()->asm_name().empty())\n     decl_name = this->func_declaration_value()->asm_name();\n   else if (this->is_type()\n-\t   && this->type_value()->location() == BUILTINS_LOCATION)\n+\t   && Linemap::is_predeclared_location(this->type_value()->location()))\n     {\n       // We don't need the package name for builtin types.\n       decl_name = Gogo::unpack_hidden_name(this->name_);\n@@ -920,8 +922,8 @@ Named_object::get_tree(Gogo* gogo, Named_object* function)\n \t      decl = error_mark_node;\n \t    else if (INTEGRAL_TYPE_P(TREE_TYPE(expr_tree)))\n \t      {\n-\t\tdecl = build_decl(named_constant->location(), CONST_DECL,\n-\t\t\t\t  name, TREE_TYPE(expr_tree));\n+\t\tdecl = build_decl(named_constant->location().gcc_location(),\n+                                  CONST_DECL, name, TREE_TYPE(expr_tree));\n \t\tDECL_INITIAL(decl) = expr_tree;\n \t\tTREE_CONSTANT(decl) = 1;\n \t\tTREE_READONLY(decl) = 1;\n@@ -958,9 +960,12 @@ Named_object::get_tree(Gogo* gogo, Named_object* function)\n \t    // descriptor, even though we don't do anything with it.\n \t    if (this->package_ == NULL)\n \t      {\n-\t\tnamed_type->type_descriptor_pointer(gogo, BUILTINS_LOCATION);\n+\t\tnamed_type->\n+                  type_descriptor_pointer(gogo,\n+\t\t\t\t\t  Linemap::predeclared_location());\n \t\tType* pn = Type::make_pointer_type(named_type);\n-\t\tpn->type_descriptor_pointer(gogo, BUILTINS_LOCATION);\n+\t\tpn->type_descriptor_pointer(gogo,\n+\t\t\t\t\t    Linemap::predeclared_location());\n \t      }\n \t  }\n       }\n@@ -989,7 +994,8 @@ Named_object::get_tree(Gogo* gogo, Named_object* function)\n \t\telse\n \t\t  push_cfun(DECL_STRUCT_FUNCTION(decl));\n \n-\t\tcfun->function_end_locus = func->block()->end_location();\n+\t\tcfun->function_end_locus =\n+                  func->block()->end_location().gcc_location();\n \n \t\tcurrent_function_decl = decl;\n \n@@ -1091,8 +1097,9 @@ Variable::get_init_block(Gogo* gogo, Named_object* function, tree var_decl)\n \t\t\t\t\t\t\tthis->location());\n \t  if (val == error_mark_node)\n \t    return error_mark_node;\n-\t  tree set = fold_build2_loc(this->location(), MODIFY_EXPR,\n-\t\t\t\t     void_type_node, var_decl, val);\n+\t  tree set = fold_build2_loc(this->location().gcc_location(),\n+                                     MODIFY_EXPR, void_type_node, var_decl,\n+                                     val);\n \t  append_to_statement_list(set, &statements);\n \t}\n     }\n@@ -1116,7 +1123,8 @@ Function::get_or_make_decl(Gogo* gogo, Named_object* no, tree id)\n \t  // want the real function type for a function declaration.\n \t  go_assert(POINTER_TYPE_P(functype));\n \t  functype = TREE_TYPE(functype);\n-\t  tree decl = build_decl(this->location(), FUNCTION_DECL, id, functype);\n+\t  tree decl = build_decl(this->location().gcc_location(), FUNCTION_DECL,\n+                                 id, functype);\n \n \t  this->fndecl_ = decl;\n \n@@ -1146,8 +1154,9 @@ Function::get_or_make_decl(Gogo* gogo, Named_object* no, tree id)\n \n \t  // Why do we have to do this in the frontend?\n \t  tree restype = TREE_TYPE(functype);\n-\t  tree resdecl = build_decl(this->location(), RESULT_DECL, NULL_TREE,\n-\t\t\t\t    restype);\n+\t  tree resdecl =\n+            build_decl(this->location().gcc_location(), RESULT_DECL, NULL_TREE,\n+                       restype);\n \t  DECL_ARTIFICIAL(resdecl) = 1;\n \t  DECL_IGNORED_P(resdecl) = 1;\n \t  DECL_CONTEXT(resdecl) = decl;\n@@ -1233,7 +1242,8 @@ Function_declaration::get_or_make_decl(Gogo* gogo, Named_object* no, tree id)\n \t  // want the real function type for a function declaration.\n \t  go_assert(POINTER_TYPE_P(functype));\n \t  functype = TREE_TYPE(functype);\n-\t  decl = build_decl(this->location(), FUNCTION_DECL, id, functype);\n+\t  decl = build_decl(this->location().gcc_location(), FUNCTION_DECL, id,\n+                            functype);\n \t  TREE_PUBLIC(decl) = 1;\n \t  DECL_EXTERNAL(decl) = 1;\n \n@@ -1292,7 +1302,8 @@ Function::make_receiver_parm_decl(Gogo* gogo, Named_object* no, tree var_decl)\n \t\t\t\t\t no->location());\n       space = save_expr(space);\n       space = fold_convert(build_pointer_type(val_type), space);\n-      tree spaceref = build_fold_indirect_ref_loc(no->location(), space);\n+      tree spaceref = build_fold_indirect_ref_loc(no->location().gcc_location(),\n+                                                  space);\n       TREE_THIS_NOTRAP(spaceref) = 1;\n       tree set = fold_build2_loc(loc, MODIFY_EXPR, void_type_node,\n \t\t\t\t spaceref, init);\n@@ -1314,7 +1325,7 @@ Function::copy_parm_to_heap(Gogo* gogo, Named_object* no, tree var_decl)\n   if (var_decl == error_mark_node)\n     return error_mark_node;\n   go_assert(TREE_CODE(var_decl) == VAR_DECL);\n-  source_location loc = DECL_SOURCE_LOCATION(var_decl);\n+  Location loc(DECL_SOURCE_LOCATION(var_decl));\n \n   std::string name = IDENTIFIER_POINTER(DECL_NAME(var_decl));\n   name += \".param\";\n@@ -1324,15 +1335,15 @@ Function::copy_parm_to_heap(Gogo* gogo, Named_object* no, tree var_decl)\n   go_assert(POINTER_TYPE_P(type));\n   type = TREE_TYPE(type);\n \n-  tree parm_decl = build_decl(loc, PARM_DECL, id, type);\n+  tree parm_decl = build_decl(loc.gcc_location(), PARM_DECL, id, type);\n   DECL_CONTEXT(parm_decl) = current_function_decl;\n   DECL_ARG_TYPE(parm_decl) = type;\n \n   tree size = TYPE_SIZE_UNIT(type);\n   tree space = gogo->allocate_memory(no->var_value()->type(), size, loc);\n   space = save_expr(space);\n   space = fold_convert(TREE_TYPE(var_decl), space);\n-  tree spaceref = build_fold_indirect_ref_loc(loc, space);\n+  tree spaceref = build_fold_indirect_ref_loc(loc.gcc_location(), space);\n   TREE_THIS_NOTRAP(spaceref) = 1;\n   tree init = build2(COMPOUND_EXPR, TREE_TYPE(space),\n \t\t     build2(MODIFY_EXPR, void_type_node, spaceref, parm_decl),\n@@ -1415,13 +1426,13 @@ Function::build_tree(Gogo* gogo, Named_object* named_function)\n \t    }\n \t  else\n \t    {\n-\t      source_location loc = (*p)->location();\n+\t      Location loc = (*p)->location();\n \t      tree type_tree = type_to_tree(type->get_backend(gogo));\n \t      tree space = gogo->allocate_memory(type,\n \t\t\t\t\t\t TYPE_SIZE_UNIT(type_tree),\n \t\t\t\t\t\t loc);\n \t      tree ptr_type_tree = build_pointer_type(type_tree);\n-\t      init = fold_convert_loc(loc, ptr_type_tree, space);\n+\t      init = fold_convert_loc(loc.gcc_location(), ptr_type_tree, space);\n \t    }\n \n \t  if (var_decl != error_mark_node)\n@@ -1486,7 +1497,8 @@ Function::build_tree(Gogo* gogo, Named_object* named_function)\n       // function.\n       if (defer_init != NULL_TREE && defer_init != error_mark_node)\n \t{\n-\t  SET_EXPR_LOCATION(defer_init, this->block_->start_location());\n+\t  SET_EXPR_LOCATION(defer_init,\n+                            this->block_->start_location().gcc_location());\n \t  append_to_statement_list(defer_init, &init);\n \n \t  // Clean up the defer stack when we leave the function.\n@@ -1524,7 +1536,7 @@ void\n Function::build_defer_wrapper(Gogo* gogo, Named_object* named_function,\n \t\t\t      tree *except, tree *fini)\n {\n-  source_location end_loc = this->block_->end_location();\n+  Location end_loc = this->block_->end_location();\n \n   // Add an exception handler.  This is used if a panic occurs.  Its\n   // purpose is to stop the stack unwinding if a deferred function\n@@ -1545,9 +1557,10 @@ Function::build_defer_wrapper(Gogo* gogo, Named_object* named_function,\n   if (retval == NULL_TREE)\n     set = NULL_TREE;\n   else\n-    set = fold_build2_loc(end_loc, MODIFY_EXPR, void_type_node,\n+    set = fold_build2_loc(end_loc.gcc_location(), MODIFY_EXPR, void_type_node,\n \t\t\t  DECL_RESULT(this->fndecl_), retval);\n-  tree ret_stmt = fold_build1_loc(end_loc, RETURN_EXPR, void_type_node, set);\n+  tree ret_stmt = fold_build1_loc(end_loc.gcc_location(), RETURN_EXPR,\n+                                  void_type_node, set);\n   append_to_statement_list(ret_stmt, &stmt_list);\n \n   go_assert(*except == NULL_TREE);\n@@ -1564,9 +1577,9 @@ Function::build_defer_wrapper(Gogo* gogo, Named_object* named_function,\n \n   stmt_list = NULL;\n \n-  tree label = create_artificial_label(end_loc);\n-  tree define_label = fold_build1_loc(end_loc, LABEL_EXPR, void_type_node,\n-\t\t\t\t      label);\n+  tree label = create_artificial_label(end_loc.gcc_location());\n+  tree define_label = fold_build1_loc(end_loc.gcc_location(), LABEL_EXPR,\n+                                      void_type_node, label);\n   append_to_statement_list(define_label, &stmt_list);\n \n   call = Runtime::make_call(Runtime::UNDEFER, end_loc, 1,\n@@ -1580,7 +1593,8 @@ Function::build_defer_wrapper(Gogo* gogo, Named_object* named_function,\n   if (undefer == error_mark_node || defer == error_mark_node)\n     return;\n \n-  tree jump = fold_build1_loc(end_loc, GOTO_EXPR, void_type_node, label);\n+  tree jump = fold_build1_loc(end_loc.gcc_location(), GOTO_EXPR, void_type_node,\n+                              label);\n   tree catch_body = build2(COMPOUND_EXPR, void_type_node, defer, jump);\n   catch_body = build2(CATCH_EXPR, void_type_node, NULL, catch_body);\n   tree try_catch = build2(TRY_CATCH_EXPR, void_type_node, undefer, catch_body);\n@@ -1598,15 +1612,16 @@ Function::build_defer_wrapper(Gogo* gogo, Named_object* named_function,\n       // variable to true if we are returning from this function.\n       retval = this->return_value(gogo, named_function, end_loc,\n \t\t\t\t  &stmt_list);\n-      set = fold_build2_loc(end_loc, MODIFY_EXPR, void_type_node,\n+      set = fold_build2_loc(end_loc.gcc_location(), MODIFY_EXPR, void_type_node,\n \t\t\t    DECL_RESULT(this->fndecl_), retval);\n-      ret_stmt = fold_build1_loc(end_loc, RETURN_EXPR, void_type_node, set);\n+      ret_stmt = fold_build1_loc(end_loc.gcc_location(), RETURN_EXPR,\n+                                 void_type_node, set);\n \n       Expression* ref =\n \tExpression::make_temporary_reference(this->defer_stack_, end_loc);\n       tree tref = ref->get_tree(&context);\n-      tree s = build3_loc(end_loc, COND_EXPR, void_type_node, tref,\n-\t\t\t  ret_stmt, NULL_TREE);\n+      tree s = build3_loc(end_loc.gcc_location(), COND_EXPR, void_type_node,\n+                          tref, ret_stmt, NULL_TREE);\n \n       append_to_statement_list(s, &stmt_list);\n \n@@ -1623,7 +1638,7 @@ Function::build_defer_wrapper(Gogo* gogo, Named_object* named_function,\n \n tree\n Function::return_value(Gogo* gogo, Named_object* named_function,\n-\t\t       source_location location, tree* stmt_list) const\n+\t\t       Location location, tree* stmt_list) const\n {\n   const Typed_identifier_list* results = this->type_->results();\n   if (results == NULL || results->empty())\n@@ -1644,7 +1659,7 @@ Function::return_value(Gogo* gogo, Named_object* named_function,\n \t\t\t\t\t\t      named_function);\n       tree ret = var_to_tree(bvar);\n       if (this->results_->front()->result_var_value()->is_in_heap())\n-\tret = build_fold_indirect_ref_loc(location, ret);\n+\tret = build_fold_indirect_ref_loc(location.gcc_location(), ret);\n       return ret;\n     }\n   else\n@@ -1662,8 +1677,9 @@ Function::return_value(Gogo* gogo, Named_object* named_function,\n \t  Bvariable* bvar = no->get_backend_variable(gogo, named_function);\n \t  tree val = var_to_tree(bvar);\n \t  if (no->result_var_value()->is_in_heap())\n-\t    val = build_fold_indirect_ref_loc(location, val);\n-\t  tree set = fold_build2_loc(location, MODIFY_EXPR, void_type_node,\n+\t    val = build_fold_indirect_ref_loc(location.gcc_location(), val);\n+\t  tree set = fold_build2_loc(location.gcc_location(), MODIFY_EXPR,\n+                                     void_type_node,\n \t\t\t\t     build3(COMPONENT_REF, TREE_TYPE(field),\n \t\t\t\t\t    retval, field, NULL_TREE),\n \t\t\t\t     val);\n@@ -1762,7 +1778,7 @@ go_type_for_mode(enum machine_mode mode, int unsignedp)\n // type TYPE.\n \n tree\n-Gogo::allocate_memory(Type* type, tree size, source_location location)\n+Gogo::allocate_memory(Type* type, tree size, Location location)\n {\n   // If the package imports unsafe, then it may play games with\n   // pointers that look like integers.\n@@ -2028,7 +2044,8 @@ Gogo::interface_method_table_for_type(const Interface_type* interface,\n     td_type = type;\n   else\n     td_type = Type::make_pointer_type(type);\n-  tree tdp = td_type->type_descriptor_pointer(this, BUILTINS_LOCATION);\n+  tree tdp = td_type->type_descriptor_pointer(this,\n+                                              Linemap::predeclared_location());\n   elt->value = fold_convert(const_ptr_type_node, tdp);\n \n   size_t i = 1;\n@@ -2105,7 +2122,7 @@ Gogo::mark_fndecl_as_builtin_library(tree fndecl)\n // Build a call to a builtin function.\n \n tree\n-Gogo::call_builtin(tree* pdecl, source_location location, const char* name,\n+Gogo::call_builtin(tree* pdecl, Location location, const char* name,\n \t\t   int nargs, tree rettype, ...)\n {\n   if (rettype == error_mark_node)\n@@ -2151,10 +2168,10 @@ Gogo::call_builtin(tree* pdecl, source_location location, const char* name,\n \n   tree fnptr = build_fold_addr_expr(*pdecl);\n   if (CAN_HAVE_LOCATION_P(fnptr))\n-    SET_EXPR_LOCATION(fnptr, location);\n+    SET_EXPR_LOCATION(fnptr, location.gcc_location());\n \n   tree ret = build_call_array(rettype, fnptr, nargs, args);\n-  SET_EXPR_LOCATION(ret, location);\n+  SET_EXPR_LOCATION(ret, location.gcc_location());\n \n   delete[] types;\n   delete[] args;\n@@ -2165,7 +2182,7 @@ Gogo::call_builtin(tree* pdecl, source_location location, const char* name,\n // Build a call to the runtime error function.\n \n tree\n-Gogo::runtime_error(int code, source_location location)\n+Gogo::runtime_error(int code, Location location)\n {\n   static tree runtime_error_fndecl;\n   tree ret = Gogo::call_builtin(&runtime_error_fndecl,\n@@ -2190,7 +2207,7 @@ Gogo::runtime_error(int code, source_location location)\n \n tree\n Gogo::receive_from_channel(tree type_tree, tree channel, bool for_select,\n-\t\t\t   source_location location)\n+\t\t\t   Location location)\n {\n   if (type_tree == error_mark_node || channel == error_mark_node)\n     return error_mark_node;\n@@ -2218,17 +2235,17 @@ Gogo::receive_from_channel(tree type_tree, tree channel, bool for_select,\n       TREE_NOTHROW(receive_small_fndecl) = 0;\n       int bitsize = GET_MODE_BITSIZE(TYPE_MODE(type_tree));\n       tree int_type_tree = go_type_for_size(bitsize, 1);\n-      return fold_convert_loc(location, type_tree,\n-\t\t\t      fold_convert_loc(location, int_type_tree,\n-\t\t\t\t\t       call));\n+      return fold_convert_loc(location.gcc_location(), type_tree,\n+\t\t\t      fold_convert_loc(location.gcc_location(),\n+                                               int_type_tree, call));\n     }\n   else\n     {\n       tree tmp = create_tmp_var(type_tree, get_name(type_tree));\n       DECL_IGNORED_P(tmp) = 0;\n       TREE_ADDRESSABLE(tmp) = 1;\n       tree make_tmp = build1(DECL_EXPR, void_type_node, tmp);\n-      SET_EXPR_LOCATION(make_tmp, location);\n+      SET_EXPR_LOCATION(make_tmp, location.gcc_location());\n       tree tmpaddr = build_fold_addr_expr(tmp);\n       tmpaddr = fold_convert(ptr_type_node, tmpaddr);\n       static tree receive_big_fndecl;\n@@ -2284,7 +2301,7 @@ Gogo::trampoline_type_tree()\n // Make a trampoline which calls FNADDR passing CLOSURE.\n \n tree\n-Gogo::make_trampoline(tree fnaddr, tree closure, source_location location)\n+Gogo::make_trampoline(tree fnaddr, tree closure, Location location)\n {\n   tree trampoline_type = Gogo::trampoline_type_tree();\n   tree trampoline_size = TYPE_SIZE_UNIT(trampoline_type);\n@@ -2302,8 +2319,8 @@ Gogo::make_trampoline(tree fnaddr, tree closure, source_location location)\n \t\t\t      size_type_node,\n \t\t\t      trampoline_size,\n \t\t\t      ptr_type_node,\n-\t\t\t      fold_convert_loc(location, ptr_type_node,\n-\t\t\t\t\t       closure));\n+\t\t\t      fold_convert_loc(location.gcc_location(),\n+                                               ptr_type_node, closure));\n   if (x == error_mark_node)\n     return error_mark_node;\n "}, {"sha": "dc5ac75268a714268cb765d40b4b1bddece54e47", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 58, "deletions": 56, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=8afa2bfbdc60088acd7f199245244890a6e7773e", "patch": "@@ -21,8 +21,10 @@\n \n // Class Gogo.\n \n-Gogo::Gogo(Backend* backend, int int_type_size, int pointer_size)\n+Gogo::Gogo(Backend* backend, Linemap* linemap, int int_type_size,\n+           int pointer_size)\n   : backend_(backend),\n+    linemap_(linemap),\n     package_(NULL),\n     functions_(),\n     globals_(new Bindings(NULL)),\n@@ -38,7 +40,7 @@ Gogo::Gogo(Backend* backend, int int_type_size, int pointer_size)\n     interface_types_(),\n     named_types_are_converted_(false)\n {\n-  const source_location loc = BUILTINS_LOCATION;\n+  const Location loc = Linemap::predeclared_location();\n \n   Named_type* uint8_type = Type::make_integer_type(\"uint8\", true, 8,\n \t\t\t\t\t\t   RUNTIME_TYPE_KIND_UINT8);\n@@ -245,7 +247,7 @@ Gogo::package_name() const\n \n void\n Gogo::set_package_name(const std::string& package_name,\n-\t\t       source_location location)\n+\t\t       Location location)\n {\n   if (this->package_ != NULL && this->package_->name() != package_name)\n     {\n@@ -270,10 +272,10 @@ Gogo::set_package_name(const std::string& package_name,\n     {\n       // Declare \"main\" as a function which takes no parameters and\n       // returns no value.\n+      Location uloc = Linemap::unknown_location();\n       this->declare_function(\"main\",\n-\t\t\t     Type::make_function_type(NULL, NULL, NULL,\n-\t\t\t\t\t\t      BUILTINS_LOCATION),\n-\t\t\t     BUILTINS_LOCATION);\n+\t\t\t     Type::make_function_type (NULL, NULL, NULL, uloc),\n+\t\t\t     uloc);\n     }\n }\n \n@@ -292,7 +294,7 @@ void\n Gogo::import_package(const std::string& filename,\n \t\t     const std::string& local_name,\n \t\t     bool is_local_name_exported,\n-\t\t     source_location location)\n+\t\t     Location location)\n {\n   if (filename == \"unsafe\")\n     {\n@@ -502,7 +504,7 @@ Gogo::add_imported_package(const std::string& real_name,\n \t\t\t   const std::string& alias_arg,\n \t\t\t   bool is_alias_exported,\n \t\t\t   const std::string& unique_prefix,\n-\t\t\t   source_location location,\n+\t\t\t   Location location,\n \t\t\t   bool* padd_to_globals)\n {\n   // FIXME: Now that we compile packages as a whole, should we permit\n@@ -552,7 +554,7 @@ Gogo::add_imported_package(const std::string& real_name,\n \n Named_object*\n Gogo::add_package(const std::string& real_name, const std::string& alias,\n-\t\t  const std::string& unique_prefix, source_location location)\n+\t\t  const std::string& unique_prefix, Location location)\n {\n   go_assert(this->in_global_scope());\n \n@@ -570,7 +572,7 @@ Gogo::add_package(const std::string& real_name, const std::string& alias,\n Package*\n Gogo::register_package(const std::string& package_name,\n \t\t       const std::string& unique_prefix,\n-\t\t       source_location location)\n+\t\t       Location location)\n {\n   go_assert(!unique_prefix.empty() && !package_name.empty());\n   std::string name = unique_prefix + '.' + package_name;\n@@ -584,7 +586,7 @@ Gogo::register_package(const std::string& package_name,\n       go_assert(package != NULL);\n       go_assert(package->name() == package_name\n \t\t && package->unique_prefix() == unique_prefix);\n-      if (package->location() == UNKNOWN_LOCATION)\n+      if (Linemap::is_unknown_location(package->location()))\n \tpackage->set_location(location);\n     }\n   else\n@@ -602,7 +604,7 @@ Gogo::register_package(const std::string& package_name,\n \n Named_object*\n Gogo::start_function(const std::string& name, Function_type* type,\n-\t\t     bool add_method_to_type, source_location location)\n+\t\t     bool add_method_to_type, Location location)\n {\n   bool at_top_level = this->functions_.empty();\n \n@@ -787,7 +789,7 @@ Gogo::start_function(const std::string& name, Function_type* type,\n // Finish compiling a function.\n \n void\n-Gogo::finish_function(source_location location)\n+Gogo::finish_function(Location location)\n {\n   this->finish_block(location);\n   go_assert(this->functions_.back().blocks.empty());\n@@ -806,7 +808,7 @@ Gogo::current_function() const\n // Start a new block.\n \n void\n-Gogo::start_block(source_location location)\n+Gogo::start_block(Location location)\n {\n   go_assert(!this->functions_.empty());\n   Block* block = new Block(this->current_block(), location);\n@@ -816,7 +818,7 @@ Gogo::start_block(source_location location)\n // Finish a block.\n \n Block*\n-Gogo::finish_block(source_location location)\n+Gogo::finish_block(Location location)\n {\n   go_assert(!this->functions_.empty());\n   go_assert(!this->functions_.back().blocks.empty());\n@@ -829,7 +831,7 @@ Gogo::finish_block(source_location location)\n // Add an unknown name.\n \n Named_object*\n-Gogo::add_unknown_name(const std::string& name, source_location location)\n+Gogo::add_unknown_name(const std::string& name, Location location)\n {\n   return this->package_->bindings()->add_unknown_name(name, location);\n }\n@@ -838,7 +840,7 @@ Gogo::add_unknown_name(const std::string& name, source_location location)\n \n Named_object*\n Gogo::declare_function(const std::string& name, Function_type* type,\n-\t\t       source_location location)\n+\t\t       Location location)\n {\n   if (!type->is_method())\n     return this->current_bindings()->add_function_declaration(name, NULL, type,\n@@ -874,7 +876,7 @@ Gogo::declare_function(const std::string& name, Function_type* type,\n \n Label*\n Gogo::add_label_definition(const std::string& label_name,\n-\t\t\t   source_location location)\n+\t\t\t   Location location)\n {\n   go_assert(!this->functions_.empty());\n   Function* func = this->functions_.back().function->func_value();\n@@ -887,7 +889,7 @@ Gogo::add_label_definition(const std::string& label_name,\n \n Label*\n Gogo::add_label_reference(const std::string& label_name,\n-\t\t\t  source_location location, bool issue_goto_errors)\n+\t\t\t  Location location, bool issue_goto_errors)\n {\n   go_assert(!this->functions_.empty());\n   Function* func = this->functions_.back().function->func_value();\n@@ -898,7 +900,7 @@ Gogo::add_label_reference(const std::string& label_name,\n // Return the current binding state.\n \n Bindings_snapshot*\n-Gogo::bindings_snapshot(source_location location)\n+Gogo::bindings_snapshot(Location location)\n {\n   return new Bindings_snapshot(this->current_block(), location);\n }\n@@ -916,7 +918,7 @@ Gogo::add_statement(Statement* statement)\n // Add a block.\n \n void\n-Gogo::add_block(Block* block, source_location location)\n+Gogo::add_block(Block* block, Location location)\n {\n   go_assert(!this->functions_.empty()\n \t     && !this->functions_.back().blocks.empty());\n@@ -936,7 +938,7 @@ Gogo::add_constant(const Typed_identifier& tid, Expression* expr,\n // Add a type.\n \n void\n-Gogo::add_type(const std::string& name, Type* type, source_location location)\n+Gogo::add_type(const std::string& name, Type* type, Location location)\n {\n   Named_object* no = this->current_bindings()->add_type(name, NULL, type,\n \t\t\t\t\t\t\tlocation);\n@@ -956,7 +958,7 @@ Gogo::add_named_type(Named_type* type)\n // Declare a type.\n \n Named_object*\n-Gogo::declare_type(const std::string& name, source_location location)\n+Gogo::declare_type(const std::string& name, Location location)\n {\n   Bindings* bindings = this->current_bindings();\n   Named_object* no = bindings->add_type_declaration(name, NULL, location);\n@@ -971,7 +973,7 @@ Gogo::declare_type(const std::string& name, source_location location)\n // Declare a type at the package level.\n \n Named_object*\n-Gogo::declare_package_type(const std::string& name, source_location location)\n+Gogo::declare_package_type(const std::string& name, Location location)\n {\n   return this->package_->bindings()->add_type_declaration(name, NULL, location);\n }\n@@ -1077,9 +1079,9 @@ Gogo::define_global_names()\n \t    {\n \t      error_at(no->location(), \"expected type\");\n \t      Type* errtype = Type::make_error_type();\n-\t      Named_object* err = Named_object::make_type(\"error\", NULL,\n-\t\t\t\t\t\t\t  errtype,\n-\t\t\t\t\t\t\t  BUILTINS_LOCATION);\n+\t      Named_object* err =\n+                Named_object::make_type(\"erroneous_type\", NULL, errtype,\n+                                        Linemap::predeclared_location());\n \t      no->set_type_value(err->type_value());\n \t    }\n \t}\n@@ -1839,7 +1841,7 @@ Shortcuts::convert_shortcut(Block* enclosing, Expression** pshortcut)\n   Binary_expression* shortcut = (*pshortcut)->binary_expression();\n   Expression* left = shortcut->left();\n   Expression* right = shortcut->right();\n-  source_location loc = shortcut->location();\n+  Location loc = shortcut->location();\n \n   Block* retblock = new Block(enclosing, loc);\n   retblock->set_end_location(loc);\n@@ -2032,7 +2034,7 @@ Order_eval::statement(Block* block, size_t* pindex, Statement* s)\n       if (is_thunk && p + 1 == find_eval_ordering.end())\n \tbreak;\n \n-      source_location loc = (*pexpr)->location();\n+      Location loc = (*pexpr)->location();\n       Statement* s;\n       if ((*pexpr)->call_expression() == NULL\n \t  || (*pexpr)->call_expression()->result_count() < 2)\n@@ -2091,7 +2093,7 @@ Order_eval::variable(Named_object* no)\n        ++p)\n     {\n       Expression** pexpr = *p;\n-      source_location loc = (*pexpr)->location();\n+      Location loc = (*pexpr)->location();\n       Statement* s;\n       if ((*pexpr)->call_expression() == NULL\n \t  || (*pexpr)->call_expression()->result_count() < 2)\n@@ -2173,7 +2175,7 @@ class Build_recover_thunks : public Traverse\n \n  private:\n   Expression*\n-  can_recover_arg(source_location);\n+  can_recover_arg(Location);\n \n   // General IR.\n   Gogo* gogo_;\n@@ -2191,7 +2193,7 @@ Build_recover_thunks::function(Named_object* orig_no)\n     return TRAVERSE_CONTINUE;\n \n   Gogo* gogo = this->gogo_;\n-  source_location location = orig_func->location();\n+  Location location = orig_func->location();\n \n   static int count;\n   char buf[50];\n@@ -2389,12 +2391,12 @@ Build_recover_thunks::function(Named_object* orig_no)\n // __go_can_recover(__builtin_return_address()).\n \n Expression*\n-Build_recover_thunks::can_recover_arg(source_location location)\n+Build_recover_thunks::can_recover_arg(Location location)\n {\n   static Named_object* builtin_return_address;\n   if (builtin_return_address == NULL)\n     {\n-      const source_location bloc = BUILTINS_LOCATION;\n+      const Location bloc = Linemap::predeclared_location();\n \n       Typed_identifier_list* param_types = new Typed_identifier_list();\n       Type* uint_type = Type::lookup_integer_type(\"uint\");\n@@ -2416,7 +2418,7 @@ Build_recover_thunks::can_recover_arg(source_location location)\n   static Named_object* can_recover;\n   if (can_recover == NULL)\n     {\n-      const source_location bloc = BUILTINS_LOCATION;\n+      const Location bloc = Linemap::predeclared_location();\n       Typed_identifier_list* param_types = new Typed_identifier_list();\n       Type* voidptr_type = Type::make_pointer_type(Type::make_void_type());\n       param_types->push_back(Typed_identifier(\"a\", voidptr_type, bloc));\n@@ -2748,7 +2750,7 @@ Gogo::convert_named_types_in_bindings(Bindings* bindings)\n // Class Function.\n \n Function::Function(Function_type* type, Function* enclosing, Block* block,\n-\t\t   source_location location)\n+\t\t   Location location)\n   : type_(type), enclosing_(enclosing), results_(NULL),\n     closure_var_(NULL), block_(block), location_(location), fndecl_(NULL),\n     defer_stack_(NULL), results_are_named_(false), calls_recover_(false),\n@@ -2829,7 +2831,7 @@ Function::closure_var()\n     {\n       // We don't know the type of the variable yet.  We add fields as\n       // we find them.\n-      source_location loc = this->type_->location();\n+      Location loc = this->type_->location();\n       Struct_field_list* sfl = new Struct_field_list;\n       Type* struct_type = Type::make_struct_type(sfl, loc);\n       Variable* var = new Variable(Type::make_pointer_type(struct_type),\n@@ -2880,7 +2882,7 @@ Function::is_method() const\n \n Label*\n Function::add_label_definition(Gogo* gogo, const std::string& label_name,\n-\t\t\t       source_location location)\n+\t\t\t       Location location)\n {\n   Label* lnull = NULL;\n   std::pair<Labels::iterator, bool> ins =\n@@ -2924,7 +2926,7 @@ Function::add_label_definition(Gogo* gogo, const std::string& label_name,\n \n Label*\n Function::add_label_reference(Gogo* gogo, const std::string& label_name,\n-\t\t\t      source_location location, bool issue_goto_errors)\n+\t\t\t      Location location, bool issue_goto_errors)\n {\n   Label* lnull = NULL;\n   std::pair<Labels::iterator, bool> ins =\n@@ -3039,7 +3041,7 @@ Function::determine_types()\n // function which uses defer.\n \n Expression*\n-Function::defer_stack(source_location location)\n+Function::defer_stack(Location location)\n {\n   if (this->defer_stack_ == NULL)\n     {\n@@ -3218,7 +3220,7 @@ Function::import_func(Import* imp, std::string* pname,\n \n // Class Block.\n \n-Block::Block(Block* enclosing, source_location location)\n+Block::Block(Block* enclosing, Location location)\n   : enclosing_(enclosing), statements_(),\n     bindings_(new Bindings(enclosing == NULL\n \t\t\t   ? NULL\n@@ -3463,7 +3465,7 @@ Block::get_backend(Translate_context* context)\n \n // Class Bindings_snapshot.\n \n-Bindings_snapshot::Bindings_snapshot(const Block* b, source_location location)\n+Bindings_snapshot::Bindings_snapshot(const Block* b, Location location)\n   : block_(b), counts_(), location_(location)\n {\n   while (b != NULL)\n@@ -3476,7 +3478,7 @@ Bindings_snapshot::Bindings_snapshot(const Block* b, source_location location)\n // Report errors appropriate for a goto from B to this.\n \n void\n-Bindings_snapshot::check_goto_from(const Block* b, source_location loc)\n+Bindings_snapshot::check_goto_from(const Block* b, Location loc)\n {\n   size_t dummy;\n   if (!this->check_goto_block(loc, b, this->block_, &dummy))\n@@ -3504,7 +3506,7 @@ Bindings_snapshot::check_goto_to(const Block* b)\n // BFROM.\n \n bool\n-Bindings_snapshot::check_goto_block(source_location loc, const Block* bfrom,\n+Bindings_snapshot::check_goto_block(Location loc, const Block* bfrom,\n \t\t\t\t    const Block* bto, size_t* pindex)\n {\n   // It is an error if BTO is not either BFROM or above BFROM.\n@@ -3527,7 +3529,7 @@ Bindings_snapshot::check_goto_block(source_location loc, const Block* bfrom,\n // CTO is the number of names defined at the point of the label.\n \n void\n-Bindings_snapshot::check_goto_defs(source_location loc, const Block* block,\n+Bindings_snapshot::check_goto_defs(Location loc, const Block* block,\n \t\t\t\t   size_t cfrom, size_t cto)\n {\n   if (cfrom < cto)\n@@ -3551,7 +3553,7 @@ Bindings_snapshot::check_goto_defs(source_location loc, const Block* block,\n \n Variable::Variable(Type* type, Expression* init, bool is_global,\n \t\t   bool is_parameter, bool is_receiver,\n-\t\t   source_location location)\n+\t\t   Location location)\n   : type_(type), init_(init), preinit_(NULL), location_(location),\n     backend_(NULL), is_global_(is_global), is_parameter_(is_parameter),\n     is_receiver_(is_receiver), is_varargs_parameter_(false),\n@@ -4098,7 +4100,7 @@ Type_declaration::add_method(const std::string& name, Function* function)\n Named_object*\n Type_declaration::add_method_declaration(const std::string&  name,\n \t\t\t\t\t Function_type* type,\n-\t\t\t\t\t source_location location)\n+\t\t\t\t\t Location location)\n {\n   Named_object* ret = Named_object::make_function_declaration(name, NULL, type,\n \t\t\t\t\t\t\t      location);\n@@ -4165,7 +4167,7 @@ Named_object::Named_object(const std::string& name,\n \n Named_object*\n Named_object::make_unknown_name(const std::string& name,\n-\t\t\t\tsource_location location)\n+\t\t\t\tLocation location)\n {\n   Named_object* named_object = new Named_object(name, NULL,\n \t\t\t\t\t\tNAMED_OBJECT_UNKNOWN);\n@@ -4194,7 +4196,7 @@ Named_object::make_constant(const Typed_identifier& tid,\n \n Named_object*\n Named_object::make_type(const std::string& name, const Package* package,\n-\t\t\tType* type, source_location location)\n+\t\t\tType* type, Location location)\n {\n   Named_object* named_object = new Named_object(name, package,\n \t\t\t\t\t\tNAMED_OBJECT_TYPE);\n@@ -4208,7 +4210,7 @@ Named_object::make_type(const std::string& name, const Package* package,\n Named_object*\n Named_object::make_type_declaration(const std::string& name,\n \t\t\t\t    const Package* package,\n-\t\t\t\t    source_location location)\n+\t\t\t\t    Location location)\n {\n   Named_object* named_object = new Named_object(name, package,\n \t\t\t\t\t\tNAMED_OBJECT_TYPE_DECLARATION);\n@@ -4267,7 +4269,7 @@ Named_object*\n Named_object::make_function_declaration(const std::string& name,\n \t\t\t\t\tconst Package* package,\n \t\t\t\t\tFunction_type* fntype,\n-\t\t\t\t\tsource_location location)\n+\t\t\t\t\tLocation location)\n {\n   Named_object* named_object = new Named_object(name, package,\n \t\t\t\t\t\tNAMED_OBJECT_FUNC_DECLARATION);\n@@ -4341,7 +4343,7 @@ Named_object::declare_as_type()\n \n // Return the location of a named object.\n \n-source_location\n+Location\n Named_object::location() const\n {\n   switch (this->classification_)\n@@ -4717,7 +4719,7 @@ Named_object*\n Bindings::add_function_declaration(const std::string& name,\n \t\t\t\t   const Package* package,\n \t\t\t\t   Function_type* type,\n-\t\t\t\t   source_location location)\n+\t\t\t\t   Location location)\n {\n   Named_object* no = Named_object::make_function_declaration(name, package,\n \t\t\t\t\t\t\t     type, location);\n@@ -4869,7 +4871,7 @@ Label::get_backend_label(Translate_context* context)\n // Return an expression for the address of this label.\n \n Bexpression*\n-Label::get_addr(Translate_context* context, source_location location)\n+Label::get_addr(Translate_context* context, Location location)\n {\n   Blabel* label = this->get_backend_label(context);\n   return context->backend()->label_address(label, location);\n@@ -4905,7 +4907,7 @@ Unnamed_label::get_definition(Translate_context* context)\n // Return a goto statement to this unnamed label.\n \n Bstatement*\n-Unnamed_label::get_goto(Translate_context* context, source_location location)\n+Unnamed_label::get_goto(Translate_context* context, Location location)\n {\n   Blabel* blabel = this->get_blabel(context);\n   return context->backend()->goto_statement(blabel, location);\n@@ -4914,7 +4916,7 @@ Unnamed_label::get_goto(Translate_context* context, source_location location)\n // Class Package.\n \n Package::Package(const std::string& name, const std::string& unique_prefix,\n-\t\t source_location location)\n+\t\t Location location)\n   : name_(name), unique_prefix_(unique_prefix), bindings_(new Bindings(NULL)),\n     priority_(0), location_(location), used_(false), is_imported_(false),\n     uses_sink_alias_(false)"}, {"sha": "9d3b37ae857f857d2658b2302a0478914c187f69", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 104, "deletions": 94, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=8afa2bfbdc60088acd7f199245244890a6e7773e", "patch": "@@ -7,6 +7,8 @@\n #ifndef GO_GOGO_H\n #define GO_GOGO_H\n \n+#include \"go-linemap.h\"\n+\n class Traverse;\n class Statement_inserter;\n class Type;\n@@ -111,20 +113,25 @@ class Gogo\n  public:\n   // Create the IR, passing in the sizes of the types \"int\" and\n   // \"uintptr\" in bits.\n-  Gogo(Backend* backend, int int_type_size, int pointer_size);\n+  Gogo(Backend* backend, Linemap *linemap, int int_type_size, int pointer_size);\n \n   // Get the backend generator.\n   Backend*\n   backend()\n   { return this->backend_; }\n \n+  // Get the Location generator.\n+  Linemap*\n+  linemap()\n+  { return this->linemap_; }\n+\n   // Get the package name.\n   const std::string&\n   package_name() const;\n \n   // Set the package name.\n   void\n-  set_package_name(const std::string&, source_location);\n+  set_package_name(const std::string&, Location);\n \n   // Return whether this is the \"main\" package.\n   bool\n@@ -195,7 +202,7 @@ class Gogo\n   // the declarations are added to the global scope.\n   void\n   import_package(const std::string& filename, const std::string& local_name,\n-\t\t bool is_local_name_exported, source_location);\n+\t\t bool is_local_name_exported, Location);\n \n   // Whether we are the global binding level.\n   bool\n@@ -223,25 +230,25 @@ class Gogo\n   add_imported_package(const std::string& real_name, const std::string& alias,\n \t\t       bool is_alias_exported,\n \t\t       const std::string& unique_prefix,\n-\t\t       source_location location,\n+\t\t       Location location,\n \t\t       bool* padd_to_globals);\n \n   // Register a package.  This package may or may not be imported.\n   // This returns the Package structure for the package, creating if\n   // it necessary.\n   Package*\n   register_package(const std::string& name, const std::string& unique_prefix,\n-\t\t   source_location);\n+\t\t   Location);\n \n   // Start compiling a function.  ADD_METHOD_TO_TYPE is true if a\n   // method function should be added to the type of its receiver.\n   Named_object*\n   start_function(const std::string& name, Function_type* type,\n-\t\t bool add_method_to_type, source_location);\n+\t\t bool add_method_to_type, Location);\n \n   // Finish compiling a function.\n   void\n-  finish_function(source_location);\n+  finish_function(Location);\n \n   // Return the current function.\n   Named_object*\n@@ -254,52 +261,52 @@ class Gogo\n   // Start a new block.  This is not initially associated with a\n   // function.\n   void\n-  start_block(source_location);\n+  start_block(Location);\n \n   // Finish the current block and return it.\n   Block*\n-  finish_block(source_location);\n+  finish_block(Location);\n \n   // Declare an unknown name.  This is used while parsing.  The name\n   // must be resolved by the end of the parse.  Unknown names are\n   // always added at the package level.\n   Named_object*\n-  add_unknown_name(const std::string& name, source_location);\n+  add_unknown_name(const std::string& name, Location);\n \n   // Declare a function.\n   Named_object*\n-  declare_function(const std::string&, Function_type*, source_location);\n+  declare_function(const std::string&, Function_type*, Location);\n \n   // Add a label.\n   Label*\n-  add_label_definition(const std::string&, source_location);\n+  add_label_definition(const std::string&, Location);\n \n   // Add a label reference.  ISSUE_GOTO_ERRORS is true if we should\n   // report errors for a goto from the current location to the label\n   // location.\n   Label*\n-  add_label_reference(const std::string&, source_location,\n+  add_label_reference(const std::string&, Location,\n \t\t      bool issue_goto_errors);\n \n   // Return a snapshot of the current binding state.\n   Bindings_snapshot*\n-  bindings_snapshot(source_location);\n+  bindings_snapshot(Location);\n \n   // Add a statement to the current block.\n   void\n   add_statement(Statement*);\n \n   // Add a block to the current block.\n   void\n-  add_block(Block*, source_location);\n+  add_block(Block*, Location);\n \n   // Add a constant.\n   Named_object*\n   add_constant(const Typed_identifier&, Expression*, int iota_value);\n \n   // Add a type.\n   void\n-  add_type(const std::string&, Type*, source_location);\n+  add_type(const std::string&, Type*, Location);\n \n   // Add a named type.  This is used for builtin types, and to add an\n   // imported type to the global scope.\n@@ -308,12 +315,12 @@ class Gogo\n \n   // Declare a type.\n   Named_object*\n-  declare_type(const std::string&, source_location);\n+  declare_type(const std::string&, Location);\n \n   // Declare a type at the package level.  This is used when the\n   // parser sees an unknown name where a type name is required.\n   Named_object*\n-  declare_package_type(const std::string&, source_location);\n+  declare_package_type(const std::string&, Location);\n \n   // Define a type which was already declared.\n   void\n@@ -466,12 +473,12 @@ class Gogo\n   // RETTYPE is the return type.  It is followed by NARGS pairs of\n   // type and argument (both trees).\n   static tree\n-  call_builtin(tree* pdecl, source_location, const char* name, int nargs,\n+  call_builtin(tree* pdecl, Location, const char* name, int nargs,\n \t       tree rettype, ...);\n \n   // Build a call to the runtime error function.\n   static tree\n-  runtime_error(int code, source_location);\n+  runtime_error(int code, Location);\n \n   // Build a builtin struct with a list of fields.\n   static tree\n@@ -503,7 +510,7 @@ class Gogo\n   // Return a tree which allocate SIZE bytes to hold values of type\n   // TYPE.\n   tree\n-  allocate_memory(Type *type, tree size, source_location);\n+  allocate_memory(Type *type, tree size, Location);\n \n   // Return a type to use for pointer to const char.\n   static tree\n@@ -521,7 +528,7 @@ class Gogo\n   // Receive a value from a channel.\n   static tree\n   receive_from_channel(tree type_tree, tree channel, bool for_select,\n-\t\t       source_location);\n+\t\t       Location);\n \n   // Return a tree for receiving an integer on a channel.\n   static tree\n@@ -530,7 +537,7 @@ class Gogo\n \n   // Make a trampoline which calls FNADDR passing CLOSURE.\n   tree\n-  make_trampoline(tree fnaddr, tree closure, source_location);\n+  make_trampoline(tree fnaddr, tree closure, Location);\n \n  private:\n   // During parsing, we keep a stack of functions.  Each function on\n@@ -549,12 +556,12 @@ class Gogo\n \n   // Set up the built-in unsafe package.\n   void\n-  import_unsafe(const std::string&, bool is_exported, source_location);\n+  import_unsafe(const std::string&, bool is_exported, Location);\n \n   // Add a new imported package.\n   Named_object*\n   add_package(const std::string& real_name, const std::string& alias,\n-\t      const std::string& unique_prefix, source_location location);\n+\t      const std::string& unique_prefix, Location location);\n \n   // Return the current binding contour.\n   Bindings*\n@@ -603,6 +610,8 @@ class Gogo\n \n   // The backend generator.\n   Backend* backend_;\n+  // The object used to keep track of file names and line numbers.\n+  Linemap* linemap_;\n   // The package we are compiling.\n   Package* package_;\n   // The list of currently open functions during parsing.\n@@ -640,7 +649,7 @@ class Gogo\n class Block\n {\n  public:\n-  Block(Block* enclosing, source_location);\n+  Block(Block* enclosing, Location);\n \n   // Return the enclosing block.\n   const Block*\n@@ -663,13 +672,13 @@ class Block\n \n   // Return the start location.  This is normally the location of the\n   // left curly brace which starts the block.\n-  source_location\n+  Location\n   start_location() const\n   { return this->start_location_; }\n \n   // Return the end location.  This is normally the location of the\n   // right curly brace which ends the block.\n-  source_location\n+  Location\n   end_location() const\n   { return this->end_location_; }\n \n@@ -695,7 +704,7 @@ class Block\n \n   // Set the end location of the block.\n   void\n-  set_end_location(source_location location)\n+  set_end_location(Location location)\n   { this->end_location_ = location; }\n \n   // Traverse the tree.\n@@ -735,17 +744,17 @@ class Block\n   // Binding contour.\n   Bindings* bindings_;\n   // Location of start of block.\n-  source_location start_location_;\n+  Location start_location_;\n   // Location of end of block.\n-  source_location end_location_;\n+  Location end_location_;\n };\n \n // A function.\n \n class Function\n {\n  public:\n-  Function(Function_type* type, Function*, Block*, source_location);\n+  Function(Function_type* type, Function*, Block*, Location);\n \n   // Return the function's type.\n   Function_type*\n@@ -790,7 +799,7 @@ class Function\n \n   // Add a new field to the closure variable.\n   void\n-  add_closure_field(Named_object* var, source_location loc)\n+  add_closure_field(Named_object* var, Location loc)\n   { this->closure_fields_.push_back(std::make_pair(var, loc)); }\n \n   // Whether this function needs a closure.\n@@ -831,7 +840,7 @@ class Function\n   { return this->block_; }\n \n   // Get the location of the start of the function.\n-  source_location\n+  Location\n   location() const\n   { return this->location_; }\n \n@@ -841,14 +850,14 @@ class Function\n \n   // Add a label definition to the function.\n   Label*\n-  add_label_definition(Gogo*, const std::string& label_name, source_location);\n+  add_label_definition(Gogo*, const std::string& label_name, Location);\n \n   // Add a label reference to a function.  ISSUE_GOTO_ERRORS is true\n   // if we should report errors for a goto from the current location\n   // to the label location.\n   Label*\n   add_label_reference(Gogo*, const std::string& label_name,\n-\t\t      source_location, bool issue_goto_errors);\n+\t\t      Location, bool issue_goto_errors);\n \n   // Warn about labels that are defined but not used.\n   void\n@@ -918,11 +927,11 @@ class Function\n   // Get the value to return when not explicitly specified.  May also\n   // add statements to execute first to STMT_LIST.\n   tree\n-  return_value(Gogo*, Named_object*, source_location, tree* stmt_list) const;\n+  return_value(Gogo*, Named_object*, Location, tree* stmt_list) const;\n \n   // Get a tree for the variable holding the defer stack.\n   Expression*\n-  defer_stack(source_location);\n+  defer_stack(Location);\n \n   // Export the function.\n   void\n@@ -953,7 +962,7 @@ class Function\n   build_defer_wrapper(Gogo*, Named_object*, tree*, tree*);\n \n   typedef std::vector<std::pair<Named_object*,\n-\t\t\t\tsource_location> > Closure_fields;\n+\t\t\t\tLocation> > Closure_fields;\n \n   // The function's type.\n   Function_type* type_;\n@@ -972,7 +981,7 @@ class Function\n   // The outer block of statements in the function.\n   Block* block_;\n   // The source location of the start of the function.\n-  source_location location_;\n+  Location location_;\n   // Labels defined or referenced in the function.\n   Labels labels_;\n   // The function decl.\n@@ -996,12 +1005,12 @@ class Function\n class Bindings_snapshot\n {\n  public:\n-  Bindings_snapshot(const Block*, source_location);\n+  Bindings_snapshot(const Block*, Location);\n \n   // Report any errors appropriate for a goto from the current binding\n   // state of B to this one.\n   void\n-  check_goto_from(const Block* b, source_location);\n+  check_goto_from(const Block* b, Location);\n \n   // Report any errors appropriate for a goto from this binding state\n   // to the current state of B.\n@@ -1010,10 +1019,10 @@ class Bindings_snapshot\n \n  private:\n   bool\n-  check_goto_block(source_location, const Block*, const Block*, size_t*);\n+  check_goto_block(Location, const Block*, const Block*, size_t*);\n \n   void\n-  check_goto_defs(source_location, const Block*, size_t, size_t);\n+  check_goto_defs(Location, const Block*, size_t, size_t);\n \n   // The current block.\n   const Block* block_;\n@@ -1022,23 +1031,23 @@ class Bindings_snapshot\n   // this->block_->enclosing(), etc.\n   std::vector<size_t> counts_;\n   // The location where this snapshot was taken.\n-  source_location location_;\n+  Location location_;\n };\n \n // A function declaration.\n \n class Function_declaration\n {\n  public:\n-  Function_declaration(Function_type* fntype, source_location location)\n+  Function_declaration(Function_type* fntype, Location location)\n     : fntype_(fntype), location_(location), asm_name_(), fndecl_(NULL)\n   { }\n \n   Function_type*\n   type() const\n   { return this->fntype_; }\n \n-  source_location\n+  Location\n   location() const\n   { return this->location_; }\n \n@@ -1064,7 +1073,7 @@ class Function_declaration\n   // The type of the function.\n   Function_type* fntype_;\n   // The location of the declaration.\n-  source_location location_;\n+  Location location_;\n   // The assembler name: this is the name to use in references to the\n   // function.  This is normally empty.\n   std::string asm_name_;\n@@ -1078,7 +1087,7 @@ class Variable\n {\n  public:\n   Variable(Type*, Expression*, bool is_global, bool is_parameter,\n-\t   bool is_receiver, source_location);\n+\t   bool is_receiver, Location);\n \n   // Get the type of the variable.\n   Type*\n@@ -1172,7 +1181,7 @@ class Variable\n   { this->is_non_escaping_address_taken_ = true; }\n \n   // Get the source location of the variable's declaration.\n-  source_location\n+  Location\n   location() const\n   { return this->location_; }\n \n@@ -1309,7 +1318,7 @@ class Variable\n   // Statements to run before the init statement.\n   Block* preinit_;\n   // Location of variable definition.\n-  source_location location_;\n+  Location location_;\n   // Backend representation.\n   Bvariable* backend_;\n   // Whether this is a global variable.\n@@ -1352,7 +1361,7 @@ class Result_variable\n {\n  public:\n   Result_variable(Type* type, Function* function, int index,\n-\t\t  source_location location)\n+\t\t  Location location)\n     : type_(type), function_(function), index_(index), location_(location),\n       backend_(NULL), is_address_taken_(false),\n       is_non_escaping_address_taken_(false)\n@@ -1374,7 +1383,7 @@ class Result_variable\n   { return this->index_; }\n \n   // The location of the variable definition.\n-  source_location\n+  Location\n   location() const\n   { return this->location_; }\n \n@@ -1422,7 +1431,7 @@ class Result_variable\n   // Index in list of results.\n   int index_;\n   // Where the result variable is defined.\n-  source_location location_;\n+  Location location_;\n   // Backend representation.\n   Bvariable* backend_;\n   // Whether something takes the address of this variable.\n@@ -1439,7 +1448,7 @@ class Named_constant\n {\n  public:\n   Named_constant(Type* type, Expression* expr, int iota_value,\n-\t\t source_location location)\n+\t\t Location location)\n     : type_(type), expr_(expr), iota_value_(iota_value), location_(location),\n       lowering_(false)\n   { }\n@@ -1456,7 +1465,7 @@ class Named_constant\n   iota_value() const\n   { return this->iota_value_; }\n \n-  source_location\n+  Location\n   location() const\n   { return this->location_; }\n \n@@ -1507,7 +1516,7 @@ class Named_constant\n   // we lower.\n   int iota_value_;\n   // The location of the definition.\n-  source_location location_;\n+  Location location_;\n   // Whether we are currently lowering this constant.\n   bool lowering_;\n };\n@@ -1517,13 +1526,13 @@ class Named_constant\n class Type_declaration\n {\n  public:\n-  Type_declaration(source_location location)\n+  Type_declaration(Location location)\n     : location_(location), in_function_(NULL), methods_(),\n       issued_warning_(false)\n   { }\n \n   // Return the location.\n-  source_location\n+  Location\n   location() const\n   { return this->location_; }\n \n@@ -1546,7 +1555,7 @@ class Type_declaration\n   // Add a method declaration to this type.\n   Named_object*\n   add_method_declaration(const std::string& name, Function_type* type,\n-\t\t\t source_location location);\n+\t\t\t Location location);\n \n   // Return whether any methods were defined.\n   bool\n@@ -1565,7 +1574,7 @@ class Type_declaration\n   typedef std::vector<Named_object*> Methods;\n \n   // The location of the type declaration.\n-  source_location location_;\n+  Location location_;\n   // If this type is declared in a function, a pointer back to the\n   // function in which it is defined.\n   Named_object* in_function_;\n@@ -1585,12 +1594,12 @@ class Type_declaration\n class Unknown_name\n {\n  public:\n-  Unknown_name(source_location location)\n+  Unknown_name(Location location)\n     : location_(location), real_named_object_(NULL)\n   { }\n \n   // Return the location where this name was first seen.\n-  source_location\n+  Location\n   location() const\n   { return this->location_; }\n \n@@ -1606,7 +1615,7 @@ class Unknown_name\n \n  private:\n   // The location where this name was first seen.\n-  source_location location_;\n+  Location location_;\n   // The real named object when it is known.\n   Named_object*\n   real_named_object_;\n@@ -1697,17 +1706,17 @@ class Named_object\n   // Creators.\n \n   static Named_object*\n-  make_unknown_name(const std::string& name, source_location);\n+  make_unknown_name(const std::string& name, Location);\n \n   static Named_object*\n   make_constant(const Typed_identifier&, const Package*, Expression*,\n \t\tint iota_value);\n \n   static Named_object*\n-  make_type(const std::string&, const Package*, Type*, source_location);\n+  make_type(const std::string&, const Package*, Type*, Location);\n \n   static Named_object*\n-  make_type_declaration(const std::string&, const Package*, source_location);\n+  make_type_declaration(const std::string&, const Package*, Location);\n \n   static Named_object*\n   make_variable(const std::string&, const Package*, Variable*);\n@@ -1723,7 +1732,7 @@ class Named_object\n \n   static Named_object*\n   make_function_declaration(const std::string&, const Package*, Function_type*,\n-\t\t\t    source_location);\n+\t\t\t    Location);\n \n   static Named_object*\n   make_package(const std::string& alias, Package* package);\n@@ -1899,7 +1908,7 @@ class Named_object\n   }\n \n   // The location where this object was defined or referenced.\n-  source_location\n+  Location\n   location() const;\n \n   // Convert a variable to the backend representation.\n@@ -1969,7 +1978,7 @@ class Bindings\n \n   // Add an unknown name.\n   Named_object*\n-  add_unknown_name(const std::string& name, source_location location)\n+  add_unknown_name(const std::string& name, Location location)\n   {\n     return this->add_named_object(Named_object::make_unknown_name(name,\n \t\t\t\t\t\t\t\t  location));\n@@ -1988,7 +1997,7 @@ class Bindings\n   // Add a type.\n   Named_object*\n   add_type(const std::string& name, const Package* package, Type* type,\n-\t   source_location location)\n+\t   Location location)\n   {\n     return this->add_named_object(Named_object::make_type(name, package, type,\n \t\t\t\t\t\t\t  location));\n@@ -2002,7 +2011,7 @@ class Bindings\n   // Add a type declaration.\n   Named_object*\n   add_type_declaration(const std::string& name, const Package* package,\n-\t\t       source_location location)\n+\t\t       Location location)\n   {\n     Named_object* no = Named_object::make_type_declaration(name, package,\n \t\t\t\t\t\t\t   location);\n@@ -2033,7 +2042,7 @@ class Bindings\n   // Add a function declaration.\n   Named_object*\n   add_function_declaration(const std::string& name, const Package* package,\n-\t\t\t   Function_type* type, source_location location);\n+\t\t\t   Function_type* type, Location location);\n \n   // Add a package.  The location is the location of the import\n   // statement.\n@@ -2153,8 +2162,8 @@ class Label\n {\n  public:\n   Label(const std::string& name)\n-    : name_(name), location_(0), snapshot_(NULL), refs_(), is_used_(false),\n-      blabel_(NULL)\n+    : name_(name), location_(Linemap::unknown_location()), snapshot_(NULL),\n+      refs_(), is_used_(false), blabel_(NULL)\n   { }\n \n   // Return the label's name.\n@@ -2165,7 +2174,7 @@ class Label\n   // Return whether the label has been defined.\n   bool\n   is_defined() const\n-  { return this->location_ != 0; }\n+  { return !Linemap::is_unknown_location(this->location_); }\n \n   // Return whether the label has been used.\n   bool\n@@ -2178,7 +2187,7 @@ class Label\n   { this->is_used_ = true; }\n \n   // Return the location of the definition.\n-  source_location\n+  Location\n   location() const\n   { return this->location_; }\n \n@@ -2191,7 +2200,7 @@ class Label\n   void\n   add_snapshot_ref(Bindings_snapshot* snapshot)\n   {\n-    go_assert(this->location_ == 0);\n+    go_assert(Linemap::is_unknown_location(this->location_));\n     this->refs_.push_back(snapshot);\n   }\n \n@@ -2207,9 +2216,10 @@ class Label\n \n   // Define the label at LOCATION with the given bindings snapshot.\n   void\n-  define(source_location location, Bindings_snapshot* snapshot)\n+  define(Location location, Bindings_snapshot* snapshot)\n   {\n-    go_assert(this->location_ == 0 && this->snapshot_ == NULL);\n+    go_assert(Linemap::is_unknown_location(this->location_)\n+              && this->snapshot_ == NULL);\n     this->location_ = location;\n     this->snapshot_ = snapshot;\n   }\n@@ -2222,14 +2232,14 @@ class Label\n   // to get the return address of a deferred function to see whether\n   // the function may call recover.\n   Bexpression*\n-  get_addr(Translate_context*, source_location location);\n+  get_addr(Translate_context*, Location location);\n \n  private:\n   // The name of the label.\n   std::string name_;\n   // The location of the definition.  This is 0 if the label has not\n   // yet been defined.\n-  source_location location_;\n+  Location location_;\n   // A snapshot of the set of bindings defined at this label, used to\n   // issue errors about invalid goto statements.\n   Bindings_snapshot* snapshot_;\n@@ -2246,18 +2256,18 @@ class Label\n class Unnamed_label\n {\n  public:\n-  Unnamed_label(source_location location)\n+  Unnamed_label(Location location)\n     : location_(location), blabel_(NULL)\n   { }\n \n   // Get the location where the label is defined.\n-  source_location\n+  Location\n   location() const\n   { return this->location_; }\n \n   // Set the location where the label is defined.\n   void\n-  set_location(source_location location)\n+  set_location(Location location)\n   { this->location_ = location; }\n \n   // Return a statement which defines this label.\n@@ -2266,15 +2276,15 @@ class Unnamed_label\n \n   // Return a goto to this label from LOCATION.\n   Bstatement*\n-  get_goto(Translate_context*, source_location location);\n+  get_goto(Translate_context*, Location location);\n \n  private:\n   // Return the backend representation.\n   Blabel*\n   get_blabel(Translate_context*);\n \n   // The location where the label is defined.\n-  source_location location_;\n+  Location location_;\n   // The backend representation of this label.\n   Blabel* blabel_;\n };\n@@ -2285,7 +2295,7 @@ class Package\n {\n  public:\n   Package(const std::string& name, const std::string& unique_prefix,\n-\t  source_location location);\n+\t  Location location);\n \n   // The real name of this package.  This may be different from the\n   // name in the associated Named_object if the import statement used\n@@ -2295,7 +2305,7 @@ class Package\n   { return this->name_; }\n \n   // Return the location of the import statement.\n-  source_location\n+  Location\n   location() const\n   { return this->location_; }\n \n@@ -2378,7 +2388,7 @@ class Package\n   // Set the location of the package.  This is used if it is seen in a\n   // different import before it is really imported.\n   void\n-  set_location(source_location location)\n+  set_location(Location location)\n   { this->location_ = location; }\n \n   // Add a constant to the package.\n@@ -2388,12 +2398,12 @@ class Package\n \n   // Add a type to the package.\n   Named_object*\n-  add_type(const std::string& name, Type* type, source_location location)\n+  add_type(const std::string& name, Type* type, Location location)\n   { return this->bindings_->add_type(name, this, type, location); }\n \n   // Add a type declaration to the package.\n   Named_object*\n-  add_type_declaration(const std::string& name, source_location location)\n+  add_type_declaration(const std::string& name, Location location)\n   { return this->bindings_->add_type_declaration(name, this, location); }\n \n   // Add a variable to the package.\n@@ -2404,7 +2414,7 @@ class Package\n   // Add a function declaration to the package.\n   Named_object*\n   add_function_declaration(const std::string& name, Function_type* type,\n-\t\t\t   source_location loc)\n+\t\t\t   Location loc)\n   { return this->bindings_->add_function_declaration(name, this, type, loc); }\n \n   // Determine types of constants.\n@@ -2423,7 +2433,7 @@ class Package\n   // is used to run init functions in the right order.\n   int priority_;\n   // The location of the import statement.\n-  source_location location_;\n+  Location location_;\n   // True if some name from this package was used.  This is mutable\n   // because we can use a package even if we have a const pointer to\n   // it."}, {"sha": "032c6a0c1b5bc960d99b521918e1866b7389d685", "filename": "gcc/go/gofrontend/import-archive.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Fimport-archive.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Fimport-archive.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fimport-archive.cc?ref=8afa2bfbdc60088acd7f199245244890a6e7773e", "patch": "@@ -66,7 +66,7 @@ Import::is_archive_magic(const char* bytes)\n class Archive_file\n {\n  public:\n-  Archive_file(const std::string& filename, int fd, source_location location)\n+  Archive_file(const std::string& filename, int fd, Location location)\n     : filename_(filename), fd_(fd), filesize_(-1), extended_names_(),\n       is_thin_archive_(false), location_(location), nested_archives_()\n   { }\n@@ -91,7 +91,7 @@ class Archive_file\n   { return this->is_thin_archive_; }\n \n   // Return the location of the import statement.\n-  source_location\n+  Location\n   location() const\n   { return this->location_; }\n \n@@ -133,7 +133,7 @@ class Archive_file\n   // Whether this is a thin archive.\n   bool is_thin_archive_;\n   // The location of the import statements.\n-  source_location location_;\n+  Location location_;\n   // Table of nested archives.\n   Nested_archive_table nested_archives_;\n };\n@@ -613,7 +613,7 @@ Stream_concatenate::do_advance(size_t skip)\n \n Import::Stream*\n Import::find_archive_export_data(const std::string& filename, int fd,\n-\t\t\t\t source_location location)\n+\t\t\t\t Location location)\n {\n   Archive_file afile(filename, fd, location);\n   if (!afile.initialize())"}, {"sha": "d3405c191c9c3c16ad792e49e9a75ac2457f260c", "filename": "gcc/go/gofrontend/import.cc", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Fimport.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Fimport.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fimport.cc?ref=8afa2bfbdc60088acd7f199245244890a6e7773e", "patch": "@@ -59,7 +59,7 @@ const char* const Import::import_marker = \"*imported*\";\n // later in the search path.\n \n Import::Stream*\n-Import::open_package(const std::string& filename, source_location location)\n+Import::open_package(const std::string& filename, Location location)\n {\n   if (!IS_ABSOLUTE_PATH(filename))\n     {\n@@ -88,7 +88,7 @@ Import::open_package(const std::string& filename, source_location location)\n \n Import::Stream*\n Import::try_package_in_directory(const std::string& filename,\n-\t\t\t\t source_location location)\n+\t\t\t\t Location location)\n {\n   std::string found_filename = filename;\n   int fd = open(found_filename.c_str(), O_RDONLY | O_BINARY);\n@@ -175,7 +175,7 @@ Import::try_suffixes(std::string* pfilename)\n \n Import::Stream*\n Import::find_export_data(const std::string& filename, int fd,\n-\t\t\t source_location location)\n+\t\t\t Location location)\n {\n   // See if we can read this as an object file.\n   Import::Stream* stream = Import::find_object_export_data(filename, fd, 0,\n@@ -213,7 +213,7 @@ Import::Stream*\n Import::find_object_export_data(const std::string& filename,\n \t\t\t\tint fd,\n \t\t\t\toff_t offset,\n-\t\t\t\tsource_location location)\n+\t\t\t\tLocation location)\n {\n   const char* errmsg;\n   int err;\n@@ -262,7 +262,7 @@ Import::find_object_export_data(const std::string& filename,\n // Construct an Import object.  We make the builtin_types_ vector\n // large enough to hold all the builtin types.\n \n-Import::Import(Stream* stream, source_location location)\n+Import::Import(Stream* stream, Location location)\n   : gogo_(NULL), stream_(stream), location_(location), package_(NULL),\n     add_to_globals_(false),\n     builtin_types_((- SMALLEST_BUILTIN_CODE) + 1),\n@@ -448,7 +448,7 @@ Import::import_func(Package* package)\n   if (is_varargs)\n     fntype->set_is_varargs();\n \n-  source_location loc = this->location_;\n+  Location loc = this->location_;\n   Named_object* no;\n   if (fntype->is_method())\n     {\n@@ -603,7 +603,7 @@ Import::read_type()\n     package = this->package_;\n   else\n     package = this->gogo_->register_package(package_name, unique_prefix,\n-\t\t\t\t\t    UNKNOWN_LOCATION);\n+\t\t\t\t\t    Linemap::unknown_location());\n \n   Named_object* no = package->bindings()->lookup(type_name);\n   if (no == NULL)\n@@ -798,7 +798,7 @@ Import::Stream::match_bytes(const char* bytes, size_t length)\n // Require that the next LENGTH bytes from the stream match BYTES.\n \n void\n-Import::Stream::require_bytes(source_location location, const char* bytes,\n+Import::Stream::require_bytes(Location location, const char* bytes,\n \t\t\t      size_t length)\n {\n   const char* read;"}, {"sha": "f5b4b3d2be3a689250a2da27d0e42c6b7ad88eea", "filename": "gcc/go/gofrontend/import.h", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Fimport.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Fimport.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fimport.h?ref=8afa2bfbdc60088acd7f199245244890a6e7773e", "patch": "@@ -8,6 +8,7 @@\n #define GO_IMPORT_H\n \n #include \"export.h\"\n+#include \"go-linemap.h\"\n \n class Gogo;\n class Package;\n@@ -78,13 +79,13 @@ class Import\n     // Give an error if the next bytes do not match STR.  Advance the\n     // read position by the length of STR.\n     void\n-    require_c_string(source_location location, const char* str)\n+    require_c_string(Location location, const char* str)\n     { this->require_bytes(location, str, strlen(str)); }\n \n     // Given an error if the next LENGTH bytes do not match BYTES.\n     // Advance the read position by LENGTH.\n     void\n-    require_bytes(source_location, const char* bytes, size_t length);\n+    require_bytes(Location, const char* bytes, size_t length);\n \n     // Advance the read position by SKIP bytes.\n     void\n@@ -124,10 +125,10 @@ class Import\n   // returns a pointer to a Stream object to read the data that it\n   // exports.  LOCATION is the location of the import statement.\n   static Stream*\n-  open_package(const std::string& filename, source_location location);\n+  open_package(const std::string& filename, Location location);\n \n   // Constructor.\n-  Import(Stream*, source_location);\n+  Import(Stream*, Location);\n \n   // Register the builtin types.\n   void\n@@ -142,7 +143,7 @@ class Import\n   import(Gogo*, const std::string& local_name, bool is_local_name_exported);\n \n   // The location of the import statement.\n-  source_location\n+  Location\n   location() const\n   { return this->location_; }\n \n@@ -190,17 +191,17 @@ class Import\n \n  private:\n   static Stream*\n-  try_package_in_directory(const std::string&, source_location);\n+  try_package_in_directory(const std::string&, Location);\n \n   static int\n   try_suffixes(std::string*);\n \n   static Stream*\n-  find_export_data(const std::string& filename, int fd, source_location);\n+  find_export_data(const std::string& filename, int fd, Location);\n \n   static Stream*\n   find_object_export_data(const std::string& filename, int fd,\n-\t\t\t  off_t offset, source_location);\n+\t\t\t  off_t offset, Location);\n \n   static const int archive_magic_len = 8;\n \n@@ -209,7 +210,7 @@ class Import\n \n   static Stream*\n   find_archive_export_data(const std::string& filename, int fd,\n-\t\t\t   source_location);\n+\t\t\t   Location);\n \n   // Read the import control functions.\n   void\n@@ -244,7 +245,7 @@ class Import\n   // The stream from which to read import data.\n   Stream* stream_;\n   // The location of the import statement we are processing.\n-  source_location location_;\n+  Location location_;\n   // The package we are importing.\n   Package* package_;\n   // Whether to add new objects to the global scope, rather than to a"}, {"sha": "effa0871699b0bbef690878465dd0754887f26b7", "filename": "gcc/go/gofrontend/lex.cc", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Flex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Flex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Flex.cc?ref=8afa2bfbdc60088acd7f199245244890a6e7773e", "patch": "@@ -146,7 +146,7 @@ static Keywords keywords;\n \n // Make a general token.\n \n-Token::Token(Classification classification, source_location location)\n+Token::Token(Classification classification, Location location)\n   : classification_(classification), location_(location)\n {\n }\n@@ -432,19 +432,18 @@ Token::print(FILE* file) const\n \n // Class Lex.\n \n-Lex::Lex(const char* input_file_name, FILE* input_file)\n+Lex::Lex(const char* input_file_name, FILE* input_file, Linemap* linemap)\n   : input_file_name_(input_file_name), input_file_(input_file),\n-    linebuf_(NULL), linebufsize_(120), linesize_(0), lineoff_(0),\n-    lineno_(0), add_semi_at_eol_(false)\n+    linemap_(linemap), linebuf_(NULL), linebufsize_(120), linesize_(0),\n+    lineoff_(0), lineno_(0), add_semi_at_eol_(false)\n {\n   this->linebuf_ = new char[this->linebufsize_];\n-  linemap_add(line_table, LC_ENTER, 0, input_file_name, 1);\n+  this->linemap_->start_file(input_file_name, 0);\n }\n \n Lex::~Lex()\n {\n   delete[] this->linebuf_;\n-  linemap_add(line_table, LC_LEAVE, 0, NULL, 0);\n }\n \n // Read a new line from the file.\n@@ -508,26 +507,26 @@ Lex::require_line()\n   this->linesize_= got;\n   this->lineoff_ = 0;\n \n-  linemap_line_start(line_table, this->lineno_, this->linesize_);\n+  this->linemap_->start_line(this->lineno_, this->linesize_);\n \n   return true;\n }\n \n // Get the current location.\n \n-source_location\n+Location\n Lex::location() const\n {\n-  return linemap_position_for_column (line_table, this->lineoff_ + 1);\n+  return this->linemap_->get_location(this->lineoff_ + 1);\n }\n \n // Get a location slightly before the current one.  This is used for\n // slightly more efficient handling of operator tokens.\n \n-source_location\n+Location\n Lex::earlier_location(int chars) const\n {\n-  return linemap_position_for_column (line_table, this->lineoff_ + 1 - chars);\n+  return this->linemap_->get_location(this->lineoff_ + 1 - chars);\n }\n \n // Get the next token.\n@@ -586,7 +585,7 @@ Lex::next_token()\n \t      else if (p[1] == '*')\n \t\t{\n \t\t  this->lineoff_ = p - this->linebuf_;\n-\t\t  source_location location = this->location();\n+\t\t  Location location = this->location();\n \t\t  if (!this->skip_c_comment())\n \t\t    return Token::make_invalid_token(location);\n \t\t  p = this->linebuf_ + this->lineoff_;\n@@ -889,7 +888,7 @@ Lex::gather_identifier()\n \t  buf.append(ubuf);\n \t}\n     }\n-  source_location location = this->location();\n+  Location location = this->location();\n   this->add_semi_at_eol_ = true;\n   this->lineoff_ = p - this->linebuf_;\n   if (has_non_ascii_char)\n@@ -956,7 +955,7 @@ Lex::gather_number()\n   const char* p = pstart;\n   const char* pend = this->linebuf_ + this->linesize_;\n \n-  source_location location = this->location();\n+  Location location = this->location();\n \n   bool neg = false;\n   if (*p == '+')\n@@ -1253,7 +1252,7 @@ Lex::advance_one_char(const char* p, bool is_single_quote, unsigned int* value,\n \n void\n Lex::append_char(unsigned int v, bool is_character, std::string* str,\n-\t\t source_location location)\n+\t\t Location location)\n {\n   char buf[4];\n   size_t len;\n@@ -1319,7 +1318,7 @@ Lex::gather_character()\n   mpz_t val;\n   mpz_init_set_ui(val, value);\n \n-  source_location location = this->location();\n+  Location location = this->location();\n   this->lineoff_ = p + 1 - this->linebuf_;\n   Token ret = Token::make_integer_token(val, location);\n   mpz_clear(val);\n@@ -1338,7 +1337,7 @@ Lex::gather_string()\n   std::string value;\n   while (*p != '\"')\n     {\n-      source_location loc = this->location();\n+      Location loc = this->location();\n       unsigned int c;\n       bool is_character;\n       this->lineoff_ = p - this->linebuf_;\n@@ -1352,7 +1351,7 @@ Lex::gather_string()\n       Lex::append_char(c, is_character, &value, loc);\n     }\n \n-  source_location location = this->location();\n+  Location location = this->location();\n   this->lineoff_ = p + 1 - this->linebuf_;\n   return Token::make_string_token(value, location);\n }\n@@ -1364,7 +1363,7 @@ Lex::gather_raw_string()\n {\n   const char* p = this->linebuf_ + this->lineoff_ + 1;\n   const char* pend = this->linebuf_ + this->linesize_;\n-  source_location location = this->location();\n+  Location location = this->location();\n \n   std::string value;\n   while (true)\n@@ -1376,7 +1375,7 @@ Lex::gather_raw_string()\n \t      this->lineoff_ = p + 1 - this->linebuf_;\n \t      return Token::make_string_token(value, location);\n \t    }\n-\t  source_location loc = this->location();\n+\t  Location loc = this->location();\n \t  unsigned int c;\n \t  bool issued_error;\n \t  this->lineoff_ = p - this->linebuf_;\n@@ -1630,8 +1629,7 @@ Lex::skip_cpp_comment()\n \t      memcpy(file, p, filelen);\n \t      file[filelen] = '\\0';\n \n-\t      linemap_add(line_table, LC_LEAVE, 0, NULL, 0);\n-\t      linemap_add(line_table, LC_ENTER, 0, file, lineno);\n+              this->linemap_->start_file(file, lineno);\n \t      this->lineno_ = lineno - 1;\n \n \t      p = plend;"}, {"sha": "6341e1e34e180c5789c4066f74d85beb731f1300", "filename": "gcc/go/gofrontend/lex.h", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Flex.h?ref=8afa2bfbdc60088acd7f199245244890a6e7773e", "patch": "@@ -11,6 +11,7 @@\n #include <mpfr.h>\n \n #include \"operator.h\"\n+#include \"go-linemap.h\"\n \n struct Unicode_range;\n \n@@ -88,17 +89,17 @@ class Token\n \n   // Make a token for an invalid value.\n   static Token\n-  make_invalid_token(source_location location)\n+  make_invalid_token(Location location)\n   { return Token(TOKEN_INVALID, location); }\n \n   // Make a token representing end of file.\n   static Token\n-  make_eof_token(source_location location)\n+  make_eof_token(Location location)\n   { return Token(TOKEN_EOF, location); }\n \n   // Make a keyword token.\n   static Token\n-  make_keyword_token(Keyword keyword, source_location location)\n+  make_keyword_token(Keyword keyword, Location location)\n   {\n     Token tok(TOKEN_KEYWORD, location);\n     tok.u_.keyword = keyword;\n@@ -108,7 +109,7 @@ class Token\n   // Make an identifier token.\n   static Token\n   make_identifier_token(const std::string& value, bool is_exported,\n-\t\t\tsource_location location)\n+\t\t\tLocation location)\n   {\n     Token tok(TOKEN_IDENTIFIER, location);\n     tok.u_.identifier_value.name = new std::string(value);\n@@ -118,7 +119,7 @@ class Token\n \n   // Make a quoted string token.\n   static Token\n-  make_string_token(const std::string& value, source_location location)\n+  make_string_token(const std::string& value, Location location)\n   {\n     Token tok(TOKEN_STRING, location);\n     tok.u_.string_value = new std::string(value);\n@@ -127,7 +128,7 @@ class Token\n \n   // Make an operator token.\n   static Token\n-  make_operator_token(Operator op, source_location location)\n+  make_operator_token(Operator op, Location location)\n   {\n     Token tok(TOKEN_OPERATOR, location);\n     tok.u_.op = op;\n@@ -136,7 +137,7 @@ class Token\n \n   // Make an integer token.\n   static Token\n-  make_integer_token(mpz_t val, source_location location)\n+  make_integer_token(mpz_t val, Location location)\n   {\n     Token tok(TOKEN_INTEGER, location);\n     mpz_init(tok.u_.integer_value);\n@@ -146,7 +147,7 @@ class Token\n \n   // Make a float token.\n   static Token\n-  make_float_token(mpfr_t val, source_location location)\n+  make_float_token(mpfr_t val, Location location)\n   {\n     Token tok(TOKEN_FLOAT, location);\n     mpfr_init(tok.u_.float_value);\n@@ -156,7 +157,7 @@ class Token\n \n   // Make a token for an imaginary number.\n   static Token\n-  make_imaginary_token(mpfr_t val, source_location location)\n+  make_imaginary_token(mpfr_t val, Location location)\n   {\n     Token tok(TOKEN_IMAGINARY, location);\n     mpfr_init(tok.u_.float_value);\n@@ -165,7 +166,7 @@ class Token\n   }\n \n   // Get the location of the token.\n-  source_location\n+  Location\n   location() const\n   { return this->location_; }\n \n@@ -275,7 +276,7 @@ class Token\n \n  private:\n   // Private constructor used by make_..._token functions above.\n-  Token(Classification, source_location);\n+  Token(Classification, Location);\n \n   // Clear the token.\n   void\n@@ -307,15 +308,15 @@ class Token\n     Operator op;\n   } u_;\n   // The source location.\n-  source_location location_;\n+  Location location_;\n };\n \n // The lexer itself.\n \n class Lex\n {\n  public:\n-  Lex(const char* input_file_name, FILE* input_file);\n+  Lex(const char* input_file_name, FILE* input_file, Linemap *linemap);\n \n   ~Lex();\n \n@@ -334,7 +335,7 @@ class Lex\n   // location is used to warn about an out of range character.\n   static void\n   append_char(unsigned int v, bool is_charater, std::string* str,\n-\t      source_location);\n+\t      Location);\n \n   // A helper function.  Fetch a UTF-8 character from STR and store it\n   // in *VALUE.  Return the number of bytes read from STR.  Return 0\n@@ -350,11 +351,11 @@ class Lex\n   require_line();\n \n   // The current location.\n-  source_location\n+  Location\n   location() const;\n \n   // A position CHARS column positions before the current location.\n-  source_location\n+  Location\n   earlier_location(int chars) const;\n \n   static bool\n@@ -432,6 +433,8 @@ class Lex\n   const char* input_file_name_;\n   // The input file.\n   FILE* input_file_;\n+  // The object used to keep track of file names and line numbers.\n+  Linemap* linemap_;\n   // The line buffer.  This holds the current line.\n   char* linebuf_;\n   // The size of the line buffer."}, {"sha": "622886876622869220c628a02ad5c51ba3ea47e9", "filename": "gcc/go/gofrontend/parse.cc", "status": "modified", "additions": 92, "deletions": 90, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.cc?ref=8afa2bfbdc60088acd7f199245244890a6e7773e", "patch": "@@ -42,8 +42,8 @@ Parse::Enclosing_var_comparison::operator()(const Enclosing_var& v1,\n \n Parse::Parse(Lex* lex, Gogo* gogo)\n   : lex_(lex),\n-    token_(Token::make_invalid_token(0)),\n-    unget_token_(Token::make_invalid_token(0)),\n+    token_(Token::make_invalid_token(Linemap::unknown_location())),\n+    unget_token_(Token::make_invalid_token(Linemap::unknown_location())),\n     unget_token_valid_(false),\n     gogo_(gogo),\n     break_stack_(NULL),\n@@ -92,7 +92,7 @@ Parse::unget_token(const Token& token)\n \n // The location of the current token.\n \n-source_location\n+Location\n Parse::location()\n {\n   return this->peek_token()->location();\n@@ -142,7 +142,7 @@ Parse::expression_list(Expression* first, bool may_be_sink)\n \treturn ret;\n \n       // Most expression lists permit a trailing comma.\n-      source_location location = token->location();\n+      Location location = token->location();\n       this->advance_token();\n       if (!this->expression_may_start_here())\n \t{\n@@ -242,7 +242,7 @@ Parse::type()\n     return this->interface_type();\n   else if (token->is_keyword(KEYWORD_FUNC))\n     {\n-      source_location location = token->location();\n+      Location location = token->location();\n       this->advance_token();\n       Type* type = this->signature(NULL, location);\n       if (type == NULL)\n@@ -299,7 +299,7 @@ Parse::type_may_start_here()\n Type*\n Parse::type_name(bool issue_error)\n {\n-  source_location location = this->location();\n+  Location location = this->location();\n \n   std::string name;\n   Named_object* package;\n@@ -425,7 +425,7 @@ Parse::array_type(bool may_use_ellipsis)\n Type*\n Parse::map_type()\n {\n-  source_location location = this->location();\n+  Location location = this->location();\n   go_assert(this->peek_token()->is_keyword(KEYWORD_MAP));\n   if (!this->advance_token()->is_op(OPERATOR_LSQUARE))\n     {\n@@ -457,10 +457,10 @@ Type*\n Parse::struct_type()\n {\n   go_assert(this->peek_token()->is_keyword(KEYWORD_STRUCT));\n-  source_location location = this->location();\n+  Location location = this->location();\n   if (!this->advance_token()->is_op(OPERATOR_LCURLY))\n     {\n-      source_location token_loc = this->location();\n+      Location token_loc = this->location();\n       if (this->peek_token()->is_op(OPERATOR_SEMICOLON)\n \t  && this->advance_token()->is_op(OPERATOR_LCURLY))\n \terror_at(token_loc, \"unexpected semicolon or newline before %<{%>\");\n@@ -514,7 +514,7 @@ void\n Parse::field_decl(Struct_field_list* sfl)\n {\n   const Token* token = this->peek_token();\n-  source_location location = token->location();\n+  Location location = token->location();\n   bool is_anonymous;\n   bool is_anonymous_pointer;\n   if (token->is_op(OPERATOR_MULT))\n@@ -526,7 +526,7 @@ Parse::field_decl(Struct_field_list* sfl)\n     {\n       std::string id = token->identifier();\n       bool is_id_exported = token->is_identifier_exported();\n-      source_location id_location = token->location();\n+      Location id_location = token->location();\n       token = this->advance_token();\n       is_anonymous = (token->is_op(OPERATOR_SEMICOLON)\n \t\t      || token->is_op(OPERATOR_RCURLY)\n@@ -718,7 +718,7 @@ Parse::check_signature_names(const Typed_identifier_list* params,\n // This returns NULL on a parse error.\n \n Function_type*\n-Parse::signature(Typed_identifier* receiver, source_location location)\n+Parse::signature(Typed_identifier* receiver, Location location)\n {\n   bool is_varargs = false;\n   Typed_identifier_list* params;\n@@ -801,7 +801,7 @@ Parse::parameters(Typed_identifier_list** pparams, bool* is_varargs)\n Typed_identifier_list*\n Parse::parameter_list(bool* is_varargs)\n {\n-  source_location location = this->location();\n+  Location location = this->location();\n   Typed_identifier_list* ret = new Typed_identifier_list();\n \n   bool saw_error = false;\n@@ -822,7 +822,7 @@ Parse::parameter_list(bool* is_varargs)\n     {\n       std::string name = token->identifier();\n       bool is_exported = token->is_identifier_exported();\n-      source_location location = token->location();\n+      Location location = token->location();\n       token = this->advance_token();\n       if (!token->is_op(OPERATOR_COMMA))\n \t{\n@@ -1000,7 +1000,7 @@ Parse::parameter_decl(bool parameters_have_names,\n   if (!parameters_have_names)\n     {\n       Type* type;\n-      source_location location = this->location();\n+      Location location = this->location();\n       if (!this->peek_token()->is_identifier())\n \t{\n \t  if (!this->peek_token()->is_op(OPERATOR_ELLIPSIS))\n@@ -1078,7 +1078,7 @@ Parse::result(Typed_identifier_list** presults)\n     return this->parameters(presults, NULL);\n   else\n     {\n-      source_location location = this->location();\n+      Location location = this->location();\n       Type* type = this->type();\n       if (type->is_error_type())\n \t{\n@@ -1096,19 +1096,19 @@ Parse::result(Typed_identifier_list** presults)\n \n // Returns the location of the closing brace.\n \n-source_location\n+Location\n Parse::block()\n {\n   if (!this->peek_token()->is_op(OPERATOR_LCURLY))\n     {\n-      source_location loc = this->location();\n+      Location loc = this->location();\n       if (this->peek_token()->is_op(OPERATOR_SEMICOLON)\n \t  && this->advance_token()->is_op(OPERATOR_LCURLY))\n \terror_at(loc, \"unexpected semicolon or newline before %<{%>\");\n       else\n \t{\n \t  error_at(this->location(), \"expected %<{%>\");\n-\t  return UNKNOWN_LOCATION;\n+\t  return Linemap::unknown_location();\n \t}\n     }\n \n@@ -1125,7 +1125,7 @@ Parse::block()\n \n \t  // Skip ahead to the end of the block, in hopes of avoiding\n \t  // lots of meaningless errors.\n-\t  source_location ret = token->location();\n+\t  Location ret = token->location();\n \t  int nest = 0;\n \t  while (!token->is_eof())\n \t    {\n@@ -1147,7 +1147,7 @@ Parse::block()\n \t}\n     }\n \n-  source_location ret = token->location();\n+  Location ret = token->location();\n   this->advance_token();\n   return ret;\n }\n@@ -1159,11 +1159,11 @@ Type*\n Parse::interface_type()\n {\n   go_assert(this->peek_token()->is_keyword(KEYWORD_INTERFACE));\n-  source_location location = this->location();\n+  Location location = this->location();\n \n   if (!this->advance_token()->is_op(OPERATOR_LCURLY))\n     {\n-      source_location token_loc = this->location();\n+      Location token_loc = this->location();\n       if (this->peek_token()->is_op(OPERATOR_SEMICOLON)\n \t  && this->advance_token()->is_op(OPERATOR_LCURLY))\n \terror_at(token_loc, \"unexpected semicolon or newline before %<{%>\");\n@@ -1224,7 +1224,7 @@ Parse::method_spec(Typed_identifier_list* methods)\n \n   std::string name = token->identifier();\n   bool is_exported = token->is_identifier_exported();\n-  source_location location = token->location();\n+  Location location = token->location();\n \n   if (this->advance_token()->is_op(OPERATOR_LPAREN))\n     {\n@@ -1472,7 +1472,7 @@ Parse::type_spec(void*)\n     }\n   std::string name = token->identifier();\n   bool is_exported = token->is_identifier_exported();\n-  source_location location = token->location();\n+  Location location = token->location();\n   token = this->advance_token();\n \n   // The scope of the type name starts at the point where the\n@@ -1549,7 +1549,7 @@ Parse::var_spec(void*)\n   Typed_identifier_list til;\n   this->identifier_list(&til);\n \n-  source_location location = this->location();\n+  Location location = this->location();\n \n   Type* type = NULL;\n   Expression_list* init = NULL;\n@@ -1588,7 +1588,7 @@ Parse::var_spec(void*)\n void\n Parse::init_vars(const Typed_identifier_list* til, Type* type,\n \t\t Expression_list* init, bool is_coloneq,\n-\t\t source_location location)\n+\t\t Location location)\n {\n   // Check for an initialization which can yield multiple values.\n   if (init != NULL && init->size() == 1 && til->size() > 1)\n@@ -1648,7 +1648,7 @@ Parse::init_vars(const Typed_identifier_list* til, Type* type,\n bool\n Parse::init_vars_from_call(const Typed_identifier_list* vars, Type* type,\n \t\t\t   Expression* expr, bool is_coloneq,\n-\t\t\t   source_location location)\n+\t\t\t   Location location)\n {\n   Call_expression* call = expr->call_expression();\n   if (call == NULL)\n@@ -1681,7 +1681,7 @@ Parse::init_vars_from_call(const Typed_identifier_list* vars, Type* type,\n bool\n Parse::init_vars_from_map(const Typed_identifier_list* vars, Type* type,\n \t\t\t  Expression* expr, bool is_coloneq,\n-\t\t\t  source_location location)\n+\t\t\t  Location location)\n {\n   Index_expression* index = expr->index_expression();\n   if (index == NULL)\n@@ -1746,7 +1746,7 @@ Parse::init_vars_from_map(const Typed_identifier_list* vars, Type* type,\n bool\n Parse::init_vars_from_receive(const Typed_identifier_list* vars, Type* type,\n \t\t\t      Expression* expr, bool is_coloneq,\n-\t\t\t      source_location location)\n+\t\t\t      Location location)\n {\n   Receive_expression* receive = expr->receive_expression();\n   if (receive == NULL)\n@@ -1812,7 +1812,7 @@ Parse::init_vars_from_receive(const Typed_identifier_list* vars, Type* type,\n bool\n Parse::init_vars_from_type_guard(const Typed_identifier_list* vars,\n \t\t\t\t Type* type, Expression* expr,\n-\t\t\t\t bool is_coloneq, source_location location)\n+\t\t\t\t bool is_coloneq, Location location)\n {\n   Type_guard_expression* type_guard = expr->type_guard_expression();\n   if (type_guard == NULL)\n@@ -1878,7 +1878,7 @@ Named_object*\n Parse::init_var(const Typed_identifier& tid, Type* type, Expression* init,\n \t\tbool is_coloneq, bool type_from_init, bool* is_new)\n {\n-  source_location location = tid.location();\n+  Location location = tid.location();\n \n   if (Gogo::is_sink_name(tid.name()))\n     {\n@@ -1927,7 +1927,7 @@ Parse::init_var(const Typed_identifier& tid, Type* type, Expression* init,\n \n Named_object*\n Parse::create_dummy_global(Type* type, Expression* init,\n-\t\t\t   source_location location)\n+\t\t\t   Location location)\n {\n   if (type == NULL && init == NULL)\n     type = Type::lookup_bool_type();\n@@ -1956,7 +1956,7 @@ Parse::create_dummy_global(Type* type, Expression* init,\n \n void\n Parse::simple_var_decl_or_assignment(const std::string& name,\n-\t\t\t\t     source_location location,\n+\t\t\t\t     Location location,\n \t\t\t\t     Range_clause* p_range_clause,\n \t\t\t\t     Type_switch* p_type_switch)\n {\n@@ -1976,7 +1976,7 @@ Parse::simple_var_decl_or_assignment(const std::string& name,\n \n \t  std::string id = token->identifier();\n \t  bool is_id_exported = token->is_identifier_exported();\n-\t  source_location id_location = token->location();\n+\t  Location id_location = token->location();\n \n \t  token = this->advance_token();\n \t  if (!token->is_op(OPERATOR_COMMA))\n@@ -2079,7 +2079,7 @@ void\n Parse::function_decl()\n {\n   go_assert(this->peek_token()->is_keyword(KEYWORD_FUNC));\n-  source_location location = this->location();\n+  Location location = this->location();\n   const Token* token = this->advance_token();\n \n   Typed_identifier* rec = NULL;\n@@ -2138,7 +2138,7 @@ Parse::function_decl()\n   // Check for the easy error of a newline before the opening brace.\n   if (this->peek_token()->is_op(OPERATOR_SEMICOLON))\n     {\n-      source_location semi_loc = this->location();\n+      Location semi_loc = this->location();\n       if (this->advance_token()->is_op(OPERATOR_LCURLY))\n \terror_at(this->location(),\n \t\t \"unexpected semicolon or newline before %<{%>\");\n@@ -2155,7 +2155,7 @@ Parse::function_decl()\n   else\n     {\n       this->gogo_->start_function(name, fntype, true, location);\n-      source_location end_loc = this->block();\n+      Location end_loc = this->block();\n       this->gogo_->finish_function(end_loc);\n     }\n }\n@@ -2170,7 +2170,7 @@ Parse::receiver()\n \n   std::string name;\n   const Token* token = this->advance_token();\n-  source_location location = token->location();\n+  Location location = token->location();\n   if (!token->is_op(OPERATOR_MULT))\n     {\n       if (!token->is_identifier())\n@@ -2271,7 +2271,7 @@ Parse::operand(bool may_be_sink)\n     {\n     case Token::TOKEN_IDENTIFIER:\n       {\n-\tsource_location location = token->location();\n+\tLocation location = token->location();\n \tstd::string id = token->identifier();\n \tbool is_exported = token->is_identifier_exported();\n \tstd::string packed = this->gogo_->pack_hidden_name(id, is_exported);\n@@ -2412,7 +2412,7 @@ Parse::operand(bool may_be_sink)\n \tcase KEYWORD_MAP:\n \tcase KEYWORD_STRUCT:\n \t  {\n-\t    source_location location = token->location();\n+\t    Location location = token->location();\n \t    return Expression::make_type(this->type(), location);\n \t  }\n \tdefault:\n@@ -2435,7 +2435,7 @@ Parse::operand(bool may_be_sink)\n \t{\n \t  // Here we call array_type directly, as this is the only\n \t  // case where an ellipsis is permitted for an array type.\n-\t  source_location location = token->location();\n+\t  Location location = token->location();\n \t  return Expression::make_type(this->array_type(true), location);\n \t}\n       break;\n@@ -2455,7 +2455,7 @@ Parse::operand(bool may_be_sink)\n \n Expression*\n Parse::enclosing_var_reference(Named_object* in_function, Named_object* var,\n-\t\t\t       source_location location)\n+\t\t\t       Location location)\n {\n   go_assert(var->is_variable() || var->is_result_variable());\n \n@@ -2505,7 +2505,7 @@ Parse::enclosing_var_reference(Named_object* in_function, Named_object* var,\n // 1.  In [][][]int{{{1}}} it will be 2.\n \n Expression*\n-Parse::composite_lit(Type* type, int depth, source_location location)\n+Parse::composite_lit(Type* type, int depth, Location location)\n {\n   go_assert(this->peek_token()->is_op(OPERATOR_LCURLY));\n   this->advance_token();\n@@ -2530,7 +2530,7 @@ Parse::composite_lit(Type* type, int depth, source_location location)\n \t{\n \t  std::string identifier = token->identifier();\n \t  bool is_exported = token->is_identifier_exported();\n-\t  source_location location = token->location();\n+\t  Location location = token->location();\n \n \t  if (this->advance_token()->is_op(OPERATOR_COLON))\n \t    {\n@@ -2656,7 +2656,7 @@ Parse::composite_lit(Type* type, int depth, source_location location)\n Expression*\n Parse::function_lit()\n {\n-  source_location location = this->location();\n+  Location location = this->location();\n   go_assert(this->peek_token()->is_keyword(KEYWORD_FUNC));\n   this->advance_token();\n \n@@ -2679,7 +2679,7 @@ Parse::function_lit()\n \n   Named_object* no = this->gogo_->start_function(\"\", type, true, location);\n \n-  source_location end_loc = this->block();\n+  Location end_loc = this->block();\n \n   this->gogo_->finish_function(end_loc);\n \n@@ -2706,7 +2706,7 @@ Parse::function_lit()\n \n Expression*\n Parse::create_closure(Named_object* function, Enclosing_vars* enclosing_vars,\n-\t\t      source_location location)\n+\t\t      Location location)\n {\n   if (enclosing_vars->empty())\n     return NULL;\n@@ -2761,7 +2761,7 @@ Expression*\n Parse::primary_expr(bool may_be_sink, bool may_be_composite_lit,\n \t\t    bool* is_type_switch)\n {\n-  source_location start_loc = this->location();\n+  Location start_loc = this->location();\n   bool is_parenthesized = this->peek_token()->is_op(OPERATOR_LPAREN);\n \n   Expression* ret = this->operand(may_be_sink);\n@@ -2792,7 +2792,7 @@ Parse::primary_expr(bool may_be_sink, bool may_be_composite_lit,\n \t}\n       else if (this->peek_token()->is_op(OPERATOR_LPAREN))\n \t{\n-\t  source_location loc = this->location();\n+\t  Location loc = this->location();\n \t  this->advance_token();\n \t  Expression* expr = this->expression(PRECEDENCE_NORMAL, false, true,\n \t\t\t\t\t      NULL);\n@@ -2859,7 +2859,7 @@ Expression*\n Parse::selector(Expression* left, bool* is_type_switch)\n {\n   go_assert(this->peek_token()->is_op(OPERATOR_DOT));\n-  source_location location = this->location();\n+  Location location = this->location();\n \n   const Token* token = this->advance_token();\n   if (token->is_identifier())\n@@ -2917,7 +2917,7 @@ Parse::selector(Expression* left, bool* is_type_switch)\n Expression*\n Parse::index(Expression* expr)\n {\n-  source_location location = this->location();\n+  Location location = this->location();\n   go_assert(this->peek_token()->is_op(OPERATOR_LSQUARE));\n   this->advance_token();\n \n@@ -2982,7 +2982,7 @@ Parse::call(Expression* func)\n // Return an expression for a single unqualified identifier.\n \n Expression*\n-Parse::id_to_expression(const std::string& name, source_location location)\n+Parse::id_to_expression(const std::string& name, Location location)\n {\n   Named_object* in_function;\n   Named_object* named_object = this->gogo_->lookup(name, &in_function);\n@@ -3096,7 +3096,7 @@ Parse::expression(Precedence precedence, bool may_be_sink,\n \t}\n \n       Operator op = token->op();\n-      source_location binop_location = token->location();\n+      Location binop_location = token->location();\n \n       if (precedence >= right_precedence)\n \t{\n@@ -3188,7 +3188,7 @@ Parse::unary_expr(bool may_be_sink, bool may_be_composite_lit,\n       || token->is_op(OPERATOR_MULT)\n       || token->is_op(OPERATOR_AND))\n     {\n-      source_location location = token->location();\n+      Location location = token->location();\n       Operator op = token->op();\n       this->advance_token();\n \n@@ -3288,7 +3288,7 @@ Parse::statement(Label* label)\n       {\n \tstd::string identifier = token->identifier();\n \tbool is_exported = token->is_identifier_exported();\n-\tsource_location location = token->location();\n+\tLocation location = token->location();\n \tif (this->advance_token()->is_op(OPERATOR_COLON))\n \t  {\n \t    this->advance_token();\n@@ -3307,9 +3307,9 @@ Parse::statement(Label* label)\n     case Token::TOKEN_OPERATOR:\n       if (token->is_op(OPERATOR_LCURLY))\n \t{\n-\t  source_location location = token->location();\n+\t  Location location = token->location();\n \t  this->gogo_->start_block(location);\n-\t  source_location end_loc = this->block();\n+\t  Location end_loc = this->block();\n \t  this->gogo_->add_block(this->gogo_->finish_block(end_loc),\n \t\t\t\t location);\n \t}\n@@ -3391,7 +3391,7 @@ Parse::statement_may_start_here()\n // Label       = identifier .\n \n void\n-Parse::labeled_stmt(const std::string& label_name, source_location location)\n+Parse::labeled_stmt(const std::string& label_name, Location location)\n {\n   Label* label = this->gogo_->add_label_definition(label_name, location);\n \n@@ -3447,7 +3447,7 @@ Parse::simple_stat(bool may_be_composite_lit, bool* return_exp,\n     {\n       std::string identifier = token->identifier();\n       bool is_exported = token->is_identifier_exported();\n-      source_location location = token->location();\n+      Location location = token->location();\n \n       token = this->advance_token();\n       if (token->is_op(OPERATOR_COLONEQ)\n@@ -3576,7 +3576,7 @@ void\n Parse::send_stmt(Expression* channel)\n {\n   go_assert(this->peek_token()->is_op(OPERATOR_CHANOP));\n-  source_location loc = this->location();\n+  Location loc = this->location();\n   this->advance_token();\n   Expression* val = this->expression(PRECEDENCE_NORMAL, false, true, NULL);\n   Statement* s = Statement::make_send_statement(channel, val, loc);\n@@ -3655,7 +3655,7 @@ Parse::tuple_assignment(Expression_list* lhs, Range_clause* p_range_clause)\n       return;\n     }\n   Operator op = token->op();\n-  source_location location = token->location();\n+  Location location = token->location();\n \n   token = this->advance_token();\n \n@@ -3803,9 +3803,9 @@ Parse::go_or_defer_stat()\n   go_assert(this->peek_token()->is_keyword(KEYWORD_GO)\n \t     || this->peek_token()->is_keyword(KEYWORD_DEFER));\n   bool is_go = this->peek_token()->is_keyword(KEYWORD_GO);\n-  source_location stat_location = this->location();\n+  Location stat_location = this->location();\n   this->advance_token();\n-  source_location expr_location = this->location();\n+  Location expr_location = this->location();\n   Expression* expr = this->expression(PRECEDENCE_NORMAL, false, true, NULL);\n   Call_expression* call_expr = expr->call_expression();\n   if (call_expr == NULL)\n@@ -3833,7 +3833,7 @@ void\n Parse::return_stat()\n {\n   go_assert(this->peek_token()->is_keyword(KEYWORD_RETURN));\n-  source_location location = this->location();\n+  Location location = this->location();\n   this->advance_token();\n   Expression_list* vals = NULL;\n   if (this->expression_may_start_here())\n@@ -3865,7 +3865,7 @@ void\n Parse::if_stat()\n {\n   go_assert(this->peek_token()->is_keyword(KEYWORD_IF));\n-  source_location location = this->location();\n+  Location location = this->location();\n   this->advance_token();\n \n   this->gogo_->start_block(location);\n@@ -3911,13 +3911,13 @@ Parse::if_stat()\n     }\n \n   this->gogo_->start_block(this->location());\n-  source_location end_loc = this->block();\n+  Location end_loc = this->block();\n   Block* then_block = this->gogo_->finish_block(end_loc);\n \n   // Check for the easy error of a newline before \"else\".\n   if (this->peek_token()->is_op(OPERATOR_SEMICOLON))\n     {\n-      source_location semi_loc = this->location();\n+      Location semi_loc = this->location();\n       if (this->advance_token()->is_keyword(KEYWORD_ELSE))\n \terror_at(this->location(),\n \t\t \"unexpected semicolon or newline before %<else%>\");\n@@ -3962,7 +3962,7 @@ void\n Parse::switch_stat(Label* label)\n {\n   go_assert(this->peek_token()->is_keyword(KEYWORD_SWITCH));\n-  source_location location = this->location();\n+  Location location = this->location();\n   this->advance_token();\n \n   this->gogo_->start_block(location);\n@@ -4004,7 +4004,7 @@ Parse::switch_stat(Label* label)\n \t      const Token* token = this->peek_token();\n \t      std::string identifier = token->identifier();\n \t      bool is_exported = token->is_identifier_exported();\n-\t      source_location id_loc = token->location();\n+\t      Location id_loc = token->location();\n \n \t      token = this->advance_token();\n \t      bool is_coloneq = token->is_op(OPERATOR_COLONEQ);\n@@ -4043,7 +4043,7 @@ Parse::switch_stat(Label* label)\n \n   if (!this->peek_token()->is_op(OPERATOR_LCURLY))\n     {\n-      source_location token_loc = this->location();\n+      Location token_loc = this->location();\n       if (this->peek_token()->is_op(OPERATOR_SEMICOLON)\n \t  && this->advance_token()->is_op(OPERATOR_LCURLY))\n \terror_at(token_loc, \"unexpected semicolon or newline before %<{%>\");\n@@ -4088,7 +4088,7 @@ Parse::switch_stat(Label* label)\n \n Statement*\n Parse::expr_switch_body(Label* label, Expression* switch_val,\n-\t\t\tsource_location location)\n+\t\t\tLocation location)\n {\n   Switch_statement* statement = Statement::make_switch_statement(switch_val,\n \t\t\t\t\t\t\t\t location);\n@@ -4122,7 +4122,7 @@ Parse::expr_switch_body(Label* label, Expression* switch_val,\n void\n Parse::expr_case_clause(Case_clauses* clauses, bool* saw_default)\n {\n-  source_location location = this->location();\n+  Location location = this->location();\n \n   bool is_default = false;\n   Expression_list* vals = this->expr_switch_case(&is_default);\n@@ -4198,7 +4198,7 @@ Parse::expr_switch_case(bool* is_default)\n \n Statement*\n Parse::type_switch_body(Label* label, const Type_switch& type_switch,\n-\t\t\tsource_location location)\n+\t\t\tLocation location)\n {\n   Named_object* switch_no = NULL;\n   if (!type_switch.name.empty())\n@@ -4243,7 +4243,7 @@ void\n Parse::type_case_clause(Named_object* switch_no, Type_case_clauses* clauses,\n \t\t\tbool* saw_default)\n {\n-  source_location location = this->location();\n+  Location location = this->location();\n \n   std::vector<Type*> types;\n   bool is_default = false;\n@@ -4355,12 +4355,12 @@ void\n Parse::select_stat(Label* label)\n {\n   go_assert(this->peek_token()->is_keyword(KEYWORD_SELECT));\n-  source_location location = this->location();\n+  Location location = this->location();\n   const Token* token = this->advance_token();\n \n   if (!token->is_op(OPERATOR_LCURLY))\n     {\n-      source_location token_loc = token->location();\n+      Location token_loc = token->location();\n       if (token->is_op(OPERATOR_SEMICOLON)\n \t  && this->advance_token()->is_op(OPERATOR_LCURLY))\n \terror_at(token_loc, \"unexpected semicolon or newline before %<{%>\");\n@@ -4402,7 +4402,7 @@ Parse::select_stat(Label* label)\n void\n Parse::comm_clause(Select_clauses* clauses, bool* saw_default)\n {\n-  source_location location = this->location();\n+  Location location = this->location();\n   bool is_send = false;\n   Expression* channel = NULL;\n   Expression* val = NULL;\n@@ -4518,7 +4518,7 @@ Parse::send_or_recv_stmt(bool* is_send, Expression** channel, Expression** val,\n       Gogo* gogo = this->gogo_;\n       std::string recv_var = token->identifier();\n       bool is_rv_exported = token->is_identifier_exported();\n-      source_location recv_var_loc = token->location();\n+      Location recv_var_loc = token->location();\n       token = this->advance_token();\n       if (token->is_op(OPERATOR_COLONEQ))\n \t{\n@@ -4547,7 +4547,7 @@ Parse::send_or_recv_stmt(bool* is_send, Expression** channel, Expression** val,\n \t    {\n \t      std::string recv_closed = token->identifier();\n \t      bool is_rc_exported = token->is_identifier_exported();\n-\t      source_location recv_closed_loc = token->location();\n+\t      Location recv_closed_loc = token->location();\n \t      closed_is_id = true;\n \n \t      token = this->advance_token();\n@@ -4673,7 +4673,7 @@ void\n Parse::for_stat(Label* label)\n {\n   go_assert(this->peek_token()->is_keyword(KEYWORD_FOR));\n-  source_location location = this->location();\n+  Location location = this->location();\n   const Token* token = this->advance_token();\n \n   // Open a block to hold any variables defined in the init statement\n@@ -4761,7 +4761,7 @@ Parse::for_stat(Label* label)\n   // For_statement.\n \n   this->gogo_->start_block(this->location());\n-  source_location end_loc = this->block();\n+  Location end_loc = this->block();\n   Block* statements = this->gogo_->finish_block(end_loc);\n \n   if (sfor != NULL)\n@@ -4830,7 +4830,7 @@ Parse::range_clause_decl(const Typed_identifier_list* til,\n \t\t\t Range_clause* p_range_clause)\n {\n   go_assert(this->peek_token()->is_keyword(KEYWORD_RANGE));\n-  source_location location = this->location();\n+  Location location = this->location();\n \n   p_range_clause->found = true;\n \n@@ -4956,7 +4956,7 @@ void\n Parse::break_stat()\n {\n   go_assert(this->peek_token()->is_keyword(KEYWORD_BREAK));\n-  source_location location = this->location();\n+  Location location = this->location();\n \n   const Token* token = this->advance_token();\n   Statement* enclosing;\n@@ -4978,7 +4978,8 @@ Parse::break_stat()\n \t{\n \t  // If there is a label with this name, mark it as used to\n \t  // avoid a useless error about an unused label.\n-\t  this->gogo_->add_label_reference(token->identifier(), 0, false);\n+\t  this->gogo_->add_label_reference(token->identifier(),\n+                                           Linemap::unknown_location(), false);\n \n \t  error_at(token->location(), \"invalid break label %qs\",\n \t\t   Gogo::message_name(token->identifier()).c_str());\n@@ -5012,7 +5013,7 @@ void\n Parse::continue_stat()\n {\n   go_assert(this->peek_token()->is_keyword(KEYWORD_CONTINUE));\n-  source_location location = this->location();\n+  Location location = this->location();\n \n   const Token* token = this->advance_token();\n   Statement* enclosing;\n@@ -5033,7 +5034,8 @@ Parse::continue_stat()\n \t{\n \t  // If there is a label with this name, mark it as used to\n \t  // avoid a useless error about an unused label.\n-\t  this->gogo_->add_label_reference(token->identifier(), 0, false);\n+\t  this->gogo_->add_label_reference(token->identifier(),\n+                                           Linemap::unknown_location(), false);\n \n \t  error_at(token->location(), \"invalid continue label %qs\",\n \t\t   Gogo::message_name(token->identifier()).c_str());\n@@ -5061,7 +5063,7 @@ void\n Parse::goto_stat()\n {\n   go_assert(this->peek_token()->is_keyword(KEYWORD_GOTO));\n-  source_location location = this->location();\n+  Location location = this->location();\n   const Token* token = this->advance_token();\n   if (!token->is_identifier())\n     error_at(this->location(), \"expected label for goto\");\n@@ -5081,7 +5083,7 @@ void\n Parse::package_clause()\n {\n   const Token* token = this->peek_token();\n-  source_location location = token->location();\n+  Location location = token->location();\n   std::string name;\n   if (!token->is_keyword(KEYWORD_PACKAGE))\n     {\n@@ -5126,7 +5128,7 @@ void\n Parse::import_spec(void*)\n {\n   const Token* token = this->peek_token();\n-  source_location location = token->location();\n+  Location location = token->location();\n \n   std::string local_name;\n   bool is_local_name_exported = false;"}, {"sha": "0a3fe64cdd6635b434e851861583c638715a05af", "filename": "gcc/go/gofrontend/parse.h", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.h?ref=8afa2bfbdc60088acd7f199245244890a6e7773e", "patch": "@@ -75,7 +75,7 @@ class Parse\n     // The variable name.\n     std::string name;\n     // The location of the variable.\n-    source_location location;\n+    Location location;\n     // The expression.\n     Expression* expr;\n \n@@ -147,7 +147,7 @@ class Parse\n   unget_token(const Token&);\n \n   // The location of the current token.\n-  source_location\n+  Location\n   location();\n \n   // For break and continue we keep a stack of statements with\n@@ -169,12 +169,12 @@ class Parse\n   Type* pointer_type();\n   Type* channel_type();\n   void check_signature_names(const Typed_identifier_list*, Names*);\n-  Function_type* signature(Typed_identifier*, source_location);\n+  Function_type* signature(Typed_identifier*, Location);\n   bool parameters(Typed_identifier_list**, bool* is_varargs);\n   Typed_identifier_list* parameter_list(bool* is_varargs);\n   void parameter_decl(bool, Typed_identifier_list*, bool*, bool*);\n   bool result(Typed_identifier_list**);\n-  source_location block();\n+  Location block();\n   Type* interface_type();\n   void method_spec(Typed_identifier_list*);\n   void declaration();\n@@ -188,30 +188,30 @@ class Parse\n   void var_decl();\n   void var_spec(void*);\n   void init_vars(const Typed_identifier_list*, Type*, Expression_list*,\n-\t\t bool is_coloneq, source_location);\n+\t\t bool is_coloneq, Location);\n   bool init_vars_from_call(const Typed_identifier_list*, Type*, Expression*,\n-\t\t\t   bool is_coloneq, source_location);\n+\t\t\t   bool is_coloneq, Location);\n   bool init_vars_from_map(const Typed_identifier_list*, Type*, Expression*,\n-\t\t\t  bool is_coloneq, source_location);\n+\t\t\t  bool is_coloneq, Location);\n   bool init_vars_from_receive(const Typed_identifier_list*, Type*,\n-\t\t\t      Expression*, bool is_coloneq, source_location);\n+\t\t\t      Expression*, bool is_coloneq, Location);\n   bool init_vars_from_type_guard(const Typed_identifier_list*, Type*,\n \t\t\t\t Expression*, bool is_coloneq,\n-\t\t\t\t source_location);\n+\t\t\t\t Location);\n   Named_object* init_var(const Typed_identifier&, Type*, Expression*,\n \t\t\t bool is_coloneq, bool type_from_init, bool* is_new);\n-  Named_object* create_dummy_global(Type*, Expression*, source_location);\n-  void simple_var_decl_or_assignment(const std::string&, source_location,\n+  Named_object* create_dummy_global(Type*, Expression*, Location);\n+  void simple_var_decl_or_assignment(const std::string&, Location,\n \t\t\t\t     Range_clause*, Type_switch*);\n   void function_decl();\n   Typed_identifier* receiver();\n   Expression* operand(bool may_be_sink);\n   Expression* enclosing_var_reference(Named_object*, Named_object*,\n-\t\t\t\t      source_location);\n-  Expression* composite_lit(Type*, int depth, source_location);\n+\t\t\t\t      Location);\n+  Expression* composite_lit(Type*, int depth, Location);\n   Expression* function_lit();\n   Expression* create_closure(Named_object* function, Enclosing_vars*,\n-\t\t\t     source_location);\n+\t\t\t     Location);\n   Expression* primary_expr(bool may_be_sink, bool may_be_composite_lit,\n \t\t\t   bool* is_type_switch);\n   Expression* selector(Expression*, bool* is_type_switch);\n@@ -222,11 +222,11 @@ class Parse\n   bool expression_may_start_here();\n   Expression* unary_expr(bool may_be_sink, bool may_be_composite_lit,\n \t\t\t bool* is_type_switch);\n-  Expression* qualified_expr(Expression*, source_location);\n-  Expression* id_to_expression(const std::string&, source_location);\n+  Expression* qualified_expr(Expression*, Location);\n+  Expression* id_to_expression(const std::string&, Location);\n   void statement(Label*);\n   bool statement_may_start_here();\n-  void labeled_stmt(const std::string&, source_location);\n+  void labeled_stmt(const std::string&, Location);\n   Expression* simple_stat(bool, bool*, Range_clause*, Type_switch*);\n   bool simple_stat_may_start_here();\n   void statement_list();\n@@ -241,10 +241,10 @@ class Parse\n   void return_stat();\n   void if_stat();\n   void switch_stat(Label*);\n-  Statement* expr_switch_body(Label*, Expression*, source_location);\n+  Statement* expr_switch_body(Label*, Expression*, Location);\n   void expr_case_clause(Case_clauses*, bool* saw_default);\n   Expression_list* expr_switch_case(bool*);\n-  Statement* type_switch_body(Label*, const Type_switch&, source_location);\n+  Statement* type_switch_body(Label*, const Type_switch&, Location);\n   void type_case_clause(Named_object*, Type_case_clauses*, bool* saw_default);\n   void type_switch_case(std::vector<Type*>*, bool*);\n   void select_stat(Label*);"}, {"sha": "42f1e787a8f1752767bf3c81a3aaa69c798986ae", "filename": "gcc/go/gofrontend/runtime.cc", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Fruntime.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Fruntime.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.cc?ref=8afa2bfbdc60088acd7f199245244890a6e7773e", "patch": "@@ -82,7 +82,7 @@ runtime_function_type(Runtime_function_type bft)\n   go_assert(bft < NUMBER_OF_RUNTIME_FUNCTION_TYPES);\n   if (runtime_function_types[bft] == NULL)\n     {\n-      const source_location bloc = BUILTINS_LOCATION;\n+      const Location bloc = Linemap::predeclared_location();\n       Type* t;\n       switch (bft)\n \t{\n@@ -193,7 +193,7 @@ runtime_function_type(Runtime_function_type bft)\n \n static Expression*\n convert_to_runtime_function_type(Runtime_function_type bft, Expression* e,\n-\t\t\t\t source_location loc)\n+\t\t\t\t Location loc)\n {\n   switch (bft)\n     {\n@@ -295,7 +295,7 @@ Runtime::runtime_declaration(Function code)\n     {\n       const Runtime_function* pb = &runtime_functions[code];\n \n-      source_location bloc = BUILTINS_LOCATION;\n+      Location bloc = Linemap::predeclared_location();\n \n       Typed_identifier_list* param_types = NULL;\n       if (pb->parameter_types[0] != RFT_VOID)\n@@ -347,7 +347,7 @@ Runtime::runtime_declaration(Function code)\n // Make a call to a runtime function.\n \n Call_expression*\n-Runtime::make_call(Runtime::Function code, source_location loc,\n+Runtime::make_call(Runtime::Function code, Location loc,\n \t\t   int param_count, ...)\n {\n   go_assert(code < Runtime::NUMBER_OF_FUNCTIONS);\n@@ -387,7 +387,8 @@ Runtime::map_iteration_type()\n \n   mpz_t ival;\n   mpz_init_set_ui(ival, map_iteration_size);\n-  Expression* iexpr = Expression::make_integer(&ival, NULL, BUILTINS_LOCATION);\n+  Expression* iexpr = Expression::make_integer(&ival, NULL,\n+                                               Linemap::predeclared_location());\n   mpz_clear(ival);\n \n   return Type::make_array_type(runtime_function_type(RFT_POINTER), iexpr);"}, {"sha": "3cd40348cbe57ad246125de01c9ffaf6f4e56d5d", "filename": "gcc/go/gofrontend/runtime.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.h?ref=8afa2bfbdc60088acd7f199245244890a6e7773e", "patch": "@@ -32,7 +32,7 @@ class Runtime\n \n   // Make a call to a runtime function.\n   static Call_expression*\n-  make_call(Function, source_location, int, ...);\n+  make_call(Function, Location, int, ...);\n \n   // Convert all the types used by runtime functions to the backend\n   // representation."}, {"sha": "835a0cca239cc92e9e63a98cc53dcc6e33b70714", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=8afa2bfbdc60088acd7f199245244890a6e7773e", "patch": "@@ -20,7 +20,7 @@\n // Class Statement.\n \n Statement::Statement(Statement_classification classification,\n-\t\t     source_location location)\n+\t\t     Location location)\n   : classification_(classification), location_(location)\n {\n }\n@@ -175,7 +175,7 @@ Statement::report_error(const char* msg)\n class Error_statement : public Statement\n {\n  public:\n-  Error_statement(source_location location)\n+  Error_statement(Location location)\n     : Statement(STATEMENT_ERROR, location)\n   { }\n \n@@ -204,7 +204,7 @@ Error_statement::do_dump_statement(Ast_dump_context* ast_dump_context) const\n // Make an error statement.\n \n Statement*\n-Statement::make_error_statement(source_location location)\n+Statement::make_error_statement(Location location)\n {\n   return new Error_statement(location);\n }\n@@ -268,7 +268,7 @@ Variable_declaration_statement::do_get_backend(Translate_context* context)\n   // Something takes the address of this variable, so the value is\n   // stored in the heap.  Initialize it to newly allocated memory\n   // space, and assign the initial value to the new space.\n-  source_location loc = this->location();\n+  Location loc = this->location();\n   Named_object* newfn = context->gogo()->lookup_global(\"new\");\n   go_assert(newfn != NULL && newfn->is_function_declaration());\n   Expression* func = Expression::make_func_reference(newfn, NULL, loc);\n@@ -497,7 +497,7 @@ Temporary_statement::do_dump_statement(Ast_dump_context* ast_dump_context) const\n \n Temporary_statement*\n Statement::make_temporary(Type* type, Expression* init,\n-\t\t\t  source_location location)\n+\t\t\t  Location location)\n {\n   return new Temporary_statement(type, init, location);\n }\n@@ -508,7 +508,7 @@ class Assignment_statement : public Statement\n {\n  public:\n   Assignment_statement(Expression* lhs, Expression* rhs,\n-\t\t       source_location location)\n+\t\t       Location location)\n     : Statement(STATEMENT_ASSIGNMENT, location),\n       lhs_(lhs), rhs_(rhs), are_hidden_fields_ok_(false)\n   { }\n@@ -647,7 +647,7 @@ Assignment_statement::do_dump_statement(Ast_dump_context* ast_dump_context)\n \n Statement*\n Statement::make_assignment(Expression* lhs, Expression* rhs,\n-\t\t\t   source_location location)\n+\t\t\t   Location location)\n {\n   return new Assignment_statement(lhs, rhs, location);\n }\n@@ -684,7 +684,7 @@ Move_subexpressions::expression(Expression** pexpr)\n     --this->skip_;\n   else if ((*pexpr)->temporary_reference_expression() == NULL)\n     {\n-      source_location loc = (*pexpr)->location();\n+      Location loc = (*pexpr)->location();\n       Temporary_statement* temp = Statement::make_temporary(NULL, *pexpr, loc);\n       this->block_->add_statement(temp);\n       *pexpr = Expression::make_temporary_reference(temp, loc);\n@@ -731,7 +731,7 @@ Move_ordered_evals::expression(Expression** pexpr)\n \n   if ((*pexpr)->must_eval_in_order())\n     {\n-      source_location loc = (*pexpr)->location();\n+      Location loc = (*pexpr)->location();\n       Temporary_statement* temp = Statement::make_temporary(NULL, *pexpr, loc);\n       this->block_->add_statement(temp);\n       *pexpr = Expression::make_temporary_reference(temp, loc);\n@@ -745,7 +745,7 @@ class Assignment_operation_statement : public Statement\n {\n  public:\n   Assignment_operation_statement(Operator op, Expression* lhs, Expression* rhs,\n-\t\t\t\t source_location location)\n+\t\t\t\t Location location)\n     : Statement(STATEMENT_ASSIGNMENT_OPERATION, location),\n       op_(op), lhs_(lhs), rhs_(rhs)\n   { }\n@@ -794,7 +794,7 @@ Statement*\n Assignment_operation_statement::do_lower(Gogo*, Named_object*,\n \t\t\t\t\t Block* enclosing, Statement_inserter*)\n {\n-  source_location loc = this->location();\n+  Location loc = this->location();\n \n   // We have to evaluate the left hand side expression only once.  We\n   // do this by moving out any expression with side effects.\n@@ -875,7 +875,7 @@ Assignment_operation_statement::do_dump_statement(\n \n Statement*\n Statement::make_assignment_operation(Operator op, Expression* lhs,\n-\t\t\t\t     Expression* rhs, source_location location)\n+\t\t\t\t     Expression* rhs, Location location)\n {\n   return new Assignment_operation_statement(op, lhs, rhs, location);\n }\n@@ -888,7 +888,7 @@ class Tuple_assignment_statement : public Statement\n {\n  public:\n   Tuple_assignment_statement(Expression_list* lhs, Expression_list* rhs,\n-\t\t\t     source_location location)\n+\t\t\t     Location location)\n     : Statement(STATEMENT_TUPLE_ASSIGNMENT, location),\n       lhs_(lhs), rhs_(rhs), are_hidden_fields_ok_(false)\n   { }\n@@ -944,7 +944,7 @@ Statement*\n Tuple_assignment_statement::do_lower(Gogo*, Named_object*, Block* enclosing,\n \t\t\t\t     Statement_inserter*)\n {\n-  source_location loc = this->location();\n+  Location loc = this->location();\n \n   Block* b = new Block(enclosing, loc);\n \n@@ -1035,7 +1035,7 @@ Tuple_assignment_statement::do_dump_statement(\n \n Statement*\n Statement::make_tuple_assignment(Expression_list* lhs, Expression_list* rhs,\n-\t\t\t\t source_location location)\n+\t\t\t\t Location location)\n {\n   return new Tuple_assignment_statement(lhs, rhs, location);\n }\n@@ -1048,7 +1048,7 @@ class Tuple_map_assignment_statement : public Statement\n public:\n   Tuple_map_assignment_statement(Expression* val, Expression* present,\n \t\t\t\t Expression* map_index,\n-\t\t\t\t source_location location)\n+\t\t\t\t Location location)\n     : Statement(STATEMENT_TUPLE_MAP_ASSIGNMENT, location),\n       val_(val), present_(present), map_index_(map_index)\n   { }\n@@ -1097,7 +1097,7 @@ Statement*\n Tuple_map_assignment_statement::do_lower(Gogo*, Named_object*,\n \t\t\t\t\t Block* enclosing, Statement_inserter*)\n {\n-  source_location loc = this->location();\n+  Location loc = this->location();\n \n   Map_index_expression* map_index = this->map_index_->map_index_expression();\n   if (map_index == NULL)\n@@ -1184,7 +1184,7 @@ Tuple_map_assignment_statement::do_dump_statement(\n Statement*\n Statement::make_tuple_map_assignment(Expression* val, Expression* present,\n \t\t\t\t     Expression* map_index,\n-\t\t\t\t     source_location location)\n+\t\t\t\t     Location location)\n {\n   return new Tuple_map_assignment_statement(val, present, map_index, location);\n }\n@@ -1197,7 +1197,7 @@ class Map_assignment_statement : public Statement\n  public:\n   Map_assignment_statement(Expression* map_index,\n \t\t\t   Expression* val, Expression* should_set,\n-\t\t\t   source_location location)\n+\t\t\t   Location location)\n     : Statement(STATEMENT_MAP_ASSIGNMENT, location),\n       map_index_(map_index), val_(val), should_set_(should_set)\n   { }\n@@ -1246,7 +1246,7 @@ Statement*\n Map_assignment_statement::do_lower(Gogo*, Named_object*, Block* enclosing,\n \t\t\t\t   Statement_inserter*)\n {\n-  source_location loc = this->location();\n+  Location loc = this->location();\n \n   Map_index_expression* map_index = this->map_index_->map_index_expression();\n   if (map_index == NULL)\n@@ -1318,7 +1318,7 @@ Map_assignment_statement::do_dump_statement(\n Statement*\n Statement::make_map_assignment(Expression* map_index,\n \t\t\t       Expression* val, Expression* should_set,\n-\t\t\t       source_location location)\n+\t\t\t       Location location)\n {\n   return new Map_assignment_statement(map_index, val, should_set, location);\n }\n@@ -1330,7 +1330,7 @@ class Tuple_receive_assignment_statement : public Statement\n  public:\n   Tuple_receive_assignment_statement(Expression* val, Expression* closed,\n \t\t\t\t     Expression* channel, bool for_select,\n-\t\t\t\t     source_location location)\n+\t\t\t\t     Location location)\n     : Statement(STATEMENT_TUPLE_RECEIVE_ASSIGNMENT, location),\n       val_(val), closed_(closed), channel_(channel), for_select_(for_select)\n   { }\n@@ -1382,7 +1382,7 @@ Tuple_receive_assignment_statement::do_lower(Gogo*, Named_object*,\n \t\t\t\t\t     Block* enclosing,\n \t\t\t\t\t     Statement_inserter*)\n {\n-  source_location loc = this->location();\n+  Location loc = this->location();\n \n   Channel_type* channel_type = this->channel_->type()->channel_type();\n   if (channel_type == NULL)\n@@ -1461,7 +1461,7 @@ Statement*\n Statement::make_tuple_receive_assignment(Expression* val, Expression* closed,\n \t\t\t\t\t Expression* channel,\n \t\t\t\t\t bool for_select,\n-\t\t\t\t\t source_location location)\n+\t\t\t\t\t Location location)\n {\n   return new Tuple_receive_assignment_statement(val, closed, channel,\n \t\t\t\t\t\tfor_select, location);\n@@ -1475,7 +1475,7 @@ class Tuple_type_guard_assignment_statement : public Statement\n  public:\n   Tuple_type_guard_assignment_statement(Expression* val, Expression* ok,\n \t\t\t\t\tExpression* expr, Type* type,\n-\t\t\t\t\tsource_location location)\n+\t\t\t\t\tLocation location)\n     : Statement(STATEMENT_TUPLE_TYPE_GUARD_ASSIGNMENT, location),\n       val_(val), ok_(ok), expr_(expr), type_(type)\n   { }\n@@ -1534,7 +1534,7 @@ Tuple_type_guard_assignment_statement::do_lower(Gogo*, Named_object*,\n \t\t\t\t\t\tBlock* enclosing,\n \t\t\t\t\t\tStatement_inserter*)\n {\n-  source_location loc = this->location();\n+  Location loc = this->location();\n \n   Type* expr_type = this->expr_->type();\n   if (expr_type->interface_type() == NULL)\n@@ -1599,7 +1599,7 @@ Tuple_type_guard_assignment_statement::do_lower(Gogo*, Named_object*,\n Call_expression*\n Tuple_type_guard_assignment_statement::lower_to_type(Runtime::Function code)\n {\n-  source_location loc = this->location();\n+  Location loc = this->location();\n   return Runtime::make_call(code, loc, 2,\n \t\t\t    Expression::make_type_descriptor(this->type_, loc),\n \t\t\t    this->expr_);\n@@ -1612,7 +1612,7 @@ Tuple_type_guard_assignment_statement::lower_to_object_type(\n     Block* b,\n     Runtime::Function code)\n {\n-  source_location loc = this->location();\n+  Location loc = this->location();\n \n   // var val_temp TYPE\n   Temporary_statement* val_temp = Statement::make_temporary(this->type_,\n@@ -1655,7 +1655,7 @@ Tuple_type_guard_assignment_statement::do_dump_statement(\n Statement*\n Statement::make_tuple_type_guard_assignment(Expression* val, Expression* ok,\n \t\t\t\t\t    Expression* expr, Type* type,\n-\t\t\t\t\t    source_location location)\n+\t\t\t\t\t    Location location)\n {\n   return new Tuple_type_guard_assignment_statement(val, ok, expr, type,\n \t\t\t\t\t\t   location);\n@@ -1778,7 +1778,7 @@ Statement::make_statement(Expression* expr, bool is_ignored)\n class Block_statement : public Statement\n {\n  public:\n-  Block_statement(Block* block, source_location location)\n+  Block_statement(Block* block, Location location)\n     : Statement(STATEMENT_BLOCK, location),\n       block_(block)\n   { }\n@@ -1826,7 +1826,7 @@ Block_statement::do_dump_statement(Ast_dump_context*) const\n // Make a block statement.\n \n Statement*\n-Statement::make_block_statement(Block* block, source_location location)\n+Statement::make_block_statement(Block* block, Location location)\n {\n   return new Block_statement(block, location);\n }\n@@ -1872,7 +1872,7 @@ class Inc_dec_statement : public Statement\n Statement*\n Inc_dec_statement::do_lower(Gogo*, Named_object*, Block*, Statement_inserter*)\n {\n-  source_location loc = this->location();\n+  Location loc = this->location();\n \n   mpz_t oval;\n   mpz_init_set_ui(oval, 1UL);\n@@ -1916,7 +1916,7 @@ Statement::make_dec_statement(Expression* expr)\n \n Thunk_statement::Thunk_statement(Statement_classification classification,\n \t\t\t\t Call_expression* call,\n-\t\t\t\t source_location location)\n+\t\t\t\t Location location)\n     : Statement(classification, location),\n       call_(call), struct_type_(NULL)\n {\n@@ -2145,7 +2145,7 @@ Thunk_statement::simplify_statement(Gogo* gogo, Named_object* function,\n   Interface_field_reference_expression* interface_method =\n     fn->interface_field_reference_expression();\n \n-  source_location location = this->location();\n+  Location location = this->location();\n \n   std::string thunk_name = Gogo::thunk_name();\n \n@@ -2230,7 +2230,7 @@ Thunk_statement::thunk_field_param(int n, char* buf, size_t buflen)\n Struct_type*\n Thunk_statement::build_struct(Function_type* fntype)\n {\n-  source_location location = this->location();\n+  Location location = this->location();\n \n   Struct_field_list* fields = new Struct_field_list();\n \n@@ -2288,7 +2288,7 @@ Thunk_statement::build_struct(Function_type* fntype)\n void\n Thunk_statement::build_thunk(Gogo* gogo, const std::string& thunk_name)\n {\n-  source_location location = this->location();\n+  Location location = this->location();\n \n   Call_expression* ce = this->call_->call_expression();\n \n@@ -2541,7 +2541,7 @@ Go_statement::do_dump_statement(Ast_dump_context* ast_dump_context) const\n // Make a go statement.\n \n Statement*\n-Statement::make_go_statement(Call_expression* call, source_location location)\n+Statement::make_go_statement(Call_expression* call, Location location)\n {\n   return new Go_statement(call, location);\n }\n@@ -2556,7 +2556,7 @@ Defer_statement::do_get_backend(Translate_context* context)\n   if (!this->get_fn_and_arg(&fn, &arg))\n     return context->backend()->error_statement();\n \n-  source_location loc = this->location();\n+  Location loc = this->location();\n   Expression* ds = context->function()->func_value()->defer_stack(loc);\n \n   Expression* call = Runtime::make_call(Runtime::DEFER, loc, 3,\n@@ -2581,7 +2581,7 @@ Defer_statement::do_dump_statement(Ast_dump_context* ast_dump_context) const\n \n Statement*\n Statement::make_defer_statement(Call_expression* call,\n-\t\t\t\tsource_location location)\n+\t\t\t\tLocation location)\n {\n   return new Defer_statement(call, location);\n }\n@@ -2623,7 +2623,7 @@ Return_statement::do_lower(Gogo*, Named_object* function, Block* enclosing,\n   this->vals_ = NULL;\n   this->is_lowered_ = true;\n \n-  source_location loc = this->location();\n+  Location loc = this->location();\n \n   size_t vals_count = vals == NULL ? 0 : vals->size();\n   Function::Results* results = function->func_value()->result_variables();\n@@ -2757,7 +2757,7 @@ Return_statement::do_lower(Gogo*, Named_object* function, Block* enclosing,\n Bstatement*\n Return_statement::do_get_backend(Translate_context* context)\n {\n-  source_location loc = this->location();\n+  Location loc = this->location();\n \n   Function* function = context->function()->func_value();\n   tree fndecl = function->get_decl();\n@@ -2795,7 +2795,7 @@ Return_statement::do_dump_statement(Ast_dump_context* ast_dump_context) const\n \n Return_statement*\n Statement::make_return_statement(Expression_list* vals,\n-\t\t\t\t source_location location)\n+\t\t\t\t Location location)\n {\n   return new Return_statement(vals, location);\n }\n@@ -2805,7 +2805,7 @@ Statement::make_return_statement(Expression_list* vals,\n class Bc_statement : public Statement\n {\n  public:\n-  Bc_statement(bool is_break, Unnamed_label* label, source_location location)\n+  Bc_statement(bool is_break, Unnamed_label* label, Location location)\n     : Statement(STATEMENT_BREAK_OR_CONTINUE, location),\n       label_(label), is_break_(is_break)\n   { }\n@@ -2855,7 +2855,7 @@ Bc_statement::do_dump_statement(Ast_dump_context* ast_dump_context) const\n // Make a break statement.\n \n Statement*\n-Statement::make_break_statement(Unnamed_label* label, source_location location)\n+Statement::make_break_statement(Unnamed_label* label, Location location)\n {\n   return new Bc_statement(true, label, location);\n }\n@@ -2864,7 +2864,7 @@ Statement::make_break_statement(Unnamed_label* label, source_location location)\n \n Statement*\n Statement::make_continue_statement(Unnamed_label* label,\n-\t\t\t\t   source_location location)\n+\t\t\t\t   Location location)\n {\n   return new Bc_statement(false, label, location);\n }\n@@ -2874,7 +2874,7 @@ Statement::make_continue_statement(Unnamed_label* label,\n class Goto_statement : public Statement\n {\n  public:\n-  Goto_statement(Label* label, source_location location)\n+  Goto_statement(Label* label, Location location)\n     : Statement(STATEMENT_GOTO, location),\n       label_(label)\n   { }\n@@ -2936,7 +2936,7 @@ Goto_statement::do_dump_statement(Ast_dump_context* ast_dump_context) const\n // Make a goto statement.\n \n Statement*\n-Statement::make_goto_statement(Label* label, source_location location)\n+Statement::make_goto_statement(Label* label, Location location)\n {\n   return new Goto_statement(label, location);\n }\n@@ -2946,7 +2946,7 @@ Statement::make_goto_statement(Label* label, source_location location)\n class Goto_unnamed_statement : public Statement\n {\n  public:\n-  Goto_unnamed_statement(Unnamed_label* label, source_location location)\n+  Goto_unnamed_statement(Unnamed_label* label, Location location)\n     : Statement(STATEMENT_GOTO_UNNAMED, location),\n       label_(label)\n   { }\n@@ -2987,7 +2987,7 @@ Goto_unnamed_statement::do_dump_statement(\n \n Statement*\n Statement::make_goto_unnamed_statement(Unnamed_label* label,\n-\t\t\t\t       source_location location)\n+\t\t\t\t       Location location)\n {\n   return new Goto_unnamed_statement(label, location);\n }\n@@ -3024,7 +3024,7 @@ Label_statement::do_dump_statement(Ast_dump_context* ast_dump_context) const\n // Make a label statement.\n \n Statement*\n-Statement::make_label_statement(Label* label, source_location location)\n+Statement::make_label_statement(Label* label, Location location)\n {\n   return new Label_statement(label, location);\n }\n@@ -3081,7 +3081,7 @@ class If_statement : public Statement\n {\n  public:\n   If_statement(Expression* cond, Block* then_block, Block* else_block,\n-\t       source_location location)\n+\t       Location location)\n     : Statement(STATEMENT_IF, location),\n       cond_(cond), then_block_(then_block), else_block_(else_block)\n   { }\n@@ -3201,7 +3201,7 @@ If_statement::do_dump_statement(Ast_dump_context* ast_dump_context) const\n \n Statement*\n Statement::make_if_statement(Expression* cond, Block* then_block,\n-\t\t\t     Block* else_block, source_location location)\n+\t\t\t     Block* else_block, Location location)\n {\n   return new If_statement(cond, then_block, else_block, location);\n }\n@@ -3303,7 +3303,7 @@ Case_clauses::Case_clause::lower(Block* b, Temporary_statement* val_temp,\n \t\t\t\t Unnamed_label* start_label,\n \t\t\t\t Unnamed_label* finish_label) const\n {\n-  source_location loc = this->location_;\n+  Location loc = this->location_;\n   Unnamed_label* next_case_label;\n   if (this->cases_ == NULL || this->cases_->empty())\n     {\n@@ -3335,7 +3335,7 @@ Case_clauses::Case_clause::lower(Block* b, Temporary_statement* val_temp,\n \t}\n \n       Block* then_block = new Block(b, loc);\n-      next_case_label = new Unnamed_label(UNKNOWN_LOCATION);\n+      next_case_label = new Unnamed_label(Linemap::unknown_location());\n       Statement* s = Statement::make_goto_unnamed_statement(next_case_label,\n \t\t\t\t\t\t\t    loc);\n       then_block->add_statement(s);\n@@ -3693,7 +3693,7 @@ class Constant_switch_statement : public Statement\n  public:\n   Constant_switch_statement(Expression* val, Case_clauses* clauses,\n \t\t\t    Unnamed_label* break_label,\n-\t\t\t    source_location location)\n+\t\t\t    Location location)\n     : Statement(STATEMENT_CONSTANT_SWITCH, location),\n       val_(val), clauses_(clauses), break_label_(break_label)\n   { }\n@@ -3838,7 +3838,7 @@ Statement*\n Switch_statement::do_lower(Gogo*, Named_object*, Block* enclosing,\n \t\t\t   Statement_inserter*)\n {\n-  source_location loc = this->location();\n+  Location loc = this->location();\n \n   if (this->val_ != NULL\n       && (this->val_->is_error_expression()\n@@ -3915,7 +3915,7 @@ Switch_statement::do_dump_statement(Ast_dump_context* ast_dump_context) const\n // Make a switch statement.\n \n Switch_statement*\n-Statement::make_switch_statement(Expression* val, source_location location)\n+Statement::make_switch_statement(Expression* val, Location location)\n {\n   return new Switch_statement(val, location);\n }\n@@ -3949,7 +3949,7 @@ Type_case_clauses::Type_case_clause::lower(Block* b,\n \t\t\t\t\t   Unnamed_label* break_label,\n \t\t\t\t\t   Unnamed_label** stmts_label) const\n {\n-  source_location loc = this->location_;\n+  Location loc = this->location_;\n \n   Unnamed_label* next_case_label = NULL;\n   if (!this->is_default_)\n@@ -3979,7 +3979,7 @@ Type_case_clauses::Type_case_clause::lower(Block* b,\n       if (!this->is_fallthrough_)\n \t{\n \t  // if !COND { goto NEXT_CASE_LABEL }\n-\t  next_case_label = new Unnamed_label(UNKNOWN_LOCATION);\n+\t  next_case_label = new Unnamed_label(Linemap::unknown_location());\n \t  dest = next_case_label;\n \t  cond = Expression::make_unary(OPERATOR_NOT, cond, loc);\n \t}\n@@ -3988,7 +3988,7 @@ Type_case_clauses::Type_case_clause::lower(Block* b,\n \t  // if COND { goto STMTS_LABEL }\n \t  go_assert(stmts_label != NULL);\n \t  if (*stmts_label == NULL)\n-\t    *stmts_label = new Unnamed_label(UNKNOWN_LOCATION);\n+\t    *stmts_label = new Unnamed_label(Linemap::unknown_location());\n \t  dest = *stmts_label;\n \t}\n       Block* then_block = new Block(b, loc);\n@@ -4022,7 +4022,7 @@ Type_case_clauses::Type_case_clause::lower(Block* b,\n     go_assert(next_case_label == NULL);\n   else\n     {\n-      source_location gloc = (this->statements_ == NULL\n+      Location gloc = (this->statements_ == NULL\n \t\t\t      ? loc\n \t\t\t      : this->statements_->end_location());\n       b->add_statement(Statement::make_goto_unnamed_statement(break_label,\n@@ -4169,7 +4169,7 @@ Statement*\n Type_switch_statement::do_lower(Gogo*, Named_object*, Block* enclosing,\n \t\t\t\tStatement_inserter*)\n {\n-  const source_location loc = this->location();\n+  const Location loc = this->location();\n \n   if (this->clauses_ != NULL)\n     this->clauses_->check_duplicates();\n@@ -4268,7 +4268,7 @@ Type_switch_statement::do_dump_statement(Ast_dump_context* ast_dump_context)\n \n Type_switch_statement*\n Statement::make_type_switch_statement(Named_object* var, Expression* expr,\n-\t\t\t\t      source_location location)\n+\t\t\t\t      Location location)\n {\n   return new Type_switch_statement(var, expr, location);\n }\n@@ -4334,7 +4334,7 @@ Send_statement::do_check_types(Gogo*)\n Bstatement*\n Send_statement::do_get_backend(Translate_context* context)\n {\n-  source_location loc = this->location();\n+  Location loc = this->location();\n \n   Channel_type* channel_type = this->channel_->type()->channel_type();\n   Type* element_type = channel_type->element_type();\n@@ -4450,7 +4450,7 @@ Send_statement::do_dump_statement(Ast_dump_context* ast_dump_context) const\n \n Send_statement*\n Statement::make_send_statement(Expression* channel, Expression* val,\n-\t\t\t       source_location location)\n+\t\t\t       Location location)\n {\n   return new Send_statement(channel, val, location);\n }\n@@ -4505,7 +4505,7 @@ Select_clauses::Select_clause::lower(Gogo* gogo, Named_object* function,\n       return;\n     }\n \n-  source_location loc = this->location_;\n+  Location loc = this->location_;\n \n   // Evaluate the channel before the select statement.\n   Temporary_statement* channel_temp = Statement::make_temporary(NULL,\n@@ -4767,7 +4767,7 @@ Select_clauses::may_fall_through() const\n Bstatement*\n Select_clauses::get_backend(Translate_context* context,\n \t\t\t    Unnamed_label *break_label,\n-\t\t\t    source_location location)\n+\t\t\t    Location location)\n {\n   size_t count = this->clauses_.size();\n \n@@ -4941,7 +4941,7 @@ Select_clauses::get_backend(Translate_context* context,\n void\n Select_clauses::add_clause_backend(\n     Translate_context* context,\n-    source_location location,\n+    Location location,\n     int index,\n     int case_value,\n     Select_clause* clause,\n@@ -4957,7 +4957,7 @@ Select_clauses::add_clause_backend(\n \n   Bstatement* s = clause->get_statements_backend(context);\n \n-  source_location gloc = (clause->statements() == NULL\n+  Location gloc = (clause->statements() == NULL\n \t\t\t  ? clause->location()\n \t\t\t  : clause->statements()->end_location());\n   Bstatement* g = bottom_label->get_goto(context, gloc);\n@@ -5038,7 +5038,7 @@ Select_statement::do_dump_statement(Ast_dump_context* ast_dump_context) const\n // Make a select statement.\n \n Select_statement*\n-Statement::make_select_statement(source_location location)\n+Statement::make_select_statement(Location location)\n {\n   return new Select_statement(location);\n }\n@@ -5076,7 +5076,7 @@ For_statement::do_lower(Gogo*, Named_object*, Block* enclosing,\n \t\t\tStatement_inserter*)\n {\n   Statement* s;\n-  source_location loc = this->location();\n+  Location loc = this->location();\n \n   Block* b = new Block(enclosing, this->location());\n   if (this->init_ != NULL)\n@@ -5100,7 +5100,7 @@ For_statement::do_lower(Gogo*, Named_object*, Block* enclosing,\n \t\t\t\t      this->statements_->start_location());\n   b->add_statement(s);\n \n-  source_location end_loc = this->statements_->end_location();\n+  Location end_loc = this->statements_->end_location();\n \n   Unnamed_label* cont = this->continue_label_;\n   if (cont != NULL)\n@@ -5120,7 +5120,7 @@ For_statement::do_lower(Gogo*, Named_object*, Block* enclosing,\n     {\n       b->add_statement(Statement::make_unnamed_label_statement(entry));\n \n-      source_location cond_loc = this->cond_->location();\n+      Location cond_loc = this->cond_->location();\n       Block* then_block = new Block(b, cond_loc);\n       s = Statement::make_goto_unnamed_statement(top, cond_loc);\n       then_block->add_statement(s);\n@@ -5211,7 +5211,7 @@ For_statement::do_dump_statement(Ast_dump_context* ast_dump_context) const\n \n For_statement*\n Statement::make_for_statement(Block* init, Expression* cond, Block* post,\n-\t\t\t      source_location location)\n+\t\t\t      Location location)\n {\n   return new For_statement(init, cond, post, location);\n }\n@@ -5285,7 +5285,7 @@ For_range_statement::do_lower(Gogo* gogo, Named_object*, Block* enclosing,\n       return Statement::make_error_statement(this->location());\n     }\n \n-  source_location loc = this->location();\n+  Location loc = this->location();\n   Block* temp_block = new Block(enclosing, loc);\n \n   Named_object* range_object = NULL;\n@@ -5388,7 +5388,7 @@ For_range_statement::do_lower(Gogo* gogo, Named_object*, Block* enclosing,\n Expression*\n For_range_statement::make_range_ref(Named_object* range_object,\n \t\t\t\t    Temporary_statement* range_temp,\n-\t\t\t\t    source_location loc)\n+\t\t\t\t    Location loc)\n {\n   if (range_object != NULL)\n     return Expression::make_var_reference(range_object, loc);\n@@ -5402,7 +5402,7 @@ For_range_statement::make_range_ref(Named_object* range_object,\n Expression*\n For_range_statement::call_builtin(Gogo* gogo, const char* funcname,\n \t\t\t\t  Expression* arg,\n-\t\t\t\t  source_location loc)\n+\t\t\t\t  Location loc)\n {\n   Named_object* no = gogo->lookup_global(funcname);\n   go_assert(no != NULL && no->is_function_declaration());\n@@ -5427,7 +5427,7 @@ For_range_statement::lower_range_array(Gogo* gogo,\n \t\t\t\t       Block** piter_init,\n \t\t\t\t       Block** ppost)\n {\n-  source_location loc = this->location();\n+  Location loc = this->location();\n \n   // The loop we generate:\n   //   len_temp := len(range)\n@@ -5519,7 +5519,7 @@ For_range_statement::lower_range_string(Gogo*,\n \t\t\t\t\tBlock** piter_init,\n \t\t\t\t\tBlock** ppost)\n {\n-  source_location loc = this->location();\n+  Location loc = this->location();\n \n   // The loop we generate:\n   //   var next_index_temp int\n@@ -5647,7 +5647,7 @@ For_range_statement::lower_range_map(Gogo*,\n \t\t\t\t     Block** piter_init,\n \t\t\t\t     Block** ppost)\n {\n-  source_location loc = this->location();\n+  Location loc = this->location();\n \n   // The runtime uses a struct to handle ranges over a map.  The\n   // struct is four pointers long.  The first pointer is NULL when we\n@@ -5752,7 +5752,7 @@ For_range_statement::lower_range_channel(Gogo*,\n {\n   go_assert(value_temp == NULL);\n \n-  source_location loc = this->location();\n+  Location loc = this->location();\n \n   // The loop we generate:\n   //   for {\n@@ -5863,7 +5863,7 @@ For_range_statement*\n Statement::make_for_range_statement(Expression* index_var,\n \t\t\t\t    Expression* value_var,\n \t\t\t\t    Expression* range,\n-\t\t\t\t    source_location location)\n+\t\t\t\t    Location location)\n {\n   return new For_range_statement(index_var, value_var, range, location);\n }"}, {"sha": "16914f16c37f01a7bfc58a259f1cefc8b443e8d1", "filename": "gcc/go/gofrontend/statements.h", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.h?ref=8afa2bfbdc60088acd7f199245244890a6e7773e", "patch": "@@ -123,7 +123,7 @@ class Statement\n     STATEMENT_TYPE_SWITCH\n   };\n \n-  Statement(Statement_classification, source_location);\n+  Statement(Statement_classification, Location);\n \n   virtual ~Statement();\n \n@@ -139,44 +139,44 @@ class Statement\n   // Either the type or the initialization expression may be NULL, but\n   // not both.\n   static Temporary_statement*\n-  make_temporary(Type*, Expression*, source_location);\n+  make_temporary(Type*, Expression*, Location);\n \n   // Make an assignment statement.\n   static Statement*\n-  make_assignment(Expression*, Expression*, source_location);\n+  make_assignment(Expression*, Expression*, Location);\n \n   // Make an assignment operation (+=, etc.).\n   static Statement*\n   make_assignment_operation(Operator, Expression*, Expression*,\n-\t\t\t    source_location);\n+\t\t\t    Location);\n \n   // Make a tuple assignment statement.\n   static Statement*\n-  make_tuple_assignment(Expression_list*, Expression_list*, source_location);\n+  make_tuple_assignment(Expression_list*, Expression_list*, Location);\n \n   // Make an assignment from a map index to a pair of variables.\n   static Statement*\n   make_tuple_map_assignment(Expression* val, Expression* present,\n-\t\t\t    Expression*, source_location);\n+\t\t\t    Expression*, Location);\n \n   // Make a statement which assigns a pair of values to a map.\n   static Statement*\n   make_map_assignment(Expression*, Expression* val,\n-\t\t      Expression* should_set, source_location);\n+\t\t      Expression* should_set, Location);\n \n   // Make an assignment from a nonblocking receive to a pair of\n   // variables.  FOR_SELECT is true is this is being created for a\n   // case x, ok := <-c in a select statement.\n   static Statement*\n   make_tuple_receive_assignment(Expression* val, Expression* closed,\n \t\t\t\tExpression* channel, bool for_select,\n-\t\t\t\tsource_location);\n+\t\t\t\tLocation);\n \n   // Make an assignment from a type guard to a pair of variables.\n   static Statement*\n   make_tuple_type_guard_assignment(Expression* val, Expression* ok,\n \t\t\t\t   Expression* expr, Type* type,\n-\t\t\t\t   source_location);\n+\t\t\t\t   Location);\n \n   // Make an expression statement from an Expression.  IS_IGNORED is\n   // true if the value is being explicitly ignored, as in an\n@@ -187,7 +187,7 @@ class Statement\n   // Make a block statement from a Block.  This is an embedded list of\n   // statements which may also include variable definitions.\n   static Statement*\n-  make_block_statement(Block*, source_location);\n+  make_block_statement(Block*, Location);\n \n   // Make an increment statement.\n   static Statement*\n@@ -199,35 +199,35 @@ class Statement\n \n   // Make a go statement.\n   static Statement*\n-  make_go_statement(Call_expression* call, source_location);\n+  make_go_statement(Call_expression* call, Location);\n \n   // Make a defer statement.\n   static Statement*\n-  make_defer_statement(Call_expression* call, source_location);\n+  make_defer_statement(Call_expression* call, Location);\n \n   // Make a return statement.\n   static Return_statement*\n-  make_return_statement(Expression_list*, source_location);\n+  make_return_statement(Expression_list*, Location);\n \n   // Make a break statement.\n   static Statement*\n-  make_break_statement(Unnamed_label* label, source_location);\n+  make_break_statement(Unnamed_label* label, Location);\n \n   // Make a continue statement.\n   static Statement*\n-  make_continue_statement(Unnamed_label* label, source_location);\n+  make_continue_statement(Unnamed_label* label, Location);\n \n   // Make a goto statement.\n   static Statement*\n-  make_goto_statement(Label* label, source_location);\n+  make_goto_statement(Label* label, Location);\n \n   // Make a goto statement to an unnamed label.\n   static Statement*\n-  make_goto_unnamed_statement(Unnamed_label* label, source_location);\n+  make_goto_unnamed_statement(Unnamed_label* label, Location);\n \n   // Make a label statement--where the label is defined.\n   static Statement*\n-  make_label_statement(Label* label, source_location);\n+  make_label_statement(Label* label, Location);\n \n   // Make an unnamed label statement--where the label is defined.\n   static Statement*\n@@ -236,41 +236,41 @@ class Statement\n   // Make an if statement.\n   static Statement*\n   make_if_statement(Expression* cond, Block* then_block, Block* else_block,\n-\t\t    source_location);\n+\t\t    Location);\n \n   // Make a switch statement.\n   static Switch_statement*\n-  make_switch_statement(Expression* switch_val, source_location);\n+  make_switch_statement(Expression* switch_val, Location);\n \n   // Make a type switch statement.\n   static Type_switch_statement*\n-  make_type_switch_statement(Named_object* var, Expression*, source_location);\n+  make_type_switch_statement(Named_object* var, Expression*, Location);\n \n   // Make a send statement.\n   static Send_statement*\n-  make_send_statement(Expression* channel, Expression* val, source_location);\n+  make_send_statement(Expression* channel, Expression* val, Location);\n \n   // Make a select statement.\n   static Select_statement*\n-  make_select_statement(source_location);\n+  make_select_statement(Location);\n \n   // Make a for statement.\n   static For_statement*\n   make_for_statement(Block* init, Expression* cond, Block* post,\n-\t\t     source_location location);\n+\t\t     Location location);\n \n   // Make a for statement with a range clause.\n   static For_range_statement*\n   make_for_range_statement(Expression* index_var, Expression* value_var,\n-\t\t\t   Expression* range, source_location);\n+\t\t\t   Expression* range, Location);\n \n   // Return the statement classification.\n   Statement_classification\n   classification() const\n   { return this->classification_; }\n \n   // Get the statement location.\n-  source_location\n+  Location\n   location() const\n   { return this->location_; }\n \n@@ -448,7 +448,7 @@ class Statement\n \n   // For children to return an error statement from lower().\n   static Statement*\n-  make_error_statement(source_location);\n+  make_error_statement(Location);\n \n  private:\n   // Convert to the desired statement classification, or return NULL.\n@@ -474,15 +474,15 @@ class Statement\n   // The statement classification.\n   Statement_classification classification_;\n   // The location in the input file of the start of this statement.\n-  source_location location_;\n+  Location location_;\n };\n \n // A statement which creates and initializes a temporary variable.\n \n class Temporary_statement : public Statement\n {\n  public:\n-  Temporary_statement(Type* type, Expression* init, source_location location)\n+  Temporary_statement(Type* type, Expression* init, Location location)\n     : Statement(STATEMENT_TEMPORARY, location),\n       type_(type), init_(init), bvariable_(NULL), are_hidden_fields_ok_(false),\n       is_address_taken_(false)\n@@ -579,7 +579,7 @@ class Variable_declaration_statement : public Statement\n class Return_statement : public Statement\n {\n  public:\n-  Return_statement(Expression_list* vals, source_location location)\n+  Return_statement(Expression_list* vals, Location location)\n     : Statement(STATEMENT_RETURN, location),\n       vals_(vals), are_hidden_fields_ok_(false), is_lowered_(false)\n   { }\n@@ -632,7 +632,7 @@ class Send_statement : public Statement\n {\n  public:\n   Send_statement(Expression* channel, Expression* val,\n-\t\t source_location location)\n+\t\t Location location)\n     : Statement(STATEMENT_SEND, location),\n       channel_(channel), val_(val), for_select_(false)\n   { }\n@@ -691,7 +691,7 @@ class Select_clauses\n   void\n   add(bool is_send, Expression* channel, Expression* val, Expression* closed,\n       Named_object* var, Named_object* closedvar, bool is_default,\n-      Block* statements, source_location location)\n+      Block* statements, Location location)\n   {\n     this->clauses_.push_back(Select_clause(is_send, channel, val, closed, var,\n \t\t\t\t\t   closedvar, is_default, statements,\n@@ -717,7 +717,7 @@ class Select_clauses\n \n   // Convert to the backend representation.\n   Bstatement*\n-  get_backend(Translate_context*, Unnamed_label* break_label, source_location);\n+  get_backend(Translate_context*, Unnamed_label* break_label, Location);\n \n   // Dump AST representation.\n   void\n@@ -737,7 +737,7 @@ class Select_clauses\n     Select_clause(bool is_send, Expression* channel, Expression* val,\n \t\t  Expression* closed, Named_object* var,\n \t\t  Named_object* closedvar, bool is_default, Block* statements,\n-\t\t  source_location location)\n+\t\t  Location location)\n       : channel_(channel), val_(val), closed_(closed), var_(var),\n \tclosedvar_(closedvar), statements_(statements), location_(location),\n \tis_send_(is_send), is_default_(is_default), is_lowered_(false)\n@@ -780,7 +780,7 @@ class Select_clauses\n     { return this->statements_; }\n \n     // Return the location.\n-    source_location\n+    Location\n     location() const\n     { return this->location_; }\n \n@@ -813,7 +813,7 @@ class Select_clauses\n     // The statements to execute.\n     Block* statements_;\n     // The location of this clause.\n-    source_location location_;\n+    Location location_;\n     // Whether this is a send or a receive.\n     bool is_send_;\n     // Whether this is the default.\n@@ -823,7 +823,7 @@ class Select_clauses\n   };\n \n   void\n-  add_clause_backend(Translate_context*, source_location, int index,\n+  add_clause_backend(Translate_context*, Location, int index,\n \t\t     int case_value, Select_clause*, Unnamed_label*,\n \t\t     std::vector<std::vector<Bexpression*> >* cases,\n \t\t     std::vector<Bstatement*>* clauses);\n@@ -838,7 +838,7 @@ class Select_clauses\n class Select_statement : public Statement\n {\n  public:\n-  Select_statement(source_location location)\n+  Select_statement(Location location)\n     : Statement(STATEMENT_SELECT, location),\n       clauses_(NULL), break_label_(NULL), is_lowered_(false)\n   { }\n@@ -892,7 +892,7 @@ class Thunk_statement : public Statement\n {\n  public:\n   Thunk_statement(Statement_classification, Call_expression*,\n-\t\t  source_location);\n+\t\t  Location);\n \n   // Return the call expression.\n   Expression*\n@@ -955,7 +955,7 @@ class Thunk_statement : public Statement\n class Go_statement : public Thunk_statement\n {\n  public:\n-  Go_statement(Call_expression* call, source_location location)\n+  Go_statement(Call_expression* call, Location location)\n     : Thunk_statement(STATEMENT_GO, call, location)\n   { }\n \n@@ -972,7 +972,7 @@ class Go_statement : public Thunk_statement\n class Defer_statement : public Thunk_statement\n {\n  public:\n-  Defer_statement(Call_expression* call, source_location location)\n+  Defer_statement(Call_expression* call, Location location)\n     : Thunk_statement(STATEMENT_DEFER, call, location)\n   { }\n \n@@ -989,7 +989,7 @@ class Defer_statement : public Thunk_statement\n class Label_statement : public Statement\n {\n  public:\n-  Label_statement(Label* label, source_location location)\n+  Label_statement(Label* label, Location location)\n     : Statement(STATEMENT_LABEL, location),\n       label_(label)\n   { }\n@@ -1020,7 +1020,7 @@ class For_statement : public Statement\n {\n  public:\n   For_statement(Block* init, Expression* cond, Block* post,\n-\t\tsource_location location)\n+\t\tLocation location)\n     : Statement(STATEMENT_FOR, location),\n       init_(init), cond_(cond), post_(post), statements_(NULL),\n       break_label_(NULL), continue_label_(NULL)\n@@ -1086,7 +1086,7 @@ class For_range_statement : public Statement\n {\n  public:\n   For_range_statement(Expression* index_var, Expression* value_var,\n-\t\t      Expression* range, source_location location)\n+\t\t      Expression* range, Location location)\n     : Statement(STATEMENT_FOR_RANGE, location),\n       index_var_(index_var), value_var_(value_var), range_(range),\n       statements_(NULL), break_label_(NULL), continue_label_(NULL)\n@@ -1128,10 +1128,10 @@ class For_range_statement : public Statement\n \n  private:\n   Expression*\n-  make_range_ref(Named_object*, Temporary_statement*, source_location);\n+  make_range_ref(Named_object*, Temporary_statement*, Location);\n \n   Expression*\n-  call_builtin(Gogo*, const char* funcname, Expression* arg, source_location);\n+  call_builtin(Gogo*, const char* funcname, Expression* arg, Location);\n \n   void\n   lower_range_array(Gogo*, Block*, Block*, Named_object*, Temporary_statement*,\n@@ -1186,7 +1186,7 @@ class Case_clauses\n   // next clause.\n   void\n   add(Expression_list* cases, bool is_default, Block* statements,\n-      bool is_fallthrough, source_location location)\n+      bool is_fallthrough, Location location)\n   {\n     this->clauses_.push_back(Case_clause(cases, is_default, statements,\n \t\t\t\t\t is_fallthrough, location));\n@@ -1252,7 +1252,7 @@ class Case_clauses\n     { }\n \n     Case_clause(Expression_list* cases, bool is_default, Block* statements,\n-\t\tbool is_fallthrough, source_location location)\n+\t\tbool is_fallthrough, Location location)\n       : cases_(cases), statements_(statements), is_default_(is_default),\n \tis_fallthrough_(is_fallthrough), location_(location)\n     { }\n@@ -1268,7 +1268,7 @@ class Case_clauses\n     { return this->is_default_; }\n \n     // The location of this clause.\n-    source_location\n+    Location\n     location() const\n     { return this->location_; }\n \n@@ -1318,7 +1318,7 @@ class Case_clauses\n     // Whether this falls through after the statements.\n     bool is_fallthrough_;\n     // The location of this case clause.\n-    source_location location_;\n+    Location location_;\n   };\n \n   friend class Case_clause;\n@@ -1335,7 +1335,7 @@ class Case_clauses\n class Switch_statement : public Statement\n {\n  public:\n-  Switch_statement(Expression* val, source_location location)\n+  Switch_statement(Expression* val, Location location)\n     : Statement(STATEMENT_SWITCH, location),\n       val_(val), clauses_(NULL), break_label_(NULL)\n   { }\n@@ -1392,7 +1392,7 @@ class Type_case_clauses\n   // statements; it may be NULL.\n   void\n   add(Type* type, bool is_fallthrough, bool is_default, Block* statements,\n-      source_location location)\n+      Location location)\n   {\n     this->clauses_.push_back(Type_case_clause(type, is_fallthrough, is_default,\n \t\t\t\t\t      statements, location));\n@@ -1431,7 +1431,7 @@ class Type_case_clauses\n     { }\n \n     Type_case_clause(Type* type, bool is_fallthrough, bool is_default,\n-\t\t     Block* statements, source_location location)\n+\t\t     Block* statements, Location location)\n       : type_(type), statements_(statements), is_fallthrough_(is_fallthrough),\n \tis_default_(is_default), location_(location)\n     { }\n@@ -1447,7 +1447,7 @@ class Type_case_clauses\n     { return this->is_default_; }\n \n     // The location of this type clause.\n-    source_location\n+    Location\n     location() const\n     { return this->location_; }\n \n@@ -1474,7 +1474,7 @@ class Type_case_clauses\n     // Whether this is the default case.\n     bool is_default_;\n     // The location of this type case clause.\n-    source_location location_;\n+    Location location_;\n   };\n \n   friend class Type_case_clause;\n@@ -1492,7 +1492,7 @@ class Type_switch_statement : public Statement\n {\n  public:\n   Type_switch_statement(Named_object* var, Expression* expr,\n-\t\t\tsource_location location)\n+\t\t\tLocation location)\n     : Statement(STATEMENT_TYPE_SWITCH, location),\n       var_(var), expr_(expr), clauses_(NULL), break_label_(NULL)\n   { go_assert(var == NULL || expr == NULL); }"}, {"sha": "74d9765c5d925c893eb03e74af288f4cb128a30b", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 89, "deletions": 81, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=8afa2bfbdc60088acd7f199245244890a6e7773e", "patch": "@@ -853,7 +853,7 @@ Type::get_btype_without_hash(Gogo* gogo)\n // Return a pointer to the type descriptor for this type.\n \n tree\n-Type::type_descriptor_pointer(Gogo* gogo, source_location location)\n+Type::type_descriptor_pointer(Gogo* gogo, Location location)\n {\n   Type* t = this->forwarded();\n   if (t->type_descriptor_var_ == NULL)\n@@ -864,7 +864,7 @@ Type::type_descriptor_pointer(Gogo* gogo, source_location location)\n   tree var_tree = var_to_tree(t->type_descriptor_var_);\n   if (var_tree == error_mark_node)\n     return error_mark_node;\n-  return build_fold_addr_expr_loc(location, var_tree);\n+  return build_fold_addr_expr_loc(location.gcc_location(), var_tree);\n }\n \n // A mapping from unnamed types to type descriptor variables.\n@@ -934,7 +934,7 @@ Type::make_type_descriptor_var(Gogo* gogo)\n \t}\n     }\n \n-  source_location loc = nt == NULL ? BUILTINS_LOCATION : nt->location();\n+  Location loc = nt == NULL ? Linemap::predeclared_location() : nt->location();\n \n   if (is_defined_elsewhere)\n     {\n@@ -1054,7 +1054,7 @@ Type::make_builtin_struct_type(int nfields, ...)\n   va_list ap;\n   va_start(ap, nfields);\n \n-  source_location bloc = BUILTINS_LOCATION;\n+  Location bloc = Linemap::predeclared_location();\n   Struct_field_list* sfl = new Struct_field_list();\n   for (int i = 0; i < nfields; i++)\n     {\n@@ -1077,7 +1077,7 @@ std::vector<Named_type*> Type::named_builtin_types;\n Named_type*\n Type::make_builtin_named_type(const char* name, Type* type)\n {\n-  source_location bloc = BUILTINS_LOCATION;\n+  Location bloc = Linemap::predeclared_location();\n   Named_object* no = Named_object::make_type(name, NULL, type, bloc);\n   Named_type* ret = no->type_value();\n   Type::named_builtin_types.push_back(ret);\n@@ -1110,7 +1110,7 @@ Type::make_type_descriptor_type()\n   static Type* ret;\n   if (ret == NULL)\n     {\n-      source_location bloc = BUILTINS_LOCATION;\n+      Location bloc = Linemap::predeclared_location();\n \n       Type* uint8_type = Type::lookup_integer_type(\"uint8\");\n       Type* uint32_type = Type::lookup_integer_type(\"uint32\");\n@@ -1286,7 +1286,7 @@ Type::type_descriptor_constructor(Gogo* gogo, int runtime_type_kind,\n \t\t\t\t  Named_type* name, const Methods* methods,\n \t\t\t\t  bool only_value_methods)\n {\n-  source_location bloc = BUILTINS_LOCATION;\n+  Location bloc = Linemap::predeclared_location();\n \n   Type* td_type = Type::make_type_descriptor_type();\n   const Struct_field_list* fields = td_type->struct_type()->fields();\n@@ -1394,7 +1394,7 @@ Type::uncommon_type_constructor(Gogo* gogo, Type* uncommon_type,\n \t\t\t\tNamed_type* name, const Methods* methods,\n \t\t\t\tbool only_value_methods) const\n {\n-  source_location bloc = BUILTINS_LOCATION;\n+  Location bloc = Linemap::predeclared_location();\n \n   const Struct_field_list* fields = uncommon_type->struct_type()->fields();\n \n@@ -1477,7 +1477,7 @@ Type::methods_constructor(Gogo* gogo, Type* methods_type,\n \t\t\t  const Methods* methods,\n \t\t\t  bool only_value_methods) const\n {\n-  source_location bloc = BUILTINS_LOCATION;\n+  Location bloc = Linemap::predeclared_location();\n \n   std::vector<std::pair<std::string, const Method*> > smethods;\n   if (methods != NULL)\n@@ -1524,7 +1524,7 @@ Type::method_constructor(Gogo*, Type* method_type,\n \t\t\t const Method* m,\n \t\t\t bool only_value_methods) const\n {\n-  source_location bloc = BUILTINS_LOCATION;\n+  Location bloc = Linemap::predeclared_location();\n \n   const Struct_field_list* fields = method_type->struct_type()->fields();\n \n@@ -1688,7 +1688,7 @@ class Error_type : public Type\n \n   Expression*\n   do_type_descriptor(Gogo*, Named_type*)\n-  { return Expression::make_error(BUILTINS_LOCATION); }\n+  { return Expression::make_error(Linemap::predeclared_location()); }\n \n   void\n   do_reflection(Gogo*, std::string*) const\n@@ -1807,9 +1807,9 @@ Named_type*\n Type::make_named_bool_type()\n {\n   Type* bool_type = Type::make_boolean_type();\n-  Named_object* named_object = Named_object::make_type(\"bool\", NULL,\n-\t\t\t\t\t\t       bool_type,\n-\t\t\t\t\t\t       BUILTINS_LOCATION);\n+  Named_object* named_object =\n+    Named_object::make_type(\"bool\", NULL, bool_type,\n+                            Linemap::predeclared_location());\n   Named_type* named_type = named_object->type_value();\n   named_bool_type = named_type;\n   return named_type;\n@@ -1829,9 +1829,9 @@ Integer_type::create_integer_type(const char* name, bool is_unsigned,\n   Integer_type* integer_type = new Integer_type(false, is_unsigned, bits,\n \t\t\t\t\t\truntime_type_kind);\n   std::string sname(name);\n-  Named_object* named_object = Named_object::make_type(sname, NULL,\n-\t\t\t\t\t\t       integer_type,\n-\t\t\t\t\t\t       BUILTINS_LOCATION);\n+  Named_object* named_object =\n+    Named_object::make_type(sname, NULL, integer_type,\n+                            Linemap::predeclared_location());\n   Named_type* named_type = named_object->type_value();\n   std::pair<Named_integer_types::iterator, bool> ins =\n     Integer_type::named_integer_types.insert(std::make_pair(sname, named_type));\n@@ -1965,8 +1965,9 @@ Float_type::create_float_type(const char* name, int bits,\n {\n   Float_type* float_type = new Float_type(false, bits, runtime_type_kind);\n   std::string sname(name);\n-  Named_object* named_object = Named_object::make_type(sname, NULL, float_type,\n-\t\t\t\t\t\t       BUILTINS_LOCATION);\n+  Named_object* named_object =\n+    Named_object::make_type(sname, NULL, float_type,\n+                            Linemap::predeclared_location());\n   Named_type* named_type = named_object->type_value();\n   std::pair<Named_float_types::iterator, bool> ins =\n     Float_type::named_float_types.insert(std::make_pair(sname, named_type));\n@@ -2089,9 +2090,9 @@ Complex_type::create_complex_type(const char* name, int bits,\n   Complex_type* complex_type = new Complex_type(false, bits,\n \t\t\t\t\t\truntime_type_kind);\n   std::string sname(name);\n-  Named_object* named_object = Named_object::make_type(sname, NULL,\n-\t\t\t\t\t\t       complex_type,\n-\t\t\t\t\t\t       BUILTINS_LOCATION);\n+  Named_object* named_object =\n+    Named_object::make_type(sname, NULL, complex_type,\n+                            Linemap::predeclared_location());\n   Named_type* named_type = named_object->type_value();\n   std::pair<Named_complex_types::iterator, bool> ins =\n     Complex_type::named_complex_types.insert(std::make_pair(sname,\n@@ -2219,12 +2220,12 @@ String_type::do_get_backend(Gogo* gogo)\n       Type* pb = Type::make_pointer_type(b);\n       fields[0].name = \"__data\";\n       fields[0].btype = pb->get_backend(gogo);\n-      fields[0].location = UNKNOWN_LOCATION;\n+      fields[0].location = Linemap::predeclared_location();\n \n       Type* int_type = Type::lookup_integer_type(\"int\");\n       fields[1].name = \"__length\";\n       fields[1].btype = int_type->get_backend(gogo);\n-      fields[1].location = UNKNOWN_LOCATION;\n+      fields[1].location = fields[0].location;\n \n       backend_string_type = gogo->backend()->struct_type(fields);\n     }\n@@ -2317,9 +2318,9 @@ Named_type*\n Type::make_named_string_type()\n {\n   Type* string_type = Type::make_string_type();\n-  Named_object* named_object = Named_object::make_type(\"string\", NULL,\n-\t\t\t\t\t\t       string_type,\n-\t\t\t\t\t\t       BUILTINS_LOCATION);\n+  Named_object* named_object =\n+    Named_object::make_type(\"string\", NULL, string_type,\n+                            Linemap::predeclared_location());\n   Named_type* named_type = named_object->type_value();\n   named_string_type = named_type;\n   return named_type;\n@@ -2742,7 +2743,7 @@ Function_type::make_function_type_descriptor_type()\n Expression*\n Function_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n {\n-  source_location bloc = BUILTINS_LOCATION;\n+  Location bloc = Linemap::predeclared_location();\n \n   Type* ftdt = Function_type::make_function_type_descriptor_type();\n \n@@ -2785,7 +2786,7 @@ Function_type::type_descriptor_params(Type* params_type,\n \t\t\t\t      const Typed_identifier* receiver,\n \t\t\t\t      const Typed_identifier_list* params)\n {\n-  source_location bloc = BUILTINS_LOCATION;\n+  Location bloc = Linemap::predeclared_location();\n \n   if (receiver == NULL && params == NULL)\n     return Expression::make_slice_composite_literal(params_type, NULL, bloc);\n@@ -3073,7 +3074,7 @@ Function_type*\n Type::make_function_type(Typed_identifier* receiver,\n \t\t\t Typed_identifier_list* parameters,\n \t\t\t Typed_identifier_list* results,\n-\t\t\t source_location location)\n+\t\t\t Location location)\n {\n   return new Function_type(receiver, parameters, results, location);\n }\n@@ -3140,7 +3141,7 @@ Pointer_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n     }\n   else\n     {\n-      source_location bloc = BUILTINS_LOCATION;\n+      Location bloc = Linemap::predeclared_location();\n \n       const Methods* methods;\n       Type* deref = this->points_to();\n@@ -3302,7 +3303,7 @@ class Call_multiple_result_type : public Type\n   do_type_descriptor(Gogo*, Named_type*)\n   {\n     go_assert(saw_errors());\n-    return Expression::make_error(UNKNOWN_LOCATION);\n+    return Expression::make_error(Linemap::unknown_location());\n   }\n \n   void\n@@ -3609,7 +3610,7 @@ Struct_type::find_local_field(const std::string& name,\n \n Field_reference_expression*\n Struct_type::field_reference(Expression* struct_expr, const std::string& name,\n-\t\t\t     source_location location) const\n+\t\t\t     Location location) const\n {\n   unsigned int depth;\n   return this->field_reference_depth(struct_expr, name, location, NULL,\n@@ -3622,7 +3623,7 @@ Struct_type::field_reference(Expression* struct_expr, const std::string& name,\n Field_reference_expression*\n Struct_type::field_reference_depth(Expression* struct_expr,\n \t\t\t\t   const std::string& name,\n-\t\t\t\t   source_location location,\n+\t\t\t\t   Location location,\n \t\t\t\t   Saw_named_type* saw,\n \t\t\t\t   unsigned int* depth) const\n {\n@@ -3867,7 +3868,7 @@ Struct_type::make_struct_type_descriptor_type()\n Expression*\n Struct_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n {\n-  source_location bloc = BUILTINS_LOCATION;\n+  Location bloc = Linemap::predeclared_location();\n \n   Type* stdt = Struct_type::make_struct_type_descriptor_type();\n \n@@ -4081,8 +4082,8 @@ Struct_type::do_export(Export* exp) const\n       if (p->has_tag())\n \t{\n \t  exp->write_c_string(\" \");\n-\t  Expression* expr = Expression::make_string(p->tag(),\n-\t\t\t\t\t\t     BUILTINS_LOCATION);\n+\t  Expression* expr =\n+            Expression::make_string(p->tag(), Linemap::predeclared_location());\n \t  expr->export_expression(exp);\n \t  delete expr;\n \t}\n@@ -4140,7 +4141,7 @@ Struct_type::do_import(Import* imp)\n \n Struct_type*\n Type::make_struct_type(Struct_field_list* fields,\n-\t\t       source_location location)\n+\t\t       Location location)\n {\n   return new Struct_type(fields, location);\n }\n@@ -4356,23 +4357,24 @@ get_backend_slice_fields(Gogo* gogo, Array_type* type,\n \n   Type* pet = Type::make_pointer_type(type->element_type());\n   Btype* pbet = pet->get_backend(gogo);\n+  Location ploc = Linemap::predeclared_location();\n \n   Backend::Btyped_identifier* p = &(*bfields)[0];\n   p->name = \"__values\";\n   p->btype = pbet;\n-  p->location = UNKNOWN_LOCATION;\n+  p->location = ploc;\n \n   Type* int_type = Type::lookup_integer_type(\"int\");\n \n   p = &(*bfields)[1];\n   p->name = \"__count\";\n   p->btype = int_type->get_backend(gogo);\n-  p->location = UNKNOWN_LOCATION;\n+  p->location = ploc;\n \n   p = &(*bfields)[2];\n   p->name = \"__capacity\";\n   p->btype = int_type->get_backend(gogo);\n-  p->location = UNKNOWN_LOCATION;\n+  p->location = ploc;\n }\n \n // Get a tree for the type of this array.  A fixed array is simply\n@@ -4579,7 +4581,7 @@ Array_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n Expression*\n Array_type::array_type_descriptor(Gogo* gogo, Named_type* name)\n {\n-  source_location bloc = BUILTINS_LOCATION;\n+  Location bloc = Linemap::predeclared_location();\n \n   Type* atdt = Array_type::make_array_type_descriptor_type();\n \n@@ -4618,7 +4620,7 @@ Array_type::array_type_descriptor(Gogo* gogo, Named_type* name)\n Expression*\n Array_type::slice_type_descriptor(Gogo* gogo, Named_type* name)\n {\n-  source_location bloc = BUILTINS_LOCATION;\n+  Location bloc = Linemap::predeclared_location();\n \n   Type* stdt = Array_type::make_slice_type_descriptor_type();\n \n@@ -4772,29 +4774,31 @@ Map_type::do_get_backend(Gogo* gogo)\n     {\n       std::vector<Backend::Btyped_identifier> bfields(4);\n \n+      Location bloc = Linemap::predeclared_location();\n+\n       Type* pdt = Type::make_type_descriptor_ptr_type();\n       bfields[0].name = \"__descriptor\";\n       bfields[0].btype = pdt->get_backend(gogo);\n-      bfields[0].location = BUILTINS_LOCATION;\n+      bfields[0].location = bloc;\n \n       Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n       bfields[1].name = \"__element_count\";\n       bfields[1].btype = uintptr_type->get_backend(gogo);\n-      bfields[1].location = BUILTINS_LOCATION;\n+      bfields[1].location = bloc;\n \n       bfields[2].name = \"__bucket_count\";\n       bfields[2].btype = bfields[1].btype;\n-      bfields[2].location = BUILTINS_LOCATION;\n+      bfields[2].location = bloc;\n \n       Btype* bvt = gogo->backend()->void_type();\n       Btype* bpvt = gogo->backend()->pointer_type(bvt);\n       Btype* bppvt = gogo->backend()->pointer_type(bpvt);\n       bfields[3].name = \"__buckets\";\n       bfields[3].btype = bppvt;\n-      bfields[3].location = BUILTINS_LOCATION;\n+      bfields[3].location = bloc;\n \n       Btype *bt = gogo->backend()->struct_type(bfields);\n-      bt = gogo->backend()->named_type(\"__go_map\", bt, BUILTINS_LOCATION);\n+      bt = gogo->backend()->named_type(\"__go_map\", bt, bloc);\n       backend_map_type = gogo->backend()->pointer_type(bt);\n     }\n   return backend_map_type;\n@@ -4828,7 +4832,7 @@ Map_type::make_map_type_descriptor_type()\n Expression*\n Map_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n {\n-  source_location bloc = BUILTINS_LOCATION;\n+  Location bloc = Linemap::predeclared_location();\n \n   Type* mtdt = Map_type::make_map_type_descriptor_type();\n \n@@ -4864,13 +4868,13 @@ Map_type::Map_descriptors Map_type::map_descriptors;\n // Build a map descriptor for this type.  Return a pointer to it.\n \n tree\n-Map_type::map_descriptor_pointer(Gogo* gogo, source_location location)\n+Map_type::map_descriptor_pointer(Gogo* gogo, Location location)\n {\n   Bvariable* bvar = this->map_descriptor(gogo);\n   tree var_tree = var_to_tree(bvar);\n   if (var_tree == error_mark_node)\n     return error_mark_node;\n-  return build_fold_addr_expr_loc(location, var_tree);\n+  return build_fold_addr_expr_loc(location.gcc_location(), var_tree);\n }\n \n // Build a map descriptor for this type.\n@@ -4907,7 +4911,7 @@ Map_type::map_descriptor(Gogo* gogo)\n   Expression_list* vals = new Expression_list();\n   vals->reserve(4);\n \n-  source_location bloc = BUILTINS_LOCATION;\n+  Location bloc = Linemap::predeclared_location();\n \n   Struct_field_list::const_iterator p = fields->begin();\n \n@@ -5028,7 +5032,7 @@ Map_type::do_import(Import* imp)\n // Make a map type.\n \n Map_type*\n-Type::make_map_type(Type* key_type, Type* val_type, source_location location)\n+Type::make_map_type(Type* key_type, Type* val_type, Location location)\n {\n   return new Map_type(key_type, val_type, location);\n }\n@@ -5075,7 +5079,8 @@ Channel_type::do_get_backend(Gogo* gogo)\n     {\n       std::vector<Backend::Btyped_identifier> bfields;\n       Btype* bt = gogo->backend()->struct_type(bfields);\n-      bt = gogo->backend()->named_type(\"__go_channel\", bt, BUILTINS_LOCATION);\n+      bt = gogo->backend()->named_type(\"__go_channel\", bt,\n+                                       Linemap::predeclared_location());\n       backend_channel_type = gogo->backend()->pointer_type(bt);\n     }\n   return backend_channel_type;\n@@ -5111,7 +5116,7 @@ Channel_type::make_chan_type_descriptor_type()\n Expression*\n Channel_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n {\n-  source_location bloc = BUILTINS_LOCATION;\n+  Location bloc = Linemap::predeclared_location();\n \n   Type* ctdt = Channel_type::make_chan_type_descriptor_type();\n \n@@ -5670,15 +5675,17 @@ Interface_type::get_backend_empty_interface_type(Gogo* gogo)\n     {\n       std::vector<Backend::Btyped_identifier> bfields(2);\n \n+      Location bloc = Linemap::predeclared_location();\n+\n       Type* pdt = Type::make_type_descriptor_ptr_type();\n       bfields[0].name = \"__type_descriptor\";\n       bfields[0].btype = pdt->get_backend(gogo);\n-      bfields[0].location = UNKNOWN_LOCATION;\n+      bfields[0].location = bloc;\n \n       Type* vt = Type::make_pointer_type(Type::make_void_type());\n       bfields[1].name = \"__object\";\n       bfields[1].btype = vt->get_backend(gogo);\n-      bfields[1].location = UNKNOWN_LOCATION;\n+      bfields[1].location = bloc;\n \n       empty_interface_type = gogo->backend()->struct_type(bfields);\n     }\n@@ -5693,7 +5700,7 @@ static void\n get_backend_interface_fields(Gogo* gogo, Interface_type* type,\n \t\t\t     std::vector<Backend::Btyped_identifier>* bfields)\n {\n-  source_location loc = type->location();\n+  Location loc = type->location();\n \n   std::vector<Backend::Btyped_identifier> mfields(type->methods()->size() + 1);\n \n@@ -5727,7 +5734,7 @@ get_backend_interface_fields(Gogo* gogo, Interface_type* type,\n   Type* vt = Type::make_pointer_type(Type::make_void_type());\n   (*bfields)[1].name = \"__object\";\n   (*bfields)[1].btype = vt->get_backend(gogo);\n-  (*bfields)[1].location = UNKNOWN_LOCATION;\n+  (*bfields)[1].location = Linemap::predeclared_location();\n }\n \n // Return a tree for an interface type.  An interface is a pointer to\n@@ -5789,7 +5796,7 @@ Interface_type::make_interface_type_descriptor_type()\n Expression*\n Interface_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n {\n-  source_location bloc = BUILTINS_LOCATION;\n+  Location bloc = Linemap::predeclared_location();\n \n   Type* itdt = Interface_type::make_interface_type_descriptor_type();\n \n@@ -5800,9 +5807,9 @@ Interface_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n \n   Struct_field_list::const_iterator pif = ifields->begin();\n   go_assert(pif->is_field_name(\"commonType\"));\n-  ivals->push_back(this->type_descriptor_constructor(gogo,\n-\t\t\t\t\t\t     RUNTIME_TYPE_KIND_INTERFACE,\n-\t\t\t\t\t\t     name, NULL, true));\n+  const int rt = RUNTIME_TYPE_KIND_INTERFACE;\n+  ivals->push_back(this->type_descriptor_constructor(gogo, rt, name, NULL,\n+\t\t\t\t\t\t     true));\n \n   ++pif;\n   go_assert(pif->is_field_name(\"methods\"));\n@@ -6095,7 +6102,7 @@ Interface_type::do_import(Import* imp)\n \n Interface_type*\n Type::make_interface_type(Typed_identifier_list* methods,\n-\t\t\t  source_location location)\n+\t\t\t  Location location)\n {\n   return new Interface_type(methods, location);\n }\n@@ -6105,7 +6112,7 @@ Type::make_interface_type(Typed_identifier_list* methods,\n // Bind a method to an object.\n \n Expression*\n-Method::bind_method(Expression* expr, source_location location) const\n+Method::bind_method(Expression* expr, Location location) const\n {\n   if (this->stub_ == NULL)\n     {\n@@ -6144,7 +6151,7 @@ Named_method::do_type() const\n \n // Return the location of the method receiver.\n \n-source_location\n+Location\n Named_method::do_receiver_location() const\n {\n   return this->do_type()->receiver()->location();\n@@ -6153,7 +6160,7 @@ Named_method::do_receiver_location() const\n // Bind a method to an object.\n \n Expression*\n-Named_method::do_bind_method(Expression* expr, source_location location) const\n+Named_method::do_bind_method(Expression* expr, Location location) const\n {\n   Named_object* no = this->named_object_;\n   Bound_method_expression* bme = Expression::make_bound_method(expr, no,\n@@ -6177,7 +6184,7 @@ Named_method::do_bind_method(Expression* expr, source_location location) const\n \n Expression*\n Interface_method::do_bind_method(Expression* expr,\n-\t\t\t\t source_location location) const\n+\t\t\t\t Location location) const\n {\n   return Expression::make_interface_field_reference(expr, this->name_,\n \t\t\t\t\t\t    location);\n@@ -6299,7 +6306,7 @@ Named_type::add_method(const std::string& name, Function* function)\n Named_object*\n Named_type::add_method_declaration(const std::string& name, Package* package,\n \t\t\t\t   Function_type* type,\n-\t\t\t\t   source_location location)\n+\t\t\t\t   Location location)\n {\n   if (this->local_methods_ == NULL)\n     this->local_methods_ = new Bindings(NULL);\n@@ -6967,7 +6974,7 @@ Named_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n void\n Named_type::do_reflection(Gogo* gogo, std::string* ret) const\n {\n-  if (this->location() != BUILTINS_LOCATION)\n+  if (!Linemap::is_predeclared_location(this->location()))\n     {\n       const Package* package = this->named_object_->package();\n       if (package != NULL)\n@@ -6991,7 +6998,7 @@ Named_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n {\n   Named_object* no = this->named_object_;\n   std::string name;\n-  if (this->location() == BUILTINS_LOCATION)\n+  if (Linemap::is_predeclared_location(this->location()))\n     go_assert(this->in_function_ == NULL);\n   else\n     {\n@@ -7081,7 +7088,7 @@ Named_type::do_export(Export* exp) const\n \n Named_type*\n Type::make_named_type(Named_object* named_object, Type* type,\n-\t\t      source_location location)\n+\t\t      Location location)\n {\n   return new Named_type(named_object, type, location);\n }\n@@ -7091,7 +7098,7 @@ Type::make_named_type(Named_object* named_object, Type* type,\n // all required stubs.\n \n void\n-Type::finalize_methods(Gogo* gogo, const Type* type, source_location location,\n+Type::finalize_methods(Gogo* gogo, const Type* type, Location location,\n \t\t       Methods** all_methods)\n {\n   *all_methods = NULL;\n@@ -7291,7 +7298,7 @@ Type::add_interface_methods_for_type(const Type* type,\n \n void\n Type::build_stub_methods(Gogo* gogo, const Type* type, const Methods* methods,\n-\t\t\t source_location location)\n+\t\t\t Location location)\n {\n   if (methods == NULL)\n     return;\n@@ -7317,7 +7324,7 @@ Type::build_stub_methods(Gogo* gogo, const Type* type, const Methods* methods,\n       Type* receiver_type = const_cast<Type*>(type);\n       if (!m->is_value_method())\n \treceiver_type = Type::make_pointer_type(receiver_type);\n-      source_location receiver_location = m->receiver_location();\n+      Location receiver_location = m->receiver_location();\n       Typed_identifier* receiver = new Typed_identifier(buf, receiver_type,\n \t\t\t\t\t\t\treceiver_location);\n \n@@ -7397,7 +7404,7 @@ Type::build_one_stub_method(Gogo* gogo, Method* method,\n \t\t\t    const char* receiver_name,\n \t\t\t    const Typed_identifier_list* params,\n \t\t\t    bool is_varargs,\n-\t\t\t    source_location location)\n+\t\t\t    Location location)\n {\n   Named_object* receiver_object = gogo->lookup(receiver_name, NULL);\n   go_assert(receiver_object != NULL);\n@@ -7460,7 +7467,7 @@ Type::build_one_stub_method(Gogo* gogo, Method* method,\n Expression*\n Type::apply_field_indexes(Expression* expr,\n \t\t\t  const Method::Field_indexes* field_indexes,\n-\t\t\t  source_location location)\n+\t\t\t  Location location)\n {\n   if (field_indexes == NULL)\n     return expr;\n@@ -7526,7 +7533,7 @@ Type::method_function(const Methods* methods, const std::string& name,\n Expression*\n Type::bind_field_or_method(Gogo* gogo, const Type* type, Expression* expr,\n \t\t\t   const std::string& name,\n-\t\t\t   source_location location)\n+\t\t\t   Location location)\n {\n   if (type->deref()->is_error_type())\n     return Expression::make_error(location);\n@@ -8040,7 +8047,7 @@ Forward_declaration_type::add_method(const std::string& name,\n Named_object*\n Forward_declaration_type::add_method_declaration(const std::string& name,\n \t\t\t\t\t\t Function_type* type,\n-\t\t\t\t\t\t source_location location)\n+\t\t\t\t\t\t Location location)\n {\n   Named_object* no = this->named_object();\n   if (no->is_unknown())\n@@ -8085,15 +8092,16 @@ Forward_declaration_type::do_get_backend(Gogo* gogo)\n Expression*\n Forward_declaration_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n {\n+  Location ploc = Linemap::predeclared_location();\n   if (!this->is_defined())\n-    return Expression::make_nil(BUILTINS_LOCATION);\n+    return Expression::make_nil(ploc);\n   else\n     {\n       Type* t = this->real_type();\n       if (name != NULL)\n \treturn this->named_type_descriptor(gogo, t, name);\n       else\n-\treturn Expression::make_type_descriptor(t, BUILTINS_LOCATION);\n+\treturn Expression::make_type_descriptor(t, ploc);\n     }\n }\n "}, {"sha": "035444f16af3ca1197333a989560cf39c484b30e", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 48, "deletions": 45, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=8afa2bfbdc60088acd7f199245244890a6e7773e", "patch": "@@ -7,6 +7,8 @@\n #ifndef GO_TYPES_H\n #define GO_TYPES_H\n \n+#include \"go-linemap.h\"\n+\n class Gogo;\n class Package;\n class Traverse;\n@@ -147,14 +149,14 @@ class Method\n   { return this->do_type(); }\n \n   // Return the location of the method receiver.\n-  source_location\n+  Location\n   receiver_location() const\n   { return this->do_receiver_location(); }\n \n   // Return an expression which binds this method to EXPR.  This is\n   // something which can be used with a function call.\n   Expression*\n-  bind_method(Expression* expr, source_location location) const;\n+  bind_method(Expression* expr, Location location) const;\n \n   // Return the named object for this method.  This may only be called\n   // after methods are finalized.\n@@ -195,12 +197,12 @@ class Method\n   do_type() const = 0;\n \n   // Return the location of the method receiver.\n-  virtual source_location\n+  virtual Location\n   do_receiver_location() const = 0;\n \n   // Bind a method to an object.\n   virtual Expression*\n-  do_bind_method(Expression* expr, source_location location) const = 0;\n+  do_bind_method(Expression* expr, Location location) const = 0;\n \n  private:\n   // The sequence of field indexes used for this method.  If this is\n@@ -245,12 +247,12 @@ class Named_method : public Method\n   do_type() const;\n \n   // Return the location of the method receiver.\n-  source_location\n+  Location\n   do_receiver_location() const;\n \n   // Bind a method to an object.\n   Expression*\n-  do_bind_method(Expression* expr, source_location location) const;\n+  do_bind_method(Expression* expr, Location location) const;\n \n  private:\n   // The method itself.  For a method which needs a stub, this starts\n@@ -265,7 +267,7 @@ class Named_method : public Method\n class Interface_method : public Method\n {\n  public:\n-  Interface_method(const std::string& name, source_location location,\n+  Interface_method(const std::string& name, Location location,\n \t\t   Function_type* fntype, const Field_indexes* field_indexes,\n \t\t   unsigned int depth)\n     : Method(field_indexes, depth, true, true),\n@@ -285,19 +287,19 @@ class Interface_method : public Method\n   { return this->fntype_; }\n \n   // Return the location of the method receiver.\n-  source_location\n+  Location\n   do_receiver_location() const\n   { return this->location_; }\n \n   // Bind a method to an object.\n   Expression*\n-  do_bind_method(Expression* expr, source_location location) const;\n+  do_bind_method(Expression* expr, Location location) const;\n \n  private:\n   // The name of the interface method to call.\n   std::string name_;\n   // The location of the definition of the interface method.\n-  source_location location_;\n+  Location location_;\n   // The type of the interface method.\n   Function_type* fntype_;\n };\n@@ -457,7 +459,7 @@ class Type\n   make_function_type(Typed_identifier* receiver,\n \t\t     Typed_identifier_list* parameters,\n \t\t     Typed_identifier_list* results,\n-\t\t     source_location);\n+\t\t     Location);\n \n   static Pointer_type*\n   make_pointer_type(Type*);\n@@ -469,19 +471,19 @@ class Type\n   make_call_multiple_result_type(Call_expression*);\n \n   static Struct_type*\n-  make_struct_type(Struct_field_list* fields, source_location);\n+  make_struct_type(Struct_field_list* fields, Location);\n \n   static Array_type*\n   make_array_type(Type* element_type, Expression* length);\n \n   static Map_type*\n-  make_map_type(Type* key_type, Type* value_type, source_location);\n+  make_map_type(Type* key_type, Type* value_type, Location);\n \n   static Channel_type*\n   make_channel_type(bool send, bool receive, Type*);\n \n   static Interface_type*\n-  make_interface_type(Typed_identifier_list* methods, source_location);\n+  make_interface_type(Typed_identifier_list* methods, Location);\n \n   static Type*\n   make_type_descriptor_type();\n@@ -490,7 +492,7 @@ class Type\n   make_type_descriptor_ptr_type();\n \n   static Named_type*\n-  make_named_type(Named_object*, Type*, source_location);\n+  make_named_type(Named_object*, Type*, Location);\n \n   static Type*\n   make_forward_declaration(Named_object*);\n@@ -806,7 +808,7 @@ class Type\n   // it, bound to EXPR.\n   static Expression*\n   bind_field_or_method(Gogo*, const Type* type, Expression* expr,\n-\t\t       const std::string& name, source_location);\n+\t\t       const std::string& name, Location);\n \n   // Return true if NAME is an unexported field or method of TYPE.\n   static bool\n@@ -825,7 +827,7 @@ class Type\n   // it.  The location is the location which causes us to need the\n   // entry.\n   tree\n-  type_descriptor_pointer(Gogo* gogo, source_location);\n+  type_descriptor_pointer(Gogo* gogo, Location);\n \n   // Return the type reflection string for this type.\n   std::string\n@@ -889,7 +891,7 @@ class Type\n \n   // Finalize the methods for a type.\n   static void\n-  finalize_methods(Gogo*, const Type*, source_location, Methods**);\n+  finalize_methods(Gogo*, const Type*, Location, Methods**);\n \n   // Return a method from a set of methods.\n   static Method*\n@@ -1061,16 +1063,16 @@ class Type\n   // Build stub methods for a type.\n   static void\n   build_stub_methods(Gogo*, const Type* type, const Methods* methods,\n-\t\t     source_location);\n+\t\t     Location);\n \n   static void\n   build_one_stub_method(Gogo*, Method*, const char* receiver_name,\n \t\t\tconst Typed_identifier_list*, bool is_varargs,\n-\t\t\tsource_location);\n+\t\t\tLocation);\n \n   static Expression*\n   apply_field_indexes(Expression*, const Method::Field_indexes*,\n-\t\t      source_location);\n+\t\t      Location);\n \n   // Look for a field or method named NAME in TYPE.\n   static bool\n@@ -1129,7 +1131,7 @@ class Typed_identifier\n {\n  public:\n   Typed_identifier(const std::string& name, Type* type,\n-\t\t   source_location location)\n+\t\t   Location location)\n     : name_(name), type_(type), location_(location)\n   { }\n \n@@ -1145,7 +1147,7 @@ class Typed_identifier\n \n   // Return the location where the name was seen.  This is not always\n   // meaningful.\n-  source_location\n+  Location\n   location() const\n   { return this->location_; }\n \n@@ -1163,7 +1165,7 @@ class Typed_identifier\n   // Type.\n   Type* type_;\n   // The location where the name was seen.\n-  source_location location_;\n+  Location location_;\n };\n \n // A list of Typed_identifiers.\n@@ -1240,7 +1242,8 @@ class Typed_identifier_list\n   resize(size_t c)\n   {\n     go_assert(c <= this->entries_.size());\n-    this->entries_.resize(c, Typed_identifier(\"\", NULL, UNKNOWN_LOCATION));\n+    this->entries_.resize(c, Typed_identifier(\"\", NULL,\n+                                              Linemap::unknown_location()));\n   }\n \n   // Iterators.\n@@ -1524,7 +1527,7 @@ class Function_type : public Type\n {\n  public:\n   Function_type(Typed_identifier* receiver, Typed_identifier_list* parameters,\n-\t\tTyped_identifier_list* results, source_location location)\n+\t\tTyped_identifier_list* results, Location location)\n     : Type(TYPE_FUNCTION),\n       receiver_(receiver), parameters_(parameters), results_(results),\n       location_(location), is_varargs_(false), is_builtin_(false)\n@@ -1556,7 +1559,7 @@ class Function_type : public Type\n   { return this->is_builtin_; }\n \n   // The location where this type was defined.\n-  source_location\n+  Location\n   location() const\n   { return this->location_; }\n \n@@ -1659,7 +1662,7 @@ class Function_type : public Type\n   // The location where this type was defined.  This exists solely to\n   // give a location for the fields of the struct if this function\n   // returns multiple values.\n-  source_location location_;\n+  Location location_;\n   // Whether this function takes a variable number of arguments.\n   bool is_varargs_;\n   // Whether this is a special builtin function which can not simply\n@@ -1742,7 +1745,7 @@ class Struct_field\n   { return this->typed_identifier_.type(); }\n \n   // The field location.\n-  source_location\n+  Location\n   location() const\n   { return this->typed_identifier_.location(); }\n \n@@ -1845,7 +1848,7 @@ class Struct_field_list\n class Struct_type : public Type\n {\n  public:\n-  Struct_type(Struct_field_list* fields, source_location location)\n+  Struct_type(Struct_field_list* fields, Location location)\n     : Type(TYPE_STRUCT),\n       fields_(fields), location_(location), all_methods_(NULL)\n   { }\n@@ -1882,7 +1885,7 @@ class Struct_type : public Type\n   // NULL if there is no field with that name.\n   Field_reference_expression*\n   field_reference(Expression* struct_expr, const std::string& name,\n-\t\t  source_location) const;\n+\t\t  Location) const;\n \n   // Return the total number of fields, including embedded fields.\n   // This is the number of values which can appear in a conversion to\n@@ -1979,13 +1982,13 @@ class Struct_type : public Type\n \n   Field_reference_expression*\n   field_reference_depth(Expression* struct_expr, const std::string& name,\n-\t\t\tsource_location, Saw_named_type*,\n+\t\t\tLocation, Saw_named_type*,\n \t\t\tunsigned int* depth) const;\n \n   // The fields of the struct.\n   Struct_field_list* fields_;\n   // The place where the struct was declared.\n-  source_location location_;\n+  Location location_;\n   // If this struct is unnamed, a list of methods.\n   Methods* all_methods_;\n };\n@@ -2106,7 +2109,7 @@ class Array_type : public Type\n class Map_type : public Type\n {\n  public:\n-  Map_type(Type* key_type, Type* val_type, source_location location)\n+  Map_type(Type* key_type, Type* val_type, Location location)\n     : Type(TYPE_MAP),\n       key_type_(key_type), val_type_(val_type), location_(location)\n   { }\n@@ -2139,7 +2142,7 @@ class Map_type : public Type\n   // The location is the location which causes us to need the\n   // descriptor.\n   tree\n-  map_descriptor_pointer(Gogo* gogo, source_location);\n+  map_descriptor_pointer(Gogo* gogo, Location);\n \n  protected:\n   int\n@@ -2184,7 +2187,7 @@ class Map_type : public Type\n   // The value type.\n   Type* val_type_;\n   // Where the type was defined.\n-  source_location location_;\n+  Location location_;\n };\n \n // The type of a channel.\n@@ -2267,13 +2270,13 @@ class Channel_type : public Type\n class Interface_type : public Type\n {\n  public:\n-  Interface_type(Typed_identifier_list* methods, source_location location)\n+  Interface_type(Typed_identifier_list* methods, Location location)\n     : Type(TYPE_INTERFACE),\n       methods_(methods), location_(location)\n   { go_assert(methods == NULL || !methods->empty()); }\n \n   // The location where the interface type was defined.\n-  source_location\n+  Location\n   location() const\n   { return this->location_; }\n \n@@ -2368,7 +2371,7 @@ class Interface_type : public Type\n   // NULL for the empty interface.\n   Typed_identifier_list* methods_;\n   // The location where the interface was defined.\n-  source_location location_;\n+  Location location_;\n };\n \n // The value we keep for a named type.  This lets us get the right\n@@ -2380,7 +2383,7 @@ class Interface_type : public Type\n class Named_type : public Type\n {\n  public:\n-  Named_type(Named_object* named_object, Type* type, source_location location)\n+  Named_type(Named_object* named_object, Type* type, Location location)\n     : Type(TYPE_NAMED),\n       named_object_(named_object), in_function_(NULL), type_(type),\n       local_methods_(NULL), all_methods_(NULL),\n@@ -2436,7 +2439,7 @@ class Named_type : public Type\n   { return this->type_; }\n \n   // Return the location.\n-  source_location\n+  Location\n   location() const\n   { return this->location_; }\n \n@@ -2458,7 +2461,7 @@ class Named_type : public Type\n   // Whether this is a builtin type.\n   bool\n   is_builtin() const\n-  { return this->location_ == BUILTINS_LOCATION; }\n+  { return Linemap::is_predeclared_location(this->location_); }\n \n   // Whether this is a circular type: a pointer or function type that\n   // refers to itself, which is not possible in C.\n@@ -2484,7 +2487,7 @@ class Named_type : public Type\n   // Add a method declaration to this type.\n   Named_object*\n   add_method_declaration(const std::string& name, Package* package,\n-\t\t\t Function_type* type, source_location location);\n+\t\t\t Function_type* type, Location location);\n \n   // Add an existing method--one defined before the type itself was\n   // defined--to a type.\n@@ -2617,7 +2620,7 @@ class Named_type : public Type\n   // tables for pointers to this type.\n   Interface_method_tables* pointer_interface_method_tables_;\n   // The location where this type was defined.\n-  source_location location_;\n+  Location location_;\n   // The backend representation of this type during backend\n   // conversion.  This is used to avoid endless recursion when a named\n   // type refers to itself.\n@@ -2691,7 +2694,7 @@ class Forward_declaration_type : public Type\n   // Add a method declaration to this type.\n   Named_object*\n   add_method_declaration(const std::string& name, Function_type*,\n-\t\t\t source_location);\n+\t\t\t Location);\n \n  protected:\n   int"}, {"sha": "eb9462e3693252e6abd40621953f464db72d89f1", "filename": "gcc/go/gofrontend/unsafe.cc", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Funsafe.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8afa2bfbdc60088acd7f199245244890a6e7773e/gcc%2Fgo%2Fgofrontend%2Funsafe.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Funsafe.cc?ref=8afa2bfbdc60088acd7f199245244890a6e7773e", "patch": "@@ -15,9 +15,9 @@\n \n void\n Gogo::import_unsafe(const std::string& local_name, bool is_local_name_exported,\n-\t\t    source_location location)\n+\t\t    Location location)\n {\n-  location_t bloc = BUILTINS_LOCATION;\n+  Location bloc = Linemap::predeclared_location();\n \n   bool add_to_globals;\n   Package* package = this->add_imported_package(\"unsafe\", local_name,\n@@ -41,7 +41,8 @@ Gogo::import_unsafe(const std::string& local_name, bool is_local_name_exported,\n   if (no == NULL)\n     {\n       Type* type = Type::make_pointer_type(Type::make_void_type());\n-      no = bindings->add_type(\"Pointer\", package, type, UNKNOWN_LOCATION);\n+      no = bindings->add_type(\"Pointer\", package, type,\n+\t\t\t      Linemap::unknown_location());\n     }\n   else\n     {"}]}