{"sha": "f86b266c7cc7e5704f3e6f3260cde43c511bb178", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjg2YjI2NmM3Y2M3ZTU3MDRmM2U2ZjMyNjBjZGU0M2M1MTFiYjE3OA==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2012-01-13T21:49:14Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2012-01-13T21:49:14Z"}, "message": "hashtable_policy.h (_Hash_node_base): New, use it as base class of ...\n\n2012-01-13  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n\n\t* include/bits/hashtable_policy.h (_Hash_node_base): New, use it as\n\tbase class of ...\n\t(_Hash_node<Value, true>, _Hash_node<Value, false>): ... those.\n\t* include/bits/hashtable.h (_Hashtable): Replace _M_begin_bucket_index\n\tby _M_before_begin. Review implementation so that we do not need to\n\tlook for previous non-empty bucket when inserting nodes.\n\nFrom-SVN: r183164", "tree": {"sha": "53fdf334bc1d89eb3b147a5d8771a60e2a463b07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53fdf334bc1d89eb3b147a5d8771a60e2a463b07"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f86b266c7cc7e5704f3e6f3260cde43c511bb178", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f86b266c7cc7e5704f3e6f3260cde43c511bb178", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f86b266c7cc7e5704f3e6f3260cde43c511bb178", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f86b266c7cc7e5704f3e6f3260cde43c511bb178/comments", "author": null, "committer": null, "parents": [{"sha": "d6430d9a0c02cac4655cedd1e489ad1ea08dffb2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6430d9a0c02cac4655cedd1e489ad1ea08dffb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6430d9a0c02cac4655cedd1e489ad1ea08dffb2"}], "stats": {"total": 553, "additions": 230, "deletions": 323}, "files": [{"sha": "fa87445d078f9dbe6df378c6f2287b3858970cf5", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f86b266c7cc7e5704f3e6f3260cde43c511bb178/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f86b266c7cc7e5704f3e6f3260cde43c511bb178/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=f86b266c7cc7e5704f3e6f3260cde43c511bb178", "patch": "@@ -1,3 +1,12 @@\n+2012-01-13  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n+\n+\t* include/bits/hashtable_policy.h (_Hash_node_base): New, use it as\n+\tbase class of ...\n+\t(_Hash_node<Value, true>, _Hash_node<Value, false>): ... those.\n+\t* include/bits/hashtable.h (_Hashtable): Replace _M_begin_bucket_index\n+\tby _M_before_begin. Review implementation so that we do not need to\n+\tlook for previous non-empty bucket when inserting nodes.\n+\n 2012-01-09  Kai Tietz  <ktietz@redhat.com>\n \n \tPR libstc++/51673 part 2"}, {"sha": "37672a26b6f63df5502928f5e8a7cc9f1133b739", "filename": "libstdc++-v3/include/bits/hashtable.h", "status": "modified", "additions": 198, "deletions": 312, "changes": 510, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f86b266c7cc7e5704f3e6f3260cde43c511bb178/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f86b266c7cc7e5704f3e6f3260cde43c511bb178/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h?ref=f86b266c7cc7e5704f3e6f3260cde43c511bb178", "patch": "@@ -93,50 +93,48 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   // and unordered_multimap.\n   /**\n    * Here's _Hashtable data structure, each _Hashtable has:\n-   * - _Bucket[]     _M_buckets\n-   * - size_type     _M_bucket_count\n-   * - size_type     _M_begin_bucket_index\n-   * - size_type     _M_element_count\n+   * - _Bucket[]       _M_buckets\n+   * - _Hash_node_base _M_before_begin\n+   * - size_type       _M_bucket_count\n+   * - size_type       _M_element_count\n    *\n-   * with _Bucket being _Node* and _Node:\n-   * - _Node*        _M_next\n+   * with _Bucket being _Hash_node* and _Hash_node constaining:\n+   * - _Hash_node*   _M_next\n    * - Tp            _M_value\n    * - size_t        _M_code if cache_hash_code is true\n    *\n    * In terms of Standard containers the hastable is like the aggregation of:\n    * - std::forward_list<_Node> containing the elements\n    * - std::vector<std::forward_list<_Node>::iterator> representing the buckets\n    *\n-   * The first non-empty bucket with index _M_begin_bucket_index contains the\n-   * first container node which is also the first bucket node whereas other\n-   * non-empty buckets contain the node before the first bucket node. This is so\n-   * to implement something like a std::forward_list::erase_after on container\n-   * erase calls.\n+   * The non-empty buckets contain the node before the first bucket node. This\n+   * design allow to implement something like a std::forward_list::insert_after\n+   * on container insertion and std::forward_list::erase_after on container\n+   * erase calls. _M_before_begin is equivalent to\n+   * std::foward_list::before_begin. Empty buckets are containing nullptr.\n+   * Note that one of the non-empty bucket contains &_M_before_begin which is\n+   * not a derefenrenceable node so the node pointers in buckets shall never be\n+   * derefenrenced, only its next node can be.\n    * \n-   * Access to the bucket last element require a check on the hash code to see\n-   * if the node is still in the bucket. Such a design impose a quite efficient\n-   * hash functor and is one of the reasons it is highly advise to set\n+   * Walk through a bucket nodes require a check on the hash code to see if the\n+   * node is still in the bucket. Such a design impose a quite efficient hash\n+   * functor and is one of the reasons it is highly advise to set\n    * __cache_hash_code to true.\n    *\n    * The container iterators are simply built from nodes. This way incrementing\n-   * the iterator is perfectly efficient no matter how many empty buckets there\n-   * are in the container.\n+   * the iterator is perfectly efficient independent of how many empty buckets\n+   * there are in the container.\n    *\n    * On insert we compute element hash code and thanks to it find the bucket\n-   * index. If the element is the first one in the bucket we must find the\n-   * previous non-empty bucket where the previous node rely. To keep this loop\n-   * minimal it is important that the number of bucket is not too high compared\n-   * to the number of elements. So the hash policy must be carefully design so\n-   * that it computes a bucket count large enough to respect the user defined\n-   * load factor but also not too large to limit impact on the insert operation.\n+   * index. If the element must be inserted on an empty bucket we add it at the\n+   * beginning of the singly linked list and make the bucket point to\n+   * _M_before_begin. The bucket that used to point to _M_before_begin, if any,\n+   * is updated to point to its new before begin node.\n    *\n    * On erase, the simple iterator design impose to use the hash functor to get\n    * the index of the bucket to update. For this reason, when __cache_hash_code\n    * is set to false, there is a static assertion that the hash functor cannot\n    * throw.\n-   *\n-   * _M_begin_bucket_index is used to offer contant time access to the container\n-   * begin iterator.\n    */\n \n   template<typename _Key, typename _Value, typename _Allocator,\n@@ -182,6 +180,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tusing __if_hash_code_not_cached\n \t  = __or_<integral_constant<bool, __cache_hash_code>, _Cond>;\n \n+      // When hash codes are not cached the hash functor shall not throw\n+      // because it is used in methods (erase, swap...) that shall not throw.\n       static_assert(__if_hash_code_not_cached<__detail::__is_noexcept_hash<_Key,\n \t\t\t\t\t\t\t\t_H1>>::value,\n       \t    \"Cache the hash code or qualify your hash functor with noexcept\");\n@@ -246,19 +246,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef __detail::_Hash_node<_Value, __cache_hash_code> _Node;\n       typedef typename _Allocator::template rebind<_Node>::other\n \t\t\t\t\t\t\t_Node_allocator_type;\n-      typedef _Node* _Bucket;\n+      typedef __detail::_Hash_node_base _BaseNode;\n+      typedef _BaseNode* _Bucket;\n       typedef typename _Allocator::template rebind<_Bucket>::other\n \t\t\t\t\t\t\t_Bucket_allocator_type;\n \n       typedef typename _Allocator::template rebind<_Value>::other\n \t\t\t\t\t\t\t_Value_allocator_type;\n \n-      _Node_allocator_type   _M_node_allocator;\n-      _Bucket*               _M_buckets;\n-      size_type              _M_bucket_count;\n-      size_type              _M_begin_bucket_index; // First non-empty bucket.\n-      size_type              _M_element_count;\n-      _RehashPolicy          _M_rehash_policy;\n+      _Node_allocator_type\t_M_node_allocator;\n+      _Bucket*\t\t\t_M_buckets;\n+      size_type\t\t\t_M_bucket_count;\n+      _BaseNode\t\t\t_M_before_begin;\n+      size_type\t\t\t_M_element_count;\n+      _RehashPolicy\t\t_M_rehash_policy;\n \n       template<typename... _Args>\n \t_Node*\n@@ -277,15 +278,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       void\n       _M_deallocate_buckets(_Bucket*, size_type __n);\n \n-      // Gets bucket begin dealing with the difference between first non-empty\n-      // bucket containing the first container node and the other non-empty\n-      // buckets containing the node before the one belonging to the bucket.\n+      // Gets bucket begin, deals with the fact that non-empty buckets contain\n+      // their before begin node.\n       _Node*\n       _M_bucket_begin(size_type __bkt) const;\n \n-      // Gets the bucket last node if any\n       _Node*\n-      _M_bucket_end(size_type __bkt) const;\n+      _M_begin() const\n+      { return static_cast<_Node*>(_M_before_begin._M_nxt); }\n \n     public:\n       // Constructor, destructor, assignment, swap\n@@ -330,11 +330,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       // Basic container operations\n       iterator\n       begin() noexcept\n-      { return iterator(_M_buckets[_M_begin_bucket_index]); }\n+      { return iterator(_M_begin()); }\n \n       const_iterator\n       begin() const noexcept\n-      { return const_iterator(_M_buckets[_M_begin_bucket_index]); }\n+      { return const_iterator(_M_begin()); }\n \n       iterator\n       end() noexcept\n@@ -346,7 +346,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       const_iterator\n       cbegin() const noexcept\n-      { return const_iterator(_M_buckets[_M_begin_bucket_index]); }\n+      { return const_iterator(_M_begin()); }\n \n       const_iterator\n       cend() const noexcept\n@@ -454,6 +454,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       equal_range(const key_type& __k) const;\n \n     private:\n+      // Bucket index computation helpers.\n       size_type\n       _M_bucket_index(_Node* __n) const\n       { return _HCBase::_M_bucket_index(__n, _M_bucket_count); }\n@@ -464,26 +465,33 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       { return _HCBase::_M_bucket_index(__k, __c, _M_bucket_count); }\n \n       // Find and insert helper functions and types\n+      // Find the node before the one matching the criteria.\n+      _BaseNode*\n+      _M_find_before_node(size_type, const key_type&,\n+\t\t\t  typename _Hashtable::_Hash_code_type) const;\n+\n       _Node*\n-      _M_find_node(size_type, const key_type&,\n-\t\t   typename _Hashtable::_Hash_code_type) const;\n+      _M_find_node(size_type __bkt, const key_type& __key,\n+\t\t   typename _Hashtable::_Hash_code_type __c) const\n+      {\n+\t_BaseNode* __before_n = _M_find_before_node(__bkt, __key, __c);\n+\tif (__before_n)\n+\t  return static_cast<_Node*>(__before_n->_M_nxt);\n+\treturn nullptr;\n+      }\n \n-      // Insert a node in an empty bucket\n+      // Insert a node at the beginning of a bucket.\n       void\n       _M_insert_bucket_begin(size_type, _Node*);\n \n-      // Insert a node after an other one in a non-empty bucket\n-      void\n-      _M_insert_after(size_type, _Node*, _Node*);\n-\n       // Remove the bucket first node\n       void\n       _M_remove_bucket_begin(size_type __bkt, _Node* __next_n,\n \t\t\t     size_type __next_bkt);\n \n       // Get the node before __n in the bucket __bkt\n-      _Node*\n-      _M_get_previous_node(size_type __bkt, _Node* __n);\n+      _BaseNode*\n+      _M_get_previous_node(size_type __bkt, _BaseNode* __n);\n \n       template<typename _Arg>\n \titerator\n@@ -645,7 +653,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       while (__n)\n \t{\n \t  _Node* __tmp = __n;\n-\t  __n = __n->_M_next;\n+\t  __n = __n->_M_next();\n \t  _M_deallocate_node(__tmp);\n \t}\n     }\n@@ -663,10 +671,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n       _Bucket_allocator_type __alloc(_M_node_allocator);\n \n-      // We allocate one extra bucket to have _M_begin_bucket_index\n-      // point to it as long as container is empty\n-      _Bucket* __p = __alloc.allocate(__n + 1);\n-      __builtin_memset(__p, 0, (__n + 1) * sizeof(_Bucket));\n+      _Bucket* __p = __alloc.allocate(__n);\n+      __builtin_memset(__p, 0, __n * sizeof(_Bucket));\n       return __p;\n     }\n \n@@ -680,7 +686,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _M_deallocate_buckets(_Bucket* __p, size_type __n)\n     {\n       _Bucket_allocator_type __alloc(_M_node_allocator);\n-      __alloc.deallocate(__p, __n + 1);\n+      __alloc.deallocate(__p, __n);\n     }\n \n   template<typename _Key, typename _Value,\n@@ -694,29 +700,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n     _M_bucket_begin(size_type __bkt) const\n     {\n-      if (__bkt == _M_begin_bucket_index)\n-\treturn _M_buckets[__bkt];\n-      _Node* __n = _M_buckets[__bkt];\n-      return __n ? __n->_M_next : nullptr;\n-    }\n-\n-  template<typename _Key, typename _Value,\n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey,\n-\t\t\t_Equal, _H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t__chc, __cit, __uk>::_Node*\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    _M_bucket_end(size_type __bkt) const\n-    {\n-      _Node* __n = _M_bucket_begin(__bkt);\n-      if (__n)\n-\tfor (;; __n = __n->_M_next)\n-\t  if (!__n->_M_next || _M_bucket_index(__n->_M_next) != __bkt)\n-\t    break;\n-      return __n;\n+      _BaseNode* __n = _M_buckets[__bkt];\n+      return __n ? static_cast<_Node*>(__n->_M_nxt) : nullptr;\n     }\n \n   template<typename _Key, typename _Value,\n@@ -744,7 +729,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       // on the first insertion so we need to reset its previous resize level.\n       _M_rehash_policy._M_prev_resize = 0;\n       _M_buckets = _M_allocate_buckets(_M_bucket_count);\n-      _M_begin_bucket_index = _M_bucket_count;\n     }\n \n   template<typename _Key, typename _Value,\n@@ -779,7 +763,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t// level.\n \t_M_rehash_policy._M_prev_resize = 0;\n \t_M_buckets = _M_allocate_buckets(_M_bucket_count);\n-\t_M_begin_bucket_index = _M_bucket_count;\n \t__try\n \t  {\n \t    for (; __f != __l; ++__f)\n@@ -806,48 +789,34 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       __detail::_Map_base<_Key, _Value, _ExtractKey, __uk, _Hashtable>(__ht),\n       _M_node_allocator(__ht._M_node_allocator),\n       _M_bucket_count(__ht._M_bucket_count),\n-      _M_begin_bucket_index(__ht._M_begin_bucket_index),\n       _M_element_count(__ht._M_element_count),\n       _M_rehash_policy(__ht._M_rehash_policy)\n     {\n       _M_buckets = _M_allocate_buckets(_M_bucket_count);\n       __try\n \t{\n-\t  const _Node* __ht_n = __ht._M_buckets[__ht._M_begin_bucket_index];\n-\t  if (!__ht_n)\n+\t  if (!__ht._M_before_begin._M_nxt)\n \t    return;\n \n-\t  // Note that the copy constructor do not rely on hash code usage.\n-\t  // First deal with the special first node that is directly store in\n-\t  // the first non-empty bucket\n+\t  // First deal with the special first node pointed to by\n+\t  // _M_before_begin.\n+\t  const _Node* __ht_n = __ht._M_begin();\n \t  _Node* __this_n = _M_allocate_node(__ht_n->_M_v);\n \t  this->_M_copy_code(__this_n, __ht_n);\n-\t  _M_buckets[_M_begin_bucket_index] = __this_n;\n-\t  __ht_n = __ht_n->_M_next;\n-\t  // Second deal with following non-empty buckets containing previous\n-\t  // nodes node.\n-\t  for (size_type __i = __ht._M_begin_bucket_index + 1;\n-\t       __i != __ht._M_bucket_count; ++__i)\n-\t    {\n-\t      if (!__ht._M_buckets[__i])\n-\t\tcontinue;\n+\t  _M_before_begin._M_nxt = __this_n;\n+\t  _M_buckets[_M_bucket_index(__this_n)] = &_M_before_begin;\n \n-\t      for (; __ht_n != __ht._M_buckets[__i]->_M_next;\n-\t\t   __ht_n = __ht_n->_M_next)\n-\t\t{\n-\t\t  __this_n->_M_next = _M_allocate_node(__ht_n->_M_v);\n-\t\t  this->_M_copy_code(__this_n->_M_next, __ht_n);\n-\t\t  __this_n = __this_n->_M_next;\n-\t\t}\n-\n-\t      _M_buckets[__i] = __this_n;\n-\t    }\n-\t  // Last finalize copy of the nodes of the last non-empty bucket\n-\t  for (; __ht_n; __ht_n = __ht_n->_M_next)\n+\t  // Then deal with other nodes.\n+\t  _BaseNode* __prev_n = __this_n;\n+\t  for (__ht_n = __ht_n->_M_next(); __ht_n; __ht_n = __ht_n->_M_next())\n \t    {\n-\t      __this_n->_M_next = _M_allocate_node(__ht_n->_M_v);\n-\t      this->_M_copy_code(__this_n->_M_next, __ht_n);\n-\t      __this_n = __this_n->_M_next;\n+\t      __this_n = _M_allocate_node(__ht_n->_M_v);\n+\t      __prev_n->_M_nxt = __this_n;\n+\t      this->_M_copy_code(__this_n, __ht_n);\n+\t      size_type __bkt = _M_bucket_index(__this_n);\n+\t      if (!_M_buckets[__bkt])\n+\t\t_M_buckets[__bkt] = __prev_n;\n+\t      __prev_n = __this_n;\n \t    }\n \t}\n       __catch(...)\n@@ -872,14 +841,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_node_allocator(std::move(__ht._M_node_allocator)),\n       _M_buckets(__ht._M_buckets),\n       _M_bucket_count(__ht._M_bucket_count),\n-      _M_begin_bucket_index(__ht._M_begin_bucket_index),\n+      _M_before_begin(__ht._M_before_begin._M_nxt),\n       _M_element_count(__ht._M_element_count),\n       _M_rehash_policy(__ht._M_rehash_policy)\n     {\n+      // Update, if necessary, bucket pointing to before begin that hasn't move.\n+      if (_M_begin())\n+\t_M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin;\n       __ht._M_rehash_policy = _RehashPolicy();\n       __ht._M_bucket_count = __ht._M_rehash_policy._M_next_bkt(0);\n       __ht._M_buckets = __ht._M_allocate_buckets(__ht._M_bucket_count);\n-      __ht._M_begin_bucket_index = __ht._M_bucket_count;\n+      __ht._M_before_begin._M_nxt = nullptr;\n       __ht._M_element_count = 0;\n     }\n \n@@ -917,8 +889,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       std::swap(_M_rehash_policy, __x._M_rehash_policy);\n       std::swap(_M_buckets, __x._M_buckets);\n       std::swap(_M_bucket_count, __x._M_bucket_count);\n-      std::swap(_M_begin_bucket_index, __x._M_begin_bucket_index);\n+      std::swap(_M_before_begin._M_nxt, __x._M_before_begin._M_nxt);\n       std::swap(_M_element_count, __x._M_element_count);\n+      // Fix buckets containing the _M_before_begin pointers that can't be\n+      // swapped.\n+      if (_M_begin())\n+\t_M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin;\n+      if (__x._M_begin())\n+\t__x._M_buckets[__x._M_bucket_index(__x._M_begin())]\n+\t  = &(__x._M_before_begin);\n     }\n \n   template<typename _Key, typename _Value,\n@@ -988,7 +967,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \treturn 0;\n \n       std::size_t __result = 0;\n-      for (;; __p = __p->_M_next)\n+      for (;; __p = __p->_M_next())\n \t{\n \t  if (this->_M_equals(__k, __code, __p))\n \t    ++__result;\n@@ -997,7 +976,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    // equivalent value after an equivalent one it means that we won't\n \t    // find anymore an equivalent value.\n \t    break;\n-\t  if (!__p->_M_next || _M_bucket_index(__p->_M_next) != __n)\n+\t  if (!__p->_M_nxt || _M_bucket_index(__p->_M_next()) != __n)\n \t    break;\n \t}\n       return __result;\n@@ -1025,10 +1004,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       if (__p)\n \t{\n-\t  _Node* __p1 = __p->_M_next;\n+\t  _Node* __p1 = __p->_M_next();\n \t  while (__p1 && _M_bucket_index(__p1) == __n\n \t\t && this->_M_equals(__k, __code, __p1))\n-\t    __p1 = __p1->_M_next;\n+\t    __p1 = __p1->_M_next();\n \n \t  return std::make_pair(iterator(__p), iterator(__p1));\n \t}\n@@ -1058,10 +1037,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       if (__p)\n \t{\n-\t  _Node* __p1 = __p->_M_next;\n+\t  _Node* __p1 = __p->_M_next();\n \t  while (__p1 && _M_bucket_index(__p1) == __n\n \t\t && this->_M_equals(__k, __code, __p1))\n-\t    __p1 = __p1->_M_next;\n+\t    __p1 = __p1->_M_next();\n \n \t  return std::make_pair(const_iterator(__p), const_iterator(__p1));\n \t}\n@@ -1077,21 +1056,23 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t   bool __chc, bool __cit, bool __uk>\n     typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey,\n \t\t\t_Equal, _H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t__chc, __cit, __uk>::_Node*\n+\t\t\t__chc, __cit, __uk>::_BaseNode*\n     _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n \t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    _M_find_node(size_type __n, const key_type& __k,\n-\t\ttypename _Hashtable::_Hash_code_type __code) const\n+    _M_find_before_node(size_type __n, const key_type& __k,\n+\t\t\ttypename _Hashtable::_Hash_code_type __code) const\n     {\n-      _Node* __p = _M_bucket_begin(__n);\n-      if (!__p)\n+      _BaseNode* __prev_p = _M_buckets[__n];\n+      if (!__prev_p)\n \treturn nullptr;\n-      for (;; __p = __p->_M_next)\n+      _Node* __p = static_cast<_Node*>(__prev_p->_M_nxt);\n+      for (;; __p = __p->_M_next())\n \t{\n \t  if (this->_M_equals(__k, __code, __p))\n-\t    return __p;\n-\t  if (!(__p->_M_next) || _M_bucket_index(__p->_M_next) != __n)\n+\t    return __prev_p;\n+\t  if (!(__p->_M_nxt) || _M_bucket_index(__p->_M_next()) != __n)\n \t    break;\n+\t  __prev_p = __p;\n \t}\n       return nullptr;\n     }\n@@ -1105,53 +1086,26 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n     _M_insert_bucket_begin(size_type __bkt, _Node* __new_node)\n     {\n-      _Node* __prev_n;\n-      if (__bkt < _M_begin_bucket_index)\n+      if (_M_buckets[__bkt])\n \t{\n-\t  if (_M_begin_bucket_index != _M_bucket_count)\n-\t    {\n-\t      __new_node->_M_next = _M_buckets[_M_begin_bucket_index];\n-\t      _M_buckets[_M_begin_bucket_index] = __new_node;\n-\t    }\n-\t  __prev_n = __new_node;\n-\t  _M_begin_bucket_index = __bkt;\n+\t  // Bucket is not empty, we just need to insert the new node after the\n+\t  // bucket before begin.\n+\t  __new_node->_M_nxt = _M_buckets[__bkt]->_M_nxt;\n+\t  _M_buckets[__bkt]->_M_nxt = __new_node;\n \t}\n       else\n \t{\n-\t  // We need to find previous non-empty bucket to link the new node.\n-\t  // There are several ways to find this previous bucket:\n-\t  // 1. Move backward until we find it (the current method)\n-\t  // 2. Start from the begin bucket index and move forward until we\n-\t  // cross __n position.\n-\t  // 3. Move forward until we find a non-empty bucket that will\n-\t  // contain the previous node.\n-\t  size_type __prev_bkt;\n-\t  for (__prev_bkt = __bkt; __prev_bkt-- != 0;)\n-\t    if (_M_buckets[__prev_bkt])\n-\t      break;\n-\t  __prev_n = _M_bucket_end(__prev_bkt);\n-\t  _M_insert_after(__prev_bkt, __prev_n, __new_node);\n-\t}\n-      _M_buckets[__bkt] = __prev_n;\n-    }\n-\n-  template<typename _Key, typename _Value,\n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    void\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    _M_insert_after(size_type __bkt, _Node* __prev_n, _Node* __new_n)\n-    {\n-      if (__prev_n->_M_next)\n-\t{\n-\t  size_type __next_bkt = _M_bucket_index(__prev_n->_M_next);\n-\t  if (__next_bkt != __bkt)\n-\t    _M_buckets[__next_bkt] = __new_n;\n+\t  // The bucket is empty, the new node is inserted at the beginning of\n+\t  // the singly linked list and the bucket will contain _M_before_begin\n+\t  // pointer.\n+\t  __new_node->_M_nxt = _M_before_begin._M_nxt;\n+\t  _M_before_begin._M_nxt = __new_node;\n+\t  if (__new_node->_M_nxt)\n+\t    // We must update former begin bucket that is pointing to\n+\t    // _M_before_begin.\n+\t    _M_buckets[_M_bucket_index(__new_node->_M_next())] = __new_node;\n+\t  _M_buckets[__bkt] = &_M_before_begin;\n \t}\n-      __new_n->_M_next = __prev_n->_M_next;\n-      __prev_n->_M_next = __new_n;\n     }\n \n   template<typename _Key, typename _Value,\n@@ -1166,22 +1120,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       if (!__next || __next_bkt != __bkt)\n \t{\n \t  // Bucket is now empty\n-\t  if (__next && __next_bkt != __bkt)\n-\t    // Update next non-empty bucket before begin node\n+\t  // First update next bucket if any\n+\t  if (__next)\n \t    _M_buckets[__next_bkt] = _M_buckets[__bkt];\n+\t  // Second update before begin node if necessary\n+\t  if (&_M_before_begin == _M_buckets[__bkt])\n+\t    _M_before_begin._M_nxt = __next;\n \t  _M_buckets[__bkt] = nullptr;\n-\t  if (__bkt == _M_begin_bucket_index)\n-\t    // We need to update begin bucket index\n-\t    if (__next)\n-\t      {\n-\t\t_M_begin_bucket_index = __next_bkt;\n-\t\t_M_buckets[_M_begin_bucket_index] = __next;\n-\t      }\n-\t    else\n-\t      _M_begin_bucket_index = _M_bucket_count;\n \t}\n-      else if (__bkt == _M_begin_bucket_index)\n-\t_M_buckets[__bkt] = __next;\n     }\n \n   template<typename _Key, typename _Value,\n@@ -1190,18 +1136,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t   bool __chc, bool __cit, bool __uk>\n     typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey,\n \t\t\t_Equal, _H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t__chc, __cit, __uk>::_Node*\n+\t\t\t__chc, __cit, __uk>::_BaseNode*\n     _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n \t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    _M_get_previous_node(size_type __bkt, _Node* __n)\n+    _M_get_previous_node(size_type __bkt, _BaseNode* __n)\n     {\n-      _Node* __prev_n = nullptr;\n-      if (__bkt != _M_begin_bucket_index || __n != _M_buckets[__bkt])\n-\t{\n-\t  __prev_n = _M_buckets[__bkt];\n-\t  while (__prev_n->_M_next != __n)\n-\t    __prev_n = __prev_n->_M_next;\n-\t}\n+      _BaseNode* __prev_n = _M_buckets[__bkt];\n+      while (__prev_n->_M_nxt != __n)\n+\t__prev_n = __prev_n->_M_nxt;\n       return __prev_n;\n     }\n \n@@ -1248,10 +1190,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t__bkt = _M_bucket_index(__k, __code);\n \t      }\n \n-\t    if (_M_buckets[__bkt])\n-\t      _M_insert_after(__bkt, _M_buckets[__bkt], __new_node);\n-\t    else \n-\t      _M_insert_bucket_begin(__bkt, __new_node);\n+\t    _M_insert_bucket_begin(__bkt, __new_node);\n \t    ++_M_element_count;\n \t    return std::make_pair(iterator(__new_node), true);\n \t  }\n@@ -1279,41 +1218,33 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  = _M_rehash_policy._M_need_rehash(_M_bucket_count,\n \t\t\t\t\t    _M_element_count, 1);\n \n-\t// First build the node to get its hash code\n+\t// First build the node to get its hash code.\n \t_Node* __new_node = _M_allocate_node(std::forward<_Args>(__args)...);\n \t__try\n \t  {\n \t    const key_type& __k = this->_M_extract()(__new_node->_M_v);\n \t    typename _Hashtable::_Hash_code_type __code\n \t      = this->_M_hash_code(__k);\n \t    this->_M_store_code(__new_node, __code);\n-\t    size_type __bkt = _M_bucket_index(__k, __code);\n \n-\t    // Second find the node, avoid rehash if compare throws.\n-\t    _Node* __prev = _M_find_node(__bkt, __k, __code);\n-\t    \n+\t    // Second,  do rehash if necessary.\n \t    if (__do_rehash.first)\n-\t      {\n \t\t_M_rehash(__do_rehash.second, __saved_state);\n-\t\t__bkt = _M_bucket_index(__k, __code);\n-\t\t// __prev is still valid because rehash do not invalidate nodes\n-\t      }\n \n+\t    // Third, find the node before an equivalent one.\n+\t    size_type __bkt = _M_bucket_index(__k, __code);\n+\t    _BaseNode* __prev = _M_find_before_node(__bkt, __k, __code);\n+\t    \n \t    if (__prev)\n-\t      // Insert after the previous equivalent node\n-\t      _M_insert_after(__bkt, __prev, __new_node);\n-\t    else if (_M_buckets[__bkt])\n-\t      // Bucket is not empty and the inserted node has no equivalent in\n-\t      // the hashtable. We must insert the new node at the beginning or\n-\t      // end of the bucket to preserve equivalent elements relative\n-\t      // positions.\n-\t      if (__bkt != _M_begin_bucket_index)\n-\t\t// We insert the new node at the beginning\n-\t\t_M_insert_after(__bkt, _M_buckets[__bkt], __new_node);\n-\t      else\n-\t\t// We insert the new node at the end\n-\t\t_M_insert_after(__bkt, _M_bucket_end(__bkt), __new_node);\n+\t      {\n+\t\t// Insert after the node before the equivalent one.\n+\t\t__new_node->_M_nxt = __prev->_M_nxt;\n+\t\t__prev->_M_nxt = __new_node;\n+\t      }\n \t    else\n+\t      // The inserted node has no equivalent in the hashtable. We must\n+\t      // insert the new node at the beginning of the bucket to preserve\n+\t      // equivalent elements relative positions.\n \t      _M_insert_bucket_begin(__bkt, __new_node);\n \t    ++_M_element_count;\n \t    return iterator(__new_node);\n@@ -1360,10 +1291,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    if (__do_rehash.first)\n \t      _M_rehash(__do_rehash.second, __saved_state);\n \n-\t    if (_M_buckets[__n])\n-\t      _M_insert_after(__n, _M_buckets[__n], __new_node);\n-\t    else \n-\t      _M_insert_bucket_begin(__n, __new_node);\n+\t    _M_insert_bucket_begin(__n, __new_node);\n \t    ++_M_element_count;\n \t    return iterator(__new_node);\n \t  }\n@@ -1421,38 +1349,29 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n \tconst key_type& __k = this->_M_extract()(__v);\n \ttypename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n-\tsize_type __n = _M_bucket_index(__k, __code);\n \n-\t// First find the node, avoid leaking new_node if compare throws.\n-\t_Node* __prev = _M_find_node(__n, __k, __code);\n \t_Node* __new_node = nullptr;\n \t__try\n \t  {\n-\t    // Second allocate new node so that we don't rehash if it throws\n+\t    // First allocate new node so that we don't rehash if it throws.\n \t    __new_node = _M_allocate_node(std::forward<_Arg>(__v));\n \t    this->_M_store_code(__new_node, __code);\n \t    if (__do_rehash.first)\n-\t      {\n \t\t_M_rehash(__do_rehash.second, __saved_state);\n-\t\t__n = _M_bucket_index(__k, __code);\n-\t\t// __prev is still valid because rehash do not invalidate nodes\n-\t      }\n \n+\t    // Second, find the node before an equivalent one.\n+\t    size_type __n = _M_bucket_index(__k, __code);\n+\t    _BaseNode* __prev = _M_find_before_node(__n, __k, __code);\n \t    if (__prev)\n-\t      // Insert after the previous equivalent node\n-\t      _M_insert_after(__n, __prev, __new_node);\n-\t    else if (_M_buckets[__n])\n-\t      // Bucket is not empty and the inserted node has no equivalent in\n-\t      // the hashtable. We must insert the new node at the beginning or\n-\t      // end of the bucket to preserve equivalent elements relative\n-\t      // positions.\n-\t      if (__n != _M_begin_bucket_index)\n-\t\t// We insert the new node at the beginning\n-\t\t_M_insert_after(__n, _M_buckets[__n], __new_node);\n-\t      else\n-\t\t// We insert the new node at the end\n-\t\t_M_insert_after(__n, _M_bucket_end(__n), __new_node);\n+\t      {\n+\t\t// Insert after the node before the equivalent one.\n+\t\t__new_node->_M_nxt = __prev->_M_nxt;\n+\t\t__prev->_M_nxt = __new_node;\n+\t      }\n \t    else\n+\t      // The inserted node has no equivalent in the hashtable. We must\n+\t      // insert the new node at the beginning of the bucket to preserve\n+\t      // equivalent elements relative positions.\n \t      _M_insert_bucket_begin(__n, __new_node);\n \t    ++_M_element_count;\n \t    return iterator(__new_node);\n@@ -1504,22 +1423,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       std::size_t __bkt = _M_bucket_index(__n);\n \n       // Look for previous node to unlink it from the erased one, this is why\n-      // we need buckets to contain the before begin node of the bucket to make\n-      // this research fast.\n-      _Node* __prev_n = _M_get_previous_node(__bkt, __n);\n+      // we need buckets to contain the before begin to make this research fast.\n+      _BaseNode* __prev_n = _M_get_previous_node(__bkt, __n);\n       if (__n == _M_bucket_begin(__bkt))\n-\t_M_remove_bucket_begin(__bkt, __n->_M_next,\n-\t   __n->_M_next ? _M_bucket_index(__n->_M_next) : 0);\n-      else if (__n->_M_next)\n+\t_M_remove_bucket_begin(__bkt, __n->_M_next(),\n+\t   __n->_M_nxt ? _M_bucket_index(__n->_M_next()) : 0);\n+      else if (__n->_M_nxt)\n \t{\n-\t  size_type __next_bkt = _M_bucket_index(__n->_M_next);\n+\t  size_type __next_bkt = _M_bucket_index(__n->_M_next());\n \t  if (__next_bkt != __bkt)\n \t    _M_buckets[__next_bkt] = __prev_n;\n \t}\n \n-      if (__prev_n)\n-\t__prev_n->_M_next = __n->_M_next;\n-      iterator __result(__n->_M_next);\n+      __prev_n->_M_nxt = __n->_M_nxt;\n+      iterator __result(__n->_M_next());\n       _M_deallocate_node(__n);\n       --_M_element_count;\n \n@@ -1539,26 +1456,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n       typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n       std::size_t __bkt = _M_bucket_index(__k, __code);\n-      // Look for the first matching node with its previous node at the same\n-      // time\n-      _Node* __n = _M_buckets[__bkt];\n-      if (!__n)\n+      // Look for the node before the first matching node.\n+      _BaseNode* __prev_n = _M_find_before_node(__bkt, __k, __code);\n+      if (!__prev_n)\n \treturn 0;\n-      _Node* __prev_n = nullptr;\n-      if (__bkt != _M_begin_bucket_index)\n-\t{\n-\t  __prev_n = __n;\n-\t  __n = __n->_M_next;\n-\t}\n-      bool __is_bucket_begin = true;\n-      for (;; __prev_n = __n, __n = __n->_M_next)\n-\t{\n-\t  if (this->_M_equals(__k, __code, __n))\n-\t    break;\n-\t  if (!(__n->_M_next) || _M_bucket_index(__n->_M_next) != __bkt)\n-\t    return 0;\n-\t  __is_bucket_begin = false;\n-\t}\n+      _Node* __n = static_cast<_Node*>(__prev_n->_M_nxt);\n+      bool __is_bucket_begin = _M_buckets[__bkt] == __prev_n;\n \n       // We found a matching node, start deallocation loop from it\n       std::size_t __next_bkt = __bkt;\n@@ -1568,7 +1471,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       do\n \t{\n \t  _Node* __p = __next_n;\n-\t  __next_n = __p->_M_next;\n+\t  __next_n = __p->_M_next();\n \t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n \t  // 526. Is it undefined if a function in the standard changes\n \t  // in parameters?\n@@ -1592,7 +1495,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       else if (__next_n && __next_bkt != __bkt)\n \t_M_buckets[__next_bkt] = __prev_n;\n       if (__prev_n)\n-\t__prev_n->_M_next = __next_n;\n+\t__prev_n->_M_nxt = __next_n;\n       return __result;\n     }\n \n@@ -1614,15 +1517,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       std::size_t __bkt = _M_bucket_index(__n);\n \n-      _Node* __prev_n = _M_get_previous_node(__bkt, __n);\n+      _BaseNode* __prev_n = _M_get_previous_node(__bkt, __n);\n       bool __is_bucket_begin = __n == _M_bucket_begin(__bkt);\n       std::size_t __n_bkt = __bkt;\n       for (;;)\n \t{\n \t  do\n \t    {\n \t      _Node* __tmp = __n;\n-\t      __n = __n->_M_next;\n+\t      __n = __n->_M_next();\n \t      _M_deallocate_node(__tmp);\n \t      --_M_element_count;\n \t      if (!__n)\n@@ -1640,8 +1543,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       if (__n && __n_bkt != __bkt)\n \t_M_buckets[__n_bkt] = __prev_n;\n-      if (__prev_n)\n-\t__prev_n->_M_next = __n;\n+      __prev_n->_M_nxt = __n;\n       return iterator(__n);\n     }\n \n@@ -1654,10 +1556,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n     clear() noexcept\n     {\n-      _M_deallocate_nodes(_M_buckets[_M_begin_bucket_index]);\n+      _M_deallocate_nodes(_M_begin());\n       __builtin_memset(_M_buckets, 0, _M_bucket_count * sizeof(_Bucket));\n       _M_element_count = 0;\n-      _M_begin_bucket_index = _M_bucket_count;\n+      _M_before_begin._M_nxt = nullptr;\n     }\n \n   template<typename _Key, typename _Value,\n@@ -1688,45 +1590,29 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       __try\n \t{\n \t  _Bucket* __new_buckets = _M_allocate_buckets(__n);\n-\t  _Node* __p = _M_buckets[_M_begin_bucket_index];\n-\t  // First loop to store each node in its new bucket\n+\t  _Node* __p = _M_begin();\n+\t  _M_before_begin._M_nxt = nullptr;\n+\t  std::size_t __cur_bbegin_bkt;\n \t  while (__p)\n \t    {\n-\t      _Node* __next = __p->_M_next;\n+\t      _Node* __next = __p->_M_next();\n \t      std::size_t __new_index = _HCBase::_M_bucket_index(__p, __n);\n \t      if (!__new_buckets[__new_index])\n-\t\t// Store temporarily bucket end node in _M_buckets if possible.\n-\t\t// This will boost second loop where we need to access bucket\n-\t\t// end node quickly.\n-\t\tif (__new_index < _M_bucket_count)\n-\t\t  _M_buckets[__new_index] = __p;\n-\t      __p->_M_next = __new_buckets[__new_index];\n-\t      __new_buckets[__new_index] = __p;\n+\t\t{\n+\t\t  __p->_M_nxt = _M_before_begin._M_nxt;\n+\t\t  _M_before_begin._M_nxt = __p;\n+\t\t  __new_buckets[__new_index] = &_M_before_begin;\n+\t\t  if (__p->_M_nxt)\n+\t\t    __new_buckets[__cur_bbegin_bkt] = __p;\n+\t\t  __cur_bbegin_bkt = __new_index;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  __p->_M_nxt = __new_buckets[__new_index]->_M_nxt;\n+\t\t  __new_buckets[__new_index]->_M_nxt = __p;\n+\t\t}\n \t      __p = __next;\n \t    }\n-\t  _M_begin_bucket_index = __n;\n-\t  _Node* __prev_node = nullptr;\n-\t  // Second loop to link all nodes together and to fix bucket values so\n-\t  // that they contain the before begin node of the bucket.\n-\t  for (size_type __i = 0; __i != __n; ++__i)\n-\t    if (__new_buckets[__i])\n-\t      {\n-\t\tif (__prev_node)\n-\t\t  {\n-\t\t    __prev_node->_M_next = __new_buckets[__i];\n-\t\t    __new_buckets[__i] = __prev_node;\n-\t\t  }\n-\t\telse\n-\t\t  _M_begin_bucket_index = __i;\n-\t\tif (__i < _M_bucket_count)\n-\t\t  __prev_node = _M_buckets[__i];\n-\t\telse\n-\t\t  {\n-\t\t    __prev_node = __new_buckets[__i];\n-\t\t    while (__prev_node->_M_next)\n-\t\t      __prev_node = __prev_node->_M_next;\n-\t\t  }\n-\t      }\n \t  _M_deallocate_buckets(_M_buckets, _M_bucket_count);\n \t  _M_bucket_count = __n;\n \t  _M_buckets = __new_buckets;"}, {"sha": "a06f6e316bc475b398da843812d8917b2c519c0f", "filename": "libstdc++-v3/include/bits/hashtable_policy.h", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f86b266c7cc7e5704f3e6f3260cde43c511bb178/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f86b266c7cc7e5704f3e6f3260cde43c511bb178/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h?ref=f86b266c7cc7e5704f3e6f3260cde43c511bb178", "patch": "@@ -73,32 +73,44 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   // template parameter of class template _Hashtable controls whether\n   // nodes also store a hash code. In some cases (e.g. strings) this\n   // may be a performance win.\n+  struct _Hash_node_base\n+  {\n+    _Hash_node_base* _M_nxt;\n+\n+    _Hash_node_base()\n+      : _M_nxt() { }\n+    _Hash_node_base(_Hash_node_base* __next)\n+      : _M_nxt(__next) { }\n+  };\n+\n   template<typename _Value, bool __cache_hash_code>\n     struct _Hash_node;\n \n   template<typename _Value>\n-    struct _Hash_node<_Value, true>\n+    struct _Hash_node<_Value, true> : _Hash_node_base\n     {\n       _Value       _M_v;\n       std::size_t  _M_hash_code;\n-      _Hash_node*  _M_next;\n \n       template<typename... _Args>\n \t_Hash_node(_Args&&... __args)\n-\t: _M_v(std::forward<_Args>(__args)...),\n-\t  _M_hash_code(), _M_next() { }\n+\t: _M_v(std::forward<_Args>(__args)...), _M_hash_code() { }\n+\n+      _Hash_node* _M_next() const\n+      { return static_cast<_Hash_node*>(_M_nxt); }\n     };\n \n   template<typename _Value>\n-    struct _Hash_node<_Value, false>\n+    struct _Hash_node<_Value, false> : _Hash_node_base\n     {\n       _Value       _M_v;\n-      _Hash_node*  _M_next;\n \n       template<typename... _Args>\n \t_Hash_node(_Args&&... __args)\n-\t: _M_v(std::forward<_Args>(__args)...),\n-\t  _M_next() { }\n+\t: _M_v(std::forward<_Args>(__args)...) { }\n+\n+      _Hash_node* _M_next() const\n+      { return static_cast<_Hash_node*>(_M_nxt); }\n     };\n \n   // Node iterators, used to iterate through all the hashtable.\n@@ -110,7 +122,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       void\n       _M_incr()\n-      { _M_cur = _M_cur->_M_next; }\n+      { _M_cur = _M_cur->_M_next(); }\n \n       _Hash_node<_Value, __cache>*  _M_cur;\n     };\n@@ -904,7 +916,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       void\n       _M_incr()\n       {\n-\t_M_cur = _M_cur->_M_next;\n+\t_M_cur = _M_cur->_M_next();\n \tif (_M_cur)\n \t  {\n \t    std::size_t __bkt = _M_h2()(_M_cur->_M_hash_code, _M_bucket_count);\n@@ -936,7 +948,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       void\n       _M_incr()\n       {\n-\t_M_cur = _M_cur->_M_next;\n+\t_M_cur = _M_cur->_M_next();\n \tif (_M_cur)\n \t  {\n \t    std::size_t __bkt = this->_M_bucket_index(_M_cur, _M_bucket_count);"}]}