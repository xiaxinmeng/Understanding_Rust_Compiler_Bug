{"sha": "677473677aa5d85ea967c998f73fb7f50b9eb379", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njc3NDczNjc3YWE1ZDg1ZWE5NjdjOTk4ZjczZmI3ZjUwYjllYjM3OQ==", "commit": {"author": {"name": "James Greenhalgh", "email": "james.greenhalgh@arm.com", "date": "2014-05-16T08:41:46Z"}, "committer": {"name": "James Greenhalgh", "email": "jgreenhalgh@gcc.gnu.org", "date": "2014-05-16T08:41:46Z"}, "message": "[AArch64 costs 1/18] Refactor aarch64_address_costs.\n\ngcc/\n\n\t* config/aarch64/aarch64-protos.h (scale_addr_mode_cost): New.\n\t(cpu_addrcost_table): Use it.\n\t* config/aarch64/aarch64.c (generic_addrcost_table): Initialize it.\n\t(aarch64_address_cost): Rewrite using aarch64_classify_address,\n\tmove it.\n\nFrom-SVN: r210493", "tree": {"sha": "7c872be35c8eaa51a6269b4942c1b7399210b7e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c872be35c8eaa51a6269b4942c1b7399210b7e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/677473677aa5d85ea967c998f73fb7f50b9eb379", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/677473677aa5d85ea967c998f73fb7f50b9eb379", "html_url": "https://github.com/Rust-GCC/gccrs/commit/677473677aa5d85ea967c998f73fb7f50b9eb379", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/677473677aa5d85ea967c998f73fb7f50b9eb379/comments", "author": {"login": "jgreenhalgh-arm", "id": 6104025, "node_id": "MDQ6VXNlcjYxMDQwMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6104025?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jgreenhalgh-arm", "html_url": "https://github.com/jgreenhalgh-arm", "followers_url": "https://api.github.com/users/jgreenhalgh-arm/followers", "following_url": "https://api.github.com/users/jgreenhalgh-arm/following{/other_user}", "gists_url": "https://api.github.com/users/jgreenhalgh-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jgreenhalgh-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jgreenhalgh-arm/subscriptions", "organizations_url": "https://api.github.com/users/jgreenhalgh-arm/orgs", "repos_url": "https://api.github.com/users/jgreenhalgh-arm/repos", "events_url": "https://api.github.com/users/jgreenhalgh-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/jgreenhalgh-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a764d66099b476db7d59829da1b86fd4a701523f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a764d66099b476db7d59829da1b86fd4a701523f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a764d66099b476db7d59829da1b86fd4a701523f"}], "stats": {"total": 156, "additions": 125, "deletions": 31}, "files": [{"sha": "47df09f2dc574a00f03b8e0c5ba1b528671f8775", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/677473677aa5d85ea967c998f73fb7f50b9eb379/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/677473677aa5d85ea967c998f73fb7f50b9eb379/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=677473677aa5d85ea967c998f73fb7f50b9eb379", "patch": "@@ -1,3 +1,11 @@\n+2014-05-16  James Greenhalgh  <james.greenhalgh@arm.com>\n+\n+\t* config/aarch64/aarch64-protos.h (scale_addr_mode_cost): New.\n+\t(cpu_addrcost_table): Use it.\n+\t* config/aarch64/aarch64.c (generic_addrcost_table): Initialize it.\n+\t(aarch64_address_cost): Rewrite using aarch64_classify_address,\n+\tmove it.\n+\n 2014-05-16  Richard Biener  <rguenther@suse.de>\n \n \t* tree-ssa-sccvn.c: Include tree-cfg.h and domwalk.h."}, {"sha": "a05605bf8a9ea92baa2e681a42c6f1d76f512e3b", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/677473677aa5d85ea967c998f73fb7f50b9eb379/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/677473677aa5d85ea967c998f73fb7f50b9eb379/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=677473677aa5d85ea967c998f73fb7f50b9eb379", "patch": "@@ -108,9 +108,22 @@ enum aarch64_symbol_type\n    cost models and vectors for address cost calculations, register\n    move costs and memory move costs.  */\n \n+/* Scaled addressing modes can vary cost depending on the mode of the\n+   value to be loaded/stored.  QImode values cannot use scaled\n+   addressing modes.  */\n+\n+struct scale_addr_mode_cost\n+{\n+  const int hi;\n+  const int si;\n+  const int di;\n+  const int ti;\n+};\n+\n /* Additional cost for addresses.  */\n struct cpu_addrcost_table\n {\n+  const struct scale_addr_mode_cost addr_scale_costs;\n   const int pre_modify;\n   const int post_modify;\n   const int register_offset;"}, {"sha": "a596f0db92d3fc8357f8220f904406cca3a1cada", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 104, "deletions": 31, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/677473677aa5d85ea967c998f73fb7f50b9eb379/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/677473677aa5d85ea967c998f73fb7f50b9eb379/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=677473677aa5d85ea967c998f73fb7f50b9eb379", "patch": "@@ -171,6 +171,15 @@ __extension__\n #endif\n static const struct cpu_addrcost_table generic_addrcost_table =\n {\n+#if HAVE_DESIGNATED_INITIALIZERS\n+  .addr_scale_costs =\n+#endif\n+    {\n+      NAMED_PARAM (qi, 0),\n+      NAMED_PARAM (hi, 0),\n+      NAMED_PARAM (si, 0),\n+      NAMED_PARAM (ti, 0),\n+    },\n   NAMED_PARAM (pre_modify, 0),\n   NAMED_PARAM (post_modify, 0),\n   NAMED_PARAM (register_offset, 0),\n@@ -4550,6 +4559,101 @@ aarch64_strip_shift_or_extend (rtx x)\n   return aarch64_strip_shift (x);\n }\n \n+static int\n+aarch64_address_cost (rtx x,\n+\t\t      enum machine_mode mode,\n+\t\t      addr_space_t as ATTRIBUTE_UNUSED,\n+\t\t      bool speed)\n+{\n+  enum rtx_code c = GET_CODE (x);\n+  const struct cpu_addrcost_table *addr_cost = aarch64_tune_params->addr_cost;\n+  struct aarch64_address_info info;\n+  int cost = 0;\n+  info.shift = 0;\n+\n+  if (!aarch64_classify_address (&info, x, mode, c, false))\n+    {\n+      if (GET_CODE (x) == CONST || GET_CODE (x) == SYMBOL_REF)\n+\t{\n+\t  /* This is a CONST or SYMBOL ref which will be split\n+\t     in a different way depending on the code model in use.\n+\t     Cost it through the generic infrastructure.  */\n+\t  int cost_symbol_ref = rtx_cost (x, MEM, 1, speed);\n+\t  /* Divide through by the cost of one instruction to\n+\t     bring it to the same units as the address costs.  */\n+\t  cost_symbol_ref /= COSTS_N_INSNS (1);\n+\t  /* The cost is then the cost of preparing the address,\n+\t     followed by an immediate (possibly 0) offset.  */\n+\t  return cost_symbol_ref + addr_cost->imm_offset;\n+\t}\n+      else\n+\t{\n+\t  /* This is most likely a jump table from a case\n+\t     statement.  */\n+\t  return addr_cost->register_offset;\n+\t}\n+    }\n+\n+  switch (info.type)\n+    {\n+      case ADDRESS_LO_SUM:\n+      case ADDRESS_SYMBOLIC:\n+      case ADDRESS_REG_IMM:\n+\tcost += addr_cost->imm_offset;\n+\tbreak;\n+\n+      case ADDRESS_REG_WB:\n+\tif (c == PRE_INC || c == PRE_DEC || c == PRE_MODIFY)\n+\t  cost += addr_cost->pre_modify;\n+\telse if (c == POST_INC || c == POST_DEC || c == POST_MODIFY)\n+\t  cost += addr_cost->post_modify;\n+\telse\n+\t  gcc_unreachable ();\n+\n+\tbreak;\n+\n+      case ADDRESS_REG_REG:\n+\tcost += addr_cost->register_offset;\n+\tbreak;\n+\n+      case ADDRESS_REG_UXTW:\n+      case ADDRESS_REG_SXTW:\n+\tcost += addr_cost->register_extend;\n+\tbreak;\n+\n+      default:\n+\tgcc_unreachable ();\n+    }\n+\n+\n+  if (info.shift > 0)\n+    {\n+      /* For the sake of calculating the cost of the shifted register\n+\t component, we can treat same sized modes in the same way.  */\n+      switch (GET_MODE_BITSIZE (mode))\n+\t{\n+\t  case 16:\n+\t    cost += addr_cost->addr_scale_costs.hi;\n+\t    break;\n+\n+\t  case 32:\n+\t    cost += addr_cost->addr_scale_costs.si;\n+\t    break;\n+\n+\t  case 64:\n+\t    cost += addr_cost->addr_scale_costs.di;\n+\t    break;\n+\n+\t  /* We can't tell, or this is a 128-bit vector.  */\n+\t  default:\n+\t    cost += addr_cost->addr_scale_costs.ti;\n+\t    break;\n+\t}\n+    }\n+\n+  return cost;\n+}\n+\n /* Calculate the cost of calculating X, storing it in *COST.  Result\n    is true if the total cost of the operation has now been calculated.  */\n static bool\n@@ -4886,37 +4990,6 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n   return false;\n }\n \n-static int\n-aarch64_address_cost (rtx x ATTRIBUTE_UNUSED,\n-\t\t  enum machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t  addr_space_t as ATTRIBUTE_UNUSED, bool speed ATTRIBUTE_UNUSED)\n-{\n-  enum rtx_code c  = GET_CODE (x);\n-  const struct cpu_addrcost_table *addr_cost = aarch64_tune_params->addr_cost;\n-\n-  if (c == PRE_INC || c == PRE_DEC || c == PRE_MODIFY)\n-    return addr_cost->pre_modify;\n-\n-  if (c == POST_INC || c == POST_DEC || c == POST_MODIFY)\n-    return addr_cost->post_modify;\n-\n-  if (c == PLUS)\n-    {\n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n-\treturn addr_cost->imm_offset;\n-      else if (GET_CODE (XEXP (x, 0)) == MULT\n-\t       || GET_CODE (XEXP (x, 0)) == ZERO_EXTEND\n-\t       || GET_CODE (XEXP (x, 0)) == SIGN_EXTEND)\n-\treturn addr_cost->register_extend;\n-\n-      return addr_cost->register_offset;\n-    }\n-  else if (c == MEM || c == LABEL_REF || c == SYMBOL_REF)\n-    return addr_cost->imm_offset;\n-\n-  return 0;\n-}\n-\n static int\n aarch64_register_move_cost (enum machine_mode mode,\n \t\t\t    reg_class_t from_i, reg_class_t to_i)"}]}