{"sha": "a750daa2859a01f62aca03fedc679ff90544e635", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTc1MGRhYTI4NTlhMDFmNjJhY2EwM2ZlZGM2NzlmZjkwNTQ0ZTYzNQ==", "commit": {"author": {"name": "Maxim Kuvyrkov", "email": "maxim@codesourcery.com", "date": "2007-10-17T19:50:55Z"}, "committer": {"name": "Maxim Kuvyrkov", "email": "mkuvyrkov@gcc.gnu.org", "date": "2007-10-17T19:50:55Z"}, "message": "sched-ebb.c: Surround code with '#ifdef INSN_SCHEDULING'.\n\n\t* sched-ebb.c: Surround code with '#ifdef INSN_SCHEDULING'.\n\t* ddg.c: Ditto.\n\t* sched-deps.c: Ditto.  Remove nested #ifdef's INSN_SCHEDULING.\n\t* sched-int.h: Surround declarations with '#ifdef INSN_SCHEDULING'.\n\t(print_insn): Move declaration to ...\n\t* rtl.h (print_insn): ... here.\n\nFrom-SVN: r129417", "tree": {"sha": "d4e5bbc949a517476a05b7d58c6980bc7235b670", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4e5bbc949a517476a05b7d58c6980bc7235b670"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a750daa2859a01f62aca03fedc679ff90544e635", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a750daa2859a01f62aca03fedc679ff90544e635", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a750daa2859a01f62aca03fedc679ff90544e635", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a750daa2859a01f62aca03fedc679ff90544e635/comments", "author": null, "committer": null, "parents": [{"sha": "fb7803cb2b0d12309503431c659cbcee1e12cd14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb7803cb2b0d12309503431c659cbcee1e12cd14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb7803cb2b0d12309503431c659cbcee1e12cd14"}], "stats": {"total": 55, "additions": 34, "deletions": 21}, "files": [{"sha": "bd049569200cb1959b8cdb02b2539becd1245b7d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a750daa2859a01f62aca03fedc679ff90544e635/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a750daa2859a01f62aca03fedc679ff90544e635/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a750daa2859a01f62aca03fedc679ff90544e635", "patch": "@@ -1,3 +1,19 @@\n+2007-10-17  Maxim Kuvyrkov  <maxim@codesourcery.com>\n+\n+\t* sched-ebb.c: Surround code with '#ifdef INSN_SCHEDULING'.\n+\t* ddg.c: Ditto.\n+\t* sched-deps.c: Ditto.  Remove nested #ifdef's INSN_SCHEDULING.\n+\t* sched-int.h: Surround declarations with '#ifdef INSN_SCHEDULING'.\n+\t(print_insn): Move declaration to ...\n+\t* rtl.h (print_insn): ... here.\n+\n+2007-10-17  Maxim Kuvyrkov  <maxim@codesourcery.com>\n+\n+\t* config/m68k/m68k.h (m68k_sched_cpu, m68k_sched_attr_opx_type,\n+\tm68k_sched_attr_opy_type, m68k_sched_attr_size, m68k_sched_attr_op_mem,\n+\tm68k_sched_branch_type): Move declarations to ...\n+\t* config/m68/m68k-protos.h: ... here.\n+\n 2007-10-17  Maxim Kuvyrkov  <maxim@codesourcery.com>\n \n \t* genattrtab.c (main): Rearrange output of insn-attrtab.c headers."}, {"sha": "14b18745823752615eeeb264eaf23121f3f83f59", "filename": "gcc/ddg.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a750daa2859a01f62aca03fedc679ff90544e635/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a750daa2859a01f62aca03fedc679ff90544e635/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=a750daa2859a01f62aca03fedc679ff90544e635", "patch": "@@ -44,6 +44,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"bitmap.h\"\n #include \"ddg.h\"\n \n+#ifdef INSN_SCHEDULING\n+\n /* A flag indicating that a ddg edge belongs to an SCC or not.  */\n enum edge_flag {NOT_IN_SCC = 0, IN_SCC};\n \n@@ -1104,3 +1106,5 @@ longest_simple_path (struct ddg * g, int src, int dest, sbitmap nodes)\n   sbitmap_free (tmp);\n   return result;\n }\n+\n+#endif /* INSN_SCHEDULING */"}, {"sha": "fbb90447c72167cfd3f56ae4afd3f7dec6846ede", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a750daa2859a01f62aca03fedc679ff90544e635/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a750daa2859a01f62aca03fedc679ff90544e635/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=a750daa2859a01f62aca03fedc679ff90544e635", "patch": "@@ -2110,6 +2110,7 @@ extern void dump_combine_total_stats (FILE *);\n extern void delete_dead_jumptables (void);\n \n /* In sched-vis.c.  */\n+extern void print_insn (char *, rtx, int);\n extern void print_rtl_slim_with_bb (FILE *, rtx, int);\n extern void dump_insn_slim (FILE *f, rtx x);\n extern void debug_insn_slim (rtx x);"}, {"sha": "d9f61eb385a03198091a723f379a405a1f92c6f0", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a750daa2859a01f62aca03fedc679ff90544e635/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a750daa2859a01f62aca03fedc679ff90544e635/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=a750daa2859a01f62aca03fedc679ff90544e635", "patch": "@@ -42,6 +42,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"params.h\"\n #include \"cselib.h\"\n \n+#ifdef INSN_SCHEDULING\n+\n #ifdef ENABLE_CHECKING\n #define CHECK (true)\n #else\n@@ -437,11 +439,9 @@ static enum DEPS_ADJUST_RESULT maybe_add_or_update_dep_1 (dep_t, bool,\n static enum DEPS_ADJUST_RESULT add_or_update_dep_1 (dep_t, bool, rtx, rtx);\n \n static dw_t estimate_dep_weak (rtx, rtx);\n-#ifdef INSN_SCHEDULING\n #ifdef ENABLE_CHECKING\n static void check_dep (dep_t, bool);\n #endif\n-#endif\n \f\n /* Return nonzero if a load of the memory reference MEM can cause a trap.  */\n \n@@ -752,19 +752,16 @@ maybe_add_or_update_dep_1 (dep_t dep, bool resolved_p, rtx mem1, rtx mem2)\n   /* Don't depend an insn on itself.  */\n   if (insn == elem)\n     {\n-#ifdef INSN_SCHEDULING\n       if (current_sched_info->flags & DO_SPECULATION)\n         /* INSN has an internal dependence, which we can't overcome.  */\n         HAS_INTERNAL_DEP (insn) = 1;\n-#endif\n \n       return DEP_NODEP;\n     }\n \n   return add_or_update_dep_1 (dep, resolved_p, mem1, mem2);\n }\n \n-#ifdef INSN_SCHEDULING\n /* Ask dependency caches what needs to be done for dependence DEP.\n    Return DEP_CREATED if new dependence should be created and there is no\n    need to try to find one searching the dependencies lists.\n@@ -935,7 +932,6 @@ change_spec_dep_to_hard (sd_iterator_def sd_it)\n     bitmap_clear_bit (&spec_dependency_cache[INSN_LUID (insn)],\n \t\t      INSN_LUID (elem));\n }\n-#endif\n \n /* Update DEP to incorporate information from NEW_DEP.\n    SD_IT points to DEP in case it should be moved to another list.\n@@ -959,7 +955,6 @@ update_dep (dep_t dep, dep_t new_dep,\n       res = DEP_CHANGED;\n     }\n \n-#ifdef INSN_SCHEDULING\n   if (current_sched_info->flags & USE_DEPS_LIST)\n     /* Update DEP_STATUS.  */\n     {\n@@ -1009,7 +1004,6 @@ update_dep (dep_t dep, dep_t new_dep,\n   if (true_dependency_cache != NULL\n       && res == DEP_CHANGED)\n     update_dependency_caches (dep, old_type);\n-#endif\n \n   return res;\n }\n@@ -1031,8 +1025,6 @@ add_or_update_dep_1 (dep_t new_dep, bool resolved_p,\n   gcc_assert (INSN_P (DEP_PRO (new_dep)) && INSN_P (DEP_CON (new_dep))\n \t      && DEP_PRO (new_dep) != DEP_CON (new_dep));\n   \n-#ifdef INSN_SCHEDULING\n-\n #ifdef ENABLE_CHECKING\n   check_dep (new_dep, mem1 != NULL);\n #endif\n@@ -1059,7 +1051,6 @@ add_or_update_dep_1 (dep_t new_dep, bool resolved_p,\n \t  break;\n \t}\n     }\n-#endif\n \n   /* Check that we don't already have this dependence.  */\n   if (maybe_present_p)\n@@ -1148,7 +1139,6 @@ sd_add_dep (dep_t dep, bool resolved_p)\n \n   add_to_deps_list (DEP_NODE_BACK (n), con_back_deps);\n \n-#ifdef INSN_SCHEDULING\n #ifdef ENABLE_CHECKING\n   check_dep (dep, false);\n #endif\n@@ -1159,7 +1149,6 @@ sd_add_dep (dep_t dep, bool resolved_p)\n      in the bitmap caches of dependency information.  */\n   if (true_dependency_cache != NULL)\n     set_dependency_caches (dep);\n-#endif\n }\n \n /* Add or update backward dependence between INSN and ELEM\n@@ -2202,7 +2191,6 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn)\n   if (SCHED_GROUP_P (insn))\n     fixup_sched_groups (insn);\n \n-#ifdef INSN_SCHEDULING\n   if ((current_sched_info->flags & DO_SPECULATION)\n       && !sched_insn_is_legitimate_for_speculation_p (insn, 0))\n     /* INSN has an internal dependency (e.g. r14 = [r14]) and thus cannot\n@@ -2215,7 +2203,6 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn)\n \t   sd_iterator_cond (&sd_it, &dep);)\n \tchange_spec_dep_to_hard (sd_it);\n     }\n-#endif\n }\n \n /* Analyze every insn between HEAD and TAIL inclusive, creating backward\n@@ -2788,7 +2775,6 @@ debug_ds (ds_t s)\n   fprintf (stderr, \"\\n\");\n }\n \n-#ifdef INSN_SCHEDULING\n #ifdef ENABLE_CHECKING\n /* Verify that dependence type and status are consistent.\n    If RELAXED_P is true, then skip dep_weakness checks.  */\n@@ -2871,5 +2857,6 @@ check_dep (dep_t dep, bool relaxed_p)\n \tgcc_assert (ds & BEGIN_CONTROL);\n     }\n }\n-#endif\n-#endif  \n+#endif /* ENABLE_CHECKING */\n+\n+#endif /* INSN_SCHEDULING */"}, {"sha": "7e22874601c164c702eb909f061746849c33f9dc", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a750daa2859a01f62aca03fedc679ff90544e635/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a750daa2859a01f62aca03fedc679ff90544e635/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=a750daa2859a01f62aca03fedc679ff90544e635", "patch": "@@ -44,6 +44,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"output.h\"\n \n \f\n+#ifdef INSN_SCHEDULING\n+\n /* The number of insns scheduled so far.  */\n static int sched_n_insns;\n \n@@ -696,3 +698,5 @@ fix_recovery_cfg (int bbi ATTRIBUTE_UNUSED, int jump_bbi, int jump_bb_nexti)\n   if (jump_bb_nexti == last_bb->index)\n     last_bb = BASIC_BLOCK (jump_bbi);\n }\n+\n+#endif /* INSN_SCHEDULING */"}, {"sha": "60919f09c412e6d1369a9a7130a2c4c6600b6891", "filename": "gcc/sched-int.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a750daa2859a01f62aca03fedc679ff90544e635/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a750daa2859a01f62aca03fedc679ff90544e635/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=a750daa2859a01f62aca03fedc679ff90544e635", "patch": "@@ -22,6 +22,8 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_SCHED_INT_H\n #define GCC_SCHED_INT_H\n \n+#ifdef INSN_SCHEDULING\n+\n /* For state_t.  */\n #include \"insn-attr.h\"\n /* For regset_head.  */\n@@ -807,9 +809,6 @@ enum INSN_TRAP_CLASS\n #define HAIFA_INLINE __inline\n #endif\n \n-/* Functions in sched-vis.c.  */\n-extern void print_insn (char *, rtx, int);\n-\n /* Functions in sched-deps.c.  */\n extern bool sched_insns_conditions_mutex_p (const_rtx, const_rtx);\n extern void add_dependence (rtx, rtx, enum reg_note);\n@@ -992,4 +991,6 @@ extern void sd_copy_back_deps (rtx, rtx, bool);\n extern void sd_delete_dep (sd_iterator_def);\n extern void sd_debug_lists (rtx, sd_list_types_def);\n \n+#endif /* INSN_SCHEDULING */\n+\n #endif /* GCC_SCHED_INT_H */"}]}