{"sha": "6f42806295525b038977345558653ff8148cfc02", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmY0MjgwNjI5NTUyNWIwMzg5NzczNDU1NTg2NTNmZjgxNDhjZmMwMg==", "commit": {"author": {"name": "David Ung", "email": "davidu@mips.com", "date": "2006-11-23T16:13:46Z"}, "committer": {"name": "David Ung", "email": "davidu@gcc.gnu.org", "date": "2006-11-23T16:13:46Z"}, "message": "mips.h (ISA_HAS_FP4): Add MIPS32R2 + 64bit fpu combination.\n\ngcc:\n\t* config/mips/mips.h (ISA_HAS_FP4): Add MIPS32R2 + 64bit fpu\n\tcombination.\n\t(ISA_HAS_MXHC1): True if ISA supports mfhc1 and mthc1 opcodes.\n\t(ASM_SPEC): Pass along -mfp32 and -mfp64.\n\t* config/mips/mips.c (mips_split_64bit_move): Use gen_mthc1 to set\n\thigh part of FP register when in 64-bit FP register mode.  Similarly\n\tuse gen_mfhc1 to load high part of FP register.\n\t(override_options): Allow -mgp32 and -mfp64 combination if\n\tISA_HAS_MXHC1 (currently for O32 only).\n\t(mips_cannot_change_mode_class): If floating-point registers are\n\tbigger than word size. disallow conversion of float register from a\n\tlarge integer mode to a float mode smaller than the float register\n\tsize.\n\t(mips_class_max_nregs): Handle float registers case seperately.\n\t* config/mips/mips.md (define_constants): Add UNSPEC_MFHC1,\n\tUNSPEC_MTHC1.\n\t(movdi_32bit): Use !TARGET_FLOAT64 in condition pattern.\n\t(movdf_hardfloat_32bit): Similarly.\n\t(movdi_gp32_fp64): New DImode pattern for MIPS32R2 which optionally\n\tsupport a full 64-bit fpu.\n\t(mthc1): New pattern to generate MTHC1 instruction.\n\t(mfhc1): New pattern to generate MFHC1 instruction.\n\t* doc/invoke.texi (MIPS Options): Document the -mgp32 -mfp64\n\toption for the MIPS32R2 and mention its use under O32 ABI.\n\ngcc/testsuite:\n\t* gcc.target/mips/mips.exp (dg-mips-options): Handle parsing of\n\t-mfp64, allowable when ISA >= 33 and float is enabled.\n\t* gcc.target/mips/mips32r2-mxhc1.c: New test for checking the use\n\tof mthc1 and mfhc1 patterns.\n\nFrom-SVN: r119124", "tree": {"sha": "65292f5a76c901840d8a3b14fca666144ac25e5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65292f5a76c901840d8a3b14fca666144ac25e5c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f42806295525b038977345558653ff8148cfc02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f42806295525b038977345558653ff8148cfc02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f42806295525b038977345558653ff8148cfc02", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f42806295525b038977345558653ff8148cfc02/comments", "author": null, "committer": null, "parents": [{"sha": "49bcb41649de38398633c544833ecdf4169a30f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49bcb41649de38398633c544833ecdf4169a30f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49bcb41649de38398633c544833ecdf4169a30f5"}], "stats": {"total": 178, "additions": 162, "deletions": 16}, "files": [{"sha": "00420bee77c08e7d3599e8889ffed9ff1b849f2d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f42806295525b038977345558653ff8148cfc02/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f42806295525b038977345558653ff8148cfc02/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6f42806295525b038977345558653ff8148cfc02", "patch": "@@ -1,3 +1,30 @@\n+2006-11-23  David Ung  <davidu@mips.com>\n+\n+\t* config/mips/mips.h (ISA_HAS_FP4): Add MIPS32R2 + 64bit fpu\n+\tcombination.\n+\t(ISA_HAS_MXHC1): True if ISA supports mfhc1 and mthc1 opcodes.\n+\t(ASM_SPEC): Pass along -mfp32 and -mfp64.\n+\t* config/mips/mips.c (mips_split_64bit_move): Use gen_mthc1 to set\n+\thigh part of FP register when in 64-bit FP register mode.  Similarly\n+\tuse gen_mfhc1 to load high part of FP register.\n+\t(override_options): Allow -mgp32 and -mfp64 combination if\n+\tISA_HAS_MXHC1 (currently for O32 only).\n+\t(mips_cannot_change_mode_class): If floating-point registers are\n+\tbigger than word size. disallow conversion of float register from a\n+\tlarge integer mode to a float mode smaller than the float register\n+\tsize.\n+\t(mips_class_max_nregs): Handle float registers case seperately.\n+\t* config/mips/mips.md (define_constants): Add UNSPEC_MFHC1,\n+\tUNSPEC_MTHC1.\n+\t(movdi_32bit): Use !TARGET_FLOAT64 in condition pattern.\n+\t(movdf_hardfloat_32bit): Similarly.\n+\t(movdi_gp32_fp64): New DImode pattern for MIPS32R2 which optionally\n+\tsupport a full 64-bit fpu.\n+\t(mthc1): New pattern to generate MTHC1 instruction.\n+\t(mfhc1): New pattern to generate MFHC1 instruction.\n+\t* doc/invoke.texi (MIPS Options): Document the -mgp32 -mfp64\n+\toption for the MIPS32R2 and mention its use under O32 ABI.\n+\n 2006-11-23  Bernd Schmidt  <bernd.schmidt@analog.com>\n \n \t* var-tracking.c (emit_note_insn_var_location): Take care not to"}, {"sha": "63c19ab99f1e4feff9612f4a89bea27380ceda21", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 54, "deletions": 15, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f42806295525b038977345558653ff8148cfc02/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f42806295525b038977345558653ff8148cfc02/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=6f42806295525b038977345558653ff8148cfc02", "patch": "@@ -2846,15 +2846,35 @@ mips_split_64bit_move (rtx dest, rtx src)\n   if (FP_REG_RTX_P (dest))\n     {\n       /* Loading an FPR from memory or from GPRs.  */\n-      emit_insn (gen_load_df_low (copy_rtx (dest), mips_subword (src, 0)));\n-      emit_insn (gen_load_df_high (dest, mips_subword (src, 1),\n-\t\t\t\t   copy_rtx (dest)));\n+      if (ISA_HAS_MXHC1)\n+\t{\n+\t  dest = gen_lowpart (DFmode, dest);\n+\t  emit_insn (gen_load_df_low (dest, mips_subword (src, 0)));\n+\t  emit_insn (gen_mthc1 (dest, mips_subword (src, 1),\n+\t\t\t\tcopy_rtx (dest)));\n+\t}\n+      else\n+\t{\n+\t  emit_insn (gen_load_df_low (copy_rtx (dest),\n+\t\t\t\t      mips_subword (src, 0)));\n+\t  emit_insn (gen_load_df_high (dest, mips_subword (src, 1),\n+\t\t\t\t       copy_rtx (dest)));\n+\t}\n     }\n   else if (FP_REG_RTX_P (src))\n     {\n       /* Storing an FPR into memory or GPRs.  */\n-      emit_move_insn (mips_subword (dest, 0), mips_subword (src, 0));\n-      emit_insn (gen_store_df_high (mips_subword (dest, 1), src));\n+      if (ISA_HAS_MXHC1)\n+\t{\n+\t  src = gen_lowpart (DFmode, src);\n+\t  emit_move_insn (mips_subword (dest, 0), mips_subword (src, 0));\n+\t  emit_insn (gen_mfhc1 (mips_subword (dest, 1), src));\n+\t}\n+      else\n+\t{\n+\t  emit_move_insn (mips_subword (dest, 0), mips_subword (src, 0));\n+\t  emit_insn (gen_store_df_high (mips_subword (dest, 1), src));\n+\t}\n     }\n   else\n     {\n@@ -4804,8 +4824,10 @@ override_options (void)\n \t only one right answer here.  */\n       if (TARGET_64BIT && TARGET_DOUBLE_FLOAT && !TARGET_FLOAT64)\n \terror (\"unsupported combination: %s\", \"-mgp64 -mfp32 -mdouble-float\");\n-      else if (!TARGET_64BIT && TARGET_FLOAT64)\n-\terror (\"unsupported combination: %s\", \"-mgp32 -mfp64\");\n+      else if (!TARGET_64BIT && TARGET_FLOAT64 \n+\t       && !(ISA_HAS_MXHC1 && mips_abi == ABI_32))\n+\terror (\"-mgp32 and -mfp64 can only be combined if the target\"\n+\t       \" supports the mfhc1 and mthc1 instructions\");\n       else if (TARGET_SINGLE_FLOAT && TARGET_FLOAT64)\n \terror (\"unsupported combination: %s\", \"-mfp64 -msingle-float\");\n     }\n@@ -7660,15 +7682,27 @@ mips_cannot_change_mode_class (enum machine_mode from,\n \t    return true;\n \t}\n     }\n+\n+  /* gcc assumes that each word of a multiword register can be accessed\n+     individually using SUBREGs.  This is not true for floating-point\n+     registers if they are bigger than a word.  */  \n+  if (UNITS_PER_FPREG > UNITS_PER_WORD\n+      && GET_MODE_SIZE (from) > UNITS_PER_WORD\n+      && GET_MODE_SIZE (to) < UNITS_PER_FPREG\n+      && reg_classes_intersect_p (FP_REGS, class))\n+    return true;\n+\n   /* Loading a 32-bit value into a 64-bit floating-point register\n      will not sign-extend the value, despite what LOAD_EXTEND_OP says.\n      We can't allow 64-bit float registers to change from SImode to\n      to a wider mode.  */\n-  if (TARGET_FLOAT64\n+  if (TARGET_64BIT\n+      && TARGET_FLOAT64\n       && from == SImode\n       && GET_MODE_SIZE (to) >= UNITS_PER_WORD\n       && reg_classes_intersect_p (FP_REGS, class))\n     return true;\n+\n   return false;\n }\n \n@@ -7830,21 +7864,26 @@ mips_secondary_reload_class (enum reg_class class,\n \n /* Implement CLASS_MAX_NREGS.\n \n-   Usually all registers are word-sized.  The only supported exception\n-   is -mgp64 -msingle-float, which has 64-bit words but 32-bit float\n-   registers.  A word-based calculation is correct even in that case,\n-   since -msingle-float disallows multi-FPR values.\n+   - UNITS_PER_FPREG controls the number of registers needed by FP_REGS.\n+\n+   - ST_REGS are always hold CCmode values, and CCmode values are\n+     considered to be 4 bytes wide.\n \n-   The FP status registers are an exception to this rule.  They are always\n-   4 bytes wide as they only hold condition code modes, and CCmode is always\n-   considered to be 4 bytes wide.  */\n+   All other register classes are covered by UNITS_PER_WORD.  Note that\n+   this is true even for unions of integer and float registers when the\n+   latter are smaller than the former.  The only supported combination\n+   in which case this occurs is -mgp64 -msingle-float, which has 64-bit\n+   words but 32-bit float registers.  A word-based calculation is correct\n+   in that case since -msingle-float disallows multi-FPR values.  */\n \n int\n mips_class_max_nregs (enum reg_class class ATTRIBUTE_UNUSED,\n \t\t      enum machine_mode mode)\n {\n   if (class == ST_REGS)\n     return (GET_MODE_SIZE (mode) + 3) / 4;\n+  else if (class == FP_REGS)\n+    return (GET_MODE_SIZE (mode) + UNITS_PER_FPREG - 1) / UNITS_PER_FPREG;\n   else\n     return (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n }"}, {"sha": "00f7ca8f55ff2d9f743686971208b8352c417faf", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f42806295525b038977345558653ff8148cfc02/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f42806295525b038977345558653ff8148cfc02/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=6f42806295525b038977345558653ff8148cfc02", "patch": "@@ -607,6 +607,7 @@ extern const struct mips_rtx_cost_data *mips_cost;\n    FP madd and msub instructions, and the FP recip and recip sqrt\n    instructions.  */\n #define ISA_HAS_FP4\t\t((ISA_MIPS4\t\t\t\t\\\n+\t\t\t\t  || (ISA_MIPS32R2 && TARGET_FLOAT64)   \\\n \t\t\t\t  || ISA_MIPS64)\t\t\t\\\n \t\t\t\t && !TARGET_MIPS16)\n \n@@ -703,6 +704,9 @@ extern const struct mips_rtx_cost_data *mips_cost;\n #define ISA_HAS_EXT_INS\t\t(ISA_MIPS32R2\t\t\t\t\\\n \t\t\t\t && !TARGET_MIPS16)\n \n+/* ISA has instructions for accessing top part of 64 bit fp regs */\n+#define ISA_HAS_MXHC1\t\t(TARGET_FLOAT64 && ISA_MIPS32R2)\n+\n /* True if the result of a load is not available to the next instruction.\n    A nop will then be needed between instructions like \"lw $4,...\"\n    and \"addiu $4,$4,1\".  */\n@@ -821,6 +825,7 @@ extern const struct mips_rtx_cost_data *mips_cost;\n %(subtarget_asm_debugging_spec) \\\n %{mabi=*} %{!mabi*: %(asm_abi_default_spec)} \\\n %{mgp32} %{mgp64} %{march=*} %{mxgot:-xgot} \\\n+%{mfp32} %{mfp64} \\\n %{mshared} %{mno-shared} \\\n %{msym32} %{mno-sym32} \\\n %{mtune=*} %{v} \\"}, {"sha": "b175fb343e8f3bb4448337c4d483ca130fcb82f7", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f42806295525b038977345558653ff8148cfc02/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f42806295525b038977345558653ff8148cfc02/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=6f42806295525b038977345558653ff8148cfc02", "patch": "@@ -47,6 +47,8 @@\n    (UNSPEC_MFHILO\t\t26)\n    (UNSPEC_TLS_LDM\t\t27)\n    (UNSPEC_TLS_GET_TP\t\t28)\n+   (UNSPEC_MFHC1\t\t31)\n+   (UNSPEC_MTHC1\t\t32)\n \n    (UNSPEC_ADDRESS_FIRST\t100)\n \n@@ -3255,14 +3257,25 @@\n (define_insn \"*movdi_32bit\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,d,d,m,*a,*d,*B*C*D,*B*C*D,*d,*m\")\n \t(match_operand:DI 1 \"move_operand\" \"d,i,m,d,*J*d,*a,*d,*m,*B*C*D,*B*C*D\"))]\n-  \"!TARGET_64BIT && !TARGET_MIPS16\n+  \"!TARGET_64BIT && !TARGET_FLOAT64 && !TARGET_MIPS16\n    && (register_operand (operands[0], DImode)\n        || reg_or_0_operand (operands[1], DImode))\"\n   { return mips_output_move (operands[0], operands[1]); }\n   [(set_attr \"type\"\t\"arith,arith,load,store,mthilo,mfhilo,xfer,load,xfer,store\")\n    (set_attr \"mode\"\t\"DI\")\n    (set_attr \"length\"   \"8,16,*,*,8,8,8,*,8,*\")])\n \n+(define_insn \"*movdi_gp32_fp64\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,d,d,m,*a,*d,*f,*f,*f,*d,*m\")\n+\t(match_operand:DI 1 \"move_operand\" \"d,i,m,d,*J*d,*a,*f,*J*d,*m,*f,*f\"))]\n+  \"!TARGET_64BIT && TARGET_FLOAT64 && !TARGET_MIPS16\n+   && (register_operand (operands[0], DImode)\n+       || reg_or_0_operand (operands[1], DImode))\"\n+  { return mips_output_move (operands[0], operands[1]); }\n+  [(set_attr \"type\"\t\"arith,arith,load,store,mthilo,mfhilo,fmove,xfer,fpload,xfer,fpstore\")\n+   (set_attr \"mode\"\t\"DI\")\n+   (set_attr \"length\"   \"8,16,*,*,8,8,4,8,*,8,*\")])\n+\n (define_insn \"*movdi_32bit_mips16\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,y,d,d,d,d,m,*d\")\n \t(match_operand:DI 1 \"move_operand\" \"d,d,y,K,N,m,d,*x\"))]\n@@ -3804,6 +3817,7 @@\n    (set_attr \"mode\"\t\"DF\")\n    (set_attr \"length\"\t\"4,4,*,*,*,4,4,4,*,*\")])\n \n+;; This pattern applies to both !TARGET_FLOAT64 and TARGET_FLOAT64.\n (define_insn \"*movdf_hardfloat_32bit\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,f,f,m,m,*f,*d,*d,*d,*m\")\n \t(match_operand:DF 1 \"move_operand\" \"f,G,m,f,G,*d,*f,*d*G,*m,*d\"))]\n@@ -3985,6 +3999,29 @@\n   [(set_attr \"type\"\t\"xfer,fpstore\")\n    (set_attr \"mode\"\t\"SF\")])\n \n+;; Move operand 1 to the high word of operand 0 using mthc1, preserving the\n+;; value in the low word.\n+(define_insn \"mthc1\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(unspec:DF [(match_operand:SI 1 \"general_operand\" \"dJ\")\n+\t\t    (match_operand:DF 2 \"register_operand\" \"0\")]\n+\t\t    UNSPEC_MTHC1))]\n+  \"TARGET_HARD_FLOAT && !TARGET_64BIT && ISA_HAS_MXHC1\"\n+  \"mthc1\\t%z1,%0\"\n+  [(set_attr \"type\"\t\"xfer\")\n+   (set_attr \"mode\"\t\"SF\")])\n+\n+;; Move high word of operand 1 to operand 0 using mfhc1.  The corresponding\n+;; low-word move is done in the normal way.\n+(define_insn \"mfhc1\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(unspec:SI [(match_operand:DF 1 \"register_operand\" \"f\")]\n+\t\t    UNSPEC_MFHC1))]\n+  \"TARGET_HARD_FLOAT && !TARGET_64BIT && ISA_HAS_MXHC1\"\n+  \"mfhc1\\t%0,%1\"\n+  [(set_attr \"type\"\t\"xfer\")\n+   (set_attr \"mode\"\t\"SF\")])\n+\n ;; Insn to initialize $gp for n32/n64 abicalls.  Operand 0 is the offset\n ;; of _gp from the start of this function.  Operand 1 is the incoming\n ;; function address."}, {"sha": "2cef7e6f1dd62391baec9cd0f79ff74f5169a843", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f42806295525b038977345558653ff8148cfc02/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f42806295525b038977345558653ff8148cfc02/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=6f42806295525b038977345558653ff8148cfc02", "patch": "@@ -10657,6 +10657,19 @@ can use @option{-mgp32} to get 32-bit code instead.\n For information about the O64 ABI, see\n @w{@uref{http://gcc.gnu.org/projects/mipso64-abi.html}}.\n \n+GCC supports a variant of the o32 ABI in which floating-point registers\n+are 64 rather than 32 bits wide.  You can select this combination with\n+@option{-mabi=32} @option{-mfp64}.  This ABI relies on the @samp{mthc1}\n+and @samp{mfhc1} instructions and is therefore only supported for\n+MIPS32R2 processors.\n+\n+The register assignments for arguments and return values remain the\n+same, but each scalar value is passed in a single 64-bit register\n+rather than a pair of 32-bit registers.  For example, scalar\n+floating-point values are returned in @samp{$f0} only, not a\n+@samp{$f0}/@samp{$f1} pair.  The set of call-saved registers also\n+remains the same, but all 64 bits are saved.\n+\n @item -mabicalls\n @itemx -mno-abicalls\n @opindex mabicalls"}, {"sha": "cec51b1d7961f27ea699995ed4974c984fc1528f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f42806295525b038977345558653ff8148cfc02/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f42806295525b038977345558653ff8148cfc02/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6f42806295525b038977345558653ff8148cfc02", "patch": "@@ -1,3 +1,10 @@\n+2006-11-23  David Ung <davidu@mips.com>\n+\t\n+\t* gcc.target/mips/mips.exp (dg-mips-options): Handle parsing of\n+\t-mfp64, allowable when ISA >= 33 and float is enabled.\n+\t* gcc.target/mips/mips32r2-mxhc1.c: New test for checking the use\n+\tof mthc1 and mfhc1 patterns.\n+\t\n 2006-11-23  Zdenek Dvorak <dvorakz@suse.cz>\n \n \tPR tree-optimization/29921"}, {"sha": "af5b0fbdd5daff5174277444033bc6d3fc1e50ed", "filename": "gcc/testsuite/gcc.target/mips/mips.exp", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f42806295525b038977345558653ff8148cfc02/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f42806295525b038977345558653ff8148cfc02/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips.exp?ref=6f42806295525b038977345558653ff8148cfc02", "patch": "@@ -158,6 +158,10 @@ proc dg-mips-options {args} {\n \t    if {$mips_mips16} {\n \t\tset matches 0\n \t    }\n+\t} elseif {$flag == \"-mfp64\"} {\n+\t    if {$mips_isa < 33 || $mips_float != \"hard\"} {\n+\t\tset matches 0\n+\t    }\n \t} elseif {[regexp -- {^-march=(.*)} $flag dummy arch]} {\n \t    if {$mips_mips16 || ($arch != $mips_arch && $mips_forced_isa)} {\n \t\tset matches 0"}, {"sha": "7a3b12d55af63a235e4bba7687bc6eb6aac1dc26", "filename": "gcc/testsuite/gcc.target/mips/mips32r2-mxhc1.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f42806295525b038977345558653ff8148cfc02/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips32r2-mxhc1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f42806295525b038977345558653ff8148cfc02/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips32r2-mxhc1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips32r2-mxhc1.c?ref=6f42806295525b038977345558653ff8148cfc02", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-mips-options \"-O -march=mips32r2 -mabi=32 -mfp64\" } */\n+/* { dg-final { scan-assembler \"mthc1\" } } */\n+/* { dg-final { scan-assembler \"mfhc1\" } } */\n+\n+double func1 (long long a)\n+{\n+  return a;\n+}\n+\n+long long func2 (double b)\n+{\n+  return b;\n+}"}]}