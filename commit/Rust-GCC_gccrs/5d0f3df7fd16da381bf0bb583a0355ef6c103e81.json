{"sha": "5d0f3df7fd16da381bf0bb583a0355ef6c103e81", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQwZjNkZjdmZDE2ZGEzODFiZjBiYjU4M2EwMzU1ZWY2YzEwM2U4MQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-09-27T22:41:07Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-09-27T22:41:07Z"}, "message": "unroll.c (simplify_cmp_and_jump_insns): New.\n\n\t* unroll.c (simplify_cmp_and_jump_insns): New.\n\t(unroll_loop): Use it.  Use simplify_gen_foo+force_operand\n\tinstead of expand_simple_foo.\n\nFrom-SVN: r57596", "tree": {"sha": "7e0a28e0b76a37c3b7c0624eb5479e0e6776d55c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e0a28e0b76a37c3b7c0624eb5479e0e6776d55c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d0f3df7fd16da381bf0bb583a0355ef6c103e81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d0f3df7fd16da381bf0bb583a0355ef6c103e81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d0f3df7fd16da381bf0bb583a0355ef6c103e81", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d0f3df7fd16da381bf0bb583a0355ef6c103e81/comments", "author": null, "committer": null, "parents": [{"sha": "d3d09886b33d802d5803e9f74cf70c9fa36a3f98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3d09886b33d802d5803e9f74cf70c9fa36a3f98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3d09886b33d802d5803e9f74cf70c9fa36a3f98"}], "stats": {"total": 130, "additions": 86, "deletions": 44}, "files": [{"sha": "c354cf995f4ef9172258ab83646067d66dd7c92e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d0f3df7fd16da381bf0bb583a0355ef6c103e81/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d0f3df7fd16da381bf0bb583a0355ef6c103e81/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5d0f3df7fd16da381bf0bb583a0355ef6c103e81", "patch": "@@ -1,3 +1,9 @@\n+2002-09-27  Richard Henderson  <rth@redhat.com>\n+\n+\t* unroll.c (simplify_cmp_and_jump_insns): New.\n+\t(unroll_loop): Use it.  Use simplify_gen_foo+force_operand\n+\tinstead of expand_simple_foo.\n+\n 2002-09-27  Richard Henderson  <rth@redhat.com>\n \n \tPR optimization/7520"}, {"sha": "126b586808d2ca8ab0dacfa9aca628e348bf64c4", "filename": "gcc/unroll.c", "status": "modified", "additions": 80, "deletions": 44, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d0f3df7fd16da381bf0bb583a0355ef6c103e81/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d0f3df7fd16da381bf0bb583a0355ef6c103e81/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=5d0f3df7fd16da381bf0bb583a0355ef6c103e81", "patch": "@@ -193,6 +193,9 @@ static int *splittable_regs_updates;\n \n /* Forward declarations.  */\n \n+static rtx simplify_cmp_and_jump_insns PARAMS ((enum rtx_code,\n+\t\t\t\t\t\tenum machine_mode,\n+\t\t\t\t\t\trtx, rtx, rtx));\n static void init_reg_map PARAMS ((struct inline_remap *, int));\n static rtx calculate_giv_inc PARAMS ((rtx, rtx, unsigned int));\n static rtx initial_reg_note_copy PARAMS ((rtx, struct inline_remap *));\n@@ -843,7 +846,7 @@ unroll_loop (loop, insn_count, strength_reduce_p)\n \t\t\t       &initial_value, &final_value, &increment,\n \t\t\t       &mode))\n \t{\n-\t  rtx diff;\n+\t  rtx diff, insn;\n \t  rtx *labels;\n \t  int abs_inc, neg_inc;\n \t  enum rtx_code cc = loop_info->comparison_code;\n@@ -875,26 +878,20 @@ unroll_loop (loop, insn_count, strength_reduce_p)\n \n \t  start_sequence ();\n \n+\t  /* We must copy the final and initial values here to avoid\n+\t     improperly shared rtl.  */\n+\t  final_value = copy_rtx (final_value);\n+\t  initial_value = copy_rtx (initial_value);\n+\n \t  /* Final value may have form of (PLUS val1 const1_rtx).  We need\n \t     to convert it into general operand, so compute the real value.  */\n \n-\t  if (GET_CODE (final_value) == PLUS)\n-\t    {\n-\t      final_value = expand_simple_binop (mode, PLUS,\n-\t\t\t\t\t\t copy_rtx (XEXP (final_value, 0)),\n-\t\t\t\t\t\t copy_rtx (XEXP (final_value, 1)),\n-\t\t\t\t\t\t NULL_RTX, 0, OPTAB_LIB_WIDEN);\n-\t    }\n+\t  final_value = force_operand (final_value, NULL_RTX);\n \t  if (!nonmemory_operand (final_value, VOIDmode))\n-\t    final_value = force_reg (mode, copy_rtx (final_value));\n+\t    final_value = force_reg (mode, final_value);\n \n \t  /* Calculate the difference between the final and initial values.\n \t     Final value may be a (plus (reg x) (const_int 1)) rtx.\n-\t     Let the following cse pass simplify this if initial value is\n-\t     a constant.\n-\n-\t     We must copy the final and initial values here to avoid\n-\t     improperly shared rtl.\n \n \t     We have to deal with for (i = 0; --i < 6;) type loops.\n \t     For such loops the real final value is the first time the\n@@ -907,18 +904,18 @@ unroll_loop (loop, insn_count, strength_reduce_p)\n \t     so we can pretend that the overflow value is 0/~0.  */\n \n \t  if (cc == NE || less_p != neg_inc)\n-\t    diff = expand_simple_binop (mode, MINUS, final_value,\n-\t\t\t\t\tcopy_rtx (initial_value), NULL_RTX, 0,\n-\t\t\t\t\tOPTAB_LIB_WIDEN);\n+\t    diff = simplify_gen_binary (MINUS, mode, final_value,\n+\t\t\t\t\tinitial_value);\n \t  else\n-\t    diff = expand_simple_unop (mode, neg_inc ? NOT : NEG,\n-\t\t\t\t       copy_rtx (initial_value), NULL_RTX, 0);\n+\t    diff = simplify_gen_unary (neg_inc ? NOT : NEG, mode,\n+\t\t\t\t       initial_value, mode);\n+\t  diff = force_operand (diff, NULL_RTX);\n \n \t  /* Now calculate (diff % (unroll * abs (increment))) by using an\n \t     and instruction.  */\n-\t  diff = expand_simple_binop (GET_MODE (diff), AND, diff,\n-\t\t\t\t      GEN_INT (unroll_number * abs_inc - 1),\n-\t\t\t\t      NULL_RTX, 0, OPTAB_LIB_WIDEN);\n+\t  diff = simplify_gen_binary (AND, mode, diff,\n+\t\t\t\t      GEN_INT (unroll_number*abs_inc - 1));\n+\t  diff = force_operand (diff, NULL_RTX);\n \n \t  /* Now emit a sequence of branches to jump to the proper precond\n \t     loop entry point.  */\n@@ -936,18 +933,22 @@ unroll_loop (loop, insn_count, strength_reduce_p)\n \t  if (cc != NE)\n \t    {\n \t      rtx incremented_initval;\n-\t      incremented_initval = expand_simple_binop (mode, PLUS,\n-\t\t\t\t\t\t\t initial_value,\n-\t\t\t\t\t\t\t increment,\n-\t\t\t\t\t\t\t NULL_RTX, 0,\n-\t\t\t\t\t\t\t OPTAB_LIB_WIDEN);\n-\t      emit_cmp_and_jump_insns (incremented_initval, final_value,\n-\t\t\t\t       less_p ? GE : LE, NULL_RTX,\n-\t\t\t\t       mode, unsigned_p, labels[1]);\n-\t      predict_insn_def (get_last_insn (), PRED_LOOP_CONDITION,\n-\t\t\t\tTAKEN);\n-\t      JUMP_LABEL (get_last_insn ()) = labels[1];\n-\t      LABEL_NUSES (labels[1])++;\n+\t      enum rtx_code cmp_code;\n+\n+\t      incremented_initval\n+\t\t= simplify_gen_binary (PLUS, mode, initial_value, increment);\n+\t      incremented_initval\n+\t\t= force_operand (incremented_initval, NULL_RTX);\n+\n+\t      cmp_code = (less_p\n+\t\t\t  ? (unsigned_p ? GEU : GE)\n+\t\t\t  : (unsigned_p ? LEU : LE));\n+\n+\t      insn = simplify_cmp_and_jump_insns (cmp_code, mode,\n+\t\t\t\t\t\t  incremented_initval,\n+\t\t\t\t\t\t  final_value, labels[1]);\n+\t      if (insn)\n+\t        predict_insn_def (insn, PRED_LOOP_CONDITION, TAKEN);\n \t    }\n \n \t  /* Assuming the unroll_number is 4, and the increment is 2, then\n@@ -986,12 +987,12 @@ unroll_loop (loop, insn_count, strength_reduce_p)\n \t\t  cmp_code = LE;\n \t\t}\n \n-\t      emit_cmp_and_jump_insns (diff, GEN_INT (abs_inc * cmp_const),\n-\t\t\t\t       cmp_code, NULL_RTX, mode, 0, labels[i]);\n-\t      JUMP_LABEL (get_last_insn ()) = labels[i];\n-\t      LABEL_NUSES (labels[i])++;\n-\t      predict_insn (get_last_insn (), PRED_LOOP_PRECONDITIONING,\n-\t\t\t    REG_BR_PROB_BASE / (unroll_number - i));\n+\t      insn = simplify_cmp_and_jump_insns (cmp_code, mode, diff,\n+\t\t\t\t\t\t  GEN_INT (abs_inc*cmp_const),\n+\t\t\t\t\t\t  labels[i]);\n+\t      if (insn)\n+\t        predict_insn (insn, PRED_LOOP_PRECONDITIONING,\n+\t\t\t      REG_BR_PROB_BASE / (unroll_number - i));\n \t    }\n \n \t  /* If the increment is greater than one, then we need another branch,\n@@ -1019,10 +1020,8 @@ unroll_loop (loop, insn_count, strength_reduce_p)\n \t\t  cmp_code = GE;\n \t\t}\n \n-\t      emit_cmp_and_jump_insns (diff, GEN_INT (cmp_const), cmp_code,\n-\t\t\t\t       NULL_RTX, mode, 0, labels[0]);\n-\t      JUMP_LABEL (get_last_insn ()) = labels[0];\n-\t      LABEL_NUSES (labels[0])++;\n+\t      simplify_cmp_and_jump_insns (cmp_code, mode, diff,\n+\t\t\t\t\t   GEN_INT (cmp_const), labels[0]);\n \t    }\n \n \t  sequence = get_insns ();\n@@ -1324,6 +1323,43 @@ unroll_loop (loop, insn_count, strength_reduce_p)\n     free (map->reg_map);\n   free (map);\n }\n+\n+/* A helper function for unroll_loop.  Emit a compare and branch to \n+   satisfy (CMP OP1 OP2), but pass this through the simplifier first.\n+   If the branch turned out to be conditional, return it, otherwise\n+   return NULL.  */\n+\n+static rtx\n+simplify_cmp_and_jump_insns (code, mode, op0, op1, label)\n+     enum rtx_code code;\n+     enum machine_mode mode;\n+     rtx op0, op1, label;\n+{\n+  rtx t, insn;\n+\n+  t = simplify_relational_operation (code, mode, op0, op1);\n+  if (!t)\n+    {\n+      enum rtx_code scode = signed_condition (code);\n+      emit_cmp_and_jump_insns (op0, op1, scode, NULL_RTX, mode,\n+\t\t\t       code != scode, label);\n+      insn = get_last_insn ();\n+\n+      JUMP_LABEL (insn) = label;\n+      LABEL_NUSES (label) += 1;\n+\n+      return insn;\n+    }\n+  else if (t == const_true_rtx)\n+    {\n+      insn = emit_jump_insn (gen_jump (label));\n+      emit_barrier ();\n+      JUMP_LABEL (insn) = label;\n+      LABEL_NUSES (label) += 1;\n+    }\n+\n+  return NULL_RTX;\n+}\n \f\n /* Return true if the loop can be safely, and profitably, preconditioned\n    so that the unrolled copies of the loop body don't need exit tests."}]}