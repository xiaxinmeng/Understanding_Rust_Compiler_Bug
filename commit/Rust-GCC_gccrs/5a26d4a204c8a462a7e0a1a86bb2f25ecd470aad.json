{"sha": "5a26d4a204c8a462a7e0a1a86bb2f25ecd470aad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWEyNmQ0YTIwNGM4YTQ2MmE3ZTBhMWE4NmJiMmYyNWVjZDQ3MGFhZA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-12-04T16:34:41Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-12-04T16:38:57Z"}, "message": "c++: Revert dependent-array changes [PR 98116]\n\nThe changes reverted here are exposing an existing problem with alias\ntemplate comparisons.  The typename_type changes are also incomplete,\npossibly for similar reasons.  It seems safer to revert them, fix the\nunderlying issue and then move forwards.\n\nThe testcases is adjusted to more robustly check the specialization\ntable, and ICEs with and without the c++ changes.\n\nRevert:\n62fb1b9e0da c++: Fix array type dependency [PR 98107]\n07589ca2b2c c++: typename_type structural comparison\n29ae1d7751 c++: Extend build_array_type API\n\n\tPR c++/98116\n\tgcc/cp/\n\t* cp-tree.h (comparing_typenames): Delete.\n\t(cplus_build_array_type): Remove default parm.\n\t* pt.c (comparing_typenames): Delete.\n\t(spec_hasher::equal): Don't increment it.\n\t* tree.c (set_array_type_canon): Remove dep parm.\n\t(build_cplus_array_type): Remove dep parm changes.\n\t(cp_build_qualified_type_real): Remove dependent array type\n\tchanges.\n\t(strip_typedefs): Likewise.\n\t* typeck.c (structural_comptypes): Revert comparing_typename\n\tchanges.\n\tgcc/testsuite/\n\t* g++.dg/template/pr98116.C: Enable robust checking.", "tree": {"sha": "3053f43703cd570003a0a08af1d2b3fc50fa4e62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3053f43703cd570003a0a08af1d2b3fc50fa4e62"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a26d4a204c8a462a7e0a1a86bb2f25ecd470aad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a26d4a204c8a462a7e0a1a86bb2f25ecd470aad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a26d4a204c8a462a7e0a1a86bb2f25ecd470aad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a26d4a204c8a462a7e0a1a86bb2f25ecd470aad/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97eaf8c92f9caaa888475f98cc7a55a05672c87b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97eaf8c92f9caaa888475f98cc7a55a05672c87b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97eaf8c92f9caaa888475f98cc7a55a05672c87b"}], "stats": {"total": 79, "additions": 30, "deletions": 49}, "files": [{"sha": "00901fe42d40225e38a86e092c03d02be5ac5358", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a26d4a204c8a462a7e0a1a86bb2f25ecd470aad/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a26d4a204c8a462a7e0a1a86bb2f25ecd470aad/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=5a26d4a204c8a462a7e0a1a86bb2f25ecd470aad", "patch": "@@ -5422,10 +5422,6 @@ extern int function_depth;\n    in structrual_comptypes.  */\n extern int comparing_specializations;\n \n-/* Nonzero if we are inside eq_specializations, which affects\n-   resolving of typenames in structural_comptypes.  */\n-extern int comparing_typenames;\n-\n /* In parser.c.  */\n \n /* Nonzero if we are parsing an unevaluated operand: an operand to\n@@ -7563,7 +7559,7 @@ extern bool is_local_temp\t\t\t(tree);\n extern tree build_aggr_init_expr\t\t(tree, tree);\n extern tree get_target_expr\t\t\t(tree);\n extern tree get_target_expr_sfinae\t\t(tree, tsubst_flags_t);\n-extern tree build_cplus_array_type\t\t(tree, tree, int is_dep = -1);\n+extern tree build_cplus_array_type\t\t(tree, tree);\n extern tree build_array_of_n_type\t\t(tree, int);\n extern bool array_of_runtime_bound_p\t\t(tree);\n extern bool vla_type_p\t\t\t\t(tree);"}, {"sha": "9e8113d51a3e0ce90f27f0a2c3dbfcd3b262b19b", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a26d4a204c8a462a7e0a1a86bb2f25ecd470aad/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a26d4a204c8a462a7e0a1a86bb2f25ecd470aad/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=5a26d4a204c8a462a7e0a1a86bb2f25ecd470aad", "patch": "@@ -1704,19 +1704,16 @@ register_specialization (tree spec, tree tmpl, tree args, bool is_friend,\n   return spec;\n }\n \n-/* Restricts tree and type comparisons.  */\n-int comparing_specializations;\n-int comparing_typenames;\n-\n /* Returns true iff two spec_entry nodes are equivalent.  */\n \n+int comparing_specializations;\n+\n bool\n spec_hasher::equal (spec_entry *e1, spec_entry *e2)\n {\n   int equal;\n \n   ++comparing_specializations;\n-  ++comparing_typenames;\n   equal = (e1->tmpl == e2->tmpl\n \t   && comp_template_args (e1->args, e2->args));\n   if (equal && flag_concepts\n@@ -1732,7 +1729,6 @@ spec_hasher::equal (spec_entry *e1, spec_entry *e2)\n       equal = equivalent_constraints (c1, c2);\n     }\n   --comparing_specializations;\n-  --comparing_typenames;\n \n   return equal;\n }"}, {"sha": "4e6bf9abba66ccc918f9cac92b13c4e02bb94399", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 11, "deletions": 29, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a26d4a204c8a462a7e0a1a86bb2f25ecd470aad/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a26d4a204c8a462a7e0a1a86bb2f25ecd470aad/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=5a26d4a204c8a462a7e0a1a86bb2f25ecd470aad", "patch": "@@ -998,7 +998,7 @@ build_min_array_type (tree elt_type, tree index_type)\n    build_cplus_array_type.  */\n \n static void\n-set_array_type_canon (tree t, tree elt_type, tree index_type, bool dep)\n+set_array_type_canon (tree t, tree elt_type, tree index_type)\n {\n   /* Set the canonical type for this new node.  */\n   if (TYPE_STRUCTURAL_EQUALITY_P (elt_type)\n@@ -1009,33 +1009,30 @@ set_array_type_canon (tree t, tree elt_type, tree index_type, bool dep)\n     TYPE_CANONICAL (t)\n       = build_cplus_array_type (TYPE_CANONICAL (elt_type),\n \t\t\t\tindex_type\n-\t\t\t\t? TYPE_CANONICAL (index_type) : index_type,\n-\t\t\t\tdep);\n+\t\t\t\t? TYPE_CANONICAL (index_type) : index_type);\n   else\n     TYPE_CANONICAL (t) = t;\n }\n \n /* Like build_array_type, but handle special C++ semantics: an array of a\n    variant element type is a variant of the array of the main variant of\n-   the element type.  IS_DEPENDENT is -ve if we should determine the\n-   dependency.  Otherwise its bool value indicates dependency.  */\n+   the element type.  */\n \n tree\n-build_cplus_array_type (tree elt_type, tree index_type, int dependent)\n+build_cplus_array_type (tree elt_type, tree index_type)\n {\n   tree t;\n \n   if (elt_type == error_mark_node || index_type == error_mark_node)\n     return error_mark_node;\n \n-  if (dependent < 0)\n-    dependent = (uses_template_parms (elt_type)\n-\t\t || (index_type && uses_template_parms (index_type)));\n+  bool dependent = (uses_template_parms (elt_type)\n+\t\t    || (index_type && uses_template_parms (index_type)));\n \n   if (elt_type != TYPE_MAIN_VARIANT (elt_type))\n     /* Start with an array of the TYPE_MAIN_VARIANT.  */\n     t = build_cplus_array_type (TYPE_MAIN_VARIANT (elt_type),\n-\t\t\t\tindex_type, dependent);\n+\t\t\t\tindex_type);\n   else if (dependent)\n     {\n       /* Since type_hash_canon calls layout_type, we need to use our own\n@@ -1065,20 +1062,13 @@ build_cplus_array_type (tree elt_type, tree index_type, int dependent)\n \t  *e = t;\n \n \t  /* Set the canonical type for this new node.  */\n-\t  set_array_type_canon (t, elt_type, index_type, dependent);\n-\n-\t  /* Mark it as dependent now, this saves time later.  */\n-\t  TYPE_DEPENDENT_P_VALID (t) = true;\n-\t  TYPE_DEPENDENT_P (t) = true;\n+\t  set_array_type_canon (t, elt_type, index_type);\n \t}\n     }\n   else\n     {\n       bool typeless_storage = is_byte_access_type (elt_type);\n       t = build_array_type (elt_type, index_type, typeless_storage);\n-\n-      /* Mark as non-dependenty now, this will save time later.  */\n-      TYPE_DEPENDENT_P_VALID (t) = true;\n     }\n \n   /* Now check whether we already have this array variant.  */\n@@ -1093,10 +1083,7 @@ build_cplus_array_type (tree elt_type, tree index_type, int dependent)\n       if (!t)\n \t{\n \t  t = build_min_array_type (elt_type, index_type);\n-\t  /* Mark dependency now, this saves time later.  */\n-\t  TYPE_DEPENDENT_P_VALID (t) = true;\n-\t  TYPE_DEPENDENT_P (t) = dependent;\n-\t  set_array_type_canon (t, elt_type, index_type, dependent);\n+\t  set_array_type_canon (t, elt_type, index_type);\n \t  if (!dependent)\n \t    {\n \t      layout_type (t);\n@@ -1332,10 +1319,7 @@ cp_build_qualified_type_real (tree type,\n \n       if (!t)\n \t{\n-\t  gcc_checking_assert (TYPE_DEPENDENT_P_VALID (type)\n-\t\t\t       || !dependent_type_p (type));\n-\t  t = build_cplus_array_type (element_type, TYPE_DOMAIN (type),\n-\t\t\t\t      TYPE_DEPENDENT_P (type));\n+\t  t = build_cplus_array_type (element_type, TYPE_DOMAIN (type));\n \n \t  /* Keep the typedef name.  */\n \t  if (TYPE_NAME (t) != TYPE_NAME (type))\n@@ -1571,9 +1555,7 @@ strip_typedefs (tree t, bool *remove_attributes, unsigned int flags)\n     case ARRAY_TYPE:\n       type = strip_typedefs (TREE_TYPE (t), remove_attributes, flags);\n       t0  = strip_typedefs (TYPE_DOMAIN (t), remove_attributes, flags);\n-      gcc_checking_assert (TYPE_DEPENDENT_P_VALID (t)\n-\t\t\t   || !dependent_type_p (t));\n-      result = build_cplus_array_type (type, t0, TYPE_DEPENDENT_P (t));\n+      result = build_cplus_array_type (type, t0);\n       break;\n     case FUNCTION_TYPE:\n     case METHOD_TYPE:"}, {"sha": "267b284ea40fad3c985ed520e7f7eab91ea19fc8", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a26d4a204c8a462a7e0a1a86bb2f25ecd470aad/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a26d4a204c8a462a7e0a1a86bb2f25ecd470aad/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=5a26d4a204c8a462a7e0a1a86bb2f25ecd470aad", "patch": "@@ -1256,15 +1256,16 @@ structural_comptypes (tree t1, tree t2, int strict)\n \n   gcc_assert (TYPE_P (t1) && TYPE_P (t2));\n \n-  /* TYPENAME_TYPEs should be resolved if the qualifying scope is the\n-     current instantiation, and we don't care about typename\n-     structural equality.  The comparing_typenames check is after the\n-     code check, in order to early-out the common case.  */\n-  if (TREE_CODE (t1) == TYPENAME_TYPE && !comparing_typenames)\n-    t1 = resolve_typename_type (t1, /*only_current_p=*/true);\n-\n-  if (TREE_CODE (t2) == TYPENAME_TYPE && !comparing_typenames)\n-    t2 = resolve_typename_type (t2, /*only_current_p=*/true);\n+  if (!comparing_specializations)\n+    {\n+      /* TYPENAME_TYPEs should be resolved if the qualifying scope is the\n+\t current instantiation.  */\n+      if (TREE_CODE (t1) == TYPENAME_TYPE)\n+\tt1 = resolve_typename_type (t1, /*only_current_p=*/true);\n+\n+      if (TREE_CODE (t2) == TYPENAME_TYPE)\n+\tt2 = resolve_typename_type (t2, /*only_current_p=*/true);\n+    }\n \n   if (TYPE_PTRMEMFUNC_P (t1))\n     t1 = TYPE_PTRMEMFUNC_FN_TYPE (t1);"}, {"sha": "874c590f9d238295bc99a72e46c52e7ea776652c", "filename": "gcc/testsuite/g++.dg/template/pr98116.C", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a26d4a204c8a462a7e0a1a86bb2f25ecd470aad/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpr98116.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a26d4a204c8a462a7e0a1a86bb2f25ecd470aad/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpr98116.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpr98116.C?ref=5a26d4a204c8a462a7e0a1a86bb2f25ecd470aad", "patch": "@@ -1,5 +1,11 @@\n // PR 98116, ICE with stripping typedef array type\n // { dg-do compile { target c++11 } }\n+// { dg-additional-options {--param=hash-table-verification-limit=10000000 -fchecking=2} }\n+// { dg-ice \"spec_hasher::equal\" }\n+\n+// We get confused by alias templates that alias the same type.\n+// { dg-prune-output \"hash table checking failed\" }\n+\n namespace std {\n struct is_convertible;\n template <typename _Tp> using remove_pointer_t = typename _Tp ::type;"}]}