{"sha": "6c30752f0916390d06be4a7e46d8aea7407dd4c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmMzMDc1MmYwOTE2MzkwZDA2YmU0YTdlNDZkOGFlYTc0MDdkZDRjMQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-09-05T20:14:21Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-09-05T20:14:21Z"}, "message": "cp-tree.h (TI_PENDING_SPECIALIZATION_FLAG): Remove.\n\n\t* cp-tree.h (TI_PENDING_SPECIALIZATION_FLAG): Remove.\n\t* class.c (finish_struct): Remove hackery to deal with explicit\n\tspecializations in class scope.\n\t* decl.c (grokfndecl): Improve error-recovery.\n\t* decl2.c (grokfield): Likewise.\n\t* pt.c (check_specialization_scope): New function.\n\t(begin_specialization): Call it.\n\t(process_partial_specialization): New function, split out from\n\tpush_template_decl.  Check partial specializations more\n\tstringently.\n\t(push_template_decl): Call it.\n\t(check_explicit_specialization): Don't attempt to handle explicit\n\tspecializations in class scope.\n\t(template_parm_data): Document.  Add current_arg and\n\targ_uses_template_parms.\n\t(mark_template_parm): Set it.\n\t(tsubst_arg_types): Remove unused variable.\n\t* semantics.c (begin_class_definition): Tweak.\n\nFrom-SVN: r22271", "tree": {"sha": "d1d0fafc75e4f76e3e8d41616158cdd0406ba16f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d1d0fafc75e4f76e3e8d41616158cdd0406ba16f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c30752f0916390d06be4a7e46d8aea7407dd4c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c30752f0916390d06be4a7e46d8aea7407dd4c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c30752f0916390d06be4a7e46d8aea7407dd4c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c30752f0916390d06be4a7e46d8aea7407dd4c1/comments", "author": null, "committer": null, "parents": [{"sha": "00dd3ccd9bb42709b6f97f6e94fcbbf4392d57d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00dd3ccd9bb42709b6f97f6e94fcbbf4392d57d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00dd3ccd9bb42709b6f97f6e94fcbbf4392d57d9"}], "stats": {"total": 566, "additions": 373, "deletions": 193}, "files": [{"sha": "c092ea215c10908184095236267f70b46d45fac3", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c30752f0916390d06be4a7e46d8aea7407dd4c1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c30752f0916390d06be4a7e46d8aea7407dd4c1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6c30752f0916390d06be4a7e46d8aea7407dd4c1", "patch": "@@ -1,3 +1,24 @@\n+1998-09-05  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* cp-tree.h (TI_PENDING_SPECIALIZATION_FLAG): Remove.\n+\t* class.c (finish_struct): Remove hackery to deal with explicit\n+\tspecializations in class scope.\n+\t* decl.c (grokfndecl): Improve error-recovery.\n+\t* decl2.c (grokfield): Likewise.\n+\t* pt.c (check_specialization_scope): New function.\n+\t(begin_specialization): Call it.\n+\t(process_partial_specialization): New function, split out from\n+\tpush_template_decl.  Check partial specializations more\n+\tstringently.\n+\t(push_template_decl): Call it.\n+\t(check_explicit_specialization): Don't attempt to handle explicit\n+\tspecializations in class scope.\n+\t(template_parm_data): Document.  Add current_arg and\n+\targ_uses_template_parms. \n+\t(mark_template_parm): Set it.\n+\t(tsubst_arg_types): Remove unused variable.\n+\t* semantics.c (begin_class_definition): Tweak.\n+\t\n 1998-09-04  Mark Mitchell  <mark@markmitchell.com>\n \n \t* inc/typeinfo (type_info::type_info(const char*)): Make"}, {"sha": "173c69a283091ead42ba0d8d61d73cb895878ce2", "filename": "gcc/cp/class.c", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c30752f0916390d06be4a7e46d8aea7407dd4c1/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c30752f0916390d06be4a7e46d8aea7407dd4c1/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=6c30752f0916390d06be4a7e46d8aea7407dd4c1", "patch": "@@ -4148,8 +4148,6 @@ finish_struct (t, list_of_fieldlists, attributes, warn_anon)\n {\n   tree fields = NULL_TREE;\n   tree *tail = &TYPE_METHODS (t);\n-  tree specializations = NULL_TREE;\n-  tree *specialization_tail = &specializations;\n   tree name = TYPE_NAME (t);\n   tree x, last_x = NULL_TREE;\n   tree access;\n@@ -4259,19 +4257,6 @@ finish_struct (t, list_of_fieldlists, attributes, warn_anon)\n \t      if (last_x)\n \t\tTREE_CHAIN (last_x) = next_x;\n \n-\t      if (DECL_TEMPLATE_SPECIALIZATION (x))\n-\t\t/* We don't enter the specialization into the class\n-\t\t   method vector since specializations don't affect\n-\t\t   overloading.  Instead we keep track of the\n-\t\t   specializations, and process them after the method\n-\t\t   vector is complete.  */\n-\t\t{\n-\t\t  *specialization_tail = x;\n-\t\t  specialization_tail = &TREE_CHAIN (x);\n-\t\t  TREE_CHAIN (x) = NULL_TREE;\n-\t\t  continue;\n-\t\t}\n-\n \t      /* Link x onto end of TYPE_METHODS.  */\n \t      *tail = x;\n \t      tail = &TREE_CHAIN (x);\n@@ -4359,27 +4344,6 @@ finish_struct (t, list_of_fieldlists, attributes, warn_anon)\n     t = finish_struct_1 (t, warn_anon);\n \n   TYPE_BEING_DEFINED (t) = 0;\n-\n-  /* Now, figure out which member templates we're specializing.  */\n-  for (x = specializations; x != NULL_TREE; x = TREE_CHAIN (x))\n-    {\n-      int pending_specialization;\n-\n-      pending_specialization \n-\t= TI_PENDING_SPECIALIZATION_FLAG (DECL_TEMPLATE_INFO (x));\n-      check_explicit_specialization \n-\t(lookup_template_function (DECL_NAME (x), DECL_TI_ARGS (x)),\n-\t x, 0, 1 | (8 * pending_specialization));\n-      TI_PENDING_SPECIALIZATION_FLAG (DECL_TEMPLATE_INFO (x)) = 0;\n-\n-      /* Now, the assembler name will be correct for fn, so we\n-\t make its RTL.  */\n-      DECL_RTL (x) = 0;\n-      make_decl_rtl (x, NULL_PTR, 1);\n-      DECL_RTL (DECL_TI_TEMPLATE (x)) = 0;\n-      make_decl_rtl (DECL_TI_TEMPLATE (x), NULL_PTR, 1);\n-    }\n-\n   if (current_class_type)\n     popclass (0);\n   else"}, {"sha": "3c3a8588139a35f60b8931bb6288f566e5d6bf83", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c30752f0916390d06be4a7e46d8aea7407dd4c1/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c30752f0916390d06be4a7e46d8aea7407dd4c1/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=6c30752f0916390d06be4a7e46d8aea7407dd4c1", "patch": "@@ -35,7 +35,6 @@ Boston, MA 02111-1307, USA.  */\n       (TREE_MANGLED) (in IDENTIFIER_NODE) (commented-out).\n    1:  IDENTIFIER_VIRTUAL_P.\n       TI_PENDING_TEMPLATE_FLAG.\n-      TI_PENDING_SPECIALIZATION_FLAG.\n       TEMPLATE_PARMS_FOR_INLINE.\n       DELETE_EXPR_USE_VEC (in DELETE_EXPR).\n       (TREE_CALLS_NEW) (in _EXPR or _REF) (commented-out).\n@@ -1267,11 +1266,6 @@ struct lang_decl\n #define TI_SPEC_INFO(NODE) (TREE_CHAIN (NODE))\n #define TI_PENDING_TEMPLATE_FLAG(NODE) TREE_LANG_FLAG_1 (NODE)\n \n-/* TI_PENDING_SPECIALIZATION_FLAG on a template-info node indicates\n-   that the template is a specialization of a member template, but\n-   that we don't yet know which one.  */\n-#define TI_PENDING_SPECIALIZATION_FLAG(NODE) TREE_LANG_FLAG_1 (NODE)\n-\n /* The TEMPLATE_DECL instantiated or specialized by NODE.  This\n    TEMPLATE_DECL will be the immediate parent, not the most general\n    template.  For example, in:"}, {"sha": "42748ff151666c79f4d3875e90e3cf624b68b59d", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c30752f0916390d06be4a7e46d8aea7407dd4c1/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c30752f0916390d06be4a7e46d8aea7407dd4c1/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=6c30752f0916390d06be4a7e46d8aea7407dd4c1", "patch": "@@ -8016,6 +8016,8 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n \t\t\t\t\t    template_count, \n \t\t\t\t\t    2 * (funcdef_flag != 0) + \n \t\t\t\t\t    4 * (friendp != 0));\n+      if (decl == error_mark_node)\n+\treturn error_mark_node;\n \n       if ((! TYPE_FOR_JAVA (ctype) || check_java_method (ctype, decl))\n \t  && check)\n@@ -8063,6 +8065,9 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n \t\t\t\t\t    template_count, \n \t\t\t\t\t    2 * (funcdef_flag != 0) + \n \t\t\t\t\t    4 * (friendp != 0));\n+      if (decl == error_mark_node)\n+\treturn error_mark_node;\n+\n       if (ctype != NULL_TREE\n \t  && (! TYPE_FOR_JAVA (ctype) || check_java_method (ctype, decl))\n \t  && check)\n@@ -10392,10 +10397,15 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\tif (decl && DECL_NAME (decl))\n \t\t  {\n \t\t    if (template_class_depth (current_class_type) == 0)\n-\t\t      decl \n-\t\t\t= check_explicit_specialization \n-\t\t\t(declarator, decl,\n-\t\t\t template_count, 2 * (funcdef_flag != 0) + 4);\n+\t\t      {\n+\t\t\tdecl \n+\t\t\t  = check_explicit_specialization \n+\t\t\t  (declarator, decl,\n+\t\t\t   template_count, 2 * (funcdef_flag != 0) + 4);\n+\t\t\tif (decl == error_mark_node)\n+\t\t\t  return error_mark_node;\n+\t\t      }\n+\n \t\t    t = do_friend (ctype, declarator, decl,\n \t\t\t\t   last_function_parms, flags, quals,\n \t\t\t\t   funcdef_flag);"}, {"sha": "be8689ce189a2c48c2ea3a65824b2257a93a6bc7", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c30752f0916390d06be4a7e46d8aea7407dd4c1/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c30752f0916390d06be4a7e46d8aea7407dd4c1/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=6c30752f0916390d06be4a7e46d8aea7407dd4c1", "patch": "@@ -1606,8 +1606,8 @@ grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n     init = NULL_TREE;\n \n   value = grokdeclarator (declarator, declspecs, FIELD, init != 0, NULL_TREE);\n-  if (! value)\n-    return value; /* friend or constructor went bad.  */\n+  if (! value || value == error_mark_node)\n+    return NULL_TREE; /* friend or constructor went bad.  */\n \n   /* Pass friendly classes back.  */\n   if (TREE_CODE (value) == VOID_TYPE)"}, {"sha": "04c9fd65fdabfef2d543f57c3487f8b678a01f14", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 247, "deletions": 100, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c30752f0916390d06be4a7e46d8aea7407dd4c1/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c30752f0916390d06be4a7e46d8aea7407dd4c1/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=6c30752f0916390d06be4a7e46d8aea7407dd4c1", "patch": "@@ -127,6 +127,8 @@ static int template_class_depth_real PROTO((tree, int));\n static tree tsubst_aggr_type PROTO((tree, tree, tree, int));\n static tree tsubst_decl PROTO((tree, tree, tree, tree));\n static tree tsubst_arg_types PROTO((tree, tree, tree));\n+static void check_specialization_scope PROTO((void));\n+static tree process_partial_specialization PROTO((tree));\n \n /* We use TREE_VECs to hold template arguments.  If there is only one\n    level of template arguments, then the TREE_VEC contains the\n@@ -575,12 +577,44 @@ begin_template_parm_list ()\n   note_template_header (0);\n }\n \n+/* This routine is called when a specialization is declared.  If it is\n+   illegal to declare a specialization here, an error is reported.  */\n+\n+void\n+check_specialization_scope ()\n+{\n+  tree scope = current_scope ();\n+  /* [temp.expl.spec] \n+     \n+     An explicit specialization shall be declared in the namespace of\n+     which the template is a member, or, for member templates, in the\n+     namespace of which the enclosing class or enclosing class\n+     template is a member.  An explicit specialization of a member\n+     function, member class or static data member of a class template\n+     shall be declared in the namespace of which the class template\n+     is a member.  */\n+  if (scope && TREE_CODE (scope) != NAMESPACE_DECL)\n+    cp_error (\"explicit specialization in non-namespace scope `%D'\",\n+\t      scope);\n+  /* [temp.expl.spec] \n+\n+     In an explicit specialization declaration for a member of a class\n+     template or a member template that appears in namespace scope,\n+     the member template and some of its enclosing class templates may\n+     remain unspecialized, except that the declaration shall not\n+     explicitly specialize a class member template if its enclosing\n+     class templates are not explicitly specialized as well.  */\n+  if (current_template_parms) \n+    cp_error (\"enclosing class templates are not explicit specialized\");\n+}\n+\n /* We've just seen template <>. */\n \n void\n begin_specialization ()\n {\n   note_template_header (1);\n+  check_specialization_scope ();\n }\n \n /* Called at then end of processing a declaration preceeded by\n@@ -1209,17 +1243,10 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n       if (ctype != NULL_TREE && TYPE_BEING_DEFINED (ctype))\n \t{\n \t  if (!explicit_instantiation)\n-\t    {\n-\t      /* Since finish_struct_1 has not been called yet, we\n-\t\t can't call lookup_fnfields.  We note that this\n-\t\t template is a specialization, and proceed, letting\n-\t\t finish_struct fix this up later.  */\n-\t      tree ti = perm_tree_cons (NULL_TREE, \n-\t\t\t\t\tTREE_OPERAND (declarator, 1),\n-\t\t\t\t\tNULL_TREE);\n-\t      TI_PENDING_SPECIALIZATION_FLAG (ti) = 1;\n-\t      DECL_TEMPLATE_INFO (decl) = ti;\n-\t    }\n+\t    /* A specialization in class scope.  This is illegal,\n+\t       but the error will already have been flagged by\n+\t       check_specialization_scope.  */\n+\t    return error_mark_node;\n \t  else\n \t    /* It's not legal to write an explicit instantiation in\n \t       class scope, e.g.:\n@@ -1759,8 +1786,23 @@ build_template_decl (decl, parms)\n \n struct template_parm_data\n {\n+  /* The level of the template parameters we are currently\n+     processing.  */\n   int level;\n+\n+  /* The index of the specialization argument we are currently\n+     processing.  */\n+  int current_arg;\n+\n+  /* An array whose size is the number of template parameters.  The\n+     elements are non-zero if the parameter has been used in any one\n+     of the arguments processed so far.  */\n   int* parms;\n+\n+  /* An array whose size is the number of template arguments.  The\n+     elements are non-zero if the argument makes use of template\n+     parameters of this level.  */\n+  int* arg_uses_template_parms;\n };\n \n /* Subroutine of push_template_decl used to see if each template\n@@ -1790,13 +1832,205 @@ mark_template_parm (t, data)\n     }\n \n   if (level == tpd->level)\n-    tpd->parms[idx] = 1;\n+    {\n+      tpd->parms[idx] = 1;\n+      tpd->arg_uses_template_parms[tpd->current_arg] = 1;\n+    }\n \n   /* Return zero so that for_each_template_parm will continue the\n      traversal of the tree; we want to mark *every* template parm.  */\n   return 0;\n }\n \n+/* Process the partial specialization DECL.  */\n+\n+tree\n+process_partial_specialization (decl)\n+     tree decl;\n+{\n+  tree type = TREE_TYPE (decl);\n+  tree maintmpl = CLASSTYPE_TI_TEMPLATE (type);\n+  tree specargs = CLASSTYPE_TI_ARGS (type);\n+  tree inner_args = innermost_args (specargs);\n+  tree inner_parms = INNERMOST_TEMPLATE_PARMS (current_template_parms);\n+  tree main_inner_parms = DECL_INNERMOST_TEMPLATE_PARMS (maintmpl);\n+  int nargs = TREE_VEC_LENGTH (inner_args);\n+  int ntparms = TREE_VEC_LENGTH (inner_parms);\n+  int  i;\n+  int did_error_intro = 0;\n+  int issued_default_arg_message = 0;\n+  struct template_parm_data tpd;\n+  struct template_parm_data tpd2;\n+\n+  /* [temp.class.spec]\n+     \n+     The template parameter list of a specialization shall not\n+     contain default template argument values.  */\n+  for (i = 0; i < ntparms; ++i) \n+    {\n+      if (TREE_PURPOSE (TREE_VEC_ELT (inner_parms, i)))\n+\t{\n+\t  if (!issued_default_arg_message)\n+\t    {\n+\t      cp_error (\"default argument in partial specialization `%T'\", \n+\t\t\ttype);\n+\t      issued_default_arg_message = 1;\n+\t    }\n+\t  TREE_PURPOSE (TREE_VEC_ELT (inner_parms, i)) = NULL_TREE;\n+\t}\n+    }\n+\n+  /* We check that each of the template parameters given in the\n+     partial specialization is used in the argument list to the\n+     specialization.  For example:\n+\n+       template <class T> struct S;\n+       template <class T> struct S<T*>;\n+\n+     The second declaration is OK because `T*' uses the template\n+     parameter T, whereas\n+\n+       template <class T> struct S<int>;\n+\n+     is no good.  Even trickier is:\n+\n+       template <class T>\n+       struct S1\n+       {\n+\t  template <class U>\n+\t  struct S2;\n+\t  template <class U>\n+\t  struct S2<T>;\n+       };\n+\n+     The S2<T> declaration is actually illegal; it is a\n+     full-specialization.  Of course, \n+\n+\t  template <class U>\n+\t  struct S2<T (*)(U)>;\n+\n+     or some such would have been OK.  */\n+  tpd.level = TMPL_PARMS_DEPTH (current_template_parms);\n+  tpd.parms = alloca (sizeof (int) * ntparms);\n+  bzero (tpd.parms, sizeof (int) * nargs);\n+\n+  tpd.arg_uses_template_parms = alloca (sizeof (int) * nargs);\n+  bzero (tpd.arg_uses_template_parms, sizeof (int) * nargs);\n+  for (i = 0; i < nargs; ++i)\n+    {\n+      tpd.current_arg = i;\n+      for_each_template_parm (TREE_VEC_ELT (inner_args, i),\n+\t\t\t      &mark_template_parm,\n+\t\t\t      &tpd);\n+    }\n+  for (i = 0; i < ntparms; ++i)\n+    if (tpd.parms[i] == 0)\n+      {\n+\t/* One of the template parms was not used in the\n+           specialization.  */\n+\tif (!did_error_intro)\n+\t  {\n+\t    cp_error (\"template parameters not used in partial specialization:\");\n+\t    did_error_intro = 1;\n+\t  }\n+\n+\tcp_error (\"        `%D'\", \n+\t\t  TREE_VALUE (TREE_VEC_ELT (inner_parms, i)));\n+      }\n+\n+  /* [temp.class.spec]\n+\n+     The argument list of the specialization shall not be identical to\n+     the implicit argument list of the primary template.  */\n+  if (comp_template_args (inner_args, \n+\t\t\t  innermost_args (CLASSTYPE_TI_ARGS (TREE_TYPE\n+\t\t\t\t\t\t\t     (maintmpl)))))\n+    cp_error (\"partial specialization `%T' does not specialize any template arguments\", type);\n+\n+  /* [temp.class.spec]\n+\n+     A partially specialized non-type argument expression shall not\n+     involve template parameters of the partial specialization except\n+     when the argument expression is a simple identifier.\n+\n+     The type of a template parameter corresponding to a specialized\n+     non-type argument shall not be dependent on a parameter of the\n+     specialization.  */\n+  my_friendly_assert (nargs == DECL_NTPARMS (maintmpl), 0);\n+  tpd2.parms = 0;\n+  for (i = 0; i < nargs; ++i)\n+    {\n+      tree arg = TREE_VEC_ELT (inner_args, i);\n+      if (/* These first two lines are the `non-type' bit.  */\n+\t  TREE_CODE_CLASS (TREE_CODE (arg)) != 't'\n+\t  && TREE_CODE (arg) != TEMPLATE_DECL\n+\t  /* This next line is the `argument expression is not just a\n+\t     simple identifier' condition and also the `specialized\n+\t     non-type argument' bit.  */\n+\t  && TREE_CODE (arg) != TEMPLATE_PARM_INDEX)\n+\t{\n+\t  if (tpd.arg_uses_template_parms[i])\n+\t    cp_error (\"template argument `%E' involves template parameter(s)\", arg);\n+\t  else \n+\t    {\n+\t      /* Look at the corresponding template parameter,\n+\t\t marking which template parameters its type depends\n+\t\t upon.  */\n+\t      tree type = \n+\t\tTREE_TYPE (TREE_VALUE (TREE_VEC_ELT (main_inner_parms, \n+\t\t\t\t\t\t     i)));\n+\n+\t      if (!tpd2.parms)\n+\t\t{\n+\t\t  /* We haven't yet initialized TPD2.  Do so now.  */\n+\t\t  tpd2.arg_uses_template_parms \n+\t\t    =  (int*) alloca (sizeof (int) * nargs);\n+\t\t  tpd2.parms = (int*) alloca (sizeof (int) * nargs);\n+\t\t  tpd2.level = \n+\t\t    TMPL_PARMS_DEPTH (DECL_TEMPLATE_PARMS (maintmpl));\n+\t\t}\n+\n+\t      /* Mark the template paramters.  But this time, we're\n+\t\t looking for the template parameters of the main\n+\t\t template, not in the specialization.  */\n+\t      tpd2.current_arg = i;\n+\t      tpd2.arg_uses_template_parms[i] = 0;\n+\t      bzero (tpd.parms, sizeof (int) * nargs);\n+\t      for_each_template_parm (type,\n+\t\t\t\t      &mark_template_parm,\n+\t\t\t\t      &tpd2);\n+\t\t  \n+\t      if (tpd2.arg_uses_template_parms [i])\n+\t\t{\n+\t\t  /* The type depended on some template parameters.\n+\t\t     If they are fully specialized in the\n+\t\t     specialization, that's OK.  */\n+\t\t  int j;\n+\t\t  for (j = 0; j < nargs; ++j)\n+\t\t    if (tpd2.parms[j] != 0\n+\t\t\t&& tpd.arg_uses_template_parms [j])\n+\t\t      {\n+\t\t\tcp_error (\"type `%T' of template argument `%E' depends on template paramter(s)\", \n+\t\t\t\t  type,\n+\t\t\t\t  arg);\n+\t\t\tbreak;\n+\t\t      }\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  if (retrieve_specialization (maintmpl, specargs))\n+    /* We've already got this specialization.  */\n+    return decl;\n+\n+  DECL_TEMPLATE_SPECIALIZATIONS (maintmpl) = CLASSTYPE_TI_SPEC_INFO (type)\n+    = perm_tree_cons (inner_args, inner_parms,\n+\t\t      DECL_TEMPLATE_SPECIALIZATIONS (maintmpl));\n+  TREE_TYPE (DECL_TEMPLATE_SPECIALIZATIONS (maintmpl)) = type;\n+  return decl;\n+}\n+\n /* Creates a TEMPLATE_DECL for the indicated DECL using the template\n    parameters given by current_template_args, or reuses a\n    previously existing one, if appropriate.  Returns the DECL, or an\n@@ -1868,92 +2102,7 @@ push_template_decl_real (decl, is_friend)\n   if (TREE_CODE (decl) == TYPE_DECL && DECL_ARTIFICIAL (decl)\n       && TREE_CODE (TREE_TYPE (decl)) != ENUMERAL_TYPE\n       && CLASSTYPE_TEMPLATE_SPECIALIZATION (TREE_TYPE (decl)))\n-    {\n-      tree type = TREE_TYPE (decl);\n-      tree maintmpl = CLASSTYPE_TI_TEMPLATE (type);\n-      tree specargs = CLASSTYPE_TI_ARGS (type);\n-\n-      /* We check that each of the template parameters given in the\n-\t partial specialization is used in the argument list to the\n-\t specialization.  For example:\n-\t \n-\t   template <class T> struct S;\n-\t   template <class T> struct S<T*>;\n-\n-\t The second declaration is OK because `T*' uses the template\n-\t parameter T, whereas\n-       \n-           template <class T> struct S<int>;\n-\n-\t is no good.  Even trickier is:\n-\n-\t   template <class T>\n-\t   struct S1\n-\t   {\n-\t      template <class U>\n-\t      struct S2;\n-\t      template <class U>\n-\t      struct S2<T>;\n-\t   };\n-\t   \n-\t The S2<T> declaration is actually illegal; it is a\n-\t full-specialization.  Of course, \n-\n-              template <class U>\n-              struct S2<T (*)(U)>;\n-\n-         or some such would have been OK.  */\n-      int  i;\n-      struct template_parm_data tpd;\n-      int ntparms \n-\t= TREE_VEC_LENGTH (INNERMOST_TEMPLATE_PARMS (current_template_parms));\n-      int did_error_intro = 0;\n-\n-      tpd.level = TMPL_PARMS_DEPTH (current_template_parms);\n-      tpd.parms = alloca (sizeof (int) * ntparms);\n-      for (i = 0; i < ntparms; ++i)\n-\ttpd.parms[i] = 0;\n-      for (i = 0; i < TREE_VEC_LENGTH (specargs); ++i)\n-\tfor_each_template_parm (TREE_VEC_ELT (specargs, i),\n-\t\t\t\t&mark_template_parm,\n-\t\t\t\t&tpd);\n-      for (i = 0; i < ntparms; ++i)\n-\tif (tpd.parms[i] == 0)\n-\t  {\n-\t    /* One of the template parms was not used in the\n-\t       specialization.  */\n-\t    if (!did_error_intro)\n-\t      {\n-\t\tcp_error (\"template parameters not used in partial specialization:\");\n-\t\tdid_error_intro = 1;\n-\t      }\n-\n-\t    cp_error (\"        `%D'\", \n-\t\t      TREE_VALUE (TREE_VEC_ELT \n-\t\t\t\t  (TREE_VALUE (current_template_parms),\n-\t\t\t\t   i)));\n-\t  }\n-\n-      /* [temp.class.spec]\n-\n-\t The argument list of the specialization shall not be\n-\t identical to the implicit argument list of the primary\n-\t template.  */\n-      if (comp_template_args (specargs, \n-\t\t\t      CLASSTYPE_TI_ARGS (TREE_TYPE (maintmpl))))\n-\tcp_error (\"partial specialization `%T' does not specialize any template arguments\", type);\n-\t\t\t   \n-      if (retrieve_specialization (maintmpl, specargs))\n-\t/* We've already got this specialization.  */\n-\treturn decl;\n-\n-      DECL_TEMPLATE_SPECIALIZATIONS (maintmpl) = CLASSTYPE_TI_SPEC_INFO (type)\n-\t= perm_tree_cons (innermost_args (specargs),\n-\t\t\t  INNERMOST_TEMPLATE_PARMS (current_template_parms),\n-\t\t\t  DECL_TEMPLATE_SPECIALIZATIONS (maintmpl));\n-      TREE_TYPE (DECL_TEMPLATE_SPECIALIZATIONS (maintmpl)) = type;\n-      return decl;\n-    }\n+    return process_partial_specialization (decl);\n \n   args = current_template_args ();\n \n@@ -5194,7 +5343,6 @@ tsubst_decl (t, args, type, in_decl)\n   return r;\n }\n \n-\n /* Substitue into the ARG_TYPES of a function type.  */\n \n tree\n@@ -5204,7 +5352,6 @@ tsubst_arg_types (arg_types, args, in_decl)\n      tree in_decl;\n {\n   tree remaining_arg_types;\n-  tree result;\n   tree type;\n \n   if (!arg_types || arg_types == void_list_node)"}, {"sha": "eee6616698e05dcaec977b0f70440094ec4c2373", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c30752f0916390d06be4a7e46d8aea7407dd4c1/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c30752f0916390d06be4a7e46d8aea7407dd4c1/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=6c30752f0916390d06be4a7e46d8aea7407dd4c1", "patch": "@@ -1234,9 +1234,9 @@ begin_class_definition (t)\n       && TREE_CODE (TYPE_CONTEXT (t)) != NAMESPACE_DECL\n       && ! current_class_type)\n     push_template_decl (TYPE_STUB_DECL (t));\n+  maybe_process_partial_specialization (t);\n   pushclass (t, 0);\n   TYPE_BEING_DEFINED (t) = 1;\n-  maybe_process_partial_specialization (t);\n   /* Reset the interface data, at the earliest possible\n      moment, as it might have been set via a class foo;\n      before.  */"}, {"sha": "0defb196116e475b8ace8bfea6932547a17c6b9c", "filename": "gcc/testsuite/g++.old-deja/g++.pt/explicit12.C", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c30752f0916390d06be4a7e46d8aea7407dd4c1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c30752f0916390d06be4a7e46d8aea7407dd4c1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit12.C?ref=6c30752f0916390d06be4a7e46d8aea7407dd4c1", "patch": "@@ -5,11 +5,13 @@ struct S\n {\n   template <class T>\n   void foo(T t);\n-\n-  template <>\n-  void foo<int>(int) {}\n };\n \n+\n+template <>\n+template <>\n+void S<char*>::foo<int>(int) {}\n+\n int main()\n {\n   S<char*> s;"}, {"sha": "fbb790130385c6d578dd2c9310a8c5916309ceae", "filename": "gcc/testsuite/g++.old-deja/g++.pt/explicit13.C", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c30752f0916390d06be4a7e46d8aea7407dd4c1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c30752f0916390d06be4a7e46d8aea7407dd4c1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit13.C?ref=6c30752f0916390d06be4a7e46d8aea7407dd4c1", "patch": "@@ -7,13 +7,14 @@ struct S\n   template <class T>\n   void foo(T t);\n \n-  template <>\n-  void foo(int) { }\n-\n   template <class T>\n   void bar(T t) { this->template foo<U>(3.74); }\n };\n \n+template <>\n+template <>\n+void S<int>::foo(int) { }\n+\n int main()\n {\n   S<int> s;"}, {"sha": "c9282632aa182938a97cd0433ba362cf09577004", "filename": "gcc/testsuite/g++.old-deja/g++.pt/explicit35.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c30752f0916390d06be4a7e46d8aea7407dd4c1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit35.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c30752f0916390d06be4a7e46d8aea7407dd4c1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit35.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit35.C?ref=6c30752f0916390d06be4a7e46d8aea7407dd4c1", "patch": "@@ -4,11 +4,11 @@ struct S\n {\n   template <class T>\n   void foo(T t);\n-\n-  template <>\n-  void foo<int>(int i) { }\n };\n \n+template <>\n+void S::foo<int>(int i) { }\n+\n int main()\n {\n   S s;"}, {"sha": "1a5cabe67a158e11b3e1afde45df101d2938efe3", "filename": "gcc/testsuite/g++.old-deja/g++.pt/memclass7.C", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c30752f0916390d06be4a7e46d8aea7407dd4c1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemclass7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c30752f0916390d06be4a7e46d8aea7407dd4c1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemclass7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemclass7.C?ref=6c30752f0916390d06be4a7e46d8aea7407dd4c1", "patch": "@@ -4,12 +4,13 @@ struct S\n   struct Y {\n     template <class T>\n     void foo(T t);\n-\n-    template <>\n-    void foo<int>(int i) { }\n   };\n };\n \n+template <>\n+template <>\n+void S::Y<char>::foo<int>(int i) { }\n+\n int main()\n {\n   S::Y<char> s;"}, {"sha": "1fdb055b3574a94d70ca5f6f5a05538781ab446b", "filename": "gcc/testsuite/g++.old-deja/g++.pt/memtemp61.C", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c30752f0916390d06be4a7e46d8aea7407dd4c1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemtemp61.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c30752f0916390d06be4a7e46d8aea7407dd4c1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemtemp61.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemtemp61.C?ref=6c30752f0916390d06be4a7e46d8aea7407dd4c1", "patch": "@@ -4,9 +4,6 @@ struct S\n {\n   template <class T>\n   void foo(T t);\n-  \n-  template <>\n-  void foo(int i);\n };\n \n "}, {"sha": "8cfadeffd3ec82fd8b4b92474d7e2ba436194af9", "filename": "gcc/testsuite/g++.old-deja/g++.pt/memtemp62.C", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c30752f0916390d06be4a7e46d8aea7407dd4c1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemtemp62.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c30752f0916390d06be4a7e46d8aea7407dd4c1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemtemp62.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemtemp62.C?ref=6c30752f0916390d06be4a7e46d8aea7407dd4c1", "patch": "@@ -4,9 +4,6 @@ struct S\n {\n   template <class T>\n   void foo(T t);\n-  \n-  template <>\n-  void foo(int i);\n };\n \n "}, {"sha": "ca4cf20e7dfb75831741d07f6b9f56cbcf5658ca", "filename": "gcc/testsuite/g++.old-deja/g++.pt/memtemp77.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c30752f0916390d06be4a7e46d8aea7407dd4c1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemtemp77.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c30752f0916390d06be4a7e46d8aea7407dd4c1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemtemp77.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemtemp77.C?ref=6c30752f0916390d06be4a7e46d8aea7407dd4c1", "patch": "@@ -7,9 +7,9 @@ struct S3\n   static char* h(U);\n };\n \n-template <class T>\n template <>\n-char* S3<T>::h(int) { return __PRETTY_FUNCTION__; }\n+template <>\n+char* S3<double>::h(int) { return __PRETTY_FUNCTION__; }\n \n template <>\n template <>"}, {"sha": "5d53e2d76b1ddbd268cd8f7f1b5a97c6489a1f74", "filename": "gcc/testsuite/g++.old-deja/g++.pt/spec10.C", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c30752f0916390d06be4a7e46d8aea7407dd4c1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c30752f0916390d06be4a7e46d8aea7407dd4c1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec10.C?ref=6c30752f0916390d06be4a7e46d8aea7407dd4c1", "patch": "@@ -5,14 +5,15 @@ struct S\n {\n   template <int i>\n   int f(int j) { abort(); return 0; }\n-\n-  template <>\n-  int f<7>(int j) { return j + 7; }\n-\n-  template <>\n-  int f<8>(int j) { return j + 8; }\n };\n \n+template <>\n+template <>\n+int S<double>::f<7>(int j) { return j + 7; }\n+\n+template <>\n+template <>\n+int S<double>::f<8>(int j) { return j + 8; }\n \n int main()\n {"}, {"sha": "340b58e73ec5f0fef4f0eece790d49fa26fcc5d3", "filename": "gcc/testsuite/g++.old-deja/g++.pt/spec11.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c30752f0916390d06be4a7e46d8aea7407dd4c1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c30752f0916390d06be4a7e46d8aea7407dd4c1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec11.C?ref=6c30752f0916390d06be4a7e46d8aea7407dd4c1", "patch": "@@ -7,9 +7,9 @@ struct S\n   int f(U u);\n };\n \n-template <class T>\n template <>\n-int S<T>::f(int i) { return 1; }\n+template <>\n+int S<char>::f(int i) { return 1; }\n \n int main()\n {"}, {"sha": "d9c39654e93a59838115d50e518bcbf7ee6d7c3e", "filename": "gcc/testsuite/g++.old-deja/g++.pt/spec12.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c30752f0916390d06be4a7e46d8aea7407dd4c1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c30752f0916390d06be4a7e46d8aea7407dd4c1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec12.C?ref=6c30752f0916390d06be4a7e46d8aea7407dd4c1", "patch": "@@ -8,9 +8,9 @@ struct S\n };\n \n \n-template <class T>\n template <>\n-int S<T>::f<int>(int i) { return 1; }\n+template <>\n+int S<char>::f<int>(int i) { return 1; }\n \n int main()\n {"}, {"sha": "e5748f56c14ed373a38dc6137b23c3ca18552ce6", "filename": "gcc/testsuite/g++.old-deja/g++.pt/spec13.C", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c30752f0916390d06be4a7e46d8aea7407dd4c1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c30752f0916390d06be4a7e46d8aea7407dd4c1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec13.C?ref=6c30752f0916390d06be4a7e46d8aea7407dd4c1", "patch": "@@ -14,11 +14,11 @@ struct S1\n \n   template <class T>\n   void f(T* t);\n-\n-  template <>\n-  void f(int* ip) {}\n };\n \n+template <>\n+void S1::f(int* ip) {}\n+\n template <class U>\n struct S2\n {\n@@ -27,11 +27,12 @@ struct S2\n \n   template <class T>\n   void f(T* t);\n-\n-  template <>\n-  void f(int* ip) {}\n };\n \n+template <>\n+template <>\n+void S2<double>::f(int* ip) {}\n+\n int main()\n {\n   int* ip;"}, {"sha": "2e97b04626534f6c80f592f434e63d84c828e0e2", "filename": "gcc/testsuite/g++.old-deja/g++.pt/spec15.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c30752f0916390d06be4a7e46d8aea7407dd4c1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c30752f0916390d06be4a7e46d8aea7407dd4c1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec15.C?ref=6c30752f0916390d06be4a7e46d8aea7407dd4c1", "patch": "@@ -28,9 +28,9 @@ struct S3\n   static int h(U);\n };\n \n-template <class T>\n template <>\n-int S3<T>::h(int) { return 0; }\n+template <>\n+int S3<double>::h(int) { return 0; }\n \n template <>\n template <>"}, {"sha": "497a32d7554642473c924692550d3ee40a705fef", "filename": "gcc/testsuite/g++.old-deja/g++.pt/spec20.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c30752f0916390d06be4a7e46d8aea7407dd4c1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec20.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c30752f0916390d06be4a7e46d8aea7407dd4c1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec20.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec20.C?ref=6c30752f0916390d06be4a7e46d8aea7407dd4c1", "patch": "@@ -0,0 +1,11 @@\n+// Build don't link:\n+\n+template <class T> \n+struct S {\n+  template <class U> void f(U);\n+  template <> void f<int>(int); // ERROR - specialization\n+\n+  template <class V> struct I {};\n+  template <class V> struct I<V*> {};\n+  template <> struct I<int>; // ERROR - specialization\n+};"}, {"sha": "95e12d2f923189cbe14f5776eaa031dc52fa5761", "filename": "gcc/testsuite/g++.old-deja/g++.pt/spec21.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c30752f0916390d06be4a7e46d8aea7407dd4c1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec21.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c30752f0916390d06be4a7e46d8aea7407dd4c1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec21.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec21.C?ref=6c30752f0916390d06be4a7e46d8aea7407dd4c1", "patch": "@@ -0,0 +1,16 @@\n+// Build don't link:\n+\n+template <class T> struct S {};\n+template <class T = int> struct S<T*> {}; // ERROR - default argument\n+\n+template <int I, int J> struct A {};\n+template <int I> struct A<I+5, I*2> {}; // ERROR - argument involves parameter\n+\n+template <class T, T t> struct C {};\n+template <class T> struct C<T, 1>;  // ERROR - type depends on parameter\n+int i;\n+template <class T> struct C<T*, &i>; // ERROR - type depends on parameter\n+\n+template< int X, int (*array_ptr)[X] > class B {};\n+int array[5];\n+template< int X > class B<X,&array> { }; // ERROR - type depends on parameter"}, {"sha": "88d55d38db6c1539acee1667e5c58de96c8f0646", "filename": "gcc/testsuite/g++.old-deja/g++.pt/spec22.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c30752f0916390d06be4a7e46d8aea7407dd4c1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec22.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c30752f0916390d06be4a7e46d8aea7407dd4c1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec22.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec22.C?ref=6c30752f0916390d06be4a7e46d8aea7407dd4c1", "patch": "@@ -0,0 +1,15 @@\n+// Build don't link:\n+\n+template <class T>\n+struct S\n+{\n+  template <class U>\n+  void f();\n+};\n+\n+\n+template <class T> \n+template <> // ERROR - enclosing classes not specialized\n+void S<T>::f<int> () \n+{\n+}"}, {"sha": "4ef8e651594a1a95fffbedf57845b097647d34ef", "filename": "gcc/testsuite/g++.old-deja/g++.pt/spec6.C", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c30752f0916390d06be4a7e46d8aea7407dd4c1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c30752f0916390d06be4a7e46d8aea7407dd4c1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec6.C?ref=6c30752f0916390d06be4a7e46d8aea7407dd4c1", "patch": "@@ -4,21 +4,23 @@ struct S1\n {\n   template <class T>\n   void f(T t1, T t2);\n-\n-  template <>\n-  void f(int i1, int i2);\n };\n \n+\n+template <>\n+void S1::f(int i1, int i2);\n+\n template <class U>\n struct S2\n {\n   template <class T>\n   void f(T t1, T t2);\n-\n-  template <>\n-  void f(int i1, int i2);\n };\n \n+template <>\n+template <>\n+void S2<char>::f(int i1, int i2);\n+\n void h()\n {\n   S1 s1;"}]}