{"sha": "3b26fe826601cd43b8a4e7b1b29114034bd3eabb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2IyNmZlODI2NjAxY2Q0M2I4YTRlN2IxYjI5MTE0MDM0YmQzZWFiYg==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2018-05-22T13:26:11Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-05-22T13:26:11Z"}, "message": "[Ada] In-place initialization for Initialize_Scalars\n\nThis patch cleans up the implementation of routine Get_Simple_Init_Val. It also\neliminates potentially large and unnecessary tree replications in the context\nof object default initialization.\n\nNo change in behavior, no test needed.\n\n2018-05-22  Hristian Kirtchev  <kirtchev@adacore.com>\n\ngcc/ada/\n\n\t* exp_ch3.adb (Build_Array_Init_Proc): Update the call to\n\tNeeds_Simple_Initialization.\n\t(Build_Init_Statements): Update the call to Get_Simple_Init_Val.\n\t(Check_Subtype_Bounds): Renamed to Extract_Subtype_Bounds. Update the\n\tprofile and comment on usage.\n\t(Default_Initialize_Object): Do not use New_Copy_Tree to set the proper\n\tSloc of a value obtained from aspect Default_Value because this could\n\tpotentially replicate large trees. The proper Sloc is now set in\n\tGet_Simple_Init_Val.\n\t(Get_Simple_Init_Val): Reorganized by breaking the various cases into\n\tseparate routines. Eliminate the use of global variables.\n\t(Init_Component): Update the call to Get_Simple_Init_Val.\n\t(Needs_Simple_Initialization): Update the parameter profile and all\n\tuses of T.\n\t(Simple_Init_Defaulted_Type): Copy the value of aspect Default_Value\n\tand set the proper Sloc.\n\t* exp_ch3.ads (Get_Simple_Init_Val): Update the parameter profile and\n\tcomment on usage.\n\t(Needs_Simple_Initialization): Update the parameter profile.\n\nFrom-SVN: r260526", "tree": {"sha": "5a1b1b59602fcad68dcf6ee7a934106b6adb7f06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a1b1b59602fcad68dcf6ee7a934106b6adb7f06"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b26fe826601cd43b8a4e7b1b29114034bd3eabb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b26fe826601cd43b8a4e7b1b29114034bd3eabb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b26fe826601cd43b8a4e7b1b29114034bd3eabb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b26fe826601cd43b8a4e7b1b29114034bd3eabb/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "59ec5d9be29535f41ecd7840fcb11708edd584f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59ec5d9be29535f41ecd7840fcb11708edd584f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59ec5d9be29535f41ecd7840fcb11708edd584f3"}], "stats": {"total": 628, "additions": 386, "deletions": 242}, "files": [{"sha": "5a0cf04996296553704c66c588e497212af1a0c6", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b26fe826601cd43b8a4e7b1b29114034bd3eabb/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b26fe826601cd43b8a4e7b1b29114034bd3eabb/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=3b26fe826601cd43b8a4e7b1b29114034bd3eabb", "patch": "@@ -1,3 +1,25 @@\n+2018-05-22  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch3.adb (Build_Array_Init_Proc): Update the call to\n+\tNeeds_Simple_Initialization.\n+\t(Build_Init_Statements): Update the call to Get_Simple_Init_Val.\n+\t(Check_Subtype_Bounds): Renamed to Extract_Subtype_Bounds. Update the\n+\tprofile and comment on usage.\n+\t(Default_Initialize_Object): Do not use New_Copy_Tree to set the proper\n+\tSloc of a value obtained from aspect Default_Value because this could\n+\tpotentially replicate large trees. The proper Sloc is now set in\n+\tGet_Simple_Init_Val.\n+\t(Get_Simple_Init_Val): Reorganized by breaking the various cases into\n+\tseparate routines. Eliminate the use of global variables.\n+\t(Init_Component): Update the call to Get_Simple_Init_Val.\n+\t(Needs_Simple_Initialization): Update the parameter profile and all\n+\tuses of T.\n+\t(Simple_Init_Defaulted_Type): Copy the value of aspect Default_Value\n+\tand set the proper Sloc.\n+\t* exp_ch3.ads (Get_Simple_Init_Val): Update the parameter profile and\n+\tcomment on usage.\n+\t(Needs_Simple_Initialization): Update the parameter profile.\n+\n 2018-05-22  Patrick Bernardi  <bernardi@adacore.com>\n \n \t* sem_ch3.adb (Build_Discriminant_Constraints): Raise an error if the"}, {"sha": "a43166b88815b4018e6f0ee7c91b72811ef401c3", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 343, "deletions": 225, "changes": 568, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b26fe826601cd43b8a4e7b1b29114034bd3eabb/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b26fe826601cd43b8a4e7b1b29114034bd3eabb/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=3b26fe826601cd43b8a4e7b1b29114034bd3eabb", "patch": "@@ -520,7 +520,7 @@ package body Exp_Ch3 is\n       Comp_Type        : constant Entity_Id := Component_Type (A_Type);\n       Comp_Simple_Init : constant Boolean   :=\n         Needs_Simple_Initialization\n-          (T           => Comp_Type,\n+          (Typ         => Comp_Type,\n            Consider_IS =>\n              not (Validity_Check_Copies and Is_Bit_Packed_Array (A_Type)));\n       --  True if the component needs simple initialization, based on its type,\n@@ -576,13 +576,17 @@ package body Exp_Ch3 is\n                 Name       => Comp,\n                 Expression =>\n                   Get_Simple_Init_Val\n-                    (Comp_Type, Nod, Component_Size (A_Type))));\n+                    (Typ  => Comp_Type,\n+                     N    => Nod,\n+                     Size => Component_Size (A_Type))));\n \n          else\n             Clean_Task_Names (Comp_Type, Proc_Id);\n             return\n               Build_Initialization_Call\n-                (Loc, Comp, Comp_Type,\n+                (Loc          => Loc,\n+                 Id_Ref       => Comp,\n+                 Typ          => Comp_Type,\n                  In_Init_Proc => True,\n                  Enclos_Type  => A_Type);\n          end if;\n@@ -3106,7 +3110,12 @@ package body Exp_Ch3 is\n                elsif Component_Needs_Simple_Initialization (Typ) then\n                   Actions :=\n                     Build_Assignment\n-                      (Id, Get_Simple_Init_Val (Typ, N, Esize (Id)));\n+                      (Id      => Id,\n+                       Default =>\n+                         Get_Simple_Init_Val\n+                           (Typ  => Typ,\n+                            N    => N,\n+                            Size => Esize (Id)));\n \n                --  Nothing needed for this case\n \n@@ -3277,7 +3286,12 @@ package body Exp_Ch3 is\n                   elsif Component_Needs_Simple_Initialization (Typ) then\n                      Append_List_To (Stmts,\n                        Build_Assignment\n-                         (Id, Get_Simple_Init_Val (Typ, N, Esize (Id))));\n+                         (Id      => Id,\n+                          Default =>\n+                            Get_Simple_Init_Val\n+                              (Typ  => Typ,\n+                               N    => N,\n+                               Size => Esize (Id))));\n                   end if;\n                end if;\n \n@@ -6004,9 +6018,9 @@ package body Exp_Ch3 is\n            and then not Initialization_Suppressed (Typ)\n          then\n             --  Do not initialize the components if No_Default_Initialization\n-            --  applies as the actual restriction check will occur later\n-            --  when the object is frozen as it is not known yet whether the\n-            --  object is imported or not.\n+            --  applies as the actual restriction check will occur later when\n+            --  the object is frozen as it is not known yet whether the object\n+            --  is imported or not.\n \n             if not Restriction_Active (No_Default_Initialization) then\n \n@@ -6016,8 +6030,8 @@ package body Exp_Ch3 is\n                Aggr_Init := Static_Initialization (Base_Init_Proc (Typ));\n \n                if Present (Aggr_Init) then\n-                  Set_Expression\n-                    (N, New_Copy_Tree (Aggr_Init, New_Scope => Current_Scope));\n+                  Set_Expression (N,\n+                    New_Copy_Tree (Aggr_Init, New_Scope => Current_Scope));\n \n                --  If type has discriminants, try to build an equivalent\n                --  aggregate using discriminant values from the declaration.\n@@ -6053,9 +6067,10 @@ package body Exp_Ch3 is\n          then\n             Set_No_Initialization (N, False);\n             Set_Expression (N,\n-              New_Copy_Tree\n-                (Source   => Get_Simple_Init_Val (Typ, N, Esize (Def_Id)),\n-                 New_Sloc => Sloc (Obj_Def)));\n+              Get_Simple_Init_Val\n+                (Typ  => Typ,\n+                 N    => Obj_Def,\n+                 Size => Esize (Def_Id)));\n \n             Analyze_And_Resolve (Expression (N), Typ);\n          end if;\n@@ -7916,55 +7931,74 @@ package body Exp_Ch3 is\n    -------------------------\n \n    function Get_Simple_Init_Val\n-     (T    : Entity_Id;\n+     (Typ  : Entity_Id;\n       N    : Node_Id;\n       Size : Uint := No_Uint) return Node_Id\n    is\n-      Loc    : constant Source_Ptr := Sloc (N);\n-      Val    : Node_Id;\n-      Result : Node_Id;\n-      Val_RE : RE_Id;\n-\n-      Size_To_Use : Uint;\n-      --  This is the size to be used for computation of the appropriate\n-      --  initial value for the Normalize_Scalars and Initialize_Scalars case.\n-\n       IV_Attribute : constant Boolean :=\n                        Nkind (N) = N_Attribute_Reference\n                          and then Attribute_Name (N) = Name_Invalid_Value;\n \n-      Lo_Bound : Uint;\n-      Hi_Bound : Uint;\n-      --  These are the values computed by the procedure Check_Subtype_Bounds\n+      Loc : constant Source_Ptr := Sloc (N);\n+\n+      procedure Extract_Subtype_Bounds\n+        (Lo_Bound : out Uint;\n+         Hi_Bound : out Uint);\n+      --  Inspect subtype Typ as well its ancestor subtypes and derived types\n+      --  to determine the best known information about the bounds of the type.\n+      --  The output parameters are set as follows:\n+      --\n+      --    * Lo_Bound - Set to No_Unit when there is no information available,\n+      --      or to the known low bound.\n+      --\n+      --    * Hi_Bound - Set to No_Unit when there is no information available,\n+      --      or to the known high bound.\n+\n+      function Simple_Init_Defaulted_Type return Node_Id;\n+      --  Build an expression to initialize type Typ which is subject to\n+      --  aspect Default_Value.\n \n-      procedure Check_Subtype_Bounds;\n-      --  This procedure examines the subtype T, and its ancestor subtypes and\n-      --  derived types to determine the best known information about the\n-      --  bounds of the subtype. After the call Lo_Bound is set either to\n-      --  No_Uint if no information can be determined, or to a value which\n-      --  represents a known low bound, i.e. a valid value of the subtype can\n-      --  not be less than this value. Hi_Bound is similarly set to a known\n-      --  high bound (valid value cannot be greater than this).\n+      function Simple_Init_Initialize_Scalars_Type\n+        (Size_To_Use : Uint) return Node_Id;\n+      --  Build an expression to initialize scalar type Typ which is subject to\n+      --  pragma Initialize_Scalars. Size_To_Use is the size of the object.\n \n-      --------------------------\n-      -- Check_Subtype_Bounds --\n-      --------------------------\n+      function Simple_Init_Normalize_Scalars_Type\n+        (Size_To_Use : Uint) return Node_Id;\n+      --  Build an expression to initialize scalar type Typ which is subject to\n+      --  pragma Normalize_Scalars. Size_To_Use is the size of the object.\n \n-      procedure Check_Subtype_Bounds is\n-         ST1  : Entity_Id;\n-         ST2  : Entity_Id;\n-         Lo   : Node_Id;\n-         Hi   : Node_Id;\n-         Loval : Uint;\n-         Hival : Uint;\n+      function Simple_Init_Private_Type return Node_Id;\n+      --  Build an expression to initialize private type Typ\n+\n+      function Simple_Init_Scalar_Type return Node_Id;\n+      --  Build an expression to initialize scalar type Typ\n+\n+      function Simple_Init_String_Type return Node_Id;\n+      --  Build an expression to initialize string type Typ\n+\n+      ----------------------------\n+      -- Extract_Subtype_Bounds --\n+      ----------------------------\n+\n+      procedure Extract_Subtype_Bounds\n+        (Lo_Bound : out Uint;\n+         Hi_Bound : out Uint)\n+      is\n+         ST1    : Entity_Id;\n+         ST2    : Entity_Id;\n+         Lo     : Node_Id;\n+         Hi     : Node_Id;\n+         Lo_Val : Uint;\n+         Hi_Val : Uint;\n \n       begin\n          Lo_Bound := No_Uint;\n          Hi_Bound := No_Uint;\n \n          --  Loop to climb ancestor subtypes and derived types\n \n-         ST1 := T;\n+         ST1 := Typ;\n          loop\n             if not Is_Discrete_Type (ST1) then\n                return;\n@@ -7974,18 +8008,18 @@ package body Exp_Ch3 is\n             Hi := Type_High_Bound (ST1);\n \n             if Compile_Time_Known_Value (Lo) then\n-               Loval := Expr_Value (Lo);\n+               Lo_Val := Expr_Value (Lo);\n \n-               if Lo_Bound = No_Uint or else Lo_Bound < Loval then\n-                  Lo_Bound := Loval;\n+               if Lo_Bound = No_Uint or else Lo_Bound < Lo_Val then\n+                  Lo_Bound := Lo_Val;\n                end if;\n             end if;\n \n             if Compile_Time_Known_Value (Hi) then\n-               Hival := Expr_Value (Hi);\n+               Hi_Val := Expr_Value (Hi);\n \n-               if Hi_Bound = No_Uint or else Hi_Bound > Hival then\n-                  Hi_Bound := Hival;\n+               if Hi_Bound = No_Uint or else Hi_Bound > Hi_Val then\n+                  Hi_Bound := Hi_Val;\n                end if;\n             end if;\n \n@@ -7998,243 +8032,327 @@ package body Exp_Ch3 is\n             exit when ST1 = ST2;\n             ST1 := ST2;\n          end loop;\n-      end Check_Subtype_Bounds;\n+      end Extract_Subtype_Bounds;\n \n-   --  Start of processing for Get_Simple_Init_Val\n+      --------------------------------\n+      -- Simple_Init_Defaulted_Type --\n+      --------------------------------\n \n-   begin\n-      --  For a private type, we should always have an underlying type (because\n-      --  this was already checked in Needs_Simple_Initialization). What we do\n-      --  is to get the value for the underlying type and then do an unchecked\n-      --  conversion to the private type.\n+      function Simple_Init_Defaulted_Type return Node_Id is\n+         Subtyp : constant Entity_Id := First_Subtype (Typ);\n \n-      if Is_Private_Type (T) then\n-         Val := Get_Simple_Init_Val (Underlying_Type (T), N, Size);\n+      begin\n+         --  Use the Sloc of the context node when constructing the initial\n+         --  value because the expression of Default_Value may come from a\n+         --  different unit. Updating the Sloc will result in accurate error\n+         --  diagnostics.\n \n-         --  A special case, if the underlying value is null, then qualify it\n-         --  with the underlying type, so that the null is properly typed.\n-         --  Similarly, if it is an aggregate it must be qualified, because an\n-         --  unchecked conversion does not provide a context for it.\n+         --  When the first subtype is private, retrieve the expression of the\n+         --  Default_Value from the underlying type.\n \n-         if Nkind_In (Val, N_Null, N_Aggregate) then\n-            Val :=\n-              Make_Qualified_Expression (Loc,\n-                Subtype_Mark =>\n-                  New_Occurrence_Of (Underlying_Type (T), Loc),\n-                Expression => Val);\n+         if Is_Private_Type (Subtyp) then\n+            return\n+              Unchecked_Convert_To\n+                (Typ  => Typ,\n+                 Expr =>\n+                   New_Copy_Tree\n+                     (Source   => Default_Aspect_Value (Full_View (Subtyp)),\n+                      New_Sloc => Loc));\n+\n+         else\n+            return\n+              Convert_To\n+                (Typ  => Typ,\n+                 Expr =>\n+                   New_Copy_Tree\n+                     (Source   => Default_Aspect_Value (Subtyp),\n+                      New_Sloc => Loc));\n          end if;\n+      end Simple_Init_Defaulted_Type;\n \n-         Result := Unchecked_Convert_To (T, Val);\n+      -----------------------------------------\n+      -- Simple_Init_Initialize_Scalars_Type --\n+      -----------------------------------------\n \n-         --  Don't truncate result (important for Initialize/Normalize_Scalars)\n+      function Simple_Init_Initialize_Scalars_Type\n+        (Size_To_Use : Uint) return Node_Id\n+      is\n+         Float_Typ : Entity_Id;\n+         Hi_Bound  : Uint;\n+         Lo_Bound  : Uint;\n+         Val_RE    : RE_Id;\n \n-         if Nkind (Result) = N_Unchecked_Type_Conversion\n-           and then Is_Scalar_Type (Underlying_Type (T))\n-         then\n-            Set_No_Truncation (Result);\n-         end if;\n+      begin\n+         Extract_Subtype_Bounds (Lo_Bound, Hi_Bound);\n \n-         return Result;\n+         --  For float types, use float values from System.Scalar_Values\n \n-      --  Scalars with Default_Value aspect. The first subtype may now be\n-      --  private, so retrieve value from underlying type.\n+         if Is_Floating_Point_Type (Typ) then\n+            Float_Typ := Root_Type (Typ);\n \n-      elsif Is_Scalar_Type (T) and then Has_Default_Aspect (T) then\n-         if Is_Private_Type (First_Subtype (T)) then\n-            return Unchecked_Convert_To (T,\n-              Default_Aspect_Value (Full_View (First_Subtype (T))));\n-         else\n-            return\n-              Convert_To (T, Default_Aspect_Value (First_Subtype (T)));\n-         end if;\n+            if Float_Typ = Standard_Short_Float then\n+               Val_RE := RE_IS_Isf;\n+            elsif Float_Typ = Standard_Float then\n+               Val_RE := RE_IS_Ifl;\n+            elsif Float_Typ = Standard_Long_Float then\n+               Val_RE := RE_IS_Ilf;\n+            else pragma Assert (Float_Typ = Standard_Long_Long_Float);\n+               Val_RE := RE_IS_Ill;\n+            end if;\n \n-      --  Otherwise, for scalars, we must have normalize/initialize scalars\n-      --  case, or if the node N is an 'Invalid_Value attribute node.\n+         --  If zero is invalid, use zero values from System.Scalar_Values\n \n-      elsif Is_Scalar_Type (T) then\n-         pragma Assert (Init_Or_Norm_Scalars or IV_Attribute);\n+         elsif Lo_Bound /= No_Uint and then Lo_Bound > Uint_0 then\n+            if Size_To_Use <= 8 then\n+               Val_RE := RE_IS_Iz1;\n+            elsif Size_To_Use <= 16 then\n+               Val_RE := RE_IS_Iz2;\n+            elsif Size_To_Use <= 32 then\n+               Val_RE := RE_IS_Iz4;\n+            else\n+               Val_RE := RE_IS_Iz8;\n+            end if;\n \n-         --  Compute size of object. If it is given by the caller, we can use\n-         --  it directly, otherwise we use Esize (T) as an estimate. As far as\n-         --  we know this covers all cases correctly.\n+         --  For unsigned, use unsigned values from System.Scalar_Values\n+\n+         elsif Is_Unsigned_Type (Typ) then\n+            if Size_To_Use <= 8 then\n+               Val_RE := RE_IS_Iu1;\n+            elsif Size_To_Use <= 16 then\n+               Val_RE := RE_IS_Iu2;\n+            elsif Size_To_Use <= 32 then\n+               Val_RE := RE_IS_Iu4;\n+            else\n+               Val_RE := RE_IS_Iu8;\n+            end if;\n+\n+         --  For signed, use signed values from System.Scalar_Values\n \n-         if Size = No_Uint or else Size <= Uint_0 then\n-            Size_To_Use := UI_Max (Uint_1, Esize (T));\n          else\n-            Size_To_Use := Size;\n+            if Size_To_Use <= 8 then\n+               Val_RE := RE_IS_Is1;\n+            elsif Size_To_Use <= 16 then\n+               Val_RE := RE_IS_Is2;\n+            elsif Size_To_Use <= 32 then\n+               Val_RE := RE_IS_Is4;\n+            else\n+               Val_RE := RE_IS_Is8;\n+            end if;\n          end if;\n \n-         --  Maximum size to use is 64 bits, since we will create values of\n-         --  type Unsigned_64 and the range must fit this type.\n+         return New_Occurrence_Of (RTE (Val_RE), Loc);\n+      end Simple_Init_Initialize_Scalars_Type;\n \n-         if Size_To_Use /= No_Uint and then Size_To_Use > Uint_64 then\n-            Size_To_Use := Uint_64;\n-         end if;\n+      ----------------------------------------\n+      -- Simple_Init_Normalize_Scalars_Type --\n+      ----------------------------------------\n \n-         --  Check known bounds of subtype\n+      function Simple_Init_Normalize_Scalars_Type\n+        (Size_To_Use : Uint) return Node_Id\n+      is\n+         Signed_Size : constant Uint := UI_Min (Uint_63, Size_To_Use - 1);\n \n-         Check_Subtype_Bounds;\n+         Expr     : Node_Id;\n+         Hi_Bound : Uint;\n+         Lo_Bound : Uint;\n \n-         --  Processing for Normalize_Scalars case\n+      begin\n+         Extract_Subtype_Bounds (Lo_Bound, Hi_Bound);\n \n-         if Normalize_Scalars and then not IV_Attribute then\n+         --  If zero is invalid, it is a convenient value to use that is for\n+         --  sure an appropriate invalid value in all situations.\n \n-            --  If zero is invalid, it is a convenient value to use that is\n-            --  for sure an appropriate invalid value in all situations.\n+         if Lo_Bound /= No_Uint and then Lo_Bound > Uint_0 then\n+            Expr := Make_Integer_Literal (Loc, 0);\n \n-            if Lo_Bound /= No_Uint and then Lo_Bound > Uint_0 then\n-               Val := Make_Integer_Literal (Loc, 0);\n+         --  Cases where all one bits is the appropriate invalid value\n \n-            --  Cases where all one bits is the appropriate invalid value\n+         --  For modular types, all 1 bits is either invalid or valid. If it\n+         --  is valid, then there is nothing that can be done since there are\n+         --  no invalid values (we ruled out zero already).\n \n-            --  For modular types, all 1 bits is either invalid or valid. If\n-            --  it is valid, then there is nothing that can be done since there\n-            --  are no invalid values (we ruled out zero already).\n+         --  For signed integer types that have no negative values, either\n+         --  there is room for negative values, or there is not. If there\n+         --  is, then all 1-bits may be interpreted as minus one, which is\n+         --  certainly invalid. Alternatively it is treated as the largest\n+         --  positive value, in which case the observation for modular types\n+         --  still applies.\n \n-            --  For signed integer types that have no negative values, either\n-            --  there is room for negative values, or there is not. If there\n-            --  is, then all 1-bits may be interpreted as minus one, which is\n-            --  certainly invalid. Alternatively it is treated as the largest\n-            --  positive value, in which case the observation for modular types\n-            --  still applies.\n+         --  For float types, all 1-bits is a NaN (not a number), which is\n+         --  certainly an appropriately invalid value.\n \n-            --  For float types, all 1-bits is a NaN (not a number), which is\n-            --  certainly an appropriately invalid value.\n+         elsif Is_Enumeration_Type (Typ)\n+           or else Is_Floating_Point_Type (Typ)\n+           or else Is_Unsigned_Type (Typ)\n+         then\n+            Expr := Make_Integer_Literal (Loc, 2 ** Size_To_Use - 1);\n \n-            elsif Is_Unsigned_Type (T)\n-              or else Is_Floating_Point_Type (T)\n-              or else Is_Enumeration_Type (T)\n-            then\n-               Val := Make_Integer_Literal (Loc, 2 ** Size_To_Use - 1);\n+            --  Resolve as Unsigned_64, because the largest number we can\n+            --  generate is out of range of universal integer.\n \n-               --  Resolve as Unsigned_64, because the largest number we can\n-               --  generate is out of range of universal integer.\n+            Analyze_And_Resolve (Expr, RTE (RE_Unsigned_64));\n \n-               Analyze_And_Resolve (Val, RTE (RE_Unsigned_64));\n+         --  Case of signed types\n+\n+         else\n+            --  Normally we like to use the most negative number. The one\n+            --  exception is when this number is in the known subtype range and\n+            --  the largest positive number is not in the known subtype range.\n+\n+            --  For this exceptional case, use largest positive value\n+\n+            if Lo_Bound /= No_Uint and then Hi_Bound /= No_Uint\n+              and then Lo_Bound <= (-(2 ** Signed_Size))\n+              and then Hi_Bound < 2 ** Signed_Size\n+            then\n+               Expr := Make_Integer_Literal (Loc, 2 ** Signed_Size - 1);\n \n-            --  Case of signed types\n+            --  Normal case of largest negative value\n \n             else\n-               declare\n-                  Signed_Size : constant Uint :=\n-                                  UI_Min (Uint_63, Size_To_Use - 1);\n+               Expr := Make_Integer_Literal (Loc, -(2 ** Signed_Size));\n+            end if;\n+         end if;\n \n-               begin\n-                  --  Normally we like to use the most negative number. The one\n-                  --  exception is when this number is in the known subtype\n-                  --  range and the largest positive number is not in the known\n-                  --  subtype range.\n+         return Expr;\n+      end Simple_Init_Normalize_Scalars_Type;\n \n-                  --  For this exceptional case, use largest positive value\n+      ------------------------------\n+      -- Simple_Init_Private_Type --\n+      ------------------------------\n \n-                  if Lo_Bound /= No_Uint and then Hi_Bound /= No_Uint\n-                    and then Lo_Bound <= (-(2 ** Signed_Size))\n-                    and then Hi_Bound < 2 ** Signed_Size\n-                  then\n-                     Val := Make_Integer_Literal (Loc, 2 ** Signed_Size - 1);\n+      function Simple_Init_Private_Type return Node_Id is\n+         Under_Typ : constant Entity_Id := Underlying_Type (Typ);\n+         Expr      : Node_Id;\n \n-                  --  Normal case of largest negative value\n+      begin\n+         --  The availability of the underlying view must be checked by routine\n+         --  Needs_Simple_Initialization.\n \n-                  else\n-                     Val := Make_Integer_Literal (Loc, -(2 ** Signed_Size));\n-                  end if;\n-               end;\n-            end if;\n+         pragma Assert (Present (Under_Typ));\n \n-         --  Here for Initialize_Scalars case (or Invalid_Value attribute used)\n+         Expr := Get_Simple_Init_Val (Under_Typ, N, Size);\n \n-         else\n-            --  For float types, use float values from System.Scalar_Values\n-\n-            if Is_Floating_Point_Type (T) then\n-               if Root_Type (T) = Standard_Short_Float then\n-                  Val_RE := RE_IS_Isf;\n-               elsif Root_Type (T) = Standard_Float then\n-                  Val_RE := RE_IS_Ifl;\n-               elsif Root_Type (T) = Standard_Long_Float then\n-                  Val_RE := RE_IS_Ilf;\n-               else pragma Assert (Root_Type (T) = Standard_Long_Long_Float);\n-                  Val_RE := RE_IS_Ill;\n-               end if;\n+         --  If the initial value is null or an aggregate, qualify it with the\n+         --  underlying type in order to provide a proper context.\n+\n+         if Nkind_In (Expr, N_Aggregate, N_Null) then\n+            Expr :=\n+              Make_Qualified_Expression (Loc,\n+                Subtype_Mark => New_Occurrence_Of (Under_Typ, Loc),\n+                Expression   => Expr);\n+         end if;\n \n-            --  If zero is invalid, use zero values from System.Scalar_Values\n+         Expr := Unchecked_Convert_To (Typ, Expr);\n \n-            elsif Lo_Bound /= No_Uint and then Lo_Bound > Uint_0 then\n-               if Size_To_Use <= 8 then\n-                  Val_RE := RE_IS_Iz1;\n-               elsif Size_To_Use <= 16 then\n-                  Val_RE := RE_IS_Iz2;\n-               elsif Size_To_Use <= 32 then\n-                  Val_RE := RE_IS_Iz4;\n-               else\n-                  Val_RE := RE_IS_Iz8;\n-               end if;\n+         --  Do not truncate the result when scalar types are involved and\n+         --  Initialize/Normalize_Scalars is in effect.\n \n-            --  For unsigned, use unsigned values from System.Scalar_Values\n+         if Nkind (Expr) = N_Unchecked_Type_Conversion\n+           and then Is_Scalar_Type (Under_Typ)\n+         then\n+            Set_No_Truncation (Expr);\n+         end if;\n \n-            elsif Is_Unsigned_Type (T) then\n-               if Size_To_Use <= 8 then\n-                  Val_RE := RE_IS_Iu1;\n-               elsif Size_To_Use <= 16 then\n-                  Val_RE := RE_IS_Iu2;\n-               elsif Size_To_Use <= 32 then\n-                  Val_RE := RE_IS_Iu4;\n-               else\n-                  Val_RE := RE_IS_Iu8;\n-               end if;\n+         return Expr;\n+      end Simple_Init_Private_Type;\n \n-            --  For signed, use signed values from System.Scalar_Values\n+      -----------------------------\n+      -- Simple_Init_Scalar_Type --\n+      -----------------------------\n \n-            else\n-               if Size_To_Use <= 8 then\n-                  Val_RE := RE_IS_Is1;\n-               elsif Size_To_Use <= 16 then\n-                  Val_RE := RE_IS_Is2;\n-               elsif Size_To_Use <= 32 then\n-                  Val_RE := RE_IS_Is4;\n-               else\n-                  Val_RE := RE_IS_Is8;\n-               end if;\n-            end if;\n+      function Simple_Init_Scalar_Type return Node_Id is\n+         Expr        : Node_Id;\n+         Size_To_Use : Uint;\n+\n+      begin\n+         pragma Assert (Init_Or_Norm_Scalars or IV_Attribute);\n \n-            Val := New_Occurrence_Of (RTE (Val_RE), Loc);\n+         --  Determine the size of the object. This is either the size provided\n+         --  by the caller, or the Esize of the scalar type.\n+\n+         if Size = No_Uint or else Size <= Uint_0 then\n+            Size_To_Use := UI_Max (Uint_1, Esize (Typ));\n+         else\n+            Size_To_Use := Size;\n+         end if;\n+\n+         --  The maximum size to use is 64 bits. This will create values of\n+         --  type Unsigned_64 and the range must fit this type.\n+\n+         if Size_To_Use /= No_Uint and then Size_To_Use > Uint_64 then\n+            Size_To_Use := Uint_64;\n+         end if;\n+\n+         if Normalize_Scalars and then not IV_Attribute then\n+            Expr := Simple_Init_Normalize_Scalars_Type (Size_To_Use);\n+         else\n+            Expr := Simple_Init_Initialize_Scalars_Type (Size_To_Use);\n          end if;\n \n          --  The final expression is obtained by doing an unchecked conversion\n          --  of this result to the base type of the required subtype. Use the\n          --  base type to prevent the unchecked conversion from chopping bits,\n          --  and then we set Kill_Range_Check to preserve the \"bad\" value.\n \n-         Result := Unchecked_Convert_To (Base_Type (T), Val);\n+         Expr := Unchecked_Convert_To (Base_Type (Typ), Expr);\n \n-         --  Ensure result is not truncated, since we want the \"bad\" bits, and\n-         --  also kill range check on result.\n+         --  Ensure that the expression is not truncated since the \"bad\" bits\n+         --  are desired, and also kill the range checks.\n \n-         if Nkind (Result) = N_Unchecked_Type_Conversion then\n-            Set_No_Truncation (Result);\n-            Set_Kill_Range_Check (Result, True);\n+         if Nkind (Expr) = N_Unchecked_Type_Conversion then\n+            Set_Kill_Range_Check (Expr);\n+            Set_No_Truncation    (Expr);\n          end if;\n \n-         return Result;\n+         return Expr;\n+      end Simple_Init_Scalar_Type;\n \n-      --  String or Wide_[Wide]_String (must have Initialize_Scalars set)\n+      -----------------------------\n+      -- Simple_Init_String_Type --\n+      -----------------------------\n \n-      elsif Is_Standard_String_Type (T) then\n-         pragma Assert (Init_Or_Norm_Scalars);\n+      function Simple_Init_String_Type return Node_Id is\n+         Comp_Typ : constant Entity_Id := Component_Type (Typ);\n+\n+      begin\n+         --  Generate:\n+         --    (others => Get_Simple_Init_Value)\n \n          return\n            Make_Aggregate (Loc,\n              Component_Associations => New_List (\n                Make_Component_Association (Loc,\n-                 Choices    => New_List (\n-                   Make_Others_Choice (Loc)),\n+                 Choices    => New_List (Make_Others_Choice (Loc)),\n                  Expression =>\n                    Get_Simple_Init_Val\n-                     (Component_Type (T), N, Esize (Root_Type (T))))));\n+                     (Typ  => Comp_Typ,\n+                      N    => N,\n+                      Size => Esize (Comp_Typ)))));\n+      end Simple_Init_String_Type;\n+\n+   --  Start of processing for Get_Simple_Init_Val\n+\n+   begin\n+      if Is_Private_Type (Typ) then\n+         return Simple_Init_Private_Type;\n+\n+      elsif Is_Scalar_Type (Typ) then\n+         if Has_Default_Aspect (Typ) then\n+            return Simple_Init_Defaulted_Type;\n+         else\n+            return Simple_Init_Scalar_Type;\n+         end if;\n+\n+      --  [[Wide_]Wide_]String with Initialize or Normalize_Scalars\n+\n+      elsif Is_Standard_String_Type (Typ) then\n+         pragma Assert (Init_Or_Norm_Scalars);\n+         return Simple_Init_String_Type;\n \n       --  Access type is initialized to null\n \n-      elsif Is_Access_Type (T) then\n+      elsif Is_Access_Type (Typ) then\n          return Make_Null (Loc);\n \n       --  No other possibilities should arise, since we should only be calling\n@@ -9889,7 +10007,7 @@ package body Exp_Ch3 is\n    ---------------------------------\n \n    function Needs_Simple_Initialization\n-     (T           : Entity_Id;\n+     (Typ         : Entity_Id;\n       Consider_IS : Boolean := True) return Boolean\n    is\n       Consider_IS_NS : constant Boolean :=\n@@ -9898,16 +10016,16 @@ package body Exp_Ch3 is\n    begin\n       --  Never need initialization if it is suppressed\n \n-      if Initialization_Suppressed (T) then\n+      if Initialization_Suppressed (Typ) then\n          return False;\n       end if;\n \n       --  Check for private type, in which case test applies to the underlying\n       --  type of the private type.\n \n-      if Is_Private_Type (T) then\n+      if Is_Private_Type (Typ) then\n          declare\n-            RT : constant Entity_Id := Underlying_Type (T);\n+            RT : constant Entity_Id := Underlying_Type (Typ);\n          begin\n             if Present (RT) then\n                return Needs_Simple_Initialization (RT);\n@@ -9918,15 +10036,15 @@ package body Exp_Ch3 is\n \n       --  Scalar type with Default_Value aspect requires initialization\n \n-      elsif Is_Scalar_Type (T) and then Has_Default_Aspect (T) then\n+      elsif Is_Scalar_Type (Typ) and then Has_Default_Aspect (Typ) then\n          return True;\n \n       --  Cases needing simple initialization are access types, and, if pragma\n       --  Normalize_Scalars or Initialize_Scalars is in effect, then all scalar\n       --  types.\n \n-      elsif Is_Access_Type (T)\n-        or else (Consider_IS_NS and then (Is_Scalar_Type (T)))\n+      elsif Is_Access_Type (Typ)\n+        or else (Consider_IS_NS and then (Is_Scalar_Type (Typ)))\n       then\n          return True;\n \n@@ -9936,10 +10054,10 @@ package body Exp_Ch3 is\n       --  filled with appropriate initializing values before they are used).\n \n       elsif Consider_IS_NS\n-        and then Is_Standard_String_Type (T)\n+        and then Is_Standard_String_Type (Typ)\n         and then\n-          (not Is_Itype (T)\n-            or else Nkind (Associated_Node_For_Itype (T)) /= N_Aggregate)\n+          (not Is_Itype (Typ)\n+            or else Nkind (Associated_Node_For_Itype (Typ)) /= N_Aggregate)\n       then\n          return True;\n "}, {"sha": "65faa3136dfde401c6996ddde7be99561c4f6f0e", "filename": "gcc/ada/exp_ch3.ads", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b26fe826601cd43b8a4e7b1b29114034bd3eabb/gcc%2Fada%2Fexp_ch3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b26fe826601cd43b8a4e7b1b29114034bd3eabb/gcc%2Fada%2Fexp_ch3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.ads?ref=3b26fe826601cd43b8a4e7b1b29114034bd3eabb", "patch": "@@ -91,6 +91,26 @@ package Exp_Ch3 is\n    --  want Gigi to see the node. This function can't delete the node itself\n    --  since it would confuse any remaining processing of the freeze node.\n \n+   function Get_Simple_Init_Val\n+     (Typ  : Entity_Id;\n+      N    : Node_Id;\n+      Size : Uint := No_Uint) return Node_Id;\n+   --  Build an expression which represents the required initial value of type\n+   --  Typ for which predicate Needs_Simple_Initialization is True. N is a node\n+   --  whose source location used in the construction of the expression. Size\n+   --  is utilized as follows:\n+   --\n+   --    * If the size of the object to be initialized it is known, it should\n+   --      be passed to the routine.\n+   --\n+   --    * If the size is unknown or is zero, then the Esize of Typ is used as\n+   --      an estimate of the size.\n+   --\n+   --  The object size is needed to prepare a known invalid value for use by\n+   --  Normalize_Scalars. A call to this routine where Typ denotes a scalar\n+   --  type is only valid when Normalize_Scalars or Initialize_Scalars is\n+   --  active, or if N is the node for a 'Invalid_Value attribute node.\n+\n    procedure Init_Secondary_Tags\n      (Typ            : Entity_Id;\n       Target         : Node_Id;\n@@ -115,7 +135,7 @@ package Exp_Ch3 is\n    --  see Check_Address_Clause.\n \n    function Needs_Simple_Initialization\n-     (T           : Entity_Id;\n+     (Typ         : Entity_Id;\n       Consider_IS : Boolean := True) return Boolean;\n    --  Certain types need initialization even though there is no specific\n    --  initialization routine:\n@@ -127,20 +147,4 @@ package Exp_Ch3 is\n    --  set to False, but if Consider_IS is set to True, then the cases above\n    --  mentioning Normalize_Scalars also apply for Initialize_Scalars mode.\n \n-   function Get_Simple_Init_Val\n-     (T    : Entity_Id;\n-      N    : Node_Id;\n-      Size : Uint := No_Uint) return Node_Id;\n-   --  For a type which Needs_Simple_Initialization (see above), prepares the\n-   --  tree for an expression representing the required initial value. N is a\n-   --  node whose source location used in constructing this tree which is\n-   --  returned as the result of the call. The Size parameter indicates the\n-   --  target size of the object if it is known (indicated by a value that is\n-   --  not No_Uint and is greater than zero). If Size is not given (Size set to\n-   --  No_Uint, or non-positive), then the Esize of T is used as an estimate of\n-   --  the Size. The object size is needed to prepare a known invalid value for\n-   --  use by Normalize_Scalars. A call to this routine where T is a scalar\n-   --  type is only valid if we are in Normalize_Scalars or Initialize_Scalars\n-   --  mode, or if N is the node for a 'Invalid_Value attribute node.\n-\n end Exp_Ch3;"}]}