{"sha": "22fa5b8add62b79ef3f6aa5b32d97db9c1d028da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjJmYTViOGFkZDYyYjc5ZWYzZjZhYTViMzJkOTdkYjljMWQwMjhkYQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@cygnus.com", "date": "1997-09-04T15:12:20Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1997-09-04T15:12:20Z"}, "message": "Add EXECUTE_IF_AND_IN_{BITMAP,REG_SET}, and bitmap_print\n\nFrom-SVN: r15071", "tree": {"sha": "de700dc0cf119390613c23ee4b4497363513c8c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de700dc0cf119390613c23ee4b4497363513c8c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22fa5b8add62b79ef3f6aa5b32d97db9c1d028da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22fa5b8add62b79ef3f6aa5b32d97db9c1d028da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22fa5b8add62b79ef3f6aa5b32d97db9c1d028da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22fa5b8add62b79ef3f6aa5b32d97db9c1d028da/comments", "author": null, "committer": null, "parents": [{"sha": "9b2c548ca6d457c5e523ad894db44fb2f6d5a424", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b2c548ca6d457c5e523ad894db44fb2f6d5a424", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b2c548ca6d457c5e523ad894db44fb2f6d5a424"}], "stats": {"total": 173, "additions": 163, "deletions": 10}, "files": [{"sha": "647f4f8d412894061088e338b8f893974248781f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fa5b8add62b79ef3f6aa5b32d97db9c1d028da/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fa5b8add62b79ef3f6aa5b32d97db9c1d028da/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=22fa5b8add62b79ef3f6aa5b32d97db9c1d028da", "patch": "@@ -1,3 +1,20 @@\n+Thu Sep  4 11:04:21 1997  Michael Meissner  <meissner@cygnus.com>\n+\n+\t* bitmap.h (EXECUTE_IF_AND_IN_BITMAP): New macro, to iterate over\n+\ttwo bitmaps ANDed together.\n+\t(bitmap_print): Declare.\n+\n+\t* bitmap.c (function_obstack): Don't declare any more.\n+\t(bitmap_obstack): Obstack for allocating links from.\n+\t(bitmap_obstack_init): New static to say whether to initialize\n+\tbitmap_obstack.\n+\t(bitmap_element_allocate): Use bitmap_obstack to allocate from.\n+\t(bitmap_release_memory): Free all memory allocated from\n+\tbitmap_obstack.\n+\n+\t* basic-block.h (EXECUTE_IF_AND_IN_REG_SET): New macro, invoke\n+\tEXECUTE_IF_AND_IN_BITMAP.\n+\n Wed Sep  3 10:39:42 1997  Jim Wilson  <wilson@cygnus.com>\n \n \t* alias.c (true_dependence): Address with AND can alias scalars."}, {"sha": "c76d8507b7c5a17049e9456b55cf8a59c1e61be1", "filename": "gcc/basic-block.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fa5b8add62b79ef3f6aa5b32d97db9c1d028da/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fa5b8add62b79ef3f6aa5b32d97db9c1d028da/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=22fa5b8add62b79ef3f6aa5b32d97db9c1d028da", "patch": "@@ -73,6 +73,12 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define EXECUTE_IF_AND_COMPL_IN_REG_SET(REGSET1, REGSET2, MIN, REGNUM, CODE) \\\n   EXECUTE_IF_AND_COMPL_IN_BITMAP (REGSET1, REGSET2, MIN, REGNUM, CODE)\n \n+/* Loop over all registers in REGSET1 and REGSET2, starting with MIN, setting\n+   REGNUM to the register number and executing CODE for all registers that are\n+   set in both regsets. */\n+#define EXECUTE_IF_AND_IN_REG_SET(REGSET1, REGSET2, MIN, REGNUM, CODE) \\\n+  EXECUTE_IF_AND_IN_BITMAP (REGSET1, REGSET2, MIN, REGNUM, CODE)\n+\n /* Allocate a register set with oballoc.  */\n #define OBSTACK_ALLOC_REG_SET(OBSTACK) BITMAP_OBSTACK_ALLOC (OBSTACK)\n "}, {"sha": "e2d61cd856f14ab1b03979323e099d0163dc3bbe", "filename": "gcc/bitmap.c", "status": "modified", "additions": 64, "deletions": 10, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fa5b8add62b79ef3f6aa5b32d97db9c1d028da/gcc%2Fbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fa5b8add62b79ef3f6aa5b32d97db9c1d028da/gcc%2Fbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.c?ref=22fa5b8add62b79ef3f6aa5b32d97db9c1d028da", "patch": "@@ -26,12 +26,9 @@ Boston, MA 02111-1307, USA.  */\n #include \"regs.h\"\n #include \"basic-block.h\"\n \n-/* The contents of the current function definition are allocated\n-   in this obstack, and all are freed at the end of the function.\n-   For top-level functions, this is temporary_obstack.\n-   Separate obstacks are made for nested functions.  */\n-\n-extern struct obstack *function_obstack;\n+/* Obstack to allocate bitmap elements from.  */\n+static struct obstack bitmap_obstack;\n+static int bitmap_obstack_init = FALSE;\n \n \f\n #ifndef INLINE\n@@ -95,8 +92,39 @@ bitmap_element_allocate (head)\n       bitmap_free = element->next;\n     }\n   else\n-    element = (bitmap_element *) obstack_alloc (function_obstack,\n-\t\t\t\t\t\tsizeof (bitmap_element));\n+    {\n+      /* We can't use gcc_obstack_init to initialize the obstack since\n+\t print-rtl.c now calls bitmap functions, and bitmap is linked\n+\t into the gen* functions.  */\n+      if (!bitmap_obstack_init)\n+\t{\n+\t  bitmap_obstack_init = TRUE;\n+\n+\t  /* Let particular systems override the size of a chunk.  */\n+#ifndef OBSTACK_CHUNK_SIZE\n+#define OBSTACK_CHUNK_SIZE 0\n+#endif\n+\t  /* Let them override the alloc and free routines too.  */\n+#ifndef OBSTACK_CHUNK_ALLOC\n+#define OBSTACK_CHUNK_ALLOC xmalloc\n+#endif\n+#ifndef OBSTACK_CHUNK_FREE\n+#define OBSTACK_CHUNK_FREE free\n+#endif\n+\n+#if !defined(__GNUC__) || (__GNUC__ < 2)\n+#define __alignof__(type) 0\n+#endif\n+\n+\t  obstack_specify_allocation (&bitmap_obstack, OBSTACK_CHUNK_SIZE,\n+\t\t\t\t      __alignof__ (bitmap_element),\n+\t\t\t\t      (void *(*) ()) OBSTACK_CHUNK_ALLOC,\n+\t\t\t\t      (void (*) ()) OBSTACK_CHUNK_FREE);\n+\t}\n+\n+      element = (bitmap_element *) obstack_alloc (&bitmap_obstack,\n+\t\t\t\t\t\t  sizeof (bitmap_element));\n+    }\n \n #if BITMAP_ELEMENT_WORDS == 2\n   element->bits[0] = element->bits[1] = 0;\n@@ -573,11 +601,37 @@ debug_bitmap (head)\n   bitmap_debug_file (stdout, head);\n }\n \f\n-/* Release any memory allocated by bitmaps.  Since we allocate off of the\n-   function_obstack, just zap the free list.  */\n+/* Function to print out the contents of a bitmap.  Unlike bitmap_debug_file,\n+   it does not print anything but the bits.  */\n+\n+void\n+bitmap_print (file, head, prefix, suffix)\n+     FILE *file;\n+     bitmap head;\n+     char *prefix;\n+     char *suffix;\n+{\n+  char *comma = \"\";\n+  int i;\n+\n+  fputs (prefix, file);\n+  EXECUTE_IF_SET_IN_BITMAP (head, 0, i,\n+\t\t\t    {\n+\t\t\t      fprintf (file, \"%s%d\", comma, i);\n+\t\t\t      comma = \", \";\n+\t\t\t    });\n+  fputs (suffix, file);\n+}\n+\f\n+/* Release any memory allocated by bitmaps.  */\n \n void\n bitmap_release_memory ()\n {\n   bitmap_free = 0;\n+  if (bitmap_obstack_init)\n+    {\n+      bitmap_obstack_init = FALSE;\n+      obstack_free (&bitmap_obstack, NULL_PTR);\n+    }\n }"}, {"sha": "343b24911c074df18653f7ec9dc9935d2c79e4fb", "filename": "gcc/bitmap.h", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fa5b8add62b79ef3f6aa5b32d97db9c1d028da/gcc%2Fbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fa5b8add62b79ef3f6aa5b32d97db9c1d028da/gcc%2Fbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.h?ref=22fa5b8add62b79ef3f6aa5b32d97db9c1d028da", "patch": "@@ -88,6 +88,9 @@ extern int bitmap_bit_p PROTO((bitmap, int));\n extern void bitmap_debug PROTO((bitmap));\n extern void bitmap_debug_file STDIO_PROTO((FILE *, bitmap));\n \n+/* Print a bitmap */\n+extern void bitmap_print STDIO_PROTO((FILE *, bitmap, char *, char *));\n+\n /* Initialize a bitmap header.  */\n extern bitmap bitmap_initialize PROTO((bitmap));\n \n@@ -237,3 +240,76 @@ do {\t\t\t\t\t\t\t\t\t\\\n       word_num_ = 0;\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n } while (0)\n+\n+/* Loop over all bits in BITMAP1 and BITMAP2, starting with MIN, setting\n+   BITNUM to the bit number and executing CODE for all bits that are set in\n+   the both bitmaps. */\n+\n+#define EXECUTE_IF_AND_IN_BITMAP(BITMAP1, BITMAP2, MIN, BITNUM, CODE)\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  bitmap_element *ptr1_ = (BITMAP1)->first;\t\t\t\t\\\n+  bitmap_element *ptr2_ = (BITMAP2)->first;\t\t\t\t\\\n+  unsigned int indx_ = (MIN) / BITMAP_ELEMENT_ALL_BITS;\t\t\t\\\n+  unsigned bit_num_ = (MIN) % ((unsigned) HOST_BITS_PER_WIDE_INT);\t\\\n+  unsigned word_num_ = (((MIN) / ((unsigned) HOST_BITS_PER_WIDE_INT))\t\\\n+\t\t\t% BITMAP_ELEMENT_WORDS);\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  /* Find the block the minimum bit is in in the first bitmap.  */\t\\\n+  while (ptr1_ != 0 && ptr1_->indx < indx_)\t\t\t\t\\\n+    ptr1_ = ptr1_->next;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  if (ptr1_ != 0 && ptr1_->indx != indx_)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      bit_num_ = 0;\t\t\t\t\t\t\t\\\n+      word_num_ = 0;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  for (; ptr1_ != 0 ; ptr1_ = ptr1_->next)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      /* Advance BITMAP2 to the equivalent link */\t\t\t\\\n+      while (ptr2_ != 0 && ptr2_->indx < ptr1_->indx)\t\t\t\\\n+\tptr2_ = ptr2_->next;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      if (ptr2_ == 0)\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  /* If there are no more elements in BITMAP2, exit loop now.*/\t\\\n+\t  ptr1_ = (bitmap_element *)0;\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (ptr2_->indx > ptr1_->indx)\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  bit_num_ = word_num_ = 0;\t\t\t\t\t\\\n+\t  continue;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      for (; word_num_ < BITMAP_ELEMENT_WORDS; word_num_++)\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  unsigned HOST_WIDE_INT word_ = (ptr1_->bits[word_num_]\t\\\n+\t\t\t\t\t  & ptr2_->bits[word_num_]);\t\\\n+\t  if (word_ != 0)\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      for (; bit_num_ < HOST_BITS_PER_WIDE_INT; bit_num_++)\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  unsigned HOST_WIDE_INT mask_\t\t\t\t\\\n+\t\t    = ((unsigned HOST_WIDE_INT)1) << bit_num_;\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t\t  if ((word_ & mask_) != 0)\t\t\t\t\\\n+\t\t    {\t\t\t\t\t\t\t\\\n+\t\t      word_ &= ~ mask_;\t\t\t\t\t\\\n+\t\t      (BITNUM) = (ptr1_->indx * BITMAP_ELEMENT_ALL_BITS \\\n+\t\t\t\t  + word_num_ * HOST_BITS_PER_WIDE_INT  \\\n+\t\t\t\t  + bit_num_);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t\t      CODE;\t\t\t\t\t\t\\\n+\t\t      if (word_ == 0)\t\t\t\t\t\\\n+\t\t\tbreak;\t\t\t\t\t\t\\\n+\t\t    }\t\t\t\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t  bit_num_ = 0;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      word_num_ = 0;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+} while (0)"}]}