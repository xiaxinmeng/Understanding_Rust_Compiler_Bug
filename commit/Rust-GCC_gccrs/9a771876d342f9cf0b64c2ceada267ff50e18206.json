{"sha": "9a771876d342f9cf0b64c2ceada267ff50e18206", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWE3NzE4NzZkMzQyZjljZjBiNjRjMmNlYWRhMjY3ZmY1MGUxODIwNg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2014-09-02T12:52:29Z"}, "committer": {"name": "Kirill Yukhin", "email": "kyukhin@gcc.gnu.org", "date": "2014-09-02T12:52:29Z"}, "message": "cilk-builtins.def (__cilkrts_cilk_for_32): New.\n\ngcc/\n\t* cilk-builtins.def (__cilkrts_cilk_for_32): New.\n\t(__cilkrts_cilk_for_64): Likewise.\n\t* cilk-common.c (declare_cilk_for_builtin): New function.\n\t(cilk_init_builtins): Declare __cilkrts_cilk_for_32 and\n\t__cilkrts_cilk_for_64 bultins.\n\t* cilk.h (enum cilk_tree_index): Added CILK_TI_F_LOOP_32 and\n\tCILK_TI_F_LOOP_64.\n\t(cilk_for_32_fndecl): New define.\n\t(cilk_for_64_fndecl): Likewise.\n\t* gimple-pretty-print.c (dump_gimple_omp_for): Correct hadling of\n\tGF_OMP_FOR_KIND_CILKFOR cases; Added NE_EXPR case.\n\t* gimple.h (enum gf_mask): Added GF_OMP_FOR_KIND_CILKFOR; adjusted\n\tGF_OMP_FOR_KIND_MASK, GF_OMP_FOR_SIMD, GF_OMP_FOR_COMBINED,\n\tGF_OMP_FOR_COMBINED_INTO.\n\t* gimplify.c (gimplify_scan_omp_clauses): Added\n\tOMP_CLAUSE__CILK_FOR_COUNT_ case.\n\t(gimplify_adjust_omp_clauses): Ditto.\n\t(gimplify_omp_for): Added CILK_FOR case.\n\t(gimplify_expr): Ditto.\n\t* omp-low.c: Include cilk.h.\n\t(extract_omp_for_data): Set appropriate kind for\n\tGF_OMP_FOR_KIND_CILKFOR; added check for GF_OMP_FOR_KIND_CILKFOR.\n\t(scan_sharing_clauses): Added OMP_CLAUSE__CILK_FOR_COUNT_ cases.\n\t(create_omp_child_function_name): Added second argument to handle\n\tcilk_for case.\n\t(cilk_for_check_loop_diff_type): New function.\n\t(expand_cilk_for_call): Likewise.\n\t(expand_cilk_for): Likewise.\n\t(create_omp_child_function): Set cilk_for_count; handle the cases when\n\tit is true; call create_omp_child_function_name with second argument.\n\t(expand_omp_taskreg): Set is_cilk_for and handle cases when it's true.\n\t(expand_omp_for): Handle case of GF_OMP_FOR_KIND_CILKFOR.\n\t* tree-core.h (omp_clause_code): Added OMP_CLAUSE__CILK_FOR_COUNT_.\n\t* tree-nested.c (convert_nonlocal_omp_clauses): Added\n\tOMP_CLAUSE__CILK_FOR_COUNT_ case.\n\t(convert_local_omp_clauses): Ditto.\n\t* tree-pretty-print.c (dump_omp_clause): Added\n\tOMP_CLAUSE__CILK_FOR_COUNT_ and OMP_CLAUSE_SCHEDULE_CILKFOR cases.\n\t(dump_generic_node): Added CILK_FOR case.\n\t* tree.c (omp_clause_num_ops): New element\n\tOMP_CLAUSE__CILK_FOR_COUNT_ (1).\n\t(omp_clause_code_name): New element _Cilk_for_count_.\n\t(walk_tree_1): Added OMP_CLAUSE__CILK_FOR_COUNT_ case.\n\t* tree.def: Add tree code for CILK_FOR.\n\ngcc/c/\n\t* c-parser.c (c_parser_cilk_for): New function.\n\t(c_parser_cilk_grainsize): Likewise.\n\t(c_get_temp_regvar): Likewise.\n\t(c_parser_statement_after_labels): Added RID_CILK_FOR case.\n\t(c_parser_pragma): Added PRAGMA_CILK_GRAINSIZE case.\n\t(c_parser_omp_for_loop): Added CILK_FOR and CILK_SIMD checks.\n\t* c-typeck.c (c_finish_omp_clauses): Added OMP_CLAUSE__CILK_FOR_COUNT_\n\tcase.\n\ngcc/cp/\n\t* cp-cilkplus.c (cpp_validate_cilk_plus_loop_aux): Loc definition\n\tsimplified.\n\t* parser.c (cp_parser_cilk_for): New function.\n\t(cp_parser_cilk_grainsize): Likewise.\n\t(cp_parser_statement): Added RID_CILK_FOR case.\n\t(cp_parser_omp_for_cond): Added CILK_FOR check.\n\t(cp_parser_omp_for_loop_init): Change function argument to accept\n\ttree_code instead just a bool flag; change the check to use that\n\ttree_code; check for initialization declaration in case of Cilk_for.\n\t(cp_parser_omp_for_loop): Added checks for CILK_FOR and RID_CILK_FOR;\n\tchanged call to cp_parser_omp_for_loop_init according new arguments'\n\tlist.\n\t(cp_parser_pragma): Added PRAGMA_CILK_GRAINSIZE case.\n\t* pt.c (tsubst_expr): Added CILK_FOR case.\n\t* semantics.c: Include convert.h.\n\t(finish_omp_clauses): Properly handle OMP_CLAUSE_SCHEDULE_CILKFOR\n\tcase; added OMP_CLAUSE__CILK_FOR_COUNT_.\n\t(handle_omp_for_class_iterator): New argument lastp and its usage;\n\tadded NE_EXPR case.\n\t(finish_omp_for): Changed call to handle_omp_for_class_iterator\n\taccording new arguments' list; in case of Cilk_for save very first\n\tdecl and create empty stmt_list block; use block to build correct\n\tstatement tree.\n\ngcc/c-family/\n\t* c-cilkplus.c (cilk_for_number_of_iterations): New function.\n\t* c-common.c (c_common_reswords): Added _Cilk_for.\n\t* c-common.h (enum rid): Added RID_CILK_FOR.\n\t(cilk_for_number_of_iterations): Add declaration.\n\t* c-omp.c (c_finish_omp_for): Added checks for CILK_SIMD and\n\tCILK_FOR.\n\t* c-pragma.c (init_pragma): Register \"grainsize\" pragma.\n\t* c-pragma.h (enum pragma_kind): Add PRAGMA_CILK_GRAINSIZE.\n\ngcc/testsuite/\n\t* c-c++-common/cilk-plus/CK/cilk-fors.c: New test.\n\t* c-c++-common/cilk-plus/CK/cilk-for-2.c: New test.\n\t* c-c++-common/cilk-plus/CK/cilk-for-3.c: New test.\n\t* c-c++-common/cilk-plus/CK/cilk_for_errors.c: New test.\n\t* c-c++-common/cilk-plus/CK/cilk_for_grain.c: New test.\n\t* c-c++-common/cilk-plus/CK/cilk_for_grain_errors.c: New test.\n\t* c-c++-common/cilk-plus/CK/cilk_for_ptr_iter.c: New test.\n\t* c-c++-common/cilk-plus/CK/nested_cilk_for.c: New test.\n\t* g++.dg/cilk-plus/CK/cf3.cc: New test.\n\t* g++.dg/cilk-plus/CK/cilk-for-tplt.cc: New test.\n\t* g++.dg/cilk-plus/CK/for1.cc: New test.\n\t* g++.dg/cilk-plus/CK/stl_iter.cc: New test.\n\t* g++.dg/cilk-plus/CK/stl_rev_iter.cc: New test.\n\t* g++.dg/cilk-plus/CK/stl_test.cc: New test.\n\nCo-Authored-By: Balaji V. Iyer <balaji.v.iyer@intel.com>\nCo-Authored-By: Igor Zamyatin <igor.zamyatin@intel.com>\n\nFrom-SVN: r214818", "tree": {"sha": "88fc4c24c6347b42ca239861cc28a6716e4730ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/88fc4c24c6347b42ca239861cc28a6716e4730ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a771876d342f9cf0b64c2ceada267ff50e18206", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a771876d342f9cf0b64c2ceada267ff50e18206", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a771876d342f9cf0b64c2ceada267ff50e18206", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a771876d342f9cf0b64c2ceada267ff50e18206/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "794307309bbf58d4cc9de19bd2a7017b92dd7eef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/794307309bbf58d4cc9de19bd2a7017b92dd7eef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/794307309bbf58d4cc9de19bd2a7017b92dd7eef"}], "stats": {"total": 2634, "additions": 2569, "deletions": 65}, "files": [{"sha": "a59c8a4cd8c71c97a3b08fd2bd9a250623aa8fdb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9a771876d342f9cf0b64c2ceada267ff50e18206", "patch": "@@ -1,3 +1,52 @@\n+2014-09-02  Jakub Jelinek  <jakub@redhat.com>\n+\t    Balaji V. Iyer  <balaji.v.iyer@intel.com>\n+\t    Igor Zamyatin  <igor.zamyatin@intel.com>\n+\n+\t* cilk-builtins.def (__cilkrts_cilk_for_32): New.\n+\t(__cilkrts_cilk_for_64): Likewise.\n+\t* cilk-common.c (declare_cilk_for_builtin): New function.\n+\t(cilk_init_builtins): Declare __cilkrts_cilk_for_32 and\n+\t__cilkrts_cilk_for_64 bultins.\n+\t* cilk.h (enum cilk_tree_index): Added CILK_TI_F_LOOP_32 and\n+\tCILK_TI_F_LOOP_64.\n+\t(cilk_for_32_fndecl): New define.\n+\t(cilk_for_64_fndecl): Likewise.\n+\t* gimple-pretty-print.c (dump_gimple_omp_for): Correct hadling of\n+\tGF_OMP_FOR_KIND_CILKFOR cases; Added NE_EXPR case.\n+\t* gimple.h (enum gf_mask): Added GF_OMP_FOR_KIND_CILKFOR; adjusted\n+\tGF_OMP_FOR_KIND_MASK, GF_OMP_FOR_SIMD, GF_OMP_FOR_COMBINED,\n+\tGF_OMP_FOR_COMBINED_INTO.\n+\t* gimplify.c (gimplify_scan_omp_clauses): Added\n+\tOMP_CLAUSE__CILK_FOR_COUNT_ case.\n+\t(gimplify_adjust_omp_clauses): Ditto.\n+\t(gimplify_omp_for): Added CILK_FOR case.\n+\t(gimplify_expr): Ditto.\n+\t* omp-low.c: Include cilk.h.\n+\t(extract_omp_for_data): Set appropriate kind for\n+\tGF_OMP_FOR_KIND_CILKFOR; added check for GF_OMP_FOR_KIND_CILKFOR.\n+\t(scan_sharing_clauses): Added OMP_CLAUSE__CILK_FOR_COUNT_ cases.\n+\t(create_omp_child_function_name): Added second argument to handle\n+\tcilk_for case.\n+\t(cilk_for_check_loop_diff_type): New function.\n+\t(expand_cilk_for_call): Likewise.\n+\t(expand_cilk_for): Likewise.\n+\t(create_omp_child_function): Set cilk_for_count; handle the cases when\n+\tit is true; call create_omp_child_function_name with second argument.\n+\t(expand_omp_taskreg): Set is_cilk_for and handle cases when it's true.\n+\t(expand_omp_for): Handle case of GF_OMP_FOR_KIND_CILKFOR.\n+\t* tree-core.h (omp_clause_code): Added OMP_CLAUSE__CILK_FOR_COUNT_.\n+\t* tree-nested.c (convert_nonlocal_omp_clauses): Added\n+\tOMP_CLAUSE__CILK_FOR_COUNT_ case.\n+\t(convert_local_omp_clauses): Ditto.\n+\t* tree-pretty-print.c (dump_omp_clause): Added\n+\tOMP_CLAUSE__CILK_FOR_COUNT_ and OMP_CLAUSE_SCHEDULE_CILKFOR cases.\n+\t(dump_generic_node): Added CILK_FOR case.\n+\t* tree.c (omp_clause_num_ops): New element\n+\tOMP_CLAUSE__CILK_FOR_COUNT_ (1).\n+\t(omp_clause_code_name): New element _Cilk_for_count_.\n+\t(walk_tree_1): Added OMP_CLAUSE__CILK_FOR_COUNT_ case.\n+\t* tree.def: Add tree code for CILK_FOR.\n+\n 2014-09-02  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* config/rs6000/40x.md (ppc403-integer): Move \"exts\" to \"no dot\"."}, {"sha": "fdcaa0d2392c177a715bfb0efc296314c58ad48d", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=9a771876d342f9cf0b64c2ceada267ff50e18206", "patch": "@@ -1,3 +1,16 @@\n+2014-09-02  Jakub Jelinek  <jakub@redhat.com>\n+\t    Balaji V. Iyer  <balaji.v.iyer@intel.com>\n+\t    Igor Zamyatin  <igor.zamyatin@intel.com>\n+\n+\t* c-cilkplus.c (cilk_for_number_of_iterations): New function.\n+\t* c-common.c (c_common_reswords): Added _Cilk_for.\n+\t* c-common.h (enum rid): Added RID_CILK_FOR.\n+\t(cilk_for_number_of_iterations): Add declaration.\n+\t* c-omp.c (c_finish_omp_for): Added checks for CILK_SIMD and\n+\tCILK_FOR.\n+\t* c-pragma.c (init_pragma): Register \"grainsize\" pragma.\n+\t* c-pragma.h (enum pragma_kind): Add PRAGMA_CILK_GRAINSIZE.\n+\n 2014-08-29  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \t* c.opt (Wbuiltin-macro-redefined,Wdeprecated,Wendif-labels,"}, {"sha": "131da0b3fea0f153ced2b8de429904877c13a886", "filename": "gcc/c-family/c-cilkplus.c", "status": "modified", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Fc-family%2Fc-cilkplus.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Fc-family%2Fc-cilkplus.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-cilkplus.c?ref=9a771876d342f9cf0b64c2ceada267ff50e18206", "patch": "@@ -91,3 +91,136 @@ c_finish_cilk_clauses (tree clauses)\n     }\n   return clauses;\n }\n+\n+/* Calculate number of iterations of CILK_FOR.  */\n+\n+tree\n+cilk_for_number_of_iterations (tree cilk_for)\n+{\n+  tree t, v, n1, n2, step, type, init, cond, incr, itype;\n+  enum tree_code cond_code;\n+  location_t loc = EXPR_LOCATION (cilk_for);\n+\n+  init = TREE_VEC_ELT (OMP_FOR_INIT (cilk_for), 0);\n+  v = TREE_OPERAND (init, 0);\n+  cond = TREE_VEC_ELT (OMP_FOR_COND (cilk_for), 0);\n+  incr = TREE_VEC_ELT (OMP_FOR_INCR (cilk_for), 0);\n+  type = TREE_TYPE (v);\n+\n+  gcc_assert (TREE_CODE (TREE_TYPE (v)) == INTEGER_TYPE\n+\t      || TREE_CODE (TREE_TYPE (v)) == POINTER_TYPE);\n+  n1 = TREE_OPERAND (init, 1);\n+  cond_code = TREE_CODE (cond);\n+  n2 = TREE_OPERAND (cond, 1);\n+  switch (cond_code)\n+    {\n+    case LT_EXPR:\n+    case GT_EXPR:\n+    case NE_EXPR:\n+      break;\n+    case LE_EXPR:\n+      if (POINTER_TYPE_P (TREE_TYPE (n2)))\n+\tn2 = fold_build_pointer_plus_hwi_loc (loc, n2, 1);\n+      else\n+\tn2 = fold_build2_loc (loc, PLUS_EXPR, TREE_TYPE (n2), n2,\n+\t\t\t      build_int_cst (TREE_TYPE (n2), 1));\n+      cond_code = LT_EXPR;\n+      break;\n+    case GE_EXPR:\n+      if (POINTER_TYPE_P (TREE_TYPE (n2)))\n+\tn2 = fold_build_pointer_plus_hwi_loc (loc, n2, -1);\n+      else\n+\tn2 = fold_build2_loc (loc, MINUS_EXPR, TREE_TYPE (n2), n2,\n+\t\t\t      build_int_cst (TREE_TYPE (n2), 1));\n+      cond_code = GT_EXPR;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  step = NULL_TREE;\n+  switch (TREE_CODE (incr))\n+    {\n+    case PREINCREMENT_EXPR:\n+    case POSTINCREMENT_EXPR:\n+      step = build_int_cst (TREE_TYPE (v), 1);\n+      break;\n+    case PREDECREMENT_EXPR:\n+    case POSTDECREMENT_EXPR:\n+      step = build_int_cst (TREE_TYPE (v), -1);\n+      break;\n+    case MODIFY_EXPR:\n+      t = TREE_OPERAND (incr, 1);\n+      gcc_assert (TREE_OPERAND (t, 0) == v);\n+      switch (TREE_CODE (t))\n+\t{\n+\tcase PLUS_EXPR:\n+\t  step = TREE_OPERAND (t, 1);\n+\t  break;\n+\tcase POINTER_PLUS_EXPR:\n+\t  step = fold_convert (ssizetype, TREE_OPERAND (t, 1));\n+\t  break;\n+\tcase MINUS_EXPR:\n+\t  step = TREE_OPERAND (t, 1);\n+\t  step = fold_build1_loc (loc, NEGATE_EXPR, TREE_TYPE (step), step);\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  itype = type;\n+  if (POINTER_TYPE_P (itype))\n+    itype = signed_type_for (itype);\n+  if (cond_code == NE_EXPR)\n+    {\n+      /* For NE_EXPR, we need to find out if the iterator increases\n+\t or decreases from whether step is positive or negative.  */\n+      tree stype = itype;\n+      if (TYPE_UNSIGNED (stype))\n+\tstype = signed_type_for (stype);\n+      cond = fold_build2_loc (loc, GE_EXPR, boolean_type_node,\n+\t\t\t      fold_convert_loc (loc, stype, step),\n+\t\t\t      build_int_cst (stype, 0));\n+      t = fold_build3_loc (loc, COND_EXPR, itype, cond,\n+\t\t\t   build_int_cst (itype, -1),\n+\t\t\t   build_int_cst (itype, 1));\n+    }\n+  else\n+    t = build_int_cst (itype, (cond_code == LT_EXPR ? -1 : 1));\n+  t = fold_build2_loc (loc, PLUS_EXPR, itype,\n+\t\t       fold_convert_loc (loc, itype, step), t);\n+  t = fold_build2_loc (loc, PLUS_EXPR, itype, t,\n+\t\t       fold_convert_loc (loc, itype, n2));\n+  t = fold_build2_loc (loc, MINUS_EXPR, itype, t,\n+\t\t       fold_convert_loc (loc, itype, n1));\n+  if (TYPE_UNSIGNED (itype) && cond_code == GT_EXPR)\n+    t = fold_build2_loc (loc, TRUNC_DIV_EXPR, itype,\n+\t\t\t fold_build1_loc (loc, NEGATE_EXPR, itype, t),\n+\t\t\t fold_build1_loc (loc, NEGATE_EXPR, itype,\n+\t\t\t\t\t  fold_convert_loc (loc, itype,\n+\t\t\t\t\t\t\t    step)));\n+  else if (TYPE_UNSIGNED (itype) && cond_code == NE_EXPR)\n+    {\n+      tree t1\n+\t= fold_build2_loc (loc, TRUNC_DIV_EXPR, itype, t,\n+\t\t\t   fold_convert_loc (loc, itype, step));\n+      tree t2\n+\t= fold_build2_loc (loc, TRUNC_DIV_EXPR, itype,\n+\t\t\t   fold_build1_loc (loc, NEGATE_EXPR, itype, t),\n+\t\t\t   fold_build1_loc (loc, NEGATE_EXPR, itype,\n+\t\t\t\t\t    fold_convert_loc (loc, itype,\n+\t\t\t\t\t\t\t      step)));\n+      t = fold_build3_loc (loc, COND_EXPR, itype, cond, t1, t2);\n+    }\n+  else\n+    t = fold_build2_loc (loc, TRUNC_DIV_EXPR, itype, t,\n+\t\t\t fold_convert_loc (loc, itype, step));\n+  cond = fold_build2_loc (loc, cond_code, boolean_type_node, n1, n2);\n+  t = fold_build3_loc (loc, COND_EXPR, itype, cond, t,\n+\t\t       build_int_cst (itype, 0));\n+  return t;\n+}"}, {"sha": "16cc5f6ed7afcec4abf245a390c5b837bc40d6e8", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=9a771876d342f9cf0b64c2ceada267ff50e18206", "patch": "@@ -418,6 +418,7 @@ const struct c_common_resword c_common_reswords[] =\n   { \"_Complex\",\t\tRID_COMPLEX,\t0 },\n   { \"_Cilk_spawn\",      RID_CILK_SPAWN, 0 },\n   { \"_Cilk_sync\",       RID_CILK_SYNC,  0 },\n+  { \"_Cilk_for\",        RID_CILK_FOR,   0 },\n   { \"_Imaginary\",\tRID_IMAGINARY, D_CONLY },\n   { \"_Decimal32\",       RID_DFLOAT32,  D_CONLY | D_EXT },\n   { \"_Decimal64\",       RID_DFLOAT64,  D_CONLY | D_EXT },"}, {"sha": "993a97b5a665c4dae679aa4bed7d3d3c69818c05", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=9a771876d342f9cf0b64c2ceada267ff50e18206", "patch": "@@ -149,7 +149,7 @@ enum rid\n   RID_CONSTEXPR, RID_DECLTYPE, RID_NOEXCEPT, RID_NULLPTR, RID_STATIC_ASSERT,\n \n   /* Cilk Plus keywords.  */\n-  RID_CILK_SPAWN, RID_CILK_SYNC,\n+  RID_CILK_SPAWN, RID_CILK_SYNC, RID_CILK_FOR,\n   \n   /* Objective-C (\"AT\" reserved words - they are only keywords when\n      they follow '@')  */\n@@ -1395,4 +1395,5 @@ extern tree create_cilk_function_exit (tree, bool, bool);\n extern tree cilk_install_body_pedigree_operations (tree);\n extern void cilk_outline (tree, tree *, void *);\n extern bool contains_cilk_spawn_stmt (tree);\n+extern tree cilk_for_number_of_iterations (tree);\n #endif /* ! GCC_C_COMMON_H */"}, {"sha": "d6ca3df51e8d221d66a3dcc11e6f355a3e3d6704", "filename": "gcc/c-family/c-omp.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Fc-family%2Fc-omp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Fc-family%2Fc-omp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-omp.c?ref=9a771876d342f9cf0b64c2ceada267ff50e18206", "patch": "@@ -396,7 +396,7 @@ c_finish_omp_for (location_t locus, enum tree_code code, tree declv,\n   bool fail = false;\n   int i;\n \n-  if (code == CILK_SIMD\n+  if ((code == CILK_SIMD || code == CILK_FOR)\n       && !c_check_cilk_loop (locus, TREE_VEC_ELT (declv, 0)))\n     fail = true;\n \n@@ -515,7 +515,10 @@ c_finish_omp_for (location_t locus, enum tree_code code, tree declv,\n \t\t  || TREE_CODE (cond) == EQ_EXPR)\n \t\t{\n \t\t  if (!INTEGRAL_TYPE_P (TREE_TYPE (decl)))\n-\t\t    cond_ok = false;\n+\t\t    {\n+\t\t      if (code != CILK_SIMD && code != CILK_FOR)\n+\t\t\tcond_ok = false;\n+\t\t    }\n \t\t  else if (operand_equal_p (TREE_OPERAND (cond, 1),\n \t\t\t\t\t    TYPE_MIN_VALUE (TREE_TYPE (decl)),\n \t\t\t\t\t    0))\n@@ -526,7 +529,7 @@ c_finish_omp_for (location_t locus, enum tree_code code, tree declv,\n \t\t\t\t\t    0))\n \t\t    TREE_SET_CODE (cond, TREE_CODE (cond) == NE_EXPR\n \t\t\t\t\t ? LT_EXPR : GE_EXPR);\n-\t\t  else if (code != CILK_SIMD)\n+\t\t  else if (code != CILK_SIMD && code != CILK_FOR)\n \t\t    cond_ok = false;\n \t\t}\n \t    }"}, {"sha": "da928b2abddf1d1749a7f0b6b7967a8169e6745f", "filename": "gcc/c-family/c-pragma.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Fc-family%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Fc-family%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.c?ref=9a771876d342f9cf0b64c2ceada267ff50e18206", "patch": "@@ -1405,6 +1405,11 @@ init_pragma (void)\n   if (!flag_preprocess_only)\n     cpp_register_deferred_pragma (parse_in, \"GCC\", \"ivdep\", PRAGMA_IVDEP, false,\n \t\t\t\t  false);\n+\n+  if (flag_cilkplus && !flag_preprocess_only)\n+    cpp_register_deferred_pragma (parse_in, \"cilk\", \"grainsize\",\n+\t\t\t\t  PRAGMA_CILK_GRAINSIZE, true, false);\n+\n #ifdef HANDLE_PRAGMA_PACK_WITH_EXPANSION\n   c_register_pragma_with_expansion (0, \"pack\", handle_pragma_pack);\n #else"}, {"sha": "b9f09ba9f98a78d0b743b56ab4b8d0fb804fb151", "filename": "gcc/c-family/c-pragma.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Fc-family%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Fc-family%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.h?ref=9a771876d342f9cf0b64c2ceada267ff50e18206", "patch": "@@ -55,6 +55,9 @@ typedef enum pragma_kind {\n   /* Top level clause to handle all Cilk Plus pragma simd clauses.  */\n   PRAGMA_CILK_SIMD,\n \n+  /* This pragma handles setting of grainsize for a _Cilk_for.  */\n+  PRAGMA_CILK_GRAINSIZE,\n+\n   PRAGMA_GCC_PCH_PREPROCESS,\n   PRAGMA_IVDEP,\n "}, {"sha": "2d02c7b9466f30faee8ae39586b43fb1697aa31e", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=9a771876d342f9cf0b64c2ceada267ff50e18206", "patch": "@@ -1,3 +1,16 @@\n+2014-09-02  Jakub Jelinek  <jakub@redhat.com>\n+\t    Balaji V. Iyer  <balaji.v.iyer@intel.com>\n+\t    Igor Zamyatin  <igor.zamyatin@intel.com>\n+\n+\t* c-parser.c (c_parser_cilk_for): New function.\n+\t(c_parser_cilk_grainsize): Likewise.\n+\t(c_get_temp_regvar): Likewise.\n+\t(c_parser_statement_after_labels): Added RID_CILK_FOR case.\n+\t(c_parser_pragma): Added PRAGMA_CILK_GRAINSIZE case.\n+\t(c_parser_omp_for_loop): Added CILK_FOR and CILK_SIMD checks.\n+\t* c-typeck.c (c_finish_omp_clauses): Added OMP_CLAUSE__CILK_FOR_COUNT_\n+\tcase.\n+\n 2014-08-27  Chen Gang  <gang.chen.5i5j@gmail.com>\n \n \t* c-aux-info.c (gen_type): Resize 'buff' from 10 to 23 bytes,"}, {"sha": "03c68309493429a5f8d67e75ea7803b81ebb5c54", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 179, "deletions": 4, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=9a771876d342f9cf0b64c2ceada267ff50e18206", "patch": "@@ -1264,9 +1264,11 @@ static bool c_parser_objc_diagnose_bad_element_prefix\n \n /* Cilk Plus supporting routines.  */\n static void c_parser_cilk_simd (c_parser *);\n+static void c_parser_cilk_for (c_parser *, tree);\n static bool c_parser_cilk_verify_simd (c_parser *, enum pragma_context);\n static tree c_parser_array_notation (location_t, c_parser *, tree, tree);\n static tree c_parser_cilk_clause_vectorlength (c_parser *, tree, bool);\n+static void c_parser_cilk_grainsize (c_parser *);\n \n /* Parse a translation unit (C90 6.7, C99 6.9).\n \n@@ -4895,6 +4897,16 @@ c_parser_statement_after_labels (c_parser *parser)\n \tcase RID_FOR:\n \t  c_parser_for_statement (parser, false);\n \t  break;\n+\tcase RID_CILK_FOR:\n+\t  if (!flag_cilkplus)\n+\t    {\n+\t      error_at (c_parser_peek_token (parser)->location,\n+\t\t\t\"-fcilkplus must be enabled to use %<_Cilk_for%>\");\n+\t      c_parser_skip_to_end_of_block_or_statement (parser);\n+\t    }\n+\t  else\n+\t    c_parser_cilk_for (parser, integer_zero_node);\n+\t  break;\n \tcase RID_CILK_SYNC:\n \t  c_parser_consume_token (parser);\n \t  c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");\n@@ -9582,6 +9594,23 @@ c_parser_pragma (c_parser *parser, enum pragma_context context)\n       c_parser_consume_pragma (parser);\n       c_parser_cilk_simd (parser);\n       return false;\n+    case PRAGMA_CILK_GRAINSIZE:\n+      if (!flag_cilkplus)\n+\t{\n+\t  warning (0, \"%<#pragma grainsize%> ignored because -fcilkplus is not\"\n+\t\t   \" enabled\");\n+\t  c_parser_skip_until_found (parser, CPP_PRAGMA_EOL, NULL);\n+\t  return false;\n+\t}\n+      if (context == pragma_external)\n+\t{\n+\t  error_at (c_parser_peek_token (parser)->location,\n+\t\t    \"%<#pragma grainsize%> must be inside a function\");\n+\t  c_parser_skip_until_found (parser, CPP_PRAGMA_EOL, NULL);\n+\t  return false;\n+\t}\n+      c_parser_cilk_grainsize (parser);\n+      return false;\n \n     default:\n       if (id < PRAGMA_FIRST_EXTERNAL)\n@@ -11715,11 +11744,18 @@ c_parser_omp_for_loop (location_t loc, c_parser *parser, enum tree_code code,\n   condv = make_tree_vec (collapse);\n   incrv = make_tree_vec (collapse);\n \n-  if (!c_parser_next_token_is_keyword (parser, RID_FOR))\n+  if (code != CILK_FOR\n+      && !c_parser_next_token_is_keyword (parser, RID_FOR))\n     {\n       c_parser_error (parser, \"for statement expected\");\n       return NULL;\n     }\n+  if (code == CILK_FOR\n+      && !c_parser_next_token_is_keyword (parser, RID_CILK_FOR))\n+    {\n+      c_parser_error (parser, \"_Cilk_for statement expected\");\n+      return NULL;\n+    }\n   for_loc = c_parser_peek_token (parser)->location;\n   c_parser_consume_token (parser);\n \n@@ -11797,7 +11833,7 @@ c_parser_omp_for_loop (location_t loc, c_parser *parser, enum tree_code code,\n \t    case LE_EXPR:\n \t      break;\n \t    case NE_EXPR:\n-\t      if (code == CILK_SIMD)\n+\t      if (code == CILK_SIMD || code == CILK_FOR)\n \t\tbreak;\n \t      /* FALLTHRU.  */\n \t    default:\n@@ -13890,8 +13926,48 @@ c_parser_cilk_all_clauses (c_parser *parser)\n   return c_finish_cilk_clauses (clauses);\n }\n \n-/* Main entry point for parsing Cilk Plus <#pragma simd> for\n-   loops.  */\n+/* This function helps parse the grainsize pragma for a _Cilk_for statement.\n+   Here is the correct syntax of this pragma:\n+\t    #pragma cilk grainsize = <EXP>\n+ */\n+\n+static void\n+c_parser_cilk_grainsize (c_parser *parser)\n+{\n+  extern tree convert_to_integer (tree, tree);\n+\n+  /* consume the 'grainsize' keyword.  */\n+  c_parser_consume_pragma (parser);\n+\n+  if (c_parser_require (parser, CPP_EQ, \"expected %<=%>\") != 0)\n+    {\n+      struct c_expr g_expr = c_parser_binary_expression (parser, NULL, NULL);\n+      if (g_expr.value == error_mark_node)\n+\t{\n+\t  c_parser_skip_to_pragma_eol (parser);\n+\t  return;\n+\t}\n+      tree grain = convert_to_integer (long_integer_type_node,\n+\t\t\t\t       c_fully_fold (g_expr.value, false,\n+\t\t\t\t\t\t     NULL));\n+      c_parser_skip_to_pragma_eol (parser);\n+      c_token *token = c_parser_peek_token (parser);\n+      if (token && token->type == CPP_KEYWORD\n+\t  && token->keyword == RID_CILK_FOR)\n+\t{\n+\t  if (grain == NULL_TREE || grain == error_mark_node)\n+\t    grain = integer_zero_node;\n+\t  c_parser_cilk_for (parser, grain);\n+\t}\n+      else\n+\twarning (0, \"%<#pragma cilk grainsize%> is not followed by \"\n+\t\t    \"%<_Cilk_for%>\");\n+    }\n+  else\n+    c_parser_skip_to_pragma_eol (parser);\n+}\n+\n+/* Main entry point for parsing Cilk Plus <#pragma simd> for loops.  */\n \n static void\n c_parser_cilk_simd (c_parser *parser)\n@@ -13903,6 +13979,105 @@ c_parser_cilk_simd (c_parser *parser)\n   block = c_end_compound_stmt (loc, block, true);\n   add_stmt (block);\n }\n+\n+/* Create an artificial decl with TYPE and emit initialization of it with\n+   INIT.  */\n+\n+static tree\n+c_get_temp_regvar (tree type, tree init)\n+{\n+  location_t loc = EXPR_LOCATION (init);\n+  tree decl = build_decl (loc, VAR_DECL, NULL_TREE, type);\n+  DECL_ARTIFICIAL (decl) = 1;\n+  DECL_IGNORED_P (decl) = 1;\n+  pushdecl (decl);\n+  tree t = build2 (INIT_EXPR, type, decl, init);\n+  add_stmt (t);\n+  return decl;\n+}\n+\n+/* Main entry point for parsing Cilk Plus _Cilk_for loops.\n+  GRAIN is the grain value passed in through pragma or 0.  */\n+\n+static void\n+c_parser_cilk_for (c_parser *parser, tree grain)\n+{\n+  tree clauses = build_omp_clause (EXPR_LOCATION (grain), OMP_CLAUSE_SCHEDULE);\n+  OMP_CLAUSE_SCHEDULE_KIND (clauses) = OMP_CLAUSE_SCHEDULE_CILKFOR;\n+  OMP_CLAUSE_SCHEDULE_CHUNK_EXPR (clauses) = grain;\n+  clauses = c_finish_omp_clauses (clauses);\n+\n+  tree block = c_begin_compound_stmt (true);\n+  tree sb = push_stmt_list ();\n+  location_t loc = c_parser_peek_token (parser)->location;\n+  tree omp_for = c_parser_omp_for_loop (loc, parser, CILK_FOR, clauses, NULL);\n+  sb = pop_stmt_list (sb);\n+\n+  if (omp_for)\n+    {\n+      tree omp_par = make_node (OMP_PARALLEL);\n+      TREE_TYPE (omp_par) = void_type_node;\n+      OMP_PARALLEL_CLAUSES (omp_par) = NULL_TREE;\n+      tree bind = build3 (BIND_EXPR, void_type_node, NULL, NULL, NULL);\n+      TREE_SIDE_EFFECTS (bind) = 1;\n+      BIND_EXPR_BODY (bind) = sb;\n+      OMP_PARALLEL_BODY (omp_par) = bind;\n+      if (OMP_FOR_PRE_BODY (omp_for))\n+\t{\n+\t  add_stmt (OMP_FOR_PRE_BODY (omp_for));\n+\t  OMP_FOR_PRE_BODY (omp_for) = NULL_TREE;\n+\t}\n+      tree init = TREE_VEC_ELT (OMP_FOR_INIT (omp_for), 0);\n+      tree decl = TREE_OPERAND (init, 0);\n+      tree cond = TREE_VEC_ELT (OMP_FOR_COND (omp_for), 0);\n+      tree incr = TREE_VEC_ELT (OMP_FOR_INCR (omp_for), 0);\n+      tree t = TREE_OPERAND (cond, 1), c, clauses = NULL_TREE;\n+      if (TREE_CODE (t) != INTEGER_CST)\n+\t{\n+\t  TREE_OPERAND (cond, 1) = c_get_temp_regvar (TREE_TYPE (t), t);\n+\t  c = build_omp_clause (input_location, OMP_CLAUSE_FIRSTPRIVATE);\n+\t  OMP_CLAUSE_DECL (c) = TREE_OPERAND (cond, 1);\n+\t  OMP_CLAUSE_CHAIN (c) = clauses;\n+\t  clauses = c;\n+\t}\n+      if (TREE_CODE (incr) == MODIFY_EXPR)\n+\t{\n+\t  t = TREE_OPERAND (TREE_OPERAND (incr, 1), 1);\n+\t  if (TREE_CODE (t) != INTEGER_CST)\n+\t    {\n+\t      TREE_OPERAND (TREE_OPERAND (incr, 1), 1)\n+\t\t= c_get_temp_regvar (TREE_TYPE (t), t);\n+\t      c = build_omp_clause (input_location, OMP_CLAUSE_FIRSTPRIVATE);\n+\t      OMP_CLAUSE_DECL (c) = TREE_OPERAND (TREE_OPERAND (incr, 1), 1);\n+\t      OMP_CLAUSE_CHAIN (c) = clauses;\n+\t      clauses = c;\n+\t    }\n+\t}\n+      t = TREE_OPERAND (init, 1);\n+      if (TREE_CODE (t) != INTEGER_CST)\n+\t{\n+\t  TREE_OPERAND (init, 1) = c_get_temp_regvar (TREE_TYPE (t), t);\n+\t  c = build_omp_clause (input_location, OMP_CLAUSE_FIRSTPRIVATE);\n+\t  OMP_CLAUSE_DECL (c) = TREE_OPERAND (init, 1);\n+\t  OMP_CLAUSE_CHAIN (c) = clauses;\n+\t  clauses = c;\n+\t}\n+      c = build_omp_clause (input_location, OMP_CLAUSE_PRIVATE);\n+      OMP_CLAUSE_DECL (c) = decl;\n+      OMP_CLAUSE_CHAIN (c) = clauses;\n+      clauses = c;\n+      c = build_omp_clause (input_location, OMP_CLAUSE__CILK_FOR_COUNT_);\n+      OMP_CLAUSE_OPERAND (c, 0)\n+\t= cilk_for_number_of_iterations (omp_for);\n+      OMP_CLAUSE_CHAIN (c) = clauses;\n+      OMP_PARALLEL_CLAUSES (omp_par) = c_finish_omp_clauses (c);\n+      add_stmt (omp_par);\n+    }\n+\n+  block = c_end_compound_stmt (loc, block, true);\n+  add_stmt (block);\n+}\n+\n \f\n /* Parse a transaction attribute (GCC Extension).\n "}, {"sha": "da71ab263f9e3f6a69e09f32e058d186ee5a745a", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=9a771876d342f9cf0b64c2ceada267ff50e18206", "patch": "@@ -12229,6 +12229,7 @@ c_finish_omp_clauses (tree clauses)\n \tcase OMP_CLAUSE_SECTIONS:\n \tcase OMP_CLAUSE_TASKGROUP:\n \tcase OMP_CLAUSE_PROC_BIND:\n+\tcase OMP_CLAUSE__CILK_FOR_COUNT_:\n \t  pc = &OMP_CLAUSE_CHAIN (c);\n \t  continue;\n "}, {"sha": "bf319d594fa1cd2581b9e56422d25313fe2ae365", "filename": "gcc/cilk-builtins.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Fcilk-builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Fcilk-builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcilk-builtins.def?ref=9a771876d342f9cf0b64c2ceada267ff50e18206", "patch": "@@ -31,3 +31,5 @@ DEF_CILK_BUILTIN_STUB (BUILT_IN_CILK_SYNC, \"__cilkrts_sync\")\n DEF_CILK_BUILTIN_STUB (BUILT_IN_CILK_LEAVE_FRAME, \"__cilkrts_leave_frame\")\n DEF_CILK_BUILTIN_STUB (BUILT_IN_CILK_POP_FRAME, \"__cilkrts_pop_frame\")\n DEF_CILK_BUILTIN_STUB (BUILT_IN_CILK_SAVE_FP, \"__cilkrts_save_fp_ctrl_state\")\n+DEF_CILK_BUILTIN_STUB (BUILT_IN_CILK_FOR_32, \"__cilkrts_cilk_for_32\")\n+DEF_CILK_BUILTIN_STUB (BUILT_IN_CILK_FOR_64, \"__cilkrts_cilk_for_64\")"}, {"sha": "35c47e19cd754c61327c8cdef658c8c2cf88a709", "filename": "gcc/cilk-common.c", "status": "modified", "additions": 37, "deletions": 8, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Fcilk-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Fcilk-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcilk-common.c?ref=9a771876d342f9cf0b64c2ceada267ff50e18206", "patch": "@@ -105,6 +105,27 @@ install_builtin (const char *name, tree fntype, enum built_in_function code,\n   return fndecl;\n }\n \n+/* Returns a FUNCTION_DECL of type TYPE whose name is *NAME.  */\n+\n+static tree\n+declare_cilk_for_builtin (const char *name, tree type,\n+\t\t\t  enum built_in_function code)\n+{\n+  tree cb, ft, fn;\n+\n+  cb = build_function_type_list (void_type_node,\n+\t\t\t\t ptr_type_node, type, type,\n+\t\t\t\t NULL_TREE);\n+  cb = build_pointer_type (cb);\n+  ft = build_function_type_list (void_type_node,\n+\t\t\t\t cb, ptr_type_node, type,\n+\t\t\t\t integer_type_node, NULL_TREE);\n+  fn = install_builtin (name, ft, code, false);\n+  TREE_NOTHROW (fn) = 0;\n+\n+  return fn;\n+}\n+\n /* Creates and initializes all the built-in Cilk keywords functions and three\n    structures: __cilkrts_stack_frame, __cilkrts_pedigree and __cilkrts_worker.\n    Detailed information about __cilkrts_stack_frame and\n@@ -119,7 +140,7 @@ cilk_init_builtins (void)\n         uint64_t rank;\n         struct __cilkrts_pedigree *parent;\n       }  */\n-       \n+\n   tree pedigree_type = lang_hooks.types.make_type (RECORD_TYPE);\n   tree pedigree_ptr  = build_pointer_type (pedigree_type);\n   tree field = add_field (\"rank\", uint64_type_node, NULL_TREE);\n@@ -131,7 +152,7 @@ cilk_init_builtins (void)\n   lang_hooks.types.register_builtin_type (pedigree_type,\n \t\t\t\t\t  \"__cilkrts_pedigree_t\");\n   cilk_pedigree_type_decl = pedigree_type; \n-  \n+\n   /* Build the Cilk Stack Frame:\n      struct __cilkrts_stack_frame {\n        uint32_t flags;\n@@ -212,7 +233,7 @@ cilk_init_builtins (void)\n   tree sysdep_t = lang_hooks.types.make_type (RECORD_TYPE);\n   finish_builtin_struct (sysdep_t, \"__cilkrts_worker_sysdep_state\", NULL_TREE,\n \t\t\t NULL_TREE);\n-  \n+\n   field = add_field (\"tail\", fptr_vol_ptr_vol, NULL_TREE);\n   cilk_trees[CILK_TI_WORKER_TAIL] = field;\n   field = add_field (\"head\", fptr_vol_ptr_vol, field);\n@@ -234,16 +255,16 @@ cilk_init_builtins (void)\n \n   tree fptr_arglist = tree_cons (NULL_TREE, frame_ptr, void_list_node);\n   tree fptr_fun = build_function_type (void_type_node, fptr_arglist);\n-  \n+\n   /* void __cilkrts_enter_frame_1 (__cilkrts_stack_frame *);  */\n   cilk_enter_fndecl = install_builtin (\"__cilkrts_enter_frame_1\", fptr_fun,\n \t\t\t\t       BUILT_IN_CILK_ENTER_FRAME, false);\n \n   /* void __cilkrts_enter_frame_fast_1 (__cilkrts_stack_frame *);  */\n   cilk_enter_fast_fndecl = \n-    install_builtin (\"__cilkrts_enter_frame_fast_1\", fptr_fun, \n+    install_builtin (\"__cilkrts_enter_frame_fast_1\", fptr_fun,\n \t\t     BUILT_IN_CILK_ENTER_FRAME_FAST, false);\n-  \n+\n   /* void __cilkrts_pop_frame (__cilkrts_stack_frame *);  */\n   cilk_pop_fndecl = install_builtin (\"__cilkrts_pop_frame\", fptr_fun,\n \t\t\t\t     BUILT_IN_CILK_POP_FRAME, false);\n@@ -261,14 +282,22 @@ cilk_init_builtins (void)\n \t\t\t\t\tBUILT_IN_CILK_DETACH, false);\n \n   /* __cilkrts_rethrow (struct stack_frame *);  */\n-  cilk_rethrow_fndecl = install_builtin (\"__cilkrts_rethrow\", fptr_fun, \n+  cilk_rethrow_fndecl = install_builtin (\"__cilkrts_rethrow\", fptr_fun,\n \t\t\t\t\t BUILT_IN_CILK_RETHROW, false);\n   TREE_NOTHROW (cilk_rethrow_fndecl) = 0;\n \n   /* __cilkrts_save_fp_ctrl_state (__cilkrts_stack_frame *);  */\n-  cilk_save_fp_fndecl = install_builtin (\"__cilkrts_save_fp_ctrl_state\", \n+  cilk_save_fp_fndecl = install_builtin (\"__cilkrts_save_fp_ctrl_state\",\n \t\t\t\t\t fptr_fun, BUILT_IN_CILK_SAVE_FP,\n \t\t\t\t\t false);\n+  /* __cilkrts_cilk_for_32 (...);  */\n+  cilk_for_32_fndecl = declare_cilk_for_builtin (\"__cilkrts_cilk_for_32\",\n+\t\t\t\t\t\t unsigned_intSI_type_node,\n+\t\t\t\t\t\t BUILT_IN_CILK_FOR_32);\n+  /* __cilkrts_cilk_for_64 (...);  */\n+  cilk_for_64_fndecl = declare_cilk_for_builtin (\"__cilkrts_cilk_for_64\",\n+\t\t\t\t\t\t unsigned_intDI_type_node,\n+\t\t\t\t\t\t BUILT_IN_CILK_FOR_64);\n }\n \n /* Get the appropriate frame arguments for CALL that is of type CALL_EXPR.  */"}, {"sha": "1fee929af19ccc3d40bf0b64af2df042c4a7c892", "filename": "gcc/cilk.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Fcilk.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Fcilk.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcilk.h?ref=9a771876d342f9cf0b64c2ceada267ff50e18206", "patch": "@@ -40,6 +40,9 @@ enum cilk_tree_index  {\n   CILK_TI_F_POP,                      /* __cilkrts_pop_frame (...).  */\n   CILK_TI_F_RETHROW,                  /* __cilkrts_rethrow (...).  */\n   CILK_TI_F_SAVE_FP,                  /* __cilkrts_save_fp_ctrl_state (...).  */\n+  CILK_TI_F_LOOP_32,                  /* __cilkrts_cilk_for_32 (...).  */\n+  CILK_TI_F_LOOP_64,                  /* __cilkrts_cilk_for_64 (...).  */\n+\n   /* __cilkrts_stack_frame struct fields.  */\n   CILK_TI_FRAME_FLAGS,                /* stack_frame->flags.  */\n   CILK_TI_FRAME_PARENT,               /* stack_frame->parent.  */\n@@ -77,6 +80,8 @@ extern GTY (()) tree cilk_trees[CILK_TI_MAX];\n #define cilk_rethrow_fndecl           cilk_trees[CILK_TI_F_RETHROW]\n #define cilk_pop_fndecl               cilk_trees[CILK_TI_F_POP]\n #define cilk_save_fp_fndecl           cilk_trees[CILK_TI_F_SAVE_FP]\n+#define cilk_for_32_fndecl            cilk_trees[CILK_TI_F_LOOP_32]\n+#define cilk_for_64_fndecl            cilk_trees[CILK_TI_F_LOOP_64]\n \n #define cilk_worker_type_fndecl       cilk_trees[CILK_TI_WORKER_TYPE]\n #define cilk_frame_type_decl          cilk_trees[CILK_TI_FRAME_TYPE]"}, {"sha": "7a72097c64676a863858546e2ff17e61cfaf9a45", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9a771876d342f9cf0b64c2ceada267ff50e18206", "patch": "@@ -1,3 +1,31 @@\n+2014-09-02  Jakub Jelinek  <jakub@redhat.com>\n+\t    Balaji V. Iyer  <balaji.v.iyer@intel.com>\n+\t    Igor Zamyatin  <igor.zamyatin@intel.com>\n+\n+\t* cp-cilkplus.c (cpp_validate_cilk_plus_loop_aux): Loc definition\n+\tsimplified.\n+\t* parser.c (cp_parser_cilk_for): New function.\n+\t(cp_parser_cilk_grainsize): Likewise.\n+\t(cp_parser_statement): Added RID_CILK_FOR case.\n+\t(cp_parser_omp_for_cond): Added CILK_FOR check.\n+\t(cp_parser_omp_for_loop_init): Change function argument to accept\n+\ttree_code instead just a bool flag; change the check to use that\n+\ttree_code; check for initialization declaration in case of Cilk_for.\n+\t(cp_parser_omp_for_loop): Added checks for CILK_FOR and RID_CILK_FOR;\n+\tchanged call to cp_parser_omp_for_loop_init according new arguments'\n+\tlist.\n+\t(cp_parser_pragma): Added PRAGMA_CILK_GRAINSIZE case.\n+\t* pt.c (tsubst_expr): Added CILK_FOR case.\n+\t* semantics.c: Include convert.h.\n+\t(finish_omp_clauses): Properly handle OMP_CLAUSE_SCHEDULE_CILKFOR\n+\tcase; added OMP_CLAUSE__CILK_FOR_COUNT_.\n+\t(handle_omp_for_class_iterator): New argument lastp and its usage;\n+\tadded NE_EXPR case.\n+\t(finish_omp_for): Changed call to handle_omp_for_class_iterator\n+\taccording new arguments' list; in case of Cilk_for save very first\n+\tdecl and create empty stmt_list block; use block to build correct\n+\tstatement tree.\n+\n 2014-08-31  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/62302"}, {"sha": "565dd402f70da1db530b174ac7382a8a3e895484", "filename": "gcc/cp/cp-cilkplus.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Fcp%2Fcp-cilkplus.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Fcp%2Fcp-cilkplus.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-cilkplus.c?ref=9a771876d342f9cf0b64c2ceada267ff50e18206", "patch": "@@ -42,12 +42,11 @@ static tree\n cpp_validate_cilk_plus_loop_aux (tree *tp, int *walk_subtrees, void *data)\n {\n   bool *valid = (bool *) data;\n-  location_t loc = EXPR_HAS_LOCATION (*tp) ? EXPR_LOCATION (*tp) :\n-    UNKNOWN_LOCATION;\n \n   if (!tp || !*tp)\n     return NULL_TREE;\n \n+  location_t loc = EXPR_LOCATION (*tp);\n   if (TREE_CODE (*tp) == THROW_EXPR)\n     {\n       error_at (loc, \"throw expressions are not allowed inside loops \"\n@@ -142,4 +141,3 @@ cilk_install_body_with_frame_cleanup (tree fndecl, tree orig_body, void *wd)\n   append_to_statement_list (build_stmt (loc, TRY_FINALLY_EXPR, body, dtor),\n \t\t\t    &list);\n }\n-"}, {"sha": "05fa86a655b96ad0b3509a585349bc8de94798c5", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 113, "deletions": 14, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=9a771876d342f9cf0b64c2ceada267ff50e18206", "patch": "@@ -239,6 +239,8 @@ static tree cp_literal_operator_id\n \n static void cp_parser_cilk_simd\n   (cp_parser *, cp_token *);\n+static tree cp_parser_cilk_for\n+  (cp_parser *, tree);\n static bool cp_parser_omp_declare_reduction_exprs\n   (tree, cp_parser *);\n static tree cp_parser_cilk_simd_vectorlength \n@@ -9532,6 +9534,18 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n \t  statement = cp_parser_iteration_statement (parser, false);\n \t  break;\n \n+\tcase RID_CILK_FOR:\n+\t  if (!flag_cilkplus)\n+\t    {\n+\t      error_at (cp_lexer_peek_token (parser->lexer)->location,\n+\t\t\t\"-fcilkplus must be enabled to use %<_Cilk_for%>\");\n+\t      cp_lexer_consume_token (parser->lexer);\n+\t      statement = error_mark_node;\n+\t    }\n+\t  else\n+\t    statement = cp_parser_cilk_for (parser, integer_zero_node);\n+\t  break;\n+\n \tcase RID_BREAK:\n \tcase RID_CONTINUE:\n \tcase RID_RETURN:\n@@ -29222,7 +29236,7 @@ cp_parser_omp_for_cond (cp_parser *parser, tree decl, enum tree_code code)\n     case LE_EXPR:\n       break;\n     case NE_EXPR:\n-      if (code == CILK_SIMD)\n+      if (code == CILK_SIMD || code == CILK_FOR)\n \tbreak;\n       /* Fall through: OpenMP disallows NE_EXPR.  */\n     default:\n@@ -29337,15 +29351,12 @@ cp_parser_omp_for_incr (cp_parser *parser, tree decl)\n /* Parse the initialization statement of either an OpenMP for loop or\n    a Cilk Plus for loop.\n \n-   PARSING_OPENMP is true if parsing OpenMP, or false if parsing Cilk\n-   Plus.\n-\n    Return true if the resulting construct should have an\n    OMP_CLAUSE_PRIVATE added to it.  */\n \n static bool\n cp_parser_omp_for_loop_init (cp_parser *parser,\n-\t\t\t     bool parsing_openmp,\n+\t\t\t     enum tree_code code,\n \t\t\t     tree &this_pre_body,\n \t\t\t     vec<tree, va_gc> *for_block,\n \t\t\t     tree &init,\n@@ -29408,7 +29419,7 @@ cp_parser_omp_for_loop_init (cp_parser *parser,\n \t      if (cp_lexer_next_token_is (parser->lexer, \n \t\t\t\t\t  CPP_OPEN_PAREN))\n \t\t{\n-\t\t  if (parsing_openmp)\n+\t\t  if (code != CILK_SIMD && code != CILK_FOR)\n \t\t    error (\"parenthesized initialization is not allowed in \"\n \t\t\t   \"OpenMP %<for%> loop\");\n \t\t  else\n@@ -29480,6 +29491,9 @@ cp_parser_omp_for_loop_init (cp_parser *parser,\n       cp_id_kind idk;\n       /* If parsing a type specifier sequence failed, then\n \t this MUST be a simple expression.  */\n+      if (code == CILK_FOR)\n+\terror (\"%<_Cilk_for%> allows expression instead of declaration only \"\n+\t       \"in C, not in C++\");\n       cp_parser_parse_tentatively (parser);\n       decl = cp_parser_primary_expression (parser, false, false,\n \t\t\t\t\t   false, &idk);\n@@ -29548,11 +29562,18 @@ cp_parser_omp_for_loop (cp_parser *parser, enum tree_code code, tree clauses,\n       bool add_private_clause = false;\n       location_t loc;\n \n-      if (!cp_lexer_next_token_is_keyword (parser->lexer, RID_FOR))\n+      if (code != CILK_FOR\n+\t  && !cp_lexer_next_token_is_keyword (parser->lexer, RID_FOR))\n \t{\n \t  cp_parser_error (parser, \"for statement expected\");\n \t  return NULL;\n \t}\n+      if (code == CILK_FOR\n+\t  && !cp_lexer_next_token_is_keyword (parser->lexer, RID_CILK_FOR))\n+\t{\n+\t  cp_parser_error (parser, \"_Cilk_for statement expected\");\n+\t  return NULL;\n+\t}\n       loc = cp_lexer_consume_token (parser->lexer)->location;\n \n       if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n@@ -29562,8 +29583,7 @@ cp_parser_omp_for_loop (cp_parser *parser, enum tree_code code, tree clauses,\n       this_pre_body = push_stmt_list ();\n \n       add_private_clause\n-\t|= cp_parser_omp_for_loop_init (parser,\n-\t\t\t\t\t/*parsing_openmp=*/code != CILK_SIMD,\n+\t|= cp_parser_omp_for_loop_init (parser, code,\n \t\t\t\t\tthis_pre_body, for_block,\n \t\t\t\t\tinit, decl, real_decl);\n \n@@ -29733,7 +29753,7 @@ cp_parser_omp_for_loop (cp_parser *parser, enum tree_code code, tree clauses,\n \n   /* Note that we saved the original contents of this flag when we entered\n      the structured block, and so we don't need to re-save it here.  */\n-  if (code == CILK_SIMD)\n+  if (code == CILK_SIMD || code == CILK_FOR)\n     parser->in_statement = IN_CILK_SIMD_FOR;\n   else\n     parser->in_statement = IN_OMP_FOR;\n@@ -31692,6 +31712,36 @@ cp_parser_initial_pragma (cp_token *first_token)\n   cp_lexer_get_preprocessor_token (NULL, first_token);\n }\n \n+/* Parses the grainsize pragma for the _Cilk_for statement.\n+   Syntax:\n+   #pragma cilk grainsize = <VALUE>.  */\n+\n+static void\n+cp_parser_cilk_grainsize (cp_parser *parser, cp_token *pragma_tok)\n+{\n+  if (cp_parser_require (parser, CPP_EQ, RT_EQ))\n+    {\n+      tree exp = cp_parser_binary_expression (parser, false, false,\n+\t\t\t\t\t      PREC_NOT_OPERATOR, NULL);\n+      cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n+      if (!exp || exp == error_mark_node)\n+\t{\n+\t  error_at (pragma_tok->location, \"invalid grainsize for _Cilk_for\");\n+\t  return;\n+\t}\n+\n+      /* Make sure the next token is _Cilk_for, it is invalid otherwise.  */\n+      if (cp_lexer_next_token_is_keyword (parser->lexer, RID_CILK_FOR))\n+\tcp_parser_cilk_for (parser, exp);\n+      else\n+\twarning_at (cp_lexer_peek_token (parser->lexer)->location, 0,\n+\t\t    \"%<#pragma cilk grainsize%> is not followed by \"\n+\t\t    \"%<_Cilk_for%>\");\n+      return;\n+    }\n+  cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n+}\n+\n /* Normal parsing of a pragma token.  Here we can (and must) use the\n    regular lexer.  */\n \n@@ -31874,6 +31924,27 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context)\n       cp_parser_cilk_simd (parser, pragma_tok);\n       return true;\n \n+    case PRAGMA_CILK_GRAINSIZE:\n+      if (context == pragma_external)\n+\t{\n+\t  error_at (pragma_tok->location,\n+\t\t    \"%<#pragma cilk grainsize%> must be inside a function\");\n+\t  break;\n+\t}\n+\n+      /* Ignore the pragma if Cilk Plus is not enabled.  */\n+      if (flag_cilkplus)\n+\t{\n+\t  cp_parser_cilk_grainsize (parser, pragma_tok);\n+\t  return true;\n+\t}\n+      else\n+\t{\n+\t  error_at (pragma_tok->location, \"-fcilkplus must be enabled to use \"\n+\t\t    \"%<#pragma cilk grainsize%>\");\n+\t  break;\n+\t}\n+\n     default:\n       gcc_assert (id >= PRAGMA_FIRST_EXTERNAL);\n       c_invoke_pragma_handler (id);\n@@ -31960,10 +32031,10 @@ cp_parser_cilk_simd_vectorlength (cp_parser *parser, tree clauses,\n \n   if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n     return error_mark_node;\n-  \n+\n   expr = cp_parser_constant_expression (parser, false, NULL);\n   expr = maybe_constant_value (expr);\n-  \n+\n   /* If expr == error_mark_node, then don't emit any errors nor\n      create a clause.  if any of the above functions returns\n      error mark node then they would have emitted an error message.  */\n@@ -32197,7 +32268,7 @@ cp_parser_cilk_simd (cp_parser *parser, cp_token *pragma_token)\n \n   if (clauses == error_mark_node)\n     return;\n-  \n+\n   if (cp_lexer_next_token_is_not_keyword (parser->lexer, RID_FOR))\n     {\n       error_at (cp_lexer_peek_token (parser->lexer)->location,\n@@ -32212,7 +32283,35 @@ cp_parser_cilk_simd (cp_parser *parser, cp_token *pragma_token)\n     cpp_validate_cilk_plus_loop (OMP_FOR_BODY (ret));\n   cp_parser_end_omp_structured_block (parser, save);\n   add_stmt (finish_omp_structured_block (sb));\n-  return;\n+}\n+\n+/* Main entry-point for parsing Cilk Plus _Cilk_for\n+   loops.  The return value is error_mark_node\n+   when errors happen and CILK_FOR tree on success.  */\n+\n+static tree\n+cp_parser_cilk_for (cp_parser *parser, tree grain)\n+{\n+  if (cp_lexer_next_token_is_not_keyword (parser->lexer, RID_CILK_FOR))\n+    gcc_unreachable ();\n+\n+  tree sb = begin_omp_structured_block ();\n+  int save = cp_parser_begin_omp_structured_block (parser);\n+\n+  tree clauses = build_omp_clause (EXPR_LOCATION (grain), OMP_CLAUSE_SCHEDULE);\n+  OMP_CLAUSE_SCHEDULE_KIND (clauses) = OMP_CLAUSE_SCHEDULE_CILKFOR;\n+  OMP_CLAUSE_SCHEDULE_CHUNK_EXPR (clauses) = grain;\n+  clauses = finish_omp_clauses (clauses);\n+\n+  tree ret = cp_parser_omp_for_loop (parser, CILK_FOR, clauses, NULL);\n+  if (ret)\n+    cpp_validate_cilk_plus_loop (ret);\n+  else\n+    ret = error_mark_node;\n+\n+  cp_parser_end_omp_structured_block (parser, save);\n+  add_stmt (finish_omp_structured_block (sb));\n+  return ret;\n }\n \n /* Create an identifier for a generic parameter type (a synthesized"}, {"sha": "5ea5a5854d89325da9e9cb3db446a9b1ed3973ec", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=9a771876d342f9cf0b64c2ceada267ff50e18206", "patch": "@@ -14012,6 +14012,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n     case OMP_FOR:\n     case OMP_SIMD:\n     case CILK_SIMD:\n+    case CILK_FOR:\n     case OMP_DISTRIBUTE:\n       {\n \ttree clauses, body, pre_body;"}, {"sha": "01748dab0e8fda2b050b8161c6eca90b3b97eed4", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 145, "deletions": 7, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=9a771876d342f9cf0b64c2ceada267ff50e18206", "patch": "@@ -49,6 +49,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"bitmap.h\"\n #include \"omp-low.h\"\n #include \"builtins.h\"\n+#include \"convert.h\"\n \n static bool verify_constant (tree, bool, bool *, bool *);\n #define VERIFY_CONSTANT(X)\t\t\t\t\t\t\\\n@@ -5424,6 +5425,8 @@ finish_omp_clauses (tree clauses)\n \t  else if (t == error_mark_node)\n \t    remove = true;\n \t  else if (!type_dependent_expression_p (t)\n+\t\t   && (OMP_CLAUSE_SCHEDULE_KIND (c)\n+\t\t       != OMP_CLAUSE_SCHEDULE_CILKFOR)\n \t\t   && !INTEGRAL_TYPE_P (TREE_TYPE (t)))\n \t    {\n \t      error (\"schedule chunk size expression must be integral\");\n@@ -5433,7 +5436,19 @@ finish_omp_clauses (tree clauses)\n \t    {\n \t      t = mark_rvalue_use (t);\n \t      if (!processing_template_decl)\n-\t\tt = fold_build_cleanup_point_expr (TREE_TYPE (t), t);\n+\t\t{\n+\t\t  if (OMP_CLAUSE_SCHEDULE_KIND (c)\n+\t\t      == OMP_CLAUSE_SCHEDULE_CILKFOR)\n+\t\t    {\n+\t\t      t = convert_to_integer (long_integer_type_node, t);\n+\t\t      if (t == error_mark_node)\n+\t\t\t{\n+\t\t\t  remove = true;\n+\t\t\t  break;\n+\t\t\t}\n+\t\t    }\n+\t\t  t = fold_build_cleanup_point_expr (TREE_TYPE (t), t);\n+\t\t}\n \t      OMP_CLAUSE_SCHEDULE_CHUNK_EXPR (c) = t;\n \t    }\n \t  break;\n@@ -5734,6 +5749,7 @@ finish_omp_clauses (tree clauses)\n \tcase OMP_CLAUSE_SECTIONS:\n \tcase OMP_CLAUSE_TASKGROUP:\n \tcase OMP_CLAUSE_PROC_BIND:\n+\tcase OMP_CLAUSE__CILK_FOR_COUNT_:\n \t  break;\n \n \tcase OMP_CLAUSE_INBRANCH:\n@@ -6053,7 +6069,7 @@ finish_omp_task (tree clauses, tree body)\n static bool\n handle_omp_for_class_iterator (int i, location_t locus, tree declv, tree initv,\n \t\t\t       tree condv, tree incrv, tree *body,\n-\t\t\t       tree *pre_body, tree clauses)\n+\t\t\t       tree *pre_body, tree clauses, tree *lastp)\n {\n   tree diff, iter_init, iter_incr = NULL, last;\n   tree incr_var = NULL, orig_pre_body, orig_body, c;\n@@ -6073,6 +6089,7 @@ handle_omp_for_class_iterator (int i, location_t locus, tree declv, tree initv,\n     case GE_EXPR:\n     case LT_EXPR:\n     case LE_EXPR:\n+    case NE_EXPR:\n       if (TREE_OPERAND (cond, 1) == iter)\n \tcond = build2 (swap_tree_comparison (TREE_CODE (cond)),\n \t\t       TREE_TYPE (cond), iter, TREE_OPERAND (cond, 0));\n@@ -6285,6 +6302,7 @@ handle_omp_for_class_iterator (int i, location_t locus, tree declv, tree initv,\n   TREE_VEC_ELT (initv, i) = init;\n   TREE_VEC_ELT (condv, i) = cond;\n   TREE_VEC_ELT (incrv, i) = incr;\n+  *lastp = last;\n \n   return false;\n }\n@@ -6301,7 +6319,8 @@ finish_omp_for (location_t locus, enum tree_code code, tree declv, tree initv,\n \t\ttree condv, tree incrv, tree body, tree pre_body, tree clauses)\n {\n   tree omp_for = NULL, orig_incr = NULL;\n-  tree decl, init, cond, incr;\n+  tree decl = NULL, init, cond, incr, orig_decl = NULL_TREE, block = NULL_TREE;\n+  tree last = NULL_TREE;\n   location_t elocus;\n   int i;\n \n@@ -6431,8 +6450,11 @@ finish_omp_for (location_t locus, enum tree_code code, tree declv, tree initv,\n \t\t\t\t\"iteration variable %qE\", decl);\n \t      return NULL;\n \t    }\n+\t  if (code == CILK_FOR && i == 0)\n+\t    orig_decl = decl;\n \t  if (handle_omp_for_class_iterator (i, locus, declv, initv, condv,\n-\t\t\t\t\t     incrv, &body, &pre_body, clauses))\n+\t\t\t\t\t     incrv, &body, &pre_body,\n+\t\t\t\t\t     clauses, &last))\n \t    return NULL;\n \t  continue;\n \t}\n@@ -6485,11 +6507,18 @@ finish_omp_for (location_t locus, enum tree_code code, tree declv, tree initv,\n   if (IS_EMPTY_STMT (pre_body))\n     pre_body = NULL;\n \n+  if (code == CILK_FOR && !processing_template_decl)\n+    block = push_stmt_list ();\n+\n   omp_for = c_finish_omp_for (locus, code, declv, initv, condv, incrv,\n \t\t\t      body, pre_body);\n \n   if (omp_for == NULL)\n-    return NULL;\n+    {\n+      if (block)\n+\tpop_stmt_list (block);\n+      return NULL;\n+    }\n \n   for (i = 0; i < TREE_VEC_LENGTH (OMP_FOR_INCR (omp_for)); i++)\n     {\n@@ -6523,8 +6552,117 @@ finish_omp_for (location_t locus, enum tree_code code, tree declv, tree initv,\n       if (orig_incr)\n \tTREE_VEC_ELT (OMP_FOR_INCR (omp_for), i) = TREE_VEC_ELT (orig_incr, i);\n     }\n-  if (omp_for != NULL)\n-    OMP_FOR_CLAUSES (omp_for) = clauses;\n+  OMP_FOR_CLAUSES (omp_for) = clauses;\n+\n+  if (block)\n+    {\n+      tree omp_par = make_node (OMP_PARALLEL);\n+      TREE_TYPE (omp_par) = void_type_node;\n+      OMP_PARALLEL_CLAUSES (omp_par) = NULL_TREE;\n+      tree bind = build3 (BIND_EXPR, void_type_node, NULL, NULL, NULL);\n+      TREE_SIDE_EFFECTS (bind) = 1;\n+      BIND_EXPR_BODY (bind) = pop_stmt_list (block);\n+      OMP_PARALLEL_BODY (omp_par) = bind;\n+      if (OMP_FOR_PRE_BODY (omp_for))\n+\t{\n+\t  add_stmt (OMP_FOR_PRE_BODY (omp_for));\n+\t  OMP_FOR_PRE_BODY (omp_for) = NULL_TREE;\n+\t}\n+      init = TREE_VEC_ELT (OMP_FOR_INIT (omp_for), 0);\n+      decl = TREE_OPERAND (init, 0);\n+      cond = TREE_VEC_ELT (OMP_FOR_COND (omp_for), 0);\n+      incr = TREE_VEC_ELT (OMP_FOR_INCR (omp_for), 0);\n+      tree t = TREE_OPERAND (cond, 1), c, clauses, *pc;\n+      clauses = OMP_FOR_CLAUSES (omp_for);\n+      OMP_FOR_CLAUSES (omp_for) = NULL_TREE;\n+      for (pc = &clauses; *pc; )\n+\tif (OMP_CLAUSE_CODE (*pc) == OMP_CLAUSE_SCHEDULE)\n+\t  {\n+\t    gcc_assert (OMP_FOR_CLAUSES (omp_for) == NULL_TREE);\n+\t    OMP_FOR_CLAUSES (omp_for) = *pc;\n+\t    *pc = OMP_CLAUSE_CHAIN (*pc);\n+\t    OMP_CLAUSE_CHAIN (OMP_FOR_CLAUSES (omp_for)) = NULL_TREE;\n+\t  }\n+\telse\n+\t  {\n+\t    gcc_assert (OMP_CLAUSE_CODE (*pc) == OMP_CLAUSE_FIRSTPRIVATE);\n+\t    pc = &OMP_CLAUSE_CHAIN (*pc);\n+\t  }\n+      if (TREE_CODE (t) != INTEGER_CST)\n+\t{\n+\t  TREE_OPERAND (cond, 1) = get_temp_regvar (TREE_TYPE (t), t);\n+\t  c = build_omp_clause (input_location, OMP_CLAUSE_FIRSTPRIVATE);\n+\t  OMP_CLAUSE_DECL (c) = TREE_OPERAND (cond, 1);\n+\t  OMP_CLAUSE_CHAIN (c) = clauses;\n+\t  clauses = c;\n+\t}\n+      if (TREE_CODE (incr) == MODIFY_EXPR)\n+\t{\n+\t  t = TREE_OPERAND (TREE_OPERAND (incr, 1), 1);\n+\t  if (TREE_CODE (t) != INTEGER_CST)\n+\t    {\n+\t      TREE_OPERAND (TREE_OPERAND (incr, 1), 1)\n+\t\t= get_temp_regvar (TREE_TYPE (t), t);\n+\t      c = build_omp_clause (input_location, OMP_CLAUSE_FIRSTPRIVATE);\n+\t      OMP_CLAUSE_DECL (c) = TREE_OPERAND (TREE_OPERAND (incr, 1), 1);\n+\t      OMP_CLAUSE_CHAIN (c) = clauses;\n+\t      clauses = c;\n+\t    }\n+\t}\n+      t = TREE_OPERAND (init, 1);\n+      if (TREE_CODE (t) != INTEGER_CST)\n+\t{\n+\t  TREE_OPERAND (init, 1) = get_temp_regvar (TREE_TYPE (t), t);\n+\t  c = build_omp_clause (input_location, OMP_CLAUSE_FIRSTPRIVATE);\n+\t  OMP_CLAUSE_DECL (c) = TREE_OPERAND (init, 1);\n+\t  OMP_CLAUSE_CHAIN (c) = clauses;\n+\t  clauses = c;\n+\t}\n+      if (orig_decl && orig_decl != decl)\n+\t{\n+\t  c = build_omp_clause (input_location, OMP_CLAUSE_FIRSTPRIVATE);\n+\t  OMP_CLAUSE_DECL (c) = orig_decl;\n+\t  OMP_CLAUSE_CHAIN (c) = clauses;\n+\t  clauses = c;\n+\t}\n+      if (last)\n+\t{\n+\t  c = build_omp_clause (input_location, OMP_CLAUSE_FIRSTPRIVATE);\n+\t  OMP_CLAUSE_DECL (c) = last;\n+\t  OMP_CLAUSE_CHAIN (c) = clauses;\n+\t  clauses = c;\n+\t}\n+      c = build_omp_clause (input_location, OMP_CLAUSE_PRIVATE);\n+      OMP_CLAUSE_DECL (c) = decl;\n+      OMP_CLAUSE_CHAIN (c) = clauses;\n+      clauses = c;\n+      c = build_omp_clause (input_location, OMP_CLAUSE__CILK_FOR_COUNT_);\n+      OMP_CLAUSE_OPERAND (c, 0)\n+\t= cilk_for_number_of_iterations (omp_for);\n+      OMP_CLAUSE_CHAIN (c) = clauses;\n+      OMP_PARALLEL_CLAUSES (omp_par) = finish_omp_clauses (c);\n+      add_stmt (omp_par);\n+      return omp_par;\n+    }\n+  else if (code == CILK_FOR && processing_template_decl)\n+    {\n+      tree c, clauses = OMP_FOR_CLAUSES (omp_for);\n+      if (orig_decl && orig_decl != decl)\n+\t{\n+\t  c = build_omp_clause (input_location, OMP_CLAUSE_FIRSTPRIVATE);\n+\t  OMP_CLAUSE_DECL (c) = orig_decl;\n+\t  OMP_CLAUSE_CHAIN (c) = clauses;\n+\t  clauses = c;\n+\t}\n+      if (last)\n+\t{\n+\t  c = build_omp_clause (input_location, OMP_CLAUSE_FIRSTPRIVATE);\n+\t  OMP_CLAUSE_DECL (c) = last;\n+\t  OMP_CLAUSE_CHAIN (c) = clauses;\n+\t  clauses = c;\n+\t}\n+      OMP_FOR_CLAUSES (omp_for) = clauses;\n+    }\n   return omp_for;\n }\n "}, {"sha": "60b56b0d3d4bc7133fa89873321898a29f9591af", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=9a771876d342f9cf0b64c2ceada267ff50e18206", "patch": "@@ -1135,6 +1135,9 @@ dump_gimple_omp_for (pretty_printer *buffer, gimple gs, int spc, int flags)\n \tcase GF_OMP_FOR_KIND_DISTRIBUTE:\n \t  kind = \" distribute\";\n \t  break;\n+\tcase GF_OMP_FOR_KIND_CILKFOR:\n+\t  kind = \" _Cilk_for\";\n+\t  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -1169,16 +1172,24 @@ dump_gimple_omp_for (pretty_printer *buffer, gimple gs, int spc, int flags)\n \tcase GF_OMP_FOR_KIND_DISTRIBUTE:\n \t  pp_string (buffer, \"#pragma omp distribute\");\n \t  break;\n+\tcase GF_OMP_FOR_KIND_CILKFOR:\n+\t  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n-      dump_omp_clauses (buffer, gimple_omp_for_clauses (gs), spc, flags);\n+      if (gimple_omp_for_kind (gs) != GF_OMP_FOR_KIND_CILKFOR)\n+\tdump_omp_clauses (buffer, gimple_omp_for_clauses (gs), spc, flags);\n       for (i = 0; i < gimple_omp_for_collapse (gs); i++)\n \t{\n \t  if (i)\n \t    spc += 2;\n-\t  newline_and_indent (buffer, spc);\n-\t  pp_string (buffer, \"for (\");\n+\t  if (gimple_omp_for_kind (gs) == GF_OMP_FOR_KIND_CILKFOR)\n+\t    pp_string (buffer, \"_Cilk_for (\");\n+\t  else\n+\t    {\n+\t      newline_and_indent (buffer, spc);\n+\t      pp_string (buffer, \"for (\");\n+\t    }\n \t  dump_generic_node (buffer, gimple_omp_for_index (gs, i), spc,\n \t\t\t     flags, false);\n \t  pp_string (buffer, \" = \");\n@@ -1203,6 +1214,9 @@ dump_gimple_omp_for (pretty_printer *buffer, gimple gs, int spc, int flags)\n \t    case GE_EXPR:\n \t      pp_greater_equal (buffer);\n \t      break;\n+\t    case NE_EXPR:\n+\t      pp_string (buffer, \"!=\");\n+\t      break;\n \t    default:\n \t      gcc_unreachable ();\n \t    }\n@@ -1221,6 +1235,8 @@ dump_gimple_omp_for (pretty_printer *buffer, gimple gs, int spc, int flags)\n \n       if (!gimple_seq_empty_p (gimple_omp_body (gs)))\n \t{\n+\t  if (gimple_omp_for_kind (gs) == GF_OMP_FOR_KIND_CILKFOR)\n+\t    dump_omp_clauses (buffer, gimple_omp_for_clauses (gs), spc, flags);\n \t  newline_and_indent (buffer, spc + 2);\n \t  pp_left_brace (buffer);\n \t  pp_newline (buffer);"}, {"sha": "ec415850bc35dd1ea1129b3da2b9e6bad6535a39", "filename": "gcc/gimple.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=9a771876d342f9cf0b64c2ceada267ff50e18206", "patch": "@@ -92,15 +92,16 @@ enum gf_mask {\n     GF_CALL_INTERNAL\t\t= 1 << 6,\n     GF_CALL_CTRL_ALTERING       = 1 << 7,\n     GF_OMP_PARALLEL_COMBINED\t= 1 << 0,\n-    GF_OMP_FOR_KIND_MASK\t= (1 << 2) - 1,\n+    GF_OMP_FOR_KIND_MASK\t= 7 << 0,\n     GF_OMP_FOR_KIND_FOR\t\t= 0,\n     GF_OMP_FOR_KIND_DISTRIBUTE\t= 1,\n+    GF_OMP_FOR_KIND_CILKFOR     = 2,\n     /* Flag for SIMD variants of OMP_FOR kinds.  */\n-    GF_OMP_FOR_SIMD\t\t= 1 << 1,\n+    GF_OMP_FOR_SIMD\t\t= 1 << 2,\n     GF_OMP_FOR_KIND_SIMD\t= GF_OMP_FOR_SIMD | 0,\n     GF_OMP_FOR_KIND_CILKSIMD\t= GF_OMP_FOR_SIMD | 1,\n-    GF_OMP_FOR_COMBINED\t\t= 1 << 2,\n-    GF_OMP_FOR_COMBINED_INTO\t= 1 << 3,\n+    GF_OMP_FOR_COMBINED\t\t= 1 << 3,\n+    GF_OMP_FOR_COMBINED_INTO\t= 1 << 4,\n     GF_OMP_TARGET_KIND_MASK\t= (1 << 2) - 1,\n     GF_OMP_TARGET_KIND_REGION\t= 0,\n     GF_OMP_TARGET_KIND_DATA\t= 1,"}, {"sha": "0ebc24c45240f6e84957590aff9c4ebb75ba4259", "filename": "gcc/gimplify.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=9a771876d342f9cf0b64c2ceada267ff50e18206", "patch": "@@ -6208,6 +6208,7 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \tcase OMP_CLAUSE_THREAD_LIMIT:\n \tcase OMP_CLAUSE_DIST_SCHEDULE:\n \tcase OMP_CLAUSE_DEVICE:\n+\tcase OMP_CLAUSE__CILK_FOR_COUNT_:\n \t  if (gimplify_expr (&OMP_CLAUSE_OPERAND (c, 0), pre_p, NULL,\n \t\t\t     is_gimple_val, fb_rvalue) == GS_ERROR)\n \t    remove = true;\n@@ -6584,6 +6585,7 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, tree *list_p)\n \tcase OMP_CLAUSE_PROC_BIND:\n \tcase OMP_CLAUSE_SAFELEN:\n \tcase OMP_CLAUSE_DEPEND:\n+\tcase OMP_CLAUSE__CILK_FOR_COUNT_:\n \t  break;\n \n \tdefault:\n@@ -7056,6 +7058,7 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n     case OMP_FOR: kind = GF_OMP_FOR_KIND_FOR; break;\n     case OMP_SIMD: kind = GF_OMP_FOR_KIND_SIMD; break;\n     case CILK_SIMD: kind = GF_OMP_FOR_KIND_CILKSIMD; break;\n+    case CILK_FOR: kind = GF_OMP_FOR_KIND_CILKFOR; break;\n     case OMP_DISTRIBUTE: kind = GF_OMP_FOR_KIND_DISTRIBUTE; break;\n     default:\n       gcc_unreachable ();\n@@ -8128,6 +8131,7 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \tcase OMP_FOR:\n \tcase OMP_SIMD:\n \tcase CILK_SIMD:\n+\tcase CILK_FOR:\n \tcase OMP_DISTRIBUTE:\n \t  ret = gimplify_omp_for (expr_p, pre_p);\n \t  break;"}, {"sha": "22a8fcab57fa390efd9be9d56e398e8b9b9fbebc", "filename": "gcc/omp-low.c", "status": "modified", "additions": 325, "deletions": 12, "changes": 337, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=9a771876d342f9cf0b64c2ceada267ff50e18206", "patch": "@@ -70,6 +70,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-prop.h\"\n #include \"tree-nested.h\"\n #include \"tree-eh.h\"\n+#include \"cilk.h\"\n \n \n /* Lowering of OpenMP parallel and workshare constructs proceeds in two\n@@ -313,6 +314,8 @@ extract_omp_for_data (gimple for_stmt, struct omp_for_data *fd,\n   fd->have_ordered = false;\n   fd->sched_kind = OMP_CLAUSE_SCHEDULE_STATIC;\n   fd->chunk_size = NULL_TREE;\n+  if (gimple_omp_for_kind (fd->for_stmt) == GF_OMP_FOR_KIND_CILKFOR)\n+    fd->sched_kind = OMP_CLAUSE_SCHEDULE_CILKFOR;\n   collapse_iter = NULL;\n   collapse_count = NULL;\n \n@@ -392,7 +395,9 @@ extract_omp_for_data (gimple for_stmt, struct omp_for_data *fd,\n \t  break;\n \tcase NE_EXPR:\n \t  gcc_assert (gimple_omp_for_kind (for_stmt)\n-\t\t      == GF_OMP_FOR_KIND_CILKSIMD);\n+\t\t      == GF_OMP_FOR_KIND_CILKSIMD\n+\t\t      || (gimple_omp_for_kind (for_stmt)\n+\t\t\t  == GF_OMP_FOR_KIND_CILKFOR));\n \t  break;\n \tcase LE_EXPR:\n \t  if (POINTER_TYPE_P (TREE_TYPE (loop->n2)))\n@@ -1604,6 +1609,7 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \tcase OMP_CLAUSE_SCHEDULE:\n \tcase OMP_CLAUSE_DIST_SCHEDULE:\n \tcase OMP_CLAUSE_DEPEND:\n+\tcase OMP_CLAUSE__CILK_FOR_COUNT_:\n \t  if (ctx->outer)\n \t    scan_omp_op (&OMP_CLAUSE_OPERAND (c, 0), ctx->outer);\n \t  break;\n@@ -1812,6 +1818,7 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \tcase OMP_CLAUSE__LOOPTEMP_:\n \tcase OMP_CLAUSE_TO:\n \tcase OMP_CLAUSE_FROM:\n+\tcase OMP_CLAUSE__CILK_FOR_COUNT_:\n \t  break;\n \n \tdefault:\n@@ -1835,13 +1842,39 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \tscan_omp (&OMP_CLAUSE_LINEAR_GIMPLE_SEQ (c), ctx);\n }\n \n-/* Create a new name for omp child function.  Returns an identifier.  */\n+/* Create a new name for omp child function.  Returns an identifier.  If\n+   IS_CILK_FOR is true then the suffix for the child function is\n+   \"_cilk_for_fn.\"  */\n \n static tree\n-create_omp_child_function_name (bool task_copy)\n+create_omp_child_function_name (bool task_copy, bool is_cilk_for)\n {\n-  return (clone_function_name (current_function_decl,\n-\t\t\t       task_copy ? \"_omp_cpyfn\" : \"_omp_fn\"));\n+  if (is_cilk_for)\n+    return clone_function_name (current_function_decl, \"_cilk_for_fn\");\n+  return clone_function_name (current_function_decl,\n+\t\t\t      task_copy ? \"_omp_cpyfn\" : \"_omp_fn\");\n+}\n+\n+/* Returns the type of the induction variable for the child function for\n+   _Cilk_for and the types for _high and _low variables based on TYPE.  */\n+\n+static tree\n+cilk_for_check_loop_diff_type (tree type)\n+{\n+  if (TYPE_PRECISION (type) <= TYPE_PRECISION (uint32_type_node))\n+    {\n+      if (TYPE_UNSIGNED (type))\n+\treturn uint32_type_node;\n+      else\n+\treturn integer_type_node;\n+    }\n+  else\n+    {\n+      if (TYPE_UNSIGNED (type))\n+\treturn uint64_type_node;\n+      else\n+\treturn long_long_integer_type_node;\n+    }\n }\n \n /* Build a decl for the omp child function.  It'll not contain a body\n@@ -1852,15 +1885,28 @@ create_omp_child_function (omp_context *ctx, bool task_copy)\n {\n   tree decl, type, name, t;\n \n-  name = create_omp_child_function_name (task_copy);\n+  tree cilk_for_count\n+    = (flag_cilkplus && gimple_code (ctx->stmt) == GIMPLE_OMP_PARALLEL)\n+      ? find_omp_clause (gimple_omp_parallel_clauses (ctx->stmt),\n+\t\t\t OMP_CLAUSE__CILK_FOR_COUNT_) : NULL_TREE;\n+  tree cilk_var_type = NULL_TREE;\n+\n+  name = create_omp_child_function_name (task_copy,\n+\t\t\t\t\t cilk_for_count != NULL_TREE);\n   if (task_copy)\n     type = build_function_type_list (void_type_node, ptr_type_node,\n \t\t\t\t     ptr_type_node, NULL_TREE);\n+  else if (cilk_for_count)\n+    {\n+      type = TREE_TYPE (OMP_CLAUSE_OPERAND (cilk_for_count, 0));\n+      cilk_var_type = cilk_for_check_loop_diff_type (type);\n+      type = build_function_type_list (void_type_node, ptr_type_node,\n+\t\t\t\t       cilk_var_type, cilk_var_type, NULL_TREE);\n+    }\n   else\n     type = build_function_type_list (void_type_node, ptr_type_node, NULL_TREE);\n \n-  decl = build_decl (gimple_location (ctx->stmt),\n-\t\t     FUNCTION_DECL, name, type);\n+  decl = build_decl (gimple_location (ctx->stmt), FUNCTION_DECL, name, type);\n \n   if (!task_copy)\n     ctx->cb.dst_fn = decl;\n@@ -1904,13 +1950,42 @@ create_omp_child_function (omp_context *ctx, bool task_copy)\n   DECL_CONTEXT (t) = decl;\n   DECL_RESULT (decl) = t;\n \n-  t = build_decl (DECL_SOURCE_LOCATION (decl),\n-\t\t  PARM_DECL, get_identifier (\".omp_data_i\"), ptr_type_node);\n+  /* _Cilk_for's child function requires two extra parameters called\n+     __low and __high that are set the by Cilk runtime when it calls this\n+     function.  */\n+  if (cilk_for_count)\n+    {\n+      t = build_decl (DECL_SOURCE_LOCATION (decl),\n+\t\t      PARM_DECL, get_identifier (\"__high\"), cilk_var_type);\n+      DECL_ARTIFICIAL (t) = 1;\n+      DECL_NAMELESS (t) = 1;\n+      DECL_ARG_TYPE (t) = ptr_type_node;\n+      DECL_CONTEXT (t) = current_function_decl;\n+      TREE_USED (t) = 1;\n+      DECL_CHAIN (t) = DECL_ARGUMENTS (decl);\n+      DECL_ARGUMENTS (decl) = t;\n+\n+      t = build_decl (DECL_SOURCE_LOCATION (decl),\n+\t\t      PARM_DECL, get_identifier (\"__low\"), cilk_var_type);\n+      DECL_ARTIFICIAL (t) = 1;\n+      DECL_NAMELESS (t) = 1;\n+      DECL_ARG_TYPE (t) = ptr_type_node;\n+      DECL_CONTEXT (t) = current_function_decl;\n+      TREE_USED (t) = 1;\n+      DECL_CHAIN (t) = DECL_ARGUMENTS (decl);\n+      DECL_ARGUMENTS (decl) = t;\n+    }\n+\n+  tree data_name = get_identifier (\".omp_data_i\");\n+  t = build_decl (DECL_SOURCE_LOCATION (decl), PARM_DECL, data_name,\n+\t\t  ptr_type_node);\n   DECL_ARTIFICIAL (t) = 1;\n   DECL_NAMELESS (t) = 1;\n   DECL_ARG_TYPE (t) = ptr_type_node;\n   DECL_CONTEXT (t) = current_function_decl;\n   TREE_USED (t) = 1;\n+  if (cilk_for_count)\n+    DECL_CHAIN (t) = DECL_ARGUMENTS (decl);\n   DECL_ARGUMENTS (decl) = t;\n   if (!task_copy)\n     ctx->receiver_decl = t;\n@@ -4382,6 +4457,44 @@ expand_parallel_call (struct omp_region *region, basic_block bb,\n \t\t\t    false, GSI_CONTINUE_LINKING);\n }\n \n+/* Insert a function call whose name is FUNC_NAME with the information from\n+   ENTRY_STMT into the basic_block BB.  */\n+\n+static void\n+expand_cilk_for_call (basic_block bb, gimple entry_stmt,\n+\t\t      vec <tree, va_gc> *ws_args)\n+{\n+  tree t, t1, t2;\n+  gimple_stmt_iterator gsi;\n+  vec <tree, va_gc> *args;\n+\n+  gcc_assert (vec_safe_length (ws_args) == 2);\n+  tree func_name = (*ws_args)[0];\n+  tree grain = (*ws_args)[1];\n+\n+  tree clauses = gimple_omp_parallel_clauses (entry_stmt);\n+  tree count = find_omp_clause (clauses, OMP_CLAUSE__CILK_FOR_COUNT_);\n+  gcc_assert (count != NULL_TREE);\n+  count = OMP_CLAUSE_OPERAND (count, 0);\n+\n+  gsi = gsi_last_bb (bb);\n+  t = gimple_omp_parallel_data_arg (entry_stmt);\n+  if (t == NULL)\n+    t1 = null_pointer_node;\n+  else\n+    t1 = build_fold_addr_expr (t);\n+  t2 = build_fold_addr_expr (gimple_omp_parallel_child_fn (entry_stmt));\n+\n+  vec_alloc (args, 4);\n+  args->quick_push (t2);\n+  args->quick_push (t1);\n+  args->quick_push (count);\n+  args->quick_push (grain);\n+  t = build_call_expr_loc_vec (UNKNOWN_LOCATION, func_name, args);\n+\n+  force_gimple_operand_gsi (&gsi, t, true, NULL_TREE, false,\n+\t\t\t    GSI_CONTINUE_LINKING);\n+}\n \n /* Build the function call to GOMP_task to actually\n    generate the task operation.  BB is the block where to insert the code.  */\n@@ -4717,7 +4830,18 @@ expand_omp_taskreg (struct omp_region *region)\n   entry_bb = region->entry;\n   exit_bb = region->exit;\n \n-  if (is_combined_parallel (region))\n+  bool is_cilk_for\n+    = (flag_cilkplus\n+       && gimple_code (entry_stmt) == GIMPLE_OMP_PARALLEL\n+       && find_omp_clause (gimple_omp_parallel_clauses (entry_stmt),\n+\t\t\t   OMP_CLAUSE__CILK_FOR_COUNT_) != NULL_TREE);\n+\n+  if (is_cilk_for)\n+    /* If it is a _Cilk_for statement, it is modelled *like* a parallel for,\n+       and the inner statement contains the name of the built-in function\n+       and grain.  */\n+    ws_args = region->inner->ws_args;\n+  else if (is_combined_parallel (region))\n     ws_args = region->ws_args;\n   else\n     ws_args = NULL;\n@@ -4929,7 +5053,9 @@ expand_omp_taskreg (struct omp_region *region)\n     }\n \n   /* Emit a library call to launch the children threads.  */\n-  if (gimple_code (entry_stmt) == GIMPLE_OMP_PARALLEL)\n+  if (is_cilk_for)\n+    expand_cilk_for_call (new_bb, entry_stmt, ws_args);\n+  else if (gimple_code (entry_stmt) == GIMPLE_OMP_PARALLEL)\n     expand_parallel_call (region, new_bb, entry_stmt, ws_args);\n   else\n     expand_task_call (new_bb, entry_stmt);\n@@ -6621,6 +6747,191 @@ expand_omp_for_static_chunk (struct omp_region *region,\n     }\n }\n \n+/* A subroutine of expand_omp_for.  Generate code for _Cilk_for loop.\n+   Given parameters:\n+   for (V = N1; V cond N2; V += STEP) BODY;\n+\n+   where COND is \"<\" or \">\" or \"!=\", we generate pseudocode\n+\n+   for (ind_var = low; ind_var < high; ind_var++)\n+     {\n+       V = n1 + (ind_var * STEP)\n+\n+       <BODY>\n+     }\n+\n+   In the above pseudocode, low and high are function parameters of the\n+   child function.  In the function below, we are inserting a temp.\n+   variable that will be making a call to two OMP functions that will not be\n+   found in the body of _Cilk_for (since OMP_FOR cannot be mixed\n+   with _Cilk_for).  These functions are replaced with low and high\n+   by the function that handles taskreg.  */\n+\n+\n+static void\n+expand_cilk_for (struct omp_region *region, struct omp_for_data *fd)\n+{\n+  bool broken_loop = region->cont == NULL;\n+  basic_block entry_bb = region->entry;\n+  basic_block cont_bb = region->cont;\n+\n+  gcc_assert (EDGE_COUNT (entry_bb->succs) == 2);\n+  gcc_assert (broken_loop\n+\t      || BRANCH_EDGE (entry_bb)->dest == FALLTHRU_EDGE (cont_bb)->dest);\n+  basic_block l0_bb = FALLTHRU_EDGE (entry_bb)->dest;\n+  basic_block l1_bb, l2_bb;\n+\n+  if (!broken_loop)\n+    {\n+      gcc_assert (BRANCH_EDGE (cont_bb)->dest == l0_bb);\n+      gcc_assert (EDGE_COUNT (cont_bb->succs) == 2);\n+      l1_bb = split_block (cont_bb, last_stmt (cont_bb))->dest;\n+      l2_bb = BRANCH_EDGE (entry_bb)->dest;\n+    }\n+  else\n+    {\n+      BRANCH_EDGE (entry_bb)->flags &= ~EDGE_ABNORMAL;\n+      l1_bb = split_edge (BRANCH_EDGE (entry_bb));\n+      l2_bb = single_succ (l1_bb);\n+    }\n+  basic_block exit_bb = region->exit;\n+  basic_block l2_dom_bb = NULL;\n+\n+  gimple_stmt_iterator gsi = gsi_last_bb (entry_bb);\n+\n+  /* Below statements until the \"tree high_val = ...\" are pseudo statements\n+     used to pass information to be used by expand_omp_taskreg.\n+     low_val and high_val will be replaced by the __low and __high\n+     parameter from the child function.\n+\n+     The call_exprs part is a place-holder, it is mainly used\n+     to distinctly identify to the top-level part that this is\n+     where we should put low and high (reasoning given in header\n+     comment).  */\n+\n+  tree child_fndecl\n+    = gimple_omp_parallel_child_fn (last_stmt (region->outer->entry));\n+  tree t, low_val = NULL_TREE, high_val = NULL_TREE;\n+  for (t = DECL_ARGUMENTS (child_fndecl); t; t = TREE_CHAIN (t))\n+    {\n+      if (!strcmp (IDENTIFIER_POINTER (DECL_NAME (t)), \"__high\"))\n+\thigh_val = t;\n+      else if (!strcmp (IDENTIFIER_POINTER (DECL_NAME (t)), \"__low\"))\n+\tlow_val = t;\n+    }\n+  gcc_assert (low_val && high_val);\n+\n+  tree type = TREE_TYPE (low_val);\n+  tree ind_var = create_tmp_reg (type, \"__cilk_ind_var\");\n+  gcc_assert (gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_FOR);\n+\n+  /* Not needed in SSA form right now.  */\n+  gcc_assert (!gimple_in_ssa_p (cfun));\n+  if (l2_dom_bb == NULL)\n+    l2_dom_bb = l1_bb;\n+\n+  tree n1 = low_val;\n+  tree n2 = high_val;\n+\n+  gimple stmt = gimple_build_assign (ind_var, n1);\n+\n+  /* Replace the GIMPLE_OMP_FOR statement.  */\n+  gsi_replace (&gsi, stmt, true);\n+\n+  if (!broken_loop)\n+    {\n+      /* Code to control the increment goes in the CONT_BB.  */\n+      gsi = gsi_last_bb (cont_bb);\n+      stmt = gsi_stmt (gsi);\n+      gcc_assert (gimple_code (stmt) == GIMPLE_OMP_CONTINUE);\n+      stmt = gimple_build_assign_with_ops (PLUS_EXPR, ind_var, ind_var,\n+\t\t\t\t\t   build_one_cst (type));\n+\n+      /* Replace GIMPLE_OMP_CONTINUE.  */\n+      gsi_replace (&gsi, stmt, true);\n+    }\n+\n+  /* Emit the condition in L1_BB.  */\n+  gsi = gsi_after_labels (l1_bb);\n+  t = fold_build2 (MULT_EXPR, TREE_TYPE (fd->loop.step),\n+\t\t   fold_convert (TREE_TYPE (fd->loop.step), ind_var),\n+\t\t   fd->loop.step);\n+  if (POINTER_TYPE_P (TREE_TYPE (fd->loop.n1)))\n+    t = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (fd->loop.n1),\n+\t\t     fd->loop.n1, fold_convert (sizetype, t));\n+  else\n+    t = fold_build2 (PLUS_EXPR, TREE_TYPE (fd->loop.n1),\n+\t\t     fd->loop.n1, fold_convert (TREE_TYPE (fd->loop.n1), t));\n+  t = fold_convert (TREE_TYPE (fd->loop.v), t);\n+  expand_omp_build_assign (&gsi, fd->loop.v, t);\n+\n+  /* The condition is always '<' since the runtime will fill in the low\n+     and high values.  */\n+  stmt = gimple_build_cond (LT_EXPR, ind_var, n2, NULL_TREE, NULL_TREE);\n+  gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n+\n+  /* Remove GIMPLE_OMP_RETURN.  */\n+  gsi = gsi_last_bb (exit_bb);\n+  gsi_remove (&gsi, true);\n+\n+  /* Connect the new blocks.  */\n+  remove_edge (FALLTHRU_EDGE (entry_bb));\n+\n+  edge e, ne;\n+  if (!broken_loop)\n+    {\n+      remove_edge (BRANCH_EDGE (entry_bb));\n+      make_edge (entry_bb, l1_bb, EDGE_FALLTHRU);\n+\n+      e = BRANCH_EDGE (l1_bb);\n+      ne = FALLTHRU_EDGE (l1_bb);\n+      e->flags = EDGE_TRUE_VALUE;\n+    }\n+  else\n+    {\n+      single_succ_edge (entry_bb)->flags = EDGE_FALLTHRU;\n+\n+      ne = single_succ_edge (l1_bb);\n+      e = make_edge (l1_bb, l0_bb, EDGE_TRUE_VALUE);\n+\n+    }\n+  ne->flags = EDGE_FALSE_VALUE;\n+  e->probability = REG_BR_PROB_BASE * 7 / 8;\n+  ne->probability = REG_BR_PROB_BASE / 8;\n+\n+  set_immediate_dominator (CDI_DOMINATORS, l1_bb, entry_bb);\n+  set_immediate_dominator (CDI_DOMINATORS, l2_bb, l2_dom_bb);\n+  set_immediate_dominator (CDI_DOMINATORS, l0_bb, l1_bb);\n+\n+  if (!broken_loop)\n+    {\n+      struct loop *loop = alloc_loop ();\n+      loop->header = l1_bb;\n+      loop->latch = cont_bb;\n+      add_loop (loop, l1_bb->loop_father);\n+      loop->safelen = INT_MAX;\n+    }\n+\n+  /* Pick the correct library function based on the precision of the\n+     induction variable type.  */\n+  tree lib_fun = NULL_TREE;\n+  if (TYPE_PRECISION (type) == 32)\n+    lib_fun = cilk_for_32_fndecl;\n+  else if (TYPE_PRECISION (type) == 64)\n+    lib_fun = cilk_for_64_fndecl;\n+  else\n+    gcc_unreachable ();\n+\n+  gcc_assert (fd->sched_kind == OMP_CLAUSE_SCHEDULE_CILKFOR);\n+\n+  /* WS_ARGS contains the library function flavor to call:\n+     __libcilkrts_cilk_for_64 or __libcilkrts_cilk_for_32), and the\n+     user-defined grain value.  If the user does not define one, then zero\n+     is passed in by the parser.  */\n+  vec_alloc (region->ws_args, 2);\n+  region->ws_args->quick_push (lib_fun);\n+  region->ws_args->quick_push (fd->chunk_size);\n+}\n \n /* A subroutine of expand_omp_for.  Generate code for a simd non-worksharing\n    loop.  Given parameters:\n@@ -6964,6 +7275,8 @@ expand_omp_for (struct omp_region *region, gimple inner_stmt)\n \n   if (gimple_omp_for_kind (fd.for_stmt) & GF_OMP_FOR_SIMD)\n     expand_omp_simd (region, &fd);\n+  else if (gimple_omp_for_kind (fd.for_stmt) == GF_OMP_FOR_KIND_CILKFOR)\n+    expand_cilk_for (region, &fd);\n   else if (fd.sched_kind == OMP_CLAUSE_SCHEDULE_STATIC\n \t   && !fd.have_ordered)\n     {"}, {"sha": "7281fd92da46379a0d2435e1ccfcc5ffe8a6d887", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9a771876d342f9cf0b64c2ceada267ff50e18206", "patch": "@@ -1,3 +1,22 @@\n+2014-09-02  Jakub Jelinek  <jakub@redhat.com>\n+\t    Balaji V. Iyer  <balaji.v.iyer@intel.com>\n+\t    Igor Zamyatin  <igor.zamyatin@intel.com>\n+\n+\t* c-c++-common/cilk-plus/CK/cilk-fors.c: New test.\n+\t* c-c++-common/cilk-plus/CK/cilk-for-2.c: New test.\n+\t* c-c++-common/cilk-plus/CK/cilk-for-3.c: New test.\n+\t* c-c++-common/cilk-plus/CK/cilk_for_errors.c: New test.\n+\t* c-c++-common/cilk-plus/CK/cilk_for_grain.c: New test.\n+\t* c-c++-common/cilk-plus/CK/cilk_for_grain_errors.c: New test.\n+\t* c-c++-common/cilk-plus/CK/cilk_for_ptr_iter.c: New test.\n+\t* c-c++-common/cilk-plus/CK/nested_cilk_for.c: New test.\n+\t* g++.dg/cilk-plus/CK/cf3.cc: New test.\n+\t* g++.dg/cilk-plus/CK/cilk-for-tplt.cc: New test.\n+\t* g++.dg/cilk-plus/CK/for1.cc: New test.\n+\t* g++.dg/cilk-plus/CK/stl_iter.cc: New test.\n+\t* g++.dg/cilk-plus/CK/stl_rev_iter.cc: New test.\n+\t* g++.dg/cilk-plus/CK/stl_test.cc: New test.\n+\n 2014-09-02  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/62695"}, {"sha": "fd30667f8dccd190052e9e33c738aedd4bb9b624", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/cilk-for-2.c", "status": "added", "additions": 393, "deletions": 0, "changes": 393, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcilk-for-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcilk-for-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcilk-for-2.c?ref=9a771876d342f9cf0b64c2ceada267ff50e18206", "patch": "@@ -0,0 +1,393 @@\n+/* { dg-do run { target { i?86-*-* x86_64-*-* } } } */\n+/* { dg-options \"-fcilkplus\" } */\n+/* { dg-additional-options \"-std=gnu99\" { target c } } */\n+/* { dg-additional-options \"-lcilkrts\" { target { i?86-*-* x86_64-*-* } } } */\n+\n+int msk;\n+\n+#define BODY \\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    int j = (i >= 30U) ? 30 : i;\t\t\t\t\t\\\n+    if (__atomic_fetch_or (&msk, 1 << j, __ATOMIC_RELAXED) & (1 << j))\t\\\n+      __builtin_abort ();\t\t\t\t\t\t\\\n+  } while (0)\n+#define TEST(x) if (msk != (x)) __builtin_abort (); msk = 0\n+\n+__attribute__((noinline, noclone)) void\n+test (int seven, int three, int two, int minustwo, int ten,\n+      int zero, int eleven, int six, int one, int threealt,\n+      unsigned long int sevenUL, unsigned long int threeUL,\n+      unsigned long int twoUL, unsigned long int minustwoUL,\n+      unsigned long int tenUL, unsigned long int zeroUL,\n+      unsigned long int elevenUL, unsigned long int sixUL,\n+      unsigned long int oneUL, unsigned long int threealtUL)\n+{\n+  _Cilk_for (int i = seven; i < three; ++i)\n+    __builtin_abort ();\n+  _Cilk_for (int i = seven; i <= three; ++i)\n+    __builtin_abort ();\n+  _Cilk_for (int i = three; i != threealt; ++i)\n+    __builtin_abort ();\n+  _Cilk_for (int i = seven; i < three; i += two)\n+    __builtin_abort ();\n+  _Cilk_for (int i = seven; i <= three; i += two)\n+    __builtin_abort ();\n+  _Cilk_for (int i = three; i != threealt; i += two)\n+    __builtin_abort ();\n+  _Cilk_for (int i = seven; i < three; i -= minustwo)\n+    __builtin_abort ();\n+  _Cilk_for (int i = seven; i <= three; i -= minustwo)\n+    __builtin_abort ();\n+  _Cilk_for (int i = three; i != threealt; i -= minustwo)\n+    __builtin_abort ();\n+  _Cilk_for (int i = three; i > seven; --i)\n+    __builtin_abort ();\n+  _Cilk_for (int i = three; i >= seven; i--)\n+    __builtin_abort ();\n+  _Cilk_for (int i = three; i != threealt; i--)\n+    __builtin_abort ();\n+  _Cilk_for (int i = three; i > seven; i -= two)\n+    __builtin_abort ();\n+  _Cilk_for (int i = three; i >= seven; i -= two)\n+    __builtin_abort ();\n+  _Cilk_for (int i = three; i != threealt; i -= two)\n+    __builtin_abort ();\n+  _Cilk_for (int i = three; i > seven; i += minustwo)\n+    __builtin_abort ();\n+  _Cilk_for (int i = three; i >= seven; i += minustwo)\n+    __builtin_abort ();\n+  _Cilk_for (int i = three; i != threealt; i += minustwo)\n+    __builtin_abort ();\n+  _Cilk_for (int i = three; i < seven; ++i)\n+    BODY;\n+  TEST (0x78);\n+  _Cilk_for (int i = three; i <= seven; i++)\n+    BODY;\n+  TEST (0xf8);\n+  _Cilk_for (int i = three; i != seven; i++)\n+    BODY;\n+  TEST (0x78);\n+  _Cilk_for (int i = zero; i < ten; i += two)\n+    BODY;\n+  TEST (0x155);\n+  _Cilk_for (int i = zero; i <= ten; i += two)\n+    BODY;\n+  TEST (0x555);\n+  _Cilk_for (int i = zero; i != ten; i += two)\n+    BODY;\n+  TEST (0x155);\n+  _Cilk_for (int i = zero; i < ten; i -= minustwo)\n+    BODY;\n+  TEST (0x155);\n+  _Cilk_for (int i = zero; i <= ten; i -= minustwo)\n+    BODY;\n+  TEST (0x555);\n+  _Cilk_for (int i = zero; i != ten; i -= minustwo)\n+    BODY;\n+  TEST (0x155);\n+  _Cilk_for (int i = six; i > two; --i)\n+    BODY;\n+  TEST (0x78);\n+  _Cilk_for (int i = seven; i >= three; i--)\n+    BODY;\n+  TEST (0xf8);\n+  _Cilk_for (int i = seven; i != three; i--)\n+    BODY;\n+  TEST (0xf0);\n+  _Cilk_for (int i = eleven; i > one; i += minustwo)\n+    BODY;\n+  TEST (0xaa8);\n+  _Cilk_for (int i = eleven; i >= two; i += minustwo)\n+    BODY;\n+  TEST (0xaa8);\n+  _Cilk_for (int i = eleven; i != one; i += minustwo)\n+    BODY;\n+  TEST (0xaa8);\n+  _Cilk_for (int i = eleven; i > one; i -= two)\n+    BODY;\n+  TEST (0xaa8);\n+  _Cilk_for (int i = eleven; i >= two; i -= two)\n+    BODY;\n+  TEST (0xaa8);\n+  _Cilk_for (int i = eleven; i != one; i -= two)\n+    BODY;\n+  TEST (0xaa8);\n+  _Cilk_for (unsigned long int i = sevenUL; i < threeUL; ++i)\n+    __builtin_abort ();\n+  _Cilk_for (unsigned long int i = sevenUL; i <= threeUL; ++i)\n+    __builtin_abort ();\n+  _Cilk_for (unsigned long int i = threeUL; i != threealtUL; ++i)\n+    __builtin_abort ();\n+  _Cilk_for (unsigned long int i = sevenUL; i < threeUL; i += twoUL)\n+    __builtin_abort ();\n+  _Cilk_for (unsigned long int i = sevenUL; i <= threeUL; i += twoUL)\n+    __builtin_abort ();\n+  _Cilk_for (unsigned long int i = threeUL; i != threealtUL; i += twoUL)\n+    __builtin_abort ();\n+  _Cilk_for (unsigned long int i = sevenUL; i < threeUL; i -= minustwoUL)\n+    __builtin_abort ();\n+  _Cilk_for (unsigned long int i = sevenUL; i <= threeUL; i -= minustwoUL)\n+    __builtin_abort ();\n+  _Cilk_for (unsigned long int i = threeUL; i != threealtUL; i -= minustwoUL)\n+    __builtin_abort ();\n+  _Cilk_for (unsigned long int i = threeUL; i > sevenUL; --i)\n+    __builtin_abort ();\n+  _Cilk_for (unsigned long int i = threeUL; i >= sevenUL; i--)\n+    __builtin_abort ();\n+  _Cilk_for (unsigned long int i = threeUL; i != threealtUL; i--)\n+    __builtin_abort ();\n+  _Cilk_for (unsigned long int i = threeUL; i > sevenUL; i -= twoUL)\n+    __builtin_abort ();\n+  _Cilk_for (unsigned long int i = threeUL; i >= sevenUL; i -= twoUL)\n+    __builtin_abort ();\n+  _Cilk_for (unsigned long int i = threeUL; i != threealtUL; i -= twoUL)\n+    __builtin_abort ();\n+  _Cilk_for (unsigned long int i = threeUL; i > sevenUL; i += minustwoUL)\n+    __builtin_abort ();\n+  _Cilk_for (unsigned long int i = threeUL; i >= sevenUL; i += minustwoUL)\n+    __builtin_abort ();\n+  _Cilk_for (unsigned long int i = threeUL; i != threealtUL; i += minustwoUL)\n+    __builtin_abort ();\n+  _Cilk_for (unsigned long int i = threeUL; i < sevenUL; ++i)\n+    BODY;\n+  TEST (0x78);\n+  _Cilk_for (unsigned long int i = threeUL; i <= sevenUL; i++)\n+    BODY;\n+  TEST (0xf8);\n+  _Cilk_for (unsigned long int i = threeUL; i != sevenUL; i++)\n+    BODY;\n+  TEST (0x78);\n+  _Cilk_for (unsigned long int i = zeroUL; i < tenUL; i += twoUL)\n+    BODY;\n+  TEST (0x155);\n+  _Cilk_for (unsigned long int i = zeroUL; i <= tenUL; i += twoUL)\n+    BODY;\n+  TEST (0x555);\n+  _Cilk_for (unsigned long int i = zeroUL; i != tenUL; i += twoUL)\n+    BODY;\n+  TEST (0x155);\n+  _Cilk_for (unsigned long int i = zeroUL; i < tenUL; i -= minustwoUL)\n+    BODY;\n+  TEST (0x155);\n+  _Cilk_for (unsigned long int i = zeroUL; i <= tenUL; i -= minustwoUL)\n+    BODY;\n+  TEST (0x555);\n+  _Cilk_for (unsigned long int i = zeroUL; i != tenUL; i -= minustwoUL)\n+    BODY;\n+  TEST (0x155);\n+  _Cilk_for (unsigned long int i = sixUL; i > twoUL; --i)\n+    BODY;\n+  TEST (0x78);\n+  _Cilk_for (unsigned long int i = sevenUL; i >= threeUL; i--)\n+    BODY;\n+  TEST (0xf8);\n+  _Cilk_for (unsigned long int i = sevenUL; i != threeUL; i--)\n+    BODY;\n+  TEST (0xf0);\n+  _Cilk_for (unsigned long int i = elevenUL; i > oneUL; i += minustwoUL)\n+    BODY;\n+  TEST (0xaa8);\n+  _Cilk_for (unsigned long int i = elevenUL; i >= twoUL; i += minustwoUL)\n+    BODY;\n+  TEST (0xaa8);\n+  _Cilk_for (unsigned long int i = elevenUL; i != oneUL; i += minustwoUL)\n+    BODY;\n+  TEST (0xaa8);\n+  _Cilk_for (unsigned long int i = elevenUL; i > oneUL; i -= twoUL)\n+    BODY;\n+  TEST (0xaa8);\n+  _Cilk_for (unsigned long int i = elevenUL; i >= twoUL; i -= twoUL)\n+    BODY;\n+  TEST (0xaa8);\n+  _Cilk_for (unsigned long int i = elevenUL; i != oneUL; i -= twoUL)\n+    BODY;\n+  TEST (0xaa8);\n+}\n+\n+int\n+main ()\n+{\n+  _Cilk_for (int i = 7; i < 3; ++i)\n+    __builtin_abort ();\n+  _Cilk_for (int i = 7; i <= 3; ++i)\n+    __builtin_abort ();\n+  _Cilk_for (int i = 3; i != 3; ++i)\n+    __builtin_abort ();\n+  _Cilk_for (int i = 7; i < 3; i += 2)\n+    __builtin_abort ();\n+  _Cilk_for (int i = 7; i <= 3; i += 2)\n+    __builtin_abort ();\n+  _Cilk_for (int i = 3; i != 3; i += 2)\n+    __builtin_abort ();\n+  _Cilk_for (int i = 7; i < 3; i -= -2)\n+    __builtin_abort ();\n+  _Cilk_for (int i = 7; i <= 3; i -= -2)\n+    __builtin_abort ();\n+  _Cilk_for (int i = 3; i != 3; i -= -2)\n+    __builtin_abort ();\n+  _Cilk_for (int i = 3; i > 7; --i)\n+    __builtin_abort ();\n+  _Cilk_for (int i = 3; i >= 7; i--)\n+    __builtin_abort ();\n+  _Cilk_for (int i = 3; i != 3; i--)\n+    __builtin_abort ();\n+  _Cilk_for (int i = 3; i > 7; i -= 2)\n+    __builtin_abort ();\n+  _Cilk_for (int i = 3; i >= 7; i -= 2)\n+    __builtin_abort ();\n+  _Cilk_for (int i = 3; i != 3; i -= 2)\n+    __builtin_abort ();\n+  _Cilk_for (int i = 3; i > 7; i += -2)\n+    __builtin_abort ();\n+  _Cilk_for (int i = 3; i >= 7; i += -2)\n+    __builtin_abort ();\n+  _Cilk_for (int i = 3; i != 3; i += -2)\n+    __builtin_abort ();\n+  _Cilk_for (int i = 3; i < 7; ++i)\n+    BODY;\n+  TEST (0x78);\n+  _Cilk_for (int i = 3; i <= 7; i++)\n+    BODY;\n+  TEST (0xf8);\n+  _Cilk_for (int i = 3; i != 7; i++)\n+    BODY;\n+  TEST (0x78);\n+  _Cilk_for (int i = 0; i < 10; i += 2)\n+    BODY;\n+  TEST (0x155);\n+  _Cilk_for (int i = 0; i <= 10; i += 2)\n+    BODY;\n+  TEST (0x555);\n+  _Cilk_for (int i = 0; i != 10; i += 2)\n+    BODY;\n+  TEST (0x155);\n+  _Cilk_for (int i = 0; i < 10; i -= -2)\n+    BODY;\n+  TEST (0x155);\n+  _Cilk_for (int i = 0; i <= 10; i -= -2)\n+    BODY;\n+  TEST (0x555);\n+  _Cilk_for (int i = 0; i != 10; i -= -2)\n+    BODY;\n+  TEST (0x155);\n+  _Cilk_for (int i = 6; i > 2; --i)\n+    BODY;\n+  TEST (0x78);\n+  _Cilk_for (int i = 7; i >= 3; i--)\n+    BODY;\n+  TEST (0xf8);\n+  _Cilk_for (int i = 7; i != 3; i--)\n+    BODY;\n+  TEST (0xf0);\n+  _Cilk_for (int i = 11; i > 1; i += -2)\n+    BODY;\n+  TEST (0xaa8);\n+  _Cilk_for (int i = 11; i >= 2; i += -2)\n+    BODY;\n+  TEST (0xaa8);\n+  _Cilk_for (int i = 11; i != 1; i += -2)\n+    BODY;\n+  TEST (0xaa8);\n+  _Cilk_for (int i = 11; i > 1; i -= 2)\n+    BODY;\n+  TEST (0xaa8);\n+  _Cilk_for (int i = 11; i >= 2; i -= 2)\n+    BODY;\n+  TEST (0xaa8);\n+  _Cilk_for (int i = 11; i != 1; i -= 2)\n+    BODY;\n+  TEST (0xaa8);\n+  _Cilk_for (unsigned long int i = 7UL; i < 3UL; ++i)\n+    __builtin_abort ();\n+  _Cilk_for (unsigned long int i = 7UL; i <= 3UL; ++i)\n+    __builtin_abort ();\n+  _Cilk_for (unsigned long int i = 3UL; i != 3UL; ++i)\n+    __builtin_abort ();\n+  _Cilk_for (unsigned long int i = 7UL; i < 3UL; i += 2UL)\n+    __builtin_abort ();\n+  _Cilk_for (unsigned long int i = 7UL; i <= 3UL; i += 2UL)\n+    __builtin_abort ();\n+  _Cilk_for (unsigned long int i = 3UL; i != 3UL; i += 2UL)\n+    __builtin_abort ();\n+  _Cilk_for (unsigned long int i = 7UL; i < 3UL; i -= -2UL)\n+    __builtin_abort ();\n+  _Cilk_for (unsigned long int i = 7UL; i <= 3UL; i -= -2UL)\n+    __builtin_abort ();\n+  _Cilk_for (unsigned long int i = 3UL; i != 3UL; i -= -2UL)\n+    __builtin_abort ();\n+  _Cilk_for (unsigned long int i = 3UL; i > 7UL; --i)\n+    __builtin_abort ();\n+  _Cilk_for (unsigned long int i = 3UL; i >= 7UL; i--)\n+    __builtin_abort ();\n+  _Cilk_for (unsigned long int i = 3UL; i != 3UL; i--)\n+    __builtin_abort ();\n+  _Cilk_for (unsigned long int i = 3UL; i > 7UL; i -= 2UL)\n+    __builtin_abort ();\n+  _Cilk_for (unsigned long int i = 3UL; i >= 7UL; i -= 2UL)\n+    __builtin_abort ();\n+  _Cilk_for (unsigned long int i = 3UL; i != 3UL; i -= 2UL)\n+    __builtin_abort ();\n+  _Cilk_for (unsigned long int i = 3UL; i > 7UL; i += -2UL)\n+    __builtin_abort ();\n+  _Cilk_for (unsigned long int i = 3UL; i >= 7UL; i += -2UL)\n+    __builtin_abort ();\n+  _Cilk_for (unsigned long int i = 3UL; i != 3UL; i += -2UL)\n+    __builtin_abort ();\n+  _Cilk_for (unsigned long int i = 3UL; i < 7UL; ++i)\n+    BODY;\n+  TEST (0x78);\n+  _Cilk_for (unsigned long int i = 3UL; i <= 7UL; i++)\n+    BODY;\n+  TEST (0xf8);\n+  _Cilk_for (unsigned long int i = 3UL; i != 7UL; i++)\n+    BODY;\n+  TEST (0x78);\n+  _Cilk_for (unsigned long int i = 0UL; i < 10UL; i += 2UL)\n+    BODY;\n+  TEST (0x155);\n+  _Cilk_for (unsigned long int i = 0UL; i <= 10UL; i += 2UL)\n+    BODY;\n+  TEST (0x555);\n+  _Cilk_for (unsigned long int i = 0UL; i != 10UL; i += 2UL)\n+    BODY;\n+  TEST (0x155);\n+  _Cilk_for (unsigned long int i = 0UL; i < 10UL; i -= -2UL)\n+    BODY;\n+  TEST (0x155);\n+  _Cilk_for (unsigned long int i = 0UL; i <= 10UL; i -= -2UL)\n+    BODY;\n+  TEST (0x555);\n+  _Cilk_for (unsigned long int i = 0UL; i != 10UL; i -= -2UL)\n+    BODY;\n+  TEST (0x155);\n+  _Cilk_for (unsigned long int i = 6UL; i > 2UL; --i)\n+    BODY;\n+  TEST (0x78);\n+  _Cilk_for (unsigned long int i = 7UL; i >= 3UL; i--)\n+    BODY;\n+  TEST (0xf8);\n+  _Cilk_for (unsigned long int i = 7UL; i != 3UL; i--)\n+    BODY;\n+  TEST (0xf0);\n+  _Cilk_for (unsigned long int i = 11UL; i > 1UL; i += -2UL)\n+    BODY;\n+  TEST (0xaa8);\n+  _Cilk_for (unsigned long int i = 11UL; i >= 2UL; i += -2UL)\n+    BODY;\n+  TEST (0xaa8);\n+  _Cilk_for (unsigned long int i = 11UL; i != 1UL; i += -2UL)\n+    BODY;\n+  TEST (0xaa8);\n+  _Cilk_for (unsigned long int i = 11UL; i > 1UL; i -= 2UL)\n+    BODY;\n+  TEST (0xaa8);\n+  _Cilk_for (unsigned long int i = 11UL; i >= 2UL; i -= 2UL)\n+    BODY;\n+  TEST (0xaa8);\n+  _Cilk_for (unsigned long int i = 11UL; i != 1UL; i -= 2UL)\n+    BODY;\n+  TEST (0xaa8);\n+  test (7, 3, 2, -2, 10, 0, 11, 6, 1, 3,\n+\t7UL, 3UL, 2UL, -2UL, 10UL, 0UL, 11UL, 6UL, 1UL, 3UL);\n+  return 0;\n+}"}, {"sha": "04c1635b012b1eb1c009dfa18f08e36c7ebd797a", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/cilk-for-3.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcilk-for-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcilk-for-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcilk-for-3.c?ref=9a771876d342f9cf0b64c2ceada267ff50e18206", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fcilkplus\" } */\n+/* { dg-additional-options \"-std=gnu99\" { target c } } */\n+\n+void bar (int *, int *, int *, int *);\n+void baz (char **, char **, char **, int *);\n+\n+void\n+foo ()\n+{\n+  int a, b, c;\n+  char *d, *e;\n+  bar (0, &a, &b, &c);\n+  _Cilk_for (int i = a; i < b; i += c)\n+    bar (&i, &a, &b, &c);\n+  baz (0, &d, &e, &c);\n+  _Cilk_for (char *p = d; p != e; p += c)\n+    baz (&p, &d, &e, &c);\n+}"}, {"sha": "0a8f046b63760e4c702b1b5575d593b15936c6f1", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/cilk-fors.c", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcilk-fors.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcilk-fors.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcilk-fors.c?ref=9a771876d342f9cf0b64c2ceada267ff50e18206", "patch": "@@ -0,0 +1,87 @@\n+/* { dg-do run { target { i?86-*-* x86_64-*-* } } } */\n+/* { dg-options \"-fcilkplus\" } */\n+/* { dg-additional-options \"-std=gnu99\" { target c } } */\n+/* { dg-additional-options \"-lcilkrts\" { target { i?86-*-* x86_64-*-* } } } */\n+\n+#if HAVE_IO\n+#include <stdio.h>\n+#endif\n+\n+static void check (int *Array, int start, int end, int incr, int value)\n+{\n+  int ii = 0;\n+  for (ii = start;  ii < end; ii = ii + incr)\n+    if (Array[ii] != value)\n+      __builtin_abort ();\n+#if HAVE_IO\n+  printf (\"Passed\\n\");\n+#endif\n+}\n+\n+static void check_reverse (int *Array, int start, int end, int incr, int value)\n+{\n+  int ii = 0;\n+  for (ii = start; ii >= end; ii = ii - incr)\n+    if (Array[ii] != value)\n+      __builtin_abort ();\n+#if HAVE_IO\n+  printf (\"Passed\\n\");\n+#endif\n+}\n+\n+\n+int main (void)\n+{\n+  int Array[10];\n+  int x = 9, y = 0, z = 3;\n+\n+\n+  _Cilk_for (int ii = 0; ii < 10; ii++)\n+    Array[ii] = 1133;\n+  check (Array, 0, 10, 1, 1133);\n+\n+  _Cilk_for (int ii = 0; ii < 10; ++ii)\n+    Array[ii] = 3311;\n+  check (Array, 0, 10, 1, 3311);\n+\n+  _Cilk_for (int ii = 9; ii > -1; ii--)\n+    Array[ii] = 4433;\n+  check_reverse (Array, 9, 0, 1, 4433);\n+\n+  _Cilk_for (int ii = 9; ii > -1; --ii)\n+    Array[ii] = 9988;\n+  check_reverse (Array, 9, 0, 1, 9988);\n+\n+  _Cilk_for (int ii = 0; ii < 10; ++ii)\n+    Array[ii] = 3311;\n+  check (Array, 0, 10, 1, 3311);\n+\n+  _Cilk_for (int ii = 0; ii < 10; ii += 2)\n+    Array[ii] = 1328;\n+  check (Array, 0, 10, 2, 1328);\n+\n+  _Cilk_for (int ii = 9; ii >= 0; ii -= 2)\n+    Array[ii] = 1738;\n+  check_reverse (Array, 9, 0, 2, 1738);\n+\n+\n+  _Cilk_for (int ii = 0; ii < 10; ii++)\n+    {\n+      if (ii % 2)\n+\tArray[ii] = 1343;\n+      else\n+\tArray[ii] = 3413;\n+    }\n+\n+  check (Array, 1, 10, 2, 1343);\n+  check (Array, 0, 10, 2, 3413);\n+\n+  _Cilk_for (short cc = 0; cc < 10; cc++)\n+    Array[cc] = 1343;\n+  check (Array, 0, 10,  1,1343);\n+\n+  _Cilk_for (short cc = 9; cc >= 0; cc--)\n+    Array[cc] = 1348;\n+  check_reverse (Array, 9, 0, 1, 1348);\n+  return 0;\n+}"}, {"sha": "60a9e7dbf36a5119b06f1b5661afc29eb12a8eb5", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/cilk_for_errors.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcilk_for_errors.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcilk_for_errors.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcilk_for_errors.c?ref=9a771876d342f9cf0b64c2ceada267ff50e18206", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fcilkplus\" } */\n+/* { dg-additional-options \"-std=c99\" { target c } } */\n+\n+\n+int main (void)\n+{\n+  int q = 0, ii = 0, jj = 0;\n+\n+  _Cilk_for (int ii; ii < 10; ii++) /* { dg-error \"is not initialized\" \"\" { target c } } */\n+    /* { dg-error \"expected\" \"\" { target c++ } 10 } */\n+    q = 5;\n+\n+  _Cilk_for (; ii < 10; ii++) /* { dg-error \"expected iteration declaration\" } */\n+    q = 2;\n+\n+  _Cilk_for (int ii = 0; ; ii++) /* { dg-error \"missing controlling predicate\" } */\n+    q = 2;\n+\n+  _Cilk_for (int ii = 0; ii < 10, jj < 10; ii++)  /* { dg-error \"expected ';' before ',' token\" \"\" { target c } } */\n+    /* { dg-error \"invalid controlling predicate\" \"\" { target c++ }  20 } */\n+    q = 5;\n+\n+  _Cilk_for (int ii = 0; ii < 10; ) /* { dg-error \"missing increment\" } */\n+    q = 5;\n+\n+  _Cilk_for (int ii = 0, jj = 0; ii < 10; ii++) /* { dg-error \"expected|invalid\" } */\n+    q = 5;\n+\n+  _Cilk_for (volatile int vii = 0; vii < 10; vii++) /* { dg-error \"iteration variable cannot be volatile\" } */\n+    q = 5;\n+\n+  _Cilk_for (static int sii = 0; sii < 10; sii++) /* { dg-error \"static|expected|declared|expression\" } */\n+    q = 5;\n+\n+  _Cilk_for (float fii = 3.47; fii < 5.23; fii++) /* { dg-error \"invalid type for iteration variable\" } */\n+    q = 5;\n+\n+  _Cilk_for (int ii = 0; 10 > jj; ii++) /* { dg-error \"invalid controlling predicate\" } */\n+    q = 5;\n+\n+  _Cilk_for (int ii = 0; ii < 10; ii >> 1) /* { dg-error \"invalid increment expression\" } */\n+    q = 5;\n+\n+  _Cilk_for (int ii = 10; ii >= 0; ii--) /* This is OK!  */\n+    q = 5;\n+\n+  _Cilk_for (int ii; ii < 10; ii++) /* { dg-error \"is not initialized\" \"\" { target c } } */\n+    /* { dg-error \"expected\" \"\" { target c++ } 48 } */\n+    q = 5;\n+\n+  return 0;\n+}"}, {"sha": "ec02613ee912197f47893edac27f57a266e28fcb", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/cilk_for_grain.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcilk_for_grain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcilk_for_grain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcilk_for_grain.c?ref=9a771876d342f9cf0b64c2ceada267ff50e18206", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-do run { target { i?86-*-* x86_64-*-* } } } */\n+/* { dg-options \"-fcilkplus\" } */\n+/* { dg-additional-options \"-std=gnu99\" { target c } } */\n+/* { dg-additional-options \"-lcilkrts\" { target { i?86-*-* x86_64-*-* } } } */\n+\n+\n+int grain_value = 2;\n+int main (void)\n+{\n+  int Array1[200], Array1_Serial[200];\n+\n+  for (int ii = 0; ii < 200; ii++)\n+    {\n+      Array1_Serial[ii] = 2;\n+      Array1[ii] = 1;\n+    }\n+\n+#pragma cilk grainsize = 2\n+  _Cilk_for (int ii = 0; ii < 200; ii++)\n+    Array1[ii] = 2;\n+\n+  for (int ii = 0; ii < 200; ii++)\n+    if (Array1[ii] != Array1_Serial[ii])\n+      return (ii+1);\n+\n+#pragma cilk grainsize = grain_value\n+  _Cilk_for (int ii = 0; ii < 200; ii++)\n+    Array1[ii] = 2;\n+\n+  for (int ii = 0; ii < 200; ii++)\n+    if (Array1[ii] != Array1_Serial[ii])\n+      return (ii+1);\n+\n+  return 0;\n+}"}, {"sha": "214c6be1e9424e6e68bb43b80712d80759bbeb09", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/cilk_for_grain_errors.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcilk_for_grain_errors.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcilk_for_grain_errors.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcilk_for_grain_errors.c?ref=9a771876d342f9cf0b64c2ceada267ff50e18206", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fcilkplus -Wunknown-pragmas\" } */\n+/* { dg-additional-options \"-std=c99\" { target c } } */\n+\n+\n+char Array1[26];\n+\n+#pragma cilk grainsize = 2 /* { dg-error \"must be inside a function\" } */\n+\n+int main(int argc, char **argv)\n+{\n+/* This is OK.  */\n+#pragma cilk grainsize = 2\n+  _Cilk_for (int ii = 0; ii < 10; ii++)\n+    Array1[ii] = 0;\n+\n+#pragma cilk grainsize 2 /* { dg-error \"expected '=' before numeric constant\" } */\n+  _Cilk_for (int ii = 0; ii < 10; ii++)\n+    Array1[ii] = 0;\n+\n+#pragma cilk grainsiz = 2 /* { dg-warning \"ignoring #pragma cilk grainsiz\" } */\n+  _Cilk_for (int ii = 0; ii < 10; ii++)\n+    Array1[ii] = 0;\n+\n+\n+/* This is OK, it will do a type conversion to long int.  */\n+#pragma cilk grainsize = 0.5\n+  _Cilk_for (int ii = 0; ii < 10; ii++)\n+    Array1[ii] = 0;\n+\n+#pragma cilk grainsize = 1\n+  while (Array1[5] != 0) /* { dg-warning \"is not followed by\" } */\n+    {\n+    /* Blah */\n+    }\n+\n+#pragma cilk grainsize = 1\n+  int q = 0; /* { dg-warning \"is not followed by\" } */\n+  _Cilk_for (q = 0; q < 10; q++) /* { dg-error \"allows expression instead of declaration\" \"\" { target c++ } } */\n+    Array1[q] = 5;\n+\n+  while (Array1[5] != 0)\n+    {\n+    /* Blah */\n+    }\n+\n+  return 0;\n+}"}, {"sha": "f4a1f4c1324e16dbeec332e80b09953ce211e188", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/cilk_for_ptr_iter.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcilk_for_ptr_iter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcilk_for_ptr_iter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcilk_for_ptr_iter.c?ref=9a771876d342f9cf0b64c2ceada267ff50e18206", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-do run { target { i?86-*-* x86_64-*-* } } } */\n+/* { dg-options \"-fcilkplus\" } */\n+/* { dg-additional-options \"-std=gnu99\" { target c } } */\n+/* { dg-additional-options \"-lcilkrts\" { target { i?86-*-* x86_64-*-* } } } */\n+\n+\n+\n+/* <feature> loop control variable must have integer, pointer or class type\n+   </feature>\n+*/\n+\n+#define ARRAY_SIZE 10000\n+int a[ARRAY_SIZE];\n+\n+int main(void)\n+{\n+  int ii = 0;\n+\n+  for (ii =0; ii < ARRAY_SIZE; ii++)\n+    a[ii] = 5;\n+  _Cilk_for(int *aa = a; aa < a + ARRAY_SIZE; aa++)\n+    *aa = 0;\n+  for (ii = 0; ii < ARRAY_SIZE; ii++)\n+    if (a[ii] != 0)\n+      __builtin_abort ();\n+\n+  _Cilk_for (int *aa = a; aa < a + ARRAY_SIZE; aa = aa + 2)\n+    *aa = 4;\n+\n+  for (ii = 0; ii < ARRAY_SIZE; ii = ii + 2)\n+    if (a[ii] != 4)\n+      __builtin_abort ();\n+\n+  return 0;\n+}"}, {"sha": "3daaca9ae87de82525c30050fd89b00af42d3892", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/nested_cilk_for.c", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fnested_cilk_for.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fnested_cilk_for.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fnested_cilk_for.c?ref=9a771876d342f9cf0b64c2ceada267ff50e18206", "patch": "@@ -0,0 +1,79 @@\n+/* { dg-do run { target { i?86-*-* x86_64-*-* } } } */\n+/* { dg-options \"-fcilkplus\" } */\n+/* { dg-additional-options \"-std=gnu99\" { target c } } */\n+/* { dg-additional-options \"-lcilkrts\" { target { i?86-*-* x86_64-*-* } } } */\n+\n+#if HAVE_IO\n+#include <stdio.h>\n+#endif\n+\n+int main (void)\n+{\n+  int Array[10][10];\n+\n+\n+  for (int ii = 0; ii < 10; ii++)\n+    for (int jj = 0; jj < 10; jj++)\n+\t{\n+\t  Array[ii][jj] = 0;\n+\t}\n+\n+  _Cilk_for (int ii = 0; ii < 10; ii++)\n+    _Cilk_for (int jj = 0; jj < 5; jj++)\n+      Array[ii][jj] = 5;\n+\n+  for (int ii = 0; ii < 10; ii++)\n+    for (int jj = 0; jj < 5; jj++)\n+      if (Array[ii][jj] != 5)\n+#if HAVE_IO\n+\tprintf(\"Array[%d][%d] = %d\\n\", ii, jj, Array[ii][jj]);\n+#else\n+\t__builtin_abort ();\n+#endif\n+\n+\n+  /* One goes up and one goes down.  */\n+  _Cilk_for (int ii = 0; ii < 10; ii++)\n+    _Cilk_for (int jj = 9; jj >= 0; jj--)\n+      Array[ii][jj] = 7;\n+\n+  for (int ii = 0; ii < 10; ii++)\n+    for (int jj = 9; jj >= 0; jj--)\n+      if (Array[ii][jj] != 7)\n+#if HAVE_IO\n+\tprintf(\"Array[%d][%d] = %d\\n\", ii, jj, Array[ii][jj]);\n+#else\n+\t__builtin_abort ();\n+#endif\n+\n+  /* different step sizes.  */\n+  _Cilk_for (int ii = 0; ii < 10; ii++)\n+    _Cilk_for (int jj = 0; jj < 10; jj += 2)\n+      Array[ii][jj] = 9;\n+\n+  for (int ii = 0; ii < 10; ii++)\n+    for (int jj = 0; jj < 10; jj += 2)\n+      if (Array[ii][jj] != 9)\n+#if HAVE_IO\n+\tprintf(\"Array[%d][%d] = %d\\n\", ii, jj, Array[ii][jj]);\n+#else\n+\t__builtin_abort ();\n+#endif\n+\n+  /* different step sizes.  */\n+  _Cilk_for (int ii = 0; ii < 10; ii += 2)\n+    _Cilk_for (int jj = 5; jj < 9; jj++)\n+      Array[ii][jj] = 11;\n+\n+  for (int ii = 0; ii < 10; ii += 2)\n+    for (int jj = 5; jj < 9; jj++)\n+      if (Array[ii][jj] != 11)\n+#if HAVE_IO\n+\tprintf(\"Array[%d][%d] = %d\\n\", ii, jj, Array[ii][jj]);\n+#else\n+\t__builtin_abort ();\n+#endif\n+\n+  return 0;\n+}\n+"}, {"sha": "8d88c5f346ca254c38d1cdcc68056d7558c1a18e", "filename": "gcc/testsuite/g++.dg/cilk-plus/CK/cf3.cc", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fcf3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fcf3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fcf3.cc?ref=9a771876d342f9cf0b64c2ceada267ff50e18206", "patch": "@@ -0,0 +1,96 @@\n+/* { dg-options \"-fcilkplus\" } */\n+\n+typedef __PTRDIFF_TYPE__ ptrdiff_t;\n+\n+template <typename T>\n+class I\n+{\n+public:\n+  typedef ptrdiff_t difference_type;\n+  I ();\n+  ~I ();\n+  I (T *);\n+  I (const I &);\n+  T &operator * ();\n+  T *operator -> ();\n+  T &operator [] (const difference_type &) const;\n+  I &operator = (const I &);\n+  I &operator ++ ();\n+  I operator ++ (int);\n+  I &operator -- ();\n+  I operator -- (int);\n+  I &operator += (const difference_type &);\n+  I &operator -= (const difference_type &);\n+  I operator + (const difference_type &) const;\n+  I operator - (const difference_type &) const;\n+  template <typename S> friend bool operator == (I<S> &, I<S> &);\n+  template <typename S> friend bool operator == (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator < (I<S> &, I<S> &);\n+  template <typename S> friend bool operator < (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator <= (I<S> &, I<S> &);\n+  template <typename S> friend bool operator <= (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator > (I<S> &, I<S> &);\n+  template <typename S> friend bool operator > (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator >= (I<S> &, I<S> &);\n+  template <typename S> friend bool operator >= (const I<S> &, const I<S> &);\n+  template <typename S> friend typename I<S>::difference_type operator - (I<S> &, I<S> &);\n+  template <typename S> friend typename I<S>::difference_type operator - (const I<S> &, const I<S> &);\n+  template <typename S> friend I<S> operator + (typename I<S>::difference_type , const I<S> &);\n+private:\n+  T *p;\n+};\n+template <typename T> I<T>::I () : p (0) {}\n+template <typename T> I<T>::~I () {}\n+template <typename T> I<T>::I (T *x) : p (x) {}\n+template <typename T> I<T>::I (const I &x) : p (x.p) {}\n+template <typename T> T &I<T>::operator * () { return *p; }\n+template <typename T> T *I<T>::operator -> () { return p; }\n+template <typename T> T &I<T>::operator [] (const difference_type &x) const { return p[x]; }\n+template <typename T> I<T> &I<T>::operator = (const I &x) { p = x.p; return *this; }\n+template <typename T> I<T> &I<T>::operator ++ () { ++p; return *this; }\n+template <typename T> I<T> I<T>::operator ++ (int) { return I (p++); }\n+template <typename T> I<T> &I<T>::operator -- () { --p; return *this; }\n+template <typename T> I<T> I<T>::operator -- (int) { return I (p--); }\n+template <typename T> I<T> &I<T>::operator += (const difference_type &x) { p += x; return *this; }\n+template <typename T> I<T> &I<T>::operator -= (const difference_type &x) { p -= x; return *this; }\n+template <typename T> I<T> I<T>::operator + (const difference_type &x) const { return I (p + x); }\n+template <typename T> I<T> I<T>::operator - (const difference_type &x) const { return I (p - x); }\n+template <typename T> bool operator == (I<T> &x, I<T> &y) { return x.p == y.p; }\n+template <typename T> bool operator == (const I<T> &x, const I<T> &y) { return x.p == y.p; }\n+template <typename T> bool operator != (I<T> &x, I<T> &y) { return !(x == y); }\n+template <typename T> bool operator != (const I<T> &x, const I<T> &y) { return !(x == y); }\n+template <typename T> bool operator < (I<T> &x, I<T> &y) { return x.p < y.p; }\n+template <typename T> bool operator < (const I<T> &x, const I<T> &y) { return x.p < y.p; }\n+template <typename T> bool operator <= (I<T> &x, I<T> &y) { return x.p <= y.p; }\n+template <typename T> bool operator <= (const I<T> &x, const I<T> &y) { return x.p <= y.p; }\n+template <typename T> bool operator > (I<T> &x, I<T> &y) { return x.p > y.p; }\n+template <typename T> bool operator > (const I<T> &x, const I<T> &y) { return x.p > y.p; }\n+template <typename T> bool operator >= (I<T> &x, I<T> &y) { return x.p >= y.p; }\n+template <typename T> bool operator >= (const I<T> &x, const I<T> &y) { return x.p >= y.p; }\n+template <typename T> typename I<T>::difference_type operator - (I<T> &x, I<T> &y) { return x.p - y.p; }\n+template <typename T> typename I<T>::difference_type operator - (const I<T> &x, const I<T> &y) { return x.p - y.p; }\n+template <typename T> I<T> operator + (typename I<T>::difference_type x, const I<T> &y) { return I<T> (x + y.p); }\n+\n+template <typename T>\n+class J\n+{\n+public:\n+  J(const I<T> &x, const I<T> &y) : b (x), e (y) {}\n+  const I<T> &begin ();\n+  const I<T> &end ();\n+private:\n+  I<T> b, e;\n+};\n+\n+template <typename T> const I<T> &J<T>::begin () { return b; }\n+template <typename T> const I<T> &J<T>::end () { return e; }\n+\n+template <typename T>\n+void baz (I<T> &i);\n+\n+void\n+foo (J<int> j)\n+{\n+  _Cilk_for (I<int> i = j.begin (); i < j.end (); i += 2)\n+    baz (i);\n+}"}, {"sha": "ff9a324a13f7ee415b16468fe3406296c614118c", "filename": "gcc/testsuite/g++.dg/cilk-plus/CK/cilk-for-tplt.cc", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fcilk-for-tplt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fcilk-for-tplt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fcilk-for-tplt.cc?ref=9a771876d342f9cf0b64c2ceada267ff50e18206", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do run { target { i?86-*-* x86_64-*-* } } } */\n+/* { dg-options \"-fcilkplus\" } */\n+/* { dg-options \"-lcilkrts\" { target { i?86-*-* x86_64-*-* } } } */\n+\n+#define SIZE 100\n+#define CHECK_VALUE 5\n+\n+template <class T>\n+int func (T start, T end)\n+{\n+  int Array[SIZE];\n+  _Cilk_for (T ii = 0; ii < end; ii++)\n+    Array[ii] = CHECK_VALUE;\n+\n+  for (T ii = 0; ii < end; ii++)\n+    if (Array[ii] != CHECK_VALUE)\n+      __builtin_abort ();\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  return func <int> (0, 100) + func <long> (0, 100);\n+}"}, {"sha": "d2243acf581b3d30ef56ed83a4135704f52ab732", "filename": "gcc/testsuite/g++.dg/cilk-plus/CK/for1.cc", "status": "added", "additions": 376, "deletions": 0, "changes": 376, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Ffor1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Ffor1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Ffor1.cc?ref=9a771876d342f9cf0b64c2ceada267ff50e18206", "patch": "@@ -0,0 +1,376 @@\n+/* { dg-do run { target { i?86-*-* x86_64-*-* } } } */\n+/* { dg-options \"-fcilkplus\" } */\n+/* { dg-additional-options \"-lcilkrts\" { target { i?86-*-* x86_64-*-* } } } */\n+\n+#if HAVE_IO\n+#include <cstdio>\n+#endif\n+\n+typedef __PTRDIFF_TYPE__ ptrdiff_t;\n+extern \"C\" void abort ();\n+\n+template <typename T>\n+class I\n+{\n+public:\n+  typedef ptrdiff_t difference_type;\n+  I ();\n+  ~I ();\n+  I (T *);\n+  I (const I &);\n+  T &operator * ();\n+  T *operator -> ();\n+  T &operator [] (const difference_type &) const;\n+  I &operator = (const I &);\n+  I &operator ++ ();\n+  I operator ++ (int);\n+  I &operator -- ();\n+  I operator -- (int);\n+  I &operator += (const difference_type &);\n+  I &operator -= (const difference_type &);\n+  I operator + (const difference_type &) const;\n+  I operator - (const difference_type &) const;\n+  template <typename S> friend bool operator == (I<S> &, I<S> &);\n+  template <typename S> friend bool operator == (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator < (I<S> &, I<S> &);\n+  template <typename S> friend bool operator < (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator <= (I<S> &, I<S> &);\n+  template <typename S> friend bool operator <= (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator > (I<S> &, I<S> &);\n+  template <typename S> friend bool operator > (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator >= (I<S> &, I<S> &);\n+  template <typename S> friend bool operator >= (const I<S> &, const I<S> &);\n+  template <typename S> friend typename I<S>::difference_type operator - (I<S> &, I<S> &);\n+  template <typename S> friend typename I<S>::difference_type operator - (const I<S> &, const I<S> &);\n+  template <typename S> friend I<S> operator + (typename I<S>::difference_type , const I<S> &);\n+private:\n+  T *p;\n+};\n+template <typename T> I<T>::I () : p (0) {}\n+template <typename T> I<T>::~I () {}\n+template <typename T> I<T>::I (T *x) : p (x) {}\n+template <typename T> I<T>::I (const I &x) : p (x.p) {}\n+template <typename T> T &I<T>::operator * () { return *p; }\n+template <typename T> T *I<T>::operator -> () { return p; }\n+template <typename T> T &I<T>::operator [] (const difference_type &x) const { return p[x]; }\n+template <typename T> I<T> &I<T>::operator = (const I &x) { p = x.p; return *this; }\n+template <typename T> I<T> &I<T>::operator ++ () { ++p; return *this; }\n+template <typename T> I<T> I<T>::operator ++ (int) { return I (p++); }\n+template <typename T> I<T> &I<T>::operator -- () { --p; return *this; }\n+template <typename T> I<T> I<T>::operator -- (int) { return I (p--); }\n+template <typename T> I<T> &I<T>::operator += (const difference_type &x) { p += x; return *this; }\n+template <typename T> I<T> &I<T>::operator -= (const difference_type &x) { p -= x; return *this; }\n+template <typename T> I<T> I<T>::operator + (const difference_type &x) const { return I (p + x); }\n+template <typename T> I<T> I<T>::operator - (const difference_type &x) const { return I (p - x); }\n+template <typename T> bool operator == (I<T> &x, I<T> &y) { return x.p == y.p; }\n+template <typename T> bool operator == (const I<T> &x, const I<T> &y) { return x.p == y.p; }\n+template <typename T> bool operator != (I<T> &x, I<T> &y) { return !(x == y); }\n+template <typename T> bool operator != (const I<T> &x, const I<T> &y) { return !(x == y); }\n+template <typename T> bool operator < (I<T> &x, I<T> &y) { return x.p < y.p; }\n+template <typename T> bool operator < (const I<T> &x, const I<T> &y) { return x.p < y.p; }\n+template <typename T> bool operator <= (I<T> &x, I<T> &y) { return x.p <= y.p; }\n+template <typename T> bool operator <= (const I<T> &x, const I<T> &y) { return x.p <= y.p; }\n+template <typename T> bool operator > (I<T> &x, I<T> &y) { return x.p > y.p; }\n+template <typename T> bool operator > (const I<T> &x, const I<T> &y) { return x.p > y.p; }\n+template <typename T> bool operator >= (I<T> &x, I<T> &y) { return x.p >= y.p; }\n+template <typename T> bool operator >= (const I<T> &x, const I<T> &y) { return x.p >= y.p; }\n+template <typename T> typename I<T>::difference_type operator - (I<T> &x, I<T> &y) { return x.p - y.p; }\n+template <typename T> typename I<T>::difference_type operator - (const I<T> &x, const I<T> &y) { return x.p - y.p; }\n+template <typename T> I<T> operator + (typename I<T>::difference_type x, const I<T> &y) { return I<T> (x + y.p); }\n+\n+template <typename T>\n+class J\n+{\n+public:\n+  J(const I<T> &x, const I<T> &y) : b (x), e (y) {}\n+  const I<T> &begin ();\n+  const I<T> &end ();\n+private:\n+  I<T> b, e;\n+};\n+\n+template <typename T> const I<T> &J<T>::begin () { return b; }\n+template <typename T> const I<T> &J<T>::end () { return e; }\n+\n+int results[2000];\n+\n+template <typename T>\n+void\n+baz (I<T> &i)\n+{\n+  if (*i < 0 || *i >= 2000)\n+    {\n+#if HAVE_IO\n+      printf (\"*i(%d) is < 0 or >= 2000\\n\", *i);\n+      fflush (stdout);\n+#endif\n+     __builtin_abort ();\n+    }\n+  else\n+    results[*i]++;\n+}\n+\n+void\n+f1 (const I<int> &x, const I<int> &y)\n+{\n+  _Cilk_for (I<int> i = x; i <= y; i += 6)\n+    {\n+      baz (i);\n+    }\n+\n+#if HAVE_IO\n+  printf(\"===== Starting F1 =========\\n\");\n+  for (I<int> i = x; i <= y; i+= 6) {\n+    printf(\"Result[%4d] = %2d\\n\", *i, results[*i]);\n+    fflush (stdout);\n+  }\n+#endif\n+}\n+\n+void\n+f2 (const I<int> &x, const I<int> &y)\n+{\n+  _Cilk_for (I<int> i = x; i < y - 1; i += 2)\n+    baz (i);\n+\n+#if HAVE_IO\n+  printf(\"===== Starting F2 =========\\n\");\n+  for (int ii = 0; ii < 1998; ii += 2) {\n+    printf(\"Result[%4d] = %2d\\n\", ii, results[ii]);\n+    fflush (stdout);\n+  }\n+#endif\n+}\n+\n+template <typename T>\n+void\n+f3 (const I<int> &x, const I<int> &y)\n+{\n+  _Cilk_for (I<int> i = x; i <= y; i += 1)\n+    baz (i);\n+#if HAVE_IO\n+  printf(\"===== Starting F3 =========\\n\");\n+  for (int ii = 20; ii < 1987; ii += 1) {\n+    printf(\"Result[%4d] = %2d\\n\", ii, results[ii]);\n+    fflush (stdout);\n+  }\n+\n+#endif\n+}\n+\n+template <typename T>\n+void\n+f4 (const I<int> &x, const I<int> &y)\n+{\n+  _Cilk_for (I<int> i = x + (2000 - 64); i > y + 10; --i)\n+    baz (i);\n+#if HAVE_IO\n+  printf(\"===== Starting F3 =========\\n\");\n+  for (I<int> i = x + (2000 - 64); i > y + 10; --i) {\n+    printf(\"Result[%4d] = %2d\\n\", *i, results[*i]);\n+    fflush (stdout);\n+  }\n+#endif\n+}\n+void\n+f5 (const I<int> &x, const I<int> &y)\n+{\n+  _Cilk_for (I<int> i = x + 2000 - 64; i > y + 10; i -= 10)\n+    baz (i);\n+#if HAVE_IO\n+  for (I<int> i = x + 2000 - 64; i > y + 10; i -= 10) {\n+    printf(\"Result[%4d] = %2d\\n\", *i, results[*i]);\n+    fflush (stdout);\n+  }\n+#endif\n+}\n+\n+template <int N>\n+void\n+f6 (const I<int> &x, const I<int> &y)\n+{\n+  _Cilk_for (I<int> i = x + 2000 - 64; i > y + 10; i -= 10)\n+    {\n+      I<int> j = i + N;\n+      baz (j);\n+    }\n+#if HAVE_IO\n+  for (I<int> i = x + 2000 - 64; i > y + 10; i = i - 12 + 2)\n+    {\n+      I<int> j = i + N;\n+      printf(\"Result[%4d] = %2d\\n\", *j, results[*j]);\n+      fflush (stdout);\n+    }\n+#endif\n+}\n+template <int N>\n+void\n+f7 (I<int> ii, const I<int> &x, const I<int> &y)\n+{\n+  _Cilk_for (I <int> i = x - 10; i <= y + 10; i += N)\n+    baz (i);\n+#if HAVE_IO\n+  for (I<int> i = x - 10; i <= y + 10; i += N)\n+    {\n+      printf(\"Result[%4d] = %2d\\n\", *i, results[*i]);\n+      fflush (stdout);\n+    }\n+#endif\n+}\n+\n+template <int N>\n+void\n+f8 (J<int> j)\n+{\n+  _Cilk_for (I<int> i = j.begin (); i <= j.end () + N; i += 2)\n+    baz (i);\n+#if HAVE_IO\n+  for (I<int> i = j.begin (); i <= j.end () + N; i += 2) {\n+    printf(\"Result[%4d] = %2d\\n\", *i, results[*i]);\n+    fflush (stdout);\n+  }\n+#endif\n+\n+}\n+\n+template <typename T, int N>\n+void\n+f9 (const I<T> &x, const I<T> &y)\n+{\n+  _Cilk_for (I<T> i = x; i <= y; i += N)\n+    baz (i);\n+#if HAVE_IO\n+  for (I<T> i = x; i <= y;  i  = i + N)\n+    {\n+      printf(\"Result[%4d] = %2d\\n\", *i, results[*i]);\n+      fflush (stdout);\n+    }\n+#endif\n+}\n+\n+template <typename T, int N>\n+void\n+f10 (const I<T> &x, const I<T> &y)\n+{\n+  _Cilk_for (I<T> i = x; i > y; i += N)\n+    baz (i);\n+#if HAVE_IO\n+  for (I<T> i = x; i > y;  i  = i + N) {\n+    printf(\"Result[%4d] = %2d\\n\", *i, results[*i]);\n+    fflush (stdout);\n+  }\n+#endif\n+}\n+\n+template <typename T>\n+void\n+f11 (const T &x, const T &y)\n+{\n+    _Cilk_for (T i = x; i <= y; i += 3)\n+      baz (i);\n+\n+#if HAVE_IO\n+  for (T i = x; i <= y;  i  += 3) {\n+    printf(\"Result[%4d] = %2d\\n\", *i, results[*i]);\n+    fflush (stdout);\n+  }\n+#endif\n+      T j = y + 3;\n+      baz (j);\n+\n+}\n+\n+template <typename T>\n+void\n+f12 (const T &x, const T &y)\n+{\n+  _Cilk_for (T i = x; i > y; --i)\n+    baz (i);\n+#if HAVE_IO\n+  for (T i = x; i > y;  --i) {\n+    printf(\"Result[%4d] = %2d\\n\", *i, results[*i]);\n+    fflush (stdout);\n+  }\n+#endif\n+}\n+template <int N>\n+struct K\n+{\n+  template <typename T>\n+  static void\n+  f13 (const T &x, const T &y)\n+  {\n+    _Cilk_for (T i = x; i <= y + N; i += N)\n+      baz (i);\n+#if HAVE_IO\n+  for (T i = x; i < y+N;  i += N) {\n+    printf(\"Result[%4d] = %2d\\n\", *i, results[*i]);\n+    fflush (stdout);\n+  }\n+#endif\n+  }\n+};\n+\n+#define check(expr) \\\n+  for (int i = 0; i < 2000; i++)\t\t\t\\\n+    if (expr)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tif (results[i] != 1) {\t\t\t\t\\\n+\t  __builtin_abort ();\t\t\t\t\\\n+\t}\t\t\t\t\t\t\\\n+\tresults[i] = 0;\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+    else if (results[i])\t\t\t\t\\\n+      abort ()\n+\n+int\n+main ()\n+{\n+  int a[2000];\n+  long b[2000];\n+  for (int i = 0; i < 2000; i++)\n+    {\n+      a[i] = i;\n+      b[i] = i;\n+    }\n+  f1 (&a[10], &a[1990]);\n+  check (i >= 10 && i <= 1990 && (i - 10) % 6 == 0);\n+  f2 (&a[0], &a[1999]);\n+  check (i < 1998 && (i & 1) == 0);\n+  f3<int> (&a[20], &a[1837]);\n+  check (i >= 20 && i <= 1837);\n+  f4<int> (&a[0], &a[30]);\n+  check (i > 40 && i <= 2000 - 64);\n+\n+  f5 (&a[0], &a[100]);\n+  check (i >= 116 && i <= 2000 - 64 && (i - 116) % 10 == 0);\n+  f6<-10> (&a[10], &a[110]);\n+  check (i >= 116 && i <= 2000 - 64 && (i - 116) % 10 == 0);\n+\n+  f7<6> (I<int> (), &a[12], &a[1800]);\n+  check (i >= 2 && i <= 1808 && (i - 2) % 6 == 0);\n+\n+  f8<121> (J<int> (&a[14], &a[1803]));\n+  check (i >= 14 && i <= 1924 && (i & 1) == 0);\n+  f9<int, 7> (&a[33], &a[1967]);\n+  check (i >= 33 && i <= 1967 && (i - 33) % 7 == 0);\n+  f10<int, -7> (&a[1939], &a[17]);\n+  check (i >= 21 && i <= 1939 && (i - 21) % 7 == 0);\n+  f11<I<int> > (&a[16], &a[1981]);\n+  check (i >= 16 && i <= 1984 && (i - 16) % 3 == 0);\n+  f12<I<int> > (&a[1761], &a[37]);\n+  check (i > 37 && i <= 1761);\n+  K<5>::f13<I<int> > (&a[1], &a[1935]);\n+  check (i >= 1 && i <= 1936 && (i - 1) % 5 == 0);\n+  f9<long, 7> (&b[33], &b[1967]);\n+  check (i >= 33 && i <= 1967 && (i - 33) % 7 == 0);\n+  f10<long, -7> (&b[1939], &b[17]);\n+  check (i >= 21 && i <= 1939 && (i - 21) % 7 == 0);\n+  f11<I<long> > (&b[16], &b[1981]);\n+  check (i >= 16 && i <= 1984 && (i - 16) % 3 == 0);\n+  f12<I<long> > (&b[1761], &b[37]);\n+  check (i > 37 && i <= 1761);\n+  K<5>::f13<I<long> > (&b[1], &b[1935]);\n+  check (i >= 1 && i <= 1936 && (i - 1) % 5 == 0);\n+  return 0;\n+}"}, {"sha": "d68ee7b7e7bf0d17cd95440ecda7d9c18175c61f", "filename": "gcc/testsuite/g++.dg/cilk-plus/CK/stl_iter.cc", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fstl_iter.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fstl_iter.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fstl_iter.cc?ref=9a771876d342f9cf0b64c2ceada267ff50e18206", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-do run { target { i?86-*-* x86_64-*-* } } } */\n+/* { dg-options \"-fcilkplus\" } */\n+/* { dg-options \"-lcilkrts\" { target { i?86-*-* x86_64-*-* } } } */\n+\n+#include <vector>\n+#include <cstdio>\n+#include <iostream>\n+#include <algorithm>\n+\n+using namespace std;\n+\n+\n+int main(void)\n+{\n+vector <int> array;\n+vector <int> array_serial;\n+\n+for (int ii = -1; ii < 10; ii++)\n+{\n+  array.push_back(ii);\n+  array_serial.push_back (ii);\n+}\n+_Cilk_for (vector<int>::iterator iter = array.begin(); iter != array.end();\n+\t  iter++)\n+{\n+   if (*iter == 6)\n+     *iter = 13;\n+}\n+for (vector<int>::iterator iter = array_serial.begin();\n+     iter != array_serial.end(); iter++)\n+{\n+   if (*iter == 6)\n+     *iter = 13;\n+}\n+sort (array.begin(), array.end());\n+sort (array_serial.begin(), array_serial.end());\n+\n+vector <int>::iterator iter = array.begin ();\n+vector <int>::iterator iter_serial = array_serial.begin ();\n+\n+while (iter != array.end () && iter_serial != array_serial.end ())\n+{\n+  if (*iter != *iter_serial)\n+    __builtin_abort ();\n+  iter++;\n+  iter_serial++;\n+}\n+\n+return 0;\n+}"}, {"sha": "6eee0d99ed1421af920ae5c52df4bbe58ce9aee7", "filename": "gcc/testsuite/g++.dg/cilk-plus/CK/stl_rev_iter.cc", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fstl_rev_iter.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fstl_rev_iter.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fstl_rev_iter.cc?ref=9a771876d342f9cf0b64c2ceada267ff50e18206", "patch": "@@ -0,0 +1,68 @@\n+/* { dg-do run { target { i?86-*-* x86_64-*-* } } } */\n+/* { dg-options \"-fcilkplus\" } */\n+/* { dg-options \"-lcilkrts\" { target { i?86-*-* x86_64-*-* } } } */\n+\n+\n+#include <vector>\n+#include <cstdio>\n+#include <iostream>\n+#include <algorithm>\n+\n+using namespace std;\n+\n+\n+int main(void)\n+{\n+vector <int> array,array_serial;\n+\n+for (int ii = -1; ii < 10; ii++)\n+{\n+  array.push_back(ii);\n+  array_serial.push_back(ii);\n+}\n+_Cilk_for (vector<int>::reverse_iterator iter4 = array.rbegin();\n+\t   iter4 != array.rend(); iter4++)\n+{\n+  if (*iter4 == 0x8) {\n+    *iter4 = 9;\n+  }\n+}\n+\n+_Cilk_for (vector<int>::reverse_iterator iter4 = array_serial.rbegin();\n+\t   iter4 != array_serial.rend(); iter4++)\n+{\n+  if (*iter4 == 0x8) {\n+    *iter4 = 9;\n+  }\n+}\n+_Cilk_for (vector<int>::reverse_iterator iter2 = array.rbegin();\n+\t   iter2 != array.rend();\n+\t  iter2 += 1)\n+{\n+   if ((*iter2 == 0x4) || (*iter2 == 0x7)) {\n+    *iter2 = 0x3;\n+   }\n+}\n+for (vector<int>::reverse_iterator iter2 = array_serial.rbegin();\n+     iter2 != array_serial.rend();\n+\t  iter2 += 1)\n+{\n+   if ((*iter2 == 0x4) || (*iter2 == 0x7)) {\n+    *iter2 = 0x3;\n+   }\n+}\n+sort (array.begin(), array.end());\n+sort (array_serial.begin(), array_serial.end());\n+\n+vector <int>::iterator iter = array.begin ();\n+vector <int>::iterator iter_serial = array_serial.begin ();\n+while (iter != array.end () && iter_serial != array_serial.end ())\n+{\n+  if (*iter != *iter_serial)\n+    __builtin_abort ();\n+  iter++;\n+  iter_serial++;\n+}\n+\n+return 0;\n+}"}, {"sha": "84518f343440f01b2a2c5743c555040b3be1b80b", "filename": "gcc/testsuite/g++.dg/cilk-plus/CK/stl_test.cc", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fstl_test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fstl_test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fstl_test.cc?ref=9a771876d342f9cf0b64c2ceada267ff50e18206", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-do run { target { i?86-*-* x86_64-*-* } } } */\n+/* { dg-options \"-fcilkplus\" } */\n+/* { dg-options \"-lcilkrts\" { target { i?86-*-* x86_64-*-* } } } */\n+\n+\n+#include <iostream>\n+#include <cstdio>\n+#include <cstdlib>\n+#include <vector>\n+#include <algorithm>\n+#include <list>\n+\n+using namespace std;\n+\n+\n+int main(int argc, char **argv)\n+{\n+  vector <int> number_list, number_list_serial;\n+  int new_number = 0;\n+  int no_elements = 0;\n+\n+  if (argc != 2)\n+  {\n+    no_elements = 10;\n+  }\n+\n+\n+  number_list.clear();\n+  number_list_serial.clear();\n+  for (int ii = 0; ii < no_elements; ii++)\n+  {\n+    number_list.push_back(new_number);\n+    number_list_serial.push_back(new_number);\n+  }\n+\n+  _Cilk_for (int jj = 0; jj < no_elements; jj++)\n+  {\n+    number_list[jj] = jj + no_elements;\n+  }\n+  for (int jj = 0; jj < no_elements; jj++)\n+  {\n+    number_list_serial[jj] = jj + no_elements;\n+  }\n+\n+  for (int jj = 0; jj < no_elements; jj++)\n+    if (number_list_serial[jj] != number_list[jj])\n+      __builtin_abort ();\n+\n+  return 0;\n+}"}, {"sha": "0761f95df45b77b544b064d0908a35a664d3a182", "filename": "gcc/tree-core.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=9a771876d342f9cf0b64c2ceada267ff50e18206", "patch": "@@ -334,7 +334,11 @@ enum omp_clause_code {\n   OMP_CLAUSE_TASKGROUP,\n \n   /* Internally used only clause, holding SIMD uid.  */\n-  OMP_CLAUSE__SIMDUID_\n+  OMP_CLAUSE__SIMDUID_,\n+\n+  /* Internally used only clause, holding _Cilk_for # of iterations\n+     on OMP_PARALLEL.  */\n+  OMP_CLAUSE__CILK_FOR_COUNT_\n };\n \n #undef DEFTREESTRUCT\n@@ -351,6 +355,7 @@ enum omp_clause_schedule_kind {\n   OMP_CLAUSE_SCHEDULE_GUIDED,\n   OMP_CLAUSE_SCHEDULE_AUTO,\n   OMP_CLAUSE_SCHEDULE_RUNTIME,\n+  OMP_CLAUSE_SCHEDULE_CILKFOR,\n   OMP_CLAUSE_SCHEDULE_LAST\n };\n "}, {"sha": "a378a02196d15213a88611bee0da3f4f11ec5d3e", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=9a771876d342f9cf0b64c2ceada267ff50e18206", "patch": "@@ -1115,6 +1115,7 @@ convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \tcase OMP_CLAUSE_NUM_TEAMS:\n \tcase OMP_CLAUSE_THREAD_LIMIT:\n \tcase OMP_CLAUSE_SAFELEN:\n+\tcase OMP_CLAUSE__CILK_FOR_COUNT_:\n \t  wi->val_only = true;\n \t  wi->is_lhs = false;\n \t  convert_nonlocal_reference_op (&OMP_CLAUSE_OPERAND (clause, 0),\n@@ -1744,6 +1745,7 @@ convert_local_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \tcase OMP_CLAUSE_NUM_TEAMS:\n \tcase OMP_CLAUSE_THREAD_LIMIT:\n \tcase OMP_CLAUSE_SAFELEN:\n+\tcase OMP_CLAUSE__CILK_FOR_COUNT_:\n \t  wi->val_only = true;\n \t  wi->is_lhs = false;\n \t  convert_local_reference_op (&OMP_CLAUSE_OPERAND (clause, 0), &dummy,"}, {"sha": "ce0c655bd3d8781c4246bede1245710f9a4c07d9", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=9a771876d342f9cf0b64c2ceada267ff50e18206", "patch": "@@ -361,6 +361,13 @@ dump_omp_clause (pretty_printer *buffer, tree clause, int spc, int flags)\n       pp_right_paren (buffer);\n       break;\n \n+    case OMP_CLAUSE__CILK_FOR_COUNT_:\n+      pp_string (buffer, \"_Cilk_for_count_(\");\n+      dump_generic_node (buffer, OMP_CLAUSE_OPERAND (clause, 0),\n+\t\t\t spc, flags, false);\n+      pp_right_paren (buffer);\n+      break;\n+\n     case OMP_CLAUSE_NOWAIT:\n       pp_string (buffer, \"nowait\");\n       break;\n@@ -411,6 +418,9 @@ dump_omp_clause (pretty_printer *buffer, tree clause, int spc, int flags)\n \tcase OMP_CLAUSE_SCHEDULE_AUTO:\n \t  pp_string (buffer, \"auto\");\n \t  break;\n+\tcase OMP_CLAUSE_SCHEDULE_CILKFOR:\n+\t  pp_string (buffer, \"cilk-for grain\");\n+\t  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -2421,6 +2431,12 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       pp_string (buffer, \"#pragma simd\");\n       goto dump_omp_loop;\n \n+    case CILK_FOR:\n+      /* This label points one line after dumping the clauses.\n+\t For _Cilk_for the clauses are dumped after the _Cilk_for (...)\n+\t parameters are printed out.  */\n+      goto dump_omp_loop_cilk_for;\n+\n     case OMP_DISTRIBUTE:\n       pp_string (buffer, \"#pragma omp distribute\");\n       goto dump_omp_loop;\n@@ -2449,27 +2465,35 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n     dump_omp_loop:\n       dump_omp_clauses (buffer, OMP_FOR_CLAUSES (node), spc, flags);\n \n+    dump_omp_loop_cilk_for:\n       if (!(flags & TDF_SLIM))\n \t{\n \t  int i;\n \n \t  if (OMP_FOR_PRE_BODY (node))\n \t    {\n-\t      newline_and_indent (buffer, spc + 2);\n+\t      if (TREE_CODE (node) == CILK_FOR)\n+\t\tpp_string (buffer, \"  \");\n+\t      else\n+\t\tnewline_and_indent (buffer, spc + 2);\n \t      pp_left_brace (buffer);\n \t      spc += 4;\n \t      newline_and_indent (buffer, spc);\n \t      dump_generic_node (buffer, OMP_FOR_PRE_BODY (node),\n-\t\t  spc, flags, false);\n+\t\t\t\t spc, flags, false);\n \t    }\n \t  if (OMP_FOR_INIT (node))\n \t    {\n \t      spc -= 2;\n \t      for (i = 0; i < TREE_VEC_LENGTH (OMP_FOR_INIT (node)); i++)\n \t\t{\n \t\t  spc += 2;\n-\t\t  newline_and_indent (buffer, spc);\n-\t\t  pp_string (buffer, \"for (\");\n+\t\t  if (TREE_CODE (node) != CILK_FOR || OMP_FOR_PRE_BODY (node))\n+\t\t    newline_and_indent (buffer, spc);\n+\t\t  if (TREE_CODE (node) == CILK_FOR)\n+\t\t    pp_string (buffer, \"_Cilk_for (\");\n+\t\t  else\n+\t\t    pp_string (buffer, \"for (\");\n \t\t  dump_generic_node (buffer,\n \t\t\t\t     TREE_VEC_ELT (OMP_FOR_INIT (node), i),\n \t\t\t\t     spc, flags, false);\n@@ -2483,6 +2507,8 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \t\t\t\t     spc, flags, false);\n \t\t  pp_right_paren (buffer);\n \t\t}\n+\t      if (TREE_CODE (node) == CILK_FOR)\n+\t\tdump_omp_clauses (buffer, OMP_FOR_CLAUSES (node), spc, flags);\n \t    }\n \t  if (OMP_FOR_BODY (node))\n \t    {"}, {"sha": "d1d67efa62942cb9662ebb48127e7c83cccc0c77", "filename": "gcc/tree.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=9a771876d342f9cf0b64c2ceada267ff50e18206", "patch": "@@ -281,6 +281,7 @@ unsigned const char omp_clause_num_ops[] =\n   0, /* OMP_CLAUSE_SECTIONS  */\n   0, /* OMP_CLAUSE_TASKGROUP  */\n   1, /* OMP_CLAUSE__SIMDUID_  */\n+  1, /* OMP_CLAUSE__CILK_FOR_COUNT_  */\n };\n \n const char * const omp_clause_code_name[] =\n@@ -324,7 +325,8 @@ const char * const omp_clause_code_name[] =\n   \"parallel\",\n   \"sections\",\n   \"taskgroup\",\n-  \"_simduid_\"\n+  \"_simduid_\",\n+  \"_Cilk_for_count_\"\n };\n \n \n@@ -11041,6 +11043,7 @@ walk_tree_1 (tree *tp, walk_tree_fn func, void *data,\n \tcase OMP_CLAUSE_SIMDLEN:\n \tcase OMP_CLAUSE__LOOPTEMP_:\n \tcase OMP_CLAUSE__SIMDUID_:\n+\tcase OMP_CLAUSE__CILK_FOR_COUNT_:\n \t  WALK_SUBTREE (OMP_CLAUSE_OPERAND (*tp, 0));\n \t  /* FALLTHRU */\n "}, {"sha": "bd39e4b89bd4cbdb6fae1c563702511c09fb108a", "filename": "gcc/tree.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a771876d342f9cf0b64c2ceada267ff50e18206/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=9a771876d342f9cf0b64c2ceada267ff50e18206", "patch": "@@ -1064,6 +1064,10 @@ DEFTREECODE (OMP_SIMD, \"omp_simd\", tcc_statement, 6)\n    Operands like for OMP_FOR.  */\n DEFTREECODE (CILK_SIMD, \"cilk_simd\", tcc_statement, 6)\n \n+/* Cilk Plus - _Cilk_for (..)\n+   Operands like for OMP_FOR.  */\n+DEFTREECODE (CILK_FOR, \"cilk_for\", tcc_statement, 6)\n+\n /* OpenMP - #pragma omp distribute [clause1 ... clauseN]\n    Operands like for OMP_FOR.  */\n DEFTREECODE (OMP_DISTRIBUTE, \"omp_distribute\", tcc_statement, 6)"}]}