{"sha": "e86a994681b0cad81ea13d29d9ab5f65d40ccc63", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTg2YTk5NDY4MWIwY2FkODFlYTEzZDI5ZDlhYjVmNjVkNDBjY2M2Mw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2015-06-30T20:55:13Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2015-06-30T20:55:13Z"}, "message": "defaults.h (HAVE_epilogue, [...]): Delete.\n\ngcc/\n\t* defaults.h (HAVE_epilogue, gen_epilogue): Delete.\n\t* target-insns.def (epilogue, prologue, sibcall_prologue): New\n\ttargetm instruction patterns.\n\t* alias.c (init_alias_analysis): Use them instead of HAVE_*/gen_*\n\tinterface.\n\t* calls.c (expand_call): Likewise.\n\t* cfgrtl.c (cfg_layout_finalize): Likewise.\n\t* df-scan.c (df_get_entry_block_def_set): Likewise.\n\t(df_get_exit_block_use_set): Likewise.\n\t* dwarf2cfi.c (pass_dwarf2_frame::gate): Likewise.\n\t* final.c (final_start_function): Likewise.\n\t* function.c (thread_prologue_and_epilogue_insns): Likewise.\n\t(reposition_prologue_and_epilogue_notes): Likewise.\n\t* reorg.c (find_end_label): Likewise.\n\t* toplev.c (process_options): Likewise.\n\nFrom-SVN: r225208", "tree": {"sha": "2193da8de1f51038b6a2aaffb584896891556546", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2193da8de1f51038b6a2aaffb584896891556546"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e86a994681b0cad81ea13d29d9ab5f65d40ccc63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e86a994681b0cad81ea13d29d9ab5f65d40ccc63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e86a994681b0cad81ea13d29d9ab5f65d40ccc63", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e86a994681b0cad81ea13d29d9ab5f65d40ccc63/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ec5d0088148d1d6218f5f503d1c8e67a529dfacd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec5d0088148d1d6218f5f503d1c8e67a529dfacd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec5d0088148d1d6218f5f503d1c8e67a529dfacd"}], "stats": {"total": 126, "additions": 53, "deletions": 73}, "files": [{"sha": "18c02bdce449db74189aa0dba871970d76526fcb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e86a994681b0cad81ea13d29d9ab5f65d40ccc63/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e86a994681b0cad81ea13d29d9ab5f65d40ccc63/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e86a994681b0cad81ea13d29d9ab5f65d40ccc63", "patch": "@@ -1,3 +1,21 @@\n+2015-06-30  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* defaults.h (HAVE_epilogue, gen_epilogue): Delete.\n+\t* target-insns.def (epilogue, prologue, sibcall_prologue): New\n+\ttargetm instruction patterns.\n+\t* alias.c (init_alias_analysis): Use them instead of HAVE_*/gen_*\n+\tinterface.\n+\t* calls.c (expand_call): Likewise.\n+\t* cfgrtl.c (cfg_layout_finalize): Likewise.\n+\t* df-scan.c (df_get_entry_block_def_set): Likewise.\n+\t(df_get_exit_block_use_set): Likewise.\n+\t* dwarf2cfi.c (pass_dwarf2_frame::gate): Likewise.\n+\t* final.c (final_start_function): Likewise.\n+\t* function.c (thread_prologue_and_epilogue_insns): Likewise.\n+\t(reposition_prologue_and_epilogue_notes): Likewise.\n+\t* reorg.c (find_end_label): Likewise.\n+\t* toplev.c (process_options): Likewise.\n+\n 2015-06-30  David Malcolm  <dmalcolm@redhat.com>\n \n \t* typed-splay-tree.h: New file."}, {"sha": "3e75b91b63d15b0bdb009520ebee55e0bae06b41", "filename": "gcc/alias.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e86a994681b0cad81ea13d29d9ab5f65d40ccc63/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e86a994681b0cad81ea13d29d9ab5f65d40ccc63/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=e86a994681b0cad81ea13d29d9ab5f65d40ccc63", "patch": "@@ -3038,6 +3038,14 @@ init_alias_analysis (void)\n   rpo = XNEWVEC (int, n_basic_blocks_for_fn (cfun));\n   rpo_cnt = pre_and_rev_post_order_compute (NULL, rpo, false);\n \n+  /* The prologue/epilogue insns are not threaded onto the\n+     insn chain until after reload has completed.  Thus,\n+     there is no sense wasting time checking if INSN is in\n+     the prologue/epilogue until after reload has completed.  */\n+  bool could_be_prologue_epilogue = ((targetm.have_prologue ()\n+\t\t\t\t      || targetm.have_epilogue ())\n+\t\t\t\t     && reload_completed);\n+\n   pass = 0;\n   do\n     {\n@@ -3076,17 +3084,7 @@ init_alias_analysis (void)\n \t\t{\n \t\t  rtx note, set;\n \n-#if defined (HAVE_prologue)\n-\t\t  static const bool prologue = true;\n-#else\n-\t\t  static const bool prologue = false;\n-#endif\n-\n-\t\t  /* The prologue/epilogue insns are not threaded onto the\n-\t\t     insn chain until after reload has completed.  Thus,\n-\t\t     there is no sense wasting time checking if INSN is in\n-\t\t     the prologue/epilogue until after reload has completed.  */\n-\t\t  if ((prologue || HAVE_epilogue) && reload_completed\n+\t\t  if (could_be_prologue_epilogue\n \t\t      && prologue_epilogue_contains (insn))\n \t\t    continue;\n "}, {"sha": "e97c356ca8061c4593c56453c575277a6607b012", "filename": "gcc/calls.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e86a994681b0cad81ea13d29d9ab5f65d40ccc63/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e86a994681b0cad81ea13d29d9ab5f65d40ccc63/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=e86a994681b0cad81ea13d29d9ab5f65d40ccc63", "patch": "@@ -2783,13 +2783,8 @@ expand_call (tree exp, rtx target, int ignore)\n     try_tail_call = 0;\n \n   /*  Rest of purposes for tail call optimizations to fail.  */\n-  if (\n-#ifdef HAVE_sibcall_epilogue\n-      !HAVE_sibcall_epilogue\n-#else\n-      1\n-#endif\n-      || !try_tail_call\n+  if (!try_tail_call\n+      || !targetm.have_sibcall_epilogue ()\n       /* Doing sibling call optimization needs some work, since\n \t structure_value_addr can be allocated on the stack.\n \t It does not seem worth the effort since few optimizable"}, {"sha": "5ac3a20d0b5df9e91732f919b1d1d68d542c75a9", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e86a994681b0cad81ea13d29d9ab5f65d40ccc63/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e86a994681b0cad81ea13d29d9ab5f65d40ccc63/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=e86a994681b0cad81ea13d29d9ab5f65d40ccc63", "patch": "@@ -4324,7 +4324,7 @@ cfg_layout_finalize (void)\n #endif\n   force_one_exit_fallthru ();\n   rtl_register_cfg_hooks ();\n-  if (reload_completed && !HAVE_epilogue)\n+  if (reload_completed && !targetm.have_epilogue ())\n     fixup_fallthru_exit_predecessor ();\n   fixup_reorder_chain ();\n "}, {"sha": "95ec8f7c5cd6b830449fca09679f3b595c44fbe6", "filename": "gcc/defaults.h", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e86a994681b0cad81ea13d29d9ab5f65d40ccc63/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e86a994681b0cad81ea13d29d9ab5f65d40ccc63/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=e86a994681b0cad81ea13d29d9ab5f65d40ccc63", "patch": "@@ -1426,16 +1426,6 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #define TARGET_VTABLE_USES_DESCRIPTORS 0\n #endif\n \n-#ifndef HAVE_epilogue\n-#define HAVE_epilogue 0\n-static inline rtx\n-gen_epilogue ()\n-{\n-  gcc_unreachable ();\n-  return NULL;\n-}\n-#endif\n-\n #ifndef HAVE_mem_thread_fence\n #define HAVE_mem_thread_fence 0\n static inline rtx"}, {"sha": "22942407f260b1e097afac1177386921c0215954", "filename": "gcc/df-scan.c", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e86a994681b0cad81ea13d29d9ab5f65d40ccc63/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e86a994681b0cad81ea13d29d9ab5f65d40ccc63/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=e86a994681b0cad81ea13d29d9ab5f65d40ccc63", "patch": "@@ -52,13 +52,6 @@ along with GCC; see the file COPYING3.  If not see\n typedef struct df_mw_hardreg *df_mw_hardreg_ptr;\n \n \n-#ifndef HAVE_prologue\n-#define HAVE_prologue 0\n-#endif\n-#ifndef HAVE_sibcall_epilogue\n-#define HAVE_sibcall_epilogue 0\n-#endif\n-\n /* The set of hard registers in eliminables[i].from. */\n \n static HARD_REG_SET elim_reg_set;\n@@ -3523,7 +3516,7 @@ df_get_entry_block_def_set (bitmap entry_block_defs)\n \n   /* Once the prologue has been generated, all of these registers\n      should just show up in the first regular block.  */\n-  if (HAVE_prologue && epilogue_completed)\n+  if (targetm.have_prologue () && epilogue_completed)\n     {\n       /* Defs for the callee saved registers are inserted so that the\n \t pushes have some defining location.  */\n@@ -3701,7 +3694,7 @@ df_get_exit_block_use_set (bitmap exit_block_uses)\n     if (global_regs[i] || EPILOGUE_USES (i))\n       bitmap_set_bit (exit_block_uses, i);\n \n-  if (HAVE_epilogue && epilogue_completed)\n+  if (targetm.have_epilogue () && epilogue_completed)\n     {\n       /* Mark all call-saved registers that we actually used.  */\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n@@ -3721,7 +3714,7 @@ df_get_exit_block_use_set (bitmap exit_block_uses)\n       }\n \n #ifdef EH_RETURN_STACKADJ_RTX\n-  if ((!HAVE_epilogue || ! epilogue_completed)\n+  if ((!targetm.have_epilogue () || ! epilogue_completed)\n       && crtl->calls_eh_return)\n     {\n       rtx tmp = EH_RETURN_STACKADJ_RTX;\n@@ -3731,7 +3724,7 @@ df_get_exit_block_use_set (bitmap exit_block_uses)\n #endif\n \n #ifdef EH_RETURN_HANDLER_RTX\n-  if ((!HAVE_epilogue || ! epilogue_completed)\n+  if ((!targetm.have_epilogue () || ! epilogue_completed)\n       && crtl->calls_eh_return)\n     {\n       rtx tmp = EH_RETURN_HANDLER_RTX;"}, {"sha": "b567b23f93853dd4275b46bb8f41027c373b5c67", "filename": "gcc/dwarf2cfi.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e86a994681b0cad81ea13d29d9ab5f65d40ccc63/gcc%2Fdwarf2cfi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e86a994681b0cad81ea13d29d9ab5f65d40ccc63/gcc%2Fdwarf2cfi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.c?ref=e86a994681b0cad81ea13d29d9ab5f65d40ccc63", "patch": "@@ -3476,11 +3476,10 @@ class pass_dwarf2_frame : public rtl_opt_pass\n bool\n pass_dwarf2_frame::gate (function *)\n {\n-#ifndef HAVE_prologue\n   /* Targets which still implement the prologue in assembler text\n      cannot use the generic dwarf2 unwinding.  */\n-  return false;\n-#endif\n+  if (!targetm.have_prologue ())\n+    return false;\n \n   /* ??? What to do for UI_TARGET unwinding?  They might be able to benefit\n      from the optimized shrink-wrapping annotations that we will compute."}, {"sha": "fe2d6adb3badc739227e4cc5c53bc45c2393d042", "filename": "gcc/final.c", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e86a994681b0cad81ea13d29d9ab5f65d40ccc63/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e86a994681b0cad81ea13d29d9ab5f65d40ccc63/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=e86a994681b0cad81ea13d29d9ab5f65d40ccc63", "patch": "@@ -1803,12 +1803,8 @@ final_start_function (rtx_insn *first, FILE *file,\n      if the profiling code comes after the prologue.  */\n   if (targetm.profile_before_prologue () && crtl->profile)\n     {\n-      if (targetm.asm_out.function_prologue\n-\t  == default_function_pro_epilogue\n-#ifdef HAVE_prologue\n-\t  && HAVE_prologue\n-#endif\n-\t )\n+      if (targetm.asm_out.function_prologue == default_function_pro_epilogue\n+\t  && targetm.have_prologue ())\n \t{\n \t  rtx_insn *insn;\n \t  for (insn = first; insn; insn = NEXT_INSN (insn))\n@@ -1864,9 +1860,7 @@ final_start_function (rtx_insn *first, FILE *file,\n \n   /* If the machine represents the prologue as RTL, the profiling code must\n      be emitted when NOTE_INSN_PROLOGUE_END is scanned.  */\n-#ifdef HAVE_prologue\n-  if (! HAVE_prologue)\n-#endif\n+  if (! targetm.have_prologue ())\n     profile_after_prologue (file);\n }\n "}, {"sha": "8134c4e7067d6c356a11340d90cb5c0fa7a75d9a", "filename": "gcc/function.c", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e86a994681b0cad81ea13d29d9ab5f65d40ccc63/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e86a994681b0cad81ea13d29d9ab5f65d40ccc63/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=e86a994681b0cad81ea13d29d9ab5f65d40ccc63", "patch": "@@ -5864,11 +5864,10 @@ thread_prologue_and_epilogue_insns (void)\n     }\n \n   prologue_seq = NULL;\n-#ifdef HAVE_prologue\n-  if (HAVE_prologue)\n+  if (targetm.have_prologue ())\n     {\n       start_sequence ();\n-      rtx_insn *seq = safe_as_a <rtx_insn *> (gen_prologue ());\n+      rtx_insn *seq = targetm.gen_prologue ();\n       emit_insn (seq);\n \n       /* Insert an explicit USE for the frame pointer\n@@ -5890,7 +5889,6 @@ thread_prologue_and_epilogue_insns (void)\n       end_sequence ();\n       set_insn_locations (prologue_seq, prologue_location);\n     }\n-#endif\n \n   bitmap_initialize (&bb_flags, &bitmap_default_obstack);\n \n@@ -5995,11 +5993,11 @@ thread_prologue_and_epilogue_insns (void)\n   if (exit_fallthru_edge == NULL)\n     goto epilogue_done;\n \n-  if (HAVE_epilogue)\n+  if (targetm.have_epilogue ())\n     {\n       start_sequence ();\n       epilogue_end = emit_note (NOTE_INSN_EPILOGUE_BEG);\n-      rtx_insn *seq = as_a <rtx_insn *> (gen_epilogue ());\n+      rtx_insn *seq = targetm.gen_epilogue ();\n       if (seq)\n \temit_jump_insn (seq);\n \n@@ -6070,15 +6068,13 @@ thread_prologue_and_epilogue_insns (void)\n     convert_to_simple_return (entry_edge, orig_entry_edge, bb_flags,\n \t\t\t      returnjump, unconverted_simple_returns);\n \n-#ifdef HAVE_sibcall_epilogue\n   /* Emit sibling epilogues before any sibling call sites.  */\n   for (ei = ei_start (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds); (e =\n \t\t\t\t\t\t\t     ei_safe_edge (ei));\n \t\t\t\t\t\t\t     )\n     {\n       basic_block bb = e->src;\n       rtx_insn *insn = BB_END (bb);\n-      rtx ep_seq;\n \n       if (!CALL_P (insn)\n \t  || ! SIBLING_CALL_P (insn)\n@@ -6090,8 +6086,7 @@ thread_prologue_and_epilogue_insns (void)\n \t  continue;\n \t}\n \n-      ep_seq = gen_sibcall_epilogue ();\n-      if (ep_seq)\n+      if (rtx_insn *ep_seq = targetm.gen_sibcall_epilogue ())\n \t{\n \t  start_sequence ();\n \t  emit_note (NOTE_INSN_EPILOGUE_BEG);\n@@ -6109,7 +6104,6 @@ thread_prologue_and_epilogue_insns (void)\n \t}\n       ei_next (&ei);\n     }\n-#endif\n \n   if (epilogue_end)\n     {\n@@ -6143,10 +6137,10 @@ thread_prologue_and_epilogue_insns (void)\n void\n reposition_prologue_and_epilogue_notes (void)\n {\n-#if ! defined (HAVE_prologue) && ! defined (HAVE_sibcall_epilogue)\n-  if (!HAVE_epilogue)\n+  if (!targetm.have_prologue ()\n+      && !targetm.have_epilogue ()\n+      && !targetm.have_sibcall_epilogue ())\n     return;\n-#endif\n \n   /* Since the hash table is created on demand, the fact that it is\n      non-null is a signal that it is non-empty.  */"}, {"sha": "6de8a544df55971c37ddbd49b1c012b3e9716e11", "filename": "gcc/reorg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e86a994681b0cad81ea13d29d9ab5f65d40ccc63/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e86a994681b0cad81ea13d29d9ab5f65d40ccc63/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=e86a994681b0cad81ea13d29d9ab5f65d40ccc63", "patch": "@@ -473,7 +473,7 @@ find_end_label (rtx kind)\n \t}\n       else\n \t{\n-\t  if (HAVE_epilogue && ! targetm.have_return ())\n+\t  if (targetm.have_epilogue () && ! targetm.have_return ())\n \t    /* The RETURN insn has its delay slot filled so we cannot\n \t       emit the label just before it.  Since we already have\n \t       an epilogue and cannot emit a new RETURN, we cannot"}, {"sha": "8fa81ded8520970f87c50364e85d6bdc4c6b8916", "filename": "gcc/target-insns.def", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e86a994681b0cad81ea13d29d9ab5f65d40ccc63/gcc%2Ftarget-insns.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e86a994681b0cad81ea13d29d9ab5f65d40ccc63/gcc%2Ftarget-insns.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-insns.def?ref=e86a994681b0cad81ea13d29d9ab5f65d40ccc63", "patch": "@@ -30,6 +30,9 @@\n    Patterns that take no operands should have a prototype \"(void)\".\n \n    Instructions should be documented in md.texi rather than here.  */\n+DEF_TARGET_INSN (canonicalize_funcptr_for_compare, (rtx x0, rtx x1))\n+DEF_TARGET_INSN (epilogue, (void))\n+DEF_TARGET_INSN (prologue, (void))\n DEF_TARGET_INSN (return, (void))\n+DEF_TARGET_INSN (sibcall_epilogue, (void))\n DEF_TARGET_INSN (simple_return, (void))\n-DEF_TARGET_INSN (canonicalize_funcptr_for_compare, (rtx x0, rtx x1))"}, {"sha": "1fc5bd92d83a582c8b9b0282ced74318892b5717", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e86a994681b0cad81ea13d29d9ab5f65d40ccc63/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e86a994681b0cad81ea13d29d9ab5f65d40ccc63/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=e86a994681b0cad81ea13d29d9ab5f65d40ccc63", "patch": "@@ -112,10 +112,6 @@ along with GCC; see the file COPYING3.  If not see\n \t\t\t\t   declarations for e.g. AIX 4.x.  */\n #endif\n \n-#ifndef HAVE_prologue\n-#define HAVE_prologue 0\n-#endif\n-\n #include <new>\n \n static void general_init (const char *, bool);\n@@ -1660,7 +1656,7 @@ process_options (void)\n \n  /* Do not use IPA optimizations for register allocation if profiler is active\n     or port does not emit prologue and epilogue as RTL.  */\n-  if (profile_flag || !HAVE_prologue || !HAVE_epilogue)\n+  if (profile_flag || !targetm.have_prologue () || !targetm.have_epilogue ())\n     flag_ipa_ra = 0;\n \n   /* Enable -Werror=coverage-mismatch when -Werror and -Wno-error"}]}