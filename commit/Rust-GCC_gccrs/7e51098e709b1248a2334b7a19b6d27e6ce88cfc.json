{"sha": "7e51098e709b1248a2334b7a19b6d27e6ce88cfc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2U1MTA5OGU3MDliMTI0OGEyMzM0YjdhMTliNmQyN2U2Y2U4OGNmYw==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "2000-10-03T20:19:54Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-10-03T20:19:54Z"}, "message": "re GNATS gcj/307 (gcj allows boolean value to be returned for int method)\n\n\tFix for PR gcj/307:\n\t* parse.y (patch_binop): Use JNUMERIC_TYPE_P, not\n\tJPRIMITIVE_TYPE_P, for arithmetic operators.\n\t(patch_method_invocation): Indentation fix.\n\t(try_builtin_assignconv): Handle boolean specially.  Fixed typo.\n\t(valid_builtin_assignconv_identity_widening_p): Handle boolean.\n\t(do_unary_numeric_promotion): Cleaned up code.\n\t(valid_cast_to_p): Handle boolean correctly.\n\nFrom-SVN: r36704", "tree": {"sha": "6b741d3fd10ee8c1dae974a5dcb52f3ec31acad2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b741d3fd10ee8c1dae974a5dcb52f3ec31acad2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e51098e709b1248a2334b7a19b6d27e6ce88cfc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e51098e709b1248a2334b7a19b6d27e6ce88cfc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e51098e709b1248a2334b7a19b6d27e6ce88cfc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e51098e709b1248a2334b7a19b6d27e6ce88cfc/comments", "author": null, "committer": null, "parents": [{"sha": "5beededc7ee5e8fa0cc8ba552efc748d47a16f59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5beededc7ee5e8fa0cc8ba552efc748d47a16f59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5beededc7ee5e8fa0cc8ba552efc748d47a16f59"}], "stats": {"total": 70, "additions": 45, "deletions": 25}, "files": [{"sha": "94b6a787ba625abfe46977fa639de6b1384bf1fc", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e51098e709b1248a2334b7a19b6d27e6ce88cfc/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e51098e709b1248a2334b7a19b6d27e6ce88cfc/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=7e51098e709b1248a2334b7a19b6d27e6ce88cfc", "patch": "@@ -1,3 +1,14 @@\n+2000-09-07  Tom Tromey  <tromey@cygnus.com>\n+\n+\tFix for PR gcj/307:\n+\t* parse.y (patch_binop): Use JNUMERIC_TYPE_P, not\n+\tJPRIMITIVE_TYPE_P, for arithmetic operators.\n+\t(patch_method_invocation): Indentation fix.\n+\t(try_builtin_assignconv): Handle boolean specially.  Fixed typo.\n+\t(valid_builtin_assignconv_identity_widening_p): Handle boolean.\n+\t(do_unary_numeric_promotion): Cleaned up code.\n+\t(valid_cast_to_p): Handle boolean correctly.\n+\n 2000-09-27  Tom Tromey  <tromey@cygnus.com>\n \n \t* lex.c (java_read_unicode): Reset bs_count when finished with"}, {"sha": "6ae90d44a2f6e8cf3951c4895313bdb234568c45", "filename": "gcc/java/parse.y", "status": "modified", "additions": 33, "deletions": 24, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e51098e709b1248a2334b7a19b6d27e6ce88cfc/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e51098e709b1248a2334b7a19b6d27e6ce88cfc/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=7e51098e709b1248a2334b7a19b6d27e6ce88cfc", "patch": "@@ -9710,13 +9710,13 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl)\n       \n       if (JPRIMITIVE_TYPE_P (type))\n         {\n-        parse_error_context\n-          (identifier_wfl,\n-          \"Can't invoke a method on primitive type `%s'\",\n-          IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type))));\n-        PATCH_METHOD_RETURN_ERROR ();         \n-      }      \n-      \n+\t  parse_error_context\n+\t    (identifier_wfl,\n+\t     \"Can't invoke a method on primitive type `%s'\",\n+\t     IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type))));\n+\t  PATCH_METHOD_RETURN_ERROR ();         \n+\t}\n+\n       list = lookup_method_invoke (0, identifier_wfl, type, identifier, args);\n       args = nreverse (args);\n \n@@ -12242,8 +12242,17 @@ try_builtin_assignconv (wfl_op1, lhs_type, rhs)\n   tree new_rhs = NULL_TREE;\n   tree rhs_type = TREE_TYPE (rhs);\n \n+  /* Handle boolean specially.  */\n+  if (TREE_CODE (rhs_type) == BOOLEAN_TYPE\n+      || TREE_CODE (lhs_type) == BOOLEAN_TYPE)\n+    {\n+      if (TREE_CODE (rhs_type) == BOOLEAN_TYPE\n+\t  && TREE_CODE (lhs_type) == BOOLEAN_TYPE)\n+\tnew_rhs = rhs;\n+    }\n+\n   /* Zero accepted everywhere */\n-  if (TREE_CODE (rhs) == INTEGER_CST \n+  else if (TREE_CODE (rhs) == INTEGER_CST \n       && TREE_INT_CST_HIGH (rhs) == 0 && TREE_INT_CST_LOW (rhs) == 0\n       && JPRIMITIVE_TYPE_P (rhs_type))\n     new_rhs = convert (lhs_type, rhs);\n@@ -12266,7 +12275,7 @@ try_builtin_assignconv (wfl_op1, lhs_type, rhs)\n         new_rhs = convert (lhs_type, rhs);\n       else if (wfl_op1)\t\t/* Might be called with a NULL */\n \tparse_warning_context \n-\t  (wfl_op1, \"Constant expression `%s' to wide for narrowing primitive conversion to `%s'\", \n+\t  (wfl_op1, \"Constant expression `%s' too wide for narrowing primitive conversion to `%s'\", \n \t   print_int_node (rhs), lang_printable_name (lhs_type, 0));\n       /* Reported a warning that will turn into an error further\n \t down, so we don't return */\n@@ -12288,8 +12297,8 @@ valid_builtin_assignconv_identity_widening_p (lhs_type, rhs_type)\n   if (lhs_type == rhs_type)\n     return 1;\n \n-  /* Reject non primitive types */\n-  if (!JPRIMITIVE_TYPE_P (lhs_type) || !JPRIMITIVE_TYPE_P (rhs_type))\n+  /* Reject non primitive types and boolean conversions.  */\n+  if (!JNUMERIC_TYPE_P (lhs_type) || !JNUMERIC_TYPE_P (rhs_type))\n     return 0;\n \n   /* 5.1.2: widening primitive conversion. byte, even if it's smaller\n@@ -12458,20 +12467,20 @@ valid_cast_to_p (source, dest)\n   else if (JNUMERIC_TYPE_P (source) && JNUMERIC_TYPE_P (dest))\n     return 1;\n \n+  else if (TREE_CODE (source) == BOOLEAN_TYPE\n+\t   && TREE_CODE (dest) == BOOLEAN_TYPE)\n+    return 1;\n+\n   return 0;\n }\n \n-/* Method invocation conversion test. Return 1 if type SOURCE can be\n-   converted to type DEST through the methond invocation conversion\n-   process (5.3) */\n-\n static tree\n do_unary_numeric_promotion (arg)\n      tree arg;\n {\n   tree type = TREE_TYPE (arg);\n-  if (TREE_CODE (type) == INTEGER_TYPE ? TYPE_PRECISION (type) < 32\n-      : TREE_CODE (type) == CHAR_TYPE)\n+  if ((TREE_CODE (type) == INTEGER_TYPE && TYPE_PRECISION (type) < 32)\n+      || TREE_CODE (type) == CHAR_TYPE)\n     arg = convert (int_type_node, arg);\n   return arg;\n }\n@@ -12666,11 +12675,11 @@ patch_binop (node, wfl_op1, wfl_op2)\n     case RDIV_EXPR:\t\t/* 15.16.2 Division Operator / */\n     case TRUNC_DIV_EXPR:\t/* 15.16.2 Integral type Division Operator / */\n     case TRUNC_MOD_EXPR:\t/* 15.16.3 Remainder operator % */\n-      if (!JPRIMITIVE_TYPE_P (op1_type) || !JPRIMITIVE_TYPE_P (op2_type))\n+      if (!JNUMERIC_TYPE_P (op1_type) || !JNUMERIC_TYPE_P (op2_type))\n \t{\n-\t  if (!JPRIMITIVE_TYPE_P (op1_type))\n+\t  if (!JNUMERIC_TYPE_P (op1_type))\n \t    ERROR_CANT_CONVERT_TO_NUMERIC (wfl_operator, node, op1_type);\n-\t  if (!JPRIMITIVE_TYPE_P (op2_type) && (op1_type != op2_type))\n+\t  if (!JNUMERIC_TYPE_P (op2_type) && (op1_type != op2_type))\n \t    ERROR_CANT_CONVERT_TO_NUMERIC (wfl_operator, node, op2_type);\n \t  TREE_TYPE (node) = error_mark_node;\n \t  error_found = 1;\n@@ -12718,11 +12727,11 @@ patch_binop (node, wfl_op1, wfl_op2)\n \n     case MINUS_EXPR:\t\t/* 15.17.2 Additive Operators (+ and -) for\n \t\t\t\t   Numeric Types */\n-      if (!JPRIMITIVE_TYPE_P (op1_type) || !JPRIMITIVE_TYPE_P (op2_type))\n+      if (!JNUMERIC_TYPE_P (op1_type) || !JNUMERIC_TYPE_P (op2_type))\n \t{\n-\t  if (!JPRIMITIVE_TYPE_P (op1_type))\n+\t  if (!JNUMERIC_TYPE_P (op1_type))\n \t    ERROR_CANT_CONVERT_TO_NUMERIC (wfl_operator, node, op1_type);\n-\t  if (!JPRIMITIVE_TYPE_P (op2_type) && (op1_type != op2_type))\n+\t  if (!JNUMERIC_TYPE_P (op2_type) && (op1_type != op2_type))\n \t    ERROR_CANT_CONVERT_TO_NUMERIC (wfl_operator, node, op2_type);\n \t  TREE_TYPE (node) = error_mark_node;\n \t  error_found = 1;\n@@ -12741,7 +12750,7 @@ patch_binop (node, wfl_op1, wfl_op2)\n \t    ERROR_CAST_NEEDED_TO_INTEGRAL (wfl_operator, node, op1_type);\n \t  else\n \t    {\n-\t      if (JPRIMITIVE_TYPE_P (op2_type))\n+\t      if (JNUMERIC_TYPE_P (op2_type))\n \t\tparse_error_context (wfl_operator,\n \t\t\t\t     \"Incompatible type for `%s'. Explicit cast needed to convert shift distance from `%s' to integral\",\n \t\t\t\t     operator_string (node),"}, {"sha": "0b406a7a545954f29a2732666ff0c4d03c6e0eeb", "filename": "gcc/java/typeck.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e51098e709b1248a2334b7a19b6d27e6ce88cfc/gcc%2Fjava%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e51098e709b1248a2334b7a19b6d27e6ce88cfc/gcc%2Fjava%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Ftypeck.c?ref=7e51098e709b1248a2334b7a19b6d27e6ce88cfc", "patch": "@@ -875,7 +875,7 @@ lookup_java_constructor (clas, method_signature)\n \n /* Return a type which is the Binary Numeric Promotion of the pair T1,\n    T2 and convert EXP1 and/or EXP2. See 5.6.2 Binary Numeric\n-   Promotion. It assumes that both T1 and T2 are elligible to BNP. */\n+   Promotion. It assumes that both T1 and T2 are eligible to BNP. */\n \n tree\n binary_numeric_promotion (t1, t2, exp1, exp2)"}]}