{"sha": "7151ffbe56dd95cbd05e4e5c418468d30dc33c2f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzE1MWZmYmU1NmRkOTVjYmQwNWU0ZTVjNDE4NDY4ZDMwZGMzM2MyZg==", "commit": {"author": {"name": "George Helffrich", "email": "george@gcc.gnu.org", "date": "2008-04-01T21:23:36Z"}, "committer": {"name": "George Helffrich", "email": "george@gcc.gnu.org", "date": "2008-04-01T21:23:36Z"}, "message": "trans-common.c (create_common): Add decl to function chain to preserve identifier scope in debug output.\n\n\t* fortran/trans-common.c (create_common):  Add decl to function\n\tchain to preserve identifier scope in debug output.\n\n\t* dbxout.c: Emit .stabs debug info for Fortran COMMON block\n\tvariables as base symbol name + offset using N_BCOMM/N_ECOMM.\n\t(is_fortran, dbxout_common_name, dbxout_common_check): New functions.\n\t(dbxout_symbol_location): Transform N_LCSYM to N_GSYM for storage\n\tin common.\n\t(dbxout_syms): Check for COMMON-based symbol and wrap in\n\tN_BCOMM/N_ECOMM stab bracket, including as many symbols as possible\n\tin bracket for efficiency.\n\n\t* dwarf2out.c: Emit DWARF debug info for Fortran COMMON block\n\tusing DW_TAG_common_block + member offset.\n\t(add_pubname_string): New function.\n\t(dw_expand_expr): New function to find block name and offset for\n\tCOMMON var.\n\t(common_check): New function to check whether symbol in Fortran COMMON.\n\t(gen_variable_die): If COMMON, use DW_TAG_common_block.\n\n\t* testsuite/gcc.dg/debug/pr35154.c:  New test to check that non-Fortran\n\tuse of common is unchanged.\n\n\t* testsuite/lib/gfortran-dg.exp:  New harness to compile Fortran progs\n\twith all combinations of debug options available on target.\n\t* testsuite/gfortran.dg/debug/debug.exp:  Ditto.\n\t* testsuite/gfortran.dg/debug/trivial.f:  Ditto.\n\t* testsuite/gfortran.dg/debug/pr35154-stabs.f:  New test case for\n\t.stabs functionality.\n\t* testsuite/gfortran.dg/debug/pr35154-dwarf2.f:  New test case for\n\tDWARF functionality.\n\nFrom-SVN: r133801", "tree": {"sha": "803082c66137124abad95c71d051d7b2b08a3878", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/803082c66137124abad95c71d051d7b2b08a3878"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7151ffbe56dd95cbd05e4e5c418468d30dc33c2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7151ffbe56dd95cbd05e4e5c418468d30dc33c2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7151ffbe56dd95cbd05e4e5c418468d30dc33c2f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7151ffbe56dd95cbd05e4e5c418468d30dc33c2f/comments", "author": null, "committer": null, "parents": [{"sha": "dc197ab91c79219326ebc83e7353ac4f925e78e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc197ab91c79219326ebc83e7353ac4f925e78e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc197ab91c79219326ebc83e7353ac4f925e78e5"}], "stats": {"total": 668, "additions": 650, "deletions": 18}, "files": [{"sha": "2ef5a6c33de06307f42fe5d8e5a74769682bde7c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7151ffbe56dd95cbd05e4e5c418468d30dc33c2f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7151ffbe56dd95cbd05e4e5c418468d30dc33c2f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7151ffbe56dd95cbd05e4e5c418468d30dc33c2f", "patch": "@@ -1,3 +1,38 @@\n+2008-04-01  George Helffrich  <george@gcc.gnu.org>\n+\n+\tPR fortran/PR35154, fortran/PR23057\n+\t* fortran/trans-common.c (create_common):  Add decl to function\n+\tchain to preserve identifier scope in debug output.\n+\n+\t* dbxout.c: Emit .stabs debug info for Fortran COMMON block\n+\tvariables as base symbol name + offset using N_BCOMM/N_ECOMM.\n+\t(is_fortran, dbxout_common_name, dbxout_common_check): New functions.\n+\t(dbxout_symbol_location): Transform N_LCSYM to N_GSYM for storage\n+\tin common.\n+\t(dbxout_syms): Check for COMMON-based symbol and wrap in\n+\tN_BCOMM/N_ECOMM stab bracket, including as many symbols as possible\n+\tin bracket for efficiency.\n+\n+\t* dwarf2out.c: Emit DWARF debug info for Fortran COMMON block\n+\tusing DW_TAG_common_block + member offset.\n+\t(add_pubname_string): New function.\n+\t(dw_expand_expr): New function to find block name and offset for\n+\tCOMMON var.\n+\t(common_check): New function to check whether symbol in Fortran COMMON.\n+\t(gen_variable_die): If COMMON, use DW_TAG_common_block.\n+\n+\t* testsuite/gcc.dg/debug/pr35154.c:  New test to check that non-Fortran\n+\tuse of common is unchanged.\n+\n+\t* testsuite/lib/gfortran-dg.exp:  New harness to compile Fortran progs\n+\twith all combinations of debug options available on target.\n+\t* testsuite/gfortran.dg/debug/debug.exp:  Ditto.\n+\t* testsuite/gfortran.dg/debug/trivial.f:  Ditto.\n+\t* testsuite/gfortran.dg/debug/pr35154-stabs.f:  New test case for\n+\t.stabs functionality.\n+\t* testsuite/gfortran.dg/debug/pr35154-dwarf2.f:  New test case for\n+\tDWARF functionality.\n+\n 2008-04-01  Volker Reichelt  <v.reichelt@netcologne.de>\n \n \tPR c/35436"}, {"sha": "acf20b2ab905a8e251c566c48dc20a635b29a601", "filename": "gcc/dbxout.c", "status": "modified", "additions": 175, "deletions": 3, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7151ffbe56dd95cbd05e4e5c418468d30dc33c2f/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7151ffbe56dd95cbd05e4e5c418468d30dc33c2f/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=7151ffbe56dd95cbd05e4e5c418468d30dc33c2f", "patch": "@@ -1,6 +1,6 @@\n /* Output dbx-format symbol table information from GNU compiler.\n    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -322,10 +322,13 @@ static void dbxout_type_methods (tree);\n static void dbxout_range_type (tree);\n static void dbxout_type (tree, int);\n static bool print_int_cst_bounds_in_octal_p (tree);\n+static bool is_fortran (void);\n static void dbxout_type_name (tree);\n static void dbxout_class_name_qualifiers (tree);\n static int dbxout_symbol_location (tree, tree, const char *, rtx);\n static void dbxout_symbol_name (tree, const char *, int);\n+static void dbxout_common_name (tree, const char *, STAB_CODE_TYPE);\n+static const char *dbxout_common_check (tree, int *);\n static void dbxout_global_decl (tree);\n static void dbxout_type_decl (tree, int);\n static void dbxout_handle_pch (unsigned);\n@@ -973,6 +976,14 @@ get_lang_number (void)\n \n }\n \n+static bool\n+is_fortran (void)\n+{\n+   unsigned int lang = get_lang_number ();\n+\n+   return (lang == N_SO_FORTRAN) || (lang == N_SO_FORTRAN90);\n+}\n+\n /* At the beginning of compilation, start writing the symbol table.\n    Initialize `typevec' and output the standard data types of C.  */\n \n@@ -2868,8 +2879,15 @@ dbxout_symbol_location (tree decl, tree type, const char *suffix, rtx home)\n     {\n       if (TREE_PUBLIC (decl))\n \t{\n+\t  int offs;\n \t  letter = 'G';\n \t  code = N_GSYM;\n+\t  if (NULL != dbxout_common_check (decl, &offs))\n+\t    {\n+\t      letter = 'V';\n+\t      addr = 0;\n+\t      number = offs;\n+\t    }\n \t}\n       else\n \t{\n@@ -2915,7 +2933,17 @@ dbxout_symbol_location (tree decl, tree type, const char *suffix, rtx home)\n \t  if (DECL_INITIAL (decl) == 0\n \t      || (!strcmp (lang_hooks.name, \"GNU C++\")\n \t\t  && DECL_INITIAL (decl) == error_mark_node))\n-\t    code = N_LCSYM;\n+\t    {\n+\t      int offs;\n+\t      code = N_LCSYM;\n+\t      if (NULL != dbxout_common_check (decl, &offs))\n+\t        {\n+\t\t  addr = 0;\n+\t\t  number = offs;\n+\t\t  letter = 'V';\n+\t\t  code = N_GSYM;\n+\t\t}\n+\t    }\n \t  else if (DECL_IN_TEXT_SECTION (decl))\n \t    /* This is not quite right, but it's the closest\n \t       of all the codes that Unix defines.  */\n@@ -3004,9 +3032,17 @@ dbxout_symbol_location (tree decl, tree type, const char *suffix, rtx home)\n \t variable, thereby avoiding the need for a register.  In such\n \t cases we're forced to lie to debuggers and tell them that\n \t this variable was itself `static'.  */\n+      int offs;\n       code = N_LCSYM;\n       letter = 'V';\n-      addr = XEXP (XEXP (home, 0), 0);\n+      if (NULL == dbxout_common_check (decl, &offs))\n+        addr = XEXP (XEXP (home, 0), 0);\n+      else\n+        {\n+\t  addr = 0;\n+\t  number = offs;\n+\t  code = N_GSYM;\n+\t}\n     }\n   else if (GET_CODE (home) == CONCAT)\n     {\n@@ -3091,18 +3127,154 @@ dbxout_symbol_name (tree decl, const char *suffix, int letter)\n     stabstr_C (letter);\n }\n \n+\n+/* Output the common block name for DECL in a stabs.\n+\n+   Symbols in global common (.comm) get wrapped with an N_BCOMM/N_ECOMM pair\n+   around each group of symbols in the same .comm area.  The N_GSYM stabs\n+   that are emitted only contain the offset in the common area.  This routine\n+   emits the N_BCOMM and N_ECOMM stabs.  */\n+\n+static void\n+dbxout_common_name (tree decl, const char *name, STAB_CODE_TYPE op)\n+{\n+  dbxout_begin_complex_stabs ();\n+  stabstr_S (name);\n+  dbxout_finish_complex_stabs (decl, op, NULL_RTX, NULL, 0);\n+}\n+\n+/* Check decl to determine whether it is a VAR_DECL destined for storage in a\n+   common area.  If it is, the return value will be a non-null string giving\n+   the name of the common storage block it will go into.  If non-null, the\n+   value is the offset into the common block for that symbol's storage.  */\n+\n+static const char *\n+dbxout_common_check (tree decl, int *value)\n+{\n+  rtx home;\n+  rtx sym_addr;\n+  const char *name = NULL;\n+  \n+  /* If the decl isn't a VAR_DECL, or if it isn't public or static, or if\n+     it does not have a value (the offset into the common area), or if it\n+     is thread local (as opposed to global) then it isn't common, and shouldn't\n+     be handled as such.\n+     \n+     ??? DECL_THREAD_LOCAL_P check prevents problems with improper .stabs\n+     for thread-local symbols.  Can be handled via same mechanism as used\n+     in dwarf2out.c.  */\n+  if (TREE_CODE (decl) != VAR_DECL\n+      || !TREE_PUBLIC(decl)\n+      || !TREE_STATIC(decl)\n+      || !DECL_HAS_VALUE_EXPR_P(decl)\n+      || DECL_THREAD_LOCAL_P (decl)\n+      || !is_fortran ())\n+    return NULL;\n+\n+  home = DECL_RTL (decl); \n+  if (home == NULL_RTX || GET_CODE (home) != MEM)\n+    return NULL;\n+\n+  sym_addr = dbxout_expand_expr (DECL_VALUE_EXPR (decl));\n+  if (sym_addr == NULL_RTX || GET_CODE (sym_addr) != MEM)\n+    return NULL;\n+\n+  sym_addr = XEXP (sym_addr, 0);\n+  if (GET_CODE (sym_addr) == CONST)\n+    sym_addr = XEXP (sym_addr, 0);\n+  if ((GET_CODE (sym_addr) == SYMBOL_REF || GET_CODE (sym_addr) == PLUS)\n+      && DECL_INITIAL (decl) == 0)\n+    {\n+\n+      /* We have a sym that will go into a common area, meaning that it\n+         will get storage reserved with a .comm/.lcomm assembler pseudo-op.\n+\n+         Determine name of common area this symbol will be an offset into,\n+         and offset into that area.  Also retrieve the decl for the area\n+         that the symbol is offset into.  */\n+      tree cdecl = NULL;\n+\n+      switch (GET_CODE (sym_addr))\n+        {\n+        case PLUS:\n+          if (GET_CODE (XEXP (sym_addr, 0)) == CONST_INT)\n+            {\n+              name =\n+                targetm.strip_name_encoding(XSTR (XEXP (sym_addr, 1), 0));\n+              *value = INTVAL (XEXP (sym_addr, 0));\n+              cdecl = SYMBOL_REF_DECL (XEXP (sym_addr, 1));\n+            }\n+          else\n+            {\n+              name =\n+                targetm.strip_name_encoding(XSTR (XEXP (sym_addr, 0), 0));\n+              *value = INTVAL (XEXP (sym_addr, 1));\n+              cdecl = SYMBOL_REF_DECL (XEXP (sym_addr, 0));\n+            }\n+          break;\n+\n+        case SYMBOL_REF:\n+          name = targetm.strip_name_encoding(XSTR (sym_addr, 0));\n+          *value = 0;\n+          cdecl = SYMBOL_REF_DECL (sym_addr);\n+          break;\n+\n+        default:\n+          error (\"common symbol debug info is not structured as \"\n+                 \"symbol+offset\");\n+        }\n+\n+      /* Check area common symbol is offset into.  If this is not public, then\n+         it is not a symbol in a common block.  It must be a .lcomm symbol, not\n+         a .comm symbol.  */\n+      if (cdecl == NULL || !TREE_PUBLIC(cdecl))\n+        name = NULL;\n+    }\n+  else\n+    name = NULL;\n+\n+  return name;\n+}\n+\n /* Output definitions of all the decls in a chain. Return nonzero if\n    anything was output */\n \n int\n dbxout_syms (tree syms)\n {\n   int result = 0;\n+  const char *comm_prev = NULL;\n+  tree syms_prev = NULL;\n+\n   while (syms)\n     {\n+      int temp, copen, cclos;\n+      const char *comm_new;\n+\n+      /* Check for common symbol, and then progression into a new/different\n+         block of common symbols.  Emit closing/opening common bracket if\n+         necessary.  */\n+      comm_new = dbxout_common_check (syms, &temp);\n+      copen = comm_new != NULL\n+              && (comm_prev == NULL || strcmp (comm_new, comm_prev));\n+      cclos = comm_prev != NULL\n+              && (comm_new == NULL || strcmp (comm_new, comm_prev));\n+      if (cclos)\n+        dbxout_common_name (syms_prev, comm_prev, N_ECOMM);\n+      if (copen)\n+        {\n+          dbxout_common_name (syms, comm_new, N_BCOMM);\n+          syms_prev = syms;\n+        }\n+      comm_prev = comm_new;\n+\n       result += dbxout_symbol (syms, 1);\n       syms = TREE_CHAIN (syms);\n     }\n+\n+  if (comm_prev != NULL)\n+    dbxout_common_name (syms_prev, comm_prev, N_ECOMM);\n+\n   return result;\n }\n \f"}, {"sha": "1d99699286b54b9cf0346a3147a78a4efa0647b9", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 215, "deletions": 10, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7151ffbe56dd95cbd05e4e5c418468d30dc33c2f/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7151ffbe56dd95cbd05e4e5c418468d30dc33c2f/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=7151ffbe56dd95cbd05e4e5c418468d30dc33c2f", "patch": "@@ -4251,6 +4251,7 @@ static void output_compilation_unit_header (void);\n static void output_comp_unit (dw_die_ref, int);\n static const char *dwarf2_name (tree, int);\n static void add_pubname (tree, dw_die_ref);\n+static void add_pubname_string (const char *, dw_die_ref);\n static void add_pubtype (tree, dw_die_ref);\n static void output_pubnames (VEC (pubname_entry,gc) *);\n static void add_arange (tree, dw_die_ref);\n@@ -7481,18 +7482,23 @@ dwarf2_name (tree decl, int scope)\n /* Add a new entry to .debug_pubnames if appropriate.  */\n \n static void\n-add_pubname (tree decl, dw_die_ref die)\n+add_pubname_string (const char *str, dw_die_ref die)\n {\n   pubname_entry e;\n \n-  if (! TREE_PUBLIC (decl))\n-    return;\n-\n   e.die = die;\n-  e.name = xstrdup (dwarf2_name (decl, 1));\n+  e.name = xstrdup (str);\n   VEC_safe_push (pubname_entry, gc, pubname_table, &e);\n }\n \n+static void\n+add_pubname (tree decl, dw_die_ref die)\n+{\n+\n+  if (TREE_PUBLIC (decl))\n+    add_pubname_string (dwarf2_name (decl, 1), die);\n+}\n+\n /* Add a new entry to .debug_pubtypes if appropriate.  */\n \n static void\n@@ -10504,6 +10510,63 @@ rtl_for_decl_init (tree init, tree type)\n   return rtl;\n }\n \n+/* This is a specialized subset of expand_expr to evaluate a DECL_VALUE_EXPR.\n+   We stop if we find decls that haven't been expanded, or if the expression is\n+   getting so complex we won't be able to represent it anyway.  Returns NULL on\n+   failure.  */\n+\n+static rtx\n+dw_expand_expr (tree expr)\n+{\n+  switch (TREE_CODE (expr))\n+  {\n+  case VAR_DECL:\n+  case PARM_DECL:\n+    if (DECL_HAS_VALUE_EXPR_P (expr))\n+      return dw_expand_expr (DECL_VALUE_EXPR (expr));\n+    /* FALLTHRU */\n+ \n+  case CONST_DECL:\n+  case RESULT_DECL:\n+    return DECL_RTL_IF_SET (expr);\n+ \n+  case INTEGER_CST:\n+    return expand_expr (expr, NULL_RTX, VOIDmode, EXPAND_INITIALIZER);\n+\n+  case COMPONENT_REF:\n+  case ARRAY_REF:\n+  case ARRAY_RANGE_REF:\n+  case BIT_FIELD_REF:\n+  {\n+    enum machine_mode mode;\n+    HOST_WIDE_INT bitsize, bitpos;\n+    tree offset, tem;\n+    int volatilep = 0, unsignedp = 0;\n+    rtx x;\n+\n+    tem = get_inner_reference (expr, &bitsize, &bitpos, &offset,\n+                               &mode, &unsignedp, &volatilep, true);\n+ \n+    x = dw_expand_expr (tem);\n+    if (x == NULL || !MEM_P (x))\n+       return NULL;\n+    if (offset != NULL)\n+      {\n+        if (!host_integerp (offset, 0))\n+          return NULL;\n+        x = adjust_address_nv (x, mode, tree_low_cst (offset, 0));\n+      }\n+    if (bitpos != 0)\n+      x = adjust_address_nv (x, mode, bitpos / BITS_PER_UNIT);\n+\n+    return x;\n+  }\n+ \n+  default:\n+    return NULL;\n+  }\n+}\n+\n /* Generate RTL for the variable DECL to represent its location.  */\n \n static rtx\n@@ -10736,6 +10799,93 @@ secname_for_decl (const_tree decl)\n   return secname;\n }\n \n+/* Check whether decl is a Fortran COMMON symbol.  If not, NULL_RTX is returned.\n+   If so, the rtx for the SYMBOL_REF for the COMMON block is returned, and the\n+   value is the offset into the common block for the symbol.  */\n+\n+static rtx\n+common_check (tree decl, HOST_WIDE_INT *value)\n+{\n+  rtx home;\n+  rtx sym_addr;\n+  rtx res = NULL_RTX;\n+ \n+  /* If the decl isn't a VAR_DECL, or if it isn't public or static, or if\n+     it does not have a value (the offset into the common area), or if it\n+     is thread local (as opposed to global) then it isn't common, and shouldn't\n+     be handled as such.  */\n+  if (TREE_CODE (decl) != VAR_DECL\n+      || !TREE_PUBLIC(decl)\n+      || !TREE_STATIC(decl)\n+      || !DECL_HAS_VALUE_EXPR_P(decl)\n+      || DECL_THREAD_LOCAL_P (decl)\n+      || !is_fortran())\n+    return NULL;\n+\n+  home = DECL_RTL (decl);\n+  if (home == NULL_RTX || GET_CODE (home) != MEM)\n+    return NULL;\n+\n+  sym_addr = dw_expand_expr (DECL_VALUE_EXPR (decl));\n+  if (sym_addr == NULL_RTX || GET_CODE (sym_addr) != MEM)\n+    return NULL;\n+\n+  sym_addr = XEXP (sym_addr, 0);\n+  if (GET_CODE (sym_addr) == CONST)\n+    sym_addr = XEXP (sym_addr, 0);\n+  if ((GET_CODE (sym_addr) == SYMBOL_REF || GET_CODE (sym_addr) == PLUS)\n+      && DECL_INITIAL (decl) == 0)\n+    {\n+ \n+      /* We have a sym that will go into a common area, meaning that it\n+         will get storage reserved with a .comm/.lcomm assembler pseudo-op.\n+\n+         Determine name of common area this symbol will be an offset into,\n+         and offset into that area.  Also retrieve the decl for the area\n+         that the symbol is offset into.  */\n+      tree cdecl = NULL;\n+\n+      switch (GET_CODE (sym_addr))\n+        {\n+        case PLUS:\n+          if (GET_CODE (XEXP (sym_addr, 0)) == CONST_INT)\n+            {\n+              res = XEXP (sym_addr, 1);\n+              *value = INTVAL (XEXP (sym_addr, 0));\n+              cdecl = SYMBOL_REF_DECL (XEXP (sym_addr, 1));\n+            }\n+          else\n+            {\n+              res = XEXP (sym_addr, 0);\n+              *value = INTVAL (XEXP (sym_addr, 1));\n+              cdecl = SYMBOL_REF_DECL (XEXP (sym_addr, 0));\n+             }\n+          break;\n+\n+        case SYMBOL_REF:\n+          res = sym_addr;\n+          *value = 0;\n+          cdecl = SYMBOL_REF_DECL (sym_addr);\n+          break;\n+\n+        default:\n+          error (\"common symbol debug info is not structured as \"\n+                 \"symbol+offset\");\n+        }\n+\n+      /* Check area common symbol is offset into.  If this is not public, then\n+         it is not a symbol in a common block.  It must be a .lcomm symbol, not\n+         a .comm symbol.  */\n+      if (cdecl == NULL || !TREE_PUBLIC(cdecl))\n+        res = NULL_RTX;\n+    }\n+  else\n+    res = NULL_RTX;\n+\n+  return res;\n+}\n+\n+\n /* Generate *either* a DW_AT_location attribute or else a DW_AT_const_value\n    data attribute for a variable or a parameter.  We generate the\n    DW_AT_const_value attribute only in those cases where the given variable\n@@ -12633,9 +12783,10 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n static void\n gen_variable_die (tree decl, dw_die_ref context_die)\n {\n+  HOST_WIDE_INT off;\n+  rtx csym;\n+  dw_die_ref var_die;\n   tree origin = decl_ultimate_origin (decl);\n-  dw_die_ref var_die = new_die (DW_TAG_variable, context_die, decl);\n-\n   dw_die_ref old_die = lookup_decl_die (decl);\n   int declaration = (DECL_EXTERNAL (decl)\n \t\t     /* If DECL is COMDAT and has not actually been\n@@ -12659,6 +12810,37 @@ gen_variable_die (tree decl, dw_die_ref context_die)\n \t\t\t && DECL_COMDAT (decl) && !TREE_ASM_WRITTEN (decl))\n \t\t     || class_or_namespace_scope_p (context_die));\n \n+  csym = common_check (decl, &off);\n+\n+  /* Symbol in common gets emitted as a child of the common block, in the form\n+     of a data member.\n+\n+     ??? This creates a new common block die for every common block symbol.\n+     Better to share same common block die for all symbols in that block.  */\n+  if (csym)\n+    {\n+      tree blok;\n+      dw_die_ref com_die;\n+      const char *cnam = targetm.strip_name_encoding(XSTR (csym, 0));\n+      dw_loc_descr_ref loc = mem_loc_descriptor (csym, dw_val_class_addr,\n+                                                 VAR_INIT_STATUS_INITIALIZED);\n+\n+      blok = (tree) TREE_OPERAND (DECL_VALUE_EXPR (decl), 0);\n+      var_die = new_die (DW_TAG_common_block, context_die, decl);\n+      add_name_and_src_coords_attributes (var_die, blok);\n+      add_AT_flag (var_die, DW_AT_external, 1);\n+      add_AT_loc (var_die, DW_AT_location, loc);\n+      com_die = new_die (DW_TAG_member, var_die, decl);\n+      add_name_and_src_coords_attributes (com_die, decl);\n+      add_type_attribute (com_die, TREE_TYPE (decl), TREE_READONLY (decl),\n+      TREE_THIS_VOLATILE (decl), context_die);\n+      add_AT_loc (com_die, DW_AT_data_member_location, int_loc_descriptor(off));\n+      add_pubname_string (cnam, var_die); /* ??? needed? */\n+      return;\n+    }\n+\n+  var_die = new_die (DW_TAG_variable, context_die, decl);\n+\n   if (origin != NULL)\n     add_abstract_origin_attribute (var_die, origin);\n \n@@ -13634,8 +13816,13 @@ decls_for_scope (tree stmt, dw_die_ref context_die, int depth)\n \t    add_child_die (context_die, die);\n \t  /* Do not produce debug information for static variables since\n \t     these might be optimized out.  We are called for these later\n-\t     in varpool_analyze_pending_decls. */\n-\t  if (TREE_CODE (decl) == VAR_DECL && TREE_STATIC (decl))\n+\t     in varpool_analyze_pending_decls.\n+\n+\t     But *do* produce it for Fortran COMMON variables because,\n+\t     even though they are static, their names can differ depending\n+\t     on the scope, which we need to preserve.  */\n+\t  if (TREE_CODE (decl) == VAR_DECL && TREE_STATIC (decl)\n+\t      && !(is_fortran () && TREE_PUBLIC (decl)))\n \t    ;\n \t  else\n \t    gen_decl_die (decl, context_die);\n@@ -13963,6 +14150,16 @@ gen_decl_die (tree decl, dw_die_ref context_die)\n       if (debug_info_level <= DINFO_LEVEL_TERSE)\n \tbreak;\n \n+      /* If this is the global definition of the Fortran COMMON block, we don't\n+         need to do anything.  Syntactically, the block itself has no identity,\n+         just its constituent identifiers.  */\n+      if (TREE_CODE (decl) == VAR_DECL\n+          && TREE_PUBLIC (decl)\n+          && TREE_STATIC (decl)\n+          && is_fortran ()\n+          && !DECL_HAS_VALUE_EXPR_P (decl))\n+        break;\n+\n       /* Output any DIEs that are needed to specify the type of this data\n \t object.  */\n       if (TREE_CODE (decl) == RESULT_DECL && DECL_BY_REFERENCE (decl))\n@@ -14029,7 +14226,15 @@ dwarf2out_global_decl (tree decl)\n   /* Output DWARF2 information for file-scope tentative data object\n      declarations, file-scope (extern) function declarations (which had no\n      corresponding body) and file-scope tagged type declarations and\n-     definitions which have not yet been forced out.  */\n+     definitions which have not yet been forced out.\n+\n+     Ignore the global decl of any Fortran COMMON blocks which also wind up here\n+     though they have already been described in the local scope for the \n+     procedures using them.  */\n+  if (TREE_CODE (decl) == VAR_DECL\n+      && TREE_PUBLIC (decl) && TREE_STATIC (decl) && is_fortran ())\n+    return;\n+\n   if (TREE_CODE (decl) != FUNCTION_DECL || !DECL_INITIAL (decl))\n     dwarf2out_decl (decl);\n }"}, {"sha": "9fb19c41572de8b61cab41af251bcc6e960da716", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7151ffbe56dd95cbd05e4e5c418468d30dc33c2f/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7151ffbe56dd95cbd05e4e5c418468d30dc33c2f/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=7151ffbe56dd95cbd05e4e5c418468d30dc33c2f", "patch": "@@ -1,3 +1,8 @@\n+2008-04-01  George Helffrich <george@gcc.gnu.org>\n+\n+\t* trans-common.c (create_common):  Add decl to function\n+\tchain to preserve identifier scope in debug output.\n+\n 2008-04-01  Joseph Myers  <joseph@codesourcery.com>\n \n \t* gfortran.texi: Include gpl_v3.texi instead of gpl.texi"}, {"sha": "f7042cb29d6e05d55259067722f0266fbf8d8159", "filename": "gcc/fortran/trans-common.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7151ffbe56dd95cbd05e4e5c418468d30dc33c2f/gcc%2Ffortran%2Ftrans-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7151ffbe56dd95cbd05e4e5c418468d30dc33c2f/gcc%2Ffortran%2Ftrans-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-common.c?ref=7151ffbe56dd95cbd05e4e5c418468d30dc33c2f", "patch": "@@ -687,10 +687,7 @@ create_common (gfc_common_head *com, segment_info *head, bool saw_equiv)\n       /* This is a fake variable just for debugging purposes.  */\n       TREE_ASM_WRITTEN (var_decl) = 1;\n \n-      if (com)\n-\tvar_decl = pushdecl_top_level (var_decl);\n-      else\n-\tgfc_add_decl_to_function (var_decl);\n+      gfc_add_decl_to_function (var_decl);\n \n       SET_DECL_VALUE_EXPR (var_decl,\n \t\t\t   fold_build3 (COMPONENT_REF, TREE_TYPE (s->field),"}, {"sha": "476e05c3fdb85de686540ec6530edb3f305bd5c4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7151ffbe56dd95cbd05e4e5c418468d30dc33c2f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7151ffbe56dd95cbd05e4e5c418468d30dc33c2f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7151ffbe56dd95cbd05e4e5c418468d30dc33c2f", "patch": "@@ -1,3 +1,18 @@\n+2008-04-01  George Helffrich  <george@gcc.gnu.org>\n+\n+\tPRs fortran/PR35154, fortran/PR23057\n+\t* gcc.dg/debug/pr35154.c:  New test to check that non-Fortran\n+\tuse of common is unchanged.\n+\n+\t* lib/gfortran-dg.exp:  New harness to compile Fortran progs\n+\twith all combinations of debug options available on target.\n+        * gfortran.dg/debug/debug.exp:  Ditto.\n+        * gfortran.dg/debug/trivial.f:  Ditto.\n+        * gfortran.dg/debug/pr35154-stabs.f:  New test case for\n+        .stabs functionality.\n+        * gfortran.dg/debug/pr35154-dwarf2.f:  New test case for\n+        DWARF functionality.\n+\n 2008-04-01  Volker Reichelt  <v.reichelt@netcologne.de>\n \n \tPR c/35436"}, {"sha": "fcb79256b00581a4795a7f29ce0b7e14fedca01a", "filename": "gcc/testsuite/gcc.dg/debug/pr35154.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7151ffbe56dd95cbd05e4e5c418468d30dc33c2f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fpr35154.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7151ffbe56dd95cbd05e4e5c418468d30dc33c2f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fpr35154.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fpr35154.c?ref=7151ffbe56dd95cbd05e4e5c418468d30dc33c2f", "patch": "@@ -0,0 +1,34 @@\n+/* Test to make sure that stabs for C symbols that go into .comm have the\n+   proper structure.  These should be lettered G for the struct that gives\n+   the name to the .comm, and should be V or S for .lcomm symbols.  */\n+\n+static char i_outer;\n+struct {\n+   char f1;\n+   char f2;\n+} opta;\n+struct {\n+   char f1;\n+   char f2;\n+} optb;\n+\n+int\n+main()\n+{\n+   static char i_inner[2];\n+   i_inner[0] = 'a'; i_inner[1] = 'b';\n+   opta.f1 = 'c';\n+   opta.f2 = 'd';\n+   optb.f1 = 'C';\n+   optb.f2 = 'D';\n+   i_outer = 'e';\n+/* { dg-do compile } */\n+/* { dg-skip-if \"No stabs\" { mmix-*-* *-*-netware* alpha*-*-* hppa*64*-*-* ia64-*-* *-*-sysv5* *-*-vxworks* } { \"*\" } { \"\" } } */\n+/* { dg-skip-if \"stabs only\" { *-*-* } { \"*\" } { \"-gstabs\" } } */\n+   return 0;\n+}\n+\n+/* { dg-final { scan-assembler \".stabs.*i_inner:V\" } } */\n+/* { dg-final { scan-assembler \".stabs.*i_outer:S\" } } */\n+/* { dg-final { scan-assembler \".stabs.*opta:G\" } } */\n+/* { dg-final { scan-assembler \".stabs.*optb:G\" } } */"}, {"sha": "0e0b4b91d01840009513995e5ab43d04523a72ac", "filename": "gcc/testsuite/gfortran.dg/debug/debug.exp", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7151ffbe56dd95cbd05e4e5c418468d30dc33c2f/gcc%2Ftestsuite%2Fgfortran.dg%2Fdebug%2Fdebug.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7151ffbe56dd95cbd05e4e5c418468d30dc33c2f/gcc%2Ftestsuite%2Fgfortran.dg%2Fdebug%2Fdebug.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdebug%2Fdebug.exp?ref=7151ffbe56dd95cbd05e4e5c418468d30dc33c2f", "patch": "@@ -0,0 +1,41 @@\n+#  Copyright (C) 2008 Free Software Foundation, Inc.\n+\n+#  This file is part of GCC.\n+#\n+#  GCC is free software; you can redistribute it and/or modify it under\n+#  the terms of the GNU General Public License as published by the Free\n+#  Software Foundation; either version 3, or (at your option) any later\n+#  version.\n+#\n+#  GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+#  WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+#  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+#  for more details.\n+#\n+#  You should have received a copy of the GNU General Public License\n+#  along with GCC; see the file COPYING3.  If not see\n+#  <http://www.gnu.org/licenses/>.\n+\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+# Load support procs.\n+load_lib gfortran-dg.exp\n+load_lib gfortran.exp\n+\n+# Debugging testsuite proc\n+proc gfortran-debug-dg-test { prog do_what extra_tool_flags } {\n+   return [gfortran-dg-test $prog $do_what $extra_tool_flags]\n+}\n+\n+# Initialize `dg'.\n+dg-init\n+\n+# Main loop.\n+\n+gfortran_init\n+\n+gfortran-dg-debug-runtest gfortran_target_compile trivial.f \"\" \\\n+    [lsort [glob -nocomplain $srcdir/$subdir/*.\\[fS\\]]]\n+\n+# All done.\n+dg-finish"}, {"sha": "0203d134a629981187f49e616c0ececd5451f3ec", "filename": "gcc/testsuite/gfortran.dg/debug/pr35154-dwarf2.f", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7151ffbe56dd95cbd05e4e5c418468d30dc33c2f/gcc%2Ftestsuite%2Fgfortran.dg%2Fdebug%2Fpr35154-dwarf2.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7151ffbe56dd95cbd05e4e5c418468d30dc33c2f/gcc%2Ftestsuite%2Fgfortran.dg%2Fdebug%2Fpr35154-dwarf2.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdebug%2Fpr35154-dwarf2.f?ref=7151ffbe56dd95cbd05e4e5c418468d30dc33c2f", "patch": "@@ -0,0 +1,37 @@\n+C     Test program for common block debugging.  G. Helffrich 11 July 2004.\n+C { dg-do compile }\n+C { dg-skip-if \"DWARF-2 only\" { \"*-*-*\" } { \"*\" } { \"-gdwarf-2\" } }\n+C { dg-options \"-dA\" }\n+      common i,j\n+      common /label/l,m\n+      i = 1\n+      j = 2\n+      k = 3\n+      l = 4\n+      m = 5\n+      call sub\n+      end\n+      subroutine sub\n+      common /label/l,m\n+      logical first\n+      save n\n+      data first /.true./\n+      if (first) then\n+         n = 0\n+\t first = .false.\n+      endif\n+      n = n + 1\n+      l = l + 1\n+      return\n+      end\n+\n+C { dg-final { scan-assembler \"(DIE.*DW_TAG_common_block)\" } }\n+C { dg-final { scan-assembler \"DW_AT_name: \\\"__BLNK__\\\"\" } }\n+C { dg-final { scan-assembler \"(DIE.*DW_TAG_member)\" } }\n+C { dg-final { scan-assembler \"\\\"i.*\\\".*DW_AT_name\" } }\n+C { dg-final { scan-assembler \"\\\"j.*\\\".*DW_AT_name\" } }\n+C { dg-final { scan-assembler \"(DIE.*DW_TAG_common_block)\" } }\n+C { dg-final { scan-assembler \"DW_AT_name: \\\"label\\\"\" } }\n+C { dg-final { scan-assembler \"(DIE.*DW_TAG_member)\" } }\n+C { dg-final { scan-assembler \"\\\"l.*\\\".*DW_AT_name\" } }\n+C { dg-final { scan-assembler \"\\\"m.*\\\".*DW_AT_name\" } }"}, {"sha": "7294771bd3ecde3be1c18780c537a34b6cfda732", "filename": "gcc/testsuite/gfortran.dg/debug/pr35154-stabs.f", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7151ffbe56dd95cbd05e4e5c418468d30dc33c2f/gcc%2Ftestsuite%2Fgfortran.dg%2Fdebug%2Fpr35154-stabs.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7151ffbe56dd95cbd05e4e5c418468d30dc33c2f/gcc%2Ftestsuite%2Fgfortran.dg%2Fdebug%2Fpr35154-stabs.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdebug%2Fpr35154-stabs.f?ref=7151ffbe56dd95cbd05e4e5c418468d30dc33c2f", "patch": "@@ -0,0 +1,35 @@\n+C     Test program for common block debugging.  G. Helffrich 11 July 2004.\n+C { dg-do compile }\n+C { dg-skip-if \"No stabs\" { mmix-*-* *-*-netware* alpha*-*-* hppa*64*-*-* ia64-*-* *-*-sysv5* *-*-vxworks* } { \"*\" } { \"\" } }\n+C { dg-skip-if \"No stabs\" {*-*-* } { \"*\" } { \"-gstabs\" } }\n+      common i,j\n+      common /label/l,m\n+      i = 1\n+      j = 2\n+      k = 3\n+      l = 4\n+      m = 5\n+      call sub\n+      end\n+      subroutine sub\n+      common /label/l,m\n+      logical first\n+      save n\n+      data first /.true./\n+      if (first) then\n+         n = 0\n+\t first = .false.\n+      endif\n+      n = n + 1\n+      l = l + 1\n+      return\n+      end\n+\n+C { dg-final { scan-assembler \".stabs.*\\\"__BLNK__\\\",226\" } }\n+C { dg-final { scan-assembler \".stabs.*\\\"i:V.*\\\",.*,0\" } }\n+C { dg-final { scan-assembler \".stabs.*\\\"j:V.*\\\",.*,4\" } }\n+C { dg-final { scan-assembler \".stabs.*\\\"__BLNK__\\\",228\" } }\n+C { dg-final { scan-assembler \".stabs.*\\\"label_\\\",226\" } }\n+C { dg-final { scan-assembler \".stabs.*\\\"l:V.*\\\",.*,0\" } }\n+C { dg-final { scan-assembler \".stabs.*\\\"m:V.*\\\",.*,4\" } }\n+C { dg-final { scan-assembler \".stabs.*\\\"label_\\\",228\" } }"}, {"sha": "4c3556725a21d4753193abe832069aa5e6e5fcf7", "filename": "gcc/testsuite/gfortran.dg/debug/trivial.f", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7151ffbe56dd95cbd05e4e5c418468d30dc33c2f/gcc%2Ftestsuite%2Fgfortran.dg%2Fdebug%2Ftrivial.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7151ffbe56dd95cbd05e4e5c418468d30dc33c2f/gcc%2Ftestsuite%2Fgfortran.dg%2Fdebug%2Ftrivial.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdebug%2Ftrivial.f?ref=7151ffbe56dd95cbd05e4e5c418468d30dc33c2f", "patch": "@@ -0,0 +1,2 @@\n+      program trivial\n+      end"}, {"sha": "401651c2b79de8afd6e55b1079a91c2297cf2f2b", "filename": "gcc/testsuite/lib/gfortran-dg.exp", "status": "modified", "additions": 55, "deletions": 1, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7151ffbe56dd95cbd05e4e5c418468d30dc33c2f/gcc%2Ftestsuite%2Flib%2Fgfortran-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7151ffbe56dd95cbd05e4e5c418468d30dc33c2f/gcc%2Ftestsuite%2Flib%2Fgfortran-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fgfortran-dg.exp?ref=7151ffbe56dd95cbd05e4e5c418468d30dc33c2f", "patch": "@@ -1,4 +1,4 @@\n-#   Copyright (C) 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n+#   Copyright (C) 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n \n # This program is free software; you can redistribute it and/or modify\n # it under the terms of the GNU General Public License as published by\n@@ -107,3 +107,57 @@ proc gfortran-dg-runtest { testcases default-extra-flags } {\n \t}\n     }\n }\n+\n+proc gfortran-dg-debug-runtest { target_compile trivial opt_opts testcases } {\n+    global srcdir subdir DEBUG_TORTURE_OPTIONS\n+\n+    if ![info exists DEBUG_TORTURE_OPTIONS] {\n+       set DEBUG_TORTURE_OPTIONS \"\"\n+       set type_list [list \"-gstabs\" \"-gstabs+\" \"-gxcoff\" \"-gxcoff+\" \"-gcoff\" \"-gdwarf-2\" ]\n+       foreach type $type_list {\n+           set comp_output [$target_compile \\\n+                   \"$srcdir/$subdir/$trivial\" \"trivial.S\" assembly \\\n+                   \"additional_flags=$type\"]\n+           if { [string match \"exit status *\" $comp_output] } {\n+               continue\n+           }\n+           if { [string match \\\n+                       \"* target system does not support the * debug format*\" \\\n+                       $comp_output]\n+           } {\n+               continue\n+           }\n+           foreach level {1 \"\" 3} {\n+               lappend DEBUG_TORTURE_OPTIONS [list \"${type}${level}\"]\n+               foreach opt $opt_opts {\n+                   lappend DEBUG_TORTURE_OPTIONS [list \"${type}${level}\" \\\n+                      \"$opt\" ]\n+               }\n+           }\n+       }\n+    }\n+\n+    verbose -log \"Using options $DEBUG_TORTURE_OPTIONS\"\n+\n+    global runtests\n+\n+    foreach test $testcases {\n+       # If we're only testing specific files and this isn't one of \n+       # them, skip it.\n+       if ![runtest_file_p $runtests $test] {\n+           continue\n+       }\n+\n+       set nshort [file tail [file dirname $test]]/[file tail $test]\n+\n+       foreach flags $DEBUG_TORTURE_OPTIONS {\n+           set doit 1\n+           # gcc-specific checking removed here\n+\n+           if { $doit } {\n+               verbose -log \"Testing $nshort, $flags\" 1\n+               dg-test $test $flags \"\"\n+           }\n+       }\n+    }\n+}"}]}