{"sha": "ab08859e37ef822c839bc33ec097091f17ebfe76", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWIwODg1OWUzN2VmODIyYzgzOWJjMzNlYzA5NzA5MWYxN2ViZmU3Ng==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2021-07-14T09:13:23Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2021-09-16T11:54:56Z"}, "message": "coroutines: Small cleanups to await_statement_walker [NFC].\n\nThere is no need to make a MODIFY_EXPR for any of the condition\nvars that we synthesize.\n\nExpansion of co_return can be carried out independently of any\nco_awaits that might be contained which simplifies this.\n\nWhere we are rewriting statements to handle await expression\nlogic, there is no need to carry out any analysis - we just need\nto detect the presence of any co_await.\n\nSigned-off-by: Iain Sandoe <iain@sandoe.co.uk>\n\ngcc/cp/ChangeLog:\n\n\t* coroutines.cc (await_statement_walker): Code cleanups.", "tree": {"sha": "25ae009dc06609738960c5507a1714f9adf67b85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/25ae009dc06609738960c5507a1714f9adf67b85"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab08859e37ef822c839bc33ec097091f17ebfe76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab08859e37ef822c839bc33ec097091f17ebfe76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab08859e37ef822c839bc33ec097091f17ebfe76", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab08859e37ef822c839bc33ec097091f17ebfe76/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d6b12b2233dabf3573383a15ccc67fdb925e5b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d6b12b2233dabf3573383a15ccc67fdb925e5b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d6b12b2233dabf3573383a15ccc67fdb925e5b3"}], "stats": {"total": 125, "additions": 59, "deletions": 66}, "files": [{"sha": "fbd5c49533f0147f0ec9c96760f84f31e178f512", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 59, "deletions": 66, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab08859e37ef822c839bc33ec097091f17ebfe76/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab08859e37ef822c839bc33ec097091f17ebfe76/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=ab08859e37ef822c839bc33ec097091f17ebfe76", "patch": "@@ -3412,16 +3412,11 @@ await_statement_walker (tree *stmt, int *do_subtree, void *d)\n       return NULL_TREE;\n     }\n \n-  /* We have something to be handled as a single statement.  */\n-  bool has_cleanup_wrapper = TREE_CODE (*stmt) == CLEANUP_POINT_EXPR;\n-  hash_set<tree> visited;\n-  awpts->saw_awaits = 0;\n-  hash_set<tree> truth_aoif_to_expand;\n-  awpts->truth_aoif_to_expand = &truth_aoif_to_expand;\n-  awpts->needs_truth_if_exp = false;\n-  awpts->has_awaiter_init = false;\n+  /* We have something to be handled as a single statement.  We have to handle\n+     a few statements specially where await statements have to be moved out of\n+     constructs.  */\n   tree expr = *stmt;\n-  if (has_cleanup_wrapper)\n+  if (TREE_CODE (*stmt) == CLEANUP_POINT_EXPR)\n     expr = TREE_OPERAND (expr, 0);\n   STRIP_NOPS (expr);\n \n@@ -3437,17 +3432,17 @@ await_statement_walker (tree *stmt, int *do_subtree, void *d)\n \t   transforms can be implemented.  */\n \tcase IF_STMT:\n \t  {\n+\t    tree *await_ptr;\n+\t    hash_set<tree> visited;\n \t    /* Transform 'if (cond with awaits) then stmt1 else stmt2' into\n \t       bool cond = cond with awaits.\n \t       if (cond) then stmt1 else stmt2.  */\n \t    tree if_stmt = *stmt;\n \t    /* We treat the condition as if it was a stand-alone statement,\n \t       to see if there are any await expressions which will be analyzed\n \t       and registered.  */\n-\t    if ((res = cp_walk_tree (&IF_COND (if_stmt),\n-\t\tanalyze_expression_awaits, d, &visited)))\n-\t      return res;\n-\t    if (!awpts->saw_awaits)\n+\t    if (!(cp_walk_tree (&IF_COND (if_stmt),\n+\t\t  find_any_await, &await_ptr, &visited)))\n \t      return NULL_TREE; /* Nothing special to do here.  */\n \n \t    gcc_checking_assert (!awpts->bind_stack->is_empty());\n@@ -3463,7 +3458,7 @@ await_statement_walker (tree *stmt, int *do_subtree, void *d)\n \t    /* We want to initialize the new variable with the expression\n \t       that contains the await(s) and potentially also needs to\n \t       have truth_if expressions expanded.  */\n-\t    tree new_s = build2_loc (sloc, MODIFY_EXPR, boolean_type_node,\n+\t    tree new_s = build2_loc (sloc, INIT_EXPR, boolean_type_node,\n \t\t\t\t     newvar, cond_inner);\n \t    finish_expr_stmt (new_s);\n \t    IF_COND (if_stmt) = newvar;\n@@ -3477,25 +3472,27 @@ await_statement_walker (tree *stmt, int *do_subtree, void *d)\n \t  break;\n \tcase FOR_STMT:\n \t  {\n+\t    tree *await_ptr;\n+\t    hash_set<tree> visited;\n \t    /* for loops only need special treatment if the condition or the\n \t       iteration expression contain a co_await.  */\n \t    tree for_stmt = *stmt;\n-\t    /* Sanity check.  */\n-\t    if ((res = cp_walk_tree (&FOR_INIT_STMT (for_stmt),\n-\t\tanalyze_expression_awaits, d, &visited)))\n-\t      return res;\n-\t    gcc_checking_assert (!awpts->saw_awaits);\n-\n-\t    if ((res = cp_walk_tree (&FOR_COND (for_stmt),\n-\t\tanalyze_expression_awaits, d, &visited)))\n-\t      return res;\n-\t    bool for_cond_await = awpts->saw_awaits != 0;\n-\t    unsigned save_awaits = awpts->saw_awaits;\n-\n-\t    if ((res = cp_walk_tree (&FOR_EXPR (for_stmt),\n-\t\tanalyze_expression_awaits, d, &visited)))\n-\t      return res;\n-\t    bool for_expr_await = awpts->saw_awaits > save_awaits;\n+\t    /* At present, the FE always generates a separate initializer for\n+\t       the FOR_INIT_STMT, when the expression has an await.  Check that\n+\t       this assumption holds in the future. */\n+\t    gcc_checking_assert\n+\t      (!(cp_walk_tree (&FOR_INIT_STMT (for_stmt), find_any_await,\n+\t\t\t       &await_ptr, &visited)));\n+\n+\t    visited.empty ();\n+\t    bool for_cond_await\n+\t      = cp_walk_tree (&FOR_COND (for_stmt), find_any_await,\n+\t\t\t      &await_ptr, &visited);\n+\n+\t    visited.empty ();\n+\t    bool for_expr_await\n+\t      = cp_walk_tree (&FOR_EXPR (for_stmt), find_any_await,\n+\t\t\t      &await_ptr, &visited);\n \n \t    /* If the condition has an await, then we will need to rewrite the\n \t       loop as\n@@ -3538,7 +3535,12 @@ await_statement_walker (tree *stmt, int *do_subtree, void *d)\n \t\t  = create_named_label_with_ctx (sloc, buf, NULL_TREE);\n \t\tfree (buf);\n \t\tadd_stmt (build_stmt (sloc, LABEL_EXPR, it_expr_label));\n-\t\tadd_stmt (FOR_EXPR (for_stmt));\n+\t\ttree for_expr = FOR_EXPR (for_stmt);\n+\t\t/* Present the iteration expression as a statement.  */\n+\t\tif (TREE_CODE (for_expr) == CLEANUP_POINT_EXPR)\n+\t\t  for_expr = TREE_OPERAND (for_expr, 0);\n+\t\tSTRIP_NOPS (for_expr);\n+\t\tfinish_expr_stmt (for_expr);\n \t\tFOR_EXPR (for_stmt) = NULL_TREE;\n \t\tFOR_BODY (for_stmt) = pop_stmt_list (insert_list);\n \t\t/* rewrite continue statements to goto label.  */\n@@ -3565,11 +3567,11 @@ await_statement_walker (tree *stmt, int *do_subtree, void *d)\n \t\t    break;\n \t\t  stmt..\n \t\t} */\n+\t    tree *await_ptr;\n+\t    hash_set<tree> visited;\n \t    tree while_stmt = *stmt;\n-\t    if ((res = cp_walk_tree (&WHILE_COND (while_stmt),\n-\t\tanalyze_expression_awaits, d, &visited)))\n-\t      return res;\n-\t    if (!awpts->saw_awaits)\n+\t    if (!(cp_walk_tree (&WHILE_COND (while_stmt),\n+\t\t  find_any_await, &await_ptr, &visited)))\n \t      return NULL_TREE; /* Nothing special to do here.  */\n \n \t    tree insert_list = push_stmt_list ();\n@@ -3595,10 +3597,10 @@ await_statement_walker (tree *stmt, int *do_subtree, void *d)\n \t\t    break;\n \t       } while (true); */\n \t    tree do_stmt = *stmt;\n-\t    if ((res = cp_walk_tree (&DO_COND (do_stmt),\n-\t\tanalyze_expression_awaits, d, &visited)))\n-\t      return res;\n-\t    if (!awpts->saw_awaits)\n+\t    tree *await_ptr;\n+\t    hash_set<tree> visited;\n+\t    if (!(cp_walk_tree (&DO_COND (do_stmt),\n+\t\t  find_any_await, &await_ptr, &visited)))\n \t      return NULL_TREE; /* Nothing special to do here.  */\n \n \t    tree insert_list = push_stmt_list ();\n@@ -3621,10 +3623,10 @@ await_statement_walker (tree *stmt, int *do_subtree, void *d)\n \t       switch_type cond = cond with awaits\n \t       switch (cond) stmt.  */\n \t    tree sw_stmt = *stmt;\n-\t    if ((res = cp_walk_tree (&SWITCH_STMT_COND (sw_stmt),\n-\t\tanalyze_expression_awaits, d, &visited)))\n-\t      return res;\n-\t    if (!awpts->saw_awaits)\n+\t    tree *await_ptr;\n+\t    hash_set<tree> visited;\n+\t    if (!(cp_walk_tree (&SWITCH_STMT_COND (sw_stmt),\n+\t\t  find_any_await, &await_ptr, &visited)))\n \t      return NULL_TREE; /* Nothing special to do here.  */\n \n \t    gcc_checking_assert (!awpts->bind_stack->is_empty());\n@@ -3665,49 +3667,40 @@ await_statement_walker (tree *stmt, int *do_subtree, void *d)\n \t\t{ expr; p.return_void(); goto final_suspend;}\n \t       - for co_return [non void expr];\n \t\t{ p.return_value(expr); goto final_suspend; }  */\n-\t    if ((res = cp_walk_tree (stmt, analyze_expression_awaits,\n-\t\t d, &visited)))\n-\t      return res;\n \t    location_t loc = EXPR_LOCATION (expr);\n \t    tree call = TREE_OPERAND (expr, 1);\n \t    expr = TREE_OPERAND (expr, 0);\n \t    tree ret_list = push_stmt_list ();\n \t    /* [stmt.return.coroutine], 2.2\n \t       If expr is present and void, it is placed immediately before\n \t       the call for return_void;  */\n-\t    tree *maybe_await_stmt = NULL;\n \t    if (expr && VOID_TYPE_P (TREE_TYPE (expr)))\n-\t      {\n-\t\tfinish_expr_stmt (expr);\n-\t\t/* If the return argument was a void expression, then any\n-\t\t   awaits must be contained in that.  */\n-\t\tmaybe_await_stmt = tsi_stmt_ptr (tsi_last (ret_list));\n-\t      }\n+\t      finish_expr_stmt (expr);\n \t    /* Insert p.return_{void,value(expr)}.  */\n \t    finish_expr_stmt (call);\n-\t    /* Absent a return of a void expression, any awaits must be in\n-\t       the parameter to return_value().  */\n-\t    if (!maybe_await_stmt)\n-\t      maybe_await_stmt = tsi_stmt_ptr (tsi_last (ret_list));\n \t    TREE_USED (awpts->fs_label) = 1;\n \t    add_stmt (build_stmt (loc, GOTO_EXPR, awpts->fs_label));\n \t    *stmt = pop_stmt_list (ret_list);\n+\t    res = cp_walk_tree (stmt, await_statement_walker, d, NULL);\n \t    /* Once this is complete, we will have processed subtrees.  */\n \t    *do_subtree = 0;\n-\t    if (awpts->saw_awaits)\n-\t      {\n-\t\tgcc_checking_assert (maybe_await_stmt);\n-\t\tres = cp_walk_tree (maybe_await_stmt, await_statement_walker,\n-\t\t\t\t    d, NULL);\n-\t\tif (res)\n-\t\t  return res;\n-\t      }\n-\t    return NULL_TREE; /* Done.  */\n+\t    return res;\n \t  }\n \tbreak;\n       }\n   else if (EXPR_P (expr))\n     {\n+      hash_set<tree> visited;\n+      tree *await_ptr;\n+      if (!(cp_walk_tree (stmt, find_any_await, &await_ptr, &visited)))\n+\treturn NULL_TREE; /* Nothing special to do here.  */\n+\n+      visited.empty ();\n+      awpts->saw_awaits = 0;\n+      hash_set<tree> truth_aoif_to_expand;\n+      awpts->truth_aoif_to_expand = &truth_aoif_to_expand;\n+      awpts->needs_truth_if_exp = false;\n+      awpts->has_awaiter_init = false;\n       if ((res = cp_walk_tree (stmt, analyze_expression_awaits, d, &visited)))\n \treturn res;\n       *do_subtree = 0; /* Done subtrees.  */"}]}