{"sha": "811849c027531923175a35b52eecce0368d36a2e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODExODQ5YzAyNzUzMTkyMzE3NWEzNWI1MmVlY2NlMDM2OGQzNmEyZQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-05-21T11:53:02Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-05-21T11:53:02Z"}, "message": "re PR fortran/27613 (compile fails with \"Unclassifiable statement\" error message)\n\n2006-05-21  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/27613\n\t* primary.c (gfc_match_rvalue): Test if symbol represents a\n\tdirect recursive function reference.  Error if array valued,\n\tgo to function0 otherwise.\n\n2006-05-21  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/27613\n\t* gfortran.dg/recursive_reference_1.f90: New test.\n\nFrom-SVN: r113951", "tree": {"sha": "4171568da927dcd7eb831eb7f19bfd1b5b93c3d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4171568da927dcd7eb831eb7f19bfd1b5b93c3d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/811849c027531923175a35b52eecce0368d36a2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/811849c027531923175a35b52eecce0368d36a2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/811849c027531923175a35b52eecce0368d36a2e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/811849c027531923175a35b52eecce0368d36a2e/comments", "author": null, "committer": null, "parents": [{"sha": "13dbe6919072573e939fe5b693d2d6f052af3b12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13dbe6919072573e939fe5b693d2d6f052af3b12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13dbe6919072573e939fe5b693d2d6f052af3b12"}], "stats": {"total": 76, "additions": 73, "deletions": 3}, "files": [{"sha": "7f80e376e6732c34fe3e19e5a6dff81a199e6845", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/811849c027531923175a35b52eecce0368d36a2e/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/811849c027531923175a35b52eecce0368d36a2e/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=811849c027531923175a35b52eecce0368d36a2e", "patch": "@@ -1,3 +1,10 @@\n+2006-05-21  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/27613\n+\t* primary.c (gfc_match_rvalue): Test if symbol represents a\n+\tdirect recursive function reference.  Error if array valued,\n+\tgo to function0 otherwise.\n+\n 2006-05-21  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/25746"}, {"sha": "967bcb04364f9965628c4ffbef3b720555b98a07", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/811849c027531923175a35b52eecce0368d36a2e/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/811849c027531923175a35b52eecce0368d36a2e/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=811849c027531923175a35b52eecce0368d36a2e", "patch": "@@ -1933,6 +1933,21 @@ gfc_match_rvalue (gfc_expr ** result)\n \n   if (sym->attr.function && sym->result == sym)\n     {\n+      /* See if this is a directly recursive function call.  */\n+      gfc_gobble_whitespace ();\n+      if (sym->attr.recursive\n+\t    && gfc_peek_char () == '('\n+\t    && gfc_current_ns->proc_name == sym)\n+\t{\n+\t  if (!sym->attr.dimension)\n+\t    goto function0;\n+\n+\t  gfc_error (\"'%s' is array valued and directly recursive \"\n+\t\t     \"at %C , so the keyword RESULT must be specified \"\n+\t\t     \"in the FUNCTION statement\", sym->name);\n+\t  return MATCH_ERROR;\n+\t}\n+\t\n       if (gfc_current_ns->proc_name == sym\n \t  || (gfc_current_ns->parent != NULL\n \t      && gfc_current_ns->parent->proc_name == sym))"}, {"sha": "13713e64087d6147d7835e9e46c1e21a491a5230", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/811849c027531923175a35b52eecce0368d36a2e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/811849c027531923175a35b52eecce0368d36a2e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=811849c027531923175a35b52eecce0368d36a2e", "patch": "@@ -1,7 +1,7 @@\n-2006-05-21  Volker Reichelt  <reichelt@igpm.rwth-aachen.de>\n+2006-05-21  Paul Thomas  <pault@gcc.gnu.org>\n \n-\tPR c++/27398\n-\t* g++.dg/template/crash50.C: New test.\n+\tPR fortran/27613\n+\t* gfortran.dg/recursive_reference_1.f90: New test.\n \n 2006-05-21  Paul Thomas  <pault@gcc.gnu.org>\n "}, {"sha": "3753e1a0acd042c1f269278b0a5f4e02c1501323", "filename": "gcc/testsuite/gfortran.dg/recursive_reference_1.f90", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/811849c027531923175a35b52eecce0368d36a2e/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_reference_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/811849c027531923175a35b52eecce0368d36a2e/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_reference_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_reference_1.f90?ref=811849c027531923175a35b52eecce0368d36a2e", "patch": "@@ -0,0 +1,48 @@\n+! { dg-do compile }\n+! Tests the patch for PR27613, in which directly recursive, scalar\n+! functions were generating an \"unclassifiable statement\" error\n+! for the recursive statement(s).\n+!\n+! Based on PR testcase by Nicolas Bock  <nicolasbock@gmail.com>\n+!\n+program test\n+  if (original_stuff(1) .ne. 5) call abort ()\n+  if (scalar_stuff(-4) .ne. 10) call abort ()\n+  if (any (array_stuff((/-19,-30/)) .ne. (/25,25/))) call abort ()\n+contains\n+  recursive function original_stuff(n)\n+    integer :: original_stuff\n+    integer :: n\n+    original_stuff = 1\n+    if(n < 5) then\n+      original_stuff = original_stuff + original_stuff (n+1)\n+    endif\n+  end function original_stuff\n+\n+  recursive function scalar_stuff(n) result (tmp)\n+    integer :: tmp\n+    integer :: n\n+    tmp = 1\n+    if(n < 5) then\n+      tmp = tmp + scalar_stuff (n+1)\n+    endif\n+  end function scalar_stuff\n+\n+  recursive function array_stuff(n) result (tmp)\n+    integer :: tmp (2)\n+    integer :: n (2)\n+    tmp = 1\n+    if(maxval (n) < 5) then\n+      tmp = tmp + array_stuff (n+1)\n+    endif\n+  end function array_stuff\n+\n+  recursive function bad_stuff(n)\n+    integer :: bad_stuff (2)\n+    integer :: n(2)\n+    bad_stuff = 1\n+    if(maxval (n) < 5) then\n+      bad_stuff = bad_stuff + bad_stuff (n+1) ! { dg-error \"RESULT must be specified\" }\n+    endif\n+  end function bad_stuff\n+end program test"}]}