{"sha": "957ec0f922c129dac8847f40246dd868044be0f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTU3ZWMwZjkyMmMxMjlkYWM4ODQ3ZjQwMjQ2ZGQ4NjgwNDRiZTBmMA==", "commit": {"author": {"name": "Hans-Peter Nilsson", "email": "hp@bitrange.com", "date": "2002-07-07T17:13:14Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@gcc.gnu.org", "date": "2002-07-07T17:13:14Z"}, "message": "Emit MMIX function prologue and epilogue as rtl.\n\n\t* config/mmix/mmix.md (\"call\"): Use mmix_get_hard_reg_initial_val,\n\tnot unprototyped get_hard_reg_initial_val.\n\t(\"call_value\", \"nonlocal_goto_receiver\"): Ditto.\n\t(\"return\"): Make define_expand.  Move real insn to...\n\t(\"*expanded_return\"): New pattern.\n\t(\"prologue\", \"epilogue\"): New define_expands.\n\t* config/mmix/mmix.h (MMIX_rO_REGNUM): New macro.\n\t(struct machine_function): New member in_prologue.\n\t(FIRST_PSEUDO_REGISTER): Adjust for including rO as register.\n\t(FIXED_REGISTERS, CALL_USED_REGISTERS): Ditto.\n\t(MMIX_MMIXWARE_ABI_REG_ALLOC_ORDER): Ditto.\n\t(MMIX_GNU_ABI_REG_ALLOC_ORDER, REG_CLASS_CONTENTS): Ditto.\n\t(REGISTER_NAMES, ADDITIONAL_REGISTER_NAMES): Ditto.\n\t(LOCAL_REGNO): Define.  Adjust comment.\n\t* config/mmix/mmix.c (MMIX_CFUN_NEEDS_SAVED_EH_RETURN_ADDRESS):\n\tConsider regs_ever_live[MMIX_rJ_REGNUM], not just\n\tleaf_function_p.\n\t(MMIX_OUTPUT_REGNO): Don't translate registers while outputting\n\tthe prologue.\n\t(mmix_target_asm_function_prologue): Make static.  Just mark that\n\tthe prologue is being emitted.  Move guts to...\n\t(mmix_expand_prologue): New function.  Adjust for emitting\n\tprologue as rtl.  For sizes, use HOST_WIDE_INT only.\n\t(mmix_target_asm_function_epilogue): Make static.  Simply emit a\n\t\\n.  Move guts to...\n\t(mmix_expand_epilogue): New function.  Adjust for emitting\n\tepilogue as rtl.  For sizes, use HOST_WIDE_INT only.\n\t(mmix_target_asm_function_end_prologue): Mark that the prologue\n\thas ended.\n\t(TARGET_ASM_FUNCTION_END_PROLOGUE): Define.\n\t(mmix_conditional_register_usage): Improve comments.\n\t(mmix_local_regno): New function.\n\t(mmix_emit_sp_add, mmix_get_hard_reg_initial_val): Ditto.\n\t* config/mmix/mmix-protos.h (mmix_local_regno): Prototype.\n\t(mmix_expand_prologue, mmix_expand_epilogue): Ditto.\n\t(mmix_get_hard_reg_initial_val): Ditto.\n\nFrom-SVN: r55302", "tree": {"sha": "7360583492a7eea5f3ca793f548aa470e505136f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7360583492a7eea5f3ca793f548aa470e505136f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/957ec0f922c129dac8847f40246dd868044be0f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/957ec0f922c129dac8847f40246dd868044be0f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/957ec0f922c129dac8847f40246dd868044be0f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/957ec0f922c129dac8847f40246dd868044be0f0/comments", "author": null, "committer": null, "parents": [{"sha": "276e31ec6eadb5318f9a826f36642a324668d796", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/276e31ec6eadb5318f9a826f36642a324668d796", "html_url": "https://github.com/Rust-GCC/gccrs/commit/276e31ec6eadb5318f9a826f36642a324668d796"}], "stats": {"total": 1138, "additions": 583, "deletions": 555}, "files": [{"sha": "2a1b68300a45789208586d1cdba3c778cf2343bb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/957ec0f922c129dac8847f40246dd868044be0f0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/957ec0f922c129dac8847f40246dd868044be0f0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=957ec0f922c129dac8847f40246dd868044be0f0", "patch": "@@ -1,3 +1,43 @@\n+2002-07-07  Hans-Peter Nilsson  <hp@bitrange.com>\n+\n+\tEmit MMIX function prologue and epilogue as rtl.\n+\t* config/mmix/mmix.md (\"call\"): Use mmix_get_hard_reg_initial_val,\n+\tnot unprototyped get_hard_reg_initial_val.\n+\t(\"call_value\", \"nonlocal_goto_receiver\"): Ditto.\n+\t(\"return\"): Make define_expand.  Move real insn to...\n+\t(\"*expanded_return\"): New pattern.\n+\t(\"prologue\", \"epilogue\"): New define_expands.\n+\t* config/mmix/mmix.h (MMIX_rO_REGNUM): New macro.\n+\t(struct machine_function): New member in_prologue.\n+\t(FIRST_PSEUDO_REGISTER): Adjust for including rO as register.\n+\t(FIXED_REGISTERS, CALL_USED_REGISTERS): Ditto.\n+\t(MMIX_MMIXWARE_ABI_REG_ALLOC_ORDER): Ditto.\n+\t(MMIX_GNU_ABI_REG_ALLOC_ORDER, REG_CLASS_CONTENTS): Ditto.\n+\t(REGISTER_NAMES, ADDITIONAL_REGISTER_NAMES): Ditto.\n+\t(LOCAL_REGNO): Define.  Adjust comment.\n+\t* config/mmix/mmix.c (MMIX_CFUN_NEEDS_SAVED_EH_RETURN_ADDRESS):\n+\tConsider regs_ever_live[MMIX_rJ_REGNUM], not just\n+\tleaf_function_p.\n+\t(MMIX_OUTPUT_REGNO): Don't translate registers while outputting\n+\tthe prologue.\n+\t(mmix_target_asm_function_prologue): Make static.  Just mark that\n+\tthe prologue is being emitted.  Move guts to...\n+\t(mmix_expand_prologue): New function.  Adjust for emitting\n+\tprologue as rtl.  For sizes, use HOST_WIDE_INT only.\n+\t(mmix_target_asm_function_epilogue): Make static.  Simply emit a\n+\t\\n.  Move guts to...\n+\t(mmix_expand_epilogue): New function.  Adjust for emitting\n+\tepilogue as rtl.  For sizes, use HOST_WIDE_INT only.\n+\t(mmix_target_asm_function_end_prologue): Mark that the prologue\n+\thas ended.\n+\t(TARGET_ASM_FUNCTION_END_PROLOGUE): Define.\n+\t(mmix_conditional_register_usage): Improve comments.\n+\t(mmix_local_regno): New function.\n+\t(mmix_emit_sp_add, mmix_get_hard_reg_initial_val): Ditto.\n+\t* config/mmix/mmix-protos.h (mmix_local_regno): Prototype.\n+\t(mmix_expand_prologue, mmix_expand_epilogue): Ditto.\n+\t(mmix_get_hard_reg_initial_val): Ditto.\n+\n 2002-07-06  Andreas Jaeger  <aj@suse.de>\n \n \t* toplev.c (set_fast_math_flags): Don't use ISO C style function"}, {"sha": "f13a179e13f8f5b8f2e6f8fc97ffdd71a3c19851", "filename": "gcc/config/mmix/mmix-protos.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/957ec0f922c129dac8847f40246dd868044be0f0/gcc%2Fconfig%2Fmmix%2Fmmix-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/957ec0f922c129dac8847f40246dd868044be0f0/gcc%2Fconfig%2Fmmix%2Fmmix-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix-protos.h?ref=957ec0f922c129dac8847f40246dd868044be0f0", "patch": "@@ -57,6 +57,7 @@ extern int mmix_shiftable_wyde_value PARAMS ((unsigned HOST_WIDEST_INT));\n extern void mmix_output_register_setting\n   PARAMS ((FILE *, int, HOST_WIDEST_INT, int));\n extern void mmix_conditional_register_usage PARAMS ((void));\n+extern int mmix_local_regno PARAMS ((int));\n extern int mmix_dbx_register_number PARAMS ((int));\n \n /* Things that need rtl.h, tree.h or real.h included, or in combination.  */\n@@ -123,6 +124,9 @@ extern void mmix_print_operand_address PARAMS ((FILE *, rtx));\n extern int mmix_valid_comparison PARAMS ((RTX_CODE, enum machine_mode, rtx));\n extern rtx mmix_gen_compare_reg PARAMS ((enum rtx_code, rtx, rtx));\n extern void mmix_machine_dependent_reorg PARAMS ((rtx));\n+extern void mmix_expand_prologue PARAMS ((void));\n+extern void mmix_expand_epilogue PARAMS ((void));\n+extern rtx mmix_get_hard_reg_initial_val PARAMS ((enum machine_mode, int));\n #endif /* RTX_CODE */\n \n extern int mmix_asm_preferred_eh_data_format PARAMS ((int, int));"}, {"sha": "c3c4d985c05990ea566bf84e5ea7dcf893297b13", "filename": "gcc/config/mmix/mmix.c", "status": "modified", "additions": 491, "deletions": 535, "changes": 1026, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/957ec0f922c129dac8847f40246dd868044be0f0/gcc%2Fconfig%2Fmmix%2Fmmix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/957ec0f922c129dac8847f40246dd868044be0f0/gcc%2Fconfig%2Fmmix%2Fmmix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.c?ref=957ec0f922c129dac8847f40246dd868044be0f0", "patch": "@@ -52,9 +52,19 @@ Boston, MA 02111-1307, USA.  */\n \n /* We have no means to tell DWARF 2 about the register stack, so we need\n    to store the return address on the stack if an exception can get into\n-   this function.  FIXME: Narrow condition.  */\n-#define MMIX_CFUN_NEEDS_SAVED_EH_RETURN_ADDRESS \\\n- (flag_exceptions && ! leaf_function_p ())\n+   this function.  FIXME: Narrow condition.  Before any whole-function\n+   analysis, regs_ever_live[] isn't initialized.  We know it's up-to-date\n+   after reload_completed; it may contain incorrect information some time\n+   before that.  Within a RTL sequence (after a call to start_sequence,\n+   such as in RTL expanders), leaf_function_p doesn't see all insns\n+   (perhaps any insn).  But regs_ever_live is up-to-date when\n+   leaf_function_p () isn't, so we \"or\" them together to get accurate\n+   information.  FIXME: Some tweak to leaf_function_p might be\n+   preferrable.  */\n+#define MMIX_CFUN_NEEDS_SAVED_EH_RETURN_ADDRESS\t\t\t\\\n+ (flag_exceptions\t\t\t\t\t\t\\\n+  && ((reload_completed && regs_ever_live[MMIX_rJ_REGNUM])\t\\\n+      || !leaf_function_p ()))\n \n #define IS_MMIX_EH_RETURN_DATA_REG(REGNO)\t\\\n  (current_function_calls_eh_return\t\t\\\n@@ -68,11 +78,15 @@ Boston, MA 02111-1307, USA.  */\n    registers.  In effect this makes unused call-saved registers to be used\n    as call-clobbered registers.  The benefit comes from keeping the number\n    of local registers (value of rL) low, since there's a cost of\n-   increasing rL and clearing unused (unset) registers with lower numbers.  */\n+   increasing rL and clearing unused (unset) registers with lower numbers.\n+   Don't translate while outputting the prologue.  */\n #define MMIX_OUTPUT_REGNO(N)\t\t\t\t\t\\\n  (TARGET_ABI_GNU \t\t\t\t\t\t\\\n   || (int) (N) < MMIX_RETURN_VALUE_REGNUM\t\t\t\\\n   || (int) (N) > MMIX_LAST_STACK_REGISTER_REGNUM\t\t\\\n+  || cfun == NULL \t\t\t\t\t\t\\\n+  || cfun->machine == NULL \t\t\t\t\t\\\n+  || cfun->machine->in_prologue\t\t\t\t\t\\\n   ? (N) : ((N) - MMIX_RETURN_VALUE_REGNUM\t\t\t\\\n \t   + cfun->machine->highest_saved_stack_register + 1))\n \n@@ -110,10 +124,11 @@ static bool mmix_assemble_integer PARAMS ((rtx, unsigned int, int));\n static struct machine_function * mmix_init_machine_status PARAMS ((void));\n static void mmix_encode_section_info PARAMS ((tree, int));\n static const char *mmix_strip_name_encoding PARAMS ((const char *));\n-\n-extern void mmix_target_asm_function_prologue\n+static void mmix_emit_sp_add PARAMS ((HOST_WIDE_INT offset));\n+static void mmix_target_asm_function_prologue\n   PARAMS ((FILE *, HOST_WIDE_INT));\n-extern void mmix_target_asm_function_epilogue\n+static void mmix_target_asm_function_end_prologue PARAMS ((FILE *));\n+static void mmix_target_asm_function_epilogue\n   PARAMS ((FILE *, HOST_WIDE_INT));\n \n \n@@ -136,6 +151,9 @@ extern void mmix_target_asm_function_epilogue\n #undef TARGET_ASM_FUNCTION_PROLOGUE\n #define TARGET_ASM_FUNCTION_PROLOGUE mmix_target_asm_function_prologue\n \n+#undef TARGET_ASM_FUNCTION_END_PROLOGUE\n+#define TARGET_ASM_FUNCTION_END_PROLOGUE mmix_target_asm_function_end_prologue\n+\n #undef TARGET_ASM_FUNCTION_EPILOGUE\n #define TARGET_ASM_FUNCTION_EPILOGUE mmix_target_asm_function_epilogue\n \n@@ -241,11 +259,11 @@ mmix_conditional_register_usage ()\n \n       /* Change the default from the mmixware ABI.  For the GNU ABI,\n \t $15..$30 are call-saved just as $0..$14.  There must be one\n-\t call-clobbered local register for the \"hole\" describing number of\n-\t saved local registers saved by PUSHJ/PUSHGO during the function\n-\t call, receiving the return value at return.  So best is to use\n-\t the highest, $31.  It's already marked call-clobbered for the\n-\t mmixware ABI.  */\n+\t call-clobbered local register for the \"hole\" that holds the\n+\t number of saved local registers saved by PUSHJ/PUSHGO during the\n+\t function call, receiving the return value at return.  So best is\n+\t to use the highest, $31.  It's already marked call-clobbered for\n+\t the mmixware ABI.  */\n       for (i = 15; i <= 30; i++)\n \tcall_used_regs[i] = 0;\n \n@@ -263,6 +281,17 @@ mmix_conditional_register_usage ()\n \treg_names[i]++;\n }\n \n+/* LOCAL_REGNO.\n+   All registers that are part of the register stack and that will be\n+   saved are local.  */\n+\n+int\n+mmix_local_regno (regno)\n+     int regno;\n+{\n+  return regno <= MMIX_LAST_STACK_REGISTER_REGNUM && !call_used_regs[regno];\n+}\n+\n /* PREFERRED_RELOAD_CLASS.\n    We need to extend the reload class of REMAINDER_REG and HIMULT_REG.  */\n \n@@ -672,335 +701,25 @@ mmix_asm_preferred_eh_data_format (code, global)\n   return DW_EH_PE_absptr;\n }\n \n-/* Emit the function prologue.  For simplicity while the port is still\n-   in a flux, we do it as text rather than the now preferred RTL way,\n-   as (define_insn \"function_prologue\").\n+/* Make a note that we've seen the beginning of of the prologue.  This\n+   matters to whether we'll translate register numbers as calculated by\n+   mmix_machine_dependent_reorg.  */\n \n-   FIXME: Translate to RTL and/or optimize some of the DWARF 2 stuff.  */\n-\n-void\n-mmix_target_asm_function_prologue (stream, locals_size)\n-     FILE *stream;\n-     HOST_WIDE_INT locals_size;\n+static void\n+mmix_target_asm_function_prologue (stream, framesize)\n+     FILE *stream ATTRIBUTE_UNUSED;\n+     HOST_WIDE_INT framesize ATTRIBUTE_UNUSED;\n {\n-  int regno;\n-  int stack_space_to_allocate\n-    = (current_function_outgoing_args_size\n-       + current_function_pretend_args_size\n-       + (int) locals_size + 7) & ~7;\n-  int offset = -8;\n-  int doing_dwarf = dwarf2out_do_frame ();\n-  long cfa_offset = 0;\n-\n-  /* Guard our assumptions.  Very low priority FIXME.  */\n-  if (locals_size != (int) locals_size)\n-    error (\"stack frame too big\");\n-\n-  /* Add room needed to save global non-register-stack registers.  */\n-  for (regno = 255;\n-       regno >= MMIX_FIRST_GLOBAL_REGNUM;\n-       regno--)\n-    /* Note that we assume that the frame-pointer-register is one of these\n-       registers, in which case we don't count it here.  */\n-    if ((((regno != MMIX_FRAME_POINTER_REGNUM || !frame_pointer_needed)\n-\t  && regs_ever_live[regno] && !call_used_regs[regno]))\n-\t|| IS_MMIX_EH_RETURN_DATA_REG (regno))\n-      stack_space_to_allocate += 8;\n-\n-  /* If we do have a frame-pointer, add room for it.  */\n-  if (frame_pointer_needed)\n-    stack_space_to_allocate += 8;\n-\n-  /* If we have a non-local label, we need to be able to unwind to it, so\n-     store the current register stack pointer.  Also store the return\n-     address if we do that.  */\n-  if (MMIX_CFUN_HAS_LANDING_PAD)\n-    stack_space_to_allocate += 16;\n-  else if (MMIX_CFUN_NEEDS_SAVED_EH_RETURN_ADDRESS)\n-    /* If we do have a saved return-address slot, add room for it.  */\n-    stack_space_to_allocate += 8;\n-\n-  /* Make sure we don't get an unaligned stack.  */\n-  if ((stack_space_to_allocate % 8) != 0)\n-    internal_error (\"stack frame not a multiple of 8 bytes: %d\",\n-\t\t    stack_space_to_allocate);\n-\n-  if (current_function_pretend_args_size)\n-    {\n-      int mmix_first_vararg_reg\n-\t= (MMIX_FIRST_INCOMING_ARG_REGNUM\n-\t   + (MMIX_MAX_ARGS_IN_REGS\n-\t      - current_function_pretend_args_size / 8));\n-\n-      for (regno\n-\t     = MMIX_FIRST_INCOMING_ARG_REGNUM + MMIX_MAX_ARGS_IN_REGS - 1;\n-\t   regno >= mmix_first_vararg_reg;\n-\t   regno--)\n-\t{\n-\t  if (offset < 0)\n-\t    {\n-\t      int stack_chunk\n-\t\t= stack_space_to_allocate > (256 - 8)\n-\t\t? (256 - 8) : stack_space_to_allocate;\n-\n-\t      fprintf (stream, \"\\tSUBU %s,%s,%d\\n\",\n-\t\t       reg_names[MMIX_STACK_POINTER_REGNUM],\n-\t\t       reg_names[MMIX_STACK_POINTER_REGNUM],\n-\t\t       stack_chunk);\n-\n-\t      if (doing_dwarf)\n-\t\t{\n-\t\t  /* Each call to dwarf2out_def_cfa overrides the previous\n-\t\t     setting; they don't accumulate.  We must keep track\n-\t\t     of the offset ourselves.  */\n-\t\t  cfa_offset += stack_chunk;\n-\t\t  if (!frame_pointer_needed)\n-\t\t    dwarf2out_def_cfa (\"\", MMIX_STACK_POINTER_REGNUM,\n-\t\t\t\t       cfa_offset);\n-\t\t}\n-\t      offset += stack_chunk;\n-\t      stack_space_to_allocate -= stack_chunk;\n-\t    }\n-\n-\t  fprintf (stream, \"\\tSTOU %s,%s,%d\\n\", reg_names[regno],\n-\t\t   reg_names[MMIX_STACK_POINTER_REGNUM],\n-\t\t   offset);\n-\n-\t  /* These registers aren't actually saved (as in \"will be\n-\t     restored\"), so don't tell DWARF2 they're saved.  */\n-\n-\t  offset -= 8;\n-\t}\n-    }\n-\n-  /* Store the frame-pointer.  */\n-\n-  if (frame_pointer_needed)\n-    {\n-      if (offset < 0)\n-\t{\n-\t  /* Get 8 less than otherwise, since we need to reach offset + 8.  */\n-\t  int stack_chunk\n-\t    = stack_space_to_allocate > (256 - 8 - 8)\n-\t    ? (256 - 8 - 8) : stack_space_to_allocate;\n-\n-\t  fprintf (stream, \"\\tSUBU %s,%s,%d\\n\",\n-\t\t   reg_names[MMIX_STACK_POINTER_REGNUM],\n-\t\t   reg_names[MMIX_STACK_POINTER_REGNUM],\n-\t\t   stack_chunk);\n-\t  if (doing_dwarf)\n-\t    cfa_offset += stack_chunk;\n-\t  offset += stack_chunk;\n-\t  stack_space_to_allocate -= stack_chunk;\n-\t}\n-\n-      fprintf (stream, \"\\tSTOU %s,%s,%d\\n\\tADDU %s,%s,%d\\n\",\n-\t       reg_names[MMIX_FRAME_POINTER_REGNUM],\n-\t       reg_names[MMIX_STACK_POINTER_REGNUM],\n-\t       offset,\n-\t       reg_names[MMIX_FRAME_POINTER_REGNUM],\n-\t       reg_names[MMIX_STACK_POINTER_REGNUM],\n-\t       offset + 8);\n-      if (doing_dwarf)\n-\t{\n-\t  /* If we're using the frame-pointer, then we just need this CFA\n-\t     definition basing on that value (often equal to the CFA).\n-\t     Further changes to the stack-pointer do not affect the\n-\t     frame-pointer, so we conditionalize them below on\n-\t     !frame_pointer_needed.  */\n-\t  dwarf2out_def_cfa (\"\", MMIX_FRAME_POINTER_REGNUM,\n-\t\t\t     -cfa_offset + offset + 8);\n-\n-\t  dwarf2out_reg_save (\"\", MMIX_FRAME_POINTER_REGNUM,\n-\t\t\t      -cfa_offset + offset);\n-\t}\n-\n-      offset -= 8;\n-    }\n-\n-  if (MMIX_CFUN_NEEDS_SAVED_EH_RETURN_ADDRESS)\n-    {\n-      /* Store the return-address, if one is needed on the stack.  We\n-\t usually store it in a register when needed, but that doesn't work\n-\t with -fexceptions.  */\n-\n-      if (offset < 0)\n-\t{\n-\t  /* Get 8 less than otherwise, since we need to reach offset + 8.  */\n-\t  int stack_chunk\n-\t    = stack_space_to_allocate > (256 - 8 - 8)\n-\t    ? (256 - 8 - 8) : stack_space_to_allocate;\n-\n-\t  fprintf (stream, \"\\tSUBU %s,%s,%d\\n\",\n-\t\t   reg_names[MMIX_STACK_POINTER_REGNUM],\n-\t\t   reg_names[MMIX_STACK_POINTER_REGNUM],\n-\t\t   stack_chunk);\n-\t  if (doing_dwarf)\n-\t    {\n-\t      cfa_offset += stack_chunk;\n-\t      if (!frame_pointer_needed)\n-\t\tdwarf2out_def_cfa (\"\", MMIX_STACK_POINTER_REGNUM,\n-\t\t\t\t   cfa_offset);\n-\t    }\n-\t  offset += stack_chunk;\n-\t  stack_space_to_allocate -= stack_chunk;\n-\t}\n-\n-      fprintf (stream, \"\\tGET $255,rJ\\n\\tSTOU $255,%s,%d\\n\",\n-\t       reg_names[MMIX_STACK_POINTER_REGNUM],\n-\t       offset);\n-      if (doing_dwarf)\n-\tdwarf2out_return_save (\"\", -cfa_offset + offset);\n-      offset -= 8;\n-    }\n-  else if (MMIX_CFUN_HAS_LANDING_PAD)\n-    offset -= 8;\n-\n-  if (MMIX_CFUN_HAS_LANDING_PAD)\n-    {\n-      /* Store the register defining the numbering of local registers, so\n-\t we know how long to unwind the register stack.  */\n-\n-      if (offset < 0)\n-\t{\n-\t  /* Get 8 less than otherwise, since we need to reach offset + 8.  */\n-\t  int stack_chunk\n-\t    = stack_space_to_allocate > (256 - 8 - 8)\n-\t    ? (256 - 8 - 8) : stack_space_to_allocate;\n-\n-\t  fprintf (stream, \"\\tSUBU %s,%s,%d\\n\",\n-\t\t   reg_names[MMIX_STACK_POINTER_REGNUM],\n-\t\t   reg_names[MMIX_STACK_POINTER_REGNUM],\n-\t\t   stack_chunk);\n-\t  offset += stack_chunk;\n-\t  stack_space_to_allocate -= stack_chunk;\n-\n-\t  if (doing_dwarf)\n-\t    {\n-\t      cfa_offset += stack_chunk;\n-\t      if (!frame_pointer_needed)\n-\t\tdwarf2out_def_cfa (\"\", MMIX_STACK_POINTER_REGNUM,\n-\t\t\t\t cfa_offset);\n-\t    }\n-\t}\n-\n-      /* We don't tell dwarf2 about this one; we just have it to unwind\n-\t the register stack at landing pads.  FIXME: It's a kludge because\n-\t we can't describe the effect of the PUSHJ and PUSHGO insns on the\n-\t register stack at the moment.  Best thing would be to handle it\n-\t like stack-pointer offsets.  Better: some hook into dwarf2out.c\n-\t to produce DW_CFA_expression:s that specify the increment of rO,\n-\t and unwind it at eh_return (preferred) or at the landing pad.\n-\t Then saves to $0..$G-1 could be specified through that register.  */\n-\n-      fprintf (stream, \"\\tGET $255,rO\\n\\tSTOU $255,%s,%d\\n\",\n-\t       reg_names[MMIX_STACK_POINTER_REGNUM], offset);\n-\n-      offset -= 8;\n-    }\n-\n-  /* After the return-address and the frame-pointer, we have the local\n-     variables.  They're the ones that may have an \"unaligned\" size.  */\n-  offset -= (locals_size + 7) & ~7;\n-\n-  /* Now store all registers that are global, i.e. not saved by the\n-     register file machinery.\n-\n-     It is assumed that the frame-pointer is one of these registers, so it\n-     is explicitly excluded in the count.  */\n-\n-  for (regno = 255;\n-       regno >= MMIX_FIRST_GLOBAL_REGNUM;\n-       regno--)\n-    if (((regno != MMIX_FRAME_POINTER_REGNUM || !frame_pointer_needed)\n-\t && regs_ever_live[regno] && ! call_used_regs[regno])\n-\t|| IS_MMIX_EH_RETURN_DATA_REG (regno))\n-      {\n-\tif (offset < 0)\n-\t  {\n-\t    int stack_chunk;\n-\n-\t    /* Since the local variables go above, we may get a large\n-\t       offset here.  */\n-\t    if (offset < -248)\n-\t      {\n-\t\t/* We're not going to access the locals area in the\n-\t\t   prologue, so we'll just silently subtract the slab we\n-\t\t   will not access.  */\n-\t\tstack_chunk =\n-\t\t  stack_space_to_allocate > (256 - offset - 8)\n-\t\t  ? (256 - offset - 8) : stack_space_to_allocate;\n-\n-\t\tmmix_output_register_setting (stream, 255, stack_chunk, 1);\n-\t\tfprintf (stream, \"\\tSUBU %s,%s,$255\\n\",\n-\t\t\t reg_names[MMIX_STACK_POINTER_REGNUM],\n-\t\t\t reg_names[MMIX_STACK_POINTER_REGNUM]);\n-\n-\t\tif (doing_dwarf)\n-\t\t  {\n-\t\t    cfa_offset += stack_chunk;\n-\t\t    if (!frame_pointer_needed)\n-\t\t      dwarf2out_def_cfa (\"\", MMIX_STACK_POINTER_REGNUM,\n-\t\t\t\t\t cfa_offset);\n-\t\t  }\n-\t      }\n-\t    else\n-\t      {\n-\t\tstack_chunk = stack_space_to_allocate > (256 - 8)\n-\t\t  ? (256 - 8) : stack_space_to_allocate;\n-\n-\t\tfprintf (stream, \"\\tSUBU %s,%s,%d\\n\",\n-\t\t\t reg_names[MMIX_STACK_POINTER_REGNUM],\n-\t\t\t reg_names[MMIX_STACK_POINTER_REGNUM], stack_chunk);\n-\t\tif (doing_dwarf)\n-\t\t  {\n-\t\t    cfa_offset += stack_chunk;\n-\t\t    if (!frame_pointer_needed)\n-\t\t      dwarf2out_def_cfa (\"\", MMIX_STACK_POINTER_REGNUM,\n-\t\t\t\t\t cfa_offset);\n-\t\t  }\n-\t      }\n-\n-\t    offset += stack_chunk;\n-\t    stack_space_to_allocate -= stack_chunk;\n-\t  }\n-\n-\tfprintf (stream, \"\\tSTOU %s,%s,%d\\n\", reg_names[regno],\n-\t       reg_names[MMIX_STACK_POINTER_REGNUM], offset);\n-\tif (doing_dwarf)\n-\t  dwarf2out_reg_save (\"\", regno, -cfa_offset + offset);\n-\toffset -= 8;\n-      }\n+  cfun->machine->in_prologue = 1;\n+}\n \n-  /* Finally, allocate room for outgoing args and local vars if room\n-     wasn't allocated above.  This might be any number of bytes (well, we\n-     assume it fits in a host-int).  */\n-  if (stack_space_to_allocate)\n-    {\n-      if (stack_space_to_allocate < 256)\n-\t{\n-\t  fprintf (stream, \"\\tSUBU %s,%s,%d\\n\",\n-\t\t   reg_names[MMIX_STACK_POINTER_REGNUM],\n-\t\t   reg_names[MMIX_STACK_POINTER_REGNUM],\n-\t\t   stack_space_to_allocate);\n-\t}\n-      else\n-\t{\n-\t  mmix_output_register_setting (stream, 255,\n-\t\t\t\t\tstack_space_to_allocate, 1);\n-\t  fprintf (stream, \"\\tSUBU %s,%s,$255\\n\",\n-\t\t   reg_names[MMIX_STACK_POINTER_REGNUM],\n-\t\t   reg_names[MMIX_STACK_POINTER_REGNUM]);\n-\t}\n+/* Make a note that we've seen the end of the prologue.  */\n \n-      if (doing_dwarf)\n-\t{\n-\t  cfa_offset += stack_space_to_allocate;\n-\t  if (!frame_pointer_needed)\n-\t    dwarf2out_def_cfa (\"\", MMIX_STACK_POINTER_REGNUM,\n-\t\t\t       cfa_offset);\n-\t}\n-    }\n+static void\n+mmix_target_asm_function_end_prologue (stream)\n+     FILE *stream ATTRIBUTE_UNUSED;\n+{\n+  cfun->machine->in_prologue = 0;\n }\n \n /* MACHINE_DEPENDENT_REORG.\n@@ -1055,210 +774,40 @@ mmix_target_asm_function_epilogue (stream, locals_size)\n      HOST_WIDE_INT locals_size;\n \n {\n-  int regno;\n-  int stack_space_to_deallocate\n-    = (current_function_outgoing_args_size\n-       + current_function_pretend_args_size\n-       + (int) locals_size + 7) & ~7;\n+  /* Emit an \\n for readability of the generated assembly.  */\n+  fputc ('\\n', stream);\n+}\n \n-  /* The assumption that locals_size fits in an int is asserted in\n-     mmix_target_asm_function_prologue.  */\n+/* ASM_OUTPUT_MI_THUNK.  */\n \n-  /* The first address to access is beyond the outgoing_args area.  */\n-  int offset = current_function_outgoing_args_size;\n+void\n+mmix_asm_output_mi_thunk (stream, fndecl, delta, func)\n+     FILE * stream;\n+     tree fndecl ATTRIBUTE_UNUSED;\n+     int delta;\n+     tree func;\n+{\n+  /* If you define STRUCT_VALUE to 0, rather than use STRUCT_VALUE_REGNUM,\n+     (i.e. pass location of structure to return as invisible first\n+     argument) you need to tweak this code too.  */\n+  const char *regname = reg_names[MMIX_FIRST_INCOMING_ARG_REGNUM];\n \n-  rtx insn = get_last_insn ();\n-\n-  /* If the last insn was a BARRIER, we don't have to write any code,\n-     then all returns were covered by \"return\" insns.  */\n-  if (GET_CODE (insn) == NOTE)\n-    insn = prev_nonnote_insn (insn);\n-  if (insn\n-      && (GET_CODE (insn) == BARRIER\n-\t  /* We must make sure that the insn really is a \"return\" and\n-\t     not a conditional branch.  Try to match the return exactly,\n-\t     and if it doesn't match, assume it is a conditional branch\n-\t     (and output an epilogue).  */\n-\t  || (GET_CODE (insn) == JUMP_INSN\n-\t      && GET_CODE (PATTERN (insn)) == RETURN)))\n+  if (delta >= 0 && delta < 65536)\n+    asm_fprintf (stream, \"\\tINCL %s,%d\\n\", delta, regname);\n+  else if (delta < 0 && delta >= -255)\n+    asm_fprintf (stream, \"\\tSUBU %s,%s,%d\\n\", regname, regname, -delta);\n+  else\n     {\n-      /* Emit an extra \\n as is done with the normal epilogue.  */\n-      fputc ('\\n', stream);\n-      return;\n+      mmix_output_register_setting (stream, 255, delta, 1);\n+      asm_fprintf (stream, \"\\tADDU %s,%s,$255\\n\", regname, regname);\n     }\n \n-  /* Add the space for global non-register-stack registers.\n-     It is assumed that the frame-pointer register can be one of these\n-     registers, in which case it is excluded from the count when needed.  */\n-  for (regno = 255;\n-       regno >= MMIX_FIRST_GLOBAL_REGNUM;\n-       regno--)\n-    if (((regno != MMIX_FRAME_POINTER_REGNUM || !frame_pointer_needed)\n-\t && regs_ever_live[regno] && !call_used_regs[regno])\n-\t|| IS_MMIX_EH_RETURN_DATA_REG (regno))\n-      stack_space_to_deallocate += 8;\n-\n-  /* Add in the space for register stack-pointer.  If so, always add room\n-     for the saved PC.  */\n-  if (MMIX_CFUN_HAS_LANDING_PAD)\n-    stack_space_to_deallocate += 16;\n-  else if (MMIX_CFUN_NEEDS_SAVED_EH_RETURN_ADDRESS)\n-    /* If we have a saved return-address slot, add it in.  */\n-    stack_space_to_deallocate += 8;\n+  fprintf (stream, \"\\tJMP \");\n+  assemble_name (stream, XSTR (XEXP (DECL_RTL (func), 0), 0));\n+  fprintf (stream, \"\\n\");\n+}\n \n-  /* Add in the frame-pointer.  */\n-  if (frame_pointer_needed)\n-    stack_space_to_deallocate += 8;\n-\n-  /* Make sure we don't get an unaligned stack.  */\n-  if ((stack_space_to_deallocate % 8) != 0)\n-    internal_error (\"stack frame not a multiple of octabyte: %d\",\n-\t\t    stack_space_to_deallocate);\n-\n-  /* We will add back small offsets to the stack pointer as we go.\n-     First, we restore all registers that are global, i.e. not saved by\n-     the register file machinery.  */\n-\n-  for (regno = MMIX_FIRST_GLOBAL_REGNUM;\n-       regno <= 255;\n-       regno++)\n-    if (((regno != MMIX_FRAME_POINTER_REGNUM || !frame_pointer_needed)\n-\t && regs_ever_live[regno] && !call_used_regs[regno])\n-\t|| IS_MMIX_EH_RETURN_DATA_REG (regno))\n-      {\n-\tif (offset > 255)\n-\t  {\n-\t    if (offset > 65535)\n-\t      {\n-\t\t/* There's better support for incrementing than\n-\t\t   decrementing, so we might be able to optimize this as\n-\t\t   we see a need.  */\n-\t\tmmix_output_register_setting (stream, 255, offset, 1);\n-\t\tfprintf (stream, \"\\tADDU %s,%s,$255\\n\",\n-\t\t\t reg_names[MMIX_STACK_POINTER_REGNUM],\n-\t\t\t reg_names[MMIX_STACK_POINTER_REGNUM]);\n-\t      }\n-\t    else\n-\t      fprintf (stream, \"\\tINCL %s,%d\\n\",\n-\t\t       reg_names[MMIX_STACK_POINTER_REGNUM], offset);\n-\n-\t    stack_space_to_deallocate -= offset;\n-\t    offset = 0;\n-\t  }\n-\n-\tfprintf (stream, \"\\tLDOU %s,%s,%d\\n\",\n-\t\t reg_names[regno],\n-\t\t reg_names[MMIX_STACK_POINTER_REGNUM],\n-\t\t offset);\n-\toffset += 8;\n-      }\n-\n-  /* Here is where the local variables were.  As in the prologue, they\n-     might be of an unaligned size.  */\n-  offset += (locals_size + 7) & ~7;\n-\n-\n-  /* The saved register stack pointer is just below the frame-pointer\n-     register.  We don't need to restore it \"manually\"; the POP\n-     instruction does that.  */\n-  if (MMIX_CFUN_HAS_LANDING_PAD)\n-    offset += 16;\n-  else if (MMIX_CFUN_NEEDS_SAVED_EH_RETURN_ADDRESS)\n-    /* The return-address slot is just below the frame-pointer register.\n-       We don't need to restore it because we don't really use it.  */\n-    offset += 8;\n-\n-  /* Get back the old frame-pointer-value.  */\n-  if (frame_pointer_needed)\n-    {\n-      if (offset > 255)\n-\t{\n-\t  if (offset > 65535)\n-\t    {\n-\t      /* There's better support for incrementing than\n-\t\t decrementing, so we might be able to optimize this as\n-\t\t we see a need.  */\n-\t      mmix_output_register_setting (stream, 255, offset, 1);\n-\t      fprintf (stream, \"\\tADDU %s,%s,$255\\n\",\n-\t\t       reg_names[MMIX_STACK_POINTER_REGNUM],\n-\t\t       reg_names[MMIX_STACK_POINTER_REGNUM]);\n-\t    }\n-\t  else\n-\t    fprintf (stream, \"\\tINCL %s,%d\\n\",\n-\t\t     reg_names[MMIX_STACK_POINTER_REGNUM], offset);\n-\n-\t  stack_space_to_deallocate -= offset;\n-\t  offset = 0;\n-\t}\n-\n-      fprintf (stream, \"\\tLDOU %s,%s,%d\\n\",\n-\t       reg_names[MMIX_FRAME_POINTER_REGNUM],\n-\t       reg_names[MMIX_STACK_POINTER_REGNUM],\n-\t       offset);\n-      offset += 8;\n-    }\n-\n-  /* We do not need to restore pretended incoming args, just add back\n-     offset to sp.  */\n-  if (stack_space_to_deallocate > 65535)\n-    {\n-      /* There's better support for incrementing than decrementing, so\n-\t we might be able to optimize this as we see a need.  */\n-      mmix_output_register_setting (stream, 255,\n-\t\t\t\t    stack_space_to_deallocate, 1);\n-      fprintf (stream, \"\\tADDU %s,%s,$255\\n\",\n-\t       reg_names[MMIX_STACK_POINTER_REGNUM],\n-\t       reg_names[MMIX_STACK_POINTER_REGNUM]);\n-    }\n-  else if (stack_space_to_deallocate != 0)\n-    fprintf (stream, \"\\tINCL %s,%d\\n\",\n-\t     reg_names[MMIX_STACK_POINTER_REGNUM],\n-\t     stack_space_to_deallocate);\n-\n-  if (current_function_calls_eh_return)\n-    /* Adjustment the (normal) stack-pointer to that of the receiver.\n-       FIXME: It would be nice if we could also adjust the register stack\n-       here, but we need to express it through DWARF 2 too.  */\n-    fprintf (stream, \"\\tADDU %s,%s,%s\\n\",\n-\t     reg_names [MMIX_STACK_POINTER_REGNUM],\n-\t     reg_names [MMIX_STACK_POINTER_REGNUM],\n-\t     reg_names [MMIX_EH_RETURN_STACKADJ_REGNUM]);\n-\n-  /* The extra \\n is so we have a blank line between the assembly code of\n-     separate functions.  */\n-  fprintf (stream, \"\\tPOP %d,0\\n\\n\", MMIX_POP_ARGUMENT ());\n-}\n-\n-/* ASM_OUTPUT_MI_THUNK.  */\n-\n-void\n-mmix_asm_output_mi_thunk (stream, fndecl, delta, func)\n-     FILE * stream;\n-     tree fndecl ATTRIBUTE_UNUSED;\n-     int delta;\n-     tree func;\n-{\n-  /* If you define STRUCT_VALUE to 0, rather than use STRUCT_VALUE_REGNUM,\n-     (i.e. pass location of structure to return as invisible first\n-     argument) you need to tweak this code too.  */\n-  const char *regname = reg_names[MMIX_FIRST_INCOMING_ARG_REGNUM];\n-\n-  if (delta >= 0 && delta < 65536)\n-    asm_fprintf (stream, \"\\tINCL %s,%d\\n\", delta, regname);\n-  else if (delta < 0 && delta >= -255)\n-    asm_fprintf (stream, \"\\tSUBU %s,%s,%d\\n\", regname, regname, -delta);\n-  else\n-    {\n-      mmix_output_register_setting (stream, 255, delta, 1);\n-      asm_fprintf (stream, \"\\tADDU %s,%s,$255\\n\", regname, regname);\n-    }\n-\n-  fprintf (stream, \"\\tJMP \");\n-  assemble_name (stream, XSTR (XEXP (DECL_RTL (func), 0), 0));\n-  fprintf (stream, \"\\n\");\n-}\n-\n-/* FUNCTION_PROFILER.  */\n+/* FUNCTION_PROFILER.  */\n \n void\n mmix_function_profiler (stream, labelno)\n@@ -2483,8 +2032,19 @@ mmix_dbx_register_number (regno)\n \n    Now MMIX's own functions.  First the exported ones.  */\n \n+/* Wrapper for get_hard_reg_initial_val since integrate.h isn't included\n+   from insn-emit.c.  */\n+\n+rtx\n+mmix_get_hard_reg_initial_val (mode, regno)\n+     enum machine_mode mode;\n+     int regno;\n+{\n+  return get_hard_reg_initial_val (mode, regno);\n+}\n+\n /* Non-zero when the function epilogue is simple enough that a single\n-   \"POP %d,0\" should be used.  */\n+   \"POP %d,0\" should be used even within the function.  */\n \n int\n mmix_use_simple_return ()\n@@ -2520,6 +2080,360 @@ mmix_use_simple_return ()\n   return stack_space_to_allocate == 0;\n }\n \n+\n+/* Expands the function prologue into RTX.  */\n+\n+void\n+mmix_expand_prologue ()\n+{\n+  HOST_WIDE_INT locals_size = get_frame_size ();\n+  int regno;\n+  HOST_WIDE_INT stack_space_to_allocate\n+    = (current_function_outgoing_args_size\n+       + current_function_pretend_args_size\n+       + locals_size + 7) & ~7;\n+  HOST_WIDE_INT offset = -8;\n+\n+  /* Add room needed to save global non-register-stack registers.  */\n+  for (regno = 255;\n+       regno >= MMIX_FIRST_GLOBAL_REGNUM;\n+       regno--)\n+    /* Note that we assume that the frame-pointer-register is one of these\n+       registers, in which case we don't count it here.  */\n+    if ((((regno != MMIX_FRAME_POINTER_REGNUM || !frame_pointer_needed)\n+\t  && regs_ever_live[regno] && !call_used_regs[regno]))\n+\t|| IS_MMIX_EH_RETURN_DATA_REG (regno))\n+      stack_space_to_allocate += 8;\n+\n+  /* If we do have a frame-pointer, add room for it.  */\n+  if (frame_pointer_needed)\n+    stack_space_to_allocate += 8;\n+\n+  /* If we have a non-local label, we need to be able to unwind to it, so\n+     store the current register stack pointer.  Also store the return\n+     address if we do that.  */\n+  if (MMIX_CFUN_HAS_LANDING_PAD)\n+    stack_space_to_allocate += 16;\n+  else if (MMIX_CFUN_NEEDS_SAVED_EH_RETURN_ADDRESS)\n+    /* If we do have a saved return-address slot, add room for it.  */\n+    stack_space_to_allocate += 8;\n+\n+  /* Make sure we don't get an unaligned stack.  */\n+  if ((stack_space_to_allocate % 8) != 0)\n+    internal_error (\"stack frame not a multiple of 8 bytes: %d\",\n+\t\t    stack_space_to_allocate);\n+\n+  if (current_function_pretend_args_size)\n+    {\n+      int mmix_first_vararg_reg\n+\t= (MMIX_FIRST_INCOMING_ARG_REGNUM\n+\t   + (MMIX_MAX_ARGS_IN_REGS\n+\t      - current_function_pretend_args_size / 8));\n+\n+      for (regno\n+\t     = MMIX_FIRST_INCOMING_ARG_REGNUM + MMIX_MAX_ARGS_IN_REGS - 1;\n+\t   regno >= mmix_first_vararg_reg;\n+\t   regno--)\n+\t{\n+\t  if (offset < 0)\n+\t    {\n+\t      HOST_WIDE_INT stack_chunk\n+\t\t= stack_space_to_allocate > (256 - 8)\n+\t\t? (256 - 8) : stack_space_to_allocate;\n+\n+\t      mmix_emit_sp_add (-stack_chunk);\n+\t      offset += stack_chunk;\n+\t      stack_space_to_allocate -= stack_chunk;\n+\t    }\n+\n+\t  /* These registers aren't actually saved (as in \"will be\n+\t     restored\"), so don't tell DWARF2 they're saved.  */\n+\t  emit_move_insn (gen_rtx_MEM (DImode,\n+\t\t\t\t       plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t      offset)),\n+\t\t\t  gen_rtx_REG (DImode, regno));\n+\t  offset -= 8;\n+\t}\n+    }\n+\n+  /* Store the frame-pointer.  */\n+\n+  if (frame_pointer_needed)\n+    {\n+      rtx insn;\n+\n+      if (offset < 0)\n+\t{\n+\t  /* Get 8 less than otherwise, since we need to reach offset + 8.  */\n+\t  HOST_WIDE_INT stack_chunk\n+\t    = stack_space_to_allocate > (256 - 8 - 8)\n+\t    ? (256 - 8 - 8) : stack_space_to_allocate;\n+\n+\t  mmix_emit_sp_add (-stack_chunk);\n+\n+\t  offset += stack_chunk;\n+\t  stack_space_to_allocate -= stack_chunk;\n+\t}\n+\n+      insn = emit_move_insn (gen_rtx_MEM (DImode,\n+\t\t\t\t\t  plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t\t offset)),\n+\t\t\t     hard_frame_pointer_rtx);\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+      insn = emit_insn (gen_adddi3 (hard_frame_pointer_rtx,\n+\t\t\t\t    stack_pointer_rtx,\n+\t\t\t\t    GEN_INT (offset + 8)));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+      offset -= 8;\n+    }\n+\n+  if (MMIX_CFUN_NEEDS_SAVED_EH_RETURN_ADDRESS)\n+    {\n+      rtx tmpreg, retreg;\n+      rtx insn;\n+\n+      /* Store the return-address, if one is needed on the stack.  We\n+\t usually store it in a register when needed, but that doesn't work\n+\t with -fexceptions.  */\n+\n+      if (offset < 0)\n+\t{\n+\t  /* Get 8 less than otherwise, since we need to reach offset + 8.  */\n+\t  HOST_WIDE_INT stack_chunk\n+\t    = stack_space_to_allocate > (256 - 8 - 8)\n+\t    ? (256 - 8 - 8) : stack_space_to_allocate;\n+\n+\t  mmix_emit_sp_add (-stack_chunk);\n+\n+\t  offset += stack_chunk;\n+\t  stack_space_to_allocate -= stack_chunk;\n+\t}\n+\n+      tmpreg = gen_rtx_REG (DImode, 255);\n+      retreg = gen_rtx_REG (DImode, MMIX_rJ_REGNUM);\n+\n+      /* Dwarf2 code is confused by the use of a temporary register for\n+\t storing the return address, so we have to express it as a note,\n+\t which we attach to the actual store insn.  */\n+      emit_move_insn (tmpreg, retreg);\n+\n+      insn = emit_move_insn (gen_rtx_MEM (DImode,\n+\t\t\t\t\t  plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t\t offset)),\n+\t\t\t     tmpreg);\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+      REG_NOTES (insn)\n+\t= gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n+\t\t\t     gen_rtx_SET (VOIDmode,\n+\t\t\t\t\t  gen_rtx_MEM (DImode,\n+\t\t\t\t\t\t       plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t\t\t      offset)),\n+\t\t\t\t\t  retreg),\n+\t\t\t     REG_NOTES (insn));\n+\n+      offset -= 8;\n+    }\n+  else if (MMIX_CFUN_HAS_LANDING_PAD)\n+    offset -= 8;\n+\n+  if (MMIX_CFUN_HAS_LANDING_PAD)\n+    {\n+      /* Store the register defining the numbering of local registers, so\n+\t we know how long to unwind the register stack.  */\n+\n+      if (offset < 0)\n+\t{\n+\t  /* Get 8 less than otherwise, since we need to reach offset + 8.  */\n+\t  HOST_WIDE_INT stack_chunk\n+\t    = stack_space_to_allocate > (256 - 8 - 8)\n+\t    ? (256 - 8 - 8) : stack_space_to_allocate;\n+\n+\t  mmix_emit_sp_add (-stack_chunk);\n+\n+\t  offset += stack_chunk;\n+\t  stack_space_to_allocate -= stack_chunk;\n+\t}\n+\n+      /* We don't tell dwarf2 about this one; we just have it to unwind\n+\t the register stack at landing pads.  FIXME: It's a kludge because\n+\t we can't describe the effect of the PUSHJ and PUSHGO insns on the\n+\t register stack at the moment.  Best thing would be to handle it\n+\t like stack-pointer offsets.  Better: some hook into dwarf2out.c\n+\t to produce DW_CFA_expression:s that specify the increment of rO,\n+\t and unwind it at eh_return (preferred) or at the landing pad.\n+\t Then saves to $0..$G-1 could be specified through that register.  */\n+\n+      emit_move_insn (gen_rtx_REG (DImode, 255),\n+\t\t      gen_rtx_REG (DImode,\n+\t\t\t\t   MMIX_rO_REGNUM));\n+      emit_move_insn (gen_rtx_MEM (DImode,\n+\t\t\t\t   plus_constant (stack_pointer_rtx, offset)),\n+\t\t      gen_rtx_REG (DImode, 255));\n+      offset -= 8;\n+    }\n+\n+  /* After the return-address and the frame-pointer, we have the local\n+     variables.  They're the ones that may have an \"unaligned\" size.  */\n+  offset -= (locals_size + 7) & ~7;\n+\n+  /* Now store all registers that are global, i.e. not saved by the\n+     register file machinery.\n+\n+     It is assumed that the frame-pointer is one of these registers, so it\n+     is explicitly excluded in the count.  */\n+\n+  for (regno = 255;\n+       regno >= MMIX_FIRST_GLOBAL_REGNUM;\n+       regno--)\n+    if (((regno != MMIX_FRAME_POINTER_REGNUM || !frame_pointer_needed)\n+\t && regs_ever_live[regno] && ! call_used_regs[regno])\n+\t|| IS_MMIX_EH_RETURN_DATA_REG (regno))\n+      {\n+\trtx insn;\n+\n+\tif (offset < 0)\n+\t  {\n+\t    HOST_WIDE_INT stack_chunk\n+\t      = (stack_space_to_allocate > (256 - offset - 8)\n+\t\t ? (256 - offset - 8) : stack_space_to_allocate);\n+\n+\t    mmix_emit_sp_add (-stack_chunk);\n+\t    offset += stack_chunk;\n+\t    stack_space_to_allocate -= stack_chunk;\n+\t  }\n+\n+\tinsn = emit_move_insn (gen_rtx_MEM (DImode,\n+\t\t\t\t\t    plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t\t   offset)),\n+\t\t\t       gen_rtx_REG (DImode, regno));\n+\tRTX_FRAME_RELATED_P (insn) = 1;\n+\toffset -= 8;\n+      }\n+\n+  /* Finally, allocate room for outgoing args and local vars if room\n+     wasn't allocated above.  */\n+  if (stack_space_to_allocate)\n+    mmix_emit_sp_add (-stack_space_to_allocate);\n+}\n+\n+/* Expands the function epilogue into RTX.  */\n+\n+void\n+mmix_expand_epilogue ()\n+{\n+  HOST_WIDE_INT locals_size = get_frame_size ();\n+  int regno;\n+  HOST_WIDE_INT stack_space_to_deallocate\n+    = (current_function_outgoing_args_size\n+       + current_function_pretend_args_size\n+       + locals_size + 7) & ~7;\n+\n+  /* The assumption that locals_size fits in an int is asserted in\n+     mmix_expand_prologue.  */\n+\n+  /* The first address to access is beyond the outgoing_args area.  */\n+  int offset = current_function_outgoing_args_size;\n+\n+  /* Add the space for global non-register-stack registers.\n+     It is assumed that the frame-pointer register can be one of these\n+     registers, in which case it is excluded from the count when needed.  */\n+  for (regno = 255;\n+       regno >= MMIX_FIRST_GLOBAL_REGNUM;\n+       regno--)\n+    if (((regno != MMIX_FRAME_POINTER_REGNUM || !frame_pointer_needed)\n+\t && regs_ever_live[regno] && !call_used_regs[regno])\n+\t|| IS_MMIX_EH_RETURN_DATA_REG (regno))\n+      stack_space_to_deallocate += 8;\n+\n+  /* Add in the space for register stack-pointer.  If so, always add room\n+     for the saved PC.  */\n+  if (MMIX_CFUN_HAS_LANDING_PAD)\n+    stack_space_to_deallocate += 16;\n+  else if (MMIX_CFUN_NEEDS_SAVED_EH_RETURN_ADDRESS)\n+    /* If we have a saved return-address slot, add it in.  */\n+    stack_space_to_deallocate += 8;\n+\n+  /* Add in the frame-pointer.  */\n+  if (frame_pointer_needed)\n+    stack_space_to_deallocate += 8;\n+\n+  /* Make sure we don't get an unaligned stack.  */\n+  if ((stack_space_to_deallocate % 8) != 0)\n+    internal_error (\"stack frame not a multiple of octabyte: %d\",\n+\t\t    stack_space_to_deallocate);\n+\n+  /* We will add back small offsets to the stack pointer as we go.\n+     First, we restore all registers that are global, i.e. not saved by\n+     the register file machinery.  */\n+\n+  for (regno = MMIX_FIRST_GLOBAL_REGNUM;\n+       regno <= 255;\n+       regno++)\n+    if (((regno != MMIX_FRAME_POINTER_REGNUM || !frame_pointer_needed)\n+\t && regs_ever_live[regno] && !call_used_regs[regno])\n+\t|| IS_MMIX_EH_RETURN_DATA_REG (regno))\n+      {\n+\tif (offset > 255)\n+\t  {\n+\t    mmix_emit_sp_add (offset);\n+\t    stack_space_to_deallocate -= offset;\n+\t    offset = 0;\n+\t  }\n+\n+\temit_move_insn (gen_rtx_REG (DImode, regno),\n+\t\t\tgen_rtx_MEM (DImode,\n+\t\t\t\t     plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t    offset)));\n+\toffset += 8;\n+      }\n+\n+  /* Here is where the local variables were.  As in the prologue, they\n+     might be of an unaligned size.  */\n+  offset += (locals_size + 7) & ~7;\n+\n+\n+  /* The saved register stack pointer is just below the frame-pointer\n+     register.  We don't need to restore it \"manually\"; the POP\n+     instruction does that.  */\n+  if (MMIX_CFUN_HAS_LANDING_PAD)\n+    offset += 16;\n+  else if (MMIX_CFUN_NEEDS_SAVED_EH_RETURN_ADDRESS)\n+    /* The return-address slot is just below the frame-pointer register.\n+       We don't need to restore it because we don't really use it.  */\n+    offset += 8;\n+\n+  /* Get back the old frame-pointer-value.  */\n+  if (frame_pointer_needed)\n+    {\n+      if (offset > 255)\n+\t{\n+\t  mmix_emit_sp_add (offset);\n+\n+\t  stack_space_to_deallocate -= offset;\n+\t  offset = 0;\n+\t}\n+\n+      emit_move_insn (hard_frame_pointer_rtx,\n+\t\t      gen_rtx_MEM (DImode,\n+\t\t\t\t   plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t  offset)));\n+      offset += 8;\n+    }\n+\n+  /* We do not need to restore pretended incoming args, just add back\n+     offset to sp.  */\n+  if (stack_space_to_deallocate != 0)\n+    mmix_emit_sp_add (stack_space_to_deallocate);\n+\n+  if (current_function_calls_eh_return)\n+    /* Adjust the (normal) stack-pointer to that of the receiver.\n+       FIXME: It would be nice if we could also adjust the register stack\n+       here, but we need to express it through DWARF 2 too.  */\n+    emit_insn (gen_adddi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t   gen_rtx_REG (DImode,\n+\t\t\t\t\tMMIX_EH_RETURN_STACKADJ_REGNUM)));\n+}\n+\n /* Output an optimal sequence for setting a register to a specific\n    constant.  Used in an alternative for const_ints in movdi, and when\n    using large stack-frame offsets.\n@@ -2884,6 +2798,48 @@ mmix_gen_compare_reg (code, x, y)\n \n /* Local (static) helper functions.  */\n \n+static void\n+mmix_emit_sp_add (offset)\n+     HOST_WIDE_INT offset;\n+{\n+  rtx insn;\n+\n+  if (offset < 0)\n+    {\n+      /* Negative stack-pointer adjustments are allocations and appear in\n+\t the prologue only.  We mark them as frame-related so unwind and\n+\t debug info is properly emitted for them.  */\n+      if (offset > -255)\n+\tinsn = emit_insn (gen_adddi3 (stack_pointer_rtx,\n+\t\t\t\t      stack_pointer_rtx,\n+\t\t\t\t      GEN_INT (offset)));\n+      else\n+\t{\n+\t  rtx tmpr = gen_rtx_REG (DImode, 255);\n+\t  RTX_FRAME_RELATED_P (emit_move_insn (tmpr, GEN_INT (offset))) = 1;\n+\t  insn = emit_insn (gen_adddi3 (stack_pointer_rtx,\n+\t\t\t\t\tstack_pointer_rtx, tmpr));\n+\t}\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+  else\n+    {\n+      /* Positive adjustments are in the epilogue only.  Don't mark them\n+\t as \"frame-related\" for unwind info.  */\n+      if (CONST_OK_FOR_LETTER_P (offset, 'L'))\n+\temit_insn (gen_adddi3 (stack_pointer_rtx,\n+\t\t\t       stack_pointer_rtx,\n+\t\t\t       GEN_INT (offset)));\n+      else\n+\t{\n+\t  rtx tmpr = gen_rtx_REG (DImode, 255);\n+\t  emit_move_insn (tmpr, GEN_INT (offset));\n+\t  insn = emit_insn (gen_adddi3 (stack_pointer_rtx,\n+\t\t\t\t\tstack_pointer_rtx, tmpr));\n+\t}\n+    }\n+}\n+\n /* Print operator suitable for doing something with a shiftable\n    wyde.  The type of operator is passed as an asm output modifier.  */\n "}, {"sha": "d3dad13fe9e24b13c3be79a50fbf35f3579b2f06", "filename": "gcc/config/mmix/mmix.h", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/957ec0f922c129dac8847f40246dd868044be0f0/gcc%2Fconfig%2Fmmix%2Fmmix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/957ec0f922c129dac8847f40246dd868044be0f0/gcc%2Fconfig%2Fmmix%2Fmmix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.h?ref=957ec0f922c129dac8847f40246dd868044be0f0", "patch": "@@ -49,6 +49,7 @@ Boston, MA 02111-1307, USA.  */\n #define MMIX_HIMULT_REGNUM 258\n #define MMIX_REMAINDER_REGNUM 260\n #define MMIX_ARG_POINTER_REGNUM 261\n+#define MMIX_rO_REGNUM 262\n #define MMIX_LAST_STACK_REGISTER_REGNUM 31\n \n /* Four registers; \"ideally, these registers should be call-clobbered\", so\n@@ -92,6 +93,7 @@ struct machine_function GTY(())\n  {\n    int has_landing_pad;\n    int highest_saved_stack_register;\n+   int in_prologue;\n  };\n \n /* For these target macros, there is no generic documentation here.  You\n@@ -360,13 +362,13 @@ extern int target_flags;\n \n /* Node: Register Basics */\n /* We tell GCC about all 256 general registers, and we also include\n-   rD, rE, rH, rJ and rR (in that order) so we can describe what insns\n+   rD, rE, rH, rJ, rR and rO (in that order) so we can describe what insns\n    clobber them.  We use a faked register for the argument pointer.  It is\n    always eliminated towards the frame-pointer or the stack-pointer, never\n    output in assembly.  Any fixed register would do for this, like $255,\n    but future debugging is easier when using a separate register.  It\n    counts as a global register for pseudorandom reasons.  */\n-#define FIRST_PSEUDO_REGISTER 262\n+#define FIRST_PSEUDO_REGISTER 263\n \n /* We treat general registers with no assigned purpose as fixed.  The\n    stack pointer, $254, is also fixed.  Register $255 is referred to as a\n@@ -390,7 +392,7 @@ extern int target_flags;\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n    1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, \\\n-   1, 1, 0, 0, 0, 1 \\\n+   1, 1, 0, 0, 0, 1, 1 \\\n  }\n \n /* General registers are fixed and therefore \"historically\" marked\n@@ -414,19 +416,23 @@ extern int target_flags;\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, \\\n-   1, 1, 1, 1, 1, 1 \\\n+   1, 1, 1, 1, 1, 1, 1 \\\n  }\n \n #define CONDITIONAL_REGISTER_USAGE mmix_conditional_register_usage ()\n \n-/* No LOCAL_REGNO, INCOMING_REGNO or OUTGOING_REGNO, since those macros\n-   are not usable for MMIX: it doesn't have a fixed register window size.\n-   FIXME: Perhaps we should say something about $0..$15 may sometimes be\n-   the incoming $16..$31.  Those macros need better documentation; it\n-   looks like they're just bogus and that FUNCTION_INCOMING_ARG_REGNO_P\n-   and FUNCTION_OUTGOING_VALUE should be used where they're used.  For the\n+/* No INCOMING_REGNO or OUTGOING_REGNO, since those macros are not usable\n+   for MMIX: it doesn't have a fixed register window size.  FIXME: Perhaps\n+   we should say something about $0..$15 may sometimes be the incoming\n+   $16..$31.  Those macros need better documentation; it looks like\n+   they're just bogus and that FUNCTION_INCOMING_ARG_REGNO_P and\n+   FUNCTION_OUTGOING_VALUE should be used where they're used.  For the\n    moment, do nothing; things seem to work anyway.  */\n \n+/* Defining LOCAL_REGNO is necessary in presence of prologue/epilogue,\n+   else GCC will be confused that those registers aren't saved and\n+   restored.  */\n+#define LOCAL_REGNO(REGNO) mmix_local_regno (REGNO)\n \n /* Node: Allocation Order */\n \n@@ -474,7 +480,7 @@ extern int target_flags;\n    232, 233, 234, 235, 236, 237, 238, 239,\t\\\n    240, 241, 242, 243, 244, 245, 246,\t\t\\\n \t\t\t\t\t\t\\\n-   254, 255, 256, 257, 261 \t\t\t\\\n+   254, 255, 256, 257, 261, 262\t\t\t\\\n  }\n \n /* As a convenience, we put this nearby, for ease of comparison.\n@@ -529,7 +535,7 @@ extern int target_flags;\n    216, 217, 218, 219, 220, 221, 222, 223,\t\\\n    224, 225, 226, 227, 228, 229, 230,\t\t\\\n \t\t\t\t\t\t\\\n-   254, 255, 256, 257, 261 \t\t\t\\\n+   254, 255, 256, 257, 261, 262\t\t\t\\\n  }\n \n /* The default one.  */\n@@ -573,8 +579,8 @@ enum reg_class\n   {~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, 0x20},\t\\\n   {0, 0, 0, 0, 0, 0, 0, 0, 0x10},\t\t\\\n   {0, 0, 0, 0, 0, 0, 0, 0, 4},\t\t\t\\\n-  {0, 0, 0, 0, 0, 0, 0, 0, 0x3f},\t\t\\\n-  {~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, 0x3f}}\n+  {0, 0, 0, 0, 0, 0, 0, 0, 0x7f},\t\t\\\n+  {~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, 0x7f}}\n \n #define REGNO_REG_CLASS(REGNO)\t\t\t\t\t\\\n  ((REGNO) <= MMIX_LAST_GENERAL_REGISTER\t\t\t\t\\\n@@ -1058,11 +1064,11 @@ typedef struct { int regs; int lib; int now_varargs; } CUMULATIVE_ARGS;\n   \"$232\", \"$233\", \"$234\", \"$235\", \"$236\", \"$237\", \"$238\", \"$239\",\t\\\n   \"$240\", \"$241\", \"$242\", \"$243\", \"$244\", \"$245\", \"$246\", \"$247\",\t\\\n   \"$248\", \"$249\", \"$250\", \"$251\", \"$252\", \"$253\", \"$254\", \"$255\",\t\\\n-  \":rD\",  \":rE\",  \":rH\",  \":rJ\",  \":rR\",  \"ap_!BAD!\"}\n+  \":rD\",  \":rE\",  \":rH\",  \":rJ\",  \":rR\",  \"ap_!BAD!\", \":rO\"}\n \n #define ADDITIONAL_REGISTER_NAMES\t\t\t\\\n  {{\"sp\", 254}, {\":sp\", 254}, {\"rD\", 256}, {\"rE\", 257},\t\\\n-  {\"rH\", 258}, {\"rJ\", MMIX_rJ_REGNUM}}\n+  {\"rH\", 258}, {\"rJ\", MMIX_rJ_REGNUM}, {\"rO\", MMIX_rO_REGNUM}}\n \n #define PRINT_OPERAND(STREAM, X, CODE) \\\n  mmix_print_operand (STREAM, X, CODE)"}, {"sha": "88ae51445d651ea33174302bcb88a198f10887f4", "filename": "gcc/config/mmix/mmix.md", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/957ec0f922c129dac8847f40246dd868044be0f0/gcc%2Fconfig%2Fmmix%2Fmmix.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/957ec0f922c129dac8847f40246dd868044be0f0/gcc%2Fconfig%2Fmmix%2Fmmix.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.md?ref=957ec0f922c129dac8847f40246dd868044be0f0", "patch": "@@ -988,7 +988,8 @@ DIVU %1,%1,%2\\;GET %0,:rR\\;NEGU %2,0,%0\\;CSNN %0,$255,%2\")\n      in the call, and we set it back after every call (all but one setting\n      will be optimized away), integrity is maintained.  */\n   operands[3]\n-    = get_hard_reg_initial_val (Pmode, MMIX_INCOMING_RETURN_ADDRESS_REGNUM);\n+    = mmix_get_hard_reg_initial_val (Pmode,\n+\t\t\t\t     MMIX_INCOMING_RETURN_ADDRESS_REGNUM);\n \n   /* FIXME: There's a bug in gcc which causes NULL to be passed as\n      operand[2] when we get out of registers, which later confuses gcc.\n@@ -1014,7 +1015,8 @@ DIVU %1,%1,%2\\;GET %0,:rR\\;NEGU %2,0,%0\\;CSNN %0,$255,%2\")\n      in the call, and we set it back after every call (all but one setting\n      will be optimized away), integrity is maintained.  */\n   operands[4]\n-    = get_hard_reg_initial_val (Pmode, MMIX_INCOMING_RETURN_ADDRESS_REGNUM);\n+    = mmix_get_hard_reg_initial_val (Pmode,\n+\t\t\t\t     MMIX_INCOMING_RETURN_ADDRESS_REGNUM);\n \n   /* FIXME: See 'call'.  */\n   if (operands[3] == NULL_RTX)\n@@ -1067,11 +1069,30 @@ DIVU %1,%1,%2\\;GET %0,:rR\\;NEGU %2,0,%0\\;CSNN %0,$255,%2\")\n ;; I hope untyped_call and untyped_return are not needed for MMIX.\n ;; Users of Objective C will notice.\n \n-(define_insn \"return\"\n+; Generated by GCC.\n+(define_expand \"return\"\n   [(return)]\n   \"mmix_use_simple_return ()\"\n+  \"\")\n+\n+; Generated by the epilogue expander.\n+(define_insn \"*expanded_return\"\n+  [(return)]\n+  \"\"\n   \"POP %.,0\")\n \n+(define_expand \"prologue\"\n+  [(const_int 0)]\n+  \"\"\n+  \"mmix_expand_prologue (); DONE;\")\n+\n+; Note that the (return) from the expander itself is always the last insn\n+; in the epilogue.\n+(define_expand \"epilogue\"\n+  [(return)]\n+  \"\"\n+  \"mmix_expand_epilogue ();\")\n+\n (define_insn \"nop\"\n   [(const_int 0)]\n   \"\"\n@@ -1111,7 +1132,8 @@ DIVU %1,%1,%2\\;GET %0,:rR\\;NEGU %2,0,%0\\;CSNN %0,$255,%2\")\n   \"\n {\n   operands[0]\n-    = get_hard_reg_initial_val (Pmode, MMIX_INCOMING_RETURN_ADDRESS_REGNUM);\n+    = mmix_get_hard_reg_initial_val (Pmode,\n+\t\t\t\t     MMIX_INCOMING_RETURN_ADDRESS_REGNUM);\n \n   /* Mark this function as containing a landing-pad.  */\n   cfun->machine->has_landing_pad = 1;"}]}