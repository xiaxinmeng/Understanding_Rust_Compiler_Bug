{"sha": "d088acea7d5f2f530507f187cfbecaeb00abe0d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDA4OGFjZWE3ZDVmMmY1MzA1MDdmMTg3Y2ZiZWNhZWIwMGFiZTBkNg==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2003-09-15T23:07:29Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2003-09-15T23:07:29Z"}, "message": "gcse.c (remove_reachable_equiv_notes): New.\n\n\n\n\t* gcse.c (remove_reachable_equiv_notes): New.\n\t(replace_store_insn): Call it.  Update antic list.\n\t(store_killed_in_insn): Take REG_EQUAL notes into account.\n\t(build_store_vectors, delete_store): Add parameter to\n\treplace_store_insn call.\n\nCo-Authored-By: Jeff Law <law@redhat.com>\n\nFrom-SVN: r71412", "tree": {"sha": "0da785b84d9e122100db0169a3eaa4d2cefd77ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0da785b84d9e122100db0169a3eaa4d2cefd77ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d088acea7d5f2f530507f187cfbecaeb00abe0d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d088acea7d5f2f530507f187cfbecaeb00abe0d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d088acea7d5f2f530507f187cfbecaeb00abe0d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d088acea7d5f2f530507f187cfbecaeb00abe0d6/comments", "author": null, "committer": null, "parents": [{"sha": "b9397bb40b4f5dd289adfbe54e52e995d5e98c2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9397bb40b4f5dd289adfbe54e52e995d5e98c2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9397bb40b4f5dd289adfbe54e52e995d5e98c2c"}], "stats": {"total": 146, "additions": 137, "deletions": 9}, "files": [{"sha": "906b771ab1366b33e81034991d191969fb976506", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d088acea7d5f2f530507f187cfbecaeb00abe0d6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d088acea7d5f2f530507f187cfbecaeb00abe0d6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d088acea7d5f2f530507f187cfbecaeb00abe0d6", "patch": "@@ -1,3 +1,12 @@\n+2003-09-15  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\t    Jeff Law  <law@redhat.com>\n+\n+\t* gcse.c (remove_reachable_equiv_notes): New.\n+\treplace_store_insn): Call it.  Update antic list.\n+\t(store_killed_in_insn): Take REG_EQUAL notes into account.\n+\t(build_store_vectors, delete_store): Add parameter to\n+\treplace_store_insn call.\n+\n 2003-09-15  Bob Wilson  <bob.wilson@acm.org>\n \n \t* config/xtensa/xtensa.h (LEGITIMATE_PIC_OPERAND_P): Use"}, {"sha": "f50c2d9a01e402d57902c413021035bda7713c92", "filename": "gcc/gcse.c", "status": "modified", "additions": 128, "deletions": 9, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d088acea7d5f2f530507f187cfbecaeb00abe0d6/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d088acea7d5f2f530507f187cfbecaeb00abe0d6/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=d088acea7d5f2f530507f187cfbecaeb00abe0d6", "patch": "@@ -692,7 +692,8 @@ static bool store_killed_before (rtx, rtx, rtx, basic_block, int *);\n static void build_store_vectors (void);\n static void insert_insn_start_bb (rtx, basic_block);\n static int insert_store (struct ls_expr *, edge);\n-static void replace_store_insn (rtx, rtx, basic_block);\n+static void remove_reachable_equiv_notes (basic_block, struct ls_expr *);\n+static void replace_store_insn (rtx, rtx, basic_block, struct ls_expr *);\n static void delete_store (struct ls_expr *, basic_block);\n static void free_store_memory (void);\n static void store_motion (void);\n@@ -7254,7 +7255,7 @@ find_loads (rtx x, rtx store_pattern, int after)\n static bool\n store_killed_in_insn (rtx x, rtx x_regs, rtx insn, int after)\n {\n-  rtx reg, base;\n+  rtx reg, base, note;\n \n   if (!INSN_P (insn))\n     return false;\n@@ -7305,10 +7306,26 @@ store_killed_in_insn (rtx x, rtx x_regs, rtx insn, int after)\n \t\treturn true;\n \t    }\n \t}\n-      return find_loads (SET_SRC (pat), x, after);\n+      if (find_loads (SET_SRC (pat), x, after))\n+\treturn true;\n     }\n-  else\n-    return find_loads (PATTERN (insn), x, after);\n+  else if (find_loads (PATTERN (insn), x, after))\n+    return true;\n+\n+  /* If this insn has a REG_EQUAL or REG_EQUIV note referencing a memory\n+     location aliased with X, then this insn kills X.  */\n+  note = find_reg_equal_equiv_note (insn);\n+  if (! note)\n+    return false;\n+  note = XEXP (note, 0);\n+\n+  /* However, if the note represents a must alias rather than a may\n+     alias relationship, then it does not kill X.  */\n+  if (expr_equiv_p (note, x))\n+    return false;\n+\n+  /* See if there are any aliased loads in the note.  */\n+  return find_loads (note, x, after);\n }\n \n /* Returns true if the expression X is loaded or clobbered on or after INSN\n@@ -7396,7 +7413,7 @@ build_store_vectors (void)\n \t      rtx r = gen_reg_rtx (GET_MODE (ptr->pattern));\n \t      if (gcse_file)\n \t\tfprintf (gcse_file, \"Removing redundant store:\\n\");\n-\t      replace_store_insn (r, XEXP (st, 0), bb);\n+\t      replace_store_insn (r, XEXP (st, 0), bb, ptr);\n \t      continue;\n \t    }\n \t  SET_BIT (ae_gen[bb->index], ptr->index);\n@@ -7551,13 +7568,87 @@ insert_store (struct ls_expr * expr, edge e)\n   return 1;\n }\n \n+/* Remove any REG_EQUAL or REG_EQUIV notes containing a reference to the\n+   memory location in SMEXPR set in basic block BB.\n+\n+   This could be rather expensive.  */\n+\n+static void\n+remove_reachable_equiv_notes (basic_block bb, struct ls_expr *smexpr)\n+{\n+  edge *stack = xmalloc (sizeof (edge) * n_basic_blocks), act;\n+  sbitmap visited = sbitmap_alloc (last_basic_block);\n+  int stack_top = 0;\n+  rtx last, insn, note;\n+  rtx mem = smexpr->pattern;\n+\n+  sbitmap_zero (visited);\n+  act = bb->succ;\n+\n+  while (1)\n+    {\n+      if (!act)\n+\t{\n+\t  if (!stack_top)\n+\t    {\n+\t      free (stack);\n+\t      sbitmap_free (visited);\n+\t      return;\n+\t    }\n+\t  act = stack[--stack_top];\n+\t}\n+      bb = act->dest;\n+      \n+      if (bb == EXIT_BLOCK_PTR\n+\t  || TEST_BIT (visited, bb->index)\n+\t  || TEST_BIT (ae_kill[bb->index], smexpr->index))\n+\t{\n+\t  act = act->succ_next;\n+\t  continue;\n+\t}\n+      SET_BIT (visited, bb->index);\n+\n+      if (TEST_BIT (st_antloc[bb->index], smexpr->index))\n+\t{\n+\t  for (last = ANTIC_STORE_LIST (smexpr);\n+\t       BLOCK_FOR_INSN (XEXP (last, 0)) != bb;\n+\t       last = XEXP (last, 1))\n+\t    continue;\n+\t  last = XEXP (last, 0);\n+\t}\n+      else\n+\tlast = NEXT_INSN (bb->end);\n+  \n+      for (insn = bb->head; insn != last; insn = NEXT_INSN (insn))\n+\tif (INSN_P (insn))\n+\t  {\n+\t    note = find_reg_equal_equiv_note (insn);\n+\t    if (!note || !expr_equiv_p (XEXP (note, 0), mem))\n+\t      continue;\n+\n+\t    if (gcse_file)\n+\t      fprintf (gcse_file, \"STORE_MOTION  drop REG_EQUAL note at insn %d:\\n\",\n+\t\t       INSN_UID (insn));\n+\t    remove_note (insn, note);\n+\t  }\n+      act = act->succ_next;\n+      if (bb->succ)\n+\t{\n+\t  if (act)\n+\t    stack[stack_top++] = act;\n+\t  act = bb->succ;\n+\t}\n+    }\n+}\n+\n /* This routine will replace a store with a SET to a specified register.  */\n \n static void\n-replace_store_insn (rtx reg, rtx del, basic_block bb)\n+replace_store_insn (rtx reg, rtx del, basic_block bb, struct ls_expr *smexpr)\n {\n-  rtx insn;\n+  rtx insn, mem, note, set, ptr;\n \n+  mem = smexpr->pattern;\n   insn = gen_move_insn (reg, SET_SRC (single_set (del)));\n   insn = emit_insn_after (insn, del);\n \n@@ -7571,7 +7662,35 @@ replace_store_insn (rtx reg, rtx del, basic_block bb)\n       fprintf (gcse_file, \"\\n\");\n     }\n \n+  for (ptr = ANTIC_STORE_LIST (smexpr); ptr; ptr = XEXP (ptr, 1))\n+    if (XEXP (ptr, 0) == del)\n+      {\n+\tXEXP (ptr, 0) = insn;\n+\tbreak;\n+      }\n   delete_insn (del);\n+\n+  /* Now we must handle REG_EQUAL notes whose contents is equal to the mem;\n+     they are no longer accurate provided that they are reached by this\n+     definition, so drop them.  */\n+  for (; insn != NEXT_INSN (bb->end); insn = NEXT_INSN (insn))\n+    if (INSN_P (insn))\n+      {\n+\tset = single_set (insn);\n+\tif (!set)\n+\t  continue;\n+\tif (expr_equiv_p (SET_DEST (set), mem))\n+\t  return;\n+\tnote = find_reg_equal_equiv_note (insn);\n+\tif (!note || !expr_equiv_p (XEXP (note, 0), mem))\n+\t  continue;\n+\n+\tif (gcse_file)\n+\t  fprintf (gcse_file, \"STORE_MOTION  drop REG_EQUAL note at insn %d:\\n\",\n+\t\t   INSN_UID (insn));\n+\tremove_note (insn, note);\n+      }\n+  remove_reachable_equiv_notes (bb, smexpr);\n }\n \n \n@@ -7595,7 +7714,7 @@ delete_store (struct ls_expr * expr, basic_block bb)\n \t{\n \t  /* We know there is only one since we deleted redundant\n \t     ones during the available computation.  */\n-\t  replace_store_insn (reg, del, bb);\n+\t  replace_store_insn (reg, del, bb, expr);\n \t  break;\n \t}\n     }"}]}