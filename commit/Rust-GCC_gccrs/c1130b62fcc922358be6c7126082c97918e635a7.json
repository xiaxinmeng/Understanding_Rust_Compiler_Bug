{"sha": "c1130b62fcc922358be6c7126082c97918e635a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzExMzBiNjJmY2M5MjIzNThiZTZjNzEyNjA4MmM5NzkxOGU2MzVhNw==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2007-07-04T22:11:14Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2007-07-04T22:11:14Z"}, "message": "re PR tree-optimization/32604 (miscompilation at -O2)\n\n2007-07-04  Daniel Berlin  <dberlin@dberlin.org>\n\n\tPR tree-optimization/32604\n\tPR tree-optimization/32606\n\t\n\t* tree-ssa-pre.c (bb_bitmap_sets): Removed antic_safe_loads.\n\t(compute_antic_safe): Removed.\n\t(ANTIC_SAFE_LOADS): Ditto.\n\t(compute_antic_aux): Don't print ANTIC_SAFE_LOADS.\n\t(execute_pre): Don't call compute_antic_safe.\n\t(vuse_equiv): New function.\n\t(make_values_for_stmt): Use it\n\t* tree-ssa-sccvn.c (set_ssa_val_to): Remove assert, since it is\n\tnot always true.\n\nFrom-SVN: r126338", "tree": {"sha": "7272a49f1cbf9d9cb1aace024bdd6f07a6145473", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7272a49f1cbf9d9cb1aace024bdd6f07a6145473"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c1130b62fcc922358be6c7126082c97918e635a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1130b62fcc922358be6c7126082c97918e635a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1130b62fcc922358be6c7126082c97918e635a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1130b62fcc922358be6c7126082c97918e635a7/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "44190aed5ed111b27b8d1be4fa5e4d406dafed86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44190aed5ed111b27b8d1be4fa5e4d406dafed86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44190aed5ed111b27b8d1be4fa5e4d406dafed86"}], "stats": {"total": 217, "additions": 128, "deletions": 89}, "files": [{"sha": "fd784786bcc64cc040a5b9af40e4215ac59a727a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1130b62fcc922358be6c7126082c97918e635a7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1130b62fcc922358be6c7126082c97918e635a7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c1130b62fcc922358be6c7126082c97918e635a7", "patch": "@@ -1,3 +1,18 @@\n+2007-07-04  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\tPR tree-optimization/32604\n+\tPR tree-optimization/32606\n+\t\n+\t* tree-ssa-pre.c (bb_bitmap_sets): Removed antic_safe_loads.\n+\t(compute_antic_safe): Removed.\n+\t(ANTIC_SAFE_LOADS): Ditto.\n+\t(compute_antic_aux): Don't print ANTIC_SAFE_LOADS.\n+\t(execute_pre): Don't call compute_antic_safe.\n+\t(vuse_equiv): New function.\n+\t(make_values_for_stmt): Use it\n+\t* tree-ssa-sccvn.c (set_ssa_val_to): Remove assert, since it is\n+\tnot always true.\n+\n 2007-07-04 Anatoly Sokolov <aesok@post.ru>\n \n \tPR target/31331"}, {"sha": "fe151202a3bdc62968eeefbd1c9914e0ee897043", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1130b62fcc922358be6c7126082c97918e635a7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1130b62fcc922358be6c7126082c97918e635a7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c1130b62fcc922358be6c7126082c97918e635a7", "patch": "@@ -1,3 +1,8 @@\n+2007-07-04  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* gcc.c-torture/compile/pr32606.c: New.\n+\t* gfortran.fortran-torture/execute/pr32604.f90: New.\n+\n 2007-07-04  Mark Mitchell  <mark@codesourcery.com>\n \n \t* gcc.dg/visibility-12.c: New test."}, {"sha": "91348c40e06460ebac53f65da2a923f7ff6875b6", "filename": "gcc/testsuite/gcc.c-torture/compile/pr32606.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1130b62fcc922358be6c7126082c97918e635a7/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr32606.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1130b62fcc922358be6c7126082c97918e635a7/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr32606.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr32606.c?ref=c1130b62fcc922358be6c7126082c97918e635a7", "patch": "@@ -0,0 +1,30 @@\n+int inb(int);\n+void is870(unsigned int wkport, unsigned char j)\n+{\n+ unsigned int tmport;\n+ unsigned char i;\n+ for (i = 0; i < 16; i++)\n+ {\n+  tmport = wkport + 0x18;\n+  tmport += 0x07;\n+  while ((inb(tmport) & 0x80) == 0)\n+  {\n+   if ((inb(tmport) & 0x01) != 0)\n+   {\n+    tmport -= 0x06;\n+    tmport += 0x06;\n+   }\n+  }\n+  tmport = wkport + 0x14;\n+  tmport += 0x04;\n+  tmport += 0x07;\n+widep_in1:\n+  if ((j & 0x01) != 0)\n+  {\n+   tmport -= 0x06;\n+   tmport += 0x06;\n+   goto widep_in1;\n+  }\n+  while ((inb(tmport) & 0x80) == 0) {}\n+ }\n+}"}, {"sha": "3eac72907cc4d85cb44562b9aa5772ec4c6e27da", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/pr32604.f90", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1130b62fcc922358be6c7126082c97918e635a7/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fpr32604.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1130b62fcc922358be6c7126082c97918e635a7/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fpr32604.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fpr32604.f90?ref=c1130b62fcc922358be6c7126082c97918e635a7", "patch": "@@ -0,0 +1,61 @@\n+MODULE TEST\n+  IMPLICIT NONE\n+  INTEGER, PARAMETER :: dp=KIND(0.0D0)\n+  TYPE mulliken_restraint_type\n+    INTEGER                         :: ref_count\n+    REAL(KIND = dp)                 :: strength\n+    REAL(KIND = dp)                 :: TARGET\n+    INTEGER                         :: natoms\n+    INTEGER, POINTER, DIMENSION(:)  :: atoms\n+  END TYPE mulliken_restraint_type\n+CONTAINS\n+  SUBROUTINE INIT(mulliken)\n+   TYPE(mulliken_restraint_type), INTENT(INOUT) :: mulliken\n+   ALLOCATE(mulliken%atoms(1))\n+   mulliken%atoms(1)=1\n+   mulliken%natoms=1\n+   mulliken%target=0\n+   mulliken%strength=0\n+  END SUBROUTINE INIT\n+  SUBROUTINE restraint_functional(mulliken_restraint_control,charges, &\n+                                charges_deriv,energy,order_p)\n+    TYPE(mulliken_restraint_type), &\n+      INTENT(IN)                             :: mulliken_restraint_control\n+    REAL(KIND=dp), DIMENSION(:, :), POINTER  :: charges, charges_deriv\n+    REAL(KIND=dp), INTENT(OUT)               :: energy, order_p\n+\n+    INTEGER                                  :: I\n+    REAL(KIND=dp)                            :: dum\n+\n+    charges_deriv=0.0_dp\n+    order_p=0.0_dp\n+\n+    DO I=1,mulliken_restraint_control%natoms\n+       order_p=order_p+charges(mulliken_restraint_control%atoms(I),1) &\n+                      -charges(mulliken_restraint_control%atoms(I),2)\n+    ENDDO\n+   \n+energy=mulliken_restraint_control%strength*(order_p-mulliken_restraint_control%target)**2\n+   \n+dum=2*mulliken_restraint_control%strength*(order_p-mulliken_restraint_control%target)\n+    DO I=1,mulliken_restraint_control%natoms\n+       charges_deriv(mulliken_restraint_control%atoms(I),1)=  dum\n+       charges_deriv(mulliken_restraint_control%atoms(I),2)= -dum\n+    ENDDO\n+END SUBROUTINE restraint_functional\n+\n+END MODULE\n+\n+    USE TEST\n+    IMPLICIT NONE\n+    TYPE(mulliken_restraint_type) :: mulliken\n+    REAL(KIND=dp), DIMENSION(:, :), POINTER  :: charges, charges_deriv\n+    REAL(KIND=dp) :: energy,order_p\n+    ALLOCATE(charges(1,2),charges_deriv(1,2))\n+    charges(1,1)=2.0_dp\n+    charges(1,2)=1.0_dp\n+    CALL INIT(mulliken)\n+    CALL restraint_functional(mulliken,charges,charges_deriv,energy,order_p)\n+    write(6,*) order_p\n+END\n+"}, {"sha": "ce70a2609f5277df7180d154b50590de2d5a9203", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 17, "deletions": 81, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1130b62fcc922358be6c7126082c97918e635a7/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1130b62fcc922358be6c7126082c97918e635a7/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=c1130b62fcc922358be6c7126082c97918e635a7", "patch": "@@ -302,10 +302,6 @@ typedef struct bb_bitmap_sets\n      the current iteration.  */\n   bitmap_set_t new_sets;\n \n-  /* These are the loads that will be ANTIC_IN at the top of the\n-     block, and are actually generated in the block.  */\n-  bitmap_set_t antic_safe_loads;\n-\n   /* True if we have visited this block during ANTIC calculation.  */\n   unsigned int visited:1;\n \n@@ -321,7 +317,6 @@ typedef struct bb_bitmap_sets\n #define ANTIC_IN(BB)\t((bb_value_sets_t) ((BB)->aux))->antic_in\n #define PA_IN(BB)\t((bb_value_sets_t) ((BB)->aux))->pa_in\n #define NEW_SETS(BB)\t((bb_value_sets_t) ((BB)->aux))->new_sets\n-#define ANTIC_SAFE_LOADS(BB) ((bb_value_sets_t) ((BB)->aux))->antic_safe_loads\n #define BB_VISITED(BB) ((bb_value_sets_t) ((BB)->aux))->visited\n #define BB_DEFERRED(BB) ((bb_value_sets_t) ((BB)->aux))->deferred\n \n@@ -1545,9 +1540,7 @@ valid_in_sets (bitmap_set_t set1, bitmap_set_t set2, tree expr,\n \t\t    && !union_contains_value (set1, set2, op3))\n \t\t  return false;\n \t    }\n-\t  return bitmap_set_contains_value (ANTIC_SAFE_LOADS (block),\n-\t\t\t\t\t    vh)\n-\t    || !value_dies_in_block_x (vh, block);\n+\t    return !value_dies_in_block_x (vh, block);\n \t  }\n       }\n       return false;\n@@ -1786,9 +1779,6 @@ compute_antic_aux (basic_block block, bool block_has_abnormal_pred_edge)\n \t  if (ANTIC_OUT)\n \t    print_bitmap_set (dump_file, ANTIC_OUT, \"ANTIC_OUT\", block->index);\n \n-\t  if (ANTIC_SAFE_LOADS (block))\n-\t    print_bitmap_set (dump_file, ANTIC_SAFE_LOADS (block),\n-\t\t\t      \"ANTIC_SAFE_LOADS\", block->index);\n \t  print_bitmap_set (dump_file, ANTIC_IN (block), \"ANTIC_IN\",\n \t\t\t    block->index);\n \n@@ -2042,74 +2032,6 @@ compute_antic (void)\n   sbitmap_free (changed_blocks);\n }\n \n-/*\n-   ANTIC_SAFE_LOADS are those loads generated in a block that actually\n-   occur before any kill to their vuses in the block, and thus, are\n-   safe at the top of the block.  This function computes the set by\n-   walking the EXP_GEN set for the block, and checking the VUSES.\n-\n-   This set could be computed as ANTIC calculation is proceeding, but\n-   but because it does not actually change during that computation, it is\n-   quicker to pre-calculate the results and use them than to do it on\n-   the fly (particularly in the presence of multiple iteration).  */\n-\n-static void\n-compute_antic_safe (void)\n-{\n-  basic_block bb;\n-  bitmap_iterator bi;\n-  unsigned int i;\n-\n-  FOR_EACH_BB (bb)\n-    {\n-      FOR_EACH_EXPR_ID_IN_SET (EXP_GEN (bb), i, bi)\n-\t{\n-\t  tree expr = expression_for_id (i);\n-\t  if (REFERENCE_CLASS_P (expr))\n-\t    {\n-\t      tree vh = get_value_handle (expr);\n-\t      tree maybe = bitmap_find_leader (AVAIL_OUT (bb), vh);\n-\t      ssa_op_iter i;\n-\t      tree vuse;\n-\t      tree stmt;\n-\t      bool okay = true;\n-\n-\t      if (!maybe)\n-\t\tcontinue;\n-\t      stmt = SSA_NAME_DEF_STMT (maybe);\n-\t      if (TREE_CODE (stmt) == PHI_NODE)\n-\t\tcontinue;\n-\t      \n-\t      FOR_EACH_SSA_TREE_OPERAND (vuse, stmt, i,\n-\t\t\t\t\t SSA_OP_VIRTUAL_USES)\n-\t\t{\n-\t\t  tree def = SSA_NAME_DEF_STMT (vuse);\n-\n-\t\t  if (bb_for_stmt (def) != bb)\n-\t\t    continue;\n-\n-\t\t  /* See if the vuse is defined by a statement that\n-\t\t     comes before us in the block.  Phi nodes are not\n-\t\t     stores, so they do not count.  */\n-\t\t  if (TREE_CODE (def) != PHI_NODE\n-\t\t      && stmt_ann (def)->uid < stmt_ann (stmt)->uid)\n-\t\t    {\n-\t\t      okay = false;\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-\t      if (okay)\n-\t\t{\n-\t\t  if (ANTIC_SAFE_LOADS (bb) == NULL)\n-\t\t    ANTIC_SAFE_LOADS (bb) = bitmap_set_new ();\n-\t\t  bitmap_value_insert_into_set (ANTIC_SAFE_LOADS (bb),\n-\t\t\t\t\t\texpr);\n-\t\t}\n-\t    }\n-\t}\n-    }\n-}\n-\n /* Return true if we can value number the call in STMT.  This is true\n    if we have a pure or constant call.  */\n \n@@ -3367,6 +3289,21 @@ make_values_for_phi (tree phi, basic_block block)\n     }\n }\n \n+/* Return true if both the statement and the value handles have no\n+   vuses, or both the statement and the value handle do have vuses.  \n+\n+   Unlike SCCVN, PRE needs not only to know equivalence, but what the\n+   actual vuses are so it can translate them through blocks.  Thus,\n+   we have to make a new value handle if the existing one has no\n+   vuses but needs them.  */\n+\n+static bool\n+vuse_equiv (tree vh1, tree stmt)\n+{\n+  bool stmt_has_vuses = !ZERO_SSA_OPERANDS (stmt, SSA_OP_VIRTUAL_USES);\n+  return (VALUE_HANDLE_VUSES (vh1) && stmt_has_vuses)\n+    || (!VALUE_HANDLE_VUSES (vh1) && !stmt_has_vuses);\n+}\n \n /* Create value handles for STMT in BLOCK.  Return true if we handled\n    the statement.  */\n@@ -3416,7 +3353,7 @@ make_values_for_stmt (tree stmt, basic_block block)\n \t{\n \t  /* If we already have a value number for the LHS, reuse\n \t     it rather than creating a new one.  */\n-\t  if (lhsval)\n+\t  if (lhsval && vuse_equiv (lhsval, stmt))\n \t    {\n \t      set_value_handle (newt, lhsval);\n \t      if (!is_gimple_min_invariant (lhsval))\n@@ -4001,7 +3938,6 @@ execute_pre (bool do_fre)\n      computing ANTIC, either, even though it's plenty fast.  */\n   if (!do_fre && n_basic_blocks < 4000)\n     {\n-      compute_antic_safe ();\n       compute_antic ();\n       insert ();\n     }"}, {"sha": "9036e2ed6f9c2f3fce8205b1f564e00fbb035435", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1130b62fcc922358be6c7126082c97918e635a7/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1130b62fcc922358be6c7126082c97918e635a7/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=c1130b62fcc922358be6c7126082c97918e635a7", "patch": "@@ -1017,14 +1017,6 @@ set_ssa_val_to (tree from, tree to)\n   tree currval;\n   gcc_assert (to != NULL);\n \n-  /* Make sure we don't create chains of copies, so that we get the\n-     best value numbering.  visit_copy has code to make sure this doesn't\n-     happen, we are doing this here to assert that nothing else breaks\n-     this.  */\n-  gcc_assert (TREE_CODE (to) != SSA_NAME\n-\t      || TREE_CODE (SSA_VAL (to)) != SSA_NAME\n-\t      || SSA_VAL (to) == to\n-\t      || to == from);\n   /* The only thing we allow as value numbers are ssa_names and\n      invariants.  So assert that here.  */\n   gcc_assert (TREE_CODE (to) == SSA_NAME || is_gimple_min_invariant (to));"}]}