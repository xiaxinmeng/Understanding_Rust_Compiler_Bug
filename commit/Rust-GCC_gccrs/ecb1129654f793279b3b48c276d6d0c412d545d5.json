{"sha": "ecb1129654f793279b3b48c276d6d0c412d545d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWNiMTEyOTY1NGY3OTMyNzliM2I0OGMyNzZkNmQwYzQxMmQ1NDVkNQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2016-12-26T19:00:47Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2016-12-26T19:00:47Z"}, "message": "re PR target/78904 (zero-extracts are not effective)\n\n\tPR target/78904\n\t* config/i386/i386.md (addqi_ext_1): Canonicalize insn pattern w.r.t.\n\tzero_extract RTXes.\n\t(*addqi_ext_2): Ditto.\n\t(testqi_ext_ccno_0): Canonicalize expander w.r.t. zero_extract RTXes.\n\t(testqi_ext_1_ccno): Rename from testqi_ext_ccno_0.\n\t(*testqi_ext_0): Merge with *testqi_ext_1.\n\t(*testqi_ext_1): Canonicalize insn pattern w.r.t. zero_extract RTXes.\n\tUpdate corresponding splitter.\n\t(*testqi_ext_2): Canonicalize insn pattern w.r.t. zero_extract RTXes.\n\t(*andqi_ext_0): Merge with *andqi_ext_1.\n\t(andqi_ext_1): Canonicalize insn pattern w.r.t. zero_extract RTXes.\n\tRename from *andqi_ext_1.  Update corresponding splitter and\n\tpeephole2 patterns.\n\t(*andqi_ext_1_cc): Rename from *andqi_ext_0_cc.\n\t(*andqi_ext_2): Canonicalize insn pattern w.r.t. zero_extract RTXes.\n\t(*<any_or:code>qi_ext_0): Merge with *andqi_ext_1.\n\t(*<any_or:code>qi_ext_1): Canonicalize insn pattern w.r.t.\n\tzero_extract RTXes.  Update corresponding splitter.\n\t(*<any_or:code>qi_ext_2): Canonicalize insn pattern w.r.t.\n\tzero_extract RTXes.\n\t(xorqi_cc_ext_1): Canonicalize expander w.r.t. zero_extract RTXes.\n\t(xorqi_ext_1_cc): Rename from xorqi_cc_ext_1.\n\t(*xorqi_cc_ext_1): Canonicalize insn pattern w.r.t. zero_extract RTXes.\n\tUpdate corresponding splitter.\n\t(*xorqi_ext_1_cc): Rename from *xorqi_cc_ext_1.\n\t(isinfxf2): Update calls to renamed expanders.\n\t(isinf<mode>2): Ditto.\n\t* config/i386/i386.c (ix86_expand_fp_compare): Ditto.\n\t(ix86_emit_fp_unordered_jump): Ditto.\n\t(ix86_emit_i387_round): Ditto.\n\ntestsuite/ChangeLog:\n\n\tPR target/78904\n\t* gcc.target/i386/pr78904.c: New test.\n\nFrom-SVN: r243929", "tree": {"sha": "ac5f4047326d63f8b746042d39e44bb160463a20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac5f4047326d63f8b746042d39e44bb160463a20"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ecb1129654f793279b3b48c276d6d0c412d545d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecb1129654f793279b3b48c276d6d0c412d545d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ecb1129654f793279b3b48c276d6d0c412d545d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecb1129654f793279b3b48c276d6d0c412d545d5/comments", "author": null, "committer": null, "parents": [{"sha": "dfcbd6b3da9a9cc08df2339a8c29ade1b3d8368c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfcbd6b3da9a9cc08df2339a8c29ade1b3d8368c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfcbd6b3da9a9cc08df2339a8c29ade1b3d8368c"}], "stats": {"total": 548, "additions": 301, "deletions": 247}, "files": [{"sha": "e7865bdf7b5ab69848854caaa8e1fe6a77a65f12", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecb1129654f793279b3b48c276d6d0c412d545d5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecb1129654f793279b3b48c276d6d0c412d545d5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ecb1129654f793279b3b48c276d6d0c412d545d5", "patch": "@@ -1,3 +1,37 @@\n+2016-12-26  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\tPR target/78904\n+\t* config/i386/i386.md (addqi_ext_1): Canonicalize insn pattern w.r.t.\n+\tzero_extract RTXes.\n+\t(*addqi_ext_2): Ditto.\n+\t(testqi_ext_ccno_0): Canonicalize expander w.r.t. zero_extract RTXes.\n+\t(testqi_ext_1_ccno): Rename from testqi_ext_ccno_0.\n+\t(*testqi_ext_0): Merge with *testqi_ext_1.\n+\t(*testqi_ext_1): Canonicalize insn pattern w.r.t. zero_extract RTXes.\n+\tUpdate corresponding splitter.\n+\t(*testqi_ext_2): Canonicalize insn pattern w.r.t. zero_extract RTXes.\n+\t(*andqi_ext_0): Merge with *andqi_ext_1.\n+\t(andqi_ext_1): Canonicalize insn pattern w.r.t. zero_extract RTXes.\n+\tRename from *andqi_ext_1.  Update corresponding splitter and\n+\tpeephole2 patterns.\n+\t(*andqi_ext_1_cc): Rename from *andqi_ext_0_cc.\n+\t(*andqi_ext_2): Canonicalize insn pattern w.r.t. zero_extract RTXes.\n+\t(*<any_or:code>qi_ext_0): Merge with *andqi_ext_1.\n+\t(*<any_or:code>qi_ext_1): Canonicalize insn pattern w.r.t.\n+\tzero_extract RTXes.  Update corresponding splitter.\n+\t(*<any_or:code>qi_ext_2): Canonicalize insn pattern w.r.t.\n+\tzero_extract RTXes.\n+\t(xorqi_cc_ext_1): Canonicalize expander w.r.t. zero_extract RTXes.\n+\t(xorqi_ext_1_cc): Rename from xorqi_cc_ext_1.\n+\t(*xorqi_cc_ext_1): Canonicalize insn pattern w.r.t. zero_extract RTXes.\n+\tUpdate corresponding splitter.\n+\t(*xorqi_ext_1_cc): Rename from *xorqi_cc_ext_1.\n+\t(isinfxf2): Update calls to renamed expanders.\n+\t(isinf<mode>2): Ditto.\n+\t* config/i386/i386.c (ix86_expand_fp_compare): Ditto.\n+\t(ix86_emit_fp_unordered_jump): Ditto.\n+\t(ix86_emit_i387_round): Ditto.\n+\n 2016-12-26  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* doc/invoke.texi (SPARC options): Add missing documentation for -mlra.\n@@ -89,7 +123,8 @@\n \t(rs6000_option_optimization_table): Enable -fsched-pressure.\n \t* config/rs6000/rs6000.c (TARGET_COMPUTE_PRESSURE_CLASSES): Define\n \ttarget hook.\n-\t(rs6000_option_override_internal): Set default -fsched-pressure algorithm.\n+\t(rs6000_option_override_internal): Set default -fsched-pressure\n+\talgorithm.\n \t(rs6000_compute_pressure_classes): Implement target hook.\n \n 2016-12-21  Bill Seurer  <seurer@linux.vnet.ibm.com>"}, {"sha": "624f0699e660b18a8453eb46878cad5e094beb73", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecb1129654f793279b3b48c276d6d0c412d545d5/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecb1129654f793279b3b48c276d6d0c412d545d5/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=ecb1129654f793279b3b48c276d6d0c412d545d5", "patch": "@@ -22585,12 +22585,12 @@ ix86_expand_fp_compare (enum rtx_code code, rtx op0, rtx op1, rtx scratch)\n \tcase UNGT:\n \t  if (code == GT || !TARGET_IEEE_FP)\n \t    {\n-\t      emit_insn (gen_testqi_ext_ccno_0 (scratch, GEN_INT (0x45)));\n+\t      emit_insn (gen_testqi_ext_1_ccno (scratch, GEN_INT (0x45)));\n \t      code = EQ;\n \t    }\n \t  else\n \t    {\n-\t      emit_insn (gen_andqi_ext_0 (scratch, scratch, GEN_INT (0x45)));\n+\t      emit_insn (gen_andqi_ext_1 (scratch, scratch, GEN_INT (0x45)));\n \t      emit_insn (gen_addqi_ext_1 (scratch, scratch, constm1_rtx));\n \t      emit_insn (gen_cmpqi_ext_3 (scratch, GEN_INT (0x44)));\n \t      intcmp_mode = CCmode;\n@@ -22601,84 +22601,84 @@ ix86_expand_fp_compare (enum rtx_code code, rtx op0, rtx op1, rtx scratch)\n \tcase UNLT:\n \t  if (code == LT && TARGET_IEEE_FP)\n \t    {\n-\t      emit_insn (gen_andqi_ext_0 (scratch, scratch, GEN_INT (0x45)));\n+\t      emit_insn (gen_andqi_ext_1 (scratch, scratch, GEN_INT (0x45)));\n \t      emit_insn (gen_cmpqi_ext_3 (scratch, const1_rtx));\n \t      intcmp_mode = CCmode;\n \t      code = EQ;\n \t    }\n \t  else\n \t    {\n-\t      emit_insn (gen_testqi_ext_ccno_0 (scratch, const1_rtx));\n+\t      emit_insn (gen_testqi_ext_1_ccno (scratch, const1_rtx));\n \t      code = NE;\n \t    }\n \t  break;\n \tcase GE:\n \tcase UNGE:\n \t  if (code == GE || !TARGET_IEEE_FP)\n \t    {\n-\t      emit_insn (gen_testqi_ext_ccno_0 (scratch, GEN_INT (0x05)));\n+\t      emit_insn (gen_testqi_ext_1_ccno (scratch, GEN_INT (0x05)));\n \t      code = EQ;\n \t    }\n \t  else\n \t    {\n-\t      emit_insn (gen_andqi_ext_0 (scratch, scratch, GEN_INT (0x45)));\n-\t      emit_insn (gen_xorqi_cc_ext_1 (scratch, scratch, const1_rtx));\n+\t      emit_insn (gen_andqi_ext_1 (scratch, scratch, GEN_INT (0x45)));\n+\t      emit_insn (gen_xorqi_ext_1_cc (scratch, scratch, const1_rtx));\n \t      code = NE;\n \t    }\n \t  break;\n \tcase LE:\n \tcase UNLE:\n \t  if (code == LE && TARGET_IEEE_FP)\n \t    {\n-\t      emit_insn (gen_andqi_ext_0 (scratch, scratch, GEN_INT (0x45)));\n+\t      emit_insn (gen_andqi_ext_1 (scratch, scratch, GEN_INT (0x45)));\n \t      emit_insn (gen_addqi_ext_1 (scratch, scratch, constm1_rtx));\n \t      emit_insn (gen_cmpqi_ext_3 (scratch, GEN_INT (0x40)));\n \t      intcmp_mode = CCmode;\n \t      code = LTU;\n \t    }\n \t  else\n \t    {\n-\t      emit_insn (gen_testqi_ext_ccno_0 (scratch, GEN_INT (0x45)));\n+\t      emit_insn (gen_testqi_ext_1_ccno (scratch, GEN_INT (0x45)));\n \t      code = NE;\n \t    }\n \t  break;\n \tcase EQ:\n \tcase UNEQ:\n \t  if (code == EQ && TARGET_IEEE_FP)\n \t    {\n-\t      emit_insn (gen_andqi_ext_0 (scratch, scratch, GEN_INT (0x45)));\n+\t      emit_insn (gen_andqi_ext_1 (scratch, scratch, GEN_INT (0x45)));\n \t      emit_insn (gen_cmpqi_ext_3 (scratch, GEN_INT (0x40)));\n \t      intcmp_mode = CCmode;\n \t      code = EQ;\n \t    }\n \t  else\n \t    {\n-\t      emit_insn (gen_testqi_ext_ccno_0 (scratch, GEN_INT (0x40)));\n+\t      emit_insn (gen_testqi_ext_1_ccno (scratch, GEN_INT (0x40)));\n \t      code = NE;\n \t    }\n \t  break;\n \tcase NE:\n \tcase LTGT:\n \t  if (code == NE && TARGET_IEEE_FP)\n \t    {\n-\t      emit_insn (gen_andqi_ext_0 (scratch, scratch, GEN_INT (0x45)));\n-\t      emit_insn (gen_xorqi_cc_ext_1 (scratch, scratch,\n+\t      emit_insn (gen_andqi_ext_1 (scratch, scratch, GEN_INT (0x45)));\n+\t      emit_insn (gen_xorqi_ext_1_cc (scratch, scratch,\n \t\t\t\t\t     GEN_INT (0x40)));\n \t      code = NE;\n \t    }\n \t  else\n \t    {\n-\t      emit_insn (gen_testqi_ext_ccno_0 (scratch, GEN_INT (0x40)));\n+\t      emit_insn (gen_testqi_ext_1_ccno (scratch, GEN_INT (0x40)));\n \t      code = EQ;\n \t    }\n \t  break;\n \n \tcase UNORDERED:\n-\t  emit_insn (gen_testqi_ext_ccno_0 (scratch, GEN_INT (0x04)));\n+\t  emit_insn (gen_testqi_ext_1_ccno (scratch, GEN_INT (0x04)));\n \t  code = NE;\n \t  break;\n \tcase ORDERED:\n-\t  emit_insn (gen_testqi_ext_ccno_0 (scratch, GEN_INT (0x04)));\n+\t  emit_insn (gen_testqi_ext_1_ccno (scratch, GEN_INT (0x04)));\n \t  code = EQ;\n \t  break;\n \n@@ -44370,7 +44370,7 @@ ix86_emit_fp_unordered_jump (rtx label)\n     }\n   else\n     {\n-      emit_insn (gen_testqi_ext_ccno_0 (reg, GEN_INT (0x04)));\n+      emit_insn (gen_testqi_ext_1_ccno (reg, GEN_INT (0x04)));\n \n       temp = gen_rtx_REG (CCNOmode, FLAGS_REG);\n       temp = gen_rtx_NE (VOIDmode, temp, const0_rtx);\n@@ -44528,7 +44528,7 @@ void ix86_emit_i387_round (rtx op0, rtx op1)\n     }\n \n   /* flags = signbit(a) */\n-  emit_insn (gen_testqi_ext_ccno_0 (scratch, GEN_INT (0x02)));\n+  emit_insn (gen_testqi_ext_1_ccno (scratch, GEN_INT (0x02)));\n \n   /* if (flags) then res = -res */\n   tmp = gen_rtx_IF_THEN_ELSE (VOIDmode,"}, {"sha": "f3f358326ac446755c8811403527d57f3383e2a7", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 194, "deletions": 228, "changes": 422, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecb1129654f793279b3b48c276d6d0c412d545d5/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecb1129654f793279b3b48c276d6d0c412d545d5/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=ecb1129654f793279b3b48c276d6d0c412d545d5", "patch": "@@ -1345,7 +1345,6 @@\n   \"cmp{b}\\t{%1, %h0|%h0, %1}\"\n   [(set_attr \"isa\" \"*,nox64\")\n    (set_attr \"type\" \"icmp\")\n-   (set_attr \"modrm\" \"1\")\n    (set_attr \"mode\" \"QI\")])\n \n (define_insn \"*cmpqi_ext_4\"\n@@ -6082,12 +6081,13 @@\n   [(set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=Q,Q\")\n \t\t\t (const_int 8)\n \t\t\t (const_int 8))\n-\t(plus:SI\n-\t  (zero_extract:SI\n-\t    (match_operand 1 \"ext_register_operand\" \"0,0\")\n-\t    (const_int 8)\n-\t    (const_int 8))\n-\t  (match_operand:QI 2 \"general_x64nomem_operand\" \"Qn,m\")))\n+\t(subreg:SI\n+\t  (plus:QI\n+\t    (subreg:QI\n+\t      (zero_extract:SI (match_operand 1 \"ext_register_operand\" \"0,0\")\n+\t\t\t       (const_int 8)\n+\t\t\t       (const_int 8)) 0)\n+\t    (match_operand:QI 2 \"general_x64nomem_operand\" \"Qn,m\")) 0))\n    (clobber (reg:CC FLAGS_REG))]\n   \"\"\n {\n@@ -6111,23 +6111,23 @@\n      (if_then_else (match_operand:QI 2 \"incdec_operand\")\n \t(const_string \"incdec\")\n \t(const_string \"alu\")))\n-   (set_attr \"modrm\" \"1\")\n    (set_attr \"mode\" \"QI\")])\n \n (define_insn \"*addqi_ext_2\"\n   [(set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=Q\")\n \t\t\t (const_int 8)\n \t\t\t (const_int 8))\n-\t(plus:SI\n-\t  (zero_extract:SI\n-\t    (match_operand 1 \"ext_register_operand\" \"%0\")\n-\t    (const_int 8)\n-\t    (const_int 8))\n-\t  (zero_extract:SI\n-\t    (match_operand 2 \"ext_register_operand\" \"Q\")\n-\t    (const_int 8)\n-\t    (const_int 8))))\n-   (clobber (reg:CC FLAGS_REG))]\n+\t(subreg:SI\n+\t  (plus:QI\n+\t    (subreg:QI\n+\t      (zero_extract:SI (match_operand 1 \"ext_register_operand\" \"%0\")\n+\t\t\t       (const_int 8)\n+\t\t\t       (const_int 8)) 0)\n+\t    (subreg:QI\n+\t      (zero_extract:SI (match_operand 2 \"ext_register_operand\" \"Q\")\n+\t\t\t       (const_int 8)\n+\t\t\t       (const_int 8)) 0)) 0))\n+  (clobber (reg:CC FLAGS_REG))]\n   \"\"\n   \"add{b}\\t{%h2, %h0|%h0, %h2}\"\n   [(set_attr \"type\" \"alu\")\n@@ -7870,45 +7870,26 @@\n    (set_attr \"mode\" \"<MODE>\")\n    (set_attr \"pent_pair\" \"uv,np,uv\")])\n \n-(define_expand \"testqi_ext_ccno_0\"\n+(define_expand \"testqi_ext_1_ccno\"\n   [(set (reg:CCNO FLAGS_REG)\n \t(compare:CCNO\n-\t  (and:SI\n-\t    (zero_extract:SI\n-\t      (match_operand 0 \"ext_register_operand\")\n-\t      (const_int 8)\n-\t      (const_int 8))\n-\t    (match_operand 1 \"const_int_operand\"))\n+\t  (and:QI\n+\t    (subreg:QI\n+\t      (zero_extract:SI (match_operand 0 \"ext_register_operand\")\n+\t\t\t       (const_int 8)\n+\t\t\t       (const_int 8)) 0)\n+\t      (match_operand 1 \"const_int_operand\"))\n \t  (const_int 0)))])\n \n-(define_insn \"*testqi_ext_0\"\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (and:SI\n-\t    (zero_extract:SI\n-\t      (match_operand 0 \"ext_register_operand\" \"Q\")\n-\t      (const_int 8)\n-\t      (const_int 8))\n-\t    (match_operand 1 \"const_int_operand\" \"n\"))\n-\t  (const_int 0)))]\n-  \"ix86_match_ccmode (insn, CCNOmode)\"\n-  \"test{b}\\t{%1, %h0|%h0, %1}\"\n-  [(set_attr \"type\" \"test\")\n-   (set_attr \"mode\" \"QI\")\n-   (set_attr \"length_immediate\" \"1\")\n-   (set_attr \"modrm\" \"1\")\n-   (set_attr \"pent_pair\" \"np\")])\n-\n (define_insn \"*testqi_ext_1\"\n   [(set (reg FLAGS_REG)\n \t(compare\n-\t  (and:SI\n-\t    (zero_extract:SI\n-\t      (match_operand 0 \"ext_register_operand\" \"Q,Q\")\n-\t      (const_int 8)\n-\t      (const_int 8))\n-\t    (zero_extend:SI\n-\t      (match_operand:QI 1 \"nonimmediate_x64nomem_operand\" \"Q,m\")))\n+\t  (and:QI\n+\t    (subreg:QI\n+\t      (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"Q,Q\")\n+\t\t\t       (const_int 8)\n+\t\t\t       (const_int 8)) 0)\n+\t    (match_operand:QI 1 \"general_x64nomem_operand\" \"Qn,m\"))\n \t  (const_int 0)))]\n   \"ix86_match_ccmode (insn, CCNOmode)\"\n   \"test{b}\\t{%1, %h0|%h0, %1}\"\n@@ -7919,15 +7900,15 @@\n (define_insn \"*testqi_ext_2\"\n   [(set (reg FLAGS_REG)\n \t(compare\n-\t  (and:SI\n-\t    (zero_extract:SI\n-\t      (match_operand 0 \"ext_register_operand\" \"Q\")\n-\t      (const_int 8)\n-\t      (const_int 8))\n-\t    (zero_extract:SI\n-\t      (match_operand 1 \"ext_register_operand\" \"Q\")\n-\t      (const_int 8)\n-\t      (const_int 8)))\n+\t  (and:QI\n+\t    (subreg:QI\n+\t      (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"Q\")\n+\t\t\t       (const_int 8)\n+\t\t\t       (const_int 8)) 0)\n+\t    (subreg:QI\n+\t      (zero_extract:SI (match_operand 1 \"ext_register_operand\" \"Q\")\n+\t\t\t       (const_int 8)\n+\t\t\t       (const_int 8)) 0))\n \t  (const_int 0)))]\n   \"ix86_match_ccmode (insn, CCNOmode)\"\n   \"test{b}\\t{%h1, %h0|%h0, %h1}\"\n@@ -8029,12 +8010,16 @@\n \t    && !(INTVAL (operands[3]) & ~(127 << 8))))\"\n   [(set (match_dup 0)\n \t(match_op_dup 1\n-\t  [(and:SI (zero_extract:SI (match_dup 2) (const_int 8) (const_int 8))\n-\t\t   (match_dup 3))\n+\t  [(and:QI\n+\t     (subreg:QI\n+\t       (zero_extract:SI (match_dup 2)\n+\t\t\t\t(const_int 8)\n+\t\t\t\t(const_int 8)) 0)\n+\t     (match_dup 3))\n \t   (const_int 0)]))]\n {\n   operands[2] = gen_lowpart (SImode, operands[2]);\n-  operands[3] = gen_int_mode (INTVAL (operands[3]) >> 8, SImode);\n+  operands[3] = gen_int_mode (INTVAL (operands[3]) >> 8, QImode);\n })\n \n (define_split\n@@ -8308,17 +8293,21 @@\n    (clobber (reg:CC FLAGS_REG))]\n   \"(!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n    && reload_completed\"\n-  [(parallel [(set (zero_extract:SI (match_dup 0)\n-\t\t\t\t    (const_int 8)\n-\t\t\t\t    (const_int 8))\n-\t\t   (xor:SI\n-\t\t     (zero_extract:SI (match_dup 0)\n-\t\t\t\t      (const_int 8)\n-\t\t\t\t      (const_int 8))\n-\t\t     (zero_extract:SI (match_dup 0)\n-\t\t\t\t      (const_int 8)\n-\t\t\t\t      (const_int 8))))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n+  [(parallel\n+     [(set (zero_extract:SI (match_dup 0)\n+\t\t\t    (const_int 8)\n+\t\t\t    (const_int 8))\n+\t   (subreg:SI\n+\t     (xor:QI\n+\t       (subreg:QI\n+\t\t (zero_extract:SI (match_dup 0)\n+\t\t\t\t  (const_int 8)\n+\t\t\t\t  (const_int 8)) 0)\n+\t       (subreg:QI\n+\t\t (zero_extract:SI (match_dup 0)\n+\t\t\t\t  (const_int 8)\n+\t\t\t\t  (const_int 8)) 0)) 0))\n+      (clobber (reg:CC FLAGS_REG))])]\n   \"operands[0] = gen_lowpart (SImode, operands[0]);\")\n \n (define_insn \"*anddi_2\"\n@@ -8418,92 +8407,69 @@\n   [(set_attr \"type\" \"alu1\")\n    (set_attr \"mode\" \"QI\")])\n \n-;; ??? A bug in recog prevents it from recognizing a const_int as an\n-;; operand to zero_extend in andqi_ext_1.  It was checking explicitly\n-;; for a QImode operand, which of course failed.\n-(define_insn \"andqi_ext_0\"\n-  [(set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=Q\")\n+(define_insn \"andqi_ext_1\"\n+  [(set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=Q,Q\")\n \t\t\t (const_int 8)\n \t\t\t (const_int 8))\n-\t(and:SI\n-\t  (zero_extract:SI\n-\t    (match_operand 1 \"ext_register_operand\" \"0\")\n-\t    (const_int 8)\n-\t    (const_int 8))\n-\t  (match_operand 2 \"const_int_operand\" \"n\")))\n+\t(subreg:SI\n+\t  (and:QI\n+\t    (subreg:QI\n+\t      (zero_extract:SI (match_operand 1 \"ext_register_operand\" \"0,0\")\n+\t\t\t       (const_int 8)\n+\t\t\t       (const_int 8)) 0)\n+\t    (match_operand:QI 2 \"general_x64nomem_operand\" \"Qn,m\")) 0))\n    (clobber (reg:CC FLAGS_REG))]\n   \"\"\n   \"and{b}\\t{%2, %h0|%h0, %2}\"\n-  [(set_attr \"type\" \"alu\")\n-   (set_attr \"length_immediate\" \"1\")\n-   (set_attr \"modrm\" \"1\")\n+  [(set_attr \"isa\" \"*,nox64\")\n+   (set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"QI\")])\n \n ;; Generated by peephole translating test to and.  This shows up\n ;; often in fp comparisons.\n-(define_insn \"*andqi_ext_0_cc\"\n+(define_insn \"*andqi_ext_1_cc\"\n   [(set (reg FLAGS_REG)\n \t(compare\n-\t  (and:SI\n-\t    (zero_extract:SI\n-\t      (match_operand 1 \"ext_register_operand\" \"0\")\n-\t      (const_int 8)\n-\t      (const_int 8))\n+\t  (and:QI\n+\t    (subreg:QI\n+\t      (zero_extract:SI (match_operand 1 \"ext_register_operand\" \"0\")\n+\t\t\t       (const_int 8)\n+\t\t\t       (const_int 8)) 0)\n \t    (match_operand 2 \"const_int_operand\" \"n\"))\n \t  (const_int 0)))\n    (set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=Q\")\n \t\t\t (const_int 8)\n \t\t\t (const_int 8))\n-\t(and:SI\n-\t  (zero_extract:SI\n-\t    (match_dup 1)\n-\t    (const_int 8)\n-\t    (const_int 8))\n-\t  (match_dup 2)))]\n+\t(subreg:SI\n+\t  (and:QI\n+\t    (subreg:QI\n+\t      (zero_extract:SI (match_dup 1)\n+\t\t\t       (const_int 8)\n+\t\t\t       (const_int 8)) 0)\n+\t    (match_dup 2)) 0))]\n   \"ix86_match_ccmode (insn, CCNOmode)\"\n   \"and{b}\\t{%2, %h0|%h0, %2}\"\n   [(set_attr \"type\" \"alu\")\n-   (set_attr \"length_immediate\" \"1\")\n-   (set_attr \"modrm\" \"1\")\n-   (set_attr \"mode\" \"QI\")])\n-\n-(define_insn \"*andqi_ext_1\"\n-  [(set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=Q,Q\")\n-\t\t\t (const_int 8)\n-\t\t\t (const_int 8))\n-\t(and:SI\n-\t  (zero_extract:SI\n-\t    (match_operand 1 \"ext_register_operand\" \"0,0\")\n-\t    (const_int 8)\n-\t    (const_int 8))\n-\t  (zero_extend:SI\n-\t    (match_operand:QI 2 \"nonimmediate_x64nomem_operand\" \"Q,m\"))))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"\"\n-  \"and{b}\\t{%2, %h0|%h0, %2}\"\n-  [(set_attr \"isa\" \"*,nox64\")\n-   (set_attr \"type\" \"alu\")\n-   (set_attr \"length_immediate\" \"0\")\n    (set_attr \"mode\" \"QI\")])\n \n (define_insn \"*andqi_ext_2\"\n   [(set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=Q\")\n \t\t\t (const_int 8)\n \t\t\t (const_int 8))\n-\t(and:SI\n-\t  (zero_extract:SI\n-\t    (match_operand 1 \"ext_register_operand\" \"%0\")\n-\t    (const_int 8)\n-\t    (const_int 8))\n-\t  (zero_extract:SI\n-\t    (match_operand 2 \"ext_register_operand\" \"Q\")\n-\t    (const_int 8)\n-\t    (const_int 8))))\n+\t(subreg:SI\n+\t  (and:QI\n+\t    (subreg:QI\n+\t      (zero_extract:SI (match_operand 1 \"ext_register_operand\" \"%0\")\n+\t\t\t       (const_int 8)\n+\t\t\t       (const_int 8)) 0)\n+\t    (subreg:QI\n+\t      (zero_extract:SI (match_operand 2 \"ext_register_operand\" \"Q\")\n+\t\t\t       (const_int 8)\n+\t\t\t       (const_int 8)) 0)) 0))\n    (clobber (reg:CC FLAGS_REG))]\n   \"\"\n   \"and{b}\\t{%h2, %h0|%h0, %h2}\"\n   [(set_attr \"type\" \"alu\")\n-   (set_attr \"length_immediate\" \"0\")\n    (set_attr \"mode\" \"QI\")])\n \n ;; Convert wide AND instructions with immediate operand to shorter QImode\n@@ -8519,15 +8485,22 @@\n    \"reload_completed\n     && (!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n     && !(~INTVAL (operands[2]) & ~(255 << 8))\"\n-  [(parallel [(set (zero_extract:SI (match_dup 0) (const_int 8) (const_int 8))\n-\t\t   (and:SI (zero_extract:SI (match_dup 1)\n-\t\t\t\t\t    (const_int 8) (const_int 8))\n-\t\t\t   (match_dup 2)))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n+  [(parallel\n+     [(set (zero_extract:SI (match_dup 0)\n+\t\t\t    (const_int 8)\n+\t\t\t    (const_int 8))\n+\t   (subreg:SI\n+\t     (and:QI\n+\t       (subreg:QI\n+\t\t (zero_extract:SI (match_dup 1)\n+\t\t\t\t  (const_int 8)\n+\t\t\t\t  (const_int 8)) 0)\n+\t       (match_dup 2)) 0))\n+      (clobber (reg:CC FLAGS_REG))])]\n {\n   operands[0] = gen_lowpart (SImode, operands[0]);\n   operands[1] = gen_lowpart (SImode, operands[1]);\n-  operands[2] = gen_int_mode ((INTVAL (operands[2]) >> 8) & 0xff, SImode);\n+  operands[2] = gen_int_mode (INTVAL (operands[2]) >> 8, QImode);\n })\n \n ;; Since AND can be encoded with sign extended immediate, this is only\n@@ -8820,59 +8793,42 @@\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"*<code>qi_ext_0\"\n-  [(set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=Q\")\n-\t\t\t (const_int 8)\n-\t\t\t (const_int 8))\n-\t(any_or:SI\n-\t  (zero_extract:SI\n-\t    (match_operand 1 \"ext_register_operand\" \"0\")\n-\t    (const_int 8)\n-\t    (const_int 8))\n-\t  (match_operand 2 \"const_int_operand\" \"n\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun)\"\n-  \"<logic>{b}\\t{%2, %h0|%h0, %2}\"\n-  [(set_attr \"type\" \"alu\")\n-   (set_attr \"length_immediate\" \"1\")\n-   (set_attr \"modrm\" \"1\")\n-   (set_attr \"mode\" \"QI\")])\n-\n (define_insn \"*<code>qi_ext_1\"\n   [(set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=Q,Q\")\n \t\t\t (const_int 8)\n \t\t\t (const_int 8))\n-\t(any_or:SI\n-\t  (zero_extract:SI\n-\t    (match_operand 1 \"ext_register_operand\" \"0,0\")\n-\t    (const_int 8)\n-\t    (const_int 8))\n-\t  (zero_extend:SI\n-\t    (match_operand:QI 2 \"nonimmediate_x64nomem_operand\" \"Q,m\"))))\n+\t(subreg:SI\n+\t  (any_or:QI\n+\t    (subreg:QI\n+\t      (zero_extract:SI (match_operand 1 \"ext_register_operand\" \"0,0\")\n+\t\t\t       (const_int 8)\n+\t\t\t       (const_int 8)) 0)\n+\t    (match_operand:QI 2 \"general_x64nomem_operand\" \"Qn,m\")) 0))\n    (clobber (reg:CC FLAGS_REG))]\n   \"!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun)\"\n   \"<logic>{b}\\t{%2, %h0|%h0, %2}\"\n   [(set_attr \"isa\" \"*,nox64\")\n    (set_attr \"type\" \"alu\")\n-   (set_attr \"length_immediate\" \"0\")\n    (set_attr \"mode\" \"QI\")])\n \n (define_insn \"*<code>qi_ext_2\"\n   [(set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=Q\")\n \t\t\t (const_int 8)\n \t\t\t (const_int 8))\n-\t(any_or:SI\n-\t  (zero_extract:SI (match_operand 1 \"ext_register_operand\" \"0\")\n-\t  \t\t   (const_int 8)\n-\t\t\t   (const_int 8))\n-\t  (zero_extract:SI (match_operand 2 \"ext_register_operand\" \"Q\")\n-\t  \t\t   (const_int 8)\n-\t\t\t   (const_int 8))))\n+\t(subreg:SI\n+\t  (any_or:QI\n+\t    (subreg:QI\n+\t      (zero_extract:SI (match_operand 1 \"ext_register_operand\" \"%0\")\n+\t\t\t       (const_int 8)\n+\t\t\t       (const_int 8)) 0)\n+\t    (subreg:QI\n+\t      (zero_extract:SI (match_operand 2 \"ext_register_operand\" \"Q\")\n+\t\t\t       (const_int 8)\n+\t\t\t       (const_int 8)) 0)) 0))\n    (clobber (reg:CC FLAGS_REG))]\n   \"!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun)\"\n   \"<logic>{b}\\t{%h2, %h0|%h0, %h2}\"\n   [(set_attr \"type\" \"alu\")\n-   (set_attr \"length_immediate\" \"0\")\n    (set_attr \"mode\" \"QI\")])\n \n ;; Convert wide OR instructions with immediate operand to shorter QImode\n@@ -8888,15 +8844,22 @@\n    \"reload_completed\n     && (!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n     && !(INTVAL (operands[2]) & ~(255 << 8))\"\n-  [(parallel [(set (zero_extract:SI (match_dup 0) (const_int 8) (const_int 8))\n-\t\t   (any_or:SI (zero_extract:SI (match_dup 1)\n-\t\t\t\t\t       (const_int 8) (const_int 8))\n-\t\t\t      (match_dup 2)))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n+  [(parallel\n+     [(set (zero_extract:SI (match_dup 0)\n+\t\t\t    (const_int 8)\n+\t\t\t    (const_int 8))\n+\t   (subreg:SI\n+\t     (any_or:QI\n+\t       (subreg:QI\n+\t\t (zero_extract:SI (match_dup 1)\n+\t\t\t\t  (const_int 8)\n+\t\t\t\t  (const_int 8)) 0)\n+\t       (match_dup 2)) 0))\n+      (clobber (reg:CC FLAGS_REG))])]\n {\n   operands[0] = gen_lowpart (SImode, operands[0]);\n   operands[1] = gen_lowpart (SImode, operands[1]);\n-  operands[2] = gen_int_mode ((INTVAL (operands[2]) >> 8) & 0xff, SImode);\n+  operands[2] = gen_int_mode (INTVAL (operands[2]) >> 8, QImode);\n })\n \n ;; Since OR can be encoded with sign extended immediate, this is only\n@@ -8920,51 +8883,52 @@\n   operands[2] = gen_lowpart (QImode, operands[2]);\n })\n \n-(define_expand \"xorqi_cc_ext_1\"\n+(define_expand \"xorqi_ext_1_cc\"\n   [(parallel [\n      (set (reg:CCNO FLAGS_REG)\n \t  (compare:CCNO\n-\t    (xor:SI\n-\t      (zero_extract:SI\n-\t\t(match_operand 1 \"ext_register_operand\")\n-\t\t(const_int 8)\n-\t\t(const_int 8))\n-\t      (match_operand:QI 2 \"const_int_operand\"))\n+\t    (xor:QI\n+\t      (subreg:QI\n+\t\t(zero_extract:SI (match_operand 1 \"ext_register_operand\")\n+\t\t\t\t (const_int 8)\n+\t\t\t\t (const_int 8)) 0)\n+\t      (match_operand 2 \"const_int_operand\"))\n \t    (const_int 0)))\n      (set (zero_extract:SI (match_operand 0 \"ext_register_operand\")\n \t\t\t   (const_int 8)\n \t\t\t   (const_int 8))\n-\t  (xor:SI\n-\t    (zero_extract:SI\n-\t     (match_dup 1)\n-\t     (const_int 8)\n-\t     (const_int 8))\n-\t    (match_dup 2)))])])\n-\n-(define_insn \"*xorqi_cc_ext_1\"\n+\t  (subreg:SI\n+\t    (xor:QI\n+\t      (subreg:QI\n+\t\t(zero_extract:SI (match_dup 1)\n+\t\t\t\t (const_int 8)\n+\t\t\t\t (const_int 8)) 0)\n+\t    (match_dup 2)) 0))])])\n+\n+(define_insn \"*xorqi_ext_1_cc\"\n   [(set (reg FLAGS_REG)\n \t(compare\n-\t  (xor:SI\n-\t    (zero_extract:SI\n-\t      (match_operand 1 \"ext_register_operand\" \"0,0\")\n-\t      (const_int 8)\n-\t      (const_int 8))\n+\t  (xor:QI\n+\t    (subreg:QI\n+\t      (zero_extract:SI (match_operand 1 \"ext_register_operand\" \"0,0\")\n+\t\t\t       (const_int 8)\n+\t\t\t       (const_int 8)) 0)\n \t    (match_operand:QI 2 \"general_x64nomem_operand\" \"Qn,m\"))\n \t  (const_int 0)))\n    (set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=Q,Q\")\n \t\t\t (const_int 8)\n \t\t\t (const_int 8))\n-\t(xor:SI\n-\t  (zero_extract:SI\n-\t   (match_dup 1)\n-\t   (const_int 8)\n-\t   (const_int 8))\n-\t  (match_dup 2)))]\n+\t(subreg:SI\n+\t  (xor:QI\n+\t    (subreg:QI\n+\t      (zero_extract:SI (match_dup 1)\n+\t\t\t       (const_int 8)\n+\t\t\t       (const_int 8)) 0)\n+\t  (match_dup 2)) 0))]\n   \"ix86_match_ccmode (insn, CCNOmode)\"\n   \"xor{b}\\t{%2, %h0|%h0, %2}\"\n   [(set_attr \"isa\" \"*,nox64\")\n    (set_attr \"type\" \"alu\")\n-   (set_attr \"modrm\" \"1\")\n    (set_attr \"mode\" \"QI\")])\n \f\n ;; Negation instructions\n@@ -16098,7 +16062,7 @@\n \n   emit_insn (gen_fxamxf2_i387 (scratch, operands[1]));\n \n-  emit_insn (gen_andqi_ext_0 (scratch, scratch, mask));\n+  emit_insn (gen_andqi_ext_1 (scratch, scratch, mask));\n   emit_insn (gen_cmpqi_ext_3 (scratch, val));\n   ix86_expand_setcc (res, EQ,\n \t\t     gen_rtx_REG (CCmode, FLAGS_REG), const0_rtx);\n@@ -16130,7 +16094,7 @@\n       emit_insn (gen_fxam<mode>2_i387_with_temp (scratch, temp));\n     }\n \n-  emit_insn (gen_andqi_ext_0 (scratch, scratch, mask));\n+  emit_insn (gen_andqi_ext_1 (scratch, scratch, mask));\n   emit_insn (gen_cmpqi_ext_3 (scratch, val));\n   ix86_expand_setcc (res, EQ,\n \t\t     gen_rtx_REG (CCmode, FLAGS_REG), const0_rtx);\n@@ -17851,35 +17815,37 @@\n (define_peephole2\n   [(set (match_operand 0 \"flags_reg_operand\")\n \t(match_operator 1 \"compare_operator\"\n-\t  [(and:SI\n-\t     (zero_extract:SI\n-\t       (match_operand 2 \"QIreg_operand\")\n-\t       (const_int 8)\n-\t       (const_int 8))\n+\t  [(and:QI\n+\t     (subreg:QI\n+\t       (zero_extract:SI (match_operand 2 \"QIreg_operand\")\n+\t\t\t\t(const_int 8)\n+\t\t\t\t(const_int 8)) 0)\n \t     (match_operand 3 \"const_int_operand\"))\n \t   (const_int 0)]))]\n   \"! TARGET_PARTIAL_REG_STALL\n    && ix86_match_ccmode (insn, CCNOmode)\n    && REGNO (operands[2]) != AX_REG\n    && peep2_reg_dead_p (1, operands[2])\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (match_op_dup 1\n-\t\t     [(and:SI\n-\t\t\t(zero_extract:SI\n-\t\t\t  (match_dup 2)\n-\t\t\t  (const_int 8)\n-\t\t\t  (const_int 8))\n-\t\t\t(match_dup 3))\n-\t\t      (const_int 0)]))\n-\t      (set (zero_extract:SI (match_dup 2)\n-\t\t\t\t    (const_int 8)\n-\t\t\t\t    (const_int 8))\n-\t\t   (and:SI\n-\t\t     (zero_extract:SI\n-\t\t       (match_dup 2)\n-\t\t       (const_int 8)\n-\t\t       (const_int 8))\n-\t\t     (match_dup 3)))])])\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (match_op_dup 1\n+\t     [(and:QI\n+\t\t(subreg:QI\n+\t\t  (zero_extract:SI (match_dup 2)\n+\t\t\t\t   (const_int 8)\n+\t\t\t\t   (const_int 8)) 0)\n+\t\t(match_dup 3))\n+\t      (const_int 0)]))\n+      (set (zero_extract:SI (match_dup 2)\n+\t\t\t    (const_int 8)\n+\t\t\t    (const_int 8))\n+\t\t   (subreg:SI\n+\t\t     (and:QI\n+\t\t       (subreg:QI\n+\t\t\t (zero_extract:SI (match_dup 2)\n+\t\t  \t  \t  \t  (const_int 8)\n+\t\t  \t  \t  \t  (const_int 8)) 0)\n+\t\t     (match_dup 3)) 0))])])\n \n ;; Don't do logical operations with memory inputs.\n (define_peephole2"}, {"sha": "31f0e4345839b8c066b37d2468ece6c7f921ec93", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecb1129654f793279b3b48c276d6d0c412d545d5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecb1129654f793279b3b48c276d6d0c412d545d5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ecb1129654f793279b3b48c276d6d0c412d545d5", "patch": "@@ -1,3 +1,8 @@\n+2016-12-26  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\tPR target/78904\n+\t* gcc.target/i386/pr78904.c: New test.\n+\n 2016-12-23  Andre Vehreschild  <vehre@gcc.gnu.org>\n \n \t* gfortran.dg/class_assign_1.f08: New test."}, {"sha": "d27d7fd651d0d548e6ef5a1fcdf50345b51cd712", "filename": "gcc/testsuite/gcc.target/i386/pr78904.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecb1129654f793279b3b48c276d6d0c412d545d5/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr78904.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecb1129654f793279b3b48c276d6d0c412d545d5/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr78904.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr78904.c?ref=ecb1129654f793279b3b48c276d6d0c412d545d5", "patch": "@@ -0,0 +1,48 @@\n+/* PR target/78904 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -masm=att\" } */\n+/* { dg-final { scan-assembler-not \"movzbl\" } } */\n+/* { dg-final { scan-assembler-not \"movb\" } } */\n+\n+struct S1\n+{\n+  unsigned char pad1;\n+  unsigned char val;\n+  unsigned short pad2;\n+};\n+\n+struct S1 test_and (struct S1 a, struct S1 b)\n+{\n+  a.val &= b.val;\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]andb\" } } */\n+\n+struct S1 test_or (struct S1 a, struct S1 b)\n+{\n+  a.val |= b.val;\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]orb\" } } */\n+\n+struct S1 test_xor (struct S1 a, struct S1 b)\n+{\n+  a.val ^= b.val;\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]xorb\" } } */\n+\n+struct S1 test_add (struct S1 a, struct S1 b)\n+{\n+  a.val += b.val;\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]addb\" } } */"}]}