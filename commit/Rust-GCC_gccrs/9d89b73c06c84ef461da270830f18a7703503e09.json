{"sha": "9d89b73c06c84ef461da270830f18a7703503e09", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWQ4OWI3M2MwNmM4NGVmNDYxZGEyNzA4MzBmMThhNzcwMzUwM2UwOQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2019-04-09T18:50:48Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-04-09T18:50:48Z"}, "message": "Add comments and style fixes to <variant>\n\n\t* include/std/variant: Adjust whitespace. Add comments.\n\t(_Multi_array): Leave primary template undefined.\n\t(_Multi_array<_Tp>): Define partial specialization for base case of\n\trecursion.\n\t(__gen_vtable_impl, __gen_vtable): Remove redundant && from type\n\twhich is always a reference.\n\t(__gen_vtable::_S_apply()): Remove function, inline body into\n\tdefault member initializer.\n\t* testsuite/20_util/variant/visit.cc: Test with noncopyable types.\n\nFrom-SVN: r270238", "tree": {"sha": "ac10bbd8a21bb6af75c1858e4798f42dcb95f8a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac10bbd8a21bb6af75c1858e4798f42dcb95f8a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9d89b73c06c84ef461da270830f18a7703503e09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d89b73c06c84ef461da270830f18a7703503e09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d89b73c06c84ef461da270830f18a7703503e09", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d89b73c06c84ef461da270830f18a7703503e09/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8701cb5e0dc0a3b949bb28f3ff9ee5bae98c47fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8701cb5e0dc0a3b949bb28f3ff9ee5bae98c47fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8701cb5e0dc0a3b949bb28f3ff9ee5bae98c47fe"}], "stats": {"total": 161, "additions": 109, "deletions": 52}, "files": [{"sha": "98a69cffcb9a86fb18f1343cf68ce235bfb9c58c", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d89b73c06c84ef461da270830f18a7703503e09/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d89b73c06c84ef461da270830f18a7703503e09/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=9d89b73c06c84ef461da270830f18a7703503e09", "patch": "@@ -1,5 +1,15 @@\n 2019-04-09  Jonathan Wakely  <jwakely@redhat.com>\n \n+\t* include/std/variant: Adjust whitespace. Add comments.\n+\t(_Multi_array): Leave primary template undefined.\n+\t(_Multi_array<_Tp>): Define partial specialization for base case of\n+\trecursion.\n+\t(__gen_vtable_impl, __gen_vtable): Remove redundant && from type\n+\twhich is always a reference.\n+\t(__gen_vtable::_S_apply()): Remove function, inline body into\n+\tdefault member initializer.\n+\t* testsuite/20_util/variant/visit.cc: Test with noncopyable types.\n+\n \t* include/std/variant (__variant_idx_cookie): Add member type.\n \t(__visitor_result_type): Remove.\n \t(__do_visit): Use invoke_result instead of __visitor_result_type."}, {"sha": "22b0c3d5c2247fb4d68ed721a1521840e46b168c", "filename": "libstdc++-v3/include/std/variant", "status": "modified", "additions": 77, "deletions": 52, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d89b73c06c84ef461da270830f18a7703503e09/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d89b73c06c84ef461da270830f18a7703503e09/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant?ref=9d89b73c06c84ef461da270830f18a7703503e09", "patch": "@@ -145,7 +145,8 @@ namespace __variant\n     __do_visit(_Visitor&& __visitor, _Variants&&... __variants);\n \n   template <typename... _Types, typename _Tp>\n-    decltype(auto) __variant_cast(_Tp&& __rhs)\n+    decltype(auto)\n+    __variant_cast(_Tp&& __rhs)\n     {\n       if constexpr (is_lvalue_reference_v<_Tp>)\n \t{\n@@ -197,9 +198,10 @@ namespace __variant\n     struct _Uninitialized<_Type, true>\n     {\n       template<typename... _Args>\n-      constexpr _Uninitialized(in_place_index_t<0>, _Args&&... __args)\n-      : _M_storage(std::forward<_Args>(__args)...)\n-      { }\n+\tconstexpr\n+\t_Uninitialized(in_place_index_t<0>, _Args&&... __args)\n+\t: _M_storage(std::forward<_Args>(__args)...)\n+\t{ }\n \n       constexpr const _Type& _M_get() const &\n       { return _M_storage; }\n@@ -220,11 +222,12 @@ namespace __variant\n     struct _Uninitialized<_Type, false>\n     {\n       template<typename... _Args>\n-      constexpr _Uninitialized(in_place_index_t<0>, _Args&&... __args)\n-      {\n-\t::new ((void*)std::addressof(_M_storage))\n-\t  _Type(std::forward<_Args>(__args)...);\n-      }\n+\tconstexpr\n+\t_Uninitialized(in_place_index_t<0>, _Args&&... __args)\n+\t{\n+\t  ::new ((void*)std::addressof(_M_storage))\n+\t    _Type(std::forward<_Args>(__args)...);\n+\t}\n \n       const _Type& _M_get() const &\n       { return *_M_storage._M_ptr(); }\n@@ -360,15 +363,14 @@ namespace __variant\n     struct _Variant_storage;\n \n   template <typename... _Types>\n-  using __select_index =\n-    typename __select_int::_Select_int_base<sizeof...(_Types),\n-\t\t\t\t\t    unsigned char,\n-\t\t\t\t\t    unsigned short>::type::value_type;\n+    using __select_index =\n+      typename __select_int::_Select_int_base<sizeof...(_Types),\n+\t\t\t\t\t      unsigned char,\n+\t\t\t\t\t      unsigned short>::type::value_type;\n \n   template<typename... _Types>\n     struct _Variant_storage<false, _Types...>\n     {\n-\n       constexpr _Variant_storage() : _M_index(variant_npos) { }\n \n       template<size_t _Np, typename... _Args>\n@@ -387,7 +389,7 @@ namespace __variant\n \t      std::_Destroy(std::__addressof(__this_mem));\n \t    return {};\n \t  }, __variant_cast<_Types...>(*this));\n-\t}\n+      }\n \n       void _M_reset()\n       {\n@@ -472,7 +474,7 @@ namespace __variant\n \t\t -> __detail::__variant::__variant_cookie\n         {\n \t  __variant_construct_single(std::forward<_Tp>(__lhs),\n-\t\t\t\t     std::forward<decltype(__rhs_mem)>(__rhs_mem));\n+\t      std::forward<decltype(__rhs_mem)>( __rhs_mem));\n \t  return {};\n \t}, __variant_cast<_Types...>(std::forward<decltype(__rhs)>(__rhs)));\n     }\n@@ -573,6 +575,7 @@ namespace __variant\n \t  __variant_construct_single(*this,\n \t\t\t\t     std::forward<_Up>(__rhs));\n \t}\n+\n       template<typename _Up>\n         void _M_destructive_copy(unsigned short __rhs_index, const _Up& __rhs)\n         {\n@@ -708,8 +711,7 @@ namespace __variant\n \n   template<typename... _Types>\n     using _Move_assign_alias =\n-\t_Move_assign_base<_Traits<_Types...>::_S_trivial_move_assign,\n-\t\t\t  _Types...>;\n+      _Move_assign_base<_Traits<_Types...>::_S_trivial_move_assign, _Types...>;\n \n   template<typename... _Types>\n     struct _Variant_base : _Move_assign_alias<_Types...>\n@@ -812,9 +814,13 @@ namespace __variant\n \t&& !_Variant_never_valueless<__remove_cvref_t<_Variant>>::value;\n     };\n \n-  // Used for storing multi-dimensional vtable.\n+  // Used for storing a multi-dimensional vtable.\n   template<typename _Tp, size_t... _Dimensions>\n-    struct _Multi_array\n+    struct _Multi_array;\n+\n+  // Partial specialization with rank zero, stores a single _Tp element.\n+  template<typename _Tp>\n+    struct _Multi_array<_Tp>\n     {\n       constexpr const _Tp&\n       _M_access() const\n@@ -823,6 +829,7 @@ namespace __variant\n       _Tp _M_data;\n     };\n \n+  // Partial specialization with rank >= 1.\n   template<typename _Ret,\n \t   typename _Visitor,\n \t   typename... _Variants,\n@@ -831,49 +838,67 @@ namespace __variant\n     {\n       static constexpr size_t __index =\n \tsizeof...(_Variants) - sizeof...(__rest) - 1;\n+\n       using _Variant = typename _Nth_type<__index, _Variants...>::type;\n+\n       static constexpr int __do_cookie =\n \t_Extra_visit_slot_needed<_Ret, _Variant>::value ? 1 : 0;\n+\n       using _Tp = _Ret(*)(_Visitor, _Variants...);\n+\n       template<typename... _Args>\n \tconstexpr const _Tp&\n \t_M_access(size_t __first_index, _Args... __rest_indices) const\n-        { return _M_arr[__first_index + __do_cookie]._M_access(__rest_indices...); }\n+        {\n+\t  return _M_arr[__first_index + __do_cookie]\n+\t    ._M_access(__rest_indices...);\n+\t}\n \n       _Multi_array<_Tp, __rest...> _M_arr[__first + __do_cookie];\n     };\n \n   // Creates a multi-dimensional vtable recursively.\n   //\n+  // The __same_return_types non-type template parameter specifies whether\n+  // to enforce that all visitor invocations return the same type. This is\n+  // required by std::visit but not std::visit<R>.\n+  //\n   // For example,\n   // visit([](auto, auto){},\n   //       variant<int, char>(),  // typedef'ed as V1\n   //       variant<float, double, long double>())  // typedef'ed as V2\n   // will trigger instantiations of:\n-  // __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&), 2, 3>,\n+  // __gen_vtable_impl<true, _Multi_array<void(*)(V1&&, V2&&), 2, 3>,\n   //                   tuple<V1&&, V2&&>, std::index_sequence<>>\n-  //   __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&), 3>,\n+  //   __gen_vtable_impl<true, _Multi_array<void(*)(V1&&, V2&&), 3>,\n   //                     tuple<V1&&, V2&&>, std::index_sequence<0>>\n-  //     __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&)>,\n+  //     __gen_vtable_impl<true, _Multi_array<void(*)(V1&&, V2&&)>,\n   //                       tuple<V1&&, V2&&>, std::index_sequence<0, 0>>\n-  //     __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&)>,\n+  //     __gen_vtable_impl<true, _Multi_array<void(*)(V1&&, V2&&)>,\n   //                       tuple<V1&&, V2&&>, std::index_sequence<0, 1>>\n-  //     __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&)>,\n+  //     __gen_vtable_impl<true, _Multi_array<void(*)(V1&&, V2&&)>,\n   //                       tuple<V1&&, V2&&>, std::index_sequence<0, 2>>\n-  //   __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&), 3>,\n+  //   __gen_vtable_impl<true, _Multi_array<void(*)(V1&&, V2&&), 3>,\n   //                     tuple<V1&&, V2&&>, std::index_sequence<1>>\n-  //     __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&)>,\n+  //     __gen_vtable_impl<true, _Multi_array<void(*)(V1&&, V2&&)>,\n   //                       tuple<V1&&, V2&&>, std::index_sequence<1, 0>>\n-  //     __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&)>,\n+  //     __gen_vtable_impl<true, _Multi_array<void(*)(V1&&, V2&&)>,\n   //                       tuple<V1&&, V2&&>, std::index_sequence<1, 1>>\n-  //     __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&)>,\n+  //     __gen_vtable_impl<true, _Multi_array<void(*)(V1&&, V2&&)>,\n   //                       tuple<V1&&, V2&&>, std::index_sequence<1, 2>>\n   // The returned multi-dimensional vtable can be fast accessed by the visitor\n   // using index calculation.\n   template<bool __same_return_types,\n \t   typename _Array_type, typename _Variant_tuple, typename _Index_seq>\n     struct __gen_vtable_impl;\n \n+  // Defines the _S_apply() member that returns a _Multi_array populated\n+  // with function pointers that perform the visitation expressions e(m)\n+  // for each valid pack of indexes into the variant types _Variants.\n+  //\n+  // This partial specialization builds up the index sequences by recursively\n+  // calling _S_apply() on the next specialization of __gen_vtable_impl.\n+  // The base case of the recursion defines the actual function pointers.\n   template<bool __same_return_types,\n \t   typename _Result_type, typename _Visitor, size_t... __dimensions,\n \t   typename... _Variants, size_t... __indices>\n@@ -940,6 +965,9 @@ namespace __variant\n \t}\n     };\n \n+  // This partial specialization is the base case for the recursion.\n+  // It populates a _Multi_array element with the address of a function\n+  // that invokes the visitor with the alternatives specified by __indices.\n   template<bool __same_return_types,\n \t   typename _Result_type, typename _Visitor, typename... _Variants,\n \t   size_t... __indices>\n@@ -949,7 +977,7 @@ namespace __variant\n \t\t   tuple<_Variants...>, std::index_sequence<__indices...>>\n     {\n       using _Array_type =\n-\t  _Multi_array<_Result_type (*)(_Visitor&&, _Variants...)>;\n+\t  _Multi_array<_Result_type (*)(_Visitor, _Variants...)>;\n \n       template<size_t __index, typename _Variant>\n \tstatic constexpr decltype(auto)\n@@ -964,20 +992,22 @@ namespace __variant\n       static constexpr decltype(auto)\n       __visit_invoke_impl(_Visitor&& __visitor, _Variants... __vars)\n       {\n-       if constexpr (is_same_v<_Result_type, __variant_idx_cookie>)\n-         return std::__invoke(std::forward<_Visitor>(__visitor),\n-            __element_by_index_or_cookie<__indices>(\n-              std::forward<_Variants>(__vars))...,\n-              integral_constant<size_t, __indices>()...);\n-        else if constexpr (!__same_return_types &&\n+\t// For raw visitation using indices, pass the indices to the visitor:\n+\tif constexpr (is_same_v<_Result_type, __variant_idx_cookie>)\n+\t  return std::__invoke(std::forward<_Visitor>(__visitor),\n+\t      __element_by_index_or_cookie<__indices>(\n+\t\tstd::forward<_Variants>(__vars))...,\n+\t      integral_constant<size_t, __indices>()...);\n+\t// For std::visit<cv void>, cast the result to void:\n+\telse if constexpr (!__same_return_types &&\n \t\t\t   std::is_void_v<_Result_type>)\n \t  return (void)std::__invoke(std::forward<_Visitor>(__visitor),\n-\t    __element_by_index_or_cookie<__indices>(\n-\t      std::forward<_Variants>(__vars))...);\n+\t      __element_by_index_or_cookie<__indices>(\n+\t\tstd::forward<_Variants>(__vars))...);\n \telse\n \t  return std::__invoke(std::forward<_Visitor>(__visitor),\n-\t    __element_by_index_or_cookie<__indices>(\n-\t      std::forward<_Variants>(__vars))...);\n+\t      __element_by_index_or_cookie<__indices>(\n+\t\tstd::forward<_Variants>(__vars))...);\n       }\n \n       static constexpr decltype(auto)\n@@ -987,6 +1017,7 @@ namespace __variant\n \t\t\t\t   std::forward<_Variants>(__vars)...);\n       }\n \n+      // Perform the implicit conversion to _Result_type for std::visit<R>.\n       static constexpr _Result_type\n       __do_visit_invoke_r(_Visitor&& __visitor, _Variants... __vars)\n       {\n@@ -1014,20 +1045,14 @@ namespace __variant\n \t   typename _Result_type, typename _Visitor, typename... _Variants>\n     struct __gen_vtable\n     {\n-      using _Func_ptr = _Result_type (*)(_Visitor&&, _Variants...);\n       using _Array_type =\n-\t  _Multi_array<_Func_ptr,\n+\t  _Multi_array<_Result_type (*)(_Visitor, _Variants...),\n \t\t       variant_size_v<remove_reference_t<_Variants>>...>;\n \n-      static constexpr _Array_type\n-      _S_apply()\n-      {\n-\treturn __gen_vtable_impl<__same_return_types,\n-\t\t\t\t _Array_type, tuple<_Variants...>,\n-\t\t\t\t std::index_sequence<>>::_S_apply();\n-      }\n-\n-      static constexpr auto _S_vtable = _S_apply();\n+      static constexpr _Array_type _S_vtable\n+\t= __gen_vtable_impl<__same_return_types,\n+\t\t\t    _Array_type, tuple<_Variants...>,\n+\t\t\t    std::index_sequence<>>::_S_apply();\n     };\n \n   template<size_t _Np, typename _Tp>"}, {"sha": "ff7cf56b4a9a35134c33ae311e6d162e3a484206", "filename": "libstdc++-v3/testsuite/20_util/variant/visit.cc", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d89b73c06c84ef461da270830f18a7703503e09/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Fvisit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d89b73c06c84ef461da270830f18a7703503e09/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Fvisit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Fvisit.cc?ref=9d89b73c06c84ef461da270830f18a7703503e09", "patch": "@@ -66,8 +66,30 @@ test01()\n   VERIFY( res == 35 );\n }\n \n+void\n+test02()\n+{\n+  struct NoCopy\n+  {\n+    NoCopy() { }\n+    NoCopy(const NoCopy&) = delete;\n+    NoCopy(NoCopy&&) = delete;\n+    ~NoCopy() { }\n+\n+    int operator()(int i) { return i; }\n+    int operator()(const NoCopy&) { return 0; }\n+  };\n+\n+  std::variant<NoCopy, int> v{1};\n+  NoCopy f;\n+  // Visit should not need arguments to be copyable:\n+  int res = std::visit(f, v);\n+  VERIFY( res == 1 );\n+}\n+\n int\n main()\n {\n   test01();\n+  test02();\n }"}]}