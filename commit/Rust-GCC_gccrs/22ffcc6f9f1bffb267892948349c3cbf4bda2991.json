{"sha": "22ffcc6f9f1bffb267892948349c3cbf4bda2991", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjJmZmNjNmY5ZjFiZmZiMjY3ODkyOTQ4MzQ5YzNjYmY0YmRhMjk5MQ==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@integrable-solutions.net", "date": "2003-02-13T04:57:20Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2003-02-13T04:57:20Z"}, "message": "timevar.h (POP_TIMEVAR_AND_RETURN): New macro.\n\n\t* timevar.h (POP_TIMEVAR_AND_RETURN): New macro.\ncp/\n\t* decl.c: Include \"timevar.h\".\n\t(poplevel): Time name lookup.\n\t(find_binding): Likewise.\n\t(push_namespace): Likewise.\n\t(pop_nested_namespace): Likewise.\n\t(store_bindings): Likewise.\n\t(maybe_push_to_top_level): Likewise.\n\t(pop_from_top_level): Likewise.\n\t(push_local_name): Likewise.\n\t(pushtag): Likewise.\n\t(pushdecl): Likewise.\n\t(pushdecl_with_scope): Likewise.\n\t(pushdecl_namespace_level): Likewise.\n\t(pushdecl_top_level): Likewise.\n\t(pushdecl_class_level): Likewise.\n\t(push_class_level_binding): Likewise.\n\t(push_using_decl): Likewise.\n\t(push_using_directive): Likewise.\n\t(push_overloaded_decl): Likewise.\n\t(lookup_label): Likewise.\n\t(define_label): Likewise.\n\t(lookup_tag): Likewise.\n\t(lookup_tag_reverse): Likewise.\n\t(lookup_namespace_name): Likewise.\n\t(select_decl): Likewise.\n\t(unqualified_namespace_lookup): Likewise.\n\t(lookup_name_real): Likewise.\n\t(lookup_name_current_level): Likewise.\n\t(lookup_type_current_level): Likewise.\n\t(maybe_inject_for_scope_var): Likewise.\n\t(xref_tag): Likewise.\n\n\t* Make-lang.in (cp/decl.o): Add dependency on timevar.h\n\nFrom-SVN: r62819", "tree": {"sha": "9a3b7172d75f59143babb90fde6ba9ce0208de97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a3b7172d75f59143babb90fde6ba9ce0208de97"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22ffcc6f9f1bffb267892948349c3cbf4bda2991", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22ffcc6f9f1bffb267892948349c3cbf4bda2991", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22ffcc6f9f1bffb267892948349c3cbf4bda2991", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22ffcc6f9f1bffb267892948349c3cbf4bda2991/comments", "author": {"login": "cxx-undef", "id": 5528103, "node_id": "MDQ6VXNlcjU1MjgxMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5528103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cxx-undef", "html_url": "https://github.com/cxx-undef", "followers_url": "https://api.github.com/users/cxx-undef/followers", "following_url": "https://api.github.com/users/cxx-undef/following{/other_user}", "gists_url": "https://api.github.com/users/cxx-undef/gists{/gist_id}", "starred_url": "https://api.github.com/users/cxx-undef/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cxx-undef/subscriptions", "organizations_url": "https://api.github.com/users/cxx-undef/orgs", "repos_url": "https://api.github.com/users/cxx-undef/repos", "events_url": "https://api.github.com/users/cxx-undef/events{/privacy}", "received_events_url": "https://api.github.com/users/cxx-undef/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8d55a4aa3bf047fcec347cac893772a37f08324f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d55a4aa3bf047fcec347cac893772a37f08324f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d55a4aa3bf047fcec347cac893772a37f08324f"}], "stats": {"total": 232, "additions": 162, "deletions": 70}, "files": [{"sha": "053d2cc2a36a96bd09af51fc10d4fa4aa0b745e8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22ffcc6f9f1bffb267892948349c3cbf4bda2991/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22ffcc6f9f1bffb267892948349c3cbf4bda2991/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=22ffcc6f9f1bffb267892948349c3cbf4bda2991", "patch": "@@ -1,3 +1,7 @@\n+2003-02-13  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\t* timevar.h (POP_TIMEVAR_AND_RETURN): New macro.\n+\n 2003-02-12  Roger Sayle  <roger@eyesopen.com>\n \n \t* config/i386/i386.md (UNSPEC_FPATAN): New UNSPEC constant."}, {"sha": "45b1497d6cadcadf602612fa444af54a73019407", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22ffcc6f9f1bffb267892948349c3cbf4bda2991/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22ffcc6f9f1bffb267892948349c3cbf4bda2991/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=22ffcc6f9f1bffb267892948349c3cbf4bda2991", "patch": "@@ -1,3 +1,39 @@\n+2003-02-13  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\t* decl.c: Include \"timevar.h\".\n+\t(poplevel): Time name lookup.\n+\t(find_binding): Likewise.\n+\t(push_namespace): Likewise.\n+\t(pop_nested_namespace): Likewise.\n+\t(store_bindings): Likewise.\n+\t(maybe_push_to_top_level): Likewise.\n+\t(pop_from_top_level): Likewise.\n+\t(push_local_name): Likewise.\n+\t(pushtag): Likewise.\n+\t(pushdecl): Likewise.\n+\t(pushdecl_with_scope): Likewise.\n+\t(pushdecl_namespace_level): Likewise.\n+\t(pushdecl_top_level): Likewise.\n+\t(pushdecl_class_level): Likewise.\n+\t(push_class_level_binding): Likewise.\n+\t(push_using_decl): Likewise.\n+\t(push_using_directive): Likewise.\n+\t(push_overloaded_decl): Likewise.\n+\t(lookup_label): Likewise.\n+\t(define_label): Likewise.\n+\t(lookup_tag): Likewise.\n+\t(lookup_tag_reverse): Likewise.\n+\t(lookup_namespace_name): Likewise.\n+\t(select_decl): Likewise.\n+\t(unqualified_namespace_lookup): Likewise.\n+\t(lookup_name_real): Likewise.\n+\t(lookup_name_current_level): Likewise.\n+\t(lookup_type_current_level): Likewise.\n+\t(maybe_inject_for_scope_var): Likewise.\n+\t(xref_tag): Likewise.\n+\n+\t* Make-lang.in (cp/decl.o): Add dependency on timevar.h\n+\t\n 2003-02-12  Phil Edwards  <pme@gcc.gnu.org>\n \n \t* decl.c (build_enumerator):  Remove unneeded test."}, {"sha": "7d8804cfbf6b2d128341115e2dfbdf5e6f965d4e", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22ffcc6f9f1bffb267892948349c3cbf4bda2991/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22ffcc6f9f1bffb267892948349c3cbf4bda2991/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=22ffcc6f9f1bffb267892948349c3cbf4bda2991", "patch": "@@ -221,7 +221,7 @@ cp/cp-lang.o: cp/cp-lang.c $(CXX_TREE_H) $(TM_H) toplev.h langhooks.h \\\n cp/decl.o: cp/decl.c $(CXX_TREE_H) $(TM_H) flags.h cp/lex.h cp/decl.h stack.h \\\n   output.h $(EXPR_H) except.h toplev.h $(HASHTAB_H) $(RTL_H) \\\n   cp/operators.def $(TM_P_H) tree-inline.h diagnostic.h c-pragma.h \\\n-  debug.h gt-cp-decl.h gtype-cp.h\n+  debug.h gt-cp-decl.h gtype-cp.h timevar.h\n cp/decl2.o: cp/decl2.c $(CXX_TREE_H) $(TM_H) flags.h cp/lex.h cp/decl.h $(EXPR_H) \\\n   output.h except.h toplev.h $(RTL_H) c-common.h gt-cp-decl2.h\n cp/typeck2.o: cp/typeck2.c $(CXX_TREE_H) $(TM_H) flags.h toplev.h output.h $(TM_P_H) \\"}, {"sha": "9cb473671352e97f4b2a17d363ab33bc0ecd9757", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 118, "deletions": 69, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22ffcc6f9f1bffb267892948349c3cbf4bda2991/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22ffcc6f9f1bffb267892948349c3cbf4bda2991/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=22ffcc6f9f1bffb267892948349c3cbf4bda2991", "patch": "@@ -50,6 +50,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"c-pragma.h\"\n #include \"diagnostic.h\"\n #include \"debug.h\"\n+#include \"timevar.h\"\n \n static tree grokparms (tree);\n static const char *redeclaration_error_message (tree, tree);\n@@ -1234,8 +1235,9 @@ poplevel (int keep, int reverse, int functionbody)\n   tree decl;\n   int leaving_for_scope;\n \n+  timevar_push (TV_NAME_LOOKUP);\n   if (cfun && !doing_semantic_analysis_p ())\n-    return NULL_TREE;\n+    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n \n   my_friendly_assert (current_binding_level->parm_flag != 2,\n \t\t      19990916);\n@@ -1526,7 +1528,7 @@ poplevel (int keep, int reverse, int functionbody)\n       block = poplevel (keep, reverse, functionbody);\n     }\n \n-  return block;\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, block);\n }\n \n /* Delete the node BLOCK from the current binding level.\n@@ -1614,6 +1616,7 @@ poplevel_class (void)\n   register struct cp_binding_level *level = class_binding_level;\n   tree shadowed;\n \n+  timevar_push (TV_NAME_LOOKUP);\n   my_friendly_assert (level != 0, 354);\n \n   /* If we're leaving a toplevel class, don't bother to do the setting\n@@ -1678,6 +1681,7 @@ poplevel_class (void)\n #endif /* defined(DEBUG_BINDING_LEVELS) */\n \n   pop_binding_level ();\n+  timevar_pop (TV_NAME_LOOKUP);\n }\n \n /* We are entering the scope of a class.  Clear IDENTIFIER_CLASS_VALUE\n@@ -2032,6 +2036,7 @@ find_binding (tree name, tree scope)\n {\n   tree iter, prev = NULL_TREE;\n \n+  timevar_push (TV_NAME_LOOKUP);\n   scope = ORIGINAL_NAMESPACE (scope);\n \n   for (iter = IDENTIFIER_NAMESPACE_BINDINGS (name); iter;\n@@ -2048,11 +2053,11 @@ find_binding (tree name, tree scope)\n \t      TREE_CHAIN (iter) = IDENTIFIER_NAMESPACE_BINDINGS (name);\n \t      IDENTIFIER_NAMESPACE_BINDINGS (name) = iter;\n \t    }\n-\t  return iter;\n+\t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, iter);\n \t}\n       prev = iter;\n     }\n-  return NULL_TREE;\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n }\n \n /* Always returns a binding for name in scope. If the\n@@ -2139,6 +2144,9 @@ push_namespace (tree name)\n   int need_new = 1;\n   int implicit_use = 0;\n   int global = 0;\n+\n+  timevar_push (TV_NAME_LOOKUP);\n+  \n   if (!global_namespace)\n     {\n       /* This must be ::.  */\n@@ -2196,6 +2204,8 @@ push_namespace (tree name)\n     do_using_directive (d);\n   /* Enter the name space.  */\n   current_namespace = d;\n+\n+  timevar_pop (TV_NAME_LOOKUP);\n }\n \n /* Pop from the scope of the current namespace.  */\n@@ -2230,13 +2240,15 @@ push_nested_namespace (tree ns)\n void\n pop_nested_namespace (tree ns)\n {\n+  timevar_push (TV_NAME_LOOKUP);\n   while (ns != global_namespace)\n     {\n       pop_namespace ();\n       ns = CP_DECL_CONTEXT (ns);\n     }\n \n   pop_from_top_level ();\n+  timevar_pop (TV_NAME_LOOKUP);\n }\n \n \f\n@@ -2253,6 +2265,7 @@ store_bindings (tree names, tree old_bindings)\n   tree t;\n   tree search_bindings = old_bindings;\n \n+  timevar_push (TV_NAME_LOOKUP);\n   for (t = names; t; t = TREE_CHAIN (t))\n     {\n       tree binding, t1, id;\n@@ -2286,7 +2299,7 @@ store_bindings (tree names, tree old_bindings)\n     skip_it:\n       ;\n     }\n-  return old_bindings;\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, old_bindings);\n }\n \n void\n@@ -2297,6 +2310,7 @@ maybe_push_to_top_level (int pseudo)\n   tree old_bindings;\n   int need_pop;\n \n+  timevar_push (TV_NAME_LOOKUP);\n   s = (struct saved_scope *) ggc_alloc_cleared (sizeof (struct saved_scope));\n \n   b = scope_chain ? current_binding_level : 0;\n@@ -2350,6 +2364,7 @@ maybe_push_to_top_level (int pseudo)\n   VARRAY_TREE_INIT (current_lang_base, 10, \"current_lang_base\");\n   current_lang_name = lang_name_cplusplus;\n   current_namespace = global_namespace;\n+  timevar_pop (TV_NAME_LOOKUP);\n }\n \n void\n@@ -2364,6 +2379,7 @@ pop_from_top_level (void)\n   struct saved_scope *s = scope_chain;\n   tree t;\n \n+  timevar_push (TV_NAME_LOOKUP); \n   /* Clear out class-level bindings cache.  */\n   if (previous_class_type)\n     invalidate_class_lookup_cache ();\n@@ -2386,6 +2402,7 @@ pop_from_top_level (void)\n     pop_function_context_from (NULL_TREE);\n   current_function_decl = s->function_decl;\n   last_function_parms = s->last_parms;\n+  timevar_pop (TV_NAME_LOOKUP);\n }\n \f\n /* Push a definition of struct, union or enum tag \"name\".\n@@ -2437,18 +2454,19 @@ set_identifier_type_value (tree id, tree type)\n tree\n identifier_type_value (tree id)\n {\n+  timevar_push (TV_NAME_LOOKUP);\n   /* There is no type with that name, anywhere.  */\n   if (REAL_IDENTIFIER_TYPE_VALUE (id) == NULL_TREE)\n-    return NULL_TREE;\n+    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n   /* This is not the type marker, but the real thing.  */\n   if (REAL_IDENTIFIER_TYPE_VALUE (id) != global_type_node)\n-    return REAL_IDENTIFIER_TYPE_VALUE (id);\n+    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, REAL_IDENTIFIER_TYPE_VALUE (id));\n   /* Have to search for it. It must be on the global level, now.\n      Ask lookup_name not to return non-types. */\n   id = lookup_name_real (id, 2, 1, 0, LOOKUP_COMPLAIN);\n   if (id)\n-    return TREE_TYPE (id);\n-  return NULL_TREE;\n+    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, TREE_TYPE (id));\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n }\n \n /* Pop off extraneous binding levels left over due to syntax errors.\n@@ -2571,6 +2589,7 @@ push_local_name (tree decl)\n   size_t i, nelts;\n   tree t, name;\n \n+  timevar_push (TV_NAME_LOOKUP);\n   if (!local_names)\n     VARRAY_TREE_INIT (local_names, 8, \"local_names\");\n \n@@ -2591,11 +2610,12 @@ push_local_name (tree decl)\n \t    DECL_DISCRIMINATOR (decl) = 1;\n \n \t  VARRAY_TREE (local_names, i) = decl;\n-\t  return;\n+\t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, (void)0);\n \t}\n     }\n \n   VARRAY_PUSH_TREE (local_names, decl);\n+  timevar_pop (TV_NAME_LOOKUP);\n }\n \n /* Push a tag name NAME for struct/class/union/enum type TYPE.\n@@ -2608,6 +2628,7 @@ pushtag (tree name, tree type, int globalize)\n {\n   register struct cp_binding_level *b;\n \n+  timevar_push (TV_NAME_LOOKUP);\n   b = current_binding_level;\n   while (b->tag_transparent\n \t || (b->parm_flag == 2\n@@ -2717,6 +2738,7 @@ pushtag (tree name, tree type, int globalize)\n       tree d = build_decl (TYPE_DECL, NULL_TREE, type);\n       TYPE_STUB_DECL (type) = pushdecl_with_scope (d, b);\n     }\n+  timevar_pop (TV_NAME_LOOKUP);\n }\n \n /* Counter used to create anonymous type names.  */\n@@ -3686,6 +3708,7 @@ pushdecl (tree x)\n   register tree name;\n   int need_new_binding;\n \n+  timevar_push (TV_NAME_LOOKUP);\n   /* We shouldn't be calling pushdecl when we're generating RTL for a\n      function that we already did semantic analysis on previously.  */\n   my_friendly_assert (!cfun || doing_semantic_analysis_p (),\n@@ -3809,7 +3832,7 @@ pushdecl (tree x)\n \n \t      /* Check for duplicate params.  */\n \t      if (duplicate_decls (x, t))\n-\t\treturn t;\n+\t\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n \t    }\n \t  else if ((DECL_EXTERN_C_FUNCTION_P (x)\n \t\t    || DECL_FUNCTION_TEMPLATE_P (x))\n@@ -3822,12 +3845,12 @@ pushdecl (tree x)\n \t\t\t    TREE_TYPE (x));\n \n \t      /* Throw away the redeclaration.  */\n-\t      return t;\n+\t      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n \t    }\n \t  else if (TREE_CODE (t) != TREE_CODE (x))\n \t    {\n \t      if (duplicate_decls (x, t))\n-\t\treturn t;\n+\t\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n \t    }\n \t  else if (duplicate_decls (x, t))\n \t    {\n@@ -3836,7 +3859,7 @@ pushdecl (tree x)\n \t      else if (TREE_CODE (t) == FUNCTION_DECL)\n \t\tcheck_default_args (t);\n \n-\t      return t;\n+\t      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n \t    }\n \t  else if (DECL_MAIN_P (x))\n \t    {\n@@ -3850,7 +3873,7 @@ pushdecl (tree x)\n \t      error (\"as `%D'\", x);\n \t      /* We don't try to push this declaration since that\n \t\t causes a crash.  */\n-\t      return x;\n+\t      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, x);\n \t    }\n \t}\n \n@@ -3868,7 +3891,7 @@ pushdecl (tree x)\n \t{\n \t  t = push_overloaded_decl (x, PUSH_LOCAL);\n \t  if (t != x)\n-\t    return t;\n+\t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n \t  if (!namespace_bindings_p ())\n \t    /* We do not need to create a binding for this name;\n \t       push_overloaded_decl will have already done so if\n@@ -3880,7 +3903,7 @@ pushdecl (tree x)\n \t  t = push_overloaded_decl (x, PUSH_GLOBAL);\n \t  if (t == x)\n \t    add_decl_to_level (x, NAMESPACE_LEVEL (CP_DECL_CONTEXT (t)));\n-\t  return t;\n+\t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n \t}\n \n       /* If declaring a type as a typedef, copy the type (unless we're\n@@ -4119,7 +4142,7 @@ pushdecl (tree x)\n \t\t       ? NAMESPACE_LEVEL (CP_DECL_CONTEXT (x))\n \t\t       : current_binding_level);\n \n-  return x;\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, x);\n }\n \n /* Same as pushdecl, but define X in binding-level LEVEL.  We rely on the\n@@ -4131,6 +4154,7 @@ pushdecl_with_scope (tree x, struct cp_binding_level* level)\n   register struct cp_binding_level *b;\n   tree function_decl = current_function_decl;\n \n+  timevar_push (TV_NAME_LOOKUP);\n   current_function_decl = NULL_TREE;\n   if (level->parm_flag == 2)\n     {\n@@ -4147,7 +4171,7 @@ pushdecl_with_scope (tree x, struct cp_binding_level* level)\n       current_binding_level = b;\n     }\n   current_function_decl = function_decl;\n-  return x;\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, x);\n }\n \n /* Like pushdecl, only it places X in the current namespace,\n@@ -4159,6 +4183,7 @@ pushdecl_namespace_level (tree x)\n   register struct cp_binding_level *b = current_binding_level;\n   register tree t;\n \n+  timevar_push (TV_NAME_LOOKUP);\n   t = pushdecl_with_scope (x, NAMESPACE_LEVEL (current_namespace));\n \n   /* Now, the type_shadowed stack may screw us.  Munge it so it does\n@@ -4192,7 +4217,7 @@ pushdecl_namespace_level (tree x)\n \t  *ptr = newval;\n         }\n     }\n-  return t;\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n }\n \n /* Like pushdecl, only it places X in GLOBAL_BINDING_LEVEL,\n@@ -4201,10 +4226,11 @@ pushdecl_namespace_level (tree x)\n tree\n pushdecl_top_level (tree x)\n {\n+  timevar_push (TV_NAME_LOOKUP);\n   push_to_top_level ();\n   x = pushdecl_namespace_level (x);\n   pop_from_top_level ();\n-  return x;\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, x);\n }\n \n /* Make the declaration of X appear in CLASS scope.  */\n@@ -4214,6 +4240,7 @@ pushdecl_class_level (tree x)\n {\n   tree name;\n \n+  timevar_push (TV_NAME_LOOKUP);\n   /* Get the name of X.  */\n   if (TREE_CODE (x) == OVERLOAD)\n     name = DECL_NAME (get_first_fn (x));\n@@ -4236,6 +4263,7 @@ pushdecl_class_level (tree x)\n       for (f = TYPE_FIELDS (TREE_TYPE (x)); f; f = TREE_CHAIN (f))\n \tpushdecl_class_level (f);\n     }\n+  timevar_pop (TV_NAME_LOOKUP);\n }\n \n /* Enter DECL into the symbol table, if that's appropriate.  Returns\n@@ -4274,10 +4302,11 @@ void\n push_class_level_binding (tree name, tree x)\n {\n   tree binding;\n+  timevar_push (TV_NAME_LOOKUP);\n   /* The class_binding_level will be NULL if x is a template\n      parameter name in a member template.  */\n   if (!class_binding_level)\n-    return;\n+    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, (void)0);\n \n   /* Make sure that this new member does not have the same name\n      as a template parameter.  */\n@@ -4327,7 +4356,7 @@ push_class_level_binding (tree name, tree x)\n \t    INHERITED_VALUE_BINDING_P (binding) = 0;\n \t    TREE_TYPE (shadow) = x;\n \t    IDENTIFIER_CLASS_VALUE (name) = x;\n-\t    return;\n+\t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, (void)0);\n \t  }\n     }\n \n@@ -4342,6 +4371,7 @@ push_class_level_binding (tree name, tree x)\n \t what to pop later.  */\n       TREE_TYPE (class_binding_level->class_shadowed) = x;\n     }\n+  timevar_pop (TV_NAME_LOOKUP);\n }\n \n /* Insert another USING_DECL into the current binding level, returning\n@@ -4354,18 +4384,20 @@ push_using_decl (tree scope, tree name)\n {\n   tree decl;\n \n+  timevar_push (TV_NAME_LOOKUP);\n   my_friendly_assert (TREE_CODE (scope) == NAMESPACE_DECL, 383);\n   my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 384);\n   for (decl = current_binding_level->usings; decl; decl = TREE_CHAIN (decl))\n     if (DECL_INITIAL (decl) == scope && DECL_NAME (decl) == name)\n       break;\n   if (decl)\n-    return namespace_bindings_p () ? decl : NULL_TREE;\n+    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP,\n+                            namespace_bindings_p () ? decl : NULL_TREE);\n   decl = build_lang_decl (USING_DECL, name, void_type_node);\n   DECL_INITIAL (decl) = scope;\n   TREE_CHAIN (decl) = current_binding_level->usings;\n   current_binding_level->usings = decl;\n-  return decl;\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, decl);\n }\n \n /* Add namespace to using_directives. Return NULL_TREE if nothing was\n@@ -4378,9 +4410,10 @@ push_using_directive (tree used)\n   tree ud = current_binding_level->using_directives;\n   tree iter, ancestor;\n \n+  timevar_push (TV_NAME_LOOKUP);\n   /* Check if we already have this.  */\n   if (purpose_member (used, ud) != NULL_TREE)\n-    return NULL_TREE;\n+    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n \n   /* Recursively add all namespaces used.  */\n   for (iter = DECL_NAMESPACE_USING (used); iter; iter = TREE_CHAIN (iter))\n@@ -4390,7 +4423,7 @@ push_using_directive (tree used)\n   ud = current_binding_level->using_directives;\n   ud = tree_cons (used, ancestor, ud);\n   current_binding_level->using_directives = ud;\n-  return ud;\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, ud);\n }\n \n /* DECL is a FUNCTION_DECL for a non-member function, which may have\n@@ -4420,6 +4453,7 @@ push_overloaded_decl (tree decl, int flags)\n   tree new_binding;\n   int doing_global = (namespace_bindings_p () || !(flags & PUSH_LOCAL));\n \n+  timevar_push (TV_NAME_LOOKUP);\n   if (doing_global)\n     old = namespace_binding (name, DECL_CONTEXT (decl));\n   else\n@@ -4452,7 +4486,7 @@ push_overloaded_decl (tree decl, int flags)\n \t\t\t  decl, fn);\n \n \t      if (duplicate_decls (decl, fn))\n-\t\treturn fn;\n+\t\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, fn);\n \t    }\n \t}\n       else if (old == error_mark_node)\n@@ -4462,7 +4496,7 @@ push_overloaded_decl (tree decl, int flags)\n \t{\n \t  cp_error_at (\"previous non-function declaration `%#D'\", old);\n \t  error (\"conflicts with function declaration `%#D'\", decl);\n-\t  return decl;\n+\t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, decl);\n \t}\n     }\n \n@@ -4511,7 +4545,7 @@ push_overloaded_decl (tree decl, int flags)\n \t\t/* And update the CPLUS_BINDING node.  */\n \t\tBINDING_VALUE (IDENTIFIER_BINDING (name))\n \t\t  = new_binding;\n-\t\treturn decl;\n+\t\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, decl);\n \t      }\n \n \t  /* We should always find a previous binding in this case.  */\n@@ -4522,7 +4556,7 @@ push_overloaded_decl (tree decl, int flags)\n       push_local_binding (name, new_binding, flags);\n     }\n \n-  return decl;\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, decl);\n }\n \f\n /* Generate an implicit declaration for identifier FUNCTIONID\n@@ -4700,18 +4734,19 @@ lookup_label (tree id)\n   tree decl;\n   struct named_label_list *ent;\n \n+  timevar_push (TV_NAME_LOOKUP);\n   /* You can't use labels at global scope.  */\n   if (current_function_decl == NULL_TREE)\n     {\n       error (\"label `%s' referenced outside of any function\",\n \t     IDENTIFIER_POINTER (id));\n-      return NULL_TREE;\n+      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n     }\n \n   /* See if we've already got this label.  */\n   decl = IDENTIFIER_LABEL_VALUE (id);\n   if (decl != NULL_TREE && DECL_CONTEXT (decl) == current_function_decl)\n-    return decl;\n+    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, decl);\n \n   /* Record this label on the list of labels used in this function.\n      We do this before calling make_label_decl so that we get the\n@@ -4728,7 +4763,7 @@ lookup_label (tree id)\n   /* Now fill in the information we didn't have before.  */\n   ent->label_decl = decl;\n \n-  return decl;\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, decl);\n }\n \n /* Declare a local label named ID.  */\n@@ -4952,6 +4987,7 @@ define_label (const char* filename, int line, tree name)\n   struct named_label_list *ent;\n   register struct cp_binding_level *p;\n \n+  timevar_push (TV_NAME_LOOKUP);\n   for (ent = named_labels; ent; ent = ent->next)\n     if (ent->label_decl == decl)\n       break;\n@@ -4967,7 +5003,7 @@ define_label (const char* filename, int line, tree name)\n   if (DECL_INITIAL (decl) != NULL_TREE)\n     {\n       error (\"duplicate label `%D'\", decl);\n-      return 0;\n+      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, 0);\n     }\n   else\n     {\n@@ -4982,8 +5018,9 @@ define_label (const char* filename, int line, tree name)\n \t  ent->binding_level = current_binding_level;\n \t}\n       check_previous_gotos (decl);\n-      return decl;\n+      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, decl);\n     }\n+  timevar_pop (TV_NAME_LOOKUP);\n }\n \n struct cp_switch\n@@ -5181,6 +5218,7 @@ lookup_tag (enum tree_code form,\n      if THISLEVEL_ONLY.  */\n   int allow_template_parms_p = 1;\n \n+  timevar_push (TV_NAME_LOOKUP);\n   for (level = binding_level; level; level = level->level_chain)\n     {\n       register tree tail;\n@@ -5190,7 +5228,7 @@ lookup_tag (enum tree_code form,\n \t    /* There's no need for error checking here, because\n \t       anon names are unique throughout the compilation.  */\n \t    if (TYPE_IDENTIFIER (TREE_VALUE (tail)) == name)\n-\t      return TREE_VALUE (tail);\n+\t      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, TREE_VALUE (tail));\n \t  }\n       else if (level->namespace_p)\n \t/* Do namespace lookup.  */\n@@ -5216,18 +5254,18 @@ lookup_tag (enum tree_code form,\n \t\t   if the typedef doesn't refer to a taggable type.  */\n \t\told = follow_tag_typedef (old);\n \t\tif (!old)\n-\t\t  return NULL_TREE;\n+\t\t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n \t\tif (TREE_CODE (old) != form\n \t\t    && (form == ENUMERAL_TYPE\n \t\t\t|| TREE_CODE (old) == ENUMERAL_TYPE))\n \t\t  {\n \t\t    error (\"`%#D' redeclared as %C\", old, form);\n-\t\t    return NULL_TREE;\n+\t\t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n \t\t  }\n-\t\treturn old;\n+\t\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, old);\n \t      }\n \t    if (thislevel_only || tail == global_namespace)\n-\t      return NULL_TREE;\n+\t      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n \t  }\n       else\n \tfor (tail = level->tags; tail; tail = TREE_CHAIN (tail))\n@@ -5241,9 +5279,9 @@ lookup_tag (enum tree_code form,\n \t\t  {\n \t\t    /* Definition isn't the kind we were looking for.  */\n \t\t    error (\"`%#D' redeclared as %C\", TREE_VALUE (tail), form);\n-\t\t    return NULL_TREE;\n+\t\t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n \t\t  }\n-\t\treturn TREE_VALUE (tail);\n+\t\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, TREE_VALUE (tail));\n \t      }\n \t  }\n       if (thislevel_only && ! level->tag_transparent)\n@@ -5265,10 +5303,10 @@ lookup_tag (enum tree_code form,\n \t      continue;\n \t    }\n \t  else\n-\t    return NULL_TREE;\n+\t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n \t}\n     }\n-  return NULL_TREE;\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n }\n \n /* Given a type, find the tag that was defined for it and return the tag name.\n@@ -5283,6 +5321,7 @@ lookup_tag_reverse (tree type, tree name)\n {\n   register struct cp_binding_level *level;\n \n+  timevar_push (TV_NAME_LOOKUP);\n   for (level = current_binding_level; level; level = level->level_chain)\n     {\n       register tree tail;\n@@ -5292,11 +5331,11 @@ lookup_tag_reverse (tree type, tree name)\n \t    {\n \t      if (name)\n \t\tTREE_PURPOSE (tail) = name;\n-\t      return TREE_PURPOSE (tail);\n+\t      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, TREE_PURPOSE (tail));\n \t    }\n \t}\n     }\n-  return NULL_TREE;\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n }\n \f\n /* Look up NAME in the NAMESPACE.  */\n@@ -5307,17 +5346,18 @@ lookup_namespace_name (tree namespace, tree name)\n   tree val;\n   tree template_id = NULL_TREE;\n \n+  timevar_push (TV_NAME_LOOKUP);\n   my_friendly_assert (TREE_CODE (namespace) == NAMESPACE_DECL, 370);\n \n   if (TREE_CODE (name) == NAMESPACE_DECL)\n     /* This happens for A::B<int> when B is a namespace.  */\n-    return name;\n+    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, name);\n   else if (TREE_CODE (name) == TEMPLATE_DECL)\n     {\n       /* This happens for A::B where B is a template, and there are no\n \t template arguments.  */\n       error (\"invalid use of `%D'\", name);\n-      return error_mark_node;\n+      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n     }\n \n   namespace = ORIGINAL_NAMESPACE (namespace);\n@@ -5336,7 +5376,7 @@ lookup_namespace_name (tree namespace, tree name)\n \n   val = make_node (CPLUS_BINDING);\n   if (!qualified_lookup_using_namespace (name, namespace, val, 0))\n-    return error_mark_node;\n+    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n \n   if (BINDING_VALUE (val))\n     {\n@@ -5359,7 +5399,7 @@ lookup_namespace_name (tree namespace, tree name)\n \t    {\n \t      error (\"`%D::%D' is not a template\",\n \t\t\tnamespace, name);\n-\t      return error_mark_node;\n+\t      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n \t    }\n \t}\n \n@@ -5371,11 +5411,11 @@ lookup_namespace_name (tree namespace, tree name)\n       if (!val || !DECL_P(val)\n           || !DECL_LANG_SPECIFIC(val)\n           || !DECL_ANTICIPATED (val))\n-        return val;\n+        POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, val);\n     }\n \n   error (\"`%D' undeclared in namespace `%D'\", name, namespace);\n-  return error_mark_node;\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n }\n \n /* Hash a TYPENAME_TYPE.  K is really of type `tree'.  */\n@@ -5660,12 +5700,13 @@ select_decl (tree binding, int flags)\n   tree val;\n   val = BINDING_VALUE (binding);\n \n+  timevar_push (TV_NAME_LOOKUP);\n   if (LOOKUP_NAMESPACES_ONLY (flags))\n     {\n       /* We are not interested in types.  */\n       if (val && TREE_CODE (val) == NAMESPACE_DECL)\n-        return val;\n-      return NULL_TREE;\n+        POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, val);\n+      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n     }\n \n   /* If we could have a type and\n@@ -5680,7 +5721,7 @@ select_decl (tree binding, int flags)\n \t       || !DECL_CLASS_TEMPLATE_P (val)))\n     val = NULL_TREE;\n \n-  return val;\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, val);\n }\n \n /* Unscoped lookup of a global: iterate over current namespaces,\n@@ -5697,6 +5738,7 @@ unqualified_namespace_lookup (tree name, int flags, tree* spacesp)\n   struct cp_binding_level *level;\n   tree val = NULL_TREE;\n \n+  timevar_push (TV_NAME_LOOKUP);\n   if (spacesp)\n     *spacesp = NULL_TREE;\n \n@@ -5729,7 +5771,7 @@ unqualified_namespace_lookup (tree name, int flags, tree* spacesp)\n \tif (!lookup_using_namespace (name, b, level->using_directives,\n                                      scope, flags, spacesp))\n \t  /* Give up because of error.  */\n-\t  return error_mark_node;\n+\t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n \n       /* Add all _DECLs seen through global using-directives.  */\n       /* XXX local and global using lists should work equally.  */\n@@ -5739,7 +5781,7 @@ unqualified_namespace_lookup (tree name, int flags, tree* spacesp)\n \t  if (!lookup_using_namespace (name, b, DECL_NAMESPACE_USING (siter),\n \t\t\t\t       scope, flags, spacesp))\n \t    /* Give up because of error.  */\n-\t    return error_mark_node;\n+\t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n \t  if (siter == scope) break;\n \t  siter = CP_DECL_CONTEXT (siter);\n \t}\n@@ -5748,7 +5790,7 @@ unqualified_namespace_lookup (tree name, int flags, tree* spacesp)\n       if (scope == global_namespace)\n \tbreak;\n     }\n-  return val;\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, val);\n }\n \n /* Combine prefer_type and namespaces_only into flags.  */\n@@ -5890,6 +5932,7 @@ lookup_name_real (tree name,\n   tree t;\n   tree val = NULL_TREE;\n \n+  timevar_push (TV_NAME_LOOKUP);\n   /* Conversion operators are handled specially because ordinary\n      unqualified name lookup will not find template conversion\n      operators.  */\n@@ -5913,10 +5956,10 @@ lookup_name_real (tree name,\n \t  class_type = level->this_class;\n \t  operators = lookup_fnfields (class_type, name, /*protect=*/0);\n \t  if (operators)\n-\t    return operators;\n+\t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, operators);\n \t}\n \n-      return NULL_TREE;\n+      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n     }\n \n   flags |= lookup_flags (prefer_type, namespaces_only);\n@@ -5965,7 +6008,7 @@ lookup_name_real (tree name,\n \tval = OVL_FUNCTION (val);\n     }\n \n-  return val;\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, val);\n }\n \n tree\n@@ -5995,6 +6038,7 @@ lookup_name_current_level (tree name)\n   struct cp_binding_level *b;\n   tree t = NULL_TREE;\n \n+  timevar_push (TV_NAME_LOOKUP);\n   b = current_binding_level;\n   while (b->parm_flag == 2)\n     b = b->level_chain;\n@@ -6013,7 +6057,7 @@ lookup_name_current_level (tree name)\n       while (1)\n \t{\n \t  if (BINDING_LEVEL (IDENTIFIER_BINDING (name)) == b)\n-\t    return IDENTIFIER_VALUE (name);\n+\t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, IDENTIFIER_VALUE (name));\n \n \t  if (b->keep == 2)\n \t    b = b->level_chain;\n@@ -6022,7 +6066,7 @@ lookup_name_current_level (tree name)\n \t}\n     }\n \n-  return t;\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n }\n \n /* Like lookup_name_current_level, but for types.  */\n@@ -6032,6 +6076,7 @@ lookup_type_current_level (tree name)\n {\n   register tree t = NULL_TREE;\n \n+  timevar_push (TV_NAME_LOOKUP);\n   my_friendly_assert (! current_binding_level->namespace_p, 980716);\n \n   if (REAL_IDENTIFIER_TYPE_VALUE (name) != NULL_TREE\n@@ -6041,15 +6086,16 @@ lookup_type_current_level (tree name)\n       while (1)\n \t{\n \t  if (purpose_member (name, b->type_shadowed))\n-\t    return REAL_IDENTIFIER_TYPE_VALUE (name);\n+\t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP,\n+                                    REAL_IDENTIFIER_TYPE_VALUE (name));\n \t  if (b->keep == 2)\n \t    b = b->level_chain;\n \t  else\n \t    break;\n \t}\n     }\n \n-  return t;\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n }\n \n \f\n@@ -7892,14 +7938,15 @@ make_rtl_for_nonlocal_decl (tree decl, tree init, const char* asmspec)\n void\n maybe_inject_for_scope_var (tree decl)\n {\n+  timevar_push (TV_NAME_LOOKUP);\n   if (!DECL_NAME (decl))\n-    return;\n+    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, (void)0);\n   \n   /* Declarations of __FUNCTION__ and its ilk appear magically when\n      the variable is first used.  If that happens to be inside a\n      for-loop, we don't want to do anything special.  */\n   if (DECL_PRETTY_FUNCTION_P (decl))\n-    return;\n+    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, (void)0);\n \n   if (current_binding_level->is_for_scope)\n     {\n@@ -7928,6 +7975,7 @@ maybe_inject_for_scope_var (tree decl)\n \t  current_binding_level->is_for_scope = 0;\n \t}\n     }\n+  timevar_pop (TV_NAME_LOOKUP);\n }\n \n /* Generate code to initialize DECL (a local variable).  */\n@@ -12563,6 +12611,7 @@ xref_tag (enum tag_types tag_code, tree name, tree attributes,\n   struct cp_binding_level *b = current_binding_level;\n   tree context = NULL_TREE;\n \n+  timevar_push (TV_NAME_LOOKUP);\n   switch (tag_code)\n     {\n     case record_type:\n@@ -12765,7 +12814,7 @@ xref_tag (enum tag_types tag_code, tree name, tree attributes,\n \n   TYPE_ATTRIBUTES (ref) = attributes;\n \n-  return ref;\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, ref);\n }\n \n tree"}, {"sha": "5d5a018a6aabb6770b3f6d4b917c5a81e649eefe", "filename": "gcc/timevar.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22ffcc6f9f1bffb267892948349c3cbf4bda2991/gcc%2Ftimevar.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22ffcc6f9f1bffb267892948349c3cbf4bda2991/gcc%2Ftimevar.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.h?ref=22ffcc6f9f1bffb267892948349c3cbf4bda2991", "patch": "@@ -76,6 +76,9 @@ typedef enum\n timevar_id_t;\n #undef DEFTIMEVAR\n \n+/* Execute the sequence: timevar_pop (TV), return (E);  */\n+#define POP_TIMEVAR_AND_RETURN(TV, E)  return (timevar_pop (TV), (E))\n+\n extern void init_timevar PARAMS ((void));\n extern void timevar_push PARAMS ((timevar_id_t));\n extern void timevar_pop PARAMS ((timevar_id_t));"}]}