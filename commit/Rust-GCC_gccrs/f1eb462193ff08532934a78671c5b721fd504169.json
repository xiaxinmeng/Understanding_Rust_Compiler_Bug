{"sha": "f1eb462193ff08532934a78671c5b721fd504169", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjFlYjQ2MjE5M2ZmMDg1MzI5MzRhNzg2NzFjNWI3MjFmZDUwNDE2OQ==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2017-07-05T12:02:21Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2017-07-05T12:02:21Z"}, "message": "tree-loop-distribution.c (enum partition_type): New.\n\n\t* tree-loop-distribution.c (enum partition_type): New.\n\t(struct partition): New field type.\n\t(partition_merge_into): Add parameter.  Update partition type.\n\t(data_dep_in_cycle_p, update_type_for_merge): New functions.\n\t(build_rdg_partition_for_vertex): Compute partition type.\n\t(rdg_build_partitions): Dump partition type.\n\t(distribute_loop): Update calls to partition_merge_into.\n\nFrom-SVN: r249992", "tree": {"sha": "5f8db27ca6ad3ae8424e21d38016df36b782cd8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f8db27ca6ad3ae8424e21d38016df36b782cd8d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1eb462193ff08532934a78671c5b721fd504169", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1eb462193ff08532934a78671c5b721fd504169", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1eb462193ff08532934a78671c5b721fd504169", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1eb462193ff08532934a78671c5b721fd504169/comments", "author": null, "committer": null, "parents": [{"sha": "17c5cbdf0fe98348a5bdef7bd6d4857270318091", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17c5cbdf0fe98348a5bdef7bd6d4857270318091", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17c5cbdf0fe98348a5bdef7bd6d4857270318091"}], "stats": {"total": 149, "additions": 133, "deletions": 16}, "files": [{"sha": "0bf90acde0b6f9bf973315d1eb084568e0b6d3dd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1eb462193ff08532934a78671c5b721fd504169/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1eb462193ff08532934a78671c5b721fd504169/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f1eb462193ff08532934a78671c5b721fd504169", "patch": "@@ -1,3 +1,13 @@\n+2017-07-05  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree-loop-distribution.c (enum partition_type): New.\n+\t(struct partition): New field type.\n+\t(partition_merge_into): Add parameter.  Update partition type.\n+\t(data_dep_in_cycle_p, update_type_for_merge): New functions.\n+\t(build_rdg_partition_for_vertex): Compute partition type.\n+\t(rdg_build_partitions): Dump partition type.\n+\t(distribute_loop): Update calls to partition_merge_into.\n+\n 2017-07-05  Bin Cheng  <bin.cheng@arm.com>\n \n \t* tree-loop-distribution.c (struct ddr_hasher): New."}, {"sha": "87fdc154435dcef7d30f2de3f6b8470dbb232336", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 123, "deletions": 16, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1eb462193ff08532934a78671c5b721fd504169/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1eb462193ff08532934a78671c5b721fd504169/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=f1eb462193ff08532934a78671c5b721fd504169", "patch": "@@ -528,11 +528,19 @@ build_rdg (struct loop *loop, control_dependences *cd)\n }\n \n \n-\n+/* Kind of distributed loop.  */\n enum partition_kind {\n     PKIND_NORMAL, PKIND_MEMSET, PKIND_MEMCPY, PKIND_MEMMOVE\n };\n \n+/* Type of distributed loop.  */\n+enum partition_type {\n+    /* The distributed loop can be executed parallelly.  */\n+    PTYPE_PARALLEL = 0,\n+    /* The distributed loop has to be executed sequentially.  */\n+    PTYPE_SEQUENTIAL\n+};\n+\n /* Partition for loop distribution.  */\n struct partition\n {\n@@ -546,6 +554,7 @@ struct partition\n      number of loop (latch) iterations.  */\n   bool plus_one;\n   enum partition_kind kind;\n+  enum partition_type type;\n   /* data-references a kind != PKIND_NORMAL partition is about.  */\n   data_reference_p main_dr;\n   data_reference_p secondary_dr;\n@@ -615,18 +624,16 @@ static const char *fuse_message[] = {\n   \"they are in the same dependence scc\",\n   \"there is no point to distribute loop\"};\n \n-/* Merge PARTITION into the partition DEST.  */\n-\n static void\n-partition_merge_into (partition *dest, partition *partition, enum fuse_type ft)\n-{\n-  dest->kind = PKIND_NORMAL;\n-  bitmap_ior_into (dest->stmts, partition->stmts);\n-  if (partition_reduction_p (partition))\n-    dest->reduction_p = true;\n+update_type_for_merge (struct graph *, partition *, partition *);\n \n-  bitmap_ior_into (dest->datarefs, partition->datarefs);\n+/* Merge PARTITION into the partition DEST.  RDG is the reduced dependence\n+   graph and we update type for result partition if it is non-NULL.  */\n \n+static void\n+partition_merge_into (struct graph *rdg, partition *dest,\n+\t\t      partition *partition, enum fuse_type ft)\n+{\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"Fuse partitions because %s:\\n\", fuse_message[ft]);\n@@ -635,6 +642,21 @@ partition_merge_into (partition *dest, partition *partition, enum fuse_type ft)\n       fprintf (dump_file, \"  Part 2: \");\n       dump_bitmap (dump_file, partition->stmts);\n     }\n+\n+  dest->kind = PKIND_NORMAL;\n+  if (dest->type == PTYPE_PARALLEL)\n+    dest->type = partition->type;\n+\n+  bitmap_ior_into (dest->stmts, partition->stmts);\n+  if (partition_reduction_p (partition))\n+    dest->reduction_p = true;\n+\n+  /* Further check if any data dependence prevents us from executing the\n+     new partition parallelly.  */\n+  if (dest->type == PTYPE_PARALLEL && rdg != NULL)\n+    update_type_for_merge (rdg, dest, partition);\n+\n+  bitmap_ior_into (dest->datarefs, partition->datarefs);\n }\n \n \n@@ -1117,6 +1139,75 @@ get_data_dependence (struct graph *rdg, data_reference_p a, data_reference_p b)\n   return *slot;\n }\n \n+/* In reduced dependence graph RDG for loop distribution, return true if\n+   dependence between references DR1 and DR2 leads to a dependence cycle\n+   and such dependence cycle can't be resolved by runtime alias check.  */\n+\n+static bool\n+data_dep_in_cycle_p (struct graph *rdg,\n+\t\t     data_reference_p dr1, data_reference_p dr2)\n+{\n+  struct data_dependence_relation *ddr;\n+\n+  /* Re-shuffle data-refs to be in topological order.  */\n+  if (rdg_vertex_for_stmt (rdg, DR_STMT (dr1))\n+      > rdg_vertex_for_stmt (rdg, DR_STMT (dr2)))\n+    std::swap (dr1, dr2);\n+\n+  ddr = get_data_dependence (rdg, dr1, dr2);\n+\n+  /* In case of no data dependence.  */\n+  if (DDR_ARE_DEPENDENT (ddr) == chrec_known)\n+    return false;\n+  /* For unknown data dependence or known data dependence which can't be\n+     expressed in classic distance vector, we check if it can be resolved\n+     by runtime alias check.  If yes, we still consider data dependence\n+     as won't introduce data dependence cycle.  */\n+  else if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know\n+\t   || DDR_NUM_DIST_VECTS (ddr) == 0)\n+    return !runtime_alias_check_p (ddr, NULL, true);\n+  else if (DDR_NUM_DIST_VECTS (ddr) > 1)\n+    return true;\n+  else if (DDR_REVERSED_P (ddr)\n+\t   || lambda_vector_zerop (DDR_DIST_VECT (ddr, 0), 1))\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Given reduced dependence graph RDG, PARTITION1 and PARTITION2, update\n+   PARTITION1's type after merging PARTITION2 into PARTITION1.  */\n+\n+static void\n+update_type_for_merge (struct graph *rdg,\n+\t\t       partition *partition1, partition *partition2)\n+{\n+  unsigned i, j;\n+  bitmap_iterator bi, bj;\n+  data_reference_p dr1, dr2;\n+\n+  EXECUTE_IF_SET_IN_BITMAP (partition1->datarefs, 0, i, bi)\n+    {\n+      unsigned start = (partition1 == partition2) ? i + 1 : 0;\n+\n+      dr1 = datarefs_vec[i];\n+      EXECUTE_IF_SET_IN_BITMAP (partition2->datarefs, start, j, bj)\n+\t{\n+\t  dr2 = datarefs_vec[j];\n+\t  if (DR_IS_READ (dr1) && DR_IS_READ (dr2))\n+\t    continue;\n+\n+\t  /* Partition can only be executed sequentially if there is any\n+\t     data dependence cycle.  */\n+\t  if (data_dep_in_cycle_p (rdg, dr1, dr2))\n+\t    {\n+\t      partition1->type = PTYPE_SEQUENTIAL;\n+\t      return;\n+\t    }\n+\t}\n+    }\n+}\n+\n /* Returns a partition with all the statements needed for computing\n    the vertex V of the RDG, also including the loop exit conditions.  */\n \n@@ -1142,10 +1233,23 @@ build_rdg_partition_for_vertex (struct graph *rdg, int v)\n \t  unsigned idx = (unsigned) DR_INDEX (dr);\n \t  gcc_assert (idx < datarefs_vec.length ());\n \n+\t  /* Partition can only be executed sequentially if there is any\n+\t     unknown data reference.  */\n+\t  if (!DR_BASE_ADDRESS (dr) || !DR_OFFSET (dr)\n+\t      || !DR_INIT (dr) || !DR_STEP (dr))\n+\t    partition->type = PTYPE_SEQUENTIAL;\n+\n \t  bitmap_set_bit (partition->datarefs, idx);\n \t}\n     }\n \n+  if (partition->type == PTYPE_SEQUENTIAL)\n+    return partition;\n+\n+  /* Further check if any data dependence prevents us from executing the\n+     partition parallelly.  */\n+  update_type_for_merge (rdg, partition, partition);\n+\n   return partition;\n }\n \n@@ -1388,8 +1492,9 @@ rdg_build_partitions (struct graph *rdg,\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n-\t  fprintf (dump_file, \"ldist useful partition:\\n\");\n-\t  dump_bitmap (dump_file, partition->stmts);\n+\t  fprintf (dump_file, \"ldist creates useful %s partition:\\n\",\n+\t\t   partition->type == PTYPE_PARALLEL ? \"parallel\" : \"sequent\");\n+\t  bitmap_print (dump_file, partition->stmts, \"  \", \"\\n\");\n \t}\n \n       partitions->safe_push (partition);\n@@ -1655,7 +1760,7 @@ distribute_loop (struct loop *loop, vec<gimple *> stmts,\n       for (++i; partitions.iterate (i, &partition); ++i)\n \tif (!partition_builtin_p (partition))\n \t  {\n-\t    partition_merge_into (into, partition, FUSE_NON_BUILTIN);\n+\t    partition_merge_into (NULL, into, partition, FUSE_NON_BUILTIN);\n \t    partitions.unordered_remove (i);\n \t    partition_free (partition);\n \t    i--;\n@@ -1671,7 +1776,7 @@ distribute_loop (struct loop *loop, vec<gimple *> stmts,\n   for (i = i + 1; partitions.iterate (i, &partition); ++i)\n     if (partition_reduction_p (partition))\n       {\n-\tpartition_merge_into (into, partition, FUSE_REDUCTION);\n+\tpartition_merge_into (rdg, into, partition, FUSE_REDUCTION);\n \tpartitions.unordered_remove (i);\n \tpartition_free (partition);\n \ti--;\n@@ -1689,7 +1794,7 @@ distribute_loop (struct loop *loop, vec<gimple *> stmts,\n \t{\n \t  if (share_memory_accesses (rdg, into, partition))\n \t    {\n-\t      partition_merge_into (into, partition, FUSE_SHARE_REF);\n+\t      partition_merge_into (rdg, into, partition, FUSE_SHARE_REF);\n \t      partitions.unordered_remove (j);\n \t      partition_free (partition);\n \t      j--;\n@@ -1759,7 +1864,9 @@ distribute_loop (struct loop *loop, vec<gimple *> stmts,\n \t  for (j = j + 1; partitions.iterate (j, &partition); ++j)\n \t    if (pg->vertices[j].component == i)\n \t      {\n-\t\tpartition_merge_into (first, partition, FUSE_SAME_SCC);\n+\t\tpartition_merge_into (NULL, first,\n+\t\t\t\t      partition, FUSE_SAME_SCC);\n+\t\tfirst->type = PTYPE_SEQUENTIAL;\n \t\tpartitions[j] = NULL;\n \t\tpartition_free (partition);\n \t\tPGDATA (j)->partition = NULL;"}]}