{"sha": "af7f140f2f17b5290ec09266329bd719a7d49d99", "node_id": "C_kwDOANBUbNoAKGFmN2YxNDBmMmYxN2I1MjkwZWMwOTI2NjMyOWJkNzE5YTdkNDlkOTk", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-06-20T09:22:11Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-06-24T13:11:02Z"}, "message": "ast: Allow disambiguation of ConstGenericArgs to const generic arguments\n\nAt the AST level, we might encounter situations where const generic\narguments are ambiguous: They could be resolved to either a type or a\nconst expression, as shown in this example:\n\n```rust\nlet a: Foo<N>; // what is N? A type? A const? The parser doesn't know\n```\n\nHowever, when parsing default expressions for const generic parameters,\nwe need to be able to disambiguate to const expressions early:\n\n```rust\nstruct Foo<const N: usize = { M }> {\n    /* ... */\n}\n```\n\nIn that code, `M` could be considered ambiguous: Is it a type? a const?\nA random non-const variable? What matters is that we disambiguate it to\na const generic argument, so that it errors out appropriately in later\nphases of the compiler.\n\nIn that case, we need to go from a `ConstArg::Ambiguous(\"M\")` to a\n`ConstArg::Clear(IdentifierExpr(\"M\"))`.\n\nIn later passes of the compiler, we will also need to disambiguate to\ntypes. But that will be done at the HIR/Resolving level.", "tree": {"sha": "94356d2fde7a77b6dec1a7e1b9baaf2e0233ac0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/94356d2fde7a77b6dec1a7e1b9baaf2e0233ac0c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af7f140f2f17b5290ec09266329bd719a7d49d99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af7f140f2f17b5290ec09266329bd719a7d49d99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af7f140f2f17b5290ec09266329bd719a7d49d99", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af7f140f2f17b5290ec09266329bd719a7d49d99/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b90f0b3cdbe8b83cd8139d0e1bdb0e8e086e358", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b90f0b3cdbe8b83cd8139d0e1bdb0e8e086e358", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b90f0b3cdbe8b83cd8139d0e1bdb0e8e086e358"}], "stats": {"total": 44, "additions": 31, "deletions": 13}, "files": [{"sha": "0d4d36b36cc2150b29e09b726d354ee95ea85913", "filename": "gcc/rust/ast/rust-ast-full-test.cc", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af7f140f2f17b5290ec09266329bd719a7d49d99/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af7f140f2f17b5290ec09266329bd719a7d49d99/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-test.cc?ref=af7f140f2f17b5290ec09266329bd719a7d49d99", "patch": "@@ -4096,10 +4096,10 @@ DelimTokenTree::parse_to_meta_item () const\n \n   /* assume top-level delim token tree in attribute - convert all nested ones\n    * to token stream */\n-  std::vector<std::unique_ptr<Token> > token_stream = to_token_stream ();\n+  std::vector<std::unique_ptr<Token>> token_stream = to_token_stream ();\n \n   AttributeParser parser (std::move (token_stream));\n-  std::vector<std::unique_ptr<MetaItemInner> > meta_items (\n+  std::vector<std::unique_ptr<MetaItemInner>> meta_items (\n     parser.parse_meta_item_seq ());\n \n   return new AttrInputMetaItemContainer (std::move (meta_items));\n@@ -4282,7 +4282,7 @@ AttributeParser::parse_path_meta_item ()\n   switch (peek_token ()->get_id ())\n     {\n       case LEFT_PAREN: {\n-\tstd::vector<std::unique_ptr<MetaItemInner> > meta_items\n+\tstd::vector<std::unique_ptr<MetaItemInner>> meta_items\n \t  = parse_meta_item_seq ();\n \n \treturn std::unique_ptr<MetaItemSeq> (\n@@ -4320,11 +4320,11 @@ AttributeParser::parse_path_meta_item ()\n \n /* Parses a parenthesised sequence of meta item inners. Parentheses are\n  * required here. */\n-std::vector<std::unique_ptr<MetaItemInner> >\n+std::vector<std::unique_ptr<MetaItemInner>>\n AttributeParser::parse_meta_item_seq ()\n {\n   int vec_length = token_stream.size ();\n-  std::vector<std::unique_ptr<MetaItemInner> > meta_items;\n+  std::vector<std::unique_ptr<MetaItemInner>> meta_items;\n \n   if (peek_token ()->get_id () != LEFT_PAREN)\n     {\n@@ -4364,13 +4364,13 @@ AttributeParser::parse_meta_item_seq ()\n \n /* Collects any nested token trees into a flat token stream, suitable for\n  * parsing. */\n-std::vector<std::unique_ptr<Token> >\n+std::vector<std::unique_ptr<Token>>\n DelimTokenTree::to_token_stream () const\n {\n-  std::vector<std::unique_ptr<Token> > tokens;\n+  std::vector<std::unique_ptr<Token>> tokens;\n   for (const auto &tree : token_trees)\n     {\n-      std::vector<std::unique_ptr<Token> > stream = tree->to_token_stream ();\n+      std::vector<std::unique_ptr<Token>> stream = tree->to_token_stream ();\n \n       tokens.insert (tokens.end (), std::make_move_iterator (stream.begin ()),\n \t\t     std::make_move_iterator (stream.end ()));\n@@ -4711,12 +4711,12 @@ MetaItemPathLit::check_cfg_predicate (const Session &session) const\n \t\t\t\t\t\t\t lit.as_string ());\n }\n \n-std::vector<std::unique_ptr<Token> >\n+std::vector<std::unique_ptr<Token>>\n Token::to_token_stream () const\n {\n   /* initialisation list doesn't work as it needs copy constructor, so have to\n    * do this */\n-  std::vector<std::unique_ptr<Token> > dummy_vector;\n+  std::vector<std::unique_ptr<Token>> dummy_vector;\n   dummy_vector.reserve (1);\n   dummy_vector.push_back (std::unique_ptr<Token> (clone_token_impl ()));\n   return dummy_vector;\n@@ -4744,7 +4744,7 @@ MetaItemPath::to_attribute () const\n Attribute\n MetaItemSeq::to_attribute () const\n {\n-  std::vector<std::unique_ptr<MetaItemInner> > new_seq;\n+  std::vector<std::unique_ptr<MetaItemInner>> new_seq;\n   new_seq.reserve (seq.size ());\n   for (const auto &e : seq)\n     new_seq.push_back (e->clone_meta_item_inner ());\n@@ -4768,7 +4768,7 @@ MetaListPaths::to_attribute () const\n    * no longer known). If conversions back are required, might have to do a\n    * \"check all are paths\" pass or something. */\n \n-  std::vector<std::unique_ptr<MetaItemInner> > new_seq;\n+  std::vector<std::unique_ptr<MetaItemInner>> new_seq;\n   new_seq.reserve (paths.size ());\n   for (const auto &e : paths)\n     new_seq.push_back (std::unique_ptr<MetaItemPath> (new MetaItemPath (e)));\n@@ -4782,7 +4782,7 @@ MetaListPaths::to_attribute () const\n Attribute\n MetaListNameValueStr::to_attribute () const\n {\n-  std::vector<std::unique_ptr<MetaItemInner> > new_seq;\n+  std::vector<std::unique_ptr<MetaItemInner>> new_seq;\n   new_seq.reserve (strs.size ());\n   for (const auto &e : strs)\n     new_seq.push_back (\n@@ -5792,5 +5792,17 @@ MetaWord::accept_vis (ASTVisitor &vis)\n {\n   vis.visit (*this);\n }\n+\n+ConstGenericArg\n+ConstGenericArg::disambiguate_to_const () const\n+{\n+  rust_assert (get_kind () == Kind::Ambiguous);\n+\n+  // FIXME: is it fine to have no outer attributes?\n+  return ConstGenericArg (std::unique_ptr<Expr> (\n+\t\t\t    new IdentifierExpr (path, {}, locus)),\n+\t\t\t  locus);\n+}\n+\n } // namespace AST\n } // namespace Rust"}, {"sha": "d2d925a01ce0a94c308aa7ee8a1869b48a5bc46b", "filename": "gcc/rust/ast/rust-path.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af7f140f2f17b5290ec09266329bd719a7d49d99/gcc%2Frust%2Fast%2Frust-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af7f140f2f17b5290ec09266329bd719a7d49d99/gcc%2Frust%2Fast%2Frust-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-path.h?ref=af7f140f2f17b5290ec09266329bd719a7d49d99", "patch": "@@ -208,6 +208,12 @@ class ConstGenericArg\n     return \"\";\n   }\n \n+  /**\n+   * Disambiguate an amibguous const generic argument or generic type argument\n+   * to a const generic argument, unequivocally\n+   */\n+  ConstGenericArg disambiguate_to_const () const;\n+\n private:\n   ConstGenericArg (std::unique_ptr<AST::Expr> expression, Identifier path,\n \t\t   Kind kind, Location locus)"}]}