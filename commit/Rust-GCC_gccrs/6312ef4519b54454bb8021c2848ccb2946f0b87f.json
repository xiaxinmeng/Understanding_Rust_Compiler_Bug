{"sha": "6312ef4519b54454bb8021c2848ccb2946f0b87f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjMxMmVmNDUxOWI1NDQ1NGJiODAyMWMyODQ4Y2NiMjk0NmYwYjg3Zg==", "commit": {"author": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2010-11-25T22:04:59Z"}, "committer": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2010-11-25T22:04:59Z"}, "message": "re PR fortran/46581 ([OOP] segfault in SELECT TYPE with associate-name)\n\n2010-11-25  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/46581\n\t* trans.h (gfc_process_block_locals): Removed second argument.\n\t* trans-decl.c (trans_associate_var): Moved to trans-stmt.c.\n\t(gfc_trans_deferred_vars): Skip ASSOCIATE variables.\n\t(gfc_process_block_locals): Don't mark associate names to be\n\tinitialized.\n\t* trans-stmt.c (trans_associate_var): Moved here from trans-decl.c.\n\t(gfc_trans_block_construct): Call 'trans_associate_var' from here\n\tto make sure SELECT TYPE with associate-name is treated correctly.\n\n2010-11-25  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/46581\n\t* gfortran.dg/select_type_19.f03: New.\n\nFrom-SVN: r167154", "tree": {"sha": "bc1d2222c6b14d7dde81673bb184b46209dc5d91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc1d2222c6b14d7dde81673bb184b46209dc5d91"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6312ef4519b54454bb8021c2848ccb2946f0b87f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6312ef4519b54454bb8021c2848ccb2946f0b87f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6312ef4519b54454bb8021c2848ccb2946f0b87f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6312ef4519b54454bb8021c2848ccb2946f0b87f/comments", "author": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be82759165691e01352cab8d9b9c20a75e69514d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be82759165691e01352cab8d9b9c20a75e69514d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be82759165691e01352cab8d9b9c20a75e69514d"}], "stats": {"total": 235, "additions": 135, "deletions": 100}, "files": [{"sha": "fa1dc77166c882d1b1e17cc7c4720f1e68f37c65", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6312ef4519b54454bb8021c2848ccb2946f0b87f/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6312ef4519b54454bb8021c2848ccb2946f0b87f/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=6312ef4519b54454bb8021c2848ccb2946f0b87f", "patch": "@@ -1,3 +1,15 @@\n+2010-11-25  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/46581\n+\t* trans.h (gfc_process_block_locals): Removed second argument.\n+\t* trans-decl.c (trans_associate_var): Moved to trans-stmt.c.\n+\t(gfc_trans_deferred_vars): Skip ASSOCIATE variables.\n+\t(gfc_process_block_locals): Don't mark associate names to be\n+\tinitialized.\n+\t* trans-stmt.c (trans_associate_var): Moved here from trans-decl.c.\n+\t(gfc_trans_block_construct): Call 'trans_associate_var' from here\n+\tto make sure SELECT TYPE with associate-name is treated correctly.\n+\n 2010-11-24  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/46638"}, {"sha": "3eb70f8c0890494c7ef6de9af57448fd41c8fc71", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 4, "deletions": 97, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6312ef4519b54454bb8021c2848ccb2946f0b87f/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6312ef4519b54454bb8021c2848ccb2946f0b87f/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=6312ef4519b54454bb8021c2848ccb2946f0b87f", "patch": "@@ -3165,91 +3165,6 @@ init_intent_out_dt (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n }\n \n \n-/* Do proper initialization for ASSOCIATE names.  */\n-\n-static void\n-trans_associate_var (gfc_symbol* sym, gfc_wrapped_block* block)\n-{\n-  gfc_expr* e;\n-  tree tmp;\n-\n-  gcc_assert (sym->assoc);\n-  e = sym->assoc->target;\n-\n-  /* Do a `pointer assignment' with updated descriptor (or assign descriptor\n-     to array temporary) for arrays with either unknown shape or if associating\n-     to a variable.  */\n-  if (sym->attr.dimension\n-      && (sym->as->type == AS_DEFERRED || sym->assoc->variable))\n-    {\n-      gfc_se se;\n-      gfc_ss* ss;\n-      tree desc;\n-\n-      desc = sym->backend_decl;\n-\n-      /* If association is to an expression, evaluate it and create temporary.\n-\t Otherwise, get descriptor of target for pointer assignment.  */\n-      gfc_init_se (&se, NULL);\n-      ss = gfc_walk_expr (e);\n-      if (sym->assoc->variable)\n-\t{\n-\t  se.direct_byref = 1;\n-\t  se.expr = desc;\n-\t}\n-      gfc_conv_expr_descriptor (&se, e, ss);\n-\n-      /* If we didn't already do the pointer assignment, set associate-name\n-\t descriptor to the one generated for the temporary.  */\n-      if (!sym->assoc->variable)\n-\t{\n-\t  int dim;\n-\n-\t  gfc_add_modify (&se.pre, desc, se.expr);\n-\n-\t  /* The generated descriptor has lower bound zero (as array\n-\t     temporary), shift bounds so we get lower bounds of 1.  */\n-\t  for (dim = 0; dim < e->rank; ++dim)\n-\t    gfc_conv_shift_descriptor_lbound (&se.pre, desc,\n-\t\t\t\t\t      dim, gfc_index_one_node);\n-\t}\n-\n-      /* Done, register stuff as init / cleanup code.  */\n-      gfc_add_init_cleanup (block, gfc_finish_block (&se.pre),\n-\t\t\t    gfc_finish_block (&se.post));\n-    }\n-\n-  /* Do a scalar pointer assignment; this is for scalar variable targets.  */\n-  else if (gfc_is_associate_pointer (sym))\n-    {\n-      gfc_se se;\n-\n-      gcc_assert (!sym->attr.dimension);\n-\n-      gfc_init_se (&se, NULL);\n-      gfc_conv_expr (&se, e);\n-\n-      tmp = TREE_TYPE (sym->backend_decl);\n-      tmp = gfc_build_addr_expr (tmp, se.expr);\n-      gfc_add_modify (&se.pre, sym->backend_decl, tmp);\n-      \n-      gfc_add_init_cleanup (block, gfc_finish_block( &se.pre),\n-\t\t\t    gfc_finish_block (&se.post));\n-    }\n-\n-  /* Do a simple assignment.  This is for scalar expressions, where we\n-     can simply use expression assignment.  */\n-  else\n-    {\n-      gfc_expr* lhs;\n-\n-      lhs = gfc_lval_expr_from_sym (sym);\n-      tmp = gfc_trans_assignment (lhs, e, false, true);\n-      gfc_add_init_cleanup (block, tmp, NULL_TREE);\n-    }\n-}\n-\n-\n /* Generate function entry and exit code, and add it to the function body.\n    This includes:\n     Allocation and initialization of array variables.\n@@ -3316,8 +3231,9 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n       bool sym_has_alloc_comp = (sym->ts.type == BT_DERIVED)\n \t\t\t\t   && sym->ts.u.derived->attr.alloc_comp;\n       if (sym->assoc)\n-\ttrans_associate_var (sym, block);\n-      else if (sym->attr.dimension)\n+\tcontinue;\n+\n+      if (sym->attr.dimension)\n \t{\n \t  switch (sym->as->type)\n \t    {\n@@ -4890,22 +4806,13 @@ gfc_generate_block_data (gfc_namespace * ns)\n /* Process the local variables of a BLOCK construct.  */\n \n void\n-gfc_process_block_locals (gfc_namespace* ns, gfc_association_list* assoc)\n+gfc_process_block_locals (gfc_namespace* ns)\n {\n   tree decl;\n \n   gcc_assert (saved_local_decls == NULL_TREE);\n   generate_local_vars (ns);\n \n-  /* Mark associate names to be initialized.  The symbol's namespace may not\n-     be the BLOCK's, we have to force this so that the deferring\n-     works as expected.  */\n-  for (; assoc; assoc = assoc->next)\n-    {\n-      assoc->st->n.sym->ns = ns;\n-      gfc_defer_symbol_init (assoc->st->n.sym);\n-    }\n-\n   decl = saved_local_decls;\n   while (decl)\n     {"}, {"sha": "c64b5f2bcd961e237db26788c9b1b8661c18b2f5", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 90, "deletions": 2, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6312ef4519b54454bb8021c2848ccb2946f0b87f/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6312ef4519b54454bb8021c2848ccb2946f0b87f/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=6312ef4519b54454bb8021c2848ccb2946f0b87f", "patch": "@@ -866,6 +866,91 @@ gfc_trans_critical (gfc_code *code)\n }\n \n \n+/* Do proper initialization for ASSOCIATE names.  */\n+\n+static void\n+trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)\n+{\n+  gfc_expr *e;\n+  tree tmp;\n+\n+  gcc_assert (sym->assoc);\n+  e = sym->assoc->target;\n+\n+  /* Do a `pointer assignment' with updated descriptor (or assign descriptor\n+     to array temporary) for arrays with either unknown shape or if associating\n+     to a variable.  */\n+  if (sym->attr.dimension\n+      && (sym->as->type == AS_DEFERRED || sym->assoc->variable))\n+    {\n+      gfc_se se;\n+      gfc_ss *ss;\n+      tree desc;\n+\n+      desc = sym->backend_decl;\n+\n+      /* If association is to an expression, evaluate it and create temporary.\n+\t Otherwise, get descriptor of target for pointer assignment.  */\n+      gfc_init_se (&se, NULL);\n+      ss = gfc_walk_expr (e);\n+      if (sym->assoc->variable)\n+\t{\n+\t  se.direct_byref = 1;\n+\t  se.expr = desc;\n+\t}\n+      gfc_conv_expr_descriptor (&se, e, ss);\n+\n+      /* If we didn't already do the pointer assignment, set associate-name\n+\t descriptor to the one generated for the temporary.  */\n+      if (!sym->assoc->variable)\n+\t{\n+\t  int dim;\n+\n+\t  gfc_add_modify (&se.pre, desc, se.expr);\n+\n+\t  /* The generated descriptor has lower bound zero (as array\n+\t     temporary), shift bounds so we get lower bounds of 1.  */\n+\t  for (dim = 0; dim < e->rank; ++dim)\n+\t    gfc_conv_shift_descriptor_lbound (&se.pre, desc,\n+\t\t\t\t\t      dim, gfc_index_one_node);\n+\t}\n+\n+      /* Done, register stuff as init / cleanup code.  */\n+      gfc_add_init_cleanup (block, gfc_finish_block (&se.pre),\n+\t\t\t    gfc_finish_block (&se.post));\n+    }\n+\n+  /* Do a scalar pointer assignment; this is for scalar variable targets.  */\n+  else if (gfc_is_associate_pointer (sym))\n+    {\n+      gfc_se se;\n+\n+      gcc_assert (!sym->attr.dimension);\n+\n+      gfc_init_se (&se, NULL);\n+      gfc_conv_expr (&se, e);\n+\n+      tmp = TREE_TYPE (sym->backend_decl);\n+      tmp = gfc_build_addr_expr (tmp, se.expr);\n+      gfc_add_modify (&se.pre, sym->backend_decl, tmp);\n+      \n+      gfc_add_init_cleanup (block, gfc_finish_block( &se.pre),\n+\t\t\t    gfc_finish_block (&se.post));\n+    }\n+\n+  /* Do a simple assignment.  This is for scalar expressions, where we\n+     can simply use expression assignment.  */\n+  else\n+    {\n+      gfc_expr *lhs;\n+\n+      lhs = gfc_lval_expr_from_sym (sym);\n+      tmp = gfc_trans_assignment (lhs, e, false, true);\n+      gfc_add_init_cleanup (block, tmp, NULL_TREE);\n+    }\n+}\n+\n+\n /* Translate a BLOCK construct.  This is basically what we would do for a\n    procedure body.  */\n \n@@ -877,6 +962,7 @@ gfc_trans_block_construct (gfc_code* code)\n   gfc_wrapped_block block;\n   tree exit_label;\n   stmtblock_t body;\n+  gfc_association_list *ass;\n \n   ns = code->ext.block.ns;\n   gcc_assert (ns);\n@@ -886,7 +972,7 @@ gfc_trans_block_construct (gfc_code* code)\n   /* Process local variables.  */\n   gcc_assert (!sym->tlink);\n   sym->tlink = sym;\n-  gfc_process_block_locals (ns, code->ext.block.assoc);\n+  gfc_process_block_locals (ns);\n \n   /* Generate code including exit-label.  */\n   gfc_init_block (&body);\n@@ -898,7 +984,9 @@ gfc_trans_block_construct (gfc_code* code)\n   /* Finish everything.  */\n   gfc_start_wrapped_block (&block, gfc_finish_block (&body));\n   gfc_trans_deferred_vars (sym, &block);\n-\n+  for (ass = code->ext.block.assoc; ass; ass = ass->next)\n+    trans_associate_var (ass->st->n.sym, &block);\n+    \n   return gfc_finish_wrapped_block (&block);\n }\n "}, {"sha": "b5e30ff1cecc8a6a899a2fbc9ffd012d3a713bb1", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6312ef4519b54454bb8021c2848ccb2946f0b87f/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6312ef4519b54454bb8021c2848ccb2946f0b87f/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=6312ef4519b54454bb8021c2848ccb2946f0b87f", "patch": "@@ -554,7 +554,7 @@ tree gfc_build_library_function_decl_with_spec (tree name, const char *spec,\n \t\t\t\t\t\ttree rettype, int nargs, ...);\n \n /* Process the local variable decls of a block construct.  */\n-void gfc_process_block_locals (gfc_namespace*, gfc_association_list*);\n+void gfc_process_block_locals (gfc_namespace*);\n \n /* Output initialization/clean-up code that was deferred.  */\n void gfc_trans_deferred_vars (gfc_symbol*, gfc_wrapped_block *);"}, {"sha": "e8e33412a5ee35ea513605a61610e37b3d832888", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6312ef4519b54454bb8021c2848ccb2946f0b87f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6312ef4519b54454bb8021c2848ccb2946f0b87f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6312ef4519b54454bb8021c2848ccb2946f0b87f", "patch": "@@ -1,3 +1,8 @@\n+2010-11-25  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/46581\n+\t* gfortran.dg/select_type_19.f03: New.\n+\n 2010-11-25  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc.dg/ivar-problem-1.m: New."}, {"sha": "0ae2e1ce2fe515d09593c169fd56281a44e4e7d4", "filename": "gcc/testsuite/gfortran.dg/select_type_19.f03", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6312ef4519b54454bb8021c2848ccb2946f0b87f/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_19.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6312ef4519b54454bb8021c2848ccb2946f0b87f/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_19.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_19.f03?ref=6312ef4519b54454bb8021c2848ccb2946f0b87f", "patch": "@@ -0,0 +1,23 @@\n+! { dg-do run }\n+!\n+! PR 46581: [4.6 Regression] [OOP] segfault in SELECT TYPE with associate-name\n+!\n+! Contributed by Salvatore Filippone <sfilippone@uniroma2.it>\n+\n+\n+  implicit none\n+\n+  type :: t1\n+    integer, allocatable :: ja(:)\n+  end type\n+\n+  class(t1), allocatable  :: a \n+\n+  allocate(a)\n+\n+  select type (aa=>a)\n+  type is (t1)\n+    if (allocated(aa%ja)) call abort()\n+  end select\n+\n+end"}]}