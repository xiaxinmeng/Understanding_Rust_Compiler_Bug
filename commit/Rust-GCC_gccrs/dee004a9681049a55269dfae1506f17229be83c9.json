{"sha": "dee004a9681049a55269dfae1506f17229be83c9", "node_id": "C_kwDOANBUbNoAKGRlZTAwNGE5NjgxMDQ5YTU1MjY5ZGZhZTE1MDZmMTcyMjliZTgzYzk", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-11-15T07:53:46Z"}, "committer": {"name": "Marc Poulhi\u00e8s", "email": "poulhies@adacore.com", "date": "2022-11-21T10:10:33Z"}, "message": "ada: Small cleanup in Expand_N_Object_Declaration\n\nThis reuses a local constant more consistently, removes a duplicate of this\nlocal constant, renames local variables, alphabetizes declarations, makes a\nfew consistency tweaks and adjusts a couple of comments.\n\nNo functional changes.\n\ngcc/ada/\n\n\t* exp_ch3.adb (Expand_N_Object_Declaration): Use Typ local\n\tconstant throughout, remove Ret_Obj_Typ local constant, rename\n\tRef_Type into Acc_Typ in a couple of places, remove a useless call\n\tto Set_Etype, use a consistent checks suppression scheme, adjust\n\tcomments for the sake of consistencty and alphabetize some local\n\tdeclarations.\n\t* exp_ch6.adb (Expand_Simple_Function_Return): Remove a couple of\n\tredundant local constants.", "tree": {"sha": "5d0a09219f3066b2a1a1f2429fbb7e6d67743bd3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d0a09219f3066b2a1a1f2429fbb7e6d67743bd3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dee004a9681049a55269dfae1506f17229be83c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dee004a9681049a55269dfae1506f17229be83c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dee004a9681049a55269dfae1506f17229be83c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dee004a9681049a55269dfae1506f17229be83c9/comments", "author": null, "committer": {"login": "dkm", "id": 87603, "node_id": "MDQ6VXNlcjg3NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/87603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dkm", "html_url": "https://github.com/dkm", "followers_url": "https://api.github.com/users/dkm/followers", "following_url": "https://api.github.com/users/dkm/following{/other_user}", "gists_url": "https://api.github.com/users/dkm/gists{/gist_id}", "starred_url": "https://api.github.com/users/dkm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dkm/subscriptions", "organizations_url": "https://api.github.com/users/dkm/orgs", "repos_url": "https://api.github.com/users/dkm/repos", "events_url": "https://api.github.com/users/dkm/events{/privacy}", "received_events_url": "https://api.github.com/users/dkm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76aac607c7eb53313cfd907a31cee6c5e4f550ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76aac607c7eb53313cfd907a31cee6c5e4f550ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76aac607c7eb53313cfd907a31cee6c5e4f550ae"}], "stats": {"total": 102, "additions": 49, "deletions": 53}, "files": [{"sha": "7b194bb9816486afa512f9d6d82bc8c81956edf7", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 45, "deletions": 49, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee004a9681049a55269dfae1506f17229be83c9/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee004a9681049a55269dfae1506f17229be83c9/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=dee004a9681049a55269dfae1506f17229be83c9", "patch": "@@ -7758,7 +7758,7 @@ package body Exp_Ch3 is\n             if Validity_Checks_On\n               and then Comes_From_Source (N)\n               and then Validity_Check_Copies\n-              and then not Is_Generic_Type (Etype (Def_Id))\n+              and then not Is_Generic_Type (Typ)\n             then\n                Ensure_Valid (Expr);\n                if Safe_To_Capture_Value (N, Def_Id) then\n@@ -7876,7 +7876,7 @@ package body Exp_Ch3 is\n       end if;\n \n       if Nkind (Obj_Def) = N_Access_Definition\n-        and then not Is_Local_Anonymous_Access (Etype (Def_Id))\n+        and then not Is_Local_Anonymous_Access (Typ)\n       then\n          --  An Ada 2012 stand-alone object of an anonymous access type\n \n@@ -7988,32 +7988,30 @@ package body Exp_Ch3 is\n \n       --    if BIPalloc = 1 then\n       --       Rxx := BIPaccess;\n+      --       Rxx.all := <expression>;\n       --    elsif BIPalloc = 2 then\n-      --       Rxx := new <expression-type>[storage_pool =\n+      --       Rxx := new <expression-type>'(<expression>)[storage_pool =\n       --         system__secondary_stack__ss_pool][procedure_to_call =\n       --         system__secondary_stack__ss_allocate];\n       --    elsif BIPalloc = 3 then\n-      --       Rxx := new <expression-type>\n+      --       Rxx := new <expression-type>'(<expression>)\n       --    elsif BIPalloc = 4 then\n       --       Pxx : system__storage_pools__root_storage_pool renames\n       --         BIPstoragepool.all;\n-      --       Rxx := new <expression-type>[storage_pool =\n+      --       Rxx := new <expression-type>'(<expression>)[storage_pool =\n       --         Pxx][procedure_to_call =\n       --         system__storage_pools__allocate_any];\n       --    else\n       --       [program_error \"build in place mismatch\"]\n       --    end if;\n \n       --    Result : T renames Rxx.all;\n-      --    Result := <expression>;\n \n       --  in the unconstrained case.\n \n       if Is_Build_In_Place_Return_Object (Def_Id) then\n          declare\n-            Func_Id     : constant Entity_Id :=\n-              Return_Applies_To (Scope (Def_Id));\n-            Ret_Obj_Typ : constant Entity_Id := Etype (Def_Id);\n+            Func_Id : constant Entity_Id := Return_Applies_To (Scope (Def_Id));\n \n             Init_Stmt       : Node_Id;\n             Obj_Acc_Formal  : Entity_Id;\n@@ -8043,9 +8041,9 @@ package body Exp_Ch3 is\n             if Present (Expr_Q)\n               and then not Is_Delayed_Aggregate (Expr_Q)\n               and then not No_Initialization (N)\n-              and then not Is_Interface (Etype (Def_Id))\n+              and then not Is_Interface (Typ)\n             then\n-               if Is_Class_Wide_Type (Etype (Def_Id))\n+               if Is_Class_Wide_Type (Typ)\n                  and then not Is_Class_Wide_Type (Etype (Expr_Q))\n                then\n                   Init_Stmt :=\n@@ -8054,7 +8052,7 @@ package body Exp_Ch3 is\n                       Expression =>\n                         Make_Type_Conversion (Loc,\n                           Subtype_Mark =>\n-                            New_Occurrence_Of (Etype (Def_Id), Loc),\n+                            New_Occurrence_Of (Typ, Loc),\n                           Expression   => New_Copy_Tree (Expr_Q)));\n \n                else\n@@ -8087,12 +8085,12 @@ package body Exp_Ch3 is\n             if Needs_BIP_Alloc_Form (Func_Id) then\n                declare\n                   Desig_Typ : constant Entity_Id :=\n-                    (if Ekind (Ret_Obj_Typ) = E_Array_Subtype\n-                     then Etype (Func_Id) else Ret_Obj_Typ);\n+                    (if Ekind (Typ) = E_Array_Subtype\n+                     then Etype (Func_Id) else Typ);\n                   --  Ensure that the we use a fat pointer when allocating\n                   --  an unconstrained array on the heap. In this case the\n-                  --  result object type is a constrained array type even\n-                  --  though the function type is unconstrained.\n+                  --  result object's type is a constrained array type even\n+                  --  though the function's type is unconstrained.\n                   Obj_Alloc_Formal : constant Entity_Id :=\n                     Build_In_Place_Formal (Func_Id, BIP_Alloc_Form);\n                   Pool_Id          : constant Entity_Id :=\n@@ -8135,7 +8133,7 @@ package body Exp_Ch3 is\n                         --  use the type of the expression, which must be an\n                         --  aggregate of a definite type.\n \n-                        if Is_Class_Wide_Type (Ret_Obj_Typ) then\n+                        if Is_Class_Wide_Type (Typ) then\n                            Alloc :=\n                              Make_Allocator (Loc,\n                                Expression =>\n@@ -8145,7 +8143,7 @@ package body Exp_Ch3 is\n                            Alloc :=\n                              Make_Allocator (Loc,\n                                Expression =>\n-                                 New_Occurrence_Of (Ret_Obj_Typ, Loc));\n+                                 New_Occurrence_Of (Typ, Loc));\n                         end if;\n \n                         --  If the object requires default initialization then\n@@ -8165,49 +8163,48 @@ package body Exp_Ch3 is\n                      return Alloc;\n                   end Make_Allocator_For_BIP_Return;\n \n-                  Alloc_Obj_Id   : Entity_Id;\n+                  Acc_Typ        : Entity_Id;\n                   Alloc_Obj_Decl : Node_Id;\n-                  Alloc_Stmt      : Node_Id;\n+                  Alloc_Obj_Id   : Entity_Id;\n+                  Alloc_Stmt     : Node_Id;\n                   Guard_Except   : Node_Id;\n                   Heap_Allocator : Node_Id;\n-                  Pool_Decl      : Node_Id;\n                   Pool_Allocator : Node_Id;\n-                  Ptr_Type_Decl  : Node_Id;\n-                  Ref_Type       : Entity_Id;\n+                  Pool_Decl      : Node_Id;\n+                  Ptr_Typ_Decl   : Node_Id;\n                   SS_Allocator   : Node_Id;\n \n                begin\n                   --  Create an access type designating the function's\n                   --  result subtype.\n \n-                  Ref_Type := Make_Temporary (Loc, 'A');\n+                  Acc_Typ := Make_Temporary (Loc, 'A');\n \n-                  Ptr_Type_Decl :=\n+                  Ptr_Typ_Decl :=\n                     Make_Full_Type_Declaration (Loc,\n-                      Defining_Identifier => Ref_Type,\n+                      Defining_Identifier => Acc_Typ,\n                       Type_Definition     =>\n                         Make_Access_To_Object_Definition (Loc,\n                           All_Present        => True,\n                           Subtype_Indication =>\n                             New_Occurrence_Of (Desig_Typ, Loc)));\n \n-                  Insert_Action (N, Ptr_Type_Decl);\n+                  Insert_Action (N, Ptr_Typ_Decl, Suppress => All_Checks);\n \n                   --  Create an access object that will be initialized to an\n                   --  access value denoting the return object, either coming\n                   --  from an implicit access value passed in by the caller\n                   --  or from the result of an allocator.\n \n                   Alloc_Obj_Id := Make_Temporary (Loc, 'R');\n-                  Set_Etype (Alloc_Obj_Id, Ref_Type);\n \n                   Alloc_Obj_Decl :=\n                     Make_Object_Declaration (Loc,\n                       Defining_Identifier => Alloc_Obj_Id,\n                       Object_Definition   =>\n-                        New_Occurrence_Of (Ref_Type, Loc));\n+                        New_Occurrence_Of (Acc_Typ, Loc));\n \n-                  Insert_Action (N, Alloc_Obj_Decl);\n+                  Insert_Action (N, Alloc_Obj_Decl, Suppress => All_Checks);\n \n                   --  First create the Heap_Allocator\n \n@@ -8320,7 +8317,7 @@ package body Exp_Ch3 is\n                   --  to-unconstrained to access-to-constrained), but the\n                   --  the unchecked conversion will presumably fail to work\n                   --  right in just such cases. It's not clear at all how to\n-                  --  handle this. ???\n+                  --  handle this.\n \n                   Alloc_Stmt :=\n                     Make_If_Statement (Loc,\n@@ -8339,7 +8336,7 @@ package body Exp_Ch3 is\n                             New_Occurrence_Of (Alloc_Obj_Id, Loc),\n                           Expression =>\n                             Unchecked_Convert_To\n-                              (Ref_Type,\n+                              (Acc_Typ,\n                                New_Occurrence_Of (Obj_Acc_Formal, Loc)))),\n \n                       Elsif_Parts => New_List (\n@@ -8372,12 +8369,12 @@ package body Exp_Ch3 is\n                           Then_Statements => New_List (\n                             Build_Heap_Or_Pool_Allocator\n                               (Temp_Id    => Alloc_Obj_Id,\n-                               Temp_Typ   => Ref_Type,\n+                               Temp_Typ   => Acc_Typ,\n                                Func_Id    => Func_Id,\n                                Ret_Typ    => Desig_Typ,\n                                Alloc_Expr => Heap_Allocator))),\n \n-                        --  ???If all is well, we can put the following\n+                        --  ??? If all is well, we can put the following\n                         --  'elsif' in the 'else', but this is a useful\n                         --  self-check in case caller and callee don't agree\n                         --  on whether BIPAlloc and so on should be passed.\n@@ -8396,7 +8393,7 @@ package body Exp_Ch3 is\n                             Pool_Decl,\n                             Build_Heap_Or_Pool_Allocator\n                               (Temp_Id    => Alloc_Obj_Id,\n-                               Temp_Typ   => Ref_Type,\n+                               Temp_Typ   => Acc_Typ,\n                                Func_Id    => Func_Id,\n                                Ret_Typ    => Desig_Typ,\n                                Alloc_Expr => Pool_Allocator)))),\n@@ -8437,33 +8434,33 @@ package body Exp_Ch3 is\n                   Obj_Acc_Formal := Alloc_Obj_Id;\n                end;\n \n-            --  When the function's subtype is unconstrained and a run-time\n-            --  test is not needed, we nevertheless need to build the return\n-            --  using the function's result subtype.\n+            --  When the function's type is unconstrained and a run-time test\n+            --  is not needed, we nevertheless need to build the return using\n+            --  the return object's type.\n \n             elsif not Is_Constrained (Underlying_Type (Etype (Func_Id))) then\n                declare\n-                  Alloc_Obj_Id   : Entity_Id;\n+                  Acc_Typ        : Entity_Id;\n                   Alloc_Obj_Decl : Node_Id;\n-                  Ptr_Type_Decl  : Node_Id;\n-                  Ref_Type       : Entity_Id;\n+                  Alloc_Obj_Id   : Entity_Id;\n+                  Ptr_Typ_Decl   : Node_Id;\n \n                begin\n                   --  Create an access type designating the function's\n                   --  result subtype.\n \n-                  Ref_Type := Make_Temporary (Loc, 'A');\n+                  Acc_Typ := Make_Temporary (Loc, 'A');\n \n-                  Ptr_Type_Decl :=\n+                  Ptr_Typ_Decl :=\n                     Make_Full_Type_Declaration (Loc,\n-                      Defining_Identifier => Ref_Type,\n+                      Defining_Identifier => Acc_Typ,\n                       Type_Definition     =>\n                         Make_Access_To_Object_Definition (Loc,\n                           All_Present        => True,\n                           Subtype_Indication =>\n-                            New_Occurrence_Of (Ret_Obj_Typ, Loc)));\n+                            New_Occurrence_Of (Typ, Loc)));\n \n-                  Insert_Action (N, Ptr_Type_Decl);\n+                  Insert_Action (N, Ptr_Typ_Decl, Suppress => All_Checks);\n \n                   --  Create an access object initialized to the conversion\n                   --  of the implicit access value passed in by the caller.\n@@ -8477,11 +8474,10 @@ package body Exp_Ch3 is\n                     Make_Object_Declaration (Loc,\n                       Defining_Identifier => Alloc_Obj_Id,\n                       Object_Definition   =>\n-                        New_Occurrence_Of (Ref_Type, Loc),\n+                        New_Occurrence_Of (Acc_Typ, Loc),\n                       Expression =>\n                         Unchecked_Convert_To\n-                          (Ref_Type,\n-                           New_Occurrence_Of (Obj_Acc_Formal, Loc)));\n+                          (Acc_Typ, New_Occurrence_Of (Obj_Acc_Formal, Loc)));\n \n                   Insert_Action (N, Alloc_Obj_Decl, Suppress => All_Checks);\n "}, {"sha": "4cdd98649c84c633ba8e3341589e3efe26f551f1", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee004a9681049a55269dfae1506f17229be83c9/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee004a9681049a55269dfae1506f17229be83c9/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=dee004a9681049a55269dfae1506f17229be83c9", "patch": "@@ -6650,8 +6650,8 @@ package body Exp_Ch6 is\n                           and then Needs_Finalization (Exp_Typ))\n          then\n             declare\n-               Loc        : constant Source_Ptr := Sloc (N);\n-               Acc_Typ    : constant Entity_Id := Make_Temporary (Loc, 'A');\n+               Acc_Typ : constant Entity_Id := Make_Temporary (Loc, 'A');\n+\n                Alloc_Node : Node_Id;\n                Temp       : Entity_Id;\n \n@@ -6753,8 +6753,8 @@ package body Exp_Ch6 is\n                           and then Needs_Finalization (Exp_Typ))\n          then\n             declare\n-               Loc        : constant Source_Ptr := Sloc (N);\n-               Acc_Typ    : constant Entity_Id := Make_Temporary (Loc, 'A');\n+               Acc_Typ : constant Entity_Id := Make_Temporary (Loc, 'A');\n+\n                Alloc_Node : Node_Id;\n                Temp       : Entity_Id;\n "}]}