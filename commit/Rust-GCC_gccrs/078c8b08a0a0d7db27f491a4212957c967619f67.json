{"sha": "078c8b08a0a0d7db27f491a4212957c967619f67", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDc4YzhiMDhhMGEwZDdkYjI3ZjQ5MWE0MjEyOTU3Yzk2NzYxOWY2Nw==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "joern.rennecke@superh.com", "date": "2004-06-10T18:14:53Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2004-06-10T18:14:53Z"}, "message": "sh.c (dump_table): New argument start.\n\n\t* sh.c (dump_table): New argument start.  Changed caller.\n\t(fixup_mova): New function.\n\t(find_barrier): Use it.\n\t(sh_reorg): Likewise.  Check for CODE_FOR_casesi_worker_2.\n\tIf the label a mova refers to is above the mova itself, change\n\tthe mova into a load.\n\t* sh.md (*casesi_worker): Rename to:\n\t(casesi_worker_1).\n\t(casesi_worker_2): New insn.\n\nFrom-SVN: r82932", "tree": {"sha": "b4200eb8e0f0246a529accceea034999fc95785c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b4200eb8e0f0246a529accceea034999fc95785c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/078c8b08a0a0d7db27f491a4212957c967619f67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/078c8b08a0a0d7db27f491a4212957c967619f67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/078c8b08a0a0d7db27f491a4212957c967619f67", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/078c8b08a0a0d7db27f491a4212957c967619f67/comments", "author": null, "committer": null, "parents": [{"sha": "9ef313e31caf3e61eb3b1b0483249d1598bd73cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ef313e31caf3e61eb3b1b0483249d1598bd73cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ef313e31caf3e61eb3b1b0483249d1598bd73cf"}], "stats": {"total": 150, "additions": 137, "deletions": 13}, "files": [{"sha": "ef9d7a37620b467f2b2951aed2ede3e7a8dfd8c7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/078c8b08a0a0d7db27f491a4212957c967619f67/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/078c8b08a0a0d7db27f491a4212957c967619f67/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=078c8b08a0a0d7db27f491a4212957c967619f67", "patch": "@@ -1,3 +1,15 @@\n+2004-06-10  J\"orn Rennecke <joern.rennecke@superh.com>\n+\n+\t* sh.c (dump_table): New argument start.  Changed caller.\n+\t(fixup_mova): New function.\n+\t(find_barrier): Use it.\n+\t(sh_reorg): Likewise.  Check for CODE_FOR_casesi_worker_2.\n+\tIf the label a mova refers to is above the mova itself, change\n+\tthe mova into a load.\n+\t* sh.md (*casesi_worker): Rename to:\n+\t(casesi_worker_1).\n+\t(casesi_worker_2): New insn.\n+\n 2004-06-10  Jason Merrill  <jason@redhat.com>\n \n \t* target.h (struct gcc_target): Change gimplify_va_arg_expr "}, {"sha": "d70178bf4958e0493bf44940f0bd4a2bf9332047", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 86, "deletions": 12, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/078c8b08a0a0d7db27f491a4212957c967619f67/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/078c8b08a0a0d7db27f491a4212957c967619f67/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=078c8b08a0a0d7db27f491a4212957c967619f67", "patch": "@@ -200,7 +200,7 @@ static int branch_dest (rtx);\n static void force_into (rtx, rtx);\n static void print_slot (rtx);\n static rtx add_constant (rtx, enum machine_mode, rtx);\n-static void dump_table (rtx);\n+static void dump_table (rtx, rtx);\n static int hi_const (rtx);\n static int broken_move (rtx);\n static int mova_p (rtx);\n@@ -2756,11 +2756,16 @@ add_constant (rtx x, enum machine_mode mode, rtx last_value)\n   return lab;\n }\n \n-/* Output the literal table.  */\n+/* Output the literal table.  START, if nonzero, is the first instruction\n+   this table is needed for, and also indicates that there is at least one\n+   casesi_worker_2 instruction; We have to emit the operand3 labels from\n+   these insns at a 4-byte  aligned position.  BARRIER is the barrier\n+   after which we are to place the table.  */\n \n static void\n-dump_table (rtx scan)\n+dump_table (rtx start, rtx barrier)\n {\n+  rtx scan = barrier;\n   int i;\n   int need_align = 1;\n   rtx lab, ref;\n@@ -2795,6 +2800,20 @@ dump_table (rtx scan)\n \n   need_align = 1;\n \n+  if (start)\n+    {\n+      scan = emit_insn_after (gen_align_4 (), scan);\n+      need_align = 0;\n+      for (; start != barrier; start = NEXT_INSN (start))\n+\tif (GET_CODE (start) == INSN\n+\t    && recog_memoized (start) == CODE_FOR_casesi_worker_2)\n+\t  {\n+\t    rtx src = SET_SRC (XVECEXP (PATTERN (start), 0, 0));\n+\t    rtx lab = XEXP (XVECEXP (src, 0, 3), 0);\n+\n+\t    scan = emit_label_after (lab, scan);\n+\t  }\n+    }\n   if (TARGET_FMOVD && TARGET_ALIGN_DOUBLE && have_df)\n     {\n       rtx align_insn = NULL_RTX;\n@@ -2995,6 +3014,46 @@ mova_p (rtx insn)\n \t  && GET_CODE (XVECEXP (SET_SRC (PATTERN (insn)), 0, 0)) == LABEL_REF);\n }\n \n+/* Fix up a mova from a switch that went out of range.  */\n+static void\n+fixup_mova (rtx mova)\n+{\n+  if (! flag_pic)\n+    {\n+      SET_SRC (PATTERN (mova)) = XVECEXP (SET_SRC (PATTERN (mova)), 0, 0);\n+      INSN_CODE (mova) = -1;\n+    }\n+  else\n+    {\n+      rtx worker = mova;\n+      rtx lab = gen_label_rtx ();\n+      rtx wpat, wpat0, wpat1, wsrc, diff;\n+\n+      do\n+\t{\n+\t  worker = NEXT_INSN (worker);\n+\t  if (! worker\n+\t      || GET_CODE (worker) == CODE_LABEL\n+\t      || GET_CODE (worker) == JUMP_INSN)\n+\t    abort ();\n+\t} while (recog_memoized (worker) != CODE_FOR_casesi_worker_1);\n+      wpat = PATTERN (worker);\n+      wpat0 = XVECEXP (wpat, 0, 0);\n+      wpat1 = XVECEXP (wpat, 0, 1);\n+      wsrc = SET_SRC (wpat0);\n+      PATTERN (worker) = (gen_casesi_worker_2\n+\t\t\t  (SET_DEST (wpat0), XVECEXP (wsrc, 0, 1),\n+\t\t\t   XEXP (XVECEXP (wsrc, 0, 2), 0), lab,\n+\t\t\t   XEXP (wpat1, 0)));\n+      INSN_CODE (worker) = -1;\n+      diff = gen_rtx_MINUS (Pmode, XVECEXP (SET_SRC (PATTERN (mova)), 0, 0),\n+\t\t\t    gen_rtx_LABEL_REF (Pmode, lab));\n+      diff = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, diff), UNSPEC_PIC);\n+      SET_SRC (PATTERN (mova)) = gen_rtx_CONST (Pmode, diff);\n+      INSN_CODE (mova) = -1;\n+    }\n+}\n+\n /* Find the last barrier from insn FROM which is close enough to hold the\n    constant pool.  If we can't find one, then create one near the end of\n    the range.  */\n@@ -3186,8 +3245,7 @@ find_barrier (int num_mova, rtx mova, rtx from)\n \t{\n \t  /* Try as we might, the leading mova is out of range.  Change\n \t     it into a load (which will become a pcload) and retry.  */\n-\t  SET_SRC (PATTERN (mova)) = XVECEXP (SET_SRC (PATTERN (mova)), 0, 0);\n-\t  INSN_CODE (mova) = -1;\n+\t  fixup_mova (mova);\n \t  return find_barrier (0, 0, mova);\n \t}\n       else\n@@ -4099,7 +4157,20 @@ sh_reorg (void)\n     {\n       if (mova_p (insn))\n \t{\n-\t  if (! num_mova++)\n+\t  /* ??? basic block reordering can move a switch table dispatch\n+\t     below the switch table.  Check if that has happened.\n+\t     We only have the addresses available when optimizing; but then,\n+\t     this check shouldn't be needed when not optimizing.  */\n+\t  rtx label_ref = XVECEXP (SET_SRC (PATTERN (insn)), 0, 0);\n+\t  if (optimize\n+\t      && (INSN_ADDRESSES (INSN_UID (insn))\n+\t\t  > INSN_ADDRESSES (INSN_UID (XEXP (label_ref, 0)))))\n+\t    {\n+\t      /* Change the mova into a load.\n+\t\t broken_move will then return true for it.  */\n+\t      fixup_mova (insn);\n+\t    }\n+\t  else if (! num_mova++)\n \t    mova = insn;\n \t}\n       else if (GET_CODE (insn) == JUMP_INSN\n@@ -4124,19 +4195,20 @@ sh_reorg (void)\n \t    {\n \t      /* Change the mova into a load, and restart scanning\n \t\t there.  broken_move will then return true for mova.  */\n-\t      SET_SRC (PATTERN (mova))\n-\t\t= XVECEXP (SET_SRC (PATTERN (mova)), 0, 0);\n-\t      INSN_CODE (mova) = -1;\n+\t      fixup_mova (mova);\n \t      insn = mova;\n \t    }\n \t}\n-      if (broken_move (insn))\n+      if (broken_move (insn)\n+\t  || (GET_CODE (insn) == INSN\n+\t      && recog_memoized (insn) == CODE_FOR_casesi_worker_2))\n \t{\n \t  rtx scan;\n \t  /* Scan ahead looking for a barrier to stick the constant table\n \t     behind.  */\n \t  rtx barrier = find_barrier (num_mova, mova, insn);\n \t  rtx last_float_move = NULL_RTX, last_float = 0, *last_float_addr = NULL;\n+\t  int need_aligned_label = 0;\n \n \t  if (num_mova && ! mova_p (mova))\n \t    {\n@@ -4150,6 +4222,9 @@ sh_reorg (void)\n \t    {\n \t      if (GET_CODE (scan) == CODE_LABEL)\n \t\tlast_float = 0;\n+\t      if (GET_CODE (scan) == INSN\n+\t\t  && recog_memoized (scan) == CODE_FOR_casesi_worker_2)\n+\t\tneed_aligned_label = 1;\n \t      if (broken_move (scan))\n \t\t{\n \t\t  rtx *patp = &PATTERN (scan), pat = *patp;\n@@ -4180,7 +4255,6 @@ sh_reorg (void)\n \t\t\t}\n \t\t      dst = gen_rtx_REG (HImode, REGNO (dst) + offset);\n \t\t    }\n-\n \t\t  if (GET_CODE (dst) == REG && FP_ANY_REGISTER_P (REGNO (dst)))\n \t\t    {\n \t\t      /* This must be an insn that clobbers r0.  */\n@@ -4257,7 +4331,7 @@ sh_reorg (void)\n \t\t  INSN_CODE (scan) = -1;\n \t\t}\n \t    }\n-\t  dump_table (barrier);\n+\t  dump_table (need_aligned_label ? insn : 0, barrier);\n \t  insn = barrier;\n \t}\n     }"}, {"sha": "d8ea00ca77a4c86b24958882a4c6b752b62acacf", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/078c8b08a0a0d7db27f491a4212957c967619f67/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/078c8b08a0a0d7db27f491a4212957c967619f67/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=078c8b08a0a0d7db27f491a4212957c967619f67", "patch": "@@ -7110,7 +7110,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \t      (clobber (match_dup 3))])]\n   \"if (GET_CODE (operands[2]) == CODE_LABEL) LABEL_NUSES (operands[2])++;\")\n \n-(define_insn \"*casesi_worker\"\n+(define_insn \"casesi_worker_1\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(unspec:SI [(reg:SI R0_REG)\n \t\t    (match_operand:SI 1 \"register_operand\" \"0,r\")\n@@ -7140,6 +7140,44 @@ mov.l\\\\t1f,r0\\\\n\\\\\n }\"\n   [(set_attr \"length\" \"4\")])\n \n+(define_insn \"casesi_worker_2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(unspec:SI [(reg:SI R0_REG)\n+\t\t    (match_operand:SI 1 \"register_operand\" \"0,r\")\n+\t\t    (label_ref (match_operand 2 \"\" \"\"))\n+\t\t    (label_ref (match_operand 3 \"\" \"\"))] UNSPEC_CASESI))\n+   (clobber (match_operand:SI 4 \"\" \"=X,1\"))]\n+  \"TARGET_SH2 && reload_completed && flag_pic\"\n+  \"*\n+{\n+  rtx diff_vec = PATTERN (next_real_insn (operands[2]));\n+  char *load;\n+\n+  if (GET_CODE (diff_vec) != ADDR_DIFF_VEC)\n+    abort ();\n+\n+  switch (GET_MODE (diff_vec))\n+    {\n+    case SImode:\n+      output_asm_insn (\\\"shll2    %1\\\", operands);\n+      load = \\\"mov.l\t@(r0,%1),%0\\\"; break;\n+    case HImode:\n+      output_asm_insn (\\\"add\t%1,%1\\\", operands);\n+      load = \\\"mov.w\t@(r0,%1),%0\\\"; break;\n+    case QImode:\n+      if (ADDR_DIFF_VEC_FLAGS (diff_vec).offset_unsigned)\n+\tload = \\\"mov.b\t@(r0,%1),%0\\;extu.b\t%0,%0\\\";\n+      else\n+\tload = \\\"mov.b\t@(r0,%1),%0\\\";\n+      break;\n+    default:\n+      abort ();\n+    }\n+  output_asm_insn (\\\"add\\tr0,%1\\;mova\\t%O3,r0\\\\n\\\", operands);\n+  return load;\n+}\"\n+  [(set_attr \"length\" \"8\")])\n+\n (define_insn \"casesi_shift_media\"\n   [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n \t(ashift:DI (match_operand:DI 1 \"arith_reg_operand\" \"r\")"}]}