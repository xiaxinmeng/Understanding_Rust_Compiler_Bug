{"sha": "cf5124f688366180484680f3b4e82f4bde2b9425", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Y1MTI0ZjY4ODM2NjE4MDQ4NDY4MGYzYjRlODJmNGJkZTJiOTQyNQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2002-05-21T22:38:00Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2002-05-21T22:38:00Z"}, "message": "re PR middle-end/6600 (i960 toolchain hits abort in c_readstr)\n\n\n\tPR middle-end/6600\n\t* expr.c (STORE_MAX_PIECES): New macro to avoid immediate constants\n\tlarger than INTEGER_CST.  (store_by_pieces_1): Use it here...\n\t(can_store_by_pieces): ... and here to limit the largest mode used.\n\tAdd a comment to document this function.\n\nFrom-SVN: r53706", "tree": {"sha": "e6e972a811f5ef5fa3c100a265feb19931714020", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e6e972a811f5ef5fa3c100a265feb19931714020"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf5124f688366180484680f3b4e82f4bde2b9425", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf5124f688366180484680f3b4e82f4bde2b9425", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf5124f688366180484680f3b4e82f4bde2b9425", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf5124f688366180484680f3b4e82f4bde2b9425/comments", "author": null, "committer": null, "parents": [{"sha": "380e6adea2e15fdb2d68305ec3b44c176d27a1d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/380e6adea2e15fdb2d68305ec3b44c176d27a1d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/380e6adea2e15fdb2d68305ec3b44c176d27a1d2"}], "stats": {"total": 25, "additions": 23, "deletions": 2}, "files": [{"sha": "abad0ac46c51fa9f80345ca1e2ed7dc564bd1426", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf5124f688366180484680f3b4e82f4bde2b9425/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf5124f688366180484680f3b4e82f4bde2b9425/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cf5124f688366180484680f3b4e82f4bde2b9425", "patch": "@@ -1,3 +1,11 @@\n+2002-05-21  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR middle-end/6600\n+\t* expr.c (STORE_MAX_PIECES): New macro to avoid immediate constants\n+\tlarger than INTEGER_CST.  (store_by_pieces_1): Use it here...\n+\t(can_store_by_pieces): ... and here to limit the largest mode used.\n+\tAdd a comment to document this function.\n+\n 2002-05-21  Richard Henderson  <rth@redhat.com>\n \n \t* flow.c (life_analysis): Fix test for deleted label."}, {"sha": "1999e162ce9cece051883ce5f4a9e15c8c411d39", "filename": "gcc/expr.c", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf5124f688366180484680f3b4e82f4bde2b9425/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf5124f688366180484680f3b4e82f4bde2b9425/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=cf5124f688366180484680f3b4e82f4bde2b9425", "patch": "@@ -1400,6 +1400,13 @@ convert_modes (mode, oldmode, x, unsignedp)\n #define MOVE_MAX_PIECES   MOVE_MAX\n #endif\n \n+/* STORE_MAX_PIECES is the number of bytes at a time that we can\n+   store efficiently.  Due to internal GCC limitations, this is\n+   MOVE_MAX_PIECES limited by the number of bytes GCC can represent\n+   for an immediate constant.  */\n+\n+#define STORE_MAX_PIECES  MIN (MOVE_MAX_PIECES, 2 * sizeof (HOST_WIDE_INT))\n+\n /* Generate several move instructions to copy LEN bytes from block FROM to\n    block TO.  (These are MEM rtx's with BLKmode).  The caller must pass FROM\n    and TO through protect_from_queue before calling.\n@@ -2331,6 +2338,12 @@ use_group_regs (call_fusage, regs)\n }\n \f\n \n+/* Determine whether the LEN bytes generated by CONSTFUN can be\n+   stored to memory using several move instructions.  CONSTFUNDATA is\n+   a pointer which will be passed as argument in every CONSTFUN call.\n+   ALIGN is maximum alignment we can assume.  Return nonzero if a\n+   call to store_by_pieces should succeed.  */\n+\n int\n can_store_by_pieces (len, constfun, constfundata, align)\n      unsigned HOST_WIDE_INT len;\n@@ -2361,7 +2374,7 @@ can_store_by_pieces (len, constfun, constfundata, align)\n     {\n       l = len;\n       mode = VOIDmode;\n-      max_size = MOVE_MAX_PIECES + 1;\n+      max_size = STORE_MAX_PIECES + 1;\n       while (max_size > 1)\n \t{\n \t  for (tmode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n@@ -2472,7 +2485,7 @@ store_by_pieces_1 (data, align)\n      unsigned int align;\n {\n   rtx to_addr = XEXP (data->to, 0);\n-  unsigned HOST_WIDE_INT max_size = MOVE_MAX_PIECES + 1;\n+  unsigned HOST_WIDE_INT max_size = STORE_MAX_PIECES + 1;\n   enum machine_mode mode = VOIDmode, tmode;\n   enum insn_code icode;\n "}]}