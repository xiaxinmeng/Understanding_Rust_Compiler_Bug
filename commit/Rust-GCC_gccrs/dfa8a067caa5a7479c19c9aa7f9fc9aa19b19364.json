{"sha": "dfa8a067caa5a7479c19c9aa7f9fc9aa19b19364", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGZhOGEwNjdjYWE1YTc0NzljMTljOWFhN2Y5ZmM5YWExOWIxOTM2NA==", "commit": {"author": {"name": "Vincent Celier", "email": "celier@adacore.com", "date": "2010-10-05T09:56:39Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-05T09:56:39Z"}, "message": "make.adb (Scan_Make_Arg): Take into account new switch --source-info=file.\n\n2010-10-05  Vincent Celier  <celier@adacore.com>\n\n\t* make.adb (Scan_Make_Arg): Take into account new switch\n\t--source-info=file.\n\t* makeusg.adb: Add line for new switch --source-info=file.\n\t* makeutl.ads (Source_Info_Option): New constant String for new builder\n\tswitch.\n\t* prj-conf.adb: Put subprograms in alphabetical order\n\t(Process_Project_And_Apply_Config): Read/write an eventual source info\n\tfile, if necessary.\n\t* prj-nmsc.adb (Look_For_Sources.Get_Sources_From_Source_Info): New\n\tprocedure.\n\t(Look_For_Sources): If a source info file was successfully read, get the\n\tsource data from the data read from the source info file.\n\t* prj-util.adb (Source_Info_Table): New table\n\t(Source_Info_Project_HTable): New hash table\n\t(Create): New procedure\n\t(Put (File), Put_Line): New procedures\n\t(Write_Source_Info_File): New procedure\n\t(Read_Source_Info_File): New procedure\n\t(Initialize): New procedure\n\t(Source_Info_Of): New procedure\n\t(Next): New procedure\n\t(Close): When file is an out file, fail if the buffer cannot be written\n\tor if the file cannot be close successfully.\n\t(Get_Line): Fail if file is an out file\n\t* prj-util.ads (Create): New procedure\n\t(Put (File), Put_Line): New procedures\n\t(Write_Source_Info_File): New procedure\n\t(Read_Source_Info_File): New procedure\n\t(Source_Info_Data): New record type\n\t(Source_Info_Iterator): New private type\n\t(Initialize): New procedure\n\t(Source_Info_Of): New procedure\n\t(Next): New procedure\n\t* prj.ads (Project_Tree_Data): New components Source_Info_File_Name and\n\tSource_Info_File_Exists.\n\nFrom-SVN: r164975", "tree": {"sha": "250d36669a9cccada4de830c6bef9b9927ea3d83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/250d36669a9cccada4de830c6bef9b9927ea3d83"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dfa8a067caa5a7479c19c9aa7f9fc9aa19b19364", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfa8a067caa5a7479c19c9aa7f9fc9aa19b19364", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfa8a067caa5a7479c19c9aa7f9fc9aa19b19364", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfa8a067caa5a7479c19c9aa7f9fc9aa19b19364/comments", "author": {"login": "vcelier", "id": 8888056, "node_id": "MDQ6VXNlcjg4ODgwNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/8888056?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vcelier", "html_url": "https://github.com/vcelier", "followers_url": "https://api.github.com/users/vcelier/followers", "following_url": "https://api.github.com/users/vcelier/following{/other_user}", "gists_url": "https://api.github.com/users/vcelier/gists{/gist_id}", "starred_url": "https://api.github.com/users/vcelier/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vcelier/subscriptions", "organizations_url": "https://api.github.com/users/vcelier/orgs", "repos_url": "https://api.github.com/users/vcelier/repos", "events_url": "https://api.github.com/users/vcelier/events{/privacy}", "received_events_url": "https://api.github.com/users/vcelier/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a8ef12e56bd1e729917e63ad98c68072d7605f81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8ef12e56bd1e729917e63ad98c68072d7605f81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8ef12e56bd1e729917e63ad98c68072d7605f81"}], "stats": {"total": 1208, "additions": 905, "deletions": 303}, "files": [{"sha": "da2707b36e219ccda5971f890044b850945fff39", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfa8a067caa5a7479c19c9aa7f9fc9aa19b19364/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfa8a067caa5a7479c19c9aa7f9fc9aa19b19364/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=dfa8a067caa5a7479c19c9aa7f9fc9aa19b19364", "patch": "@@ -7988,6 +7988,12 @@ package body Make is\n                end;\n             end if;\n \n+         elsif Argv'Length > Source_Info_Option'Length and then\n+           Argv (1 .. Source_Info_Option'Length) = Source_Info_Option\n+         then\n+            Project_Tree.Source_Info_File_Name :=\n+              new String'(Argv (Source_Info_Option'Length + 1 .. Argv'Last));\n+\n          elsif Argv'Length >= 8 and then\n            Argv (1 .. 8) = \"--param=\"\n          then"}, {"sha": "123907a887b15406cc02b3006ff125d13511813c", "filename": "gcc/ada/makeusg.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfa8a067caa5a7479c19c9aa7f9fc9aa19b19364/gcc%2Fada%2Fmakeusg.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfa8a067caa5a7479c19c9aa7f9fc9aa19b19364/gcc%2Fada%2Fmakeusg.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeusg.adb?ref=dfa8a067caa5a7479c19c9aa7f9fc9aa19b19364", "patch": "@@ -313,6 +313,13 @@ begin\n    Write_Str (\"  --subdirs=dir real obj/lib/exec dirs are subdirs\");\n    Write_Eol;\n \n+   --  Line for --source-info=\n+\n+   Write_Str (\"  \");\n+   Write_Str (Makeutl.Source_Info_Option);\n+   Write_Str (\"file specify a source info file\");\n+   Write_Eol;\n+\n    --  Line for --unchecked-shared-lib-imports\n \n    Write_Str (\"  \");"}, {"sha": "4bfe6cdd7042fd7ac5d7b231fbf88f6604bcd312", "filename": "gcc/ada/makeutl.ads", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfa8a067caa5a7479c19c9aa7f9fc9aa19b19364/gcc%2Fada%2Fmakeutl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfa8a067caa5a7479c19c9aa7f9fc9aa19b19364/gcc%2Fada%2Fmakeutl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeutl.ads?ref=dfa8a067caa5a7479c19c9aa7f9fc9aa19b19364", "patch": "@@ -43,6 +43,9 @@ package Makeutl is\n    Project_Tree : constant Project_Tree_Ref := new Project_Tree_Data;\n    --  The project tree\n \n+   Source_Info_Option : constant String := \"--source-info=\";\n+   --  Switch to indicate the source info file\n+\n    Subdirs_Option : constant String := \"--subdirs=\";\n    --  Switch used to indicate that the real directories (object, exec,\n    --  library, ...) are subdirectories of those in the project file."}, {"sha": "d30cf5773061c18976f06dac4e1fabc422d1cf2f", "filename": "gcc/ada/prj-conf.adb", "status": "modified", "additions": 325, "deletions": 282, "changes": 607, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfa8a067caa5a7479c19c9aa7f9fc9aa19b19364/gcc%2Fada%2Fprj-conf.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfa8a067caa5a7479c19c9aa7f9fc9aa19b19364/gcc%2Fada%2Fprj-conf.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-conf.adb?ref=dfa8a067caa5a7479c19c9aa7f9fc9aa19b19364", "patch": "@@ -315,22 +315,194 @@ package body Prj.Conf is\n       end loop;\n    end Add_Attributes;\n \n-   ------------------------\n-   -- Locate_Config_File --\n-   ------------------------\n+   ------------------------------------\n+   -- Add_Default_GNAT_Naming_Scheme --\n+   ------------------------------------\n+\n+   procedure Add_Default_GNAT_Naming_Scheme\n+     (Config_File  : in out Project_Node_Id;\n+      Project_Tree : Project_Node_Tree_Ref)\n+   is\n+      procedure Create_Attribute\n+        (Name  : Name_Id;\n+         Value : String;\n+         Index : String := \"\";\n+         Pkg   : Project_Node_Id := Empty_Node);\n+\n+      ----------------------\n+      -- Create_Attribute --\n+      ----------------------\n+\n+      procedure Create_Attribute\n+        (Name  : Name_Id;\n+         Value : String;\n+         Index : String := \"\";\n+         Pkg   : Project_Node_Id := Empty_Node)\n+      is\n+         Attr       : Project_Node_Id;\n+         pragma Unreferenced (Attr);\n+\n+         Expr   : Name_Id         := No_Name;\n+         Val    : Name_Id         := No_Name;\n+         Parent : Project_Node_Id := Config_File;\n+      begin\n+         if Index /= \"\" then\n+            Name_Len := Index'Length;\n+            Name_Buffer (1 .. Name_Len) := Index;\n+            Val := Name_Find;\n+         end if;\n+\n+         if Pkg /= Empty_Node then\n+            Parent := Pkg;\n+         end if;\n+\n+         Name_Len := Value'Length;\n+         Name_Buffer (1 .. Name_Len) := Value;\n+         Expr := Name_Find;\n+\n+         Attr := Create_Attribute\n+           (Tree       => Project_Tree,\n+            Prj_Or_Pkg => Parent,\n+            Name       => Name,\n+            Index_Name => Val,\n+            Kind       => Prj.Single,\n+            Value      => Create_Literal_String (Expr, Project_Tree));\n+      end Create_Attribute;\n+\n+      --  Local variables\n+\n+      Name   : Name_Id;\n+      Naming : Project_Node_Id;\n+\n+   --  Start of processing for Add_Default_GNAT_Naming_Scheme\n \n-   function Locate_Config_File (Name : String) return String_Access is\n-      Prefix_Path : constant String := Executable_Prefix_Path;\n    begin\n-      if Prefix_Path'Length /= 0 then\n-         return Locate_Regular_File\n-           (Name,\n-            \".\" & Path_Separator &\n-            Prefix_Path & \"share\" & Directory_Separator & \"gpr\");\n-      else\n-         return Locate_Regular_File (Name, \".\");\n+      if Config_File = Empty_Node then\n+\n+         --  Create a dummy config file is none was found\n+\n+         Name_Len := Auto_Cgpr'Length;\n+         Name_Buffer (1 .. Name_Len) := Auto_Cgpr;\n+         Name := Name_Find;\n+\n+         --  An invalid project name to avoid conflicts with user-created ones\n+\n+         Name_Len := 5;\n+         Name_Buffer (1 .. Name_Len) := \"_auto\";\n+\n+         Config_File :=\n+           Create_Project\n+             (In_Tree        => Project_Tree,\n+              Name           => Name_Find,\n+              Full_Path      => Path_Name_Type (Name),\n+              Is_Config_File => True);\n+\n+         --  Setup library support\n+\n+         case MLib.Tgt.Support_For_Libraries is\n+            when None =>\n+               null;\n+\n+            when Static_Only =>\n+               Create_Attribute (Name_Library_Support, \"static_only\");\n+\n+            when Full =>\n+               Create_Attribute (Name_Library_Support, \"full\");\n+         end case;\n+\n+         if MLib.Tgt.Standalone_Library_Auto_Init_Is_Supported then\n+            Create_Attribute (Name_Library_Auto_Init_Supported, \"true\");\n+         else\n+            Create_Attribute (Name_Library_Auto_Init_Supported, \"false\");\n+         end if;\n+\n+         --  Setup Ada support (Ada is the default language here, since this\n+         --  is only called when no config file existed initially, ie for\n+         --  gnatmake).\n+\n+         Create_Attribute (Name_Default_Language, \"ada\");\n+\n+         Naming := Create_Package (Project_Tree, Config_File, \"naming\");\n+         Create_Attribute (Name_Spec_Suffix, \".ads\", \"ada\",     Pkg => Naming);\n+         Create_Attribute (Name_Separate_Suffix, \".adb\", \"ada\", Pkg => Naming);\n+         Create_Attribute (Name_Body_Suffix, \".adb\", \"ada\",     Pkg => Naming);\n+         Create_Attribute (Name_Dot_Replacement, \"-\",           Pkg => Naming);\n+         Create_Attribute (Name_Casing,          \"lowercase\",   Pkg => Naming);\n+\n+         if Current_Verbosity = High then\n+            Write_Line (\"Automatically generated (in-memory) config file\");\n+            Prj.PP.Pretty_Print\n+              (Project                => Config_File,\n+               In_Tree                => Project_Tree,\n+               Backward_Compatibility => False);\n+         end if;\n       end if;\n-   end Locate_Config_File;\n+   end Add_Default_GNAT_Naming_Scheme;\n+\n+   -----------------------\n+   -- Apply_Config_File --\n+   -----------------------\n+\n+   procedure Apply_Config_File\n+     (Config_File  : Prj.Project_Id;\n+      Project_Tree : Prj.Project_Tree_Ref)\n+   is\n+      Conf_Decl    : constant Declarations := Config_File.Decl;\n+      Conf_Pack_Id : Package_Id;\n+      Conf_Pack    : Package_Element;\n+\n+      User_Decl    : Declarations;\n+      User_Pack_Id : Package_Id;\n+      User_Pack    : Package_Element;\n+      Proj         : Project_List;\n+\n+   begin\n+      Proj := Project_Tree.Projects;\n+      while Proj /= null loop\n+         if Proj.Project /= Config_File then\n+            User_Decl := Proj.Project.Decl;\n+            Add_Attributes\n+              (Project_Tree => Project_Tree,\n+               Conf_Decl    => Conf_Decl,\n+               User_Decl    => User_Decl);\n+\n+            Conf_Pack_Id := Conf_Decl.Packages;\n+            while Conf_Pack_Id /= No_Package loop\n+               Conf_Pack := Project_Tree.Packages.Table (Conf_Pack_Id);\n+\n+               User_Pack_Id := User_Decl.Packages;\n+               while User_Pack_Id /= No_Package loop\n+                  User_Pack := Project_Tree.Packages.Table (User_Pack_Id);\n+                  exit when User_Pack.Name = Conf_Pack.Name;\n+                  User_Pack_Id := User_Pack.Next;\n+               end loop;\n+\n+               if User_Pack_Id = No_Package then\n+                  Package_Table.Increment_Last (Project_Tree.Packages);\n+                  User_Pack := Conf_Pack;\n+                  User_Pack.Next := User_Decl.Packages;\n+                  User_Decl.Packages :=\n+                    Package_Table.Last (Project_Tree.Packages);\n+                  Project_Tree.Packages.Table (User_Decl.Packages) :=\n+                    User_Pack;\n+\n+               else\n+                  Add_Attributes\n+                    (Project_Tree => Project_Tree,\n+                     Conf_Decl    => Conf_Pack.Decl,\n+                     User_Decl    => Project_Tree.Packages.Table\n+                       (User_Pack_Id).Decl);\n+               end if;\n+\n+               Conf_Pack_Id := Conf_Pack.Next;\n+            end loop;\n+\n+            Proj.Project.Decl := User_Decl;\n+         end if;\n+\n+         Proj := Proj.Next;\n+      end loop;\n+   end Apply_Config_File;\n \n    ------------------\n    -- Check_Target --\n@@ -965,15 +1137,33 @@ package body Prj.Conf is\n       end if;\n    end Get_Or_Create_Configuration_File;\n \n-   --------------------------------------\n-   -- Process_Project_And_Apply_Config --\n-   --------------------------------------\n+   ------------------------\n+   -- Locate_Config_File --\n+   ------------------------\n \n-   procedure Process_Project_And_Apply_Config\n+   function Locate_Config_File (Name : String) return String_Access is\n+      Prefix_Path : constant String := Executable_Prefix_Path;\n+   begin\n+      if Prefix_Path'Length /= 0 then\n+         return Locate_Regular_File\n+           (Name,\n+            \".\" & Path_Separator &\n+            Prefix_Path & \"share\" & Directory_Separator & \"gpr\");\n+      else\n+         return Locate_Regular_File (Name, \".\");\n+      end if;\n+   end Locate_Config_File;\n+\n+   ------------------------------------\n+   -- Parse_Project_And_Apply_Config --\n+   ------------------------------------\n+\n+   procedure Parse_Project_And_Apply_Config\n      (Main_Project               : out Prj.Project_Id;\n-      User_Project_Node          : Prj.Tree.Project_Node_Id;\n+      User_Project_Node          : out Prj.Tree.Project_Node_Id;\n       Config_File_Name           : String := \"\";\n       Autoconf_Specified         : Boolean;\n+      Project_File_Name          : String;\n       Project_Tree               : Prj.Project_Tree_Ref;\n       Project_Node_Tree          : Prj.Tree.Project_Node_Tree_Ref;\n       Packages_To_Check          : String_List_Access;\n@@ -983,93 +1173,15 @@ package body Prj.Conf is\n       Target_Name                : String := \"\";\n       Normalized_Hostname        : String;\n       Flags                      : Processing_Flags;\n-      On_Load_Config             : Config_File_Hook := null;\n-      Reset_Tree                 : Boolean := True)\n+      On_Load_Config             : Config_File_Hook := null)\n    is\n-      Main_Config_Project : Project_Id;\n-      Success : Boolean;\n-\n    begin\n-      Main_Project := No_Project;\n-      Automatically_Generated := False;\n-\n-      Process_Project_Tree_Phase_1\n-        (In_Tree                => Project_Tree,\n-         Project                => Main_Project,\n-         Success                => Success,\n-         From_Project_Node      => User_Project_Node,\n-         From_Project_Node_Tree => Project_Node_Tree,\n-         Flags                  => Flags,\n-         Reset_Tree             => Reset_Tree);\n+      --  Parse the user project tree\n \n-      if not Success then\n-         Main_Project := No_Project;\n-         return;\n-      end if;\n+      Prj.Initialize (Project_Tree);\n \n-      --  Find configuration file\n-\n-      Get_Or_Create_Configuration_File\n-        (Config                     => Main_Config_Project,\n-         Project                    => Main_Project,\n-         Project_Tree               => Project_Tree,\n-         Project_Node_Tree          => Project_Node_Tree,\n-         Allow_Automatic_Generation => Allow_Automatic_Generation,\n-         Config_File_Name           => Config_File_Name,\n-         Autoconf_Specified         => Autoconf_Specified,\n-         Target_Name                => Target_Name,\n-         Normalized_Hostname        => Normalized_Hostname,\n-         Packages_To_Check          => Packages_To_Check,\n-         Config_File_Path           => Config_File_Path,\n-         Automatically_Generated    => Automatically_Generated,\n-         Flags                      => Flags,\n-         On_Load_Config             => On_Load_Config);\n-\n-      Apply_Config_File (Main_Config_Project, Project_Tree);\n-\n-      --  Finish processing the user's project\n-\n-      Prj.Proc.Process_Project_Tree_Phase_2\n-        (In_Tree                    => Project_Tree,\n-         Project                    => Main_Project,\n-         Success                    => Success,\n-         From_Project_Node          => User_Project_Node,\n-         From_Project_Node_Tree     => Project_Node_Tree,\n-         Flags                      => Flags);\n-\n-      if not Success then\n-         Main_Project := No_Project;\n-      end if;\n-   end Process_Project_And_Apply_Config;\n-\n-   ------------------------------------\n-   -- Parse_Project_And_Apply_Config --\n-   ------------------------------------\n-\n-   procedure Parse_Project_And_Apply_Config\n-     (Main_Project               : out Prj.Project_Id;\n-      User_Project_Node          : out Prj.Tree.Project_Node_Id;\n-      Config_File_Name           : String := \"\";\n-      Autoconf_Specified         : Boolean;\n-      Project_File_Name          : String;\n-      Project_Tree               : Prj.Project_Tree_Ref;\n-      Project_Node_Tree          : Prj.Tree.Project_Node_Tree_Ref;\n-      Packages_To_Check          : String_List_Access;\n-      Allow_Automatic_Generation : Boolean := True;\n-      Automatically_Generated    : out Boolean;\n-      Config_File_Path           : out String_Access;\n-      Target_Name                : String := \"\";\n-      Normalized_Hostname        : String;\n-      Flags                      : Processing_Flags;\n-      On_Load_Config             : Config_File_Hook := null)\n-   is\n-   begin\n-      --  Parse the user project tree\n-\n-      Prj.Initialize (Project_Tree);\n-\n-      Main_Project      := No_Project;\n-      Automatically_Generated := False;\n+      Main_Project      := No_Project;\n+      Automatically_Generated := False;\n \n       Prj.Part.Parse\n         (In_Tree                => Project_Node_Tree,\n@@ -1103,81 +1215,125 @@ package body Prj.Conf is\n          On_Load_Config             => On_Load_Config);\n    end Parse_Project_And_Apply_Config;\n \n-   -----------------------\n-   -- Apply_Config_File --\n-   -----------------------\n+   --------------------------------------\n+   -- Process_Project_And_Apply_Config --\n+   --------------------------------------\n \n-   procedure Apply_Config_File\n-     (Config_File  : Prj.Project_Id;\n-      Project_Tree : Prj.Project_Tree_Ref)\n+   procedure Process_Project_And_Apply_Config\n+     (Main_Project               : out Prj.Project_Id;\n+      User_Project_Node          : Prj.Tree.Project_Node_Id;\n+      Config_File_Name           : String := \"\";\n+      Autoconf_Specified         : Boolean;\n+      Project_Tree               : Prj.Project_Tree_Ref;\n+      Project_Node_Tree          : Prj.Tree.Project_Node_Tree_Ref;\n+      Packages_To_Check          : String_List_Access;\n+      Allow_Automatic_Generation : Boolean := True;\n+      Automatically_Generated    : out Boolean;\n+      Config_File_Path           : out String_Access;\n+      Target_Name                : String := \"\";\n+      Normalized_Hostname        : String;\n+      Flags                      : Processing_Flags;\n+      On_Load_Config             : Config_File_Hook := null;\n+      Reset_Tree                 : Boolean := True)\n    is\n-      Conf_Decl    : constant Declarations := Config_File.Decl;\n-      Conf_Pack_Id : Package_Id;\n-      Conf_Pack    : Package_Element;\n-\n-      User_Decl    : Declarations;\n-      User_Pack_Id : Package_Id;\n-      User_Pack    : Package_Element;\n-      Proj         : Project_List;\n+      Main_Config_Project : Project_Id;\n+      Success : Boolean;\n \n    begin\n-      Proj := Project_Tree.Projects;\n-      while Proj /= null loop\n-         if Proj.Project /= Config_File then\n-            User_Decl := Proj.Project.Decl;\n-            Add_Attributes\n-              (Project_Tree => Project_Tree,\n-               Conf_Decl    => Conf_Decl,\n-               User_Decl    => User_Decl);\n+      Main_Project := No_Project;\n+      Automatically_Generated := False;\n \n-            Conf_Pack_Id := Conf_Decl.Packages;\n-            while Conf_Pack_Id /= No_Package loop\n-               Conf_Pack := Project_Tree.Packages.Table (Conf_Pack_Id);\n+      Process_Project_Tree_Phase_1\n+        (In_Tree                => Project_Tree,\n+         Project                => Main_Project,\n+         Success                => Success,\n+         From_Project_Node      => User_Project_Node,\n+         From_Project_Node_Tree => Project_Node_Tree,\n+         Flags                  => Flags,\n+         Reset_Tree             => Reset_Tree);\n \n-               User_Pack_Id := User_Decl.Packages;\n-               while User_Pack_Id /= No_Package loop\n-                  User_Pack := Project_Tree.Packages.Table (User_Pack_Id);\n-                  exit when User_Pack.Name = Conf_Pack.Name;\n-                  User_Pack_Id := User_Pack.Next;\n-               end loop;\n+      if not Success then\n+         Main_Project := No_Project;\n+         return;\n+      end if;\n \n-               if User_Pack_Id = No_Package then\n-                  Package_Table.Increment_Last (Project_Tree.Packages);\n-                  User_Pack := Conf_Pack;\n-                  User_Pack.Next := User_Decl.Packages;\n-                  User_Decl.Packages :=\n-                    Package_Table.Last (Project_Tree.Packages);\n-                  Project_Tree.Packages.Table (User_Decl.Packages) :=\n-                    User_Pack;\n+      if Project_Tree.Source_Info_File_Name /= null then\n+         if not Is_Absolute_Path (Project_Tree.Source_Info_File_Name.all) then\n+            declare\n+               Obj_Dir : constant Variable_Value :=\n+                 Value_Of\n+                   (Name_Object_Dir,\n+                    Main_Project.Decl.Attributes,\n+                    Project_Tree);\n+\n+            begin\n+               if Obj_Dir = Nil_Variable_Value or else Obj_Dir.Default then\n+                  Get_Name_String (Main_Project.Directory.Display_Name);\n \n                else\n-                  Add_Attributes\n-                    (Project_Tree => Project_Tree,\n-                     Conf_Decl    => Conf_Pack.Decl,\n-                     User_Decl    => Project_Tree.Packages.Table\n-                       (User_Pack_Id).Decl);\n+                  if Is_Absolute_Path (Get_Name_String (Obj_Dir.Value)) then\n+                     Get_Name_String (Obj_Dir.Value);\n+\n+                  else\n+                     Name_Len := 0;\n+                     Add_Str_To_Name_Buffer\n+                       (Get_Name_String (Main_Project.Directory.Display_Name));\n+                     Add_Str_To_Name_Buffer (Get_Name_String (Obj_Dir.Value));\n+                  end if;\n                end if;\n \n-               Conf_Pack_Id := Conf_Pack.Next;\n-            end loop;\n-\n-            Proj.Project.Decl := User_Decl;\n+               Add_Char_To_Name_Buffer (Directory_Separator);\n+               Add_Str_To_Name_Buffer (Project_Tree.Source_Info_File_Name.all);\n+               Free (Project_Tree.Source_Info_File_Name);\n+               Project_Tree.Source_Info_File_Name :=\n+                 new String'(Name_Buffer (1 .. Name_Len));\n+            end;\n          end if;\n \n-         Proj := Proj.Next;\n-      end loop;\n-   end Apply_Config_File;\n+         Read_Source_Info_File (Project_Tree);\n+      end if;\n \n-   ---------------------\n-   -- Set_Runtime_For --\n-   ---------------------\n+      --  Find configuration file\n \n-   procedure Set_Runtime_For (Language : Name_Id; RTS_Name : String) is\n-   begin\n-      Name_Len := RTS_Name'Length;\n-      Name_Buffer (1 .. Name_Len) := RTS_Name;\n-      RTS_Languages.Set (Language, Name_Find);\n-   end Set_Runtime_For;\n+      Get_Or_Create_Configuration_File\n+        (Config                     => Main_Config_Project,\n+         Project                    => Main_Project,\n+         Project_Tree               => Project_Tree,\n+         Project_Node_Tree          => Project_Node_Tree,\n+         Allow_Automatic_Generation => Allow_Automatic_Generation,\n+         Config_File_Name           => Config_File_Name,\n+         Autoconf_Specified         => Autoconf_Specified,\n+         Target_Name                => Target_Name,\n+         Normalized_Hostname        => Normalized_Hostname,\n+         Packages_To_Check          => Packages_To_Check,\n+         Config_File_Path           => Config_File_Path,\n+         Automatically_Generated    => Automatically_Generated,\n+         Flags                      => Flags,\n+         On_Load_Config             => On_Load_Config);\n+\n+      Apply_Config_File (Main_Config_Project, Project_Tree);\n+\n+      --  Finish processing the user's project\n+\n+      Prj.Proc.Process_Project_Tree_Phase_2\n+        (In_Tree                    => Project_Tree,\n+         Project                    => Main_Project,\n+         Success                    => Success,\n+         From_Project_Node          => User_Project_Node,\n+         From_Project_Node_Tree     => Project_Node_Tree,\n+         Flags                      => Flags);\n+\n+      if Success then\n+         if Project_Tree.Source_Info_File_Name /= null and then\n+            not Project_Tree.Source_Info_File_Exists\n+         then\n+            Write_Source_Info_File (Project_Tree);\n+         end if;\n+\n+      else\n+         Main_Project := No_Project;\n+      end if;\n+   end Process_Project_And_Apply_Config;\n \n    ----------------------\n    -- Runtime_Name_For --\n@@ -1192,128 +1348,15 @@ package body Prj.Conf is\n       end if;\n    end Runtime_Name_For;\n \n-   ------------------------------------\n-   -- Add_Default_GNAT_Naming_Scheme --\n-   ------------------------------------\n-\n-   procedure Add_Default_GNAT_Naming_Scheme\n-     (Config_File  : in out Project_Node_Id;\n-      Project_Tree : Project_Node_Tree_Ref)\n-   is\n-      procedure Create_Attribute\n-        (Name  : Name_Id;\n-         Value : String;\n-         Index : String := \"\";\n-         Pkg   : Project_Node_Id := Empty_Node);\n-\n-      ----------------------\n-      -- Create_Attribute --\n-      ----------------------\n-\n-      procedure Create_Attribute\n-        (Name  : Name_Id;\n-         Value : String;\n-         Index : String := \"\";\n-         Pkg   : Project_Node_Id := Empty_Node)\n-      is\n-         Attr       : Project_Node_Id;\n-         pragma Unreferenced (Attr);\n-\n-         Expr   : Name_Id         := No_Name;\n-         Val    : Name_Id         := No_Name;\n-         Parent : Project_Node_Id := Config_File;\n-      begin\n-         if Index /= \"\" then\n-            Name_Len := Index'Length;\n-            Name_Buffer (1 .. Name_Len) := Index;\n-            Val := Name_Find;\n-         end if;\n-\n-         if Pkg /= Empty_Node then\n-            Parent := Pkg;\n-         end if;\n-\n-         Name_Len := Value'Length;\n-         Name_Buffer (1 .. Name_Len) := Value;\n-         Expr := Name_Find;\n-\n-         Attr := Create_Attribute\n-           (Tree       => Project_Tree,\n-            Prj_Or_Pkg => Parent,\n-            Name       => Name,\n-            Index_Name => Val,\n-            Kind       => Prj.Single,\n-            Value      => Create_Literal_String (Expr, Project_Tree));\n-      end Create_Attribute;\n-\n-      --  Local variables\n-\n-      Name   : Name_Id;\n-      Naming : Project_Node_Id;\n-\n-   --  Start of processing for Add_Default_GNAT_Naming_Scheme\n+   ---------------------\n+   -- Set_Runtime_For --\n+   ---------------------\n \n+   procedure Set_Runtime_For (Language : Name_Id; RTS_Name : String) is\n    begin\n-      if Config_File = Empty_Node then\n-\n-         --  Create a dummy config file is none was found\n-\n-         Name_Len := Auto_Cgpr'Length;\n-         Name_Buffer (1 .. Name_Len) := Auto_Cgpr;\n-         Name := Name_Find;\n-\n-         --  An invalid project name to avoid conflicts with user-created ones\n-\n-         Name_Len := 5;\n-         Name_Buffer (1 .. Name_Len) := \"_auto\";\n-\n-         Config_File :=\n-           Create_Project\n-             (In_Tree        => Project_Tree,\n-              Name           => Name_Find,\n-              Full_Path      => Path_Name_Type (Name),\n-              Is_Config_File => True);\n-\n-         --  Setup library support\n-\n-         case MLib.Tgt.Support_For_Libraries is\n-            when None =>\n-               null;\n-\n-            when Static_Only =>\n-               Create_Attribute (Name_Library_Support, \"static_only\");\n-\n-            when Full =>\n-               Create_Attribute (Name_Library_Support, \"full\");\n-         end case;\n-\n-         if MLib.Tgt.Standalone_Library_Auto_Init_Is_Supported then\n-            Create_Attribute (Name_Library_Auto_Init_Supported, \"true\");\n-         else\n-            Create_Attribute (Name_Library_Auto_Init_Supported, \"false\");\n-         end if;\n-\n-         --  Setup Ada support (Ada is the default language here, since this\n-         --  is only called when no config file existed initially, ie for\n-         --  gnatmake).\n-\n-         Create_Attribute (Name_Default_Language, \"ada\");\n-\n-         Naming := Create_Package (Project_Tree, Config_File, \"naming\");\n-         Create_Attribute (Name_Spec_Suffix, \".ads\", \"ada\",     Pkg => Naming);\n-         Create_Attribute (Name_Separate_Suffix, \".adb\", \"ada\", Pkg => Naming);\n-         Create_Attribute (Name_Body_Suffix, \".adb\", \"ada\",     Pkg => Naming);\n-         Create_Attribute (Name_Dot_Replacement, \"-\",           Pkg => Naming);\n-         Create_Attribute (Name_Casing,          \"lowercase\",   Pkg => Naming);\n-\n-         if Current_Verbosity = High then\n-            Write_Line (\"Automatically generated (in-memory) config file\");\n-            Prj.PP.Pretty_Print\n-              (Project                => Config_File,\n-               In_Tree                => Project_Tree,\n-               Backward_Compatibility => False);\n-         end if;\n-      end if;\n-   end Add_Default_GNAT_Naming_Scheme;\n+      Name_Len := RTS_Name'Length;\n+      Name_Buffer (1 .. Name_Len) := RTS_Name;\n+      RTS_Languages.Set (Language, Name_Find);\n+   end Set_Runtime_For;\n \n end Prj.Conf;"}, {"sha": "2a1d90b7e357863cdee3a0705730c79e97a94893", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 127, "deletions": 13, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfa8a067caa5a7479c19c9aa7f9fc9aa19b19364/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfa8a067caa5a7479c19c9aa7f9fc9aa19b19364/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=dfa8a067caa5a7479c19c9aa7f9fc9aa19b19364", "patch": "@@ -32,6 +32,7 @@ with Err_Vars; use Err_Vars;\n with Opt;      use Opt;\n with Osint;    use Osint;\n with Output;   use Output;\n+with Prj.Com;\n with Prj.Err;  use Prj.Err;\n with Prj.Util; use Prj.Util;\n with Sinput.P;\n@@ -7175,8 +7176,8 @@ package body Prj.Nmsc is\n       Data    : in out Tree_Processing_Data)\n    is\n       Object_Files : Object_File_Names_Htable.Instance;\n-      Iter : Source_Iterator;\n-      Src  : Source_Id;\n+      Iter         : Source_Iterator;\n+      Src          : Source_Id;\n \n       procedure Check_Object (Src : Source_Id);\n       --  Check if object file name of Src is already used in the project tree,\n@@ -7192,6 +7193,10 @@ package body Prj.Nmsc is\n       --  Check whether one of the languages has no sources, and report an\n       --  error when appropriate\n \n+      procedure Get_Sources_From_Source_Info;\n+      --  Get the source information from the tabes that were created when a\n+      --  source info fie was read.\n+\n       ---------------------------\n       -- Check_Missing_Sources --\n       ---------------------------\n@@ -7421,22 +7426,131 @@ package body Prj.Nmsc is\n          end loop;\n       end Check_Object_Files;\n \n+      ----------------------------------\n+      -- Get_Sources_From_Source_Info --\n+      ----------------------------------\n+\n+      procedure Get_Sources_From_Source_Info is\n+         Iter    : Source_Info_Iterator;\n+         Src     : Source_Info;\n+         Id      : Source_Id;\n+         Lang_Id : Language_Ptr;\n+      begin\n+         Initialize (Iter, Project.Project.Name);\n+\n+         loop\n+            Src := Source_Info_Of (Iter);\n+\n+            exit when Src = No_Source_Info;\n+\n+            Id := new Source_Data;\n+\n+            Id.Project := Project.Project;\n+\n+            Lang_Id := Project.Project.Languages;\n+            while Lang_Id /= No_Language_Index and then\n+            Lang_Id.Name /= Src.Language\n+            loop\n+               Lang_Id := Lang_Id.Next;\n+            end loop;\n+\n+            if Lang_Id = No_Language_Index then\n+               Prj.Com.Fail\n+                 (\"unknown language \" &\n+                  Get_Name_String (Src.Language) &\n+                  \" for project \" &\n+                  Get_Name_String (Src.Project) &\n+                  \" in source info file\");\n+            end if;\n+\n+            Id.Language            := Lang_Id;\n+            Id.Kind                := Src.Kind;\n+\n+            Id.Index               := Src.Index;\n+\n+            Id.Path :=\n+              (Path_Name_Type (Src.Display_Path_Name),\n+               Path_Name_Type (Src.Path_Name));\n+\n+            Name_Len := 0;\n+            Add_Str_To_Name_Buffer\n+              (Ada.Directories.Simple_Name\n+                 (Get_Name_String (Src.Path_Name)));\n+            Id.File := Name_Find;\n+\n+            Name_Len := 0;\n+            Add_Str_To_Name_Buffer\n+              (Ada.Directories.Simple_Name\n+                 (Get_Name_String (Src.Display_Path_Name)));\n+            Id.Display_File := Name_Find;\n+\n+            Id.Dep_Name            := Dependency_Name\n+              (Id.File, Id.Language.Config.Dependency_Kind);\n+            Id.Naming_Exception    := Src.Naming_Exception;\n+            Id.Object              := Object_Name\n+              (Id.File, Id.Language.Config.Object_File_Suffix);\n+            Id.Switches            := Switches_Name (Id.File);\n+\n+            --  Add the source id to the Unit_Sources_HT hash table, if the\n+            --  unit name is not null.\n+\n+            if Src.Kind /= Sep and then Src.Unit_Name /= No_Name then\n+\n+               declare\n+                  UData : Unit_Index :=\n+                    Units_Htable.Get (Data.Tree.Units_HT, Src.Unit_Name);\n+               begin\n+                  if UData = No_Unit_Index then\n+                     UData := new Unit_Data;\n+                     UData.Name := Src.Unit_Name;\n+                     Units_Htable.Set\n+                       (Data.Tree.Units_HT, Src.Unit_Name, UData);\n+                  end if;\n+\n+                  Id.Unit := UData;\n+               end;\n+\n+               --  Note that this updates Unit information as well\n+\n+               Override_Kind (Id, Id.Kind);\n+            end if;\n+\n+            if Src.Index /= 0 then\n+               Project.Project.Has_Multi_Unit_Sources := True;\n+            end if;\n+\n+            --  Add the source to the language list\n+\n+            Id.Next_In_Lang := Id.Language.First_Source;\n+            Id.Language.First_Source := Id;\n+\n+            Files_Htable.Set (Data.File_To_Source, Id.File, Id);\n+\n+            Next (Iter);\n+         end loop;\n+      end Get_Sources_From_Source_Info;\n+\n    --  Start of processing for Look_For_Sources\n \n    begin\n-      if Project.Project.Source_Dirs /= Nil_String then\n-         Find_Excluded_Sources (Project, Data);\n-\n-         if Project.Project.Languages /= No_Language_Index then\n-            Load_Naming_Exceptions (Project, Data);\n-            Find_Sources (Project, Data);\n-            Mark_Excluded_Sources;\n-            Check_Object_Files;\n-            Check_Missing_Sources;\n+      if Data.Tree.Source_Info_File_Exists then\n+         Get_Sources_From_Source_Info;\n+\n+      else\n+         if Project.Project.Source_Dirs /= Nil_String then\n+            Find_Excluded_Sources (Project, Data);\n+\n+            if Project.Project.Languages /= No_Language_Index then\n+               Load_Naming_Exceptions (Project, Data);\n+               Find_Sources (Project, Data);\n+               Mark_Excluded_Sources;\n+               Check_Object_Files;\n+               Check_Missing_Sources;\n+            end if;\n          end if;\n-      end if;\n \n-      Object_File_Names_Htable.Reset (Object_Files);\n+         Object_File_Names_Htable.Reset (Object_Files);\n+      end if;\n    end Look_For_Sources;\n \n    ------------------"}, {"sha": "ce5c38fefa2bc7e4aaf92c31e415f7b165df43d9", "filename": "gcc/ada/prj-util.adb", "status": "modified", "additions": 365, "deletions": 3, "changes": 368, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfa8a067caa5a7479c19c9aa7f9fc9aa19b19364/gcc%2Fada%2Fprj-util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfa8a067caa5a7479c19c9aa7f9fc9aa19b19364/gcc%2Fada%2Fprj-util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-util.adb?ref=dfa8a067caa5a7479c19c9aa7f9fc9aa19b19364", "patch": "@@ -29,12 +29,32 @@ with GNAT.Case_Util; use GNAT.Case_Util;\n \n with Osint;    use Osint;\n with Output;   use Output;\n+with Opt;\n with Prj.Com;\n with Snames;   use Snames;\n+with Table;\n with Targparm; use Targparm;\n \n+with GNAT.HTable;\n+\n package body Prj.Util is\n \n+   package Source_Info_Table is new Table.Table\n+     (Table_Component_Type => Source_Info_Iterator,\n+      Table_Index_Type     => Natural,\n+      Table_Low_Bound      => 1,\n+      Table_Initial        => 10,\n+      Table_Increment      => 100,\n+      Table_Name           => \"Makeutl.Source_Info_Table\");\n+\n+   package Source_Info_Project_HTable is new GNAT.HTable.Simple_HTable\n+     (Header_Num => Prj.Header_Num,\n+      Element    => Natural,\n+      No_Element => 0,\n+      Key        => Name_Id,\n+      Hash       => Prj.Hash,\n+      Equal      => \"=\");\n+\n    procedure Free is new Ada.Unchecked_Deallocation\n      (Text_File_Data, Text_File);\n \n@@ -43,18 +63,65 @@ package body Prj.Util is\n    -----------\n \n    procedure Close (File : in out Text_File) is\n+      Len : Integer;\n+      Status : Boolean;\n+\n    begin\n       if File = null then\n          Prj.Com.Fail (\"Close attempted on an invalid Text_File\");\n       end if;\n \n-      --  Close file, no need to test status, since this is a file that we\n-      --  read, and the file was read successfully before we closed it.\n+      if File.Out_File then\n+         if File.Buffer_Len > 0 then\n+            Len := Write (File.FD, File.Buffer'Address, File.Buffer_Len);\n+\n+            if Len /= File.Buffer_Len then\n+               Prj.Com.Fail (\"Unable to write to an out Text_File\");\n+            end if;\n+         end if;\n+\n+         Close (File.FD, Status);\n+\n+         if not Status then\n+            Prj.Com.Fail (\"Unable to close an out Text_File\");\n+         end if;\n+\n+      else\n+\n+         --  Close in file, no need to test status, since this is a file that\n+         --  we read, and the file was read successfully before we closed it.\n+\n+         Close (File.FD);\n+      end if;\n \n-      Close (File.FD);\n       Free (File);\n    end Close;\n \n+   ------------\n+   -- Create --\n+   ------------\n+\n+   procedure Create (File : out Text_File; Name : String) is\n+      FD        : File_Descriptor;\n+      File_Name : String (1 .. Name'Length + 1);\n+\n+   begin\n+      File_Name (1 .. Name'Length) := Name;\n+      File_Name (File_Name'Last) := ASCII.NUL;\n+      FD := Create_File (Name => File_Name'Address,\n+                         Fmode => GNAT.OS_Lib.Text);\n+\n+      if FD = Invalid_FD then\n+         File := null;\n+\n+      else\n+         File := new Text_File_Data;\n+         File.FD := FD;\n+         File.Out_File := True;\n+         File.End_Of_File_Reached := True;\n+      end if;\n+   end Create;\n+\n    ---------------\n    -- Duplicate --\n    ---------------\n@@ -365,6 +432,9 @@ package body Prj.Util is\n    begin\n       if File = null then\n          Prj.Com.Fail (\"Get_Line attempted on an invalid Text_File\");\n+\n+      elsif File.Out_File then\n+         Prj.Com.Fail (\"Get_Line attempted on an out file\");\n       end if;\n \n       Last := Line'First - 1;\n@@ -400,6 +470,23 @@ package body Prj.Util is\n       end if;\n    end Get_Line;\n \n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize\n+     (Iter : out Source_Info_Iterator; For_Project : Name_Id)\n+   is\n+      Ind : constant Natural := Source_Info_Project_HTable.Get (For_Project);\n+   begin\n+      if Ind = 0 then\n+         Iter := (No_Source_Info, 0);\n+\n+      else\n+         Iter := Source_Info_Table.Table (Ind);\n+      end if;\n+   end Initialize;\n+\n    --------------\n    -- Is_Valid --\n    --------------\n@@ -409,6 +496,20 @@ package body Prj.Util is\n       return File /= null;\n    end Is_Valid;\n \n+   ----------\n+   -- Next --\n+   ----------\n+\n+   procedure Next (Iter : in out Source_Info_Iterator) is\n+   begin\n+      if Iter.Next = 0 then\n+         Iter.Info := No_Source_Info;\n+\n+      else\n+         Iter := Source_Info_Table.Table (Iter.Next);\n+      end if;\n+   end Next;\n+\n    ----------\n    -- Open --\n    ----------\n@@ -496,6 +597,194 @@ package body Prj.Util is\n       end loop;\n    end Put;\n \n+   procedure Put (File : Text_File; S : String) is\n+      Len : Integer;\n+   begin\n+      if File = null then\n+         Prj.Com.Fail (\"Attempted to write on an invalid Text_File\");\n+\n+      elsif not File.Out_File then\n+         Prj.Com.Fail (\"Attempted to write an in Text_File\");\n+      end if;\n+\n+      if File.Buffer_Len + S'Length > File.Buffer'Last then\n+         --  Write buffer\n+         Len := Write (File.FD, File.Buffer'Address, File.Buffer_Len);\n+\n+         if Len /= File.Buffer_Len then\n+            Prj.Com.Fail (\"Failed to write to an out Text_File\");\n+         end if;\n+\n+         File.Buffer_Len := 0;\n+      end if;\n+\n+      File.Buffer (File.Buffer_Len + 1 .. File.Buffer_Len + S'Length) := S;\n+      File.Buffer_Len := File.Buffer_Len + S'Length;\n+   end Put;\n+\n+   --------------\n+   -- Put_Line --\n+   --------------\n+\n+   procedure Put_Line (File : Text_File; Line : String) is\n+      L : String (1 .. Line'Length + 1);\n+   begin\n+      L (1 .. Line'Length) := Line;\n+      L (L'Last) := ASCII.LF;\n+      Put (File, L);\n+   end Put_Line;\n+\n+   ---------------------------\n+   -- Read_Source_Info_File --\n+   ---------------------------\n+\n+   procedure Read_Source_Info_File (Tree : Project_Tree_Ref) is\n+      File : Text_File;\n+      Info : Source_Info_Iterator;\n+      Proj : Name_Id;\n+\n+      procedure Report_Error;\n+\n+      ------------------\n+      -- Report_Error --\n+      ------------------\n+\n+      procedure Report_Error is\n+      begin\n+         Write_Line (\"errors in source info file \"\"\" &\n+                     Tree.Source_Info_File_Name.all & '\"');\n+         Tree.Source_Info_File_Exists := False;\n+      end Report_Error;\n+\n+   begin\n+      Source_Info_Project_HTable.Reset;\n+      Source_Info_Table.Init;\n+\n+      if Tree.Source_Info_File_Name = null then\n+         Tree.Source_Info_File_Exists := False;\n+         return;\n+      end if;\n+\n+      Open (File, Tree.Source_Info_File_Name.all);\n+\n+      if not Is_Valid (File) then\n+         if Opt.Verbose_Mode then\n+            Write_Line (\"source info file \" & Tree.Source_Info_File_Name.all &\n+                        \" does not exist\");\n+         end if;\n+\n+         Tree.Source_Info_File_Exists := False;\n+         return;\n+      end if;\n+\n+      Tree.Source_Info_File_Exists := True;\n+\n+      if Opt.Verbose_Mode then\n+         Write_Line (\"Reading source info file \" &\n+                     Tree.Source_Info_File_Name.all);\n+      end if;\n+\n+      Source_Loop :\n+      while not End_Of_File (File) loop\n+         Info := (new Source_Info_Data, 0);\n+         Source_Info_Table.Increment_Last;\n+\n+         --  project name\n+         Get_Line (File, Name_Buffer, Name_Len);\n+         Proj := Name_Find;\n+         Info.Info.Project := Proj;\n+         Info.Next := Source_Info_Project_HTable.Get (Proj);\n+         Source_Info_Project_HTable.Set (Proj, Source_Info_Table.Last);\n+\n+         if End_Of_File (File) then\n+            Report_Error;\n+            exit Source_Loop;\n+         end if;\n+\n+         --  language name\n+         Get_Line (File, Name_Buffer, Name_Len);\n+         Info.Info.Language := Name_Find;\n+\n+         if End_Of_File (File) then\n+            Report_Error;\n+            exit Source_Loop;\n+         end if;\n+\n+         --  kind\n+         Get_Line (File, Name_Buffer, Name_Len);\n+         Info.Info.Kind := Source_Kind'Value (Name_Buffer (1 .. Name_Len));\n+\n+         if End_Of_File (File) then\n+            Report_Error;\n+            exit Source_Loop;\n+         end if;\n+\n+         --  display path name\n+         Get_Line (File, Name_Buffer, Name_Len);\n+         Info.Info.Display_Path_Name := Name_Find;\n+         Info.Info.Path_Name := Info.Info.Display_Path_Name;\n+\n+         if End_Of_File (File) then\n+            Report_Error;\n+            exit Source_Loop;\n+         end if;\n+\n+         --  optional fields\n+         Option_Loop :\n+         loop\n+            Get_Line (File, Name_Buffer, Name_Len);\n+            exit Option_Loop when Name_Len = 0;\n+\n+            if Name_Len <= 2 then\n+               Report_Error;\n+               exit Source_Loop;\n+\n+            else\n+               if Name_Buffer (1 .. 2) = \"P=\" then\n+                  Name_Buffer (1 .. Name_Len - 2) :=\n+                    Name_Buffer (3 .. Name_Len);\n+                  Name_Len := Name_Len - 2;\n+                  Info.Info.Path_Name := Name_Find;\n+\n+               elsif Name_Buffer (1 .. 2) = \"U=\" then\n+                  Name_Buffer (1 .. Name_Len - 2) :=\n+                    Name_Buffer (3 .. Name_Len);\n+                  Name_Len := Name_Len - 2;\n+                  Info.Info.Unit_Name := Name_Find;\n+\n+               elsif Name_Buffer (1 .. 2) = \"I=\" then\n+                  Info.Info.Index := Int'Value (Name_Buffer (3 .. Name_Len));\n+\n+               elsif Name_Buffer (1 .. Name_Len) = \"N=T\" then\n+                  Info.Info.Naming_Exception := True;\n+\n+               else\n+                  Report_Error;\n+                  exit Source_Loop;\n+               end if;\n+            end if;\n+         end loop Option_Loop;\n+\n+         Source_Info_Table.Table (Source_Info_Table.Last) := Info;\n+      end loop Source_Loop;\n+\n+      Close (File);\n+\n+   exception\n+      when others =>\n+         Close (File);\n+         Report_Error;\n+   end Read_Source_Info_File;\n+\n+   --------------------\n+   -- Source_Info_Of --\n+   --------------------\n+\n+   function Source_Info_Of (Iter : Source_Info_Iterator) return Source_Info is\n+   begin\n+      return Iter.Info;\n+   end Source_Info_Of;\n+\n    --------------\n    -- Value_Of --\n    --------------\n@@ -746,6 +1035,79 @@ package body Prj.Util is\n       return Nil_Variable_Value;\n    end Value_Of;\n \n+   ----------------------------\n+   -- Write_Source_Info_File --\n+   ----------------------------\n+\n+   procedure Write_Source_Info_File (Tree : Project_Tree_Ref) is\n+      Iter : Source_Iterator := For_Each_Source (Tree);\n+      Source : Prj.Source_Id;\n+      File   : Text_File;\n+   begin\n+      if Opt.Verbose_Mode then\n+         Write_Line (\"Writing new source info file \" &\n+                     Tree.Source_Info_File_Name.all);\n+      end if;\n+\n+      Create (File, Tree.Source_Info_File_Name.all);\n+\n+      if not Is_Valid (File) then\n+         Write_Line (\"warning: unable to create source info file \"\"\" &\n+                     Tree.Source_Info_File_Name.all & '\"');\n+         return;\n+      end if;\n+\n+      loop\n+         Source := Element (Iter);\n+         exit when Source = No_Source;\n+\n+         if not Source.Locally_Removed and then\n+           Source.Replaced_By = No_Source\n+         then\n+            --  project name\n+            Put_Line (File, Get_Name_String (Source.Project.Name));\n+            --  language name\n+            Put_Line (File, Get_Name_String (Source.Language.Name));\n+            --  kind\n+            Put_Line (File, Source.Kind'Img);\n+            --  display path name\n+            Put_Line (File, Get_Name_String (Source.Path.Display_Name));\n+\n+            --  Optional lines:\n+\n+            --  path name (P=)\n+            if Source.Path.Name /= Source.Path.Display_Name then\n+               Put (File, \"P=\");\n+               Put_Line (File, Get_Name_String (Source.Path.Name));\n+            end if;\n+\n+            --  unit name (U=)\n+            if Source.Unit /= No_Unit_Index then\n+               Put (File, \"U=\");\n+               Put_Line (File, Get_Name_String (Source.Unit.Name));\n+            end if;\n+\n+            --  multi-source index (I=)\n+            if Source.Index /= 0 then\n+               Put (File, \"I=\");\n+               Put_Line (File, Source.Index'Img);\n+            end if;\n+\n+            --  naming exception (\"N=T\");\n+            if Source.Naming_Exception then\n+               Put_Line (File, \"N=T\");\n+            end if;\n+\n+            --  empty line to indicate end of info on this source\n+            Put_Line (File, \"\");\n+         end if;\n+\n+         Next (Iter);\n+      end loop;\n+\n+      Close (File);\n+   end Write_Source_Info_File;\n+\n    ---------------\n    -- Write_Str --\n    ---------------"}, {"sha": "b34769e75f119c6a3a92325732f51d4edc124182", "filename": "gcc/ada/prj-util.ads", "status": "modified", "additions": 66, "deletions": 5, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfa8a067caa5a7479c19c9aa7f9fc9aa19b19364/gcc%2Fada%2Fprj-util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfa8a067caa5a7479c19c9aa7f9fc9aa19b19364/gcc%2Fada%2Fprj-util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-util.ads?ref=dfa8a067caa5a7479c19c9aa7f9fc9aa19b19364", "patch": "@@ -160,32 +160,93 @@ package Prj.Util is\n    --  closed.\n \n    procedure Open (File : out Text_File; Name : String);\n-   --  Open a text file to read (file is invalid if text file cannot be opened)\n+   --  Open a text file to read (File is invalid if text file cannot be opened)\n+\n+   procedure Create (File : out Text_File; Name : String);\n+   --  Create a text file to write (File is invaid if text file cannot be\n+   --  created).\n \n    function End_Of_File (File : Text_File) return Boolean;\n    --  Returns True if the end of the text file File has been reached. Fails if\n-   --  File is invalid.\n+   --  File is invalid. Return True if File is an out file.\n \n    procedure Get_Line\n      (File : Text_File;\n       Line : out String;\n       Last : out Natural);\n-   --  Reads a line from an open text file (fails if file is invalid)\n+   --  Reads a line from an open text file (fails if File is invalid or in an\n+   --  out file).\n+\n+   procedure Put (File : Text_File; S : String);\n+   procedure Put_Line (File : Text_File; Line : String);\n+   --  Output a string or a line to an out text file (fails if File is invalid\n+   --  or in an in file).\n \n    procedure Close (File : in out Text_File);\n    --  Close an open text file. File becomes invalid. Fails if File is already\n-   --  invalid.\n+   --  invalid or if an out file cannot be closed successfully.\n+\n+   -----------------------\n+   -- Source info files --\n+   -----------------------\n+\n+   procedure Write_Source_Info_File (Tree : Project_Tree_Ref);\n+   --  Create a new source info file, with the path name specified in the\n+   --  project tree data. Issue a warning if it is not possible to create\n+   --  the new file.\n+\n+   procedure Read_Source_Info_File (Tree : Project_Tree_Ref);\n+   --  Check if there is a source info file specified for the project Tree and\n+   --  if there is one, attempt to read it. If the file exists and is\n+   --  successfully read, set the flag Source_Info_File_Exists to True for\n+   --  the tree.\n+\n+   type Source_Info_Data is record\n+      Project             : Name_Id;\n+      Language            : Name_Id;\n+      Kind                : Source_Kind;\n+      Display_Path_Name   : Name_Id;\n+      Path_Name           : Name_Id;\n+      Unit_Name           : Name_Id := No_Name;\n+      Index               : Int := 0;\n+      Naming_Exception    : Boolean := False;\n+   end record;\n+   --  Data read from a source info file for a single source\n+\n+   type Source_Info is access all Source_Info_Data;\n+   No_Source_Info : constant Source_Info := null;\n+\n+   type Source_Info_Iterator is private;\n+   --  Iterator to get the sources for a single project\n+\n+   procedure Initialize\n+     (Iter : out Source_Info_Iterator; For_Project : Name_Id);\n+   --  Initiaize Iter for the project\n+\n+   function Source_Info_Of (Iter : Source_Info_Iterator) return Source_Info;\n+   --  Get the source info for the source corresponding to the current value of\n+   --  the iterator. Returns No_Source_Info if there is no source corresponding\n+   --  to the iterator.\n+\n+   procedure Next (Iter : in out Source_Info_Iterator);\n+   --  Advance the iterator to the next source in the project\n \n private\n \n    type Text_File_Data is record\n       FD                  : File_Descriptor := Invalid_FD;\n+      Out_File            : Boolean := False;\n       Buffer              : String (1 .. 1_000);\n-      Buffer_Len          : Natural;\n+      Buffer_Len          : Natural := 0;\n       Cursor              : Natural := 0;\n       End_Of_File_Reached : Boolean := False;\n    end record;\n \n    type Text_File is access Text_File_Data;\n \n+   type Source_Info_Iterator is record\n+      Info : Source_Info;\n+      Next : Natural;\n+   end record;\n+\n end Prj.Util;"}, {"sha": "bdd7ccee62ecd621dd488b2166643b6706f929ff", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfa8a067caa5a7479c19c9aa7f9fc9aa19b19364/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfa8a067caa5a7479c19c9aa7f9fc9aa19b19364/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=dfa8a067caa5a7479c19c9aa7f9fc9aa19b19364", "patch": "@@ -1354,6 +1354,12 @@ package Prj is\n          Source_Paths_HT   : Source_Paths_Htable.Instance;\n          --  Full path to Source_Id\n \n+         Source_Info_File_Name   : String_Access := null;\n+         --  The name of the source info file, if specified by the builder\n+\n+         Source_Info_File_Exists : Boolean := False;\n+         --  True when a source info file has been successfully read\n+\n          Private_Part      : Private_Project_Tree_Data;\n       end record;\n    --  Data for a project tree"}]}