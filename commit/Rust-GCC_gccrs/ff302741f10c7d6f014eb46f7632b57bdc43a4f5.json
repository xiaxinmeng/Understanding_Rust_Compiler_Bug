{"sha": "ff302741f10c7d6f014eb46f7632b57bdc43a4f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmYzMDI3NDFmMTBjN2Q2ZjAxNGViNDZmNzYzMmI1N2JkYzQzYTRmNQ==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2015-07-15T15:58:43Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2015-07-15T15:58:43Z"}, "message": "Limit AA walking when inlining analysis examines parameters\n\n2015-07-15  Paolo Bonzini  <bonzini@gnu.org>\n\t    Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-inline-analysis.c (unmodified_parm_or_parm_agg_item): Accept\n\tstruct func_body_info* instead of struct ipa_node_params*, expecting\n\tfbi->info to be filled in.  Replace throughout.  Adjust call to\n\tipa_load_from_parm_agg.\n\t(set_cond_stmt_execution_predicate): Accept struct func_body_info*\n\tinstead of struct ipa_node_params*.  Adjust calls to other functions\n\tso that they pass either fbi or fbi->info.\n\t(set_switch_stmt_execution_predicate): Likewise.\n\t(will_be_nonconstant_predicate): Likewise.\n\t(compute_bb_predicates): Likewise.\n\t(estimate_function_body_sizes): Move asserts earlier.  Fill in\n\tstruct func_body_info, replace parms_info with fbi.info.  Adjust\n\tcalls to functions that now accept struct func_body_info.\n\t* ipa-prop.c (param_aa_status, struct ipa_bb_info): Move to ipa-prop.h.\n\t(struct func_body_info): Likewise.\n\t(ipa_load_from_parm_agg_1): Rename to ipa_load_from_parm_agg,\n\tremove static.  Adjust callers.\n\t(ipa_load_from_parm_agg): Remove.\n\t* ipa-prop.h (param_aa_status, ipa_bb_info): Move from ipa-prop.c.\n\t(func_body_info): Likewise.\n\t(ipa_load_from_parm_agg): Adjust prototype.\n\n\nCo-Authored-By: Martin Jambor <mjambor@suse.cz>\n\nFrom-SVN: r225838", "tree": {"sha": "127491dc7e4f3bf8622f11581b6fa60ff963f42b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/127491dc7e4f3bf8622f11581b6fa60ff963f42b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff302741f10c7d6f014eb46f7632b57bdc43a4f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff302741f10c7d6f014eb46f7632b57bdc43a4f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff302741f10c7d6f014eb46f7632b57bdc43a4f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff302741f10c7d6f014eb46f7632b57bdc43a4f5/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7392b0906f329b552ab6de61a2248f860acfcd7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7392b0906f329b552ab6de61a2248f860acfcd7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7392b0906f329b552ab6de61a2248f860acfcd7a"}], "stats": {"total": 238, "additions": 129, "deletions": 109}, "files": [{"sha": "a2ce483c774f7ec9a7c278b4600633f189b28cbb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff302741f10c7d6f014eb46f7632b57bdc43a4f5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff302741f10c7d6f014eb46f7632b57bdc43a4f5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ff302741f10c7d6f014eb46f7632b57bdc43a4f5", "patch": "@@ -1,3 +1,28 @@\n+2015-07-15  Paolo Bonzini  <bonzini@gnu.org>\n+\t    Martin Jambor  <mjambor@suse.cz>\n+\n+\t* ipa-inline-analysis.c (unmodified_parm_or_parm_agg_item): Accept\n+\tstruct func_body_info* instead of struct ipa_node_params*, expecting\n+\tfbi->info to be filled in.  Replace throughout.  Adjust call to\n+\tipa_load_from_parm_agg.\n+\t(set_cond_stmt_execution_predicate): Accept struct func_body_info*\n+\tinstead of struct ipa_node_params*.  Adjust calls to other functions\n+\tso that they pass either fbi or fbi->info.\n+\t(set_switch_stmt_execution_predicate): Likewise.\n+\t(will_be_nonconstant_predicate): Likewise.\n+\t(compute_bb_predicates): Likewise.\n+\t(estimate_function_body_sizes): Move asserts earlier.  Fill in\n+\tstruct func_body_info, replace parms_info with fbi.info.  Adjust\n+\tcalls to functions that now accept struct func_body_info.\n+\t* ipa-prop.c (param_aa_status, struct ipa_bb_info): Move to ipa-prop.h.\n+\t(struct func_body_info): Likewise.\n+\t(ipa_load_from_parm_agg_1): Rename to ipa_load_from_parm_agg,\n+\tremove static.  Adjust callers.\n+\t(ipa_load_from_parm_agg): Remove.\n+\t* ipa-prop.h (param_aa_status, ipa_bb_info): Move from ipa-prop.c.\n+\t(func_body_info): Likewise.\n+\t(ipa_load_from_parm_agg): Adjust prototype.\n+\n 2015-07-12  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n \n \t* gensupport.c (rtx_handle_directive): Adjust."}, {"sha": "81a6860f1146b03b6e04422ad09c024241f5bed2", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 39, "deletions": 33, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff302741f10c7d6f014eb46f7632b57bdc43a4f5/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff302741f10c7d6f014eb46f7632b57bdc43a4f5/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=ff302741f10c7d6f014eb46f7632b57bdc43a4f5", "patch": "@@ -1574,7 +1574,7 @@ unmodified_parm (gimple stmt, tree op)\n    loaded.  */\n \n static bool\n-unmodified_parm_or_parm_agg_item (struct ipa_node_params *info,\n+unmodified_parm_or_parm_agg_item (struct func_body_info *fbi,\n \t\t\t\t  gimple stmt, tree op, int *index_p,\n \t\t\t\t  struct agg_position_info *aggpos)\n {\n@@ -1583,7 +1583,7 @@ unmodified_parm_or_parm_agg_item (struct ipa_node_params *info,\n   gcc_checking_assert (aggpos);\n   if (res)\n     {\n-      *index_p = ipa_get_param_decl_index (info, res);\n+      *index_p = ipa_get_param_decl_index (fbi->info, res);\n       if (*index_p < 0)\n \treturn false;\n       aggpos->agg_contents = false;\n@@ -1599,13 +1599,14 @@ unmodified_parm_or_parm_agg_item (struct ipa_node_params *info,\n       stmt = SSA_NAME_DEF_STMT (op);\n       op = gimple_assign_rhs1 (stmt);\n       if (!REFERENCE_CLASS_P (op))\n-\treturn unmodified_parm_or_parm_agg_item (info, stmt, op, index_p,\n+\treturn unmodified_parm_or_parm_agg_item (fbi, stmt, op, index_p,\n \t\t\t\t\t\t aggpos);\n     }\n \n   aggpos->agg_contents = true;\n-  return ipa_load_from_parm_agg (info, stmt, op, index_p, &aggpos->offset,\n-\t\t\t\t &aggpos->by_ref);\n+  return ipa_load_from_parm_agg (fbi, fbi->info->descriptors,\n+\t\t\t\t stmt, op, index_p, &aggpos->offset,\n+\t\t\t\t NULL, &aggpos->by_ref);\n }\n \n /* See if statement might disappear after inlining.\n@@ -1744,7 +1745,7 @@ eliminated_by_inlining_prob (gimple stmt)\n    predicates to the CFG edges.   */\n \n static void\n-set_cond_stmt_execution_predicate (struct ipa_node_params *info,\n+set_cond_stmt_execution_predicate (struct func_body_info *fbi,\n \t\t\t\t   struct inline_summary *summary,\n \t\t\t\t   basic_block bb)\n {\n@@ -1767,7 +1768,7 @@ set_cond_stmt_execution_predicate (struct ipa_node_params *info,\n   /* TODO: handle conditionals like\n      var = op0 < 4;\n      if (var != 0).  */\n-  if (unmodified_parm_or_parm_agg_item (info, last, op, &index, &aggpos))\n+  if (unmodified_parm_or_parm_agg_item (fbi, last, op, &index, &aggpos))\n     {\n       code = gimple_cond_code (last);\n       inverted_code = invert_tree_comparison (code, HONOR_NANS (op));\n@@ -1810,8 +1811,7 @@ set_cond_stmt_execution_predicate (struct ipa_node_params *info,\n       || gimple_call_num_args (set_stmt) != 1)\n     return;\n   op2 = gimple_call_arg (set_stmt, 0);\n-  if (!unmodified_parm_or_parm_agg_item\n-      (info, set_stmt, op2, &index, &aggpos))\n+  if (!unmodified_parm_or_parm_agg_item (fbi, set_stmt, op2, &index, &aggpos))\n     return;\n   FOR_EACH_EDGE (e, ei, bb->succs) if (e->flags & EDGE_FALSE_VALUE)\n     {\n@@ -1827,7 +1827,7 @@ set_cond_stmt_execution_predicate (struct ipa_node_params *info,\n    predicates to the CFG edges.   */\n \n static void\n-set_switch_stmt_execution_predicate (struct ipa_node_params *info,\n+set_switch_stmt_execution_predicate (struct func_body_info *fbi,\n \t\t\t\t     struct inline_summary *summary,\n \t\t\t\t     basic_block bb)\n {\n@@ -1845,7 +1845,7 @@ set_switch_stmt_execution_predicate (struct ipa_node_params *info,\n     return;\n   gswitch *last = as_a <gswitch *> (lastg);\n   op = gimple_switch_index (last);\n-  if (!unmodified_parm_or_parm_agg_item (info, last, op, &index, &aggpos))\n+  if (!unmodified_parm_or_parm_agg_item (fbi, last, op, &index, &aggpos))\n     return;\n \n   FOR_EACH_EDGE (e, ei, bb->succs)\n@@ -1888,8 +1888,8 @@ set_switch_stmt_execution_predicate (struct ipa_node_params *info,\n    which it is executable.  */\n \n static void\n-compute_bb_predicates (struct cgraph_node *node,\n-\t\t       struct ipa_node_params *parms_info,\n+compute_bb_predicates (struct func_body_info *fbi,\n+\t\t       struct cgraph_node *node,\n \t\t       struct inline_summary *summary)\n {\n   struct function *my_function = DECL_STRUCT_FUNCTION (node->decl);\n@@ -1898,8 +1898,8 @@ compute_bb_predicates (struct cgraph_node *node,\n \n   FOR_EACH_BB_FN (bb, my_function)\n     {\n-      set_cond_stmt_execution_predicate (parms_info, summary, bb);\n-      set_switch_stmt_execution_predicate (parms_info, summary, bb);\n+      set_cond_stmt_execution_predicate (fbi, summary, bb);\n+      set_switch_stmt_execution_predicate (fbi, summary, bb);\n     }\n \n   /* Entry block is always executable.  */\n@@ -2031,7 +2031,7 @@ will_be_nonconstant_expr_predicate (struct ipa_node_params *info,\n    a compile time constant.  */\n \n static struct predicate\n-will_be_nonconstant_predicate (struct ipa_node_params *info,\n+will_be_nonconstant_predicate (struct func_body_info *fbi,\n \t\t\t       struct inline_summary *summary,\n \t\t\t       gimple stmt,\n \t\t\t       vec<predicate_t> nonconstant_names)\n@@ -2065,7 +2065,7 @@ will_be_nonconstant_predicate (struct ipa_node_params *info,\n       tree op;\n       gcc_assert (gimple_assign_single_p (stmt));\n       op = gimple_assign_rhs1 (stmt);\n-      if (!unmodified_parm_or_parm_agg_item (info, stmt, op, &base_index,\n+      if (!unmodified_parm_or_parm_agg_item (fbi, stmt, op, &base_index,\n \t\t\t\t\t     &aggpos))\n \treturn p;\n     }\n@@ -2078,7 +2078,7 @@ will_be_nonconstant_predicate (struct ipa_node_params *info,\n     {\n       tree parm = unmodified_parm (stmt, use);\n       /* For arguments we can build a condition.  */\n-      if (parm && ipa_get_param_decl_index (info, parm) >= 0)\n+      if (parm && ipa_get_param_decl_index (fbi->info, parm) >= 0)\n \tcontinue;\n       if (TREE_CODE (use) != SSA_NAME)\n \treturn p;\n@@ -2099,7 +2099,7 @@ will_be_nonconstant_predicate (struct ipa_node_params *info,\n       tree parm = unmodified_parm (stmt, use);\n       int index;\n \n-      if (parm && (index = ipa_get_param_decl_index (info, parm)) >= 0)\n+      if (parm && (index = ipa_get_param_decl_index (fbi->info, parm)) >= 0)\n \t{\n \t  if (index != base_index)\n \t    p = add_condition (summary, index, NULL, CHANGED, NULL_TREE);\n@@ -2481,13 +2481,17 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n   int freq;\n   struct inline_summary *info = inline_summaries->get (node);\n   struct predicate bb_predicate;\n-  struct ipa_node_params *parms_info = NULL;\n+  struct func_body_info fbi;\n   vec<predicate_t> nonconstant_names = vNULL;\n   int nblocks, n;\n   int *order;\n   predicate array_index = true_predicate ();\n   gimple fix_builtin_expect_stmt;\n \n+  gcc_assert (my_function && my_function->cfg);\n+  gcc_assert (cfun == my_function);\n+\n+  memset(&fbi, 0, sizeof(fbi));\n   info->conds = NULL;\n   info->entry = NULL;\n \n@@ -2510,7 +2514,11 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \n       if (ipa_node_params_sum)\n \t{\n-\t  parms_info = IPA_NODE_REF (node);\n+\t  fbi.node = node;\n+\t  fbi.info = IPA_NODE_REF (node);\n+\t  fbi.bb_infos = vNULL;\n+\t  fbi.bb_infos.safe_grow_cleared (last_basic_block_for_fn (cfun));\n+\t  fbi.param_count = count_formal_params(node->decl);\n \t  nonconstant_names.safe_grow_cleared\n \t    (SSANAMES (my_function)->length ());\n \t}\n@@ -2528,10 +2536,8 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n   bb_predicate = not_inlined_predicate ();\n   account_size_time (info, 2 * INLINE_SIZE_SCALE, 0, &bb_predicate);\n \n-  gcc_assert (my_function && my_function->cfg);\n-  if (parms_info)\n-    compute_bb_predicates (node, parms_info, info);\n-  gcc_assert (cfun == my_function);\n+  if (fbi.info)\n+    compute_bb_predicates (&fbi, node, info);\n   order = XNEWVEC (int, n_basic_blocks_for_fn (cfun));\n   nblocks = pre_and_rev_post_order_compute (NULL, order, false);\n   for (n = 0; n < nblocks; n++)\n@@ -2548,7 +2554,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t}\n \n       /* TODO: Obviously predicates can be propagated down across CFG.  */\n-      if (parms_info)\n+      if (fbi.info)\n \t{\n \t  if (bb->aux)\n \t    bb_predicate = *(struct predicate *) bb->aux;\n@@ -2564,7 +2570,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t  dump_predicate (dump_file, info->conds, &bb_predicate);\n \t}\n \n-      if (parms_info && nonconstant_names.exists ())\n+      if (fbi.info && nonconstant_names.exists ())\n \t{\n \t  struct predicate phi_predicate;\n \t  bool first_phi = true;\n@@ -2573,7 +2579,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t       gsi_next (&bsi))\n \t    {\n \t      if (first_phi\n-\t\t  && !phi_result_unknown_predicate (parms_info, info, bb,\n+\t\t  && !phi_result_unknown_predicate (fbi.info, info, bb,\n \t\t\t\t\t\t    &phi_predicate,\n \t\t\t\t\t\t    nonconstant_names))\n \t\tbreak;\n@@ -2682,9 +2688,9 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t  /* TODO: When conditional jump or swithc is known to be constant, but\n \t     we did not translate it into the predicates, we really can account\n \t     just maximum of the possible paths.  */\n-\t  if (parms_info)\n+\t  if (fbi.info)\n \t    will_be_nonconstant\n-\t      = will_be_nonconstant_predicate (parms_info, info,\n+\t      = will_be_nonconstant_predicate (&fbi, info,\n \t\t\t\t\t       stmt, nonconstant_names);\n \t  if (this_time || this_size)\n \t    {\n@@ -2699,7 +2705,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t      if (prob == 2 && dump_file && (dump_flags & TDF_DETAILS))\n \t\tfprintf (dump_file, \"\\t\\tWill be eliminated by inlining\\n\");\n \n-\t      if (parms_info)\n+\t      if (fbi.info)\n \t\tp = and_predicates (info->conds, &bb_predicate,\n \t\t\t\t    &will_be_nonconstant);\n \t      else\n@@ -2767,7 +2773,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t\t&& !is_gimple_min_invariant (niter_desc.niter))\n \t    {\n \t      predicate will_be_nonconstant\n-\t\t= will_be_nonconstant_expr_predicate (parms_info, info,\n+\t\t= will_be_nonconstant_expr_predicate (fbi.info, info,\n \t\t\t\t\t\t      niter_desc.niter,\n \t\t\t\t\t\t      nonconstant_names);\n \t      if (!true_predicate_p (&will_be_nonconstant))\n@@ -2805,7 +2811,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t\t\t|| is_gimple_min_invariant (iv.step))\n \t\t      continue;\n \t\t    will_be_nonconstant\n-\t\t      = will_be_nonconstant_expr_predicate (parms_info, info,\n+\t\t      = will_be_nonconstant_expr_predicate (fbi.info, info,\n \t\t\t\t\t\t\t    iv.step,\n \t\t\t\t\t\t\t    nonconstant_names);\n \t\t    if (!true_predicate_p (&will_be_nonconstant))"}, {"sha": "615f749f8fdcc0ea22a14cf91197682c2cdc40ff", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 11, "deletions": 74, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff302741f10c7d6f014eb46f7632b57bdc43a4f5/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff302741f10c7d6f014eb46f7632b57bdc43a4f5/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=ff302741f10c7d6f014eb46f7632b57bdc43a4f5", "patch": "@@ -70,57 +70,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"domwalk.h\"\n #include \"builtins.h\"\n \n-/* Intermediate information that we get from alias analysis about a particular\n-   parameter in a particular basic_block.  When a parameter or the memory it\n-   references is marked modified, we use that information in all dominatd\n-   blocks without cosulting alias analysis oracle.  */\n-\n-struct param_aa_status\n-{\n-  /* Set when this structure contains meaningful information.  If not, the\n-     structure describing a dominating BB should be used instead.  */\n-  bool valid;\n-\n-  /* Whether we have seen something which might have modified the data in\n-     question.  PARM is for the parameter itself, REF is for data it points to\n-     but using the alias type of individual accesses and PT is the same thing\n-     but for computing aggregate pass-through functions using a very inclusive\n-     ao_ref.  */\n-  bool parm_modified, ref_modified, pt_modified;\n-};\n-\n-/* Information related to a given BB that used only when looking at function\n-   body.  */\n-\n-struct ipa_bb_info\n-{\n-  /* Call graph edges going out of this BB.  */\n-  vec<cgraph_edge *> cg_edges;\n-  /* Alias analysis statuses of each formal parameter at this bb.  */\n-  vec<param_aa_status> param_aa_statuses;\n-};\n-\n-/* Structure with global information that is only used when looking at function\n-   body. */\n-\n-struct func_body_info\n-{\n-  /* The node that is being analyzed.  */\n-  cgraph_node *node;\n-\n-  /* Its info.  */\n-  struct ipa_node_params *info;\n-\n-  /* Information about individual BBs. */\n-  vec<ipa_bb_info> bb_infos;\n-\n-  /* Number of parameters.  */\n-  int param_count;\n-\n-  /* Number of statements already walked by when analyzing this function.  */\n-  unsigned int aa_walked;\n-};\n-\n /* Function summary where the parameter infos are actually stored. */\n ipa_node_params_t *ipa_node_params_sum = NULL;\n /* Vector of IPA-CP transformation data for each clone.  */\n@@ -1010,12 +959,12 @@ parm_ref_data_pass_through_p (struct func_body_info *fbi, int index,\n    within the aggregate and whether it is a load from a value passed by\n    reference respectively.  */\n \n-static bool\n-ipa_load_from_parm_agg_1 (struct func_body_info *fbi,\n-\t\t\t  vec<ipa_param_descriptor> descriptors,\n-\t\t\t  gimple stmt, tree op, int *index_p,\n-\t\t\t  HOST_WIDE_INT *offset_p, HOST_WIDE_INT *size_p,\n-\t\t\t  bool *by_ref_p)\n+bool\n+ipa_load_from_parm_agg (struct func_body_info *fbi,\n+\t\t\tvec<ipa_param_descriptor> descriptors,\n+\t\t\tgimple stmt, tree op, int *index_p,\n+\t\t\tHOST_WIDE_INT *offset_p, HOST_WIDE_INT *size_p,\n+\t\t\tbool *by_ref_p)\n {\n   int index;\n   HOST_WIDE_INT size, max_size;\n@@ -1082,18 +1031,6 @@ ipa_load_from_parm_agg_1 (struct func_body_info *fbi,\n   return false;\n }\n \n-/* Just like the previous function, just without the param_analysis_info\n-   pointer, for users outside of this file.  */\n-\n-bool\n-ipa_load_from_parm_agg (struct ipa_node_params *info, gimple stmt,\n-\t\t\ttree op, int *index_p, HOST_WIDE_INT *offset_p,\n-\t\t\tbool *by_ref_p)\n-{\n-  return ipa_load_from_parm_agg_1 (NULL, info->descriptors, stmt, op, index_p,\n-\t\t\t\t   offset_p, NULL, by_ref_p);\n-}\n-\n /* Given that an actual argument is an SSA_NAME (given in NAME) and is a result\n    of an assignment statement STMT, try to determine whether we are actually\n    handling any of the following cases and construct an appropriate jump\n@@ -1977,9 +1914,9 @@ ipa_analyze_indirect_call_uses (struct func_body_info *fbi, gcall *call,\n   int index;\n   gimple def = SSA_NAME_DEF_STMT (target);\n   if (gimple_assign_single_p (def)\n-      && ipa_load_from_parm_agg_1 (fbi, info->descriptors, def,\n-\t\t\t\t   gimple_assign_rhs1 (def), &index, &offset,\n-\t\t\t\t   NULL, &by_ref))\n+      && ipa_load_from_parm_agg (fbi, info->descriptors, def,\n+\t\t\t\t gimple_assign_rhs1 (def), &index, &offset,\n+\t\t\t\t NULL, &by_ref))\n     {\n       struct cgraph_edge *cs = ipa_note_param_call (fbi->node, index, call);\n       cs->indirect_info->offset = offset;\n@@ -5192,8 +5129,8 @@ ipcp_modif_dom_walker::before_dom_children (basic_block bb)\n       if (vce)\n \tcontinue;\n \n-      if (!ipa_load_from_parm_agg_1 (m_fbi, m_descriptors, stmt, rhs, &index,\n-\t\t\t\t     &offset, &size, &by_ref))\n+      if (!ipa_load_from_parm_agg (m_fbi, m_descriptors, stmt, rhs, &index,\n+\t\t\t\t   &offset, &size, &by_ref))\n \tcontinue;\n       for (v = m_aggval; v; v = v->next)\n \tif (v->index == index"}, {"sha": "a6b26b8a4f6639aa3709b2092780f8051433dcc9", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 54, "deletions": 2, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff302741f10c7d6f014eb46f7632b57bdc43a4f5/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff302741f10c7d6f014eb46f7632b57bdc43a4f5/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=ff302741f10c7d6f014eb46f7632b57bdc43a4f5", "patch": "@@ -336,6 +336,57 @@ struct ipa_node_params\n   unsigned node_calling_single_call : 1;\n };\n \n+/* Intermediate information that we get from alias analysis about a particular\n+   parameter in a particular basic_block.  When a parameter or the memory it\n+   references is marked modified, we use that information in all dominatd\n+   blocks without cosulting alias analysis oracle.  */\n+\n+struct param_aa_status\n+{\n+  /* Set when this structure contains meaningful information.  If not, the\n+     structure describing a dominating BB should be used instead.  */\n+  bool valid;\n+\n+  /* Whether we have seen something which might have modified the data in\n+     question.  PARM is for the parameter itself, REF is for data it points to\n+     but using the alias type of individual accesses and PT is the same thing\n+     but for computing aggregate pass-through functions using a very inclusive\n+     ao_ref.  */\n+  bool parm_modified, ref_modified, pt_modified;\n+};\n+\n+/* Information related to a given BB that used only when looking at function\n+   body.  */\n+\n+struct ipa_bb_info\n+{\n+  /* Call graph edges going out of this BB.  */\n+  vec<cgraph_edge *> cg_edges;\n+  /* Alias analysis statuses of each formal parameter at this bb.  */\n+  vec<param_aa_status> param_aa_statuses;\n+};\n+\n+/* Structure with global information that is only used when looking at function\n+   body. */\n+\n+struct func_body_info\n+{\n+  /* The node that is being analyzed.  */\n+  cgraph_node *node;\n+\n+  /* Its info.  */\n+  struct ipa_node_params *info;\n+\n+  /* Information about individual BBs. */\n+  vec<ipa_bb_info> bb_infos;\n+\n+  /* Number of parameters.  */\n+  int param_count;\n+\n+  /* Number of statements already walked by when analyzing this function.  */\n+  unsigned int aa_walked;\n+};\n+\n /* ipa_node_params access functions.  Please use these to access fields that\n    are or will be shared among various passes.  */\n \n@@ -585,8 +636,9 @@ void ipa_analyze_node (struct cgraph_node *);\n /* Aggregate jump function related functions.  */\n tree ipa_find_agg_cst_for_param (struct ipa_agg_jump_function *, HOST_WIDE_INT,\n \t\t\t\t bool);\n-bool ipa_load_from_parm_agg (struct ipa_node_params *, gimple, tree, int *,\n-\t\t\t     HOST_WIDE_INT *, bool *);\n+bool ipa_load_from_parm_agg (struct func_body_info *,\n+\t\t\t     vec<ipa_param_descriptor>, gimple, tree, int *,\n+\t\t\t     HOST_WIDE_INT *, HOST_WIDE_INT *, bool *);\n \n /* Debugging interface.  */\n void ipa_print_node_params (FILE *, struct cgraph_node *node);"}]}