{"sha": "f71ef09df3b1dcbbb5521ce9488894e1db9c6246", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjcxZWYwOWRmM2IxZGNiYmI1NTIxY2U5NDg4ODk0ZTFkYjljNjI0Ng==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2006-11-23T02:19:39Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2006-11-23T02:19:39Z"}, "message": "Revert accidental commit (patch coming for this :P)\n\nFrom-SVN: r119113", "tree": {"sha": "f8a9128f5bf19f445a21b025ab8217021f7fc145", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f8a9128f5bf19f445a21b025ab8217021f7fc145"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f71ef09df3b1dcbbb5521ce9488894e1db9c6246", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f71ef09df3b1dcbbb5521ce9488894e1db9c6246", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f71ef09df3b1dcbbb5521ce9488894e1db9c6246", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f71ef09df3b1dcbbb5521ce9488894e1db9c6246/comments", "author": null, "committer": null, "parents": [{"sha": "78ab22b9d3a57218376e650984e71b5ac91bd004", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78ab22b9d3a57218376e650984e71b5ac91bd004", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78ab22b9d3a57218376e650984e71b5ac91bd004"}], "stats": {"total": 658, "additions": 544, "deletions": 114}, "files": [{"sha": "42099ddedd4aee8e93b7f287e2fb6226407ad8ad", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 544, "deletions": 114, "changes": 658, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f71ef09df3b1dcbbb5521ce9488894e1db9c6246/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f71ef09df3b1dcbbb5521ce9488894e1db9c6246/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=f71ef09df3b1dcbbb5521ce9488894e1db9c6246", "patch": "@@ -434,14 +434,53 @@ struct constraint\n static VEC(constraint_t,heap) *constraints;\n static alloc_pool constraint_pool;\n \n+/* An edge in the weighted constraint graph.   The edges are weighted,\n+   with a bit set in weights meaning their is an edge with that\n+   weight. \n+   We don't keep the src in the edge, because we always know what it\n+   is. */\n \n-/* The constraint graph is represented as an array of bitmaps\n-   containing successor nodes.  */\n+struct constraint_edge\n+{\n+  unsigned int dest;\n+  bitmap weights;\n+};\n+\n+typedef struct constraint_edge *constraint_edge_t;\n+static alloc_pool constraint_edge_pool;\n+\n+/* Return a new constraint edge from SRC to DEST.  */\n+\n+static constraint_edge_t\n+new_constraint_edge (unsigned int dest)\n+{\n+  constraint_edge_t ret = pool_alloc (constraint_edge_pool);\n+  ret->dest = dest;\n+  ret->weights = NULL;\n+  return ret;\n+}\n+\n+DEF_VEC_P(constraint_edge_t);\n+DEF_VEC_ALLOC_P(constraint_edge_t,heap);\n+\n+\n+/* The constraint graph is represented internally in two different\n+   ways.  The overwhelming majority of edges in the constraint graph\n+   are zero weigh edges, and thus, using a vector of contrainst_edge_t\n+   is a waste of time and memory, since they have no weights.  We\n+   simply use a bitmap to store the preds and succs for each node.\n+   The weighted edges are stored as a set of adjacency vectors, one\n+   per variable. succs[x] is the vector of successors for variable x,\n+   and preds[x] is the vector of predecessors for variable x.  IOW,\n+   all edges are \"forward\" edges, which is not like our CFG.  So\n+   remember that preds[x]->src == x, and succs[x]->src == x.  */\n \n struct constraint_graph\n {\n-  bitmap *succs;\n-  bitmap *preds;\n+  bitmap *zero_weight_succs;\n+  bitmap *zero_weight_preds;\n+  VEC(constraint_edge_t,heap) **succs;\n+  VEC(constraint_edge_t,heap) **preds;\n };\n \n typedef struct constraint_graph *constraint_graph_t;\n@@ -700,6 +739,44 @@ insert_into_complex (unsigned int var, constraint_t c)\n }\n \n \n+/* Compare two constraint edges A and B, return true if they are equal.  */\n+\n+static bool\n+constraint_edge_equal (struct constraint_edge a, struct constraint_edge b)\n+{\n+  return a.dest == b.dest;\n+}\n+\n+/* Compare two constraint edges, return true if A is less than B */\n+\n+static bool\n+constraint_edge_less (const constraint_edge_t a, const constraint_edge_t b)\n+{\n+  if (a->dest < b->dest)\n+    return true;\n+  return false;\n+}\n+\n+/* Find the constraint edge that matches LOOKFOR, in VEC.\n+   Return the edge, if found, NULL otherwise.  */\n+\n+static constraint_edge_t \n+constraint_edge_vec_find (VEC(constraint_edge_t,heap) *vec, \n+\t\t\t  struct constraint_edge lookfor)\n+{\n+  unsigned int place;  \n+  constraint_edge_t edge = NULL;\n+\n+  place = VEC_lower_bound (constraint_edge_t, vec, &lookfor, \n+\t\t\t   constraint_edge_less);\n+  if (place >= VEC_length (constraint_edge_t, vec))\n+    return NULL;\n+  edge = VEC_index (constraint_edge_t, vec, place);\n+  if (!constraint_edge_equal (*edge, lookfor))\n+    return NULL;\n+  return edge;\n+}\n+\n /* Condense two variable nodes into a single variable node, by moving\n    all associated info from SRC to TO.  */\n \n@@ -738,116 +815,351 @@ condense_varmap_nodes (unsigned int to, unsigned int src)\n   srcvi->complex = NULL;\n }\n \n+/* Erase an edge from SRC to SRC from GRAPH.  This routine only\n+   handles self-edges (e.g. an edge from a to a).  */\n+\n+static void\n+erase_graph_self_edge (constraint_graph_t graph, unsigned int src)\n+{\n+  VEC(constraint_edge_t,heap) *predvec = graph->preds[src];\n+  VEC(constraint_edge_t,heap) *succvec = graph->succs[src];\n+  struct constraint_edge edge;\n+  unsigned int place;\n+\n+  edge.dest = src;\n+\n+  /* Remove from the successors.  */\n+  place = VEC_lower_bound (constraint_edge_t, succvec, &edge, \n+\t\t\t   constraint_edge_less);\n+  \n+  /* Make sure we found the edge.  */\n+#ifdef ENABLE_CHECKING\n+  {\n+    constraint_edge_t tmp = VEC_index (constraint_edge_t, succvec, place);\n+    gcc_assert (constraint_edge_equal (*tmp, edge));\n+  }\n+#endif\n+  VEC_ordered_remove (constraint_edge_t, succvec, place);\n+\n+  /* Remove from the predecessors.  */\n+  place = VEC_lower_bound (constraint_edge_t, predvec, &edge,\n+\t\t\t   constraint_edge_less);\n+\n+  /* Make sure we found the edge.  */\n+#ifdef ENABLE_CHECKING\n+  {\n+    constraint_edge_t tmp = VEC_index (constraint_edge_t, predvec, place);\n+    gcc_assert (constraint_edge_equal (*tmp, edge));\n+  }\n+#endif\n+  VEC_ordered_remove (constraint_edge_t, predvec, place);\n+}\n \n /* Remove edges involving NODE from GRAPH.  */\n \n static void\n clear_edges_for_node (constraint_graph_t graph, unsigned int node)\n {\n+  VEC(constraint_edge_t,heap) *succvec = graph->succs[node];\n+  VEC(constraint_edge_t,heap) *predvec = graph->preds[node];\n   bitmap_iterator bi;\n   unsigned int j;\n+  constraint_edge_t c = NULL;\n+  int i;\n \n   /* Walk the successors, erase the associated preds.  */\n   \n-  EXECUTE_IF_IN_NONNULL_BITMAP (graph->succs[node], 0, j, bi)\n+  EXECUTE_IF_IN_NONNULL_BITMAP (graph->zero_weight_succs[node], 0, j, bi)\n     if (j != node)\n-      bitmap_clear_bit (graph->preds[j], node);\n+      bitmap_clear_bit (graph->zero_weight_preds[j], node);\n   \n+  for (i = 0; VEC_iterate (constraint_edge_t, succvec, i, c); i++)\n+    if (c->dest != node)\n+      {\n+\tunsigned int place;\n+\tstruct constraint_edge lookfor;\n+\tconstraint_edge_t result;\n+\n+\tlookfor.dest = node;\n+\tplace = VEC_lower_bound (constraint_edge_t, graph->preds[c->dest], \n+\t\t\t\t &lookfor, constraint_edge_less);\n+\tresult = VEC_ordered_remove (constraint_edge_t, \n+\t\t\t\t     graph->preds[c->dest], place);\n+\tpool_free (constraint_edge_pool, result);\n+      }\n \n   /* Walk the preds, erase the associated succs.  */\n \n-  EXECUTE_IF_IN_NONNULL_BITMAP (graph->preds[node], 0, j, bi)\n+  EXECUTE_IF_IN_NONNULL_BITMAP (graph->zero_weight_preds[node], 0, j, bi)\n     if (j != node)\n-      bitmap_clear_bit (graph->succs[j], node);\n+      bitmap_clear_bit (graph->zero_weight_succs[j], node);\n   \n+  for (i =0; VEC_iterate (constraint_edge_t, predvec, i, c); i++)\n+    if (c->dest != node)\n+      {\n+\tunsigned int place;\n+\tstruct constraint_edge lookfor;\n+\tconstraint_edge_t result;\n+\n+\tlookfor.dest = node;\n+\tplace = VEC_lower_bound (constraint_edge_t, graph->succs[c->dest],\n+\t\t\t\t &lookfor, constraint_edge_less);\n+\tresult = VEC_ordered_remove (constraint_edge_t, \n+\t\t\t\t     graph->succs[c->dest], place);\n+\tpool_free (constraint_edge_pool, result);\n \n-  if (graph->preds[node])\n+      }    \n+\n+  if (graph->zero_weight_preds[node])\n     {\n-      BITMAP_FREE (graph->preds[node]);\n-      graph->preds[node] = NULL;\n+      BITMAP_FREE (graph->zero_weight_preds[node]);\n+      graph->zero_weight_preds[node] = NULL;\n     } \n \n-  if (graph->succs[node])\n+  if (graph->zero_weight_succs[node])\n     {\n-      BITMAP_FREE (graph->succs[node]);\n-      graph->succs[node] = NULL;\n-    }\n+      BITMAP_FREE (graph->zero_weight_succs[node]);\n+      graph->zero_weight_succs[node] = NULL;\n+    } \n+\n+  VEC_free (constraint_edge_t, heap, graph->preds[node]);\n+  VEC_free (constraint_edge_t, heap, graph->succs[node]);\n+  graph->preds[node] = NULL;\n+  graph->succs[node] = NULL;\n }\n \n static bool edge_added = false;\n+  \n+/* Add edge (src, dest) to the graph.  */\n+\n+static bool\n+add_graph_edge (constraint_graph_t graph, unsigned int src, unsigned int dest)\n+{\n+  unsigned int place;\n+  VEC(constraint_edge_t,heap) *vec;\n+  struct constraint_edge newe;\n+  newe.dest = dest;\n+\n+  vec = graph->preds[src];\n+  place = VEC_lower_bound (constraint_edge_t, vec, &newe, \n+\t\t\t   constraint_edge_less);\n+  if (place == VEC_length (constraint_edge_t, vec)\n+      || VEC_index (constraint_edge_t, vec, place)->dest != dest)\n+    {\n+      constraint_edge_t edge = new_constraint_edge (dest);\n+\n+      VEC_safe_insert (constraint_edge_t, heap, graph->preds[src], \n+\t\t       place, edge);\n+      edge = new_constraint_edge (src);\n+\n+      place = VEC_lower_bound (constraint_edge_t, graph->succs[dest],\n+\t\t\t       edge, constraint_edge_less);\n+      VEC_safe_insert (constraint_edge_t, heap, graph->succs[dest], \n+\t\t       place, edge);\n+      edge_added = true;\n+      stats.num_edges++;\n+      return true;\n+    }\n+  else\n+    return false;\n+}\n+\n+\n+/* Return the bitmap representing the weights of edge (SRC, DEST).  */\n+\n+static bitmap *\n+get_graph_weights (constraint_graph_t graph, unsigned int src,\n+\t\t   unsigned int dest)\n+{\n+  constraint_edge_t edge;\n+  VEC(constraint_edge_t,heap) *vec;\n+  struct constraint_edge lookfor;\n+\n+  lookfor.dest = dest;\n+\n+  vec = graph->preds[src];\n+  edge = constraint_edge_vec_find (vec, lookfor);\n+  gcc_assert (edge != NULL);\n+  return &edge->weights;\n+}\n+\n+/* Allocate graph weight bitmap for the edges associated with SRC and\n+   DEST in GRAPH.  Both the pred and the succ edges share a single\n+   bitmap, so we need to set both edges to that bitmap.  */\n+\n+static bitmap\n+allocate_graph_weights (constraint_graph_t graph, unsigned int src, \n+\t\t\tunsigned int dest)\n+{\n+  bitmap result;\n+  constraint_edge_t edge;\n+  VEC(constraint_edge_t,heap) *vec;\n+  struct constraint_edge lookfor;\n+  \n+  result = BITMAP_ALLOC (&ptabitmap_obstack);\n+\n+  /* Set the pred weight.  */\n+  lookfor.dest = dest;\n+  vec = graph->preds[src];\n+  edge = constraint_edge_vec_find (vec, lookfor);\n+  gcc_assert (edge != NULL);\n+  edge->weights = result;\n+\n+  /* Set the succ weight.  */  \n+  lookfor.dest = src;\n+  vec = graph->succs[dest];\n+  edge = constraint_edge_vec_find (vec, lookfor);\n+  gcc_assert (edge != NULL);\n+  edge->weights = result;\n+  \n+  return result;  \n+}\n+\n \n /* Merge GRAPH nodes FROM and TO into node TO.  */\n \n static void\n merge_graph_nodes (constraint_graph_t graph, unsigned int to, \n \t\t   unsigned int from)\n {\n+  VEC(constraint_edge_t,heap) *succvec = graph->succs[from];\n+  VEC(constraint_edge_t,heap) *predvec = graph->preds[from];\n+  int i;\n+  constraint_edge_t c;\n   unsigned int j;\n   bitmap_iterator bi;\n \n-  /* Merge all the predecessor edges.  */\n-  if (graph->preds[from])\n+  /* Merge all the zero weighted predecessor edges.  */\n+  if (graph->zero_weight_preds[from])\n     {\n-      if (!graph->preds[to])\n-\tgraph->preds[to] = BITMAP_ALLOC (&predbitmap_obstack);\n+      if (!graph->zero_weight_preds[to])\n+\tgraph->zero_weight_preds[to] = BITMAP_ALLOC (&predbitmap_obstack);\n       \n-      EXECUTE_IF_SET_IN_BITMAP (graph->preds[from], 0, j, bi)\n+      EXECUTE_IF_SET_IN_BITMAP (graph->zero_weight_preds[from], 0, j, bi)\n \t{\n \t  if (j != to)\n \t    {\n-\t      bitmap_clear_bit (graph->succs[j], from);\n-\t      bitmap_set_bit (graph->succs[j], to);\n+\t      bitmap_clear_bit (graph->zero_weight_succs[j], from);\n+\t      bitmap_set_bit (graph->zero_weight_succs[j], to);\n \t    }\n \t}\n-      bitmap_ior_into (graph->preds[to], \n-\t\t       graph->preds[from]);\n+      bitmap_ior_into (graph->zero_weight_preds[to], \n+\t\t       graph->zero_weight_preds[from]);\n     }\n \n-  /* Merge all the successor edges.  */\n-  if (graph->succs[from])\n+  /* Merge all the zero weighted successor edges.  */\n+  if (graph->zero_weight_succs[from])\n     {\n-      if (!graph->succs[to])\n-\tgraph->succs[to] = BITMAP_ALLOC (&ptabitmap_obstack);\n-      EXECUTE_IF_SET_IN_BITMAP (graph->succs[from], 0, j, bi)\n+      if (!graph->zero_weight_succs[to])\n+\tgraph->zero_weight_succs[to] = BITMAP_ALLOC (&ptabitmap_obstack);\n+      EXECUTE_IF_SET_IN_BITMAP (graph->zero_weight_succs[from], 0, j, bi)\n+\t{\n+\t  bitmap_clear_bit (graph->zero_weight_preds[j], from);\n+\t  bitmap_set_bit (graph->zero_weight_preds[j], to);\n+\t}\n+      bitmap_ior_into (graph->zero_weight_succs[to], \n+\t\t       graph->zero_weight_succs[from]);\n+    }\n+\n+  /* Merge all the nonzero weighted predecessor edges.  */\n+  for (i = 0; VEC_iterate (constraint_edge_t, predvec, i, c); i++)\n+    {\n+      unsigned int d = c->dest;\n+      bitmap temp;\n+      bitmap *weights;\n+\n+      if (c->dest == from)\n+\td = to;\n+\n+      add_graph_edge (graph, to, d);\n+\n+      temp = *(get_graph_weights (graph, from, c->dest));      \n+      if (temp)\n \t{\n-\t  bitmap_clear_bit (graph->preds[j], from);\n-\t  bitmap_set_bit (graph->preds[j], to);\n+\t  weights = get_graph_weights (graph, to, d);\n+\t  if (!*weights)\n+\t    *weights = allocate_graph_weights (graph, to, d);\n+\t  \n+\t  bitmap_ior_into (*weights, temp);\n \t}\n-      bitmap_ior_into (graph->succs[to], \n-\t\t       graph->succs[from]);\n+      \n     }\n+  \n+  /* Merge all the nonzero weighted successor edges.  */\n+  for (i = 0; VEC_iterate (constraint_edge_t, succvec, i, c); i++)\n+    {\n+      unsigned int d = c->dest;\n+      bitmap temp;\n+      bitmap *weights;\n+\n+      if (c->dest == from)\n+\td = to;\n \n+      add_graph_edge (graph, d, to);\n+\n+      temp = *(get_graph_weights (graph, c->dest, from));\n+      if (temp)\n+\t{\n+\t  weights = get_graph_weights (graph, d, to);\n+\t  if (!*weights)\n+\t    *weights = allocate_graph_weights (graph, d, to);\n+\t  bitmap_ior_into (*weights, temp);\n+\t}\n+    }\n   clear_edges_for_node (graph, from);\n }\n \n-/* Add a graph edge to GRAPH, going from TO to FROM if\n+/* Add a graph edge to GRAPH, going from TO to FROM, with WEIGHT, if\n    it doesn't exist in the graph already.\n    Return false if the edge already existed, true otherwise.  */\n \n static bool\n-add_graph_edge (constraint_graph_t graph, unsigned int to,\n-\t\tunsigned int from)\n+int_add_graph_edge (constraint_graph_t graph, unsigned int to, \n+\t\t    unsigned int from, unsigned HOST_WIDE_INT weight)\n {\n-  if (to == from)\n+  if (to == from && weight == 0)\n     {\n       return false;\n     }\n   else\n     {\n       bool r = false;\n-      \n-      if (!graph->preds[to])\n-\tgraph->preds[to] = BITMAP_ALLOC (&predbitmap_obstack);\n-      if (!graph->succs[from])\n-\tgraph->succs[from] = BITMAP_ALLOC (&ptabitmap_obstack);\n-      if (!bitmap_bit_p (graph->succs[from], to))\n+\n+      if (weight == 0)\n \t{\n-\t  edge_added = true;\n-\t  r = true;\n-\t  stats.num_edges++;\n-\t  bitmap_set_bit (graph->preds[to], from);\n-\t  bitmap_set_bit (graph->succs[from], to);\n+          if (!graph->zero_weight_preds[to])\n+\t    graph->zero_weight_preds[to] = BITMAP_ALLOC (&predbitmap_obstack);\n+          if (!graph->zero_weight_succs[from])\n+\t    graph->zero_weight_succs[from] = BITMAP_ALLOC (&ptabitmap_obstack);\n+\t  if (!bitmap_bit_p (graph->zero_weight_succs[from], to))\n+\t    {\n+\t      edge_added = true;\n+\t      r = true;\n+\t      stats.num_edges++;\n+\t      bitmap_set_bit (graph->zero_weight_preds[to], from);\n+\t      bitmap_set_bit (graph->zero_weight_succs[from], to);\n+\t    }\n \t}\n+      else\n+\t{\n+\t  bitmap *weights;\n+\n+\t  r = add_graph_edge (graph, to, from);\n+\t  weights = get_graph_weights (graph, to, from);\n+\n+\t  if (!*weights)\n+\t    {\n+\t      r = true;\n+\t      *weights = allocate_graph_weights (graph, to, from);\n+\t      bitmap_set_bit (*weights, weight);\n+\t    }\n+\t  else\n+\t    {\n+\t      r |= !bitmap_bit_p (*weights, weight);\n+\t      bitmap_set_bit (*weights, weight);\n+\t    }\n+\t}\n+      \n       return r;\n     }\n }\n@@ -859,10 +1171,28 @@ static bool\n valid_graph_edge (constraint_graph_t graph, unsigned int src, \n \t\t  unsigned int dest)\n {\n-  return (graph->succs[dest] \n-\t  && bitmap_bit_p (graph->succs[dest], src));\n+  struct constraint_edge lookfor;\n+  lookfor.dest = src;\n+  \n+  return (graph->zero_weight_succs[dest] \n+      && bitmap_bit_p (graph->zero_weight_succs[dest], src)) \n+    || constraint_edge_vec_find (graph->succs[dest], lookfor) != NULL;\n }\n \n+/* Return true if {DEST, SRC} is an existing weighted graph edge (IE has\n+   a weight other than 0) in GRAPH.  */\n+static bool\n+valid_weighted_graph_edge (constraint_graph_t graph, unsigned int src, \n+\t\t\t   unsigned int dest)\n+{\n+  struct constraint_edge lookfor;\n+  lookfor.dest = src;\n+  \n+  return graph->preds[src] \n+    && constraint_edge_vec_find (graph->succs[dest], lookfor) != NULL;\n+}\n+\n+\n /* Build the constraint graph.  */\n \n static void\n@@ -873,8 +1203,10 @@ build_constraint_graph (void)\n \n   graph = XNEW (struct constraint_graph);\n   graph_size = VEC_length (varinfo_t, varmap) + 1;\n-  graph->succs = XCNEWVEC (bitmap, graph_size);\n-  graph->preds = XCNEWVEC (bitmap, graph_size);\n+  graph->succs = XCNEWVEC (VEC(constraint_edge_t,heap) *, graph_size);\n+  graph->preds = XCNEWVEC (VEC(constraint_edge_t,heap) *, graph_size);\n+  graph->zero_weight_succs = XCNEWVEC (bitmap, graph_size);\n+  graph->zero_weight_preds = XCNEWVEC (bitmap, graph_size);\n \n   for (i = 0; VEC_iterate (constraint_t, constraints, i, c); i++)\n     {\n@@ -902,14 +1234,12 @@ build_constraint_graph (void)\n \t}\n       else if (lhsvar > anything_id)\n \t{\n-\t  /* Ignore self edges, as they can't possibly contribute\n+\t  /* Ignore 0 weighted self edges, as they can't possibly contribute\n \t     anything */\n \t  if (lhsvar != rhsvar || rhs.offset != 0 || lhs.offset != 0)\n \t    {\n-\t      if (rhs.offset != 0 || lhs.offset != 0)\n-\t\tinsert_into_complex (lhsvar, c);\n-\t      else\n-\t\tadd_graph_edge (graph, lhs.var, rhs.var);\n+\t      /* x = y (simple) */\n+\t      int_add_graph_edge (graph, lhs.var, rhs.var, rhs.offset);\n \t    }\n \t  \n \t}\n@@ -961,7 +1291,7 @@ scc_visit (constraint_graph_t graph, struct scc_info *si, unsigned int n)\n   si->visited_index[n] = si->current_index ++;\n   \n   /* Visit all the successors.  */\n-  EXECUTE_IF_IN_NONNULL_BITMAP (graph->succs[n], 0, i, bi)\n+  EXECUTE_IF_IN_NONNULL_BITMAP (graph->zero_weight_succs[n], 0, i, bi)\n     {\n       unsigned int w = i;\n       if (!TEST_BIT (si->visited, w))\n@@ -1010,10 +1340,16 @@ collapse_nodes (constraint_graph_t graph, unsigned int to, unsigned int from)\n \n   if (valid_graph_edge (graph, to, to))\n     {\n-      if (graph->preds[to])\n+      if (graph->zero_weight_preds[to])\n+\t{\n+\t  bitmap_clear_bit (graph->zero_weight_preds[to], to);\n+\t  bitmap_clear_bit (graph->zero_weight_succs[to], to);\n+\t}\n+      if (valid_weighted_graph_edge (graph, to, to))\n \t{\n-\t  bitmap_clear_bit (graph->preds[to], to);\n-\t  bitmap_clear_bit (graph->succs[to], to);\n+\t  bitmap weights = *(get_graph_weights (graph, to, to));\n+\t  if (!weights || bitmap_empty_p (weights))\n+\t    erase_graph_self_edge (graph, to);\n \t}\n     }\n   BITMAP_FREE (fromsol);\n@@ -1058,7 +1394,7 @@ process_unification_queue (constraint_graph_t graph, struct scc_info *si,\n \tMerge tmp into solution for rep, marking rep changed if this\n \tchanged rep's solution.\n \t\n-\tDelete any self-edges we now have for rep.  */\n+\tDelete any 0 weighted self-edges we now have for rep.  */\n   while (i != VEC_length (unsigned, si->unification_queue))\n     {\n       unsigned int tounify = VEC_index (unsigned, si->unification_queue, i);\n@@ -1111,11 +1447,17 @@ process_unification_queue (constraint_graph_t graph, struct scc_info *si,\n \n \t  if (valid_graph_edge (graph, n, n))\n \t    {\n-\t      if (graph->succs[n])\n+\t      if (graph->zero_weight_succs[n])\n \t\t{\n-\t\t  if (graph->preds[n])\n-\t\t    bitmap_clear_bit (graph->preds[n], n);\n-\t\t  bitmap_clear_bit (graph->succs[n], n);\n+\t\t  if (graph->zero_weight_preds[n])\n+\t\t    bitmap_clear_bit (graph->zero_weight_preds[n], n);\n+\t\t  bitmap_clear_bit (graph->zero_weight_succs[n], n);\n+\t\t}\n+\t      if (valid_weighted_graph_edge (graph, n, n))\n+\t\t{\n+\t\t  bitmap weights = *(get_graph_weights (graph, n, n));\n+\t\t  if (!weights || bitmap_empty_p (weights))\n+\t\t    erase_graph_self_edge (graph, n);\n \t\t}\n \t    }\n \t}\n@@ -1167,12 +1509,24 @@ static void\n topo_visit (constraint_graph_t graph, struct topo_info *ti,\n \t    unsigned int n)\n {\n+  VEC(constraint_edge_t,heap) *succs = graph->succs[n];\n   bitmap temp;\n   bitmap_iterator bi;\n+  constraint_edge_t c;\n+  int i;\n   unsigned int j;\n \n   SET_BIT (ti->visited, n);\n-  temp = graph->succs[n];\n+  if (VEC_length (constraint_edge_t, succs) != 0)\n+    {\n+      temp = BITMAP_ALLOC (&iteration_obstack);\n+      if (graph->zero_weight_succs[n])\n+\tbitmap_ior_into (temp, graph->zero_weight_succs[n]);\n+      for (i = 0; VEC_iterate (constraint_edge_t, succs, i, c); i++)\n+\tbitmap_set_bit (temp, c->dest);\n+    }\n+  else \n+    temp = graph->zero_weight_succs[n];\n \n   if (temp) \n     EXECUTE_IF_SET_IN_BITMAP (temp, 0, j, bi)\n@@ -1286,7 +1640,7 @@ do_sd_constraint (constraint_graph_t graph, constraint_t c,\n \t     They don't have sets that can change.  */\n \t  if (get_varinfo (t) ->is_special_var)\n \t    flag |= bitmap_ior_into (sol, get_varinfo (t)->solution);\n-\t  else if (add_graph_edge (graph, lhs, t))\n+\t  else if (int_add_graph_edge (graph, lhs, t, 0))\n \t    flag |= bitmap_ior_into (sol, get_varinfo (t)->solution);\n \t}\n       else if (0 && dump_file && !(get_varinfo (j)->is_special_var))\n@@ -1310,7 +1664,7 @@ do_sd_constraint (constraint_graph_t graph, constraint_t c,\n /* Process a constraint C that represents *x = y.  */\n \n static void\n-do_ds_constraint (constraint_t c, bitmap delta)\n+do_ds_constraint (constraint_graph_t graph, constraint_t c, bitmap delta)\n {\n   unsigned int rhs = get_varinfo (c->rhs.var)->node;\n   unsigned HOST_WIDE_INT roff = c->rhs.offset;\n@@ -1356,26 +1710,27 @@ do_ds_constraint (constraint_t c, bitmap delta)\n \t  varinfo_t v;\n \t  unsigned int t;\n \t  unsigned HOST_WIDE_INT fieldoffset = get_varinfo (j)->offset + loff;\n-\t  bitmap tmp;\n-\t  \n+\n \t  v = first_vi_for_offset (get_varinfo (j), fieldoffset);\n \t  if (!v)\n \t    continue;\n \t  t = v->node;\n-\t  tmp = get_varinfo (t)->solution;\n-\n-\t  if (set_union_with_increment (tmp, sol, roff))\n+\t  if (int_add_graph_edge (graph, t, rhs, roff))\n \t    {\n-\t      get_varinfo (t)->solution = tmp;\n-\t      if (t == rhs)\n-\t\tsol = get_varinfo (rhs)->solution;\n-\t      if (!TEST_BIT (changed, t))\n+\t      bitmap tmp = get_varinfo (t)->solution;\n+\t      if (set_union_with_increment (tmp, sol, roff))\n \t\t{\n-\t\t  SET_BIT (changed, t);\n-\t\t  changed_count++;\n+\t\t  get_varinfo (t)->solution = tmp;\n+\t\t  if (t == rhs)\n+\t\t    sol = get_varinfo (rhs)->solution;\n+\t\t  if (!TEST_BIT (changed, t))\n+\t\t    {\n+\t\t      SET_BIT (changed, t);\n+\t\t      changed_count++;\n+\t\t    }\n \t\t}\n \t    }\n-\t}\n+\t}    \n       else if (0 && dump_file && !(get_varinfo (j)->is_special_var))\n \tfprintf (dump_file, \"Untypesafe usage in do_ds_constraint\\n\");\n     }\n@@ -1397,40 +1752,15 @@ do_complex_constraint (constraint_graph_t graph, constraint_t c, bitmap delta)\n       else\n \t{\n \t  /* *x = y */\n-\t  do_ds_constraint (c, delta);\n+\t  do_ds_constraint (graph, c, delta);\n \t}\n     }\n-  else if (c->rhs.type == DEREF)\n+  else\n     {\n       /* x = *y */\n       if (!(get_varinfo (c->lhs.var)->is_special_var))\n \tdo_sd_constraint (graph, c, delta);\n     }\n-  else \n-    {\n-      bitmap tmp; \n-      bitmap solution;\n-      bool flag = false;\n-      unsigned int t;\n-\n-      gcc_assert(c->rhs.type == SCALAR && c->lhs.type == SCALAR);\n-      t = get_varinfo (c->rhs.var)->node;\n-      solution = get_varinfo (t)->solution;\n-      t = get_varinfo (c->lhs.var)->node;\n-      tmp = get_varinfo (t)->solution;\n-\n-      flag = set_union_with_increment (tmp, solution, c->rhs.offset);\n-      \n-      if (flag)\n-\t{\n-\t  get_varinfo (t)->solution = tmp;\n-\t  if (!TEST_BIT (changed, c->lhs.var))\n-\t    {\n-\t      SET_BIT (changed, c->lhs.var);\n-\t      changed_count++;\n-\t    }\n-\t}\n-    }\n }\n \n /* Initialize and return a new SCC info structure.  */\n@@ -1501,6 +1831,21 @@ compute_topo_order (constraint_graph_t graph,\n       topo_visit (graph, ti, i);\n }\n \n+/* Return true if bitmap B is empty, or a bitmap other than bit 0 is set. */\n+\n+static bool\n+bitmap_other_than_zero_bit_set (bitmap b)\n+{\n+  unsigned int i;\n+  bitmap_iterator bi;\n+\n+  if (bitmap_empty_p (b))\n+    return false;\n+  EXECUTE_IF_SET_IN_BITMAP (b, 1, i, bi)\n+    return true;\n+  return false;\n+}\n+\n /* Perform offline variable substitution.\n    \n    This is a linear time way of identifying variables that must have\n@@ -1524,9 +1869,12 @@ perform_var_substitution (constraint_graph_t graph)\n   while (VEC_length (unsigned, ti->topo_order) != 0)\n     {\n       unsigned int i = VEC_pop (unsigned, ti->topo_order);\n+      unsigned int pred;\n       varinfo_t vi = get_varinfo (i);\n       bool okay_to_elim = false;\n       unsigned int root = VEC_length (varinfo_t, varmap);\n+      VEC(constraint_edge_t,heap) *predvec = graph->preds[i];\n+      constraint_edge_t ce = NULL;\n       bitmap tmp;\n       unsigned int k;\n       bitmap_iterator bi;\n@@ -1537,7 +1885,7 @@ perform_var_substitution (constraint_graph_t graph)\n \tcontinue;\n \n       /* See if all predecessors of I are ripe for elimination */\n-      EXECUTE_IF_IN_NONNULL_BITMAP (graph->preds[i], 0, k, bi)\n+      EXECUTE_IF_IN_NONNULL_BITMAP (graph->zero_weight_preds[i], 0, k, bi)\n \t  {\n \t    unsigned int w;\n \t    w = get_varinfo (k)->node;\n@@ -1573,6 +1921,55 @@ perform_var_substitution (constraint_graph_t graph)\n \t    BITMAP_FREE (tmp);\n \t  }\n \n+      if (okay_to_elim)\n+\tfor (pred = 0; \n+\t     VEC_iterate (constraint_edge_t, predvec, pred, ce); \n+\t     pred++)\n+\t  {\n+\t    bitmap weight;\n+\t    unsigned int w;\n+\t    weight = *(get_graph_weights (graph, i, ce->dest));\n+\n+\t    /* We can't eliminate variables that have nonzero weighted\n+\t       edges between them.  */\n+\t    if (weight && bitmap_other_than_zero_bit_set (weight))\n+\t      {\n+\t\tokay_to_elim = false;\n+\t\tbreak;\n+\t      }\n+\t    w = get_varinfo (ce->dest)->node;\n+\n+\t    /* We can't eliminate the node if one of the predecessors is\n+\t       part of a different strongly connected component.  */\n+\t    if (!okay_to_elim)\n+\t      {\n+\t\troot = w;\n+\t\tokay_to_elim = true;\n+\t      }\n+\t    else if (w != root)\n+\t      {\n+\t\tokay_to_elim = false;\n+\t\tbreak;\n+\t      }\n+\n+\t    /* Theorem 4 in Rountev and Chandra: If i is a direct node,\n+\t       then Solution(i) is a subset of Solution (w), where w is a\n+\t       predecessor in the graph.  \n+\t       Corollary: If all predecessors of i have the same\n+\t       points-to set, then i has that same points-to set as\n+\t       those predecessors.  */\n+\t    tmp = BITMAP_ALLOC (NULL);\n+\t    bitmap_and_compl (tmp, get_varinfo (i)->solution,\n+\t\t\t      get_varinfo (w)->solution);\n+\t    if (!bitmap_empty_p (tmp))\n+\t      {\n+\t\tokay_to_elim = false;\n+\t\tBITMAP_FREE (tmp);\n+\t\tbreak;\n+\t      }\n+\t    BITMAP_FREE (tmp);\n+\t  }\n+\n       /* See if the root is different than the original node. \n \t If so, we've found an equivalence.  */\n       if (root != get_varinfo (i)->node && okay_to_elim)\n@@ -1647,9 +2044,11 @@ solve_graph (constraint_graph_t graph)\n \t    {\n \t      unsigned int j;\n \t      constraint_t c;\n+\t      constraint_edge_t e = NULL;\n \t      bitmap solution;\n \t      bitmap_iterator bi;\n \t      VEC(constraint_t,heap) *complex = get_varinfo (i)->complex;\n+\t      VEC(constraint_edge_t,heap) *succs;\n \t      bool solution_empty;\n \n \t      RESET_BIT (changed, i);\n@@ -1674,14 +2073,14 @@ solve_graph (constraint_graph_t graph)\n \t      if (!solution_empty)\n \t\t{\n \t\t  /* Propagate solution to all successors.  */\n-\t\t  EXECUTE_IF_IN_NONNULL_BITMAP (graph->succs[i], \n+\t\t  succs = graph->succs[i];\n+\t\t  \n+\t\t  EXECUTE_IF_IN_NONNULL_BITMAP (graph->zero_weight_succs[i], \n \t\t\t\t\t\t0, j, bi)\n \t\t    {\n \t\t      bitmap tmp = get_varinfo (j)->solution;\n \t\t      bool flag = false;\n \t\t  \n-\t\t      gcc_assert (get_varinfo (j)->node == j);\n-\t\t      \n \t\t      flag = set_union_with_increment (tmp, solution, 0);\n \t\t  \n \t\t      if (flag)\n@@ -1694,13 +2093,35 @@ solve_graph (constraint_graph_t graph)\n \t\t\t    }\n \t\t\t}\n \t\t    }\n+\t\t  for (j = 0; VEC_iterate (constraint_edge_t, succs, j, e); j++)\n+\t\t    {\n+\t\t      bitmap tmp = get_varinfo (e->dest)->solution;\n+\t\t      bool flag = false;\n+\t\t      unsigned int k;\n+\t\t      bitmap weights = e->weights;\n+\t\t      bitmap_iterator bi;\n+\n+\t\t      gcc_assert (weights && !bitmap_empty_p (weights));\n+\t\t      EXECUTE_IF_SET_IN_BITMAP (weights, 0, k, bi)\n+\t\t\tflag |= set_union_with_increment (tmp, solution, k);\n+\n+\t\t      if (flag)\n+\t\t\t{\n+\t\t\t  get_varinfo (e->dest)->solution = tmp;\n+\t\t\t  if (!TEST_BIT (changed, e->dest))\n+\t\t\t    {\n+\t\t\t      SET_BIT (changed, e->dest);\n+\t\t\t      changed_count++;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n \t\t}\n \t    }\n \t}\n       free_topo_info (ti);\n       bitmap_obstack_release (&iteration_obstack);\n     }\n-  \n+\n   sbitmap_free (changed);\n }\n \n@@ -4246,6 +4667,9 @@ init_alias_vars (void)\n \t\t\t\t       sizeof (struct constraint), 30);\n   variable_info_pool = create_alloc_pool (\"Variable info pool\",\n \t\t\t\t\t  sizeof (struct variable_info), 30);\n+  constraint_edge_pool = create_alloc_pool (\"Constraint edges\",\n+\t\t\t\t\t    sizeof (struct constraint_edge), 30);\n+  \n   constraints = VEC_alloc (constraint_t, heap, 8);\n   varmap = VEC_alloc (varinfo_t, heap, 8);\n   id_for_tree = htab_create (10, tree_id_hash, tree_id_eq, free);\n@@ -4449,15 +4873,21 @@ delete_points_to_sets (void)\n       if (i >= graph_size)\n \tbreak;\n \n+      VEC_free (constraint_edge_t, heap, graph->succs[i]);\n+      VEC_free (constraint_edge_t, heap, graph->preds[i]);\n       VEC_free (constraint_t, heap, v->complex);\n     }\n-  free (graph->preds);\n+  free (graph->zero_weight_preds);\n+  free (graph->zero_weight_succs);\n   free (graph->succs);\n+  free (graph->preds);\n   free (graph);\n \n   VEC_free (varinfo_t, heap, varmap);\n   free_alloc_pool (variable_info_pool);\n   free_alloc_pool (constraint_pool); \n+  free_alloc_pool (constraint_edge_pool);\n+\n   have_alias_info = false;\n }\n "}]}