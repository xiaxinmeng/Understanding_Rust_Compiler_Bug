{"sha": "51cd6b78eedaefec65059f7a8cbca1f2b9bf4878", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTFjZDZiNzhlZWRhZWZlYzY1MDU5ZjdhOGNiY2ExZjJiOWJmNDg3OA==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2017-05-19T15:48:35Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2017-05-19T15:48:35Z"}, "message": "[multiple changes]\n\n2017-05-19  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/80333\n\t* trans-io.c (nml_get_addr_expr): If we are dealing with class\n\ttype data set tmp tree to get that address.\n\t(transfer_namelist_element): Set the array spec to point to the\n\tthe class data.\n\n2017-05-19  Paul Thomas  <pault@gcc.gnu.org>\n\t    Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR fortran/80333\n\t* list_read.c (nml_read_obj): Compute pointer into class/type\n\tarrays from the nl->dim information. Update it for each iteration\n\tof the loop for the given object.\n\n2017-05-19  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR libgfortran/80333\n\t* gfortran.dg/dtio_30.f03: New test.\n\nFrom-SVN: r248293", "tree": {"sha": "908bf66366979aea047bb5cdb52160fd2e75d187", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/908bf66366979aea047bb5cdb52160fd2e75d187"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51cd6b78eedaefec65059f7a8cbca1f2b9bf4878", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51cd6b78eedaefec65059f7a8cbca1f2b9bf4878", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51cd6b78eedaefec65059f7a8cbca1f2b9bf4878", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51cd6b78eedaefec65059f7a8cbca1f2b9bf4878/comments", "author": null, "committer": null, "parents": [{"sha": "33f8c0a14da482bc7884e5f663615a3d7fd08cff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33f8c0a14da482bc7884e5f663615a3d7fd08cff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33f8c0a14da482bc7884e5f663615a3d7fd08cff"}], "stats": {"total": 131, "additions": 120, "deletions": 11}, "files": [{"sha": "76418d94948b34a5c78995cea8ddf8efe4960d30", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51cd6b78eedaefec65059f7a8cbca1f2b9bf4878/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51cd6b78eedaefec65059f7a8cbca1f2b9bf4878/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=51cd6b78eedaefec65059f7a8cbca1f2b9bf4878", "patch": "@@ -1,3 +1,11 @@\n+2017-05-19  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/80333\n+\t* trans-io.c (nml_get_addr_expr): If we are dealing with class\n+\ttype data set tmp tree to get that address.\n+\t(transfer_namelist_element): Set the array spec to point to the\n+\tthe class data.\n+\n 2017-05-19  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR fortran/79852"}, {"sha": "c3c56f296238ed6ed4724d32e5bdc6f34eb80822", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51cd6b78eedaefec65059f7a8cbca1f2b9bf4878/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51cd6b78eedaefec65059f7a8cbca1f2b9bf4878/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=51cd6b78eedaefec65059f7a8cbca1f2b9bf4878", "patch": "@@ -1613,6 +1613,10 @@ nml_get_addr_expr (gfc_symbol * sym, gfc_component * c,\n     tmp = fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (tmp),\n \t\t\t   base_addr, tmp, NULL_TREE);\n \n+  if (GFC_CLASS_TYPE_P (TREE_TYPE (tmp))\n+      && GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (gfc_class_data_get (tmp))))\n+    tmp = gfc_class_data_get (tmp);\n+\n   if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (tmp)))\n     tmp = gfc_conv_array_data (tmp);\n   else\n@@ -1670,8 +1674,12 @@ transfer_namelist_element (stmtblock_t * block, const char * var_name,\n \n   /* Build ts, as and data address using symbol or component.  */\n \n-  ts = (sym) ? &sym->ts : &c->ts;\n-  as = (sym) ? sym->as : c->as;\n+  ts = sym ? &sym->ts : &c->ts;\n+\n+  if (ts->type != BT_CLASS)\n+    as = sym ? sym->as : c->as;\n+  else\n+    as = sym ? CLASS_DATA (sym)->as : CLASS_DATA (c)->as;\n \n   addr_expr = nml_get_addr_expr (sym, c, base_addr);\n \n@@ -1680,9 +1688,12 @@ transfer_namelist_element (stmtblock_t * block, const char * var_name,\n \n   if (rank)\n     {\n-      decl = (sym) ? sym->backend_decl : c->backend_decl;\n+      decl = sym ? sym->backend_decl : c->backend_decl;\n       if (sym && sym->attr.dummy)\n         decl = build_fold_indirect_ref_loc (input_location, decl);\n+\n+      if (ts->type == BT_CLASS)\n+\tdecl = gfc_class_data_get (decl);\n       dt =  TREE_TYPE (decl);\n       dtype = gfc_get_dtype (dt);\n     }"}, {"sha": "fb4b1bd2db07705ec09fa4e18abd68001f6c32ad", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51cd6b78eedaefec65059f7a8cbca1f2b9bf4878/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51cd6b78eedaefec65059f7a8cbca1f2b9bf4878/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=51cd6b78eedaefec65059f7a8cbca1f2b9bf4878", "patch": "@@ -1,3 +1,8 @@\n+2017-05-19  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR libgfortran/80333\n+\t* gfortran.dg/dtio_30.f03: New test.\n+\n 2017-05-19  Marek Polacek  <polacek@redhat.com>\n \n \tPR sanitizer/80800"}, {"sha": "9edc8f3878d8e7b6795abe2ca1cf06198e4887dc", "filename": "gcc/testsuite/gfortran.dg/dtio_30.f03", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51cd6b78eedaefec65059f7a8cbca1f2b9bf4878/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_30.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51cd6b78eedaefec65059f7a8cbca1f2b9bf4878/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_30.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_30.f03?ref=51cd6b78eedaefec65059f7a8cbca1f2b9bf4878", "patch": "@@ -0,0 +1,60 @@\n+! { dg-do run }\n+! PR80333  Namelist dtio write of array of class does not traverse the array\n+! This test checks both NAMELIST WRITE and READ of an array of class\n+module m\n+  implicit none\n+  type :: t\n+    character :: c\n+    character :: d\n+  contains\n+    procedure :: read_formatted\n+    generic :: read(formatted) => read_formatted\n+    procedure :: write_formatted\n+    generic :: write(formatted) => write_formatted\n+  end type t\n+contains\n+  subroutine read_formatted(dtv, unit, iotype, v_list, iostat, iomsg)\n+    class(t), intent(inout) :: dtv\n+    integer, intent(in) :: unit\n+    character(*), intent(in) :: iotype\n+    integer, intent(in) :: v_list(:)\n+    integer, intent(out) :: iostat\n+    character(*), intent(inout) :: iomsg\n+    integer :: i\n+    read(unit,'(a1,a1)', iostat=iostat, iomsg=iomsg) dtv%c, dtv%d\n+  end subroutine read_formatted\n+\n+  subroutine write_formatted(dtv, unit, iotype, v_list, iostat, iomsg)\n+    class(t), intent(in) :: dtv\n+    integer, intent(in) :: unit\n+    character(*), intent(in) :: iotype\n+    integer, intent(in) :: v_list(:)\n+    integer, intent(out) :: iostat\n+    character(*), intent(inout) :: iomsg\n+    write(unit,'(a1,a1)', iostat=iostat, iomsg=iomsg) dtv%c, dtv%d\n+  end subroutine write_formatted\n+end module m\n+\n+program p\n+  use m\n+  implicit none\n+  class(t), dimension(:,:), allocatable :: w\n+  namelist /nml/  w\n+  integer :: unit, iostatus\n+  character(256) :: str = \"\"\n+\n+  open(10, status='scratch')\n+  allocate(w(10,3))\n+  w = t('j','r')\n+  w(5:7,2)%c='k'\n+  write(10, nml)\n+  rewind(10)\n+  w = t('p','z')\n+  read(10, nml)\n+  write(str,*) w\n+  if (str.ne.\" jr jr jr jr jr jr jr jr jr jr jr jr jr jr kr kr kr jr jr jr jr jr jr jr jr jr jr jr jr jr\") &\n+      & call abort\n+  str = \"\"\n+  write(str,\"(*(DT))\") w\n+  if (str.ne.\"jrjrjrjrjrjrjrjrjrjrjrjrjrjrkrkrkrjrjrjrjrjrjrjrjrjrjrjrjrjr\") call abort\n+end program p"}, {"sha": "4ada8b8074a5a696ff070afc61b63f7eab440486", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51cd6b78eedaefec65059f7a8cbca1f2b9bf4878/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51cd6b78eedaefec65059f7a8cbca1f2b9bf4878/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=51cd6b78eedaefec65059f7a8cbca1f2b9bf4878", "patch": "@@ -1,3 +1,11 @@\n+2017-05-19  Paul Thomas  <pault@gcc.gnu.org>\n+\t    Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR fortran/80333\n+\t* list_read.c (nml_read_obj): Compute pointer into class/type\n+\tarrays from the nl->dim information. Update it for each iteration\n+\tof the loop for the given object.\n+\n 2017-05-17  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/80741"}, {"sha": "6c00d11bf0537379074134876c4dae947cc944e1", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51cd6b78eedaefec65059f7a8cbca1f2b9bf4878/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51cd6b78eedaefec65059f7a8cbca1f2b9bf4878/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=51cd6b78eedaefec65059f7a8cbca1f2b9bf4878", "patch": "@@ -2871,6 +2871,7 @@ nml_read_obj (st_parameter_dt *dtp, namelist_info *nl, index_type offset,\n   index_type m;\n   size_t obj_name_len;\n   void *pdata;\n+  gfc_class list_obj;\n \n   /* If we have encountered a previous read error or this object has not been\n      touched in name parsing, just return.  */\n@@ -2909,11 +2910,28 @@ nml_read_obj (st_parameter_dt *dtp, namelist_info *nl, index_type offset,\n     {\n       /* Update the pointer to the data, using the current index vector  */\n \n-      pdata = (void*)(nl->mem_pos + offset);\n-      for (dim = 0; dim < nl->var_rank; dim++)\n-\tpdata = (void*)(pdata + (nl->ls[dim].idx\n-\t\t\t\t - GFC_DESCRIPTOR_LBOUND(nl,dim))\n-\t\t\t* GFC_DESCRIPTOR_STRIDE(nl,dim) * nl->size);\n+      if ((nl->type == BT_DERIVED || nl->type == BT_CLASS)\n+\t  && nl->dtio_sub != NULL)\n+\t{\n+\t  pdata = NULL;  /* Not used under these conidtions.  */\n+\t  if (nl->type == BT_CLASS)\n+\t    list_obj.data = ((gfc_class*)nl->mem_pos)->data;\n+\t  else\n+\t    list_obj.data = (void *)nl->mem_pos;\n+\n+\t  for (dim = 0; dim < nl->var_rank; dim++)\n+\t    list_obj.data = list_obj.data + (nl->ls[dim].idx\n+\t      - GFC_DESCRIPTOR_LBOUND(nl,dim))\n+\t      * GFC_DESCRIPTOR_STRIDE(nl,dim) * nl->size;\n+\t}\n+      else\n+\t{\n+\t  pdata = (void*)(nl->mem_pos + offset);\n+\t  for (dim = 0; dim < nl->var_rank; dim++)\n+\t    pdata = (void*)(pdata + (nl->ls[dim].idx\n+\t      - GFC_DESCRIPTOR_LBOUND(nl,dim))\n+\t      * GFC_DESCRIPTOR_STRIDE(nl,dim) * nl->size);\n+\t}\n \n       /* If we are finished with the repeat count, try to read next value.  */\n \n@@ -2958,6 +2976,7 @@ nml_read_obj (st_parameter_dt *dtp, namelist_info *nl, index_type offset,\n \t    break;\n \n \t  case BT_DERIVED:\n+\t  case BT_CLASS:\n \t    /* If this object has a User Defined procedure, call it.  */\n \t    if (nl->dtio_sub != NULL)\n \t      {\n@@ -2970,13 +2989,11 @@ nml_read_obj (st_parameter_dt *dtp, namelist_info *nl, index_type offset,\n \t\tint noiostat;\n \t\tint *child_iostat = NULL;\n \t\tgfc_array_i4 vlist;\n-\t\tgfc_class list_obj;\n \t\tformatted_dtio dtio_ptr = (formatted_dtio)nl->dtio_sub;\n \n \t\tGFC_DESCRIPTOR_DATA(&vlist) = NULL;\n \t\tGFC_DIMENSION_SET(vlist.dim[0],1, 0, 0);\n-\n-\t\tlist_obj.data = (void *)nl->mem_pos;\n+\t\t\n \t\tlist_obj.vptr = nl->vtable;\n \t\tlist_obj.len = 0;\n "}]}