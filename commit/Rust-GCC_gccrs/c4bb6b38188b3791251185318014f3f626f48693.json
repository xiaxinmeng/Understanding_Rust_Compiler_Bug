{"sha": "c4bb6b38188b3791251185318014f3f626f48693", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzRiYjZiMzgxODhiMzc5MTI1MTE4NTMxODAxNGYzZjYyNmY0ODY5Mw==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1996-12-31T00:14:56Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1996-12-31T00:14:56Z"}, "message": "pa.c (fmpy_operands): Remove.\n\n        * pa/pa.c (fmpy_operands): Remove.  No longer needed.\n        (combinable_add, combinable_copy, combinable_fmpy): Likewise.\n        (combinable_fadd, combineable_fsub): Likewise.\n        (pa_reorg): Call pa_combine_instructions.\n        (pa_combine_instructions): Combine instructions to make things\n        like fmpyadd and fmpysub.\n        (pa_can_combine_p): Helper function for pa_combine_instructions.\n        * pa/pa.md (pa_combine_type): New attribute.  Set it appropriately\n        for various insns.\n        (define_delays): Use a separate define_delay for unconditional\n        branches.\n        (fmpyadd, fmpysub peepholes): Remove, no longer needed.\n        (fmpyadd, fmpysub insns): Add variant with fadd/fsub first,\n        then the fmpy.\n\nFrom-SVN: r13346", "tree": {"sha": "36f0d442caccda2143017d5d7b11b6fc56d2dc7b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36f0d442caccda2143017d5d7b11b6fc56d2dc7b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c4bb6b38188b3791251185318014f3f626f48693", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4bb6b38188b3791251185318014f3f626f48693", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4bb6b38188b3791251185318014f3f626f48693", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4bb6b38188b3791251185318014f3f626f48693/comments", "author": null, "committer": null, "parents": [{"sha": "545526514b8f418dadf07bb8d4fcd49d372f93c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/545526514b8f418dadf07bb8d4fcd49d372f93c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/545526514b8f418dadf07bb8d4fcd49d372f93c7"}], "stats": {"total": 630, "additions": 331, "deletions": 299}, "files": [{"sha": "bab4a12fb7f8e264a272d6465d87f526bde67226", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 290, "deletions": 237, "changes": 527, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4bb6b38188b3791251185318014f3f626f48693/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4bb6b38188b3791251185318014f3f626f48693/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=c4bb6b38188b3791251185318014f3f626f48693", "patch": "@@ -62,14 +62,6 @@ static int out_of_line_prologue_epilogue;\n \n static rtx find_addr_reg ();\n \n-/* Kludgery.  We hold the operands to a fmpy insn here so we can\n-   compare them with the operands for an fadd/fsub to determine if\n-   they can be combined into a fmpyadd/fmpysub insn.\n-\n-   This _WILL_ disappear as the code to combine independent insns\n-   matures.  */\n-static rtx fmpy_operands[3];\n-\n /* Keep track of the number of bytes we have output in the CODE subspaces\n    during this compilation so we'll know when to emit inline long-calls.  */\n \n@@ -1347,7 +1339,7 @@ emit_move_sequence (operands, mode, scratch_reg)\n }\n \n /* Examine EXP and return nonzero if it contains an ADDR_EXPR (meaning\n-   it will need a link/runtime reloc.  */\n+   it will need a link/runtime reloc).  */\n \n int\n reloc_needed (exp)\n@@ -5484,70 +5476,6 @@ output_parallel_addb (operands, length)\n     }\n }\n \n-/* Return nonzero if INSN represents an integer add which might be\n-   combinable with an unconditional branch.  */ \n-\n-combinable_add (insn)\n-     rtx insn;\n-{\n-  rtx src, dest, prev, pattern = PATTERN (insn);\n-\n-  /* Must be a (set (reg) (plus (reg) (reg/5_bit_int)))  */\n-  if (GET_CODE (pattern) != SET\n-      || GET_CODE (SET_SRC (pattern)) != PLUS\n-      || GET_CODE (SET_DEST (pattern)) != REG)\n-    return 0;\n-\n-  src = SET_SRC (pattern);\n-  dest = SET_DEST (pattern);\n-\n-  /* Must be an integer add.  */\n-  if (GET_MODE (src) != SImode\n-      || GET_MODE (dest) != SImode)\n-    return 0;\n-\n-  /* Each operand must be an integer register and/or 5 bit immediate.  */\n-  if (!ireg_or_int5_operand (dest, VOIDmode)\n-       || !ireg_or_int5_operand (XEXP (src, 0), VOIDmode)\n-       || !ireg_or_int5_operand (XEXP (src, 1), VOIDmode))\n-    return 0;\n-\n-  /* The destination must also be one of the sources.  */\n-  return (dest == XEXP (src, 0) || dest == XEXP (src, 1));\n-}\n-\n-/* Return nonzero if INSN represents an integer load/copy which might be\n-   combinable with an unconditional branch.  */ \n-\n-combinable_copy (insn)\n-     rtx insn;\n-{\n-  rtx src, dest, pattern = PATTERN (insn);\n-  enum machine_mode mode;\n-\n-  /* Must be a (set (reg) (reg/5_bit_int)).  */\n-  if (GET_CODE (pattern) != SET)\n-    return 0;\n-\n-  src = SET_SRC (pattern);\n-  dest = SET_DEST (pattern);\n-\n-  /* Must be a mode that corresponds to a single integer register.  */\n-  mode = GET_MODE (dest);\n-  if (mode != SImode\n-      && mode != SFmode\n-      && mode != HImode\n-      && mode != QImode)\n-    return 0;\n-\n-  /* Each operand must be a register or 5 bit integer.  */\n-  if (!ireg_or_int5_operand (dest, VOIDmode)\n-      || !ireg_or_int5_operand (src, VOIDmode))\n-    return 0;\n-\n-  return 1;\n-}\n-\n /* Return nonzero if INSN (a jump insn) immediately follows a call.  This\n    is used to discourage creating parallel movb/addb insns since a jump\n    which immediately follows a call can execute in the delay slot of the\n@@ -5574,170 +5502,6 @@ following_call (insn)\n   return 0;\n }\n \n-/* Return nonzero if this is a floating point multiply (fmpy) which\n-   could be combined with a suitable floating point add or sub insn.  */\n-\n-combinable_fmpy (insn)\n-     rtx insn;\n-{\n-  rtx src, dest, pattern = PATTERN (insn);\n-  enum machine_mode mode;\n-\n-  /* Only on 1.1 and later cpus.  */\n-  if (!TARGET_SNAKE)\n-    return 0;\n-\n-  /* Must be a (set (reg) (mult (reg) (reg))).  */\n-  if (GET_CODE (pattern) != SET\n-      || GET_CODE (SET_SRC (pattern)) != MULT\n-      || GET_CODE (SET_DEST (pattern)) != REG)\n-    return 0;\n-\n-  src = SET_SRC (pattern);\n-  dest = SET_DEST (pattern);\n-\n-  /* Must be registers.  */\n-  if (GET_CODE (XEXP (src, 0)) != REG\n-      || GET_CODE (XEXP (src, 1)) != REG)\n-    return 0;\n-\n-  /* Must be a floating point mode.  Must match the mode of the fmul.  */\n-  mode = GET_MODE (dest);\n-  if (mode != DFmode && mode != SFmode)\n-    return 0;\n- \n-  /* SFmode limits the registers which can be used to the upper\n-     32 32bit FP registers.  */\n-  if (mode == SFmode\n-      && (REGNO (dest) < 57\n-\t  || REGNO (XEXP (src, 0)) < 57\n-\t  || REGNO (XEXP (src, 1)) < 57))\n-    return 0;\n-     \n-  /* Save our operands, we'll need to verify they don't conflict with\n-     those in the fadd or fsub.  XXX This needs to disasppear soon.  */\n-  fmpy_operands[0] = dest;\n-  fmpy_operands[1] = XEXP (src, 0);\n-  fmpy_operands[2] = XEXP (src, 1);\n-\n-  return 1;\n-}\n-\n-/* Return nonzero if INSN is a floating point add suitable for combining\n-   with the most recently examined floating point multiply.  */\n-\n-combinable_fadd (insn)\n-     rtx insn;\n-{\n-  rtx src, dest, pattern = PATTERN (insn);\n-  enum machine_mode mode;\n-\n-  /* Must be a (set (reg) (plus (reg) (reg))).  */\n-  if (GET_CODE (pattern) != SET\n-      || GET_CODE (SET_SRC (pattern)) != PLUS\n-      || GET_CODE (SET_DEST (pattern)) != REG)\n-    return 0;\n-\n-  src = SET_SRC (pattern);\n-  dest = SET_DEST (pattern);\n-\n-  /* Must be registers.  */\n-  if (GET_CODE (XEXP (src, 0)) != REG\n-      || GET_CODE (XEXP (src, 1)) != REG)\n-    return 0;\n-\n-  /* Must be a floating point mode.  Must match the mode of the fmul.  */\n-  mode = GET_MODE (dest);\n-  if (mode != DFmode && mode != SFmode)\n-    return 0;\n- \n-  if (mode != GET_MODE (fmpy_operands[0]))\n-    return 0;\n-\n-  /* SFmode limits the registers which can be used to the upper\n-     32 32bit FP registers.  */\n-  if (mode == SFmode\n-      && (REGNO (dest) < 57\n-\t  || REGNO (XEXP (src, 0)) < 57\n-\t  || REGNO (XEXP (src, 1)) < 57))\n-    return 0;\n-     \n-  /* Only 2 real operands to the addition.  One of the input operands\n-     must be the same as the output operand.  */\n-  if (! rtx_equal_p (dest, XEXP (src, 0))\n-      && ! rtx_equal_p (dest, XEXP (src, 1)))\n-    return 0;\n-\n-  /* Inout operand of the add can not conflict with any operands from the\n-     multiply.  */\n-  if (rtx_equal_p (dest, fmpy_operands[0])\n-      || rtx_equal_p (dest, fmpy_operands[1])\n-      || rtx_equal_p (dest, fmpy_operands[2]))\n-    return 0;\n-\n-  /* The multiply can not feed into the addition.  */\n-  if (rtx_equal_p (fmpy_operands[0], XEXP (src, 0))\n-      || rtx_equal_p (fmpy_operands[0], XEXP (src, 1)))\n-    return 0;\n-\n-  return 1;\n-}\n-\n-/* Return nonzero if INSN is a floating point sub suitable for combining\n-   with the most recently examined floating point multiply.  */\n-\n-combinable_fsub (insn)\n-     rtx insn;\n-{\n-  rtx src, dest, pattern = PATTERN (insn);\n-  enum machine_mode mode;\n-\n-  /* Must be (set (reg) (minus (reg) (reg))).  */\n-  if (GET_CODE (pattern) != SET\n-      || GET_CODE (SET_SRC (pattern)) != MINUS\n-      || GET_CODE (SET_DEST (pattern)) != REG)\n-    return 0;\n-\n-  src = SET_SRC (pattern);\n-  dest = SET_DEST (pattern);\n-\n-  if (GET_CODE (XEXP (src, 0)) != REG\n-      || GET_CODE (XEXP (src, 1)) != REG)\n-    return 0;\n-\n-  /* Must be a floating point mode.  Must match the mode of the fmul.  */\n-  mode = GET_MODE (dest);\n-  if (mode != DFmode && mode != SFmode)\n-    return 0;\n- \n-  if (mode != GET_MODE (fmpy_operands[0]))\n-    return 0;\n-\n-  /* SFmode limits the registers which can be used to the upper\n-     32 32bit FP registers.  */\n-  if (mode == SFmode && (REGNO (dest) < 57 || REGNO (XEXP (src, 1)) < 57))\n-    return 0;\n-     \n-  /* Only 2 real operands to the subtraction.  Output must be the\n-     same as the first operand of the MINUS.  */\n-  if (! rtx_equal_p (dest, XEXP (src, 0)))\n-    return 0;\n-\n-  /* Inout operand of the sub can not conflict with any operands from the\n-     multiply.  */\n-  if (rtx_equal_p (dest, fmpy_operands[0])\n-      || rtx_equal_p (dest, fmpy_operands[1])\n-      || rtx_equal_p (dest, fmpy_operands[2]))\n-    return 0;\n-\n-  /* The multiply can not feed into the subtraction.  */\n-  if (rtx_equal_p (fmpy_operands[0], XEXP (src, 0))\n-      || rtx_equal_p (fmpy_operands[0], XEXP (src, 1)))\n-    return 0;\n-\n-  return 1;\n-}\n-\n /* We use this hook to perform a PA specific optimization which is difficult\n    to do in earlier passes.\n \n@@ -5771,6 +5535,8 @@ pa_reorg (insns)\n \n   remove_useless_addtr_insns (insns, 1);\n \n+  pa_combine_instructions (get_insns ());\n+\n   /* This is fairly cheap, so always run it if optimizing.  */\n   if (optimize > 0)\n     {\n@@ -5840,3 +5606,290 @@ pa_reorg (insns)\n \t}\n     }\n }\n+\n+/* The PA has a number of odd instructions which can perform multiple\n+   tasks at once.  On first generation PA machines (PA1.0 and PA1.1)\n+   it may be profitable to combine two instructions into one instruction\n+   with two outputs.  It's not profitable PA2.0 machines because the\n+   two outputs would take two slots in the reorder buffers.\n+\n+   This routine finds instructions which can be combined and combines\n+   them.  We only support some of the potential combinations, and we\n+   only try common ways to find suitable instructions.\n+\n+      * addb can add two registers or a register and a small integer\n+      and jump to a nearby (+-8k) location.  Normally the jump to the\n+      nearby location is conditional on the result of the add, but by\n+      using the \"true\" condition we can make the jump unconditional.\n+      Thus addb can perform two independent operations in one insn.\n+\n+      * movb is similar to addb in that it can perform a reg->reg\n+      or small immediate->reg copy and jump to a nearby (+-8k location).\n+\n+      * fmpyadd and fmpysub can perform a FP multiply and either an\n+      FP add or FP sub if the operands of the multiply and add/sub are\n+      independent (there are other minor restrictions).  Note both\n+      the fmpy and fadd/fsub can in theory move to better spots according\n+      to data dependencies, but for now we require the fmpy stay at a\n+      fixed location.\n+\n+      * Many of the memory operations can perform pre & post updates\n+      of index registers.  GCC's pre/post increment/decrement addressing\n+      is far too simple to take advantage of all the possibilities.  This\n+      pass may not be suitable since those insns may not be independent.\n+\n+      * comclr can compare two ints or an int and a register, nullify\n+      the following instruction and zero some other register.  This\n+      is more difficult to use as it's harder to find an insn which\n+      will generate a comclr than finding something like an unconditional\n+      branch.  (conditional moves & long branches create comclr insns).\n+\n+      * Most arithmetic operations can conditionally skip the next\n+      instruction.  They can be viewed as \"perform this operation\n+      and conditionally jump to this nearby location\" (where nearby\n+      is an insns away).  These are difficult to use due to the\n+      branch length restrictions.  */\n+\n+pa_combine_instructions (insns)\n+     rtx insns;\n+{\n+  rtx anchor, new;\n+\n+  /* This can get expensive since the basic algorithm is on the\n+     order of O(n^2) (or worse).  Only do it for -O2 or higher\n+     levels of optimizaton.  */\n+  if (optimize < 2)\n+    return;\n+\n+  /* Walk down the list of insns looking for \"anchor\" insns which\n+     may be combined with \"floating\" insns.  As the name implies,\n+     \"anchor\" instructions don't move, while \"floating\" insns may\n+     move around.  */\n+  new = gen_rtx (PARALLEL, VOIDmode, gen_rtvec (2, NULL_RTX, NULL_RTX));\n+  new = make_insn_raw (new);\n+\n+  for (anchor = get_insns (); anchor; anchor = NEXT_INSN (anchor))\n+    {\n+      enum attr_pa_combine_type anchor_attr;\n+      enum attr_pa_combine_type floater_attr;\n+\n+      /* We only care about INSNs, JUMP_INSNs, and CALL_INSNs.\n+\t Also ignore any special USE insns.  */\n+      if (GET_CODE (anchor) != INSN\n+\t  && GET_CODE (anchor) != JUMP_INSN\n+\t  && GET_CODE (anchor) != CALL_INSN\n+\t  || GET_CODE (PATTERN (anchor)) == USE\n+\t  || GET_CODE (PATTERN (anchor)) == CLOBBER\n+\t  || GET_CODE (PATTERN (anchor)) == ADDR_VEC\n+\t  || GET_CODE (PATTERN (anchor)) == ADDR_DIFF_VEC)\n+\tcontinue;\n+\n+      anchor_attr = get_attr_pa_combine_type (anchor);\n+      /* See if anchor is an insn suitable for combination.  */\n+      if (anchor_attr == PA_COMBINE_TYPE_FMPY\n+\t  || anchor_attr == PA_COMBINE_TYPE_FADDSUB\n+\t  || (anchor_attr == PA_COMBINE_TYPE_UNCOND_BRANCH\n+\t      && ! forward_branch_p (anchor)))\n+\t{\n+\t  rtx floater;\n+\n+\t  for (floater = PREV_INSN (anchor);\n+\t       floater;\n+\t       floater = PREV_INSN (floater))\n+\t    {\n+\t      if (GET_CODE (floater) == NOTE\n+\t\t  || (GET_CODE (floater) == INSN\n+\t\t      && (GET_CODE (PATTERN (floater)) == USE\n+\t\t\t  || GET_CODE (PATTERN (floater)) == CLOBBER)))\n+\t\tcontinue;\n+\n+\t      /* Anything except a regular INSN will stop our search.  */\n+\t      if (GET_CODE (floater) != INSN\n+\t\t  || GET_CODE (PATTERN (floater)) == ADDR_VEC\n+\t\t  || GET_CODE (PATTERN (floater)) == ADDR_DIFF_VEC)\n+\t\t{\n+\t\t  floater = NULL_RTX;\n+\t\t  break;\n+\t\t}\n+\n+\t      /* See if FLOATER is suitable for combination with the\n+\t\t anchor.  */\n+\t      floater_attr = get_attr_pa_combine_type (floater);\n+\t      if ((anchor_attr == PA_COMBINE_TYPE_FMPY\n+\t\t   && floater_attr == PA_COMBINE_TYPE_FADDSUB)\n+\t\t  || (anchor_attr == PA_COMBINE_TYPE_FADDSUB\n+\t\t      && floater_attr == PA_COMBINE_TYPE_FMPY))\n+\t\t{\n+\t\t  /* If ANCHOR and FLOATER can be combined, then we're\n+\t\t     done with this pass.  */\n+\t\t  if (pa_can_combine_p (new, anchor, floater, 0,\n+\t\t\t\t\tSET_DEST (PATTERN (floater)),\n+\t\t\t\t\tXEXP (SET_SRC (PATTERN (floater)), 0),\n+\t\t\t\t\tXEXP (SET_SRC (PATTERN (floater)), 1)))\n+\t\t    break;\n+\t\t}\n+\n+\t      else if (anchor_attr == PA_COMBINE_TYPE_UNCOND_BRANCH\n+\t\t       && floater_attr == PA_COMBINE_TYPE_ADDMOVE)\n+\t\t{\n+\t\t  if (GET_CODE (SET_SRC (PATTERN (floater))) == PLUS)\n+\t\t    {\n+\t\t      if (pa_can_combine_p (new, anchor, floater, 0,\n+\t\t\t\t\t    SET_DEST (PATTERN (floater)),\n+\t\t\t\t\tXEXP (SET_SRC (PATTERN (floater)), 0),\n+\t\t\t\t\tXEXP (SET_SRC (PATTERN (floater)), 1)))\n+\t\t\tbreak;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      if (pa_can_combine_p (new, anchor, floater, 0,\n+\t\t\t\t\t    SET_DEST (PATTERN (floater)),\n+\t\t\t\t\t    SET_SRC (PATTERN (floater)),\n+\t\t\t\t\t    SET_SRC (PATTERN (floater))))\n+\t\t\tbreak;\n+\t\t    }\n+\t\t}\n+\t    }\n+\n+\t  /* If we didn't find anything on the backwards scan try forwards.  */\n+\t  if (!floater\n+\t      && (anchor_attr == PA_COMBINE_TYPE_FMPY\n+\t\t  || anchor_attr == PA_COMBINE_TYPE_FADDSUB))\n+\t    {\n+\t      for (floater = anchor; floater; floater = NEXT_INSN (floater))\n+\t\t{\n+\t\t  if (GET_CODE (floater) == NOTE\n+\t\t      || (GET_CODE (floater) == INSN\n+\t\t\t  && (GET_CODE (PATTERN (floater)) == USE\n+\t\t\t      || GET_CODE (PATTERN (floater)) == CLOBBER)))\n+\t\t\t\n+\t\t    continue;\n+\n+\t\t  /* Anything except a regular INSN will stop our search.  */\n+\t\t  if (GET_CODE (floater) != INSN\n+\t\t      || GET_CODE (PATTERN (floater)) == ADDR_VEC\n+\t\t      || GET_CODE (PATTERN (floater)) == ADDR_DIFF_VEC)\n+\t\t    {\n+\t\t      floater = NULL_RTX;\n+\t\t      break;\n+\t\t    }\n+\n+\t\t  /* See if FLOATER is suitable for combination with the\n+\t\t     anchor.  */\n+\t\t  floater_attr = get_attr_pa_combine_type (floater);\n+\t\t  if ((anchor_attr == PA_COMBINE_TYPE_FMPY\n+\t\t       && floater_attr == PA_COMBINE_TYPE_FADDSUB)\n+\t\t      || (anchor_attr == PA_COMBINE_TYPE_FADDSUB\n+\t\t\t  && floater_attr == PA_COMBINE_TYPE_FMPY))\n+\t\t    {\n+\t\t      /* If ANCHOR and FLOATER can be combined, then we're\n+\t\t\t done with this pass.  */\n+\t\t      if (pa_can_combine_p (new, anchor, floater, 1,\n+\t\t\t\t\t    SET_DEST (PATTERN (floater)),\n+\t\t\t\t\t    XEXP (SET_SRC (PATTERN(floater)),0),\n+\t\t\t\t\t    XEXP(SET_SRC(PATTERN(floater)),1)))\n+\t\t\tbreak;\n+\t\t    }\n+\t\t}\n+\t    }\n+\n+\t  /* FLOATER will be nonzero if we found a suitable floating\n+\t     insn for combination with ANCHOR.  */\n+\t  if (floater\n+\t      && (anchor_attr == PA_COMBINE_TYPE_FADDSUB\n+\t\t  || anchor_attr == PA_COMBINE_TYPE_FMPY))\n+\t    {\n+\t      /* Emit the new instruction and delete the old anchor.  */\n+\t      emit_insn_before (gen_rtx (PARALLEL, VOIDmode,\n+\t\t\t\t\t gen_rtvec (2, PATTERN (anchor),\n+\t\t\t\t\t\t    PATTERN (floater))),\n+\t\t\t\tanchor);\n+\t      PUT_CODE (anchor, NOTE);\n+\t      NOTE_LINE_NUMBER (anchor) = NOTE_INSN_DELETED;\n+\t      NOTE_SOURCE_FILE (anchor) = 0;\n+\n+\t      /* Emit a special USE insn for FLOATER, then delete\n+\t\t the floating insn.  */\n+\t      emit_insn_before (gen_rtx (USE, VOIDmode, floater), floater);\n+\t      delete_insn (floater);\n+\n+\t      continue;\n+\t    }\n+\t  else if (floater\n+\t\t   && anchor_attr == PA_COMBINE_TYPE_UNCOND_BRANCH)\n+\t    {\n+\t      rtx temp;\n+\t      /* Emit the new_jump instruction and delete the old anchor.  */\n+\t      temp = emit_jump_insn_before (gen_rtx (PARALLEL, VOIDmode,\n+\t\t\t\t\t      gen_rtvec (2, PATTERN (anchor),\n+\t\t\t\t\t\t\t PATTERN (floater))),\n+\t\t\t\tanchor);\n+\t      JUMP_LABEL (temp) = JUMP_LABEL (anchor);\n+\t      PUT_CODE (anchor, NOTE);\n+\t      NOTE_LINE_NUMBER (anchor) = NOTE_INSN_DELETED;\n+\t      NOTE_SOURCE_FILE (anchor) = 0;\n+\n+\t      /* Emit a special USE insn for FLOATER, then delete\n+\t\t the floating insn.  */\n+\t      emit_insn_before (gen_rtx (USE, VOIDmode, floater), floater);\n+\t      delete_insn (floater);\n+\t      continue;\n+\t    }\n+\t}\n+    }\n+}\n+\n+int\n+pa_can_combine_p (new, anchor, floater, reversed, dest, src1, src2)\n+     rtx new, anchor, floater;\n+     int reversed;\n+     rtx dest, src1, src2;\n+{\n+  int insn_code_number;\n+  rtx start, end;\n+\n+  /* Create a PARALLEL with the patterns of ANCHOR and\n+     FLOATER, try to recognize it, then test constraints\n+     for the resulting pattern.\n+\n+     If the pattern doesn't match or the constraints\n+     aren't met keep searching for a suitable floater\n+     insn.  */\n+  XVECEXP (PATTERN (new), 0, 0) = PATTERN (anchor);\n+  XVECEXP (PATTERN (new), 0, 1) = PATTERN (floater);\n+  INSN_CODE (new) = -1;\n+  insn_code_number = recog_memoized (new);\n+  if (insn_code_number < 0\n+      || !constrain_operands (insn_code_number, 1))\n+    return 0;\n+\n+  if (reversed)\n+    {\n+      start = anchor;\n+      end = floater;\n+    }\n+  else\n+    {\n+      start = floater;\n+      end = anchor;\n+    }\n+\n+  /* There's up to three operands to consider.  One\n+     output and two inputs.\n+\n+     The output must not be used between FLOATER & ANCHOR\n+     exclusive.  The inputs must not be set between\n+     FLOATER and ANCHOR exclusive.  */\n+\n+  if (reg_used_between_p (dest, start, end))\n+    return 0;\n+\n+  if (reg_set_between_p (src1, start, end))\n+    return 0;\n+\n+  if (reg_set_between_p (src2, start, end))\n+    return 0;\n+\n+  /* If we get here, then everything is good.  */\n+  return 1;\n+}"}, {"sha": "ed7b654030c61aac326835b94802c22f3f3dc3c5", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 41, "deletions": 62, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4bb6b38188b3791251185318014f3f626f48693/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4bb6b38188b3791251185318014f3f626f48693/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=c4bb6b38188b3791251185318014f3f626f48693", "patch": "@@ -34,6 +34,10 @@\n   \"move,unary,binary,shift,nullshift,compare,load,store,uncond_branch,branch,cbranch,fbranch,call,dyncall,fpload,fpstore,fpalu,fpcc,fpmulsgl,fpmuldbl,fpdivsgl,fpdivdbl,fpsqrtsgl,fpsqrtdbl,multi,milli,parallel_branch\"\n   (const_string \"binary\"))\n \n+(define_attr \"pa_combine_type\"\n+  \"fmpy,faddsub,uncond_branch,addmove,none\"\n+  (const_string \"none\"))\n+\n ;; Processor type (for scheduling, not code generation) -- this attribute\n ;; must exactly match the processor_type enumeration in pa.h.\n ;;\n@@ -97,7 +101,7 @@\n \n \n ;; Call delay slot description.\n-(define_delay (eq_attr \"type\" \"uncond_branch,call\")\n+(define_delay (eq_attr \"type\" \"call\")\n   [(eq_attr \"in_call_delay\" \"true\") (nil) (nil)])\n \n ;; millicode call delay slot description.  Note it disallows delay slot\n@@ -129,6 +133,11 @@\n    (and (eq_attr \"in_nullified_branch_delay\" \"true\")\n \t(attr_flag \"backward\"))])\n \n+(define_delay (and (eq_attr \"type\" \"uncond_branch\")\n+\t\t   (eq (symbol_ref \"following_call (insn)\")\n+\t\t       (const_int 0)))\n+  [(eq_attr \"in_branch_delay\" \"true\") (nil) (nil)])\n+\n ;; Function units of the HPPA. The following data is for the 700 CPUs\n ;; (Mustang CPU + Timex FPU aka PA-89) because that's what I have the docs for.\n ;; Scheduling instructions for PA-83 machines according to the Snake\n@@ -1337,6 +1346,7 @@\n    fldw%F1 %1,%0\n    fstw%F0 %1,%0\"\n   [(set_attr \"type\" \"move,move,move,shift,load,store,move,fpalu,fpload,fpstore\")\n+   (set_attr \"pa_combine_type\" \"addmove\")\n    (set_attr \"length\" \"4,4,4,4,4,4,4,4,4,4\")])\n \n (define_insn \"\"\n@@ -1356,6 +1366,7 @@\n    stw%M0 %r1,%0\n    mtsar %r1\"\n   [(set_attr \"type\" \"move,move,move,move,load,store,move\")\n+   (set_attr \"pa_combine_type\" \"addmove\")\n    (set_attr \"length\" \"4,4,4,4,4,4,4\")])\n \n (define_insn \"\"\n@@ -1735,6 +1746,7 @@\n    mtsar %r1\n    fcpy,sgl %r1,%0\"\n   [(set_attr \"type\" \"move,move,move,shift,load,store,move,fpalu\")\n+   (set_attr \"pa_combine_type\" \"addmove\")\n    (set_attr \"length\" \"4,4,4,4,4,4,4,4\")])\n \n (define_insn \"\"\n@@ -1896,6 +1908,7 @@\n    mtsar %r1\n    fcpy,sgl %r1,%0\"\n   [(set_attr \"type\" \"move,move,move,shift,load,store,move,fpalu\")\n+   (set_attr \"pa_combine_type\" \"addmove\")\n    (set_attr \"length\" \"4,4,4,4,4,4,4,4\")])\n \n (define_insn \"\"\n@@ -2535,6 +2548,7 @@\n    fstw%F0 %r1,%0\n    stw%M0 %r1,%0\"\n   [(set_attr \"type\" \"fpalu,move,fpload,load,fpstore,store\")\n+   (set_attr \"pa_combine_type\" \"addmove\")\n    (set_attr \"length\" \"4,4,4,4,4,4\")])\n \n (define_insn \"\"\n@@ -2550,6 +2564,7 @@\n    ldw%M1 %1,%0\n    stw%M0 %r1,%0\"\n   [(set_attr \"type\" \"move,load,store\")\n+   (set_attr \"pa_combine_type\" \"addmove\")\n    (set_attr \"length\" \"4,4,4\")])\n \n (define_insn \"\"\n@@ -2932,6 +2947,7 @@\n    addl %1,%2,%0\n    ldo %2(%1),%0\"\n   [(set_attr \"type\" \"binary,binary\")\n+   (set_attr \"pa_combine_type\" \"addmove\")\n    (set_attr \"length\" \"4,4\")])\n \n ;; Disgusting kludge to work around reload bugs with frame pointer\n@@ -3452,6 +3468,7 @@\n   \"! TARGET_SOFT_FLOAT\"\n   \"fadd,dbl %1,%2,%0\"\n   [(set_attr \"type\" \"fpalu\")\n+   (set_attr \"pa_combine_type\" \"faddsub\")\n    (set_attr \"length\" \"4\")])\n \n (define_insn \"addsf3\"\n@@ -3461,6 +3478,7 @@\n   \"! TARGET_SOFT_FLOAT\"\n   \"fadd,sgl %1,%2,%0\"\n   [(set_attr \"type\" \"fpalu\")\n+   (set_attr \"pa_combine_type\" \"faddsub\")\n    (set_attr \"length\" \"4\")])\n \n (define_insn \"subdf3\"\n@@ -3470,6 +3488,7 @@\n   \"! TARGET_SOFT_FLOAT\"\n   \"fsub,dbl %1,%2,%0\"\n   [(set_attr \"type\" \"fpalu\")\n+   (set_attr \"pa_combine_type\" \"faddsub\")\n    (set_attr \"length\" \"4\")])\n \n (define_insn \"subsf3\"\n@@ -3479,6 +3498,7 @@\n   \"! TARGET_SOFT_FLOAT\"\n   \"fsub,sgl %1,%2,%0\"\n   [(set_attr \"type\" \"fpalu\")\n+   (set_attr \"pa_combine_type\" \"faddsub\")\n    (set_attr \"length\" \"4\")])\n \n (define_insn \"muldf3\"\n@@ -3488,6 +3508,7 @@\n   \"! TARGET_SOFT_FLOAT\"\n   \"fmpy,dbl %1,%2,%0\"\n   [(set_attr \"type\" \"fpmuldbl\")\n+   (set_attr \"pa_combine_type\" \"fmpy\")\n    (set_attr \"length\" \"4\")])\n \n (define_insn \"mulsf3\"\n@@ -3497,6 +3518,7 @@\n   \"! TARGET_SOFT_FLOAT\"\n   \"fmpy,sgl %1,%2,%0\"\n   [(set_attr \"type\" \"fpmulsgl\")\n+   (set_attr \"pa_combine_type\" \"fmpy\")\n    (set_attr \"length\" \"4\")])\n \n (define_insn \"divdf3\"\n@@ -3892,6 +3914,7 @@\n   \"\"\n   \"bl%* %l0,0\"\n   [(set_attr \"type\" \"uncond_branch\")\n+   (set_attr \"pa_combine_type\" \"uncond_branch\")\n    (set (attr \"length\")\n     (cond [(eq (symbol_ref \"jump_in_call_delay (insn)\") (const_int 0))\n \t   (const_int 4)\n@@ -4738,64 +4761,14 @@\n    (set_attr \"length\" \"4\")])\n \n (define_insn \"\"\n-  [(set (match_operand 0 \"register_operand\" \"=f\")\n-\t(mult (match_operand 1 \"register_operand\" \"f\")\n-\t      (match_operand 2 \"register_operand\" \"f\")))\n-   (set (match_operand 3 \"register_operand\" \"+f\")\n-\t(minus (match_operand 4 \"register_operand\" \"f\")\n-\t       (match_operand 5 \"register_operand\" \"f\")))]\n-  \"TARGET_SNAKE && ! TARGET_SOFT_FLOAT\n-   && reload_completed && fmpysuboperands (operands)\"\n-  \"*\n-{\n-  if (GET_MODE (operands[0]) == DFmode)\n-    return \\\"fmpysub,dbl %1,%2,%0,%5,%3\\\";\n-  else\n-    return \\\"fmpysub,sgl %1,%2,%0,%5,%3\\\";\n-}\"\n-  [(set_attr \"type\" \"fpalu\")\n-   (set_attr \"length\" \"4\")])\n-\n-;; The next four peepholes take advantage of the new 5 operand\n-;; fmpy{add,sub} instructions available on 1.1 CPUS.  Basically\n-;; fmpyadd performs a multiply and add/sub of independent operands\n-;; at the same time.  Because the operands must be independent\n-;; combine will not try to combine such insns...  Thus we have\n-;; to use a peephole.\n-(define_peephole\n-  [(set (match_operand 0 \"register_operand\" \"=f\")\n-\t(mult (match_operand 1 \"register_operand\" \"f\")\n-\t      (match_operand 2 \"register_operand\" \"f\")))\n-   (set (match_operand 3 \"register_operand\" \"+f\")\n-\t(plus (match_operand 4 \"register_operand\" \"f\")\n-\t      (match_operand 5 \"register_operand\" \"f\")))]\n-  \"! TARGET_SOFT_FLOAT && TARGET_SNAKE && fmpyaddoperands (operands)\"\n-  \"*\n-{\n-  if (GET_MODE (operands[0]) == DFmode)\n-    {\n-      if (rtx_equal_p (operands[5], operands[3]))\n-\treturn \\\"fmpyadd,dbl %1,%2,%0,%4,%3\\\";\n-      else\n-\treturn \\\"fmpyadd,dbl %1,%2,%0,%5,%3\\\";\n-    }\n-  else\n-    {\n-      if (rtx_equal_p (operands[5], operands[3]))\n-\treturn \\\"fmpyadd,sgl %1,%2,%0,%4,%3\\\";\n-      else\n-\treturn \\\"fmpyadd,sgl %1,%2,%0,%5,%3\\\";\n-    }\n-}\")\n-\n-(define_peephole\n   [(set (match_operand 3 \"register_operand\" \"+f\")\n \t(plus (match_operand 4 \"register_operand\" \"f\")\n \t      (match_operand 5 \"register_operand\" \"f\")))\n    (set (match_operand 0 \"register_operand\" \"=f\")\n \t(mult (match_operand 1 \"register_operand\" \"f\")\n \t      (match_operand 2 \"register_operand\" \"f\")))]\n-  \"! TARGET_SOFT_FLOAT && TARGET_SNAKE && fmpyaddoperands (operands)\"\n+  \"TARGET_SNAKE && ! TARGET_SOFT_FLOAT\n+   && reload_completed && fmpyaddoperands (operands)\"\n   \"*\n {\n   if (GET_MODE (operands[0]) == DFmode)\n@@ -4812,41 +4785,47 @@\n       else\n \treturn \\\"fmpyadd,sgl %1,%2,%0,%5,%3\\\";\n     }\n-}\")\n+}\"\n+  [(set_attr \"type\" \"fpalu\")\n+   (set_attr \"length\" \"4\")])\n \n-;; Note fsub subtracts the second operand from the first while fmpysub\n-;; does the opposite for the subtraction operands!\n-(define_peephole\n+(define_insn \"\"\n   [(set (match_operand 0 \"register_operand\" \"=f\")\n \t(mult (match_operand 1 \"register_operand\" \"f\")\n \t      (match_operand 2 \"register_operand\" \"f\")))\n    (set (match_operand 3 \"register_operand\" \"+f\")\n \t(minus (match_operand 4 \"register_operand\" \"f\")\n \t       (match_operand 5 \"register_operand\" \"f\")))]\n-  \"! TARGET_SOFT_FLOAT && TARGET_SNAKE && fmpysuboperands (operands)\"\n+  \"TARGET_SNAKE && ! TARGET_SOFT_FLOAT\n+   && reload_completed && fmpysuboperands (operands)\"\n   \"*\n {\n   if (GET_MODE (operands[0]) == DFmode)\n     return \\\"fmpysub,dbl %1,%2,%0,%5,%3\\\";\n   else\n     return \\\"fmpysub,sgl %1,%2,%0,%5,%3\\\";\n-}\")\n+}\"\n+  [(set_attr \"type\" \"fpalu\")\n+   (set_attr \"length\" \"4\")])\n \n-(define_peephole\n+(define_insn \"\"\n   [(set (match_operand 3 \"register_operand\" \"+f\")\n \t(minus (match_operand 4 \"register_operand\" \"f\")\n \t       (match_operand 5 \"register_operand\" \"f\")))\n    (set (match_operand 0 \"register_operand\" \"=f\")\n \t(mult (match_operand 1 \"register_operand\" \"f\")\n \t      (match_operand 2 \"register_operand\" \"f\")))]\n-  \"! TARGET_SOFT_FLOAT && TARGET_SNAKE && fmpysuboperands (operands)\"\n+  \"TARGET_SNAKE && ! TARGET_SOFT_FLOAT\n+   && reload_completed && fmpysuboperands (operands)\"\n   \"*\n {\n   if (GET_MODE (operands[0]) == DFmode)\n     return \\\"fmpysub,dbl %1,%2,%0,%5,%3\\\";\n   else\n     return \\\"fmpysub,sgl %1,%2,%0,%5,%3\\\";\n-}\")\n+}\"\n+  [(set_attr \"type\" \"fpalu\")\n+   (set_attr \"length\" \"4\")])\n \n ;; Clean up turds left by reload.\n (define_peephole"}]}