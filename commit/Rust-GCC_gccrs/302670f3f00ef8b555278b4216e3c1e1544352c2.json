{"sha": "302670f3f00ef8b555278b4216e3c1e1544352c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzAyNjcwZjNmMDBlZjhiNTU1Mjc4YjQyMTZlM2MxZTE1NDQzNTJjMg==", "commit": {"author": {"name": "Michael Hayes", "email": "m.hayes@elec.canterbury.ac.nz", "date": "1998-11-25T21:19:21Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "1998-11-25T21:19:21Z"}, "message": "loop.h (struct loop_info): Define new structure.\n\n\t* loop.h (struct loop_info): Define new structure.\n\t(precondition_loop_p): Added prototype.\n\t(unroll_loop): Added new argument loop_info to prototype.\n\t(final_biv_value, final_giv_value): Added new argument n_iterations\n\tto prototype.\n\t* loop.c (strength_reduce): Declare new structure loop_iteration_info\n\tand new pointer loop_info.\n\t(loop_n_iterations): Replace global variable by element in\n\tloop_info structure.\n\t(check_final_value): New argument n_iterations.\n\t(insert_bct): New argument loop_info.\n\t(loop_unroll_factor): Replace global array by element in\n\tloop_info structure.\n\t(loop_optimize): Remove code to allocate and initialise\n\tloop_unroll_factor_array.\n\t* unroll.c (precondition_loop_p):  No longer static since\n\tused by branch on count optimization.\n\t(precondition_loop_p, unroll_loop): New argument loop_info.\n\t(final_biv_value, final_giv_value, find_splittable_regs): New\n\targument n_iterations.\n\t(loop_iteration_var, loop_initial_value, loop_increment,\n\tloop_final_value, loop_comparison_code, loop_unroll_factor):\n\tReplaced global variables by loop_info structure.\n\t(loop_unroll_factor): Replace global array by element in\n\tloop_info structure.\n\nFrom-SVN: r23884", "tree": {"sha": "bcc06470760eed2be6d81b571ebe62b1538aca25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bcc06470760eed2be6d81b571ebe62b1538aca25"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/302670f3f00ef8b555278b4216e3c1e1544352c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/302670f3f00ef8b555278b4216e3c1e1544352c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/302670f3f00ef8b555278b4216e3c1e1544352c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/302670f3f00ef8b555278b4216e3c1e1544352c2/comments", "author": null, "committer": null, "parents": [{"sha": "a70603680e368c79db0f0b3f7ea2bd792f0d9b6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a70603680e368c79db0f0b3f7ea2bd792f0d9b6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a70603680e368c79db0f0b3f7ea2bd792f0d9b6d"}], "stats": {"total": 316, "additions": 183, "deletions": 133}, "files": [{"sha": "e295f1ca3160d34a9b0205a57538754d53bf596b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/302670f3f00ef8b555278b4216e3c1e1544352c2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/302670f3f00ef8b555278b4216e3c1e1544352c2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=302670f3f00ef8b555278b4216e3c1e1544352c2", "patch": "@@ -1,3 +1,32 @@\n+Thu Nov 26 18:05:04 1998  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n+\n+\t* loop.h (struct loop_info): Define new structure.\n+\t(precondition_loop_p): Added prototype.\n+\t(unroll_loop): Added new argument loop_info to prototype.\n+\t(final_biv_value, final_giv_value): Added new argument n_iterations\n+\tto prototype.\n+\t* loop.c (strength_reduce): Declare new structure loop_iteration_info\n+\tand new pointer loop_info.\n+\t(loop_n_iterations): Replace global variable by element in \n+\tloop_info structure.\n+\t(check_final_value): New argument n_iterations.\n+\t(insert_bct): New argument loop_info.\n+\t(loop_unroll_factor): Replace global array by element in \n+\tloop_info structure.\n+\t(loop_optimize): Remove code to allocate and initialise \n+\tloop_unroll_factor_array.\n+\t* unroll.c (precondition_loop_p):  No longer static since\n+\tused by branch on count optimization.\n+\t(precondition_loop_p, unroll_loop): New argument loop_info.\n+\t(final_biv_value, final_giv_value, find_splittable_regs): New\n+\targument n_iterations.\n+\t(loop_iteration_var, loop_initial_value, loop_increment, \n+\tloop_final_value, loop_comparison_code, loop_unroll_factor): \n+\tReplaced global variables by loop_info structure.\n+\t(loop_unroll_factor): Replace global array by element in\n+\tloop_info structure.\n+\n+\n Thu Nov 26 17:49:29 1998  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n \n \t* loop.c (check_dbra_loop): Update JUMP_LABEL field of jump insn"}, {"sha": "1d0e08d59f5b7b780065a4005397921014537af6", "filename": "gcc/loop.c", "status": "modified", "additions": 27, "deletions": 41, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/302670f3f00ef8b555278b4216e3c1e1544352c2/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/302670f3f00ef8b555278b4216e3c1e1544352c2/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=302670f3f00ef8b555278b4216e3c1e1544352c2", "patch": "@@ -88,14 +88,6 @@ int *loop_outer_loop;\n int *loop_used_count_register;\n #endif  /* HAVE_decrement_and_branch_on_count */\n \n-/* For each loop, keep track of its unrolling factor.\n-   Potential values:\n-      0: unrolled\n-      1: not unrolled.\n-     -1: completely unrolled\n-     >0: holds the unroll exact factor.  */\n-int *loop_unroll_factor;\n-\n /* Indexed by loop number, contains a nonzero value if the \"loop\" isn't\n    really a loop (an insn outside the loop branches into it).  */\n \n@@ -118,14 +110,6 @@ rtx *loop_number_exit_labels;\n \n int *loop_number_exit_count;\n \n-/* Holds the number of loop iterations.  It is zero if the number could not be\n-   calculated.  Must be unsigned since the number of iterations can\n-   be as high as 2^wordsize-1.  For loops with a wider iterator, this number\n-   will be zero if the number of loop iterations is too large for an\n-   unsigned integer to hold.  */\n-\n-unsigned HOST_WIDE_INT loop_n_iterations;\n-\n /* Nonzero if there is a subroutine call in the current loop.  */\n \n static int loop_has_call;\n@@ -320,7 +304,8 @@ static void find_single_use_in_loop PROTO((rtx, rtx, varray_type));\n static int valid_initial_value_p PROTO((rtx, rtx, int, rtx));\n static void find_mem_givs PROTO((rtx, rtx, int, rtx, rtx));\n static void record_biv PROTO((struct induction *, rtx, rtx, rtx, rtx, int, int));\n-static void check_final_value PROTO((struct induction *, rtx, rtx));\n+static void check_final_value PROTO((struct induction *, rtx, rtx, \n+\t\t\t\t     unsigned HOST_WIDE_INT));\n static void record_giv PROTO((struct induction *, rtx, rtx, rtx, rtx, rtx, int, enum g_types, int, rtx *, rtx, rtx));\n static void update_giv_derive PROTO((rtx));\n static int basic_induction_var PROTO((rtx, enum machine_mode, rtx, rtx, rtx *, rtx *));\n@@ -365,7 +350,7 @@ typedef struct rtx_pair {\n \n #ifdef HAVE_decrement_and_branch_on_count\n /* Test whether BCT applicable and safe.  */\n-static void insert_bct PROTO((rtx, rtx));\n+static void insert_bct PROTO((rtx, rtx, struct loop_info *));\n \n /* Auxiliary function that inserts the BCT pattern into the loop.  */\n static void instrument_loop_bct PROTO((rtx, rtx, rtx));\n@@ -478,12 +463,6 @@ loop_optimize (f, dumpfile, unroll_p, bct_p)\n   loop_number_exit_labels = (rtx *) alloca (max_loop_num * sizeof (rtx));\n   loop_number_exit_count = (int *) alloca (max_loop_num * sizeof (int));\n \n-  /* This is initialized by the unrolling code, so we go ahead\n-     and clear them just in case we are not performing loop\n-     unrolling.  */\n-  loop_unroll_factor = (int *) alloca (max_loop_num *sizeof (int));\n-  bzero ((char *) loop_unroll_factor, max_loop_num * sizeof (int));\n-\n #ifdef HAVE_decrement_and_branch_on_count\n   /* Allocate for BCT optimization */\n   loop_used_count_register = (int *) alloca (max_loop_num * sizeof (int));\n@@ -3573,6 +3552,8 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n   rtx test;\n   rtx end_insert_before;\n   int loop_depth = 0;\n+  struct loop_info loop_iteration_info;\n+  struct loop_info *loop_info = &loop_iteration_info;\n \n   reg_iv_type = (enum iv_mode *) alloca (max_reg_before_loop\n \t\t\t\t\t * sizeof (enum iv_mode));\n@@ -3771,7 +3752,8 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n       /* Can still unroll the loop anyways, but indicate that there is no\n \t strength reduction info available.  */\n       if (unroll_p)\n-\tunroll_loop (loop_end, insn_count, loop_start, end_insert_before, 0);\n+\tunroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n+\t\t     loop_info, 0);\n \n       return;\n     }\n@@ -4040,7 +4022,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n      be called after all giv's have been identified, since otherwise it may\n      fail if the iteration variable is a giv.  */\n \n-  loop_n_iterations = loop_iterations (loop_start, loop_end);\n+  loop_iterations (loop_start, loop_end, loop_info);\n \n   /* Now for each giv for which we still don't know whether or not it is\n      replaceable, check to see if it is replaceable because its final value\n@@ -4053,7 +4035,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \n       for (v = bl->giv; v; v = v->next_iv)\n \tif (! v->replaceable && ! v->not_replaceable)\n-\t  check_final_value (v, loop_start, loop_end);\n+\t  check_final_value (v, loop_start, loop_end, loop_info->n_iterations);\n     }\n \n   /* Try to prove that the loop counter variable (if any) is always\n@@ -4099,7 +4081,8 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t   && ! bl->nonneg\n #endif\n \t   && ! reg_mentioned_p (bl->biv->dest_reg, SET_SRC (bl->init_set)))\n-\t  || ((final_value = final_biv_value (bl, loop_start, loop_end))\n+\t  || ((final_value = final_biv_value (bl, loop_start, loop_end, \n+\t\t\t\t\t      loop_info->n_iterations))\n #ifdef HAVE_decrement_and_branch_until_zero\n \t      && ! bl->nonneg\n #endif\n@@ -4562,13 +4545,14 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n      collected.  */\n   \n   if (unroll_p)\n-    unroll_loop (loop_end, insn_count, loop_start, end_insert_before, 1);\n+    unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n+\t\t loop_info, 1);\n \n #ifdef HAVE_decrement_and_branch_on_count\n   /* Instrument the loop with BCT insn.  */\n   if (HAVE_decrement_and_branch_on_count && bct_p\n       && flag_branch_on_count_reg)\n-    insert_bct (loop_start, loop_end);\n+    insert_bct (loop_start, loop_end, loop_info);\n #endif  /* HAVE_decrement_and_branch_on_count */\n \n   if (loop_dump_stream)\n@@ -5058,9 +5042,10 @@ record_giv (v, insn, src_reg, dest_reg, mult_val, add_val, benefit,\n    have been identified.  */\n \n static void\n-check_final_value (v, loop_start, loop_end)\n+check_final_value (v, loop_start, loop_end, n_iterations)\n      struct induction *v;\n      rtx loop_start, loop_end;\n+     unsigned HOST_WIDE_INT n_iterations;\n {\n   struct iv_class *bl;\n   rtx final_value = 0;\n@@ -5087,7 +5072,7 @@ check_final_value (v, loop_start, loop_end)\n   v->replaceable = 0;\n #endif\n \n-  if ((final_value = final_giv_value (v, loop_start, loop_end))\n+  if ((final_value = final_giv_value (v, loop_start, loop_end, n_iterations))\n       && (v->always_computable || last_use_this_basic_block (v->dest_reg, v->insn)))\n     {\n       int biv_increment_seen = 0;\n@@ -7965,8 +7950,9 @@ get_condition_for_loop (x)\n  */\n \n static void\n-insert_bct (loop_start, loop_end)\n+insert_bct (loop_start, loop_end, loop_info)\n      rtx loop_start, loop_end;\n+     struct loop_info *loop_info;\n {\n   int i;\n   unsigned HOST_WIDE_INT n_iterations;\n@@ -7982,7 +7968,7 @@ insert_bct (loop_start, loop_end)\n   int loop_num = uid_loop_num [INSN_UID (loop_start)];\n \n   /* It's impossible to instrument a competely unrolled loop.  */\n-  if (loop_unroll_factor [loop_num] == -1)\n+  if (loop_info->unroll_number == -1)\n     return;\n \n   /* Make sure that the count register is not in use.  */\n@@ -8040,10 +8026,10 @@ insert_bct (loop_start, loop_end)\n     }\n \n   /* Account for loop unrolling in instrumented iteration count.  */\n-  if (loop_unroll_factor [loop_num] > 1)\n-    n_iterations = loop_n_iterations / loop_unroll_factor [loop_num];\n+  if (loop_info->unroll_number > 1)\n+    n_iterations = loop_info->n_iterations / loop_info->unroll_number;\n   else\n-    n_iterations = loop_n_iterations;\n+    n_iterations = loop_info->n_iterations;\n \n   if (n_iterations != 0 && n_iterations < 3)\n     {\n@@ -8071,7 +8057,7 @@ insert_bct (loop_start, loop_end)\n      at compile time.  In this case we generate run_time calculation\n      of the number of iterations.  */\n \n-  if (loop_iteration_var == 0)\n+  if (loop_info->iteration_var == 0)\n     {\n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream,\n@@ -8080,8 +8066,8 @@ insert_bct (loop_start, loop_end)\n       return;\n     }\n \n-  if (GET_MODE_CLASS (GET_MODE (loop_iteration_var)) != MODE_INT\n-      || GET_MODE_SIZE (GET_MODE (loop_iteration_var)) != UNITS_PER_WORD)\n+  if (GET_MODE_CLASS (GET_MODE (loop_info->iteration_var)) != MODE_INT\n+      || GET_MODE_SIZE (GET_MODE (loop_info->iteration_var)) != UNITS_PER_WORD)\n     {\n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream,\n@@ -8091,7 +8077,7 @@ insert_bct (loop_start, loop_end)\n     }\n \n   /* With runtime bounds, if the compare is of the form '!=' we give up */\n-  if (loop_comparison_code == NE)\n+  if (loop_info->comparison_code == NE)\n     {\n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream,"}, {"sha": "f747e46612ece26de1a00a4b2f89044c9090e60e", "filename": "gcc/loop.h", "status": "modified", "additions": 46, "deletions": 13, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/302670f3f00ef8b555278b4216e3c1e1544352c2/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/302670f3f00ef8b555278b4216e3c1e1544352c2/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=302670f3f00ef8b555278b4216e3c1e1544352c2", "patch": "@@ -143,6 +143,43 @@ struct iv_class {\n \t\t\t\t   biv controls. */\n };\n \n+/* Information required to calculate the number of loop iterations. \n+   This is set by loop_iterations.  */\n+\n+struct loop_info\n+{\n+  /* Register or constant initial loop value.  */\n+  rtx initial_value;\n+  /* Register or constant value used for comparison test.  */\n+  rtx comparison_value;\n+  /* Register or constant approximate final value.  */\n+  rtx final_value;\n+  /* Register or constant initial loop value with term common to\n+     final_value removed.  */\n+  rtx initial_equiv_value;\n+  /* Register or constant final loop value with term common to\n+     initial_value removed.  */\n+  rtx final_equiv_value;\n+  /* Register corresponding to iteration variable.  */\n+  rtx iteration_var;\n+  /* Constant loop increment.  */\n+  rtx increment;\n+  enum rtx_code comparison_code;\n+  /* Holds the number of loop iterations.  It is zero if the number\n+     could not be calculated.  Must be unsigned since the number of\n+     iterations can be as high as 2^wordsize - 1.  For loops with a\n+     wider iterator, this number will be zero if the number of loop\n+     iterations is too large for an unsigned integer to hold.  */\n+  unsigned HOST_WIDE_INT n_iterations;\n+  /* The loop unrolling factor.\n+     Potential values:\n+     0: unrolled\n+     1: not unrolled.\n+     -1: completely unrolled\n+     >0: holds the unroll exact factor.  */\n+  int unroll_number;\n+};\n+\n /* Definitions used by the basic induction variable discovery code.  */\n enum iv_mode { UNKNOWN_INDUCT, BASIC_INDUCT, NOT_BASIC_INDUCT,\n \t\t GENERAL_INDUCT };\n@@ -155,7 +192,6 @@ extern int *uid_loop_num;\n extern int *loop_outer_loop;\n extern rtx *loop_number_exit_labels;\n extern int *loop_number_exit_count;\n-extern unsigned HOST_WIDE_INT loop_n_iterations;\n extern int max_reg_before_loop;\n \n extern FILE *loop_dump_stream;\n@@ -175,21 +211,18 @@ void emit_iv_add_mult PROTO((rtx, rtx, rtx, rtx, rtx));\n void find_loop_tree_blocks PROTO((void));\n void unroll_block_trees PROTO((void));\n \n-void unroll_loop PROTO((rtx, int, rtx, rtx, int));\n+void unroll_loop PROTO((rtx, int, rtx, rtx, struct loop_info *, int));\n rtx biv_total_increment PROTO((struct iv_class *, rtx, rtx));\n-unsigned HOST_WIDE_INT loop_iterations PROTO((rtx, rtx));\n-rtx final_biv_value PROTO((struct iv_class *, rtx, rtx));\n-rtx final_giv_value PROTO((struct induction *, rtx, rtx));\n+unsigned HOST_WIDE_INT loop_iterations PROTO((rtx, rtx, struct loop_info *));\n+int precondition_loop_p PROTO((rtx, struct loop_info *, \n+\t\t\t       rtx *, rtx *, rtx *));\n+rtx final_biv_value PROTO((struct iv_class *, rtx, rtx,\n+\t\t\t   unsigned HOST_WIDE_INT));\n+rtx final_giv_value PROTO((struct induction *, rtx, rtx,\n+\t\t\t   unsigned HOST_WIDE_INT));\n void emit_unrolled_add PROTO((rtx, rtx, rtx));\n int back_branch_in_range_p PROTO((rtx, rtx, rtx));\n \n-extern int *loop_unroll_factor;\n+extern int *loop_unroll_number;\n \n-#ifdef HAVE_decrement_and_branch_on_count\n-extern rtx loop_iteration_var;\n-extern rtx loop_initial_value;\n-extern rtx loop_increment;\n-extern rtx loop_final_value;\n-extern enum rtx_code loop_comparison_code;\n-#endif  /* HAVE_decrement_and_branch_on_count */\n "}, {"sha": "5f9f2c7addc85f4a71caddabac7f82c009c6c049", "filename": "gcc/unroll.c", "status": "modified", "additions": 81, "deletions": 79, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/302670f3f00ef8b555278b4216e3c1e1544352c2/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/302670f3f00ef8b555278b4216e3c1e1544352c2/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=302670f3f00ef8b555278b4216e3c1e1544352c2", "patch": "@@ -186,28 +186,19 @@ static rtx *splittable_regs;\n \n static int *splittable_regs_updates;\n \n-/* Values describing the current loop's iteration variable.  These are set up\n-   by loop_iterations, and used by precondition_loop_p.  */\n-\n-rtx loop_iteration_var;\n-rtx loop_initial_value;\n-rtx loop_increment;\n-rtx loop_final_value;\n-enum rtx_code loop_comparison_code;\n-\n /* Forward declarations.  */\n \n static void init_reg_map PROTO((struct inline_remap *, int));\n-static int precondition_loop_p PROTO((rtx *, rtx *, rtx *, rtx));\n static rtx calculate_giv_inc PROTO((rtx, rtx, int));\n static rtx initial_reg_note_copy PROTO((rtx, struct inline_remap *));\n static void final_reg_note_copy PROTO((rtx, struct inline_remap *));\n static void copy_loop_body PROTO((rtx, rtx, struct inline_remap *, rtx, int,\n \t\t\t\t  enum unroll_types, rtx, rtx, rtx, rtx));\n void iteration_info PROTO((rtx, rtx *, rtx *, rtx, rtx));\n static rtx approx_final_value PROTO((enum rtx_code, rtx, int *, int *));\n-static int find_splittable_regs PROTO((enum unroll_types, rtx, rtx, rtx, int));\n-static int find_splittable_givs PROTO((struct iv_class *,enum unroll_types,\n+static int find_splittable_regs PROTO((enum unroll_types, rtx, rtx, rtx, int,\n+\t\t\t\t       unsigned HOST_WIDE_INT));\n+static int find_splittable_givs PROTO((struct iv_class *, enum unroll_types,\n \t\t\t\t       rtx, rtx, rtx, int));\n static int reg_dead_after_loop PROTO((rtx, rtx, rtx));\n static rtx fold_rtx_mult_add PROTO((rtx, rtx, rtx, enum machine_mode));\n@@ -227,11 +218,12 @@ static rtx remap_split_bivs PROTO((rtx));\n \n void\n unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n-\t     strength_reduce_p)\n+\t     loop_info, strength_reduce_p)\n      rtx loop_end;\n      int insn_count;\n      rtx loop_start;\n      rtx end_insert_before;\n+     struct loop_info *loop_info;\n      int strength_reduce_p;\n {\n   int i, j, temp;\n@@ -304,18 +296,19 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n   /* Determine type of unroll to perform.  Depends on the number of iterations\n      and the size of the loop.  */\n \n-  /* If there is no strength reduce info, then set loop_n_iterations to zero.\n-     This can happen if strength_reduce can't find any bivs in the loop.\n-     A value of zero indicates that the number of iterations could not be\n-     calculated.  */\n+  /* If there is no strength reduce info, then set\n+     loop_info->n_iterations to zero.  This can happen if\n+     strength_reduce can't find any bivs in the loop.  A value of zero\n+     indicates that the number of iterations could not be calculated.  */\n \n   if (! strength_reduce_p)\n-    loop_n_iterations = 0;\n+    loop_info->n_iterations = 0;\n \n-  if (loop_dump_stream && loop_n_iterations > 0)\n+  if (loop_dump_stream && loop_info->n_iterations > 0)\n     {\n       fputs (\"Loop unrolling: \", loop_dump_stream);\n-      fprintf (loop_dump_stream, HOST_WIDE_INT_PRINT_DEC, loop_n_iterations);\n+      fprintf (loop_dump_stream, HOST_WIDE_INT_PRINT_DEC, \n+\t       loop_info->n_iterations);\n       fputs (\" iterations.\\n\", loop_dump_stream);\n     }\n \n@@ -326,7 +319,7 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n   /* Calculate how many times to unroll the loop.  Indicate whether or\n      not the loop is being completely unrolled.  */\n \n-  if (loop_n_iterations == 1)\n+  if (loop_info->n_iterations == 1)\n     {\n       /* If number of iterations is exactly 1, then eliminate the compare and\n \t branch at the end of the loop since they will never be taken.\n@@ -355,13 +348,13 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \t}\n       return;\n     }\n-  else if (loop_n_iterations > 0\n-      && loop_n_iterations * insn_count < MAX_UNROLLED_INSNS)\n+  else if (loop_info->n_iterations > 0\n+      && loop_info->n_iterations * insn_count < MAX_UNROLLED_INSNS)\n     {\n-      unroll_number = loop_n_iterations;\n+      unroll_number = loop_info->n_iterations;\n       unroll_type = UNROLL_COMPLETELY;\n     }\n-  else if (loop_n_iterations > 0)\n+  else if (loop_info->n_iterations > 0)\n     {\n       /* Try to factor the number of iterations.  Don't bother with the\n \t general case, only using 2, 3, 5, and 7 will get 75% of all\n@@ -370,7 +363,7 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n       for (i = 0; i < NUM_FACTORS; i++)\n \tfactors[i].count = 0;\n \n-      temp = loop_n_iterations;\n+      temp = loop_info->n_iterations;\n       for (i = NUM_FACTORS - 1; i >= 0; i--)\n \twhile (temp % factors[i].factor == 0)\n \t  {\n@@ -857,8 +850,8 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n     {\n       rtx initial_value, final_value, increment;\n \n-      if (precondition_loop_p (&initial_value, &final_value, &increment,\n-\t\t\t       loop_start))\n+      if (precondition_loop_p (loop_start, loop_info,\n+\t\t\t       &initial_value, &final_value, &increment))\n \t{\n \t  register rtx diff ;\n \t  enum machine_mode mode;\n@@ -939,7 +932,7 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \t     case.  This check does not apply if the loop has a NE\n \t     comparison at the end.  */\n \n-\t  if (loop_comparison_code != NE)\n+\t  if (loop_info->comparison_code != NE)\n \t    {\n \t      emit_cmp_insn (initial_value, final_value, neg_inc ? LE : GE,\n \t\t\t     NULL_RTX, mode, 0, 0);\n@@ -1141,11 +1134,11 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \n   /* At this point, we are guaranteed to unroll the loop.  */\n \n-  /* Keep track of the unroll factor for each loop.  */\n+  /* Keep track of the unroll factor for the loop.  */\n   if (unroll_type == UNROLL_COMPLETELY)\n-    loop_unroll_factor [uid_loop_num [INSN_UID (loop_start)]] = -1;\n+    loop_info->unroll_number = -1;\n   else\n-    loop_unroll_factor [uid_loop_num [INSN_UID (loop_start)]] = unroll_number;\n+    loop_info->unroll_number = unroll_number;\n \n \n   /* For each biv and giv, determine whether it can be safely split into\n@@ -1160,7 +1153,8 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n     temp = 0;\n   else\n     temp = find_splittable_regs (unroll_type, loop_start, loop_end,\n-\t\t\t\tend_insert_before, unroll_number);\n+\t\t\t\t end_insert_before, unroll_number,\n+\t\t\t\t loop_info->n_iterations);\n \n   /* find_splittable_regs may have created some new registers, so must\n      reallocate the reg_map with the new larger size, and must realloc\n@@ -1318,52 +1312,54 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n    when the increment is not a power of 2.  Use RTX_COST to compute\n    whether divide is cheap.  */\n \n-static int\n-precondition_loop_p (initial_value, final_value, increment, loop_start)\n-     rtx *initial_value, *final_value, *increment;\n+int\n+precondition_loop_p (loop_start, loop_info,\n+\t\t     initial_value, final_value, increment)\n      rtx loop_start;\n+     struct loop_info *loop_info;\n+     rtx *initial_value, *final_value, *increment;\n {\n \n-  if (loop_n_iterations > 0)\n+  if (loop_info->n_iterations > 0)\n     {\n       *initial_value = const0_rtx;\n       *increment = const1_rtx;\n-      *final_value = GEN_INT (loop_n_iterations);\n+      *final_value = GEN_INT (loop_info->n_iterations);\n \n       if (loop_dump_stream)\n \t{\n \t  fputs (\"Preconditioning: Success, number of iterations known, \",\n \t\t loop_dump_stream);\n \t  fprintf (loop_dump_stream, HOST_WIDE_INT_PRINT_DEC,\n-\t\t   loop_n_iterations);\n+\t\t   loop_info->n_iterations);\n \t  fputs (\".\\n\", loop_dump_stream);\n \t}\n       return 1;\n     }\n \n-  if (loop_initial_value == 0)\n+  if (loop_info->initial_value == 0)\n     {\n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream,\n \t\t \"Preconditioning: Could not find initial value.\\n\");\n       return 0;\n     }\n-  else if (loop_increment == 0)\n+  else if (loop_info->increment == 0)\n     {\n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream,\n \t\t \"Preconditioning: Could not find increment value.\\n\");\n       return 0;\n     }\n-  else if (GET_CODE (loop_increment) != CONST_INT)\n+  else if (GET_CODE (loop_info->increment) != CONST_INT)\n     {\n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream,\n \t\t \"Preconditioning: Increment not a constant.\\n\");\n       return 0;\n     }\n-  else if ((exact_log2 (INTVAL (loop_increment)) < 0)\n-\t   && (exact_log2 (- INTVAL (loop_increment)) < 0))\n+  else if ((exact_log2 (INTVAL (loop_info->increment)) < 0)\n+\t   && (exact_log2 (- INTVAL (loop_info->increment)) < 0))\n     {\n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream,\n@@ -1374,7 +1370,7 @@ precondition_loop_p (initial_value, final_value, increment, loop_start)\n   /* Unsigned_compare and compare_dir can be ignored here, since they do\n      not matter for preconditioning.  */\n \n-  if (loop_final_value == 0)\n+  if (loop_info->final_value == 0)\n     {\n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream,\n@@ -1387,11 +1383,11 @@ precondition_loop_p (initial_value, final_value, increment, loop_start)\n      to make sure that the register is in the range covered by invariant_p.\n      If it isn't, then it is most likely a biv/giv which by definition are\n      not invariant.  */\n-  if ((GET_CODE (loop_final_value) == REG\n-       && REGNO (loop_final_value) >= max_reg_before_loop)\n-      || (GET_CODE (loop_final_value) == PLUS\n-\t  && REGNO (XEXP (loop_final_value, 0)) >= max_reg_before_loop)\n-      || ! invariant_p (loop_final_value))\n+  if ((GET_CODE (loop_info->final_value) == REG\n+       && REGNO (loop_info->final_value) >= max_reg_before_loop)\n+      || (GET_CODE (loop_info->final_value) == PLUS\n+\t  && REGNO (XEXP (loop_info->final_value, 0)) >= max_reg_before_loop)\n+      || ! invariant_p (loop_info->final_value))\n     {\n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream,\n@@ -1401,19 +1397,19 @@ precondition_loop_p (initial_value, final_value, increment, loop_start)\n \n   /* Fail for floating point values, since the caller of this function\n      does not have code to deal with them.  */\n-  if (GET_MODE_CLASS (GET_MODE (loop_final_value)) == MODE_FLOAT\n-      || GET_MODE_CLASS (GET_MODE (loop_initial_value)) == MODE_FLOAT)\n+  if (GET_MODE_CLASS (GET_MODE (loop_info->final_value)) == MODE_FLOAT\n+      || GET_MODE_CLASS (GET_MODE (loop_info->initial_value)) == MODE_FLOAT)\n     {\n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream,\n \t\t \"Preconditioning: Floating point final or initial value.\\n\");\n       return 0;\n     }\n \n-  /* Fail if loop_iteration_var is not live before loop_start, since we need\n-     to test its value in the preconditioning code.  */\n+  /* Fail if loop_info->iteration_var is not live before loop_start,\n+     since we need to test its value in the preconditioning code.  */\n \n-  if (uid_luid[REGNO_FIRST_UID (REGNO (loop_iteration_var))]\n+  if (uid_luid[REGNO_FIRST_UID (REGNO (loop_info->iteration_var))]\n       > INSN_LUID (loop_start))\n     {\n       if (loop_dump_stream)\n@@ -1430,9 +1426,9 @@ precondition_loop_p (initial_value, final_value, increment, loop_start)\n      Also note that the absolute values of initial_value and\n      final_value are unimportant as only their difference is used for\n      calculating the number of loop iterations.  */\n-  *initial_value = loop_initial_value;\n-  *increment = loop_increment;\n-  *final_value = loop_final_value;\n+  *initial_value = loop_info->initial_value;\n+  *increment = loop_info->increment;\n+  *final_value = loop_info->final_value;\n \n   /* Success! */\n   if (loop_dump_stream)\n@@ -2361,7 +2357,7 @@ iteration_info (iteration_var, initial_value, increment, loop_start, loop_end)\n \n   /* Reject iteration variables larger than the host wide int size, since they\n      could result in a number of iterations greater than the range of our\n-     `unsigned HOST_WIDE_INT' variable loop_n_iterations.  */\n+     `unsigned HOST_WIDE_INT' variable loop_info->n_iterations.  */\n   else if ((GET_MODE_BITSIZE (GET_MODE (iteration_var))\n \t    > HOST_BITS_PER_WIDE_INT))\n     {\n@@ -2506,11 +2502,12 @@ approx_final_value (comparison_code, comparison_value, unsigned_p, compare_dir)\n \n static int\n find_splittable_regs (unroll_type, loop_start, loop_end, end_insert_before,\n-\t\t     unroll_number)\n+\t\t     unroll_number, n_iterations)\n      enum unroll_types unroll_type;\n      rtx loop_start, loop_end;\n      rtx end_insert_before;\n      int unroll_number;\n+     unsigned HOST_WIDE_INT n_iterations;\n {\n   struct iv_class *bl;\n   struct induction *v;\n@@ -2548,7 +2545,8 @@ find_splittable_regs (unroll_type, loop_start, loop_end, end_insert_before,\n \t      || (uid_luid[REGNO_FIRST_UID (bl->regno)]\n \t\t  < INSN_LUID (bl->init_insn))\n \t      || reg_mentioned_p (bl->biv->dest_reg, SET_SRC (bl->init_set)))\n-\t  && ! (biv_final_value = final_biv_value (bl, loop_start, loop_end)))\n+\t  && ! (biv_final_value = final_biv_value (bl, loop_start, loop_end,\n+\t\t\t\t\t\t   n_iterations)))\n \tbiv_splittable = 0;\n \n       /* If any of the insns setting the BIV don't do so with a simple\n@@ -3201,9 +3199,10 @@ reg_dead_after_loop (reg, loop_start, loop_end)\n    the end of the loop.  If we can do it, return that value.  */\n   \n rtx\n-final_biv_value (bl, loop_start, loop_end)\n+final_biv_value (bl, loop_start, loop_end, n_iterations)\n      struct iv_class *bl;\n      rtx loop_start, loop_end;\n+     unsigned HOST_WIDE_INT n_iterations;\n {\n   rtx increment, tem;\n \n@@ -3231,7 +3230,7 @@ final_biv_value (bl, loop_start, loop_end)\n      it may not have its final value when the loop exits), and the initial\n      value of the biv must be invariant.  */\n \n-  if (loop_n_iterations != 0\n+  if (n_iterations != 0\n       && ! loop_number_exit_count[uid_loop_num[INSN_UID (loop_start)]]\n       && invariant_p (bl->initial_value))\n     {\n@@ -3248,7 +3247,7 @@ final_biv_value (bl, loop_start, loop_end)\n \t  /* Make sure loop_end is not the last insn.  */\n \t  if (NEXT_INSN (loop_end) == 0)\n \t    emit_note_after (NOTE_INSN_DELETED, loop_end);\n-\t  emit_iv_add_mult (increment, GEN_INT (loop_n_iterations),\n+\t  emit_iv_add_mult (increment, GEN_INT (n_iterations),\n \t\t\t    bl->initial_value, tem, NEXT_INSN (loop_end));\n \n \t  if (loop_dump_stream)\n@@ -3277,9 +3276,10 @@ final_biv_value (bl, loop_start, loop_end)\n    the end of the loop.  If we can do it, return that value.  */\n \n rtx\n-final_giv_value (v, loop_start, loop_end)\n+final_giv_value (v, loop_start, loop_end, n_iterations)\n      struct induction *v;\n      rtx loop_start, loop_end;\n+     unsigned HOST_WIDE_INT n_iterations;\n {\n   struct iv_class *bl;\n   rtx insn;\n@@ -3310,7 +3310,7 @@ final_giv_value (v, loop_start, loop_end)\n      only one exit for this to work, but the loop iterations does not need\n      to be known.  */\n \n-  if (loop_n_iterations != 0\n+  if (n_iterations != 0\n       && ! loop_number_exit_count[uid_loop_num[INSN_UID (loop_start)]])\n     {\n       /* ?? It is tempting to use the biv's value here since these insns will\n@@ -3330,7 +3330,7 @@ final_giv_value (v, loop_start, loop_end)\n \t  && invariant_p (bl->initial_value))\n \t{\n \t  /* Can calculate the loop exit value of its biv as\n-\t     (loop_n_iterations * increment) + initial_value */\n+\t     (n_iterations * increment) + initial_value */\n \t      \n \t  /* The loop exit value of the giv is then\n \t     (final_biv_value - extra increments) * mult_val + add_val.\n@@ -3344,7 +3344,7 @@ final_giv_value (v, loop_start, loop_end)\n \t  /* Put the final biv value in tem.  */\n \t  tem = gen_reg_rtx (bl->biv->mode);\n \t  record_base_value (REGNO (tem), bl->biv->add_val, 0);\n-\t  emit_iv_add_mult (increment, GEN_INT (loop_n_iterations),\n+\t  emit_iv_add_mult (increment, GEN_INT (n_iterations),\n \t\t\t    bl->initial_value, tem, insert_before);\n \n \t  /* Subtract off extra increments as we find them.  */\n@@ -3402,8 +3402,9 @@ final_giv_value (v, loop_start, loop_end)\n    iterations if it can be calculated, otherwise returns zero.  */\n \n unsigned HOST_WIDE_INT\n-loop_iterations (loop_start, loop_end)\n+loop_iterations (loop_start, loop_end, loop_info)\n      rtx loop_start, loop_end;\n+     struct loop_info *loop_info;\n {\n   rtx comparison, comparison_value;\n   rtx iteration_var, initial_value, increment, final_value;\n@@ -3418,10 +3419,11 @@ loop_iterations (loop_start, loop_end)\n      branch, and the insn before tests a register value, make that the\n      iteration variable.  */\n   \n-  loop_initial_value = 0;\n-  loop_increment = 0;\n-  loop_final_value = 0;\n-  loop_iteration_var = 0;\n+  loop_info->initial_value = 0;\n+  loop_info->increment = 0;\n+  loop_info->final_value = 0;\n+  loop_info->iteration_var = 0;\n+  loop_info->unroll_number = 2;\n \n   /* We used to use pren_nonnote_insn here, but that fails because it might\n      accidentally get the branch for a contained loop if the branch for this\n@@ -3508,11 +3510,11 @@ loop_iterations (loop_start, loop_end)\n      recalculated inside precondition_loop_p because strength reduction\n      optimizations may obscure the loop's structure.  */\n \n-  loop_iteration_var = iteration_var;\n-  loop_initial_value = initial_value;\n-  loop_increment = increment;\n-  loop_final_value = final_value;\n-  loop_comparison_code = comparison_code;\n+  loop_info->iteration_var = iteration_var;\n+  loop_info->initial_value = initial_value;\n+  loop_info->increment = increment;\n+  loop_info->final_value = final_value;\n+  loop_info->comparison_code = comparison_code;\n \n   if (increment == 0)\n     {\n@@ -3617,7 +3619,7 @@ loop_iterations (loop_start, loop_end)\n     }\n \n   /* Calculate the number of iterations, final_value is only an approximation,\n-     so correct for that.  Note that tempu and loop_n_iterations are\n+     so correct for that.  Note that tempu and loop_info->n_iterations are\n      unsigned, because they can be as large as 2^n - 1.  */\n \n   i = INTVAL (increment);"}]}