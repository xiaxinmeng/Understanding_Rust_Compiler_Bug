{"sha": "1de43f850cf14d42f9b601c63b15cff3049dd940", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWRlNDNmODUwY2YxNGQ0MmY5YjYwMWM2M2IxNWNmZjMwNDlkZDk0MA==", "commit": {"author": {"name": "David Edelsohn", "email": "edelsohn@gnu.org", "date": "2007-07-14T00:12:45Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2007-07-14T00:12:45Z"}, "message": "spe.md (SPE_ACC_REGNO): Delete definition.\n\n        * config/rs6000/spe.md (SPE_ACC_REGNO): Delete definition.\n        (SPEFSCR_REGNO): Delete definition.\n        * config/rs6000/rs6000.c: LINK_REGISTER_REGNUM -> LR_REGNO.\n        COUNT_REGISTER_REGNUM -> CTR_REGNO.\n        * config/rs6000/rs6000.h: Do not define *_REGNO.\n        LINK_REGISTER_REGNUM -> LR_REGNO.\n        COUNT_REGISTER_REGNUM -> CTR_REGNO.\n        * config/rs6000/predicates.md: LINK_REGISTER_REGNUM -> LR_REGNO.\n        COUNT_REGISTER_REGNUM -> CTR_REGNO.\n        * config/rs6000/linux-unwind.h: Define R_LR, R_CR2, R_VR0,\n        R_VRSAVE, R_VSCR. Use them.\n        * config/rs6000/darwin-fallback.c: Define R_LR, R_CTR, R_CR2,\n        R_XER, R_VR0, R_VRSAVE, R_VSCR, R_SPEFSCR.  Use them.\n        * config/rs6000/rs6000.md: Define REGNO constants.  Use them.\n        * config/rs6000/aix.h: Define R_LR.  Use it.\n\nFrom-SVN: r126631", "tree": {"sha": "7d98a5769ddb6a068404053c007e475b18355f98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d98a5769ddb6a068404053c007e475b18355f98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1de43f850cf14d42f9b601c63b15cff3049dd940", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1de43f850cf14d42f9b601c63b15cff3049dd940", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1de43f850cf14d42f9b601c63b15cff3049dd940", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1de43f850cf14d42f9b601c63b15cff3049dd940/comments", "author": null, "committer": null, "parents": [{"sha": "62760ffd155d4ff29cf8f3092d756016a953b99e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62760ffd155d4ff29cf8f3092d756016a953b99e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62760ffd155d4ff29cf8f3092d756016a953b99e"}], "stats": {"total": 316, "additions": 178, "deletions": 138}, "files": [{"sha": "1057ccba8b10d4fe2b13826980ee42da0dbad0c4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1de43f850cf14d42f9b601c63b15cff3049dd940/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1de43f850cf14d42f9b601c63b15cff3049dd940/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1de43f850cf14d42f9b601c63b15cff3049dd940", "patch": "@@ -1,3 +1,21 @@\n+2007-07-13  David Edelsohn  <edelsohn@gnu.org>\n+\n+\t* config/rs6000/spe.md (SPE_ACC_REGNO): Delete definition.\n+\t(SPEFSCR_REGNO): Delete definition.\n+\t* config/rs6000/rs6000.c: LINK_REGISTER_REGNUM -> LR_REGNO.\n+\tCOUNT_REGISTER_REGNUM -> CTR_REGNO.\n+\t* config/rs6000/rs6000.h: Do not define *_REGNO.\n+\tLINK_REGISTER_REGNUM -> LR_REGNO.\n+\tCOUNT_REGISTER_REGNUM -> CTR_REGNO.\n+\t* config/rs6000/predicates.md: LINK_REGISTER_REGNUM -> \tLR_REGNO.\n+\tCOUNT_REGISTER_REGNUM -> CTR_REGNO.\n+\t* config/rs6000/linux-unwind.h: Define R_LR, R_CR2, R_VR0,\n+\tR_VRSAVE, R_VSCR. Use them.\n+\t* config/rs6000/darwin-fallback.c: Define R_LR, R_CTR, R_CR2,\n+\tR_XER, R_VR0, R_VRSAVE, R_VSCR, R_SPEFSCR.  Use them.\n+\t* config/rs6000/rs6000.md: Define REGNO constants.  Use them.\n+\t* config/rs6000/aix.h: Define R_LR.  Use it.\n+\t\n 2007-07-13  Caroline Tice  <ctice@apple.com>\n \t\n \t* toplev.c (process_options): Turn flag_var_tracking_uninit off when"}, {"sha": "385f39c94e7907fba19ddf86c56847d63a64088d", "filename": "gcc/config/rs6000/aix.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1de43f850cf14d42f9b601c63b15cff3049dd940/gcc%2Fconfig%2Frs6000%2Faix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1de43f850cf14d42f9b601c63b15cff3049dd940/gcc%2Fconfig%2Frs6000%2Faix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faix.h?ref=1de43f850cf14d42f9b601c63b15cff3049dd940", "patch": "@@ -220,14 +220,16 @@\n    code that does the save/restore is generated by the linker, so\n    we have no good way to determine at compile time what to do.  */\n \n+#define R_LR 65\n+\n #ifdef __64BIT__\n #define MD_FROB_UPDATE_CONTEXT(CTX, FS)\t\t\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n     if ((FS)->regs.reg[2].how == REG_UNSAVED)\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n \tunsigned int *insn\t\t\t\t\t\t\\\n \t  = (unsigned int *)\t\t\t\t\t\t\\\n-\t    _Unwind_GetGR ((CTX), LINK_REGISTER_REGNUM);\t\t\\\n+\t    _Unwind_GetGR ((CTX), R_LR);\t\t\t\t\\\n \tif (*insn == 0xE8410028)\t\t\t\t\t\\\n \t  _Unwind_SetGRPtr ((CTX), 2, (CTX)->cfa + 40);\t\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n@@ -239,7 +241,7 @@\n       {\t\t\t\t\t\t\t\t\t\\\n \tunsigned int *insn\t\t\t\t\t\t\\\n \t  = (unsigned int *)\t\t\t\t\t\t\\\n-\t    _Unwind_GetGR ((CTX), LINK_REGISTER_REGNUM);\t\t\\\n+\t    _Unwind_GetGR ((CTX), R_LR);\t\t\t\t\\\n \tif (*insn == 0x80410014)\t\t\t\t\t\\\n \t  _Unwind_SetGRPtr ((CTX), 2, (CTX)->cfa + 20);\t\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\"}, {"sha": "11a5e9801645cfd602cd243a46d529fb6b1608d7", "filename": "gcc/config/rs6000/darwin-fallback.c", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1de43f850cf14d42f9b601c63b15cff3049dd940/gcc%2Fconfig%2Frs6000%2Fdarwin-fallback.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1de43f850cf14d42f9b601c63b15cff3049dd940/gcc%2Fconfig%2Frs6000%2Fdarwin-fallback.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fdarwin-fallback.c?ref=1de43f850cf14d42f9b601c63b15cff3049dd940", "patch": "@@ -41,6 +41,15 @@\n #include <sys/types.h>\n #include <signal.h>\n \n+#define R_LR\t\t65\n+#define R_CTR\t\t66\n+#define R_CR2\t\t70\n+#define R_XER\t\t76\n+#define R_VR0\t\t77\n+#define R_VRSAVE\t109\n+#define R_VSCR\t\t110\n+#define R_SPEFSCR\t112\n+\n typedef unsigned long reg_unit;\n \n /* Place in GPRS the parameters to the first 'sc' instruction that would\n@@ -383,14 +392,14 @@ handle_syscall (_Unwind_FrameState *fs, const reg_unit gprs[32],\n \n       new_cfa = m64->gpr[1][1];\n       \n-      set_offset (CR2_REGNO, &m64->cr);\n+      set_offset (R_CR2, &m64->cr);\n       for (i = 0; i < 32; i++)\n \tset_offset (i, m64->gpr[i] + 1);\n-      set_offset (XER_REGNO, m64->xer + 1);\n-      set_offset (LINK_REGISTER_REGNUM, m64->lr + 1);\n-      set_offset (COUNT_REGISTER_REGNUM, m64->ctr + 1);\n+      set_offset (R_XER, m64->xer + 1);\n+      set_offset (R_LR, m64->lr + 1);\n+      set_offset (R_CTR, m64->ctr + 1);\n       if (is_vector)\n-\tset_offset (VRSAVE_REGNO, &m64->vrsave);\n+\tset_offset (R_VRSAVE, &m64->vrsave);\n       \n       /* Sometimes, srr0 points to the instruction that caused the exception,\n \t and sometimes to the next instruction to be executed; we want\n@@ -411,15 +420,15 @@ handle_syscall (_Unwind_FrameState *fs, const reg_unit gprs[32],\n       \n       new_cfa = m->gpr[1];\n \n-      set_offset (CR2_REGNO, &m->cr);\n+      set_offset (R_CR2, &m->cr);\n       for (i = 0; i < 32; i++)\n \tset_offset (i, m->gpr + i);\n-      set_offset (XER_REGNO, &m->xer);\n-      set_offset (LINK_REGISTER_REGNUM, &m->lr);\n-      set_offset (COUNT_REGISTER_REGNUM, &m->ctr);\n+      set_offset (R_XER, &m->xer);\n+      set_offset (R_LR, &m->lr);\n+      set_offset (R_CTR, &m->ctr);\n \n       if (is_vector)\n-\tset_offset (VRSAVE_REGNO, &m->vrsave);\n+\tset_offset (R_VRSAVE, &m->vrsave);\n \n       /* Sometimes, srr0 points to the instruction that caused the exception,\n \t and sometimes to the next instruction to be executed; we want\n@@ -449,13 +458,13 @@ handle_syscall (_Unwind_FrameState *fs, const reg_unit gprs[32],\n \n   for (i = 0; i < 32; i++)\n     set_offset (32 + i, float_vector_state->fpregs + i);\n-  set_offset (SPEFSCR_REGNO, &float_vector_state->fpscr);\n+  set_offset (R_SPEFSCR, &float_vector_state->fpscr);\n   \n   if (is_vector)\n     {\n       for (i = 0; i < 32; i++)\n-\tset_offset (FIRST_ALTIVEC_REGNO + i, float_vector_state->save_vr + i);\n-      set_offset (VSCR_REGNO, float_vector_state->save_vscr);\n+\tset_offset (R_VR0 + i, float_vector_state->save_vr + i);\n+      set_offset (R_VSCR, float_vector_state->save_vscr);\n     }\n \n   return true;"}, {"sha": "18b0faa4c25cf3a9e8a85b643a38a42c41ddb33e", "filename": "gcc/config/rs6000/linux-unwind.h", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1de43f850cf14d42f9b601c63b15cff3049dd940/gcc%2Fconfig%2Frs6000%2Flinux-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1de43f850cf14d42f9b601c63b15cff3049dd940/gcc%2Fconfig%2Frs6000%2Flinux-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flinux-unwind.h?ref=1de43f850cf14d42f9b601c63b15cff3049dd940", "patch": "@@ -1,5 +1,5 @@\n /* DWARF2 EH unwinding support for PowerPC and PowerPC64 Linux.\n-   Copyright (C) 2004, 2005, 2006 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n \n    This file is part of GCC.\n \n@@ -32,6 +32,12 @@\n    these structs elsewhere;  Many fields are missing, particularly\n    from the end of the structures.  */\n \n+#define R_LR\t\t65\n+#define R_CR2\t\t70\n+#define R_VR0\t\t77\n+#define R_VRSAVE\t109\n+#define R_VSCR\t\t110\n+\n struct gcc_vregs\n {\n   __attribute__ ((vector_size (16))) int vr[32];\n@@ -243,11 +249,11 @@ ppc_fallback_frame_state (struct _Unwind_Context *context,\n \tfs->regs.reg[i].loc.offset = (long) &regs->gpr[i] - new_cfa;\n       }\n \n-  fs->regs.reg[CR2_REGNO].how = REG_SAVED_OFFSET;\n-  fs->regs.reg[CR2_REGNO].loc.offset = (long) &regs->ccr - new_cfa;\n+  fs->regs.reg[R_CR2].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[R_CR2].loc.offset = (long) &regs->ccr - new_cfa;\n \n-  fs->regs.reg[LINK_REGISTER_REGNUM].how = REG_SAVED_OFFSET;\n-  fs->regs.reg[LINK_REGISTER_REGNUM].loc.offset = (long) &regs->link - new_cfa;\n+  fs->regs.reg[R_LR].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[R_LR].loc.offset = (long) &regs->link - new_cfa;\n \n   fs->regs.reg[ARG_POINTER_REGNUM].how = REG_SAVED_OFFSET;\n   fs->regs.reg[ARG_POINTER_REGNUM].loc.offset = (long) &regs->nip - new_cfa;\n@@ -288,17 +294,17 @@ ppc_fallback_frame_state (struct _Unwind_Context *context,\n \t{\n \t  for (i = 0; i < 32; i++)\n \t    {\n-\t      fs->regs.reg[i + FIRST_ALTIVEC_REGNO].how = REG_SAVED_OFFSET;\n-\t      fs->regs.reg[i + FIRST_ALTIVEC_REGNO].loc.offset\n+\t      fs->regs.reg[i + R_VR0].how = REG_SAVED_OFFSET;\n+\t      fs->regs.reg[i + R_VR0].loc.offset\n \t\t= (long) &vregs[i] - new_cfa;\n \t    }\n \n-\t  fs->regs.reg[VSCR_REGNO].how = REG_SAVED_OFFSET;\n-\t  fs->regs.reg[VSCR_REGNO].loc.offset = (long) &vregs->vscr - new_cfa;\n+\t  fs->regs.reg[R_VSCR].how = REG_SAVED_OFFSET;\n+\t  fs->regs.reg[R_VSCR].loc.offset = (long) &vregs->vscr - new_cfa;\n \t}\n \n-      fs->regs.reg[VRSAVE_REGNO].how = REG_SAVED_OFFSET;\n-      fs->regs.reg[VRSAVE_REGNO].loc.offset = (long) &vregs->vsave - new_cfa;\n+      fs->regs.reg[R_VRSAVE].how = REG_SAVED_OFFSET;\n+      fs->regs.reg[R_VRSAVE].loc.offset = (long) &vregs->vsave - new_cfa;\n     }\n \n   /* If we have SPE register high-parts... we check at compile-time to\n@@ -351,7 +357,7 @@ frob_update_context (struct _Unwind_Context *context, _Unwind_FrameState *fs ATT\n \t code that does the save/restore is generated by the linker, so\n \t we have no good way to determine at compile time what to do.  */\n       unsigned int *insn\n-\t= (unsigned int *) _Unwind_GetGR (context, LINK_REGISTER_REGNUM);\n+\t= (unsigned int *) _Unwind_GetGR (context, R_LR);\n       if (*insn == 0xE8410028)\n \t_Unwind_SetGRPtr (context, 2, context->cfa + 40);\n     }"}, {"sha": "8bcac9137d7bf558422b7e13b4b8d8d8185b0f0f", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1de43f850cf14d42f9b601c63b15cff3049dd940/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1de43f850cf14d42f9b601c63b15cff3049dd940/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=1de43f850cf14d42f9b601c63b15cff3049dd940", "patch": "@@ -29,7 +29,7 @@\n ;; Return 1 if op is COUNT register.\n (define_predicate \"count_register_operand\"\n   (and (match_code \"reg\")\n-       (match_test \"REGNO (op) == COUNT_REGISTER_REGNUM\n+       (match_test \"REGNO (op) == CTR_REGNO\n \t\t    || REGNO (op) > LAST_VIRTUAL_REGISTER\")))\n   \n ;; Return 1 if op is an Altivec register.\n@@ -686,8 +686,8 @@\n ;; to CALL.  This is a SYMBOL_REF, a pseudo-register, LR or CTR.\n (define_predicate \"call_operand\"\n   (if_then_else (match_code \"reg\")\n-     (match_test \"REGNO (op) == LINK_REGISTER_REGNUM\n-\t\t  || REGNO (op) == COUNT_REGISTER_REGNUM\n+     (match_test \"REGNO (op) == LR_REGNO\n+\t\t  || REGNO (op) == CTR_REGNO\n \t\t  || REGNO (op) >= FIRST_PSEUDO_REGISTER\")\n      (match_code \"symbol_ref\")))\n "}, {"sha": "2d4f5e85089e3cd8f89395a3b870e5c2c2e3460d", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1de43f850cf14d42f9b601c63b15cff3049dd940/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1de43f850cf14d42f9b601c63b15cff3049dd940/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=1de43f850cf14d42f9b601c63b15cff3049dd940", "patch": "@@ -3493,7 +3493,7 @@ rs6000_legitimize_tls_address (rtx addr, enum tls_model model)\n \n \t\t  first = emit_insn (gen_load_toc_v4_PIC_1b (gsym));\n \t\t  emit_move_insn (tmp1,\n-\t\t\t\t  gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM));\n+\t\t\t\t  gen_rtx_REG (Pmode, LR_REGNO));\n \t\t  emit_move_insn (tmp2, mem);\n \t\t  emit_insn (gen_addsi3 (tmp3, tmp1, tmp2));\n \t\t  last = emit_move_insn (got, tmp3);\n@@ -11067,10 +11067,10 @@ print_operand (FILE *file, rtx x, int code)\n \n     case 'T':\n       /* Print the symbolic name of a branch target register.  */\n-      if (GET_CODE (x) != REG || (REGNO (x) != LINK_REGISTER_REGNUM\n-\t\t\t\t  && REGNO (x) != COUNT_REGISTER_REGNUM))\n+      if (GET_CODE (x) != REG || (REGNO (x) != LR_REGNO\n+\t\t\t\t  && REGNO (x) != CTR_REGNO))\n \toutput_operand_lossage (\"invalid %%T value\");\n-      else if (REGNO (x) == LINK_REGISTER_REGNUM)\n+      else if (REGNO (x) == LR_REGNO)\n \tfputs (TARGET_NEW_MNEMONICS ? \"lr\" : \"r\", file);\n       else\n \tfputs (\"ctr\", file);\n@@ -13532,7 +13532,7 @@ rs6000_stack_info (void)\n       || rs6000_ra_ever_killed ())\n     {\n       info_ptr->lr_save_p = 1;\n-      df_set_regs_ever_live (LINK_REGISTER_REGNUM, true);\n+      df_set_regs_ever_live (LR_REGNO, true);\n     }\n \n   /* Determine if we need to save the condition code registers.  */\n@@ -13956,7 +13956,7 @@ rs6000_return_addr (int count, rtx frame)\n     }\n \n   cfun->machine->ra_need_lr = 1;\n-  return get_hard_reg_initial_val (Pmode, LINK_REGISTER_REGNUM);\n+  return get_hard_reg_initial_val (Pmode, LR_REGNO);\n }\n \n /* Say whether a function is a candidate for sibcall handling or not.\n@@ -14042,7 +14042,7 @@ rs6000_ra_ever_killed (void)\n   push_topmost_sequence ();\n   top = get_insns ();\n   pop_topmost_sequence ();\n-  reg = gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM);\n+  reg = gen_rtx_REG (Pmode, LR_REGNO);\n \n   for (insn = NEXT_INSN (top); insn != NULL_RTX; insn = NEXT_INSN (insn))\n     {\n@@ -14053,7 +14053,7 @@ rs6000_ra_ever_killed (void)\n \t      if (!SIBLING_CALL_P (insn))\n \t\treturn 1;\n \t    }\n-\t  else if (find_regno_note (insn, REG_INC, LINK_REGISTER_REGNUM))\n+\t  else if (find_regno_note (insn, REG_INC, LR_REGNO))\n \t    return 1;\n \t  else if (set_of (reg, insn) != NULL_RTX\n \t\t   && !prologue_epilogue_contains (insn))\n@@ -14092,14 +14092,14 @@ rs6000_emit_load_toc_table (int fromprolog)\n \t}\n       emit_insn (gen_load_toc_v4_PIC_1 (lab));\n       emit_move_insn (tmp1,\n-\t\t\t     gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM));\n+\t\t\t     gen_rtx_REG (Pmode, LR_REGNO));\n       emit_insn (gen_load_toc_v4_PIC_3b (tmp2, tmp1, got, lab));\n       emit_insn (gen_load_toc_v4_PIC_3c (dest, tmp2, got, lab));\n     }\n   else if (TARGET_ELF && DEFAULT_ABI == ABI_V4 && flag_pic == 1)\n     {\n       emit_insn (gen_load_toc_v4_pic_si ());\n-      emit_move_insn (dest, gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM));\n+      emit_move_insn (dest, gen_rtx_REG (Pmode, LR_REGNO));\n     }\n   else if (TARGET_ELF && DEFAULT_ABI != ABI_AIX && flag_pic == 2)\n     {\n@@ -14120,7 +14120,7 @@ rs6000_emit_load_toc_table (int fromprolog)\n \n \t  emit_insn (gen_load_toc_v4_PIC_1 (symF));\n \t  emit_move_insn (dest,\n-\t\t\t  gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM));\n+\t\t\t  gen_rtx_REG (Pmode, LR_REGNO));\n \t  emit_insn (gen_load_toc_v4_PIC_2 (temp0, dest, symL, symF));\n \t}\n       else\n@@ -14130,7 +14130,7 @@ rs6000_emit_load_toc_table (int fromprolog)\n \t  tocsym = gen_rtx_SYMBOL_REF (Pmode, toc_label_name);\n \t  emit_insn (gen_load_toc_v4_PIC_1b (tocsym));\n \t  emit_move_insn (dest,\n-\t\t\t  gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM));\n+\t\t\t  gen_rtx_REG (Pmode, LR_REGNO));\n \t  emit_move_insn (temp0, gen_rtx_MEM (Pmode, dest));\n \t}\n       emit_insn (gen_addsi3 (dest, temp0, dest));\n@@ -14191,7 +14191,7 @@ rs6000_emit_eh_reg_restore (rtx source, rtx scratch)\n       emit_move_insn (tmp, operands[0]);\n     }\n   else\n-    emit_move_insn (gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM), operands[0]);\n+    emit_move_insn (gen_rtx_REG (Pmode, LR_REGNO), operands[0]);\n }\n \n static GTY(()) int set = -1;\n@@ -14773,7 +14773,7 @@ rs6000_emit_prologue (void)\n       if (info->lr_save_p)\n \t{\n \t  insn = emit_move_insn (reg0,\n-\t\t\t\t gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM));\n+\t\t\t\t gen_rtx_REG (Pmode, LR_REGNO));\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n \t}\n \n@@ -14806,7 +14806,7 @@ rs6000_emit_prologue (void)\n       j = 0;\n       RTVEC_ELT (p, j++) = gen_rtx_CLOBBER (VOIDmode,\n \t\t\t\t\t    gen_rtx_REG (SImode,\n-\t\t\t\t\t\t\t LINK_REGISTER_REGNUM));\n+\t\t\t\t\t\t\t LR_REGNO));\n       RTVEC_ELT (p, j++) = gen_rtx_USE (VOIDmode,\n \t\t\t\t\tgen_rtx_SYMBOL_REF (Pmode,\n \t\t\t\t\t\t\t    \"*save_world\"));\n@@ -14881,7 +14881,7 @@ rs6000_emit_prologue (void)\n       rtx addr, reg, mem;\n \n       insn = emit_move_insn (gen_rtx_REG (Pmode, 0),\n-\t\t\t     gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM));\n+\t\t\t     gen_rtx_REG (Pmode, LR_REGNO));\n       RTX_FRAME_RELATED_P (insn) = 1;\n \n       addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n@@ -14940,7 +14940,7 @@ rs6000_emit_prologue (void)\n \n       RTVEC_ELT (p, 0) = gen_rtx_CLOBBER (VOIDmode,\n \t\t\t\t\t  gen_rtx_REG (Pmode,\n-\t\t\t\t\t\t       LINK_REGISTER_REGNUM));\n+\t\t\t\t\t\t       LR_REGNO));\n       sprintf (rname, \"%s%d%s\", SAVE_FP_PREFIX,\n \t       info->first_fp_reg_save - 32, SAVE_FP_SUFFIX);\n       alloc_rname = ggc_strdup (rname);\n@@ -15261,7 +15261,7 @@ rs6000_emit_prologue (void)\n \t\t\t\t      && EDGE_COUNT (EXIT_BLOCK_PTR->preds) > 0);\n       if (save_LR_around_toc_setup)\n \t{\n-\t  rtx lr = gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM);\n+\t  rtx lr = gen_rtx_REG (Pmode, LR_REGNO);\n \n \t  insn = emit_move_insn (frame_ptr_rtx, lr);\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n@@ -15279,7 +15279,7 @@ rs6000_emit_prologue (void)\n   if (DEFAULT_ABI == ABI_DARWIN\n       && flag_pic && current_function_uses_pic_offset_table)\n     {\n-      rtx lr = gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM);\n+      rtx lr = gen_rtx_REG (Pmode, LR_REGNO);\n       rtx src = machopic_function_base_sym ();\n \n       /* Save and restore LR locally around this call (in R0).  */\n@@ -15435,7 +15435,7 @@ rs6000_emit_epilogue (int sibcall)\n       RTVEC_ELT (p, j++) = gen_rtx_RETURN (VOIDmode);\n       RTVEC_ELT (p, j++) = gen_rtx_USE (VOIDmode,\n \t\t\t\t\tgen_rtx_REG (Pmode,\n-\t\t\t\t\t\t     LINK_REGISTER_REGNUM));\n+\t\t\t\t\t\t     LR_REGNO));\n       RTVEC_ELT (p, j++)\n \t= gen_rtx_USE (VOIDmode, gen_rtx_SYMBOL_REF (Pmode, alloc_rname));\n       /* The instruction pattern requires a clobber here;\n@@ -15592,7 +15592,7 @@ rs6000_emit_epilogue (int sibcall)\n \n   /* Set LR here to try to overlap restores below.  */\n   if (info->lr_save_p)\n-    emit_move_insn (gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM),\n+    emit_move_insn (gen_rtx_REG (Pmode, LR_REGNO),\n \t\t    gen_rtx_REG (Pmode, 0));\n \n   /* Load exception handler data registers, if needed.  */\n@@ -15814,7 +15814,7 @@ rs6000_emit_epilogue (int sibcall)\n       RTVEC_ELT (p, 0) = gen_rtx_RETURN (VOIDmode);\n       RTVEC_ELT (p, 1) = gen_rtx_USE (VOIDmode,\n \t\t\t\t      gen_rtx_REG (Pmode,\n-\t\t\t\t\t\t   LINK_REGISTER_REGNUM));\n+\t\t\t\t\t\t   LR_REGNO));\n \n       /* If we have to restore more than two FP registers, branch to the\n \t restore function.  It will return to our caller.  */\n@@ -16255,7 +16255,7 @@ rs6000_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \t\t\tgen_rtx_USE (VOIDmode, const0_rtx),\n \t\t\tgen_rtx_USE (VOIDmode,\n \t\t\t\t     gen_rtx_REG (SImode,\n-\t\t\t\t\t\t  LINK_REGISTER_REGNUM)),\n+\t\t\t\t\t\t  LR_REGNO)),\n \t\t\tgen_rtx_RETURN (VOIDmode))));\n   SIBLING_CALL_P (insn) = 1;\n   emit_barrier ();\n@@ -16904,7 +16904,7 @@ output_profile_hook (int labelno ATTRIBUTE_UNUSED)\n   else if (DEFAULT_ABI == ABI_DARWIN)\n     {\n       const char *mcount_name = RS6000_MCOUNT;\n-      int caller_addr_regno = LINK_REGISTER_REGNUM;\n+      int caller_addr_regno = LR_REGNO;\n \n       /* Be conservative and always set this, at least for now.  */\n       current_function_uses_pic_offset_table = 1;\n@@ -20903,9 +20903,9 @@ rs6000_dbx_register_number (unsigned int regno)\n     return regno;\n   if (regno == MQ_REGNO)\n     return 100;\n-  if (regno == LINK_REGISTER_REGNUM)\n+  if (regno == LR_REGNO)\n     return 108;\n-  if (regno == COUNT_REGISTER_REGNUM)\n+  if (regno == CTR_REGNO)\n     return 109;\n   if (CR_REGNO_P (regno))\n     return regno - CR0_REGNO + 86;"}, {"sha": "475e4667fa2a50e325f5ce4d719f6f3de504683d", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 7, "deletions": 26, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1de43f850cf14d42f9b601c63b15cff3049dd940/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1de43f850cf14d42f9b601c63b15cff3049dd940/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=1de43f850cf14d42f9b601c63b15cff3049dd940", "patch": "@@ -724,21 +724,7 @@ extern enum rs6000_nop_insertion rs6000_sched_insert_nops;\n    , 0, 0, 0                                       \\\n }\n \n-#define MQ_REGNO     64\n-#define CR0_REGNO    68\n-#define CR1_REGNO    69\n-#define CR2_REGNO    70\n-#define CR3_REGNO    71\n-#define CR4_REGNO    72\n-#define MAX_CR_REGNO 75\n-#define XER_REGNO    76\n-#define FIRST_ALTIVEC_REGNO\t77\n-#define LAST_ALTIVEC_REGNO\t108\n #define TOTAL_ALTIVEC_REGS\t(LAST_ALTIVEC_REGNO - FIRST_ALTIVEC_REGNO + 1)\n-#define VRSAVE_REGNO\t\t109\n-#define VSCR_REGNO\t\t110\n-#define SPE_ACC_REGNO\t\t111\n-#define SPEFSCR_REGNO\t\t112\n \n #define FIRST_SAVED_ALTIVEC_REGNO (FIRST_ALTIVEC_REGNO+20)\n #define FIRST_SAVED_FP_REGNO    (14+32)\n@@ -812,10 +798,10 @@ extern enum rs6000_nop_insertion rs6000_sched_insert_nops;\n #define FP_REGNO_P(N) ((N) >= 32 && (N) <= 63)\n \n /* True if register is a condition register.  */\n-#define CR_REGNO_P(N) ((N) >= 68 && (N) <= 75)\n+#define CR_REGNO_P(N) ((N) >= CR0_REGNO && (N) <= CR7_REGNO)\n \n /* True if register is a condition register, but not cr0.  */\n-#define CR_REGNO_NOT_CR0_P(N) ((N) >= 69 && (N) <= 75)\n+#define CR_REGNO_NOT_CR0_P(N) ((N) >= CR1_REGNO && (N) <= CR7_REGNO)\n \n /* True if register is an integer register.  */\n #define INT_REGNO_P(N) \\\n@@ -952,11 +938,6 @@ extern enum rs6000_nop_insertion rs6000_sched_insert_nops;\n /* Place to put static chain when calling a function that requires it.  */\n #define STATIC_CHAIN_REGNUM 11\n \n-/* Link register number.  */\n-#define LINK_REGISTER_REGNUM 65\n-\n-/* Count register number.  */\n-#define COUNT_REGISTER_REGNUM 66\n \f\n /* Define the classes of registers for register constraints in the\n    machine description.  Also define ranges of constants.\n@@ -1085,8 +1066,8 @@ enum reg_class\n   : (REGNO) == CR0_REGNO ? CR0_REGS\t\t\\\n   : CR_REGNO_P (REGNO) ? CR_REGS\t\t\\\n   : (REGNO) == MQ_REGNO ? MQ_REGS\t\t\\\n-  : (REGNO) == LINK_REGISTER_REGNUM ? LINK_REGS\t\\\n-  : (REGNO) == COUNT_REGISTER_REGNUM ? CTR_REGS\t\\\n+  : (REGNO) == LR_REGNO ? LINK_REGS\t\\\n+  : (REGNO) == CTR_REGNO ? CTR_REGS\t\\\n   : (REGNO) == ARG_POINTER_REGNUM ? BASE_REGS\t\\\n   : (REGNO) == XER_REGNO ? XER_REGS\t\t\\\n   : (REGNO) == VRSAVE_REGNO ? VRSAVE_REGS\t\\\n@@ -1503,7 +1484,7 @@ typedef struct rs6000_args\n    needed.  */\n \n #define\tEPILOGUE_USES(REGNO)\t\t\t\t\t\\\n-  ((reload_completed && (REGNO) == LINK_REGISTER_REGNUM)\t\\\n+  ((reload_completed && (REGNO) == LR_REGNO)\t\t\t\\\n    || (TARGET_ALTIVEC && (REGNO) == VRSAVE_REGNO)\t\t\\\n    || (current_function_calls_eh_return\t\t\t\t\\\n        && TARGET_AIX\t\t\t\t\t\t\\\n@@ -2244,8 +2225,8 @@ extern char rs6000_reg_names[][8];\t/* register names (0 vs. %r0).  */\n    dwarf2 unwind information.  This also enables the table driven\n    mechanism.  */\n \n-#define INCOMING_RETURN_ADDR_RTX   gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM)\n-#define DWARF_FRAME_RETURN_COLUMN  DWARF_FRAME_REGNUM (LINK_REGISTER_REGNUM)\n+#define INCOMING_RETURN_ADDR_RTX   gen_rtx_REG (Pmode, LR_REGNO)\n+#define DWARF_FRAME_RETURN_COLUMN  DWARF_FRAME_REGNUM (LR_REGNO)\n \n /* Describe how we implement __builtin_eh_return.  */\n #define EH_RETURN_DATA_REGNO(N) ((N) < 4 ? (N) + 3 : INVALID_REGNUM)"}, {"sha": "92648a022a36af4f9793802b906c9204b8467e64", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 79, "deletions": 52, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1de43f850cf14d42f9b601c63b15cff3049dd940/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1de43f850cf14d42f9b601c63b15cff3049dd940/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=1de43f850cf14d42f9b601c63b15cff3049dd940", "patch": "@@ -23,6 +23,33 @@\n \n ;;- See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n \n+;;\n+;; REGNOS\n+;;\n+\n+(define_constants\n+  [(MQ_REGNO\t\t\t64)\n+   (LR_REGNO\t\t\t65)\n+   (CTR_REGNO\t\t\t66)\n+   (CR0_REGNO\t\t\t68)\n+   (CR1_REGNO\t\t\t69)\n+   (CR2_REGNO\t\t\t70)\n+   (CR3_REGNO\t\t\t71)\n+   (CR4_REGNO\t\t\t72)\n+   (CR5_REGNO\t\t\t73)\n+   (CR6_REGNO\t\t\t74)\n+   (CR7_REGNO\t\t\t75)\n+   (MAX_CR_REGNO\t\t75)\n+   (XER_REGNO\t\t\t76)\n+   (FIRST_ALTIVEC_REGNO\t\t77)\n+   (LAST_ALTIVEC_REGNO\t\t108)\n+   (VRSAVE_REGNO\t\t109)\n+   (VSCR_REGNO\t\t\t110)\n+   (SPE_ACC_REGNO\t\t111)\n+   (SPEFSCR_REGNO\t\t112)\n+   (SFP_REGNO\t\t\t113)\n+  ])\n+\n ;;\n ;; UNSPEC usage\n ;;\n@@ -2714,7 +2741,7 @@\n \t (lshiftrt:DI (mult:DI (sign_extend:DI (reg:SI 3))\n \t\t\t       (sign_extend:DI (reg:SI 4)))\n \t\t      (const_int 32))))\n-   (clobber (reg:SI 65))]\n+   (clobber (reg:SI LR_REGNO))]\n   \"! TARGET_POWER && ! TARGET_POWERPC\"\n   \"bla __mulh\"\n   [(set_attr \"type\" \"imul\")])\n@@ -2723,7 +2750,7 @@\n   [(set (reg:DI 3)\n \t(mult:DI (sign_extend:DI (reg:SI 3))\n \t\t (sign_extend:DI (reg:SI 4))))\n-   (clobber (reg:SI 65))\n+   (clobber (reg:SI LR_REGNO))\n    (clobber (reg:SI 0))]\n   \"! TARGET_POWER && ! TARGET_POWERPC\"\n   \"bla __mull\"\n@@ -2734,7 +2761,7 @@\n \t(div:SI (reg:SI 3) (reg:SI 4)))\n    (set (reg:SI 4)\n \t(mod:SI (reg:SI 3) (reg:SI 4)))\n-   (clobber (reg:SI 65))\n+   (clobber (reg:SI LR_REGNO))\n    (clobber (reg:SI 0))]\n   \"! TARGET_POWER && ! TARGET_POWERPC\"\n   \"bla __divss\"\n@@ -2745,29 +2772,29 @@\n \t(udiv:SI (reg:SI 3) (reg:SI 4)))\n    (set (reg:SI 4)\n \t(umod:SI (reg:SI 3) (reg:SI 4)))\n-   (clobber (reg:SI 65))\n+   (clobber (reg:SI LR_REGNO))\n    (clobber (reg:SI 0))\n    (clobber (match_scratch:CC 0 \"=x\"))\n-   (clobber (reg:CC 69))]\n+   (clobber (reg:CC CR1_REGNO))]\n   \"! TARGET_POWER && ! TARGET_POWERPC\"\n   \"bla __divus\"\n   [(set_attr \"type\" \"idiv\")])\n \n (define_insn \"quoss_call\"\n   [(set (reg:SI 3)\n \t(div:SI (reg:SI 3) (reg:SI 4)))\n-   (clobber (reg:SI 65))]\n+   (clobber (reg:SI LR_REGNO))]\n   \"! TARGET_POWER && ! TARGET_POWERPC\"\n   \"bla __quoss\"\n   [(set_attr \"type\" \"idiv\")])\n \n (define_insn \"quous_call\"\n   [(set (reg:SI 3)\n \t(udiv:SI (reg:SI 3) (reg:SI 4)))\n-   (clobber (reg:SI 65))\n+   (clobber (reg:SI LR_REGNO))\n    (clobber (reg:SI 0))\n    (clobber (match_scratch:CC 0 \"=x\"))\n-   (clobber (reg:CC 69))]\n+   (clobber (reg:CC CR1_REGNO))]\n   \"! TARGET_POWER && ! TARGET_POWERPC\"\n   \"bla __quous\"\n   [(set_attr \"type\" \"idiv\")])\n@@ -10491,15 +10518,15 @@\n   [(set_attr \"type\" \"load\")])\n \n (define_insn \"load_toc_v4_pic_si\"\n-  [(set (reg:SI 65)\n+  [(set (reg:SI LR_REGNO)\n \t(unspec:SI [(const_int 0)] UNSPEC_TOC))]\n   \"DEFAULT_ABI == ABI_V4 && flag_pic == 1 && TARGET_32BIT\"\n   \"bl _GLOBAL_OFFSET_TABLE_@local-4\"\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"4\")])\n \n (define_insn \"load_toc_v4_PIC_1\"\n-  [(set (reg:SI 65)\n+  [(set (reg:SI LR_REGNO)\n \t(match_operand:SI 0 \"immediate_operand\" \"s\"))\n    (use (unspec [(match_dup 0)] UNSPEC_TOC))]\n   \"TARGET_ELF && DEFAULT_ABI != ABI_AIX\n@@ -10509,7 +10536,7 @@\n    (set_attr \"length\" \"4\")])\n \n (define_insn \"load_toc_v4_PIC_1b\"\n-  [(set (reg:SI 65)\n+  [(set (reg:SI LR_REGNO)\n \t(unspec:SI [(match_operand:SI 0 \"immediate_operand\" \"s\")]\n \t\tUNSPEC_TOCPTR))]\n   \"TARGET_ELF && DEFAULT_ABI != ABI_AIX && flag_pic == 2\"\n@@ -10569,7 +10596,7 @@\n       tmplabrtx = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (tmplab));\n \n       emit_insn (gen_load_macho_picbase (tmplabrtx));\n-      emit_move_insn (picreg, gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM));\n+      emit_move_insn (picreg, gen_rtx_REG (Pmode, LR_REGNO));\n       emit_insn (gen_macho_correct_pic (picreg, picreg, picrtx, tmplabrtx));\n     }\n   else\n@@ -10620,7 +10647,7 @@\n \t      (use (reg:SI 11))\n \t      (set (reg:SI 2)\n \t\t   (mem:SI (plus:SI (reg:SI 1) (const_int 20))))\n-\t      (clobber (reg:SI 65))])]\n+\t      (clobber (reg:SI LR_REGNO))])]\n   \"TARGET_32BIT\"\n   \"\n { operands[2] = gen_reg_rtx (SImode); }\")\n@@ -10642,7 +10669,7 @@\n \t      (use (reg:DI 11))\n \t      (set (reg:DI 2)\n \t\t   (mem:DI (plus:DI (reg:DI 1) (const_int 40))))\n-\t      (clobber (reg:SI 65))])]\n+\t      (clobber (reg:SI LR_REGNO))])]\n   \"TARGET_64BIT\"\n   \"\n { operands[2] = gen_reg_rtx (DImode); }\")\n@@ -10665,7 +10692,7 @@\n \t      (use (reg:SI 11))\n \t      (set (reg:SI 2)\n \t\t   (mem:SI (plus:SI (reg:SI 1) (const_int 20))))\n-\t      (clobber (reg:SI 65))])]\n+\t      (clobber (reg:SI LR_REGNO))])]\n   \"TARGET_32BIT\"\n   \"\n { operands[3] = gen_reg_rtx (SImode); }\")\n@@ -10688,7 +10715,7 @@\n \t      (use (reg:DI 11))\n \t      (set (reg:DI 2)\n \t\t   (mem:DI (plus:DI (reg:DI 1) (const_int 40))))\n-\t      (clobber (reg:SI 65))])]\n+\t      (clobber (reg:SI LR_REGNO))])]\n   \"TARGET_64BIT\"\n   \"\n { operands[3] = gen_reg_rtx (DImode); }\")\n@@ -10698,7 +10725,7 @@\n   [(parallel [(call (mem:SI (match_operand 0 \"address_operand\" \"\"))\n \t\t    (match_operand 1 \"\" \"\"))\n \t      (use (match_operand 2 \"\" \"\"))\n-\t      (clobber (reg:SI 65))])]\n+\t      (clobber (reg:SI LR_REGNO))])]\n   \"\"\n   \"\n {\n@@ -10726,8 +10753,7 @@\n \t\t\t\t     operands[1]),\n \t\t       gen_rtx_USE (VOIDmode, operands[2]),\n \t\t       gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t\tgen_rtx_REG (Pmode,\n-\t\t\t\t\t\t     LINK_REGISTER_REGNUM)));\n+\t\t\t\t\tgen_rtx_REG (Pmode, LR_REGNO)));\n       call = emit_call_insn (gen_rtx_PARALLEL (VOIDmode, tmp));\n       use_reg (&CALL_INSN_FUNCTION_USAGE (call), pic_offset_table_rtx);\n       DONE;\n@@ -10770,7 +10796,7 @@\n \t\t   (call (mem:SI (match_operand 1 \"address_operand\" \"\"))\n \t\t\t (match_operand 2 \"\" \"\")))\n \t      (use (match_operand 3 \"\" \"\"))\n-\t      (clobber (reg:SI 65))])]\n+\t      (clobber (reg:SI LR_REGNO))])]\n   \"\"\n   \"\n {\n@@ -10801,8 +10827,7 @@\n \t\t\t\t\t\t  operands[2])),\n \t\t       gen_rtx_USE (VOIDmode, operands[3]),\n \t\t       gen_rtx_CLOBBER (VOIDmode, \n-\t\t\t\t\tgen_rtx_REG (Pmode,\n-                                                     LINK_REGISTER_REGNUM)));\n+\t\t\t\t\tgen_rtx_REG (Pmode, LR_REGNO)));\n       call = emit_call_insn (gen_rtx_PARALLEL (VOIDmode, tmp));\n       use_reg (&CALL_INSN_FUNCTION_USAGE (call), pic_offset_table_rtx);\n       DONE;\n@@ -10852,7 +10877,7 @@\n   [(call (mem:SI (match_operand:SI 0 \"current_file_function_operand\" \"s,s\"))\n \t (match_operand 1 \"\" \"g,g\"))\n    (use (match_operand:SI 2 \"immediate_operand\" \"O,n\"))\n-   (clobber (reg:SI 65))]\n+   (clobber (reg:SI LR_REGNO))]\n   \"(INTVAL (operands[2]) & CALL_LONG) == 0\"\n   \"*\n {\n@@ -10871,7 +10896,7 @@\n   [(call (mem:SI (match_operand:DI 0 \"current_file_function_operand\" \"s,s\"))\n \t (match_operand 1 \"\" \"g,g\"))\n    (use (match_operand:SI 2 \"immediate_operand\" \"O,n\"))\n-   (clobber (reg:SI 65))]\n+   (clobber (reg:SI LR_REGNO))]\n   \"TARGET_64BIT && (INTVAL (operands[2]) & CALL_LONG) == 0\"\n   \"*\n {\n@@ -10891,7 +10916,7 @@\n \t(call (mem:SI (match_operand:SI 1 \"current_file_function_operand\" \"s,s\"))\n \t      (match_operand 2 \"\" \"g,g\")))\n    (use (match_operand:SI 3 \"immediate_operand\" \"O,n\"))\n-   (clobber (reg:SI 65))]\n+   (clobber (reg:SI LR_REGNO))]\n   \"(INTVAL (operands[3]) & CALL_LONG) == 0\"\n   \"*\n {\n@@ -10912,7 +10937,7 @@\n \t(call (mem:SI (match_operand:DI 1 \"current_file_function_operand\" \"s,s\"))\n \t      (match_operand 2 \"\" \"g,g\")))\n    (use (match_operand:SI 3 \"immediate_operand\" \"O,n\"))\n-   (clobber (reg:SI 65))]\n+   (clobber (reg:SI LR_REGNO))]\n   \"TARGET_64BIT && (INTVAL (operands[3]) & CALL_LONG) == 0\"\n   \"*\n {\n@@ -10941,7 +10966,7 @@\n    (use (reg:SI 11))\n    (set (reg:SI 2)\n \t(mem:SI (plus:SI (reg:SI 1) (const_int 20))))\n-   (clobber (reg:SI 65))]\n+   (clobber (reg:SI LR_REGNO))]\n   \"TARGET_32BIT && DEFAULT_ABI == ABI_AIX\"\n   \"b%T0l\\;{l|lwz} 2,20(1)\"\n   [(set_attr \"type\" \"jmpreg\")\n@@ -10951,7 +10976,7 @@\n   [(call (mem:SI (match_operand:SI 0 \"symbol_ref_operand\" \"s\"))\n \t (match_operand 1 \"\" \"g\"))\n    (use (match_operand:SI 2 \"immediate_operand\" \"O\"))\n-   (clobber (reg:SI 65))]\n+   (clobber (reg:SI LR_REGNO))]\n   \"TARGET_32BIT\n    && DEFAULT_ABI == ABI_AIX\n    && (INTVAL (operands[2]) & CALL_LONG) == 0\"\n@@ -10966,7 +10991,7 @@\n    (use (reg:DI 11))\n    (set (reg:DI 2)\n \t(mem:DI (plus:DI (reg:DI 1) (const_int 40))))\n-   (clobber (reg:SI 65))]\n+   (clobber (reg:SI LR_REGNO))]\n   \"TARGET_64BIT && DEFAULT_ABI == ABI_AIX\"\n   \"b%T0l\\;ld 2,40(1)\"\n   [(set_attr \"type\" \"jmpreg\")\n@@ -10976,7 +11001,7 @@\n   [(call (mem:SI (match_operand:DI 0 \"symbol_ref_operand\" \"s\"))\n \t (match_operand 1 \"\" \"g\"))\n    (use (match_operand:SI 2 \"immediate_operand\" \"O\"))\n-   (clobber (reg:SI 65))]\n+   (clobber (reg:SI LR_REGNO))]\n   \"TARGET_64BIT\n    && DEFAULT_ABI == ABI_AIX\n    && (INTVAL (operands[2]) & CALL_LONG) == 0\"\n@@ -10992,7 +11017,7 @@\n    (use (reg:SI 11))\n    (set (reg:SI 2)\n \t(mem:SI (plus:SI (reg:SI 1) (const_int 20))))\n-   (clobber (reg:SI 65))]\n+   (clobber (reg:SI LR_REGNO))]\n   \"TARGET_32BIT && DEFAULT_ABI == ABI_AIX\"\n   \"b%T1l\\;{l|lwz} 2,20(1)\"\n   [(set_attr \"type\" \"jmpreg\")\n@@ -11003,7 +11028,7 @@\n \t(call (mem:SI (match_operand:SI 1 \"symbol_ref_operand\" \"s\"))\n \t      (match_operand 2 \"\" \"g\")))\n    (use (match_operand:SI 3 \"immediate_operand\" \"O\"))\n-   (clobber (reg:SI 65))]\n+   (clobber (reg:SI LR_REGNO))]\n   \"TARGET_32BIT\n    && DEFAULT_ABI == ABI_AIX\n    && (INTVAL (operands[3]) & CALL_LONG) == 0\"\n@@ -11019,7 +11044,7 @@\n    (use (reg:DI 11))\n    (set (reg:DI 2)\n \t(mem:DI (plus:DI (reg:DI 1) (const_int 40))))\n-   (clobber (reg:SI 65))]\n+   (clobber (reg:SI LR_REGNO))]\n   \"TARGET_64BIT && DEFAULT_ABI == ABI_AIX\"\n   \"b%T1l\\;ld 2,40(1)\"\n   [(set_attr \"type\" \"jmpreg\")\n@@ -11030,7 +11055,7 @@\n \t(call (mem:SI (match_operand:DI 1 \"symbol_ref_operand\" \"s\"))\n \t      (match_operand 2 \"\" \"g\")))\n    (use (match_operand:SI 3 \"immediate_operand\" \"O\"))\n-   (clobber (reg:SI 65))]\n+   (clobber (reg:SI LR_REGNO))]\n   \"TARGET_64BIT\n    && DEFAULT_ABI == ABI_AIX\n    && (INTVAL (operands[3]) & CALL_LONG) == 0\"\n@@ -11048,7 +11073,7 @@\n   [(call (mem:SI (match_operand:P 0 \"register_operand\" \"c,*l,c,*l\"))\n \t (match_operand 1 \"\" \"g,g,g,g\"))\n    (use (match_operand:SI 2 \"immediate_operand\" \"O,O,n,n\"))\n-   (clobber (reg:SI 65))]\n+   (clobber (reg:SI LR_REGNO))]\n   \"DEFAULT_ABI == ABI_V4\n    || DEFAULT_ABI == ABI_DARWIN\"\n {\n@@ -11067,7 +11092,7 @@\n   [(call (mem:SI (match_operand:P 0 \"symbol_ref_operand\" \"s,s\"))\n \t (match_operand 1 \"\" \"g,g\"))\n    (use (match_operand:SI 2 \"immediate_operand\" \"O,n\"))\n-   (clobber (reg:SI 65))]\n+   (clobber (reg:SI LR_REGNO))]\n   \"(DEFAULT_ABI == ABI_DARWIN\n    || (DEFAULT_ABI == ABI_V4\n        && (INTVAL (operands[2]) & CALL_LONG) == 0))\"\n@@ -11103,7 +11128,7 @@\n \t(call (mem:SI (match_operand:P 1 \"register_operand\" \"c,*l,c,*l\"))\n \t      (match_operand 2 \"\" \"g,g,g,g\")))\n    (use (match_operand:SI 3 \"immediate_operand\" \"O,O,n,n\"))\n-   (clobber (reg:SI 65))]\n+   (clobber (reg:SI LR_REGNO))]\n   \"DEFAULT_ABI == ABI_V4\n    || DEFAULT_ABI == ABI_DARWIN\"\n {\n@@ -11123,7 +11148,7 @@\n \t(call (mem:SI (match_operand:P 1 \"symbol_ref_operand\" \"s,s\"))\n \t      (match_operand 2 \"\" \"g,g\")))\n    (use (match_operand:SI 3 \"immediate_operand\" \"O,n\"))\n-   (clobber (reg:SI 65))]\n+   (clobber (reg:SI LR_REGNO))]\n   \"(DEFAULT_ABI == ABI_DARWIN\n    || (DEFAULT_ABI == ABI_V4\n        && (INTVAL (operands[3]) & CALL_LONG) == 0))\"\n@@ -11184,7 +11209,7 @@\n   [(parallel [(call (mem:SI (match_operand 0 \"address_operand\" \"\"))\n \t\t    (match_operand 1 \"\" \"\"))\n \t      (use (match_operand 2 \"\" \"\"))\n-\t      (use (reg:SI 65))\n+\t      (use (reg:SI LR_REGNO))\n \t      (return)])]\n   \"\"\n   \"\n@@ -11208,7 +11233,7 @@\n   [(call (mem:SI (match_operand:SI 0 \"current_file_function_operand\" \"s,s\"))\n \t (match_operand 1 \"\" \"g,g\"))\n    (use (match_operand:SI 2 \"immediate_operand\" \"O,n\"))\n-   (use (reg:SI 65))\n+   (use (reg:SI LR_REGNO))\n    (return)]\n   \"(INTVAL (operands[2]) & CALL_LONG) == 0\"\n   \"*\n@@ -11228,7 +11253,7 @@\n   [(call (mem:SI (match_operand:DI 0 \"current_file_function_operand\" \"s,s\"))\n \t (match_operand 1 \"\" \"g,g\"))\n    (use (match_operand:SI 2 \"immediate_operand\" \"O,n\"))\n-   (use (reg:SI 65))\n+   (use (reg:SI LR_REGNO))\n    (return)]\n   \"TARGET_64BIT && (INTVAL (operands[2]) & CALL_LONG) == 0\"\n   \"*\n@@ -11249,7 +11274,7 @@\n \t(call (mem:SI (match_operand:SI 1 \"current_file_function_operand\" \"s,s\"))\n \t      (match_operand 2 \"\" \"g,g\")))\n    (use (match_operand:SI 3 \"immediate_operand\" \"O,n\"))\n-   (use (reg:SI 65))\n+   (use (reg:SI LR_REGNO))\n    (return)]\n   \"(INTVAL (operands[3]) & CALL_LONG) == 0\"\n   \"*\n@@ -11271,7 +11296,7 @@\n \t(call (mem:SI (match_operand:DI 1 \"current_file_function_operand\" \"s,s\"))\n \t      (match_operand 2 \"\" \"g,g\")))\n    (use (match_operand:SI 3 \"immediate_operand\" \"O,n\"))\n-   (use (reg:SI 65))\n+   (use (reg:SI LR_REGNO))\n    (return)]\n   \"TARGET_64BIT && (INTVAL (operands[3]) & CALL_LONG) == 0\"\n   \"*\n@@ -11291,7 +11316,7 @@\n   [(call (mem:SI (match_operand:SI 0 \"symbol_ref_operand\" \"s\"))\n \t (match_operand 1 \"\" \"g\"))\n    (use (match_operand:SI 2 \"immediate_operand\" \"O\"))\n-   (use (reg:SI 65))\n+   (use (reg:SI LR_REGNO))\n    (return)]\n   \"TARGET_32BIT\n    && DEFAULT_ABI == ABI_AIX\n@@ -11304,7 +11329,7 @@\n   [(call (mem:SI (match_operand:DI 0 \"symbol_ref_operand\" \"s\"))\n \t (match_operand 1 \"\" \"g\"))\n    (use (match_operand:SI 2 \"immediate_operand\" \"O\"))\n-   (use (reg:SI 65))\n+   (use (reg:SI LR_REGNO))\n    (return)]\n   \"TARGET_64BIT\n    && DEFAULT_ABI == ABI_AIX\n@@ -11318,7 +11343,7 @@\n \t(call (mem:SI (match_operand:SI 1 \"symbol_ref_operand\" \"s\"))\n \t      (match_operand 2 \"\" \"g\")))\n    (use (match_operand:SI 3 \"immediate_operand\" \"O\"))\n-   (use (reg:SI 65))\n+   (use (reg:SI LR_REGNO))\n    (return)]\n   \"TARGET_32BIT\n    && DEFAULT_ABI == ABI_AIX\n@@ -11332,7 +11357,7 @@\n \t(call (mem:SI (match_operand:DI 1 \"symbol_ref_operand\" \"s\"))\n \t      (match_operand 2 \"\" \"g\")))\n    (use (match_operand:SI 3 \"immediate_operand\" \"O\"))\n-   (use (reg:SI 65))\n+   (use (reg:SI LR_REGNO))\n    (return)]\n   \"TARGET_64BIT\n    && DEFAULT_ABI == ABI_AIX\n@@ -11345,7 +11370,7 @@\n   [(call (mem:SI (match_operand:P 0 \"symbol_ref_operand\" \"s,s\"))\n \t (match_operand 1 \"\" \"\"))\n    (use (match_operand 2 \"immediate_operand\" \"O,n\"))\n-   (use (reg:SI 65))\n+   (use (reg:SI LR_REGNO))\n    (return)]\n   \"(DEFAULT_ABI == ABI_DARWIN\n      || DEFAULT_ABI == ABI_V4)\n@@ -11376,7 +11401,7 @@\n \t\t(call (mem:SI (match_operand 1 \"address_operand\" \"\"))\n \t\t      (match_operand 2 \"\" \"\")))\n \t      (use (match_operand 3 \"\" \"\"))\n-\t      (use (reg:SI 65))\n+\t      (use (reg:SI LR_REGNO))\n \t      (return)])]\n   \"\"\n   \"\n@@ -11397,7 +11422,7 @@\n \t(call (mem:SI (match_operand:P 1 \"symbol_ref_operand\" \"s,s\"))\n \t      (match_operand 2 \"\" \"\")))\n    (use (match_operand:SI 3 \"immediate_operand\" \"O,n\"))\n-   (use (reg:SI 65))\n+   (use (reg:SI LR_REGNO))\n    (return)]\n   \"(DEFAULT_ABI == ABI_DARWIN\n        || DEFAULT_ABI == ABI_V4)\n@@ -14374,8 +14399,10 @@\n \n (define_insn \"movesi_from_cr\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-        (unspec:SI [(reg:CC 68) (reg:CC 69) (reg:CC 70) (reg:CC 71)\n-\t\t    (reg:CC 72)\t(reg:CC 73) (reg:CC 74) (reg:CC 75)]\n+        (unspec:SI [(reg:CC CR0_REGNO) (reg:CC CR1_REGNO)\n+\t\t    (reg:CC CR2_REGNO) (reg:CC CR3_REGNO)\n+\t\t    (reg:CC CR4_REGNO) (reg:CC CR5_REGNO)\n+\t\t    (reg:CC CR6_REGNO) (reg:CC CR7_REGNO)]\n \t\t   UNSPEC_MOVESI_FROM_CR))]\n   \"\"\n   \"mfcr %0\""}, {"sha": "28c40c5e9e3bd45cb11289a533b0a6635a82184e", "filename": "gcc/config/rs6000/spe.md", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1de43f850cf14d42f9b601c63b15cff3049dd940/gcc%2Fconfig%2Frs6000%2Fspe.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1de43f850cf14d42f9b601c63b15cff3049dd940/gcc%2Fconfig%2Frs6000%2Fspe.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fspe.md?ref=1de43f850cf14d42f9b601c63b15cff3049dd940", "patch": "@@ -21,10 +21,7 @@\n ;; MA 02110-1301, USA.\n \n (define_constants\n-  [(SPE_ACC_REGNO\t111)\n-   (SPEFSCR_REGNO\t112)\n-\n-   (CMPDFEQ_GPR\t\t1006)\n+  [(CMPDFEQ_GPR\t\t1006)\n    (TSTDFEQ_GPR\t\t1007)\n    (CMPDFGT_GPR\t\t1008)\n    (TSTDFGT_GPR\t\t1009)"}]}