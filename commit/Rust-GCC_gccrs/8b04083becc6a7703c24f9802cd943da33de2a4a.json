{"sha": "8b04083becc6a7703c24f9802cd943da33de2a4a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGIwNDA4M2JlY2M2YTc3MDNjMjRmOTgwMmNkOTQzZGEzM2RlMmE0YQ==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@tofu.to.cygnus.com", "date": "1999-05-05T13:30:51Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "1999-05-05T13:30:51Z"}, "message": "function.c (purge_addressof_replacements): Rename into purge_bitfield_addressof_replacements.\n\nWed May  5 16:26:13 1999  Vladimir Makarov  <vmakarov@tofu.to.cygnus.com>\n\t* function.c (purge_addressof_replacements): Rename into\n \tpurge_bitfield_addressof_replacements.\n\t(purge_addressof_replacements): New variable.\n\t(purge_addressof_1): Add code for changing addressof in notes for\n \tfield values which are extracted by usage MEM with narrower mode.\n\t(purge_addressof): Initialize purge_bitfield_addressof_replacements.\n\nFrom-SVN: r26784", "tree": {"sha": "13754bae153a54ceb8907f647de03fe66ccfbb4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/13754bae153a54ceb8907f647de03fe66ccfbb4c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b04083becc6a7703c24f9802cd943da33de2a4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b04083becc6a7703c24f9802cd943da33de2a4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b04083becc6a7703c24f9802cd943da33de2a4a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b04083becc6a7703c24f9802cd943da33de2a4a/comments", "author": null, "committer": null, "parents": [{"sha": "24dc3000ddb70742725cec46ee03b3cf9679c453", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24dc3000ddb70742725cec46ee03b3cf9679c453", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24dc3000ddb70742725cec46ee03b3cf9679c453"}], "stats": {"total": 134, "additions": 85, "deletions": 49}, "files": [{"sha": "a56814c51ad2a7841f6eabde58524fd337f74d15", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b04083becc6a7703c24f9802cd943da33de2a4a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b04083becc6a7703c24f9802cd943da33de2a4a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8b04083becc6a7703c24f9802cd943da33de2a4a", "patch": "@@ -1,3 +1,12 @@\n+Wed May  5 16:26:13 1999  Vladimir Makarov  <vmakarov@tofu.to.cygnus.com>\n+\n+\t* function.c (purge_addressof_replacements): Rename into\n+ \tpurge_bitfield_addressof_replacements.\n+\t(purge_addressof_replacements): New variable.\n+\t(purge_addressof_1): Add code for changing addressof in notes for\n+ \tfield values which are extracted by usage MEM with narrower mode.\n+\t(purge_addressof): Initialize purge_bitfield_addressof_replacements.\n+\n Wed May  5 07:40:02 1999  Nick Clifton  <nickc@cygnus.com>\n \n \tPatch from: Nick Burrett  <nick.burrett@btinternet.com>"}, {"sha": "0937844d812a1c26d60d7e29bb45f62a49b9e4e7", "filename": "gcc/function.c", "status": "modified", "additions": 76, "deletions": 49, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b04083becc6a7703c24f9802cd943da33de2a4a/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b04083becc6a7703c24f9802cd943da33de2a4a/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=8b04083becc6a7703c24f9802cd943da33de2a4a", "patch": "@@ -3031,6 +3031,14 @@ put_addressof_into_stack (r, ht)\n \n /* List of replacements made below in purge_addressof_1 when creating\n    bitfield insertions.  */\n+static rtx purge_bitfield_addressof_replacements;\n+\n+/* List of replacements made below in purge_addressof_1 for patterns\n+   (MEM (ADDRESSOF (REG ...))).  The key of the list entry is the\n+   corresponding (ADDRESSOF (REG ...)) and value is a substitution for\n+   the all pattern.  List PURGE_BITFIELD_ADDRESSOF_REPLACEMENTS is not\n+   enough in complex cases, e.g. when some field values can be\n+   extracted by usage MEM with narrower mode. */\n static rtx purge_addressof_replacements;\n \n /* Helper function for purge_addressof.  See if the rtx expression at *LOC\n@@ -3110,51 +3118,54 @@ purge_addressof_1 (loc, insn, force, store, ht)\n \t\t was replaced by.  */\n \t      rtx tem;\n \n-\t      for (tem = purge_addressof_replacements; tem != NULL_RTX;\n+\t      for (tem = purge_bitfield_addressof_replacements;\n+\t\t   tem != NULL_RTX;\n \t\t   tem = XEXP (XEXP (tem, 1), 1))\n-\t\t{\n-\t\t  rtx y = XEXP (tem, 0);\n-\t\t  if (GET_CODE (y) == MEM\n-\t\t      && rtx_equal_p (XEXP (x, 0), XEXP (y, 0)))\n-\t\t    {\n-\t\t      /* It can happen that the note may speak of things in\n-\t\t\t a wider (or just different) mode than the code did. \n-\t\t\t This is especially true of REG_RETVAL.  */\n+\t\tif (rtx_equal_p (x, XEXP (tem, 0)))\n+\t\t  {\n+\t\t    *loc = XEXP (XEXP (tem, 1), 0);\n+\t\t    return;\n+\t\t  }\n \n-\t\t      rtx z = XEXP (XEXP (tem, 1), 0);\n-\t\t      if (GET_MODE (x) != GET_MODE (y))\n-\t\t\t{\n-\t\t\t  if (GET_CODE (z) == SUBREG && SUBREG_WORD (z) == 0)\n-\t\t\t    z = SUBREG_REG (z);\n-\n-\t\t\t  /* ??? If we'd gotten into any of the really complex\n-\t\t\t     cases below, I'm not sure we can do a proper\n-\t\t\t     replacement.  Might we be able to delete the\n-\t\t\t     note in some cases?  */\n-\t\t\t  if (GET_MODE_SIZE (GET_MODE (x))\n-\t\t\t      < GET_MODE_SIZE (GET_MODE (y)))\n-\t\t\t    abort ();\n-\n-\t\t\t  if (GET_MODE_SIZE (GET_MODE (x)) > UNITS_PER_WORD\n-\t\t\t      && (GET_MODE_SIZE (GET_MODE (x))\n-\t\t\t\t  > GET_MODE_SIZE (GET_MODE (z))))\n-\t\t\t    {\n-\t\t\t      /* This can occur as a result in invalid\n-\t\t\t\t pointer casts, e.g. float f; ... \n-\t\t\t\t *(long long int *)&f.\n-\t\t\t\t ??? We could emit a warning here, but\n-\t\t\t\t without a line number that wouldn't be\n-\t\t\t\t very helpful.  */\n-\t\t\t      z = gen_rtx_SUBREG (GET_MODE (x), z, 0);\n-\t\t\t    }\n-\t\t\t  else\n-\t\t\t    z = gen_lowpart (GET_MODE (x), z);\n-\t\t\t}\n+\t      /* See comment for purge_addressof_replacements. */\n+\t      for (tem = purge_addressof_replacements;\n+\t\t   tem != NULL_RTX;\n+\t\t   tem = XEXP (XEXP (tem, 1), 1))\n+\t\tif (rtx_equal_p (XEXP (x, 0), XEXP (tem, 0)))\n+\t\t  {\n+\t\t    rtx z = XEXP (XEXP (tem, 1), 0);\n \n-\t\t      *loc = z;\n-\t\t      return;\n-\t\t    }\n-\t\t}\n+\t\t    if (GET_MODE (x) == GET_MODE (z)\n+\t\t\t|| (GET_CODE (XEXP (XEXP (tem, 1), 0)) != REG\n+\t\t\t    && GET_CODE (XEXP (XEXP (tem, 1), 0)) != SUBREG))\n+\t\t      abort ();\n+\n+\t\t    /* It can happen that the note may speak of things\n+\t\t       in a wider (or just different) mode than the\n+\t\t       code did.  This is especially true of\n+\t\t       REG_RETVAL. */\n+\n+\t\t    if (GET_CODE (z) == SUBREG && SUBREG_WORD (z) == 0)\n+\t\t      z = SUBREG_REG (z);\n+\t\t    \n+\t\t    if (GET_MODE_SIZE (GET_MODE (x)) > UNITS_PER_WORD\n+\t\t\t&& (GET_MODE_SIZE (GET_MODE (x))\n+\t\t\t    > GET_MODE_SIZE (GET_MODE (z))))\n+\t\t      {\n+\t\t\t/* This can occur as a result in invalid\n+\t\t\t   pointer casts, e.g. float f; ... \n+\t\t\t   *(long long int *)&f.\n+\t\t\t   ??? We could emit a warning here, but\n+\t\t\t   without a line number that wouldn't be\n+\t\t\t   very helpful.  */\n+\t\t\tz = gen_rtx_SUBREG (GET_MODE (x), z, 0);\n+\t\t      }\n+\t\t    else\n+\t\t      z = gen_lowpart (GET_MODE (x), z);\n+\n+\t\t    *loc = z;\n+\t\t    return;\n+\t\t  }\n \n \t      /* There should always be such a replacement.  */\n \t      abort ();\n@@ -3242,10 +3253,11 @@ purge_addressof_1 (loc, insn, force, store, ht)\n \n \t      /* Remember the replacement so that the same one can be done\n \t\t on the REG_NOTES.  */\n-\t      purge_addressof_replacements\n+\t      purge_bitfield_addressof_replacements\n \t\t= gen_rtx_EXPR_LIST (VOIDmode, x,\n-\t\t\t\t     gen_rtx_EXPR_LIST (VOIDmode, val,\n-\t\t\t\t\t\t\tpurge_addressof_replacements));\n+\t\t\t\t     gen_rtx_EXPR_LIST\n+\t\t\t\t     (VOIDmode, val,\n+\t\t\t\t      purge_bitfield_addressof_replacements));\n \n \t      /* We replaced with a reg -- all done.  */\n \t      return;\n@@ -3255,10 +3267,24 @@ purge_addressof_1 (loc, insn, force, store, ht)\n \t{\n \t  /* Remember the replacement so that the same one can be done\n \t     on the REG_NOTES.  */\n-\t  purge_addressof_replacements\n-\t    = gen_rtx_EXPR_LIST (VOIDmode, x,\n-\t\t\t\t gen_rtx_EXPR_LIST (VOIDmode, sub,\n-\t\t\t\t\t\t    purge_addressof_replacements));\n+\t  if (GET_CODE (sub) == REG || GET_CODE (sub) == SUBREG)\n+\t    {\n+\t      rtx tem;\n+\n+\t      for (tem = purge_addressof_replacements;\n+\t\t   tem != NULL_RTX;\n+\t\t   tem = XEXP (XEXP (tem, 1), 1))\n+\t\tif (rtx_equal_p (XEXP (x, 0), XEXP (tem, 0)))\n+\t\t  {\n+\t\t    XEXP (XEXP (tem, 1), 0) = sub;\n+\t\t    return;\n+\t\t  }\n+\t      purge_addressof_replacements\n+\t\t= gen_rtx (EXPR_LIST, VOIDmode, XEXP (x, 0),\n+\t\t\t   gen_rtx_EXPR_LIST (VOIDmode, sub,\n+\t\t\t\t\t      purge_addressof_replacements));\n+\t      return;\n+\t    }\n \t  goto restart;\n \t}\n     give_up:;\n@@ -3440,6 +3466,7 @@ purge_addressof (insns)\n \n   /* Clean up.  */\n   hash_table_free (&ht);\n+  purge_bitfield_addressof_replacements = 0;\n   purge_addressof_replacements = 0;\n }\n \f"}]}