{"sha": "22faf0048fbe3261eafc0ff93bbcdbaa7a8d0df8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjJmYWYwMDQ4ZmJlMzI2MWVhZmMwZmY5M2JiY2RiYWE3YThkMGRmOA==", "commit": {"author": {"name": "Rainer Orth", "email": "ro@CeBiTec.Uni-Bielefeld.DE", "date": "2010-02-24T16:02:17Z"}, "committer": {"name": "Rainer Orth", "email": "ro@gcc.gnu.org", "date": "2010-02-24T16:02:17Z"}, "message": "libffi.texi (The Closure API): Fix typo.\n\n\t* doc/libffi.texi (The Closure API): Fix typo.\n\t* doc/libffi.info: Remove.\n\nFrom-SVN: r157049", "tree": {"sha": "84df16f25de2b93d1e187ce71c884784d6c3813c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/84df16f25de2b93d1e187ce71c884784d6c3813c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22faf0048fbe3261eafc0ff93bbcdbaa7a8d0df8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22faf0048fbe3261eafc0ff93bbcdbaa7a8d0df8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22faf0048fbe3261eafc0ff93bbcdbaa7a8d0df8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22faf0048fbe3261eafc0ff93bbcdbaa7a8d0df8/comments", "author": {"login": "rorth", "id": 3930951, "node_id": "MDQ6VXNlcjM5MzA5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/3930951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rorth", "html_url": "https://github.com/rorth", "followers_url": "https://api.github.com/users/rorth/followers", "following_url": "https://api.github.com/users/rorth/following{/other_user}", "gists_url": "https://api.github.com/users/rorth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rorth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rorth/subscriptions", "organizations_url": "https://api.github.com/users/rorth/orgs", "repos_url": "https://api.github.com/users/rorth/repos", "events_url": "https://api.github.com/users/rorth/events{/privacy}", "received_events_url": "https://api.github.com/users/rorth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "28c64ec89358cbe999af26abcc2867149a85bb23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28c64ec89358cbe999af26abcc2867149a85bb23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28c64ec89358cbe999af26abcc2867149a85bb23"}], "stats": {"total": 540, "additions": 6, "deletions": 534}, "files": [{"sha": "85e255d1d2779e9cab00707d71e6d0c66a5f85de", "filename": "libffi/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22faf0048fbe3261eafc0ff93bbcdbaa7a8d0df8/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22faf0048fbe3261eafc0ff93bbcdbaa7a8d0df8/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=22faf0048fbe3261eafc0ff93bbcdbaa7a8d0df8", "patch": "@@ -1,3 +1,8 @@\n+2010-02-24  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n+\n+\t* doc/libffi.texi (The Closure API): Fix typo.\n+\t* doc/libffi.info: Remove.\n+\n 2010-02-15  Matthias Klose  <doko@ubuntu.com>\n \n \t* src/arm/sysv.S (__ARM_ARCH__): Define for processor"}, {"sha": "87dee8a13ada7e5d227deb86d9345c0a5fe5cc45", "filename": "libffi/doc/libffi.info", "status": "removed", "additions": 0, "deletions": 533, "changes": 533, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28c64ec89358cbe999af26abcc2867149a85bb23/libffi%2Fdoc%2Flibffi.info", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28c64ec89358cbe999af26abcc2867149a85bb23/libffi%2Fdoc%2Flibffi.info", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fdoc%2Flibffi.info?ref=28c64ec89358cbe999af26abcc2867149a85bb23", "patch": "@@ -1,533 +0,0 @@\n-This is doc/libffi.info, produced by makeinfo version 4.12 from\n-./doc/libffi.texi.\n-\n-This manual is for Libffi, a portable foreign-function interface\n-library.\n-\n-   Copyright (C) 2008 Red Hat, Inc.\n-\n-     Permission is granted to copy, distribute and/or modify this\n-     document under the terms of the GNU General Public License as\n-     published by the Free Software Foundation; either version 2, or\n-     (at your option) any later version.  A copy of the license is\n-     included in the section entitled \"GNU General Public License\".\n-\n-\n-INFO-DIR-SECTION\n-START-INFO-DIR-ENTRY\n-* libffi: (libffi).             Portable foreign-function interface library.\n-END-INFO-DIR-ENTRY\n-\n-\u001f\n-File: libffi.info,  Node: Top,  Next: Introduction,  Up: (dir)\n-\n-libffi\n-******\n-\n-This manual is for Libffi, a portable foreign-function interface\n-library.\n-\n-   Copyright (C) 2008 Red Hat, Inc.\n-\n-     Permission is granted to copy, distribute and/or modify this\n-     document under the terms of the GNU General Public License as\n-     published by the Free Software Foundation; either version 2, or\n-     (at your option) any later version.  A copy of the license is\n-     included in the section entitled \"GNU General Public License\".\n-\n-\n-* Menu:\n-\n-* Introduction::                What is libffi?\n-* Using libffi::                How to use libffi.\n-* Missing Features::            Things libffi can't do.\n-* Index::                       Index.\n-\n-\u001f\n-File: libffi.info,  Node: Introduction,  Next: Using libffi,  Prev: Top,  Up: Top\n-\n-1 What is libffi?\n-*****************\n-\n-Compilers for high level languages generate code that follow certain\n-conventions.  These conventions are necessary, in part, for separate\n-compilation to work.  One such convention is the \"calling convention\".\n-The calling convention is a set of assumptions made by the compiler\n-about where function arguments will be found on entry to a function.  A\n-calling convention also specifies where the return value for a function\n-is found.  The calling convention is also sometimes called the \"ABI\" or\n-\"Application Binary Interface\".  \n-\n-   Some programs may not know at the time of compilation what arguments\n-are to be passed to a function.  For instance, an interpreter may be\n-told at run-time about the number and types of arguments used to call a\n-given function.  `Libffi' can be used in such programs to provide a\n-bridge from the interpreter program to compiled code.\n-\n-   The `libffi' library provides a portable, high level programming\n-interface to various calling conventions.  This allows a programmer to\n-call any function specified by a call interface description at run time.\n-\n-   FFI stands for Foreign Function Interface.  A foreign function\n-interface is the popular name for the interface that allows code\n-written in one language to call code written in another language.  The\n-`libffi' library really only provides the lowest, machine dependent\n-layer of a fully featured foreign function interface.  A layer must\n-exist above `libffi' that handles type conversions for values passed\n-between the two languages.  \n-\n-\u001f\n-File: libffi.info,  Node: Using libffi,  Next: Missing Features,  Prev: Introduction,  Up: Top\n-\n-2 Using libffi\n-**************\n-\n-* Menu:\n-\n-* The Basics::                  The basic libffi API.\n-* Simple Example::              A simple example.\n-* Types::                       libffi type descriptions.\n-* Multiple ABIs::               Different passing styles on one platform.\n-* The Closure API::             Writing a generic function.\n-\n-\u001f\n-File: libffi.info,  Node: The Basics,  Next: Simple Example,  Up: Using libffi\n-\n-2.1 The Basics\n-==============\n-\n-`Libffi' assumes that you have a pointer to the function you wish to\n-call and that you know the number and types of arguments to pass it, as\n-well as the return type of the function.\n-\n-   The first thing you must do is create an `ffi_cif' object that\n-matches the signature of the function you wish to call.  This is a\n-separate step because it is common to make multiple calls using a\n-single `ffi_cif'.  The \"cif\" in `ffi_cif' stands for Call InterFace.\n-To prepare a call interface object, use the function `ffi_prep_cif'.  \n-\n- -- Function: ffi_status ffi_prep_cif (ffi_cif *CIF, ffi_abi ABI,\n-          unsigned int NARGS, ffi_type *RTYPE, ffi_type **ARGTYPES)\n-     This initializes CIF according to the given parameters.\n-\n-     ABI is the ABI to use; normally `FFI_DEFAULT_ABI' is what you\n-     want.  *note Multiple ABIs:: for more information.\n-\n-     NARGS is the number of arguments that this function accepts.\n-     `libffi' does not yet handle varargs functions; see *note Missing\n-     Features:: for more information.\n-\n-     RTYPE is a pointer to an `ffi_type' structure that describes the\n-     return type of the function.  *Note Types::.\n-\n-     ARGTYPES is a vector of `ffi_type' pointers.  ARGTYPES must have\n-     NARGS elements.  If NARGS is 0, this argument is ignored.\n-\n-     `ffi_prep_cif' returns a `libffi' status code, of type\n-     `ffi_status'.  This will be either `FFI_OK' if everything worked\n-     properly; `FFI_BAD_TYPEDEF' if one of the `ffi_type' objects is\n-     incorrect; or `FFI_BAD_ABI' if the ABI parameter is invalid.\n-\n-   To call a function using an initialized `ffi_cif', use the\n-`ffi_call' function:\n-\n- -- Function: void ffi_call (ffi_cif *CIF, void *FN, void *RVALUE, void\n-          **AVALUES)\n-     This calls the function FN according to the description given in\n-     CIF.  CIF must have already been prepared using `ffi_prep_cif'.\n-\n-     RVALUE is a pointer to a chunk of memory that will hold the result\n-     of the function call.  This must be large enough to hold the\n-     result and must be suitably aligned; it is the caller's\n-     responsibility to ensure this.  If CIF declares that the function\n-     returns `void' (using `ffi_type_void'), then RVALUE is ignored.\n-     If RVALUE is `NULL', then the return value is discarded.\n-\n-     AVALUES is a vector of `void *' pointers that point to the memory\n-     locations holding the argument values for a call.  If CIF declares\n-     that the function has no arguments (i.e., NARGS was 0), then\n-     AVALUES is ignored.\n-\n-\u001f\n-File: libffi.info,  Node: Simple Example,  Next: Types,  Prev: The Basics,  Up: Using libffi\n-\n-2.2 Simple Example\n-==================\n-\n-Here is a trivial example that calls `puts' a few times.\n-\n-     #include <stdio.h>\n-     #include <ffi.h>\n-\n-     int main()\n-     {\n-       ffi_cif cif;\n-       ffi_type *args[1];\n-       void *values[1];\n-       char *s;\n-       int rc;\n-\n-       /* Initialize the argument info vectors */\n-       args[0] = &ffi_type_pointer;\n-       values[0] = &s;\n-\n-       /* Initialize the cif */\n-       if (ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,\n-     \t\t       &ffi_type_uint, args) == FFI_OK)\n-         {\n-           s = \"Hello World!\";\n-           ffi_call(&cif, puts, &rc, values);\n-           /* rc now holds the result of the call to puts */\n-\n-           /* values holds a pointer to the function's arg, so to\n-              call puts() again all we need to do is change the\n-              value of s */\n-           s = \"This is cool!\";\n-           ffi_call(&cif, puts, &rc, values);\n-         }\n-\n-       return 0;\n-     }\n-\n-\u001f\n-File: libffi.info,  Node: Types,  Next: Multiple ABIs,  Prev: Simple Example,  Up: Using libffi\n-\n-2.3 Types\n-=========\n-\n-* Menu:\n-\n-* Primitive Types::             Built-in types.\n-* Structures::                  Structure types.\n-* Type Example::                Structure type example.\n-\n-\u001f\n-File: libffi.info,  Node: Primitive Types,  Next: Structures,  Up: Types\n-\n-2.3.1 Primitive Types\n----------------------\n-\n-`Libffi' provides a number of built-in type descriptors that can be\n-used to describe argument and return types:\n-\n-`ffi_type_void'\n-     The type `void'.  This cannot be used for argument types, only for\n-     return values.\n-\n-`ffi_type_uint8'\n-     An unsigned, 8-bit integer type.\n-\n-`ffi_type_sint8'\n-     A signed, 8-bit integer type.\n-\n-`ffi_type_uint16'\n-     An unsigned, 16-bit integer type.\n-\n-`ffi_type_sint16'\n-     A signed, 16-bit integer type.\n-\n-`ffi_type_uint32'\n-     An unsigned, 32-bit integer type.\n-\n-`ffi_type_sint32'\n-     A signed, 32-bit integer type.\n-\n-`ffi_type_uint64'\n-     An unsigned, 64-bit integer type.\n-\n-`ffi_type_sint64'\n-     A signed, 64-bit integer type.\n-\n-`ffi_type_float'\n-     The C `float' type.\n-\n-`ffi_type_double'\n-     The C `double' type.\n-\n-`ffi_type_uchar'\n-     The C `unsigned char' type.\n-\n-`ffi_type_schar'\n-     The C `signed char' type.  (Note that there is not an exact\n-     equivalent to the C `char' type in `libffi'; ordinarily you should\n-     either use `ffi_type_schar' or `ffi_type_uchar' depending on\n-     whether `char' is signed.)\n-\n-`ffi_type_ushort'\n-     The C `unsigned short' type.\n-\n-`ffi_type_sshort'\n-     The C `short' type.\n-\n-`ffi_type_uint'\n-     The C `unsigned int' type.\n-\n-`ffi_type_sint'\n-     The C `int' type.\n-\n-`ffi_type_ulong'\n-     The C `unsigned long' type.\n-\n-`ffi_type_slong'\n-     The C `long' type.\n-\n-`ffi_type_longdouble'\n-     On platforms that have a C `long double' type, this is defined.\n-     On other platforms, it is not.\n-\n-`ffi_type_pointer'\n-     A generic `void *' pointer.  You should use this for all pointers,\n-     regardless of their real type.\n-\n-   Each of these is of type `ffi_type', so you must take the address\n-when passing to `ffi_prep_cif'.\n-\n-\u001f\n-File: libffi.info,  Node: Structures,  Next: Type Example,  Prev: Primitive Types,  Up: Types\n-\n-2.3.2 Structures\n-----------------\n-\n-Although `libffi' has no special support for unions or bit-fields, it\n-is perfectly happy passing structures back and forth.  You must first\n-describe the structure to `libffi' by creating a new `ffi_type' object\n-for it.\n-\n- -- ffi_type:\n-     The `ffi_type' has the following members:\n-    `size_t size'\n-          This is set by `libffi'; you should initialize it to zero.\n-\n-    `unsigned short alignment'\n-          This is set by `libffi'; you should initialize it to zero.\n-\n-    `unsigned short type'\n-          For a structure, this should be set to `FFI_TYPE_STRUCT'.\n-\n-    `ffi_type **elements'\n-          This is a `NULL'-terminated array of pointers to `ffi_type'\n-          objects.  There is one element per field of the struct.\n-\n-\u001f\n-File: libffi.info,  Node: Type Example,  Prev: Structures,  Up: Types\n-\n-2.3.3 Type Example\n-------------------\n-\n-The following example initializes a `ffi_type' object representing the\n-`tm' struct from Linux's `time.h'.\n-\n-   Here is how the struct is defined:\n-\n-     struct tm {\n-         int tm_sec;\n-         int tm_min;\n-         int tm_hour;\n-         int tm_mday;\n-         int tm_mon;\n-         int tm_year;\n-         int tm_wday;\n-         int tm_yday;\n-         int tm_isdst;\n-         /* Those are for future use. */\n-         long int __tm_gmtoff__;\n-         __const char *__tm_zone__;\n-     };\n-\n-   Here is the corresponding code to describe this struct to `libffi':\n-\n-         {\n-           ffi_type tm_type;\n-           ffi_type *tm_type_elements[12];\n-           int i;\n-\n-           tm_type.size = tm_type.alignment = 0;\n-           tm_type.elements = &tm_type_elements;\n-\n-           for (i = 0; i < 9; i++)\n-               tm_type_elements[i] = &ffi_type_sint;\n-\n-           tm_type_elements[9] = &ffi_type_slong;\n-           tm_type_elements[10] = &ffi_type_pointer;\n-           tm_type_elements[11] = NULL;\n-\n-           /* tm_type can now be used to represent tm argument types and\n-     \t return types for ffi_prep_cif() */\n-         }\n-\n-\u001f\n-File: libffi.info,  Node: Multiple ABIs,  Next: The Closure API,  Prev: Types,  Up: Using libffi\n-\n-2.4 Multiple ABIs\n-=================\n-\n-A given platform may provide multiple different ABIs at once.  For\n-instance, the x86 platform has both `stdcall' and `fastcall' functions.\n-\n-   `libffi' provides some support for this.  However, this is\n-necessarily platform-specific.\n-\n-\u001f\n-File: libffi.info,  Node: The Closure API,  Prev: Multiple ABIs,  Up: Using libffi\n-\n-2.5 The Closure API\n-===================\n-\n-`libffi' also provides a way to write a generic function - a function\n-that can accept and decode any combination of arguments.  This can be\n-useful when writing an interpreter, or to provide wrappers for\n-arbitrary functions.\n-\n-   This facility is called the \"closure API\".  Closures are not\n-supported on all platforms; you can check the `FFI_CLOSURES' define to\n-determine whether they are supported on the current platform.  \n-\n-   Because closures work by assembling a tiny function at runtime, they\n-require special allocation on platforms that have a non-executable\n-heap.  Memory management for closures is handled by a pair of functions:\n-\n- -- Function: void *ffi_closure_alloc (size_t SIZE, void **CODE)\n-     Allocate a chunk of memory holding SIZE bytes.  This returns a\n-     pointer to the writable address, and sets *CODE to the\n-     corresponding executable address.\n-\n-     SIZE should be sufficient to hold a `ffi_closure' object.\n-\n- -- Function: void ffi_closure_free (void *WRITABLE)\n-     Free memory allocated using `ffi_closure_alloc'.  The argument is\n-     the writable address that was returned.\n-\n-   Once you have allocated the memory for a closure, you must construct\n-a `ffi_cif' describing the function call.  Finally you can prepare the\n-closure function:\n-\n- -- Function: ffi_status ffi_prep_closure_loc (ffi_closure *CLOSURE,\n-          ffi_cif *CIF, void (*FUN) (ffi_cif *CIF, void *RET, void\n-          **ARGS, void *USER_DATA), void *USER_DATA, void *CODELOC)\n-     Prepare a closure function.\n-\n-     CLOSURE is the address of a `ffi_closure' object; this is the\n-     writable address returned by `ffi_closure_alloc'.\n-\n-     CIF is the `ffi_cif' describing the function parameters.\n-\n-     USER_DATA is an arbitrary datum that is passed, uninterpreted, to\n-     your closure function.\n-\n-     CODELOC is the executable address returned by `ffi_closure_alloc'.\n-\n-     FUN is the function which will be called when the closure is\n-     invoked.  It is called with the arguments:\n-    CIF\n-          The `ffi_cif' passed to `ffi_prep_closure_loc'.\n-\n-    RET\n-          A pointer to the memory used for the function's return value.\n-          FUN must fill this, unless the function is declared as\n-          returning `void'.\n-\n-    ARGS\n-          A vector of pointers to memory holding the arguments to the\n-          function.\n-\n-    USER_DATA\n-          The same USER_DATA that was passed to `ffi_prep_closure_loc'.\n-\n-     `ffi_prep_closure_loc' will return `FFI_OK' if everything went ok,\n-     and something else on error.\n-\n-     After calling `ffi_prep_closure_loc', you can cast CODELOC to the\n-     appropriate pointer-to-function type.\n-\n-   You may see old code referring to `ffi_prep_closure'.  This function\n-is deprecated, as it cannot handle the need for separate writable and\n-executable addresses.\n-\n-\u001f\n-File: libffi.info,  Node: Missing Features,  Next: Index,  Prev: Using libffi,  Up: Top\n-\n-3 Missing Features\n-******************\n-\n-`libffi' is missing a few features.  We welcome patches to add support\n-for these.\n-\n-   * There is no support for calling varargs functions.  This may work\n-     on some platforms, depending on how the ABI is defined, but it is\n-     not reliable.\n-\n-   * There is no support for bit fields in structures.\n-\n-   * The closure API is\n-\n-   * The \"raw\" API is undocumented.\n-\n-\u001f\n-File: libffi.info,  Node: Index,  Prev: Missing Features,  Up: Top\n-\n-Index\n-*****\n-\n-\u0000\b[index\u0000\b]\n-* Menu:\n-\n-* :                                      Structures.           (line 12)\n-* ABI:                                   Introduction.         (line 13)\n-* Application Binary Interface:          Introduction.         (line 13)\n-* calling convention:                    Introduction.         (line 13)\n-* cif:                                   The Basics.           (line 14)\n-* closure API:                           The Closure API.      (line 13)\n-* closures:                              The Closure API.      (line 13)\n-* FFI:                                   Introduction.         (line 31)\n-* ffi_call:                              The Basics.           (line 41)\n-* ffi_closure_alloca:                    The Closure API.      (line 19)\n-* ffi_closure_free:                      The Closure API.      (line 26)\n-* FFI_CLOSURES:                          The Closure API.      (line 13)\n-* ffi_prep_cif:                          The Basics.           (line 16)\n-* ffi_prep_closure_loc:                  The Closure API.      (line 34)\n-* ffi_status <1>:                        The Closure API.      (line 37)\n-* ffi_status:                            The Basics.           (line 18)\n-* ffi_type:                              Structures.           (line 11)\n-* ffi_type_double:                       Primitive Types.      (line 41)\n-* ffi_type_float:                        Primitive Types.      (line 38)\n-* ffi_type_longdouble:                   Primitive Types.      (line 71)\n-* ffi_type_pointer:                      Primitive Types.      (line 75)\n-* ffi_type_schar:                        Primitive Types.      (line 47)\n-* ffi_type_sint:                         Primitive Types.      (line 62)\n-* ffi_type_sint16:                       Primitive Types.      (line 23)\n-* ffi_type_sint32:                       Primitive Types.      (line 29)\n-* ffi_type_sint64:                       Primitive Types.      (line 35)\n-* ffi_type_sint8:                        Primitive Types.      (line 17)\n-* ffi_type_slong:                        Primitive Types.      (line 68)\n-* ffi_type_sshort:                       Primitive Types.      (line 56)\n-* ffi_type_uchar:                        Primitive Types.      (line 44)\n-* ffi_type_uint:                         Primitive Types.      (line 59)\n-* ffi_type_uint16:                       Primitive Types.      (line 20)\n-* ffi_type_uint32:                       Primitive Types.      (line 26)\n-* ffi_type_uint64:                       Primitive Types.      (line 32)\n-* ffi_type_uint8:                        Primitive Types.      (line 14)\n-* ffi_type_ulong:                        Primitive Types.      (line 65)\n-* ffi_type_ushort:                       Primitive Types.      (line 53)\n-* ffi_type_void:                         Primitive Types.      (line 10)\n-* Foreign Function Interface:            Introduction.         (line 31)\n-* void <1>:                              The Closure API.      (line 20)\n-* void:                                  The Basics.           (line 43)\n-\n-\n-\u001f\n-Tag Table:\n-Node: Top\u007f670\n-Node: Introduction\u007f1406\n-Node: Using libffi\u007f3042\n-Node: The Basics\u007f3477\n-Node: Simple Example\u007f6084\n-Node: Types\u007f7111\n-Node: Primitive Types\u007f7394\n-Node: Structures\u007f9214\n-Node: Type Example\u007f10074\n-Node: Multiple ABIs\u007f11297\n-Node: The Closure API\u007f11668\n-Node: Missing Features\u007f14588\n-Node: Index\u007f15081\n-\u001f\n-End Tag Table"}, {"sha": "06384cbcffd78580c0c856ef96c10fcfbede7b86", "filename": "libffi/doc/libffi.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22faf0048fbe3261eafc0ff93bbcdbaa7a8d0df8/libffi%2Fdoc%2Flibffi.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22faf0048fbe3261eafc0ff93bbcdbaa7a8d0df8/libffi%2Fdoc%2Flibffi.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fdoc%2Flibffi.texi?ref=22faf0048fbe3261eafc0ff93bbcdbaa7a8d0df8", "patch": "@@ -437,7 +437,7 @@ require special allocation on platforms that have a non-executable\n heap.  Memory management for closures is handled by a pair of\n functions:\n \n-@findex ffi_closure_alloca\n+@findex ffi_closure_alloc\n @defun void *ffi_closure_alloc (size_t @var{size}, void **@var{code})\n Allocate a chunk of memory holding @var{size} bytes.  This returns a\n pointer to the writable address, and sets *@var{code} to the"}]}