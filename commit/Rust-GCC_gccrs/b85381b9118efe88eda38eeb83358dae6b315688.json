{"sha": "b85381b9118efe88eda38eeb83358dae6b315688", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjg1MzgxYjkxMThlZmU4OGVkYTM4ZWViODMzNThkYWU2YjMxNTY4OA==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2001-04-30T20:53:31Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2001-04-30T20:53:31Z"}, "message": "ostreambuf_iterator.cc: New file.\n\n\n2001-04-30  Benjamin Kosnik  <bkoz@redhat.com>\n\n\tlibstdc++/2627\n\t* testsuite/24_iterators/ostreambuf_iterator.cc: New file.\n\t* include/bits/sbuf_iter.h (ostreambuf_iterator): Remove bogus\n\tspecializations.\n\nFrom-SVN: r41694", "tree": {"sha": "111d6c64cb69489385bc3d36595f3b33b6a46850", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/111d6c64cb69489385bc3d36595f3b33b6a46850"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b85381b9118efe88eda38eeb83358dae6b315688", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b85381b9118efe88eda38eeb83358dae6b315688", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b85381b9118efe88eda38eeb83358dae6b315688", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b85381b9118efe88eda38eeb83358dae6b315688/comments", "author": null, "committer": null, "parents": [{"sha": "60de6385e1b6b764dca5e467fa2c17e8822777f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60de6385e1b6b764dca5e467fa2c17e8822777f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60de6385e1b6b764dca5e467fa2c17e8822777f1"}], "stats": {"total": 195, "additions": 127, "deletions": 68}, "files": [{"sha": "acbaaffb5958db6279d02370e9b2dbb59f8b3736", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b85381b9118efe88eda38eeb83358dae6b315688/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b85381b9118efe88eda38eeb83358dae6b315688/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=b85381b9118efe88eda38eeb83358dae6b315688", "patch": "@@ -1,3 +1,10 @@\n+2001-04-30  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\tlibstdc++/2627 \n+\t* testsuite/24_iterators/ostreambuf_iterator.cc: New file.\n+\t* include/bits/sbuf_iter.h (ostreambuf_iterator): Remove bogus\n+\tspecializations.\n+\n 2001-04-30  Benjamin Kosnik  <bkoz@redhat.com>\n \n \tlibstdc++/2964"}, {"sha": "6bec6d2037a51adcac2cea8d708d622a4f3360fa", "filename": "libstdc++-v3/include/bits/sbuf_iter.h", "status": "modified", "additions": 23, "deletions": 68, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b85381b9118efe88eda38eeb83358dae6b315688/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fsbuf_iter.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b85381b9118efe88eda38eeb83358dae6b315688/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fsbuf_iter.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fsbuf_iter.h?ref=b85381b9118efe88eda38eeb83358dae6b315688", "patch": "@@ -36,29 +36,23 @@\n \n namespace std\n {\n-\n   template<typename _CharT, typename _Traits>\n     class ostreambuf_iterator\n-#if 1      // XXX this is standard:\n     : public iterator<output_iterator_tag, _CharT, void, void, void>\n-#else\n-    : public output_iterator\n-#endif\n     {\n     public:\n-\n       // Types:\n-      typedef _CharT                       \t char_type;\n+      typedef _CharT                           char_type;\n       typedef _Traits                          traits_type;\n       typedef basic_streambuf<_CharT, _Traits> streambuf_type;\n       typedef basic_ostream<_CharT, _Traits>   ostream_type;\n       \n       inline \n       ostreambuf_iterator(ostream_type& __s) throw ()\n-      : _M_sbuf(__s.rdbuf()), _M_failed(false) { }\n+      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }\n       \n       ostreambuf_iterator(streambuf_type* __s) throw ()\n-      : _M_sbuf(__s), _M_failed(false) { }\n+      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }\n \n       ostreambuf_iterator& \n       operator=(_CharT __c);\n@@ -82,57 +76,19 @@ namespace std\n     private:\n       streambuf_type* \t_M_sbuf;\n       bool \t\t_M_failed;\n-\n-#if 0\n-      template<>\n-        friend char const*\n-        copy(char const* __first, char const* __last,\n-             ostreambuf_iterator<char,char_traits<char> > __to);\n-      template<>\n-        friend wchar_t const*\n-        copy(wchar_t const* __first, wchar_t const* __last,\n-             ostreambuf_iterator<wchar_t,char_traits<wchar_t> > __to);\n-#endif\n     };\n \n   template<typename _CharT, typename _Traits>\n     inline ostreambuf_iterator<_CharT, _Traits>&\n     ostreambuf_iterator<_CharT, _Traits>::operator=(_CharT __c)\n     {\n-      if (!_M_failed &&\n+      if (!_M_failed && \n           _Traits::eq_int_type(_M_sbuf->sputc(__c),_Traits::eof()))\n       _M_failed = true;\n       return *this;\n     }\n \n \n-#if 0\n-  // Optimized specializations of standard algorithms\n-  // These are specialized only for standard types\n-  // (with no unbound arguments) to avoid creating\n-  // overload problems with user specializations.\n-\n-  template<>\n-    char const*\n-    copy(char const* __first, char const* __last,\n-\t ostreambuf_iterator<char,char_traits<char> > __to)\n-    {\n-      if (!__to._M_failed)\n-\t__to._M_sbuf->sputn(__first, __last-__first);\n-      return __last;\n-    }\n-\n-  template<>\n-    wchar_t const*\n-    copy(wchar_t const* __first, wchar_t const* __last,\n-\t ostreambuf_iterator<whar_t,char_traits<wchar_t> > __to)\n-    {\n-      if (!__to._M_failed)\n-\t__to._M_sbuf->sputn(__first, __last-__first);\n-      return __last;\n-    }\n-#endif\n-\n   // 24.5.3 Template class istreambuf_iterator\n   template<class _CharT, class _Traits>\n     class istreambuf_iterator\n@@ -151,13 +107,13 @@ namespace std\n       typedef istreambuf_iterator<_CharT, _Traits>\t__istreambufiter_type;\n \n       istreambuf_iterator() throw() \n-      : _M_istreambuf(NULL), _M_c(-2) { }\n+      : _M_sbuf(NULL), _M_c(-2) { }\n       \n       istreambuf_iterator(istream_type& __s) throw()\n-      : _M_istreambuf(__s.rdbuf()), _M_c(-2) { }\n+      : _M_sbuf(__s.rdbuf()), _M_c(-2) { }\n \n       istreambuf_iterator(streambuf_type* __s) throw()\n-      : _M_istreambuf(__s), _M_c(-2) { }\n+      : _M_sbuf(__s), _M_c(-2) { }\n        \n       // NB: This should really have an int_type return\n       // value, so \"end of stream\" postion can be checked without\n@@ -167,10 +123,10 @@ namespace std\n       { \n \t// The result of operator*() on an end of stream is undefined.\n \tchar_type __ret;\n-\tif (_M_istreambuf && _M_c != static_cast<int_type>(-2))\n+\tif (_M_sbuf && _M_c != static_cast<int_type>(-2))\n \t  __ret = _M_c;\n-\telse if (_M_istreambuf)\n-\t  __ret = traits_type::to_char_type(_M_istreambuf->sgetc()); \n+\telse if (_M_sbuf)\n+\t  __ret = traits_type::to_char_type(_M_sbuf->sgetc()); \n \telse\n \t  __ret = static_cast<char_type>(traits_type::eof());\n \treturn __ret;\n@@ -179,8 +135,8 @@ namespace std\n       __istreambufiter_type& \n       operator++()\n       { \n-\tif (_M_istreambuf)\n-\t  _M_istreambuf->sbumpc();\n+\tif (_M_sbuf)\n+\t  _M_sbuf->sbumpc();\n \t_M_c = -2;\n \treturn *this; \n       }\n@@ -192,8 +148,8 @@ namespace std\n       const __istreambufiter_type\n       operator++(int)\n       {\n-\tif (_M_istreambuf)\n-\t  _M_c = _M_istreambuf->sbumpc();\n+\tif (_M_sbuf)\n+\t  _M_c = _M_sbuf->sbumpc();\n \treturn *this; \n       }\n #endif\n@@ -202,9 +158,9 @@ namespace std\n       equal(const __istreambufiter_type& __b)\n       { \n \tint_type __eof = traits_type::eof();\n-\tbool __thiseof = !_M_istreambuf || _M_istreambuf->sgetc() == __eof;\n-\tbool __beof = !__b._M_istreambuf \n-\t  \t      || __b._M_istreambuf->sgetc() == __eof;\n+\tbool __thiseof = !_M_sbuf || _M_sbuf->sgetc() == __eof;\n+\tbool __beof = !__b._M_sbuf \n+\t  \t      || __b._M_sbuf->sgetc() == __eof;\n \treturn (__thiseof && __beof || (!__thiseof && !__beof));\n       }\n \n@@ -215,9 +171,9 @@ namespace std\n       equal(const __istreambufiter_type& __b) const\n       {\n \tint_type __eof = traits_type::eof();\n-\tbool __thiseof = !_M_istreambuf || _M_istreambuf->sgetc() == __eof;\n-\tbool __beof = !__b._M_istreambuf \n-\t  \t      || __b._M_istreambuf->sgetc() == __eof;\n+\tbool __thiseof = !_M_sbuf || _M_sbuf->sgetc() == __eof;\n+\tbool __beof = !__b._M_sbuf \n+\t  \t      || __b._M_sbuf->sgetc() == __eof;\n \treturn (__thiseof && __beof || (!__thiseof && !__beof));\n       }\n #endif\n@@ -230,7 +186,7 @@ namespace std\n       // the \"end of stream\" iterator value.\n       // NB: This implementation assumes the \"end of stream\" value\n       // is EOF, or -1.\n-      streambuf_type* \t\t_M_istreambuf;  \n+      streambuf_type* \t\t_M_sbuf;  \n       int_type \t\t\t_M_c;\n     };\n \n@@ -246,7 +202,6 @@ namespace std\n \t       const istreambuf_iterator<_CharT, _Traits>& __b)\n     { return !__a.equal(__b); }\n \n-} // std::\n-\n-#endif /* _CPP_BITS_SBUF_ITER_H */\n+} // namespace std\n \n+#endif"}, {"sha": "9f1544f2a318fddc6e6db6fb0c5eec982f64e72e", "filename": "libstdc++-v3/testsuite/24_iterators/ostreambuf_iterator.cc", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b85381b9118efe88eda38eeb83358dae6b315688/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fostreambuf_iterator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b85381b9118efe88eda38eeb83358dae6b315688/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fostreambuf_iterator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fostreambuf_iterator.cc?ref=b85381b9118efe88eda38eeb83358dae6b315688", "patch": "@@ -0,0 +1,97 @@\n+// 2001-04-30  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 24.5.4 template class ostreambuf_iterator\n+\n+#include <sstream>\n+#include <iterator>\n+#include <debug_assert.h>\n+\n+bool test01(void)\n+{\n+  typedef std::ostreambuf_iterator<char> costreambuf_iter;\n+  typedef costreambuf_iter::streambuf_type cstreambuf_type;\n+  bool test = true;\n+  const char slit01[] = \"playa hermosa, liberia, guanacaste\";\n+  std::string str01(slit01);\n+  std::string tmp;\n+  std::stringbuf     strbuf01;\n+  std::stringbuf     strbuf02(str01);\n+  std::ostringstream ostrs00(str01);\n+  std::ostringstream ostrs01(str01);\n+\n+  // ctor sanity checks\n+  costreambuf_iter ostrb_it01(ostrs00);\n+  VERIFY( !ostrb_it01.failed() );\n+  ostrb_it01++;\n+  ++ostrb_it01;\n+  VERIFY( !ostrb_it01.failed() );\n+  ostrb_it01 = 'a';\n+  VERIFY( !ostrb_it01.failed() );\n+  *ostrb_it01;\n+  VERIFY( !ostrb_it01.failed() );\n+\n+  costreambuf_iter ostrb_it02(NULL);\n+  VERIFY( ostrb_it02.failed() );\n+  ostrb_it02++;\n+  ++ostrb_it02;\n+  VERIFY( ostrb_it02.failed() );\n+  *ostrb_it02;\n+  VERIFY( ostrb_it02.failed() );\n+  ostrb_it02 = 'a';\n+  VERIFY( ostrb_it02.failed() );\n+  \n+  // charT operator*() const\n+  // ostreambuf_iterator& operator++();\n+  // ostreambuf_iterator& operator++(int);\n+  costreambuf_iter ostrb_it27(ostrs00);\n+  VERIFY( !ostrb_it27.failed() );\n+  for (int i = 0; i < strlen(slit01) - 2; ++i)\n+    ostrb_it27 = 'a';\n+  VERIFY( !ostrb_it27.failed() );\n+  tmp = ostrs00.str();\n+  VERIFY ( tmp == str01 );\n+\n+  costreambuf_iter ostrb_it28(ostrs01);\n+  VERIFY( !ostrb_it28.failed() );\n+  for (int i = 0; i < strlen(slit01) + 1; ++i)\n+    ostrb_it28 = 'b';\n+  VERIFY( !ostrb_it28.failed() );\n+  tmp = ostrs01.str();\n+  VERIFY ( tmp != str01 );\n+\n+#ifdef DEBUG_ASSERT\n+  assert(test);\n+#endif\n+\n+  return test;\n+}\n+\n+int main()\n+{\n+  test01();\n+\n+  return 0;\n+}\n+\n+\n+\n+\n+"}]}