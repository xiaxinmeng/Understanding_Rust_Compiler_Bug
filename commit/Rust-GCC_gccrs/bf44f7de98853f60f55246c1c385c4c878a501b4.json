{"sha": "bf44f7de98853f60f55246c1c385c4c878a501b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmY0NGY3ZGU5ODg1M2Y2MGY1NTI0NmMxYzM4NWM0Yzg3OGE1MDFiNA==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1995-11-29T18:55:34Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1995-11-29T18:55:34Z"}, "message": "(duplicate_decls): Add new paramter different_binding_level.\n\nLots of changes to use new new parameter.\n(pushdecl): Delete variable declared_global.  New variable\ndifferent_binding_level and code to set it.  Move extern/static\nwarning before duplicate_decls call.  Don't let global typedefs\nconflict with nested extern declarations.  Move oldglobal test\ninside code for setting IDENTIFIER_LIMBO_VALUE.\n(lookup_name_current_level_global): Delete.\n\nFrom-SVN: r10618", "tree": {"sha": "13895fbf6cfabc15008f410474d91d4d9ebae8c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/13895fbf6cfabc15008f410474d91d4d9ebae8c3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf44f7de98853f60f55246c1c385c4c878a501b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf44f7de98853f60f55246c1c385c4c878a501b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf44f7de98853f60f55246c1c385c4c878a501b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf44f7de98853f60f55246c1c385c4c878a501b4/comments", "author": null, "committer": null, "parents": [{"sha": "1417e9bdd0b26cc19de6fea5a15aad895f710240", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1417e9bdd0b26cc19de6fea5a15aad895f710240", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1417e9bdd0b26cc19de6fea5a15aad895f710240"}], "stats": {"total": 253, "additions": 134, "deletions": 119}, "files": [{"sha": "20165214f9453b7171cc7a4d52e4bda3702b5629", "filename": "gcc/c-decl.c", "status": "modified", "additions": 134, "deletions": 119, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf44f7de98853f60f55246c1c385c4c878a501b4/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf44f7de98853f60f55246c1c385c4c878a501b4/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=bf44f7de98853f60f55246c1c385c4c878a501b4", "patch": "@@ -1307,11 +1307,15 @@ pushtag (name, type)\n    Prints an error message if appropriate.\n \n    If safely possible, alter OLDDECL to look like NEWDECL, and return 1.\n-   Otherwise, return 0.  */\n+   Otherwise, return 0.\n+\n+   When DIFFERENT_BINDING_LEVEL is true, NEWDECL is an external declaration,\n+   and OLDDECL is in an outer binding level and should thus not be changed.  */\n \n static int\n-duplicate_decls (newdecl, olddecl)\n+duplicate_decls (newdecl, olddecl, different_binding_level)\n      register tree newdecl, olddecl;\n+     int different_binding_level;\n {\n   int types_match = comptypes (TREE_TYPE (newdecl), TREE_TYPE (olddecl));\n   int new_is_definition = (TREE_CODE (newdecl) == FUNCTION_DECL\n@@ -1404,8 +1408,8 @@ duplicate_decls (newdecl, olddecl)\n       else if (!types_match)\n \t{\n           /* Accept the return type of the new declaration if same modes.  */\n-\t  tree oldreturntype = TREE_TYPE (TREE_TYPE (olddecl));\n-\t  tree newreturntype = TREE_TYPE (TREE_TYPE (newdecl));\n+\t  tree oldreturntype = TREE_TYPE (oldtype);\n+\t  tree newreturntype = TREE_TYPE (newtype);\n \n \t  /* Make sure we put the new type in the same obstack as the old ones.\n \t     If the old types are not both in the same obstack, use the\n@@ -1422,36 +1426,37 @@ duplicate_decls (newdecl, olddecl)\n             {\n \t      /* Function types may be shared, so we can't just modify\n \t\t the return type of olddecl's function type.  */\n-\t      tree newtype\n+\t      tree trytype\n \t\t= build_function_type (newreturntype,\n-\t\t\t\t       TYPE_ARG_TYPES (TREE_TYPE (olddecl)));\n+\t\t\t\t       TYPE_ARG_TYPES (oldtype));\n \t      \n-              types_match = comptypes (TREE_TYPE (newdecl), newtype);\n+              types_match = comptypes (newtype, trytype);\n \t      if (types_match)\n-\t\tTREE_TYPE (olddecl) = newtype;\n+\t\toldtype = trytype;\n \t    }\n \t  /* Accept harmless mismatch in first argument type also.\n \t     This is for ffs.  */\n \t  if (TYPE_ARG_TYPES (TREE_TYPE (newdecl)) != 0\n-\t      && TYPE_ARG_TYPES (TREE_TYPE (olddecl)) != 0\n-\t      && TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (newdecl))) != 0\n-\t      && TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (olddecl))) != 0\n-\t      && (TYPE_MODE (TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (newdecl))))\n-\t\t  ==\n-\t\t  TYPE_MODE (TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (olddecl))))))\n+\t      && TYPE_ARG_TYPES (oldtype) != 0\n+\t      && TREE_VALUE (TYPE_ARG_TYPES (newtype)) != 0\n+\t      && TREE_VALUE (TYPE_ARG_TYPES (oldtype)) != 0\n+\t      && (TYPE_MODE (TREE_VALUE (TYPE_ARG_TYPES (newtype)))\n+\t\t  == TYPE_MODE (TREE_VALUE (TYPE_ARG_TYPES (oldtype)))))\n \t    {\n \t      /* Function types may be shared, so we can't just modify\n \t\t the return type of olddecl's function type.  */\n-\t      tree newtype\n-\t\t= build_function_type (TREE_TYPE (TREE_TYPE (olddecl)),\n+\t      tree trytype\n+\t\t= build_function_type (TREE_TYPE (oldtype),\n \t\t\t\t       tree_cons (NULL_TREE, \n-\t\t\t\t\t\t  TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (newdecl))),\n-\t\t\t\t\t\t  TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (olddecl)))));\n+\t\t\t\t\t\t  TREE_VALUE (TYPE_ARG_TYPES (newtype)),\n+\t\t\t\t\t\t  TREE_CHAIN (TYPE_ARG_TYPES (oldtype))));\n \t      \n-              types_match = comptypes (TREE_TYPE (newdecl), newtype);\n+              types_match = comptypes (newtype, trytype);\n \t      if (types_match)\n-\t\tTREE_TYPE (olddecl) = newtype;\n+\t\toldtype = trytype;\n \t    }\n+\t  if (! different_binding_level)\n+\t    TREE_TYPE (olddecl) = oldtype;\n \n \t  pop_obstacks ();\n \t}\n@@ -1691,6 +1696,11 @@ duplicate_decls (newdecl, olddecl)\n \n   if (types_match)\n     {\n+      /* When copying info to olddecl, we store into write_olddecl\n+\t instead.  This allows us to avoid modifying olddecl when\n+\t different_binding_level is true.  */\n+      tree write_olddecl = different_binding_level ? newdecl : olddecl;\n+\n       /* Make sure we put the new type in the same obstack as the old ones.\n \t If the old types are not both in the same obstack, use the permanent\n \t one.  */\n@@ -1704,9 +1714,18 @@ duplicate_decls (newdecl, olddecl)\n \t\t       \n       /* Merge the data types specified in the two decls.  */\n       if (TREE_CODE (newdecl) != FUNCTION_DECL || !DECL_BUILT_IN (olddecl))\n-\tTREE_TYPE (newdecl)\n-\t  = TREE_TYPE (olddecl)\n-\t    = common_type (newtype, oldtype);\n+\t{\n+\t  if (different_binding_level)\n+\t    TREE_TYPE (newdecl)\n+\t      = build_type_attribute_variant\n+\t\t(newtype,\n+\t\t merge_attributes (TYPE_ATTRIBUTES (newtype),\n+\t\t\t\t   TYPE_ATTRIBUTES (oldtype)));\n+\t  else\n+\t    TREE_TYPE (newdecl)\n+\t      = TREE_TYPE (olddecl)\n+\t\t= common_type (newtype, oldtype);\n+\t}\n \n       /* Lay the type out, unless already done.  */\n       if (oldtype != TREE_TYPE (newdecl))\n@@ -1733,37 +1752,37 @@ duplicate_decls (newdecl, olddecl)\n       /* Merge the type qualifiers.  */\n       if (DECL_BUILT_IN_NONANSI (olddecl) && TREE_THIS_VOLATILE (olddecl)\n \t  && !TREE_THIS_VOLATILE (newdecl))\n-\tTREE_THIS_VOLATILE (olddecl) = 0;\n+\tTREE_THIS_VOLATILE (write_olddecl) = 0;\n       if (TREE_READONLY (newdecl))\n-\tTREE_READONLY (olddecl) = 1;\n+\tTREE_READONLY (write_olddecl) = 1;\n       if (TREE_THIS_VOLATILE (newdecl))\n \t{\n-\t  TREE_THIS_VOLATILE (olddecl) = 1;\n+\t  TREE_THIS_VOLATILE (write_olddecl) = 1;\n \t  if (TREE_CODE (newdecl) == VAR_DECL)\n \t    make_var_volatile (newdecl);\n \t}\n \n-      /* Keep source location of definition rather than declaration.\n-\t Likewise, keep decl at outer scope.  */\n-      if ((DECL_INITIAL (newdecl) == 0 && DECL_INITIAL (olddecl) != 0)\n-\t  || (DECL_CONTEXT (newdecl) != 0 && DECL_CONTEXT (olddecl) == 0))\n+      /* Keep source location of definition rather than declaration.  */\n+      /* When called with different_binding_level set, keep the old\n+\t information so that meaningful diagnostics can be given.  */\n+      if (DECL_INITIAL (newdecl) == 0 && DECL_INITIAL (olddecl) != 0\n+\t  && ! different_binding_level)\n \t{\n \t  DECL_SOURCE_LINE (newdecl) = DECL_SOURCE_LINE (olddecl);\n \t  DECL_SOURCE_FILE (newdecl) = DECL_SOURCE_FILE (olddecl);\n-\n-\t  if (DECL_CONTEXT (olddecl) == 0\n-\t      && TREE_CODE (newdecl) != FUNCTION_DECL)\n-\t    DECL_CONTEXT (newdecl) = 0;\n \t}\n \n       /* Merge the unused-warning information.  */\n       if (DECL_IN_SYSTEM_HEADER (olddecl))\n \tDECL_IN_SYSTEM_HEADER (newdecl) = 1;\n       else if (DECL_IN_SYSTEM_HEADER (newdecl))\n-\tDECL_IN_SYSTEM_HEADER (olddecl) = 1;\n+\tDECL_IN_SYSTEM_HEADER (write_olddecl) = 1;\n \n       /* Merge the initialization information.  */\n-      if (DECL_INITIAL (newdecl) == 0)\n+      /* When called with different_binding_level set, don't copy over\n+\t DECL_INITIAL, so that we don't accidentally change function\n+\t declarations into function definitions.  */\n+      if (DECL_INITIAL (newdecl) == 0 && ! different_binding_level)\n \tDECL_INITIAL (newdecl) = DECL_INITIAL (olddecl);\n \n       /* Merge the section attribute.\n@@ -1783,7 +1802,7 @@ duplicate_decls (newdecl, olddecl)\n     }\n   /* If cannot merge, then use the new type and qualifiers,\n      and don't preserve the old rtl.  */\n-  else\n+  else if (! different_binding_level)\n     {\n       TREE_TYPE (olddecl) = TREE_TYPE (newdecl);\n       TREE_READONLY (olddecl) = TREE_READONLY (newdecl);\n@@ -1799,6 +1818,8 @@ duplicate_decls (newdecl, olddecl)\n       TREE_PUBLIC (newdecl) &= TREE_PUBLIC (olddecl);\n       /* This is since we don't automatically\n \t copy the attributes of NEWDECL into OLDDECL.  */\n+      /* No need to worry about different_binding_level here because\n+\t then TREE_PUBLIC (newdecl) was true.  */\n       TREE_PUBLIC (olddecl) = TREE_PUBLIC (newdecl);\n       /* If this clears `static', clear it in the identifier too.  */\n       if (! TREE_PUBLIC (olddecl))\n@@ -1823,33 +1844,48 @@ duplicate_decls (newdecl, olddecl)\n     DECL_INLINE (olddecl) = 1;\n   DECL_INLINE (newdecl) = DECL_INLINE (olddecl);\n \n-  /* Get rid of any built-in function if new arg types don't match it\n-     or if we have a function definition.  */\n-  if (TREE_CODE (newdecl) == FUNCTION_DECL\n-      && DECL_BUILT_IN (olddecl)\n-      && (!types_match || new_is_definition))\n-    {\n-      TREE_TYPE (olddecl) = TREE_TYPE (newdecl);\n-      DECL_BUILT_IN (olddecl) = 0;\n-    }\n-\n-  /* If redeclaring a builtin function, and not a definition,\n-     it stays built in.\n-     Also preserve various other info from the definition.  */\n-  if (TREE_CODE (newdecl) == FUNCTION_DECL && !new_is_definition)\n+  if (TREE_CODE (newdecl) == FUNCTION_DECL)\n     {\n       if (DECL_BUILT_IN (olddecl))\n \t{\n-\t  DECL_BUILT_IN (newdecl) = 1;\n-\t  DECL_FUNCTION_CODE (newdecl) = DECL_FUNCTION_CODE (olddecl);\n+\t  /* Get rid of any built-in function if new arg types don't match it\n+\t     or if we have a function definition.  */\n+\t  if (! types_match || new_is_definition)\n+\t    {\n+\t      if (! different_binding_level)\n+\t\t{\n+\t\t  TREE_TYPE (olddecl) = TREE_TYPE (newdecl);\n+\t\t  DECL_BUILT_IN (olddecl) = 0;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      /* If redeclaring a builtin function, and not a definition,\n+\t\t it stays built in.  */\n+\t      DECL_BUILT_IN (newdecl) = 1;\n+\t      DECL_FUNCTION_CODE (newdecl) = DECL_FUNCTION_CODE (olddecl);\n+\t    }\n \t}\n-      else\n+      /* Also preserve various other info from the definition.  */\n+      else if (! new_is_definition)\n \tDECL_FRAME_SIZE (newdecl) = DECL_FRAME_SIZE (olddecl);\n-\n-      DECL_RESULT (newdecl) = DECL_RESULT (olddecl);\n-      DECL_INITIAL (newdecl) = DECL_INITIAL (olddecl);\n-      DECL_SAVED_INSNS (newdecl) = DECL_SAVED_INSNS (olddecl);\n-      DECL_ARGUMENTS (newdecl) = DECL_ARGUMENTS (olddecl);\n+      if (! new_is_definition)\n+\t{\n+\t  DECL_RESULT (newdecl) = DECL_RESULT (olddecl);\n+\t  /* When called with different_binding_level set, don't copy over\n+\t     DECL_INITIAL, so that we don't accidentally change function\n+\t     declarations into function definitions.  */\n+\t  if (! different_binding_level)\n+\t    DECL_INITIAL (newdecl) = DECL_INITIAL (olddecl);\n+\t  DECL_SAVED_INSNS (newdecl) = DECL_SAVED_INSNS (olddecl);\n+\t  DECL_ARGUMENTS (newdecl) = DECL_ARGUMENTS (olddecl);\n+\t}\n+    }\n+  if (different_binding_level)\n+    {\n+      /* Don't output a duplicate symbol for this declaration.  */\n+      TREE_ASM_WRITTEN (newdecl) = 1;\n+      return 0;\n     }\n \n   /* Copy most of the decl-specific fields of NEWDECL into OLDDECL.\n@@ -1900,15 +1936,21 @@ pushdecl (x)\n     {\n       char *file;\n       int line;\n-      int declared_global;\n+      int different_binding_level = 0;\n \n+      t = lookup_name_current_level (name);\n       /* Don't type check externs here when -traditional.  This is so that\n \t code with conflicting declarations inside blocks will get warnings\n \t not errors.  X11 for instance depends on this.  */\n-      if (DECL_EXTERNAL (x) && TREE_PUBLIC (x) && ! flag_traditional)\n-\tt = lookup_name_current_level_global (name);\n-      else\n-\tt = lookup_name_current_level (name);\n+      if (! t && DECL_EXTERNAL (x) && TREE_PUBLIC (x) && ! flag_traditional)\n+\t{\n+\t  t = IDENTIFIER_GLOBAL_VALUE (name);\n+\t  /* Type decls at global scope don't conflict with externs declared\n+\t     inside lexical blocks.  */\n+\t  if (t && TREE_CODE (t) == TYPE_DECL)\n+\t    t = 0;\n+\t  different_binding_level = 1;\n+\t}\n       if (t != 0 && t == error_mark_node)\n \t/* error_mark_node is 0 for a while during initialization!  */\n \t{\n@@ -1922,10 +1964,27 @@ pushdecl (x)\n \t  line = DECL_SOURCE_LINE (t);\n \t}\n \n-      /* duplicate_decls might write to TREE_PUBLIC (x) and DECL_EXTERNAL (x)\n-\t to make it identical to the initial declaration.  */\n-      declared_global = TREE_PUBLIC (x) || DECL_EXTERNAL (x);\n-      if (t != 0 && duplicate_decls (x, t))\n+      /* If this decl is `static' and an implicit decl was seen previously,\n+\t warn.  But don't complain if -traditional,\n+\t since traditional compilers don't complain.  */\n+      if (! flag_traditional && TREE_PUBLIC (name)\n+\t  /* Don't test for DECL_EXTERNAL, because grokdeclarator\n+\t     sets this for all functions.  */\n+\t  && ! TREE_PUBLIC (x)\n+\t  /* We used to warn also for explicit extern followed by static,\n+\t     but sometimes you need to do it that way.  */\n+\t  && IDENTIFIER_IMPLICIT_DECL (name) != 0)\n+\t{\n+\t  pedwarn (\"`%s' was declared implicitly `extern' and later `static'\",\n+\t\t   IDENTIFIER_POINTER (name));\n+\t  pedwarn_with_file_and_line\n+\t    (DECL_SOURCE_FILE (IDENTIFIER_IMPLICIT_DECL (name)),\n+\t     DECL_SOURCE_LINE (IDENTIFIER_IMPLICIT_DECL (name)),\n+\t     \"previous declaration of `%s'\",\n+\t     IDENTIFIER_POINTER (name));\n+\t}\n+\n+      if (t != 0 && duplicate_decls (x, t, different_binding_level))\n \t{\n \t  if (TREE_CODE (t) == PARM_DECL)\n \t    {\n@@ -1934,32 +1993,7 @@ pushdecl (x)\n \t      TREE_ASM_WRITTEN (t) = TREE_ASM_WRITTEN (x);\n \t      return t;\n \t    }\n-\t  /* If this decl is `static' and an implicit decl was seen previously,\n-\t     warn.  But don't complain if -traditional,\n-\t     since traditional compilers don't complain.  */\n-\t  if (!flag_traditional && TREE_PUBLIC (name)\n-\n-\t      /* should this be '&& ! declared_global' ?  */\n-\t      && ! TREE_PUBLIC (x) && ! DECL_EXTERNAL (x)\n-\n-\t      /* We used to warn also for explicit extern followed by static,\n-\t\t but sometimes you need to do it that way.  */\n-\t      && IDENTIFIER_IMPLICIT_DECL (name) != 0)\n-\t    {\n-\t      pedwarn (\"`%s' was declared implicitly `extern' and later `static'\",\n-\t\t       IDENTIFIER_POINTER (name));\n-\t      pedwarn_with_file_and_line (file, line,\n-\t\t\t\t\t  \"previous declaration of `%s'\",\n-\t\t\t\t\t  IDENTIFIER_POINTER (name));\n-\t    }\n-\n-\t  /* If this is a global decl, and there exists a conflicting local\n-\t     decl in a parent block, then we can't return as yet, because we\n-\t     need to register this decl in the current binding block.  */\n-\t  /* A test for TREE_PUBLIC (x) will fail for variables that have\n-\t     been declared static first, and extern now.  */\n-\t  if (! declared_global || lookup_name (name) == t)\n-\t    return t;\n+\t  return t;\n \t}\n \n       /* If we are processing a typedef statement, generate a whole new\n@@ -2145,6 +2179,10 @@ pushdecl (x)\n \t      /* Okay to declare a non-ANSI built-in as anything.  */\n \t      else if (t != 0 && DECL_BUILT_IN_NONANSI (t))\n \t\t;\n+\t      /* Okay to have global type decl after an earlier extern\n+\t\t declaration inside a lexical block.  */\n+\t      else if (TREE_CODE (x) == TYPE_DECL)\n+\t\t;\n \t      else if (IDENTIFIER_IMPLICIT_DECL (name))\n \t\tpedwarn (\"`%s' was declared implicitly `extern' and later `static'\",\n \t\t\t IDENTIFIER_POINTER (name));\n@@ -2217,11 +2255,11 @@ pushdecl (x)\n \t     and no file-scope declaration has yet been seen,\n \t     then if we later have a file-scope decl it must not be static.  */\n \t  if (oldlocal == 0\n-\t      && oldglobal == 0\n \t      && DECL_EXTERNAL (x)\n \t      && TREE_PUBLIC (x))\n \t    {\n-\t      TREE_PUBLIC (name) = 1;\n+\t      if (oldglobal == 0)\n+\t        TREE_PUBLIC (name) = 1;\n \n \t      /* Save this decl, so that we can do type checking against\n \t\t other decls after it falls out of scope.\n@@ -2731,29 +2769,6 @@ lookup_name_current_level (name)\n \n   return t;\n }\n-\n-/* Similar to `lookup_name_current_level' but also look at the global binding\n-   level.  */\n-\n-tree\n-lookup_name_current_level_global (name)\n-     tree name;\n-{\n-  register tree t = 0;\n-\n-  if (current_binding_level == global_binding_level)\n-    return IDENTIFIER_GLOBAL_VALUE (name);\n-\n-  if (IDENTIFIER_LOCAL_VALUE (name) != 0)\n-    for (t = current_binding_level->names; t; t = TREE_CHAIN (t))\n-      if (DECL_NAME (t) == name)\n-\tbreak;\n-\n-  if (t == 0)\n-    t = IDENTIFIER_GLOBAL_VALUE (name);\n-\n-  return t;\n-}\n \f\n /* Create the predefined scalar types of C,\n    and some nodes representing standard constants (0, 1, (void *)0)."}]}