{"sha": "46081bb341bba053f5aa906029c5d2fa89569fc2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDYwODFiYjM0MWJiYTA1M2Y1YWE5MDYwMjljNWQyZmE4OTU2OWZjMg==", "commit": {"author": {"name": "Stuart Hastings", "email": "stuart@apple.com", "date": "2002-10-10T23:16:54Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2002-10-10T23:16:54Z"}, "message": "cse.c (struct cse_reg_info): Add subreg_ticked.\n\n2002-10-10  Stuart Hastings  <stuart@apple.com>\n\n\t* cse.c (struct cse_reg_info): Add subreg_ticked.\n\t(SUBREG_TICKED): New.\n\t(get_cse_reg_info): Initialize SUBREG_TICKED.\n\t(mention_regs): Use it.\n\t(invalidate): Set SUBREG_TICKED.\n\t(invalidate_for_call): Likewise.\n\t(addr_affects_sp_p): Likewise.\n\nFrom-SVN: r58035", "tree": {"sha": "5c8b7544eae4091a0a2cedc289212b7e6ea34c75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c8b7544eae4091a0a2cedc289212b7e6ea34c75"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46081bb341bba053f5aa906029c5d2fa89569fc2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46081bb341bba053f5aa906029c5d2fa89569fc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46081bb341bba053f5aa906029c5d2fa89569fc2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46081bb341bba053f5aa906029c5d2fa89569fc2/comments", "author": null, "committer": null, "parents": [{"sha": "e89fe41c872ca6495ce74543ecb6824c203bab70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e89fe41c872ca6495ce74543ecb6824c203bab70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e89fe41c872ca6495ce74543ecb6824c203bab70"}], "stats": {"total": 84, "additions": 77, "deletions": 7}, "files": [{"sha": "a7d8310a2c3eda6c05c518058e300306b21e8e7b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46081bb341bba053f5aa906029c5d2fa89569fc2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46081bb341bba053f5aa906029c5d2fa89569fc2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=46081bb341bba053f5aa906029c5d2fa89569fc2", "patch": "@@ -1,3 +1,13 @@\n+2002-10-10  Stuart Hastings  <stuart@apple.com>\n+\n+\t* cse.c (struct cse_reg_info): Add subreg_ticked.\n+\t(SUBREG_TICKED): New.\n+\t(get_cse_reg_info): Initialize SUBREG_TICKED.\n+\t(mention_regs): Use it.\n+\t(invalidate): Set SUBREG_TICKED.\n+\t(invalidate_for_call): Likewise.\n+\t(addr_affects_sp_p): Likewise.\n+\n 2002-10-10  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/i386/i386.md (tls_local_dynamic_base): Put pic reg"}, {"sha": "f212fd94a98471e2712d459f95b4d10f4b179601", "filename": "gcc/cse.c", "status": "modified", "additions": 30, "deletions": 7, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46081bb341bba053f5aa906029c5d2fa89569fc2/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46081bb341bba053f5aa906029c5d2fa89569fc2/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=46081bb341bba053f5aa906029c5d2fa89569fc2", "patch": "@@ -316,6 +316,10 @@ struct cse_reg_info\n      reg_tick value, such expressions existing in the hash table are\n      invalid.  */\n   int reg_in_table;\n+\n+  /* The SUBREG that was set when REG_TICK was last incremented.  Set\n+     to -1 if the last store was to the whole register, not a subreg.  */\n+  int subreg_ticked;\n };\n \n /* A free list of cse_reg_info entries.  */\n@@ -514,6 +518,11 @@ struct table_elt\n \n #define REG_IN_TABLE(N) ((GET_CSE_REG_INFO (N))->reg_in_table)\n \n+/* Get the SUBREG set at the last increment to REG_TICK (-1 if not a\n+   SUBREG).  */\n+\n+#define SUBREG_TICKED(N) ((GET_CSE_REG_INFO (N))->subreg_ticked)\n+\n /* Get the quantity number for REG.  */\n \n #define REG_QTY(N) ((GET_CSE_REG_INFO (N))->reg_qty)\n@@ -957,6 +966,7 @@ get_cse_reg_info (regno)\n       /* Initialize it.  */\n       p->reg_tick = 1;\n       p->reg_in_table = -1;\n+      p->subreg_ticked = -1;\n       p->reg_qty = regno;\n       p->regno = regno;\n       p->next = cse_reg_info_used_list;\n@@ -1191,6 +1201,7 @@ mention_regs (x)\n \t    remove_invalid_refs (i);\n \n \t  REG_IN_TABLE (i) = REG_TICK (i);\n+\t  SUBREG_TICKED (i) = -1;\n \t}\n \n       return 0;\n@@ -1206,17 +1217,20 @@ mention_regs (x)\n \n       if (REG_IN_TABLE (i) >= 0 && REG_IN_TABLE (i) != REG_TICK (i))\n \t{\n-\t  /* If reg_tick has been incremented more than once since\n-\t     reg_in_table was last set, that means that the entire\n-\t     register has been set before, so discard anything memorized\n-\t     for the entire register, including all SUBREG expressions.  */\n-\t  if (REG_IN_TABLE (i) != REG_TICK (i) - 1)\n+\t  /* If REG_IN_TABLE (i) differs from REG_TICK (i) by one, and\n+\t     the last store to this register really stored into this\n+\t     subreg, then remove the memory of this subreg.\n+\t     Otherwise, remove any memory of the entire register and\n+\t     all its subregs from the table.  */\n+\t  if (REG_TICK (i) - REG_IN_TABLE (i) > 1\n+\t      || SUBREG_TICKED (i) != SUBREG_REG (x))\n \t    remove_invalid_refs (i);\n \t  else\n \t    remove_invalid_subreg_refs (i, SUBREG_BYTE (x), GET_MODE (x));\n \t}\n \n       REG_IN_TABLE (i) = REG_TICK (i);\n+      SUBREG_TICKED (i) = SUBREG_REG (x);\n       return 0;\n     }\n \n@@ -1861,6 +1875,7 @@ invalidate (x, full_mode)\n \n \tdelete_reg_equiv (regno);\n \tREG_TICK (regno)++;\n+\tSUBREG_TICKED (regno) = -1;\n \n \tif (regno >= FIRST_PSEUDO_REGISTER)\n \t  {\n@@ -1888,6 +1903,7 @@ invalidate (x, full_mode)\n \t\tCLEAR_HARD_REG_BIT (hard_regs_in_table, rn);\n \t\tdelete_reg_equiv (rn);\n \t\tREG_TICK (rn)++;\n+\t\tSUBREG_TICKED (rn) = -1;\n \t      }\n \n \t    if (in_table)\n@@ -2093,7 +2109,10 @@ invalidate_for_call ()\n       {\n \tdelete_reg_equiv (regno);\n \tif (REG_TICK (regno) >= 0)\n-\t  REG_TICK (regno)++;\n+\t  {\n+\t    REG_TICK (regno)++;\n+\t    SUBREG_TICKED (regno) = -1;\n+\t  }\n \n \tin_table |= (TEST_HARD_REG_BIT (hard_regs_in_table, regno) != 0);\n       }\n@@ -6407,7 +6426,11 @@ addr_affects_sp_p (addr)\n       && REGNO (XEXP (addr, 0)) == STACK_POINTER_REGNUM)\n     {\n       if (REG_TICK (STACK_POINTER_REGNUM) >= 0)\n-\tREG_TICK (STACK_POINTER_REGNUM)++;\n+\t{\n+\t  REG_TICK (STACK_POINTER_REGNUM)++;\n+\t  /* Is it possible to use a subreg of SP?  */\n+\t  SUBREG_TICKED (STACK_POINTER_REGNUM) = -1;\n+\t}\n \n       /* This should be *very* rare.  */\n       if (TEST_HARD_REG_BIT (hard_regs_in_table, STACK_POINTER_REGNUM))"}, {"sha": "425a8f6e4c86fb3592ccedf303c28f352676d9fc", "filename": "gcc/testsuite/gcc.c-torture/execute/20021010-2.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46081bb341bba053f5aa906029c5d2fa89569fc2/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20021010-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46081bb341bba053f5aa906029c5d2fa89569fc2/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20021010-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20021010-2.c?ref=46081bb341bba053f5aa906029c5d2fa89569fc2", "patch": "@@ -0,0 +1,37 @@\n+/* cse.c failure on x86 target.\n+   Contributed by Stuart Hastings 10 Oct 2002 <stuart@apple.com> */\n+#include <stdlib.h>\n+\n+typedef signed short SInt16;\n+\n+typedef struct {\n+    SInt16 minx;\n+    SInt16 maxx;\n+    SInt16 miny;\n+    SInt16 maxy;\n+} IOGBounds;\n+\n+int expectedwidth = 50;\n+\n+unsigned int *global_vramPtr = (unsigned int *)0xa000;\n+\n+IOGBounds global_bounds = { 100, 150, 100, 150 };\n+IOGBounds global_saveRect = { 75, 175, 75, 175 };\n+\n+main()\n+{\n+  unsigned int *vramPtr;\n+  int width;\n+  IOGBounds saveRect = global_saveRect;\n+  IOGBounds bounds = global_bounds;\n+\n+  if (saveRect.minx < bounds.minx) saveRect.minx = bounds.minx;\n+  if (saveRect.maxx > bounds.maxx) saveRect.maxx = bounds.maxx;\n+\n+  vramPtr = global_vramPtr + (saveRect.miny - bounds.miny) ;\n+  width = saveRect.maxx - saveRect.minx;\n+\n+  if (width != expectedwidth)\n+    abort ();\n+  exit (0);\n+}"}]}