{"sha": "10b1d5e751023bfe9b2e34befae33ed9cd6bd64c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBiMWQ1ZTc1MTAyM2JmZTliMmUzNGJlZmFlMzNlZDljZDZiZDY0Yw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2003-07-16T00:09:45Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-07-16T00:09:45Z"}, "message": "cp-tree.def (LOOKUP_EXPR): Remove.\n\n\t* cp-tree.def (LOOKUP_EXPR): Remove.\n\t* cp-tree.h (cp_id_kind): Add CP_ID_KIND_UNQUALIFIED_DEPENDENT.\n\t(LOOKUP_EXPR_GLOBAL): Remove.\n\t(get_bindings): Remove.\n\t(is_aggr_type_2): Remove.\n\t* call.c (resolved_scoped_fn_name): Remove support for\n\tLOOKUP_EXPR.\n\t* decl.c (grokfndecl): Likewise.\n\t(grokdeclarator): Likewise.\n\t* error.c (dump_decl): Likewise.\n\t(dump_expr): Likewise.\n\t* friend.c (do_friend): Likewise.\n\t* init.c (build_offset_ref): Likewise.\n\t* lex.c (unqualified_fn_lookup_error): Use pedwarn.  Do not create\n\tLOOKUP_EXPRs\n\t* mangle.c (write_expression): Remove support for LOOKUP_EXPR.\n\t* parser.c (cp_parser_postfix_expression): Modify Koenig lookup\n\ttest.\n\t* pt.c (get_bindings): Give it internal linkage.\n\t(check_explicit_specialization): Remove support for LOOKUP_EXPR.\n\t(lookup_template_function): Likewise.\n\t(for_each_tempalte_parm_r): Likewise.\n\t(tsubst_decl): Likewise.\n\t(tsubst_qualified_id): Handle template template parameters.\n\t(tsubst_copy): Remove support for LOOKUP_EXPR.\n\t(tsubst_copy_and_build): Likewise.\n\t(most_general_template): Likewise.\n\t(value_dependent_expression_p): Likewise.\n\t(type_dependent_expression_p): Note that IDENTIFIER_NODEs are\n\talways dependent.\n\t* semantics.c (perform_koenig_lookup): Do not create\n\tIDENTIFIER_NODEs.\n\t(finish_fname): Likewise.\n\t(finish_id_expression): Likewise.\n\t* tree.c (is_aggr_type_2): Remove.\n\nFrom-SVN: r69427", "tree": {"sha": "3322e2ccf0fe461c605621cdc18981801b890fe3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3322e2ccf0fe461c605621cdc18981801b890fe3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10b1d5e751023bfe9b2e34befae33ed9cd6bd64c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10b1d5e751023bfe9b2e34befae33ed9cd6bd64c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10b1d5e751023bfe9b2e34befae33ed9cd6bd64c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10b1d5e751023bfe9b2e34befae33ed9cd6bd64c/comments", "author": null, "committer": null, "parents": [{"sha": "b0e3f7ec306dafdaf554f5b3eea03de75cec2a84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0e3f7ec306dafdaf554f5b3eea03de75cec2a84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0e3f7ec306dafdaf554f5b3eea03de75cec2a84"}], "stats": {"total": 213, "additions": 88, "deletions": 125}, "files": [{"sha": "b491c2b720b3683a877c438e8fa5f7f8c9757283", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b1d5e751023bfe9b2e34befae33ed9cd6bd64c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b1d5e751023bfe9b2e34befae33ed9cd6bd64c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=10b1d5e751023bfe9b2e34befae33ed9cd6bd64c", "patch": "@@ -1,3 +1,41 @@\n+2003-07-15  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.def (LOOKUP_EXPR): Remove.\n+\t* cp-tree.h (cp_id_kind): Add CP_ID_KIND_UNQUALIFIED_DEPENDENT.\n+\t(LOOKUP_EXPR_GLOBAL): Remove.\n+\t(get_bindings): Remove.\n+\t(is_aggr_type_2): Remove.\n+\t* call.c (resolved_scoped_fn_name): Remove support for\n+\tLOOKUP_EXPR.\n+\t* decl.c (grokfndecl): Likewise.\n+\t(grokdeclarator): Likewise.\n+\t* error.c (dump_decl): Likewise.\n+\t(dump_expr): Likewise.\n+\t* friend.c (do_friend): Likewise.\n+\t* init.c (build_offset_ref): Likewise.\n+\t* lex.c (unqualified_fn_lookup_error): Use pedwarn.  Do not create\n+\tLOOKUP_EXPRs \n+\t* mangle.c (write_expression): Remove support for LOOKUP_EXPR.\n+\t* parser.c (cp_parser_postfix_expression): Modify Koenig lookup\n+\ttest.\n+\t* pt.c (get_bindings): Give it internal linkage.\n+\t(check_explicit_specialization): Remove support for LOOKUP_EXPR.\n+\t(lookup_template_function): Likewise.\n+\t(for_each_tempalte_parm_r): Likewise.\n+\t(tsubst_decl): Likewise.\n+\t(tsubst_qualified_id): Handle template template parameters.\n+\t(tsubst_copy): Remove support for LOOKUP_EXPR.\n+\t(tsubst_copy_and_build): Likewise.\n+\t(most_general_template): Likewise.\n+\t(value_dependent_expression_p): Likewise.\n+\t(type_dependent_expression_p): Note that IDENTIFIER_NODEs are\n+\talways dependent.\n+\t* semantics.c (perform_koenig_lookup): Do not create\n+\tIDENTIFIER_NODEs.\n+\t(finish_fname): Likewise.\n+\t(finish_id_expression): Likewise.\n+\t* tree.c (is_aggr_type_2): Remove.\n+\t\n 2003-07-16  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \tPR c++/11531"}, {"sha": "a9323cc1f91d9517f6c83b7a079e7732e1325a76", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b1d5e751023bfe9b2e34befae33ed9cd6bd64c/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b1d5e751023bfe9b2e34befae33ed9cd6bd64c/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=10b1d5e751023bfe9b2e34befae33ed9cd6bd64c", "patch": "@@ -2607,7 +2607,7 @@ build_user_type_conversion (tree totype, tree expr, int flags)\n \n /* Find the possibly overloaded set of functions corresponding to a\n    call of the form SCOPE::NAME (...). NAME might be a\n-   TEMPLATE_ID_EXPR, OVERLOAD, _DECL, IDENTIFIER_NODE or LOOKUP_EXPR.  */\n+   TEMPLATE_ID_EXPR, OVERLOAD, _DECL, or IDENTIFIER_NODE.  */\n \n tree\n resolve_scoped_fn_name (tree scope, tree name)\n@@ -2623,8 +2623,6 @@ resolve_scoped_fn_name (tree scope, tree name)\n     }\n   if (TREE_CODE (name) == OVERLOAD)\n     name = DECL_NAME (get_first_fn (name));\n-  else if (TREE_CODE (name) == LOOKUP_EXPR)\n-    name = TREE_OPERAND (name, 0);\n   \n   if (TREE_CODE (scope) == NAMESPACE_DECL)\n     fn = lookup_namespace_name (scope, name);"}, {"sha": "5e853fea085799271e490b3a02f2a0f35d4e9bb3", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b1d5e751023bfe9b2e34befae33ed9cd6bd64c/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b1d5e751023bfe9b2e34befae33ed9cd6bd64c/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=10b1d5e751023bfe9b2e34befae33ed9cd6bd64c", "patch": "@@ -208,8 +208,7 @@ DEFTREECODE (DEFAULT_ARG, \"default_arg\", 'x', 0)\n    The second is the TREE_LIST or TREE_VEC of explicitly specified\n    arguments.  The template will be a FUNCTION_DECL, TEMPLATE_DECL, or\n    an OVERLOAD.  If the template-id refers to a member template, the\n-   template may be an IDENTIFIER_NODE.  In an uninstantiated template,\n-   the template may be a LOOKUP_EXPR.  */\n+   template may be an IDENTIFIER_NODE.  */\n DEFTREECODE (TEMPLATE_ID_EXPR, \"template_id_expr\", 'e', 2)\n \n /* A list-like node for chaining overloading candidates. TREE_TYPE is \n@@ -220,12 +219,6 @@ DEFTREECODE (OVERLOAD, \"overload\", 'x', 0)\n    tree structure.  */\n DEFTREECODE (WRAPPER, \"wrapper\", 'x', 0)\n \n-/* Used to represent deferred name lookup for dependent names while\n-   parsing a template declaration.  The first argument is an\n-   IDENTIFIER_NODE for the name in question.  The TREE_TYPE is\n-   unused.  */\n-DEFTREECODE (LOOKUP_EXPR, \"lookup_expr\", 'e', 1)\n-\n /* A whole bunch of tree codes for the initial, superficial parsing of\n    templates.  */\n DEFTREECODE (MODOP_EXPR, \"modop_expr\", 'e', 3)"}, {"sha": "8272adc4db489f893466c75bde44c6cada4ee3e9", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b1d5e751023bfe9b2e34befae33ed9cd6bd64c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b1d5e751023bfe9b2e34befae33ed9cd6bd64c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=10b1d5e751023bfe9b2e34befae33ed9cd6bd64c", "patch": "@@ -39,7 +39,6 @@ struct diagnostic_context;\n       IDENTIFIER_MARKED (IDENTIFIER_NODEs)\n       NEW_EXPR_USE_GLOBAL (in NEW_EXPR).\n       DELETE_EXPR_USE_GLOBAL (in DELETE_EXPR).\n-      LOOKUP_EXPR_GLOBAL (in LOOKUP_EXPR).\n       TREE_INDIRECT_USING (in NAMESPACE_DECL).\n       ICS_USER_FLAG (in _CONV)\n       CLEANUP_P (in TRY_BLOCK)\n@@ -359,6 +358,8 @@ typedef enum cp_id_kind\n   CP_ID_KIND_NONE,\n   /* An unqualified-id that is not a template-id.  */\n   CP_ID_KIND_UNQUALIFIED,\n+  /* An uqualified-id that is a dependent name.  */\n+  CP_ID_KIND_UNQUALIFIED_DEPENDENT,\n   /* An unqualified template-id.  */\n   CP_ID_KIND_TEMPLATE_ID,\n   /* A qualified-id.  */\n@@ -2257,14 +2258,13 @@ struct lang_decl GTY(())\n    DECL_TI_TEMPLATE, `template <class U> S<int>::f<U>'.\n \n    As a special case, for a member friend template of a template\n-   class, this value will not be a TEMPLATE_DECL, but rather a\n-   LOOKUP_EXPR, IDENTIFIER_NODE or OVERLOAD indicating the name of\n-   the template and any explicit template arguments provided.  For\n-   example, in:\n+   class, this value will not be a TEMPLATE_DECL, but rather an\n+   IDENTIFIER_NODE or OVERLOAD indicating the name of the template and\n+   any explicit template arguments provided.  For example, in:\n \n      template <class T> struct S { friend void f<int>(int, double); }\n \n-   the DECL_TI_TEMPLATE will be a LOOKUP_EXPR for `f' and the\n+   the DECL_TI_TEMPLATE will be an IDENTIFIER_NODE for `f' and the\n    DECL_TI_ARGS will be {int}.  */\n #define DECL_TI_TEMPLATE(NODE)      TI_TEMPLATE (DECL_TEMPLATE_INFO (NODE))\n \n@@ -2312,7 +2312,6 @@ struct lang_decl GTY(())\n #define NEW_EXPR_USE_GLOBAL(NODE)\tTREE_LANG_FLAG_0 (NODE)\n #define DELETE_EXPR_USE_GLOBAL(NODE)\tTREE_LANG_FLAG_0 (NODE)\n #define DELETE_EXPR_USE_VEC(NODE)\tTREE_LANG_FLAG_1 (NODE)\n-#define LOOKUP_EXPR_GLOBAL(NODE)\tTREE_LANG_FLAG_0 (NODE)\n \n /* Nonzero if this AGGR_INIT_EXPR provides for initialization via a\n    constructor call, rather than an ordinary function call.  */\n@@ -3965,7 +3964,6 @@ extern void mark_class_instantiated\t\t(tree, int);\n extern void do_decl_instantiation\t\t(tree, tree);\n extern void do_type_instantiation\t\t(tree, tree, tsubst_flags_t);\n extern tree instantiate_decl\t\t\t(tree, int);\n-extern tree get_bindings\t\t\t(tree, tree, tree);\n extern int push_tinst_level\t\t\t(tree);\n extern void pop_tinst_level\t\t\t(void);\n extern int more_specialized_class\t\t(tree, tree, tree);\n@@ -4211,7 +4209,6 @@ extern tree ovl_cons                            (tree, tree);\n extern tree build_overload                      (tree, tree);\n extern tree function_arg_chain\t\t\t(tree);\n extern int promotes_to_aggr_type\t\t(tree, enum tree_code);\n-extern int is_aggr_type_2\t\t\t(tree, tree);\n extern const char *cxx_printable_name\t\t(tree, int);\n extern tree build_exception_variant\t\t(tree, tree);\n extern tree bind_template_template_parm\t\t(tree, tree);"}, {"sha": "9147caffa66d6446a50d88ff9af62045a20f9f14", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b1d5e751023bfe9b2e34befae33ed9cd6bd64c/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b1d5e751023bfe9b2e34befae33ed9cd6bd64c/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=10b1d5e751023bfe9b2e34befae33ed9cd6bd64c", "patch": "@@ -8982,7 +8982,6 @@ grokfndecl (tree ctype,\n               fns = TREE_OPERAND (fns, 1);\n             }\n \t  my_friendly_assert (TREE_CODE (fns) == IDENTIFIER_NODE\n-\t                      || TREE_CODE (fns) == LOOKUP_EXPR\n \t                      || TREE_CODE (fns) == OVERLOAD, 20001120);\n \t  DECL_TEMPLATE_INFO (decl) = tree_cons (fns, args, NULL_TREE);\n \n@@ -9804,9 +9803,6 @@ grokdeclarator (tree declarator,\n \t      {\n \t\ttree fns = TREE_OPERAND (decl, 0);\n \n-\t\tif (TREE_CODE (fns) == LOOKUP_EXPR)\n-\t\t  fns = TREE_OPERAND (fns, 0);\n-\n \t\tdname = fns;\n \t\tif (TREE_CODE (dname) == COMPONENT_REF)\n \t\t  dname = TREE_OPERAND (dname, 1);"}, {"sha": "c547d672bc61c24fd9363b0dc9edaf2a96188f1d", "filename": "gcc/cp/error.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b1d5e751023bfe9b2e34befae33ed9cd6bd64c/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b1d5e751023bfe9b2e34befae33ed9cd6bd64c/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=10b1d5e751023bfe9b2e34befae33ed9cd6bd64c", "patch": "@@ -956,10 +956,6 @@ dump_decl (tree t, int flags)\n       }\n       break;\n \n-    case LOOKUP_EXPR:\n-      dump_decl (TREE_OPERAND (t, 0), flags);\n-      break;\n-\n     case LABEL_DECL:\n       print_tree_identifier (scratch_buffer, DECL_NAME (t));\n       break;\n@@ -1957,10 +1953,6 @@ dump_expr (tree t, int flags)\n       print_right_paren (scratch_buffer);\n       break;\n \n-    case LOOKUP_EXPR:\n-      print_tree_identifier (scratch_buffer, TREE_OPERAND (t, 0));\n-      break;\n-\n     case ARROW_EXPR:\n       dump_expr (TREE_OPERAND (t, 0), flags);\n       output_add_string (scratch_buffer, \"->\");"}, {"sha": "220b01214bb50fb48459eedbc1a04bc74b1b01fa", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b1d5e751023bfe9b2e34befae33ed9cd6bd64c/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b1d5e751023bfe9b2e34befae33ed9cd6bd64c/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=10b1d5e751023bfe9b2e34befae33ed9cd6bd64c", "patch": "@@ -333,8 +333,6 @@ do_friend (tree ctype, tree declarator, tree decl, tree parmdecls,\n   if (TREE_CODE (declarator) == TEMPLATE_ID_EXPR)\n     {\n       declarator = TREE_OPERAND (declarator, 0);\n-      if (TREE_CODE (declarator) == LOOKUP_EXPR)\n-\tdeclarator = TREE_OPERAND (declarator, 0);\n       if (is_overloaded_fn (declarator))\n \tdeclarator = DECL_NAME (get_first_fn (declarator));\n     }"}, {"sha": "dad52284e6377995cbf5aff22d9677edc1d8e83b", "filename": "gcc/cp/init.c", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b1d5e751023bfe9b2e34befae33ed9cd6bd64c/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b1d5e751023bfe9b2e34befae33ed9cd6bd64c/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=10b1d5e751023bfe9b2e34befae33ed9cd6bd64c", "patch": "@@ -1374,16 +1374,10 @@ build_offset_ref (tree type, tree name)\n \tname = DECL_NAME (name);\n       else\n \t{\n-\t  if (TREE_CODE (name) == LOOKUP_EXPR)\n-\t    /* This can happen during tsubst'ing.  */\n-\t    name = TREE_OPERAND (name, 0);\n-\t  else\n-\t    {\n-\t      if (TREE_CODE (name) == COMPONENT_REF)\n-\t\tname = TREE_OPERAND (name, 1);\n-\t      if (TREE_CODE (name) == OVERLOAD)\n-\t\tname = DECL_NAME (OVL_CURRENT (name));\n-\t    }\n+\t  if (TREE_CODE (name) == COMPONENT_REF)\n+\t    name = TREE_OPERAND (name, 1);\n+\t  if (TREE_CODE (name) == OVERLOAD)\n+\t    name = DECL_NAME (OVL_CURRENT (name));\n \t}\n \n       my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 0);"}, {"sha": "2266f04080ef3e6ef42be02c1cc99415ab65340d", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b1d5e751023bfe9b2e34befae33ed9cd6bd64c/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b1d5e751023bfe9b2e34befae33ed9cd6bd64c/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=10b1d5e751023bfe9b2e34befae33ed9cd6bd64c", "patch": "@@ -710,10 +710,9 @@ unqualified_fn_lookup_error (tree name)\n \t declaration of \"f\" is available.  Historically, G++ and most\n \t other compilers accepted that usage; explain to the user what\n \t is going wrong.  */\n-      (flag_permissive ? warning : error)\n-\t(\"there are no arguments to `%D' that depend on a template \"\n-\t \"parameter, so a declaration of `%D' must be available\", name,\n-\t name);\n+      pedwarn (\"there are no arguments to `%D' that depend on a template \"\n+\t       \"parameter, so a declaration of `%D' must be available\", \n+\t       name, name);\n       \n       if (!flag_permissive)\n \t{\n@@ -726,7 +725,7 @@ unqualified_fn_lookup_error (tree name)\n \t      hint = true;\n \t    }\n \t}\n-      return build_min_nt (LOOKUP_EXPR, name);\n+      return name;\n     }\n \n   return unqualified_name_lookup_error (name);"}, {"sha": "ba7cf92c052a74292d3594b5b60887cc1243d71c", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b1d5e751023bfe9b2e34befae33ed9cd6bd64c/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b1d5e751023bfe9b2e34befae33ed9cd6bd64c/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=10b1d5e751023bfe9b2e34befae33ed9cd6bd64c", "patch": "@@ -1926,8 +1926,6 @@ write_expression (tree expr)\n \t    {\n \t      template_args = TREE_OPERAND (member, 1);\n \t      member = TREE_OPERAND (member, 0);\n-\t      if (TREE_CODE (member) == LOOKUP_EXPR)\n-\t\tmember = TREE_OPERAND (member, 0);\n \t    }\n \t  else\n \t    template_args = NULL_TREE;"}, {"sha": "33f1d793ce0ce019d144a788432694ee089208a2", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b1d5e751023bfe9b2e34befae33ed9cd6bd64c/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b1d5e751023bfe9b2e34befae33ed9cd6bd64c/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=10b1d5e751023bfe9b2e34befae33ed9cd6bd64c", "patch": "@@ -3438,7 +3438,8 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n   /* Keep looping until the postfix-expression is complete.  */\n   while (true)\n     {\n-      if (TREE_CODE (postfix_expression) == IDENTIFIER_NODE\n+      if (idk == CP_ID_KIND_UNQUALIFIED\n+\t  && TREE_CODE (postfix_expression) == IDENTIFIER_NODE\n \t  && cp_lexer_next_token_is_not (parser->lexer, CPP_OPEN_PAREN))\n \t/* It is not a Koenig lookup function call.  */\n \tpostfix_expression "}, {"sha": "8712ce6efb74afd0e96af785c15c913ead45609e", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 28, "deletions": 56, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b1d5e751023bfe9b2e34befae33ed9cd6bd64c/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b1d5e751023bfe9b2e34befae33ed9cd6bd64c/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=10b1d5e751023bfe9b2e34befae33ed9cd6bd64c", "patch": "@@ -132,6 +132,7 @@ static int template_parm_this_level_p (tree, void *);\n static tree tsubst_friend_function (tree, tree);\n static tree tsubst_friend_class (tree, tree);\n static int can_complete_type_without_circularity (tree);\n+static tree get_bindings (tree, tree, tree);\n static tree get_bindings_real (tree, tree, tree, int, int, int);\n static int template_decl_level (tree);\n static int check_cv_quals_for_unify (int, tree, tree);\n@@ -1639,15 +1640,6 @@ check_explicit_specialization (tree declarator,\n \n \t  return decl;\n \t}\n-      else if (TREE_CODE (TREE_OPERAND (declarator, 0)) == LOOKUP_EXPR)\n-\t{\n-\t  /* A friend declaration.  We can't do much, because we don't\n-\t     know what this resolves to, yet.  */\n-\t  my_friendly_assert (is_friend != 0, 0);\n-\t  my_friendly_assert (!explicit_instantiation, 0);\n-\t  SET_DECL_IMPLICIT_INSTANTIATION (decl);\n-\t  return decl;\n-\t} \n       else if (ctype != NULL_TREE \n \t       && (TREE_CODE (TREE_OPERAND (declarator, 0)) ==\n \t\t   IDENTIFIER_NODE))\n@@ -3905,8 +3897,7 @@ lookup_template_function (tree fns, tree arglist)\n   my_friendly_assert (TREE_CODE (fns) == TEMPLATE_DECL\n \t\t      || TREE_CODE (fns) == OVERLOAD\n \t\t      || BASELINK_P (fns)\n-\t\t      || TREE_CODE (fns) == IDENTIFIER_NODE\n-\t\t      || TREE_CODE (fns) == LOOKUP_EXPR,\n+\t\t      || TREE_CODE (fns) == IDENTIFIER_NODE,\n \t\t      20020730);\n \n   if (BASELINK_P (fns))\n@@ -4579,7 +4570,6 @@ for_each_template_parm_r (tree* tp, int* walk_subtrees, void* d)\n     case ARROW_EXPR:\n     case DOTSTAR_EXPR:\n     case TYPEID_EXPR:\n-    case LOOKUP_EXPR:\n     case PSEUDO_DTOR_EXPR:\n       if (!fn)\n \treturn error_mark_node;\n@@ -5965,10 +5955,10 @@ tsubst_decl (tree t, tree args, tree type, tsubst_flags_t complain)\n \t\t };\n \n \t       Here, the DECL_TI_TEMPLATE for the friend declaration\n-\t       will be a LOOKUP_EXPR or an IDENTIFIER_NODE.  We are\n-\t       being called from tsubst_friend_function, and we want\n-\t       only to create a new decl (R) with appropriate types so\n-\t       that we can call determine_specialization.  */\n+\t       will be an IDENTIFIER_NODE.  We are being called from\n+\t       tsubst_friend_function, and we want only to create a\n+\t       new decl (R) with appropriate types so that we can call\n+\t       determine_specialization.  */\n \t    gen_tmpl = NULL_TREE;\n \t  }\n \n@@ -7143,6 +7133,18 @@ tsubst_qualified_id (tree qualified_id, tree args,\n     }\n   else\n     expr = name;\n+\n+  /* This case can occur while determining which of two templates is\n+     the more specialized.  After performing argument deduction, we\n+     check that no invalid types are created.  During that phase, we\n+     may seem uninstantiated template parameters.  */\n+  if (TREE_CODE (scope) == BOUND_TEMPLATE_TEMPLATE_PARM)\n+    {\n+      if (is_template)\n+\texpr = lookup_template_function (expr, template_args);\n+      return build_nt (SCOPE_REF, scope, expr);\n+    }\n+\n   if (!BASELINK_P (name) && !DECL_P (expr))\n     expr = lookup_qualified_name (scope, expr, /*is_type_p=*/0,\n \t\t\t\t  (complain & tf_error) != 0);\n@@ -7160,7 +7162,7 @@ tsubst_qualified_id (tree qualified_id, tree args,\n     }\n \n   if (is_template)\n-    lookup_template_function (expr, template_args);\n+    expr = lookup_template_function (expr, template_args);\n \n   if (TYPE_P (scope))\n     {\n@@ -7286,25 +7288,6 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t/* Ordinary template template argument.  */\n \treturn t;\n \n-    case LOOKUP_EXPR:\n-      {\n-\t/* We must tsubst into a LOOKUP_EXPR in case the names to\n-\t   which it refers is a conversion operator; in that case the\n-\t   name will change.  We avoid making unnecessary copies,\n-\t   however.  */\n-\t\n-\ttree id = tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl);\n-\n-\tif (id != TREE_OPERAND (t, 0))\n-\t  {\n-\t    r = build_nt (LOOKUP_EXPR, id);\n-\t    LOOKUP_EXPR_GLOBAL (r) = LOOKUP_EXPR_GLOBAL (t);\n-\t    t = r;\n-\t  }\n-\n-\treturn t;\n-      }\n-\n     case CAST_EXPR:\n     case REINTERPRET_CAST_EXPR:\n     case CONST_CAST_EXPR:\n@@ -7907,44 +7890,29 @@ tsubst_copy_and_build (tree t,\n \n   switch (TREE_CODE (t))\n     {\n-    case LOOKUP_EXPR:\n     case IDENTIFIER_NODE:\n       {\n \ttree decl;\n-\ttree scope;\n \tcp_id_kind idk;\n \ttree qualifying_class;\n \tbool non_constant_expression_p;\n \tconst char *error_msg;\n \n-\t/* Remember whether this identifier was explicitly qualified\n-\t   with \"::\".  */\n-\tif (TREE_CODE (t) == LOOKUP_EXPR && LOOKUP_EXPR_GLOBAL (t))\n-\t  scope = global_namespace;\n-\telse\n-\t  scope = NULL_TREE;\n-\t/* Get at the underlying identifier.  */\n-\tif (TREE_CODE (t) == LOOKUP_EXPR)\n-\t  t = TREE_OPERAND (t, 0);\n-\n \tif (IDENTIFIER_TYPENAME_P (t))\n \t  {\n \t    tree new_type = tsubst (TREE_TYPE (t), args, complain, in_decl);\n \t    t = mangle_conv_op_name_for_type (new_type);\n \t  }\n \n \t/* Look up the name.  */\n-\tif (scope == global_namespace)\n-\t  decl = IDENTIFIER_GLOBAL_VALUE (t);\n-\telse\n-\t  decl = lookup_name (t, 0);\n+\tdecl = lookup_name (t, 0);\n \n \t/* By convention, expressions use ERROR_MARK_NODE to indicate\n \t   failure, not NULL_TREE.  */\n \tif (decl == NULL_TREE)\n \t  decl = error_mark_node;\n \n-\tdecl = finish_id_expression (t, decl, scope,\n+\tdecl = finish_id_expression (t, decl, NULL_TREE,\n \t\t\t\t     &idk,\n \t\t\t\t     &qualifying_class,\n \t\t\t\t     /*constant_expression_p=*/false,\n@@ -10203,8 +10171,8 @@ most_general_template (tree decl)\n   /* Look for more and more general templates.  */\n   while (DECL_TEMPLATE_INFO (decl))\n     {\n-      /* The DECL_TI_TEMPLATE can be a LOOKUP_EXPR or IDENTIFIER_NODE\n-\t in some cases.  (See cp-tree.h for details.)  */\n+      /* The DECL_TI_TEMPLATE can be an IDENTIFIER_NODE in some cases.\n+\t (See cp-tree.h for details.)  */\n       if (TREE_CODE (DECL_TI_TEMPLATE (decl)) != TEMPLATE_DECL)\n \tbreak;\n \n@@ -11493,7 +11461,7 @@ value_dependent_expression_p (tree expression)\n     return false;\n \n   /* A name declared with a dependent type.  */\n-  if (TREE_CODE (expression) == LOOKUP_EXPR\n+  if (TREE_CODE (expression) == IDENTIFIER_NODE\n       || (DECL_P (expression) \n \t  && type_dependent_expression_p (expression)))\n     return true;\n@@ -11595,6 +11563,10 @@ type_dependent_expression_p (tree expression)\n \n   if (expression == error_mark_node)\n     return false;\n+\n+  /* An unresolved name is always dependent.  */\n+  if (TREE_CODE (expression) == IDENTIFIER_NODE)\n+    return true;\n   \n   /* Some expression forms are never type-dependent.  */\n   if (TREE_CODE (expression) == PSEUDO_DTOR_EXPR"}, {"sha": "02783859cb42a545cdf156a7559d379e10becd7d", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b1d5e751023bfe9b2e34befae33ed9cd6bd64c/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b1d5e751023bfe9b2e34befae33ed9cd6bd64c/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=10b1d5e751023bfe9b2e34befae33ed9cd6bd64c", "patch": "@@ -1512,7 +1512,7 @@ perform_koenig_lookup (tree fn, tree args)\n \tfn = unqualified_fn_lookup_error (identifier);\n     }\n   else\n-    fn = build_min_nt (LOOKUP_EXPR, identifier);\n+    fn = identifier;\n \n   return fn;\n }\n@@ -1819,7 +1819,7 @@ finish_fname (tree id)\n   \n   decl = fname_decl (C_RID_CODE (id), id);\n   if (processing_template_decl)\n-    decl = build_min_nt (LOOKUP_EXPR, DECL_NAME (decl));\n+    decl = DECL_NAME (decl);\n   return decl;\n }\n \n@@ -2372,12 +2372,6 @@ finish_id_expression (tree id_expression,\n \t An id-expression is type-dependent if it contains an\n \t identifier that was declared with a dependent type.\n \n-\t As an optimization, we could choose not to create a\n-\t LOOKUP_EXPR for a name that resolved to a local variable in\n-\t the template function that we are currently declaring; such a\n-\t name cannot ever resolve to anything else.  If we did that we\n-\t would not have to look up these names at instantiation time.\n-\n \t The standard is not very specific about an id-expression that\n \t names a set of overloaded functions.  What if some of them\n \t have dependent types and some of them do not?  Presumably,\n@@ -2469,8 +2463,8 @@ finish_id_expression (tree id_expression,\n \t     constant when things are instantiated.  */\n \t  if (constant_expression_p)\n \t    *non_constant_expression_p = true;\n-\t  /* Create a LOOKUP_EXPR for other unqualified names.  */\n-\t  return build_min_nt (LOOKUP_EXPR, id_expression);\n+\t  *idk = CP_ID_KIND_UNQUALIFIED_DEPENDENT;\n+\t  return id_expression;\n \t}\n \n       /* Only certain kinds of names are allowed in constant"}, {"sha": "72173fe48bb6c0c481181850bc19b5dd69a9cecd", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b1d5e751023bfe9b2e34befae33ed9cd6bd64c/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b1d5e751023bfe9b2e34befae33ed9cd6bd64c/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=10b1d5e751023bfe9b2e34befae33ed9cd6bd64c", "patch": "@@ -988,13 +988,6 @@ build_overload (tree decl, tree chain)\n   return ovl_cons (decl, chain);\n }\n \n-int\n-is_aggr_type_2 (tree t1, tree t2)\n-{\n-  if (TREE_CODE (t1) != TREE_CODE (t2))\n-    return 0;\n-  return IS_AGGR_TYPE (t1) && IS_AGGR_TYPE (t2);\n-}\n \f\n #define PRINT_RING_SIZE 4\n "}]}