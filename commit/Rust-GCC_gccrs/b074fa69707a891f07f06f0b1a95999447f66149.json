{"sha": "b074fa69707a891f07f06f0b1a95999447f66149", "node_id": "C_kwDOANBUbNoAKGIwNzRmYTY5NzA3YTg5MWYwN2YwNmYwYjFhOTU5OTk0NDdmNjYxNDk", "commit": {"author": {"name": "Andre Vieira", "email": "andre.simoesdiasvieira@arm.com", "date": "2022-03-22T10:45:23Z"}, "committer": {"name": "Andre Vieira", "email": "andre.simoesdiasvieira@arm.com", "date": "2022-03-22T11:59:21Z"}, "message": "aarch64: Update reg-costs to differentiate between memmove costs\n\nThis patch introduces a struct to differentiate between different memmove costs\nto enable a better modeling of memory operations. These have been modelled for\n-mcpu/-mtune=neoverse-v1/neoverse-n1/neoverse-n2/neoverse-512tvb, for all other\ntunings all entries are equal to the old single memmove cost to ensure the\nbehaviour remains the same.\n\n2022-03-16  Tamar Christina  <tamar.christina@arm.com>\n\t    Andre Vieira  <andre.simoesdiasvieira@arm.com>\n\ngcc/ChangeLog:\n\n\t* config/aarch64/aarch64-protos.h (struct cpu_memmov_cost): New struct.\n\t(struct tune_params): Change type of memmov_cost to use cpu_memmov_cost.\n\t* config/aarch64/aarch64.cc (aarch64_memory_move_cost): Update all\n\ttunings to use cpu_memmov_cost struct.", "tree": {"sha": "7f603eaafc886f2f6883339b3562c54369d216fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7f603eaafc886f2f6883339b3562c54369d216fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b074fa69707a891f07f06f0b1a95999447f66149", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b074fa69707a891f07f06f0b1a95999447f66149", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b074fa69707a891f07f06f0b1a95999447f66149", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b074fa69707a891f07f06f0b1a95999447f66149/comments", "author": {"login": "avieira-arm", "id": 68072104, "node_id": "MDQ6VXNlcjY4MDcyMTA0", "avatar_url": "https://avatars.githubusercontent.com/u/68072104?v=4", "gravatar_id": "", "url": "https://api.github.com/users/avieira-arm", "html_url": "https://github.com/avieira-arm", "followers_url": "https://api.github.com/users/avieira-arm/followers", "following_url": "https://api.github.com/users/avieira-arm/following{/other_user}", "gists_url": "https://api.github.com/users/avieira-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/avieira-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/avieira-arm/subscriptions", "organizations_url": "https://api.github.com/users/avieira-arm/orgs", "repos_url": "https://api.github.com/users/avieira-arm/repos", "events_url": "https://api.github.com/users/avieira-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/avieira-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "avieira-arm", "id": 68072104, "node_id": "MDQ6VXNlcjY4MDcyMTA0", "avatar_url": "https://avatars.githubusercontent.com/u/68072104?v=4", "gravatar_id": "", "url": "https://api.github.com/users/avieira-arm", "html_url": "https://github.com/avieira-arm", "followers_url": "https://api.github.com/users/avieira-arm/followers", "following_url": "https://api.github.com/users/avieira-arm/following{/other_user}", "gists_url": "https://api.github.com/users/avieira-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/avieira-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/avieira-arm/subscriptions", "organizations_url": "https://api.github.com/users/avieira-arm/orgs", "repos_url": "https://api.github.com/users/avieira-arm/repos", "events_url": "https://api.github.com/users/avieira-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/avieira-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a850930164ebbba2a6e18a39242cd0371b548407", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a850930164ebbba2a6e18a39242cd0371b548407", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a850930164ebbba2a6e18a39242cd0371b548407"}], "stats": {"total": 215, "additions": 188, "deletions": 27}, "files": [{"sha": "46bade28ed6056bea90067d3af1311f300cea559", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b074fa69707a891f07f06f0b1a95999447f66149/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b074fa69707a891f07f06f0b1a95999447f66149/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=b074fa69707a891f07f06f0b1a95999447f66149", "patch": "@@ -507,6 +507,18 @@ struct cpu_prefetch_tune\n   const int default_opt_level;\n };\n \n+/* Model the costs for loads/stores for the register allocators so that it can\n+   do more accurate spill heuristics.  */\n+struct cpu_memmov_cost\n+{\n+  int load_int;\n+  int store_int;\n+  int load_fp;\n+  int store_fp;\n+  int load_pred;\n+  int store_pred;\n+};\n+\n struct tune_params\n {\n   const struct cpu_cost_table *insn_extra_cost;\n@@ -519,7 +531,8 @@ struct tune_params\n      or SVE_NOT_IMPLEMENTED if not applicable.  Only used for tuning\n      decisions, does not disable VLA vectorization.  */\n   unsigned int sve_width;\n-  int memmov_cost;\n+  /* Structure used by reload to cost spills.  */\n+  struct cpu_memmov_cost memmov_cost;\n   int issue_rate;\n   unsigned int fusible_ops;\n   const char *function_align;"}, {"sha": "c10124f26ba28305b798619f9741b8a62843cf33", "filename": "gcc/config/aarch64/aarch64.cc", "status": "modified", "additions": 174, "deletions": 26, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b074fa69707a891f07f06f0b1a95999447f66149/gcc%2Fconfig%2Faarch64%2Faarch64.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b074fa69707a891f07f06f0b1a95999447f66149/gcc%2Fconfig%2Faarch64%2Faarch64.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.cc?ref=b074fa69707a891f07f06f0b1a95999447f66149", "patch": "@@ -1297,7 +1297,13 @@ static const struct tune_params generic_tunings =\n   &generic_branch_cost,\n   &generic_approx_modes,\n   SVE_NOT_IMPLEMENTED, /* sve_width  */\n-  4, /* memmov_cost  */\n+  { 4, /* load_int.  */\n+    4, /* store_int.  */\n+    4, /* load_fp.  */\n+    4, /* store_fp.  */\n+    4, /* load_pred.  */\n+    4 /* store_pred.  */\n+  }, /* memmov_cost.  */\n   2, /* issue_rate  */\n   (AARCH64_FUSE_AES_AESMC | AARCH64_FUSE_CMP_BRANCH), /* fusible_ops  */\n   \"16:12\",\t/* function_align.  */\n@@ -1326,7 +1332,13 @@ static const struct tune_params cortexa35_tunings =\n   &generic_branch_cost,\n   &generic_approx_modes,\n   SVE_NOT_IMPLEMENTED, /* sve_width  */\n-  4, /* memmov_cost  */\n+  { 4, /* load_int.  */\n+    4, /* store_int.  */\n+    4, /* load_fp.  */\n+    4, /* store_fp.  */\n+    4, /* load_pred.  */\n+    4 /* store_pred.  */\n+  }, /* memmov_cost.  */\n   1, /* issue_rate  */\n   (AARCH64_FUSE_AES_AESMC | AARCH64_FUSE_MOV_MOVK | AARCH64_FUSE_ADRP_ADD\n    | AARCH64_FUSE_MOVK_MOVK | AARCH64_FUSE_ADRP_LDR), /* fusible_ops  */\n@@ -1353,7 +1365,13 @@ static const struct tune_params cortexa53_tunings =\n   &generic_branch_cost,\n   &generic_approx_modes,\n   SVE_NOT_IMPLEMENTED, /* sve_width  */\n-  4, /* memmov_cost  */\n+  { 4, /* load_int.  */\n+    4, /* store_int.  */\n+    4, /* load_fp.  */\n+    4, /* store_fp.  */\n+    4, /* load_pred.  */\n+    4 /* store_pred.  */\n+  }, /* memmov_cost.  */\n   2, /* issue_rate  */\n   (AARCH64_FUSE_AES_AESMC | AARCH64_FUSE_MOV_MOVK | AARCH64_FUSE_ADRP_ADD\n    | AARCH64_FUSE_MOVK_MOVK | AARCH64_FUSE_ADRP_LDR), /* fusible_ops  */\n@@ -1380,7 +1398,13 @@ static const struct tune_params cortexa57_tunings =\n   &generic_branch_cost,\n   &generic_approx_modes,\n   SVE_NOT_IMPLEMENTED, /* sve_width  */\n-  4, /* memmov_cost  */\n+  { 4, /* load_int.  */\n+    4, /* store_int.  */\n+    4, /* load_fp.  */\n+    4, /* store_fp.  */\n+    4, /* load_pred.  */\n+    4 /* store_pred.  */\n+  }, /* memmov_cost.  */\n   3, /* issue_rate  */\n   (AARCH64_FUSE_AES_AESMC | AARCH64_FUSE_MOV_MOVK | AARCH64_FUSE_ADRP_ADD\n    | AARCH64_FUSE_MOVK_MOVK), /* fusible_ops  */\n@@ -1407,7 +1431,13 @@ static const struct tune_params cortexa72_tunings =\n   &generic_branch_cost,\n   &generic_approx_modes,\n   SVE_NOT_IMPLEMENTED, /* sve_width  */\n-  4, /* memmov_cost  */\n+  { 4, /* load_int.  */\n+    4, /* store_int.  */\n+    4, /* load_fp.  */\n+    4, /* store_fp.  */\n+    4, /* load_pred.  */\n+    4 /* store_pred.  */\n+  }, /* memmov_cost.  */\n   3, /* issue_rate  */\n   (AARCH64_FUSE_AES_AESMC | AARCH64_FUSE_MOV_MOVK | AARCH64_FUSE_ADRP_ADD\n    | AARCH64_FUSE_MOVK_MOVK), /* fusible_ops  */\n@@ -1434,7 +1464,13 @@ static const struct tune_params cortexa73_tunings =\n   &generic_branch_cost,\n   &generic_approx_modes,\n   SVE_NOT_IMPLEMENTED, /* sve_width  */\n-  4, /* memmov_cost.  */\n+  { 4, /* load_int.  */\n+    4, /* store_int.  */\n+    4, /* load_fp.  */\n+    4, /* store_fp.  */\n+    4, /* load_pred.  */\n+    4 /* store_pred.  */\n+  }, /* memmov_cost.  */\n   2, /* issue_rate.  */\n   (AARCH64_FUSE_AES_AESMC | AARCH64_FUSE_MOV_MOVK | AARCH64_FUSE_ADRP_ADD\n    | AARCH64_FUSE_MOVK_MOVK | AARCH64_FUSE_ADRP_LDR), /* fusible_ops  */\n@@ -1463,7 +1499,13 @@ static const struct tune_params exynosm1_tunings =\n   &generic_branch_cost,\n   &exynosm1_approx_modes,\n   SVE_NOT_IMPLEMENTED, /* sve_width  */\n-  4,\t/* memmov_cost  */\n+  { 4, /* load_int.  */\n+    4, /* store_int.  */\n+    4, /* load_fp.  */\n+    4, /* store_fp.  */\n+    4, /* load_pred.  */\n+    4 /* store_pred.  */\n+  }, /* memmov_cost.  */\n   3,\t/* issue_rate  */\n   (AARCH64_FUSE_AES_AESMC), /* fusible_ops  */\n   \"4\",\t/* function_align.  */\n@@ -1489,7 +1531,13 @@ static const struct tune_params thunderxt88_tunings =\n   &generic_branch_cost,\n   &generic_approx_modes,\n   SVE_NOT_IMPLEMENTED, /* sve_width  */\n-  6, /* memmov_cost  */\n+  { 6, /* load_int.  */\n+    6, /* store_int.  */\n+    6, /* load_fp.  */\n+    6, /* store_fp.  */\n+    6, /* load_pred.  */\n+    6 /* store_pred.  */\n+  }, /* memmov_cost.  */\n   2, /* issue_rate  */\n   AARCH64_FUSE_ALU_BRANCH, /* fusible_ops  */\n   \"8\",\t/* function_align.  */\n@@ -1515,7 +1563,13 @@ static const struct tune_params thunderx_tunings =\n   &generic_branch_cost,\n   &generic_approx_modes,\n   SVE_NOT_IMPLEMENTED, /* sve_width  */\n-  6, /* memmov_cost  */\n+  { 6, /* load_int.  */\n+    6, /* store_int.  */\n+    6, /* load_fp.  */\n+    6, /* store_fp.  */\n+    6, /* load_pred.  */\n+    6 /* store_pred.  */\n+  }, /* memmov_cost.  */\n   2, /* issue_rate  */\n   AARCH64_FUSE_ALU_BRANCH, /* fusible_ops  */\n   \"8\",\t/* function_align.  */\n@@ -1542,7 +1596,13 @@ static const struct tune_params tsv110_tunings =\n   &generic_branch_cost,\n   &generic_approx_modes,\n   SVE_NOT_IMPLEMENTED, /* sve_width  */\n-  4,    /* memmov_cost  */\n+  { 4, /* load_int.  */\n+    4, /* store_int.  */\n+    4, /* load_fp.  */\n+    4, /* store_fp.  */\n+    4, /* load_pred.  */\n+    4 /* store_pred.  */\n+  }, /* memmov_cost.  */\n   4,    /* issue_rate  */\n   (AARCH64_FUSE_AES_AESMC | AARCH64_FUSE_ALU_BRANCH\n    | AARCH64_FUSE_ALU_CBZ), /* fusible_ops  */\n@@ -1569,7 +1629,13 @@ static const struct tune_params xgene1_tunings =\n   &generic_branch_cost,\n   &xgene1_approx_modes,\n   SVE_NOT_IMPLEMENTED, /* sve_width  */\n-  6, /* memmov_cost  */\n+  { 6, /* load_int.  */\n+    6, /* store_int.  */\n+    6, /* load_fp.  */\n+    6, /* store_fp.  */\n+    6, /* load_pred.  */\n+    6 /* store_pred.  */\n+  }, /* memmov_cost.  */\n   4, /* issue_rate  */\n   AARCH64_FUSE_NOTHING, /* fusible_ops  */\n   \"16\",\t/* function_align.  */\n@@ -1595,7 +1661,13 @@ static const struct tune_params emag_tunings =\n   &generic_branch_cost,\n   &xgene1_approx_modes,\n   SVE_NOT_IMPLEMENTED,\n-  6, /* memmov_cost  */\n+  { 6, /* load_int.  */\n+    6, /* store_int.  */\n+    6, /* load_fp.  */\n+    6, /* store_fp.  */\n+    6, /* load_pred.  */\n+    6 /* store_pred.  */\n+  }, /* memmov_cost.  */\n   4, /* issue_rate  */\n   AARCH64_FUSE_NOTHING, /* fusible_ops  */\n   \"16\",\t/* function_align.  */\n@@ -1621,7 +1693,13 @@ static const struct tune_params qdf24xx_tunings =\n   &generic_branch_cost,\n   &generic_approx_modes,\n   SVE_NOT_IMPLEMENTED, /* sve_width  */\n-  4, /* memmov_cost  */\n+  { 4, /* load_int.  */\n+    4, /* store_int.  */\n+    4, /* load_fp.  */\n+    4, /* store_fp.  */\n+    4, /* load_pred.  */\n+    4 /* store_pred.  */\n+  }, /* memmov_cost.  */\n   4, /* issue_rate  */\n   (AARCH64_FUSE_MOV_MOVK | AARCH64_FUSE_ADRP_ADD\n    | AARCH64_FUSE_MOVK_MOVK), /* fuseable_ops  */\n@@ -1650,7 +1728,13 @@ static const struct tune_params saphira_tunings =\n   &generic_branch_cost,\n   &generic_approx_modes,\n   SVE_NOT_IMPLEMENTED, /* sve_width  */\n-  4, /* memmov_cost  */\n+  { 4, /* load_int.  */\n+    4, /* store_int.  */\n+    4, /* load_fp.  */\n+    4, /* store_fp.  */\n+    4, /* load_pred.  */\n+    4 /* store_pred.  */\n+  }, /* memmov_cost.  */\n   4, /* issue_rate  */\n   (AARCH64_FUSE_MOV_MOVK | AARCH64_FUSE_ADRP_ADD\n    | AARCH64_FUSE_MOVK_MOVK), /* fuseable_ops  */\n@@ -1677,7 +1761,13 @@ static const struct tune_params thunderx2t99_tunings =\n   &generic_branch_cost,\n   &generic_approx_modes,\n   SVE_NOT_IMPLEMENTED, /* sve_width  */\n-  4, /* memmov_cost.  */\n+  { 4, /* load_int.  */\n+    4, /* store_int.  */\n+    4, /* load_fp.  */\n+    4, /* store_fp.  */\n+    4, /* load_pred.  */\n+    4 /* store_pred.  */\n+  }, /* memmov_cost.  */\n   4, /* issue_rate.  */\n   (AARCH64_FUSE_ALU_BRANCH | AARCH64_FUSE_AES_AESMC\n    | AARCH64_FUSE_ALU_CBZ), /* fusible_ops  */\n@@ -1704,7 +1794,13 @@ static const struct tune_params thunderx3t110_tunings =\n   &generic_branch_cost,\n   &generic_approx_modes,\n   SVE_NOT_IMPLEMENTED, /* sve_width  */\n-  4, /* memmov_cost.  */\n+  { 4, /* load_int.  */\n+    4, /* store_int.  */\n+    4, /* load_fp.  */\n+    4, /* store_fp.  */\n+    4, /* load_pred.  */\n+    4 /* store_pred.  */\n+  }, /* memmov_cost.  */\n   6, /* issue_rate.  */\n   (AARCH64_FUSE_ALU_BRANCH | AARCH64_FUSE_AES_AESMC\n    | AARCH64_FUSE_ALU_CBZ), /* fusible_ops  */\n@@ -1731,7 +1827,13 @@ static const struct tune_params neoversen1_tunings =\n   &generic_branch_cost,\n   &generic_approx_modes,\n   SVE_NOT_IMPLEMENTED, /* sve_width  */\n-  4, /* memmov_cost  */\n+  { 4, /* load_int.  */\n+    2, /* store_int.  */\n+    5, /* load_fp.  */\n+    2, /* store_fp.  */\n+    4, /* load_pred.  */\n+    4 /* store_pred.  */\n+  }, /* memmov_cost.  */\n   3, /* issue_rate  */\n   (AARCH64_FUSE_AES_AESMC | AARCH64_FUSE_CMP_BRANCH), /* fusible_ops  */\n   \"32:16\",\t/* function_align.  */\n@@ -1757,7 +1859,13 @@ static const struct tune_params ampere1_tunings =\n   &generic_branch_cost,\n   &generic_approx_modes,\n   SVE_NOT_IMPLEMENTED, /* sve_width  */\n-  4, /* memmov_cost  */\n+  { 4, /* load_int.  */\n+    4, /* store_int.  */\n+    4, /* load_fp.  */\n+    4, /* store_fp.  */\n+    4, /* load_pred.  */\n+    4 /* store_pred.  */\n+  }, /* memmov_cost.  */\n   4, /* issue_rate  */\n   (AARCH64_FUSE_ADRP_ADD | AARCH64_FUSE_AES_AESMC |\n    AARCH64_FUSE_MOV_MOVK | AARCH64_FUSE_MOVK_MOVK |\n@@ -1932,7 +2040,13 @@ static const struct tune_params neoversev1_tunings =\n   &generic_branch_cost,\n   &generic_approx_modes,\n   SVE_256, /* sve_width  */\n-  4, /* memmov_cost  */\n+  { 4, /* load_int.  */\n+    1, /* store_int.  */\n+    6, /* load_fp.  */\n+    2, /* store_fp.  */\n+    6, /* load_pred.  */\n+    1 /* store_pred.  */\n+  }, /* memmov_cost.  */\n   3, /* issue_rate  */\n   (AARCH64_FUSE_AES_AESMC | AARCH64_FUSE_CMP_BRANCH), /* fusible_ops  */\n   \"32:16\",\t/* function_align.  */\n@@ -2063,7 +2177,13 @@ static const struct tune_params neoverse512tvb_tunings =\n   &generic_branch_cost,\n   &generic_approx_modes,\n   SVE_128 | SVE_256, /* sve_width  */\n-  4, /* memmov_cost  */\n+  { 4, /* load_int.  */\n+    1, /* store_int.  */\n+    6, /* load_fp.  */\n+    2, /* store_fp.  */\n+    6, /* load_pred.  */\n+    1 /* store_pred.  */\n+  }, /* memmov_cost.  */\n   3, /* issue_rate  */\n   (AARCH64_FUSE_AES_AESMC | AARCH64_FUSE_CMP_BRANCH), /* fusible_ops  */\n   \"32:16\",\t/* function_align.  */\n@@ -2245,7 +2365,13 @@ static const struct tune_params neoversen2_tunings =\n   &generic_branch_cost,\n   &generic_approx_modes,\n   SVE_128, /* sve_width  */\n-  4, /* memmov_cost  */\n+  { 4, /* load_int.  */\n+    1, /* store_int.  */\n+    6, /* load_fp.  */\n+    2, /* store_fp.  */\n+    6, /* load_pred.  */\n+    1 /* store_pred.  */\n+  }, /* memmov_cost.  */\n   3, /* issue_rate  */\n   (AARCH64_FUSE_AES_AESMC | AARCH64_FUSE_CMP_BRANCH), /* fusible_ops  */\n   \"32:16\",\t/* function_align.  */\n@@ -2274,7 +2400,13 @@ static const struct tune_params a64fx_tunings =\n   &generic_branch_cost,\n   &generic_approx_modes,\n   SVE_512, /* sve_width  */\n-  4, /* memmov_cost  */\n+  { 4, /* load_int.  */\n+    4, /* store_int.  */\n+    4, /* load_fp.  */\n+    4, /* store_fp.  */\n+    4, /* load_pred.  */\n+    4 /* store_pred.  */\n+  }, /* memmov_cost.  */\n   7, /* issue_rate  */\n   (AARCH64_FUSE_AES_AESMC | AARCH64_FUSE_CMP_BRANCH), /* fusible_ops  */\n   \"32\",\t/* function_align.  */\n@@ -14659,12 +14791,28 @@ aarch64_register_move_cost (machine_mode mode,\n   return regmove_cost->FP2FP;\n }\n \n+/* Implements TARGET_MEMORY_MOVE_COST.  */\n static int\n-aarch64_memory_move_cost (machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t\t  reg_class_t rclass ATTRIBUTE_UNUSED,\n-\t\t\t  bool in ATTRIBUTE_UNUSED)\n+aarch64_memory_move_cost (machine_mode mode, reg_class_t rclass_i, bool in)\n {\n-  return aarch64_tune_params.memmov_cost;\n+  enum reg_class rclass = (enum reg_class) rclass_i;\n+  if (GET_MODE_CLASS (mode) == MODE_VECTOR_BOOL\n+      ? reg_classes_intersect_p (rclass, PR_REGS)\n+      : reg_class_subset_p (rclass, PR_REGS))\n+    return (in\n+\t    ? aarch64_tune_params.memmov_cost.load_pred\n+\t    : aarch64_tune_params.memmov_cost.store_pred);\n+\n+  if (VECTOR_MODE_P (mode) || FLOAT_MODE_P (mode)\n+      ? reg_classes_intersect_p (rclass, FP_REGS)\n+      : reg_class_subset_p (rclass, FP_REGS))\n+    return (in\n+\t    ? aarch64_tune_params.memmov_cost.load_fp\n+\t    : aarch64_tune_params.memmov_cost.store_fp);\n+\n+  return (in\n+\t  ? aarch64_tune_params.memmov_cost.load_int\n+\t  : aarch64_tune_params.memmov_cost.store_int);\n }\n \n /* Implement TARGET_INIT_BUILTINS.  */"}]}