{"sha": "ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2E5ZTA0OWJjMTQ1YWU5ODViYzBlMmRkNjA3OWRhY2RkNTE3MTdhYw==", "commit": {"author": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2005-11-18T00:59:33Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2005-11-18T00:59:33Z"}, "message": "Imported GNU Classpath gcj-import-20051117.\n\n       * gnu/java/net/protocol/file/Connection.java: Removed, fully merged.\n       * sources.am: Regenerated.\n       * Makefile.in: Likewise.\n\nFrom-SVN: r107153", "tree": {"sha": "4c44aaa3ed1ee1b4f15732664c05cfc9214e1fa9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4c44aaa3ed1ee1b4f15732664c05cfc9214e1fa9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/comments", "author": null, "committer": null, "parents": [{"sha": "fb3a09c214e19c97d3751003d9a2ea8008f5005e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb3a09c214e19c97d3751003d9a2ea8008f5005e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb3a09c214e19c97d3751003d9a2ea8008f5005e"}], "stats": {"total": 8440, "additions": 6717, "deletions": 1723}, "files": [{"sha": "9219f19c734199475ddd36417265d034efa522e1", "filename": "libjava/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -1,3 +1,10 @@\n+2005-11-17  Mark Wielaard  <mark@klomp.org>\n+\n+\tImported GNU Classpath gcj-import-20051117.\n+\t* gnu/java/net/protocol/file/Connection.java: Removed, fully merged.\n+\t* sources.am: Regenerated.\n+\t* Makefile.in: Likewise.\n+\n 2005-11-17  Mark Wielaard  <mark@klomp.org>\n \n \t* gnu/java/net/protocol/file/Handler.java: Removed, fully merged now."}, {"sha": "e1bff42c7cf2c01f1f90fe1dba260a1846da2038", "filename": "libjava/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -1425,7 +1425,7 @@ gnu/java/net/protocol/gcjlib/Handler.java\n \n gnu_java_net_header_files = $(patsubst classpath/%,%,$(patsubst %.java,%.h,$(gnu_java_net_source_files)))\n gnu_java_net_protocol_file_source_files = \\\n-gnu/java/net/protocol/file/Connection.java \\\n+classpath/gnu/java/net/protocol/file/Connection.java \\\n classpath/gnu/java/net/protocol/file/Handler.java\n \n gnu_java_net_protocol_file_header_files = $(patsubst classpath/%,%,$(patsubst %.java,%.h,$(gnu_java_net_protocol_file_source_files)))\n@@ -4224,6 +4224,7 @@ classpath/javax/swing/plaf/metal/MetalInternalFrameTitlePane.java \\\n classpath/javax/swing/plaf/metal/MetalInternalFrameUI.java \\\n classpath/javax/swing/plaf/metal/MetalLabelUI.java \\\n classpath/javax/swing/plaf/metal/MetalLookAndFeel.java \\\n+classpath/javax/swing/plaf/metal/MetalMenuBarUI.java \\\n classpath/javax/swing/plaf/metal/MetalPopupMenuSeparatorUI.java \\\n classpath/javax/swing/plaf/metal/MetalProgressBarUI.java \\\n classpath/javax/swing/plaf/metal/MetalRadioButtonUI.java \\"}, {"sha": "2ef1cb7a679504817ef27895e932cd7b16028029", "filename": "libjava/classpath/AUTHORS", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2FAUTHORS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2FAUTHORS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2FAUTHORS?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -5,6 +5,7 @@ on either list, but should, let us know. Please keep this list in\n alphabetic order.\n \n Lillian Angel (langel@redhat.com)\n+Anthony Balkissoon (abalkiss@redhat.com)\n Stuart Ballard (stuart.a.ballard@gmail.com)\n Mark Benvenuto (mcb54@columbia.edu)\n Geoff Berry (gcb@gnu.org)"}, {"sha": "125388f5d6ff18c98b6b4ee97ec7b2e823c8bec4", "filename": "libjava/classpath/ChangeLog", "status": "modified", "additions": 643, "deletions": 1, "changes": 644, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2FChangeLog?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -1,3 +1,644 @@\n+2005-11-17  Roman Kennke  <kennke@aicas.com>\n+\n+\t* javax/swing/JEditorPane.java\n+\t(PlainEditorKit): New inner class.\n+\t(createDefaultEditorKit): Return an instance of PlainEditorKit.\n+\t* javax/swing/JTextPane.java\n+\t(insertComponent): Implemented previously stubbed method.\n+\t(insertIcon): Implemented previously stubbed method.\n+\n+2005-11-17  Roman Kennke  <kennke@aicas.com>\n+\n+\t* javax/swing/plaf/basic/BasicEditorPaneUI.java\n+\t(create): Removed unneeded method.\n+\t* javax/swing/plaf/basic/BasicTextPaneUI.java\n+\t(create): Removed unneeded method.\n+\n+2005-11-17  Roman Kennke  <kennke@aicas.com>\n+\n+\t* java/awt/Container.java\n+\t(Container): Added comment.\n+\t(remove): Only call removeNotify if removed component is still\n+\tshowing.\n+\t(paintComponents): Call paint() instead of super.paint().\n+\t(AccessibleContainerHandler.AccessibleContainerHandler): Added\n+\tcomment.\n+\t(LightweightDispatcher.acquireComponentForMouseEvent):\n+\tDon't special case MOUSE_RELEASED events. They should be\n+\tdispatched unmodified just as MOUSE_PRESSED.\n+\t(LightweightDispatcher.handleEvent): Also clean up the pressCount\n+\tafter a MOUSE_RELEASE.\n+\n+2005-11-17  Anthony Balkissoon  <abalkiss@redhat.com>\n+\n+\t* javax/swing/text/BoxView.java:\n+\t(modelToView): New API method.\n+\n+2005-11-17  Lillian Angel  <langel@redhat.com>\n+\n+\tFixes PR classpath/PR24721\n+\t* javax/swing/text/BoxView.java\n+\t(getViewAtPoint): Added check in to return the last view, if one exists and\n+\tthe point was not contained in the rectangle. This is what the JDK does.\n+\t* javax/swing/text/CompositeView.java\n+\t(viewToModel): Fixed API documentation. Added check to make sure\n+\tx and y are greater than 0. Otherwise, 0 is returned.\n+\t* javax/swing/text/DefaultCaret.java\n+\t(moveDot): Added check to match API specs.\n+\t(setDot): Likewise.\n+\t* javax/swing/text/GlyphView.java\n+\t(viewToModel): Removed assert. This is not needed here. The point does not\n+\tneed to be in the rectangle.\n+\n+2005-11-17  Roman Kennke  <kennke@aicas.com>\n+\n+\tReported by Roman Schnider <schnider@aicas.com>:\n+\t* java/awt/Component.java\n+\t(reshape): Removed unused statement.\n+\t(repaint()): Don't forward to parent when not showing.\n+\t(repaint(int)): Don't forward to parent when not showing.\n+\t(repaint(int,int,int,int)): Don't forward to parent when not showing.\n+\t(repaint(float,int,int,int,int)): Don't forward to parent when not\n+\tshowing.\n+\n+2005-11-17  Roman Kennke  <kennke@aicas.com>\n+\n+\t* javax/swing/text/AbstractDocument.java\n+\t(LeafElement.getName): If super.getName() returns something\n+\tnon-null, then return that instead of ContentElementName.\n+\t* javax/swing/text/ComponentView.java\n+\t(comp): New field.\n+\t(getAlignment): Implemented previously stubbed method.\n+\t(getComponent): Implemented previously stubbed method.\n+\t(getMaximumSpan): Implemented previously stubbed method.\n+\t(getMinimumSpan): Implemented previously stubbed method.\n+\t(getPreferredSpan): Implemented previously stubbed method.\n+\t(modelToView): Implemented previously stubbed method.\n+\t(paint): Implemented previously stubbed method.\n+\t(setParent): Implemented previously stubbed method.\n+\t(setSize): Removed unneeded method.\n+\t(viewToModel): Implemented previously stubbed method.\n+\t* javax/swing/text/FlowView.java\n+\t(insertUpdate): Forward this event to the logical view.\n+\t* javax/swing/text/IconView.java\n+\t(paint): Implemented previously stubbed method.\n+\t(getPreferredSpan): Implemented previously stubbed method.\n+\t(modelToView): Implemented previously stubbed method.\n+\t(viewToModel): Implemented previously stubbed method.\n+\t* javax/swing/text/ParagraphView.java\n+\t(firstLineIndent): New field.\n+\t(justification): New field.\n+\t(lineSpacing): New field.\n+\t(tabSet): New field.\n+\t(changedUpdate): New method.\n+\t(setPropertiesFromAttributes): New method.\n+\t(setFirstLineIndent): New method.\n+\t(setJustification): New method.\n+\t(setLineSpacing): New method.\n+\t(getLayoutView): New method.\n+\t(getLayoutViewCount): New method.\n+\t(getTabSet): New method.\n+\n+2005-11-17  Anthony Balkissoon  <abalkiss@redhat.com>\n+\n+\t* javax/swing/plaf/basic/BasicEditorPaneUI.java:\n+\t(create): Create new WrappedPlainView instance instead of PlainView.\n+\n+2005-11-17  Audrius Meskauskas  <AudriusA@Bioinformatics.org>\n+        \n+\tPR 24911\n+\t* classpath/examples/Makefile.am\n+\t(EXAMPLE_JAVA_FILES): Extended by /*/*/*.java and /*/*/*/*.java.\n+\t(READMES): New category.\n+\t(ALL_EXAMPLE_FILES): Extended by READMES category. \n+\n+2004-11-17  Bryce McKinlay  <mckinlay@redhat.com>\n+\n+\t* gnu/java/net/protocol/jar/Connection.java (getHeaderField):\n+\tImplemented.\n+\t(getLastModified): Implemented.\n+\n+2005-11-17  Mark Wielaard  <mark@klomp.org>\n+\n+\t* java/net/URLClassLoader.java: Reindented.\n+\n+2005-11-17  Roman Kennke  <kennke@aicas.com>\n+\n+\t* javax/swing/JApplet.java\n+\t(paramString): Returns super.paramString() instead of a meaningless\n+\t'JFrame'.\n+\t* javax/swing/JPanel.java\n+\t(paramString): Returns super.paramString() instead of a meaningless\n+\t'JPanel'.\n+\n+2005-11-17  Roman Kennke  <kennke@aicas.com>\n+\n+\t* javax/swing/plaf/basic/BasicButtonUI.java\n+\t(installDefaults): Don't handle the Button.rollover property here,\n+\tthis is Metal specific and is handled in MetalButtonUI.\n+\n+2005-11-17  Roman Kennke  <kennke@aicas.com>\n+\n+\t* javax/swing/JList.java\n+\t(locationToIndex): Clarified API comment.\n+\n+2005-11-17  Roman Kennke  <kennke@aicas.com>\n+\n+\t* javax/swing/tree/DefaultTreeCellEditor.java\n+\t(DefaultTreeCellEditor): Replaced\n+\tUIManager.getLookAndFeelDefaults().getXXX() with UIManager.getXXX().\n+\t(createTreeCellEditor): Replaced\n+\tUIManager.getLookAndFeelDefaults().getXXX() with UIManager.getXXX().\n+\t* javax/swing/tree/DefaultTreeCellRenderer.java\n+\t(DefaultTreeCellRenderer): Replaced\n+\tUIManager.getLookAndFeelDefaults().getXXX() with UIManager.getXXX().\n+\t(getDefaultOpenIcon): Replaced\n+\tUIManager.getLookAndFeelDefaults().getXXX() with UIManager.getXXX().\n+\t(getDefaultClosedIcon): Replaced\n+\tUIManager.getLookAndFeelDefaults().getXXX() with UIManager.getXXX().\n+\t(getDefaultLeafIcon): Replaced\n+\tUIManager.getLookAndFeelDefaults().getXXX() with UIManager.getXXX().\n+\t(getTreeCellRendererComponent): Replaced\n+\tUIManager.getLookAndFeelDefaults().getXXX() with UIManager.getXXX().w\n+\t(paint): Replaced UIManager.getLookAndFeelDefaults().getXXX()\n+\twith UIManager.getXXX().\n+\n+2005-11-17  Andrew Haley  <aph@redhat.com>\n+\n+\t* gnu/java/net/protocol/file/Connection.java (unquote): New\n+\tmethod.\n+\t(connect): Unquote filename.\n+\t* gnu/java/net/protocol/jar/Connection.java (get): Likewise.\n+\n+\t* java/net/URL.java (URL): If the file part of a spec is absolute,\n+\tignore the file part of its context.\n+\n+2005-11-17  Audrius Meskauskas  <AudriusA@Bioinformatics.org>\n+\n+\t* examples/gnu/classpath/examples/CORBA/swing/README.html:\n+\tAdded note about the build.\n+\t\n+2005-11-16  Anthony Balkissoon  <abalkiss@redhat.com>\n+\n+\t* javax/swing/JSplitPane.java: Reformatted file.\n+\t* javax/swing/plaf/basic/BasicSplitPaneUI.java: Reformatted file.\n+\n+2005-11-16  Lillian Angel  <langel@redhat.com>\n+\n+\t* javax/swing/ToolTipManager.java\n+\t(mouseEntered): No need to start the insideTimer here,\n+\talready called showTip.\n+\n+2005-11-16  Lillian Angel  <langel@redhat.com>\n+\n+\tFixes PR classpath/PR24763\n+\t* javax/swing/ToolTipManager.java\n+\t(mouseEntered): showTip should be called if exitTimer is running.\n+\tThis means that the mouse has exited and re-entered a component\n+\tin less than 500ms.\n+\t(mouseExited): If enterTimer is not running, the exitTimer should\n+\tbe started no matter what.\n+\t(showTip): Should not show tool tip if the currentComponent is\n+\tnot showing.\n+\n+2005-11-16  Lillian Angel  <langel@redhat.com>\n+\t\n+\tFixes PR classpath/PR23557 and PR classpath/PR24099\n+\t* native/jni/gtk-peer/gnu_java_awt_peer_gtk_GdkGraphics2D.c\n+\t(Java_gnu_java_awt_peer_gtk_GdkGraphics2D_gdkDrawDrawable):\n+\tAdded check to determine if dst->drawable or src->drawable\n+\tare actually drawable. If not, return.\n+\n+2005-11-16  Roman Kennke  <kennke@aicas.com>\n+\n+\t* javax/swing/plaf/metal/MetalBorders.java\n+\t(ButtonBorder.paintBorder): Special case the OceanTheme.\n+\t(ButtonBorder.paintOceanThemeBorder): New method.\n+\t* javax/swing/plaf/metal/MetalButtonUI.java\n+\t(installDefaults): Set the rollover flag here. Don't set a special\n+\tborder for rollover buttons.\n+\t(uninstallDefaults): Reset the rollover flag.\n+\t(update): Only paint gradient when button is enabled and not pressed.\n+\t* javax/swing/plaf/metal/MetalButtonUI.java\n+\t(getCurrentTheme): New method.\n+\n+2005-11-16  Gary Benson  <gbenson@redhat.com>\n+\n+\t* java/io/FilePermission.java (implies): Correct the sense\n+\tin which action checks are applied.\n+\n+2005-11-16  Anthony Balkissoon  <abalkiss@redhat.com>\n+\n+\t* AUTHORS: Added myself.\n+\t* javax/swing/KeyboardManager.java: Changed @author tag to match the \n+\tother ones I have.\n+\t* javax/swing/text/WrappedPlainView.java: Likewise.\n+\n+2005-11-16  Gary Benson  <gbenson@redhat.com>\n+ \n+\t* java/security/ProtectionDomain.java (toString): Use\n+\tgnu.classpath.SystemProperties to read line.separator\n+\twithout security manager check.\n+\n+2005-11-16  Lillian Angel  <langel@redhat.com>\n+\n+\t* java/awt/image/MemoryImageSource.java\n+\t(startProduction): If animated, imageComplete should\n+\tbe called with the SINGLEFRAMEDONE flag, meaning the\n+\tsingle frame is complete, but there are more frames \n+\tto follow.\n+\n+2005-11-16  Anthony Balkissoon  <abalkiss@redhat.com>\n+\n+\t* javax/swing/text/PlainDocument.java:\n+\t(insertString): Null check fixes PR 24890.\n+\n+2005-11-16  Lillian Angel  <langel@redhat.com>\n+\n+\t* javax/swing/plaf/basic/BasicTreeUI.java\n+\t(paintVerticalPartOfLeg): Added a check to prevent\n+\tArrayOutOfBoundsException.\n+\n+2005-11-16  Roman Kennke  <kennke@aicas.com>\n+\n+\t* javax/swing/plaf/basic/BasicInternalFrameTitlePane.java\n+\t(paintTitleBackground): Only paint background if component is\n+\topaque.\n+\t* javax/swing/plaf/metal/MetalInternalFrameTitlePane.java\n+\t(paintPalette): Added gradient painting.\n+\t(paintComponent): Added gradient painting.\n+\t* javax/swing/plaf/metal/OceanTheme.java\n+\t(addCustomEntriesToTable): Added gradient for\n+\tInternalFrama.activeTitleGradient.\n+\n+2005-11-16  Lillian Angel  <langel@redhat.com>\n+\n+\t* javax/swing/ToolTipManager.java:\n+\tRemoved unneeded fields.\n+\t(showTip): Re-implemented to use PopupFactory.\n+\t(hideTip): Likewise.\n+\t(adjustLocation): Fixed location.\n+\n+2005-11-16  Anthony Balkissoon  <abalkiss@redhat.com>\n+\n+\t* javax/swing/text/PlainDocument.java:\n+\t(insertUpdate): The very first new element added doesn't start at the \n+\tstart of the event, it starts at the start offset of the Element that\n+\tcontains the start of the event.\n+\n+2005-11-16  Roman Kennke  <kennke@aicas.com>\n+\n+\t* javax/swing/plaf/basic/BasicMenuItemUI.java\n+\t(paintMenuItem): Always call paintBackground().\n+\n+2005-11-16  Lillian Angel  <langel@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GtkDialogPeer.java\n+\t(create): Since popups were changed to be JWindowPopups,\n+\tthis code should be done in GtkWindowPeer. Code is not\n+\tneeded.\n+\t* gnu/java/awt/peer/gtk/GtkWindowPeer.java\n+\t(create): If window is not focusable, it should not take\n+\tthe focus away from any other window. Therefore, its\n+\ttype should be set to GDK_WINDOW_TYPE_HINT_MENU.\n+\n+2005-11-16  Roman Kennke  <kennke@aicas.com>\n+\n+\t* javax/swing/plaf/metal/MetalButtonUI.java\n+\t(update): New method. Paints the gradient.\n+\t* javax/swing/plaf/metal/MetalCheckBoxIcon.java\n+\t(paintIcon): Paint gradient.\n+\t* javax/swing/plaf/metal/MetalIconFactory.java\n+\t(RadioButtonIcon.paintIcon): Paint gradient.\n+\t* javax/swing/plaf/metal/MetalLookAndFeel.java\n+\t(initClassDefaults): Added MetalMenuBarUI.\n+\t* javax/swing/plaf/metal/MetalMenuBarUI.java: New file.\n+\t* javax/swing/plaf/metal/MetalToggleButtonUI.java\n+\t(update): New method. Paints the gradient.\n+\t* javax/swing/plaf/metal/OceanTheme.java\n+\t(addCustomEntriesToTable): Added all the gradients.\n+\n+2005-11-16  Roman Kennke  <kennke@aicas.com>\n+\n+\t* javax/swing/JMenu.java\n+\t(JMenu()): Set opaque flag to false.\n+\t(JMenu(String)): Likewise.\n+\t(JMenu(Action)): Likewise.\n+\n+2005-11-16  Roman Kennke  <kennke@aicas.com>\n+\n+\t* javax/swing/plaf/basic/BasicListUI.java\n+\t(getRowHeight): Adjusted to deal correctly with fixed cell heights.\n+\t(convertYRoRow): Likewise.\n+\t* javax/swing/plaf/basic/BasicMenuItemUI.java\n+\t(installDefaults): Don't make the menu item opaque here.\n+\t(paintBackground): Moved background painting code from\n+\tpaintMenuItem() to this method.\n+\t(paintMenuItem): Moved background painting to paintBackground().\n+\t(installDefaults): Don't set opaque flag here.\n+\n+2005-11-16  Roman Kennke  <kennke@aicas.com>\n+\n+\t* javax/swing/plaf/metal/MetalUtils.java\n+\t(paintGradient): New utility method(s).\n+\t(paintHorizontalGradient): New utility method.\n+\t(paintVerticalGradient): New utility method.\n+\n+2005-11-15  Roman Kennke  <kennke@aicas.com>\n+\n+\t* javax/swing/JComponent.java\n+\t(paintDoubleBuffered): Put paint() call inside a try-finally\n+\tblock to correctly recover the double-buffering flag when\n+\tan exception is thrown inside the paint() call.\n+\n+2005-11-15  Lillian Angel  <langel@redhat.com>\n+\n+\t* native/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkWindowPeer.c\n+\t(Java_gnu_java_awt_peer_gtk_GtkWindowPeer_gtkWindowSetResizable):\n+\tNeeded to set allow_shrink to the same value as resizable. Other-\n+\twise, it is always set to false.\n+\n+2005-11-15  Lillian Angel  <langel@redhat.com>\n+\n+\t* javax/swing/plaf/basic/BasicTreeUI.java\n+\t(paint): Added check to prevent NPE.\n+\n+2005-11-15  Anthony Balkissoon  <abalkiss@redhat.com>\n+\n+\t* javax/swing/JComponent.java:\n+\t(removeNotify): Unregister WHEN_IN_FOCUSED_WINDOW bindings from the \n+\tKeyboardManager.\n+\n+2005-11-15  Lillian Angel  <langel@redhat.com>\n+\n+\t* javax/swing/plaf/basic/BasicLookAndFeel.java\n+\t(initComponentDefaults): Default rowHeight for tree's should\n+\tbe 0. This is Sun and IBM's default.\n+\t* javax/swing/plaf/metal/MetalLookAndFeel.java\n+\t(initComponentDefaults): Default rowHeight for tree's should\n+\te 0. This is Sun and IBM's default.\n+\t* javax/swing/plaf/basic/BasicTreeUI.java:\n+\tAdded a default rowHeight field.\n+\t(setRowHeight): Set the rowHeight to the class default if parameter\n+\tis 0. Tree row height should never be set to 0. 20 is the minimum.\n+\t(installDefaults): fixed call to tree.setRowHeight\n+\t(shouldPaintExpandControl): Added to check to prevent NPE.\n+\n+2005-11-15  Audrius Meskauskas  <AudriusA@Bioinformatics.org>\n+\n+\t* examples/gnu/classpath/examples/CORBA/swing/README.html,\n+\texamples/gnu/classpath/examples/CORBA/swing/x5/CanvasWorld.java,\n+\texamples/gnu/classpath/examples/CORBA/swing/x5/ChatConstants.java,\n+\texamples/gnu/classpath/examples/CORBA/swing/x5/ClientFrame.java,\n+\texamples/gnu/classpath/examples/CORBA/swing/x5/Demo.java,\n+\texamples/gnu/classpath/examples/CORBA/swing/x5/GameManager.java,\n+\texamples/gnu/classpath/examples/CORBA/swing/x5/GameManagerImpl.java,\n+\texamples/gnu/classpath/examples/CORBA/swing/x5/IorReader.java,\n+\texamples/gnu/classpath/examples/CORBA/swing/x5/OrbStarter.java,\n+\texamples/gnu/classpath/examples/CORBA/swing/x5/Player.java,\n+\texamples/gnu/classpath/examples/CORBA/swing/x5/PlayerImpl.java,\n+\texamples/gnu/classpath/examples/CORBA/swing/x5/PlayingDesk.java,\n+\texamples/gnu/classpath/examples/CORBA/swing/x5/State.java,\n+\texamples/gnu/classpath/examples/CORBA/swing/x5/X5Server.java,\n+\texamples/gnu/classpath/examples/CORBA/swing/x5/_GameManagerImpl_Tie.java,\n+\texamples/gnu/classpath/examples/CORBA/swing/x5/_GameManager_Stub.java,\n+\texamples/gnu/classpath/examples/CORBA/swing/x5/_PlayerImpl_Tie.java,\n+\texamples/gnu/classpath/examples/CORBA/swing/x5/_Player_Stub.java: \n+\tNew files.\n+\n+2005-11-15  Roman Kennke  <kennke@aicas.com>\n+\n+\t* javax/swing/UIManager.java\n+\t(userUIDefaults): New field.\n+\t(get(Object)): Respect the user UI settings.\n+\t(get(Object,Locale)): Respect the user UI settings.\n+\t(getBoolean(Object)): Call get() instead of\n+\tgetLookAndFeelDefaults().get() in order to respect the user UI\n+\tsettings.\n+\t(getBoolean(Object,Locale)): Call get() instead of\n+\tgetLookAndFeelDefaults().get() in order to respect the user UI\n+\tsettings.\n+\t(getBorder(Object)): Call get() instead of\n+\tgetLookAndFeelDefaults().get() in order to respect the user UI\n+\tsettings.\n+\t(getBorder(Object,Locale)): Call get() instead of\n+\tgetLookAndFeelDefaults().get() in order to respect the user UI\n+\tsettings.\n+\t(getColor(Object)): Call get() instead of\n+\tgetLookAndFeelDefaults().get() in order to respect the user UI\n+\tsettings.\n+\t(getColor(Object,Locale)): Call get() instead of\n+\tgetLookAndFeelDefaults().get() in order to respect the user UI\n+\tsettings.\n+\t(getDimension(Object)): Call get() instead of\n+\tgetLookAndFeelDefaults().get() in order to respect the user UI\n+\tsettings.\n+\t(getDimension(Object,Locale)): Call get() instead of\n+\tgetLookAndFeelDefaults().get() in order to respect the user UI\n+\tsettings.\n+\t(getFont(Object)): Call get() instead of\n+\tgetLookAndFeelDefaults().get() in order to respect the user UI\n+\tsettings.\n+\t(getFont(Object,Locale)): Call get() instead of\n+\tgetLookAndFeelDefaults().get() in order to respect the user UI\n+\tsettings.\n+\t(getIcon(Object)): Call get() instead of\n+\tgetLookAndFeelDefaults().get() in order to respect the user UI\n+\tsettings.\n+\t(getIcon(Object,Locale)): Call get() instead of\n+\tgetLookAndFeelDefaults().get() in order to respect the user UI\n+\tsettings.\n+\t(getInsets(Object)): Call get() instead of\n+\tgetLookAndFeelDefaults().getInsets() in order to respect the user UI\n+\tsettings.\n+\t(getInsets(Object,Locale)): Call get() instead of\n+\tgetLookAndFeelDefaults().getInsets() in order to respect the user UI\n+\tsettings.\n+\t(getInt(Object)): Call get() instead of\n+\tgetLookAndFeelDefaults().get() in order to respect the user UI\n+\tsettings.\n+\t(getInt(Object,Locale)): Call get() instead of\n+\tgetLookAndFeelDefaults().get() in order to respect the user UI\n+\tsettings.\n+\t(getString(Object)): Call get() instead of\n+\tgetLookAndFeelDefaults().get() in order to respect the user UI\n+\tsettings.\n+\t(getString(Object,Locale)): Call get() instead of\n+\tgetLookAndFeelDefaults().get() in order to respect the user UI\n+\tsettings.\n+\t(getUI(JComponent)): Respect the user UI settings.\n+\t(put): Put key/value into user UI settings.\n+\n+2005-11-15  Roman Kennke  <kennke@aicas.com>\n+\n+\t* javax/swing/plaf/metal/MetalBorders.java\n+\t(OptionDialogBorder.paintBorder): Replaced\n+\tUIManager.getLookAndFeelDefaults().get() with UIManager.get().\n+\t* javax/swing/plaf/metal/MetalButtonUI.java\n+\t(MetalButtonUI): Replaced UIManager.getLookAndFeelDefaults().get()\n+\twith UIManager.get().\n+\t* javax/swing/plaf/metal/MetalInternalFrameTitlePane.java\n+\t(installDefaults): Replaced UIManager.getLookAndFeelDefaults().get()\n+\twith UIManager.get().\n+\t* javax/swing/plaf/metal/MetalLabelUI.java\n+\t(paintDisabledText): Replaced UIManager.getLookAndFeelDefaults().get()\n+\twith UIManager.get().\n+\t* javax/swing/plaf/metal/MetalRadioButtonUI.java\n+\t(installDefaults): Replaced UIManager.getLookAndFeelDefaults().get()\n+\twith UIManager.get().\n+\t* javax/swing/plaf/metal/MetalScrollBarUI.java\n+\t(createDecreaseButton): Replaced\n+\tUIManager.getLookAndFeelDefaults().get() with UIManager.get().\n+\t(createIncreaseButton): Replaced\n+\tUIManager.getLookAndFeelDefaults().get() with UIManager.get().\n+\t(paintThumbHorizontal): Replaced\n+\tUIManager.getLookAndFeelDefaults().get() with UIManager.get().\n+\t(paintThumbVertical): Replaced\n+\tUIManager.getLookAndFeelDefaults().get() with UIManager.get().\n+\t* javax/swing/plaf/metal/MetalSplitPaneUI.java\n+\t(createDefaultDivider): Replaced\n+\tUIManager.getLookAndFeelDefaults().get() with UIManager.get().\n+\t* javax/swing/plaf/metal/MetalToggleButtonUI.java\n+\t(installDefaults): Replaced UIManager.getLookAndFeelDefaults().get()\n+\twith UIManager.get().\n+\t* javax/swing/plaf/metal/MetalToolTipUI.java\n+\t(MetalToolTipUI): Replaced UIManager.getLookAndFeelDefaults().get()\n+\twith UIManager.get().\n+\t* javax/swing/plaf/metal/MetalTreeUI.java\n+\tRemoved all listener fields.\n+\t(installUI): Removed initialization and call super.installUI()\n+\tinstead.\n+\t(uninstallUI): Removed initialization and call super.uninstallUI()\n+\tinstead.\n+\n+2005-11-15  Audrius Meskauskas  <AudriusA@Bioinformatics.org>\n+\n+\t* gnu/CORBA/OrbFunctional.java (serveStep):\n+\tReturning ensure that the socket is closed.\n+\n+2005-11-15  Roman Kennke  <kennke@aicas.com>\n+\n+\t* javax/swing/plaf/basic/BasicBorders.java\n+\t(getButtonBorder): Replaced UIManager.getLookAndFeelDefaults().get()\n+\twith UIManager.get().\n+\t(getRadioButtonBorder): Replaced\n+\tUIManager.getLookAndFeelDefaults().get() with UIManager.get().\n+\t(getToggleButtonBorder): Replaced\n+\tUIManager.getLookAndFeelDefaults().get() with UIManager.get().\n+\t(getMenuBarBorder): Replaced\n+\tUIManager.getLookAndFeelDefaults().get() with UIManager.get().\n+\t(getSplitPaneBorder): Replaced\n+\tUIManager.getLookAndFeelDefaults().get() with UIManager.get().\n+\t(getSplitPaneDividerBorder): Replaced\n+\tUIManager.getLookAndFeelDefaults().get() with UIManager.get().\n+\t(getTextFieldBorder): Replaced\n+\tUIManager.getLookAndFeelDefaults().get() with UIManager.get().\n+\t(getInternalFrameBorder): Replaced\n+\tUIManager.getLookAndFeelDefaults().get() with UIManager.get().\n+\t* javax/swing/plaf/basic/BasicButtonUI.java\n+\t(paintText): Replaced UIManager.getLookAndFeelDefaults().get()\n+\twith UIManager.get().\n+\t* javax/swing/plaf/basic/BasicCheckBoxUI.java\n+\t(getDefaultIcon): Replaced UIManager.getLookAndFeelDefaults().get()\n+\twith UIManager.get().\n+\t* javax/swing/plaf/basic/BasicComboBoxUI.java\n+\t(paintCurrentValue): Replaced UIManager.getLookAndFeelDefaults().get()\n+\twith UIManager.get().\n+\t* javax/swing/plaf/basic/BasicFileChooserUI.java\n+\t(installStrings): Replaced UIManager.getLookAndFeelDefaults().get()\n+\twith UIManager.get().\n+\t* javax/swing/plaf/basic/BasicInternalFrameTitlePane.java\n+\t(installDefaults): Replaced UIManager.getLookAndFeelDefaults().get()\n+\twith UIManager.get().\n+\t* javax/swing/plaf/basic/BasicListUI.java\n+\t(installKeyboardActions): Replaced\n+\tUIManager.getLookAndFeelDefaults().get() with UIManager.get().\n+\t* javax/swing/plaf/basic/BasicProgressBarUI.java\n+\t(boxRect): Added @since tag to the API comment.\n+\t* javax/swing/plaf/basic/BasicRadioButtonUI.java\n+\t(getDefaultIcon): Replaced UIManager.getLookAndFeelDefaults().get()\n+\twith UIManager.get().\n+\t* javax/swing/plaf/basic/BasicScrollBarUI.java\n+\t(configureScrollBarColors): Replaced\n+\tUIManager.getLookAndFeelDefaults().get() with UIManager.get().\n+\t(calculatePreferredSize): Fetch preferred width or height from\n+\tUI defaults.\n+\t* javax/swing/plaf/basic/BasicTableUI.java\n+\t(installKeyboardActions): Replaced\n+\tUIManager.getLookAndFeelDefaults().get() with UIManager.get().\n+\t* javax/swing/plaf/basic/BasicTextUI.java\n+\t(createKeymap): Replaced\n+\tUIManager.getLookAndFeelDefaults().get() with UIManager.get().\n+\t(getInputMap): Replaced\n+\tUIManager.getLookAndFeelDefaults().get() with UIManager.get().\n+\t(getActionMap): Replaced\n+\tUIManager.getLookAndFeelDefaults().get() with UIManager.get().\n+\t* javax/swing/plaf/basic/BasicToolBarUI.java\n+\t(dragTo): Don't use cached* fields.\n+\t(installComponents): Don't use cached* fields.\n+\t* javax/swing/plaf/basic/BasicTreeUI.java\n+\t(getHashColor): Replaced\n+\tUIManager.getLookAndFeelDefaults().get() with UIManager.get().\n+\t(setHashColor): Replaced\n+\tUIManager.getLookAndFeelDefaults().get() with UIManager.get().\n+\tAdded FIXME comment.\n+\t(installKeyboardActions): Replaced\n+\tUIManager.getLookAndFeelDefaults().get() with UIManager.get().\n+\n+2005-11-15  Christian Thalinger  <twisti@complang.tuwien.ac.at>\n+\n+\t* native/jni/java-lang/java_lang_VMDouble.c (initIDs): Register \n+\tclsDouble as global ref.\n+\t* native/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkToolkit.c \n+\t(gtkInit): Register gtkgenericpeer as global ref.\n+\n+2005-11-15  Lillian Angel  <langel@redhat.com>\n+\n+\t* javax/swing/plaf/basic/BasicTreeUI.java:\n+\tRemoved unneeded field.\n+\t(getPathBounds): Reimplemented to use getNodeDimensions.\n+\t(getRowCount): Removed call to updateCurrentVisiblePath.\n+\t(uninstallKeyboardActions): Implemented.\n+\t(paint): Reimplemented to only paint rows contained in clip.\n+\tNo longer uses recursion.\n+\t(mousePressed): If control icon is clicked, should scroll to that\n+\tpath.\n+\t(getNodeDimensions): Implemented.\n+\t(getRowX): Implemented.\n+\t(getCellBounds): Removed.\n+\t(getCellLocation): Removed.\n+\t(paintRecursive): Removed.\n+\t(paintControlIcons): Removed.\n+\t(getPreviousVisibleNode): Removed call to updateCurrentVisiblePath.\n+\t(getLevel): Added check for invisible root.\n+\t(paintVerticalLine): Set graphics color.\n+\t(paintHorizontalLine): Likewise.\n+\t(drawCentered): Added negative check.\n+\t(drawDashedHorizontalLine): Set graphics color.\n+\t(drawDashedVerticalLine): Likewise.\n+\t(paintExpandControl): Implemented.\n+\t(paintHorizontalPartOfLeg): Likewise.\n+\t(paintVerticalPartOfLeg): Likewise.\n+\t(paintRow): Added call to paint the control icons.\n+\t(updateCurrentVisiblePath): Cleaned up function.\t\n+\n+2005-11-15  Anthony Balkissoon  <abalkiss@redhat.com>\n+\n+\t* javax/swing/text/AbstractDocument.java:\n+\t(remove): Do not set up an ElementEdit here, this is done in the \n+\tDocument implementation's removeUpdate method.\n+\t* javax/swing/text/PlainDocument.java:\n+\t(insertUpdate): Do not call reindex, instead, reindex the lines here\n+\tdirectly but only starting from the offset of the newly inserted text.\n+\tAlso, if entire lines have been added or removed, set up an ElementEdit\n+\tand add it to the DocumentEvent.  Chain BadLocationException to an \n+\tAssertionError and throw it in the unexpected case.\n+\t(removeUpdate): If entire lines have been added or removed, set up an \n+\tElementEdit and add it to the DocumentEvent.  Chain \n+\tBadLocationException to an AssertionError and throw it in the \n+\tunexpected case.\n+\t(reindex): Removed unnecessary method.\n+\n 2005-11-15  Wolfgang Baer  <WBaer@gmx.de>\n \n \t* javax/print/attribute/DateTimeSyntax.java,\n@@ -8,7 +649,8 @@\n \n 2005-11-15  Lillian Angel  <langel@redhat.com>\n \n-\t* gnu/java/awt/peer/gtk/GtkComponentPeer.java\n+\t* gnu/java/awt/peer/gtk/GtkComponentPeer.java:\n+\tCode written by Sven de Marothy.\n \t(gtkWindowGetLocationOnScreen): Added declaration\n \tfor native function.\n \t(getLocationOnScreen): Changed to handle 2 different cases."}, {"sha": "341fc5e8e23eccffa9e9a7755fe3bb45fe92cb1c", "filename": "libjava/classpath/examples/Makefile.am", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fexamples%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fexamples%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2FMakefile.am?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -20,7 +20,7 @@ endif\n endif\n \n # All our example java source files\n-EXAMPLE_JAVA_FILES = $(srcdir)/gnu/classpath/examples/*/*.java\n+EXAMPLE_JAVA_FILES = $(srcdir)/gnu/classpath/examples/*/*.java $(srcdir)/gnu/classpath/examples/*/*/*.java $(srcdir)/gnu/classpath/examples/*/*/*/*.java\n \n # The example C source files\n EXAMPLE_C_FILES = $(srcdir)/gnu/classpath/examples/*/*.c\n@@ -34,8 +34,11 @@ BUILT_SOURCES = $(EXAMPLE_ZIP)\n # the png icons we use in some of the examples.\n EXAMPLE_ICONS = $(srcdir)/gnu/classpath/examples/icons/*.png\n \n+# The example specific README files.\n+READMES = $(srcdir)/gnu/classpath/examples/CORBA/swing/README.html\n+\n # All the files we find \"interesting\"\n-ALL_EXAMPLE_FILES = $(EXAMPLE_JAVA_FILES) $(EXAMPLE_C_FILES) $(EXAMPLE_ICONS)\n+ALL_EXAMPLE_FILES = $(EXAMPLE_JAVA_FILES) $(EXAMPLE_C_FILES) $(EXAMPLE_ICONS) $(READMES)\n \n # Some architecture independent data to be installed.\n example_DATA = $(EXAMPLE_ZIP) README"}, {"sha": "5ba479cf5e220d93ea3c44a603c56b7079abf424", "filename": "libjava/classpath/examples/Makefile.in", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fexamples%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fexamples%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2FMakefile.in?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -263,7 +263,7 @@ vm_classes = @vm_classes@\n @FOUND_GCJ_TRUE@JCOMPILER = $(GCJ) --bootclasspath '$(top_builddir)/lib' --classpath . -C\n \n # All our example java source files\n-EXAMPLE_JAVA_FILES = $(srcdir)/gnu/classpath/examples/*/*.java\n+EXAMPLE_JAVA_FILES = $(srcdir)/gnu/classpath/examples/*/*.java $(srcdir)/gnu/classpath/examples/*/*/*.java $(srcdir)/gnu/classpath/examples/*/*/*/*.java\n \n # The example C source files\n EXAMPLE_C_FILES = $(srcdir)/gnu/classpath/examples/*/*.c\n@@ -277,8 +277,11 @@ BUILT_SOURCES = $(EXAMPLE_ZIP)\n # the png icons we use in some of the examples.\n EXAMPLE_ICONS = $(srcdir)/gnu/classpath/examples/icons/*.png\n \n+# The example specific README files.\n+READMES = $(srcdir)/gnu/classpath/examples/CORBA/swing/README.html\n+\n # All the files we find \"interesting\"\n-ALL_EXAMPLE_FILES = $(EXAMPLE_JAVA_FILES) $(EXAMPLE_C_FILES) $(EXAMPLE_ICONS)\n+ALL_EXAMPLE_FILES = $(EXAMPLE_JAVA_FILES) $(EXAMPLE_C_FILES) $(EXAMPLE_ICONS) $(READMES)\n \n # Some architecture independent data to be installed.\n example_DATA = $(EXAMPLE_ZIP) README"}, {"sha": "a3a9e62823eba968027478a8403f6d673a9d8b86", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/swing/README.html", "status": "added", "additions": 493, "deletions": 0, "changes": 493, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2FREADME.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2FREADME.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2FREADME.html?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -0,0 +1,493 @@\n+<html>\n+  <head>\n+    <title>Five-in-a-row v 0.0</title>\n+  </head>\n+  <body LANG=\"en-US\">\n+    <h1>\n+      <i>Five-in-a-row\n+      </i> 0.0 supplementary documentation\n+    </h1>\n+    <h3>Introduction and rules\n+    </h3>\n+    <p>\n+      <i>Five-in-a-row\n+      </i> is a two player strategy game. The players\n+      are connected via network using CORBA-based RMI/IIOP protocol and\n+      make they moves with the help of the Swing-based\n+      interface. While playing, the users can also chat.\n+    </p>\n+    <p>The system consists of the single server and any number of\n+      interconnected players. The person, willing to play, starts the\n+      client and connects the server. The server redirects call to the\n+      partner that has previously connected the same server, also willing\n+      to play.\n+    </p>\n+    <p>The game desk is a field where it is possible to set O's\n+      and X'es, one per move. The goal is to get five O's in a row while\n+      preventing your partner from getting five X's in a row. Vertical,\n+      horizontal and diagonal rows are allowed. The system detects the\n+      loss-victory situation on the desk, but currently does not serve as a\n+      playing partner, requiring at least two human players for this game.\n+    </p>\n+    <p>Both players can at any time reset the game (restarting it with\n+      the same player) or leave the game (disconnecting). The disconnected\n+      player can contact the game manager again, requesting to find another\n+      partner.\n+    </p>\n+    <p>Simple as it is, the application has some features of the typical\n+      role playing game that frequently just has more states, actions,\n+      possible moves and also provides far richer graphics environment. The\n+      game manger serves as a World-Wide-Pub where you can always find a\n+      partner to play.\n+\n+      The players can made both unsynchronized (chatting, game reset and\n+      leaving) and synchronized (moves) actions. The game state changes\n+      while playing, and the set of the available actions depends on the\n+      current state. Finally, the mouse and canvas are involved. However\n+      using RMI/IIOP machinery allowed to implement all this functionality\n+      with just 13 classes (plus 4 generated), all of them being rather\n+      simple.\n+      \n+      This example refers to the standard classes only and must be buildable\n+      from your IDE as long as it has any java 1.4 compiler.       \n+    </p>\n+    <p>\n+      The used IIOP protocol must ensure interoperability, allowing players\n+      to use different java virtual machines and operating systems.\n+      The processors may have the opposite byte order.\n+    </p>\n+    <h3>Configuration and run\n+    </h3>\n+    <p>The game manager server executable class is\n+      <i>gnu.classpath.examples.CORBA.swing.x5.X5Server\n+      </i>. After start,\n+      it will print to console the Internet address that must be entered to\n+      the client to reach the manager.\n+    </p>\n+    <p>The client executable class it\n+      <i>gnu.classpath.examples.CORBA.swing.x5.Demo\n+      </i>.\n+    </p>\n+    <p>The game should run with GNU Classpath\n+      0.19 and Sun Microsystems java 1.5.0_04. Due later fixed bugs it will\n+      not run with the older versions of these two implementations.\n+    </p>\n+    <p>The game manager HTTP server uses port\n+      1500. Hence all firewalls between the server and the player must be\n+      configured to allow HTTP on 1500. The ports, used by the RMI/IIOP are\n+      not persistent. GNU Classpath is configured to take ports 1501, 1502\n+      and 1503 (the firewalls must allow to use them for RMI/IIOP). The\n+      CORBA implementation other than Classpath may use different port\n+      values. Unfortunately, there is no standard method to configure the\n+      used port range in a vendor-independent way.\n+    </p>\n+    <h3>The game server\n+    </h3>\n+    <p>The game manager is first reachable via http:// protocol (for\n+      instance http://123.456.7.89:1500). The simple server at this port\n+      always serves much longer string, representing the CORBA stringified\n+      object reference (IOR). The\n+      <i>Five-in-a-row&nbsp;\n+      </i>client uses\n+      this reference to find and access the remote game server object.\n+    </p>\n+    <p>If the server player queue is empty, it simply queues this player.\n+      If the queue is not empty, the server introduces the arrived player\n+      and queued player to each other as leaves the them alone. When\n+      playing, the two clients communicate with each other directly, so the\n+      server is just a &ldquo;meeting point&rdquo; where the players can\n+      find each other. The game server is a console-only application.\n+    </p>\n+    <p>The initial server http:// address must be transferred to players\n+      by some other means of communication (web chat, E-mail, link in a web\n+      site and so on). The server writes this address to the specified\n+      file, and the client can also take the default value from the same\n+      file. This is convenient when all applications run on a single\n+      machine, but also may be used to transfer the address via shared\n+      filesystem.\n+    </p>\n+    <h3>The game client\n+    </h3>\n+    <p>The clients are Swing-based GUI applications, capable for remote\n+      communication with each other and with the game manager. They have a\n+      set of predefined states and switch between these states in\n+      accordance to the preprogrammed logic. The client states are defined\n+      in the\n+      <i>State\n+      </i> interface. They are displayed in the bottom left\n+      corner of the window and are summarized in the following table:\n+    </p>\n+    <table BORDER=1 CELLPADDING=4 CELLSPACING=0 WIDTH=\"100%\">\n+      <thead>\n+        <tr BGCOLOR=\"#ccccff\">\n+          <th BGCOLOR=\"#e6e6ff\">\n+            Our state\n+          </th>\n+          <th BGCOLOR=\"#e6e6ff\">\n+            Partner state\n+          </th>\n+          <th BGCOLOR=\"#e6e6ff\">\n+            Possible actions\n+          </th>\n+          <th BGCOLOR=\"#e6e6ff\">\n+            Comment\n+          </th>\n+        </tr>\n+      </thead>\n+      <tbody>\n+        <tr>\n+          <td>\n+            Disconnected\n+          </td>\n+          <td>\n+            Partner not accessible\n+          </td>\n+          <td>\n+            Connect\n+          </td>\n+          <td>\n+            Initial state.\n+          </td>\n+        </tr>\n+        <tr>\n+          <td>\n+            Queued\n+          </td>\n+          <td>\n+            Partner not accessible\n+          </td>\n+          <td>\n+            Leave\n+          </td>\n+          <td>\n+            Queued by the game manager.\n+          </td>\n+        </tr>\n+        <tr>\n+          <td>\n+            I think.\n+          </td>\n+          <td>\n+            I wait for your move\n+          </td>\n+          <td>\n+            Make move, reset game, leave, chat.\n+          </td>\n+          <td>\n+            The person who waited for another player to come starts\n+            the game first.\n+          </td>\n+        </tr>\n+        <tr>\n+          <td>\n+            I wait for your move\n+          </td>\n+          <td>\n+            I think\n+          </td>\n+          <td>\n+            Chat, reset game, leave.\n+          </td>\n+          <td>\n+            After the partner makes the move, the state changes to\n+            <i>I think\n+            </i>, unless the end of game situation is detected by\n+            the desk analyzer.\n+          </td>\n+        </tr>\n+        <tr>\n+          <td>\n+            I have lost\n+          </td>\n+          <td>\n+            I have won\n+          </td>\n+          <td>\n+            Chat, reset game, leave.\n+          </td>\n+          <td>\n+            Can be entered with the help of the desk analyzer only.\n+          </td>\n+        </tr>\n+        <tr>\n+          <td>\n+            I have won\n+          </td>\n+          <td>\n+            I have lost\n+          </td>\n+          <td>\n+            Chat, reset game, leave\n+          </td>\n+          <td>\n+            Can be entered with the help of the desk analyzer only.\n+          </td>\n+        </tr>\n+        <tr>\n+          <td>\n+            Error\n+          </td>\n+          <td>\n+            Any\n+          </td>\n+          <td>\n+            Chat, leave\n+          </td>\n+          <td>\n+            This should never happen under normal work, but the demo\n+            program may be modified by the user.\n+          </td>\n+        </tr>\n+      </tbody>\n+    </table>\n+    <br>\n+    <br>\n+    As it is seen, being in one of the states, the client expects to\n+    be the partner client in a certain defined state, and both clients\n+    change they states in a synchronized manner. Each state has its own\n+    set of the available actions and each action either preserves the\n+    current state (chat, reset) or changes it following the rules. For\n+    this simple example, the state change rules are obvious.\n+    <h3>The used RMI-IIOP architecture\n+    </h3>\n+    Both player and game manager servants are derived from the\n+    <i>org.omg.PortableServer.Servant\n+    </i> and, being servants, are simply\n+    connected to the\n+    <i>POA\n+    </i>with\n+    <i>POA.servant_to_reference\n+    </i>. The\n+    first remote object (game manager) is found using the stringified\n+    object reference. No naming service is involved.\n+</p>\n+Where required, the CORBA objects are narrowed into required\n+player and game manager interfaces using method\n+<i>PortableRemoteObject.narrow(org.omg.CORBA.Object object, Class\n+  interface_class)\n+</i>, passing the actual interface of the object as\n+the second parameter. After narrowing, the remote side obtains\n+possibility to invoke remote methods, defined in the interface of\n+this object. After the first remote object is found, other objects\n+can be simply passed as the method parameters. For instance, the game\n+manager introduces another player by passing its reference as a\n+parameter to the method\n+<i>Player.start_game.\n+</i>\n+<h3>Class and interface summary\n+</h3>\n+<table BORDER=1 CELLPADDING=3 CELLSPACING=0 WIDTH=\"100%\">\n+  <col>\n+  <col>\n+  <tr>\n+    <th COLSPAN=2 BGCOLOR=\"#e6e6ff\">\n+      Executables classes\n+    </th>\n+  </tr>\n+  <tr>\n+    <td>\n+      Demo\n+    </td>\n+    <td>\n+      The main executable class of the game client.\n+    </td>\n+  </tr>\n+  <tr>\n+    <td>\n+      X5Server\n+    </td>\n+    <td>\n+      The main executable class of the game manager server.\n+    </td>\n+  </tr>\n+</table>\n+<p></p>\n+<table BORDER=1 CELLPADDING=3 CELLSPACING=0 WIDTH=\"100%\">\n+  <tr BGCOLOR=\"#ccccff\">\n+    <th COLSPAN=2 BGCOLOR=\"#e6e6ff\">\n+      Interface Summary\n+    </th>\n+  </tr>\n+  <tr>\n+    <td>\n+      GameManager\n+    </td>\n+    <td>\n+      The game manager interface.\n+    </td>\n+  </tr>\n+  <tr>\n+    <td>\n+      Player\n+    </td>\n+    <td>\n+      Defines remote methods that are invoked by another player or by\n+      the challenge server.\n+    </td>\n+  </tr>\n+  <tr>\n+    <td>\n+      State\n+    </td>\n+    <td>\n+      Defines the states in that the player can be.\n+    </td>\n+  </tr>\n+</table>\n+&nbsp;\n+<table BORDER=1 CELLPADDING=3 CELLSPACING=0 WIDTH=\"100%\">\n+  <col>\n+  <col>\n+  <tr BGCOLOR=\"#ccccff\">\n+    <th COLSPAN=2 BGCOLOR=\"#e6e6ff\">\n+      Class Summary\n+    </th>\n+  </tr>\n+  <tr>\n+    <td>\n+      _GameManager_Stub\n+    </td>\n+    <td>\n+      Normally generated with rmic compiler, this class represents\n+      the GameManager Stub on the client side.\n+    </td>\n+  </tr>\n+  <tr>\n+    <td>\n+      _GameManagerImpl_Tie\n+    </td>\n+    <td>\n+      Normally generated with rmic compiler, this class represents\n+      the GameManager Tie on the client side.\n+    </td>\n+  </tr>\n+  <tr>\n+    <td>\n+      _Player_Stub\n+    </td>\n+    <td>\n+      Generate with rmic, command line rmic -iiop -poa -keep\n+      gnu.classpath.examples.CORBA.swing.x5.PlayerImpl (the compiled\n+      package must be present in the current folder).\n+    </td>\n+  </tr>\n+  <tr>\n+    <td>\n+      _PlayerImpl_Tie\n+    </td>\n+    <td>\n+      Generate with rmic, command line rmic -iiop -poa -keep\n+      gnu.classpath.examples.CORBA.swing.x5.PlayerImpl (the compiled\n+      package must be present in the current folder).\n+    </td>\n+  </tr>\n+  <tr>\n+    <td>\n+      ChatConstants\n+    </td>\n+    <td>\n+      The chat color code constants, used to indicate who is talking.\n+    </td>\n+  </tr>\n+  <tr>\n+    <td>\n+      ClientFrame\n+    </td>\n+    <td>\n+      The JFrame of the GUI client.\n+    </td>\n+  </tr>\n+  <tr>\n+    <td>\n+      GameManagerImpl\n+    </td>\n+    <td>\n+      The manager connects two players into the game.\n+    </td>\n+  </tr>\n+  <tr>\n+    <td>\n+      IorReader\n+    </td>\n+    <td>\n+      Reads the remote URL.\n+    </td>\n+  </tr>\n+  <tr>\n+    <td>\n+      OrbStarter\n+    </td>\n+    <td>\n+      Starts the ORBs, involved into this application.\n+    </td>\n+  </tr>\n+  <tr>\n+    <td>\n+      PlayerImpl\n+    </td>\n+    <td>\n+      The implementation of the PlayerCommunicator, providing the\n+      local functionality.\n+    </td>\n+  </tr>\n+  <tr>\n+    <td>\n+      PlayingDesk\n+    </td>\n+    <td>\n+      Manages actions, related to the game rules and also does all\n+      painting.\n+    </td>\n+  </tr>\n+</table>\n+<h3>See also\n+</h3>\n+<p>\n+  <a HREF=\"http://www.javascripter.net/games/xo/xo.htm\">http://www.javascripter.net/games/xo/xo.htm\n+  </a>\n+</p>\n+<p>\n+  <a HREF=\"http://www.leepoint.net/notes-java/45examples/55games/five/five.html\">http://www.leepoint.net/notes-java/45examples/55games/five/five.html\n+  </a>\n+</p>\n+<p>Copyright\n+</p>\n+<p>\n+  <font COLOR=\"#b3b3b3\">Copyright (C) 2005 Free Software Foundation,\n+    Inc. This file is part of GNU Classpath. GNU Classpath is free\n+    software; you can redistribute it and/or modify it under the terms of\n+    the GNU General Public License as published by the Free Software\n+    Foundation; either version 2, or (at your option) any later version.\n+    GNU Classpath is distributed in the hope that it will be useful, but\n+    WITHOUT ANY WARRANTY; without even the implied warranty of\n+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+    General Public License for more details. You should have received a\n+    copy of the GNU General Public License along with GNU Classpath; see\n+    the file COPYING. If not, write to the Free Software Foundation,\n+    Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n+    Linking this library statically or dynamically with other modules is\n+    making a combined work based on this library. Thus, the terms and\n+    conditions of the GNU General Public License cover the whole\n+    combination. As a special exception, the copyright holders of this\n+    library give you permission to link this library with independent\n+    modules to produce an executable, regardless of the license terms of\n+    these independent modules, and to copy and distribute the resulting\n+    executable under terms of your choice, provided that you also meet,\n+    for each linked independent module, the terms and conditions of the\n+    license of that module. An independent module is a module which is\n+    not derived from or based on this library. If you modify this\n+    library, you may extend this exception to your version of the\n+    library, but you are not obligated to do so. If you do not wish to do\n+    so, delete this exception statement from your version.\n+  </font>\n+</p>\n+<p>\n+  <br>\n+  <br>\n+</p>\n+<p>\n+First version written by <a href=\"http://savannah.gnu.org/users/audriusa\">\n+Audrius Me&scaron;kauskas</a>\n+</p>\n+</body>\n+</html>"}, {"sha": "9e1a70fcc1659ca85d4131403311cfc09d884d44", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/swing/x5/CanvasWorld.java", "status": "added", "additions": 307, "deletions": 0, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FCanvasWorld.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FCanvasWorld.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FCanvasWorld.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -0,0 +1,307 @@\n+/* CanvasWorld.java --\n+ Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+ This file is part of GNU Classpath.\n+\n+ GNU Classpath is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 2, or (at your option)\n+ any later version.\n+\n+ GNU Classpath is distributed in the hope that it will be useful, but\n+ WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with GNU Classpath; see the file COPYING.  If not, write to the\n+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ 02110-1301 USA.\n+\n+ Linking this library statically or dynamically with other modules is\n+ making a combined work based on this library.  Thus, the terms and\n+ conditions of the GNU General Public License cover the whole\n+ combination.\n+\n+ As a special exception, the copyright holders of this library give you\n+ permission to link this library with independent modules to produce an\n+ executable, regardless of the license terms of these independent\n+ modules, and to copy and distribute the resulting executable under\n+ terms of your choice, provided that you also meet, for each linked\n+ independent module, the terms and conditions of the license of that\n+ module.  An independent module is a module which is not derived from\n+ or based on this library.  If you modify this library, you may extend\n+ this exception to your version of the library, but you are not\n+ obligated to do so.  If you do not wish to do so, delete this\n+ exception statement from your version. */\n+\n+\n+package gnu.classpath.examples.CORBA.swing.x5;\n+\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Point;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.MouseListener;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+import javax.swing.JComponent;\n+import javax.swing.JFrame;\n+import javax.swing.JScrollPane;\n+\n+/**\n+ * The purpose of this simple example is to check if the mouse events are\n+ * correctly received in a scrollable canvas and also if the canvas are\n+ * correctly repainted. The similar canvas are used in various games and\n+ * interactive demonstrations. \n+ * \n+ * The user can set one of the three possible figures with the different\n+ * mouse buttons. The figure must be set where the user have clicked the\n+ * mouse.\n+ *\n+ * @author Audrius Meskauskas (AudriusA@Bioinformatics.org)\n+ */\n+public class CanvasWorld\n+  extends JComponent\n+  implements MouseListener, State\n+{\n+  /**\n+   * Use serialVersionUID for interoperability.\n+   */\n+  private static final long serialVersionUID = 1;\n+\n+  /**\n+   * Red oval, set by the left mouse button.\n+   */\n+  public static final int RED = 0;\n+\n+  /**\n+   * Black cross, set by the right mouse button.\n+   */\n+  public static final int BLACK = 1;\n+  \n+  /**\n+   * Blue and smaller oval, set by the middle mouse button.\n+   */\n+  public static final int HINT = 2;\n+  \n+  /**\n+   * The message string is displayed at the top of the window.\n+   */\n+  String message = \"Click left, right or middle button in to set the figure\";\n+  \n+  /**\n+   * The additinal message, related to the mouse events.\n+   */\n+  String mouse = \"No mouse event so far\";\n+\n+  /**\n+   * The grid spacing.\n+   */\n+  static int W = 16;\n+\n+  /**\n+   * The radius of the dots being painted.\n+   */\n+  static int R = W / 3;\n+\n+  /**\n+   * The collection of the red dots.\n+   */\n+  ArrayList reds = new ArrayList();\n+\n+  /**\n+   * The collection of the black crosses.\n+   */\n+  ArrayList blacks = new ArrayList();\n+  \n+  /**\n+   * The collection of the smaller blue crosses.\n+   */\n+  ArrayList hints = new ArrayList();\n+\n+  public CanvasWorld()\n+  {\n+    try\n+      {\n+        addMouseListener(this);\n+      }\n+    catch (Exception e)\n+      {\n+        throw new AssertionError(e);\n+      }\n+  }\n+\n+  /**\n+   * Paint this component.\n+   */\n+  public void paintComponent(Graphics g)\n+  {\n+    int w = getWidth();\n+    int h = getHeight();\n+\n+    g.setColor(Color.white);\n+    g.fillRect(0, 0, w, h);\n+\n+    drawGrid(w, h, g);\n+    \n+    g.setColor(Color.black);\n+    \n+    g.drawString(message, W, W);\n+    g.drawString(mouse, W, 2*W);\n+    \n+    drawFigures(g);\n+  }\n+\n+  /**\n+   * Check for the presence of the given point in the collection.\n+   */\n+  public final boolean pointPresent(int x, int y, Collection in)\n+  {\n+    Iterator iter = in.iterator();\n+    Point p;\n+    while (iter.hasNext())\n+      {\n+        p = (Point) iter.next();\n+        if (p.x == x && p.y == y)\n+          return true;\n+      }\n+    return false;\n+  }\n+\n+  public void drawGrid(int w, int h, Graphics g)\n+  {\n+    g.setColor(Color.lightGray);\n+\n+    int xs = 2*W+W/2;\n+    \n+    // Draw vertical lines:\n+    for (int x = 0; x < w; x += W)\n+      {\n+        g.drawLine(x, xs, x, h);\n+      }\n+\n+    // Draw horizontal lines:\n+    for (int y = 3*W; y < h; y += W)\n+      {\n+        g.drawLine(0, y, w, y);\n+      }\n+      \n+    g.setColor(Color.gray);\n+  }\n+\n+  public void drawFigures(Graphics g)\n+  {\n+    g.setColor(Color.red);\n+    drawDots(reds, g, RED);\n+\n+    g.setColor(Color.black);\n+    drawDots(blacks, g, BLACK);\n+    \n+    g.setColor(Color.blue);\n+    drawDots(hints, g, HINT);\n+  }\n+\n+  public Point makePoint(int x, int y)\n+  {\n+    return new Point(x / W, y / W);\n+  }\n+\n+  /**\n+   * Draw a collection of dots (the collor must be set before calling the\n+   * method).\n+   */\n+  public void drawDots(Collection dots, Graphics g, int mode)\n+  {\n+    Iterator iter = dots.iterator();\n+    int x;\n+    int y;\n+\n+    int hW = W / 2;\n+    int RR = R * 2;\n+    int hR = R / 2;\n+    Point p;\n+    while (iter.hasNext())\n+      {\n+        p = (Point) iter.next();\n+        x = p.x * W + hW;\n+        y = p.y * W + hW;\n+\n+        if (mode == RED)\n+          g.drawOval(x - R, y - R, RR, RR);\n+        else if (mode == BLACK)\n+          {\n+            g.drawLine(x - R, y - R, x + R, y + R);\n+            g.drawLine(x - R, y + R, x + R, y - R);\n+          }\n+        else\n+          {\n+            // Hint.\n+            g.drawOval(x - hR, y - hR, R, R);\n+          }\n+      }\n+  }\n+\n+  public void mouseClicked(MouseEvent e)\n+  {\n+    int x = e.getX();\n+    int y = e.getY();\n+\n+    Point p = makePoint(x, y);\n+\n+    // Ignore clicks on the occupied cells.\n+    if (pointPresent(p.x, p.y, reds) || (pointPresent(p.x, p.y, blacks)))\n+      {\n+        message = \"Clicked on the occupied cell.\";\n+        return;\n+      }\n+    else\n+      message = \"Figure set at [\"+p.x+\",\"+p.y+\"]\";\n+\n+    if (e.getButton() == MouseEvent.BUTTON1)\n+      reds.add(p);\n+    else if (e.getButton() == MouseEvent.BUTTON3)\n+      blacks.add(p);\n+    else if (e.getButton() == MouseEvent.BUTTON2)\n+      hints.add(p);\n+    repaint();\n+  }\n+\n+  public void mouseEntered(MouseEvent m)\n+  {\n+    mouse = \"Mouse entered.\";\n+    repaint();  \n+  }\n+\n+  public void mousePressed(MouseEvent m)\n+  {\n+    mouse = \"Mouse pressed at \"+m.getX()+\",\"+m.getY();\n+    repaint();\n+  }\n+\n+  public void mouseReleased(MouseEvent m)\n+  {\n+    mouse = \"Mouse released at \"+m.getX()+\",\"+m.getY();    \n+    repaint();\n+  }\n+\n+  public void mouseExited(MouseEvent m)\n+  {\n+    mouse = \"Mouse exited\";\n+    repaint();\n+  }\n+  \n+  public static void main(String[] args)\n+  {\n+    JFrame frame = new JFrame();\n+    CanvasWorld world = new CanvasWorld();\n+    world.setPreferredSize(new Dimension(1000,1000));\n+    frame.add(new JScrollPane(world));\n+    frame.setSize(400, 200);\n+    frame.setVisible(true);\n+  }\n+\n+}\n\\ No newline at end of file"}, {"sha": "b0552b4394360293a8ac9dd03f1db6fcd194d4e7", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/swing/x5/ChatConstants.java", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FChatConstants.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FChatConstants.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FChatConstants.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -0,0 +1,80 @@\n+/* ChatConstants.java --\n+ Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+ This file is part of GNU Classpath.\n+\n+ GNU Classpath is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 2, or (at your option)\n+ any later version.\n+\n+ GNU Classpath is distributed in the hope that it will be useful, but\n+ WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with GNU Classpath; see the file COPYING.  If not, write to the\n+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ 02110-1301 USA.\n+\n+ Linking this library statically or dynamically with other modules is\n+ making a combined work based on this library.  Thus, the terms and\n+ conditions of the GNU General Public License cover the whole\n+ combination.\n+\n+ As a special exception, the copyright holders of this library give you\n+ permission to link this library with independent modules to produce an\n+ executable, regardless of the license terms of these independent\n+ modules, and to copy and distribute the resulting executable under\n+ terms of your choice, provided that you also meet, for each linked\n+ independent module, the terms and conditions of the license of that\n+ module.  An independent module is a module which is not derived from\n+ or based on this library.  If you modify this library, you may extend\n+ this exception to your version of the library, but you are not\n+ obligated to do so.  If you do not wish to do so, delete this\n+ exception statement from your version. */\n+\n+\n+package gnu.classpath.examples.CORBA.swing.x5;\n+\n+import java.awt.Color;\n+\n+/**\n+ * The chat color code constants, used to indicate who is talking.\n+ * Additionally, the red color is reseved for the most important messages,\n+ * related to the start and end of the game.\n+ * \n+ * @author Audrius Meskauskas (AudriusA@Bioinformatics.org) \n+ */\n+public class ChatConstants\n+{\n+  /**\n+   * Messages from the local system.\n+   */\n+  public static byte SYSTEM = 0;\n+\n+  /**\n+   * Mirrored messsages from the local player.\n+   */\n+  public static byte SELF = 1;\n+\n+  /**\n+   * Messages from the remote player.\n+   */\n+  public static byte REMOTE_PLAYER = 2;\n+\n+  /**\n+   * Messages from the game server/\n+   */\n+  public static byte GAME_SERVER = 3;\n+  \n+  /**\n+   * The array of the used colors.\n+   */\n+  public static Color[] colors =\n+    new Color[]\n+    {\n+      Color.black, new Color(0, 80, 0), new Color(0, 0, 128), Color.blue\n+    };\n+}\n\\ No newline at end of file"}, {"sha": "c3d8300b7c3490093bf6bd667da405b99ba3def4", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/swing/x5/ClientFrame.java", "status": "added", "additions": 417, "deletions": 0, "changes": 417, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FClientFrame.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FClientFrame.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FClientFrame.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -0,0 +1,417 @@\n+/* ClientFrame.java --\n+ Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+ This file is part of GNU Classpath.\n+\n+ GNU Classpath is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 2, or (at your option)\n+ any later version.\n+\n+ GNU Classpath is distributed in the hope that it will be useful, but\n+ WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with GNU Classpath; see the file COPYING.  If not, write to the\n+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ 02110-1301 USA.\n+\n+ Linking this library statically or dynamically with other modules is\n+ making a combined work based on this library.  Thus, the terms and\n+ conditions of the GNU General Public License cover the whole\n+ combination.\n+\n+ As a special exception, the copyright holders of this library give you\n+ permission to link this library with independent modules to produce an\n+ executable, regardless of the license terms of these independent\n+ modules, and to copy and distribute the resulting executable under\n+ terms of your choice, provided that you also meet, for each linked\n+ independent module, the terms and conditions of the license of that\n+ module.  An independent module is a module which is not derived from\n+ or based on this library.  If you modify this library, you may extend\n+ this exception to your version of the library, but you are not\n+ obligated to do so.  If you do not wish to do so, delete this\n+ exception statement from your version. */\n+\n+package gnu.classpath.examples.CORBA.swing.x5;\n+\n+import java.awt.BorderLayout;\n+import java.awt.Color;\n+import java.awt.GridLayout;\n+import java.awt.event.*;\n+import java.io.BufferedWriter;\n+import java.io.File;\n+import java.io.FileWriter;\n+\n+import java.rmi.RemoteException;\n+\n+import javax.rmi.PortableRemoteObject;\n+\n+import javax.swing.*;\n+import java.awt.Dimension;\n+\n+/**\n+ * The JFrame of the GUI client.\n+ *\n+ * @author Audrius Meskauskas (AudriusA@Bioinformatics.org)\n+ */\n+public class ClientFrame\n+  extends JFrame\n+{\n+  /**\n+   * The size of the playing field.\n+   */\n+  public final Dimension DESK_SIZE = \n+\tnew Dimension(624, 352-PlayingDesk.W);\n+\n+  /**\n+   * Use serialVersionUID for interoperability.\n+   */\n+  private static final long serialVersionUID = 1;\n+\n+  // Define the application components:\n+\n+  /**\n+   * Central panel where the main action takes place.\n+   */\n+  PlayingDesk desk = new PlayingDesk();\n+\n+  /**\n+   * The scroll pane for canvas.\n+   */\n+  JScrollPane scroll = new JScrollPane();\n+\n+  /**\n+   * Will remember the manager IOR.\n+   */\n+  String mior = \"\";\n+\n+  // The bottom panel contains the area that is used both to enter URL and\n+  // for chatting.\n+  JPanel pnBottom = new JPanel();\n+\n+  BorderLayout layBottom = new BorderLayout();\n+\n+  JTextField taUrl = new JTextField();\n+\n+  // The top primitive chatting panel, composed from labels.\n+  JPanel pnChat = new JPanel();\n+\n+  GridLayout layChat = new GridLayout();\n+\n+  JLabel lbC3 = new JLabel();\n+\n+  JLabel lbC2 = new JLabel();\n+\n+  JLabel lbC1 = new JLabel();\n+\n+  // The button panel.\n+  JPanel pnButtons = new JPanel();\n+\n+  GridLayout layButtons = new GridLayout();\n+\n+  JButton bLeave = new JButton();\n+\n+  JButton bConnect = new JButton();\n+\n+  JButton bExit = new JButton();\n+\n+  JButton bReset = new JButton();\n+\n+  JLabel lbState = new JLabel();\n+\n+  JButton bChat = new JButton();\n+  \n+  JButton bPaste = new JButton();\n+\n+  public ClientFrame()\n+  {\n+    try\n+      {\n+        jbInit();\n+      }\n+    catch (Exception e)\n+      {\n+        e.printStackTrace();\n+      }\n+  }\n+\n+  private void jbInit()\n+    throws Exception\n+  {\n+    desk.frame = this;\n+\n+    pnBottom.setLayout(layBottom);\n+\n+    pnChat.setLayout(layChat);\n+    layChat.setColumns(1);\n+    layChat.setRows(3);\n+\n+    lbC1.setText(\"This program needs the game server (see README on how to start it).\");\n+    lbC2.setText(\"Enter the game server address (host:port)\");\n+    lbC3.setText(\"Pressing \\'Connect\\' with the empty address will start the server on \"\n+      + \"the local machine.\");\n+    bLeave.setEnabled(true);\n+    bLeave.setToolTipText(\"Leave if either you have lost or do not want longer to play with \"\n+      + \"this partner.\");\n+    bLeave.setText(\"Leave game\");\n+    bLeave.addActionListener(new java.awt.event.ActionListener()\n+    {\n+      public void actionPerformed(ActionEvent e)\n+      {\n+        bLeave_actionPerformed(e);\n+      }\n+    });\n+    bConnect.setToolTipText(\"Connect your playing partner\");\n+    bConnect.setText(\"Connect\");\n+    bConnect.addActionListener(new java.awt.event.ActionListener()\n+    {\n+      public void actionPerformed(ActionEvent e)\n+      {\n+        bConnect_actionPerformed(e);\n+      }\n+    });\n+    pnButtons.setLayout(layButtons);\n+    bExit.setToolTipText(\"Exit this program\");\n+    bExit.setText(\"Exit\");\n+    bExit.addActionListener(new java.awt.event.ActionListener()\n+    {\n+      public void actionPerformed(ActionEvent e)\n+      {\n+        bExit_actionPerformed(e);\n+      }\n+    });\n+    layButtons.setHgap(2);\n+    bReset.setToolTipText(\"Restart the game. The partner may choose to exit!\");\n+    bReset.setText(\"Reset game\");\n+    bReset.addActionListener(new java.awt.event.ActionListener()\n+    {\n+      public void actionPerformed(ActionEvent e)\n+      {\n+        bReset_actionPerformed(e);\n+      }\n+    });\n+    lbState.setText(\"Disconnected\");\n+    bChat.setToolTipText(\"Send message to player. Reuse the address \"+\n+                         \"field to enter the message.\");\n+    bChat.setText(\"Chat\");\n+    bChat.addActionListener(new java.awt.event.ActionListener()\n+    {\n+      public void actionPerformed(ActionEvent e)\n+      {\n+        bChat_actionPerformed(e);\n+      }\n+    });\n+    \n+    bPaste.setText(\"Paste\");\n+    bPaste.setToolTipText(\"Paste, same as Ctrl-V\");\n+    bPaste.addActionListener(new java.awt.event.ActionListener()\n+    {\n+      public void actionPerformed(ActionEvent e)\n+      {\n+        bPaste_actionPerformed(e);\n+      }\n+    });\n+    \n+    desk.setMaximumSize(DESK_SIZE);\n+    desk.setPreferredSize(DESK_SIZE);\n+    \n+    scroll.getViewport().add(desk, null);\n+    getContentPane().add(scroll, BorderLayout.CENTER);\n+    getContentPane().add(pnBottom, BorderLayout.SOUTH);\n+\n+    pnBottom.add(taUrl, BorderLayout.CENTER);\n+    pnBottom.add(pnChat, BorderLayout.NORTH);\n+\n+    pnChat.add(lbC1, null);\n+    pnChat.add(lbC2, null);\n+    pnChat.add(lbC3, null);\n+    pnBottom.add(pnButtons, BorderLayout.SOUTH);\n+    pnButtons.add(lbState, null);\n+    pnButtons.add(bConnect, null);\n+    pnButtons.add(bChat, null);\n+    pnButtons.add(bLeave, null);\n+    pnButtons.add(bReset, null);\n+    pnButtons.add(bExit, null);\n+    pnButtons.add(bPaste, null);    \n+\n+    desk.player.set_current_state(State.DISCONNECTED);\n+  }\n+\n+  /**\n+   * Handles exit procedure.\n+   */\n+  protected void processWindowEvent(WindowEvent e)\n+  {\n+    super.processWindowEvent(e);\n+    if (e.getID() == WindowEvent.WINDOW_CLOSING)\n+      {\n+        bExit_actionPerformed(null);\n+      }\n+  }\n+\n+  /**\n+   * Handles the connection procedure.\n+   */\n+  void bConnect_actionPerformed(ActionEvent e)\n+  {\n+    try\n+      {\n+        int state = desk.player.get_current_state();\n+\n+        if (state == State.DISCONNECTED || state == State.ERROR)\n+          {\n+            talk(ChatConstants.colors[0], \"Connecting...\");\n+\n+            if (desk.manager == null)\n+              {\n+                mior = taUrl.getText().trim();\n+\n+                // Obtain the manager object:\n+                org.omg.CORBA.Object object = null;\n+\n+                try\n+                  {\n+                    object = desk.orb.string_to_object(mior);\n+                  }\n+                catch (Exception exc)\n+                  {\n+                    // Maybe CORBA 3.0.3 is not completely implemented?\n+                    if (mior.startsWith(\"http://\") || mior.startsWith(\"ftp://\")\n+                      || mior.startsWith(\"file://\"))\n+                      object = desk.orb.string_to_object(IorReader.readUrl(mior));\n+                    else\n+                      throw exc;\n+                  }\n+\n+                desk.manager = (GameManager) PortableRemoteObject.narrow(\n+                  object, GameManager.class);\n+\n+                // Export the desk.player as a remote object.\n+                PortableRemoteObject.exportObject(desk.player);\n+              }\n+\n+            desk.player.set_current_state(State.QUEUED);\n+            desk.manager.requestTheGame(desk.player);\n+          }\n+\n+        // Save the specified IOR for the future use:\n+        File gmf = new File(OrbStarter.WRITE_URL_TO_FILE);\n+        FileWriter f = new FileWriter(gmf);\n+        BufferedWriter b = new BufferedWriter(f);\n+\n+        b.write(mior);\n+        b.close();\n+      }\n+    catch (Exception ex)\n+      {\n+        talk(Color.red, \"The manager is not reachable by this address.\");\n+        talk(Color.red, ex.getMessage());\n+        desk.player.set_current_state(State.DISCONNECTED);\n+      }\n+  }\n+\n+  /**\n+   * Display the new message with the given color. Shift the other messages over\n+   * the labels.\n+   */\n+  public void talk(Color color, String text)\n+  {\n+    lbC1.setText(lbC2.getText());\n+    lbC1.setForeground(lbC2.getForeground());\n+\n+    lbC2.setText(lbC3.getText());\n+    lbC2.setForeground(lbC3.getForeground());\n+\n+    lbC3.setText(text);\n+    lbC3.setForeground(color);\n+  }\n+\n+  /**\n+   * Exit this program.\n+   */\n+  void bExit_actionPerformed(ActionEvent e)\n+  {\n+    try\n+      {\n+        if (desk.player.get_current_state() != State.DISCONNECTED\n+          && desk.player.partner != null)\n+          {\n+            desk.player.partner.receive_chat(ChatConstants.REMOTE_PLAYER,\n+              \"I close the program!\");\n+            desk.player.partner.disconnect();\n+          }\n+      }\n+    catch (RemoteException ex)\n+      {\n+        // We will print the exception because this is a demo application that\n+        // may be modified for learning purposes.\n+        ex.printStackTrace();\n+      }\n+    System.exit(0);\n+  }\n+\n+  void bReset_actionPerformed(ActionEvent e)\n+  {\n+    if (desk.player.partner != null)\n+      {\n+        try\n+          {\n+            desk.player.partner.receive_chat(ChatConstants.REMOTE_PLAYER,\n+              \"Your partner restarted the game.\");\n+\n+            desk.player.start_game(desk.player.partner, false);\n+            desk.player.partner.start_game(desk.player, true);\n+          }\n+        catch (RemoteException ex)\n+          {\n+            // We will print the exception because this is a demo application\n+            // that\n+            // may be modified for learning purposes.\n+            ex.printStackTrace();\n+          }\n+      }\n+    else\n+      talk(Color.black, \"You have not started the game yet.\");\n+  }\n+\n+  void bLeave_actionPerformed(ActionEvent e)\n+  {\n+    desk.player.leave();\n+  }\n+\n+  void bChat_actionPerformed(ActionEvent e)\n+  {\n+    try\n+      {\n+        if (desk.player.partner != null)\n+          {\n+            String message = taUrl.getText();\n+            desk.player.partner.receive_chat(ChatConstants.REMOTE_PLAYER, message);\n+            talk(ChatConstants.colors[ChatConstants.SELF], message);\n+            taUrl.setText(\"\");\n+          }\n+        else\n+          {\n+            talk(Color.black, \"Sorry, not connected to anybody\");\n+          }\n+      }\n+    catch (RemoteException ex)\n+      {\n+        // We will print the exception because this is a demo application that\n+        // may be modified for learning purposes.\n+        ex.printStackTrace();\n+      }\n+  }\n+  \n+  /**\n+   * Work around our keyboard shortcut handling that is still not working\n+   * properly.\n+   */\n+  void bPaste_actionPerformed(ActionEvent e)\n+  {\n+    taUrl.paste();\n+  }  \n+}\n\\ No newline at end of file"}, {"sha": "b83217896d57e4b69b7e3c9302d5556b861bc6b4", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/swing/x5/Demo.java", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FDemo.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FDemo.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FDemo.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -0,0 +1,99 @@\n+/* Demo.java --\n+ Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+ This file is part of GNU Classpath.\n+\n+ GNU Classpath is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 2, or (at your option)\n+ any later version.\n+\n+ GNU Classpath is distributed in the hope that it will be useful, but\n+ WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with GNU Classpath; see the file COPYING.  If not, write to the\n+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ 02110-1301 USA.\n+\n+ Linking this library statically or dynamically with other modules is\n+ making a combined work based on this library.  Thus, the terms and\n+ conditions of the GNU General Public License cover the whole\n+ combination.\n+\n+ As a special exception, the copyright holders of this library give you\n+ permission to link this library with independent modules to produce an\n+ executable, regardless of the license terms of these independent\n+ modules, and to copy and distribute the resulting executable under\n+ terms of your choice, provided that you also meet, for each linked\n+ independent module, the terms and conditions of the license of that\n+ module.  An independent module is a module which is not derived from\n+ or based on this library.  If you modify this library, you may extend\n+ this exception to your version of the library, but you are not\n+ obligated to do so.  If you do not wish to do so, delete this\n+ exception statement from your version. */\n+\n+\n+package gnu.classpath.examples.CORBA.swing.x5;\n+\n+import java.awt.Dimension;\n+import java.awt.Toolkit;\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+\n+/**\n+ * The main executable class of the game client.\n+ * \n+ * @author Audrius Meskauskas (AudriusA@Bioinformatics.org) \n+ */\n+public class Demo\n+{\n+\n+  public static void main(String[] args)\n+  {\n+    ClientFrame frame = new ClientFrame();\n+    frame.setSize(new Dimension(640, 480));\n+    frame.setTitle(\"Make vertical, horizontal or diagonal line of 5 dots. \"\n+      + \"Click mouse to set the dot.\");\n+    frame.validate();\n+\n+    // Center the window\n+    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n+    Dimension frameSize = frame.getSize();\n+    if (frameSize.height > screenSize.height)\n+      {\n+        frameSize.height = screenSize.height;\n+      }\n+    if (frameSize.width > screenSize.width)\n+      {\n+        frameSize.width = screenSize.width;\n+      }\n+    frame.setLocation((screenSize.width - frameSize.width) / 2,\n+      (screenSize.height - frameSize.height) / 2);\n+    frame.setVisible(true);\n+\n+    // Set the ior.\n+    try\n+      {\n+        if (OrbStarter.WRITE_URL_TO_FILE != null)\n+          {\n+            File saved_ior = new File(OrbStarter.WRITE_URL_TO_FILE);\n+            if (saved_ior.exists())\n+              {\n+                FileReader f = new FileReader(saved_ior);\n+                String s = new BufferedReader(f).readLine();\n+                frame.taUrl.setText(s);\n+              }\n+          }\n+      }\n+    catch (Exception e)\n+      {\n+        // We will print the exception, because this is a demo program -\n+        // expected to be modified by user.\n+        e.printStackTrace();\n+      }\n+  }\n+}\n\\ No newline at end of file"}, {"sha": "4d632e8bf5748458e9dd768486d011f0be082458", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/swing/x5/GameManager.java", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FGameManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FGameManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FGameManager.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -0,0 +1,68 @@\n+/* GameManager.java --\n+ Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+ This file is part of GNU Classpath.\n+\n+ GNU Classpath is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 2, or (at your option)\n+ any later version.\n+\n+ GNU Classpath is distributed in the hope that it will be useful, but\n+ WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with GNU Classpath; see the file COPYING.  If not, write to the\n+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ 02110-1301 USA.\n+\n+ Linking this library statically or dynamically with other modules is\n+ making a combined work based on this library.  Thus, the terms and\n+ conditions of the GNU General Public License cover the whole\n+ combination.\n+\n+ As a special exception, the copyright holders of this library give you\n+ permission to link this library with independent modules to produce an\n+ executable, regardless of the license terms of these independent\n+ modules, and to copy and distribute the resulting executable under\n+ terms of your choice, provided that you also meet, for each linked\n+ independent module, the terms and conditions of the license of that\n+ module.  An independent module is a module which is not derived from\n+ or based on this library.  If you modify this library, you may extend\n+ this exception to your version of the library, but you are not\n+ obligated to do so.  If you do not wish to do so, delete this\n+ exception statement from your version. */\n+\n+\n+package gnu.classpath.examples.CORBA.swing.x5;\n+\n+import java.rmi.Remote;\n+import java.rmi.RemoteException;\n+\n+/**\n+ * The game manager interface.\n+ * \n+ * Defines the operations of the game server that connects two players into\n+ * the game. The game server does not participate in the game itself.\n+ * \n+ * @author Audrius Meskauskas (AudriusA@Bioinformatics.org) \n+ */\n+public interface GameManager extends Remote\n+{\n+  /**\n+   * Register the newPlayer as the person who is willing to play. When another\n+   * player calls this method, the Manager connects them by calling\n+   * {@link PlayerCommunicator#start_game}. The manager provides the partner\n+   * and sets (randomly) the starting side.\n+   */\n+  void requestTheGame(Player newPlayer) throws RemoteException;\n+\n+  /**\n+   * Unregister the player that left and is no longer waiting for a playing\n+   * partner to come.\n+   * @throws RemoteException\n+   */\n+  void unregister(Player player) throws RemoteException;\n+}\n\\ No newline at end of file"}, {"sha": "fc449bc50ba2385fe9c037ed74fc8952997db700", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/swing/x5/GameManagerImpl.java", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FGameManagerImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FGameManagerImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FGameManagerImpl.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -0,0 +1,135 @@\n+/* GameManagerImpl.java --\n+ Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+ This file is part of GNU Classpath.\n+\n+ GNU Classpath is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 2, or (at your option)\n+ any later version.\n+\n+ GNU Classpath is distributed in the hope that it will be useful, but\n+ WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with GNU Classpath; see the file COPYING.  If not, write to the\n+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ 02110-1301 USA.\n+\n+ Linking this library statically or dynamically with other modules is\n+ making a combined work based on this library.  Thus, the terms and\n+ conditions of the GNU General Public License cover the whole\n+ combination.\n+\n+ As a special exception, the copyright holders of this library give you\n+ permission to link this library with independent modules to produce an\n+ executable, regardless of the license terms of these independent\n+ modules, and to copy and distribute the resulting executable under\n+ terms of your choice, provided that you also meet, for each linked\n+ independent module, the terms and conditions of the license of that\n+ module.  An independent module is a module which is not derived from\n+ or based on this library.  If you modify this library, you may extend\n+ this exception to your version of the library, but you are not\n+ obligated to do so.  If you do not wish to do so, delete this\n+ exception statement from your version. */\n+\n+package gnu.classpath.examples.CORBA.swing.x5;\n+\n+import java.rmi.RemoteException;\n+\n+import org.omg.CORBA.ORB;\n+import org.omg.CORBA.Object;\n+\n+/**\n+ * The manager connects two players into the game.\n+ * \n+ * @author Audrius Meskauskas (AudriusA@Bioinformatics.org) \n+ */\n+public class GameManagerImpl\n+  implements GameManager\n+{\n+  /**\n+   * The game manager IOR.\n+   */\n+  static String ior;\n+\n+  /**\n+   * The game manager ORB.\n+   */\n+  static ORB orb;\n+\n+  /**\n+   * True if the manager started ok.\n+   */\n+  static boolean ok;\n+\n+  /**\n+   * Another player that is already waiting for the game.\n+   */\n+  Player queuedPlayer = null;\n+\n+  public synchronized void requestTheGame(Player newPlayer)\n+    throws RemoteException\n+  {\n+    System.out.println(\"Game requested\");\n+\n+    if (queuedPlayer == null)\n+      {\n+        // No other player so far.\n+        newPlayer.receive_chat(ChatConstants.GAME_SERVER,\n+          \"Request registered, waiting for the other player to come...\");\n+        System.out.println(\"Player queued.\");\n+        queuedPlayer = newPlayer;\n+      }\n+    else if (queuedPlayer.equals(newPlayer))\n+      {\n+        // The same player applies again.\n+        newPlayer.receive_chat(ChatConstants.GAME_SERVER,\n+          \"No other player so far... Please wait.\");\n+      }\n+    else\n+      {\n+        // As the queued player waited for the game, we allow him/her\n+        // to start the game. This is a reward for waiting.\n+        newPlayer.receive_chat(ChatConstants.GAME_SERVER,\n+          \"The other player is waiting. The game started, your \"\n+            + \"partner begins...\");\n+        queuedPlayer.receive_chat(ChatConstants.GAME_SERVER,\n+          \"The other player arrived. Lets play, you begin the game now...\");\n+\n+        newPlayer.start_game(queuedPlayer, false);\n+        queuedPlayer.start_game(newPlayer, true);\n+\n+        queuedPlayer = null;\n+        System.out.println(\"Players connected.\");\n+      }\n+  }\n+\n+  /**\n+   * Unregister the player who left and is no longer waiting for another side.\n+   */\n+  public void unregister(Player player)\n+    throws RemoteException\n+  {\n+    if (queuedPlayer != null)\n+      {\n+        // We need to verify the identity of the player being unregistered.\n+        // The stubs, being derived from the org.omg.CORBA.Object, have the\n+        // method for this. This method compares the player host address,\n+        // used port and the object key.\n+        if (player instanceof Object && queuedPlayer instanceof Object)\n+          {\n+            Object a = (Object) player;\n+            Object b = (Object) queuedPlayer;\n+\n+            if (a._is_equivalent(b))\n+              queuedPlayer = null;\n+          }\n+        else\n+          queuedPlayer = null;\n+      }\n+    System.out.println(\"Unregistering player\");\n+  }\n+}\n\\ No newline at end of file"}, {"sha": "a976def74f3a1d6f862d4ce4db18586b59fb2361", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/swing/x5/IorReader.java", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FIorReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FIorReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FIorReader.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -0,0 +1,124 @@\n+/* IorReader.java --\n+ Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+ This file is part of GNU Classpath.\n+\n+ GNU Classpath is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 2, or (at your option)\n+ any later version.\n+\n+ GNU Classpath is distributed in the hope that it will be useful, but\n+ WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with GNU Classpath; see the file COPYING.  If not, write to the\n+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ 02110-1301 USA.\n+\n+ Linking this library statically or dynamically with other modules is\n+ making a combined work based on this library.  Thus, the terms and\n+ conditions of the GNU General Public License cover the whole\n+ combination.\n+\n+ As a special exception, the copyright holders of this library give you\n+ permission to link this library with independent modules to produce an\n+ executable, regardless of the license terms of these independent\n+ modules, and to copy and distribute the resulting executable under\n+ terms of your choice, provided that you also meet, for each linked\n+ independent module, the terms and conditions of the license of that\n+ module.  An independent module is a module which is not derived from\n+ or based on this library.  If you modify this library, you may extend\n+ this exception to your version of the library, but you are not\n+ obligated to do so.  If you do not wish to do so, delete this\n+ exception statement from your version. */\n+\n+\n+package gnu.classpath.examples.CORBA.swing.x5;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+\n+import org.omg.CORBA.BAD_PARAM;\n+import org.omg.CORBA.DATA_CONVERSION;\n+\n+/**\n+ * Reads the remote URL. Following formal/04-03-12, CORBA should be able to do \n+ * this without the help of this class. However some popular class libraries\n+ * are written using the older CORBA specifications and may not handle \n+ * functionality, require by this game. This class substitutes the functionality,\n+ * ensuring that these implementations will also start and we will be able\n+ * to test the interoperability.\n+ * \n+ * @author Audrius Meskauskas (AudriusA@Bioinformatics.org) \n+ */\n+public class IorReader\n+{\n+  /**\n+   * Read IOR from the remote URL.\n+   */\n+  public static String readUrl(String url)\n+  {\n+    URL u;\n+    try\n+      {\n+        u = new URL(url);\n+      }\n+    catch (MalformedURLException mex)\n+      {\n+        throw new BAD_PARAM(\"Malformed URL: '\" + url + \"'\");\n+      }\n+\n+    try\n+      {\n+        InputStreamReader r = new InputStreamReader(u.openStream());\n+\n+        StringBuffer b = new StringBuffer();\n+        int c;\n+\n+        while ((c = r.read()) > 0)\n+          b.append((char) c);\n+\n+        return b.toString().trim();\n+      }\n+    catch (Exception exc)\n+      {\n+        DATA_CONVERSION d = new DATA_CONVERSION(\"Reading \" + url + \" failed.\");\n+        throw d;\n+      }\n+  }\n+  \n+  /**\n+   * Read IOR from the file in the local file system.\n+   */\n+  public static String readFile(String file)\n+  {\n+    File f = new File(file);\n+    if (!f.exists())\n+      {\n+        DATA_CONVERSION err = new DATA_CONVERSION(f.getAbsolutePath()\n+          + \" does not exist.\");\n+        throw err;\n+      }\n+    try\n+      {\n+        char[] c = new char[(int) f.length()];\n+        FileReader fr = new FileReader(f);\n+        fr.read(c);\n+        fr.close();\n+        return new String(c).trim();\n+      }\n+    catch (IOException ex)\n+      {\n+        DATA_CONVERSION d = new DATA_CONVERSION();\n+        d.initCause(ex);\n+        throw (d);\n+      }\n+  }  \n+}"}, {"sha": "3852945c6b96cf9c7668427543520c216a66e6ab", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/swing/x5/OrbStarter.java", "status": "added", "additions": 236, "deletions": 0, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FOrbStarter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FOrbStarter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FOrbStarter.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -0,0 +1,236 @@\n+/* OrbStarter.java --\n+ Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+ This file is part of GNU Classpath.\n+\n+ GNU Classpath is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 2, or (at your option)\n+ any later version.\n+\n+ GNU Classpath is distributed in the hope that it will be useful, but\n+ WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with GNU Classpath; see the file COPYING.  If not, write to the\n+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ 02110-1301 USA.\n+\n+ Linking this library statically or dynamically with other modules is\n+ making a combined work based on this library.  Thus, the terms and\n+ conditions of the GNU General Public License cover the whole\n+ combination.\n+\n+ As a special exception, the copyright holders of this library give you\n+ permission to link this library with independent modules to produce an\n+ executable, regardless of the license terms of these independent\n+ modules, and to copy and distribute the resulting executable under\n+ terms of your choice, provided that you also meet, for each linked\n+ independent module, the terms and conditions of the license of that\n+ module.  An independent module is a module which is not derived from\n+ or based on this library.  If you modify this library, you may extend\n+ this exception to your version of the library, but you are not\n+ obligated to do so.  If you do not wish to do so, delete this\n+ exception statement from your version. */\n+\n+\n+package gnu.classpath.examples.CORBA.swing.x5;\n+\n+import java.rmi.RemoteException;\n+import java.util.Properties;\n+\n+import javax.rmi.PortableRemoteObject;\n+import javax.rmi.CORBA.Tie;\n+\n+import org.omg.CORBA.ORB;\n+import org.omg.PortableServer.POA;\n+import org.omg.PortableServer.POAHelper;\n+import org.omg.PortableServer.Servant;\n+\n+/**\n+ * Starts the ORBs, involved into this application.\n+ * \n+ * @author Audrius Meskauskas (AudriusA@Bioinformatics.org)\n+ */\n+public class OrbStarter\n+{\n+  /**\n+   * The game manager name server port. This server allows to access the game\n+   * manager by host (IP) and port rather than by the rather long IOR string.\n+   */\n+  static int MANAGER_NAMER_PORT = 1500;\n+\t  \n+  /**\n+   * The used port range (understood and used by GNU Classpath only).\n+   */\n+  static String USED_PORT_RANGE = \"1501-1503\";\n+\t  \n+  /**\n+   * Specify the file where under start the game manager writes its IOR.\n+   * You may specify the path if the game manager and player clients have\n+   * access to some share file system or if you prefer to write IOR to\n+   * floppy and then read from the floppy on the client side. Both clients\n+   * and server will use this constant. Set to null not to write the IOR.\n+   */\n+  static String WRITE_URL_TO_FILE = \"game_manager_ior.txt\";\t\n+\t\n+  /**\n+   * Start the manager ORB.\n+   * @return the manager URL if it starts.\n+   */\n+  public static String startManager(final String[] args)\n+  {\n+    GameManagerImpl.ior = null;\n+    GameManagerImpl.ok = false;\n+\n+    final Properties p = new Properties();\n+    p.put(\"gnu.CORBA.ListenerPort\", USED_PORT_RANGE);\n+\n+    try\n+      {\n+        new Thread()\n+        {\n+          public void run()\n+          {\n+            try\n+              {\n+                GameManagerImpl.orb = ORB.init(args, p);\n+\n+                // Obtain the root poa:\n+                POA rootPOA = POAHelper.narrow(GameManagerImpl.orb.resolve_initial_references(\"RootPOA\"));\n+\n+                GameManagerImpl impl = new GameManagerImpl();\n+\n+                PortableRemoteObject.exportObject(impl);\n+\n+                // Construct the tie that is also the servant.\n+                Tie tie = new _GameManagerImpl_Tie();\n+\n+                // Set the invocation target for this tie.\n+                tie.setTarget(impl);\n+\n+                // Obtain the reference to the corresponding CORBA object:\n+                org.omg.CORBA.Object object = rootPOA.servant_to_reference((Servant) tie);\n+\n+                GameManagerImpl.ok = true;\n+\n+                // Activate the root POA.\n+                rootPOA.the_POAManager().activate();\n+\n+                // Get the IOR URL that must be passed to clients.\n+                GameManagerImpl.ior = GameManagerImpl.orb.object_to_string(object);\n+\n+                GameManagerImpl.orb.run();\n+              }\n+            catch (Exception exc)\n+              {\n+                exc.printStackTrace();\n+                GameManagerImpl.ior = \"Unable to start the ORB: \" + exc;\n+              }\n+          }\n+        }.start();\n+\n+        // Wait the thread to enter orb.run.\n+        long t = System.currentTimeMillis();\n+        while (GameManagerImpl.ior == null\n+          && System.currentTimeMillis() - t < 20000)\n+          {\n+            Thread.sleep(100);\n+          }\n+\n+        return GameManagerImpl.ior;\n+      }\n+    catch (Exception e)\n+      {\n+        e.printStackTrace();\n+        return \"Exception: \" + e;\n+      }\n+  }\n+  \n+  /**\n+   * Start the client ORB.\n+   */\n+  public static String startPlayer(final Player player, final PlayingDesk desk)\n+  {\n+    desk.ior = null;\n+    desk.ok = false;\n+    \n+    final Properties p = new Properties();\n+    p.put(\"gnu.CORBA.ListenerPort\", USED_PORT_RANGE);\n+    \n+    try\n+      {\n+        new Thread()\n+        {\n+          public void run()\n+          {\n+            try\n+              {\n+                desk.orb = ORB.init(new String[0], p);\n+\n+                POA rootPOA = POAHelper.narrow(desk.orb.resolve_initial_references(\"RootPOA\"));\n+                rootPOA.the_POAManager().activate();\n+\n+                // Construct the tie.\n+                Tie tie = new _PlayerImpl_Tie();\n+\n+                // Set the implementing class (invocation target).\n+                tie.setTarget(new PlayerImpl());\n+\n+                // Connect the tie as POA servant.\n+                org.omg.CORBA.Object object = rootPOA.servant_to_reference((Servant) tie);\n+\n+                // Get the stringified reference.\n+                desk.ior = desk.orb.object_to_string(object);\n+\n+                // Mark that the object was created OK.\n+                desk.ok = true;\n+                desk.orb.run();\n+              }\n+            catch (Exception exc)\n+              {\n+                exc.printStackTrace();\n+                desk.ior = \"Unable to start the ORB: \" + exc;\n+              }\n+          }\n+        }.start();\n+\n+        long t = System.currentTimeMillis();\n+        while (desk.ior == null && System.currentTimeMillis() - t < 20000)\n+          {\n+            Thread.sleep(100);\n+          }\n+      }\n+    catch (Exception e)\n+      {\n+        e.printStackTrace();\n+        return \"Exception: \" + e;\n+      }\n+\n+    // Add shutdown hook to unregister from the manager.\n+    Runtime.getRuntime().addShutdownHook(new Thread()\n+    {\n+      public void run()\n+      {\n+        if (desk.manager != null && player != null)\n+          {\n+            try\n+              {\n+                desk.manager.unregister(player);\n+              }\n+            catch (RemoteException ex)\n+              {\n+                // We will print the exception because this is a demo\n+                // application that\n+                // may be modified for learning purposes.\n+                ex.printStackTrace();\n+              }\n+            desk.manager = null;\n+          }\n+      }\n+    });\n+    return desk.ior;\n+  }  \n+}"}, {"sha": "ff5624b79c42fc63df2fd77a67934184ef6427c3", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/swing/x5/Player.java", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FPlayer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FPlayer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FPlayer.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -0,0 +1,96 @@\n+/* Player.java --\n+ Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+ This file is part of GNU Classpath.\n+\n+ GNU Classpath is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 2, or (at your option)\n+ any later version.\n+\n+ GNU Classpath is distributed in the hope that it will be useful, but\n+ WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with GNU Classpath; see the file COPYING.  If not, write to the\n+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ 02110-1301 USA.\n+\n+ Linking this library statically or dynamically with other modules is\n+ making a combined work based on this library.  Thus, the terms and\n+ conditions of the GNU General Public License cover the whole\n+ combination.\n+\n+ As a special exception, the copyright holders of this library give you\n+ permission to link this library with independent modules to produce an\n+ executable, regardless of the license terms of these independent\n+ modules, and to copy and distribute the resulting executable under\n+ terms of your choice, provided that you also meet, for each linked\n+ independent module, the terms and conditions of the license of that\n+ module.  An independent module is a module which is not derived from\n+ or based on this library.  If you modify this library, you may extend\n+ this exception to your version of the library, but you are not\n+ obligated to do so.  If you do not wish to do so, delete this\n+ exception statement from your version. */\n+\n+package gnu.classpath.examples.CORBA.swing.x5;\n+\n+import java.awt.Point;\n+\n+import java.rmi.Remote;\n+import java.rmi.RemoteException;\n+\n+/**\n+ * Defines remote methods that are invoked by another player or by the\n+ * challenge server.\n+ * \n+ * @author Audrius Meskauskas (AudriusA@Bioinformatics.org) \n+ */\n+public interface Player extends Remote\n+{\n+  /**\n+   * Receive the invitation to play from the patner or the game manager.\n+   *\n+   * @param address the address (host and port) of the remote partner.\n+   * @param youStart if true, the game manager instructs to start\n+   * the game first (another side is instructed to start the game second).\n+   *\n+   * @return true on success.\n+   */\n+  boolean start_game(Player otherPlayer, boolean youStart)\n+    throws RemoteException;\n+\n+  /**\n+   * Get the state of the local player (one of the constants, defined\n+   * in this interface).\n+   */\n+  int get_current_state() throws RemoteException;\n+\n+  /**\n+   * Receive the chat message from the friend or challenge server (remote).\n+   * Possible at any state, always remote.\n+   *\n+   * @param color the color code, used to highlight the message.\n+   * @param text the message text.\n+   */\n+  void receive_chat(byte color, String test) throws RemoteException;\n+\n+  /**\n+   * Indicated that the remote side leaves the game (capitulating).\n+   */\n+  void disconnect() throws RemoteException;\n+\n+  /**\n+   * Receive friends move (possible at I_WAIT_FOR_YOUR_MOVE).\n+   *\n+   * @param x grid position.\n+   * @param y grid position.\n+   *\n+   * @param sessionId the session id, must match (otherwise the call is ignored).\n+   * @param victory if not a null, the friend thinks that it has won, the parameter\n+   * containing the ends of the builded line.\n+   */\n+  void receive_move(int x, int y, Point[] victory) throws RemoteException;\n+}\n\\ No newline at end of file"}, {"sha": "c30f7d51a42cd6c7b9561e74d09d0055ea497df4", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/swing/x5/PlayerImpl.java", "status": "added", "additions": 275, "deletions": 0, "changes": 275, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FPlayerImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FPlayerImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FPlayerImpl.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -0,0 +1,275 @@\n+/* PlayerImpl.java --\n+ Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+ This file is part of GNU Classpath.\n+\n+ GNU Classpath is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 2, or (at your option)\n+ any later version.\n+\n+ GNU Classpath is distributed in the hope that it will be useful, but\n+ WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with GNU Classpath; see the file COPYING.  If not, write to the\n+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ 02110-1301 USA.\n+\n+ Linking this library statically or dynamically with other modules is\n+ making a combined work based on this library.  Thus, the terms and\n+ conditions of the GNU General Public License cover the whole\n+ combination.\n+\n+ As a special exception, the copyright holders of this library give you\n+ permission to link this library with independent modules to produce an\n+ executable, regardless of the license terms of these independent\n+ modules, and to copy and distribute the resulting executable under\n+ terms of your choice, provided that you also meet, for each linked\n+ independent module, the terms and conditions of the license of that\n+ module.  An independent module is a module which is not derived from\n+ or based on this library.  If you modify this library, you may extend\n+ this exception to your version of the library, but you are not\n+ obligated to do so.  If you do not wish to do so, delete this\n+ exception statement from your version. */\n+\n+\n+package gnu.classpath.examples.CORBA.swing.x5;\n+\n+import java.awt.Color;\n+import java.awt.Point;\n+\n+import java.rmi.RemoteException;\n+\n+/**\n+ * The implementation of the PlayerCommunicator, providing the local\n+ * functionality. Apart remote methods, the class also defines some local\n+ * methods, needed for the co-ordinated work with the game user interface.\n+ * \n+ * @author Audrius Meskauskas (AudriusA@Bioinformatics.org) \n+ */\n+public class PlayerImpl\n+  implements Player, State\n+{\n+  /**\n+   * The playing table.\n+   */\n+  PlayingDesk desk;\n+\n+  /**\n+   * The state of this player (one of the constants, defined in the player\n+   * interface.\n+   */\n+  private int state = DISCONNECTED;\n+\n+  /**\n+   * The other player.\n+   */\n+  Player partner;\n+\n+  /**\n+   * Called when the local player refuses to continue the game.\n+   */\n+  public void leave()\n+  {\n+    try\n+      {\n+        if (state == I_THINK || state == I_WAIT_FOR_YOUR_MOVE)\n+          {\n+            partner.receive_chat(ChatConstants.REMOTE_PLAYER,\n+              \"Your partner has left the game.\");\n+            partner.disconnect();\n+          }\n+        else if (state == State.QUEUED)\n+          {\n+            if (desk.manager != null)\n+              desk.manager.unregister(desk.player);\n+            receive_chat(ChatConstants.SYSTEM,\n+              \"Do not be so pessimistic, try to play first!\");\n+          }\n+        set_current_state(State.DISCONNECTED);\n+\n+        desk.frame.bChat.setEnabled(false);\n+        desk.frame.bLeave.setEnabled(false);\n+        desk.frame.bConnect.setEnabled(true);\n+        desk.frame.taUrl.setText(desk.frame.mior);\n+      }\n+    catch (RemoteException ex)\n+      {\n+        // We will print the exception because this is a demo application that\n+        // may be modified for learning purposes.\n+        ex.printStackTrace();\n+      }\n+  }\n+\n+  /**\n+   * Called when we make the move. The PlayingTable is responsible for checking\n+   * the correctness of the move and detecting the victory.\n+   * \n+   * @param x x position of the new dot.\n+   * @param y y position of the new dot.\n+   * \n+   * @param victory array of two memebers, representing the endpoints of the\n+   * drawn line (victory detected) or null if no such yet exists.\n+   */\n+  public void we_move(int x, int y, Point[] victory)\n+  {\n+    try\n+      {\n+        set_current_state(I_WAIT_FOR_YOUR_MOVE);\n+        partner.receive_move(x, y, victory);\n+      }\n+    catch (RemoteException ex)\n+      {\n+        // We will print the exception because this is a demo application that\n+        // may be modified for learning purposes.\n+        ex.printStackTrace();\n+\n+        state = ERROR;\n+      }\n+  }\n+\n+  /**\n+   * Set the current state.\n+   */\n+  public void set_current_state(int new_state)\n+  {\n+    state = new_state;\n+\n+    if (state == DISCONNECTED)\n+      {\n+        setStatus(\"Disconnected\");\n+      }\n+    else if (state == I_THINK)\n+      {\n+        setStatus(\"Our move\");\n+      }\n+    else if (state == I_WAIT_FOR_YOUR_MOVE)\n+      {\n+        setStatus(\"Partner's move\");\n+      }\n+    else if (state == ERROR)\n+      {\n+        setStatus(\"Error.\");\n+      }\n+    else if (state == I_HAVE_LOST)\n+      {\n+        setStatus(\"We lost\");\n+      }\n+    else if (state == I_HAVE_WON)\n+      {\n+        setStatus(\"Victory\");\n+      }\n+    else if (state == QUEUED)\n+      {\n+        setStatus(\"Queued\");\n+      }\n+    else\n+      {\n+        setStatus(\"State \" + state);\n+      }\n+\n+    boolean connected = state != State.DISCONNECTED;\n+\n+    desk.frame.bConnect.setEnabled(!connected && state != State.QUEUED);\n+    desk.frame.bReset.setEnabled(connected);\n+    desk.frame.bLeave.setEnabled(connected);\n+    desk.frame.bChat.setEnabled(connected);\n+  }\n+\n+  /**\n+   * Show the state in the status line.\n+   */\n+  public void setStatus(String status)\n+  {\n+    desk.frame.lbState.setText(status);\n+  }\n+\n+  /**\n+   * Receive the invitation to play from the patner or the game manager.\n+   * \n+   * @param address the address (host and port) of the remote partner.\n+   * @param youStart if true, the game manager instructs to start the game first\n+   * (another side is instructed to start the game second).\n+   * \n+   * Game server may also chat a little bit with both players, saying that the\n+   * game has started.\n+   * \n+   * @return true on success.\n+   */\n+  public boolean start_game(Player otherPlayer, boolean youStart)\n+    throws RemoteException\n+  {\n+    partner = otherPlayer;\n+    desk.reset();\n+\n+    if (youStart)\n+      {\n+        set_current_state(I_THINK);\n+      }\n+    else\n+      {\n+        set_current_state(I_WAIT_FOR_YOUR_MOVE);\n+      }\n+\n+    desk.frame.taUrl.setText(\"\");\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Get the state of the local player (one of the constants, defined in this\n+   * interface).\n+   */\n+  public int get_current_state()\n+    throws RemoteException\n+  {\n+    return state;\n+  }\n+\n+  /**\n+   * Receive the chat message from the friend or challenge server (remote).\n+   * Possible at any state, always remote.\n+   * \n+   * @param color the color code, used to highlight the message.\n+   * @param text the message text.\n+   */\n+  public void receive_chat(byte color, String text)\n+    throws RemoteException\n+  {\n+    if (color >= ChatConstants.colors.length)\n+      color = ChatConstants.REMOTE_PLAYER;\n+\n+    desk.frame.talk(ChatConstants.colors[color], text);\n+  }\n+\n+  /**\n+   * Indicated that the remote side leaves the game (capitulating).\n+   */\n+  public void disconnect()\n+    throws RemoteException\n+  {\n+    desk.frame.talk(Color.red, \"The partner leaves the game.\");\n+    partner = null;\n+    set_current_state(DISCONNECTED);\n+\n+    desk.frame.taUrl.setText(desk.frame.mior);\n+  }\n+\n+  /**\n+   * Receive friends move (possible at I_WAIT_FOR_YOUR_MOVE).\n+   * \n+   * @param x grid position.\n+   * @param y grid position.\n+   * @param victory if not a null, the friend thinks that it has won, the\n+   * parameter containing the ends of the builded line.\n+   */\n+  public void receive_move(int x, int y, Point[] victory)\n+    throws RemoteException\n+  {\n+    // The state changes are handled by the PlayingTable\n+    desk.friendsMove(x, y, victory);\n+  }\n+}\n\\ No newline at end of file"}, {"sha": "83178f93606f9f13ada934c42c24aae8e37f866a", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/swing/x5/PlayingDesk.java", "status": "added", "additions": 512, "deletions": 0, "changes": 512, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FPlayingDesk.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FPlayingDesk.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FPlayingDesk.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -0,0 +1,512 @@\n+/* PlayingDesk.java --\n+ Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+ This file is part of GNU Classpath.\n+\n+ GNU Classpath is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 2, or (at your option)\n+ any later version.\n+\n+ GNU Classpath is distributed in the hope that it will be useful, but\n+ WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with GNU Classpath; see the file COPYING.  If not, write to the\n+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ 02110-1301 USA.\n+\n+ Linking this library statically or dynamically with other modules is\n+ making a combined work based on this library.  Thus, the terms and\n+ conditions of the GNU General Public License cover the whole\n+ combination.\n+\n+ As a special exception, the copyright holders of this library give you\n+ permission to link this library with independent modules to produce an\n+ executable, regardless of the license terms of these independent\n+ modules, and to copy and distribute the resulting executable under\n+ terms of your choice, provided that you also meet, for each linked\n+ independent module, the terms and conditions of the license of that\n+ module.  An independent module is a module which is not derived from\n+ or based on this library.  If you modify this library, you may extend\n+ this exception to your version of the library, but you are not\n+ obligated to do so.  If you do not wish to do so, delete this\n+ exception statement from your version. */\n+\n+\n+package gnu.classpath.examples.CORBA.swing.x5;\n+\n+import java.awt.Color;\n+import java.awt.Graphics;\n+import java.awt.Point;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.MouseListener;\n+import java.rmi.RemoteException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+import javax.swing.JComponent;\n+\n+import org.omg.CORBA.ORB;\n+\n+/**\n+ * Manages actions, related to the game rules and also does all painting.\n+ *\n+ * @author Audrius Meskauskas, Lithuania (AudriusA@Bioinformatics.org)\n+ */\n+public class PlayingDesk\n+  extends JComponent\n+  implements MouseListener, State\n+{\n+  /**\n+   * Use serialVersionUID for interoperability.\n+   */\n+  private static final long serialVersionUID = 1;\n+\n+  /**\n+   * Indicates that the field point state is the red oval.\n+   */\n+  public static final int RED = 0;\n+\n+  /**\n+   * Indicates that the field point state is the black cross.\n+   */\n+  public static final int BLACK = 1;\n+\n+  /**\n+   * Indicates that the field point state is the hint, suggested by the fan.\n+   */\n+  public static final int HINT = 2;\n+\n+  /**\n+   * The access to the main frame methods.\n+   */\n+  ClientFrame frame;\n+\n+  /**\n+   * The access to the player communicator.\n+   */\n+  PlayerImpl player;\n+\n+  /**\n+   * The game manager.\n+   */\n+  GameManager manager;\n+\n+  /**\n+   * The player ORB.\n+   */\n+  ORB orb;\n+\n+  /**\n+   * The player IOR.\n+   */\n+  String ior;\n+\n+  /**\n+   * True if the player ORB started ok.\n+   */\n+  boolean ok;\n+\n+  /**\n+   * The grid spacing.\n+   */\n+  static int W = 16;\n+\n+  /**\n+   * The radius of the dots being painted.\n+   */\n+  static int R = W / 3;\n+\n+  /**\n+   * The collection of the red dots.\n+   */\n+  ArrayList reds = new ArrayList();\n+\n+  /**\n+   * The collection of the black dots.\n+   */\n+  ArrayList blacks = new ArrayList();\n+\n+  /**\n+   * The array of hints.\n+   */\n+  ArrayList hints = new ArrayList();\n+\n+  /**\n+   * When the game is completed, obtains the value of the two end points of the\n+   * created line.\n+   */\n+  Point[] endOfGame;\n+\n+  public PlayingDesk()\n+  {\n+    try\n+      {\n+        player = new PlayerImpl();\n+        player.desk = this;\n+\n+        OrbStarter.startPlayer(player, this);\n+\n+        jbInit();\n+      }\n+    catch (Exception e)\n+      {\n+        e.printStackTrace();\n+      }\n+  }\n+\n+  /**\n+   * Paint this component.\n+   */\n+  public void paintComponent(Graphics g)\n+  {\n+    int w = getWidth();\n+    int h = getHeight();\n+\n+    g.setColor(Color.white);\n+    g.fillRect(0, 0, w, h);\n+\n+    drawGrid(w, h, g);\n+    drawFigures(g);\n+  }\n+\n+  /**\n+   * Check maybe a game is finished after setting the point N\n+   */\n+  public Point[] checkFinished(Collection x, Point N)\n+  {\n+    Iterator iter = x.iterator();\n+    Point p;\n+\n+    // The victory, if happens, must occur inside these boundaries:\n+    int ax = N.x - 5;\n+    int bx = N.x + 5;\n+\n+    int ay = N.y - 5;\n+    int by = N.y + 5;\n+\n+    while (iter.hasNext())\n+      {\n+        p = (Point) iter.next();\n+\n+        if (p.x > ax && p.x < bx && p.y > ay && p.y < by)\n+          {\n+            // Check the vertical line down\n+            if (pointPresent(p.x, p.y + 1, x))\n+              if (pointPresent(p.x, p.y + 2, x))\n+                if (pointPresent(p.x, p.y + 3, x))\n+                  if (pointPresent(p.x, p.y + 4, x))\n+                    return new Point[] { p, new Point(p.x, p.y + 4) };\n+\n+            // Check the horizontal line left\n+            if (pointPresent(p.x + 1, p.y, x))\n+              if (pointPresent(p.x + 2, p.y, x))\n+                if (pointPresent(p.x + 3, p.y, x))\n+                  if (pointPresent(p.x + 4, p.y, x))\n+                    return new Point[] { p, new Point(p.x + 4, p.y) };\n+\n+            // Check the diagonal line right down.\n+            if (pointPresent(p.x + 1, p.y + 1, x))\n+              if (pointPresent(p.x + 2, p.y + 2, x))\n+                if (pointPresent(p.x + 3, p.y + 3, x))\n+                  if (pointPresent(p.x + 4, p.y + 4, x))\n+                    return new Point[] { p, new Point(p.x + 4, p.y + 4) };\n+\n+            // Check the diagonal line left down.\n+            if (pointPresent(p.x - 1, p.y + 1, x))\n+              if (pointPresent(p.x - 2, p.y + 2, x))\n+                if (pointPresent(p.x - 3, p.y + 3, x))\n+                  if (pointPresent(p.x - 4, p.y + 4, x))\n+                    return new Point[] { p, new Point(p.x - 4, p.y + 4) };\n+          }\n+      }\n+    return null;\n+  }\n+\n+  /**\n+   * Called when the \"end of the game\" situation is detected.\n+   */\n+  public void drawFinishLine(int xa, int ya, int xb, int yb, Graphics g)\n+  {\n+    g.setColor(Color.blue);\n+\n+    int hW = W / 2;\n+    g.drawLine(xa * W + hW, ya * W + hW, xb * W + hW, yb * W + hW);\n+  }\n+\n+  /**\n+   * Check for the presence of the given point in the collection.\n+   */\n+  public final boolean pointPresent(int x, int y, Collection in)\n+  {\n+    Iterator iter = in.iterator();\n+    Point p;\n+    while (iter.hasNext())\n+      {\n+        p = (Point) iter.next();\n+        if (p.x == x && p.y == y)\n+          return true;\n+      }\n+    return false;\n+  }\n+\n+  public void drawGrid(int w, int h, Graphics g)\n+  {\n+    g.setColor(Color.lightGray);\n+\n+    // Draw vertical lines:\n+    for (int x = 0; x < w; x += W)\n+      {\n+        g.drawLine(x, 0, x, h);\n+      }\n+\n+    // Draw horizontal lines:\n+    for (int y = 0; y < h; y += W)\n+      {\n+        g.drawLine(0, y, w, y);\n+      }\n+      \n+    g.setColor(Color.gray);\n+    g.drawRect(0,0, frame.DESK_SIZE.width, frame.DESK_SIZE.height);\n+    g.drawRect(0,0, frame.DESK_SIZE.width+3, frame.DESK_SIZE.height+3);    \n+  }\n+\n+  public void drawFigures(Graphics g)\n+  {\n+    g.setColor(Color.red);\n+    drawDots(reds, g, RED);\n+\n+    g.setColor(Color.black);\n+    drawDots(blacks, g, BLACK);\n+\n+    g.setColor(Color.lightGray);\n+    drawDots(hints, g, HINT);\n+\n+    if (endOfGame != null)\n+      drawFinishLine(endOfGame[0].x, endOfGame[0].y, endOfGame[1].x,\n+        endOfGame[1].y, g);\n+  }\n+\n+  public Point makePoint(int x, int y)\n+  {\n+    return new Point(x / W, y / W);\n+  }\n+\n+  /**\n+   * Draw a collection of dots (the collor must be set before calling the\n+   * method).\n+   */\n+  public void drawDots(Collection dots, Graphics g, int mode)\n+  {\n+    Iterator iter = dots.iterator();\n+    int x;\n+    int y;\n+\n+    int hW = W / 2;\n+    int RR = R * 2;\n+    int hR = R / 2;\n+    Point p;\n+    while (iter.hasNext())\n+      {\n+        p = (Point) iter.next();\n+        x = p.x * W + hW;\n+        y = p.y * W + hW;\n+\n+        if (mode == RED)\n+          g.drawOval(x - R, y - R, RR, RR);\n+        else if (mode == BLACK)\n+          {\n+            g.drawLine(x - R, y - R, x + R, y + R);\n+            g.drawLine(x - R, y + R, x + R, y - R);\n+          }\n+        else\n+          {\n+            // Hint.\n+            g.drawOval(x - hR, y - hR, R, R);\n+          }\n+      }\n+  }\n+\n+  private void jbInit()\n+    throws Exception\n+  {\n+    addMouseListener(this);\n+  }\n+\n+  public void mouseClicked(MouseEvent e)\n+  {\n+    try\n+      {\n+        int state = player.get_current_state();\n+\n+        // Check if the state is correct.\n+        if (state == I_WAIT_FOR_YOUR_MOVE)\n+          {\n+            frame.talk(Color.black,\n+              \"It is now time for our partner's move, not ours. Please wait.\");\n+          }\n+        else if (state == DISCONNECTED)\n+          {\n+            frame.talk(Color.black,\n+              \"We are not connected to the playing partner yet.\");\n+          }\n+        else if (state == I_HAVE_LOST)\n+          {\n+            frame.talk(Color.black,\n+              \"We have already lost this battle, but why not to try again?\");\n+          }\n+        else if (state == I_HAVE_WON)\n+          {\n+            frame.talk(Color.black,\n+              \"The victory is ours, nothing more to do here.\");\n+          }\n+        else if (player.partner == null)\n+          frame.talk(Color.black, \"No other player so far.\");\n+        else\n+          {\n+            int x = e.getX();\n+            int y = e.getY();\n+\n+            if (x>frame.DESK_SIZE.width ||\n+                y>frame.DESK_SIZE.height)\n+            {\n+              frame.talk(Color.black,\"Outside the game area.\");\n+              return;\n+            }\n+\n+            Point p = makePoint(x, y);\n+\n+            // Ignore clicks on the occupied cells.\n+            if (pointPresent(p.x, p.y, reds)\n+              || (pointPresent(p.x, p.y, blacks)))\n+              {\n+                frame.talk(Color.black,\n+                  \"This is against the rules, select the unoccupied cell.\");\n+                return;\n+              }\n+\n+            reds.add(p);\n+\n+            endOfGame = checkFinished(reds, p);\n+            repaint();\n+\n+            if (endOfGame != null)\n+              {\n+                frame.talk(Color.red, \"Our move \" + p.x + \"-\" + p.y\n+                  + \" and we win!\");\n+                player.set_current_state(I_HAVE_WON);\n+              }\n+            else\n+              {\n+                frame.talk(Color.black, \"Our move \" + p.x + \"-\" + p.y\n+                  + \". Waiting for the other side move...\");\n+                player.set_current_state(I_WAIT_FOR_YOUR_MOVE);\n+              }\n+\n+            player.partner.receive_move(p.x, p.y, endOfGame);\n+          }\n+      }\n+    catch (RemoteException ex)\n+      {\n+        // We will print the exception because this is a demo application\n+        // that may be modified for learning purposes.\n+        ex.printStackTrace();\n+      }\n+  }\n+\n+  /**\n+   * Handle the move of the other playing side.\n+   */\n+  public void friendsMove(int x, int y, Point[] victory)\n+  {\n+    try\n+      {\n+        int state = player.get_current_state();\n+        if (state != I_WAIT_FOR_YOUR_MOVE || pointPresent(x, y, blacks))\n+          {\n+            stateFailed(\"Move \" + x + \"-\" + y);\n+          }\n+        else\n+          {\n+            blacks.add(new Point(x, y));\n+            repaint();\n+\n+            if (victory != null)\n+              {\n+                frame.talk(Color.red,\n+                  \" We have lost this time, unfortunately..\");\n+                player.set_current_state(I_HAVE_LOST);\n+                endOfGame = victory;\n+              }\n+            else\n+              {\n+                frame.talk(Color.black, \"Partner goes \" + x + \"-\" + y\n+                  + \". Your move?\");\n+                player.set_current_state(I_THINK);\n+              }\n+          }\n+      }\n+    catch (RemoteException rex)\n+      {\n+        rex.printStackTrace();\n+      }\n+  }\n+\n+  /**\n+   * Prepare for the new game.\n+   */\n+  public void reset()\n+  {\n+    blacks.clear();\n+    reds.clear();\n+    hints.clear();\n+    endOfGame = null;\n+    repaint();\n+  }\n+\n+  public void mouseEntered(MouseEvent m)\n+  {\n+    // Nothing to do.\n+  }\n+\n+  public void mousePressed(MouseEvent m)\n+  {\n+    // Nothing to do.\n+  }\n+\n+  public void mouseReleased(MouseEvent m)\n+  {\n+    // Nothing to do.\n+  }\n+\n+  public void mouseExited(MouseEvent m)\n+  {\n+    // Nothing to do.\n+  }\n+\n+  /**\n+   * The systems detected the error conditions. The game cannot continue (the\n+   * chat is still possible).\n+   */\n+  public void stateFailed(String reason)\n+  {\n+    try\n+      {\n+        player.receive_chat(ChatConstants.REMOTE_PLAYER,\n+          \"Wrong move, game cannot continue (our state was \"\n+            + player.get_current_state() + \")\");\n+        frame.talk(Color.red, \"The remote side violates communicating rules.\");\n+        player.set_current_state(State.ERROR);\n+      }\n+    catch (RemoteException ex)\n+      {\n+        // We will print the exception because this is a demo application\n+        // that may be modified for learning purposes.\n+        ex.printStackTrace();\n+      }\n+  }\n+}\n\\ No newline at end of file"}, {"sha": "7285396cdc8e321689c2646ef0ba53b46f567280", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/swing/x5/State.java", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FState.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FState.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FState.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -0,0 +1,82 @@\n+/* State.java --\n+ Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+ This file is part of GNU Classpath.\n+\n+ GNU Classpath is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 2, or (at your option)\n+ any later version.\n+\n+ GNU Classpath is distributed in the hope that it will be useful, but\n+ WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with GNU Classpath; see the file COPYING.  If not, write to the\n+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ 02110-1301 USA.\n+\n+ Linking this library statically or dynamically with other modules is\n+ making a combined work based on this library.  Thus, the terms and\n+ conditions of the GNU General Public License cover the whole\n+ combination.\n+\n+ As a special exception, the copyright holders of this library give you\n+ permission to link this library with independent modules to produce an\n+ executable, regardless of the license terms of these independent\n+ modules, and to copy and distribute the resulting executable under\n+ terms of your choice, provided that you also meet, for each linked\n+ independent module, the terms and conditions of the license of that\n+ module.  An independent module is a module which is not derived from\n+ or based on this library.  If you modify this library, you may extend\n+ this exception to your version of the library, but you are not\n+ obligated to do so.  If you do not wish to do so, delete this\n+ exception statement from your version. */\n+\n+\n+package gnu.classpath.examples.CORBA.swing.x5;\n+\n+/**\n+ * Defines the states in that the player can be.\n+ * \n+ * @author Audrius Meskauskas (AudriusA@Bioinformatics.org) \n+ */\n+public interface State {\n+  /**\n+   * The initial (\"disconnected\") state.\n+   */\n+  int DISCONNECTED = 0;\n+  \n+  /**\n+   * The state, indicating that the player has been queued for the game and\n+   * waiting for the partner to come.\n+   */\n+  int QUEUED = 1;\n+\n+  /**\n+   * The \"my move\" state.\n+   */\n+  int I_THINK = 2;\n+\n+  /**\n+   * The \"friend's move\" state.\n+   */\n+  int I_WAIT_FOR_YOUR_MOVE = 3;\n+\n+  /**\n+   * States that we have won.\n+   */\n+  int I_HAVE_WON = 4;\n+\n+  /**\n+   * States that we have lost.\n+   */\n+  int I_HAVE_LOST = 5;\n+  \n+  /**\n+   * The \"inconsistent\" state when it is not possible to continue the game.\n+   */\n+  int ERROR = -1;\n+}\n\\ No newline at end of file"}, {"sha": "2ef9241c52002e23b45f0886edfa92336b37cd65", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/swing/x5/X5Server.java", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FX5Server.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FX5Server.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FX5Server.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -0,0 +1,175 @@\n+/* GameManagerAddressServer.java --\n+ Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+ This file is part of GNU Classpath.\n+\n+ GNU Classpath is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 2, or (at your option)\n+ any later version.\n+\n+ GNU Classpath is distributed in the hope that it will be useful, but\n+ WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with GNU Classpath; see the file COPYING.  If not, write to the\n+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ 02110-1301 USA.\n+\n+ Linking this library statically or dynamically with other modules is\n+ making a combined work based on this library.  Thus, the terms and\n+ conditions of the GNU General Public License cover the whole\n+ combination.\n+\n+ As a special exception, the copyright holders of this library give you\n+ permission to link this library with independent modules to produce an\n+ executable, regardless of the license terms of these independent\n+ modules, and to copy and distribute the resulting executable under\n+ terms of your choice, provided that you also meet, for each linked\n+ independent module, the terms and conditions of the license of that\n+ module.  An independent module is a module which is not derived from\n+ or based on this library.  If you modify this library, you may extend\n+ this exception to your version of the library, but you are not\n+ obligated to do so.  If you do not wish to do so, delete this\n+ exception statement from your version. */\n+\n+\n+package gnu.classpath.examples.CORBA.swing.x5;\n+\n+import java.io.BufferedWriter;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+\n+/**\n+ * The main executable class of the game manager server.\n+ * \n+ * The manager address server returns the IOR address string of the game\n+ * manager. Hence the user does not need to enter the rather long IOR address\n+ * string and only needs to specify the host and port of the machine where the\n+ * game manager is running.\n+ * \n+ * The manager address server starts the main game manager as well.\n+ * \n+ * This server acts as a HTTP server that always returns the same response. This\n+ * primitive functionality is sufficient for its task.\n+ * \n+ * The more complex CORBA applications should use the name service instead. We\n+ * do not use the name service as this would require to start additional\n+ * external application, specific for the different java platforms.\n+ * \n+ * @author Audrius Meskauskas (AudriusA@Bioinformatics.org) \n+ */\n+public class X5Server\n+{\n+  /**\n+   * Start the game manager.\n+   */\n+  public static void main(String[] args)\n+  {\n+    // Start the game manager, write the IOR to the agreed location.\n+    OrbStarter.startManager(args);\n+\n+    if (!GameManagerImpl.ok)\n+      {\n+        System.out.println(\"Unable to start the game manager:\");\n+        System.exit(1);\n+      }\n+\n+    // Print the IOR.\n+    System.out.println(GameManagerImpl.ior);\n+\n+    String manager_address = null;\n+\n+    // Start the game manager server.\n+    ServerSocket nameServer = null;\n+    try\n+      {\n+        nameServer = new ServerSocket(OrbStarter.MANAGER_NAMER_PORT);\n+\n+        System.out.println(\"The game manager is listening at:\");\n+        manager_address = \"http://\"\n+          + InetAddress.getLocalHost().getHostAddress() + \":\"\n+          + nameServer.getLocalPort();\n+\n+        System.out.println(manager_address);\n+\n+        System.out.println(\"Enter this address to the \"\n+          + \"input field of the game client.\");\n+\n+        System.out.println(\"Use ^C to stop the manager.\");\n+      }\n+    catch (Exception ex)\n+      {\n+        System.out.println(\"The port \" + OrbStarter.MANAGER_NAMER_PORT\n+          + \" is not available. The game manager namer will not start.\");\n+        System.exit(1);\n+      }\n+\n+    // Write the IOR to the local file system.\n+    if (OrbStarter.WRITE_URL_TO_FILE != null)\n+      {\n+        try\n+          {\n+            File gmf = new File(OrbStarter.WRITE_URL_TO_FILE);\n+            FileWriter f = new FileWriter(gmf);\n+            BufferedWriter b = new BufferedWriter(f);\n+\n+            b.write(manager_address);\n+            b.close();\n+          }\n+        catch (IOException e)\n+          {\n+            System.out.println(\"Local filesystem not accessible.\"\n+              + \"Read IOR from console.\");\n+          }\n+      }\n+\n+    // Do forever.\n+    while (true)\n+      {\n+        try\n+          {\n+            Socket socket = nameServer.accept();\n+\n+            System.out.println(\"Connected.\");\n+\n+            // Set the two minutes timeout.\n+            socket.setSoTimeout(1000 * 120);\n+\n+            OutputStream out = socket.getOutputStream();\n+\n+            int length = GameManagerImpl.ior.length();\n+\n+            StringBuffer b = new StringBuffer();\n+            b.append(\"HTTP/1.0 200 OK\\r\\n\");\n+            b.append(\"Content-Length: \" + length + \"\\r\\n\");\n+            b.append(\"Connection: close\\r\\n\");\n+            b.append(\"Content-Type: text/plain; charset=UTF-8\\r\\n\");\n+            b.append(\"\\r\\n\");\n+\n+            b.append(GameManagerImpl.ior);\n+\n+            out.write(b.toString().getBytes(\"UTF-8\"));\n+\n+            socket.shutdownOutput();\n+\n+            if (!socket.isClosed())\n+              socket.close();\n+\n+            System.out.println(\"Completed.\");\n+          }\n+        catch (Exception exc)\n+          {\n+            exc.printStackTrace();\n+            System.out.println(\"Network problem.\");\n+          }\n+      }\n+  }\n+}"}, {"sha": "17a62600c962afa3c7607023e4f5940aad361ccf", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/swing/x5/_GameManagerImpl_Tie.java", "status": "added", "additions": 214, "deletions": 0, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2F_GameManagerImpl_Tie.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2F_GameManagerImpl_Tie.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2F_GameManagerImpl_Tie.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -0,0 +1,214 @@\n+/* _GameManagerImpl_Tie.java --\n+ Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+ This file is part of GNU Classpath.\n+\n+ GNU Classpath is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 2, or (at your option)\n+ any later version.\n+\n+ GNU Classpath is distributed in the hope that it will be useful, but\n+ WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with GNU Classpath; see the file COPYING.  If not, write to the\n+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ 02110-1301 USA.\n+\n+ Linking this library statically or dynamically with other modules is\n+ making a combined work based on this library.  Thus, the terms and\n+ conditions of the GNU General Public License cover the whole\n+ combination.\n+\n+ As a special exception, the copyright holders of this library give you\n+ permission to link this library with independent modules to produce an\n+ executable, regardless of the license terms of these independent\n+ modules, and to copy and distribute the resulting executable under\n+ terms of your choice, provided that you also meet, for each linked\n+ independent module, the terms and conditions of the license of that\n+ module.  An independent module is a module which is not derived from\n+ or based on this library.  If you modify this library, you may extend\n+ this exception to your version of the library, but you are not\n+ obligated to do so.  If you do not wish to do so, delete this\n+ exception statement from your version. */\n+\n+\n+package gnu.classpath.examples.CORBA.swing.x5;\n+\n+import java.rmi.Remote;\n+\n+import javax.rmi.PortableRemoteObject;\n+import javax.rmi.CORBA.Tie;\n+\n+import org.omg.CORBA.BAD_OPERATION;\n+import org.omg.CORBA.ORB;\n+import org.omg.CORBA.SystemException;\n+import org.omg.CORBA.portable.InputStream;\n+import org.omg.CORBA.portable.OutputStream;\n+import org.omg.CORBA.portable.ResponseHandler;\n+import org.omg.CORBA.portable.UnknownException;\n+import org.omg.PortableServer.Servant;\n+\n+/**\n+ * Normally generated with rmic compiler, this class represents the GameManager\n+ * Tie on the client side. The Game Manager methods contain the code for remote\n+ * invocation.\n+ * \n+ * This class is normally generated with rmic from the {@link GameManagerImpl}:\n+ * \n+ * <pre>\n+ *   rmic -iiop -poa -keep gnu.classpath.examples.CORBA.swing.x5.GameManagerImpl\n+ * </pre>\n+ * \n+ * (the compiled package must be present in the current folder).\n+ * \n+ * In this example the class was manually edited and commented for better\n+ * understanding of functionality.\n+ * \n+ * @author Audrius Meskauskas (AudriusA@Bioinformatics.org) \n+ */\n+public class _GameManagerImpl_Tie\n+  extends Servant\n+  implements Tie\n+{\n+  /**\n+   * The target, where remote invocations are forwarded.\n+   */\n+  private GameManagerImpl target = null;\n+\n+  /**\n+   * The GameManager repository Id.\n+   */\n+  private static final String[] _type_ids = \n+  { \"RMI:gnu.classpath.examples.CORBA.swing.x5.GameManager:0000000000000000\" };\n+\n+  /**\n+   * Set the target where the remote invocations are forwarded.\n+   */\n+  public void setTarget(Remote a_target)\n+  {\n+    this.target = (GameManagerImpl) a_target;\n+  }\n+\n+  /**\n+   * Get the target where the remote invocations are forwarded.\n+   */\n+  public Remote getTarget()\n+  {\n+    return target;\n+  }\n+\n+  /**\n+   * Get the CORBA object for that this Tie is currently serving the request.\n+   * The same tie may serve multiple requests for the different objects in\n+   * parallel threads.\n+   */\n+  public org.omg.CORBA.Object thisObject()\n+  {\n+    return _this_object();\n+  }\n+\n+  /**\n+   * Deactivate this object.\n+   */\n+  public void deactivate()\n+  {\n+    try\n+      {\n+        _poa().deactivate_object(_poa().servant_to_id(this));\n+      }\n+    catch (org.omg.PortableServer.POAPackage.WrongPolicy exception)\n+      {\n+      }\n+    catch (org.omg.PortableServer.POAPackage.ObjectNotActive exception)\n+      {\n+      }\n+    catch (org.omg.PortableServer.POAPackage.ServantNotActive exception)\n+      {\n+      }\n+  }\n+\n+  /**\n+   * Get the ORB for this tie.\n+   */\n+  public ORB orb()\n+  {\n+    return _orb();\n+  }\n+\n+  /**\n+   * Set the ORB for this tie.\n+   */\n+  public void orb(ORB orb)\n+  {\n+    try\n+      {\n+        ((org.omg.CORBA_2_3.ORB) orb).set_delegate(this);\n+      }\n+    catch (ClassCastException e)\n+      {\n+        throw new org.omg.CORBA.BAD_PARAM(\n+          \"POA Servant requires an instance of org.omg.CORBA_2_3.ORB\");\n+      }\n+  }\n+\n+  /**\n+   * Return all interfaces, supported by this method.\n+   */\n+  public String[] _all_interfaces(org.omg.PortableServer.POA poa,\n+    byte[] objectId)\n+  {\n+    return _type_ids;\n+  }\n+\n+  /**\n+   * This method is invoked by CORBA system to handle the remote invocation.\n+   * \n+   * @param method the name of the method being invoked.\n+   * @param _in the stream to read the method parameters.\n+   * @param reply the responsed handler that can create the output stream to\n+   * write the parameters being returned.\n+   */\n+  public OutputStream _invoke(String method, InputStream _in,\n+    ResponseHandler reply)\n+    throws SystemException\n+  {\n+    try\n+      {\n+        org.omg.CORBA_2_3.portable.InputStream in = \n+          (org.omg.CORBA_2_3.portable.InputStream) _in;\n+        if (method.equals(\"requestTheGame\"))\n+          {\n+            Player p = (Player) PortableRemoteObject.narrow(\n+              in.read_Object(), Player.class);\n+            target.requestTheGame(p);\n+\n+            OutputStream out = reply.createReply();\n+            return out;\n+          }\n+        else if (method.equals(\"unregister\"))\n+          {\n+            Player p = (Player) PortableRemoteObject.narrow(\n+              in.read_Object(), Player.class);\n+            target.unregister(p);\n+\n+            OutputStream out = reply.createReply();\n+            return out;\n+          }\n+        else\n+          throw new BAD_OPERATION();\n+      }\n+    catch (SystemException ex)\n+      {\n+        throw ex;\n+      }\n+    catch (Throwable ex)\n+      {\n+        ex.printStackTrace();\n+        throw new UnknownException(ex);\n+      }\n+  }\n+}\n\\ No newline at end of file"}, {"sha": "e9279963a6ad2daaa4de6963d66d0c2f1d87a2bc", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/swing/x5/_GameManager_Stub.java", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2F_GameManager_Stub.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2F_GameManager_Stub.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2F_GameManager_Stub.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -0,0 +1,207 @@\n+/* _GameManager_Stub.java --\n+ Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+ This file is part of GNU Classpath.\n+\n+ GNU Classpath is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 2, or (at your option)\n+ any later version.\n+\n+ GNU Classpath is distributed in the hope that it will be useful, but\n+ WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with GNU Classpath; see the file COPYING.  If not, write to the\n+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ 02110-1301 USA.\n+\n+ Linking this library statically or dynamically with other modules is\n+ making a combined work based on this library.  Thus, the terms and\n+ conditions of the GNU General Public License cover the whole\n+ combination.\n+\n+ As a special exception, the copyright holders of this library give you\n+ permission to link this library with independent modules to produce an\n+ executable, regardless of the license terms of these independent\n+ modules, and to copy and distribute the resulting executable under\n+ terms of your choice, provided that you also meet, for each linked\n+ independent module, the terms and conditions of the license of that\n+ module.  An independent module is a module which is not derived from\n+ or based on this library.  If you modify this library, you may extend\n+ this exception to your version of the library, but you are not\n+ obligated to do so.  If you do not wish to do so, delete this\n+ exception statement from your version. */\n+\n+\n+package gnu.classpath.examples.CORBA.swing.x5;\n+\n+import java.rmi.RemoteException;\n+import java.rmi.UnexpectedException;\n+\n+import javax.rmi.CORBA.Stub;\n+import javax.rmi.CORBA.Util;\n+\n+import org.omg.CORBA.SystemException;\n+import org.omg.CORBA.portable.ApplicationException;\n+import org.omg.CORBA.portable.OutputStream;\n+import org.omg.CORBA.portable.RemarshalException;\n+import org.omg.CORBA.portable.ServantObject;\n+\n+/**\n+ * Normally generated with rmic compiler, this class represents the GameManager\n+ * Stub on the client side. The Game Manager methods contain the code for\n+ * remote invocation.\n+ * \n+ * This class is normally generated with rmic from the {@link GameManagerImpl}:\n+ * <pre>\n+ * rmic -iiop -poa -keep gnu.classpath.examples.CORBA.swing.x5.GameManagerImpl\n+ * </pre>\n+ * (the compiled package must be present in the current folder).\n+ * \n+ * @author Audrius Meskauskas (AudriusA@Bioinformatics.org) \n+ */\n+public class _GameManager_Stub extends Stub implements GameManager\n+{\n+  /** \n+   * Use serialVersionUID for interoperability. \n+   */\n+  private static final long serialVersionUID = 1;\n+  \n+  private static final String[] _type_ids =\n+    { \"RMI:gnu.classpath.examples.CORBA.swing.x5.GameManager:0000000000000000\" };\n+\n+  public String[] _ids()\n+  {\n+    return _type_ids;\n+  }\n+  \n+  /**\n+   * Notify the manager that the player is no longer willing to play and\n+   * should be removed from the queue.\n+   */\n+  public void unregister(Player p)\n+    throws RemoteException\n+  {\n+    if (!Util.isLocal(this))\n+      {\n+        try\n+          {\n+            org.omg.CORBA.portable.InputStream in = null;\n+            try\n+              {\n+                OutputStream out = _request(\"unregister\", true);\n+                Util.writeRemoteObject(out, p);\n+                _invoke(out);\n+              }\n+            catch (ApplicationException ex)\n+              {\n+                in = ex.getInputStream();\n+\n+                String id = in.read_string();\n+                throw new UnexpectedException(id);\n+              }\n+            catch (RemarshalException ex)\n+              {\n+                unregister(p);\n+              }\n+            finally\n+              {\n+                _releaseReply(in);\n+              }\n+          }\n+        catch (SystemException ex)\n+          {\n+            throw Util.mapSystemException(ex);\n+          }\n+      }\n+    else\n+      {\n+        ServantObject so =\n+          _servant_preinvoke(\"requestTheGame\", GameManager.class);\n+        if (so == null)\n+          {\n+            unregister(p);\n+            return;\n+          }\n+        try\n+          {\n+            ((GameManager) so.servant).unregister(p);\n+          }\n+        catch (Throwable ex)\n+          {\n+            Throwable exCopy = (Throwable) Util.copyObject(ex, _orb());\n+            throw Util.wrapException(exCopy);\n+          }\n+        finally\n+          {\n+            _servant_postinvoke(so);\n+          }\n+      }\n+  }\n+  \n+  /**\n+   * The method that the user should invoke.\n+   */\n+  public void requestTheGame(Player arg0) throws RemoteException\n+  {\n+    if (!Util.isLocal(this))\n+      {\n+        try\n+          {\n+            org.omg.CORBA.portable.InputStream in = null;\n+            try\n+              {\n+                OutputStream out = _request(\"requestTheGame\", true);\n+                Util.writeRemoteObject(out, arg0);\n+                _invoke(out);\n+              }\n+            catch (ApplicationException ex)\n+              {\n+                in = ex.getInputStream();\n+\n+                String id = in.read_string();\n+                throw new UnexpectedException(id);\n+              }\n+            catch (RemarshalException ex)\n+              {\n+                requestTheGame(arg0);\n+              }\n+            finally\n+              {\n+                _releaseReply(in);\n+              }\n+          }\n+        catch (SystemException ex)\n+          {\n+            throw Util.mapSystemException(ex);\n+          }\n+      }\n+    else\n+      {\n+        ServantObject so =\n+          _servant_preinvoke(\"requestTheGame\", GameManager.class);\n+        if (so == null)\n+          {\n+            requestTheGame(arg0);\n+            return;\n+          }\n+        try\n+          {\n+            Player arg0Copy = (Player) Util.copyObject(arg0, _orb());\n+            ((GameManager) so.servant).requestTheGame(arg0Copy);\n+          }\n+        catch (Throwable ex)\n+          {\n+            Throwable exCopy = (Throwable) Util.copyObject(ex, _orb());\n+            throw Util.wrapException(exCopy);\n+          }\n+        finally\n+          {\n+            _servant_postinvoke(so);\n+          }\n+      }\n+  }\n+}\n\\ No newline at end of file"}, {"sha": "730c6f469a0a9ef5eb0c31d8f720dcbcf6f611cd", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/swing/x5/_PlayerImpl_Tie.java", "status": "added", "additions": 212, "deletions": 0, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2F_PlayerImpl_Tie.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2F_PlayerImpl_Tie.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2F_PlayerImpl_Tie.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -0,0 +1,212 @@\n+/* _PlayerImpl_Tie.java --\n+ Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+ This file is part of GNU Classpath.\n+\n+ GNU Classpath is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 2, or (at your option)\n+ any later version.\n+\n+ GNU Classpath is distributed in the hope that it will be useful, but\n+ WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with GNU Classpath; see the file COPYING.  If not, write to the\n+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ 02110-1301 USA.\n+\n+ Linking this library statically or dynamically with other modules is\n+ making a combined work based on this library.  Thus, the terms and\n+ conditions of the GNU General Public License cover the whole\n+ combination.\n+\n+ As a special exception, the copyright holders of this library give you\n+ permission to link this library with independent modules to produce an\n+ executable, regardless of the license terms of these independent\n+ modules, and to copy and distribute the resulting executable under\n+ terms of your choice, provided that you also meet, for each linked\n+ independent module, the terms and conditions of the license of that\n+ module.  An independent module is a module which is not derived from\n+ or based on this library.  If you modify this library, you may extend\n+ this exception to your version of the library, but you are not\n+ obligated to do so.  If you do not wish to do so, delete this\n+ exception statement from your version. */\n+\n+\n+package gnu.classpath.examples.CORBA.swing.x5;\n+\n+import java.awt.Point;\n+import java.rmi.Remote;\n+\n+import javax.rmi.PortableRemoteObject;\n+import javax.rmi.CORBA.Tie;\n+\n+import org.omg.CORBA.BAD_OPERATION;\n+import org.omg.CORBA.ORB;\n+import org.omg.CORBA.SystemException;\n+import org.omg.CORBA.portable.InputStream;\n+import org.omg.CORBA.portable.OutputStream;\n+import org.omg.CORBA.portable.ResponseHandler;\n+import org.omg.CORBA.portable.UnknownException;\n+import org.omg.PortableServer.Servant;\n+\n+/**\n+ * Generate with rmic, command line\n+ * rmic -iiop -poa -keep gnu.classpath.examples.CORBA.swing.x5.PlayerImpl\n+ * (the compiled package must be present in the current folder).\n+ * \n+ * This class is normally generated with rmic from the {@link PlayerImpl}:\n+ * <pre>\n+ * rmic -iiop -poa -keep gnu.classpath.examples.CORBA.swing.x5.PlayerImpl\n+ * </pre>\n+ * (the compiled package must be present in the current folder).\n+ * \n+ * In this example the class was manually edited and commented for better \n+ * understanding of functionality.\n+ * \n+ * @author Audrius Meskauskas (AudriusA@Bioinformatics.org) \n+ */\n+public class _PlayerImpl_Tie extends Servant implements Tie\n+{\n+  private PlayerImpl target = null;\n+  private static final String[] _type_ids =\n+    { \"RMI:gnu.classpath.examples.CORBA.swing.x5.Player:0000000000000000\" };\n+\n+  public void setTarget(Remote a_target)\n+  {\n+    this.target = (PlayerImpl) a_target;\n+  }\n+\n+  public Remote getTarget()\n+  {\n+    return target;\n+  }\n+\n+  public org.omg.CORBA.Object thisObject()\n+  {\n+    return _this_object();\n+  }\n+\n+  public void deactivate()\n+  {\n+    try\n+      {\n+        _poa().deactivate_object(_poa().servant_to_id(this));\n+      }\n+    catch (org.omg.PortableServer.POAPackage.WrongPolicy exception)\n+      {\n+      }\n+    catch (org.omg.PortableServer.POAPackage.ObjectNotActive exception)\n+      {\n+      }\n+    catch (org.omg.PortableServer.POAPackage.ServantNotActive exception)\n+      {\n+      }\n+  }\n+\n+  public ORB orb()\n+  {\n+    return _orb();\n+  }\n+\n+  public void orb(ORB orb)\n+  {\n+    try\n+      {\n+        ((org.omg.CORBA_2_3.ORB) orb).set_delegate(this);\n+      }\n+    catch (ClassCastException e)\n+      {\n+        throw new org.omg.CORBA.BAD_PARAM(\n+          \"POA Servant requires an instance of org.omg.CORBA_2_3.ORB\"\n+        );\n+      }\n+  }\n+\n+  public String[] _all_interfaces(org.omg.PortableServer.POA poa,\n+    byte[] objectId\n+  )\n+  {\n+    return _type_ids;\n+  }\n+\n+  public OutputStream _invoke(String method, InputStream _in,\n+    ResponseHandler reply\n+  ) throws SystemException\n+  {\n+    try\n+      {\n+        org.omg.CORBA_2_3.portable.InputStream in =\n+          (org.omg.CORBA_2_3.portable.InputStream) _in;\n+        switch (method.charAt(9))\n+          {\n+            case 101 :\n+              if (method.equals(\"start_game\"))\n+                {\n+                  Player arg0 =\n+                    (Player) PortableRemoteObject.narrow(in.read_Object(),\n+                      Player.class\n+                    );\n+                  boolean arg1 = in.read_boolean();\n+                  boolean result = target.start_game(arg0, arg1);\n+                  OutputStream out = reply.createReply();\n+                  out.write_boolean(result);\n+                  return out;\n+                }\n+\n+            case 104 :\n+              if (method.equals(\"receive_chat\"))\n+                {\n+                  byte arg0 = in.read_octet();\n+                  String arg1 = (String) in.read_value(String.class);\n+                  target.receive_chat(arg0, arg1);\n+\n+                  OutputStream out = reply.createReply();\n+                  return out;\n+                }\n+\n+            case 111 :\n+              if (method.equals(\"receive_move\"))\n+                {\n+                  int arg0 = in.read_long();\n+                  int arg1 = in.read_long();\n+                  Point[] arg2 = (Point[]) in.read_value(Point[].class);\n+                  target.receive_move(arg0, arg1, arg2);\n+\n+                  OutputStream out = reply.createReply();\n+                  return out;\n+                }\n+\n+            case 114 :\n+              if (method.equals(\"_get_J_current_state\"))\n+                {\n+                  int result = target.get_current_state();\n+                  OutputStream out = reply.createReply();\n+                  out.write_long(result);\n+                  return out;\n+                }\n+\n+            case 116 :\n+              if (method.equals(\"disconnect\"))\n+                {\n+                  target.disconnect();\n+\n+                  OutputStream out = reply.createReply();\n+                  return out;\n+                }\n+          }\n+        throw new BAD_OPERATION(\"No such method: '\"+method+\"'\");\n+      }\n+    catch (SystemException ex)\n+      {\n+        throw ex;\n+      }\n+    catch (Throwable ex)\n+      {\n+        throw new UnknownException(ex);\n+      }\n+  }\n+}\n\\ No newline at end of file"}, {"sha": "eeb5cf0daa410576d17d0bb4a2958581854caecb", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/swing/x5/_Player_Stub.java", "status": "added", "additions": 397, "deletions": 0, "changes": 397, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2F_Player_Stub.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2F_Player_Stub.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2F_Player_Stub.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -0,0 +1,397 @@\n+/* _Player_Stub.java --\n+ Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+ This file is part of GNU Classpath.\n+\n+ GNU Classpath is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 2, or (at your option)\n+ any later version.\n+\n+ GNU Classpath is distributed in the hope that it will be useful, but\n+ WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with GNU Classpath; see the file COPYING.  If not, write to the\n+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ 02110-1301 USA.\n+\n+ Linking this library statically or dynamically with other modules is\n+ making a combined work based on this library.  Thus, the terms and\n+ conditions of the GNU General Public License cover the whole\n+ combination.\n+\n+ As a special exception, the copyright holders of this library give you\n+ permission to link this library with independent modules to produce an\n+ executable, regardless of the license terms of these independent\n+ modules, and to copy and distribute the resulting executable under\n+ terms of your choice, provided that you also meet, for each linked\n+ independent module, the terms and conditions of the license of that\n+ module.  An independent module is a module which is not derived from\n+ or based on this library.  If you modify this library, you may extend\n+ this exception to your version of the library, but you are not\n+ obligated to do so.  If you do not wish to do so, delete this\n+ exception statement from your version. */\n+\n+\n+package gnu.classpath.examples.CORBA.swing.x5;\n+\n+import java.awt.Point;\n+import java.io.Serializable;\n+import java.rmi.RemoteException;\n+import java.rmi.UnexpectedException;\n+\n+import javax.rmi.CORBA.Stub;\n+import javax.rmi.CORBA.Util;\n+\n+import org.omg.CORBA.SystemException;\n+import org.omg.CORBA.portable.ApplicationException;\n+import org.omg.CORBA.portable.OutputStream;\n+import org.omg.CORBA.portable.RemarshalException;\n+import org.omg.CORBA.portable.ServantObject;\n+\n+/**\n+ * Generate with rmic, command line\n+ * rmic -iiop -poa -keep gnu.classpath.examples.CORBA.swing.x5.PlayerImpl\n+ * (the compiled package must be present in the current folder).\n+ * \n+ * This class is normally generated with rmic from the {@link GameManagerImpl}:\n+ * <pre>\n+ * rmic -iiop -poa -keep gnu.classpath.examples.CORBA.swing.x5.GameManagerImpl\n+ * </pre>\n+ * (the compiled package must be present in the current folder).\n+ * \n+ * In this example the class was manually edited and commented for better \n+ * understanding of functionality.\n+ * \n+ * @author Audrius Meskauskas (AudriusA@Bioinformatics.org) \n+ */\n+public class _Player_Stub extends Stub implements Player\n+{\n+  /** \n+   * Use serialVersionUID for interoperability. \n+   */\n+  private static final long serialVersionUID = 1;\n+  \n+  private static final String[] _type_ids =\n+    { \"RMI:gnu.classpath.examples.CORBA.swing.x5.Player:0000000000000000\" };\n+\n+  public String[] _ids()\n+  {\n+    return _type_ids;\n+  }\n+  \n+  public boolean start_game(Player arg0, boolean arg1)\n+    throws RemoteException\n+  {\n+    if (!Util.isLocal(this))\n+      {\n+        try\n+          {\n+            org.omg.CORBA.portable.InputStream in = null;\n+            try\n+              {\n+                OutputStream out = _request(\"start_game\", true);\n+                Util.writeRemoteObject(out, arg0);\n+                out.write_boolean(arg1);\n+                in = _invoke(out);\n+                return in.read_boolean();\n+              }\n+            catch (ApplicationException ex)\n+              {\n+                in = ex.getInputStream();\n+\n+                String id = in.read_string();\n+                throw new UnexpectedException(id);\n+              }\n+            catch (RemarshalException ex)\n+              {\n+                return start_game(arg0, arg1);\n+              }\n+            finally\n+              {\n+                _releaseReply(in);\n+              }\n+          }\n+        catch (SystemException ex)\n+          {\n+            throw Util.mapSystemException(ex);\n+          }\n+      }\n+    else\n+      {\n+        ServantObject so = _servant_preinvoke(\"start_game\", Player.class);\n+        if (so == null)\n+          {\n+            return start_game(arg0, arg1);\n+          }\n+        try\n+          {\n+            Player arg0Copy = (Player) Util.copyObject(arg0, _orb());\n+            return ((Player) so.servant).start_game(arg0Copy, arg1);\n+          }\n+        catch (Throwable ex)\n+          {\n+            Throwable exCopy = (Throwable) Util.copyObject(ex, _orb());\n+            throw Util.wrapException(exCopy);\n+          }\n+        finally\n+          {\n+            _servant_postinvoke(so);\n+          }\n+      }\n+  }\n+\n+  public int get_current_state() throws RemoteException\n+  {\n+    if (!Util.isLocal(this))\n+      {\n+        try\n+          {\n+            org.omg.CORBA.portable.InputStream in = null;\n+            try\n+              {\n+                OutputStream out = _request(\"_get_J_current_state\", true);\n+                in = _invoke(out);\n+                return in.read_long();\n+              }\n+            catch (ApplicationException ex)\n+              {\n+                in = ex.getInputStream();\n+\n+                String id = in.read_string();\n+                throw new UnexpectedException(id);\n+              }\n+            catch (RemarshalException ex)\n+              {\n+                return get_current_state();\n+              }\n+            finally\n+              {\n+                _releaseReply(in);\n+              }\n+          }\n+        catch (SystemException ex)\n+          {\n+            throw Util.mapSystemException(ex);\n+          }\n+      }\n+    else\n+      {\n+        ServantObject so =\n+          _servant_preinvoke(\"_get_J_current_state\", Player.class);\n+        if (so == null)\n+          {\n+            return get_current_state();\n+          }\n+        try\n+          {\n+            return ((Player) so.servant).get_current_state();\n+          }\n+        catch (Throwable ex)\n+          {\n+            Throwable exCopy = (Throwable) Util.copyObject(ex, _orb());\n+            throw Util.wrapException(exCopy);\n+          }\n+        finally\n+          {\n+            _servant_postinvoke(so);\n+          }\n+      }\n+  }\n+\n+  public void receive_chat(byte arg0, String arg1) throws RemoteException\n+  {\n+    if (!Util.isLocal(this))\n+      {\n+        try\n+          {\n+            org.omg.CORBA_2_3.portable.InputStream in = null;\n+            try\n+              {\n+                org.omg.CORBA_2_3.portable.OutputStream out =\n+                  (org.omg.CORBA_2_3.portable.OutputStream) _request(\"receive_chat\",\n+                    true\n+                  );\n+                out.write_octet(arg0);\n+                out.write_value(arg1, String.class);\n+                _invoke(out);\n+              }\n+            catch (ApplicationException ex)\n+              {\n+                in =\n+                  (org.omg.CORBA_2_3.portable.InputStream) ex.getInputStream();\n+\n+                String id = in.read_string();\n+                throw new UnexpectedException(id);\n+              }\n+            catch (RemarshalException ex)\n+              {\n+                receive_chat(arg0, arg1);\n+              }\n+            finally\n+              {\n+                _releaseReply(in);\n+              }\n+          }\n+        catch (SystemException ex)\n+          {\n+            throw Util.mapSystemException(ex);\n+          }\n+      }\n+    else\n+      {\n+        ServantObject so = _servant_preinvoke(\"receive_chat\", Player.class);\n+        if (so == null)\n+          {\n+            receive_chat(arg0, arg1);\n+            return;\n+          }\n+        try\n+          {\n+            ((Player) so.servant).receive_chat(arg0, arg1);\n+          }\n+        catch (Throwable ex)\n+          {\n+            Throwable exCopy = (Throwable) Util.copyObject(ex, _orb());\n+            throw Util.wrapException(exCopy);\n+          }\n+        finally\n+          {\n+            _servant_postinvoke(so);\n+          }\n+      }\n+  }\n+\n+  public void disconnect() throws RemoteException\n+  {\n+    if (!Util.isLocal(this))\n+      {\n+        try\n+          {\n+            org.omg.CORBA.portable.InputStream in = null;\n+            try\n+              {\n+                OutputStream out = _request(\"disconnect\", true);\n+                _invoke(out);\n+              }\n+            catch (ApplicationException ex)\n+              {\n+                in = ex.getInputStream();\n+\n+                String id = in.read_string();\n+                throw new UnexpectedException(id);\n+              }\n+            catch (RemarshalException ex)\n+              {\n+                disconnect();\n+              }\n+            finally\n+              {\n+                _releaseReply(in);\n+              }\n+          }\n+        catch (SystemException ex)\n+          {\n+            throw Util.mapSystemException(ex);\n+          }\n+      }\n+    else\n+      {\n+        ServantObject so = _servant_preinvoke(\"disconnect\", Player.class);\n+        if (so == null)\n+          {\n+            disconnect();\n+            return;\n+          }\n+        try\n+          {\n+            ((Player) so.servant).disconnect();\n+          }\n+        catch (Throwable ex)\n+          {\n+            Throwable exCopy = (Throwable) Util.copyObject(ex, _orb());\n+            throw Util.wrapException(exCopy);\n+          }\n+        finally\n+          {\n+            _servant_postinvoke(so);\n+          }\n+      }\n+  }\n+\n+  public void receive_move(int arg0, int arg1, Point[] arg2)\n+    throws RemoteException\n+  {\n+    if (!Util.isLocal(this))\n+      {\n+        try\n+          {\n+            org.omg.CORBA_2_3.portable.InputStream in = null;\n+            try\n+              {\n+                org.omg.CORBA_2_3.portable.OutputStream out =\n+                  (org.omg.CORBA_2_3.portable.OutputStream) _request(\"receive_move\",\n+                    true\n+                  );\n+                out.write_long(arg0);\n+                out.write_long(arg1);\n+                out.write_value(cast_array(arg2), Point[].class);\n+                _invoke(out);\n+              }\n+            catch (ApplicationException ex)\n+              {\n+                in =\n+                  (org.omg.CORBA_2_3.portable.InputStream) ex.getInputStream();\n+\n+                String id = in.read_string();\n+                throw new UnexpectedException(id);\n+              }\n+            catch (RemarshalException ex)\n+              {\n+                receive_move(arg0, arg1, arg2);\n+              }\n+            finally\n+              {\n+                _releaseReply(in);\n+              }\n+          }\n+        catch (SystemException ex)\n+          {\n+            throw Util.mapSystemException(ex);\n+          }\n+      }\n+    else\n+      {\n+        ServantObject so = _servant_preinvoke(\"receive_move\", Player.class);\n+        if (so == null)\n+          {\n+            receive_move(arg0, arg1, arg2);\n+            return;\n+          }\n+        try\n+          {\n+            Point[] arg2Copy = (Point[]) Util.copyObject(arg2, _orb());\n+            ((Player) so.servant).receive_move(arg0, arg1, arg2Copy);\n+          }\n+        catch (Throwable ex)\n+          {\n+            Throwable exCopy = (Throwable) Util.copyObject(ex, _orb());\n+            throw Util.wrapException(exCopy);\n+          }\n+        finally\n+          {\n+            _servant_postinvoke(so);\n+          }\n+      }\n+  }\n+\n+  // This method is required as a work-around for\n+  // a bug in the JDK 1.1.6 verifier.\n+  private Serializable cast_array(Object obj)\n+  {\n+    return (Serializable) obj;\n+  }\n+}\n\\ No newline at end of file"}, {"sha": "7b9c34ada123027b09acc379a6d94baddd0755aa", "filename": "libjava/classpath/gnu/CORBA/OrbFunctional.java", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fgnu%2FCORBA%2FOrbFunctional.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fgnu%2FCORBA%2FOrbFunctional.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2FCORBA%2FOrbFunctional.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -1612,6 +1612,18 @@ else if (msh_request.message_type == MessageHeader.CLOSE_CONNECTION\n         // TODO log it.\n         return;\n       }\n+    finally\n+      {\n+        try \n+          {\n+            if (service!=null && !service.isClosed())\n+              service.close();\n+          }\n+        catch (IOException ioex)\n+          {\n+            // OK.\n+          }\n+      }\n   }\n   \n   /**"}, {"sha": "3e3125a2b388f4754d24c73425faceabc6f07342", "filename": "libjava/classpath/gnu/java/awt/peer/gtk/GtkDialogPeer.java", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkDialogPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkDialogPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkDialogPeer.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -44,10 +44,6 @@\n import java.awt.event.PaintEvent;\n import java.awt.peer.DialogPeer;\n \n-import javax.swing.JDialog;\n-import javax.swing.JPopupMenu;\n-import javax.swing.JToolTip;\n-\n public class GtkDialogPeer extends GtkWindowPeer\n   implements DialogPeer\n {\n@@ -87,27 +83,9 @@ protected void postExposeEvent (int x, int y, int width, int height)\n   void create ()\n   {\n     Dialog dialog = (Dialog) awtComponent;\n-    int type = GDK_WINDOW_TYPE_HINT_DIALOG;\n-\n-    if (dialog instanceof JDialog)\n-      {\n-        Class heavyWeightClass;\n-        try\n-          {\n-            heavyWeightClass = Class.forName(\"javax.swing.Popup$JWindowPopup\");\n-          }\n-        catch (ClassNotFoundException e)\n-          {\n-            throw new AssertionError(e);\n-          }\n-        \n-        if (dialog.getClass() == heavyWeightClass \n-            || ((JDialog) dialog).getContentPane() instanceof JToolTip)\n-          type = GDK_WINDOW_TYPE_HINT_MENU;\n-      }\n     \n     // Create a decorated dialog window.\n-    create (type, !((Dialog) awtComponent).isUndecorated ());\n+    create (GDK_WINDOW_TYPE_HINT_DIALOG, !((Dialog) awtComponent).isUndecorated ());\n \n     gtkWindowSetModal (dialog.isModal ());\n     setTitle (dialog.getTitle ());"}, {"sha": "57fb87f37bfe837803d2ccfd0a1933e0a0d403c7", "filename": "libjava/classpath/gnu/java/awt/peer/gtk/GtkWindowPeer.java", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkWindowPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkWindowPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkWindowPeer.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -41,7 +41,6 @@\n import java.awt.Component;\n import java.awt.Frame;\n import java.awt.Window;\n-import java.awt.event.ComponentEvent;\n import java.awt.event.WindowEvent;\n import java.awt.peer.WindowPeer;\n \n@@ -80,12 +79,16 @@ int getHeight ()\n \n   void create (int type, boolean decorated)\n   {\n+    Window window = (Window) awtComponent;\n     GtkWindowPeer parent_peer = null;\n     Component parent = awtComponent.getParent();\n-\n+    \n+    if (!window.isFocusableWindow())\n+      type = GDK_WINDOW_TYPE_HINT_MENU;\n+    \n     if (parent != null)\n       parent_peer = (GtkWindowPeer) awtComponent.getParent().getPeer();\n-\n+    \n     create (type, decorated, parent_peer);\n   }\n "}, {"sha": "8e4a413667d1b946d377aa1ca111dea257403d90", "filename": "libjava/classpath/gnu/java/net/protocol/file/Connection.java", "status": "modified", "additions": 50, "deletions": 1, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Ffile%2FConnection.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Ffile%2FConnection.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Ffile%2FConnection.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -59,6 +59,7 @@\n import java.text.SimpleDateFormat;\n import java.util.Date;\n import java.util.Locale;\n+import java.net.MalformedURLException;\n \n /**\n  * This subclass of java.net.URLConnection models a URLConnection via\n@@ -124,6 +125,54 @@ public Connection(URL url)\n     permission = new FilePermission(getURL().getFile(), DEFAULT_PERMISSION);\n   }\n   \n+  /**\n+   * Unquote \"%\" + hex quotes characters\n+   *\n+   * @param str The string to unquote or null.\n+   *\n+   * @return The unquoted string or null if str was null.\n+   *\n+   * @exception MalformedURLException If the given string contains invalid\n+   * escape sequences.\n+   *\n+   * Sadly the same as URI.unquote, but there's nothing we can do to\n+   * make it accessible.\n+   *\n+   */\n+  public static String unquote(String str) throws MalformedURLException\n+  {\n+    if (str == null)\n+      return null;\n+    byte[] buf = new byte[str.length()];\n+    int pos = 0;\n+    for (int i = 0; i < str.length(); i++)\n+      {\n+\tchar c = str.charAt(i);\n+\tif (c > 127)\n+\t  throw new MalformedURLException(str + \" : Invalid character\");\n+\tif (c == '%')\n+\t  {\n+\t    if (i + 2 >= str.length())\n+\t      throw new MalformedURLException(str + \" : Invalid quoted character\");\n+\t    int hi = Character.digit(str.charAt(++i), 16);\n+\t    int lo = Character.digit(str.charAt(++i), 16);\n+\t    if (lo < 0 || hi < 0)\n+\t      throw new MalformedURLException(str + \" : Invalid quoted character\");\n+\t    buf[pos++] = (byte) (hi * 16 + lo);\n+\t  }\n+\telse\n+\t  buf[pos++] = (byte) c;\n+      }\n+    try\n+      {\n+\treturn new String(buf, 0, pos, \"utf-8\");\n+      }\n+    catch (java.io.UnsupportedEncodingException x2)\n+      {\n+\tthrow (Error) new InternalError().initCause(x2);\n+      }\n+  }\n+\n   /**\n    * \"Connects\" to the file by opening it.\n    */\n@@ -134,7 +183,7 @@ public void connect() throws IOException\n       return;\n     \n     // If not connected, then file needs to be openned.\n-    file = new File (getURL().getFile());\n+    file = new File (unquote(getURL().getFile()));\n \n     if (! file.isDirectory())\n       {"}, {"sha": "e2a052ef581860953deb7c5cb6c57a1e2a7dd698", "filename": "libjava/classpath/gnu/java/net/protocol/jar/Connection.java", "status": "modified", "additions": 59, "deletions": 1, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fjar%2FConnection.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fjar%2FConnection.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fjar%2FConnection.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -47,7 +47,10 @@\n import java.net.ProtocolException;\n import java.net.URL;\n import java.net.URLConnection;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n import java.util.Hashtable;\n+import java.util.Locale;\n import java.util.jar.JarEntry;\n import java.util.jar.JarFile;\n import java.util.zip.ZipFile;\n@@ -60,6 +63,12 @@\n  */\n public final class Connection extends JarURLConnection\n {\n+  /**\n+   * HTTP-style DateFormat, used to format the last-modified header.\n+   * Lazy initialized since jar files are used during bootstrapping.\n+   */\n+  private static SimpleDateFormat dateFormat;\n+\n   private JarFile jar_file;\n   private JarEntry jar_entry;\n   private URL jar_url;\n@@ -82,7 +91,9 @@ public static synchronized JarFile get (URL url, boolean useCaches)\n \n       if (\"file\".equals (url.getProtocol()))\n \t{\n-\t  File f = new File (url.getFile());\n+\t  String fn = url.getFile();\n+\t  fn = gnu.java.net.protocol.file.Connection.unquote(fn);\n+\t  File f = new File (fn);\n \t  jf = new JarFile (f, true, ZipFile.OPEN_READ);\n \t}\n       else\n@@ -165,11 +176,58 @@ public synchronized JarFile getJarFile() throws IOException\n     return jar_file;\n   }\n \n+  public String getHeaderField(String field)\n+  {\n+    try\n+      {\n+\tif (!connected)\n+\t  connect();\n+\n+\tif (field.equals(\"content-type\"))\n+          return guessContentTypeFromName(getJarEntry().getName());\n+\telse if (field.equals(\"content-length\"))\n+          return Long.toString(getJarEntry().getSize());\n+\telse if (field.equals(\"last-modified\"))\n+\t  {\n+\t    // Both creating and manipulating dateFormat need synchronization.\n+\t    synchronized (this.getClass())\n+\t      {\n+\t\tif (dateFormat == null)\n+\t\t  dateFormat = new SimpleDateFormat\n+\t\t    (\"EEE, dd MMM yyyy hh:mm:ss 'GMT'\",\n+\t\t     new Locale (\"En\", \"Us\", \"Unix\"));\n+\n+        \treturn dateFormat.format(new Date(getJarEntry().getTime()));\n+\t      }\n+\t  }\n+      }\n+    catch (IOException e)\n+      {\n+        // Fall through.\n+      }\n+    return null;\n+  }\n+\n   public int getContentLength()\n   {\n     if (!connected)\n       return -1;\n \n     return (int) jar_entry.getSize();\n   }\n+\n+  public long getLastModified()\n+  {\n+    if (!connected)\n+      return -1;\n+\n+    try\n+      {\n+\treturn getJarEntry().getTime();\n+      }\n+    catch (IOException e)\n+      {\n+\treturn -1;\n+      }\n+  }\n }"}, {"sha": "ec03d631dcfd76bd6b058e8b5f862edae00d4543", "filename": "libjava/classpath/java/awt/Component.java", "status": "modified", "additions": 4, "deletions": 29, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjava%2Fawt%2FComponent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjava%2Fawt%2FComponent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fawt%2FComponent.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -1409,7 +1409,6 @@ public void reshape(int x, int y, int width, int height)\n       {\n         if (parent != null)\n           {\n-            Rectangle parentBounds = parent.getBounds();\n             Rectangle oldBounds = new Rectangle(oldx, oldy, oldwidth,\n                                                 oldheight);\n             Rectangle newBounds = new Rectangle(x, y, width, height);\n@@ -1887,13 +1886,7 @@ public void paintAll(Graphics g)\n    */\n   public void repaint()\n   {   \n-    if(!isShowing())\n-      {\n-        Component p = parent;\n-        if (p != null)\n-          p.repaint(0, getX(), getY(), width, height);\n-      }\n-    else\n+    if (isShowing())\n       repaint(0, 0, 0, width, height);\n   }\n \n@@ -1908,13 +1901,7 @@ public void repaint()\n    */\n   public void repaint(long tm)\n   {\n-    if(!isShowing())\n-      {\n-        Component p = parent;\n-        if (p != null)\n-          p.repaint(tm, getX(), getY(), width, height);\n-      }\n-    else\n+    if (isShowing())\n       repaint(tm, 0, 0, width, height);\n   }\n \n@@ -1932,13 +1919,7 @@ public void repaint(long tm)\n    */\n   public void repaint(int x, int y, int w, int h)\n   {\n-    if(!isShowing())\n-      {\n-        Component p = parent;\n-        if (p != null)\n-          p.repaint(0, x + getX(), y + getY(), width, height);\n-      }\n-    else\n+    if (isShowing())\n       repaint(0, x, y, w, h);\n   }\n \n@@ -1957,13 +1938,7 @@ public void repaint(int x, int y, int w, int h)\n    */\n   public void repaint(long tm, int x, int y, int width, int height)\n   {\n-    if(!isShowing())\n-      {\n-        Component p = parent;\n-        if (p != null)\n-          p.repaint(tm, x + getX(), y + getY(), width, height);\n-      }\n-    else\n+    if (isShowing())\n       {\n         ComponentPeer p = peer;\n         if (p != null)"}, {"sha": "ed791dc8b8803a86bebed1e52aaea1694b0afdb3", "filename": "libjava/classpath/java/awt/Container.java", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjava%2Fawt%2FContainer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjava%2Fawt%2FContainer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fawt%2FContainer.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -123,6 +123,7 @@ public class Container extends Component\n    */\n   public Container()\n   {\n+    // Nothing to do here.\n   }\n \n   /**\n@@ -427,7 +428,8 @@ public void remove(int index)\n         for (int j = 0; j < list.length; j++)\n               r.removeComponentListener(list[j]);\n         \n-        r.removeNotify();\n+        if (r.isShowing())\n+          r.removeNotify();\n \n         System.arraycopy(component, index + 1, component, index,\n                          ncomponents - index - 1);\n@@ -846,7 +848,7 @@ public void print(Graphics g)\n    */\n   public void paintComponents(Graphics g)\n   {\n-    super.paint(g);\n+    paint(g);\n     visitChildren(g, GfxPaintAllVisitor.INSTANCE, true);\n   }\n \n@@ -1972,6 +1974,7 @@ protected class AccessibleContainerHandler implements ContainerListener\n        */\n       protected AccessibleContainerHandler()\n       {\n+        // Nothing to do here.\n       }\n \n       /**\n@@ -2039,8 +2042,7 @@ void enableEvents(long l)\n    * location, otherwise the appropriate component from the conditions\n    * above.\n    */\n-  Component getDeepestComponentForMouseEventAt (\n-                                                              Component parent, int x, int y)\n+  Component getDeepestComponentForMouseEventAt(Component parent, int x, int y)\n   {\n     if (parent == null || (! parent.contains(x, y)))\n       return null;\n@@ -2064,8 +2066,7 @@ Component acquireComponentForMouseEvent(MouseEvent me)\n     Point p = me.getPoint();\n     while (candidate == null && parent != null)\n       {\n-        candidate =\n-          getDeepestComponentForMouseEventAt(parent, p.x, p.y);\n+        candidate = getDeepestComponentForMouseEventAt(parent, p.x, p.y);\n         if (candidate == null || (candidate.eventMask & me.getID()) == 0)\n           {\n             candidate = null;\n@@ -2147,14 +2148,12 @@ Component acquireComponentForMouseEvent(MouseEvent me)\n         break;\n       }\n \n-    if (me.getID() == MouseEvent.MOUSE_RELEASED\n-        || me.getID() == MouseEvent.MOUSE_PRESSED && modifiers > 0\n+    if (me.getID() == MouseEvent.MOUSE_PRESSED && modifiers > 0\n         || me.getID() == MouseEvent.MOUSE_DRAGGED)\n       {\n         // If any of the following events occur while a button is held down,\n         // they should be dispatched to the same component to which the\n         // original MOUSE_PRESSED event was dispatched:\n-        //   - MOUSE_RELEASED\n         //   - MOUSE_PRESSED: another button pressed while the first is held\n         //     down\n         //   - MOUSE_DRAGGED\n@@ -2204,10 +2203,13 @@ boolean handleEvent(AWTEvent e)\n                 // there is a CLICKED event after this, it will do clean up.\n                 if (--pressCount == 0\n                     && mouseEventTarget != pressedComponent)\n-                  pressedComponent = null;\n+                  {\n+                    pressedComponent = null;\n+                    pressCount = 0;\n+                  }\n                 break;\n               }\n-            \n+\n             MouseEvent newEvt =\n               AWTUtilities.convertMouseEvent(nativeContainer, me,\n                                              mouseEventTarget);"}, {"sha": "95cd4081922ceda756dde2eec26db8090aea592b", "filename": "libjava/classpath/java/awt/image/MemoryImageSource.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjava%2Fawt%2Fimage%2FMemoryImageSource.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjava%2Fawt%2Fimage%2FMemoryImageSource.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fawt%2Fimage%2FMemoryImageSource.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -187,7 +187,7 @@ public void startProduction(ImageConsumer ic)\n \tic = (ImageConsumer) list.elementAt(i);\n \tsendPicture(ic);\n \tif (animated)\n-\t  ic.imageComplete(ImageConsumer.SINGLEFRAME);\n+\t  ic.imageComplete(ImageConsumer.SINGLEFRAMEDONE);\n \telse\n \t  ic.imageComplete(ImageConsumer.STATICIMAGEDONE);\n       }"}, {"sha": "31802c631d6bb6df0fa28741d742a3dbace64b97", "filename": "libjava/classpath/java/io/FilePermission.java", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjava%2Fio%2FFilePermission.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjava%2Fio%2FFilePermission.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fio%2FFilePermission.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -278,13 +278,13 @@ else if (!f1.equals(f2))\n \tbreak;\n       }\n \n-    if (readPerm && ! fp.readPerm)\n+    if (fp.readPerm && ! readPerm)\n       return false;\n-    if (writePerm && ! fp.writePerm)\n+    if (fp.writePerm && ! writePerm)\n       return false;\n-    if (executePerm && ! fp.executePerm)\n+    if (fp.executePerm && ! executePerm)\n       return false;\n-    if (deletePerm && ! fp.deletePerm)\n+    if (fp.deletePerm && ! deletePerm)\n       return false;\n     \n     return true;"}, {"sha": "1d947a0b46a694d8b6ddffdd97e80dfcad2e76dc", "filename": "libjava/classpath/java/net/URL.java", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjava%2Fnet%2FURL.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjava%2Fnet%2FURL.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fnet%2FURL.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -408,10 +408,7 @@ public URL(URL context, String spec, URLStreamHandler ph)\n \t    // The 1.2 doc specifically says these are copied to the new URL.\n \t    host = context.host;\n \t    port = context.port;\n-\t    file = context.file;\n             userInfo = context.userInfo;\n-\t    if (file == null || file.length() == 0)\n-\t      file = \"/\";\n \t    authority = context.authority;\n \t  }\n       }\n@@ -423,10 +420,13 @@ else if (context != null)\n \tprotocol = context.protocol;\n \thost = context.host;\n \tport = context.port;\n-\tfile = context.file;\n         userInfo = context.userInfo;\n-\tif (file == null || file.length() == 0)\n-\t  file = \"/\";\n+\tif (spec.indexOf(\":/\", 1) < 0)\n+\t  {\n+\t    file = context.file;\n+\t    if (file == null || file.length() == 0)\n+\t      file = \"/\";\n+\t  }\n \tauthority = context.authority;\n       }\n     else // Protocol NOT specified in spec. and no context available."}, {"sha": "9d0e5041006e14fda13b612497e2f55360431ba8", "filename": "libjava/classpath/java/net/URLClassLoader.java", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjava%2Fnet%2FURLClassLoader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjava%2Fnet%2FURLClassLoader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fnet%2FURLClassLoader.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -536,15 +536,15 @@ static final class FileURLLoader extends URLLoader\n     Resource getResource(String name)\n     {\n       try \n-\t{\n-\t  File file = new File(dir, name).getCanonicalFile();\n-\t  if (file.exists() && !file.isDirectory())\n-\t    return new FileResource(this, file);\n-\t}\n+ \t{\n+ \t  File file = new File(dir, name).getCanonicalFile();\n+ \t  if (file.exists() && !file.isDirectory())\n+ \t    return new FileResource(this, file);\n+ \t}\n       catch (IOException e)\n-\t{\n-\t  // Fall through...\n-\t}\n+ \t{\n+ \t  // Fall through...\n+ \t}\n       return null;\n     }\n   }\n@@ -873,47 +873,47 @@ protected Class findClass(final String className)\n     // construct the class (and watch out for those nasty IOExceptions)\n     try\n       {\n-        byte[] data;\n-        InputStream in = resource.getInputStream();\n-        try\n-          {\n-            int length = resource.getLength();\n-            if (length != -1)\n-              {\n-                // We know the length of the data.\n-                // Just try to read it in all at once\n-                data = new byte[length];\n-                int pos = 0;\n-                while (length - pos > 0)\n-                  {\n-                    int len = in.read(data, pos, length - pos);\n-                    if (len == -1)\n-                      throw new EOFException(\"Not enough data reading from: \"\n-                                             + in);\n-                    pos += len;\n-                  }\n-              }\n-            else\n-              {\n-                // We don't know the data length.\n-                // Have to read it in chunks.\n-                ByteArrayOutputStream out = new ByteArrayOutputStream(4096);\n-                byte[] b = new byte[4096];\n-                int l = 0;\n-                while (l != -1)\n-                  {\n-                    l = in.read(b);\n-                    if (l != -1)\n-                      out.write(b, 0, l);\n-                  }\n-                data = out.toByteArray();\n-              }\n-          }\n-        finally\n-          {\n-            in.close();\n-          }\n-        final byte[] classData = data;\n+\tbyte[] data;\n+\tInputStream in = resource.getInputStream();\n+\ttry\n+\t  {\n+\t    int length = resource.getLength();\n+\t    if (length != -1)\n+\t      {\n+\t\t// We know the length of the data.\n+\t\t// Just try to read it in all at once\n+\t\tdata = new byte[length];\n+\t\tint pos = 0;\n+\t\twhile (length - pos > 0)\n+\t\t  {\n+\t\t    int len = in.read(data, pos, length - pos);\n+\t\t    if (len == -1)\n+\t\t      throw new EOFException(\"Not enough data reading from: \"\n+\t\t\t\t\t     + in);\n+\t\t    pos += len;\n+\t\t  }\n+\t      }\n+\t    else\n+\t      {\n+\t\t// We don't know the data length.\n+\t\t// Have to read it in chunks.\n+\t\tByteArrayOutputStream out = new ByteArrayOutputStream(4096);\n+\t\tbyte[] b = new byte[4096];\n+\t\tint l = 0;\n+\t\twhile (l != -1)\n+\t\t  {\n+\t\t    l = in.read(b);\n+\t\t    if (l != -1)\n+\t\t      out.write(b, 0, l);\n+\t\t  }\n+\t\tdata = out.toByteArray();\n+\t      }\n+\t  }\n+\tfinally\n+\t  {\n+\t    in.close();\n+\t  }\n+\tfinal byte[] classData = data;\n \n         // Now get the CodeSource\n         final CodeSource source = resource.getCodeSource();"}, {"sha": "a8a093925049ba96a5b63e218499c62511c26634", "filename": "libjava/classpath/java/security/ProtectionDomain.java", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjava%2Fsecurity%2FProtectionDomain.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjava%2Fsecurity%2FProtectionDomain.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fsecurity%2FProtectionDomain.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -37,6 +37,8 @@\n \n package java.security;\n \n+import gnu.classpath.SystemProperties;\n+\n /**\n  * <p>This <code>ProtectionDomain</code> class encapsulates the characteristics\n  * of a domain, which encloses a set of classes whose instances are granted a\n@@ -222,7 +224,7 @@ public boolean implies(Permission permission)\n    */\n   public String toString()\n   {\n-    String linesep = System.getProperty(\"line.separator\");\n+    String linesep = SystemProperties.getProperty(\"line.separator\");\n     StringBuffer sb = new StringBuffer(\"ProtectionDomain (\").append(linesep);\n \n     if (code_source == null)"}, {"sha": "e90c451891eef3c30d72c68ed21f030c79c039e7", "filename": "libjava/classpath/javax/swing/JApplet.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2FJApplet.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2FJApplet.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJApplet.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -189,7 +189,7 @@ public void setJMenuBar(JMenuBar menubar)\n \n   protected String paramString()\n   {\n-    return \"JFrame\";\n+    return super.paramString();\n   }\n \n   protected void processKeyEvent(KeyEvent e)"}, {"sha": "deb08c5db5928d3fe9f6a5d68540ec8ac4210b9e", "filename": "libjava/classpath/javax/swing/JComponent.java", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2FJComponent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2FJComponent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJComponent.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -1918,9 +1918,15 @@ void paintDoubleBuffered(Graphics g)\n     g2 = getComponentGraphics(g2);\n     g2.setClip(r.x, r.y, r.width, r.height);\n     isPaintingDoubleBuffered = true;\n-    paint(g2);\n-    isPaintingDoubleBuffered = false;\n-    g2.dispose();\n+    try\n+      {\n+        paint(g2);\n+      }\n+    finally\n+      {\n+        isPaintingDoubleBuffered = false;\n+        g2.dispose();\n+      }\n     \n     // Paint the buffer contents on screen.\n     g.drawImage(buffer, 0, 0, this);\n@@ -2921,8 +2927,7 @@ public void removeNotify()\n   {\n     super.removeNotify();\n \n-    // FIXME: remove the WHEN_IN_FOCUSED_WINDOW bindings from the \n-    // KeyboardManager\n+    KeyboardManager.getManager().clearBindingsForComp(this);\n     \n     // Notify ancestor listeners.\n     fireAncestorEvent(this, AncestorEvent.ANCESTOR_REMOVED);"}, {"sha": "39f7c1f142f0add747ae2bfcb751fe470bf6c18d", "filename": "libjava/classpath/javax/swing/JEditorPane.java", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2FJEditorPane.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2FJEditorPane.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJEditorPane.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -59,6 +59,9 @@\n import javax.swing.text.EditorKit;\n import javax.swing.text.Element;\n import javax.swing.text.JTextComponent;\n+import javax.swing.text.View;\n+import javax.swing.text.ViewFactory;\n+import javax.swing.text.WrappedPlainView;\n import javax.swing.text.html.HTML;\n import javax.swing.text.html.HTMLDocument;\n import javax.swing.text.html.HTMLEditorKit;\n@@ -466,6 +469,30 @@ public String getLinkText(int i)\n     }\n   }\n \n+  /**\n+   * An EditorKit used for plain text. This is the default editor kit for\n+   * JEditorPanes.\n+   *\n+   * @author Roman Kennke (kennke@aicas.com)\n+   */\n+  private static class PlainEditorKit extends DefaultEditorKit\n+  {\n+\n+    /**\n+     * Returns a ViewFactory that supplies WrappedPlainViews.\n+     */\n+    public ViewFactory getViewFactory()\n+    {\n+      return new ViewFactory()\n+      {\n+        public View create(Element el)\n+        {\n+          return new WrappedPlainView(el);\n+        }\n+      };\n+    }\n+  }\n+\n   private static final long serialVersionUID = 3140472492599046285L;\n   \n   private URL page;\n@@ -497,12 +524,12 @@ public JEditorPane(URL url) throws IOException\n \n   protected EditorKit createDefaultEditorKit()\n   {\n-    return new DefaultEditorKit();\n+    return new PlainEditorKit();\n   }\n \n   public static EditorKit createEditorKitForContentType(String type)\n   {\n-    return new DefaultEditorKit();\n+    return new PlainEditorKit();\n   }\n \n   /**"}, {"sha": "caa7f310ea80542250c1f1de6fdf880a5b5d6719", "filename": "libjava/classpath/javax/swing/JList.java", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2FJList.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2FJList.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJList.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -1322,7 +1322,11 @@ public int getFirstVisibleIndex()\n \n \n   /**\n-   * Returns index of the cell to which specified location is closest to\n+   * Returns index of the cell to which specified location is closest to. If\n+   * the location is outside the bounds of the list, then the greatest index\n+   * in the list model is returned. If the list model is empty, then\n+   * <code>-1</code> is returned.\n+   *\n    * @param location for which to look for in the list\n    * \n    * @return index of the cell to which specified location is closest to."}, {"sha": "369c44d40c66695edc3c86449e46b83b92d7da26", "filename": "libjava/classpath/javax/swing/JMenu.java", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2FJMenu.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2FJMenu.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJMenu.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -96,6 +96,7 @@ public class JMenu extends JMenuItem implements Accessible, MenuElement\n   public JMenu()\n   {\n     super();\n+    setOpaque(false);\n   }\n \n   /**\n@@ -107,6 +108,7 @@ public JMenu(String text)\n   {\n     super(text);\n     popupMenu.setInvoker(this);\n+    setOpaque(false);\n   }\n \n   /**\n@@ -120,6 +122,7 @@ public JMenu(Action action)\n     super(action);\n     createActionChangeListener(this);\n     popupMenu.setInvoker(this);\n+    setOpaque(false);\n   }\n \n   /**"}, {"sha": "c02a9cfad6fe7644d162425fe8acabbf48df5a24", "filename": "libjava/classpath/javax/swing/JPanel.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2FJPanel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2FJPanel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJPanel.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -137,6 +137,6 @@ public AccessibleContext getAccessibleContext()\n     \n   protected  String paramString()\n   {\n-\treturn \"JPanel\";\n+\treturn super.paramString();\n   }\n }"}, {"sha": "70feefab26e96511282c3e43459578a2dc044b89", "filename": "libjava/classpath/javax/swing/JSplitPane.java", "status": "modified", "additions": 64, "deletions": 56, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2FJSplitPane.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2FJSplitPane.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJSplitPane.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -170,13 +170,15 @@ public Number getMaximumAccessibleValue()\n   public static final int HORIZONTAL_SPLIT = 1;\n \n   /** The property fired when the last divider location property changes. */\n-  public static final String LAST_DIVIDER_LOCATION_PROPERTY = \"lastDividerLocation\";\n+  public static final String LAST_DIVIDER_LOCATION_PROPERTY = \n+    \"lastDividerLocation\";\n \n   /** The constraints string used to add components to the left. */\n   public static final String LEFT = \"left\";\n \n   /** The property fired when the one touch expandable property changes. */\n-  public static final String ONE_TOUCH_EXPANDABLE_PROPERTY = \"oneTouchExpandable\";\n+  public static final String ONE_TOUCH_EXPANDABLE_PROPERTY = \n+    \"oneTouchExpandable\";\n \n   /** The property fired when the orientation property changes. */\n   public static final String ORIENTATION_PROPERTY = \"orientation\";\n@@ -199,7 +201,8 @@ public Number getMaximumAccessibleValue()\n   /** Whether the JSplitPane uses one touch expandable buttons. */\n   protected boolean oneTouchExpandable = false;\n \n-  // This is the master dividerSize variable and sets the BasicSplitPaneDivider one accordingly\n+  // This is the master dividerSize variable and sets the \n+  // BasicSplitPaneDivider one accordingly\n \n   /** The size of the divider. */\n   protected int dividerSize = 10;\n@@ -286,7 +289,8 @@ public JSplitPane(int newOrientation)\n    */\n   public JSplitPane()\n   {\n-    this(HORIZONTAL_SPLIT, false, null, null);\n+    this(HORIZONTAL_SPLIT, false, new JButton(\"left button\"),\n+         new JButton(\"right button\"));\n   }\n \n   /**\n@@ -300,7 +304,8 @@ public JSplitPane()\n    * @param constraints The constraints string to use.\n    * @param index Where to place to component in the list of components.\n    *\n-   * @throws IllegalArgumentException When the constraints is not a known identifier.\n+   * @throws IllegalArgumentException When the constraints is not a known \n+   * identifier.\n    */\n   protected void addImpl(Component comp, Object constraints, int index)\n   {\n@@ -310,34 +315,35 @@ protected void addImpl(Component comp, Object constraints, int index)\n     int place;\n     if (constraints == null)\n       {\n-\tif (leftComponent == null)\n-\t  constraints = LEFT;\n-\telse if (rightComponent == null)\n-\t  constraints = RIGHT;\n+        if (leftComponent == null)\n+          constraints = LEFT;\n+        else if (rightComponent == null)\n+          constraints = RIGHT;\n       }\n \n     if (constraints instanceof String)\n       {\n-\tString placement = (String) constraints;\n-\n-\tif (placement.equals(BOTTOM) || placement.equals(RIGHT))\n-\t  {\n-\t    if (rightComponent != null)\n-\t\tremove(rightComponent);\n-\t    rightComponent = comp;\n-\t  }\n-\telse if (placement.equals(LEFT) || placement.equals(TOP))\n-\t  {\n-\t    if (leftComponent != null)\n-\t      remove(leftComponent);\n-\t    leftComponent = comp;\n-\t  }\n-\telse if (placement.equals(DIVIDER))\n-\t  constraints = null;\n-\telse\n-\t  throw new IllegalArgumentException(\"Constraints is not a known identifier.\");\n-\n-\tsuper.addImpl(comp, constraints, index);\n+        String placement = (String) constraints;\n+\n+        if (placement.equals(BOTTOM) || placement.equals(RIGHT))\n+          {\n+            if (rightComponent != null)\n+              remove(rightComponent);\n+            rightComponent = comp;\n+          }\n+        else if (placement.equals(LEFT) || placement.equals(TOP))\n+          {\n+            if (leftComponent != null)\n+              remove(leftComponent);\n+            leftComponent = comp;\n+          }\n+        else if (placement.equals(DIVIDER))\n+          constraints = null;\n+        else\n+          throw new \n+            IllegalArgumentException(\"Constraints is not a known identifier.\");\n+\n+        super.addImpl(comp, constraints, index);\n       }\n     invalidate();\n     layout();\n@@ -614,10 +620,10 @@ public void setContinuousLayout(boolean newContinuousLayout)\n   {\n     if (newContinuousLayout != continuousLayout)\n       {\n-\tboolean oldValue = continuousLayout;\n-\tcontinuousLayout = newContinuousLayout;\n-\tfirePropertyChange(CONTINUOUS_LAYOUT_PROPERTY, oldValue,\n-\t                   continuousLayout);\n+        boolean oldValue = continuousLayout;\n+        continuousLayout = newContinuousLayout;\n+        firePropertyChange(CONTINUOUS_LAYOUT_PROPERTY, oldValue,\n+                           continuousLayout);\n       }\n   }\n \n@@ -634,7 +640,8 @@ public void setContinuousLayout(boolean newContinuousLayout)\n   public void setDividerLocation(double proportionalLocation)\n   {\n     if (proportionalLocation > 1 || proportionalLocation < 0)\n-      throw new IllegalArgumentException(\"proportion has to be between 0 and 1.\");\n+      throw new IllegalArgumentException\n+        (\"proportion has to be between 0 and 1.\");\n \n     int max = (orientation == HORIZONTAL_SPLIT) ? getWidth() : getHeight();\n     setDividerLocation((int) (proportionalLocation * max));\n@@ -649,9 +656,9 @@ public void setDividerLocation(int location)\n   {\n     if (ui != null && location != getDividerLocation())\n       {\n-\tint oldLocation = getDividerLocation();\n-\t((SplitPaneUI) ui).setDividerLocation(this, location);\n-\tfirePropertyChange(DIVIDER_LOCATION_PROPERTY, oldLocation, location);\n+        int oldLocation = getDividerLocation();\n+        ((SplitPaneUI) ui).setDividerLocation(this, location);\n+        firePropertyChange(DIVIDER_LOCATION_PROPERTY, oldLocation, location);\n       }\n   }\n \n@@ -664,9 +671,9 @@ public void setDividerSize(int newSize)\n   {\n     if (newSize != dividerSize)\n       {\n-\tint oldSize = dividerSize;\n-\tdividerSize = newSize;\n-\tfirePropertyChange(DIVIDER_SIZE_PROPERTY, oldSize, dividerSize);\n+        int oldSize = dividerSize;\n+        dividerSize = newSize;\n+        firePropertyChange(DIVIDER_SIZE_PROPERTY, oldSize, dividerSize);\n       }\n   }\n \n@@ -683,10 +690,10 @@ public void setLastDividerLocation(int newLastLocation)\n   {\n     if (newLastLocation != lastDividerLocation)\n       {\n-\tint oldValue = lastDividerLocation;\n-\tlastDividerLocation = newLastLocation;\n-\tfirePropertyChange(LAST_DIVIDER_LOCATION_PROPERTY, oldValue,\n-\t                   lastDividerLocation);\n+        int oldValue = lastDividerLocation;\n+        lastDividerLocation = newLastLocation;\n+        firePropertyChange(LAST_DIVIDER_LOCATION_PROPERTY, oldValue,\n+                           lastDividerLocation);\n       }\n   }\n \n@@ -696,11 +703,11 @@ public void setLastDividerLocation(int newLastLocation)\n    * @param comp The left component.\n    */\n   public void setLeftComponent(Component comp)\n-  {\n+  {    \n     if (comp != null)\n       add(comp, LEFT);\n     else\n-      add(new JButton(\"left button\"), LEFT);\n+      remove (leftComponent);\n   }\n \n   /**\n@@ -715,10 +722,10 @@ public void setOneTouchExpandable(boolean newValue)\n   {\n     if (newValue != oneTouchExpandable)\n       {\n-\tboolean oldValue = oneTouchExpandable;\n-\toneTouchExpandable = newValue;\n-\tfirePropertyChange(ONE_TOUCH_EXPANDABLE_PROPERTY, oldValue,\n-\t                   oneTouchExpandable);\n+        boolean oldValue = oneTouchExpandable;\n+        oneTouchExpandable = newValue;\n+        firePropertyChange(ONE_TOUCH_EXPANDABLE_PROPERTY, oldValue,\n+                           oneTouchExpandable);\n       }\n   }\n \n@@ -732,13 +739,14 @@ public void setOneTouchExpandable(boolean newValue)\n   public void setOrientation(int orientation)\n   {\n     if (orientation != HORIZONTAL_SPLIT && orientation != VERTICAL_SPLIT)\n-      throw new IllegalArgumentException(\"orientation must be one of VERTICAL_SPLIT, HORIZONTAL_SPLIT\");\n+      throw new IllegalArgumentException\n+        (\"orientation must be one of VERTICAL_SPLIT, HORIZONTAL_SPLIT\");\n     if (orientation != this.orientation)\n       {\n-\tint oldOrientation = this.orientation;\n-\tthis.orientation = orientation;\n-\tfirePropertyChange(ORIENTATION_PROPERTY, oldOrientation,\n-\t                   this.orientation);\n+        int oldOrientation = this.orientation;\n+        this.orientation = orientation;\n+        firePropertyChange(ORIENTATION_PROPERTY, oldOrientation,\n+                           this.orientation);\n       }\n   }\n \n@@ -766,7 +774,7 @@ public void setRightComponent(Component comp)\n     if (comp != null)\n       add(comp, RIGHT);\n     else\n-\tadd(new JButton(\"right button\"), RIGHT);\n+      remove (rightComponent);\n   }\n \n   /**"}, {"sha": "a2aebd4ca684dbd6561fb75f3226d9eabf82080e", "filename": "libjava/classpath/javax/swing/JTextPane.java", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2FJTextPane.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2FJTextPane.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJTextPane.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -47,7 +47,9 @@\n import javax.swing.text.EditorKit;\n import javax.swing.text.Element;\n import javax.swing.text.MutableAttributeSet;\n+import javax.swing.text.SimpleAttributeSet;\n import javax.swing.text.Style;\n+import javax.swing.text.StyleConstants;\n import javax.swing.text.StyledDocument;\n import javax.swing.text.StyledEditorKit;\n \n@@ -192,9 +194,20 @@ public void replaceSelection(String content)\n    */\n   public void insertComponent(Component component)\n   {\n-    // TODO: One space must be inserted here with attributes set to indicate\n-    // that the component must be displayed here. Have to figure out the\n-    // attributes.\n+    SimpleAttributeSet atts = new SimpleAttributeSet();\n+    atts.addAttribute(StyleConstants.ComponentAttribute, component);\n+    atts.addAttribute(StyleConstants.NameAttribute,\n+                      StyleConstants.ComponentElementName);\n+    try\n+      {\n+        getDocument().insertString(getCaret().getDot(), \" \", atts);\n+      }\n+    catch (BadLocationException ex)\n+      {\n+        AssertionError err = new AssertionError(\"Unexpected bad location\");\n+        err.initCause(ex);\n+        throw err;\n+      }\n   }\n \n   /**\n@@ -204,9 +217,20 @@ public void insertComponent(Component component)\n    */\n   public void insertIcon(Icon icon)\n   {\n-    // TODO: One space must be inserted here with attributes set to indicate\n-    // that the icon must be displayed here. Have to figure out the\n-    // attributes.\n+    SimpleAttributeSet atts = new SimpleAttributeSet();\n+    atts.addAttribute(StyleConstants.IconAttribute, icon);\n+    atts.addAttribute(StyleConstants.NameAttribute,\n+                      StyleConstants.IconElementName);\n+    try\n+      {\n+        getDocument().insertString(getCaret().getDot(), \" \", atts);\n+      }\n+    catch (BadLocationException ex)\n+      {\n+        AssertionError err = new AssertionError(\"Unexpected bad location\");\n+        err.initCause(ex);\n+        throw err;\n+      }\n   }\n \n   /**"}, {"sha": "aa9524cfe570aad7f10dc16dfd2d6fd0209dc6cf", "filename": "libjava/classpath/javax/swing/KeyboardManager.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2FKeyboardManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2FKeyboardManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FKeyboardManager.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -53,7 +53,7 @@\n  * Components register keyboard actions with the condition\n  * JComponent.WHEN_IN_FOCUSED_WINDOW.\n  * \n- * @author Anthony Balkissoon <abalkiss@redhat.com>\n+ * @author Anthony Balkissoon abalkiss at redhat dot com\n  *\n  */\n class KeyboardManager"}, {"sha": "289149fb603e9c6a60acbb17d9e4bea1f816f542", "filename": "libjava/classpath/javax/swing/ToolTipManager.java", "status": "modified", "additions": 39, "deletions": 109, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2FToolTipManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2FToolTipManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FToolTipManager.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -173,18 +173,9 @@ public void actionPerformed(ActionEvent event)\n \n   /** The last known position of the mouse cursor. */\n   private static Point currentPoint;\n-\n-  /**\n-   * The panel that holds the tooltip when the tooltip is displayed fully\n-   * inside the current container.\n-   */\n-  private static Container containerPanel;\n-\n-  /**\n-   * The window used when the tooltip doesn't fit inside the current\n-   * container.\n-   */\n-  private static JDialog tooltipWindow;\n+  \n+  /**  */\n+  private static Popup popup;\n \n   /**\n    * Creates a new ToolTipManager and sets up the timers.\n@@ -369,26 +360,27 @@ public void mouseEntered(MouseEvent event)\n         && getContentPaneDeepestComponent(event) == currentComponent)\n       return;\n     currentPoint = event.getPoint();\n+\n     currentComponent = (Component) event.getSource();\n \n     if (exitTimer.isRunning())\n       {\n-\texitTimer.stop();\n-\tinsideTimer.start();\n-\treturn;\n+        exitTimer.stop();\n+        showTip();\n+        return;\n       }\n-\n     // This should always be stopped unless we have just fake-exited.\n-    if (! enterTimer.isRunning())\n+    if (!enterTimer.isRunning())\n       enterTimer.start();\n   }\n \n   /**\n-   * This method is called when the mouse exits a JComponent registered with\n-   * the ToolTipManager. When the mouse exits, the tooltip should be hidden\n+   * This method is called when the mouse exits a JComponent registered with the\n+   * ToolTipManager. When the mouse exits, the tooltip should be hidden\n    * immediately.\n-   *\n-   * @param event The MouseEvent.\n+   * \n+   * @param event\n+   *          The MouseEvent.\n    */\n   public void mouseExited(MouseEvent event)\n   {\n@@ -399,7 +391,7 @@ public void mouseExited(MouseEvent event)\n     currentComponent = null;\n     hideTip();\n \n-    if (! enterTimer.isRunning() && insideTimer.isRunning())\n+    if (! enterTimer.isRunning())\n       exitTimer.start();\n     if (enterTimer.isRunning())\n       enterTimer.stop();\n@@ -460,77 +452,36 @@ public void mouseMoved(MouseEvent event)\n   void showTip()\n   {\n     if (!enabled || currentComponent == null || !currentComponent.isEnabled()\n-        || (currentTip != null && currentTip.isVisible()))\n-      return;\n+        || !currentComponent.isShowing())\n+      {\n+        popup = null;\n+        return;\n+      }\n \n     if (currentTip == null || currentTip.getComponent() != currentComponent\n         && currentComponent instanceof JComponent)\n       currentTip = ((JComponent) currentComponent).createToolTip();\n \n-    currentTip.setVisible(true);\n-    Container parent = currentComponent.getParent();\n     Point p = currentPoint;\n+    Point cP = currentComponent.getLocationOnScreen();\n     Dimension dims = currentTip.getPreferredSize();\n     \n-    if (parent instanceof JPopupMenu)\n-        setLightWeightPopupEnabled(((JPopupMenu) parent).isLightWeightPopupEnabled());\n-    else\n-      setLightWeightPopupEnabled(true);\n-           \n-    if (isLightWeightPopupEnabled())\n-      {\n-        JLayeredPane pane = null;\n-        JRootPane r = ((JRootPane) SwingUtilities.\n-            getAncestorOfClass(JRootPane.class, currentComponent));\n-        if (r != null)\n-          pane = r.getLayeredPane();\n-        if (pane == null)\n-          return;\n-        \n-        if (containerPanel != null)\n-          hideTip();\n-        \n-        containerPanel = new Panel();\n-        JRootPane root = new JRootPane();\n-        root.getContentPane().add(currentTip);\n-        containerPanel.add(root);\n-\n-        LayoutManager lm = containerPanel.getLayout();\n-        if (lm instanceof FlowLayout)\n-          {\n-            FlowLayout fm = (FlowLayout) lm;\n-            fm.setVgap(0);\n-            fm.setHgap(0);\n-          }\n-\n-        p = SwingUtilities.convertPoint(currentComponent, p, pane);\n-        p = adjustLocation(p, pane, dims);\n-        \n-        pane.add(containerPanel);\n-        containerPanel.setBounds(p.x, p.y, dims.width, dims.height);\n-        currentTip.setBounds(0, 0, dims.width, dims.height);\n-        containerPanel.validate();\n-        containerPanel.repaint();\n-      }\n-    else if (currentComponent.isShowing())\n-      {        \n-        SwingUtilities.convertPointToScreen(p, currentComponent);\n-        p = adjustLocation(p, SwingUtilities.getWindowAncestor(currentComponent), \n-                           dims);\n-        \n-        tooltipWindow = new JDialog();\n-        tooltipWindow.setContentPane(currentTip);\n-        tooltipWindow.setUndecorated(true);\n-        tooltipWindow.getRootPane().\n-                setWindowDecorationStyle(JRootPane.PLAIN_DIALOG);\n-        tooltipWindow.pack();\n-        tooltipWindow.setBounds(p.x, p.y, dims.width, dims.height);\n-        tooltipWindow.show();\n-        tooltipWindow.validate();\n-        tooltipWindow.repaint();\n-        currentTip.revalidate();\n-        currentTip.repaint();\n-      }\n+    JLayeredPane pane = null;\n+    JRootPane r = ((JRootPane) SwingUtilities.getAncestorOfClass(JRootPane.class,\n+                                                                 currentComponent));\n+    if (r != null)\n+      pane = r.getLayeredPane();\n+    if (pane == null)\n+      return;\n+    \n+    p.translate(cP.x, cP.y);\n+    adjustLocation(p, pane, dims);\n+    \n+    currentTip.setBounds(0, 0, dims.width, dims.height);\n+    \n+    PopupFactory factory = PopupFactory.getSharedInstance();\n+    popup = factory.getPopup(currentComponent, currentTip, p.x, p.y);\n+    popup.show();\n   }\n \n   /**\n@@ -550,7 +501,7 @@ private Point adjustLocation(Point p, Component c, Dimension d)\n     if (p.y + d.height < c.getHeight())\n       p.y += d.height;\n     if (p.y + d.height > c.getHeight())\n-      p.y -= d.height*2;\n+      p.y -= d.height;\n     \n     return p;\n   }\n@@ -561,29 +512,8 @@ private Point adjustLocation(Point p, Component c, Dimension d)\n    */\n   void hideTip()\n   {\n-    if (currentTip == null || ! currentTip.isVisible() || ! enabled)\n-      return;\n-    currentTip.setVisible(false);\n-    if (containerPanel != null)\n-      {\n-\tContainer parent = containerPanel.getParent();\n-\tif (parent == null)\n-\t  return;\n-\tparent.remove(containerPanel);\n-\n-\tparent = currentTip.getParent();\n-\tif (parent == null)\n-\t  return;\n-\tparent.remove(currentTip);\n-\tcontainerPanel = null;\n-      }\n-    if (tooltipWindow != null)\n-      {\n-\ttooltipWindow.hide();\n-\ttooltipWindow.dispose();\n-\ttooltipWindow = null;\n-      }\n-    currentTip = null;\n+    if (popup != null)\n+      popup.hide();\n   }\n \n   /**"}, {"sha": "fbf1c7c79cbea3e28f22b3cb8c19abef73c8ff51", "filename": "libjava/classpath/javax/swing/UIManager.java", "status": "modified", "additions": 55, "deletions": 23, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2FUIManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2FUIManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FUIManager.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -132,6 +132,11 @@ public String toString()\n   \n   static UIDefaults currentUIDefaults;\n \n+  /**\n+   * UIDefaults set by the user.\n+   */\n+  static UIDefaults userUIDefaults;\n+\n   /** Property change listener mechanism. */\n   static SwingPropertyChangeSupport listeners \n       = new SwingPropertyChangeSupport(UIManager.class);\n@@ -305,7 +310,12 @@ public static LookAndFeel[] getAuxiliaryLookAndFeels()\n    */\n   public static Object get(Object key)\n   {\n-    return getLookAndFeelDefaults().get(key);\n+    Object val = null;\n+    if (userUIDefaults != null)\n+      val = userUIDefaults.get(key);\n+    if (val == null)\n+      val = getLookAndFeelDefaults().get(key);\n+    return val;\n   }\n \n   /**\n@@ -318,7 +328,12 @@ public static Object get(Object key)\n    */\n   public static Object get(Object key, Locale locale)\n   {\n-    return getLookAndFeelDefaults().get(key ,locale);\n+    Object val = null;\n+    if (userUIDefaults != null)\n+      val = userUIDefaults.get(key, locale);\n+    if (val == null)\n+      val = getLookAndFeelDefaults().get(key, locale);\n+    return val;\n   }\n \n   /**\n@@ -329,7 +344,7 @@ public static Object get(Object key, Locale locale)\n    */\n   public static boolean getBoolean(Object key)\n   {\n-    Boolean value = (Boolean) getLookAndFeelDefaults().get(key);\n+    Boolean value = (Boolean) get(key);\n     return value != null ? value.booleanValue() : false;\n   }\n   \n@@ -341,7 +356,7 @@ public static boolean getBoolean(Object key)\n    */\n   public static boolean getBoolean(Object key, Locale locale)\n   {\n-    Boolean value = (Boolean) getLookAndFeelDefaults().get(key, locale);\n+    Boolean value = (Boolean) get(key, locale);\n     return value != null ? value.booleanValue() : false;\n   }\n     \n@@ -350,7 +365,7 @@ public static boolean getBoolean(Object key, Locale locale)\n    */\n   public static Border getBorder(Object key)\n   {\n-    return (Border) getLookAndFeelDefaults().get(key);\n+    return (Border) get(key);\n   }\n     \n   /**\n@@ -360,23 +375,23 @@ public static Border getBorder(Object key)\n    */\n   public static Border getBorder(Object key, Locale locale)\n   {\n-    return (Border) getLookAndFeelDefaults().get(key, locale);\n+    return (Border) get(key, locale);\n   }\n     \n   /**\n    * Returns a drawing color from the defaults table. \n    */\n   public static Color getColor(Object key)\n   {\n-    return (Color) getLookAndFeelDefaults().get(key);\n+    return (Color) get(key);\n   }\n \n   /**\n    * Returns a drawing color from the defaults table. \n    */\n   public static Color getColor(Object key, Locale locale)\n   {\n-    return (Color) getLookAndFeelDefaults().get(key);\n+    return (Color) get(key);\n   }\n \n   /**\n@@ -405,15 +420,15 @@ public static UIDefaults getDefaults()\n    */\n   public static Dimension getDimension(Object key)\n   {\n-    return (Dimension) getLookAndFeelDefaults().get(key);\n+    return (Dimension) get(key);\n   }\n \n   /**\n    * Returns a dimension from the defaults table. \n    */\n   public static Dimension getDimension(Object key, Locale locale)\n   {\n-    return (Dimension) getLookAndFeelDefaults().get(key, locale);\n+    return (Dimension) get(key, locale);\n   }\n \n   /**\n@@ -426,7 +441,7 @@ public static Dimension getDimension(Object key, Locale locale)\n    */\n   public static Font getFont(Object key)\n   {\n-    return (Font) getLookAndFeelDefaults().get(key);\n+    return (Font) get(key);\n   }\n \n   /**\n@@ -439,39 +454,47 @@ public static Font getFont(Object key)\n    */\n   public static Font getFont(Object key, Locale locale)\n   {\n-    return (Font) getLookAndFeelDefaults().get(key ,locale);\n+    return (Font) get(key ,locale);\n   }\n \n   /**\n    * Returns an Icon from the defaults table.\n    */\n   public static Icon getIcon(Object key)\n   {\n-    return (Icon) getLookAndFeelDefaults().get(key);\n+    return (Icon) get(key);\n   }\n   \n   /**\n    * Returns an Icon from the defaults table.\n    */\n   public static Icon getIcon(Object key, Locale locale)\n   {\n-    return (Icon) getLookAndFeelDefaults().get(key, locale);\n+    return (Icon) get(key, locale);\n   }\n   \n   /**\n    * Returns an Insets object from the defaults table.\n    */\n   public static Insets getInsets(Object key)\n   {\n-    return getLookAndFeelDefaults().getInsets(key);\n+    Object o = get(key);\n+    if (o instanceof Insets)\n+      return (Insets) o;\n+    else\n+      return null;\n   }\n \n   /**\n    * Returns an Insets object from the defaults table.\n    */\n   public static Insets getInsets(Object key, Locale locale)\n   {\n-    return getLookAndFeelDefaults().getInsets(key, locale);\n+    Object o = get(key, locale);\n+    if (o instanceof Insets)\n+      return (Insets) o;\n+    else\n+      return null;\n   }\n \n   /**\n@@ -487,15 +510,15 @@ public static LookAndFeelInfo[] getInstalledLookAndFeels()\n \n   public static int getInt(Object key)\n   {\n-    Integer x = (Integer) getLookAndFeelDefaults().get(key);\n+    Integer x = (Integer) get(key);\n     if (x == null)\n       return 0;\n     return x.intValue();\n   }\n \n   public static int getInt(Object key, Locale locale)\n   {\n-    Integer x = (Integer) getLookAndFeelDefaults().get(key, locale);\n+    Integer x = (Integer) get(key, locale);\n     if (x == null)\n       return 0;\n     return x.intValue();\n@@ -529,15 +552,15 @@ public static UIDefaults getLookAndFeelDefaults()\n    */\n   public static String getString(Object key)\n   {\n-    return (String) getLookAndFeelDefaults().get(key);\n+    return (String) get(key);\n   }\n   \n   /**\n    * Returns a string from the defaults table.\n    */\n   public static String getString(Object key, Locale locale)\n   {\n-    return (String) getLookAndFeelDefaults().get(key, locale);\n+    return (String) get(key, locale);\n   }\n   \n   /**\n@@ -562,7 +585,13 @@ public static String getSystemLookAndFeelClassName()\n    */\n   public static ComponentUI getUI(JComponent target)\n   {\n-    return getLookAndFeelDefaults().getUI(target);\n+    ComponentUI ui = null;\n+    if (userUIDefaults != null\n+        && userUIDefaults.get(target.getUIClassID()) != null)\n+      ui = userUIDefaults.getUI(target);\n+    if (ui == null)\n+      ui = currentUIDefaults.getUI(target);\n+    return ui;\n   }\n \n   /**\n@@ -591,7 +620,11 @@ public static void installLookAndFeel(LookAndFeelInfo info)\n    */\n   public static Object put(Object key, Object value)\n   {\n-    return getLookAndFeelDefaults().put(key,value);\n+    Object old = get(key);\n+    if (userUIDefaults == null)\n+      userUIDefaults = new UIDefaults();\n+    userUIDefaults.put(key, value);\n+    return old;\n   }\n \n   /**\n@@ -617,7 +650,6 @@ public static void setLookAndFeel(LookAndFeel newLookAndFeel)\n   {\n     if (newLookAndFeel != null && ! newLookAndFeel.isSupportedLookAndFeel())\n       throw new UnsupportedLookAndFeelException(newLookAndFeel.getName());\n-    \n     LookAndFeel oldLookAndFeel = currentLookAndFeel;\n     if (oldLookAndFeel != null)\n       oldLookAndFeel.uninitialize();"}, {"sha": "5d4ce18932b9772ad9f607f315cec414c3243ce9", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicBorders.java", "status": "modified", "additions": 27, "deletions": 52, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicBorders.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicBorders.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicBorders.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -51,7 +51,6 @@\n import javax.swing.JPopupMenu;\n import javax.swing.JSplitPane;\n import javax.swing.JToolBar;\n-import javax.swing.UIDefaults;\n import javax.swing.UIManager;\n import javax.swing.border.AbstractBorder;\n import javax.swing.border.BevelBorder;\n@@ -95,21 +94,18 @@\n    */\n   public static Border getButtonBorder()\n   {\n-    UIDefaults defaults;\n     Border outer;\n \n-    defaults = UIManager.getLookAndFeelDefaults();\n-\n     /* The keys for UIDefaults have been determined by writing a\n      * test program that dumps the UIDefaults to stdout; that program\n      * was run on a JDK 1.4.1_01 for GNU/Linux. Note that in the API,\n      * the key \"light\" is usually called \"highlight\", and \"highlight\"\n      * is usually called \"lightHighlight\".\n      */\n-    outer = new ButtonBorder(defaults.getColor(\"Button.shadow\"),\n-                             defaults.getColor(\"Button.darkShadow\"),\n-                             defaults.getColor(\"Button.light\"),\n-                             defaults.getColor(\"Button.highlight\"));\n+    outer = new ButtonBorder(UIManager.getColor(\"Button.shadow\"),\n+                             UIManager.getColor(\"Button.darkShadow\"),\n+                             UIManager.getColor(\"Button.light\"),\n+                             UIManager.getColor(\"Button.highlight\"));\n \n     /* While the inner border is shared between multiple buttons,\n      * we do not share the outer border because ButtonBorders store\n@@ -145,22 +141,19 @@ public static Border getButtonBorder()\n    */\n   public static Border getRadioButtonBorder()\n   {\n-    UIDefaults defaults;\n     Border outer;\n \n-    defaults = UIManager.getLookAndFeelDefaults();\n-\n     /* The keys for UIDefaults have been determined by writing a\n      * test program that dumps the UIDefaults to stdout; that program\n      * was run on a JDK 1.4.1_01 for GNU/Linux. Note that in the API,\n      * the key \"light\" is usually called \"highlight\", and \"highlight\"\n      * is usually called \"lightHighlight\".\n      */\n     outer = new RadioButtonBorder(\n-      defaults.getColor(\"RadioButton.shadow\"),\n-      defaults.getColor(\"RadioButton.darkShadow\"),\n-      defaults.getColor(\"RadioButton.light\"),\n-      defaults.getColor(\"RadioButton.highlight\"));\n+      UIManager.getColor(\"RadioButton.shadow\"),\n+      UIManager.getColor(\"RadioButton.darkShadow\"),\n+      UIManager.getColor(\"RadioButton.light\"),\n+      UIManager.getColor(\"RadioButton.highlight\"));\n \n     /* While the inner border is shared between multiple buttons, we\n      * do not share the outer border because RadioButtonBorders, being\n@@ -197,22 +190,19 @@ public static Border getRadioButtonBorder()\n    */\n   public static Border getToggleButtonBorder()\n   {\n-    UIDefaults defaults;\n     Border outer;\n \n-    defaults = UIManager.getLookAndFeelDefaults();\n-\n     /* The keys for UIDefaults have been determined by writing a\n      * test program that dumps the UIDefaults to stdout; that program\n      * was run on a JDK 1.4.1_01 for GNU/Linux. Note that in the API,\n      * the key \"light\" is usually called \"highlight\", and \"highlight\"\n      * is usually called \"lightHighlight\".\n      */\n     outer = new ToggleButtonBorder(\n-      defaults.getColor(\"ToggleButton.shadow\"),\n-      defaults.getColor(\"ToggleButton.darkShadow\"),\n-      defaults.getColor(\"ToggleButton.light\"),\n-      defaults.getColor(\"ToggleButton.highlight\"));\n+      UIManager.getColor(\"ToggleButton.shadow\"),\n+      UIManager.getColor(\"ToggleButton.darkShadow\"),\n+      UIManager.getColor(\"ToggleButton.light\"),\n+      UIManager.getColor(\"ToggleButton.highlight\"));\n \n     /* While the inner border is shared between multiple buttons, we\n      * do not share the outer border because ToggleButtonBorders, being\n@@ -247,12 +237,9 @@ public static Border getToggleButtonBorder()\n    */\n   public static Border getMenuBarBorder()\n   {\n-    UIDefaults defaults;\n-\n     /* See comment in methods above for why this border is not shared. */\n-    defaults = UIManager.getLookAndFeelDefaults();\n-    return new MenuBarBorder(defaults.getColor(\"MenuBar.shadow\"),\n-                             defaults.getColor(\"MenuBar.highlight\"));\n+    return new MenuBarBorder(UIManager.getColor(\"MenuBar.shadow\"),\n+                             UIManager.getColor(\"MenuBar.highlight\"));\n   }\n \n \n@@ -279,12 +266,9 @@ public static Border getMenuBarBorder()\n    */\n   public static Border getSplitPaneBorder()\n   {\n-    UIDefaults defaults;\n-\n     /* See comment in methods above for why this border is not shared. */\n-    defaults = UIManager.getLookAndFeelDefaults();\n-    return new SplitPaneBorder(defaults.getColor(\"SplitPane.highlight\"),\n-                               defaults.getColor(\"SplitPane.darkShadow\"));\n+    return new SplitPaneBorder(UIManager.getColor(\"SplitPane.highlight\"),\n+                               UIManager.getColor(\"SplitPane.darkShadow\"));\n   }\n \n \n@@ -314,13 +298,10 @@ public static Border getSplitPaneBorder()\n    */\n   public static Border getSplitPaneDividerBorder()\n   {\n-    UIDefaults defaults;\n-\n     /* See comment in methods above for why this border is not shared. */\n-    defaults = UIManager.getLookAndFeelDefaults();\n     return new SplitPaneDividerBorder(\n-      defaults.getColor(\"SplitPane.highlight\"),\n-      defaults.getColor(\"SplitPane.darkShadow\"));\n+      UIManager.getColor(\"SplitPane.highlight\"),\n+      UIManager.getColor(\"SplitPane.darkShadow\"));\n   }\n \n \n@@ -346,15 +327,12 @@ public static Border getSplitPaneDividerBorder()\n    */\n   public static Border getTextFieldBorder()\n   {\n-    UIDefaults defaults;\n-\n     /* See comment in methods above for why this border is not shared. */\n-    defaults = UIManager.getLookAndFeelDefaults();\n     return new FieldBorder(\n-      defaults.getColor(\"TextField.shadow\"),\n-      defaults.getColor(\"TextField.darkShadow\"),\n-      defaults.getColor(\"TextField.light\"),\n-      defaults.getColor(\"TextField.highlight\"));\n+      UIManager.getColor(\"TextField.shadow\"),\n+      UIManager.getColor(\"TextField.darkShadow\"),\n+      UIManager.getColor(\"TextField.light\"),\n+      UIManager.getColor(\"TextField.highlight\"));\n   }\n   \n \n@@ -394,17 +372,14 @@ public static Border getProgressBarBorder()\n    */\n   public static Border getInternalFrameBorder()\n   {\n-    UIDefaults defaults;\n     Color shadow, darkShadow, highlight, lightHighlight, line;\n \n     /* See comment in methods above for why this border is not shared. */\n-    defaults = UIManager.getLookAndFeelDefaults();\n-    \n-    shadow = defaults.getColor(\"InternalFrame.borderShadow\");\n-    darkShadow = defaults.getColor(\"InternalFrame.borderDarkShadow\");\n-    highlight = defaults.getColor(\"InternalFrame.borderLight\");\n-    lightHighlight = defaults.getColor(\"InternalFrame.borderHighlight\");\n-    line = defaults.getColor(\"InternalFrame.borderColor\");\n+    shadow = UIManager.getColor(\"InternalFrame.borderShadow\");\n+    darkShadow = UIManager.getColor(\"InternalFrame.borderDarkShadow\");\n+    highlight = UIManager.getColor(\"InternalFrame.borderLight\");\n+    lightHighlight = UIManager.getColor(\"InternalFrame.borderHighlight\");\n+    line = UIManager.getColor(\"InternalFrame.borderColor\");\n \n     return new BorderUIResource.CompoundBorderUIResource(\n       /* outer border */"}, {"sha": "7a63331b9c8f290b9afb74d48f2abbae4e8a0ce8", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicButtonUI.java", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicButtonUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicButtonUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicButtonUI.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -52,7 +52,6 @@\n import javax.swing.JComponent;\n import javax.swing.LookAndFeel;\n import javax.swing.SwingUtilities;\n-import javax.swing.UIDefaults;\n import javax.swing.UIManager;\n import javax.swing.plaf.ButtonUI;\n import javax.swing.plaf.ComponentUI;\n@@ -161,7 +160,6 @@ protected void installDefaults(AbstractButton b)\n     b.setIconTextGap(UIManager.getInt(prefix + \"textIconGap\"));\n     b.setInputMap(JComponent.WHEN_FOCUSED, \n                   (InputMap) UIManager.get(prefix + \"focusInputMap\"));\n-    b.setRolloverEnabled(UIManager.getBoolean(prefix + \"rollover\"));\n   }\n \n   /**\n@@ -444,9 +442,8 @@ protected void paintText(Graphics g, AbstractButton b, Rectangle textRect,\n       }\n     else\n       {\n-        UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n         String prefix = getPropertyPrefix();\n-        g.setColor(defaults.getColor(prefix + \"disabledText\"));\n+        g.setColor(UIManager.getColor(prefix + \"disabledText\"));\n         g.drawString(text, textRect.x, textRect.y + fm.getAscent());\n       }\n   } "}, {"sha": "14dadb85cf91f4ee41be8f3e27c38a38084e5885", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicCheckBoxUI.java", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicCheckBoxUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicCheckBoxUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicCheckBoxUI.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -40,7 +40,6 @@\n \n import javax.swing.Icon;\n import javax.swing.JComponent;\n-import javax.swing.UIDefaults;\n import javax.swing.UIManager;\n import javax.swing.plaf.ComponentUI;\n \n@@ -53,12 +52,11 @@ public static ComponentUI createUI(final JComponent c)  {\n \n   public Icon getDefaultIcon()\n   {\n-    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n-    return defaults.getIcon(\"CheckBox.icon\");\n+    return UIManager.getIcon(\"CheckBox.icon\");\n   }\n   \n   /**\n-   * Returns the prefix for entries in the {@link UIDefaults} table.\n+   * Returns the prefix for entries in the {@link UIManager} defaults table.\n    *\n    * @return \"CheckBox.\"\n    */"}, {"sha": "b22aa15f901d6c34632024a33ff978c2b400c593", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicComboBoxUI.java", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicComboBoxUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicComboBoxUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicComboBoxUI.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -805,10 +805,10 @@ public void paintCurrentValue(Graphics g, Rectangle bounds, boolean hasFocus)\n                 isPressed, hasFocus);\n         if (! comboBox.isEnabled())\n           {\n-            comp.setBackground(UIManager.getLookAndFeelDefaults().getColor(\n-                \"ComboBox.disabledBackground\"));\n-            comp.setForeground(UIManager.getLookAndFeelDefaults().getColor(\n-                \"ComboBox.disabledForeground\"));\n+            comp.setBackground(UIManager.getColor(\n+                                               \"ComboBox.disabledBackground\"));\n+            comp.setForeground(UIManager.getColor(\n+                                               \"ComboBox.disabledForeground\"));\n             comp.setEnabled(false);\n           }\n         comp.setBounds(0, 0, bounds.width, bounds.height);"}, {"sha": "d514a87c8ee46ff43509c1b76cfdf41806bc254e", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicEditorPaneUI.java", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicEditorPaneUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicEditorPaneUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicEditorPaneUI.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -42,10 +42,7 @@\n import javax.swing.JEditorPane;\n import javax.swing.plaf.ComponentUI;\n import javax.swing.text.EditorKit;\n-import javax.swing.text.Element;\n import javax.swing.text.JTextComponent;\n-import javax.swing.text.PlainView;\n-import javax.swing.text.View;\n \n /**\n  * The UI class for  {@link JEditorPane}s.\n@@ -76,14 +73,6 @@ public BasicEditorPaneUI()\n     // Do nothing here.\n   }\n \n-  // FIXME: Should not be overridden here but instead be handled by the\n-  // JEditorPane's EditorKit. However, as long as we don't have styles in\n-  // place this doesn't make much sense.\n-  public View create(Element elem)\n-  {\n-    return new PlainView(elem);\n-  }\n-\n   /**\n    * Returns the property prefix to be used by this UI class. This is\n    * <code>EditorPane</code> in this case."}, {"sha": "60179dc0706e22c60260c93ec4f96395fdf258e3", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicFileChooserUI.java", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicFileChooserUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicFileChooserUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicFileChooserUI.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -79,7 +79,6 @@\n import javax.swing.SwingConstants;\n import javax.swing.SwingUtilities;\n import javax.swing.Timer;\n-import javax.swing.UIDefaults;\n import javax.swing.UIManager;\n import javax.swing.event.ListSelectionEvent;\n import javax.swing.event.ListSelectionListener;\n@@ -1429,27 +1428,25 @@ protected void uninstallIcons(JFileChooser fc)\n    */\n   protected void installStrings(JFileChooser fc)\n   {\n-    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n+    acceptAllFileFilterText = UIManager.getString(\"FileChooser.acceptAllFileFilterText\");\n+    cancelButtonMnemonic = UIManager.getInt(\"FileChooser.cancelButtonMnemonic\");\n+    cancelButtonText = UIManager.getString(\"FileChooser.cancelButtonText\");\n+    cancelButtonToolTipText = UIManager.getString(\"FileChooser.cancelButtonToolTipText\");\n \n-    acceptAllFileFilterText = defaults.getString(\"FileChooser.acceptAllFileFilterText\");\n-    cancelButtonMnemonic = defaults.getInt(\"FileChooser.cancelButtonMnemonic\");\n-    cancelButtonText = defaults.getString(\"FileChooser.cancelButtonText\");\n-    cancelButtonToolTipText = defaults.getString(\"FileChooser.cancelButtonToolTipText\");\n+    dirDescText = UIManager.getString(\"FileChooser.directoryDescriptionText\");\n+    fileDescText = UIManager.getString(\"FileChooser.fileDescriptionText\");\n \n-    dirDescText = defaults.getString(\"FileChooser.directoryDescriptionText\");\n-    fileDescText = defaults.getString(\"FileChooser.fileDescriptionText\");\n+    helpButtonMnemonic = UIManager.getInt(\"FileChooser.helpButtonMnemonic\");\n+    helpButtonText = UIManager.getString(\"FileChooser.helpButtonText\");\n+    helpButtonToolTipText = UIManager.getString(\"FileChooser.helpButtonToolTipText\");\n \n-    helpButtonMnemonic = defaults.getInt(\"FileChooser.helpButtonMnemonic\");\n-    helpButtonText = defaults.getString(\"FileChooser.helpButtonText\");\n-    helpButtonToolTipText = defaults.getString(\"FileChooser.helpButtonToolTipText\");\n+    openButtonMnemonic = UIManager.getInt(\"FileChooser.openButtonMnemonic\");\n+    openButtonText = UIManager.getString(\"FileChooser.openButtonText\");\n+    openButtonToolTipText = UIManager.getString(\"FileChooser.openButtonToolTipText\");\n \n-    openButtonMnemonic = defaults.getInt(\"FileChooser.openButtonMnemonic\");\n-    openButtonText = defaults.getString(\"FileChooser.openButtonText\");\n-    openButtonToolTipText = defaults.getString(\"FileChooser.openButtonToolTipText\");\n-\n-    saveButtonMnemonic = defaults.getInt(\"FileChooser.saveButtonMnemonic\");\n-    saveButtonText = defaults.getString(\"FileChooser.saveButtonText\");\n-    saveButtonToolTipText = defaults.getString(\"FileChooser.saveButtonToolTipText\");\n+    saveButtonMnemonic = UIManager.getInt(\"FileChooser.saveButtonMnemonic\");\n+    saveButtonText = UIManager.getString(\"FileChooser.saveButtonText\");\n+    saveButtonToolTipText = UIManager.getString(\"FileChooser.saveButtonToolTipText\");\n   }\n \n   /**"}, {"sha": "56022f3331e56e6b912c00f0f384b2bbb4961f8e", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicInternalFrameTitlePane.java", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicInternalFrameTitlePane.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicInternalFrameTitlePane.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicInternalFrameTitlePane.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -66,7 +66,6 @@\n import javax.swing.JMenuItem;\n import javax.swing.SwingConstants;\n import javax.swing.SwingUtilities;\n-import javax.swing.UIDefaults;\n import javax.swing.UIManager;\n \n /**\n@@ -718,13 +717,11 @@ protected void uninstallListeners()\n    */\n   protected void installDefaults()\n   {\n-    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n-\n-    title.setFont(defaults.getFont(\"InternalFrame.titleFont\"));\n-    selectedTextColor = defaults.getColor(\"InternalFrame.activeTitleForeground\");\n-    selectedTitleColor = defaults.getColor(\"InternalFrame.activeTitleBackground\");\n-    notSelectedTextColor = defaults.getColor(\"InternalFrame.inactiveTitleForeground\");\n-    notSelectedTitleColor = defaults.getColor(\"InternalFrame.inactiveTitleBackground\");\n+    title.setFont(UIManager.getFont(\"InternalFrame.titleFont\"));\n+    selectedTextColor = UIManager.getColor(\"InternalFrame.activeTitleForeground\");\n+    selectedTitleColor = UIManager.getColor(\"InternalFrame.activeTitleBackground\");\n+    notSelectedTextColor = UIManager.getColor(\"InternalFrame.inactiveTitleForeground\");\n+    notSelectedTitleColor = UIManager.getColor(\"InternalFrame.inactiveTitleBackground\");\n   \n     closeIcon = UIManager.getIcon(\"InternalFrame.closeIcon\");\n     iconIcon = UIManager.getIcon(\"InternalFrame.iconifyIcon\");\n@@ -901,6 +898,9 @@ public void paintComponent(Graphics g)\n    */\n   protected void paintTitleBackground(Graphics g)\n   {\n+    if (!isOpaque())\n+      return;\n+\n     Color saved = g.getColor();\n     Dimension dims = getSize();\n "}, {"sha": "2d66645fb7d5b1ec4e77c09c50e2afc042e997e5", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicListUI.java", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicListUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicListUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicListUI.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -703,12 +703,17 @@ public static ComponentUI createUI(final JComponent c)\n    */\n   protected int getRowHeight(int row)\n   {\n-    if (row < 0 || row >= cellHeights.length)\n-      return -1;\n-    else if (cellHeight != -1)\n-      return cellHeight;\n+    int height;\n+    if (cellHeights == null)\n+      height = cellHeight;\n     else\n-      return cellHeights[row];\n+      {\n+        if (row < 0 || row >= cellHeights.length)\n+          height = -1;\n+        else\n+          height = cellHeights[row];\n+      }\n+    return height;\n   }\n \n   /**\n@@ -803,9 +808,7 @@ protected int convertYToRow(int y0)\n \n     // If a fixed cell height is set, then we can work more efficient.\n     if (cellHeight > 0)\n-      {\n-        index = Math.max(y0 / cellHeight, index);\n-      }\n+      index = Math.min(y0 / cellHeight, index);\n     // If we have no fixed cell height, we must add up each cell height up\n     // to y0.\n     else\n@@ -992,8 +995,7 @@ protected void uninstallListeners()\n    */\n   protected void installKeyboardActions()\n   {\n-    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n-    InputMap focusInputMap = (InputMap)defaults.get(\"List.focusInputMap\");\n+    InputMap focusInputMap = (InputMap) UIManager.get(\"List.focusInputMap\");\n     InputMapUIResource parentInputMap = new InputMapUIResource();\n     // FIXME: The JDK uses a LazyActionMap for parentActionMap\n     ActionMap parentActionMap = new ActionMapUIResource();"}, {"sha": "13c78add6f84db25f564f6eeabe910f2a2894312", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicLookAndFeel.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicLookAndFeel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicLookAndFeel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicLookAndFeel.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -1159,7 +1159,7 @@ public Object createValue(UIDefaults def)\n       \"Tree.hash\", new ColorUIResource(new Color(128, 128, 128)),\n       \"Tree.leftChildIndent\", new Integer(7),\n       \"Tree.rightChildIndent\", new Integer(13),\n-      \"Tree.rowHeight\", new Integer(16),\n+      \"Tree.rowHeight\", new Integer(0),\n       \"Tree.scrollsOnExpand\", Boolean.TRUE,\n       \"Tree.selectionBackground\", new ColorUIResource(Color.black),\n       \"Tree.nonSelectionBackground\", new ColorUIResource(new Color(255, 255, 255)),"}, {"sha": "c8754a3e049e1e18d12711d8590822afadd4a199", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicMenuItemUI.java", "status": "modified", "additions": 14, "deletions": 28, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicMenuItemUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicMenuItemUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicMenuItemUI.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -475,7 +475,6 @@ protected void installDefaults()\n     \n     menuItem.setHorizontalTextPosition(SwingConstants.TRAILING);\n     menuItem.setHorizontalAlignment(SwingConstants.LEADING);\n-    menuItem.setOpaque(true);\n   }\n \n   /**\n@@ -553,11 +552,20 @@ public void paint(Graphics g, JComponent c)\n    */\n   protected void paintBackground(Graphics g, JMenuItem menuItem, Color bgColor)\n   {\n-    Dimension size = getPreferredSize(menuItem);\n-    Color foreground = g.getColor();\n-    g.setColor(bgColor);\n-    g.drawRect(0, 0, size.width, size.height);\n-    g.setColor(foreground);\n+    // Menu item is considered to be highlighted when it is selected.\n+    // But we don't want to paint the background of JCheckBoxMenuItems\n+    ButtonModel mod = menuItem.getModel();\n+    if ((menuItem.isSelected() && checkIcon == null) || (mod != null && \n+        mod.isArmed())\n+        && (menuItem.getParent() instanceof MenuElement))\n+      {\n+        if (menuItem.isContentAreaFilled())\n+          {\n+            g.setColor(selectionBackground);\n+            g.fillRect(0, 0, menuItem.getWidth(), menuItem.getHeight());\n+          }\n+      }\n+\n   }\n \n   /**\n@@ -612,28 +620,6 @@ protected void paintMenuItem(Graphics g, JComponent c, Icon checkIcon,\n     br.width += insets.right + insets.left;\n     br.height += insets.top + insets.bottom;\n \n-    // Menu item is considered to be highlighted when it is selected.\n-    // But we don't want to paint the background of JCheckBoxMenuItems\n-    ButtonModel mod = m.getModel();\n-    if ((m.isSelected() && checkIcon == null) || (mod != null && \n-        mod.isArmed())\n-        && (m.getParent() instanceof MenuElement))\n-      {\n-        if (m.isContentAreaFilled())\n-          {\n-            g.setColor(selectionBackground);\n-            g.fillRect(br.x, br.y, br.width, br.height);\n-          }\n-      }\n-    else\n-      {\n-        if (m.isContentAreaFilled())\n-          {\n-            g.setColor(m.getBackground());\n-            g.fillRect(br.x, br.y, br.width, br.height);\n-          }\n-      }\n-\n     // If this menu item is a JCheckBoxMenuItem then paint check icon\n     if (checkIcon != null)\n       {"}, {"sha": "e638b68e1dc3da7e59adf6019071b938c93b88b7", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicMenuUI.java", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicMenuUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicMenuUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicMenuUI.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -211,7 +211,6 @@ protected void installDefaults()\n     selectionForeground = UIManager.getColor(\"Menu.selectionForeground\");\n     arrowIcon = UIManager.getIcon(\"Menu.arrowIcon\");\n     oldBorderPainted = UIManager.getBoolean(\"Menu.borderPainted\");\n-    menuItem.setOpaque(true);\n   }\n \n   /**"}, {"sha": "d3674664d4ccc7229eab4da9f0ea08112bea24f3", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicProgressBarUI.java", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicProgressBarUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicProgressBarUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicProgressBarUI.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -212,6 +212,8 @@ public void componentResized(ComponentEvent e)\n \n   /**\n    * Holds the value of the bouncing box that is returned by {@link #getBox}.\n+   *\n+   * @since 1.5\n    */ \n   protected Rectangle boxRect;\n "}, {"sha": "66e53803722101eecf9f888f4e740791db9a368a", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicRadioButtonUI.java", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicRadioButtonUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicRadioButtonUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicRadioButtonUI.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -48,7 +48,6 @@\n import javax.swing.Icon;\n import javax.swing.JComponent;\n import javax.swing.SwingUtilities;\n-import javax.swing.UIDefaults;\n import javax.swing.UIManager;\n import javax.swing.plaf.ComponentUI;\n \n@@ -122,8 +121,7 @@ protected String getPropertyPrefix()\n    */\n   public Icon getDefaultIcon()\n   {\n-    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n-    return defaults.getIcon(getPropertyPrefix() + \"icon\");\n+    return UIManager.getIcon(getPropertyPrefix() + \"icon\");\n   }\n \n   /**"}, {"sha": "a2f5b82dbec93c07a401d41d5da455d4c1094e3a", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicScrollBarUI.java", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicScrollBarUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicScrollBarUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicScrollBarUI.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -62,7 +62,6 @@\n import javax.swing.SwingConstants;\n import javax.swing.SwingUtilities;\n import javax.swing.Timer;\n-import javax.swing.UIDefaults;\n import javax.swing.UIManager;\n import javax.swing.event.ChangeEvent;\n import javax.swing.event.ChangeListener;\n@@ -501,14 +500,12 @@ public void addLayoutComponent(String name, Component child)\n    */\n   protected void configureScrollBarColors()\n   {\n-    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n-\n-    trackColor = defaults.getColor(\"ScrollBar.track\");\n-    trackHighlightColor = defaults.getColor(\"ScrollBar.trackHighlight\");\n-    thumbColor = defaults.getColor(\"ScrollBar.thumb\");\n-    thumbHighlightColor = defaults.getColor(\"ScrollBar.thumbHighlight\");\n-    thumbDarkShadowColor = defaults.getColor(\"ScrollBar.thumbDarkShadow\");\n-    thumbLightShadowColor = defaults.getColor(\"ScrollBar.thumbShadow\");\n+    trackColor = UIManager.getColor(\"ScrollBar.track\");\n+    trackHighlightColor = UIManager.getColor(\"ScrollBar.trackHighlight\");\n+    thumbColor = UIManager.getColor(\"ScrollBar.thumb\");\n+    thumbHighlightColor = UIManager.getColor(\"ScrollBar.thumbHighlight\");\n+    thumbDarkShadowColor = UIManager.getColor(\"ScrollBar.thumbDarkShadow\");\n+    thumbLightShadowColor = UIManager.getColor(\"ScrollBar.thumbShadow\");\n   }\n \n   /**\n@@ -660,23 +657,15 @@ void calculatePreferredSize()\n \twidth += decrButton.getPreferredSize().getWidth();\n \n \twidth += (scrollbar.getMaximum() - scrollbar.getMinimum());\n-\n-\theight = Math.max(incrButton.getPreferredSize().height,\n-\t                  decrButton.getPreferredSize().height);\n-\theight = Math.max(getMinimumThumbSize().height, height);\n-\theight = Math.min(getMaximumThumbSize().height, height);\n+\theight = UIManager.getInt(\"ScrollBar.width\");\n       }\n     else\n       {\n \theight += incrButton.getPreferredSize().getHeight();\n \theight += decrButton.getPreferredSize().getHeight();\n \n \theight += (scrollbar.getMaximum() - scrollbar.getMinimum());\n-\n-\twidth = Math.max(incrButton.getPreferredSize().width,\n-\t                 decrButton.getPreferredSize().width);\n-\twidth = Math.max(getMinimumThumbSize().width, width);\n-\twidth = Math.min(getMaximumThumbSize().width, width);\n+\twidth = UIManager.getInt(\"ScrollBar.width\");\n       }\n \n     Insets insets = scrollbar.getInsets();"}, {"sha": "cf31e8b5df1ad187d680b1acf902706306fa63c8", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicSplitPaneUI.java", "status": "modified", "additions": 152, "deletions": 148, "changes": 300, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSplitPaneUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSplitPaneUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSplitPaneUI.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -126,14 +126,14 @@ public void addLayoutComponent(String place, Component component)\n     {\n       int i = 0;\n       if (place == null)\n-\ti = 2;\n+        i = 2;\n       else if (place.equals(JSplitPane.TOP) || place.equals(JSplitPane.LEFT))\n-\ti = 0;\n+        i = 0;\n       else if (place.equals(JSplitPane.BOTTOM)\n                || place.equals(JSplitPane.RIGHT))\n-\ti = 1;\n+        i = 1;\n       else\n-\tthrow new IllegalArgumentException(\"Illegal placement in JSplitPane\");\n+        throw new IllegalArgumentException(\"Illegal placement in JSplitPane\");\n       components[i] = component;\n       resetSizeAt(i);\n       splitPane.revalidate();\n@@ -164,7 +164,7 @@ protected int getAvailableSize(Dimension containerSize, Insets insets)\n     protected int getInitialLocation(Insets insets)\n     {\n       if (insets != null)\n-\treturn insets.left;\n+        return insets.left;\n       return 0;\n     }\n \n@@ -205,7 +205,7 @@ protected int getPreferredSizeOfComponent(Component c)\n     {\n       Dimension dims = c.getPreferredSize();\n       if (dims != null)\n-\treturn dims.width;\n+        return dims.width;\n       return 0;\n     }\n \n@@ -250,23 +250,23 @@ public void layoutContainer(Container container)\n     {\n       if (container instanceof JSplitPane)\n         {\n-\t  JSplitPane split = (JSplitPane) container;\n-\t  distributeExtraSpace();\n-\t  Insets insets = split.getInsets();\n-\t  int width = getInitialLocation(insets);\n-\t  Dimension dims = split.getSize();\n-\t  for (int i = 0; i < components.length; i += 2)\n-\t    {\n-\t      if (components[i] == null)\n-\t\tcontinue;\n-\t      setComponentToSize(components[i], sizes[i], width, insets, dims);\n-\t      width += sizes[i];\n-\t    }\n-\t  if (components[1] != null)\n-\t    {\n-\t      setComponentToSize(components[1], sizes[1], width, insets, dims);\n-\t      width += sizes[1];\n-\t    }\n+          JSplitPane split = (JSplitPane) container;\n+          distributeExtraSpace();\n+          Insets insets = split.getInsets();\n+          int width = getInitialLocation(insets);\n+          Dimension dims = split.getSize();\n+          for (int i = 0; i < components.length; i += 2)\n+            {\n+              if (components[i] == null)\n+                continue;\n+              setComponentToSize(components[i], sizes[i], width, insets, dims);\n+              width += sizes[i];\n+            }\n+          if (components[1] != null)\n+            {\n+              setComponentToSize(components[1], sizes[1], width, insets, dims);\n+              width += sizes[1];\n+            }\n         }\n     }\n \n@@ -297,23 +297,23 @@ public Dimension minimumLayoutSize(Container target)\n     {\n       if (target instanceof JSplitPane)\n         {\n-\t  JSplitPane split = (JSplitPane) target;\n-\t  Insets insets = target.getInsets();\n-\n-\t  int height = 0;\n-\t  int width = 0;\n-\t  for (int i = 0; i < components.length; i++)\n-\t    {\n-\t      if (components[i] == null)\n-\t\tcontinue;\n-\t      Dimension dims = components[i].getMinimumSize();\n-\t      if (dims != null)\n-\t        {\n-\t\t  width += dims.width;\n-\t\t  height = Math.max(height, dims.height);\n-\t        }\n-\t    }\n-\t  return new Dimension(width, height);\n+          JSplitPane split = (JSplitPane) target;\n+          Insets insets = target.getInsets();\n+\n+          int height = 0;\n+          int width = 0;\n+          for (int i = 0; i < components.length; i++)\n+            {\n+              if (components[i] == null)\n+                continue;\n+              Dimension dims = components[i].getMinimumSize();\n+              if (dims != null)\n+                {\n+                  width += dims.width;\n+                  height = Math.max(height, dims.height);\n+                }\n+            }\n+          return new Dimension(width, height);\n         }\n       return null;\n     }\n@@ -331,24 +331,24 @@ public Dimension preferredLayoutSize(Container target)\n     {\n       if (target instanceof JSplitPane)\n         {\n-\t  JSplitPane split = (JSplitPane) target;\n-\t  Insets insets = target.getInsets();\n-\n-\t  int height = 0;\n-\t  int width = 0;\n-\t  for (int i = 0; i < components.length; i++)\n-\t    {\n-\t      if (components[i] == null)\n-\t\tcontinue;\n-\t      Dimension dims = components[i].getPreferredSize();\n-\t      if (dims != null)\n-\t        {\n-\t\t  width += dims.width;\n-\t\t  if (! (components[i] instanceof BasicSplitPaneDivider))\n-\t\t    height = Math.max(height, dims.height);\n-\t        }\n-\t    }\n-\t  return new Dimension(width, height);\t\n+          JSplitPane split = (JSplitPane) target;\n+          Insets insets = target.getInsets();\n+\n+          int height = 0;\n+          int width = 0;\n+          for (int i = 0; i < components.length; i++)\n+            {\n+              if (components[i] == null)\n+                continue;\n+              Dimension dims = components[i].getPreferredSize();\n+              if (dims != null)\n+                {\n+                  width += dims.width;\n+                  if (!(components[i] instanceof BasicSplitPaneDivider))\n+                    height = Math.max(height, dims.height);\n+                }\n+            }\n+          return new Dimension(width, height);\n         }\n       return null;\n     }\n@@ -362,11 +362,11 @@ public void removeLayoutComponent(Component component)\n     {\n       for (int i = 0; i < components.length; i++)\n         {\n-\t  if (component == components[i])\n-\t    {\n-\t      components[i] = null;\n-\t      sizes[i] = 0;\n-\t    }\n+          if (component == components[i])\n+            {\n+              components[i] = null;\n+              sizes[i] = 0;\n+            }\n         }\n     }\n \n@@ -378,7 +378,7 @@ public void removeLayoutComponent(Component component)\n     protected void resetSizeAt(int index)\n     {\n       if (components[index] != null)\n-\tsizes[index] = getPreferredSizeOfComponent(components[index]);\n+        sizes[index] = getPreferredSizeOfComponent(components[index]);\n     }\n \n     /**\n@@ -387,7 +387,7 @@ protected void resetSizeAt(int index)\n     public void resetToPreferredSizes()\n     {\n       for (int i = 0; i < components.length; i++)\n-\tresetSizeAt(i);\n+        resetSizeAt(i);\n     }\n \n     /**\n@@ -433,13 +433,13 @@ protected void updateComponents()\n \n       if (left != null)\n         {\n-\t  components[0] = left;\n-\t  resetSizeAt(0);\n+          components[0] = left;\n+          resetSizeAt(0);\n         }\n       if (right != null)\n         {\n-\t  components[1] = right;\n-\t  resetSizeAt(1);\n+          components[1] = right;\n+          resetSizeAt(1);\n         }\n       components[2] = divider;\n       resetSizeAt(2);\n@@ -480,9 +480,9 @@ int minimumSizeOfComponent(int index)\n     {\n       Dimension dims = components[index].getMinimumSize();\n       if (dims != null)\n-\treturn dims.width;\n+        return dims.width;\n       else\n-\treturn 0;\n+        return 0;\n     }\n   } //end BasicHorizontalLayoutManager\n \n@@ -534,7 +534,7 @@ protected int getPreferredSizeOfComponent(Component c)\n     {\n       Dimension dims = c.getPreferredSize();\n       if (dims != null)\n-\treturn dims.height;\n+        return dims.height;\n       return 0;\n     }\n \n@@ -563,23 +563,23 @@ public Dimension minimumLayoutSize(Container container)\n     {\n       if (container instanceof JSplitPane)\n         {\n-\t  JSplitPane split = (JSplitPane) container;\n-\t  Insets insets = container.getInsets();\n-\n-\t  int height = 0;\n-\t  int width = 0;\n-\t  for (int i = 0; i < components.length; i++)\n-\t    {\n-\t      if (components[i] == null)\n-\t\tcontinue;\n-\t      Dimension dims = components[i].getMinimumSize();\n-\t      if (dims != null)\n-\t        {\n-\t\t  height += dims.height;\n-\t\t  width = Math.max(width, dims.width);\n-\t        }\n-\t    }\n-\t  return new Dimension(width, height);\n+          JSplitPane split = (JSplitPane) container;\n+          Insets insets = container.getInsets();\n+\n+          int height = 0;\n+          int width = 0;\n+          for (int i = 0; i < components.length; i++)\n+            {\n+              if (components[i] == null)\n+                continue;\n+              Dimension dims = components[i].getMinimumSize();\n+              if (dims != null)\n+                {\n+                  height += dims.height;\n+                  width = Math.max(width, dims.width);\n+                }\n+            }\n+          return new Dimension(width, height);\n         }\n       return null;\n     }\n@@ -597,23 +597,23 @@ public Dimension preferredLayoutSize(Container container)\n     {\n       if (container instanceof JSplitPane)\n         {\n-\t  JSplitPane split = (JSplitPane) container;\n-\t  Insets insets = container.getInsets();\n-\n-\t  int height = 0;\n-\t  int width = 0;\n-\t  for (int i = 0; i < components.length; i++)\n-\t    {\n-\t      if (components[i] == null)\n-\t\tcontinue;\n-\t      Dimension dims = components[i].getPreferredSize();\n-\t      if (dims != null)\n-\t        {\n-\t\t  height += dims.height;\n-\t\t  width = Math.max(width, dims.width);\n-\t        }\n-\t    }\n-\t  return new Dimension(width, height);\n+          JSplitPane split = (JSplitPane) container;\n+          Insets insets = container.getInsets();\n+\n+          int height = 0;\n+          int width = 0;\n+          for (int i = 0; i < components.length; i++)\n+            {\n+              if (components[i] == null)\n+                continue;\n+              Dimension dims = components[i].getPreferredSize();\n+              if (dims != null)\n+                {\n+                  height += dims.height;\n+                  width = Math.max(width, dims.width);\n+                }\n+            }\n+          return new Dimension(width, height);\n         }\n       return null;\n     }\n@@ -652,9 +652,9 @@ int minimumSizeOfComponent(int index)\n     {\n       Dimension dims = components[index].getMinimumSize();\n       if (dims != null)\n-\treturn dims.height;\n+        return dims.height;\n       else\n-\treturn 0;\n+        return 0;\n     }\n   }\n \n@@ -813,27 +813,27 @@ public void propertyChange(PropertyChangeEvent e)\n     {\n       if (e.getPropertyName().equals(JSplitPane.DIVIDER_SIZE_PROPERTY))\n         {\n-\t  int newSize = splitPane.getDividerSize();\n-\t  int[] tmpSizes = layoutManager.getSizes();\n-\t  dividerSize = tmpSizes[2];\n-      int newSpace = newSize - tmpSizes[2];\n-\t  tmpSizes[2] = newSize;\n-\n-\t  tmpSizes[0] += newSpace / 2;\n-\t  tmpSizes[1] += newSpace / 2;\n+          int newSize = splitPane.getDividerSize();\n+          int[] tmpSizes = layoutManager.getSizes();\n+          dividerSize = tmpSizes[2];\n+          int newSpace = newSize - tmpSizes[2];\n+          tmpSizes[2] = newSize;\n+\n+          tmpSizes[0] += newSpace / 2;\n+          tmpSizes[1] += newSpace / 2;\n       \n-\t  layoutManager.setSizes(tmpSizes);\n+          layoutManager.setSizes(tmpSizes);\n         }\n       else if (e.getPropertyName().equals(JSplitPane.ORIENTATION_PROPERTY))\n         {\n-\t  int max = layoutManager.getAvailableSize(splitPane.getSize(),\n-\t                                           splitPane.getInsets());\n-\t  int dividerLoc = getDividerLocation(splitPane);\n-\t  double prop = ((double) dividerLoc) / max;\n-\n-\t  resetLayoutManager();\n-\t  if (prop <= 1 && prop >= 0)\n-\t    splitPane.setDividerLocation(prop);\n+          int max = layoutManager.getAvailableSize(splitPane.getSize(),\n+                                                   splitPane.getInsets());\n+          int dividerLoc = getDividerLocation(splitPane);\n+          double prop = ((double) dividerLoc) / max;\n+\n+          resetLayoutManager();\n+          if (prop <= 1 && prop >= 0)\n+            splitPane.setDividerLocation(prop);\n         }\n       layoutManager.layoutContainer(splitPane);\n       splitPane.repaint();\n@@ -843,13 +843,13 @@ else if (e.getPropertyName().equals(JSplitPane.ORIENTATION_PROPERTY))\n       // Don't have to deal with resize_weight (as there\n       // will be no extra space associated with this\n       // event - the changes to the weighting will\n-      // be taken into account the next time the \n+      // be taken into account the next time the\n       // sizes change.)\n-      // Don't have to deal with divider_location \n+      // Don't have to deal with divider_location\n       // The method in JSplitPane calls our setDividerLocation\n       // so we'll know about those anyway.\n       // Don't have to deal with last_divider_location\n-      // Although I'm not sure why, it doesn't seem to \n+      // Although I'm not sure why, it doesn't seem to\n       // have any effect on Sun's JSplitPane.\n       // one_touch_expandable changes are dealt with\n       // by our divider.\n@@ -962,10 +962,10 @@ public void installUI(JComponent c)\n   {\n     if (c instanceof JSplitPane)\n       {\n-\tsplitPane = (JSplitPane) c;\n-\tinstallDefaults();\n-\tinstallListeners();\n-\tinstallKeyboardActions();\n+        splitPane = (JSplitPane) c;\n+        installDefaults();\n+        installListeners();\n+        installKeyboardActions();\n       }\n   }\n \n@@ -1218,8 +1218,8 @@ protected Component createDefaultNonContinuousLayoutDivider()\n   {\n     if (nonContinuousLayoutDivider == null)\n       {\n-\tnonContinuousLayoutDivider = new Canvas();\n-\tnonContinuousLayoutDivider.setBackground(Color.DARK_GRAY);\n+        nonContinuousLayoutDivider = new Canvas();\n+        nonContinuousLayoutDivider.setBackground(Color.DARK_GRAY);\n       }\n     return nonContinuousLayoutDivider;\n   }\n@@ -1300,12 +1300,14 @@ public void setDividerLocation(JSplitPane jc, int location)\n   {\n     location = validLocation(location);\n     Container p = jc.getParent();\n-    Dimension rightPrefSize = jc.getRightComponent().getPreferredSize();\n+    Component right = jc.getRightComponent();\n+    Dimension rightPrefSize = right == null ? new Dimension(0, 0)\n+                                           : right.getPreferredSize();\n     Dimension size = jc.getSize();\n     // check if the size has been set for the splitpane\n     if (size.width == 0 && size.height == 0)\n       size = jc.getPreferredSize();\n-    \n+\n     if (getOrientation() == 0 && location > size.height)\n       {\n         location = size.height;\n@@ -1324,11 +1326,11 @@ else if (location > size.width)\n             p = p.getParent();\n           }\n       }\n-    \n+\n     setLastDragLocation(getDividerLocation(splitPane));\n     splitPane.setLastDividerLocation(getDividerLocation(splitPane));\n     int[] tmpSizes = layoutManager.getSizes();\n-    tmpSizes[0] = location \n+    tmpSizes[0] = location\n                   - layoutManager.getInitialLocation(splitPane.getInsets());\n     tmpSizes[1] = layoutManager.getAvailableSize(splitPane.getSize(),\n                                                  splitPane.getInsets())\n@@ -1483,19 +1485,21 @@ protected void resetLayoutManager()\n    */\n   protected void startDragging()\n   {\n+    Component left = splitPane.getLeftComponent();\n+    Component right = splitPane.getRightComponent();\n     dividerSize = divider.getDividerSize();\n     setLastDragLocation(-1);\n \n-    if (! splitPane.getLeftComponent().isLightweight()\n-        || ! splitPane.getRightComponent().isLightweight())\n+    if ((left != null && !left.isLightweight())\n+        || (right != null && !right.isLightweight()))\n       draggingHW = true;\n \n     if (splitPane.isContinuousLayout())\n       nonContinuousLayoutDivider.setVisible(false);\n     else\n       {\n-\tnonContinuousLayoutDivider.setVisible(true);\n-\tnonContinuousLayoutDivider.setBounds(divider.getBounds());\n+        nonContinuousLayoutDivider.setVisible(true);\n+        nonContinuousLayoutDivider.setBounds(divider.getBounds());\n       }\n     splitPane.revalidate();\n     splitPane.repaint();\n@@ -1518,12 +1522,12 @@ protected void dragDividerTo(int location)\n       splitPane.setDividerLocation(location);\n     else\n       {\n-\tPoint p = nonContinuousLayoutDivider.getLocation();\n-\tif (getOrientation() == JSplitPane.HORIZONTAL_SPLIT)\n-\t  p.x = location;\n-\telse\n-\t  p.y = location;\n-\tnonContinuousLayoutDivider.setLocation(p);\n+        Point p = nonContinuousLayoutDivider.getLocation();\n+        if (getOrientation() == JSplitPane.HORIZONTAL_SPLIT)\n+          p.x = location;\n+        else\n+          p.y = location;\n+        nonContinuousLayoutDivider.setLocation(p);\n       }\n     setLastDragLocation(location);\n     splitPane.repaint();"}, {"sha": "015443946d720a5342744c83e4a498e929850cbd", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicTableUI.java", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTableUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTableUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTableUI.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -66,7 +66,6 @@\n import javax.swing.KeyStroke;\n import javax.swing.ListSelectionModel;\n import javax.swing.LookAndFeel;\n-import javax.swing.UIDefaults;\n import javax.swing.UIManager;\n import javax.swing.border.Border;\n import javax.swing.event.ChangeEvent;\n@@ -398,8 +397,7 @@ protected void installDefaults()\n \n   protected void installKeyboardActions() \n   {\n-    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n-    InputMap ancestorMap = (InputMap)defaults.get(\"Table.ancestorInputMap\");\n+    InputMap ancestorMap = (InputMap) UIManager.get(\"Table.ancestorInputMap\");\n     InputMapUIResource parentInputMap = new InputMapUIResource();\n     // FIXME: The JDK uses a LazyActionMap for parentActionMap\n     ActionMap parentActionMap = new ActionMapUIResource();"}, {"sha": "a988c5a63c834e65cb01d50de9818d31636de76d", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicTextPaneUI.java", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTextPaneUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTextPaneUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTextPaneUI.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -45,12 +45,9 @@\n import javax.swing.plaf.ColorUIResource;\n import javax.swing.UIDefaults;\n import javax.swing.plaf.ComponentUI;\n-import javax.swing.text.Element;\n-import javax.swing.text.PlainView;\n import javax.swing.text.Style;\n import javax.swing.text.StyleConstants;\n import javax.swing.text.StyleContext;\n-import javax.swing.text.View;\n \n public class BasicTextPaneUI extends BasicEditorPaneUI\n {\n@@ -64,11 +61,6 @@ public static ComponentUI createUI(JComponent comp)\n     return new BasicTextPaneUI();\n   }\n \n-  public View create(Element elem)\n-  {\n-    return new PlainView(elem);\n-  }\n-\n   /**\n    * Returns the prefix for entries in the {@link UIDefaults} table.\n    *"}, {"sha": "e8eeece3b328d52c7b5ea490793b293b83b3e94e", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicTextUI.java", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTextUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTextUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTextUI.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -58,7 +58,6 @@\n import javax.swing.LookAndFeel;\n import javax.swing.SwingConstants;\n import javax.swing.SwingUtilities;\n-import javax.swing.UIDefaults;\n import javax.swing.UIManager;\n import javax.swing.event.DocumentEvent;\n import javax.swing.event.DocumentListener;\n@@ -618,13 +617,14 @@ protected String getKeymapName()\n   protected Keymap createKeymap()\n   {\n     String prefix = getPropertyPrefix();\n-    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n     JTextComponent.KeyBinding[] bindings = \n-      (JTextComponent.KeyBinding[]) defaults.get(prefix + \".keyBindings\");\n+      (JTextComponent.KeyBinding[]) UIManager.get(prefix + \".keyBindings\");\n     if (bindings == null)\n       {\n         bindings = new JTextComponent.KeyBinding[0];\n-        defaults.put(prefix + \".keyBindings\", bindings);\n+        // FIXME: Putting something into the defaults map is certainly wrong.\n+        // Must be fixed somehow.\n+        UIManager.put(prefix + \".keyBindings\", bindings);\n       }\n \n     Keymap km = JTextComponent.addKeymap(getKeymapName(), \n@@ -661,17 +661,16 @@ protected void installKeyboardActions()\n   InputMap getInputMap(int condition)\n   {\n     String prefix = getPropertyPrefix();\n-    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n     switch (condition)\n       {\n       case JComponent.WHEN_IN_FOCUSED_WINDOW:\n         // FIXME: is this the right string? nobody seems to use it.\n-        return (InputMap) defaults.get(prefix + \".windowInputMap\"); \n+        return (InputMap) UIManager.get(prefix + \".windowInputMap\"); \n       case JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT:\n-        return (InputMap) defaults.get(prefix + \".ancestorInputMap\");\n+        return (InputMap) UIManager.get(prefix + \".ancestorInputMap\");\n       default:\n       case JComponent.WHEN_FOCUSED:\n-        return (InputMap) defaults.get(prefix + \".focusInputMap\");\n+        return (InputMap) UIManager.get(prefix + \".focusInputMap\");\n       }\n   }\n \n@@ -685,12 +684,14 @@ InputMap getInputMap(int condition)\n   ActionMap getActionMap()\n   {\n     String prefix = getPropertyPrefix();\n-    UIDefaults defaults = UIManager.getLookAndFeelDefaults();    \n-    ActionMap am = (ActionMap) defaults.get(prefix + \".actionMap\");\n+    ActionMap am = (ActionMap) UIManager.get(prefix + \".actionMap\");\n     if (am == null)\n       {\n         am = createActionMap();\n-        defaults.put(prefix + \".actionMap\", am);\n+        // FIXME: Putting something in the UIDefaults map is certainly wrong.\n+        // However, the whole method seems wrong and must be replaced by\n+        // something that is less wrong.\n+        UIManager.put(prefix + \".actionMap\", am);\n       }\n     return am;\n   }"}, {"sha": "7bf2a4ab167ad5b773653de798edd5b441079228", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicToolBarUI.java", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicToolBarUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicToolBarUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicToolBarUI.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -404,6 +404,8 @@ protected void dragTo(Point position, Point origin)\n     boolean tmp = ((loc == SwingConstants.NORTH)\n                   || (loc == SwingConstants.SOUTH) || (loc == -1));\n \n+    cachedOrientation = toolBar.getOrientation();\n+    cachedBounds = toolBar.getSize();\n     if (((cachedOrientation == SwingConstants.HORIZONTAL) && tmp)\n         || ((cachedOrientation == VERTICAL) && ! tmp))\n       {\n@@ -571,9 +573,6 @@ protected void installComponents()\n \n     dragWindow = createDragWindow(toolBar);\n \n-    cachedBounds = toolBar.getPreferredSize();\n-    cachedOrientation = toolBar.getOrientation();\n-\n     nonRolloverBorder = createNonRolloverBorder();\n     rolloverBorder = createRolloverBorder();\n "}, {"sha": "2d54983e61f9c42c1c0138d5861869203b29891f", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicTreeUI.java", "status": "modified", "additions": 154, "deletions": 309, "changes": 463, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTreeUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTreeUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTreeUI.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -81,7 +81,6 @@\n import javax.swing.LookAndFeel;\n import javax.swing.SwingUtilities;\n import javax.swing.Timer;\n-import javax.swing.UIDefaults;\n import javax.swing.UIManager;\n import javax.swing.event.CellEditorListener;\n import javax.swing.event.ChangeEvent;\n@@ -239,14 +238,14 @@ public class BasicTreeUI extends TreeUI\n   /** Boolean to keep track of editing. */\n   boolean isEditing;\n   \n-  /** The bounds of the current cell. */\n-  Rectangle bounds;\n-  \n   /** The current path of the visible nodes in the tree. */\n   TreePath currentVisiblePath;\n   \n   /** The gap between the icon and text. */\n   int gap = 4;\n+  \n+  /** Default row height, if none was set. */\n+  int rowHeight = 20;\n \n   /** Listeners */\n   private PropertyChangeListener propertyChangeListener;\n@@ -304,7 +303,7 @@ public static ComponentUI createUI(JComponent c)\n    */\n   protected Color getHashColor()\n   {\n-    return UIManager.getLookAndFeelDefaults().getColor(\"Tree.hash\");\n+    return UIManager.getColor(\"Tree.hash\");\n   }\n \n   /**\n@@ -315,8 +314,8 @@ protected Color getHashColor()\n    */\n   protected void setHashColor(Color color)\n   {\n-    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n-    defaults.put(\"Tree.hash\", color);\n+    // FIXME: Putting something in the UIDefaults map is certainly wrong.\n+    UIManager.put(\"Tree.hash\", color);\n   }\n \n   /**\n@@ -437,6 +436,8 @@ protected boolean isLargeModel()\n    */\n   protected void setRowHeight(int rowHeight)\n   {\n+    if (rowHeight == 0)\n+      rowHeight = this.rowHeight;\n     treeState.setRowHeight(rowHeight);\n   }\n \n@@ -624,21 +625,19 @@ protected TreeSelectionModel getSelectionModel()\n    */\n   public Rectangle getPathBounds(JTree tree, TreePath path)\n   {\n+    Rectangle bounds = null;\n+    int row = -1;\n+    Object cell = null;\n     if (path != null)\n       {\n-        Object cell = path.getLastPathComponent();\n-\n-        if (treeModel != null)\n-          {\n-            Object root = treeModel.getRoot();\n-\n-            if (!tree.isRootVisible() && tree.isExpanded(new TreePath(root)))\n-              root = getNextNode(root);\n-            Point loc = getCellLocation(0, 0, tree, treeModel, cell, root);\n-            return getCellBounds(loc.x, loc.y, cell);\n-          }\n+        row = getRowForPath(tree, path);\n+        cell = path.getLastPathComponent();\n+        bounds = new Rectangle(0, row * getRowHeight(), 0, 0);\n       }\n-    return null;\n+    return nodeDimensions.getNodeDimensions(cell, row,\n+                                            getLevel(cell),\n+                                            tree.isExpanded(path),\n+                                            bounds);\n   }\n \n   /**\n@@ -700,7 +699,6 @@ public int getRowForPath(JTree tree, TreePath path)\n    */\n   public int getRowCount(JTree tree)\n   {\n-    updateCurrentVisiblePath();\n     if (currentVisiblePath != null)\n       return currentVisiblePath.getPathCount();\n     return 0;\n@@ -1035,7 +1033,9 @@ protected void uninstallListeners()\n    */\n   protected void uninstallKeyboardActions()\n   {\n-    // TODO: Implement this properly.\n+    action = null;\n+    tree.getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).setParent(null);\n+    tree.getActionMap().setParent(null);\n   }\n \n   /**\n@@ -1227,7 +1227,7 @@ protected void installDefaults()\n     rightChildIndent = UIManager.getInt(\"Tree.rightChildIndent\");\n     leftChildIndent = UIManager.getInt(\"Tree.leftChildIndent\");\n     setRowHeight(UIManager.getInt(\"Tree.rowHeight\"));\n-    tree.setRowHeight(UIManager.getInt(\"Tree.rowHeight\"));\n+    tree.setRowHeight(getRowHeight());\n     tree.requestFocusInWindow(false);\n     tree.setScrollsOnExpand(UIManager.getBoolean(\"Tree.scrollsOnExpand\"));\n     setExpandedIcon(UIManager.getIcon(\"Tree.expandedIcon\"));\n@@ -1239,8 +1239,7 @@ protected void installDefaults()\n    */\n   protected void installKeyboardActions()\n   {\n-    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n-    InputMap focusInputMap = (InputMap) defaults.get(\"Tree.focusInputMap\");\n+    InputMap focusInputMap = (InputMap) UIManager.get(\"Tree.focusInputMap\");\n     InputMapUIResource parentInputMap = new InputMapUIResource();\n     ActionMap parentActionMap = new ActionMapUIResource();\n     action = new TreeAction();\n@@ -1409,14 +1408,30 @@ public void paint(Graphics g, JComponent c)\n     JTree tree = (JTree) c;\n     if (currentVisiblePath == null)\n       updateCurrentVisiblePath();\n-    \n-    if (currentVisiblePath != null && treeModel != null)\n+\n+    Rectangle clip = g.getClipBounds();\n+    Insets insets = tree.getInsets();\n+\n+    if (clip != null && treeModel != null && currentVisiblePath != null)\n       {\n-        Object root = treeModel.getRoot();\n-        paintRecursive(g, 0, 0, 0, tree, treeModel, root);\n-        \n-        if (hasControlIcons())\n-          paintControlIcons(g, 0, 0, 0, tree, treeModel, root);\n+        int startIndex = tree.getClosestRowForLocation(clip.x, clip.y);\n+        int endIndex = tree.getClosestRowForLocation(clip.x + clip.width,\n+                                                     clip.y + clip.height);\n+\n+        paintVerticalPartOfLeg(g, clip, insets, currentVisiblePath);\n+        for (int i = startIndex; i <= endIndex; i++)\n+          {\n+            Object curr = currentVisiblePath.getPathComponent(i);\n+            boolean isLeaf = treeModel.isLeaf(curr);\n+            TreePath path = new TreePath(getPathToRoot(curr, 0));\n+\n+            boolean isExpanded = tree.isExpanded(path);\n+            Rectangle bounds = getPathBounds(tree, path);\n+            paintHorizontalPartOfLeg(g, clip, insets, bounds, path, i,\n+                                     isExpanded, false, isLeaf);\n+            paintRow(g, clip, insets, bounds, path, i, isExpanded, false,\n+                     isLeaf);\n+          }\n       }\n   }\n \n@@ -1590,7 +1605,7 @@ protected boolean startEditing(TreePath path, MouseEvent event)\n     int y;\n     if (event == null)\n       {\n-        bounds = getPathBounds(tree, path);\n+        Rectangle bounds = getPathBounds(tree, path);\n         x = bounds.x;\n         y = bounds.y;\n       }\n@@ -1670,7 +1685,7 @@ protected boolean isLocationInExpandControl(TreePath path, int mouseX,\n     \n     if (!isLeaf(row))\n       {\n-        bounds = getPathBounds(tree, path);\n+        Rectangle bounds = getPathBounds(tree, path);\n \n         if (hasControlIcons() && (mouseX < bounds.x) \n             && (mouseX > (bounds.x - getCurrentControlIcon(path).getIconWidth() - gap)))\n@@ -1991,7 +2006,7 @@ public void componentMoved(ComponentEvent e)\n     }\n \n     /**\n-     * Creats, if necessary, and starts a Timer to check if needed to resize the\n+     * Creates, if necessary, and starts a Timer to check if needed to resize the\n      * bounds\n      */\n     protected void startTimer()\n@@ -2227,7 +2242,7 @@ public void mousePressed(MouseEvent e)\n \n       if (path != null)\n         {\n-          bounds = getPathBounds(tree, path);\n+          Rectangle bounds = getPathBounds(tree, path);\n           int row = getRowForPath(tree, path);\n           boolean cntlClick = isLocationInExpandControl(path, click.x, click.y);\n \n@@ -2268,6 +2283,7 @@ else if (tree.isExpanded(path))\n                   handleExpandControlClick(path, click.x, click.y);\n                   if (cellEditor != null)\n                     cellEditor.cancelCellEditing();\n+                  tree.scrollPathToVisible(path);\n                 }\n               else if (tree.isEditable())\n                 startEditing(path, e);\n@@ -2451,9 +2467,12 @@ public NodeDimensionsHandler()\n     }\n \n     /**\n-     * Responsible for getting the size of a particular node.\n+     * Returns, by reference in bounds, the size and x origin to place value at. \n+     * The calling method is responsible for determining the Y location. \n+     * If bounds is null, a newly created Rectangle should be returned, \n+     * otherwise the value should be placed in bounds and returned.\n      * \n-     * @param value\n+     * @param cell\n      *          the value to be represented\n      * @param row\n      *          row being queried\n@@ -2465,10 +2484,23 @@ public NodeDimensionsHandler()\n      *          a Rectangle containing the size needed to represent value\n      * @return containing the node dimensions, or null if node has no dimension\n      */\n-    public Rectangle getNodeDimensions(Object value, int row, int depth,\n+    public Rectangle getNodeDimensions(Object cell, int row, int depth,\n                                        boolean expanded, Rectangle size)\n     {\n-      return null;\n+      if (size == null || cell == null)\n+        return null;\n+\n+      String s = cell.toString();\n+      Font f = tree.getFont();\n+      FontMetrics fm = tree.getToolkit().getFontMetrics(f);\n+\n+      if (s != null)\n+        {\n+          size.x = getRowX(row, depth);\n+          size.width = SwingUtilities.computeStringWidth(fm, s);\n+          size.height = fm.getHeight();\n+        }\n+      return size;\n     }\n \n     /**\n@@ -2478,7 +2510,9 @@ public Rectangle getNodeDimensions(Object value, int row, int depth,\n      */\n     protected int getRowX(int row, int depth)\n     {\n-      return 0;\n+      if (row == 0)\n+        return 0;\n+      return depth * rightChildIndent;\n     }\n   }// NodeDimensionsHandler\n \n@@ -3056,241 +3090,6 @@ public boolean isEnabled()\n     }\n   }\n \n-  /**\n-   * Returns the cell bounds for painting selected cells Package private for use\n-   * in inner classes.\n-   * \n-   * @param x\n-   *          is the x location of the cell\n-   * @param y\n-   *          is the y location of the cell\n-   * @param cell\n-   *          is the Object to get the bounds for\n-   * @returns Rectangle that represents the cell bounds\n-   */\n-  Rectangle getCellBounds(int x, int y, Object cell)\n-  {\n-    if (cell != null)\n-      {\n-        String s = cell.toString();\n-        Font f = tree.getFont();\n-        FontMetrics fm = tree.getToolkit().getFontMetrics(f);\n-\n-        if (s != null)\n-            return new Rectangle(x, y, SwingUtilities.computeStringWidth(fm, s),\n-                               fm.getHeight());\n-      }\n-    return new Rectangle(x, y, 0, 0);\n-  }\n-\n-  /**\n-   * Retrieves the location of some node, recursively starting at from some\n-   * node. Package private for use in inner classes.\n-   * \n-   * @param x\n-   *          is the starting x position, offset\n-   * @param y\n-   *          is the starting y position, offset\n-   * @param tree\n-   *          is the tree to traverse\n-   * @param mod\n-   *          is the TreeModel to use\n-   * @param node\n-   *          is the node to get the location for\n-   * @param startNode\n-   *          is the node to start searching from\n-   * @return Point - the location of node\n-   */\n-  Point getCellLocation(int x, int y, JTree tree, TreeModel mod, Object node,\n-                        Object startNode)\n-  {\n-    int rowHeight = getRowHeight();\n-    if (startNode == null || startNode.equals(node))\n-      {\n-        int level = getLevel(node);\n-        if (level == 0)\n-          return new Point(x, y);\n-        if (!tree.isRootVisible() && \n-            tree.isExpanded(new TreePath(mod.getRoot())))\n-          return new Point(x + ((level - 1) * rightChildIndent), y);\n-        return new Point(x + (level * rightChildIndent), y);\n-      }\n-    return getCellLocation(x, y + rowHeight, tree, mod, node,\n-                           getNextVisibleNode(startNode));\n-  }\n-\n-  /**\n-   * Recursively paints all elements of the tree Package private for use in\n-   * inner classes.\n-   * \n-   * @param g\n-   *          the Graphics context in which to paint\n-   * @param indentation\n-   *          of the current object\n-   * @param descent\n-   *          is the number of elements drawn\n-   * @param depth\n-   *          is the depth of the current object in the tree\n-   * @param tree\n-   *          is the tree to draw to\n-   * @param mod\n-   *          is the TreeModel we are using to draw\n-   * @param curr\n-   *          is the current object to draw\n-   * @return int - current descent of the tree\n-   */\n-  int paintRecursive(Graphics g, int indentation, int descent,\n-                     int depth, JTree tree, TreeModel mod, Object curr)\n-  {\n-    Rectangle clip = tree.getVisibleRect();\n-    if (indentation > clip.x + clip.width + rightChildIndent\n-        || descent > clip.y + clip.height + getRowHeight())\n-      return descent;\n-\n-    TreePath path = new TreePath(getPathToRoot(curr, 0));\n-    int halfHeight = getRowHeight() / 2;\n-    int halfWidth = rightChildIndent / 2;\n-    int y0 = descent + halfHeight;\n-    int heightOfLine = descent + halfHeight;\n-    int row = getRowForPath(tree, path);\n-    boolean isRootVisible = tree.isRootVisible();\n-    boolean isExpanded = tree.isExpanded(path);\n-    boolean isLeaf = mod.isLeaf(curr);\n-    Rectangle bounds = getPathBounds(tree, path);\n-    Object root = mod.getRoot();\n-    \n-    if (isLeaf)\n-      {\n-        paintRow(g, clip, null, bounds, path, row, true, false, true);\n-        descent += getRowHeight();\n-      }\n-    else\n-      {\n-        if (depth > 0 || isRootVisible)\n-          {\n-            paintRow(g, clip, null, bounds, path, row, isExpanded, false, false);\n-            descent += getRowHeight();\n-            y0 += halfHeight;\n-          }\n-        \n-        if (isExpanded)\n-          {\n-            int max = mod.getChildCount(curr);\n-            for (int i = 0; i < max; i++)\n-              {\n-                Object child = mod.getChild(curr, i); \n-                boolean childVis = tree.isVisible(new TreePath\n-                                                  (getPathToRoot(child, 0)));\n-                int indent = indentation + rightChildIndent;\n-                if (!isRootVisible && depth == 0)\n-                  indent = 0;\n-                else if (isRootVisible || \n-                    (!isRootVisible && !curr.equals(root)) && childVis)\n-                  {\n-                    g.setColor(getHashColor());\n-                    heightOfLine = descent + halfHeight;\n-                    paintHorizontalLine(g, (JComponent) tree, heightOfLine, \n-                      indentation + halfWidth, indentation + rightChildIndent);\n-                  }\n-\n-                descent = paintRecursive(g, indent, descent, depth + 1,\n-                                         tree, mod, child);\n-              }\n-          }\n-      }\n-\n-    if (isExpanded)\n-      if (y0 != heightOfLine\n-          && (mod.getChildCount(curr) > 0 && \n-              tree.isVisible(new TreePath(getPathToRoot(mod.getChild\n-                                                        (curr, 0), 0)))))\n-        {\n-          g.setColor(getHashColor());\n-          paintVerticalLine(g, (JComponent) tree, indentation + halfWidth, y0,\n-                            heightOfLine);\n-        }\n-    return descent;\n-  }\n-  \n-  /**\n-   * Recursively paints all the control icons on the tree. Package private for\n-   * use in inner classes.\n-   * \n-   * @param g\n-   *          the Graphics context in which to paint\n-   * @param indentation\n-   *          of the current object\n-   * @param descent\n-   *          is the number of elements drawn\n-   * @param depth\n-   *          is the depth of the current object in the tree\n-   * @param tree\n-   *          is the tree to draw to\n-   * @param mod\n-   *          is the TreeModel we are using to draw\n-   * @param node\n-   *          is the current object to draw\n-   * @return int current descent of the tree\n-   */\n-  int paintControlIcons(Graphics g, int indentation, int descent,\n-                        int depth, JTree tree, TreeModel mod,\n-                        Object node)\n-  {\n-    int rowHeight = getRowHeight();\n-    TreePath path = new TreePath(getPathToRoot(node, 0));\n-    Icon icon = getCurrentControlIcon(path);\n-       \n-    Rectangle clip = tree.getVisibleRect();\n-    if (indentation > clip.x + clip.width + rightChildIndent\n-        || descent > clip.y + clip.height + getRowHeight())\n-      return descent;\n-   \n-    if (mod.isLeaf(node))\n-      descent += rowHeight;\n-    else\n-      {   \n-        if (!node.equals(mod.getRoot()) && \n-            (tree.isRootVisible() || getLevel(node) != 1))\n-          {\n-            int width = icon.getIconWidth();\n-            int height = icon.getIconHeight() + 2;\n-            int posX = indentation - rightChildIndent;\n-            int posY = descent;\n-            if (width > rightChildIndent)\n-              posX -= gap;\n-            else posX += width/2;\n-               \n-            if (height < rowHeight)\n-              posY += height/2;\n-               \n-            icon.paintIcon(tree, g, posX, posY);\n-          }\n-\n-        if (depth > 0 || tree.isRootVisible())\n-          descent += rowHeight;\n-           \n-        if (tree.isExpanded(path))\n-          {\n-            int max = 0;\n-            if (!mod.isLeaf(node))\n-              max = mod.getChildCount(node);\n-               \n-            for (int i = 0; i < max; i++)\n-              {\n-                int indent = indentation + rightChildIndent;\n-                Object child = mod.getChild(node, i);\n-                if (depth == 0 && !tree.isRootVisible())\n-                  indent =  1;\n-                if (tree.isVisible(new TreePath(getPathToRoot(child, 0))))\n-                  descent = paintControlIcons(g, indent, descent, depth + 1,\n-                                            tree, mod, child);\n-              }\n-          }\n-      }\n-   \n-    return descent;\n-  }\n-\n   /**\n    * Returns true if the LookAndFeel implements the control icons. Package\n    * private for use in inner classes.\n@@ -3376,7 +3175,6 @@ private Object findNode(Object root, Object node)\n    */\n   Object getPreviousVisibleNode(Object node)\n   {\n-    updateCurrentVisiblePath();\n     if (currentVisiblePath != null)\n       {\n         Object[] nodes = currentVisiblePath.getPath();\n@@ -3568,16 +3366,22 @@ Object[] getPathToRoot(Object node, int depth)\n   int getLevel(Object node)\n   {\n     int count = -1;\n-    \n+\n     Object current = node;\n \n-    do\n+    if (treeModel != null)\n       {\n-        current = getParent(treeModel.getRoot(), current);\n-        count++;\n+        Object root = treeModel.getRoot();\n+        if (!tree.isRootVisible() && tree.isExpanded(new TreePath(root)))\n+          count--;\n+        \n+        do\n+          {\n+            current = getParent(root, current);\n+            count++;\n+          }\n+        while (current != null);\n       }\n-    while (current != null);\n-    \n     return count;\n   }\n \n@@ -3598,6 +3402,8 @@ int getLevel(Object node)\n   protected void paintVerticalLine(Graphics g, JComponent c, int x, int top,\n                                    int bottom)\n   {\n+    // FIXME: Check if drawing a dashed line or not.\n+    g.setColor(getHashColor());\n     g.drawLine(x, top, x, bottom);\n   }\n \n@@ -3618,6 +3424,8 @@ protected void paintVerticalLine(Graphics g, JComponent c, int x, int top,\n   protected void paintHorizontalLine(Graphics g, JComponent c, int y, int left,\n                                      int right)\n   {\n+    // FIXME: Check if drawing a dashed line or not.\n+    g.setColor(getHashColor());\n     g.drawLine(left, y, right, y);\n   }\n \n@@ -3633,14 +3441,19 @@ protected void paintHorizontalLine(Graphics g, JComponent c, int y, int left,\n    * @param x\n    *          is the center position in x-direction\n    * @param y\n-   *          is the center position in y-direction FIXME what to do if x <\n-   *          (icon.width / 2). Same with y\n+   *          is the center position in y-direction \n    */\n   protected void drawCentered(Component c, Graphics g, Icon icon, int x, int y)\n   {\n-    int beginPositionX = x - icon.getIconWidth() / 2;\n-    int beginPositionY = y - icon.getIconHeight() / 2;\n-    icon.paintIcon(c, g, beginPositionX, beginPositionY);\n+    x -= icon.getIconWidth() / 2;\n+    y -= icon.getIconHeight() / 2;\n+    \n+    if (x < 0)\n+      x = 0;\n+    if (y < 0)\n+      y = 0;\n+    \n+    icon.paintIcon(c, g, x, y);\n   }\n   \n   /**\n@@ -3653,6 +3466,7 @@ protected void drawCentered(Component c, Graphics g, Icon icon, int x, int y)\n    */\n   protected void drawDashedHorizontalLine(Graphics g, int y, int x1, int x2)\n   {\n+    g.setColor(getHashColor());\n     for (int i = x1; i < x2; i += 2)\n       g.drawLine(i, y, i + 1, y);\n   }\n@@ -3667,6 +3481,7 @@ protected void drawDashedHorizontalLine(Graphics g, int y, int x1, int x2)\n    */\n   protected void drawDashedVerticalLine(Graphics g, int x, int y1, int y2)\n   {\n+    g.setColor(getHashColor());\n     for (int i = y1; i < y2; i += 2)\n       g.drawLine(x, i, x, i + 1);\n   }\n@@ -3691,8 +3506,15 @@ protected void paintExpandControl(Graphics g, Rectangle clipBounds,\n                                     boolean isExpanded, boolean hasBeenExpanded,\n                                     boolean isLeaf)\n   {\n-    if (treeModel != null && hasControlIcons())\n-      paintControlIcons(g, 0, 0, 0, tree, treeModel, path.getLastPathComponent());\n+    if (shouldPaintExpandControl(path, row, isExpanded, hasBeenExpanded, isLeaf))\n+      {\n+        Icon icon = getCurrentControlIcon(path);\n+        int iconW = icon.getIconWidth();\n+        int x = bounds.x - rightChildIndent + iconW/2;\n+        if (x + iconW > bounds.x)\n+          x = bounds.x - rightChildIndent - gap;\n+        icon.paintIcon(tree, g, x, bounds.y + bounds.height/2 - icon.getIconHeight()/2);\n+      }\n   }\n \n   /**\n@@ -3703,9 +3525,9 @@ protected void paintExpandControl(Graphics g, Rectangle clipBounds,\n    * @param g - the graphics configuration\n    * @param clipBounds - \n    * @param insets - \n-   * @param bounds - bounds of expand control\n-   * @param path - path to draw control for\n-   * @param row - row to draw control for\n+   * @param bounds - bounds of the cell\n+   * @param path - path to draw leg for\n+   * @param row - row to start drawing at\n    * @param isExpanded - is the row expanded\n    * @param hasBeenExpanded - has the row already been expanded\n    * @param isLeaf - is the path a leaf\n@@ -3716,7 +3538,9 @@ protected void paintHorizontalPartOfLeg(Graphics g, Rectangle clipBounds,\n                                           boolean isExpanded, boolean hasBeenExpanded,\n                                           boolean isLeaf)\n   {\n-    // FIXME: not implemented\n+    if (row != 0)\n+      paintHorizontalLine(g, tree, bounds.y + bounds.height/2, bounds.x - gap - 2,\n+                          bounds.x);\n   }\n   \n   /**\n@@ -3731,7 +3555,24 @@ protected void paintHorizontalPartOfLeg(Graphics g, Rectangle clipBounds,\n   protected void paintVerticalPartOfLeg(Graphics g, Rectangle clipBounds,\n                                         Insets insets, TreePath path)\n   {\n-    // FIXME: not implemented\n+    int max = tree.getVisibleRowCount();\n+    for (int i = 0; i < max; i++)\n+      {\n+        Object curr = path.getPathComponent(i);\n+        TreePath currPath = new TreePath(getPathToRoot(curr, 0));\n+        int numChild = treeModel.getChildCount(curr);\n+        if (numChild > 0 && tree.isExpanded(currPath))\n+          {\n+            Rectangle bounds = getPathBounds(tree, currPath);\n+            Rectangle lastChildBounds = getPathBounds(tree, \n+                                        new TreePath(getPathToRoot(\n+                                        treeModel.getChild(curr, numChild - 1), \n+                                        0)));\n+            paintVerticalLine(g, tree, bounds.x + gap + 2, bounds.y + \n+                              bounds.height - 2, lastChildBounds.y + \n+                              lastChildBounds.height/2);\n+          }\n+      }\n   }\n \n   /**\n@@ -3762,7 +3603,12 @@ protected void paintRow(Graphics g, Rectangle clipBounds,\n       {\n         if (!validCachedPreferredSize)\n           updateCachedPreferredSize();\n-        bounds.x += gap;\n+        \n+        \n+        paintExpandControl(g, clipBounds, insets, bounds, path, row, isExpanded, hasBeenExpanded, isLeaf);\n+        \n+        if (row != 0)\n+          bounds.x += gap;\n         bounds.width = preferredSize.width + bounds.x;\n         \n         if (editingComponent != null && editingPath != null && isEditing(tree)\n@@ -3808,10 +3654,7 @@ protected boolean shouldPaintExpandControl(TreePath path, int row,\n                                              boolean isLeaf)\n   {\n     Object node = path.getLastPathComponent();\n-    if (treeModel != null && (!isLeaf && !node.equals(treeModel.getRoot())) && \n-        (tree.isRootVisible() || getLevel(node) != 1))\n-      return true;\n-    return false;\n+    return (!isLeaf && getLevel(node) != 0 && hasControlIcons());\n   }\n   \n   /**\n@@ -3824,24 +3667,28 @@ void updateCurrentVisiblePath()\n       return;\n \n     Object next = treeModel.getRoot();\n-    Rectangle bounds = getCellBounds(0, 0, next);\n-    boolean rootVisible = isRootVisible();\n+    TreePath rootPath = new TreePath(next);\n+    Rectangle bounds = getPathBounds(tree, rootPath);\n     \n     // If root is not a valid size to be visible, or is\n     // not visible and the tree is expanded, then the next node acts\n     // as the root\n-    if ((bounds.width == 0 && bounds.height == 0) || (!rootVisible\n+    if ((bounds.width == 0 && bounds.height == 0) || (!isRootVisible()\n         && tree.isExpanded(new TreePath(next))))\n+      {\n         next = getNextNode(next);\n+        rootPath = new TreePath(next);\n+      }\n     \n     Object root = next;\n     TreePath current = null;\n     while (next != null)\n       {\n         if (current == null)\n-          current = new TreePath(next);\n-        else \n-            current = current.pathByAddingChild(next);\n+          current = rootPath;\n+        else\n+          current = current.pathByAddingChild(next);\n+        \n         do\n           {\n             TreePath path = new TreePath(getPathToRoot(next, 0));\n@@ -3860,7 +3707,7 @@ void updateCurrentVisiblePath()\n                       {\n                         next = getNextSibling(parent);\n                         if (next == null)\n-                          parent = getParent(treeModel.getRoot(), next);\n+                          parent = getParent(root, parent);\n                       }\n                   }\n               }\n@@ -3870,9 +3717,7 @@ void updateCurrentVisiblePath()\n       }\n \n     currentVisiblePath = current;\n-    if (currentVisiblePath != null)\n-      tree.setVisibleRowCount(currentVisiblePath.getPathCount());\n-    else tree.setVisibleRowCount(0);\n+    tree.setVisibleRowCount(getRowCount(tree));\n \n     if (tree.getSelectionModel() != null && tree.getSelectionCount() == 0 &&\n         currentVisiblePath != null)"}, {"sha": "28143d51ecdb3c54799cb4355cf878e2c96b1164", "filename": "libjava/classpath/javax/swing/plaf/metal/MetalBorders.java", "status": "modified", "additions": 101, "deletions": 40, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalBorders.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalBorders.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalBorders.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -56,7 +56,6 @@\n import javax.swing.JToggleButton;\n import javax.swing.JToolBar;\n import javax.swing.SwingConstants;\n-import javax.swing.UIDefaults;\n import javax.swing.UIManager;\n import javax.swing.border.AbstractBorder;\n import javax.swing.border.Border;\n@@ -130,6 +129,82 @@ public ButtonBorder()\n      */\n     public void paintBorder(Component c, Graphics g, int x, int y, int w,\n                             int h)\n+    {\n+      // With the OceanTheme the button border is painted entirely different.\n+      // However, I couldn't figure out how this is determined besides checking\n+      // for instanceof OceanTheme. The button painting is definitely not\n+      // influenced by a UI default property and it is definitely performed\n+      // by the same Border class.\n+      if (MetalLookAndFeel.getCurrentTheme() instanceof OceanTheme)\n+        paintOceanButtonBorder(c, g, x, y, w, h);\n+      else\n+        {\n+          ButtonModel bmodel = null;\n+      \n+          if (c instanceof AbstractButton)\n+            bmodel = ((AbstractButton) c).getModel();\n+\n+          Color darkShadow = MetalLookAndFeel.getControlDarkShadow();\n+          Color shadow = MetalLookAndFeel.getControlShadow();\n+          Color light = MetalLookAndFeel.getControlHighlight();\n+          Color middle = MetalLookAndFeel.getControl();\n+\n+          if (c.isEnabled())\n+            {\n+              // draw dark border\n+              g.setColor(darkShadow);\n+              g.drawRect(x, y, w - 2, h - 2);\n+\n+              if (!bmodel.isPressed())\n+                {\n+                  // draw light border\n+                  g.setColor(light);\n+                  g.drawRect(x + 1, y + 1, w - 2, h - 2);\n+\n+                  // draw crossing pixels of both borders\n+                  g.setColor(middle);\n+                  g.drawLine(x + 1, y + h - 2, x + 1, y + h - 2);\n+                  g.drawLine(x + w - 2, y + 1, x + w - 2, y + 1);\n+                }\n+              else\n+                {\n+                  // draw light border\n+                  g.setColor(light);\n+                  g.drawLine(x + w - 1, y + 1, x + w - 1, y + h - 1);\n+                  g.drawLine(x + 1, y + h - 1, x + w - 1, y + h - 1);\n+\n+                  // draw shadow border\n+                  g.setColor(middle);\n+                  g.drawLine(x + 1, y + 1, x + w - 2, y + 1);\n+                  g.drawLine(x + 1, y + 1, x + 1, y + h - 2);\n+ \n+                  // draw crossing pixels of both borders\n+                  g.setColor(shadow);\n+                  g.drawRect(x + 1, y + h - 2, 0, 0);\n+                  g.drawRect(x + w - 2, y + 1, 0, 0);\n+                }\n+            }\n+          else \n+            {\n+              // draw disabled border\n+              g.setColor(MetalLookAndFeel.getInactiveControlTextColor());\n+              g.drawRect(x, y, w - 2, h - 2);          \n+            }\n+        }\n+    }\n+\n+    /**\n+     * Paints the button border for the OceanTheme.\n+     *\n+     * @param c the button\n+     * @param g the graphics context\n+     * @param x the X coordinate of the upper left corner of the painting rect\n+     * @param y the Y coordinate of the upper left corner of the painting rect\n+     * @param w the width of the painting rect\n+     * @param h the height of the painting rect\n+     */\n+    private void paintOceanButtonBorder(Component c, Graphics g, int x,\n+                                        int y, int w, int h)\n     {\n       ButtonModel bmodel = null;\n       \n@@ -138,44 +213,31 @@ public void paintBorder(Component c, Graphics g, int x, int y, int w,\n \n       Color darkShadow = MetalLookAndFeel.getControlDarkShadow();\n       Color shadow = MetalLookAndFeel.getControlShadow();\n-      Color light = MetalLookAndFeel.getWhite();\n+      Color light = MetalLookAndFeel.getControlHighlight();\n       Color middle = MetalLookAndFeel.getControl();\n \n       if (c.isEnabled())\n-      {\n-        // draw dark border\n-        g.setColor(darkShadow);\n-        g.drawRect(x, y, w - 2, h - 2);\n-\n-        if (!bmodel.isPressed())\n-          {\n-            // draw light border\n-            g.setColor(light);\n-            g.drawRect(x + 1, y + 1, w - 2, h - 2);\n-\n-            // draw crossing pixels of both borders\n-            g.setColor(middle);\n-            g.drawRect(x + 1, y + h - 2, 0, 0);\n-            g.drawRect(x + w - 2, y + 1, 0, 0);\n-          }\n-        else\n-          {\n-            // draw light border\n-            g.setColor(light);\n-            g.drawLine(x + w - 1, y + 1, x + w - 1, y + h - 1);\n-            g.drawLine(x + 1, y + h - 1, x + w - 1, y + h - 1);\n-\n-            // draw shadow border\n-            g.setColor(middle);\n-            g.drawLine(x + 1, y + 1, x + w - 2, y + 1);\n-            g.drawLine(x + 1, y + 1, x + 1, y + h - 2);\n- \n-            // draw crossing pixels of both borders\n-            g.setColor(shadow);\n-            g.drawRect(x + 1, y + h - 2, 0, 0);\n-            g.drawRect(x + w - 2, y + 1, 0, 0);\n-          }\n-      }\n+        {\n+          if (bmodel.isPressed())\n+            {\n+              // draw fat border\n+              g.drawLine(x + 1, y + 1, x + w - 2, y + 1);\n+              g.drawLine(x + 1, y + 1, x + 1, y + h - 2);\n+            }\n+          else if (bmodel.isRollover())\n+            {\n+              g.setColor(shadow);\n+              g.drawRect(x, y, w - 1, h - 1);\n+              g.drawRect(x + 2, y + 2, w - 5, h - 5);\n+              g.setColor(darkShadow);\n+              g.drawRect(x + 1, y + 1, w - 3, h - 3);\n+            }\n+          else\n+            {\n+              g.setColor(darkShadow);\n+              g.drawRect(x, y, w - 1, h - 1);\n+            }\n+        }\n       else \n         {\n           // draw disabled border\n@@ -654,24 +716,23 @@ public void paintBorder(Component c, Graphics g, int x, int y, int w,\n         {\n           JOptionPane pane = (JOptionPane) f.getContentPane();\n           int type = pane.getMessageType();\n-          UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n           if (type == JOptionPane.QUESTION_MESSAGE)\n             {\n-              Color bc = defaults.getColor(\n+              Color bc = UIManager.getColor(\n                   \"OptionPane.questionDialog.border.background\");\n               if (bc != null)\n                 g.setColor(bc);\n             }\n           if (type == JOptionPane.WARNING_MESSAGE)\n             {\n-              Color bc = defaults.getColor(\n+              Color bc = UIManager.getColor(\n                   \"OptionPane.warningDialog.border.background\");\n               if (bc != null)\n                 g.setColor(bc);              \n             }\n           else if (type == JOptionPane.ERROR_MESSAGE)\n             {\n-              Color bc = defaults.getColor(\n+              Color bc = UIManager.getColor(\n                   \"OptionPane.errorDialog.border.background\");\n               if (bc != null)\n                 g.setColor(bc);              "}, {"sha": "10e51117329ff0b6ac9f6c0f83889eeb2b3df01a", "filename": "libjava/classpath/javax/swing/plaf/metal/MetalButtonUI.java", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalButtonUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalButtonUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalButtonUI.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -47,7 +47,7 @@\n import javax.swing.AbstractButton;\n import javax.swing.JButton;\n import javax.swing.JComponent;\n-import javax.swing.UIDefaults;\n+import javax.swing.SwingConstants;\n import javax.swing.UIManager;\n import javax.swing.plaf.ComponentUI;\n import javax.swing.plaf.UIResource;\n@@ -78,10 +78,9 @@\n   public MetalButtonUI()\n   {\n     super();\n-    UIDefaults def = UIManager.getLookAndFeelDefaults();\n-    focusColor = def.getColor(getPropertyPrefix() + \"focus\");\n-    selectColor = def.getColor(getPropertyPrefix() + \"select\");\n-    disabledTextColor = def.getColor(getPropertyPrefix() + \"disabledText\");\n+    focusColor = UIManager.getColor(getPropertyPrefix() + \"focus\");\n+    selectColor = UIManager.getColor(getPropertyPrefix() + \"select\");\n+    disabledTextColor = UIManager.getColor(getPropertyPrefix() + \"disabledText\");\n   }\n \n   /**\n@@ -135,11 +134,8 @@ public static ComponentUI createUI(JComponent c) {\n   public void installDefaults(AbstractButton button)\n   {\n     super.installDefaults(button);\n-    if (button.isRolloverEnabled())\n-      {\n-        if (button.getBorder() instanceof UIResource)\n-          button.setBorder(MetalBorders.getRolloverBorder());\n-      }\n+    button.setRolloverEnabled(UIManager.getBoolean(\n+                                            getPropertyPrefix() + \"rollover\"));\n   }\n     \n   /**\n@@ -148,8 +144,7 @@ public void installDefaults(AbstractButton button)\n   public void uninstallDefaults(AbstractButton button) \n   {\n     super.uninstallDefaults(button);\n-    if (button.getBorder() instanceof UIResource)\n-      button.setBorder(null);\n+    button.setRolloverEnabled(false);\n   }\n \n   /**\n@@ -230,4 +225,24 @@ protected void paintText(Graphics g, JComponent c, Rectangle textRect,\n         g.drawString(text, textRect.x, textRect.y + fm.getAscent());\n       }  \n   }\n+\n+  /**\n+   * If the property <code>Button.gradient</code> is set, then a gradient is\n+   * painted as background, otherwise the normal superclass behaviour is\n+   * called.\n+   */\n+  public void update(Graphics g, JComponent c)\n+  {\n+    AbstractButton b = (AbstractButton) c;\n+    if (b.isOpaque() && UIManager.get(getPropertyPrefix() + \"gradient\") != null\n+        && !b.getModel().isPressed() && b.isEnabled())\n+      {\n+        MetalUtils.paintGradient(g, 0, 0, c.getWidth(), c.getHeight(),\n+                                 SwingConstants.VERTICAL,\n+                                 getPropertyPrefix() + \"gradient\");\n+        paint(g, c);\n+      }\n+    else\n+      super.update(g, c);\n+  }\n }"}, {"sha": "fb8280e44da956ced5a850d70fb96f6f177d4b13", "filename": "libjava/classpath/javax/swing/plaf/metal/MetalCheckBoxIcon.java", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalCheckBoxIcon.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalCheckBoxIcon.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalCheckBoxIcon.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -44,6 +44,8 @@\n \n import javax.swing.Icon;\n import javax.swing.JCheckBox;\n+import javax.swing.SwingConstants;\n+import javax.swing.UIManager;\n import javax.swing.plaf.UIResource;\n \n /**\n@@ -128,6 +130,9 @@ public int getIconHeight()\n    */\n   public void paintIcon(Component c, Graphics g, int x, int y)\n   {\n+    if (UIManager.get(\"CheckBox.gradient\") != null)\n+      MetalUtils.paintGradient(g, x, y, getIconWidth(), getIconHeight(),\n+                               SwingConstants.VERTICAL, \"CheckBox.gradient\");\n     border.paintBorder(c, g, x, y, getIconWidth(), getIconHeight());\n     JCheckBox cb = (JCheckBox) c;\n     if (cb.isSelected())"}, {"sha": "bcb86e6104779574968696462b7733163b1edd4e", "filename": "libjava/classpath/javax/swing/plaf/metal/MetalIconFactory.java", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalIconFactory.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalIconFactory.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalIconFactory.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -52,6 +52,8 @@\n import javax.swing.JRadioButton;\n import javax.swing.JRadioButtonMenuItem;\n import javax.swing.JSlider;\n+import javax.swing.SwingConstants;\n+import javax.swing.UIManager;\n import javax.swing.plaf.UIResource;\n \n \n@@ -779,6 +781,10 @@ public int getIconHeight()\n      */\n     public void paintIcon(Component c, Graphics g, int x, int y) \n     {\n+      if (UIManager.get(\"RadioButton.gradient\") != null)\n+        MetalUtils.paintGradient(g, x, y, getIconWidth(), getIconHeight(),\n+                              SwingConstants.VERTICAL, \"RadioButton.gradient\");\n+\n       Color savedColor = g.getColor();\n       JRadioButton b = (JRadioButton) c;\n       "}, {"sha": "2cf5f67d55d4b4781bfdf5709e6af9924291d7e0", "filename": "libjava/classpath/javax/swing/plaf/metal/MetalInternalFrameTitlePane.java", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalInternalFrameTitlePane.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalInternalFrameTitlePane.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalInternalFrameTitlePane.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -55,7 +55,6 @@\n import javax.swing.JMenu;\n import javax.swing.SwingConstants;\n import javax.swing.SwingUtilities;\n-import javax.swing.UIDefaults;\n import javax.swing.UIManager;\n import javax.swing.plaf.basic.BasicInternalFrameTitlePane;\n \n@@ -260,9 +259,8 @@ protected void installDefaults()\n     notSelectedTextColor = MetalLookAndFeel.getInactiveControlTextColor();\n     notSelectedTitleColor = MetalLookAndFeel.getWindowTitleInactiveBackground();\n     \n-    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n-    paletteTitleHeight = defaults.getInt(\"InternalFrame.paletteTitleHeight\");\n-    paletteCloseIcon = defaults.getIcon(\"InternalFrame.paletteCloseIcon\");\n+    paletteTitleHeight = UIManager.getInt(\"InternalFrame.paletteTitleHeight\");\n+    paletteCloseIcon = UIManager.getIcon(\"InternalFrame.paletteCloseIcon\");\n     minIcon = MetalIconFactory.getInternalFrameAltMaximizeIcon(16);\n     \n     title = new JLabel(frame.getTitle(), \n@@ -351,8 +349,14 @@ public void paintPalette(Graphics g)\n   {\n     Color savedColor = g.getColor();\n     Rectangle b = SwingUtilities.getLocalBounds(this);\n-    g.setColor(MetalLookAndFeel.getPrimaryControlShadow());\n-    g.fillRect(b.x, b.y, b.width, b.height);\n+\n+    if (UIManager.get(\"InternalFrame.activeTitleGradient\") != null\n+        && frame.isSelected())\n+      {\n+        MetalUtils.paintGradient(g, b.x, b.y, b.width, b.height,\n+                                 SwingConstants.VERTICAL,\n+                                 \"InternalFrame.activeTitleGradient\");\n+      }\n     MetalUtils.fillMetalPattern(this, g, b.x + 4, b.y + 2, b.width \n             - paletteCloseIcon.getIconWidth() - 13, b.height - 5,\n             MetalLookAndFeel.getPrimaryControlHighlight(), \n@@ -393,6 +397,14 @@ public void paintComponent(Graphics g)\n         g.drawLine(0, d.height - 1, d.width - 1, d.height - 1);\n         \n         // draw the metal pattern\n+        if (UIManager.get(\"InternalFrame.activeTitleGradient\") != null\n+            && frame.isSelected())\n+          {\n+            MetalUtils.paintGradient(g, 0, 0, getWidth(), getHeight(),\n+                                     SwingConstants.VERTICAL,\n+                                     \"InternalFrame.activeTitleGradient\");\n+          }\n+\n         Rectangle b = title.getBounds();\n         int startX = b.x + b.width + 5;\n         int endX = startX;"}, {"sha": "12b858e0a934210b9ee5a76c71187cd5c5653b8d", "filename": "libjava/classpath/javax/swing/plaf/metal/MetalLabelUI.java", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalLabelUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalLabelUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalLabelUI.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -43,7 +43,6 @@\n \n import javax.swing.JComponent;\n import javax.swing.JLabel;\n-import javax.swing.UIDefaults;\n import javax.swing.UIManager;\n import javax.swing.plaf.ComponentUI;\n import javax.swing.plaf.basic.BasicGraphicsUtils;\n@@ -83,22 +82,20 @@ public static ComponentUI createUI(JComponent component)\n   \n   /**\n    * Draws the text for a disabled label, using the color defined in the \n-   * {@link UIDefaults} with the key <code>Label.disabledForeground</code>.\n+   * {@link UIManager} defaults with the key\n+   * <code>Label.disabledForeground</code>.\n    * \n    * @param l  the label.\n    * @param g  the graphics device.\n    * @param s  the label text.\n    * @param textX  the x-coordinate for the label.\n    * @param textY  the y-coordinate for the label.\n-   * \n-   * @see UIManager#getLookAndFeelDefaults()\n    */\n   protected void paintDisabledText(JLabel l, Graphics g, String s, int textX,\n                                  int textY)\n   {\n     Color savedColor = g.getColor();\n-    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n-    g.setColor(defaults.getColor(\"Label.disabledForeground\"));\n+    g.setColor(UIManager.getColor(\"Label.disabledForeground\"));\n     int mnemIndex = l.getDisplayedMnemonicIndex();\n     if (mnemIndex != -1)\n       BasicGraphicsUtils.drawStringUnderlineCharAt(g, s, mnemIndex, textX,"}, {"sha": "da019379bf51ca2c4df0609a5e6e15360bc688b5", "filename": "libjava/classpath/javax/swing/plaf/metal/MetalLookAndFeel.java", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalLookAndFeel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalLookAndFeel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalLookAndFeel.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -693,6 +693,7 @@ protected void initClassDefaults(UIDefaults defaults)\n       \"DesktopIconUI\", \"javax.swing.plaf.metal.MetalDesktopIconUI\",\n       \"InternalFrameUI\", \"javax.swing.plaf.metal.MetalInternalFrameUI\",\n       \"LabelUI\", \"javax.swing.plaf.metal.MetalLabelUI\",\n+      \"MenuBarUI\", \"javax.swing.plaf.metal.MetalMenuBarUI\",\n       \"PopupMenuSeparatorUI\",\n       \"javax.swing.plaf.metal.MetalPopupMenuSeparatorUI\",\n       \"ProgressBarUI\", \"javax.swing.plaf.metal.MetalProgressBarUI\",\n@@ -1162,7 +1163,7 @@ public Object createValue(UIDefaults def)\n       \"Tree.line\", getPrimaryControl(),\n       \"Tree.openIcon\", MetalIconFactory.getTreeFolderIcon(),\n       \"Tree.rightChildIndent\", new Integer(13),\n-      \"Tree.rowHeight\", new Integer(20),\n+      \"Tree.rowHeight\", new Integer(0),\n       \"Tree.scrollsOnExpand\", Boolean.TRUE,\n       \"Tree.selectionBackground\", getTextHighlightColor(),\n       \"Tree.selectionBorder\", new BorderUIResource.LineBorderUIResource(new Color(102, 102, 153)),\n@@ -1201,4 +1202,13 @@ protected void initSystemColorDefaults(UIDefaults defaults)\n     defaults.putDefaults(uiDefaults);\n   }\n \n+  /**\n+   * Returns the current theme setting for the Metal L&amp;F.\n+   *\n+   * @return the current theme setting for the Metal L&amp;F\n+   */\n+  public static MetalTheme getCurrentTheme()\n+  {\n+    return theme;\n+  }\n }"}, {"sha": "31d8d671fa1a93fa940aec543c174f8cfe27c1e0", "filename": "libjava/classpath/javax/swing/plaf/metal/MetalMenuBarUI.java", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalMenuBarUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalMenuBarUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalMenuBarUI.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -0,0 +1,88 @@\n+/* MetalMenuBarUI.java -- MenuBar UI for the Metal L&F\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.swing.plaf.metal;\n+\n+import java.awt.Graphics;\n+\n+import javax.swing.JComponent;\n+import javax.swing.SwingConstants;\n+import javax.swing.UIManager;\n+import javax.swing.plaf.ComponentUI;\n+import javax.swing.plaf.basic.BasicMenuBarUI;\n+\n+/**\n+ * A UI implementation for MenuBar in the Metal Look &amp; Feel.\n+ * \n+ * @author Roman Kennke (kennke@aicas.com)\n+ *\n+ * @since 1.5\n+ */\n+public class MetalMenuBarUI extends BasicMenuBarUI\n+{\n+  /**\n+   * Creates and returns a new instance of this UI for the specified component.\n+   *\n+   * @param c the component to create a UI for\n+   *\n+   * @return the UI for the component\n+   */\n+  public static ComponentUI createUI(JComponent c)\n+  {\n+    return new MetalMenuBarUI();\n+  }\n+\n+\n+  /**\n+   * If the property <code>MenuBar.gradient</code> is set, then a gradient\n+   * is painted as background, otherwise the normal superclass behaviour is\n+   * called.\n+   */\n+  public void update(Graphics g, JComponent c)\n+  {\n+    if (c.isOpaque() && UIManager.get(\"MenuBar.gradient\") != null)\n+      {\n+        MetalUtils.paintGradient(g, 0, 0, c.getWidth(), c.getHeight(),\n+                                 SwingConstants.VERTICAL, \"MenuBar.gradient\");\n+        paint(g, c);\n+      }\n+    else\n+      super.update(g, c);\n+  }\n+\n+}"}, {"sha": "de71fe8e5b2a468f8943d5721b485319ecb67025", "filename": "libjava/classpath/javax/swing/plaf/metal/MetalRadioButtonUI.java", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalRadioButtonUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalRadioButtonUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalRadioButtonUI.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -46,7 +46,6 @@\n import javax.swing.AbstractButton;\n import javax.swing.JComponent;\n import javax.swing.JRadioButton;\n-import javax.swing.UIDefaults;\n import javax.swing.UIManager;\n import javax.swing.plaf.ComponentUI;\n import javax.swing.plaf.basic.BasicRadioButtonUI;\n@@ -96,10 +95,9 @@ public static ComponentUI createUI(JComponent component)\n   public void installDefaults(AbstractButton b)\n   {\n     super.installDefaults(b);\n-    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n-    disabledTextColor = defaults.getColor(\"RadioButton.disabledText\");\n-    focusColor = defaults.getColor(\"RadioButton.focus\");\n-    selectColor = defaults.getColor(\"RadioButton.select\");\n+    disabledTextColor = UIManager.getColor(\"RadioButton.disabledText\");\n+    focusColor = UIManager.getColor(\"RadioButton.focus\");\n+    selectColor = UIManager.getColor(\"RadioButton.select\");\n   }\n   \n   /**\n@@ -118,7 +116,7 @@ protected void uninstallDefaults(AbstractButton b)\n   /**\n    * Returns the color used to fill the {@link JRadioButton}'s icon when the\n    * button is pressed.  The default color is obtained from the \n-   * {@link UIDefaults} via an entry with the key \n+   * {@link UIManager} defaults via an entry with the key \n    * <code>RadioButton.select</code>.\n    * \n    * @return The select color.\n@@ -130,8 +128,8 @@ protected Color getSelectColor()\n   \n   /**\n    * Returns the color for the {@link JRadioButton}'s text when the button is\n-   * disabled.  The default color is obtained from the {@link UIDefaults} via \n-   * an entry with the key <code>RadioButton.disabledText</code>.\n+   * disabled.  The default color is obtained from the {@link UIManager}\n+   * defaults via an entry with the key <code>RadioButton.disabledText</code>.\n    * \n    * @return The disabled text color.\n    */\n@@ -143,7 +141,7 @@ protected Color getDisabledTextColor()\n   /**\n    * Returns the color used to draw the focus rectangle when the \n    * {@link JRadioButton} has the focus.  The default color is obtained from \n-   * the {@link UIDefaults} via an entry with the key \n+   * the {@link UIManager} defaults via an entry with the key \n    * <code>RadioButton.focus</code>.\n    * \n    * @return The color used to draw the focus rectangle."}, {"sha": "0ff501f89a9d54591fbdac4859cefaa52c3f25ab", "filename": "libjava/classpath/javax/swing/plaf/metal/MetalScrollBarUI.java", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalScrollBarUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalScrollBarUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalScrollBarUI.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -48,7 +48,6 @@\n import javax.swing.JButton;\n import javax.swing.JComponent;\n import javax.swing.JScrollBar;\n-import javax.swing.UIDefaults;\n import javax.swing.UIManager;\n import javax.swing.plaf.ComponentUI;\n import javax.swing.plaf.basic.BasicScrollBarUI;\n@@ -195,8 +194,7 @@ protected PropertyChangeListener createPropertyChangeListener()\n    */\n   protected JButton createDecreaseButton(int orientation)\n   {\n-    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n-    scrollBarWidth = defaults.getInt(\"ScrollBar.width\");\n+    scrollBarWidth = UIManager.getInt(\"ScrollBar.width\");\n     decreaseButton = new MetalScrollButton(orientation, scrollBarWidth, \n             isFreeStanding);\n     return decreaseButton;\n@@ -213,8 +211,7 @@ protected JButton createDecreaseButton(int orientation)\n    */\n   protected JButton createIncreaseButton(int orientation)\n   {\n-    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n-    scrollBarWidth = defaults.getInt(\"ScrollBar.width\");\n+    scrollBarWidth = UIManager.getInt(\"ScrollBar.width\");\n     increaseButton = new MetalScrollButton(orientation, scrollBarWidth, \n             isFreeStanding);\n     return increaseButton;\n@@ -403,8 +400,7 @@ private void paintThumbHorizontal(Graphics g, JComponent c,\n       }\n     \n     // draw the shadow line\n-    UIDefaults def = UIManager.getLookAndFeelDefaults();\n-    g.setColor(def.getColor(\"ScrollBar.shadow\"));\n+    g.setColor(UIManager.getColor(\"ScrollBar.shadow\"));\n     g.drawLine(x + w, y + 1, x + w, y + h - 1);\n \n   }\n@@ -456,8 +452,7 @@ private void paintThumbVertical(Graphics g, JComponent c,\n       }\n     \n     // draw the shadow line\n-    UIDefaults def = UIManager.getLookAndFeelDefaults();\n-    g.setColor(def.getColor(\"ScrollBar.shadow\"));\n+    g.setColor(UIManager.getColor(\"ScrollBar.shadow\"));\n     g.drawLine(x + 1, y + h, x + w - 2, y + h);\n   }\n   "}, {"sha": "dbcc0910d4664cfc88011702bf8a0f407aa3b636", "filename": "libjava/classpath/javax/swing/plaf/metal/MetalSplitPaneUI.java", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalSplitPaneUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalSplitPaneUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalSplitPaneUI.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -42,7 +42,6 @@\n \n import javax.swing.JComponent;\n import javax.swing.JSplitPane;\n-import javax.swing.UIDefaults;\n import javax.swing.UIManager;\n import javax.swing.plaf.ComponentUI;\n import javax.swing.plaf.basic.BasicSplitPaneDivider;\n@@ -83,9 +82,8 @@ public static ComponentUI createUI(JComponent component)\n    */\n   public BasicSplitPaneDivider createDefaultDivider()\n   {\n-    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n-    Color light = defaults.getColor(\"SplitPane.highlight\");\n-    Color dark = defaults.getColor(\"SplitPane.darkShadow\");\n+    Color light = UIManager.getColor(\"SplitPane.highlight\");\n+    Color dark = UIManager.getColor(\"SplitPane.darkShadow\");\n     return new MetalSplitPaneDivider(this, light, dark);\n   }\n }"}, {"sha": "0b56d59144286ecbe81abc63c3bd5b4ff76d70c1", "filename": "libjava/classpath/javax/swing/plaf/metal/MetalToggleButtonUI.java", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalToggleButtonUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalToggleButtonUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalToggleButtonUI.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -47,8 +47,8 @@\n import javax.swing.AbstractButton;\n import javax.swing.JComponent;\n import javax.swing.JToggleButton;\n+import javax.swing.SwingConstants;\n import javax.swing.SwingUtilities;\n-import javax.swing.UIDefaults;\n import javax.swing.UIManager;\n import javax.swing.plaf.ComponentUI;\n import javax.swing.plaf.basic.BasicButtonUI;\n@@ -131,10 +131,9 @@ protected Color getDisabledTextColor()\n   public void installDefaults(AbstractButton b)\n   {\n     super.installDefaults(b);\n-    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n-    focusColor = defaults.getColor(getPropertyPrefix() + \"focus\");\n-    selectColor = defaults.getColor(getPropertyPrefix() + \"select\");\n-    disabledTextColor = defaults.getColor(getPropertyPrefix() + \"disabledText\");\n+    focusColor = UIManager.getColor(getPropertyPrefix() + \"focus\");\n+    selectColor = UIManager.getColor(getPropertyPrefix() + \"select\");\n+    disabledTextColor = UIManager.getColor(getPropertyPrefix() + \"disabledText\");\n   }\n   \n   /**\n@@ -200,5 +199,23 @@ protected void paintFocus(Graphics g, AbstractButton b, Rectangle viewRect,\n     g.drawRect(fr.x - 1, fr.y - 1, fr.width + 1, fr.height + 1);\n     g.setColor(saved);    \n   }\n+\n+  /**\n+   * If the property <code>ToggleButton.gradient</code> is set, then a gradient\n+   * is painted as background, otherwise the normal superclass behaviour is\n+   * called.\n+   */\n+  public void update(Graphics g, JComponent c)\n+  {\n+    if (c.isOpaque() && UIManager.get(getPropertyPrefix() + \"gradient\") != null)\n+      {\n+        MetalUtils.paintGradient(g, 0, 0, c.getWidth(), c.getHeight(),\n+                                 SwingConstants.VERTICAL,\n+                                 getPropertyPrefix() + \"gradient\");\n+        paint(g, c);\n+      }\n+    else\n+      super.update(g, c);\n+  }\n   \n }"}, {"sha": "f183ed5a14963da734b3c47fd0e10d16a3c4a657", "filename": "libjava/classpath/javax/swing/plaf/metal/MetalToolTipUI.java", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalToolTipUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalToolTipUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalToolTipUI.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -56,7 +56,6 @@\n import javax.swing.KeyStroke;\n import javax.swing.SwingConstants;\n import javax.swing.SwingUtilities;\n-import javax.swing.UIDefaults;\n import javax.swing.UIManager;\n import javax.swing.border.Border;\n import javax.swing.plaf.ComponentUI;\n@@ -107,13 +106,12 @@\n   public MetalToolTipUI()\n   {\n     super();\n-    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n-    activeBorder = defaults.getBorder(\"ToolTip.border\");\n-    inactiveBorder = defaults.getBorder(\"ToolTip.borderInactive\");\n-    isAcceleratorHidden = defaults.getBoolean(\"ToolTip.hideAccelerator\");\n-    acceleratorFont = defaults.getFont(\"MenuItem.acceleratorFont\");\n-    acceleratorForeground = defaults.getColor(\"MenuItem.acceleratorForeground\");\n-    acceleratorDelimiter = defaults.getString(\"MenuItem.acceleratorDelimiter\");\n+    activeBorder = UIManager.getBorder(\"ToolTip.border\");\n+    inactiveBorder = UIManager.getBorder(\"ToolTip.borderInactive\");\n+    isAcceleratorHidden = UIManager.getBoolean(\"ToolTip.hideAccelerator\");\n+    acceleratorFont = UIManager.getFont(\"MenuItem.acceleratorFont\");\n+    acceleratorForeground = UIManager.getColor(\"MenuItem.acceleratorForeground\");\n+    acceleratorDelimiter = UIManager.getString(\"MenuItem.acceleratorDelimiter\");\n   }\n \n   /**"}, {"sha": "24432a2b5f67a8a4eca0e2e6a11315e7a49a197e", "filename": "libjava/classpath/javax/swing/plaf/metal/MetalTreeUI.java", "status": "modified", "additions": 4, "deletions": 117, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalTreeUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalTreeUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalTreeUI.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -41,24 +41,10 @@\n import java.awt.Graphics;\n import java.awt.Insets;\n import java.awt.Rectangle;\n-import java.awt.event.ComponentListener;\n-import java.awt.event.FocusListener;\n-import java.awt.event.KeyListener;\n-import java.awt.event.MouseListener;\n-import java.beans.PropertyChangeListener;\n-import java.util.Hashtable;\n \n import javax.swing.JComponent;\n import javax.swing.JTree;\n-import javax.swing.UIDefaults;\n-import javax.swing.UIManager;\n-import javax.swing.tree.TreeCellEditor;\n-import javax.swing.tree.TreeModel;\n import javax.swing.tree.TreePath;\n-import javax.swing.event.CellEditorListener;\n-import javax.swing.event.TreeExpansionListener;\n-import javax.swing.event.TreeModelListener;\n-import javax.swing.event.TreeSelectionListener;\n import javax.swing.plaf.ComponentUI;\n import javax.swing.plaf.basic.BasicTreeUI;\n \n@@ -67,19 +53,6 @@\n  */\n public class MetalTreeUI extends BasicTreeUI\n {\n-\n-  /** Listeners */\n-  private PropertyChangeListener propertyChangeListener;\n-  private FocusListener focusListener;\n-  private TreeSelectionListener treeSelectionListener;\n-  private MouseListener mouseListener;\n-  private KeyListener keyListener;\n-  private PropertyChangeListener selectionModelPropertyChangeListener;\n-  private ComponentListener componentListener;\n-  private CellEditorListener cellEditorListener;\n-  private TreeExpansionListener treeExpansionListener;\n-  private TreeModelListener treeModelListener;\n-    \n   /**\n    * Constructs a new instance of <code>MetalTreeUI</code>.\n    */\n@@ -128,71 +101,8 @@ protected int getHorizontalLegBuffer()\n    */\n   public void installUI(JComponent c)\n   {\n-    tree = (JTree) c;\n-    configureLayoutCache();\n-    \n-    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n-    tree.setFont(defaults.getFont(\"Tree.font\"));\n-    tree.setForeground(defaults.getColor(\"Tree.foreground\"));\n-    tree.setBackground(defaults.getColor(\"Tree.background\"));\n-    tree.setOpaque(true);\n-    tree.setScrollsOnExpand(defaults.getBoolean(\"Tree.scrollsOnExpand\"));\n-    rightChildIndent = defaults.getInt(\"Tree.rightChildIndent\");\n-    leftChildIndent = defaults.getInt(\"Tree.leftChildIndent\");\n-    setRowHeight(defaults.getInt(\"Tree.rowHeight\"));\n-    tree.setRowHeight(defaults.getInt(\"Tree.rowHeight\"));\n-    tree.requestFocusInWindow(false);\n-    \n-    setExpandedIcon(defaults.getIcon(\"Tree.expandedIcon\"));\n-    setCollapsedIcon(defaults.getIcon(\"Tree.collapsedIcon\"));\n-    \n-    currentCellRenderer = createDefaultCellRenderer();\n-    rendererPane = createCellRendererPane();\n-    createdRenderer = true;\n-    setCellEditor(createDefaultCellEditor());\n-    createdCellEditor = true;\n-    TreeModel mod = tree.getModel();\n-    setModel(mod);\n-\n-    treeSelectionModel = tree.getSelectionModel();\n-    drawingCache = new Hashtable();\n-    nodeDimensions = createNodeDimensions();\n-    \n-    propertyChangeListener = createPropertyChangeListener();\n-    focusListener = createFocusListener();\n-    treeSelectionListener = createTreeSelectionListener();\n-    mouseListener = createMouseListener();\n-    keyListener = createKeyListener();\n-    selectionModelPropertyChangeListener = createSelectionModelPropertyChangeListener();\n-    componentListener = createComponentListener();\n-    cellEditorListener = createCellEditorListener();\n-    treeExpansionListener = createTreeExpansionListener();\n-    treeModelListener = createTreeModelListener();\n-\n-    editingRow = -1;\n-    lastSelectedRow = -1;\n-    \n-    installKeyboardActions();\n-    \n-    tree.addPropertyChangeListener(propertyChangeListener);\n-    tree.addFocusListener(focusListener);\n-    tree.addTreeSelectionListener(treeSelectionListener);\n-    tree.addMouseListener(mouseListener);\n-    tree.addKeyListener(keyListener);\n-    tree.addPropertyChangeListener(selectionModelPropertyChangeListener);\n-    tree.addComponentListener(componentListener);\n-    tree.addTreeExpansionListener(treeExpansionListener);\n-    if (treeModel != null)\n-      treeModel.addTreeModelListener(treeModelListener);\n-    \n-    if (mod != null)\n-      {\n-        TreePath path = new TreePath(mod.getRoot());\n-        if (!tree.isExpanded(path))\n-          toggleExpandState(path);\n-      }\n-    \n-    completeUIInstall();\n+    // TODO: What to do here, if anything?\n+    super.installUI(c);\n   }\n   \n   /**\n@@ -212,31 +122,8 @@ public void installUI(JComponent c)\n    */\n   public void uninstallUI(JComponent c)\n   {\n-    tree.setFont(null);\n-    tree.setForeground(null);\n-    tree.setBackground(null);\n-    \n-    uninstallKeyboardActions();\n-    \n-    tree.removePropertyChangeListener(propertyChangeListener);\n-    tree.removeFocusListener(focusListener);\n-    tree.removeTreeSelectionListener(treeSelectionListener);\n-    tree.removeMouseListener(mouseListener);\n-    tree.removeKeyListener(keyListener);\n-    tree.removePropertyChangeListener(selectionModelPropertyChangeListener);\n-    tree.removeComponentListener(componentListener);\n-    tree.removeTreeExpansionListener(treeExpansionListener);\n-\n-    TreeCellEditor tce = tree.getCellEditor();\n-    if (tce != null)\n-      tce.removeCellEditorListener(cellEditorListener);\n-    TreeModel tm = tree.getModel();\n-    if (tm != null)\n-      tm.removeTreeModelListener(treeModelListener);\n-    \n-    tree = null;\n-    uninstallComponents();\n-    completeUIUninstall();\n+    // TODO: What to do here?\n+    super.uninstallUI(c);\n   }\n   \n   /**"}, {"sha": "50112ce21612f36c4ddebf11a209f93098fe636a", "filename": "libjava/classpath/javax/swing/plaf/metal/MetalUtils.java", "status": "modified", "additions": 252, "deletions": 0, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalUtils.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalUtils.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalUtils.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -44,6 +44,10 @@\n import java.awt.TexturePaint;\n import java.awt.geom.Rectangle2D;\n import java.awt.image.BufferedImage;\n+import java.util.List;\n+\n+import javax.swing.SwingConstants;\n+import javax.swing.UIManager;\n \n /**\n  * Some utility and helper methods for the Metal Look &amp; Feel.\n@@ -151,4 +155,252 @@ static void initializePattern(Color light, Color dark)\n     g.fillRect(3, 3, 1, 1);\n     g.dispose();\n   }\n+\n+  /**\n+   * Paints the typical Metal gradient. See {@link #paintGradient(Graphics,\n+   * int, int, int, int, double, double, Color, Color, Color, int)}\n+   * for more details.\n+   *\n+   * The parameters are fetched from the UIManager using the key\n+   * <code>uiProp</code>. The value is expected to be a {@link List} that\n+   * contains 4 values: two {@link Double}s and 3 {@link Color} object that\n+   * together make up the parameters passed to the painting method.\n+   * \n+   * @param g the graphics context to use\n+   * @param x the X coordinate of the upper left corner of the rectangle\n+   * @param y the Y coordinate of the upper left corner of the rectangle\n+   * @param w the width of the rectangle\n+   * @param h the height of the rectangle\n+   * @param dir the direction of the gradient, either\n+   * @param uiProp the key of the UIManager property that has the parameters\n+   */\n+  static void paintGradient(Graphics g, int x, int y, int w, int h,\n+                            int dir, String uiProp)\n+  {\n+    List params = (List) UIManager.get(uiProp);\n+    double g1 = ((Double) params.get(0)).doubleValue();\n+    double g2 = ((Double) params.get(1)).doubleValue();\n+    Color c1 = (Color) params.get(2);\n+    Color c2 = (Color) params.get(3);\n+    Color c3 = (Color) params.get(4);\n+    paintGradient(g, x, y, w, h, g1, g2, c1, c2, c3, dir);\n+  }\n+\n+  /**\n+   * Paints the typical Metal gradient. The gradient is painted as follows:\n+   * <pre>\n+   * \n+   * +-------+--------+--------+-----------------------------+\n+   * |       |        |        |                             |\n+   * +-------+--------+--------+-----------------------------+\n+   * c1  ->  c2  --   c2  ->   c1         -------->          c3\n+   * < -g1- > < -g2- > < -g1- >\n+   * </pre>\n+   * \n+   * There are 4 distinct areas in this gradient:\n+   * <ol>\n+   * <li>A gradient from color 1 to color 2 with the relative width specified\n+   *   by <code>g1</code></li>\n+   * <li>A solid area with the color 2 and the relative width specified by\n+   *  <code>g2</code></li>\n+   * <li>A gradient from color 2 to color 1 with the relative width specified\n+   *   by <code>g1</code></li>\n+   *\n+   * @param g the graphics context to use\n+   * @param x the X coordinate of the upper left corner of the rectangle\n+   * @param y the Y coordinate of the upper left corner of the rectangle\n+   * @param w the width of the rectangle\n+   * @param h the height of the rectangle\n+   * @param g1 the relative width of the c1->c2 gradients\n+   * @param g2 the relative width of the c2 solid area\n+   * @param c1 the color 1\n+   * @param c2 the color 2\n+   * @param c3 the color 3\n+   * @param dir the direction of the gradient, either\n+   *        {@link SwingConstants#HORIZONTAL} or {@link SwingConstants#VERTICAL}\n+   */\n+  static void paintGradient(Graphics g, int x, int y, int w, int h, double g1,\n+                            double g2, Color c1, Color c2, Color c3, int dir)\n+  {\n+    if (dir == SwingConstants.HORIZONTAL)\n+      paintHorizontalGradient(g, x, y, w, h, g1, g2, c1, c2, c3);\n+    else\n+      paintVerticalGradient(g, x, y, w, h, g1, g2, c1, c2, c3);\n+  }\n+\n+  /**\n+   * Paints a horizontal gradient. See {@link #paintGradient(Graphics, int,\n+   * int, int, int, double, double, Color, Color, Color, int)} for details.\n+   *\n+   * @param x the X coordinate of the upper left corner of the rectangle\n+   * @param y the Y coordinate of the upper left corner of the rectangle\n+   * @param w the width of the rectangle\n+   * @param h the height of the rectangle\n+   * @param g1 the relative width of the c1->c2 gradients\n+   * @param g2 the relative width of the c2 solid area\n+   * @param c1 the color 1\n+   * @param c2 the color 2\n+   * @param c3 the color 3\n+   */\n+  static void paintHorizontalGradient(Graphics g, int x, int y, int w, int h,\n+                                      double g1, double g2, Color c1, Color c2,\n+                                      Color c3)\n+  {\n+    // Calculate the coordinates.\n+    // The size of the first gradient area (c1->2).\n+    int w1 = (int) (w * g1);\n+    // The size of the solid c2 area.\n+    int w2 = (int) (w * g2);\n+    int x0 = x;\n+    int x1 = x0 + w1;\n+    int x2 = x1 + w2;\n+    int x3 = x2 + w1;\n+    int x4 = x + w;\n+\n+    // Paint first gradient area (c1->c2).\n+    int xc; // The current y coordinate.\n+    for (xc = x0; xc < x1; xc++)\n+      {\n+        if (xc > x + w)\n+          break;\n+\n+        // Perform color interpolation;\n+        double factor = (xc - x0) / (double) w1;\n+        int rInt = (int) ((c2.getRed() - c1.getRed()) * factor + c1.getRed());\n+        int gInt = (int) ((c2.getGreen() - c1.getGreen()) * factor\n+            + c1.getGreen());\n+        int bInt = (int) ((c2.getBlue() - c1.getBlue()) * factor\n+            + c1.getBlue());\n+        Color interpolated = new Color(rInt, gInt, bInt);\n+        g.setColor(interpolated);\n+        g.drawLine(xc, y, xc, y + h);\n+      }\n+    // Paint solid c2 area.\n+    g.setColor(c2);\n+    g.fillRect(x1, y, x2 - x1, h);\n+\n+    // Paint second gradient area (c2->c1).\n+    for (xc = x2; xc < x3; xc++)\n+      {\n+        if (xc > x + w)\n+          break;\n+\n+        // Perform color interpolation;\n+        double factor = (xc - x2) / (double) w1;\n+        int rInt = (int) ((c1.getRed() - c2.getRed()) * factor + c2.getRed());\n+        int gInt = (int) ((c1.getGreen() - c2.getGreen()) * factor\n+            + c2.getGreen());\n+        int bInt = (int) ((c1.getBlue() - c2.getBlue()) * factor\n+            + c2.getBlue());\n+        Color interpolated = new Color(rInt, gInt, bInt);\n+        g.setColor(interpolated);\n+        g.drawLine(xc, y, xc, y + h);\n+      }\n+\n+    // Paint third gradient area (c1->c3).\n+    for (xc = x3; xc < x4; xc++)\n+      {\n+        if (xc > x + w)\n+          break;\n+\n+        // Perform color interpolation;\n+        double factor = (xc - x3) / (double) (x4 - x3);\n+        int rInt = (int) ((c3.getRed() - c1.getRed()) * factor + c1.getRed());\n+        int gInt = (int) ((c3.getGreen() - c1.getGreen()) * factor\n+            + c1.getGreen());\n+        int bInt = (int) ((c3.getBlue() - c1.getBlue()) * factor\n+            + c1.getBlue());\n+        Color interpolated = new Color(rInt, gInt, bInt);\n+        g.setColor(interpolated);\n+        g.drawLine(xc, y, xc, y + h);\n+      }\n+  }\n+\n+  /**\n+   * Paints a vertical gradient. See {@link #paintGradient(Graphics, int, int,\n+   * int, int, double, double, Color, Color, Color, int)} for details.\n+   *\n+   * @param x the X coordinate of the upper left corner of the rectangle\n+   * @param y the Y coordinate of the upper left corner of the rectangle\n+   * @param w the width of the rectangle\n+   * @param h the height of the rectangle\n+   * @param g1 the relative width of the c1->c2 gradients\n+   * @param g2 the relative width of the c2 solid area\n+   * @param c1 the color 1\n+   * @param c2 the color 2\n+   * @param c3 the color 3\n+   */\n+  static void paintVerticalGradient(Graphics g, int x, int y, int w, int h,\n+                                    double g1, double g2, Color c1, Color c2,\n+                                    Color c3)\n+  {\n+    // Calculate the coordinates.\n+    // The size of the first gradient area (c1->2).\n+    int w1 = (int) (h * g1);\n+    // The size of the solid c2 area.\n+    int w2 = (int) (h * g2);\n+    int y0 = y;\n+    int y1 = y0 + w1;\n+    int y2 = y1 + w2;\n+    int y3 = y2 + w1;\n+    int y4 = y + h;\n+\n+    // Paint first gradient area (c1->c2).\n+    int yc; // The current y coordinate.\n+    for (yc = y0; yc < y1; yc++)\n+      {\n+        if (yc > y + h)\n+          break;\n+\n+        // Perform color interpolation;\n+        double factor = (yc - y0) / (double) w1;\n+        int rInt = (int) ((c2.getRed() - c1.getRed()) * factor + c1.getRed());\n+        int gInt = (int) ((c2.getGreen() - c1.getGreen()) * factor\n+            + c1.getGreen());\n+        int bInt = (int) ((c2.getBlue() - c1.getBlue()) * factor\n+            + c1.getBlue());\n+        Color interpolated = new Color(rInt, gInt, bInt);\n+        g.setColor(interpolated);\n+        g.drawLine(x, yc, x + w, yc);\n+      }\n+    // Paint solid c2 area.\n+    g.setColor(c2);\n+    g.fillRect(x, y1, w, y2 - y1);\n+\n+    // Paint second gradient area (c2->c1).\n+    for (yc = y2; yc < y3; yc++)\n+      {\n+        if (yc > y + h)\n+          break;\n+\n+        // Perform color interpolation;\n+        double factor = (yc - y2) / (double) w1;\n+        int rInt = (int) ((c1.getRed() - c2.getRed()) * factor + c2.getRed());\n+        int gInt = (int) ((c1.getGreen() - c2.getGreen()) * factor\n+            + c2.getGreen());\n+        int bInt = (int) ((c1.getBlue() - c2.getBlue()) * factor\n+            + c2.getBlue());\n+        Color interpolated = new Color(rInt, gInt, bInt);\n+        g.setColor(interpolated);\n+        g.drawLine(x, yc, x + w, yc);\n+      }\n+\n+    // Paint third gradient area (c1->c3).\n+    for (yc = y3; yc < y4; yc++)\n+      {\n+        if (yc > y + h)\n+          break;\n+\n+        // Perform color interpolation;\n+        double factor = (yc - y3) / (double) (y4 - y3);\n+        int rInt = (int) ((c3.getRed() - c1.getRed()) * factor + c1.getRed());\n+        int gInt = (int) ((c3.getGreen() - c1.getGreen()) * factor\n+            + c1.getGreen());\n+        int bInt = (int) ((c3.getBlue() - c1.getBlue()) * factor\n+            + c1.getBlue());\n+        Color interpolated = new Color(rInt, gInt, bInt);\n+        g.setColor(interpolated);\n+        g.drawLine(x, yc, x + w, yc);\n+      }\n+  }\n }"}, {"sha": "f1886b167cf8b58046be30ac16dda2ed478a8f38", "filename": "libjava/classpath/javax/swing/plaf/metal/OceanTheme.java", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FOceanTheme.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FOceanTheme.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FOceanTheme.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -37,6 +37,9 @@\n \n package javax.swing.plaf.metal;\n \n+import java.awt.Color;\n+import java.util.Arrays;\n+\n import javax.swing.UIDefaults;\n import javax.swing.plaf.ColorUIResource;\n \n@@ -204,6 +207,37 @@ protected ColorUIResource getSecondary3()\n    */\n   public void addCustomEntriesToTable(UIDefaults defaults)\n   {\n+    defaults.put(\"Button.gradient\", Arrays.asList(new Object[]\n+      {new Double(0.3), new Double(0.0), new ColorUIResource(221, 232, 243),\n+       new ColorUIResource(Color.WHITE), new ColorUIResource(184, 207, 229)}));\n+    defaults.put(\"CheckBox.gradient\", Arrays.asList(new Object[]\n+      {new Double(0.3), new Double(0.0), new ColorUIResource(221, 232, 243),\n+       new ColorUIResource(Color.WHITE), new ColorUIResource(184, 207, 229)}));\n+    defaults.put(\"CheckBoxMenuItem.gradient\", Arrays.asList(new Object[]\n+      {new Double(0.3), new Double(0.0), new ColorUIResource(221, 232, 243),\n+       new ColorUIResource(Color.WHITE), new ColorUIResource(184, 207, 229)}));\n+    defaults.put(\"MenuBar.gradient\", Arrays.asList(new Object[]\n+      {new Double(1.0), new Double(0.0), new ColorUIResource(Color.WHITE),\n+      new ColorUIResource(218, 218, 218), new ColorUIResource(218, 218, 218)}));\n+    defaults.put(\"RadioButton.gradient\", Arrays.asList(new Object[]\n+      {new Double(0.3), new Double(0.0), new ColorUIResource(221, 232, 243),\n+       new ColorUIResource(Color.WHITE), new ColorUIResource(184, 207, 229)}));\n+    defaults.put(\"RadioButtonMenuItem.gradient\", Arrays.asList(new Object[]\n+      {new Double(0.3), new Double(0.0), new ColorUIResource(221, 232, 243),\n+       new ColorUIResource(Color.WHITE), new ColorUIResource(184, 207, 229)}));\n+    defaults.put(\"ScrollBar.gradient\", Arrays.asList(new Object[]\n+      {new Double(1.0), new Double(0.0), new ColorUIResource(Color.WHITE),\n+       new ColorUIResource(218, 218, 218), new ColorUIResource(218, 218, 218)}));\n+    defaults.put(\"Slider.gradient\", Arrays.asList(new Object[]\n+      {new Double(0.3), new Double(0.2), new ColorUIResource(200, 221, 242),\n+       new ColorUIResource(Color.WHITE), new ColorUIResource(184, 207, 229)}));\n+    defaults.put(\"ToggleButton.gradient\", Arrays.asList(new Object[]\n+      {new Double(0.3), new Double(0.0), new ColorUIResource(221, 232, 243),\n+       new ColorUIResource(Color.WHITE), new ColorUIResource(184, 207, 229)}));\n+    defaults.put(\"InternalFrame.activeTitleGradient\", Arrays.asList(new Object[]\n+      {new Double(0.3), new Double(0.0), new ColorUIResource(221, 232, 243),\n+       new ColorUIResource(Color.WHITE), new ColorUIResource(184, 207, 229)}));\n+\n     defaults.put(\"Button.rollover\", Boolean.TRUE);\n   }\n }"}, {"sha": "a324425562ef23c284c3c6708e1f4571cdfa80b9", "filename": "libjava/classpath/javax/swing/text/AbstractDocument.java", "status": "modified", "additions": 4, "deletions": 24, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FAbstractDocument.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FAbstractDocument.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FAbstractDocument.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -672,20 +672,8 @@ public void remove(int offset, int length) throws BadLocationException\n       new DefaultDocumentEvent(offset, length,\n \t\t\t       DocumentEvent.EventType.REMOVE);\n     \n-    // Here we set up the parameters for an ElementChange, if one\n-    // needs to be added to the DocumentEvent later\n-    Element root = getDefaultRootElement();\n-    int start = root.getElementIndex(offset);\n-    int end = root.getElementIndex(offset + length);\n-    \n-    Element[] removed = new Element[end - start + 1];\n-    for (int i = start; i <= end; i++)\n-      removed[i - start] = root.getElement(i);\n-    \n     removeUpdate(event);\n \n-    Element[] added = new Element[1];\n-    added[0] = root.getElement(start);\n     boolean shouldFire = content.getString(offset, length).length() != 0;\n     \n     writeLock();\n@@ -694,17 +682,6 @@ public void remove(int offset, int length) throws BadLocationException\n     \n     postRemoveUpdate(event);\n     \n-    GapContent.UndoRemove changes = null;\n-    if (content instanceof GapContent)\n-      changes = (GapContent.UndoRemove) temp;\n-\n-    if (changes != null && !(start == end))\n-      {\n-        // We need to add an ElementChange to our DocumentEvent\n-        ElementEdit edit = new ElementEdit (root, start, removed, added);\n-        event.addEdit(edit);\n-      }\n-    \n     if (shouldFire)\n       fireRemoveUpdate(event);\n   }\n@@ -2143,7 +2120,10 @@ public int getEndOffset()\n      */\n     public String getName()\n     {\n-      return ContentElementName;\n+      String name = super.getName();\n+      if (name == null)\n+        name = ContentElementName;\n+      return name;\n     }\n \n     /**"}, {"sha": "5c9587dfe5d9580284d8b42d7e1a6a0c187a0fbb", "filename": "libjava/classpath/javax/swing/text/BoxView.java", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FBoxView.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FBoxView.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FBoxView.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -476,7 +476,6 @@ protected boolean isAfter(int x, int y, Rectangle r)\n   protected View getViewAtPoint(int x, int y, Rectangle r)\n   {\n     View result = null;\n-\n     int count = getViewCount();\n     Rectangle copy = new Rectangle(r);\n \n@@ -490,18 +489,22 @@ protected View getViewAtPoint(int x, int y, Rectangle r)\n             break;\n           }\n       }\n-\n+    \n+    if (result == null && count > 0)\n+      return getView(count - 1);\n     return result;\n   }\n \n   /**\n    * Computes the allocation for a child <code>View</code>. The parameter\n    * <code>a</code> stores the allocation of this <code>CompositeView</code>\n    * and is then adjusted to hold the allocation of the child view.\n-   *\n-   * @param index the index of the child <code>View</code>\n-   * @param a the allocation of this <code>CompositeView</code> before the\n-   *        call, the allocation of the child on exit\n+   * \n+   * @param index\n+   *          the index of the child <code>View</code>\n+   * @param a\n+   *          the allocation of this <code>CompositeView</code> before the\n+   *          call, the allocation of the child on exit\n    */\n   protected void childAllocation(int index, Rectangle a)\n   {\n@@ -737,4 +740,22 @@ public void preferenceChanged (View child, boolean width, boolean height)\n       yLayoutValid = false;\n     super.preferenceChanged(child, width, height);\n   }\n+  \n+  /**\n+   * Maps the document model position <code>pos</code> to a Shape\n+   * in the view coordinate space.  This method overrides CompositeView's\n+   * method to make sure the children are allocated properly before\n+   * calling the super's behaviour.\n+   */\n+  public Shape modelToView(int pos, Shape a, Position.Bias bias)\n+      throws BadLocationException\n+  {\n+    // Make sure everything is allocated properly and then call super\n+    if (!isAllocationValid())\n+      {\n+        Rectangle bounds = a.getBounds();\n+        setSize(bounds.width, bounds.height);\n+      }\n+    return super.modelToView(pos, a, bias);\n+  }\n }"}, {"sha": "830dda3ecdc425771bebf0ae06f86ca25b110ddb", "filename": "libjava/classpath/javax/swing/text/ComponentView.java", "status": "modified", "additions": 117, "deletions": 31, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FComponentView.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FComponentView.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FComponentView.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -38,10 +38,13 @@\n package javax.swing.text;\n \n import java.awt.Component;\n+import java.awt.Container;\n import java.awt.Graphics;\n+import java.awt.Rectangle;\n import java.awt.Shape;\n \n import javax.swing.SwingConstants;\n+import javax.swing.SwingUtilities;\n \n /**\n  * A {@link View} implementation that is able to render arbitrary\n@@ -52,12 +55,17 @@\n  * this <code>ComponentView</code>, so this view must not be shared between\n  * multiple <code>JTextComponent</code>s.\n  *\n+ * @author Roman Kennke (kennke@aicas.com)\n  * @author original author unknown\n- * @author Roman Kennke (roman@kennke.org)\n  */\n-// FIXME: This class is a complete stub and needs to be implemented properly.\n public class ComponentView extends View\n {\n+\n+  /**\n+   * The component that is displayed by this view.\n+   */\n+  private Component comp;\n+\n   /**\n    * Creates a new instance of <code>ComponentView</code> for the specified\n    * <code>Element</code>.\n@@ -77,7 +85,7 @@ public ComponentView(Element elem)\n    *\n    * @return the component that is rendered\n    */\n-  protected  Component createComponent()\n+  protected Component createComponent()\n   {\n     return StyleConstants.getComponent(getElement().getAttributes());\n   }\n@@ -91,7 +99,14 @@ protected  Component createComponent()\n    */\n   public float getAlignment(int axis)\n   {\n-    return 0;\n+    float align;\n+    if (axis == X_AXIS)\n+      align = getComponent().getAlignmentX();\n+    else if (axis == Y_AXIS)\n+      align = getComponent().getAlignmentY();\n+    else\n+      throw new IllegalArgumentException();\n+    return align;\n   }\n \n   /**\n@@ -103,7 +118,9 @@ public float getAlignment(int axis)\n    */\n   public final Component getComponent()\n   {\n-    return null;\n+    if (comp == null)\n+      comp = createComponent();\n+    return comp;\n   }\n \n   /**\n@@ -118,49 +135,115 @@ public final Component getComponent()\n    */\n   public float getMaximumSpan(int axis)\n   {\n-    return 0;\n+    float span;\n+    if (axis == X_AXIS)\n+      span = getComponent().getMaximumSize().width;\n+    else if (axis == Y_AXIS)\n+      span = getComponent().getMaximumSize().height;\n+    else\n+      throw new IllegalArgumentException();\n+    return span;\n   }\n \n   public float getMinimumSpan(int axis)\n   {\n-    // TODO: Implement this properly.\n-    return 0;\n+    float span;\n+    if (axis == X_AXIS)\n+      span = getComponent().getMinimumSize().width;\n+    else if (axis == Y_AXIS)\n+      span = getComponent().getMinimumSize().height;\n+    else\n+      throw new IllegalArgumentException();\n+    return span;\n   }\n \n   public float getPreferredSpan(int axis)\n   {\n-    // TODO: Implement this properly.\n-    return 0;\n+    float span;\n+    if (axis == X_AXIS)\n+      span = getComponent().getPreferredSize().width;\n+    else if (axis == Y_AXIS)\n+      span = getComponent().getPreferredSize().height;\n+    else\n+      throw new IllegalArgumentException();\n+    return span;\n   }\n \n   public Shape modelToView(int pos, Shape a, Position.Bias b)\n     throws BadLocationException\n   {\n-    // TODO: Implement this properly.\n-    return null;\n+    Element el = getElement();\n+    if (pos < el.getStartOffset() || pos >= el.getEndOffset())\n+      throw new BadLocationException(\"Illegal offset for this view\", pos);\n+    Rectangle r = a.getBounds();\n+    Component c = getComponent();\n+    return new Rectangle(r.x, r.y, c.getWidth(), c.getHeight());\n   }\n-    \n+\n+  /**\n+   * The real painting behavour is performed by normal component painting,\n+   * triggered by the text component that hosts this view. This method does\n+   * not paint by itself. However, it sets the size of the component according\n+   * to the allocation that is passed here.\n+   *\n+   * @param g the graphics context\n+   * @param a the allocation of the child\n+   */\n   public void paint(Graphics g, Shape a)\n   {\n-    // TODO: Implement this properly.\n+    Rectangle r = a.getBounds();\n+    getComponent().setBounds(r.x, r.y, r.width, r.height);\n   }\n-  \n-  public void setParent(View p)\n+\n+  /**\n+   * This sets up the component when the view is added to its parent, or\n+   * cleans up the view when it is removed from its parent.\n+   *\n+   * When this view is added to a parent view, the component of this view\n+   * is added to the container that hosts this view. When <code>p</code> is\n+   * <code>null</code>, then the view is removed from it's parent and we have\n+   * to also remove the component from it's parent container.\n+   *\n+   * @param p the parent view or <code>null</code> if this view is removed\n+   *        from it's parent\n+   */\n+  public void setParent(final View p)\n   {\n-    // TODO: Implement this properly.\n+    if (SwingUtilities.isEventDispatchThread())\n+      setParentImpl(p);\n+    else\n+      SwingUtilities.invokeLater\n+      (new Runnable()\n+       {\n+         public void run()\n+         {\n+           setParentImpl(p);\n+         }\n+       });\n   }\n-    \n-  public void setSize(float width, float height)\n+\n+  /**\n+   * The implementation of {@link #setParent}. This is package private to\n+   * avoid a synthetic accessor method.\n+   *\n+   * @param p the parent view to set\n+   */\n+  void setParentImpl(View p)\n   {\n-    // TODO: Implement this properly.\n+    if (p != null)\n+      {\n+        Component c = getComponent();\n+        p.getContainer().add(c);\n+      }\n+    else\n+      {\n+        Component c = getComponent();\n+        Container parent = c.getParent();\n+        parent.remove(c);\n+        comp = null;\n+      }\n   }\n     \n-  public int viewToModel(float x, float y, Shape a, Position.Bias[] bias)\n-  {\n-    // TODO: Implement this properly.\n-    return 0;\n-  }\n-\n   /**\n    * Maps coordinates from the <code>View</code>'s space into a position\n    * in the document model.\n@@ -173,10 +256,13 @@ public int viewToModel(float x, float y, Shape a, Position.Bias[] bias)\n    * @return the position in the document that corresponds to the screen\n    *         coordinates <code>x, y</code>\n    */\n-  public int viewToModel(float x, float y, Shape a, Position.Bias b)\n+  public int viewToModel(float x, float y, Shape a, Position.Bias[] b)\n   {\n-    // FIXME: Implement this properly.\n-    return 0;\n+    // The element should only have one character position and it is clear\n+    // that this position is the position that best matches the given screen\n+    // coordinates, simply because this view has only this one position.\n+    Element el = getElement();\n+    return el.getStartOffset();\n   }\n \n   /**\n@@ -205,7 +291,7 @@ public int getNextVisualPositionFrom(JTextComponent c, int pos,\n                                        Position.Bias[] biasRet)\n     throws BadLocationException\n   {\n-    // TODO: Implement this properly.\n-    throw new AssertionError(\"Not implemented yet.\");\n+    // FIXME: Implement this method.\n+    throw new AssertionError(\"Not yet implemented\");\n   }\n }"}, {"sha": "e6c2e4cc2d8aff1e4db1d2aa890d17b93a363654", "filename": "libjava/classpath/javax/swing/text/CompositeView.java", "status": "modified", "additions": 37, "deletions": 31, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FCompositeView.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FCompositeView.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FCompositeView.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -264,50 +264,56 @@ public Shape modelToView(int p1, Position.Bias b1,\n    * Maps coordinates from the <code>View</code>'s space into a position\n    * in the document model.\n    *\n-   * @param x the x coordinate in the view space\n-   * @param y the y coordinate in the view space\n+   * @param x the x coordinate in the view space, x >= 0\n+   * @param y the y coordinate in the view space, y >= 0\n    * @param a the allocation of this <code>View</code>\n    * @param b the bias to use\n    *\n    * @return the position in the document that corresponds to the screen\n-   *         coordinates <code>x, y</code>\n+   *         coordinates <code>x, y</code> >= 0\n    */\n   public int viewToModel(float x, float y, Shape a, Position.Bias[] b)\n   {\n-    Rectangle r = getInsideAllocation(a);\n-    View view = getViewAtPoint((int) x, (int) y, r);\n-    return view.viewToModel(x, y, a, b);\n+    if (x >= 0 && y >= 0)\n+      {\n+        Rectangle r = getInsideAllocation(a);\n+        View view = getViewAtPoint((int) x, (int) y, r);\n+        return view.viewToModel(x, y, a, b);\n+      }\n+    return 0;\n   }\n \n   /**\n    * Returns the next model location that is visible in eiter north / south\n-   * direction or east / west direction. This is used to determine the\n-   * placement of the caret when navigating around the document with\n-   * the arrow keys.\n-   *\n-   * This is a convenience method for\n-   * {@link #getNextNorthSouthVisualPositionFrom} and\n-   * {@link #getNextEastWestVisualPositionFrom}.\n-   *\n-   * @param pos the model position to start search from\n-   * @param b the bias for <code>pos</code>\n-   * @param a the allocated region for this view\n-   * @param direction the direction from the current position, can be one of\n-   *        the following:\n-   *        <ul>\n-   *        <li>{@link SwingConstants#WEST}</li>\n-   *        <li>{@link SwingConstants#EAST}</li>\n-   *        <li>{@link SwingConstants#NORTH}</li>\n-   *        <li>{@link SwingConstants#SOUTH}</li>\n-   *        </ul>\n-   * @param biasRet the bias of the return value gets stored here\n-   *\n+   * direction or east / west direction. This is used to determine the placement\n+   * of the caret when navigating around the document with the arrow keys. This\n+   * is a convenience method for {@link #getNextNorthSouthVisualPositionFrom}\n+   * and {@link #getNextEastWestVisualPositionFrom}.\n+   * \n+   * @param pos\n+   *          the model position to start search from\n+   * @param b\n+   *          the bias for <code>pos</code>\n+   * @param a\n+   *          the allocated region for this view\n+   * @param direction\n+   *          the direction from the current position, can be one of the\n+   *          following:\n+   *          <ul>\n+   *          <li>{@link SwingConstants#WEST}</li>\n+   *          <li>{@link SwingConstants#EAST}</li>\n+   *          <li>{@link SwingConstants#NORTH}</li>\n+   *          <li>{@link SwingConstants#SOUTH}</li>\n+   *          </ul>\n+   * @param biasRet\n+   *          the bias of the return value gets stored here\n    * @return the position inside the model that represents the next visual\n    *         location\n-   *\n-   * @throws BadLocationException if <code>pos</code> is not a valid location\n-   *         inside the document model\n-   * @throws IllegalArgumentException if <code>direction</code> is invalid\n+   * @throws BadLocationException\n+   *           if <code>pos</code> is not a valid location inside the document\n+   *           model\n+   * @throws IllegalArgumentException\n+   *           if <code>direction</code> is invalid\n    */\n   public int getNextVisualPositionFrom(int pos, Position.Bias b, Shape a,\n                                        int direction, Position.Bias[] biasRet)"}, {"sha": "3ebeceb947de9512ba328cdcc9b39bed2f0fc720", "filename": "libjava/classpath/javax/swing/text/DefaultCaret.java", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FDefaultCaret.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FDefaultCaret.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FDefaultCaret.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -781,28 +781,34 @@ public int getDot()\n    */\n   public void moveDot(int dot)\n   {\n-    this.dot = dot;\n-    handleHighlight();\n-    adjustVisibility(this);\n-    appear();\n+    if (dot >= 0)\n+      {\n+        this.dot = dot;\n+        handleHighlight();\n+        adjustVisibility(this);\n+        appear();\n+      }\n   }\n \n   /**\n    * Sets the current position of this <code>Caret</code> within the\n-   * <code>Document</code>. This also sets the <code>mark</code> to the\n-   * new location.\n-   *\n-   * @param dot the new position to be set\n-   *\n+   * <code>Document</code>. This also sets the <code>mark</code> to the new\n+   * location.\n+   * \n+   * @param dot\n+   *          the new position to be set\n    * @see #moveDot(int)\n    */\n   public void setDot(int dot)\n   {\n-    this.dot = dot;\n-    this.mark = dot;\n-    handleHighlight();\n-    adjustVisibility(this);\n-    appear();\n+    if (dot >= 0)\n+      {\n+        this.mark = dot;\n+        this.dot = dot;\n+        handleHighlight();\n+        adjustVisibility(this);\n+        appear();\n+      }\n   }\n   \n   /**\n@@ -878,7 +884,7 @@ public void setVisible(boolean v)\n           }\n         Rectangle area = null;\n         try\n-          {\n+          {            \n             area = getComponent().modelToView(getDot());\n           }\n         catch (BadLocationException ex)"}, {"sha": "765f515a20d574d960c65085954e681606f5c975", "filename": "libjava/classpath/javax/swing/text/FlowView.java", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FFlowView.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FFlowView.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FFlowView.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -601,6 +601,9 @@ protected void layout(int width, int height)\n    */\n   public void insertUpdate(DocumentEvent changes, Shape a, ViewFactory vf)\n   {\n+    // First we must send the insertUpdate to the logical view so it can\n+    // be updated accordingly.\n+    layoutPool.insertUpdate(changes, a, vf);\n     strategy.insertUpdate(this, changes, getInsideAllocation(a));\n   }\n "}, {"sha": "d3dd75e624bd2e13f0ba89976a292b5aa5ef8120", "filename": "libjava/classpath/javax/swing/text/GlyphView.java", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FGlyphView.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FGlyphView.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FGlyphView.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -457,9 +457,6 @@ public int viewToModel(GlyphView v, float x, float y, Shape a,\n                            Bias[] biasRet)\n     {\n       Rectangle b = a.getBounds();\n-      assert b.contains(x, y) : \"The coordinates are expected to be within the \"\n-                                + \"view's bounds: x=\" + x + \", y=\" + y\n-                                + \"a=\" + a;\n       int pos = getBoundedPosition(v, v.getStartOffset(), b.x, x - b.x);\n       return pos;\n     }"}, {"sha": "86c27dd5fda0f639299d47aaf41ee06ec4135178", "filename": "libjava/classpath/javax/swing/text/IconView.java", "status": "modified", "additions": 39, "deletions": 8, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FIconView.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FIconView.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FIconView.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -39,11 +39,25 @@\n package javax.swing.text;\n \n import java.awt.Graphics;\n+import java.awt.Rectangle;\n import java.awt.Shape;\n \n+import javax.swing.Icon;\n+import javax.swing.JTextPane;\n import javax.swing.SwingConstants;\n \n-// TODO: Implement this class.\n+/**\n+ * A View that can render an icon. This view is created by the\n+ * {@link StyledEditorKit}'s view factory for all elements that have name\n+ * {@link StyleConstants#IconElementName}. This is usually created by\n+ * inserting an icon into <code>JTextPane</code> using\n+ * {@link JTextPane#insertIcon(Icon)}\n+ *\n+ * The icon is determined using the attribute\n+ * {@link StyleConstants#IconAttribute}, which's value must be an {@link Icon}.\n+ *\n+ * @author Roman Kennke (kennke@aicas.com)\n+ */\n public class IconView\n   extends View\n {\n@@ -67,7 +81,9 @@ public IconView(Element element)\n    */\n   public void paint(Graphics g, Shape a)\n   {\n-    // TODO: Implement me.\n+    Icon icon = StyleConstants.getIcon(getElement().getAttributes());\n+    Rectangle b = a.getBounds();\n+    icon.paintIcon(getContainer(), g, b.x, b.y);\n   }\n \n   /**\n@@ -80,8 +96,15 @@ public void paint(Graphics g, Shape a)\n    */\n   public float getPreferredSpan(int axis)\n   {\n-    // TODO: Implement me.\n-    return 0F;\n+    Icon icon = StyleConstants.getIcon(getElement().getAttributes());\n+    float span;\n+    if (axis == X_AXIS)\n+      span = icon.getIconWidth();\n+    else if (axis == Y_AXIS)\n+      span = icon.getIconHeight();\n+    else\n+      throw new IllegalArgumentException();\n+    return span;\n   }\n \n   /**\n@@ -106,8 +129,12 @@ public float getPreferredSpan(int axis)\n   public Shape modelToView(int pos, Shape a, Position.Bias b)\n     throws BadLocationException\n   {\n-    // Implement me.\n-    return null;\n+    Element el = getElement();\n+    if (pos < el.getStartOffset() || pos >= el.getEndOffset())\n+      throw new BadLocationException(\"Illegal offset for this view\", pos);\n+    Rectangle r = a.getBounds();\n+    Icon icon = StyleConstants.getIcon(el.getAttributes());\n+    return new Rectangle(r.x, r.y, icon.getIconWidth(), icon.getIconHeight());\n   }\n \n   /**\n@@ -124,8 +151,11 @@ public Shape modelToView(int pos, Shape a, Position.Bias b)\n    */\n   public int viewToModel(float x, float y, Shape a, Position.Bias[] b)\n   {\n-    // FIXME: not implemented\n-    return 0;\n+    // The element should only have one character position and it is clear\n+    // that this position is the position that best matches the given screen\n+    // coordinates, simply because this view has only this one position.\n+    Element el = getElement();\n+    return el.getStartOffset();\n   }\n \n   /**\n@@ -157,4 +187,5 @@ public int getNextVisualPositionFrom(JTextComponent c, int pos,\n     // TODO: Implement this properly.\n     throw new AssertionError(\"Not implemented yet.\");\n   }\n+\n }"}, {"sha": "c4864503187b18b667e0f02b7308f161978a418f", "filename": "libjava/classpath/javax/swing/text/ParagraphView.java", "status": "modified", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FParagraphView.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FParagraphView.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FParagraphView.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -38,6 +38,10 @@\n \n package javax.swing.text;\n \n+import java.awt.Shape;\n+\n+import javax.swing.event.DocumentEvent;\n+\n /**\n  * A {@link FlowView} that flows it's children horizontally and boxes the rows\n  * vertically.\n@@ -66,6 +70,26 @@ public float getAlignment(int axis)\n     }\n   }\n \n+  /**\n+   * The indentation of the first line of the paragraph.\n+   */\n+  protected int firstLineIndent;\n+\n+  /**\n+   * The justification of the paragraph.\n+   */\n+  private int justification;\n+\n+  /**\n+   * The line spacing of this paragraph.\n+   */\n+  private float lineSpacing;\n+\n+  /**\n+   * The TabSet of this paragraph.\n+   */\n+  private TabSet tabSet;\n+\n   /**\n    * Creates a new <code>ParagraphView</code> for the given\n    * <code>Element</code>.\n@@ -116,4 +140,93 @@ else if (getViewCount() > 0)\n     else\n       return 0.0F;\n   }\n+\n+  /**\n+   * Receives notification when some attributes of the displayed element\n+   * changes. This triggers a refresh of the cached attributes of this\n+   * paragraph.\n+   *\n+   * @param ev the document event\n+   * @param a the allocation of this view\n+   * @param fv the view factory to use for creating new child views\n+   */\n+  public void changedUpdate(DocumentEvent ev, Shape a, ViewFactory fv)\n+  {\n+    setPropertiesFromAttributes();\n+  }\n+\n+  /**\n+   * Fetches the cached properties from the element's attributes.\n+   */\n+  protected void setPropertiesFromAttributes()\n+  {\n+    Element el = getElement();\n+    AttributeSet atts = el.getAttributes();\n+    setFirstLineIndent(StyleConstants.getFirstLineIndent(atts));\n+    setLineSpacing(StyleConstants.getLineSpacing(atts));\n+    setJustification(StyleConstants.getAlignment(atts));\n+    tabSet = StyleConstants.getTabSet(atts);\n+  }\n+\n+  /**\n+   * Sets the indentation of the first line of the paragraph.\n+   *\n+   * @param i the indentation to set\n+   */\n+  protected void setFirstLineIndent(float i)\n+  {\n+    firstLineIndent = (int) i;\n+  }\n+\n+  /**\n+   * Sets the justification of the paragraph.\n+   *\n+   * @param j the justification to set \n+   */\n+  protected void setJustification(int j)\n+  {\n+    justification = j;\n+  }\n+\n+  /**\n+   * Sets the line spacing for this paragraph.\n+   *\n+   * @param s the line spacing to set\n+   */\n+  protected void setLineSpacing(float s)\n+  {\n+    lineSpacing = s;\n+  }\n+\n+  /**\n+   * Returns the i-th view from the logical views, before breaking into rows.\n+   *\n+   * @param i the index of the logical view to return\n+   *\n+   * @return the i-th view from the logical views, before breaking into rows\n+   */\n+  protected View getLayoutView(int i)\n+  {\n+    return layoutPool.getView(i);\n+  }\n+\n+  /**\n+   * Returns the number of logical child views.\n+   *\n+   * @return the number of logical child views\n+   */\n+  protected int getLayoutViewCount()\n+  {\n+    return layoutPool.getViewCount();\n+  }\n+\n+  /**\n+   * Returns the TabSet used by this ParagraphView.\n+   *\n+   * @return the TabSet used by this ParagraphView\n+   */\n+  protected TabSet getTabSet()\n+  {\n+    return tabSet;\n+  }\n }"}, {"sha": "0c00a06ff252b3308e6e1a23cbde2e50a9392225", "filename": "libjava/classpath/javax/swing/text/PlainDocument.java", "status": "modified", "additions": 81, "deletions": 13, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FPlainDocument.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FPlainDocument.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FPlainDocument.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -105,35 +105,103 @@ protected AbstractDocument.AbstractElement createDefaultRoot()\n     return root;\n   }\n \n-  protected void insertUpdate(DefaultDocumentEvent event, AttributeSet attributes)\n+  protected void insertUpdate(DefaultDocumentEvent event,\n+                              AttributeSet attributes)\n   {\n-    reindex();\n+    int offset = event.getOffset();\n+    int end = offset + event.getLength();\n+    int elementIndex = rootElement.getElementIndex(offset);\n+    Element firstElement = rootElement.getElement(elementIndex);\n+    \n+    // added and removed are Element arrays used to add an ElementEdit\n+    // to the DocumentEvent if there were entire lines added or removed.\n+    Element[] removed = new Element[1];\n+    Element[] added;\n+    try \n+      {\n+        String str = content.getString(0, content.length());\n+        ArrayList elts = new ArrayList();\n \n+        // Determine how many NEW lines were added by finding the newline\n+        // characters within the newly inserted text\n+        int j = firstElement.getStartOffset();\n+        int i = str.indexOf('\\n', offset);\n+        while (i != -1 && i <= end)\n+          {            \n+            // For each new line, create a new element\n+            elts.add(createLeafElement(rootElement, SimpleAttributeSet.EMPTY,\n+                                       j, i + 1));\n+            j = i + 1;\n+            if (j >= str.length())\n+              break;\n+            i = str.indexOf('\\n', j);\n+          }\n+        // If there were new lines added we have to add an ElementEdit to \n+        // the DocumentEvent and we have to call rootElement.replace to \n+        // insert the new lines\n+        if (elts.size() != 0)\n+          {\n+            // Set up the ElementEdit by filling the added and removed \n+            // arrays with the proper Elements\n+            added = new Element[elts.size()];\n+            for (int k = 0; k < elts.size(); ++k)\n+              added[k] = (Element) elts.get(k);\n+            removed[0] = firstElement;\n+            \n+            // Now create and add the ElementEdit\n+            ElementEdit e = new ElementEdit(rootElement, elementIndex, removed,\n+                                            added);\n+            event.addEdit(e);\n+            \n+            // And call replace to actually make the changes\n+            ((BranchElement) rootElement).replace(elementIndex, 1, added);\n+          }\n+      }\n+    catch (BadLocationException e)\n+      {\n+        // This shouldn't happen so we throw an AssertionError\n+        AssertionError ae = new AssertionError();\n+        ae.initCause(e);\n+        throw ae;\n+      }\n     super.insertUpdate(event, attributes);\n   }\n \n   protected void removeUpdate(DefaultDocumentEvent event)\n   {\n     super.removeUpdate(event);\n \n+    // added and removed are Element arrays used to add an ElementEdit\n+    // to the DocumentEvent if there were entire lines added or removed\n+    // from the Document\n+    Element[] added = new Element[1];\n+    Element[] removed;\n     int p0 = event.getOffset();\n-    int len = event.getLength();\n-    int p1 = len + p0;\n \n     // check if we must collapse some elements\n     int i1 = rootElement.getElementIndex(p0);\n-    int i2 = rootElement.getElementIndex(p1);\n+    int i2 = rootElement.getElementIndex(p0 + event.getLength());\n     if (i1 != i2)\n       {\n-        Element el1 = rootElement.getElement(i1);\n-        Element el2 = rootElement.getElement(i2);\n-        int start = el1.getStartOffset();\n-        int end = el2.getEndOffset();\n-        // collapse elements if the removal spans more than 1 line\n-        Element newEl = createLeafElement(rootElement,\n+        // If there were lines removed then we have to add an ElementEdit\n+        // to the DocumentEvent so we set it up now by filling the Element\n+        // arrays \"removed\" and \"added\" appropriately\n+        removed = new Element [i2 - i1 + 1];\n+        for (int i = i1; i <= i2; i++)\n+          removed[i-i1] = rootElement.getElement(i);\n+        \n+        int start = rootElement.getElement(i1).getStartOffset();\n+        int end = rootElement.getElement(i2).getEndOffset();        \n+        added[0] = createLeafElement(rootElement,\n                                           SimpleAttributeSet.EMPTY,\n                                           start, end);\n-        rootElement.replace(i1, i2 - i1 + 1, new Element[]{ newEl });\n+\n+        // Now create and add the ElementEdit\n+        ElementEdit e = new ElementEdit(rootElement, i1, removed, added);\n+        event.addEdit(e);\n+\n+        // collapse elements if the removal spans more than 1 line\n+        rootElement.replace(i1, i2 - i1 + 1, added);\n       }\n   }\n \n@@ -167,7 +235,7 @@ public void insertString(int offs, String str, AttributeSet atts)\n     throws BadLocationException\n   {\n     String string = str;\n-    if (Boolean.TRUE.equals(getProperty(\"filterNewlines\")))\n+    if (str != null && Boolean.TRUE.equals(getProperty(\"filterNewlines\")))\n       string = str.replaceAll(\"\\n\", \" \");\n     super.insertString(offs, string, atts);\n   }"}, {"sha": "b03399d097455c94e403ef789ffb6186d2892bd2", "filename": "libjava/classpath/javax/swing/text/WrappedPlainView.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FWrappedPlainView.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FWrappedPlainView.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FWrappedPlainView.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -50,7 +50,7 @@\n import javax.swing.text.Position.Bias;\n \n /**\n- * @author abalkiss\n+ * @author Anthony Balkissoon abalkiss at redhat dot com\n  *\n  */\n public class WrappedPlainView extends BoxView implements TabExpander"}, {"sha": "ae8b99c2fe5c69740f12e4bc76c88281284d4359", "filename": "libjava/classpath/javax/swing/tree/DefaultTreeCellEditor.java", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftree%2FDefaultTreeCellEditor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftree%2FDefaultTreeCellEditor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftree%2FDefaultTreeCellEditor.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -339,9 +339,8 @@ public DefaultTreeCellEditor(JTree tree, DefaultTreeCellRenderer renderer,\n     lastPath = tree.getLeadSelectionPath();\n     tree.addTreeSelectionListener(this);\n     editingContainer = createContainer();\n-    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n-    setFont(defaults.getFont(\"Tree.font\"));\n-    setBorderSelectionColor(defaults.getColor(\"Tree.selectionBorderColor\"));\n+    setFont(UIManager.getFont(\"Tree.font\"));\n+    setBorderSelectionColor(UIManager.getColor(\"Tree.selectionBorderColor\"));\n     editingIcon = renderer.getIcon();\n     timer = new javax.swing.Timer(1200, this);\n   }\n@@ -735,9 +734,8 @@ protected Container createContainer()\n    */\n   protected TreeCellEditor createTreeCellEditor()\n   {\n-    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n     realEditor = new DefaultCellEditor(new DefaultTreeCellEditor.DefaultTextField(\n-                                  defaults.getBorder(\"Tree.selectionBorder\")));\n+                                  UIManager.getBorder(\"Tree.selectionBorder\")));\n     return realEditor;\n   }\n }"}, {"sha": "df70ba7fb9fac8e0d8ec62e934bbb717f783ac8b", "filename": "libjava/classpath/javax/swing/tree/DefaultTreeCellRenderer.java", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftree%2FDefaultTreeCellRenderer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftree%2FDefaultTreeCellRenderer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftree%2FDefaultTreeCellRenderer.java?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -51,7 +51,6 @@\n import javax.swing.Icon;\n import javax.swing.JLabel;\n import javax.swing.JTree;\n-import javax.swing.UIDefaults;\n import javax.swing.UIManager;\n import javax.swing.SwingUtilities;\n import javax.swing.plaf.UIResource;\n@@ -133,17 +132,15 @@\n    */\n   public DefaultTreeCellRenderer()\n   {\n-    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n-\n     setLeafIcon(getDefaultLeafIcon());\n     setOpenIcon(getDefaultOpenIcon());\n     setClosedIcon(getDefaultClosedIcon());\n \n-    setTextNonSelectionColor(defaults.getColor(\"Tree.textForeground\"));\n-    setTextSelectionColor(defaults.getColor(\"Tree.selectionForeground\"));\n-    setBackgroundNonSelectionColor(defaults.getColor(\"Tree.nonSelectionBackground\"));\n-    setBackgroundSelectionColor(defaults.getColor(\"Tree.selectionBackground\"));\n-    setBorderSelectionColor(defaults.getColor(\"Tree.selectionBorderColor\"));\n+    setTextNonSelectionColor(UIManager.getColor(\"Tree.textForeground\"));\n+    setTextSelectionColor(UIManager.getColor(\"Tree.selectionForeground\"));\n+    setBackgroundNonSelectionColor(UIManager.getColor(\"Tree.nonSelectionBackground\"));\n+    setBackgroundSelectionColor(UIManager.getColor(\"Tree.selectionBackground\"));\n+    setBorderSelectionColor(UIManager.getColor(\"Tree.selectionBorderColor\"));\n   }\n \n   // -------------------------------------------------------------\n@@ -157,7 +154,7 @@ public DefaultTreeCellRenderer()\n    */\n   public Icon getDefaultOpenIcon()\n   {\n-    return UIManager.getLookAndFeelDefaults().getIcon(\"Tree.openIcon\");\n+    return UIManager.getIcon(\"Tree.openIcon\");\n   }\n \n   /**\n@@ -167,7 +164,7 @@ public Icon getDefaultOpenIcon()\n    */\n   public Icon getDefaultClosedIcon()\n   {\n-    return UIManager.getLookAndFeelDefaults().getIcon(\"Tree.closedIcon\");\n+    return UIManager.getIcon(\"Tree.closedIcon\");\n   }\n \n   /**\n@@ -177,7 +174,7 @@ public Icon getDefaultClosedIcon()\n    */\n   public Icon getDefaultLeafIcon()\n   {\n-    return UIManager.getLookAndFeelDefaults().getIcon(\"Tree.leafIcon\");\n+    return UIManager.getIcon(\"Tree.leafIcon\");\n   }\n \n   /**\n@@ -412,7 +409,7 @@ else if (expanded)\n     setOpaque(false);\n     setVerticalAlignment(TOP);\n     setEnabled(true);\n-    super.setFont(UIManager.getLookAndFeelDefaults().getFont(\"Tree.font\"));\n+    super.setFont(UIManager.getFont(\"Tree.font\"));\n \n     if (selected)\n       {\n@@ -459,8 +456,7 @@ public void paint(Graphics g)\n     Rectangle tr = new Rectangle();\n \n     Insets insets = new Insets(0, 0, 0, 0);\n-    Border border = UIManager.getLookAndFeelDefaults().getBorder(\n-                                                                 \"Tree.selectionBorder\");\n+    Border border = UIManager.getBorder(\"Tree.selectionBorder\");\n     if (border != null)\n       insets = border.getBorderInsets(this);\n "}, {"sha": "092e997a36d27e7ddba35c44cbc3080e0ed4157f", "filename": "libjava/classpath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_GdkGraphics2D.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkGraphics2D.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkGraphics2D.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkGraphics2D.c?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -565,6 +565,13 @@ Java_gnu_java_awt_peer_gtk_GdkGraphics2D_gdkDrawDrawable\n \n   /* gdk_flush(); */\n \n+  if (!GDK_IS_DRAWABLE (src->drawable) || \n+   !GDK_IS_DRAWABLE (dst->drawable))\n+    {\n+      gdk_threads_leave ();\n+      return;\n+    }\n+\n   gdk_drawable_get_size (src->drawable, &s_width, &s_height);\n   gdk_drawable_get_size (dst->drawable, &d_width, &d_height);\n   width = min (s_width, d_width);"}, {"sha": "b14330e5fe225a986d1834bf66e9e3edbfbea5f2", "filename": "libjava/classpath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkToolkit.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkToolkit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkToolkit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkToolkit.c?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -135,6 +135,8 @@ Java_gnu_java_awt_peer_gtk_GtkToolkit_gtkInit (JNIEnv *env,\n \n   gtkgenericpeer = (*env)->FindClass(env, \"gnu/java/awt/peer/gtk/GtkGenericPeer\");\n \n+  gtkgenericpeer = (*env)->NewGlobalRef(env, gtkgenericpeer);\n+\n   printCurrentThreadID = (*env)->GetStaticMethodID (env, gtkgenericpeer,\n                                                     \"printCurrentThread\", \"()V\");\n  "}, {"sha": "ac8f6a8ff1eaf4084494e007a649c0272dbd5d21", "filename": "libjava/classpath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkWindowPeer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkWindowPeer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkWindowPeer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkWindowPeer.c?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -1204,8 +1204,8 @@ Java_gnu_java_awt_peer_gtk_GtkWindowPeer_gtkWindowSetResizable\n   gdk_threads_enter ();\n \n   ptr = NSA_GET_PTR (env, obj);\n-\n   gtk_window_set_resizable (GTK_WINDOW (ptr), resizable);\n+  g_object_set (G_OBJECT (ptr), \"allow-shrink\", resizable, NULL);\n \n   gdk_threads_leave ();\n }"}, {"sha": "076f42b86a384095b8442bec56abdeece7ce226c", "filename": "libjava/classpath/native/jni/java-lang/java_lang_VMDouble.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fnative%2Fjni%2Fjava-lang%2Fjava_lang_VMDouble.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fclasspath%2Fnative%2Fjni%2Fjava-lang%2Fjava_lang_VMDouble.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fjni%2Fjava-lang%2Fjava_lang_VMDouble.c?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -71,6 +71,11 @@ Java_java_lang_VMDouble_initIDs (JNIEnv * env, jclass cls __attribute__ ((__unus\n     {\n       DBG (\"unable to get class java.lang.Double\\n\") return;\n     }\n+  clsDouble = (*env)->NewGlobalRef(env, clsDouble);\n+  if (clsDouble == NULL)\n+    {\n+      DBG (\"unable to register class java.lang.Double as global ref\\n\") return;\n+    }\n   isNaNID = (*env)->GetStaticMethodID (env, clsDouble, \"isNaN\", \"(D)Z\");\n   if (isNaNID == NULL)\n     {"}, {"sha": "8e4a413667d1b946d377aa1ca111dea257403d90", "filename": "libjava/gnu/java/net/protocol/file/Connection.java", "status": "removed", "additions": 0, "deletions": 368, "changes": 368, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb3a09c214e19c97d3751003d9a2ea8008f5005e/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Ffile%2FConnection.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb3a09c214e19c97d3751003d9a2ea8008f5005e/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Ffile%2FConnection.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Ffile%2FConnection.java?ref=fb3a09c214e19c97d3751003d9a2ea8008f5005e", "patch": "@@ -1,368 +0,0 @@\n-/* FileURLConnection.java -- URLConnection class for \"file\" protocol\n-   Copyright (C) 1998, 1999, 2003 Free Software Foundation, Inc.\n-\n-This file is part of GNU Classpath.\n-\n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n- \n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n-02110-1301 USA.\n-\n-Linking this library statically or dynamically with other modules is\n-making a combined work based on this library.  Thus, the terms and\n-conditions of the GNU General Public License cover the whole\n-combination.\n-\n-As a special exception, the copyright holders of this library give you\n-permission to link this library with independent modules to produce an\n-executable, regardless of the license terms of these independent\n-modules, and to copy and distribute the resulting executable under\n-terms of your choice, provided that you also meet, for each linked\n-independent module, the terms and conditions of the license of that\n-module.  An independent module is a module which is not derived from\n-or based on this library.  If you modify this library, you may extend\n-this exception to your version of the library, but you are not\n-obligated to do so.  If you do not wish to do so, delete this\n-exception statement from your version. */\n-\n-package gnu.java.net.protocol.file;\n-\n-import gnu.classpath.SystemProperties;\n-\n-import java.io.BufferedInputStream;\n-import java.io.BufferedOutputStream;\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.FileOutputStream;\n-import java.io.FilePermission;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n-import java.io.OutputStreamWriter;\n-import java.io.Writer;\n-import java.net.ProtocolException;\n-import java.net.URL;\n-import java.net.URLConnection;\n-import java.security.Permission;\n-import java.text.SimpleDateFormat;\n-import java.util.Date;\n-import java.util.Locale;\n-import java.net.MalformedURLException;\n-\n-/**\n- * This subclass of java.net.URLConnection models a URLConnection via\n- * the \"file\" protocol.\n- *\n- * @author Aaron M. Renn (arenn@urbanophile.com)\n- * @author Nic Ferrier (nferrier@tapsellferrier.co.uk)\n- * @author Warren Levy (warrenl@cygnus.com)\n- */\n-public class Connection extends URLConnection\n-{\n-  /**\n-   * Default permission for a file\n-   */\n-  private static final String DEFAULT_PERMISSION = \"read\";\n-\n-  private static class StaticData\n-  {\n-    /**\n-     * HTTP-style DateFormat, used to format the last-modified header.\n-     */\n-    static SimpleDateFormat dateFormat\n-      = new SimpleDateFormat(\"EEE, dd MMM yyyy hh:mm:ss 'GMT'\",\n-                             new Locale (\"En\", \"Us\", \"Unix\"));\n-\n-    static String lineSeparator =\n-      SystemProperties.getProperty(\"line.separator\");\n-  }\n-\n-  \n-  /**\n-   * This is a File object for this connection\n-   */\n-  private File file;\n-\n-  /**\n-   * If a directory, contains a list of files in the directory.\n-   */\n-  private byte[] directoryListing;\n-\n-  /**\n-   * InputStream if we are reading from the file\n-   */\n-  private InputStream inputStream;\n-\n-  /**\n-   * OutputStream if we are writing to the file\n-   */\n-  private OutputStream outputStream;\n-  \n-  /**\n-   * FilePermission to read the file\n-   */\n-  private FilePermission permission;\n-\n-  /**\n-   * Calls superclass constructor to initialize.\n-   */\n-  public Connection(URL url)\n-  {\n-    super (url);\n-\n-    permission = new FilePermission(getURL().getFile(), DEFAULT_PERMISSION);\n-  }\n-  \n-  /**\n-   * Unquote \"%\" + hex quotes characters\n-   *\n-   * @param str The string to unquote or null.\n-   *\n-   * @return The unquoted string or null if str was null.\n-   *\n-   * @exception MalformedURLException If the given string contains invalid\n-   * escape sequences.\n-   *\n-   * Sadly the same as URI.unquote, but there's nothing we can do to\n-   * make it accessible.\n-   *\n-   */\n-  public static String unquote(String str) throws MalformedURLException\n-  {\n-    if (str == null)\n-      return null;\n-    byte[] buf = new byte[str.length()];\n-    int pos = 0;\n-    for (int i = 0; i < str.length(); i++)\n-      {\n-\tchar c = str.charAt(i);\n-\tif (c > 127)\n-\t  throw new MalformedURLException(str + \" : Invalid character\");\n-\tif (c == '%')\n-\t  {\n-\t    if (i + 2 >= str.length())\n-\t      throw new MalformedURLException(str + \" : Invalid quoted character\");\n-\t    int hi = Character.digit(str.charAt(++i), 16);\n-\t    int lo = Character.digit(str.charAt(++i), 16);\n-\t    if (lo < 0 || hi < 0)\n-\t      throw new MalformedURLException(str + \" : Invalid quoted character\");\n-\t    buf[pos++] = (byte) (hi * 16 + lo);\n-\t  }\n-\telse\n-\t  buf[pos++] = (byte) c;\n-      }\n-    try\n-      {\n-\treturn new String(buf, 0, pos, \"utf-8\");\n-      }\n-    catch (java.io.UnsupportedEncodingException x2)\n-      {\n-\tthrow (Error) new InternalError().initCause(x2);\n-      }\n-  }\n-\n-  /**\n-   * \"Connects\" to the file by opening it.\n-   */\n-  public void connect() throws IOException\n-  {\n-    // Call is ignored if already connected.\n-    if (connected)\n-      return;\n-    \n-    // If not connected, then file needs to be openned.\n-    file = new File (unquote(getURL().getFile()));\n-\n-    if (! file.isDirectory())\n-      {\n-\tif (doInput)\n-\t  inputStream = new BufferedInputStream(new FileInputStream(file));\n-    \n-\tif (doOutput)\n-\t  outputStream = new BufferedOutputStream(new FileOutputStream(file));\n-      }\n-    else\n-      {\n-\tif (doInput)\n-\t  {\n-            inputStream = new ByteArrayInputStream(getDirectoryListing());\n-\t  }\n-\n-\tif (doOutput)\n-\t  throw new ProtocolException\n-\t    (\"file: protocol does not support output on directories\");\n-      }\n-    \n-    connected = true;\n-  }\n-\n-  /**\n-   * Populates the <code>directoryListing</code> field with a byte array\n-   * containing a representation of the directory listing.\n-   */\n-  byte[] getDirectoryListing()\n-    throws IOException\n-  {\n-    if (directoryListing == null)\n-      {\n-        ByteArrayOutputStream sink = new ByteArrayOutputStream();\n-        // NB uses default character encoding for this system\n-        Writer writer = new OutputStreamWriter(sink);\n-    \n-        String[] files = file.list();\n-    \n-        for (int i = 0; i < files.length; i++)\n-          {\n-            writer.write(files[i]);\n-            writer.write(StaticData.lineSeparator);\n-          }\n-\n-        directoryListing = sink.toByteArray();\n-      }\n-    return directoryListing;  \n-  }\n-  \n-  /**\n-   * Opens the file for reading and returns a stream for it.\n-   *\n-   * @return An InputStream for this connection.\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  public InputStream getInputStream()\n-    throws IOException\n-  {\n-    if (!doInput)\n-      throw new ProtocolException(\"Can't open InputStream if doInput is false\");\n-    \n-    if (!connected)\n-      connect();\n-    \n-    return inputStream;\n-  }\n-\n-  /**\n-   * Opens the file for writing and returns a stream for it.\n-   *\n-   * @return An OutputStream for this connection.\n-   *\n-   * @exception IOException If an error occurs.\n-   */\n-  public OutputStream getOutputStream()\n-    throws IOException\n-  {\n-    if (!doOutput)\n-      throw new\n-\tProtocolException(\"Can't open OutputStream if doOutput is false\");\n-\n-    if (!connected)\n-      connect();\n-    \n-    return outputStream;\n-  }\n-\n-  /**\n-   * Get the last modified time of the resource.\n-   *\n-   * @return the time since epoch that the resource was modified.\n-   */\n-  public long getLastModified()\n-  {\n-    try\n-      {\n-\tif (!connected)\n-\t  connect();\n-\n-\treturn file.lastModified();\n-      }\n-    catch (IOException e)\n-      {\n-\treturn -1;\n-      }\n-  }\n-  \n-  /**\n-   *  Get an http-style header field. Just handle a few common ones. \n-   */\n-  public String getHeaderField(String field)\n-  {\n-    try\n-      {\n-\tif (!connected)\n-\t  connect();\n-\n-\tif (field.equals(\"content-type\"))\n-          return guessContentTypeFromName(file.getName());\n-\telse if (field.equals(\"content-length\"))\n-          {\n-            if (file.isDirectory())\n-              {\n-                return Integer.toString(getContentLength());\n-              }\n-            return Long.toString(file.length());\n-          }\n-\telse if (field.equals(\"last-modified\"))\n-\t  {\n-\t    synchronized (StaticData.dateFormat)\n-\t      {\n-        \treturn StaticData.dateFormat.format(\n-                        new Date(file.lastModified()));\n-\t      }\n-\t  }\n-      }\n-    catch (IOException e)\n-      {\n-        // Fall through.\n-      }\n-    return null;\n-  }\n-\n-  /**\n-   * Get the length of content.\n-   *\n-   * @return the length of the content.\n-   */\n-  public int getContentLength()\n-  {\n-    try\n-      {\n-\tif (!connected)\n-\t  connect();\n-        \n-        if (file.isDirectory())\n-          {\n-            return getDirectoryListing().length;\n-          }\n-\treturn (int) file.length();\n-      }\n-    catch (IOException e)\n-      {\n-\treturn -1;\n-      }\n-  }\n-  \n-  /**\n-   * This method returns a <code>Permission</code> object representing the\n-   * permissions required to access this URL.  This method returns a\n-   * <code>java.io.FilePermission</code> for the file's path with a read\n-   * permission.\n-   *\n-   * @return A Permission object\n-   */\n-  public Permission getPermission() throws IOException\n-  {\n-    return permission;\n-  }\n-}"}, {"sha": "6a0b3025f1c5e5b6bfcef30535d9c47ab586b0df", "filename": "libjava/sources.am", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fsources.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9e049bc145ae985bc0e2dd6079dacdd51717ac/libjava%2Fsources.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fsources.am?ref=ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "patch": "@@ -975,7 +975,7 @@ gnu/java/net.list: $(gnu_java_net_source_files)\n \n \n gnu_java_net_protocol_file_source_files = \\\n-gnu/java/net/protocol/file/Connection.java \\\n+classpath/gnu/java/net/protocol/file/Connection.java \\\n classpath/gnu/java/net/protocol/file/Handler.java\n \n gnu_java_net_protocol_file_header_files = $(patsubst classpath/%,%,$(patsubst %.java,%.h,$(gnu_java_net_protocol_file_source_files)))\n@@ -5133,6 +5133,7 @@ classpath/javax/swing/plaf/metal/MetalInternalFrameTitlePane.java \\\n classpath/javax/swing/plaf/metal/MetalInternalFrameUI.java \\\n classpath/javax/swing/plaf/metal/MetalLabelUI.java \\\n classpath/javax/swing/plaf/metal/MetalLookAndFeel.java \\\n+classpath/javax/swing/plaf/metal/MetalMenuBarUI.java \\\n classpath/javax/swing/plaf/metal/MetalPopupMenuSeparatorUI.java \\\n classpath/javax/swing/plaf/metal/MetalProgressBarUI.java \\\n classpath/javax/swing/plaf/metal/MetalRadioButtonUI.java \\"}]}