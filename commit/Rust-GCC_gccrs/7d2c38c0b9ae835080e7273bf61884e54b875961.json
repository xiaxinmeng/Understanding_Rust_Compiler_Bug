{"sha": "7d2c38c0b9ae835080e7273bf61884e54b875961", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2QyYzM4YzBiOWFlODM1MDgwZTcyNzNiZjYxODg0ZTU0Yjg3NTk2MQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2010-08-31T16:53:56Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2010-08-31T16:53:56Z"}, "message": "i386.md (popdi1): Rewrite using POST_INC memory operand.\n\n\t* config/i386/i386.md (popdi1): Rewrite using POST_INC memory operand.\n\t(popsi1): Ditto.\n\t(*popdi1_epilogue): Ditto.\n\t(*popsi1_epilogue): Ditto.\n\t(popsi, popdi peephole2 patterns): Update peepholes for changed\n\tpop{si,di}1 and *pop{si,di}1_epilogue patterns.\n\n\t(pop<mode>1): Macroize insn from pop{si,di}1 using P code iterator.\n\t(*pop<mode>1_epilogue): Ditto from *pop{si,di}1_epilogue.\n\n\t* config/i386/i386.c (*ix86_gen_pop1): Remove indirect function.\n\t(override_options): Do not initialize removed ix86_gen_pop1.\n\t(gen_pop): New static function.\n\t(ix86_expand_prologue): Use gen_pop instead of ix86_gen_pop1.\n\t(release_scratch_register_on_entry): Ditto.\n\t(ix86_restore_reg_using_pop): Ditto.\n\t(ix86_expand_epilogue): Ditto.\n\nFrom-SVN: r163679", "tree": {"sha": "3840346b238200462e03d4bacd6e6256c1a832eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3840346b238200462e03d4bacd6e6256c1a832eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d2c38c0b9ae835080e7273bf61884e54b875961", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d2c38c0b9ae835080e7273bf61884e54b875961", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d2c38c0b9ae835080e7273bf61884e54b875961", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d2c38c0b9ae835080e7273bf61884e54b875961/comments", "author": null, "committer": null, "parents": [{"sha": "0f643366ab9164e19a2efce88f141b04c0002f48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f643366ab9164e19a2efce88f141b04c0002f48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f643366ab9164e19a2efce88f141b04c0002f48"}], "stats": {"total": 214, "additions": 91, "deletions": 123}, "files": [{"sha": "ac896e4f55f54950fc4a465ed2995122092c8888", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d2c38c0b9ae835080e7273bf61884e54b875961/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d2c38c0b9ae835080e7273bf61884e54b875961/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7d2c38c0b9ae835080e7273bf61884e54b875961", "patch": "@@ -1,3 +1,23 @@\n+2010-08-31  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.md (popdi1): Rewrite using POST_INC memory operand.\n+\t(popsi1): Ditto.\n+\t(*popdi1_epilogue): Ditto.\n+\t(*popsi1_epilogue): Ditto.\n+\t(popsi, popdi peephole2 patterns): Update peepholes for changed\n+\tpop{si,di}1 and *pop{si,di}1_epilogue patterns.\n+\n+\t(pop<mode>1): Macroize insn from pop{si,di}1 using P code iterator.\n+\t(*pop<mode>1_epilogue): Ditto from *pop{si,di}1_epilogue.\n+\n+\t* config/i386/i386.c (*ix86_gen_pop1): Remove indirect function.\n+\t(override_options): Do not initialize removed ix86_gen_pop1.\n+\t(gen_pop): New static function.\n+\t(ix86_expand_prologue): Use gen_pop instead of ix86_gen_pop1.\n+\t(release_scratch_register_on_entry): Ditto.\n+\t(ix86_restore_reg_using_pop): Ditto.\n+\t(ix86_expand_epilogue): Ditto.\n+\n 2010-08-31  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/45461\n@@ -414,9 +434,9 @@\n \t(VSr3): Ditto.\n \n 2010-08-27  Basile Starynkevitch  <basile@starynkevitch.net>\n-            Jeremie Salvucci  <jeremie.salvucci@free.fr>\n+\t    Jeremie Salvucci  <jeremie.salvucci@free.fr>\n \n-        * gengtype.c (output_type_enum): Test the right union member.\n+\t* gengtype.c (output_type_enum): Test the right union member.\n \n 2010-08-27  Uros Bizjak  <ubizjak@gmail.com>\n "}, {"sha": "6ff9b11c6351784479c3a75cadf1389e1616fdb3", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d2c38c0b9ae835080e7273bf61884e54b875961/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d2c38c0b9ae835080e7273bf61884e54b875961/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=7d2c38c0b9ae835080e7273bf61884e54b875961", "patch": "@@ -1896,7 +1896,6 @@ static const char ix86_force_align_arg_pointer_string[]\n   = \"force_align_arg_pointer\";\n \n static rtx (*ix86_gen_leave) (void);\n-static rtx (*ix86_gen_pop1) (rtx);\n static rtx (*ix86_gen_add3) (rtx, rtx, rtx);\n static rtx (*ix86_gen_sub3) (rtx, rtx, rtx);\n static rtx (*ix86_gen_sub3_carry) (rtx, rtx, rtx, rtx, rtx);\n@@ -3655,7 +3654,6 @@ override_options (bool main_args_p)\n   if (TARGET_64BIT)\n     {\n       ix86_gen_leave = gen_leave_rex64;\n-      ix86_gen_pop1 = gen_popdi1;\n       ix86_gen_add3 = gen_adddi3;\n       ix86_gen_sub3 = gen_subdi3;\n       ix86_gen_sub3_carry = gen_subdi3_carry;\n@@ -3669,7 +3667,6 @@ override_options (bool main_args_p)\n   else\n     {\n       ix86_gen_leave = gen_leave;\n-      ix86_gen_pop1 = gen_popsi1;\n       ix86_gen_add3 = gen_addsi3;\n       ix86_gen_sub3 = gen_subsi3;\n       ix86_gen_sub3_carry = gen_subsi3_carry;\n@@ -8173,6 +8170,18 @@ gen_push (rtx arg)\n \t\t      arg);\n }\n \n+/* Generate an \"pop\" pattern for input ARG.  */\n+\n+static rtx\n+gen_pop (rtx arg)\n+{\n+  return gen_rtx_SET (VOIDmode,\n+\t\t      arg,\n+\t\t      gen_rtx_MEM (Pmode,\n+\t\t\t\t   gen_rtx_POST_INC (Pmode,\n+\t\t\t\t\t\t     stack_pointer_rtx)));\n+}\n+\n /* Return >= 0 if there is an unused call-clobbered register available\n    for the entire function.  */\n \n@@ -9052,7 +9061,7 @@ release_scratch_register_on_entry (struct scratch_reg *sr)\n {\n   if (sr->saved)\n     {\n-      rtx x, insn = emit_insn (ix86_gen_pop1 (sr->reg));\n+      rtx x, insn = emit_insn (gen_pop (sr->reg));\n \n       /* The RTX_FRAME_RELATED_P mechanism doesn't know about pop.  */\n       RTX_FRAME_RELATED_P (insn) = 1;\n@@ -9478,7 +9487,7 @@ ix86_expand_prologue (void)\n \t{\n \t  /* The frame pointer is not needed so pop %ebp again.\n \t     This leaves us with a pristine state.  */\n-\t  emit_insn (ix86_gen_pop1 (hard_frame_pointer_rtx));\n+\t  emit_insn (gen_pop (hard_frame_pointer_rtx));\n \t}\n     }\n \n@@ -9786,7 +9795,7 @@ static void\n ix86_emit_restore_reg_using_pop (rtx reg)\n {\n   struct machine_function *m = cfun->machine;\n-  rtx insn = emit_insn (ix86_gen_pop1 (reg));\n+  rtx insn = emit_insn (gen_pop (reg));\n \n   ix86_add_cfa_restore_note (insn, reg, m->fs.sp_offset);\n   m->fs.sp_offset -= UNITS_PER_WORD;\n@@ -9809,10 +9818,12 @@ ix86_emit_restore_reg_using_pop (rtx reg)\n \n   if (m->fs.cfa_reg == stack_pointer_rtx)\n     {\n-      m->fs.cfa_offset -= UNITS_PER_WORD;\n-      add_reg_note (insn, REG_CFA_ADJUST_CFA,\n-\t\t    copy_rtx (XVECEXP (PATTERN (insn), 0, 1)));\n+      rtx x = plus_constant (stack_pointer_rtx, UNITS_PER_WORD);\n+      x = gen_rtx_SET (VOIDmode, stack_pointer_rtx, x);\n+      add_reg_note (insn, REG_CFA_ADJUST_CFA, x);\n       RTX_FRAME_RELATED_P (insn) = 1;\n+\n+      m->fs.cfa_offset -= UNITS_PER_WORD;\n     }\n \n   /* When the frame pointer is the CFA, and we pop it, we are\n@@ -10229,7 +10240,7 @@ ix86_expand_epilogue (int style)\n \t  /* There is no \"pascal\" calling convention in any 64bit ABI.  */\n \t  gcc_assert (!TARGET_64BIT);\n \n-\t  insn = emit_insn (gen_popsi1 (ecx));\n+\t  insn = emit_insn (gen_pop (ecx));\n \t  m->fs.cfa_offset -= UNITS_PER_WORD;\n \t  m->fs.sp_offset -= UNITS_PER_WORD;\n "}, {"sha": "17dc0a668b8394eeab0ecbcc6c50a187863ede5b", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 48, "deletions": 111, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d2c38c0b9ae835080e7273bf61884e54b875961/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d2c38c0b9ae835080e7273bf61884e54b875961/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=7d2c38c0b9ae835080e7273bf61884e54b875961", "patch": "@@ -1636,14 +1636,7 @@\n   \"\"\n   \"ix86_expand_move (<MODE>mode, operands); DONE;\")\n \n-;; Push/pop instructions.  They are separate since autoinc/dec is not a\n-;; general_operand.\n-;;\n-;; %%% We don't use a post-inc memory reference because x86 is not a\n-;; general AUTO_INC_DEC host, which impacts how it is treated in flow.\n-;; Changing this impacts compiler performance on other non-AUTO_INC_DEC\n-;; targets without our curiosities, and it is just as easy to represent\n-;; this differently.\n+;; Push/pop instructions.\n \n (define_insn \"*pushdi2_rex64\"\n   [(set (match_operand:DI 0 \"push_operand\" \"=<,!<\")\n@@ -1756,47 +1749,22 @@\n   [(set_attr \"type\" \"push\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"popdi1\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r*m\")\n-\t(mem:DI (reg:DI SP_REG)))\n-   (set (reg:DI SP_REG)\n-\t(plus:DI (reg:DI SP_REG) (const_int 8)))]\n-  \"TARGET_64BIT\"\n-  \"pop{q}\\t%0\"\n-  [(set_attr \"type\" \"pop\")\n-   (set_attr \"mode\" \"DI\")])\n-\n-(define_insn \"popsi1\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r*m\")\n-\t(mem:SI (reg:SI SP_REG)))\n-   (set (reg:SI SP_REG)\n-\t(plus:SI (reg:SI SP_REG) (const_int 4)))]\n-  \"!TARGET_64BIT\"\n-  \"pop{l}\\t%0\"\n-  [(set_attr \"type\" \"pop\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*popdi1_epilogue\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r*m\")\n-\t(mem:DI (reg:DI SP_REG)))\n-   (set (reg:DI SP_REG)\n-\t(plus:DI (reg:DI SP_REG) (const_int 8)))\n-   (clobber (mem:BLK (scratch)))]\n-  \"TARGET_64BIT\"\n-  \"pop{q}\\t%0\"\n+(define_insn \"pop<mode>1\"\n+  [(set (match_operand:P 0 \"nonimmediate_operand\" \"=r*m\")\n+\t(match_operand:P 1 \"pop_operand\" \">\"))]\n+  \"\"\n+  \"pop{<imodesuffix>}\\t%0\"\n   [(set_attr \"type\" \"pop\")\n-   (set_attr \"mode\" \"DI\")])\n+   (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"*popsi1_epilogue\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r*m\")\n-\t(mem:SI (reg:SI SP_REG)))\n-   (set (reg:SI SP_REG)\n-\t(plus:SI (reg:SI SP_REG) (const_int 4)))\n+(define_insn \"*pop<mode>1_epilogue\"\n+  [(set (match_operand:P 0 \"nonimmediate_operand\" \"=r*m\")\n+\t(match_operand:P 1 \"pop_operand\" \">\"))\n    (clobber (mem:BLK (scratch)))]\n-  \"!TARGET_64BIT\"\n-  \"pop{l}\\t%0\"\n+  \"\"\n+  \"pop{<imodesuffix>}\\t%0\"\n   [(set_attr \"type\" \"pop\")\n-   (set_attr \"mode\" \"SI\")])\n+   (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"*mov<mode>_xor\"\n   [(set (match_operand:SWI48 0 \"register_operand\" \"=r\")\n@@ -17037,12 +17005,13 @@\n   \"operands[2] = GEN_INT (exact_log2 (INTVAL (operands[2])));\")\n \n ;; The ESP adjustments can be done by the push and pop instructions.  Resulting\n-;; code is shorter, since push is only 1 byte, while add imm, %esp 3 bytes.  On\n-;; many CPUs it is also faster, since special hardware to avoid esp\n+;; code is shorter, since push is only 1 byte, while add imm, %esp is 3 bytes.\n+;; On many CPUs it is also faster, since special hardware to avoid esp\n ;; dependencies is present.\n \n-;; While some of these conversions may be done using splitters, we use peepholes\n-;; in order to allow combine_stack_adjustments pass to see nonobfuscated RTL.\n+;; While some of these conversions may be done using splitters, we use\n+;; peepholes in order to allow combine_stack_adjustments pass to see\n+;; nonobfuscated RTL.\n \n ;; Convert prologue esp subtractions to push.\n ;; We need register to push.  In order to keep verify_flow_info happy we have\n@@ -17101,74 +17070,58 @@\n \t      (clobber (reg:CC FLAGS_REG))\n \t      (clobber (mem:BLK (scratch)))])]\n   \"optimize_insn_for_size_p () || !TARGET_ADD_ESP_4\"\n-  [(parallel [(set (match_dup 0) (mem:SI (reg:SI SP_REG)))\n-\t      (set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (const_int 4)))\n-\t      (clobber (mem:BLK (scratch)))])]\n-  \"\")\n+  [(parallel [(set (match_dup 0) (mem:SI (post_inc:SI (reg:SI SP_REG))))\n+\t      (clobber (mem:BLK (scratch)))])])\n \n-;; Two pops case is tricky, since pop causes dependency on destination register.\n-;; We use two registers if available.\n+;; Two pops case is tricky, since pop causes dependency\n+;; on destination register.  We use two registers if available.\n (define_peephole2\n   [(match_scratch:SI 0 \"r\")\n    (match_scratch:SI 1 \"r\")\n    (parallel [(set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (const_int 8)))\n \t      (clobber (reg:CC FLAGS_REG))\n \t      (clobber (mem:BLK (scratch)))])]\n   \"optimize_insn_for_size_p () || !TARGET_ADD_ESP_8\"\n-  [(parallel [(set (match_dup 0) (mem:SI (reg:SI SP_REG)))\n-\t      (set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (const_int 4)))\n+  [(parallel [(set (match_dup 0) (mem:SI (post_inc:SI (reg:SI SP_REG))))\n \t      (clobber (mem:BLK (scratch)))])\n-   (parallel [(set (match_dup 1) (mem:SI (reg:SI SP_REG)))\n-\t      (set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (const_int 4)))])]\n-  \"\")\n+   (set (match_dup 1) (mem:SI (post_inc:SI (reg:SI SP_REG))))])\n \n (define_peephole2\n   [(match_scratch:SI 0 \"r\")\n    (parallel [(set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (const_int 8)))\n \t      (clobber (reg:CC FLAGS_REG))\n \t      (clobber (mem:BLK (scratch)))])]\n   \"optimize_insn_for_size_p ()\"\n-  [(parallel [(set (match_dup 0) (mem:SI (reg:SI SP_REG)))\n-\t      (set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (const_int 4)))\n+  [(parallel [(set (match_dup 0) (mem:SI (post_inc:SI (reg:SI SP_REG))))\n \t      (clobber (mem:BLK (scratch)))])\n-   (parallel [(set (match_dup 0) (mem:SI (reg:SI SP_REG)))\n-\t      (set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (const_int 4)))])]\n-  \"\")\n+   (set (match_dup 0) (mem:SI (post_inc:SI (reg:SI SP_REG))))])\n \n ;; Convert esp additions to pop.\n (define_peephole2\n   [(match_scratch:SI 0 \"r\")\n    (parallel [(set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (const_int 4)))\n \t      (clobber (reg:CC FLAGS_REG))])]\n   \"\"\n-  [(parallel [(set (match_dup 0) (mem:SI (reg:SI SP_REG)))\n-\t      (set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (const_int 4)))])]\n-  \"\")\n+  [(set (match_dup 0) (mem:SI (post_inc:SI (reg:SI SP_REG))))])\n \n-;; Two pops case is tricky, since pop causes dependency on destination register.\n-;; We use two registers if available.\n+;; Two pops case is tricky, since pop causes dependency\n+;; on destination register.  We use two registers if available.\n (define_peephole2\n   [(match_scratch:SI 0 \"r\")\n    (match_scratch:SI 1 \"r\")\n    (parallel [(set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (const_int 8)))\n \t      (clobber (reg:CC FLAGS_REG))])]\n   \"\"\n-  [(parallel [(set (match_dup 0) (mem:SI (reg:SI SP_REG)))\n-\t      (set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (const_int 4)))])\n-   (parallel [(set (match_dup 1) (mem:SI (reg:SI SP_REG)))\n-\t      (set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (const_int 4)))])]\n-  \"\")\n+  [(set (match_dup 0) (mem:SI (post_inc:SI (reg:SI SP_REG))))\n+   (set (match_dup 1) (mem:SI (post_inc:SI (reg:SI SP_REG))))])\n \n (define_peephole2\n   [(match_scratch:SI 0 \"r\")\n    (parallel [(set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (const_int 8)))\n \t      (clobber (reg:CC FLAGS_REG))])]\n   \"optimize_insn_for_size_p ()\"\n-  [(parallel [(set (match_dup 0) (mem:SI (reg:SI SP_REG)))\n-\t      (set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (const_int 4)))])\n-   (parallel [(set (match_dup 0) (mem:SI (reg:SI SP_REG)))\n-\t      (set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (const_int 4)))])]\n-  \"\")\n+  [(set (match_dup 0) (mem:SI (post_inc:SI (reg:SI SP_REG))))\n+   (set (match_dup 0) (mem:SI (post_inc:SI (reg:SI SP_REG))))])\n \f\n (define_peephole2\n   [(match_scratch:DI 0 \"r\")\n@@ -17216,74 +17169,58 @@\n \t      (clobber (reg:CC FLAGS_REG))\n \t      (clobber (mem:BLK (scratch)))])]\n   \"optimize_insn_for_size_p () || !TARGET_ADD_ESP_4\"\n-  [(parallel [(set (match_dup 0) (mem:DI (reg:DI SP_REG)))\n-\t      (set (reg:DI SP_REG) (plus:DI (reg:DI SP_REG) (const_int 8)))\n-\t      (clobber (mem:BLK (scratch)))])]\n-  \"\")\n+  [(parallel [(set (match_dup 0) (mem:DI (post_inc:DI (reg:DI SP_REG))))\n+\t      (clobber (mem:BLK (scratch)))])])\n \n-;; Two pops case is tricky, since pop causes dependency on destination register.\n-;; We use two registers if available.\n+;; Two pops case is tricky, since pop causes dependency\n+;; on destination register.  We use two registers if available.\n (define_peephole2\n   [(match_scratch:DI 0 \"r\")\n    (match_scratch:DI 1 \"r\")\n    (parallel [(set (reg:DI SP_REG) (plus:DI (reg:DI SP_REG) (const_int 16)))\n \t      (clobber (reg:CC FLAGS_REG))\n \t      (clobber (mem:BLK (scratch)))])]\n   \"optimize_insn_for_size_p () || !TARGET_ADD_ESP_8\"\n-  [(parallel [(set (match_dup 0) (mem:DI (reg:DI SP_REG)))\n-\t      (set (reg:DI SP_REG) (plus:DI (reg:DI SP_REG) (const_int 8)))\n+  [(parallel [(set (match_dup 0) (mem:DI (post_inc:DI (reg:DI SP_REG))))\n \t      (clobber (mem:BLK (scratch)))])\n-   (parallel [(set (match_dup 1) (mem:DI (reg:DI SP_REG)))\n-\t      (set (reg:DI SP_REG) (plus:DI (reg:DI SP_REG) (const_int 8)))])]\n-  \"\")\n+   (set (match_dup 1) (mem:DI (post_inc:DI (reg:DI SP_REG))))])\n \n (define_peephole2\n   [(match_scratch:DI 0 \"r\")\n    (parallel [(set (reg:DI SP_REG) (plus:DI (reg:DI SP_REG) (const_int 16)))\n \t      (clobber (reg:CC FLAGS_REG))\n \t      (clobber (mem:BLK (scratch)))])]\n   \"optimize_insn_for_size_p ()\"\n-  [(parallel [(set (match_dup 0) (mem:DI (reg:DI SP_REG)))\n-\t      (set (reg:DI SP_REG) (plus:DI (reg:DI SP_REG) (const_int 8)))\n+  [(parallel [(set (match_dup 0) (mem:DI (post_inc:DI (reg:DI SP_REG))))\n \t      (clobber (mem:BLK (scratch)))])\n-   (parallel [(set (match_dup 0) (mem:DI (reg:DI SP_REG)))\n-\t      (set (reg:DI SP_REG) (plus:DI (reg:DI SP_REG) (const_int 8)))])]\n-  \"\")\n+   (set (match_dup 0) (mem:DI (post_inc:DI (reg:DI SP_REG))))])\n \n ;; Convert esp additions to pop.\n (define_peephole2\n   [(match_scratch:DI 0 \"r\")\n    (parallel [(set (reg:DI SP_REG) (plus:DI (reg:DI SP_REG) (const_int 8)))\n \t      (clobber (reg:CC FLAGS_REG))])]\n   \"\"\n-  [(parallel [(set (match_dup 0) (mem:DI (reg:DI SP_REG)))\n-\t      (set (reg:DI SP_REG) (plus:DI (reg:DI SP_REG) (const_int 8)))])]\n-  \"\")\n+  [(set (match_dup 0) (mem:DI (post_inc:DI (reg:DI SP_REG))))])\n \n-;; Two pops case is tricky, since pop causes dependency on destination register.\n-;; We use two registers if available.\n+;; Two pops case is tricky, since pop causes dependency\n+;; on destination register.  We use two registers if available.\n (define_peephole2\n   [(match_scratch:DI 0 \"r\")\n    (match_scratch:DI 1 \"r\")\n    (parallel [(set (reg:DI SP_REG) (plus:DI (reg:DI SP_REG) (const_int 16)))\n \t      (clobber (reg:CC FLAGS_REG))])]\n   \"\"\n-  [(parallel [(set (match_dup 0) (mem:DI (reg:DI SP_REG)))\n-\t      (set (reg:DI SP_REG) (plus:DI (reg:DI SP_REG) (const_int 8)))])\n-   (parallel [(set (match_dup 1) (mem:DI (reg:DI SP_REG)))\n-\t      (set (reg:DI SP_REG) (plus:DI (reg:DI SP_REG) (const_int 8)))])]\n-  \"\")\n+  [(set (match_dup 0) (mem:DI (post_inc:DI (reg:DI SP_REG))))\n+   (set (match_dup 1) (mem:DI (post_inc:DI (reg:DI SP_REG))))])\n \n (define_peephole2\n   [(match_scratch:DI 0 \"r\")\n    (parallel [(set (reg:DI SP_REG) (plus:DI (reg:DI SP_REG) (const_int 16)))\n \t      (clobber (reg:CC FLAGS_REG))])]\n   \"optimize_insn_for_size_p ()\"\n-  [(parallel [(set (match_dup 0) (mem:DI (reg:DI SP_REG)))\n-\t      (set (reg:DI SP_REG) (plus:DI (reg:DI SP_REG) (const_int 8)))])\n-   (parallel [(set (match_dup 0) (mem:DI (reg:DI SP_REG)))\n-\t      (set (reg:DI SP_REG) (plus:DI (reg:DI SP_REG) (const_int 8)))])]\n-  \"\")\n+  [(set (match_dup 0) (mem:DI (post_inc:DI (reg:DI SP_REG))))\n+   (set (match_dup 0) (mem:DI (post_inc:DI (reg:DI SP_REG))))])\n \f\n ;; Convert compares with 1 to shorter inc/dec operations when CF is not\n ;; required and register dies.  Similarly for 128 to -128."}]}