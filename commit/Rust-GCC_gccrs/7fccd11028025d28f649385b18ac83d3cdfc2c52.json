{"sha": "7fccd11028025d28f649385b18ac83d3cdfc2c52", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2ZjY2QxMTAyODAyNWQyOGY2NDkzODViMThhYzgzZDNjZGZjMmM1Mg==", "commit": {"author": {"name": "Ulrich Drepper", "email": "drepper@gcc.gnu.org", "date": "1999-02-04T15:51:42Z"}, "committer": {"name": "Ulrich Drepper", "email": "drepper@gcc.gnu.org", "date": "1999-02-04T15:51:42Z"}, "message": "Add support for Solaris thread library.\n\nFrom-SVN: r25028", "tree": {"sha": "9192669da2a51ce71f85b6e812569666d0fc863d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9192669da2a51ce71f85b6e812569666d0fc863d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7fccd11028025d28f649385b18ac83d3cdfc2c52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fccd11028025d28f649385b18ac83d3cdfc2c52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7fccd11028025d28f649385b18ac83d3cdfc2c52", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fccd11028025d28f649385b18ac83d3cdfc2c52/comments", "author": null, "committer": null, "parents": [{"sha": "b76354a5429ae957a4dae83f2273bd4204323138", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b76354a5429ae957a4dae83f2273bd4204323138", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b76354a5429ae957a4dae83f2273bd4204323138"}], "stats": {"total": 73, "additions": 47, "deletions": 26}, "files": [{"sha": "51115b23482f39868173df43cbaf2fc050c68a5b", "filename": "libstdc++/stl/stl_alloc.h", "status": "modified", "additions": 47, "deletions": 26, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fccd11028025d28f649385b18ac83d3cdfc2c52/libstdc%2B%2B%2Fstl%2Fstl_alloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fccd11028025d28f649385b18ac83d3cdfc2c52/libstdc%2B%2B%2Fstl%2Fstl_alloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_alloc.h?ref=7fccd11028025d28f649385b18ac83d3cdfc2c52", "patch": "@@ -58,7 +58,8 @@\n #  define __RESTRICT\n #endif\n \n-#if !defined(__STL_PTHREADS) && !defined(_NOTHREADS) \\\n+#if !defined(__STL_PTHREADS) && !defined(__STL_SOLTHREADS) \\\n+ && !defined(_NOTHREADS) \\\n  && !defined(__STL_SGI_THREADS) && !defined(__STL_WIN32THREADS)\n #   define _NOTHREADS\n #endif\n@@ -75,6 +76,15 @@\n #   define __NODE_ALLOCATOR_THREADS true\n #   define __VOLATILE volatile  // Needed at -O3 on SGI\n # endif\n+# ifdef __STL_SOLTHREADS\n+#   include <thread.h>\n+#   define __NODE_ALLOCATOR_LOCK \\\n+\tif (threads) mutex_lock(&_S_node_allocator_lock)\n+#   define __NODE_ALLOCATOR_UNLOCK \\\n+        if (threads) mutex_unlock(&_S_node_allocator_lock)\n+#   define __NODE_ALLOCATOR_THREADS true\n+#   define __VOLATILE\n+# endif\n # ifdef __STL_WIN32THREADS\n     // The lock needs to be initialized by constructing an allocator\n     // objects of the right type.  We do that here explicitly for alloc.\n@@ -318,7 +328,7 @@ class __default_alloc_template {\n     enum {_NFREELISTS = _MAX_BYTES/_ALIGN};\n # endif\n   static size_t\n-  _S_round_up(size_t __bytes) \n+  _S_round_up(size_t __bytes)\n     { return (((__bytes) + _ALIGN-1) & ~(_ALIGN - 1)); }\n \n __PRIVATE:\n@@ -328,10 +338,10 @@ class __default_alloc_template {\n   };\n private:\n # ifdef __SUNPRO_CC\n-    static _Obj* __VOLATILE _S_free_list[]; \n+    static _Obj* __VOLATILE _S_free_list[];\n         // Specifying a size results in duplicate def for 4.1\n # else\n-    static _Obj* __VOLATILE _S_free_list[_NFREELISTS]; \n+    static _Obj* __VOLATILE _S_free_list[_NFREELISTS];\n # endif\n   static  size_t _S_freelist_index(size_t __bytes) {\n         return (((__bytes) + _ALIGN-1)/_ALIGN - 1);\n@@ -350,14 +360,18 @@ class __default_alloc_template {\n \n # ifdef __STL_SGI_THREADS\n     static volatile unsigned long _S_node_allocator_lock;\n-    static void _S_lock(volatile unsigned long*); \n+    static void _S_lock(volatile unsigned long*);\n     static inline void _S_unlock(volatile unsigned long*);\n # endif\n \n # ifdef __STL_PTHREADS\n     static pthread_mutex_t _S_node_allocator_lock;\n # endif\n \n+# ifdef __STL_SOLTHREADS\n+    static mutex_t _S_node_allocator_lock;\n+# endif\n+\n # ifdef __STL_WIN32THREADS\n     static CRITICAL_SECTION _S_node_allocator_lock;\n     static bool _S_node_allocator_lock_initialized;\n@@ -445,7 +459,7 @@ typedef __default_alloc_template<false, 0> single_client_alloc;\n /* We hold the allocation lock.                                         */\n template <bool __threads, int __inst>\n char*\n-__default_alloc_template<__threads, __inst>::_S_chunk_alloc(size_t __size, \n+__default_alloc_template<__threads, __inst>::_S_chunk_alloc(size_t __size,\n                                                             int& __nobjs)\n {\n     char* __result;\n@@ -463,7 +477,7 @@ __default_alloc_template<__threads, __inst>::_S_chunk_alloc(size_t __size,\n         _S_start_free += __total_bytes;\n         return(__result);\n     } else {\n-        size_t __bytes_to_get = \n+        size_t __bytes_to_get =\n \t  2 * __total_bytes + _S_round_up(_S_heap_size >> 4);\n         // Try to make use of the left-over piece.\n         if (__bytes_left > 0) {\n@@ -567,6 +581,13 @@ __default_alloc_template<threads, inst>::reallocate(void* __p,\n         = PTHREAD_MUTEX_INITIALIZER;\n #endif\n \n+#ifdef __STL_SOLTHREADS\n+    template <bool __threads, int __inst>\n+    mutex_t\n+    __default_alloc_template<__threads, __inst>::_S_node_allocator_lock\n+        = DEFAULTMUTEX;\n+#endif\n+\n #ifdef __STL_WIN32THREADS\n     template <bool __threads, int __inst>\n     CRITICAL_SECTION\n@@ -597,7 +618,7 @@ __default_alloc_template<__threads, __inst>::_S_node_allocator_lock = 0;\n #endif\n \n template <bool __threads, int __inst>\n-void \n+void\n __default_alloc_template<__threads, __inst>::\n   _S_lock(volatile unsigned long* __lock)\n {\n@@ -659,7 +680,7 @@ __default_alloc_template<__threads, __inst>::_S_unlock(\n         *__lock = 0;\n #   elif __mips >= 3 && (defined (_ABIN32) || defined(_ABI64))\n         __lock_release(__lock);\n-#   else \n+#   else\n         *__lock = 0;\n         // This is not sufficient on many multiprocessors, since\n         // writes to protected variables and the lock may be reordered.\n@@ -694,7 +715,7 @@ __default_alloc_template<__threads, __inst> ::_S_free_list[\n \n #endif /* ! __USE_MALLOC */\n \n-// This implements allocators as specified in the C++ standard.  \n+// This implements allocators as specified in the C++ standard.\n //\n // Note that standard-conforming allocators use many language features\n // that are not yet widely implemented.  In particular, they rely on\n@@ -731,15 +752,15 @@ class allocator {\n   // __n is permitted to be 0.  The C++ standard says nothing about what\n   // the return value is when __n == 0.\n   _Tp* allocate(size_type __n, const void* = 0) {\n-    return __n != 0 ? static_cast<_Tp*>(_Alloc::allocate(__n * sizeof(_Tp))) \n+    return __n != 0 ? static_cast<_Tp*>(_Alloc::allocate(__n * sizeof(_Tp)))\n                     : 0;\n   }\n \n   // __p is not permitted to be a null pointer.\n   void deallocate(pointer __p, size_type __n)\n     { _Alloc::deallocate(__p, __n * sizeof(_Tp)); }\n \n-  size_type max_size() const __STL_NOTHROW \n+  size_type max_size() const __STL_NOTHROW\n     { return size_t(-1) / sizeof(_Tp); }\n \n   void construct(pointer __p, const _Tp& __val) { new(__p) _Tp(__val); }\n@@ -761,7 +782,7 @@ class allocator<void> {\n \n \n template <class _T1, class _T2>\n-inline bool operator==(const allocator<_T1>&, const allocator<_T2>&) \n+inline bool operator==(const allocator<_T1>&, const allocator<_T2>&)\n {\n   return true;\n }\n@@ -776,7 +797,7 @@ inline bool operator!=(const allocator<_T1>&, const allocator<_T2>&)\n // into a standard-conforming allocator.   Note that this adaptor does\n // *not* assume that all objects of the underlying alloc class are\n // identical, nor does it assume that all of the underlying alloc's\n-// member functions are static member functions.  Note, also, that \n+// member functions are static member functions.  Note, also, that\n // __allocator<_Tp, alloc> is essentially the same thing as allocator<_Tp>.\n \n template <class _Tp, class _Alloc>\n@@ -798,7 +819,7 @@ struct __allocator {\n   __allocator() __STL_NOTHROW {}\n   __allocator(const __allocator& __a) __STL_NOTHROW\n     : __underlying_alloc(__a.__underlying_alloc) {}\n-  template <class _Tp1> \n+  template <class _Tp1>\n   __allocator(const __allocator<_Tp1, _Alloc>& __a) __STL_NOTHROW\n     : __underlying_alloc(__a.__underlying_alloc) {}\n   ~__allocator() __STL_NOTHROW {}\n@@ -808,16 +829,16 @@ struct __allocator {\n \n   // __n is permitted to be 0.\n   _Tp* allocate(size_type __n, const void* = 0) {\n-    return __n != 0 \n-        ? static_cast<_Tp*>(__underlying_alloc.allocate(__n * sizeof(_Tp))) \n+    return __n != 0\n+        ? static_cast<_Tp*>(__underlying_alloc.allocate(__n * sizeof(_Tp)))\n         : 0;\n   }\n \n   // __p is not permitted to be a null pointer.\n   void deallocate(pointer __p, size_type __n)\n     { __underlying_alloc.deallocate(__p, __n * sizeof(_Tp)); }\n \n-  size_type max_size() const __STL_NOTHROW \n+  size_type max_size() const __STL_NOTHROW\n     { return size_t(-1) / sizeof(_Tp); }\n \n   void construct(pointer __p, const _Tp& __val) { new(__p) _Tp(__val); }\n@@ -935,7 +956,7 @@ template <class _Tp, class _Allocator>\n struct _Alloc_traits\n {\n   static const bool _S_instanceless = false;\n-  typedef typename _Allocator::__STL_TEMPLATE rebind<_Tp>::other \n+  typedef typename _Allocator::__STL_TEMPLATE rebind<_Tp>::other\n           allocator_type;\n };\n \n@@ -966,9 +987,9 @@ template <class _Tp, bool __threads, int __inst>\n struct _Alloc_traits<_Tp, __default_alloc_template<__threads, __inst> >\n {\n   static const bool _S_instanceless = true;\n-  typedef simple_alloc<_Tp, __default_alloc_template<__threads, __inst> > \n+  typedef simple_alloc<_Tp, __default_alloc_template<__threads, __inst> >\n           _Alloc_type;\n-  typedef __allocator<_Tp, __default_alloc_template<__threads, __inst> > \n+  typedef __allocator<_Tp, __default_alloc_template<__threads, __inst> >\n           allocator_type;\n };\n \n@@ -984,7 +1005,7 @@ struct _Alloc_traits<_Tp, debug_alloc<_Alloc> >\n // SGI-style allocators.\n \n template <class _Tp, class _Tp1, int __inst>\n-struct _Alloc_traits<_Tp, \n+struct _Alloc_traits<_Tp,\n                      __allocator<_Tp1, __malloc_alloc_template<__inst> > >\n {\n   static const bool _S_instanceless = true;\n@@ -993,14 +1014,14 @@ struct _Alloc_traits<_Tp,\n };\n \n template <class _Tp, class _Tp1, bool __thr, int __inst>\n-struct _Alloc_traits<_Tp, \n-                      __allocator<_Tp1, \n+struct _Alloc_traits<_Tp,\n+                      __allocator<_Tp1,\n                                   __default_alloc_template<__thr, __inst> > >\n {\n   static const bool _S_instanceless = true;\n-  typedef simple_alloc<_Tp, __default_alloc_template<__thr,__inst> > \n+  typedef simple_alloc<_Tp, __default_alloc_template<__thr,__inst> >\n           _Alloc_type;\n-  typedef __allocator<_Tp, __default_alloc_template<__thr,__inst> > \n+  typedef __allocator<_Tp, __default_alloc_template<__thr,__inst> >\n           allocator_type;\n };\n "}]}