{"sha": "c1bd2d6675c9ef4eee8af1ded66b32f9238ef5eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzFiZDJkNjY3NWM5ZWY0ZWVlOGFmMWRlZDY2YjMyZjkyMzhlZjVlYg==", "commit": {"author": {"name": "Eric Christopher", "email": "echristo@redhat.com", "date": "2005-06-02T18:08:20Z"}, "committer": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2005-06-02T18:08:20Z"}, "message": "mips.h (processor_type): Remove PROCESSOR_DEFAULT, add PROCESSOR_MAX.\n\n2005-06-02  Eric Christopher  <echristo@redhat.com>\n\n\t* config/mips/mips.h (processor_type): Remove PROCESSOR_DEFAULT,\n\tadd PROCESSOR_MAX.\n\t(mips_rtx_cost_data): New datatype.\n\t(MEMORY_MOVE_COST): Use data from structure.\n\t(BRANCH_COST): Ditto.\n\t(LOGICAL_OP_NON_SHORT_CIRCUIT): Define to zero.\n\t* config/mips/mips.md (cpu): Rework for processor_type changes.\n\t* config/mips/mips.c (mips_cost): New variable.\n\t(DEFAULT_COSTS): Define.\n\t(mips_rtx_cost_data): New.\n\t(mips_rtx_costs): Use. Minor formatting changes. Use COSTS_N_INSNS\n\tfor NEG cost. Add support for FLOAT, UNSIGNED_FLOAT, FIX,\n\tFLOAT_EXTEND, FLOAT_TRUNCATE, and SQRT.\n\t(override_options): Set cost data.\n\t(mips_register_move_cost): Formatting changes.\n\t(bdesc_arrays): Use PROCESSOR_MAX.\n\t(mips_init_builtins): Ditto.\n\nFrom-SVN: r100503", "tree": {"sha": "c4c1f0ac0b576d592885fab389559d467e3b2882", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c4c1f0ac0b576d592885fab389559d467e3b2882"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c1bd2d6675c9ef4eee8af1ded66b32f9238ef5eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1bd2d6675c9ef4eee8af1ded66b32f9238ef5eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1bd2d6675c9ef4eee8af1ded66b32f9238ef5eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1bd2d6675c9ef4eee8af1ded66b32f9238ef5eb/comments", "author": {"login": "echristo", "id": 327308, "node_id": "MDQ6VXNlcjMyNzMwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/327308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/echristo", "html_url": "https://github.com/echristo", "followers_url": "https://api.github.com/users/echristo/followers", "following_url": "https://api.github.com/users/echristo/following{/other_user}", "gists_url": "https://api.github.com/users/echristo/gists{/gist_id}", "starred_url": "https://api.github.com/users/echristo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/echristo/subscriptions", "organizations_url": "https://api.github.com/users/echristo/orgs", "repos_url": "https://api.github.com/users/echristo/repos", "events_url": "https://api.github.com/users/echristo/events{/privacy}", "received_events_url": "https://api.github.com/users/echristo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3e3935a94ce8702a788cd3e76eab584ed09277e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e3935a94ce8702a788cd3e76eab584ed09277e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e3935a94ce8702a788cd3e76eab584ed09277e8"}], "stats": {"total": 570, "additions": 384, "deletions": 186}, "files": [{"sha": "fa38950efbfc29e6d1518dbd7b6f569eb032055a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bd2d6675c9ef4eee8af1ded66b32f9238ef5eb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bd2d6675c9ef4eee8af1ded66b32f9238ef5eb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c1bd2d6675c9ef4eee8af1ded66b32f9238ef5eb", "patch": "@@ -1,3 +1,23 @@\n+2005-06-02  Eric Christopher  <echristo@redhat.com>\n+\n+\t* config/mips/mips.h (processor_type): Remove PROCESSOR_DEFAULT,\n+\tadd PROCESSOR_MAX.\n+\t(mips_rtx_cost_data): New datatype.\n+\t(MEMORY_MOVE_COST): Use data from structure.\n+\t(BRANCH_COST): Ditto.\n+\t(LOGICAL_OP_NON_SHORT_CIRCUIT): Define to zero.\n+\t* config/mips/mips.md (cpu): Rework for processor_type changes.\n+\t* config/mips/mips.c (mips_cost): New variable.\n+\t(DEFAULT_COSTS): Define.\n+\t(mips_rtx_cost_data): New.\n+\t(mips_rtx_costs): Use. Minor formatting changes. Use COSTS_N_INSNS\n+\tfor NEG cost. Add support for FLOAT, UNSIGNED_FLOAT, FIX,\n+\tFLOAT_EXTEND, FLOAT_TRUNCATE, and SQRT.\n+\t(override_options): Set cost data.\n+\t(mips_register_move_cost): Formatting changes.\n+\t(bdesc_arrays): Use PROCESSOR_MAX.\n+\t(mips_init_builtins): Ditto.\n+\n 2005-06-02  Diego Novillo  <dnovillo@redhat.com>\n \n \tPR 21765"}, {"sha": "101d542dd638535c647e258454c15798390998ae", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 339, "deletions": 175, "changes": 514, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bd2d6675c9ef4eee8af1ded66b32f9238ef5eb/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bd2d6675c9ef4eee8af1ded66b32f9238ef5eb/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=c1bd2d6675c9ef4eee8af1ded66b32f9238ef5eb", "patch": "@@ -549,6 +549,9 @@ int mips_isa;\n /* Which ABI to use.  */\n int mips_abi = MIPS_ABI_DEFAULT;\n \n+/* Cost information to use.  */\n+const struct mips_rtx_cost_data *mips_cost;\n+\n /* Whether we are generating mips16 hard float code.  In mips16 mode\n    we always set TARGET_SOFT_FLOAT; this variable is nonzero if\n    -msoft-float was not specified by the user, which means that we\n@@ -708,6 +711,224 @@ const struct mips_cpu_info mips_cpu_info_table[] = {\n   /* End marker */\n   { 0, 0, 0 }\n };\n+\n+/* Default costs. If these are used for a processor we should look\n+   up the acutal costs.  */\n+#define DEFAULT_COSTS COSTS_N_INSNS (6),  /* fp_add */       \\\n+                      COSTS_N_INSNS (7),  /* fp_mult_sf */   \\\n+                      COSTS_N_INSNS (8),  /* fp_mult_df */   \\\n+                      COSTS_N_INSNS (23), /* fp_div_sf */    \\\n+                      COSTS_N_INSNS (36), /* fp_div_df */    \\\n+                      COSTS_N_INSNS (10), /* int_mult_si */  \\\n+                      COSTS_N_INSNS (10), /* int_mult_di */  \\\n+                      COSTS_N_INSNS (69), /* int_div_si */   \\\n+                      COSTS_N_INSNS (69), /* int_div_di */   \\\n+                                       2, /* branch_cost */  \\\n+                                       4  /* memory_latency */\n+\n+/* Need to replace these with the costs of calling the appropriate\n+   libgcc routine.  */\n+#define SOFT_FP_COSTS COSTS_N_INSNS (256), /* fp_add */       \\\n+                      COSTS_N_INSNS (256), /* fp_mult_sf */   \\\n+                      COSTS_N_INSNS (256), /* fp_mult_df */   \\\n+                      COSTS_N_INSNS (256), /* fp_div_sf */    \\\n+                      COSTS_N_INSNS (256)  /* fp_div_df */\n+\n+static struct mips_rtx_cost_data const mips_rtx_cost_data[PROCESSOR_MAX] =\n+  {\n+    { /* R3000 */\n+      COSTS_N_INSNS (2),            /* fp_add */\n+      COSTS_N_INSNS (4),            /* fp_mult_sf */\n+      COSTS_N_INSNS (5),            /* fp_mult_df */\n+      COSTS_N_INSNS (12),           /* fp_div_sf */\n+      COSTS_N_INSNS (19),           /* fp_div_df */\n+      COSTS_N_INSNS (12),           /* int_mult_si */\n+      COSTS_N_INSNS (12),           /* int_mult_di */\n+      COSTS_N_INSNS (35),           /* int_div_si */\n+      COSTS_N_INSNS (35),           /* int_div_di */\n+                       1,           /* branch_cost */\n+                       4            /* memory_latency */\n+\n+    },\n+    { /* 4KC */\n+      DEFAULT_COSTS\n+    },\n+    { /* 4KP */\n+      DEFAULT_COSTS\n+    },\n+    { /* 5KC */\n+      DEFAULT_COSTS\n+    },\n+    { /* 20KC */\n+      DEFAULT_COSTS\n+    },\n+    { /* 24k */\n+      DEFAULT_COSTS\n+    },\n+    { /* 24kx */\n+      DEFAULT_COSTS\n+    },\n+    { /* M4k */\n+      DEFAULT_COSTS\n+    },\n+    { /* R3900 */\n+      COSTS_N_INSNS (2),            /* fp_add */\n+      COSTS_N_INSNS (4),            /* fp_mult_sf */\n+      COSTS_N_INSNS (5),            /* fp_mult_df */\n+      COSTS_N_INSNS (12),           /* fp_div_sf */\n+      COSTS_N_INSNS (19),           /* fp_div_df */\n+      COSTS_N_INSNS (2),            /* int_mult_si */\n+      COSTS_N_INSNS (2),            /* int_mult_di */\n+      COSTS_N_INSNS (35),           /* int_div_si */\n+      COSTS_N_INSNS (35),           /* int_div_di */\n+                       1,           /* branch_cost */\n+                       4            /* memory_latency */\n+    },\n+    { /* R6000 */\n+      COSTS_N_INSNS (3),            /* fp_add */\n+      COSTS_N_INSNS (5),            /* fp_mult_sf */\n+      COSTS_N_INSNS (6),            /* fp_mult_df */\n+      COSTS_N_INSNS (15),           /* fp_div_sf */\n+      COSTS_N_INSNS (16),           /* fp_div_df */\n+      COSTS_N_INSNS (17),           /* int_mult_si */\n+      COSTS_N_INSNS (17),           /* int_mult_di */\n+      COSTS_N_INSNS (38),           /* int_div_si */\n+      COSTS_N_INSNS (38),           /* int_div_di */\n+                       2,           /* branch_cost */\n+                       6            /* memory_latency */\n+    },\n+    { /* R4000 */\n+       COSTS_N_INSNS (6),           /* fp_add */\n+       COSTS_N_INSNS (7),           /* fp_mult_sf */\n+       COSTS_N_INSNS (8),           /* fp_mult_df */\n+       COSTS_N_INSNS (23),          /* fp_div_sf */\n+       COSTS_N_INSNS (36),          /* fp_div_df */\n+       COSTS_N_INSNS (10),          /* int_mult_si */\n+       COSTS_N_INSNS (10),          /* int_mult_di */\n+       COSTS_N_INSNS (69),          /* int_div_si */\n+       COSTS_N_INSNS (69),          /* int_div_di */\n+                        2,          /* branch_cost */\n+                        6           /* memory_latency */\n+    },\n+    { /* R4100 */\n+      DEFAULT_COSTS\n+    },\n+    { /* R4111 */\n+      DEFAULT_COSTS\n+    },\n+    { /* R4120 */\n+      DEFAULT_COSTS\n+    },\n+    { /* R4130 */\n+      /* The only costs that appear to be updated here are\n+\t integer multiplication.  */\n+      SOFT_FP_COSTS,\n+      COSTS_N_INSNS (4),            /* int_mult_si */\n+      COSTS_N_INSNS (6),            /* int_mult_di */\n+      COSTS_N_INSNS (69),           /* int_div_si */\n+      COSTS_N_INSNS (69),           /* int_div_di */\n+                       1,           /* branch_cost */\n+                       4            /* memory_latency */\n+    },\n+    { /* R4300 */\n+      DEFAULT_COSTS\n+    },\n+    { /* R4600 */\n+      DEFAULT_COSTS\n+    },\n+    { /* R4650 */\n+      DEFAULT_COSTS\n+    },\n+    { /* R5000 */\n+      COSTS_N_INSNS (6),            /* fp_add */\n+      COSTS_N_INSNS (4),            /* fp_mult_sf */\n+      COSTS_N_INSNS (5),            /* fp_mult_df */\n+      COSTS_N_INSNS (23),           /* fp_div_sf */\n+      COSTS_N_INSNS (36),           /* fp_div_df */\n+      COSTS_N_INSNS (5),            /* int_mult_si */\n+      COSTS_N_INSNS (5),            /* int_mult_di */\n+      COSTS_N_INSNS (36),           /* int_div_si */\n+      COSTS_N_INSNS (36),           /* int_div_di */\n+                       1,           /* branch_cost */\n+                       4            /* memory_latency */\n+    },\n+    { /* R5400 */\n+      COSTS_N_INSNS (6),            /* fp_add */\n+      COSTS_N_INSNS (5),            /* fp_mult_sf */\n+      COSTS_N_INSNS (6),            /* fp_mult_df */\n+      COSTS_N_INSNS (30),           /* fp_div_sf */\n+      COSTS_N_INSNS (59),           /* fp_div_df */\n+      COSTS_N_INSNS (3),            /* int_mult_si */\n+      COSTS_N_INSNS (4),            /* int_mult_di */\n+      COSTS_N_INSNS (42),           /* int_div_si */\n+      COSTS_N_INSNS (74),           /* int_div_di */\n+                       1,           /* branch_cost */\n+                       4            /* memory_latency */\n+    },\n+    { /* R5500 */\n+      COSTS_N_INSNS (6),            /* fp_add */\n+      COSTS_N_INSNS (5),            /* fp_mult_sf */\n+      COSTS_N_INSNS (6),            /* fp_mult_df */\n+      COSTS_N_INSNS (30),           /* fp_div_sf */\n+      COSTS_N_INSNS (59),           /* fp_div_df */\n+      COSTS_N_INSNS (5),            /* int_mult_si */\n+      COSTS_N_INSNS (9),            /* int_mult_di */\n+      COSTS_N_INSNS (42),           /* int_div_si */\n+      COSTS_N_INSNS (74),           /* int_div_di */\n+                       1,           /* branch_cost */\n+                       4            /* memory_latency */\n+    },\n+    { /* R7000 */\n+      /* The only costs that are changed here are\n+\t integer multiplication.  */\n+      COSTS_N_INSNS (6),            /* fp_add */\n+      COSTS_N_INSNS (7),            /* fp_mult_sf */\n+      COSTS_N_INSNS (8),            /* fp_mult_df */\n+      COSTS_N_INSNS (23),           /* fp_div_sf */\n+      COSTS_N_INSNS (36),           /* fp_div_df */\n+      COSTS_N_INSNS (5),            /* int_mult_si */\n+      COSTS_N_INSNS (9),            /* int_mult_di */\n+      COSTS_N_INSNS (69),           /* int_div_si */\n+      COSTS_N_INSNS (69),           /* int_div_di */\n+                       1,           /* branch_cost */\n+                       4            /* memory_latency */\n+    },\n+    { /* R8000 */\n+      DEFAULT_COSTS\n+    },\n+    { /* R9000 */\n+      /* The only costs that are changed here are\n+\t integer multiplication.  */\n+      COSTS_N_INSNS (6),            /* fp_add */\n+      COSTS_N_INSNS (7),            /* fp_mult_sf */\n+      COSTS_N_INSNS (8),            /* fp_mult_df */\n+      COSTS_N_INSNS (23),           /* fp_div_sf */\n+      COSTS_N_INSNS (36),           /* fp_div_df */\n+      COSTS_N_INSNS (3),            /* int_mult_si */\n+      COSTS_N_INSNS (8),            /* int_mult_di */\n+      COSTS_N_INSNS (69),           /* int_div_si */\n+      COSTS_N_INSNS (69),           /* int_div_di */\n+                       1,           /* branch_cost */\n+                       4            /* memory_latency */\n+    },\n+    { /* SB1 */\n+      COSTS_N_INSNS (4),            /* fp_add */\n+      COSTS_N_INSNS (4),            /* fp_mult_sf */\n+      COSTS_N_INSNS (4),            /* fp_mult_df */\n+      COSTS_N_INSNS (24),           /* fp_div_sf */\n+      COSTS_N_INSNS (32),           /* fp_div_df */\n+      COSTS_N_INSNS (3),            /* int_mult_si */\n+      COSTS_N_INSNS (4),            /* int_mult_di */\n+      COSTS_N_INSNS (36),           /* int_div_si */\n+      COSTS_N_INSNS (68),           /* int_div_di */\n+                       1,           /* branch_cost */\n+                       4            /* memory_latency */\n+    },\n+    { /* SR71000 */\n+      DEFAULT_COSTS\n+    },\n+  };\n+\n \f\n /* Nonzero if -march should decide the default value of MASK_SOFT_FLOAT.  */\n #ifndef MIPS_MARCH_CONTROLS_SOFT_FLOAT\n@@ -2084,75 +2305,80 @@ static bool\n mips_rtx_costs (rtx x, int code, int outer_code, int *total)\n {\n   enum machine_mode mode = GET_MODE (x);\n+  bool float_mode_p = FLOAT_MODE_P (mode);\n+\n+  /* To be used for soft-float costs.  */\n+  int max_cost = COSTS_N_INSNS (256);\n \n   switch (code)\n     {\n     case CONST_INT:\n-      if (!TARGET_MIPS16)\n-        {\n-          /* Always return 0, since we don't have different sized\n-             instructions, hence different costs according to Richard\n-             Kenner */\n-          *total = 0;\n-          return true;\n-        }\n-\n-      /* A number between 1 and 8 inclusive is efficient for a shift.\n-         Otherwise, we will need an extended instruction.  */\n-      if ((outer_code) == ASHIFT || (outer_code) == ASHIFTRT\n-          || (outer_code) == LSHIFTRT)\n+      if (TARGET_MIPS16)\n         {\n-          if (INTVAL (x) >= 1 && INTVAL (x) <= 8)\n-            *total = 0;\n-          else\n-            *total = COSTS_N_INSNS (1);\n-          return true;\n-        }\n+\t  /* A number between 1 and 8 inclusive is efficient for a shift.\n+\t     Otherwise, we will need an extended instruction.  */\n+\t  if ((outer_code) == ASHIFT || (outer_code) == ASHIFTRT\n+\t      || (outer_code) == LSHIFTRT)\n+\t    {\n+\t      if (INTVAL (x) >= 1 && INTVAL (x) <= 8)\n+\t\t*total = 0;\n+\t      else\n+\t\t*total = COSTS_N_INSNS (1);\n+\t      return true;\n+\t    }\n \n-      /* We can use cmpi for an xor with an unsigned 16 bit value.  */\n-      if ((outer_code) == XOR\n-          && INTVAL (x) >= 0 && INTVAL (x) < 0x10000)\n-        {\n-          *total = 0;\n-          return true;\n-        }\n+\t  /* We can use cmpi for an xor with an unsigned 16 bit value.  */\n+\t  if ((outer_code) == XOR\n+\t      && INTVAL (x) >= 0 && INTVAL (x) < 0x10000)\n+\t    {\n+\t      *total = 0;\n+\t      return true;\n+\t    }\n \n-      /* We may be able to use slt or sltu for a comparison with a\n-         signed 16 bit value.  (The boundary conditions aren't quite\n-         right, but this is just a heuristic anyhow.)  */\n-      if (((outer_code) == LT || (outer_code) == LE\n-           || (outer_code) == GE || (outer_code) == GT\n-           || (outer_code) == LTU || (outer_code) == LEU\n-           || (outer_code) == GEU || (outer_code) == GTU)\n-          && INTVAL (x) >= -0x8000 && INTVAL (x) < 0x8000)\n-        {\n-          *total = 0;\n-          return true;\n-        }\n+\t  /* We may be able to use slt or sltu for a comparison with a\n+\t     signed 16 bit value.  (The boundary conditions aren't quite\n+\t     right, but this is just a heuristic anyhow.)  */\n+\t  if (((outer_code) == LT || (outer_code) == LE\n+\t       || (outer_code) == GE || (outer_code) == GT\n+\t       || (outer_code) == LTU || (outer_code) == LEU\n+\t       || (outer_code) == GEU || (outer_code) == GTU)\n+\t      && INTVAL (x) >= -0x8000 && INTVAL (x) < 0x8000)\n+\t    {\n+\t      *total = 0;\n+\t      return true;\n+\t    }\n \n-      /* Equality comparisons with 0 are cheap.  */\n-      if (((outer_code) == EQ || (outer_code) == NE)\n-          && INTVAL (x) == 0)\n-        {\n-          *total = 0;\n-          return true;\n-        }\n+\t  /* Equality comparisons with 0 are cheap.  */\n+\t  if (((outer_code) == EQ || (outer_code) == NE)\n+\t      && INTVAL (x) == 0)\n+\t    {\n+\t      *total = 0;\n+\t      return true;\n+\t    }\n \n-      /* Constants in the range 0...255 can be loaded with an unextended\n-\t instruction.  They are therefore as cheap as a register move.\n+\t  /* Constants in the range 0...255 can be loaded with an unextended\n+\t     instruction.  They are therefore as cheap as a register move.\n \n-\t Given the choice between \"li R1,0...255\" and \"move R1,R2\"\n-\t (where R2 is a known constant), it is usually better to use \"li\",\n-\t since we do not want to unnecessarily extend the lifetime of R2.  */\n-      if (outer_code == SET\n-\t  && INTVAL (x) >= 0\n-\t  && INTVAL (x) < 256)\n+\t     Given the choice between \"li R1,0...255\" and \"move R1,R2\"\n+\t     (where R2 is a known constant), it is usually better to use \"li\",\n+\t     since we do not want to unnessarily extend the lifetime of R2.  */\n+\t  if (outer_code == SET\n+\t      && INTVAL (x) >= 0\n+\t      && INTVAL (x) < 256)\n+\t    {\n+\t      *total = 0;\n+\t      return true;\n+\t    }\n+\t}\n+      else\n \t{\n+\t  /* These can be used anywhere. */\n \t  *total = 0;\n \t  return true;\n \t}\n \n-      /* Otherwise fall through to the handling below.  */\n+      /* Otherwise fall through to the handling below because\n+\t we'll need to construct the constant.  */\n \n     case CONST:\n     case SYMBOL_REF:\n@@ -2172,15 +2398,15 @@ mips_rtx_costs (rtx x, int code, int outer_code, int *total)\n \n     case MEM:\n       {\n-        /* If the address is legitimate, return the number of\n-           instructions it needs, otherwise use the default handling.  */\n-        int n = mips_address_insns (XEXP (x, 0), GET_MODE (x));\n-        if (n > 0)\n-          {\n-            *total = COSTS_N_INSNS (1 + n);\n-            return true;\n-          }\n-        return false;\n+\t/* If the address is legitimate, return the number of\n+\t   instructions it needs, otherwise use the default handling.  */\n+\tint n = mips_address_insns (XEXP (x, 0), GET_MODE (x));\n+\tif (n > 0)\n+\t  {\n+\t    *total = COSTS_N_INSNS (n + 1);\n+\t    return true;\n+\t  }\n+\treturn false;\n       }\n \n     case FFS:\n@@ -2213,7 +2439,7 @@ mips_rtx_costs (rtx x, int code, int outer_code, int *total)\n       return false;\n \n     case ABS:\n-      if (mode == SFmode || mode == DFmode)\n+      if (float_mode_p)\n         *total = COSTS_N_INSNS (1);\n       else\n         *total = COSTS_N_INSNS (4);\n@@ -2225,19 +2451,13 @@ mips_rtx_costs (rtx x, int code, int outer_code, int *total)\n \n     case PLUS:\n     case MINUS:\n-      if (mode == SFmode || mode == DFmode)\n-        {\n-          if (TUNE_MIPS3000 || TUNE_MIPS3900)\n-            *total = COSTS_N_INSNS (2);\n-          else if (TUNE_MIPS6000)\n-            *total = COSTS_N_INSNS (3);\n-\t  else if (TUNE_SB1)\n-\t    *total = COSTS_N_INSNS (4);\n-          else\n-            *total = COSTS_N_INSNS (6);\n-          return true;\n-        }\n-      if (mode == DImode && !TARGET_64BIT)\n+      if (float_mode_p)\n+\t{\n+\t  *total = mips_cost->fp_add;\n+\t  return true;\n+\t}\n+\n+      else if (mode == DImode && !TARGET_64BIT)\n         {\n           *total = COSTS_N_INSNS (4);\n           return true;\n@@ -2247,115 +2467,46 @@ mips_rtx_costs (rtx x, int code, int outer_code, int *total)\n     case NEG:\n       if (mode == DImode && !TARGET_64BIT)\n         {\n-          *total = 4;\n+          *total = COSTS_N_INSNS (4);\n           return true;\n         }\n       return false;\n \n     case MULT:\n       if (mode == SFmode)\n-        {\n-          if (TUNE_MIPS3000\n-              || TUNE_MIPS3900\n-              || TUNE_MIPS5000\n-\t      || TUNE_SB1)\n-            *total = COSTS_N_INSNS (4);\n-          else if (TUNE_MIPS6000\n-                   || TUNE_MIPS5400\n-                   || TUNE_MIPS5500)\n-            *total = COSTS_N_INSNS (5);\n-          else\n-            *total = COSTS_N_INSNS (7);\n-          return true;\n-        }\n+\t*total = mips_cost->fp_mult_sf;\n \n-      if (mode == DFmode)\n-        {\n-          if (TUNE_SB1)\n-\t    *total = COSTS_N_INSNS (4);\n-          else if (TUNE_MIPS3000\n-              || TUNE_MIPS3900\n-              || TUNE_MIPS5000)\n-            *total = COSTS_N_INSNS (5);\n-          else if (TUNE_MIPS6000\n-                   || TUNE_MIPS5400\n-                   || TUNE_MIPS5500)\n-            *total = COSTS_N_INSNS (6);\n-          else\n-            *total = COSTS_N_INSNS (8);\n-          return true;\n-        }\n+      else if (mode == DFmode)\n+\t*total = mips_cost->fp_mult_df;\n+\n+      else if (mode == SImode)\n+\t*total = mips_cost->int_mult_si;\n \n-      if (TUNE_MIPS3000)\n-        *total = COSTS_N_INSNS (12);\n-      else if (TUNE_MIPS3900)\n-        *total = COSTS_N_INSNS (2);\n-      else if (TUNE_MIPS4130)\n-\t*total = COSTS_N_INSNS (mode == DImode ? 6 : 4);\n-      else if (TUNE_MIPS5400 || TUNE_SB1)\n-        *total = COSTS_N_INSNS (mode == DImode ? 4 : 3);\n-      else if (TUNE_MIPS5500 || TUNE_MIPS7000)\n-        *total = COSTS_N_INSNS (mode == DImode ? 9 : 5);\n-      else if (TUNE_MIPS9000)\n-        *total = COSTS_N_INSNS (mode == DImode ? 8 : 3);\n-      else if (TUNE_MIPS6000)\n-        *total = COSTS_N_INSNS (17);\n-      else if (TUNE_MIPS5000)\n-        *total = COSTS_N_INSNS (5);\n       else\n-        *total = COSTS_N_INSNS (10);\n+\t*total = mips_cost->int_mult_di;\n+\n       return true;\n \n     case DIV:\n     case MOD:\n-      if (mode == SFmode)\n-        {\n-          if (TUNE_MIPS3000\n-              || TUNE_MIPS3900)\n-            *total = COSTS_N_INSNS (12);\n-          else if (TUNE_MIPS6000)\n-            *total = COSTS_N_INSNS (15);\n-\t  else if (TUNE_SB1)\n-\t    *total = COSTS_N_INSNS (24);\n-          else if (TUNE_MIPS5400 || TUNE_MIPS5500)\n-            *total = COSTS_N_INSNS (30);\n-          else\n-            *total = COSTS_N_INSNS (23);\n-          return true;\n-        }\n+      if (float_mode_p)\n+\t{\n+\t  if (mode == SFmode)\n+\t    *total = mips_cost->fp_div_sf;\n+\t  else\n+\t    *total = mips_cost->fp_div_df;\n \n-      if (mode == DFmode)\n-        {\n-          if (TUNE_MIPS3000\n-              || TUNE_MIPS3900)\n-            *total = COSTS_N_INSNS (19);\n-          else if (TUNE_MIPS5400 || TUNE_MIPS5500)\n-            *total = COSTS_N_INSNS (59);\n-          else if (TUNE_MIPS6000)\n-            *total = COSTS_N_INSNS (16);\n-\t  else if (TUNE_SB1)\n-\t    *total = COSTS_N_INSNS (32);\n-          else\n-            *total = COSTS_N_INSNS (36);\n-          return true;\n-        }\n+\t  return true;\n+\t}\n       /* Fall through.  */\n \n     case UDIV:\n     case UMOD:\n-      if (TUNE_MIPS3000\n-          || TUNE_MIPS3900)\n-        *total = COSTS_N_INSNS (35);\n-      else if (TUNE_MIPS6000)\n-        *total = COSTS_N_INSNS (38);\n-      else if (TUNE_MIPS5000)\n-        *total = COSTS_N_INSNS (36);\n-      else if (TUNE_SB1)\n-\t*total = COSTS_N_INSNS ((mode == SImode) ? 36 : 68);\n-      else if (TUNE_MIPS5400 || TUNE_MIPS5500)\n-        *total = COSTS_N_INSNS ((mode == SImode) ? 42 : 74);\n+      if (mode == DImode)\n+        *total = mips_cost->int_div_di;\n       else\n-        *total = COSTS_N_INSNS (69);\n+\t*total = mips_cost->int_div_si;\n+\n       return true;\n \n     case SIGN_EXTEND:\n@@ -2377,6 +2528,15 @@ mips_rtx_costs (rtx x, int code, int outer_code, int *total)\n         *total = COSTS_N_INSNS (1);\n       return true;\n \n+    case FLOAT:\n+    case UNSIGNED_FLOAT:\n+    case FIX:\n+    case FLOAT_EXTEND:\n+    case FLOAT_TRUNCATE:\n+    case SQRT:\n+      *total = mips_cost->fp_add;\n+      return true;\n+\n     default:\n       return false;\n     }\n@@ -4306,6 +4466,9 @@ override_options (void)\n   if (mips_tune_info == 0)\n     mips_set_tune (mips_arch_info);\n \n+  /* Set cost structure for the processor.  */\n+  mips_cost = &mips_rtx_cost_data[mips_tune];\n+\n   if ((target_flags_explicit & MASK_64BIT) != 0)\n     {\n       /* The user specified the size of the integer registers.  Make sure\n@@ -8686,7 +8849,7 @@ mips_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n \t{\n \t  return 5;\n \t}\n-    }  /* GR_REG_CLASS_P (from) */\n+    }\n   else if (from == FP_REGS)\n     {\n       if (GR_REG_CLASS_P (to))\n@@ -8695,7 +8858,7 @@ mips_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n \treturn 2;\n       else if (to == ST_REGS)\n \treturn 8;\n-    }  /* from == FP_REGS */\n+    }\n   else if (from == HI_REG || from == LO_REG || from == MD_REGS)\n     {\n       if (GR_REG_CLASS_P (to))\n@@ -8705,15 +8868,16 @@ mips_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n \t  else\n \t    return 6;\n \t}\n-    }  /* from == HI_REG, etc.  */\n+    }\n   else if (from == ST_REGS && GR_REG_CLASS_P (to))\n     return 4;\n   else if (COP_REG_CLASS_P (from))\n     {\n       return 5;\n-    }  /* COP_REG_CLASS_P (from) */\n+    }\n \n-  /* Fall through.  */\n+  /* Fall through.\n+     ??? What cases are these? Shouldn't we return 2 here?  */\n \n   return 12;\n }\n@@ -9709,13 +9873,13 @@ struct bdesc_map\n   unsigned int size;\n \n   /* The target processor that supports these builtin functions.\n-     PROCESSOR_DEFAULT means we enable them for all processors.  */\n+     PROCESSOR_MAX means we enable them for all processors.  */\n   enum processor_type proc;\n };\n \n static const struct bdesc_map bdesc_arrays[] =\n {\n-  { mips_bdesc, ARRAY_SIZE (mips_bdesc), PROCESSOR_DEFAULT },\n+  { mips_bdesc, ARRAY_SIZE (mips_bdesc), PROCESSOR_MAX },\n   { sb1_bdesc, ARRAY_SIZE (sb1_bdesc), PROCESSOR_SB1 }\n };\n \n@@ -9890,7 +10054,7 @@ mips_init_builtins (void)\n   offset = 0;\n   for (m = bdesc_arrays; m < &bdesc_arrays[ARRAY_SIZE (bdesc_arrays)]; m++)\n     {\n-      if (m->proc == PROCESSOR_DEFAULT || (m->proc == mips_arch))\n+      if (m->proc == PROCESSOR_MAX || (m->proc == mips_arch))\n \tfor (d = m->bdesc; d < &m->bdesc[m->size]; d++)\n \t  if ((d->target_flags & target_flags) == d->target_flags)\n \t    lang_hooks.builtin_function (d->name, types[d->function_type],"}, {"sha": "6c9d343b530fa57d71ae1db972c3dca684c0632a", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 24, "deletions": 10, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bd2d6675c9ef4eee8af1ded66b32f9238ef5eb/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bd2d6675c9ef4eee8af1ded66b32f9238ef5eb/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=c1bd2d6675c9ef4eee8af1ded66b32f9238ef5eb", "patch": "@@ -32,15 +32,14 @@ Boston, MA 02111-1307, USA.  */\n    the cpu attribute in the mips.md machine description.  */\n \n enum processor_type {\n-  PROCESSOR_DEFAULT,\n+  PROCESSOR_R3000,\n   PROCESSOR_4KC,\n   PROCESSOR_4KP,\n   PROCESSOR_5KC,\n   PROCESSOR_20KC,\n   PROCESSOR_24K,\n   PROCESSOR_24KX,\n   PROCESSOR_M4K,\n-  PROCESSOR_R3000,\n   PROCESSOR_R3900,\n   PROCESSOR_R6000,\n   PROCESSOR_R4000,\n@@ -58,7 +57,25 @@ enum processor_type {\n   PROCESSOR_R8000,\n   PROCESSOR_R9000,\n   PROCESSOR_SB1,\n-  PROCESSOR_SR71000\n+  PROCESSOR_SR71000,\n+  PROCESSOR_MAX\n+};\n+\n+/* Costs of various operations on the different architectures.  */\n+\n+struct mips_rtx_cost_data\n+{\n+  unsigned short fp_add;\n+  unsigned short fp_mult_sf;\n+  unsigned short fp_mult_df;\n+  unsigned short fp_div_sf;\n+  unsigned short fp_div_df;\n+  unsigned short int_mult_si;\n+  unsigned short int_mult_di;\n+  unsigned short int_div_si;\n+  unsigned short int_div_di;\n+  unsigned short branch_cost;\n+  unsigned short memory_latency;\n };\n \n /* Which ABI to use.  ABI_32 (original 32, or o32), ABI_N32 (n32),\n@@ -108,6 +125,7 @@ extern int mips16_hard_float;\t\t/* mips16 without -msoft-float */\n extern const struct mips_cpu_info mips_cpu_info_table[];\n extern const struct mips_cpu_info *mips_arch_info;\n extern const struct mips_cpu_info *mips_tune_info;\n+extern const struct mips_rtx_cost_data *mips_cost;\n \n /* Macros to silence warnings about numbers being signed in traditional\n    C and unsigned in ISO C when compiled on 32-bit hosts.  */\n@@ -2299,9 +2317,8 @@ typedef struct mips_args {\n #define REGISTER_MOVE_COST(MODE, FROM, TO)\t\t\t\t\\\n   mips_register_move_cost (MODE, FROM, TO)\n \n-/* ??? Fix this to be right for the R8000.  */\n #define MEMORY_MOVE_COST(MODE,CLASS,TO_P) \\\n-  (((TUNE_MIPS4000 || TUNE_MIPS6000) ? 6 : 4) \\\n+  (mips_cost->memory_latency\t      \t\t\\\n    + memory_move_secondary_cost ((MODE), (CLASS), (TO_P)))\n \n /* Define if copies to/from condition code registers should be avoided.\n@@ -2314,11 +2331,8 @@ typedef struct mips_args {\n /* A C expression for the cost of a branch instruction.  A value of\n    1 is the default; other values are interpreted relative to that.  */\n \n-/* ??? Fix this to be right for the R8000.  */\n-#define BRANCH_COST\t\t\t\t\t\t\t\\\n-  ((! TARGET_MIPS16\t\t\t\t\t\t\t\\\n-    && (TUNE_MIPS4000 || TUNE_MIPS6000))\t\t\t\t\\\n-   ? 2 : 1)\n+#define BRANCH_COST mips_cost->branch_cost\n+#define LOGICAL_OP_NON_SHORT_CIRCUIT 0\n \n /* If defined, modifies the length assigned to instruction INSN as a\n    function of the context in which it is used.  LENGTH is an lvalue"}, {"sha": "e8a6b2a8576dba8140a1798aec95ac893e73689c", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bd2d6675c9ef4eee8af1ded66b32f9238ef5eb/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bd2d6675c9ef4eee8af1ded66b32f9238ef5eb/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=c1bd2d6675c9ef4eee8af1ded66b32f9238ef5eb", "patch": "@@ -266,7 +266,7 @@\n ;; Attribute describing the processor.  This attribute must match exactly\n ;; with the processor_type enumeration in mips.h.\n (define_attr \"cpu\"\n-  \"default,4kc,4kp,5kc,20kc,24k,24kx,m4k,r3000,r3900,r6000,r4000,r4100,r4111,r4120,r4130,r4300,r4600,r4650,r5000,r5400,r5500,r7000,r8000,r9000,sb1,sr71000\"\n+  \"r3000,4kc,4kp,5kc,20kc,24k,24kx,m4k,r3900,r6000,r4000,r4100,r4111,r4120,r4130,r4300,r4600,r4650,r5000,r5400,r5500,r7000,r8000,r9000,sb1,sr71000\"\n   (const (symbol_ref \"mips_tune\")))\n \n ;; The type of hardware hazard associated with this instruction."}]}