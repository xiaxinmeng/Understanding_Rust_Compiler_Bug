{"sha": "4934cc537b68343ba318335725b26567a767ecca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDkzNGNjNTM3YjY4MzQzYmEzMTgzMzU3MjViMjY1NjdhNzY3ZWNjYQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-11-01T06:57:01Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-11-01T06:57:01Z"}, "message": "ggc-page.c (struct page_entry): Remove save_num_free_objects.\n\n\t* ggc-page.c (struct page_entry): Remove save_num_free_objects.\n\t(DIV_ROUND_UP): Robustify.\n\t(ggc_recalculate_in_use_p): New function.\n\t(release_pages): Don't inline it.\n\t(ggc_alloc_obj): Don't refuse to allocate objects on pages for\n\touter contexts.\n\t(ggc_pop_context): Use ggc_recalculate_in_use_p.\n\t(clear_marks): Always save in_use_p.\n\t(sweep_pages): Use ggc_recalculate_in_use_p.\n\t(ggc_page_print_statistics): Avoid signed/unsigned comparisons.\n\tRelease pages before counting statistics.\n\nFrom-SVN: r30314", "tree": {"sha": "1baa221a228a41e439858be1e5c13d28376c65b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1baa221a228a41e439858be1e5c13d28376c65b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4934cc537b68343ba318335725b26567a767ecca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4934cc537b68343ba318335725b26567a767ecca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4934cc537b68343ba318335725b26567a767ecca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4934cc537b68343ba318335725b26567a767ecca/comments", "author": null, "committer": null, "parents": [{"sha": "3e038608acd6e57ae2a13088b5e1f25d2b23d926", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e038608acd6e57ae2a13088b5e1f25d2b23d926", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e038608acd6e57ae2a13088b5e1f25d2b23d926"}], "stats": {"total": 96, "additions": 73, "deletions": 23}, "files": [{"sha": "664fb4340dcc0d51c27f9502682ce2e6fc2adbd0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4934cc537b68343ba318335725b26567a767ecca/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4934cc537b68343ba318335725b26567a767ecca/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4934cc537b68343ba318335725b26567a767ecca", "patch": "@@ -1,3 +1,17 @@\n+Sun Oct 31 23:57:07 1999  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* ggc-page.c (struct page_entry): Remove save_num_free_objects.\n+\t(DIV_ROUND_UP): Robustify.\n+\t(ggc_recalculate_in_use_p): New function.\n+\t(release_pages): Don't inline it.\n+\t(ggc_alloc_obj): Don't refuse to allocate objects on pages for\n+\touter contexts.\n+\t(ggc_pop_context): Use ggc_recalculate_in_use_p.\n+\t(clear_marks): Always save in_use_p.\n+\t(sweep_pages): Use ggc_recalculate_in_use_p.\n+\t(ggc_page_print_statistics): Avoid signed/unsigned comparisons.\n+\tRelease pages before counting statistics.\n+\t\n Sun Oct 31 23:42:37 1999  Mark Mitchell  <mark@codesourcery.com>\n \n \t* toplev.c (rest_of_compilation): Fix thinko in this change:"}, {"sha": "2497f55f069d2609f087e06f65289d8fe1001700", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 59, "deletions": 23, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4934cc537b68343ba318335725b26567a767ecca/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4934cc537b68343ba318335725b26567a767ecca/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=4934cc537b68343ba318335725b26567a767ecca", "patch": "@@ -169,10 +169,6 @@ typedef struct page_entry\n      next allocation from this page.  */\n   unsigned short next_bit_hint;\n \n-  /* Saved number of free objects for pages that aren't in the topmost\n-     context during colleciton.  */\n-  unsigned short save_num_free_objects;\n-\n   /* A bit vector indicating whether or not objects are in use.  The\n      Nth bit is one if the Nth object on this page is allocated.  This\n      array is dynamically sized.  */\n@@ -247,7 +243,7 @@ static struct globals\n \n /* Compute DIVIDEND / DIVISOR, rounded up.  */\n #define DIV_ROUND_UP(Dividend, Divisor) \\\n-  ((Dividend + Divisor - 1) / Divisor)\n+  (((Dividend) + (Divisor) - 1) / (Divisor))\n \n /* The number of objects per allocation page, for objects of size\n    2^ORDER.  */\n@@ -279,6 +275,7 @@ static void free_page PROTO ((struct page_entry *));\n static void release_pages PROTO ((void));\n static void clear_marks PROTO ((void));\n static void sweep_pages PROTO ((void));\n+static void ggc_recalculate_in_use_p PROTO ((page_entry *));\n \n #ifdef GGC_POISON\n static void poison_pages PROTO ((void));\n@@ -533,7 +530,7 @@ free_page (entry)\n \n /* Release the free page cache to the system.  */\n \n-static inline void\n+static void\n release_pages ()\n {\n #ifdef HAVE_MMAP\n@@ -638,9 +635,7 @@ ggc_alloc_obj (size, zero)\n \n   /* If there is no page for this object size, or all pages in this\n      context are full, allocate a new page.  */\n-  if (entry == NULL \n-      || entry->num_free_objects == 0 \n-      || entry->context_depth != G.context_depth)\n+  if (entry == NULL || entry->num_free_objects == 0)\n     {\n       struct page_entry *new_entry;\n       new_entry = alloc_page (order);\n@@ -850,6 +845,44 @@ ggc_push_context ()\n     abort ();\n }\n \n+/* Merge the SAVE_IN_USE_P and IN_USE_P arrays in P so that IN_USE_P\n+   reflects reality.  Recalculate NUM_FREE_OBJECTS as well.  */\n+\n+static void\n+ggc_recalculate_in_use_p (p)\n+     page_entry *p;\n+{\n+  unsigned int i;\n+  size_t num_objects;\n+\n+  /* Because the past-the-end bit in in_use_p is always set, we \n+     pretend there is one additional object.  */\n+  num_objects = OBJECTS_PER_PAGE (p->order) + 1;\n+\n+  /* Reset the free object count.  */\n+  p->num_free_objects = num_objects;\n+\n+  /* Combine the IN_USE_P and SAVE_IN_USE_P arrays.  */\n+  for (i = 0; \n+       i < DIV_ROUND_UP (BITMAP_SIZE (num_objects),\n+\t\t\t sizeof (*p->in_use_p));\n+       ++i)\n+    {\n+      unsigned long j;\n+\n+      /* Something is in use if it is marked, or if it was in use in a\n+\t context further down the context stack.  */\n+      p->in_use_p[i] |= p->save_in_use_p[i];\n+\n+      /* Decrement the free object count for every object allocated.  */\n+      for (j = p->in_use_p[i]; j; j >>= 1)\n+\tp->num_free_objects -= (j & 1);\n+    }\n+\n+  if (p->num_free_objects >= num_objects)\n+    abort ();\n+}\n+\n /* Decrement the `GC context'.  All objects allocated since the \n    previous ggc_push_context are migrated to the outer context.  */\n \n@@ -865,26 +898,20 @@ ggc_pop_context ()\n      left over are imported into the previous context.  */\n   for (order = 2; order < HOST_BITS_PER_PTR; order++)\n     {\n-      size_t num_objects = OBJECTS_PER_PAGE (order);\n-      size_t bitmap_size = BITMAP_SIZE (num_objects);\n-\n       page_entry *p;\n \n       for (p = G.pages[order]; p != NULL; p = p->next)\n \t{\n \t  if (p->context_depth > depth)\n-\t    {\n-\t      p->context_depth = depth;\n-\t    }\n+\t    p->context_depth = depth;\n \n \t  /* If this page is now in the topmost context, and we'd\n \t     saved its allocation state, restore it.  */\n \t  else if (p->context_depth == depth && p->save_in_use_p)\n \t    {\n-\t      memcpy (p->in_use_p, p->save_in_use_p, bitmap_size);\n+\t      ggc_recalculate_in_use_p (p);\n \t      free (p->save_in_use_p);\n \t      p->save_in_use_p = 0;\n-\t      p->num_free_objects = p->save_num_free_objects;\n \t    }\n \t}\n     }\n@@ -900,7 +927,7 @@ clear_marks ()\n   for (order = 2; order < HOST_BITS_PER_PTR; order++)\n     {\n       size_t num_objects = OBJECTS_PER_PAGE (order);\n-      size_t bitmap_size = BITMAP_SIZE (num_objects);\n+      size_t bitmap_size = BITMAP_SIZE (num_objects + 1);\n       page_entry *p;\n \n       for (p = G.pages[order]; p != NULL; p = p->next)\n@@ -914,12 +941,11 @@ clear_marks ()\n \t  /* Pages that aren't in the topmost context are not collected;\n \t     nevertheless, we need their in-use bit vectors to store GC\n \t     marks.  So, back them up first.  */\n-\t  if (p->context_depth < G.context_depth\n-\t      && ! p->save_in_use_p)\n+\t  if (p->context_depth < G.context_depth)\n \t    {\n-\t      p->save_in_use_p = xmalloc (bitmap_size);\n+\t      if (! p->save_in_use_p)\n+\t\tp->save_in_use_p = xmalloc (bitmap_size);\n \t      memcpy (p->save_in_use_p, p->in_use_p, bitmap_size);\n-\t      p->save_num_free_objects = p->num_free_objects;\n \t    }\n \n \t  /* Reset reset the number of free objects and clear the\n@@ -1025,6 +1051,12 @@ sweep_pages ()\n \t  p = next;\n \t} \n       while (! done);\n+\n+      /* Now, restore the in_use_p vectors for any pages from contexts\n+         other than the current one.  */\n+      for (p = G.pages[order]; p; p = p->next)\n+\tif (p->context_depth != G.context_depth)\n+\t  ggc_recalculate_in_use_p (p);\n     }\n }\n \n@@ -1122,7 +1154,7 @@ void\n ggc_page_print_statistics ()\n {\n   struct ggc_statistics stats;\n-  int i;\n+  unsigned int i;\n \n   /* Clear the statistics.  */\n   bzero (&stats, sizeof (stats));\n@@ -1133,6 +1165,10 @@ ggc_page_print_statistics ()\n   /* Collect and print the statistics common across collectors.  */\n   ggc_print_statistics (stderr, &stats);\n \n+  /* Release free pages so that we will not count the bytes allocated\n+     there as part of the total allocated memory.  */\n+  release_pages ();\n+\n   /* Collect some information about the various sizes of \n      allocation.  */\n   fprintf (stderr, \"\\n%-4s%-16s%-16s\\n\", \"Log\", \"Allocated\", \"Used\");"}]}