{"sha": "db8697336fbb1f6665adbfa24a72a4dbbd549398", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGI4Njk3MzM2ZmJiMWY2NjY1YWRiZmEyNGE3MmE0ZGJiZDU0OTM5OA==", "commit": {"author": {"name": "Paul Woegerer", "email": "paul.woegerer@nsc.com", "date": "2005-07-22T09:49:48Z"}, "committer": {"name": "Paul Woegerer", "email": "woepaul@gcc.gnu.org", "date": "2005-07-22T09:49:48Z"}, "message": "config.gcc: Add crx-elf support.\n\n        * config.gcc: Add crx-elf support.\n\n        * doc/contrib.texi: Mention crx.\n        * doc/extend.texi: Document crx extensions.\n        * doc/install.texi: Document crx install.\n        * doc/invoke.texi: Document crx options.\n        * doc/md.texi: Document crx constraints.\n\n        * config/crx/crx-protos.h: New file.\n        * config/crx/crx.c: New file.\n        * config/crx/crx.h: New file.\n        * config/crx/crx.md: New file.\n        * config/crx/crx.opt: New file.\n        * config/crx/t-crx: New file.\n\nFrom-SVN: r102278", "tree": {"sha": "a33f7560f0dde97a44c7a0bdcb0fa5fd23a44569", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a33f7560f0dde97a44c7a0bdcb0fa5fd23a44569"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db8697336fbb1f6665adbfa24a72a4dbbd549398", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db8697336fbb1f6665adbfa24a72a4dbbd549398", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db8697336fbb1f6665adbfa24a72a4dbbd549398", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db8697336fbb1f6665adbfa24a72a4dbbd549398/comments", "author": null, "committer": null, "parents": [{"sha": "0fb6f88ac7ab49796b45268f6df19371bfa96416", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fb6f88ac7ab49796b45268f6df19371bfa96416", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fb6f88ac7ab49796b45268f6df19371bfa96416"}], "stats": {"total": 3082, "additions": 3082, "deletions": 0}, "files": [{"sha": "94fa4b2b85e23debde12762e96741770485cec1b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db8697336fbb1f6665adbfa24a72a4dbbd549398/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db8697336fbb1f6665adbfa24a72a4dbbd549398/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=db8697336fbb1f6665adbfa24a72a4dbbd549398", "patch": "@@ -1,3 +1,20 @@\n+2005-07-22  Paul Woegerer  <paul.woegerer@nsc.com>\n+\n+\t* config.gcc: Add crx-elf support.\n+\n+\t* doc/contrib.texi: Mention crx.\n+\t* doc/extend.texi: Document crx extensions.\n+\t* doc/install.texi: Document crx install.\n+\t* doc/invoke.texi: Document crx options.\n+\t* doc/md.texi: Document crx constraints.\n+\n+\t* config/crx/crx-protos.h: New file.\n+\t* config/crx/crx.c: New file.\n+\t* config/crx/crx.h: New file.\n+\t* config/crx/crx.md: New file.\n+\t* config/crx/crx.opt: New file.\n+\t* config/crx/t-crx: New file.\n+\t\n 2005-07-22  Manfred Hollstein  <mh@suse.com>\n \n \t* tree-ssa-structalias.c (merge_graph_nodes): Fix uninitialised"}, {"sha": "0361c35459b28fc8c4f6806d5d632e12c3379074", "filename": "gcc/config.gcc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db8697336fbb1f6665adbfa24a72a4dbbd549398/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db8697336fbb1f6665adbfa24a72a4dbbd549398/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=db8697336fbb1f6665adbfa24a72a4dbbd549398", "patch": "@@ -779,6 +779,11 @@ cris-*-linux*)\n \ttmake_file=\"cris/t-cris t-slibgcc-elf-ver cris/t-linux\"\n \textra_options=\"${extra_options} cris/linux.opt\"\n \t;;\n+crx-*-elf)\n+\ttm_file=\"elfos.h ${tm_file}\"\n+\textra_parts=\"crtbegin.o crtend.o\"\n+\tuse_collect2=no\n+\t;;\n fr30-*-elf)\n \ttm_file=\"dbxelf.h elfos.h svr4.h ${tm_file}\"\n \ttmake_file=fr30/t-fr30"}, {"sha": "ebee79bd927572b66a4e28848a2ee0e1a33fda1f", "filename": "gcc/config/crx/crx-protos.h", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db8697336fbb1f6665adbfa24a72a4dbbd549398/gcc%2Fconfig%2Fcrx%2Fcrx-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db8697336fbb1f6665adbfa24a72a4dbbd549398/gcc%2Fconfig%2Fcrx%2Fcrx-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcrx%2Fcrx-protos.h?ref=db8697336fbb1f6665adbfa24a72a4dbbd549398", "patch": "@@ -0,0 +1,75 @@\n+/* Prototypes for exported functions defined in crx.c\n+   Copyright (C) 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,\n+   2002, 2003, 2004  Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+#ifndef GCC_CRX_PROTOS_H\n+#define GCC_CRX_PROTOS_H\n+\n+\n+/* Register usage. */\n+extern enum reg_class crx_regno_reg_class (int);\n+extern int crx_hard_regno_mode_ok (int regno, enum machine_mode);\n+#ifdef RTX_CODE\n+extern enum reg_class crx_secondary_reload_class (enum reg_class, enum machine_mode, rtx);\n+#endif /* RTX_CODE */\n+\n+/* Passing function arguments.  */\n+extern int crx_function_arg_regno_p (int);\n+#ifdef TREE_CODE\n+extern void crx_function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode, tree, int);\n+#ifdef RTX_CODE\n+extern void crx_init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx);\n+extern rtx crx_function_arg (struct cumulative_args *, enum machine_mode, tree, int);\n+#endif /* RTX_CODE */\n+#endif /* TREE_CODE */\n+\n+#ifdef RTX_CODE\n+/* Addressing Modes.  */\n+extern int crx_legitimate_address_p (enum machine_mode, rtx, int);\n+\n+extern int crx_const_double_ok (rtx op);\n+\n+/* Instruction output.  */\n+extern void crx_print_operand (FILE *, rtx, int);\n+extern void crx_print_operand_address (FILE *, rtx);\n+\n+/* Misc functions called from crx.md.  */\n+extern rtx crx_expand_compare (enum rtx_code, enum machine_mode);\n+extern void crx_expand_branch (enum rtx_code, rtx);\n+extern void crx_expand_scond (enum rtx_code, rtx);\n+\n+extern void crx_expand_movmem_single (rtx, rtx, rtx, rtx, rtx, unsigned HOST_WIDE_INT *);\n+extern int crx_expand_movmem (rtx, rtx, rtx, rtx);\n+#endif /* RTX_CODE */\n+\n+/* Routines to compute costs.  */\n+extern int crx_memory_move_cost (enum machine_mode, enum reg_class, int);\n+\n+/* Prologue/Epilogue functions.  */\n+extern int crx_initial_elimination_offset (int, int);\n+extern char *crx_prepare_push_pop_string (int);\n+extern void crx_expand_prologue (void);\n+extern void crx_expand_epilogue (void);\n+\n+\n+/* Handling the \"interrupt\" attribute */\n+extern int crx_interrupt_function_p (void);\n+\n+#endif /* GCC_CRX_PROTOS_H */"}, {"sha": "28d88ff159049dde28635a8a1d55dc194d7d776a", "filename": "gcc/config/crx/crx.c", "status": "added", "additions": 1485, "deletions": 0, "changes": 1485, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db8697336fbb1f6665adbfa24a72a4dbbd549398/gcc%2Fconfig%2Fcrx%2Fcrx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db8697336fbb1f6665adbfa24a72a4dbbd549398/gcc%2Fconfig%2Fcrx%2Fcrx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcrx%2Fcrx.c?ref=db8697336fbb1f6665adbfa24a72a4dbbd549398", "patch": "@@ -0,0 +1,1485 @@\n+/* Output routines for GCC for CRX.\n+   Copyright (C) 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,\n+   2002, 2003, 2004  Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+/*****************************************************************************/\n+/* HEADER INCLUDES\t\t\t\t\t\t\t     */\n+/*****************************************************************************/\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"tree.h\"\n+#include \"tm_p.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"output.h\"\n+#include \"insn-codes.h\"\n+#include \"insn-attr.h\"\n+#include \"flags.h\"\n+#include \"except.h\"\n+#include \"function.h\"\n+#include \"recog.h\"\n+#include \"expr.h\"\n+#include \"optabs.h\"\n+#include \"toplev.h\"\n+#include \"basic-block.h\"\n+#include \"target.h\"\n+#include \"target-def.h\"\n+\n+/*****************************************************************************/\n+/* DEFINITIONS\t\t\t\t\t\t\t\t     */\n+/*****************************************************************************/\n+\n+/* Maximum number of register used for passing parameters.  */\n+#define MAX_REG_FOR_PASSING_ARGS 5\n+\n+/* Minimum number register used for passing parameters.  */\n+#define MIN_REG_FOR_PASSING_ARGS 2\n+\n+/* The maximum count of words supported in the assembly of the architecture in\n+ * a push/pop instruction.  */\n+#define MAX_COUNT\t\t8\n+\n+/* Predicate is true if the current function is a 'noreturn' function, i.e. it\n+ * is qualified as volatile.  */\n+#define FUNC_IS_NORETURN_P(decl)  (TREE_THIS_VOLATILE (decl))\n+\n+/* The following 3 macros are used in crx_legitimate_address_p() */\n+\n+/* Returns 1 if the scale factor of an index address is valid.  */\n+#define SCALE_FOR_INDEX_P(X)\t\t\t\t\t\\\n+  (GET_CODE (X) == CONST_INT\t\t\t\t\t\\\n+   && (INTVAL (X) == 1 || INTVAL (X) == 2\t\t\t\\\n+       || INTVAL(X) == 4 || INTVAL (X) == 8))\n+\n+/* Nonzero if the rtx X is a signed const int of n bits */\n+#define RTX_SIGNED_INT_FITS_N_BITS(X,n)\t\t\t\\\n+  ((GET_CODE(X) == CONST_INT\t\t\t\t\\\n+    && SIGNED_INT_FITS_N_BITS(INTVAL(X),n)) ? 1 : 0)\n+\n+/* Nonzero if the rtx X is a unsigned const int of n bits */\n+#define RTX_UNSIGNED_INT_FITS_N_BITS(X,n)\t\t\\\n+  ((GET_CODE(X) == CONST_INT\t\t\t\t\\\n+    && UNSIGNED_INT_FITS_N_BITS(INTVAL(X),n)) ? 1 : 0)\n+\n+\n+/* Register relative legal displacement */\n+#define CRX_REGISTER_RELATIVE_DISP_P(X)\t\t\t\t\\\n+ (CONSTANT_ADDRESS_P(X)\t\t\t\t\t\t\\\n+  && (GET_CODE (X) != CONST_INT\t\t\t\t\t\\\n+      || RTX_SIGNED_INT_FITS_N_BITS(X, GET_MODE_BITSIZE (Pmode))))\n+\n+/*****************************************************************************/\n+/* STATIC VARIABLES\t\t\t\t\t\t\t     */\n+/*****************************************************************************/\n+\n+/* Non-zero if the last param processed is passed in a register.  */\n+static int last_parm_in_reg;\n+\n+/* Will hold the number of the last register the prologue saves, -1 if no\n+ * register is saved. */\n+static int last_reg_to_save;\n+\n+/* Each object in the array is a register number. Mark 1 for registers that\n+ * need to be saved.  */\n+static int save_regs[FIRST_PSEUDO_REGISTER];\n+\n+/* Number of bytes saved on the stack for non-scratch registers */\n+static int sum_regs = 0;\n+\n+/* Number of bytes saved on the stack for local variables. */\n+static int local_vars_size;\n+\n+/* The sum of 2 sizes: locals vars and padding byte for saving the registers.\n+ * Used in expand_prologue() and expand_epilogue().  */\n+static int size_for_adjusting_sp;\n+\n+/* In case of a POST_INC or POST_DEC memory reference, we must report the mode\n+ * of the memory reference from PRINT_OPERAND to PRINT_OPERAND_ADDRESS. */\n+static enum machine_mode output_memory_reference_mode;\n+\n+/*****************************************************************************/\n+/* GLOBAL VARIABLES\t\t\t\t\t\t\t     */\n+/*****************************************************************************/\n+\n+/* Table of machine attributes.  */\n+const struct attribute_spec crx_attribute_table[];\n+\n+/* Test and compare insns use these globals to generate branch insns.  */\n+rtx crx_compare_op0 = NULL_RTX;\n+rtx crx_compare_op1 = NULL_RTX;\n+\n+/*****************************************************************************/\n+/* TARGETM FUNCTION PROTOTYPES\t\t\t\t\t\t     */\n+/*****************************************************************************/\n+\n+static bool crx_fixed_condition_code_regs (unsigned int *, unsigned int *);\n+static rtx crx_struct_value_rtx (tree fntype ATTRIBUTE_UNUSED,\n+\t\t\t\t int incoming ATTRIBUTE_UNUSED);\n+static bool crx_return_in_memory (tree type, tree fntype ATTRIBUTE_UNUSED);\n+\n+/*****************************************************************************/\n+/* STACK LAYOUT AND CALLING CONVENTIONS\t\t\t\t\t     */\n+/*****************************************************************************/\n+\n+#undef\tTARGET_FIXED_CONDITION_CODE_REGS\n+#define\tTARGET_FIXED_CONDITION_CODE_REGS crx_fixed_condition_code_regs\n+\n+#undef\tTARGET_STRUCT_VALUE_RTX\n+#define\tTARGET_STRUCT_VALUE_RTX\t\tcrx_struct_value_rtx\n+\n+#undef\tTARGET_RETURN_IN_MEMORY\n+#define\tTARGET_RETURN_IN_MEMORY\t\tcrx_return_in_memory\n+\n+/*****************************************************************************/\n+/* TARGET-SPECIFIC USES OF `__attribute__'\t\t\t\t     */\n+/*****************************************************************************/\n+\n+#undef  TARGET_ATTRIBUTE_TABLE\n+#define TARGET_ATTRIBUTE_TABLE\t\tcrx_attribute_table\n+\n+const struct attribute_spec crx_attribute_table[] = {\n+  /* ISRs have special prologue and epilogue requirements. */\n+  {\"interrupt\", 0, 0, false, true, true, NULL},\n+  {NULL, 0, 0, false, false, false, NULL}\n+};\n+\n+\n+/* Initialize 'targetm' variable which contains pointers to functions and data\n+ * relating to the target machine.  */\n+\n+struct gcc_target targetm = TARGET_INITIALIZER;\n+\n+\n+/*****************************************************************************/\n+/* TARGET HOOK IMPLEMENTATIONS\t\t\t\t\t\t     */\n+/*****************************************************************************/\n+\n+/* Return the fixed registers used for condition codes.  */\n+\n+static bool\n+crx_fixed_condition_code_regs (unsigned int *p1, unsigned int *p2)\n+{\n+    *p1 = CC_REGNUM;\n+    *p2 = INVALID_REGNUM;\n+    return true;\n+}\n+\n+/* Implements hook TARGET_STRUCT_VALUE_RTX.  */\n+\n+static rtx\n+crx_struct_value_rtx (tree fntype ATTRIBUTE_UNUSED,\n+\t\t      int incoming ATTRIBUTE_UNUSED)\n+{\n+  return gen_rtx_REG (Pmode, CRX_STRUCT_VALUE_REGNUM);\n+}\n+\n+/* Implements hook TARGET_RETURN_IN_MEMORY.  */\n+\n+static bool\n+crx_return_in_memory (tree type, tree fntype ATTRIBUTE_UNUSED)\n+{\n+  if (TYPE_MODE (type) == BLKmode)\n+    {\n+      HOST_WIDE_INT size = int_size_in_bytes (type);\n+      return (size == -1 || size > 8);\n+    }\n+  else\n+    return false;\n+}\n+\n+\n+/*****************************************************************************/\n+/* MACRO IMPLEMENTATIONS\t\t\t\t\t\t     */\n+/*****************************************************************************/\n+\n+/* STACK LAYOUT AND CALLING CONVENTIONS ROUTINES */\n+/* --------------------------------------------- */\n+\n+/* Return nonzero if the current function being compiled is an interrupt\n+ * function as specified by the \"interrupt\" attribute.  */\n+\n+int\n+crx_interrupt_function_p (void)\n+{\n+  tree attributes;\n+\n+  attributes = TYPE_ATTRIBUTES (TREE_TYPE (current_function_decl));\n+  return lookup_attribute (\"interrupt\", attributes) != NULL_TREE;\n+}\n+\n+/* Compute values for the array save_regs and the variable sum_regs.  The index\n+ * of save_regs is numbers of register, each will get 1 if we need to save it\n+ * in the current function, 0 if not. sum_regs is the total sum of the\n+ * registers being saved. */\n+\n+static void\n+crx_compute_save_regs (void)\n+{\n+  unsigned int regno;\n+\n+  /* initialize here so in case the function is no-return it will be -1. */\n+  last_reg_to_save = -1;\n+\n+  /* No need to save any registers if the function never returns.  */\n+  if (FUNC_IS_NORETURN_P (current_function_decl))\n+    return;\n+\n+  /* Initialize the number of bytes to be saved. */\n+  sum_regs = 0;\n+\n+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    {\n+      if (fixed_regs[regno])\n+\t{\n+\t  save_regs[regno] = 0;\n+\t  continue;\n+\t}\n+\n+      /* If this reg is used and not call-used (except RA), save it. */\n+      if (crx_interrupt_function_p())\n+\t{\n+\t  if (!current_function_is_leaf && call_used_regs[regno])\n+\t    /* this is a volatile reg in a non-leaf interrupt routine - save it\n+\t     * for the sake of its sons.  */\n+\t    save_regs[regno] = 1;\n+\n+\t  else if (regs_ever_live[regno])\n+\t    /* This reg is used - save it.  */\n+\t    save_regs[regno] = 1;\n+\t  else\n+\t    /* This reg is not used, and is not a volatile - don't save. */\n+      \t    save_regs[regno] = 0;\n+\t}\n+      else\n+\t{\n+\t  /* If this reg is used and not call-used (except RA), save it. */\n+\t  if (regs_ever_live[regno]\n+\t      && (!call_used_regs[regno] || regno == RETURN_ADDRESS_REGNUM))\n+\t    save_regs[regno] = 1;\n+\t  else\n+\t    save_regs[regno] = 0;\n+\t}\n+    }\n+\n+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    if (save_regs[regno] == 1)\n+      {\n+\tlast_reg_to_save = regno;\n+\tsum_regs += UNITS_PER_WORD;\n+      }\n+}\n+\n+/* Compute the size of the local area and the size to be adjusted by the\n+ * prologue and epilogue. */\n+\n+static void\n+crx_compute_frame (void)\n+{\n+  /* For aligning the local variables. */\n+  int stack_alignment = STACK_BOUNDARY / BITS_PER_UNIT;\n+  int padding_locals;\n+\n+  /* Padding needed for each element of the frame.  */\n+  local_vars_size = get_frame_size ();\n+\n+  /* Align to the stack alignment. */\n+  padding_locals = local_vars_size % stack_alignment;\n+  if (padding_locals)\n+    padding_locals = stack_alignment - padding_locals;\n+\n+  local_vars_size += padding_locals;\n+\n+  size_for_adjusting_sp = local_vars_size + (ACCUMULATE_OUTGOING_ARGS ?\n+\t\t\t\t     current_function_outgoing_args_size : 0);\n+}\n+\n+/* Implements the macro INITIAL_ELIMINATION_OFFSET, return the OFFSET. */\n+\n+int\n+crx_initial_elimination_offset (int from, int to)\n+{\n+  /* Compute this since we need to use sum_regs.  */\n+  crx_compute_save_regs ();\n+\n+  /* Compute this since we need to use local_vars_size.  */\n+  crx_compute_frame ();\n+\n+  if ((from) == FRAME_POINTER_REGNUM && (to) == STACK_POINTER_REGNUM)\n+    return (ACCUMULATE_OUTGOING_ARGS ?\n+\t    current_function_outgoing_args_size : 0);\n+  else if ((from) == ARG_POINTER_REGNUM && (to) == FRAME_POINTER_REGNUM)\n+    return (sum_regs + local_vars_size);\n+  else if ((from) == ARG_POINTER_REGNUM && (to) == STACK_POINTER_REGNUM)\n+    return (sum_regs + local_vars_size +\n+\t    (ACCUMULATE_OUTGOING_ARGS ?\n+\t     current_function_outgoing_args_size : 0));\n+  else\n+    abort ();\n+}\n+\n+/* REGISTER USAGE */\n+/* -------------- */\n+\n+/* Return the class number of the smallest class containing reg number REGNO.\n+ * This could be a conditional expression or could index an array. */\n+\n+enum reg_class\n+crx_regno_reg_class (int regno)\n+{\n+  if (regno >= 0 && regno < SP_REGNUM)\n+    return NOSP_REGS;\n+\n+  if (regno == SP_REGNUM) return GENERAL_REGS;\n+\n+  if (regno == LO_REGNUM) return LO_REGS;\n+  if (regno == HI_REGNUM) return HI_REGS;\n+\n+  return NO_REGS;\n+}\n+\n+/* Transfer between HILO_REGS and memory via secondary reloading. */\n+\n+enum reg_class\n+crx_secondary_reload_class (enum reg_class class,\n+\t\t\t    enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t    rtx x ATTRIBUTE_UNUSED)\n+{\n+  if (reg_classes_intersect_p (class, HILO_REGS)\n+      && true_regnum (x) == -1)\n+    return GENERAL_REGS;\n+\n+  return NO_REGS;\n+}\n+\n+/* Return 1 if hard register REGNO can hold a value of machine-mode MODE. */\n+\n+int\n+crx_hard_regno_mode_ok (int regno, enum machine_mode mode)\n+{\n+  /* CC can only hold CCmode values.  */\n+  if (regno == CC_REGNUM)\n+    return GET_MODE_CLASS (mode) == MODE_CC;\n+  if (GET_MODE_CLASS (mode) == MODE_CC)\n+    return 0;\n+  /* HILO registers can only hold SImode and DImode */\n+  if (HILO_REGNO_P (regno))\n+    return mode == SImode || mode == DImode;\n+  return 1;\n+}\n+\n+/* PASSING FUNCTION ARGUMENTS */\n+/* -------------------------- */\n+\n+/* If enough param regs are available for passing the param of type TYPE return\n+ * the number of registers needed else 0.  */\n+\n+static int\n+enough_regs_for_param (CUMULATIVE_ARGS * cum, tree type,\n+\t\t       enum machine_mode mode)\n+{\n+  int type_size;\n+  int remaining_size;\n+\n+  if (mode != BLKmode)\n+    type_size = GET_MODE_BITSIZE (mode);\n+  else\n+    type_size = int_size_in_bytes (type) * BITS_PER_UNIT;\n+\n+  remaining_size =\n+    BITS_PER_WORD * (MAX_REG_FOR_PASSING_ARGS -\n+    (MIN_REG_FOR_PASSING_ARGS + cum->ints) + 1);\n+\n+  /* Any variable which is too big to pass in two registers, will pass on\n+   * stack. */\n+  if ((remaining_size >= type_size) && (type_size <= 2 * BITS_PER_WORD))\n+    return (type_size + BITS_PER_WORD - 1) / BITS_PER_WORD;\n+\n+  return 0;\n+}\n+\n+/* Implements the macro FUNCTION_ARG defined in crx.h.  */\n+\n+rtx\n+crx_function_arg (CUMULATIVE_ARGS * cum, enum machine_mode mode, tree type,\n+\t      int named ATTRIBUTE_UNUSED)\n+{\n+  last_parm_in_reg = 0;\n+\n+  /* Function_arg() is called with this type just after all the args have had\n+   * their registers assigned. The rtx that function_arg returns from this type\n+   * is supposed to pass to 'gen_call' but currently it is not implemented (see\n+   * macro GEN_CALL).  */\n+  if (type == void_type_node)\n+    return NULL_RTX;\n+\n+  if (targetm.calls.must_pass_in_stack (mode, type) || (cum->ints < 0))\n+    return NULL_RTX;\n+\n+  if (mode == BLKmode)\n+    {\n+      /* Enable structures that need padding bytes at the end to pass to a\n+       * function in registers. */\n+      if (enough_regs_for_param (cum, type, mode) != 0)\n+\t{\n+\t  last_parm_in_reg = 1;\n+\t  return gen_rtx_REG (mode, MIN_REG_FOR_PASSING_ARGS + cum->ints);\n+\t}\n+    }\n+\n+  if (MIN_REG_FOR_PASSING_ARGS + cum->ints > MAX_REG_FOR_PASSING_ARGS)\n+    return NULL_RTX;\n+  else\n+    {\n+      if (enough_regs_for_param (cum, type, mode) != 0)\n+\t{\n+\t  last_parm_in_reg = 1;\n+\t  return gen_rtx_REG (mode, MIN_REG_FOR_PASSING_ARGS + cum->ints);\n+\t}\n+    }\n+\n+  return NULL_RTX;\n+}\n+\n+/* Implements the macro INIT_CUMULATIVE_ARGS defined in crx.h.  */\n+\n+void\n+crx_init_cumulative_args (CUMULATIVE_ARGS * cum, tree fntype,\n+\t\t      rtx libfunc ATTRIBUTE_UNUSED)\n+{\n+  tree param, next_param;\n+\n+  cum->ints = 0;\n+\n+  /* Determine if this function has variable arguments.  This is indicated by\n+   * the last argument being 'void_type_mode' if there are no variable\n+   * arguments.  Change here for a different vararg.  */\n+  for (param = (fntype) ? TYPE_ARG_TYPES (fntype) : 0;\n+       param != (tree) 0; param = next_param)\n+    {\n+      next_param = TREE_CHAIN (param);\n+      if (next_param == (tree) 0 && TREE_VALUE (param) != void_type_node)\n+\t{\n+\t  cum->ints = -1;\n+\t  return;\n+\t}\n+    }\n+}\n+\n+/* Implements the macro FUNCTION_ARG_ADVANCE defined in crx.h.  */\n+\n+void\n+crx_function_arg_advance (CUMULATIVE_ARGS * cum, enum machine_mode mode,\n+\t\t      tree type, int named ATTRIBUTE_UNUSED)\n+{\n+  /* l holds the number of registers required */\n+  int l = GET_MODE_BITSIZE (mode) / BITS_PER_WORD;\n+\n+  /* If the parameter isn't passed on a register don't advance cum.  */\n+  if (!last_parm_in_reg)\n+    return;\n+\n+  if (targetm.calls.must_pass_in_stack (mode, type) || (cum->ints < 0))\n+    return;\n+\n+  if (mode == SImode || mode == HImode || mode == QImode || mode == DImode)\n+    {\n+      if (l <= 1)\n+\tcum->ints += 1;\n+      else\n+\tcum->ints += l;\n+    }\n+  else if (mode == SFmode || mode == DFmode)\n+    cum->ints += l;\n+  else if ((mode) == BLKmode)\n+    {\n+      if ((l = enough_regs_for_param (cum, type, mode)) != 0)\n+\tcum->ints += l;\n+    }\n+\n+}\n+\n+/* Implements the macro FUNCTION_ARG_REGNO_P defined in crx.h.  Return non-zero\n+ * if N is a register used for passing parameters.  */\n+\n+int\n+crx_function_arg_regno_p (int n)\n+{\n+  return (n <= MAX_REG_FOR_PASSING_ARGS && n >= MIN_REG_FOR_PASSING_ARGS);\n+}\n+\n+/* ADDRESSING MODES */\n+/* ---------------- */\n+\n+/* Implements the macro GO_IF_LEGITIMATE_ADDRESS defined in crx.h.\n+ * The legitimate addressing modes for the CRX are:\n+ *\n+ * Relocations\t\t--> const | symbol_ref | label_ref\n+ * Absolute address\t--> 32 bit absolute\n+ * Post increment\t--> reg + 12 bit disp.\n+ * Post modify\t\t--> reg + 12 bit disp.\n+ * Register relative\t--> reg | 32 bit disp. + reg | 4 bit + reg\n+ * Scaled index\t\t--> reg + reg | 22 bit disp. + reg + reg |\n+ *\t\t\t    22 disp. + reg + reg + (2 | 4 | 8) */\n+\n+int\n+crx_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t  rtx x, int strict)\n+{\n+  /* Absolute address */\n+  if (RTX_UNSIGNED_INT_FITS_N_BITS(x, GET_MODE_BITSIZE(Pmode)))\n+    return 1;\n+\n+  /* Label */\n+  if (GET_CODE (x) == CONST\n+      || GET_CODE (x) == SYMBOL_REF\n+      || GET_CODE (x) == LABEL_REF\n+      || (GET_CODE (x) == REG && (strict ? STRICT_REG_OK_FOR_BASE_P (x)\n+\t\t\t\t  : NONSTRICT_REG_OK_FOR_BASE_P (x))))\n+    return 1;\n+\n+  /* Post increment - The first argument is a register and the second is\n+   * 12-bit long int. */\n+  if (GET_CODE (x) == POST_INC || GET_CODE (x) == POST_DEC)\n+    {\n+      /* Don't allow modes to be referenced through post autoinc/dec that\n+       * cannot be loaded/stored with a single instruction */\n+      if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n+\treturn 0;\n+\n+      if((GET_CODE (XEXP (x, 0)) == REG)\n+\t && (strict ? STRICT_REG_OK_FOR_BASE_P (XEXP (x, 0))\n+\t     : NONSTRICT_REG_OK_FOR_BASE_P (XEXP (x, 0))))\n+\treturn 1;\n+    }\n+\n+  /* Post modify */\n+  if (GET_CODE (x) == POST_MODIFY)\n+    {\n+      /* Don't allow modes to be referenced through post autoinc/dec that\n+       * cannot be loaded/stored with a single instruction */\n+      if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n+\treturn 0;\n+\n+      if (!(GET_CODE (XEXP (x, 0)) == REG\n+\t  && (strict ? STRICT_REG_OK_FOR_BASE_P (XEXP (x, 0))\n+\t      : NONSTRICT_REG_OK_FOR_BASE_P (XEXP (x, 0)))\n+\t  && RTX_SIGNED_INT_FITS_N_BITS(XEXP (XEXP (x, 1), 1), 12)))\n+\treturn 0;\n+\n+      if(!(GET_CODE (XEXP (x, 1)) == PLUS || GET_CODE (XEXP (x, 1)) == MINUS))\n+\treturn 0;\n+\n+      if(!rtx_equal_p(XEXP (x, 0), XEXP (XEXP (x, 1), 0)))\n+\treturn 0;\n+\n+      return 1;\n+    }\n+\n+  if (GET_CODE (x) == PLUS)\n+    {\n+      /* Register relative */\n+      if (GET_CODE (XEXP (x, 0)) == REG\n+\t  && (strict ? STRICT_REG_OK_FOR_BASE_P (XEXP (x, 0))\n+\t      : NONSTRICT_REG_OK_FOR_BASE_P (XEXP (x, 0)))\n+\t  && (CRX_REGISTER_RELATIVE_DISP_P (XEXP (x, 1))))\n+\treturn 1;\n+\n+      /* Scaled index with factor 1 */\n+      /* 1a. reg + reg */\n+      if (GET_CODE (XEXP (x, 0)) == REG\n+\t  && (strict ? STRICT_REG_OK_FOR_BASE_P (XEXP (x, 0))\n+\t      : REG_OK_FOR_INDEX_P (XEXP (x, 0)))\n+\t  && GET_CODE (XEXP (x, 1)) == REG\n+\t  && (strict ? STRICT_REG_OK_FOR_BASE_P (XEXP (x, 1))\n+\t      : REG_OK_FOR_INDEXED_BASE_P (XEXP (x, 1))))\n+\treturn 1;\n+\n+      /* Scaled index with different factor */\n+      /* 1b. reg * scale + reg */\n+      if (GET_CODE (XEXP (x, 0)) == MULT\n+\t  && GET_CODE (XEXP( XEXP (x, 0), 0)) == REG\n+\t  && (strict ? STRICT_REG_OK_FOR_INDEX_P (XEXP( XEXP (x, 0), 0))\n+\t      : NONSTRICT_REG_OK_FOR_INDEX_P (XEXP( XEXP (x, 0), 0)))\n+\t  && (SCALE_FOR_INDEX_P (XEXP( XEXP (x, 0), 1)))\n+\t  && GET_CODE (XEXP (x, 1)) == REG\n+\t  && (strict ? STRICT_REG_OK_FOR_BASE_P (XEXP (x, 1))\n+\t      : NONSTRICT_REG_OK_FOR_BASE_P (XEXP (x, 1))))\n+\treturn 1;\n+\n+      if (GET_CODE (XEXP (x, 0)) == PLUS)\n+\t{\n+\t  /* 2. reg + reg + 22 bit disp.  */\n+\t  if (GET_CODE (XEXP (XEXP (x, 0), 0)) == REG\n+\t      && (strict ? STRICT_REG_OK_FOR_BASE_P (XEXP (XEXP (x, 0), 0))\n+\t\t  : REG_OK_FOR_INDEX_P (XEXP (XEXP (x, 0), 0)))\n+\t      && GET_CODE (XEXP (XEXP (x, 0), 1)) == REG\n+\t      && (strict ? STRICT_REG_OK_FOR_BASE_P (XEXP (XEXP (x, 0), 1))\n+\t\t  : REG_OK_FOR_INDEXED_BASE_P (XEXP (XEXP (x, 0), 1)))\n+\t      && (RTX_SIGNED_INT_FITS_N_BITS(XEXP (x, 1), 22)))\n+\t    return 1;\n+\n+\t  /* 3. reg * scale + reg + 22 bit disp. */\n+\t  if ((GET_CODE (XEXP (XEXP (x, 0), 0)) == MULT)\n+\t      && (GET_CODE (XEXP (XEXP (XEXP (x, 0), 0), 0)) == REG)\n+\t      && (strict ?\n+\t\t  STRICT_REG_OK_FOR_BASE_P (XEXP (XEXP (XEXP (x, 0), 0), 0))\n+\t\t  :\n+\t\t  REG_OK_FOR_INDEXED_BASE_P (XEXP (XEXP (XEXP (x, 0), 0), 0)))\n+\t      && (SCALE_FOR_INDEX_P (XEXP (XEXP (XEXP (x, 0), 0), 1)))\n+\t      && (GET_CODE (XEXP (XEXP (x, 0), 1)) == REG)\n+\t      && (strict ? STRICT_REG_OK_FOR_BASE_P (XEXP (XEXP (x, 0), 1)) :\n+\t\t  REG_OK_FOR_INDEX_P (XEXP (XEXP (x, 0), 1)))\n+\t      && (RTX_SIGNED_INT_FITS_N_BITS(XEXP (x, 1), 22)))\n+\t    return 1;\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n+/* ROUTINES TO COMPUTE COSTS */\n+/* ------------------------- */\n+\n+/* Return the cost of moving data of mode MODE between a register of class\n+ * CLASS and memory; IN is zero if the value is to be written to memory,\n+ * non-zero if it is to be read in. This cost is relative to those in\n+ * REGISTER_MOVE_COST. */\n+\n+int\n+crx_memory_move_cost (enum machine_mode mode,\n+\t\t  enum reg_class class ATTRIBUTE_UNUSED,\n+\t\t  int in ATTRIBUTE_UNUSED)\n+{\n+  /* One LD or ST takes twice the time of a simple reg-reg move */\n+  if (reg_classes_intersect_p (class, GENERAL_REGS))\n+    {\n+      /* printf(\"GENERAL_REGS LD/ST = %d\\n\", 4 * HARD_REGNO_NREGS (0, mode));*/\n+      return 4 * HARD_REGNO_NREGS (0, mode);\n+    }\t\n+  else if (reg_classes_intersect_p (class, HILO_REGS))\n+    {\n+      /* HILO to memory and vice versa */\n+      /* printf(\"HILO_REGS %s = %d\\n\",in ? \"LD\" : \"ST\",\n+\t     (REGISTER_MOVE_COST(mode,\n+\t\t\t\t in ? GENERAL_REGS : HILO_REGS,\n+\t\t\t\t in ? HILO_REGS : GENERAL_REGS) + 4)\n+\t* HARD_REGNO_NREGS (0, mode)); */\n+      return (REGISTER_MOVE_COST(mode,\n+\t\t\t\t in ? GENERAL_REGS : HILO_REGS,\n+\t\t\t\t in ? HILO_REGS : GENERAL_REGS) + 4)\n+\t* HARD_REGNO_NREGS (0, mode);\n+    }\n+  else /* default (like in i386) */\n+    {\n+      /* printf(\"ANYREGS = 100\\n\"); */\n+      return 100;\n+    }\n+}\n+\n+/* INSTRUCTION OUTPUT */\n+/* ------------------ */\n+\n+/* Print to FILE addr expression of the form post_inc/dec (in this case\n+ * post_offset is zero) or post_inc/dec + post_offset */\n+\n+static void\n+print_post_operand_address (FILE * file, rtx addr, int post_offset)\n+{\n+  int displmnt;\n+\n+  if (GET_CODE (addr) == POST_MODIFY)\n+    {\n+      displmnt = INTVAL(XEXP( XEXP (addr, 1), 1));\n+      if (GET_CODE (XEXP (addr, 1)) == MINUS) displmnt = (-1) * displmnt;\n+    }\n+  else\n+    {\n+      displmnt = GET_MODE_SIZE (output_memory_reference_mode);\n+      /* Make the displacement negative for POST_DEC */\n+      if (GET_CODE (addr) == POST_DEC) displmnt = (-1) * displmnt;\n+    }\n+\n+  if (GET_CODE (XEXP (addr, 0)) != REG)\n+    abort ();\n+\n+  displmnt += post_offset;\n+\n+  fprintf (file, \"%d(%s)+\", displmnt, reg_names[REGNO (XEXP (addr, 0))]);\n+}\n+\n+/* Check if constant rtx contains label_ref.  */\n+\n+static rtx\n+const_and_contains_label_ref (rtx x)\n+{\n+  if (!x)\n+    return NULL_RTX;\n+\n+  if (GET_CODE (x) == LABEL_REF)\n+    return x;\n+\n+  /* Check within enclosing const.  */\n+  if (GET_CODE (x) == CONST)\n+    x = XEXP (x, 0);\n+\n+  if ((GET_CODE (x) == PLUS || GET_CODE (x) == MINUS)\n+      && GET_CODE (XEXP (x, 1)) == CONST_INT\n+      && GET_CODE (XEXP (x, 0)) == LABEL_REF)\n+    return XEXP (x, 0);\n+\n+  return NULL_RTX;\n+}\n+\n+/* Check if rtx contains symbol_ref. */\n+\n+static rtx\n+const_and_contains_symbol_ref (rtx x)\n+{\n+  if (!x)\n+    return NULL_RTX;\n+\n+  if (GET_CODE (x) == SYMBOL_REF)\n+    return x;\n+\n+  /* Check within enclosing const.  */\n+  if (GET_CODE (x) == CONST)\n+    x = XEXP (x, 0);\n+\n+  if ((GET_CODE (x) == PLUS || GET_CODE (x) == MINUS)\n+      && GET_CODE (XEXP (x, 1)) == CONST_INT\n+      && GET_CODE (XEXP (x, 0)) == SYMBOL_REF)\n+    return XEXP (x, 0);\n+\n+  return NULL_RTX;\n+}\n+\n+/* Check if a const_double is ok for crx store-immediate instructions */\n+\n+int\n+crx_const_double_ok (rtx op)\n+{\n+  if (GET_MODE (op) == DFmode)\n+  {\n+    REAL_VALUE_TYPE r;\n+    long l[2];\n+    REAL_VALUE_FROM_CONST_DOUBLE (r, op);\n+    REAL_VALUE_TO_TARGET_DOUBLE (r, l);\n+    return (UNSIGNED_INT_FITS_N_BITS(l[0], 4) &&\n+\t    UNSIGNED_INT_FITS_N_BITS(l[1], 4)) ? 1 : 0;\n+  }\n+\n+  if (GET_MODE (op) == SFmode)\n+  {\n+    REAL_VALUE_TYPE r;\n+    long l;\n+    REAL_VALUE_FROM_CONST_DOUBLE (r, op);\n+    REAL_VALUE_TO_TARGET_SINGLE (r, l);\n+    return UNSIGNED_INT_FITS_N_BITS(l, 4) ? 1 : 0;\n+  }\n+\n+  return (UNSIGNED_INT_FITS_N_BITS (CONST_DOUBLE_LOW (op), 4) &&\n+\t  UNSIGNED_INT_FITS_N_BITS (CONST_DOUBLE_HIGH (op), 4)) ? 1 : 0;\n+}\n+\n+/* Implements the macro PRINT_OPERAND defined in crx.h.  */\n+\n+void\n+crx_print_operand (FILE * file, rtx x, int code)\n+{\n+  switch (code)\n+    {\n+    case 'p' :\n+      if (GET_CODE (x) == REG) {\n+\tif (GET_MODE (x) == DImode || GET_MODE (x) == DFmode)\n+\t  {\n+\t    int regno = REGNO (x);\n+\t    if (regno + 1 >= SP_REGNUM) abort ();\n+\t    fprintf (file, \"{%s, %s}\", reg_names[regno], reg_names[regno + 1]);\n+\t    return;\n+\t  }\n+\telse\n+\t  {\n+\t    if (REGNO (x) >= SP_REGNUM) abort ();\n+\t    fprintf (file, \"%s\", reg_names[REGNO (x)]);\n+\t    return;\n+\t  }\n+      }\n+\n+    case 'd' :\n+\t{\n+\t  const char *crx_cmp_str;\n+\t  switch (GET_CODE (x))\n+\t    { /* MD: compare(reg, reg or imm) but CRX: cmp(reg or imm, reg)\n+\t       * -> swap all non symmetric ops */\n+\t    case EQ  : crx_cmp_str = \"eq\"; break;\n+\t    case NE  : crx_cmp_str = \"ne\"; break;\n+\t    case GT  : crx_cmp_str = \"lt\"; break;\n+\t    case GTU : crx_cmp_str = \"lo\"; break;\n+\t    case LT  : crx_cmp_str = \"gt\"; break;\n+\t    case LTU : crx_cmp_str = \"hi\"; break;\n+\t    case GE  : crx_cmp_str = \"le\"; break;\n+\t    case GEU : crx_cmp_str = \"ls\"; break;\n+\t    case LE  : crx_cmp_str = \"ge\"; break;\n+\t    case LEU : crx_cmp_str = \"hs\"; break;\n+\t    default : abort ();\n+\t    }\n+\t  fprintf (file, \"%s\", crx_cmp_str);\n+\t  return;\n+\t}\n+\n+    case 'H':\n+      /* Print high part of a double precision value. */\n+      switch (GET_CODE (x))\n+\t{\n+\tcase CONST_DOUBLE:\n+\t  if (GET_MODE (x) == SFmode) abort ();\n+\t  if (GET_MODE (x) == DFmode)\n+\t    {\n+\t      /* High part of a DF const. */\n+\t      REAL_VALUE_TYPE r;\n+\t      long l[2];\n+\n+\t      REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n+\t      REAL_VALUE_TO_TARGET_DOUBLE (r, l);\n+\n+\t      fprintf (file, \"$0x%lx\", l[1]);\n+\t      return;\n+\t    }\n+\n+\t  /* -- Fallthrough to handle DI consts -- */\n+\n+\tcase CONST_INT:\n+\t    {\n+\t      rtx high, low;\n+\t      split_double (x, &low, &high);\n+\t      putc ('$', file);\n+\t      output_addr_const (file, high);\n+\t      return;\n+\t    }\n+\n+\tcase REG:\n+\t  if (REGNO (x) + 1 >= FIRST_PSEUDO_REGISTER) abort ();\n+\t  fprintf (file, \"%s\", reg_names[REGNO (x) + 1]);\n+\t  return;\n+\n+\tcase MEM:\n+\t  /* Adjust memory address to high part.  */\n+\t    {\n+\t      rtx adj_mem = x;\n+\t      adj_mem = adjust_address (adj_mem, GET_MODE (adj_mem), 4);\n+\n+\t      output_memory_reference_mode = GET_MODE (adj_mem);\n+\t      output_address (XEXP (adj_mem, 0));\n+\t      return;\n+\t    }\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+\n+    case 'L':\n+      /* Print low part of a double precision value. */\n+      switch (GET_CODE (x))\n+\t{\n+\tcase CONST_DOUBLE:\n+\t  if (GET_MODE (x) == SFmode) abort ();\n+\t  if (GET_MODE (x) == DFmode)\n+\t    {\n+\t      /* High part of a DF const. */\n+\t      REAL_VALUE_TYPE r;\n+\t      long l[2];\n+\n+\t      REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n+\t      REAL_VALUE_TO_TARGET_DOUBLE (r, l);\n+\n+\t      fprintf (file, \"$0x%lx\", l[0]);\n+\t      return;\n+\t    }\n+\n+\t  /* -- Fallthrough to handle DI consts -- */\n+\n+\tcase CONST_INT:\n+\t    {\n+\t      rtx high, low;\n+\t      split_double (x, &low, &high);\n+\t      putc ('$', file);\n+\t      output_addr_const (file, low);\n+\t      return;\n+\t    }\n+\n+\tcase REG:\n+\t  fprintf (file, \"%s\", reg_names[REGNO (x)]);\n+\t  return;\n+\n+\tcase MEM:\n+\t  output_memory_reference_mode = GET_MODE (x);\n+\t  output_address (XEXP (x, 0));\n+\t  return;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+\n+    case 0 : /* default */\n+      switch (GET_CODE(x))\n+\t{\n+\tcase REG:\n+\t  fprintf (file, \"%s\", reg_names[REGNO (x)]);\n+\t  return;\n+\n+\tcase MEM:\n+\t  output_memory_reference_mode = GET_MODE (x);\n+\t  output_address (XEXP (x, 0));\n+\t  return;\n+\n+\tcase CONST_DOUBLE:\n+\t    {\n+\t      REAL_VALUE_TYPE r;\n+\t      long l;\n+\n+\t      /* Always use H and L for double precision - see above */\n+\t      gcc_assert(GET_MODE (x) == SFmode);\n+\n+\t      REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n+\t      REAL_VALUE_TO_TARGET_SINGLE (r, l);\n+\n+\t      fprintf (file, \"$0x%lx\", l);\n+\t      return;\n+\t    }\n+\n+\tdefault:\n+\t  putc ('$', file);\n+\t  output_addr_const (file, x);\n+\t  return;\n+\t}\n+\n+    default:\n+      output_operand_lossage (\"invalid %%xn code\");\n+    }\n+\n+  abort ();\n+}\n+\n+/* Implements the macro PRINT_OPERAND_ADDRESS defined in crx.h.  */\n+\n+void\n+crx_print_operand_address (FILE * file, rtx addr)\n+{\n+  rtx breg = 0, ireg = 0;\n+  rtx offset = 0;\n+  rtx post_offset = 0;\n+  rtx scale = 0;\n+  int mem = 0;\n+\n+retry:\n+  switch (GET_CODE (addr))\n+    {\n+    case MEM:\n+      fprintf (file, \"0(\");\n+      addr = XEXP (addr, 0);\n+      mem = 1;\n+      goto retry;\n+    case REG:\n+      fprintf (file, \"0(%s)\", reg_names[REGNO (addr)]);\n+      break;\n+    case MULT:\n+      abort ();\n+      break;\n+    case PLUS:\n+      switch (GET_CODE (XEXP (addr, 0)))\n+\t{\n+\tcase REG:\n+\t  if (GET_CODE (XEXP (addr, 1)) == REG)\n+\t    {\n+\t      ireg = XEXP (addr, 0);\n+\t      breg = XEXP (addr, 1);\n+\t    }\n+\t  else if (CONSTANT_ADDRESS_P (XEXP (addr, 1)))\n+\t    {\n+\t      if (REG_OK_FOR_BASE_P (XEXP (addr, 0))\n+\t\t  && ((GET_CODE (XEXP (addr, 1)) == CONST_INT)\n+\t\t      || (const_and_contains_symbol_ref (XEXP (addr, 1)))\n+\t\t      || (const_and_contains_label_ref (XEXP (addr, 1)))))\n+\t\tireg = XEXP (addr, 0);\n+\t      else\n+\t\tbreg = XEXP (addr, 0);\n+\n+\t      offset = XEXP (addr, 1);\n+\t    }\n+\t  else\n+\t    abort ();\n+\t  break;\n+\tcase MULT:\n+\t  ireg = XEXP (XEXP (addr, 0), 0);\n+\t  scale = XEXP (XEXP (addr, 0), 1);\n+\t  breg = XEXP (addr, 1);\n+\t  break;\n+\tcase PLUS:\n+\t  if ((GET_CODE (XEXP (XEXP (addr, 0), 0)) == MULT)\n+\t      && (GET_CODE (XEXP (XEXP (XEXP (addr, 0), 0), 0)) == REG)\n+\t      && (SCALE_FOR_INDEX_P (XEXP (XEXP (XEXP (addr, 0), 0), 1)))\n+\t      && (GET_CODE (XEXP (XEXP (addr, 0), 1)) == REG)\n+\t      && (GET_CODE (XEXP (addr, 1)) == CONST_INT))\n+\t    {\n+\t      ireg = XEXP (XEXP (XEXP (addr, 0), 0), 0);\n+\t      breg = XEXP (XEXP (addr, 0), 1);\n+\t      scale = (XEXP (XEXP (XEXP (addr, 0), 0), 1));\n+\t      offset = XEXP (addr, 1);\n+\t    }\n+\t  else if (GET_CODE (XEXP (XEXP (addr, 0), 0)) == REG\n+\t\t   && GET_CODE (XEXP (XEXP (addr, 0), 1)) == REG\n+\t\t   && CONSTANT_ADDRESS_P (XEXP (addr, 1)))\n+\t    {\n+\t      ireg = XEXP (XEXP (addr, 0), 0);\n+\t      breg = XEXP (XEXP (addr, 0), 1);\n+\t      offset = XEXP (addr, 1);\n+\t    }\n+\t  else if (GET_CODE (XEXP (XEXP (addr, 0), 0)) == REG\n+\t\t   && GET_CODE (XEXP (addr, 1)) == REG\n+\t\t   && CONSTANT_ADDRESS_P (XEXP (XEXP (addr, 0), 1)))\n+\t    {\n+\t      ireg = XEXP (XEXP (addr, 0), 0);\n+\t      breg = XEXP (addr, 1);\n+\t      offset = XEXP (XEXP (addr, 0), 1);\n+\t    }\n+\t  else\n+\t    abort ();\n+\t  break;\n+\tdefault:\n+\t  if (CONSTANT_ADDRESS_P (XEXP (addr, 1)))\n+\t    {\n+\t      if (CONSTANT_ADDRESS_P (XEXP (addr, 0)))\n+\t\toffset = addr;\n+\t      else if (GET_CODE (XEXP (addr, 0)) == POST_INC\n+\t\t       || GET_CODE (XEXP (addr, 0)) == POST_DEC)\n+\t\tpost_offset = XEXP (addr, 1);\n+\t      else\n+\t\tabort ();\n+\t    }\n+\n+\t  break;\n+\t}\n+\n+      if (scale)\n+\t{\n+\t  fprintf (file, \"%ld(%s,%s,%ld)\", offset ? INTVAL (offset) : 0,\n+\t\t   reg_names[REGNO (breg)], reg_names[REGNO (ireg)],\n+\t\t   INTVAL (scale));\n+\t}\n+      else\n+\t{\n+\t  /* If this is (POST_DEC/INC expression + post_offset) make addr =\n+\t   * POST_DEC/INC expression  */\n+\t  if (post_offset != 0)\n+\t    {\n+\t      addr = XEXP (addr, 0);\n+\t      print_post_operand_address (file, addr, INTVAL (post_offset));\n+\t      break;\n+\t    }\n+\n+\t  if (ireg != 0)\n+\t    {\n+\t      if (offset != 0)\n+\t\t{\n+\t\t  output_addr_const (file, offset);\n+\t\t  /* Print modifier if relevant.  */\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  fprintf (file, \"0\");\n+\t\t}\n+\t      /* Print address string */\n+\t      if (breg != 0)\n+\t\t{\n+\t\t  fprintf (file, \"(%s,%s)\", reg_names[REGNO (breg)],\n+\t\t\t   reg_names[REGNO (ireg)]);\n+\t\t}\n+\t      else\n+\t\tfprintf (file, \"(%s)\", reg_names[REGNO (ireg)]);\n+\t    }\n+\t  else\n+\t    {\n+\t      if (offset != 0)\n+\t\t{\n+\t\t  output_addr_const (file, offset);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  fprintf (file, \"0\");\n+\t\t}\n+\n+\t      if (breg != 0)\n+\t\t{\n+\t\t  if (offset == 0)\n+\t\t    fprintf (file, \"0\");\n+\t\t  fprintf (file, \"(%s)\", reg_names[REGNO (breg)]);\n+\t\t}\n+\t    }\n+\t}\n+      break;\n+\n+    case POST_DEC:\n+    case POST_INC:\n+    case POST_MODIFY:\n+      print_post_operand_address (file, addr, 0);\n+      break;\n+\n+    default:\n+\n+      output_addr_const (file, addr);\n+    }\n+\n+  if (mem)\n+    fprintf (file, \")\");\n+}\n+\n+\n+/*****************************************************************************/\n+/* MACHINE DESCRIPTION HELPER-FUNCTIONS\t\t\t\t\t     */\n+/*****************************************************************************/\n+\n+void crx_expand_movmem_single (rtx src, rtx srcbase, rtx dst, rtx dstbase,\n+\t\t\t       rtx tmp_reg, unsigned HOST_WIDE_INT *offset_p)\n+{\n+  rtx addr, mem;\n+  unsigned HOST_WIDE_INT offset = *offset_p;\n+\n+  /* Load */\n+  addr = plus_constant (src, offset);\n+  mem = adjust_automodify_address (srcbase, SImode, addr, offset);\n+  emit_move_insn (tmp_reg, mem);\n+\n+  /* Store */\n+  addr = plus_constant (dst, offset);\n+  mem = adjust_automodify_address (dstbase, SImode, addr, offset);\n+  emit_move_insn (mem, tmp_reg);\n+\n+  *offset_p = offset + 4;\n+}\n+\n+int\n+crx_expand_movmem (rtx dstbase, rtx srcbase, rtx count_exp, rtx align_exp)\n+{\n+  unsigned HOST_WIDE_INT count = 0, offset, si_moves, i;\n+  HOST_WIDE_INT align = 0;\n+\n+  rtx src, dst;\n+  rtx tmp_reg;\n+\n+  if (GET_CODE (align_exp) == CONST_INT)\n+    { /* Only if aligned */\n+      align = INTVAL (align_exp);\n+      if (align & 3) return 0;\n+    }\n+\n+  if (GET_CODE (count_exp) == CONST_INT)\n+    { /* No more than 16 SImode moves */\n+      count = INTVAL (count_exp);\n+      if (count > 64) return 0;\n+    }\n+\n+  tmp_reg = gen_reg_rtx(SImode);\n+\n+  /* Create psrs for the src and dest pointers */\n+  dst = copy_to_mode_reg (Pmode, XEXP (dstbase, 0));\n+  if (dst != XEXP (dstbase, 0))\n+    dstbase = replace_equiv_address_nv (dstbase, dst);\n+  src = copy_to_mode_reg (Pmode, XEXP (srcbase, 0));\n+  if (src != XEXP (srcbase, 0))\n+    srcbase = replace_equiv_address_nv (srcbase, src);\n+\n+  offset = 0;\n+\n+  /* Emit SImode moves */\n+  si_moves = count >> 2;\n+  for (i = 0; i < si_moves; i++)\n+    crx_expand_movmem_single (src, srcbase, dst, dstbase, tmp_reg, &offset);\n+\n+  /* Special cases */\n+  if (count & 3)\n+    {\n+      offset = count - 4;\n+      crx_expand_movmem_single (src, srcbase, dst, dstbase, tmp_reg, &offset);\n+    }\n+\n+  gcc_assert (offset == count);\n+\n+  return 1;\n+}\n+\n+rtx\n+crx_expand_compare (enum rtx_code code, enum machine_mode mode)\n+{\n+  rtx op0, op1, cc_reg, ret;\n+\n+  op0 = crx_compare_op0;\n+  op1 = crx_compare_op1;\n+\n+  /* Emit the compare that writes into CC_REGNUM) */\n+  cc_reg = gen_rtx_REG (CCmode, CC_REGNUM);\n+  ret = gen_rtx_COMPARE (CCmode, op0, op1);\n+  emit_insn (gen_rtx_SET (VOIDmode, cc_reg, ret));\n+  /* debug_rtx (get_last_insn ()); */\n+\n+  /* Return the rtx for using the result in CC_REGNUM */\n+  return gen_rtx_fmt_ee (code, mode, cc_reg, const0_rtx);\n+}\n+\n+void\n+crx_expand_branch (enum rtx_code code, rtx label)\n+{\n+  rtx tmp = crx_expand_compare (code, VOIDmode);\n+  tmp = gen_rtx_IF_THEN_ELSE (VOIDmode, tmp,\n+\t\t\t      gen_rtx_LABEL_REF (VOIDmode, label),\n+\t\t\t      pc_rtx);\n+  emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx, tmp));\n+  /* debug_rtx (get_last_insn ()); */\n+}\n+\n+void\n+crx_expand_scond (enum rtx_code code, rtx dest)\n+{\n+  rtx tmp = crx_expand_compare (code, GET_MODE (dest));\n+  emit_move_insn (dest, tmp);\n+  /* debug_rtx (get_last_insn ()); */\n+}\n+\n+static void\n+mpushpop_str (char *stringbuffer, const char *mnemonic, char *mask)\n+{\n+  if(strlen(mask) > 2 || crx_interrupt_function_p ()) /* needs 2-word instr. */\n+    sprintf (stringbuffer, \"\\n\\t%s\\tsp, {%s}\", mnemonic, mask);\n+  else /* single word instruction */\n+    sprintf (stringbuffer, \"\\n\\t%s\\t%s\", mnemonic, mask);\n+}\n+\n+/* Called from crx.md. The return value depends on the parameter push_or_pop:\n+ * When push_or_pop is zero -> string for push instructions of prologue.\n+ * When push_or_pop is nonzero -> string for pop/popret/retx in epilogue.\n+ * Relies on the assumptions:\n+ * 1. RA is the last register to be saved.\n+ * 2. The maximal value of the counter is MAX_COUNT. */\n+\n+char *\n+crx_prepare_push_pop_string (int push_or_pop)\n+{\n+  /* j is the number of registers being saved, takes care that there won't be\n+   * more than 8 in one push/pop instruction */\n+\n+  /* For the register mask string */\n+  static char mask_str[50];\n+\n+  /* i is the index of save_regs[], going from 0 until last_reg_to_save */\n+  int i = 0;\n+\n+  int ra_in_bitmask = 0;\n+\n+  char *return_str;\n+\n+  /* For reversing on the push instructions if there are more than one. */\n+  char *temp_str;\n+\n+  return_str = (char *) xmalloc (120);\n+  temp_str = (char *) xmalloc (120);\n+\n+  /* Initialize */\n+  memset (return_str, 0, 3);\n+\n+  while (i <= last_reg_to_save)\n+    {\n+      /* Prepare mask for one instruction. */\n+      mask_str[0] = 0;\n+\n+      if (i <= SP_REGNUM)\n+\t{ /* Add regs unit full or SP register reached */\n+\t  int j = 0;\n+\t  while (j < MAX_COUNT && i <= SP_REGNUM)\n+\t    {\n+\t      if (save_regs[i])\n+\t\t{\n+\t\t  /* TODO to use ra_in_bitmask for detecting last pop is not\n+\t\t   * smart it prevents things like:  popret r5 */\n+\t\t  if (i == RETURN_ADDRESS_REGNUM) ra_in_bitmask = 1;\n+\t\t  if (j > 0) strcat (mask_str, \", \");\n+\t\t  strcat (mask_str, reg_names[i]);\n+\t\t  ++j;\n+\t\t}\n+\t      ++i;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* Handle hi/lo savings */\n+\t  while (i <= last_reg_to_save)\n+\t    {\n+\t      if (save_regs[i])\n+\t\t{\n+\t\t  strcat (mask_str, \"lo, hi\");\n+\t\t  i = last_reg_to_save + 1;\n+\t\t  break;\n+\t\t}\n+\t      ++i;\n+\t    }\n+\t}\n+\n+      if (strlen(mask_str) == 0) continue;\n+       \t\n+      if (push_or_pop == 1)\n+\t{\n+\t  if (crx_interrupt_function_p ())\n+\t    mpushpop_str (temp_str, \"popx\", mask_str);\n+\t  else\n+\t    {\n+\t      if (ra_in_bitmask)\n+\t\t{\n+\t\t  mpushpop_str (temp_str, \"popret\", mask_str);\n+\t\t  ra_in_bitmask = 0;\n+\t\t}\n+\t      else mpushpop_str (temp_str, \"pop\", mask_str);\n+\t    }\n+\n+\t  strcat (return_str, temp_str);\n+\t}\n+      else\n+\t{\n+\t  /* push - We need to reverse the order of the instructions if there\n+\t   * are more than one. (since the pop will not be reversed in the\n+\t   * epilogue */\n+      \t  if (crx_interrupt_function_p ())\n+\t    mpushpop_str (temp_str, \"pushx\", mask_str);\n+\t  else\n+\t    mpushpop_str (temp_str, \"push\", mask_str);\n+\t  strcat (temp_str, return_str);\n+\t  strcpy (strcat (return_str, \"\\t\"), temp_str);\n+\t}\n+\n+    }\n+\n+  if (push_or_pop == 1)\n+    {\n+      /* pop */\n+      if (crx_interrupt_function_p ())\n+\tstrcat (return_str, \"\\n\\tretx\\n\");\n+\n+      else if (!FUNC_IS_NORETURN_P (current_function_decl)\n+\t       && !save_regs[RETURN_ADDRESS_REGNUM])\n+\tstrcat (return_str, \"\\n\\tjump\\tra\\n\");\n+    }\n+\n+  /* Skip the newline and the tab in the start of return_str. */\n+  return_str += 2;\n+  return return_str;\n+}\n+\n+/*  CompactRISC CRX Architecture stack layout:\n+\n+     0 +---------------------\n+\t|\n+\t.\n+\t.\n+\t|\n+\t+==================== Sp(x)=Ap(x+1)\n+      A | Args for functions\n+      | | called by X and      Dynamically\n+      | | Dynamic allocations  allocated and\n+      | | (alloca, variable    deallocated\n+  Stack | length arrays).\n+  grows +-------------------- Fp(x)\n+  down| | Local vaiables of X\n+  ward| +--------------------\n+      | | Regs saved for X-1\n+      | +==================== Sp(x-1)=Ap(x)\n+\t| Args for func X\n+\t| pushed by X-1\n+\t+-------------------- Fp(x-1)\n+\t|\n+\t|\n+\tV\n+\n+*/\n+\n+void\n+crx_expand_prologue (void)\n+{\n+  crx_compute_frame ();\n+  crx_compute_save_regs ();\n+\n+  /* If there is no need in push and adjustment to sp, return. */\n+  if (size_for_adjusting_sp + sum_regs == 0)\n+    return;\n+\n+  if (last_reg_to_save != -1)\n+    /* If there are registers to push.  */\n+    emit_insn (gen_push_for_prologue (GEN_INT (sum_regs)));\n+\n+  if (size_for_adjusting_sp > 0)\n+    emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t   GEN_INT (-(size_for_adjusting_sp))));\n+\n+  if (frame_pointer_needed)\n+    /* Initialize the frame pointer with the value of the stack pointer\n+     * pointing now to the locals. */\n+    emit_move_insn (frame_pointer_rtx, stack_pointer_rtx);\n+}\n+\n+/* Generate insn that updates the stack for local variables and padding for\n+ * registers we save. - Generate the appropriate return insn. */\n+\n+void\n+crx_expand_epilogue (void)\n+{\n+  rtx return_reg;\n+\n+  /* Nonzero if we need to return and pop only RA. This will generate a\n+   * different insn. This differentiate is for the peepholes for call as last\n+   * statement in function. */\n+  int only_popret_RA = (save_regs[RETURN_ADDRESS_REGNUM]\n+\t\t\t&& (sum_regs == UNITS_PER_WORD));\n+\n+  /* Return register.  */\n+  return_reg = gen_rtx_REG (Pmode, RETURN_ADDRESS_REGNUM);\n+\n+  if (frame_pointer_needed)\n+    /* Restore the stack pointer with the frame pointers value */\n+    emit_move_insn (stack_pointer_rtx, frame_pointer_rtx);\n+\n+  if (size_for_adjusting_sp > 0)\n+    emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t   GEN_INT (size_for_adjusting_sp)));\n+\n+  if (crx_interrupt_function_p ())\n+    emit_jump_insn (gen_interrupt_return ());\n+  else if (last_reg_to_save == -1)\n+    /* Nothing to pop */\n+    /* Don't output jump for interrupt routine, only retx.  */\n+    emit_jump_insn (gen_indirect_jump_return ());\n+  else if (only_popret_RA)\n+    emit_jump_insn (gen_popret_RA_return ());\n+  else\n+    emit_jump_insn (gen_pop_and_popret_return (GEN_INT (sum_regs)));\n+}\n+"}, {"sha": "e7ec8ce460be5451c455d021bf362a74cb5e9ca6", "filename": "gcc/config/crx/crx.h", "status": "added", "additions": 533, "deletions": 0, "changes": 533, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db8697336fbb1f6665adbfa24a72a4dbbd549398/gcc%2Fconfig%2Fcrx%2Fcrx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db8697336fbb1f6665adbfa24a72a4dbbd549398/gcc%2Fconfig%2Fcrx%2Fcrx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcrx%2Fcrx.h?ref=db8697336fbb1f6665adbfa24a72a4dbbd549398", "patch": "@@ -0,0 +1,533 @@\n+/* Definitions of target machine for GNU compiler, for CRX.\n+   Copyright (C) 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n+   2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.  */\n+\n+#ifndef GCC_CRX_H\n+#define GCC_CRX_H\n+\n+/*****************************************************************************/\n+/* CONTROLLING THE DRIVER\t\t\t\t\t\t     */\n+/*****************************************************************************/\n+\n+#define CC1PLUS_SPEC \"%{!frtti:-fno-rtti} \\\n+    %{!fenforce-eh-specs:-fno-enforce-eh-specs} \\\n+    %{!fexceptions:-fno-exceptions} \\\n+    %{!fthreadsafe-statics:-fno-threadsafe-statics}\"\n+\n+#undef  STARTFILE_SPEC\n+#define STARTFILE_SPEC \"crti.o%s crtbegin.o%s\"\n+\n+#undef  ENDFILE_SPEC\n+#define ENDFILE_SPEC \"crtend.o%s crtn.o%s\"\n+\n+/*****************************************************************************/\n+/* RUN-TIME TARGET SPECIFICATION\t\t\t\t\t     */\n+/*****************************************************************************/\n+\n+#ifndef TARGET_CPU_CPP_BUILTINS\n+#define TARGET_CPU_CPP_BUILTINS()\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\\\n+     builtin_define(\"__CRX__\");\t\t\t\t\t\\\n+     builtin_define(\"__CR__\");\t\t  \t\t\t\\\n+} while (0)\n+#endif\n+\n+#define TARGET_VERSION fputs (\" (CRX/ELF)\", stderr);\n+\n+/* Put each function in its own section so that PAGE-instruction\n+ * relaxation can do its best.  */\n+#define OPTIMIZATION_OPTIONS(LEVEL, SIZEFLAG)\t\\\n+    do {\t\t\t\t\t\\\n+\tif ((LEVEL) || (SIZEFLAG))\t\t\\\n+\t    flag_function_sections = 1;\t\\\n+    } while (0)\n+\n+/* Show we can debug even without a frame pointer.  */\n+#define CAN_DEBUG_WITHOUT_FP\n+\n+/*****************************************************************************/\n+/* STORAGE LAYOUT\t\t\t\t\t\t\t     */\n+/*****************************************************************************/\n+\n+#define BITS_BIG_ENDIAN  0\n+\n+#define BYTES_BIG_ENDIAN 0\n+\n+#define WORDS_BIG_ENDIAN 0\n+\n+#define UNITS_PER_WORD 4\n+\n+#define POINTER_SIZE 32\n+\n+#define PARM_BOUNDARY 32\n+\n+#define STACK_BOUNDARY 32\n+\n+#define FUNCTION_BOUNDARY 32\n+\n+#define STRUCTURE_SIZE_BOUNDARY 32\n+\n+#define BIGGEST_ALIGNMENT 32\n+\n+/* In CRX arrays of chars are word-aligned, so strcpy() will be faster.  */\n+#define DATA_ALIGNMENT(TYPE, ALIGN) \\\n+  (TREE_CODE (TYPE) == ARRAY_TYPE && TYPE_MODE (TREE_TYPE (TYPE)) == QImode \\\n+   && (ALIGN) < BITS_PER_WORD \\\n+   ? (BITS_PER_WORD) : (ALIGN))\n+\n+/* In CRX strings are word-aligned so strcpy from constants will be faster. */\n+#define CONSTANT_ALIGNMENT(CONSTANT, ALIGN) \\\n+  (TREE_CODE (CONSTANT) == STRING_CST && (ALIGN) < BITS_PER_WORD \\\n+   ? (BITS_PER_WORD) : (ALIGN))\n+\n+#define STRICT_ALIGNMENT 0\n+\n+#define PCC_BITFIELD_TYPE_MATTERS 1\n+\n+/*****************************************************************************/\n+/* LAYOUT OF SOURCE LANGUAGE DATA TYPES\t\t\t\t\t     */\n+/*****************************************************************************/\n+\n+#define INT_TYPE_SIZE\t\t32\n+\n+#define SHORT_TYPE_SIZE\t\t16\n+\n+#define LONG_TYPE_SIZE\t\t32\n+\n+#define LONG_LONG_TYPE_SIZE\t64\n+\n+#define FLOAT_TYPE_SIZE \t32\n+\n+#define DOUBLE_TYPE_SIZE \t64\n+\n+#define LONG_DOUBLE_TYPE_SIZE   64\n+\n+#define DEFAULT_SIGNED_CHAR\t1\n+\n+#define SIZE_TYPE\t\t\"unsigned int\"\n+\n+#define PTRDIFF_TYPE\t\t\"int\"\n+\n+/*****************************************************************************/\n+/* REGISTER USAGE.\t\t\t\t\t\t\t     */\n+/*****************************************************************************/\n+\n+#define FIRST_PSEUDO_REGISTER\t19\n+\n+/* On the CRX, only the stack pointer (r15) is such. */\n+#define FIXED_REGISTERS \\\n+  { \\\n+ /* r0  r1  r2  r3  r4  r5  r6  r7  r8  r9  r10 */  \\\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\t    \\\n+ /* r11 r12 r13 ra  sp  r16 r17 cc */\t\t    \\\n+    0,  0,  0,  0,  1,  0,  0,  1\t\t    \\\n+  }\n+\n+/* On the CRX, calls clobbers r0-r6 (scratch registers), ra (the return address)\n+ * and sp - (the stack pointer which is fixed). */\n+#define CALL_USED_REGISTERS \\\n+  { \\\n+ /* r0  r1  r2  r3  r4  r5  r6  r7  r8  r9  r10 */  \\\n+    1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,\t    \\\n+ /* r11 r12 r13 ra  sp  r16 r17 cc */\t\t    \\\n+    0,  0,  0,  1,  1,  1,  1,  1\t\t    \\\n+  }\n+\n+#define HARD_REGNO_NREGS(REGNO, MODE) \\\n+    ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* On the CRX architecture, HILO regs can only hold SI mode. */\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) crx_hard_regno_mode_ok(REGNO, MODE)\n+\n+/* So far no patterns for moving CCMODE data are available */\n+#define AVOID_CCMODE_COPIES\n+\n+/* Interrupt functions can only use registers that have already been saved by\n+ * the prologue, even if they would normally be call-clobbered. */\n+#define HARD_REGNO_RENAME_OK(SRC, DEST)\t\\\n+\t(!crx_interrupt_function_p () || regs_ever_live[DEST])\n+\n+#define MODES_TIEABLE_P(MODE1, MODE2)  1\n+\n+enum reg_class\n+{\n+  NO_REGS,\n+  LO_REGS,\n+  HI_REGS,\n+  HILO_REGS,\n+  NOSP_REGS,\n+  GENERAL_REGS,\n+  ALL_REGS,\n+  LIM_REG_CLASSES\n+};\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+#define REG_CLASS_NAMES \\\n+  {\t\t\t\\\n+    \"NO_REGS\",\t\t\\\n+    \"LO_REGS\",\t\t\\\n+    \"HI_REGS\",\t\t\\\n+    \"HILO_REGS\",\t\\\n+    \"NOSP_REGS\",\t\\\n+    \"GENERAL_REGS\",\t\\\n+    \"ALL_REGS\"\t\t\\\n+  }\n+\n+#define REG_CLASS_CONTENTS\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    {0x00000000}, /* NO_REGS\t\t\t*/\t\\\n+    {0x00010000}, /* LO_REGS :\t\t16 \t*/\t\\\n+    {0x00020000}, /* HI_REGS :\t\t17\t*/\t\\\n+    {0x00030000}, /* HILO_REGS :\t16, 17\t*/\t\\\n+    {0x00007fff}, /* NOSP_REGS : \t0 - 14\t*/\t\\\n+    {0x0000ffff}, /* GENERAL_REGS : \t0 - 15\t*/\t\\\n+    {0x0007ffff}  /* ALL_REGS : \t0 - 18\t*/\t\\\n+  }\n+\n+#define REGNO_REG_CLASS(REGNO)  crx_regno_reg_class(REGNO)\n+\n+#define BASE_REG_CLASS\t\tGENERAL_REGS\n+\n+#define INDEX_REG_CLASS\t\tGENERAL_REGS\n+\n+#define REG_CLASS_FROM_LETTER(C)\t\\\n+  ((C) == 'b' ? NOSP_REGS :\t\t\\\n+   (C) == 'l' ? LO_REGS : \t\t\\\n+   (C) == 'h' ? HI_REGS :\t\t\\\n+   (C) == 'k' ? HILO_REGS :\t\t\\\n+  NO_REGS)\n+\n+#define REGNO_OK_FOR_BASE_P(REGNO) \\\n+  ((REGNO) < 16 \\\n+   || (reg_renumber && (unsigned)reg_renumber[REGNO] < 16))\n+\n+#define REGNO_OK_FOR_INDEX_P(REGNO)\t   REGNO_OK_FOR_BASE_P(REGNO)\n+#define REGNO_OK_FOR_INDEXED_BASE_P(REGNO) REGNO_OK_FOR_BASE_P(REGNO)\n+\n+#define PREFERRED_RELOAD_CLASS(X,CLASS) CLASS\n+\n+#define SECONDARY_RELOAD_CLASS(CLASS, MODE, X) \\\n+  crx_secondary_reload_class (CLASS, MODE, X)\n+\n+#define CLASS_MAX_NREGS(CLASS, MODE) \\\n+    (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD\n+\n+#define SIGNED_INT_FITS_N_BITS(imm, N) \\\n+  ((((imm) < ((long long)1<<((N)-1))) && ((imm) >= -((long long)1<<((N)-1)))) ? 1 : 0)\n+\n+#define UNSIGNED_INT_FITS_N_BITS(imm, N) \\\n+  (((imm) < ((long long)1<<(N)) && (imm) >= (long long)0) ? 1 : 0)\n+\n+#define HILO_REGNO_P(regno) \\\n+  (reg_classes_intersect_p(REGNO_REG_CLASS(regno), HILO_REGS))\n+\n+#define INT_CST4(VALUE) \\\n+  (((VALUE) >= -1 && (VALUE) <= 4) || (VALUE) == -4 \\\n+  || (VALUE) == 7 || (VALUE) == 8 || (VALUE) == 16 || (VALUE) == 32 \\\n+  || (VALUE) == 20 || (VALUE) == 12 || (VALUE) == 48)\n+\n+#define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\\\n+  /* Legal const for store immediate instructions */\t\t\\\n+  ((C) == 'I' ? UNSIGNED_INT_FITS_N_BITS(VALUE, 3) :\t\t\\\n+   (C) == 'J' ? UNSIGNED_INT_FITS_N_BITS(VALUE, 4) :\t\t\\\n+   (C) == 'K' ? UNSIGNED_INT_FITS_N_BITS(VALUE, 5) :\t\t\\\n+   (C) == 'L' ? INT_CST4(VALUE) :\t\t\t\t\\\n+  0)\n+\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)\t\\\n+  ((C) == 'G' ? crx_const_double_ok (VALUE) :\t\\\n+  0)\n+\n+/*****************************************************************************/\n+/* STACK LAYOUT AND CALLING CONVENTIONS.\t\t\t\t     */\n+/*****************************************************************************/\n+\n+#define STACK_GROWS_DOWNWARD\n+\n+#define STARTING_FRAME_OFFSET  0\n+\n+#define\tSTACK_POINTER_REGNUM\t15\n+\n+#define\tFRAME_POINTER_REGNUM\t13\n+\n+#define\tARG_POINTER_REGNUM\t12\n+\n+#define STATIC_CHAIN_REGNUM\t1\n+\n+#define\tRETURN_ADDRESS_REGNUM\t14\n+\n+#define FIRST_PARM_OFFSET(FNDECL)  0\n+\n+#define FRAME_POINTER_REQUIRED (current_function_calls_alloca)\n+\n+#define ELIMINABLE_REGS \\\n+  { \\\n+    { ARG_POINTER_REGNUM,   STACK_POINTER_REGNUM}, \\\n+    { ARG_POINTER_REGNUM,   FRAME_POINTER_REGNUM}, \\\n+    { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}  \\\n+  }\n+\n+#define CAN_ELIMINATE(FROM, TO) \\\n+ ((TO) == STACK_POINTER_REGNUM ? ! frame_pointer_needed : 1)\n+\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    (OFFSET) = crx_initial_elimination_offset ((FROM), (TO));\t\t\\\n+  } while (0)\n+\n+/*****************************************************************************/\n+/* PASSING FUNCTION ARGUMENTS\t\t\t\t\t\t     */\n+/*****************************************************************************/\n+\n+#define ACCUMULATE_OUTGOING_ARGS (TARGET_NO_PUSH_ARGS)\n+\n+#define PUSH_ARGS (!TARGET_NO_PUSH_ARGS)\n+\n+#define PUSH_ROUNDING(BYTES) (((BYTES) + 3) & ~3)\n+\n+#define RETURN_POPS_ARGS(FNDECL, FUNTYPE, SIZE)   0\n+\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n+  ((rtx) crx_function_arg(&(CUM), (MODE), (TYPE), (NAMED)))\n+\n+#ifndef CUMULATIVE_ARGS\n+struct cumulative_args\n+{\n+  int ints;\n+};\n+\n+#define CUMULATIVE_ARGS struct cumulative_args\n+#endif\n+\n+/* On the CRX architecture, Varargs routines should receive their parameters on\n+ * the stack.  */\n+\n+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, FNDECL, N_NAMED_ARGS) \\\n+  crx_init_cumulative_args(&(CUM), (FNTYPE), (LIBNAME))\n+\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED) \\\n+  crx_function_arg_advance(&(CUM), (MODE), (TYPE), (NAMED))\n+\n+#define FUNCTION_ARG_REGNO_P(REGNO)  crx_function_arg_regno_p((REGNO))\n+\n+/*****************************************************************************/\n+/* RETURNING FUNCTION VALUE\t\t\t\t\t\t     */\n+/*****************************************************************************/\n+\n+/* On the CRX, the return value is in R0 */\n+\n+#define FUNCTION_VALUE(VALTYPE, FUNC) \\\n+\tgen_rtx_REG(TYPE_MODE (VALTYPE), 0)\n+\n+#define LIBCALL_VALUE(MODE)\tgen_rtx_REG (MODE, 0)\n+\n+#define FUNCTION_VALUE_REGNO_P(N)\t((N) == 0)\n+\n+#define CRX_STRUCT_VALUE_REGNUM  0\n+\n+/*****************************************************************************/\n+/* GENERATING CODE FOR PROFILING - NOT IMPLEMENTED\t\t\t     */\n+/*****************************************************************************/\n+\n+#undef  FUNCTION_PROFILER\n+#define FUNCTION_PROFILER(STREAM, LABELNO)\t\\\n+{\t\t\t\t\t\t\\\n+    sorry (\"Profiler support for CRX\");\t\t\\\n+}\n+\t\n+/*****************************************************************************/\n+/* TRAMPOLINES FOR NESTED FUNCTIONS - NOT SUPPORTED      \t\t     */\n+/*****************************************************************************/\n+\n+#define TRAMPOLINE_SIZE\t32\n+\n+#define INITIALIZE_TRAMPOLINE(addr, fnaddr, static_chain)\t\\\n+{\t\t\t\t\t\t\t\t\\\n+    sorry (\"Trampoline support for CRX\");\t\t\t\\\n+}\n+\n+/*****************************************************************************/\n+/* ADDRESSING MODES\t\t\t\t\t\t\t     */\n+/*****************************************************************************/\n+\n+#define CONSTANT_ADDRESS_P(X)\t\t\t\t\t\t\\\n+  (GET_CODE (X) == LABEL_REF\t\t\t\t\t\t\\\n+   || GET_CODE (X) == SYMBOL_REF\t\t\t\t\t\\\n+   || GET_CODE (X) == CONST\t\t\t\t\t\t\\\n+   || GET_CODE (X) == CONST_INT)\n+\n+#define MAX_REGS_PER_ADDRESS 2\n+\n+#define HAVE_POST_INCREMENT  1\n+#define HAVE_POST_DECREMENT  1\n+#define HAVE_POST_MODIFY_DISP 1\n+#define HAVE_POST_MODIFY_REG 0\n+\n+#define STRICT_REG_OK_FOR_BASE_P(X)\t    REGNO_OK_FOR_BASE_P (REGNO (X))\n+#define STRICT_REG_OK_FOR_INDEX_P(X)\t    REGNO_OK_FOR_INDEX_P(REGNO(X))\n+#define STRICT_REG_OK_FOR_INDEXED_BASE_P(X) REGNO_OK_FOR_INDEXED_BASE_P(REGNO(X))\n+\n+#define NONSTRICT_REG_OK_FOR_BASE_P(X)\t\t1\n+#define NONSTRICT_REG_OK_FOR_INDEX_P(X)\t\t1\n+#define NONSTRICT_REG_OK_FOR_INDEXED_BASE_P(X)\t1\n+\n+#ifdef REG_OK_STRICT\n+#define REG_OK_FOR_BASE_P(X)\t\tSTRICT_REG_OK_FOR_BASE_P(X)\n+#define REG_OK_FOR_INDEX_P(X)\t\tSTRICT_REG_OK_FOR_INDEX_P(X)\n+#define REG_OK_FOR_INDEXED_BASE_P(X)\tSTRICT_REG_OK_FOR_INDEXED_BASE_P(X)\n+#else\n+#define REG_OK_FOR_BASE_P(X)\t\tNONSTRICT_REG_OK_FOR_BASE_P(X)\n+#define REG_OK_FOR_INDEX_P(X)\t\tNONSTRICT_REG_OK_FOR_INDEX_P(X)\n+#define REG_OK_FOR_INDEXED_BASE_P(X)\tNONSTRICT_REG_OK_FOR_INDEXED_BASE_P(X)\n+#endif /* REG_OK_STRICT */\n+\n+#ifdef REG_OK_STRICT\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (crx_legitimate_address_p (MODE, X, 1))\t\t\t\t\\\n+      goto LABEL;\t\t\t\t\t\t\t\\\n+}\n+#else\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (crx_legitimate_address_p (MODE, X, 0))\t\t\t\t\\\n+      goto LABEL;\t\t\t\t\t\t\t\\\n+}\n+#endif\n+\n+#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\t{}\n+\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (GET_CODE (ADDR) == POST_INC || GET_CODE (ADDR) == POST_DEC)\t\\\n+    goto LABEL;\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define LEGITIMATE_CONSTANT_P(X)  1\n+\n+/*****************************************************************************/\n+/* CONDITION CODE STATUS\t\t\t\t\t\t     */\n+/*****************************************************************************/\n+\n+/*****************************************************************************/\n+/* RELATIVE COSTS OF OPERATIONS\t\t\t\t\t\t     */\n+/*****************************************************************************/\n+\n+#define MEMORY_MOVE_COST(MODE, CLASS, IN) crx_memory_move_cost(MODE, CLASS, IN)\n+/* Moving to processor register flushes pipeline - thus asymmetric */\n+#define REGISTER_MOVE_COST(MODE, FROM, TO) ((TO != GENERAL_REGS) ? 8 : 2)\n+/* Assume best case (branch predicted) */\n+#define BRANCH_COST 2\n+\n+#define SLOW_BYTE_ACCESS  1\n+\n+/*****************************************************************************/\n+/* DIVIDING THE OUTPUT INTO SECTIONS\t\t\t\t\t     */\n+/*****************************************************************************/\n+\n+#define TEXT_SECTION_ASM_OP\t\"\\t.section\\t.text\"\n+\n+#define DATA_SECTION_ASM_OP\t\"\\t.section\\t.data\"\n+\n+#define BSS_SECTION_ASM_OP\t\"\\t.section\\t.bss\"\n+\n+/*****************************************************************************/\n+/* POSITION INDEPENDENT CODE\t\t\t\t\t\t     */\n+/*****************************************************************************/\n+\n+#define PIC_OFFSET_TABLE_REGNUM  12\n+\n+#define LEGITIMATE_PIC_OPERAND_P(X)  1\n+\n+/*****************************************************************************/\n+/* ASSEMBLER FORMAT\t\t\t\t\t\t\t     */\n+/*****************************************************************************/\n+\n+#define GLOBAL_ASM_OP \"\\t.globl\\t\"\n+\n+#undef\tUSER_LABEL_PREFIX\n+#define\tUSER_LABEL_PREFIX \"_\"\n+\n+#undef\tASM_OUTPUT_LABELREF\n+#define ASM_OUTPUT_LABELREF(STREAM, NAME) \\\n+  asm_fprintf (STREAM, \"%U%s\", (*targetm.strip_name_encoding) (NAME));\n+\n+#undef\tASM_APP_ON\n+#define ASM_APP_ON   \"#APP\\n\"\n+\n+#undef\tASM_APP_OFF\n+#define ASM_APP_OFF  \"#NO_APP\\n\"\n+\n+/*****************************************************************************/\n+/* INSTRUCTION OUTPUT\t\t\t\t\t\t\t     */\n+/*****************************************************************************/\n+\n+#define REGISTER_NAMES \\\n+  { \\\n+    \"r0\",  \"r1\",  \"r2\",  \"r3\",  \"r4\",  \"r5\",  \"r6\",  \"r7\", \\\n+    \"r8\",  \"r9\",  \"r10\", \"r11\", \"r12\", \"r13\", \"ra\",  \"sp\", \\\n+    \"lo\",  \"hi\",  \"cc\" \\\n+  }\n+\n+#define PRINT_OPERAND(STREAM, X, CODE) \\\n+  crx_print_operand(STREAM, X, CODE)\n+\n+#define PRINT_OPERAND_ADDRESS(STREAM, ADDR) \\\n+  crx_print_operand_address(STREAM, ADDR)\n+\n+/*****************************************************************************/\n+/* OUTPUT OF DISPATCH TABLES\t\t\t\t\t\t     */\n+/*****************************************************************************/\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(STREAM, VALUE) \\\n+  asm_fprintf ((STREAM), \"\\t.long\\t.L%d\\n\", (VALUE))\n+\n+/*****************************************************************************/\n+/* ALIGNMENT IN ASSEMBLER FILE\t\t\t\t\t\t     */\n+/*****************************************************************************/\n+\n+#define ASM_OUTPUT_ALIGN(STREAM, POWER) \\\n+  asm_fprintf ((STREAM), \"\\t.align\\t%d\\n\", 1 << (POWER))\n+\n+/*****************************************************************************/\n+/* MISCELLANEOUS PARAMETERS\t\t\t\t\t\t     */\n+/*****************************************************************************/\n+\n+#define CASE_VECTOR_MODE  Pmode\n+\n+#define MOVE_MAX 4\n+\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC)  1\n+\n+#define STORE_FLAG_VALUE  1\n+\n+#define Pmode\t\tSImode\n+\n+#define FUNCTION_MODE\tQImode\n+\n+/*****************************************************************************/\n+/* EXTERNAL DECLARATIONS FOR VARIABLES DEFINED IN CRX.C\t\t\t     */\n+/*****************************************************************************/\n+\n+extern rtx crx_compare_op0;    /* operand 0 for comparisons */\n+extern rtx crx_compare_op1;    /* operand 1 for comparisons */\n+\n+#endif /* ! GCC_CRX_H */"}, {"sha": "54dcd49c7da46ba65739364b7b09bebd99fec7a6", "filename": "gcc/config/crx/crx.md", "status": "added", "additions": 920, "deletions": 0, "changes": 920, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db8697336fbb1f6665adbfa24a72a4dbbd549398/gcc%2Fconfig%2Fcrx%2Fcrx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db8697336fbb1f6665adbfa24a72a4dbbd549398/gcc%2Fconfig%2Fcrx%2Fcrx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcrx%2Fcrx.md?ref=db8697336fbb1f6665adbfa24a72a4dbbd549398", "patch": "@@ -0,0 +1,920 @@\n+;; GCC machine description for CRX.\n+;; Copyright (C) 1988, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n+;; 2001, 2002, 2003, 2004\n+;; Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.  */\n+\n+;;  Register numbers\n+\n+(define_constants\n+  [(SP_REGNUM 15)\t; Stack pointer\n+   (RA_REGNUM 14)\t; Return address\n+   (LO_REGNUM 16)\t; LO register\n+   (HI_REGNUM 17)\t; HI register\n+   (CC_REGNUM 18)\t; Condition code register\n+  ]\n+)\n+\n+(define_attr \"length\" \"\" ( const_int 6 ) )\n+\n+(define_asm_attributes\n+  [(set_attr \"length\" \"6\")]\n+)\n+\n+;;  Predicates\n+\n+(define_predicate \"u4bits_operand\"\n+  (match_code \"const_int,const_double\")\n+  {\n+    if (GET_CODE (op) == CONST_DOUBLE)\n+      return crx_const_double_ok (op);\n+    return (UNSIGNED_INT_FITS_N_BITS(INTVAL(op), 4)) ? 1 : 0;\n+  }\n+)\n+\n+(define_predicate \"cst4_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INT_CST4(INTVAL(op))\")))\n+\n+(define_predicate \"reg_or_u4bits_operand\"\n+  (ior (match_operand 0 \"u4bits_operand\")\n+       (match_operand 0 \"register_operand\")))\n+\n+(define_predicate \"reg_or_cst4_operand\"\n+  (ior (match_operand 0 \"cst4_operand\")\n+       (match_operand 0 \"register_operand\")))\n+\n+(define_predicate \"reg_or_sym_operand\"\n+  (ior (match_code \"symbol_ref\")\n+       (match_operand 0 \"register_operand\")))\n+\n+(define_predicate \"nosp_reg_operand\"\n+  (and (match_operand 0 \"register_operand\")\n+       (match_test \"REGNO (op) != SP_REGNUM\")))\n+\n+(define_predicate \"store_operand\"\n+  (and (match_operand 0 \"memory_operand\")\n+       (not (match_operand 0 \"push_operand\"))))\n+\n+;;  Mode Macro Definitions\n+\n+(define_mode_macro ALLMT [QI HI SI SF DI DF])\n+(define_mode_macro CRXMM [QI HI SI SF])\n+(define_mode_macro CRXIM [QI HI SI])\n+(define_mode_macro DIDFM [DI DF])\n+(define_mode_macro SISFM [SI SF])\n+(define_mode_macro SHORT [QI HI])\n+\n+(define_mode_attr tIsa [(QI \"b\") (HI \"w\") (SI \"d\") (SF \"d\")])\n+(define_mode_attr lImmArith [(QI \"4\") (HI \"4\") (SI \"6\")])\n+(define_mode_attr lImmRotl [(QI \"2\") (HI \"2\") (SI \"4\")])\n+(define_mode_attr IJK [(QI \"I\") (HI \"J\") (SI \"K\")])\n+(define_mode_attr iF [(QI \"i\") (HI \"i\") (SI \"i\") (DI \"i\") (SF \"F\") (DF \"F\")])\n+(define_mode_attr JG [(QI \"J\") (HI \"J\") (SI \"J\") (DI \"J\") (SF \"G\") (DF \"G\")])\n+;   In HI or QI mode we push 4 bytes.\n+(define_mode_attr pushCnstr [(QI \"X\") (HI \"X\") (SI \"<\") (SF \"<\") (DI \"<\") (DF \"<\")])\n+(define_mode_attr tpush [(QI \"\") (HI \"\") (SI \"\") (SF \"\") (DI \"sp, \") (DF \"sp, \")])\n+(define_mode_attr lpush [(QI \"2\") (HI \"2\") (SI \"2\") (SF \"2\") (DI \"4\") (DF \"4\")])\n+\n+\n+;;  Code Macro Definitions\n+\n+(define_code_macro sz_xtnd [sign_extend zero_extend])\n+(define_code_attr sIsa [(sign_extend \"\") (zero_extend \"u\")])\n+(define_code_attr sPat [(sign_extend \"s\") (zero_extend \"u\")])\n+(define_code_attr szPat [(sign_extend \"\") (zero_extend \"zero_\")])\n+(define_code_attr szIsa [(sign_extend \"s\") (zero_extend \"z\")])\n+\n+(define_code_macro sh_oprnd [ashift ashiftrt lshiftrt])\n+(define_code_attr shIsa [(ashift \"ll\") (ashiftrt \"ra\") (lshiftrt \"rl\")])\n+(define_code_attr shPat [(ashift \"ashl\") (ashiftrt \"ashr\") (lshiftrt \"lshr\")])\n+\n+(define_code_macro mima_oprnd [smax umax smin umin])\n+(define_code_attr mimaIsa [(smax \"maxs\") (umax \"maxu\") (smin \"mins\") (umin \"minu\")])\n+\n+(define_code_macro any_cond [eq ne gt gtu lt ltu ge geu le leu])\n+\n+;;  Addition Instructions\n+\n+(define_insn \"adddi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"%0,0\")\n+\t\t (match_operand:DI 2 \"nonmemory_operand\" \"r,i\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"\"\n+  \"addd\\\\t%L2, %L1\\;addcd\\\\t%H2, %H1\"\n+  [(set_attr \"length\" \"4,12\")]\n+)\n+\n+(define_insn \"add<mode>3\"\n+  [(set (match_operand:CRXIM 0 \"register_operand\" \"=r,r\")\n+\t(plus:CRXIM (match_operand:CRXIM 1 \"register_operand\" \"%0,0\")\n+\t\t    (match_operand:CRXIM 2 \"nonmemory_operand\" \"r,i\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"\"\n+  \"add<tIsa>\\\\t%2, %0\"\n+  [(set_attr \"length\" \"2,<lImmArith>\")]\n+)\n+\n+;;  Subtract Instructions\n+\n+(define_insn \"subdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t(minus:DI (match_operand:DI 1 \"register_operand\" \"0,0\")\n+\t\t  (match_operand:DI 2 \"nonmemory_operand\" \"r,i\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"\"\n+  \"subd\\\\t%L2, %L1\\;subcd\\\\t%H2, %H1\"\n+  [(set_attr \"length\" \"4,12\")]\n+)\n+\n+(define_insn \"sub<mode>3\"\n+  [(set (match_operand:CRXIM 0 \"register_operand\" \"=r,r\")\n+\t(minus:CRXIM (match_operand:CRXIM 1 \"register_operand\" \"0,0\")\n+\t\t     (match_operand:CRXIM 2 \"nonmemory_operand\" \"r,i\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"\"\n+  \"sub<tIsa>\\\\t%2, %0\"\n+  [(set_attr \"length\" \"2,<lImmArith>\")]\n+)\n+\n+;;  Multiply Instructions\n+\n+(define_insn \"mul<mode>3\"\n+  [(set (match_operand:CRXIM 0 \"register_operand\" \"=r,r\")\n+\t(mult:CRXIM (match_operand:CRXIM 1 \"register_operand\" \"%0,0\")\n+\t\t    (match_operand:CRXIM 2 \"nonmemory_operand\" \"r,i\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"\"\n+  \"mul<tIsa>\\\\t%2, %0\"\n+  [(set_attr \"length\" \"2,<lImmArith>\")]\n+)\n+\n+;;  Widening-multiplication Instructions\n+\n+(define_insn \"<sIsa>mulsidi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=k\")\n+\t(mult:DI (sz_xtnd:DI (match_operand:SI 1 \"register_operand\" \"%r\"))\n+\t\t (sz_xtnd:DI (match_operand:SI 2 \"register_operand\" \"r\"))))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"\"\n+  \"mull<sPat>d\\\\t%2, %1\"\n+  [(set_attr \"length\" \"4\")]\n+)\n+\n+(define_insn \"<sIsa>mulhisi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(mult:SI (sz_xtnd:SI (match_operand:HI 1 \"register_operand\" \"%0\"))\n+\t\t (sz_xtnd:SI (match_operand:HI 2 \"register_operand\" \"r\"))))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"\"\n+  \"mul<sPat>wd\\\\t%2, %0\"\n+  [(set_attr \"length\" \"4\")]\n+)\n+\n+(define_insn \"<sIsa>mulqihi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(mult:HI (sz_xtnd:HI (match_operand:QI 1 \"register_operand\" \"%0\"))\n+\t\t (sz_xtnd:HI (match_operand:QI 2 \"register_operand\" \"r\"))))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"\"\n+  \"mul<sPat>bw\\\\t%2, %0\"\n+  [(set_attr \"length\" \"4\")]\n+)\n+\n+;;  Logical Instructions - and\n+\n+(define_insn \"and<mode>3\"\n+  [(set (match_operand:CRXIM 0 \"register_operand\" \"=r,r\")\n+\t(and:CRXIM (match_operand:CRXIM 1 \"register_operand\" \"%0,0\")\n+\t\t   (match_operand:CRXIM 2 \"nonmemory_operand\" \"r,i\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"\"\n+  \"and<tIsa>\\\\t%2, %0\"\n+  [(set_attr \"length\" \"2,<lImmArith>\")]\n+)\n+\n+;;  Logical Instructions - or\n+\n+(define_insn \"ior<mode>3\"\n+  [(set (match_operand:CRXIM 0 \"register_operand\" \"=r,r\")\n+\t(ior:CRXIM (match_operand:CRXIM 1 \"register_operand\" \"%0,0\")\n+\t\t   (match_operand:CRXIM 2 \"nonmemory_operand\" \"r,i\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"\"\n+  \"or<tIsa>\\\\t%2, %0\"\n+  [(set_attr \"length\" \"2,<lImmArith>\")]\n+)\n+\n+;;  Logical Instructions - xor\n+\n+(define_insn \"xor<mode>3\"\n+  [(set (match_operand:CRXIM 0 \"register_operand\" \"=r,r\")\n+\t(xor:CRXIM (match_operand:CRXIM 1 \"register_operand\" \"%0,0\")\n+\t\t   (match_operand:CRXIM 2 \"nonmemory_operand\" \"r,i\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"\"\n+  \"xor<tIsa>\\\\t%2, %0\"\n+  [(set_attr \"length\" \"2,<lImmArith>\")]\n+)\n+\n+;;  Sign and Zero Extend Instructions\n+\n+(define_insn \"<szPat>extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(sz_xtnd:SI (match_operand:HI 1 \"register_operand\" \"r\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"\"\n+  \"<szIsa>extwd\\\\t%1, %0\"\n+  [(set_attr \"length\" \"4\")]\n+)\n+\n+(define_insn \"<szPat>extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(sz_xtnd:SI (match_operand:QI 1 \"register_operand\" \"r\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"\"\n+  \"<szIsa>extbd\\\\t%1, %0\"\n+  [(set_attr \"length\" \"4\")]\n+)\n+\n+(define_insn \"<szPat>extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(sz_xtnd:HI (match_operand:QI 1 \"register_operand\" \"r\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"\"\n+  \"<szIsa>extbw\\\\t%1, %0\"\n+  [(set_attr \"length\" \"4\")]\n+)\n+\n+;;  Negation Instructions\n+\n+(define_insn \"neg<mode>2\"\n+  [(set (match_operand:CRXIM 0 \"register_operand\" \"=r\")\n+\t(neg:CRXIM (match_operand:CRXIM 1 \"register_operand\" \"r\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"\"\n+  \"neg<tIsa>\\\\t%1, %0\"\n+  [(set_attr \"length\" \"4\")]\n+)\n+\n+;;  Absolute Instructions\n+\n+(define_insn \"abs<mode>2\"\n+  [(set (match_operand:CRXIM 0 \"register_operand\" \"=r\")\n+\t(abs:CRXIM (match_operand:CRXIM 1 \"register_operand\" \"r\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"\"\n+  \"abs<tIsa>\\\\t%1, %0\"\n+  [(set_attr \"length\" \"4\")]\n+)\n+\n+;;  Max and Min Instructions\n+\n+(define_insn \"<code><mode>3\"\n+  [(set (match_operand:CRXIM 0 \"register_operand\" \"=r\")\n+\t(mima_oprnd:CRXIM (match_operand:CRXIM 1 \"register_operand\"  \"%0\")\n+\t\t\t  (match_operand:CRXIM 2 \"register_operand\"  \"r\")))]\n+  \"\"\n+  \"<mimaIsa><tIsa>\\\\t%2, %0\"\n+  [(set_attr \"length\" \"4\")]\n+)\n+\n+;;  One's Complement\n+\n+(define_insn \"one_cmpl<mode>2\"\n+  [(set (match_operand:CRXIM 0 \"register_operand\" \"=r\")\n+\t(not:CRXIM (match_operand:CRXIM 1 \"register_operand\" \"0\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"\"\n+  \"xor<tIsa>\\\\t$-1, %0\"\n+  [(set_attr \"length\" \"2\")]\n+)\n+\n+;;  Rotate Instructions\n+\n+(define_insn \"rotl<mode>3\"\n+  [(set (match_operand:CRXIM 0 \"register_operand\" \"=r,r\")\n+\t(rotate:CRXIM (match_operand:CRXIM 1 \"register_operand\" \"0,0\")\n+\t\t      (match_operand:CRXIM 2 \"nonmemory_operand\" \"r,<IJK>\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"\"\n+  \"@\n+  rotl<tIsa>\\\\t%2, %0\n+  rot<tIsa>\\\\t%2, %0\"\n+  [(set_attr \"length\" \"4,<lImmRotl>\")]\n+)\n+\n+(define_insn \"rotr<mode>3\"\n+  [(set (match_operand:CRXIM 0 \"register_operand\" \"=r\")\n+\t(rotatert:CRXIM (match_operand:CRXIM 1 \"register_operand\" \"0\")\n+\t\t\t(match_operand:CRXIM 2 \"register_operand\" \"r\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"\"\n+  \"rotr<tIsa>\\\\t%2, %0\"\n+  [(set_attr \"length\" \"4\")]\n+)\n+\n+;;  Arithmetic Left and Right Shift Instructions\n+\n+(define_insn \"<shPat><mode>3\"\n+  [(set (match_operand:CRXIM 0 \"register_operand\" \"=r,r\")\n+\t(sh_oprnd:CRXIM (match_operand:CRXIM 1 \"register_operand\" \"0,0\")\n+\t\t\t(match_operand:QI 2 \"nonmemory_operand\" \"r,<IJK>\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"\"\n+  \"s<shIsa><tIsa>\\\\t%2, %0\"\n+  [(set_attr \"length\" \"2,2\")]\n+)\n+\n+;;  Bit Set Instructions\n+\n+(define_insn \"extv\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(sign_extract:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t (match_operand:SI 2 \"const_int_operand\" \"n\")\n+\t\t\t (match_operand:SI 3 \"const_int_operand\" \"n\")))]\n+  \"\"\n+  {\n+    static char buf[100];\n+    int strpntr;\n+    int size = INTVAL (operands[2]);\n+    int pos = INTVAL (operands[3]);\n+    strpntr = sprintf (buf, \"ram\\t$%d, $31, $%d, %%1, %%0\\;\",\n+\t      BITS_PER_WORD - (size + pos), BITS_PER_WORD - size);\n+    sprintf (buf + strpntr, \"srad\\t$%d, %%0\", BITS_PER_WORD - size);\n+    return buf;\n+  }\n+  [(set_attr \"length\" \"6\")]\n+)\n+\n+(define_insn \"extzv\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t (match_operand:SI 2 \"const_int_operand\" \"n\")\n+\t\t\t (match_operand:SI 3 \"const_int_operand\" \"n\")))]\n+  \"\"\n+  {\n+    static char buf[40];\n+    int size = INTVAL (operands[2]);\n+    int pos = INTVAL (operands[3]);\n+    sprintf (buf, \"ram\\t$%d, $%d, $0, %%1, %%0\",\n+\t   (BITS_PER_WORD - pos) % BITS_PER_WORD, size - 1);\n+    return buf;\n+  }\n+  [(set_attr \"length\" \"4\")]\n+)\n+\n+(define_insn \"insv\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"+r\")\n+\t\t\t (match_operand:SI 1 \"const_int_operand\" \"n\")\n+\t\t\t (match_operand:SI 2 \"const_int_operand\" \"n\"))\n+\t(match_operand:SI 3 \"register_operand\" \"r\"))]\n+  \"\"\n+  {\n+    static char buf[40];\n+    int size = INTVAL (operands[1]);\n+    int pos = INTVAL (operands[2]);\n+    sprintf (buf, \"rim\\t$%d, $%d, $%d, %%3, %%0\",\n+\t    pos, size + pos - 1, pos);\n+    return buf;\n+  }\n+  [(set_attr \"length\" \"4\")]\n+)\n+\n+;;  Move Instructions\n+\n+(define_expand \"mov<mode>\"\n+  [(set (match_operand:ALLMT 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:ALLMT 1 \"general_operand\" \"\"))]\n+  \"\"\n+  {\n+    if (!(reload_in_progress || reload_completed))\n+      {\n+\tif (!register_operand (operands[0], <MODE>mode))\n+\t  {\n+\t    if (push_operand (operands[0], <MODE>mode) ?\n+\t\t!nosp_reg_operand (operands[1], <MODE>mode) :\n+\t\t!reg_or_u4bits_operand (operands[1], <MODE>mode))\n+\t      {\n+\t\toperands[1] = copy_to_mode_reg (<MODE>mode, operands[1]);\n+\t      }\n+\t  }\n+      }\n+  }\n+)\n+\n+(define_insn \"push<mode>_internal\"\n+  [(set (match_operand:ALLMT 0 \"push_operand\" \"=<pushCnstr>\")\n+\t(match_operand:ALLMT 1 \"nosp_reg_operand\" \"b\"))]\n+  \"\"\n+  \"push\\t<tpush>%p1\"\n+  [(set_attr \"length\" \"<lpush>\")]\n+)\n+\n+(define_insn \"mov<mode>_regs\"\n+  [(set (match_operand:SISFM 0 \"register_operand\" \"=r, r, r, k\")\n+\t(match_operand:SISFM 1 \"nonmemory_operand\" \"r, <iF>, k, r\"))]\n+  \"\"\n+  \"@\n+  movd\\\\t%1, %0\n+  movd\\\\t%1, %0\n+  mfpr\\\\t%1, %0\n+  mtpr\\\\t%1, %0\"\n+  [(set_attr \"length\" \"2,6,4,4\")]\n+)\n+\n+(define_insn \"mov<mode>_regs\"\n+  [(set (match_operand:DIDFM 0 \"register_operand\" \"=r, r, r, k\")\n+\t(match_operand:DIDFM 1 \"nonmemory_operand\" \"r, <iF>, k, r\"))]\n+  \"\"\n+  {\n+    switch (which_alternative)\n+      {\n+      case 0: if (REGNO (operands[0]) > REGNO (operands[1]))\n+\t        return \"movd\\t%H1, %H0\\;movd\\t%L1, %L0\";\n+\t      else\n+\t        return \"movd\\t%L1, %L0\\;movd\\t%H1, %H0\";\n+      case 1: return \"movd\\t%H1, %H0\\;movd\\t%L1, %L0\";\n+      case 2: return \"mfpr\\t%H1, %H0\\;mfpr\\t%L1, %L0\";\n+      case 3: return \"mtpr\\t%H1, %H0\\;mtpr\\t%L1, %L0\";\n+      default: gcc_unreachable ();\n+      }\n+  }\n+  [(set_attr \"length\" \"4,12,8,8\")]\n+)\n+\n+(define_insn \"mov<mode>_regs\" ; no HI/QI mode in HILO regs\n+  [(set (match_operand:SHORT 0 \"register_operand\" \"=r, r\")\n+\t(match_operand:SHORT 1 \"nonmemory_operand\" \"r, i\"))]\n+  \"\"\n+  \"mov<tIsa>\\\\t%1, %0\"\n+  [(set_attr \"length\" \"2,<lImmArith>\")]\n+)\n+\n+(define_insn \"mov<mode>_load\"\n+  [(set (match_operand:CRXMM 0 \"register_operand\" \"=r\")\n+\t(match_operand:CRXMM 1 \"memory_operand\" \"m\"))]\n+  \"\"\n+  \"load<tIsa>\\\\t%1, %0\"\n+  [(set_attr \"length\" \"6\")]\n+)\n+\n+(define_insn \"mov<mode>_load\"\n+  [(set (match_operand:DIDFM 0 \"register_operand\" \"=r\")\n+\t(match_operand:DIDFM 1 \"memory_operand\" \"m\"))]\n+  \"\"\n+  {\n+    rtx first_dest_reg = gen_rtx_REG (SImode, REGNO (operands[0]));\n+    if (reg_overlap_mentioned_p (first_dest_reg, operands[1]))\n+      return \"loadd\\t%H1, %H0\\;loadd\\t%L1, %L0\";\n+    return \"loadd\\t%L1, %L0\\;loadd\\t%H1, %H0\";\n+  }\n+  [(set_attr \"length\" \"12\")]\n+)\n+\n+(define_insn \"mov<mode>_store\"\n+  [(set (match_operand:CRXMM 0 \"store_operand\" \"=m, m\")\n+\t(match_operand:CRXMM 1 \"reg_or_u4bits_operand\" \"r, <JG>\"))]\n+  \"\"\n+  \"stor<tIsa>\\\\t%1, %0\"\n+  [(set_attr \"length\" \"6\")]\n+)\n+\n+(define_insn \"mov<mode>_store\"\n+  [(set (match_operand:DIDFM 0 \"store_operand\" \"=m, m\")\n+\t(match_operand:DIDFM 1 \"reg_or_u4bits_operand\" \"r, <JG>\"))]\n+  \"\"\n+  \"stord\\t%H1, %H0\\;stord\\t%L1, %L0\"\n+  [(set_attr \"length\" \"12\")]\n+)\n+\n+;;  Movmem Instruction\n+\n+(define_expand \"movmemsi\"\n+  [(use (match_operand:BLK 0 \"memory_operand\" \"\"))\n+   (use (match_operand:BLK 1 \"memory_operand\" \"\"))\n+   (use (match_operand:SI 2 \"nonmemory_operand\" \"\"))\n+   (use (match_operand:SI 3 \"const_int_operand\" \"\"))]\n+  \"\"\n+  {\n+    if (crx_expand_movmem (operands[0], operands[1], operands[2], operands[3]))\n+      DONE;\n+    else\n+      FAIL;\n+  }\n+)\n+\n+;;  Compare and Branch Instructions\n+\n+(define_insn \"cbranch<mode>4\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t\t[(match_operand:CRXIM 1 \"register_operand\" \"r\")\n+\t\t\t (match_operand:CRXIM 2 \"reg_or_cst4_operand\" \"rL\")])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"cmpb%d0<tIsa>\\\\t%2, %1, %l3\"\n+  [(set_attr \"length\" \"6\")]\n+)\n+\n+;;  Compare Instructions\n+\n+(define_expand \"cmp<mode>\"\n+  [(set (reg:CC CC_REGNUM)\n+\t(compare:CC (match_operand:CRXIM 0 \"register_operand\" \"\")\n+\t\t    (match_operand:CRXIM 1 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  {\n+    crx_compare_op0 = operands[0];\n+    crx_compare_op1 = operands[1];\n+    DONE;\n+  }\n+)\n+\n+(define_insn \"cmp<mode>_internal\"\n+  [(set (reg:CC CC_REGNUM)\n+\t(compare:CC (match_operand:CRXIM 0 \"register_operand\" \"r,r\")\n+\t\t    (match_operand:CRXIM 1 \"nonmemory_operand\" \"r,i\")))]\n+  \"\"\n+  \"cmp<tIsa>\\\\t%1, %0\"\n+  [(set_attr \"length\" \"2,<lImmArith>\")]\n+)\n+\n+;;  Conditional Branch Instructions\n+\n+(define_expand \"b<code>\"\n+  [(set (pc)\n+\t(if_then_else (any_cond (reg:CC CC_REGNUM)\n+\t\t\t\t(const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  {\n+    crx_expand_branch (<CODE>, operands[0]);\n+    DONE;\n+  }\n+)\n+\n+(define_insn \"bCOND_internal\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t\t[(reg:CC CC_REGNUM)\n+\t\t\t (const_int 0)])\n+\t\t      (label_ref (match_operand 1 \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"b%d0\\\\t%l1\"\n+  [(set_attr \"length\" \"6\")]\n+)\n+\n+;;  Scond Instructions\n+\n+(define_expand \"s<code>\"\n+  [(set (match_operand:SI 0 \"register_operand\")\n+  \t(any_cond:SI (reg:CC CC_REGNUM) (const_int 0)))]\n+  \"\"\n+  {\n+    crx_expand_scond (<CODE>, operands[0]);\n+    DONE;\n+  }\n+)\n+\n+(define_insn \"sCOND_internal\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_operator:SI 1 \"comparison_operator\"\n+\t  [(reg:CC CC_REGNUM) (const_int 0)]))]\n+  \"\"\n+  \"s%d1\\\\t%0\"\n+  [(set_attr \"length\" \"2\")]\n+)\n+\n+;;  Jumps and Branches\n+\n+(define_insn \"indirect_jump_return\"\n+  [(parallel\n+    [(set (pc)\n+\t  (reg:SI RA_REGNUM))\n+     (return)])\n+  ]\n+  \"reload_completed\"\n+  \"jump\\\\tra\"\n+  [(set_attr \"length\" \"2\")]\n+)\n+\n+(define_insn \"indirect_jump\"\n+  [(set (pc)\n+\t(match_operand:SI 0 \"reg_or_sym_operand\" \"r,i\"))]\n+  \"\"\n+  \"@\n+  jump\\\\t%0\n+  br\\\\t%a0\"\n+  [(set_attr \"length\" \"2,6\")]\n+)\n+\n+(define_insn \"interrupt_return\"\n+  [(parallel\n+    [(unspec_volatile [(const_int 0)] 0)\n+     (return)])]\n+  \"\"\n+  {\n+    return crx_prepare_push_pop_string (1);\n+  }\n+  [(set_attr \"length\" \"14\")]\n+)\n+\n+(define_insn \"jump_to_imm\"\n+  [(set (pc)\n+\t(match_operand 0 \"immediate_operand\" \"i\"))]\n+  \"\"\n+  \"br\\\\t%c0\"\n+  [(set_attr \"length\" \"6\")]\n+)\n+\n+(define_insn \"jump\"\n+  [(set (pc)\n+\t(label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"br\\\\t%l0\"\n+  [(set_attr \"length\" \"6\")]\n+)\n+\n+;;  Function Prologue and Epilogue\n+\n+(define_expand \"prologue\"\n+  [(const_int 0)]\n+  \"\"\n+  {\n+    crx_expand_prologue ();\n+    DONE;\n+  }\n+)\n+\n+(define_insn \"push_for_prologue\"\n+  [(parallel\n+    [(set (reg:SI SP_REGNUM)\n+\t  (minus:SI (reg:SI SP_REGNUM)\n+\t\t    (match_operand:SI 0 \"immediate_operand\" \"i\")))])]\n+  \"reload_completed\"\n+  {\n+    return crx_prepare_push_pop_string (0);\n+  }\n+  [(set_attr \"length\" \"4\")]\n+)\n+\n+(define_expand \"epilogue\"\n+  [(return)]\n+  \"\"\n+  {\n+    crx_expand_epilogue ();\n+    DONE;\n+  }\n+)\n+\n+(define_insn \"pop_and_popret_return\"\n+  [(parallel\n+    [(set (reg:SI SP_REGNUM)\n+\t  (plus:SI (reg:SI SP_REGNUM)\n+\t\t   (match_operand:SI 0 \"immediate_operand\" \"i\")))\n+     (use (reg:SI RA_REGNUM))\n+     (return)])\n+  ]\n+  \"reload_completed\"\n+  {\n+    return crx_prepare_push_pop_string (1);\n+  }\n+  [(set_attr \"length\" \"4\")]\n+)\n+\n+(define_insn \"popret_RA_return\"\n+  [(parallel\n+    [(use (reg:SI RA_REGNUM))\n+     (return)])\n+  ]\n+  \"reload_completed\"\n+  \"popret\\\\tra\"\n+  [(set_attr \"length\" \"2\")]\n+)\n+\n+;;  Table Jump\n+\n+(define_insn \"tablejump\"\n+  [(set (pc)\n+\t(match_operand:SI 0 \"register_operand\" \"r\"))\n+\t(use (label_ref:SI (match_operand 1 \"\" \"\" )))]\n+  \"\"\n+  \"jump\\\\t%0\"\n+  [(set_attr \"length\" \"2\")]\n+)\n+\n+;;  Call Instructions\n+\n+(define_expand \"call\"\n+  [(call (match_operand:QI 0 \"memory_operand\" \"\")\n+\t (match_operand 1 \"\" \"\"))]\n+  \"\"\n+  {\n+    emit_call_insn (gen_crx_call (operands[0], operands[1]));\n+    DONE;\n+  }\n+)\n+\n+(define_expand \"crx_call\"\n+  [(parallel\n+    [(call (match_operand:QI 0 \"memory_operand\" \"\")\n+\t   (match_operand 1 \"\" \"\"))\n+     (clobber (reg:SI RA_REGNUM))])]\n+  \"\"\n+  \"\"\n+)\n+\n+(define_insn \"crx_call_insn_branch\"\n+  [(call (mem:QI (match_operand:SI 0 \"immediate_operand\" \"i\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"+r\"))]\n+  \"\"\n+  \"bal\\\\tra, %a0\"\n+  [(set_attr \"length\" \"6\")]\n+)\n+\n+(define_insn \"crx_call_insn_jump\"\n+  [(call (mem:QI (match_operand:SI 0 \"register_operand\" \"r\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"+r\"))]\n+  \"\"\n+  \"jal\\\\t%0\"\n+  [(set_attr \"length\" \"2\")]\n+)\n+\n+(define_insn \"crx_call_insn_jalid\"\n+  [(call (mem:QI (mem:SI (plus:SI\n+\t\t\t   (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t   (match_operand:SI 1 \"register_operand\" \"r\"))))\n+\t (match_operand 2 \"\" \"\"))\n+   (clobber (match_operand:SI 3 \"register_operand\" \"+r\"))]\n+  \"\"\n+  \"jalid\\\\t%0, %1\"\n+  [(set_attr \"length\" \"4\")]\n+)\n+\n+;;  Call Value Instructions\n+\n+(define_expand \"call_value\"\n+  [(set (match_operand 0 \"general_operand\" \"\")\n+\t(call (match_operand:QI 1 \"memory_operand\" \"\")\n+\t      (match_operand 2 \"\" \"\")))]\n+  \"\"\n+  {\n+    emit_call_insn (gen_crx_call_value (operands[0], operands[1], operands[2]));\n+    DONE;\n+  }\n+)\n+\n+(define_expand \"crx_call_value\"\n+  [(parallel\n+    [(set (match_operand 0 \"general_operand\" \"\")\n+\t  (call (match_operand 1 \"memory_operand\" \"\")\n+\t\t(match_operand 2 \"\" \"\")))\n+     (clobber (reg:SI RA_REGNUM))])]\n+  \"\"\n+  \"\"\n+)\n+\n+(define_insn \"crx_call_value_insn_branch\"\n+  [(set (match_operand 0 \"\" \"=g\")\n+\t(call (mem:QI (match_operand:SI 1 \"immediate_operand\" \"i\"))\n+\t      (match_operand 2 \"\" \"\")))\n+   (clobber (match_operand:SI 3 \"register_operand\" \"+r\"))]\n+  \"\"\n+  \"bal\\\\tra, %a1\"\n+  [(set_attr \"length\" \"6\")]\n+)\n+\n+(define_insn \"crx_call_value_insn_jump\"\n+  [(set (match_operand 0 \"\" \"=g\")\n+\t(call (mem:QI (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t      (match_operand 2 \"\" \"\")))\n+   (clobber (match_operand:SI 3 \"register_operand\" \"+r\"))]\n+  \"\"\n+  \"jal\\\\t%1\"\n+  [(set_attr \"length\" \"2\")]\n+)\n+\n+(define_insn \"crx_call_value_insn_jalid\"\n+  [(set (match_operand 0 \"\" \"=g\")\n+\t(call (mem:QI (mem:SI (plus:SI\n+\t\t\t\t(match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t\t(match_operand:SI 2 \"register_operand\" \"r\"))))\n+\t      (match_operand 3 \"\" \"\")))\n+   (clobber (match_operand:SI 4 \"register_operand\" \"+r\"))]\n+  \"\"\n+  \"jalid\\\\t%0, %1\"\n+  [(set_attr \"length\" \"4\")]\n+)\n+\n+;;  Nop\n+\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"\"\n+)\n+\n+;;  Multiply and Accumulate Instructions\n+\n+(define_insn \"<sPat>madsidi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"+k\")\n+\t(plus:DI\n+\t  (mult:DI (sz_xtnd:DI (match_operand:SI 1 \"register_operand\" \"%r\"))\n+\t\t   (sz_xtnd:DI (match_operand:SI 2 \"register_operand\" \"r\")))\n+\t  (match_dup 0)))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"TARGET_MAC\"\n+  \"mac<sPat>d\\\\t%2, %1\"\n+  [(set_attr \"length\" \"4\")]\n+)\n+\n+(define_insn \"<sPat>madhisi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"+l\")\n+\t(plus:SI\n+\t  (mult:SI (sz_xtnd:SI (match_operand:HI 1 \"register_operand\" \"%r\"))\n+\t\t   (sz_xtnd:SI (match_operand:HI 2 \"register_operand\" \"r\")))\n+\t  (match_dup 0)))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"TARGET_MAC\"\n+  \"mac<sPat>w\\\\t%2, %1\"\n+  [(set_attr \"length\" \"4\")]\n+)\n+\n+(define_insn \"<sPat>madqihi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"+l\")\n+\t(plus:HI\n+\t  (mult:HI (sz_xtnd:HI (match_operand:QI 1 \"register_operand\" \"%r\"))\n+\t\t   (sz_xtnd:HI (match_operand:QI 2 \"register_operand\" \"r\")))\n+\t  (match_dup 0)))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"TARGET_MAC\"\n+  \"mac<sPat>b\\\\t%2, %1\"\n+  [(set_attr \"length\" \"4\")]\n+)\n+\n+;;  Loop Instructions\n+\n+(define_expand \"doloop_end\"\n+  [(use (match_operand 0 \"\" \"\"))\t; loop pseudo\n+   (use (match_operand 1 \"\" \"\"))\t; iterations; zero if unknown\n+   (use (match_operand 2 \"\" \"\"))\t; max iterations\n+   (use (match_operand 3 \"\" \"\"))\t; loop level\n+   (use (match_operand 4 \"\" \"\"))]       ; label\n+  \"\"\n+  {\n+    switch (GET_MODE (operands[0]))\n+      {\n+      case SImode:\n+\temit_jump_insn (gen_doloop_end_si (operands[4], operands[0], operands[0]));\n+\tbreak;\n+      case HImode:\n+\temit_jump_insn (gen_doloop_end_hi (operands[4], operands[0], operands[0]));\n+\tbreak;\n+      case QImode:\n+\temit_jump_insn (gen_doloop_end_qi (operands[4], operands[0], operands[0]));\n+\tbreak;\n+      default:\n+\tFAIL;\n+      }\n+    DONE;\n+  }\n+)\n+\n+(define_insn \"doloop_end_<mode>\"\n+  [(set (pc)\n+\t(if_then_else (ne (match_operand:CRXIM 1 \"register_operand\" \"r,m\")\n+\t\t\t  (const_int 1))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))\n+   (set (match_operand:CRXIM 2 \"register_operand\" \"=r,m\") (plus:CRXIM (match_dup 1) (const_int -1)))\n+   (clobber (match_scratch:CRXIM 3 \"=X,r\"))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"\"\n+  \"@\n+  dbnz<tIsa>\\\\t%1, %l0\n+  load<tIsa>\\\\t%1, %3\\;add<tIsa>\\\\t$-1, %3\\;stor<tIsa>\\\\t%3, %1\\;bne\\\\t%l0\"\n+  [(set_attr \"length\" \"6, 12\")]\n+)"}, {"sha": "9abd3c4bff26066dbdc7feab7567914d492dffc6", "filename": "gcc/config/crx/crx.opt", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db8697336fbb1f6665adbfa24a72a4dbbd549398/gcc%2Fconfig%2Fcrx%2Fcrx.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db8697336fbb1f6665adbfa24a72a4dbbd549398/gcc%2Fconfig%2Fcrx%2Fcrx.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcrx%2Fcrx.opt?ref=db8697336fbb1f6665adbfa24a72a4dbbd549398", "patch": "@@ -0,0 +1,28 @@\n+; Options for the National Semiconductor CRX port of the compiler.\n+\n+; Copyright (C) 2005 Free Software Foundation, Inc.\n+;\n+; This file is part of GCC.\n+;\n+; GCC is free software; you can redistribute it and/or modify it under\n+; the terms of the GNU General Public License as published by the Free\n+; Software Foundation; either version 2, or (at your option) any later\n+; version.\n+;\n+; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+; for more details.\n+;\n+; You should have received a copy of the GNU General Public License\n+; along with GCC; see the file COPYING.  If not, write to the Free\n+; Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+; 02110-1301, USA.\n+\n+mmac\n+Target Report Mask(MAC)\n+Support multiply accumulate instructions\n+\n+mno-push-args\n+Target Report RejectNegative Mask(NO_PUSH_ARGS)\n+Do not use push to store function arguments"}, {"sha": "012fad173e5f65edb7bbb046753f22fdcc48e2c4", "filename": "gcc/config/crx/t-crx", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db8697336fbb1f6665adbfa24a72a4dbbd549398/gcc%2Fconfig%2Fcrx%2Ft-crx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db8697336fbb1f6665adbfa24a72a4dbbd549398/gcc%2Fconfig%2Fcrx%2Ft-crx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcrx%2Ft-crx?ref=db8697336fbb1f6665adbfa24a72a4dbbd549398", "patch": "@@ -0,0 +1,19 @@\n+# CRX Target Makefile\n+\n+# Mingw specific compilation fixes\n+USE_COLLECT2 =\n+STMP_FIXINC =\n+\n+# Software emulation for integer div and mod\n+LIB2FUNCS_EXTRA = $(srcdir)/config/udivmodsi4.c $(srcdir)/config/udivmod.c $(srcdir)/config/divmod.c\n+\n+# Build the floating point emulation libraries.\n+FPBIT = fp-bit.c\n+DPBIT = dp-bit.c\n+\n+fp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#define FLOAT' > fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n+\n+dp-bit.c: $(srcdir)/config/fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c > dp-bit.c"}]}