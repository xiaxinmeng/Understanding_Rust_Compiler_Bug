{"sha": "b088d47cdc1514d5f92801481cbb412d1e01aeeb", "node_id": "C_kwDOANBUbNoAKGIwODhkNDdjZGMxNTE0ZDVmOTI4MDE0ODFjYmI0MTJkMWUwMWFlZWI", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-05-05T13:18:08Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-05-05T14:25:30Z"}, "message": "util: Add Optional<T> wrapper class\n\nThe class provides an easy to use alternative to raw pointers or member\n+ bool pairs. It should be easy to extend and improve upon.", "tree": {"sha": "b3898bf22b24c3dad7e45a633619efab247fed5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b3898bf22b24c3dad7e45a633619efab247fed5d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b088d47cdc1514d5f92801481cbb412d1e01aeeb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b088d47cdc1514d5f92801481cbb412d1e01aeeb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b088d47cdc1514d5f92801481cbb412d1e01aeeb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b088d47cdc1514d5f92801481cbb412d1e01aeeb/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6f5bc6054520f0dc8479215dc1204196ae7767f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6f5bc6054520f0dc8479215dc1204196ae7767f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6f5bc6054520f0dc8479215dc1204196ae7767f"}], "stats": {"total": 254, "additions": 250, "deletions": 4}, "files": [{"sha": "89ab0c8e1bd7d32cda2a67571d8a7d703534b78e", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b088d47cdc1514d5f92801481cbb412d1e01aeeb/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b088d47cdc1514d5f92801481cbb412d1e01aeeb/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=b088d47cdc1514d5f92801481cbb412d1e01aeeb", "patch": "@@ -289,7 +289,8 @@ RUST_INCLUDES = -I $(srcdir)/rust \\\n \t-I $(srcdir)/rust/util \\\n \t-I $(srcdir)/rust/typecheck \\\n \t-I $(srcdir)/rust/privacy \\\n-\t-I $(srcdir)/rust/lint\n+\t-I $(srcdir)/rust/lint \\\n+\t-I $(srcdir)/rust/util\n \n # add files that require cross-folder includes - currently rust-lang.o, rust-lex.o\n CFLAGS-rust/rust-lang.o += $(RUST_INCLUDES)"}, {"sha": "f74c66125b86816ac5183f4af9c33ecaf6f9837e", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b088d47cdc1514d5f92801481cbb412d1e01aeeb/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b088d47cdc1514d5f92801481cbb412d1e01aeeb/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=b088d47cdc1514d5f92801481cbb412d1e01aeeb", "patch": "@@ -22,7 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #define INCLUDE_ALGORITHM\n #include \"rust-diagnostics.h\"\n-#include \"util/rust-make-unique.h\"\n+#include \"rust-make-unique.h\"\n \n namespace Rust {\n // Left binding powers of operations."}, {"sha": "dd8c608789a5908dc83074a446d959394e0d665d", "filename": "gcc/rust/rust-lang.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b088d47cdc1514d5f92801481cbb412d1e01aeeb/gcc%2Frust%2Frust-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b088d47cdc1514d5f92801481cbb412d1e01aeeb/gcc%2Frust%2Frust-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-lang.cc?ref=b088d47cdc1514d5f92801481cbb412d1e01aeeb", "patch": "@@ -37,6 +37,7 @@\n #include \"rust-cfg-parser.h\"\n #include \"rust-privacy-ctx.h\"\n #include \"rust-ast-resolve-item.h\"\n+#include \"rust-optional.h\"\n \n #include <mpfr.h>\n // note: header files must be in this order or else forward declarations don't\n@@ -461,6 +462,7 @@ run_rust_tests ()\n   rust_privacy_ctx_test ();\n   rust_crate_name_validation_test ();\n   rust_simple_path_resolve_test ();\n+  rust_optional_test ();\n }\n } // namespace selftest\n "}, {"sha": "f33f9125f8907dbd03b2615d90fd5c3204c5a564", "filename": "gcc/rust/util/rust-make-unique.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b088d47cdc1514d5f92801481cbb412d1e01aeeb/gcc%2Frust%2Futil%2Frust-make-unique.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b088d47cdc1514d5f92801481cbb412d1e01aeeb/gcc%2Frust%2Futil%2Frust-make-unique.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-make-unique.h?ref=b088d47cdc1514d5f92801481cbb412d1e01aeeb", "patch": "@@ -24,8 +24,10 @@\n namespace Rust {\n \n template <typename T, typename... Ts>\n-std::unique_ptr<T> make_unique(Ts &&...params) {\n-  return std::unique_ptr<T>(new T(std::forward<Ts>(params)...));\n+std::unique_ptr<T>\n+make_unique (Ts &&... params)\n+{\n+  return std::unique_ptr<T> (new T (std::forward<Ts> (params)...));\n }\n \n } // namespace Rust"}, {"sha": "c1b547a29d68cf6447ac3cd1759c0825c60df227", "filename": "gcc/rust/util/rust-optional.h", "status": "added", "additions": 241, "deletions": 0, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b088d47cdc1514d5f92801481cbb412d1e01aeeb/gcc%2Frust%2Futil%2Frust-optional.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b088d47cdc1514d5f92801481cbb412d1e01aeeb/gcc%2Frust%2Futil%2Frust-optional.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-optional.h?ref=b088d47cdc1514d5f92801481cbb412d1e01aeeb", "patch": "@@ -0,0 +1,241 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_OPTIONAL_H\n+#define RUST_OPTIONAL_H\n+\n+#include \"config.h\"\n+#include \"rust-system.h\"\n+\n+#include \"selftest.h\"\n+\n+namespace Rust {\n+\n+/**\n+ * Tagged union to try and simulate a sum type. This is safer and more ergonomic\n+ * than one of the two alternatives we're currently using in the compiler:\n+ *\n+ * 1. Storing a raw pointer, which can be `nullptr` or valid\n+ *\n+ * This is wildly unsafe, and usable in conjunction with local references, stack\n+ * variables, or pointers managed elsewhere, which can cause crashes, hard to\n+ * debug issues or undefined behavior. Likewise, if you do not check for the\n+ * pointer's validity, this will cause a crash.\n+ *\n+ * 2. Storing an extra boolean alongside the object\n+ *\n+ * This causes implementors to use a \"dummy object\": Either an empty version or\n+ * an error version. But what happens if what you really wanted to store was\n+ * the empty or error version? You can also easily incorporate logic bugs if you\n+ * forget to check for the associated boolean.\n+ *\n+ * The `Optional<T>` type has the same \"ergonomic\" cost: You need to check\n+ * whether your option is valid or not. However, the main advantage is that it\n+ * is more restrictive: You can only acess the member it contains \"safely\".\n+ * It is similar to storing a value + an associated boolean, but has the\n+ * advantage of making up only one member in your class.\n+ * You also benefit from some helper methods such as `map()`.\n+ *\n+ * You also get helper functions and operator overloading to \"seamlessly\"\n+ * replace raw pointer alternatives.\n+ *\n+ * ```c++\n+ * MyType *raw_pointer = something_that_can_fail();\n+ * if (raw_pointer)\n+ *     raw_pointer->method();\n+ *\n+ * // or\n+ *\n+ * Optional<MyType> opt = something_that_can_fail2();\n+ * if (opt)\n+ *     opt->method();\n+ *\n+ * // equivalent to\n+ *\n+ * if (opt.is_some())\n+ *     opt.get().method();\n+ * ```\n+ */\n+template <typename T> class Optional\n+{\n+private:\n+  struct Empty\n+  {\n+  };\n+\n+  enum Kind\n+  {\n+    Some,\n+    None\n+  } kind;\n+\n+  union Content\n+  {\n+    Empty empty;\n+    T value;\n+\n+    Content () = default;\n+  } content;\n+\n+  Optional<T> (Kind kind, Content content) : kind (kind), content (content) {}\n+\n+public:\n+  Optional (const Optional &other) = default;\n+  Optional (Optional &&other) = default;\n+\n+  static Optional<T> some (T value)\n+  {\n+    Content content;\n+    content.value = value;\n+\n+    return Optional (Kind::Some, content);\n+  }\n+\n+  static Optional<T> none ()\n+  {\n+    Content content;\n+    content.empty = Empty ();\n+\n+    return Optional (Kind::None, content);\n+  }\n+\n+  bool is_some () const { return kind == Kind::Some; }\n+  bool is_none () const { return !is_some (); }\n+\n+  /**\n+   * Enable boolean-like comparisons.\n+   */\n+  operator bool () { return is_some (); }\n+\n+  /**\n+   * Enables dereferencing to access the contained value\n+   */\n+  T &operator* () { return get (); }\n+  const T &operator* () const { return get (); }\n+  T *operator-> () { return &get (); }\n+  const T *operator-> () const { return &get (); }\n+\n+  const T &get () const\n+  {\n+    rust_assert (is_some ());\n+\n+    return content.value;\n+  }\n+\n+  T &get ()\n+  {\n+    rust_assert (is_some ());\n+\n+    return content.value;\n+  }\n+\n+  T take ()\n+  {\n+    rust_assert (is_some ());\n+\n+    auto to_return = std::move (content.value);\n+\n+    content.empty = Empty ();\n+    kind = Kind::None;\n+\n+    return to_return;\n+  }\n+\n+  template <typename U> Optional<U> map (std::function<U (T)> functor)\n+  {\n+    if (is_none ())\n+      return Optional::none ();\n+\n+    auto value = functor (take ());\n+\n+    return Optional::some (value);\n+  }\n+};\n+\n+} // namespace Rust\n+\n+#ifdef CHECKING_P\n+\n+static void\n+rust_optional_create ()\n+{\n+  auto opt = Rust::Optional<int>::some (15);\n+\n+  ASSERT_TRUE (opt.is_some ());\n+  ASSERT_EQ (opt.get (), 15);\n+\n+  Rust::Optional<int> const_opt = Rust::Optional<int>::some (15);\n+  const int &value = const_opt.get ();\n+\n+  ASSERT_EQ (value, 15);\n+}\n+\n+static void\n+rust_optional_operators ()\n+{\n+  auto opt = Rust::Optional<int>::some (15);\n+\n+  // as bool\n+  ASSERT_TRUE (opt);\n+\n+  // deref\n+  ASSERT_EQ (*opt, 15);\n+\n+  class Methodable\n+  {\n+  public:\n+    int method () { return 15; }\n+  };\n+\n+  auto m_opt = Rust::Optional<Methodable>::some (Methodable ());\n+  ASSERT_EQ (m_opt->method (), 15);\n+}\n+\n+static void\n+rust_optional_take ()\n+{\n+  auto opt = Rust::Optional<int>::some (15);\n+  auto value = opt.take ();\n+\n+  ASSERT_EQ (value, 15);\n+  ASSERT_TRUE (opt.is_none ());\n+}\n+\n+static void\n+rust_optional_map ()\n+{\n+  auto opt = Rust::Optional<int>::some (15);\n+  auto twice = opt.map<int> ([] (int value) { return value * 2; });\n+\n+  ASSERT_FALSE (opt);\n+  ASSERT_TRUE (twice);\n+  ASSERT_EQ (*twice, 30);\n+}\n+\n+static void\n+rust_optional_test ()\n+{\n+  rust_optional_create ();\n+  rust_optional_operators ();\n+  rust_optional_take ();\n+  rust_optional_map ();\n+}\n+\n+#endif // !CHECKING_P\n+\n+#endif // !RUST_OPTIONAL_H"}]}