{"sha": "b41d1f6ed753bf7ae7e68f745e50c26ee65b5711", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQxZDFmNmVkNzUzYmY3YWU3ZTY4Zjc0NWU1MGMyNmVlNjViNTcxMQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-07-12T13:01:33Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-07-12T13:01:33Z"}, "message": "Add IFN_COND_FMA functions\n\nThis patch adds conditional equivalents of the IFN_FMA built-in functions.\nMost of it is just a mechanical extension of the binary stuff.\n\n2018-07-12  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* doc/md.texi (cond_fma, cond_fms, cond_fnma, cond_fnms): Document.\n\t* optabs.def (cond_fma_optab, cond_fms_optab, cond_fnma_optab)\n\t(cond_fnms_optab): New optabs.\n\t* internal-fn.def (COND_FMA, COND_FMS, COND_FNMA, COND_FNMS): New\n\tinternal functions.\n\t(FMA): Use DEF_INTERNAL_FLT_FN rather than DEF_INTERNAL_FLT_FLOATN_FN.\n\t* internal-fn.h (get_conditional_internal_fn): Declare.\n\t(get_unconditional_internal_fn): Likewise.\n\t* internal-fn.c (cond_ternary_direct): New macro.\n\t(expand_cond_ternary_optab_fn): Likewise.\n\t(direct_cond_ternary_optab_supported_p): Likewise.\n\t(FOR_EACH_COND_FN_PAIR): Likewise.\n\t(get_conditional_internal_fn): New function.\n\t(get_unconditional_internal_fn): Likewise.\n\t* gimple-match.h (gimple_match_op::MAX_NUM_OPS): Bump to 5.\n\t(gimple_match_op::gimple_match_op): Add a new overload for 5\n\toperands.\n\t(gimple_match_op::set_op): Likewise.\n\t(gimple_resimplify5): Declare.\n\t* genmatch.c (decision_tree::gen): Generate simplifications for\n\t5 operands.\n\t* gimple-match-head.c (gimple_simplify): Define an overload for\n\t5 operands.  Handle calls with 5 arguments in the top-level overload.\n\t(convert_conditional_op): Handle conversions from unconditional\n\tinternal functions to conditional ones.\n\t(gimple_resimplify5): New function.\n\t(build_call_internal): Pass a fifth operand.\n\t(maybe_push_res_to_seq): Likewise.\n\t(try_conditional_simplification): Try converting conditional\n\tinternal functions to unconditional internal functions.\n\tHandle 3-operand unconditional forms.\n\t* match.pd (UNCOND_TERNARY, COND_TERNARY): Operator lists.\n\tDefine ternary equivalents of the current rules for binary conditional\n\tinternal functions.\n\t* config/aarch64/aarch64.c (aarch64_preferred_else_value): Handle\n\tternary operations.\n\t* config/aarch64/iterators.md (UNSPEC_COND_FMLA, UNSPEC_COND_FMLS)\n\t(UNSPEC_COND_FNMLA, UNSPEC_COND_FNMLS): New unspecs.\n\t(optab): Handle them.\n\t(SVE_COND_FP_TERNARY): New int iterator.\n\t(sve_fmla_op, sve_fmad_op): New int attributes.\n\t* config/aarch64/aarch64-sve.md (cond_<optab><mode>)\n\t(*cond_<optab><mode>_2, *cond_<optab><mode_4)\n\t(*cond_<optab><mode>_any): New SVE_COND_FP_TERNARY patterns.\n\ngcc/testsuite/\n\t* gcc.dg/vect/vect-cond-arith-3.c: New test.\n\t* gcc.target/aarch64/sve/vcond_13.c: Likewise.\n\t* gcc.target/aarch64/sve/vcond_13_run.c: Likewise.\n\t* gcc.target/aarch64/sve/vcond_14.c: Likewise.\n\t* gcc.target/aarch64/sve/vcond_14_run.c: Likewise.\n\t* gcc.target/aarch64/sve/vcond_15.c: Likewise.\n\t* gcc.target/aarch64/sve/vcond_15_run.c: Likewise.\n\t* gcc.target/aarch64/sve/vcond_16.c: Likewise.\n\t* gcc.target/aarch64/sve/vcond_16_run.c: Likewise.\n\nFrom-SVN: r262587", "tree": {"sha": "ebae427289293f6e3740a7445a2efd490b062588", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ebae427289293f6e3740a7445a2efd490b062588"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/comments", "author": null, "committer": null, "parents": [{"sha": "6a86928d9882c17b7526d657a38cb314fa0aaba6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a86928d9882c17b7526d657a38cb314fa0aaba6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a86928d9882c17b7526d657a38cb314fa0aaba6"}], "stats": {"total": 856, "additions": 839, "deletions": 17}, "files": [{"sha": "a12938054c7f5d1d494a4c4645238610ea06e6cc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b41d1f6ed753bf7ae7e68f745e50c26ee65b5711", "patch": "@@ -1,3 +1,50 @@\n+2018-07-12  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* doc/md.texi (cond_fma, cond_fms, cond_fnma, cond_fnms): Document.\n+\t* optabs.def (cond_fma_optab, cond_fms_optab, cond_fnma_optab)\n+\t(cond_fnms_optab): New optabs.\n+\t* internal-fn.def (COND_FMA, COND_FMS, COND_FNMA, COND_FNMS): New\n+\tinternal functions.\n+\t(FMA): Use DEF_INTERNAL_FLT_FN rather than DEF_INTERNAL_FLT_FLOATN_FN.\n+\t* internal-fn.h (get_conditional_internal_fn): Declare.\n+\t(get_unconditional_internal_fn): Likewise.\n+\t* internal-fn.c (cond_ternary_direct): New macro.\n+\t(expand_cond_ternary_optab_fn): Likewise.\n+\t(direct_cond_ternary_optab_supported_p): Likewise.\n+\t(FOR_EACH_COND_FN_PAIR): Likewise.\n+\t(get_conditional_internal_fn): New function.\n+\t(get_unconditional_internal_fn): Likewise.\n+\t* gimple-match.h (gimple_match_op::MAX_NUM_OPS): Bump to 5.\n+\t(gimple_match_op::gimple_match_op): Add a new overload for 5\n+\toperands.\n+\t(gimple_match_op::set_op): Likewise.\n+\t(gimple_resimplify5): Declare.\n+\t* genmatch.c (decision_tree::gen): Generate simplifications for\n+\t5 operands.\n+\t* gimple-match-head.c (gimple_simplify): Define an overload for\n+\t5 operands.  Handle calls with 5 arguments in the top-level overload.\n+\t(convert_conditional_op): Handle conversions from unconditional\n+\tinternal functions to conditional ones.\n+\t(gimple_resimplify5): New function.\n+\t(build_call_internal): Pass a fifth operand.\n+\t(maybe_push_res_to_seq): Likewise.\n+\t(try_conditional_simplification): Try converting conditional\n+\tinternal functions to unconditional internal functions.\n+\tHandle 3-operand unconditional forms.\n+\t* match.pd (UNCOND_TERNARY, COND_TERNARY): Operator lists.\n+\tDefine ternary equivalents of the current rules for binary conditional\n+\tinternal functions.\n+\t* config/aarch64/aarch64.c (aarch64_preferred_else_value): Handle\n+\tternary operations.\n+\t* config/aarch64/iterators.md (UNSPEC_COND_FMLA, UNSPEC_COND_FMLS)\n+\t(UNSPEC_COND_FNMLA, UNSPEC_COND_FNMLS): New unspecs.\n+\t(optab): Handle them.\n+\t(SVE_COND_FP_TERNARY): New int iterator.\n+\t(sve_fmla_op, sve_fmad_op): New int attributes.\n+\t* config/aarch64/aarch64-sve.md (cond_<optab><mode>)\n+\t(*cond_<optab><mode>_2, *cond_<optab><mode_4)\n+\t(*cond_<optab><mode>_any): New SVE_COND_FP_TERNARY patterns.\n+\n 2018-07-12  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* target.def (preferred_else_value): New target hook."}, {"sha": "5cd591b94335cde2230decf632f65c0faf33c4de", "filename": "gcc/config/aarch64/aarch64-sve.md", "status": "modified", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md?ref=b41d1f6ed753bf7ae7e68f745e50c26ee65b5711", "patch": "@@ -2906,6 +2906,101 @@\n \t  UNSPEC_SEL))]\n )\n \n+;; Predicated floating-point ternary operations with select.\n+(define_expand \"cond_<optab><mode>\"\n+  [(set (match_operand:SVE_F 0 \"register_operand\")\n+\t(unspec:SVE_F\n+\t  [(match_operand:<VPRED> 1 \"register_operand\")\n+\t   (unspec:SVE_F\n+\t     [(match_operand:SVE_F 2 \"register_operand\")\n+\t      (match_operand:SVE_F 3 \"register_operand\")\n+\t      (match_operand:SVE_F 4 \"register_operand\")]\n+\t     SVE_COND_FP_TERNARY)\n+\t   (match_operand:SVE_F 5 \"aarch64_simd_reg_or_zero\")]\n+\t  UNSPEC_SEL))]\n+  \"TARGET_SVE\"\n+{\n+  /* Swap the multiplication operands if the fallback value is the\n+     second of the two.  */\n+  if (rtx_equal_p (operands[3], operands[5]))\n+    std::swap (operands[2], operands[3]);\n+})\n+\n+;; Predicated floating-point ternary operations using the FMAD-like form.\n+(define_insn \"*cond_<optab><mode>_2\"\n+  [(set (match_operand:SVE_F 0 \"register_operand\" \"=w, ?&w\")\n+\t(unspec:SVE_F\n+\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl\")\n+\t   (unspec:SVE_F\n+\t     [(match_operand:SVE_F 2 \"register_operand\" \"0, w\")\n+\t      (match_operand:SVE_F 3 \"register_operand\" \"w, w\")\n+\t      (match_operand:SVE_F 4 \"register_operand\" \"w, w\")]\n+\t     SVE_COND_FP_TERNARY)\n+\t   (match_dup 2)]\n+\t  UNSPEC_SEL))]\n+  \"TARGET_SVE\"\n+  \"@\n+   <sve_fmad_op>\\t%0.<Vetype>, %1/m, %3.<Vetype>, %4.<Vetype>\n+   movprfx\\t%0, %2\\;<sve_fmad_op>\\t%0.<Vetype>, %1/m, %3.<Vetype>, %4.<Vetype>\"\n+  [(set_attr \"movprfx\" \"*,yes\")]\n+)\n+\n+;; Predicated floating-point ternary operations using the FMLA-like form.\n+(define_insn \"*cond_<optab><mode>_4\"\n+  [(set (match_operand:SVE_F 0 \"register_operand\" \"=w, ?&w\")\n+\t(unspec:SVE_F\n+\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl\")\n+\t   (unspec:SVE_F\n+\t     [(match_operand:SVE_F 2 \"register_operand\" \"w, w\")\n+\t      (match_operand:SVE_F 3 \"register_operand\" \"w, w\")\n+\t      (match_operand:SVE_F 4 \"register_operand\" \"0, w\")]\n+\t     SVE_COND_FP_TERNARY)\n+\t   (match_dup 4)]\n+\t  UNSPEC_SEL))]\n+  \"TARGET_SVE\"\n+  \"@\n+   <sve_fmla_op>\\t%0.<Vetype>, %1/m, %2.<Vetype>, %3.<Vetype>\n+   movprfx\\t%0, %4\\;<sve_fmad_op>\\t%0.<Vetype>, %1/m, %2.<Vetype>, %3.<Vetype>\"\n+  [(set_attr \"movprfx\" \"*,yes\")]\n+)\n+\n+;; Predicated floating-point ternary operations in which the value for\n+;; inactive lanes is distinct from the other inputs.\n+(define_insn_and_split \"*cond_<optab><mode>_any\"\n+  [(set (match_operand:SVE_F 0 \"register_operand\" \"=&w, &w, ?&w\")\n+\t(unspec:SVE_F\n+\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl, Upl\")\n+\t   (unspec:SVE_F\n+\t     [(match_operand:SVE_F 2 \"register_operand\" \"w, w, w\")\n+\t      (match_operand:SVE_F 3 \"register_operand\" \"w, w, w\")\n+\t      (match_operand:SVE_F 4 \"register_operand\" \"w, w, w\")]\n+\t     SVE_COND_FP_TERNARY)\n+\t   (match_operand:SVE_F 5 \"aarch64_simd_reg_or_zero\" \"Dz, 0, w\")]\n+\t  UNSPEC_SEL))]\n+  \"TARGET_SVE\n+   && !rtx_equal_p (operands[2], operands[5])\n+   && !rtx_equal_p (operands[3], operands[5])\n+   && !rtx_equal_p (operands[4], operands[5])\"\n+  \"@\n+   movprfx\\t%0.<Vetype>, %1/z, %4.<Vetype>\\;<sve_fmla_op>\\t%0.<Vetype>, %1/m, %2.<Vetype>, %3.<Vetype>\n+   movprfx\\t%0.<Vetype>, %1/m, %4.<Vetype>\\;<sve_fmla_op>\\t%0.<Vetype>, %1/m, %2.<Vetype>, %3.<Vetype>\n+   #\"\n+  \"&& reload_completed\n+   && !CONSTANT_P (operands[5])\n+   && !rtx_equal_p (operands[0], operands[5])\"\n+  [(set (match_dup 0)\n+\t(unspec:SVE_F [(match_dup 1) (match_dup 4) (match_dup 5)] UNSPEC_SEL))\n+   (set (match_dup 0)\n+\t(unspec:SVE_F\n+\t  [(match_dup 1)\n+\t   (unspec:SVE_F [(match_dup 2) (match_dup 3) (match_dup 0)]\n+\t\t\t SVE_COND_FP_TERNARY)\n+           (match_dup 0)]\n+\t  UNSPEC_SEL))]\n+  \"\"\n+  [(set_attr \"movprfx\" \"yes\")]\n+)\n+\n ;; Shift an SVE vector left and insert a scalar into element 0.\n (define_insn \"vec_shl_insert_<mode>\"\n   [(set (match_operand:SVE_ALL 0 \"register_operand\" \"=w, w\")"}, {"sha": "e15b4e83d20a765e9c38274931f4c0a3e2c19e87", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=b41d1f6ed753bf7ae7e68f745e50c26ee65b5711", "patch": "@@ -1320,14 +1320,18 @@ aarch64_get_mask_mode (poly_uint64 nunits, poly_uint64 nbytes)\n   return default_get_mask_mode (nunits, nbytes);\n }\n \n-/* Implement TARGET_PREFERRED_ELSE_VALUE.  Prefer to use the first\n-   arithmetic operand as the else value if the else value doesn't matter,\n-   since that exactly matches the SVE destructive merging form.  */\n+/* Implement TARGET_PREFERRED_ELSE_VALUE.  For binary operations,\n+   prefer to use the first arithmetic operand as the else value if\n+   the else value doesn't matter, since that exactly matches the SVE\n+   destructive merging form.  For ternary operations we could either\n+   pick the first operand and use FMAD-like instructions or the last\n+   operand and use FMLA-like instructions; the latter seems more\n+   natural.  */\n \n static tree\n-aarch64_preferred_else_value (unsigned, tree, unsigned int, tree *ops)\n+aarch64_preferred_else_value (unsigned, tree, unsigned int nops, tree *ops)\n {\n-  return ops[0];\n+  return nops == 3 ? ops[2] : ops[0];\n }\n \n /* Implement TARGET_HARD_REGNO_NREGS.  */"}, {"sha": "d846118d3b6b18da3796c98a5bd9aa6e15d83595", "filename": "gcc/config/aarch64/iterators.md", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/gcc%2Fconfig%2Faarch64%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/gcc%2Fconfig%2Faarch64%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fiterators.md?ref=b41d1f6ed753bf7ae7e68f745e50c26ee65b5711", "patch": "@@ -471,6 +471,10 @@\n     UNSPEC_COND_DIV\t; Used in aarch64-sve.md.\n     UNSPEC_COND_MAX\t; Used in aarch64-sve.md.\n     UNSPEC_COND_MIN\t; Used in aarch64-sve.md.\n+    UNSPEC_COND_FMLA\t; Used in aarch64-sve.md.\n+    UNSPEC_COND_FMLS\t; Used in aarch64-sve.md.\n+    UNSPEC_COND_FNMLA\t; Used in aarch64-sve.md.\n+    UNSPEC_COND_FNMLS\t; Used in aarch64-sve.md.\n     UNSPEC_COND_LT\t; Used in aarch64-sve.md.\n     UNSPEC_COND_LE\t; Used in aarch64-sve.md.\n     UNSPEC_COND_EQ\t; Used in aarch64-sve.md.\n@@ -1567,6 +1571,11 @@\n \t\t\t\t\t UNSPEC_COND_MUL UNSPEC_COND_DIV\n \t\t\t\t\t UNSPEC_COND_MAX UNSPEC_COND_MIN])\n \n+(define_int_iterator SVE_COND_FP_TERNARY [UNSPEC_COND_FMLA\n+\t\t\t\t\t  UNSPEC_COND_FMLS\n+\t\t\t\t\t  UNSPEC_COND_FNMLA\n+\t\t\t\t\t  UNSPEC_COND_FNMLS])\n+\n (define_int_iterator SVE_COND_FP_CMP [UNSPEC_COND_LT UNSPEC_COND_LE\n \t\t\t\t      UNSPEC_COND_EQ UNSPEC_COND_NE\n \t\t\t\t      UNSPEC_COND_GE UNSPEC_COND_GT])\n@@ -1599,7 +1608,11 @@\n \t\t\t(UNSPEC_COND_MUL \"mul\")\n \t\t\t(UNSPEC_COND_DIV \"div\")\n \t\t\t(UNSPEC_COND_MAX \"smax\")\n-\t\t\t(UNSPEC_COND_MIN \"smin\")])\n+\t\t\t(UNSPEC_COND_MIN \"smin\")\n+\t\t\t(UNSPEC_COND_FMLA \"fma\")\n+\t\t\t(UNSPEC_COND_FMLS \"fnma\")\n+\t\t\t(UNSPEC_COND_FNMLA \"fnms\")\n+\t\t\t(UNSPEC_COND_FNMLS \"fms\")])\n \n (define_int_attr  maxmin_uns [(UNSPEC_UMAXV \"umax\")\n \t\t\t      (UNSPEC_UMINV \"umin\")\n@@ -1826,6 +1839,16 @@\n \t\t\t        (UNSPEC_COND_MAX \"fmaxnm\")\n \t\t\t        (UNSPEC_COND_MIN \"fminnm\")])\n \n+(define_int_attr sve_fmla_op [(UNSPEC_COND_FMLA \"fmla\")\n+\t\t\t      (UNSPEC_COND_FMLS \"fmls\")\n+\t\t\t      (UNSPEC_COND_FNMLA \"fnmla\")\n+\t\t\t      (UNSPEC_COND_FNMLS \"fnmls\")])\n+\n+(define_int_attr sve_fmad_op [(UNSPEC_COND_FMLA \"fmad\")\n+\t\t\t      (UNSPEC_COND_FMLS \"fmsb\")\n+\t\t\t      (UNSPEC_COND_FNMLA \"fnmad\")\n+\t\t\t      (UNSPEC_COND_FNMLS \"fnmsb\")])\n+\n (define_int_attr commutative [(UNSPEC_COND_ADD \"true\")\n \t\t\t      (UNSPEC_COND_SUB \"false\")\n \t\t\t      (UNSPEC_COND_MUL \"true\")"}, {"sha": "b4f4a9a96229a7b367a85e3e707c94651b9cb6bc", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=b41d1f6ed753bf7ae7e68f745e50c26ee65b5711", "patch": "@@ -6438,6 +6438,23 @@ Operands 0, 2, 3 and 4 all have mode @var{m}.  Operand 1 is a scalar\n integer if @var{m} is scalar, otherwise it has the mode returned by\n @code{TARGET_VECTORIZE_GET_MASK_MODE}.\n \n+@cindex @code{cond_fma@var{mode}} instruction pattern\n+@cindex @code{cond_fms@var{mode}} instruction pattern\n+@cindex @code{cond_fnma@var{mode}} instruction pattern\n+@cindex @code{cond_fnms@var{mode}} instruction pattern\n+@item @samp{cond_fma@var{mode}}\n+@itemx @samp{cond_fms@var{mode}}\n+@itemx @samp{cond_fnma@var{mode}}\n+@itemx @samp{cond_fnms@var{mode}}\n+Like @samp{cond_add@var{m}}, except that the conditional operation\n+takes 3 operands rather than two.  For example, the vector form of\n+@samp{cond_fma@var{mode}} is equivalent to:\n+\n+@smallexample\n+for (i = 0; i < GET_MODE_NUNITS (@var{m}); i++)\n+  op0[i] = op1[i] ? fma (op2[i], op3[i], op4[i]) : op5[i];\n+@end smallexample\n+\n @cindex @code{neg@var{mode}cc} instruction pattern\n @item @samp{neg@var{mode}cc}\n Similar to @samp{mov@var{mode}cc} but for conditional negation.  Conditionally"}, {"sha": "5d6cf0b4d3a75ec1d3e64d814df829feff399f29", "filename": "gcc/genmatch.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/gcc%2Fgenmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/gcc%2Fgenmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmatch.c?ref=b41d1f6ed753bf7ae7e68f745e50c26ee65b5711", "patch": "@@ -3750,7 +3750,7 @@ decision_tree::gen (FILE *f, bool gimple)\n     }\n   fprintf (stderr, \"removed %u duplicate tails\\n\", rcnt);\n \n-  for (unsigned n = 1; n <= 4; ++n)\n+  for (unsigned n = 1; n <= 5; ++n)\n     {\n       /* First generate split-out functions.  */\n       for (unsigned i = 0; i < root->kids.length (); i++)"}, {"sha": "414007ec1f9ece6ba112387c9383938adce87950", "filename": "gcc/gimple-match-head.c", "status": "modified", "additions": 59, "deletions": 7, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/gcc%2Fgimple-match-head.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/gcc%2Fgimple-match-head.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-match-head.c?ref=b41d1f6ed753bf7ae7e68f745e50c26ee65b5711", "patch": "@@ -54,6 +54,8 @@ static bool gimple_simplify (gimple_match_op *, gimple_seq *, tree (*)(tree),\n \t\t\t     code_helper, tree, tree, tree, tree);\n static bool gimple_simplify (gimple_match_op *, gimple_seq *, tree (*)(tree),\n \t\t\t     code_helper, tree, tree, tree, tree, tree);\n+static bool gimple_simplify (gimple_match_op *, gimple_seq *, tree (*)(tree),\n+\t\t\t     code_helper, tree, tree, tree, tree, tree, tree);\n \n const unsigned int gimple_match_op::MAX_NUM_OPS;\n \n@@ -80,7 +82,12 @@ convert_conditional_op (gimple_match_op *orig_op,\n   if (orig_op->code.is_tree_code ())\n     ifn = get_conditional_internal_fn ((tree_code) orig_op->code);\n   else\n-    return false;\n+    {\n+      combined_fn cfn = orig_op->code;\n+      if (!internal_fn_p (cfn))\n+\treturn false;\n+      ifn = get_conditional_internal_fn (as_internal_fn (cfn));\n+    }\n   if (ifn == IFN_LAST)\n     return false;\n   unsigned int num_ops = orig_op->num_ops;\n@@ -403,6 +410,34 @@ gimple_resimplify4 (gimple_seq *seq, gimple_match_op *res_op,\n   return false;\n }\n \n+/* Helper that matches and simplifies the toplevel result from\n+   a gimple_simplify run (where we don't want to build\n+   a stmt in case it's used in in-place folding).  Replaces\n+   RES_OP with a simplified and/or canonicalized result and\n+   returns whether any change was made.  */\n+\n+bool\n+gimple_resimplify5 (gimple_seq *seq, gimple_match_op *res_op,\n+\t\t    tree (*valueize)(tree))\n+{\n+  /* No constant folding is defined for five-operand functions.  */\n+\n+  gimple_match_op res_op2 (*res_op);\n+  if (gimple_simplify (&res_op2, seq, valueize,\n+\t\t       res_op->code, res_op->type,\n+\t\t       res_op->ops[0], res_op->ops[1], res_op->ops[2],\n+\t\t       res_op->ops[3], res_op->ops[4]))\n+    {\n+      *res_op = res_op2;\n+      return true;\n+    }\n+\n+  if (maybe_resimplify_conditional_op (seq, res_op, valueize))\n+    return true;\n+\n+  return false;\n+}\n+\n /* If in GIMPLE the operation described by RES_OP should be single-rhs,\n    build a GENERIC tree for that expression and update RES_OP accordingly.  */\n \n@@ -444,7 +479,8 @@ build_call_internal (internal_fn fn, gimple_match_op *res_op)\n \t\t\t\t     res_op->op_or_null (0),\n \t\t\t\t     res_op->op_or_null (1),\n \t\t\t\t     res_op->op_or_null (2),\n-\t\t\t\t     res_op->op_or_null (3));\n+\t\t\t\t     res_op->op_or_null (3),\n+\t\t\t\t     res_op->op_or_null (4));\n }\n \n /* Push the exploded expression described by RES_OP as a statement to\n@@ -538,7 +574,8 @@ maybe_push_res_to_seq (gimple_match_op *res_op, gimple_seq *seq, tree res)\n \t\t\t\t\tres_op->op_or_null (0),\n \t\t\t\t\tres_op->op_or_null (1),\n \t\t\t\t\tres_op->op_or_null (2),\n-\t\t\t\t\tres_op->op_or_null (3));\n+\t\t\t\t\tres_op->op_or_null (3),\n+\t\t\t\t\tres_op->op_or_null (4));\n \t}\n       if (!res)\n \t{\n@@ -745,14 +782,22 @@ static bool\n try_conditional_simplification (internal_fn ifn, gimple_match_op *res_op,\n \t\t\t\tgimple_seq *seq, tree (*valueize) (tree))\n {\n+  code_helper op;\n   tree_code code = conditional_internal_fn_code (ifn);\n-  if (code == ERROR_MARK)\n-    return false;\n+  if (code != ERROR_MARK)\n+    op = code;\n+  else\n+    {\n+      ifn = get_unconditional_internal_fn (ifn);\n+      if (ifn == IFN_LAST)\n+\treturn false;\n+      op = as_combined_fn (ifn);\n+    }\n \n   unsigned int num_ops = res_op->num_ops;\n   gimple_match_op cond_op (gimple_match_cond (res_op->ops[0],\n \t\t\t\t\t      res_op->ops[num_ops - 1]),\n-\t\t\t   code, res_op->type, num_ops - 2);\n+\t\t\t   op, res_op->type, num_ops - 2);\n   for (unsigned int i = 1; i < num_ops - 1; ++i)\n     cond_op.ops[i - 1] = res_op->ops[i];\n   switch (num_ops - 2)\n@@ -761,6 +806,10 @@ try_conditional_simplification (internal_fn ifn, gimple_match_op *res_op,\n       if (!gimple_resimplify2 (seq, &cond_op, valueize))\n \treturn false;\n       break;\n+    case 3:\n+      if (!gimple_resimplify3 (seq, &cond_op, valueize))\n+\treturn false;\n+      break;\n     default:\n       gcc_unreachable ();\n     }\n@@ -893,7 +942,7 @@ gimple_simplify (gimple *stmt, gimple_match_op *res_op, gimple_seq *seq,\n       /* ???  This way we can't simplify calls with side-effects.  */\n       if (gimple_call_lhs (stmt) != NULL_TREE\n \t  && gimple_call_num_args (stmt) >= 1\n-\t  && gimple_call_num_args (stmt) <= 4)\n+\t  && gimple_call_num_args (stmt) <= 5)\n \t{\n \t  bool valueized = false;\n \t  combined_fn cfn;\n@@ -943,6 +992,9 @@ gimple_simplify (gimple *stmt, gimple_match_op *res_op, gimple_seq *seq,\n \t    case 4:\n \t      return (gimple_resimplify4 (seq, res_op, valueize)\n \t\t      || valueized);\n+\t    case 5:\n+\t      return (gimple_resimplify5 (seq, res_op, valueize)\n+\t\t      || valueized);\n \t    default:\n \t     gcc_unreachable ();\n \t    }"}, {"sha": "704fa76c0a4a9ca76eba5556e02f04b4eadecfa2", "filename": "gcc/gimple-match.h", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/gcc%2Fgimple-match.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/gcc%2Fgimple-match.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-match.h?ref=b41d1f6ed753bf7ae7e68f745e50c26ee65b5711", "patch": "@@ -91,18 +91,21 @@ struct gimple_match_op\n \t\t   code_helper, tree, tree, tree, tree);\n   gimple_match_op (const gimple_match_cond &,\n \t\t   code_helper, tree, tree, tree, tree, tree);\n+  gimple_match_op (const gimple_match_cond &,\n+\t\t   code_helper, tree, tree, tree, tree, tree, tree);\n \n   void set_op (code_helper, tree, unsigned int);\n   void set_op (code_helper, tree, tree);\n   void set_op (code_helper, tree, tree, tree);\n   void set_op (code_helper, tree, tree, tree, tree);\n   void set_op (code_helper, tree, tree, tree, tree, tree);\n+  void set_op (code_helper, tree, tree, tree, tree, tree, tree);\n   void set_value (tree);\n \n   tree op_or_null (unsigned int) const;\n \n   /* The maximum value of NUM_OPS.  */\n-  static const unsigned int MAX_NUM_OPS = 4;\n+  static const unsigned int MAX_NUM_OPS = 5;\n \n   /* The conditions under which the operation is performed, and the value to\n      use as a fallback.  */\n@@ -182,6 +185,20 @@ gimple_match_op::gimple_match_op (const gimple_match_cond &cond_in,\n   ops[3] = op3;\n }\n \n+inline\n+gimple_match_op::gimple_match_op (const gimple_match_cond &cond_in,\n+\t\t\t\t  code_helper code_in, tree type_in,\n+\t\t\t\t  tree op0, tree op1, tree op2, tree op3,\n+\t\t\t\t  tree op4)\n+  : cond (cond_in), code (code_in), type (type_in), num_ops (5)\n+{\n+  ops[0] = op0;\n+  ops[1] = op1;\n+  ops[2] = op2;\n+  ops[3] = op3;\n+  ops[4] = op4;\n+}\n+\n /* Change the operation performed to CODE_IN, the type of the result to\n    TYPE_IN, and the number of operands to NUM_OPS_IN.  The caller needs\n    to set the operands itself.  */\n@@ -242,6 +259,20 @@ gimple_match_op::set_op (code_helper code_in, tree type_in,\n   ops[3] = op3;\n }\n \n+inline void\n+gimple_match_op::set_op (code_helper code_in, tree type_in,\n+\t\t\t tree op0, tree op1, tree op2, tree op3, tree op4)\n+{\n+  code = code_in;\n+  type = type_in;\n+  num_ops = 5;\n+  ops[0] = op0;\n+  ops[1] = op1;\n+  ops[2] = op2;\n+  ops[3] = op3;\n+  ops[4] = op4;\n+}\n+\n /* Set the \"operation\" to be the single value VALUE, such as a constant\n    or SSA_NAME.  */\n \n@@ -279,6 +310,7 @@ bool gimple_resimplify1 (gimple_seq *, gimple_match_op *, tree (*)(tree));\n bool gimple_resimplify2 (gimple_seq *, gimple_match_op *, tree (*)(tree));\n bool gimple_resimplify3 (gimple_seq *, gimple_match_op *, tree (*)(tree));\n bool gimple_resimplify4 (gimple_seq *, gimple_match_op *, tree (*)(tree));\n+bool gimple_resimplify5 (gimple_seq *, gimple_match_op *, tree (*)(tree));\n tree maybe_push_res_to_seq (gimple_match_op *, gimple_seq *,\n \t\t\t    tree res = NULL_TREE);\n void maybe_build_generic_op (gimple_match_op *);"}, {"sha": "474a16bc6fb12df44fced67f17e74cc28faef83f", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=b41d1f6ed753bf7ae7e68f745e50c26ee65b5711", "patch": "@@ -113,6 +113,7 @@ init_internal_fns ()\n #define ternary_direct { 0, 0, true }\n #define cond_unary_direct { 1, 1, true }\n #define cond_binary_direct { 1, 1, true }\n+#define cond_ternary_direct { 1, 1, true }\n #define while_direct { 0, 2, false }\n #define fold_extract_direct { 2, 2, false }\n #define fold_left_direct { 1, 1, false }\n@@ -2993,6 +2994,9 @@ expand_while_optab_fn (internal_fn, gcall *stmt, convert_optab optab)\n #define expand_cond_binary_optab_fn(FN, STMT, OPTAB) \\\n   expand_direct_optab_fn (FN, STMT, OPTAB, 4)\n \n+#define expand_cond_ternary_optab_fn(FN, STMT, OPTAB) \\\n+  expand_direct_optab_fn (FN, STMT, OPTAB, 5)\n+\n #define expand_fold_extract_optab_fn(FN, STMT, OPTAB) \\\n   expand_direct_optab_fn (FN, STMT, OPTAB, 3)\n \n@@ -3075,6 +3079,7 @@ multi_vector_optab_supported_p (convert_optab optab, tree_pair types,\n #define direct_ternary_optab_supported_p direct_optab_supported_p\n #define direct_cond_unary_optab_supported_p direct_optab_supported_p\n #define direct_cond_binary_optab_supported_p direct_optab_supported_p\n+#define direct_cond_ternary_optab_supported_p direct_optab_supported_p\n #define direct_mask_load_optab_supported_p direct_optab_supported_p\n #define direct_load_lanes_optab_supported_p multi_vector_optab_supported_p\n #define direct_mask_load_lanes_optab_supported_p multi_vector_optab_supported_p\n@@ -3277,6 +3282,57 @@ conditional_internal_fn_code (internal_fn ifn)\n     }\n }\n \n+/* Invoke T(IFN) for each internal function IFN that also has an\n+   IFN_COND_* form.  */\n+#define FOR_EACH_COND_FN_PAIR(T) \\\n+  T (FMA) \\\n+  T (FMS) \\\n+  T (FNMA) \\\n+  T (FNMS)\n+\n+/* Return a function that only performs internal function FN when a\n+   certain condition is met and that uses a given fallback value otherwise.\n+   In other words, the returned function FN' is such that:\n+\n+     LHS = FN' (COND, A1, ... An, ELSE)\n+\n+   is equivalent to the C expression:\n+\n+     LHS = COND ? FN (A1, ..., An) : ELSE;\n+\n+   operating elementwise if the operands are vectors.\n+\n+   Return IFN_LAST if no such function exists.  */\n+\n+internal_fn\n+get_conditional_internal_fn (internal_fn fn)\n+{\n+  switch (fn)\n+    {\n+#define CASE(NAME) case IFN_##NAME: return IFN_COND_##NAME;\n+      FOR_EACH_COND_FN_PAIR(CASE)\n+#undef CASE\n+    default:\n+      return IFN_LAST;\n+    }\n+}\n+\n+/* If IFN implements the conditional form of an unconditional internal\n+   function, return that unconditional function, otherwise return IFN_LAST.  */\n+\n+internal_fn\n+get_unconditional_internal_fn (internal_fn ifn)\n+{\n+  switch (ifn)\n+    {\n+#define CASE(NAME) case IFN_COND_##NAME: return IFN_##NAME;\n+      FOR_EACH_COND_FN_PAIR(CASE)\n+#undef CASE\n+    default:\n+      return IFN_LAST;\n+    }\n+}\n+\n /* Return true if IFN is some form of load from memory.  */\n \n bool"}, {"sha": "cda314e112155ae638db7cdb60a51df20b96ade3", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=b41d1f6ed753bf7ae7e68f745e50c26ee65b5711", "patch": "@@ -59,7 +59,8 @@ along with GCC; see the file COPYING3.  If not see\n    - binary: a normal binary optab, such as vec_interleave_lo_<mode>\n    - ternary: a normal ternary optab, such as fma<mode>4\n \n-   - cond_binary: a conditional binary optab, such as add<mode>cc\n+   - cond_binary: a conditional binary optab, such as cond_add<mode>\n+   - cond_ternary: a conditional ternary optab, such as cond_fma_rev<mode>\n \n    - fold_left: for scalar = FN (scalar, vector), keyed off the vector mode\n \n@@ -167,6 +168,11 @@ DEF_INTERNAL_OPTAB_FN (COND_IOR, ECF_CONST | ECF_NOTHROW,\n DEF_INTERNAL_OPTAB_FN (COND_XOR, ECF_CONST | ECF_NOTHROW,\n \t\t       cond_xor, cond_binary)\n \n+DEF_INTERNAL_OPTAB_FN (COND_FMA, ECF_CONST, cond_fma, cond_ternary)\n+DEF_INTERNAL_OPTAB_FN (COND_FMS, ECF_CONST, cond_fms, cond_ternary)\n+DEF_INTERNAL_OPTAB_FN (COND_FNMA, ECF_CONST, cond_fnma, cond_ternary)\n+DEF_INTERNAL_OPTAB_FN (COND_FNMS, ECF_CONST, cond_fnms, cond_ternary)\n+\n DEF_INTERNAL_OPTAB_FN (RSQRT, ECF_CONST, rsqrt, unary)\n \n DEF_INTERNAL_OPTAB_FN (REDUC_PLUS, ECF_CONST | ECF_NOTHROW,\n@@ -235,7 +241,7 @@ DEF_INTERNAL_OPTAB_FN (XORSIGN, ECF_CONST, xorsign, binary)\n DEF_INTERNAL_FLT_FN (LDEXP, ECF_CONST, ldexp, binary)\n \n /* Ternary math functions.  */\n-DEF_INTERNAL_FLT_FN (FMA, ECF_CONST, fma, ternary)\n+DEF_INTERNAL_FLT_FLOATN_FN (FMA, ECF_CONST, fma, ternary)\n \n /* Unary integer ops.  */\n DEF_INTERNAL_INT_FN (CLRSB, ECF_CONST | ECF_NOTHROW, clrsb, unary)"}, {"sha": "7105c3bbff833ba6956e649ab7ba69209022911e", "filename": "gcc/internal-fn.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/gcc%2Finternal-fn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/gcc%2Finternal-fn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.h?ref=b41d1f6ed753bf7ae7e68f745e50c26ee65b5711", "patch": "@@ -193,7 +193,9 @@ direct_internal_fn_supported_p (internal_fn fn, tree type0, tree type1,\n extern bool set_edom_supported_p (void);\n \n extern internal_fn get_conditional_internal_fn (tree_code);\n+extern internal_fn get_conditional_internal_fn (internal_fn);\n extern tree_code conditional_internal_fn_code (internal_fn);\n+extern internal_fn get_unconditional_internal_fn (internal_fn);\n \n extern bool internal_load_fn_p (internal_fn);\n extern bool internal_store_fn_p (internal_fn);"}, {"sha": "dea6cde49abb2e828ff596e2af4a1b54d93412a7", "filename": "gcc/match.pd", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=b41d1f6ed753bf7ae7e68f745e50c26ee65b5711", "patch": "@@ -86,6 +86,12 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n   IFN_COND_MUL IFN_COND_DIV IFN_COND_MOD IFN_COND_RDIV\n   IFN_COND_MIN IFN_COND_MAX\n   IFN_COND_AND IFN_COND_IOR IFN_COND_XOR)\n+\n+/* Same for ternary operations.  */\n+(define_operator_list UNCOND_TERNARY\n+  IFN_FMA IFN_FMS IFN_FNMA IFN_FNMS)\n+(define_operator_list COND_TERNARY\n+  IFN_COND_FMA IFN_COND_FMS IFN_COND_FNMA IFN_COND_FNMS)\n     \n /* As opposed to convert?, this still creates a single pattern, so\n    it is not a suitable replacement for convert? in all cases.  */\n@@ -4885,6 +4891,21 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n    (if (element_precision (type) == element_precision (op_type))\n     (view_convert (cond_op (bit_not @0) @2 @3 (view_convert:op_type @1)))))))\n \n+/* Same for ternary operations.  */\n+(for uncond_op (UNCOND_TERNARY)\n+     cond_op (COND_TERNARY)\n+ (simplify\n+  (vec_cond @0 (view_convert? (uncond_op@5 @1 @2 @3)) @4)\n+  (with { tree op_type = TREE_TYPE (@5); }\n+   (if (element_precision (type) == element_precision (op_type))\n+    (view_convert (cond_op @0 @1 @2 @3 (view_convert:op_type @4))))))\n+ (simplify\n+  (vec_cond @0 @1 (view_convert? (uncond_op@5 @2 @3 @4)))\n+  (with { tree op_type = TREE_TYPE (@5); }\n+   (if (element_precision (type) == element_precision (op_type))\n+    (view_convert (cond_op (bit_not @0) @2 @3 @4\n+\t\t  (view_convert:op_type @1)))))))\n+\n /* Detect cases in which a VEC_COND_EXPR effectively replaces the\n    \"else\" value of an IFN_COND_*.  */\n (for cond_op (COND_BINARY)\n@@ -4893,3 +4914,11 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n   (with { tree op_type = TREE_TYPE (@3); }\n    (if (element_precision (type) == element_precision (op_type))\n     (view_convert (cond_op @0 @1 @2 (view_convert:op_type @4)))))))\n+\n+/* Same for ternary operations.  */\n+(for cond_op (COND_TERNARY)\n+ (simplify\n+  (vec_cond @0 (view_convert? (cond_op @0 @1 @2 @3 @4)) @5)\n+  (with { tree op_type = TREE_TYPE (@4); }\n+   (if (element_precision (type) == element_precision (op_type))\n+    (view_convert (cond_op @0 @1 @2 @3 (view_convert:op_type @5)))))))"}, {"sha": "5a67f5eed5e457e6dea34f9969534f8497e620f6", "filename": "gcc/optabs.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/gcc%2Foptabs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/gcc%2Foptabs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.def?ref=b41d1f6ed753bf7ae7e68f745e50c26ee65b5711", "patch": "@@ -234,6 +234,10 @@ OPTAB_D (cond_smin_optab, \"cond_smin$a\")\n OPTAB_D (cond_smax_optab, \"cond_smax$a\")\n OPTAB_D (cond_umin_optab, \"cond_umin$a\")\n OPTAB_D (cond_umax_optab, \"cond_umax$a\")\n+OPTAB_D (cond_fma_optab, \"cond_fma$a\")\n+OPTAB_D (cond_fms_optab, \"cond_fms$a\")\n+OPTAB_D (cond_fnma_optab, \"cond_fnma$a\")\n+OPTAB_D (cond_fnms_optab, \"cond_fnms$a\")\n OPTAB_D (cmov_optab, \"cmov$a6\")\n OPTAB_D (cstore_optab, \"cstore$a4\")\n OPTAB_D (ctrap_optab, \"ctrap$a4\")"}, {"sha": "9e5287d4742360e897a387c9403163cd19140246", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b41d1f6ed753bf7ae7e68f745e50c26ee65b5711", "patch": "@@ -1,3 +1,15 @@\n+2018-07-12  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* gcc.dg/vect/vect-cond-arith-3.c: New test.\n+\t* gcc.target/aarch64/sve/vcond_13.c: Likewise.\n+\t* gcc.target/aarch64/sve/vcond_13_run.c: Likewise.\n+\t* gcc.target/aarch64/sve/vcond_14.c: Likewise.\n+\t* gcc.target/aarch64/sve/vcond_14_run.c: Likewise.\n+\t* gcc.target/aarch64/sve/vcond_15.c: Likewise.\n+\t* gcc.target/aarch64/sve/vcond_15_run.c: Likewise.\n+\t* gcc.target/aarch64/sve/vcond_16.c: Likewise.\n+\t* gcc.target/aarch64/sve/vcond_16_run.c: Likewise.\n+\n 2018-07-12  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* gcc.dg/vect/vect-cond-arith-2.c: New test."}, {"sha": "f02b0dc5d3a11e3cfa8a23536f570ecb04a039fd", "filename": "gcc/testsuite/gcc.dg/vect/vect-cond-arith-3.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-arith-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-arith-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-arith-3.c?ref=b41d1f6ed753bf7ae7e68f745e50c26ee65b5711", "patch": "@@ -0,0 +1,63 @@\n+/* { dg-require-effective-target scalar_all_fma } */\n+/* { dg-additional-options \"-fdump-tree-optimized\" } */\n+\n+#include \"tree-vect.h\"\n+\n+#define N (VECTOR_BITS * 11 / 64 + 3)\n+\n+#define DEF(INV)\t\t\t\t\t\\\n+  void __attribute__ ((noipa))\t\t\t\t\\\n+  f_##INV (double *restrict a, double *restrict b,\t\\\n+\t   double *restrict c, double *restrict d)\t\\\n+  {\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tdouble mb = (INV & 1 ? -b[i] : b[i]);\t\t\\\n+\tdouble mc = c[i];\t\t\t\t\\\n+\tdouble md = (INV & 2 ? -d[i] : d[i]);\t\t\\\n+\tdouble fma = __builtin_fma (mb, mc, md);\t\\\n+\tdouble truev = (INV & 4 ? -fma : fma);\t\t\\\n+\ta[i] = b[i] < 10 ? truev : 10.0;\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+  }\n+\n+#define TEST(INV)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    f_##INV (a, b, c, d);\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tdouble mb = (INV & 1 ? -b[i] : b[i]);\t\t\\\n+\tdouble mc = c[i];\t\t\t\t\\\n+\tdouble md = (INV & 2 ? -d[i] : d[i]);\t\t\\\n+\tdouble fma = __builtin_fma (mb, mc, md);\t\\\n+\tdouble truev = (INV & 4 ? -fma : fma);\t\t\\\n+\tif (a[i] != (i % 17 < 10 ? truev : 10.0))\t\\\n+\t  __builtin_abort ();\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+  }\n+\n+#define FOR_EACH_INV(T) \\\n+  T (0) T (1) T (2) T (3) T (4) T (5) T (6) T (7)\n+\n+FOR_EACH_INV (DEF)\n+\n+int\n+main (void)\n+{\n+  double a[N], b[N], c[N], d[N];\n+  for (int i = 0; i < N; ++i)\n+    {\n+      b[i] = i % 17;\n+      c[i] = i % 9 + 11;\n+      d[i] = i % 13 + 14;\n+      asm volatile (\"\" ::: \"memory\");\n+    }\n+  FOR_EACH_INV (TEST)\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times { = \\.COND_FMA } 2 \"optimized\" { target vect_double_cond_arith } } } */\n+/* { dg-final { scan-tree-dump-times { = \\.COND_FMS } 2 \"optimized\" { target vect_double_cond_arith } } } */\n+/* { dg-final { scan-tree-dump-times { = \\.COND_FNMA } 2 \"optimized\" { target vect_double_cond_arith } } } */\n+/* { dg-final { scan-tree-dump-times { = \\.COND_FNMS } 2 \"optimized\" { target vect_double_cond_arith } } } */"}, {"sha": "3c3aa00f6741344e936768067431b0c27efae81c", "filename": "gcc/testsuite/gcc.target/aarch64/sve/vcond_13.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_13.c?ref=b41d1f6ed753bf7ae7e68f745e50c26ee65b5711", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#define N 119\n+\n+#define DEF_LOOP(INV, TYPE, CMPTYPE, SUFFIX)\t\t\t\\\n+  void __attribute__ ((noipa))\t\t\t\t\t\\\n+  f_##INV##_##SUFFIX (TYPE *restrict a, TYPE *restrict b,\t\\\n+\t\t      TYPE *restrict c, TYPE *restrict d,\t\\\n+\t\t      CMPTYPE *restrict cond)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tTYPE mb = (INV & 1 ? -b[i] : b[i]);\t\t\t\\\n+\tTYPE mc = c[i];\t\t\t\t\t\t\\\n+\tTYPE md = (INV & 2 ? -d[i] : d[i]);\t\t\t\\\n+\tTYPE fma = __builtin_fma##SUFFIX (mb, mc, md);\t\t\\\n+\tTYPE truev = (INV & 4 ? -fma : fma);\t\t\t\\\n+\ta[i] = cond[i] < 10 ? truev : b[i];\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  }\n+\n+#define FOR_EACH_TYPE(T, INV)\t\t\t\\\n+  T (INV, _Float16, short, f16)\t\t\t\\\n+  T (INV, float, float, f32)\t\t\t\\\n+  T (INV, double, double, f64)\n+\n+#define FOR_EACH_INV(T)\t\t\t\t\\\n+  FOR_EACH_TYPE (T, 0)\t\t\t\t\\\n+  FOR_EACH_TYPE (T, 1)\t\t\t\t\\\n+  FOR_EACH_TYPE (T, 2)\t\t\t\t\\\n+  FOR_EACH_TYPE (T, 3)\t\t\t\t\\\n+  FOR_EACH_TYPE (T, 4)\t\t\t\t\\\n+  FOR_EACH_TYPE (T, 5)\t\t\t\t\\\n+  FOR_EACH_TYPE (T, 6)\t\t\t\t\\\n+  FOR_EACH_TYPE (T, 7)\n+\n+FOR_EACH_INV (DEF_LOOP)\n+\n+/* { dg-final { scan-assembler-not {\\tsel\\t} } } */\n+/* { dg-final { scan-assembler-not {\\tmovprfx\\t} } } */\n+/* { dg-final { scan-assembler-not {\\tmov\\tz[0-9]+\\.., z[0-9]+} } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfmad\\tz[0-9]+\\.h,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfmad\\tz[0-9]+\\.s,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfmad\\tz[0-9]+\\.d,} 2 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfmsb\\tz[0-9]+\\.h,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfmsb\\tz[0-9]+\\.s,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfmsb\\tz[0-9]+\\.d,} 2 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfnmad\\tz[0-9]+\\.h,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfnmad\\tz[0-9]+\\.s,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfnmad\\tz[0-9]+\\.d,} 2 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfnmsb\\tz[0-9]+\\.h,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfnmsb\\tz[0-9]+\\.s,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfnmsb\\tz[0-9]+\\.d,} 2 } } */"}, {"sha": "f0f8385babc6ef48c0a3f804061e322b9600a8c5", "filename": "gcc/testsuite/gcc.target/aarch64/sve/vcond_13_run.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_13_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_13_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_13_run.c?ref=b41d1f6ed753bf7ae7e68f745e50c26ee65b5711", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include \"vcond_13.c\"\n+\n+#define TEST_LOOP(INV, TYPE, CMPTYPE, SUFFIX)\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    TYPE a[N], b[N], c[N], d[N];\t\t\t\\\n+    CMPTYPE cond[N];\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tb[i] = i % 15;\t\t\t\t\t\\\n+\tc[i] = i % 9 + 11;\t\t\t\t\\\n+\td[i] = i % 13 + 14;\t\t\t\t\\\n+\tcond[i] = i % 17;\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+    f_##INV##_##SUFFIX (a, b, c, d, cond);\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tdouble mb = (INV & 1 ? -b[i] : b[i]);\t\t\\\n+\tdouble mc = c[i];\t\t\t\t\\\n+\tdouble md = (INV & 2 ? -d[i] : d[i]);\t\t\\\n+\tdouble fma = __builtin_fma (mb, mc, md);\t\\\n+\tdouble truev = (INV & 4 ? -fma : fma);\t\t\\\n+\tif (a[i] != (i % 17 < 10 ? truev : b[i]))\t\\\n+\t  __builtin_abort ();\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+  }\n+\n+int\n+main (void)\n+{\n+  FOR_EACH_INV (TEST_LOOP)\n+  return 0;\n+}"}, {"sha": "1144461dec0ee739025fd31c7904b121da170c75", "filename": "gcc/testsuite/gcc.target/aarch64/sve/vcond_14.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_14.c?ref=b41d1f6ed753bf7ae7e68f745e50c26ee65b5711", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#define N 119\n+\n+#define DEF_LOOP(INV, TYPE, CMPTYPE, SUFFIX)\t\t\t\\\n+  void __attribute__ ((noipa))\t\t\t\t\t\\\n+  f_##INV##_##SUFFIX (TYPE *restrict a, TYPE *restrict b,\t\\\n+\t\t      TYPE *restrict c, TYPE *restrict d,\t\\\n+\t\t      CMPTYPE *restrict cond)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tTYPE mb = (INV & 1 ? -b[i] : b[i]);\t\t\t\\\n+\tTYPE mc = c[i];\t\t\t\t\t\t\\\n+\tTYPE md = (INV & 2 ? -d[i] : d[i]);\t\t\t\\\n+\tTYPE fma = __builtin_fma##SUFFIX (mb, mc, md);\t\t\\\n+\tTYPE truev = (INV & 4 ? -fma : fma);\t\t\t\\\n+\ta[i] = cond[i] < 10 ? truev : c[i];\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  }\n+\n+#define FOR_EACH_TYPE(T, INV)\t\t\t\\\n+  T (INV, _Float16, short, f16)\t\t\t\\\n+  T (INV, float, float, f32)\t\t\t\\\n+  T (INV, double, double, f64)\n+\n+#define FOR_EACH_INV(T)\t\t\t\t\\\n+  FOR_EACH_TYPE (T, 0)\t\t\t\t\\\n+  FOR_EACH_TYPE (T, 1)\t\t\t\t\\\n+  FOR_EACH_TYPE (T, 2)\t\t\t\t\\\n+  FOR_EACH_TYPE (T, 3)\t\t\t\t\\\n+  FOR_EACH_TYPE (T, 4)\t\t\t\t\\\n+  FOR_EACH_TYPE (T, 5)\t\t\t\t\\\n+  FOR_EACH_TYPE (T, 6)\t\t\t\t\\\n+  FOR_EACH_TYPE (T, 7)\n+\n+FOR_EACH_INV (DEF_LOOP)\n+\n+/* { dg-final { scan-assembler-not {\\tsel\\t} } } */\n+/* { dg-final { scan-assembler-not {\\tmovprfx\\t} } } */\n+/* { dg-final { scan-assembler-not {\\tmov\\tz[0-9]+\\.., z[0-9]+} } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfmad\\tz[0-9]+\\.h,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfmad\\tz[0-9]+\\.s,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfmad\\tz[0-9]+\\.d,} 2 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfmsb\\tz[0-9]+\\.h,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfmsb\\tz[0-9]+\\.s,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfmsb\\tz[0-9]+\\.d,} 2 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfnmad\\tz[0-9]+\\.h,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfnmad\\tz[0-9]+\\.s,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfnmad\\tz[0-9]+\\.d,} 2 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfnmsb\\tz[0-9]+\\.h,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfnmsb\\tz[0-9]+\\.s,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfnmsb\\tz[0-9]+\\.d,} 2 } } */"}, {"sha": "090f35be315b1a8551f6c11180ee9bea99762882", "filename": "gcc/testsuite/gcc.target/aarch64/sve/vcond_14_run.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_14_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_14_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_14_run.c?ref=b41d1f6ed753bf7ae7e68f745e50c26ee65b5711", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include \"vcond_14.c\"\n+\n+#define TEST_LOOP(INV, TYPE, CMPTYPE, SUFFIX)\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    TYPE a[N], b[N], c[N], d[N];\t\t\t\\\n+    CMPTYPE cond[N];\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tb[i] = i % 15;\t\t\t\t\t\\\n+\tc[i] = i % 9 + 11;\t\t\t\t\\\n+\td[i] = i % 13 + 14;\t\t\t\t\\\n+\tcond[i] = i % 17;\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+    f_##INV##_##SUFFIX (a, b, c, d, cond);\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tdouble mb = (INV & 1 ? -b[i] : b[i]);\t\t\\\n+\tdouble mc = c[i];\t\t\t\t\\\n+\tdouble md = (INV & 2 ? -d[i] : d[i]);\t\t\\\n+\tdouble fma = __builtin_fma (mb, mc, md);\t\\\n+\tdouble truev = (INV & 4 ? -fma : fma);\t\t\\\n+\tif (a[i] != (i % 17 < 10 ? truev : c[i]))\t\\\n+\t  __builtin_abort ();\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+  }\n+\n+int\n+main (void)\n+{\n+  FOR_EACH_INV (TEST_LOOP)\n+  return 0;\n+}"}, {"sha": "4967074072c7197a288db3505a83ddf3378a4f9d", "filename": "gcc/testsuite/gcc.target/aarch64/sve/vcond_15.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_15.c?ref=b41d1f6ed753bf7ae7e68f745e50c26ee65b5711", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#define N 119\n+\n+#define DEF_LOOP(INV, TYPE, CMPTYPE, SUFFIX)\t\t\t\\\n+  void __attribute__ ((noipa))\t\t\t\t\t\\\n+  f_##INV##_##SUFFIX (TYPE *restrict a, TYPE *restrict b,\t\\\n+\t\t      TYPE *restrict c, TYPE *restrict d,\t\\\n+\t\t      CMPTYPE *restrict cond)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tTYPE mb = (INV & 1 ? -b[i] : b[i]);\t\t\t\\\n+\tTYPE mc = c[i];\t\t\t\t\t\t\\\n+\tTYPE md = (INV & 2 ? -d[i] : d[i]);\t\t\t\\\n+\tTYPE fma = __builtin_fma##SUFFIX (mb, mc, md);\t\t\\\n+\tTYPE truev = (INV & 4 ? -fma : fma);\t\t\t\\\n+\ta[i] = cond[i] < 10 ? truev : d[i];\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  }\n+\n+#define FOR_EACH_TYPE(T, INV)\t\t\t\\\n+  T (INV, _Float16, short, f16)\t\t\t\\\n+  T (INV, float, float, f32)\t\t\t\\\n+  T (INV, double, double, f64)\n+\n+#define FOR_EACH_INV(T)\t\t\t\t\\\n+  FOR_EACH_TYPE (T, 0)\t\t\t\t\\\n+  FOR_EACH_TYPE (T, 1)\t\t\t\t\\\n+  FOR_EACH_TYPE (T, 2)\t\t\t\t\\\n+  FOR_EACH_TYPE (T, 3)\t\t\t\t\\\n+  FOR_EACH_TYPE (T, 4)\t\t\t\t\\\n+  FOR_EACH_TYPE (T, 5)\t\t\t\t\\\n+  FOR_EACH_TYPE (T, 6)\t\t\t\t\\\n+  FOR_EACH_TYPE (T, 7)\n+\n+FOR_EACH_INV (DEF_LOOP)\n+\n+/* { dg-final { scan-assembler-not {\\tsel\\t} } } */\n+/* { dg-final { scan-assembler-not {\\tmovprfx\\t} } } */\n+/* { dg-final { scan-assembler-not {\\tmov\\tz[0-9]+\\.., z[0-9]+} } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfmla\\tz[0-9]+\\.h,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfmla\\tz[0-9]+\\.s,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfmla\\tz[0-9]+\\.d,} 2 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfmls\\tz[0-9]+\\.h,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfmls\\tz[0-9]+\\.s,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfmls\\tz[0-9]+\\.d,} 2 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfnmla\\tz[0-9]+\\.h,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfnmla\\tz[0-9]+\\.s,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfnmla\\tz[0-9]+\\.d,} 2 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfnmls\\tz[0-9]+\\.h,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfnmls\\tz[0-9]+\\.s,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfnmls\\tz[0-9]+\\.d,} 2 } } */"}, {"sha": "b08d4d8ebfb369972c1c552de82ebb17662ab836", "filename": "gcc/testsuite/gcc.target/aarch64/sve/vcond_15_run.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_15_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_15_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_15_run.c?ref=b41d1f6ed753bf7ae7e68f745e50c26ee65b5711", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include \"vcond_15.c\"\n+\n+#define TEST_LOOP(INV, TYPE, CMPTYPE, SUFFIX)\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    TYPE a[N], b[N], c[N], d[N];\t\t\t\\\n+    CMPTYPE cond[N];\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tb[i] = i % 15;\t\t\t\t\t\\\n+\tc[i] = i % 9 + 11;\t\t\t\t\\\n+\td[i] = i % 13 + 14;\t\t\t\t\\\n+\tcond[i] = i % 17;\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+    f_##INV##_##SUFFIX (a, b, c, d, cond);\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tdouble mb = (INV & 1 ? -b[i] : b[i]);\t\t\\\n+\tdouble mc = c[i];\t\t\t\t\\\n+\tdouble md = (INV & 2 ? -d[i] : d[i]);\t\t\\\n+\tdouble fma = __builtin_fma (mb, mc, md);\t\\\n+\tdouble truev = (INV & 4 ? -fma : fma);\t\t\\\n+\tif (a[i] != (i % 17 < 10 ? truev : d[i]))\t\\\n+\t  __builtin_abort ();\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+  }\n+\n+int\n+main (void)\n+{\n+  FOR_EACH_INV (TEST_LOOP)\n+  return 0;\n+}"}, {"sha": "7fa98716830bd576d10a6f7e7a0fd83147bf7808", "filename": "gcc/testsuite/gcc.target/aarch64/sve/vcond_16.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_16.c?ref=b41d1f6ed753bf7ae7e68f745e50c26ee65b5711", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#define N 119\n+\n+#define DEF_LOOP(INV, TYPE, CMPTYPE, SUFFIX)\t\t\t\\\n+  void __attribute__ ((noipa))\t\t\t\t\t\\\n+  f_##INV##_##SUFFIX (TYPE *restrict a, TYPE *restrict b,\t\\\n+\t\t      TYPE *restrict c, TYPE *restrict d,\t\\\n+\t\t      CMPTYPE *restrict cond)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tTYPE mb = (INV & 1 ? -b[i] : b[i]);\t\t\t\\\n+\tTYPE mc = c[i];\t\t\t\t\t\t\\\n+\tTYPE md = (INV & 2 ? -d[i] : d[i]);\t\t\t\\\n+\tTYPE fma = __builtin_fma##SUFFIX (mb, mc, md);\t\t\\\n+\tTYPE truev = (INV & 4 ? -fma : fma);\t\t\t\\\n+\ta[i] = cond[i] < 10 ? truev : 10;\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  }\n+\n+#define FOR_EACH_TYPE(T, INV)\t\t\t\\\n+  T (INV, _Float16, short, f16)\t\t\t\\\n+  T (INV, float, float, f32)\t\t\t\\\n+  T (INV, double, double, f64)\n+\n+#define FOR_EACH_INV(T)\t\t\t\t\\\n+  FOR_EACH_TYPE (T, 0)\t\t\t\t\\\n+  FOR_EACH_TYPE (T, 1)\t\t\t\t\\\n+  FOR_EACH_TYPE (T, 2)\t\t\t\t\\\n+  FOR_EACH_TYPE (T, 3)\t\t\t\t\\\n+  FOR_EACH_TYPE (T, 4)\t\t\t\t\\\n+  FOR_EACH_TYPE (T, 5)\t\t\t\t\\\n+  FOR_EACH_TYPE (T, 6)\t\t\t\t\\\n+  FOR_EACH_TYPE (T, 7)\n+\n+FOR_EACH_INV (DEF_LOOP)\n+\n+/* { dg-final { scan-assembler-times {\\tsel\\t} 24 } } */\n+/* { dg-final { scan-assembler-not {\\tmovprfx\\t} } } */\n+/* { dg-final { scan-assembler-not {\\tmov\\tz[0-9]+\\.., z[0-9]+} } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfmla\\tz[0-9]+\\.h,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfmla\\tz[0-9]+\\.s,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfmla\\tz[0-9]+\\.d,} 2 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfmls\\tz[0-9]+\\.h,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfmls\\tz[0-9]+\\.s,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfmls\\tz[0-9]+\\.d,} 2 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfnmla\\tz[0-9]+\\.h,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfnmla\\tz[0-9]+\\.s,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfnmla\\tz[0-9]+\\.d,} 2 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfnmls\\tz[0-9]+\\.h,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfnmls\\tz[0-9]+\\.s,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfnmls\\tz[0-9]+\\.d,} 2 } } */"}, {"sha": "d4e5afd4d57ecb183c36afe26cad446fd0963fe9", "filename": "gcc/testsuite/gcc.target/aarch64/sve/vcond_16_run.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_16_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_16_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_16_run.c?ref=b41d1f6ed753bf7ae7e68f745e50c26ee65b5711", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include \"vcond_16.c\"\n+\n+#define TEST_LOOP(INV, TYPE, CMPTYPE, SUFFIX)\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    TYPE a[N], b[N], c[N], d[N];\t\t\t\\\n+    CMPTYPE cond[N];\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tb[i] = i % 15;\t\t\t\t\t\\\n+\tc[i] = i % 9 + 11;\t\t\t\t\\\n+\td[i] = i % 13 + 14;\t\t\t\t\\\n+\tcond[i] = i % 17;\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+    f_##INV##_##SUFFIX (a, b, c, d, cond);\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tdouble mb = (INV & 1 ? -b[i] : b[i]);\t\t\\\n+\tdouble mc = c[i];\t\t\t\t\\\n+\tdouble md = (INV & 2 ? -d[i] : d[i]);\t\t\\\n+\tdouble fma = __builtin_fma (mb, mc, md);\t\\\n+\tdouble truev = (INV & 4 ? -fma : fma);\t\t\\\n+\tif (a[i] != (i % 17 < 10 ? truev : 10))\t\t\\\n+\t  __builtin_abort ();\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+  }\n+\n+int\n+main (void)\n+{\n+  FOR_EACH_INV (TEST_LOOP)\n+  return 0;\n+}"}]}