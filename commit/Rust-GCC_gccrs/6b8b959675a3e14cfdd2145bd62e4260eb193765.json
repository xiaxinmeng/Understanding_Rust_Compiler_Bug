{"sha": "6b8b959675a3e14cfdd2145bd62e4260eb193765", "node_id": "C_kwDOANBUbNoAKDZiOGI5NTk2NzVhM2UxNGNmZGQyMTQ1YmQ2MmU0MjYwZWIxOTM3NjU", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-10-08T13:54:23Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-11-09T08:55:58Z"}, "message": "Convert strlen pass from evrp to ranger.\n\nThe following patch converts the strlen pass from evrp to ranger,\nleaving DOM as the last remaining user.\n\nNo additional cleanups have been done.  For example, the strlen pass\nstill has uses of VR_ANTI_RANGE, and the sprintf still passes around\npairs of integers instead of using a proper range.  Fixing this\ncould further improve these passes.\n\nBasically the entire patch is just adjusting the calls to range_of_expr\nto include context.  The previous context of si->stmt was mostly\nempty, so not really useful ;-).\n\nWith ranger we are now able to remove the range calculation from\nbefore_dom_children entirely.  Just working with the ranger on-demand\ncatches all the strlen and sprintf testcases with the exception of\nbuiltin-sprintf-warn-22.c which is due to a limitation of the sprintf\ncode.  I have XFAILed the test and documented what the problem is.\n\nOn a positive note, these changes found two possible sprintf overflow\nbugs in the C++ and Fortran front-ends which I have fixed below.\n\nTested on x86-64 Linux.\n\ngcc/ChangeLog:\n\n\t* tree-ssa-strlen.c (compare_nonzero_chars): Pass statement\n\tcontext to ranger.\n\t(get_addr_stridx): Same.\n\t(get_stridx): Same.\n\t(get_range_strlen_dynamic): Same.\n\t(handle_builtin_strlen): Same.\n\t(handle_builtin_strchr): Same.\n\t(handle_builtin_strcpy): Same.\n\t(maybe_diag_stxncpy_trunc): Same.\n\t(handle_builtin_stxncpy_strncat): Same.\n\t(handle_builtin_memcpy): Same.\n\t(handle_builtin_strcat): Same.\n\t(handle_alloc_call): Same.\n\t(handle_builtin_memset): Same.\n\t(handle_builtin_string_cmp): Same.\n\t(handle_pointer_plus): Same.\n\t(count_nonzero_bytes_addr): Same.\n\t(count_nonzero_bytes): Same.\n\t(handle_store): Same.\n\t(fold_strstr_to_strncmp): Same.\n\t(handle_integral_assign): Same.\n\t(check_and_optimize_stmt): Same.\n\t(class strlen_dom_walker): Replace evrp with ranger.\n\t(strlen_dom_walker::before_dom_children): Remove evrp.\n\t(strlen_dom_walker::after_dom_children): Remove evrp.\n\t* gimple-ssa-warn-access.cc (maybe_check_access_sizes):\n\tRestrict sprintf output.\n\ngcc/cp/ChangeLog:\n\n\t* ptree.c (cxx_print_xnode): Add more space to pfx array.\n\ngcc/fortran/ChangeLog:\n\n\t* misc.c (gfc_dummy_typename): Make sure ts->kind is\n\tnon-negative.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-22.c: XFAIL.", "tree": {"sha": "aaeb4a8542b28b6f9362a21c8127e1ecda9498a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aaeb4a8542b28b6f9362a21c8127e1ecda9498a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b8b959675a3e14cfdd2145bd62e4260eb193765", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b8b959675a3e14cfdd2145bd62e4260eb193765", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b8b959675a3e14cfdd2145bd62e4260eb193765", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b8b959675a3e14cfdd2145bd62e4260eb193765/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc6b8cd9a21b363815998b11e5cc7529557a9ce5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc6b8cd9a21b363815998b11e5cc7529557a9ce5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc6b8cd9a21b363815998b11e5cc7529557a9ce5"}], "stats": {"total": 154, "additions": 85, "deletions": 69}, "files": [{"sha": "ca7884db39bf80aee50ce04575b4d7d920545e31", "filename": "gcc/cp/ptree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b8b959675a3e14cfdd2145bd62e4260eb193765/gcc%2Fcp%2Fptree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b8b959675a3e14cfdd2145bd62e4260eb193765/gcc%2Fcp%2Fptree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fptree.c?ref=6b8b959675a3e14cfdd2145bd62e4260eb193765", "patch": "@@ -292,7 +292,7 @@ cxx_print_xnode (FILE *file, tree node, int indent)\n \tfor (unsigned ix = 0; ix != len; ix++)\n \t  {\n \t    binding_cluster *cluster = &BINDING_VECTOR_CLUSTER (node, ix);\n-\t    char pfx[24];\n+\t    char pfx[32];\n \t    for (unsigned jx = 0; jx != BINDING_VECTOR_SLOTS_PER_CLUSTER; jx++)\n \t      if (cluster->indices[jx].span)\n \t\t{"}, {"sha": "a553e1ee6c5a07808fa5129d427da69493d773ab", "filename": "gcc/fortran/misc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b8b959675a3e14cfdd2145bd62e4260eb193765/gcc%2Ffortran%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b8b959675a3e14cfdd2145bd62e4260eb193765/gcc%2Ffortran%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmisc.c?ref=6b8b959675a3e14cfdd2145bd62e4260eb193765", "patch": "@@ -284,7 +284,7 @@ gfc_dummy_typename (gfc_typespec *ts)\n \t{\n \t  if (ts->kind == gfc_default_character_kind)\n \t    sprintf(buffer, \"CHARACTER(*)\");\n-\t  else if (ts->kind < 10)\n+\t  else if (ts->kind >= 0 && ts->kind < 10)\n \t    sprintf(buffer, \"CHARACTER(*,%d)\", ts->kind);\n \t  else\n \t    sprintf(buffer, \"CHARACTER(*,?)\");"}, {"sha": "073f122af31b04014da2403684ad981ebd60961c", "filename": "gcc/gimple-ssa-warn-access.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b8b959675a3e14cfdd2145bd62e4260eb193765/gcc%2Fgimple-ssa-warn-access.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b8b959675a3e14cfdd2145bd62e4260eb193765/gcc%2Fgimple-ssa-warn-access.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-access.cc?ref=6b8b959675a3e14cfdd2145bd62e4260eb193765", "patch": "@@ -3012,7 +3012,7 @@ pass_waccess::maybe_check_access_sizes (rdwr_map *rwm, tree fndecl, tree fntype,\n \t      char *s1 = print_generic_expr_to_str (sizrng[1]);\n \t      gcc_checking_assert (strlen (s0) + strlen (s1)\n \t\t\t\t   < sizeof sizstr - 4);\n-\t      sprintf (sizstr, \"[%s, %s]\", s0, s1);\n+\t      sprintf (sizstr, \"[%.37s, %.37s]\", s0, s1);\n \t      free (s1);\n \t    }\n \t  free (s0);"}, {"sha": "82eb5851c59b0bb6776de4a67a474cb8805adab0", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-22.c", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b8b959675a3e14cfdd2145bd62e4260eb193765/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-22.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b8b959675a3e14cfdd2145bd62e4260eb193765/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-22.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-22.c?ref=6b8b959675a3e14cfdd2145bd62e4260eb193765", "patch": "@@ -18,7 +18,18 @@ void g (char *s1, char *s2)\n   if (n + d + 1 >= 1025)\n     return;\n \n-  sprintf (b, \"%s.%s\", s1, s2);     // { dg-bogus \"\\\\\\[-Wformat-overflow\" }\n+  /* Ranger can find ranges here:\n+     [1] n_6: size_t [0, 1023]\n+     [2] d_8: size_t [0, 1023]\n+\n+     Whereas evrp can't really:\n+     [1] n_6: size_t [0, 9223372036854775805]\n+     [2] d_8: size_t [0, 9223372036854775805]\n+\n+     This is causing the sprintf warning pass to issue a false\n+     positive here.  */\n+\n+  sprintf (b, \"%s.%s\", s1, s2);     // { dg-bogus \"\\\\\\[-Wformat-overflow\" \"\" { xfail *-*-* } }\n \n   f (b);\n }"}, {"sha": "c0ec7d20a6082b8264adfce8dba358ff989e00f3", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 70, "deletions": 65, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b8b959675a3e14cfdd2145bd62e4260eb193765/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b8b959675a3e14cfdd2145bd62e4260eb193765/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=6b8b959675a3e14cfdd2145bd62e4260eb193765", "patch": "@@ -59,7 +59,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-loop.h\"\n #include \"tree-scalar-evolution.h\"\n #include \"vr-values.h\"\n-#include \"gimple-ssa-evrp-analyze.h\"\n+#include \"gimple-range.h\"\n #include \"tree-ssa.h\"\n \n /* A vector indexed by SSA_NAME_VERSION.  0 means unknown, positive value\n@@ -234,8 +234,7 @@ class strlen_pass : public dom_walker\n public:\n   strlen_pass (cdi_direction direction)\n     : dom_walker (direction),\n-      evrp (false),\n-      ptr_qry (&evrp, &var_cache),\n+      ptr_qry (&m_ranger, &var_cache),\n       var_cache (),\n       m_cleanup_cfg (false)\n   {\n@@ -277,15 +276,18 @@ class strlen_pass : public dom_walker\n \t\t\t   unsigned HOST_WIDE_INT len[2],\n \t\t\t   unsigned HOST_WIDE_INT *psize);\n   bool count_nonzero_bytes (tree expr_or_type,\n+\t\t\t    gimple *stmt,\n \t\t\t    unsigned lenrange[3], bool *nulterm,\n \t\t\t    bool *allnul, bool *allnonnul);\n   bool count_nonzero_bytes (tree exp,\n+\t\t\t    gimple *stmt,\n \t\t\t    unsigned HOST_WIDE_INT offset,\n \t\t\t    unsigned HOST_WIDE_INT nbytes,\n \t\t\t    unsigned lenrange[3], bool *nulterm,\n \t\t\t    bool *allnul, bool *allnonnul,\n \t\t\t    ssa_name_limit_t &snlim);\n   bool count_nonzero_bytes_addr (tree exp,\n+\t\t\t\t gimple *stmt,\n \t\t\t\t unsigned HOST_WIDE_INT offset,\n \t\t\t\t unsigned HOST_WIDE_INT nbytes,\n \t\t\t\t unsigned lenrange[3], bool *nulterm,\n@@ -295,9 +297,7 @@ class strlen_pass : public dom_walker\n \t\t\tunsigned HOST_WIDE_INT lenrng[2],\n \t\t\tunsigned HOST_WIDE_INT *size, bool *nulterm);\n \n-  /* EVRP analyzer used for printf argument range processing, and to\n-     track strlen results across integer variable assignments.  */\n-  evrp_range_analyzer evrp;\n+  gimple_ranger m_ranger;\n \n   /* A pointer_query object and its cache to store information about\n      pointers and their targets in.  */\n@@ -335,7 +335,8 @@ compare_nonzero_chars (strinfo *si, unsigned HOST_WIDE_INT off)\n    Uses RVALS to determine length range.  */\n \n static int\n-compare_nonzero_chars (strinfo *si, unsigned HOST_WIDE_INT off,\n+compare_nonzero_chars (strinfo *si, gimple *stmt,\n+\t\t       unsigned HOST_WIDE_INT off,\n \t\t       range_query *rvals)\n {\n   if (!si->nonzero_chars)\n@@ -348,7 +349,7 @@ compare_nonzero_chars (strinfo *si, unsigned HOST_WIDE_INT off,\n     return -1;\n \n   value_range vr;\n-  if (!rvals->range_of_expr (vr, si->nonzero_chars, si->stmt))\n+  if (!rvals->range_of_expr (vr, si->nonzero_chars, stmt))\n     return -1;\n   value_range_kind rng = vr.kind ();\n   if (rng != VR_RANGE)\n@@ -403,7 +404,8 @@ get_next_strinfo (strinfo *si)\n    information.  */\n \n static int\n-get_addr_stridx (tree exp, tree ptr, unsigned HOST_WIDE_INT *offset_out,\n+get_addr_stridx (tree exp, gimple *stmt,\n+\t\t tree ptr, unsigned HOST_WIDE_INT *offset_out,\n \t\t range_query *rvals = NULL)\n {\n   HOST_WIDE_INT off;\n@@ -442,7 +444,7 @@ get_addr_stridx (tree exp, tree ptr, unsigned HOST_WIDE_INT *offset_out,\n       unsigned HOST_WIDE_INT rel_off\n \t= (unsigned HOST_WIDE_INT) off - last->offset;\n       strinfo *si = get_strinfo (last->idx);\n-      if (si && compare_nonzero_chars (si, rel_off, rvals) >= 0)\n+      if (si && compare_nonzero_chars (si, stmt, rel_off, rvals) >= 0)\n \t{\n \t  if (offset_out)\n \t    {\n@@ -464,7 +466,8 @@ get_addr_stridx (tree exp, tree ptr, unsigned HOST_WIDE_INT *offset_out,\n    When nonnull, uses RVALS to determine range information.  */\n \n static int\n-get_stridx (tree exp, wide_int offrng[2] = NULL, range_query *rvals = NULL)\n+get_stridx (tree exp, gimple *stmt,\n+\t    wide_int offrng[2] = NULL, range_query *rvals = NULL)\n {\n   if (offrng)\n     offrng[0] = offrng[1] = wi::zero (TYPE_PRECISION (ptrdiff_type_node));\n@@ -601,7 +604,7 @@ get_stridx (tree exp, wide_int offrng[2] = NULL, range_query *rvals = NULL)\n \n   if (TREE_CODE (exp) == ADDR_EXPR)\n     {\n-      int idx = get_addr_stridx (TREE_OPERAND (exp, 0), exp, NULL);\n+      int idx = get_addr_stridx (TREE_OPERAND (exp, 0), stmt, exp, NULL);\n       if (idx != 0)\n \treturn idx;\n     }\n@@ -1095,7 +1098,7 @@ get_range_strlen_dynamic (tree src, gimple *stmt,\n \t\t\t  c_strlen_data *pdata, bitmap *visited,\n \t\t\t  range_query *rvals, unsigned *pssa_def_max)\n {\n-  int idx = get_stridx (src);\n+  int idx = get_stridx (src, stmt);\n   if (!idx)\n     {\n       if (TREE_CODE (src) == SSA_NAME)\n@@ -2200,7 +2203,7 @@ strlen_pass::handle_builtin_strlen ()\n   tree src = gimple_call_arg (stmt, 0);\n   tree bound = (DECL_FUNCTION_CODE (callee) == BUILT_IN_STRNLEN\n \t\t? gimple_call_arg (stmt, 1) : NULL_TREE);\n-  int idx = get_stridx (src);\n+  int idx = get_stridx (src, stmt);\n   if (idx || (bound && integer_zerop (bound)))\n     {\n       strinfo *si = NULL;\n@@ -2380,7 +2383,7 @@ strlen_pass::handle_builtin_strchr ()\n   if (!check_nul_terminated_array (NULL_TREE, src))\n     return;\n \n-  int idx = get_stridx (src);\n+  int idx = get_stridx (src, stmt);\n   if (idx)\n     {\n       strinfo *si = NULL;\n@@ -2486,12 +2489,12 @@ strlen_pass::handle_builtin_strcpy (built_in_function bcode)\n   src = gimple_call_arg (stmt, 1);\n   dst = gimple_call_arg (stmt, 0);\n   lhs = gimple_call_lhs (stmt);\n-  idx = get_stridx (src);\n+  idx = get_stridx (src, stmt);\n   si = NULL;\n   if (idx > 0)\n     si = get_strinfo (idx);\n \n-  didx = get_stridx (dst);\n+  didx = get_stridx (dst, stmt);\n   olddsi = NULL;\n   oldlen = NULL_TREE;\n   if (didx > 0)\n@@ -2893,7 +2896,7 @@ maybe_diag_stxncpy_trunc (gimple_stmt_iterator gsi, tree src, tree cnt,\n      when ssa_ver_to_stridx is empty.  That implies the caller isn't\n      running under the control of this pass and ssa_ver_to_stridx hasn't\n      been created yet.  */\n-  int sidx = ssa_ver_to_stridx.length () ? get_stridx (src) : 0;\n+  int sidx = ssa_ver_to_stridx.length () ? get_stridx (src, stmt) : 0;\n   if (sidx < 0 && wi::gtu_p (cntrange[0], ~sidx))\n     return false;\n \n@@ -3167,7 +3170,7 @@ strlen_pass::handle_builtin_stxncpy_strncat (bool append_p)\n      a lower bound).  */\n   tree dstlenp1 = NULL_TREE, srclenp1 = NULL_TREE;;\n \n-  int didx = get_stridx (dst);\n+  int didx = get_stridx (dst, stmt);\n   if (strinfo *sidst = didx > 0 ? get_strinfo (didx) : NULL)\n     {\n       /* Compute the size of the destination string including the nul\n@@ -3193,7 +3196,7 @@ strlen_pass::handle_builtin_stxncpy_strncat (bool append_p)\n       dst = sidst->ptr;\n     }\n \n-  int sidx = get_stridx (src);\n+  int sidx = get_stridx (src, stmt);\n   strinfo *sisrc = sidx > 0 ? get_strinfo (sidx) : NULL;\n   if (sisrc)\n     {\n@@ -3302,7 +3305,7 @@ strlen_pass::handle_builtin_memcpy (built_in_function bcode)\n   tree src = gimple_call_arg (stmt, 1);\n   tree dst = gimple_call_arg (stmt, 0);\n \n-  int didx = get_stridx (dst);\n+  int didx = get_stridx (dst, stmt);\n   strinfo *olddsi = NULL;\n   if (didx > 0)\n     olddsi = get_strinfo (didx);\n@@ -3316,7 +3319,7 @@ strlen_pass::handle_builtin_memcpy (built_in_function bcode)\n       adjust_last_stmt (olddsi, stmt, false);\n     }\n \n-  int idx = get_stridx (src);\n+  int idx = get_stridx (src, stmt);\n   if (idx == 0)\n     return;\n \n@@ -3491,7 +3494,7 @@ strlen_pass::handle_builtin_strcat (built_in_function bcode)\n \n   tree lhs = gimple_call_lhs (stmt);\n \n-  didx = get_stridx (dst);\n+  didx = get_stridx (dst, stmt);\n   if (didx < 0)\n     return;\n \n@@ -3501,7 +3504,7 @@ strlen_pass::handle_builtin_strcat (built_in_function bcode)\n \n   srclen = NULL_TREE;\n   si = NULL;\n-  idx = get_stridx (src);\n+  idx = get_stridx (src, stmt);\n   if (idx < 0)\n     srclen = build_int_cst (size_type_node, ~idx);\n   else if (idx > 0)\n@@ -3723,7 +3726,7 @@ strlen_pass::handle_alloc_call (built_in_function bcode)\n   if (lhs == NULL_TREE)\n     return;\n \n-  gcc_assert (get_stridx (lhs) == 0);\n+  gcc_assert (get_stridx (lhs, stmt) == 0);\n   int idx = new_stridx (lhs);\n   tree length = NULL_TREE;\n   if (bcode == BUILT_IN_CALLOC)\n@@ -3759,7 +3762,7 @@ strlen_pass::handle_builtin_memset (bool *zero_write)\n   tree ptr = gimple_call_arg (memset_stmt, 0);\n   /* Set to the non-constant offset added to PTR.  */\n   wide_int offrng[2];\n-  int idx1 = get_stridx (ptr, offrng, ptr_qry.rvals);\n+  int idx1 = get_stridx (ptr, memset_stmt, offrng, ptr_qry.rvals);\n   if (idx1 <= 0)\n     return false;\n   strinfo *si1 = get_strinfo (idx1);\n@@ -4250,8 +4253,8 @@ strlen_pass::handle_builtin_string_cmp ()\n \n   tree arg1 = gimple_call_arg (stmt, 0);\n   tree arg2 = gimple_call_arg (stmt, 1);\n-  int idx1 = get_stridx (arg1);\n-  int idx2 = get_stridx (arg2);\n+  int idx1 = get_stridx (arg1, stmt);\n+  int idx2 = get_stridx (arg2, stmt);\n \n   /* For strncmp set to the value of the third argument if known.  */\n   HOST_WIDE_INT bound = -1;\n@@ -4389,7 +4392,7 @@ strlen_pass::handle_pointer_plus ()\n {\n   gimple *stmt = gsi_stmt (m_gsi);\n   tree lhs = gimple_assign_lhs (stmt), off;\n-  int idx = get_stridx (gimple_assign_rhs1 (stmt));\n+  int idx = get_stridx (gimple_assign_rhs1 (stmt), stmt);\n   strinfo *si, *zsi;\n \n   if (idx == 0)\n@@ -4482,7 +4485,7 @@ nonzero_bytes_for_type (tree type, unsigned lenrange[3],\n    Returns true on success and false otherwise.  */\n \n bool\n-strlen_pass::count_nonzero_bytes (tree exp,\n+strlen_pass::count_nonzero_bytes (tree exp, gimple *stmt,\n \t\t\t\t  unsigned HOST_WIDE_INT offset,\n \t\t\t\t  unsigned HOST_WIDE_INT nbytes,\n \t\t\t\t  unsigned lenrange[3], bool *nulterm,\n@@ -4502,7 +4505,8 @@ strlen_pass::count_nonzero_bytes (tree exp,\n \t     exact value is not known) recurse once to set the range\n \t     for an arbitrary constant.  */\n \t  exp = build_int_cst (type, 1);\n-\t  return count_nonzero_bytes (exp, offset, 1, lenrange,\n+\t  return count_nonzero_bytes (exp, stmt,\n+\t\t\t\t      offset, 1, lenrange,\n \t\t\t\t      nulterm, allnul, allnonnul, snlim);\n \t}\n \n@@ -4529,7 +4533,8 @@ strlen_pass::count_nonzero_bytes (tree exp,\n \t  for (unsigned i = 0; i != n; i++)\n \t    {\n \t      tree def = gimple_phi_arg_def (stmt, i);\n-\t      if (!count_nonzero_bytes (def, offset, nbytes, lenrange, nulterm,\n+\t      if (!count_nonzero_bytes (def, stmt,\n+\t\t\t\t\toffset, nbytes, lenrange, nulterm,\n \t\t\t\t\tallnul, allnonnul, snlim))\n \t\treturn false;\n \t    }\n@@ -4586,7 +4591,8 @@ strlen_pass::count_nonzero_bytes (tree exp,\n \treturn false;\n \n       /* Handle MEM_REF = SSA_NAME types of assignments.  */\n-      return count_nonzero_bytes_addr (arg, offset, nbytes, lenrange, nulterm,\n+      return count_nonzero_bytes_addr (arg, stmt,\n+\t\t\t\t       offset, nbytes, lenrange, nulterm,\n \t\t\t\t       allnul, allnonnul, snlim);\n     }\n \n@@ -4698,14 +4704,14 @@ strlen_pass::count_nonzero_bytes (tree exp,\n    bytes that are pointed to by EXP, which should be a pointer.  */\n \n bool\n-strlen_pass::count_nonzero_bytes_addr (tree exp,\n+strlen_pass::count_nonzero_bytes_addr (tree exp, gimple *stmt,\n \t\t\t\t       unsigned HOST_WIDE_INT offset,\n \t\t\t\t       unsigned HOST_WIDE_INT nbytes,\n \t\t\t\t       unsigned lenrange[3], bool *nulterm,\n \t\t\t\t       bool *allnul, bool *allnonnul,\n \t\t\t\t       ssa_name_limit_t &snlim)\n {\n-  int idx = get_stridx (exp);\n+  int idx = get_stridx (exp, stmt);\n   if (idx > 0)\n     {\n       strinfo *si = get_strinfo (idx);\n@@ -4721,7 +4727,7 @@ strlen_pass::count_nonzero_bytes_addr (tree exp,\n \t       && TREE_CODE (si->nonzero_chars) == SSA_NAME)\n \t{\n \t  value_range vr;\n-\t  ptr_qry.rvals->range_of_expr (vr, si->nonzero_chars, si->stmt);\n+\t  ptr_qry.rvals->range_of_expr (vr, si->nonzero_chars, stmt);\n \t  if (vr.kind () != VR_RANGE)\n \t    return false;\n \n@@ -4767,7 +4773,8 @@ strlen_pass::count_nonzero_bytes_addr (tree exp,\n     }\n \n   if (TREE_CODE (exp) == ADDR_EXPR)\n-    return count_nonzero_bytes (TREE_OPERAND (exp, 0), offset, nbytes,\n+    return count_nonzero_bytes (TREE_OPERAND (exp, 0), stmt,\n+\t\t\t\toffset, nbytes,\n \t\t\t\tlenrange, nulterm, allnul, allnonnul, snlim);\n \n   if (TREE_CODE (exp) == SSA_NAME)\n@@ -4786,7 +4793,8 @@ strlen_pass::count_nonzero_bytes_addr (tree exp,\n \t  for (unsigned i = 0; i != n; i++)\n \t    {\n \t      tree def = gimple_phi_arg_def (stmt, i);\n-\t      if (!count_nonzero_bytes_addr (def, offset, nbytes, lenrange,\n+\t      if (!count_nonzero_bytes_addr (def, stmt,\n+\t\t\t\t\t     offset, nbytes, lenrange,\n \t\t\t\t\t     nulterm, allnul, allnonnul,\n \t\t\t\t\t     snlim))\n \t\treturn false;\n@@ -4814,7 +4822,7 @@ strlen_pass::count_nonzero_bytes_addr (tree exp,\n    (the results of strlen).  */\n \n bool\n-strlen_pass::count_nonzero_bytes (tree expr_or_type,\n+strlen_pass::count_nonzero_bytes (tree expr_or_type, gimple *stmt,\n \t\t\t\t  unsigned lenrange[3], bool *nulterm,\n \t\t\t\t  bool *allnul, bool *allnonnul)\n {\n@@ -4833,7 +4841,8 @@ strlen_pass::count_nonzero_bytes (tree expr_or_type,\n \n   ssa_name_limit_t snlim;\n   tree expr = expr_or_type;\n-  return count_nonzero_bytes (expr, 0, 0, lenrange, nulterm, allnul, allnonnul,\n+  return count_nonzero_bytes (expr, stmt,\n+\t\t\t      0, 0, lenrange, nulterm, allnul, allnonnul,\n \t\t\t      snlim);\n }\n \n@@ -4885,18 +4894,19 @@ strlen_pass::handle_store (bool *zero_write)\n \t     least OFFSET nonzero characters.  This is trivially true if\n \t     OFFSET is zero.  */\n \t  offset = tree_to_uhwi (mem_offset);\n-\t  idx = get_stridx (TREE_OPERAND (lhs, 0));\n+\t  idx = get_stridx (TREE_OPERAND (lhs, 0), stmt);\n \t  if (idx > 0)\n \t    si = get_strinfo (idx);\n \t  if (offset == 0)\n \t    ssaname = TREE_OPERAND (lhs, 0);\n-\t  else if (si == NULL || compare_nonzero_chars (si, offset, rvals) < 0)\n+\t  else if (si == NULL\n+\t\t   || compare_nonzero_chars (si, stmt, offset, rvals) < 0)\n \t    {\n \t      *zero_write = rhs ? initializer_zerop (rhs) : false;\n \n \t      bool dummy;\n \t      unsigned lenrange[] = { UINT_MAX, 0, 0 };\n-\t      if (count_nonzero_bytes (rhs ? rhs : storetype, lenrange,\n+\t      if (count_nonzero_bytes (rhs ? rhs : storetype, stmt, lenrange,\n \t\t\t\t       &dummy, &dummy, &dummy))\n \t\tmaybe_warn_overflow (stmt, true, lenrange[2]);\n \n@@ -4906,7 +4916,7 @@ strlen_pass::handle_store (bool *zero_write)\n     }\n   else\n     {\n-      idx = get_addr_stridx (lhs, NULL_TREE, &offset, rvals);\n+      idx = get_addr_stridx (lhs, stmt, NULL_TREE, &offset, rvals);\n       if (idx > 0)\n \tsi = get_strinfo (idx);\n     }\n@@ -4929,7 +4939,8 @@ strlen_pass::handle_store (bool *zero_write)\n   bool full_string_p;\n \n   const bool ranges_valid\n-    = count_nonzero_bytes (rhs ? rhs : storetype, lenrange, &full_string_p,\n+    = count_nonzero_bytes (rhs ? rhs : storetype, stmt,\n+\t\t\t   lenrange, &full_string_p,\n \t\t\t   &storing_all_zeros_p, &storing_all_nonzero_p);\n \n   if (ranges_valid)\n@@ -4961,15 +4972,18 @@ strlen_pass::handle_store (bool *zero_write)\n \t{\n \t  /* The offset of the last stored byte.  */\n \t  unsigned HOST_WIDE_INT endoff = offset + lenrange[2] - 1;\n-\t  store_before_nul[0] = compare_nonzero_chars (si, offset, rvals);\n+\t  store_before_nul[0]\n+\t    = compare_nonzero_chars (si, stmt, offset, rvals);\n \t  if (endoff == offset)\n \t    store_before_nul[1] = store_before_nul[0];\n \t  else\n-\t    store_before_nul[1] = compare_nonzero_chars (si, endoff, rvals);\n+\t    store_before_nul[1]\n+\t      = compare_nonzero_chars (si, stmt, endoff, rvals);\n \t}\n       else\n \t{\n-\t  store_before_nul[0] = compare_nonzero_chars (si, offset, rvals);\n+\t  store_before_nul[0]\n+\t    = compare_nonzero_chars (si, stmt, offset, rvals);\n \t  store_before_nul[1] = store_before_nul[0];\n \t  gcc_assert (offset == 0 || store_before_nul[0] >= 0);\n \t}\n@@ -5194,7 +5208,7 @@ fold_strstr_to_strncmp (tree rhs1, tree rhs2, gimple *stmt)\n \t{\n \t  tree arg1 = gimple_call_arg (call_stmt, 1);\n \t  tree arg1_len = NULL_TREE;\n-\t  int idx = get_stridx (arg1);\n+\t  int idx = get_stridx (arg1, call_stmt);\n \n \t  if (idx)\n \t    {\n@@ -5406,7 +5420,7 @@ strlen_pass::handle_integral_assign (bool *cleanup_eh)\n       tree rhs1 = gimple_assign_rhs1 (stmt);\n       if (code == MEM_REF)\n \t{\n-\t  idx = get_stridx (TREE_OPERAND (rhs1, 0));\n+\t  idx = get_stridx (TREE_OPERAND (rhs1, 0), stmt);\n \t  if (idx > 0)\n \t    {\n \t      strinfo *si = get_strinfo (idx);\n@@ -5423,7 +5437,7 @@ strlen_pass::handle_integral_assign (bool *cleanup_eh)\n \t    }\n \t}\n       if (idx <= 0)\n-\tidx = get_addr_stridx (rhs1, NULL_TREE, &coff);\n+\tidx = get_addr_stridx (rhs1, stmt, NULL_TREE, &coff);\n       if (idx > 0)\n \t{\n \t  strinfo *si = get_strinfo (idx);\n@@ -5485,7 +5499,8 @@ strlen_pass::handle_integral_assign (bool *cleanup_eh)\n \t  unsigned lenrange[] = { UINT_MAX, 0, 0 };\n \t  tree rhs = gimple_assign_rhs1 (stmt);\n \t  const bool ranges_valid\n-\t    = count_nonzero_bytes (rhs, lenrange, &full_string_p,\n+\t    = count_nonzero_bytes (rhs, stmt,\n+\t\t\t\t   lenrange, &full_string_p,\n \t\t\t\t   &storing_all_zeros_p,\n \t\t\t\t   &storing_all_nonzero_p);\n \t  if (ranges_valid)\n@@ -5582,7 +5597,7 @@ strlen_pass::check_and_optimize_stmt (bool *cleanup_eh)\n \t      || (gimple_assign_cast_p (stmt)\n \t\t  && POINTER_TYPE_P (TREE_TYPE (gimple_assign_rhs1 (stmt)))))\n \t    {\n-\t      int idx = get_stridx (gimple_assign_rhs1 (stmt));\n+\t      int idx = get_stridx (gimple_assign_rhs1 (stmt), stmt);\n \t      ssa_ver_to_stridx[SSA_NAME_VERSION (lhs)] = idx;\n \t    }\n \t  else if (gimple_assign_rhs_code (stmt) == POINTER_PLUS_EXPR)\n@@ -5672,8 +5687,6 @@ strlen_pass::~strlen_pass ()\n edge\n strlen_pass::before_dom_children (basic_block bb)\n {\n-  evrp.enter (bb);\n-\n   basic_block dombb = get_immediate_dominator (CDI_DOMINATORS, bb);\n \n   if (dombb == NULL)\n@@ -5730,12 +5743,12 @@ strlen_pass::before_dom_children (basic_block bb)\n       tree result = gimple_phi_result (phi);\n       if (!virtual_operand_p (result) && POINTER_TYPE_P (TREE_TYPE (result)))\n \t{\n-\t  int idx = get_stridx (gimple_phi_arg_def (phi, 0));\n+\t  int idx = get_stridx (gimple_phi_arg_def (phi, 0), phi);\n \t  if (idx != 0)\n \t    {\n \t      unsigned int i, n = gimple_phi_num_args (phi);\n \t      for (i = 1; i < n; i++)\n-\t\tif (idx != get_stridx (gimple_phi_arg_def (phi, i)))\n+\t\tif (idx != get_stridx (gimple_phi_arg_def (phi, i), phi))\n \t\t  break;\n \t      if (i == n)\n \t\tssa_ver_to_stridx[SSA_NAME_VERSION (result)] = idx;\n@@ -5748,12 +5761,6 @@ strlen_pass::before_dom_children (basic_block bb)\n   /* Attempt to optimize individual statements.  */\n   for (m_gsi = gsi_start_bb (bb); !gsi_end_p (m_gsi); )\n     {\n-      gimple *stmt = gsi_stmt (m_gsi);\n-\n-      /* First record ranges generated by this statement so they\n-\t can be used by printf argument processing.  */\n-      evrp.record_ranges_from_stmt (stmt, false);\n-\n       /* Reset search depth preformance counter.  */\n       ptr_qry.depth = 0;\n \n@@ -5776,8 +5783,6 @@ strlen_pass::before_dom_children (basic_block bb)\n void\n strlen_pass::after_dom_children (basic_block bb)\n {\n-  evrp.leave (bb);\n-\n   if (bb->aux)\n     {\n       stridx_to_strinfo = ((vec<strinfo *, va_heap, vl_embed> *) bb->aux);"}]}