{"sha": "d2d8936f3faf747a3305f39bc4d12a37fbe3e8cb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDJkODkzNmYzZmFmNzQ3YTMzMDVmMzliYzRkMTJhMzdmYmUzZThjYg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2004-06-24T15:59:52Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2004-06-24T15:59:52Z"}, "message": "tree-ssa-dom.c (record_dominating_conditions): New function.\n\n\n\t* tree-ssa-dom.c (record_dominating_conditions): New function.\n\t(dom_opt_finalize_block, get_eq_expr_value): Use it.\n\n\t* gcc.dg/tree-ssa/20040624-1.c: New test.\n\nFrom-SVN: r83597", "tree": {"sha": "3e3da230b9f168fafc545c3116e8e37645a1edb2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e3da230b9f168fafc545c3116e8e37645a1edb2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2d8936f3faf747a3305f39bc4d12a37fbe3e8cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2d8936f3faf747a3305f39bc4d12a37fbe3e8cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2d8936f3faf747a3305f39bc4d12a37fbe3e8cb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2d8936f3faf747a3305f39bc4d12a37fbe3e8cb/comments", "author": null, "committer": null, "parents": [{"sha": "d01a8ee025fac8ecd9619c3a868d1979d64bc7b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d01a8ee025fac8ecd9619c3a868d1979d64bc7b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d01a8ee025fac8ecd9619c3a868d1979d64bc7b6"}], "stats": {"total": 207, "additions": 207, "deletions": 0}, "files": [{"sha": "9876fc878ae130a6bc59fcbef621d167e4c52e97", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2d8936f3faf747a3305f39bc4d12a37fbe3e8cb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2d8936f3faf747a3305f39bc4d12a37fbe3e8cb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d2d8936f3faf747a3305f39bc4d12a37fbe3e8cb", "patch": "@@ -1,3 +1,8 @@\n+2004-06-24  Jeff Law  <law@redhat.com>\n+\n+\t* tree-ssa-dom.c (record_dominating_conditions): New function.\n+\t(dom_opt_finalize_block, get_eq_expr_value): Use it.\n+\n 2004-06-24  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* calls.c (shift_returned_value): Fix handling of non-integer"}, {"sha": "f7acf36ee0b5c70ab6c08e583d4cb4125202736f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2d8936f3faf747a3305f39bc4d12a37fbe3e8cb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2d8936f3faf747a3305f39bc4d12a37fbe3e8cb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d2d8936f3faf747a3305f39bc4d12a37fbe3e8cb", "patch": "@@ -1,3 +1,7 @@\n+2004-06-24  Jeff Law  <law@redhat.com>\n+\n+\t* gcc.dg/tree-ssa/20040624-1.c: New test.\n+\n 2004-06-24  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* gcc.c-torture/compile/20040624-1.c: New test."}, {"sha": "54f37433d95f0d051c3528be8b1e90ac78927f5e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20040624-1.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2d8936f3faf747a3305f39bc4d12a37fbe3e8cb/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20040624-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2d8936f3faf747a3305f39bc4d12a37fbe3e8cb/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20040624-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20040624-1.c?ref=d2d8936f3faf747a3305f39bc4d12a37fbe3e8cb", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fdump-tree-dom1\" } */\n+  \n+void bar1 (void);\n+void bar2 (void);\n+\n+void\n+foo (unsigned int a, unsigned int b)\n+{\n+  if (a >= b)\n+    bar1 ();\n+  else if (a <= b)\n+    bar2 ();\n+}\n+\n+/* The second conditional is redundant since we know it must be\n+   true (to reach the second condition we know a < b via the first\n+   conditional.  */\n+\n+/* { dg-final { scan-tree-dump-times \"if \" 1 \"dom1\" } } */\n+"}, {"sha": "a4151423cf36bd4ce035bd49418a7bf194ffd6d7", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2d8936f3faf747a3305f39bc4d12a37fbe3e8cb/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2d8936f3faf747a3305f39bc4d12a37fbe3e8cb/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=d2d8936f3faf747a3305f39bc4d12a37fbe3e8cb", "patch": "@@ -226,6 +226,7 @@ static hashval_t avail_expr_hash (const void *);\n static int avail_expr_eq (const void *, const void *);\n static void htab_statistics (FILE *, htab_t);\n static void record_cond (tree, tree, varray_type *);\n+static void record_dominating_conditions (tree, varray_type *);\n static void record_const_or_copy (tree, tree, varray_type *);\n static void record_equality (tree, tree, varray_type *);\n static tree update_rhs_and_lookup_avail_expr (tree, tree, varray_type *,\n@@ -1228,6 +1229,7 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n \t  if (TREE_CODE_CLASS (cond_code) == '<')\n \t    {\n \t      record_cond (cond, boolean_true_node, &bd->avail_exprs);\n+\t      record_dominating_conditions (cond, &bd->avail_exprs);\n \t      record_cond (inverted, boolean_false_node, &bd->avail_exprs);\n \t    }\n \t  else if (cond_code == SSA_NAME)\n@@ -1257,6 +1259,7 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n \t    {\n \t      record_cond (cond, boolean_false_node, &bd->avail_exprs);\n \t      record_cond (inverted, boolean_true_node, &bd->avail_exprs);\n+\t      record_dominating_conditions (inverted, &bd->avail_exprs);\n \t    }\n \t  else if (cond_code == SSA_NAME)\n \t    record_const_or_copy (cond, boolean_false_node,\n@@ -1606,6 +1609,178 @@ record_cond (tree cond, tree value, varray_type *block_avail_exprs_p)\n     free (element);\n }\n \n+/* COND is a condition which is known to be true.   Record variants of\n+   COND which must also be true.\n+\n+   For example, if a < b is true, then a <= b must also be true.  */\n+\n+static void\n+record_dominating_conditions (tree cond, varray_type *block_avail_exprs_p)\n+{\n+  switch (TREE_CODE (cond))\n+    {\n+    case LT_EXPR:\n+      record_cond (build2 (LE_EXPR, boolean_type_node,\n+\t\t\t   TREE_OPERAND (cond, 0),\n+\t\t\t   TREE_OPERAND (cond, 1)),\n+\t\t   boolean_true_node,\n+\t\t   block_avail_exprs_p);\n+      record_cond (build2 (ORDERED_EXPR, boolean_type_node,\n+\t\t\t   TREE_OPERAND (cond, 0),\n+\t\t\t   TREE_OPERAND (cond, 1)),\n+\t\t   boolean_true_node,\n+\t\t   block_avail_exprs_p);\n+      record_cond (build2 (NE_EXPR, boolean_type_node,\n+\t\t\t   TREE_OPERAND (cond, 0),\n+\t\t\t   TREE_OPERAND (cond, 1)),\n+\t\t   boolean_true_node,\n+\t\t   block_avail_exprs_p);\n+      record_cond (build2 (LTGT_EXPR, boolean_type_node,\n+\t\t\t   TREE_OPERAND (cond, 0),\n+\t\t\t   TREE_OPERAND (cond, 1)),\n+\t\t   boolean_true_node,\n+\t\t   block_avail_exprs_p);\n+      break;\n+\n+    case GT_EXPR:\n+      record_cond (build2 (GE_EXPR, boolean_type_node,\n+\t\t\t   TREE_OPERAND (cond, 0),\n+\t\t\t   TREE_OPERAND (cond, 1)),\n+\t\t   boolean_true_node,\n+\t\t   block_avail_exprs_p);\n+      record_cond (build2 (ORDERED_EXPR, boolean_type_node,\n+\t\t\t   TREE_OPERAND (cond, 0),\n+\t\t\t   TREE_OPERAND (cond, 1)),\n+\t\t   boolean_true_node,\n+\t\t   block_avail_exprs_p);\n+      record_cond (build2 (NE_EXPR, boolean_type_node,\n+\t\t\t   TREE_OPERAND (cond, 0),\n+\t\t\t   TREE_OPERAND (cond, 1)),\n+\t\t   boolean_true_node,\n+\t\t   block_avail_exprs_p);\n+      record_cond (build2 (LTGT_EXPR, boolean_type_node,\n+\t\t\t   TREE_OPERAND (cond, 0),\n+\t\t\t   TREE_OPERAND (cond, 1)),\n+\t\t   boolean_true_node,\n+\t\t   block_avail_exprs_p);\n+      break;\n+\n+    case GE_EXPR:\n+    case LE_EXPR:\n+      record_cond (build2 (ORDERED_EXPR, boolean_type_node,\n+\t\t\t   TREE_OPERAND (cond, 0),\n+\t\t\t   TREE_OPERAND (cond, 1)),\n+\t\t   boolean_true_node,\n+\t\t   block_avail_exprs_p);\n+      break;\n+\n+    case EQ_EXPR:\n+      record_cond (build2 (ORDERED_EXPR, boolean_type_node,\n+\t\t\t   TREE_OPERAND (cond, 0),\n+\t\t\t   TREE_OPERAND (cond, 1)),\n+\t\t   boolean_true_node,\n+\t\t   block_avail_exprs_p);\n+      record_cond (build2 (LE_EXPR, boolean_type_node,\n+\t\t\t   TREE_OPERAND (cond, 0),\n+\t\t\t   TREE_OPERAND (cond, 1)),\n+\t\t   boolean_true_node,\n+\t\t   block_avail_exprs_p);\n+      record_cond (build2 (GE_EXPR, boolean_type_node,\n+\t\t\t   TREE_OPERAND (cond, 0),\n+\t\t\t   TREE_OPERAND (cond, 1)),\n+\t\t   boolean_true_node,\n+\t\t   block_avail_exprs_p);\n+      break;\n+\n+    case UNORDERED_EXPR:\n+      record_cond (build2 (NE_EXPR, boolean_type_node,\n+\t\t\t   TREE_OPERAND (cond, 0),\n+\t\t\t   TREE_OPERAND (cond, 1)),\n+\t\t   boolean_true_node,\n+\t\t   block_avail_exprs_p);\n+      record_cond (build2 (UNLE_EXPR, boolean_type_node,\n+\t\t\t   TREE_OPERAND (cond, 0),\n+\t\t\t   TREE_OPERAND (cond, 1)),\n+\t\t   boolean_true_node,\n+\t\t   block_avail_exprs_p);\n+      record_cond (build2 (UNGE_EXPR, boolean_type_node,\n+\t\t\t   TREE_OPERAND (cond, 0),\n+\t\t\t   TREE_OPERAND (cond, 1)),\n+\t\t   boolean_true_node,\n+\t\t   block_avail_exprs_p);\n+      record_cond (build2 (UNEQ_EXPR, boolean_type_node,\n+\t\t\t   TREE_OPERAND (cond, 0),\n+\t\t\t   TREE_OPERAND (cond, 1)),\n+\t\t   boolean_true_node,\n+\t\t   block_avail_exprs_p);\n+      record_cond (build2 (UNLT_EXPR, boolean_type_node,\n+\t\t\t   TREE_OPERAND (cond, 0),\n+\t\t\t   TREE_OPERAND (cond, 1)),\n+\t\t   boolean_true_node,\n+\t\t   block_avail_exprs_p);\n+      record_cond (build2 (UNGT_EXPR, boolean_type_node,\n+\t\t\t   TREE_OPERAND (cond, 0),\n+\t\t\t   TREE_OPERAND (cond, 1)),\n+\t\t   boolean_true_node,\n+\t\t   block_avail_exprs_p);\n+      break;\n+\n+    case UNLT_EXPR:\n+      record_cond (build2 (UNLE_EXPR, boolean_type_node,\n+\t\t\t   TREE_OPERAND (cond, 0),\n+\t\t\t   TREE_OPERAND (cond, 1)),\n+\t\t   boolean_true_node,\n+\t\t   block_avail_exprs_p);\n+      record_cond (build2 (NE_EXPR, boolean_type_node,\n+\t\t\t   TREE_OPERAND (cond, 0),\n+\t\t\t   TREE_OPERAND (cond, 1)),\n+\t\t   boolean_true_node,\n+\t\t   block_avail_exprs_p);\n+      break;\n+\n+    case UNGT_EXPR:\n+      record_cond (build2 (UNGE_EXPR, boolean_type_node,\n+\t\t\t   TREE_OPERAND (cond, 0),\n+\t\t\t   TREE_OPERAND (cond, 1)),\n+\t\t   boolean_true_node,\n+\t\t   block_avail_exprs_p);\n+      record_cond (build2 (NE_EXPR, boolean_type_node,\n+\t\t\t   TREE_OPERAND (cond, 0),\n+\t\t\t   TREE_OPERAND (cond, 1)),\n+\t\t   boolean_true_node,\n+\t\t   block_avail_exprs_p);\n+      break;\n+\n+    case UNEQ_EXPR:\n+      record_cond (build2 (UNLE_EXPR, boolean_type_node,\n+\t\t\t   TREE_OPERAND (cond, 0),\n+\t\t\t   TREE_OPERAND (cond, 1)),\n+\t\t   boolean_true_node,\n+\t\t   block_avail_exprs_p);\n+      record_cond (build2 (UNGE_EXPR, boolean_type_node,\n+\t\t\t   TREE_OPERAND (cond, 0),\n+\t\t\t   TREE_OPERAND (cond, 1)),\n+\t\t   boolean_true_node,\n+\t\t   block_avail_exprs_p);\n+      break;\n+\n+    case LTGT_EXPR:\n+      record_cond (build2 (NE_EXPR, boolean_type_node,\n+\t\t\t   TREE_OPERAND (cond, 0),\n+\t\t\t   TREE_OPERAND (cond, 1)),\n+\t\t   boolean_true_node,\n+\t\t   block_avail_exprs_p);\n+      record_cond (build2 (ORDERED_EXPR, boolean_type_node,\n+\t\t\t   TREE_OPERAND (cond, 0),\n+\t\t\t   TREE_OPERAND (cond, 1)),\n+\t\t   boolean_true_node,\n+\t\t   block_avail_exprs_p);\n+\n+    default:\n+      break;\n+    }\n+}\n+\n /* A helper function for record_const_or_copy and record_equality.\n    Do the work of recording the value and undo info.  */\n \n@@ -3044,6 +3219,7 @@ get_eq_expr_value (tree if_stmt,\n \t  if (true_arm)\n \t    {\n \t      record_cond (cond, boolean_true_node, block_avail_exprs_p);\n+\t      record_dominating_conditions (cond, block_avail_exprs_p);\n \t      record_cond (inverted, boolean_false_node, block_avail_exprs_p);\n \n \t      if (TREE_CONSTANT (op1))\n@@ -3062,6 +3238,7 @@ get_eq_expr_value (tree if_stmt,\n \t    {\n \n \t      record_cond (inverted, boolean_true_node, block_avail_exprs_p);\n+\t      record_dominating_conditions (inverted, block_avail_exprs_p);\n \t      record_cond (cond, boolean_false_node, block_avail_exprs_p);\n \n \t      if (TREE_CONSTANT (op1))"}]}