{"sha": "ab29fdfc6f2682e996600cadf6ac272bc6f60532", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWIyOWZkZmM2ZjI2ODJlOTk2NjAwY2FkZjZhYzI3MmJjNmY2MDUzMg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-03-14T10:09:52Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-03-14T10:09:52Z"}, "message": "(convert_to_integer): Convert integer_one_node to proper type before\ntree_int_cst_lt call.\n\nFrom-SVN: r6777", "tree": {"sha": "65e41a167189a79c9184ef9d1532ce832e0abfeb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65e41a167189a79c9184ef9d1532ce832e0abfeb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab29fdfc6f2682e996600cadf6ac272bc6f60532", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab29fdfc6f2682e996600cadf6ac272bc6f60532", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab29fdfc6f2682e996600cadf6ac272bc6f60532", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab29fdfc6f2682e996600cadf6ac272bc6f60532/comments", "author": null, "committer": null, "parents": [{"sha": "ff3225e75cb196c53e8cd7491759a111c44878f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff3225e75cb196c53e8cd7491759a111c44878f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff3225e75cb196c53e8cd7491759a111c44878f9"}], "stats": {"total": 44, "additions": 23, "deletions": 21}, "files": [{"sha": "c34e5615ef0baf0a21892c56c1b4af59888f116e", "filename": "gcc/convert.c", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab29fdfc6f2682e996600cadf6ac272bc6f60532/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab29fdfc6f2682e996600cadf6ac272bc6f60532/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=ab29fdfc6f2682e996600cadf6ac272bc6f60532", "patch": "@@ -170,41 +170,43 @@ convert_to_integer (type, expr)\n       else if (outprec >= inprec)\n \treturn build1 (NOP_EXPR, type, expr);\n \n-/* Here detect when we can distribute the truncation down past some arithmetic.\n-   For example, if adding two longs and converting to an int,\n-   we can equally well convert both to ints and then add.\n-   For the operations handled here, such truncation distribution\n-   is always safe.\n-   It is desirable in these cases:\n-   1) when truncating down to full-word from a larger size\n-   2) when truncating takes no work.\n-   3) when at least one operand of the arithmetic has been extended\n-   (as by C's default conversions).  In this case we need two conversions\n-   if we do the arithmetic as already requested, so we might as well\n-   truncate both and then combine.  Perhaps that way we need only one.\n-\n-   Note that in general we cannot do the arithmetic in a type\n-   shorter than the desired result of conversion, even if the operands\n-   are both extended from a shorter type, because they might overflow\n-   if combined in that type.  The exceptions to this--the times when\n-   two narrow values can be combined in their narrow type even to\n-   make a wider result--are handled by \"shorten\" in build_binary_op.  */\n+      /* Here detect when we can distribute the truncation down past some\n+\t arithmetic.  For example, if adding two longs and converting to an\n+\t int, we can equally well convert both to ints and then add.\n+\t For the operations handled here, such truncation distribution\n+\t is always safe.\n+\t It is desirable in these cases:\n+\t 1) when truncating down to full-word from a larger size\n+\t 2) when truncating takes no work.\n+\t 3) when at least one operand of the arithmetic has been extended\n+\t (as by C's default conversions).  In this case we need two conversions\n+\t if we do the arithmetic as already requested, so we might as well\n+\t truncate both and then combine.  Perhaps that way we need only one.\n+\n+\t Note that in general we cannot do the arithmetic in a type\n+\t shorter than the desired result of conversion, even if the operands\n+\t are both extended from a shorter type, because they might overflow\n+\t if combined in that type.  The exceptions to this--the times when\n+\t two narrow values can be combined in their narrow type even to\n+\t make a wider result--are handled by \"shorten\" in build_binary_op.  */\n \n       switch (ex_form)\n \t{\n \tcase RSHIFT_EXPR:\n \t  /* We can pass truncation down through right shifting\n \t     when the shift count is a nonpositive constant.  */\n \t  if (TREE_CODE (TREE_OPERAND (expr, 1)) == INTEGER_CST\n-\t      && tree_int_cst_lt (TREE_OPERAND (expr, 1), integer_one_node))\n+\t      && tree_int_cst_lt (TREE_OPERAND (expr, 1),\n+\t\t\t\t  convert (TREE_TYPE (TREE_OPERAND (expr, 1)),\n+\t\t\t\t\t   integer_one_node)))\n \t    goto trunc1;\n \t  break;\n \n \tcase LSHIFT_EXPR:\n \t  /* We can pass truncation down through left shifting\n \t     when the shift count is a nonnegative constant.  */\n \t  if (TREE_CODE (TREE_OPERAND (expr, 1)) == INTEGER_CST\n-\t      && ! tree_int_cst_lt (TREE_OPERAND (expr, 1), integer_zero_node)\n+\t      && tree_int_cst_sgn (TREE_OPERAND (expr, 1)) >= 0\n \t      && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST)\n \t    {\n \t      /* If shift count is less than the width of the truncated type,"}]}