{"sha": "7b1b4aed94bc2787c2e8654bb7a678c56f96a214", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2IxYjRhZWQ5NGJjMjc4N2MyZTg2NTRiYjdhNjc4YzU2Zjk2YTIxNA==", "commit": {"author": {"name": "Steven Bosscher", "email": "stevenb@suse.de", "date": "2004-06-12T13:17:39Z"}, "committer": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2004-06-12T13:17:39Z"}, "message": "gcse.c (record_set_info): Use predicates like REG_P.\n\n\t* gcse.c (record_set_info): Use predicates like REG_P.\n\t(mems_conflict_for_gcse_p): Likewise.\n\t(load_killed_in_block_p): Likewise.\n\t(hash_expr_1): Likewise.\n\t(insert_set_in_table): Likewise.\n\t(gcse_constant_p): Likewise.\n\t(hash_scan_set): Likewise.\n\t(hash_scan_insn): Likewise.\n\t(canon_list_insert): Likewise.\n\t(record_last_mem_set_info): Likewise.\n\t(record_last_set_info): Likewise.\n\t(compute_hash_table_work): Likewise.\n\t(mark_set): Likewise.\n\t(mark_clobber): Likewise.\n\t(mark_oprs_set): Likewise.\n\t(compute_transp): Likewise.\n\t(find_avail_set): Likewise.\n\t(cprop_insn): Likewise.\n\t(do_local_cprop): Likewise.\n\t(cprop): Likewise.\n\t(find_implicit_sets): Likewise.\n\t(find_bypass_set): Likewise.\n\t(bypass_conditional_jumps): Likewise.\n\t(insert_insn_end_bb): Likewise.\n\t(pre_insert_copy_insn): Likewise.\n\t(compute_transpout): Likewise.\n\t(next_ls_expr): Likewise.\n\t(invalidate_any_buried_refs): Likewise.\n\t(compute_ld_motion_mems): Likewise.\n\t(reg_set_info): Likewise.\n\t(reg_clear_last_set): Likewise.\n\t(find_moveable_store): Likewise.\n\t(compute_store_table): Likewise.\n\t(find_loads): Likewise.\n\t(store_killed_in_insn): Likewise.\n\t(insert_insn_start_bb): Likewise.\n\t(reg_set_between_after_reload_p): Likewise.\n\t(reg_used_between_after_reload_p): Likewise.\n\t(is_jump_table_basic_block): Likewise.\n\t(gcse_after_reload): Likewise.\n\t(hash_scan_set_after_reload): Likewise.\n\t(compute_hash_table_after_reload): Likewise.\n\nCo-Authored-By: Andreas Jaeger <aj@suse.de>\n\nFrom-SVN: r83026", "tree": {"sha": "a4c4741e36a0cc8d87150d30f2d4237dd22150b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a4c4741e36a0cc8d87150d30f2d4237dd22150b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b1b4aed94bc2787c2e8654bb7a678c56f96a214", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b1b4aed94bc2787c2e8654bb7a678c56f96a214", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b1b4aed94bc2787c2e8654bb7a678c56f96a214", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b1b4aed94bc2787c2e8654bb7a678c56f96a214/comments", "author": null, "committer": null, "parents": [{"sha": "ff6ea709cbe6cb3c54184c8f40f1cdbc794f8473", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff6ea709cbe6cb3c54184c8f40f1cdbc794f8473", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff6ea709cbe6cb3c54184c8f40f1cdbc794f8473"}], "stats": {"total": 231, "additions": 137, "deletions": 94}, "files": [{"sha": "792940ca05999fb7089ddabc3d33a152d1142abd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1b4aed94bc2787c2e8654bb7a678c56f96a214/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1b4aed94bc2787c2e8654bb7a678c56f96a214/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7b1b4aed94bc2787c2e8654bb7a678c56f96a214", "patch": "@@ -1,3 +1,49 @@\n+2004-06-12  Steven Bosscher <stevenb@suse.de>,\n+\t    Andreas Jaeger  <aj@suse.de>\n+\n+\t* gcse.c (record_set_info): Use predicates like REG_P.\n+\t(mems_conflict_for_gcse_p): Likewise.\n+\t(load_killed_in_block_p): Likewise.\n+\t(hash_expr_1): Likewise.\n+\t(insert_set_in_table): Likewise.\n+\t(gcse_constant_p): Likewise.\n+\t(hash_scan_set): Likewise.\n+\t(hash_scan_insn): Likewise.\n+\t(canon_list_insert): Likewise.\n+\t(record_last_mem_set_info): Likewise.\n+\t(record_last_set_info): Likewise.\n+\t(compute_hash_table_work): Likewise.\n+\t(mark_set): Likewise.\n+\t(mark_clobber): Likewise.\n+\t(mark_oprs_set): Likewise.\n+\t(compute_transp): Likewise.\n+\t(find_avail_set): Likewise.\n+\t(cprop_insn): Likewise.\n+\t(do_local_cprop): Likewise.\n+\t(cprop): Likewise.\n+\t(find_implicit_sets): Likewise.\n+\t(find_bypass_set): Likewise.\n+\t(bypass_conditional_jumps): Likewise.\n+\t(insert_insn_end_bb): Likewise.\n+\t(pre_insert_copy_insn): Likewise.\n+\t(compute_transpout): Likewise.\n+\t(next_ls_expr): Likewise.\n+\t(invalidate_any_buried_refs): Likewise.\n+\t(compute_ld_motion_mems): Likewise.\n+\t(reg_set_info): Likewise.\n+\t(reg_clear_last_set): Likewise.\n+\t(find_moveable_store): Likewise.\n+\t(compute_store_table): Likewise.\n+\t(find_loads): Likewise.\n+\t(store_killed_in_insn): Likewise.\n+\t(insert_insn_start_bb): Likewise.\n+\t(reg_set_between_after_reload_p): Likewise.\n+\t(reg_used_between_after_reload_p): Likewise.\n+\t(is_jump_table_basic_block): Likewise.\n+\t(gcse_after_reload): Likewise.\n+\t(hash_scan_set_after_reload): Likewise.\n+\t(compute_hash_table_after_reload): Likewise.\n+\n 2004-06-12  Steven Bosscher  <stevenb@suse.de>\n \n \t* rtl.h (MEM_P, NONJUMP_INSN_P, CALL_INSN_P): New predicates."}, {"sha": "20baed8a9efdcfbf5c30655fe74406608224d0f6", "filename": "gcc/gcse.c", "status": "modified", "additions": 91, "deletions": 94, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1b4aed94bc2787c2e8654bb7a678c56f96a214/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1b4aed94bc2787c2e8654bb7a678c56f96a214/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=7b1b4aed94bc2787c2e8654bb7a678c56f96a214", "patch": "@@ -232,8 +232,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    substitutions.\n \n    PRE is quite expensive in complicated functions because the DFA can take\n-   awhile to converge.  Hence we only perform one pass.  The parameter max-gcse-passes can\n-   be modified if one wants to experiment.\n+   a while to converge.  Hence we only perform one pass.  The parameter\n+   max-gcse-passes can be modified if one wants to experiment.\n \n    **********************\n \n@@ -288,7 +288,6 @@ static FILE *gcse_file;\n     * If we changed any jumps via cprop.\n \n     * If we added any labels via edge splitting.  */\n-\n static int run_jump_opt_after_gcse;\n \n /* Bitmaps are normally not included in debugging dumps.\n@@ -707,7 +706,7 @@ gcse_main (rtx f, FILE *file)\n   /* Return if there's nothing to do, or it is too expensive.  */\n   if (n_basic_blocks <= 1 || is_too_expensive (_(\"GCSE disabled\")))\n     return 0;\n-  \n+\n   gcc_obstack_init (&gcse_obstack);\n   bytes_used = 0;\n \n@@ -822,6 +821,7 @@ gcse_main (rtx f, FILE *file)\n \n   obstack_free (&gcse_obstack, NULL);\n   free_reg_set_mem ();\n+\n   /* We are finished with alias.  */\n   end_alias_analysis ();\n   allocate_reg_info (max_reg_num (), FALSE, FALSE);\n@@ -1013,7 +1013,8 @@ free_gcse_mem (void)\n    ABSALTERED.  */\n \n static void\n-compute_local_properties (sbitmap *transp, sbitmap *comp, sbitmap *antloc, struct hash_table *table)\n+compute_local_properties (sbitmap *transp, sbitmap *comp, sbitmap *antloc,\n+\t\t\t  struct hash_table *table)\n {\n   unsigned int i;\n \n@@ -1154,7 +1155,7 @@ record_set_info (rtx dest, rtx setter ATTRIBUTE_UNUSED, void *data)\n {\n   rtx record_set_insn = (rtx) data;\n \n-  if (GET_CODE (dest) == REG && REGNO (dest) >= FIRST_PSEUDO_REGISTER)\n+  if (REG_P (dest) && REGNO (dest) >= FIRST_PSEUDO_REGISTER)\n     record_one_set (REGNO (dest), record_set_insn);\n }\n \n@@ -1355,7 +1356,7 @@ mems_conflict_for_gcse_p (rtx dest, rtx setter ATTRIBUTE_UNUSED,\n   /* If DEST is not a MEM, then it will not conflict with the load.  Note\n      that function calls are assumed to clobber memory, but are handled\n      elsewhere.  */\n-  if (GET_CODE (dest) != MEM)\n+  if (! MEM_P (dest))\n     return;\n \n   /* If we are setting a MEM in our list of specially recognized MEMs,\n@@ -1403,7 +1404,7 @@ load_killed_in_block_p (basic_block bb, int uid_limit, rtx x, int avail_p)\n       /* If SETTER is a call everything is clobbered.  Note that calls\n \t to pure functions are never put on the list, so we need not\n \t worry about them.  */\n-      if (GET_CODE (setter) == CALL_INSN)\n+      if (CALL_P (setter))\n \treturn 1;\n \n       /* SETTER must be an INSN of some kind that sets memory.  Call\n@@ -1485,14 +1486,14 @@ hash_expr_1 (rtx x, enum machine_mode mode, int *do_not_record_p)\n   enum rtx_code code;\n   const char *fmt;\n \n-  /* Used to turn recursion into iteration.  We can't rely on GCC's\n-     tail-recursion elimination since we need to keep accumulating values\n-     in HASH.  */\n-\n   if (x == 0)\n     return hash;\n \n+  /* Used to turn recursion into iteration.  We can't rely on GCC's\n+     tail-recursion elimination since we need to keep accumulating values\n+     in HASH.  */\n  repeat:\n+\n   code = GET_CODE (x);\n   switch (code)\n     {\n@@ -1964,7 +1965,7 @@ insert_set_in_table (rtx x, rtx insn, struct hash_table *table)\n   struct occr *cur_occr, *last_occr = NULL;\n \n   if (GET_CODE (x) != SET\n-      || GET_CODE (SET_DEST (x)) != REG)\n+      || ! REG_P (SET_DEST (x)))\n     abort ();\n \n   hash = hash_set (REGNO (SET_DEST (x)), table->size);\n@@ -2048,12 +2049,10 @@ gcse_constant_p (rtx x)\n       && GET_CODE (XEXP (x, 1)) == CONST_INT)\n     return true;\n \n-\n   /* Consider a COMPARE of the same registers is a constant\n-    if they are not floating point registers.  */\n+     if they are not floating point registers.  */\n   if (GET_CODE(x) == COMPARE\n-      && GET_CODE (XEXP (x, 0)) == REG\n-      && GET_CODE (XEXP (x, 1)) == REG\n+      && REG_P (XEXP (x, 0)) && REG_P (XEXP (x, 1))\n       && REGNO (XEXP (x, 0)) == REGNO (XEXP (x, 1))\n       && ! FLOAT_MODE_P (GET_MODE (XEXP (x, 0)))\n       && ! FLOAT_MODE_P (GET_MODE (XEXP (x, 1))))\n@@ -2072,10 +2071,10 @@ hash_scan_set (rtx pat, rtx insn, struct hash_table *table)\n   rtx dest = SET_DEST (pat);\n   rtx note;\n \n-  if (GET_CODE (src) == CALL)\n+  if (CALL_P (src))\n     hash_scan_call (src, insn, table);\n \n-  else if (GET_CODE (dest) == REG)\n+  else if (REG_P (dest))\n     {\n       unsigned int regno = REGNO (dest);\n       rtx tmp;\n@@ -2105,7 +2104,7 @@ hash_scan_set (rtx pat, rtx insn, struct hash_table *table)\n \t     explicitly, it means address of parameter has been taken,\n \t     so we should not extend the lifetime of the pseudo.  */\n \t  && ((note = find_reg_note (insn, REG_EQUIV, NULL_RTX)) == 0\n-\t      || GET_CODE (XEXP (note, 0)) != MEM))\n+\t      || ! MEM_P (XEXP (note, 0))))\n \t{\n \t  /* An expression is not anticipatable if its operands are\n \t     modified before this insn or if this is not the only SET in\n@@ -2124,7 +2123,7 @@ hash_scan_set (rtx pat, rtx insn, struct hash_table *table)\n       /* Record sets for constant/copy propagation.  */\n       else if (table->set_p\n \t       && regno >= FIRST_PSEUDO_REGISTER\n-\t       && ((GET_CODE (src) == REG\n+\t       && ((REG_P (src)\n \t\t    && REGNO (src) >= FIRST_PSEUDO_REGISTER\n \t\t    && can_copy_p (GET_MODE (dest))\n \t\t    && REGNO (src) != regno)\n@@ -2140,7 +2139,7 @@ hash_scan_set (rtx pat, rtx insn, struct hash_table *table)\n   /* In case of store we want to consider the memory value as available in\n      the REG stored in that memory. This makes it possible to remove\n      redundant loads from due to stores to the same location.  */\n-  else if (flag_gcse_las && GET_CODE (src) == REG && GET_CODE (dest) == MEM)\n+  else if (flag_gcse_las && REG_P (src) && MEM_P (dest))\n       {\n         unsigned int regno = REGNO (src);\n \n@@ -2164,7 +2163,7 @@ hash_scan_set (rtx pat, rtx insn, struct hash_table *table)\n \t      explicitly, it means address of parameter has been taken,\n \t      so we should not extend the lifetime of the pseudo.  */\n \t   && ((note = find_reg_note (insn, REG_EQUIV, NULL_RTX)) == 0\n-\t       || GET_CODE (XEXP (note, 0)) != MEM))\n+\t       || ! MEM_P (XEXP (note, 0))))\n              {\n                /* Stores are never anticipatable.  */\n                int antic_p = 0;\n@@ -2232,13 +2231,13 @@ hash_scan_insn (rtx insn, struct hash_table *table, int in_libcall_block)\n \t  hash_scan_set (x, insn, table);\n \telse if (GET_CODE (x) == CLOBBER)\n \t  hash_scan_clobber (x, insn, table);\n-\telse if (GET_CODE (x) == CALL)\n+\telse if (CALL_P (x))\n \t  hash_scan_call (x, insn, table);\n       }\n \n   else if (GET_CODE (pat) == CLOBBER)\n     hash_scan_clobber (pat, insn, table);\n-  else if (GET_CODE (pat) == CALL)\n+  else if (CALL_P (pat))\n     hash_scan_call (pat, insn, table);\n }\n \n@@ -2331,7 +2330,7 @@ canon_list_insert (rtx dest ATTRIBUTE_UNUSED, rtx unused1 ATTRIBUTE_UNUSED,\n      that function calls are assumed to clobber memory, but are handled\n      elsewhere.  */\n \n-  if (GET_CODE (dest) != MEM)\n+  if (! MEM_P (dest))\n     return;\n \n   dest_addr = get_addr (XEXP (dest, 0));\n@@ -2360,7 +2359,7 @@ record_last_mem_set_info (rtx insn)\n   modify_mem_list[bb] = alloc_INSN_LIST (insn, modify_mem_list[bb]);\n   bitmap_set_bit (modify_mem_list_set, bb);\n \n-  if (GET_CODE (insn) == CALL_INSN)\n+  if (CALL_P (insn))\n     {\n       /* Note that traversals of this loop (other than for free-ing)\n \t will break after encountering a CALL_INSN.  So, there's no\n@@ -2385,9 +2384,9 @@ record_last_set_info (rtx dest, rtx setter ATTRIBUTE_UNUSED, void *data)\n   if (GET_CODE (dest) == SUBREG)\n     dest = SUBREG_REG (dest);\n \n-  if (GET_CODE (dest) == REG)\n+  if (REG_P (dest))\n     record_last_reg_set_info (last_set_insn, REGNO (dest));\n-  else if (GET_CODE (dest) == MEM\n+  else if (MEM_P (dest)\n \t   /* Ignore pushes, they clobber nothing.  */\n \t   && ! push_operand (dest, GET_MODE (dest)))\n     record_last_mem_set_info (last_set_insn);\n@@ -2446,7 +2445,7 @@ compute_hash_table_work (struct hash_table *table)\n \t  if (! INSN_P (insn))\n \t    continue;\n \n-\t  if (GET_CODE (insn) == CALL_INSN)\n+\t  if (CALL_P (insn))\n \t    {\n \t      bool clobbers_all = false;\n #ifdef NON_SAVING_SETJMP\n@@ -2741,12 +2740,12 @@ mark_set (rtx pat, rtx insn)\n \t || GET_CODE (dest) == STRICT_LOW_PART)\n     dest = XEXP (dest, 0);\n \n-  if (GET_CODE (dest) == REG)\n+  if (REG_P (dest))\n     SET_REGNO_REG_SET (reg_set_bitmap, REGNO (dest));\n-  else if (GET_CODE (dest) == MEM)\n+  else if (MEM_P (dest))\n     record_last_mem_set_info (insn);\n \n-  if (GET_CODE (SET_SRC (pat)) == CALL)\n+  if (CALL_P (SET_SRC (pat)))\n     mark_call (insn);\n }\n \n@@ -2760,7 +2759,7 @@ mark_clobber (rtx pat, rtx insn)\n   while (GET_CODE (clob) == SUBREG || GET_CODE (clob) == STRICT_LOW_PART)\n     clob = XEXP (clob, 0);\n \n-  if (GET_CODE (clob) == REG)\n+  if (REG_P (clob))\n     SET_REGNO_REG_SET (reg_set_bitmap, REGNO (clob));\n   else\n     record_last_mem_set_info (insn);\n@@ -2786,13 +2785,13 @@ mark_oprs_set (rtx insn)\n \t  mark_set (x, insn);\n \telse if (GET_CODE (x) == CLOBBER)\n \t  mark_clobber (x, insn);\n-\telse if (GET_CODE (x) == CALL)\n+\telse if (CALL_P (x))\n \t  mark_call (insn);\n       }\n \n   else if (GET_CODE (pat) == CLOBBER)\n     mark_clobber (pat, insn);\n-  else if (GET_CODE (pat) == CALL)\n+  else if (CALL_P (pat))\n     mark_call (insn);\n }\n \n@@ -2897,7 +2896,7 @@ compute_transp (rtx x, int indx, sbitmap *bmap, int set_p)\n \t    {\n \t      rtx dest, dest_addr;\n \n-\t      if (GET_CODE (XEXP (list_entry, 0)) == CALL_INSN)\n+\t      if (CALL_P (XEXP (list_entry, 0)))\n \t\t{\n \t\t  if (set_p)\n \t\t    SET_BIT (bmap[bb->index], indx);\n@@ -3156,7 +3155,7 @@ find_avail_set (int regno, rtx insn)\n \n       /* If the source of the set is anything except a register, then\n \t we have reached the end of the copy chain.  */\n-      if (GET_CODE (src) != REG)\n+      if (! REG_P (src))\n \tbreak;\n \n       /* Follow the copy chain, ie start another iteration of the loop\n@@ -3379,7 +3378,7 @@ cprop_insn (rtx insn, int alter_jumps)\n \t\treturn 1;\n \t    }\n \t}\n-      else if (GET_CODE (src) == REG\n+      else if (REG_P (src)\n \t       && REGNO (src) >= FIRST_PSEUDO_REGISTER\n \t       && REGNO (src) != regno)\n \t{\n@@ -3461,7 +3460,7 @@ do_local_cprop (rtx x, rtx insn, int alter_jumps, rtx *libcall_sp)\n \n   /* Rule out USE instructions and ASM statements as we don't want to\n      change the hard registers mentioned.  */\n-  if (GET_CODE (x) == REG\n+  if (REG_P (x)\n       && (REGNO (x) >= FIRST_PSEUDO_REGISTER\n           || (GET_CODE (PATTERN (insn)) != USE\n \t      && asm_noperands (PATTERN (insn)) < 0)))\n@@ -3488,7 +3487,7 @@ do_local_cprop (rtx x, rtx insn, int alter_jumps, rtx *libcall_sp)\n \t\t explicitly, it means address of parameter has been taken,\n \t\t so we should not extend the lifetime of the pseudo.  */\n \t      && (!(note = find_reg_note (l->setting_insn, REG_EQUIV, NULL_RTX))\n-\t\t  || GET_CODE (XEXP (note, 0)) != MEM))\n+\t\t  || ! MEM_P (XEXP (note, 0))))\n \t    newreg = this_rtx;\n \t}\n       if (newcnst && constprop_register (insn, x, newcnst, alter_jumps))\n@@ -3664,7 +3663,7 @@ cprop (int alter_jumps)\n \t    /* Keep track of everything modified by this insn.  */\n \t    /* ??? Need to be careful w.r.t. mods done to INSN.  Don't\n \t       call mark_oprs_set if we turned the insn into a NOTE.  */\n-\t    if (GET_CODE (insn) != NOTE)\n+\t    if (! NOTE_P (insn))\n \t      mark_oprs_set (insn);\n \t  }\n     }\n@@ -3791,7 +3790,7 @@ find_implicit_sets (void)\n \n \tif (cond\n \t    && (GET_CODE (cond) == EQ || GET_CODE (cond) == NE)\n-\t    && GET_CODE (XEXP (cond, 0)) == REG\n+\t    && REG_P (XEXP (cond, 0))\n \t    && REGNO (XEXP (cond, 0)) >= FIRST_PSEUDO_REGISTER\n \t    && implicit_set_cond_p (cond))\n \t  {\n@@ -3913,7 +3912,7 @@ find_bypass_set (int regno, int bb)\n       if (gcse_constant_p (src))\n \tresult = set;\n \n-      if (GET_CODE (src) != REG)\n+      if (! REG_P (src))\n \tbreak;\n \n       regno = REGNO (src);\n@@ -4050,7 +4049,7 @@ bypass_block (basic_block bb, rtx setcc, rtx jump)\n \t  /* Avoid unification of the edge with other edges from original\n \t     branch.  We would end up emitting the instruction on \"both\"\n \t     edges.  */\n-\t    \n+\n \t  if (dest && setcc && !CC0_P (SET_DEST (PATTERN (setcc))))\n \t    {\n \t      edge e2;\n@@ -4141,7 +4140,7 @@ bypass_conditional_jumps (void)\n \t\telse\n \t\t  break;\n \t      }\n-\t    else if (GET_CODE (insn) == JUMP_INSN)\n+\t    else if (JUMP_P (insn))\n \t      {\n \t\tif ((any_condjump_p (insn) || computed_jump_p (insn))\n \t\t    && onlyjump_p (insn))\n@@ -4427,7 +4426,7 @@ insert_insn_end_bb (struct expr *expr, basic_block bb, int pre)\n      handle cc0, etc. properly].  Similarly we need to care trapping\n      instructions in presence of non-call exceptions.  */\n \n-  if (GET_CODE (insn) == JUMP_INSN\n+  if (JUMP_P (insn)\n       || (GET_CODE (insn) == INSN\n \t  && (bb->succ->succ_next || (bb->succ->flags & EDGE_ABNORMAL))))\n     {\n@@ -4470,7 +4469,7 @@ insert_insn_end_bb (struct expr *expr, basic_block bb, int pre)\n \n   /* Likewise if the last insn is a call, as will happen in the presence\n      of exception handling.  */\n-  else if (GET_CODE (insn) == CALL_INSN\n+  else if (CALL_P (insn)\n \t   && (bb->succ->succ_next || (bb->succ->flags & EDGE_ABNORMAL)))\n     {\n       /* Keeping in mind SMALL_REGISTER_CLASSES and parameters in registers,\n@@ -4500,7 +4499,7 @@ insert_insn_end_bb (struct expr *expr, basic_block bb, int pre)\n \t If we inserted before the CODE_LABEL, then we would be putting\n \t the insn in the wrong basic block.  In that case, put the insn\n \t after the CODE_LABEL.  Also, respect NOTE_INSN_BASIC_BLOCK.  */\n-      while (GET_CODE (insn) == CODE_LABEL\n+      while (LABEL_P (insn)\n \t     || NOTE_INSN_BASIC_BLOCK_P (insn))\n \tinsn = NEXT_INSN (insn);\n \n@@ -4663,7 +4662,7 @@ pre_insert_copy_insn (struct expr *expr, rtx insn)\n   else\n     abort ();\n \n-  if (GET_CODE (SET_DEST (set)) == REG)\n+  if (REG_P (SET_DEST (set)))\n     {\n       old_reg = SET_DEST (set);\n       /* Check if we can modify the set destination in the original insn.  */\n@@ -4736,9 +4735,9 @@ pre_insert_copies (void)\n \t   expression wasn't deleted anywhere.  */\n \tif (expr->reaching_reg == NULL)\n \t  continue;\n-\t\n+\n \t/* Set when we add a copy for that expression.  */\n-\tadded_copy = 0; \n+\tadded_copy = 0;\n \n \tfor (occr = expr->antic_occr; occr != NULL; occr = occr->next)\n \t  {\n@@ -4771,7 +4770,7 @@ pre_insert_copies (void)\n \t      }\n \t  }\n \n- \t  if (added_copy)\n+\t  if (added_copy)\n             update_ld_motion_stores (expr);\n       }\n }\n@@ -5050,12 +5049,12 @@ compute_transpout (void)\n       /* Note that flow inserted a nop a the end of basic blocks that\n \t end in call instructions for reasons other than abnormal\n \t control flow.  */\n-      if (GET_CODE (BB_END (bb)) != CALL_INSN)\n+      if (! CALL_P (BB_END (bb)))\n \tcontinue;\n \n       for (i = 0; i < expr_hash_table.size; i++)\n \tfor (expr = expr_hash_table.table[i]; expr ; expr = expr->next_same_hash)\n-\t  if (GET_CODE (expr->expr) == MEM)\n+\t  if (MEM_P (expr->expr))\n \t    {\n \t      if (GET_CODE (XEXP (expr->expr, 0)) == SYMBOL_REF\n \t\t  && CONSTANT_POOL_ADDRESS_P (XEXP (expr->expr, 0)))\n@@ -5591,7 +5590,7 @@ next_ls_expr (struct ls_expr * ptr)\n static int\n simple_mem (rtx x)\n {\n-  if (GET_CODE (x) != MEM)\n+  if (! MEM_P (x))\n     return 0;\n \n   if (MEM_VOLATILE_P (x))\n@@ -5635,7 +5634,7 @@ invalidate_any_buried_refs (rtx x)\n   struct ls_expr * ptr;\n \n   /* Invalidate it in the list.  */\n-  if (GET_CODE (x) == MEM && simple_mem (x))\n+  if (MEM_P (x) && simple_mem (x))\n     {\n       ptr = ldst_entry (x);\n       ptr->invalid = 1;\n@@ -5685,10 +5684,10 @@ compute_ld_motion_mems (void)\n \t\t  rtx dest = SET_DEST (PATTERN (insn));\n \n \t\t  /* Check for a simple LOAD...  */\n-\t\t  if (GET_CODE (src) == MEM && simple_mem (src))\n+\t\t  if (MEM_P (src) && simple_mem (src))\n \t\t    {\n \t\t      ptr = ldst_entry (src);\n-\t\t      if (GET_CODE (dest) == REG)\n+\t\t      if (REG_P (dest))\n \t\t\tptr->loads = alloc_INSN_LIST (insn, ptr->loads);\n \t\t      else\n \t\t\tptr->invalid = 1;\n@@ -5703,11 +5702,11 @@ compute_ld_motion_mems (void)\n \t\t     will block any movement we might do later. We only care\n \t\t     about this exact pattern since those are the only\n \t\t     circumstance that we will ignore the aliasing info.  */\n-\t\t  if (GET_CODE (dest) == MEM && simple_mem (dest))\n+\t\t  if (MEM_P (dest) && simple_mem (dest))\n \t\t    {\n \t\t      ptr = ldst_entry (dest);\n \n-\t\t      if (GET_CODE (src) != MEM\n+\t\t      if (! MEM_P (src)\n \t\t\t  && GET_CODE (src) != ASM_OPERANDS\n \t\t\t  /* Check for REG manually since want_to_gcse_p\n \t\t\t     returns 0 for all REGs.  */\n@@ -5860,7 +5859,7 @@ reg_set_info (rtx dest, rtx setter ATTRIBUTE_UNUSED,\n   if (GET_CODE (dest) == SUBREG)\n     dest = SUBREG_REG (dest);\n \n-  if (GET_CODE (dest) == REG)\n+  if (REG_P (dest))\n     {\n       regvec[REGNO (dest)] = INSN_UID (compute_store_table_current_insn);\n       if (bb_reg)\n@@ -5880,7 +5879,7 @@ reg_clear_last_set (rtx dest, rtx setter ATTRIBUTE_UNUSED,\n   if (GET_CODE (dest) == SUBREG)\n     dest = SUBREG_REG (dest);\n \n-  if (GET_CODE (dest) == REG &&\n+  if (REG_P (dest) &&\n       dead_vec[REGNO (dest)] == INSN_UID (compute_store_table_current_insn))\n     dead_vec[REGNO (dest)] = 0;\n }\n@@ -6025,7 +6024,7 @@ find_moveable_store (rtx insn, int *regs_set_before, int *regs_set_after)\n \n   dest = SET_DEST (set);\n \n-  if (GET_CODE (dest) != MEM || MEM_VOLATILE_P (dest)\n+  if (! MEM_P (dest) || MEM_VOLATILE_P (dest)\n       || GET_MODE (dest) == BLKmode)\n     return;\n \n@@ -6137,7 +6136,7 @@ compute_store_table (void)\n \t  if (! INSN_P (insn))\n \t    continue;\n \n-\t  if (GET_CODE (insn) == CALL_INSN)\n+\t  if (CALL_P (insn))\n \t    {\n \t      bool clobbers_all = false;\n #ifdef NON_SAVING_SETJMP\n@@ -6170,7 +6169,7 @@ compute_store_table (void)\n \t  if (! INSN_P (insn))\n \t    continue;\n \n-\t  if (GET_CODE (insn) == CALL_INSN)\n+\t  if (CALL_P (insn))\n \t    {\n \t      bool clobbers_all = false;\n #ifdef NON_SAVING_SETJMP\n@@ -6194,7 +6193,7 @@ compute_store_table (void)\n \t  /* Unmark regs that are no longer set.  */\n \t  compute_store_table_current_insn = insn;\n \t  note_stores (pat, reg_clear_last_set, last_set_in);\n-\t  if (GET_CODE (insn) == CALL_INSN)\n+\t  if (CALL_P (insn))\n \t    {\n \t      bool clobbers_all = false;\n #ifdef NON_SAVING_SETJMP\n@@ -6288,7 +6287,7 @@ find_loads (rtx x, rtx store_pattern, int after)\n   if (GET_CODE (x) == SET)\n     x = SET_SRC (x);\n \n-  if (GET_CODE (x) == MEM)\n+  if (MEM_P (x))\n     {\n       if (load_kills_store (x, store_pattern, after))\n \treturn true;\n@@ -6320,7 +6319,7 @@ store_killed_in_insn (rtx x, rtx x_regs, rtx insn, int after)\n   if (!INSN_P (insn))\n     return false;\n \n-  if (GET_CODE (insn) == CALL_INSN)\n+  if (CALL_P (insn))\n     {\n       /* A normal or pure call might read from pattern,\n \t but a const call will not.  */\n@@ -6352,7 +6351,7 @@ store_killed_in_insn (rtx x, rtx x_regs, rtx insn, int after)\n \tdest = XEXP (dest, 0);\n \n       /* Check for memory stores to aliased objects.  */\n-      if (GET_CODE (dest) == MEM\n+      if (MEM_P (dest)\n \t  && !expr_equiv_p (dest, x))\n \t{\n \t  if (after)\n@@ -6537,8 +6536,8 @@ insert_insn_start_bb (rtx insn, basic_block bb)\n   rtx before = BB_HEAD (bb);\n   while (before != 0)\n     {\n-      if (GET_CODE (before) != CODE_LABEL\n-\t  && (GET_CODE (before) != NOTE\n+      if (! LABEL_P (before)\n+\t  && (! NOTE_P (before)\n \t      || NOTE_LINE_NUMBER (before) != NOTE_INSN_BASIC_BLOCK))\n \tbreak;\n       prev = before;\n@@ -6658,7 +6657,7 @@ remove_reachable_equiv_notes (basic_block bb, struct ls_expr *smexpr)\n \t  act = stack[--stack_top];\n \t}\n       bb = act->dest;\n-      \n+\n       if (bb == EXIT_BLOCK_PTR\n \t  || TEST_BIT (visited, bb->index))\n \t{\n@@ -6677,7 +6676,7 @@ remove_reachable_equiv_notes (basic_block bb, struct ls_expr *smexpr)\n \t}\n       else\n \tlast = NEXT_INSN (BB_END (bb));\n-  \n+\n       for (insn = BB_HEAD (bb); insn != last; insn = NEXT_INSN (insn))\n \tif (INSN_P (insn))\n \t  {\n@@ -6940,7 +6939,7 @@ is_too_expensive (const char *pass)\n   /* Trying to perform global optimizations on flow graphs which have\n      a high connectivity will take a long time and is unlikely to be\n      particularly useful.\n-     \n+\n      In normal circumstances a cfg should have about twice as many\n      edges as blocks.  But we do not want to punish small functions\n      which have a couple switch statements.  Rather than simply\n@@ -6951,7 +6950,7 @@ is_too_expensive (const char *pass)\n       if (warn_disabled_optimization)\n \twarning (\"%s: %d basic blocks and %d edges/basic block\",\n \t\t pass, n_basic_blocks, n_edges / n_basic_blocks);\n-      \n+\n       return true;\n     }\n \n@@ -7030,7 +7029,7 @@ reg_set_between_after_reload_p (rtx reg, rtx from_insn, rtx to_insn)\n   rtx insn;\n   int regno;\n \n-  if (GET_CODE (reg) != REG)\n+  if (! REG_P (reg))\n     abort ();\n   regno = REGNO (reg);\n \n@@ -7048,7 +7047,7 @@ reg_set_between_after_reload_p (rtx reg, rtx from_insn, rtx to_insn)\n       if (INSN_P (insn))\n \t{\n \t  if (FIND_REG_INC_NOTE (insn, reg)\n-\t      || (GET_CODE (insn) == CALL_INSN\n+\t      || (CALL_P (insn)\n \t\t  && call_used_regs[regno])\n \t      || find_reg_fusage (insn, CLOBBER, reg))\n \t    return insn;\n@@ -7069,7 +7068,7 @@ reg_used_between_after_reload_p (rtx reg, rtx from_insn, rtx to_insn)\n   rtx insn;\n   int regno;\n \n-  if (GET_CODE (reg) != REG)\n+  if (! REG_P (reg))\n     return to_insn;\n   regno = REGNO (reg);\n \n@@ -7084,7 +7083,7 @@ reg_used_between_after_reload_p (rtx reg, rtx from_insn, rtx to_insn)\n        insn = NEXT_INSN (insn))\n     if (INSN_P (insn)\n \t&& (reg_overlap_mentioned_p (reg, PATTERN (insn))\n-\t    || (GET_CODE (insn) == CALL_INSN\n+\t    || (CALL_P (insn)\n \t\t&& call_used_regs[regno])\n \t    || find_reg_fusage (insn, USE, reg)\n \t    || find_reg_fusage (insn, CLOBBER, reg)))\n@@ -7097,9 +7096,9 @@ reg_used_between_after_reload_p (rtx reg, rtx from_insn, rtx to_insn)\n static rtx\n get_avail_load_store_reg (rtx insn)\n {\n-  if (GET_CODE (SET_DEST (PATTERN (insn))) == REG)  /* A load.  */\n+  if (REG_P (SET_DEST (PATTERN (insn))))  /* A load.  */\n     return SET_DEST(PATTERN(insn));\n-  if (GET_CODE (SET_SRC (PATTERN (insn))) == REG)  /* A store.  */\n+  if (REG_P (SET_SRC (PATTERN (insn))))  /* A store.  */\n     return SET_SRC (PATTERN (insn));\n   abort ();\n }\n@@ -7111,9 +7110,7 @@ is_jump_table_basic_block (basic_block bb)\n {\n   rtx insn = BB_END (bb);\n \n-  if (GET_CODE (insn) == JUMP_INSN &&\n-      (GET_CODE (PATTERN (insn)) == ADDR_VEC\n-       || GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC))\n+  if (JUMP_TABLE_DATA_P (insn))\n     return true;\n   return false;\n }\n@@ -7324,7 +7321,7 @@ eliminate_partially_redundant_loads (basic_block bb, rtx insn,\n     delete_insn (insn);\n   else\n     a_occr->deleted_p = 1;\n-  \n+\n cleanup:\n \n   while (unavail_occrs)\n@@ -7380,8 +7377,8 @@ gcse_after_reload (void)\n \t  /* Is it a load - of the form (set (reg) (mem))?  */\n \t  if (GET_CODE (insn) == INSN\n               && GET_CODE (PATTERN (insn)) == SET\n-\t      && GET_CODE (SET_DEST (PATTERN (insn))) == REG\n-\t      && GET_CODE (SET_SRC (PATTERN (insn))) == MEM)\n+\t      && REG_P (SET_DEST (PATTERN (insn)))\n+\t      && MEM_P (SET_SRC (PATTERN (insn))))\n \t    {\n \t      rtx pat = PATTERN (insn);\n \t      rtx src = SET_SRC (pat);\n@@ -7435,10 +7432,10 @@ hash_scan_set_after_reload (rtx pat, rtx insn, struct hash_table *table)\n   rtx src = SET_SRC (pat);\n   rtx dest = SET_DEST (pat);\n \n-  if (GET_CODE (src) != MEM && GET_CODE (dest) != MEM)\n+  if (! MEM_P (src) && ! MEM_P (dest))\n     return;\n \n-  if (GET_CODE (dest) == REG)\n+  if (REG_P (dest))\n     {\n       if (/* Don't GCSE something if we can't do a reg/reg copy.  */\n \t  can_copy_p (GET_MODE (dest))\n@@ -7458,7 +7455,7 @@ hash_scan_set_after_reload (rtx pat, rtx insn, struct hash_table *table)\n \t    insert_expr_in_table (src, GET_MODE (dest), insn, 0, 1, table);\n \t}\n     }\n-  else if ((GET_CODE (src) == REG))\n+  else if (REG_P (src))\n     {\n       /* Only record sets of pseudo-regs in the hash table.  */\n       if (/* Don't GCSE something if we can't do a reg/reg copy.  */\n@@ -7528,7 +7525,7 @@ compute_hash_table_after_reload (struct hash_table *table)\n \t  if (! INSN_P (insn))\n \t    continue;\n \n-\t  if (GET_CODE (insn) == CALL_INSN)\n+\t  if (CALL_P (insn))\n \t    {\n \t      bool clobbers_all = false;\n \n@@ -7555,12 +7552,12 @@ compute_hash_table_after_reload (struct hash_table *table)\n \n \t\tsrc = SET_SRC (PATTERN (insn));\n \t\tdest = SET_DEST (PATTERN (insn));\n-\t\tif (GET_CODE (src) == MEM && auto_inc_p (XEXP (src, 0)))\n+\t\tif (MEM_P (src) && auto_inc_p (XEXP (src, 0)))\n \t\t  {\n \t\t    regno = REGNO (XEXP (XEXP (src, 0), 0));\n \t\t    record_last_reg_set_info (insn, regno);\n \t\t  }\n-\t\tif (GET_CODE (dest) == MEM && auto_inc_p (XEXP (dest, 0)))\n+\t\tif (MEM_P (dest) && auto_inc_p (XEXP (dest, 0)))\n \t\t  {\n \t\t    regno = REGNO (XEXP (XEXP (dest, 0), 0));\n \t\t    record_last_reg_set_info (insn, regno);"}]}