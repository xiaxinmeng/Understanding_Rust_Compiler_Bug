{"sha": "cae80939b64ac547c253fbb53f4c91c67d9e8ad5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2FlODA5MzliNjRhYzU0N2MyNTNmYmI1M2Y0YzkxYzY3ZDllOGFkNQ==", "commit": {"author": {"name": "John David Anglin", "email": "dave.anglin@nrc-cnrc.gc.ca", "date": "2004-06-21T23:49:04Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2004-06-21T23:49:04Z"}, "message": "re PR rtl-optimization/14782 (produces an unaligned data access at -O2)\n\n\tPR rtl-optimization/14782\n\t* pa.c (emit_move_sequence): Use SFmode for 4-byte modes when doing\n\tthe address checks for secondary reloads for loads from and stores\n\tto floating-point registers.\n\t* pa.h (EXTRA_CONSTRAINT, case T): Use SFmode for 4-byte modes\n\tin the address check.  Move work around for ELF32 targets to\n\tGO_IF_LEGITIMATE_ADDRESS.\n\t(GO_IF_LEGITIMATE_ADDRESS): Require constant offsets to be\n\tcorrectly aligned for DImode loads and stores.  Don't allow long\n\tSFmode displacements on ELF32.\n\nFrom-SVN: r83464", "tree": {"sha": "849135555b08d2fca700a6e4b72f2efaba5ccb2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/849135555b08d2fca700a6e4b72f2efaba5ccb2f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cae80939b64ac547c253fbb53f4c91c67d9e8ad5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cae80939b64ac547c253fbb53f4c91c67d9e8ad5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cae80939b64ac547c253fbb53f4c91c67d9e8ad5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cae80939b64ac547c253fbb53f4c91c67d9e8ad5/comments", "author": null, "committer": null, "parents": [{"sha": "a90fc8e0f36a0d855d46085d48b3f8c4c9a5698e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a90fc8e0f36a0d855d46085d48b3f8c4c9a5698e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a90fc8e0f36a0d855d46085d48b3f8c4c9a5698e"}], "stats": {"total": 92, "additions": 69, "deletions": 23}, "files": [{"sha": "9f124c17310e8212ff861e2445009e5464b1f3a5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cae80939b64ac547c253fbb53f4c91c67d9e8ad5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cae80939b64ac547c253fbb53f4c91c67d9e8ad5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cae80939b64ac547c253fbb53f4c91c67d9e8ad5", "patch": "@@ -1,3 +1,16 @@\n+2004-06-21  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\n+\tPR rtl-optimization/14782\n+\t* pa.c (emit_move_sequence): Use SFmode for 4-byte modes when doing\n+\tthe address checks for secondary reloads for loads from and stores\n+\tto floating-point registers.\n+\t* pa.h (EXTRA_CONSTRAINT, case T): Use SFmode for 4-byte modes\n+\tin the address check.  Move work around for ELF32 targets to\n+\tGO_IF_LEGITIMATE_ADDRESS.\n+\t(GO_IF_LEGITIMATE_ADDRESS): Require constant offsets to be\n+\tcorrectly aligned for DImode loads and stores.  Don't allow long\n+\tSFmode displacements on ELF32.\n+\n 2004-06-21  Richard Henderson  <rth@redhat.com>\n \n         PR rtl-opt/16114"}, {"sha": "3aee1adecbd883eacafff2437b228d8229ab231f", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cae80939b64ac547c253fbb53f4c91c67d9e8ad5/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cae80939b64ac547c253fbb53f4c91c67d9e8ad5/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=cae80939b64ac547c253fbb53f4c91c67d9e8ad5", "patch": "@@ -1562,15 +1562,18 @@ emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n     operand1 = gen_rtx_MEM (GET_MODE (operand1), tem);\n \n   /* Handle secondary reloads for loads/stores of FP registers from\n-     REG+D addresses where D does not fit in 5 bits, including\n+     REG+D addresses where D does not fit in 5 or 14 bits, including\n      (subreg (mem (addr))) cases.  */\n   if (scratch_reg\n       && fp_reg_operand (operand0, mode)\n       && ((GET_CODE (operand1) == MEM\n-\t   && !memory_address_p (DFmode, XEXP (operand1, 0)))\n+\t   && !memory_address_p ((GET_MODE_SIZE (mode) == 4 ? SFmode : DFmode),\n+\t\t\t\t XEXP (operand1, 0)))\n \t  || ((GET_CODE (operand1) == SUBREG\n \t       && GET_CODE (XEXP (operand1, 0)) == MEM\n-\t       && !memory_address_p (DFmode, XEXP (XEXP (operand1, 0), 0))))))\n+\t       && !memory_address_p ((GET_MODE_SIZE (mode) == 4\n+\t\t\t\t      ? SFmode : DFmode),\n+\t\t\t\t     XEXP (XEXP (operand1, 0), 0))))))\n     {\n       if (GET_CODE (operand1) == SUBREG)\n \toperand1 = XEXP (operand1, 0);\n@@ -1600,10 +1603,13 @@ emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n   else if (scratch_reg\n \t   && fp_reg_operand (operand1, mode)\n \t   && ((GET_CODE (operand0) == MEM\n-\t\t&& ! memory_address_p (DFmode, XEXP (operand0, 0)))\n+\t\t&& !memory_address_p ((GET_MODE_SIZE (mode) == 4\n+\t\t\t\t\t? SFmode : DFmode),\n+\t\t\t\t       XEXP (operand0, 0)))\n \t       || ((GET_CODE (operand0) == SUBREG)\n \t\t   && GET_CODE (XEXP (operand0, 0)) == MEM\n-\t\t   && !memory_address_p (DFmode,\n+\t\t   && !memory_address_p ((GET_MODE_SIZE (mode) == 4\n+\t\t\t\t\t  ? SFmode : DFmode),\n \t\t\t   \t\t XEXP (XEXP (operand0, 0), 0)))))\n     {\n       if (GET_CODE (operand0) == SUBREG)"}, {"sha": "5edc151d26d47db243cedacc63811f0ed34fb657", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 45, "deletions": 18, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cae80939b64ac547c253fbb53f4c91c67d9e8ad5/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cae80939b64ac547c253fbb53f4c91c67d9e8ad5/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=cae80939b64ac547c253fbb53f4c91c67d9e8ad5", "patch": "@@ -1284,7 +1284,7 @@ extern int may_call_alloca;\n \n    `S' is the constant 31.\n \n-   `T' is for fp loads and stores.\n+   `T' is for floating-point loads and stores.\n \n    `U' is the constant 63.  */\n \n@@ -1307,17 +1307,20 @@ extern int may_call_alloca;\n       (GET_CODE (OP) == MEM\t\t\t\t\t\t\\\n        && !IS_LO_SUM_DLT_ADDR_P (XEXP (OP, 0))\t\t\t\t\\\n        && !IS_INDEX_ADDR_P (XEXP (OP, 0))\t\t\t\t\\\n-       /* Using DFmode forces only short displacements\t\t\t\\\n-\t  to be recognized as valid in reg+d addresses. \t\t\\\n-\t  However, this is not necessary for PA2.0 since\t\t\\\n-\t  it has long FP loads/stores.\t\t\t\t\t\\\n+       /* Floating-point loads and stores are used to load\t\t\\\n+\t  integer values as well as floating-point values.\t\t\\\n+\t  They don't have the same set of REG+D address modes\t\t\\\n+\t  as integer loads and stores.  PA 1.x supports only\t\t\\\n+\t  short displacements.  PA 2.0 supports long displacements\t\\\n+\t  but the base register needs to be aligned.\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-\t  FIXME: the ELF32 linker clobbers the LSB of\t\t\t\\\n-\t  the FP register number in {fldw,fstw} insns.\t\t\t\\\n-\t  Thus, we only allow long FP loads/stores on\t\t\t\\\n-\t  TARGET_64BIT.  */\t\t\t\t\t\t\\\n-       && memory_address_p ((TARGET_PA_20 && !TARGET_ELF32\t\t\\\n-\t\t\t     ? GET_MODE (OP)\t\t\t\t\\\n+\t  The checks in GO_IF_LEGITIMATE_ADDRESS for SFmode and\t\t\\\n+\t  DFmode test the validity of an address for use in a\t\t\\\n+\t  floating point load or store.  So, we use SFmode/DFmode\t\\\n+\t  to see if the address is valid for a floating-point\t\t\\\n+\t  load/store operation.  */\t\t\t\t\t\\\n+       && memory_address_p ((GET_MODE_SIZE (GET_MODE (OP)) == 4\t\t\\\n+\t\t\t     ? SFmode\t\t\t\t\t\\\n \t\t\t     : DFmode),\t\t\t\t\t\\\n \t\t\t    XEXP (OP, 0)))\t\t\t\t\\\n    : ((C) == 'S' ?\t\t\t\t\t\t\t\\\n@@ -1467,13 +1470,32 @@ extern int may_call_alloca;\n       if (base\t\t\t\t\t\t\t\t\\\n \t  && GET_CODE (index) == CONST_INT\t\t\t\t\\\n \t  && ((INT_14_BITS (index)\t\t\t\t\t\\\n-\t       && (TARGET_SOFT_FLOAT\t\t\t\t\t\\\n-\t\t   || (TARGET_PA_20\t\t\t\t\t\\\n-\t\t       && ((MODE == SFmode\t\t\t\t\\\n-\t\t\t    && (INTVAL (index) % 4) == 0)\t\t\\\n-\t\t\t   || (MODE == DFmode\t\t\t\t\\\n-\t\t\t       && (INTVAL (index) % 8) == 0)))\t\t\\\n-\t\t   || ((MODE) != SFmode && (MODE) != DFmode)))\t\t\\\n+\t       && (((MODE) != DImode\t\t\t\t\t\\\n+\t\t    && (MODE) != SFmode\t\t\t\t\t\\\n+\t\t    && (MODE) != DFmode)\t\t\t\t\\\n+\t\t   /* The base register for DImode loads and stores\t\\\n+\t\t      with long displacements must be aligned because\t\\\n+\t\t      the lower three bits in the displacement are\t\\\n+\t\t      assumed to be zero.  */\t\t\t\t\\\n+\t\t   || ((MODE) == DImode\t\t\t\t\t\\\n+\t\t       && (!TARGET_64BIT\t\t\t\t\\\n+\t\t\t   || (INTVAL (index) % 8) == 0))\t\t\\\n+\t\t   /* Similarly, the base register for SFmode/DFmode\t\\\n+\t\t      loads and stores with long displacements must\t\\\n+\t\t      be aligned.\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t\t      FIXME: the ELF32 linker clobbers the LSB of\t\\\n+\t\t      the FP register number in PA 2.0 floating-point\t\\\n+\t\t      insns with long displacements.  This is because\t\\\n+\t\t      R_PARISC_DPREL14WR and other relocations like\t\\\n+\t\t      it are not supported.  For now, we reject long\t\\\n+\t\t      displacements on this target.  */\t\t\t\\\n+\t\t   || (((MODE) == SFmode || (MODE) == DFmode)\t\t\\\n+\t\t       && (TARGET_SOFT_FLOAT\t\t\t\t\\\n+\t\t\t   || (TARGET_PA_20\t\t\t\t\\\n+\t\t\t       && !TARGET_ELF32\t\t\t\t\\\n+\t\t\t       && (INTVAL (index)\t\t\t\\\n+\t\t\t\t   % GET_MODE_SIZE (MODE)) == 0)))))\t\\\n \t       || INT_5_BITS (index)))\t\t\t\t\t\\\n \tgoto ADDR;\t\t\t\t\t\t\t\\\n       if (!TARGET_DISABLE_INDEXING\t\t\t\t\t\\\n@@ -1589,6 +1611,11 @@ do { \t\t\t\t\t\t\t\t\t\\\n       else\t\t\t\t\t\t\t\t\\\n \tnewoffset = offset & ~mask;\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n+      /* Ensure that long displacements are aligned.  */\t\t\\\n+      if (!VAL_5_BITS_P (newoffset)\t\t\t\t\t\\\n+\t  && GET_MODE_CLASS (MODE) == MODE_FLOAT)\t\t\t\\\n+\tnewoffset &= ~(GET_MODE_SIZE (MODE) -1);\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n       if (newoffset != 0 && VAL_14_BITS_P (newoffset))\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n \t  temp = gen_rtx_PLUS (Pmode, XEXP (new, 0),\t\t\t\\"}]}