{"sha": "8a171a5948d2c67775cb88046c224eb663c55fdf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGExNzFhNTk0OGQyYzY3Nzc1Y2I4ODA0NmMyMjRlYjY2M2M1NWZkZg==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "ook@ucw.cz", "date": "2007-12-19T15:01:19Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2007-12-19T15:01:19Z"}, "message": "re PR tree-optimization/34355 (ICE: invariant not recomputed when ADDR_EXPR changed with -ftree-parallelize-loops)\n\n\tPR tree-optimization/34355\n\t* tree-parloops.c (take_address_of): Handle expresions\n\tinstead of just variables.\n\t(eliminate_local_variables_1): Force whole invariant\n\taddress to ssa name.\n\n\t* g++.dg/tree-ssa/pr34355.C: New test.\n\nFrom-SVN: r131063", "tree": {"sha": "11701d71781fafe83da10888fc434238585e0d79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/11701d71781fafe83da10888fc434238585e0d79"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a171a5948d2c67775cb88046c224eb663c55fdf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a171a5948d2c67775cb88046c224eb663c55fdf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a171a5948d2c67775cb88046c224eb663c55fdf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a171a5948d2c67775cb88046c224eb663c55fdf/comments", "author": {"login": "rakdver", "id": 20416833, "node_id": "MDQ6VXNlcjIwNDE2ODMz", "avatar_url": "https://avatars.githubusercontent.com/u/20416833?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rakdver", "html_url": "https://github.com/rakdver", "followers_url": "https://api.github.com/users/rakdver/followers", "following_url": "https://api.github.com/users/rakdver/following{/other_user}", "gists_url": "https://api.github.com/users/rakdver/gists{/gist_id}", "starred_url": "https://api.github.com/users/rakdver/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rakdver/subscriptions", "organizations_url": "https://api.github.com/users/rakdver/orgs", "repos_url": "https://api.github.com/users/rakdver/repos", "events_url": "https://api.github.com/users/rakdver/events{/privacy}", "received_events_url": "https://api.github.com/users/rakdver/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "89deeaffbbfd671c5e57190b999ee10c6f4af07f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89deeaffbbfd671c5e57190b999ee10c6f4af07f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89deeaffbbfd671c5e57190b999ee10c6f4af07f"}], "stats": {"total": 118, "additions": 92, "deletions": 26}, "files": [{"sha": "d038634ac6262366c789593c749d5ba3059f2fbd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a171a5948d2c67775cb88046c224eb663c55fdf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a171a5948d2c67775cb88046c224eb663c55fdf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8a171a5948d2c67775cb88046c224eb663c55fdf", "patch": "@@ -1,3 +1,11 @@\n+2007-12-19  Zdenek Dvorak  <ook@ucw.cz>\n+\n+\tPR tree-optimization/34355\n+\t* tree-parloops.c (take_address_of): Handle expresions\n+\tinstead of just variables.\n+\t(eliminate_local_variables_1): Force whole invariant\n+\taddress to ssa name.\n+\n 2007-12-19  Alexander Monakov  <amonakov@ispras.ru>\n \t    Revital Eres  <eres@il.ibm.com>\n "}, {"sha": "024867a4cf39c6f125de0aa018fe6bf9cd3d087b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a171a5948d2c67775cb88046c224eb663c55fdf/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a171a5948d2c67775cb88046c224eb663c55fdf/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8a171a5948d2c67775cb88046c224eb663c55fdf", "patch": "@@ -1,3 +1,8 @@\n+2007-12-19  Zdenek Dvorak  <ook@ucw.cz>\n+\n+\tPR tree-optimization/34355\n+\t* g++.dg/tree-ssa/pr34355.C: New test.\n+\n 2007-12-19  Revital Eres  <eres@il.ibm.com>\n \n \t * gcc.dg/sms-5.c: New testcase."}, {"sha": "212c54777445b508f363a481b3036fd260c25326", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr34355.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a171a5948d2c67775cb88046c224eb663c55fdf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr34355.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a171a5948d2c67775cb88046c224eb663c55fdf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr34355.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr34355.C?ref=8a171a5948d2c67775cb88046c224eb663c55fdf", "patch": "@@ -0,0 +1,26 @@\n+// { dg-do compile }\n+// { dg-options \"-O3 -ftree-parallelize-loops=4\" }\n+\n+typedef double EXPRESS[5];\n+\n+extern int Terms;\n+\n+void Parse_Rel_Factor (EXPRESS Express, int *Terms)\n+{\n+  EXPRESS Local_Express = {5.0, 4.0, 3.0, 2.0, 1.0};\n+  int Local_Terms = 5;\n+\n+  int i;\n+\n+  for (i = (*Terms); i < Local_Terms; i++)\n+    Express[i] = 0.0;\n+\n+  Express[i] += Local_Express[i];\n+}\n+\n+double Parse_Float ()\n+{\n+  EXPRESS Express = {1.0, 2.0, 3.0, 4.0, 5.0};\n+\n+  Parse_Rel_Factor (Express, &Terms);\n+}"}, {"sha": "7639af6337e2e5b078f50be60aeb7615b696b99c", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 53, "deletions": 26, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a171a5948d2c67775cb88046c224eb663c55fdf/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a171a5948d2c67775cb88046c224eb663c55fdf/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=8a171a5948d2c67775cb88046c224eb663c55fdf", "patch": "@@ -431,29 +431,37 @@ loop_parallel_p (struct loop *loop, htab_t reduction_list, struct tree_niter_des\n   return ret;\n }\n \n-/* Assigns the address of VAR in TYPE to an ssa name, and returns this name.\n+/* Assigns the address of OBJ in TYPE to an ssa name, and returns this name.\n    The assignment statement is placed before LOOP.  DECL_ADDRESS maps decls\n-   to their addresses that can be reused.  */\n+   to their addresses that can be reused.  The address of OBJ is known to\n+   be invariant in the whole function.  */\n \n static tree\n-take_address_of (tree var, tree type, struct loop *loop, htab_t decl_address)\n+take_address_of (tree obj, tree type, struct loop *loop, htab_t decl_address)\n {\n-  int uid = DECL_UID (var);\n+  int uid;\n   void **dslot;\n   struct int_tree_map ielt, *nielt;\n-  tree name, bvar, stmt;\n+  tree *var_p, name, bvar, stmt, addr;\n   edge entry = loop_preheader_edge (loop);\n \n+  /* Since the address of OBJ is invariant, the trees may be shared.\n+     Avoid rewriting unrelated parts of the code.  */\n+  obj = unshare_expr (obj);\n+  for (var_p = &obj;\n+       handled_component_p (*var_p);\n+       var_p = &TREE_OPERAND (*var_p, 0))\n+    continue;\n+  uid = DECL_UID (*var_p);\n+\n   ielt.uid = uid;\n   dslot = htab_find_slot_with_hash (decl_address, &ielt, uid, INSERT);\n   if (!*dslot)\n     {\n-      bvar = create_tmp_var (type, get_name (var));\n+      addr = build_addr (*var_p, current_function_decl);\n+      bvar = create_tmp_var (TREE_TYPE (addr), get_name (*var_p));\n       add_referenced_var (bvar);\n-      stmt = build_gimple_modify_stmt (bvar,\n-\t\t\t\t       fold_convert (type,\n-\t\t\t\t\t\t     build_addr (var,\n-\t\t\t\t\t\t\t\t current_function_decl)));\n+      stmt = build_gimple_modify_stmt (bvar, addr);\n       name = make_ssa_name (bvar, stmt);\n       GIMPLE_STMT_OPERAND (stmt, 0) = name;\n       bsi_insert_on_edge_immediate (entry, stmt);\n@@ -462,19 +470,26 @@ take_address_of (tree var, tree type, struct loop *loop, htab_t decl_address)\n       nielt->uid = uid;\n       nielt->to = name;\n       *dslot = nielt;\n-\n-      return name;\n     }\n+  else\n+    name = ((struct int_tree_map *) *dslot)->to;\n \n-  name = ((struct int_tree_map *) *dslot)->to;\n-  if (TREE_TYPE (name) == type)\n-    return name;\n+  if (var_p != &obj)\n+    {\n+      *var_p = build1 (INDIRECT_REF, TREE_TYPE (*var_p), name);\n+      name = force_gimple_operand (build_addr (obj, current_function_decl),\n+\t\t\t\t   &stmt, true, NULL_TREE);\n+      if (stmt)\n+\tbsi_insert_on_edge_immediate (entry, stmt);\n+    }\n \n-  bvar = SSA_NAME_VAR (name);\n-  stmt = build_gimple_modify_stmt (bvar, fold_convert (type, name));\n-  name = make_ssa_name (bvar, stmt);\n-  GIMPLE_STMT_OPERAND (stmt, 0) = name;\n-  bsi_insert_on_edge_immediate (entry, stmt);\n+  if (TREE_TYPE (name) != type)\n+    {\n+      name = force_gimple_operand (fold_convert (type, name), &stmt, true,\n+\t\t\t\t   NULL_TREE);\n+      if (stmt)\n+\tbsi_insert_on_edge_immediate (entry, stmt);\n+    }\n \n   return name;\n }\n@@ -543,10 +558,10 @@ struct elv_data\n    walk_tree.  */\n \n static tree\n-eliminate_local_variables_1 (tree * tp, int *walk_subtrees, void *data)\n+eliminate_local_variables_1 (tree *tp, int *walk_subtrees, void *data)\n {\n   struct elv_data *dta = data;\n-  tree t = *tp, var, addr, addr_type, type;\n+  tree t = *tp, var, addr, addr_type, type, obj;\n \n   if (DECL_P (t))\n     {\n@@ -566,16 +581,28 @@ eliminate_local_variables_1 (tree * tp, int *walk_subtrees, void *data)\n \n   if (TREE_CODE (t) == ADDR_EXPR)\n     {\n-      var = TREE_OPERAND (t, 0);\n-      if (!DECL_P (var))\n+      /* ADDR_EXPR may appear in two contexts:\n+\t -- as a gimple operand, when the address taken is a function invariant\n+\t -- as gimple rhs, when the resulting address in not a function\n+\t    invariant\n+\t We do not need to do anything special in the latter case (the base of\n+\t the memory reference whose address is taken may be replaced in the\n+\t DECL_P case).  The former case is more complicated, as we need to\n+\t ensure that the new address is still a gimple operand.  Thus, it\n+\t is not sufficient to replace just the base of the memory reference --\n+\t we need to move the whole computation of the address out of the\n+\t loop.  */\n+      if (!is_gimple_val (t))\n \treturn NULL_TREE;\n \n       *walk_subtrees = 0;\n-      if (!SSA_VAR_P (var) || DECL_EXTERNAL (var))\n+      obj = TREE_OPERAND (t, 0);\n+      var = get_base_address (obj);\n+      if (!var || !SSA_VAR_P (var) || DECL_EXTERNAL (var))\n \treturn NULL_TREE;\n \n       addr_type = TREE_TYPE (t);\n-      addr = take_address_of (var, addr_type, dta->loop, dta->decl_address);\n+      addr = take_address_of (obj, addr_type, dta->loop, dta->decl_address);\n       *tp = addr;\n \n       dta->changed = true;"}]}