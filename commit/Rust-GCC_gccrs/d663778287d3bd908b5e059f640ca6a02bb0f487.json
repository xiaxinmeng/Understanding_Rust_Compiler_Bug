{"sha": "d663778287d3bd908b5e059f640ca6a02bb0f487", "node_id": "C_kwDOANBUbNoAKGQ2NjM3NzgyODdkM2JkOTA4YjVlMDU5ZjY0MGNhNmEwMmJiMGY0ODc", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2022-02-15T19:09:48Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-05-13T08:04:45Z"}, "message": "[Ada] Compiler crash on -gnata -O2\n\ngcc/ada/\n\n\t* contracts.adb (Build_Unique_Name): New subprogram.\n\t(Make_Class_Precondition_Subps): Use Build_Unique_Name to\n\tgenerate the names of the call helpers and the name of indirect\n\tcall wrappers.\n\t* freeze.adb (Needs_Wrapper): Remove dead code.\n\t(Check_Inherited_Conditions): Defer building helpers and ICW\n\tuntil all the dispatch table wrappers have been built and\n\tanalyzed. Required to ensure uniqueness in their names because\n\twhen building these wrappers for overlapped subprograms their\n\thomonym number is not definite until they have been analyzed.", "tree": {"sha": "c909dc3df56af51314f1e1e4d90120413fb35afe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c909dc3df56af51314f1e1e4d90120413fb35afe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d663778287d3bd908b5e059f640ca6a02bb0f487", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d663778287d3bd908b5e059f640ca6a02bb0f487", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d663778287d3bd908b5e059f640ca6a02bb0f487", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d663778287d3bd908b5e059f640ca6a02bb0f487/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "78e26388edb20bc827a8c0504010621f01204af2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78e26388edb20bc827a8c0504010621f01204af2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78e26388edb20bc827a8c0504010621f01204af2"}], "stats": {"total": 141, "additions": 88, "deletions": 53}, "files": [{"sha": "7ce3cfac91d8c049ea9befc997f72926b0be88bb", "filename": "gcc/ada/contracts.adb", "status": "modified", "additions": 30, "deletions": 9, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d663778287d3bd908b5e059f640ca6a02bb0f487/gcc%2Fada%2Fcontracts.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d663778287d3bd908b5e059f640ca6a02bb0f487/gcc%2Fada%2Fcontracts.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcontracts.adb?ref=d663778287d3bd908b5e059f640ca6a02bb0f487", "patch": "@@ -3630,6 +3630,10 @@ package body Contracts is\n       --  and append it to the freezing actions of Tagged_Type. Is_Dynamic\n       --  controls building the static or dynamic version of the helper.\n \n+      function Build_Unique_Name (Suffix : String) return Name_Id;\n+      --  Build an unique new name adding suffix to Subp_Id name (plus its\n+      --  homonym number for values bigger than 1).\n+\n       -------------------------------\n       -- Add_Indirect_Call_Wrapper --\n       -------------------------------\n@@ -3710,9 +3714,7 @@ package body Contracts is\n          function Build_ICW_Decl return Node_Id is\n             ICW_Id : constant Entity_Id  :=\n                        Make_Defining_Identifier (Loc,\n-                         New_External_Name (Chars (Subp_Id),\n-                           Suffix       => \"ICW\",\n-                           Suffix_Index => Source_Offset (Loc)));\n+                         Build_Unique_Name (Suffix => \"ICW\"));\n             Decl   : Node_Id;\n             Spec   : Node_Id;\n \n@@ -4049,6 +4051,29 @@ package body Contracts is\n          end if;\n       end Add_Call_Helper;\n \n+      -----------------------\n+      -- Build_Unique_Name --\n+      -----------------------\n+\n+      function Build_Unique_Name (Suffix : String) return Name_Id is\n+      begin\n+         --  Append the homonym number. Strip the leading space character in\n+         --  the image of natural numbers. Also do not add the homonym value\n+         --  of 1.\n+\n+         if Has_Homonym (Subp_Id) and then Homonym_Number (Subp_Id) > 1 then\n+            declare\n+               S : constant String := Homonym_Number (Subp_Id)'Img;\n+\n+            begin\n+               return New_External_Name (Chars (Subp_Id),\n+                        Suffix => Suffix & \"_\" & S (2 .. S'Last));\n+            end;\n+         end if;\n+\n+         return New_External_Name (Chars (Subp_Id), Suffix);\n+      end Build_Unique_Name;\n+\n       --  Local variables\n \n       Helper_Id : Entity_Id;\n@@ -4070,9 +4095,7 @@ package body Contracts is\n \n             Helper_Id :=\n               Make_Defining_Identifier (Loc,\n-                New_External_Name (Chars (Subp_Id),\n-                Suffix       => \"DP\",\n-                Suffix_Index => Source_Offset (Loc)));\n+                Build_Unique_Name (Suffix => \"DP\"));\n             Add_Call_Helper (Helper_Id, Is_Dynamic => True);\n \n             --  Link original subprogram to helper and vice versa\n@@ -4089,9 +4112,7 @@ package body Contracts is\n \n             Helper_Id :=\n               Make_Defining_Identifier (Loc,\n-                New_External_Name (Chars (Subp_Id),\n-                Suffix       => \"SP\",\n-                Suffix_Index => Source_Offset (Loc)));\n+                Build_Unique_Name (Suffix => \"SP\"));\n \n             Add_Call_Helper (Helper_Id, Is_Dynamic => False);\n "}, {"sha": "7d90f51224596af37e9c5aa0846522c8822bee63", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 58, "deletions": 44, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d663778287d3bd908b5e059f640ca6a02bb0f487/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d663778287d3bd908b5e059f640ca6a02bb0f487/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=d663778287d3bd908b5e059f640ca6a02bb0f487", "patch": "@@ -1741,17 +1741,6 @@ package body Freeze is\n                 (Nkind (Parent (N)) /= N_Attribute_Reference\n                   or else Attribute_Name (Parent (N)) /= Name_Class)\n             then\n-               --  The check does not apply to dispatching calls within the\n-               --  condition, but only to calls whose static tag is that of\n-               --  the parent type.\n-\n-               if Is_Subprogram (Entity (N))\n-                 and then Nkind (Parent (N)) = N_Function_Call\n-                 and then Present (Controlling_Argument (Parent (N)))\n-               then\n-                  return OK;\n-               end if;\n-\n                --  Determine whether entity has a renaming\n \n                New_E := Get_Mapped_Entity (Entity (N));\n@@ -1795,6 +1784,10 @@ package body Freeze is\n       Ifaces_Listed  : Boolean := False;\n       --  Cache the list of interface operations inherited by R\n \n+      Wrappers_List  : Elist_Id := No_Elist;\n+      --  List containing identifiers of built wrappers. Used to defer building\n+      --  and analyzing their class-wide precondition subprograms.\n+\n    --  Start of processing for Check_Inherited_Conditions\n \n    begin\n@@ -1985,16 +1978,21 @@ package body Freeze is\n                Prim_Prev_E : constant Entity_Id := Prev_Entity (Prim);\n \n             begin\n-               --  The wrapper must be analyzed in the scope of its wrapped\n-               --  primitive (to ensure its correct decoration).\n-\n-               Push_Scope (Scope (Prim));\n-\n                DTW_Spec := Build_DTW_Spec (Par_Prim);\n                DTW_Id   := Defining_Entity (DTW_Spec);\n                DTW_Decl := Make_Subprogram_Declaration (Loc,\n                              Specification => DTW_Spec);\n \n+               --  The spec of the wrapper has been built using the source\n+               --  location of its parent primitive; we must update it now\n+               --  (with the source location of the internal primitive built\n+               --  by Derive_Subprogram that will override this wrapper) to\n+               --  avoid inlining conflicts between internally built helpers\n+               --  for class-wide pre/postconditions of the parent and the\n+               --  helpers built for this wrapper.\n+\n+               Set_Sloc (DTW_Id, Sloc (Prim));\n+\n                --  For inherited class-wide preconditions the DTW wrapper\n                --  reuses the ICW of the parent (which checks the parent\n                --  interpretation of the class-wide preconditions); the\n@@ -2121,42 +2119,58 @@ package body Freeze is\n                     Register_Primitive (Loc, DTW_Id));\n                end if;\n \n-               --  Build the helper and ICW for the DTW\n+               --  Defer building helpers and ICW for the DTW. Required to\n+               --  ensure uniqueness in their names because when building\n+               --  these wrappers for overlapped subprograms their homonym\n+               --  number is not definite until all these dispatch table\n+               --  wrappers of tagged type R have been analyzed.\n \n                if Present (Indirect_Call_Wrapper (Par_Prim)) then\n-                  declare\n-                     CW_Subp : Entity_Id;\n-                     Decl_N  : Node_Id;\n-                     Body_N  : Node_Id;\n-\n-                  begin\n-                     Merge_Class_Conditions (DTW_Id);\n-                     Make_Class_Precondition_Subps (DTW_Id,\n-                       Late_Overriding => Late_Overriding);\n-\n-                     CW_Subp := Static_Call_Helper (DTW_Id);\n-                     Decl_N  := Unit_Declaration_Node (CW_Subp);\n-                     Analyze (Decl_N);\n-\n-                     --  If the DTW was built for a late-overriding primitive\n-                     --  its body must be analyzed now (since the tagged type\n-                     --  is already frozen).\n-\n-                     if Late_Overriding then\n-                        Body_N :=\n-                          Unit_Declaration_Node\n-                            (Corresponding_Body (Decl_N));\n-                        Analyze (Body_N);\n-                     end if;\n-                  end;\n+                  Append_New_Elmt (DTW_Id, Wrappers_List);\n                end if;\n-\n-               Pop_Scope;\n             end;\n          end if;\n \n          Next_Elmt (Op_Node);\n       end loop;\n+\n+      --  Build and analyze deferred class-wide precondition subprograms of\n+      --  built wrappers.\n+\n+      if Present (Wrappers_List) then\n+         declare\n+            Body_N  : Node_Id;\n+            CW_Subp : Entity_Id;\n+            Decl_N  : Node_Id;\n+            DTW_Id  : Entity_Id;\n+            Elmt    : Elmt_Id;\n+\n+         begin\n+            Elmt := First_Elmt (Wrappers_List);\n+\n+            while Present (Elmt) loop\n+               DTW_Id := Node (Elmt);\n+               Next_Elmt (Elmt);\n+\n+               Merge_Class_Conditions (DTW_Id);\n+               Make_Class_Precondition_Subps (DTW_Id, Late_Overriding);\n+\n+               CW_Subp := Static_Call_Helper (DTW_Id);\n+               Decl_N  := Unit_Declaration_Node (CW_Subp);\n+               Analyze (Decl_N);\n+\n+               --  If the DTW was built for a late-overriding primitive\n+               --  its body must be analyzed now (since the tagged type\n+               --  is already frozen).\n+\n+               if Late_Overriding then\n+                  Body_N :=\n+                    Unit_Declaration_Node (Corresponding_Body (Decl_N));\n+                  Analyze (Body_N);\n+               end if;\n+            end loop;\n+         end;\n+      end if;\n    end Check_Inherited_Conditions;\n \n    ----------------------------"}]}