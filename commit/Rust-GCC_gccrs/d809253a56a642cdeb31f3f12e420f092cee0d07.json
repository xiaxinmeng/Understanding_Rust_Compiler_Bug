{"sha": "d809253a56a642cdeb31f3f12e420f092cee0d07", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDgwOTI1M2E1NmE2NDJjZGViMzFmM2YxMmU0MjBmMDkyY2VlMGQwNw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2009-11-03T22:49:37Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-11-03T22:49:37Z"}, "message": "re PR target/10127 (-fstack-check let's program crash)\n\n\tPR target/10127\n\tPR ada/20548\n\t* expr.h (STACK_CHECK_PROBE_INTERVAL): Delete.\n\t(STACK_CHECK_PROBE_INTERVAL_EXP): New macro.\n\t(STACK_CHECK_MOVING_SP): Likewise.\n\t* system.h (STACK_CHECK_PROBE_INTERVAL): Poison it.\n\t* doc/tm.texi (Stack Checking): Delete STACK_CHECK_PROBE_INTERVAL.\n\tDocument STACK_CHECK_PROBE_INTERVAL_EXP and STACK_CHECK_MOVING_SP.\n\t* doc/md.texi (Standard Pattern Names): Tweak entry of CHECK_STACK.\n\tDocument PROBE_STACK.\n\t* explow.c (anti_adjust_stack_and_probe): New function.\n\t(allocate_dynamic_stack_space): Do not directly allocate space if\n\tSTACK_CHECK_MOVING_SP, instead invoke above function.\n\t(emit_stack_probe): Handle probe_stack insn.\n\t(PROBE_INTERVAL): New macro.\n\t(STACK_GROW_OPTAB): Likewise.\n\t(STACK_GROW_OFF): Likewise.\n\t(probe_stack_range): Use Pmode and memory_address consistently.  Fix\n\tloop condition in the small constant case.  Rewrite in the general\n\tcase to be immune to wraparounds.  Make sure the address of probes\n\tis valid.  Try to use [base + disp] addressing mode if possible.\n\t* ira.c (setup_eliminable_regset): Set frame_pointer_needed if stack\n\tchecking is enabled and STACK_CHECK_MOVING_SP.\n\t* rtlanal.c (may_trap_p_1) <MEM>: If stack checking is enabled,\n\treturn 1 for volatile references to the stack pointer.\n\t* tree.c (build_common_builtin_nodes): Do not set ECF_NOTHROW on\n\t__builtin_alloca if stack checking is enabled.\n\t* unwind-dw2.c (uw_identify_context): Take into account whether the\n\tcontext is that of a signal frame or not.\n\t* config/i386/linux.h (STACK_CHECK_MOVING_SP): Define to 1.\n\t* config/i386/linux64.h (STACK_CHECK_MOVING_SP): Likewise.\n\nFrom-SVN: r153877", "tree": {"sha": "f611e7abf6528b7dc5e27a9acf00f201c85571a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f611e7abf6528b7dc5e27a9acf00f201c85571a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d809253a56a642cdeb31f3f12e420f092cee0d07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d809253a56a642cdeb31f3f12e420f092cee0d07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d809253a56a642cdeb31f3f12e420f092cee0d07", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d809253a56a642cdeb31f3f12e420f092cee0d07/comments", "author": null, "committer": null, "parents": [{"sha": "24d179b4c7717ceeceef16166064bd4a3933cb11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24d179b4c7717ceeceef16166064bd4a3933cb11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24d179b4c7717ceeceef16166064bd4a3933cb11"}], "stats": {"total": 545, "additions": 442, "deletions": 103}, "files": [{"sha": "ce890998894960228096b99c0be7be85bccb5beb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d809253a56a642cdeb31f3f12e420f092cee0d07/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d809253a56a642cdeb31f3f12e420f092cee0d07/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d809253a56a642cdeb31f3f12e420f092cee0d07", "patch": "@@ -1,3 +1,37 @@\n+2009-11-03  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR target/10127\n+\tPR ada/20548\n+\t* expr.h (STACK_CHECK_PROBE_INTERVAL): Delete.\n+\t(STACK_CHECK_PROBE_INTERVAL_EXP): New macro.\n+\t(STACK_CHECK_MOVING_SP): Likewise.\n+\t* system.h (STACK_CHECK_PROBE_INTERVAL): Poison it.\n+\t* doc/tm.texi (Stack Checking): Delete STACK_CHECK_PROBE_INTERVAL.\n+\tDocument STACK_CHECK_PROBE_INTERVAL_EXP and STACK_CHECK_MOVING_SP.\n+\t* doc/md.texi (Standard Pattern Names): Tweak entry of CHECK_STACK.\n+\tDocument PROBE_STACK.\n+\t* explow.c (anti_adjust_stack_and_probe): New function.\n+\t(allocate_dynamic_stack_space): Do not directly allocate space if\n+\tSTACK_CHECK_MOVING_SP, instead invoke above function.\n+\t(emit_stack_probe): Handle probe_stack insn.\n+\t(PROBE_INTERVAL): New macro.\n+\t(STACK_GROW_OPTAB): Likewise.\n+\t(STACK_GROW_OFF): Likewise.\n+\t(probe_stack_range): Use Pmode and memory_address consistently.  Fix\n+\tloop condition in the small constant case.  Rewrite in the general\n+\tcase to be immune to wraparounds.  Make sure the address of probes\n+\tis valid.  Try to use [base + disp] addressing mode if possible.\n+\t* ira.c (setup_eliminable_regset): Set frame_pointer_needed if stack\n+\tchecking is enabled and STACK_CHECK_MOVING_SP.\n+\t* rtlanal.c (may_trap_p_1) <MEM>: If stack checking is enabled,\n+\treturn 1 for volatile references to the stack pointer.\n+\t* tree.c (build_common_builtin_nodes): Do not set ECF_NOTHROW on\n+\t__builtin_alloca if stack checking is enabled.\n+\t* unwind-dw2.c (uw_identify_context): Take into account whether the\n+\tcontext is that of a signal frame or not.\n+\t* config/i386/linux.h (STACK_CHECK_MOVING_SP): Define to 1.\n+\t* config/i386/linux64.h (STACK_CHECK_MOVING_SP): Likewise.\n+\n 2009-11-03  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR rtl-optimization/41917"}, {"sha": "5d8e5ad2cbefcf5bb2b54eab0440a8a12891ddc2", "filename": "gcc/config/i386/linux.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d809253a56a642cdeb31f3f12e420f092cee0d07/gcc%2Fconfig%2Fi386%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d809253a56a642cdeb31f3f12e420f092cee0d07/gcc%2Fconfig%2Fi386%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Flinux.h?ref=d809253a56a642cdeb31f3f12e420f092cee0d07", "patch": "@@ -207,6 +207,9 @@ along with GCC; see the file COPYING3.  If not see\n \n #define MD_UNWIND_SUPPORT \"config/i386/linux-unwind.h\"\n \n+/* The stack pointer needs to be moved while checking the stack.  */\n+#define STACK_CHECK_MOVING_SP 1\n+\n /* This macro may be overridden in i386/k*bsd-gnu.h.  */\n #define REG_NAME(reg) reg\n "}, {"sha": "d07547a804f58ac5eaf791b5836d7349ac0b949e", "filename": "gcc/config/i386/linux64.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d809253a56a642cdeb31f3f12e420f092cee0d07/gcc%2Fconfig%2Fi386%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d809253a56a642cdeb31f3f12e420f092cee0d07/gcc%2Fconfig%2Fi386%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Flinux64.h?ref=d809253a56a642cdeb31f3f12e420f092cee0d07", "patch": "@@ -110,6 +110,9 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #define MD_UNWIND_SUPPORT \"config/i386/linux-unwind.h\"\n \n+/* The stack pointer needs to be moved while checking the stack.  */\n+#define STACK_CHECK_MOVING_SP 1\n+\n /* This macro may be overridden in i386/k*bsd-gnu.h.  */\n #define REG_NAME(reg) reg\n "}, {"sha": "2974dcfb20c3ff67f00ce21fd84956731d62541a", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d809253a56a642cdeb31f3f12e420f092cee0d07/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d809253a56a642cdeb31f3f12e420f092cee0d07/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=d809253a56a642cdeb31f3f12e420f092cee0d07", "patch": "@@ -5037,11 +5037,19 @@ operations in addition to updating the stack pointer.\n @item @samp{check_stack}\n If stack checking cannot be done on your system by probing the stack with\n a load or store instruction (@pxref{Stack Checking}), define this pattern\n-to perform the needed check and signaling an error if the stack\n-has overflowed.  The single operand is the location in the stack furthest\n-from the current stack pointer that you need to validate.  Normally,\n-on machines where this pattern is needed, you would obtain the stack\n-limit from a global or thread-specific variable or register.\n+to perform the needed check and signal an error if the stack has overflowed.\n+The single operand is the address in the stack furthest from the current\n+stack pointer that you need to validate.  Normally, on machines where this\n+pattern is needed, you would obtain the stack limit from a global or\n+thread-specific variable or register.\n+\n+@cindex @code{probe_stack} instruction pattern\n+@item @samp{probe_stack}\n+If stack checking can be done on your system by probing the stack but doing\n+it with a load or store instruction is not optimal (@pxref{Stack Checking}),\n+define this pattern to do the probing differently and signal an error if\n+the stack has overflowed.  The single operand is the memory location in the\n+stack that needs to be probed.\n \n @cindex @code{nonlocal_goto} instruction pattern\n @item @samp{nonlocal_goto}"}, {"sha": "c69ef0c73abf9089c145cae714a165907be3f554", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d809253a56a642cdeb31f3f12e420f092cee0d07/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d809253a56a642cdeb31f3f12e420f092cee0d07/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=d809253a56a642cdeb31f3f12e420f092cee0d07", "patch": "@@ -3556,11 +3556,12 @@ like to do static stack checking in some more efficient way than the generic\n approach.  The default value of this macro is zero.\n @end defmac\n \n-@defmac STACK_CHECK_PROBE_INTERVAL\n-An integer representing the interval at which GCC must generate stack\n-probe instructions.  You will normally define this macro to be no larger\n-than the size of the ``guard pages'' at the end of a stack area.  The\n-default value of 4096 is suitable for most systems.\n+@defmac STACK_CHECK_PROBE_INTERVAL_EXP\n+An integer specifying the interval at which GCC must generate stack probe\n+instructions, defined as 2 raised to this integer.  You will normally\n+define this macro so that the interval be no larger than the size of\n+the ``guard pages'' at the end of a stack area.  The default value\n+of 12 (4096-byte interval) is suitable for most systems.\n @end defmac\n \n @defmac STACK_CHECK_PROBE_LOAD\n@@ -3569,6 +3570,15 @@ as a load instruction and zero if GCC should use a store instruction.\n The default is zero, which is the most efficient choice on most systems.\n @end defmac\n \n+@defmac STACK_CHECK_MOVING_SP\n+An integer which is nonzero if GCC should move the stack pointer page by page\n+when doing probes.  This can be necessary on systems where the stack pointer\n+contains the bottom address of the memory area accessible to the executing\n+thread at any point in time.  In this situation an alternate signal stack\n+is required in order to be able to recover from a stack overflow.  The\n+default value of this macro is zero.\n+@end defmac\n+\n @defmac STACK_CHECK_PROTECT\n The number of bytes of stack needed to recover from a stack overflow,\n for languages where such a recovery is supported.  The default value of"}, {"sha": "0bbbc003f6d95d1c5510c417f135ef2be48921ef", "filename": "gcc/explow.c", "status": "modified", "additions": 258, "deletions": 82, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d809253a56a642cdeb31f3f12e420f092cee0d07/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d809253a56a642cdeb31f3f12e420f092cee0d07/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=d809253a56a642cdeb31f3f12e420f092cee0d07", "patch": "@@ -43,6 +43,7 @@ along with GCC; see the file COPYING3.  If not see\n \n static rtx break_out_memory_refs (rtx);\n static void emit_stack_probe (rtx);\n+static void anti_adjust_stack_and_probe (rtx);\n \n \n /* Truncate and perhaps sign-extend C as appropriate for MODE.  */\n@@ -1233,9 +1234,11 @@ allocate_dynamic_stack_space (rtx size, rtx target, int known_align)\n   gcc_assert (!(stack_pointer_delta\n \t\t% (PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT)));\n \n-  /* If needed, check that we have the required amount of stack.\n-     Take into account what has already been checked.  */\n-  if (flag_stack_check == GENERIC_STACK_CHECK)\n+  /* If needed, check that we have the required amount of stack.  Take into\n+     account what has already been checked.  */\n+  if (STACK_CHECK_MOVING_SP)\n+    ;\n+  else if (flag_stack_check == GENERIC_STACK_CHECK)\n     probe_stack_range (STACK_OLD_CHECK_PROTECT + STACK_CHECK_MAX_FRAME_SIZE,\n \t\t       size);\n   else if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK)\n@@ -1304,7 +1307,10 @@ allocate_dynamic_stack_space (rtx size, rtx target, int known_align)\n \t  emit_label (space_available);\n \t}\n \n-      anti_adjust_stack (size);\n+      if (flag_stack_check && STACK_CHECK_MOVING_SP)\n+\tanti_adjust_stack_and_probe (size);\n+      else\n+\tanti_adjust_stack (size);\n \n #ifdef STACK_GROWS_DOWNWARD\n       emit_move_insn (target, virtual_stack_dynamic_rtx);\n@@ -1355,22 +1361,33 @@ emit_stack_probe (rtx address)\n \n   MEM_VOLATILE_P (memref) = 1;\n \n+  /* See if we have an insn to probe the stack.  */\n+#ifdef HAVE_probe_stack\n+  if (HAVE_probe_stack)\n+    emit_insn (gen_probe_stack (memref));\n+  else\n+#endif\n   if (STACK_CHECK_PROBE_LOAD)\n     emit_move_insn (gen_reg_rtx (word_mode), memref);\n   else\n     emit_move_insn (memref, const0_rtx);\n }\n \n /* Probe a range of stack addresses from FIRST to FIRST+SIZE, inclusive.\n-   FIRST is a constant and size is a Pmode RTX.  These are offsets from the\n-   current stack pointer.  STACK_GROWS_DOWNWARD says whether to add or\n-   subtract from the stack.  If SIZE is constant, this is done\n-   with a fixed number of probes.  Otherwise, we must make a loop.  */\n+   FIRST is a constant and size is a Pmode RTX.  These are offsets from\n+   the current stack pointer.  STACK_GROWS_DOWNWARD says whether to add\n+   or subtract them from the stack pointer.  */\n+\n+#define PROBE_INTERVAL (1 << STACK_CHECK_PROBE_INTERVAL_EXP)\n \n #ifdef STACK_GROWS_DOWNWARD\n #define STACK_GROW_OP MINUS\n+#define STACK_GROW_OPTAB sub_optab\n+#define STACK_GROW_OFF(off) -(off)\n #else\n #define STACK_GROW_OP PLUS\n+#define STACK_GROW_OPTAB add_optab\n+#define STACK_GROW_OFF(off) (off)\n #endif\n \n void\n@@ -1380,113 +1397,272 @@ probe_stack_range (HOST_WIDE_INT first, rtx size)\n   if (GET_MODE (size) != VOIDmode && GET_MODE (size) != Pmode)\n     size = convert_to_mode (Pmode, size, 1);\n \n-  /* Next see if the front end has set up a function for us to call to\n-     check the stack.  */\n-  if (stack_check_libfunc != 0)\n+  /* Next see if we have a function to check the stack.  */\n+  if (stack_check_libfunc)\n     {\n-      rtx addr = memory_address (QImode,\n+      rtx addr = memory_address (Pmode,\n \t\t\t\t gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,\n \t\t\t\t\t         stack_pointer_rtx,\n \t\t\t\t\t         plus_constant (size, first)));\n-\n-      addr = convert_memory_address (ptr_mode, addr);\n-      emit_library_call (stack_check_libfunc, LCT_NORMAL, VOIDmode, 1, addr,\n-\t\t\t ptr_mode);\n+      emit_library_call (stack_check_libfunc, LCT_NORMAL, VOIDmode, 1, addr);\n     }\n \n-  /* Next see if we have an insn to check the stack.  Use it if so.  */\n+  /* Next see if we have an insn to check the stack.  */\n #ifdef HAVE_check_stack\n   else if (HAVE_check_stack)\n     {\n-      insn_operand_predicate_fn pred;\n-      rtx last_addr\n-\t= force_operand (gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,\n-\t\t\t\t\t stack_pointer_rtx,\n-\t\t\t\t\t plus_constant (size, first)),\n-\t\t\t NULL_RTX);\n-\n-      pred = insn_data[(int) CODE_FOR_check_stack].operand[0].predicate;\n-      if (pred && ! ((*pred) (last_addr, Pmode)))\n-\tlast_addr = copy_to_mode_reg (Pmode, last_addr);\n+      rtx addr = memory_address (Pmode,\n+\t\t\t\t gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,\n+\t\t\t\t\t         stack_pointer_rtx,\n+\t\t\t\t\t         plus_constant (size, first)));\n+      insn_operand_predicate_fn pred\n+\t= insn_data[(int) CODE_FOR_check_stack].operand[0].predicate;\n+      if (pred && !((*pred) (addr, Pmode)))\n+\taddr = copy_to_mode_reg (Pmode, addr);\n \n-      emit_insn (gen_check_stack (last_addr));\n+      emit_insn (gen_check_stack (addr));\n     }\n #endif\n \n-  /* If we have to generate explicit probes, see if we have a constant\n-     small number of them to generate.  If so, that's the easy case.  */\n-  else if (CONST_INT_P (size)\n-\t   && INTVAL (size) < 10 * STACK_CHECK_PROBE_INTERVAL)\n+  /* Otherwise we have to generate explicit probes.  If we have a constant\n+     small number of them to generate, that's the easy case.  */\n+  else if (CONST_INT_P (size) && INTVAL (size) < 7 * PROBE_INTERVAL)\n     {\n-      HOST_WIDE_INT offset;\n-\n-      /* Start probing at FIRST + N * STACK_CHECK_PROBE_INTERVAL\n-\t for values of N from 1 until it exceeds LAST.  If only one\n-\t probe is needed, this will not generate any code.  Then probe\n-\t at LAST.  */\n-      for (offset = first + STACK_CHECK_PROBE_INTERVAL;\n-\t   offset < INTVAL (size);\n-\t   offset = offset + STACK_CHECK_PROBE_INTERVAL)\n-\temit_stack_probe (gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,\n-\t\t\t\t\t  stack_pointer_rtx,\n-\t\t\t\t\t  GEN_INT (offset)));\n-\n-      emit_stack_probe (gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,\n-\t\t\t\t\tstack_pointer_rtx,\n-\t\t\t\t\tplus_constant (size, first)));\n+      HOST_WIDE_INT isize = INTVAL (size), i;\n+      rtx addr;\n+\n+      /* Probe at FIRST + N * PROBE_INTERVAL for values of N from 1 until\n+\t it exceeds SIZE.  If only one probe is needed, this will not\n+\t generate any code.  Then probe at FIRST + SIZE.  */\n+      for (i = PROBE_INTERVAL; i < isize; i += PROBE_INTERVAL)\n+\t{\n+\t  addr = memory_address (Pmode,\n+\t\t\t\t plus_constant (stack_pointer_rtx,\n+\t\t\t\t \t\tSTACK_GROW_OFF (first + i)));\n+\t  emit_stack_probe (addr);\n+\t}\n+\n+      addr = memory_address (Pmode,\n+\t\t\t     plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t    STACK_GROW_OFF (first + isize)));\n+      emit_stack_probe (addr);\n     }\n \n-  /* In the variable case, do the same as above, but in a loop.  We emit loop\n-     notes so that loop optimization can be done.  */\n+  /* In the variable case, do the same as above, but in a loop.  Note that we\n+     must be extra careful with variables wrapping around because we might be\n+     at the very top (or the very bottom) of the address space and we have to\n+     be able to handle this case properly; in particular, we use an equality\n+     test for the loop condition.  */\n   else\n     {\n-      rtx test_addr\n-\t= force_operand (gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,\n-\t\t\t\t\t stack_pointer_rtx,\n-\t\t\t\t\t GEN_INT (first + STACK_CHECK_PROBE_INTERVAL)),\n-\t\t\t NULL_RTX);\n-      rtx last_addr\n-\t= force_operand (gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,\n-\t\t\t\t\t stack_pointer_rtx,\n-\t\t\t\t\t plus_constant (size, first)),\n-\t\t\t NULL_RTX);\n-      rtx incr = GEN_INT (STACK_CHECK_PROBE_INTERVAL);\n+      rtx rounded_size, rounded_size_op, test_addr, last_addr, temp;\n       rtx loop_lab = gen_label_rtx ();\n-      rtx test_lab = gen_label_rtx ();\n       rtx end_lab = gen_label_rtx ();\n-      rtx temp;\n \n-      if (!REG_P (test_addr)\n-\t  || REGNO (test_addr) < FIRST_PSEUDO_REGISTER)\n-\ttest_addr = force_reg (Pmode, test_addr);\n \n-      emit_jump (test_lab);\n+      /* Step 1: round SIZE to the previous multiple of the interval.  */\n+\n+      /* ROUNDED_SIZE = SIZE & -PROBE_INTERVAL  */\n+      rounded_size\n+\t= simplify_gen_binary (AND, Pmode, size, GEN_INT (-PROBE_INTERVAL));\n+      rounded_size_op = force_operand (rounded_size, NULL_RTX);\n+\n+\n+      /* Step 2: compute initial and final value of the loop counter.  */\n+\n+      /* TEST_ADDR = SP + FIRST.  */\n+      test_addr = force_operand (gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,\n+\t\t\t\t\t \t stack_pointer_rtx,\n+\t\t\t\t\t \t GEN_INT (first)), NULL_RTX);\n+\n+      /* LAST_ADDR = SP + FIRST + ROUNDED_SIZE.  */\n+      last_addr = force_operand (gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,\n+\t\t\t\t\t\t test_addr,\n+\t\t\t\t\t\t rounded_size_op), NULL_RTX);\n+\n+\n+      /* Step 3: the loop\n+\n+\t while (TEST_ADDR != LAST_ADDR)\n+\t   {\n+\t     TEST_ADDR = TEST_ADDR + PROBE_INTERVAL\n+\t     probe at TEST_ADDR\n+\t   }\n+\n+\t probes at FIRST + N * PROBE_INTERVAL for values of N from 1\n+\t until it is equal to ROUNDED_SIZE.  */\n \n       emit_label (loop_lab);\n-      emit_stack_probe (test_addr);\n \n-#ifdef STACK_GROWS_DOWNWARD\n-#define CMP_OPCODE GTU\n-      temp = expand_binop (Pmode, sub_optab, test_addr, incr, test_addr,\n-\t\t\t   1, OPTAB_WIDEN);\n-#else\n-#define CMP_OPCODE LTU\n-      temp = expand_binop (Pmode, add_optab, test_addr, incr, test_addr,\n+      /* Jump to END_LAB if TEST_ADDR == LAST_ADDR.  */\n+      emit_cmp_and_jump_insns (test_addr, last_addr, EQ, NULL_RTX, Pmode, 1,\n+\t\t\t       end_lab);\n+\n+      /* TEST_ADDR = TEST_ADDR + PROBE_INTERVAL.  */\n+      temp = expand_binop (Pmode, STACK_GROW_OPTAB, test_addr,\n+\t\t\t   GEN_INT (PROBE_INTERVAL), test_addr,\n \t\t\t   1, OPTAB_WIDEN);\n-#endif\n \n       gcc_assert (temp == test_addr);\n \n-      emit_label (test_lab);\n-      emit_cmp_and_jump_insns (test_addr, last_addr, CMP_OPCODE,\n-\t\t\t       NULL_RTX, Pmode, 1, loop_lab);\n-      emit_jump (end_lab);\n+      /* Probe at TEST_ADDR.  */\n+      emit_stack_probe (test_addr);\n+\n+      emit_jump (loop_lab);\n+\n       emit_label (end_lab);\n \n-      emit_stack_probe (last_addr);\n+\n+      /* Step 4: probe at FIRST + SIZE if we cannot assert at compile-time\n+\t that SIZE is equal to ROUNDED_SIZE.  */\n+\n+      /* TEMP = SIZE - ROUNDED_SIZE.  */\n+      temp = simplify_gen_binary (MINUS, Pmode, size, rounded_size);\n+      if (temp != const0_rtx)\n+\t{\n+\t  rtx addr;\n+\n+\t  if (GET_CODE (temp) == CONST_INT)\n+\t    {\n+\t      /* Use [base + disp} addressing mode if supported.  */\n+\t      HOST_WIDE_INT offset = INTVAL (temp);\n+\t      addr = memory_address (Pmode,\n+\t\t\t\t     plus_constant (last_addr,\n+\t\t\t\t\t\t    STACK_GROW_OFF (offset)));\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Manual CSE if the difference is not known at compile-time.  */\n+\t      temp = gen_rtx_MINUS (Pmode, size, rounded_size_op);\n+\t      addr = memory_address (Pmode,\n+\t\t\t\t     gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,\n+\t\t\t\t\t\t     last_addr, temp));\n+\t    }\n+\n+\t  emit_stack_probe (addr);\n+\t}\n     }\n }\n-\f\n+\n+/* Adjust the stack by SIZE bytes while probing it.  Note that we skip the\n+   probe for the first interval + a small dope of 4 words and instead probe\n+   that many bytes past the specified size to maintain a protection area.  */\n+\n+static void\n+anti_adjust_stack_and_probe (rtx size)\n+{\n+  const int dope = 4 * UNITS_PER_WORD;\n+\n+  /* First ensure SIZE is Pmode.  */\n+  if (GET_MODE (size) != VOIDmode && GET_MODE (size) != Pmode)\n+    size = convert_to_mode (Pmode, size, 1);\n+\n+  /* If we have a constant small number of probes to generate, that's the\n+     easy case.  */\n+  if (GET_CODE (size) == CONST_INT && INTVAL (size) < 7 * PROBE_INTERVAL)\n+    {\n+      HOST_WIDE_INT isize = INTVAL (size), i;\n+      bool first_probe = true;\n+\n+      /* Adjust SP and probe to PROBE_INTERVAL + N * PROBE_INTERVAL for\n+\t values of N from 1 until it exceeds SIZE.  If only one probe is\n+\t needed, this will not generate any code.  Then adjust and probe\n+\t to PROBE_INTERVAL + SIZE.  */\n+      for (i = PROBE_INTERVAL; i < isize; i += PROBE_INTERVAL)\n+\t{\n+\t  if (first_probe)\n+\t    {\n+\t      anti_adjust_stack (GEN_INT (2 * PROBE_INTERVAL + dope));\n+\t      first_probe = false;\n+\t    }\n+\t  else\n+\t    anti_adjust_stack (GEN_INT (PROBE_INTERVAL));\n+\t  emit_stack_probe (stack_pointer_rtx);\n+\t}\n+\n+      if (first_probe)\n+\tanti_adjust_stack (plus_constant (size, PROBE_INTERVAL + dope));\n+      else\n+\tanti_adjust_stack (plus_constant (size, PROBE_INTERVAL - i));\n+      emit_stack_probe (stack_pointer_rtx);\n+    }\n+\n+  /* In the variable case, do the same as above, but in a loop.  Note that we\n+     must be extra careful with variables wrapping around because we might be\n+     at the very top (or the very bottom) of the address space and we have to\n+     be able to handle this case properly; in particular, we use an equality\n+     test for the loop condition.  */\n+  else\n+    {\n+      rtx rounded_size, rounded_size_op, last_addr, temp;\n+      rtx loop_lab = gen_label_rtx ();\n+      rtx end_lab = gen_label_rtx ();\n+\n+\n+      /* Step 1: round SIZE to the previous multiple of the interval.  */\n+\n+      /* ROUNDED_SIZE = SIZE & -PROBE_INTERVAL  */\n+      rounded_size\n+\t= simplify_gen_binary (AND, Pmode, size, GEN_INT (-PROBE_INTERVAL));\n+      rounded_size_op = force_operand (rounded_size, NULL_RTX);\n+\n+\n+      /* Step 2: compute initial and final value of the loop counter.  */\n+\n+      /* SP = SP_0 + PROBE_INTERVAL.  */\n+      anti_adjust_stack (GEN_INT (PROBE_INTERVAL + dope));\n+\n+      /* LAST_ADDR = SP_0 + PROBE_INTERVAL + ROUNDED_SIZE.  */\n+      last_addr = force_operand (gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,\n+\t\t\t\t\t\t stack_pointer_rtx,\n+\t\t\t\t\t\t rounded_size_op), NULL_RTX);\n+\n+\n+      /* Step 3: the loop\n+\n+\t  while (SP != LAST_ADDR)\n+\t    {\n+\t      SP = SP + PROBE_INTERVAL\n+\t      probe at SP\n+\t    }\n+\n+\t adjusts SP and probes to PROBE_INTERVAL + N * PROBE_INTERVAL for\n+\t values of N from 1 until it is equal to ROUNDED_SIZE.  */\n+\n+      emit_label (loop_lab);\n+\n+      /* Jump to END_LAB if SP == LAST_ADDR.  */\n+      emit_cmp_and_jump_insns (stack_pointer_rtx, last_addr, EQ, NULL_RTX,\n+\t\t\t       Pmode, 1, end_lab);\n+\n+      /* SP = SP + PROBE_INTERVAL and probe at SP.  */\n+      anti_adjust_stack (GEN_INT (PROBE_INTERVAL));\n+      emit_stack_probe (stack_pointer_rtx);\n+\n+      emit_jump (loop_lab);\n+\n+      emit_label (end_lab);\n+\n+\n+      /* Step 4: adjust SP and probe to PROBE_INTERVAL + SIZE if we cannot\n+\t assert at compile-time that SIZE is equal to ROUNDED_SIZE.  */\n+\n+      /* TEMP = SIZE - ROUNDED_SIZE.  */\n+      temp = simplify_gen_binary (MINUS, Pmode, size, rounded_size);\n+      if (temp != const0_rtx)\n+\t{\n+\t  /* Manual CSE if the difference is not known at compile-time.  */\n+\t  if (GET_CODE (temp) != CONST_INT)\n+\t    temp = gen_rtx_MINUS (Pmode, size, rounded_size_op);\n+\t  anti_adjust_stack (temp);\n+\t  emit_stack_probe (stack_pointer_rtx);\n+\t}\n+    }\n+\n+  /* Adjust back to account for the additional first interval.  */\n+  adjust_stack (GEN_INT (PROBE_INTERVAL + dope));\n+}\n+\n /* Return an rtx representing the register or memory location\n    in which a scalar value of data type VALTYPE\n    was returned by a function call to function FUNC."}, {"sha": "e84779639b5945d39cfd5a03ec38091ab9847be6", "filename": "gcc/expr.h", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d809253a56a642cdeb31f3f12e420f092cee0d07/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d809253a56a642cdeb31f3f12e420f092cee0d07/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=d809253a56a642cdeb31f3f12e420f092cee0d07", "patch": "@@ -218,16 +218,21 @@ do {\t\t\t\t\t\t\t\t\\\n #define STACK_CHECK_STATIC_BUILTIN 0\n #endif\n \n-/* The default interval is one page.  */\n-#ifndef STACK_CHECK_PROBE_INTERVAL\n-#define STACK_CHECK_PROBE_INTERVAL 4096\n+/* The default interval is one page (4096 bytes).  */\n+#ifndef STACK_CHECK_PROBE_INTERVAL_EXP\n+#define STACK_CHECK_PROBE_INTERVAL_EXP 12\n #endif\n \n /* The default is to do a store into the stack.  */\n #ifndef STACK_CHECK_PROBE_LOAD\n #define STACK_CHECK_PROBE_LOAD 0\n #endif\n \n+/* The default is not to move the stack pointer.  */\n+#ifndef STACK_CHECK_MOVING_SP\n+#define STACK_CHECK_MOVING_SP 0\n+#endif\n+\n /* This is a kludge to try to capture the discrepancy between the old\n    mechanism (generic stack checking) and the new mechanism (static\n    builtin stack checking).  STACK_CHECK_PROTECT needs to be bumped\n@@ -252,7 +257,7 @@ do {\t\t\t\t\t\t\t\t\\\n    one probe per function.  */\n #ifndef STACK_CHECK_MAX_FRAME_SIZE\n #define STACK_CHECK_MAX_FRAME_SIZE \\\n-  (STACK_CHECK_PROBE_INTERVAL - UNITS_PER_WORD)\n+  ((1 << STACK_CHECK_PROBE_INTERVAL_EXP) - UNITS_PER_WORD)\n #endif\n \n /* This is arbitrary, but should be large enough everywhere.  */\n@@ -779,10 +784,9 @@ extern void update_nonlocal_goto_save_area (void);\n extern rtx allocate_dynamic_stack_space (rtx, rtx, int);\n \n /* Probe a range of stack addresses from FIRST to FIRST+SIZE, inclusive.\n-   FIRST is a constant and size is a Pmode RTX.  These are offsets from the\n-   current stack pointer.  STACK_GROWS_DOWNWARD says whether to add or\n-   subtract from the stack.  If SIZE is constant, this is done\n-   with a fixed number of probes.  Otherwise, we must make a loop.  */\n+   FIRST is a constant and size is a Pmode RTX.  These are offsets from\n+   the current stack pointer.  STACK_GROWS_DOWNWARD says whether to add\n+   or subtract them from the stack pointer.  */\n extern void probe_stack_range (HOST_WIDE_INT, rtx);\n \n /* Return an rtx that refers to the value returned by a library call"}, {"sha": "a3e899f83138dbd17a9cc8f87d43f65f4d0f9348", "filename": "gcc/ira.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d809253a56a642cdeb31f3f12e420f092cee0d07/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d809253a56a642cdeb31f3f12e420f092cee0d07/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=d809253a56a642cdeb31f3f12e420f092cee0d07", "patch": "@@ -1442,6 +1442,9 @@ ira_setup_eliminable_regset (void)\n   int need_fp\n     = (! flag_omit_frame_pointer\n        || (cfun->calls_alloca && EXIT_IGNORE_STACK)\n+       /* We need the frame pointer to catch stack overflow exceptions\n+\t  if the stack pointer is moving.  */\n+       || (flag_stack_check && STACK_CHECK_MOVING_SP)\n        || crtl->accesses_prior_frames\n        || crtl->stack_realign_needed\n        || targetm.frame_pointer_required ());"}, {"sha": "ab88f23a3790b7bba105f6a4333dbb9e07b9d7ca", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d809253a56a642cdeb31f3f12e420f092cee0d07/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d809253a56a642cdeb31f3f12e420f092cee0d07/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=d809253a56a642cdeb31f3f12e420f092cee0d07", "patch": "@@ -2252,6 +2252,11 @@ may_trap_p_1 (const_rtx x, unsigned flags)\n \n       /* Memory ref can trap unless it's a static var or a stack slot.  */\n     case MEM:\n+      /* Recognize specific pattern of stack checking probes.  */\n+      if (flag_stack_check\n+\t  && MEM_VOLATILE_P (x)\n+\t  && XEXP (x, 0) == stack_pointer_rtx)\n+\treturn 1;\n       if (/* MEM_NOTRAP_P only relates to the actual position of the memory\n \t     reference; moving it out of context such as when moving code\n \t     when optimizing, might cause its address to become invalid.  */"}, {"sha": "03910d0152f2a2fb88d1fdc22629d8e74329e878", "filename": "gcc/system.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d809253a56a642cdeb31f3f12e420f092cee0d07/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d809253a56a642cdeb31f3f12e420f092cee0d07/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=d809253a56a642cdeb31f3f12e420f092cee0d07", "patch": "@@ -761,7 +761,7 @@ extern void fancy_abort (const char *, int, const char *) ATTRIBUTE_NORETURN;\n \tTARGET_ASM_EXCEPTION_SECTION TARGET_ASM_EH_FRAME_SECTION\t   \\\n \tSMALL_ARG_MAX ASM_OUTPUT_SHARED_BSS ASM_OUTPUT_SHARED_COMMON\t   \\\n \tASM_OUTPUT_SHARED_LOCAL UNALIGNED_WORD_ASM_OP\t\t\t   \\\n-\tASM_MAKE_LABEL_LINKONCE\n+\tASM_MAKE_LABEL_LINKONCE STACK_CHECK_PROBE_INTERVAL\n \n /* Hooks that are no longer used.  */\n  #pragma GCC poison LANG_HOOKS_FUNCTION_MARK LANG_HOOKS_FUNCTION_FREE\t\\"}, {"sha": "4a499e28f8a5c3f43d9d770c352a075d62fa7a4f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d809253a56a642cdeb31f3f12e420f092cee0d07/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d809253a56a642cdeb31f3f12e420f092cee0d07/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d809253a56a642cdeb31f3f12e420f092cee0d07", "patch": "@@ -1,3 +1,8 @@\n+2009-11-03  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/stack_check.adb1: New test.\n+\t* gnat.dg/stack_check.adb2: Likewise.\n+\n 2009-11-03  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR rtl-optimization/41917"}, {"sha": "51ee1a633b31696ce63f8f3aee109fd62cce9dc7", "filename": "gcc/testsuite/gnat.dg/stack_check1.adb", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d809253a56a642cdeb31f3f12e420f092cee0d07/gcc%2Ftestsuite%2Fgnat.dg%2Fstack_check1.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d809253a56a642cdeb31f3f12e420f092cee0d07/gcc%2Ftestsuite%2Fgnat.dg%2Fstack_check1.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fstack_check1.adb?ref=d809253a56a642cdeb31f3f12e420f092cee0d07", "patch": "@@ -0,0 +1,38 @@\n+-- { dg-do run }\n+-- { dg-options \"-fstack-check\" }\n+\n+-- This test requires architecture- and OS-specific support code for unwinding\n+-- through signal frames (typically located in *-unwind.h) to pass.  Feel free\n+-- to disable it if this code hasn't been implemented yet.\n+\n+procedure Stack_Check1 is\n+\n+  type A is Array (1..2048) of Integer;\n+\n+  procedure Consume_Stack (N : Integer) is\n+    My_A : A; -- 8 KB static\n+  begin\n+    My_A (1) := 0;\n+    if N <= 0 then\n+      return;\n+    end if;\n+    Consume_Stack (N-1);\n+  end;\n+\n+  Task T;\n+\n+  Task body T is\n+  begin\n+    begin\n+      Consume_Stack (Integer'Last);\n+      raise Program_Error;\n+    exception\n+      when Storage_Error => null;\n+    end;\n+\n+    Consume_Stack (128);\n+  end;\n+\n+begin\n+  null;\n+end;"}, {"sha": "4a3008ba02b2bcdf8d9a15bf37515c36267a27a5", "filename": "gcc/testsuite/gnat.dg/stack_check2.adb", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d809253a56a642cdeb31f3f12e420f092cee0d07/gcc%2Ftestsuite%2Fgnat.dg%2Fstack_check2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d809253a56a642cdeb31f3f12e420f092cee0d07/gcc%2Ftestsuite%2Fgnat.dg%2Fstack_check2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fstack_check2.adb?ref=d809253a56a642cdeb31f3f12e420f092cee0d07", "patch": "@@ -0,0 +1,43 @@\n+-- { dg-do run }\n+-- { dg-options \"-fstack-check\" }\n+\n+-- This test requires architecture- and OS-specific support code for unwinding\n+-- through signal frames (typically located in *-unwind.h) to pass.  Feel free\n+-- to disable it if this code hasn't been implemented yet.\n+\n+procedure Stack_Check2 is\n+\n+  function UB return Integer is\n+  begin\n+    return 2048;\n+  end;\n+\n+  type A is Array (Positive range <>) of Integer;\n+\n+  procedure Consume_Stack (N : Integer) is\n+    My_A : A (1..UB); -- 8 KB dynamic\n+  begin\n+    My_A (1) := 0;\n+    if N <= 0 then\n+      return;\n+    end if;\n+    Consume_Stack (N-1);\n+  end;\n+\n+  Task T;\n+\n+  Task body T is\n+  begin\n+    begin\n+      Consume_Stack (Integer'Last);\n+      raise Program_Error;\n+    exception\n+      when Storage_Error => null;\n+    end;\n+\n+    Consume_Stack (128);\n+  end;\n+\n+begin\n+  null;\n+end;"}, {"sha": "f3970dd3a55e704d9040976970936f9808913a27", "filename": "gcc/tree.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d809253a56a642cdeb31f3f12e420f092cee0d07/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d809253a56a642cdeb31f3f12e420f092cee0d07/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=d809253a56a642cdeb31f3f12e420f092cee0d07", "patch": "@@ -9009,7 +9009,8 @@ build_common_builtin_nodes (void)\n       tmp = tree_cons (NULL_TREE, size_type_node, void_list_node);\n       ftype = build_function_type (ptr_type_node, tmp);\n       local_define_builtin (\"__builtin_alloca\", ftype, BUILT_IN_ALLOCA,\n-\t\t\t    \"alloca\", ECF_NOTHROW | ECF_MALLOC);\n+\t\t\t    \"alloca\",\n+\t\t\t    ECF_MALLOC | (flag_stack_check ? 0 : ECF_NOTHROW));\n     }\n \n   tmp = tree_cons (NULL_TREE, ptr_type_node, void_list_node);"}, {"sha": "2208f17dc1db62bfe97c8b719a86df20c974647d", "filename": "gcc/unwind-dw2.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d809253a56a642cdeb31f3f12e420f092cee0d07/gcc%2Funwind-dw2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d809253a56a642cdeb31f3f12e420f092cee0d07/gcc%2Funwind-dw2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-dw2.c?ref=d809253a56a642cdeb31f3f12e420f092cee0d07", "patch": "@@ -1559,7 +1559,13 @@ uw_install_context_1 (struct _Unwind_Context *current,\n static inline _Unwind_Ptr\n uw_identify_context (struct _Unwind_Context *context)\n {\n-  return _Unwind_GetCFA (context);\n+  /* The CFA is not sufficient to disambiguate the context of a function\n+     interrupted by a signal before establishing its frame and the context\n+     of the signal itself.  */\n+  if (STACK_GROWS_DOWNWARD)\n+    return _Unwind_GetCFA (context) - _Unwind_IsSignalFrame (context);\n+  else\n+    return _Unwind_GetCFA (context) + _Unwind_IsSignalFrame (context);\n }\n \n "}]}