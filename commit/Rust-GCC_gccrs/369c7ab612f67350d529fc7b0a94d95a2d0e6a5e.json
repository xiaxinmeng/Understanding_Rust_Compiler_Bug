{"sha": "369c7ab612f67350d529fc7b0a94d95a2d0e6a5e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzY5YzdhYjYxMmY2NzM1MGQ1MjlmYzdiMGE5NGQ5NWEyZDBlNmE1ZQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-12-29T02:17:58Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-12-29T02:17:58Z"}, "message": "(find_equiv_reg): Exclude registers clobbered in the\nCALL_INSN_FUNCTION_USAGE field of a CALL_INSN.\n\nFrom-SVN: r8696", "tree": {"sha": "46f60b85fef073407d3144159efe02f1bc92bcc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46f60b85fef073407d3144159efe02f1bc92bcc6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/369c7ab612f67350d529fc7b0a94d95a2d0e6a5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/369c7ab612f67350d529fc7b0a94d95a2d0e6a5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/369c7ab612f67350d529fc7b0a94d95a2d0e6a5e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/369c7ab612f67350d529fc7b0a94d95a2d0e6a5e/comments", "author": null, "committer": null, "parents": [{"sha": "581d4b9d55cea8af6d272b699a114a947468dd46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/581d4b9d55cea8af6d272b699a114a947468dd46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/581d4b9d55cea8af6d272b699a114a947468dd46"}], "stats": {"total": 45, "additions": 45, "deletions": 0}, "files": [{"sha": "e739c6c9a1aab6bc24c2276bf692399b6a11ad5b", "filename": "gcc/reload.c", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/369c7ab612f67350d529fc7b0a94d95a2d0e6a5e/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/369c7ab612f67350d529fc7b0a94d95a2d0e6a5e/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=369c7ab612f67350d529fc7b0a94d95a2d0e6a5e", "patch": "@@ -5584,6 +5584,51 @@ find_equiv_reg (goal, insn, class, other, reload_reg_p, goalreg, mode)\n \t\t}\n \t    }\n \n+\t  if (GET_CODE (p) == CALL_INSN && CALL_INSN_FUNCTION_USAGE (p))\n+\t    {\n+\t      rtx link;\n+\n+\t      for (link = CALL_INSN_FUNCTION_USAGE (p); XEXP (link, 1) != 0;\n+\t\t   link = XEXP (link, 1))\n+\t\t{\n+\t\t  pat = XEXP (link, 0);\n+\t\t  if (GET_CODE (pat) == CLOBBER)\n+\t\t    {\n+\t\t      register rtx dest = SET_DEST (pat);\n+\t\t      while (GET_CODE (dest) == SUBREG\n+\t\t\t     || GET_CODE (dest) == ZERO_EXTRACT\n+\t\t\t     || GET_CODE (dest) == SIGN_EXTRACT\n+\t\t\t     || GET_CODE (dest) == STRICT_LOW_PART)\n+\t\t\tdest = XEXP (dest, 0);\n+\t\t      if (GET_CODE (dest) == REG)\n+\t\t\t{\n+\t\t\t  register int xregno = REGNO (dest);\n+\t\t\t  int xnregs;\n+\t\t\t  if (REGNO (dest) < FIRST_PSEUDO_REGISTER)\n+\t\t\t    xnregs = HARD_REGNO_NREGS (xregno, GET_MODE (dest));\n+\t\t\t  else\n+\t\t\t    xnregs = 1;\n+\t\t\t  if (xregno < regno + nregs\n+\t\t\t      && xregno + xnregs > regno)\n+\t\t\t    return 0;\n+\t\t\t  if (xregno < valueno + valuenregs\n+\t\t\t      && xregno + xnregs > valueno)\n+\t\t\t    return 0;\n+\t\t\t  if (goal_mem_addr_varies\n+\t\t\t      && reg_overlap_mentioned_for_reload_p (dest,\n+\t\t\t\t\t\t\t\t     goal))\n+\t\t\t    return 0;\n+\t\t\t}\n+\t\t      else if (goal_mem && GET_CODE (dest) == MEM\n+\t\t\t       && ! push_operand (dest, GET_MODE (dest)))\n+\t\t\treturn 0;\n+\t\t      else if (need_stable_sp\n+\t\t\t       && push_operand (dest, GET_MODE (dest)))\n+\t\t\treturn 0;\n+\t\t    }\n+\t\t}\n+\t    }\n+\n #ifdef AUTO_INC_DEC\n \t  /* If this insn auto-increments or auto-decrements\n \t     either regno or valueno, return 0 now."}]}