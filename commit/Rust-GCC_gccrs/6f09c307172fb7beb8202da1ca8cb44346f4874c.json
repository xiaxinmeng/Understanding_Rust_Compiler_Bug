{"sha": "6f09c307172fb7beb8202da1ca8cb44346f4874c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmYwOWMzMDcxNzJmYjdiZWI4MjAyZGExY2E4Y2I0NDM0NmY0ODc0Yw==", "commit": {"author": {"name": "Anthony Green", "email": "green@redhat.com", "date": "2000-08-27T22:06:44Z"}, "committer": {"name": "Anthony Green", "email": "green@gcc.gnu.org", "date": "2000-08-27T22:06:44Z"}, "message": "ArrayList.java, [...]: Imported from GNU Classpath.\n\n2000-08-27  Anthony Green  <green@redhat.com>\n\n\t* java/util/ArrayList.java, java/util/Timer.java,\n\tjava/util/LinkedList.java, java/util/TimerTask.java,\n\tjava/util/HashMap.java, java/util/AbstractMap.java,\n\tjava/util/SortedMap.java, java/util/AbstractSequentialList.java,\n\tjava/util/SortedSet.java: Imported from GNU Classpath.\n\t* Makefile.in: Rebuilt.\n\t* Makefile.am: Added new files.\n\nFrom-SVN: r36006", "tree": {"sha": "c342711888f627f7baae5e2abb62a00909d971ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c342711888f627f7baae5e2abb62a00909d971ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f09c307172fb7beb8202da1ca8cb44346f4874c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f09c307172fb7beb8202da1ca8cb44346f4874c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f09c307172fb7beb8202da1ca8cb44346f4874c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f09c307172fb7beb8202da1ca8cb44346f4874c/comments", "author": {"login": "atgreen", "id": 89993, "node_id": "MDQ6VXNlcjg5OTkz", "avatar_url": "https://avatars.githubusercontent.com/u/89993?v=4", "gravatar_id": "", "url": "https://api.github.com/users/atgreen", "html_url": "https://github.com/atgreen", "followers_url": "https://api.github.com/users/atgreen/followers", "following_url": "https://api.github.com/users/atgreen/following{/other_user}", "gists_url": "https://api.github.com/users/atgreen/gists{/gist_id}", "starred_url": "https://api.github.com/users/atgreen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/atgreen/subscriptions", "organizations_url": "https://api.github.com/users/atgreen/orgs", "repos_url": "https://api.github.com/users/atgreen/repos", "events_url": "https://api.github.com/users/atgreen/events{/privacy}", "received_events_url": "https://api.github.com/users/atgreen/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e53ca51f94aea5a90e6326d634c2286982359166", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e53ca51f94aea5a90e6326d634c2286982359166", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e53ca51f94aea5a90e6326d634c2286982359166"}], "stats": {"total": 3122, "additions": 3112, "deletions": 10}, "files": [{"sha": "222bb3cf2049363873b9f82a61e5ad5092d5afc7", "filename": "libjava/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f09c307172fb7beb8202da1ca8cb44346f4874c/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f09c307172fb7beb8202da1ca8cb44346f4874c/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=6f09c307172fb7beb8202da1ca8cb44346f4874c", "patch": "@@ -1,3 +1,13 @@\n+2000-08-27  Anthony Green  <green@redhat.com>\n+\n+\t* java/util/ArrayList.java, java/util/Timer.java,\n+\tjava/util/LinkedList.java, java/util/TimerTask.java,\n+\tjava/util/HashMap.java, java/util/AbstractMap.java,\n+\tjava/util/SortedMap.java, java/util/AbstractSequentialList.java,\n+\tjava/util/SortedSet.java: Imported from GNU Classpath.\n+\t* Makefile.in: Rebuilt.\n+\t* Makefile.am: Added new files.\n+\t\n 2000-08-26  Anthony Green  <green@redhat.com>\n \n \t* Makefile.in: Rebuilt."}, {"sha": "403333ab750cc62fb7f09c88aed59a288e11cb33", "filename": "libjava/Makefile.am", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f09c307172fb7beb8202da1ca8cb44346f4874c/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f09c307172fb7beb8202da1ca8cb44346f4874c/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=6f09c307172fb7beb8202da1ca8cb44346f4874c", "patch": "@@ -1030,7 +1030,10 @@ java/text/SimpleDateFormat.java\t\\\n java/text/StringCharacterIterator.java \\\n java/util/AbstractCollection.java \\\n java/util/AbstractList.java \\\n+java/util/AbstractMap.java \\\n+java/util/AbstractSequentialList.java \\\n java/util/AbstractSet.java \\\n+java/util/ArrayList.java \\\n java/util/Arrays.java \\\n java/util/BasicMapEntry.java \\\n java/util/BitSet.java \\\n@@ -1046,6 +1049,7 @@ java/util/Enumeration.java \\\n java/util/EventListener.java \\\n java/util/EventObject.java \\\n java/util/GregorianCalendar.java \\\n+java/util/HashMap.java \\\n java/util/Hashtable.java \\\n java/util/Iterator.java\t\\\n java/util/List.java \\\n@@ -1064,9 +1068,13 @@ java/util/Random.java \\\n java/util/ResourceBundle.java \\\n java/util/Set.java \\\n java/util/SimpleTimeZone.java \\\n+java/util/SortedMap.java \\\n+java/util/SortedSet.java \\\n java/util/Stack.java \\\n java/util/StringTokenizer.java \\\n java/util/TimeZone.java\t\\\n+java/util/Timer.java \\\n+java/util/TimerTask.java \\\n java/util/TooManyListenersException.java \\\n java/util/Vector.java \\\n java/util/jar/Attributes.java \\"}, {"sha": "afa1383696b2fb0aae5caa476cbdf755e5a13483", "filename": "libjava/Makefile.in", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f09c307172fb7beb8202da1ca8cb44346f4874c/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f09c307172fb7beb8202da1ca8cb44346f4874c/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=6f09c307172fb7beb8202da1ca8cb44346f4874c", "patch": "@@ -799,7 +799,10 @@ java/text/SimpleDateFormat.java\t\\\n java/text/StringCharacterIterator.java \\\n java/util/AbstractCollection.java \\\n java/util/AbstractList.java \\\n+java/util/AbstractMap.java \\\n+java/util/AbstractSequentialList.java \\\n java/util/AbstractSet.java \\\n+java/util/ArrayList.java \\\n java/util/Arrays.java \\\n java/util/BasicMapEntry.java \\\n java/util/BitSet.java \\\n@@ -815,6 +818,7 @@ java/util/Enumeration.java \\\n java/util/EventListener.java \\\n java/util/EventObject.java \\\n java/util/GregorianCalendar.java \\\n+java/util/HashMap.java \\\n java/util/Hashtable.java \\\n java/util/Iterator.java\t\\\n java/util/List.java \\\n@@ -833,9 +837,13 @@ java/util/Random.java \\\n java/util/ResourceBundle.java \\\n java/util/Set.java \\\n java/util/SimpleTimeZone.java \\\n+java/util/SortedMap.java \\\n+java/util/SortedSet.java \\\n java/util/Stack.java \\\n java/util/StringTokenizer.java \\\n java/util/TimeZone.java\t\\\n+java/util/Timer.java \\\n+java/util/TimerTask.java \\\n java/util/TooManyListenersException.java \\\n java/util/Vector.java \\\n java/util/jar/Attributes.java \\\n@@ -1429,26 +1437,30 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/text/RuleBasedCollator.P .deps/java/text/SimpleDateFormat.P \\\n .deps/java/text/StringCharacterIterator.P \\\n .deps/java/util/AbstractCollection.P .deps/java/util/AbstractList.P \\\n-.deps/java/util/AbstractSet.P .deps/java/util/Arrays.P \\\n-.deps/java/util/BasicMapEntry.P .deps/java/util/BitSet.P \\\n-.deps/java/util/Bucket.P .deps/java/util/Calendar.P \\\n-.deps/java/util/Collection.P .deps/java/util/Comparator.P \\\n+.deps/java/util/AbstractMap.P .deps/java/util/AbstractSequentialList.P \\\n+.deps/java/util/AbstractSet.P .deps/java/util/ArrayList.P \\\n+.deps/java/util/Arrays.P .deps/java/util/BasicMapEntry.P \\\n+.deps/java/util/BitSet.P .deps/java/util/Bucket.P \\\n+.deps/java/util/Calendar.P .deps/java/util/Collection.P \\\n+.deps/java/util/Comparator.P \\\n .deps/java/util/ConcurrentModificationException.P \\\n .deps/java/util/Date.P .deps/java/util/Dictionary.P \\\n .deps/java/util/EmptyStackException.P .deps/java/util/Enumeration.P \\\n .deps/java/util/EventListener.P .deps/java/util/EventObject.P \\\n-.deps/java/util/GregorianCalendar.P .deps/java/util/Hashtable.P \\\n-.deps/java/util/Iterator.P .deps/java/util/List.P \\\n-.deps/java/util/ListIterator.P .deps/java/util/ListResourceBundle.P \\\n-.deps/java/util/Locale.P .deps/java/util/Map.P \\\n-.deps/java/util/MissingResourceException.P \\\n+.deps/java/util/GregorianCalendar.P .deps/java/util/HashMap.P \\\n+.deps/java/util/Hashtable.P .deps/java/util/Iterator.P \\\n+.deps/java/util/List.P .deps/java/util/ListIterator.P \\\n+.deps/java/util/ListResourceBundle.P .deps/java/util/Locale.P \\\n+.deps/java/util/Map.P .deps/java/util/MissingResourceException.P \\\n .deps/java/util/NoSuchElementException.P .deps/java/util/Observable.P \\\n .deps/java/util/Observer.P .deps/java/util/Properties.P \\\n .deps/java/util/PropertyPermission.P \\\n .deps/java/util/PropertyResourceBundle.P .deps/java/util/Random.P \\\n .deps/java/util/ResourceBundle.P .deps/java/util/Set.P \\\n-.deps/java/util/SimpleTimeZone.P .deps/java/util/Stack.P \\\n+.deps/java/util/SimpleTimeZone.P .deps/java/util/SortedMap.P \\\n+.deps/java/util/SortedSet.P .deps/java/util/Stack.P \\\n .deps/java/util/StringTokenizer.P .deps/java/util/TimeZone.P \\\n+.deps/java/util/Timer.P .deps/java/util/TimerTask.P \\\n .deps/java/util/TooManyListenersException.P .deps/java/util/Vector.P \\\n .deps/java/util/jar/Attributes.P .deps/java/util/jar/JarEntry.P \\\n .deps/java/util/jar/JarException.P .deps/java/util/jar/JarFile.P \\"}, {"sha": "4935afe5fb316e163aaf76fe0bbbe694504b7df5", "filename": "libjava/java/util/AbstractMap.java", "status": "added", "additions": 283, "deletions": 0, "changes": 283, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f09c307172fb7beb8202da1ca8cb44346f4874c/libjava%2Fjava%2Futil%2FAbstractMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f09c307172fb7beb8202da1ca8cb44346f4874c/libjava%2Fjava%2Futil%2FAbstractMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FAbstractMap.java?ref=6f09c307172fb7beb8202da1ca8cb44346f4874c", "patch": "@@ -0,0 +1,283 @@\n+/* AbstractMap.java -- Abstract implementation of most of Map\n+   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+// TO DO:\n+// comments\n+// test suite\n+\n+package java.util;\n+\n+public abstract class AbstractMap implements Map {\n+  \n+  public void clear()\n+  {\n+    entrySet().clear();\n+  }\n+\n+  public boolean containsKey( Object key )\n+  {\n+    Object k;\n+    Iterator entries = entrySet().iterator();\n+  \n+    while( entries.hasNext() )\n+    {\n+      k = ((Map.Entry)entries.next()).getKey();\n+      if( key == null ? k == null : key.equals( k ) )\n+\treturn true;\n+    }\n+\n+    return false;\n+  }\n+\n+  public boolean containsValue( Object value )\n+  {\n+    Object v;\n+    Iterator entries = entrySet().iterator();\n+  \n+    while( entries.hasNext() )\n+    {\n+      v = ((Map.Entry)entries.next()).getValue();\n+      if( value == null ? v == null : value.equals( v ) )\n+\treturn true;\n+    }\n+\n+    return false; \n+  }\n+\n+  public abstract Set entrySet();\n+\n+  public boolean equals( Object o )\n+  {\n+    if( this == o )\n+      return true;\n+    \n+    if( o == null || !( o instanceof Map ) )\n+      return false;\n+    \n+    Map m = (Map)o;\n+    if( m.size() != size() )\n+      return false;\n+    \n+    Object key, value1, value2;\n+    Map.Entry entry;\n+    Iterator entries = entrySet().iterator();\n+    while( entries.hasNext() )\n+    {\n+      entry = (Map.Entry)entries.next();\n+      key = entry.getKey();\n+      value1 = entry.getValue();\n+      value2 = m.get( key );\n+      \n+      if( !( ( value1 == null && value2 == null )\n+\t     || value1.equals( value2 ) ) )\n+\treturn false;\n+    }\n+\n+    return true;    \n+  }\n+\n+  public Object get( Object key )\n+  {\n+    Object k;\n+    Map.Entry entry;\n+    Iterator entries = entrySet().iterator();\n+  \n+    while( entries.hasNext() )\n+    {\n+      entry = (Map.Entry)entries.next();\n+      k = entry.getKey();\n+      if( key == null ? k == null : key.equals( k ) )\n+\treturn entry.getValue();\n+    }\n+\n+    return null;\n+  }\n+\n+  public int hashCode()\n+  {\n+    int hashcode = 0;\n+    Iterator entries = entrySet().iterator();\n+  \n+    while( entries.hasNext() )\n+      hashcode += entries.next().hashCode();\n+\n+    return hashcode;\n+  }\n+\n+  public boolean isEmpty()\n+  {\n+    return size() == 0;\n+  }\n+\n+  public Set keySet()\n+  {\n+    if( this.keySet == null )\n+    {\n+      this.keySet =\n+\tnew AbstractSet()\n+\t{\n+\t  public int size()\n+          {\n+\t    return AbstractMap.this.size();\n+\t  }\n+\n+\t  public boolean contains(Object key)\n+\t  {\n+\t    return AbstractMap.this.containsKey(key);\n+\t  }\n+\t  \n+\t  public Iterator iterator()\n+          {\n+\t    return new Iterator()\n+            {\n+\t      Iterator map_iterator = AbstractMap.this.entrySet().iterator();\n+\t      \n+\t      public boolean hasNext()\n+              {\n+\t\treturn map_iterator.hasNext();\n+\t      }\n+\n+\t      public Object next()\n+              {\n+\t\treturn ((Map.Entry)map_iterator.next()).getKey();\n+\t      }\n+\t      \n+\t      public void remove()\n+              {\n+\t\tmap_iterator.remove();\n+\t      }\n+\t    };\n+\t  }\n+\t};\n+    }\n+    \n+    return this.keySet;    \n+  }\n+\n+  public Object put( Object key, Object value )\n+  {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  public void putAll( Map m )\n+  {\n+    Map.Entry entry;\n+    Iterator entries = m.entrySet().iterator();\n+    while( entries.hasNext() )\n+    {\n+      entry = (Map.Entry)entries.next();\n+      put( entry.getKey(), entry.getValue() );\n+    }\n+  }\n+\n+  public Object remove( Object key )\n+  {\n+    Object k, value;\n+    Map.Entry entry;\n+    Iterator entries = entrySet().iterator();\n+  \n+    while( entries.hasNext() )\n+    {\n+      entry = (Map.Entry)entries.next();\n+      k = entry.getKey();\n+      if( key == null ? k == null : key.equals( k ) )\n+      {\n+\tvalue = entry.getValue();\n+\tentries.remove();\n+\treturn value;\n+      }\n+    }\n+\n+    return null;    \n+  }\n+\n+  public int size()\n+  {\n+    return entrySet().size();\n+  }\n+\n+  public String toString()\n+  {\n+    StringBuffer sb = new StringBuffer(\"{\");\n+    String comma = \"\";\n+    Iterator entries = entrySet().iterator();\n+  \n+    while( entries.hasNext() )\n+    {\n+      Map.Entry entry = (Map.Entry)entries.next();\n+      sb.append(comma).append(entry.getKey())\n+\t.append('=').append(entry.getValue());\n+      comma = \", \";\n+    }\n+\n+    return sb.append('}').toString();\n+  }\n+\n+  public Collection values()\n+  {\n+    if( this.valueCollection == null )\n+    {\n+      this.valueCollection =\n+\tnew AbstractCollection()\n+\t{\n+\t  public int size()\n+          {\n+\t    return AbstractMap.this.size();\n+\t  }\n+\t  \n+\t  public Iterator iterator()\n+          {\n+\t    return new Iterator()\n+            {\n+\t      Iterator map_iterator = AbstractMap.this.entrySet().iterator();\n+\t      \n+\t      public boolean hasNext()\n+              {\n+\t\treturn map_iterator.hasNext();\n+\t      }\n+\n+\t      public Object next()\n+              {\n+\t\treturn ((Map.Entry)map_iterator.next()).getValue();\n+\t      }\n+\t      \n+\t      public void remove()\n+              {\n+\t\tmap_iterator.remove();\n+\t      }\n+\t    };\n+\t  }\n+\t};\n+    }\n+    \n+    return this.valueCollection;\n+  }\n+\n+\n+  private Collection valueCollection = null;\n+  private Set keySet = null;\n+}"}, {"sha": "69bdc4ae220ef4b9d434b5902d60c4edd2d5c6a7", "filename": "libjava/java/util/AbstractSequentialList.java", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f09c307172fb7beb8202da1ca8cb44346f4874c/libjava%2Fjava%2Futil%2FAbstractSequentialList.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f09c307172fb7beb8202da1ca8cb44346f4874c/libjava%2Fjava%2Futil%2FAbstractSequentialList.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FAbstractSequentialList.java?ref=6f09c307172fb7beb8202da1ca8cb44346f4874c", "patch": "@@ -0,0 +1,113 @@\n+/* AbstractSequentialList.java -- List implementation for sequential access\n+   Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+// TO DO:\n+// ~ Lots of doc comments still missing.\n+// ~ The class comment should include a description of what should be overridden\n+//   to provide what features, as should the listIterator comment.\n+\n+package java.util;\n+\n+/**\n+ * Abstract superclass to make it easier to implement the List interface when\n+ * backed by a sequential-access store, such as a linked list.\n+ */\n+public abstract class AbstractSequentialList extends AbstractList {\n+\n+  /**\n+   * Returns a ListIterator over the list, starting from position index.\n+   * Subclasses must provide an implementation of this method.\n+   *\n+   * @exception IndexOutOfBoundsException if index < 0 || index > size()\n+   */\n+  public abstract ListIterator listIterator(int index);\n+\n+  /**\n+   * Add an element to the list at a given index. This implementation obtains a\n+   * ListIterator positioned at the specified index, and then adds the element\n+   * using the ListIterator's add method.\n+   *\n+   * @param index the position to add the element\n+   * @param o the element to insert\n+   * @exception IndexOutOfBoundsException if index < 0 || index > size()\n+   * @exception UnsupportedOperationException if the iterator returned by\n+   *   listIterator(index) does not support the add method.\n+   */\n+  public void add(int index, Object o) {\n+    ListIterator i = listIterator(index);\n+    i.add(o);\n+  }\n+\n+  public boolean addAll(int index, Collection c) {\n+    boolean changed = false;\n+    Iterator ci = c.iterator();\n+    ListIterator i = listIterator(index);\n+    while (ci.hasNext()) {\n+      i.add(ci.next());\n+      changed = true;\n+    }\n+    return changed;\n+  }\n+\n+  public Object get(int index) {\n+    ListIterator i = listIterator(index);\n+    if (!i.hasNext()) {\n+      throw new IndexOutOfBoundsException();\n+    }\n+    return i.next();\n+  }\n+\n+  /**\n+   * Return an Iterator over this List. This implementation returns\n+   * listIterator().\n+   *\n+   * @return an Iterator over this List\n+   */\n+  public Iterator iterator() {\n+    return listIterator();\n+  }\n+\n+  public Object remove(int index) {\n+    ListIterator i = listIterator(index);\n+    if (!i.hasNext()) {\n+      throw new IndexOutOfBoundsException();\n+    }\n+    Object removed = i.next();\n+    i.remove();\n+    return removed;\n+  }\n+\n+  public Object set(int index, Object o) {\n+    ListIterator i = listIterator(index);\n+    if (!i.hasNext()) {\n+      throw new IndexOutOfBoundsException();\n+    }\n+    Object old = i.next();\n+    i.set(o);\n+    return old;\n+  }\n+}"}, {"sha": "7e6562cc22e57fa904c414e205633a00018be67d", "filename": "libjava/java/util/ArrayList.java", "status": "added", "additions": 497, "deletions": 0, "changes": 497, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f09c307172fb7beb8202da1ca8cb44346f4874c/libjava%2Fjava%2Futil%2FArrayList.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f09c307172fb7beb8202da1ca8cb44346f4874c/libjava%2Fjava%2Futil%2FArrayList.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FArrayList.java?ref=6f09c307172fb7beb8202da1ca8cb44346f4874c", "patch": "@@ -0,0 +1,497 @@\n+/* ArrayList.java -- JDK1.2's answer to Vector; this is an array-backed\n+   implementation of the List interface\n+   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.util;\n+\n+import java.lang.reflect.Array;\n+import java.io.Serializable;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectStreamField;\n+\n+/**\n+ * An array-backed implementation of the List interface.  ArrayList\n+ * performs well on simple tasks:  random access into a list, appending\n+ * to or removing from the end of a list, checking the size, &c.\n+ *\n+ * @author        Jon A. Zeppieri\n+ * @version       $Id: ArrayList.java,v 1.4 2000/03/15 21:59:06 rao Exp $\n+ * @see           java.util.AbstractList\n+ * @see           java.util.List\n+ */\n+public class ArrayList extends AbstractList \n+  implements List, Cloneable, Serializable\n+{\n+  /** the default capacity for new ArrayLists */\n+  private static final int DEFAULT_CAPACITY = 16;\n+\n+  /** the number of elements in this list */\n+  int _iSize;\n+\n+  /** where the data is stored */\n+  Object[] _arData;\n+\n+  /** used for serialization -- denotes which fields are serialized */\n+  private static final ObjectStreamField[] serialPersistentFields =\n+  {new ObjectStreamField(\"size\", int.class)};\n+\n+  /** \n+   * Construct a new ArrayList with the supplied initial capacity. \n+   *\n+   * @param     iCapacity\n+   */\n+  public ArrayList(int iCapacity)\n+  {\n+    _arData = new Object[iCapacity];\n+  }\n+\n+\n+  /**\n+   * Construct a new ArrayList with the default capcity \n+   */\n+  public ArrayList()\n+  {\n+    this(DEFAULT_CAPACITY);\n+  }\n+\n+  /** \n+   * Construct a new ArrayList, and initialize it with the elements\n+   * in the supplied Collection; Sun specs say that the initial \n+   * capacity is 110% of the Collection's size.\n+   *\n+   * @param        oCollection     the collection whose elements will\n+   *                               initialize this list\n+   */\n+  public ArrayList(Collection oCollection)\n+  {\n+    this((int) (oCollection.size() * 1.1));\n+    addAll(oCollection);\n+  }\n+\n+  /**\n+   * Guarantees that this list will have at least enough capacity to\n+   * hold iMinCapacity elements.\n+   *\n+   * @param      iMinCapacity     the minimum guaranteed capacity\n+   */\n+  public void ensureCapacity(int iMinCapacity)\n+  {\n+    Object[] arNewData;\n+    int iCapacity = _arData.length;\n+\n+    if (iMinCapacity > iCapacity)\n+    {\n+      arNewData = new Object[Math.max((iCapacity * 2), iMinCapacity)];\n+      System.arraycopy(_arData, 0, arNewData, 0, iCapacity);\n+      _arData = arNewData;\n+    }\n+  }\n+\n+  /**\n+   * Appends the supplied element to the end of this list.\n+   *\n+   * @param       oElement      the element to be appended to this list\n+   */\n+  public boolean add(Object oElement)\n+  {\n+    ensureCapacity(_iSize + 1);\n+    _arData[_iSize++] = oElement;\n+    modCount++;\n+    return true;\n+  }\n+\n+  /**\n+   * Retrieves the element at the user-supplied index.\n+   *\n+   * @param    iIndex        the index of the element we are fetching\n+   * @throws   IndexOutOfBoundsException  (iIndex < 0) || (iIndex >= size())\n+   */\n+  public Object get(int iIndex)\n+  {\n+    if (iIndex >= _iSize)\n+      throw new IndexOutOfBoundsException(\"ArrayList size=\" +\n+                                          String.valueOf(_iSize) + \"; \" +\n+                                          \"index=\" + String.valueOf(iIndex));\n+    return _arData[iIndex];\n+  }\n+\n+  /**\n+   * Returns the number of elements in this list \n+   */\n+  public int size()\n+  {\n+    return _iSize;\n+  }\n+\n+  /**\n+   * Removes the element at the user-supplied index\n+   *\n+   * @param     iIndex      the index of the element to be removed\n+   * @return    the removed Object\n+   * @throws    IndexOutOfBoundsException  (iIndex < 0) || (iIndex >= size())\n+   */\n+  public Object remove(int iIndex)\n+  {\n+    Object oResult;\n+\n+    if (iIndex >= _iSize)\n+      throw new IndexOutOfBoundsException(\"ArrayList size=\" +\n+                                          String.valueOf(_iSize) + \"; \" +\n+                                          \"index=\" + String.valueOf(iIndex));\n+\n+    oResult = _arData[iIndex];\n+\n+    if (iIndex != --_iSize)\n+      System.arraycopy(_arData, (iIndex + 1), _arData, iIndex, \n+                       (_iSize - iIndex));\n+  \n+    modCount++;\n+    _arData[_iSize] = null;\n+\n+    return oResult;\n+  }\n+\n+  /**\n+   * Removes all elements in the half-open interval [iFromIndex, iToIndex).\n+   *\n+   * @param     iFromIndex   the first index which will be removed\n+   * @param     iToIndex     one greater than the last index which will be \n+   *                         removed\n+   */\n+  public void removeRange(int iFromIndex, int iToIndex)\n+  {\n+    int iReduction;\n+    int i;\n+\n+    if ((iFromIndex >= _iSize) || (iToIndex >= _iSize))\n+    {\n+      throw new IndexOutOfBoundsException(\"ArrayList size=\" +\n+                                          String.valueOf(_iSize) + \"; \" +\n+                                          \"indices=\" + \n+                                          String.valueOf(iFromIndex) + \",\" +\n+                                          String.valueOf(iToIndex));\n+    }\n+    else if (iFromIndex > iToIndex)\n+    {\n+      throw new IllegalArgumentException(\"fromIndex(\" + \n+                                         String.valueOf(iFromIndex) + \n+                                         \") > toIndex(\" +\n+                                         String.valueOf(iToIndex) + \")\");\n+    }\n+    else if (iFromIndex != iToIndex)\n+    {\n+      iReduction = iToIndex - iFromIndex;\n+      System.arraycopy(_arData, (iFromIndex + iReduction), _arData,\n+                       iFromIndex, (_iSize - iFromIndex - iReduction));\n+      modCount++;\n+\n+      for (i = (iFromIndex + iReduction); i < _iSize; i++)\n+        _arData[i] = null;\n+\n+      _iSize -= iReduction;\n+    }\n+  }\n+\n+  /**\n+   * Adds the supplied element at the specified index, shifting all\n+   * elements currently at that index or higher one to the right.\n+   *\n+   * @param     iIndex      the index at which the element is being added\n+   * @param     oElement    the element being added\n+   */\n+  public void add(int iIndex, Object oElement)\n+  {\n+    if (iIndex > _iSize)\n+      throw new IndexOutOfBoundsException(\"ArrayList size=\" +\n+                                          String.valueOf(_iSize) + \"; \" +\n+                                          \"index=\" + String.valueOf(iIndex));\n+\n+    ensureCapacity(_iSize + 1);\n+    System.arraycopy(_arData, iIndex, _arData, \n+                      (iIndex + 1), (_iSize - iIndex));\n+    _arData[iIndex] = oElement;\n+    _iSize++;\n+    modCount++;\n+  }\n+\n+  /** \n+   * Add each element in the supplied Collection to this List.\n+   *\n+   * @param        oCollection     a Collection containing elements to be \n+   *                               added to this List\n+   */\n+  public boolean addAll(Collection oCollection)\n+  {\n+    Iterator itElements;\n+    int iLen = oCollection.size();\n+\n+    if (iLen > 0)\n+    {\n+      ensureCapacity(_iSize + iLen);\n+      modCount++;\n+\n+      itElements = oCollection.iterator();\n+\n+      while (itElements.hasNext())\n+        _arData[_iSize++] = itElements.next();\n+\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  /** \n+   * Add all elements in the supplied collection, inserting them beginning\n+   * at the specified index.\n+   *\n+   * @param     iIndex       the index at which the elements will be inserted\n+   * @param     oCollection  the Collection containing the elements to be\n+   *                         inserted\n+   */\n+  public boolean addAll(int iIndex, Collection oCollection)\n+  {\n+    Iterator itElements;\n+    int iLen;\n+\n+    if (iIndex > _iSize)\n+      throw new IndexOutOfBoundsException(\"ArrayList size=\" +\n+                                          String.valueOf(_iSize) + \"; \" +\n+                                          \"index=\" + String.valueOf(iIndex));\n+\n+    iLen = oCollection.size();\n+\n+    if (iLen > 0)\n+    {\n+      ensureCapacity(_iSize + iLen);\n+\n+      System.arraycopy(_arData, iIndex, _arData, \n+                       (iIndex + iLen), (_iSize - iIndex));\n+      modCount++;\n+      _iSize += iLen;\n+\n+      itElements = oCollection.iterator();\n+      while (itElements.hasNext())\n+        _arData[iIndex++] = itElements.next();\n+\n+      return true;\n+   }\n+    return false;\n+  }\n+\n+  /**\n+   * Creates a shallow copy of this ArrayList\n+   */\n+  public Object clone()\n+  {\n+    ArrayList oClone;\n+\n+    try\n+    {\n+      oClone = (ArrayList) super.clone();\n+      oClone._arData = _arData;\n+      oClone._iSize = _iSize;\n+    }\n+    catch(CloneNotSupportedException e)\n+    {\n+      oClone = null;\n+    }\n+    return oClone;\n+  }\n+\n+  /** \n+   * Returns true iff oElement is in this ArrayList.\n+   *\n+   * @param     oElement     the element whose inclusion in the List is being\n+   *                         tested\n+   */\n+  public boolean contains(Object oElement)\n+  {\n+    return (indexOf(oElement) != -1);\n+  }\n+\n+  /**\n+   * Returns the lowest index at which oElement appears in this List, or \n+   * -1 if it does not appear.\n+   *\n+   * @param    oElement       the element whose inclusion in the List is being\n+   *                          tested\n+   */\n+  public int indexOf(Object oElement)\n+  {\n+    int i;\n+\n+    for (i = 0; i < _iSize; i++)\n+    {\n+      if (doesEqual(oElement, _arData[i]))\n+        return i;\n+    }\n+    return -1;\n+  }\n+\n+  /**\n+   * Returns the highest index at which oElement appears in this List, or \n+   * -1 if it does not appear.\n+   *\n+   * @param    oElement       the element whose inclusion in the List is being\n+   *                          tested\n+   */\n+  public int lastIndexOf(Object oElement)\n+  {\n+    int i;\n+\n+    for (i = _iSize - 1; i >= 0; i--)\n+    {\n+      if (doesEqual(oElement, _arData[i]))\n+        return i;\n+    }\n+    return -1;\n+  }\n+\n+  /**\n+   * Removes all elements from this List\n+   */\n+  public void clear()\n+  {\n+    int i;\n+\n+    if (_iSize > 0)\n+    {\n+      modCount++;\n+      _iSize = 0;\n+\n+      for (i = 0; i < _iSize; i++)\n+        _arData[i] = null;\n+    }      \n+  }\n+\n+  /**\n+   * Sets the element at the specified index.\n+   *\n+   * @param     iIndex     the index at which the element is being set\n+   * @param     oElement   the element to be set\n+   * @return    the element previously at the specified index, or null if\n+   *            none was there\n+   */\n+  public Object set(int iIndex, Object oElement)\n+  {\n+    Object oResult;\n+\n+    if (iIndex >= _iSize)\n+      throw new IndexOutOfBoundsException(\"ArrayList size=\" +\n+                                          String.valueOf(_iSize) + \"; \" +\n+                                          \"index=\" + String.valueOf(iIndex));\n+    oResult = _arData[iIndex];\n+    // SEH: no structural change, so don't update modCount\n+    _arData[iIndex] = oElement;\n+\n+    return oResult;\n+  }\n+\n+  /**\n+   * Returns an Object Array containing all of the elements in this ArrayList\n+   */\n+  public Object[] toArray()\n+  {\n+    Object[] arObjects = new Object[_iSize];\n+    System.arraycopy(_arData, 0, arObjects, 0, _iSize);\n+    return arObjects;\n+  }\n+\n+  /**\n+   * Returns an Array whse component type is the runtime component type of\n+   * the passes-in Array.  The returned Array is populated with all of the\n+   * elements in this ArrayList.  If the passed-in Array is not large enough\n+   * to store all of the elements in this List, a new Array will be created \n+   * and returned; if the passed-in Array is <i>larger</i> than the size\n+   * of this List, then size() + 1 index will be set to null.\n+   *\n+   * @param      arObjects      the passed-in Array\n+   */\n+  public Object[] toArray(Object[] arObjects)\n+  {\n+    Object[] arReturn = (arObjects.length >= _iSize)\n+      ? arObjects \n+      : (Object[])\n+      Array.newInstance(arObjects.getClass().getComponentType(), _iSize);\n+\n+    System.arraycopy(_arData, 0, arReturn, 0, _iSize);\n+\n+    if (arReturn.length > _iSize)\n+      arReturn[_iSize] = null;\n+\n+    return arReturn;\n+  }\n+\n+  /**\n+   * Trims the capacity of tjis List to be equal to its size; \n+   * a memory saver. \n+   */\n+  public void trimToSize()\n+  {\n+    Object[] arNewData = new Object[_iSize];\n+    System.arraycopy(_arData, 0, arNewData, 0, _iSize);\n+    modCount++;\n+    _arData = arNewData;\n+  }\n+\n+  private void writeObject(ObjectOutputStream oOut)\n+    throws IOException\n+  {\n+    int i;\n+\n+    ObjectOutputStream.PutField oFields = oOut.putFields();\n+    oFields.put(\"size\", _iSize);\n+    oOut.writeFields();\n+\n+    oOut.writeInt(_arData.length);\n+    for (i = 0; i < _arData.length; i++)\n+      oOut.writeObject(_arData[i]);\n+  }\n+\n+  private void readObject(ObjectInputStream oIn)\n+    throws IOException, ClassNotFoundException\n+  {\n+    int i;\n+    int iCapacity;\n+\n+    ObjectInputStream.GetField oFields = oIn.readFields();\n+    _iSize = oFields.get(\"size\", 0);\n+\n+    iCapacity = oIn.readInt();\n+    _arData = new Object[iCapacity];\n+\n+    for (i = 0; i < iCapacity; i++)\n+      _arData[i] = oIn.readObject();\n+  }\n+\n+  private static final boolean doesEqual(Object oOne, Object oTwo)\n+  {\n+    return ((oOne == null) ? (oTwo == null) : oOne.equals(oTwo));\n+  }\n+}"}, {"sha": "5d506602aa74ed2ce20c947204162f86ee56c561", "filename": "libjava/java/util/HashMap.java", "status": "added", "additions": 858, "deletions": 0, "changes": 858, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f09c307172fb7beb8202da1ca8cb44346f4874c/libjava%2Fjava%2Futil%2FHashMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f09c307172fb7beb8202da1ca8cb44346f4874c/libjava%2Fjava%2Futil%2FHashMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FHashMap.java?ref=6f09c307172fb7beb8202da1ca8cb44346f4874c", "patch": "@@ -0,0 +1,858 @@\n+/* HashMap.java -- a class providing a basic hashtable data structure,\n+   mapping Object --> Object\n+   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.util;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectStreamField;\n+\n+/**\n+ * This class provides a hashtable-backed implementation of the\n+ * Map interface.  \n+ *\n+ * It uses a hash-bucket approach; that is, hash\n+ * collisions are handled by linking the new node off of the\n+ * pre-existing node (or list of nodes).  In this manner, techniques \n+ * such as linear probing (which can casue primary clustering) and \n+ * rehashing (which does not fit very well with Java's method of \n+ * precomputing hash codes) are avoided.  \n+ *\n+ * Under ideal circumstances (no collisions, HashMap offers O(1) \n+ * performance on most operations (<pre>containsValue()</pre> is,\n+ * of course, O(n)).  In the worst case (all keys map to the same \n+ * hash code -- very unlikely), most operations are O(n).\n+ *\n+ * HashMap is part of the JDK1.2 Collections API.  It differs from \n+ * Hashtable in that it accepts the null key and null values, and it\n+ * does not support \"Enumeration views.\"\n+ *\n+ * @author         Jon Zeppieri\n+ * @version        $Revision: 1.6 $\n+ * @modified       $Id: HashMap.java,v 1.6 2000/03/15 21:59:13 rao Exp $\n+ */\n+public class HashMap extends AbstractMap \n+    implements Map, Cloneable, Serializable\n+{\n+    // STATIC (CLASS) VARIABLES ------------------------------------------\n+\n+    /** \n+     * the default capacity for an instance of HashMap -- I think this\n+     * is low, and perhaps it shoudl be raised; Sun's documentation mildly\n+     * suggests that this (11) is the correct value, though\n+     */\n+    private static final int DEFAULT_CAPACITY = 11;\n+\n+    /** the default load factor of a HashMap */\n+    private static final float DEFAULT_LOAD_FACTOR = 0.75F;\n+\n+    /** used internally to represent the null key */\n+    private static final HashMap.Null NULL_KEY = new HashMap.Null();\n+\n+    /** used internally to parameterize the creation of set/collection views */\n+    private static final int KEYS = 0;\n+\n+    /** used internally to parameterize the creation of set/collection views */\n+    private static final int VALUES = 1;\n+\n+    /** used internally to parameterize the creation of set/collection views */\n+    private static final int ENTRIES = 2;\n+\n+    private static final long serialVersionUID = 362498820763181265L;\n+\n+    // INSTANCE VARIABLES -------------------------------------------------\n+\n+    /** the capacity of this HashMap:  denotes the size of the bucket array */\n+    transient int capacity;\n+\n+    /** the size of this HashMap:  denotes the number of key-value pairs */\n+    private transient int size;\n+\n+    /** the load factor of this HashMap:  used in computing the threshold \n+     * @serial\n+     */\n+    float loadFactor;\n+\n+    /* the rounded product of the capacity and the load factor; when the number of\n+     * elements exceeds the threshold, the HashMap calls <pre>rehash()</pre>\n+     * @serial\n+     */\n+    private int threshold;\n+\n+    /** \n+     * this data structure contains the actual key-value mappings; a\n+     * <pre>BucketList</pre> is a lightweight linked list of \"Buckets\",\n+     * which, in turn, are linked nodes containing a key-value mapping \n+     * and a reference to the \"next\" Bucket in the list\n+     */\n+    private transient Bucket[] buckets;\n+\n+    /** \n+     * counts the number of modifications this HashMap has undergone; used by Iterators\n+     * to know when to throw ConcurrentModificationExceptions (idea ripped-off from\n+     * Stuart Ballard's AbstractList implementation) \n+     */\n+    private transient int modCount;\n+\n+\n+    // CONSTRUCTORS ---------------------------------------------------------\n+    \n+    /**\n+     * construct a new HashMap with the default capacity and the default\n+     * load factor\n+     */\n+    public HashMap()\n+    {\n+\tinit(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR);\n+    }\n+\n+    /**\n+     * construct a new HashMap with a specific inital capacity and load factor\n+     *\n+     * @param   initialCapacity     the initial capacity of this HashMap (>=0)\n+     * @param   initialLoadFactor   the load factor of this HashMap \n+     *                              (a misnomer, really, since the load factor of\n+     *                              a HashMap does not change)\n+     * \n+     * @throws   IllegalArgumentException    if (initialCapacity < 0) ||\n+     *                                          (initialLoadFactor > 1.0) ||\n+     *                                          (initialLoadFactor <= 0.0)\n+     */\n+    public HashMap(int initialCapacity, float initialLoadFactor)\n+\tthrows IllegalArgumentException\n+    {\n+\tif (initialCapacity < 0 || initialLoadFactor <= 0 || initialLoadFactor > 1)\n+\t    throw new IllegalArgumentException();\n+\telse\n+\t    init(initialCapacity, initialLoadFactor);\n+    }\n+\n+    /**\n+     * construct a new HashMap with a specific inital capacity \n+     *\n+     * @param   initialCapacity     the initial capacity of this HashMap (>=0)\n+     *\n+     * @throws   IllegalArgumentException    if (initialCapacity < 0)\n+     */\n+    public HashMap(int initialCapacity)\t\n+\tthrows IllegalArgumentException \n+    {\n+\tif (initialCapacity < 0)\n+\t    throw new IllegalArgumentException();\n+\telse\n+\t    init(initialCapacity, DEFAULT_LOAD_FACTOR);\n+    }\n+\n+    /**\n+     * construct a new HashMap from the given Map\n+     * \n+     * every element in Map t will be put into this new HashMap\n+     *\n+     * @param     t        a Map whose key / value pairs will be put into\n+     *                     the new HashMap.  <b>NOTE: key / value pairs\n+     *                     are not cloned in this constructor</b>\n+     */\n+    public HashMap(Map t)\n+    {\n+\tint mapSize = t.size() * 2;\n+\tinit(((mapSize > DEFAULT_CAPACITY) ? mapSize : DEFAULT_CAPACITY), DEFAULT_LOAD_FACTOR);\n+\tputAll(t);\n+    }\n+\n+\n+    // PUBLIC METHODS ---------------------------------------------------------\n+\n+    /** returns the number of kay-value mappings currently in this Map */\n+    public int size()\n+    {\n+\treturn size;\n+    }\n+\n+    /** returns true if there are no key-value mappings currently in this Map */\n+    public boolean isEmpty()\n+    {\n+\treturn size == 0;\n+    }\n+\n+    /** empties this HashMap of all elements */\n+    public void clear()\n+    {\n+\tsize = 0;\n+\tmodCount++;\n+\tbuckets = new Bucket[capacity];\n+    }\n+\n+    /** \n+     * returns a shallow clone of this HashMap (i.e. the Map itself is cloned, but\n+     * its contents are not)\n+     */\n+    public Object clone()\n+    {\n+\tMap.Entry entry;\n+\tIterator it = entrySet().iterator();\n+\tHashMap clone = new HashMap(capacity, loadFactor);\n+\twhile (it.hasNext())\n+\t    {\n+\t\tentry = (Map.Entry) it.next();\n+\t\tclone.internalPut(entry.getKey(), entry.getValue());\n+\t    }\n+\treturn clone;\n+    }\n+\n+    /** returns a \"set view\" of this HashMap's keys */\n+    public Set keySet()\n+    {\n+\treturn new HashMapSet(KEYS);\n+    }\n+\n+    /** returns a \"set view\" of this HashMap's entries */\n+    public Set entrySet()\n+    {\n+\treturn new HashMapSet(ENTRIES);\n+    }\n+\n+    /** returns a \"collection view\" (or \"bag view\") of this HashMap's values */\n+    public Collection values()\n+    {\n+\treturn new HashMapCollection();\n+    }\n+\n+    /** \n+     * returns true if the supplied object equals (<pre>equals()</pre>) a key\n+     * in this HashMap \n+     *\n+     * @param       key        the key to search for in this HashMap\n+     */\n+    public boolean containsKey(Object key)\n+    {\n+\treturn (internalGet(key) != null);\n+    }\n+    \n+    /**\n+     * returns true if this HashMap contains a value <pre>o</pre>, such that\n+     * <pre>o.equals(value)</pre>.\n+     *\n+     * @param      value       the value to search for in this Hashtable\n+     */\n+    public boolean containsValue(Object value)\n+    {\n+\tint i;\n+\tBucket list;\n+\n+\tfor (i = 0; i < capacity; i++)\n+\t    {\n+\t\tlist = buckets[i];\n+\t\tif (list != null && list.containsValue(value))\n+\t\t    return true;\n+\t    }\n+\treturn false;\n+    }\n+    \n+    /*\n+     * return the value in this Hashtable associated with the supplied key, or <pre>null</pre>\n+     * if the key maps to nothing\n+     *\n+     * @param     key      the key for which to fetch an associated value\n+     */\n+    public Object get(Object key)\n+    {\n+\tMap.Entry oResult = internalGet(key);\n+\treturn (oResult == null) ? null : oResult.getValue();\n+    }\n+\n+    /**\n+     * puts the supplied value into the Map, mapped by the supplied key\n+     *\n+     * @param       key        the HashMap key used to locate the value\n+     * @param       value      the value to be stored in the HashMap\n+     */\n+    public Object put(Object key, Object value)\n+    {\n+\treturn internalPut(key, value);\n+    }\n+\n+    /**\n+     * removes from the HashMap and returns the value which is mapped by the \n+     * supplied key; if the key maps to nothing, then the HashMap remains unchanged,\n+     * and <pre>null</pre> is returned\n+     *\n+     * @param    key     the key used to locate the value to remove from the HashMap\n+     */\n+    public Object remove(Object key)\n+    {\n+\tBucket list;\n+\tint index;\n+\tObject result = null;\n+\tif (size > 0)\n+\t    {\n+\t\tindex = hash(((key == null) ? NULL_KEY : key));\n+\t\tlist = buckets[index];\n+\t\tif (list != null)\n+\t\t    {\n+\t\t\tresult = list.removeByKey(key);\n+\t\t\tif (result != null)\n+\t\t\t    {\n+\t\t\t\tsize--;\n+\t\t\t\tmodCount++;\n+\t\t\t\tif (list.first == null)\n+\t\t\t\t    buckets[index] = null;\n+\t\t\t    }\n+\t\t    }\n+\t    }\n+\treturn result;\n+    }\n+\n+\n+    // PRIVATE METHODS -----------------------------------------------------------\n+\n+    /** \n+     * puts the given key-value pair into this HashMap; a private method is used\n+     * because it is called by the rehash() method as well as the put() method,\n+     * and if a subclass overrides put(), then rehash would do funky things\n+     * if it called put()\n+     *\n+     * @param       key        the HashMap key used to locate the value\n+     * @param       value      the value to be stored in the HashMap\n+     */\n+  private Object internalPut(Object key, Object value)\n+    {\n+\tHashMapEntry entry;\n+\tBucket list;\n+\tint hashIndex;\n+\tObject oResult;\n+\tObject oRealKey = ((key == null) ? NULL_KEY : key);\n+\n+\tentry = new HashMapEntry(oRealKey, value);\n+\thashIndex = hash(oRealKey);\n+\tlist = buckets[hashIndex];\n+\tif (list == null)\n+\t  {\n+\t    list = new Bucket();\n+\t    buckets[hashIndex] = list;\n+\t  }\n+\toResult = list.add(entry);\n+\tif (oResult == null)\n+\t    {\n+\t        modCount++;\n+\t\tif (size++ == threshold)\n+\t\t    rehash();\n+\t\treturn null;\n+\t    }\n+\telse\n+\t    {\n+\t\t// SEH: if key already exists, we don't rehash & we don't update the modCount\n+\t\t// because it is not a \"structural\" modification\n+\t\treturn oResult;\n+\t    }\n+    }\n+\n+    /** \n+     * a private method, called by all of the constructors to initialize a new HashMap\n+     *\n+     * @param   initialCapacity     the initial capacity of this HashMap (>=0)\n+     * @param   initialLoadFactor   the load factor of this HashMap \n+     *                              (a misnomer, really, since the load factor of\n+     *                              a HashMap does not change)\n+     */ \n+    private void init(int initialCapacity, float initialLoadFactor)\n+    {\n+\tsize = 0;\n+\tmodCount = 0;\n+\tcapacity = initialCapacity;\n+\tloadFactor = initialLoadFactor;\n+\tthreshold = (int) ((float) capacity * loadFactor);\n+\tbuckets = new Bucket[capacity];\n+    }\n+\n+    /** private -- simply hashes a non-null Object to its array index */\n+    private int hash(Object key)\n+    {\n+\treturn Math.abs(key.hashCode() % capacity);\n+    }\n+\n+    /** \n+     * increases the size of the HashMap and rehashes all keys to new array indices;\n+     * this is called when the addition of a new value would cause size() > threshold\n+     */\n+    private void rehash()\n+    {\n+\tint i;\n+\tBucket[] data = buckets;\n+\tBucket.Node node;\n+\n+\tmodCount++;\n+\tcapacity = (capacity * 2) + 1;\n+\tsize = 0;\n+\tthreshold = (int) ((float) capacity * loadFactor);\n+\tbuckets = new Bucket[capacity];\n+\tfor (i = 0; i < data.length; i++)\n+\t    {\n+\t\tif (data[i] != null)\n+\t\t    {\n+\t\t\tnode = data[i].first;\n+\t\t\twhile (node != null)\n+\t\t\t    {\n+\t\t\t\tinternalPut(node.getKey(), node.getValue());\n+\t\t\t\tnode = node.next;\n+\t\t\t    }\n+\t\t    }\n+\t    }\n+    }\n+\n+    /** \n+     * a private method which does the \"dirty work\" (or some of it anyway) of fetching a value\n+     * with a key\n+     *\n+     *  @param     key      the key for which to fetch an associated value\n+     */    \n+    private Map.Entry internalGet(Object key)\n+    {\n+\tBucket list;\n+\tif (size == 0)\n+\t    {\n+\t\treturn null;\n+\t    }\n+\telse\n+\t    {\n+\t\tlist = buckets[hash(((key == null) ? NULL_KEY : key))];\n+\t\treturn (list == null) ? null : list.getEntryByKey(key);\n+\t    }\n+    }\n+\n+    /**\n+     * a private method used by inner class HashMapSet to implement its own \n+     * <pre>contains(Map.Entry)</pre> method; returns true if the supplied\n+     * key / value pair is found in this HashMap (again, using <pre>equals()</pre>,\n+     * rather than <pre>==</pre>)\n+     *\n+     * @param      entry      a Map.Entry to match against key / value pairs in \n+     *                        this HashMap\n+     */\n+    private boolean containsEntry(Map.Entry entry)\n+    {\n+\tMap.Entry oInternalEntry;\n+\tif (entry == null)\n+\t    {\n+\t\treturn false;\n+\t    }\n+\telse\n+\t    {\n+\t\toInternalEntry = internalGet(entry.getKey());\n+\t\treturn (oInternalEntry != null && oInternalEntry.equals(entry));\n+\t    }\n+    }\n+\n+    /**\n+     * Serializes this object to the given stream.\n+     * @serialdata the <i>capacity</i>(int) that is the length of the\n+     * bucket array, the <i>size</i>(int) of the hash map are emitted\n+     * first.  They are followed by size entries, each consisting of\n+     * a key (Object) and a value (Object).\n+     */\n+    private void writeObject(ObjectOutputStream s) \n+      throws IOException\n+    {\n+        // the fields\n+        s.defaultWriteObject();\n+\n+\ts.writeInt(capacity);\n+\ts.writeInt(size);\n+\tIterator it = entrySet().iterator();\n+\twhile (it.hasNext())\n+\t    {\n+\t\tMap.Entry oEntry = (Map.Entry) it.next();\n+\t\ts.writeObject(oEntry.getKey());\n+\t\ts.writeObject(oEntry.getValue());\n+\t    }\n+    }\n+\n+    /**\n+     * Deserializes this object from the given stream.\n+     * @serialdata the <i>capacity</i>(int) that is the length of the\n+     * bucket array, the <i>size</i>(int) of the hash map are emitted\n+     * first.  They are followed by size entries, each consisting of\n+     * a key (Object) and a value (Object).\n+     */\n+    private void readObject(ObjectInputStream s)\n+      throws IOException, ClassNotFoundException\n+    {\n+      // the fields\n+      s.defaultReadObject();\n+\n+      capacity = s.readInt();\n+      int iLen = s.readInt();\n+      size = 0;\n+      modCount = 0;\n+      buckets = new Bucket[capacity];\n+\n+      for (int i = 0; i < iLen; i++)\n+\t{\n+\t  Object oKey = s.readObject();\n+\t  Object oValue = s.readObject();\n+\t  internalPut(oKey, oValue);\n+\t}\n+    }\n+\n+    // INNER CLASSES -------------------------------------------------------------\n+    // ---------------------------------------------------------------------------\n+    \n+    /**\n+     * an inner class providing a Set view of a HashMap; this implementation is \n+     * parameterized to view either a Set of keys or a Set of Map.Entry objects\n+     *\n+     * Note:  a lot of these methods are implemented by AbstractSet, and would work \n+     * just fine without any meddling, but far greater efficiency can be gained by\n+     * overriding a number of them.  And so I did.\n+     *\n+     * @author      Jon Zeppieri\n+     * @version     $Revision: 1.6 $\n+     * @modified    $Id: HashMap.java,v 1.6 2000/03/15 21:59:13 rao Exp $\n+     */\n+    private class HashMapSet extends AbstractSet\n+\timplements Set\n+    {\n+\t/** the type of this Set view:  KEYS or ENTRIES */\n+\tprivate int setType;\n+\n+\t/** construct a new HashtableSet with the supplied view type */\n+\tHashMapSet(int type)\n+\t{\n+\t    setType = type;\n+\t}\n+\n+\t/**\n+\t * adding an element is unsupported; this method simply throws an exception \n+\t *\n+\t * @throws       UnsupportedOperationException\n+\t */\n+\tpublic boolean add(Object o) throws UnsupportedOperationException\n+\t{\n+\t    throw new UnsupportedOperationException();\n+\t}\n+\n+\t/**\n+\t * adding an element is unsupported; this method simply throws an exception \n+\t *\n+\t * @throws       UnsupportedOperationException\n+\t */\n+\tpublic boolean addAll(Collection c) throws UnsupportedOperationException\n+\t{\n+\t    throw new UnsupportedOperationException();\n+\t}\n+\n+\t/**\n+\t * clears the backing HashMap; this is a prime example of an overridden implementation\n+\t * which is far more efficient than its superclass implementation (which uses an iterator\n+\t * and is O(n) -- this is an O(1) call)\n+\t */\n+\tpublic void clear()\n+\t{\n+\t    HashMap.this.clear();\n+\t}\n+\n+\t/**\n+\t * returns true if the supplied object is contained by this Set\n+\t *\n+\t * @param     o       an Object being testing to see if it is in this Set\n+\t */\n+\tpublic boolean contains(Object o)\n+\t{\n+\t    if (setType == KEYS)\n+\t\treturn HashMap.this.containsKey(o);\n+\t    else\n+\t\treturn (o instanceof Map.Entry) ? HashMap.this.containsEntry((Map.Entry) o) : false;\n+\t}\n+\n+\t/** \n+\t * returns true if the backing HashMap is empty (which is the only case either a KEYS\n+\t * Set or an ENTRIES Set would be empty)\n+\t */\n+\tpublic boolean isEmpty()\n+\t{\n+\t    return HashMap.this.isEmpty();\n+\t}\n+\n+\t/**\n+\t * removes the supplied Object from the Set\n+\t *\n+\t * @param      o       the Object to be removed\n+\t */\n+\tpublic boolean remove(Object o)\n+\t{\n+\t    if (setType == KEYS)\n+\t\treturn (HashMap.this.remove(o) != null);\n+\t    else\n+\t\treturn (o instanceof Map.Entry) ? \n+\t\t    (HashMap.this.remove(((Map.Entry) o).getKey()) != null) : false;\n+\t}\n+\n+\t/** returns the size of this Set (always equal to the size of the backing Hashtable) */\n+\tpublic int size()\n+\t{\n+\t    return HashMap.this.size();\n+\t}\n+\n+\t/** returns an Iterator over the elements of this Set */\n+\tpublic Iterator iterator()\n+\t{\n+\t    return new HashMapIterator(setType);\n+\t}\n+    }\n+    \n+    /**\n+     * Like the above Set view, except this one if for values, which are not\n+     * guaranteed to be unique in a Map; this prvides a Bag of values\n+     * in the HashMap\n+     *\n+     * @author       Jon Zeppieri\n+     * @version      $Revision: 1.6 $\n+     * @modified     $Id: HashMap.java,v 1.6 2000/03/15 21:59:13 rao Exp $\n+     */\n+    private class HashMapCollection extends AbstractCollection\n+\timplements Collection\n+    {\n+\t/** a trivial contructor for HashMapCollection */\n+\tHashMapCollection()\n+\t{\n+\t}\n+\n+\t/** \n+\t * adding elements is not supported by this Collection;\n+\t * this method merely throws an exception\n+\t *\n+\t * @throws     UnsupportedOperationException\n+\t */\n+\tpublic boolean add(Object o) throws UnsupportedOperationException\n+\t{\n+\t    throw new UnsupportedOperationException();\n+\t}\n+\n+\t/** \n+\t * adding elements is not supported by this Collection;\n+\t * this method merely throws an exception\n+\t *\n+\t * @throws     UnsupportedOperationException\n+\t */\n+\tpublic boolean addAll(Collection c) throws UnsupportedOperationException\n+\t{\n+\t    throw new UnsupportedOperationException();\n+\t}\n+\n+\t/** removes all elements from this Collection (and from the backing HashMap) */\n+\tpublic void clear()\n+\t{\n+\t    HashMap.this.clear();\n+\t}\n+\n+\t/** \n+\t * returns true if this Collection contains at least one Object which equals() the\n+\t * supplied Object\n+\t *\n+\t * @param         o        the Object to compare against those in the Set\n+\t */\n+\tpublic boolean contains(Object o)\n+\t{\n+\t    return HashMap.this.containsValue(o);\n+\t}\n+\n+\t/** returns true IFF the Collection has no elements */\n+\tpublic boolean isEmpty()\n+\t{\n+\t    return HashMap.this.isEmpty();\n+\t}\n+\n+\t/** returns the size of this Collection */\n+\tpublic int size()\n+\t{\n+\t    return HashMap.this.size();\n+\t}\n+\n+\t/** returns an Iterator over the elements in this Collection */\n+\tpublic Iterator iterator()\n+\t{\n+\t    return new HashMapIterator(VALUES);\n+\t}\n+    }\n+\n+    /**\n+     * a class which implements the Iterator interface and is used for\n+     * iterating over HashMaps;\n+     * this implementation is parameterized to give a sequential view of\n+     * keys, values, or entries; it also allows the removal of elements, \n+     * as per the Javasoft spec.\n+     *\n+     * @author       Jon Zeppieri\n+     * @version      $Revision: 1.6 $\n+     * @modified     $Id: HashMap.java,v 1.6 2000/03/15 21:59:13 rao Exp $\n+     */\n+    class HashMapIterator implements Iterator\n+    {\n+\t/** the type of this Iterator: KEYS, VALUES, or ENTRIES */\n+\tprivate int myType;\n+\t/** \n+\t * the number of modifications to the backing Hashtable for which\n+\t * this Iterator can account (idea ripped off from Stuart Ballard)\n+\t */\n+\tprivate int knownMods;\n+\t/** the location of our sequential \"cursor\" */\n+\tprivate int position;\n+\t/** the current index of the BucketList array */\n+\tprivate int bucketIndex;\n+\t/** a reference, originally null, to the specific Bucket our \"cursor\" is pointing to */\n+\tprivate Bucket.Node currentNode;\n+\t/** a reference to the current key -- used fro removing elements via the Iterator */\n+\tprivate Object currentKey;\n+\n+\t/** construct a new HashtableIterator with the supllied type: KEYS, VALUES, or ENTRIES */\n+\tHashMapIterator(int type)\n+\t{\n+\t    myType = type;\n+\t    knownMods = HashMap.this.modCount;\n+\t    position = 0;\n+\t    bucketIndex = -1;\n+\t    currentNode = null;\n+\t    currentKey = null;\n+\t}\n+\n+\t/** \n+\t * Stuart Ballard's code:  if the backing HashMap has been altered through anything \n+\t * but <i>this</i> Iterator's <pre>remove()</pre> method, we will give up right here,\n+\t * rather than risking undefined behavior\n+\t *\n+\t * @throws    ConcurrentModificationException\n+\t */\n+\tprivate void checkMod() \n+\t{\n+\t    if (knownMods != HashMap.this.modCount)\n+\t\tthrow new ConcurrentModificationException();\n+\t}\n+\n+\t/** returns true if the Iterator has more elements */\n+\tpublic boolean hasNext()\n+\t{\n+\t    checkMod();\n+\t    return position < HashMap.this.size();\n+\t}\n+\n+\t/** returns the next element in the Iterator's sequential view */\n+\tpublic Object next()\n+\t{\n+\t    Bucket list = null;\n+\t    Object result;\n+\t    checkMod();\t    \n+\t    try\n+\t\t{\n+\t\t    while (currentNode == null)\n+\t\t\t{\n+\t\t\t    while (list == null)\n+\t\t\t\tlist = HashMap.this.buckets[++bucketIndex];\n+\t\t\t    currentNode = list.first;\n+\t\t\t}\n+\t\t    currentKey = currentNode.getKey();\n+\t\t    result = (myType == KEYS) ? currentKey : \n+\t\t\t((myType == VALUES) ? currentNode.getValue() : currentNode);\n+\t\t    currentNode = currentNode.next;\n+\t\t}\n+\t    catch(Exception e)\n+\t\t{\n+\t\t    throw new NoSuchElementException();\n+\t\t}\n+\t    position++;\n+\t    return result;\n+\t}\n+\n+\t/** \n+\t * removes from the backing HashMap the last element which was fetched with the\n+\t * <pre>next()</pre> method\n+\t */\n+\tpublic void remove()\n+\t{\n+\t    checkMod();\n+\t    if (currentKey == null)\n+\t\t{\n+\t\t    throw new IllegalStateException();\n+\t\t}\n+\t    else\n+\t\t{\n+\t\t    HashMap.this.remove(currentKey);\n+\t\t    knownMods++;\n+\t\t    position--;\n+\t\t    currentKey = null;\n+\t\t}\n+\t}\n+    }\n+\n+    /**\n+     * a singleton instance of this class (HashMap.NULL_KEY)\n+     * is used to represent the null key in HashMap objects\n+     *\n+     * @author     Jon Zeppieri\n+     * @version    $Revision: 1.6 $\n+     * @modified   $Id: HashMap.java,v 1.6 2000/03/15 21:59:13 rao Exp $\n+     */\n+    private static class Null\n+    {\n+\t/** trivial constructor */\n+\tNull()\n+\t{\n+\t}\n+    }\n+\n+    /**\n+     * a HashMap version of Map.Entry -- one thing in this implementation is\n+     * HashMap-specific:  if the key is HashMap.NULL_KEY, getKey() will return\n+     * null\n+     *\n+     * Simply, a key / value pair\n+     *\n+     * @author      Jon Zeppieri\n+     * @version     $Revision: 1.6 $\n+     * @modified    $Id: HashMap.java,v 1.6 2000/03/15 21:59:13 rao Exp $\n+     */\n+    private static class HashMapEntry extends Bucket.Node implements Map.Entry\n+    {\n+\t/** construct a new HashMapEntry with the given key and value */\n+\tpublic HashMapEntry(Object key, Object value)\n+\t{\n+\t    super(key, value);\n+\t}\n+\n+\t/**\n+\t * if the key == HashMap.NULL_KEY, null is returned, otherwise the actual\n+\t * key is returned\n+\t */\n+\tpublic Object getKey()\n+\t{\n+\t    Object oResult = super.getKey();\n+\t    return (oResult == HashMap.NULL_KEY) ? null : oResult;\n+\t}\n+    }\n+    // EOF -----------------------------------------------------------------------\n+}"}, {"sha": "41f1ab4e4f76cdc443758e36c5a4982e6a91c61e", "filename": "libjava/java/util/LinkedList.java", "status": "added", "additions": 584, "deletions": 0, "changes": 584, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f09c307172fb7beb8202da1ca8cb44346f4874c/libjava%2Fjava%2Futil%2FLinkedList.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f09c307172fb7beb8202da1ca8cb44346f4874c/libjava%2Fjava%2Futil%2FLinkedList.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FLinkedList.java?ref=6f09c307172fb7beb8202da1ca8cb44346f4874c", "patch": "@@ -0,0 +1,584 @@\n+/* LinkedList.java -- Linked list implementation of the List interface\n+   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.util;\n+import java.io.Serializable;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.IOException;\n+\n+// TO DO:\n+// ~ Doc comment for the class.\n+// ~ Doc comments for the non-list methods.\n+// ~ Some commenting on the Backing API and other general implementation notes.\n+\n+/**\n+ * Linked list implementation of the List interface.\n+ */\n+public class LinkedList extends AbstractSequentialList \n+  implements Serializable, Cloneable\n+{\n+  static final long serialVersionUID = 876323262645176354L;\n+\n+  /**\n+   * An Entry containing the head (in the next field) and the tail (in the\n+   * previous field) of the list. The data field is null. If the list is empty,\n+   * both the head and the tail point to ends itself.\n+   */\n+  transient Entry ends = new Entry();\n+\n+  /**\n+   * The current length of the list.\n+   */\n+  transient int size = 0;\n+\n+  /**\n+   * Class to represent an entry in the list. Holds a single element.\n+   */\n+  private static class Entry {\n+\n+    /**\n+     * The list element.\n+     */\n+    Object data = null;\n+\n+    /**\n+     * The next entry in the list. If this is the last entry in the list, the\n+     * ends field of the list is held here.\n+     */\n+    Entry next;\n+\n+    /**\n+     * The previous entry in the list. If this is the first entry in the list,\n+     * the ends field of the list is held here.\n+     */\n+    Entry previous;\n+\n+    /**\n+     * Create an entry with given data and linkage.\n+     */\n+    Entry(Object d, Entry n, Entry p) {\n+      data = d;\n+      next = n;\n+      previous = p;\n+    }\n+\n+    /**\n+     * Create an entry with no data and linking to itself, for use as the ends\n+     * field of the list.\n+     */\n+    Entry() {\n+      next = previous = this;\n+    }\n+\n+    /**\n+     * Remove this entry.\n+     */\n+    Object remove() {\n+      previous.next = next;\n+      next.previous = previous;\n+      return data;\n+    }\n+  }\n+\n+  private static interface Backing {\n+    void checkMod(int known);\n+    void upMod();\n+    void incSize(int by);\n+    void decSize(int by);\n+  }\n+\n+  private final Backing back = new Backing() {\n+    public void checkMod(int known) {\n+      if (known != modCount) {\n+\tthrow new ConcurrentModificationException();\n+      }\n+    }\n+    public void upMod() {\n+      modCount++;\n+    }\n+    public void incSize(int by) {\n+      size += by;\n+    }\n+    public void decSize(int by) {\n+      size -= by;\n+    }\n+  };\n+\n+  /** A ListIterator over the list. This class keeps track of its\n+   * position in the list, the size of the list, and the two list\n+   * entries it is between.  This enables it to be used identically\n+   * for both the list itself and a sublist of the list.\n+   */\n+  private static class Iter implements ListIterator {\n+\n+    /**\n+     * The index of the element that will be returned by next().\n+     */\n+    int pos;\n+\n+    /**\n+     * The size of the backing list.\n+     */\n+    int size;\n+\n+    /**\n+     * The entry containing the element that will be returned by next().\n+     */\n+    Entry next;\n+\n+    /**\n+     * The entry containing the element that will be returned by previous().\n+     */\n+    Entry previous;\n+\n+    /**\n+     * The entry that will be affected by remove() or set().\n+     */\n+    Entry recent;\n+\n+    /**\n+     * The known value of the modCount of the backing list.\n+     */\n+    int knownMod;\n+\n+    private final Backing b;\n+\n+    /**\n+     * Create a new Iter starting at a given Entry within the list, at a given\n+     * position, in a list of given size.\n+     *\n+     * @param index the index to begin iteration.\n+     * @exception IndexOutOfBoundsException if index < 0 || index > size.\n+     */\n+    Iter(Backing backing, Entry n, int index, int s, int modCount) {\n+      b = backing;\n+      pos = index;\n+      size = s;\n+      next = n;\n+      previous = n.previous;\n+      knownMod = modCount;\n+    }\n+\n+    public int nextIndex() {\n+      b.checkMod(knownMod);\n+      return pos;\n+    }\n+\n+    public int previousIndex() {\n+      b.checkMod(knownMod);\n+      return pos - 1;\n+    }\n+\n+    public boolean hasNext() {\n+      b.checkMod(knownMod);\n+      return pos < size;\n+    }\n+\n+    public boolean hasPrevious() {\n+      b.checkMod(knownMod);\n+      return pos > 0;\n+    }\n+\n+    public Object next() {\n+      b.checkMod(knownMod);\n+      if (pos >= size) {\n+\tthrow new NoSuchElementException();\n+      } else {\n+\tpos++;\n+\trecent = previous = next;\n+\tnext = recent.next;\n+\treturn recent.data;\n+      }\n+    }\n+\n+    public Object previous() {\n+      b.checkMod(knownMod);\n+      if (pos <= 0) {\n+\tthrow new NoSuchElementException();\n+      } else {\n+\tpos--;\n+\trecent = next = previous;\n+\tprevious = recent.previous;\n+\treturn recent.data;\n+      }\n+    }\n+\n+    public void remove() {\n+      b.checkMod(knownMod);\n+      if (recent == null) {\n+\tthrow new IllegalStateException();\n+      }\n+\n+      // Adjust the position to before the removed element\n+      if (recent == previous) pos--;\n+\n+      // Could use recent.remove() but this way is quicker, and also correctly\n+      // fixes next and previous.\n+      next = recent.previous.next = recent.next;\n+      previous = recent.next.previous = recent.previous;\n+      size--;\n+      b.decSize(1);\n+      knownMod++;\n+      b.upMod();\n+      recent = null;\n+    }\n+\n+    public void add(Object o) {\n+      b.checkMod(knownMod);\n+      previous.next = next.previous = new Entry(o, next, previous);\n+\n+      // New for 1.2RC1 - the semantics changed so that the iterator is\n+      // positioned *after* the new element.\n+      previous = previous.next;\n+      pos++;\n+\n+      size++;\n+      b.incSize(1);\n+      knownMod++;\n+      b.upMod();\n+      recent = null;\n+    }\n+\n+    public void set(Object o) {\n+      b.checkMod(knownMod);\n+      if (recent == null) {\n+\tthrow new IllegalStateException();\n+      }\n+      recent.data = o;\n+    }\n+  }\n+\n+  /**\n+   * Obtain the Entry at a given position in a list. This method of course\n+   * takes linear time, but it is intelligent enough to take the shorter of the\n+   * paths to get to the Entry required. This implies that the first or last\n+   * entry in the list is obtained in constant time, which is a very desirable\n+   * property.\n+   * For speed and flexibility in which ranges are valid, range checking is not\n+   * done in this method, and if n is outside the range -1 <= n <= size, the\n+   * result will be wrong (but no exception will be thrown).\n+   * Note that you *can* obtain entries at position -1 and size, which are\n+   * equal to prehead and posttail respectively.\n+   * This method is static so that it can also be used in subList.\n+   *\n+   * @param n the number of the entry to get.\n+   * @param size the size of the list to get the entry in.\n+   * @param head the entry before the first element of the list (usually ends).\n+   * @param tail the entry after the last element of the list (usually ends).\n+   */\n+  static Entry getEntry(int n, int size, Entry head, Entry tail) {\n+\n+    // n less than size/2, iterate from start\n+    if (n < size >> 1) {\n+      while (n-- >= 0) {\n+\thead = head.next;\n+      }\n+      return head;\n+\n+    // n greater than size/2, iterate from end\n+    } else {\n+      while (++n <= size) {\n+\ttail = tail.previous;\n+      }\n+      return tail;\n+    }\n+  }\n+\n+  /**\n+   * Create an empty linked list.\n+   */\n+  public LinkedList() {\n+    super();\n+  }\n+\n+  /**\n+   * Create a linked list containing the elements, in order, of a given\n+   * collection.\n+   *\n+   * @param c the collection to populate this list from.\n+   */\n+  public LinkedList(Collection c) {\n+    super();\n+    // Note: addAll could be made slightly faster, but not enough so to justify\n+    // re-implementing it from scratch. It is just a matter of a relatively\n+    // small constant factor.\n+    addAll(c);\n+  }\n+\n+  public Object getFirst() {\n+    if (size == 0) {\n+      throw new NoSuchElementException();\n+    }\n+    return ends.next.data;\n+  }\n+\n+  public Object getLast() {\n+    if (size == 0) {\n+      throw new NoSuchElementException();\n+    }\n+    return ends.previous.data;\n+  }\n+\n+  public Object removeFirst() {\n+    if (size == 0) {\n+      throw new NoSuchElementException();\n+    }\n+    size--;\n+    modCount++;\n+    return ends.next.remove();\n+  }\n+\n+  public Object removeLast() {\n+    if (size == 0) {\n+      throw new NoSuchElementException();\n+    }\n+    size--;\n+    modCount++;\n+    return ends.previous.remove();\n+  }\n+\n+  public void addFirst(Object o) {\n+    ends.next.previous = ends.next = new Entry(o, ends.next, ends);\n+    size++;\n+    modCount++;\n+  }\n+\n+  public void addLast(Object o) {\n+    ends.previous.next = ends.previous = new Entry(o, ends, ends.previous);\n+    size++;\n+    modCount++;\n+  }\n+\n+  /**\n+   * Obtain the number of elements currently in this list.\n+   *\n+   * @returns the number of elements currently in this list.\n+   */\n+  public int size() {\n+    return size;\n+  }\n+\n+  /**\n+   * Remove a range of elements from this list.\n+   *\n+   * @param fromIndex the index, inclusive, to remove from.\n+   * @param toIndex the index, exclusive, to remove to.\n+   * @exception IndexOutOfBoundsException if fromIndex > toIndex || fromIndex <\n+   *   0 || toIndex > size().\n+   */\n+  // Note: normally removeRange is provided to allow efficient ways to\n+  // implement clear() on subLists. However, in this case clear on subLists\n+  // works anyway, so this implementation is included just for completeness\n+  // and because subclasses might try to use it.\n+  protected void removeRange(int fromIndex, int toIndex) {\n+    subList(fromIndex, toIndex).clear();\n+  }\n+\n+  /**\n+   * Clear the list.\n+   */\n+  public void clear() {\n+    ends.next = ends.previous = ends;\n+    modCount++;\n+    size = 0;\n+  }\n+\n+  /**\n+   * Obtain a ListIterator over this list, starting at a given index. The\n+   * ListIterator returned by this method supports the add, remove and set\n+   * methods.\n+   *\n+   * @param index the index of the element to be returned by the first call to\n+   *   next(), or size() to be initially positioned at the end of the list.\n+   * @exception IndexOutOfBoundsException if index < 0 || index > size().\n+   */\n+  public ListIterator listIterator(int index) {\n+\n+    // Check bounds\n+    if (index < 0 || index > size) {\n+      throw new IndexOutOfBoundsException();\n+    }\n+\n+    return new Iter(back, getEntry(index, size, ends, ends), \n+\t\t    index, size, modCount);\n+  }\n+\n+  /**\n+   * Obtain a List view of a subsection of this list, from fromIndex\n+   * (inclusive) to toIndex (exclusive). The returned list is modifiable in\n+   * every respect. Changes to the returned list are reflected in this list. If\n+   * this list is structurally modified is any way other than through the\n+   * returned list, any subsequent operations on the returned list will result\n+   * in a ConcurrentModificationException (that is, the returned list is\n+   * fail-fast).\n+   *\n+   * @param fromIndex the index that the returned list should start from\n+   *    (inclusive).\n+   * @param toIndex the index that the returned list should go to (exclusive).\n+   * @returns a List backed by a subsection of this list.\n+   * @exception IndexOutOfBoundsException if fromIndex < 0 || toIndex > size()\n+   *   || fromIndex > toIndex.\n+   */\n+  public List subList(int fromIndex, int toIndex) {\n+\n+    // Check bounds\n+    if (fromIndex > toIndex || fromIndex < 0 || toIndex > size) {\n+      throw new IndexOutOfBoundsException();\n+    }\n+\n+    return new SubLinkedList(back, modCount,\n+\t\t\t     getEntry(fromIndex - 1, size, ends, ends),\n+\t\t\t     getEntry(toIndex, size, ends, ends),\n+\t\t\t     toIndex - fromIndex);\n+  }\n+\n+  private static class SubLinkedList extends AbstractSequentialList {\n+\n+    Entry head; // entry before the beginning\n+    Entry tail; // entry after the end\n+    int size;\n+    private final Backing b;\n+\n+    private final Backing back = new Backing() {\n+      public void checkMod(int known) {\n+\tif (known != modCount) {\n+\t  throw new ConcurrentModificationException();\n+\t}\n+      }\n+      public void upMod() {\n+\tmodCount++;\n+      }\n+      public void incSize(int by) {\n+\tsize += by;\n+      }\n+      public void decSize(int by) {\n+\tsize -= by;\n+      }\n+    };\n+\n+    SubLinkedList(Backing backing, int knownMod, Entry h, Entry t, int s) {\n+      this.modCount = knownMod;\n+      b = backing;\n+      head = h;\n+      tail = t;\n+      size = s;\n+    }\n+\n+    public int size() {\n+      b.checkMod(this.modCount);\n+      return size;\n+    }\n+\n+    public ListIterator listIterator(int index) {\n+      b.checkMod(this.modCount);\n+\n+      // Check bounds\n+      if (index < 0 || index > size) {\n+\tthrow new IndexOutOfBoundsException();\n+      }\n+\n+      return new Iter(back, getEntry(index, size, head, tail), \n+\t\t      index, size, modCount);\n+    }\n+\n+    public void clear() {\n+      b.checkMod(this.modCount);\n+      head.next = tail;\n+      tail.previous = head;\n+      size = 0;\n+      b.decSize(size);\n+      modCount++;\n+      b.upMod();\n+    }\n+\n+    // No removeRange because this class cannot be publically subclassed.\n+\n+    public List subList(int fromIndex, int toIndex) {\n+      b.checkMod(this.modCount);\n+\n+      // Check bounds\n+      if (fromIndex > toIndex || fromIndex < 0 || toIndex > size) {\n+\tthrow new IndexOutOfBoundsException();\n+      }\n+\n+      return new SubLinkedList(back, this.modCount,\n+\t\t\t       getEntry(fromIndex - 1, size, head, tail),\n+\t\t\t       getEntry(toIndex, size, head, tail),\n+\t\t\t       toIndex - fromIndex);\n+    }\n+  }\n+\n+  /**\n+   * Create a shallow copy of this LinkedList.\n+   * @return an object of the same class as this object, containing the\n+   * same elements in the same order.\n+   */\n+  public Object clone() \n+  {\n+    LinkedList copy;\n+    try\n+      {\n+\tcopy = (LinkedList) super.clone();\n+      }\n+    catch (CloneNotSupportedException ex)\n+      {\n+\tthrow new InternalError(ex.getMessage());\n+      }\n+    copy.size = 0;\n+    copy.ends = new Entry();\n+    copy.addAll(this);\n+    return copy;\n+  }\n+\n+  /**\n+   * Serialize an object to a stream.\n+   * @serialdata the size of the list (int), followed by all the elements\n+   * (Object) in proper order.\n+   */\n+  private void writeObject(ObjectOutputStream s)\n+    throws IOException\n+  {\n+    s.writeInt(size);\n+    for (Iterator i = iterator(); i.hasNext(); )\n+      s.writeObject(i.next());\n+  }\n+\n+  /**\n+   * Deserialize an object from a stream.\n+   * @serialdata the size of the list (int), followed by all the elements\n+   * (Object) in proper order.\n+   */\n+  private void readObject(ObjectInputStream s)\n+    throws IOException, ClassNotFoundException\n+  {\n+    int serialSize = s.readInt();\n+    ends = new Entry();\n+    for (int i=0; i< serialSize; i++)\n+      addLast(s.readObject());\n+  }\n+}"}, {"sha": "594f188ae5695689f1e55f5eddd9b7ffed826799", "filename": "libjava/java/util/SortedMap.java", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f09c307172fb7beb8202da1ca8cb44346f4874c/libjava%2Fjava%2Futil%2FSortedMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f09c307172fb7beb8202da1ca8cb44346f4874c/libjava%2Fjava%2Futil%2FSortedMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FSortedMap.java?ref=6f09c307172fb7beb8202da1ca8cb44346f4874c", "patch": "@@ -0,0 +1,40 @@\n+/* SortedMap.java -- A map that makes guarantees about the order of its keys\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+// TO DO:\n+// ~ Doc comments for everything.\n+\n+package java.util;\n+\n+public interface SortedMap extends Map {\n+  Comparator comparator();\n+  Object firstKey();\n+  SortedMap headMap(Object toKey);\n+  Object lastKey();\n+  SortedMap subMap(Object fromKey, Object toKey);\n+  SortedMap tailMap(Object fromKey);\n+}"}, {"sha": "ede65032b527a76aeeb3e52398538268484fa6d1", "filename": "libjava/java/util/SortedSet.java", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f09c307172fb7beb8202da1ca8cb44346f4874c/libjava%2Fjava%2Futil%2FSortedSet.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f09c307172fb7beb8202da1ca8cb44346f4874c/libjava%2Fjava%2Futil%2FSortedSet.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FSortedSet.java?ref=6f09c307172fb7beb8202da1ca8cb44346f4874c", "patch": "@@ -0,0 +1,41 @@\n+/* SortedSet.java -- A set that makes guarantees about the order of its \n+   elements\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+// TO DO:\n+// ~ Doc comments for everything.\n+\n+package java.util;\n+\n+public interface SortedSet extends Set {\n+  Comparator comparator();\n+  Object first();\n+  SortedSet headSet(Object toElement);\n+  Object last();\n+  SortedSet subSet(Object fromElement, Object toElement);\n+  SortedSet tailSet(Object fromElement);\n+}"}, {"sha": "8c3e993833a485d7d1a99b091ad4a1d791ab55e2", "filename": "libjava/java/util/Timer.java", "status": "added", "additions": 525, "deletions": 0, "changes": 525, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f09c307172fb7beb8202da1ca8cb44346f4874c/libjava%2Fjava%2Futil%2FTimer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f09c307172fb7beb8202da1ca8cb44346f4874c/libjava%2Fjava%2Futil%2FTimer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FTimer.java?ref=6f09c307172fb7beb8202da1ca8cb44346f4874c", "patch": "@@ -0,0 +1,525 @@\n+/* Timer.java -- Timer that runs TimerTasks at a later time.\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+package java.util;\n+\n+/**\n+ * Timer that can run TimerTasks at a later time.\n+ * TimerTasks can be scheduled for one time execution at some time in the\n+ * future. They can be scheduled to be rescheduled at a time period after the\n+ * task was last executed. Or they can be scheduled to be executed repeatedly\n+ * at a fixed rate.\n+ * <p>\n+ * The normal scheduling will result in a more or less even delay in time\n+ * between successive executions, but the executions could drift in time if\n+ * the task (or other tasks) takes a long time to execute. Fixed delay\n+ * scheduling guarantees more or less that the task will be executed at a\n+ * specific time, but if there is ever a delay in execution then the period\n+ * between successive executions will be shorter. The first method of\n+ * repeated scheduling is prefered for repeated tasks in response to user\n+ * interaction, the second method of repeated scheduling is prefered for tasks\n+ * that act like alarms.\n+ * <p>\n+ * The Timer keeps a binary heap as a task priority queue which means that\n+ * scheduling and serving of a task in a queue of n tasks costs O(log n).\n+ *\n+ * @see TimerTask\n+ * @since 1.3\n+ * @author Mark Wielaard (mark@klomp.org)\n+ */\n+public class Timer {\n+\n+    /**\n+     * Priority Task Queue.\n+     * TimerTasks are kept in a binary heap.\n+     * The scheduler calls sleep() on the queue when it has nothing to do or\n+     * has to wait. A sleeping scheduler can be notified by calling interrupt()\n+     * which is automatically called by the enqueue(), cancel() and\n+     * timerFinalized() methods.\n+     */\n+    private static final class TaskQueue {\n+\n+        /** Default size of this queue */\n+        private final int DEFAULT_SIZE = 32;\n+\n+        /** Wheter to return null when there is nothing in the queue */\n+        private boolean nullOnEmpty;\n+\n+        /**\n+         * The heap containing all the scheduled TimerTasks\n+         * sorted by the TimerTask.scheduled field.\n+         * Null when the stop() method has been called.\n+         */\n+        private TimerTask heap[];\n+\n+        /**\n+         * The actual number of elements in the heap\n+         * Can be less then heap.length.\n+         * Note that heap[0] is used as a sentinel.\n+         */\n+        private int elements;\n+\n+        /**\n+         * Creates a TaskQueue of default size without any elements in it.\n+         */\n+        public TaskQueue() {\n+            heap = new TimerTask[DEFAULT_SIZE];\n+            elements = 0;\n+            nullOnEmpty = false;\n+        }\n+\n+        /**\n+         * Adds a TimerTask at the end of the heap.\n+         * Grows the heap if necessary by doubling the heap in size.\n+         */\n+        private void add(TimerTask task) {\n+            elements++;\n+            if (elements == heap.length) {\n+                TimerTask new_heap[] = new TimerTask[heap.length*2];\n+                System.arraycopy(heap, 0, new_heap, 0, heap.length);\n+                heap = new_heap;\n+            }\n+            heap[elements] = task;\n+        }\n+\n+        /**\n+         * Removes the last element from the heap.\n+         * Shrinks the heap in half if\n+         * elements+DEFAULT_SIZE/2 <= heap.length/4.\n+         */\n+        private void remove() {\n+            // clear the entry first\n+            heap[elements] = null;\n+            elements--;\n+            if (elements+DEFAULT_SIZE/2 <= (heap.length/4)) {\n+                TimerTask new_heap[] = new TimerTask[heap.length/2];\n+                System.arraycopy(heap, 0, new_heap, 0, elements+1);\n+            }\n+        }\n+\n+        /**\n+         * Adds a task to the queue and puts it at the correct place\n+         * in the heap.\n+         */\n+        public synchronized void enqueue(TimerTask task) {\n+ \n+           // Check if it is legal to add another element\n+            if (heap == null) {\n+                throw new IllegalStateException\n+                    (\"cannot enqueue when stop() has been called on queue\");\n+            }\n+\n+            heap[0] = task; // sentinel\n+            add(task); // put the new task at the end\n+            // Now push the task up in the heap until it has reached its place\n+            int child = elements;\n+            int parent = child / 2;\n+            while (heap[parent].scheduled > task.scheduled) {\n+                heap[child] = heap[parent];\n+                child = parent;\n+                parent = child / 2;\n+            }\n+            // This is the correct place for the new task\n+            heap[child] = task;\n+            heap[0] = null; // clear sentinel\n+            // Maybe sched() is waiting for a new element\n+            this.notify();\n+        }\n+\n+        /**\n+         * Returns the top element of the queue.\n+         * Can return null when no task is in the queue.\n+         */\n+        private TimerTask top() {\n+            if (elements == 0) {\n+                return null;\n+            } else {\n+                return heap[1];\n+            }\n+        }\n+\n+        /**\n+         * Returns the top task in the Queue.\n+         * Removes the element from the heap and reorders the heap first.\n+         * Can return null when there is nothing in the queue.\n+         */\n+        public synchronized TimerTask serve() {\n+            // The task to return\n+            TimerTask task = null;\n+            \n+            while (task == null) {\n+                // Get the next task\n+                task = top();\n+                \n+                // return null when asked to stop\n+                // or if asked to return null when the queue is empty\n+                if ((heap == null) || (task == null && nullOnEmpty)) {\n+                    return null;\n+                }\n+                \n+                // Do we have a task?\n+                if (task != null) {\n+                    // The time to wait until the task should be served\n+                    long time = task.scheduled-System.currentTimeMillis();\n+                    if (time > 0) {\n+                        // This task should not yet be served\n+                        // So wait until this task is ready\n+                        // or something else happens to the queue\n+                        task = null; // set to null to make sure we call top()\n+                        try {\n+                            this.wait(time);\n+                        } catch (InterruptedException _) {}\n+                    }\n+                } else {\n+                    // wait until a task is added\n+                    // or something else happens to the queue\n+                    try {\n+                        this.wait();\n+                    } catch (InterruptedException _) {}\n+                }\n+            }\n+            \n+            // reconstruct the heap\n+            TimerTask lastTask = heap[elements];\n+            remove();\n+            \n+            // drop lastTask at the beginning and move it down the heap\n+            int parent = 1;\n+            int child = 2;\n+            heap[1] = lastTask;\n+            while(child <= elements) {\n+                if (child < elements) {\n+                    if (heap[child].scheduled > heap[child+1].scheduled) {\n+                        child++;\n+                    }\n+                }\n+                \n+                if (lastTask.scheduled <= heap[child].scheduled)\n+                    break; // found the correct place (the parent) - done\n+                \n+                heap[parent] = heap[child];\n+                parent = child;\n+                child = parent*2;\n+            }\n+\n+            // this is the correct new place for the lastTask\n+            heap[parent] = lastTask;\n+\n+            // return the task\n+            return task;\n+        }\n+\n+    \n+        /**\n+         * When nullOnEmpty is true the serve() method will return null when\n+         * there are no tasks in the queue, otherwise it will wait until\n+         * a new element is added to the queue. It is used to indicate to\n+         * the scheduler that no new tasks will ever be added to the queue.\n+         */\n+        public synchronized void setNullOnEmpty(boolean nullOnEmpty) {\n+            this.nullOnEmpty = nullOnEmpty;\n+            this.notify();\n+        }\n+\n+        /**\n+         * When this method is called the current and all future calls to\n+         * serve() will return null. It is used to indicate to the Scheduler\n+         * that it should stop executing since no more tasks will come.\n+         */\n+        public synchronized void stop() {\n+            this.heap = null;\n+            this.notify();\n+        }\n+        \n+    } // TaskQueue\n+\n+    /**\n+     * The scheduler that executes all the tasks on a particular TaskQueue,\n+     * reschedules any repeating tasks and that waits when no task has to be\n+     * executed immediatly. Stops running when canceled or when the parent\n+     * Timer has been finalized and no more tasks have to be executed.\n+     */\n+    private static final class Scheduler implements Runnable {\n+\n+        // The priority queue containing all the TimerTasks.\n+        private TaskQueue queue;\n+\n+        /**\n+         * Creates a new Scheduler that will schedule the tasks on the\n+         * given TaskQueue.\n+         */\n+        public Scheduler(TaskQueue queue) {\n+            this.queue = queue;\n+        }\n+\n+        public void run() {\n+            TimerTask task;\n+            while((task = queue.serve()) != null) {\n+                // If this task has not been canceled\n+                if (task.scheduled >= 0) {\n+\n+                    // Mark execution time\n+                    task.lastExecutionTime = task.scheduled;\n+\n+                    // Repeatable task?\n+                    if (task.period < 0) {\n+                        // Last time this task is executed\n+                        task.scheduled = -1;\n+                    }\n+\n+                    // Run the task\n+                    try {\n+                        task.run();\n+                    } catch (Throwable t) {/* ignore all errors */}\n+                }\n+\n+                // Calculate next time and possibly re-enqueue\n+                if (task.scheduled >= 0) {\n+                    if (task.fixed) {\n+                        task.scheduled += task.period;\n+                    } else {\n+                        task.scheduled = task.period +\n+                            System.currentTimeMillis();\n+                    }\n+                    queue.enqueue(task);\n+                }\n+            }\n+        }\n+    } // Scheduler\n+\n+    // Number of Timers created.\n+    // Used for creating nice Thread names.\n+    private static int  nr = 0;\n+\n+    // The queue that all the tasks are put in.\n+    // Given to the scheduler\n+    private TaskQueue queue;\n+\n+    // The Scheduler that does all the real work\n+    private Scheduler scheduler;\n+\n+    // Used to run the scheduler.\n+    // Also used to checked if the Thread is still running by calling\n+    // thread.isAlive(). Sometimes a Thread is suddenly killed by the system\n+    // (if it belonged to an Applet).\n+    private Thread thread;\n+    \n+    // When cancelled we don't accept any more TimerTasks.\n+    private boolean canceled;\n+\n+    /**\n+     * Creates a new Timer with a non deamon Thread as Scheduler, with normal\n+     * priority and a default name.\n+     */\n+    public Timer() {\n+        this(false);\n+    }\n+\n+    /**\n+     * Creates a new Timer with a deamon Thread as scheduler if deamon is true,\n+     * with normal priority and a default name.\n+     */\n+    public Timer(boolean daemon) {\n+        this(daemon, Thread.NORM_PRIORITY);\n+    }\n+\n+    /**\n+     * Creates a new Timer with a deamon Thread as scheduler if deamon is true,\n+     * with the priority given and a default name.\n+     */\n+    private Timer(boolean daemon, int priority) {\n+        this(daemon, priority, \"Timer-\" + (++nr));\n+    }\n+\n+    /**\n+     * Creates a new Timer with a deamon Thread as scheduler if deamon is true,\n+     * with the priority and name given.E\n+     */\n+    private Timer(boolean daemon, int priority, String name) {\n+        canceled = false;\n+        queue = new TaskQueue();\n+        scheduler = new Scheduler(queue);\n+        thread = new Thread(scheduler, name);\n+        thread.setDaemon(daemon);\n+        thread.setPriority(priority);\n+        thread.start();\n+    }\n+\n+    /**\n+     * Cancels the execution of the scheduler. If a task is executing it will\n+     * normally finish execution, but no other tasks will be executed and no\n+     * more tasks can be scheduled.\n+     */\n+    public void cancel() {\n+        canceled = true;\n+        queue.stop();\n+    }\n+\n+    /**\n+     * Schedules the task at Time time, repeating every period\n+     * milliseconds if period is positive and at a fixed rate if fixed is true.\n+     *\n+     * @exception IllegalArgumentException if time is negative\n+     * @exception IllegalStateException if the task was already scheduled or\n+     * canceled or this Timer is canceled or the scheduler thread has died\n+     */\n+    private void schedule(TimerTask task,\n+                          long time,\n+                          long period,\n+                          boolean fixed) {\n+\n+        if (time < 0)\n+            throw new IllegalArgumentException(\"negative time\");\n+\n+        if (task.scheduled == 0 && task.lastExecutionTime == -1) {\n+            task.scheduled = time;\n+            task.period = period;\n+            task.fixed = fixed;\n+        } else {\n+            throw new IllegalStateException\n+                (\"task was already scheduled or canceled\");\n+        }\n+\n+        if (!this.canceled && this.thread != null) {\n+            queue.enqueue(task);\n+        } else {\n+            throw new IllegalStateException\n+                (\"timer was canceled or scheduler thread has died\");\n+        }\n+    }\n+\n+    private static void positiveDelay(long delay) {\n+        if (delay < 0) {\n+            throw new IllegalArgumentException(\"delay is negative\");\n+        }\n+    }\n+\n+    private static void positivePeriod(long period) {\n+        if (period < 0) {\n+            throw new IllegalArgumentException(\"period is negative\");\n+        }\n+    }\n+\n+    /**\n+     * Schedules the task at the specified data for one time execution.\n+     *\n+     * @exception IllegalArgumentException if date.getTime() is negative\n+     * @exception IllegalStateException if the task was already scheduled or\n+     * canceled or this Timer is canceled or the scheduler thread has died\n+     */\n+    public void schedule(TimerTask task, Date date) {\n+        long time = date.getTime();\n+        schedule(task, time, -1, false);\n+    }\n+\n+    /**\n+     * Schedules the task at the specified date and reschedules the task every\n+     * period milliseconds after the last execution of the task finishes until\n+     * this timer or the task is canceled.\n+     *\n+     * @exception IllegalArgumentException if period or date.getTime() is\n+     * negative\n+     * @exception IllegalStateException if the task was already scheduled or\n+     * canceled or this Timer is canceled or the scheduler thread has died\n+     */\n+    public void schedule(TimerTask task, Date date, long period) {\n+        positivePeriod(period);\n+        long time = date.getTime();\n+        schedule(task, time, period, false);\n+    }\n+\n+    /**\n+     * Schedules the task after the specified delay milliseconds for one time\n+     * execution.\n+     *\n+     * @exception IllegalArgumentException if delay or\n+     * System.currentTimeMillis + delay is negative\n+     * @exception IllegalStateException if the task was already scheduled or\n+     * canceled or this Timer is canceled or the scheduler thread has died\n+     */\n+    public void schedule(TimerTask task, long delay) {\n+        positiveDelay(delay);\n+        long time = System.currentTimeMillis() + delay;\n+        schedule(task, time, -1, false);\n+    }\n+\n+    /**\n+     * Schedules the task after the delay milliseconds and reschedules the\n+     * task every period milliseconds after the last execution of the task\n+     * finishes until this timer or the task is canceled.\n+     *\n+     * @exception IllegalArgumentException if delay or period is negative\n+     * @exception IllegalStateException if the task was already scheduled or\n+     * canceled or this Timer is canceled or the scheduler thread has died\n+     */\n+    public void schedule(TimerTask task, long delay, long period) {\n+        positiveDelay(delay);\n+        positivePeriod(period);\n+        long time = System.currentTimeMillis() + delay;\n+        schedule(task, time, period, false);\n+    }\n+\n+    /**\n+     * Schedules the task at the specified date and reschedules the task at a\n+     * fixed rate every period milliseconds until this timer or the task is\n+     * canceled.\n+     *\n+     * @exception IllegalArgumentException if period or date.getTime() is\n+     * negative\n+     * @exception IllegalStateException if the task was already scheduled or\n+     * canceled or this Timer is canceled or the scheduler thread has died\n+     */\n+    public void scheduleAtFixedRate(TimerTask task, Date date, long period) {\n+        positivePeriod(period);\n+        long time = date.getTime();\n+        schedule(task, time, period, true);\n+    }\n+\n+    /**\n+     * Schedules the task after the delay milliseconds and reschedules the task\n+     * at a fixed rate every period milliseconds until this timer or the task\n+     * is canceled.\n+     *\n+     * @exception IllegalArgumentException if delay or\n+     * System.currentTimeMillis + delay is negative\n+     * @exception IllegalStateException if the task was already scheduled or\n+     * canceled or this Timer is canceled or the scheduler thread has died\n+     */\n+    public void scheduleAtFixedRate(TimerTask task, long delay, long period) {\n+        positiveDelay(delay);\n+        positivePeriod(period);\n+        long time = System.currentTimeMillis() + delay;\n+        schedule(task, time, period, true);\n+    }\n+\n+    /**\n+     * Tells the scheduler that the Timer task died\n+     * so there will be no more new tasks scheduled.\n+     */\n+    protected void finalize() {\n+        queue.setNullOnEmpty(true);\n+    }\n+}"}, {"sha": "29ffe342fc334bac6582da59f35ab374b7a84a22", "filename": "libjava/java/util/TimerTask.java", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f09c307172fb7beb8202da1ca8cb44346f4874c/libjava%2Fjava%2Futil%2FTimerTask.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f09c307172fb7beb8202da1ca8cb44346f4874c/libjava%2Fjava%2Futil%2FTimerTask.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FTimerTask.java?ref=6f09c307172fb7beb8202da1ca8cb44346f4874c", "patch": "@@ -0,0 +1,131 @@\n+/* TimerTask.java -- Task that can be run at a later time if given to a Timer.\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+package java.util;\n+\n+/**\n+ * Task that can be run at a later time if given to a Timer.\n+ * The TimerTask must implement a run method that will be called by the\n+ * Timer when the task is scheduled for execution. The task can check when\n+ * it should have been scheduled and cancel itself when no longer needed.\n+ * <p>\n+ * Example:\n+ * <code>\n+ *  Timer timer = new Timer();\n+ *  TimerTask task = new TimerTask() {\n+ *      public void run() {\n+ *      if (this.scheduledExecutionTime() < System.currentTimeMillis() + 500)\n+ *          // Do something\n+ *      else\n+ *          // Complain: We are more then half a second late!\n+ *      if (someStopCondition)\n+ *          this.cancel(); // This was our last execution\n+ *  };\n+ *  timer.scheduleAtFixedRate(task, 1000, 1000); // schedule every second\n+ * </code>\n+ * <p>\n+ * Note that a TimerTask object is a one shot object and can only given once\n+ * to a Timer. (The Timer will use the TimerTask object for bookkeeping,\n+ * in this implementation).\n+ * <p>\n+ * This class also implements <code>Runnable</code> to make it possible to\n+ * give a TimerTask directly as a target to a <code>Thread</code>.\n+ *\n+ * @see Timer\n+ * @since 1.3\n+ * @author Mark Wielaard (mark@klomp.org)\n+ */\n+public abstract class TimerTask implements Runnable {\n+\n+    /**\n+     * If positive the next time this task should be run.\n+     * If negative this TimerTask is canceled or executed for the last time.\n+     */\n+    long scheduled;\n+\n+    /**\n+     * If positive the last time this task was run.\n+     * If negative this TimerTask has not yet been scheduled.\n+     */\n+    long lastExecutionTime;\n+\n+    /**\n+     * If positive the number of milliseconds between runs of this task.\n+     * If -1 this task doesn't have to be run more then once.\n+     */\n+    long period;\n+\n+    /**\n+     * If true the next time this task should be run is relative to\n+     * the last scheduled time, otherwise it can drift in time.\n+     */\n+    boolean fixed;\n+\n+    /**\n+     * Creates a TimerTask and marks it as not yet scheduled.\n+     */\n+    protected TimerTask() {\n+        this.scheduled = 0;\n+        this.lastExecutionTime = -1;\n+    }\n+\n+    /**\n+     * Marks the task as canceled and prevents any further execution.\n+     * Returns true if the task was scheduled for any execution in the future\n+     * and this cancel operation prevents that execution from happening.\n+     * <p>\n+     * A task that has been canceled can never be scheduled again.\n+     * <p>\n+     * In this implementation the TimerTask it is possible that the Timer does\n+     * keep a reference to the TimerTask until the first time the TimerTask\n+     * is actually scheduled. But the reference will disappear immediatly when\n+     * cancel is called from within the TimerTask run method.\n+     */\n+    public boolean cancel() {\n+        boolean prevented_execution = (this.scheduled >= 0);\n+        this.scheduled = -1;\n+        return prevented_execution;\n+    }\n+\n+    /**\n+     * Method that is called when this task is scheduled for execution.\n+     */\n+    public abstract void run();\n+\n+    /**\n+     * Returns the last time this task was scheduled or (when called by the\n+     * task from the run method) the time the current execution of the task\n+     * was scheduled. When the task has not yet run the return value is\n+     * undefined.\n+     * <p>\n+     * Can be used (when the task is scheduled at fixed rate) to see the\n+     * difference between the requested schedule time and the actual time\n+     * that can be found with <code>System.currentTimeMillis()</code>.\n+     */\n+    public long scheduledExecutionTime() {\n+        return lastExecutionTime;\n+    }\n+}"}]}