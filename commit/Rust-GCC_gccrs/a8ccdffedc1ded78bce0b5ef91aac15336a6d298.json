{"sha": "a8ccdffedc1ded78bce0b5ef91aac15336a6d298", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YThjY2RmZmVkYzFkZWQ3OGJjZTBiNWVmOTFhYWMxNTMzNmE2ZDI5OA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@codesourcery.com", "date": "2003-07-28T00:12:32Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-07-28T00:12:32Z"}, "message": "c-decl.c (struct c_scope): Remove keep_if_subblocks field.\n\n\t* c-decl.c (struct c_scope): Remove keep_if_subblocks field.\n\t(keep_next_if_subblocks): Rename next_is_function_body.\n\t(pushlevel): Adjust commentary.  Always set ->keep on the\n\toutermost level of a function.  Don't set ->keep_if_subblocks.\n\t(poplevel): Adjust commentary.  Don't look at ->keep_if_subblocks.\n\t(store_parm_decls): Adjust to match.\n\t(finish_function): Adjust to match.\n\tCall poplevel with all three arguments zero.\n\nFrom-SVN: r69865", "tree": {"sha": "7ddd711a5c0a7923e80b7886c12ae06f84ee1f61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ddd711a5c0a7923e80b7886c12ae06f84ee1f61"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a8ccdffedc1ded78bce0b5ef91aac15336a6d298", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8ccdffedc1ded78bce0b5ef91aac15336a6d298", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8ccdffedc1ded78bce0b5ef91aac15336a6d298", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8ccdffedc1ded78bce0b5ef91aac15336a6d298/comments", "author": null, "committer": null, "parents": [{"sha": "2d29f3a1c523bb1bc1ba8f7b63ca9b0214b42f9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d29f3a1c523bb1bc1ba8f7b63ca9b0214b42f9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d29f3a1c523bb1bc1ba8f7b63ca9b0214b42f9a"}], "stats": {"total": 66, "additions": 37, "deletions": 29}, "files": [{"sha": "42fe2f85adea962c4f15861f6d228e443860306d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8ccdffedc1ded78bce0b5ef91aac15336a6d298/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8ccdffedc1ded78bce0b5ef91aac15336a6d298/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a8ccdffedc1ded78bce0b5ef91aac15336a6d298", "patch": "@@ -1,5 +1,14 @@\n 2003-07-27  Zack Weinberg  <zack@codesourcery.com>\n \n+\t* c-decl.c (struct c_scope): Remove keep_if_subblocks field.\n+\t(keep_next_if_subblocks): Rename next_is_function_body.\n+\t(pushlevel): Adjust commentary.  Always set ->keep on the\n+\toutermost level of a function.  Don't set ->keep_if_subblocks.\n+\t(poplevel): Adjust commentary.  Don't look at ->keep_if_subblocks.\n+\t(store_parm_decls): Adjust to match.\n+\t(finish_function): Adjust to match.\n+\tCall poplevel with all three arguments zero.\n+\n \t* c-decl.c (store_parm_decls_newstyle, store_parm_decls_oldstyle):\n \tNew functions split out of store_parm_decls.\n \tAvoid unnecessary work. Use local variables consistently."}, {"sha": "2325eaee8141ee66946b02ef3fd7d07a55b1fbb0", "filename": "gcc/c-decl.c", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8ccdffedc1ded78bce0b5ef91aac15336a6d298/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8ccdffedc1ded78bce0b5ef91aac15336a6d298/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=a8ccdffedc1ded78bce0b5ef91aac15336a6d298", "patch": "@@ -215,9 +215,6 @@ struct c_scope GTY(())\n     /* True means make a BLOCK for this scope regardless of all else.  */\n     bool keep : 1;\n \n-    /* True means make a BLOCK if this scope has any subblocks.  */\n-    bool keep_if_subblocks : 1;\n-\n     /* List of decls in `names' that have incomplete structure or\n        union types.  */\n     tree incomplete_list;\n@@ -250,9 +247,11 @@ static GTY(()) struct c_scope *global_scope;\n \n static bool keep_next_level_flag;\n \n-/* True means make a BLOCK for the next scope pushed if it has subblocks.  */\n+/* True means the next call to pushlevel will be the outermost scope\n+   of a function body, so do not push a new scope, merely cease\n+   expecting parameter decls.  */\n \n-static bool keep_next_if_subblocks;\n+static bool next_is_function_body;\n \n /* Functions called automatically at the beginning and end of execution.  */\n \n@@ -408,25 +407,26 @@ in_parm_level_p (void)\n void\n pushlevel (int dummy ATTRIBUTE_UNUSED)\n {\n-  if (keep_next_if_subblocks)\n+  if (next_is_function_body)\n     {\n       /* This is the transition from the parameters to the top level\n \t of the function body.  These are the same scope\n \t (C99 6.2.1p4,6) so we do not push another scope structure.\n+\t next_is_function_body is set only by store_parm_decls, which\n+\t in turn is called when and only when we are about to\n+\t encounter the opening curly brace for the function body.\n \n-\t XXX Note kludge - keep_next_if_subblocks is set only by\n-\t store_parm_decls, which in turn is called when and only\n-\t when we are about to encounter the opening curly brace for\n-\t the function body.  */\n+\t The outermost block of a function always gets a BLOCK node,\n+\t because the debugging output routines expect that each\n+\t function has at least one BLOCK. */\n       current_scope->parm_flag         = false;\n       current_scope->function_body     = true;\n-      current_scope->keep             |= keep_next_level_flag;\n-      current_scope->keep_if_subblocks = true;\n+      current_scope->keep              = true;\n       current_scope->outer_function    = current_function_scope;\n       current_function_scope           = current_scope;\n \n       keep_next_level_flag = false;\n-      keep_next_if_subblocks = false;\n+      next_is_function_body = false;\n     }\n   else\n     {\n@@ -448,8 +448,8 @@ pushlevel (int dummy ATTRIBUTE_UNUSED)\n    or tags lists are nonempty.\n \n    If FUNCTIONBODY is nonzero, this level is the body of a function,\n-   so create a block as if KEEP were set and also clear out all\n-   label names.\n+   so create a BLOCK as if KEEP were set, and save that BLOCK in\n+   DECL_INITIAL of current_function_decl.\n \n    If REVERSE is nonzero, reverse the order of decls before putting\n    them into the BLOCK.  */\n@@ -468,9 +468,9 @@ poplevel (int keep, int reverse, int functionbody)\n \n   if (keep == KEEP_MAYBE)\n     keep = (current_scope->names || current_scope->tags);\n-  \n-  keep |= (current_scope->keep || functionbody\n-\t   || (subblocks && current_scope->keep_if_subblocks));\n+\n+  keep |= current_scope->keep;\n+  keep |= functionbody;\n \n   /* We used to warn about unused variables in expand_end_bindings,\n      i.e. while generating RTL.  But in function-at-a-time mode we may\n@@ -6058,11 +6058,9 @@ store_parm_decls (void)\n   else\n     store_parm_decls_oldstyle ();\n \n-  /* Make sure the scope for the top of the function body\n-     gets a BLOCK if there are any in the function.\n-     Otherwise, the dbx output is wrong.  */\n+  /* The next call to pushlevel will be a function body.  */\n \n-  keep_next_if_subblocks = 1;\n+  next_is_function_body = true;\n \n   /* Write a record describing this function definition to the prototypes\n      file (if requested).  */\n@@ -6121,15 +6119,16 @@ finish_function (int nested, int can_defer_p)\n         void foo(void) { }\n      (the argument list is irrelevant) the compstmt rule will not\n      bother calling pushlevel/poplevel, which means we get here with\n-     the scope stack out of sync.  Detect this situation by\n-     noticing that current_scope is still as\n-     store_parm_decls left it, and do a dummy push/pop to get back to\n-     consistency.  Note that the call to pushlevel does not actually\n-     push another scope - see there for details.  */\n-  if (current_scope->parm_flag && keep_next_if_subblocks)\n+     the scope stack out of sync.  Detect this situation by noticing\n+     that current_scope is still as store_parm_decls left it, and do\n+     a dummy push/pop to get back to consistency.\n+     Note that the call to pushlevel does not actually push another\n+     scope - see there for details.  */\n+\n+  if (current_scope->parm_flag && next_is_function_body)\n     {\n       pushlevel (0);\n-      poplevel (1, 0, 0);\n+      poplevel (0, 0, 0);\n     }\n \n   BLOCK_SUPERCONTEXT (DECL_INITIAL (fndecl)) = fndecl;"}]}