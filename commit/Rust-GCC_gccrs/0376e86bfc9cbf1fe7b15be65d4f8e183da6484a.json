{"sha": "0376e86bfc9cbf1fe7b15be65d4f8e183da6484a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDM3NmU4NmJmYzljYmYxZmU3YjE1YmU2NWQ0ZjhlMTgzZGE2NDg0YQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2016-12-15T12:45:42Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2016-12-15T12:45:42Z"}, "message": "Add GDB XMethods for shared_ptr and unique_ptr<T[]>\n\n\t* python/libstdcxx/v6/xmethods.py (UniquePtrGetWorker.__init__): Use\n\tcorrect element type for unique_ptr<T[]>.\n\t(UniquePtrGetWorker._supports, UniquePtrDerefWorker._supports): New\n\tfunctions to disable unsupported operators for unique_ptr<T[]>.\n\t(UniquePtrSubscriptWorker): New worker for operator[].\n\t(UniquePtrMethodsMatcher.__init__): Register UniquePtrSubscriptWorker.\n\t(UniquePtrMethodsMatcher.match): Call _supports on the chosen worker.\n\t(SharedPtrGetWorker, SharedPtrDerefWorker, SharedPtrSubscriptWorker)\n\t(SharedPtrUseCountWorker, SharedPtrUniqueWorker): New workers.\n\t(SharedPtrMethodsMatcher): New matcher for shared_ptr.\n\t(register_libstdcxx_xmethods): Register SharedPtrMethodsMatcher.\n\t* testsuite/libstdc++-xmethods/unique_ptr.cc: Test arrays.\n\t* testsuite/libstdc++-xmethods/shared_ptr.cc: New test.\n\nFrom-SVN: r243688", "tree": {"sha": "ae1599078d94ec2e2137bc68e7a9105f160f8870", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae1599078d94ec2e2137bc68e7a9105f160f8870"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0376e86bfc9cbf1fe7b15be65d4f8e183da6484a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0376e86bfc9cbf1fe7b15be65d4f8e183da6484a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0376e86bfc9cbf1fe7b15be65d4f8e183da6484a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0376e86bfc9cbf1fe7b15be65d4f8e183da6484a/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5aa934d0f22c06e4e2d2316aa6d48bd8a727243", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5aa934d0f22c06e4e2d2316aa6d48bd8a727243", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5aa934d0f22c06e4e2d2316aa6d48bd8a727243"}], "stats": {"total": 269, "additions": 261, "deletions": 8}, "files": [{"sha": "a881ee6829da43ffd3e32d4c6f19ad5d233c1e49", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0376e86bfc9cbf1fe7b15be65d4f8e183da6484a/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0376e86bfc9cbf1fe7b15be65d4f8e183da6484a/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=0376e86bfc9cbf1fe7b15be65d4f8e183da6484a", "patch": "@@ -1,3 +1,19 @@\n+2016-12-15  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* python/libstdcxx/v6/xmethods.py (UniquePtrGetWorker.__init__): Use\n+\tcorrect element type for unique_ptr<T[]>.\n+\t(UniquePtrGetWorker._supports, UniquePtrDerefWorker._supports): New\n+\tfunctions to disable unsupported operators for unique_ptr<T[]>.\n+\t(UniquePtrSubscriptWorker): New worker for operator[].\n+\t(UniquePtrMethodsMatcher.__init__): Register UniquePtrSubscriptWorker.\n+\t(UniquePtrMethodsMatcher.match): Call _supports on the chosen worker.\n+\t(SharedPtrGetWorker, SharedPtrDerefWorker, SharedPtrSubscriptWorker)\n+\t(SharedPtrUseCountWorker, SharedPtrUniqueWorker): New workers.\n+\t(SharedPtrMethodsMatcher): New matcher for shared_ptr.\n+\t(register_libstdcxx_xmethods): Register SharedPtrMethodsMatcher.\n+\t* testsuite/libstdc++-xmethods/unique_ptr.cc: Test arrays.\n+\t* testsuite/libstdc++-xmethods/shared_ptr.cc: New test.\n+\n 2016-12-14  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n \n \t* include/bits/stl_tree.h"}, {"sha": "1c9bf3ac0f4cf79812df550015d73ab589be6f97", "filename": "libstdc++-v3/python/libstdcxx/v6/xmethods.py", "status": "modified", "additions": 160, "deletions": 2, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0376e86bfc9cbf1fe7b15be65d4f8e183da6484a/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fxmethods.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0376e86bfc9cbf1fe7b15be65d4f8e183da6484a/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fxmethods.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fxmethods.py?ref=0376e86bfc9cbf1fe7b15be65d4f8e183da6484a", "patch": "@@ -565,15 +565,25 @@ def match(self, class_type, method_name):\n # Xmethods for std::unique_ptr\n \n class UniquePtrGetWorker(gdb.xmethod.XMethodWorker):\n+    \"Implements std::unique_ptr<T>::get() and std::unique_ptr<T>::operator->()\"\n+\n     def __init__(self, elem_type):\n-        self._elem_type = elem_type\n+        self._is_array = elem_type.code == gdb.TYPE_CODE_ARRAY\n+        if self._is_array:\n+            self._elem_type = elem_type.target()\n+        else:\n+            self._elem_type = elem_type\n \n     def get_arg_types(self):\n         return None\n \n     def get_result_type(self, obj):\n         return self._elem_type.pointer()\n \n+    def _supports(self, method_name):\n+        \"operator-> is not supported for unique_ptr<T[]>\"\n+        return method_name == 'get' or not self._is_array\n+\n     def __call__(self, obj):\n         impl_type = obj.dereference().type.fields()[0].type.tag\n         if impl_type.startswith('std::__uniq_ptr_impl<'): # New implementation\n@@ -583,15 +593,40 @@ def __call__(self, obj):\n         return None\n \n class UniquePtrDerefWorker(UniquePtrGetWorker):\n+    \"Implements std::unique_ptr<T>::operator*()\"\n+\n     def __init__(self, elem_type):\n         UniquePtrGetWorker.__init__(self, elem_type)\n \n     def get_result_type(self, obj):\n         return self._elem_type\n \n+    def _supports(self, method_name):\n+        \"operator* is not supported for unique_ptr<T[]>\"\n+        return not self._is_array\n+\n     def __call__(self, obj):\n         return UniquePtrGetWorker.__call__(self, obj).dereference()\n \n+class UniquePtrSubscriptWorker(UniquePtrGetWorker):\n+    \"Implements std::unique_ptr<T>::operator[](size_t)\"\n+\n+    def __init__(self, elem_type):\n+        UniquePtrGetWorker.__init__(self, elem_type)\n+\n+    def get_arg_types(self):\n+        return get_std_size_type()\n+\n+    def get_result_type(self, obj, index):\n+        return self._elem_type\n+\n+    def _supports(self, method_name):\n+        \"operator[] is only supported for unique_ptr<T[]>\"\n+        return self._is_array\n+\n+    def __call__(self, obj, index):\n+        return UniquePtrGetWorker.__call__(self, obj)[index]\n+\n class UniquePtrMethodsMatcher(gdb.xmethod.XMethodMatcher):\n     def __init__(self):\n         gdb.xmethod.XMethodMatcher.__init__(self,\n@@ -600,6 +635,7 @@ def __init__(self):\n             'get': LibStdCxxXMethod('get', UniquePtrGetWorker),\n             'operator->': LibStdCxxXMethod('operator->', UniquePtrGetWorker),\n             'operator*': LibStdCxxXMethod('operator*', UniquePtrDerefWorker),\n+            'operator[]': LibStdCxxXMethod('operator[]', UniquePtrSubscriptWorker),\n         }\n         self.methods = [self._method_dict[m] for m in self._method_dict]\n \n@@ -609,7 +645,128 @@ def match(self, class_type, method_name):\n         method = self._method_dict.get(method_name)\n         if method is None or not method.enabled:\n             return None\n-        return method.worker_class(class_type.template_argument(0))\n+        worker = method.worker_class(class_type.template_argument(0))\n+        if worker._supports(method_name):\n+            return worker\n+        return None\n+\n+# Xmethods for std::shared_ptr\n+\n+class SharedPtrGetWorker(gdb.xmethod.XMethodWorker):\n+    \"Implements std::shared_ptr<T>::get() and std::shared_ptr<T>::operator->()\"\n+\n+    def __init__(self, elem_type):\n+        self._is_array = elem_type.code == gdb.TYPE_CODE_ARRAY\n+        if self._is_array:\n+            self._elem_type = elem_type.target()\n+        else:\n+            self._elem_type = elem_type\n+\n+    def get_arg_types(self):\n+        return None\n+\n+    def get_result_type(self, obj):\n+        return self._elem_type.pointer()\n+\n+    def _supports(self, method_name):\n+        \"operator-> is not supported for shared_ptr<T[]>\"\n+        return method_name == 'get' or not self._is_array\n+\n+    def __call__(self, obj):\n+        return obj['_M_ptr']\n+\n+class SharedPtrDerefWorker(SharedPtrGetWorker):\n+    \"Implements std::shared_ptr<T>::operator*()\"\n+\n+    def __init__(self, elem_type):\n+        SharedPtrGetWorker.__init__(self, elem_type)\n+\n+    def get_result_type(self, obj):\n+        return self._elem_type\n+\n+    def _supports(self, method_name):\n+        \"operator* is not supported for shared_ptr<T[]>\"\n+        return not self._is_array\n+\n+    def __call__(self, obj):\n+        return SharedPtrGetWorker.__call__(self, obj).dereference()\n+\n+class SharedPtrSubscriptWorker(SharedPtrGetWorker):\n+    \"Implements std::shared_ptr<T>::operator[](size_t)\"\n+\n+    def __init__(self, elem_type):\n+        SharedPtrGetWorker.__init__(self, elem_type)\n+\n+    def get_arg_types(self):\n+        return get_std_size_type()\n+\n+    def get_result_type(self, obj, index):\n+        return self._elem_type\n+\n+    def _supports(self, method_name):\n+        \"operator[] is only supported for shared_ptr<T[]>\"\n+        return self._is_array\n+\n+    def __call__(self, obj, index):\n+        # Check bounds if _elem_type is an array of known bound\n+        m = re.match('.*\\[(\\d+)]$', str(self._elem_type))\n+        if m and index >= int(m.group(1)):\n+            raise IndexError('shared_ptr<%s> index \"%d\" should not be >= %d.' %\n+                             (self._elem_type, int(index), int(m.group(1))))\n+        return SharedPtrGetWorker.__call__(self, obj)[index]\n+\n+class SharedPtrUseCountWorker(gdb.xmethod.XMethodWorker):\n+    \"Implements std::shared_ptr<T>::use_count()\"\n+\n+    def __init__(self, elem_type):\n+        SharedPtrUseCountWorker.__init__(self, elem_type)\n+\n+    def get_arg_types(self):\n+        return None\n+\n+    def get_result_type(self, obj):\n+        return gdb.lookup_type('long')\n+\n+    def __call__(self, obj):\n+        refcounts = ['_M_refcount']['_M_pi']\n+        return refcounts['_M_use_count'] if refcounts else 0\n+\n+class SharedPtrUniqueWorker(SharedPtrUseCountWorker):\n+    \"Implements std::shared_ptr<T>::unique()\"\n+\n+    def __init__(self, elem_type):\n+        SharedPtrUseCountWorker.__init__(self, elem_type)\n+\n+    def get_result_type(self, obj):\n+        return gdb.lookup_type('bool')\n+\n+    def __call__(self, obj):\n+        return SharedPtrUseCountWorker.__call__(self, obj) == 1\n+\n+class SharedPtrMethodsMatcher(gdb.xmethod.XMethodMatcher):\n+    def __init__(self):\n+        gdb.xmethod.XMethodMatcher.__init__(self,\n+                                            matcher_name_prefix + 'shared_ptr')\n+        self._method_dict = {\n+            'get': LibStdCxxXMethod('get', SharedPtrGetWorker),\n+            'operator->': LibStdCxxXMethod('operator->', SharedPtrGetWorker),\n+            'operator*': LibStdCxxXMethod('operator*', SharedPtrDerefWorker),\n+            'operator[]': LibStdCxxXMethod('operator[]', SharedPtrSubscriptWorker),\n+            'use_count': LibStdCxxXMethod('use_count', SharedPtrUseCountWorker),\n+            'unique': LibStdCxxXMethod('unique', SharedPtrUniqueWorker),\n+        }\n+        self.methods = [self._method_dict[m] for m in self._method_dict]\n+\n+    def match(self, class_type, method_name):\n+        if not re.match('^std::shared_ptr<.*>$', class_type.tag):\n+            return None\n+        method = self._method_dict.get(method_name)\n+        if method is None or not method.enabled:\n+            return None\n+        worker = method.worker_class(class_type.template_argument(0))\n+        if worker._supports(method_name):\n+            return worker\n+        return None\n \f\n def register_libstdcxx_xmethods(locus):\n     gdb.xmethod.register_xmethod_matcher(locus, ArrayMethodsMatcher())\n@@ -634,3 +791,4 @@ def register_libstdcxx_xmethods(locus):\n     gdb.xmethod.register_xmethod_matcher(\n         locus, AssociativeContainerMethodsMatcher('unordered_multimap'))\n     gdb.xmethod.register_xmethod_matcher(locus, UniquePtrMethodsMatcher())\n+    gdb.xmethod.register_xmethod_matcher(locus, SharedPtrMethodsMatcher())"}, {"sha": "c90dd01d8654dd37489cd59192cba7fcd58ae341", "filename": "libstdc++-v3/testsuite/libstdc++-xmethods/shared_ptr.cc", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0376e86bfc9cbf1fe7b15be65d4f8e183da6484a/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-xmethods%2Fshared_ptr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0376e86bfc9cbf1fe7b15be65d4f8e183da6484a/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-xmethods%2Fshared_ptr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-xmethods%2Fshared_ptr.cc?ref=0376e86bfc9cbf1fe7b15be65d4f8e183da6484a", "patch": "@@ -0,0 +1,72 @@\n+// { dg-do run { target c++11 } }\n+// { dg-options \"-g -O0\" }\n+\n+// Copyright (C) 2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <memory>\n+\n+struct x_struct\n+{\n+  int y;\n+};\n+\n+int\n+main ()\n+{\n+  std::shared_ptr<int> p(new int(10));\n+\n+  std::shared_ptr<x_struct> q(new x_struct{23});\n+\n+  std::shared_ptr<x_struct[]> r(new x_struct[2]{ {46}, {69} });\n+\n+  std::shared_ptr<x_struct[3]> s(new x_struct[2]{ {92}, {115} });\n+\n+// { dg-final { note-test *p 10 } }\n+// { dg-final { regexp-test p.get() 0x.* } }\n+\n+// { dg-final { whatis-test *p int } }\n+// { dg-final { whatis-test p.get() \"int \\*\" } }\n+\n+// { dg-final { note-test *q {\\{y = 23\\}} } }\n+// { dg-final { regexp-test q.get() 0x.* } }\n+// { dg-final { note-test q->y 23 } }\n+\n+// { dg-final { whatis-test *q x_struct } }\n+// { dg-final { whatis-test q.get() \"x_struct \\*\" } }\n+// { dg-final { whatis-test q->y int } }\n+\n+// { dg-final { note-test r\\[1] {\\{y = 69\\}} } }\n+// { dg-final { regexp-test r.get() 0x.* } }\n+// { dg-final { note-test r\\[1].y 69 } }\n+\n+// { dg-final { whatis-test r\\[1] x_struct } }\n+// { dg-final { whatis-test r.get() \"x_struct \\*\" } }\n+// { dg-final { whatis-test r\\[1].y int } }\n+\n+// { dg-final { note-test s\\[1] {\\{y = 115\\}} } }\n+// { dg-final { regexp-test s.get() 0x.* } }\n+// { dg-final { note-test s\\[1].y 115 } }\n+\n+// { dg-final { whatis-test s\\[1] x_struct } }\n+// { dg-final { whatis-test s.get() \"x_struct \\*\" } }\n+// { dg-final { whatis-test s\\[1].y int } }\n+\n+  return 0;  // Mark SPOT\n+}\n+\n+// { dg-final { gdb-test SPOT {} 1 } }"}, {"sha": "5559e2769c9fce10a85d27057cbeb76839ace65a", "filename": "libstdc++-v3/testsuite/libstdc++-xmethods/unique_ptr.cc", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0376e86bfc9cbf1fe7b15be65d4f8e183da6484a/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-xmethods%2Funique_ptr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0376e86bfc9cbf1fe7b15be65d4f8e183da6484a/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-xmethods%2Funique_ptr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-xmethods%2Funique_ptr.cc?ref=0376e86bfc9cbf1fe7b15be65d4f8e183da6484a", "patch": "@@ -28,13 +28,11 @@ struct x_struct\n int\n main ()\n {\n-  int *i = new int;\n-  *i = 10;\n-  std::unique_ptr<int> p(i);\n+  std::unique_ptr<int> p(new int(10));\n \n-  x_struct *x = new x_struct;\n-  x->y = 23;\n-  std::unique_ptr<x_struct> q(x);\n+  std::unique_ptr<x_struct> q(new x_struct{23});\n+\n+  std::unique_ptr<x_struct[]> r(new x_struct[2]{ {46}, {69} });\n \n // { dg-final { note-test *p 10 } }\n // { dg-final { regexp-test p.get() 0x.* } }\n@@ -50,6 +48,15 @@ main ()\n // { dg-final { whatis-test q.get() \"x_struct \\*\" } }\n // { dg-final { whatis-test q->y int } }\n \n+// { dg-final { note-test r\\[1] {\\{y = 69\\}} } }\n+// { dg-final { regexp-test r.get() 0x.* } }\n+// { dg-final { note-test r\\[1].y 69 } }\n+\n+// { dg-final { whatis-test r\\[1] x_struct } }\n+// { dg-final { whatis-test r.get() \"x_struct \\*\" } }\n+// { dg-final { whatis-test r\\[1].y int } }\n+\n+\n   return 0;  // Mark SPOT\n }\n "}]}