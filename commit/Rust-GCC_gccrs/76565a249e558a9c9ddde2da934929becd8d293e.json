{"sha": "76565a249e558a9c9ddde2da934929becd8d293e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzY1NjVhMjQ5ZTU1OGE5YzlkZGRlMmRhOTM0OTI5YmVjZDhkMjkzZQ==", "commit": {"author": {"name": "Stan Cox", "email": "coxs@gnu.org", "date": "1996-06-09T02:13:52Z"}, "committer": {"name": "Stan Cox", "email": "coxs@gnu.org", "date": "1996-06-09T02:13:52Z"}, "message": "i386.h (CONST_COSTS): even integer constants have a cost.\n\nFrom-SVN: r12255", "tree": {"sha": "87b515251459294eb2813c4f7729c2733bea7ef2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87b515251459294eb2813c4f7729c2733bea7ef2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/76565a249e558a9c9ddde2da934929becd8d293e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76565a249e558a9c9ddde2da934929becd8d293e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76565a249e558a9c9ddde2da934929becd8d293e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76565a249e558a9c9ddde2da934929becd8d293e/comments", "author": null, "committer": null, "parents": [{"sha": "2d49677f9c86b2daf35e3cef2e3ff4635fb15dfc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d49677f9c86b2daf35e3cef2e3ff4635fb15dfc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d49677f9c86b2daf35e3cef2e3ff4635fb15dfc"}], "stats": {"total": 55, "additions": 44, "deletions": 11}, "files": [{"sha": "c30b16dd3d1fa04677bb8b4a567f5535a3f5b888", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 44, "deletions": 11, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76565a249e558a9c9ddde2da934929becd8d293e/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76565a249e558a9c9ddde2da934929becd8d293e/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=76565a249e558a9c9ddde2da934929becd8d293e", "patch": "@@ -1804,7 +1804,7 @@ while (0)\n   case CONST:\t\t\t\t\t\t\t\\\n   case LABEL_REF:\t\t\t\t\t\t\\\n   case SYMBOL_REF:\t\t\t\t\t\t\\\n-    return flag_pic && SYMBOLIC_CONST (RTX) ? 2 : 0;\t\t\\\n+    return flag_pic && SYMBOLIC_CONST (RTX) ? 2 : 1;\t\t\\\n \t\t\t\t\t\t\t\t\\\n   case CONST_DOUBLE:\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n@@ -1818,6 +1818,9 @@ while (0)\n \t\t\t 2;\t\t\t\t\t\\\n     }\n \n+/* Delete the definition here when TOPLEVEL_COSTS_N_INSNS gets added to cse.c */\n+#define TOPLEVEL_COSTS_N_INSNS(N) {total = COSTS_N_INSNS (N); break;}\n+\n /* Like `CONST_COSTS' but applies to nonconstant RTL expressions.\n    This can be used, for example, to indicate how costly a multiply\n    instruction is.  In writing this macro, you can use the construct\n@@ -1836,46 +1839,70 @@ while (0)\n \tHOST_WIDE_INT value = INTVAL (XEXP (X, 1));\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n \tif (value == 1)\t\t\t\t\t\t\t\\\n-\t  return COSTS_N_INSNS (ix86_cost->add);\t\t\t\t\\\n+\t  return COSTS_N_INSNS (ix86_cost->add) + rtx_cost(XEXP (X, 0));\\\n \t\t\t\t\t\t\t\t\t\\\n \tif (value == 2 || value == 3)\t\t\t\t\t\\\n-\t  return COSTS_N_INSNS (ix86_cost->lea);\t\t\t\t\\\n+\t  return COSTS_N_INSNS (ix86_cost->lea) + rtx_cost(XEXP (X, 0));\\\n       }\t\t\t\t\t\t\t\t\t\\\n     /* fall through */\t\t\t\t\t\t\t\\\n \t\t  \t\t\t\t\t\t\t\\\n   case ROTATE:\t\t\t\t\t\t\t\t\\\n   case ASHIFTRT:\t\t\t\t\t\t\t\\\n   case LSHIFTRT:\t\t\t\t\t\t\t\\\n   case ROTATERT:\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS ((GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\\\n-\t\t\t\t? ix86_cost->shift_const\t\t\t\\\n-\t\t\t\t: ix86_cost->shift_var);\t\t\t\\\n+    if (GET_MODE (XEXP (X, 0)) == DImode)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tif (GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\t\\\n+\t  if (INTVAL (XEXP (X, 1)) > 32)\t\t\t\t\t\\\n+\t    return COSTS_N_INSNS(ix86_cost->shift_const + 2);\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    return COSTS_N_INSNS(ix86_cost->shift_const * 2);\t\t\\\n+\treturn ((GET_CODE (XEXP (X, 1)) == AND\t\t\t\t\\\n+\t\t ? COSTS_N_INSNS(ix86_cost->shift_var * 2)\t\t\\\n+\t\t : COSTS_N_INSNS(ix86_cost->shift_var * 6 + 2))\t\t\\\n+\t\t+ rtx_cost(XEXP (X, 0)));\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS (GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\\\n+\t\t\t  ? ix86_cost->shift_const\t\t\t\\\n+\t\t\t  : ix86_cost->shift_var)\t\t\t\\\n+      + rtx_cost(XEXP (X, 0));\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   case MULT:\t\t\t\t\t\t\t\t\\\n     if (GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n \tunsigned HOST_WIDE_INT value = INTVAL (XEXP (X, 1));\t\t\\\n \tint nbits = 0;\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n+\tif (value == 2)\t\t\t\t\t\t\t\\\n+\t  return COSTS_N_INSNS (ix86_cost->add) + rtx_cost(XEXP (X, 0));\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tif (value == 4 || value == 8)\t\t\t\t\t\\\n+\t  return COSTS_N_INSNS (ix86_cost->lea) + rtx_cost(XEXP (X, 0));\\\n+\t\t\t\t\t\t\t\t\t\\\n \twhile (value != 0)\t\t\t\t\t\t\\\n \t  {\t\t\t\t\t\t\t\t\\\n \t    nbits++;\t\t\t\t\t\t\t\\\n \t    value >>= 1;\t\t\t\t\t\t\\\n \t  } \t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n+\tif (nbits == 1)\t\t\t\t\t\t\t\\\n+\t  return COSTS_N_INSNS (ix86_cost->shift_const)\t\t\t\\\n+\t    + rtx_cost(XEXP (X, 0));\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n \treturn COSTS_N_INSNS (ix86_cost->mult_init\t\t\t\\\n-\t\t\t      + nbits * ix86_cost->mult_bit);\t\t\\\n+\t\t\t      + nbits * ix86_cost->mult_bit)\t\t\\\n+\t  + rtx_cost(XEXP (X, 0));\t\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n     else\t\t\t/* This is arbitrary */\t\t\t\\\n-      return COSTS_N_INSNS (ix86_cost->mult_init\t\t\t\t\\\n-\t\t\t    + 7 * ix86_cost->mult_bit);\t\t\t\\\n+      TOPLEVEL_COSTS_N_INSNS (ix86_cost->mult_init\t\t\t\\\n+\t\t\t      + 7 * ix86_cost->mult_bit);\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   case DIV:\t\t\t\t\t\t\t\t\\\n   case UDIV:\t\t\t\t\t\t\t\t\\\n   case MOD:\t\t\t\t\t\t\t\t\\\n   case UMOD:\t\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (ix86_cost->divide);\t\t\t\t\\\n+    TOPLEVEL_COSTS_N_INSNS (ix86_cost->divide);\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   case PLUS:\t\t\t\t\t\t\t\t\\\n     if (GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t\\\n@@ -1888,9 +1915,15 @@ while (0)\n   case IOR:\t\t\t\t\t\t\t\t\\\n   case XOR:\t\t\t\t\t\t\t\t\\\n   case MINUS:\t\t\t\t\t\t\t\t\\\n+    if (GET_MODE (X) == DImode)\t\t\t\t\t\t\\\n+      return COSTS_N_INSNS (ix86_cost->add) * 2\t\t\t\t\\\n+\t+ (rtx_cost (XEXP (X, 0)) << (GET_MODE (XEXP (X, 0)) != DImode))\\\n+\t+ (rtx_cost (XEXP (X, 1)) << (GET_MODE (XEXP (X, 1)) != DImode));\\\n   case NEG:\t\t\t\t\t\t\t\t\\\n   case NOT:\t\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (ix86_cost->add);\n+    if (GET_MODE (X) == DImode)\t\t\t\t\t\t\\\n+      TOPLEVEL_COSTS_N_INSNS (ix86_cost->add * 2)\t\t\t\\\n+    TOPLEVEL_COSTS_N_INSNS (ix86_cost->add)\n \n \n /* An expression giving the cost of an addressing mode that contains"}]}