{"sha": "0b4a9743a38af4c0f8483117813d01ae31a7e6d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGI0YTk3NDNhMzhhZjRjMGY4NDgzMTE3ODEzZDAxYWUzMWE3ZTZkNQ==", "commit": {"author": {"name": "Jiong Wang", "email": "jiong.wang@arm.com", "date": "2014-07-23T16:04:39Z"}, "committer": {"name": "Marcus Shawcroft", "email": "mshawcroft@gcc.gnu.org", "date": "2014-07-23T16:04:39Z"}, "message": "[AArch64] Use register offset in cfun->machine->frame.reg_offset\n\nFrom-SVN: r212949", "tree": {"sha": "682d5761458643dce883edc505883c9c06b7d145", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/682d5761458643dce883edc505883c9c06b7d145"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b4a9743a38af4c0f8483117813d01ae31a7e6d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b4a9743a38af4c0f8483117813d01ae31a7e6d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b4a9743a38af4c0f8483117813d01ae31a7e6d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b4a9743a38af4c0f8483117813d01ae31a7e6d5/comments", "author": null, "committer": null, "parents": [{"sha": "106d7513c6ee0c36c2862ac37754332eb9c4593d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/106d7513c6ee0c36c2862ac37754332eb9c4593d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/106d7513c6ee0c36c2862ac37754332eb9c4593d"}], "stats": {"total": 56, "additions": 29, "deletions": 27}, "files": [{"sha": "2b21db2c0bf4b88bf19b2889d54472c078bc40fa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4a9743a38af4c0f8483117813d01ae31a7e6d5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4a9743a38af4c0f8483117813d01ae31a7e6d5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0b4a9743a38af4c0f8483117813d01ae31a7e6d5", "patch": "@@ -1,3 +1,10 @@\n+2014-07-23  Jiong Wang  <jiong.wang@arm.com>\n+\n+\t* config/aarch64/aarch64.c\n+\t(aarch64_save_or_restore_callee_save_registers)\n+\t(aarch64_save_or_restore_fprs): Use register offset in\n+\tcfun->machine->frame.reg_offset.\n+\n 2014-07-23  Jiong Wang  <jiong.wang@arm.com>\n \n \t* config/aarch64/aarch64.c"}, {"sha": "7610cef33c1f8f604267cdc30c641198e2a79a19", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 22, "deletions": 27, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4a9743a38af4c0f8483117813d01ae31a7e6d5/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4a9743a38af4c0f8483117813d01ae31a7e6d5/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=0b4a9743a38af4c0f8483117813d01ae31a7e6d5", "patch": "@@ -1925,10 +1925,11 @@ aarch64_save_or_restore_fprs (HOST_WIDE_INT start_offset, int increment,\n       if (aarch64_register_saved_on_entry (regno))\n \t{\n \t  rtx mem;\n-\t  mem = gen_mem_ref (DFmode,\n-\t\t\t     plus_constant (Pmode,\n-\t\t\t\t\t    stack_pointer_rtx,\n-\t\t\t\t\t    start_offset));\n+\n+\t  HOST_WIDE_INT offset = start_offset\n+\t\t\t\t + cfun->machine->frame.reg_offset[regno];\n+\t  mem = gen_mem_ref (DFmode, plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t\t    offset));\n \n \t  for (regno2 = regno + 1;\n \t       regno2 <= V31_REGNUM\n@@ -1943,12 +1944,10 @@ aarch64_save_or_restore_fprs (HOST_WIDE_INT start_offset, int increment,\n \t    {\n \t      rtx mem2;\n \n-\t      /* Next highest register to be saved.  */\n+\t      offset = start_offset + cfun->machine->frame.reg_offset[regno2];\n \t      mem2 = gen_mem_ref (DFmode,\n-\t\t\t\t  plus_constant\n-\t\t\t\t  (Pmode,\n-\t\t\t\t   stack_pointer_rtx,\n-\t\t\t\t   start_offset + increment));\n+\t\t\t\t  plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t\t offset));\n \t      if (restore == false)\n \t\t{\n \t\t  insn = emit_insn\n@@ -1974,7 +1973,6 @@ aarch64_save_or_restore_fprs (HOST_WIDE_INT start_offset, int increment,\n \t\t frame-related if explicitly marked.  */\n \t      RTX_FRAME_RELATED_P (XVECEXP (PATTERN (insn), 0, 1)) = 1;\n \t      regno = regno2;\n-\t      start_offset += increment * 2;\n \t    }\n \t  else\n \t    {\n@@ -1986,7 +1984,6 @@ aarch64_save_or_restore_fprs (HOST_WIDE_INT start_offset, int increment,\n \t\t  add_reg_note (insn, REG_CFA_RESTORE,\n \t\t\t\tgen_rtx_REG (DFmode, regno));\n \t\t}\n-\t      start_offset += increment;\n \t    }\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n \t}\n@@ -2013,10 +2010,11 @@ aarch64_save_or_restore_callee_save_registers (HOST_WIDE_INT start_offset,\n       if (aarch64_register_saved_on_entry (regno))\n \t{\n \t  rtx mem;\n-\t  mem = gen_mem_ref (Pmode,\n-\t\t\t     plus_constant (Pmode,\n-\t\t\t\t\t    stack_pointer_rtx,\n-\t\t\t\t\t    start_offset));\n+\n+\t  HOST_WIDE_INT offset = start_offset\n+\t\t\t\t + cfun->machine->frame.reg_offset[regno];\n+\t  mem = gen_mem_ref (Pmode, plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t\t   offset));\n \n \t  for (regno2 = regno + 1;\n \t       regno2 <= limit\n@@ -2025,17 +2023,18 @@ aarch64_save_or_restore_callee_save_registers (HOST_WIDE_INT start_offset,\n \t    {\n \t      /* Empty loop.  */\n \t    }\n+\n \t  if (regno2 <= limit\n-\t      && aarch64_register_saved_on_entry (regno2))\n+\t      && aarch64_register_saved_on_entry (regno2)\n+\t      && ((cfun->machine->frame.reg_offset[regno] + UNITS_PER_WORD)\n+\t\t  == cfun->machine->frame.reg_offset[regno2]))\n \t    {\n \t      rtx mem2;\n \n-\t      /* Next highest register to be saved.  */\n+\t      offset = start_offset + cfun->machine->frame.reg_offset[regno2];\n \t      mem2 = gen_mem_ref (Pmode,\n-\t\t\t\t  plus_constant\n-\t\t\t\t  (Pmode,\n-\t\t\t\t   stack_pointer_rtx,\n-\t\t\t\t   start_offset + increment));\n+\t\t\t\t  plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t\t offset));\n \t      if (restore == false)\n \t\t{\n \t\t  insn = emit_insn\n@@ -2061,7 +2060,6 @@ aarch64_save_or_restore_callee_save_registers (HOST_WIDE_INT start_offset,\n \t\t frame-related if explicitly marked.  */\n \t      RTX_FRAME_RELATED_P (XVECEXP (PATTERN (insn), 0, 1)) = 1;\n \t      regno = regno2;\n-\t      start_offset += increment * 2;\n \t    }\n \t  else\n \t    {\n@@ -2073,7 +2071,6 @@ aarch64_save_or_restore_callee_save_registers (HOST_WIDE_INT start_offset,\n \t\t  add_reg_note (insn, REG_CFA_RESTORE,\n \t\t\t\tgen_rtx_REG (DImode, regno));\n \t\t}\n-\t      start_offset += increment;\n \t    }\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n \t}\n@@ -2272,8 +2269,7 @@ aarch64_expand_prologue (void)\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n \t}\n \n-      aarch64_save_or_restore_callee_save_registers\n-\t(fp_offset + cfun->machine->frame.hardfp_offset, 0);\n+      aarch64_save_or_restore_callee_save_registers (fp_offset, 0);\n     }\n \n   /* when offset >= 512,\n@@ -2344,8 +2340,7 @@ aarch64_expand_epilogue (bool for_sibcall)\n       cfa_reg = stack_pointer_rtx;\n     }\n \n-  aarch64_save_or_restore_callee_save_registers\n-    (fp_offset + cfun->machine->frame.hardfp_offset, 1);\n+  aarch64_save_or_restore_callee_save_registers (fp_offset, 1);\n \n   /* Restore the frame pointer and lr if the frame pointer is needed.  */\n   if (offset > 0)"}]}