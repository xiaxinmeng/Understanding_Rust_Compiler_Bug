{"sha": "bf7a697f0ad4399b6ef6abc542520c9be858356e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmY3YTY5N2YwYWQ0Mzk5YjZlZjZhYmM1NDI1MjBjOWJlODU4MzU2ZQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-08-30T21:21:40Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-08-30T21:21:40Z"}, "message": "c-tree.h (C_TYPE_INCOMPLETE_VARS): New macro.\n\n\t* c-tree.h (C_TYPE_INCOMPLETE_VARS): New macro.\n\t* c-decl.c (struct c_scope): Remove \"incomplete\" field.\n\t(pushdecl): Attach variables with incomplete types to\n\tthe TYPE_MAIN_VARIANT of the incomplete type in question.\n\t(finish_struct): Look at C_TYPE_INCOMPLETE_VARS for variables\n\tto complete, not at current_scope->incomplete.  All such\n\tvariables do need completion.\n\nFrom-SVN: r70952", "tree": {"sha": "cdce6115b5f67f736d2426ccd24c4fa2c238f753", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cdce6115b5f67f736d2426ccd24c4fa2c238f753"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf7a697f0ad4399b6ef6abc542520c9be858356e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf7a697f0ad4399b6ef6abc542520c9be858356e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf7a697f0ad4399b6ef6abc542520c9be858356e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf7a697f0ad4399b6ef6abc542520c9be858356e/comments", "author": null, "committer": null, "parents": [{"sha": "496b84c8edb6289c1e9e24c8c69ae2f63d1bcd13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/496b84c8edb6289c1e9e24c8c69ae2f63d1bcd13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/496b84c8edb6289c1e9e24c8c69ae2f63d1bcd13"}], "stats": {"total": 172, "additions": 74, "deletions": 98}, "files": [{"sha": "acec8f5090cef79eb338891870a98a520b2fd1bc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 42, "deletions": 32, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf7a697f0ad4399b6ef6abc542520c9be858356e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf7a697f0ad4399b6ef6abc542520c9be858356e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bf7a697f0ad4399b6ef6abc542520c9be858356e", "patch": "@@ -1,3 +1,13 @@\n+2003-08-30  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* c-tree.h (C_TYPE_INCOMPLETE_VARS): New macro.\n+\t* c-decl.c (struct c_scope): Remove \"incomplete\" field.\n+\t(pushdecl): Attach variables with incomplete types to\n+\tthe TYPE_MAIN_VARIANT of the incomplete type in question.\n+\t(finish_struct): Look at C_TYPE_INCOMPLETE_VARS for variables\n+\tto complete, not at current_scope->incomplete.  All such\n+\tvariables do need completion.\n+\n 2003-08-30  Richard Earnshaw  <rearnsha@arm.com>\n \tNicolas Pitre <nico@cam.org>\n \n@@ -16,20 +26,20 @@\n \tSplit into separate conditionally-compiled units.\n \tUse RETLDM to return from routines.\n \t* arm/ieee754-sf.S: Similarly.\n-\t* t-arm-elf (LIB1ASMFUNCS): Remove _ieee754_dp and _ieee754_sp. \n+\t* t-arm-elf (LIB1ASMFUNCS): Remove _ieee754_dp and _ieee754_sp.\n \tAdd _negdf2 _addsubdf3 _muldivdf3 _cmpdf2 _unorddf2 _fixdfsi\n \t_truncdfsf2 _negsf2 _addsubsf3 _muldivsf3 _cmpsf2 _unordsf2\n \t_fixsfsi and _fixunssfsi.\n \n-\t* arm/ieee754-df.S (__muldf3): Fix bug when result of a \n+\t* arm/ieee754-df.S (__muldf3): Fix bug when result of a\n \tmultiplication underflows to zero.\n-\t(__adddf3): Fix bug when using VFP ordering on little-endian \n+\t(__adddf3): Fix bug when using VFP ordering on little-endian\n \tprocessors.\n \t(__fixdfsi): Use rrx to extract the carry into a register instead of\n \tMRS instruction.  Optimize later use of result.\n \t* arm/ieee754-sf.S (__fixsfsi): Likewise.\n \t(__fixunssfsi): Use a better sequence for handling negative-or-zero.\n-\t\n+\n 2003-08-29  Richard Henderson  <rth@redhat.com>\n \n \t* tree-optimize.c: New file.\n@@ -68,8 +78,8 @@\n \n 2003-08-29  Nathanael Nerode  <neroden@gcc.gnu.org>\n \n-        * config.gcc: Don't use negated character class in shell case\n-        clause.\n+\t* config.gcc: Don't use negated character class in shell case\n+\tclause.\n \n 2003-08-29  Richard Henderson  <rth@redhat.com>\n \n@@ -127,7 +137,7 @@\n \t(fsf-funding.7): Likewise.\n \t($(objdir)/%.info): New pattern rule.\n \t(%.dvi): Likewise.\n-\t\n+\n 2003-08-29  Kelley Cook  <kelleycook@wideopenwest.com>\n \n \t* Makefile.in (restage1): Pass BOOT_CFLAGS to recursive make.\n@@ -186,15 +196,15 @@\n \t* tree.h (tree_index): Add TI_FLOAT_PTR_TYPE, TI_DOUBLE_PTR_TYPE,\n \tTI_LONG_DOUBLE_PTR_TYPE, TI_INTEGER_PTR_TYPE.\n \t(float_ptr_type_node, double_ptr_type_node,\n-\tlong_double_ptr_type_node, integer_ptr_type_node): New type_nodes. \n-\t\n+\tlong_double_ptr_type_node, integer_ptr_type_node): New type_nodes.\n+\n \t* doc/extend.texi: Document new builtins.\n \n 2003-08-28  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* builtin-types.def (BT_FN_FLOAT_INT_FLOAT,\n \tBT_FN_DOUBLE_INT_DOUBLE, BT_FN_LONGDOUBLE_INT_LONGDOUBLE): New.\n-\t\n+\n \t* builtins.def (BUILT_IN_ERF, BUILT_IN_ERFC, BUILT_IN_ERFCF,\n \tBUILT_IN_ERFCL, BUILT_IN_ERFF, BUILT_IN_ERFL, BUILT_IN_GAMMA,\n \tBUILT_IN_GAMMAF, BUILT_IN_GAMMAL, BUILT_IN_J0, BUILT_IN_J0F,\n@@ -205,13 +215,13 @@\n \tBUILT_IN_TGAMMAF, BUILT_IN_TGAMMAL, BUILT_IN_Y0, BUILT_IN_Y0F,\n \tBUILT_IN_Y0L, BUILT_IN_Y1, BUILT_IN_Y1F, BUILT_IN_Y1L,\n \tBUILT_IN_YN, BUILT_IN_YNF, BUILT_IN_YNL): New.\n-\t\n+\n \t* doc/extend.texi: Document new builtins.\n \n 2003-08-28  Nathanael Nerode  <neroden@gcc.gnu.org>\n \n \t* fixinc/mkfixinc.sh: Remove special case code for unsupported\n-\tvariants of i?86, powerpcle, and thumb. \n+\tvariants of i?86, powerpcle, and thumb.\n \t* fixinc/mkfixinc.sh: Remove special case code for unsupported\n \tarm and hppa variants.\n \n@@ -285,13 +295,13 @@\n \t(\"jump\"): Likewise.\n \t(\"call\"): Use BRASL on zSeries machines.\n \t(\"call_value\", \"call_value_tls\"): Likewise.\n-\t(\"brasl\", \"bras\", \"basr_64\", \"basr_31\", \"bas_64\", \"bas_31\"): Remove \n+\t(\"brasl\", \"bras\", \"basr_64\", \"basr_31\", \"bas_64\", \"bas_31\"): Remove\n \tand replace by ...\n \t(\"*bras\", \"*brasl\", \"*basr\") ... these new insns.\n-\t(\"brasl_r\", \"bras_r\", \"basr_64_r\", \"basr_31_r\", \"bas_64_r\", \n+\t(\"brasl_r\", \"bras_r\", \"basr_64_r\", \"basr_31_r\", \"bas_64_r\",\n \t\"bas_31_r\"): Remove and replace by ...\n \t(\"*bras_r\", \"*brasl_r\", \"*basr_r\") ... these new insns.\n-\t(\"brasl_tls\", \"bras_tls\", \"basr_64_tls\", \"basr_31_tls\", \n+\t(\"brasl_tls\", \"bras_tls\", \"basr_64_tls\", \"basr_31_tls\",\n \t\"bas_64_tls\", \"bas_31_tls\"): Remove and replace by ...\n \t(\"*bras_tls\", \"*brasl_tls\", \"*basr_tls\") ... these new insns.\n \t(\"*return_si\", \"*return_di\"): Remove and replace by ...\n@@ -304,11 +314,11 @@\n \t(\"*andsi3_ni\", \"*andhi3_ni\", \"*andqi3_ni\"): Likewise.\n \t(\"*iorsi3_ni\", \"*iorhi3_ni\", \"*iorqi3_ni\"): Likewise.\n \t(\"*extendqisi2\"): Use LB in z/Architecture mode.\n-\t(\"*zero_extendqisi2_64\", \"*zero_extendqisi2_31\"): Use LLGC in \n+\t(\"*zero_extendqisi2_64\", \"*zero_extendqisi2_31\"): Use LLGC in\n \tz/Architecture mode.\n-\t(\"zero_extendqihi2\", \"*zero_extendqihi2_64\", \"*zero_extendqihi2_31\"): \n+\t(\"zero_extendqihi2\", \"*zero_extendqihi2_64\", \"*zero_extendqihi2_31\"):\n \tLikewise.\n-\t\n+\n \t* config/s390/s390.md (\"*tmdi_ext\"): Allow in both 64-bit\n \tand 31-bit mode.\n \t(\"ptr_extend\"): Allow only in 64-bit mode.\n@@ -340,27 +350,27 @@\n \n \t* config/s390/s390.c (struct machine_function): Remove member\n \tliteral_pool_label.\n-\t(s390_optimize_prolog): Replace TEMP_REG argument with \n+\t(s390_optimize_prolog): Replace TEMP_REG argument with\n \tTEMP_USED and BASE_USED.  Do not check get_pool_size ().\n-\t(general_s_operand): Accept all immediates before reload if \n-\tALLOW_IMMEDIATE.  If not ALLOW_IMMEDIATE, reject literal pool \n+\t(general_s_operand): Accept all immediates before reload if\n+\tALLOW_IMMEDIATE.  If not ALLOW_IMMEDIATE, reject literal pool\n \treferences.\n \t(s390_output_symbolic_const): Remove UNSPEC_LTREL_OFFSET handling.\n \t(find_constant_pool_ref): Ignore UNSPECV_POOL_ENTRY insns.\n \t(s390_alloc_pool): New function.\n \t(s390_new_pool): Call it.\n \t(s390_dump_pool): Add REMOTE_LABEL argument.\n-\t(s390_chunkify_start): Add BASE_REG argument.  Do not check \n+\t(s390_chunkify_start): Add BASE_REG argument.  Do not check\n \tget_pool_size ().\n-\t(s390_chunkify_finish): Add BASE_REG argument.  Adapt \n+\t(s390_chunkify_finish): Add BASE_REG argument.  Adapt\n \ts390_dump_pool call.\n \t(s390_pool_count, s390_nr_constants): Remove.\n \t(s390_output_constant_pool): Remove.\n \t(s390_mainpool_start): New function.\n \t(s390_mainpool_finish): New function.\n \t(s390_mainpool_cancel): New function.\n \t(s390_reorg): Implement main literal pool handling.\n-\t(s390_emit_prologue): Emit main_pool placeholder instead of \n+\t(s390_emit_prologue): Emit main_pool placeholder instead of\n \tliteral_pool_31 / literal_pool_64 insns.\n \t* config/s390/s390.h (s390_pool_count, s390_nr_constants): Remove.\n \t(ASM_OUTPUT_POOL_PROLOGUE, ASM_OUTPUT_SPECIAL_POOL_ENTRY): Remove.\n@@ -430,9 +440,9 @@\n \tfrom fixinc.svr4.\n \t* fixinc/inclhack.def (ptx_pwd_h): New disabled fix, ported\n \tfrom fixinc.ptx.\n-        * fixinc/inclhack.def (ptx_sys_mc_param_h): New disabled fix,\n-        ported from fixinc.ptx.\n-\t\n+\t* fixinc/inclhack.def (ptx_sys_mc_param_h): New disabled fix,\n+\tported from fixinc.ptx.\n+\n 2003-08-26  Per Bothner  <pbothner@apple.com>\n \n \t* cpplib.h (struct cpp_token):  Change type of field line to fileline.\n@@ -455,13 +465,13 @@\n 2003-08-26  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* config/s390/s390.c (emit_prologue): Don't check literal pool size.\n-\t* config/s390/s390.h (ASM_OUTPUT_SPECIAL_POOL_ENTRY): Call \n+\t* config/s390/s390.h (ASM_OUTPUT_SPECIAL_POOL_ENTRY): Call\n \ts390_output_pool_entry.\n \n 2003-08-26  Nathanael Nerode  <neroden@gcc.gnu.org>\n \n-\t* fixinc/inclhack.def (svr4_preproc_lint_on, \n-\tsvr4_preproc_lint_off, svr4_preproc_machine): New disabled \n+\t* fixinc/inclhack.def (svr4_preproc_lint_on,\n+\tsvr4_preproc_lint_off, svr4_preproc_machine): New disabled\n \tfixes, ported from fixinc.svr4.\n \n 2003-08-26  Mark Mitchell  <mark@codesourcery.com>\n@@ -502,7 +512,7 @@\n \n 2003-08-26  Andreas Krebbel <krebbel1@de.ibm.com>\n \n-\t* config/s390/s390.md (\"*fmadddf\", \"*fmsubdf\", \n+\t* config/s390/s390.md (\"*fmadddf\", \"*fmsubdf\",\n \t\"*fmaddsf\", \"*fmsubsf\"): New insns.\n \n 2003-08-26  Roger Sayle  <roger@eyesopen.com>\n@@ -532,7 +542,7 @@\n \t(clear_storage_via_libcall): Likewise.\n \t* tree.c (build): Set TREE_SIDE_EFFECTS for non-const, non-pure\n \tCALL_EXPRs.\n-\t\n+\n \t* gcse.c (is_too_expensive): New function.\n \t(gcse_main, delete_null_pointer_checks, bypass_jumps): Use it.\n "}, {"sha": "a346516a9aeb77ade06067cf489487c8b58d65c1", "filename": "gcc/c-decl.c", "status": "modified", "additions": 28, "deletions": 66, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf7a697f0ad4399b6ef6abc542520c9be858356e/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf7a697f0ad4399b6ef6abc542520c9be858356e/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=bf7a697f0ad4399b6ef6abc542520c9be858356e", "patch": "@@ -185,7 +185,7 @@ static int current_extern_inline;\n    the end of the list on each insertion, or reverse the lists later,\n    we maintain a pointer to the last list entry for each of the lists.\n \n-   The order of the tags, shadowed, shadowed_tags, and incomplete\n+   The order of the tags, shadowed, and shadowed_tags\n    lists does not matter, so we just prepend to these lists.  */\n \n struct c_scope GTY(())\n@@ -225,9 +225,6 @@ struct c_scope GTY(())\n   tree blocks;\n   tree blocks_last;\n \n-  /* Variable declarations with incomplete type in this scope.  */\n-  tree incomplete;\n-\n   /* True if we are currently filling this scope with parameter\n      declarations.  */\n   bool parm_flag : 1;\n@@ -1745,26 +1742,30 @@ pushdecl (tree x)\n       IDENTIFIER_SYMBOL_VALUE (name) = x;\n       C_DECL_INVISIBLE (x) = 0;\n \n-      /* Keep list of variables in this scope with incomplete type.\n+      /* If x's type is incomplete because it's based on a\n+\t structure or union which has not yet been fully declared,\n+\t attach it to that structure or union type, so we can go\n+\t back and complete the variable declaration later, if the\n+\t structure or union gets fully declared.\n+\n \t If the input is erroneous, we can have error_mark in the type\n \t slot (e.g. \"f(void a, ...)\") - that doesn't count as an\n-\t incomplete type.\n-\n-\t FIXME: Chain these off the TYPE_DECL for the incomplete type,\n-\t then we don't have to do (potentially quite costly) searches\n-\t in finish_struct.  */\n+\t incomplete type.  */\n       if (TREE_TYPE (x) != error_mark_node\n \t  && !COMPLETE_TYPE_P (TREE_TYPE (x)))\n \t{\n \t  tree element = TREE_TYPE (x);\n \n \t  while (TREE_CODE (element) == ARRAY_TYPE)\n \t    element = TREE_TYPE (element);\n+\t  element = TYPE_MAIN_VARIANT (element);\n+\n \t  if ((TREE_CODE (element) == RECORD_TYPE\n \t       || TREE_CODE (element) == UNION_TYPE)\n \t      && (TREE_CODE (x) != TYPE_DECL\n \t\t  || TREE_CODE (TREE_TYPE (x)) == ARRAY_TYPE))\n-\t    scope->incomplete = tree_cons (NULL_TREE, x, scope->incomplete);\n+\t    C_TYPE_INCOMPLETE_VARS (element)\n+\t      = tree_cons (NULL_TREE, x, C_TYPE_INCOMPLETE_VARS (element));\n \t}\n     }\n \n@@ -5143,63 +5144,24 @@ finish_struct (tree t, tree fieldlist, tree attributes)\n \n   /* If this structure or union completes the type of any previous\n      variable declaration, lay it out and output its rtl.  */\n-\n-  if (current_scope->incomplete != NULL_TREE)\n-    {\n-      tree prev = NULL_TREE;\n-\n-      for (x = current_scope->incomplete; x; x = TREE_CHAIN (x))\n-        {\n-\t  tree decl = TREE_VALUE (x);\n-\n-\t  if (TYPE_MAIN_VARIANT (TREE_TYPE (decl)) == TYPE_MAIN_VARIANT (t)\n-\t      && TREE_CODE (decl) != TYPE_DECL)\n-\t    {\n-\t      layout_decl (decl, 0);\n-\t      /* This is a no-op in c-lang.c or something real in\n-\t\t objc-act.c.  */\n-\t      if (c_dialect_objc ())\n-\t\tobjc_check_decl (decl);\n-\t      rest_of_decl_compilation (decl, NULL, toplevel, 0);\n-\t      if (! toplevel)\n-\t\texpand_decl (decl);\n-\t      /* Unlink X from the incomplete list.  */\n-\t      if (prev)\n-\t\tTREE_CHAIN (prev) = TREE_CHAIN (x);\n-\t      else\n-\t        current_scope->incomplete = TREE_CHAIN (x);\n-\t    }\n-\t  else if (!COMPLETE_TYPE_P (TREE_TYPE (decl))\n-\t\t   && TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n-\t    {\n-\t      tree element = TREE_TYPE (decl);\n-\t      while (TREE_CODE (element) == ARRAY_TYPE)\n-\t\telement = TREE_TYPE (element);\n-\t      if (element == t)\n-\t\t{\n-\t\t  layout_array_type (TREE_TYPE (decl));\n-\t\t  if (TREE_CODE (decl) != TYPE_DECL)\n-\t\t    {\n-\t\t      layout_decl (decl, 0);\n-\t\t      if (c_dialect_objc ())\n-\t\t\tobjc_check_decl (decl);\n-\t\t      rest_of_decl_compilation (decl, NULL, toplevel, 0);\n-\t\t      if (! toplevel)\n-\t\t\texpand_decl (decl);\n-\t\t    }\n-\t\t  /* Unlink X from the incomplete list.  */\n-\t\t  if (prev)\n-\t\t    TREE_CHAIN (prev) = TREE_CHAIN (x);\n-\t\t  else\n-\t\t    current_scope->incomplete = TREE_CHAIN (x);\n-\t\t}\n-\t      else\n-\t\tprev = x;\n-\t    }\n-\t  else\n-\t    prev = x;\n+  for (x = C_TYPE_INCOMPLETE_VARS (TYPE_MAIN_VARIANT (t));\n+       x;\n+       x = TREE_CHAIN (x))\n+    {\n+      tree decl = TREE_VALUE (x);\n+      if (TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n+\tlayout_array_type (TREE_TYPE (decl));\n+      if (TREE_CODE (decl) != TYPE_DECL)\n+\t{\n+\t  layout_decl (decl, 0);\n+\t  if (c_dialect_objc ())\n+\t    objc_check_decl (decl);\n+\t  rest_of_decl_compilation (decl, NULL, toplevel, 0);\n+\t  if (! toplevel)\n+\t    expand_decl (decl);\n \t}\n     }\n+  C_TYPE_INCOMPLETE_VARS (TYPE_MAIN_VARIANT (t)) = 0;\n \n   /* Finish debugging output for this type.  */\n   rest_of_type_compilation (t, toplevel);"}, {"sha": "f692f7314dde9e85c36f2534fae9209c00560912", "filename": "gcc/c-tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf7a697f0ad4399b6ef6abc542520c9be858356e/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf7a697f0ad4399b6ef6abc542520c9be858356e/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=bf7a697f0ad4399b6ef6abc542520c9be858356e", "patch": "@@ -94,6 +94,10 @@ struct lang_decl GTY(())\n    nonzero if the definition of the type has already started.  */\n #define C_TYPE_BEING_DEFINED(TYPE) TYPE_LANG_FLAG_0 (TYPE)\n \n+/* In an incomplete RECORD_TYPE or UNION_TYPE, a list of variable\n+   declarations whose type would be completed by completing that type.  */\n+#define C_TYPE_INCOMPLETE_VARS(TYPE) TYPE_VFIELD (TYPE)\n+\n /* In an IDENTIFIER_NODE, nonzero if this identifier is actually a\n    keyword.  C_RID_CODE (node) is then the RID_* value of the keyword,\n    and C_RID_YYCODE is the token number wanted by Yacc.  */"}]}