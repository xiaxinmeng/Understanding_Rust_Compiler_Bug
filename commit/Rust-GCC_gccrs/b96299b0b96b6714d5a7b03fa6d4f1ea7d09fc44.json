{"sha": "b96299b0b96b6714d5a7b03fa6d4f1ea7d09fc44", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjk2Mjk5YjBiOTZiNjcxNGQ1YTdiMDNmYTZkNGYxZWE3ZDA5ZmM0NA==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-02-08T15:51:54Z"}, "committer": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2021-02-09T09:47:35Z"}, "message": "Fix bad type resolution for CallExpr when fn is not simply PathInExpression\n\nWhen we have a function that is for example a FieldAccessExpression the\ncompiler must resolve and compile that field into a reference which can be\ncalled. This is not simple direct call to a function in that senario.\n\nFixes #217", "tree": {"sha": "ec392cdf34bc5bdd5d9193745c4b0b48a4db8cbb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec392cdf34bc5bdd5d9193745c4b0b48a4db8cbb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b96299b0b96b6714d5a7b03fa6d4f1ea7d09fc44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b96299b0b96b6714d5a7b03fa6d4f1ea7d09fc44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b96299b0b96b6714d5a7b03fa6d4f1ea7d09fc44", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b96299b0b96b6714d5a7b03fa6d4f1ea7d09fc44/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "60cccd8e58f2a024676599cc00971a6e406e6d42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60cccd8e58f2a024676599cc00971a6e406e6d42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60cccd8e58f2a024676599cc00971a6e406e6d42"}], "stats": {"total": 151, "additions": 69, "deletions": 82}, "files": [{"sha": "600b2f9d059b8b52f8c7cf9927a0ca971816724b", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 20, "deletions": 26, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b96299b0b96b6714d5a7b03fa6d4f1ea7d09fc44/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b96299b0b96b6714d5a7b03fa6d4f1ea7d09fc44/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=b96299b0b96b6714d5a7b03fa6d4f1ea7d09fc44", "patch": "@@ -53,33 +53,9 @@ CompileCrate::go ()\n void\n CompileExpr::visit (HIR::CallExpr &expr)\n {\n-  // this can be a function call or it can be a constructor for a tuple struct\n-  Bexpression *fn = ResolvePathRef::Compile (expr.get_fnexpr (), ctx);\n-  if (fn != nullptr)\n+  Btype *type = ResolvePathType::Compile (expr.get_fnexpr (), ctx);\n+  if (type != nullptr)\n     {\n-      std::vector<Bexpression *> args;\n-      expr.iterate_params ([&] (HIR::Expr *p) mutable -> bool {\n-\tBexpression *compiled_expr = CompileExpr::Compile (p, ctx);\n-\trust_assert (compiled_expr != nullptr);\n-\targs.push_back (compiled_expr);\n-\treturn true;\n-      });\n-\n-      auto fncontext = ctx->peek_fn ();\n-      translated\n-\t= ctx->get_backend ()->call_expression (fncontext.fndecl, fn, args,\n-\t\t\t\t\t\tnullptr, expr.get_locus ());\n-    }\n-  else\n-    {\n-      Btype *type = ResolvePathType::Compile (expr.get_fnexpr (), ctx);\n-      if (type == nullptr)\n-\t{\n-\t  rust_fatal_error (expr.get_locus (),\n-\t\t\t    \"failed to lookup type associated with call\");\n-\t  return;\n-\t}\n-\n       // this assumes all fields are in order from type resolution and if a base\n       // struct was specified those fields are filed via accesors\n       std::vector<Bexpression *> vals;\n@@ -93,6 +69,24 @@ CompileExpr::visit (HIR::CallExpr &expr)\n \t= ctx->get_backend ()->constructor_expression (type, vals,\n \t\t\t\t\t\t       expr.get_locus ());\n     }\n+  else\n+    {\n+      // must be a call to a function\n+      Bexpression *fn = CompileExpr::Compile (expr.get_fnexpr (), ctx);\n+\n+      std::vector<Bexpression *> args;\n+      expr.iterate_params ([&] (HIR::Expr *p) mutable -> bool {\n+\tBexpression *compiled_expr = CompileExpr::Compile (p, ctx);\n+\trust_assert (compiled_expr != nullptr);\n+\targs.push_back (compiled_expr);\n+\treturn true;\n+      });\n+\n+      auto fncontext = ctx->peek_fn ();\n+      translated\n+\t= ctx->get_backend ()->call_expression (fncontext.fndecl, fn, args,\n+\t\t\t\t\t\tnullptr, expr.get_locus ());\n+    }\n }\n \n void"}, {"sha": "cb92332059a90f11bc906020fca94ccf117871af", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 31, "deletions": 56, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b96299b0b96b6714d5a7b03fa6d4f1ea7d09fc44/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b96299b0b96b6714d5a7b03fa6d4f1ea7d09fc44/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=b96299b0b96b6714d5a7b03fa6d4f1ea7d09fc44", "patch": "@@ -155,58 +155,11 @@ class TypeCheckExpr : public TypeCheckBase\n \n   void visit (HIR::CallExpr &expr)\n   {\n-    auto fn = expr.get_fnexpr ();\n-    auto fn_node_id = fn->get_mappings ().get_nodeid ();\n-\n-    // then lookup the reference_node_id\n-    NodeId ref_node_id = UNKNOWN_NODEID;\n-    if (resolver->lookup_resolved_name (fn_node_id, &ref_node_id))\n-      {\n-\tDefinition def;\n-\tif (!resolver->lookup_definition (ref_node_id, &def))\n-\t  {\n-\t    rust_error_at (expr.get_locus (),\n-\t\t\t   \"unknown reference for resolved name\");\n-\t    return;\n-\t  }\n-\tref_node_id = def.parent;\n-      }\n-    else if (!resolver->lookup_resolved_type (fn_node_id, &ref_node_id))\n-      {\n-\trust_error_at (expr.get_locus (),\n-\t\t       \"Failed to lookup type reference for node: %s\",\n-\t\t       expr.as_string ().c_str ());\n-\treturn;\n-      }\n-\n-    if (ref_node_id == UNKNOWN_NODEID)\n-      {\n-\trust_error_at (expr.get_locus (), \"unresolved node: %s\",\n-\t\t       expr.as_string ().c_str ());\n-\treturn;\n-      }\n-\n-    // node back to HIR\n-    HirId ref;\n-    if (!mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n-\t\t\t\t       ref_node_id, &ref))\n-      {\n-\trust_error_at (expr.get_locus (), \"reverse lookup failure for node %u\",\n-\t\t       ref_node_id);\n-\treturn;\n-      }\n-\n-    // check if this has a type\n-    TyTy::TyBase *lookup;\n-    if (!context->lookup_type (ref, &lookup))\n-      {\n-\trust_error_at (mappings->lookup_location (ref),\n-\t\t       \"failed to lookup type for CallExpr: %s\",\n-\t\t       expr.as_string ().c_str ());\n-\treturn;\n-      }\n+    TyTy::TyBase *function_tyty = TypeCheckExpr::Resolve (expr.get_fnexpr ());\n+    if (function_tyty == nullptr)\n+      return;\n \n-    infered = TyTy::TypeCheckCallExpr::go (lookup, expr, context);\n+    infered = TyTy::TypeCheckCallExpr::go (function_tyty, expr, context);\n     if (infered == nullptr)\n       {\n \trust_error_at (expr.get_locus (), \"failed to lookup type to CallExpr\");\n@@ -703,6 +656,10 @@ class TypeCheckExpr : public TypeCheckBase\n \n   void visit (HIR::GroupedExpr &expr)\n   {\n+    printf (\"inside grouped expr: \\n%s\\n inside it is: \\n%s\\n\",\n+\t    expr.as_string ().c_str (),\n+\t    expr.get_expr_in_parens ()->as_string ().c_str ());\n+\n     infered = TypeCheckExpr::Resolve (expr.get_expr_in_parens ().get ());\n   }\n \n@@ -738,16 +695,33 @@ class TypeCheckExpr : public TypeCheckBase\n     NodeId ast_node_id = expr.get_mappings ().get_nodeid ();\n \n     // then lookup the reference_node_id\n-    NodeId ref_node_id;\n-    if (!resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n+    NodeId ref_node_id = UNKNOWN_NODEID;\n+    if (resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n       {\n-\tif (!resolver->lookup_resolved_type (ast_node_id, &ref_node_id))\n+\t// these ref_node_ids will resolve to a pattern declaration but we are\n+\t// interested in the definition that this refers to get the parent id\n+\tDefinition def;\n+\tif (!resolver->lookup_definition (ref_node_id, &def))\n \t  {\n \t    rust_error_at (expr.get_locus (),\n-\t\t\t   \"Failed to lookup reference for node: %s\",\n-\t\t\t   expr.as_string ().c_str ());\n+\t\t\t   \"unknown reference for resolved name\");\n \t    return;\n \t  }\n+\tref_node_id = def.parent;\n+      }\n+    else if (!resolver->lookup_resolved_type (ast_node_id, &ref_node_id))\n+      {\n+\trust_error_at (expr.get_locus (),\n+\t\t       \"Failed to lookup type reference for node: %s\",\n+\t\t       expr.as_string ().c_str ());\n+\treturn;\n+      }\n+\n+    if (ref_node_id == UNKNOWN_NODEID)\n+      {\n+\trust_error_at (expr.get_locus (), \"unresolved node: %s\",\n+\t\t       expr.as_string ().c_str ());\n+\treturn;\n       }\n \n     // node back to HIR\n@@ -763,6 +737,7 @@ class TypeCheckExpr : public TypeCheckBase\n       {\n \trust_error_at (expr.get_locus (),\n \t\t       \"failed to resolve PathInExpression type\");\n+\treturn;\n       }\n   }\n "}, {"sha": "32f4728d71c412652ba3cff6d68bbf23d855fcf5", "filename": "gcc/testsuite/rust.test/compilable/function_reference3.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b96299b0b96b6714d5a7b03fa6d4f1ea7d09fc44/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ffunction_reference3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b96299b0b96b6714d5a7b03fa6d4f1ea7d09fc44/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ffunction_reference3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ffunction_reference3.rs?ref=b96299b0b96b6714d5a7b03fa6d4f1ea7d09fc44", "patch": "@@ -0,0 +1,18 @@\n+struct Foo {\n+    a: fn(i32) -> i32,\n+    b: i32,\n+}\n+\n+fn test(a: i32) -> i32 {\n+    a + 1\n+}\n+\n+fn main() {\n+    let a = test(1);\n+\n+    let b: fn(i32) -> i32 = test;\n+    let c = b(1);\n+\n+    let d = Foo { a: test, b: c };\n+    let e = (d.a)(d.b);\n+}"}]}