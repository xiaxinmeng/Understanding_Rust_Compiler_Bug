{"sha": "c253bc8cd89728259ebfc568c287aa085d9b8397", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzI1M2JjOGNkODk3MjgyNTllYmZjNTY4YzI4N2FhMDg1ZDliODM5Nw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2012-07-06T07:44:52Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2012-07-06T07:44:52Z"}, "message": "Revert\n\t2012-06-14  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* dwarf2out.c (function_possibly_abstracted_p): New static function.\n\t(gen_subprogram_die): Use it function_possibly_abstracted_p in lieu of\n\tcgraph_function_possibly_inlined_p.\n\t(gen_inlined_subroutine_die): Return if the origin is to be ignored.\n\t(process_scope_var): Do not emit concrete instances of abstracted\n\tnested functions from here.\n\t(gen_decl_die): Emit the abstract instance if the function is possibly\n\tabstracted and not only possibly inlined.\n\t(dwarf2out_finish): Find the first non-abstract parent instance and\n\tattach concrete instances on the limbo list to it.\n\nFrom-SVN: r189311", "tree": {"sha": "1effe761e2c4255f49d6af3e22094fd5a7456fc7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1effe761e2c4255f49d6af3e22094fd5a7456fc7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c253bc8cd89728259ebfc568c287aa085d9b8397", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c253bc8cd89728259ebfc568c287aa085d9b8397", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c253bc8cd89728259ebfc568c287aa085d9b8397", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c253bc8cd89728259ebfc568c287aa085d9b8397/comments", "author": null, "committer": null, "parents": [{"sha": "39f0c3aacb8f60c629f1f276dbe1228a0281ebf0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39f0c3aacb8f60c629f1f276dbe1228a0281ebf0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39f0c3aacb8f60c629f1f276dbe1228a0281ebf0"}], "stats": {"total": 79, "additions": 25, "deletions": 54}, "files": [{"sha": "40c165306389c0961d2221083669aeb2d7716cf9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c253bc8cd89728259ebfc568c287aa085d9b8397/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c253bc8cd89728259ebfc568c287aa085d9b8397/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c253bc8cd89728259ebfc568c287aa085d9b8397", "patch": "@@ -1,3 +1,19 @@\n+2012-07-06  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tRevert\n+\t2012-06-14  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* dwarf2out.c (function_possibly_abstracted_p): New static function.\n+\t(gen_subprogram_die): Use it function_possibly_abstracted_p in lieu of\n+\tcgraph_function_possibly_inlined_p.\n+\t(gen_inlined_subroutine_die): Return if the origin is to be ignored.\n+\t(process_scope_var): Do not emit concrete instances of abstracted\n+\tnested functions from here.\n+\t(gen_decl_die): Emit the abstract instance if the function is possibly\n+\tabstracted and not only possibly inlined.\n+\t(dwarf2out_finish): Find the first non-abstract parent instance and\n+\tattach concrete instances on the limbo list to it.\n+\n 2012-07-05  Ramana Radhakrishnan  <ramana.radhakrishnan@linaro.org>\n \t    Julian Brown  <julian@codesourcery.com>\n "}, {"sha": "1fc76fe19a6e2c41c275e7782814b5d86b6d0c74", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 9, "deletions": 54, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c253bc8cd89728259ebfc568c287aa085d9b8397/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c253bc8cd89728259ebfc568c287aa085d9b8397/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=c253bc8cd89728259ebfc568c287aa085d9b8397", "patch": "@@ -16825,30 +16825,6 @@ gen_call_site_die (tree decl, dw_die_ref subr_die,\n   return die;\n }\n \n-/* Return true if an abstract instance of function DECL can be generated in\n-   the debug information.  */\n-\n-static bool\n-function_possibly_abstracted_p (tree decl)\n-{\n-  /* An abstract instance of DECL can be generated if DECL can be inlined or\n-     is nested in a function that can be inlined, recursively.  */\n-  while (decl)\n-    {\n-      if (cgraph_function_possibly_inlined_p (decl))\n-\treturn true;\n-      decl = decl_function_context (decl);\n-      /* Do not consider Fortran subroutines as nested in the main program.  */\n-      if (decl\n-\t  && is_fortran ()\n-\t  && !strcmp (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)),\n-\t\t      \"MAIN__\"))\n-        break;\n-    }\n-\n-  return false;\n-}\n-\n /* Generate a DIE to represent a declared function (either file-scope or\n    block-local).  */\n \n@@ -17003,14 +16979,14 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n     {\n       if (DECL_DECLARED_INLINE_P (decl))\n \t{\n-\t  if (function_possibly_abstracted_p (decl))\n+\t  if (cgraph_function_possibly_inlined_p (decl))\n \t    add_AT_unsigned (subr_die, DW_AT_inline, DW_INL_declared_inlined);\n \t  else\n \t    add_AT_unsigned (subr_die, DW_AT_inline, DW_INL_declared_not_inlined);\n \t}\n       else\n \t{\n-\t  if (function_possibly_abstracted_p (decl))\n+\t  if (cgraph_function_possibly_inlined_p (decl))\n \t    add_AT_unsigned (subr_die, DW_AT_inline, DW_INL_inlined);\n \t  else\n \t    add_AT_unsigned (subr_die, DW_AT_inline, DW_INL_not_inlined);\n@@ -17936,8 +17912,6 @@ gen_inlined_subroutine_die (tree stmt, dw_die_ref context_die, int depth)\n   gcc_assert (! BLOCK_ABSTRACT (stmt));\n \n   decl = block_ultimate_origin (stmt);\n-  if (DECL_IGNORED_P (decl))\n-    return;\n \n   /* Emit info for the abstract instance first, if we haven't yet.  We\n      must emit this even if the block is abstract, otherwise when we\n@@ -18882,7 +18856,6 @@ gen_block_die (tree stmt, dw_die_ref context_die, int depth)\n \n /* Process variable DECL (or variable with origin ORIGIN) within\n    block STMT and add it to CONTEXT_DIE.  */\n-\n static void\n process_scope_var (tree stmt, tree decl, tree origin, dw_die_ref context_die)\n {\n@@ -18900,15 +18873,8 @@ process_scope_var (tree stmt, tree decl, tree origin, dw_die_ref context_die)\n   if (die != NULL && die->die_parent == NULL)\n     add_child_die (context_die, die);\n   else if (TREE_CODE (decl_or_origin) == IMPORTED_DECL)\n-    dwarf2out_imported_module_or_decl_1 (decl_or_origin,\n-\t\t\t\t\t DECL_NAME (decl_or_origin),\n+    dwarf2out_imported_module_or_decl_1 (decl_or_origin, DECL_NAME (decl_or_origin),\n \t\t\t\t\t stmt, context_die);\n-  /* Do not emit concrete instances of abstracted nested functions within\n-     concrete instances of parent functions.  */\n-  else if (TREE_CODE (decl_or_origin) == FUNCTION_DECL\n-\t   && die\n-\t   && get_AT (die, DW_AT_inline))\n-    ;\n   else\n     gen_decl_die (decl, origin, context_die);\n }\n@@ -19258,11 +19224,11 @@ gen_decl_die (tree decl, tree origin, dw_die_ref context_die)\n \t\t\t\t     ? DECL_ORIGIN (origin)\n \t\t\t\t     : DECL_ABSTRACT_ORIGIN (decl));\n \n-      /* If we're emitting an out-of-line copy of an abstracted function,\n+      /* If we're emitting an out-of-line copy of an inline function,\n \t emit info for the abstract instance and set up to refer to it.  */\n-      else if (!DECL_ABSTRACT (decl)\n-\t       && function_possibly_abstracted_p (decl)\n-\t       && !class_or_namespace_scope_p (context_die)\n+      else if (cgraph_function_possibly_inlined_p (decl)\n+\t       && ! DECL_ABSTRACT (decl)\n+\t       && ! class_or_namespace_scope_p (context_die)\n \t       /* dwarf2out_abstract_function won't emit a die if this is just\n \t\t  a declaration.  We must avoid setting DECL_ABSTRACT_ORIGIN in\n \t\t  that case, because that works only if we have a die.  */\n@@ -22263,19 +22229,8 @@ dwarf2out_finish (const char *filename)\n \t{\n \t  dw_die_ref origin = get_AT_ref (die, DW_AT_abstract_origin);\n \n-\t  if (origin)\n-\t    {\n-\t      /* Find the first non-abstract parent instance.  */\n-\t      do\n-\t\torigin = origin->die_parent;\n-\t      while (origin\n-\t\t     && (origin->die_tag != DW_TAG_subprogram\n-\t\t\t || get_AT (origin, DW_AT_inline)));\n-\t      if (origin)\n-\t\tadd_child_die (origin, die);\n-\t      else\n-\t\tadd_child_die (comp_unit_die (), die);\n-\t    }\n+\t  if (origin && origin->die_parent)\n+\t    add_child_die (origin->die_parent, die);\n \t  else if (is_cu_die (die))\n \t    ;\n \t  else if (seen_error ())"}]}