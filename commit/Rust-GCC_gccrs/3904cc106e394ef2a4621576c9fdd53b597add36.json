{"sha": "3904cc106e394ef2a4621576c9fdd53b597add36", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzkwNGNjMTA2ZTM5NGVmMmE0NjIxNTc2YzlmZGQ1M2I1OTdhZGQzNg==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@linux.alibaba.com", "date": "2020-01-30T04:33:47Z"}, "committer": {"name": "Bin Cheng", "email": "bin.cheng@linux.alibaba.com", "date": "2020-01-30T04:35:53Z"}, "message": "Use promise in coroutine frame in actor function.\n\nBy standard, coroutine body should be encapsulated in try-catch block\nas following:\n  try {\n    // coroutine body\n  } catch(...) {\n    promise.unhandled_exception();\n  }\nGiven above try-catch block is implemented in the coroutine actor\nfunction called by coroutine ramp function, so the promise should\nbe accessed via actor function's coroutine frame pointer argument,\nrather than the ramp function's coroutine frame variable.\n\nThis patch cleans code a bit to make fix easy.\n\ngcc/cp\n    * coroutines.cc (act_des_fn): New.\n    (morph_fn_to_coro): Call act_des_fn to build actor/destroy decls.\n    Access promise via actor function's frame pointer argument.\n    (build_actor_fn, build_destroy_fn): Use frame pointer argument.", "tree": {"sha": "7753b9740998e68663dc5dbabecd692b61dab80f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7753b9740998e68663dc5dbabecd692b61dab80f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3904cc106e394ef2a4621576c9fdd53b597add36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3904cc106e394ef2a4621576c9fdd53b597add36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3904cc106e394ef2a4621576c9fdd53b597add36", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3904cc106e394ef2a4621576c9fdd53b597add36/comments", "author": null, "committer": null, "parents": [{"sha": "3b35b3d4cc26816d1c6342b880f303b577ecbb84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b35b3d4cc26816d1c6342b880f303b577ecbb84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b35b3d4cc26816d1c6342b880f303b577ecbb84"}], "stats": {"total": 76, "additions": 43, "deletions": 33}, "files": [{"sha": "a402b975ce3bab09e9cfed0781f2fd70fc94333b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3904cc106e394ef2a4621576c9fdd53b597add36/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3904cc106e394ef2a4621576c9fdd53b597add36/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3904cc106e394ef2a4621576c9fdd53b597add36", "patch": "@@ -1,3 +1,10 @@\n+2020-01-30  Bin Cheng  <bin.cheng@linux.alibaba.com>\n+\n+\t* coroutines.cc (act_des_fn): New.\n+\t(morph_fn_to_coro): Call act_des_fn to build actor/destroy decls.\n+\tAccess promise via actor function's frame pointer argument.\n+\t(build_actor_fn, build_destroy_fn): Use frame pointer argument.\n+\n 2020-01-30  Bin Cheng  <bin.cheng@linux.alibaba.com>\n \n \t* coroutines.cc (co_await_expander): Handle type conversion case."}, {"sha": "f7f85cb7643b5b604716e1da800830229a5ff25b", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 36, "deletions": 33, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3904cc106e394ef2a4621576c9fdd53b597add36/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3904cc106e394ef2a4621576c9fdd53b597add36/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=3904cc106e394ef2a4621576c9fdd53b597add36", "patch": "@@ -1828,11 +1828,7 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n   tree act_des_fn_ptr = build_pointer_type (act_des_fn_type);\n \n   /* One param, the coro frame pointer.  */\n-  tree actor_fp\n-    = build_lang_decl (PARM_DECL, get_identifier (\"frame_ptr\"), coro_frame_ptr);\n-  DECL_CONTEXT (actor_fp) = actor;\n-  DECL_ARG_TYPE (actor_fp) = type_passed_as (coro_frame_ptr);\n-  DECL_ARGUMENTS (actor) = actor_fp;\n+  tree actor_fp = DECL_ARGUMENTS (actor);\n \n   /* A void return.  */\n   tree resdecl = build_decl (loc, RESULT_DECL, 0, void_type_node);\n@@ -2219,12 +2215,7 @@ build_destroy_fn (location_t loc, tree coro_frame_type, tree destroy,\n \t\t  tree actor)\n {\n   /* One param, the coro frame pointer.  */\n-  tree coro_frame_ptr = build_pointer_type (coro_frame_type);\n-  tree destr_fp\n-    = build_lang_decl (PARM_DECL, get_identifier (\"frame_ptr\"), coro_frame_ptr);\n-  DECL_CONTEXT (destr_fp) = destroy;\n-  DECL_ARG_TYPE (destr_fp) = type_passed_as (coro_frame_ptr);\n-  DECL_ARGUMENTS (destroy) = destr_fp;\n+  tree destr_fp = DECL_ARGUMENTS (destroy);\n \n   /* A void return.  */\n   tree resdecl = build_decl (loc, RESULT_DECL, 0, void_type_node);\n@@ -2865,6 +2856,24 @@ register_local_var_uses (tree *stmt, int *do_subtree, void *d)\n   return NULL_TREE;\n }\n \n+/* Build, return FUNCTION_DECL node with its coroutine frame pointer argument\n+   for either actor or destroy functions.  */\n+\n+static tree\n+act_des_fn (tree orig, tree fn_type, tree coro_frame_ptr, const char* name)\n+{\n+  tree fn_name = get_fn_local_identifier (orig, name);\n+  tree fn = build_lang_decl (FUNCTION_DECL, fn_name, fn_type);\n+  DECL_CONTEXT (fn) = DECL_CONTEXT (orig);\n+  DECL_INITIAL (fn) = error_mark_node;\n+  tree id = get_identifier (\"frame_ptr\");\n+  tree fp = build_lang_decl (PARM_DECL, id, coro_frame_ptr);\n+  DECL_CONTEXT (fp) = fn;\n+  DECL_ARG_TYPE (fp) = type_passed_as (coro_frame_ptr);\n+  DECL_ARGUMENTS (fn) = fp;\n+  return fn;\n+}\n+\n /* Here we:\n    a) Check that the function and promise type are valid for a\n       coroutine.\n@@ -2991,17 +3000,9 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n     = build_function_type_list (void_type_node, coro_frame_ptr, NULL_TREE);\n   tree act_des_fn_ptr = build_pointer_type (act_des_fn_type);\n \n-  /* Declare the actor function.  */\n-  tree actor_name = get_fn_local_identifier (orig, \"actor\");\n-  tree actor = build_lang_decl (FUNCTION_DECL, actor_name, act_des_fn_type);\n-  DECL_CONTEXT (actor) = DECL_CONTEXT (orig);\n-  DECL_INITIAL (actor) = error_mark_node;\n-\n-  /* Declare the destroyer function.  */\n-  tree destr_name = get_fn_local_identifier (orig, \"destroy\");\n-  tree destroy = build_lang_decl (FUNCTION_DECL, destr_name, act_des_fn_type);\n-  DECL_CONTEXT (destroy) = DECL_CONTEXT (orig);\n-  DECL_INITIAL (destroy) = error_mark_node;\n+  /* Declare the actor and destroyer function.  */\n+  tree actor = act_des_fn (orig, act_des_fn_type, coro_frame_ptr, \"actor\");\n+  tree destroy = act_des_fn (orig, act_des_fn_type, coro_frame_ptr, \"destroy\");\n \n   /* Build our dummy coro frame layout.  */\n   coro_frame_type = begin_class_definition (coro_frame_type);\n@@ -3598,39 +3599,41 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n       tree ueh_meth\n \t= lookup_promise_method (orig, coro_unhandled_exception_identifier,\n \t\t\t\t fn_start, /*musthave=*/true);\n+      /* actor's version of the promise.  */\n+      tree actor_frame = build1_loc (fn_start, INDIRECT_REF, coro_frame_type,\n+\t\t\t\t     DECL_ARGUMENTS (actor));\n+      tree ap_m = lookup_member (coro_frame_type, get_identifier (\"__p\"), 1, 0,\n+\t\t\t\t tf_warning_or_error);\n+      tree ap = build_class_member_access_expr (actor_frame, ap_m, NULL_TREE,\n+\t\t\t\t\t\tfalse, tf_warning_or_error);\n       /* Build promise.unhandled_exception();  */\n       tree ueh\n-\t= build_new_method_call (p, ueh_meth, NULL, NULL_TREE, LOOKUP_NORMAL,\n+\t= build_new_method_call (ap, ueh_meth, NULL, NULL_TREE, LOOKUP_NORMAL,\n \t\t\t\t NULL, tf_warning_or_error);\n \n       /* The try block is just the original function, there's no real\n \t need to call any function to do this.  */\n-      tree tcb = build_stmt (fn_start, TRY_BLOCK, NULL_TREE, NULL_TREE);\n-      TRY_STMTS (tcb) = fnbody;\n-      TRY_HANDLERS (tcb) = push_stmt_list ();\n+      fnbody = build_stmt (fn_start, TRY_BLOCK, fnbody, NULL_TREE);\n+      TRY_HANDLERS (fnbody) = push_stmt_list ();\n       /* Mimic what the parser does for the catch.  */\n       tree handler = begin_handler ();\n       finish_handler_parms (NULL_TREE, handler); /* catch (...) */\n       ueh = maybe_cleanup_point_expr_void (ueh);\n       add_stmt (ueh);\n       finish_handler (handler);\n-      TRY_HANDLERS (tcb) = pop_stmt_list (TRY_HANDLERS (tcb));\n+      TRY_HANDLERS (fnbody) = pop_stmt_list (TRY_HANDLERS (fnbody));\n       /* If the function starts with a BIND_EXPR, then we need to create\n \t one here to contain the try-catch and to link up the scopes.  */\n       if (orig_fn_has_outer_bind)\n \t{\n-\t  tree tcb_bind = build3 (BIND_EXPR, void_type_node, NULL, NULL, NULL);\n+\t  fnbody = build3 (BIND_EXPR, void_type_node, NULL, fnbody, NULL);\n \t  /* Make and connect the scope blocks.  */\n \t  tree tcb_block = make_node (BLOCK);\n \t  /* .. and connect it here.  */\n \t  BLOCK_SUPERCONTEXT (replace_blk) = tcb_block;\n \t  BLOCK_SUBBLOCKS (tcb_block) = replace_blk;\n-\t  BIND_EXPR_BLOCK (tcb_bind) = tcb_block;\n-\t  BIND_EXPR_BODY (tcb_bind) = tcb;\n-\t  fnbody = tcb_bind;\n+\t  BIND_EXPR_BLOCK (fnbody) = tcb_block;\n \t}\n-      else\n-\tfnbody = tcb;\n     }\n   else if (pedantic)\n     {"}]}