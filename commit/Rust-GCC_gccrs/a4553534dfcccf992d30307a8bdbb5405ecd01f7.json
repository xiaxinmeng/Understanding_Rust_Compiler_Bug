{"sha": "a4553534dfcccf992d30307a8bdbb5405ecd01f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQ1NTM1MzRkZmNjY2Y5OTJkMzAzMDdhOGJkYmI1NDA1ZWNkMDFmNw==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2019-02-12T01:09:31Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2019-02-12T01:09:31Z"}, "message": "linemap_line_start: protect against location_t overflow (PR lto/88147)\n\nPR lto/88147 reports an assertion failure due to a bogus location_t value\nwhen adding a line to a pre-existing line map, when there's a large\ndifference between the two line numbers.\n\nFor some \"large differences\", this leads to a location_t value that exceeds\nLINE_MAP_MAX_LOCATION, in which case linemap_line_start returns 0.  This\nisn't ideal, but at least should lead to safe degradation of location\ninformation.\n\nHowever, if the difference is very large, it's possible for the line\nnumber offset (relative to the start of the map) to be sufficiently large\nthat overflow occurs when left-shifted by the column-bits, and hence\nthe check against the LINE_MAP_MAX_LOCATION limit fails, leading to\na seemingly-valid location_t value, but encoding the wrong location.  This\ntriggers the assertion failure:\n  linemap_assert (SOURCE_LINE (map, r) == to_line);\n\nThe fix (thanks to Martin) is to check for overflow when determining\nwhether to reuse an existing map, and to not reuse it if it would occur.\n\ngcc/ChangeLog: David Malcolm  <dmalcolm@redhat.com>\n\tPR lto/88147\n\t* input.c (selftest::test_line_offset_overflow): New selftest.\n\t(selftest::input_c_tests): Call it.\n\nlibcpp/ChangeLog: Martin Liska  <mliska@suse.cz>\n\tPR lto/88147\n\t* line-map.c (linemap_line_start): Don't reuse the existing line\n\tmap if the line offset is sufficiently large to cause overflow\n\twhen computing location_t values.\n\nFrom-SVN: r268789", "tree": {"sha": "f67e59ffd6fb5cf560579cb0ca4c399c581cda40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f67e59ffd6fb5cf560579cb0ca4c399c581cda40"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a4553534dfcccf992d30307a8bdbb5405ecd01f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4553534dfcccf992d30307a8bdbb5405ecd01f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4553534dfcccf992d30307a8bdbb5405ecd01f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4553534dfcccf992d30307a8bdbb5405ecd01f7/comments", "author": null, "committer": null, "parents": [{"sha": "f11bb3106f4232ea2c9a2bc754a7d929879ea746", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f11bb3106f4232ea2c9a2bc754a7d929879ea746", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f11bb3106f4232ea2c9a2bc754a7d929879ea746"}], "stats": {"total": 47, "additions": 47, "deletions": 0}, "files": [{"sha": "33623ada53f5d6ea9893469482727cd6165db747", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4553534dfcccf992d30307a8bdbb5405ecd01f7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4553534dfcccf992d30307a8bdbb5405ecd01f7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a4553534dfcccf992d30307a8bdbb5405ecd01f7", "patch": "@@ -1,3 +1,9 @@\n+2019-02-11  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR lto/88147\n+\t* input.c (selftest::test_line_offset_overflow): New selftest.\n+\t(selftest::input_c_tests): Call it.\n+\n 2019-02-11  Martin Sebor  <msebor@redhat.com>\n \n \tPR tree-optimization/88771"}, {"sha": "c589d70c2bbe6c2edb5de120efbf3ac68323ba9b", "filename": "gcc/input.c", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4553534dfcccf992d30307a8bdbb5405ecd01f7/gcc%2Finput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4553534dfcccf992d30307a8bdbb5405ecd01f7/gcc%2Finput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.c?ref=a4553534dfcccf992d30307a8bdbb5405ecd01f7", "patch": "@@ -3557,6 +3557,34 @@ for_each_line_table_case (void (*testcase) (const line_table_case &))\n   ASSERT_EQ (num_cases_tested, 2 * 12);\n }\n \n+/* Verify that when presented with a consecutive pair of locations with\n+   a very large line offset, we don't attempt to consolidate them into\n+   a single ordinary linemap where the line offsets within the line map\n+   would lead to overflow (PR lto/88147).  */\n+\n+static void\n+test_line_offset_overflow ()\n+{\n+  line_table_test ltt (line_table_case (5, 0));\n+\n+  linemap_add (line_table, LC_ENTER, false, \"foo.c\", 0);\n+  linemap_line_start (line_table, 1, 100);\n+  location_t loc_a = linemap_line_start (line_table, 2578, 255);\n+  assert_loceq (\"foo.c\", 2578, 0, loc_a);\n+\n+  const line_map_ordinary *ordmap_a = LINEMAPS_LAST_ORDINARY_MAP (line_table);\n+  ASSERT_EQ (ordmap_a->m_column_and_range_bits, 13);\n+  ASSERT_EQ (ordmap_a->m_range_bits, 5);\n+\n+  location_t loc_b = linemap_line_start (line_table, 404198, 512);\n+  assert_loceq (\"foo.c\", 404198, 0, loc_b);\n+\n+  /* We should have started a new linemap, rather than attempting to store\n+     a very large line offset.  */\n+  const line_map_ordinary *ordmap_b = LINEMAPS_LAST_ORDINARY_MAP (line_table);\n+  ASSERT_NE (ordmap_a, ordmap_b);\n+}\n+\n /* Run all of the selftests within this file.  */\n \n void\n@@ -3596,6 +3624,8 @@ input_c_tests ()\n   for_each_line_table_case (test_lexer_char_constants);\n \n   test_reading_source_line ();\n+\n+  test_line_offset_overflow ();\n }\n \n } // namespace selftest"}, {"sha": "8af9846d7fba3ec467c0710f88e29a5596d9d05c", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4553534dfcccf992d30307a8bdbb5405ecd01f7/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4553534dfcccf992d30307a8bdbb5405ecd01f7/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=a4553534dfcccf992d30307a8bdbb5405ecd01f7", "patch": "@@ -1,3 +1,10 @@\n+2019-02-11  Martin Liska  <mliska@suse.cz>\n+\n+\tPR lto/88147\n+\t* line-map.c (linemap_line_start): Don't reuse the existing line\n+\tmap if the line offset is sufficiently large to cause overflow\n+\twhen computing location_t values.\n+\n 2019-01-26  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR preprocessor/88974"}, {"sha": "0e30b4b2b391de6725341d38fe71278770b5e56b", "filename": "libcpp/line-map.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4553534dfcccf992d30307a8bdbb5405ecd01f7/libcpp%2Fline-map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4553534dfcccf992d30307a8bdbb5405ecd01f7/libcpp%2Fline-map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fline-map.c?ref=a4553534dfcccf992d30307a8bdbb5405ecd01f7", "patch": "@@ -742,6 +742,10 @@ linemap_line_start (struct line_maps *set, linenum_type to_line,\n       if (line_delta < 0\n \t  || last_line != ORDINARY_MAP_STARTING_LINE_NUMBER (map)\n \t  || SOURCE_COLUMN (map, highest) >= (1U << (column_bits - range_bits))\n+\t  || ( /* We can't reuse the map if the line offset is sufficiently\n+\t\t  large to cause overflow when computing location_t values.  */\n+\t      (to_line - ORDINARY_MAP_STARTING_LINE_NUMBER (map))\n+\t      >= (1U << (CHAR_BIT * sizeof (linenum_type) - column_bits)))\n \t  || range_bits < map->m_range_bits)\n \tmap = linemap_check_ordinary\n \t        (const_cast <line_map *>"}]}