{"sha": "92d38f386bb23d45f15326edac74449064a6429d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTJkMzhmMzg2YmIyM2Q0NWYxNTMyNmVkYWM3NDQ0OTA2NGE2NDI5ZA==", "commit": {"author": {"name": "Florian Weimer", "email": "fweimer@redhat.com", "date": "2012-11-07T09:45:57Z"}, "committer": {"name": "Florian Weimer", "email": "fw@gcc.gnu.org", "date": "2012-11-07T09:45:57Z"}, "message": "init.c (build_new_1): Do not check for arithmetic overflow if inner array size is 1.\n\n\t* init.c (build_new_1): Do not check for arithmetic overflow if\n\tinner array size is 1.\n\n\t* g++.dg/init/new40.C: New.\n\nFrom-SVN: r193287", "tree": {"sha": "712ee66f5a475c777251a49b6a28cdc8f3c3b420", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/712ee66f5a475c777251a49b6a28cdc8f3c3b420"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92d38f386bb23d45f15326edac74449064a6429d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92d38f386bb23d45f15326edac74449064a6429d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92d38f386bb23d45f15326edac74449064a6429d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92d38f386bb23d45f15326edac74449064a6429d/comments", "author": {"login": "fweimer-rh", "id": 75532728, "node_id": "MDQ6VXNlcjc1NTMyNzI4", "avatar_url": "https://avatars.githubusercontent.com/u/75532728?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fweimer-rh", "html_url": "https://github.com/fweimer-rh", "followers_url": "https://api.github.com/users/fweimer-rh/followers", "following_url": "https://api.github.com/users/fweimer-rh/following{/other_user}", "gists_url": "https://api.github.com/users/fweimer-rh/gists{/gist_id}", "starred_url": "https://api.github.com/users/fweimer-rh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fweimer-rh/subscriptions", "organizations_url": "https://api.github.com/users/fweimer-rh/orgs", "repos_url": "https://api.github.com/users/fweimer-rh/repos", "events_url": "https://api.github.com/users/fweimer-rh/events{/privacy}", "received_events_url": "https://api.github.com/users/fweimer-rh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7d57274b36a1aac0e2c38ab1073ce12b29f97ff4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d57274b36a1aac0e2c38ab1073ce12b29f97ff4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d57274b36a1aac0e2c38ab1073ce12b29f97ff4"}], "stats": {"total": 141, "additions": 137, "deletions": 4}, "files": [{"sha": "c623b5e909e490842ecc104ad97c0ced60708a4c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d38f386bb23d45f15326edac74449064a6429d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d38f386bb23d45f15326edac74449064a6429d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=92d38f386bb23d45f15326edac74449064a6429d", "patch": "@@ -1,3 +1,8 @@\n+2012-11-07  Florian Weimer  <fweimer@redhat.com>\n+\n+\t* init.c (build_new_1): Do not check for arithmetic overflow if\n+\tinner array size is 1.\n+\n 2012-11-05  Sriraman Tallam  <tmsriram@google.com>\n \n \t* class.c (add_method): Change assembler names of function versions."}, {"sha": "c842aaca4c693f4fc36bd95f3622f8422371fadd", "filename": "gcc/cp/init.c", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d38f386bb23d45f15326edac74449064a6429d/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d38f386bb23d45f15326edac74449064a6429d/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=92d38f386bb23d45f15326edac74449064a6429d", "patch": "@@ -2185,6 +2185,8 @@ build_new_1 (VEC(tree,gc) **placement, tree type, tree nelts,\n   bool outer_nelts_from_type = false;\n   double_int inner_nelts_count = double_int_one;\n   tree alloc_call, alloc_expr;\n+  /* Size of the inner array elements. */\n+  double_int inner_size;\n   /* The address returned by the call to \"operator new\".  This node is\n      a VAR_DECL and is therefore reusable.  */\n   tree alloc_node;\n@@ -2346,8 +2348,6 @@ build_new_1 (VEC(tree,gc) **placement, tree type, tree nelts,\n       double_int max_size\n \t= double_int_one.llshift (TYPE_PRECISION (sizetype) - 1,\n \t\t\t\t  HOST_BITS_PER_DOUBLE_INT);\n-      /* Size of the inner array elements. */\n-      double_int inner_size;\n       /* Maximum number of outer elements which can be allocated. */\n       double_int max_outer_nelts;\n       tree max_outer_nelts_tree;\n@@ -2451,7 +2451,13 @@ build_new_1 (VEC(tree,gc) **placement, tree type, tree nelts,\n \t  if (array_p && TYPE_VEC_NEW_USES_COOKIE (elt_type))\n \t    size = size_binop (PLUS_EXPR, size, cookie_size);\n \t  else\n-\t    cookie_size = NULL_TREE;\n+\t    {\n+\t      cookie_size = NULL_TREE;\n+\t      /* No size arithmetic necessary, so the size check is\n+\t\t not needed. */\n+\t      if (outer_nelts_check != NULL && inner_size.is_one ())\n+\t\touter_nelts_check = NULL_TREE;\n+\t    }\n \t  /* Perform the overflow check.  */\n \t  if (outer_nelts_check != NULL_TREE)\n             size = fold_build3 (COND_EXPR, sizetype, outer_nelts_check,\n@@ -2487,7 +2493,13 @@ build_new_1 (VEC(tree,gc) **placement, tree type, tree nelts,\n \t  /* Use a global operator new.  */\n \t  /* See if a cookie might be required.  */\n \t  if (!(array_p && TYPE_VEC_NEW_USES_COOKIE (elt_type)))\n-\t    cookie_size = NULL_TREE;\n+\t    {\n+\t      cookie_size = NULL_TREE;\n+\t      /* No size arithmetic necessary, so the size check is\n+\t\t not needed. */\n+\t      if (outer_nelts_check != NULL && inner_size.is_one ())\n+\t\touter_nelts_check = NULL_TREE;\n+\t    }\n \n \t  alloc_call = build_operator_new_call (fnname, placement,\n \t\t\t\t\t\t&size, &cookie_size,"}, {"sha": "5f10e41a877f96831367b184be746f2d14d38c1e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d38f386bb23d45f15326edac74449064a6429d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d38f386bb23d45f15326edac74449064a6429d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=92d38f386bb23d45f15326edac74449064a6429d", "patch": "@@ -1,3 +1,7 @@\n+2012-11-07  Florian Weimer  <fweimer@redhat.com>\n+\n+\t* g++.dg/init/new40.C: New.\n+\n 2012-11-07  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR debug/54693"}, {"sha": "4b283a4454d53cc2b36986259b8b21fbd317ce19", "filename": "gcc/testsuite/g++.dg/init/new40.C", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d38f386bb23d45f15326edac74449064a6429d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew40.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d38f386bb23d45f15326edac74449064a6429d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew40.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew40.C?ref=92d38f386bb23d45f15326edac74449064a6429d", "patch": "@@ -0,0 +1,112 @@\n+// Testcase for overflow handling in operator new[].\n+// Optimization of unnecessary overflow checks.\n+// { dg-do run }\n+\n+#include <assert.h>\n+#include <stdlib.h>\n+#include <stdexcept>\n+\n+static size_t magic_allocation_size\n+  = 1 + (size_t (1) << (sizeof (size_t) * 8 - 1));\n+\n+struct exc : std::bad_alloc {\n+};\n+\n+static size_t expected_size;\n+\n+struct pod_with_new {\n+  char ch;\n+  void *operator new[] (size_t sz)\n+  {\n+    if (sz != expected_size)\n+      abort ();\n+    throw exc ();\n+  }\n+};\n+\n+struct with_new {\n+  char ch;\n+  with_new () { }\n+  ~with_new () { }\n+  void *operator new[] (size_t sz)\n+  {\n+    if (sz != size_t (-1))\n+      abort ();\n+    throw exc ();\n+  }\n+};\n+\n+struct non_pod {\n+  char ch;\n+  non_pod () { }\n+  ~non_pod () { }\n+};\n+\n+void *\n+operator new (size_t sz) _GLIBCXX_THROW (std::bad_alloc)\n+{\n+  if (sz != expected_size)\n+    abort ();\n+  throw exc ();\n+}\n+\n+int\n+main ()\n+{\n+  if (sizeof (pod_with_new) == 1)\n+    expected_size = magic_allocation_size;\n+  else\n+    expected_size = -1;\n+\n+  try {\n+    new pod_with_new[magic_allocation_size];\n+    abort ();\n+  } catch (exc &) {\n+  }\n+\n+  if (sizeof (with_new) == 1)\n+    expected_size = magic_allocation_size;\n+  else\n+    expected_size = -1;\n+\n+  try {\n+    new with_new[magic_allocation_size];\n+    abort ();\n+  } catch (exc &) {\n+  }\n+\n+  expected_size = magic_allocation_size;\n+  try {\n+    new char[magic_allocation_size];\n+    abort ();\n+  } catch (exc &) {\n+  }\n+\n+  expected_size = -1;\n+\n+  try {\n+    new pod_with_new[magic_allocation_size][2];\n+    abort ();\n+  } catch (exc &) {\n+  }\n+\n+  try {\n+    new with_new[magic_allocation_size][2];\n+    abort ();\n+  } catch (exc &) {\n+  }\n+\n+  try {\n+    new char[magic_allocation_size][2];\n+    abort ();\n+  } catch (exc &) {\n+  }\n+\n+  try {\n+    new non_pod[magic_allocation_size];\n+    abort ();\n+  } catch (exc &) {\n+  }\n+\n+  return 0;\n+}"}]}