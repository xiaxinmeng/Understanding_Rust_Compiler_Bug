{"sha": "85f8926ee5b22248d538d46afe3f859a4593346d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODVmODkyNmVlNWIyMjI0OGQ1MzhkNDZhZmUzZjg1OWE0NTkzMzQ2ZA==", "commit": {"author": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1996-10-07T20:25:37Z"}, "committer": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1996-10-07T20:25:37Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r12910", "tree": {"sha": "50922a99a2f136f4a9b9b6545a15d44c41f87935", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/50922a99a2f136f4a9b9b6545a15d44c41f87935"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/85f8926ee5b22248d538d46afe3f859a4593346d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85f8926ee5b22248d538d46afe3f859a4593346d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85f8926ee5b22248d538d46afe3f859a4593346d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85f8926ee5b22248d538d46afe3f859a4593346d/comments", "author": null, "committer": null, "parents": [{"sha": "fcb37f66ba225769fd451325065bceefee1b5f68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcb37f66ba225769fd451325065bceefee1b5f68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fcb37f66ba225769fd451325065bceefee1b5f68"}], "stats": {"total": 111, "additions": 36, "deletions": 75}, "files": [{"sha": "151c45b8bd46395c9b085acd691ed1acaff3570e", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 36, "deletions": 75, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f8926ee5b22248d538d46afe3f859a4593346d/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f8926ee5b22248d538d46afe3f859a4593346d/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=85f8926ee5b22248d538d46afe3f859a4593346d", "patch": "@@ -393,8 +393,8 @@ static inline int type_of_for_scope\tPROTO((tree, tree));\n static void output_pending_types_for_scope PROTO((tree));\n static void output_type\t\t\tPROTO((tree, tree));\n static void output_tagged_type_instantiation PROTO((tree));\n-static void output_block\t\tPROTO((tree));\n-static void output_decls_for_scope\tPROTO((tree));\n+static void output_block\t\tPROTO((tree, int));\n+static void output_decls_for_scope\tPROTO((tree, int));\n static void output_decl\t\t\tPROTO((tree, tree));\n static void shuffle_filename_entry\tPROTO((filename_entry *));\n static void geneate_new_sfname_entry\tPROTO((void));\n@@ -2992,25 +2992,14 @@ type_tag (type)\n       /* Find the IDENTIFIER_NODE for the type name.  */\n       if (TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE)\n \tt = TYPE_NAME (type);\n-#if 0\n-      /* The g++ front end makes the TYPE_NAME of *each* tagged type point\n-\t to a TYPE_DECL node, regardless of whether or not a `typedef' was\n-\t involved.  This is distinctly different from what the gcc front-end\n-\t does.  It always makes the TYPE_NAME for each tagged type be either\n-\t NULL (signifying an anonymous tagged type) or else a pointer to an\n-\t IDENTIFIER_NODE.  Obviously, we would like to generate correct Dwarf\n-\t for both C and C++, but given this inconsistency in the TREE\n-\t representation of tagged types for C and C++ in the GNU front-ends,\n-\t we cannot support both languages correctly unless we introduce some\n-\t front-end specific code here, and rms objects to that, so we can\n-\t only generate correct Dwarf for one of these two languages.  C is\n-\t more important, so for now we'll do the right thing for C and let\n-\t g++ go fish.  */\n \n+      /* The g++ front end makes the TYPE_NAME of *each* tagged type point to \n+         a TYPE_DECL node, regardless of whether or not a `typedef' was\n+         involved.  */\n       else\n \tif (TREE_CODE (TYPE_NAME (type)) == TYPE_DECL)\n \t  t = DECL_NAME (TYPE_NAME (type));\n-#endif\n+\n       /* Now get the name as a string, or invent one.  */\n       if (t != 0)\n \tname = IDENTIFIER_POINTER (t);\n@@ -4142,7 +4131,10 @@ output_type (type, containing_scope)\n \t   type as we are ever going to know, so at that point in time, we\n \t   can safely generate correct Dwarf descriptions for these file-\n \t   scope tagged types.\n-\t*/\n+\n+\t   This loses for C++ nested types that are defined after their\n+\t   containing class, but I don't see a good way to fix it.  I doubt\n+\t   many people will be using DWARF 1 for C++ in any case.  */\n \n \tif (TYPE_SIZE (type) == 0 && TYPE_CONTEXT (type) == NULL && !finalizing)\n \t  return;\t/* EARLY EXIT!  Avoid setting TREE_ASM_WRITTEN.  */\n@@ -4204,30 +4196,14 @@ output_type (type, containing_scope)\n \t    }\n \n \t    {\n-\t      register tree vec_base;\n+\t      register tree func_member;\n \n \t      /* Now output info about the function members (if any).  */\n \n-\t      vec_base = TYPE_METHODS (type);\n-\t      if (vec_base)\n-\t\t{\n-\t\t  register tree first_func_member = TREE_VEC_ELT (vec_base, 0);\n-\t\t  register tree func_member;\n-\n-\t\t  /* This isn't documented, but the first element of the\n-\t\t     vector of member functions can be NULL in cases where\n-\t\t     the class type in question didn't have either a\n-\t\t     constructor or a destructor declared for it.  We have\n-\t\t     to make allowances for that here.  */\n-\n-\t\t  if (first_func_member == NULL)\n-\t\t    first_func_member = TREE_VEC_ELT (vec_base, 1);\n-\n-\t\t  for (func_member = first_func_member;\n-\t\t       func_member;\n-\t\t       func_member = TREE_CHAIN (func_member))\n-\t\t    output_decl (func_member, type);\n-\t\t}\n+\t      for (func_member = TYPE_METHODS (type);\n+\t\t   func_member;\n+\t\t   func_member = TREE_CHAIN (func_member))\n+\t\toutput_decl (func_member, type);\n \t    }\n \n \t    /* RECORD_TYPEs, UNION_TYPEs, and QUAL_UNION_TYPEs are themselves\n@@ -4302,8 +4278,9 @@ output_tagged_type_instantiation (type)\n    the things which are local to the given block.  */\n \n static void\n-output_block (stmt)\n+output_block (stmt, depth)\n     register tree stmt;\n+    int depth;\n {\n   register int must_output_die = 0;\n   register tree origin;\n@@ -4341,7 +4318,7 @@ output_block (stmt)\n \t not represent a \"body block inlining\" before trying to set the\n \t `must_output_die' flag.  */\n \n-      if (origin == NULL || ! is_body_block (origin))\n+      if (! is_body_block (origin ? origin : stmt))\n \t{\n \t  /* Determine if this block directly contains any \"significant\"\n \t     local declarations which we will need to output DIEs for.  */\n@@ -4375,32 +4352,35 @@ output_block (stmt)\n      a \"significant\" local declaration gets restricted to include only\n      inlined function instances and local (nested) function definitions.  */\n \n-  if (must_output_die)\n+  if (origin_code == FUNCTION_DECL && BLOCK_ABSTRACT (stmt))\n+    /* We don't care about an abstract inlined subroutine.  */;\n+  else if (must_output_die)\n     {\n       output_die ((origin_code == FUNCTION_DECL)\n \t\t    ? output_inlined_subroutine_die\n \t\t    : output_lexical_block_die,\n \t\t  stmt);\n-      output_decls_for_scope (stmt);\n+      output_decls_for_scope (stmt, depth);\n       end_sibling_chain ();\n     }\n   else\n-    output_decls_for_scope (stmt);\n+    output_decls_for_scope (stmt, depth);\n }\n \n /* Output all of the decls declared within a given scope (also called\n    a `binding contour') and (recursively) all of it's sub-blocks.  */\n \n static void\n-output_decls_for_scope (stmt)\n+output_decls_for_scope (stmt, depth)\n      register tree stmt;\n+     int depth;\n {\n   /* Ignore blocks never really used to make RTL.  */\n \n   if (! stmt || ! TREE_USED (stmt))\n     return;\n \n-  if (! BLOCK_ABSTRACT (stmt))\n+  if (! BLOCK_ABSTRACT (stmt) && depth > 0)\n     next_block_number++;\n \n   /* Output the DIEs to represent all of the data objects, functions,\n@@ -4425,7 +4405,7 @@ output_decls_for_scope (stmt)\n     for (subblocks = BLOCK_SUBBLOCKS (stmt);\n          subblocks;\n          subblocks = BLOCK_CHAIN (subblocks))\n-      output_block (subblocks);\n+      output_block (subblocks, depth + 1);\n   }\n }\n \n@@ -4639,28 +4619,12 @@ output_decl (decl, containing_scope)\n \t       with a list of the LABEL_DECL nodes for the function however,\n \t       and we output DWARF info for those here.\n \n-\t       Just within the `outer_scope' there will be another BLOCK\n-\t       node representing the function's outermost pair of curly\n-\t       braces.  We mustn't generate a lexical_block DIE for this\n-\t       outermost pair of curly braces because that is not really an\n-\t       independent scope according to ANSI C rules.  Rather, it is\n-\t       the same scope in which the parameters were declared.  */\n+\t       Just within the `outer_scope' there will be a BLOCK node\n+\t       representing the function's outermost pair of curly braces,\n+\t       and any blocks used for the base and member initializers of\n+\t       a C++ constructor function.  */\n \n-\t    {\n-\t      register tree label;\n-\n-\t      for (label = BLOCK_VARS (outer_scope);\n-\t\t   label;\n-\t\t   label = TREE_CHAIN (label))\n-\t\toutput_decl (label, outer_scope);\n-\t    }\n-\n-\t    /* Note here that `BLOCK_SUBBLOCKS (outer_scope)' points to a\n-\t       list of BLOCK nodes which is always only one element long.\n-\t       That one element represents the outermost pair of curley\n-\t       braces for the function body.  */\n-\n-\t    output_decls_for_scope (BLOCK_SUBBLOCKS (outer_scope));\n+\t    output_decls_for_scope (outer_scope, 0);\n \n \t    /* Finally, force out any pending types which are local to the\n \t       outermost block of this function definition.  These will\n@@ -4710,12 +4674,9 @@ output_decl (decl, containing_scope)\n \t TYPE_DECL node for each complete tagged type, each array type,\n \t and each function type node created) the g++ front end generates\n \t a *named* TYPE_DECL node for each tagged type node created.\n-\t Unfortunately, these g++ TYPE_DECL nodes cause us to output many\n-\t superfluous and unnecessary TAG_typedef DIEs here.  When g++ is\n-\t fixed to stop generating these superfluous named TYPE_DECL nodes,\n-\t the superfluous TAG_typedef DIEs will likewise cease.  */\n-\n-      if (DECL_NAME (decl))\n+\t These TYPE_DECLs have DECL_ARTIFICIAL set, so we know not to\n+\t generate a DW_TAG_typedef DIE for them.  */\n+      if (DECL_NAME (decl) && ! DECL_ARTIFICIAL (decl))\n \t/* Output a DIE to represent the typedef itself.  */\n \toutput_die (output_typedef_die, decl);\n       break;\n@@ -4862,7 +4823,7 @@ dwarfout_file_scope_decl (decl, set_finalizing)\n \t the compiler never generates any out-of-lines instances of such\n \t things (despite the fact that they *are* definitions).  The\n \t important point is that the C front-end marks these \"extern inline\"\n-\t functions as DECL_EXTERNAL, but we need to generate DWARf for them\n+\t functions as DECL_EXTERNAL, but we need to generate DWARF for them\n \t anyway.\n \n \t Note that the C++ front-end also plays some similar games for inline"}]}