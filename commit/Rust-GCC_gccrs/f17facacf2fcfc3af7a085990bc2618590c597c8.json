{"sha": "f17facacf2fcfc3af7a085990bc2618590c597c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjE3ZmFjYWNmMmZjZmMzYWY3YTA4NTk5MGJjMjYxODU5MGM1OTdjOA==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2007-01-05T09:08:37Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2007-01-05T09:08:37Z"}, "message": "re PR fortran/29624 (Fortran 2003: Support intent for pointers)\n\nfortran/\n2007-01-05  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/29624\n        * interface.c (compare_parameter_intent): New function.\n          (check_intents): Support pointer intents.\n        * symbol.c (check_conflict): Support pointer intents,\n          better conflict_std message.\n        * expr.c (gfc_check_assign,gfc_check_pointer_assign):\n          Support pointer intents.\n        * resolve.c (resolve_deallocate_expr,resolve_allocate_expr):\n          Support pointer intents.\n\ntestsuite/\n2006-01-05  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/29624\n        * gfortran.dg/alloc_alloc_expr_1.f90: Add check for\n          invalid deallocate.\n        * gfortran.dg/allocatable_dummy_2.f90: Update dg-error.\n        * gfortran.dg/protected_4.f90: Add pointer intent check.\n        * gfortran.dg/protected_6.f90: Add pointer intent check.\n        * gfortran.dg/pointer_intent_1.f90: New test.\n        * gfortran.dg/pointer_intent_2.f90: New test.\n        * gfortran.dg/pointer_intent_3.f90: New test.\n\nFrom-SVN: r120472", "tree": {"sha": "f40639a46b029ee6c2ccfe80b9c03b2f7f2cd3fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f40639a46b029ee6c2ccfe80b9c03b2f7f2cd3fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f17facacf2fcfc3af7a085990bc2618590c597c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f17facacf2fcfc3af7a085990bc2618590c597c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f17facacf2fcfc3af7a085990bc2618590c597c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f17facacf2fcfc3af7a085990bc2618590c597c8/comments", "author": null, "committer": null, "parents": [{"sha": "150f069c1cdecb68a8789151b8b6706eb519d244", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/150f069c1cdecb68a8789151b8b6706eb519d244", "html_url": "https://github.com/Rust-GCC/gccrs/commit/150f069c1cdecb68a8789151b8b6706eb519d244"}], "stats": {"total": 369, "additions": 304, "deletions": 65}, "files": [{"sha": "be3a9b5ebd6077b6f1edbe48886de7bd5ec70826", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f17facacf2fcfc3af7a085990bc2618590c597c8/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f17facacf2fcfc3af7a085990bc2618590c597c8/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=f17facacf2fcfc3af7a085990bc2618590c597c8", "patch": "@@ -1,3 +1,15 @@\n+2007-01-05  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/29624\n+\t* interface.c (compare_parameter_intent): New function.\n+\t  (check_intents): Support pointer intents.\n+\t* symbol.c (check_conflict): Support pointer intents,\n+\t  better conflict_std message.\n+\t* expr.c (gfc_check_assign,gfc_check_pointer_assign):\n+\t  Support pointer intents.\n+\t* resolve.c (resolve_deallocate_expr,resolve_allocate_expr):\n+\t  Support pointer intents.\n+\n 2007-01-03  Brooks Moses  <brooks.moses@codesourcery.com>\n \n \tPR 30371"}, {"sha": "7c2069c340b19193737c270c19470098ea86cf66", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 40, "deletions": 4, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f17facacf2fcfc3af7a085990bc2618590c597c8/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f17facacf2fcfc3af7a085990bc2618590c597c8/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=f17facacf2fcfc3af7a085990bc2618590c597c8", "patch": "@@ -2188,12 +2188,25 @@ try\n gfc_check_assign (gfc_expr * lvalue, gfc_expr * rvalue, int conform)\n {\n   gfc_symbol *sym;\n+  gfc_ref *ref;\n+  int has_pointer;\n \n   sym = lvalue->symtree->n.sym;\n \n-  if (sym->attr.intent == INTENT_IN)\n+  /* Check INTENT(IN), unless the object itself is the component or\n+     sub-component of a pointer.  */\n+  has_pointer = sym->attr.pointer;\n+\n+  for (ref = lvalue->ref; ref; ref = ref->next)\n+    if (ref->type == REF_COMPONENT && ref->u.c.component->pointer)\n+      {\n+\thas_pointer = 1;\n+\tbreak;\n+      }\n+\n+  if (!has_pointer && sym->attr.intent == INTENT_IN)\n     {\n-      gfc_error (\"Can't assign to INTENT(IN) variable '%s' at %L\",\n+      gfc_error (\"Cannot assign to INTENT(IN) variable '%s' at %L\",\n \t\t sym->name, &lvalue->where);\n       return FAILURE;\n     }\n@@ -2318,7 +2331,9 @@ try\n gfc_check_pointer_assign (gfc_expr * lvalue, gfc_expr * rvalue)\n {\n   symbol_attribute attr;\n+  gfc_ref *ref;\n   int is_pure;\n+  int pointer, check_intent_in;\n \n   if (lvalue->symtree->n.sym->ts.type == BT_UNKNOWN)\n     {\n@@ -2336,8 +2351,29 @@ gfc_check_pointer_assign (gfc_expr * lvalue, gfc_expr * rvalue)\n       return FAILURE;\n     }\n \n-  attr = gfc_variable_attr (lvalue, NULL);\n-  if (!attr.pointer)\n+\n+  /* Check INTENT(IN), unless the object itself is the component or\n+     sub-component of a pointer.  */\n+  check_intent_in = 1;\n+  pointer = lvalue->symtree->n.sym->attr.pointer;\n+\n+  for (ref = lvalue->ref; ref; ref = ref->next)\n+    {\n+      if (pointer)\n+        check_intent_in = 0;\n+\n+      if (ref->type == REF_COMPONENT && ref->u.c.component->pointer)\n+        pointer = 1;\n+    }\n+\n+  if (check_intent_in && lvalue->symtree->n.sym->attr.intent == INTENT_IN)\n+    {\n+      gfc_error (\"Cannot assign to INTENT(IN) variable '%s' at %L\",\n+                 lvalue->symtree->n.sym->name, &lvalue->where);\n+      return FAILURE;\n+    }\n+\n+  if (!pointer)\n     {\n       gfc_error (\"Pointer assignment to non-POINTER at %L\", &lvalue->where);\n       return FAILURE;"}, {"sha": "8a1987dc6ec5553c53f6c24aba9427545ab90dad", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f17facacf2fcfc3af7a085990bc2618590c597c8/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f17facacf2fcfc3af7a085990bc2618590c597c8/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=f17facacf2fcfc3af7a085990bc2618590c597c8", "patch": "@@ -1664,14 +1664,35 @@ check_some_aliasing (gfc_formal_arglist * f, gfc_actual_arglist * a)\n }\n \n \n+/* Given a symbol of a formal argument list and an expression,\n+   return non-zero if their intents are compatible, zero otherwise.  */\n+\n+static int\n+compare_parameter_intent (gfc_symbol * formal, gfc_expr * actual)\n+{\n+  if (actual->symtree->n.sym->attr.pointer\n+      && !formal->attr.pointer)\n+    return 1;\n+\n+  if (actual->symtree->n.sym->attr.intent != INTENT_IN)\n+    return 1;\n+\n+  if (formal->attr.intent == INTENT_INOUT\n+      || formal->attr.intent == INTENT_OUT)\n+    return 0;\n+\n+  return 1;\n+}\n+\n+\n /* Given formal and actual argument lists that correspond to one\n    another, check that they are compatible in the sense that intents\n    are not mismatched.  */\n \n static try\n check_intents (gfc_formal_arglist * f, gfc_actual_arglist * a)\n {\n-  sym_intent a_intent, f_intent;\n+  sym_intent f_intent;\n \n   for (;; f = f->next, a = a->next)\n     {\n@@ -1683,12 +1704,9 @@ check_intents (gfc_formal_arglist * f, gfc_actual_arglist * a)\n       if (a->expr == NULL || a->expr->expr_type != EXPR_VARIABLE)\n \tcontinue;\n \n-      a_intent = a->expr->symtree->n.sym->attr.intent;\n       f_intent = f->sym->attr.intent;\n \n-      if (a_intent == INTENT_IN\n-\t  && (f_intent == INTENT_INOUT\n-\t      || f_intent == INTENT_OUT))\n+      if (!compare_parameter_intent(f->sym, a->expr))\n \t{\n \n \t  gfc_error (\"Procedure argument at %L is INTENT(IN) while interface \""}, {"sha": "3c28d452ee43e4633f16d56f3dece8e41a9a635c", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 62, "deletions": 44, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f17facacf2fcfc3af7a085990bc2618590c597c8/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f17facacf2fcfc3af7a085990bc2618590c597c8/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=f17facacf2fcfc3af7a085990bc2618590c597c8", "patch": "@@ -3446,48 +3446,57 @@ static try\n resolve_deallocate_expr (gfc_expr * e)\n {\n   symbol_attribute attr;\n-  int allocatable;\n+  int allocatable, pointer, check_intent_in;\n   gfc_ref *ref;\n \n+  /* Check INTENT(IN), unless the object is a sub-component of a pointer.  */\n+  check_intent_in = 1;\n+\n   if (gfc_resolve_expr (e) == FAILURE)\n     return FAILURE;\n \n-  attr = gfc_expr_attr (e);\n-  if (attr.pointer)\n-    return SUCCESS;\n-\n   if (e->expr_type != EXPR_VARIABLE)\n     goto bad;\n \n   allocatable = e->symtree->n.sym->attr.allocatable;\n+  pointer = e->symtree->n.sym->attr.pointer;\n   for (ref = e->ref; ref; ref = ref->next)\n-    switch (ref->type)\n-      {\n-      case REF_ARRAY:\n-\tif (ref->u.ar.type != AR_FULL)\n-\t  allocatable = 0;\n-\tbreak;\n+    {\n+      if (pointer)\n+        check_intent_in = 0;\n \n-      case REF_COMPONENT:\n-\tallocatable = (ref->u.c.component->as != NULL\n-\t\t       && ref->u.c.component->as->type == AS_DEFERRED);\n-\tbreak;\n+      switch (ref->type)\n+        {\n+        case REF_ARRAY:\n+\t  if (ref->u.ar.type != AR_FULL)\n+\t    allocatable = 0;\n+\t  break;\n \n-      case REF_SUBSTRING:\n-\tallocatable = 0;\n-\tbreak;\n-      }\n+        case REF_COMPONENT:\n+\t  allocatable = (ref->u.c.component->as != NULL\n+\t\t         && ref->u.c.component->as->type == AS_DEFERRED);\n+\t  pointer = ref->u.c.component->pointer;\n+\t  break;\n \n-  if (allocatable == 0)\n+        case REF_SUBSTRING:\n+\t  allocatable = 0;\n+\t  break;\n+        }\n+    }\n+\n+  attr = gfc_expr_attr (e);\n+\n+  if (allocatable == 0 && attr.pointer == 0)\n     {\n     bad:\n       gfc_error (\"Expression in DEALLOCATE statement at %L must be \"\n \t\t \"ALLOCATABLE or a POINTER\", &e->where);\n     }\n \n-  if (e->symtree->n.sym->attr.intent == INTENT_IN)\n+  if (check_intent_in\n+      && e->symtree->n.sym->attr.intent == INTENT_IN)\n     {\n-      gfc_error (\"Can't deallocate INTENT(IN) variable '%s' at %L\",\n+      gfc_error (\"Cannot deallocate INTENT(IN) variable '%s' at %L\",\n                  e->symtree->n.sym->name, &e->where);\n       return FAILURE;\n     }\n@@ -3609,7 +3618,7 @@ expr_to_initialize (gfc_expr * e)\n static try\n resolve_allocate_expr (gfc_expr * e, gfc_code * code)\n {\n-  int i, pointer, allocatable, dimension;\n+  int i, pointer, allocatable, dimension, check_intent_in;\n   symbol_attribute attr;\n   gfc_ref *ref, *ref2;\n   gfc_array_ref *ar;\n@@ -3618,6 +3627,9 @@ resolve_allocate_expr (gfc_expr * e, gfc_code * code)\n   gfc_symbol *sym;\n   gfc_alloc *a;\n \n+  /* Check INTENT(IN), unless the object is a sub-component of a pointer.  */\n+  check_intent_in = 1;\n+\n   if (gfc_resolve_expr (e) == FAILURE)\n     return FAILURE;\n \n@@ -3655,26 +3667,31 @@ resolve_allocate_expr (gfc_expr * e, gfc_code * code)\n \t}\n \n       for (ref = e->ref; ref; ref2 = ref, ref = ref->next)\n-\tswitch (ref->type)\n-\t  {\n-\t  case REF_ARRAY:\n-\t    if (ref->next != NULL)\n-\t      pointer = 0;\n-\t    break;\n-\n-\t  case REF_COMPONENT:\n-\t    allocatable = (ref->u.c.component->as != NULL\n-\t\t\t   && ref->u.c.component->as->type == AS_DEFERRED);\n-\n-\t    pointer = ref->u.c.component->pointer;\n-\t    dimension = ref->u.c.component->dimension;\n-\t    break;\n+        {\n+\t  if (pointer)\n+\t    check_intent_in = 0;\n \n-\t  case REF_SUBSTRING:\n-\t    allocatable = 0;\n-\t    pointer = 0;\n-\t    break;\n-\t  }\n+\t  switch (ref->type)\n+\t    {\n+ \t      case REF_ARRAY:\n+\t        if (ref->next != NULL)\n+\t          pointer = 0;\n+\t        break;\n+\n+\t      case REF_COMPONENT:\n+\t        allocatable = (ref->u.c.component->as != NULL\n+\t\t\t      && ref->u.c.component->as->type == AS_DEFERRED);\n+\n+\t        pointer = ref->u.c.component->pointer;\n+\t        dimension = ref->u.c.component->dimension;\n+\t        break;\n+\n+\t      case REF_SUBSTRING:\n+\t        allocatable = 0;\n+\t        pointer = 0;\n+\t        break;\n+\t    }\n+       }\n     }\n \n   if (allocatable == 0 && pointer == 0)\n@@ -3684,9 +3701,10 @@ resolve_allocate_expr (gfc_expr * e, gfc_code * code)\n       return FAILURE;\n     }\n \n-  if (e->symtree->n.sym->attr.intent == INTENT_IN)\n+  if (check_intent_in\n+      && e->symtree->n.sym->attr.intent == INTENT_IN)\n     {\n-      gfc_error (\"Can't allocate INTENT(IN) variable '%s' at %L\",\n+      gfc_error (\"Cannot allocate INTENT(IN) variable '%s' at %L\",\n                  e->symtree->n.sym->name, &e->where);\n       return FAILURE;\n     }"}, {"sha": "a1aaae8fddff02e17d816da548e675bbbedfe49d", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f17facacf2fcfc3af7a085990bc2618590c597c8/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f17facacf2fcfc3af7a085990bc2618590c597c8/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=f17facacf2fcfc3af7a085990bc2618590c597c8", "patch": "@@ -288,7 +288,8 @@ check_conflict (symbol_attribute * attr, const char * name, locus * where)\n     {\n       a1 = pointer;\n       a2 = intent;\n-      goto conflict;\n+      standard = GFC_STD_F2003;\n+      goto conflict_std;\n     }\n \n   /* Check for attributes not allowed in a BLOCK DATA.  */\n@@ -571,14 +572,14 @@ check_conflict (symbol_attribute * attr, const char * name, locus * where)\n conflict_std:\n   if (name == NULL)\n     {\n-      return gfc_notify_std (standard, \"In the selected standard, %s attribute \"\n+      return gfc_notify_std (standard, \"Fortran 2003: %s attribute \"\n                              \"conflicts with %s attribute at %L\", a1, a2,\n                              where);\n     }\n   else\n     {\n-      return gfc_notify_std (standard, \"In the selected standard, %s attribute \"\n-                             \"conflicts with %s attribute in '%s' at %L\",\n+      return gfc_notify_std (standard, \"Fortran 2003: %s attribute \"\n+\t\t\t     \"with %s attribute in '%s' at %L\",\n                              a1, a2, name, where);\n     }\n }"}, {"sha": "aae1b7a35bbc0d0067f2932975fca1ab28d81893", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f17facacf2fcfc3af7a085990bc2618590c597c8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f17facacf2fcfc3af7a085990bc2618590c597c8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f17facacf2fcfc3af7a085990bc2618590c597c8", "patch": "@@ -1,4 +1,16 @@\n-2006-01-04  Brooks Moses  <brooks.moses@codesourcery.com>\n+2006-01-05  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/29624\n+\t* gfortran.dg/alloc_alloc_expr_1.f90: Add check for\n+\t  invalid deallocate.\n+\t* gfortran.dg/allocatable_dummy_2.f90: Update dg-error.\n+\t* gfortran.dg/protected_4.f90: Add pointer intent check.\n+\t* gfortran.dg/protected_6.f90: Add pointer intent check.\n+\t* gfortran.dg/pointer_intent_1.f90: New test.\n+\t* gfortran.dg/pointer_intent_2.f90: New test.\n+\t* gfortran.dg/pointer_intent_3.f90: New test.\n+\n+2007-01-04  Brooks Moses  <brooks.moses@codesourcery.com>\n \n \tPR 30235\n \t* gfortran.dg/altreturn_2.f90: new test."}, {"sha": "5545b0dce6c5491000405fcee96a155aa38ccbaa", "filename": "gcc/testsuite/gfortran.dg/alloc_alloc_expr_1.f90", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f17facacf2fcfc3af7a085990bc2618590c597c8/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_alloc_expr_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f17facacf2fcfc3af7a085990bc2618590c597c8/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_alloc_expr_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_alloc_expr_1.f90?ref=f17facacf2fcfc3af7a085990bc2618590c597c8", "patch": "@@ -24,6 +24,8 @@ program fc011\n \n   ALLOCATE(PTR,ALLOCS(PTR)) ! { dg-error \"same ALLOCATE statement\" }\n \n-  print *, 'This program has three errors', PTR, ALLOC(1)\n+  deallocate(ALLOCS(1)) ! { dg-error \"must be ALLOCATABLE or a POINTER\" }\n+\n+  print *, 'This program has four errors', PTR, ALLOC(1)\n \n end program fc011"}, {"sha": "c33ad13b8c57c3668d2d3c2d3db5786c45158939", "filename": "gcc/testsuite/gfortran.dg/allocatable_dummy_2.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f17facacf2fcfc3af7a085990bc2618590c597c8/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocatable_dummy_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f17facacf2fcfc3af7a085990bc2618590c597c8/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocatable_dummy_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocatable_dummy_2.f90?ref=f17facacf2fcfc3af7a085990bc2618590c597c8", "patch": "@@ -16,13 +16,13 @@ end subroutine init\n     subroutine init2(x)\n         integer, allocatable, intent(in) :: x(:)\n \n-        allocate(x(3)) ! { dg-error \"Can't allocate\" }\n+        allocate(x(3)) ! { dg-error \"Cannot allocate\" }\n     end subroutine init2\n \n     subroutine kill(x)\n         integer, allocatable, intent(in) :: x(:)\n         \n-        deallocate(x) ! { dg-error \"Can't deallocate\" }\n+        deallocate(x) ! { dg-error \"Cannot deallocate\" }\n     end subroutine kill\n \n end program alloc_dummy"}, {"sha": "882c6a5f9030690cd27726e61e4ad7adc6ae181b", "filename": "gcc/testsuite/gfortran.dg/pointer_intent_1.f90", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f17facacf2fcfc3af7a085990bc2618590c597c8/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_intent_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f17facacf2fcfc3af7a085990bc2618590c597c8/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_intent_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_intent_1.f90?ref=f17facacf2fcfc3af7a085990bc2618590c597c8", "patch": "@@ -0,0 +1,71 @@\n+! { dg-run }\n+! { dg-options \"-std=f2003 -fall-intrinsics\" }\n+! Pointer intent test\n+! PR fortran/29624\n+!\n+! Valid program\n+program test\n+ implicit none\n+ type myT\n+   integer          :: x\n+   integer, pointer :: point\n+ end type myT\n+ integer, pointer :: p\n+ type(myT), pointer :: t\n+ type(myT) :: t2\n+ allocate(p,t)\n+ allocate(t%point)\n+ t%point = 55\n+ p = 33\n+ call a(p,t)\n+ deallocate(p)\n+ nullify(p)\n+ call a(p,t)\n+ call nonpointer(t2)\n+contains\n+  subroutine a(p,t)\n+    integer, pointer,intent(in)    :: p\n+    type(myT), pointer, intent(in) :: t\n+    integer, pointer :: tmp\n+    if(.not.associated(p)) return\n+    if(p /= 33) call abort()\n+    p = 7\n+    if (associated(t)) then\n+      ! allocating is valid as we don't change the status\n+      ! of the pointer \"t\", only of it's target\n+      t%x = -15\n+      if(.not.associated(t%point)) call abort()\n+      if(t%point /= 55) call abort()\n+      nullify(t%point)\n+      allocate(tmp)\n+      t%point => tmp\n+      deallocate(t%point)\n+      t%point => null(t%point)\n+      tmp => null(tmp)\n+      allocate(t%point)\n+      t%point = 27\n+      if(t%point /= 27) call abort()\n+      if(t%x     /= -15) call abort()\n+      call foo(t)\n+      if(t%x     /=  32) call abort()\n+      if(t%point /= -98) call abort()\n+    end if\n+    call b(p)\n+    if(p /= 5) call abort()\n+  end subroutine\n+  subroutine b(v)\n+    integer, intent(out) :: v\n+    v = 5\n+  end subroutine b\n+  subroutine foo(comp)\n+    type(myT), intent(inout) :: comp\n+    if(comp%x     /= -15) call abort()\n+    !if(comp%point /=  27) call abort()\n+    comp%x     = 32\n+    comp%point = -98\n+  end subroutine foo\n+  subroutine nonpointer(t)\n+     type(myT), intent(in) :: t\n+     t%point = 7\n+  end subroutine nonpointer\n+end program"}, {"sha": "247016bdab09ae3f234dd9470e779104a7d893c9", "filename": "gcc/testsuite/gfortran.dg/pointer_intent_2.f90", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f17facacf2fcfc3af7a085990bc2618590c597c8/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_intent_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f17facacf2fcfc3af7a085990bc2618590c597c8/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_intent_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_intent_2.f90?ref=f17facacf2fcfc3af7a085990bc2618590c597c8", "patch": "@@ -0,0 +1,19 @@\n+! { dg-compile }\n+! { dg-options \"-std=f95\" }\n+! { dg-shouldfail \"Fortran 2003 feature with -std=f95\" }\n+!\n+! Pointer intent test\n+! PR fortran/29624\n+!\n+! Fortran 2003 features in Fortran 95\n+program test\n+ implicit none\n+ integer, pointer :: p\n+ allocate(p)\n+ p = 33\n+ call a(p) ! { dg-error \"Type/rank mismatch in argument\" }\n+contains\n+  subroutine a(p)! { dg-error \"has no IMPLICIT type\" }\n+    integer, pointer,intent(in) :: p ! { dg-error \"POINTER attribute with INTENT attribute\" }\n+  end subroutine\n+end program"}, {"sha": "e7ce590b11743060bdae695a1a411635158af196", "filename": "gcc/testsuite/gfortran.dg/pointer_intent_3.f90", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f17facacf2fcfc3af7a085990bc2618590c597c8/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_intent_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f17facacf2fcfc3af7a085990bc2618590c597c8/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_intent_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_intent_3.f90?ref=f17facacf2fcfc3af7a085990bc2618590c597c8", "patch": "@@ -0,0 +1,41 @@\n+! { dg-compile }\n+! { dg-options \"-std=f2003 -fall-intrinsics\" }\n+! { dg-shouldfail \"Invalid code\" }\n+!\n+! Pointer intent test\n+! PR fortran/29624\n+!\n+! Valid program\n+program test\n+ implicit none\n+ type myT\n+    integer :: j = 5\n+    integer, pointer :: jp => null()\n+ end type myT\n+ integer, pointer :: p\n+ type(myT) :: t\n+ call a(p)\n+ call b(t)\n+contains\n+  subroutine a(p)\n+    integer, pointer,intent(in) :: p\n+    p => null(p)! { dg-error \"Cannot assign to INTENT\\\\(IN\\\\) variable\" }\n+    nullify(p)  ! { dg-error \"Cannot assign to INTENT\\\\(IN\\\\) variable\" }\n+    allocate(p) ! { dg-error \"Cannot allocate INTENT\\\\(IN\\\\) variable\" }\n+    call c(p)   ! { dg-error \"is INTENT\\\\(IN\\\\) while interface specifies INTENT\\\\(INOUT\\\\)\" }\n+    deallocate(p) ! { dg-error \"Cannot deallocate INTENT\\\\(IN\\\\) variable\" }\n+  end subroutine\n+  subroutine c(p)\n+    integer, pointer, intent(inout) :: p\n+    nullify(p)\n+  end subroutine c\n+  subroutine b(t)\n+    type(myT),intent(in) :: t\n+    t%jp = 5\n+    t%jp => null(t%jp)  ! { dg-error \"Cannot assign to INTENT\\\\(IN\\\\) variable\" }\n+    nullify(t%jp) ! { dg-error \"Cannot assign to INTENT\\\\(IN\\\\) variable\" }\n+    t%j = 7 ! { dg-error \"Cannot assign to INTENT\\\\(IN\\\\) variable\" }\n+    allocate(t%jp) ! { dg-error \"Cannot allocate INTENT\\\\(IN\\\\) variable\" }\n+    deallocate(t%jp) ! { dg-error \"Cannot deallocate INTENT\\\\(IN\\\\) variable\" }\n+  end subroutine b\n+end program"}, {"sha": "7d2238e2ffd36ed210969362b253a50979f19bf8", "filename": "gcc/testsuite/gfortran.dg/protected_4.f90", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f17facacf2fcfc3af7a085990bc2618590c597c8/gcc%2Ftestsuite%2Fgfortran.dg%2Fprotected_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f17facacf2fcfc3af7a085990bc2618590c597c8/gcc%2Ftestsuite%2Fgfortran.dg%2Fprotected_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fprotected_4.f90?ref=f17facacf2fcfc3af7a085990bc2618590c597c8", "patch": "@@ -21,6 +21,7 @@ program main\n   use protmod\n   implicit none\n   integer   :: j \n+  logical   :: asgnd\n   protected :: j ! { dg-error \"only allowed in specification part of a module\" }\n   a = 43       ! { dg-error \"Assigning to PROTECTED variable\" }\n   ap => null() ! { dg-error \"Assigning to PROTECTED variable\" }\n@@ -30,16 +31,23 @@ program main\n   allocate(ap) ! { dg-error \"Assigning to PROTECTED variable\" }\n   ap = 73      ! { dg-error \"Assigning to PROTECTED variable\" }\n   call increment(a,at) ! { dg-error \"use-associated with PROTECTED attribute\" }\n+  call pointer_assignments(ap) ! { dg-error \"is use-associated with PROTECTED attribute\" }\n+  asgnd = pointer_check(ap)\n contains\n   subroutine increment(a1,a3)\n     integer, intent(inout) :: a1, a3\n     a1 = a1 + 1\n     a3 = a3 + 1\n   end subroutine increment\n   subroutine pointer_assignments(p)\n-    integer, pointer :: p ! with [pointer] intent(out)\n-    p => null()           ! this is invalid\n+    integer, pointer,intent(out) :: p\n+    p => null()           \n   end subroutine pointer_assignments\n+  function pointer_check(p)\n+    integer, pointer,intent(in) :: p\n+    logical :: pointer_check\n+    pointer_check = associated(p)\n+  end function pointer_check\n end program main\n \n module test"}, {"sha": "5b71f8ba5744aea0c2edec5da9251be7ca4dcad8", "filename": "gcc/testsuite/gfortran.dg/protected_6.f90", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f17facacf2fcfc3af7a085990bc2618590c597c8/gcc%2Ftestsuite%2Fgfortran.dg%2Fprotected_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f17facacf2fcfc3af7a085990bc2618590c597c8/gcc%2Ftestsuite%2Fgfortran.dg%2Fprotected_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fprotected_6.f90?ref=f17facacf2fcfc3af7a085990bc2618590c597c8", "patch": "@@ -27,15 +27,16 @@ program main\n   allocate(ap) ! { dg-error \"Assigning to PROTECTED variable\" }\n   ap = 73      ! { dg-error \"Assigning to PROTECTED variable\" }\n   call increment(a,at) ! { dg-error \"use-associated with PROTECTED attribute\" }\n+  call pointer_assignments(ap) ! { dg-error \"is use-associated with PROTECTED attribute\" }\n contains\n   subroutine increment(a1,a3)\n     integer, intent(inout) :: a1, a3\n     a1 = a1 + 1\n     a3 = a3 + 1\n   end subroutine increment\n   subroutine pointer_assignments(p)\n-    integer, pointer :: p ! with [pointer] intent(out)\n-    p => null()           ! this is invalid\n+    integer, pointer,intent (inout) :: p\n+    p => null()\n   end subroutine pointer_assignments\n end program main\n "}]}