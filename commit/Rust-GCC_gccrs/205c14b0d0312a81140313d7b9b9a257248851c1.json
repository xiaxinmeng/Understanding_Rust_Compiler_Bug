{"sha": "205c14b0d0312a81140313d7b9b9a257248851c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjA1YzE0YjBkMDMxMmE4MTE0MDMxM2Q3YjliOWEyNTcyNDg4NTFjMQ==", "commit": {"author": {"name": "Thomas Quinot", "email": "quinot@adacore.com", "date": "2009-04-16T09:22:37Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-16T09:22:37Z"}, "message": "sem_elim.adb: Minor reformatting\n\n2009-04-16  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_elim.adb: Minor reformatting\n\n\t* freeze.adb: Minor reformatting\n\n\t* exp_ch4.adb: Minor reformatting\n\nFrom-SVN: r146154", "tree": {"sha": "a314edc627b506695c11ccfe18f27846d7277949", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a314edc627b506695c11ccfe18f27846d7277949"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/205c14b0d0312a81140313d7b9b9a257248851c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/205c14b0d0312a81140313d7b9b9a257248851c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/205c14b0d0312a81140313d7b9b9a257248851c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/205c14b0d0312a81140313d7b9b9a257248851c1/comments", "author": null, "committer": null, "parents": [{"sha": "b6fc2cdb350cd4f4d1591264caf57ad07a7ff78a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6fc2cdb350cd4f4d1591264caf57ad07a7ff78a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6fc2cdb350cd4f4d1591264caf57ad07a7ff78a"}], "stats": {"total": 18, "additions": 13, "deletions": 5}, "files": [{"sha": "92ae20a8fac6eacbc3bb861bd9bcf2d84a262e40", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/205c14b0d0312a81140313d7b9b9a257248851c1/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/205c14b0d0312a81140313d7b9b9a257248851c1/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=205c14b0d0312a81140313d7b9b9a257248851c1", "patch": "@@ -1,3 +1,11 @@\n+2009-04-16  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_elim.adb: Minor reformatting\n+\n+\t* freeze.adb: Minor reformatting\n+\n+\t* exp_ch4.adb: Minor reformatting\n+\n 2009-04-16  Emmanuel Briot  <briot@adacore.com>\n \n \t* prj-nmsc.adb (Path_Name_Of): fix memory leak"}, {"sha": "39158ecc62b40ff95dc6766669dbf4416f0a4291", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/205c14b0d0312a81140313d7b9b9a257248851c1/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/205c14b0d0312a81140313d7b9b9a257248851c1/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=205c14b0d0312a81140313d7b9b9a257248851c1", "patch": "@@ -2938,7 +2938,7 @@ package body Exp_Ch4 is\n       function Size_In_Storage_Elements (E : Entity_Id) return Node_Id;\n       --  Given a constrained array type E, returns a node representing the\n       --  code to compute the size in storage elements for the given type.\n-      --  This is done without using the attribute (which malfunctins for\n+      --  This is done without using the attribute (which malfunctions for\n       --  large sizes ???)\n \n       ---------------------------------------\n@@ -3356,7 +3356,7 @@ package body Exp_Ch4 is\n          --  least at the moment we don't compute this attribute right, and\n          --  can silently give wrong results when the result gets large. Since\n          --  this is all about large results, that's bad, so instead we only\n-         --  applly the check for constrained arrays, and manually compute the\n+         --  apply the check for constrained arrays, and manually compute the\n          --  value of the attribute ???\n \n          if Is_Array_Type (Etyp) and then Is_Constrained (Etyp) then"}, {"sha": "bc8e56c6246bd5ac7aedce50127e4756e4eed645", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/205c14b0d0312a81140313d7b9b9a257248851c1/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/205c14b0d0312a81140313d7b9b9a257248851c1/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=205c14b0d0312a81140313d7b9b9a257248851c1", "patch": "@@ -3509,7 +3509,7 @@ package body Freeze is\n          --  For access subprogram, freeze types of all formals, the return\n          --  type was already frozen, since it is the Etype of the function.\n          --  Formal types can be tagged Taft amendment types, but otherwise\n-         --  they cannot be incomplete;\n+         --  they cannot be incomplete.\n \n          elsif Ekind (E) = E_Subprogram_Type then\n             Formal := First_Formal (E);\n@@ -3535,7 +3535,7 @@ package body Freeze is\n \n             --  Ada 2005 (AI-326): Check wrong use of tag incomplete type\n \n-            --    type T;  --   tagged or untagged, may be from limited view;\n+            --    type T;  --   tagged or untagged, may be from limited view\n             --    type Acc is access function (X : T) return T; -- ERROR\n \n             if Ekind (Etype (E)) = E_Incomplete_Type"}, {"sha": "c15f9cfb3bc3fe1d24619e53c6eaab46f5664a82", "filename": "gcc/ada/sem_elim.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/205c14b0d0312a81140313d7b9b9a257248851c1/gcc%2Fada%2Fsem_elim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/205c14b0d0312a81140313d7b9b9a257248851c1/gcc%2Fada%2Fsem_elim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elim.adb?ref=205c14b0d0312a81140313d7b9b9a257248851c1", "patch": "@@ -282,7 +282,7 @@ package body Sem_Elim is\n                if Is_Dispatching_Operation (E) then\n \n                   --  If an overriding dispatching primitive is eliminated then\n-                  --  its parent must have been eliminated\n+                  --  its parent must have been eliminated.\n \n                   if Is_Overriding_Operation (E)\n                     and then not Is_Eliminated (Overridden_Operation (E))"}]}