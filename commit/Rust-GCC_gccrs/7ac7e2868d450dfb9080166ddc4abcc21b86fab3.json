{"sha": "7ac7e2868d450dfb9080166ddc4abcc21b86fab3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2FjN2UyODY4ZDQ1MGRmYjkwODAxNjZkZGM0YWJjYzIxYjg2ZmFiMw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-02T18:26:06Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-02T18:26:06Z"}, "message": "Split can_vec_perm_p into can_vec_perm_{var,const}_p\n\nThis patch splits can_vec_perm_p into two functions: can_vec_perm_var_p\nfor testing permute operations with variable selection vectors, and\ncan_vec_perm_const_p for testing permute operations with specific\nconstant selection vectors.  This means that we can pass the constant\nselection vector by reference.\n\nConstant permutes can still use a variable permute as a fallback.\nA later patch adds a check to makre sure that we don't truncate the\nvector indices when doing this.\n\nHowever, have_whole_vector_shift checked:\n\n  if (direct_optab_handler (vec_perm_const_optab, mode) == CODE_FOR_nothing)\n    return false;\n\nwhich had the effect of disallowing the fallback to variable permutes.\nI'm not sure whether that was the intention or whether it was just\nsupposed to short-cut the loop on targets that don't support permutes.\n(But then why bother?  The first check in the loop would fail and\nwe'd bail out straightaway.)\n\nThe patch adds a parameter for disallowing the fallback.  I think it\nmakes sense to do this for the following code in the VEC_PERM_EXPR\nfolder:\n\n\t  /* Some targets are deficient and fail to expand a single\n\t     argument permutation while still allowing an equivalent\n\t     2-argument version.  */\n\t  if (need_mask_canon && arg2 == op2\n\t      && !can_vec_perm_p (TYPE_MODE (type), false, &sel)\n\t      && can_vec_perm_p (TYPE_MODE (type), false, &sel2))\n\nsince it's really testing whether the expand_vec_perm_const code expects\na particular form.\n\n2018-01-02  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* optabs-query.h (can_vec_perm_p): Delete.\n\t(can_vec_perm_var_p, can_vec_perm_const_p): Declare.\n\t* optabs-query.c (can_vec_perm_p): Split into...\n\t(can_vec_perm_var_p, can_vec_perm_const_p): ...these two functions.\n\t(can_mult_highpart_p): Use can_vec_perm_const_p to test whether a\n\tparticular selector is valid.\n\t* tree-ssa-forwprop.c (simplify_vector_constructor): Likewise.\n\t* tree-vect-data-refs.c (vect_grouped_store_supported): Likewise.\n\t(vect_grouped_load_supported): Likewise.\n\t(vect_shift_permute_load_chain): Likewise.\n\t* tree-vect-slp.c (vect_build_slp_tree_1): Likewise.\n\t(vect_transform_slp_perm_load): Likewise.\n\t* tree-vect-stmts.c (perm_mask_for_reverse): Likewise.\n\t(vectorizable_bswap): Likewise.\n\t(vect_gen_perm_mask_checked): Likewise.\n\t* fold-const.c (fold_ternary_loc): Likewise.  Don't take\n\timplementations of variable permutation vectors into account\n\twhen deciding which selector to use.\n\t* tree-vect-loop.c (have_whole_vector_shift): Don't check whether\n\tvec_perm_const_optab is supported; instead use can_vec_perm_const_p\n\twith a false third argument.\n\t* tree-vect-generic.c (lower_vec_perm): Use can_vec_perm_const_p\n\tto test whether the constant selector is valid and can_vec_perm_var_p\n\tto test whether a variable selector is valid.\n\nFrom-SVN: r256091", "tree": {"sha": "944b586115ea01dff6dac70820714852c4cf2029", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/944b586115ea01dff6dac70820714852c4cf2029"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ac7e2868d450dfb9080166ddc4abcc21b86fab3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ac7e2868d450dfb9080166ddc4abcc21b86fab3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ac7e2868d450dfb9080166ddc4abcc21b86fab3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ac7e2868d450dfb9080166ddc4abcc21b86fab3/comments", "author": null, "committer": null, "parents": [{"sha": "4aae3cb3559802faee3b5cb58d9315dcc5000bc8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4aae3cb3559802faee3b5cb58d9315dcc5000bc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4aae3cb3559802faee3b5cb58d9315dcc5000bc8"}], "stats": {"total": 188, "additions": 121, "deletions": 67}, "files": [{"sha": "61fddf233d1f059f705ed8135dbf3aa2a5a09395", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ac7e2868d450dfb9080166ddc4abcc21b86fab3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ac7e2868d450dfb9080166ddc4abcc21b86fab3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7ac7e2868d450dfb9080166ddc4abcc21b86fab3", "patch": "@@ -1,3 +1,30 @@\n+2018-01-02  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* optabs-query.h (can_vec_perm_p): Delete.\n+\t(can_vec_perm_var_p, can_vec_perm_const_p): Declare.\n+\t* optabs-query.c (can_vec_perm_p): Split into...\n+\t(can_vec_perm_var_p, can_vec_perm_const_p): ...these two functions.\n+\t(can_mult_highpart_p): Use can_vec_perm_const_p to test whether a\n+\tparticular selector is valid.\n+\t* tree-ssa-forwprop.c (simplify_vector_constructor): Likewise.\n+\t* tree-vect-data-refs.c (vect_grouped_store_supported): Likewise.\n+\t(vect_grouped_load_supported): Likewise.\n+\t(vect_shift_permute_load_chain): Likewise.\n+\t* tree-vect-slp.c (vect_build_slp_tree_1): Likewise.\n+\t(vect_transform_slp_perm_load): Likewise.\n+\t* tree-vect-stmts.c (perm_mask_for_reverse): Likewise.\n+\t(vectorizable_bswap): Likewise.\n+\t(vect_gen_perm_mask_checked): Likewise.\n+\t* fold-const.c (fold_ternary_loc): Likewise.  Don't take\n+\timplementations of variable permutation vectors into account\n+\twhen deciding which selector to use.\n+\t* tree-vect-loop.c (have_whole_vector_shift): Don't check whether\n+\tvec_perm_const_optab is supported; instead use can_vec_perm_const_p\n+\twith a false third argument.\n+\t* tree-vect-generic.c (lower_vec_perm): Use can_vec_perm_const_p\n+\tto test whether the constant selector is valid and can_vec_perm_var_p\n+\tto test whether a variable selector is valid.\n+\n 2018-01-02  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* optabs-query.h (can_vec_perm_p): Take a const vec_perm_indices *."}, {"sha": "d9430ab473b53fcbfbdbd961429a2a5ac2f2baeb", "filename": "gcc/fold-const.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ac7e2868d450dfb9080166ddc4abcc21b86fab3/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ac7e2868d450dfb9080166ddc4abcc21b86fab3/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=7ac7e2868d450dfb9080166ddc4abcc21b86fab3", "patch": "@@ -11778,8 +11778,8 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n \t     argument permutation while still allowing an equivalent\n \t     2-argument version.  */\n \t  if (need_mask_canon && arg2 == op2\n-\t      && !can_vec_perm_p (TYPE_MODE (type), false, &sel)\n-\t      && can_vec_perm_p (TYPE_MODE (type), false, &sel2))\n+\t      && !can_vec_perm_const_p (TYPE_MODE (type), sel, false)\n+\t      && can_vec_perm_const_p (TYPE_MODE (type), sel2, false))\n \t    {\n \t      need_mask_canon = need_mask_canon2;\n \t      sel = sel2;"}, {"sha": "90925908d67f541d819607fa03c10f858a1edc89", "filename": "gcc/optabs-query.c", "status": "modified", "additions": 59, "deletions": 31, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ac7e2868d450dfb9080166ddc4abcc21b86fab3/gcc%2Foptabs-query.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ac7e2868d450dfb9080166ddc4abcc21b86fab3/gcc%2Foptabs-query.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.c?ref=7ac7e2868d450dfb9080166ddc4abcc21b86fab3", "patch": "@@ -361,58 +361,86 @@ qimode_for_vec_perm (machine_mode mode)\n   return opt_machine_mode ();\n }\n \n-/* Return true if VEC_PERM_EXPR of arbitrary input vectors can be\n-   expanded using SIMD extensions of the CPU.  SEL may be NULL, which\n-   stands for an unknown constant.  Note that additional permutations\n-   representing whole-vector shifts may also be handled via the vec_shr\n-   optab, but only where the second input vector is entirely constant\n-   zeroes; this case is not dealt with here.  */\n+/* Return true if VEC_PERM_EXPRs with variable selector operands can be\n+   expanded using SIMD extensions of the CPU.  MODE is the mode of the\n+   vectors being permuted.  */\n \n bool\n-can_vec_perm_p (machine_mode mode, bool variable, const vec_perm_indices *sel)\n+can_vec_perm_var_p (machine_mode mode)\n {\n-  machine_mode qimode;\n-\n   /* If the target doesn't implement a vector mode for the vector type,\n      then no operations are supported.  */\n   if (!VECTOR_MODE_P (mode))\n     return false;\n \n-  if (!variable)\n-    {\n-      if (direct_optab_handler (vec_perm_const_optab, mode) != CODE_FOR_nothing\n-\t  && (sel == NULL\n-\t      || targetm.vectorize.vec_perm_const_ok == NULL\n-\t      || targetm.vectorize.vec_perm_const_ok (mode, *sel)))\n-\treturn true;\n-    }\n-\n   if (direct_optab_handler (vec_perm_optab, mode) != CODE_FOR_nothing)\n     return true;\n \n   /* We allow fallback to a QI vector mode, and adjust the mask.  */\n+  machine_mode qimode;\n   if (!qimode_for_vec_perm (mode).exists (&qimode))\n     return false;\n \n-  /* ??? For completeness, we ought to check the QImode version of\n-      vec_perm_const_optab.  But all users of this implicit lowering\n-      feature implement the variable vec_perm_optab.  */\n   if (direct_optab_handler (vec_perm_optab, qimode) == CODE_FOR_nothing)\n     return false;\n \n   /* In order to support the lowering of variable permutations,\n      we need to support shifts and adds.  */\n-  if (variable)\n+  if (GET_MODE_UNIT_SIZE (mode) > 2\n+      && optab_handler (ashl_optab, mode) == CODE_FOR_nothing\n+      && optab_handler (vashl_optab, mode) == CODE_FOR_nothing)\n+    return false;\n+  if (optab_handler (add_optab, qimode) == CODE_FOR_nothing)\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Return true if the target directly supports VEC_PERM_EXPRs on vectors\n+   of mode MODE using the selector SEL.  ALLOW_VARIABLE_P is true if it\n+   is acceptable to force the selector into a register and use a variable\n+   permute (if the target supports that).\n+\n+   Note that additional permutations representing whole-vector shifts may\n+   also be handled via the vec_shr optab, but only where the second input\n+   vector is entirely constant zeroes; this case is not dealt with here.  */\n+\n+bool\n+can_vec_perm_const_p (machine_mode mode, const vec_perm_indices &sel,\n+\t\t      bool allow_variable_p)\n+{\n+  /* If the target doesn't implement a vector mode for the vector type,\n+     then no operations are supported.  */\n+  if (!VECTOR_MODE_P (mode))\n+    return false;\n+\n+  /* It's probably cheaper to test for the variable case first.  */\n+  if (allow_variable_p)\n+    {\n+      if (direct_optab_handler (vec_perm_optab, mode) != CODE_FOR_nothing)\n+\treturn true;\n+\n+      /* Unlike can_vec_perm_var_p, we don't need to test for optabs\n+\t related computing the QImode selector, since that happens at\n+\t compile time.  */\n+      machine_mode qimode;\n+      if (qimode_for_vec_perm (mode).exists (&qimode)\n+\t  && direct_optab_handler (vec_perm_optab, qimode) != CODE_FOR_nothing)\n+\treturn true;\n+    }\n+\n+  if (direct_optab_handler (vec_perm_const_optab, mode) != CODE_FOR_nothing)\n     {\n-      if (GET_MODE_UNIT_SIZE (mode) > 2\n-\t  && optab_handler (ashl_optab, mode) == CODE_FOR_nothing\n-\t  && optab_handler (vashl_optab, mode) == CODE_FOR_nothing)\n-\treturn false;\n-      if (optab_handler (add_optab, qimode) == CODE_FOR_nothing)\n-\treturn false;\n+      if (targetm.vectorize.vec_perm_const_ok == NULL\n+\t  || targetm.vectorize.vec_perm_const_ok (mode, sel))\n+\treturn true;\n+\n+      /* ??? For completeness, we ought to check the QImode version of\n+\t vec_perm_const_optab.  But all users of this implicit lowering\n+\t feature implement the variable vec_perm_optab.  */\n     }\n \n-  return true;\n+  return false;\n }\n \n /* Find a widening optab even if it doesn't widen as much as we want.\n@@ -472,7 +500,7 @@ can_mult_highpart_p (machine_mode mode, bool uns_p)\n \t    sel.quick_push (!BYTES_BIG_ENDIAN\n \t\t\t    + (i & ~1)\n \t\t\t    + ((i & 1) ? nunits : 0));\n-\t  if (can_vec_perm_p (mode, false, &sel))\n+\t  if (can_vec_perm_const_p (mode, sel))\n \t    return 2;\n \t}\n     }\n@@ -486,7 +514,7 @@ can_mult_highpart_p (machine_mode mode, bool uns_p)\n \t  auto_vec_perm_indices sel (nunits);\n \t  for (i = 0; i < nunits; ++i)\n \t    sel.quick_push (2 * i + (BYTES_BIG_ENDIAN ? 0 : 1));\n-\t  if (can_vec_perm_p (mode, false, &sel))\n+\t  if (can_vec_perm_const_p (mode, sel))\n \t    return 3;\n \t}\n     }"}, {"sha": "28f20e7d0fd536c3cf7cd80b50624cb4c572f894", "filename": "gcc/optabs-query.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ac7e2868d450dfb9080166ddc4abcc21b86fab3/gcc%2Foptabs-query.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ac7e2868d450dfb9080166ddc4abcc21b86fab3/gcc%2Foptabs-query.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.h?ref=7ac7e2868d450dfb9080166ddc4abcc21b86fab3", "patch": "@@ -175,7 +175,9 @@ enum insn_code can_float_p (machine_mode, machine_mode, int);\n enum insn_code can_fix_p (machine_mode, machine_mode, int, bool *);\n bool can_conditionally_move_p (machine_mode mode);\n opt_machine_mode qimode_for_vec_perm (machine_mode);\n-bool can_vec_perm_p (machine_mode, bool, const vec_perm_indices *);\n+bool can_vec_perm_var_p (machine_mode);\n+bool can_vec_perm_const_p (machine_mode, const vec_perm_indices &,\n+\t\t\t   bool = true);\n /* Find a widening optab even if it doesn't widen as much as we want.  */\n #define find_widening_optab_handler(A, B, C) \\\n   find_widening_optab_handler_and_mode (A, B, C, NULL)"}, {"sha": "783ceb689b83b0f224dd0e03c32a64a05b60e514", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ac7e2868d450dfb9080166ddc4abcc21b86fab3/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ac7e2868d450dfb9080166ddc4abcc21b86fab3/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=7ac7e2868d450dfb9080166ddc4abcc21b86fab3", "patch": "@@ -2108,7 +2108,7 @@ simplify_vector_constructor (gimple_stmt_iterator *gsi)\n     {\n       tree mask_type;\n \n-      if (!can_vec_perm_p (TYPE_MODE (type), false, &sel))\n+      if (!can_vec_perm_const_p (TYPE_MODE (type), sel))\n \treturn false;\n       mask_type\n \t= build_vector_type (build_nonstandard_integer_type (elem_size, 1),"}, {"sha": "bbbeef6f8163207902c56851e598cb9872d716f8", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ac7e2868d450dfb9080166ddc4abcc21b86fab3/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ac7e2868d450dfb9080166ddc4abcc21b86fab3/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=7ac7e2868d450dfb9080166ddc4abcc21b86fab3", "patch": "@@ -4600,11 +4600,11 @@ vect_grouped_store_supported (tree vectype, unsigned HOST_WIDE_INT count)\n \t\t  if (3 * i + nelt2 < nelt)\n \t\t    sel[3 * i + nelt2] = 0;\n \t\t}\n-\t      if (!can_vec_perm_p (mode, false, &sel))\n+\t      if (!can_vec_perm_const_p (mode, sel))\n \t\t{\n \t\t  if (dump_enabled_p ())\n \t\t    dump_printf (MSG_MISSED_OPTIMIZATION,\n-\t\t\t\t \"permutaion op not supported by target.\\n\");\n+\t\t\t\t \"permutation op not supported by target.\\n\");\n \t\t  return false;\n \t\t}\n \n@@ -4617,11 +4617,11 @@ vect_grouped_store_supported (tree vectype, unsigned HOST_WIDE_INT count)\n \t\t  if (3 * i + nelt2 < nelt)\n \t\t    sel[3 * i + nelt2] = nelt + j2++;\n \t\t}\n-\t      if (!can_vec_perm_p (mode, false, &sel))\n+\t      if (!can_vec_perm_const_p (mode, sel))\n \t\t{\n \t\t  if (dump_enabled_p ())\n \t\t    dump_printf (MSG_MISSED_OPTIMIZATION,\n-\t\t\t\t \"permutaion op not supported by target.\\n\");\n+\t\t\t\t \"permutation op not supported by target.\\n\");\n \t\t  return false;\n \t\t}\n \t    }\n@@ -4637,11 +4637,11 @@ vect_grouped_store_supported (tree vectype, unsigned HOST_WIDE_INT count)\n \t      sel[i * 2] = i;\n \t      sel[i * 2 + 1] = i + nelt;\n \t    }\n-\t  if (can_vec_perm_p (mode, false, &sel))\n+\t  if (can_vec_perm_const_p (mode, sel))\n \t    {\n \t      for (i = 0; i < nelt; i++)\n \t\tsel[i] += nelt / 2;\n-\t      if (can_vec_perm_p (mode, false, &sel))\n+\t      if (can_vec_perm_const_p (mode, sel))\n \t\treturn true;\n \t    }\n \t}\n@@ -5179,7 +5179,7 @@ vect_grouped_load_supported (tree vectype, bool single_element_p,\n \t\t  sel[i] = 3 * i + k;\n \t\telse\n \t\t  sel[i] = 0;\n-\t      if (!can_vec_perm_p (mode, false, &sel))\n+\t      if (!can_vec_perm_const_p (mode, sel))\n \t\t{\n \t\t  if (dump_enabled_p ())\n \t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -5192,7 +5192,7 @@ vect_grouped_load_supported (tree vectype, bool single_element_p,\n \t\t  sel[i] = i;\n \t\telse\n \t\t  sel[i] = nelt + ((nelt + k) % 3) + 3 * (j++);\n-\t      if (!can_vec_perm_p (mode, false, &sel))\n+\t      if (!can_vec_perm_const_p (mode, sel))\n \t\t{\n \t\t  if (dump_enabled_p ())\n \t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -5209,11 +5209,11 @@ vect_grouped_load_supported (tree vectype, bool single_element_p,\n \t  gcc_assert (pow2p_hwi (count));\n \t  for (i = 0; i < nelt; i++)\n \t    sel[i] = i * 2;\n-\t  if (can_vec_perm_p (mode, false, &sel))\n+\t  if (can_vec_perm_const_p (mode, sel))\n \t    {\n \t      for (i = 0; i < nelt; i++)\n \t\tsel[i] = i * 2 + 1;\n-\t      if (can_vec_perm_p (mode, false, &sel))\n+\t      if (can_vec_perm_const_p (mode, sel))\n \t\treturn true;\n \t    }\n         }\n@@ -5540,7 +5540,7 @@ vect_shift_permute_load_chain (vec<tree> dr_chain,\n \tsel[i] = i * 2;\n       for (i = 0; i < nelt / 2; ++i)\n \tsel[nelt / 2 + i] = i * 2 + 1;\n-      if (!can_vec_perm_p (TYPE_MODE (vectype), false, &sel))\n+      if (!can_vec_perm_const_p (TYPE_MODE (vectype), sel))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -5554,7 +5554,7 @@ vect_shift_permute_load_chain (vec<tree> dr_chain,\n \tsel[i] = i * 2 + 1;\n       for (i = 0; i < nelt / 2; ++i)\n \tsel[nelt / 2 + i] = i * 2;\n-      if (!can_vec_perm_p (TYPE_MODE (vectype), false, &sel))\n+      if (!can_vec_perm_const_p (TYPE_MODE (vectype), sel))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -5568,7 +5568,7 @@ vect_shift_permute_load_chain (vec<tree> dr_chain,\n \t For vector length 8 it is {4 5 6 7 8 9 10 11}.  */\n       for (i = 0; i < nelt; i++)\n \tsel[i] = nelt / 2 + i;\n-      if (!can_vec_perm_p (TYPE_MODE (vectype), false, &sel))\n+      if (!can_vec_perm_const_p (TYPE_MODE (vectype), sel))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -5583,7 +5583,7 @@ vect_shift_permute_load_chain (vec<tree> dr_chain,\n \tsel[i] = i;\n       for (i = nelt / 2; i < nelt; i++)\n \tsel[i] = nelt + i;\n-      if (!can_vec_perm_p (TYPE_MODE (vectype), false, &sel))\n+      if (!can_vec_perm_const_p (TYPE_MODE (vectype), sel))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -5646,7 +5646,7 @@ vect_shift_permute_load_chain (vec<tree> dr_chain,\n \t  sel[i] = 3 * k + (l % 3);\n \t  k++;\n \t}\n-      if (!can_vec_perm_p (TYPE_MODE (vectype), false, &sel))\n+      if (!can_vec_perm_const_p (TYPE_MODE (vectype), sel))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -5660,7 +5660,7 @@ vect_shift_permute_load_chain (vec<tree> dr_chain,\n \t For vector length 8 it is {6 7 8 9 10 11 12 13}.  */\n       for (i = 0; i < nelt; i++)\n \tsel[i] = 2 * (nelt / 3) + (nelt % 3) + i;\n-      if (!can_vec_perm_p (TYPE_MODE (vectype), false, &sel))\n+      if (!can_vec_perm_const_p (TYPE_MODE (vectype), sel))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -5673,7 +5673,7 @@ vect_shift_permute_load_chain (vec<tree> dr_chain,\n \t For vector length 8 it is {5 6 7 8 9 10 11 12}.  */\n       for (i = 0; i < nelt; i++)\n \tsel[i] = 2 * (nelt / 3) + 1 + i;\n-      if (!can_vec_perm_p (TYPE_MODE (vectype), false, &sel))\n+      if (!can_vec_perm_const_p (TYPE_MODE (vectype), sel))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -5686,7 +5686,7 @@ vect_shift_permute_load_chain (vec<tree> dr_chain,\n \t For vector length 8 it is {3 4 5 6 7 8 9 10}.  */\n       for (i = 0; i < nelt; i++)\n \tsel[i] = (nelt / 3) + (nelt % 3) / 2 + i;\n-      if (!can_vec_perm_p (TYPE_MODE (vectype), false, &sel))\n+      if (!can_vec_perm_const_p (TYPE_MODE (vectype), sel))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -5699,7 +5699,7 @@ vect_shift_permute_load_chain (vec<tree> dr_chain,\n \t For vector length 8 it is {5 6 7 8 9 10 11 12}.  */\n       for (i = 0; i < nelt; i++)\n \tsel[i] = 2 * (nelt / 3) + (nelt % 3) / 2 + i;\n-      if (!can_vec_perm_p (TYPE_MODE (vectype), false, &sel))\n+      if (!can_vec_perm_const_p (TYPE_MODE (vectype), sel))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,"}, {"sha": "7e78df8b5dda61a88d3d33542fd7917b0992dd0d", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ac7e2868d450dfb9080166ddc4abcc21b86fab3/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ac7e2868d450dfb9080166ddc4abcc21b86fab3/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=7ac7e2868d450dfb9080166ddc4abcc21b86fab3", "patch": "@@ -1306,7 +1306,7 @@ lower_vec_perm (gimple_stmt_iterator *gsi)\n \tsel_int.quick_push (TREE_INT_CST_LOW (VECTOR_CST_ELT (mask, i))\n \t\t\t    & (2 * elements - 1));\n \n-      if (can_vec_perm_p (TYPE_MODE (vect_type), false, &sel_int))\n+      if (can_vec_perm_const_p (TYPE_MODE (vect_type), sel_int))\n \t{\n \t  gimple_assign_set_rhs3 (stmt, mask);\n \t  update_stmt (stmt);\n@@ -1337,7 +1337,7 @@ lower_vec_perm (gimple_stmt_iterator *gsi)\n \t    }\n \t}\n     }\n-  else if (can_vec_perm_p (TYPE_MODE (vect_type), true, NULL))\n+  else if (can_vec_perm_var_p (TYPE_MODE (vect_type)))\n     return;\n   \n   warning_at (loc, OPT_Wvector_operation_performance,"}, {"sha": "02f6f7f2c76823ff51759779632ffc8afea83362", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ac7e2868d450dfb9080166ddc4abcc21b86fab3/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ac7e2868d450dfb9080166ddc4abcc21b86fab3/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=7ac7e2868d450dfb9080166ddc4abcc21b86fab3", "patch": "@@ -3729,17 +3729,14 @@ have_whole_vector_shift (machine_mode mode)\n   if (optab_handler (vec_shr_optab, mode) != CODE_FOR_nothing)\n     return true;\n \n-  if (direct_optab_handler (vec_perm_const_optab, mode) == CODE_FOR_nothing)\n-    return false;\n-\n   unsigned int i, nelt = GET_MODE_NUNITS (mode);\n   auto_vec_perm_indices sel (nelt);\n \n   for (i = nelt/2; i >= 1; i/=2)\n     {\n       sel.truncate (0);\n       calc_vec_perm_mask_for_shift (i, nelt, &sel);\n-      if (!can_vec_perm_p (mode, false, &sel))\n+      if (!can_vec_perm_const_p (mode, sel, false))\n \treturn false;\n     }\n   return true;"}, {"sha": "0f6005338df2e9df870a3a70032e7b81c85c77a3", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ac7e2868d450dfb9080166ddc4abcc21b86fab3/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ac7e2868d450dfb9080166ddc4abcc21b86fab3/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=7ac7e2868d450dfb9080166ddc4abcc21b86fab3", "patch": "@@ -901,7 +901,7 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \t    elt += count;\n \t  sel.quick_push (elt);\n \t}\n-      if (!can_vec_perm_p (TYPE_MODE (vectype), false, &sel))\n+      if (!can_vec_perm_const_p (TYPE_MODE (vectype), sel))\n \t{\n \t  for (i = 0; i < group_size; ++i)\n \t    if (gimple_assign_rhs_code (stmts[i]) == alt_stmt_code)\n@@ -3646,7 +3646,7 @@ vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n \t  if (index == nunits)\n \t    {\n \t      if (! noop_p\n-\t\t  && ! can_vec_perm_p (mode, false, &mask))\n+\t\t  && ! can_vec_perm_const_p (mode, mask))\n \t\t{\n \t\t  if (dump_enabled_p ())\n \t\t    {"}, {"sha": "85167d3123aa827dd901c36474da0920ee8f5ebc", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ac7e2868d450dfb9080166ddc4abcc21b86fab3/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ac7e2868d450dfb9080166ddc4abcc21b86fab3/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=7ac7e2868d450dfb9080166ddc4abcc21b86fab3", "patch": "@@ -1720,7 +1720,7 @@ perm_mask_for_reverse (tree vectype)\n   for (i = 0; i < nunits; ++i)\n     sel.quick_push (nunits - 1 - i);\n \n-  if (!can_vec_perm_p (TYPE_MODE (vectype), false, &sel))\n+  if (!can_vec_perm_const_p (TYPE_MODE (vectype), sel))\n     return NULL_TREE;\n   return vect_gen_perm_mask_checked (vectype, sel);\n }\n@@ -2502,7 +2502,7 @@ vectorizable_bswap (gimple *stmt, gimple_stmt_iterator *gsi,\n     for (unsigned j = 0; j < word_bytes; ++j)\n       elts.quick_push ((i + 1) * word_bytes - j - 1);\n \n-  if (! can_vec_perm_p (TYPE_MODE (char_vectype), false, &elts))\n+  if (!can_vec_perm_const_p (TYPE_MODE (char_vectype), elts))\n     return false;\n \n   if (! vec_stmt)\n@@ -6519,7 +6519,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \n /* Given a vector type VECTYPE, turns permutation SEL into the equivalent\n    VECTOR_CST mask.  No checks are made that the target platform supports the\n-   mask, so callers may wish to test can_vec_perm_p separately, or use\n+   mask, so callers may wish to test can_vec_perm_const_p separately, or use\n    vect_gen_perm_mask_checked.  */\n \n tree\n@@ -6540,13 +6540,13 @@ vect_gen_perm_mask_any (tree vectype, const vec_perm_indices &sel)\n   return mask_elts.build ();\n }\n \n-/* Checked version of vect_gen_perm_mask_any.  Asserts can_vec_perm_p,\n+/* Checked version of vect_gen_perm_mask_any.  Asserts can_vec_perm_const_p,\n    i.e. that the target supports the pattern _for arbitrary input vectors_.  */\n \n tree\n vect_gen_perm_mask_checked (tree vectype, const vec_perm_indices &sel)\n {\n-  gcc_assert (can_vec_perm_p (TYPE_MODE (vectype), false, &sel));\n+  gcc_assert (can_vec_perm_const_p (TYPE_MODE (vectype), sel));\n   return vect_gen_perm_mask_any (vectype, sel);\n }\n "}]}