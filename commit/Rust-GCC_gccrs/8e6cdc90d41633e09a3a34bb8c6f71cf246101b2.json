{"sha": "8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGU2Y2RjOTBkNDE2MzNlMDlhM2EzNGJiOGM2ZjcxY2YyNDYxMDFiMg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-10-10T16:55:34Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-10-10T16:55:34Z"}, "message": "Require wi::to_wide for trees\n\nThe wide_int routines allow things like:\n\n   wi::add (t, 1)\n\nto add 1 to an INTEGER_CST T in its native precision.  But we also have:\n\n   wi::to_offset (t)      // Treat T as an offset_int\n   wi::to_widest (t)      // Treat T as a widest_int\n\nRecently we also gained:\n\n   wi::to_wide (t, prec)  // Treat T as a wide_int in preccision PREC\n\nThis patch therefore requires:\n\n   wi::to_wide (t)\n\nwhen operating on INTEGER_CSTs in their native precision.  This is\njust as efficient, and makes it clearer that a deliberate choice is\nbeing made to treat the tree as a wide_int in its native precision.\nThis also removes the inconsistency that\n\na) INTEGER_CSTs in their native precision can be used without an accessor\n   but must use wi:: functions instead of C++ operators\n\nb) the other forms need an explicit accessor but the result can be used\n   with C++ operators.\n\nIt also helps with SVE, where there's the additional possibility\nthat the tree could be a runtime value.\n\n2017-10-10  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* wide-int.h (wide_int_ref_storage): Make host_dependent_precision\n\ta template parameter.\n\t(WIDE_INT_REF_FOR): Update accordingly.\n\t* tree.h (wi::int_traits <const_tree>): Delete.\n\t(wi::tree_to_widest_ref, wi::tree_to_offset_ref): New typedefs.\n\t(wi::to_widest, wi::to_offset): Use them.  Expand commentary.\n\t(wi::tree_to_wide_ref): New typedef.\n\t(wi::to_wide): New function.\n\t* calls.c (get_size_range): Use wi::to_wide when operating on\n\ttrees as wide_ints.\n\t* cgraph.c (cgraph_node::create_thunk): Likewise.\n\t* config/i386/i386.c (ix86_data_alignment): Likewise.\n\t(ix86_local_alignment): Likewise.\n\t* dbxout.c (stabstr_O): Likewise.\n\t* dwarf2out.c (add_scalar_info, gen_enumeration_type_die): Likewise.\n\t* expr.c (const_vector_from_tree): Likewise.\n\t* fold-const-call.c (host_size_t_cst_p, fold_const_call_1): Likewise.\n\t* fold-const.c (may_negate_without_overflow_p, negate_expr_p)\n\t(fold_negate_expr_1, int_const_binop_1, const_binop)\n\t(fold_convert_const_int_from_real, optimize_bit_field_compare)\n\t(all_ones_mask_p, sign_bit_p, unextend, extract_muldiv_1)\n\t(fold_div_compare, fold_single_bit_test, fold_plusminus_mult_expr)\n\t(pointer_may_wrap_p, expr_not_equal_to, fold_binary_loc)\n\t(fold_ternary_loc, multiple_of_p, fold_negate_const, fold_abs_const)\n\t(fold_not_const, round_up_loc): Likewise.\n\t* gimple-fold.c (gimple_fold_indirect_ref): Likewise.\n\t* gimple-ssa-warn-alloca.c (alloca_call_type_by_arg): Likewise.\n\t(alloca_call_type): Likewise.\n\t* gimple.c (preprocess_case_label_vec_for_gimple): Likewise.\n\t* godump.c (go_output_typedef): Likewise.\n\t* graphite-sese-to-poly.c (tree_int_to_gmp): Likewise.\n\t* internal-fn.c (get_min_precision): Likewise.\n\t* ipa-cp.c (ipcp_store_vr_results): Likewise.\n\t* ipa-polymorphic-call.c\n\t(ipa_polymorphic_call_context::ipa_polymorphic_call_context): Likewise.\n\t* ipa-prop.c (ipa_print_node_jump_functions_for_edge): Likewise.\n\t(ipa_modify_call_arguments): Likewise.\n\t* match.pd: Likewise.\n\t* omp-low.c (scan_omp_1_op, lower_omp_ordered_clauses): Likewise.\n\t* print-tree.c (print_node_brief, print_node): Likewise.\n\t* stmt.c (expand_case): Likewise.\n\t* stor-layout.c (layout_type): Likewise.\n\t* tree-affine.c (tree_to_aff_combination): Likewise.\n\t* tree-cfg.c (group_case_labels_stmt): Likewise.\n\t* tree-data-ref.c (dr_analyze_indices): Likewise.\n\t(prune_runtime_alias_test_list): Likewise.\n\t* tree-dump.c (dequeue_and_dump): Likewise.\n\t* tree-inline.c (remap_gimple_op_r, copy_tree_body_r): Likewise.\n\t* tree-predcom.c (is_inv_store_elimination_chain): Likewise.\n\t* tree-pretty-print.c (dump_generic_node): Likewise.\n\t* tree-scalar-evolution.c (iv_can_overflow_p): Likewise.\n\t(simple_iv_with_niters): Likewise.\n\t* tree-ssa-address.c (addr_for_mem_ref): Likewise.\n\t* tree-ssa-ccp.c (ccp_finalize, evaluate_stmt): Likewise.\n\t* tree-ssa-loop-ivopts.c (constant_multiple_of): Likewise.\n\t* tree-ssa-loop-niter.c (split_to_var_and_offset)\n\t(refine_value_range_using_guard, number_of_iterations_ne_max)\n\t(number_of_iterations_lt_to_ne, number_of_iterations_lt)\n\t(get_cst_init_from_scev, record_nonwrapping_iv)\n\t(scev_var_range_cant_overflow): Likewise.\n\t* tree-ssa-phiopt.c (minmax_replacement): Likewise.\n\t* tree-ssa-pre.c (compute_avail): Likewise.\n\t* tree-ssa-sccvn.c (vn_reference_fold_indirect): Likewise.\n\t(vn_reference_maybe_forwprop_address, valueized_wider_op): Likewise.\n\t* tree-ssa-structalias.c (get_constraint_for_ptr_offset): Likewise.\n\t* tree-ssa-uninit.c (is_pred_expr_subset_of): Likewise.\n\t* tree-ssanames.c (set_nonzero_bits, get_nonzero_bits): Likewise.\n\t* tree-switch-conversion.c (collect_switch_conv_info, array_value_type)\n\t(dump_case_nodes, try_switch_expansion): Likewise.\n\t* tree-vect-loop-manip.c (vect_gen_vector_loop_niters): Likewise.\n\t(vect_do_peeling): Likewise.\n\t* tree-vect-patterns.c (vect_recog_bool_pattern): Likewise.\n\t* tree-vect-stmts.c (vectorizable_load): Likewise.\n\t* tree-vrp.c (compare_values_warnv, vrp_int_const_binop): Likewise.\n\t(zero_nonzero_bits_from_vr, ranges_from_anti_range): Likewise.\n\t(extract_range_from_binary_expr_1, adjust_range_with_scev): Likewise.\n\t(overflow_comparison_p_1, register_edge_assert_for_2): Likewise.\n\t(is_masked_range_test, find_switch_asserts, maybe_set_nonzero_bits)\n\t(vrp_evaluate_conditional_warnv_with_ops, intersect_ranges): Likewise.\n\t(range_fits_type_p, two_valued_val_range_p, vrp_finalize): Likewise.\n\t(evrp_dom_walker::before_dom_children): Likewise.\n\t* tree.c (cache_integer_cst, real_value_from_int_cst, integer_zerop)\n\t(integer_all_onesp, integer_pow2p, integer_nonzerop, tree_log2)\n\t(tree_floor_log2, tree_ctz, mem_ref_offset, tree_int_cst_sign_bit)\n\t(tree_int_cst_sgn, get_unwidened, int_fits_type_p): Likewise.\n\t(get_type_static_bounds, num_ending_zeros, drop_tree_overflow)\n\t(get_range_pos_neg): Likewise.\n\t* ubsan.c (ubsan_expand_ptr_ifn): Likewise.\n\t* config/darwin.c (darwin_mergeable_constant_section): Likewise.\n\t* config/aarch64/aarch64.c (aapcs_vfp_sub_candidate): Likewise.\n\t* config/arm/arm.c (aapcs_vfp_sub_candidate): Likewise.\n\t* config/avr/avr.c (avr_fold_builtin): Likewise.\n\t* config/bfin/bfin.c (bfin_local_alignment): Likewise.\n\t* config/msp430/msp430.c (msp430_attr): Likewise.\n\t* config/nds32/nds32.c (nds32_insert_attributes): Likewise.\n\t* config/powerpcspe/powerpcspe-c.c\n\t(altivec_resolve_overloaded_builtin): Likewise.\n\t* config/powerpcspe/powerpcspe.c (rs6000_aggregate_candidate)\n\t(rs6000_expand_ternop_builtin): Likewise.\n\t* config/rs6000/rs6000-c.c\n\t(altivec_resolve_overloaded_builtin): Likewise.\n\t* config/rs6000/rs6000.c (rs6000_aggregate_candidate): Likewise.\n\t(rs6000_expand_ternop_builtin): Likewise.\n\t* config/s390/s390.c (s390_handle_hotpatch_attribute): Likewise.\n\ngcc/ada/\n\t* gcc-interface/decl.c (annotate_value): Use wi::to_wide when\n\toperating on trees as wide_ints.\n\ngcc/c/\n\t* c-parser.c (c_parser_cilk_clause_vectorlength): Use wi::to_wide when\n\toperating on trees as wide_ints.\n\t* c-typeck.c (build_c_cast, c_finish_omp_clauses): Likewise.\n\t(c_tree_equal): Likewise.\n\ngcc/c-family/\n\t* c-ada-spec.c (dump_generic_ada_node): Use wi::to_wide when\n\toperating on trees as wide_ints.\n\t* c-common.c (pointer_int_sum): Likewise.\n\t* c-pretty-print.c (pp_c_integer_constant): Likewise.\n\t* c-warn.c (match_case_to_enum_1): Likewise.\n\t(c_do_switch_warnings): Likewise.\n\t(maybe_warn_shift_overflow): Likewise.\n\ngcc/cp/\n\t* cvt.c (ignore_overflows): Use wi::to_wide when\n\toperating on trees as wide_ints.\n\t* decl.c (check_array_designated_initializer): Likewise.\n\t* mangle.c (write_integer_cst): Likewise.\n\t* semantics.c (cp_finish_omp_clause_depend_sink): Likewise.\n\ngcc/fortran/\n\t* target-memory.c (gfc_interpret_logical): Use wi::to_wide when\n\toperating on trees as wide_ints.\n\t* trans-const.c (gfc_conv_tree_to_mpz): Likewise.\n\t* trans-expr.c (gfc_conv_cst_int_power): Likewise.\n\t* trans-intrinsic.c (trans_this_image): Likewise.\n\t(gfc_conv_intrinsic_bound): Likewise.\n\t(conv_intrinsic_cobound): Likewise.\n\ngcc/lto/\n\t* lto.c (compare_tree_sccs_1): Use wi::to_wide when\n\toperating on trees as wide_ints.\n\ngcc/objc/\n\t* objc-act.c (objc_decl_method_attributes): Use wi::to_wide when\n\toperating on trees as wide_ints.\n\nFrom-SVN: r253595", "tree": {"sha": "c8d6aac483b647ae892778e9398965071da02686", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8d6aac483b647ae892778e9398965071da02686"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/comments", "author": null, "committer": null, "parents": [{"sha": "3934b625ee2f522edf455191d1eaaa42e265a1d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3934b625ee2f522edf455191d1eaaa42e265a1d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3934b625ee2f522edf455191d1eaaa42e265a1d9"}], "stats": {"total": 1455, "additions": 896, "deletions": 559}, "files": [{"sha": "351b1f013792c405f0c7b7cfeaacdd6076489434", "filename": "gcc/ChangeLog", "status": "modified", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -1,3 +1,110 @@\n+2017-10-10  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* wide-int.h (wide_int_ref_storage): Make host_dependent_precision\n+\ta template parameter.\n+\t(WIDE_INT_REF_FOR): Update accordingly.\n+\t* tree.h (wi::int_traits <const_tree>): Delete.\n+\t(wi::tree_to_widest_ref, wi::tree_to_offset_ref): New typedefs.\n+\t(wi::to_widest, wi::to_offset): Use them.  Expand commentary.\n+\t(wi::tree_to_wide_ref): New typedef.\n+\t(wi::to_wide): New function.\n+\t* calls.c (get_size_range): Use wi::to_wide when operating on\n+\ttrees as wide_ints.\n+\t* cgraph.c (cgraph_node::create_thunk): Likewise.\n+\t* config/i386/i386.c (ix86_data_alignment): Likewise.\n+\t(ix86_local_alignment): Likewise.\n+\t* dbxout.c (stabstr_O): Likewise.\n+\t* dwarf2out.c (add_scalar_info, gen_enumeration_type_die): Likewise.\n+\t* expr.c (const_vector_from_tree): Likewise.\n+\t* fold-const-call.c (host_size_t_cst_p, fold_const_call_1): Likewise.\n+\t* fold-const.c (may_negate_without_overflow_p, negate_expr_p)\n+\t(fold_negate_expr_1, int_const_binop_1, const_binop)\n+\t(fold_convert_const_int_from_real, optimize_bit_field_compare)\n+\t(all_ones_mask_p, sign_bit_p, unextend, extract_muldiv_1)\n+\t(fold_div_compare, fold_single_bit_test, fold_plusminus_mult_expr)\n+\t(pointer_may_wrap_p, expr_not_equal_to, fold_binary_loc)\n+\t(fold_ternary_loc, multiple_of_p, fold_negate_const, fold_abs_const)\n+\t(fold_not_const, round_up_loc): Likewise.\n+\t* gimple-fold.c (gimple_fold_indirect_ref): Likewise.\n+\t* gimple-ssa-warn-alloca.c (alloca_call_type_by_arg): Likewise.\n+\t(alloca_call_type): Likewise.\n+\t* gimple.c (preprocess_case_label_vec_for_gimple): Likewise.\n+\t* godump.c (go_output_typedef): Likewise.\n+\t* graphite-sese-to-poly.c (tree_int_to_gmp): Likewise.\n+\t* internal-fn.c (get_min_precision): Likewise.\n+\t* ipa-cp.c (ipcp_store_vr_results): Likewise.\n+\t* ipa-polymorphic-call.c\n+\t(ipa_polymorphic_call_context::ipa_polymorphic_call_context): Likewise.\n+\t* ipa-prop.c (ipa_print_node_jump_functions_for_edge): Likewise.\n+\t(ipa_modify_call_arguments): Likewise.\n+\t* match.pd: Likewise.\n+\t* omp-low.c (scan_omp_1_op, lower_omp_ordered_clauses): Likewise.\n+\t* print-tree.c (print_node_brief, print_node): Likewise.\n+\t* stmt.c (expand_case): Likewise.\n+\t* stor-layout.c (layout_type): Likewise.\n+\t* tree-affine.c (tree_to_aff_combination): Likewise.\n+\t* tree-cfg.c (group_case_labels_stmt): Likewise.\n+\t* tree-data-ref.c (dr_analyze_indices): Likewise.\n+\t(prune_runtime_alias_test_list): Likewise.\n+\t* tree-dump.c (dequeue_and_dump): Likewise.\n+\t* tree-inline.c (remap_gimple_op_r, copy_tree_body_r): Likewise.\n+\t* tree-predcom.c (is_inv_store_elimination_chain): Likewise.\n+\t* tree-pretty-print.c (dump_generic_node): Likewise.\n+\t* tree-scalar-evolution.c (iv_can_overflow_p): Likewise.\n+\t(simple_iv_with_niters): Likewise.\n+\t* tree-ssa-address.c (addr_for_mem_ref): Likewise.\n+\t* tree-ssa-ccp.c (ccp_finalize, evaluate_stmt): Likewise.\n+\t* tree-ssa-loop-ivopts.c (constant_multiple_of): Likewise.\n+\t* tree-ssa-loop-niter.c (split_to_var_and_offset)\n+\t(refine_value_range_using_guard, number_of_iterations_ne_max)\n+\t(number_of_iterations_lt_to_ne, number_of_iterations_lt)\n+\t(get_cst_init_from_scev, record_nonwrapping_iv)\n+\t(scev_var_range_cant_overflow): Likewise.\n+\t* tree-ssa-phiopt.c (minmax_replacement): Likewise.\n+\t* tree-ssa-pre.c (compute_avail): Likewise.\n+\t* tree-ssa-sccvn.c (vn_reference_fold_indirect): Likewise.\n+\t(vn_reference_maybe_forwprop_address, valueized_wider_op): Likewise.\n+\t* tree-ssa-structalias.c (get_constraint_for_ptr_offset): Likewise.\n+\t* tree-ssa-uninit.c (is_pred_expr_subset_of): Likewise.\n+\t* tree-ssanames.c (set_nonzero_bits, get_nonzero_bits): Likewise.\n+\t* tree-switch-conversion.c (collect_switch_conv_info, array_value_type)\n+\t(dump_case_nodes, try_switch_expansion): Likewise.\n+\t* tree-vect-loop-manip.c (vect_gen_vector_loop_niters): Likewise.\n+\t(vect_do_peeling): Likewise.\n+\t* tree-vect-patterns.c (vect_recog_bool_pattern): Likewise.\n+\t* tree-vect-stmts.c (vectorizable_load): Likewise.\n+\t* tree-vrp.c (compare_values_warnv, vrp_int_const_binop): Likewise.\n+\t(zero_nonzero_bits_from_vr, ranges_from_anti_range): Likewise.\n+\t(extract_range_from_binary_expr_1, adjust_range_with_scev): Likewise.\n+\t(overflow_comparison_p_1, register_edge_assert_for_2): Likewise.\n+\t(is_masked_range_test, find_switch_asserts, maybe_set_nonzero_bits)\n+\t(vrp_evaluate_conditional_warnv_with_ops, intersect_ranges): Likewise.\n+\t(range_fits_type_p, two_valued_val_range_p, vrp_finalize): Likewise.\n+\t(evrp_dom_walker::before_dom_children): Likewise.\n+\t* tree.c (cache_integer_cst, real_value_from_int_cst, integer_zerop)\n+\t(integer_all_onesp, integer_pow2p, integer_nonzerop, tree_log2)\n+\t(tree_floor_log2, tree_ctz, mem_ref_offset, tree_int_cst_sign_bit)\n+\t(tree_int_cst_sgn, get_unwidened, int_fits_type_p): Likewise.\n+\t(get_type_static_bounds, num_ending_zeros, drop_tree_overflow)\n+\t(get_range_pos_neg): Likewise.\n+\t* ubsan.c (ubsan_expand_ptr_ifn): Likewise.\n+\t* config/darwin.c (darwin_mergeable_constant_section): Likewise.\n+\t* config/aarch64/aarch64.c (aapcs_vfp_sub_candidate): Likewise.\n+\t* config/arm/arm.c (aapcs_vfp_sub_candidate): Likewise.\n+\t* config/avr/avr.c (avr_fold_builtin): Likewise.\n+\t* config/bfin/bfin.c (bfin_local_alignment): Likewise.\n+\t* config/msp430/msp430.c (msp430_attr): Likewise.\n+\t* config/nds32/nds32.c (nds32_insert_attributes): Likewise.\n+\t* config/powerpcspe/powerpcspe-c.c\n+\t(altivec_resolve_overloaded_builtin): Likewise.\n+\t* config/powerpcspe/powerpcspe.c (rs6000_aggregate_candidate)\n+\t(rs6000_expand_ternop_builtin): Likewise.\n+\t* config/rs6000/rs6000-c.c\n+\t(altivec_resolve_overloaded_builtin): Likewise.\n+\t* config/rs6000/rs6000.c (rs6000_aggregate_candidate): Likewise.\n+\t(rs6000_expand_ternop_builtin): Likewise.\n+\t* config/s390/s390.c (s390_handle_hotpatch_attribute): Likewise.\n+\n 2017-10-10  Bin Cheng  <bin.cheng@arm.com>\n \n \t* tree-vect-loop-manip.c (rename_variables_in_bb): Rename PHI nodes"}, {"sha": "3e1f53762c0e767033d0ed6b1efb312f2591fbeb", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -1,3 +1,8 @@\n+2017-10-10  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* gcc-interface/decl.c (annotate_value): Use wi::to_wide when\n+\toperating on trees as wide_ints.\n+\n 2017-10-09  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* sem_unit.adb (Find_Enclosing_Scope): Do not treat a block statement"}, {"sha": "e0d7a5f55685a15101bae4586944a75a9be2e631", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -8070,7 +8070,7 @@ annotate_value (tree gnu_size)\n \t can appear for discriminants in expressions for variants.  */\n       if (tree_int_cst_sgn (gnu_size) < 0)\n \t{\n-\t  tree t = wide_int_to_tree (sizetype, wi::neg (gnu_size));\n+\t  tree t = wide_int_to_tree (sizetype, -wi::to_wide (gnu_size));\n \t  tcode = Negate_Expr;\n \t  ops[0] = UI_From_gnu (t);\n \t}\n@@ -8174,7 +8174,8 @@ annotate_value (tree gnu_size)\n       if (TREE_CODE (TREE_OPERAND (gnu_size, 1)) == INTEGER_CST)\n \t{\n \t  tree op1 = TREE_OPERAND (gnu_size, 1);\n-\t  wide_int signed_op1 = wi::sext (op1, TYPE_PRECISION (sizetype));\n+\t  wide_int signed_op1 = wi::sext (wi::to_wide (op1),\n+\t\t\t\t\t  TYPE_PRECISION (sizetype));\n \t  if (wi::neg_p (signed_op1))\n \t    {\n \t      op1 = wide_int_to_tree (sizetype, wi::neg (signed_op1));"}, {"sha": "b63673035f451c4bbc5def857b4fd59beff6a156", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -1,3 +1,13 @@\n+2017-10-10  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* c-ada-spec.c (dump_generic_ada_node): Use wi::to_wide when\n+\toperating on trees as wide_ints.\n+\t* c-common.c (pointer_int_sum): Likewise.\n+\t* c-pretty-print.c (pp_c_integer_constant): Likewise.\n+\t* c-warn.c (match_case_to_enum_1): Likewise.\n+\t(c_do_switch_warnings): Likewise.\n+\t(maybe_warn_shift_overflow): Likewise.\n+\n 2017-10-10  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c/82437"}, {"sha": "95aacd1697adf0de6b6d3061d53ac73f76aa8bcf", "filename": "gcc/c-family/c-ada-spec.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fc-family%2Fc-ada-spec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fc-family%2Fc-ada-spec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-ada-spec.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -2362,7 +2362,7 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n \tpp_unsigned_wide_integer (buffer, tree_to_uhwi (node));\n       else\n \t{\n-\t  wide_int val = node;\n+\t  wide_int val = wi::to_wide (node);\n \t  int i;\n \t  if (wi::neg_p (val))\n \t    {"}, {"sha": "09594e44e6c5f1c10a539221a4cd4f6ca5ba1d02", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -3158,7 +3158,7 @@ pointer_int_sum (location_t loc, enum tree_code resultcode,\n \t\t\t      convert (TREE_TYPE (intop), size_exp));\n     intop = convert (sizetype, t);\n     if (TREE_OVERFLOW_P (intop) && !TREE_OVERFLOW (t))\n-      intop = wide_int_to_tree (TREE_TYPE (intop), intop);\n+      intop = wide_int_to_tree (TREE_TYPE (intop), wi::to_wide (intop));\n   }\n \n   /* Create the sum or difference.  */"}, {"sha": "0f48b9e958a7f13e7e77579e308e99f848023c11", "filename": "gcc/c-family/c-pretty-print.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fc-family%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fc-family%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pretty-print.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -916,9 +916,9 @@ pp_c_integer_constant (c_pretty_printer *pp, tree i)\n     pp_unsigned_wide_integer (pp, tree_to_uhwi (i));\n   else\n     {\n-      wide_int wi = i;\n+      wide_int wi = wi::to_wide (i);\n \n-      if (wi::lt_p (i, 0, TYPE_SIGN (TREE_TYPE (i))))\n+      if (wi::lt_p (wi::to_wide (i), 0, TYPE_SIGN (TREE_TYPE (i))))\n \t{\n \t  pp_minus (pp);\n \t  wi = -wi;"}, {"sha": "cb1db0327c3c09b31285b067757877697a7262b2", "filename": "gcc/c-family/c-warn.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fc-family%2Fc-warn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fc-family%2Fc-warn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-warn.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -1240,11 +1240,11 @@ match_case_to_enum_1 (tree key, tree type, tree label)\n   char buf[WIDE_INT_PRINT_BUFFER_SIZE];\n \n   if (tree_fits_uhwi_p (key))\n-    print_dec (key, buf, UNSIGNED);\n+    print_dec (wi::to_wide (key), buf, UNSIGNED);\n   else if (tree_fits_shwi_p (key))\n-    print_dec (key, buf, SIGNED);\n+    print_dec (wi::to_wide (key), buf, SIGNED);\n   else\n-    print_hex (key, buf);\n+    print_hex (wi::to_wide (key), buf);\n \n   if (TYPE_NAME (type) == NULL_TREE)\n     warning_at (DECL_SOURCE_LOCATION (CASE_LABEL (label)),\n@@ -1346,8 +1346,8 @@ c_do_switch_warnings (splay_tree cases, location_t switch_location,\n       /* If there's a case value > 1 or < 0, that is outside bool\n \t range, warn.  */\n       if (outside_range_p\n-\t  || (max && wi::gts_p (max, 1))\n-\t  || (min && wi::lts_p (min, 0))\n+\t  || (max && wi::gts_p (wi::to_wide (max), 1))\n+\t  || (min && wi::lts_p (wi::to_wide (min), 0))\n \t  /* And handle the\n \t     switch (boolean)\n \t       {\n@@ -1357,8 +1357,8 @@ c_do_switch_warnings (splay_tree cases, location_t switch_location,\n \t       }\n \t     case, where we want to warn.  */\n \t  || (default_node\n-\t      && max && wi::eq_p (max, 1)\n-\t      && min && wi::eq_p (min, 0)))\n+\t      && max && wi::to_wide (max) == 1\n+\t      && min && wi::to_wide (min) == 0))\n \twarning_at (switch_location, OPT_Wswitch_bool,\n \t\t    \"switch condition has boolean value\");\n     }\n@@ -2263,7 +2263,7 @@ maybe_warn_shift_overflow (location_t loc, tree op0, tree op1)\n   if (TYPE_UNSIGNED (type0))\n     return false;\n \n-  unsigned int min_prec = (wi::min_precision (op0, SIGNED)\n+  unsigned int min_prec = (wi::min_precision (wi::to_wide (op0), SIGNED)\n \t\t\t   + TREE_INT_CST_LOW (op1));\n   /* Handle the case of left-shifting 1 into the sign bit.\n    * However, shifting 1 _out_ of the sign bit, as in"}, {"sha": "822d0227ee81fca779ca00734918b4b2b7dcaa97", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -1,3 +1,10 @@\n+2017-10-10  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* c-parser.c (c_parser_cilk_clause_vectorlength): Use wi::to_wide when\n+\toperating on trees as wide_ints.\n+\t* c-typeck.c (build_c_cast, c_finish_omp_clauses): Likewise.\n+\t(c_tree_equal): Likewise.\n+\n 2017-10-04  David Malcolm  <dmalcolm@redhat.com>\n \n \t* c-decl.c (push_parm_decl): Store c_parm's location into the"}, {"sha": "a622e2a89c9fb6645e2a12e34db52b27ae806a9e", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -17832,7 +17832,7 @@ c_parser_cilk_clause_vectorlength (c_parser *parser, tree clauses,\n \t   || !INTEGRAL_TYPE_P (TREE_TYPE (expr)))\n   \n     error_at (loc, \"vectorlength must be an integer constant\");  \n-  else if (wi::exact_log2 (expr) == -1)\n+  else if (wi::exact_log2 (wi::to_wide (expr)) == -1)\n     error_at (loc, \"vectorlength must be a power of 2\");\n   else\n     {"}, {"sha": "cb9c589e061f4233756bfb119f85e0e17cce67fa", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -5684,7 +5684,7 @@ build_c_cast (location_t loc, tree type, tree expr)\n \t    }\n \t  else if (TREE_OVERFLOW (value))\n \t    /* Reset VALUE's overflow flags, ensuring constant sharing.  */\n-\t    value = wide_int_to_tree (TREE_TYPE (value), value);\n+\t    value = wide_int_to_tree (TREE_TYPE (value), wi::to_wide (value));\n \t}\n     }\n \n@@ -13504,7 +13504,7 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t  if (TREE_CODE (TREE_TYPE (decl)) == POINTER_TYPE)\n \t\t    {\n \t\t      tree offset = TREE_PURPOSE (t);\n-\t\t      bool neg = wi::neg_p ((wide_int) offset);\n+\t\t      bool neg = wi::neg_p (wi::to_wide (offset));\n \t\t      offset = fold_unary (ABS_EXPR, TREE_TYPE (offset), offset);\n \t\t      tree t2 = pointer_int_sum (OMP_CLAUSE_LOCATION (c),\n \t\t\t\t\t\t neg ? MINUS_EXPR : PLUS_EXPR,\n@@ -14237,7 +14237,7 @@ c_tree_equal (tree t1, tree t2)\n   switch (code1)\n     {\n     case INTEGER_CST:\n-      return wi::eq_p (t1, t2);\n+      return wi::to_wide (t1) == wi::to_wide (t2);\n \n     case REAL_CST:\n       return real_equal (&TREE_REAL_CST (t1), &TREE_REAL_CST (t2));"}, {"sha": "4d54fc6de0533c2377c1d4d9b1032422bdc689f6", "filename": "gcc/calls.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -1293,54 +1293,52 @@ get_size_range (tree exp, tree range[2])\n \n   tree exptype = TREE_TYPE (exp);\n   unsigned expprec = TYPE_PRECISION (exptype);\n-  wide_int wzero = wi::zero (expprec);\n-  wide_int wmaxval = wide_int (TYPE_MAX_VALUE (exptype));\n \n   bool signed_p = !TYPE_UNSIGNED (exptype);\n \n   if (range_type == VR_ANTI_RANGE)\n     {\n       if (signed_p)\n \t{\n-\t  if (wi::les_p (max, wzero))\n+\t  if (wi::les_p (max, 0))\n \t    {\n \t      /* EXP is not in a strictly negative range.  That means\n \t\t it must be in some (not necessarily strictly) positive\n \t\t range which includes zero.  Since in signed to unsigned\n \t\t conversions negative values end up converted to large\n \t\t positive values, and otherwise they are not valid sizes,\n \t\t the resulting range is in both cases [0, TYPE_MAX].  */\n-\t      min = wzero;\n-\t      max = wmaxval;\n+\t      min = wi::zero (expprec);\n+\t      max = wi::to_wide (TYPE_MAX_VALUE (exptype));\n \t    }\n-\t  else if (wi::les_p (min - 1, wzero))\n+\t  else if (wi::les_p (min - 1, 0))\n \t    {\n \t      /* EXP is not in a negative-positive range.  That means EXP\n \t\t is either negative, or greater than max.  Since negative\n \t\t sizes are invalid make the range [MAX + 1, TYPE_MAX].  */\n \t      min = max + 1;\n-\t      max = wmaxval;\n+\t      max = wi::to_wide (TYPE_MAX_VALUE (exptype));\n \t    }\n \t  else\n \t    {\n \t      max = min - 1;\n-\t      min = wzero;\n+\t      min = wi::zero (expprec);\n \t    }\n \t}\n-      else if (wi::eq_p (wzero, min - 1))\n+      else if (wi::eq_p (0, min - 1))\n \t{\n \t  /* EXP is unsigned and not in the range [1, MAX].  That means\n \t     it's either zero or greater than MAX.  Even though 0 would\n \t     normally be detected by -Walloc-zero set the range to\n \t     [MAX, TYPE_MAX] so that when MAX is greater than the limit\n \t     the whole range is diagnosed.  */\n \t  min = max + 1;\n-\t  max = wmaxval;\n+\t  max = wi::to_wide (TYPE_MAX_VALUE (exptype));\n \t}\n       else\n \t{\n \t  max = min - 1;\n-\t  min = wzero;\n+\t  min = wi::zero (expprec);\n \t}\n     }\n "}, {"sha": "d8da3dd76cdffe783975785ed1b25abd3d6ab8c5", "filename": "gcc/cgraph.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -626,7 +626,7 @@ cgraph_node::create_thunk (tree alias, tree, bool this_adjusting,\n \n   /* Make sure that if VIRTUAL_OFFSET is in sync with VIRTUAL_VALUE.  */\n   gcc_checking_assert (virtual_offset\n-\t\t       ? wi::eq_p (virtual_offset, virtual_value)\n+\t\t       ? virtual_value == wi::to_wide (virtual_offset)\n \t\t       : virtual_value == 0);\n \n   node->thunk.fixed_offset = fixed_offset;"}, {"sha": "6b3a7566bc1e32f71cdf0bed9f05296771581293", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -11039,7 +11039,8 @@ aapcs_vfp_sub_candidate (const_tree type, machine_mode *modep)\n \t\t      - tree_to_uhwi (TYPE_MIN_VALUE (index)));\n \n \t/* There must be no padding.  */\n-\tif (wi::ne_p (TYPE_SIZE (type), count * GET_MODE_BITSIZE (*modep)))\n+\tif (wi::to_wide (TYPE_SIZE (type))\n+\t    != count * GET_MODE_BITSIZE (*modep))\n \t  return -1;\n \n \treturn count;\n@@ -11069,7 +11070,8 @@ aapcs_vfp_sub_candidate (const_tree type, machine_mode *modep)\n \t  }\n \n \t/* There must be no padding.  */\n-\tif (wi::ne_p (TYPE_SIZE (type), count * GET_MODE_BITSIZE (*modep)))\n+\tif (wi::to_wide (TYPE_SIZE (type))\n+\t    != count * GET_MODE_BITSIZE (*modep))\n \t  return -1;\n \n \treturn count;\n@@ -11101,7 +11103,8 @@ aapcs_vfp_sub_candidate (const_tree type, machine_mode *modep)\n \t  }\n \n \t/* There must be no padding.  */\n-\tif (wi::ne_p (TYPE_SIZE (type), count * GET_MODE_BITSIZE (*modep)))\n+\tif (wi::to_wide (TYPE_SIZE (type))\n+\t    != count * GET_MODE_BITSIZE (*modep))\n \t  return -1;\n \n \treturn count;"}, {"sha": "c93ad95b1a6a88915d68069ad3bc6c6e5684c528", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -5883,7 +5883,8 @@ aapcs_vfp_sub_candidate (const_tree type, machine_mode *modep)\n \t\t      - tree_to_uhwi (TYPE_MIN_VALUE (index)));\n \n \t/* There must be no padding.  */\n-\tif (wi::ne_p (TYPE_SIZE (type), count * GET_MODE_BITSIZE (*modep)))\n+\tif (wi::to_wide (TYPE_SIZE (type))\n+\t    != count * GET_MODE_BITSIZE (*modep))\n \t  return -1;\n \n \treturn count;\n@@ -5913,7 +5914,8 @@ aapcs_vfp_sub_candidate (const_tree type, machine_mode *modep)\n \t  }\n \n \t/* There must be no padding.  */\n-\tif (wi::ne_p (TYPE_SIZE (type), count * GET_MODE_BITSIZE (*modep)))\n+\tif (wi::to_wide (TYPE_SIZE (type))\n+\t    != count * GET_MODE_BITSIZE (*modep))\n \t  return -1;\n \n \treturn count;\n@@ -5945,7 +5947,8 @@ aapcs_vfp_sub_candidate (const_tree type, machine_mode *modep)\n \t  }\n \n \t/* There must be no padding.  */\n-\tif (wi::ne_p (TYPE_SIZE (type), count * GET_MODE_BITSIZE (*modep)))\n+\tif (wi::to_wide (TYPE_SIZE (type))\n+\t    != count * GET_MODE_BITSIZE (*modep))\n \t  return -1;\n \n \treturn count;"}, {"sha": "d9c8277eff547a698f65e9b2bad30ac7d06a9d70", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -14495,7 +14495,7 @@ avr_fold_builtin (tree fndecl, int n_args ATTRIBUTE_UNUSED, tree *arg,\n             break;\n           }\n \n-        tmap = wide_int_to_tree (map_type, arg[0]);\n+        tmap = wide_int_to_tree (map_type, wi::to_wide (arg[0]));\n         map = TREE_INT_CST_LOW (tmap);\n \n         if (TREE_CODE (tval) != INTEGER_CST"}, {"sha": "c95f82dc3aebb62652748ea295f8f8a8c98bebc3", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -3318,7 +3318,7 @@ bfin_local_alignment (tree type, unsigned align)\n      memcpy can use 32 bit loads/stores.  */\n   if (TYPE_SIZE (type)\n       && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST\n-      && wi::gtu_p (TYPE_SIZE (type), 8)\n+      && wi::gtu_p (wi::to_wide (TYPE_SIZE (type)), 8)\n       && align < 32)\n     return 32;\n   return align;"}, {"sha": "e633b88f6b0c7f2a0b7aa3bfc3d9e66c3d915537", "filename": "gcc/config/darwin.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fconfig%2Fdarwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fconfig%2Fdarwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -1319,13 +1319,13 @@ darwin_mergeable_constant_section (tree exp,\n \n       if (TREE_CODE (size) == INTEGER_CST)\n \t{\n-\t  if (wi::eq_p (size, 4))\n+\t  if (wi::to_wide (size) == 4)\n \t    return darwin_sections[literal4_section];\n-\t  else if (wi::eq_p (size, 8))\n+\t  else if (wi::to_wide (size) == 8)\n \t    return darwin_sections[literal8_section];\n \t  else if (HAVE_GAS_LITERAL16\n \t\t   && TARGET_64BIT\n-\t\t   && wi::eq_p (size, 16))\n+\t\t   && wi::to_wide (size) == 16)\n \t    return darwin_sections[literal16_section];\n \t}\n     }"}, {"sha": "d6f913ac411a97783d82f79310e9576ee4f1bad4", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -31670,12 +31670,12 @@ ix86_data_alignment (tree type, int align, bool opt)\n       && TYPE_SIZE (type)\n       && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST)\n     {\n-      if (wi::geu_p (TYPE_SIZE (type), max_align_compat)\n+      if (wi::geu_p (wi::to_wide (TYPE_SIZE (type)), max_align_compat)\n \t  && align < max_align_compat)\n \talign = max_align_compat;\n-       if (wi::geu_p (TYPE_SIZE (type), max_align)\n-\t   && align < max_align)\n-\t align = max_align;\n+      if (wi::geu_p (wi::to_wide (TYPE_SIZE (type)), max_align)\n+\t  && align < max_align)\n+\talign = max_align;\n     }\n \n   /* x86-64 ABI requires arrays greater than 16 bytes to be aligned\n@@ -31685,7 +31685,7 @@ ix86_data_alignment (tree type, int align, bool opt)\n       if ((opt ? AGGREGATE_TYPE_P (type) : TREE_CODE (type) == ARRAY_TYPE)\n \t  && TYPE_SIZE (type)\n \t  && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST\n-\t  && wi::geu_p (TYPE_SIZE (type), 128)\n+\t  && wi::geu_p (wi::to_wide (TYPE_SIZE (type)), 128)\n \t  && align < 128)\n \treturn 128;\n     }\n@@ -31804,7 +31804,7 @@ ix86_local_alignment (tree exp, machine_mode mode,\n \t\t  != TYPE_MAIN_VARIANT (va_list_type_node)))\n \t  && TYPE_SIZE (type)\n \t  && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST\n-\t  && wi::geu_p (TYPE_SIZE (type), 128)\n+\t  && wi::geu_p (wi::to_wide (TYPE_SIZE (type)), 128)\n \t  && align < 128)\n \treturn 128;\n     }"}, {"sha": "4f32fc855e592d10472a86ca6eee4af64f312285", "filename": "gcc/config/msp430/msp430.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -1877,7 +1877,7 @@ msp430_attr (tree * node,\n \t  break;\n \n \tcase INTEGER_CST:\n-\t  if (wi::gtu_p (value, 63))\n+\t  if (wi::gtu_p (wi::to_wide (value), 63))\n \t    /* Allow the attribute to be added - the linker script\n \t       being used may still recognise this value.  */\n \t    warning (OPT_Wattributes,"}, {"sha": "c1eb66abc171cc7ff62a3050c002289ca5e40d13", "filename": "gcc/config/nds32/nds32.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fconfig%2Fnds32%2Fnds32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fconfig%2Fnds32%2Fnds32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -2576,8 +2576,8 @@ nds32_insert_attributes (tree decl, tree *attributes)\n \t      id = TREE_VALUE (id_list);\n \t      /* Issue error if it is not a valid integer value.  */\n \t      if (TREE_CODE (id) != INTEGER_CST\n-\t\t  || wi::ltu_p (id, lower_bound)\n-\t\t  || wi::gtu_p (id, upper_bound))\n+\t\t  || wi::ltu_p (wi::to_wide (id), lower_bound)\n+\t\t  || wi::gtu_p (wi::to_wide (id), upper_bound))\n \t\terror (\"invalid id value for interrupt/exception attribute\");\n \n \t      /* Advance to next id.  */\n@@ -2604,8 +2604,8 @@ nds32_insert_attributes (tree decl, tree *attributes)\n \n \t  /* 3. Check valid integer value for reset.  */\n \t  if (TREE_CODE (id) != INTEGER_CST\n-\t      || wi::ltu_p (id, lower_bound)\n-\t      || wi::gtu_p (id, upper_bound))\n+\t      || wi::ltu_p (wi::to_wide (id), lower_bound)\n+\t      || wi::gtu_p (wi::to_wide (id), upper_bound))\n \t    error (\"invalid id value for reset attribute\");\n \n \t  /* 4. Check valid function for nmi/warm.  */"}, {"sha": "661480fd479f5e8dd0196457fdd0677e85669410", "filename": "gcc/config/powerpcspe/powerpcspe-c.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe-c.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -6055,7 +6055,8 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t  /* If the second argument is an integer constant, if the value is in\n \t     the expected range, generate the built-in code if we can.  We need\n \t     64-bit and direct move to extract the small integer vectors.  */\n-\t  if (TREE_CODE (arg2) == INTEGER_CST && wi::ltu_p (arg2, nunits))\n+\t  if (TREE_CODE (arg2) == INTEGER_CST\n+\t      && wi::ltu_p (wi::to_wide (arg2), nunits))\n \t    {\n \t      switch (mode)\n \t\t{\n@@ -6217,7 +6218,7 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n       mode = TYPE_MODE (arg1_type);\n       if ((mode == V2DFmode || mode == V2DImode) && VECTOR_UNIT_VSX_P (mode)\n \t  && TREE_CODE (arg2) == INTEGER_CST\n-\t  && wi::ltu_p (arg2, 2))\n+\t  && wi::ltu_p (wi::to_wide (arg2), 2))\n \t{\n \t  tree call = NULL_TREE;\n \n@@ -6233,7 +6234,7 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t}\n       else if (mode == V1TImode && VECTOR_UNIT_VSX_P (mode)\n \t       && TREE_CODE (arg2) == INTEGER_CST\n-\t       && wi::eq_p (arg2, 0))\n+\t       && wi::eq_p (wi::to_wide (arg2), 0))\n \t{\n \t  tree call = rs6000_builtin_decls[VSX_BUILTIN_VEC_SET_V1TI];\n "}, {"sha": "528f62da71d7ecb831f87226c798d86dcd4b43d8", "filename": "gcc/config/powerpcspe/powerpcspe.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -11617,7 +11617,8 @@ rs6000_aggregate_candidate (const_tree type, machine_mode *modep)\n \t\t      - tree_to_uhwi (TYPE_MIN_VALUE (index)));\n \n \t/* There must be no padding.  */\n-\tif (wi::ne_p (TYPE_SIZE (type), count * GET_MODE_BITSIZE (*modep)))\n+\tif (wi::to_wide (TYPE_SIZE (type))\n+\t    != count * GET_MODE_BITSIZE (*modep))\n \t  return -1;\n \n \treturn count;\n@@ -11647,7 +11648,8 @@ rs6000_aggregate_candidate (const_tree type, machine_mode *modep)\n \t  }\n \n \t/* There must be no padding.  */\n-\tif (wi::ne_p (TYPE_SIZE (type), count * GET_MODE_BITSIZE (*modep)))\n+\tif (wi::to_wide (TYPE_SIZE (type))\n+\t    != count * GET_MODE_BITSIZE (*modep))\n \t  return -1;\n \n \treturn count;\n@@ -11679,7 +11681,8 @@ rs6000_aggregate_candidate (const_tree type, machine_mode *modep)\n \t  }\n \n \t/* There must be no padding.  */\n-\tif (wi::ne_p (TYPE_SIZE (type), count * GET_MODE_BITSIZE (*modep)))\n+\tif (wi::to_wide (TYPE_SIZE (type))\n+\t    != count * GET_MODE_BITSIZE (*modep))\n \t  return -1;\n \n \treturn count;\n@@ -15936,14 +15939,15 @@ rs6000_expand_ternop_builtin (enum insn_code icode, tree exp, rtx target)\n       /* Check whether the 2nd and 3rd arguments are integer constants and in\n \t range and prepare arguments.  */\n       STRIP_NOPS (arg1);\n-      if (TREE_CODE (arg1) != INTEGER_CST || wi::geu_p (arg1, 2))\n+      if (TREE_CODE (arg1) != INTEGER_CST || wi::geu_p (wi::to_wide (arg1), 2))\n \t{\n \t  error (\"argument 2 must be 0 or 1\");\n \t  return CONST0_RTX (tmode);\n \t}\n \n       STRIP_NOPS (arg2);\n-      if (TREE_CODE (arg2) != INTEGER_CST || wi::geu_p (arg2, 16))\n+      if (TREE_CODE (arg2) != INTEGER_CST\n+\t  || wi::geu_p (wi::to_wide (arg2), 16))\n \t{\n \t  error (\"argument 3 must be in the range 0..15\");\n \t  return CONST0_RTX (tmode);"}, {"sha": "8e581249b740237ed9cec866a304dfcc8e036392", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -6253,7 +6253,8 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t  /* If the second argument is an integer constant, if the value is in\n \t     the expected range, generate the built-in code if we can.  We need\n \t     64-bit and direct move to extract the small integer vectors.  */\n-\t  if (TREE_CODE (arg2) == INTEGER_CST && wi::ltu_p (arg2, nunits))\n+\t  if (TREE_CODE (arg2) == INTEGER_CST\n+\t      && wi::ltu_p (wi::to_wide (arg2), nunits))\n \t    {\n \t      switch (mode)\n \t\t{\n@@ -6415,7 +6416,7 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n       mode = TYPE_MODE (arg1_type);\n       if ((mode == V2DFmode || mode == V2DImode) && VECTOR_UNIT_VSX_P (mode)\n \t  && TREE_CODE (arg2) == INTEGER_CST\n-\t  && wi::ltu_p (arg2, 2))\n+\t  && wi::ltu_p (wi::to_wide (arg2), 2))\n \t{\n \t  tree call = NULL_TREE;\n \n@@ -6431,7 +6432,7 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t}\n       else if (mode == V1TImode && VECTOR_UNIT_VSX_P (mode)\n \t       && TREE_CODE (arg2) == INTEGER_CST\n-\t       && wi::eq_p (arg2, 0))\n+\t       && wi::eq_p (wi::to_wide (arg2), 0))\n \t{\n \t  tree call = rs6000_builtin_decls[VSX_BUILTIN_VEC_SET_V1TI];\n "}, {"sha": "12ddd970be52af48633f0fe1218253a35b1ae7ab", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -10958,7 +10958,8 @@ rs6000_aggregate_candidate (const_tree type, machine_mode *modep)\n \t\t      - tree_to_uhwi (TYPE_MIN_VALUE (index)));\n \n \t/* There must be no padding.  */\n-\tif (wi::ne_p (TYPE_SIZE (type), count * GET_MODE_BITSIZE (*modep)))\n+\tif (wi::to_wide (TYPE_SIZE (type))\n+\t    != count * GET_MODE_BITSIZE (*modep))\n \t  return -1;\n \n \treturn count;\n@@ -10988,7 +10989,8 @@ rs6000_aggregate_candidate (const_tree type, machine_mode *modep)\n \t  }\n \n \t/* There must be no padding.  */\n-\tif (wi::ne_p (TYPE_SIZE (type), count * GET_MODE_BITSIZE (*modep)))\n+\tif (wi::to_wide (TYPE_SIZE (type))\n+\t    != count * GET_MODE_BITSIZE (*modep))\n \t  return -1;\n \n \treturn count;\n@@ -11020,7 +11022,8 @@ rs6000_aggregate_candidate (const_tree type, machine_mode *modep)\n \t  }\n \n \t/* There must be no padding.  */\n-\tif (wi::ne_p (TYPE_SIZE (type), count * GET_MODE_BITSIZE (*modep)))\n+\tif (wi::to_wide (TYPE_SIZE (type))\n+\t    != count * GET_MODE_BITSIZE (*modep))\n \t  return -1;\n \n \treturn count;\n@@ -15091,14 +15094,15 @@ rs6000_expand_ternop_builtin (enum insn_code icode, tree exp, rtx target)\n       /* Check whether the 2nd and 3rd arguments are integer constants and in\n \t range and prepare arguments.  */\n       STRIP_NOPS (arg1);\n-      if (TREE_CODE (arg1) != INTEGER_CST || wi::geu_p (arg1, 2))\n+      if (TREE_CODE (arg1) != INTEGER_CST || wi::geu_p (wi::to_wide (arg1), 2))\n \t{\n \t  error (\"argument 2 must be 0 or 1\");\n \t  return CONST0_RTX (tmode);\n \t}\n \n       STRIP_NOPS (arg2);\n-      if (TREE_CODE (arg2) != INTEGER_CST || wi::geu_p (arg2, 16))\n+      if (TREE_CODE (arg2) != INTEGER_CST\n+\t  || wi::geu_p (wi::to_wide (arg2), 16))\n \t{\n \t  error (\"argument 3 must be in the range 0..15\");\n \t  return CONST0_RTX (tmode);"}, {"sha": "3ef3c197fed830107130501470a4b29480730bdd", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -1102,11 +1102,11 @@ s390_handle_hotpatch_attribute (tree *node, tree name, tree args,\n     err = 1;\n   else if (TREE_CODE (expr) != INTEGER_CST\n \t   || !INTEGRAL_TYPE_P (TREE_TYPE (expr))\n-\t   || wi::gtu_p (expr, s390_hotpatch_hw_max))\n+\t   || wi::gtu_p (wi::to_wide (expr), s390_hotpatch_hw_max))\n     err = 1;\n   else if (TREE_CODE (expr2) != INTEGER_CST\n \t   || !INTEGRAL_TYPE_P (TREE_TYPE (expr2))\n-\t   || wi::gtu_p (expr2, s390_hotpatch_hw_max))\n+\t   || wi::gtu_p (wi::to_wide (expr2), s390_hotpatch_hw_max))\n     err = 1;\n   else\n     err = 0;"}, {"sha": "0d69bda285d0ec826024a888a10c005076378c61", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -1,3 +1,11 @@\n+2017-10-10  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* cvt.c (ignore_overflows): Use wi::to_wide when\n+\toperating on trees as wide_ints.\n+\t* decl.c (check_array_designated_initializer): Likewise.\n+\t* mangle.c (write_integer_cst): Likewise.\n+\t* semantics.c (cp_finish_omp_clause_depend_sink): Likewise.\n+\n 2017-10-10  Nathan Sidwell  <nathan@acm.org>\n \n \t* name-lookup.c (set_global_binding): Don't deal with STAT_HACK."}, {"sha": "d82293b421d1d092da32ac56e97a6f4350b9ab3e", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -582,7 +582,7 @@ ignore_overflows (tree expr, tree orig)\n     {\n       gcc_assert (!TREE_OVERFLOW (orig));\n       /* Ensure constant sharing.  */\n-      expr = wide_int_to_tree (TREE_TYPE (expr), expr);\n+      expr = wide_int_to_tree (TREE_TYPE (expr), wi::to_wide (expr));\n     }\n   return expr;\n }"}, {"sha": "5a0305597b4c04c922128682c6ad32cd4c846efa", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -5298,7 +5298,7 @@ check_array_designated_initializer (constructor_elt *ce,\n \t      == INTEGER_CST))\n \t{\n \t  /* A C99 designator is OK if it matches the current index.  */\n-\t  if (wi::eq_p (ce_index, index))\n+\t  if (wi::to_wide (ce_index) == index)\n \t    return true;\n \t  else\n \t    sorry (\"non-trivial designated initializers not supported\");"}, {"sha": "64397cdddcb63b163f1206df49a5d57cc52ad2a2", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -1725,7 +1725,7 @@ write_integer_cst (const tree cst)\n \n       type = c_common_signed_or_unsigned_type (1, TREE_TYPE (cst));\n       base = build_int_cstu (type, chunk);\n-      n = wide_int_to_tree (type, cst);\n+      n = wide_int_to_tree (type, wi::to_wide (cst));\n \n       if (sign < 0)\n \t{"}, {"sha": "77c71e71bcf4c4efb2f83dc1387c47e078c43229", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -5761,7 +5761,7 @@ cp_finish_omp_clause_depend_sink (tree sink_clause)\n       if (TREE_CODE (TREE_TYPE (decl)) == POINTER_TYPE)\n \t{\n \t  tree offset = TREE_PURPOSE (t);\n-\t  bool neg = wi::neg_p ((wide_int) offset);\n+\t  bool neg = wi::neg_p (wi::to_wide (offset));\n \t  offset = fold_unary (ABS_EXPR, TREE_TYPE (offset), offset);\n \t  decl = mark_rvalue_use (decl);\n \t  decl = convert_from_reference (decl);"}, {"sha": "0615e84fc831b37cb13a2b0e676e8b8eda7f2f48", "filename": "gcc/dbxout.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -714,27 +714,27 @@ stabstr_O (tree cst)\n \n   /* If the value is zero, the base indicator will serve as the value\n      all by itself.  */\n-  if (wi::eq_p (cst, 0))\n+  if (wi::to_wide (cst) == 0)\n     return;\n \n   /* GDB wants constants with no extra leading \"1\" bits, so\n      we need to remove any sign-extension that might be\n      present.  */\n   if (res_pres == 1)\n     {\n-      digit = wi::extract_uhwi (cst, prec - 1, 1);\n+      digit = wi::extract_uhwi (wi::to_wide (cst), prec - 1, 1);\n       stabstr_C ('0' + digit);\n     }\n   else if (res_pres == 2)\n     {\n-      digit = wi::extract_uhwi (cst, prec - 2, 2);\n+      digit = wi::extract_uhwi (wi::to_wide (cst), prec - 2, 2);\n       stabstr_C ('0' + digit);\n     }\n \n   prec -= res_pres;\n   for (i = prec - 3; i >= 0; i = i - 3)\n     {\n-      digit = wi::extract_uhwi (cst, i, 3);\n+      digit = wi::extract_uhwi (wi::to_wide (cst), i, 3);\n       stabstr_C ('0' + digit);\n     }\n }"}, {"sha": "528c1852e5de6d0155c281830ce8a16ecac029a6", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -19820,7 +19820,7 @@ add_scalar_info (dw_die_ref die, enum dwarf_attribute attr, tree value,\n \t   the precision of its type.  The precision and signedness\n \t   of the type will be necessary to re-interpret it\n \t   unambiguously.  */\n-\tadd_AT_wide (die, attr, value);\n+\tadd_AT_wide (die, attr, wi::to_wide (value));\n       return;\n     }\n \n@@ -21236,7 +21236,7 @@ gen_enumeration_type_die (tree type, dw_die_ref context_die)\n \t    /* Enumeration constants may be wider than HOST_WIDE_INT.  Handle\n \t       that here.  TODO: This should be re-worked to use correct\n \t       signed/unsigned double tags for all cases.  */\n-\t    add_AT_wide (enum_die, DW_AT_const_value, value);\n+\t    add_AT_wide (enum_die, DW_AT_const_value, wi::to_wide (value));\n \t}\n \n       add_gnat_descriptive_type_attribute (type_die, type, context_die);"}, {"sha": "d2e4d042f1bee968d10ef27b0966bb45ca3b63bf", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -11788,7 +11788,7 @@ const_vector_from_tree (tree exp)\n \tRTVEC_ELT (v, i) = CONST_FIXED_FROM_FIXED_VALUE (TREE_FIXED_CST (elt),\n \t\t\t\t\t\t\t inner);\n       else\n-\tRTVEC_ELT (v, i) = immed_wide_int_const (elt, inner);\n+\tRTVEC_ELT (v, i) = immed_wide_int_const (wi::to_wide (elt), inner);\n     }\n \n   return gen_rtx_CONST_VECTOR (mode, v);"}, {"sha": "98ac09117434dc7f49726ac6c6707edaa35a5407", "filename": "gcc/fold-const-call.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ffold-const-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ffold-const-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const-call.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -60,7 +60,8 @@ host_size_t_cst_p (tree t, size_t *size_out)\n {\n   if (types_compatible_p (size_type_node, TREE_TYPE (t))\n       && integer_cst_p (t)\n-      && wi::min_precision (t, UNSIGNED) <= sizeof (size_t) * CHAR_BIT)\n+      && (wi::min_precision (wi::to_wide (t), UNSIGNED)\n+\t  <= sizeof (size_t) * CHAR_BIT))\n     {\n       *size_out = tree_to_uhwi (t);\n       return true;\n@@ -1041,8 +1042,8 @@ fold_const_call_1 (combined_fn fn, tree type, tree arg)\n       if (SCALAR_INT_MODE_P (mode))\n \t{\n \t  wide_int result;\n-\t  if (fold_const_call_ss (&result, fn, arg, TYPE_PRECISION (type),\n-\t\t\t\t  TREE_TYPE (arg)))\n+\t  if (fold_const_call_ss (&result, fn, wi::to_wide (arg),\n+\t\t\t\t  TYPE_PRECISION (type), TREE_TYPE (arg)))\n \t    return wide_int_to_tree (type, result);\n \t}\n       return NULL_TREE;\n@@ -1322,7 +1323,8 @@ fold_const_call_1 (combined_fn fn, tree type, tree arg0, tree arg1)\n \t  /* real, int -> real.  */\n \t  REAL_VALUE_TYPE result;\n \t  if (fold_const_call_sss (&result, fn, TREE_REAL_CST_PTR (arg0),\n-\t\t\t\t   arg1, REAL_MODE_FORMAT (mode)))\n+\t\t\t\t   wi::to_wide (arg1),\n+\t\t\t\t   REAL_MODE_FORMAT (mode)))\n \t    return build_real (type, result);\n \t}\n       return NULL_TREE;\n@@ -1336,7 +1338,7 @@ fold_const_call_1 (combined_fn fn, tree type, tree arg0, tree arg1)\n \t{\n \t  /* int, real -> real.  */\n \t  REAL_VALUE_TYPE result;\n-\t  if (fold_const_call_sss (&result, fn, arg0,\n+\t  if (fold_const_call_sss (&result, fn, wi::to_wide (arg0),\n \t\t\t\t   TREE_REAL_CST_PTR (arg1),\n \t\t\t\t   REAL_MODE_FORMAT (mode)))\n \t    return build_real (type, result);"}, {"sha": "f2e1cea2038b2301bb4f076459fe213021cc2fd8", "filename": "gcc/fold-const.c", "status": "modified", "additions": 68, "deletions": 55, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -360,7 +360,7 @@ may_negate_without_overflow_p (const_tree t)\n   if (TYPE_UNSIGNED (type))\n     return false;\n \n-  return !wi::only_sign_bit_p (t);\n+  return !wi::only_sign_bit_p (wi::to_wide (t));\n }\n \n /* Determine whether an expression T can be cheaply negated using\n@@ -452,9 +452,11 @@ negate_expr_p (tree t)\n       if (INTEGRAL_TYPE_P (TREE_TYPE (t))\n \t  && ! TYPE_OVERFLOW_WRAPS (TREE_TYPE (t))\n \t  && ! ((TREE_CODE (TREE_OPERAND (t, 0)) == INTEGER_CST\n-\t\t && wi::popcount (wi::abs (TREE_OPERAND (t, 0))) != 1)\n+\t\t && (wi::popcount\n+\t\t     (wi::abs (wi::to_wide (TREE_OPERAND (t, 0))))) != 1)\n \t\t|| (TREE_CODE (TREE_OPERAND (t, 1)) == INTEGER_CST\n-\t\t    && wi::popcount (wi::abs (TREE_OPERAND (t, 1))) != 1)))\n+\t\t    && (wi::popcount\n+\t\t\t(wi::abs (wi::to_wide (TREE_OPERAND (t, 1))))) != 1)))\n \tbreak;\n \n       /* Fall through.  */\n@@ -503,7 +505,7 @@ negate_expr_p (tree t)\n       if (TREE_CODE (TREE_OPERAND (t, 1)) == INTEGER_CST)\n \t{\n \t  tree op1 = TREE_OPERAND (t, 1);\n-\t  if (wi::eq_p (op1, TYPE_PRECISION (type) - 1))\n+\t  if (wi::to_wide (op1) == TYPE_PRECISION (type) - 1)\n \t    return true;\n \t}\n       break;\n@@ -695,7 +697,7 @@ fold_negate_expr_1 (location_t loc, tree t)\n       if (TREE_CODE (TREE_OPERAND (t, 1)) == INTEGER_CST)\n \t{\n \t  tree op1 = TREE_OPERAND (t, 1);\n-\t  if (wi::eq_p (op1, TYPE_PRECISION (type) - 1))\n+\t  if (wi::to_wide (op1) == TYPE_PRECISION (type) - 1)\n \t    {\n \t      tree ntype = TYPE_UNSIGNED (type)\n \t\t\t   ? signed_type_for (type)\n@@ -959,20 +961,21 @@ int_binop_types_match_p (enum tree_code code, const_tree type1, const_tree type2\n }\n \n \n-/* Combine two integer constants ARG1 and ARG2 under operation CODE\n+/* Combine two integer constants PARG1 and PARG2 under operation CODE\n    to produce a new constant.  Return NULL_TREE if we don't know how\n    to evaluate CODE at compile-time.  */\n \n static tree\n-int_const_binop_1 (enum tree_code code, const_tree arg1, const_tree parg2,\n+int_const_binop_1 (enum tree_code code, const_tree parg1, const_tree parg2,\n \t\t   int overflowable)\n {\n   wide_int res;\n   tree t;\n-  tree type = TREE_TYPE (arg1);\n+  tree type = TREE_TYPE (parg1);\n   signop sign = TYPE_SIGN (type);\n   bool overflow = false;\n \n+  wi::tree_to_wide_ref arg1 = wi::to_wide (parg1);\n   wide_int arg2 = wi::to_wide (parg2, TYPE_PRECISION (type));\n \n   switch (code)\n@@ -1106,7 +1109,7 @@ int_const_binop_1 (enum tree_code code, const_tree arg1, const_tree parg2,\n   t = force_fit_type (type, res, overflowable,\n \t\t      (((sign == SIGNED || overflowable == -1)\n \t\t\t&& overflow)\n-\t\t       | TREE_OVERFLOW (arg1) | TREE_OVERFLOW (parg2)));\n+\t\t       | TREE_OVERFLOW (parg1) | TREE_OVERFLOW (parg2)));\n \n   return t;\n }\n@@ -1258,7 +1261,7 @@ const_binop (enum tree_code code, tree arg1, tree arg2)\n \t  {\n \t    if (TREE_CODE (arg2) != INTEGER_CST)\n \t      return NULL_TREE;\n-\t    wide_int w2 = arg2;\n+\t    wi::tree_to_wide_ref w2 = wi::to_wide (arg2);\n \t    f2.data.high = w2.elt (1);\n \t    f2.data.low = w2.ulow ();\n \t    f2.mode = SImode;\n@@ -1909,7 +1912,7 @@ fold_convert_const_int_from_real (enum tree_code code, tree type, const_tree arg\n       if (real_less (&r, &l))\n \t{\n \t  overflow = true;\n-\t  val = lt;\n+\t  val = wi::to_wide (lt);\n \t}\n     }\n \n@@ -1922,7 +1925,7 @@ fold_convert_const_int_from_real (enum tree_code code, tree type, const_tree arg\n \t  if (real_less (&u, &r))\n \t    {\n \t      overflow = true;\n-\t      val = ut;\n+\t      val = wi::to_wide (ut);\n \t    }\n \t}\n     }\n@@ -4037,7 +4040,7 @@ optimize_bit_field_compare (location_t loc, enum tree_code code,\n \n   if (lunsignedp)\n     {\n-      if (wi::lrshift (rhs, lbitsize) != 0)\n+      if (wi::lrshift (wi::to_wide (rhs), lbitsize) != 0)\n \t{\n \t  warning (0, \"comparison is always %d due to width of bit-field\",\n \t\t   code == NE_EXPR);\n@@ -4046,7 +4049,7 @@ optimize_bit_field_compare (location_t loc, enum tree_code code,\n     }\n   else\n     {\n-      wide_int tem = wi::arshift (rhs, lbitsize - 1);\n+      wide_int tem = wi::arshift (wi::to_wide (rhs), lbitsize - 1);\n       if (tem != 0 && tem != -1)\n \t{\n \t  warning (0, \"comparison is always %d due to width of bit-field\",\n@@ -4196,7 +4199,7 @@ all_ones_mask_p (const_tree mask, unsigned int size)\n   if (size > precision || TYPE_SIGN (type) == UNSIGNED)\n     return false;\n \n-  return wi::mask (size, false, precision) == mask;\n+  return wi::mask (size, false, precision) == wi::to_wide (mask);\n }\n \n /* Subroutine for fold: determine if VAL is the INTEGER_CONST that\n@@ -4222,7 +4225,7 @@ sign_bit_p (tree exp, const_tree val)\n     return NULL_TREE;\n \n   width = TYPE_PRECISION (t);\n-  if (wi::only_sign_bit_p (val, width))\n+  if (wi::only_sign_bit_p (wi::to_wide (val), width))\n     return exp;\n \n   /* Handle extension from a narrower type.  */\n@@ -5449,7 +5452,8 @@ unextend (tree c, int p, int unsignedp, tree mask)\n   /* We work by getting just the sign bit into the low-order bit, then\n      into the high-order bit, then sign-extend.  We then XOR that value\n      with C.  */\n-  temp = build_int_cst (TREE_TYPE (c), wi::extract_uhwi (c, p - 1, 1));\n+  temp = build_int_cst (TREE_TYPE (c),\n+\t\t\twi::extract_uhwi (wi::to_wide (c), p - 1, 1));\n \n   /* We must use a signed type in order to get an arithmetic right shift.\n      However, we must also avoid introducing accidental overflows, so that\n@@ -6055,7 +6059,8 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type,\n       /* For a constant, we can always simplify if we are a multiply\n \t or (for divide and modulus) if it is a multiple of our constant.  */\n       if (code == MULT_EXPR\n-\t  || wi::multiple_of_p (t, c, TYPE_SIGN (type)))\n+\t  || wi::multiple_of_p (wi::to_wide (t), wi::to_wide (c),\n+\t\t\t\tTYPE_SIGN (type)))\n \t{\n \t  tree tem = const_binop (code, fold_convert (ctype, t),\n \t\t\t\t  fold_convert (ctype, c));\n@@ -6172,7 +6177,8 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type,\n \t  && (tcode == RSHIFT_EXPR || TYPE_UNSIGNED (TREE_TYPE (op0)))\n \t  /* const_binop may not detect overflow correctly,\n \t     so check for it explicitly here.  */\n-\t  && wi::gtu_p (TYPE_PRECISION (TREE_TYPE (size_one_node)), op1)\n+\t  && wi::gtu_p (TYPE_PRECISION (TREE_TYPE (size_one_node)),\n+\t\t\twi::to_wide (op1))\n \t  && 0 != (t1 = fold_convert (ctype,\n \t\t\t\t      const_binop (LSHIFT_EXPR,\n \t\t\t\t\t\t   size_one_node,\n@@ -6241,7 +6247,8 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type,\n       /* If it's a multiply or a division/modulus operation of a multiple\n          of our constant, do the operation and verify it doesn't overflow.  */\n       if (code == MULT_EXPR\n-\t  || wi::multiple_of_p (op1, c, TYPE_SIGN (type)))\n+\t  || wi::multiple_of_p (wi::to_wide (op1), wi::to_wide (c),\n+\t\t\t\tTYPE_SIGN (type)))\n \t{\n \t  op1 = const_binop (code, fold_convert (ctype, op1),\n \t\t\t     fold_convert (ctype, c));\n@@ -6280,7 +6287,8 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type,\n \t  /* If the multiplication can overflow we cannot optimize this.  */\n \t  && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (t))\n \t  && TREE_CODE (TREE_OPERAND (t, 1)) == INTEGER_CST\n-\t  && wi::multiple_of_p (op1, c, TYPE_SIGN (type)))\n+\t  && wi::multiple_of_p (wi::to_wide (op1), wi::to_wide (c),\n+\t\t\t\tTYPE_SIGN (type)))\n \t{\n \t  *strict_overflow_p = true;\n \t  return omit_one_operand (type, integer_zero_node, op0);\n@@ -6342,7 +6350,8 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type,\n \t\t  && code != FLOOR_MOD_EXPR && code != ROUND_MOD_EXPR\n \t\t  && code != MULT_EXPR)))\n \t{\n-\t  if (wi::multiple_of_p (op1, c, TYPE_SIGN (type)))\n+\t  if (wi::multiple_of_p (wi::to_wide (op1), wi::to_wide (c),\n+\t\t\t\t TYPE_SIGN (type)))\n \t    {\n \t      if (TYPE_OVERFLOW_UNDEFINED (ctype))\n \t\t*strict_overflow_p = true;\n@@ -6351,7 +6360,8 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type,\n \t\t\t\t\t\tconst_binop (TRUNC_DIV_EXPR,\n \t\t\t\t\t\t\t     op1, c)));\n \t    }\n-\t  else if (wi::multiple_of_p (c, op1, TYPE_SIGN (type)))\n+\t  else if (wi::multiple_of_p (wi::to_wide (c), wi::to_wide (op1),\n+\t\t\t\t      TYPE_SIGN (type)))\n \t    {\n \t      if (TYPE_OVERFLOW_UNDEFINED (ctype))\n \t\t*strict_overflow_p = true;\n@@ -6534,7 +6544,7 @@ fold_div_compare (enum tree_code code, tree c1, tree c2, tree *lo,\n \n   /* We have to do this the hard way to detect unsigned overflow.\n      prod = int_const_binop (MULT_EXPR, c1, c2);  */\n-  wide_int val = wi::mul (c1, c2, sign, &overflow);\n+  wide_int val = wi::mul (wi::to_wide (c1), wi::to_wide (c2), sign, &overflow);\n   prod = force_fit_type (type, val, -1, overflow);\n   *neg_overflow = false;\n \n@@ -6544,7 +6554,7 @@ fold_div_compare (enum tree_code code, tree c1, tree c2, tree *lo,\n       *lo = prod;\n \n       /* Likewise *hi = int_const_binop (PLUS_EXPR, prod, tmp).  */\n-      val = wi::add (prod, tmp, sign, &overflow);\n+      val = wi::add (wi::to_wide (prod), wi::to_wide (tmp), sign, &overflow);\n       *hi = force_fit_type (type, val, -1, overflow | TREE_OVERFLOW (prod));\n     }\n   else if (tree_int_cst_sgn (c1) >= 0)\n@@ -6688,7 +6698,7 @@ fold_single_bit_test (location_t loc, enum tree_code code,\n       if (TREE_CODE (inner) == RSHIFT_EXPR\n \t  && TREE_CODE (TREE_OPERAND (inner, 1)) == INTEGER_CST\n \t  && bitnum < TYPE_PRECISION (type)\n-\t  && wi::ltu_p (TREE_OPERAND (inner, 1),\n+\t  && wi::ltu_p (wi::to_wide (TREE_OPERAND (inner, 1)),\n \t\t\tTYPE_PRECISION (type) - bitnum))\n \t{\n \t  bitnum += tree_to_uhwi (TREE_OPERAND (inner, 1));\n@@ -6868,7 +6878,7 @@ fold_plusminus_mult_expr (location_t loc, enum tree_code code, tree type,\n       arg10 = build_one_cst (type);\n       /* As we canonicalize A - 2 to A + -2 get rid of that sign for\n \t the purpose of this canonicalization.  */\n-      if (wi::neg_p (arg1, TYPE_SIGN (TREE_TYPE (arg1)))\n+      if (wi::neg_p (wi::to_wide (arg1), TYPE_SIGN (TREE_TYPE (arg1)))\n \t  && negate_expr_p (arg1)\n \t  && code == PLUS_EXPR)\n \t{\n@@ -6960,7 +6970,8 @@ fold_plusminus_mult_expr (location_t loc, enum tree_code code, tree type,\n   /* If the sum evaluated to a constant that is not -INF the multiplication\n      cannot overflow.  */\n   if (TREE_CODE (tem) == INTEGER_CST\n-      && ! wi::eq_p (tem, wi::min_value (TYPE_PRECISION (utype), SIGNED)))\n+      && (wi::to_wide (tem)\n+\t  != wi::min_value (TYPE_PRECISION (utype), SIGNED)))\n     return fold_build2_loc (loc, MULT_EXPR, type,\n \t\t\t    fold_convert (type, tem), same);\n \n@@ -8215,7 +8226,7 @@ pointer_may_wrap_p (tree base, tree offset, HOST_WIDE_INT bitpos)\n   else if (TREE_CODE (offset) != INTEGER_CST || TREE_OVERFLOW (offset))\n     return true;\n   else\n-    wi_offset = offset;\n+    wi_offset = wi::to_wide (offset);\n \n   bool overflow;\n   wide_int units = wi::shwi (bitpos / BITS_PER_UNIT, precision);\n@@ -9017,7 +9028,7 @@ expr_not_equal_to (tree t, const wide_int &w)\n   switch (TREE_CODE (t))\n     {\n     case INTEGER_CST:\n-      return wi::ne_p (t, w);\n+      return wi::to_wide (t) != w;\n \n     case SSA_NAME:\n       if (!INTEGRAL_TYPE_P (TREE_TYPE (t)))\n@@ -9876,8 +9887,8 @@ fold_binary_loc (location_t loc,\n \t  && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST)\n \t{\n \t  int width = TYPE_PRECISION (type), w;\n-\t  wide_int c1 = TREE_OPERAND (arg0, 1);\n-\t  wide_int c2 = arg1;\n+\t  wide_int c1 = wi::to_wide (TREE_OPERAND (arg0, 1));\n+\t  wide_int c2 = wi::to_wide (arg1);\n \n \t  /* If (C1&C2) == C1, then (X&C1)|C2 becomes (X,C2).  */\n \t  if ((c1 & c2) == c1)\n@@ -9979,7 +9990,7 @@ fold_binary_loc (location_t loc,\n          multiple of 1 << CST.  */\n       if (TREE_CODE (arg1) == INTEGER_CST)\n \t{\n-\t  wide_int cst1 = arg1;\n+\t  wi::tree_to_wide_ref cst1 = wi::to_wide (arg1);\n \t  wide_int ncst1 = -cst1;\n \t  if ((cst1 & ncst1) == ncst1\n \t      && multiple_of_p (type, arg0,\n@@ -9993,8 +10004,9 @@ fold_binary_loc (location_t loc,\n \t  && TREE_CODE (arg0) == MULT_EXPR\n \t  && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST)\n \t{\n-\t  wide_int warg1 = arg1;\n-\t  wide_int masked = mask_with_tz (type, warg1, TREE_OPERAND (arg0, 1));\n+\t  wi::tree_to_wide_ref warg1 = wi::to_wide (arg1);\n+\t  wide_int masked\n+\t    = mask_with_tz (type, warg1, wi::to_wide (TREE_OPERAND (arg0, 1)));\n \n \t  if (masked == 0)\n \t    return omit_two_operands_loc (loc, type, build_zero_cst (type),\n@@ -10021,7 +10033,7 @@ fold_binary_loc (location_t loc,\n \t If B is constant and (B & M) == 0, fold into A & M.  */\n       if (TREE_CODE (arg1) == INTEGER_CST)\n \t{\n-\t  wide_int cst1 = arg1;\n+\t  wi::tree_to_wide_ref cst1 = wi::to_wide (arg1);\n \t  if ((~cst1 != 0) && (cst1 & (cst1 + 1)) == 0\n \t      && INTEGRAL_TYPE_P (TREE_TYPE (arg0))\n \t      && (TREE_CODE (arg0) == PLUS_EXPR\n@@ -10057,8 +10069,7 @@ fold_binary_loc (location_t loc,\n \t\t    if (TREE_CODE (TREE_OPERAND (pmop[which], 1))\n \t\t\t!= INTEGER_CST)\n \t\t      break;\n-\t\t    cst0 = TREE_OPERAND (pmop[which], 1);\n-\t\t    cst0 &= cst1;\n+\t\t    cst0 = wi::to_wide (TREE_OPERAND (pmop[which], 1)) & cst1;\n \t\t    if (TREE_CODE (pmop[which]) == BIT_AND_EXPR)\n \t\t      {\n \t\t\tif (cst0 != cst1)\n@@ -10076,7 +10087,7 @@ fold_binary_loc (location_t loc,\n \t\t       omitted (assumed 0).  */\n \t\t    if ((TREE_CODE (arg0) == PLUS_EXPR\n \t\t\t || (TREE_CODE (arg0) == MINUS_EXPR && which == 0))\n-\t\t\t&& (cst1 & pmop[which]) == 0)\n+\t\t\t&& (cst1 & wi::to_wide (pmop[which])) == 0)\n \t\t      pmop[which] = NULL;\n \t\t    break;\n \t\t  default:\n@@ -10134,7 +10145,7 @@ fold_binary_loc (location_t loc,\n \t{\n \t  prec = element_precision (TREE_TYPE (TREE_OPERAND (arg0, 0)));\n \n-\t  wide_int mask = wide_int::from (arg1, prec, UNSIGNED);\n+\t  wide_int mask = wide_int::from (wi::to_wide (arg1), prec, UNSIGNED);\n \t  if (mask == -1)\n \t    return\n \t      fold_convert_loc (loc, type, TREE_OPERAND (arg0, 0));\n@@ -10177,7 +10188,7 @@ fold_binary_loc (location_t loc,\n \t    {\n \t      tree sh_cnt = TREE_OPERAND (arg1, 1);\n \t      tree pow2 = build_int_cst (TREE_TYPE (sh_cnt),\n-\t\t\t\t\t wi::exact_log2 (sval));\n+\t\t\t\t\t wi::exact_log2 (wi::to_wide (sval)));\n \n \t      if (strict_overflow_p)\n \t\tfold_overflow_warning ((\"assuming signed overflow does not \"\n@@ -10308,7 +10319,8 @@ fold_binary_loc (location_t loc,\n       if (code == RROTATE_EXPR && TREE_CODE (arg1) == INTEGER_CST\n \t  && TREE_CODE (arg0) == RROTATE_EXPR\n \t  && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST\n-\t  && wi::umod_trunc (wi::add (arg1, TREE_OPERAND (arg0, 1)),\n+\t  && wi::umod_trunc (wi::to_wide (arg1)\n+\t\t\t     + wi::to_wide (TREE_OPERAND (arg0, 1)),\n \t\t\t     prec) == 0)\n \treturn fold_convert_loc (loc, type, TREE_OPERAND (arg0, 0));\n \n@@ -10595,7 +10607,7 @@ fold_binary_loc (location_t loc,\n \t  prec = TYPE_PRECISION (itype);\n \n \t  /* Check for a valid shift count.  */\n-\t  if (wi::ltu_p (arg001, prec))\n+\t  if (wi::ltu_p (wi::to_wide (arg001), prec))\n \t    {\n \t      tree arg01 = TREE_OPERAND (arg0, 1);\n \t      tree arg000 = TREE_OPERAND (TREE_OPERAND (arg0, 0), 0);\n@@ -10671,7 +10683,7 @@ fold_binary_loc (location_t loc,\n \t  tree arg00 = TREE_OPERAND (arg0, 0);\n \t  tree arg01 = TREE_OPERAND (arg0, 1);\n \t  tree itype = TREE_TYPE (arg00);\n-\t  if (wi::eq_p (arg01, element_precision (itype) - 1))\n+\t  if (wi::to_wide (arg01) == element_precision (itype) - 1)\n \t    {\n \t      if (TYPE_UNSIGNED (itype))\n \t\t{\n@@ -11421,7 +11433,7 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n \t\t(inner_width, outer_width - inner_width, false,\n \t\t TYPE_PRECISION (TREE_TYPE (arg1)));\n \n-\t      wide_int common = mask & arg1;\n+\t      wide_int common = mask & wi::to_wide (arg1);\n \t      if (common == mask)\n \t\t{\n \t\t  tem_type = signed_type_for (TREE_TYPE (tem));\n@@ -11644,7 +11656,7 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n \n \t      /* Make sure that the perm value is in an acceptable\n \t\t range.  */\n-\t      wide_int t = val;\n+\t      wi::tree_to_wide_ref t = wi::to_wide (val);\n \t      need_mask_canon |= wi::gtu_p (t, mask);\n \t      need_mask_canon2 |= wi::gtu_p (t, mask2);\n \t      unsigned int elt = t.to_uhwi () & mask;\n@@ -11726,9 +11738,9 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n \t{\n \t  unsigned HOST_WIDE_INT bitpos = tree_to_uhwi (op2);\n \t  unsigned bitsize = TYPE_PRECISION (TREE_TYPE (arg1));\n-\t  wide_int tem = wi::bit_and (arg0,\n-\t\t\t\t      wi::shifted_mask (bitpos, bitsize, true,\n-\t\t\t\t\t\t\tTYPE_PRECISION (type)));\n+\t  wide_int tem = (wi::to_wide (arg0)\n+\t\t\t  & wi::shifted_mask (bitpos, bitsize, true,\n+\t\t\t\t\t      TYPE_PRECISION (type)));\n \t  wide_int tem2\n \t    = wi::lshift (wi::zext (wi::to_wide (arg1, TYPE_PRECISION (type)),\n \t\t\t\t    bitsize), bitpos);\n@@ -12548,7 +12560,8 @@ multiple_of_p (tree type, const_tree top, const_tree bottom)\n \t  op1 = TREE_OPERAND (top, 1);\n \t  /* const_binop may not detect overflow correctly,\n \t     so check for it explicitly here.  */\n-\t  if (wi::gtu_p (TYPE_PRECISION (TREE_TYPE (size_one_node)), op1)\n+\t  if (wi::gtu_p (TYPE_PRECISION (TREE_TYPE (size_one_node)),\n+\t\t\t wi::to_wide (op1))\n \t      && 0 != (t1 = fold_convert (type,\n \t\t\t\t\t  const_binop (LSHIFT_EXPR,\n \t\t\t\t\t\t       size_one_node,\n@@ -13682,7 +13695,7 @@ fold_negate_const (tree arg0, tree type)\n     case INTEGER_CST:\n       {\n \tbool overflow;\n-\twide_int val = wi::neg (arg0, &overflow);\n+\twide_int val = wi::neg (wi::to_wide (arg0), &overflow);\n \tt = force_fit_type (type, val, 1,\n \t\t\t    (overflow && ! TYPE_UNSIGNED (type))\n \t\t\t    || TREE_OVERFLOW (arg0));\n@@ -13729,15 +13742,15 @@ fold_abs_const (tree arg0, tree type)\n       {\n         /* If the value is unsigned or non-negative, then the absolute value\n \t   is the same as the ordinary value.  */\n-\tif (!wi::neg_p (arg0, TYPE_SIGN (type)))\n+\tif (!wi::neg_p (wi::to_wide (arg0), TYPE_SIGN (type)))\n \t  t = arg0;\n \n \t/* If the value is negative, then the absolute value is\n \t   its negation.  */\n \telse\n \t  {\n \t    bool overflow;\n-\t    wide_int val = wi::neg (arg0, &overflow);\n+\t    wide_int val = wi::neg (wi::to_wide (arg0), &overflow);\n \t    t = force_fit_type (type, val, -1,\n \t\t\t\toverflow | TREE_OVERFLOW (arg0));\n \t  }\n@@ -13766,7 +13779,7 @@ fold_not_const (const_tree arg0, tree type)\n {\n   gcc_assert (TREE_CODE (arg0) == INTEGER_CST);\n \n-  return force_fit_type (type, wi::bit_not (arg0), 0, TREE_OVERFLOW (arg0));\n+  return force_fit_type (type, ~wi::to_wide (arg0), 0, TREE_OVERFLOW (arg0));\n }\n \n /* Given CODE, a relational operator, the target type, TYPE and two\n@@ -14221,7 +14234,7 @@ round_up_loc (location_t loc, tree value, unsigned int divisor)\n     {\n       if (TREE_CODE (value) == INTEGER_CST)\n \t{\n-\t  wide_int val = value;\n+\t  wide_int val = wi::to_wide (value);\n \t  bool overflow_p;\n \n \t  if ((val & (divisor - 1)) == 0)"}, {"sha": "926bee73529be45dc7e46f4f31bdb36c0c26e90f", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -1,3 +1,13 @@\n+2017-10-10  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* target-memory.c (gfc_interpret_logical): Use wi::to_wide when\n+\toperating on trees as wide_ints.\n+\t* trans-const.c (gfc_conv_tree_to_mpz): Likewise.\n+\t* trans-expr.c (gfc_conv_cst_int_power): Likewise.\n+\t* trans-intrinsic.c (trans_this_image): Likewise.\n+\t(gfc_conv_intrinsic_bound): Likewise.\n+\t(conv_intrinsic_cobound): Likewise.\n+\n 2017-10-08  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \t* check.c (gfc_check_x): Remove function."}, {"sha": "b2fe8eee01c18499ea11212093c7bd41f1e2c9dd", "filename": "gcc/fortran/target-memory.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ffortran%2Ftarget-memory.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ffortran%2Ftarget-memory.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftarget-memory.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -429,7 +429,7 @@ gfc_interpret_logical (int kind, unsigned char *buffer, size_t buffer_size,\n {\n   tree t = native_interpret_expr (gfc_get_logical_type (kind), buffer,\n \t\t\t\t  buffer_size);\n-  *logical = wi::eq_p (t, 0) ? 0 : 1;\n+  *logical = wi::to_wide (t) == 0 ? 0 : 1;\n   return size_logical (kind);\n }\n "}, {"sha": "62b85f738fc21b5f545914f22aa81a8026368011", "filename": "gcc/fortran/trans-const.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ffortran%2Ftrans-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ffortran%2Ftrans-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-const.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -211,7 +211,7 @@ gfc_conv_mpz_to_tree (mpz_t i, int kind)\n void\n gfc_conv_tree_to_mpz (mpz_t i, tree source)\n {\n-  wi::to_mpz (source, i, TYPE_SIGN (TREE_TYPE (source)));\n+  wi::to_mpz (wi::to_wide (source), i, TYPE_SIGN (TREE_TYPE (source)));\n }\n \n /* Converts a real constant into backend form.  */"}, {"sha": "4e8bfc5d6f92a9275f921944afc07df8f4368616", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -2861,7 +2861,7 @@ gfc_conv_cst_int_power (gfc_se * se, tree lhs, tree rhs)\n   HOST_WIDE_INT m;\n   unsigned HOST_WIDE_INT n;\n   int sgn;\n-  wide_int wrhs = rhs;\n+  wi::tree_to_wide_ref wrhs = wi::to_wide (rhs);\n \n   /* If exponent is too large, we won't expand it anyway, so don't bother\n      with large integer values.  */"}, {"sha": "532d3ab237d035d2a53675c880a5ed76e1eb1c5e", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -2235,8 +2235,9 @@ trans_this_image (gfc_se * se, gfc_expr *expr)\n \n       if (INTEGER_CST_P (dim_arg))\n \t{\n-\t  if (wi::ltu_p (dim_arg, 1)\n-\t      || wi::gtu_p (dim_arg, GFC_TYPE_ARRAY_CORANK (TREE_TYPE (desc))))\n+\t  if (wi::ltu_p (wi::to_wide (dim_arg), 1)\n+\t      || wi::gtu_p (wi::to_wide (dim_arg),\n+\t\t\t    GFC_TYPE_ARRAY_CORANK (TREE_TYPE (desc))))\n \t    gfc_error (\"%<dim%> argument of %s intrinsic at %L is not a valid \"\n \t\t       \"dimension index\", expr->value.function.isym->name,\n \t\t       &expr->where);\n@@ -2657,8 +2658,9 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n   if (INTEGER_CST_P (bound))\n     {\n       if (((!as || as->type != AS_ASSUMED_RANK)\n-\t   && wi::geu_p (bound, GFC_TYPE_ARRAY_RANK (TREE_TYPE (desc))))\n-\t  || wi::gtu_p (bound, GFC_MAX_DIMENSIONS))\n+\t   && wi::geu_p (wi::to_wide (bound),\n+\t\t\t GFC_TYPE_ARRAY_RANK (TREE_TYPE (desc))))\n+\t  || wi::gtu_p (wi::to_wide (bound), GFC_MAX_DIMENSIONS))\n \tgfc_error (\"%<dim%> argument of %s intrinsic at %L is not a valid \"\n \t\t   \"dimension index\", upper ? \"UBOUND\" : \"LBOUND\",\n \t\t   &expr->where);\n@@ -2853,8 +2855,9 @@ conv_intrinsic_cobound (gfc_se * se, gfc_expr * expr)\n \n       if (INTEGER_CST_P (bound))\n \t{\n-\t  if (wi::ltu_p (bound, 1)\n-\t      || wi::gtu_p (bound, GFC_TYPE_ARRAY_CORANK (TREE_TYPE (desc))))\n+\t  if (wi::ltu_p (wi::to_wide (bound), 1)\n+\t      || wi::gtu_p (wi::to_wide (bound),\n+\t\t\t    GFC_TYPE_ARRAY_CORANK (TREE_TYPE (desc))))\n \t    gfc_error (\"%<dim%> argument of %s intrinsic at %L is not a valid \"\n \t\t       \"dimension index\", expr->value.function.isym->name,\n \t\t       &expr->where);"}, {"sha": "cb33c1e09fe4b41aacf21e2638dfd8181a9ce759", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -6784,7 +6784,7 @@ gimple_fold_indirect_ref (tree t)\n \t  || DECL_P (TREE_OPERAND (addr, 0)))\n \treturn fold_build2 (MEM_REF, type,\n \t\t\t    addr,\n-\t\t\t    wide_int_to_tree (ptype, off));\n+\t\t\t    wide_int_to_tree (ptype, wi::to_wide (off)));\n     }\n \n   /* *(foo *)fooarrptr => (*fooarrptr)[0] */"}, {"sha": "2d255a493d024a5c34b4b4f02b45255cb9053807", "filename": "gcc/gimple-ssa-warn-alloca.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fgimple-ssa-warn-alloca.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fgimple-ssa-warn-alloca.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-alloca.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -194,7 +194,8 @@ alloca_call_type_by_arg (tree arg, tree arg_casted, edge e, unsigned max_size)\n \t      // degrade into \"if (N > Y) alloca(N)\".\n \t      if (cond_code == GT_EXPR || cond_code == GE_EXPR)\n \t\trhs = integer_zero_node;\n-\t      return alloca_type_and_limit (ALLOCA_BOUND_MAYBE_LARGE, rhs);\n+\t      return alloca_type_and_limit (ALLOCA_BOUND_MAYBE_LARGE,\n+\t\t\t\t\t    wi::to_wide (rhs));\n \t    }\n \t}\n       else\n@@ -294,7 +295,8 @@ alloca_call_type (gimple *stmt, bool is_vla, tree *invalid_casted_type)\n   if (TREE_CODE (len) == INTEGER_CST)\n     {\n       if (tree_to_uhwi (len) > max_size)\n-\treturn alloca_type_and_limit (ALLOCA_BOUND_DEFINITELY_LARGE, len);\n+\treturn alloca_type_and_limit (ALLOCA_BOUND_DEFINITELY_LARGE,\n+\t\t\t\t      wi::to_wide (len));\n       if (integer_zerop (len))\n \treturn alloca_type_and_limit (ALLOCA_ARG_IS_ZERO);\n       ret = alloca_type_and_limit (ALLOCA_OK);"}, {"sha": "79213b22c24d769e3945f32533c47c69f0f815c9", "filename": "gcc/gimple.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -2965,13 +2965,14 @@ preprocess_case_label_vec_for_gimple (vec<tree> labels,\n \n \t\t  if (CASE_HIGH (labels[i]) != NULL_TREE\n \t\t      && (CASE_HIGH (widest_label) == NULL_TREE\n-\t\t\t  || wi::gtu_p (wi::sub (CASE_HIGH (labels[i]),\n-\t\t\t\t\t\t CASE_LOW (labels[i])),\n-\t\t\t\t\twi::sub (CASE_HIGH (widest_label),\n-\t\t\t\t\t\t CASE_LOW (widest_label)))))\n+\t\t\t  || (wi::gtu_p\n+\t\t\t      (wi::to_wide (CASE_HIGH (labels[i]))\n+\t\t\t       - wi::to_wide (CASE_LOW (labels[i])),\n+\t\t\t       wi::to_wide (CASE_HIGH (widest_label))\n+\t\t\t       - wi::to_wide (CASE_LOW (widest_label))))))\n \t\t    widest_label = labels[i];\n \n-\t\t  if (wi::add (low, 1) != high)\n+\t\t  if (wi::to_wide (low) + 1 != wi::to_wide (high))\n \t\t    break;\n \t\t}\n \t      if (i == len)"}, {"sha": "9a9d70fd59e77179af1078c0b212db7c5f78527e", "filename": "gcc/godump.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fgodump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fgodump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgodump.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -1159,7 +1159,7 @@ go_output_typedef (struct godump_container *container, tree decl)\n \t    snprintf (buf, sizeof buf, HOST_WIDE_INT_PRINT_UNSIGNED,\n \t\t      tree_to_uhwi (TREE_VALUE (element)));\n \t  else\n-\t    print_hex (element, buf);\n+\t    print_hex (wi::to_wide (element), buf);\n \n \t  mhval->value = xstrdup (buf);\n \t  *slot = mhval;"}, {"sha": "0e6824bbd454c09fe7664da9fbb811997752b93c", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -63,7 +63,7 @@ along with GCC; see the file COPYING3.  If not see\n static inline void\n tree_int_to_gmp (tree t, mpz_t res)\n {\n-  wi::to_mpz (t, res, TYPE_SIGN (TREE_TYPE (t)));\n+  wi::to_mpz (wi::to_wide (t), res, TYPE_SIGN (TREE_TYPE (t)));\n }\n \n /* Return an isl identifier for the polyhedral basic block PBB.  */"}, {"sha": "d9e243e154729aab97450e6c9b278954bad89ef1", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -485,7 +485,7 @@ get_min_precision (tree arg, signop sign)\n \t  p = wi::min_precision (w, sign);\n \t}\n       else\n-\tp = wi::min_precision (arg, sign);\n+\tp = wi::min_precision (wi::to_wide (arg), sign);\n       return MIN (p, prec);\n     }\n   while (CONVERT_EXPR_P (arg)"}, {"sha": "d23c1d8ba3eca35cdcb4ab550e5edd9aa06fdd21", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -4971,8 +4971,8 @@ ipcp_store_vr_results (void)\n \t    {\n \t      vr.known = true;\n \t      vr.type = plats->m_value_range.m_vr.type;\n-\t      vr.min = plats->m_value_range.m_vr.min;\n-\t      vr.max = plats->m_value_range.m_vr.max;\n+\t      vr.min = wi::to_wide (plats->m_value_range.m_vr.min);\n+\t      vr.max = wi::to_wide (plats->m_value_range.m_vr.max);\n \t    }\n \t  else\n \t    {"}, {"sha": "1c5aca4abdcfe4f9f1871092b326a23d3a259996", "filename": "gcc/ipa-polymorphic-call.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fipa-polymorphic-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fipa-polymorphic-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-polymorphic-call.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -967,8 +967,9 @@ ipa_polymorphic_call_context::ipa_polymorphic_call_context (tree fndecl,\n       else if (TREE_CODE (base_pointer) == POINTER_PLUS_EXPR\n \t       && TREE_CODE (TREE_OPERAND (base_pointer, 1)) == INTEGER_CST)\n \t{\n-\t  offset_int o = offset_int::from (TREE_OPERAND (base_pointer, 1),\n-\t\t\t\t\t   SIGNED);\n+\t  offset_int o\n+\t    = offset_int::from (wi::to_wide (TREE_OPERAND (base_pointer, 1)),\n+\t\t\t\tSIGNED);\n \t  o *= BITS_PER_UNIT;\n \t  o += offset;\n \t  if (!wi::fits_shwi_p (o))"}, {"sha": "a687f7cb29e9961b44539b9b3fe483ca0a3879f0", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -397,9 +397,9 @@ ipa_print_node_jump_functions_for_edge (FILE *f, struct cgraph_edge *cs)\n \t  fprintf (f, \"         VR  \");\n \t  fprintf (f, \"%s[\",\n \t\t   (jump_func->m_vr->type == VR_ANTI_RANGE) ? \"~\" : \"\");\n-\t  print_decs (jump_func->m_vr->min, f);\n+\t  print_decs (wi::to_wide (jump_func->m_vr->min), f);\n \t  fprintf (f, \", \");\n-\t  print_decs (jump_func->m_vr->max, f);\n+\t  print_decs (wi::to_wide (jump_func->m_vr->max), f);\n \t  fprintf (f, \"]\\n\");\n \t}\n       else\n@@ -4373,7 +4373,8 @@ ipa_modify_call_arguments (struct cgraph_edge *cs, gcall *stmt,\n \t\t  if (TYPE_ALIGN (type) > align)\n \t\t    align = TYPE_ALIGN (type);\n \t\t}\n-\t      misalign += (offset_int::from (off, SIGNED).to_short_addr ()\n+\t      misalign += (offset_int::from (wi::to_wide (off),\n+\t\t\t\t\t     SIGNED).to_short_addr ()\n \t\t\t   * BITS_PER_UNIT);\n \t      misalign = misalign & (align - 1);\n \t      if (misalign != 0)"}, {"sha": "fef0f9cc96dcfb907011d54d2182086cea339365", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -1,3 +1,8 @@\n+2017-10-10  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* lto.c (compare_tree_sccs_1): Use wi::to_wide when\n+\toperating on trees as wide_ints.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "cc36851b8b679fbb70f7545d79e48b0ad57ee32e", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -1039,7 +1039,7 @@ compare_tree_sccs_1 (tree t1, tree t2, tree **map)\n \n   if (CODE_CONTAINS_STRUCT (code, TS_INT_CST))\n     {\n-      if (!wi::eq_p (t1, t2))\n+      if (wi::to_wide (t1) != wi::to_wide (t2))\n \treturn false;\n     }\n "}, {"sha": "2f8a7411d76b8333adf51cd876a016275bc7f377", "filename": "gcc/match.pd", "status": "modified", "additions": 105, "deletions": 80, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -276,7 +276,8 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n   (div (div @0 INTEGER_CST@1) INTEGER_CST@2)\n   (with {\n     bool overflow_p;\n-    wide_int mul = wi::mul (@1, @2, TYPE_SIGN (type), &overflow_p);\n+    wide_int mul = wi::mul (wi::to_wide (@1), wi::to_wide (@2),\n+\t\t\t    TYPE_SIGN (type), &overflow_p);\n    }\n    (if (!overflow_p)\n     (div @0 { wide_int_to_tree (type, mul); })\n@@ -290,7 +291,8 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n  (mult (mult @0 INTEGER_CST@1) INTEGER_CST@2)\n  (with {\n    bool overflow_p;\n-   wide_int mul = wi::mul (@1, @2, TYPE_SIGN (type), &overflow_p);\n+   wide_int mul = wi::mul (wi::to_wide (@1), wi::to_wide (@2),\n+\t\t\t   TYPE_SIGN (type), &overflow_p);\n   }\n   /* Skip folding on overflow: the only special case is @1 * @2 == -INT_MIN,\n      otherwise undefined overflow implies that @0 must be zero.  */\n@@ -359,9 +361,10 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n   (if (integer_pow2p (@2)\n        && tree_int_cst_sgn (@2) > 0\n        && tree_nop_conversion_p (type, TREE_TYPE (@0))\n-       && wi::add (@2, @1) == 0)\n-   (rshift (convert @0) { build_int_cst (integer_type_node,\n-\t\t\t\t\t wi::exact_log2 (@2)); }))))\n+       && wi::to_wide (@2) + wi::to_wide (@1) == 0)\n+   (rshift (convert @0)\n+\t   { build_int_cst (integer_type_node,\n+\t\t\t    wi::exact_log2 (wi::to_wide (@2))); }))))\n \n /* If ARG1 is a constant, we can convert this to a multiply by the\n    reciprocal.  This does not have the same rounding properties,\n@@ -414,15 +417,16 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n   (mod (mult @0 INTEGER_CST@1) INTEGER_CST@2)\n   (if (ANY_INTEGRAL_TYPE_P (type)\n        && TYPE_OVERFLOW_UNDEFINED (type)\n-       && wi::multiple_of_p (@1, @2, TYPE_SIGN (type)))\n+       && wi::multiple_of_p (wi::to_wide (@1), wi::to_wide (@2),\n+\t\t\t     TYPE_SIGN (type)))\n    { build_zero_cst (type); })))\n \n /* X % -C is the same as X % C.  */\n (simplify\n  (trunc_mod @0 INTEGER_CST@1)\n   (if (TYPE_SIGN (type) == SIGNED\n        && !TREE_OVERFLOW (@1)\n-       && wi::neg_p (@1)\n+       && wi::neg_p (wi::to_wide (@1))\n        && !TYPE_OVERFLOW_TRAPS (type)\n        /* Avoid this transformation if C is INT_MIN, i.e. C == -C.  */\n        && !sign_bit_p (@1, @1))\n@@ -438,7 +442,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n       /* Avoid this transformation if X might be INT_MIN or\n \t Y might be -1, because we would then change valid\n \t INT_MIN % -(-1) into invalid INT_MIN % -1.  */\n-      && (expr_not_equal_to (@0, TYPE_MIN_VALUE (type))\n+      && (expr_not_equal_to (@0, wi::to_wide (TYPE_MIN_VALUE (type)))\n \t  || expr_not_equal_to (@1, wi::minus_one (TYPE_PRECISION\n \t\t\t\t\t\t\t(TREE_TYPE (@1))))))\n   (trunc_mod @0 (convert @1))))\n@@ -471,7 +475,8 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n  (trunc_div (mult @0 integer_pow2p@1) @1)\n  (if (TYPE_UNSIGNED (TREE_TYPE (@0)))\n   (bit_and @0 { wide_int_to_tree\n-\t\t(type, wi::mask (TYPE_PRECISION (type) - wi::exact_log2 (@1),\n+\t\t(type, wi::mask (TYPE_PRECISION (type)\n+\t\t\t\t - wi::exact_log2 (wi::to_wide (@1)),\n \t\t\t\t false, TYPE_PRECISION (type))); })))\n \n /* Simplify (unsigned t / 2) * 2 -> unsigned t & ~1.  */\n@@ -505,7 +510,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n  (for pows (POWI)\n   (simplify\n    (pows (op @0) INTEGER_CST@1)\n-   (if (wi::bit_and (@1, 1) == 0)\n+   (if ((wi::to_wide (@1) & 1) == 0)\n     (pows @0 @1))))\n  /* Strip negate and abs from both operands of hypot.  */\n  (for hypots (HYPOT)\n@@ -546,7 +551,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n      copysigns (COPYSIGN)\n  (simplify\n   (pows (copysigns @0 @2) INTEGER_CST@1)\n-  (if (wi::bit_and (@1, 1) == 0)\n+  (if ((wi::to_wide (@1) & 1) == 0)\n    (pows @0 @1))))\n \n (for hypots (HYPOT)\n@@ -657,7 +662,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n   (minus (bit_xor @0 @1) @1))\n (simplify\n  (minus (bit_and:s @0 INTEGER_CST@2) (bit_and:s @0 INTEGER_CST@1))\n- (if (wi::bit_not (@2) == @1)\n+ (if (~wi::to_wide (@2) == wi::to_wide (@1))\n   (minus (bit_xor @0 @1) @1)))\n \n /* Fold (A & B) - (A & ~B) into B - (A ^ B).  */\n@@ -672,7 +677,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n    (bit_xor @0 @1))\n  (simplify\n   (op:c (bit_and @0 INTEGER_CST@2) (bit_and (bit_not @0) INTEGER_CST@1))\n-  (if (wi::bit_not (@2) == @1)\n+  (if (~wi::to_wide (@2) == wi::to_wide (@1))\n    (bit_xor @0 @1))))\n \n /* PR53979: Transform ((a ^ b) | a) -> (a | b) */\n@@ -685,7 +690,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n (simplify\n  (bit_and (bit_not SSA_NAME@0) INTEGER_CST@1)\n  (if (INTEGRAL_TYPE_P (TREE_TYPE (@0))\n-      && (get_nonzero_bits (@0) & wi::bit_not (@1)) == 0)\n+      && wi::bit_and_not (get_nonzero_bits (@0), wi::to_wide (@1)) == 0)\n   (bit_xor @0 @1)))\n #endif\n \n@@ -750,7 +755,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n (simplify\n  (bit_and SSA_NAME@0 INTEGER_CST@1)\n  (if (INTEGRAL_TYPE_P (TREE_TYPE (@0))\n-      && (get_nonzero_bits (@0) & wi::bit_not (@1)) == 0)\n+      && wi::bit_and_not (get_nonzero_bits (@0), wi::to_wide (@1)) == 0)\n   @0))\n #endif\n \n@@ -851,7 +856,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n       (convert2? (bit_and@5 @2 INTEGER_CST@3)))\n   (if (tree_nop_conversion_p (type, TREE_TYPE (@0))\n        && tree_nop_conversion_p (type, TREE_TYPE (@2))\n-       && wi::bit_and (@1, @3) == 0)\n+       && (wi::to_wide (@1) & wi::to_wide (@3)) == 0)\n    (bit_ior (convert @4) (convert @5)))))\n \n /* (X | Y) ^ X -> Y & ~ X*/\n@@ -1150,7 +1155,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n    (if (tree_expr_nonnegative_p (@1) && tree_expr_nonzero_p (@1))\n     (cmp @0 @2)\n    (if (TREE_CODE (@1) == INTEGER_CST\n-\t&& wi::neg_p (@1, TYPE_SIGN (TREE_TYPE (@1))))\n+\t&& wi::neg_p (wi::to_wide (@1), TYPE_SIGN (TREE_TYPE (@1))))\n     (cmp @2 @0))))))\n \n /* (X - 1U) <= INT_MAX-1U into (int) X > 0.  */\n@@ -1161,16 +1166,16 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n    (if (INTEGRAL_TYPE_P (TREE_TYPE (@0))\n \t&& TYPE_UNSIGNED (TREE_TYPE (@0))\n \t&& TYPE_PRECISION (TREE_TYPE (@0)) > 1\n-\t&& wi::eq_p (@2, wi::max_value (TYPE_PRECISION (TREE_TYPE (@0)),\n-\t\t\t\t\tSIGNED) - 1))\n+\t&& (wi::to_wide (@2)\n+\t    == wi::max_value (TYPE_PRECISION (TREE_TYPE (@0)), SIGNED) - 1))\n     (with { tree stype = signed_type_for (TREE_TYPE (@0)); }\n      (icmp (convert:stype @0) { build_int_cst (stype, 0); })))))\n \n /* X / 4 < Y / 4 iff X < Y when the division is known to be exact.  */\n (for cmp (simple_comparison)\n  (simplify\n   (cmp (exact_div @0 INTEGER_CST@2) (exact_div @1 @2))\n-  (if (wi::gt_p(@2, 0, TYPE_SIGN (TREE_TYPE (@2))))\n+  (if (wi::gt_p (wi::to_wide (@2), 0, TYPE_SIGN (TREE_TYPE (@2))))\n    (cmp @0 @1))))\n \n /* X / C1 op C2 into a simple range test.  */\n@@ -1318,7 +1323,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n (for cmp (eq ne)\n  (simplify\n   (cmp:c (with_possible_nonzero_bits2 @0) (with_certain_nonzero_bits2 @1))\n-  (if ((~get_nonzero_bits (@0) & @1) != 0)\n+  (if (wi::bit_and_not (wi::to_wide (@1), get_nonzero_bits (@0)) != 0)\n    { constant_boolean_node (cmp == NE_EXPR, type); })))\n \n /* ((X inner_op C0) outer_op C1)\n@@ -1350,18 +1355,18 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n \n     if (inner_op == BIT_XOR_EXPR)\n       {\n-\tC0 = wi::bit_and_not (@0, @1);\n-\tcst_emit = wi::bit_or (C0, @1);\n+\tC0 = wi::bit_and_not (wi::to_wide (@0), wi::to_wide (@1));\n+\tcst_emit = C0 | wi::to_wide (@1);\n       }\n     else\n       {\n-\tC0 = @0;\n-\tcst_emit = wi::bit_xor (@0, @1);\n+\tC0 = wi::to_wide (@0);\n+\tcst_emit = C0 ^ wi::to_wide (@1);\n       }\n   }\n-  (if (!fail && wi::bit_and (C0, zero_mask_not) == 0)\n+  (if (!fail && (C0 & zero_mask_not) == 0)\n    (outer_op @2 { wide_int_to_tree (type, cst_emit); })\n-   (if (!fail && wi::bit_and (@1, zero_mask_not) == 0)\n+   (if (!fail && (wi::to_wide (@1) & zero_mask_not) == 0)\n     (inner_op @2 { wide_int_to_tree (type, cst_emit); }))))))\n \n /* Associate (p +p off1) +p off2 as (p +p (off1 + off2)).  */\n@@ -1394,7 +1399,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n      ... = ptr & ~algn;  */\n (simplify\n   (pointer_plus @0 (negate (bit_and (convert @0) INTEGER_CST@1)))\n-  (with { tree algn = wide_int_to_tree (TREE_TYPE (@0), wi::bit_not (@1)); }\n+  (with { tree algn = wide_int_to_tree (TREE_TYPE (@0), ~wi::to_wide (@1)); }\n    (bit_and @0 { algn; })))\n \n /* Try folding difference of addresses.  */\n@@ -1424,8 +1429,9 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n      unsigned HOST_WIDE_INT bitpos;\n      get_pointer_alignment_1 (@0, &align, &bitpos);\n    }\n-   (if (wi::ltu_p (@1, align / BITS_PER_UNIT))\n-    { wide_int_to_tree (type, wi::bit_and (@1, bitpos / BITS_PER_UNIT)); }))))\n+   (if (wi::ltu_p (wi::to_wide (@1), align / BITS_PER_UNIT))\n+    { wide_int_to_tree (type, (wi::to_wide (@1)\n+\t\t\t       & (bitpos / BITS_PER_UNIT))); }))))\n \n \n /* We can't reassociate at all for saturating types.  */\n@@ -1535,8 +1541,8 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n \t  (inner_op @0 { cst; } )\n \t  /* X+INT_MAX+1 is X-INT_MIN.  */\n \t  (if (INTEGRAL_TYPE_P (type) && cst\n-\t       && wi::eq_p (cst, wi::min_value (type)))\n-\t   (neg_inner_op @0 { wide_int_to_tree (type, cst); })\n+\t       && wi::to_wide (cst) == wi::min_value (type))\n+\t   (neg_inner_op @0 { wide_int_to_tree (type, wi::to_wide (cst)); })\n \t   /* Last resort, use some unsigned type.  */\n \t   (with { tree utype = unsigned_type_for (type); }\n \t    (view_convert (inner_op\n@@ -1788,16 +1794,20 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n (for cmp (eq ne)\n  (simplify\n   (cmp (min @0 INTEGER_CST@1) INTEGER_CST@2)\n-  (if (wi::lt_p (@1, @2, TYPE_SIGN (TREE_TYPE (@0))))\n+  (if (wi::lt_p (wi::to_wide (@1), wi::to_wide (@2),\n+\t\t TYPE_SIGN (TREE_TYPE (@0))))\n    { constant_boolean_node (cmp == NE_EXPR, type); }\n-   (if (wi::gt_p (@1, @2, TYPE_SIGN (TREE_TYPE (@0))))\n+   (if (wi::gt_p (wi::to_wide (@1), wi::to_wide (@2),\n+\t\t  TYPE_SIGN (TREE_TYPE (@0))))\n     (cmp @0 @2)))))\n (for cmp (eq ne)\n  (simplify\n   (cmp (max @0 INTEGER_CST@1) INTEGER_CST@2)\n-  (if (wi::gt_p (@1, @2, TYPE_SIGN (TREE_TYPE (@0))))\n+  (if (wi::gt_p (wi::to_wide (@1), wi::to_wide (@2),\n+\t\t TYPE_SIGN (TREE_TYPE (@0))))\n    { constant_boolean_node (cmp == NE_EXPR, type); }\n-   (if (wi::lt_p (@1, @2, TYPE_SIGN (TREE_TYPE (@0))))\n+   (if (wi::lt_p (wi::to_wide (@1), wi::to_wide (@2),\n+\t\t  TYPE_SIGN (TREE_TYPE (@0))))\n     (cmp @0 @2)))))\n /* MIN (X, C1) < C2 -> X < C2 || C1 < C2  */\n (for minmax (min     min     max     max     min     min     max     max    )\n@@ -1824,15 +1834,15 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n /* Optimize (x >> c) << c into x & (-1<<c).  */\n (simplify\n  (lshift (rshift @0 INTEGER_CST@1) @1)\n- (if (wi::ltu_p (@1, element_precision (type)))\n+ (if (wi::ltu_p (wi::to_wide (@1), element_precision (type)))\n   (bit_and @0 (lshift { build_minus_one_cst (type); } @1))))\n \n /* Optimize (x << c) >> c into x & ((unsigned)-1 >> c) for unsigned\n    types.  */\n (simplify\n  (rshift (lshift @0 INTEGER_CST@1) @1)\n  (if (TYPE_UNSIGNED (type)\n-      && (wi::ltu_p (@1, element_precision (type))))\n+      && (wi::ltu_p (wi::to_wide (@1), element_precision (type))))\n   (bit_and @0 (rshift { build_minus_one_cst (type); } @1))))\n \n (for shiftrotate (lrotate rrotate lshift rshift)\n@@ -1879,10 +1889,10 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n  (simplify\n   (op (op @0 INTEGER_CST@1) INTEGER_CST@2)\n   (with { unsigned int prec = element_precision (type); }\n-   (if (wi::ge_p (@1, 0, TYPE_SIGN (TREE_TYPE (@1)))\n-        && wi::lt_p (@1, prec, TYPE_SIGN (TREE_TYPE (@1)))\n-        && wi::ge_p (@2, 0, TYPE_SIGN (TREE_TYPE (@2)))\n-\t&& wi::lt_p (@2, prec, TYPE_SIGN (TREE_TYPE (@2))))\n+   (if (wi::ge_p (wi::to_wide (@1), 0, TYPE_SIGN (TREE_TYPE (@1)))\n+        && wi::lt_p (wi::to_wide (@1), prec, TYPE_SIGN (TREE_TYPE (@1)))\n+        && wi::ge_p (wi::to_wide (@2), 0, TYPE_SIGN (TREE_TYPE (@2)))\n+\t&& wi::lt_p (wi::to_wide (@2), prec, TYPE_SIGN (TREE_TYPE (@2))))\n     (with { unsigned int low = (tree_to_uhwi (@1)\n \t\t\t\t+ tree_to_uhwi (@2)); }\n      /* Deal with a OP (c1 + c2) being undefined but (a OP c1) OP c2\n@@ -1910,13 +1920,13 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n (for cmp (ne eq)\n  (simplify\n   (cmp (lshift INTEGER_CST@0 @1) INTEGER_CST@2)\n-  (with { int cand = wi::ctz (@2) - wi::ctz (@0); }\n+  (with { int cand = wi::ctz (wi::to_wide (@2)) - wi::ctz (wi::to_wide (@0)); }\n    (if (cand < 0\n \t|| (!integer_zerop (@2)\n-\t    && wi::ne_p (wi::lshift (@0, cand), @2)))\n+\t    && wi::lshift (wi::to_wide (@0), cand) != wi::to_wide (@2)))\n     { constant_boolean_node (cmp == NE_EXPR, type); }\n     (if (!integer_zerop (@2)\n-\t && wi::eq_p (wi::lshift (@0, cand), @2))\n+\t && wi::lshift (wi::to_wide (@0), cand) == wi::to_wide (@2))\n      (cmp @1 { build_int_cst (TREE_TYPE (@1), cand); }))))))\n \n /* Fold (X << C1) & C2 into (X << C1) & (C2 | ((1 << C1) - 1))\n@@ -2454,7 +2464,10 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n       {\n \tbool overflow = false;\n \tenum tree_code code, cmp_code = cmp;\n-\twide_int real_c1, c1 = @1, c2 = @2, c3 = @3;\n+\twide_int real_c1;\n+\twide_int c1 = wi::to_wide (@1);\n+\twide_int c2 = wi::to_wide (@2);\n+\twide_int c3 = wi::to_wide (@3);\n \tsignop sgn = TYPE_SIGN (from_type);\n \n \t/* Handle special case A), given x of unsigned type:\n@@ -2592,13 +2605,13 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n  (simplify\n   (cmp @0 INTEGER_CST@1)\n   (if (tree_int_cst_sgn (@1) == -1)\n-   (acmp @0 { wide_int_to_tree (TREE_TYPE (@1), wi::add (@1, 1)); }))))\n+   (acmp @0 { wide_int_to_tree (TREE_TYPE (@1), wi::to_wide (@1) + 1); }))))\n (for cmp  (ge lt)\n      acmp (gt le)\n  (simplify\n   (cmp @0 INTEGER_CST@1)\n   (if (tree_int_cst_sgn (@1) == 1)\n-   (acmp @0 { wide_int_to_tree (TREE_TYPE (@1), wi::sub (@1, 1)); }))))\n+   (acmp @0 { wide_int_to_tree (TREE_TYPE (@1), wi::to_wide (@1) - 1); }))))\n \n \n /* We can simplify a logical negation of a comparison to the\n@@ -2998,28 +3011,31 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n  (simplify\n   (cmp (exact_div @0 @1) INTEGER_CST@2)\n   (if (!integer_zerop (@1))\n-   (if (wi::eq_p (@2, 0))\n+   (if (wi::to_wide (@2) == 0)\n     (cmp @0 @2)\n     (if (TREE_CODE (@1) == INTEGER_CST)\n      (with\n       {\n \tbool ovf;\n-\twide_int prod = wi::mul (@2, @1, TYPE_SIGN (TREE_TYPE (@1)), &ovf);\n+\twide_int prod = wi::mul (wi::to_wide (@2), wi::to_wide (@1),\n+\t\t\t\t TYPE_SIGN (TREE_TYPE (@1)), &ovf);\n       }\n       (if (ovf)\n        { constant_boolean_node (cmp == NE_EXPR, type); }\n        (cmp @0 { wide_int_to_tree (TREE_TYPE (@0), prod); }))))))))\n (for cmp (lt le gt ge)\n  (simplify\n   (cmp (exact_div @0 INTEGER_CST@1) INTEGER_CST@2)\n-  (if (wi::gt_p (@1, 0, TYPE_SIGN (TREE_TYPE (@1))))\n+  (if (wi::gt_p (wi::to_wide (@1), 0, TYPE_SIGN (TREE_TYPE (@1))))\n    (with\n     {\n       bool ovf;\n-      wide_int prod = wi::mul (@2, @1, TYPE_SIGN (TREE_TYPE (@1)), &ovf);\n+      wide_int prod = wi::mul (wi::to_wide (@2), wi::to_wide (@1),\n+\t\t\t       TYPE_SIGN (TREE_TYPE (@1)), &ovf);\n     }\n     (if (ovf)\n-     { constant_boolean_node (wi::lt_p (@2, 0, TYPE_SIGN (TREE_TYPE (@2)))\n+     { constant_boolean_node (wi::lt_p (wi::to_wide (@2), 0,\n+\t\t\t\t\tTYPE_SIGN (TREE_TYPE (@2)))\n \t\t\t      != (cmp == LT_EXPR || cmp == LE_EXPR), type); }\n      (cmp @0 { wide_int_to_tree (TREE_TYPE (@0), prod); }))))))\n \n@@ -3191,7 +3207,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n  (simplify\n   (cmp (convert?@3 (bit_ior @0 INTEGER_CST@1)) INTEGER_CST@2)\n   (if (tree_nop_conversion_p (TREE_TYPE (@3), TREE_TYPE (@0))\n-       && wi::bit_and_not (@1, @2) != 0)\n+       && wi::bit_and_not (wi::to_wide (@1), wi::to_wide (@2)) != 0)\n    { constant_boolean_node (cmp == NE_EXPR, type); }))\n \n  /* (X ^ Y) == 0 becomes X == Y, and (X ^ Y) != 0 becomes X != Y.  */\n@@ -3231,7 +3247,8 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n   (ne (bit_and @0 integer_pow2p@1) integer_zerop)\n   integer_pow2p@2 integer_zerop)\n  (with {\n-    int shift = wi::exact_log2 (@2) - wi::exact_log2 (@1);\n+    int shift = (wi::exact_log2 (wi::to_wide (@2))\n+\t\t - wi::exact_log2 (wi::to_wide (@1)));\n   }\n   (if (shift > 0)\n    (bit_and\n@@ -3248,7 +3265,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n   (if (INTEGRAL_TYPE_P (TREE_TYPE (@0))\n        && type_has_mode_precision_p (TREE_TYPE (@0))\n        && element_precision (@2) >= element_precision (@0)\n-       && wi::only_sign_bit_p (@1, element_precision (@0)))\n+       && wi::only_sign_bit_p (wi::to_wide (@1), element_precision (@0)))\n    (with { tree stype = signed_type_for (TREE_TYPE (@0)); }\n     (ncmp (convert:stype @0) { build_zero_cst (stype); })))))\n \n@@ -3260,7 +3277,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n   integer_pow2p@1 integer_zerop)\n  (if (!TYPE_UNSIGNED (TREE_TYPE (@0)))\n   (with {\n-    int shift = element_precision (@0) - wi::exact_log2 (@1) - 1;\n+    int shift = element_precision (@0) - wi::exact_log2 (wi::to_wide (@1)) - 1;\n    }\n    (if (shift >= 0)\n     (bit_and\n@@ -3381,7 +3398,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n       wide_int min = wi::min_value (arg1_type);\n     }\n     (switch\n-     (if (wi::eq_p (@1, max))\n+     (if (wi::to_wide (@1) == max)\n       (switch\n        (if (cmp == GT_EXPR)\n \t{ constant_boolean_node (false, type); })\n@@ -3391,7 +3408,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n \t{ constant_boolean_node (true, type); })\n        (if (cmp == LT_EXPR)\n \t(ne @2 @1))))\n-     (if (wi::eq_p (@1, min))\n+     (if (wi::to_wide (@1) == min)\n       (switch\n        (if (cmp == LT_EXPR)\n         { constant_boolean_node (false, type); })\n@@ -3401,19 +3418,19 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n         { constant_boolean_node (true, type); })\n        (if (cmp == GT_EXPR)\n         (ne @2 @1))))\n-     (if (wi::eq_p (@1, max - 1))\n+     (if (wi::to_wide (@1) == max - 1)\n       (switch\n        (if (cmp == GT_EXPR)\n-        (eq @2 { wide_int_to_tree (TREE_TYPE (@1), wi::add (@1, 1)); }))\n+\t(eq @2 { wide_int_to_tree (TREE_TYPE (@1), wi::to_wide (@1) + 1); }))\n        (if (cmp == LE_EXPR)\n-        (ne @2 { wide_int_to_tree (TREE_TYPE (@1), wi::add (@1, 1)); }))))\n-     (if (wi::eq_p (@1, min + 1))\n+\t(ne @2 { wide_int_to_tree (TREE_TYPE (@1), wi::to_wide (@1) + 1); }))))\n+     (if (wi::to_wide (@1) == min + 1)\n       (switch\n        (if (cmp == GE_EXPR)\n-        (ne @2 { wide_int_to_tree (TREE_TYPE (@1), wi::sub (@1, 1)); }))\n+        (ne @2 { wide_int_to_tree (TREE_TYPE (@1), wi::to_wide (@1) - 1); }))\n        (if (cmp == LT_EXPR)\n-        (eq @2 { wide_int_to_tree (TREE_TYPE (@1), wi::sub (@1, 1)); }))))\n-     (if (wi::eq_p (@1, signed_max)\n+        (eq @2 { wide_int_to_tree (TREE_TYPE (@1), wi::to_wide (@1) - 1); }))))\n+     (if (wi::to_wide (@1) == signed_max\n \t  && TYPE_UNSIGNED (arg1_type)\n \t  /* We will flip the signedness of the comparison operator\n \t     associated with the mode of @1, so the sign bit is\n@@ -3469,10 +3486,12 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n   (cmp:c (plus@2 @0 INTEGER_CST@1) @0)\n   (if (TYPE_UNSIGNED (TREE_TYPE (@0))\n        && TYPE_OVERFLOW_WRAPS (TREE_TYPE (@0))\n-       && wi::ne_p (@1, 0)\n+       && wi::to_wide (@1) != 0\n        && single_use (@2))\n-   (out @0 { wide_int_to_tree (TREE_TYPE (@0), wi::max_value\n-\t       (TYPE_PRECISION (TREE_TYPE (@0)), UNSIGNED) - @1); }))))\n+   (with { unsigned int prec = TYPE_PRECISION (TREE_TYPE (@0)); }\n+    (out @0 { wide_int_to_tree (TREE_TYPE (@0),\n+\t\t\t        wi::max_value (prec, UNSIGNED)\n+\t\t\t\t- wi::to_wide (@1)); })))))\n \n /* To detect overflow in unsigned A - B, A < B is simpler than A - B > A.\n    However, the detection logic for SUB_OVERFLOW in tree-ssa-math-opts.c\n@@ -4034,13 +4053,13 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n  (POWI @0 INTEGER_CST@1)\n  (switch\n   /* powi(x,0) -> 1.  */\n-  (if (wi::eq_p (@1, 0))\n+  (if (wi::to_wide (@1) == 0)\n    { build_real (type, dconst1); })\n   /* powi(x,1) -> x.  */\n-  (if (wi::eq_p (@1, 1))\n+  (if (wi::to_wide (@1) == 1)\n    @0)\n   /* powi(x,-1) -> 1/x.  */\n-  (if (wi::eq_p (@1, -1))\n+  (if (wi::to_wide (@1) == -1)\n    (rdiv { build_real (type, dconst1); } @0))))\n \n /* Narrowing of arithmetic and logical operations. \n@@ -4105,8 +4124,9 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n        && types_match (@0, @1)\n        && (tree_int_cst_min_precision (@4, TYPE_SIGN (TREE_TYPE (@0)))\n \t   <= TYPE_PRECISION (TREE_TYPE (@0)))\n-       && (wi::bit_and (@4, wi::mask (TYPE_PRECISION (TREE_TYPE (@0)),\n-\t\t\ttrue, TYPE_PRECISION (type))) == 0))\n+       && (wi::to_wide (@4)\n+\t   & wi::mask (TYPE_PRECISION (TREE_TYPE (@0)),\n+\t\t       true, TYPE_PRECISION (type))) == 0)\n    (if (TYPE_OVERFLOW_WRAPS (TREE_TYPE (@0)))\n     (with { tree ntype = TREE_TYPE (@0); }\n      (convert (bit_and (op @0 @1) (convert:ntype @4))))\n@@ -4166,7 +4186,8 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n \t\t\t       WARN_STRICT_OVERFLOW_CONDITIONAL);\n         bool less = cmp == LE_EXPR || cmp == LT_EXPR;\n \t/* wi::ges_p (@2, 0) should be sufficient for a signed type.  */\n-\tbool ovf_high = wi::lt_p (@1, 0, TYPE_SIGN (TREE_TYPE (@1)))\n+\tbool ovf_high = wi::lt_p (wi::to_wide (@1), 0,\n+\t\t\t\t  TYPE_SIGN (TREE_TYPE (@1)))\n \t\t\t!= (op == MINUS_EXPR);\n \tconstant_boolean_node (less == ovf_high, type);\n       }\n@@ -4292,10 +4313,14 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n       isize = tree_to_uhwi (TYPE_SIZE (TREE_TYPE (@1)));\n   }\n   (switch\n-   (if (wi::leu_p (@ipos, @rpos)\n-        && wi::leu_p (wi::add (@rpos, @rsize), wi::add (@ipos, isize)))\n+   (if (wi::leu_p (wi::to_wide (@ipos), wi::to_wide (@rpos))\n+\t&& wi::leu_p (wi::to_wide (@rpos) + wi::to_wide (@rsize),\n+\t\t      wi::to_wide (@ipos) + isize))\n     (BIT_FIELD_REF @1 @rsize { wide_int_to_tree (bitsizetype,\n-                                                 wi::sub (@rpos, @ipos)); }))\n-   (if (wi::geu_p (@ipos, wi::add (@rpos, @rsize))\n-        || wi::geu_p (@rpos, wi::add (@ipos, isize)))\n+                                                 wi::to_wide (@rpos)\n+\t\t\t\t\t\t - wi::to_wide (@ipos)); }))\n+   (if (wi::geu_p (wi::to_wide (@ipos),\n+\t\t   wi::to_wide (@rpos) + wi::to_wide (@rsize))\n+\t|| wi::geu_p (wi::to_wide (@rpos),\n+\t\t      wi::to_wide (@ipos) + isize))\n     (BIT_FIELD_REF @0 @rsize @rpos)))))"}, {"sha": "20b0fe44b29bb1edbaed05664eed4167172a9f38", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -1,3 +1,8 @@\n+2017-10-10  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* objc-act.c (objc_decl_method_attributes): Use wi::to_wide when\n+\toperating on trees as wide_ints.\n+\n 2017-09-29  Jakub Jelinek  <jakub@redhat.com>\n \n \t* objc-act.c (check_ivars, gen_declaration): For OBJCPLUS look at"}, {"sha": "ce2adcc0dedb0537858e028390de5477cac99e6c", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -4900,10 +4900,10 @@ objc_decl_method_attributes (tree *node, tree attributes, int flags)\n \t\t  number = TREE_VALUE (second_argument);\n \t\t  if (number\n \t\t      && TREE_CODE (number) == INTEGER_CST\n-\t\t      && !wi::eq_p (number, 0))\n+\t\t      && wi::to_wide (number) != 0)\n \t\t    TREE_VALUE (second_argument)\n \t\t      = wide_int_to_tree (TREE_TYPE (number),\n-\t\t\t\t\t  wi::add (number, 2));\n+\t\t\t\t\t  wi::to_wide (number) + 2);\n \n \t\t  /* This is the third argument, the \"first-to-check\",\n \t\t     which specifies the index of the first argument to\n@@ -4913,10 +4913,10 @@ objc_decl_method_attributes (tree *node, tree attributes, int flags)\n \t\t  number = TREE_VALUE (third_argument);\n \t\t  if (number\n \t\t      && TREE_CODE (number) == INTEGER_CST\n-\t\t      && !wi::eq_p (number, 0))\n+\t\t      && wi::to_wide (number) != 0)\n \t\t    TREE_VALUE (third_argument)\n \t\t      = wide_int_to_tree (TREE_TYPE (number),\n-\t\t\t\t\t  wi::add (number, 2));\n+\t\t\t\t\t  wi::to_wide (number) + 2);\n \t\t}\n \t      filtered_attributes = chainon (filtered_attributes,\n \t\t\t\t\t     new_attribute);\n@@ -4949,10 +4949,10 @@ objc_decl_method_attributes (tree *node, tree attributes, int flags)\n \t\t  /* Get the value of the argument and add 2.  */\n \t\t  tree number = TREE_VALUE (argument);\n \t\t  if (number && TREE_CODE (number) == INTEGER_CST\n-\t\t      && !wi::eq_p (number, 0))\n+\t\t      && wi::to_wide (number) != 0)\n \t\t    TREE_VALUE (argument)\n \t\t      = wide_int_to_tree (TREE_TYPE (number),\n-\t\t\t\t\t  wi::add (number, 2));\n+\t\t\t\t\t  wi::to_wide (number) + 2);\n \t\t  argument = TREE_CHAIN (argument);\n \t\t}\n "}, {"sha": "afa758bf499487978d9247686eeb2a895cc57041", "filename": "gcc/omp-low.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -3081,7 +3081,7 @@ scan_omp_1_op (tree *tp, int *walk_subtrees, void *data)\n \t      if (tem != TREE_TYPE (t))\n \t\t{\n \t\t  if (TREE_CODE (t) == INTEGER_CST)\n-\t\t    *tp = wide_int_to_tree (tem, t);\n+\t\t    *tp = wide_int_to_tree (tem, wi::to_wide (t));\n \t\t  else\n \t\t    TREE_TYPE (t) = tem;\n \t\t}\n@@ -6372,14 +6372,14 @@ lower_omp_ordered_clauses (gimple_stmt_iterator *gsi_p, gomp_ordered *ord_stmt,\n \t  tree itype = TREE_TYPE (TREE_VALUE (vec));\n \t  if (POINTER_TYPE_P (itype))\n \t    itype = sizetype;\n-\t  wide_int offset = wide_int::from (TREE_PURPOSE (vec),\n+\t  wide_int offset = wide_int::from (wi::to_wide (TREE_PURPOSE (vec)),\n \t\t\t\t\t    TYPE_PRECISION (itype),\n \t\t\t\t\t    TYPE_SIGN (itype));\n \n \t  /* Ignore invalid offsets that are not multiples of the step.  */\n-\t  if (!wi::multiple_of_p\n-\t      (wi::abs (offset), wi::abs ((wide_int) fd.loops[i].step),\n-\t       UNSIGNED))\n+\t  if (!wi::multiple_of_p (wi::abs (offset),\n+\t\t\t\t  wi::abs (wi::to_wide (fd.loops[i].step)),\n+\t\t\t\t  UNSIGNED))\n \t    {\n \t      warning_at (OMP_CLAUSE_LOCATION (c), 0,\n \t\t\t  \"ignoring sink clause with offset that is not \""}, {"sha": "d534c76ee495df9fda652384e974e84ad38e777e", "filename": "gcc/print-tree.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -118,7 +118,7 @@ print_node_brief (FILE *file, const char *prefix, const_tree node, int indent)\n \tfprintf (file, \" overflow\");\n \n       fprintf (file, \" \");\n-      print_dec (node, file, TYPE_SIGN (TREE_TYPE (node)));\n+      print_dec (wi::to_wide (node), file, TYPE_SIGN (TREE_TYPE (node)));\n     }\n   if (TREE_CODE (node) == REAL_CST)\n     {\n@@ -721,7 +721,7 @@ print_node (FILE *file, const char *prefix, tree node, int indent,\n \t    fprintf (file, \" overflow\");\n \n \t  fprintf (file, \" \");\n-\t  print_dec (node, file, TYPE_SIGN (TREE_TYPE (node)));\n+\t  print_dec (wi::to_wide (node), file, TYPE_SIGN (TREE_TYPE (node)));\n \t  break;\n \n \tcase REAL_CST:"}, {"sha": "410ae61bd4ddf7c56363c05f37fcd02f8669009e", "filename": "gcc/stmt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -941,7 +941,7 @@ expand_case (gswitch *stmt)\n \t original type.  Make sure to drop overflow flags.  */\n       low = fold_convert (index_type, low);\n       if (TREE_OVERFLOW (low))\n-\tlow = wide_int_to_tree (index_type, low);\n+\tlow = wide_int_to_tree (index_type, wi::to_wide (low));\n \n       /* The canonical from of a case label in GIMPLE is that a simple case\n \t has an empty CASE_HIGH.  For the casesi and tablejump expanders,\n@@ -950,7 +950,7 @@ expand_case (gswitch *stmt)\n \thigh = low;\n       high = fold_convert (index_type, high);\n       if (TREE_OVERFLOW (high))\n-\thigh = wide_int_to_tree (index_type, high);\n+\thigh = wide_int_to_tree (index_type, wi::to_wide (high));\n \n       case_list.safe_push (simple_case_node (low, high, lab));\n     }"}, {"sha": "02739b0ed7fd330fdf4f863b1836ebf8e0af8caf", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -2362,9 +2362,11 @@ layout_type (tree type)\n \t\t    && tree_int_cst_lt (ub, lb))\n \t\t  {\n \t\t    lb = wide_int_to_tree (ssizetype,\n-\t\t\t\t\t   offset_int::from (lb, SIGNED));\n+\t\t\t\t\t   offset_int::from (wi::to_wide (lb),\n+\t\t\t\t\t\t\t     SIGNED));\n \t\t    ub = wide_int_to_tree (ssizetype,\n-\t\t\t\t\t   offset_int::from (ub, SIGNED));\n+\t\t\t\t\t   offset_int::from (wi::to_wide (ub),\n+\t\t\t\t\t\t\t     SIGNED));\n \t\t  }\n \t\tlength\n \t\t  = fold_convert (sizetype,"}, {"sha": "47f56bf2b5436449792adf4b6e6cbdb0a7acbacc", "filename": "gcc/tree-affine.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree-affine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree-affine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-affine.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -408,8 +408,8 @@ tree_to_aff_combination (tree expr, tree type, aff_tree *comb)\n \t\t&& get_range_info (op0, &minv, &maxv) == VR_RANGE)\n \t      {\n \t\tif (icode == PLUS_EXPR)\n-\t\t  op1 = wide_int_to_tree (itype, wi::neg (op1));\n-\t\tif (wi::geu_p (minv, op1))\n+\t\t  op1 = wide_int_to_tree (itype, -wi::to_wide (op1));\n+\t\tif (wi::geu_p (minv, wi::to_wide (op1)))\n \t\t  {\n \t\t    op0 = fold_convert (otype, op0);\n \t\t    op1 = fold_convert (otype, op1);"}, {"sha": "b5e0460c84a5b345805a2dea932ca06f3dc53b53", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -1721,12 +1721,12 @@ group_case_labels_stmt (gswitch *stmt)\n \t{\n \t  tree merge_case = gimple_switch_label (stmt, next_index);\n \t  basic_block merge_bb = label_to_block (CASE_LABEL (merge_case));\n-\t  wide_int bhp1 = wi::add (base_high, 1);\n+\t  wide_int bhp1 = wi::to_wide (base_high) + 1;\n \n \t  /* Merge the cases if they jump to the same place,\n \t     and their ranges are consecutive.  */\n \t  if (merge_bb == base_bb\n-\t      && wi::eq_p (CASE_LOW (merge_case), bhp1))\n+\t      && wi::to_wide (CASE_LOW (merge_case)) == bhp1)\n \t    {\n \t      base_high = CASE_HIGH (merge_case) ?\n \t\t  CASE_HIGH (merge_case) : CASE_LOW (merge_case);"}, {"sha": "19cceb8dfd95012bce2b061c32aed8183e24e955", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 24, "deletions": 17, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -1060,12 +1060,15 @@ dr_analyze_indices (struct data_reference *dr, loop_p nest, loop_p loop)\n \t  if (TYPE_SIZE_UNIT (TREE_TYPE (ref))\n \t      && TREE_CODE (TYPE_SIZE_UNIT (TREE_TYPE (ref))) == INTEGER_CST\n \t      && !integer_zerop (TYPE_SIZE_UNIT (TREE_TYPE (ref))))\n-\t    rem = wi::mod_trunc (off, TYPE_SIZE_UNIT (TREE_TYPE (ref)), SIGNED);\n+\t    rem = wi::mod_trunc\n+\t      (wi::to_wide (off),\n+\t       wi::to_wide (TYPE_SIZE_UNIT (TREE_TYPE (ref))),\n+\t       SIGNED);\n \t  else\n \t    /* If we can't compute the remainder simply force the initial\n \t       condition to zero.  */\n-\t    rem = off;\n-\t  off = wide_int_to_tree (ssizetype, wi::sub (off, rem));\n+\t    rem = wi::to_wide (off);\n+\t  off = wide_int_to_tree (ssizetype, wi::to_wide (off) - rem);\n \t  memoff = wide_int_to_tree (TREE_TYPE (memoff), rem);\n \t  /* And finally replace the initial condition.  */\n \t  access_fn = chrec_replace_initial_condition\n@@ -1485,14 +1488,16 @@ prune_runtime_alias_test_list (vec<dr_with_seg_len_pair_t> *alias_pairs,\n \t    std::swap (*dr_a1, *dr_a2);\n \n \t  bool do_remove = false;\n-\t  wide_int diff = wi::sub (DR_INIT (dr_a2->dr), DR_INIT (dr_a1->dr));\n+\t  wide_int diff = (wi::to_wide (DR_INIT (dr_a2->dr))\n+\t\t\t   - wi::to_wide (DR_INIT (dr_a1->dr)));\n \t  wide_int min_seg_len_b;\n \t  tree new_seg_len;\n \n \t  if (TREE_CODE (dr_b1->seg_len) == INTEGER_CST)\n-\t    min_seg_len_b = wi::abs (dr_b1->seg_len);\n+\t    min_seg_len_b = wi::abs (wi::to_wide (dr_b1->seg_len));\n \t  else\n-\t    min_seg_len_b = wi::mul (factor, wi::abs (DR_STEP (dr_b1->dr)));\n+\t    min_seg_len_b\n+\t      = factor * wi::abs (wi::to_wide (DR_STEP (dr_b1->dr)));\n \n \t  /* Now we try to merge alias check dr_a1 & dr_b and dr_a2 & dr_b.\n \n@@ -1531,19 +1536,20 @@ prune_runtime_alias_test_list (vec<dr_with_seg_len_pair_t> *alias_pairs,\n \t      /* Adjust diff according to access size of both references.  */\n \t      tree size_a1 = TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dr_a1->dr)));\n \t      tree size_a2 = TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dr_a2->dr)));\n-\t      diff = wi::add (diff, wi::sub (size_a2, size_a1));\n+\t      diff += wi::to_wide (size_a2) - wi::to_wide (size_a1);\n \t      /* Case A.1.  */\n \t      if (wi::leu_p (diff, min_seg_len_b)\n \t\t  /* Case A.2 and B combined.  */\n \t\t  || (tree_fits_uhwi_p (dr_a2->seg_len)))\n \t\t{\n \t\t  if (tree_fits_uhwi_p (dr_a1->seg_len)\n \t\t      && tree_fits_uhwi_p (dr_a2->seg_len))\n-\t\t    new_seg_len\n-\t\t      = wide_int_to_tree (sizetype,\n-\t\t\t\t\t  wi::umin (wi::sub (dr_a1->seg_len,\n-\t\t\t\t\t\t\t     diff),\n-\t\t\t\t\t\t    dr_a2->seg_len));\n+\t\t    {\n+\t\t      wide_int min_len\n+\t\t\t= wi::umin (wi::to_wide (dr_a1->seg_len) - diff,\n+\t\t\t\t    wi::to_wide (dr_a2->seg_len));\n+\t\t      new_seg_len = wide_int_to_tree (sizetype, min_len);\n+\t\t    }\n \t\t  else\n \t\t    new_seg_len\n \t\t      = size_binop (MINUS_EXPR, dr_a2->seg_len,\n@@ -1562,11 +1568,12 @@ prune_runtime_alias_test_list (vec<dr_with_seg_len_pair_t> *alias_pairs,\n \t\t{\n \t\t  if (tree_fits_uhwi_p (dr_a1->seg_len)\n \t\t      && tree_fits_uhwi_p (dr_a2->seg_len))\n-\t\t    new_seg_len\n-\t\t      = wide_int_to_tree (sizetype,\n-\t\t\t\t\t  wi::umax (wi::add (dr_a2->seg_len,\n-\t\t\t\t\t\t\t     diff),\n-\t\t\t\t\t\t    dr_a1->seg_len));\n+\t\t    {\n+\t\t      wide_int max_len\n+\t\t\t= wi::umax (wi::to_wide (dr_a2->seg_len) + diff,\n+\t\t\t\t    wi::to_wide (dr_a1->seg_len));\n+\t\t      new_seg_len = wide_int_to_tree (sizetype, max_len);\n+\t\t    }\n \t\t  else\n \t\t    new_seg_len\n \t\t      = size_binop (PLUS_EXPR, dr_a2->seg_len,"}, {"sha": "ac0c7b868a132c041fc0a22694834e7cbbc08633", "filename": "gcc/tree-dump.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -540,7 +540,7 @@ dequeue_and_dump (dump_info_p di)\n \n     case INTEGER_CST:\n       fprintf (di->stream, \"int: \");\n-      print_decs (t, di->stream);\n+      print_decs (wi::to_wide (t), di->stream);\n       break;\n \n     case STRING_CST:"}, {"sha": "c764a44db61684195640d076b467dfcebfbbb930", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -949,7 +949,7 @@ remap_gimple_op_r (tree *tp, int *walk_subtrees, void *data)\n \t*walk_subtrees = 0;\n \n       else if (TREE_CODE (*tp) == INTEGER_CST)\n-\t*tp = wide_int_to_tree (new_type, *tp);\n+\t*tp = wide_int_to_tree (new_type, wi::to_wide (*tp));\n       else\n \t{\n \t  *tp = copy_node (*tp);\n@@ -1133,7 +1133,7 @@ copy_tree_body_r (tree *tp, int *walk_subtrees, void *data)\n \t*walk_subtrees = 0;\n \n       else if (TREE_CODE (*tp) == INTEGER_CST)\n-\t*tp = wide_int_to_tree (new_type, *tp);\n+\t*tp = wide_int_to_tree (new_type, wi::to_wide (*tp));\n       else\n \t{\n \t  *tp = copy_node (*tp);"}, {"sha": "fdb32f10529badeed770015d4ff95bca65416264", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -1655,7 +1655,8 @@ is_inv_store_elimination_chain (struct loop *loop, chain_p chain)\n   /* If loop iterates for unknown times or fewer times than chain->lenght,\n      we still need to setup root variable and propagate it with PHI node.  */\n   tree niters = number_of_latch_executions (loop);\n-  if (TREE_CODE (niters) != INTEGER_CST || wi::leu_p (niters, chain->length))\n+  if (TREE_CODE (niters) != INTEGER_CST\n+      || wi::leu_p (wi::to_wide (niters), chain->length))\n     return false;\n \n   /* Check stores in chain for elimination if they only store loop invariant"}, {"sha": "4e7bb5fbdbc6d4f64239aec31a8c9ed9523f106f", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -1710,7 +1710,7 @@ dump_generic_node (pretty_printer *pp, tree node, int spc, dump_flags_t flags,\n \tpp_unsigned_wide_integer (pp, tree_to_uhwi (node));\n       else\n \t{\n-\t  wide_int val = node;\n+\t  wide_int val = wi::to_wide (node);\n \n \t  if (wi::neg_p (val, TYPE_SIGN (TREE_TYPE (node))))\n \t    {"}, {"sha": "58c2bde83074bce2863ba779a0fd1a2aeeba8b5f", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -3324,7 +3324,7 @@ iv_can_overflow_p (struct loop *loop, tree type, tree base, tree step)\n     return false;\n \n   if (TREE_CODE (base) == INTEGER_CST)\n-    base_min = base_max = base;\n+    base_min = base_max = wi::to_wide (base);\n   else if (TREE_CODE (base) == SSA_NAME\n \t   && INTEGRAL_TYPE_P (TREE_TYPE (base))\n \t   && get_range_info (base, &base_min, &base_max) == VR_RANGE)\n@@ -3333,7 +3333,7 @@ iv_can_overflow_p (struct loop *loop, tree type, tree base, tree step)\n     return true;\n \n   if (TREE_CODE (step) == INTEGER_CST)\n-    step_min = step_max = step;\n+    step_min = step_max = wi::to_wide (step);\n   else if (TREE_CODE (step) == SSA_NAME\n \t   && INTEGRAL_TYPE_P (TREE_TYPE (step))\n \t   && get_range_info (step, &step_min, &step_max) == VR_RANGE)\n@@ -3593,7 +3593,8 @@ simple_iv_with_niters (struct loop *wrto_loop, struct loop *use_loop,\n       extreme = wi::max_value (type);\n     }\n   overflow = false;\n-  extreme = wi::sub (extreme, iv->step, TYPE_SIGN (type), &overflow);\n+  extreme = wi::sub (extreme, wi::to_wide (iv->step),\n+\t\t     TYPE_SIGN (type), &overflow);\n   if (overflow)\n     return true;\n   e = fold_build2 (code, boolean_type_node, base,"}, {"sha": "14c743414dfacb6aa0b48a35176b3720210cac1a", "filename": "gcc/tree-ssa-address.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree-ssa-address.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree-ssa-address.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-address.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -197,13 +197,13 @@ addr_for_mem_ref (struct mem_address *addr, addr_space_t as,\n   struct mem_addr_template *templ;\n \n   if (addr->step && !integer_onep (addr->step))\n-    st = immed_wide_int_const (addr->step, pointer_mode);\n+    st = immed_wide_int_const (wi::to_wide (addr->step), pointer_mode);\n   else\n     st = NULL_RTX;\n \n   if (addr->offset && !integer_zerop (addr->offset))\n     {\n-      offset_int dc = offset_int::from (addr->offset, SIGNED);\n+      offset_int dc = offset_int::from (wi::to_wide (addr->offset), SIGNED);\n       off = immed_wide_int_const (dc, pointer_mode);\n     }\n   else"}, {"sha": "439bb0a8b40f31c5d3d4968f2715c10f83da8121", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -951,8 +951,9 @@ ccp_finalize (bool nonzero_p)\n       else\n \t{\n \t  unsigned int precision = TYPE_PRECISION (TREE_TYPE (val->value));\n-\t  wide_int nonzero_bits = wide_int::from (val->mask, precision,\n-\t\t\t\t\t\t  UNSIGNED) | val->value;\n+\t  wide_int nonzero_bits\n+\t    = (wide_int::from (val->mask, precision, UNSIGNED)\n+\t       | wi::to_wide (val->value));\n \t  nonzero_bits &= get_nonzero_bits (name);\n \t  set_nonzero_bits (name, nonzero_bits);\n \t}\n@@ -1972,9 +1973,10 @@ evaluate_stmt (gimple *stmt)\n \t    }\n \t  else\n \t    {\n-\t      if (wi::bit_and_not (val.value, nonzero_bits) != 0)\n+\t      if (wi::bit_and_not (wi::to_wide (val.value), nonzero_bits) != 0)\n \t\tval.value = wide_int_to_tree (TREE_TYPE (lhs),\n-\t\t\t\t\t      nonzero_bits & val.value);\n+\t\t\t\t\t      nonzero_bits\n+\t\t\t\t\t      & wi::to_wide (val.value));\n \t      if (nonzero_bits == 0)\n \t\tval.mask = 0;\n \t      else"}, {"sha": "2a71027a1e2ccaefba1e231420200dec58255956", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -2160,8 +2160,8 @@ constant_multiple_of (tree top, tree bot, widest_int *mul)\n       if (TREE_CODE (bot) != INTEGER_CST)\n \treturn false;\n \n-      p0 = widest_int::from (top, SIGNED);\n-      p1 = widest_int::from (bot, SIGNED);\n+      p0 = widest_int::from (wi::to_wide (top), SIGNED);\n+      p1 = widest_int::from (wi::to_wide (bot), SIGNED);\n       if (p1 == 0)\n \treturn false;\n       *mul = wi::sext (wi::divmod_trunc (p0, p1, SIGNED, &res), precision);"}, {"sha": "f8f2eeb1a3b81b86f12cfefefcf3eec54f60f5d0", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -92,14 +92,14 @@ split_to_var_and_offset (tree expr, tree *var, mpz_t offset)\n \n       *var = op0;\n       /* Always sign extend the offset.  */\n-      wi::to_mpz (op1, offset, SIGNED);\n+      wi::to_mpz (wi::to_wide (op1), offset, SIGNED);\n       if (negate)\n \tmpz_neg (offset, offset);\n       break;\n \n     case INTEGER_CST:\n       *var = build_int_cst_type (type, 0);\n-      wi::to_mpz (expr, offset, TYPE_SIGN (type));\n+      wi::to_mpz (wi::to_wide (expr), offset, TYPE_SIGN (type));\n       break;\n \n     default:\n@@ -164,7 +164,7 @@ refine_value_range_using_guard (tree type, tree var,\n \n \t  /* Case of comparing VAR with its below/up bounds.  */\n \t  mpz_init (valc1);\n-\t  wi::to_mpz (c1, valc1, TYPE_SIGN (type));\n+\t  wi::to_mpz (wi::to_wide (c1), valc1, TYPE_SIGN (type));\n \t  if (mpz_cmp (valc1, below) == 0)\n \t    cmp = GT_EXPR;\n \t  if (mpz_cmp (valc1, up) == 0)\n@@ -178,9 +178,9 @@ refine_value_range_using_guard (tree type, tree var,\n \t  wide_int min = wi::min_value (type);\n \t  wide_int max = wi::max_value (type);\n \n-\t  if (wi::eq_p (c1, min))\n+\t  if (wi::to_wide (c1) == min)\n \t    cmp = GT_EXPR;\n-\t  if (wi::eq_p (c1, max))\n+\t  if (wi::to_wide (c1) == max)\n \t    cmp = LT_EXPR;\n \t}\n \n@@ -221,8 +221,8 @@ refine_value_range_using_guard (tree type, tree var,\n   /* Setup range information for varc1.  */\n   if (integer_zerop (varc1))\n     {\n-      wi::to_mpz (integer_zero_node, minc1, TYPE_SIGN (type));\n-      wi::to_mpz (integer_zero_node, maxc1, TYPE_SIGN (type));\n+      wi::to_mpz (0, minc1, TYPE_SIGN (type));\n+      wi::to_mpz (0, maxc1, TYPE_SIGN (type));\n     }\n   else if (TREE_CODE (varc1) == SSA_NAME\n \t   && INTEGRAL_TYPE_P (type)\n@@ -903,7 +903,8 @@ number_of_iterations_ne_max (mpz_t bnd, bool no_overflow, tree c, tree s,\n   if (integer_onep (s)\n       || (TREE_CODE (c) == INTEGER_CST\n \t  && TREE_CODE (s) == INTEGER_CST\n-\t  && wi::mod_trunc (c, s, TYPE_SIGN (type)) == 0)\n+\t  && wi::mod_trunc (wi::to_wide (c), wi::to_wide (s),\n+\t\t\t    TYPE_SIGN (type)) == 0)\n       || (TYPE_OVERFLOW_UNDEFINED (type)\n \t  && multiple_of_p (type, c, s)))\n     {\n@@ -922,7 +923,8 @@ number_of_iterations_ne_max (mpz_t bnd, bool no_overflow, tree c, tree s,\n      the whole # of iterations analysis will fail).  */\n   if (!no_overflow)\n     {\n-      max = wi::mask <widest_int> (TYPE_PRECISION (type) - wi::ctz (s), false);\n+      max = wi::mask <widest_int> (TYPE_PRECISION (type)\n+\t\t\t\t   - wi::ctz (wi::to_wide (s)), false);\n       wi::to_mpz (max, bnd, UNSIGNED);\n       return;\n     }\n@@ -938,13 +940,13 @@ number_of_iterations_ne_max (mpz_t bnd, bool no_overflow, tree c, tree s,\n       /* ... then we can strengthen this to C / S, and possibly we can use\n \t the upper bound on C given by BNDS.  */\n       if (TREE_CODE (c) == INTEGER_CST)\n-\twi::to_mpz (c, bnd, UNSIGNED);\n+\twi::to_mpz (wi::to_wide (c), bnd, UNSIGNED);\n       else if (bnds_u_valid)\n \tmpz_set (bnd, bnds->up);\n     }\n \n   mpz_init (d);\n-  wi::to_mpz (s, d, UNSIGNED);\n+  wi::to_mpz (wi::to_wide (s), d, UNSIGNED);\n   mpz_fdiv_q (bnd, bnd, d);\n   mpz_clear (d);\n }\n@@ -1157,7 +1159,7 @@ number_of_iterations_lt_to_ne (tree type, affine_iv *iv0, affine_iv *iv1,\n   tmod = fold_convert (type1, mod);\n \n   mpz_init (mmod);\n-  wi::to_mpz (mod, mmod, UNSIGNED);\n+  wi::to_mpz (wi::to_wide (mod), mmod, UNSIGNED);\n   mpz_neg (mmod, mmod);\n \n   /* If the induction variable does not overflow and the exit is taken,\n@@ -1543,7 +1545,7 @@ number_of_iterations_lt (struct loop *loop, tree type, affine_iv *iv0,\n \n   mpz_init (mstep);\n   mpz_init (tmp);\n-  wi::to_mpz (step, mstep, UNSIGNED);\n+  wi::to_mpz (wi::to_wide (step), mstep, UNSIGNED);\n   mpz_add (tmp, bnds->up, mstep);\n   mpz_sub_ui (tmp, tmp, 1);\n   mpz_fdiv_q (tmp, tmp, mstep);\n@@ -3178,7 +3180,7 @@ get_cst_init_from_scev (tree var, wide_int *init, bool is_min)\n   if (is_min == tree_int_cst_sign_bit (iv.step))\n     return false;\n \n-  *init = iv.base;\n+  *init = wi::to_wide (iv.base);\n   return true;\n }\n \n@@ -3225,7 +3227,7 @@ record_nonwrapping_iv (struct loop *loop, tree base, tree step, gimple *stmt,\n \t  && INTEGRAL_TYPE_P (TREE_TYPE (orig_base))\n \t  && (get_range_info (orig_base, &min, &max) == VR_RANGE\n \t      || get_cst_init_from_scev (orig_base, &max, false))\n-\t  && wi::gts_p (high, max))\n+\t  && wi::gts_p (wi::to_wide (high), max))\n \tbase = wide_int_to_tree (unsigned_type, max);\n       else if (TREE_CODE (base) != INTEGER_CST\n \t       && dominated_by_p (CDI_DOMINATORS,\n@@ -3243,7 +3245,7 @@ record_nonwrapping_iv (struct loop *loop, tree base, tree step, gimple *stmt,\n \t  && INTEGRAL_TYPE_P (TREE_TYPE (orig_base))\n \t  && (get_range_info (orig_base, &min, &max) == VR_RANGE\n \t      || get_cst_init_from_scev (orig_base, &min, true))\n-\t  && wi::gts_p (min, low))\n+\t  && wi::gts_p (min, wi::to_wide (low)))\n \tbase = wide_int_to_tree (unsigned_type, min);\n       else if (TREE_CODE (base) != INTEGER_CST\n \t       && dominated_by_p (CDI_DOMINATORS,\n@@ -4499,19 +4501,15 @@ scev_var_range_cant_overflow (tree var, tree step, struct loop *loop)\n        MIN - type_MIN >= |step| ; if step < 0.\n \n      Or VAR must take value outside of value range, which is not true.  */\n-  step_wi = step;\n+  step_wi = wi::to_wide (step);\n   type = TREE_TYPE (var);\n   if (tree_int_cst_sign_bit (step))\n     {\n-      diff = lower_bound_in_type (type, type);\n-      diff = minv - diff;\n+      diff = minv - wi::to_wide (lower_bound_in_type (type, type));\n       step_wi = - step_wi;\n     }\n   else\n-    {\n-      diff = upper_bound_in_type (type, type);\n-      diff = diff - maxv;\n-    }\n+    diff = wi::to_wide (upper_bound_in_type (type, type)) - maxv;\n \n   return (wi::geu_p (diff, step_wi));\n }"}, {"sha": "05fbb31b0eec6db96d6bf3a0058304fb7553cb67", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -1123,15 +1123,17 @@ minmax_replacement (basic_block cond_bb, basic_block middle_bb,\n \t  if (cmp == LT_EXPR)\n \t    {\n \t      bool overflow;\n-\t      wide_int alt = wi::sub (larger, 1, TYPE_SIGN (TREE_TYPE (larger)),\n+\t      wide_int alt = wi::sub (wi::to_wide (larger), 1,\n+\t\t\t\t      TYPE_SIGN (TREE_TYPE (larger)),\n \t\t\t\t      &overflow);\n \t      if (! overflow)\n \t\talt_larger = wide_int_to_tree (TREE_TYPE (larger), alt);\n \t    }\n \t  else\n \t    {\n \t      bool overflow;\n-\t      wide_int alt = wi::add (larger, 1, TYPE_SIGN (TREE_TYPE (larger)),\n+\t      wide_int alt = wi::add (wi::to_wide (larger), 1,\n+\t\t\t\t      TYPE_SIGN (TREE_TYPE (larger)),\n \t\t\t\t      &overflow);\n \t      if (! overflow)\n \t\talt_larger = wide_int_to_tree (TREE_TYPE (larger), alt);\n@@ -1149,15 +1151,17 @@ minmax_replacement (basic_block cond_bb, basic_block middle_bb,\n \t  if (cmp == GT_EXPR)\n \t    {\n \t      bool overflow;\n-\t      wide_int alt = wi::add (smaller, 1, TYPE_SIGN (TREE_TYPE (smaller)),\n+\t      wide_int alt = wi::add (wi::to_wide (smaller), 1,\n+\t\t\t\t      TYPE_SIGN (TREE_TYPE (smaller)),\n \t\t\t\t      &overflow);\n \t      if (! overflow)\n \t\talt_smaller = wide_int_to_tree (TREE_TYPE (smaller), alt);\n \t    }\n \t  else\n \t    {\n \t      bool overflow;\n-\t      wide_int alt = wi::sub (smaller, 1, TYPE_SIGN (TREE_TYPE (smaller)),\n+\t      wide_int alt = wi::sub (wi::to_wide (smaller), 1,\n+\t\t\t\t      TYPE_SIGN (TREE_TYPE (smaller)),\n \t\t\t\t      &overflow);\n \t      if (! overflow)\n \t\talt_smaller = wide_int_to_tree (TREE_TYPE (smaller), alt);"}, {"sha": "5eb47a9d6d54bc8033f351f0dee25bf16aa849da", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -4020,21 +4020,25 @@ compute_avail (void)\n \t\t\t{\n \t\t\t  ref->set = set;\n \t\t\t  if (ref1->opcode == MEM_REF)\n-\t\t\t    ref1->op0 = wide_int_to_tree (TREE_TYPE (ref2->op0),\n-\t\t\t\t\t\t\t  ref1->op0);\n+\t\t\t    ref1->op0\n+\t\t\t      = wide_int_to_tree (TREE_TYPE (ref2->op0),\n+\t\t\t\t\t\t  wi::to_wide (ref1->op0));\n \t\t\t  else\n-\t\t\t    ref1->op2 = wide_int_to_tree (TREE_TYPE (ref2->op2),\n-\t\t\t\t\t\t\t  ref1->op2);\n+\t\t\t    ref1->op2\n+\t\t\t      = wide_int_to_tree (TREE_TYPE (ref2->op2),\n+\t\t\t\t\t\t  wi::to_wide (ref1->op2));\n \t\t\t}\n \t\t      else\n \t\t\t{\n \t\t\t  ref->set = 0;\n \t\t\t  if (ref1->opcode == MEM_REF)\n-\t\t\t    ref1->op0 = wide_int_to_tree (ptr_type_node,\n-\t\t\t\t\t\t\t  ref1->op0);\n+\t\t\t    ref1->op0\n+\t\t\t      = wide_int_to_tree (ptr_type_node,\n+\t\t\t\t\t\t  wi::to_wide (ref1->op0));\n \t\t\t  else\n-\t\t\t    ref1->op2 = wide_int_to_tree (ptr_type_node,\n-\t\t\t\t\t\t\t  ref1->op2);\n+\t\t\t    ref1->op2\n+\t\t\t      = wide_int_to_tree (ptr_type_node,\n+\t\t\t\t\t\t  wi::to_wide (ref1->op2));\n \t\t\t}\n \t\t      operands.release ();\n "}, {"sha": "d27bcee8262a763625da7b7e5cc84f91bb17820f", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -1167,7 +1167,7 @@ vn_reference_fold_indirect (vec<vn_reference_op_s> *ops,\n   gcc_checking_assert (addr_base && TREE_CODE (addr_base) != MEM_REF);\n   if (addr_base != TREE_OPERAND (op->op0, 0))\n     {\n-      offset_int off = offset_int::from (mem_op->op0, SIGNED);\n+      offset_int off = offset_int::from (wi::to_wide (mem_op->op0), SIGNED);\n       off += addr_offset;\n       mem_op->op0 = wide_int_to_tree (TREE_TYPE (mem_op->op0), off);\n       op->op0 = build_fold_addr_expr (addr_base);\n@@ -1202,7 +1202,7 @@ vn_reference_maybe_forwprop_address (vec<vn_reference_op_s> *ops,\n       && code != POINTER_PLUS_EXPR)\n     return false;\n \n-  off = offset_int::from (mem_op->op0, SIGNED);\n+  off = offset_int::from (wi::to_wide (mem_op->op0), SIGNED);\n \n   /* The only thing we have to do is from &OBJ.foo.bar add the offset\n      from .foo.bar to the preceding MEM_REF offset and replace the\n@@ -1235,8 +1235,9 @@ vn_reference_maybe_forwprop_address (vec<vn_reference_op_s> *ops,\n \t      && tem[tem.length () - 2].opcode == MEM_REF)\n \t    {\n \t      vn_reference_op_t new_mem_op = &tem[tem.length () - 2];\n-\t      new_mem_op->op0 = wide_int_to_tree (TREE_TYPE (mem_op->op0),\n-\t\t\t\t\t\t  new_mem_op->op0);\n+\t      new_mem_op->op0\n+\t\t= wide_int_to_tree (TREE_TYPE (mem_op->op0),\n+\t\t\t\t    wi::to_wide (new_mem_op->op0));\n \t    }\n \t  else\n \t    gcc_assert (tem.last ().opcode == STRING_CST);\n@@ -3537,7 +3538,7 @@ valueized_wider_op (tree wide_type, tree op)\n \n   /* For constants simply extend it.  */\n   if (TREE_CODE (op) == INTEGER_CST)\n-    return wide_int_to_tree (wide_type, op);\n+    return wide_int_to_tree (wide_type, wi::to_wide (op));\n \n   return NULL_TREE;\n }"}, {"sha": "407ad3759b35bf3b0cdc9e455e4b6c9c5a22b812", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -3098,7 +3098,7 @@ get_constraint_for_ptr_offset (tree ptr, tree offset,\n   else\n     {\n       /* Sign-extend the offset.  */\n-      offset_int soffset = offset_int::from (offset, SIGNED);\n+      offset_int soffset = offset_int::from (wi::to_wide (offset), SIGNED);\n       if (!wi::fits_shwi_p (soffset))\n \trhsoffset = UNKNOWN_OFFSET;\n       else"}, {"sha": "4096ded7ea2ed038a48ed6118e5a5d786759bb5e", "filename": "gcc/tree-ssa-uninit.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree-ssa-uninit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree-ssa-uninit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -1474,8 +1474,8 @@ is_pred_expr_subset_of (pred_info expr1, pred_info expr2)\n     code2 = invert_tree_comparison (code2, false);\n \n   if ((code1 == EQ_EXPR || code1 == BIT_AND_EXPR) && code2 == BIT_AND_EXPR)\n-    return wi::eq_p (expr1.pred_rhs,\n-\t\t     wi::bit_and (expr1.pred_rhs, expr2.pred_rhs));\n+    return (wi::to_wide (expr1.pred_rhs)\n+\t    == (wi::to_wide (expr1.pred_rhs) & wi::to_wide (expr2.pred_rhs)));\n \n   if (code1 != code2 && code2 != NE_EXPR)\n     return false;"}, {"sha": "6d344ad5309627ff9a9e87410e97bdd1d735467c", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -454,8 +454,8 @@ set_nonzero_bits (tree name, const wide_int_ref &mask)\n       if (mask == -1)\n \treturn;\n       set_range_info_raw (name, VR_RANGE,\n-\t\t\t  TYPE_MIN_VALUE (TREE_TYPE (name)),\n-\t\t\t  TYPE_MAX_VALUE (TREE_TYPE (name)));\n+\t\t\t  wi::to_wide (TYPE_MIN_VALUE (TREE_TYPE (name))),\n+\t\t\t  wi::to_wide (TYPE_MAX_VALUE (TREE_TYPE (name))));\n     }\n   range_info_def *ri = SSA_NAME_RANGE_INFO (name);\n   ri->set_nonzero_bits (mask);\n@@ -468,7 +468,7 @@ wide_int\n get_nonzero_bits (const_tree name)\n {\n   if (TREE_CODE (name) == INTEGER_CST)\n-    return name;\n+    return wi::to_wide (name);\n \n   /* Use element_precision instead of TYPE_PRECISION so complex and\n      vector types get a non-zero precision.  */"}, {"sha": "dc9fc84c6a01bca5a379117aa2e0a4425faf7678", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -655,8 +655,7 @@ collect_switch_conv_info (gswitch *swtch, struct switch_conv_info *info)\n   for (i = 2; i < branch_num; i++)\n     {\n       tree elt = gimple_switch_label (swtch, i);\n-      wide_int w = last;\n-      if (w + 1 != CASE_LOW (elt))\n+      if (wi::to_wide (last) + 1 != wi::to_wide (CASE_LOW (elt)))\n \t{\n \t  info->contiguous_range = false;\n \t  break;\n@@ -1065,7 +1064,7 @@ array_value_type (gswitch *swtch, tree type, int num,\n       if (TREE_CODE (elt->value) != INTEGER_CST)\n \treturn type;\n \n-      cst = elt->value;\n+      cst = wi::to_wide (elt->value);\n       while (1)\n \t{\n \t  unsigned int prec = GET_MODE_BITSIZE (mode);\n@@ -1778,11 +1777,12 @@ dump_case_nodes (FILE *f, case_node *root, int indent_step, int indent_level)\n \n   fputs (\";; \", f);\n   fprintf (f, \"%*s\", indent_step * indent_level, \"\");\n-  print_dec (root->low, f, TYPE_SIGN (TREE_TYPE (root->low)));\n+  print_dec (wi::to_wide (root->low), f, TYPE_SIGN (TREE_TYPE (root->low)));\n   if (!tree_int_cst_equal (root->low, root->high))\n     {\n       fprintf (f, \" ... \");\n-      print_dec (root->high, f, TYPE_SIGN (TREE_TYPE (root->high)));\n+      print_dec (wi::to_wide (root->high), f,\n+\t\t TYPE_SIGN (TREE_TYPE (root->high)));\n     }\n   fputs (\"\\n\", f);\n \n@@ -2113,7 +2113,7 @@ try_switch_expansion (gswitch *stmt)\n \t original type.  Make sure to drop overflow flags.  */\n       low = fold_convert (index_type, low);\n       if (TREE_OVERFLOW (low))\n-\tlow = wide_int_to_tree (index_type, low);\n+\tlow = wide_int_to_tree (index_type, wi::to_wide (low));\n \n       /* The canonical from of a case label in GIMPLE is that a simple case\n \t has an empty CASE_HIGH.  For the casesi and tablejump expanders,\n@@ -2122,7 +2122,7 @@ try_switch_expansion (gswitch *stmt)\n \thigh = low;\n       high = fold_convert (index_type, high);\n       if (TREE_OVERFLOW (high))\n-\thigh = wide_int_to_tree (index_type, high);\n+\thigh = wide_int_to_tree (index_type, wi::to_wide (high));\n \n       basic_block case_bb = label_to_block_fn (cfun, lab);\n       edge case_edge = find_edge (bb, case_bb);"}, {"sha": "910334f664e6737a5225de9add3235e382b13e61", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -1232,9 +1232,11 @@ vect_gen_vector_loop_niters (loop_vec_info loop_vinfo, tree niters,\n       /* Peeling algorithm guarantees that vector loop bound is at least ONE,\n \t we set range information to make niters analyzer's life easier.  */\n       if (stmts != NULL)\n-\tset_range_info (niters_vector, VR_RANGE, build_int_cst (type, 1),\n-\t\t\tfold_build2 (RSHIFT_EXPR, type,\n-\t\t\t\t     TYPE_MAX_VALUE (type), log_vf));\n+\tset_range_info (niters_vector, VR_RANGE,\n+\t\t\twi::to_wide (build_int_cst (type, 1)),\n+\t\t\twi::to_wide (fold_build2 (RSHIFT_EXPR, type,\n+\t\t\t\t\t\t  TYPE_MAX_VALUE (type),\n+\t\t\t\t\t\t  log_vf)));\n     }\n   *niters_vector_ptr = niters_vector;\n \n@@ -1787,7 +1789,8 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n \t least VF, so set range information for newly generated var.  */\n       if (new_var_p)\n \tset_range_info (niters, VR_RANGE,\n-\t\t\tbuild_int_cst (type, vf), TYPE_MAX_VALUE (type));\n+\t\t\twi::to_wide (build_int_cst (type, vf)),\n+\t\t\twi::to_wide (TYPE_MAX_VALUE (type)));\n \n       /* Prolog iterates at most bound_prolog times, latch iterates at\n \t most bound_prolog - 1 times.  */"}, {"sha": "e4051b68dd0188b99b0e1d27f5180f40eaa9d2bf", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -3714,7 +3714,7 @@ vect_recog_bool_pattern (vec<gimple *> *stmts, tree *type_in,\n          vectorized matches the vector type of the result in\n \t size and number of elements.  */\n       unsigned prec\n-\t= wi::udiv_trunc (TYPE_SIZE (vectype),\n+\t= wi::udiv_trunc (wi::to_wide (TYPE_SIZE (vectype)),\n \t\t\t  TYPE_VECTOR_SUBPARTS (vectype)).to_uhwi ();\n       tree type\n \t= build_nonstandard_integer_type (prec,"}, {"sha": "d3fa5164238895b4e0f78e80f98ccf6744a52a7e", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -7712,11 +7712,9 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t      if (group_gap_adj != 0 && ! slp_perm\n \t\t  && group_elt == group_size - group_gap_adj)\n \t\t{\n-\t\t  bool ovf;\n-\t\t  tree bump\n-\t\t    = wide_int_to_tree (sizetype,\n-\t\t\t\t\twi::smul (TYPE_SIZE_UNIT (elem_type),\n-\t\t\t\t\t\t  group_gap_adj, &ovf));\n+\t\t  wide_int bump_val = (wi::to_wide (TYPE_SIZE_UNIT (elem_type))\n+\t\t\t\t       * group_gap_adj);\n+\t\t  tree bump = wide_int_to_tree (sizetype, bump_val);\n \t\t  dataref_ptr = bump_vector_ptr (dataref_ptr, ptr_incr, gsi,\n \t\t\t\t\t\t stmt, bump);\n \t\t  group_elt = 0;\n@@ -7726,11 +7724,9 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t     elements loaded for a permuted SLP load.  */\n \t  if (group_gap_adj != 0 && slp_perm)\n \t    {\n-\t      bool ovf;\n-\t      tree bump\n-\t\t= wide_int_to_tree (sizetype,\n-\t\t\t\t    wi::smul (TYPE_SIZE_UNIT (elem_type),\n-\t\t\t\t\t      group_gap_adj, &ovf));\n+\t      wide_int bump_val = (wi::to_wide (TYPE_SIZE_UNIT (elem_type))\n+\t\t\t\t   * group_gap_adj);\n+\t      tree bump = wide_int_to_tree (sizetype, bump_val);\n \t      dataref_ptr = bump_vector_ptr (dataref_ptr, ptr_incr, gsi,\n \t\t\t\t\t     stmt, bump);\n \t    }"}, {"sha": "2c86b8e5c910c5a52916acded39175a576df46c7", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 125, "deletions": 95, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -1072,7 +1072,8 @@ compare_values_warnv (tree val1, tree val2, bool *strict_overflow_p)\n       if (!inv2)\n \tinv2 = build_int_cst (TREE_TYPE (val2), 0);\n \n-      return wi::cmp (inv1, inv2, TYPE_SIGN (TREE_TYPE (val1)));\n+      return wi::cmp (wi::to_wide (inv1), wi::to_wide (inv2),\n+\t\t      TYPE_SIGN (TREE_TYPE (val1)));\n     }\n \n   const bool cst1 = is_gimple_min_invariant (val1);\n@@ -1099,10 +1100,11 @@ compare_values_warnv (tree val1, tree val2, bool *strict_overflow_p)\n       /* Compute the difference between the constants.  If it overflows or\n \t underflows, this means that we can trivially compare the NAME with\n \t it and, consequently, the two values with each other.  */\n-      wide_int diff = wi::sub (cst, inv);\n-      if (wi::cmp (0, inv, sgn) != wi::cmp (diff, cst, sgn))\n+      wide_int diff = wi::to_wide (cst) - wi::to_wide (inv);\n+      if (wi::cmp (0, wi::to_wide (inv), sgn)\n+\t  != wi::cmp (diff, wi::to_wide (cst), sgn))\n \t{\n-\t  const int res = wi::cmp (cst, inv, sgn);\n+\t  const int res = wi::cmp (wi::to_wide (cst), wi::to_wide (inv), sgn);\n \t  return cst1 ? res : -res;\n \t}\n \n@@ -1635,14 +1637,15 @@ vrp_int_const_binop (enum tree_code code, tree val1, tree val2,\n \t  /* It's unclear from the C standard whether shifts can overflow.\n \t     The following code ignores overflow; perhaps a C standard\n \t     interpretation ruling is needed.  */\n-\t  res = wi::rshift (val1, wval2, sign);\n+\t  res = wi::rshift (wi::to_wide (val1), wval2, sign);\n \telse\n-\t  res = wi::lshift (val1, wval2);\n+\t  res = wi::lshift (wi::to_wide (val1), wval2);\n \tbreak;\n       }\n \n     case MULT_EXPR:\n-      res = wi::mul (val1, val2, sign, &overflow);\n+      res = wi::mul (wi::to_wide (val1),\n+\t\t     wi::to_wide (val2), sign, &overflow);\n       break;\n \n     case TRUNC_DIV_EXPR:\n@@ -1653,7 +1656,8 @@ vrp_int_const_binop (enum tree_code code, tree val1, tree val2,\n \t  return res;\n \t}\n       else\n-\tres = wi::div_trunc (val1, val2, sign, &overflow);\n+\tres = wi::div_trunc (wi::to_wide (val1),\n+\t\t\t     wi::to_wide (val2), sign, &overflow);\n       break;\n \n     case FLOOR_DIV_EXPR:\n@@ -1662,7 +1666,8 @@ vrp_int_const_binop (enum tree_code code, tree val1, tree val2,\n \t  *overflow_p = true;\n \t  return res;\n \t}\n-      res = wi::div_floor (val1, val2, sign, &overflow);\n+      res = wi::div_floor (wi::to_wide (val1),\n+\t\t\t   wi::to_wide (val2), sign, &overflow);\n       break;\n \n     case CEIL_DIV_EXPR:\n@@ -1671,7 +1676,8 @@ vrp_int_const_binop (enum tree_code code, tree val1, tree val2,\n \t  *overflow_p = true;\n \t  return res;\n \t}\n-      res = wi::div_ceil (val1, val2, sign, &overflow);\n+      res = wi::div_ceil (wi::to_wide (val1),\n+\t\t\t  wi::to_wide (val2), sign, &overflow);\n       break;\n \n     case ROUND_DIV_EXPR:\n@@ -1680,7 +1686,8 @@ vrp_int_const_binop (enum tree_code code, tree val1, tree val2,\n \t  *overflow_p = 0;\n \t  return res;\n \t}\n-      res = wi::div_round (val1, val2, sign, &overflow);\n+      res = wi::div_round (wi::to_wide (val1),\n+\t\t\t   wi::to_wide (val2), sign, &overflow);\n       break;\n \n     default:\n@@ -1755,15 +1762,15 @@ zero_nonzero_bits_from_vr (const tree expr_type,\n \n   if (range_int_cst_singleton_p (vr))\n     {\n-      *may_be_nonzero = vr->min;\n+      *may_be_nonzero = wi::to_wide (vr->min);\n       *must_be_nonzero = *may_be_nonzero;\n     }\n   else if (tree_int_cst_sgn (vr->min) >= 0\n \t   || tree_int_cst_sgn (vr->max) < 0)\n     {\n-      wide_int xor_mask = wi::bit_xor (vr->min, vr->max);\n-      *may_be_nonzero = wi::bit_or (vr->min, vr->max);\n-      *must_be_nonzero = wi::bit_and (vr->min, vr->max);\n+      wide_int xor_mask = wi::to_wide (vr->min) ^ wi::to_wide (vr->max);\n+      *may_be_nonzero = wi::to_wide (vr->min) | wi::to_wide (vr->max);\n+      *must_be_nonzero = wi::to_wide (vr->min) & wi::to_wide (vr->max);\n       if (xor_mask != 0)\n \t{\n \t  wide_int mask = wi::mask (wi::floor_log2 (xor_mask), false,\n@@ -1801,12 +1808,12 @@ ranges_from_anti_range (value_range *ar,\n     {\n       vr0->type = VR_RANGE;\n       vr0->min = vrp_val_min (type);\n-      vr0->max = wide_int_to_tree (type, wi::sub (ar->min, 1));\n+      vr0->max = wide_int_to_tree (type, wi::to_wide (ar->min) - 1);\n     }\n   if (!vrp_val_is_max (ar->max))\n     {\n       vr1->type = VR_RANGE;\n-      vr1->min = wide_int_to_tree (type, wi::add (ar->max, 1));\n+      vr1->min = wide_int_to_tree (type, wi::to_wide (ar->max) + 1);\n       vr1->max = vrp_val_max (type);\n     }\n   if (vr0->type == VR_UNDEFINED)\n@@ -2171,48 +2178,51 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t    }\n \t  else\n \t    {\n-\t      type_min = vrp_val_min (expr_type);\n-\t      type_max = vrp_val_max (expr_type);\n+\t      type_min = wi::to_wide (vrp_val_min (expr_type));\n+\t      type_max = wi::to_wide (vrp_val_max (expr_type));\n \t    }\n \n \t  /* Combine the lower bounds, if any.  */\n \t  if (min_op0 && min_op1)\n \t    {\n \t      if (minus_p)\n \t\t{\n-\t\t  wmin = wi::sub (min_op0, min_op1);\n+\t\t  wmin = wi::to_wide (min_op0) - wi::to_wide (min_op1);\n \n \t\t  /* Check for overflow.  */\n-\t\t  if (wi::cmp (0, min_op1, sgn)\n-\t\t      != wi::cmp (wmin, min_op0, sgn))\n-\t\t    min_ovf = wi::cmp (min_op0, min_op1, sgn);\n+\t\t  if (wi::cmp (0, wi::to_wide (min_op1), sgn)\n+\t\t      != wi::cmp (wmin, wi::to_wide (min_op0), sgn))\n+\t\t    min_ovf = wi::cmp (wi::to_wide (min_op0),\n+\t\t\t\t       wi::to_wide (min_op1), sgn);\n \t\t}\n \t      else\n \t\t{\n-\t\t  wmin = wi::add (min_op0, min_op1);\n+\t\t  wmin = wi::to_wide (min_op0) + wi::to_wide (min_op1);\n \n \t\t  /* Check for overflow.  */\n-\t\t  if (wi::cmp (min_op1, 0, sgn)\n-\t\t      != wi::cmp (wmin, min_op0, sgn))\n-\t\t    min_ovf = wi::cmp (min_op0, wmin, sgn);\n+\t\t  if (wi::cmp (wi::to_wide (min_op1), 0, sgn)\n+\t\t      != wi::cmp (wmin, wi::to_wide (min_op0), sgn))\n+\t\t    min_ovf = wi::cmp (wi::to_wide (min_op0), wmin, sgn);\n \t\t}\n \t    }\n \t  else if (min_op0)\n-\t    wmin = min_op0;\n+\t    wmin = wi::to_wide (min_op0);\n \t  else if (min_op1)\n \t    {\n \t      if (minus_p)\n \t\t{\n-\t\t  wmin = wi::neg (min_op1);\n+\t\t  wmin = -wi::to_wide (min_op1);\n \n \t\t  /* Check for overflow.  */\n-\t\t  if (sgn == SIGNED && wi::neg_p (min_op1) && wi::neg_p (wmin))\n+\t\t  if (sgn == SIGNED\n+\t\t      && wi::neg_p (wi::to_wide (min_op1))\n+\t\t      && wi::neg_p (wmin))\n \t\t    min_ovf = 1;\n-\t\t  else if (sgn == UNSIGNED && wi::ne_p (min_op1, 0))\n+\t\t  else if (sgn == UNSIGNED && wi::to_wide (min_op1) != 0)\n \t\t    min_ovf = -1;\n \t\t}\n \t      else\n-\t\twmin = min_op1;\n+\t\twmin = wi::to_wide (min_op1);\n \t    }\n \t  else\n \t    wmin = wi::shwi (0, prec);\n@@ -2222,38 +2232,41 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t    {\n \t      if (minus_p)\n \t\t{\n-\t\t  wmax = wi::sub (max_op0, max_op1);\n+\t\t  wmax = wi::to_wide (max_op0) - wi::to_wide (max_op1);\n \n \t\t  /* Check for overflow.  */\n-\t\t  if (wi::cmp (0, max_op1, sgn)\n-\t\t      != wi::cmp (wmax, max_op0, sgn))\n-\t\t    max_ovf = wi::cmp (max_op0, max_op1, sgn);\n+\t\t  if (wi::cmp (0, wi::to_wide (max_op1), sgn)\n+\t\t      != wi::cmp (wmax, wi::to_wide (max_op0), sgn))\n+\t\t    max_ovf = wi::cmp (wi::to_wide (max_op0),\n+\t\t\t\t       wi::to_wide (max_op1), sgn);\n \t\t}\n \t      else\n \t\t{\n-\t\t  wmax = wi::add (max_op0, max_op1);\n+\t\t  wmax = wi::to_wide (max_op0) + wi::to_wide (max_op1);\n \n-\t\t  if (wi::cmp (max_op1, 0, sgn)\n-\t\t      != wi::cmp (wmax, max_op0, sgn))\n-\t\t    max_ovf = wi::cmp (max_op0, wmax, sgn);\n+\t\t  if (wi::cmp (wi::to_wide (max_op1), 0, sgn)\n+\t\t      != wi::cmp (wmax, wi::to_wide (max_op0), sgn))\n+\t\t    max_ovf = wi::cmp (wi::to_wide (max_op0), wmax, sgn);\n \t\t}\n \t    }\n \t  else if (max_op0)\n-\t    wmax = max_op0;\n+\t    wmax = wi::to_wide (max_op0);\n \t  else if (max_op1)\n \t    {\n \t      if (minus_p)\n \t\t{\n-\t\t  wmax = wi::neg (max_op1);\n+\t\t  wmax = -wi::to_wide (max_op1);\n \n \t\t  /* Check for overflow.  */\n-\t\t  if (sgn == SIGNED && wi::neg_p (max_op1) && wi::neg_p (wmax))\n+\t\t  if (sgn == SIGNED\n+\t\t      && wi::neg_p (wi::to_wide (max_op1))\n+\t\t      && wi::neg_p (wmax))\n \t\t    max_ovf = 1;\n-\t\t  else if (sgn == UNSIGNED && wi::ne_p (max_op1, 0))\n+\t\t  else if (sgn == UNSIGNED && wi::to_wide (max_op1) != 0)\n \t\t    max_ovf = -1;\n \t\t}\n \t      else\n-\t\twmax = max_op1;\n+\t\twmax = wi::to_wide (max_op1);\n \t    }\n \t  else\n \t    wmax = wi::shwi (0, prec);\n@@ -2628,14 +2641,14 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t\t{\n \t\t  low_bound = bound;\n \t\t  high_bound = complement;\n-\t\t  if (wi::ltu_p (vr0.max, low_bound))\n+\t\t  if (wi::ltu_p (wi::to_wide (vr0.max), low_bound))\n \t\t    {\n \t\t      /* [5, 6] << [1, 2] == [10, 24].  */\n \t\t      /* We're shifting out only zeroes, the value increases\n \t\t\t monotonically.  */\n \t\t      in_bounds = true;\n \t\t    }\n-\t\t  else if (wi::ltu_p (high_bound, vr0.min))\n+\t\t  else if (wi::ltu_p (high_bound, wi::to_wide (vr0.min)))\n \t\t    {\n \t\t      /* [0xffffff00, 0xffffffff] << [1, 2]\n \t\t         == [0xfffffc00, 0xfffffffe].  */\n@@ -2649,8 +2662,8 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t\t  /* [-1, 1] << [1, 2] == [-4, 4].  */\n \t\t  low_bound = complement;\n \t\t  high_bound = bound;\n-\t\t  if (wi::lts_p (vr0.max, high_bound)\n-\t\t      && wi::lts_p (low_bound, vr0.min))\n+\t\t  if (wi::lts_p (wi::to_wide (vr0.max), high_bound)\n+\t\t      && wi::lts_p (low_bound, wi::to_wide (vr0.min)))\n \t\t    {\n \t\t      /* For non-negative numbers, we're shifting out only\n \t\t\t zeroes, the value increases monotonically.\n@@ -2793,14 +2806,12 @@ extract_range_from_binary_expr_1 (value_range *vr,\n       signop sgn = TYPE_SIGN (expr_type);\n       unsigned int prec = TYPE_PRECISION (expr_type);\n       wide_int wmin, wmax, tmp;\n-      wide_int zero = wi::zero (prec);\n-      wide_int one = wi::one (prec);\n       if (vr1.type == VR_RANGE && !symbolic_range_p (&vr1))\n \t{\n-\t  wmax = wi::sub (vr1.max, one);\n+\t  wmax = wi::to_wide (vr1.max) - 1;\n \t  if (sgn == SIGNED)\n \t    {\n-\t      tmp = wi::sub (wi::minus_one (prec), vr1.min);\n+\t      tmp = -1 - wi::to_wide (vr1.min);\n \t      wmax = wi::smax (wmax, tmp);\n \t    }\n \t}\n@@ -2809,28 +2820,28 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t  wmax = wi::max_value (prec, sgn);\n \t  /* X % INT_MIN may be INT_MAX.  */\n \t  if (sgn == UNSIGNED)\n-\t    wmax = wmax - one;\n+\t    wmax = wmax - 1;\n \t}\n \n       if (sgn == UNSIGNED)\n-\twmin = zero;\n+\twmin = wi::zero (prec);\n       else\n \t{\n \t  wmin = -wmax;\n \t  if (vr0.type == VR_RANGE && TREE_CODE (vr0.min) == INTEGER_CST)\n \t    {\n-\t      tmp = vr0.min;\n-\t      if (wi::gts_p (tmp, zero))\n-\t\ttmp = zero;\n+\t      tmp = wi::to_wide (vr0.min);\n+\t      if (wi::gts_p (tmp, 0))\n+\t\ttmp = wi::zero (prec);\n \t      wmin = wi::smax (wmin, tmp);\n \t    }\n \t}\n \n       if (vr0.type == VR_RANGE && TREE_CODE (vr0.max) == INTEGER_CST)\n \t{\n-\t  tmp = vr0.max;\n+\t  tmp = wi::to_wide (vr0.max);\n \t  if (sgn == SIGNED && wi::neg_p (tmp))\n-\t    tmp = zero;\n+\t    tmp = wi::zero (prec);\n \t  wmax = wi::min (wmax, tmp, sgn);\n \t}\n \n@@ -2875,7 +2886,7 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t     range.  */\n \t  if (vr0p && range_int_cst_p (vr0p))\n \t    {\n-\t      wide_int w = vr1p->min;\n+\t      wide_int w = wi::to_wide (vr1p->min);\n \t      int m = 0, n = 0;\n \t      if (code == BIT_IOR_EXPR)\n \t\tw = ~w;\n@@ -2891,7 +2902,8 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t\t    m = wi::ctz (w) - n;\n \t\t}\n \t      wide_int mask = wi::mask (m + n, true, w.get_precision ());\n-\t      if (wi::eq_p (mask & vr0p->min, mask & vr0p->max))\n+\t      if ((mask & wi::to_wide (vr0p->min))\n+\t\t  == (mask & wi::to_wide (vr0p->max)))\n \t\t{\n \t\t  min = int_const_binop (code, vr0p->min, vr1p->min);\n \t\t  max = int_const_binop (code, vr0p->max, vr1p->min);\n@@ -2914,16 +2926,20 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t      && tree_int_cst_sgn (vr0.max) < 0\n \t      && tree_int_cst_sgn (vr1.max) < 0)\n \t    {\n-\t      wmax = wi::min (wmax, vr0.max, TYPE_SIGN (expr_type));\n-\t      wmax = wi::min (wmax, vr1.max, TYPE_SIGN (expr_type));\n+\t      wmax = wi::min (wmax, wi::to_wide (vr0.max),\n+\t\t\t      TYPE_SIGN (expr_type));\n+\t      wmax = wi::min (wmax, wi::to_wide (vr1.max),\n+\t\t\t      TYPE_SIGN (expr_type));\n \t    }\n \t  /* If either input range contains only non-negative values\n \t     we can truncate the result range maximum to the respective\n \t     maximum of the input range.  */\n \t  if (int_cst_range0 && tree_int_cst_sgn (vr0.min) >= 0)\n-\t    wmax = wi::min (wmax, vr0.max, TYPE_SIGN (expr_type));\n+\t    wmax = wi::min (wmax, wi::to_wide (vr0.max),\n+\t\t\t    TYPE_SIGN (expr_type));\n \t  if (int_cst_range1 && tree_int_cst_sgn (vr1.min) >= 0)\n-\t    wmax = wi::min (wmax, vr1.max, TYPE_SIGN (expr_type));\n+\t    wmax = wi::min (wmax, wi::to_wide (vr1.max),\n+\t\t\t    TYPE_SIGN (expr_type));\n \t  max = wide_int_to_tree (expr_type, wmax);\n \t  cmp = compare_values (min, max);\n \t  /* PR68217: In case of signed & sign-bit-CST should\n@@ -2936,10 +2952,10 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t      if (!TYPE_UNSIGNED (expr_type)\n \t\t  && ((int_cst_range0\n \t\t       && value_range_constant_singleton (&vr0)\n-\t\t       && !wi::cmps (vr0.min, sign_bit))\n+\t\t       && !wi::cmps (wi::to_wide (vr0.min), sign_bit))\n \t\t      || (int_cst_range1\n \t\t\t  && value_range_constant_singleton (&vr1)\n-\t\t\t  && !wi::cmps (vr1.min, sign_bit))))\n+\t\t\t  && !wi::cmps (wi::to_wide (vr1.min), sign_bit))))\n \t\t{\n \t\t  min = TYPE_MIN_VALUE (expr_type);\n \t\t  max = build_int_cst (expr_type, 0);\n@@ -2958,16 +2974,20 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t      && tree_int_cst_sgn (vr0.min) >= 0\n \t      && tree_int_cst_sgn (vr1.min) >= 0)\n \t    {\n-\t      wmin = wi::max (wmin, vr0.min, TYPE_SIGN (expr_type));\n-\t      wmin = wi::max (wmin, vr1.min, TYPE_SIGN (expr_type));\n+\t      wmin = wi::max (wmin, wi::to_wide (vr0.min),\n+\t\t\t      TYPE_SIGN (expr_type));\n+\t      wmin = wi::max (wmin, wi::to_wide (vr1.min),\n+\t\t\t      TYPE_SIGN (expr_type));\n \t    }\n \t  /* If either input range contains only negative values\n \t     we can truncate the minimum of the result range to the\n \t     respective minimum range.  */\n \t  if (int_cst_range0 && tree_int_cst_sgn (vr0.max) < 0)\n-\t    wmin = wi::max (wmin, vr0.min, TYPE_SIGN (expr_type));\n+\t    wmin = wi::max (wmin, wi::to_wide (vr0.min),\n+\t\t\t    TYPE_SIGN (expr_type));\n \t  if (int_cst_range1 && tree_int_cst_sgn (vr1.max) < 0)\n-\t    wmin = wi::max (wmin, vr1.min, TYPE_SIGN (expr_type));\n+\t    wmin = wi::max (wmin, wi::to_wide (vr1.min),\n+\t\t\t    TYPE_SIGN (expr_type));\n \t  min = wide_int_to_tree (expr_type, wmin);\n \t}\n       else if (code == BIT_XOR_EXPR)\n@@ -4044,7 +4064,7 @@ adjust_range_with_scev (value_range *vr, struct loop *loop,\n \t  if (!overflow\n \t      && wi::fits_to_tree_p (wtmp, TREE_TYPE (init))\n \t      && (sgn == UNSIGNED\n-\t\t  || wi::gts_p (wtmp, 0) == wi::gts_p (step, 0)))\n+\t\t  || wi::gts_p (wtmp, 0) == wi::gts_p (wi::to_wide (step), 0)))\n \t    {\n \t      tem = wide_int_to_tree (TREE_TYPE (init), wtmp);\n \t      extract_range_from_binary_expr (&maxvr, PLUS_EXPR,\n@@ -4966,9 +4986,9 @@ overflow_comparison_p_1 (enum tree_code code, tree op0, tree op1,\n \t  wide_int max = wi::max_value (TYPE_PRECISION (type), UNSIGNED);\n \t  tree inc = gimple_assign_rhs2 (op1_def);\n \t  if (reversed)\n-\t    *new_cst = wide_int_to_tree (type, max + inc);\n+\t    *new_cst = wide_int_to_tree (type, max + wi::to_wide (inc));\n \t  else\n-\t    *new_cst = wide_int_to_tree (type, max - inc);\n+\t    *new_cst = wide_int_to_tree (type, max - wi::to_wide (inc));\n \t  return true;\n \t}\n     }\n@@ -5290,15 +5310,15 @@ register_edge_assert_for_2 (tree name, edge e,\n \t      wide_int minval\n \t\t= wi::min_value (prec, TYPE_SIGN (TREE_TYPE (val)));\n \t      new_val = val2;\n-\t      if (minval == new_val)\n+\t      if (minval == wi::to_wide (new_val))\n \t\tnew_val = NULL_TREE;\n \t    }\n \t  else\n \t    {\n \t      wide_int maxval\n \t\t= wi::max_value (prec, TYPE_SIGN (TREE_TYPE (val)));\n-\t      mask |= val2;\n-\t      if (mask == maxval)\n+\t      mask |= wi::to_wide (val2);\n+\t      if (wi::eq_p (mask, maxval))\n \t\tnew_val = NULL_TREE;\n \t      else\n \t\tnew_val = wide_int_to_tree (TREE_TYPE (val2), mask);\n@@ -5373,8 +5393,8 @@ register_edge_assert_for_2 (tree name, edge e,\n \t  bool valid_p = false, valn, cst2n;\n \t  enum tree_code ccode = comp_code;\n \n-\t  valv = wide_int::from (val, nprec, UNSIGNED);\n-\t  cst2v = wide_int::from (cst2, nprec, UNSIGNED);\n+\t  valv = wide_int::from (wi::to_wide (val), nprec, UNSIGNED);\n+\t  cst2v = wide_int::from (wi::to_wide (cst2), nprec, UNSIGNED);\n \t  valn = wi::neg_p (valv, TYPE_SIGN (TREE_TYPE (val)));\n \t  cst2n = wi::neg_p (cst2v, TYPE_SIGN (TREE_TYPE (val)));\n \t  /* If CST2 doesn't have most significant bit set,\n@@ -5671,9 +5691,10 @@ is_masked_range_test (tree name, tree valt, enum tree_code cond_code,\n   if (TREE_CODE (t) != SSA_NAME || TREE_CODE (maskt) != INTEGER_CST)\n     return false;\n \n-  wide_int mask = maskt;\n+  wi::tree_to_wide_ref mask = wi::to_wide (maskt);\n   wide_int inv_mask = ~mask;\n-  wide_int val = valt;  // Assume VALT is INTEGER_CST\n+  /* Assume VALT is INTEGER_CST.  */\n+  wi::tree_to_wide_ref val = wi::to_wide (valt);\n \n   if ((inv_mask & (inv_mask + 1)) != 0\n       || (val & mask) != val)\n@@ -6022,7 +6043,8 @@ find_switch_asserts (basic_block bb, gswitch *last)\n \t  next_min = CASE_LOW (next_cl);\n \t  next_max = CASE_HIGH (next_cl);\n \n-\t  wide_int difference = wi::sub (next_min, max ? max : min);\n+\t  wide_int difference = (wi::to_wide (next_min)\n+\t\t\t\t - wi::to_wide (max ? max : min));\n \t  if (wi::eq_p (difference, 1))\n \t    max = next_max ? next_max : next_min;\n \t  else\n@@ -6953,7 +6975,8 @@ maybe_set_nonzero_bits (basic_block bb, tree var)\n \treturn;\n     }\n   cst = gimple_assign_rhs2 (stmt);\n-  set_nonzero_bits (var, wi::bit_and_not (get_nonzero_bits (var), cst));\n+  set_nonzero_bits (var, wi::bit_and_not (get_nonzero_bits (var),\n+\t\t\t\t\t  wi::to_wide (cst)));\n }\n \n /* Convert range assertion expressions into the implied copies and\n@@ -7547,7 +7570,7 @@ vrp_evaluate_conditional_warnv_with_ops (enum tree_code code, tree op0,\n          B = A + 1; if (A < B) -> B = A + 1; if (B != 0)\n          B = A - 1; if (B > A) -> B = A - 1; if (A == 0)\n          B = A - 1; if (B < A) -> B = A - 1; if (A != 0) */\n-      else if (wi::eq_p (x, max - 1))\n+      else if (wi::to_wide (x) == max - 1)\n \t{\n \t  op0 = op1;\n \t  op1 = wide_int_to_tree (TREE_TYPE (op0), 0);\n@@ -8658,7 +8681,7 @@ intersect_ranges (enum value_range_type *vr0type,\n \t\t       == TYPE_PRECISION (ptr_type_node))\n \t\t   && TREE_CODE (vr1max) == INTEGER_CST\n \t\t   && TREE_CODE (vr1min) == INTEGER_CST\n-\t\t   && (wi::clz (wi::sub (vr1max, vr1min))\n+\t\t   && (wi::clz (wi::to_wide (vr1max) - wi::to_wide (vr1min))\n \t\t       < TYPE_PRECISION (TREE_TYPE (*vr0min)) / 2))\n \t    ;\n \t  /* Else choose the range.  */\n@@ -9679,7 +9702,8 @@ range_fits_type_p (value_range *vr, unsigned dest_precision, signop dest_sgn)\n      a signed wide_int, while a negative value cannot be represented\n      by an unsigned wide_int.  */\n   if (src_sgn != dest_sgn\n-      && (wi::lts_p (vr->min, 0) || wi::lts_p (vr->max, 0)))\n+      && (wi::lts_p (wi::to_wide (vr->min), 0)\n+\t  || wi::lts_p (wi::to_wide (vr->max), 0)))\n     return false;\n \n   /* Then we can perform the conversion on both ends and compare\n@@ -10275,7 +10299,7 @@ two_valued_val_range_p (tree var, tree *a, tree *b)\n     return false;\n \n   if (vr->type == VR_RANGE\n-      && wi::sub (vr->max, vr->min) == 1)\n+      && wi::to_wide (vr->max) - wi::to_wide (vr->min) == 1)\n     {\n       *a = vr->min;\n       *b = vr->max;\n@@ -10284,8 +10308,10 @@ two_valued_val_range_p (tree var, tree *a, tree *b)\n \n   /* ~[TYPE_MIN + 1, TYPE_MAX - 1] */\n   if (vr->type == VR_ANTI_RANGE\n-      && wi::sub (vr->min, vrp_val_min (TREE_TYPE (var))) == 1\n-      && wi::sub (vrp_val_max (TREE_TYPE (var)), vr->max) == 1)\n+      && (wi::to_wide (vr->min)\n+\t  - wi::to_wide (vrp_val_min (TREE_TYPE (var)))) == 1\n+      && (wi::to_wide (vrp_val_max (TREE_TYPE (var)))\n+\t  - wi::to_wide (vr->max)) == 1)\n     {\n       *a = vrp_val_min (TREE_TYPE (var));\n       *b = vrp_val_max (TREE_TYPE (var));\n@@ -10850,8 +10876,9 @@ vrp_finalize (bool warn_array_bounds_p)\n \t\t\t\t\t      vr_value[i]->max) == 1)))\n \t  set_ptr_nonnull (name);\n \telse if (!POINTER_TYPE_P (TREE_TYPE (name)))\n-\t  set_range_info (name, vr_value[i]->type, vr_value[i]->min,\n-\t\t\t  vr_value[i]->max);\n+\t  set_range_info (name, vr_value[i]->type,\n+\t\t\t  wi::to_wide (vr_value[i]->min),\n+\t\t\t  wi::to_wide (vr_value[i]->max));\n       }\n \n   substitute_and_fold (op_with_constant_singleton_value_range, vrp_fold_stmt);\n@@ -11047,8 +11074,9 @@ evrp_dom_walker::before_dom_children (basic_block bb)\n \t       || vr_result.type == VR_ANTI_RANGE)\n \t      && (TREE_CODE (vr_result.min) == INTEGER_CST)\n \t      && (TREE_CODE (vr_result.max) == INTEGER_CST))\n-\t    set_range_info (lhs,\n-\t\t\t    vr_result.type, vr_result.min, vr_result.max);\n+\t    set_range_info (lhs, vr_result.type,\n+\t\t\t    wi::to_wide (vr_result.min),\n+\t\t\t    wi::to_wide (vr_result.max));\n \t}\n       else if (POINTER_TYPE_P (TREE_TYPE (lhs))\n \t       && ((vr_result.type == VR_RANGE\n@@ -11121,7 +11149,9 @@ evrp_dom_walker::before_dom_children (basic_block bb)\n \t\t       || vr.type == VR_ANTI_RANGE)\n \t\t      && (TREE_CODE (vr.min) == INTEGER_CST)\n \t\t      && (TREE_CODE (vr.max) == INTEGER_CST))\n-\t\t    set_range_info (output, vr.type, vr.min, vr.max);\n+\t\t    set_range_info (output, vr.type,\n+\t\t\t\t    wi::to_wide (vr.min),\n+\t\t\t\t    wi::to_wide (vr.max));\n \t\t}\n \t      else if (POINTER_TYPE_P (TREE_TYPE (output))\n \t\t       && ((vr.type == VR_RANGE"}, {"sha": "a43177b6a39b7896ede886208e891b6e2b413f93", "filename": "gcc/tree.c", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -1584,7 +1584,7 @@ cache_integer_cst (tree t)\n     case BOOLEAN_TYPE:\n       /* Cache false or true.  */\n       limit = 2;\n-      if (wi::ltu_p (t, 2))\n+      if (wi::ltu_p (wi::to_wide (t), 2))\n \tix = TREE_INT_CST_ELT (t, 0);\n       break;\n \n@@ -1603,7 +1603,7 @@ cache_integer_cst (tree t)\n \t      if (tree_to_uhwi (t) < (unsigned HOST_WIDE_INT) INTEGER_SHARE_LIMIT)\n \t\tix = tree_to_uhwi (t);\n \t    }\n-\t  else if (wi::ltu_p (t, INTEGER_SHARE_LIMIT))\n+\t  else if (wi::ltu_p (wi::to_wide (t), INTEGER_SHARE_LIMIT))\n \t    ix = tree_to_uhwi (t);\n \t}\n       else\n@@ -1613,14 +1613,14 @@ cache_integer_cst (tree t)\n \n \t  if (integer_minus_onep (t))\n \t    ix = 0;\n-\t  else if (!wi::neg_p (t))\n+\t  else if (!wi::neg_p (wi::to_wide (t)))\n \t    {\n \t      if (prec < HOST_BITS_PER_WIDE_INT)\n \t\t{\n \t\t  if (tree_to_shwi (t) < INTEGER_SHARE_LIMIT)\n \t\t    ix = tree_to_shwi (t) + 1;\n \t\t}\n-\t      else if (wi::ltu_p (t, INTEGER_SHARE_LIMIT))\n+\t      else if (wi::ltu_p (wi::to_wide (t), INTEGER_SHARE_LIMIT))\n \t\tix = tree_to_shwi (t) + 1;\n \t    }\n \t}\n@@ -1652,7 +1652,7 @@ cache_integer_cst (tree t)\n       /* If there is already an entry for the number verify it's the\n          same.  */\n       if (*slot)\n-\tgcc_assert (wi::eq_p (tree (*slot), t));\n+\tgcc_assert (wi::to_wide (tree (*slot)) == wi::to_wide (t));\n       else\n \t/* Otherwise insert this one into the hash table.  */\n \t*slot = t;\n@@ -1969,7 +1969,7 @@ real_value_from_int_cst (const_tree type, const_tree i)\n      bitwise comparisons to see if two values are the same.  */\n   memset (&d, 0, sizeof d);\n \n-  real_from_integer (&d, type ? TYPE_MODE (type) : VOIDmode, i,\n+  real_from_integer (&d, type ? TYPE_MODE (type) : VOIDmode, wi::to_wide (i),\n \t\t     TYPE_SIGN (TREE_TYPE (i)));\n   return d;\n }\n@@ -2331,7 +2331,7 @@ integer_zerop (const_tree expr)\n   switch (TREE_CODE (expr))\n     {\n     case INTEGER_CST:\n-      return wi::eq_p (expr, 0);\n+      return wi::to_wide (expr) == 0;\n     case COMPLEX_CST:\n       return (integer_zerop (TREE_REALPART (expr))\n \t      && integer_zerop (TREE_IMAGPART (expr)));\n@@ -2410,7 +2410,8 @@ integer_all_onesp (const_tree expr)\n   else if (TREE_CODE (expr) != INTEGER_CST)\n     return 0;\n \n-  return wi::max_value (TYPE_PRECISION (TREE_TYPE (expr)), UNSIGNED) == expr;\n+  return (wi::max_value (TYPE_PRECISION (TREE_TYPE (expr)), UNSIGNED)\n+\t  == wi::to_wide (expr));\n }\n \n /* Return 1 if EXPR is the integer constant minus one.  */\n@@ -2439,7 +2440,7 @@ integer_pow2p (const_tree expr)\n   if (TREE_CODE (expr) != INTEGER_CST)\n     return 0;\n \n-  return wi::popcount (expr) == 1;\n+  return wi::popcount (wi::to_wide (expr)) == 1;\n }\n \n /* Return 1 if EXPR is an integer constant other than zero or a\n@@ -2449,7 +2450,7 @@ int\n integer_nonzerop (const_tree expr)\n {\n   return ((TREE_CODE (expr) == INTEGER_CST\n-\t   && !wi::eq_p (expr, 0))\n+\t   && wi::to_wide (expr) != 0)\n \t  || (TREE_CODE (expr) == COMPLEX_CST\n \t      && (integer_nonzerop (TREE_REALPART (expr))\n \t\t  || integer_nonzerop (TREE_IMAGPART (expr)))));\n@@ -2485,7 +2486,7 @@ tree_log2 (const_tree expr)\n   if (TREE_CODE (expr) == COMPLEX_CST)\n     return tree_log2 (TREE_REALPART (expr));\n \n-  return wi::exact_log2 (expr);\n+  return wi::exact_log2 (wi::to_wide (expr));\n }\n \n /* Similar, but return the largest integer Y such that 2 ** Y is less\n@@ -2497,7 +2498,7 @@ tree_floor_log2 (const_tree expr)\n   if (TREE_CODE (expr) == COMPLEX_CST)\n     return tree_log2 (TREE_REALPART (expr));\n \n-  return wi::floor_log2 (expr);\n+  return wi::floor_log2 (wi::to_wide (expr));\n }\n \n /* Return number of known trailing zero bits in EXPR, or, if the value of\n@@ -2514,7 +2515,7 @@ tree_ctz (const_tree expr)\n   switch (TREE_CODE (expr))\n     {\n     case INTEGER_CST:\n-      ret1 = wi::ctz (expr);\n+      ret1 = wi::ctz (wi::to_wide (expr));\n       return MIN (ret1, prec);\n     case SSA_NAME:\n       ret1 = wi::ctz (get_nonzero_bits (expr));\n@@ -4679,7 +4680,7 @@ build_simple_mem_ref_loc (location_t loc, tree ptr)\n offset_int\n mem_ref_offset (const_tree t)\n {\n-  return offset_int::from (TREE_OPERAND (t, 1), SIGNED);\n+  return offset_int::from (wi::to_wide (TREE_OPERAND (t, 1)), SIGNED);\n }\n \n /* Return an invariant ADDR_EXPR of type TYPE taking the address of BASE\n@@ -6614,7 +6615,7 @@ tree_int_cst_sign_bit (const_tree t)\n {\n   unsigned bitno = TYPE_PRECISION (TREE_TYPE (t)) - 1;\n \n-  return wi::extract_uhwi (t, bitno, 1);\n+  return wi::extract_uhwi (wi::to_wide (t), bitno, 1);\n }\n \n /* Return an indication of the sign of the integer constant T.\n@@ -6624,11 +6625,11 @@ tree_int_cst_sign_bit (const_tree t)\n int\n tree_int_cst_sgn (const_tree t)\n {\n-  if (wi::eq_p (t, 0))\n+  if (wi::to_wide (t) == 0)\n     return 0;\n   else if (TYPE_UNSIGNED (TREE_TYPE (t)))\n     return 1;\n-  else if (wi::neg_p (t))\n+  else if (wi::neg_p (wi::to_wide (t)))\n     return -1;\n   else\n     return 1;\n@@ -8291,7 +8292,7 @@ get_unwidened (tree op, tree for_type)\n   if (TREE_CODE (win) == INTEGER_CST)\n     {\n       tree wtype = TREE_TYPE (win);\n-      unsigned prec = wi::min_precision (win, TYPE_SIGN (wtype));\n+      unsigned prec = wi::min_precision (wi::to_wide (win), TYPE_SIGN (wtype));\n       if (for_type)\n \tprec = MAX (prec, final_prec);\n       if (prec < TYPE_PRECISION (wtype))\n@@ -8412,7 +8413,7 @@ int_fits_type_p (const_tree c, const_tree type)\n   /* Non-standard boolean types can have arbitrary precision but various\n      transformations assume that they can only take values 0 and +/-1.  */\n   if (TREE_CODE (type) == BOOLEAN_TYPE)\n-    return wi::fits_to_boolean_p (c, type);\n+    return wi::fits_to_boolean_p (wi::to_wide (c), type);\n \n retry:\n   type_low_bound = TYPE_MIN_VALUE (type);\n@@ -8455,7 +8456,7 @@ int_fits_type_p (const_tree c, const_tree type)\n   /* Perform some generic filtering which may allow making a decision\n      even if the bounds are not constant.  First, negative integers\n      never fit in unsigned types, */\n-  if (TYPE_UNSIGNED (type) && sgn_c == SIGNED && wi::neg_p (c))\n+  if (TYPE_UNSIGNED (type) && sgn_c == SIGNED && wi::neg_p (wi::to_wide (c)))\n     return false;\n \n   /* Second, narrower types always fit in wider ones.  */\n@@ -8474,10 +8475,10 @@ int_fits_type_p (const_tree c, const_tree type)\n \t     possible that the value will not fit.  The test below\n \t     fails if any bit is set between the sign bit of the\n \t     underlying mode and the top bit of the type.  */\n-\t  if (wi::ne_p (wi::zext (c, prec - 1), c))\n+\t  if (wi::zext (wi::to_wide (c), prec - 1) != wi::to_wide (c))\n \t    return false;\n \t}\n-      else if (wi::neg_p (c))\n+      else if (wi::neg_p (wi::to_wide (c)))\n \treturn false;\n     }\n \n@@ -8493,7 +8494,7 @@ int_fits_type_p (const_tree c, const_tree type)\n     }\n \n   /* Or to fits_to_tree_p, if nothing else.  */\n-  return wi::fits_to_tree_p (c, type);\n+  return wi::fits_to_tree_p (wi::to_wide (c), type);\n }\n \n /* Stores bounds of an integer TYPE in MIN and MAX.  If TYPE has non-constant\n@@ -8506,7 +8507,7 @@ get_type_static_bounds (const_tree type, mpz_t min, mpz_t max)\n {\n   if (!POINTER_TYPE_P (type) && TYPE_MIN_VALUE (type)\n       && TREE_CODE (TYPE_MIN_VALUE (type)) == INTEGER_CST)\n-    wi::to_mpz (TYPE_MIN_VALUE (type), min, TYPE_SIGN (type));\n+    wi::to_mpz (wi::to_wide (TYPE_MIN_VALUE (type)), min, TYPE_SIGN (type));\n   else\n     {\n       if (TYPE_UNSIGNED (type))\n@@ -8520,7 +8521,7 @@ get_type_static_bounds (const_tree type, mpz_t min, mpz_t max)\n \n   if (!POINTER_TYPE_P (type) && TYPE_MAX_VALUE (type)\n       && TREE_CODE (TYPE_MAX_VALUE (type)) == INTEGER_CST)\n-    wi::to_mpz (TYPE_MAX_VALUE (type), max, TYPE_SIGN (type));\n+    wi::to_mpz (wi::to_wide (TYPE_MAX_VALUE (type)), max, TYPE_SIGN (type));\n   else\n     {\n       wide_int mn = wi::max_value (TYPE_PRECISION (type), TYPE_SIGN (type));\n@@ -10931,7 +10932,7 @@ operand_equal_for_phi_arg_p (const_tree arg0, const_tree arg1)\n tree\n num_ending_zeros (const_tree x)\n {\n-  return build_int_cst (TREE_TYPE (x), wi::ctz (x));\n+  return build_int_cst (TREE_TYPE (x), wi::ctz (wi::to_wide (x)));\n }\n \n \n@@ -12355,7 +12356,7 @@ drop_tree_overflow (tree t)\n \n   /* For tree codes with a sharing machinery re-build the result.  */\n   if (TREE_CODE (t) == INTEGER_CST)\n-    return wide_int_to_tree (TREE_TYPE (t), t);\n+    return wide_int_to_tree (TREE_TYPE (t), wi::to_wide (t));\n \n   /* Otherwise, as all tcc_constants are possibly shared, copy the node\n      and drop the flag.  */\n@@ -13528,7 +13529,7 @@ get_range_pos_neg (tree arg)\n   int cnt = 0;\n   if (TREE_CODE (arg) == INTEGER_CST)\n     {\n-      wide_int w = wi::sext (arg, prec);\n+      wide_int w = wi::sext (wi::to_wide (arg), prec);\n       if (wi::neg_p (w))\n \treturn 2;\n       else"}, {"sha": "7c2d2e7eb021867ea2d230ce1e066cb09ff69f7b", "filename": "gcc/tree.h", "status": "modified", "additions": 94, "deletions": 35, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -5120,20 +5120,6 @@ extern bool anon_aggrname_p (const_tree);\n /* The tree and const_tree overload templates.   */\n namespace wi\n {\n-  template <>\n-  struct int_traits <const_tree>\n-  {\n-    static const enum precision_type precision_type = VAR_PRECISION;\n-    static const bool host_dependent_precision = false;\n-    static const bool is_sign_extended = false;\n-    static unsigned int get_precision (const_tree);\n-    static wi::storage_ref decompose (HOST_WIDE_INT *, unsigned int,\n-\t\t\t\t      const_tree);\n-  };\n-\n-  template <>\n-  struct int_traits <tree> : public int_traits <const_tree> {};\n-\n   template <int N>\n   class extended_tree\n   {\n@@ -5157,50 +5143,123 @@ namespace wi\n     static const unsigned int precision = N;\n   };\n \n-  generic_wide_int <extended_tree <WIDE_INT_MAX_PRECISION> >\n-  to_widest (const_tree);\n-\n-  generic_wide_int <extended_tree <ADDR_MAX_PRECISION> > to_offset (const_tree);\n+  typedef const generic_wide_int <extended_tree <WIDE_INT_MAX_PRECISION> >\n+    tree_to_widest_ref;\n+  typedef const generic_wide_int <extended_tree <ADDR_MAX_PRECISION> >\n+    tree_to_offset_ref;\n+  typedef const generic_wide_int<wide_int_ref_storage<false, false> >\n+    tree_to_wide_ref;\n \n+  tree_to_widest_ref to_widest (const_tree);\n+  tree_to_offset_ref to_offset (const_tree);\n+  tree_to_wide_ref to_wide (const_tree);\n   wide_int to_wide (const_tree, unsigned int);\n }\n \n-inline unsigned int\n-wi::int_traits <const_tree>::get_precision (const_tree tcst)\n-{\n-  return TYPE_PRECISION (TREE_TYPE (tcst));\n-}\n+/* Refer to INTEGER_CST T as though it were a widest_int.\n \n-/* Convert the tree_cst X into a wide_int of PRECISION.  */\n-inline wi::storage_ref\n-wi::int_traits <const_tree>::decompose (HOST_WIDE_INT *,\n-\t\t\t\t\tunsigned int precision, const_tree x)\n-{\n-  gcc_checking_assert (precision == TYPE_PRECISION (TREE_TYPE (x)));\n-  return wi::storage_ref (&TREE_INT_CST_ELT (x, 0), TREE_INT_CST_NUNITS (x),\n-\t\t\t  precision);\n-}\n+   This function gives T's actual numerical value, influenced by the\n+   signedness of its type.  For example, a signed byte with just the\n+   top bit set would be -128 while an unsigned byte with the same\n+   bit pattern would be 128.\n+\n+   This is the right choice when operating on groups of INTEGER_CSTs\n+   that might have different signedness or precision.  It is also the\n+   right choice in code that specifically needs an approximation of\n+   infinite-precision arithmetic instead of normal modulo arithmetic.\n+\n+   The approximation of infinite precision is good enough for realistic\n+   numbers of additions and subtractions of INTEGER_CSTs (where\n+   \"realistic\" includes any number less than 1 << 31) but it cannot\n+   represent the result of multiplying the two largest supported\n+   INTEGER_CSTs.  The overflow-checking form of wi::mul provides a way\n+   of multiplying two arbitrary INTEGER_CSTs and checking that the\n+   result is representable as a widest_int.\n+\n+   Note that any overflow checking done on these values is relative to\n+   the range of widest_int rather than the range of a TREE_TYPE.\n+\n+   Calling this function should have no overhead in release builds,\n+   so it is OK to call it several times for the same tree.  If it is\n+   useful for readability reasons to reduce the number of calls,\n+   it is more efficient to use:\n+\n+     wi::tree_to_widest_ref wt = wi::to_widest (t);\n+\n+   instead of:\n \n-inline generic_wide_int <wi::extended_tree <WIDE_INT_MAX_PRECISION> >\n+     widest_int wt = wi::to_widest (t).  */\n+\n+inline wi::tree_to_widest_ref\n wi::to_widest (const_tree t)\n {\n   return t;\n }\n \n-inline generic_wide_int <wi::extended_tree <ADDR_MAX_PRECISION> >\n+/* Refer to INTEGER_CST T as though it were an offset_int.\n+\n+   This function is an optimisation of wi::to_widest for cases\n+   in which T is known to be a bit or byte count in the range\n+   (-(2 ^ (N + BITS_PER_UNIT)), 2 ^ (N + BITS_PER_UNIT)), where N is\n+   the target's address size in bits.\n+\n+   This is the right choice when operating on bit or byte counts as\n+   untyped numbers rather than M-bit values.  The wi::to_widest comments\n+   about addition, subtraction and multiplication apply here: sequences\n+   of 1 << 31 additions and subtractions do not induce overflow, but\n+   multiplying the largest sizes might.  Again,\n+\n+     wi::tree_to_offset_ref wt = wi::to_offset (t);\n+\n+   is more efficient than:\n+\n+     offset_int wt = wi::to_offset (t).  */\n+\n+inline wi::tree_to_offset_ref\n wi::to_offset (const_tree t)\n {\n   return t;\n }\n \n+/* Refer to INTEGER_CST T as though it were a wide_int.\n+\n+   In contrast to the approximation of infinite-precision numbers given\n+   by wi::to_widest and wi::to_offset, this function treats T as a\n+   signless collection of N bits, where N is the precision of T's type.\n+   As with machine registers, signedness is determined by the operation\n+   rather than the operands; for example, there is a distinction between\n+   signed and unsigned division.\n+\n+   This is the right choice when operating on values with the same type\n+   using normal modulo arithmetic.  The overflow-checking forms of things\n+   like wi::add check whether the result can be represented in T's type.\n+\n+   Calling this function should have no overhead in release builds,\n+   so it is OK to call it several times for the same tree.  If it is\n+   useful for readability reasons to reduce the number of calls,\n+   it is more efficient to use:\n+\n+     wi::tree_to_wide_ref wt = wi::to_wide (t);\n+\n+   instead of:\n+\n+     wide_int wt = wi::to_wide (t).  */\n+\n+inline wi::tree_to_wide_ref\n+wi::to_wide (const_tree t)\n+{\n+  return wi::storage_ref (&TREE_INT_CST_ELT (t, 0), TREE_INT_CST_NUNITS (t),\n+\t\t\t  TYPE_PRECISION (TREE_TYPE (t)));\n+}\n+\n /* Convert INTEGER_CST T to a wide_int of precision PREC, extending or\n    truncating as necessary.  When extending, use sign extension if T's\n    type is signed and zero extension if T's type is unsigned.  */\n \n inline wide_int\n wi::to_wide (const_tree t, unsigned int prec)\n {\n-  return wide_int::from (t, prec, TYPE_SIGN (TREE_TYPE (t)));\n+  return wide_int::from (wi::to_wide (t), prec, TYPE_SIGN (TREE_TYPE (t)));\n }\n \n template <int N>"}, {"sha": "6c4fe0e77a00bc9534aaa95fa19eede585ee8e1c", "filename": "gcc/ubsan.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fubsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fubsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fubsan.c?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -1164,8 +1164,8 @@ ubsan_expand_ptr_ifn (gimple_stmt_iterator *gsip)\n   unlink_stmt_vdef (stmt);\n \n   if (TREE_CODE (off) == INTEGER_CST)\n-    g = gimple_build_cond (wi::neg_p (off) ? LT_EXPR : GE_EXPR, ptri,\n-\t\t\t   fold_build1 (NEGATE_EXPR, sizetype, off),\n+    g = gimple_build_cond (wi::neg_p (wi::to_wide (off)) ? LT_EXPR : GE_EXPR,\n+\t\t\t   ptri, fold_build1 (NEGATE_EXPR, sizetype, off),\n \t\t\t   NULL_TREE, NULL_TREE);\n   else if (pos_neg != 3)\n     g = gimple_build_cond (pos_neg == 1 ? LT_EXPR : GT_EXPR,"}, {"sha": "e17b016af040f2d08a93c50d473ede2268e9d4ba", "filename": "gcc/wide-int.h", "status": "modified", "additions": 36, "deletions": 28, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fwide-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6cdc90d41633e09a3a34bb8c6f71cf246101b2/gcc%2Fwide-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fwide-int.h?ref=8e6cdc90d41633e09a3a34bb8c6f71cf246101b2", "patch": "@@ -150,15 +150,23 @@ along with GCC; see the file COPYING3.  If not see\n    and in wider precisions.\n \n    There are constructors to create the various forms of wide_int from\n-   trees, rtl and constants.  For trees you can simply say:\n+   trees, rtl and constants.  For trees the options are:\n \n \t     tree t = ...;\n-\t     wide_int x = t;\n+\t     wi::to_wide (t)     // Treat T as a wide_int\n+\t     wi::to_offset (t)   // Treat T as an offset_int\n+\t     wi::to_widest (t)   // Treat T as a widest_int\n \n-   However, a little more syntax is required for rtl constants since\n-   they do not have an explicit precision.  To make an rtl into a\n-   wide_int, you have to pair it with a mode.  The canonical way to do\n-   this is with rtx_mode_t as in:\n+   All three are light-weight accessors that should have no overhead\n+   in release builds.  If it is useful for readability reasons to\n+   store the result in a temporary variable, the preferred method is:\n+\n+\t     wi::tree_to_wide_ref twide = wi::to_wide (t);\n+\t     wi::tree_to_offset_ref toffset = wi::to_offset (t);\n+\t     wi::tree_to_widest_ref twidest = wi::to_widest (t);\n+\n+   To make an rtx into a wide_int, you have to pair it with a mode.\n+   The canonical way to do this is with rtx_mode_t as in:\n \n \t     rtx r = ...\n \t     wide_int x = rtx_mode_t (r, mode);\n@@ -175,23 +183,22 @@ along with GCC; see the file COPYING3.  If not see\n \t     offset_int x = (int) c;          // sign-extend C\n \t     widest_int x = (unsigned int) c; // zero-extend C\n \n-   It is also possible to do arithmetic directly on trees, rtxes and\n+   It is also possible to do arithmetic directly on rtx_mode_ts and\n    constants.  For example:\n \n-\t     wi::add (t1, t2);\t  // add equal-sized INTEGER_CSTs t1 and t2\n-\t     wi::add (t1, 1);     // add 1 to INTEGER_CST t1\n-\t     wi::add (r1, r2);    // add equal-sized rtx constants r1 and r2\n+\t     wi::add (r1, r2);    // add equal-sized rtx_mode_ts r1 and r2\n+\t     wi::add (r1, 1);     // add 1 to rtx_mode_t r1\n \t     wi::lshift (1, 100); // 1 << 100 as a widest_int\n \n    Many binary operations place restrictions on the combinations of inputs,\n    using the following rules:\n \n-   - {tree, rtx, wide_int} op {tree, rtx, wide_int} -> wide_int\n+   - {rtx, wide_int} op {rtx, wide_int} -> wide_int\n        The inputs must be the same precision.  The result is a wide_int\n        of the same precision\n \n-   - {tree, rtx, wide_int} op (un)signed HOST_WIDE_INT -> wide_int\n-     (un)signed HOST_WIDE_INT op {tree, rtx, wide_int} -> wide_int\n+   - {rtx, wide_int} op (un)signed HOST_WIDE_INT -> wide_int\n+     (un)signed HOST_WIDE_INT op {rtx, wide_int} -> wide_int\n        The HOST_WIDE_INT is extended or truncated to the precision of\n        the other input.  The result is a wide_int of the same precision\n        as that input.\n@@ -316,7 +323,9 @@ typedef generic_wide_int <wide_int_storage> wide_int;\n typedef FIXED_WIDE_INT (ADDR_MAX_PRECISION) offset_int;\n typedef FIXED_WIDE_INT (WIDE_INT_MAX_PRECISION) widest_int;\n \n-template <bool SE>\n+/* wi::storage_ref can be a reference to a primitive type,\n+   so this is the conservatively-correct setting.  */\n+template <bool SE, bool HDP = true>\n struct wide_int_ref_storage;\n \n typedef generic_wide_int <wide_int_ref_storage <false> > wide_int_ref;\n@@ -330,7 +339,8 @@ typedef generic_wide_int <wide_int_ref_storage <false> > wide_int_ref;\n    to use those.  */\n #define WIDE_INT_REF_FOR(T) \\\n   generic_wide_int \\\n-    <wide_int_ref_storage <wi::int_traits <T>::is_sign_extended> >\n+    <wide_int_ref_storage <wi::int_traits <T>::is_sign_extended, \\\n+\t\t\t   wi::int_traits <T>::host_dependent_precision> >\n \n namespace wi\n {\n@@ -929,7 +939,7 @@ decompose (HOST_WIDE_INT *, unsigned int precision,\n /* Provide the storage for a wide_int_ref.  This acts like a read-only\n    wide_int, with the optimization that VAL is normally a pointer to\n    another integer's storage, so that no array copy is needed.  */\n-template <bool SE>\n+template <bool SE, bool HDP>\n struct wide_int_ref_storage : public wi::storage_ref\n {\n private:\n@@ -948,41 +958,39 @@ struct wide_int_ref_storage : public wi::storage_ref\n };\n \n /* Create a reference from an existing reference.  */\n-template <bool SE>\n-inline wide_int_ref_storage <SE>::\n+template <bool SE, bool HDP>\n+inline wide_int_ref_storage <SE, HDP>::\n wide_int_ref_storage (const wi::storage_ref &x)\n   : storage_ref (x)\n {}\n \n /* Create a reference to integer X in its natural precision.  Note\n    that the natural precision is host-dependent for primitive\n    types.  */\n-template <bool SE>\n+template <bool SE, bool HDP>\n template <typename T>\n-inline wide_int_ref_storage <SE>::wide_int_ref_storage (const T &x)\n+inline wide_int_ref_storage <SE, HDP>::wide_int_ref_storage (const T &x)\n   : storage_ref (wi::int_traits <T>::decompose (scratch,\n \t\t\t\t\t\twi::get_precision (x), x))\n {\n }\n \n /* Create a reference to integer X in precision PRECISION.  */\n-template <bool SE>\n+template <bool SE, bool HDP>\n template <typename T>\n-inline wide_int_ref_storage <SE>::wide_int_ref_storage (const T &x,\n-\t\t\t\t\t\t\tunsigned int precision)\n+inline wide_int_ref_storage <SE, HDP>::\n+wide_int_ref_storage (const T &x, unsigned int precision)\n   : storage_ref (wi::int_traits <T>::decompose (scratch, precision, x))\n {\n }\n \n namespace wi\n {\n-  template <bool SE>\n-  struct int_traits <wide_int_ref_storage <SE> >\n+  template <bool SE, bool HDP>\n+  struct int_traits <wide_int_ref_storage <SE, HDP> >\n   {\n     static const enum precision_type precision_type = VAR_PRECISION;\n-    /* wi::storage_ref can be a reference to a primitive type,\n-       so this is the conservatively-correct setting.  */\n-    static const bool host_dependent_precision = true;\n+    static const bool host_dependent_precision = HDP;\n     static const bool is_sign_extended = SE;\n   };\n }"}]}