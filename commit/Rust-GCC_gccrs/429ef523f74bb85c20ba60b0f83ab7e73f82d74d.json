{"sha": "429ef523f74bb85c20ba60b0f83ab7e73f82d74d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDI5ZWY1MjNmNzRiYjg1YzIwYmE2MGIwZjgzYWI3ZTczZjgyZDc0ZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-13T18:01:49Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-13T18:01:49Z"}, "message": "Allow gather loads to be used for grouped accesses\n\nFollowing on from the previous patch for strided accesses, this patch\nallows gather loads to be used with grouped accesses, if we otherwise\nwould need to fall back to VMAT_ELEMENTWISE.  However, as the comment\nsays, this is restricted to single-element groups for now:\n\n\t ??? Although the code can handle all group sizes correctly,\n\t it probably isn't a win to use separate strided accesses based\n\t on nearby locations.  Or, even if it's a win over scalar code,\n\t it might not be a win over vectorizing at a lower VF, if that\n\t allows us to use contiguous accesses.\n\nSingle-element groups are an important special case though,\nand this means that code is less sensitive to GCC's classification\nof single accesses with constant steps as \"grouped\" and ones with\nvariable steps as \"strided\".\n\n2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* tree-vectorizer.h (vect_gather_scatter_fn_p): Declare.\n\t* tree-vect-data-refs.c (vect_gather_scatter_fn_p): Make public.\n\t* tree-vect-stmts.c (vect_truncate_gather_scatter_offset): New\n\tfunction.\n\t(vect_use_strided_gather_scatters_p): Take a masked_p argument.\n\tUse vect_truncate_gather_scatter_offset if we can't treat the\n\toperation as a normal gather load or scatter store.\n\t(get_group_load_store_type): Take the gather_scatter_info\n\tas argument.  Try using a gather load or scatter store for\n\tsingle-element groups.\n\t(get_load_store_type): Update calls to get_group_load_store_type\n\tand vect_use_strided_gather_scatters_p.\n\ngcc/testsuite/\n\t* gcc.target/aarch64/sve/reduc_strict_3.c: Expect FADDA to be used\n\tfor double_reduc1.\n\t* gcc.target/aarch64/sve/strided_load_4.c: New test.\n\t* gcc.target/aarch64/sve/strided_load_5.c: Likewise.\n\t* gcc.target/aarch64/sve/strided_load_6.c: Likewise.\n\t* gcc.target/aarch64/sve/strided_load_7.c: Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256642", "tree": {"sha": "bc0950b9148fc31de4da0f855b784687fae88a81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc0950b9148fc31de4da0f855b784687fae88a81"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/429ef523f74bb85c20ba60b0f83ab7e73f82d74d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/429ef523f74bb85c20ba60b0f83ab7e73f82d74d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/429ef523f74bb85c20ba60b0f83ab7e73f82d74d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/429ef523f74bb85c20ba60b0f83ab7e73f82d74d/comments", "author": null, "committer": null, "parents": [{"sha": "ab2fc782509f934ef0cc22c31d743fcb63063c1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab2fc782509f934ef0cc22c31d743fcb63063c1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab2fc782509f934ef0cc22c31d743fcb63063c1b"}], "stats": {"total": 276, "additions": 263, "deletions": 13}, "files": [{"sha": "c660ff13f0df3a48c0e533196845bb1c55611c70", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/429ef523f74bb85c20ba60b0f83ab7e73f82d74d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/429ef523f74bb85c20ba60b0f83ab7e73f82d74d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=429ef523f74bb85c20ba60b0f83ab7e73f82d74d", "patch": "@@ -1,3 +1,20 @@\n+2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* tree-vectorizer.h (vect_gather_scatter_fn_p): Declare.\n+\t* tree-vect-data-refs.c (vect_gather_scatter_fn_p): Make public.\n+\t* tree-vect-stmts.c (vect_truncate_gather_scatter_offset): New\n+\tfunction.\n+\t(vect_use_strided_gather_scatters_p): Take a masked_p argument.\n+\tUse vect_truncate_gather_scatter_offset if we can't treat the\n+\toperation as a normal gather load or scatter store.\n+\t(get_group_load_store_type): Take the gather_scatter_info\n+\tas argument.  Try using a gather load or scatter store for\n+\tsingle-element groups.\n+\t(get_load_store_type): Update calls to get_group_load_store_type\n+\tand vect_use_strided_gather_scatters_p.\n+\n 2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "20d84c268403ed1653a35ef748834d2be270b59e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/429ef523f74bb85c20ba60b0f83ab7e73f82d74d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/429ef523f74bb85c20ba60b0f83ab7e73f82d74d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=429ef523f74bb85c20ba60b0f83ab7e73f82d74d", "patch": "@@ -1,3 +1,14 @@\n+2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* gcc.target/aarch64/sve/reduc_strict_3.c: Expect FADDA to be used\n+\tfor double_reduc1.\n+\t* gcc.target/aarch64/sve/strided_load_4.c: New test.\n+\t* gcc.target/aarch64/sve/strided_load_5.c: Likewise.\n+\t* gcc.target/aarch64/sve/strided_load_6.c: Likewise.\n+\t* gcc.target/aarch64/sve/strided_load_7.c: Likewise.\n+\n 2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "a718e9d2ebfabae80b4d00d4733cfe0706778c2d", "filename": "gcc/testsuite/gcc.target/aarch64/sve/reduc_strict_3.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/429ef523f74bb85c20ba60b0f83ab7e73f82d74d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_strict_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/429ef523f74bb85c20ba60b0f83ab7e73f82d74d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_strict_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_strict_3.c?ref=429ef523f74bb85c20ba60b0f83ab7e73f82d74d", "patch": "@@ -118,14 +118,11 @@ double_reduc3 (float *restrict i, float *restrict j)\n   return l * k;\n }\n \n-/* We can't yet handle double_reduc1.  */\n-/* { dg-final { scan-assembler-times {\\tfadda\\ts[0-9]+, p[0-7], s[0-9]+, z[0-9]+\\.s} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tfadda\\ts[0-9]+, p[0-7], s[0-9]+, z[0-9]+\\.s} 4 } } */\n /* { dg-final { scan-assembler-times {\\tfadda\\td[0-9]+, p[0-7], d[0-9]+, z[0-9]+\\.d} 9 } } */\n /* 1 reduction each for double_reduc{1,2} and 2 for double_reduc3.  Each one\n    is reported three times, once for SVE, once for 128-bit AdvSIMD and once\n    for 64-bit AdvSIMD.  */\n /* { dg-final { scan-tree-dump-times \"Detected double reduction\" 12 \"vect\" } } */\n-/* double_reduc2 has 2 reductions and slp_non_chained_reduc has 3.\n-   double_reduc1 is reported 3 times (SVE, 128-bit AdvSIMD, 64-bit AdvSIMD)\n-   before failing.  */\n-/* { dg-final { scan-tree-dump-times \"Detected reduction\" 12 \"vect\" } } */\n+/* double_reduc2 has 2 reductions and slp_non_chained_reduc has 3.  */\n+/* { dg-final { scan-tree-dump-times \"Detected reduction\" 10 \"vect\" } } */"}, {"sha": "0eff3844706389414d113b214b4058612dbb39c3", "filename": "gcc/testsuite/gcc.target/aarch64/sve/strided_load_4.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/429ef523f74bb85c20ba60b0f83ab7e73f82d74d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstrided_load_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/429ef523f74bb85c20ba60b0f83ab7e73f82d74d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstrided_load_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstrided_load_4.c?ref=429ef523f74bb85c20ba60b0f83ab7e73f82d74d", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O2 -ftree-vectorize --save-temps\" } */\n+\n+#include <stdint.h>\n+\n+#define TEST_LOOP(DATA_TYPE, NAME, SCALE)\t\t\t\\\n+  void __attribute__ ((noinline, noclone))\t\t\t\\\n+  f_##DATA_TYPE##_##NAME (DATA_TYPE *restrict dest,\t\t\\\n+\t\t\t   DATA_TYPE *restrict src, int n)\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < n; ++i)\t\t\t\t\t\\\n+      dest[i] += src[i * SCALE];\t\t\t\t\\\n+  }\n+\n+#define TEST_TYPE(T, DATA_TYPE)\t\t\t\\\n+  T (DATA_TYPE, 5, 5)\t\t\t\t\\\n+  T (DATA_TYPE, 7, 7)\t\t\t\t\\\n+  T (DATA_TYPE, 11, 11)\t\t\t\t\\\n+  T (DATA_TYPE, 200, 200)\t\t\t\\\n+  T (DATA_TYPE, m100, -100)\n+\n+#define TEST_ALL(T)\t\t\t\t\\\n+  TEST_TYPE (T, int32_t)\t\t\t\\\n+  TEST_TYPE (T, uint32_t)\t\t\t\\\n+  TEST_TYPE (T, float)\t\t\t\t\\\n+  TEST_TYPE (T, int64_t)\t\t\t\\\n+  TEST_TYPE (T, uint64_t)\t\t\t\\\n+  TEST_TYPE (T, double)\n+\n+TEST_ALL (TEST_LOOP)\n+\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+\\.s, p[0-7]/z, \\[x[0-9]+, z[0-9]+.s, sxtw 2\\]\\n} 15 } } */\n+/* { dg-final { scan-assembler-times {\\tld1d\\tz[0-9]+\\.d, p[0-7]/z, \\[x[0-9]+, z[0-9]+.d, lsl 3\\]\\n} 15 } } */"}, {"sha": "415b466d6986889350c3cab09df05e3012a4a145", "filename": "gcc/testsuite/gcc.target/aarch64/sve/strided_load_5.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/429ef523f74bb85c20ba60b0f83ab7e73f82d74d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstrided_load_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/429ef523f74bb85c20ba60b0f83ab7e73f82d74d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstrided_load_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstrided_load_5.c?ref=429ef523f74bb85c20ba60b0f83ab7e73f82d74d", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O2 -ftree-vectorize -msve-vector-bits=256 --save-temps\" } */\n+\n+#include <stdint.h>\n+\n+#define TEST_LOOP(DATA_TYPE, NAME, SCALE)\t\t\t\\\n+  void __attribute__ ((noinline, noclone))\t\t\t\\\n+  f_##DATA_TYPE##_##NAME (DATA_TYPE *restrict dest,\t\t\\\n+\t\t\t  DATA_TYPE *restrict src, long n)\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    for (long i = 0; i < n; ++i)\t\t\t\t\\\n+      dest[i] += src[i * SCALE];\t\t\t\t\\\n+  }\n+\n+#define TEST_TYPE(T, DATA_TYPE)\t\t\t\\\n+  T (DATA_TYPE, 5, 5)\t\t\t\t\\\n+  T (DATA_TYPE, 7, 7)\t\t\t\t\\\n+  T (DATA_TYPE, 11, 11)\t\t\t\t\\\n+  T (DATA_TYPE, 200, 200)\t\t\t\\\n+  T (DATA_TYPE, m100, -100)\n+\n+#define TEST_ALL(T)\t\t\t\t\\\n+  TEST_TYPE (T, int32_t)\t\t\t\\\n+  TEST_TYPE (T, uint32_t)\t\t\t\\\n+  TEST_TYPE (T, float)\t\t\t\t\\\n+  TEST_TYPE (T, int64_t)\t\t\t\\\n+  TEST_TYPE (T, uint64_t)\t\t\t\\\n+  TEST_TYPE (T, double)\n+\n+TEST_ALL (TEST_LOOP)\n+\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+\\.s, p[0-7]/z, \\[x[0-9]+, z[0-9]+.s, uxtw\\]\\n} 12 } } */\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+\\.s, p[0-7]/z, \\[x[0-9]+, z[0-9]+.s, sxtw\\]\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1d\\tz[0-9]+\\.d, p[0-7]/z, \\[x[0-9]+, z[0-9]+.d\\]\\n} 15 } } */"}, {"sha": "9e0001551c1cf9af4e30e262ca3f218bea139172", "filename": "gcc/testsuite/gcc.target/aarch64/sve/strided_load_6.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/429ef523f74bb85c20ba60b0f83ab7e73f82d74d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstrided_load_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/429ef523f74bb85c20ba60b0f83ab7e73f82d74d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstrided_load_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstrided_load_6.c?ref=429ef523f74bb85c20ba60b0f83ab7e73f82d74d", "patch": "@@ -0,0 +1,7 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O2 -ftree-vectorize -msve-vector-bits=scalable --save-temps\" } */\n+\n+#include \"strided_load_5.c\"\n+\n+/* { dg-final { scan-assembler-not {\\[x[0-9]+, z[0-9]+\\.s} } } */\n+/* { dg-final { scan-assembler-times {\\tld1d\\tz[0-9]+\\.d, p[0-7]/z, \\[x[0-9]+, z[0-9]+.d\\]\\n} 15 } } */"}, {"sha": "3a363677525b8e95bc0c61f487ac7ec1b51c4547", "filename": "gcc/testsuite/gcc.target/aarch64/sve/strided_load_7.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/429ef523f74bb85c20ba60b0f83ab7e73f82d74d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstrided_load_7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/429ef523f74bb85c20ba60b0f83ab7e73f82d74d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstrided_load_7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstrided_load_7.c?ref=429ef523f74bb85c20ba60b0f83ab7e73f82d74d", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O2 -ftree-vectorize --save-temps\" } */\n+\n+#include <stdint.h>\n+\n+#define TEST_LOOP(DATA_TYPE, NAME, SCALE)\t\t\t\\\n+  void __attribute__ ((noinline, noclone))\t\t\t\\\n+  f_##DATA_TYPE##_##NAME (DATA_TYPE *restrict dest,\t\t\\\n+\t\t\t  DATA_TYPE *restrict src)\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    for (long i = 0; i < 1000; ++i)\t\t\t\t\\\n+      dest[i] += src[i * SCALE];\t\t\t\t\\\n+  }\n+\n+#define TEST_TYPE(T, DATA_TYPE)\t\t\t\\\n+  T (DATA_TYPE, 5, 5)\t\t\t\t\\\n+  T (DATA_TYPE, 7, 7)\t\t\t\t\\\n+  T (DATA_TYPE, 11, 11)\t\t\t\t\\\n+  T (DATA_TYPE, 200, 200)\t\t\t\\\n+  T (DATA_TYPE, m100, -100)\n+\n+#define TEST_ALL(T)\t\t\t\t\\\n+  TEST_TYPE (T, int32_t)\t\t\t\\\n+  TEST_TYPE (T, uint32_t)\t\t\t\\\n+  TEST_TYPE (T, float)\t\t\t\t\\\n+  TEST_TYPE (T, int64_t)\t\t\t\\\n+  TEST_TYPE (T, uint64_t)\t\t\t\\\n+  TEST_TYPE (T, double)\n+\n+TEST_ALL (TEST_LOOP)\n+\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+\\.s, p[0-7]/z, \\[x[0-9]+, z[0-9]+.s, uxtw\\]\\n} 12 } } */\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+\\.s, p[0-7]/z, \\[x[0-9]+, z[0-9]+.s, sxtw\\]\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1d\\tz[0-9]+\\.d, p[0-7]/z, \\[x[0-9]+, z[0-9]+.d\\]\\n} 15 } } */"}, {"sha": "daa8b0c36d3fea7d0ffb5831c76f65556efddcd5", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/429ef523f74bb85c20ba60b0f83ab7e73f82d74d/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/429ef523f74bb85c20ba60b0f83ab7e73f82d74d/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=429ef523f74bb85c20ba60b0f83ab7e73f82d74d", "patch": "@@ -3312,7 +3312,7 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n    Return true if the function is supported, storing the function\n    id in *IFN_OUT and the type of a vector element in *ELEMENT_TYPE_OUT.  */\n \n-static bool\n+bool\n vect_gather_scatter_fn_p (bool read_p, bool masked_p, tree vectype,\n \t\t\t  tree memory_type, unsigned int offset_bits,\n \t\t\t  signop offset_sign, int scale,"}, {"sha": "df588347789184bca1a726d469561f379048446e", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 121, "deletions": 6, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/429ef523f74bb85c20ba60b0f83ab7e73f82d74d/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/429ef523f74bb85c20ba60b0f83ab7e73f82d74d/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=429ef523f74bb85c20ba60b0f83ab7e73f82d74d", "patch": "@@ -1849,18 +1849,117 @@ prepare_load_store_mask (tree mask_type, tree loop_mask, tree vec_mask,\n   return and_res;\n }\n \n+/* Determine whether we can use a gather load or scatter store to vectorize\n+   strided load or store STMT by truncating the current offset to a smaller\n+   width.  We need to be able to construct an offset vector:\n+\n+     { 0, X, X*2, X*3, ... }\n+\n+   without loss of precision, where X is STMT's DR_STEP.\n+\n+   Return true if this is possible, describing the gather load or scatter\n+   store in GS_INFO.  MASKED_P is true if the load or store is conditional.  */\n+\n+static bool\n+vect_truncate_gather_scatter_offset (gimple *stmt, loop_vec_info loop_vinfo,\n+\t\t\t\t     bool masked_p,\n+\t\t\t\t     gather_scatter_info *gs_info)\n+{\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n+  tree step = DR_STEP (dr);\n+  if (TREE_CODE (step) != INTEGER_CST)\n+    {\n+      /* ??? Perhaps we could use range information here?  */\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"cannot truncate variable step.\\n\");\n+      return false;\n+    }\n+\n+  /* Get the number of bits in an element.  */\n+  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n+  scalar_mode element_mode = SCALAR_TYPE_MODE (TREE_TYPE (vectype));\n+  unsigned int element_bits = GET_MODE_BITSIZE (element_mode);\n+\n+  /* Set COUNT to the upper limit on the number of elements - 1.\n+     Start with the maximum vectorization factor.  */\n+  unsigned HOST_WIDE_INT count = vect_max_vf (loop_vinfo) - 1;\n+\n+  /* Try lowering COUNT to the number of scalar latch iterations.  */\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  widest_int max_iters;\n+  if (max_loop_iterations (loop, &max_iters)\n+      && max_iters < count)\n+    count = max_iters.to_shwi ();\n+\n+  /* Try scales of 1 and the element size.  */\n+  int scales[] = { 1, vect_get_scalar_dr_size (dr) };\n+  bool overflow_p = false;\n+  for (int i = 0; i < 2; ++i)\n+    {\n+      int scale = scales[i];\n+      widest_int factor;\n+      if (!wi::multiple_of_p (wi::to_widest (step), scale, SIGNED, &factor))\n+\tcontinue;\n+\n+      /* See whether we can calculate (COUNT - 1) * STEP / SCALE\n+\t in OFFSET_BITS bits.  */\n+      widest_int range = wi::mul (count, factor, SIGNED, &overflow_p);\n+      if (overflow_p)\n+\tcontinue;\n+      signop sign = range >= 0 ? UNSIGNED : SIGNED;\n+      if (wi::min_precision (range, sign) > element_bits)\n+\t{\n+\t  overflow_p = true;\n+\t  continue;\n+\t}\n+\n+      /* See whether the target supports the operation.  */\n+      tree memory_type = TREE_TYPE (DR_REF (dr));\n+      if (!vect_gather_scatter_fn_p (DR_IS_READ (dr), masked_p, vectype,\n+\t\t\t\t     memory_type, element_bits, sign, scale,\n+\t\t\t\t     &gs_info->ifn, &gs_info->element_type))\n+\tcontinue;\n+\n+      tree offset_type = build_nonstandard_integer_type (element_bits,\n+\t\t\t\t\t\t\t sign == UNSIGNED);\n+\n+      gs_info->decl = NULL_TREE;\n+      /* Logically the sum of DR_BASE_ADDRESS, DR_INIT and DR_OFFSET,\n+\t but we don't need to store that here.  */\n+      gs_info->base = NULL_TREE;\n+      gs_info->offset = fold_convert (offset_type, step);\n+      gs_info->offset_dt = vect_unknown_def_type;\n+      gs_info->offset_vectype = NULL_TREE;\n+      gs_info->scale = scale;\n+      gs_info->memory_type = memory_type;\n+      return true;\n+    }\n+\n+  if (overflow_p && dump_enabled_p ())\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"truncating gather/scatter offset to %d bits\"\n+\t\t     \" might change its value.\\n\", element_bits);\n+\n+  return false;\n+}\n+\n /* Return true if we can use gather/scatter internal functions to\n    vectorize STMT, which is a grouped or strided load or store.\n-   When returning true, fill in GS_INFO with the information required\n-   to perform the operation.  */\n+   MASKED_P is true if load or store is conditional.  When returning\n+   true, fill in GS_INFO with the information required to perform the\n+   operation.  */\n \n static bool\n vect_use_strided_gather_scatters_p (gimple *stmt, loop_vec_info loop_vinfo,\n+\t\t\t\t    bool masked_p,\n \t\t\t\t    gather_scatter_info *gs_info)\n {\n   if (!vect_check_gather_scatter (stmt, loop_vinfo, gs_info)\n       || gs_info->decl)\n-    return false;\n+    return vect_truncate_gather_scatter_offset (stmt, loop_vinfo,\n+\t\t\t\t\t\tmasked_p, gs_info);\n \n   scalar_mode element_mode = SCALAR_TYPE_MODE (gs_info->element_type);\n   unsigned int element_bits = GET_MODE_BITSIZE (element_mode);\n@@ -1951,7 +2050,8 @@ vect_get_store_rhs (gimple *stmt)\n static bool\n get_group_load_store_type (gimple *stmt, tree vectype, bool slp,\n \t\t\t   bool masked_p, vec_load_store_type vls_type,\n-\t\t\t   vect_memory_access_type *memory_access_type)\n+\t\t\t   vect_memory_access_type *memory_access_type,\n+\t\t\t   gather_scatter_info *gs_info)\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   vec_info *vinfo = stmt_info->vinfo;\n@@ -2073,6 +2173,20 @@ get_group_load_store_type (gimple *stmt, tree vectype, bool slp,\n \t      overrun_p = would_overrun_p;\n \t    }\n \t}\n+\n+      /* As a last resort, trying using a gather load or scatter store.\n+\n+\t ??? Although the code can handle all group sizes correctly,\n+\t it probably isn't a win to use separate strided accesses based\n+\t on nearby locations.  Or, even if it's a win over scalar code,\n+\t it might not be a win over vectorizing at a lower VF, if that\n+\t allows us to use contiguous accesses.  */\n+      if (*memory_access_type == VMAT_ELEMENTWISE\n+\t  && single_element_p\n+\t  && loop_vinfo\n+\t  && vect_use_strided_gather_scatters_p (stmt, loop_vinfo,\n+\t\t\t\t\t\t masked_p, gs_info))\n+\t*memory_access_type = VMAT_GATHER_SCATTER;\n     }\n \n   if (vls_type != VLS_LOAD && first_stmt == stmt)\n@@ -2200,14 +2314,15 @@ get_load_store_type (gimple *stmt, tree vectype, bool slp, bool masked_p,\n   else if (STMT_VINFO_GROUPED_ACCESS (stmt_info))\n     {\n       if (!get_group_load_store_type (stmt, vectype, slp, masked_p, vls_type,\n-\t\t\t\t      memory_access_type))\n+\t\t\t\t      memory_access_type, gs_info))\n \treturn false;\n     }\n   else if (STMT_VINFO_STRIDED_P (stmt_info))\n     {\n       gcc_assert (!slp);\n       if (loop_vinfo\n-\t  && vect_use_strided_gather_scatters_p (stmt, loop_vinfo, gs_info))\n+\t  && vect_use_strided_gather_scatters_p (stmt, loop_vinfo,\n+\t\t\t\t\t\t masked_p, gs_info))\n \t*memory_access_type = VMAT_GATHER_SCATTER;\n       else\n \t*memory_access_type = VMAT_ELEMENTWISE;"}, {"sha": "903e56e3431b147d0133b6c90f07f14b98ddd141", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/429ef523f74bb85c20ba60b0f83ab7e73f82d74d/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/429ef523f74bb85c20ba60b0f83ab7e73f82d74d/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=429ef523f74bb85c20ba60b0f83ab7e73f82d74d", "patch": "@@ -1455,6 +1455,8 @@ extern bool vect_verify_datarefs_alignment (loop_vec_info);\n extern bool vect_slp_analyze_and_verify_instance_alignment (slp_instance);\n extern bool vect_analyze_data_ref_accesses (vec_info *);\n extern bool vect_prune_runtime_alias_test_list (loop_vec_info);\n+extern bool vect_gather_scatter_fn_p (bool, bool, tree, tree, unsigned int,\n+\t\t\t\t      signop, int, internal_fn *, tree *);\n extern bool vect_check_gather_scatter (gimple *, loop_vec_info,\n \t\t\t\t       gather_scatter_info *);\n extern bool vect_analyze_data_refs (vec_info *, poly_uint64 *);"}]}