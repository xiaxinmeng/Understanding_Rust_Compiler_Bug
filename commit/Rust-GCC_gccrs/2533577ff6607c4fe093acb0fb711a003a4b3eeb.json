{"sha": "2533577ff6607c4fe093acb0fb711a003a4b3eeb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjUzMzU3N2ZmNjYwN2M0ZmUwOTNhY2IwZmI3MTFhMDAzYTRiM2VlYg==", "commit": {"author": {"name": "Janis Johnson", "email": "janis187@us.ibm.com", "date": "2007-09-10T20:44:08Z"}, "committer": {"name": "Janis Johnson", "email": "janis@gcc.gnu.org", "date": "2007-09-10T20:44:08Z"}, "message": "Makefile.in (libdecnumber_a_OBJS): Remove decUtility.o\n\n2007-09-10  Janis Johnson  <janis187@us.ibm.com>\n\t    Ben Elliston  <bje@au.ibm.com>\n\nlibdecnumber/\n\t* Makefile.in (libdecnumber_a_OBJS): Remove decUtility.o\n\t(dependencies): Add Symbols headers.\n\t* decContext.c: Upgrade to decNumber 3.53.\n\t* decContext.h: Ditto.\n\t* decDPD.h: Ditto.\n\t* decNumber.c: Ditto.\n\t* decNumber.h: Ditto.\n\t* decNumberLocal.h: Ditto.\n\t* decBasic.c: New file from decNumber 3.53.\n\t* decCommon.c: Ditto.\n\t* decDouble.c: Ditto.\n\t* decDouble.h: Ditto.\n\t* decQuad.c: Ditto.\n\t* decQuad.h: Ditto.\n\t* decSingle.c: Ditto.\n\t* decSingle.h: Ditto.\n\t* decPacked.c: Ditto.\n\t* decPacked.h: Ditto.\n\t* dpd/decimal128.c: Upgrade to decNumber 3.53.\n\t* dpd/decimal128.h: Ditto.\n\t* dpd/decimal32.c: Ditto.\n\t* dpd/decimal32.h: Ditto.\n\t* dpd/decimal64.c: Ditto.\n\t* dpd/decimal64.h: Ditto.\n\t* decLibrary.c (__dec_byte_swap): Remove.\n\t* decContextSymbols.h: New file.\n\t* decDoubleSymbols.h: New file.\n\t* decNumberSymbols.h: New file.\n\t* decPackedSymbols.h: New file.\n\t* decQuadSymbols.h: New file.\n\t* decSingleSymbols.h: New file.\n\t* decUtility.c: Delete file.\n\t* decUtility.h: Delete file.\n\t* bid/decimal128Symbols.h: New file.\n\t* bid/decimal128Local.h: New file.\n\t* bid/decimal32Symbols.h: New file.\n\t* bid/decimal64Symbols.h: New file.\n\t* bid/host-ieee128.c (__swap128): Remove.\n\t(__host_to_ieee_128, __ieee_to_host_128): Don't handle endianness.\n\t* bid/host-ieee32.c (__dec_type_swap): Remove.\n\t(__host_to_ieee_32, __ieee_to_host_32): Don't handle endianness.\n\t* bid/host-ieee64.c (__swap64): Remove.\n\t(__host_to_ieee_64, __ieee_to_host_64): Don't handle endianness.\n\t* dpd/decimal32Symbols.h: New file.\n\t* dpd/decimal64Symbols.h: New file.\n\t* dpd/decimal128Symbols.h: New file.\n\t* dpd/decimal128Local.h: New file.\n\nlibgcc/\n\t* Makefile.in (dfp-filenames): Remove decUtility, add\n\tdecDouble, decPacked, decQuad, decSingle.\n\ngcc/\n\t* dfp.c: Include decimal128Local.h; \n\t(dfp_byte_swap): Remove.\n\t(encode_decimal32, decode_decimal32): Don't handle endianness.\n\t(encode_decimal64, decode_decimal64): Ditto.\n\t(encode_decimal128, decode_decimal128): Ditto.\n\t* config/dfp-bit.c (host_to_ieee32, ieee_to_host_32): Ditto.\n\t(__swap64): Remove.\n\t(host_to_ieee_64, ieee_to_host_64): Don't handle endianness.\n         (__swap128): Remove\n\t(host_to_ieee_128, ieee_to_host_128): Don't handle endianness.\n\t* Makefile.in (DECNUM_H): Add decimal128Local.h.\n\nCo-Authored-By: Ben Elliston <bje@au.ibm.com>\n\nFrom-SVN: r128350", "tree": {"sha": "dc346951fedce72b616d1e6c4be76685c2e68c3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc346951fedce72b616d1e6c4be76685c2e68c3a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2533577ff6607c4fe093acb0fb711a003a4b3eeb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2533577ff6607c4fe093acb0fb711a003a4b3eeb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2533577ff6607c4fe093acb0fb711a003a4b3eeb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2533577ff6607c4fe093acb0fb711a003a4b3eeb/comments", "author": null, "committer": null, "parents": [{"sha": "bfd9cff5c5bbcbea235e60529138848df5222b0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfd9cff5c5bbcbea235e60529138848df5222b0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfd9cff5c5bbcbea235e60529138848df5222b0c"}], "stats": {"total": 27030, "additions": 19002, "deletions": 8028}, "files": [{"sha": "9bcfca14751ab7038dc004857d82b6fccf817748", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb", "patch": "@@ -1,3 +1,18 @@\n+2007-09-10  Janis Johnson  <janis187@us.ibm.com>\n+\t    Ben Elliston  <bje@au.ibm.com>\n+\n+\t* dfp.c: Include decimal128Local.h; \n+\t(dfp_byte_swap): Remove.\n+\t(encode_decimal32, decode_decimal32): Don't handle endianness.\n+\t(encode_decimal64, decode_decimal64): Ditto.\n+\t(encode_decimal128, decode_decimal128): Ditto.\n+\t* config/dfp-bit.c (host_to_ieee32, ieee_to_host_32): Ditto.\n+\t(__swap64): Remove.\n+\t(host_to_ieee_64, ieee_to_host_64): Don't handle endianness.\n+         (__swap128): Remove\n+\t(host_to_ieee_128, ieee_to_host_128): Don't handle endianness.\n+\t* Makefile.in (DECNUM_H): Add decimal128Local.h.\n+\n 2007-09-10  David Daney  <ddaney@avtrex.com>\n \n \t* config/mips/mips.md (UNSPEC_MEMORY_BARRIER): New entry in"}, {"sha": "ef7a949f121c28d109b7614e8c4cac98a0f35ae1", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb", "patch": "@@ -815,7 +815,8 @@ PREDICT_H = predict.h predict.def\n CPPLIB_H = $(srcdir)/../libcpp/include/line-map.h \\\n \t$(srcdir)/../libcpp/include/cpplib.h\n DECNUM_H = $(DECNUM)/decContext.h $(DECNUM)/decDPD.h $(DECNUM)/decNumber.h \\\n-\t$(DECNUMFMT)/decimal32.h $(DECNUMFMT)/decimal64.h $(DECNUMFMT)/decimal128.h\n+\t$(DECNUMFMT)/decimal32.h $(DECNUMFMT)/decimal64.h \\\n+\t$(DECNUMFMT)/decimal128.h $(DECNUMFMT)/decimal128Local.h\n MKDEPS_H = $(srcdir)/../libcpp/include/mkdeps.h\n SYMTAB_H = $(srcdir)/../libcpp/include/symtab.h\n CPP_ID_DATA_H = $(CPPLIB_H) $(srcdir)/../libcpp/include/cpp-id-data.h"}, {"sha": "252abe0224c1ced5ff4fbb3b895e139c5b41b76e", "filename": "gcc/config/dfp-bit.c", "status": "modified", "additions": 6, "deletions": 68, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/gcc%2Fconfig%2Fdfp-bit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/gcc%2Fconfig%2Fdfp-bit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdfp-bit.c?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb", "patch": "@@ -70,8 +70,6 @@ typedef decNumber* (*dfp_unary_func)\n /* A pointer to a binary decNumber operation.  */\n typedef decNumber* (*dfp_binary_func)\n      (decNumber *, const decNumber *, const decNumber *, decContext *);\n-\n-extern uint32_t __dec_byte_swap (uint32_t);\n \f\n /* Unary operations.  */\n \n@@ -190,101 +188,41 @@ dfp_compare_op (dfp_binary_func op, DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n void\n __host_to_ieee_32 (_Decimal32 in, decimal32 *out)\n {\n-  uint32_t t;\n-\n-  if (!LIBGCC2_FLOAT_WORDS_BIG_ENDIAN)\n-    {\n-      memcpy (&t, &in, 4);\n-      t = __dec_byte_swap (t);\n-      memcpy (out, &t, 4);\n-    }\n-  else\n-    memcpy (out, &in, 4);\n+  memcpy (out, &in, 4);\n }\n \n void\n __ieee_to_host_32 (decimal32 in, _Decimal32 *out)\n {\n-  uint32_t t;\n-\n-  if (!LIBGCC2_FLOAT_WORDS_BIG_ENDIAN)\n-    {\n-      memcpy (&t, &in, 4);\n-      t = __dec_byte_swap (t);\n-      memcpy (out, &t, 4);\n-    }\n-  else\n-    memcpy (out, &in, 4);\n+  memcpy (out, &in, 4);\n }\n #endif /* L_conv_sd */\n \n #if defined(L_conv_dd)\n-static void\n-__swap64 (char *src, char *dst)\n-{\n-  uint32_t t1, t2;\n-\n-  if (!LIBGCC2_FLOAT_WORDS_BIG_ENDIAN) \n-    {\n-      memcpy (&t1, src, 4);\n-      memcpy (&t2, src + 4, 4);\n-      t1 = __dec_byte_swap (t1);\n-      t2 = __dec_byte_swap (t2);\n-      memcpy (dst, &t2, 4);\n-      memcpy (dst + 4, &t1, 4);\n-    }\n-  else\n-    memcpy (dst, src, 8);\n-}\n-\n void\n __host_to_ieee_64 (_Decimal64 in, decimal64 *out)\n {\n-  __swap64 ((char *) &in, (char *) out);\n+  memcpy (out, &in, 8);\n }\n \n void\n __ieee_to_host_64 (decimal64 in, _Decimal64 *out)\n {\n-  __swap64 ((char *) &in, (char *) out);\n+  memcpy (out, &in, 8);\n }\n #endif /* L_conv_dd */\n \n #if defined(L_conv_td)\n-static void\n-__swap128 (char *src, char *dst)\n-{\n-  uint32_t t1, t2, t3, t4;\n-\n-  if (!LIBGCC2_FLOAT_WORDS_BIG_ENDIAN)\n-    {\n-      memcpy (&t1, src, 4);\n-      memcpy (&t2, src + 4, 4);\n-      memcpy (&t3, src + 8, 4);\n-      memcpy (&t4, src + 12, 4);\n-      t1 = __dec_byte_swap (t1);\n-      t2 = __dec_byte_swap (t2);\n-      t3 = __dec_byte_swap (t3);\n-      t4 = __dec_byte_swap (t4);\n-      memcpy (dst, &t4, 4);\n-      memcpy (dst + 4, &t3, 4);\n-      memcpy (dst + 8, &t2, 4);\n-      memcpy (dst + 12, &t1, 4);\n-    }\n-  else\n-    memcpy (dst, src, 16);\n-}\n-\n void\n __host_to_ieee_128 (_Decimal128 in, decimal128 *out)\n {\n-  __swap128 ((char *) &in, (char *) out);\n+  memcpy (out, &in, 16);\n }\n \n void\n __ieee_to_host_128 (decimal128 in, _Decimal128 *out)\n {\n-  __swap128 ((char *) &in, (char *) out);\n+  memcpy (out, &in, 16);\n }\n #endif /* L_conv_td */\n "}, {"sha": "88ffdedbcfb41baf5272a9a3616801e495ff070f", "filename": "gcc/dfp.c", "status": "modified", "additions": 15, "deletions": 75, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/gcc%2Fdfp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/gcc%2Fdfp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdfp.c?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb", "patch": "@@ -31,29 +31,11 @@ along with GCC; see the file COPYING3.  If not see\n    decNumber structure is large enough to hold decimal128 digits.  */\n \n #include \"decimal128.h\"\n+#include \"decimal128Local.h\"\n #include \"decimal64.h\"\n #include \"decimal32.h\"\n #include \"decNumber.h\"\n \n-static uint32_t\n-dfp_byte_swap (uint32_t in)\n-{\n-  uint32_t out = 0;\n-  unsigned char *p = (unsigned char *) &out;\n-  union {\n-    uint32_t i;\n-    unsigned char b[4];\n-  } u;\n-\n-  u.i = in;\n-  p[0] = u.b[3];\n-  p[1] = u.b[2];\n-  p[2] = u.b[1];\n-  p[3] = u.b[0];\n-\n-  return out;\n-}\n-\n /* Initialize R (a real with the decimal flag set) from DN.  Can\n    utilize status passed in via CONTEXT, if a previous operation had\n    interesting status.  */\n@@ -155,10 +137,7 @@ encode_decimal32 (const struct real_format *fmt ATTRIBUTE_UNUSED,\n   decimal_to_decnumber (r, &dn); \n   decimal32FromNumber (&d32, &dn, &set);\n \n-  if (FLOAT_WORDS_BIG_ENDIAN)\n-    buf[0] = *(uint32_t *) d32.bytes;\n-  else\n-    buf[0] = dfp_byte_swap (*(uint32_t *) d32.bytes);\n+  buf[0] = *(uint32_t *) d32.bytes;\n }\n \n /* Decode an IEEE 754R decimal32 type into a real.  */\n@@ -174,10 +153,7 @@ decode_decimal32 (const struct real_format *fmt ATTRIBUTE_UNUSED,\n   decContextDefault (&set, DEC_INIT_DECIMAL128);\n   set.traps = 0;\n \n-  if (FLOAT_WORDS_BIG_ENDIAN)\n-    *((uint32_t *) d32.bytes) = (uint32_t) buf[0];\n-  else\n-    *((uint32_t *) d32.bytes) = dfp_byte_swap ((uint32_t) buf[0]);\n+  *((uint32_t *) d32.bytes) = (uint32_t) buf[0];\n \n   decimal32ToNumber (&d32, &dn);\n   decimal_from_decnumber (r, &dn, &set); \n@@ -199,16 +175,8 @@ encode_decimal64 (const struct real_format *fmt ATTRIBUTE_UNUSED,\n   decimal_to_decnumber (r, &dn);\n   decimal64FromNumber (&d64, &dn, &set);\n \n-  if (FLOAT_WORDS_BIG_ENDIAN)\n-    {\n-      buf[0] = *(uint32_t *) &d64.bytes[0];\n-      buf[1] = *(uint32_t *) &d64.bytes[4];\n-    }\n-  else\n-    {\n-      buf[1] = dfp_byte_swap (*(uint32_t *) &d64.bytes[0]);\n-      buf[0] = dfp_byte_swap (*(uint32_t *) &d64.bytes[4]);\n-    }\n+  buf[0] = *(uint32_t *) &d64.bytes[0];\n+  buf[1] = *(uint32_t *) &d64.bytes[4];\n }\n \n /* Decode an IEEE 754R decimal64 type into a real.  */\n@@ -224,16 +192,8 @@ decode_decimal64 (const struct real_format *fmt ATTRIBUTE_UNUSED,\n   decContextDefault (&set, DEC_INIT_DECIMAL128);\n   set.traps = 0;\n \n-  if (FLOAT_WORDS_BIG_ENDIAN)\n-    {\n-      *((uint32_t *) &d64.bytes[0]) = (uint32_t) buf[0];\n-      *((uint32_t *) &d64.bytes[4]) = (uint32_t) buf[1];\n-    }\n-  else\n-    {\n-      *((uint32_t *) &d64.bytes[0]) = dfp_byte_swap ((uint32_t) buf[1]);\n-      *((uint32_t *) &d64.bytes[4]) = dfp_byte_swap ((uint32_t) buf[0]); \n-    }\n+  *((uint32_t *) &d64.bytes[0]) = (uint32_t) buf[0];\n+  *((uint32_t *) &d64.bytes[4]) = (uint32_t) buf[1];\n \n   decimal64ToNumber (&d64, &dn);\n   decimal_from_decnumber (r, &dn, &set); \n@@ -255,20 +215,10 @@ encode_decimal128 (const struct real_format *fmt ATTRIBUTE_UNUSED,\n   decimal_to_decnumber (r, &dn);\n   decimal128FromNumber (&d128, &dn, &set);\n \n-  if (FLOAT_WORDS_BIG_ENDIAN)\n-    {\n-      buf[0] = *(uint32_t *) &d128.bytes[0];\n-      buf[1] = *(uint32_t *) &d128.bytes[4];\n-      buf[2] = *(uint32_t *) &d128.bytes[8];\n-      buf[3] = *(uint32_t *) &d128.bytes[12];\n-    }\n-  else\n-    {\n-      buf[0] = dfp_byte_swap (*(uint32_t *) &d128.bytes[12]);\n-      buf[1] = dfp_byte_swap (*(uint32_t *) &d128.bytes[8]);\n-      buf[2] = dfp_byte_swap (*(uint32_t *) &d128.bytes[4]);\n-      buf[3] = dfp_byte_swap (*(uint32_t *) &d128.bytes[0]);\n-    }\n+  buf[0] = *(uint32_t *) &d128.bytes[0];\n+  buf[1] = *(uint32_t *) &d128.bytes[4];\n+  buf[2] = *(uint32_t *) &d128.bytes[8];\n+  buf[3] = *(uint32_t *) &d128.bytes[12];\n }\n \n /* Decode an IEEE 754R decimal128 type into a real.  */\n@@ -284,20 +234,10 @@ decode_decimal128 (const struct real_format *fmt ATTRIBUTE_UNUSED,\n   decContextDefault (&set, DEC_INIT_DECIMAL128);\n   set.traps = 0;\n \n-  if (FLOAT_WORDS_BIG_ENDIAN)\n-    {\n-      *((uint32_t *) &d128.bytes[0])  = (uint32_t) buf[0];\n-      *((uint32_t *) &d128.bytes[4])  = (uint32_t) buf[1];\n-      *((uint32_t *) &d128.bytes[8])  = (uint32_t) buf[2];\n-      *((uint32_t *) &d128.bytes[12]) = (uint32_t) buf[3];\n-    }\n-  else\n-    {\n-      *((uint32_t *) &d128.bytes[0])  = dfp_byte_swap ((uint32_t) buf[3]);\n-      *((uint32_t *) &d128.bytes[4])  = dfp_byte_swap ((uint32_t) buf[2]);\n-      *((uint32_t *) &d128.bytes[8])  = dfp_byte_swap ((uint32_t) buf[1]);\n-      *((uint32_t *) &d128.bytes[12]) = dfp_byte_swap ((uint32_t) buf[0]);\n-    }\n+  *((uint32_t *) &d128.bytes[0])  = (uint32_t) buf[0];\n+  *((uint32_t *) &d128.bytes[4])  = (uint32_t) buf[1];\n+  *((uint32_t *) &d128.bytes[8])  = (uint32_t) buf[2];\n+  *((uint32_t *) &d128.bytes[12]) = (uint32_t) buf[3];\n \n   decimal128ToNumber (&d128, &dn);\n   decimal_from_decnumber (r, &dn, &set); "}, {"sha": "38b4253920545f732c363db0709198283c86e884", "filename": "libdecnumber/ChangeLog", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FChangeLog?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb", "patch": "@@ -1,3 +1,54 @@\n+2007-09-10  Janis Johnson  <janis187@us.ibm.com>\n+\t    Ben Elliston  <bje@au.ibm.com>\n+\n+\t* Makefile.in (libdecnumber_a_OBJS): Remove decUtility.o\n+\t(dependencies): Add Symbols headers.\n+\t* decContext.c: Upgrade to decNumber 3.53.\n+\t* decContext.h: Ditto.\n+\t* decDPD.h: Ditto.\n+\t* decNumber.c: Ditto.\n+\t* decNumber.h: Ditto.\n+\t* decNumberLocal.h: Ditto.\n+\t* decBasic.c: New file from decNumber 3.53.\n+\t* decCommon.c: Ditto.\n+\t* decDouble.c: Ditto.\n+\t* decDouble.h: Ditto.\n+\t* decQuad.c: Ditto.\n+\t* decQuad.h: Ditto.\n+\t* decSingle.c: Ditto.\n+\t* decSingle.h: Ditto.\n+\t* decPacked.c: Ditto.\n+\t* decPacked.h: Ditto.\n+\t* dpd/decimal128.c: Upgrade to decNumber 3.53.\n+\t* dpd/decimal128.h: Ditto.\n+\t* dpd/decimal32.c: Ditto.\n+\t* dpd/decimal32.h: Ditto.\n+\t* dpd/decimal64.c: Ditto.\n+\t* dpd/decimal64.h: Ditto.\n+\t* decLibrary.c (__dec_byte_swap): Remove.\n+\t* decContextSymbols.h: New file.\n+\t* decDoubleSymbols.h: New file.\n+\t* decNumberSymbols.h: New file.\n+\t* decPackedSymbols.h: New file.\n+\t* decQuadSymbols.h: New file.\n+\t* decSingleSymbols.h: New file.\n+\t* decUtility.c: Delete file.\n+\t* decUtility.h: Delete file.\n+\t* bid/decimal128Symbols.h: New file.\n+\t* bid/decimal128Local.h: New file.\n+\t* bid/decimal32Symbols.h: New file.\n+\t* bid/decimal64Symbols.h: New file.\n+\t* bid/host-ieee128.c (__swap128): Remove.\n+\t(__host_to_ieee_128, __ieee_to_host_128): Don't handle endianness.\n+\t* bid/host-ieee32.c (__dec_type_swap): Remove.\n+\t(__host_to_ieee_32, __ieee_to_host_32): Don't handle endianness.\n+\t* bid/host-ieee64.c (__swap64): Remove.\n+\t(__host_to_ieee_64, __ieee_to_host_64): Don't handle endianness.\n+\t* dpd/decimal32Symbols.h: New file.\n+\t* dpd/decimal64Symbols.h: New file.\n+\t* dpd/decimal128Symbols.h: New file.\n+\t* dpd/decimal128Local.h: New file.\n+\n 2007-06-18  Martin Michlmayr  <tbm@cyrius.com>\n \t    H.J. Lu  <hongjiu.lu@intel.com>\n "}, {"sha": "98ae9eac78ca9f9c48eebc923f14dcdad71cf97e", "filename": "libdecnumber/Makefile.in", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FMakefile.in?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb", "patch": "@@ -56,7 +56,7 @@ INCLUDES = -I$(srcdir) -I.\n \n ALL_CFLAGS = $(CFLAGS) $(WARN_CFLAGS) $(INCLUDES) $(CPPFLAGS)\n \n-libdecnumber_a_OBJS = decNumber.o decContext.o decUtility.o \\\n+libdecnumber_a_OBJS = decNumber.o decContext.o \\\n \tdecimal32.o decimal64.o decimal128.o\n \n ifeq ($(enable_decimal_float),bid)\n@@ -66,7 +66,6 @@ endif\n \n libdecnumber_a_SOURCES = decContext.c decContext.h decDPD.h \\\n \tdecNumber.c decNumber.h decNumberLocal.h \\\n-\tdecUtility.c decUtility.h \\\n \tdpd/decimal128.c dpd/decimal128.h \\\n \tdpd/decimal32.c dpd/decimal32.h \\\n \tdpd/decimal64.c dpd/decimal64.h \\\n@@ -113,19 +112,25 @@ $(srcdir)/config.in: @MAINT@ $(srcdir)/configure\n \n # Dependencies.\n \n-decContext.o: decContext.c decContext.h decNumberLocal.h\n-decNumber.o:  decNumber.c decNumber.h decContext.h decNumberLocal.h\n+decContext.o: decContext.c decContext.h decNumberLocal.h \\\n+\tdecContextSymbols.h\n+decNumber.o:  decNumber.c decNumber.h decContext.h decNumberLocal.h \\\n+\tdecNumberSymbols.h\n decimal32.o:  $(enable_decimal_float)/decimal32.c \\\n    $(enable_decimal_float)/decimal32.h \\\n-   decNumber.h decContext.h decNumberLocal.h decUtility.h\n+   $(enable_decimal_float)/decimal32Symbols.h \\\n+   decNumber.h decContext.h decNumberLocal.h\n \t$(COMPILE) $<\n decimal64.o:  $(enable_decimal_float)/decimal64.c \\\n    $(enable_decimal_float)/decimal64.h \\\n-   decNumber.h decContext.h decNumberLocal.h decUtility.h\n+   $(enable_decimal_float)/decimal64Symbols.h \\\n+   decNumber.h decContext.h decNumberLocal.h\n \t$(COMPILE) $<\n decimal128.o:  $(enable_decimal_float)/decimal128.c \\\n    $(enable_decimal_float)/decimal128.h \\\n-   decNumber.h decContext.h decNumberLocal.h decUtility.h\n+   $(enable_decimal_float)/decimal128Symbols.h\\\n+   $(enable_decimal_float)/decimal128Local.h\\\n+   decNumber.h decContext.h decNumberLocal.h \n \t$(COMPILE) $<\n bid2dpd_dpd2bid.o : bid/bid2dpd_dpd2bid.c bid/bid2dpd_dpd2bid.h\n \t$(COMPILE) $<"}, {"sha": "e499d73bf049b5a8ea2bd2061877fc3be7a1be31", "filename": "libdecnumber/bid/decimal128Local.h", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2Fbid%2Fdecimal128Local.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2Fbid%2Fdecimal128Local.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2Fbid%2Fdecimal128Local.h?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb", "patch": "@@ -0,0 +1 @@\n+#include \"dpd/decimal128Local.h\""}, {"sha": "17757114ae7327974b4f41d7070767ccce4395c5", "filename": "libdecnumber/bid/decimal128Symbols.h", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2Fbid%2Fdecimal128Symbols.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2Fbid%2Fdecimal128Symbols.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2Fbid%2Fdecimal128Symbols.h?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb", "patch": "@@ -0,0 +1 @@\n+#include \"dpd/decimal128Symbols.h\""}, {"sha": "a0c4bf8cd3cb84fe6303a123231bb13cfec03d1f", "filename": "libdecnumber/bid/decimal32Symbols.h", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2Fbid%2Fdecimal32Symbols.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2Fbid%2Fdecimal32Symbols.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2Fbid%2Fdecimal32Symbols.h?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb", "patch": "@@ -0,0 +1 @@\n+#include \"dpd/decimal32Symbols.h\""}, {"sha": "5f3069cd62e9ecb159f8e2cdf07b82361f629b15", "filename": "libdecnumber/bid/decimal64Symbols.h", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2Fbid%2Fdecimal64Symbols.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2Fbid%2Fdecimal64Symbols.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2Fbid%2Fdecimal64Symbols.h?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb", "patch": "@@ -0,0 +1 @@\n+#include \"dpd/decimal64Symbols.h\""}, {"sha": "6d493e5c9d8a49bd5c13b9542f3cf930c8f42fc2", "filename": "libdecnumber/bid/host-ieee128.c", "status": "modified", "additions": 2, "deletions": 36, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2Fbid%2Fhost-ieee128.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2Fbid%2Fhost-ieee128.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2Fbid%2Fhost-ieee128.c?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb", "patch": "@@ -27,56 +27,22 @@ along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n 02110-1301, USA.  */\n \n-#include <stdio.h>\n-#include <stdlib.h>\n #include <string.h>\n-#include <limits.h>\n \n-#include \"config.h\"\n-#include \"gstdint.h\"\n #include \"bid-dpd.h\"\n #include \"decimal128.h\"\n \n-extern uint32_t __dec_byte_swap (uint32_t);\n void __host_to_ieee_128 (_Decimal128 in, decimal128 *out);\n void __ieee_to_host_128 (decimal128 in, _Decimal128 *out);\n \n-#ifndef WORDS_BIGENDIAN\n-#define WORDS_BIGENDIAN 0\n-#endif\n-\n-static void\n-__swap128 (char *src, char *dst)\n-{\n-  uint32_t t1, t2, t3, t4;\n-\n-  if (!WORDS_BIGENDIAN)\n-    {\n-      memcpy (&t1, src, 4);\n-      memcpy (&t2, src + 4, 4);\n-      memcpy (&t3, src + 8, 4);\n-      memcpy (&t4, src + 12, 4);\n-      t1 = __dec_byte_swap (t1);\n-      t2 = __dec_byte_swap (t2);\n-      t3 = __dec_byte_swap (t3);\n-      t4 = __dec_byte_swap (t4);\n-      memcpy (dst, &t4, 4);\n-      memcpy (dst + 4, &t3, 4);\n-      memcpy (dst + 8, &t2, 4);\n-      memcpy (dst + 12, &t1, 4);\n-    }\n-  else\n-    memcpy (dst, src, 16);\n-}\n-\n void\n __host_to_ieee_128 (_Decimal128 in, decimal128 *out)\n {\n-  __swap128 ((char *) &in, (char *) out);\n+  memcpy ((char *) out, (char *) &in, 16);\n }\n \n void\n __ieee_to_host_128 (decimal128 in, _Decimal128 *out)\n {\n-  __swap128 ((char *) &in, (char *) out);\n+  memcpy ((char *) out, (char *) &in, 16);\n }"}, {"sha": "9a59c938644983628502f07f7b4bc2a8b5c5ea7c", "filename": "libdecnumber/bid/host-ieee32.c", "status": "modified", "additions": 2, "deletions": 50, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2Fbid%2Fhost-ieee32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2Fbid%2Fhost-ieee32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2Fbid%2Fhost-ieee32.c?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb", "patch": "@@ -37,69 +37,21 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n /* The intended way to use this file is to make two copies, add `#define '\n    to one copy, then compile both copies and add them to libgcc.a.  */\n \n-#include <stdio.h>\n-#include <stdlib.h>\n #include <string.h>\n-#include <limits.h>\n-\n-#include \"config.h\"\n-#include \"gstdint.h\"\n #include \"bid-dpd.h\"\n #include \"decimal32.h\"\n \n-uint32_t __dec_byte_swap (uint32_t);\n void __host_to_ieee_32 (_Decimal32 in, decimal32 *out);\n void __ieee_to_host_32 (decimal32 in, _Decimal32 *out);\n \n-#ifndef WORDS_BIGENDIAN\n-#define WORDS_BIGENDIAN 0\n-#endif\n-\n-uint32_t\n-__dec_byte_swap (uint32_t in)\n-{\n-  uint32_t out = 0;\n-  unsigned char *p = (unsigned char *) &out;\n-  union {\n-    uint32_t i;\n-    unsigned char b[4];\n-  } u;\n-\n-  u.i = in;\n-  p[0] = u.b[3];\n-  p[1] = u.b[2];\n-  p[2] = u.b[1];\n-  p[3] = u.b[0];\n-\n-  return out;\n-}\n-\n void\n __host_to_ieee_32 (_Decimal32 in, decimal32 *out)\n {\n-  uint32_t t;\n-\n-  if (!WORDS_BIGENDIAN)\n-    {\n-      memcpy (&t, &in, 4);\n-      t = __dec_byte_swap (t);\n-      memcpy (out, &t, 4);\n-    }\n-  else\n-    memcpy (out, &in, 4);\n+  memcpy ((char *) out, (char *) &in, 4);\n }\n \n void\n __ieee_to_host_32 (decimal32 in, _Decimal32 *out)\n {\n-  uint32_t t;\n-\n-  if (!WORDS_BIGENDIAN)\n-    {\n-      memcpy (&t, &in, 4);\n-      t = __dec_byte_swap (t);\n-      memcpy (out, &t, 4);\n-    }\n-  else\n-    memcpy (out, &in, 4);\n+  memcpy ((char *) out, (char *) &in, 4);\n }"}, {"sha": "ac6cd849efecd86f96f1eb7895a0ce80fb92bcaa", "filename": "libdecnumber/bid/host-ieee64.c", "status": "modified", "additions": 2, "deletions": 31, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2Fbid%2Fhost-ieee64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2Fbid%2Fhost-ieee64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2Fbid%2Fhost-ieee64.c?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb", "patch": "@@ -37,50 +37,21 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n /* The intended way to use this file is to make two copies, add `#define '\n    to one copy, then compile both copies and add them to libgcc.a.  */\n \n-#include <stdio.h>\n-#include <stdlib.h>\n #include <string.h>\n-#include <limits.h>\n-\n-#include \"config.h\"\n-#include \"gstdint.h\"\n #include \"bid-dpd.h\"\n #include \"decimal64.h\"\n \n-uint32_t __dec_byte_swap (uint32_t);\n void __host_to_ieee_64 (_Decimal64 in, decimal64 *out);\n void __ieee_to_host_64 (decimal64 in, _Decimal64 *out);\n \n-#ifndef WORDS_BIGENDIAN\n-#define WORDS_BIGENDIAN 0\n-#endif\n-\n-static void\n-__swap64 (char *src, char *dst)\n-{\n-  uint32_t t1, t2;\n-\n-  if (!WORDS_BIGENDIAN) \n-    {\n-      memcpy (&t1, src, 4);\n-      memcpy (&t2, src + 4, 4);\n-      t1 = __dec_byte_swap (t1);\n-      t2 = __dec_byte_swap (t2);\n-      memcpy (dst, &t2, 4);\n-      memcpy (dst + 4, &t1, 4);\n-    }\n-  else\n-    memcpy (dst, src, 8);\n-}\n-\n void\n __host_to_ieee_64 (_Decimal64 in, decimal64 *out)\n {\n-  __swap64 ((char *) &in, (char *) out);\n+  memcpy ((char *) out, (char *) &in, 8);\n }\n \n void\n __ieee_to_host_64 (decimal64 in, _Decimal64 *out)\n {\n-  __swap64 ((char *) &in, (char *) out);\n+  memcpy ((char *) out, (char *) &in, 8);\n }"}, {"sha": "9ce277d2c30e8be733b64f0a4a920afeca9be242", "filename": "libdecnumber/decBasic.c", "status": "added", "additions": 3769, "deletions": 0, "changes": 3769, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FdecBasic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FdecBasic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecBasic.c?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb"}, {"sha": "84e1b2ad530db2374c1f5436da71474a5138a7f6", "filename": "libdecnumber/decCommon.c", "status": "added", "additions": 1771, "deletions": 0, "changes": 1771, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FdecCommon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FdecCommon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecCommon.c?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb", "patch": "@@ -0,0 +1,1771 @@\n+/* Common code for fixed-size types in the decNumber C Library.\n+   Copyright (C) 2007 Free Software Foundation, Inc.\n+   Contributed by IBM Corporation.  Author Mike Cowlishaw.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 2, or (at your option) any later\n+   version.\n+\n+   In addition to the permissions in the GNU General Public License,\n+   the Free Software Foundation gives you unlimited permission to link\n+   the compiled version of this file into combinations with other\n+   programs, and to distribute those combinations without any\n+   restriction coming from the use of this file.  (The General Public\n+   License restrictions do apply in other respects; for example, they\n+   cover modification of the file, and distribution when not linked\n+   into a combine executable.)\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+   02110-1301, USA.  */\n+\n+/* ------------------------------------------------------------------ */\n+/* decCommon.c -- common code for all three fixed-size types\t      */\n+/* ------------------------------------------------------------------ */\n+/* This module comprises code that is shared between all the formats  */\n+/* (decSingle, decDouble, and decQuad); it includes set and extract   */\n+/* of format components, widening, narrowing, and string conversions. */\n+/*\t\t\t\t\t\t\t\t      */\n+/* Unlike decNumber, parameterization takes place at compile time     */\n+/* rather than at runtime.  The parameters are set in the decDouble.c */\n+/* (etc.) files, which then include this one to produce the compiled  */\n+/* code.  The functions here, therefore, are code shared between      */\n+/* multiple formats.\t\t\t\t\t\t      */\n+/* ------------------------------------------------------------------ */\n+/* Names here refer to decFloat rather than to decDouble, etc., and */\n+/* the functions are in strict alphabetical order. */\n+/* Constants, tables, and debug function(s) are included only for QUAD */\n+/* (which will always be compiled if DOUBLE or SINGLE are used). */\n+/* */\n+/* Whenever a decContext is used, only the status may be set (using */\n+/* OR) or the rounding mode read; all other fields are ignored and */\n+/* untouched. */\n+\n+/* names for simpler testing and default context */\n+#if DECPMAX==7\n+  #define SINGLE     1\n+  #define DOUBLE     0\n+  #define QUAD\t     0\n+  #define DEFCONTEXT DEC_INIT_DECIMAL32\n+#elif DECPMAX==16\n+  #define SINGLE     0\n+  #define DOUBLE     1\n+  #define QUAD\t     0\n+  #define DEFCONTEXT DEC_INIT_DECIMAL64\n+#elif DECPMAX==34\n+  #define SINGLE     0\n+  #define DOUBLE     0\n+  #define QUAD\t     1\n+  #define DEFCONTEXT DEC_INIT_DECIMAL128\n+#else\n+  #error Unexpected DECPMAX value\n+#endif\n+\n+/* Assertions */\n+\n+#if DECPMAX!=7 && DECPMAX!=16 && DECPMAX!=34\n+  #error Unexpected Pmax (DECPMAX) value for this module\n+#endif\n+\n+/* Assert facts about digit characters, etc. */\n+#if ('9'&0x0f)!=9\n+  #error This module assumes characters are of the form 0b....nnnn\n+  /* where .... are don't care 4 bits and nnnn is 0000 through 1001 */\n+#endif\n+#if ('9'&0xf0)==('.'&0xf0)\n+  #error This module assumes '.' has a different mask than a digit\n+#endif\n+\n+/* Assert ToString lay-out conditions */\n+#if DECSTRING<DECPMAX+9\n+  #error ToString needs at least 8 characters for lead-in and dot\n+#endif\n+#if DECPMAX+DECEMAXD+5 > DECSTRING\n+  #error Exponent form can be too long for ToString to lay out safely\n+#endif\n+#if DECEMAXD > 4\n+  #error Exponent form is too long for ToString to lay out\n+  /* Note: code for up to 9 digits exists in archives [decOct] */\n+#endif\n+\n+/* Private functions used here and possibly in decBasic.c, etc. */\n+static decFloat * decFinalize(decFloat *, bcdnum *, decContext *);\n+static Flag decBiStr(const char *, const char *, const char *);\n+\n+/* Macros and private tables; those which are not format-dependent    */\n+/* are only included if decQuad is being built.\t\t\t      */\n+\n+/* ------------------------------------------------------------------ */\n+/* Combination field lookup tables (uInts to save measurable work)    */\n+/*\t\t\t\t\t\t\t\t      */\n+/*   DECCOMBEXP\t - 2 most-significant-bits of exponent (00, 01, or    */\n+/*\t\t   10), shifted left for format, or DECFLOAT_Inf/NaN  */\n+/*   DECCOMBWEXP - The same, for the next-wider format (unless QUAD)  */\n+/*   DECCOMBMSD\t - 4-bit most-significant-digit\t\t\t      */\n+/*\t\t   [0 if the index is a special (Infinity or NaN)]    */\n+/*   DECCOMBFROM - 5-bit combination field from EXP top bits and MSD  */\n+/*\t\t   (placed in uInt so no shift is needed)\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* DECCOMBEXP, DECCOMBWEXP, and DECCOMBMSD are indexed by the sign    */\n+/*   and 5-bit combination field (0-63, the second half of the table  */\n+/*   identical to the first half)\t\t\t\t      */\n+/* DECCOMBFROM is indexed by expTopTwoBits*16 + msd\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* DECCOMBMSD and DECCOMBFROM are not format-dependent and so are     */\n+/* only included once, when QUAD is being built\t\t\t      */\n+/* ------------------------------------------------------------------ */\n+static const uInt DECCOMBEXP[64]={\n+  0, 0, 0, 0, 0, 0, 0, 0,\n+  1<<DECECONL, 1<<DECECONL, 1<<DECECONL, 1<<DECECONL,\n+  1<<DECECONL, 1<<DECECONL, 1<<DECECONL, 1<<DECECONL,\n+  2<<DECECONL, 2<<DECECONL, 2<<DECECONL, 2<<DECECONL,\n+  2<<DECECONL, 2<<DECECONL, 2<<DECECONL, 2<<DECECONL,\n+  0,\t       0,\t    1<<DECECONL, 1<<DECECONL,\n+  2<<DECECONL, 2<<DECECONL, DECFLOAT_Inf, DECFLOAT_NaN,\n+  0, 0, 0, 0, 0, 0, 0, 0,\n+  1<<DECECONL, 1<<DECECONL, 1<<DECECONL, 1<<DECECONL,\n+  1<<DECECONL, 1<<DECECONL, 1<<DECECONL, 1<<DECECONL,\n+  2<<DECECONL, 2<<DECECONL, 2<<DECECONL, 2<<DECECONL,\n+  2<<DECECONL, 2<<DECECONL, 2<<DECECONL, 2<<DECECONL,\n+  0,\t       0,\t    1<<DECECONL, 1<<DECECONL,\n+  2<<DECECONL, 2<<DECECONL, DECFLOAT_Inf, DECFLOAT_NaN};\n+#if !QUAD\n+static const uInt DECCOMBWEXP[64]={\n+  0, 0, 0, 0, 0, 0, 0, 0,\n+  1<<DECWECONL, 1<<DECWECONL, 1<<DECWECONL, 1<<DECWECONL,\n+  1<<DECWECONL, 1<<DECWECONL, 1<<DECWECONL, 1<<DECWECONL,\n+  2<<DECWECONL, 2<<DECWECONL, 2<<DECWECONL, 2<<DECWECONL,\n+  2<<DECWECONL, 2<<DECWECONL, 2<<DECWECONL, 2<<DECWECONL,\n+  0,\t\t0,\t      1<<DECWECONL, 1<<DECWECONL,\n+  2<<DECWECONL, 2<<DECWECONL, DECFLOAT_Inf, DECFLOAT_NaN,\n+  0, 0, 0, 0, 0, 0, 0, 0,\n+  1<<DECWECONL, 1<<DECWECONL, 1<<DECWECONL, 1<<DECWECONL,\n+  1<<DECWECONL, 1<<DECWECONL, 1<<DECWECONL, 1<<DECWECONL,\n+  2<<DECWECONL, 2<<DECWECONL, 2<<DECWECONL, 2<<DECWECONL,\n+  2<<DECWECONL, 2<<DECWECONL, 2<<DECWECONL, 2<<DECWECONL,\n+  0,\t\t0,\t      1<<DECWECONL, 1<<DECWECONL,\n+  2<<DECWECONL, 2<<DECWECONL, DECFLOAT_Inf, DECFLOAT_NaN};\n+#endif\n+\n+#if QUAD\n+const uInt DECCOMBMSD[64]={\n+  0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7,\n+  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 8, 9, 8, 9, 0, 1,\n+  0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7,\n+  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 8, 9, 8, 9, 0, 0};\n+\n+const uInt DECCOMBFROM[48]={\n+  0x00000000, 0x04000000, 0x08000000, 0x0C000000, 0x10000000, 0x14000000,\n+  0x18000000, 0x1C000000, 0x60000000, 0x64000000, 0x00000000, 0x00000000,\n+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x20000000, 0x24000000,\n+  0x28000000, 0x2C000000, 0x30000000, 0x34000000, 0x38000000, 0x3C000000,\n+  0x68000000, 0x6C000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n+  0x00000000, 0x00000000, 0x40000000, 0x44000000, 0x48000000, 0x4C000000,\n+  0x50000000, 0x54000000, 0x58000000, 0x5C000000, 0x70000000, 0x74000000,\n+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000};\n+\n+/* ------------------------------------------------------------------ */\n+/* Request and include the tables to use for conversions\t      */\n+/* ------------------------------------------------------------------ */\n+#define DEC_BCD2DPD  1\t      /* 0-0x999 -> DPD */\n+#define DEC_BIN2DPD  1\t      /* 0-999 -> DPD */\n+#define DEC_BIN2BCD8 1\t      /* 0-999 -> ddd, len */\n+#define DEC_DPD2BCD8 1\t      /* DPD -> ddd, len */\n+#define DEC_DPD2BIN  1\t      /* DPD -> 0-999 */\n+#define DEC_DPD2BINK 1\t      /* DPD -> 0-999000 */\n+#define DEC_DPD2BINM 1\t      /* DPD -> 0-999000000 */\n+#include \"decDPD.h\"\t      /* source of the lookup tables */\n+\n+#endif\n+\n+/* ----------------------------------------------------------------- */\n+/* decBiStr -- compare string with pairwise options\t\t     */\n+/*\t\t\t\t\t\t\t\t     */\n+/*   targ is the string to compare\t\t\t\t     */\n+/*   str1 is one of the strings to compare against (length may be 0) */\n+/*   str2 is the other; it must be the same length as str1\t     */\n+/*\t\t\t\t\t\t\t\t     */\n+/*   returns 1 if strings compare equal, (that is, targ is the same  */\n+/*   length as str1 and str2, and each character of targ is in one   */\n+/*   of str1 or str2 in the corresponding position), or 0 otherwise  */\n+/*\t\t\t\t\t\t\t\t     */\n+/* This is used for generic caseless compare, including the awkward  */\n+/* case of the Turkish dotted and dotless Is.  Use as (for example): */\n+/*   if (decBiStr(test, \"mike\", \"MIKE\")) ...\t\t\t     */\n+/* ----------------------------------------------------------------- */\n+static Flag decBiStr(const char *targ, const char *str1, const char *str2) {\n+  for (;;targ++, str1++, str2++) {\n+    if (*targ!=*str1 && *targ!=*str2) return 0;\n+    /* *targ has a match in one (or both, if terminator) */\n+    if (*targ=='\\0') break;\n+    } /* forever */\n+  return 1;\n+  } /* decBiStr */\n+\n+/* ------------------------------------------------------------------ */\n+/* decFinalize -- adjust and store a final result\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  df\tis the decFloat format number which gets the final result     */\n+/*  num is the descriptor of the number to be checked and encoded     */\n+/*\t   [its values, including the coefficient, may be modified]   */\n+/*  set is the context to use\t\t\t\t\t      */\n+/*  returns df\t\t\t\t\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* The num descriptor may point to a bcd8 string of any length; this  */\n+/* string may have leading insignificant zeros.\t If it has more than  */\n+/* DECPMAX digits then the final digit can be a round-for-reround     */\n+/* digit (i.e., it may include a sticky bit residue).\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* The exponent (q) may be one of the codes for a special value and   */\n+/* can be up to 999999999 for conversion from string.\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* No error is possible, but Inexact, Underflow, and/or Overflow may  */\n+/* be set.\t\t\t\t\t\t\t      */\n+/* ------------------------------------------------------------------ */\n+/* Constant whose size varies with format; also the check for surprises */\n+static uByte allnines[DECPMAX]=\n+#if SINGLE\n+  {9, 9, 9, 9, 9, 9, 9};\n+#elif DOUBLE\n+  {9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9};\n+#elif QUAD\n+  {9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,\n+   9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9};\n+#endif\n+\n+static decFloat * decFinalize(decFloat *df, bcdnum *num,\n+\t\t\t      decContext *set) {\n+  uByte *ub;\t\t      /* work */\n+  uInt\t dpd;\t\t      /* .. */\n+  uByte *umsd=num->msd;\t      /* local copy */\n+  uByte *ulsd=num->lsd;\t      /* .. */\n+  uInt\t encode;\t      /* encoding accumulator */\n+  Int\t length;\t      /* coefficient length */\n+\n+  #if DECCHECK\n+  Int clen=ulsd-umsd+1;\n+  #if QUAD\n+    #define COEXTRA 2\t\t\t     /* extra-long coefficent */\n+  #else\n+    #define COEXTRA 0\n+  #endif\n+  if (clen<1 || clen>DECPMAX*3+2+COEXTRA)\n+    printf(\"decFinalize: suspect coefficient [length=%ld]\\n\", (LI)clen);\n+  if (num->sign!=0 && num->sign!=DECFLOAT_Sign)\n+    printf(\"decFinalize: bad sign [%08lx]\\n\", (LI)num->sign);\n+  if (!EXPISSPECIAL(num->exponent)\n+      && (num->exponent>1999999999 || num->exponent<-1999999999))\n+    printf(\"decFinalize: improbable exponent [%ld]\\n\", (LI)num->exponent);\n+  /* decShowNum(num, \"final\"); */\n+  #endif\n+\n+  /* A special will have an 'exponent' which is very positive and a */\n+  /* coefficient < DECPMAX */\n+  length=(uInt)(ulsd-umsd+1);\t\t     /* coefficient length */\n+\n+  if (!NUMISSPECIAL(num)) {\n+    Int\t  drop;\t\t\t\t     /* digits to be dropped */\n+    /* skip leading insignificant zeros to calculate an exact length */\n+    /* [this is quite expensive] */\n+    if (*umsd==0) {\n+      for (; UINTAT(umsd)==0 && umsd+3<ulsd;) umsd+=4;\n+      for (; *umsd==0 && umsd<ulsd;) umsd++;\n+      length=ulsd-umsd+1;\t\t     /* recalculate */\n+      }\n+    drop=MAXI(length-DECPMAX, DECQTINY-num->exponent);\n+    /* drop can now be > digits for bottom-clamp (subnormal) cases */\n+    if (drop>0) {\t\t\t     /* rounding needed */\n+      /* (decFloatQuantize has very similar code to this, so any */\n+      /* changes may need to be made there, too) */\n+      uByte *roundat;\t\t\t     /* -> re-round digit */\n+      uByte reround;\t\t\t     /* reround value */\n+      /* printf(\"Rounding; drop=%ld\\n\", (LI)drop); */\n+\n+      num->exponent+=drop;\t\t     /* always update exponent */\n+\n+      /* Three cases here: */\n+      /*   1. new LSD is in coefficient (almost always) */\n+      /*   2. new LSD is digit to left of coefficient (so MSD is */\n+      /*      round-for-reround digit) */\n+      /*   3. new LSD is to left of case 2 (whole coefficient is sticky) */\n+      /* [duplicate check-stickies code to save a test] */\n+      /* [by-digit check for stickies as runs of zeros are rare] */\n+      if (drop<length) {\t\t     /* NB lengths not addresses */\n+\troundat=umsd+length-drop;\n+\treround=*roundat;\n+\tfor (ub=roundat+1; ub<=ulsd; ub++) {\n+\t  if (*ub!=0) {\t\t\t     /* non-zero to be discarded */\n+\t    reround=DECSTICKYTAB[reround];   /* apply sticky bit */\n+\t    break;\t\t\t     /* [remainder don't-care] */\n+\t    }\n+\t  } /* check stickies */\n+\tulsd=roundat-1;\t\t\t     /* new LSD */\n+\t}\n+       else {\t\t\t\t     /* edge case */\n+\tif (drop==length) {\n+\t  roundat=umsd;\n+\t  reround=*roundat;\n+\t  }\n+\t else {\n+\t  roundat=umsd-1;\n+\t  reround=0;\n+\t  }\n+\tfor (ub=roundat+1; ub<=ulsd; ub++) {\n+\t  if (*ub!=0) {\t\t\t     /* non-zero to be discarded */\n+\t    reround=DECSTICKYTAB[reround];   /* apply sticky bit */\n+\t    break;\t\t\t     /* [remainder don't-care] */\n+\t    }\n+\t  } /* check stickies */\n+\t*umsd=0;\t\t\t     /* coefficient is a 0 */\n+\tulsd=umsd;\t\t\t     /* .. */\n+\t}\n+\n+      if (reround!=0) {\t\t\t     /* discarding non-zero */\n+\tuInt bump=0;\n+\tset->status|=DEC_Inexact;\n+\t/* if adjusted exponent [exp+digits-1] is < EMIN then num is */\n+\t/* subnormal -- so raise Underflow */\n+\tif (num->exponent<DECEMIN && (num->exponent+(ulsd-umsd+1)-1)<DECEMIN)\n+\t  set->status|=DEC_Underflow;\n+\n+\t/* next decide whether increment of the coefficient is needed */\n+\tif (set->round==DEC_ROUND_HALF_EVEN) {\t  /* fastpath slowest case */\n+\t  if (reround>5) bump=1;\t\t  /* >0.5 goes up */\n+\t   else if (reround==5)\t\t\t  /* exactly 0.5000 .. */\n+\t    bump=*ulsd & 0x01;\t\t\t  /* .. up iff [new] lsd is odd */\n+\t  } /* r-h-e */\n+\t else switch (set->round) {\n+\t  case DEC_ROUND_DOWN: {\n+\t    /* no change */\n+\t    break;} /* r-d */\n+\t  case DEC_ROUND_HALF_DOWN: {\n+\t    if (reround>5) bump=1;\n+\t    break;} /* r-h-d */\n+\t  case DEC_ROUND_HALF_UP: {\n+\t    if (reround>=5) bump=1;\n+\t    break;} /* r-h-u */\n+\t  case DEC_ROUND_UP: {\n+\t    if (reround>0) bump=1;\n+\t    break;} /* r-u */\n+\t  case DEC_ROUND_CEILING: {\n+\t    /* same as _UP for positive numbers, and as _DOWN for negatives */\n+\t    if (!num->sign && reround>0) bump=1;\n+\t    break;} /* r-c */\n+\t  case DEC_ROUND_FLOOR: {\n+\t    /* same as _UP for negative numbers, and as _DOWN for positive */\n+\t    /* [negative reround cannot occur on 0] */\n+\t    if (num->sign && reround>0) bump=1;\n+\t    break;} /* r-f */\n+\t  case DEC_ROUND_05UP: {\n+\t    if (reround>0) { /* anything out there is 'sticky' */\n+\t      /* bump iff lsd=0 or 5; this cannot carry so it could be */\n+\t      /* effected immediately with no bump -- but the code */\n+\t      /* is clearer if this is done the same way as the others */\n+\t      if (*ulsd==0 || *ulsd==5) bump=1;\n+\t      }\n+\t    break;} /* r-r */\n+\t  default: {\t  /* e.g., DEC_ROUND_MAX */\n+\t    set->status|=DEC_Invalid_context;\n+\t    #if DECCHECK\n+\t    printf(\"Unknown rounding mode: %ld\\n\", (LI)set->round);\n+\t    #endif\n+\t    break;}\n+\t  } /* switch (not r-h-e) */\n+\t/* printf(\"ReRound: %ld\t bump: %ld\\n\", (LI)reround, (LI)bump); */\n+\n+\tif (bump!=0) {\t\t\t     /* need increment */\n+\t  /* increment the coefficient; this might end up with 1000... */\n+\t  /* (after the all nines case) */\n+\t  ub=ulsd;\n+\t  for(; ub-3>=umsd && UINTAT(ub-3)==0x09090909; ub-=4) UINTAT(ub-3)=0;\n+\t  /* [note ub could now be to left of msd, and it is not safe */\n+\t  /* to write to the the left of the msd] */\n+\t  /* now at most 3 digits left to non-9 (usually just the one) */\n+\t  for (; ub>=umsd; *ub=0, ub--) {\n+\t    if (*ub==9) continue;\t     /* carry */\n+\t    *ub+=1;\n+\t    break;\n+\t    }\n+\t  if (ub<umsd) {\t\t     /* had all-nines */\n+\t    *umsd=1;\t\t\t     /* coefficient to 1000... */\n+\t    /* usually the 1000... coefficient can be used as-is */\n+\t    if ((ulsd-umsd+1)==DECPMAX) {\n+\t      num->exponent++;\n+\t      }\n+\t     else {\n+\t      /* if coefficient is shorter than Pmax then num is */\n+\t      /* subnormal, so extend it; this is safe as drop>0 */\n+\t      /* (or, if the coefficient was supplied above, it could */\n+\t      /* not be 9); this may make the result normal. */\n+\t      ulsd++;\n+\t      *ulsd=0;\n+\t      /* [exponent unchanged] */\n+\t      #if DECCHECK\n+\t      if (num->exponent!=DECQTINY) /* sanity check */\n+\t\tprintf(\"decFinalize: bad all-nines extend [^%ld, %ld]\\n\",\n+\t\t       (LI)num->exponent, (LI)(ulsd-umsd+1));\n+\t      #endif\n+\t      } /* subnormal extend */\n+\t    } /* had all-nines */\n+\t  } /* bump needed */\n+\t} /* inexact rounding */\n+\n+      length=ulsd-umsd+1;\t\t/* recalculate (may be <DECPMAX) */\n+      } /* need round (drop>0) */\n+\n+    /* The coefficient will now fit and has final length unless overflow */\n+    /* decShowNum(num, \"rounded\"); */\n+\n+    /* if exponent is >=emax may have to clamp, overflow, or fold-down */\n+    if (num->exponent>DECEMAX-(DECPMAX-1)) { /* is edge case */\n+      /* printf(\"overflow checks...\\n\"); */\n+      if (*ulsd==0 && ulsd==umsd) {\t/* have zero */\n+\tnum->exponent=DECEMAX-(DECPMAX-1); /* clamp to max */\n+\t}\n+       else if ((num->exponent+length-1)>DECEMAX) { /* > Nmax */\n+\t/* Overflow -- these could go straight to encoding, here, but */\n+\t/* instead num is adjusted to keep the code cleaner */\n+\tFlag needmax=0;\t\t\t/* 1 for finite result */\n+\tset->status|=(DEC_Overflow | DEC_Inexact);\n+\tswitch (set->round) {\n+\t  case DEC_ROUND_DOWN: {\n+\t    needmax=1;\t\t\t/* never Infinity */\n+\t    break;} /* r-d */\n+\t  case DEC_ROUND_05UP: {\n+\t    needmax=1;\t\t\t/* never Infinity */\n+\t    break;} /* r-05 */\n+\t  case DEC_ROUND_CEILING: {\n+\t    if (num->sign) needmax=1;\t/* Infinity iff non-negative */\n+\t    break;} /* r-c */\n+\t  case DEC_ROUND_FLOOR: {\n+\t    if (!num->sign) needmax=1;\t/* Infinity iff negative */\n+\t    break;} /* r-f */\n+\t  default: break;\t\t/* Infinity in all other cases */\n+\t  }\n+\tif (!needmax) {\t\t\t/* easy .. set Infinity */\n+\t  num->exponent=DECFLOAT_Inf;\n+\t  *umsd=0;\t\t\t/* be clean: coefficient to 0 */\n+\t  ulsd=umsd;\t\t\t/* .. */\n+\t  }\n+\t else {\t\t\t\t/* return Nmax */\n+\t  umsd=allnines;\t\t/* use constant array */\n+\t  ulsd=allnines+DECPMAX-1;\n+\t  num->exponent=DECEMAX-(DECPMAX-1);\n+\t  }\n+\t}\n+       else { /* no overflow but non-zero and may have to fold-down */\n+\tInt shift=num->exponent-(DECEMAX-(DECPMAX-1));\n+\tif (shift>0) {\t\t\t/* fold-down needed */\n+\t  /* fold down needed; must copy to buffer in order to pad */\n+\t  /* with zeros safely; fortunately this is not the worst case */\n+\t  /* path because cannot have had a round */\n+\t  uByte buffer[ROUNDUP(DECPMAX+3, 4)]; /* [+3 allows uInt padding] */\n+\t  uByte *s=umsd;\t\t/* source */\n+\t  uByte *t=buffer;\t\t/* safe target */\n+\t  uByte *tlsd=buffer+(ulsd-umsd)+shift; /* target LSD */\n+\t  /* printf(\"folddown shift=%ld\\n\", (LI)shift); */\n+\t  for (; s<=ulsd; s+=4, t+=4) UINTAT(t)=UINTAT(s);\n+\t  for (t=tlsd-shift+1; t<=tlsd; t+=4) UINTAT(t)=0;  /* pad */\n+\t  num->exponent-=shift;\n+\t  umsd=buffer;\n+\t  ulsd=tlsd;\n+\t  }\n+\t} /* fold-down? */\n+      length=ulsd-umsd+1;\t\t/* recalculate length */\n+      } /* high-end edge case */\n+    } /* finite number */\n+\n+  /*------------------------------------------------------------------*/\n+  /* At this point the result will properly fit the decFloat\t      */\n+  /* encoding, and it can be encoded with no possibility of error     */\n+  /*------------------------------------------------------------------*/\n+  /* Following code does not alter coefficient (could be allnines array) */\n+\n+  if (length==DECPMAX) {\n+    return decFloatFromBCD(df, num->exponent, umsd, num->sign);\n+    }\n+\n+  /* Here when length is short */\n+  if (!NUMISSPECIAL(num)) {\t\t/* is still finite */\n+    /* encode the combination field and exponent continuation */\n+    uInt uexp=(uInt)(num->exponent+DECBIAS); /* biased exponent */\n+    uInt code=(uexp>>DECECONL)<<4;\t/* top two bits of exp */\n+    /* [msd=0] */\n+    /* look up the combination field and make high word */\n+    encode=DECCOMBFROM[code];\t\t/* indexed by (0-2)*16+msd */\n+    encode|=(uexp<<(32-6-DECECONL)) & 0x03ffffff; /* exponent continuation */\n+    }\n+   else encode=num->exponent;\t\t/* special [already in word] */\n+  /* [coefficient length here will be < DECPMAX] */\n+\n+  encode|=num->sign;\t\t\t/* add sign */\n+\n+  /* private macro to extract a declet, n (where 0<=n<DECLETS and 0 */\n+  /* refers to the declet from the least significant three digits) */\n+  /* and put the corresponding DPD code into dpd.  Access to umsd and */\n+  /* ulsd (pointers to the most and least significant digit of the */\n+  /* variable-length coefficient) is assumed, along with use of a */\n+  /* working pointer, uInt *ub. */\n+  /* As not full-length then chances are there are many leading zeros */\n+  /* [and there may be a partial triad] */\n+  #define getDPD(dpd, n) ub=ulsd-(3*(n))-2;\t\t\t      \\\n+    if (ub<umsd-2) dpd=0;\t\t\t\t\t      \\\n+     else if (ub>=umsd) dpd=BCD2DPD[(*ub*256)+(*(ub+1)*16)+*(ub+2)];  \\\n+     else {dpd=*(ub+2); if (ub+1==umsd) dpd+=*(ub+1)*16; dpd=BCD2DPD[dpd];}\n+\n+  /* place the declets in the encoding words and copy to result (df), */\n+  /* according to endianness; in all cases complete the sign word */\n+  /* first */\n+  #if DECPMAX==7\n+    getDPD(dpd, 1);\n+    encode|=dpd<<10;\n+    getDPD(dpd, 0);\n+    encode|=dpd;\n+    DFWORD(df, 0)=encode;     /* just the one word */\n+\n+  #elif DECPMAX==16\n+    getDPD(dpd, 4); encode|=dpd<<8;\n+    getDPD(dpd, 3); encode|=dpd>>2;\n+    DFWORD(df, 0)=encode;\n+    encode=dpd<<30;\n+    getDPD(dpd, 2); encode|=dpd<<20;\n+    getDPD(dpd, 1); encode|=dpd<<10;\n+    getDPD(dpd, 0); encode|=dpd;\n+    DFWORD(df, 1)=encode;\n+\n+  #elif DECPMAX==34\n+    getDPD(dpd,10); encode|=dpd<<4;\n+    getDPD(dpd, 9); encode|=dpd>>6;\n+    DFWORD(df, 0)=encode;\n+\n+    encode=dpd<<26;\n+    getDPD(dpd, 8); encode|=dpd<<16;\n+    getDPD(dpd, 7); encode|=dpd<<6;\n+    getDPD(dpd, 6); encode|=dpd>>4;\n+    DFWORD(df, 1)=encode;\n+\n+    encode=dpd<<28;\n+    getDPD(dpd, 5); encode|=dpd<<18;\n+    getDPD(dpd, 4); encode|=dpd<<8;\n+    getDPD(dpd, 3); encode|=dpd>>2;\n+    DFWORD(df, 2)=encode;\n+\n+    encode=dpd<<30;\n+    getDPD(dpd, 2); encode|=dpd<<20;\n+    getDPD(dpd, 1); encode|=dpd<<10;\n+    getDPD(dpd, 0); encode|=dpd;\n+    DFWORD(df, 3)=encode;\n+  #endif\n+\n+  /* printf(\"Status: %08lx\\n\", (LI)set->status); */\n+  /* decFloatShow(df, \"final\"); */\n+  return df;\n+  } /* decFinalize */\n+\n+/* ------------------------------------------------------------------ */\n+/* decFloatFromBCD -- set decFloat from exponent, BCD8, and sign      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  df is the target decFloat\t\t\t\t\t      */\n+/*  exp is the in-range unbiased exponent, q, or a special value in   */\n+/*    the form returned by decFloatGetExponent\t\t\t      */\n+/*  bcdar holds DECPMAX digits to set the coefficient from, one\t      */\n+/*    digit in each byte (BCD8 encoding); the first (MSD) is ignored  */\n+/*    if df is a NaN; all are ignored if df is infinite.\t      */\n+/*    All bytes must be in 0-9; results undefined otherwise.\t      */\n+/*  sig is DECFLOAT_Sign to set the sign bit, 0 otherwise\t      */\n+/*  returns df, which will be canonical\t\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* No error is possible, and no status will be set.\t\t      */\n+/* ------------------------------------------------------------------ */\n+decFloat * decFloatFromBCD(decFloat *df, Int exp, const uByte *bcdar,\n+\t\t\t   Int sig) {\n+  uInt encode, dpd;\t\t\t/* work */\n+  const uByte *ub;\t\t\t/* .. */\n+\n+  if (EXPISSPECIAL(exp)) encode=exp|sig;/* specials already encoded */\n+   else {\t\t\t\t/* is finite */\n+    /* encode the combination field and exponent continuation */\n+    uInt uexp=(uInt)(exp+DECBIAS);\t/* biased exponent */\n+    uInt code=(uexp>>DECECONL)<<4;\t/* top two bits of exp */\n+    code+=bcdar[0];\t\t\t/* add msd */\n+    /* look up the combination field and make high word */\n+    encode=DECCOMBFROM[code]|sig;\t/* indexed by (0-2)*16+msd */\n+    encode|=(uexp<<(32-6-DECECONL)) & 0x03ffffff; /* exponent continuation */\n+    }\n+\n+  /* private macro to extract a declet, n (where 0<=n<DECLETS and 0 */\n+  /* refers to the declet from the least significant three digits) */\n+  /* and put the corresponding DPD code into dpd. */\n+  /* Use of a working pointer, uInt *ub, is assumed. */\n+\n+  #define getDPDf(dpd, n) ub=bcdar+DECPMAX-1-(3*(n))-2;\t    \\\n+    dpd=BCD2DPD[(*ub*256)+(*(ub+1)*16)+*(ub+2)];\n+\n+  /* place the declets in the encoding words and copy to result (df), */\n+  /* according to endianness; in all cases complete the sign word */\n+  /* first */\n+  #if DECPMAX==7\n+    getDPDf(dpd, 1);\n+    encode|=dpd<<10;\n+    getDPDf(dpd, 0);\n+    encode|=dpd;\n+    DFWORD(df, 0)=encode;     /* just the one word */\n+\n+  #elif DECPMAX==16\n+    getDPDf(dpd, 4); encode|=dpd<<8;\n+    getDPDf(dpd, 3); encode|=dpd>>2;\n+    DFWORD(df, 0)=encode;\n+    encode=dpd<<30;\n+    getDPDf(dpd, 2); encode|=dpd<<20;\n+    getDPDf(dpd, 1); encode|=dpd<<10;\n+    getDPDf(dpd, 0); encode|=dpd;\n+    DFWORD(df, 1)=encode;\n+\n+  #elif DECPMAX==34\n+    getDPDf(dpd,10); encode|=dpd<<4;\n+    getDPDf(dpd, 9); encode|=dpd>>6;\n+    DFWORD(df, 0)=encode;\n+\n+    encode=dpd<<26;\n+    getDPDf(dpd, 8); encode|=dpd<<16;\n+    getDPDf(dpd, 7); encode|=dpd<<6;\n+    getDPDf(dpd, 6); encode|=dpd>>4;\n+    DFWORD(df, 1)=encode;\n+\n+    encode=dpd<<28;\n+    getDPDf(dpd, 5); encode|=dpd<<18;\n+    getDPDf(dpd, 4); encode|=dpd<<8;\n+    getDPDf(dpd, 3); encode|=dpd>>2;\n+    DFWORD(df, 2)=encode;\n+\n+    encode=dpd<<30;\n+    getDPDf(dpd, 2); encode|=dpd<<20;\n+    getDPDf(dpd, 1); encode|=dpd<<10;\n+    getDPDf(dpd, 0); encode|=dpd;\n+    DFWORD(df, 3)=encode;\n+  #endif\n+  /* decFloatShow(df, \"final\"); */\n+  return df;\n+  } /* decFloatFromBCD */\n+\n+/* ------------------------------------------------------------------ */\n+/* decFloatFromPacked -- set decFloat from exponent and packed BCD    */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  df is the target decFloat\t\t\t\t\t      */\n+/*  exp is the in-range unbiased exponent, q, or a special value in   */\n+/*    the form returned by decFloatGetExponent\t\t\t      */\n+/*  packed holds DECPMAX packed decimal digits plus a sign nibble     */\n+/*    (all 6 codes are OK); the first (MSD) is ignored if df is a NaN */\n+/*    and all except sign are ignored if df is infinite.  For DOUBLE  */\n+/*    and QUAD the first (pad) nibble is also ignored in all cases.   */\n+/*    All coefficient nibbles must be in 0-9 and sign in A-F; results */\n+/*    are undefined otherwise.\t\t\t\t\t      */\n+/*  returns df, which will be canonical\t\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* No error is possible, and no status will be set.\t\t      */\n+/* ------------------------------------------------------------------ */\n+decFloat * decFloatFromPacked(decFloat *df, Int exp, const uByte *packed) {\n+  uByte bcdar[DECPMAX+2];\t\t/* work [+1 for pad, +1 for sign] */\n+  const uByte *ip;\t\t\t/* .. */\n+  uByte *op;\t\t\t\t/* .. */\n+  Int\tsig=0;\t\t\t\t/* sign */\n+\n+  /* expand coefficient and sign to BCDAR */\n+  #if SINGLE\n+  op=bcdar+1;\t\t\t\t/* no pad digit */\n+  #else\n+  op=bcdar;\t\t\t\t/* first (pad) digit ignored */\n+  #endif\n+  for (ip=packed; ip<packed+((DECPMAX+2)/2); ip++) {\n+    *op++=*ip>>4;\n+    *op++=(uByte)(*ip&0x0f);\t\t/* [final nibble is sign] */\n+    }\n+  op--;\t\t\t\t\t/* -> sign byte */\n+  if (*op==DECPMINUS || *op==DECPMINUSALT) sig=DECFLOAT_Sign;\n+\n+  if (EXPISSPECIAL(exp)) {\t\t/* Infinity or NaN */\n+    if (!EXPISINF(exp)) bcdar[1]=0;\t/* a NaN: ignore MSD */\n+     else memset(bcdar+1, 0, DECPMAX);\t/* Infinite: coefficient to 0 */\n+    }\n+  return decFloatFromBCD(df, exp, bcdar+1, sig);\n+  } /* decFloatFromPacked */\n+\n+/* ------------------------------------------------------------------ */\n+/* decFloatFromString -- conversion from numeric string\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  result  is the decFloat format number which gets the result of    */\n+/*\t    the conversion\t\t\t\t\t      */\n+/*  *string is the character string which should contain a valid      */\n+/*\t    number (which may be a special value), \\0-terminated      */\n+/*\t    If there are too many significant digits in the\t      */\n+/*\t    coefficient it will be rounded.\t\t\t      */\n+/*  set\t    is the context\t\t\t\t\t      */\n+/*  returns result\t\t\t\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* The length of the coefficient and the size of the exponent are     */\n+/* checked by this routine, so the correct error (Underflow or\t      */\n+/* Overflow) can be reported or rounding applied, as necessary.\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* There is no limit to the coefficient length for finite inputs;     */\n+/* NaN payloads must be integers with no more than DECPMAX-1 digits.  */\n+/* Exponents may have up to nine significant digits.\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* If bad syntax is detected, the result will be a quiet NaN.\t      */\n+/* ------------------------------------------------------------------ */\n+decFloat * decFloatFromString(decFloat *result, const char *string,\n+\t\t\t      decContext *set) {\n+  Int\t digits;\t\t   /* count of digits in coefficient */\n+  const\t char *dotchar=NULL;\t   /* where dot was found [NULL if none] */\n+  const\t char *cfirst=string;\t   /* -> first character of decimal part */\n+  const\t char *c;\t\t   /* work */\n+  uByte *ub;\t\t\t   /* .. */\n+  bcdnum num;\t\t\t   /* collects data for finishing */\n+  uInt\t error=DEC_Conversion_syntax;\t/* assume the worst */\n+  uByte\t buffer[ROUNDUP(DECSTRING+11, 8)]; /* room for most coefficents, */\n+\t\t\t\t   /* some common rounding, +3, & pad */\n+  #if DECTRACE\n+  /* printf(\"FromString %s ...\\n\", string); */\n+  #endif\n+\n+  for(;;) {\t\t\t\t/* once-only 'loop' */\n+    num.sign=0;\t\t\t\t/* assume non-negative */\n+    num.msd=buffer;\t\t\t/* MSD is here always */\n+\n+    /* detect and validate the coefficient, including any leading, */\n+    /* trailing, or embedded '.' */\n+    /* [could test four-at-a-time here (saving 10% for decQuads), */\n+    /* but that risks storage violation because the position of the */\n+    /* terminator is unknown] */\n+    for (c=string;; c++) {\t\t/* -> input character */\n+      if (((unsigned)(*c-'0'))<=9) continue; /* '0' through '9' is good */\n+      if (*c=='\\0') break;\t\t/* most common non-digit */\n+      if (*c=='.') {\n+\tif (dotchar!=NULL) break;\t/* not first '.' */\n+\tdotchar=c;\t\t\t/* record offset into decimal part */\n+\tcontinue;}\n+      if (c==string) {\t\t\t/* first in string... */\n+\tif (*c=='-') {\t\t\t/* valid - sign */\n+\t  cfirst++;\n+\t  num.sign=DECFLOAT_Sign;\n+\t  continue;}\n+\tif (*c=='+') {\t\t\t/* valid + sign */\n+\t  cfirst++;\n+\t  continue;}\n+\t}\n+      /* *c is not a digit, terminator, or a valid +, -, or '.' */\n+      break;\n+      } /* c loop */\n+\n+    digits=(uInt)(c-cfirst);\t\t/* digits (+1 if a dot) */\n+\n+    if (digits>0) {\t\t\t/* had digits and/or dot */\n+      const char *clast=c-1;\t\t/* note last coefficient char position */\n+      Int exp=0;\t\t\t/* exponent accumulator */\n+      if (*c!='\\0') {\t\t\t/* something follows the coefficient */\n+\tuInt edig;\t\t\t/* unsigned work */\n+\t/* had some digits and more to come; expect E[+|-]nnn now */\n+\tconst char *firstexp;\t\t/* exponent first non-zero */\n+\tif (*c!='E' && *c!='e') break;\n+\tc++;\t\t\t\t/* to (optional) sign */\n+\tif (*c=='-' || *c=='+') c++;\t/* step over sign (c=clast+2) */\n+\tif (*c=='\\0') break;\t\t/* no digits!  (e.g., '1.2E') */\n+\tfor (; *c=='0';) c++;\t\t/* skip leading zeros [even last] */\n+\tfirstexp=c;\t\t\t/* remember start [maybe '\\0'] */\n+\t/* gather exponent digits */\n+\tedig=(uInt)*c-(uInt)'0';\n+\tif (edig<=9) {\t\t\t/* [check not bad or terminator] */\n+\t  exp+=edig;\t\t\t/* avoid initial X10 */\n+\t  c++;\n+\t  for (;; c++) {\n+\t    edig=(uInt)*c-(uInt)'0';\n+\t    if (edig>9) break;\n+\t    exp=exp*10+edig;\n+\t    }\n+\t  }\n+\t/* if not now on the '\\0', *c must not be a digit */\n+\tif (*c!='\\0') break;\n+\n+\t/* (this next test must be after the syntax checks) */\n+\t/* if definitely more than the possible digits for format then */\n+\t/* the exponent may have wrapped, so simply set it to a certain */\n+\t/* over/underflow value */\n+\tif (c>firstexp+DECEMAXD) exp=DECEMAX*2;\n+\tif (*(clast+2)=='-') exp=-exp;\t/* was negative */\n+\t} /* digits>0 */\n+\n+      if (dotchar!=NULL) {\t\t/* had a '.' */\n+\tdigits--;\t\t\t/* remove from digits count */\n+\tif (digits==0) break;\t\t/* was dot alone: bad syntax */\n+\texp-=(Int)(clast-dotchar);\t/* adjust exponent */\n+\t/* [the '.' can now be ignored] */\n+\t}\n+      num.exponent=exp;\t\t\t/* exponent is good; store it */\n+\n+      /* Here when whole string has been inspected and syntax is good */\n+      /* cfirst->first digit or dot, clast->last digit or dot */\n+      error=0;\t\t\t\t/* no error possible now */\n+\n+      /* if the number of digits in the coefficient will fit in buffer */\n+      /* then it can simply be converted to bcd8 and copied -- decFinalize */\n+      /* will take care of leading zeros and rounding; the buffer is big */\n+      /* enough for all canonical coefficients, including 0.00000nn... */\n+      ub=buffer;\n+      if (digits<=(Int)(sizeof(buffer)-3)) { /* [-3 allows by-4s copy] */\n+\tc=cfirst;\n+\tif (dotchar!=NULL) {\t\t     /* a dot to worry about */\n+\t  if (*(c+1)=='.') {\t\t     /* common canonical case */\n+\t    *ub++=(uByte)(*c-'0');\t     /* copy leading digit */\n+\t    c+=2;\t\t\t     /* prepare to handle rest */\n+\t    }\n+\t   else for (; c<=clast;) {\t     /* '.' could be anywhere */\n+\t    /* as usual, go by fours when safe; NB it has been asserted */\n+\t    /* that a '.' does not have the same mask as a digit */\n+\t    if (c<=clast-3\t\t\t       /* safe for four */\n+\t     && (UINTAT(c)&0xf0f0f0f0)==CHARMASK) {    /* test four */\n+\t      UINTAT(ub)=UINTAT(c)&0x0f0f0f0f;\t       /* to BCD8 */\n+\t      ub+=4;\n+\t      c+=4;\n+\t      continue;\n+\t      }\n+\t    if (*c=='.') {\t\t     /* found the dot */\n+\t      c++;\t\t\t     /* step over it .. */\n+\t      break;\t\t\t     /* .. and handle the rest */\n+\t      }\n+\t    *ub++=(uByte)(*c++-'0');\n+\t    }\n+\t  } /* had dot */\n+\t/* Now no dot; do this by fours (where safe) */\n+\tfor (; c<=clast-3; c+=4, ub+=4) UINTAT(ub)=UINTAT(c)&0x0f0f0f0f;\n+\tfor (; c<=clast; c++, ub++) *ub=(uByte)(*c-'0');\n+\tnum.lsd=buffer+digits-1;\t     /* record new LSD */\n+\t} /* fits */\n+\n+       else {\t\t\t\t     /* too long for buffer */\n+\t/* [This is a rare and unusual case; arbitrary-length input] */\n+\t/* strip leading zeros [but leave final 0 if all 0's] */\n+\tif (*cfirst=='.') cfirst++;\t     /* step past dot at start */\n+\tif (*cfirst=='0') {\t\t     /* [cfirst always -> digit] */\n+\t  for (; cfirst<clast; cfirst++) {\n+\t    if (*cfirst!='0') {\t\t     /* non-zero found */\n+\t      if (*cfirst=='.') continue;    /* [ignore] */\n+\t      break;\t\t\t     /* done */\n+\t      }\n+\t    digits--;\t\t\t     /* 0 stripped */\n+\t    } /* cfirst */\n+\t  } /* at least one leading 0 */\n+\n+\t/* the coefficient is now as short as possible, but may still */\n+\t/* be too long; copy up to Pmax+1 digits to the buffer, then */\n+\t/* just record any non-zeros (set round-for-reround digit) */\n+\tfor (c=cfirst; c<=clast && ub<=buffer+DECPMAX; c++) {\n+\t  /* (see commentary just above) */\n+\t  if (c<=clast-3\t\t\t  /* safe for four */\n+\t   && (UINTAT(c)&0xf0f0f0f0)==CHARMASK) { /* four digits */\n+\t    UINTAT(ub)=UINTAT(c)&0x0f0f0f0f;\t  /* to BCD8 */\n+\t    ub+=4;\n+\t    c+=3;\t\t\t     /* [will become 4] */\n+\t    continue;\n+\t    }\n+\t  if (*c=='.') continue;\t     /* [ignore] */\n+\t  *ub++=(uByte)(*c-'0');\n+\t  }\n+\tub--;\t\t\t\t     /* -> LSD */\n+\tfor (; c<=clast; c++) {\t\t     /* inspect remaining chars */\n+\t  if (*c!='0') {\t\t     /* sticky bit needed */\n+\t    if (*c=='.') continue;\t     /* [ignore] */\n+\t    *ub=DECSTICKYTAB[*ub];\t     /* update round-for-reround */\n+\t    break;\t\t\t     /* no need to look at more */\n+\t    }\n+\t  }\n+\tnum.lsd=ub;\t\t\t     /* record LSD */\n+\t/* adjust exponent for dropped digits */\n+\tnum.exponent+=digits-(Int)(ub-buffer+1);\n+\t} /* too long for buffer */\n+      } /* digits or dot */\n+\n+     else {\t\t\t\t/* no digits or dot were found */\n+      if (*c=='\\0') break;\t\t/* nothing to come is bad */\n+      /* only Infinities and NaNs are allowed, here */\n+      buffer[0]=0;\t\t\t/* default a coefficient of 0 */\n+      num.lsd=buffer;\t\t\t/* .. */\n+      if (decBiStr(c, \"infinity\", \"INFINITY\")\n+       || decBiStr(c, \"inf\", \"INF\")) num.exponent=DECFLOAT_Inf;\n+       else {\t\t\t\t/* should be a NaN */\n+\tnum.exponent=DECFLOAT_qNaN;\t/* assume quiet NaN */\n+\tif (*c=='s' || *c=='S') {\t/* probably an sNaN */\n+\t  c++;\n+\t  num.exponent=DECFLOAT_sNaN;\t/* assume is in fact sNaN */\n+\t  }\n+\tif (*c!='N' && *c!='n') break;\t/* check caseless \"NaN\" */\n+\tc++;\n+\tif (*c!='a' && *c!='A') break;\t/* .. */\n+\tc++;\n+\tif (*c!='N' && *c!='n') break;\t/* .. */\n+\tc++;\n+\t/* now either nothing, or nnnn payload (no dots), expected */\n+\t/* -> start of integer, and skip leading 0s [including plain 0] */\n+\tfor (cfirst=c; *cfirst=='0';) cfirst++;\n+\tif (*cfirst!='\\0') {\t\t/* not empty or all-0, payload */\n+\t  /* payload found; check all valid digits and copy to buffer as bcd8 */\n+\t  ub=buffer;\n+\t  for (c=cfirst;; c++, ub++) {\n+\t    if ((unsigned)(*c-'0')>9) break; /* quit if not 0-9 */\n+\t    if (c-cfirst==DECPMAX-1) break;  /* too many digits */\n+\t    *ub=(uByte)(*c-'0');\t/* good bcd8 */\n+\t    }\n+\t  if (*c!='\\0') break;\t\t/* not all digits, or too many */\n+\t  num.lsd=ub-1;\t\t\t/* record new LSD */\n+\t  }\n+\t} /* NaN or sNaN */\n+      error=0;\t\t\t\t/* syntax is OK */\n+      break;\t\t\t\t/* done with specials */\n+      } /* digits=0 (special expected) */\n+    break;\n+    }\t\t\t\t\t/* [for(;;) break] */\n+\n+  /* decShowNum(&num, \"fromStr\"); */\n+\n+  if (error!=0) {\n+    set->status|=error;\n+    num.exponent=DECFLOAT_qNaN;\t\t/* set up quiet NaN */\n+    num.sign=0;\t\t\t\t/* .. with 0 sign */\n+    buffer[0]=0;\t\t\t/* .. and coefficient */\n+    num.lsd=buffer;\t\t\t/* .. */\n+    /* decShowNum(&num, \"oops\"); */\n+    }\n+\n+  /* decShowNum(&num, \"dffs\"); */\n+  decFinalize(result, &num, set);\t/* round, check, and lay out */\n+  /* decFloatShow(result, \"fromString\"); */\n+  return result;\n+  } /* decFloatFromString */\n+\n+/* ------------------------------------------------------------------ */\n+/* decFloatFromWider -- conversion from next-wider format\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  result  is the decFloat format number which gets the result of    */\n+/*\t    the conversion\t\t\t\t\t      */\n+/*  wider   is the decFloatWider format number which will be narrowed */\n+/*  set\t    is the context\t\t\t\t\t      */\n+/*  returns result\t\t\t\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* Narrowing can cause rounding, overflow, etc., but not Invalid      */\n+/* operation (sNaNs are copied and do not signal).\t\t      */\n+/* ------------------------------------------------------------------ */\n+/* narrow-to is not possible for decQuad format numbers; simply omit */\n+#if !QUAD\n+decFloat * decFloatFromWider(decFloat *result, const decFloatWider *wider,\n+\t\t\t     decContext *set) {\n+  bcdnum num;\t\t\t\t/* collects data for finishing */\n+  uByte\t bcdar[DECWPMAX];\t\t/* room for wider coefficient */\n+  uInt\t widerhi=DFWWORD(wider, 0);\t/* top word */\n+  Int\t exp;\n+\n+  GETWCOEFF(wider, bcdar);\n+\n+  num.msd=bcdar;\t\t\t/* MSD is here always */\n+  num.lsd=bcdar+DECWPMAX-1;\t\t/* LSD is here always */\n+  num.sign=widerhi&0x80000000;\t\t/* extract sign [DECFLOAT_Sign=Neg] */\n+\n+  /* decode the wider combination field to exponent */\n+  exp=DECCOMBWEXP[widerhi>>26];\t\t/* decode from wider combination field */\n+  /* if it is a special there's nothing to do unless sNaN; if it's */\n+  /* finite then add the (wider) exponent continuation and unbias */\n+  if (EXPISSPECIAL(exp)) exp=widerhi&0x7e000000; /* include sNaN selector */\n+   else exp+=GETWECON(wider)-DECWBIAS;\n+  num.exponent=exp;\n+\n+  /* decShowNum(&num, \"dffw\"); */\n+  return decFinalize(result, &num, set);/* round, check, and lay out */\n+  } /* decFloatFromWider */\n+#endif\n+\n+/* ------------------------------------------------------------------ */\n+/* decFloatGetCoefficient -- get coefficient as BCD8\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  df is the decFloat from which to extract the coefficient\t      */\n+/*  bcdar is where DECPMAX bytes will be written, one BCD digit in    */\n+/*    each byte (BCD8 encoding); if df is a NaN the first byte will   */\n+/*    be zero, and if it is infinite they will all be zero\t      */\n+/*  returns the sign of the coefficient (DECFLOAT_Sign if negative,   */\n+/*    0 otherwise)\t\t\t\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* No error is possible, and no status will be set.  If df is a\t      */\n+/* special value the array is set to zeros (for Infinity) or to the   */\n+/* payload of a qNaN or sNaN.\t\t\t\t\t      */\n+/* ------------------------------------------------------------------ */\n+Int decFloatGetCoefficient(const decFloat *df, uByte *bcdar) {\n+  if (DFISINF(df)) memset(bcdar, 0, DECPMAX);\n+   else {\n+    GETCOEFF(df, bcdar);\t   /* use macro */\n+    if (DFISNAN(df)) bcdar[0]=0;   /* MSD needs correcting */\n+    }\n+  return DFISSIGNED(df);\n+  } /* decFloatGetCoefficient */\n+\n+/* ------------------------------------------------------------------ */\n+/* decFloatGetExponent -- get unbiased exponent\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  df is the decFloat from which to extract the exponent\t      */\n+/*  returns the exponent, q.\t\t\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* No error is possible, and no status will be set.  If df is a\t      */\n+/* special value the first seven bits of the decFloat are returned,   */\n+/* left adjusted and with the first (sign) bit set to 0 (followed by  */\n+/* 25 0 bits).\te.g., -sNaN would return 0x7e000000 (DECFLOAT_sNaN).  */\n+/* ------------------------------------------------------------------ */\n+Int decFloatGetExponent(const decFloat *df) {\n+  if (DFISSPECIAL(df)) return DFWORD(df, 0)&0x7e000000;\n+  return GETEXPUN(df);\n+  } /* decFloatGetExponent */\n+\n+/* ------------------------------------------------------------------ */\n+/* decFloatSetCoefficient -- set coefficient from BCD8\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  df is the target decFloat (and source of exponent/special value)  */\n+/*  bcdar holds DECPMAX digits to set the coefficient from, one\t      */\n+/*    digit in each byte (BCD8 encoding); the first (MSD) is ignored  */\n+/*    if df is a NaN; all are ignored if df is infinite.\t      */\n+/*  sig is DECFLOAT_Sign to set the sign bit, 0 otherwise\t      */\n+/*  returns df, which will be canonical\t\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* No error is possible, and no status will be set.\t\t      */\n+/* ------------------------------------------------------------------ */\n+decFloat * decFloatSetCoefficient(decFloat *df, const uByte *bcdar,\n+\t\t\t\t  Int sig) {\n+  uInt exp;\t\t\t   /* for exponent */\n+  uByte bcdzero[DECPMAX];\t   /* for infinities */\n+\n+  /* Exponent/special code is extracted from df */\n+  if (DFISSPECIAL(df)) {\n+    exp=DFWORD(df, 0)&0x7e000000;\n+    if (DFISINF(df)) {\n+      memset(bcdzero, 0, DECPMAX);\n+      return decFloatFromBCD(df, exp, bcdzero, sig);\n+      }\n+    }\n+   else exp=GETEXPUN(df);\n+  return decFloatFromBCD(df, exp, bcdar, sig);\n+  } /* decFloatSetCoefficient */\n+\n+/* ------------------------------------------------------------------ */\n+/* decFloatSetExponent -- set exponent or special value\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  df\tis the target decFloat (and source of coefficient/payload)    */\n+/*  set is the context for reporting status\t\t\t      */\n+/*  exp is the unbiased exponent, q, or a special value in the form   */\n+/*    returned by decFloatGetExponent\t\t\t\t      */\n+/*  returns df, which will be canonical\t\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* No error is possible, but Overflow or Underflow might occur.\t      */\n+/* ------------------------------------------------------------------ */\n+decFloat * decFloatSetExponent(decFloat *df, decContext *set, Int exp) {\n+  uByte\t bcdcopy[DECPMAX];\t   /* for coefficient */\n+  bcdnum num;\t\t\t   /* work */\n+  num.exponent=exp;\n+  num.sign=decFloatGetCoefficient(df, bcdcopy); /* extract coefficient */\n+  if (DFISSPECIAL(df)) {\t   /* MSD or more needs correcting */\n+    if (DFISINF(df)) memset(bcdcopy, 0, DECPMAX);\n+    bcdcopy[0]=0;\n+    }\n+  num.msd=bcdcopy;\n+  num.lsd=bcdcopy+DECPMAX-1;\n+  return decFinalize(df, &num, set);\n+  } /* decFloatSetExponent */\n+\n+/* ------------------------------------------------------------------ */\n+/* decFloatRadix -- returns the base (10)\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*   df is any decFloat of this format\t\t\t\t      */\n+/* ------------------------------------------------------------------ */\n+uInt decFloatRadix(const decFloat *df) {\n+  if (df) return 10;\t\t\t     /* to placate compiler */\n+  return 10;\n+  } /* decFloatRadix */\n+\n+/* ------------------------------------------------------------------ */\n+/* decFloatShow -- printf a decFloat in hexadecimal and decimal\t      */\n+/*   df\t is the decFloat to show\t\t\t\t      */\n+/*   tag is a tag string displayed with the number\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* This is a debug aid; the precise format of the string may change.  */\n+/* ------------------------------------------------------------------ */\n+void decFloatShow(const decFloat *df, const char *tag) {\n+  char hexbuf[DECBYTES*2+DECBYTES/4+1]; /* NB blank after every fourth */\n+  char buff[DECSTRING];\t\t\t/* for value in decimal */\n+  Int i, j=0;\n+\n+  for (i=0; i<DECBYTES; i++) {\n+    #if DECLITEND\n+      sprintf(&hexbuf[j], \"%02x\", df->bytes[DECBYTES-1-i]);\n+    #else\n+      sprintf(&hexbuf[j], \"%02x\", df->bytes[i]);\n+    #endif\n+    j+=2;\n+    /* the next line adds blank (and terminator) after final pair, too */\n+    if ((i+1)%4==0) {strcpy(&hexbuf[j], \" \"); j++;}\n+    }\n+  decFloatToString(df, buff);\n+  printf(\">%s> %s [big-endian]\t%s\\n\", tag, hexbuf, buff);\n+  return;\n+  } /* decFloatShow */\n+\n+/* ------------------------------------------------------------------ */\n+/* decFloatToBCD -- get sign, exponent, and BCD8 from a decFloat      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  df is the source decFloat\t\t\t\t\t      */\n+/*  exp will be set to the unbiased exponent, q, or to a special      */\n+/*    value in the form returned by decFloatGetExponent\t\t      */\n+/*  bcdar is where DECPMAX bytes will be written, one BCD digit in    */\n+/*    each byte (BCD8 encoding); if df is a NaN the first byte will   */\n+/*    be zero, and if it is infinite they will all be zero\t      */\n+/*  returns the sign of the coefficient (DECFLOAT_Sign if negative,   */\n+/*    0 otherwise)\t\t\t\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* No error is possible, and no status will be set.\t\t      */\n+/* ------------------------------------------------------------------ */\n+Int decFloatToBCD(const decFloat *df, Int *exp, uByte *bcdar) {\n+  if (DFISINF(df)) {\n+    memset(bcdar, 0, DECPMAX);\n+    *exp=DFWORD(df, 0)&0x7e000000;\n+    }\n+   else {\n+    GETCOEFF(df, bcdar);\t   /* use macro */\n+    if (DFISNAN(df)) {\n+      bcdar[0]=0;\t\t   /* MSD needs correcting */\n+      *exp=DFWORD(df, 0)&0x7e000000;\n+      }\n+     else {\t\t\t   /* finite */\n+      *exp=GETEXPUN(df);\n+      }\n+    }\n+  return DFISSIGNED(df);\n+  } /* decFloatToBCD */\n+\n+/* ------------------------------------------------------------------ */\n+/* decFloatToEngString -- conversion to numeric string, engineering   */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  df is the decFloat format number to convert\t\t\t      */\n+/*  string is the string where the result will be laid out\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* string must be at least DECPMAX+9 characters (the worst case is    */\n+/* \"-0.00000nnn...nnn\\0\", which is as long as the exponent form when  */\n+/* DECEMAXD<=4); this condition is asserted above\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* No error is possible, and no status will be set\t\t      */\n+/* ------------------------------------------------------------------ */\n+char * decFloatToEngString(const decFloat *df, char *string){\n+  uInt msd;\t\t\t   /* coefficient MSD */\n+  Int  exp;\t\t\t   /* exponent top two bits or full */\n+  uInt comb;\t\t\t   /* combination field */\n+  char *cstart;\t\t\t   /* coefficient start */\n+  char *c;\t\t\t   /* output pointer in string */\n+  char *s, *t;\t\t\t   /* .. (source, target) */\n+  Int  pre, e;\t\t\t   /* work */\n+  const uByte *u;\t\t   /* .. */\n+\n+  /* Source words; macro handles endianness */\n+  uInt sourhi=DFWORD(df, 0);\t   /* word with sign */\n+  #if DECPMAX==16\n+  uInt sourlo=DFWORD(df, 1);\n+  #elif DECPMAX==34\n+  uInt sourmh=DFWORD(df, 1);\n+  uInt sourml=DFWORD(df, 2);\n+  uInt sourlo=DFWORD(df, 3);\n+  #endif\n+\n+  c=string;\t\t\t   /* where result will go */\n+  if (((Int)sourhi)<0) *c++='-';   /* handle sign */\n+  comb=sourhi>>26;\t\t   /* sign+combination field */\n+  msd=DECCOMBMSD[comb];\t\t   /* decode the combination field */\n+  exp=DECCOMBEXP[comb];\t\t   /* .. */\n+\n+  if (EXPISSPECIAL(exp)) {\t   /* special */\n+    if (exp==DECFLOAT_Inf) {\t   /* infinity */\n+      strcpy(c,\t  \"Inf\");\n+      strcpy(c+3, \"inity\");\n+      return string;\t\t   /* easy */\n+      }\n+    if (sourhi&0x02000000) *c++='s'; /* sNaN */\n+    strcpy(c, \"NaN\");\t\t   /* complete word */\n+    c+=3;\t\t\t   /* step past */\n+    /* quick exit if the payload is zero */\n+    #if DECPMAX==7\n+    if ((sourhi&0x000fffff)==0) return string;\n+    #elif DECPMAX==16\n+    if (sourlo==0 && (sourhi&0x0003ffff)==0) return string;\n+    #elif DECPMAX==34\n+    if (sourlo==0 && sourml==0 && sourmh==0\n+     && (sourhi&0x00003fff)==0) return string;\n+    #endif\n+    /* otherwise drop through to add integer; set correct exp etc. */\n+    exp=0; msd=0;\t\t   /* setup for following code */\n+    }\n+   else { /* complete exponent; top two bits are in place */\n+    exp+=GETECON(df)-DECBIAS;\t   /* .. + continuation and unbias */\n+    }\n+\n+  /* convert the digits of the significand to characters */\n+  cstart=c;\t\t\t   /* save start of coefficient */\n+  if (msd) *c++=(char)('0'+(char)msd);\t/* non-zero most significant digit */\n+\n+  /* Decode the declets.  After extracting each declet, it is */\n+  /* decoded to a 4-uByte sequence by table lookup; the four uBytes */\n+  /* are the three encoded BCD8 digits followed by a 1-byte length */\n+  /* (significant digits, except that 000 has length 0).  This allows */\n+  /* us to left-align the first declet with non-zero content, then */\n+  /* the remaining ones are full 3-char length.\t Fixed-length copies */\n+  /* are used because variable-length memcpy causes a subroutine call */\n+  /* in at least two compilers.\t (The copies are length 4 for speed */\n+  /* and are safe because the last item in the array is of length */\n+  /* three and has the length byte following.) */\n+  #define dpd2char(dpdin) u=&DPD2BCD8[((dpdin)&0x3ff)*4];\t \\\n+\t if (c!=cstart) {UINTAT(c)=UINTAT(u)|CHARMASK; c+=3;}\t \\\n+\t  else if (*(u+3)) {\t\t\t\t\t \\\n+\t   UINTAT(c)=UINTAT(u+3-*(u+3))|CHARMASK; c+=*(u+3);}\n+\n+  #if DECPMAX==7\n+  dpd2char(sourhi>>10);\t\t\t/* declet 1 */\n+  dpd2char(sourhi);\t\t\t/* declet 2 */\n+\n+  #elif DECPMAX==16\n+  dpd2char(sourhi>>8);\t\t\t/* declet 1 */\n+  dpd2char((sourhi<<2) | (sourlo>>30)); /* declet 2 */\n+  dpd2char(sourlo>>20);\t\t\t/* declet 3 */\n+  dpd2char(sourlo>>10);\t\t\t/* declet 4 */\n+  dpd2char(sourlo);\t\t\t/* declet 5 */\n+\n+  #elif DECPMAX==34\n+  dpd2char(sourhi>>4);\t\t\t/* declet 1 */\n+  dpd2char((sourhi<<6) | (sourmh>>26)); /* declet 2 */\n+  dpd2char(sourmh>>16);\t\t\t/* declet 3 */\n+  dpd2char(sourmh>>6);\t\t\t/* declet 4 */\n+  dpd2char((sourmh<<4) | (sourml>>28)); /* declet 5 */\n+  dpd2char(sourml>>18);\t\t\t/* declet 6 */\n+  dpd2char(sourml>>8);\t\t\t/* declet 7 */\n+  dpd2char((sourml<<2) | (sourlo>>30)); /* declet 8 */\n+  dpd2char(sourlo>>20);\t\t\t/* declet 9 */\n+  dpd2char(sourlo>>10);\t\t\t/* declet 10 */\n+  dpd2char(sourlo);\t\t\t/* declet 11 */\n+  #endif\n+\n+  if (c==cstart) *c++='0';\t   /* all zeros, empty -- make \"0\" */\n+\n+  if (exp==0) {\t\t\t   /* integer or NaN case -- easy */\n+    *c='\\0';\t\t\t   /* terminate */\n+    return string;\n+    }\n+  /* non-0 exponent */\n+\n+  e=0;\t\t\t\t   /* assume no E */\n+  pre=(Int)(c-cstart)+exp;\t   /* length+exp  [c->LSD+1] */\n+  /* [here, pre-exp is the digits count (==1 for zero)] */\n+\n+  if (exp>0 || pre<-5) {\t   /* need exponential form */\n+    e=pre-1;\t\t\t   /* calculate E value */\n+    pre=1;\t\t\t   /* assume one digit before '.' */\n+    if (e!=0) {\t\t\t   /* engineering: may need to adjust */\n+      Int adj;\t\t\t   /* adjustment */\n+      /* The C remainder operator is undefined for negative numbers, so */\n+      /* a positive remainder calculation must be used here */\n+      if (e<0) {\n+\tadj=(-e)%3;\n+\tif (adj!=0) adj=3-adj;\n+\t}\n+       else { /* e>0 */\n+\tadj=e%3;\n+\t}\n+      e=e-adj;\n+      /* if dealing with zero still produce an exponent which is a */\n+      /* multiple of three, as expected, but there will only be the */\n+      /* one zero before the E, still.\tOtherwise note the padding. */\n+      if (!DFISZERO(df)) pre+=adj;\n+       else {  /* is zero */\n+\tif (adj!=0) {\t\t   /* 0.00Esnn needed */\n+\t  e=e+3;\n+\t  pre=-(2-adj);\n+\t  }\n+\t} /* zero */\n+      } /* engineering adjustment */\n+    } /* exponential form */\n+  /* printf(\"e=%ld pre=%ld exp=%ld\\n\", (LI)e, (LI)pre, (LI)exp); */\n+\n+  /* modify the coefficient, adding 0s, '.', and E+nn as needed */\n+  if (pre>0) {\t\t\t   /* ddd.ddd (plain), perhaps with E */\n+\t\t\t\t   /* or dd00 padding for engineering */\n+    char *dotat=cstart+pre;\n+    if (dotat<c) {\t\t\t/* if embedded dot needed... */\n+      /* move by fours; there must be space for junk at the end */\n+      /* because there is still space for exponent */\n+      s=dotat+ROUNDDOWN4(c-dotat);\t/* source */\n+      t=s+1;\t\t\t\t/* target */\n+      /* open the gap */\n+      for (; s>=dotat; s-=4, t-=4) UINTAT(t)=UINTAT(s);\n+      *dotat='.';\n+      c++;\t\t\t\t/* length increased by one */\n+      } /* need dot? */\n+     else for (; c<dotat; c++) *c='0';\t/* pad for engineering */\n+    } /* pre>0 */\n+   else {\n+    /* -5<=pre<=0: here for plain 0.ddd or 0.000ddd forms (may have\n+       E, but only for 0.00E+3 kind of case -- with plenty of spare\n+       space in this case */\n+    pre=-pre+2;\t\t\t\t/* gap width, including \"0.\" */\n+    t=cstart+ROUNDDOWN4(c-cstart)+pre;\t/* preferred first target point */\n+    /* backoff if too far to the right */\n+    if (t>string+DECSTRING-5) t=string+DECSTRING-5; /* adjust to fit */\n+    /* now shift the entire coefficient to the right, being careful not */\n+    /* to access to the left of string */\n+    for (s=t-pre; s>=string; s-=4, t-=4) UINTAT(t)=UINTAT(s);\n+    /* for Quads and Singles there may be a character or two left... */\n+    s+=3;\t\t\t\t/* where next would come from */\n+    for(; s>=cstart; s--, t--) *(t+3)=*(s);\n+    /* now have fill 0. through 0.00000; use overlaps to avoid tests */\n+    if (pre>=4) {\n+      UINTAT(cstart+pre-4)=UINTAT(\"0000\");\n+      UINTAT(cstart)=UINTAT(\"0.00\");\n+      }\n+     else { /* 2 or 3 */\n+      *(cstart+pre-1)='0';\n+      USHORTAT(cstart)=USHORTAT(\"0.\");\n+      }\n+    c+=pre;\t\t\t\t/* to end */\n+    }\n+\n+  /* finally add the E-part, if needed; it will never be 0, and has */\n+  /* a maximum length of 3 or 4 digits (asserted above) */\n+  if (e!=0) {\n+    USHORTAT(c)=USHORTAT(\"E+\");\t\t/* starts with E, assume + */\n+    c++;\n+    if (e<0) {\n+      *c='-';\t\t\t\t/* oops, need '-' */\n+      e=-e;\t\t\t\t/* uInt, please */\n+      }\n+    c++;\n+    /* Three-character exponents are easy; 4-character a little trickier */\n+    #if DECEMAXD<=3\n+      u=&BIN2BCD8[e*4];\t\t\t/* -> 3 digits + length byte */\n+      /* copy fixed 4 characters [is safe], starting at non-zero */\n+      /* and with character mask to convert BCD to char */\n+      UINTAT(c)=UINTAT(u+3-*(u+3))|CHARMASK;\n+      c+=*(u+3);\t\t\t/* bump pointer appropriately */\n+    #elif DECEMAXD==4\n+      if (e<1000) {\t\t\t/* 3 (or fewer) digits case */\n+\tu=&BIN2BCD8[e*4];\t\t/* -> 3 digits + length byte */\n+\tUINTAT(c)=UINTAT(u+3-*(u+3))|CHARMASK; /* [as above] */\n+\tc+=*(u+3);\t\t\t/* bump pointer appropriately */\n+\t}\n+       else {\t\t\t\t/* 4-digits */\n+\tInt thou=((e>>3)*1049)>>17;\t/* e/1000 */\n+\tInt rem=e-(1000*thou);\t\t/* e%1000 */\n+\t*c++=(char)('0'+(char)thou);\t/* the thousands digit */\n+\tu=&BIN2BCD8[rem*4];\t\t/* -> 3 digits + length byte */\n+\tUINTAT(c)=UINTAT(u)|CHARMASK;\t/* copy fixed 3+1 characters [is safe] */\n+\tc+=3;\t\t\t\t/* bump pointer, always 3 digits */\n+\t}\n+    #endif\n+    }\n+  *c='\\0';\t\t\t\t/* terminate */\n+  /*printf(\"res %s\\n\", string); */\n+  return string;\n+  } /* decFloatToEngString */\n+\n+/* ------------------------------------------------------------------ */\n+/* decFloatToPacked -- convert decFloat to Packed decimal + exponent  */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  df is the source decFloat\t\t\t\t\t      */\n+/*  exp will be set to the unbiased exponent, q, or to a special      */\n+/*    value in the form returned by decFloatGetExponent\t\t      */\n+/*  packed is where DECPMAX nibbles will be written with the sign as  */\n+/*    final nibble (0x0c for +, 0x0d for -); a NaN has a first nibble */\n+/*    of zero, and an infinity is all zeros. decDouble and decQuad    */\n+/*    have a additional leading zero nibble, leading to result\t      */\n+/*    lengths of 4, 9, and 18 bytes.\t\t\t\t      */\n+/*  returns the sign of the coefficient (DECFLOAT_Sign if negative,   */\n+/*    0 otherwise)\t\t\t\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* No error is possible, and no status will be set.\t\t      */\n+/* ------------------------------------------------------------------ */\n+Int decFloatToPacked(const decFloat *df, Int *exp, uByte *packed) {\n+  uByte bcdar[DECPMAX+2];\t   /* work buffer */\n+  uByte *ip=bcdar, *op=packed;\t   /* work pointers */\n+  if (DFISINF(df)) {\n+    memset(bcdar, 0, DECPMAX+2);\n+    *exp=DECFLOAT_Inf;\n+    }\n+   else {\n+    GETCOEFF(df, bcdar+1);\t   /* use macro */\n+    if (DFISNAN(df)) {\n+      bcdar[1]=0;\t\t   /* MSD needs clearing */\n+      *exp=DFWORD(df, 0)&0x7e000000;\n+      }\n+     else {\t\t\t   /* finite */\n+      *exp=GETEXPUN(df);\n+      }\n+    }\n+  /* now pack; coefficient currently at bcdar+1 */\n+  #if SINGLE\n+    ip++;\t\t\t   /* ignore first byte */\n+  #else\n+    *ip=0;\t\t\t   /* need leading zero */\n+  #endif\n+  /* set final byte to Packed BCD sign value */\n+  bcdar[DECPMAX+1]=(DFISSIGNED(df) ? DECPMINUS : DECPPLUS);\n+  /* pack an even number of bytes... */\n+  for (; op<packed+((DECPMAX+2)/2); op++, ip+=2) {\n+    *op=(uByte)((*ip<<4)+*(ip+1));\n+    }\n+  return (bcdar[DECPMAX+1]==DECPMINUS ? DECFLOAT_Sign : 0);\n+  } /* decFloatToPacked */\n+\n+/* ------------------------------------------------------------------ */\n+/* decFloatToString -- conversion to numeric string\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  df is the decFloat format number to convert\t\t\t      */\n+/*  string is the string where the result will be laid out\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* string must be at least DECPMAX+9 characters (the worst case is    */\n+/* \"-0.00000nnn...nnn\\0\", which is as long as the exponent form when  */\n+/* DECEMAXD<=4); this condition is asserted above\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* No error is possible, and no status will be set\t\t      */\n+/* ------------------------------------------------------------------ */\n+char * decFloatToString(const decFloat *df, char *string){\n+  uInt msd;\t\t\t   /* coefficient MSD */\n+  Int  exp;\t\t\t   /* exponent top two bits or full */\n+  uInt comb;\t\t\t   /* combination field */\n+  char *cstart;\t\t\t   /* coefficient start */\n+  char *c;\t\t\t   /* output pointer in string */\n+  char *s, *t;\t\t\t   /* .. (source, target) */\n+  Int  pre, e;\t\t\t   /* work */\n+  const uByte *u;\t\t   /* .. */\n+\n+  /* Source words; macro handles endianness */\n+  uInt sourhi=DFWORD(df, 0);\t   /* word with sign */\n+  #if DECPMAX==16\n+  uInt sourlo=DFWORD(df, 1);\n+  #elif DECPMAX==34\n+  uInt sourmh=DFWORD(df, 1);\n+  uInt sourml=DFWORD(df, 2);\n+  uInt sourlo=DFWORD(df, 3);\n+  #endif\n+\n+  c=string;\t\t\t   /* where result will go */\n+  if (((Int)sourhi)<0) *c++='-';   /* handle sign */\n+  comb=sourhi>>26;\t\t   /* sign+combination field */\n+  msd=DECCOMBMSD[comb];\t\t   /* decode the combination field */\n+  exp=DECCOMBEXP[comb];\t\t   /* .. */\n+\n+  if (EXPISSPECIAL(exp)) {\t   /* special */\n+    if (exp==DECFLOAT_Inf) {\t   /* infinity */\n+      strcpy(c, \"Infinity\");\n+      return string;\t\t   /* easy */\n+      }\n+    if (sourhi&0x02000000) *c++='s'; /* sNaN */\n+    strcpy(c, \"NaN\");\t\t   /* complete word */\n+    c+=3;\t\t\t   /* step past */\n+    /* quick exit if the payload is zero */\n+    #if DECPMAX==7\n+    if ((sourhi&0x000fffff)==0) return string;\n+    #elif DECPMAX==16\n+    if (sourlo==0 && (sourhi&0x0003ffff)==0) return string;\n+    #elif DECPMAX==34\n+    if (sourlo==0 && sourml==0 && sourmh==0\n+     && (sourhi&0x00003fff)==0) return string;\n+    #endif\n+    /* otherwise drop through to add integer; set correct exp etc. */\n+    exp=0; msd=0;\t\t   /* setup for following code */\n+    }\n+   else { /* complete exponent; top two bits are in place */\n+    exp+=GETECON(df)-DECBIAS;\t   /* .. + continuation and unbias */\n+    }\n+\n+  /* convert the digits of the significand to characters */\n+  cstart=c;\t\t\t   /* save start of coefficient */\n+  if (msd) *c++=(char)('0'+(char)msd);\t/* non-zero most significant digit */\n+\n+  /* Decode the declets.  After extracting each declet, it is */\n+  /* decoded to a 4-uByte sequence by table lookup; the four uBytes */\n+  /* are the three encoded BCD8 digits followed by a 1-byte length */\n+  /* (significant digits, except that 000 has length 0).  This allows */\n+  /* us to left-align the first declet with non-zero content, then */\n+  /* the remaining ones are full 3-char length.\t Fixed-length copies */\n+  /* are used because variable-length memcpy causes a subroutine call */\n+  /* in at least two compilers.\t (The copies are length 4 for speed */\n+  /* and are safe because the last item in the array is of length */\n+  /* three and has the length byte following.) */\n+  #define dpd2char(dpdin) u=&DPD2BCD8[((dpdin)&0x3ff)*4];\t \\\n+\t if (c!=cstart) {UINTAT(c)=UINTAT(u)|CHARMASK; c+=3;}\t \\\n+\t  else if (*(u+3)) {\t\t\t\t\t \\\n+\t   UINTAT(c)=UINTAT(u+3-*(u+3))|CHARMASK; c+=*(u+3);}\n+\n+  #if DECPMAX==7\n+  dpd2char(sourhi>>10);\t\t\t/* declet 1 */\n+  dpd2char(sourhi);\t\t\t/* declet 2 */\n+\n+  #elif DECPMAX==16\n+  dpd2char(sourhi>>8);\t\t\t/* declet 1 */\n+  dpd2char((sourhi<<2) | (sourlo>>30)); /* declet 2 */\n+  dpd2char(sourlo>>20);\t\t\t/* declet 3 */\n+  dpd2char(sourlo>>10);\t\t\t/* declet 4 */\n+  dpd2char(sourlo);\t\t\t/* declet 5 */\n+\n+  #elif DECPMAX==34\n+  dpd2char(sourhi>>4);\t\t\t/* declet 1 */\n+  dpd2char((sourhi<<6) | (sourmh>>26)); /* declet 2 */\n+  dpd2char(sourmh>>16);\t\t\t/* declet 3 */\n+  dpd2char(sourmh>>6);\t\t\t/* declet 4 */\n+  dpd2char((sourmh<<4) | (sourml>>28)); /* declet 5 */\n+  dpd2char(sourml>>18);\t\t\t/* declet 6 */\n+  dpd2char(sourml>>8);\t\t\t/* declet 7 */\n+  dpd2char((sourml<<2) | (sourlo>>30)); /* declet 8 */\n+  dpd2char(sourlo>>20);\t\t\t/* declet 9 */\n+  dpd2char(sourlo>>10);\t\t\t/* declet 10 */\n+  dpd2char(sourlo);\t\t\t/* declet 11 */\n+  #endif\n+\n+  if (c==cstart) *c++='0';\t   /* all zeros, empty -- make \"0\" */\n+\n+  /*[This fast path is valid but adds 3-5 cycles to worst case length] */\n+  /*if (exp==0) {\t\t   // integer or NaN case -- easy */\n+  /*  *c='\\0';\t\t\t   // terminate */\n+  /*  return string; */\n+  /*  } */\n+\n+  e=0;\t\t\t\t   /* assume no E */\n+  pre=(Int)(c-cstart)+exp;\t   /* length+exp  [c->LSD+1] */\n+  /* [here, pre-exp is the digits count (==1 for zero)] */\n+\n+  if (exp>0 || pre<-5) {\t   /* need exponential form */\n+    e=pre-1;\t\t\t   /* calculate E value */\n+    pre=1;\t\t\t   /* assume one digit before '.' */\n+    } /* exponential form */\n+\n+  /* modify the coefficient, adding 0s, '.', and E+nn as needed */\n+  if (pre>0) {\t\t\t   /* ddd.ddd (plain), perhaps with E */\n+    char *dotat=cstart+pre;\n+    if (dotat<c) {\t\t\t/* if embedded dot needed... */\n+      /* move by fours; there must be space for junk at the end */\n+      /* because there is still space for exponent */\n+      s=dotat+ROUNDDOWN4(c-dotat);\t/* source */\n+      t=s+1;\t\t\t\t/* target */\n+      /* open the gap */\n+      for (; s>=dotat; s-=4, t-=4) UINTAT(t)=UINTAT(s);\n+      *dotat='.';\n+      c++;\t\t\t\t/* length increased by one */\n+      } /* need dot? */\n+\n+    /* finally add the E-part, if needed; it will never be 0, and has */\n+    /* a maximum length of 3 or 4 digits (asserted above) */\n+    if (e!=0) {\n+      USHORTAT(c)=USHORTAT(\"E+\");\t/* starts with E, assume + */\n+      c++;\n+      if (e<0) {\n+\t*c='-';\t\t\t\t/* oops, need '-' */\n+\te=-e;\t\t\t\t/* uInt, please */\n+\t}\n+      c++;\n+      /* Three-character exponents are easy; 4-character a little trickier */\n+      #if DECEMAXD<=3\n+\tu=&BIN2BCD8[e*4];\t\t/* -> 3 digits + length byte */\n+\t/* copy fixed 4 characters [is safe], starting at non-zero */\n+\t/* and with character mask to convert BCD to char */\n+\tUINTAT(c)=UINTAT(u+3-*(u+3))|CHARMASK;\n+\tc+=*(u+3);\t\t\t/* bump pointer appropriately */\n+      #elif DECEMAXD==4\n+\tif (e<1000) {\t\t\t/* 3 (or fewer) digits case */\n+\t  u=&BIN2BCD8[e*4];\t\t/* -> 3 digits + length byte */\n+\t  UINTAT(c)=UINTAT(u+3-*(u+3))|CHARMASK; /* [as above] */\n+\t  c+=*(u+3);\t\t\t/* bump pointer appropriately */\n+\t  }\n+\t else {\t\t\t\t/* 4-digits */\n+\t  Int thou=((e>>3)*1049)>>17;\t/* e/1000 */\n+\t  Int rem=e-(1000*thou);\t/* e%1000 */\n+\t  *c++=(char)('0'+(char)thou);\t/* the thousands digit */\n+\t  u=&BIN2BCD8[rem*4];\t\t/* -> 3 digits + length byte */\n+\t  UINTAT(c)=UINTAT(u)|CHARMASK; /* copy fixed 3+1 characters [is safe] */\n+\t  c+=3;\t\t\t\t/* bump pointer, always 3 digits */\n+\t  }\n+      #endif\n+      }\n+    *c='\\0';\t\t\t\t/* add terminator */\n+    /*printf(\"res %s\\n\", string); */\n+    return string;\n+    } /* pre>0 */\n+\n+  /* -5<=pre<=0: here for plain 0.ddd or 0.000ddd forms (can never have E) */\n+  /* Surprisingly, this is close to being the worst-case path, so the */\n+  /* shift is done by fours; this is a little tricky because the */\n+  /* rightmost character to be written must not be beyond where the */\n+  /* rightmost terminator could be -- so backoff to not touch */\n+  /* terminator position if need be (this can make exact alignments */\n+  /* for full Doubles, but in some cases needs care not to access too */\n+  /* far to the left) */\n+\n+  pre=-pre+2;\t\t\t\t/* gap width, including \"0.\" */\n+  t=cstart+ROUNDDOWN4(c-cstart)+pre;\t/* preferred first target point */\n+  /* backoff if too far to the right */\n+  if (t>string+DECSTRING-5) t=string+DECSTRING-5; /* adjust to fit */\n+  /* now shift the entire coefficient to the right, being careful not */\n+  /* to access to the left of string */\n+  for (s=t-pre; s>=string; s-=4, t-=4) UINTAT(t)=UINTAT(s);\n+  /* for Quads and Singles there may be a character or two left... */\n+  s+=3;\t\t\t\t\t/* where next would come from */\n+  for(; s>=cstart; s--, t--) *(t+3)=*(s);\n+  /* now have fill 0. through 0.00000; use overlaps to avoid tests */\n+  if (pre>=4) {\n+    UINTAT(cstart+pre-4)=UINTAT(\"0000\");\n+    UINTAT(cstart)=UINTAT(\"0.00\");\n+    }\n+   else { /* 2 or 3 */\n+    *(cstart+pre-1)='0';\n+    USHORTAT(cstart)=USHORTAT(\"0.\");\n+    }\n+  *(c+pre)='\\0';\t\t\t/* terminate */\n+  return string;\n+  } /* decFloatToString */\n+\n+/* ------------------------------------------------------------------ */\n+/* decFloatToWider -- conversion to next-wider format\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  source  is the decFloat format number which gets the result of    */\n+/*\t    the conversion\t\t\t\t\t      */\n+/*  wider   is the decFloatWider format number which will be narrowed */\n+/*  returns wider\t\t\t\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* Widening is always exact; no status is set (sNaNs are copied and   */\n+/* do not signal).  The result will be canonical if the source is,    */\n+/* and may or may not be if the source is not.\t\t\t      */\n+/* ------------------------------------------------------------------ */\n+/* widening is not possible for decQuad format numbers; simply omit */\n+#if !QUAD\n+decFloatWider * decFloatToWider(const decFloat *source, decFloatWider *wider) {\n+  uInt msd;\n+\n+  /* Construct and copy the sign word */\n+  if (DFISSPECIAL(source)) {\n+    /* copy sign, combination, and first bit of exponent (sNaN selector) */\n+    DFWWORD(wider, 0)=DFWORD(source, 0)&0xfe000000;\n+    msd=0;\n+    }\n+   else { /* is finite number */\n+    uInt exp=GETEXPUN(source)+DECWBIAS; /* get unbiased exponent and rebias */\n+    uInt code=(exp>>DECWECONL)<<29;\t/* set two bits of exp [msd=0] */\n+    code|=(exp<<(32-6-DECWECONL)) & 0x03ffffff; /* add exponent continuation */\n+    code|=DFWORD(source, 0)&0x80000000; /* add sign */\n+    DFWWORD(wider, 0)=code;\t\t/* .. and place top word in wider */\n+    msd=GETMSD(source);\t\t\t/* get source coefficient MSD [0-9] */\n+    }\n+  /* Copy the coefficient and clear any 'unused' words to left */\n+  #if SINGLE\n+    DFWWORD(wider, 1)=(DFWORD(source, 0)&0x000fffff)|(msd<<20);\n+  #elif DOUBLE\n+    DFWWORD(wider, 2)=(DFWORD(source, 0)&0x0003ffff)|(msd<<18);\n+    DFWWORD(wider, 3)=DFWORD(source, 1);\n+    DFWWORD(wider, 1)=0;\n+  #endif\n+  return wider;\n+  } /* decFloatToWider */\n+#endif\n+\n+/* ------------------------------------------------------------------ */\n+/* decFloatVersion -- return package version string\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  returns a constant string describing this package\t\t      */\n+/* ------------------------------------------------------------------ */\n+const char *decFloatVersion(void) {\n+  return DECVERSION;\n+  } /* decFloatVersion */\n+\n+/* ------------------------------------------------------------------ */\n+/* decFloatZero -- set to canonical (integer) zero\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  df is the decFloat format number to integer +0 (q=0, c=+0)\t      */\n+/*  returns df\t\t\t\t\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* No error is possible, and no status can be set.\t\t      */\n+/* ------------------------------------------------------------------ */\n+decFloat * decFloatZero(decFloat *df){\n+  DFWORD(df, 0)=ZEROWORD;     /* set appropriate top word */\n+  #if DOUBLE || QUAD\n+    DFWORD(df, 1)=0;\n+    #if QUAD\n+      DFWORD(df, 2)=0;\n+      DFWORD(df, 3)=0;\n+    #endif\n+  #endif\n+  /* decFloatShow(df, \"zero\"); */\n+  return df;\n+  } /* decFloatZero */\n+\n+/* ------------------------------------------------------------------ */\n+/* Private generic function (not format-specific) for development use */\n+/* ------------------------------------------------------------------ */\n+/* This is included once only, for all to use */\n+#if QUAD && (DECCHECK || DECTRACE)\n+  /* ---------------------------------------------------------------- */\n+  /* decShowNum -- display bcd8 number in debug form\t\t      */\n+  /*\t\t\t\t\t\t\t\t      */\n+  /*   num is the bcdnum to display\t\t\t\t      */\n+  /*   tag is a string to label the display\t\t\t      */\n+  /* ---------------------------------------------------------------- */\n+  void decShowNum(const bcdnum *num, const char *tag) {\n+    const char *csign=\"+\";\t\t/* sign character */\n+    uByte *ub;\t\t\t\t/* work */\n+    if (num->sign==DECFLOAT_Sign) csign=\"-\";\n+\n+    printf(\">%s> \", tag);\n+    if (num->exponent==DECFLOAT_Inf) printf(\"%sInfinity\", csign);\n+    else if (num->exponent==DECFLOAT_qNaN) printf(\"%sqNaN\", csign);\n+    else if (num->exponent==DECFLOAT_sNaN) printf(\"%ssNaN\", csign);\n+    else {\t\t\t\t/* finite */\n+     char qbuf[10];\t\t\t/* for right-aligned q */\n+     char *c;\t\t\t\t/* work */\n+     const uByte *u;\t\t\t/* .. */\n+     Int e=num->exponent;\t\t/* .. exponent */\n+     strcpy(qbuf, \"q=\");\n+     c=&qbuf[2];\t\t\t/* where exponent will go */\n+     /* lay out the exponent */\n+     if (e<0) {\n+       *c++='-';\t\t\t/* add '-' */\n+       e=-e;\t\t\t\t/* uInt, please */\n+       }\n+     #if DECEMAXD>4\n+       #error Exponent form is too long for ShowNum to lay out\n+     #endif\n+     if (e==0) *c++='0';\t\t/* 0-length case */\n+      else if (e<1000) {\t\t/* 3 (or fewer) digits case */\n+       u=&BIN2BCD8[e*4];\t\t/* -> 3 digits + length byte */\n+       UINTAT(c)=UINTAT(u+3-*(u+3))|CHARMASK; /* [as above] */\n+       c+=*(u+3);\t\t\t/* bump pointer appropriately */\n+       }\n+      else {\t\t\t\t/* 4-digits */\n+       Int thou=((e>>3)*1049)>>17;\t/* e/1000 */\n+       Int rem=e-(1000*thou);\t\t/* e%1000 */\n+       *c++=(char)('0'+(char)thou);\t/* the thousands digit */\n+       u=&BIN2BCD8[rem*4];\t\t/* -> 3 digits + length byte */\n+       UINTAT(c)=UINTAT(u)|CHARMASK;\t/* copy fixed 3+1 characters [is safe] */\n+       c+=3;\t\t\t\t/* bump pointer, always 3 digits */\n+       }\n+     *c='\\0';\t\t\t\t/* add terminator */\n+     printf(\"%7s c=%s\", qbuf, csign);\n+     }\n+\n+    if (!EXPISSPECIAL(num->exponent) || num->msd!=num->lsd || *num->lsd!=0) {\n+      for (ub=num->msd; ub<=num->lsd; ub++) { /* coefficient... */\n+\tprintf(\"%1x\", *ub);\n+\tif ((num->lsd-ub)%3==0 && ub!=num->lsd) printf(\" \"); /* 4-space */\n+\t}\n+      }\n+    printf(\"\\n\");\n+    } /* decShowNum */\n+#endif"}, {"sha": "077419318194df44cc1d53f0a82580c90276816e", "filename": "libdecnumber/decContext.c", "status": "modified", "additions": 376, "deletions": 172, "changes": 548, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FdecContext.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FdecContext.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecContext.c?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb", "patch": "@@ -1,5 +1,5 @@\n /* Decimal context module for the decNumber C Library.\n-   Copyright (C) 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2005, 2007 Free Software Foundation, Inc.\n    Contributed by IBM Corporation.  Author Mike Cowlishaw.\n \n    This file is part of GCC.\n@@ -28,201 +28,405 @@\n    Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    02110-1301, USA.  */\n \n-/*  This module compirises the routines for handling the arithmetic\n-    context structures. */\n-\n-#include <string.h>\t\t/* for strcmp */\n-#include \"config.h\"\n-#include \"decContext.h\"\t\t/* context and base types */\n-#include \"decNumberLocal.h\"\t/* decNumber local types, etc. */\n-\n-/* ------------------------------------------------------------------ */\n-/* decContextDefault -- initialize a context structure                */\n-/*                                                                    */\n-/*  context is the structure to be initialized                        */\n-/*  kind selects the required set of default values, one of:          */\n-/*      DEC_INIT_BASE       -- select ANSI X3-274 defaults            */\n-/*      DEC_INIT_DECIMAL32  -- select IEEE 754r defaults, 32-bit      */\n-/*      DEC_INIT_DECIMAL64  -- select IEEE 754r defaults, 64-bit      */\n-/*      DEC_INIT_DECIMAL128 -- select IEEE 754r defaults, 128-bit     */\n-/*      For any other value a valid context is returned, but with     */\n-/*      Invalid_operation set in the status field.                    */\n+/* ------------------------------------------------------------------ */\n+/* Decimal Context module\t\t\t\t\t      */\n+/* ------------------------------------------------------------------ */\n+/* This module comprises the routines for handling arithmetic\t      */\n+/* context structures.\t\t\t\t\t\t      */\n+/* ------------------------------------------------------------------ */\n+\n+#include <string.h>\t      /* for strcmp */\n+#include <stdio.h>\t      /* for printf if DECCHECK */\n+#include \"config.h\"\t      /* for GCC definitions */\n+#include \"decContext.h\"\t      /* context and base types */\n+#include \"decNumberLocal.h\"   /* decNumber local types, etc. */\n+\n+#if DECCHECK\n+/* compile-time endian tester [assumes sizeof(Int)>1] */\n+static\tconst  Int mfcone=1;\t\t     /* constant 1 */\n+static\tconst  Flag *mfctop=(Flag *)&mfcone; /* -> top byte */\n+#define LITEND *mfctop\t\t   /* named flag; 1=little-endian */\n+#endif\n+\n+/* ------------------------------------------------------------------ */\n+/* round-for-reround digits\t\t\t\t\t      */\n+/* ------------------------------------------------------------------ */\n+const uByte DECSTICKYTAB[10]={1,1,2,3,4,6,6,7,8,9}; /* used if sticky */\n+\n+/* ------------------------------------------------------------------ */\n+/* Powers of ten (powers[n]==10**n, 0<=n<=9)\t\t\t      */\n+/* ------------------------------------------------------------------ */\n+const uInt DECPOWERS[10]={1, 10, 100, 1000, 10000, 100000, 1000000,\n+\t\t\t  10000000, 100000000, 1000000000};\n+\n+/* ------------------------------------------------------------------ */\n+/* decContextClearStatus -- clear bits in current status\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  context is the context structure to be queried\t\t      */\n+/*  mask indicates the bits to be cleared (the status bit that\t      */\n+/*    corresponds to each 1 bit in the mask is cleared)\t\t      */\n+/*  returns context\t\t\t\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* No error is possible.\t\t\t\t\t      */\n+/* ------------------------------------------------------------------ */\n+decContext *decContextClearStatus(decContext *context, uInt mask) {\n+  context->status&=~mask;\n+  return context;\n+  } /* decContextClearStatus */\n+\n+/* ------------------------------------------------------------------ */\n+/* decContextDefault -- initialize a context structure\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  context is the structure to be initialized\t\t\t      */\n+/*  kind selects the required set of default values, one of:\t      */\n+/*\tDEC_INIT_BASE\t    -- select ANSI X3-274 defaults\t      */\n+/*\tDEC_INIT_DECIMAL32  -- select IEEE 754r defaults, 32-bit      */\n+/*\tDEC_INIT_DECIMAL64  -- select IEEE 754r defaults, 64-bit      */\n+/*\tDEC_INIT_DECIMAL128 -- select IEEE 754r defaults, 128-bit     */\n+/*\tFor any other value a valid context is returned, but with     */\n+/*\tInvalid_operation set in the status field.\t\t      */\n /*  returns a context structure with the appropriate initial values.  */\n /* ------------------------------------------------------------------ */\n-decContext *\n-decContextDefault (decContext * context, Int kind)\n-{\n+decContext * decContextDefault(decContext *context, Int kind) {\n   /* set defaults... */\n-  context->digits = 9;\t\t/* 9 digits */\n-  context->emax = DEC_MAX_EMAX;\t/* 9-digit exponents */\n-  context->emin = DEC_MIN_EMIN;\t/* .. balanced */\n-  context->round = DEC_ROUND_HALF_UP;\t/* 0.5 rises */\n-  context->traps = DEC_Errors;\t/* all but informational */\n-  context->status = 0;\t\t/* cleared */\n-  context->clamp = 0;\t\t/* no clamping */\n-#if DECSUBSET\n-  context->extended = 0;\t/* cleared */\n-#endif\n-  switch (kind)\n-    {\n+  context->digits=9;\t\t\t     /* 9 digits */\n+  context->emax=DEC_MAX_EMAX;\t\t     /* 9-digit exponents */\n+  context->emin=DEC_MIN_EMIN;\t\t     /* .. balanced */\n+  context->round=DEC_ROUND_HALF_UP;\t     /* 0.5 rises */\n+  context->traps=DEC_Errors;\t\t     /* all but informational */\n+  context->status=0;\t\t\t     /* cleared */\n+  context->clamp=0;\t\t\t     /* no clamping */\n+  #if DECSUBSET\n+  context->extended=0;\t\t\t     /* cleared */\n+  #endif\n+  switch (kind) {\n     case DEC_INIT_BASE:\n       /* [use defaults] */\n       break;\n     case DEC_INIT_DECIMAL32:\n-      context->digits = 7;\t/* digits */\n-      context->emax = 96;\t/* Emax */\n-      context->emin = -95;\t/* Emin */\n-      context->round = DEC_ROUND_HALF_EVEN;\t/* 0.5 to nearest even */\n-      context->traps = 0;\t/* no traps set */\n-      context->clamp = 1;\t/* clamp exponents */\n-#if DECSUBSET\n-      context->extended = 1;\t/* set */\n-#endif\n+      context->digits=7;\t\t     /* digits */\n+      context->emax=96;\t\t\t     /* Emax */\n+      context->emin=-95;\t\t     /* Emin */\n+      context->round=DEC_ROUND_HALF_EVEN;    /* 0.5 to nearest even */\n+      context->traps=0;\t\t\t     /* no traps set */\n+      context->clamp=1;\t\t\t     /* clamp exponents */\n+      #if DECSUBSET\n+      context->extended=1;\t\t     /* set */\n+      #endif\n       break;\n     case DEC_INIT_DECIMAL64:\n-      context->digits = 16;\t/* digits */\n-      context->emax = 384;\t/* Emax */\n-      context->emin = -383;\t/* Emin */\n-      context->round = DEC_ROUND_HALF_EVEN;\t/* 0.5 to nearest even */\n-      context->traps = 0;\t/* no traps set */\n-      context->clamp = 1;\t/* clamp exponents */\n-#if DECSUBSET\n-      context->extended = 1;\t/* set */\n-#endif\n+      context->digits=16;\t\t     /* digits */\n+      context->emax=384;\t\t     /* Emax */\n+      context->emin=-383;\t\t     /* Emin */\n+      context->round=DEC_ROUND_HALF_EVEN;    /* 0.5 to nearest even */\n+      context->traps=0;\t\t\t     /* no traps set */\n+      context->clamp=1;\t\t\t     /* clamp exponents */\n+      #if DECSUBSET\n+      context->extended=1;\t\t     /* set */\n+      #endif\n       break;\n     case DEC_INIT_DECIMAL128:\n-      context->digits = 34;\t/* digits */\n-      context->emax = 6144;\t/* Emax */\n-      context->emin = -6143;\t/* Emin */\n-      context->round = DEC_ROUND_HALF_EVEN;\t/* 0.5 to nearest even */\n-      context->traps = 0;\t/* no traps set */\n-      context->clamp = 1;\t/* clamp exponents */\n-#if DECSUBSET\n-      context->extended = 1;\t/* set */\n-#endif\n+      context->digits=34;\t\t     /* digits */\n+      context->emax=6144;\t\t     /* Emax */\n+      context->emin=-6143;\t\t     /* Emin */\n+      context->round=DEC_ROUND_HALF_EVEN;    /* 0.5 to nearest even */\n+      context->traps=0;\t\t\t     /* no traps set */\n+      context->clamp=1;\t\t\t     /* clamp exponents */\n+      #if DECSUBSET\n+      context->extended=1;\t\t     /* set */\n+      #endif\n       break;\n \n-    default:\t\t\t/* invalid Kind */\n+    default:\t\t\t\t     /* invalid Kind */\n       /* use defaults, and .. */\n-      decContextSetStatus (context, DEC_Invalid_operation);\t/* trap */\n+      decContextSetStatus(context, DEC_Invalid_operation); /* trap */\n+    }\n+\n+  #if DECCHECK\n+  if (LITEND!=DECLITEND) {\n+    const char *adj;\n+    if (LITEND) adj=\"little\";\n+\t   else adj=\"big\";\n+    printf(\"Warning: DECLITEND is set to %d, but this computer appears to be %s-endian\\n\",\n+\t   DECLITEND, adj);\n     }\n+  #endif\n+  return context;} /* decContextDefault */\n+\n+/* ------------------------------------------------------------------ */\n+/* decContextGetRounding -- return current rounding mode\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  context is the context structure to be queried\t\t      */\n+/*  returns the rounding mode\t\t\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* No error is possible.\t\t\t\t\t      */\n+/* ------------------------------------------------------------------ */\n+enum rounding decContextGetRounding(decContext *context) {\n+  return context->round;\n+  } /* decContextGetRounding */\n+\n+/* ------------------------------------------------------------------ */\n+/* decContextGetStatus -- return current status\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  context is the context structure to be queried\t\t      */\n+/*  returns status\t\t\t\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* No error is possible.\t\t\t\t\t      */\n+/* ------------------------------------------------------------------ */\n+uInt decContextGetStatus(decContext *context) {\n+  return context->status;\n+  } /* decContextGetStatus */\n+\n+/* ------------------------------------------------------------------ */\n+/* decContextRestoreStatus -- restore bits in current status\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  context is the context structure to be updated\t\t      */\n+/*  newstatus is the source for the bits to be restored\t\t      */\n+/*  mask indicates the bits to be restored (the status bit that\t      */\n+/*    corresponds to each 1 bit in the mask is set to the value of    */\n+/*    the correspnding bit in newstatus)\t\t\t      */\n+/*  returns context\t\t\t\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* No error is possible.\t\t\t\t\t      */\n+/* ------------------------------------------------------------------ */\n+decContext *decContextRestoreStatus(decContext *context,\n+\t\t\t\t    uInt newstatus, uInt mask) {\n+  context->status&=~mask;\t\t/* clear the selected bits */\n+  context->status|=(mask&newstatus);\t/* or in the new bits */\n   return context;\n-}\t\t\t\t/* decContextDefault */\n+  } /* decContextRestoreStatus */\n \n /* ------------------------------------------------------------------ */\n-/* decContextStatusToString -- convert status flags to a string       */\n-/*                                                                    */\n-/*  context is a context with valid status field                      */\n-/*                                                                    */\n-/*  returns a constant string describing the condition.  If multiple  */\n-/*    (or no) flags are set, a generic constant message is returned.  */\n+/* decContextSaveStatus -- save bits in current status\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  context is the context structure to be queried\t\t      */\n+/*  mask indicates the bits to be saved (the status bits that\t      */\n+/*    correspond to each 1 bit in the mask are saved)\t\t      */\n+/*  returns the AND of the mask and the current status\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* No error is possible.\t\t\t\t\t      */\n /* ------------------------------------------------------------------ */\n-const char *\n-decContextStatusToString (const decContext * context)\n-{\n-  Int status = context->status;\n-  if (status == DEC_Conversion_syntax)\n-    return DEC_Condition_CS;\n-  if (status == DEC_Division_by_zero)\n-    return DEC_Condition_DZ;\n-  if (status == DEC_Division_impossible)\n-    return DEC_Condition_DI;\n-  if (status == DEC_Division_undefined)\n-    return DEC_Condition_DU;\n-  if (status == DEC_Inexact)\n-    return DEC_Condition_IE;\n-  if (status == DEC_Insufficient_storage)\n-    return DEC_Condition_IS;\n-  if (status == DEC_Invalid_context)\n-    return DEC_Condition_IC;\n-  if (status == DEC_Invalid_operation)\n-    return DEC_Condition_IO;\n-#if DECSUBSET\n-  if (status == DEC_Lost_digits)\n-    return DEC_Condition_LD;\n-#endif\n-  if (status == DEC_Overflow)\n-    return DEC_Condition_OV;\n-  if (status == DEC_Clamped)\n-    return DEC_Condition_PA;\n-  if (status == DEC_Rounded)\n-    return DEC_Condition_RO;\n-  if (status == DEC_Subnormal)\n-    return DEC_Condition_SU;\n-  if (status == DEC_Underflow)\n-    return DEC_Condition_UN;\n-  if (status == 0)\n-    return DEC_Condition_ZE;\n-  return DEC_Condition_MU;\t/* Multiple errors */\n-}\t\t\t\t/* decContextStatusToString */\n-\n-/* ------------------------------------------------------------------ */\n-/* decContextSetStatusFromString -- set status from a string          */\n-/*                                                                    */\n-/*  context is the controlling context                                */\n+uInt decContextSaveStatus(decContext *context, uInt mask) {\n+  return context->status&mask;\n+  } /* decContextSaveStatus */\n+\n+/* ------------------------------------------------------------------ */\n+/* decContextSetRounding -- set current rounding mode\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  context is the context structure to be updated\t\t      */\n+/*  newround is the value which will replace the current mode\t      */\n+/*  returns context\t\t\t\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* No error is possible.\t\t\t\t\t      */\n+/* ------------------------------------------------------------------ */\n+decContext *decContextSetRounding(decContext *context,\n+\t\t\t\t  enum rounding newround) {\n+  context->round=newround;\n+  return context;\n+  } /* decContextSetRounding */\n+\n+/* ------------------------------------------------------------------ */\n+/* decContextSetStatus -- set status and raise trap if appropriate    */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  context is the context structure to be updated\t\t      */\n+/*  status  is the DEC_ exception code\t\t\t\t      */\n+/*  returns the context structure\t\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* Control may never return from this routine, if there is a signal   */\n+/* handler and it takes a long jump.\t\t\t\t      */\n+/* ------------------------------------------------------------------ */\n+decContext * decContextSetStatus(decContext *context, uInt status) {\n+  context->status|=status;\n+  if (status & context->traps) raise(SIGFPE);\n+  return context;} /* decContextSetStatus */\n+\n+/* ------------------------------------------------------------------ */\n+/* decContextSetStatusFromString -- set status from a string + trap   */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  context is the context structure to be updated\t\t      */\n /*  string is a string exactly equal to one that might be returned    */\n-/*            by decContextStatusToString                             */\n-/*                                                                    */\n+/*\t      by decContextStatusToString\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n /*  The status bit corresponding to the string is set, and a trap     */\n-/*  is raised if appropriate.                                         */\n-/*                                                                    */\n+/*  is raised if appropriate.\t\t\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n /*  returns the context structure, unless the string is equal to      */\n /*    DEC_Condition_MU or is not recognized.  In these cases NULL is  */\n-/*    returned.                                                       */\n-/* ------------------------------------------------------------------ */\n-decContext *\n-decContextSetStatusFromString (decContext * context, const char *string)\n-{\n-  if (strcmp (string, DEC_Condition_CS) == 0)\n-    return decContextSetStatus (context, DEC_Conversion_syntax);\n-  if (strcmp (string, DEC_Condition_DZ) == 0)\n-    return decContextSetStatus (context, DEC_Division_by_zero);\n-  if (strcmp (string, DEC_Condition_DI) == 0)\n-    return decContextSetStatus (context, DEC_Division_impossible);\n-  if (strcmp (string, DEC_Condition_DU) == 0)\n-    return decContextSetStatus (context, DEC_Division_undefined);\n-  if (strcmp (string, DEC_Condition_IE) == 0)\n-    return decContextSetStatus (context, DEC_Inexact);\n-  if (strcmp (string, DEC_Condition_IS) == 0)\n-    return decContextSetStatus (context, DEC_Insufficient_storage);\n-  if (strcmp (string, DEC_Condition_IC) == 0)\n-    return decContextSetStatus (context, DEC_Invalid_context);\n-  if (strcmp (string, DEC_Condition_IO) == 0)\n-    return decContextSetStatus (context, DEC_Invalid_operation);\n-#if DECSUBSET\n-  if (strcmp (string, DEC_Condition_LD) == 0)\n-    return decContextSetStatus (context, DEC_Lost_digits);\n-#endif\n-  if (strcmp (string, DEC_Condition_OV) == 0)\n-    return decContextSetStatus (context, DEC_Overflow);\n-  if (strcmp (string, DEC_Condition_PA) == 0)\n-    return decContextSetStatus (context, DEC_Clamped);\n-  if (strcmp (string, DEC_Condition_RO) == 0)\n-    return decContextSetStatus (context, DEC_Rounded);\n-  if (strcmp (string, DEC_Condition_SU) == 0)\n-    return decContextSetStatus (context, DEC_Subnormal);\n-  if (strcmp (string, DEC_Condition_UN) == 0)\n-    return decContextSetStatus (context, DEC_Underflow);\n-  if (strcmp (string, DEC_Condition_ZE) == 0)\n+/*    returned.\t\t\t\t\t\t\t      */\n+/* ------------------------------------------------------------------ */\n+decContext * decContextSetStatusFromString(decContext *context,\n+\t\t\t\t\t   const char *string) {\n+  if (strcmp(string, DEC_Condition_CS)==0)\n+    return decContextSetStatus(context, DEC_Conversion_syntax);\n+  if (strcmp(string, DEC_Condition_DZ)==0)\n+    return decContextSetStatus(context, DEC_Division_by_zero);\n+  if (strcmp(string, DEC_Condition_DI)==0)\n+    return decContextSetStatus(context, DEC_Division_impossible);\n+  if (strcmp(string, DEC_Condition_DU)==0)\n+    return decContextSetStatus(context, DEC_Division_undefined);\n+  if (strcmp(string, DEC_Condition_IE)==0)\n+    return decContextSetStatus(context, DEC_Inexact);\n+  if (strcmp(string, DEC_Condition_IS)==0)\n+    return decContextSetStatus(context, DEC_Insufficient_storage);\n+  if (strcmp(string, DEC_Condition_IC)==0)\n+    return decContextSetStatus(context, DEC_Invalid_context);\n+  if (strcmp(string, DEC_Condition_IO)==0)\n+    return decContextSetStatus(context, DEC_Invalid_operation);\n+  #if DECSUBSET\n+  if (strcmp(string, DEC_Condition_LD)==0)\n+    return decContextSetStatus(context, DEC_Lost_digits);\n+  #endif\n+  if (strcmp(string, DEC_Condition_OV)==0)\n+    return decContextSetStatus(context, DEC_Overflow);\n+  if (strcmp(string, DEC_Condition_PA)==0)\n+    return decContextSetStatus(context, DEC_Clamped);\n+  if (strcmp(string, DEC_Condition_RO)==0)\n+    return decContextSetStatus(context, DEC_Rounded);\n+  if (strcmp(string, DEC_Condition_SU)==0)\n+    return decContextSetStatus(context, DEC_Subnormal);\n+  if (strcmp(string, DEC_Condition_UN)==0)\n+    return decContextSetStatus(context, DEC_Underflow);\n+  if (strcmp(string, DEC_Condition_ZE)==0)\n     return context;\n-  return NULL;\t\t\t/* Multiple status, or unknown */\n-}\t\t\t\t/* decContextSetStatusFromString */\n+  return NULL;\t/* Multiple status, or unknown */\n+  } /* decContextSetStatusFromString */\n \n /* ------------------------------------------------------------------ */\n-/* decContextSetStatus -- set status and raise trap if appropriate    */\n-/*                                                                    */\n-/*  context is the controlling context                                */\n-/*  status  is the DEC_ exception code                                */\n-/*  returns the context structure                                     */\n-/*                                                                    */\n-/* Control may never return from this routine, if there is a signal   */\n-/* handler and it takes a long jump.                                  */\n-/* ------------------------------------------------------------------ */\n-decContext *\n-decContextSetStatus (decContext * context, uInt status)\n-{\n-  context->status |= status;\n-  if (status & context->traps)\n-    raise (SIGFPE);\n+/* decContextSetStatusFromStringQuiet -- set status from a string     */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  context is the context structure to be updated\t\t      */\n+/*  string is a string exactly equal to one that might be returned    */\n+/*\t      by decContextStatusToString\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  The status bit corresponding to the string is set; no trap is     */\n+/*  raised.\t\t\t\t\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  returns the context structure, unless the string is equal to      */\n+/*    DEC_Condition_MU or is not recognized.  In these cases NULL is  */\n+/*    returned.\t\t\t\t\t\t\t      */\n+/* ------------------------------------------------------------------ */\n+decContext * decContextSetStatusFromStringQuiet(decContext *context,\n+\t\t\t\t\t\tconst char *string) {\n+  if (strcmp(string, DEC_Condition_CS)==0)\n+    return decContextSetStatusQuiet(context, DEC_Conversion_syntax);\n+  if (strcmp(string, DEC_Condition_DZ)==0)\n+    return decContextSetStatusQuiet(context, DEC_Division_by_zero);\n+  if (strcmp(string, DEC_Condition_DI)==0)\n+    return decContextSetStatusQuiet(context, DEC_Division_impossible);\n+  if (strcmp(string, DEC_Condition_DU)==0)\n+    return decContextSetStatusQuiet(context, DEC_Division_undefined);\n+  if (strcmp(string, DEC_Condition_IE)==0)\n+    return decContextSetStatusQuiet(context, DEC_Inexact);\n+  if (strcmp(string, DEC_Condition_IS)==0)\n+    return decContextSetStatusQuiet(context, DEC_Insufficient_storage);\n+  if (strcmp(string, DEC_Condition_IC)==0)\n+    return decContextSetStatusQuiet(context, DEC_Invalid_context);\n+  if (strcmp(string, DEC_Condition_IO)==0)\n+    return decContextSetStatusQuiet(context, DEC_Invalid_operation);\n+  #if DECSUBSET\n+  if (strcmp(string, DEC_Condition_LD)==0)\n+    return decContextSetStatusQuiet(context, DEC_Lost_digits);\n+  #endif\n+  if (strcmp(string, DEC_Condition_OV)==0)\n+    return decContextSetStatusQuiet(context, DEC_Overflow);\n+  if (strcmp(string, DEC_Condition_PA)==0)\n+    return decContextSetStatusQuiet(context, DEC_Clamped);\n+  if (strcmp(string, DEC_Condition_RO)==0)\n+    return decContextSetStatusQuiet(context, DEC_Rounded);\n+  if (strcmp(string, DEC_Condition_SU)==0)\n+    return decContextSetStatusQuiet(context, DEC_Subnormal);\n+  if (strcmp(string, DEC_Condition_UN)==0)\n+    return decContextSetStatusQuiet(context, DEC_Underflow);\n+  if (strcmp(string, DEC_Condition_ZE)==0)\n+    return context;\n+  return NULL;\t/* Multiple status, or unknown */\n+  } /* decContextSetStatusFromStringQuiet */\n+\n+/* ------------------------------------------------------------------ */\n+/* decContextSetStatusQuiet -- set status without trap\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  context is the context structure to be updated\t\t      */\n+/*  status  is the DEC_ exception code\t\t\t\t      */\n+/*  returns the context structure\t\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* No error is possible.\t\t\t\t\t      */\n+/* ------------------------------------------------------------------ */\n+decContext * decContextSetStatusQuiet(decContext *context, uInt status) {\n+  context->status|=status;\n+  return context;} /* decContextSetStatusQuiet */\n+\n+/* ------------------------------------------------------------------ */\n+/* decContextStatusToString -- convert status flags to a string\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  context is a context with valid status field\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  returns a constant string describing the condition.\t If multiple  */\n+/*    (or no) flags are set, a generic constant message is returned.  */\n+/* ------------------------------------------------------------------ */\n+const char *decContextStatusToString(const decContext *context) {\n+  Int status=context->status;\n+\n+  /* test the five IEEE first, as some of the others are ambiguous when */\n+  /* DECEXTFLAG=0 */\n+  if (status==DEC_Invalid_operation    ) return DEC_Condition_IO;\n+  if (status==DEC_Division_by_zero     ) return DEC_Condition_DZ;\n+  if (status==DEC_Overflow\t       ) return DEC_Condition_OV;\n+  if (status==DEC_Underflow\t       ) return DEC_Condition_UN;\n+  if (status==DEC_Inexact\t       ) return DEC_Condition_IE;\n+\n+  if (status==DEC_Division_impossible  ) return DEC_Condition_DI;\n+  if (status==DEC_Division_undefined   ) return DEC_Condition_DU;\n+  if (status==DEC_Rounded\t       ) return DEC_Condition_RO;\n+  if (status==DEC_Clamped\t       ) return DEC_Condition_PA;\n+  if (status==DEC_Subnormal\t       ) return DEC_Condition_SU;\n+  if (status==DEC_Conversion_syntax    ) return DEC_Condition_CS;\n+  if (status==DEC_Insufficient_storage ) return DEC_Condition_IS;\n+  if (status==DEC_Invalid_context      ) return DEC_Condition_IC;\n+  #if DECSUBSET\n+  if (status==DEC_Lost_digits\t       ) return DEC_Condition_LD;\n+  #endif\n+  if (status==0\t\t\t       ) return DEC_Condition_ZE;\n+  return DEC_Condition_MU;  /* Multiple errors */\n+  } /* decContextStatusToString */\n+\n+/* ------------------------------------------------------------------ */\n+/* decContextTestSavedStatus -- test bits in saved status\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  oldstatus is the status word to be tested\t\t\t      */\n+/*  mask indicates the bits to be tested (the oldstatus bits that     */\n+/*    correspond to each 1 bit in the mask are tested)\t\t      */\n+/*  returns 1 if any of the tested bits are 1, or 0 otherwise\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* No error is possible.\t\t\t\t\t      */\n+/* ------------------------------------------------------------------ */\n+uInt decContextTestSavedStatus(uInt oldstatus, uInt mask) {\n+  return (oldstatus&mask)!=0;\n+  } /* decContextTestSavedStatus */\n+\n+/* ------------------------------------------------------------------ */\n+/* decContextTestStatus -- test bits in current status\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  context is the context structure to be updated\t\t      */\n+/*  mask indicates the bits to be tested (the status bits that\t      */\n+/*    correspond to each 1 bit in the mask are tested)\t\t      */\n+/*  returns 1 if any of the tested bits are 1, or 0 otherwise\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* No error is possible.\t\t\t\t\t      */\n+/* ------------------------------------------------------------------ */\n+uInt decContextTestStatus(decContext *context, uInt mask) {\n+  return (context->status&mask)!=0;\n+  } /* decContextTestStatus */\n+\n+/* ------------------------------------------------------------------ */\n+/* decContextZeroStatus -- clear all status bits\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  context is the context structure to be updated\t\t      */\n+/*  returns context\t\t\t\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* No error is possible.\t\t\t\t\t      */\n+/* ------------------------------------------------------------------ */\n+decContext *decContextZeroStatus(decContext *context) {\n+  context->status=0;\n   return context;\n-}\t\t\t\t/* decContextSetStatus */\n+  } /* decContextZeroStatus */\n+"}, {"sha": "f80d03c50cf5710a4c3b2a6994d087794fc4c237", "filename": "libdecnumber/decContext.h", "status": "modified", "additions": 222, "deletions": 151, "changes": 373, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FdecContext.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FdecContext.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecContext.h?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb", "patch": "@@ -1,5 +1,5 @@\n-/* Decimal Context module header for the decNumber C Library\n-   Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n+/* Decimal context header module for the decNumber C Library.\n+   Copyright (C) 2005, 2007 Free Software Foundation, Inc.\n    Contributed by IBM Corporation.  Author Mike Cowlishaw.\n \n    This file is part of GCC.\n@@ -29,159 +29,230 @@\n    02110-1301, USA.  */\n \n /* ------------------------------------------------------------------ */\n-/*                                                                    */\n-/* Context must always be set correctly:                              */\n-/*                                                                    */\n-/*  digits   -- must be in the range 1 through 999999999              */\n-/*  emax     -- must be in the range 0 through 999999999              */\n-/*  emin     -- must be in the range 0 through -999999999             */\n-/*  round    -- must be one of the enumerated rounding modes          */\n-/*  traps    -- only defined bits may be set                          */\n-/*  status   -- [any bits may be cleared, but not set, by user]       */\n-/*  clamp    -- must be either 0 or 1                                 */\n+/* Decimal Context module header\t\t\t\t      */\n+/* ------------------------------------------------------------------ */\n+/*\t\t\t\t\t\t\t\t      */\n+/* Context variables must always have valid values:\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  status   -- [any bits may be cleared, but not set, by user]\t      */\n+/*  round    -- must be one of the enumerated rounding modes\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* The following variables are implied for fixed size formats (i.e.,  */\n+/* they are ignored) but should still be set correctly in case used   */\n+/* with decNumber functions:\t\t\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  clamp    -- must be either 0 or 1\t\t\t\t      */\n+/*  digits   -- must be in the range 1 through 999999999\t      */\n+/*  emax     -- must be in the range 0 through 999999999\t      */\n+/*  emin     -- must be in the range 0 through -999999999\t      */\n /*  extended -- must be either 0 or 1 [present only if DECSUBSET]     */\n-/*                                                                    */\n+/*  traps    -- only defined bits may be set\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n /* ------------------------------------------------------------------ */\n \n #if !defined(DECCONTEXT)\n-#define DECCONTEXT\n-#define DECCNAME     \"decContext\"\t/* Short name */\n-#define DECCFULLNAME \"Decimal Context Descriptor\"\t/* Verbose name */\n-#define DECCAUTHOR   \"Mike Cowlishaw\"\t/* Who to blame */\n-\n-#include \"gstdint.h\"\t\t/* C99 standard integers */\n-#include <signal.h>\t\t/* for traps */\n-\n-\n-  /* Conditional code flag -- set this to 0 for best performance */\n-#define DECSUBSET 0\t\t/* 1 to enable subset arithmetic */\n-\n-  /* Context for operations, with associated constants */\n-enum rounding\n-{\n-  DEC_ROUND_CEILING,\t\t/* round towards +infinity */\n-  DEC_ROUND_UP,\t\t\t/* round away from 0 */\n-  DEC_ROUND_HALF_UP,\t\t/* 0.5 rounds up */\n-  DEC_ROUND_HALF_EVEN,\t\t/* 0.5 rounds to nearest even */\n-  DEC_ROUND_HALF_DOWN,\t\t/* 0.5 rounds down */\n-  DEC_ROUND_DOWN,\t\t/* round towards 0 (truncate) */\n-  DEC_ROUND_FLOOR,\t\t/* round towards -infinity */\n-  DEC_ROUND_MAX\t\t\t/* enum must be less than this */\n-};\n-\n-typedef struct\n-{\n-  int32_t digits;\t\t/* working precision */\n-  int32_t emax;\t\t\t/* maximum positive exponent */\n-  int32_t emin;\t\t\t/* minimum negative exponent */\n-  enum rounding round;\t\t/* rounding mode */\n-  uint32_t traps;\t\t/* trap-enabler flags */\n-  uint32_t status;\t\t/* status flags */\n-  uint8_t clamp;\t\t/* flag: apply IEEE exponent clamp */\n-#if DECSUBSET\n-  uint8_t extended;\t\t/* flag: special-values allowed */\n-#endif\n-} decContext;\n-\n-  /* Maxima and Minima */\n-#define DEC_MAX_DIGITS 999999999\n-#define DEC_MIN_DIGITS         1\n-#define DEC_MAX_EMAX   999999999\n-#define DEC_MIN_EMAX           0\n-#define DEC_MAX_EMIN           0\n-#define DEC_MIN_EMIN  -999999999\n-\n-  /* Trap-enabler and Status flags (exceptional conditions), and their names */\n-  /* Top byte is reserved for internal use */\n-#define DEC_Conversion_syntax    0x00000001\n-#define DEC_Division_by_zero     0x00000002\n-#define DEC_Division_impossible  0x00000004\n-#define DEC_Division_undefined   0x00000008\n-#define DEC_Insufficient_storage 0x00000010\t/* [used if malloc fails] */\n-#define DEC_Inexact              0x00000020\n-#define DEC_Invalid_context      0x00000040\n-#define DEC_Invalid_operation    0x00000080\n-#if DECSUBSET\n-#define DEC_Lost_digits          0x00000100\n-#endif\n-#define DEC_Overflow             0x00000200\n-#define DEC_Clamped              0x00000400\n-#define DEC_Rounded              0x00000800\n-#define DEC_Subnormal            0x00001000\n-#define DEC_Underflow            0x00002000\n-\n-  /* IEEE 854 groupings for the flags */\n-  /* [DEC_Clamped, DEC_Lost_digits, DEC_Rounded, and DEC_Subnormal are */\n-  /* not in IEEE 854] */\n-#define DEC_IEEE_854_Division_by_zero  (DEC_Division_by_zero)\n-#if DECSUBSET\n-#define DEC_IEEE_854_Inexact           (DEC_Inexact | DEC_Lost_digits)\n-#else\n-#define DEC_IEEE_854_Inexact           (DEC_Inexact)\n-#endif\n-#define DEC_IEEE_854_Invalid_operation (DEC_Conversion_syntax |     \\\n-                                          DEC_Division_impossible |   \\\n-                                          DEC_Division_undefined |    \\\n-                                          DEC_Insufficient_storage |  \\\n-                                          DEC_Invalid_context |       \\\n-                                          DEC_Invalid_operation)\n-#define DEC_IEEE_854_Overflow          (DEC_Overflow)\n-#define DEC_IEEE_854_Underflow         (DEC_Underflow)\n-\n-  /* flags which are normally errors (results are qNaN, infinite, or 0) */\n-#define DEC_Errors (DEC_IEEE_854_Division_by_zero |                 \\\n-                      DEC_IEEE_854_Invalid_operation |                \\\n-                      DEC_IEEE_854_Overflow | DEC_IEEE_854_Underflow)\n-  /* flags which cause a result to become qNaN */\n-#define DEC_NaNs    DEC_IEEE_854_Invalid_operation\n-\n-  /* flags which are normally for information only (have finite results) */\n-#if DECSUBSET\n-#define DEC_Information (DEC_Clamped | DEC_Rounded | DEC_Inexact     \\\n-                          | DEC_Lost_digits)\n-#else\n-#define DEC_Information (DEC_Clamped | DEC_Rounded | DEC_Inexact)\n-#endif\n+  #define DECCONTEXT\n+  #define DECCNAME     \"decContext\"\t\t\t/* Short name */\n+  #define DECCFULLNAME \"Decimal Context Descriptor\"   /* Verbose name */\n+  #define DECCAUTHOR   \"Mike Cowlishaw\"\t\t      /* Who to blame */\n \n-  /* name strings for the exceptional conditions */\n-\n-#define DEC_Condition_CS \"Conversion syntax\"\n-#define DEC_Condition_DZ \"Division by zero\"\n-#define DEC_Condition_DI \"Division impossible\"\n-#define DEC_Condition_DU \"Division undefined\"\n-#define DEC_Condition_IE \"Inexact\"\n-#define DEC_Condition_IS \"Insufficient storage\"\n-#define DEC_Condition_IC \"Invalid context\"\n-#define DEC_Condition_IO \"Invalid operation\"\n-#if DECSUBSET\n-#define DEC_Condition_LD \"Lost digits\"\n-#endif\n-#define DEC_Condition_OV \"Overflow\"\n-#define DEC_Condition_PA \"Clamped\"\n-#define DEC_Condition_RO \"Rounded\"\n-#define DEC_Condition_SU \"Subnormal\"\n-#define DEC_Condition_UN \"Underflow\"\n-#define DEC_Condition_ZE \"No status\"\n-#define DEC_Condition_MU \"Multiple status\"\n-#define DEC_Condition_Length 21\t/* length of the longest string, */\n-\t\t\t\t   /* including terminator */\n-\n-  /* Initialization descriptors, used by decContextDefault */\n-#define DEC_INIT_BASE         0\n-#define DEC_INIT_DECIMAL32   32\n-#define DEC_INIT_DECIMAL64   64\n-#define DEC_INIT_DECIMAL128 128\n-\n-  /* decContext routines */\n-#ifdef IN_LIBGCC2\n-#define decContextDefault __decContextDefault\n-#define decContextSetStatus __decContextSetStatus\n-#define decContextStatusToString __decContextStatusToString\n-#define decContextSetStatusFromString __decContextSetStatusFromString\n-#endif\n-decContext *decContextDefault (decContext *, int32_t);\n-decContext *decContextSetStatus (decContext *, uint32_t);\n-const char *decContextStatusToString (const decContext *);\n-decContext *decContextSetStatusFromString (decContext *, const char *);\n+  #include \"gstdint.h\"\t\t   /* C99 standard integers\t      */\n+  #include <stdio.h>\t\t   /* for printf, etc.\t\t      */\n+  #include <signal.h>\t\t   /* for traps\t\t\t      */\n+\n+  /* Extended flags setting -- set this to 0 to use only IEEE flags   */\n+  #define DECEXTFLAG 1\t\t   /* 1=enable extended flags\t      */\n+\n+  /* Conditional code flag -- set this to 0 for best performance      */\n+  #define DECSUBSET  0\t\t   /* 1=enable subset arithmetic      */\n+\n+  /* Context for operations, with associated constants\t\t      */\n+  enum rounding {\n+    DEC_ROUND_CEILING,\t\t   /* round towards +infinity\t      */\n+    DEC_ROUND_UP,\t\t   /* round away from 0\t\t      */\n+    DEC_ROUND_HALF_UP,\t\t   /* 0.5 rounds up\t\t      */\n+    DEC_ROUND_HALF_EVEN,\t   /* 0.5 rounds to nearest even      */\n+    DEC_ROUND_HALF_DOWN,\t   /* 0.5 rounds down\t\t      */\n+    DEC_ROUND_DOWN,\t\t   /* round towards 0 (truncate)      */\n+    DEC_ROUND_FLOOR,\t\t   /* round towards -infinity\t      */\n+    DEC_ROUND_05UP,\t\t   /* round for reround\t\t      */\n+    DEC_ROUND_MAX\t\t   /* enum must be less than this     */\n+    };\n+  #define DEC_ROUND_DEFAULT DEC_ROUND_HALF_EVEN;\n+\n+  typedef struct {\n+    int32_t  digits;\t\t   /* working precision\t\t      */\n+    int32_t  emax;\t\t   /* maximum positive exponent\t      */\n+    int32_t  emin;\t\t   /* minimum negative exponent\t      */\n+    enum     rounding round;\t   /* rounding mode\t\t      */\n+    uint32_t traps;\t\t   /* trap-enabler flags\t      */\n+    uint32_t status;\t\t   /* status flags\t\t      */\n+    uint8_t  clamp;\t\t   /* flag: apply IEEE exponent clamp */\n+    #if DECSUBSET\n+    uint8_t  extended;\t\t   /* flag: special-values allowed    */\n+    #endif\n+    } decContext;\n+\n+  /* Maxima and Minima for context settings\t\t\t      */\n+  #define DEC_MAX_DIGITS 999999999\n+  #define DEC_MIN_DIGITS\t 1\n+  #define DEC_MAX_EMAX\t 999999999\n+  #define DEC_MIN_EMAX\t\t 0\n+  #define DEC_MAX_EMIN\t\t 0\n+  #define DEC_MIN_EMIN\t-999999999\n+  #define DEC_MAX_MATH\t    999999 /* max emax, etc., for math funcs. */\n+\n+  /* Classifications for decimal numbers, aligned with 754r (note     */\n+  /* that 'normal' and 'subnormal' are meaningful only with a\t      */\n+  /* decContext or a fixed size format).\t\t\t      */\n+  enum decClass {\n+    DEC_CLASS_SNAN,\n+    DEC_CLASS_QNAN,\n+    DEC_CLASS_NEG_INF,\n+    DEC_CLASS_NEG_NORMAL,\n+    DEC_CLASS_NEG_SUBNORMAL,\n+    DEC_CLASS_NEG_ZERO,\n+    DEC_CLASS_POS_ZERO,\n+    DEC_CLASS_POS_SUBNORMAL,\n+    DEC_CLASS_POS_NORMAL,\n+    DEC_CLASS_POS_INF\n+    };\n+  /* Strings for the decClasses */\n+  #define DEC_ClassString_SN  \"sNaN\"\n+  #define DEC_ClassString_QN  \"NaN\"\n+  #define DEC_ClassString_NI  \"-Infinity\"\n+  #define DEC_ClassString_NN  \"-Normal\"\n+  #define DEC_ClassString_NS  \"-Subnormal\"\n+  #define DEC_ClassString_NZ  \"-Zero\"\n+  #define DEC_ClassString_PZ  \"+Zero\"\n+  #define DEC_ClassString_PS  \"+Subnormal\"\n+  #define DEC_ClassString_PN  \"+Normal\"\n+  #define DEC_ClassString_PI  \"+Infinity\"\n+  #define DEC_ClassString_UN  \"Invalid\"\n+\n+  /* Trap-enabler and Status flags (exceptional conditions), and      */\n+  /* their names.  The top byte is reserved for internal use\t      */\n+  #if DECEXTFLAG\n+    /* Extended flags */\n+    #define DEC_Conversion_syntax    0x00000001\n+    #define DEC_Division_by_zero     0x00000002\n+    #define DEC_Division_impossible  0x00000004\n+    #define DEC_Division_undefined   0x00000008\n+    #define DEC_Insufficient_storage 0x00000010 /* [when malloc fails]\t*/\n+    #define DEC_Inexact\t\t     0x00000020\n+    #define DEC_Invalid_context\t     0x00000040\n+    #define DEC_Invalid_operation    0x00000080\n+    #if DECSUBSET\n+    #define DEC_Lost_digits\t     0x00000100\n+    #endif\n+    #define DEC_Overflow\t     0x00000200\n+    #define DEC_Clamped\t\t     0x00000400\n+    #define DEC_Rounded\t\t     0x00000800\n+    #define DEC_Subnormal\t     0x00001000\n+    #define DEC_Underflow\t     0x00002000\n+  #else\n+    /* IEEE flags only */\n+    #define DEC_Conversion_syntax    0x00000010\n+    #define DEC_Division_by_zero     0x00000002\n+    #define DEC_Division_impossible  0x00000010\n+    #define DEC_Division_undefined   0x00000010\n+    #define DEC_Insufficient_storage 0x00000010 /* [when malloc fails]\t*/\n+    #define DEC_Inexact\t\t     0x00000001\n+    #define DEC_Invalid_context\t     0x00000010\n+    #define DEC_Invalid_operation    0x00000010\n+    #if DECSUBSET\n+    #define DEC_Lost_digits\t     0x00000000\n+    #endif\n+    #define DEC_Overflow\t     0x00000008\n+    #define DEC_Clamped\t\t     0x00000000\n+    #define DEC_Rounded\t\t     0x00000000\n+    #define DEC_Subnormal\t     0x00000000\n+    #define DEC_Underflow\t     0x00000004\n+  #endif\n+\n+  /* IEEE 854 groupings for the flags\t\t\t\t      */\n+  /* [DEC_Clamped, DEC_Lost_digits, DEC_Rounded, and DEC_Subnormal    */\n+  /* are not in IEEE 854]\t\t\t\t\t      */\n+  #define DEC_IEEE_854_Division_by_zero\t (DEC_Division_by_zero)\n+  #if DECSUBSET\n+  #define DEC_IEEE_854_Inexact\t\t (DEC_Inexact | DEC_Lost_digits)\n+  #else\n+  #define DEC_IEEE_854_Inexact\t\t (DEC_Inexact)\n+  #endif\n+  #define DEC_IEEE_854_Invalid_operation (DEC_Conversion_syntax |     \\\n+\t\t\t\t\t  DEC_Division_impossible |   \\\n+\t\t\t\t\t  DEC_Division_undefined |    \\\n+\t\t\t\t\t  DEC_Insufficient_storage |  \\\n+\t\t\t\t\t  DEC_Invalid_context |\t      \\\n+\t\t\t\t\t  DEC_Invalid_operation)\n+  #define DEC_IEEE_854_Overflow\t\t (DEC_Overflow)\n+  #define DEC_IEEE_854_Underflow\t (DEC_Underflow)\n+\n+  /* flags which are normally errors (result is qNaN, infinite, or 0) */\n+  #define DEC_Errors (DEC_IEEE_854_Division_by_zero |\t\t      \\\n+\t\t      DEC_IEEE_854_Invalid_operation |\t\t      \\\n+\t\t      DEC_IEEE_854_Overflow | DEC_IEEE_854_Underflow)\n+  /* flags which cause a result to become qNaN\t\t\t      */\n+  #define DEC_NaNs    DEC_IEEE_854_Invalid_operation\n+\n+  /* flags which are normally for information only (finite results)   */\n+  #if DECSUBSET\n+  #define DEC_Information (DEC_Clamped | DEC_Rounded | DEC_Inexact    \\\n+\t\t\t  | DEC_Lost_digits)\n+  #else\n+  #define DEC_Information (DEC_Clamped | DEC_Rounded | DEC_Inexact)\n+  #endif\n+\n+  /* Name strings for the exceptional conditions\t\t      */\n+  #define DEC_Condition_CS \"Conversion syntax\"\n+  #define DEC_Condition_DZ \"Division by zero\"\n+  #define DEC_Condition_DI \"Division impossible\"\n+  #define DEC_Condition_DU \"Division undefined\"\n+  #define DEC_Condition_IE \"Inexact\"\n+  #define DEC_Condition_IS \"Insufficient storage\"\n+  #define DEC_Condition_IC \"Invalid context\"\n+  #define DEC_Condition_IO \"Invalid operation\"\n+  #if DECSUBSET\n+  #define DEC_Condition_LD \"Lost digits\"\n+  #endif\n+  #define DEC_Condition_OV \"Overflow\"\n+  #define DEC_Condition_PA \"Clamped\"\n+  #define DEC_Condition_RO \"Rounded\"\n+  #define DEC_Condition_SU \"Subnormal\"\n+  #define DEC_Condition_UN \"Underflow\"\n+  #define DEC_Condition_ZE \"No status\"\n+  #define DEC_Condition_MU \"Multiple status\"\n+  #define DEC_Condition_Length 21  /* length of the longest string,   */\n+\t\t\t\t   /* including terminator\t      */\n+\n+  /* Initialization descriptors, used by decContextDefault\t      */\n+  #define DEC_INIT_BASE\t\t0\n+  #define DEC_INIT_DECIMAL32   32\n+  #define DEC_INIT_DECIMAL64   64\n+  #define DEC_INIT_DECIMAL128 128\n+  /* Synonyms */\n+  #define DEC_INIT_DECSINGLE  DEC_INIT_DECIMAL32\n+  #define DEC_INIT_DECDOUBLE  DEC_INIT_DECIMAL64\n+  #define DEC_INIT_DECQUAD    DEC_INIT_DECIMAL128\n+\n+  /* decContext routines\t\t\t\t\t      */\n+\n+  #include \"decContextSymbols.h\"\n+\n+  extern decContext  * decContextClearStatus(decContext *, uint32_t);\n+  extern decContext  * decContextDefault(decContext *, int32_t);\n+  extern enum rounding decContextGetRounding(decContext *);\n+  extern uint32_t      decContextGetStatus(decContext *);\n+  extern decContext  * decContextRestoreStatus(decContext *, uint32_t, uint32_t);\n+  extern uint32_t      decContextSaveStatus(decContext *, uint32_t);\n+  extern decContext  * decContextSetRounding(decContext *, enum rounding);\n+  extern decContext  * decContextSetStatus(decContext *, uint32_t);\n+  extern decContext  * decContextSetStatusFromString(decContext *, const char *);\n+  extern decContext  * decContextSetStatusFromStringQuiet(decContext *, const char *);\n+  extern decContext  * decContextSetStatusQuiet(decContext *, uint32_t);\n+  extern const char  * decContextStatusToString(const decContext *);\n+  extern uint32_t      decContextTestSavedStatus(uint32_t, uint32_t);\n+  extern uint32_t      decContextTestStatus(decContext *, uint32_t);\n+  extern decContext  * decContextZeroStatus(decContext *);\n \n #endif"}, {"sha": "38830a916dc397eb846abbd403c467a7037cc59f", "filename": "libdecnumber/decContextSymbols.h", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FdecContextSymbols.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FdecContextSymbols.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecContextSymbols.h?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb", "patch": "@@ -0,0 +1,22 @@\n+#if !defined(DECCONTEXTSYMBOLS)\n+#define DECCONTEXTSYMBOLS\n+\n+#ifdef IN_LIBGCC2\n+#define decContextClearStatus __decContextClearStatus\n+#define decContextDefault __decContextDefault\n+#define decContextGetRounding __decContextGetRounding\n+#define decContextGetStatus __decContextGetStatus\n+#define decContextRestoreStatus __decContextRestoreStatus\n+#define decContextSaveStatus __decContextSaveStatus\n+#define decContextSetRounding __decContextSetRounding\n+#define decContextSetStatus __decContextSetStatus\n+#define decContextSetStatusFromString __decContextSetStatusFromString\n+#define decContextSetStatusFromStringQuiet __decContextSetStatusFromStringQuiet\n+#define decContextSetStatusQuiet __decContextSetStatusQuiet\n+#define decContextStatusToString __decContextStatusToString\n+#define decContextTestSavedStatus __decContextTestSavedStatus\n+#define decContextTestStatus __decContextTestStatus\n+#define decContextZeroStatus __decContextZeroStatus\n+#endif\n+\n+#endif"}, {"sha": "8e0347c6aa85f6413e9a0b05c65339389a67e01f", "filename": "libdecnumber/decDPD.h", "status": "modified", "additions": 1171, "deletions": 491, "changes": 1662, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FdecDPD.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FdecDPD.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecDPD.h?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb"}, {"sha": "ba6a0af893be07ab5147357303e8d69c231df21d", "filename": "libdecnumber/decDouble.c", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FdecDouble.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FdecDouble.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecDouble.c?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb", "patch": "@@ -0,0 +1,154 @@\n+/* decDouble module for the decNumber C Library.\n+   Copyright (C) 2007 Free Software Foundation, Inc.\n+   Contributed by IBM Corporation.  Author Mike Cowlishaw.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 2, or (at your option) any later\n+   version.\n+\n+   In addition to the permissions in the GNU General Public License,\n+   the Free Software Foundation gives you unlimited permission to link\n+   the compiled version of this file into combinations with other\n+   programs, and to distribute those combinations without any\n+   restriction coming from the use of this file.  (The General Public\n+   License restrictions do apply in other respects; for example, they\n+   cover modification of the file, and distribution when not linked\n+   into a combine executable.)\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+   02110-1301, USA.  */\n+\n+/* ------------------------------------------------------------------ */\n+/* decDouble.c -- decDouble operations module\t\t\t      */\n+/* ------------------------------------------------------------------ */\n+/* This module comprises decDouble operations (including conversions) */\n+/* ------------------------------------------------------------------ */\n+\n+#include \"decContext.h\"\t      /* public includes */\n+#include \"decDouble.h\"\t      /* .. */\n+\n+/* Constant mappings for shared code */\n+#define DECPMAX\t    DECDOUBLE_Pmax\n+#define DECEMIN\t    DECDOUBLE_Emin\n+#define DECEMAX\t    DECDOUBLE_Emax\n+#define DECEMAXD    DECDOUBLE_EmaxD\n+#define DECBYTES    DECDOUBLE_Bytes\n+#define DECSTRING   DECDOUBLE_String\n+#define DECECONL    DECDOUBLE_EconL\n+#define DECBIAS\t    DECDOUBLE_Bias\n+#define DECLETS\t    DECDOUBLE_Declets\n+#define DECQTINY    (-DECDOUBLE_Bias)\n+/* parameters of next-wider format */\n+#define DECWBYTES   DECQUAD_Bytes\n+#define DECWPMAX    DECQUAD_Pmax\n+#define DECWECONL   DECQUAD_EconL\n+#define DECWBIAS    DECQUAD_Bias\n+\n+/* Type and function mappings for shared code */\n+#define decFloat\t       decDouble\t  /* Type name */\n+#define decFloatWider\t       decQuad\t\t  /* Type name */\n+\n+/* Utilities and conversions (binary results, extractors, etc.) */\n+#define decFloatFromBCD\t\tdecDoubleFromBCD\n+#define decFloatFromInt32\tdecDoubleFromInt32\n+#define decFloatFromPacked\tdecDoubleFromPacked\n+#define decFloatFromString\tdecDoubleFromString\n+#define decFloatFromUInt32\tdecDoubleFromUInt32\n+#define decFloatFromWider\tdecDoubleFromWider\n+#define decFloatGetCoefficient\tdecDoubleGetCoefficient\n+#define decFloatGetExponent\tdecDoubleGetExponent\n+#define decFloatSetCoefficient\tdecDoubleSetCoefficient\n+#define decFloatSetExponent\tdecDoubleSetExponent\n+#define decFloatShow\t\tdecDoubleShow\n+#define decFloatToBCD\t\tdecDoubleToBCD\n+#define decFloatToEngString\tdecDoubleToEngString\n+#define decFloatToInt32\t\tdecDoubleToInt32\n+#define decFloatToInt32Exact\tdecDoubleToInt32Exact\n+#define decFloatToPacked\tdecDoubleToPacked\n+#define decFloatToString\tdecDoubleToString\n+#define decFloatToUInt32\tdecDoubleToUInt32\n+#define decFloatToUInt32Exact\tdecDoubleToUInt32Exact\n+#define decFloatToWider\t\tdecDoubleToWider\n+#define decFloatZero\t\tdecDoubleZero\n+\n+/* Computational (result is a decFloat) */\n+#define decFloatAbs\t\tdecDoubleAbs\n+#define decFloatAdd\t\tdecDoubleAdd\n+#define decFloatAnd\t\tdecDoubleAnd\n+#define decFloatDivide\t\tdecDoubleDivide\n+#define decFloatDivideInteger\tdecDoubleDivideInteger\n+#define decFloatFMA\t\tdecDoubleFMA\n+#define decFloatInvert\t\tdecDoubleInvert\n+#define decFloatLogB\t\tdecDoubleLogB\n+#define decFloatMax\t\tdecDoubleMax\n+#define decFloatMaxMag\t\tdecDoubleMaxMag\n+#define decFloatMin\t\tdecDoubleMin\n+#define decFloatMinMag\t\tdecDoubleMinMag\n+#define decFloatMinus\t\tdecDoubleMinus\n+#define decFloatMultiply\tdecDoubleMultiply\n+#define decFloatNextMinus\tdecDoubleNextMinus\n+#define decFloatNextPlus\tdecDoubleNextPlus\n+#define decFloatNextToward\tdecDoubleNextToward\n+#define decFloatOr\t\tdecDoubleOr\n+#define decFloatPlus\t\tdecDoublePlus\n+#define decFloatQuantize\tdecDoubleQuantize\n+#define decFloatReduce\t\tdecDoubleReduce\n+#define decFloatRemainder\tdecDoubleRemainder\n+#define decFloatRemainderNear\tdecDoubleRemainderNear\n+#define decFloatRotate\t\tdecDoubleRotate\n+#define decFloatScaleB\t\tdecDoubleScaleB\n+#define decFloatShift\t\tdecDoubleShift\n+#define decFloatSubtract\tdecDoubleSubtract\n+#define decFloatToIntegralValue decDoubleToIntegralValue\n+#define decFloatToIntegralExact decDoubleToIntegralExact\n+#define decFloatXor\t\tdecDoubleXor\n+\n+/* Comparisons */\n+#define decFloatCompare\t\tdecDoubleCompare\n+#define decFloatCompareSignal\tdecDoubleCompareSignal\n+#define decFloatCompareTotal\tdecDoubleCompareTotal\n+#define decFloatCompareTotalMag decDoubleCompareTotalMag\n+\n+/* Copies */\n+#define decFloatCanonical\tdecDoubleCanonical\n+#define decFloatCopy\t\tdecDoubleCopy\n+#define decFloatCopyAbs\t\tdecDoubleCopyAbs\n+#define decFloatCopyNegate\tdecDoubleCopyNegate\n+#define decFloatCopySign\tdecDoubleCopySign\n+\n+/* Non-computational */\n+#define decFloatClass\t\tdecDoubleClass\n+#define decFloatClassString\tdecDoubleClassString\n+#define decFloatDigits\t\tdecDoubleDigits\n+#define decFloatIsCanonical\tdecDoubleIsCanonical\n+#define decFloatIsFinite\tdecDoubleIsFinite\n+#define decFloatIsInfinite\tdecDoubleIsInfinite\n+#define decFloatIsInteger\tdecDoubleIsInteger\n+#define decFloatIsNaN\t\tdecDoubleIsNaN\n+#define decFloatIsNormal\tdecDoubleIsNormal\n+#define decFloatIsSignaling\tdecDoubleIsSignaling\n+#define decFloatIsSignalling\tdecDoubleIsSignalling\n+#define decFloatIsSigned\tdecDoubleIsSigned\n+#define decFloatIsSubnormal\tdecDoubleIsSubnormal\n+#define decFloatIsZero\t\tdecDoubleIsZero\n+#define decFloatRadix\t\tdecDoubleRadix\n+#define decFloatSameQuantum\tdecDoubleSameQuantum\n+#define decFloatVersion\t\tdecDoubleVersion\n+\n+\n+#include \"decNumberLocal.h\"   /* local includes (need DECPMAX) */\n+#include \"decCommon.c\"\t      /* non-arithmetic decFloat routines */\n+#include \"decBasic.c\"\t      /* basic formats routines */\n+\n+/* Below here will move to shared file as completed */\n+"}, {"sha": "32eba395d8570d777d228f2b05cd3c49f445d1ac", "filename": "libdecnumber/decDouble.h", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FdecDouble.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FdecDouble.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecDouble.h?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb", "patch": "@@ -0,0 +1,164 @@\n+/* decDouble module header for the decNumber C Library.\n+   Copyright (C) 2007 Free Software Foundation, Inc.\n+   Contributed by IBM Corporation.  Author Mike Cowlishaw.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 2, or (at your option) any later\n+   version.\n+\n+   In addition to the permissions in the GNU General Public License,\n+   the Free Software Foundation gives you unlimited permission to link\n+   the compiled version of this file into combinations with other\n+   programs, and to distribute those combinations without any\n+   restriction coming from the use of this file.  (The General Public\n+   License restrictions do apply in other respects; for example, they\n+   cover modification of the file, and distribution when not linked\n+   into a combine executable.)\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+   02110-1301, USA.  */\n+\n+/* ------------------------------------------------------------------ */\n+/* decDouble.h -- Decimal 64-bit format module header\t\t      */\n+/* ------------------------------------------------------------------ */\n+/* Please see decFloats.h for an overview and documentation details.  */\n+/* ------------------------------------------------------------------ */\n+\n+#if !defined(DECDOUBLE)\n+  #define DECDOUBLE\n+\n+  #define DECDOUBLENAME\t      \"decimalDouble\"\t      /* Short name   */\n+  #define DECDOUBLETITLE      \"Decimal 64-bit datum\"  /* Verbose name */\n+  #define DECDOUBLEAUTHOR     \"Mike Cowlishaw\"\t      /* Who to blame */\n+\n+  /* parameters for decDoubles */\n+  #define DECDOUBLE_Bytes   8\t   /* length\t\t\t      */\n+  #define DECDOUBLE_Pmax    16\t   /* maximum precision (digits)      */\n+  #define DECDOUBLE_Emin   -383\t   /* minimum adjusted exponent\t      */\n+  #define DECDOUBLE_Emax    384\t   /* maximum adjusted exponent\t      */\n+  #define DECDOUBLE_EmaxD   3\t   /* maximum exponent digits\t      */\n+  #define DECDOUBLE_Bias    398\t   /* bias for the exponent\t      */\n+  #define DECDOUBLE_String  25\t   /* maximum string length, +1\t      */\n+  #define DECDOUBLE_EconL   8\t   /* exponent continuation length    */\n+  #define DECDOUBLE_Declets 5\t   /* count of declets\t\t      */\n+  /* highest biased exponent (Elimit-1) */\n+  #define DECDOUBLE_Ehigh (DECDOUBLE_Emax + DECDOUBLE_Bias - (DECDOUBLE_Pmax-1))\n+\n+  /* Required includes\t\t\t\t\t\t      */\n+  #include \"decContext.h\"\n+  #include \"decQuad.h\"\n+\n+  /* The decDouble decimal 64-bit type, accessible by bytes */\n+  typedef struct {\n+    uint8_t bytes[DECDOUBLE_Bytes]; /* fields: 1, 5, 8, 50 bits\t  */\n+    } decDouble;\n+\n+  /* ---------------------------------------------------------------- */\n+  /* Routines -- implemented as decFloat routines in common files     */\n+  /* ---------------------------------------------------------------- */\n+\n+  #include \"decDoubleSymbols.h\"\n+\n+  /* Utilities and conversions, extractors, etc.) */\n+  extern decDouble * decDoubleFromBCD(decDouble *, int32_t, const uint8_t *, int32_t);\n+  extern decDouble * decDoubleFromInt32(decDouble *, int32_t);\n+  extern decDouble * decDoubleFromPacked(decDouble *, int32_t, const uint8_t *);\n+  extern decDouble * decDoubleFromString(decDouble *, const char *, decContext *);\n+  extern decDouble * decDoubleFromUInt32(decDouble *, uint32_t);\n+  extern decDouble * decDoubleFromWider(decDouble *, const decQuad *, decContext *);\n+  extern int32_t     decDoubleGetCoefficient(const decDouble *, uint8_t *);\n+  extern int32_t     decDoubleGetExponent(const decDouble *);\n+  extern decDouble * decDoubleSetCoefficient(decDouble *, const uint8_t *, int32_t);\n+  extern decDouble * decDoubleSetExponent(decDouble *, decContext *, int32_t);\n+  extern void\t     decDoubleShow(const decDouble *, const char *);\n+  extern int32_t     decDoubleToBCD(const decDouble *, int32_t *, uint8_t *);\n+  extern char\t   * decDoubleToEngString(const decDouble *, char *);\n+  extern int32_t     decDoubleToInt32(const decDouble *, decContext *, enum rounding);\n+  extern int32_t     decDoubleToInt32Exact(const decDouble *, decContext *, enum rounding);\n+  extern int32_t     decDoubleToPacked(const decDouble *, int32_t *, uint8_t *);\n+  extern char\t   * decDoubleToString(const decDouble *, char *);\n+  extern uint32_t    decDoubleToUInt32(const decDouble *, decContext *, enum rounding);\n+  extern uint32_t    decDoubleToUInt32Exact(const decDouble *, decContext *, enum rounding);\n+  extern decQuad   * decDoubleToWider(const decDouble *, decQuad *);\n+  extern decDouble * decDoubleZero(decDouble *);\n+\n+  /* Computational (result is a decDouble) */\n+  extern decDouble * decDoubleAbs(decDouble *, const decDouble *, decContext *);\n+  extern decDouble * decDoubleAdd(decDouble *, const decDouble *, const decDouble *, decContext *);\n+  extern decDouble * decDoubleAnd(decDouble *, const decDouble *, const decDouble *, decContext *);\n+  extern decDouble * decDoubleDivide(decDouble *, const decDouble *, const decDouble *, decContext *);\n+  extern decDouble * decDoubleDivideInteger(decDouble *, const decDouble *, const decDouble *, decContext *);\n+  extern decDouble * decDoubleFMA(decDouble *, const decDouble *, const decDouble *, const decDouble *, decContext *);\n+  extern decDouble * decDoubleInvert(decDouble *, const decDouble *, decContext *);\n+  extern decDouble * decDoubleLogB(decDouble *, const decDouble *, decContext *);\n+  extern decDouble * decDoubleMax(decDouble *, const decDouble *, const decDouble *, decContext *);\n+  extern decDouble * decDoubleMaxMag(decDouble *, const decDouble *, const decDouble *, decContext *);\n+  extern decDouble * decDoubleMin(decDouble *, const decDouble *, const decDouble *, decContext *);\n+  extern decDouble * decDoubleMinMag(decDouble *, const decDouble *, const decDouble *, decContext *);\n+  extern decDouble * decDoubleMinus(decDouble *, const decDouble *, decContext *);\n+  extern decDouble * decDoubleMultiply(decDouble *, const decDouble *, const decDouble *, decContext *);\n+  extern decDouble * decDoubleNextMinus(decDouble *, const decDouble *, decContext *);\n+  extern decDouble * decDoubleNextPlus(decDouble *, const decDouble *, decContext *);\n+  extern decDouble * decDoubleNextToward(decDouble *, const decDouble *, const decDouble *, decContext *);\n+  extern decDouble * decDoubleOr(decDouble *, const decDouble *, const decDouble *, decContext *);\n+  extern decDouble * decDoublePlus(decDouble *, const decDouble *, decContext *);\n+  extern decDouble * decDoubleQuantize(decDouble *, const decDouble *, const decDouble *, decContext *);\n+  extern decDouble * decDoubleReduce(decDouble *, const decDouble *, decContext *);\n+  extern decDouble * decDoubleRemainder(decDouble *, const decDouble *, const decDouble *, decContext *);\n+  extern decDouble * decDoubleRemainderNear(decDouble *, const decDouble *, const decDouble *, decContext *);\n+  extern decDouble * decDoubleRotate(decDouble *, const decDouble *, const decDouble *, decContext *);\n+  extern decDouble * decDoubleScaleB(decDouble *, const decDouble *, const decDouble *, decContext *);\n+  extern decDouble * decDoubleShift(decDouble *, const decDouble *, const decDouble *, decContext *);\n+  extern decDouble * decDoubleSubtract(decDouble *, const decDouble *, const decDouble *, decContext *);\n+  extern decDouble * decDoubleToIntegralValue(decDouble *, const decDouble *, decContext *, enum rounding);\n+  extern decDouble * decDoubleToIntegralExact(decDouble *, const decDouble *, decContext *);\n+  extern decDouble * decDoubleXor(decDouble *, const decDouble *, const decDouble *, decContext *);\n+\n+  /* Comparisons */\n+  extern decDouble * decDoubleCompare(decDouble *, const decDouble *, const decDouble *, decContext *);\n+  extern decDouble * decDoubleCompareSignal(decDouble *, const decDouble *, const decDouble *, decContext *);\n+  extern decDouble * decDoubleCompareTotal(decDouble *, const decDouble *, const decDouble *);\n+  extern decDouble * decDoubleCompareTotalMag(decDouble *, const decDouble *, const decDouble *);\n+\n+  /* Copies */\n+  extern decDouble * decDoubleCanonical(decDouble *, const decDouble *);\n+  extern decDouble * decDoubleCopy(decDouble *, const decDouble *);\n+  extern decDouble * decDoubleCopyAbs(decDouble *, const decDouble *);\n+  extern decDouble * decDoubleCopyNegate(decDouble *, const decDouble *);\n+  extern decDouble * decDoubleCopySign(decDouble *, const decDouble *, const decDouble *);\n+\n+  /* Non-computational */\n+  extern enum decClass decDoubleClass(const decDouble *);\n+  extern const char *  decDoubleClassString(const decDouble *);\n+  extern uint32_t      decDoubleDigits(const decDouble *);\n+  extern uint32_t      decDoubleIsCanonical(const decDouble *);\n+  extern uint32_t      decDoubleIsFinite(const decDouble *);\n+  extern uint32_t      decDoubleIsInfinite(const decDouble *);\n+  extern uint32_t      decDoubleIsInteger(const decDouble *);\n+  extern uint32_t      decDoubleIsNaN(const decDouble *);\n+  extern uint32_t      decDoubleIsNormal(const decDouble *);\n+  extern uint32_t      decDoubleIsSignaling(const decDouble *);\n+  extern uint32_t      decDoubleIsSignalling(const decDouble *);\n+  extern uint32_t      decDoubleIsSigned(const decDouble *);\n+  extern uint32_t      decDoubleIsSubnormal(const decDouble *);\n+  extern uint32_t      decDoubleIsZero(const decDouble *);\n+  extern uint32_t      decDoubleRadix(const decDouble *);\n+  extern uint32_t      decDoubleSameQuantum(const decDouble *, const decDouble *);\n+  extern const char *  decDoubleVersion(void);\n+\n+  /* decNumber conversions; these are implemented as macros so as not  */\n+  /* to force a dependency on decimal64 and decNumber in decDouble.    */\n+  #define decDoubleToNumber(dq, dn) decimal64ToNumber((decimal64 *)(dq), dn)\n+  #define decDoubleFromNumber(dq, dn, set) (decDouble *)decimal64FromNumber((decimal64 *)(dq), dn, set)\n+\n+#endif"}, {"sha": "add1248096d649a6f1cf67c353a83e7cdc8da697", "filename": "libdecnumber/decDoubleSymbols.h", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FdecDoubleSymbols.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FdecDoubleSymbols.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecDoubleSymbols.h?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb", "patch": "@@ -0,0 +1,84 @@\n+#if !defined(DECDOUBLESYMBOLS)\n+#define DECDOUBLESYMBOLS\n+\n+#ifdef IN_LIBGCC2\n+#define decDoubleAbs __decDoubleAbs\n+#define decDoubleAdd __decDoubleAdd\n+#define decDoubleAnd __decDoubleAnd\n+#define decDoubleCanonical __decDoubleCanonical\n+#define decDoubleClass __decDoubleClass\n+#define decDoubleClassString __decDoubleClassString\n+#define decDoubleCompare __decDoubleCompare\n+#define decDoubleCompareSignal __decDoubleCompareSignal\n+#define decDoubleCompareTotal __decDoubleCompareTotal\n+#define decDoubleCompareTotalMag __decDoubleCompareTotalMag\n+#define decDoubleCopy __decDoubleCopy\n+#define decDoubleCopyAbs __decDoubleCopyAbs\n+#define decDoubleCopyNegate __decDoubleCopyNegate\n+#define decDoubleCopySign __decDoubleCopySign\n+#define decDoubleDigits __decDoubleDigits\n+#define decDoubleDivide __decDoubleDivide\n+#define decDoubleDivideInteger __decDoubleDivideInteger\n+#define decDoubleFMA __decDoubleFMA\n+#define decDoubleFromBCD __decDoubleFromBCD\n+#define decDoubleFromInt32 __decDoubleFromInt32\n+#define decDoubleFromPacked __decDoubleFromPacked\n+#define decDoubleFromString __decDoubleFromString\n+#define decDoubleFromUInt32 __decDoubleFromUInt32\n+#define decDoubleFromWider __decDoubleFromWider\n+#define decDoubleGetCoefficient __decDoubleGetCoefficient\n+#define decDoubleGetExponent __decDoubleGetExponent\n+#define decDoubleInvert __decDoubleInvert\n+#define decDoubleIsCanonical __decDoubleIsCanonical\n+#define decDoubleIsFinite __decDoubleIsFinite\n+#define decDoubleIsInfinite __decDoubleIsInfinite\n+#define decDoubleIsInteger __decDoubleIsInteger\n+#define decDoubleIsNaN __decDoubleIsNaN\n+#define decDoubleIsNormal __decDoubleIsNormal\n+#define decDoubleIsSignaling __decDoubleIsSignaling\n+#define decDoubleIsSignalling __decDoubleIsSignalling\n+#define decDoubleIsSigned __decDoubleIsSigned\n+#define decDoubleIsSubnormal __decDoubleIsSubnormal\n+#define decDoubleIsZero __decDoubleIsZero\n+#define decDoubleLogB __decDoubleLogB\n+#define decDoubleMax __decDoubleMax\n+#define decDoubleMaxMag __decDoubleMaxMag\n+#define decDoubleMin __decDoubleMin\n+#define decDoubleMinMag __decDoubleMinMag\n+#define decDoubleMinus __decDoubleMinus\n+#define decDoubleMultiply __decDoubleMultiply\n+#define decDoubleNextMinus __decDoubleNextMinus\n+#define decDoubleNextPlus __decDoubleNextPlus\n+#define decDoubleNextToward __decDoubleNextToward\n+#define decDoubleOr __decDoubleOr\n+#define decDoublePlus __decDoublePlus\n+#define decDoubleQuantize __decDoubleQuantize\n+#define decDoubleRadix __decDoubleRadix\n+#define decDoubleReduce __decDoubleReduce\n+#define decDoubleRemainder __decDoubleRemainder\n+#define decDoubleRemainderNear __decDoubleRemainderNear\n+#define decDoubleRotate __decDoubleRotate\n+#define decDoubleSameQuantum __decDoubleSameQuantum\n+#define decDoubleScaleB __decDoubleScaleB\n+#define decDoubleSetCoefficient __decDoubleSetCoefficient\n+#define decDoubleSetExponent __decDoubleSetExponent\n+#define decDoubleShift __decDoubleShift\n+#define decDoubleShow __decDoubleShow\n+#define decDoubleSubtract __decDoubleSubtract\n+#define decDoubleToBCD __decDoubleToBCD\n+#define decDoubleToEngString __decDoubleToEngString\n+#define decDoubleToInt32 __decDoubleToInt32\n+#define decDoubleToInt32Exact __decDoubleToInt32Exact\n+#define decDoubleToIntegralExact __decDoubleToIntegralExact\n+#define decDoubleToIntegralValue __decDoubleToIntegralValue\n+#define decDoubleToPacked __decDoubleToPacked\n+#define decDoubleToString __decDoubleToString\n+#define decDoubleToUInt32 __decDoubleToUInt32\n+#define decDoubleToUInt32Exact __decDoubleToUInt32Exact\n+#define decDoubleToWider __decDoubleToWider\n+#define decDoubleVersion __decDoubleVersion\n+#define decDoubleXor __decDoubleXor\n+#define decDoubleZero __decDoubleZero\n+#endif\n+\n+#endif"}, {"sha": "7e5e928edc27977db4969403b271f89a1417db9d", "filename": "libdecnumber/decLibrary.c", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FdecLibrary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FdecLibrary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecLibrary.c?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb", "patch": "@@ -74,22 +74,3 @@ isinfd128 (_Decimal128 arg)\n   decimal128ToNumber (&d128, &dn);\n   return (decNumberIsInfinite (&dn));\n }\n-\n-uint32_t\n-__dec_byte_swap (uint32_t in)\n-{\n-  uint32_t out = 0;\n-  unsigned char *p = (unsigned char *) &out;\n-  union {\n-    uint32_t i;\n-    unsigned char b[4];\n-  } u;\n-\n-  u.i = in;\n-  p[0] = u.b[3];\n-  p[1] = u.b[2];\n-  p[2] = u.b[1];\n-  p[3] = u.b[0];\n-\n-  return out;\n-}"}, {"sha": "c5e223c812fea3e755700734025db06168cb7aa1", "filename": "libdecnumber/decNumber.c", "status": "modified", "additions": 7440, "deletions": 5281, "changes": 12721, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FdecNumber.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FdecNumber.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecNumber.c?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb"}, {"sha": "0a9fdced8b3f5bd829a20a1a476614d2d8592650", "filename": "libdecnumber/decNumber.h", "status": "modified", "additions": 166, "deletions": 160, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FdecNumber.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FdecNumber.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecNumber.h?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb", "patch": "@@ -1,5 +1,5 @@\n-/* Decimal Number module header for the decNumber C Library\n-   Copyright (C) 2005 Free Software Foundation, Inc.\n+/* Decimal number arithmetic module header for the decNumber C Library.\n+   Copyright (C) 2005, 2007 Free Software Foundation, Inc.\n    Contributed by IBM Corporation.  Author Mike Cowlishaw.\n \n    This file is part of GCC.\n@@ -28,167 +28,173 @@\n    Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    02110-1301, USA.  */\n \n-#if !defined(DECNUMBER)\n-#define DECNUMBER\n-#define DECNAME     \"decNumber\"\t/* Short name */\n-#define DECVERSION  \"decNumber 3.24\"\t/* Version [16 max.] */\n-#define DECFULLNAME \"Decimal Number Module\"\t/* Verbose name */\n-#define DECAUTHOR   \"Mike Cowlishaw\"\t/* Who to blame */\n-\n-#if !defined(DECCONTEXT)\n-#include \"decContext.h\"\n-#endif\n-\n-\n-  /* Bit settings for decNumber.bits */\n-#define DECNEG    0x80\t\t/* Sign; 1=negative, 0=positive or zero */\n-#define DECINF    0x40\t\t/* 1=Infinity */\n-#define DECNAN    0x20\t\t/* 1=NaN */\n-#define DECSNAN   0x10\t\t/* 1=sNaN */\n-  /* The remaining bits are reserved; they must be 0 */\n-#define DECSPECIAL (DECINF|DECNAN|DECSNAN)\t/* any special value */\n-\n-  /* DECNUMDIGITS is the default number of digits we can hold in the */\n-  /* structure.  If undefined, 1 is assumed and it is assumed that the */\n-  /* structure will be immediately followed by extra space (if */\n-  /* required).  DECNUMDIGITS is always >0. */\n-#if !defined(DECNUMDIGITS)\n-#define DECNUMDIGITS 1\n-#endif\n-\n+/* ------------------------------------------------------------------ */\n+/* Decimal Number arithmetic module header\t\t\t      */\n+/* ------------------------------------------------------------------ */\n \n-  /* Define the decNumber data structure.  The size and shape of the */\n-  /* units array in the structure is determined by the following */\n-  /* constant.  This must not be changed without recompiling the */\n+#if !defined(DECNUMBER)\n+  #define DECNUMBER\n+  #define DECNAME     \"decNumber\"\t\t\t/* Short name */\n+  #define DECFULLNAME \"Decimal Number Module\"\t      /* Verbose name */\n+  #define DECAUTHOR   \"Mike Cowlishaw\"\t\t      /* Who to blame */\n+\n+  #if !defined(DECCONTEXT)\n+    #include \"decContext.h\"\n+  #endif\n+\n+  /* Bit settings for decNumber.bits\t\t\t\t      */\n+  #define DECNEG    0x80      /* Sign; 1=negative, 0=positive or zero */\n+  #define DECINF    0x40      /* 1=Infinity\t\t\t      */\n+  #define DECNAN    0x20      /* 1=NaN\t\t\t\t      */\n+  #define DECSNAN   0x10      /* 1=sNaN\t\t\t\t      */\n+  /* The remaining bits are reserved; they must be 0\t\t      */\n+  #define DECSPECIAL (DECINF|DECNAN|DECSNAN) /* any special value     */\n+\n+  /* Define the decNumber data structure.  The size and shape of the  */\n+  /* units array in the structure is determined by the following      */\n+  /* constant.\tThis must not be changed without recompiling the      */\n   /* decNumber library modules. */\n-#define DECDPUN 4\t\t/* Decimal Digits Per UNit [must be in */\n-\t\t\t\t   /* range 1-9; power of 2 recommended]. */\n-  /* The size (integer data type) of each unit is determined by the */\n-  /* number of digits it will hold. */\n-#if   DECDPUN<=2\n-#define decNumberUnit uint8_t\n-#elif DECDPUN<=4\n-#define decNumberUnit uint16_t\n-#else\n-#define decNumberUnit uint32_t\n-#endif\n-  /* The number of decNumberUnits we need is ceiling of DECNUMDIGITS/DECDPUN */\n-#define DECNUMUNITS ((DECNUMDIGITS+DECDPUN-1)/DECDPUN)\n \n-  /* The data structure... */\n-typedef struct\n-{\n-  int32_t digits;\t\t/* Count of digits in the coefficient; >0 */\n-  int32_t exponent;\t\t/* Unadjusted exponent, unbiased, in */\n-  /* range: -1999999997 through 999999999 */\n-  uint8_t bits;\t\t\t/* Indicator bits (see above) */\n-  decNumberUnit lsu[DECNUMUNITS];\t/* Coefficient, from least significant unit */\n-} decNumber;\n-\n-  /* Notes: */\n-  /* 1. If digits is > DECDPUN then there will be more than one */\n-  /*    decNumberUnits immediately following the first element of lsu. */\n-  /*    These contain the remaining (more significant) digits of the */\n-  /*    number, and may be in the lsu array, or may be guaranteed by */\n-  /*    some other mechanism (such as being contained in another */\n-  /*    structure, or being overlaid on dynamically allocated storage). */\n-  /* */\n-  /*    Each integer of the coefficient (except the possibly the last) */\n-  /*    contains DECDPUN digits (e.g., a value in the range 0 through */\n-  /*    99999999 if DECDPUN is 8, or 0 through 9999 if DECDPUN is 4). */\n-  /* */\n-  /* 2. A decNumber converted to a string may need up to digits+14 */\n-  /*    characters.  The worst cases (non-exponential and exponential */\n-  /*    formats) are: -0.00000{9...}# */\n-  /*             and: -9.{9...}E+999999999#   (where # is '\\0') */\n-\n-\n-  /* ------------------------------------------------------------------ */\n-  /* decNumber public functions and macros                              */\n-  /* ------------------------------------------------------------------ */\n-\n-#ifdef IN_LIBGCC2\n-#define decNumberFromString __decNumberFromString\n-#define decNumberToString __decNumberToString\n-#define decNumberToEngString __decNumberToEngString\n-#define decNumberAbs __decNumberAbs\n-#define decNumberAdd __decNumberAdd\n-#define decNumberCompare __decNumberCompare\n-#define decNumberDivide __decNumberDivide\n-#define decNumberDivideInteger __decNumberDivideInteger\n-#define decNumberMax __decNumberMax\n-#define decNumberMin __decNumberMin\n-#define decNumberMinus __decNumberMinus\n-#define decNumberMultiply __decNumberMultiply\n-#define decNumberNormalize __decNumberNormalize\n-#define decNumberPlus __decNumberPlus\n-#define decNumberPower __decNumberPower\n-#define decNumberQuantize __decNumberQuantize\n-#define decNumberRemainder __decNumberRemainder\n-#define decNumberRemainderNear __decNumberRemainderNear\n-#define decNumberRescale __decNumberRescale\n-#define decNumberSameQuantum __decNumberSameQuantum\n-#define decNumberSquareRoot __decNumberSquareRoot\n-#define decNumberSubtract __decNumberSubtract\n-#define decNumberToIntegralValue __decNumberToIntegralValue\n-#define decNumberCopy __decNumberCopy\n-#define decNumberTrim __decNumberTrim\n-#define decNumberVersion __decNumberVersion\n-#define decNumberZero __decNumberZero\n-#endif\n+  #define DECDPUN 3\t      /* DECimal Digits Per UNit [must be >0  */\n+\t\t\t      /* and <10; 3 or powers of 2 are best]. */\n+\n+  /* DECNUMDIGITS is the default number of digits that can be held in */\n+  /* the structure.  If undefined, 1 is assumed and it is assumed     */\n+  /* that the structure will be immediately followed by extra space,  */\n+  /* as required.  DECNUMDIGITS is always >0.\t\t\t      */\n+  #if !defined(DECNUMDIGITS)\n+    #define DECNUMDIGITS 1\n+  #endif\n+\n+  /* The size (integer data type) of each unit is determined by the   */\n+  /* number of digits it will hold.\t\t\t\t      */\n+  #if\tDECDPUN<=2\n+    #define decNumberUnit uint8_t\n+  #elif DECDPUN<=4\n+    #define decNumberUnit uint16_t\n+  #else\n+    #define decNumberUnit uint32_t\n+  #endif\n+  /* The number of units needed is ceil(DECNUMDIGITS/DECDPUN)\t      */\n+  #define DECNUMUNITS ((DECNUMDIGITS+DECDPUN-1)/DECDPUN)\n \n-  /* Conversions */\n-decNumber *decNumberFromString (decNumber *, const char *, decContext *);\n-char *decNumberToString (const decNumber *, char *);\n-char *decNumberToEngString (const decNumber *, char *);\n-\n-  /* Operators */\n-decNumber *decNumberAbs (decNumber *, const decNumber *, decContext *);\n-decNumber *decNumberAdd (decNumber *, const decNumber *,\n-\t\t\t const decNumber *, decContext *);\n-decNumber *decNumberCompare (decNumber *, const decNumber *,\n-\t\t\t     const decNumber *, decContext *);\n-decNumber *decNumberDivide (decNumber *, const decNumber *,\n-\t\t\t    const decNumber *, decContext *);\n-decNumber *decNumberDivideInteger (decNumber *, const decNumber *,\n-\t\t\t\t   const decNumber *, decContext *);\n-decNumber *decNumberMax (decNumber *, const decNumber *,\n-\t\t\t const decNumber *, decContext *);\n-decNumber *decNumberMin (decNumber *, const decNumber *,\n-\t\t\t const decNumber *, decContext *);\n-decNumber *decNumberMinus (decNumber *, const decNumber *, decContext *);\n-decNumber *decNumberMultiply (decNumber *, const decNumber *,\n-\t\t\t      const decNumber *, decContext *);\n-decNumber *decNumberNormalize (decNumber *, const decNumber *, decContext *);\n-decNumber *decNumberPlus (decNumber *, const decNumber *, decContext *);\n-decNumber *decNumberPower (decNumber *, const decNumber *,\n-\t\t\t   const decNumber *, decContext *);\n-decNumber *decNumberQuantize (decNumber *, const decNumber *,\n-\t\t\t      const decNumber *, decContext *);\n-decNumber *decNumberRemainder (decNumber *, const decNumber *,\n-\t\t\t       const decNumber *, decContext *);\n-decNumber *decNumberRemainderNear (decNumber *, const decNumber *,\n-\t\t\t\t   const decNumber *, decContext *);\n-decNumber *decNumberRescale (decNumber *, const decNumber *,\n-\t\t\t     const decNumber *, decContext *);\n-decNumber *decNumberSameQuantum (decNumber *, const decNumber *, const decNumber *);\n-decNumber *decNumberSquareRoot (decNumber *, const decNumber *, decContext *);\n-decNumber *decNumberSubtract (decNumber *, const decNumber *,\n-\t\t\t      const decNumber *, decContext *);\n-decNumber *decNumberToIntegralValue (decNumber *, const decNumber *, decContext *);\n-\n-  /* Utilities */\n-decNumber *decNumberCopy (decNumber *, const decNumber *);\n-decNumber *decNumberTrim (decNumber *);\n-const char *decNumberVersion (void);\n-decNumber *decNumberZero (decNumber *);\n-\n-  /* Macros */\n-#define decNumberIsZero(dn)     (*(dn)->lsu==0 \\\n-                                   && (dn)->digits==1 \\\n-                                   && (((dn)->bits&DECSPECIAL)==0))\n-#define decNumberIsNegative(dn) (((dn)->bits&DECNEG)!=0)\n-#define decNumberIsNaN(dn)      (((dn)->bits&(DECNAN|DECSNAN))!=0)\n-#define decNumberIsInfinite(dn) (((dn)->bits&DECINF)!=0)\n+  /* The data structure... */\n+  typedef struct {\n+    int32_t digits;\t /* Count of digits in the coefficient; >0    */\n+    int32_t exponent;\t /* Unadjusted exponent, unbiased, in\t      */\n+\t\t\t /* range: -1999999997 through 999999999      */\n+    uint8_t bits;\t /* Indicator bits (see above)\t\t      */\n+\t\t\t /* Coefficient, from least significant unit  */\n+    decNumberUnit lsu[DECNUMUNITS];\n+    } decNumber;\n+\n+  /* Notes:\t\t\t\t\t\t\t      */\n+  /* 1. If digits is > DECDPUN then there will one or more\t      */\n+  /*\tdecNumberUnits immediately following the first element of lsu.*/\n+  /*\tThese contain the remaining (more significant) digits of the  */\n+  /*\tnumber, and may be in the lsu array, or may be guaranteed by  */\n+  /*\tsome other mechanism (such as being contained in another      */\n+  /*\tstructure, or being overlaid on dynamically allocated\t      */\n+  /*\tstorage).\t\t\t\t\t\t      */\n+  /*\t\t\t\t\t\t\t\t      */\n+  /*\tEach integer of the coefficient (except potentially the last) */\n+  /*\tcontains DECDPUN digits (e.g., a value in the range 0 through */\n+  /*\t99999999 if DECDPUN is 8, or 0 through 999 if DECDPUN is 3).  */\n+  /*\t\t\t\t\t\t\t\t      */\n+  /* 2. A decNumber converted to a string may need up to digits+14    */\n+  /*\tcharacters.  The worst cases (non-exponential and exponential */\n+  /*\tformats) are -0.00000{9...}# and -9.{9...}E+999999999#\t      */\n+  /*\t(where # is '\\0')\t\t\t\t\t      */\n+\n+\n+  /* ---------------------------------------------------------------- */\n+  /* decNumber public functions and macros\t\t\t      */\n+  /* ---------------------------------------------------------------- */\n+\n+  #include \"decNumberSymbols.h\"\n+\n+  /* Conversions\t\t\t\t\t\t      */\n+  decNumber * decNumberFromInt32(decNumber *, int32_t);\n+  decNumber * decNumberFromUInt32(decNumber *, uint32_t);\n+  decNumber * decNumberFromString(decNumber *, const char *, decContext *);\n+  char\t    * decNumberToString(const decNumber *, char *);\n+  char\t    * decNumberToEngString(const decNumber *, char *);\n+  uint32_t    decNumberToUInt32(const decNumber *, decContext *);\n+  int32_t     decNumberToInt32(const decNumber *, decContext *);\n+  uint8_t   * decNumberGetBCD(const decNumber *, uint8_t *);\n+  decNumber * decNumberSetBCD(decNumber *, const uint8_t *, uint32_t);\n+\n+  /* Operators and elementary functions\t\t\t\t      */\n+  decNumber * decNumberAbs(decNumber *, const decNumber *, decContext *);\n+  decNumber * decNumberAdd(decNumber *, const decNumber *, const decNumber *, decContext *);\n+  decNumber * decNumberAnd(decNumber *, const decNumber *, const decNumber *, decContext *);\n+  decNumber * decNumberCompare(decNumber *, const decNumber *, const decNumber *, decContext *);\n+  decNumber * decNumberCompareSignal(decNumber *, const decNumber *, const decNumber *, decContext *);\n+  decNumber * decNumberCompareTotal(decNumber *, const decNumber *, const decNumber *, decContext *);\n+  decNumber * decNumberCompareTotalMag(decNumber *, const decNumber *, const decNumber *, decContext *);\n+  decNumber * decNumberDivide(decNumber *, const decNumber *, const decNumber *, decContext *);\n+  decNumber * decNumberDivideInteger(decNumber *, const decNumber *, const decNumber *, decContext *);\n+  decNumber * decNumberExp(decNumber *, const decNumber *, decContext *);\n+  decNumber * decNumberFMA(decNumber *, const decNumber *, const decNumber *, const decNumber *, decContext *);\n+  decNumber * decNumberInvert(decNumber *, const decNumber *, decContext *);\n+  decNumber * decNumberLn(decNumber *, const decNumber *, decContext *);\n+  decNumber * decNumberLogB(decNumber *, const decNumber *, decContext *);\n+  decNumber * decNumberLog10(decNumber *, const decNumber *, decContext *);\n+  decNumber * decNumberMax(decNumber *, const decNumber *, const decNumber *, decContext *);\n+  decNumber * decNumberMaxMag(decNumber *, const decNumber *, const decNumber *, decContext *);\n+  decNumber * decNumberMin(decNumber *, const decNumber *, const decNumber *, decContext *);\n+  decNumber * decNumberMinMag(decNumber *, const decNumber *, const decNumber *, decContext *);\n+  decNumber * decNumberMinus(decNumber *, const decNumber *, decContext *);\n+  decNumber * decNumberMultiply(decNumber *, const decNumber *, const decNumber *, decContext *);\n+  decNumber * decNumberNormalize(decNumber *, const decNumber *, decContext *);\n+  decNumber * decNumberOr(decNumber *, const decNumber *, const decNumber *, decContext *);\n+  decNumber * decNumberPlus(decNumber *, const decNumber *, decContext *);\n+  decNumber * decNumberPower(decNumber *, const decNumber *, const decNumber *, decContext *);\n+  decNumber * decNumberQuantize(decNumber *, const decNumber *, const decNumber *, decContext *);\n+  decNumber * decNumberReduce(decNumber *, const decNumber *, decContext *);\n+  decNumber * decNumberRemainder(decNumber *, const decNumber *, const decNumber *, decContext *);\n+  decNumber * decNumberRemainderNear(decNumber *, const decNumber *, const decNumber *, decContext *);\n+  decNumber * decNumberRescale(decNumber *, const decNumber *, const decNumber *, decContext *);\n+  decNumber * decNumberRotate(decNumber *, const decNumber *, const decNumber *, decContext *);\n+  decNumber * decNumberSameQuantum(decNumber *, const decNumber *, const decNumber *);\n+  decNumber * decNumberScaleB(decNumber *, const decNumber *, const decNumber *, decContext *);\n+  decNumber * decNumberShift(decNumber *, const decNumber *, const decNumber *, decContext *);\n+  decNumber * decNumberSquareRoot(decNumber *, const decNumber *, decContext *);\n+  decNumber * decNumberSubtract(decNumber *, const decNumber *, const decNumber *, decContext *);\n+  decNumber * decNumberToIntegralExact(decNumber *, const decNumber *, decContext *);\n+  decNumber * decNumberToIntegralValue(decNumber *, const decNumber *, decContext *);\n+  decNumber * decNumberXor(decNumber *, const decNumber *, const decNumber *, decContext *);\n+\n+  /* Utilities\t\t\t\t\t\t\t      */\n+  enum decClass decNumberClass(const decNumber *, decContext *);\n+  const char * decNumberClassToString(enum decClass);\n+  decNumber  * decNumberCopy(decNumber *, const decNumber *);\n+  decNumber  * decNumberCopyAbs(decNumber *, const decNumber *);\n+  decNumber  * decNumberCopyNegate(decNumber *, const decNumber *);\n+  decNumber  * decNumberCopySign(decNumber *, const decNumber *, const decNumber *);\n+  decNumber  * decNumberNextMinus(decNumber *, const decNumber *, decContext *);\n+  decNumber  * decNumberNextPlus(decNumber *, const decNumber *, decContext *);\n+  decNumber  * decNumberNextToward(decNumber *, const decNumber *, const decNumber *, decContext *);\n+  decNumber  * decNumberTrim(decNumber *);\n+  const char * decNumberVersion(void);\n+  decNumber  * decNumberZero(decNumber *);\n+\n+  /* Functions for testing decNumbers (normality depends on context)  */\n+  int32_t decNumberIsNormal(const decNumber *, decContext *);\n+  int32_t decNumberIsSubnormal(const decNumber *, decContext *);\n+\n+  /* Macros for testing decNumber *dn\t\t\t\t      */\n+  #define decNumberIsCanonical(dn) (1)\t/* All decNumbers are saintly */\n+  #define decNumberIsFinite(dn)\t   (((dn)->bits&DECSPECIAL)==0)\n+  #define decNumberIsInfinite(dn)  (((dn)->bits&DECINF)!=0)\n+  #define decNumberIsNaN(dn)\t   (((dn)->bits&(DECNAN|DECSNAN))!=0)\n+  #define decNumberIsNegative(dn)  (((dn)->bits&DECNEG)!=0)\n+  #define decNumberIsQNaN(dn)\t   (((dn)->bits&(DECNAN))!=0)\n+  #define decNumberIsSNaN(dn)\t   (((dn)->bits&(DECSNAN))!=0)\n+  #define decNumberIsSpecial(dn)   (((dn)->bits&DECSPECIAL)!=0)\n+  #define decNumberIsZero(dn)\t   (*(dn)->lsu==0 \\\n+\t\t\t\t    && (dn)->digits==1 \\\n+\t\t\t\t    && (((dn)->bits&DECSPECIAL)==0))\n+  #define decNumberRadix(dn)\t   (10)\n \n #endif"}, {"sha": "891a0841c894edae4df4f62898c5a1eb3678a31a", "filename": "libdecnumber/decNumberLocal.h", "status": "modified", "additions": 623, "deletions": 94, "changes": 717, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FdecNumberLocal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FdecNumberLocal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecNumberLocal.h?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb", "patch": "@@ -1,5 +1,5 @@\n-/* decNumber package local type, tuning, and macro definitions.\n-   Copyright (C) 2005 Free Software Foundation, Inc.\n+/* Local definitions for the decNumber C Library.\n+   Copyright (C) 2007 Free Software Foundation, Inc.\n    Contributed by IBM Corporation.  Author Mike Cowlishaw.\n \n    This file is part of GCC.\n@@ -29,108 +29,637 @@\n    02110-1301, USA.  */\n \n /* ------------------------------------------------------------------ */\n-/* This header file is included by all modules in the decNumber       */\n+/* decNumber package local type, tuning, and macro definitions\t      */\n+/* ------------------------------------------------------------------ */\n+/* This header file is included by all modules in the decNumber\t      */\n /* library, and contains local type definitions, tuning parameters,   */\n-/* etc.  It must only be included once, and should not need to be     */\n-/* used by application programs.  decNumber.h must be included first. */\n+/* etc.\t It should not need to be used by application programs.\t      */\n+/* decNumber.h or one of decDouble (etc.) must be included first.     */\n /* ------------------------------------------------------------------ */\n \n #if !defined(DECNUMBERLOC)\n-#define DECNUMBERLOC\n-#define DECNLAUTHOR   \"Mike Cowlishaw\"\t/* Who to blame */\n-\n-  /* Local names for common types -- decNumber modules do not use int or\n-     long directly */\n-#define Flag   uint8_t\n-#define Byte   int8_t\n-#define uByte  uint8_t\n-#define Short  int16_t\n-#define uShort uint16_t\n-#define Int    int32_t\n-#define uInt   uint32_t\n-#define Unit   decNumberUnit\n-\n-\n-  /* Tuning parameter */\n-#define DECBUFFER 36\t\t/* Maximum size basis for local buffers. */\n-\t\t\t      /* Should be a common maximum precision */\n-\t\t\t      /* rounded up to a multiple of 4; must */\n-\t\t\t      /* be non-negative. */\n-\n-  /* Conditional code flags -- set these to 0 for best performance */\n-#define DECCHECK  0\t\t/* 1 to enable robust checking */\n-#define DECALLOC  0\t\t/* 1 to enable memory allocation accounting */\n-#define DECTRACE  0\t\t/* 1 to trace critical intermediates, etc. */\n-\n-\n-  /* Development use defines */\n-#if DECALLOC\n-     /* if these interfere with your C includes, just comment them out */\n-#define  int ?\t\t\t/* enable to ensure we do not use plain C */\n-#define  long ??\t\t/* .. 'int' or 'long' types from here on */\n-#endif\n+  #define DECNUMBERLOC\n+  #define DECVERSION\t\"decNumber 3.53\" /* Package Version [16 max.] */\n+  #define DECNLAUTHOR\t\"Mike Cowlishaw\"\t      /* Who to blame */\n \n-  /* Limits and constants */\n-#define DECNUMMAXP 999999999\t/* maximum precision we can handle (9 digits) */\n-#define DECNUMMAXE 999999999\t/* maximum adjusted exponent ditto (9 digits) */\n-#define DECNUMMINE -999999999\t/* minimum adjusted exponent ditto (9 digits) */\n-#if (DECNUMMAXP != DEC_MAX_DIGITS)\n-#error Maximum digits mismatch\n-#endif\n-#if (DECNUMMAXE != DEC_MAX_EMAX)\n-#error Maximum exponent mismatch\n-#endif\n-#if (DECNUMMINE != DEC_MIN_EMIN)\n-#error Minimum exponent mismatch\n-#endif\n+  #include <stdlib.h>\t      /* for abs\t\t\t      */\n+  #include <string.h>\t      /* for memset, strcpy\t\t      */\n+  #include \"config.h\"\t      /* for WORDS_BIGENDIAN                  */\n \n-  /* Set DECDPUNMAX -- the maximum integer that fits in DECDPUN digits */\n-#if   DECDPUN==1\n-#define DECDPUNMAX 9\n-#elif DECDPUN==2\n-#define DECDPUNMAX 99\n-#elif DECDPUN==3\n-#define DECDPUNMAX 999\n-#elif DECDPUN==4\n-#define DECDPUNMAX 9999\n-#elif DECDPUN==5\n-#define DECDPUNMAX 99999\n-#elif DECDPUN==6\n-#define DECDPUNMAX 999999\n-#elif DECDPUN==7\n-#define DECDPUNMAX 9999999\n-#elif DECDPUN==8\n-#define DECDPUNMAX 99999999\n-#elif DECDPUN==9\n-#define DECDPUNMAX 999999999\n-#elif defined(DECDPUN)\n-#error DECDPUN must be in the range 1-9\n-#endif\n+  /* Conditional code flag -- set this to match hardware platform     */\n+  /* 1=little-endian, 0=big-endian\t                              */\n+  #if WORDS_BIGENDIAN\n+  #define DECLITEND 0\n+  #else\n+  #define DECLITEND 1\n+  #endif\n+\n+  /* Conditional code flag -- set this to 1 for best performance      */\n+  #define DECUSE64  1\t      /* 1=use int64s, 0=int32 & smaller only */\n+\n+  /* Conditional check flags -- set these to 0 for best performance   */\n+  #define DECCHECK  0\t      /* 1 to enable robust checking\t      */\n+  #define DECALLOC  0\t      /* 1 to enable memory accounting\t      */\n+  #define DECTRACE  0\t      /* 1 to trace certain internals, etc.   */\n+\n+  /* Tuning parameter for decNumber (arbitrary precision) module      */\n+  #define DECBUFFER 36\t      /* Size basis for local buffers.\tThis  */\n+\t\t\t      /* should be a common maximum precision */\n+\t\t\t      /* rounded up to a multiple of 4; must  */\n+\t\t\t      /* be zero or positive.\t\t      */\n+\n+  /* ---------------------------------------------------------------- */\n+  /* Definitions for all modules (general-purpose)\t\t      */\n+  /* ---------------------------------------------------------------- */\n+\n+  /* Local names for common types -- for safety, decNumber modules do */\n+  /* not use int or long directly.\t\t\t\t      */\n+  #define Flag\t uint8_t\n+  #define Byte\t int8_t\n+  #define uByte\t uint8_t\n+  #define Short\t int16_t\n+  #define uShort uint16_t\n+  #define Int\t int32_t\n+  #define uInt\t uint32_t\n+  #define Unit\t decNumberUnit\n+  #if DECUSE64\n+  #define Long\t int64_t\n+  #define uLong\t uint64_t\n+  #endif\n+\n+  /* Development-use definitions\t\t\t\t      */\n+  typedef long int LI;\t      /* for printf arguments only\t      */\n+  #define DECNOINT  0\t      /* 1 to check no internal use of 'int'  */\n+  #if DECNOINT\n+    /* if these interfere with your C includes, do not set DECNOINT   */\n+    #define  int ?\t      /* enable to ensure that plain C 'int'  */\n+    #define  long ??\t      /* .. or 'long' types are not used      */\n+  #endif\n+\n+  /* Shared lookup tables\t\t\t\t\t      */\n+  extern const uByte  DECSTICKYTAB[10]; /* re-round digits if sticky  */\n+  extern const uInt   DECPOWERS[10];\t/* powers of ten table\t      */\n+  /* The following are included from decDPD.h\t\t\t      */\n+  extern const uShort DPD2BIN[1024];\t/* DPD -> 0-999\t\t      */\n+  extern const uShort BIN2DPD[1000];\t/* 0-999 -> DPD\t\t      */\n+  extern const uInt   DPD2BINK[1024];\t/* DPD -> 0-999000\t      */\n+  extern const uInt   DPD2BINM[1024];\t/* DPD -> 0-999000000\t      */\n+  extern const uByte  DPD2BCD8[4096];\t/* DPD -> ddd + len\t      */\n+  extern const uByte  BIN2BCD8[4000];\t/* 0-999 -> ddd + len\t      */\n+  extern const uShort BCD2DPD[2458];\t/* 0-0x999 -> DPD (0x999=2457)*/\n+\n+  /* LONGMUL32HI -- set w=(u*v)>>32, where w, u, and v are uInts      */\n+  /* (that is, sets w to be the high-order word of the 64-bit result; */\n+  /* the low-order word is simply u*v.)\t\t\t\t      */\n+  /* This version is derived from Knuth via Hacker's Delight;\t      */\n+  /* it seems to optimize better than some others tried\t\t      */\n+  #define LONGMUL32HI(w, u, v) {\t     \\\n+    uInt u0, u1, v0, v1, w0, w1, w2, t;\t     \\\n+    u0=u & 0xffff; u1=u>>16;\t\t     \\\n+    v0=v & 0xffff; v1=v>>16;\t\t     \\\n+    w0=u0*v0;\t\t\t\t     \\\n+    t=u1*v0 + (w0>>16);\t\t\t     \\\n+    w1=t & 0xffff; w2=t>>16;\t\t     \\\n+    w1=u0*v1 + w1;\t\t\t     \\\n+    (w)=u1*v1 + w2 + (w1>>16);}\n+\n+  /* ROUNDUP -- round an integer up to a multiple of n\t\t      */\n+  #define ROUNDUP(i, n) ((((i)+(n)-1)/n)*n)\n+\n+  /* ROUNDDOWN -- round an integer down to a multiple of n\t      */\n+  #define ROUNDDOWN(i, n) (((i)/n)*n)\n+  #define ROUNDDOWN4(i)\t  ((i)&~3)\t/* special for n=4\t      */\n+\n+  /* References to multi-byte sequences under different sizes\t      */\n+  /* Refer to a uInt from four bytes starting at a char* or uByte*,   */\n+  /* etc.\t\t\t\t\t\t\t      */\n+  #define UINTAT(b)   (*((uInt\t *)(b)))\n+  #define USHORTAT(b) (*((uShort *)(b)))\n+  #define UBYTEAT(b)  (*((uByte\t *)(b)))\n \n+  /* X10 and X100 -- multiply integer i by 10 or 100\t\t      */\n+  /* [shifts are usually faster than multiply; could be conditional]  */\n+  #define X10(i)  (((i)<<1)+((i)<<3))\n+  #define X100(i) (((i)<<2)+((i)<<5)+((i)<<6))\n \n-  /* ----- Shared data ----- */\n-  /* The powers of of ten array (powers[n]==10**n, 0<=n<=10) */\n-extern const uInt powers[];\n+  /* MAXI and MINI -- general max & min (not in ANSI) for integers    */\n+  #define MAXI(x,y) ((x)<(y)?(y):(x))\n+  #define MINI(x,y) ((x)>(y)?(y):(x))\n+\n+  /* Useful constants\t\t\t\t\t\t      */\n+  #define BILLION      1000000000\t     /* 10**9\t\t      */\n+  /* CHARMASK: 0x30303030 for ASCII/UTF8; 0xF0F0F0F0 for EBCDIC\t      */\n+  #define CHARMASK ((((((((uInt)'0')<<8)+'0')<<8)+'0')<<8)+'0')\n+\n+\n+  /* ---------------------------------------------------------------- */\n+  /* Definitions for arbitary-precision modules (only valid after     */\n+  /* decNumber.h has been included)\t\t\t\t      */\n+  /* ---------------------------------------------------------------- */\n+\n+  /* Limits and constants\t\t\t\t\t      */\n+  #define DECNUMMAXP 999999999\t/* maximum precision code can handle  */\n+  #define DECNUMMAXE 999999999\t/* maximum adjusted exponent ditto    */\n+  #define DECNUMMINE -999999999 /* minimum adjusted exponent ditto    */\n+  #if (DECNUMMAXP != DEC_MAX_DIGITS)\n+    #error Maximum digits mismatch\n+  #endif\n+  #if (DECNUMMAXE != DEC_MAX_EMAX)\n+    #error Maximum exponent mismatch\n+  #endif\n+  #if (DECNUMMINE != DEC_MIN_EMIN)\n+    #error Minimum exponent mismatch\n+  #endif\n+\n+  /* Set DECDPUNMAX -- the maximum integer that fits in DECDPUN\t      */\n+  /* digits, and D2UTABLE -- the initializer for the D2U table\t      */\n+  #if\tDECDPUN==1\n+    #define DECDPUNMAX 9\n+    #define D2UTABLE {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,  \\\n+\t\t      18,19,20,21,22,23,24,25,26,27,28,29,30,31,32, \\\n+\t\t      33,34,35,36,37,38,39,40,41,42,43,44,45,46,47, \\\n+\t\t      48,49}\n+  #elif DECDPUN==2\n+    #define DECDPUNMAX 99\n+    #define D2UTABLE {0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,  \\\n+\t\t      11,11,12,12,13,13,14,14,15,15,16,16,17,17,18, \\\n+\t\t      18,19,19,20,20,21,21,22,22,23,23,24,24,25}\n+  #elif DECDPUN==3\n+    #define DECDPUNMAX 999\n+    #define D2UTABLE {0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7,  \\\n+\t\t      8,8,8,9,9,9,10,10,10,11,11,11,12,12,12,13,13, \\\n+\t\t      13,14,14,14,15,15,15,16,16,16,17}\n+  #elif DECDPUN==4\n+    #define DECDPUNMAX 9999\n+    #define D2UTABLE {0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,6,  \\\n+\t\t      6,6,6,7,7,7,7,8,8,8,8,9,9,9,9,10,10,10,10,11, \\\n+\t\t      11,11,11,12,12,12,12,13}\n+  #elif DECDPUN==5\n+    #define DECDPUNMAX 99999\n+    #define D2UTABLE {0,1,1,1,1,1,2,2,2,2,2,3,3,3,3,3,4,4,4,4,4,5,  \\\n+\t\t      5,5,5,5,6,6,6,6,6,7,7,7,7,7,8,8,8,8,8,9,9,9,  \\\n+\t\t      9,9,10,10,10,10}\n+  #elif DECDPUN==6\n+    #define DECDPUNMAX 999999\n+    #define D2UTABLE {0,1,1,1,1,1,1,2,2,2,2,2,2,3,3,3,3,3,3,4,4,4,  \\\n+\t\t      4,4,4,5,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,8,  \\\n+\t\t      8,8,8,8,8,9}\n+  #elif DECDPUN==7\n+    #define DECDPUNMAX 9999999\n+    #define D2UTABLE {0,1,1,1,1,1,1,1,2,2,2,2,2,2,2,3,3,3,3,3,3,3,  \\\n+\t\t      4,4,4,4,4,4,4,5,5,5,5,5,5,5,6,6,6,6,6,6,6,7,  \\\n+\t\t      7,7,7,7,7,7}\n+  #elif DECDPUN==8\n+    #define DECDPUNMAX 99999999\n+    #define D2UTABLE {0,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,3,  \\\n+\t\t      3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,6,6,6,  \\\n+\t\t      6,6,6,6,6,7}\n+  #elif DECDPUN==9\n+    #define DECDPUNMAX 999999999\n+    #define D2UTABLE {0,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,3,3,3,  \\\n+\t\t      3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,  \\\n+\t\t      5,5,6,6,6,6}\n+  #elif defined(DECDPUN)\n+    #error DECDPUN must be in the range 1-9\n+  #endif\n+\n+  /* ----- Shared data (in decNumber.c) ----- */\n+  /* Public lookup table used by the D2U macro (see below)\t      */\n+  #define DECMAXD2U 49\n+  extern const uByte d2utable[DECMAXD2U+1];\n \n   /* ----- Macros ----- */\n-  /* ISZERO -- return true if decNumber dn is a zero */\n-  /* [performance-critical in some situations] */\n-#define ISZERO(dn) decNumberIsZero(dn)\t/* now just a local name */\n-\n-  /* X10 and X100 -- multiply integer i by 10 or 100 */\n-  /* [shifts are usually faster than multiply; could be conditional] */\n-#define X10(i)  (((i)<<1)+((i)<<3))\n-#define X100(i) (((i)<<2)+((i)<<5)+((i)<<6))\n-\n-  /* D2U -- return the number of Units needed to hold d digits */\n-#if DECDPUN==8\n-#define D2U(d) ((unsigned)((d)+7)>>3)\n-#elif DECDPUN==4\n-#define D2U(d) ((unsigned)((d)+3)>>2)\n-#else\n-#define D2U(d) (((d)+DECDPUN-1)/DECDPUN)\n-#endif\n+  /* ISZERO -- return true if decNumber dn is a zero\t\t      */\n+  /* [performance-critical in some situations]\t\t\t      */\n+  #define ISZERO(dn) decNumberIsZero(dn)     /* now just a local name */\n+\n+  /* D2U -- return the number of Units needed to hold d digits\t      */\n+  /* (runtime version, with table lookaside for small d)\t      */\n+  #if DECDPUN==8\n+    #define D2U(d) ((unsigned)((d)<=DECMAXD2U?d2utable[d]:((d)+7)>>3))\n+  #elif DECDPUN==4\n+    #define D2U(d) ((unsigned)((d)<=DECMAXD2U?d2utable[d]:((d)+3)>>2))\n+  #else\n+    #define D2U(d) ((d)<=DECMAXD2U?d2utable[d]:((d)+DECDPUN-1)/DECDPUN)\n+  #endif\n+  /* SD2U -- static D2U macro (for compile-time calculation)\t      */\n+  #define SD2U(d) (((d)+DECDPUN-1)/DECDPUN)\n+\n+  /* MSUDIGITS -- returns digits in msu, from digits, calculated      */\n+  /* using D2U\t\t\t\t\t\t\t      */\n+  #define MSUDIGITS(d) ((d)-(D2U(d)-1)*DECDPUN)\n+\n+  /* D2N -- return the number of decNumber structs that would be      */\n+  /* needed to contain that number of digits (and the initial\t      */\n+  /* decNumber struct) safely.\tNote that one Unit is included in the */\n+  /* initial structure.\t Used for allocating space that is aligned on */\n+  /* a decNumber struct boundary. */\n+  #define D2N(d) \\\n+    ((((SD2U(d)-1)*sizeof(Unit))+sizeof(decNumber)*2-1)/sizeof(decNumber))\n+\n+  /* TODIGIT -- macro to remove the leading digit from the unsigned   */\n+  /* integer u at column cut (counting from the right, LSD=0) and     */\n+  /* place it as an ASCII character into the character pointed to by  */\n+  /* c.\t Note that cut must be <= 9, and the maximum value for u is   */\n+  /* 2,000,000,000 (as is needed for negative exponents of\t      */\n+  /* subnormals).  The unsigned integer pow is used as a temporary    */\n+  /* variable. */\n+  #define TODIGIT(u, cut, c, pow) {\t  \\\n+    *(c)='0';\t\t\t\t  \\\n+    pow=DECPOWERS[cut]*2;\t\t  \\\n+    if ((u)>pow) {\t\t\t  \\\n+      pow*=4;\t\t\t\t  \\\n+      if ((u)>=pow) {(u)-=pow; *(c)+=8;}  \\\n+      pow/=2;\t\t\t\t  \\\n+      if ((u)>=pow) {(u)-=pow; *(c)+=4;}  \\\n+      pow/=2;\t\t\t\t  \\\n+      }\t\t\t\t\t  \\\n+    if ((u)>=pow) {(u)-=pow; *(c)+=2;}\t  \\\n+    pow/=2;\t\t\t\t  \\\n+    if ((u)>=pow) {(u)-=pow; *(c)+=1;}\t  \\\n+    }\n+\n+  /* ---------------------------------------------------------------- */\n+  /* Definitions for fixed-precision modules (only valid after\t      */\n+  /* decSingle.h, decDouble.h, or decQuad.h has been included)\t      */\n+  /* ---------------------------------------------------------------- */\n+\n+  /* bcdnum -- a structure describing a format-independent finite     */\n+  /* number, whose coefficient is a string of bcd8 uBytes\t      */\n+  typedef struct {\n+    uByte   *msd;\t      /* -> most significant digit\t      */\n+    uByte   *lsd;\t      /* -> least ditto\t\t\t      */\n+    uInt     sign;\t      /* 0=positive, DECFLOAT_Sign=negative   */\n+    Int\t     exponent;\t      /* Unadjusted signed exponent (q), or   */\n+\t\t\t      /* DECFLOAT_NaN etc. for a special      */\n+    } bcdnum;\n+\n+  /* Test if exponent or bcdnum exponent must be a special, etc.      */\n+  #define EXPISSPECIAL(exp) ((exp)>=DECFLOAT_MinSp)\n+  #define EXPISINF(exp) (exp==DECFLOAT_Inf)\n+  #define EXPISNAN(exp) (exp==DECFLOAT_qNaN || exp==DECFLOAT_sNaN)\n+  #define NUMISSPECIAL(num) (EXPISSPECIAL((num)->exponent))\n+\n+  /* Refer to a 32-bit word or byte in a decFloat (df) by big-endian  */\n+  /* (array) notation (the 0 word or byte contains the sign bit),     */\n+  /* automatically adjusting for endianness; similarly address a word */\n+  /* in the next-wider format (decFloatWider, or dfw)\t\t      */\n+  #define DECWORDS  (DECBYTES/4)\n+  #define DECWWORDS (DECWBYTES/4)\n+  #if DECLITEND\n+    #define DFWORD(df, off) UINTAT((df)->bytes+(DECWORDS-1-(off))*4)\n+    #define DFBYTE(df, off) UBYTEAT((df)->bytes+(DECBYTES-1-(off)))\n+    #define DFWWORD(dfw, off) UINTAT((dfw)->bytes+(DECWWORDS-1-(off))*4)\n+  #else\n+    #define DFWORD(df, off) UINTAT((df)->bytes+(off)*4)\n+    #define DFBYTE(df, off) UBYTEAT((df)->bytes+(off))\n+    #define DFWWORD(dfw, off) UINTAT((dfw)->bytes+(off)*4)\n+  #endif\n+\n+  /* Tests for sign or specials, directly on DECFLOATs\t\t      */\n+  #define DFISSIGNED(df)   (DFWORD(df, 0)&0x80000000)\n+  #define DFISSPECIAL(df) ((DFWORD(df, 0)&0x78000000)==0x78000000)\n+  #define DFISINF(df)\t  ((DFWORD(df, 0)&0x7c000000)==0x78000000)\n+  #define DFISNAN(df)\t  ((DFWORD(df, 0)&0x7c000000)==0x7c000000)\n+  #define DFISQNAN(df)\t  ((DFWORD(df, 0)&0x7e000000)==0x7c000000)\n+  #define DFISSNAN(df)\t  ((DFWORD(df, 0)&0x7e000000)==0x7e000000)\n+\n+  /* Shared lookup tables\t\t\t\t\t      */\n+  extern const uInt   DECCOMBMSD[64];\t/* Combination field -> MSD   */\n+  extern const uInt   DECCOMBFROM[48];\t/* exp+msd -> Combination     */\n+\n+  /* Private generic (utility) routine\t\t\t\t      */\n+  #if DECCHECK || DECTRACE\n+    extern void decShowNum(const bcdnum *, const char *);\n+  #endif\n+\n+  /* Format-dependent macros and constants\t\t\t      */\n+  #if defined(DECPMAX)\n+\n+    /* Useful constants\t\t\t\t\t\t      */\n+    #define DECPMAX9  (ROUNDUP(DECPMAX, 9)/9)  /* 'Pmax' in 10**9s    */\n+    /* Top words for a zero\t\t\t\t\t      */\n+    #define SINGLEZERO\t 0x22500000\n+    #define DOUBLEZERO\t 0x22380000\n+    #define QUADZERO\t 0x22080000\n+    /* [ZEROWORD is defined to be one of these in the DFISZERO macro] */\n+\n+    /* Format-dependent common tests:\t\t\t\t      */\n+    /*\t DFISZERO   -- test for (any) zero\t\t\t      */\n+    /*\t DFISCCZERO -- test for coefficient continuation being zero   */\n+    /*\t DFISCC01   -- test for coefficient contains only 0s and 1s   */\n+    /*\t DFISINT    -- test for finite and exponent q=0\t\t      */\n+    /*\t DFISUINT01 -- test for sign=0, finite, exponent q=0, and     */\n+    /*\t\t       MSD=0 or 1\t\t\t\t      */\n+    /*\t ZEROWORD is also defined here.\t\t\t\t      */\n+    /* In DFISZERO the first test checks the least-significant word   */\n+    /* (most likely to be non-zero); the penultimate tests MSD and    */\n+    /* DPDs in the signword, and the final test excludes specials and */\n+    /* MSD>7.  DFISINT similarly has to allow for the two forms of    */\n+    /* MSD codes.  DFISUINT01 only has to allow for one form of MSD   */\n+    /* code.\t\t\t\t\t\t\t      */\n+    #if DECPMAX==7\n+      #define ZEROWORD SINGLEZERO\n+      /* [test macros not needed except for Zero]\t\t      */\n+      #define DFISZERO(df)  ((DFWORD(df, 0)&0x1c0fffff)==0\t   \\\n+\t\t\t  && (DFWORD(df, 0)&0x60000000)!=0x60000000)\n+    #elif DECPMAX==16\n+      #define ZEROWORD DOUBLEZERO\n+      #define DFISZERO(df)  ((DFWORD(df, 1)==0\t\t\t   \\\n+\t\t\t  && (DFWORD(df, 0)&0x1c03ffff)==0\t   \\\n+\t\t\t  && (DFWORD(df, 0)&0x60000000)!=0x60000000))\n+      #define DFISINT(df) ((DFWORD(df, 0)&0x63fc0000)==0x22380000  \\\n+\t\t\t ||(DFWORD(df, 0)&0x7bfc0000)==0x6a380000)\n+      #define DFISUINT01(df) ((DFWORD(df, 0)&0xfbfc0000)==0x22380000)\n+      #define DFISCCZERO(df) (DFWORD(df, 1)==0\t\t\t   \\\n+\t\t\t  && (DFWORD(df, 0)&0x0003ffff)==0)\n+      #define DFISCC01(df)  ((DFWORD(df, 0)&~0xfffc9124)==0\t   \\\n+\t\t\t  && (DFWORD(df, 1)&~0x49124491)==0)\n+    #elif DECPMAX==34\n+      #define ZEROWORD QUADZERO\n+      #define DFISZERO(df)  ((DFWORD(df, 3)==0\t\t\t   \\\n+\t\t\t  &&  DFWORD(df, 2)==0\t\t\t   \\\n+\t\t\t  &&  DFWORD(df, 1)==0\t\t\t   \\\n+\t\t\t  && (DFWORD(df, 0)&0x1c003fff)==0\t   \\\n+\t\t\t  && (DFWORD(df, 0)&0x60000000)!=0x60000000))\n+      #define DFISINT(df) ((DFWORD(df, 0)&0x63ffc000)==0x22080000  \\\n+\t\t\t ||(DFWORD(df, 0)&0x7bffc000)==0x6a080000)\n+      #define DFISUINT01(df) ((DFWORD(df, 0)&0xfbffc000)==0x22080000)\n+      #define DFISCCZERO(df) (DFWORD(df, 3)==0\t\t\t   \\\n+\t\t\t  &&  DFWORD(df, 2)==0\t\t\t   \\\n+\t\t\t  &&  DFWORD(df, 1)==0\t\t\t   \\\n+\t\t\t  && (DFWORD(df, 0)&0x00003fff)==0)\n+\n+      #define DFISCC01(df)   ((DFWORD(df, 0)&~0xffffc912)==0\t   \\\n+\t\t\t  &&  (DFWORD(df, 1)&~0x44912449)==0\t   \\\n+\t\t\t  &&  (DFWORD(df, 2)&~0x12449124)==0\t   \\\n+\t\t\t  &&  (DFWORD(df, 3)&~0x49124491)==0)\n+    #endif\n+\n+    /* Macros to test if a certain 10 bits of a uInt or pair of uInts */\n+    /* are a canonical declet [higher or lower bits are ignored].     */\n+    /* declet is at offset 0 (from the right) in a uInt:\t      */\n+    #define CANONDPD(dpd) (((dpd)&0x300)==0 || ((dpd)&0x6e)!=0x6e)\n+    /* declet is at offset k (a multiple of 2) in a uInt:\t      */\n+    #define CANONDPDOFF(dpd, k) (((dpd)&(0x300<<(k)))==0\t    \\\n+      || ((dpd)&(((uInt)0x6e)<<(k)))!=(((uInt)0x6e)<<(k)))\n+    /* declet is at offset k (a multiple of 2) in a pair of uInts:    */\n+    /* [the top 2 bits will always be in the more-significant uInt]   */\n+    #define CANONDPDTWO(hi, lo, k) (((hi)&(0x300>>(32-(k))))==0\t    \\\n+      || ((hi)&(0x6e>>(32-(k))))!=(0x6e>>(32-(k)))\t\t    \\\n+      || ((lo)&(((uInt)0x6e)<<(k)))!=(((uInt)0x6e)<<(k)))\n+\n+    /* Macro to test whether a full-length (length DECPMAX) BCD8      */\n+    /* coefficient is zero\t\t\t\t\t      */\n+    /* test just the LSWord first, then the remainder\t\t      */\n+    #if DECPMAX==7\n+      #define ISCOEFFZERO(u) (UINTAT((u)+DECPMAX-4)==0\t\t    \\\n+\t&& UINTAT((u)+DECPMAX-7)==0)\n+    #elif DECPMAX==16\n+      #define ISCOEFFZERO(u) (UINTAT((u)+DECPMAX-4)==0\t\t    \\\n+\t&& (UINTAT((u)+DECPMAX-8)+UINTAT((u)+DECPMAX-12)\t    \\\n+\t   +UINTAT((u)+DECPMAX-16))==0)\n+    #elif DECPMAX==34\n+      #define ISCOEFFZERO(u) (UINTAT((u)+DECPMAX-4)==0\t\t    \\\n+\t&& (UINTAT((u)+DECPMAX-8) +UINTAT((u)+DECPMAX-12)\t    \\\n+\t   +UINTAT((u)+DECPMAX-16)+UINTAT((u)+DECPMAX-20)\t    \\\n+\t   +UINTAT((u)+DECPMAX-24)+UINTAT((u)+DECPMAX-28)\t    \\\n+\t   +UINTAT((u)+DECPMAX-32)+USHORTAT((u)+DECPMAX-34))==0)\n+    #endif\n+\n+    /* Macros and masks for the exponent continuation field and MSD   */\n+    /* Get the exponent continuation from a decFloat *df as an Int    */\n+    #define GETECON(df) ((Int)((DFWORD((df), 0)&0x03ffffff)>>(32-6-DECECONL)))\n+    /* Ditto, from the next-wider format\t\t\t      */\n+    #define GETWECON(df) ((Int)((DFWWORD((df), 0)&0x03ffffff)>>(32-6-DECWECONL)))\n+    /* Get the biased exponent similarly\t\t\t      */\n+    #define GETEXP(df)\t((Int)(DECCOMBEXP[DFWORD((df), 0)>>26]+GETECON(df)))\n+    /* Get the unbiased exponent similarly\t\t\t      */\n+    #define GETEXPUN(df) ((Int)GETEXP(df)-DECBIAS)\n+    /* Get the MSD similarly (as uInt)\t\t\t\t      */\n+    #define GETMSD(df)\t (DECCOMBMSD[DFWORD((df), 0)>>26])\n+\n+    /* Compile-time computes of the exponent continuation field masks */\n+    /* full exponent continuation field:\t\t\t      */\n+    #define ECONMASK ((0x03ffffff>>(32-6-DECECONL))<<(32-6-DECECONL))\n+    /* same, not including its first digit (the qNaN/sNaN selector):  */\n+    #define ECONNANMASK ((0x01ffffff>>(32-6-DECECONL))<<(32-6-DECECONL))\n+\n+    /* Macros to decode the coefficient in a finite decFloat *df into */\n+    /* a BCD string (uByte *bcdin) of length DECPMAX uBytes\t      */\n+\n+    /* In-line sequence to convert 10 bits at right end of uInt dpd   */\n+    /* to three BCD8 digits starting at uByte u.  Note that an extra  */\n+    /* byte is written to the right of the three digits because this  */\n+    /* moves four at a time for speed; the alternative macro moves    */\n+    /* exactly three bytes\t\t\t\t\t      */\n+    #define dpd2bcd8(u, dpd) {\t\t\t\t \\\n+      UINTAT(u)=UINTAT(&DPD2BCD8[((dpd)&0x3ff)*4]);}\n+\n+    #define dpd2bcd83(u, dpd) {\t\t\t\t \\\n+      *(u)=DPD2BCD8[((dpd)&0x3ff)*4];\t\t\t \\\n+      *(u+1)=DPD2BCD8[((dpd)&0x3ff)*4+1];\t\t \\\n+      *(u+2)=DPD2BCD8[((dpd)&0x3ff)*4+2];}\n+\n+    /* Decode the declets.  After extracting each one, it is decoded  */\n+    /* to BCD8 using a table lookup (also used for variable-length    */\n+    /* decode).\t Each DPD decode is 3 bytes BCD8 plus a one-byte      */\n+    /* length which is not used, here).\t Fixed-length 4-byte moves    */\n+    /* are fast, however, almost everywhere, and so are used except   */\n+    /* for the final three bytes (to avoid overrun).  The code below  */\n+    /* is 36 instructions for Doubles and about 70 for Quads, even    */\n+    /* on IA32.\t\t\t\t\t\t\t      */\n+\n+    /* Two macros are defined for each format:\t\t\t      */\n+    /*\t GETCOEFF extracts the coefficient of the current format      */\n+    /*\t GETWCOEFF extracts the coefficient of the next-wider format. */\n+    /* The latter is a copy of the next-wider GETCOEFF using DFWWORD. */\n+\n+    #if DECPMAX==7\n+    #define GETCOEFF(df, bcd) {\t\t\t\t \\\n+      uInt sourhi=DFWORD(df, 0);\t\t\t \\\n+      *(bcd)=(uByte)DECCOMBMSD[sourhi>>26];\t\t \\\n+      dpd2bcd8(bcd+1, sourhi>>10);\t\t\t \\\n+      dpd2bcd83(bcd+4, sourhi);}\n+    #define GETWCOEFF(df, bcd) {\t\t\t \\\n+      uInt sourhi=DFWWORD(df, 0);\t\t\t \\\n+      uInt sourlo=DFWWORD(df, 1);\t\t\t \\\n+      *(bcd)=(uByte)DECCOMBMSD[sourhi>>26];\t\t \\\n+      dpd2bcd8(bcd+1, sourhi>>8);\t\t\t \\\n+      dpd2bcd8(bcd+4, (sourhi<<2) | (sourlo>>30));\t \\\n+      dpd2bcd8(bcd+7, sourlo>>20);\t\t\t \\\n+      dpd2bcd8(bcd+10, sourlo>>10);\t\t\t \\\n+      dpd2bcd83(bcd+13, sourlo);}\n+\n+    #elif DECPMAX==16\n+    #define GETCOEFF(df, bcd) {\t\t\t\t \\\n+      uInt sourhi=DFWORD(df, 0);\t\t\t \\\n+      uInt sourlo=DFWORD(df, 1);\t\t\t \\\n+      *(bcd)=(uByte)DECCOMBMSD[sourhi>>26];\t\t \\\n+      dpd2bcd8(bcd+1, sourhi>>8);\t\t\t \\\n+      dpd2bcd8(bcd+4, (sourhi<<2) | (sourlo>>30));\t \\\n+      dpd2bcd8(bcd+7, sourlo>>20);\t\t\t \\\n+      dpd2bcd8(bcd+10, sourlo>>10);\t\t\t \\\n+      dpd2bcd83(bcd+13, sourlo);}\n+    #define GETWCOEFF(df, bcd) {\t\t\t \\\n+      uInt sourhi=DFWWORD(df, 0);\t\t\t \\\n+      uInt sourmh=DFWWORD(df, 1);\t\t\t \\\n+      uInt sourml=DFWWORD(df, 2);\t\t\t \\\n+      uInt sourlo=DFWWORD(df, 3);\t\t\t \\\n+      *(bcd)=(uByte)DECCOMBMSD[sourhi>>26];\t\t \\\n+      dpd2bcd8(bcd+1, sourhi>>4);\t\t\t \\\n+      dpd2bcd8(bcd+4, ((sourhi)<<6) | (sourmh>>26));\t \\\n+      dpd2bcd8(bcd+7, sourmh>>16);\t\t\t \\\n+      dpd2bcd8(bcd+10, sourmh>>6);\t\t\t \\\n+      dpd2bcd8(bcd+13, ((sourmh)<<4) | (sourml>>28));\t \\\n+      dpd2bcd8(bcd+16, sourml>>18);\t\t\t \\\n+      dpd2bcd8(bcd+19, sourml>>8);\t\t\t \\\n+      dpd2bcd8(bcd+22, ((sourml)<<2) | (sourlo>>30));\t \\\n+      dpd2bcd8(bcd+25, sourlo>>20);\t\t\t \\\n+      dpd2bcd8(bcd+28, sourlo>>10);\t\t\t \\\n+      dpd2bcd83(bcd+31, sourlo);}\n+\n+    #elif DECPMAX==34\n+    #define GETCOEFF(df, bcd) {\t\t\t\t \\\n+      uInt sourhi=DFWORD(df, 0);\t\t\t \\\n+      uInt sourmh=DFWORD(df, 1);\t\t\t \\\n+      uInt sourml=DFWORD(df, 2);\t\t\t \\\n+      uInt sourlo=DFWORD(df, 3);\t\t\t \\\n+      *(bcd)=(uByte)DECCOMBMSD[sourhi>>26];\t\t \\\n+      dpd2bcd8(bcd+1, sourhi>>4);\t\t\t \\\n+      dpd2bcd8(bcd+4, ((sourhi)<<6) | (sourmh>>26));\t \\\n+      dpd2bcd8(bcd+7, sourmh>>16);\t\t\t \\\n+      dpd2bcd8(bcd+10, sourmh>>6);\t\t\t \\\n+      dpd2bcd8(bcd+13, ((sourmh)<<4) | (sourml>>28));\t \\\n+      dpd2bcd8(bcd+16, sourml>>18);\t\t\t \\\n+      dpd2bcd8(bcd+19, sourml>>8);\t\t\t \\\n+      dpd2bcd8(bcd+22, ((sourml)<<2) | (sourlo>>30));\t \\\n+      dpd2bcd8(bcd+25, sourlo>>20);\t\t\t \\\n+      dpd2bcd8(bcd+28, sourlo>>10);\t\t\t \\\n+      dpd2bcd83(bcd+31, sourlo);}\n+\n+      #define GETWCOEFF(df, bcd) {??} /* [should never be used]\t      */\n+    #endif\n+\n+    /* Macros to decode the coefficient in a finite decFloat *df into */\n+    /* a base-billion uInt array, with the least-significant\t      */\n+    /* 0-999999999 'digit' at offset 0.\t\t\t\t      */\n+\n+    /* Decode the declets.  After extracting each one, it is decoded  */\n+    /* to binary using a table lookup.\tThree tables are used; one    */\n+    /* the usual DPD to binary, the other two pre-multiplied by 1000  */\n+    /* and 1000000 to avoid multiplication during decode.  These      */\n+    /* tables can also be used for multiplying up the MSD as the DPD  */\n+    /* code for 0 through 9 is the identity.\t\t\t      */\n+    #define DPD2BIN0 DPD2BIN\t     /* for prettier code\t      */\n+\n+    #if DECPMAX==7\n+    #define GETCOEFFBILL(df, buf) {\t\t\t      \\\n+      uInt sourhi=DFWORD(df, 0);\t\t\t      \\\n+      (buf)[0]=DPD2BIN0[sourhi&0x3ff]\t\t\t      \\\n+\t      +DPD2BINK[(sourhi>>10)&0x3ff]\t\t      \\\n+\t      +DPD2BINM[DECCOMBMSD[sourhi>>26]];}\n+\n+    #elif DECPMAX==16\n+    #define GETCOEFFBILL(df, buf) {\t\t\t      \\\n+      uInt sourhi, sourlo;\t\t\t\t      \\\n+      sourlo=DFWORD(df, 1);\t\t\t\t      \\\n+      (buf)[0]=DPD2BIN0[sourlo&0x3ff]\t\t\t      \\\n+\t      +DPD2BINK[(sourlo>>10)&0x3ff]\t\t      \\\n+\t      +DPD2BINM[(sourlo>>20)&0x3ff];\t\t      \\\n+      sourhi=DFWORD(df, 0);\t\t\t\t      \\\n+      (buf)[1]=DPD2BIN0[((sourhi<<2) | (sourlo>>30))&0x3ff]   \\\n+\t      +DPD2BINK[(sourhi>>8)&0x3ff]\t\t      \\\n+\t      +DPD2BINM[DECCOMBMSD[sourhi>>26]];}\n+\n+    #elif DECPMAX==34\n+    #define GETCOEFFBILL(df, buf) {\t\t\t      \\\n+      uInt sourhi, sourmh, sourml, sourlo;\t\t      \\\n+      sourlo=DFWORD(df, 3);\t\t\t\t      \\\n+      (buf)[0]=DPD2BIN0[sourlo&0x3ff]\t\t\t      \\\n+\t      +DPD2BINK[(sourlo>>10)&0x3ff]\t\t      \\\n+\t      +DPD2BINM[(sourlo>>20)&0x3ff];\t\t      \\\n+      sourml=DFWORD(df, 2);\t\t\t\t      \\\n+      (buf)[1]=DPD2BIN0[((sourml<<2) | (sourlo>>30))&0x3ff]   \\\n+\t      +DPD2BINK[(sourml>>8)&0x3ff]\t\t      \\\n+\t      +DPD2BINM[(sourml>>18)&0x3ff];\t\t      \\\n+      sourmh=DFWORD(df, 1);\t\t\t\t      \\\n+      (buf)[2]=DPD2BIN0[((sourmh<<4) | (sourml>>28))&0x3ff]   \\\n+\t      +DPD2BINK[(sourmh>>6)&0x3ff]\t\t      \\\n+\t      +DPD2BINM[(sourmh>>16)&0x3ff];\t\t      \\\n+      sourhi=DFWORD(df, 0);\t\t\t\t      \\\n+      (buf)[3]=DPD2BIN0[((sourhi<<6) | (sourmh>>26))&0x3ff]   \\\n+\t      +DPD2BINK[(sourhi>>4)&0x3ff]\t\t      \\\n+\t      +DPD2BINM[DECCOMBMSD[sourhi>>26]];}\n+\n+    #endif\n+\n+    /* Macros to decode the coefficient in a finite decFloat *df into */\n+    /* a base-thousand uInt array, with the least-significant 0-999   */\n+    /* 'digit' at offset 0.\t\t\t\t\t      */\n+\n+    /* Decode the declets.  After extracting each one, it is decoded  */\n+    /* to binary using a table lookup.\t\t\t\t      */\n+    #if DECPMAX==7\n+    #define GETCOEFFTHOU(df, buf) {\t\t\t      \\\n+      uInt sourhi=DFWORD(df, 0);\t\t\t      \\\n+      (buf)[0]=DPD2BIN[sourhi&0x3ff];\t\t\t      \\\n+      (buf)[1]=DPD2BIN[(sourhi>>10)&0x3ff];\t\t      \\\n+      (buf)[2]=DECCOMBMSD[sourhi>>26];}\n+\n+    #elif DECPMAX==16\n+    #define GETCOEFFTHOU(df, buf) {\t\t\t      \\\n+      uInt sourhi, sourlo;\t\t\t\t      \\\n+      sourlo=DFWORD(df, 1);\t\t\t\t      \\\n+      (buf)[0]=DPD2BIN[sourlo&0x3ff];\t\t\t      \\\n+      (buf)[1]=DPD2BIN[(sourlo>>10)&0x3ff];\t\t      \\\n+      (buf)[2]=DPD2BIN[(sourlo>>20)&0x3ff];\t\t      \\\n+      sourhi=DFWORD(df, 0);\t\t\t\t      \\\n+      (buf)[3]=DPD2BIN[((sourhi<<2) | (sourlo>>30))&0x3ff];   \\\n+      (buf)[4]=DPD2BIN[(sourhi>>8)&0x3ff];\t\t      \\\n+      (buf)[5]=DECCOMBMSD[sourhi>>26];}\n+\n+    #elif DECPMAX==34\n+    #define GETCOEFFTHOU(df, buf) {\t\t\t      \\\n+      uInt sourhi, sourmh, sourml, sourlo;\t\t      \\\n+      sourlo=DFWORD(df, 3);\t\t\t\t      \\\n+      (buf)[0]=DPD2BIN[sourlo&0x3ff];\t\t\t      \\\n+      (buf)[1]=DPD2BIN[(sourlo>>10)&0x3ff];\t\t      \\\n+      (buf)[2]=DPD2BIN[(sourlo>>20)&0x3ff];\t\t      \\\n+      sourml=DFWORD(df, 2);\t\t\t\t      \\\n+      (buf)[3]=DPD2BIN[((sourml<<2) | (sourlo>>30))&0x3ff];   \\\n+      (buf)[4]=DPD2BIN[(sourml>>8)&0x3ff];\t\t      \\\n+      (buf)[5]=DPD2BIN[(sourml>>18)&0x3ff];\t\t      \\\n+      sourmh=DFWORD(df, 1);\t\t\t\t      \\\n+      (buf)[6]=DPD2BIN[((sourmh<<4) | (sourml>>28))&0x3ff];   \\\n+      (buf)[7]=DPD2BIN[(sourmh>>6)&0x3ff];\t\t      \\\n+      (buf)[8]=DPD2BIN[(sourmh>>16)&0x3ff];\t\t      \\\n+      sourhi=DFWORD(df, 0);\t\t\t\t      \\\n+      (buf)[9]=DPD2BIN[((sourhi<<6) | (sourmh>>26))&0x3ff];   \\\n+      (buf)[10]=DPD2BIN[(sourhi>>4)&0x3ff];\t\t      \\\n+      (buf)[11]=DECCOMBMSD[sourhi>>26];}\n+\n+    #endif\n+\n+    /* Set a decFloat to the maximum positive finite number (Nmax)    */\n+    #if DECPMAX==7\n+    #define DFSETNMAX(df)\t     \\\n+      {DFWORD(df, 0)=0x77f3fcff;}\n+    #elif DECPMAX==16\n+    #define DFSETNMAX(df)\t     \\\n+      {DFWORD(df, 0)=0x77fcff3f;     \\\n+       DFWORD(df, 1)=0xcff3fcff;}\n+    #elif DECPMAX==34\n+    #define DFSETNMAX(df)\t     \\\n+      {DFWORD(df, 0)=0x77ffcff3;     \\\n+       DFWORD(df, 1)=0xfcff3fcf;     \\\n+       DFWORD(df, 2)=0xf3fcff3f;     \\\n+       DFWORD(df, 3)=0xcff3fcff;}\n+    #endif\n+\n+  /* [end of format-dependent macros and constants]\t\t      */\n+  #endif\n \n #else\n-#error decNumberLocal included more than once\n+  #error decNumberLocal included more than once\n #endif"}, {"sha": "e638a070b1c60c6cfac665abea2315d860b70b0f", "filename": "libdecnumber/decNumberSymbols.h", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FdecNumberSymbols.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FdecNumberSymbols.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecNumberSymbols.h?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb", "patch": "@@ -0,0 +1,69 @@\n+#if !defined(DECNUMBERSYMBOLS)\n+#define DECNUMBERSYMBOLS\n+\n+#ifdef IN_LIBGCC2\n+#define decNumberAbs __decNumberAbs\n+#define decNumberAdd __decNumberAdd\n+#define decNumberAnd __decNumberAnd\n+#define decNumberClass __decNumberClass\n+#define decNumberClassToString __decNumberClassToString\n+#define decNumberCompare __decNumberCompare\n+#define decNumberCompareSignal __decNumberCompareSignal\n+#define decNumberCompareTotal __decNumberCompareTotal\n+#define decNumberCompareTotalMag __decNumberCompareTotalMag\n+#define decNumberCopy __decNumberCopy\n+#define decNumberCopyAbs __decNumberCopyAbs\n+#define decNumberCopyNegate __decNumberCopyNegate\n+#define decNumberCopySign __decNumberCopySign\n+#define decNumberDivide __decNumberDivide\n+#define decNumberDivideInteger __decNumberDivideInteger\n+#define decNumberExp __decNumberExp\n+#define decNumberFMA __decNumberFMA\n+#define decNumberFromInt32 __decNumberFromInt32\n+#define decNumberFromString __decNumberFromString\n+#define decNumberFromUInt32 __decNumberFromUInt32\n+#define decNumberGetBCD __decNumberGetBCD\n+#define decNumberInvert __decNumberInvert\n+#define decNumberIsNormal __decNumberIsNormal\n+#define decNumberIsSubnormal __decNumberIsSubnormal\n+#define decNumberLn __decNumberLn\n+#define decNumberLog10 __decNumberLog10\n+#define decNumberLogB __decNumberLogB\n+#define decNumberMax __decNumberMax\n+#define decNumberMaxMag __decNumberMaxMag\n+#define decNumberMin __decNumberMin\n+#define decNumberMinMag __decNumberMinMag\n+#define decNumberMinus __decNumberMinus\n+#define decNumberMultiply __decNumberMultiply\n+#define decNumberNextMinus __decNumberNextMinus\n+#define decNumberNextPlus __decNumberNextPlus\n+#define decNumberNextToward __decNumberNextToward\n+#define decNumberNormalize __decNumberNormalize\n+#define decNumberOr __decNumberOr\n+#define decNumberPlus __decNumberPlus\n+#define decNumberPower __decNumberPower\n+#define decNumberQuantize __decNumberQuantize\n+#define decNumberReduce __decNumberReduce\n+#define decNumberRemainder __decNumberRemainder\n+#define decNumberRemainderNear __decNumberRemainderNear\n+#define decNumberRescale __decNumberRescale\n+#define decNumberRotate __decNumberRotate\n+#define decNumberSameQuantum __decNumberSameQuantum\n+#define decNumberScaleB __decNumberScaleB\n+#define decNumberSetBCD __decNumberSetBCD\n+#define decNumberShift __decNumberShift\n+#define decNumberSquareRoot __decNumberSquareRoot\n+#define decNumberSubtract __decNumberSubtract\n+#define decNumberToEngString __decNumberToEngString\n+#define decNumberToInt32 __decNumberToInt32\n+#define decNumberToIntegralExact __decNumberToIntegralExact\n+#define decNumberToIntegralValue __decNumberToIntegralValue\n+#define decNumberToString __decNumberToString\n+#define decNumberToUInt32 __decNumberToUInt32\n+#define decNumberTrim __decNumberTrim\n+#define decNumberVersion __decNumberVersion\n+#define decNumberXor __decNumberXor\n+#define decNumberZero __decNumberZero\n+#endif\n+\n+#endif"}, {"sha": "2b912fe13bc3ca53a526516621d601b23b7474fb", "filename": "libdecnumber/decPacked.c", "status": "added", "additions": 235, "deletions": 0, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FdecPacked.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FdecPacked.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecPacked.c?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb", "patch": "@@ -0,0 +1,235 @@\n+/* Packed decimal conversion module for the decNumber C Library.\n+   Copyright (C) 2007 Free Software Foundation, Inc.\n+   Contributed by IBM Corporation.  Author Mike Cowlishaw.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 2, or (at your option) any later\n+   version.\n+\n+   In addition to the permissions in the GNU General Public License,\n+   the Free Software Foundation gives you unlimited permission to link\n+   the compiled version of this file into combinations with other\n+   programs, and to distribute those combinations without any\n+   restriction coming from the use of this file.  (The General Public\n+   License restrictions do apply in other respects; for example, they\n+   cover modification of the file, and distribution when not linked\n+   into a combine executable.)\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+   02110-1301, USA.  */\n+\n+/* ------------------------------------------------------------------ */\n+/* Packed Decimal conversion module\t\t\t\t      */\n+/* ------------------------------------------------------------------ */\n+/* This module comprises the routines for Packed Decimal format\t      */\n+/* numbers.  Conversions are supplied to and from decNumber, which in */\n+/* turn supports:\t\t\t\t\t\t      */\n+/*   conversions to and from string\t\t\t\t      */\n+/*   arithmetic routines\t\t\t\t\t      */\n+/*   utilities.\t\t\t\t\t\t\t      */\n+/* Conversions from decNumber to and from densely packed decimal      */\n+/* formats are provided by the decimal32 through decimal128 modules.  */\n+/* ------------------------------------------------------------------ */\n+\n+#include <string.h>\t      /* for NULL */\n+#include \"decNumber.h\"\t      /* base number library */\n+#include \"decPacked.h\"\t      /* packed decimal */\n+#include \"decNumberLocal.h\"   /* decNumber local types, etc. */\n+\n+/* ------------------------------------------------------------------ */\n+/* decPackedFromNumber -- convert decNumber to BCD Packed Decimal     */\n+/*\t\t\t\t\t\t\t\t      */\n+/*   bcd    is the BCD bytes\t\t\t\t\t      */\n+/*   length is the length of the BCD array\t\t\t      */\n+/*   scale  is the scale result\t\t\t\t\t      */\n+/*   dn\t    is the decNumber\t\t\t\t\t      */\n+/*   returns bcd, or NULL if error\t\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* The number is converted to a BCD packed decimal byte array,\t      */\n+/* right aligned in the bcd array, whose length is indicated by the   */\n+/* second parameter.  The final 4-bit nibble in the array will be a   */\n+/* sign nibble, C (1100) for + and D (1101) for -.  Unused bytes and  */\n+/* nibbles to the left of the number are set to 0.\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* scale is set to the scale of the number (this is the exponent,     */\n+/* negated).  To force the number to a specified scale, first use the */\n+/* decNumberRescale routine, which will round and change the exponent */\n+/* as necessary.\t\t\t\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* If there is an error (that is, the decNumber has too many digits   */\n+/* to fit in length bytes, or it is a NaN or Infinity), NULL is\t      */\n+/* returned and the bcd and scale results are unchanged.  Otherwise   */\n+/* bcd is returned.\t\t\t\t\t\t      */\n+/* ------------------------------------------------------------------ */\n+uByte * decPackedFromNumber(uByte *bcd, Int length, Int *scale,\n+\t\t\t    const decNumber *dn) {\n+  const Unit *up=dn->lsu;     /* Unit array pointer */\n+  uByte obyte, *out;\t      /* current output byte, and where it goes */\n+  Int indigs=dn->digits;      /* digits processed */\n+  uInt cut=DECDPUN;\t      /* downcounter per Unit */\n+  uInt u=*up;\t\t      /* work */\n+  uInt nib;\t\t      /* .. */\n+  #if DECDPUN<=4\n+  uInt temp;\t\t      /* .. */\n+  #endif\n+\n+  if (dn->digits>length*2-1\t\t     /* too long .. */\n+   ||(dn->bits & DECSPECIAL)) return NULL;   /* .. or special -- hopeless */\n+\n+  if (dn->bits&DECNEG) obyte=DECPMINUS;\t     /* set the sign .. */\n+   else\t\t       obyte=DECPPLUS;\n+  *scale=-dn->exponent;\t\t\t     /* .. and scale */\n+\n+  /* loop from lowest (rightmost) byte */\n+  out=bcd+length-1;\t\t\t     /* -> final byte */\n+  for (; out>=bcd; out--) {\n+    if (indigs>0) {\n+      if (cut==0) {\n+\tup++;\n+\tu=*up;\n+\tcut=DECDPUN;\n+\t}\n+      #if DECDPUN<=4\n+\ttemp=(u*6554)>>16;\t   /* fast /10 */\n+\tnib=u-X10(temp);\n+\tu=temp;\n+      #else\n+\tnib=u%10;\t\t   /* cannot use *6554 trick :-( */\n+\tu=u/10;\n+      #endif\n+      obyte|=(nib<<4);\n+      indigs--;\n+      cut--;\n+      }\n+    *out=obyte;\n+    obyte=0;\t\t\t   /* assume 0 */\n+    if (indigs>0) {\n+      if (cut==0) {\n+\tup++;\n+\tu=*up;\n+\tcut=DECDPUN;\n+\t}\n+      #if DECDPUN<=4\n+\ttemp=(u*6554)>>16;\t   /* as above */\n+\tobyte=(uByte)(u-X10(temp));\n+\tu=temp;\n+      #else\n+\tobyte=(uByte)(u%10);\n+\tu=u/10;\n+      #endif\n+      indigs--;\n+      cut--;\n+      }\n+    } /* loop */\n+\n+  return bcd;\n+  } /* decPackedFromNumber */\n+\n+/* ------------------------------------------------------------------ */\n+/* decPackedToNumber -- convert BCD Packed Decimal to a decNumber     */\n+/*\t\t\t\t\t\t\t\t      */\n+/*   bcd    is the BCD bytes\t\t\t\t\t      */\n+/*   length is the length of the BCD array\t\t\t      */\n+/*   scale  is the scale associated with the BCD integer\t      */\n+/*   dn\t    is the decNumber [with space for length*2 digits]\t      */\n+/*   returns dn, or NULL if error\t\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* The BCD packed decimal byte array, together with an associated     */\n+/* scale, is converted to a decNumber.\tThe BCD array is assumed full */\n+/* of digits, and must be ended by a 4-bit sign nibble in the least   */\n+/* significant four bits of the final byte.\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* The scale is used (negated) as the exponent of the decNumber.      */\n+/* Note that zeros may have a sign and/or a scale.\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* The decNumber structure is assumed to have sufficient space to     */\n+/* hold the converted number (that is, up to length*2-1 digits), so   */\n+/* no error is possible unless the adjusted exponent is out of range, */\n+/* no sign nibble was found, or a sign nibble was found before the    */\n+/* final nibble.  In these error cases, NULL is returned and the      */\n+/* decNumber will be 0.\t\t\t\t\t\t      */\n+/* ------------------------------------------------------------------ */\n+decNumber * decPackedToNumber(const uByte *bcd, Int length,\n+\t\t\t      const Int *scale, decNumber *dn) {\n+  const uByte *last=bcd+length-1;  /* -> last byte */\n+  const uByte *first;\t\t   /* -> first non-zero byte */\n+  uInt\tnib;\t\t\t   /* work nibble */\n+  Unit\t*up=dn->lsu;\t\t   /* output pointer */\n+  Int\tdigits;\t\t\t   /* digits count */\n+  Int\tcut=0;\t\t\t   /* phase of output */\n+\n+  decNumberZero(dn);\t\t   /* default result */\n+  last=&bcd[length-1];\n+  nib=*last & 0x0f;\t\t   /* get the sign */\n+  if (nib==DECPMINUS || nib==DECPMINUSALT) dn->bits=DECNEG;\n+   else if (nib<=9) return NULL;   /* not a sign nibble */\n+\n+  /* skip leading zero bytes [final byte is always non-zero, due to sign] */\n+  for (first=bcd; *first==0;) first++;\n+  digits=(last-first)*2+1;\t\t/* calculate digits .. */\n+  if ((*first & 0xf0)==0) digits--;\t/* adjust for leading zero nibble */\n+  if (digits!=0) dn->digits=digits;\t/* count of actual digits [if 0, */\n+\t\t\t\t\t/* leave as 1] */\n+\n+  /* check the adjusted exponent; note that scale could be unbounded */\n+  dn->exponent=-*scale;\t\t\t/* set the exponent */\n+  if (*scale>=0) {\t\t\t/* usual case */\n+    if ((dn->digits-*scale-1)<-DECNUMMAXE) {\t  /* underflow */\n+      decNumberZero(dn);\n+      return NULL;}\n+    }\n+   else { /* -ve scale; +ve exponent */\n+    /* need to be careful to avoid wrap, here, also BADINT case */\n+    if ((*scale<-DECNUMMAXE)\t\t/* overflow even without digits */\n+\t || ((dn->digits-*scale-1)>DECNUMMAXE)) { /* overflow */\n+      decNumberZero(dn);\n+      return NULL;}\n+    }\n+  if (digits==0) return dn;\t\t/* result was zero */\n+\n+  /* copy the digits to the number's units, starting at the lsu */\n+  /* [unrolled] */\n+  for (;;) {\t\t\t\t/* forever */\n+    /* left nibble first */\n+    nib=(unsigned)(*last & 0xf0)>>4;\n+    /* got a digit, in nib */\n+    if (nib>9) {decNumberZero(dn); return NULL;}\n+\n+    if (cut==0) *up=(Unit)nib;\n+     else *up=(Unit)(*up+nib*DECPOWERS[cut]);\n+    digits--;\n+    if (digits==0) break;\t\t/* got them all */\n+    cut++;\n+    if (cut==DECDPUN) {\n+      up++;\n+      cut=0;\n+      }\n+    last--;\t\t\t\t/* ready for next */\n+    nib=*last & 0x0f;\t\t\t/* get right nibble */\n+    if (nib>9) {decNumberZero(dn); return NULL;}\n+\n+    /* got a digit, in nib */\n+    if (cut==0) *up=(Unit)nib;\n+     else *up=(Unit)(*up+nib*DECPOWERS[cut]);\n+    digits--;\n+    if (digits==0) break;\t\t/* got them all */\n+    cut++;\n+    if (cut==DECDPUN) {\n+      up++;\n+      cut=0;\n+      }\n+    } /* forever */\n+\n+  return dn;\n+  } /* decPackedToNumber */\n+"}, {"sha": "c76aa09631e701c98e94a29ce2ef214878131514", "filename": "libdecnumber/decPacked.h", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FdecPacked.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FdecPacked.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecPacked.h?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb", "patch": "@@ -0,0 +1,70 @@\n+/* Packed decimal conversion module header for the decNumber C Library.\n+   Copyright (C) 2007 Free Software Foundation, Inc.\n+   Contributed by IBM Corporation.  Author Mike Cowlishaw.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 2, or (at your option) any later\n+   version.\n+\n+   In addition to the permissions in the GNU General Public License,\n+   the Free Software Foundation gives you unlimited permission to link\n+   the compiled version of this file into combinations with other\n+   programs, and to distribute those combinations without any\n+   restriction coming from the use of this file.  (The General Public\n+   License restrictions do apply in other respects; for example, they\n+   cover modification of the file, and distribution when not linked\n+   into a combine executable.)\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+   02110-1301, USA.  */\n+\n+/* ------------------------------------------------------------------ */\n+/* Packed Decimal conversion module header\t\t\t      */\n+/* ------------------------------------------------------------------ */\n+\n+#if !defined(DECPACKED)\n+  #define DECPACKED\n+  #define DECPNAME     \"decPacked\"\t\t\t/* Short name */\n+  #define DECPFULLNAME \"Packed Decimal conversions\"   /* Verbose name */\n+  #define DECPAUTHOR   \"Mike Cowlishaw\"\t\t      /* Who to blame */\n+\n+  #define DECPACKED_DefP 32\t\t/* default precision\t      */\n+\n+  #ifndef  DECNUMDIGITS\n+    #define DECNUMDIGITS DECPACKED_DefP /* size if not already defined*/\n+  #endif\n+  #include \"decNumber.h\"\t\t/* context and number library */\n+\n+  /* Sign nibble constants\t\t\t\t\t      */\n+  #if !defined(DECPPLUSALT)\n+    #define DECPPLUSALT\t 0x0A /* alternate plus\t nibble\t\t      */\n+    #define DECPMINUSALT 0x0B /* alternate minus nibble\t\t      */\n+    #define DECPPLUS\t 0x0C /* preferred plus\t nibble\t\t      */\n+    #define DECPMINUS\t 0x0D /* preferred minus nibble\t\t      */\n+    #define DECPPLUSALT2 0x0E /* alternate plus\t nibble\t\t      */\n+    #define DECPUNSIGNED 0x0F /* alternate plus\t nibble (unsigned)    */\n+  #endif\n+\n+  /* ---------------------------------------------------------------- */\n+  /* decPacked public routines\t\t\t\t\t      */\n+  /* ---------------------------------------------------------------- */\n+\n+  #include \"decPackedSymbols.h\"\n+\n+  /* Conversions\t\t\t\t\t\t      */\n+  uint8_t * decPackedFromNumber(uint8_t *, int32_t, int32_t *,\n+\t\t\t\tconst decNumber *);\n+  decNumber * decPackedToNumber(const uint8_t *, int32_t, const int32_t *,\n+\t\t\t\tdecNumber *);\n+\n+#endif"}, {"sha": "862db401fc98ce45ad7fe4471d7c740f411df2e7", "filename": "libdecnumber/decPackedSymbols.h", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FdecPackedSymbols.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FdecPackedSymbols.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecPackedSymbols.h?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb", "patch": "@@ -0,0 +1,9 @@\n+#if !defined(DECPACKEDSYMBOLS)\n+#define DECPACKEDSYMBOLS\n+\n+#ifdef IN_LIBGCC2\n+#define decPackedFromNumber __decPackedFromNumber\n+#define decPackedToNumber __decPackedToNumber\n+#endif\n+\n+#endif"}, {"sha": "6ec9b7f735f6984ef1dd8fdc691a523a0aeb373b", "filename": "libdecnumber/decQuad.c", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FdecQuad.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FdecQuad.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecQuad.c?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb", "patch": "@@ -0,0 +1,146 @@\n+/* decQuad module for the decNumber C Library.\n+   Copyright (C) 2007 Free Software Foundation, Inc.\n+   Contributed by IBM Corporation.  Author Mike Cowlishaw.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 2, or (at your option) any later\n+   version.\n+\n+   In addition to the permissions in the GNU General Public License,\n+   the Free Software Foundation gives you unlimited permission to link\n+   the compiled version of this file into combinations with other\n+   programs, and to distribute those combinations without any\n+   restriction coming from the use of this file.  (The General Public\n+   License restrictions do apply in other respects; for example, they\n+   cover modification of the file, and distribution when not linked\n+   into a combine executable.)\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+   02110-1301, USA.  */\n+\n+/* ------------------------------------------------------------------ */\n+/* decQuad.c -- decQuad operations module\t\t\t      */\n+/* ------------------------------------------------------------------ */\n+/* This module comprises decQuad operations (including conversions)   */\n+/* ------------------------------------------------------------------ */\n+\n+#include \"decContext.h\"\t      /* public includes */\n+#include \"decQuad.h\"\t      /* .. */\n+\n+/* Constant mappings for shared code */\n+#define DECPMAX\t    DECQUAD_Pmax\n+#define DECEMIN\t    DECQUAD_Emin\n+#define DECEMAX\t    DECQUAD_Emax\n+#define DECEMAXD    DECQUAD_EmaxD\n+#define DECBYTES    DECQUAD_Bytes\n+#define DECSTRING   DECQUAD_String\n+#define DECECONL    DECQUAD_EconL\n+#define DECBIAS\t    DECQUAD_Bias\n+#define DECLETS\t    DECQUAD_Declets\n+#define DECQTINY   (-DECQUAD_Bias)\n+\n+/* Type and function mappings for shared code */\n+#define decFloat\t\tdecQuad\t\t  /* Type name */\n+\n+/* Utilities and conversions (binary results, extractors, etc.) */\n+#define decFloatFromBCD\t\tdecQuadFromBCD\n+#define decFloatFromInt32\tdecQuadFromInt32\n+#define decFloatFromPacked\tdecQuadFromPacked\n+#define decFloatFromString\tdecQuadFromString\n+#define decFloatFromUInt32\tdecQuadFromUInt32\n+#define decFloatFromWider\tdecQuadFromWider\n+#define decFloatGetCoefficient\tdecQuadGetCoefficient\n+#define decFloatGetExponent\tdecQuadGetExponent\n+#define decFloatSetCoefficient\tdecQuadSetCoefficient\n+#define decFloatSetExponent\tdecQuadSetExponent\n+#define decFloatShow\t\tdecQuadShow\n+#define decFloatToBCD\t\tdecQuadToBCD\n+#define decFloatToEngString\tdecQuadToEngString\n+#define decFloatToInt32\t\tdecQuadToInt32\n+#define decFloatToInt32Exact\tdecQuadToInt32Exact\n+#define decFloatToPacked\tdecQuadToPacked\n+#define decFloatToString\tdecQuadToString\n+#define decFloatToUInt32\tdecQuadToUInt32\n+#define decFloatToUInt32Exact\tdecQuadToUInt32Exact\n+#define decFloatToWider\t\tdecQuadToWider\n+#define decFloatZero\t\tdecQuadZero\n+\n+/* Computational (result is a decFloat) */\n+#define decFloatAbs\t\tdecQuadAbs\n+#define decFloatAdd\t\tdecQuadAdd\n+#define decFloatAnd\t\tdecQuadAnd\n+#define decFloatDivide\t\tdecQuadDivide\n+#define decFloatDivideInteger\tdecQuadDivideInteger\n+#define decFloatFMA\t\tdecQuadFMA\n+#define decFloatInvert\t\tdecQuadInvert\n+#define decFloatLogB\t\tdecQuadLogB\n+#define decFloatMax\t\tdecQuadMax\n+#define decFloatMaxMag\t\tdecQuadMaxMag\n+#define decFloatMin\t\tdecQuadMin\n+#define decFloatMinMag\t\tdecQuadMinMag\n+#define decFloatMinus\t\tdecQuadMinus\n+#define decFloatMultiply\tdecQuadMultiply\n+#define decFloatNextMinus\tdecQuadNextMinus\n+#define decFloatNextPlus\tdecQuadNextPlus\n+#define decFloatNextToward\tdecQuadNextToward\n+#define decFloatOr\t\tdecQuadOr\n+#define decFloatPlus\t\tdecQuadPlus\n+#define decFloatQuantize\tdecQuadQuantize\n+#define decFloatReduce\t\tdecQuadReduce\n+#define decFloatRemainder\tdecQuadRemainder\n+#define decFloatRemainderNear\tdecQuadRemainderNear\n+#define decFloatRotate\t\tdecQuadRotate\n+#define decFloatScaleB\t\tdecQuadScaleB\n+#define decFloatShift\t\tdecQuadShift\n+#define decFloatSubtract\tdecQuadSubtract\n+#define decFloatToIntegralValue decQuadToIntegralValue\n+#define decFloatToIntegralExact decQuadToIntegralExact\n+#define decFloatXor\t\tdecQuadXor\n+\n+/* Comparisons */\n+#define decFloatCompare\t\tdecQuadCompare\n+#define decFloatCompareSignal\tdecQuadCompareSignal\n+#define decFloatCompareTotal\tdecQuadCompareTotal\n+#define decFloatCompareTotalMag decQuadCompareTotalMag\n+\n+/* Copies */\n+#define decFloatCanonical\tdecQuadCanonical\n+#define decFloatCopy\t\tdecQuadCopy\n+#define decFloatCopyAbs\t\tdecQuadCopyAbs\n+#define decFloatCopyNegate\tdecQuadCopyNegate\n+#define decFloatCopySign\tdecQuadCopySign\n+\n+/* Non-computational */\n+#define decFloatClass\t\tdecQuadClass\n+#define decFloatClassString\tdecQuadClassString\n+#define decFloatDigits\t\tdecQuadDigits\n+#define decFloatIsCanonical\tdecQuadIsCanonical\n+#define decFloatIsFinite\tdecQuadIsFinite\n+#define decFloatIsInfinite\tdecQuadIsInfinite\n+#define decFloatIsInteger\tdecQuadIsInteger\n+#define decFloatIsNaN\t\tdecQuadIsNaN\n+#define decFloatIsNormal\tdecQuadIsNormal\n+#define decFloatIsSignaling\tdecQuadIsSignaling\n+#define decFloatIsSignalling\tdecQuadIsSignalling\n+#define decFloatIsSigned\tdecQuadIsSigned\n+#define decFloatIsSubnormal\tdecQuadIsSubnormal\n+#define decFloatIsZero\t\tdecQuadIsZero\n+#define decFloatRadix\t\tdecQuadRadix\n+#define decFloatSameQuantum\tdecQuadSameQuantum\n+#define decFloatVersion\t\tdecQuadVersion\n+\n+\n+#include \"decNumberLocal.h\"   /* local includes (need DECPMAX) */\n+#include \"decCommon.c\"\t      /* non-arithmetic decFloat routines */\n+#include \"decBasic.c\"\t      /* basic formats routines */\n+"}, {"sha": "39f75d33e3a9b9feadde0f8d8dcaac20e5b2a88d", "filename": "libdecnumber/decQuad.h", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FdecQuad.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FdecQuad.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecQuad.h?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb", "patch": "@@ -0,0 +1,186 @@\n+/* decQuad module header for the decNumber C Library.\n+   Copyright (C) 2007 Free Software Foundation, Inc.\n+   Contributed by IBM Corporation.  Author Mike Cowlishaw.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 2, or (at your option) any later\n+   version.\n+\n+   In addition to the permissions in the GNU General Public License,\n+   the Free Software Foundation gives you unlimited permission to link\n+   the compiled version of this file into combinations with other\n+   programs, and to distribute those combinations without any\n+   restriction coming from the use of this file.  (The General Public\n+   License restrictions do apply in other respects; for example, they\n+   cover modification of the file, and distribution when not linked\n+   into a combine executable.)\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+   02110-1301, USA.  */\n+\n+/* ------------------------------------------------------------------ */\n+/* decQuad.h -- Decimal 128-bit format module header\t\t      */\n+/* ------------------------------------------------------------------ */\n+/* Please see decFloats.h for an overview and documentation details.  */\n+/* ------------------------------------------------------------------ */\n+/* This include file is always included by decSingle and decDouble,   */\n+/* and therefore also holds useful constants used by all three.\t      */\n+\n+#if !defined(DECQUAD)\n+  #define DECQUAD\n+\n+  #define DECQUADNAME\t      \"decimalQuad\"\t      /* Short name   */\n+  #define DECQUADTITLE\t      \"Decimal 128-bit datum\" /* Verbose name */\n+  #define DECQUADAUTHOR\t      \"Mike Cowlishaw\"\t      /* Who to blame */\n+\n+  /* parameters for decQuads */\n+  #define DECQUAD_Bytes\t   16\t   /* length\t\t\t      */\n+  #define DECQUAD_Pmax\t   34\t   /* maximum precision (digits)      */\n+  #define DECQUAD_Emin\t-6143\t   /* minimum adjusted exponent\t      */\n+  #define DECQUAD_Emax\t 6144\t   /* maximum adjusted exponent\t      */\n+  #define DECQUAD_EmaxD\t    4\t   /* maximum exponent digits\t      */\n+  #define DECQUAD_Bias\t 6176\t   /* bias for the exponent\t      */\n+  #define DECQUAD_String   43\t   /* maximum string length, +1\t      */\n+  #define DECQUAD_EconL\t   12\t   /* exponent continuation length    */\n+  #define DECQUAD_Declets  11\t   /* count of declets\t\t      */\n+  /* highest biased exponent (Elimit-1) */\n+  #define DECQUAD_Ehigh (DECQUAD_Emax + DECQUAD_Bias - (DECQUAD_Pmax-1))\n+\n+  /* Required include\t\t\t\t\t\t      */\n+  #include \"decContext.h\"\n+\n+  /* The decQuad decimal 128-bit type, accessible by bytes */\n+  typedef struct {\n+    uint8_t bytes[DECQUAD_Bytes];  /* fields: 1, 5, 12, 110 bits */\n+    } decQuad;\n+\n+  /* ---------------------------------------------------------------- */\n+  /* Shared constants\t\t\t\t\t\t      */\n+  /* ---------------------------------------------------------------- */\n+\n+  /* sign and special values [top 32-bits; last two bits are don't-care\n+     for Infinity on input, last bit don't-care for NaNs] */\n+  #define DECFLOAT_Sign\t 0x80000000\t/* 1 00000 00 Sign */\n+  #define DECFLOAT_NaN\t 0x7c000000\t/* 0 11111 00 NaN generic */\n+  #define DECFLOAT_qNaN\t 0x7c000000\t/* 0 11111 00 qNaN */\n+  #define DECFLOAT_sNaN\t 0x7e000000\t/* 0 11111 10 sNaN */\n+  #define DECFLOAT_Inf\t 0x78000000\t/* 0 11110 00 Infinity */\n+  #define DECFLOAT_MinSp 0x78000000\t/* minimum special value */\n+\t\t\t\t\t/* [specials are all >=MinSp] */\n+  /* Sign nibble constants\t\t\t\t\t      */\n+  #if !defined(DECPPLUSALT)\n+    #define DECPPLUSALT\t 0x0A /* alternate plus\t nibble\t\t      */\n+    #define DECPMINUSALT 0x0B /* alternate minus nibble\t\t      */\n+    #define DECPPLUS\t 0x0C /* preferred plus\t nibble\t\t      */\n+    #define DECPMINUS\t 0x0D /* preferred minus nibble\t\t      */\n+    #define DECPPLUSALT2 0x0E /* alternate plus\t nibble\t\t      */\n+    #define DECPUNSIGNED 0x0F /* alternate plus\t nibble (unsigned)    */\n+  #endif\n+\n+  /* ---------------------------------------------------------------- */\n+  /* Routines -- implemented as decFloat routines in common files     */\n+  /* ---------------------------------------------------------------- */\n+\n+  #include \"decQuadSymbols.h\"\n+\n+  /* Utilities and conversions, extractors, etc.) */\n+  extern decQuad * decQuadFromBCD(decQuad *, int32_t, const uint8_t *, int32_t);\n+  extern decQuad * decQuadFromInt32(decQuad *, int32_t);\n+  extern decQuad * decQuadFromPacked(decQuad *, int32_t, const uint8_t *);\n+  extern decQuad * decQuadFromString(decQuad *, const char *, decContext *);\n+  extern decQuad * decQuadFromUInt32(decQuad *, uint32_t);\n+  extern int32_t   decQuadGetCoefficient(const decQuad *, uint8_t *);\n+  extern int32_t   decQuadGetExponent(const decQuad *);\n+  extern decQuad * decQuadSetCoefficient(decQuad *, const uint8_t *, int32_t);\n+  extern decQuad * decQuadSetExponent(decQuad *, decContext *, int32_t);\n+  extern void\t   decQuadShow(const decQuad *, const char *);\n+  extern int32_t   decQuadToBCD(const decQuad *, int32_t *, uint8_t *);\n+  extern char\t * decQuadToEngString(const decQuad *, char *);\n+  extern int32_t   decQuadToInt32(const decQuad *, decContext *, enum rounding);\n+  extern int32_t   decQuadToInt32Exact(const decQuad *, decContext *, enum rounding);\n+  extern int32_t   decQuadToPacked(const decQuad *, int32_t *, uint8_t *);\n+  extern char\t * decQuadToString(const decQuad *, char *);\n+  extern uint32_t  decQuadToUInt32(const decQuad *, decContext *, enum rounding);\n+  extern uint32_t  decQuadToUInt32Exact(const decQuad *, decContext *, enum rounding);\n+  extern decQuad * decQuadZero(decQuad *);\n+\n+  /* Computational (result is a decQuad) */\n+  extern decQuad * decQuadAbs(decQuad *, const decQuad *, decContext *);\n+  extern decQuad * decQuadAdd(decQuad *, const decQuad *, const decQuad *, decContext *);\n+  extern decQuad * decQuadAnd(decQuad *, const decQuad *, const decQuad *, decContext *);\n+  extern decQuad * decQuadDivide(decQuad *, const decQuad *, const decQuad *, decContext *);\n+  extern decQuad * decQuadDivideInteger(decQuad *, const decQuad *, const decQuad *, decContext *);\n+  extern decQuad * decQuadFMA(decQuad *, const decQuad *, const decQuad *, const decQuad *, decContext *);\n+  extern decQuad * decQuadInvert(decQuad *, const decQuad *, decContext *);\n+  extern decQuad * decQuadLogB(decQuad *, const decQuad *, decContext *);\n+  extern decQuad * decQuadMax(decQuad *, const decQuad *, const decQuad *, decContext *);\n+  extern decQuad * decQuadMaxMag(decQuad *, const decQuad *, const decQuad *, decContext *);\n+  extern decQuad * decQuadMin(decQuad *, const decQuad *, const decQuad *, decContext *);\n+  extern decQuad * decQuadMinMag(decQuad *, const decQuad *, const decQuad *, decContext *);\n+  extern decQuad * decQuadMinus(decQuad *, const decQuad *, decContext *);\n+  extern decQuad * decQuadMultiply(decQuad *, const decQuad *, const decQuad *, decContext *);\n+  extern decQuad * decQuadNextMinus(decQuad *, const decQuad *, decContext *);\n+  extern decQuad * decQuadNextPlus(decQuad *, const decQuad *, decContext *);\n+  extern decQuad * decQuadNextToward(decQuad *, const decQuad *, const decQuad *, decContext *);\n+  extern decQuad * decQuadOr(decQuad *, const decQuad *, const decQuad *, decContext *);\n+  extern decQuad * decQuadPlus(decQuad *, const decQuad *, decContext *);\n+  extern decQuad * decQuadQuantize(decQuad *, const decQuad *, const decQuad *, decContext *);\n+  extern decQuad * decQuadReduce(decQuad *, const decQuad *, decContext *);\n+  extern decQuad * decQuadRemainder(decQuad *, const decQuad *, const decQuad *, decContext *);\n+  extern decQuad * decQuadRemainderNear(decQuad *, const decQuad *, const decQuad *, decContext *);\n+  extern decQuad * decQuadRotate(decQuad *, const decQuad *, const decQuad *, decContext *);\n+  extern decQuad * decQuadScaleB(decQuad *, const decQuad *, const decQuad *, decContext *);\n+  extern decQuad * decQuadShift(decQuad *, const decQuad *, const decQuad *, decContext *);\n+  extern decQuad * decQuadSubtract(decQuad *, const decQuad *, const decQuad *, decContext *);\n+  extern decQuad * decQuadToIntegralValue(decQuad *, const decQuad *, decContext *, enum rounding);\n+  extern decQuad * decQuadToIntegralExact(decQuad *, const decQuad *, decContext *);\n+  extern decQuad * decQuadXor(decQuad *, const decQuad *, const decQuad *, decContext *);\n+\n+  /* Comparisons */\n+  extern decQuad * decQuadCompare(decQuad *, const decQuad *, const decQuad *, decContext *);\n+  extern decQuad * decQuadCompareSignal(decQuad *, const decQuad *, const decQuad *, decContext *);\n+  extern decQuad * decQuadCompareTotal(decQuad *, const decQuad *, const decQuad *);\n+  extern decQuad * decQuadCompareTotalMag(decQuad *, const decQuad *, const decQuad *);\n+\n+  /* Copies */\n+  extern decQuad * decQuadCanonical(decQuad *, const decQuad *);\n+  extern decQuad * decQuadCopy(decQuad *, const decQuad *);\n+  extern decQuad * decQuadCopyAbs(decQuad *, const decQuad *);\n+  extern decQuad * decQuadCopyNegate(decQuad *, const decQuad *);\n+  extern decQuad * decQuadCopySign(decQuad *, const decQuad *, const decQuad *);\n+\n+  /* Non-computational */\n+  extern enum decClass decQuadClass(const decQuad *);\n+  extern const char *  decQuadClassString(const decQuad *);\n+  extern uint32_t      decQuadDigits(const decQuad *);\n+  extern uint32_t      decQuadIsCanonical(const decQuad *);\n+  extern uint32_t      decQuadIsFinite(const decQuad *);\n+  extern uint32_t      decQuadIsInteger(const decQuad *);\n+  extern uint32_t      decQuadIsInfinite(const decQuad *);\n+  extern uint32_t      decQuadIsNaN(const decQuad *);\n+  extern uint32_t      decQuadIsNormal(const decQuad *);\n+  extern uint32_t      decQuadIsSignaling(const decQuad *);\n+  extern uint32_t      decQuadIsSignalling(const decQuad *);\n+  extern uint32_t      decQuadIsSigned(const decQuad *);\n+  extern uint32_t      decQuadIsSubnormal(const decQuad *);\n+  extern uint32_t      decQuadIsZero(const decQuad *);\n+  extern uint32_t      decQuadRadix(const decQuad *);\n+  extern uint32_t      decQuadSameQuantum(const decQuad *, const decQuad *);\n+  extern const char *  decQuadVersion(void);\n+\n+  /* decNumber conversions; these are implemented as macros so as not  */\n+  /* to force a dependency on decimal128 and decNumber in decQuad.     */\n+  #define decQuadToNumber(dq, dn) decimal128ToNumber((decimal128 *)(dq), dn)\n+  #define decQuadFromNumber(dq, dn, set) (decQuad *)decimal128FromNumber((decimal128 *)(dq), dn, set)\n+\n+#endif"}, {"sha": "5f614d40dc490778fa42df8e3e99194df0105c59", "filename": "libdecnumber/decQuadSymbols.h", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FdecQuadSymbols.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FdecQuadSymbols.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecQuadSymbols.h?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb", "patch": "@@ -0,0 +1,82 @@\n+#if !defined(DECQUADSYMBOLS)\n+#define DECQUADSYMBOLS\n+\n+#ifdef IN_LIBGCC2\n+#define decQuadAbs __decQuadAbs\n+#define decQuadAdd __decQuadAdd\n+#define decQuadAnd __decQuadAnd\n+#define decQuadCanonical __decQuadCanonical\n+#define decQuadClass __decQuadClass\n+#define decQuadClassString __decQuadClassString\n+#define decQuadCompare __decQuadCompare\n+#define decQuadCompareSignal __decQuadCompareSignal\n+#define decQuadCompareTotal __decQuadCompareTotal\n+#define decQuadCompareTotalMag __decQuadCompareTotalMag\n+#define decQuadCopy __decQuadCopy\n+#define decQuadCopyAbs __decQuadCopyAbs\n+#define decQuadCopyNegate __decQuadCopyNegate\n+#define decQuadCopySign __decQuadCopySign\n+#define decQuadDigits __decQuadDigits\n+#define decQuadDivide __decQuadDivide\n+#define decQuadDivideInteger __decQuadDivideInteger\n+#define decQuadFMA __decQuadFMA\n+#define decQuadFromBCD __decQuadFromBCD\n+#define decQuadFromInt32 __decQuadFromInt32\n+#define decQuadFromPacked __decQuadFromPacked\n+#define decQuadFromString __decQuadFromString\n+#define decQuadFromUInt32 __decQuadFromUInt32\n+#define decQuadGetCoefficient __decQuadGetCoefficient\n+#define decQuadGetExponent __decQuadGetExponent\n+#define decQuadInvert __decQuadInvert\n+#define decQuadIsCanonical __decQuadIsCanonical\n+#define decQuadIsFinite __decQuadIsFinite\n+#define decQuadIsInfinite __decQuadIsInfinite\n+#define decQuadIsInteger __decQuadIsInteger\n+#define decQuadIsNaN __decQuadIsNaN\n+#define decQuadIsNormal __decQuadIsNormal\n+#define decQuadIsSignaling __decQuadIsSignaling\n+#define decQuadIsSignalling __decQuadIsSignalling\n+#define decQuadIsSigned __decQuadIsSigned\n+#define decQuadIsSubnormal __decQuadIsSubnormal\n+#define decQuadIsZero __decQuadIsZero\n+#define decQuadLogB __decQuadLogB\n+#define decQuadMax __decQuadMax\n+#define decQuadMaxMag __decQuadMaxMag\n+#define decQuadMin __decQuadMin\n+#define decQuadMinMag __decQuadMinMag\n+#define decQuadMinus __decQuadMinus\n+#define decQuadMultiply __decQuadMultiply\n+#define decQuadNextMinus __decQuadNextMinus\n+#define decQuadNextPlus __decQuadNextPlus\n+#define decQuadNextToward __decQuadNextToward\n+#define decQuadOr __decQuadOr\n+#define decQuadPlus __decQuadPlus\n+#define decQuadQuantize __decQuadQuantize\n+#define decQuadRadix __decQuadRadix\n+#define decQuadReduce __decQuadReduce\n+#define decQuadRemainder __decQuadRemainder\n+#define decQuadRemainderNear __decQuadRemainderNear\n+#define decQuadRotate __decQuadRotate\n+#define decQuadSameQuantum __decQuadSameQuantum\n+#define decQuadScaleB __decQuadScaleB\n+#define decQuadSetCoefficient __decQuadSetCoefficient\n+#define decQuadSetExponent __decQuadSetExponent\n+#define decQuadShift __decQuadShift\n+#define decQuadShow __decQuadShow\n+#define decQuadSubtract __decQuadSubtract\n+#define decQuadToBCD __decQuadToBCD\n+#define decQuadToEngString __decQuadToEngString\n+#define decQuadToInt32 __decQuadToInt32\n+#define decQuadToInt32Exact __decQuadToInt32Exact\n+#define decQuadToIntegralExact __decQuadToIntegralExact\n+#define decQuadToIntegralValue __decQuadToIntegralValue\n+#define decQuadToPacked __decQuadToPacked\n+#define decQuadToString __decQuadToString\n+#define decQuadToUInt32 __decQuadToUInt32\n+#define decQuadToUInt32Exact __decQuadToUInt32Exact\n+#define decQuadVersion __decQuadVersion\n+#define decQuadXor __decQuadXor\n+#define decQuadZero __decQuadZero\n+#endif\n+\n+#endif"}, {"sha": "112395970fe1afa16549df0cb2edf20c05497f8e", "filename": "libdecnumber/decSingle.c", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FdecSingle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FdecSingle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecSingle.c?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb", "patch": "@@ -0,0 +1,85 @@\n+/* decSingle module for the decNumber C Library.\n+   Copyright (C) 2007 Free Software Foundation, Inc.\n+   Contributed by IBM Corporation.  Author Mike Cowlishaw.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 2, or (at your option) any later\n+   version.\n+\n+   In addition to the permissions in the GNU General Public License,\n+   the Free Software Foundation gives you unlimited permission to link\n+   the compiled version of this file into combinations with other\n+   programs, and to distribute those combinations without any\n+   restriction coming from the use of this file.  (The General Public\n+   License restrictions do apply in other respects; for example, they\n+   cover modification of the file, and distribution when not linked\n+   into a combine executable.)\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+   02110-1301, USA.  */\n+\n+/* ------------------------------------------------------------------ */\n+/* decSingle.c -- decSingle operations module\t\t\t      */\n+/* ------------------------------------------------------------------ */\n+/* This module comprises decSingle operations (including conversions) */\n+/* ------------------------------------------------------------------ */\n+\n+#include \"decContext.h\"\t      /* public includes */\n+#include \"decSingle.h\"\t      /* public includes */\n+\n+/* Constant mappings for shared code */\n+#define DECPMAX\t    DECSINGLE_Pmax\n+#define DECEMIN\t    DECSINGLE_Emin\n+#define DECEMAX\t    DECSINGLE_Emax\n+#define DECEMAXD    DECSINGLE_EmaxD\n+#define DECBYTES    DECSINGLE_Bytes\n+#define DECSTRING   DECSINGLE_String\n+#define DECECONL    DECSINGLE_EconL\n+#define DECBIAS\t    DECSINGLE_Bias\n+#define DECLETS\t    DECSINGLE_Declets\n+#define DECQTINY    (-DECSINGLE_Bias)\n+/* parameters of next-wider format */\n+#define DECWBYTES   DECDOUBLE_Bytes\n+#define DECWPMAX    DECDOUBLE_Pmax\n+#define DECWECONL   DECDOUBLE_EconL\n+#define DECWBIAS    DECDOUBLE_Bias\n+\n+/* Type and function mappings for shared code */\n+#define decFloat\t\tdecSingle\t  /* Type name */\n+#define decFloatWider\t\tdecDouble\t  /* Type name */\n+\n+/* Utility (binary results, extractors, etc.) */\n+#define decFloatFromBCD\t\tdecSingleFromBCD\n+#define decFloatFromPacked\tdecSingleFromPacked\n+#define decFloatFromString\tdecSingleFromString\n+#define decFloatFromWider\tdecSingleFromWider\n+#define decFloatGetCoefficient\tdecSingleGetCoefficient\n+#define decFloatGetExponent\tdecSingleGetExponent\n+#define decFloatSetCoefficient\tdecSingleSetCoefficient\n+#define decFloatSetExponent\tdecSingleSetExponent\n+#define decFloatShow\t\tdecSingleShow\n+#define decFloatToBCD\t\tdecSingleToBCD\n+#define decFloatToEngString\tdecSingleToEngString\n+#define decFloatToPacked\tdecSingleToPacked\n+#define decFloatToString\tdecSingleToString\n+#define decFloatToWider\t\tdecSingleToWider\n+#define decFloatZero\t\tdecSingleZero\n+\n+/* Non-computational */\n+#define decFloatRadix\t\tdecSingleRadix\n+#define decFloatVersion\t\tdecSingleVersion\n+\n+#include \"decNumberLocal.h\"   /* local includes (need DECPMAX) */\n+#include \"decCommon.c\"\t      /* non-basic decFloat routines */\n+/* [Do not include decBasic.c for decimal32] */\n+"}, {"sha": "8dd1bd38ac0d8a9e504e74f08ed47226cad1d30f", "filename": "libdecnumber/decSingle.h", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FdecSingle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FdecSingle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecSingle.h?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb", "patch": "@@ -0,0 +1,101 @@\n+/* decSingle module header for the decNumber C Library.\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by IBM Corporation.  Author Mike Cowlishaw.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 2, or (at your option) any later\n+   version.\n+\n+   In addition to the permissions in the GNU General Public License,\n+   the Free Software Foundation gives you unlimited permission to link\n+   the compiled version of this file into combinations with other\n+   programs, and to distribute those combinations without any\n+   restriction coming from the use of this file.  (The General Public\n+   License restrictions do apply in other respects; for example, they\n+   cover modification of the file, and distribution when not linked\n+   into a combine executable.)\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+   02110-1301, USA.  */\n+\n+/* ------------------------------------------------------------------ */\n+/* decSingle.h -- Decimal 32-bit format module header\t\t      */\n+/* ------------------------------------------------------------------ */\n+/* Please see decFloats.h for an overview and documentation details.  */\n+/* ------------------------------------------------------------------ */\n+\n+#if !defined(DECSINGLE)\n+  #define DECSINGLE\n+\n+  #define DECSINGLENAME\t      \"decSingle\"\t      /* Short name   */\n+  #define DECSINGLETITLE      \"Decimal 32-bit datum\"  /* Verbose name */\n+  #define DECSINGLEAUTHOR     \"Mike Cowlishaw\"\t      /* Who to blame */\n+\n+  /* parameters for decSingles */\n+  #define DECSINGLE_Bytes    4\t   /* length\t\t\t      */\n+  #define DECSINGLE_Pmax     7\t   /* maximum precision (digits)      */\n+  #define DECSINGLE_Emin   -95\t   /* minimum adjusted exponent\t      */\n+  #define DECSINGLE_Emax    96\t   /* maximum adjusted exponent\t      */\n+  #define DECSINGLE_EmaxD    3\t   /* maximum exponent digits\t      */\n+  #define DECSINGLE_Bias   101\t   /* bias for the exponent\t      */\n+  #define DECSINGLE_String  16\t   /* maximum string length, +1\t      */\n+  #define DECSINGLE_EconL    6\t   /* exponent continuation length    */\n+  #define DECSINGLE_Declets  2\t   /* count of declets\t\t      */\n+  /* highest biased exponent (Elimit-1) */\n+  #define DECSINGLE_Ehigh (DECSINGLE_Emax + DECSINGLE_Bias - (DECSINGLE_Pmax-1))\n+\n+  /* Required includes\t\t\t\t\t\t      */\n+  #include \"decContext.h\"\n+  #include \"decQuad.h\"\n+  #include \"decDouble.h\"\n+\n+  /* The decSingle decimal 32-bit type, accessible by bytes */\n+  typedef struct {\n+    uint8_t bytes[DECSINGLE_Bytes];\t/* fields: 1, 5, 6, 20 bits */\n+    } decSingle;\n+\n+  /* ---------------------------------------------------------------- */\n+  /* Routines -- implemented as decFloat routines in common files     */\n+  /* ---------------------------------------------------------------- */\n+\n+  #include \"decSingleSymbols.h\"\n+\n+  /* Utilities (binary argument(s) or result, extractors, etc.) */\n+  extern decSingle * decSingleFromBCD(decSingle *, int32_t, const uint8_t *, int32_t);\n+  extern decSingle * decSingleFromPacked(decSingle *, int32_t, const uint8_t *);\n+  extern decSingle * decSingleFromString(decSingle *, const char *, decContext *);\n+  extern decSingle * decSingleFromWider(decSingle *, const decDouble *, decContext *);\n+  extern int32_t     decSingleGetCoefficient(const decSingle *, uint8_t *);\n+  extern int32_t     decSingleGetExponent(const decSingle *);\n+  extern decSingle * decSingleSetCoefficient(decSingle *, const uint8_t *, int32_t);\n+  extern decSingle * decSingleSetExponent(decSingle *, decContext *, int32_t);\n+  extern void\t     decSingleShow(const decSingle *, const char *);\n+  extern int32_t     decSingleToBCD(const decSingle *, int32_t *, uint8_t *);\n+  extern char\t   * decSingleToEngString(const decSingle *, char *);\n+  extern int32_t     decSingleToPacked(const decSingle *, int32_t *, uint8_t *);\n+  extern char\t   * decSingleToString(const decSingle *, char *);\n+  extern decDouble * decSingleToWider(const decSingle *, decDouble *);\n+  extern decSingle * decSingleZero(decSingle *);\n+\n+  /* (No Arithmetic routines for decSingle) */\n+\n+  /* Non-computational */\n+  extern uint32_t     decSingleRadix(const decSingle *);\n+  extern const char * decSingleVersion(void);\n+\n+  /* decNumber conversions; these are implemented as macros so as not  */\n+  /* to force a dependency on decimal32 and decNumber in decSingle.    */\n+  #define decSingleToNumber(dq, dn) decimal32ToNumber((decimal32 *)(dq), dn)\n+  #define decSingleFromNumber(dq, dn, set) (decSingle *)decimal32FromNumber((decimal32 *)(dq), dn, set)\n+\n+#endif"}, {"sha": "6eee0e5cbbc6fc2bf47e8c7685cb4b6c028d15c0", "filename": "libdecnumber/decSingleSymbols.h", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FdecSingleSymbols.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2FdecSingleSymbols.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecSingleSymbols.h?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb", "patch": "@@ -0,0 +1,24 @@\n+#if !defined(DECSINGLESYMBOLS)\n+#define DECSINGLESYMBOLS\n+\n+#ifdef IN_LIBGCC2\n+#define decSingleFromBCD __decSingleFromBCD\n+#define decSingleFromPacked __decSingleFromPacked\n+#define decSingleFromString __decSingleFromString\n+#define decSingleFromWider __decSingleFromWider\n+#define decSingleGetCoefficient __decSingleGetCoefficient\n+#define decSingleGetExponent __decSingleGetExponent\n+#define decSingleRadix __decSingleRadix\n+#define decSingleSetCoefficient __decSingleSetCoefficient\n+#define decSingleSetExponent __decSingleSetExponent\n+#define decSingleShow __decSingleShow\n+#define decSingleToBCD __decSingleToBCD\n+#define decSingleToEngString __decSingleToEngString\n+#define decSingleToPacked __decSingleToPacked\n+#define decSingleToString __decSingleToString\n+#define decSingleToWider __decSingleToWider\n+#define decSingleVersion __decSingleVersion\n+#define decSingleZero __decSingleZero\n+#endif\n+\n+#endif"}, {"sha": "2cbed947ba78d032326254b5e038e1b4e2d836ee", "filename": "libdecnumber/decUtility.c", "status": "removed", "additions": 0, "deletions": 360, "changes": 360, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfd9cff5c5bbcbea235e60529138848df5222b0c/libdecnumber%2FdecUtility.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfd9cff5c5bbcbea235e60529138848df5222b0c/libdecnumber%2FdecUtility.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecUtility.c?ref=bfd9cff5c5bbcbea235e60529138848df5222b0c", "patch": "@@ -1,360 +0,0 @@\n-/* Utility functions for decimal floating point support via decNumber.\n-   Copyright (C) 2005 Free Software Foundation, Inc.\n-   Contributed by IBM Corporation.  Author Mike Cowlishaw.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 2, or (at your option) any later\n-   version.\n-\n-   In addition to the permissions in the GNU General Public License,\n-   the Free Software Foundation gives you unlimited permission to link\n-   the compiled version of this file into combinations with other\n-   programs, and to distribute those combinations without any\n-   restriction coming from the use of this file.  (The General Public\n-   License restrictions do apply in other respects; for example, they\n-   cover modification of the file, and distribution when not linked\n-   into a combine executable.)\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING.  If not, write to the Free\n-   Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n-   02110-1301, USA.  */\n-\n-#include \"config.h\"\n-#include \"decNumber.h\"          /* base number library */\n-#include \"decNumberLocal.h\"     /* decNumber local types, etc. */\n-#include \"decUtility.h\"         /* utility routines */\n-\n-/* ================================================================== */\n-/* Shared utility routines                                            */\n-/* ================================================================== */\n-\n-/* define and include the conversion tables to use */\n-#define DEC_BIN2DPD 1\t\t/* used for all sizes */\n-#if DECDPUN==3\n-#define DEC_DPD2BIN 1\n-#else\n-#define DEC_DPD2BCD 1\n-#endif\n-#include \"decDPD.h\"\t\t/* lookup tables */\n-\n-/* The maximum number of decNumberUnits we need for a working copy of */\n-/* the units array is the ceiling of digits/DECDPUN, where digits is */\n-/* the maximum number of digits in any of the formats for which this */\n-/* is used.  We do not want to include decimal128.h, so, as a very */\n-/* special case, that number is defined here. */\n-#define DECMAX754   34\n-#define DECMAXUNITS ((DECMAX754+DECDPUN-1)/DECDPUN)\n-\n-/* ------------------------------------------------------------------ */\n-/* decDensePackCoeff -- densely pack coefficient into DPD form        */\n-/*                                                                    */\n-/*   dn is the source number (assumed valid, max DECMAX754 digits)    */\n-/*   bytes is the target's byte array                                 */\n-/*   len is length of target format's byte array                      */\n-/*   shift is the number of 0 digits to add on the right (normally 0) */\n-/*                                                                    */\n-/* The coefficient must be known small enough to fit, and is filled   */\n-/* in from the right (least significant first).  Note that the full   */\n-/* coefficient is copied, including the leading 'odd' digit.  This    */\n-/* digit is retrieved and packed into the combination field by the    */\n-/* caller.                                                            */\n-/*                                                                    */\n-/* shift is used for 'fold-down' padding.                             */\n-/*                                                                    */\n-/* No error is possible.                                              */\n-/* ------------------------------------------------------------------ */\n-void\n-decDensePackCoeff (const decNumber * dn, uByte * bytes, Int len, Int shift)\n-{\n-  Int cut;\t\t\t/* work */\n-  Int n;\t\t\t/* output bunch counter */\n-  Int digits = dn->digits;\t/* digit countdown */\n-  uInt dpd;\t\t\t/* densely packed decimal value */\n-  uInt bin;\t\t\t/* binary value 0-999 */\n-  uByte *bout;\t\t\t/* -> current output byte */\n-  const Unit *inu = dn->lsu;\t/* -> current input unit */\n-  Unit uar[DECMAXUNITS];\t/* working copy of units, iff shifted */\n-#if DECDPUN!=3\t\t\t/* not fast path */\n-  Unit in;\t\t\t/* current input unit */\n-#endif\n-\n-  if (shift != 0)\n-    {\t\t\t\t/* shift towards most significant required */\n-      /* shift the units array to the left by pad digits and copy */\n-      /* [this code is a special case of decShiftToMost, which could */\n-      /* be used instead if exposed and the array were copied first] */\n-      Unit *target, *first;\t/* work */\n-      const Unit *source;\t/* work */\n-      uInt next = 0;\t\t/* work */\n-\n-      source = dn->lsu + D2U (digits) - 1;\t/* where msu comes from */\n-      first = uar + D2U (digits + shift) - 1;\t/* where msu will end up */\n-      target = uar + D2U (digits) - 1 + D2U (shift);\t/* where upper part of first cut goes */\n-\n-      cut = (DECDPUN - shift % DECDPUN) % DECDPUN;\n-      for (; source >= dn->lsu; source--, target--)\n-\t{\n-\t  /* split the source Unit and accumulate remainder for next */\n-\t  uInt rem = *source % powers[cut];\n-\t  next += *source / powers[cut];\n-\t  if (target <= first)\n-\t    *target = (Unit) next;\t/* write to target iff valid */\n-\t  next = rem * powers[DECDPUN - cut];\t/* save remainder for next Unit */\n-\t}\n-      /* propagate remainder to one below and clear the rest */\n-      for (; target >= uar; target--)\n-\t{\n-\t  *target = (Unit) next;\n-\t  next = 0;\n-\t}\n-      digits += shift;\t\t/* add count (shift) of zeros added */\n-      inu = uar;\t\t/* use units in working array */\n-    }\n-\n-  /* densely pack the coefficient into the byte array, starting from\n-     the right (optionally padded) */\n-  bout = &bytes[len - 1];\t/* rightmost result byte for phase */\n-\n-#if DECDPUN!=3\t\t\t/* not fast path */\n-  in = *inu;\t\t\t/* prime */\n-  cut = 0;\t\t\t/* at lowest digit */\n-  bin = 0;\t\t\t/* [keep compiler quiet] */\n-#endif\n-\n-  for (n = 0; digits > 0; n++)\n-    {\t\t\t\t/* each output bunch */\n-#if DECDPUN==3\t\t\t/* fast path, 3-at-a-time */\n-      bin = *inu;\t\t/* 3 ready for convert */\n-      digits -= 3;\t\t/* [may go negative] */\n-      inu++;\t\t\t/* may need another */\n-\n-#else /* must collect digit-by-digit */\n-      Unit dig;\t\t\t/* current digit */\n-      Int j;\t\t\t/* digit-in-bunch count */\n-      for (j = 0; j < 3; j++)\n-\t{\n-#if DECDPUN<=4\n-\t  Unit temp = (Unit) ((uInt) (in * 6554) >> 16);\n-\t  dig = (Unit) (in - X10 (temp));\n-\t  in = temp;\n-#else\n-\t  dig = in % 10;\n-\t  in = in / 10;\n-#endif\n-\n-\t  if (j == 0)\n-\t    bin = dig;\n-\t  else if (j == 1)\n-\t    bin += X10 (dig);\n-\t  else\t\t\t/* j==2 */\n-\t    bin += X100 (dig);\n-\n-\t  digits--;\n-\t  if (digits == 0)\n-\t    break;\t\t/* [also protects *inu below] */\n-\t  cut++;\n-\t  if (cut == DECDPUN)\n-\t    {\n-\t      inu++;\n-\t      in = *inu;\n-\t      cut = 0;\n-\t    }\n-\t}\n-#endif\n-      /* here we have 3 digits in bin, or have used all input digits */\n-\n-      dpd = BIN2DPD[bin];\n-\n-      /* write bunch (bcd) to byte array */\n-      switch (n & 0x03)\n-\t{\t\t\t/* phase 0-3 */\n-\tcase 0:\n-\t  *bout = (uByte) dpd;\t/* [top 2 bits truncated] */\n-\t  bout--;\n-\t  *bout = (uByte) (dpd >> 8);\n-\t  break;\n-\tcase 1:\n-\t  *bout |= (uByte) (dpd << 2);\n-\t  bout--;\n-\t  *bout = (uByte) (dpd >> 6);\n-\t  break;\n-\tcase 2:\n-\t  *bout |= (uByte) (dpd << 4);\n-\t  bout--;\n-\t  *bout = (uByte) (dpd >> 4);\n-\t  break;\n-\tcase 3:\n-\t  *bout |= (uByte) (dpd << 6);\n-\t  bout--;\n-\t  *bout = (uByte) (dpd >> 2);\n-\t  bout--;\n-\t  break;\n-\t}\t\t\t/* switch */\n-    }\t\t\t\t/* n bunches */\n-  return;\n-}\n-\n-/* ------------------------------------------------------------------ */\n-/* decDenseUnpackCoeff -- unpack a format's coefficient               */\n-/*                                                                    */\n-/*   byte is the source's byte array                                  */\n-/*   len is length of the source's byte array                         */\n-/*   dn is the target number, with 7, 16, or 34-digit space.          */\n-/*   bunches is the count of DPD groups in the decNumber (2, 5, or 11)*/\n-/*   odd is 1 if there is a non-zero leading 10-bit group containing  */\n-/*     a single digit, 0 otherwise                                    */\n-/*                                                                    */\n-/* (This routine works on a copy of the number, if necessary, where   */\n-/* an extra 10-bit group is prefixed to the coefficient continuation  */\n-/* to hold the most significant digit if the latter is non-0.)        */\n-/*                                                                    */\n-/* dn->digits is set, but not the sign or exponent.                   */\n-/* No error is possible [the redundant 888 codes are allowed].        */\n-/* ------------------------------------------------------------------ */\n-void\n-decDenseUnpackCoeff (const uByte * bytes, Int len, decNumber * dn,\n-\t\t     Int bunches, Int odd)\n-{\n-  uInt dpd = 0;\t\t\t/* collector for 10 bits */\n-  Int n;\t\t\t/* counter */\n-  const uByte *bin;\t\t/* -> current input byte */\n-  Unit *uout = dn->lsu;\t\t/* -> current output unit */\n-  Unit out = 0;\t\t\t/* accumulator */\n-  Int cut = 0;\t\t\t/* power of ten in current unit */\n-  Unit *last = uout;\t\t/* will be unit containing msd */\n-#if DECDPUN!=3\n-  uInt bcd;\t\t\t/* BCD result */\n-  uInt nibble;\t\t\t/* work */\n-#endif\n-\n-  /* Expand the densely-packed integer, right to left */\n-  bin = &bytes[len - 1];\t/* next input byte to use */\n-  for (n = 0; n < bunches + odd; n++)\n-    {\t\t\t\t/* N bunches of 10 bits */\n-      /* assemble the 10 bits */\n-      switch (n & 0x03)\n-\t{\t\t\t/* phase 0-3 */\n-\tcase 0:\n-\t  dpd = *bin;\n-\t  bin--;\n-\t  dpd |= (*bin & 0x03) << 8;\n-\t  break;\n-\tcase 1:\n-\t  dpd = (unsigned) *bin >> 2;\n-\t  bin--;\n-\t  dpd |= (*bin & 0x0F) << 6;\n-\t  break;\n-\tcase 2:\n-\t  dpd = (unsigned) *bin >> 4;\n-\t  bin--;\n-\t  dpd |= (*bin & 0x3F) << 4;\n-\t  break;\n-\tcase 3:\n-\t  dpd = (unsigned) *bin >> 6;\n-\t  bin--;\n-\t  dpd |= (*bin) << 2;\n-\t  bin--;\n-\t  break;\n-\t}\t\t\t/*switch */\n-\n-#if DECDPUN==3\n-      if (dpd == 0)\n-\t*uout = 0;\n-      else\n-\t{\n-\t  *uout = DPD2BIN[dpd];\t/* convert 10 bits to binary 0-999 */\n-\t  last = uout;\t\t/* record most significant unit */\n-\t}\n-      uout++;\n-\n-#else /* DECDPUN!=3 */\n-      if (dpd == 0)\n-\t{\t\t\t/* fastpath [e.g., leading zeros] */\n-\t  cut += 3;\n-\t  for (; cut >= DECDPUN;)\n-\t    {\n-\t      cut -= DECDPUN;\n-\t      *uout = out;\n-\t      uout++;\n-\t      out = 0;\n-\t    }\n-\t  continue;\n-\t}\n-      bcd = DPD2BCD[dpd];\t/* convert 10 bits to 12 bits BCD */\n-      /* now split the 3 BCD nibbles into bytes, and accumulate into units */\n-      /* If this is the last bunch and it is an odd one, we only have one */\n-      /* nibble to handle [extras could overflow a Unit] */\n-      nibble = bcd & 0x000f;\n-      if (nibble)\n-\t{\n-\t  last = uout;\n-\t  out = (Unit) (out + nibble * powers[cut]);\n-\t}\n-      cut++;\n-      if (cut == DECDPUN)\n-\t{\n-\t  *uout = out;\n-\t  uout++;\n-\t  cut = 0;\n-\t  out = 0;\n-\t}\n-      if (n < bunches)\n-\t{\n-\t  nibble = bcd & 0x00f0;\n-\t  if (nibble)\n-\t    {\n-\t      nibble >>= 4;\n-\t      last = uout;\n-\t      out = (Unit) (out + nibble * powers[cut]);\n-\t    }\n-\t  cut++;\n-\t  if (cut == DECDPUN)\n-\t    {\n-\t      *uout = out;\n-\t      uout++;\n-\t      cut = 0;\n-\t      out = 0;\n-\t    }\n-\t  nibble = bcd & 0x0f00;\n-\t  if (nibble)\n-\t    {\n-\t      nibble >>= 8;\n-\t      last = uout;\n-\t      out = (Unit) (out + nibble * powers[cut]);\n-\t    }\n-\t  cut++;\n-\t  if (cut == DECDPUN)\n-\t    {\n-\t      *uout = out;\n-\t      uout++;\n-\t      cut = 0;\n-\t      out = 0;\n-\t    }\n-\t}\n-#endif\n-    }\t\t\t\t/* n */\n-  if (cut != 0)\n-    *uout = out;\t\t/* write out final unit */\n-\n-  /* here, last points to the most significant unit with digits */\n-  /* we need to inspect it to get final digits count */\n-  dn->digits = (last - dn->lsu) * DECDPUN;\t/* floor of digits */\n-  for (cut = 0; cut < DECDPUN; cut++)\n-    {\n-      if (*last < powers[cut])\n-\tbreak;\n-      dn->digits++;\n-    }\n-  if (dn->digits == 0)\n-    dn->digits++;\t\t/* zero has one digit */\n-  return;\n-}"}, {"sha": "6aa98b5a21de9a6af03a1f23dc017861848019b9", "filename": "libdecnumber/dpd/decimal128.c", "status": "modified", "additions": 476, "deletions": 253, "changes": 729, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2Fdpd%2Fdecimal128.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2Fdpd%2Fdecimal128.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2Fdpd%2Fdecimal128.c?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb", "patch": "@@ -1,5 +1,5 @@\n-/* Decimal 128-bit format module from the decNumber C Library.\n-   Copyright (C) 2005 Free Software Foundation, Inc.\n+/* Decimal 128-bit format module for the decNumber C Library.\n+   Copyright (C) 2005, 2007 Free Software Foundation, Inc.\n    Contributed by IBM Corporation.  Author Mike Cowlishaw.\n \n    This file is part of GCC.\n@@ -28,320 +28,543 @@\n    Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    02110-1301, USA.  */\n \n+/* ------------------------------------------------------------------ */\n+/* Decimal 128-bit format module\t\t\t\t      */\n /* ------------------------------------------------------------------ */\n /* This module comprises the routines for decimal128 format numbers.  */\n-/* Conversions are supplied to and from decNumber and String.         */\n-/*                                                                    */\n-/* No arithmetic routines are included; decNumber provides these.     */\n-/*                                                                    */\n-/* Error handling is the same as decNumber (qv.).                     */\n+/* Conversions are supplied to and from decNumber and String.\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* This is used when decNumber provides operations, either for all    */\n+/* operations or as a proxy between decNumber and decSingle.\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* Error handling is the same as decNumber (qv.).\t\t      */\n /* ------------------------------------------------------------------ */\n-#include <string.h>\t\t/* [for memset/memcpy] */\n-#include <stdio.h>\t\t/* [for printf] */\n+#include <string.h>\t      /* [for memset/memcpy] */\n+#include <stdio.h>\t      /* [for printf] */\n+\n+#include \"config.h\"\t      /* GCC definitions */\n+#define\t DECNUMDIGITS 34      /* make decNumbers with space for 34 */\n+#include \"decNumber.h\"\t      /* base number library */\n+#include \"decNumberLocal.h\"   /* decNumber local types, etc. */\n+#include \"decimal128.h\"\t      /* our primary include */\n \n-#define  DECNUMDIGITS 34\t/* we need decNumbers with space for 34 */\n-#include \"config.h\"\n-#include \"decNumber.h\"\t\t/* base number library */\n-#include \"decNumberLocal.h\"\t/* decNumber local types, etc. */\n-#include \"decimal128.h\"\t\t/* our primary include */\n-#include \"decUtility.h\"\t\t/* utility routines */\n+/* Utility routines and tables [in decimal64.c] */\n+/* DPD2BIN and the reverse are renamed to prevent link-time conflict */\n+/* if decQuad is also built in the same executable */\n+#define DPD2BIN DPD2BINx\n+#define BIN2DPD BIN2DPDx\n+extern const uInt   COMBEXP[32], COMBMSD[32];\n+extern const uShort DPD2BIN[1024];\n+extern const uShort BIN2DPD[1000];\t/* [not used] */\n+extern const uByte  BIN2CHAR[4001];\n+\n+extern void decDigitsFromDPD(decNumber *, const uInt *, Int);\n+extern void decDigitsToDPD(const decNumber *, uInt *, Int);\n \n #if DECTRACE || DECCHECK\n-void decimal128Show (const decimal128 *);\t/* for debug */\n-void decNumberShow (const decNumber *);\t/* .. */\n+void decimal128Show(const decimal128 *);\t  /* for debug */\n+extern void decNumberShow(const decNumber *);\t  /* .. */\n #endif\n \n /* Useful macro */\n /* Clear a structure (e.g., a decNumber) */\n #define DEC_clear(d) memset(d, 0, sizeof(*d))\n \n /* ------------------------------------------------------------------ */\n-/* decimal128FromNumber -- convert decNumber to decimal128            */\n-/*                                                                    */\n-/*   ds is the target decimal128                                      */\n-/*   dn is the source number (assumed valid)                          */\n-/*   set is the context, used only for reporting errors               */\n-/*                                                                    */\n+/* decimal128FromNumber -- convert decNumber to decimal128\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*   ds is the target decimal128\t\t\t\t      */\n+/*   dn is the source number (assumed valid)\t\t\t      */\n+/*   set is the context, used only for reporting errors\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n /* The set argument is used only for status reporting and for the     */\n /* rounding mode (used if the coefficient is more than DECIMAL128_Pmax*/\n-/* digits or an overflow is detected).  If the exponent is out of the */\n-/* valid range then Overflow or Underflow will be raised.             */\n-/* After Underflow a subnormal result is possible.                    */\n-/*                                                                    */\n+/* digits or an overflow is detected).\tIf the exponent is out of the */\n+/* valid range then Overflow or Underflow will be raised.\t      */\n+/* After Underflow a subnormal result is possible.\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n /* DEC_Clamped is set if the number has to be 'folded down' to fit,   */\n /* by reducing its exponent and multiplying the coefficient by a      */\n /* power of ten, or if the exponent on a zero had to be clamped.      */\n /* ------------------------------------------------------------------ */\n-decimal128 *\n-decimal128FromNumber (decimal128 * d128, const decNumber * dn, decContext * set)\n-{\n-  uInt status = 0;\t\t/* status accumulator */\n-  Int pad = 0;\t\t\t/* coefficient pad digits */\n-  decNumber dw;\t\t\t/* work */\n-  decContext dc;\t\t/* .. */\n-  uByte isneg = dn->bits & DECNEG;\t/* non-0 if original sign set */\n-  uInt comb, exp;\t\t/* work */\n-\n-  /* If the number is finite, and has too many digits, or the exponent */\n-  /* could be out of range then we reduce the number under the */\n-  /* appropriate constraints */\n-  if (!(dn->bits & DECSPECIAL))\n-    {\t\t\t\t/* not a special value */\n-      Int ae = dn->exponent + dn->digits - 1;\t/* adjusted exponent */\n-      if (dn->digits > DECIMAL128_Pmax\t/* too many digits */\n-\t  || ae > DECIMAL128_Emax\t/* likely overflow */\n-\t  || ae < DECIMAL128_Emin)\n-\t{\t\t\t/* likely underflow */\n-\t  decContextDefault (&dc, DEC_INIT_DECIMAL128);\t/* [no traps] */\n-\t  dc.round = set->round;\t/* use supplied rounding */\n-\t  decNumberPlus (&dw, dn, &dc);\t/* (round and check) */\n-\t  /* [this changes -0 to 0, but it will be restored below] */\n-\t  status |= dc.status;\t/* save status */\n-\t  dn = &dw;\t\t/* use the work number */\n-\t}\n-      /* [this could have pushed number to Infinity or zero, so this */\n-      /* rounding must be done before we generate the decimal128] */\n-    }\n+decimal128 * decimal128FromNumber(decimal128 *d128, const decNumber *dn,\n+\t\t\t\t  decContext *set) {\n+  uInt status=0;\t\t   /* status accumulator */\n+  Int ae;\t\t\t   /* adjusted exponent */\n+  decNumber  dw;\t\t   /* work */\n+  decContext dc;\t\t   /* .. */\n+  uInt *pu;\t\t\t   /* .. */\n+  uInt comb, exp;\t\t   /* .. */\n+  uInt targar[4]={0,0,0,0};\t   /* target 128-bit */\n+  #define targhi targar[3]\t   /* name the word with the sign */\n+  #define targmh targar[2]\t   /* name the words */\n+  #define targml targar[1]\t   /* .. */\n+  #define targlo targar[0]\t   /* .. */\n+\n+  /* If the number has too many digits, or the exponent could be */\n+  /* out of range then reduce the number under the appropriate */\n+  /* constraints.  This could push the number to Infinity or zero, */\n+  /* so this check and rounding must be done before generating the */\n+  /* decimal128] */\n+  ae=dn->exponent+dn->digits-1;\t\t     /* [0 if special] */\n+  if (dn->digits>DECIMAL128_Pmax\t     /* too many digits */\n+   || ae>DECIMAL128_Emax\t\t     /* likely overflow */\n+   || ae<DECIMAL128_Emin) {\t\t     /* likely underflow */\n+    decContextDefault(&dc, DEC_INIT_DECIMAL128); /* [no traps] */\n+    dc.round=set->round;\t\t     /* use supplied rounding */\n+    decNumberPlus(&dw, dn, &dc);\t     /* (round and check) */\n+    /* [this changes -0 to 0, so enforce the sign...] */\n+    dw.bits|=dn->bits&DECNEG;\n+    status=dc.status;\t\t\t     /* save status */\n+    dn=&dw;\t\t\t\t     /* use the work number */\n+    } /* maybe out of range */\n \n-  DEC_clear (d128);\t\t/* clean the target */\n-  if (dn->bits & DECSPECIAL)\n-    {\t\t\t\t/* a special value */\n-      uByte top;\t\t/* work */\n-      if (dn->bits & DECINF)\n-\ttop = DECIMAL_Inf;\n-      else\n-\t{\t\t\t/* sNaN or qNaN */\n-\t  if ((*dn->lsu != 0 || dn->digits > 1)\t/* non-zero coefficient */\n-\t      && (dn->digits < DECIMAL128_Pmax))\n-\t    {\t\t\t/* coefficient fits */\n-\t      decDensePackCoeff (dn, d128->bytes, sizeof (d128->bytes), 0);\n-\t    }\n-\t  if (dn->bits & DECNAN)\n-\t    top = DECIMAL_NaN;\n-\t  else\n-\t    top = DECIMAL_sNaN;\n+  if (dn->bits&DECSPECIAL) {\t\t\t  /* a special value */\n+    if (dn->bits&DECINF) targhi=DECIMAL_Inf<<24;\n+     else {\t\t\t\t\t  /* sNaN or qNaN */\n+      if ((*dn->lsu!=0 || dn->digits>1)\t\t  /* non-zero coefficient */\n+       && (dn->digits<DECIMAL128_Pmax)) {\t  /* coefficient fits */\n+\tdecDigitsToDPD(dn, targar, 0);\n \t}\n-      d128->bytes[0] = top;\n-    }\n-  else if (decNumberIsZero (dn))\n-    {\t\t\t\t/* a zero */\n+      if (dn->bits&DECNAN) targhi|=DECIMAL_NaN<<24;\n+       else targhi|=DECIMAL_sNaN<<24;\n+      } /* a NaN */\n+    } /* special */\n+\n+   else { /* is finite */\n+    if (decNumberIsZero(dn)) {\t\t     /* is a zero */\n       /* set and clamp exponent */\n-      if (dn->exponent < -DECIMAL128_Bias)\n-\t{\n-\t  exp = 0;\n-\t  status |= DEC_Clamped;\n+      if (dn->exponent<-DECIMAL128_Bias) {\n+\texp=0;\t\t\t\t     /* low clamp */\n+\tstatus|=DEC_Clamped;\n \t}\n-      else\n-\t{\n-\t  exp = dn->exponent + DECIMAL128_Bias;\t/* bias exponent */\n-\t  if (exp > DECIMAL128_Ehigh)\n-\t    {\t\t\t/* top clamp */\n-\t      exp = DECIMAL128_Ehigh;\n-\t      status |= DEC_Clamped;\n-\t    }\n-\t}\n-      comb = (exp >> 9) & 0x18;\t/* combination field */\n-      d128->bytes[0] = (uByte) (comb << 2);\n-      exp &= 0xfff;\t\t/* remaining exponent bits */\n-      decimal128SetExpCon (d128, exp);\n-    }\n-  else\n-    {\t\t\t\t/* non-zero finite number */\n-      uInt msd;\t\t\t/* work */\n-\n-      /* we have a dn that fits, but it may need to be padded */\n-      exp = (uInt) (dn->exponent + DECIMAL128_Bias);\t/* bias exponent */\n-\n-      if (exp > DECIMAL128_Ehigh)\n-\t{\t\t\t/* fold-down case */\n-\t  pad = exp - DECIMAL128_Ehigh;\n-\t  exp = DECIMAL128_Ehigh;\t/* [to maximum] */\n-\t  status |= DEC_Clamped;\n+       else {\n+\texp=dn->exponent+DECIMAL128_Bias;    /* bias exponent */\n+\tif (exp>DECIMAL128_Ehigh) {\t     /* top clamp */\n+\t  exp=DECIMAL128_Ehigh;\n+\t  status|=DEC_Clamped;\n+\t  }\n \t}\n+      comb=(exp>>9) & 0x18;\t\t/* msd=0, exp top 2 bits .. */\n+      }\n+     else {\t\t\t\t/* non-zero finite number */\n+      uInt msd;\t\t\t\t/* work */\n+      Int pad=0;\t\t\t/* coefficient pad digits */\n \n-      decDensePackCoeff (dn, d128->bytes, sizeof (d128->bytes), pad);\n+      /* the dn is known to fit, but it may need to be padded */\n+      exp=(uInt)(dn->exponent+DECIMAL128_Bias);\t   /* bias exponent */\n+      if (exp>DECIMAL128_Ehigh) {\t\t   /* fold-down case */\n+\tpad=exp-DECIMAL128_Ehigh;\n+\texp=DECIMAL128_Ehigh;\t\t\t   /* [to maximum] */\n+\tstatus|=DEC_Clamped;\n+\t}\n \n+      /* [fastpath for common case is not a win, here] */\n+      decDigitsToDPD(dn, targar, pad);\n       /* save and clear the top digit */\n-      msd = ((unsigned) d128->bytes[1] << 2) & 0x0c;\t/* top 2 bits */\n-      msd |= ((unsigned) d128->bytes[2] >> 6);\t/* low 2 bits */\n-      d128->bytes[1] &= 0xfc;\n-      d128->bytes[2] &= 0x3f;\n+      msd=targhi>>14;\n+      targhi&=0x00003fff;\n \n       /* create the combination field */\n-      if (msd >= 8)\n-\tcomb = 0x18 | (msd & 0x01) | ((exp >> 11) & 0x06);\n-      else\n-\tcomb = (msd & 0x07) | ((exp >> 9) & 0x18);\n-      d128->bytes[0] = (uByte) (comb << 2);\n-      exp &= 0xfff;\t\t/* remaining exponent bits */\n-      decimal128SetExpCon (d128, exp);\n-    }\n+      if (msd>=8) comb=0x18 | ((exp>>11) & 0x06) | (msd & 0x01);\n+\t     else comb=((exp>>9) & 0x18) | msd;\n+      }\n+    targhi|=comb<<26;\t\t   /* add combination field .. */\n+    targhi|=(exp&0xfff)<<14;\t   /* .. and exponent continuation */\n+    } /* finite */\n \n-  if (isneg)\n-    decimal128SetSign (d128, 1);\n-  if (status != 0)\n-    decContextSetStatus (set, status);\t/* pass on status */\n+  if (dn->bits&DECNEG) targhi|=0x80000000; /* add sign bit */\n \n+  /* now write to storage; this is endian */\n+  pu=(uInt *)d128->bytes;\t   /* overlay */\n+  if (DECLITEND) {\n+    pu[0]=targlo;\t\t   /* directly store the low int */\n+    pu[1]=targml;\t\t   /* then the mid-low */\n+    pu[2]=targmh;\t\t   /* then the mid-high */\n+    pu[3]=targhi;\t\t   /* then the high int */\n+    }\n+   else {\n+    pu[0]=targhi;\t\t   /* directly store the high int */\n+    pu[1]=targmh;\t\t   /* then the mid-high */\n+    pu[2]=targml;\t\t   /* then the mid-low */\n+    pu[3]=targlo;\t\t   /* then the low int */\n+    }\n+\n+  if (status!=0) decContextSetStatus(set, status); /* pass on status */\n   /* decimal128Show(d128); */\n   return d128;\n-}\n+  } /* decimal128FromNumber */\n \n /* ------------------------------------------------------------------ */\n-/* decimal128ToNumber -- convert decimal128 to decNumber              */\n-/*   d128 is the source decimal128                                    */\n-/*   dn is the target number, with appropriate space                  */\n-/* No error is possible.                                              */\n+/* decimal128ToNumber -- convert decimal128 to decNumber\t      */\n+/*   d128 is the source decimal128\t\t\t\t      */\n+/*   dn is the target number, with appropriate space\t\t      */\n+/* No error is possible.\t\t\t\t\t      */\n /* ------------------------------------------------------------------ */\n-decNumber *\n-decimal128ToNumber (const decimal128 * d128, decNumber * dn)\n-{\n-  uInt msd;\t\t\t/* coefficient MSD */\n-  decimal128 wk;\t\t/* working copy, if needed */\n-  uInt top = d128->bytes[0] & 0x7f;\t/* top byte, less sign bit */\n-  decNumberZero (dn);\t\t/* clean target */\n-  /* set the sign if negative */\n-  if (decimal128Sign (d128))\n-    dn->bits = DECNEG;\n-\n-  if (top >= 0x78)\n-    {\t\t\t\t/* is a special */\n-      if ((top & 0x7c) == (DECIMAL_Inf & 0x7c))\n-\tdn->bits |= DECINF;\n-      else if ((top & 0x7e) == (DECIMAL_NaN & 0x7e))\n-\tdn->bits |= DECNAN;\n-      else\n-\tdn->bits |= DECSNAN;\n-      msd = 0;\t\t\t/* no top digit */\n+decNumber * decimal128ToNumber(const decimal128 *d128, decNumber *dn) {\n+  uInt msd;\t\t\t   /* coefficient MSD */\n+  uInt exp;\t\t\t   /* exponent top two bits */\n+  uInt comb;\t\t\t   /* combination field */\n+  const uInt *pu;\t\t   /* work */\n+  Int  need;\t\t\t   /* .. */\n+  uInt sourar[4];\t\t   /* source 128-bit */\n+  #define sourhi sourar[3]\t   /* name the word with the sign */\n+  #define sourmh sourar[2]\t   /* and the mid-high word */\n+  #define sourml sourar[1]\t   /* and the mod-low word */\n+  #define sourlo sourar[0]\t   /* and the lowest word */\n+\n+  /* load source from storage; this is endian */\n+  pu=(const uInt *)d128->bytes;\t   /* overlay */\n+  if (DECLITEND) {\n+    sourlo=pu[0];\t\t   /* directly load the low int */\n+    sourml=pu[1];\t\t   /* then the mid-low */\n+    sourmh=pu[2];\t\t   /* then the mid-high */\n+    sourhi=pu[3];\t\t   /* then the high int */\n     }\n-  else\n-    {\t\t\t\t/* have a finite number */\n-      uInt comb = top >> 2;\t/* combination field */\n-      uInt exp;\t\t\t/* exponent */\n-\n-      if (comb >= 0x18)\n-\t{\n-\t  msd = 8 + (comb & 0x01);\n-\t  exp = (comb & 0x06) << 11;\t/* MSBs */\n-\t}\n-      else\n-\t{\n-\t  msd = comb & 0x07;\n-\t  exp = (comb & 0x18) << 9;\n-\t}\n-      dn->exponent = exp + decimal128ExpCon (d128) - DECIMAL128_Bias;\t/* remove bias */\n+   else {\n+    sourhi=pu[0];\t\t   /* directly load the high int */\n+    sourmh=pu[1];\t\t   /* then the mid-high */\n+    sourml=pu[2];\t\t   /* then the mid-low */\n+    sourlo=pu[3];\t\t   /* then the low int */\n     }\n \n-  /* get the coefficient, unless infinite */\n-  if (!(dn->bits & DECINF))\n-    {\n-      Int bunches = DECIMAL128_Pmax / 3;\t/* coefficient full bunches to convert */\n-      Int odd = 0;\t\t/* assume MSD is 0 (no odd bunch) */\n-      if (msd != 0)\n-\t{\t\t\t/* coefficient has leading non-0 digit */\n-\t  /* make a copy of the decimal128, with an extra bunch which has */\n-\t  /* the top digit ready for conversion */\n-\t  wk = *d128;\t\t/* take a copy */\n-\t  wk.bytes[0] = 0;\t/* clear all but coecon */\n-\t  wk.bytes[1] = 0;\t/* .. */\n-\t  wk.bytes[2] &= 0x3f;\t/* .. */\n-\t  wk.bytes[1] |= (msd >> 2);\t/* and prefix MSD */\n-\t  wk.bytes[2] |= (msd << 6);\t/* .. */\n-\t  odd++;\t\t/* indicate the extra */\n-\t  d128 = &wk;\t\t/* use the work copy */\n-\t}\n-      decDenseUnpackCoeff (d128->bytes, sizeof (d128->bytes), dn, bunches,\n-\t\t\t   odd);\n+  comb=(sourhi>>26)&0x1f;\t   /* combination field */\n+\n+  decNumberZero(dn);\t\t   /* clean number */\n+  if (sourhi&0x80000000) dn->bits=DECNEG; /* set sign if negative */\n+\n+  msd=COMBMSD[comb];\t\t   /* decode the combination field */\n+  exp=COMBEXP[comb];\t\t   /* .. */\n+\n+  if (exp==3) {\t\t\t   /* is a special */\n+    if (msd==0) {\n+      dn->bits|=DECINF;\n+      return dn;\t\t   /* no coefficient needed */\n+      }\n+    else if (sourhi&0x02000000) dn->bits|=DECSNAN;\n+    else dn->bits|=DECNAN;\n+    msd=0;\t\t\t   /* no top digit */\n+    }\n+   else {\t\t\t   /* is a finite number */\n+    dn->exponent=(exp<<12)+((sourhi>>14)&0xfff)-DECIMAL128_Bias; /* unbiased */\n     }\n \n+  /* get the coefficient */\n+  sourhi&=0x00003fff;\t\t   /* clean coefficient continuation */\n+  if (msd) {\t\t\t   /* non-zero msd */\n+    sourhi|=msd<<14;\t\t   /* prefix to coefficient */\n+    need=12;\t\t\t   /* process 12 declets */\n+    }\n+   else { /* msd=0 */\n+    if (sourhi) need=11;\t   /* declets to process */\n+     else if (sourmh) need=10;\n+     else if (sourml) need=7;\n+     else if (sourlo) need=4;\n+     else return dn;\t\t   /* easy: coefficient is 0 */\n+    } /*msd=0 */\n+\n+  decDigitsFromDPD(dn, sourar, need);\t/* process declets */\n   /* decNumberShow(dn); */\n   return dn;\n-}\n+  } /* decimal128ToNumber */\n \n /* ------------------------------------------------------------------ */\n-/* to-scientific-string -- conversion to numeric string               */\n-/* to-engineering-string -- conversion to numeric string              */\n-/*                                                                    */\n-/*   decimal128ToString(d128, string);                                */\n-/*   decimal128ToEngString(d128, string);                             */\n-/*                                                                    */\n-/*  d128 is the decimal128 format number to convert                   */\n-/*  string is the string where the result will be laid out            */\n-/*                                                                    */\n-/*  string must be at least 24 characters                             */\n-/*                                                                    */\n-/*  No error is possible, and no status can be set.                   */\n+/* to-scientific-string -- conversion to numeric string\t\t      */\n+/* to-engineering-string -- conversion to numeric string\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*   decimal128ToString(d128, string);\t\t\t\t      */\n+/*   decimal128ToEngString(d128, string);\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  d128 is the decimal128 format number to convert\t\t      */\n+/*  string is the string where the result will be laid out\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  string must be at least 24 characters\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  No error is possible, and no status can be set.\t\t      */\n /* ------------------------------------------------------------------ */\n-char *\n-decimal128ToString (const decimal128 * d128, char *string)\n-{\n-  decNumber dn;\t\t\t/* work */\n-  decimal128ToNumber (d128, &dn);\n-  decNumberToString (&dn, string);\n+char * decimal128ToEngString(const decimal128 *d128, char *string){\n+  decNumber dn;\t\t\t\t/* work */\n+  decimal128ToNumber(d128, &dn);\n+  decNumberToEngString(&dn, string);\n   return string;\n-}\n-\n-char *\n-decimal128ToEngString (const decimal128 * d128, char *string)\n-{\n-  decNumber dn;\t\t\t/* work */\n-  decimal128ToNumber (d128, &dn);\n-  decNumberToEngString (&dn, string);\n+  } /* decimal128ToEngString */\n+\n+char * decimal128ToString(const decimal128 *d128, char *string){\n+  uInt msd;\t\t\t   /* coefficient MSD */\n+  Int  exp;\t\t\t   /* exponent top two bits or full */\n+  uInt comb;\t\t\t   /* combination field */\n+  char *cstart;\t\t\t   /* coefficient start */\n+  char *c;\t\t\t   /* output pointer in string */\n+  const uInt *pu;\t\t   /* work */\n+  char *s, *t;\t\t\t   /* .. (source, target) */\n+  Int  dpd;\t\t\t   /* .. */\n+  Int  pre, e;\t\t\t   /* .. */\n+  const uByte *u;\t\t   /* .. */\n+\n+  uInt sourar[4];\t\t   /* source 128-bit */\n+  #define sourhi sourar[3]\t   /* name the word with the sign */\n+  #define sourmh sourar[2]\t   /* and the mid-high word */\n+  #define sourml sourar[1]\t   /* and the mod-low word */\n+  #define sourlo sourar[0]\t   /* and the lowest word */\n+\n+  /* load source from storage; this is endian */\n+  pu=(const uInt *)d128->bytes;\t   /* overlay */\n+  if (DECLITEND) {\n+    sourlo=pu[0];\t\t   /* directly load the low int */\n+    sourml=pu[1];\t\t   /* then the mid-low */\n+    sourmh=pu[2];\t\t   /* then the mid-high */\n+    sourhi=pu[3];\t\t   /* then the high int */\n+    }\n+   else {\n+    sourhi=pu[0];\t\t   /* directly load the high int */\n+    sourmh=pu[1];\t\t   /* then the mid-high */\n+    sourml=pu[2];\t\t   /* then the mid-low */\n+    sourlo=pu[3];\t\t   /* then the low int */\n+    }\n+\n+  c=string;\t\t\t   /* where result will go */\n+  if (((Int)sourhi)<0) *c++='-';   /* handle sign */\n+\n+  comb=(sourhi>>26)&0x1f;\t   /* combination field */\n+  msd=COMBMSD[comb];\t\t   /* decode the combination field */\n+  exp=COMBEXP[comb];\t\t   /* .. */\n+\n+  if (exp==3) {\n+    if (msd==0) {\t\t   /* infinity */\n+      strcpy(c,\t  \"Inf\");\n+      strcpy(c+3, \"inity\");\n+      return string;\t\t   /* easy */\n+      }\n+    if (sourhi&0x02000000) *c++='s'; /* sNaN */\n+    strcpy(c, \"NaN\");\t\t   /* complete word */\n+    c+=3;\t\t\t   /* step past */\n+    if (sourlo==0 && sourml==0 && sourmh==0\n+     && (sourhi&0x0003ffff)==0) return string; /* zero payload */\n+    /* otherwise drop through to add integer; set correct exp */\n+    exp=0; msd=0;\t\t   /* setup for following code */\n+    }\n+   else exp=(exp<<12)+((sourhi>>14)&0xfff)-DECIMAL128_Bias; /* unbiased */\n+\n+  /* convert 34 digits of significand to characters */\n+  cstart=c;\t\t\t   /* save start of coefficient */\n+  if (msd) *c++='0'+(char)msd;\t   /* non-zero most significant digit */\n+\n+  /* Now decode the declets.  After extracting each one, it is */\n+  /* decoded to binary and then to a 4-char sequence by table lookup; */\n+  /* the 4-chars are a 1-char length (significant digits, except 000 */\n+  /* has length 0).  This allows us to left-align the first declet */\n+  /* with non-zero content, then remaining ones are full 3-char */\n+  /* length.  We use fixed-length memcpys because variable-length */\n+  /* causes a subroutine call in GCC.  (These are length 4 for speed */\n+  /* and are safe because the array has an extra terminator byte.) */\n+  #define dpd2char u=&BIN2CHAR[DPD2BIN[dpd]*4];\t\t\t  \\\n+\t\t   if (c!=cstart) {memcpy(c, u+1, 4); c+=3;}\t  \\\n+\t\t    else if (*u)  {memcpy(c, u+4-*u, 4); c+=*u;}\n+  dpd=(sourhi>>4)&0x3ff;\t\t     /* declet 1 */\n+  dpd2char;\n+  dpd=((sourhi&0xf)<<6) | (sourmh>>26);\t     /* declet 2 */\n+  dpd2char;\n+  dpd=(sourmh>>16)&0x3ff;\t\t     /* declet 3 */\n+  dpd2char;\n+  dpd=(sourmh>>6)&0x3ff;\t\t     /* declet 4 */\n+  dpd2char;\n+  dpd=((sourmh&0x3f)<<4) | (sourml>>28);     /* declet 5 */\n+  dpd2char;\n+  dpd=(sourml>>18)&0x3ff;\t\t     /* declet 6 */\n+  dpd2char;\n+  dpd=(sourml>>8)&0x3ff;\t\t     /* declet 7 */\n+  dpd2char;\n+  dpd=((sourml&0xff)<<2) | (sourlo>>30);     /* declet 8 */\n+  dpd2char;\n+  dpd=(sourlo>>20)&0x3ff;\t\t     /* declet 9 */\n+  dpd2char;\n+  dpd=(sourlo>>10)&0x3ff;\t\t     /* declet 10 */\n+  dpd2char;\n+  dpd=(sourlo)&0x3ff;\t\t\t     /* declet 11 */\n+  dpd2char;\n+\n+  if (c==cstart) *c++='0';\t   /* all zeros -- make 0 */\n+\n+  if (exp==0) {\t\t\t   /* integer or NaN case -- easy */\n+    *c='\\0';\t\t\t   /* terminate */\n+    return string;\n+    }\n+\n+  /* non-0 exponent */\n+  e=0;\t\t\t\t   /* assume no E */\n+  pre=c-cstart+exp;\n+  /* [here, pre-exp is the digits count (==1 for zero)] */\n+  if (exp>0 || pre<-5) {\t   /* need exponential form */\n+    e=pre-1;\t\t\t   /* calculate E value */\n+    pre=1;\t\t\t   /* assume one digit before '.' */\n+    } /* exponential form */\n+\n+  /* modify the coefficient, adding 0s, '.', and E+nn as needed */\n+  s=c-1;\t\t\t   /* source (LSD) */\n+  if (pre>0) {\t\t\t   /* ddd.ddd (plain), perhaps with E */\n+    char *dotat=cstart+pre;\n+    if (dotat<c) {\t\t   /* if embedded dot needed... */\n+      t=c;\t\t\t\t/* target */\n+      for (; s>=dotat; s--, t--) *t=*s; /* open the gap; leave t at gap */\n+      *t='.';\t\t\t\t/* insert the dot */\n+      c++;\t\t\t\t/* length increased by one */\n+      }\n+\n+    /* finally add the E-part, if needed; it will never be 0, and has */\n+    /* a maximum length of 4 digits */\n+    if (e!=0) {\n+      *c++='E';\t\t\t   /* starts with E */\n+      *c++='+';\t\t\t   /* assume positive */\n+      if (e<0) {\n+\t*(c-1)='-';\t\t   /* oops, need '-' */\n+\te=-e;\t\t\t   /* uInt, please */\n+\t}\n+      if (e<1000) {\t\t   /* 3 (or fewer) digits case */\n+\tu=&BIN2CHAR[e*4];\t   /* -> length byte */\n+\tmemcpy(c, u+4-*u, 4);\t   /* copy fixed 4 characters [is safe] */\n+\tc+=*u;\t\t\t   /* bump pointer appropriately */\n+\t}\n+       else {\t\t\t   /* 4-digits */\n+\tInt thou=((e>>3)*1049)>>17; /* e/1000 */\n+\tInt rem=e-(1000*thou);\t    /* e%1000 */\n+\t*c++='0'+(char)thou;\n+\tu=&BIN2CHAR[rem*4];\t   /* -> length byte */\n+\tmemcpy(c, u+1, 4);\t   /* copy fixed 3+1 characters [is safe] */\n+\tc+=3;\t\t\t   /* bump pointer, always 3 digits */\n+\t}\n+      }\n+    *c='\\0';\t\t\t   /* add terminator */\n+    /*printf(\"res %s\\n\", string); */\n+    return string;\n+    } /* pre>0 */\n+\n+  /* -5<=pre<=0: here for plain 0.ddd or 0.000ddd forms (can never have E) */\n+  t=c+1-pre;\n+  *(t+1)='\\0';\t\t\t\t/* can add terminator now */\n+  for (; s>=cstart; s--, t--) *t=*s;\t/* shift whole coefficient right */\n+  c=cstart;\n+  *c++='0';\t\t\t\t/* always starts with 0. */\n+  *c++='.';\n+  for (; pre<0; pre++) *c++='0';\t/* add any 0's after '.' */\n+  /*printf(\"res %s\\n\", string); */\n   return string;\n-}\n+  } /* decimal128ToString */\n \n /* ------------------------------------------------------------------ */\n-/* to-number -- conversion from numeric string                        */\n-/*                                                                    */\n-/*   decimal128FromString(result, string, set);                       */\n-/*                                                                    */\n+/* to-number -- conversion from numeric string\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*   decimal128FromString(result, string, set);\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n /*  result  is the decimal128 format number which gets the result of  */\n-/*          the conversion                                            */\n+/*\t    the conversion\t\t\t\t\t      */\n /*  *string is the character string which should contain a valid      */\n-/*          number (which may be a special value)                     */\n-/*  set     is the context                                            */\n-/*                                                                    */\n+/*\t    number (which may be a special value)\t\t      */\n+/*  set\t    is the context\t\t\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n /* The context is supplied to this routine is used for error handling */\n /* (setting of status and traps) and for the rounding mode, only.     */\n /* If an error occurs, the result will be a valid decimal128 NaN.     */\n /* ------------------------------------------------------------------ */\n-decimal128 *\n-decimal128FromString (decimal128 * result, const char *string, decContext * set)\n-{\n-  decContext dc;\t\t/* work */\n-  decNumber dn;\t\t\t/* .. */\n-\n-  decContextDefault (&dc, DEC_INIT_DECIMAL128);\t/* no traps, please */\n-  dc.round = set->round;\t/* use supplied rounding */\n-\n-  decNumberFromString (&dn, string, &dc);\t/* will round if needed */\n-  decimal128FromNumber (result, &dn, &dc);\n-  if (dc.status != 0)\n-    {\t\t\t\t/* something happened */\n-      decContextSetStatus (set, dc.status);\t/* .. pass it on */\n+decimal128 * decimal128FromString(decimal128 *result, const char *string,\n+\t\t\t\t  decContext *set) {\n+  decContext dc;\t\t\t     /* work */\n+  decNumber dn;\t\t\t\t     /* .. */\n+\n+  decContextDefault(&dc, DEC_INIT_DECIMAL128); /* no traps, please */\n+  dc.round=set->round;\t\t\t       /* use supplied rounding */\n+\n+  decNumberFromString(&dn, string, &dc);     /* will round if needed */\n+  decimal128FromNumber(result, &dn, &dc);\n+  if (dc.status!=0) {\t\t\t     /* something happened */\n+    decContextSetStatus(set, dc.status);     /* .. pass it on */\n     }\n   return result;\n-}\n+  } /* decimal128FromString */\n+\n+/* ------------------------------------------------------------------ */\n+/* decimal128IsCanonical -- test whether encoding is canonical\t      */\n+/*   d128 is the source decimal128\t\t\t\t      */\n+/*   returns 1 if the encoding of d128 is canonical, 0 otherwise      */\n+/* No error is possible.\t\t\t\t\t      */\n+/* ------------------------------------------------------------------ */\n+uint32_t decimal128IsCanonical(const decimal128 *d128) {\n+  decNumber dn;\t\t\t\t/* work */\n+  decimal128 canon;\t\t\t /* .. */\n+  decContext dc;\t\t\t/* .. */\n+  decContextDefault(&dc, DEC_INIT_DECIMAL128);\n+  decimal128ToNumber(d128, &dn);\n+  decimal128FromNumber(&canon, &dn, &dc);/* canon will now be canonical */\n+  return memcmp(d128, &canon, DECIMAL128_Bytes)==0;\n+  } /* decimal128IsCanonical */\n \n+/* ------------------------------------------------------------------ */\n+/* decimal128Canonical -- copy an encoding, ensuring it is canonical  */\n+/*   d128 is the source decimal128\t\t\t\t      */\n+/*   result is the target (may be the same decimal128)\t\t      */\n+/*   returns result\t\t\t\t\t\t      */\n+/* No error is possible.\t\t\t\t\t      */\n+/* ------------------------------------------------------------------ */\n+decimal128 * decimal128Canonical(decimal128 *result, const decimal128 *d128) {\n+  decNumber dn;\t\t\t\t/* work */\n+  decContext dc;\t\t\t/* .. */\n+  decContextDefault(&dc, DEC_INIT_DECIMAL128);\n+  decimal128ToNumber(d128, &dn);\n+  decimal128FromNumber(result, &dn, &dc);/* result will now be canonical */\n+  return result;\n+  } /* decimal128Canonical */\n \n #if DECTRACE || DECCHECK\n+/* Macros for accessing decimal128 fields.  These assume the argument\n+   is a reference (pointer) to the decimal128 structure, and the\n+   decimal128 is in network byte order (big-endian) */\n+/* Get sign */\n+#define decimal128Sign(d)\t((unsigned)(d)->bytes[0]>>7)\n+\n+/* Get combination field */\n+#define decimal128Comb(d)\t(((d)->bytes[0] & 0x7c)>>2)\n+\n+/* Get exponent continuation [does not remove bias] */\n+#define decimal128ExpCon(d)\t((((d)->bytes[0] & 0x03)<<10)\t      \\\n+\t\t\t      | ((unsigned)(d)->bytes[1]<<2)\t      \\\n+\t\t\t      | ((unsigned)(d)->bytes[2]>>6))\n+\n+/* Set sign [this assumes sign previously 0] */\n+#define decimal128SetSign(d, b) {\t\t\t\t      \\\n+  (d)->bytes[0]|=((unsigned)(b)<<7);}\n+\n+/* Set exponent continuation [does not apply bias] */\n+/* This assumes range has been checked and exponent previously 0; */\n+/* type of exponent must be unsigned */\n+#define decimal128SetExpCon(d, e) {\t\t\t\t      \\\n+  (d)->bytes[0]|=(uint8_t)((e)>>10);\t\t\t\t      \\\n+  (d)->bytes[1] =(uint8_t)(((e)&0x3fc)>>2);\t\t\t      \\\n+  (d)->bytes[2]|=(uint8_t)(((e)&0x03)<<6);}\n+\n /* ------------------------------------------------------------------ */\n-/* decimal128Show -- display a single in hexadecimal [debug aid]      */\n-/*   d128 -- the number to show                                       */\n+/* decimal128Show -- display a decimal128 in hexadecimal [debug aid]  */\n+/*   d128 -- the number to show\t\t\t\t\t      */\n /* ------------------------------------------------------------------ */\n /* Also shows sign/cob/expconfields extracted */\n-void\n-decimal128Show (const decimal128 * d128)\n-{\n-  char buf[DECIMAL128_Bytes * 2 + 1];\n-  Int i, j;\n-  j = 0;\n-  for (i = 0; i < DECIMAL128_Bytes; i++)\n-    {\n-      sprintf (&buf[j], \"%02x\", d128->bytes[i]);\n-      j = j + 2;\n+void decimal128Show(const decimal128 *d128) {\n+  char buf[DECIMAL128_Bytes*2+1];\n+  Int i, j=0;\n+\n+  if (DECLITEND) {\n+    for (i=0; i<DECIMAL128_Bytes; i++, j+=2) {\n+      sprintf(&buf[j], \"%02x\", d128->bytes[15-i]);\n+      }\n+    printf(\" D128> %s [S:%d Cb:%02x Ec:%02x] LittleEndian\\n\", buf,\n+\t   d128->bytes[15]>>7, (d128->bytes[15]>>2)&0x1f,\n+\t   ((d128->bytes[15]&0x3)<<10)|(d128->bytes[14]<<2)|\n+\t   (d128->bytes[13]>>6));\n+    }\n+   else {\n+    for (i=0; i<DECIMAL128_Bytes; i++, j+=2) {\n+      sprintf(&buf[j], \"%02x\", d128->bytes[i]);\n+      }\n+    printf(\" D128> %s [S:%d Cb:%02x Ec:%02x] BigEndian\\n\", buf,\n+\t   decimal128Sign(d128), decimal128Comb(d128),\n+\t   decimal128ExpCon(d128));\n     }\n-  printf (\" D128> %s [S:%d Cb:%02x E:%d]\\n\", buf,\n-\t  decimal128Sign (d128), decimal128Comb (d128),\n-\t  decimal128ExpCon (d128));\n-}\n+  } /* decimal128Show */\n #endif"}, {"sha": "f8f5b5a8ff222aace913bdda0cb09393a7930da3", "filename": "libdecnumber/dpd/decimal128.h", "status": "modified", "additions": 68, "deletions": 97, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2Fdpd%2Fdecimal128.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2Fdpd%2Fdecimal128.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2Fdpd%2Fdecimal128.h?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb", "patch": "@@ -1,5 +1,5 @@\n-/* Decimal 128-bit format module header for the decNumber C Library\n-   Copyright (C) 2005 Free Software Foundation, Inc.\n+/* Decimal 128-bit format module header for the decNumber C Library.\n+   Copyright (C) 2005, 2007 Free Software Foundation, Inc.\n    Contributed by IBM Corporation.  Author Mike Cowlishaw.\n \n    This file is part of GCC.\n@@ -28,103 +28,74 @@\n    Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    02110-1301, USA.  */\n \n+/* ------------------------------------------------------------------ */\n+/* Decimal 128-bit format module header\t\t\t\t      */\n+/* ------------------------------------------------------------------ */\n+\n #if !defined(DECIMAL128)\n-#define DECIMAL128\n-#define DEC128NAME     \"decimal128\"\t/* Short name */\n-#define DEC128FULLNAME \"Decimal 128-bit Number\"\t/* Verbose name */\n-#define DEC128AUTHOR   \"Mike Cowlishaw\"\t/* Who to blame */\n-\n-#if defined(DECIMAL32)\n-#error decimal128.h must precede decimal32.h for correct DECNUMDIGITS\n-#else\n-#if defined(DECIMAL64)\n-#error decimal128.h must precede decimal64.h for correct DECNUMDIGITS\n-#endif\n-#endif\n+  #define DECIMAL128\n+  #define DEC128NAME\t \"decimal128\"\t\t      /* Short name   */\n+  #define DEC128FULLNAME \"Decimal 128-bit Number\"     /* Verbose name */\n+  #define DEC128AUTHOR\t \"Mike Cowlishaw\"\t      /* Who to blame */\n \n   /* parameters for decimal128s */\n-#define DECIMAL128_Bytes  16\t/* length */\n-#define DECIMAL128_Pmax   34\t/* maximum precision (digits) */\n-#define DECIMAL128_Emax   6144\t/* maximum adjusted exponent */\n-#define DECIMAL128_Emin  -6143\t/* minimum adjusted exponent */\n-#define DECIMAL128_Bias   6176\t/* bias for the exponent */\n-#define DECIMAL128_String 43\t/* maximum string length, +1 */\n-  /* highest biased exponent (Elimit-1) */\n-#define DECIMAL128_Ehigh  (DECIMAL128_Emax+DECIMAL128_Bias-DECIMAL128_Pmax+1)\n-\n-#ifndef DECNUMDIGITS\n-#define DECNUMDIGITS DECIMAL128_Pmax\t/* size if not already defined */\n-#endif\n-#ifndef DECNUMBER\n-#include \"decNumber.h\"\t\t/* context and number library */\n-#endif\n-\n-  /* Decimal 128-bit type, accessible by bytes */\n-typedef struct\n-{\n-  uint8_t bytes[DECIMAL128_Bytes];\t/* decimal128: 1, 5, 12, 110 bits */\n-} decimal128;\n-\n-  /* special values [top byte excluding sign bit; last two bits are\n-     don't-care for Infinity on input, last bit don't-care for NaN] */\n-#if !defined(DECIMAL_NaN)\n-#define DECIMAL_NaN     0x7c\t/* 0 11111 00 NaN */\n-#define DECIMAL_sNaN    0x7e\t/* 0 11111 10 sNaN */\n-#define DECIMAL_Inf     0x78\t/* 0 11110 00 Infinity */\n-#endif\n-\n-  /* Macros for accessing decimal128 fields.  These assume the argument\n-     is a reference (pointer) to the decimal128 structure */\n-  /* Get sign */\n-#define decimal128Sign(d)       ((unsigned)(d)->bytes[0]>>7)\n-\n-  /* Get combination field */\n-#define decimal128Comb(d)       (((d)->bytes[0] & 0x7c)>>2)\n-\n-  /* Get exponent continuation [does not remove bias] */\n-#define decimal128ExpCon(d)     ((((d)->bytes[0] & 0x03)<<10)       \\\n-                                | ((unsigned)(d)->bytes[1]<<2)        \\\n-                                | ((unsigned)(d)->bytes[2]>>6))\n-\n-  /* Set sign [this assumes sign previously 0] */\n-#define decimal128SetSign(d, b) {                                   \\\n-    (d)->bytes[0]|=((unsigned)(b)<<7);}\n-\n-  /* Clear sign */\n-#define decimal128ClearSign(d) {(d)->bytes[0]&=~0x80;}\n-\n-  /* Flip sign */\n-#define decimal128FlipSign(d) {(d)->bytes[0]^=0x80;}\n-\n-  /* Set exponent continuation [does not apply bias] */\n-  /* This assumes range has been checked and exponent previously 0; */\n-  /* type of exponent must be unsigned */\n-#define decimal128SetExpCon(d, e) {                                 \\\n-    (d)->bytes[0]|=(uint8_t)((e)>>10);                                \\\n-    (d)->bytes[1] =(uint8_t)(((e)&0x3fc)>>2);                         \\\n-    (d)->bytes[2]|=(uint8_t)(((e)&0x03)<<6);}\n-\n-  /* ------------------------------------------------------------------ */\n-  /* Routines                                                           */\n-  /* ------------------------------------------------------------------ */\n-\n-#ifdef IN_LIBGCC2\n-#ifndef decimal128FromString\n-#define decimal128FromString __decimal128FromString\n-#define decimal128ToString __decimal128ToString\n-#define decimal128ToEngString __decimal128ToEngString\n-#define decimal128FromNumber __decimal128FromNumber\n-#define decimal128ToNumber __decimal128ToNumber\n-#endif\n-#endif\n-\n-  /* String conversions */\n-decimal128 *decimal128FromString (decimal128 *, const char *, decContext *);\n-char *decimal128ToString (const decimal128 *, char *);\n-char *decimal128ToEngString (const decimal128 *, char *);\n-\n-  /* decNumber conversions */\n-decimal128 *decimal128FromNumber (decimal128 *, const decNumber *, decContext *);\n-decNumber *decimal128ToNumber (const decimal128 *, decNumber *);\n+  #define DECIMAL128_Bytes  16\t\t/* length\t\t      */\n+  #define DECIMAL128_Pmax   34\t\t/* maximum precision (digits) */\n+  #define DECIMAL128_Emax   6144\t/* maximum adjusted exponent  */\n+  #define DECIMAL128_Emin  -6143\t/* minimum adjusted exponent  */\n+  #define DECIMAL128_Bias   6176\t/* bias for the exponent      */\n+  #define DECIMAL128_String 43\t\t/* maximum string length, +1  */\n+  #define DECIMAL128_EconL  12\t\t/* exp. continuation length   */\n+  /* highest biased exponent (Elimit-1)\t\t\t\t      */\n+  #define DECIMAL128_Ehigh  (DECIMAL128_Emax+DECIMAL128_Bias-DECIMAL128_Pmax+1)\n+\n+  /* check enough digits, if pre-defined\t\t\t      */\n+  #if defined(DECNUMDIGITS)\n+    #if (DECNUMDIGITS<DECIMAL128_Pmax)\n+      #error decimal128.h needs pre-defined DECNUMDIGITS>=34 for safe use\n+    #endif\n+  #endif\n+\n+  #ifndef DECNUMDIGITS\n+    #define DECNUMDIGITS DECIMAL128_Pmax /* size if not already defined*/\n+  #endif\n+  #ifndef DECNUMBER\n+    #include \"decNumber.h\"\t\t/* context and number library */\n+  #endif\n+\n+  /* Decimal 128-bit type, accessible by bytes\t\t\t      */\n+  typedef struct {\n+    uint8_t bytes[DECIMAL128_Bytes]; /* decimal128: 1, 5, 12, 110 bits*/\n+    } decimal128;\n+\n+  /* special values [top byte excluding sign bit; last two bits are   */\n+  /* don't-care for Infinity on input, last bit don't-care for NaN]   */\n+  #if !defined(DECIMAL_NaN)\n+    #define DECIMAL_NaN\t    0x7c\t/* 0 11111 00 NaN\t      */\n+    #define DECIMAL_sNaN    0x7e\t/* 0 11111 10 sNaN\t      */\n+    #define DECIMAL_Inf\t    0x78\t/* 0 11110 00 Infinity\t      */\n+  #endif\n+\n+  #include \"decimal128Local.h\"\n+\n+  /* ---------------------------------------------------------------- */\n+  /* Routines\t\t\t\t\t\t\t      */\n+  /* ---------------------------------------------------------------- */\n+\n+  #include \"decimal128Symbols.h\"\n+\n+  /* String conversions\t\t\t\t\t\t      */\n+  decimal128 * decimal128FromString(decimal128 *, const char *, decContext *);\n+  char * decimal128ToString(const decimal128 *, char *);\n+  char * decimal128ToEngString(const decimal128 *, char *);\n+\n+  /* decNumber conversions\t\t\t\t\t      */\n+  decimal128 * decimal128FromNumber(decimal128 *, const decNumber *,\n+\t\t\t\t    decContext *);\n+  decNumber * decimal128ToNumber(const decimal128 *, decNumber *);\n+\n+  /* Format-dependent utilities\t\t\t\t\t      */\n+  uint32_t    decimal128IsCanonical(const decimal128 *);\n+  decimal128 * decimal128Canonical(decimal128 *, const decimal128 *);\n \n #endif"}, {"sha": "b4130b53425a722ab0431fa7f347a73752255ceb", "filename": "libdecnumber/dpd/decimal128Local.h", "status": "renamed", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2Fdpd%2Fdecimal128Local.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2Fdpd%2Fdecimal128Local.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2Fdpd%2Fdecimal128Local.h?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb", "patch": "@@ -1,6 +1,5 @@\n-/* Utility functions for decimal floating point support via decNumber.\n-   Copyright (C) 2005 Free Software Foundation, Inc.\n-   Contributed by IBM Corporation.  Author Mike Cowlishaw.\n+/* Local definitions for use with the decNumber C Library.\n+   Copyright (C) 2007 Free Software Foundation, Inc.\n \n    This file is part of GCC.\n \n@@ -28,10 +27,21 @@\n    Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    02110-1301, USA.  */\n \n-#ifdef IN_LIBGCC2\n-#define decDensePackCoeff __decDensePackCoeff\n-#define decDenseUnpackCoeff __decDenseUnpackCoeff\n-#endif\n+#if !defined(DECIMAL128LOCAL)\n+\n+/* The compiler needs sign manipulation functions for decimal128 which\n+   are not part of the decNumber package.  */\n+\n+/* Set sign; this assumes the sign was previously zero.  */\n+#define decimal128SetSign(d,b) \\\n+  { (d)->bytes[FLOAT_WORDS_BIG_ENDIAN ? 0 : 15] |= ((unsigned) (b) << 7); }\n \n-extern void decDensePackCoeff (const decNumber *, uByte *, Int, Int);\n-extern void decDenseUnpackCoeff (const uByte *, Int, decNumber *, Int, Int);\n+/* Clear sign.  */\n+#define decimal128ClearSign(d) \\\n+  { (d)->bytes[FLOAT_WORDS_BIG_ENDIAN ? 0 : 15] &= ~0x80; }\n+\n+/* Flip sign.  */\n+#define decimal128FlipSign(d) \\\n+  { (d)->bytes[FLOAT_WORDS_BIG_ENDIAN ? 0 : 15] ^= 0x80; }\n+\n+#endif", "previous_filename": "libdecnumber/decUtility.h"}, {"sha": "da9d76beaf6ae5c66986032d0427735cba875991", "filename": "libdecnumber/dpd/decimal128Symbols.h", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2Fdpd%2Fdecimal128Symbols.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2Fdpd%2Fdecimal128Symbols.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2Fdpd%2Fdecimal128Symbols.h?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb", "patch": "@@ -0,0 +1,16 @@\n+#if !defined(DECIMAL128SYMBOLS)\n+#define DECIMAL128SYMBOLS\n+\n+#ifdef IN_LIBGCC2\n+#define decDigitsFromDPD __decDigitsFromDPD\n+#define decDigitsToDPD __decDigitsToDPD\n+#define decimal128Canonical __decimal128Canonical\n+#define decimal128FromNumber __decimal128FromNumber\n+#define decimal128FromString __decimal128FromString\n+#define decimal128IsCanonical __decimal128IsCanonical\n+#define decimal128ToEngString __decimal128ToEngString\n+#define decimal128ToNumber __decimal128ToNumber\n+#define decimal128ToString __decimal128ToString\n+#endif\n+\n+#endif"}, {"sha": "692c2f70ecbdebe4fce0650c8646ae5582936eb3", "filename": "libdecnumber/dpd/decimal32.c", "status": "modified", "additions": 407, "deletions": 249, "changes": 656, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2Fdpd%2Fdecimal32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2Fdpd%2Fdecimal32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2Fdpd%2Fdecimal32.c?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb", "patch": "@@ -1,5 +1,5 @@\n-/* Decimal 32-bit format module for the decNumber C Library\n-   Copyright (C) 2005 Free Software Foundation, Inc.\n+/* Decimal 32-bit format module for the decNumber C Library.\n+   Copyright (C) 2005, 2007 Free Software Foundation, Inc.\n    Contributed by IBM Corporation.  Author Mike Cowlishaw.\n \n    This file is part of GCC.\n@@ -28,310 +28,468 @@\n    Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    02110-1301, USA.  */\n \n+/* ------------------------------------------------------------------ */\n+/* Decimal 32-bit format module\t\t\t\t\t      */\n /* ------------------------------------------------------------------ */\n /* This module comprises the routines for decimal32 format numbers.   */\n-/* Conversions are supplied to and from decNumber and String.         */\n-/*                                                                    */\n-/* No arithmetic routines are included; decNumber provides these.     */\n-/*                                                                    */\n-/* Error handling is the same as decNumber (qv.).                     */\n+/* Conversions are supplied to and from decNumber and String.\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* This is used when decNumber provides operations, either for all    */\n+/* operations or as a proxy between decNumber and decSingle.\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* Error handling is the same as decNumber (qv.).\t\t      */\n /* ------------------------------------------------------------------ */\n-#include <string.h>\t\t/* [for memset/memcpy] */\n-#include <stdio.h>\t\t/* [for printf] */\n+#include <string.h>\t      /* [for memset/memcpy] */\n+#include <stdio.h>\t      /* [for printf] */\n+\n+#include \"config.h\"\t      /* GCC definitions */\n+#define\t DECNUMDIGITS  7      /* make decNumbers with space for 7 */\n+#include \"decNumber.h\"\t      /* base number library */\n+#include \"decNumberLocal.h\"   /* decNumber local types, etc. */\n+#include \"decimal32.h\"\t      /* our primary include */\n \n-#define  DECNUMDIGITS  7\t/* we need decNumbers with space for 7 */\n-#include \"config.h\"\n-#include \"decNumber.h\"\t\t/* base number library */\n-#include \"decNumberLocal.h\"\t/* decNumber local types, etc. */\n-#include \"decimal32.h\"\t\t/* our primary include */\n-#include \"decUtility.h\"\t\t/* utility routines */\n+/* Utility tables and routines [in decimal64.c] */\n+/* DPD2BIN and the reverse are renamed to prevent link-time conflict */\n+/* if decQuad is also built in the same executable */\n+#define DPD2BIN DPD2BINx\n+#define BIN2DPD BIN2DPDx\n+extern const uInt   COMBEXP[32], COMBMSD[32];\n+extern const uShort DPD2BIN[1024];\n+extern const uShort BIN2DPD[1000];\n+extern const uByte  BIN2CHAR[4001];\n+\n+extern void decDigitsToDPD(const decNumber *, uInt *, Int);\n+extern void decDigitsFromDPD(decNumber *, const uInt *, Int);\n \n #if DECTRACE || DECCHECK\n-void decimal32Show (const decimal32 *);\t/* for debug */\n-void decNumberShow (const decNumber *);\t/* .. */\n+void decimal32Show(const decimal32 *);\t\t  /* for debug */\n+extern void decNumberShow(const decNumber *);\t  /* .. */\n #endif\n \n /* Useful macro */\n /* Clear a structure (e.g., a decNumber) */\n #define DEC_clear(d) memset(d, 0, sizeof(*d))\n \n /* ------------------------------------------------------------------ */\n-/* decimal32FromNumber -- convert decNumber to decimal32              */\n-/*                                                                    */\n-/*   ds is the target decimal32                                       */\n-/*   dn is the source number (assumed valid)                          */\n-/*   set is the context, used only for reporting errors               */\n-/*                                                                    */\n+/* decimal32FromNumber -- convert decNumber to decimal32\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*   ds is the target decimal32\t\t\t\t\t      */\n+/*   dn is the source number (assumed valid)\t\t\t      */\n+/*   set is the context, used only for reporting errors\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n /* The set argument is used only for status reporting and for the     */\n /* rounding mode (used if the coefficient is more than DECIMAL32_Pmax */\n-/* digits or an overflow is detected).  If the exponent is out of the */\n-/* valid range then Overflow or Underflow will be raised.             */\n-/* After Underflow a subnormal result is possible.                    */\n-/*                                                                    */\n+/* digits or an overflow is detected).\tIf the exponent is out of the */\n+/* valid range then Overflow or Underflow will be raised.\t      */\n+/* After Underflow a subnormal result is possible.\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n /* DEC_Clamped is set if the number has to be 'folded down' to fit,   */\n /* by reducing its exponent and multiplying the coefficient by a      */\n /* power of ten, or if the exponent on a zero had to be clamped.      */\n /* ------------------------------------------------------------------ */\n-decimal32 *\n-decimal32FromNumber (decimal32 * d32, const decNumber * dn, decContext * set)\n-{\n-  uInt status = 0;\t\t/* status accumulator */\n-  Int pad = 0;\t\t\t/* coefficient pad digits */\n-  decNumber dw;\t\t\t/* work */\n-  decContext dc;\t\t/* .. */\n-  uByte isneg = dn->bits & DECNEG;\t/* non-0 if original sign set */\n-  uInt comb, exp;\t\t/* work */\n-\n-  /* If the number is finite, and has too many digits, or the exponent */\n-  /* could be out of range then we reduce the number under the */\n-  /* appropriate constraints */\n-  if (!(dn->bits & DECSPECIAL))\n-    {\t\t\t\t/* not a special value */\n-      Int ae = dn->exponent + dn->digits - 1;\t/* adjusted exponent */\n-      if (dn->digits > DECIMAL32_Pmax\t/* too many digits */\n-\t  || ae > DECIMAL32_Emax\t/* likely overflow */\n-\t  || ae < DECIMAL32_Emin)\n-\t{\t\t\t/* likely underflow */\n-\t  decContextDefault (&dc, DEC_INIT_DECIMAL32);\t/* [no traps] */\n-\t  dc.round = set->round;\t/* use supplied rounding */\n-\t  decNumberPlus (&dw, dn, &dc);\t/* (round and check) */\n-\t  /* [this changes -0 to 0, but it will be restored below] */\n-\t  status |= dc.status;\t/* save status */\n-\t  dn = &dw;\t\t/* use the work number */\n-\t}\n-      /* [this could have pushed number to Infinity or zero, so this */\n-      /* rounding must be done before we generate the decimal32] */\n-    }\n+decimal32 * decimal32FromNumber(decimal32 *d32, const decNumber *dn,\n+\t\t\t      decContext *set) {\n+  uInt status=0;\t\t   /* status accumulator */\n+  Int ae;\t\t\t   /* adjusted exponent */\n+  decNumber  dw;\t\t   /* work */\n+  decContext dc;\t\t   /* .. */\n+  uInt *pu;\t\t\t   /* .. */\n+  uInt comb, exp;\t\t   /* .. */\n+  uInt targ=0;\t\t\t   /* target 32-bit */\n+\n+  /* If the number has too many digits, or the exponent could be */\n+  /* out of range then reduce the number under the appropriate */\n+  /* constraints.  This could push the number to Infinity or zero, */\n+  /* so this check and rounding must be done before generating the */\n+  /* decimal32] */\n+  ae=dn->exponent+dn->digits-1;\t\t     /* [0 if special] */\n+  if (dn->digits>DECIMAL32_Pmax\t\t     /* too many digits */\n+   || ae>DECIMAL32_Emax\t\t\t     /* likely overflow */\n+   || ae<DECIMAL32_Emin) {\t\t     /* likely underflow */\n+    decContextDefault(&dc, DEC_INIT_DECIMAL32); /* [no traps] */\n+    dc.round=set->round;\t\t     /* use supplied rounding */\n+    decNumberPlus(&dw, dn, &dc);\t     /* (round and check) */\n+    /* [this changes -0 to 0, so enforce the sign...] */\n+    dw.bits|=dn->bits&DECNEG;\n+    status=dc.status;\t\t\t     /* save status */\n+    dn=&dw;\t\t\t\t     /* use the work number */\n+    } /* maybe out of range */\n \n-  DEC_clear (d32);\t\t/* clean the target */\n-  if (dn->bits & DECSPECIAL)\n-    {\t\t\t\t/* a special value */\n-      uByte top;\t\t/* work */\n-      if (dn->bits & DECINF)\n-\ttop = DECIMAL_Inf;\n-      else\n-\t{\t\t\t/* sNaN or qNaN */\n-\t  if ((*dn->lsu != 0 || dn->digits > 1)\t/* non-zero coefficient */\n-\t      && (dn->digits < DECIMAL32_Pmax))\n-\t    {\t\t\t/* coefficient fits */\n-\t      decDensePackCoeff (dn, d32->bytes, sizeof (d32->bytes), 0);\n-\t    }\n-\t  if (dn->bits & DECNAN)\n-\t    top = DECIMAL_NaN;\n-\t  else\n-\t    top = DECIMAL_sNaN;\n+  if (dn->bits&DECSPECIAL) {\t\t\t  /* a special value */\n+    if (dn->bits&DECINF) targ=DECIMAL_Inf<<24;\n+     else {\t\t\t\t\t  /* sNaN or qNaN */\n+      if ((*dn->lsu!=0 || dn->digits>1)\t\t  /* non-zero coefficient */\n+       && (dn->digits<DECIMAL32_Pmax)) {\t  /* coefficient fits */\n+\tdecDigitsToDPD(dn, &targ, 0);\n \t}\n-      d32->bytes[0] = top;\n-    }\n-  else if (decNumberIsZero (dn))\n-    {\t\t\t\t/* a zero */\n+      if (dn->bits&DECNAN) targ|=DECIMAL_NaN<<24;\n+       else targ|=DECIMAL_sNaN<<24;\n+      } /* a NaN */\n+    } /* special */\n+\n+   else { /* is finite */\n+    if (decNumberIsZero(dn)) {\t\t     /* is a zero */\n       /* set and clamp exponent */\n-      if (dn->exponent < -DECIMAL32_Bias)\n-\t{\n-\t  exp = 0;\n-\t  status |= DEC_Clamped;\n+      if (dn->exponent<-DECIMAL32_Bias) {\n+\texp=0;\t\t\t\t     /* low clamp */\n+\tstatus|=DEC_Clamped;\n \t}\n-      else\n-\t{\n-\t  exp = dn->exponent + DECIMAL32_Bias;\t/* bias exponent */\n-\t  if (exp > DECIMAL32_Ehigh)\n-\t    {\t\t\t/* top clamp */\n-\t      exp = DECIMAL32_Ehigh;\n-\t      status |= DEC_Clamped;\n-\t    }\n+       else {\n+\texp=dn->exponent+DECIMAL32_Bias;     /* bias exponent */\n+\tif (exp>DECIMAL32_Ehigh) {\t     /* top clamp */\n+\t  exp=DECIMAL32_Ehigh;\n+\t  status|=DEC_Clamped;\n+\t  }\n \t}\n-      comb = (exp >> 3) & 0x18;\t/* combination field */\n-      d32->bytes[0] = (uByte) (comb << 2);\n-      exp &= 0x3f;\t\t/* remaining exponent bits */\n-      decimal32SetExpCon (d32, exp);\n-    }\n-  else\n-    {\t\t\t\t/* non-zero finite number */\n-      uInt msd;\t\t\t/* work */\n-\n-      /* we have a dn that fits, but it may need to be padded */\n-      exp = (uInt) (dn->exponent + DECIMAL32_Bias);\t/* bias exponent */\n-\n-      if (exp > DECIMAL32_Ehigh)\n-\t{\t\t\t/* fold-down case */\n-\t  pad = exp - DECIMAL32_Ehigh;\n-\t  exp = DECIMAL32_Ehigh;\t/* [to maximum] */\n-\t  status |= DEC_Clamped;\n+      comb=(exp>>3) & 0x18;\t\t/* msd=0, exp top 2 bits .. */\n+      }\n+     else {\t\t\t\t/* non-zero finite number */\n+      uInt msd;\t\t\t\t/* work */\n+      Int pad=0;\t\t\t/* coefficient pad digits */\n+\n+      /* the dn is known to fit, but it may need to be padded */\n+      exp=(uInt)(dn->exponent+DECIMAL32_Bias);\t  /* bias exponent */\n+      if (exp>DECIMAL32_Ehigh) {\t\t  /* fold-down case */\n+\tpad=exp-DECIMAL32_Ehigh;\n+\texp=DECIMAL32_Ehigh;\t\t\t  /* [to maximum] */\n+\tstatus|=DEC_Clamped;\n \t}\n \n-      decDensePackCoeff (dn, d32->bytes, sizeof (d32->bytes), pad);\n+      /* fastpath common case */\n+      if (DECDPUN==3 && pad==0) {\n+\ttarg=BIN2DPD[dn->lsu[0]];\n+\tif (dn->digits>3) targ|=(uInt)(BIN2DPD[dn->lsu[1]])<<10;\n+\tmsd=(dn->digits==7 ? dn->lsu[2] : 0);\n+\t}\n+       else { /* general case */\n+\tdecDigitsToDPD(dn, &targ, pad);\n+\t/* save and clear the top digit */\n+\tmsd=targ>>20;\n+\ttarg&=0x000fffff;\n+\t}\n \n-      /* save and clear the top digit */\n-      msd = ((unsigned) d32->bytes[1] >> 4);\n-      d32->bytes[1] &= 0x0f;\n       /* create the combination field */\n-      if (msd >= 8)\n-\tcomb = 0x18 | (msd & 0x01) | ((exp >> 5) & 0x06);\n-      else\n-\tcomb = (msd & 0x07) | ((exp >> 3) & 0x18);\n-      d32->bytes[0] = (uByte) (comb << 2);\n-      exp &= 0x3f;\t\t/* remaining exponent bits */\n-      decimal32SetExpCon (d32, exp);\n-    }\n+      if (msd>=8) comb=0x18 | ((exp>>5) & 0x06) | (msd & 0x01);\n+\t     else comb=((exp>>3) & 0x18) | msd;\n+      }\n+    targ|=comb<<26;\t\t   /* add combination field .. */\n+    targ|=(exp&0x3f)<<20;\t   /* .. and exponent continuation */\n+    } /* finite */\n+\n+  if (dn->bits&DECNEG) targ|=0x80000000;  /* add sign bit */\n \n-  if (isneg)\n-    decimal32SetSign (d32, 1);\n-  if (status != 0)\n-    decContextSetStatus (set, status);\t/* pass on status */\n+  /* now write to storage; this is endian */\n+  pu=(uInt *)d32->bytes;\t   /* overlay */\n+  *pu=targ;\t\t\t   /* directly store the int */\n \n-  /*decimal32Show(d32); */\n+  if (status!=0) decContextSetStatus(set, status); /* pass on status */\n+  /* decimal32Show(d32); */\n   return d32;\n-}\n+  } /* decimal32FromNumber */\n \n /* ------------------------------------------------------------------ */\n-/* decimal32ToNumber -- convert decimal32 to decNumber                */\n-/*   d32 is the source decimal32                                      */\n-/*   dn is the target number, with appropriate space                  */\n-/* No error is possible.                                              */\n+/* decimal32ToNumber -- convert decimal32 to decNumber\t\t      */\n+/*   d32 is the source decimal32\t\t\t\t      */\n+/*   dn is the target number, with appropriate space\t\t      */\n+/* No error is possible.\t\t\t\t\t      */\n /* ------------------------------------------------------------------ */\n-decNumber *\n-decimal32ToNumber (const decimal32 * d32, decNumber * dn)\n-{\n-  uInt msd;\t\t\t/* coefficient MSD */\n-  decimal32 wk;\t\t\t/* working copy, if needed */\n-  uInt top = d32->bytes[0] & 0x7f;\t/* top byte, less sign bit */\n-  decNumberZero (dn);\t\t/* clean target */\n-  /* set the sign if negative */\n-  if (decimal32Sign (d32))\n-    dn->bits = DECNEG;\n-\n-  if (top >= 0x78)\n-    {\t\t\t\t/* is a special */\n-      if ((top & 0x7c) == (DECIMAL_Inf & 0x7c))\n-\tdn->bits |= DECINF;\n-      else if ((top & 0x7e) == (DECIMAL_NaN & 0x7e))\n-\tdn->bits |= DECNAN;\n-      else\n-\tdn->bits |= DECSNAN;\n-      msd = 0;\t\t\t/* no top digit */\n+decNumber * decimal32ToNumber(const decimal32 *d32, decNumber *dn) {\n+  uInt msd;\t\t\t   /* coefficient MSD */\n+  uInt exp;\t\t\t   /* exponent top two bits */\n+  uInt comb;\t\t\t   /* combination field */\n+  uInt sour;\t\t\t   /* source 32-bit */\n+  const uInt *pu;\t\t   /* work */\n+\n+  /* load source from storage; this is endian */\n+  pu=(const uInt *)d32->bytes;\t   /* overlay */\n+  sour=*pu;\t\t\t   /* directly load the int */\n+\n+  comb=(sour>>26)&0x1f;\t\t   /* combination field */\n+\n+  decNumberZero(dn);\t\t   /* clean number */\n+  if (sour&0x80000000) dn->bits=DECNEG; /* set sign if negative */\n+\n+  msd=COMBMSD[comb];\t\t   /* decode the combination field */\n+  exp=COMBEXP[comb];\t\t   /* .. */\n+\n+  if (exp==3) {\t\t\t   /* is a special */\n+    if (msd==0) {\n+      dn->bits|=DECINF;\n+      return dn;\t\t   /* no coefficient needed */\n+      }\n+    else if (sour&0x02000000) dn->bits|=DECSNAN;\n+    else dn->bits|=DECNAN;\n+    msd=0;\t\t\t   /* no top digit */\n     }\n-  else\n-    {\t\t\t\t/* have a finite number */\n-      uInt comb = top >> 2;\t/* combination field */\n-      uInt exp;\t\t\t/* working exponent */\n-\n-      if (comb >= 0x18)\n-\t{\n-\t  msd = 8 + (comb & 0x01);\n-\t  exp = (comb & 0x06) << 5;\t/* MSBs */\n-\t}\n-      else\n-\t{\n-\t  msd = comb & 0x07;\n-\t  exp = (comb & 0x18) << 3;\n-\t}\n-      dn->exponent = exp + decimal32ExpCon (d32) - DECIMAL32_Bias;\t/* remove bias */\n+   else {\t\t\t   /* is a finite number */\n+    dn->exponent=(exp<<6)+((sour>>20)&0x3f)-DECIMAL32_Bias; /* unbiased */\n     }\n \n-  /* get the coefficient, unless infinite */\n-  if (!(dn->bits & DECINF))\n-    {\n-      Int bunches = DECIMAL32_Pmax / 3;\t/* coefficient full bunches to convert */\n-      Int odd = 0;\t\t/* assume MSD is 0 (no odd bunch) */\n-      if (msd != 0)\n-\t{\t\t\t/* coefficient has leading non-0 digit */\n-\t  /* make a copy of the decimal32, with an extra bunch which has */\n-\t  /* the top digit ready for conversion */\n-\t  wk = *d32;\t\t/* take a copy */\n-\t  wk.bytes[0] = 0;\t/* clear all but coecon */\n-\t  wk.bytes[1] &= 0x0f;\t/* .. */\n-\t  wk.bytes[1] |= (msd << 4);\t/* and prefix MSD */\n-\t  odd++;\t\t/* indicate the extra */\n-\t  d32 = &wk;\t\t/* use the work copy */\n-\t}\n-      decDenseUnpackCoeff (d32->bytes, sizeof (d32->bytes), dn, bunches, odd);\n+  /* get the coefficient */\n+  sour&=0x000fffff;\t\t   /* clean coefficient continuation */\n+  if (msd) {\t\t\t   /* non-zero msd */\n+    sour|=msd<<20;\t\t   /* prefix to coefficient */\n+    decDigitsFromDPD(dn, &sour, 3); /* process 3 declets */\n+    return dn;\n     }\n+  /* msd=0 */\n+  if (!sour) return dn;\t\t   /* easy: coefficient is 0 */\n+  if (sour&0x000ffc00)\t\t   /* need 2 declets? */\n+    decDigitsFromDPD(dn, &sour, 2); /* process 2 declets */\n+   else\n+    decDigitsFromDPD(dn, &sour, 1); /* process 1 declet */\n   return dn;\n-}\n+  } /* decimal32ToNumber */\n \n /* ------------------------------------------------------------------ */\n-/* to-scientific-string -- conversion to numeric string               */\n-/* to-engineering-string -- conversion to numeric string              */\n-/*                                                                    */\n-/*   decimal32ToString(d32, string);                                  */\n-/*   decimal32ToEngString(d32, string);                               */\n-/*                                                                    */\n-/*  d32 is the decimal32 format number to convert                     */\n-/*  string is the string where the result will be laid out            */\n-/*                                                                    */\n-/*  string must be at least 24 characters                             */\n-/*                                                                    */\n-/*  No error is possible, and no status can be set.                   */\n+/* to-scientific-string -- conversion to numeric string\t\t      */\n+/* to-engineering-string -- conversion to numeric string\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*   decimal32ToString(d32, string);\t\t\t\t      */\n+/*   decimal32ToEngString(d32, string);\t\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  d32 is the decimal32 format number to convert\t\t      */\n+/*  string is the string where the result will be laid out\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  string must be at least 24 characters\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  No error is possible, and no status can be set.\t\t      */\n /* ------------------------------------------------------------------ */\n-char *\n-decimal32ToString (const decimal32 * d32, char *string)\n-{\n-  decNumber dn;\t\t\t/* work */\n-  decimal32ToNumber (d32, &dn);\n-  decNumberToString (&dn, string);\n+char * decimal32ToEngString(const decimal32 *d32, char *string){\n+  decNumber dn;\t\t\t\t/* work */\n+  decimal32ToNumber(d32, &dn);\n+  decNumberToEngString(&dn, string);\n   return string;\n-}\n-\n-char *\n-decimal32ToEngString (const decimal32 * d32, char *string)\n-{\n-  decNumber dn;\t\t\t/* work */\n-  decimal32ToNumber (d32, &dn);\n-  decNumberToEngString (&dn, string);\n+  } /* decimal32ToEngString */\n+\n+char * decimal32ToString(const decimal32 *d32, char *string){\n+  uInt msd;\t\t\t   /* coefficient MSD */\n+  Int  exp;\t\t\t   /* exponent top two bits or full */\n+  uInt comb;\t\t\t   /* combination field */\n+  char *cstart;\t\t\t   /* coefficient start */\n+  char *c;\t\t\t   /* output pointer in string */\n+  const uInt *pu;\t\t   /* work */\n+  const uByte *u;\t\t   /* .. */\n+  char *s, *t;\t\t\t   /* .. (source, target) */\n+  Int  dpd;\t\t\t   /* .. */\n+  Int  pre, e;\t\t\t   /* .. */\n+  uInt sour;\t\t\t   /* source 32-bit */\n+\n+  /* load source from storage; this is endian */\n+  pu=(const uInt *)d32->bytes;\t   /* overlay */\n+  sour=*pu;\t\t\t   /* directly load the int */\n+\n+  c=string;\t\t\t   /* where result will go */\n+  if (((Int)sour)<0) *c++='-';\t   /* handle sign */\n+\n+  comb=(sour>>26)&0x1f;\t\t   /* combination field */\n+  msd=COMBMSD[comb];\t\t   /* decode the combination field */\n+  exp=COMBEXP[comb];\t\t   /* .. */\n+\n+  if (exp==3) {\n+    if (msd==0) {\t\t   /* infinity */\n+      strcpy(c,\t  \"Inf\");\n+      strcpy(c+3, \"inity\");\n+      return string;\t\t   /* easy */\n+      }\n+    if (sour&0x02000000) *c++='s'; /* sNaN */\n+    strcpy(c, \"NaN\");\t\t   /* complete word */\n+    c+=3;\t\t\t   /* step past */\n+    if ((sour&0x000fffff)==0) return string; /* zero payload */\n+    /* otherwise drop through to add integer; set correct exp */\n+    exp=0; msd=0;\t\t   /* setup for following code */\n+    }\n+   else exp=(exp<<6)+((sour>>20)&0x3f)-DECIMAL32_Bias; /* unbiased */\n+\n+  /* convert 7 digits of significand to characters */\n+  cstart=c;\t\t\t   /* save start of coefficient */\n+  if (msd) *c++='0'+(char)msd;\t   /* non-zero most significant digit */\n+\n+  /* Now decode the declets.  After extracting each one, it is */\n+  /* decoded to binary and then to a 4-char sequence by table lookup; */\n+  /* the 4-chars are a 1-char length (significant digits, except 000 */\n+  /* has length 0).  This allows us to left-align the first declet */\n+  /* with non-zero content, then remaining ones are full 3-char */\n+  /* length.  We use fixed-length memcpys because variable-length */\n+  /* causes a subroutine call in GCC.  (These are length 4 for speed */\n+  /* and are safe because the array has an extra terminator byte.) */\n+  #define dpd2char u=&BIN2CHAR[DPD2BIN[dpd]*4];\t\t\t  \\\n+\t\t   if (c!=cstart) {memcpy(c, u+1, 4); c+=3;}\t  \\\n+\t\t    else if (*u)  {memcpy(c, u+4-*u, 4); c+=*u;}\n+\n+  dpd=(sour>>10)&0x3ff;\t\t   /* declet 1 */\n+  dpd2char;\n+  dpd=(sour)&0x3ff;\t\t   /* declet 2 */\n+  dpd2char;\n+\n+  if (c==cstart) *c++='0';\t   /* all zeros -- make 0 */\n+\n+  if (exp==0) {\t\t\t   /* integer or NaN case -- easy */\n+    *c='\\0';\t\t\t   /* terminate */\n+    return string;\n+    }\n+\n+  /* non-0 exponent */\n+  e=0;\t\t\t\t   /* assume no E */\n+  pre=c-cstart+exp;\n+  /* [here, pre-exp is the digits count (==1 for zero)] */\n+  if (exp>0 || pre<-5) {\t   /* need exponential form */\n+    e=pre-1;\t\t\t   /* calculate E value */\n+    pre=1;\t\t\t   /* assume one digit before '.' */\n+    } /* exponential form */\n+\n+  /* modify the coefficient, adding 0s, '.', and E+nn as needed */\n+  s=c-1;\t\t\t   /* source (LSD) */\n+  if (pre>0) {\t\t\t   /* ddd.ddd (plain), perhaps with E */\n+    char *dotat=cstart+pre;\n+    if (dotat<c) {\t\t   /* if embedded dot needed... */\n+      t=c;\t\t\t\t/* target */\n+      for (; s>=dotat; s--, t--) *t=*s; /* open the gap; leave t at gap */\n+      *t='.';\t\t\t\t/* insert the dot */\n+      c++;\t\t\t\t/* length increased by one */\n+      }\n+\n+    /* finally add the E-part, if needed; it will never be 0, and has */\n+    /* a maximum length of 3 digits (E-101 case) */\n+    if (e!=0) {\n+      *c++='E';\t\t\t   /* starts with E */\n+      *c++='+';\t\t\t   /* assume positive */\n+      if (e<0) {\n+\t*(c-1)='-';\t\t   /* oops, need '-' */\n+\te=-e;\t\t\t   /* uInt, please */\n+\t}\n+      u=&BIN2CHAR[e*4];\t\t   /* -> length byte */\n+      memcpy(c, u+4-*u, 4);\t   /* copy fixed 4 characters [is safe] */\n+      c+=*u;\t\t\t   /* bump pointer appropriately */\n+      }\n+    *c='\\0';\t\t\t   /* add terminator */\n+    /*printf(\"res %s\\n\", string); */\n+    return string;\n+    } /* pre>0 */\n+\n+  /* -5<=pre<=0: here for plain 0.ddd or 0.000ddd forms (can never have E) */\n+  t=c+1-pre;\n+  *(t+1)='\\0';\t\t\t\t/* can add terminator now */\n+  for (; s>=cstart; s--, t--) *t=*s;\t/* shift whole coefficient right */\n+  c=cstart;\n+  *c++='0';\t\t\t\t/* always starts with 0. */\n+  *c++='.';\n+  for (; pre<0; pre++) *c++='0';\t/* add any 0's after '.' */\n+  /*printf(\"res %s\\n\", string); */\n   return string;\n-}\n+  } /* decimal32ToString */\n \n /* ------------------------------------------------------------------ */\n-/* to-number -- conversion from numeric string                        */\n-/*                                                                    */\n-/*   decimal32FromString(result, string, set);                        */\n-/*                                                                    */\n+/* to-number -- conversion from numeric string\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*   decimal32FromString(result, string, set);\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n /*  result  is the decimal32 format number which gets the result of   */\n-/*          the conversion                                            */\n+/*\t    the conversion\t\t\t\t\t      */\n /*  *string is the character string which should contain a valid      */\n-/*          number (which may be a special value)                     */\n-/*  set     is the context                                            */\n-/*                                                                    */\n+/*\t    number (which may be a special value)\t\t      */\n+/*  set\t    is the context\t\t\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n /* The context is supplied to this routine is used for error handling */\n /* (setting of status and traps) and for the rounding mode, only.     */\n /* If an error occurs, the result will be a valid decimal32 NaN.      */\n /* ------------------------------------------------------------------ */\n-decimal32 *\n-decimal32FromString (decimal32 * result, const char *string, decContext * set)\n-{\n-  decContext dc;\t\t/* work */\n-  decNumber dn;\t\t\t/* .. */\n-\n-  decContextDefault (&dc, DEC_INIT_DECIMAL32);\t/* no traps, please */\n-  dc.round = set->round;\t/* use supplied rounding */\n-\n-  decNumberFromString (&dn, string, &dc);\t/* will round if needed */\n-  decimal32FromNumber (result, &dn, &dc);\n-  if (dc.status != 0)\n-    {\t\t\t\t/* something happened */\n-      decContextSetStatus (set, dc.status);\t/* .. pass it on */\n+decimal32 * decimal32FromString(decimal32 *result, const char *string,\n+\t\t\t\tdecContext *set) {\n+  decContext dc;\t\t\t     /* work */\n+  decNumber dn;\t\t\t\t     /* .. */\n+\n+  decContextDefault(&dc, DEC_INIT_DECIMAL32); /* no traps, please */\n+  dc.round=set->round;\t\t\t      /* use supplied rounding */\n+\n+  decNumberFromString(&dn, string, &dc);     /* will round if needed */\n+  decimal32FromNumber(result, &dn, &dc);\n+  if (dc.status!=0) {\t\t\t     /* something happened */\n+    decContextSetStatus(set, dc.status);     /* .. pass it on */\n     }\n   return result;\n-}\n+  } /* decimal32FromString */\n+\n+/* ------------------------------------------------------------------ */\n+/* decimal32IsCanonical -- test whether encoding is canonical\t      */\n+/*   d32 is the source decimal32\t\t\t\t      */\n+/*   returns 1 if the encoding of d32 is canonical, 0 otherwise\t      */\n+/* No error is possible.\t\t\t\t\t      */\n+/* ------------------------------------------------------------------ */\n+uint32_t decimal32IsCanonical(const decimal32 *d32) {\n+  decNumber dn;\t\t\t\t/* work */\n+  decimal32 canon;\t\t\t/* .. */\n+  decContext dc;\t\t\t/* .. */\n+  decContextDefault(&dc, DEC_INIT_DECIMAL32);\n+  decimal32ToNumber(d32, &dn);\n+  decimal32FromNumber(&canon, &dn, &dc);/* canon will now be canonical */\n+  return memcmp(d32, &canon, DECIMAL32_Bytes)==0;\n+  } /* decimal32IsCanonical */\n+\n+/* ------------------------------------------------------------------ */\n+/* decimal32Canonical -- copy an encoding, ensuring it is canonical   */\n+/*   d32 is the source decimal32\t\t\t\t      */\n+/*   result is the target (may be the same decimal32)\t\t      */\n+/*   returns result\t\t\t\t\t\t      */\n+/* No error is possible.\t\t\t\t\t      */\n+/* ------------------------------------------------------------------ */\n+decimal32 * decimal32Canonical(decimal32 *result, const decimal32 *d32) {\n+  decNumber dn;\t\t\t\t/* work */\n+  decContext dc;\t\t\t/* .. */\n+  decContextDefault(&dc, DEC_INIT_DECIMAL32);\n+  decimal32ToNumber(d32, &dn);\n+  decimal32FromNumber(result, &dn, &dc);/* result will now be canonical */\n+  return result;\n+  } /* decimal32Canonical */\n \n #if DECTRACE || DECCHECK\n+/* Macros for accessing decimal32 fields.  These assume the argument\n+   is a reference (pointer) to the decimal32 structure, and the\n+   decimal32 is in network byte order (big-endian) */\n+/* Get sign */\n+#define decimal32Sign(d)       ((unsigned)(d)->bytes[0]>>7)\n+\n+/* Get combination field */\n+#define decimal32Comb(d)       (((d)->bytes[0] & 0x7c)>>2)\n+\n+/* Get exponent continuation [does not remove bias] */\n+#define decimal32ExpCon(d)     ((((d)->bytes[0] & 0x03)<<4)\t      \\\n+\t\t\t     | ((unsigned)(d)->bytes[1]>>4))\n+\n+/* Set sign [this assumes sign previously 0] */\n+#define decimal32SetSign(d, b) {\t\t\t\t      \\\n+  (d)->bytes[0]|=((unsigned)(b)<<7);}\n+\n+/* Set exponent continuation [does not apply bias] */\n+/* This assumes range has been checked and exponent previously 0; */\n+/* type of exponent must be unsigned */\n+#define decimal32SetExpCon(d, e) {\t\t\t\t      \\\n+  (d)->bytes[0]|=(uint8_t)((e)>>4);\t\t\t\t      \\\n+  (d)->bytes[1]|=(uint8_t)(((e)&0x0F)<<4);}\n+\n /* ------------------------------------------------------------------ */\n-/* decimal32Show -- display a single in hexadecimal [debug aid]       */\n-/*   d32 -- the number to show                                        */\n+/* decimal32Show -- display a decimal32 in hexadecimal [debug aid]    */\n+/*   d32 -- the number to show\t\t\t\t\t      */\n /* ------------------------------------------------------------------ */\n-/* Also shows sign/cob/expconfields extracted */\n-void\n-decimal32Show (const decimal32 * d32)\n-{\n-  char buf[DECIMAL32_Bytes * 2 + 1];\n-  Int i, j;\n-  j = 0;\n-  for (i = 0; i < DECIMAL32_Bytes; i++)\n-    {\n-      sprintf (&buf[j], \"%02x\", d32->bytes[i]);\n-      j = j + 2;\n+/* Also shows sign/cob/expconfields extracted - valid bigendian only */\n+void decimal32Show(const decimal32 *d32) {\n+  char buf[DECIMAL32_Bytes*2+1];\n+  Int i, j=0;\n+\n+  if (DECLITEND) {\n+    for (i=0; i<DECIMAL32_Bytes; i++, j+=2) {\n+      sprintf(&buf[j], \"%02x\", d32->bytes[3-i]);\n+      }\n+    printf(\" D32> %s [S:%d Cb:%02x Ec:%02x] LittleEndian\\n\", buf,\n+\t   d32->bytes[3]>>7, (d32->bytes[3]>>2)&0x1f,\n+\t   ((d32->bytes[3]&0x3)<<4)| (d32->bytes[2]>>4));\n+    }\n+   else {\n+    for (i=0; i<DECIMAL32_Bytes; i++, j+=2) {\n+      sprintf(&buf[j], \"%02x\", d32->bytes[i]);\n+      }\n+    printf(\" D32> %s [S:%d Cb:%02x Ec:%02x] BigEndian\\n\", buf,\n+\t   decimal32Sign(d32), decimal32Comb(d32), decimal32ExpCon(d32));\n     }\n-  printf (\" D32> %s [S:%d Cb:%02x E:%d]\\n\", buf,\n-\t  decimal32Sign (d32), decimal32Comb (d32), decimal32ExpCon (d32));\n-}\n+  } /* decimal32Show */\n #endif"}, {"sha": "0d530464172c4a95e4e8a866112bb561efda4fe6", "filename": "libdecnumber/dpd/decimal32.h", "status": "modified", "additions": 64, "deletions": 85, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2Fdpd%2Fdecimal32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2Fdpd%2Fdecimal32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2Fdpd%2Fdecimal32.h?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb", "patch": "@@ -1,5 +1,5 @@\n-/* Decimal 32-bit format module header for the decNumber C Library\n-   Copyright (C) 2005 Free Software Foundation, Inc.\n+/* Decimal 32-bit format module header for the decNumber C Library.\n+   Copyright (C) 2005, 2007 Free Software Foundation, Inc.\n    Contributed by IBM Corporation.  Author Mike Cowlishaw.\n \n    This file is part of GCC.\n@@ -28,93 +28,72 @@\n    Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    02110-1301, USA.  */\n \n+/* ------------------------------------------------------------------ */\n+/* Decimal 32-bit format module header\t\t\t\t      */\n+/* ------------------------------------------------------------------ */\n+\n #if !defined(DECIMAL32)\n-#define DECIMAL32\n-#define DEC32NAME     \"decimal32\"\t/* Short name */\n-#define DEC32FULLNAME \"Decimal 32-bit Number\"\t/* Verbose name */\n-#define DEC32AUTHOR   \"Mike Cowlishaw\"\t/* Who to blame */\n+  #define DECIMAL32\n+  #define DEC32NAME\t\"decimal32\"\t\t      /* Short name   */\n+  #define DEC32FULLNAME \"Decimal 32-bit Number\"\t      /* Verbose name */\n+  #define DEC32AUTHOR\t\"Mike Cowlishaw\"\t      /* Who to blame */\n \n   /* parameters for decimal32s */\n-#define DECIMAL32_Bytes  4\t/* length */\n-#define DECIMAL32_Pmax   7\t/* maximum precision (digits) */\n-#define DECIMAL32_Emax   96\t/* maximum adjusted exponent */\n-#define DECIMAL32_Emin  -95\t/* minimum adjusted exponent */\n-#define DECIMAL32_Bias   101\t/* bias for the exponent */\n-#define DECIMAL32_String 15\t/* maximum string length, +1 */\n-  /* highest biased exponent (Elimit-1) */\n-#define DECIMAL32_Ehigh  (DECIMAL32_Emax+DECIMAL32_Bias-DECIMAL32_Pmax+1)\n-\n-#ifndef DECNUMDIGITS\n-#define DECNUMDIGITS DECIMAL32_Pmax\t/* size if not already defined */\n-#endif\n-#ifndef DECNUMBER\n-#include \"decNumber.h\"\t\t/* context and number library */\n-#endif\n+  #define DECIMAL32_Bytes  4\t\t/* length\t\t      */\n+  #define DECIMAL32_Pmax   7\t\t/* maximum precision (digits) */\n+  #define DECIMAL32_Emax   96\t\t/* maximum adjusted exponent  */\n+  #define DECIMAL32_Emin  -95\t\t/* minimum adjusted exponent  */\n+  #define DECIMAL32_Bias   101\t\t/* bias for the exponent      */\n+  #define DECIMAL32_String 15\t\t/* maximum string length, +1  */\n+  #define DECIMAL32_EconL  6\t\t/* exp. continuation length   */\n+  /* highest biased exponent (Elimit-1)\t\t\t\t      */\n+  #define DECIMAL32_Ehigh  (DECIMAL32_Emax+DECIMAL32_Bias-DECIMAL32_Pmax+1)\n+\n+  /* check enough digits, if pre-defined\t\t\t      */\n+  #if defined(DECNUMDIGITS)\n+    #if (DECNUMDIGITS<DECIMAL32_Pmax)\n+      #error decimal32.h needs pre-defined DECNUMDIGITS>=7 for safe use\n+    #endif\n+  #endif\n+\n+  #ifndef DECNUMDIGITS\n+    #define DECNUMDIGITS DECIMAL32_Pmax /* size if not already defined*/\n+  #endif\n+  #ifndef DECNUMBER\n+    #include \"decNumber.h\"\t\t/* context and number library */\n+  #endif\n \n   /* Decimal 32-bit type, accessible by bytes */\n-typedef struct\n-{\n-  uint8_t bytes[DECIMAL32_Bytes];\t/* decimal32: 1, 5, 6, 20 bits */\n-} decimal32;\n-\n-  /* special values [top byte excluding sign bit; last two bits are\n-     don't-care for Infinity on input, last bit don't-care for NaN] */\n-#if !defined(DECIMAL_NaN)\n-#define DECIMAL_NaN     0x7c\t/* 0 11111 00 NaN */\n-#define DECIMAL_sNaN    0x7e\t/* 0 11111 10 sNaN */\n-#define DECIMAL_Inf     0x78\t/* 0 11110 00 Infinity */\n-#endif\n-\n-  /* Macros for accessing decimal32 fields.  These assume the argument\n-     is a reference (pointer) to the decimal32 structure */\n-  /* Get sign */\n-#define decimal32Sign(d)       ((unsigned)(d)->bytes[0]>>7)\n-\n-  /* Get combination field */\n-#define decimal32Comb(d)       (((d)->bytes[0] & 0x7c)>>2)\n-\n-  /* Get exponent continuation [does not remove bias] */\n-#define decimal32ExpCon(d)     ((((d)->bytes[0] & 0x03)<<4)         \\\n-                               | ((unsigned)(d)->bytes[1]>>4))\n-\n-  /* Set sign [this assumes sign previously 0] */\n-#define decimal32SetSign(d, b) {                                    \\\n-    (d)->bytes[0]|=((unsigned)(b)<<7);}\n-\n-  /* Clear sign */\n-#define decimal32ClearSign(d) {(d)->bytes[0]&=~0x80;}\n-\n-  /* Flip sign */\n-#define decimal32FlipSign(d) {(d)->bytes[0]^=0x80;}\n-\n-  /* Set exponent continuation [does not apply bias] */\n-  /* This assumes range has been checked and exponent previously 0; */\n-  /* type of exponent must be unsigned */\n-#define decimal32SetExpCon(d, e) {                                  \\\n-    (d)->bytes[0]|=(uint8_t)((e)>>4);                                 \\\n-    (d)->bytes[1]|=(uint8_t)(((e)&0x0F)<<4);}\n-\n-  /* ------------------------------------------------------------------ */\n-  /* Routines                                                           */\n-  /* ------------------------------------------------------------------ */\n-\n-#ifdef IN_LIBGCC2\n-#ifndef decimal32FromString\n-#define decimal32FromString __decimal32FromString\n-#define decimal32ToString __decimal32ToString\n-#define decimal32ToEngString __decimal32ToEngString\n-#define decimal32FromNumber __decimal32FromNumber\n-#define decimal32ToNumber __decimal32ToNumber\n-#endif\n-#endif\n-\n-/* String conversions.  */\n-decimal32 *decimal32FromString (decimal32 *, const char *, decContext *);\n-char *decimal32ToString (const decimal32 *, char *);\n-char *decimal32ToEngString (const decimal32 *, char *);\n-\n-/* decNumber conversions.  */\n-decimal32 *decimal32FromNumber (decimal32 *, const decNumber *, decContext *);\n-decNumber *decimal32ToNumber (const decimal32 *, decNumber *);\n+  typedef struct {\n+    uint8_t bytes[DECIMAL32_Bytes];\t/* decimal32: 1, 5, 6, 20 bits*/\n+    } decimal32;\n+\n+  /* special values [top byte excluding sign bit; last two bits are   */\n+  /* don't-care for Infinity on input, last bit don't-care for NaN]   */\n+  #if !defined(DECIMAL_NaN)\n+    #define DECIMAL_NaN\t    0x7c\t/* 0 11111 00 NaN\t      */\n+    #define DECIMAL_sNaN    0x7e\t/* 0 11111 10 sNaN\t      */\n+    #define DECIMAL_Inf\t    0x78\t/* 0 11110 00 Infinity\t      */\n+  #endif\n+\n+  /* ---------------------------------------------------------------- */\n+  /* Routines\t\t\t\t\t\t\t      */\n+  /* ---------------------------------------------------------------- */\n+\n+  #include \"decimal32Symbols.h\"\n+\n+  /* String conversions\t\t\t\t\t\t      */\n+  decimal32 * decimal32FromString(decimal32 *, const char *, decContext *);\n+  char * decimal32ToString(const decimal32 *, char *);\n+  char * decimal32ToEngString(const decimal32 *, char *);\n+\n+  /* decNumber conversions\t\t\t\t\t      */\n+  decimal32 * decimal32FromNumber(decimal32 *, const decNumber *,\n+\t\t\t\t  decContext *);\n+  decNumber * decimal32ToNumber(const decimal32 *, decNumber *);\n+\n+  /* Format-dependent utilities\t\t\t\t\t      */\n+  uint32_t    decimal32IsCanonical(const decimal32 *);\n+  decimal32 * decimal32Canonical(decimal32 *, const decimal32 *);\n \n #endif"}, {"sha": "de119346c4ccdf6b92832498df4973e83e0dd0ce", "filename": "libdecnumber/dpd/decimal32Symbols.h", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2Fdpd%2Fdecimal32Symbols.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2Fdpd%2Fdecimal32Symbols.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2Fdpd%2Fdecimal32Symbols.h?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb", "patch": "@@ -0,0 +1,16 @@\n+#if !defined(DECIMAL32SYMBOLS)\n+#define DECIMAL32SYMBOLS\n+\n+#ifdef IN_LIBGCC2\n+#define decDigitsFromDPD __decDigitsFromDPD\n+#define decDigitsToDPD __decDigitsToDPD\n+#define decimal32Canonical __decimal32Canonical\n+#define decimal32FromNumber __decimal32FromNumber\n+#define decimal32FromString __decimal32FromString\n+#define decimal32IsCanonical __decimal32IsCanonical\n+#define decimal32ToEngString __decimal32ToEngString\n+#define decimal32ToNumber __decimal32ToNumber\n+#define decimal32ToString __decimal32ToString\n+#endif\n+\n+#endif"}, {"sha": "359214e5dbe1cc6ac7339824688894a64e036fff", "filename": "libdecnumber/dpd/decimal64.c", "status": "modified", "additions": 764, "deletions": 245, "changes": 1009, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2Fdpd%2Fdecimal64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2Fdpd%2Fdecimal64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2Fdpd%2Fdecimal64.c?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb", "patch": "@@ -1,5 +1,5 @@\n-/* Decimal 64-bit format module for the decNumber C Library\n-   Copyright (C) 2005 Free Software Foundation, Inc.\n+/* Decimal 64-bit format module for the decNumber C Library.\n+   Copyright (C) 2005, 2007 Free Software Foundation, Inc.\n    Contributed by IBM Corporation.  Author Mike Cowlishaw.\n \n    This file is part of GCC.\n@@ -28,310 +28,829 @@\n    Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    02110-1301, USA.  */\n \n+/* ------------------------------------------------------------------ */\n+/* Decimal 64-bit format module\t\t\t\t\t      */\n /* ------------------------------------------------------------------ */\n /* This module comprises the routines for decimal64 format numbers.   */\n-/* Conversions are supplied to and from decNumber and String.         */\n-/*                                                                    */\n-/* No arithmetic routines are included; decNumber provides these.     */\n-/*                                                                    */\n-/* Error handling is the same as decNumber (qv.).                     */\n+/* Conversions are supplied to and from decNumber and String.\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* This is used when decNumber provides operations, either for all    */\n+/* operations or as a proxy between decNumber and decSingle.\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* Error handling is the same as decNumber (qv.).\t\t      */\n /* ------------------------------------------------------------------ */\n-#include <string.h>\t\t/* [for memset/memcpy] */\n-#include <stdio.h>\t\t/* [for printf] */\n+#include <string.h>\t      /* [for memset/memcpy] */\n+#include <stdio.h>\t      /* [for printf] */\n+\n+#include \"config.h\"\t      /* GCC definitions */\n+#define\t DECNUMDIGITS 16      /* make decNumbers with space for 16 */\n+#include \"decNumber.h\"\t      /* base number library */\n+#include \"decNumberLocal.h\"   /* decNumber local types, etc. */\n+#include \"decimal64.h\"\t      /* our primary include */\n \n-#define  DECNUMDIGITS 16\t/* we need decNumbers with space for 16 */\n-#include \"config.h\"\n-#include \"decNumber.h\"\t\t/* base number library */\n-#include \"decNumberLocal.h\"\t/* decNumber local types, etc. */\n-#include \"decimal64.h\"\t\t/* our primary include */\n-#include \"decUtility.h\"\t\t/* utility routines */\n+/* Utility routines and tables [in decimal64.c]; externs for C++ */\n+/* DPD2BIN and the reverse are renamed to prevent link-time conflict */\n+/* if decQuad is also built in the same executable */\n+#define DPD2BIN DPD2BINx\n+#define BIN2DPD BIN2DPDx\n+extern const uInt COMBEXP[32], COMBMSD[32];\n+extern const uShort DPD2BIN[1024];\n+extern const uShort BIN2DPD[1000];\n+extern const uByte  BIN2CHAR[4001];\n+\n+extern void decDigitsFromDPD(decNumber *, const uInt *, Int);\n+extern void decDigitsToDPD(const decNumber *, uInt *, Int);\n \n #if DECTRACE || DECCHECK\n-void decimal64Show (const decimal64 *);\t/* for debug */\n-void decNumberShow (const decNumber *);\t/* .. */\n+void decimal64Show(const decimal64 *);\t\t  /* for debug */\n+extern void decNumberShow(const decNumber *);\t  /* .. */\n #endif\n \n /* Useful macro */\n /* Clear a structure (e.g., a decNumber) */\n #define DEC_clear(d) memset(d, 0, sizeof(*d))\n \n+/* define and include the tables to use for conversions */\n+#define DEC_BIN2CHAR 1\n+#define DEC_DPD2BIN  1\n+#define DEC_BIN2DPD  1\t\t   /* used for all sizes */\n+#include \"decDPD.h\"\t\t   /* lookup tables */\n+\n /* ------------------------------------------------------------------ */\n-/* decimal64FromNumber -- convert decNumber to decimal64              */\n-/*                                                                    */\n-/*   ds is the target decimal64                                       */\n-/*   dn is the source number (assumed valid)                          */\n-/*   set is the context, used only for reporting errors               */\n-/*                                                                    */\n+/* decimal64FromNumber -- convert decNumber to decimal64\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*   ds is the target decimal64\t\t\t\t\t      */\n+/*   dn is the source number (assumed valid)\t\t\t      */\n+/*   set is the context, used only for reporting errors\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n /* The set argument is used only for status reporting and for the     */\n /* rounding mode (used if the coefficient is more than DECIMAL64_Pmax */\n-/* digits or an overflow is detected).  If the exponent is out of the */\n-/* valid range then Overflow or Underflow will be raised.             */\n-/* After Underflow a subnormal result is possible.                    */\n-/*                                                                    */\n+/* digits or an overflow is detected).\tIf the exponent is out of the */\n+/* valid range then Overflow or Underflow will be raised.\t      */\n+/* After Underflow a subnormal result is possible.\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n /* DEC_Clamped is set if the number has to be 'folded down' to fit,   */\n /* by reducing its exponent and multiplying the coefficient by a      */\n /* power of ten, or if the exponent on a zero had to be clamped.      */\n /* ------------------------------------------------------------------ */\n-decimal64 *\n-decimal64FromNumber (decimal64 * d64, const decNumber * dn, decContext * set)\n-{\n-  uInt status = 0;\t\t/* status accumulator */\n-  Int pad = 0;\t\t\t/* coefficient pad digits */\n-  decNumber dw;\t\t\t/* work */\n-  decContext dc;\t\t/* .. */\n-  uByte isneg = dn->bits & DECNEG;\t/* non-0 if original sign set */\n-  uInt comb, exp;\t\t/* work */\n-\n-  /* If the number is finite, and has too many digits, or the exponent */\n-  /* could be out of range then we reduce the number under the */\n-  /* appropriate constraints */\n-  if (!(dn->bits & DECSPECIAL))\n-    {\t\t\t\t/* not a special value */\n-      Int ae = dn->exponent + dn->digits - 1;\t/* adjusted exponent */\n-      if (dn->digits > DECIMAL64_Pmax\t/* too many digits */\n-\t  || ae > DECIMAL64_Emax\t/* likely overflow */\n-\t  || ae < DECIMAL64_Emin)\n-\t{\t\t\t/* likely underflow */\n-\t  decContextDefault (&dc, DEC_INIT_DECIMAL64);\t/* [no traps] */\n-\t  dc.round = set->round;\t/* use supplied rounding */\n-\t  decNumberPlus (&dw, dn, &dc);\t/* (round and check) */\n-\t  /* [this changes -0 to 0, but it will be restored below] */\n-\t  status |= dc.status;\t/* save status */\n-\t  dn = &dw;\t\t/* use the work number */\n-\t}\n-      /* [this could have pushed number to Infinity or zero, so this */\n-      /* rounding must be done before we generate the decimal64] */\n-    }\n+decimal64 * decimal64FromNumber(decimal64 *d64, const decNumber *dn,\n+\t\t\t\tdecContext *set) {\n+  uInt status=0;\t\t   /* status accumulator */\n+  Int ae;\t\t\t   /* adjusted exponent */\n+  decNumber  dw;\t\t   /* work */\n+  decContext dc;\t\t   /* .. */\n+  uInt *pu;\t\t\t   /* .. */\n+  uInt comb, exp;\t\t   /* .. */\n+  uInt targar[2]={0, 0};\t   /* target 64-bit */\n+  #define targhi targar[1]\t   /* name the word with the sign */\n+  #define targlo targar[0]\t   /* and the other */\n+\n+  /* If the number has too many digits, or the exponent could be */\n+  /* out of range then reduce the number under the appropriate */\n+  /* constraints.  This could push the number to Infinity or zero, */\n+  /* so this check and rounding must be done before generating the */\n+  /* decimal64] */\n+  ae=dn->exponent+dn->digits-1;\t\t     /* [0 if special] */\n+  if (dn->digits>DECIMAL64_Pmax\t\t     /* too many digits */\n+   || ae>DECIMAL64_Emax\t\t\t     /* likely overflow */\n+   || ae<DECIMAL64_Emin) {\t\t     /* likely underflow */\n+    decContextDefault(&dc, DEC_INIT_DECIMAL64); /* [no traps] */\n+    dc.round=set->round;\t\t     /* use supplied rounding */\n+    decNumberPlus(&dw, dn, &dc);\t     /* (round and check) */\n+    /* [this changes -0 to 0, so enforce the sign...] */\n+    dw.bits|=dn->bits&DECNEG;\n+    status=dc.status;\t\t\t     /* save status */\n+    dn=&dw;\t\t\t\t     /* use the work number */\n+    } /* maybe out of range */\n \n-  DEC_clear (d64);\t\t/* clean the target */\n-  if (dn->bits & DECSPECIAL)\n-    {\t\t\t\t/* a special value */\n-      uByte top;\t\t/* work */\n-      if (dn->bits & DECINF)\n-\ttop = DECIMAL_Inf;\n-      else\n-\t{\t\t\t/* sNaN or qNaN */\n-\t  if ((*dn->lsu != 0 || dn->digits > 1)\t/* non-zero coefficient */\n-\t      && (dn->digits < DECIMAL64_Pmax))\n-\t    {\t\t\t/* coefficient fits */\n-\t      decDensePackCoeff (dn, d64->bytes, sizeof (d64->bytes), 0);\n-\t    }\n-\t  if (dn->bits & DECNAN)\n-\t    top = DECIMAL_NaN;\n-\t  else\n-\t    top = DECIMAL_sNaN;\n+  if (dn->bits&DECSPECIAL) {\t\t\t  /* a special value */\n+    if (dn->bits&DECINF) targhi=DECIMAL_Inf<<24;\n+     else {\t\t\t\t\t  /* sNaN or qNaN */\n+      if ((*dn->lsu!=0 || dn->digits>1)\t\t  /* non-zero coefficient */\n+       && (dn->digits<DECIMAL64_Pmax)) {\t  /* coefficient fits */\n+\tdecDigitsToDPD(dn, targar, 0);\n \t}\n-      d64->bytes[0] = top;\n-    }\n-  else if (decNumberIsZero (dn))\n-    {\t\t\t\t/* a zero */\n+      if (dn->bits&DECNAN) targhi|=DECIMAL_NaN<<24;\n+       else targhi|=DECIMAL_sNaN<<24;\n+      } /* a NaN */\n+    } /* special */\n+\n+   else { /* is finite */\n+    if (decNumberIsZero(dn)) {\t\t     /* is a zero */\n       /* set and clamp exponent */\n-      if (dn->exponent < -DECIMAL64_Bias)\n-\t{\n-\t  exp = 0;\n-\t  status |= DEC_Clamped;\n+      if (dn->exponent<-DECIMAL64_Bias) {\n+\texp=0;\t\t\t\t     /* low clamp */\n+\tstatus|=DEC_Clamped;\n \t}\n-      else\n-\t{\n-\t  exp = dn->exponent + DECIMAL64_Bias;\t/* bias exponent */\n-\t  if (exp > DECIMAL64_Ehigh)\n-\t    {\t\t\t/* top clamp */\n-\t      exp = DECIMAL64_Ehigh;\n-\t      status |= DEC_Clamped;\n-\t    }\n+       else {\n+\texp=dn->exponent+DECIMAL64_Bias;     /* bias exponent */\n+\tif (exp>DECIMAL64_Ehigh) {\t     /* top clamp */\n+\t  exp=DECIMAL64_Ehigh;\n+\t  status|=DEC_Clamped;\n+\t  }\n \t}\n-      comb = (exp >> 5) & 0x18;\t/* combination field */\n-      d64->bytes[0] = (uByte) (comb << 2);\n-      exp &= 0xff;\t\t/* remaining exponent bits */\n-      decimal64SetExpCon (d64, exp);\n-    }\n-  else\n-    {\t\t\t\t/* non-zero finite number */\n-      uInt msd;\t\t\t/* work */\n-\n-      /* we have a dn that fits, but it may need to be padded */\n-      exp = (uInt) (dn->exponent + DECIMAL64_Bias);\t/* bias exponent */\n-      if (exp > DECIMAL64_Ehigh)\n-\t{\t\t\t/* fold-down case */\n-\t  pad = exp - DECIMAL64_Ehigh;\n-\t  exp = DECIMAL64_Ehigh;\t/* [to maximum] */\n-\t  status |= DEC_Clamped;\n+      comb=(exp>>5) & 0x18;\t\t/* msd=0, exp top 2 bits .. */\n+      }\n+     else {\t\t\t\t/* non-zero finite number */\n+      uInt msd;\t\t\t\t/* work */\n+      Int pad=0;\t\t\t/* coefficient pad digits */\n+\n+      /* the dn is known to fit, but it may need to be padded */\n+      exp=(uInt)(dn->exponent+DECIMAL64_Bias);\t  /* bias exponent */\n+      if (exp>DECIMAL64_Ehigh) {\t\t  /* fold-down case */\n+\tpad=exp-DECIMAL64_Ehigh;\n+\texp=DECIMAL64_Ehigh;\t\t\t  /* [to maximum] */\n+\tstatus|=DEC_Clamped;\n \t}\n \n-      decDensePackCoeff (dn, d64->bytes, sizeof (d64->bytes), pad);\n+      /* fastpath common case */\n+      if (DECDPUN==3 && pad==0) {\n+\tuInt dpd[6]={0,0,0,0,0,0};\n+\tuInt i;\n+\tInt d=dn->digits;\n+\tfor (i=0; d>0; i++, d-=3) dpd[i]=BIN2DPD[dn->lsu[i]];\n+\ttarglo =dpd[0];\n+\ttarglo|=dpd[1]<<10;\n+\ttarglo|=dpd[2]<<20;\n+\tif (dn->digits>6) {\n+\t  targlo|=dpd[3]<<30;\n+\t  targhi =dpd[3]>>2;\n+\t  targhi|=dpd[4]<<8;\n+\t  }\n+\tmsd=dpd[5];\t\t   /* [did not really need conversion] */\n+\t}\n+       else { /* general case */\n+\tdecDigitsToDPD(dn, targar, pad);\n+\t/* save and clear the top digit */\n+\tmsd=targhi>>18;\n+\ttarghi&=0x0003ffff;\n+\t}\n \n-      /* save and clear the top digit */\n-      msd = ((unsigned) d64->bytes[1] >> 2) & 0x0f;\n-      d64->bytes[1] &= 0x03;\n       /* create the combination field */\n-      if (msd >= 8)\n-\tcomb = 0x18 | (msd & 0x01) | ((exp >> 7) & 0x06);\n-      else\n-\tcomb = (msd & 0x07) | ((exp >> 5) & 0x18);\n-      d64->bytes[0] = (uByte) (comb << 2);\n-      exp &= 0xff;\t\t/* remaining exponent bits */\n-      decimal64SetExpCon (d64, exp);\n-    }\n+      if (msd>=8) comb=0x18 | ((exp>>7) & 0x06) | (msd & 0x01);\n+\t     else comb=((exp>>5) & 0x18) | msd;\n+      }\n+    targhi|=comb<<26;\t\t   /* add combination field .. */\n+    targhi|=(exp&0xff)<<18;\t   /* .. and exponent continuation */\n+    } /* finite */\n+\n+  if (dn->bits&DECNEG) targhi|=0x80000000; /* add sign bit */\n \n-  if (isneg)\n-    decimal64SetSign (d64, 1);\n-  if (status != 0)\n-    decContextSetStatus (set, status);\t/* pass on status */\n+  /* now write to storage; this is now always endian */\n+  pu=(uInt *)d64->bytes;\t   /* overlay */\n+  if (DECLITEND) {\n+    pu[0]=targar[0];\t\t   /* directly store the low int */\n+    pu[1]=targar[1];\t\t   /* then the high int */\n+    }\n+   else {\n+    pu[0]=targar[1];\t\t   /* directly store the high int */\n+    pu[1]=targar[0];\t\t   /* then the low int */\n+    }\n \n-  /*decimal64Show(d64); */\n+  if (status!=0) decContextSetStatus(set, status); /* pass on status */\n+  /* decimal64Show(d64); */\n   return d64;\n-}\n+  } /* decimal64FromNumber */\n \n /* ------------------------------------------------------------------ */\n-/* decimal64ToNumber -- convert decimal64 to decNumber                */\n-/*   d64 is the source decimal64                                      */\n-/*   dn is the target number, with appropriate space                  */\n-/* No error is possible.                                              */\n+/* decimal64ToNumber -- convert decimal64 to decNumber\t\t      */\n+/*   d64 is the source decimal64\t\t\t\t      */\n+/*   dn is the target number, with appropriate space\t\t      */\n+/* No error is possible.\t\t\t\t\t      */\n /* ------------------------------------------------------------------ */\n-decNumber *\n-decimal64ToNumber (const decimal64 * d64, decNumber * dn)\n-{\n-  uInt msd;\t\t\t/* coefficient MSD */\n-  decimal64 wk;\t\t\t/* working copy, if needed */\n-  uInt top = d64->bytes[0] & 0x7f;\t/* top byte, less sign bit */\n-  decNumberZero (dn);\t\t/* clean target */\n-  /* set the sign if negative */\n-  if (decimal64Sign (d64))\n-    dn->bits = DECNEG;\n-\n-  if (top >= 0x78)\n-    {\t\t\t\t/* is a special */\n-      if ((top & 0x7c) == (DECIMAL_Inf & 0x7c))\n-\tdn->bits |= DECINF;\n-      else if ((top & 0x7e) == (DECIMAL_NaN & 0x7e))\n-\tdn->bits |= DECNAN;\n-      else\n-\tdn->bits |= DECSNAN;\n-      msd = 0;\t\t\t/* no top digit */\n+decNumber * decimal64ToNumber(const decimal64 *d64, decNumber *dn) {\n+  uInt msd;\t\t\t   /* coefficient MSD */\n+  uInt exp;\t\t\t   /* exponent top two bits */\n+  uInt comb;\t\t\t   /* combination field */\n+  const uInt *pu;\t\t   /* work */\n+  Int  need;\t\t\t   /* .. */\n+  uInt sourar[2];\t\t   /* source 64-bit */\n+  #define sourhi sourar[1]\t   /* name the word with the sign */\n+  #define sourlo sourar[0]\t   /* and the lower word */\n+\n+  /* load source from storage; this is endian */\n+  pu=(const uInt *)d64->bytes;\t   /* overlay */\n+  if (DECLITEND) {\n+    sourlo=pu[0];\t\t   /* directly load the low int */\n+    sourhi=pu[1];\t\t   /* then the high int */\n     }\n-  else\n-    {\t\t\t\t/* have a finite number */\n-      uInt comb = top >> 2;\t/* combination field */\n-      uInt exp;\t\t\t/* exponent */\n-\n-      if (comb >= 0x18)\n-\t{\n-\t  msd = 8 + (comb & 0x01);\n-\t  exp = (comb & 0x06) << 7;\t/* MSBs */\n-\t}\n-      else\n-\t{\n-\t  msd = comb & 0x07;\n-\t  exp = (comb & 0x18) << 5;\n-\t}\n-      dn->exponent = exp + decimal64ExpCon (d64) - DECIMAL64_Bias;\t/* remove bias */\n+   else {\n+    sourhi=pu[0];\t\t   /* directly load the high int */\n+    sourlo=pu[1];\t\t   /* then the low int */\n     }\n \n-  /* get the coefficient, unless infinite */\n-  if (!(dn->bits & DECINF))\n-    {\n-      Int bunches = DECIMAL64_Pmax / 3;\t/* coefficient full bunches to convert */\n-      Int odd = 0;\t\t/* assume MSD is 0 (no odd bunch) */\n-      if (msd != 0)\n-\t{\t\t\t/* coefficient has leading non-0 digit */\n-\t  /* make a copy of the decimal64, with an extra bunch which has */\n-\t  /* the top digit ready for conversion */\n-\t  wk = *d64;\t\t/* take a copy */\n-\t  wk.bytes[0] = 0;\t/* clear all but coecon */\n-\t  wk.bytes[1] &= 0x03;\t/* .. */\n-\t  wk.bytes[1] |= (msd << 2);\t/* and prefix MSD */\n-\t  odd++;\t\t/* indicate the extra */\n-\t  d64 = &wk;\t\t/* use the work copy */\n-\t}\n-      decDenseUnpackCoeff (d64->bytes, sizeof (d64->bytes), dn, bunches, odd);\n+  comb=(sourhi>>26)&0x1f;\t   /* combination field */\n+\n+  decNumberZero(dn);\t\t   /* clean number */\n+  if (sourhi&0x80000000) dn->bits=DECNEG; /* set sign if negative */\n+\n+  msd=COMBMSD[comb];\t\t   /* decode the combination field */\n+  exp=COMBEXP[comb];\t\t   /* .. */\n+\n+  if (exp==3) {\t\t\t   /* is a special */\n+    if (msd==0) {\n+      dn->bits|=DECINF;\n+      return dn;\t\t   /* no coefficient needed */\n+      }\n+    else if (sourhi&0x02000000) dn->bits|=DECSNAN;\n+    else dn->bits|=DECNAN;\n+    msd=0;\t\t\t   /* no top digit */\n+    }\n+   else {\t\t\t   /* is a finite number */\n+    dn->exponent=(exp<<8)+((sourhi>>18)&0xff)-DECIMAL64_Bias; /* unbiased */\n     }\n+\n+  /* get the coefficient */\n+  sourhi&=0x0003ffff;\t\t   /* clean coefficient continuation */\n+  if (msd) {\t\t\t   /* non-zero msd */\n+    sourhi|=msd<<18;\t\t   /* prefix to coefficient */\n+    need=6;\t\t\t   /* process 6 declets */\n+    }\n+   else { /* msd=0 */\n+    if (!sourhi) {\t\t   /* top word 0 */\n+      if (!sourlo) return dn;\t   /* easy: coefficient is 0 */\n+      need=3;\t\t\t   /* process at least 3 declets */\n+      if (sourlo&0xc0000000) need++; /* process 4 declets */\n+      /* [could reduce some more, here] */\n+      }\n+     else {\t\t\t   /* some bits in top word, msd=0 */\n+      need=4;\t\t\t   /* process at least 4 declets */\n+      if (sourhi&0x0003ff00) need++; /* top declet!=0, process 5 */\n+      }\n+    } /*msd=0 */\n+\n+  decDigitsFromDPD(dn, sourar, need);\t/* process declets */\n   return dn;\n-}\n+  } /* decimal64ToNumber */\n+\n \n /* ------------------------------------------------------------------ */\n-/* to-scientific-string -- conversion to numeric string               */\n-/* to-engineering-string -- conversion to numeric string              */\n-/*                                                                    */\n-/*   decimal64ToString(d64, string);                                  */\n-/*   decimal64ToEngString(d64, string);                               */\n-/*                                                                    */\n-/*  d64 is the decimal64 format number to convert                     */\n-/*  string is the string where the result will be laid out            */\n-/*                                                                    */\n-/*  string must be at least 24 characters                             */\n-/*                                                                    */\n-/*  No error is possible, and no status can be set.                   */\n+/* to-scientific-string -- conversion to numeric string\t\t      */\n+/* to-engineering-string -- conversion to numeric string\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*   decimal64ToString(d64, string);\t\t\t\t      */\n+/*   decimal64ToEngString(d64, string);\t\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  d64 is the decimal64 format number to convert\t\t      */\n+/*  string is the string where the result will be laid out\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  string must be at least 24 characters\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  No error is possible, and no status can be set.\t\t      */\n /* ------------------------------------------------------------------ */\n-char *\n-decimal64ToString (const decimal64 * d64, char *string)\n-{\n-  decNumber dn;\t\t\t/* work */\n-  decimal64ToNumber (d64, &dn);\n-  decNumberToString (&dn, string);\n+char * decimal64ToEngString(const decimal64 *d64, char *string){\n+  decNumber dn;\t\t\t\t/* work */\n+  decimal64ToNumber(d64, &dn);\n+  decNumberToEngString(&dn, string);\n   return string;\n-}\n-\n-char *\n-decimal64ToEngString (const decimal64 * d64, char *string)\n-{\n-  decNumber dn;\t\t\t/* work */\n-  decimal64ToNumber (d64, &dn);\n-  decNumberToEngString (&dn, string);\n+  } /* decimal64ToEngString */\n+\n+char * decimal64ToString(const decimal64 *d64, char *string){\n+  uInt msd;\t\t\t   /* coefficient MSD */\n+  Int  exp;\t\t\t   /* exponent top two bits or full */\n+  uInt comb;\t\t\t   /* combination field */\n+  char *cstart;\t\t\t   /* coefficient start */\n+  char *c;\t\t\t   /* output pointer in string */\n+  const uInt *pu;\t\t   /* work */\n+  char *s, *t;\t\t\t   /* .. (source, target) */\n+  Int  dpd;\t\t\t   /* .. */\n+  Int  pre, e;\t\t\t   /* .. */\n+  const uByte *u;\t\t   /* .. */\n+\n+  uInt sourar[2];\t\t   /* source 64-bit */\n+  #define sourhi sourar[1]\t   /* name the word with the sign */\n+  #define sourlo sourar[0]\t   /* and the lower word */\n+\n+  /* load source from storage; this is endian */\n+  pu=(const uInt *)d64->bytes;\t   /* overlay */\n+  if (DECLITEND) {\n+    sourlo=pu[0];\t\t   /* directly load the low int */\n+    sourhi=pu[1];\t\t   /* then the high int */\n+    }\n+   else {\n+    sourhi=pu[0];\t\t   /* directly load the high int */\n+    sourlo=pu[1];\t\t   /* then the low int */\n+    }\n+\n+  c=string;\t\t\t   /* where result will go */\n+  if (((Int)sourhi)<0) *c++='-';   /* handle sign */\n+\n+  comb=(sourhi>>26)&0x1f;\t   /* combination field */\n+  msd=COMBMSD[comb];\t\t   /* decode the combination field */\n+  exp=COMBEXP[comb];\t\t   /* .. */\n+\n+  if (exp==3) {\n+    if (msd==0) {\t\t   /* infinity */\n+      strcpy(c,\t  \"Inf\");\n+      strcpy(c+3, \"inity\");\n+      return string;\t\t   /* easy */\n+      }\n+    if (sourhi&0x02000000) *c++='s'; /* sNaN */\n+    strcpy(c, \"NaN\");\t\t   /* complete word */\n+    c+=3;\t\t\t   /* step past */\n+    if (sourlo==0 && (sourhi&0x0003ffff)==0) return string; /* zero payload */\n+    /* otherwise drop through to add integer; set correct exp */\n+    exp=0; msd=0;\t\t   /* setup for following code */\n+    }\n+   else exp=(exp<<8)+((sourhi>>18)&0xff)-DECIMAL64_Bias;\n+\n+  /* convert 16 digits of significand to characters */\n+  cstart=c;\t\t\t   /* save start of coefficient */\n+  if (msd) *c++='0'+(char)msd;\t   /* non-zero most significant digit */\n+\n+  /* Now decode the declets.  After extracting each one, it is */\n+  /* decoded to binary and then to a 4-char sequence by table lookup; */\n+  /* the 4-chars are a 1-char length (significant digits, except 000 */\n+  /* has length 0).  This allows us to left-align the first declet */\n+  /* with non-zero content, then remaining ones are full 3-char */\n+  /* length.  We use fixed-length memcpys because variable-length */\n+  /* causes a subroutine call in GCC.  (These are length 4 for speed */\n+  /* and are safe because the array has an extra terminator byte.) */\n+  #define dpd2char u=&BIN2CHAR[DPD2BIN[dpd]*4];\t\t\t  \\\n+\t\t   if (c!=cstart) {memcpy(c, u+1, 4); c+=3;}\t  \\\n+\t\t    else if (*u)  {memcpy(c, u+4-*u, 4); c+=*u;}\n+\n+  dpd=(sourhi>>8)&0x3ff;\t\t     /* declet 1 */\n+  dpd2char;\n+  dpd=((sourhi&0xff)<<2) | (sourlo>>30);     /* declet 2 */\n+  dpd2char;\n+  dpd=(sourlo>>20)&0x3ff;\t\t     /* declet 3 */\n+  dpd2char;\n+  dpd=(sourlo>>10)&0x3ff;\t\t     /* declet 4 */\n+  dpd2char;\n+  dpd=(sourlo)&0x3ff;\t\t\t     /* declet 5 */\n+  dpd2char;\n+\n+  if (c==cstart) *c++='0';\t   /* all zeros -- make 0 */\n+\n+  if (exp==0) {\t\t\t   /* integer or NaN case -- easy */\n+    *c='\\0';\t\t\t   /* terminate */\n+    return string;\n+    }\n+\n+  /* non-0 exponent */\n+  e=0;\t\t\t\t   /* assume no E */\n+  pre=c-cstart+exp;\n+  /* [here, pre-exp is the digits count (==1 for zero)] */\n+  if (exp>0 || pre<-5) {\t   /* need exponential form */\n+    e=pre-1;\t\t\t   /* calculate E value */\n+    pre=1;\t\t\t   /* assume one digit before '.' */\n+    } /* exponential form */\n+\n+  /* modify the coefficient, adding 0s, '.', and E+nn as needed */\n+  s=c-1;\t\t\t   /* source (LSD) */\n+  if (pre>0) {\t\t\t   /* ddd.ddd (plain), perhaps with E */\n+    char *dotat=cstart+pre;\n+    if (dotat<c) {\t\t   /* if embedded dot needed... */\n+      t=c;\t\t\t\t/* target */\n+      for (; s>=dotat; s--, t--) *t=*s; /* open the gap; leave t at gap */\n+      *t='.';\t\t\t\t/* insert the dot */\n+      c++;\t\t\t\t/* length increased by one */\n+      }\n+\n+    /* finally add the E-part, if needed; it will never be 0, and has */\n+    /* a maximum length of 3 digits */\n+    if (e!=0) {\n+      *c++='E';\t\t\t   /* starts with E */\n+      *c++='+';\t\t\t   /* assume positive */\n+      if (e<0) {\n+\t*(c-1)='-';\t\t   /* oops, need '-' */\n+\te=-e;\t\t\t   /* uInt, please */\n+\t}\n+      u=&BIN2CHAR[e*4];\t\t   /* -> length byte */\n+      memcpy(c, u+4-*u, 4);\t   /* copy fixed 4 characters [is safe] */\n+      c+=*u;\t\t\t   /* bump pointer appropriately */\n+      }\n+    *c='\\0';\t\t\t   /* add terminator */\n+    /*printf(\"res %s\\n\", string); */\n+    return string;\n+    } /* pre>0 */\n+\n+  /* -5<=pre<=0: here for plain 0.ddd or 0.000ddd forms (can never have E) */\n+  t=c+1-pre;\n+  *(t+1)='\\0';\t\t\t\t/* can add terminator now */\n+  for (; s>=cstart; s--, t--) *t=*s;\t/* shift whole coefficient right */\n+  c=cstart;\n+  *c++='0';\t\t\t\t/* always starts with 0. */\n+  *c++='.';\n+  for (; pre<0; pre++) *c++='0';\t/* add any 0's after '.' */\n+  /*printf(\"res %s\\n\", string); */\n   return string;\n-}\n+  } /* decimal64ToString */\n \n /* ------------------------------------------------------------------ */\n-/* to-number -- conversion from numeric string                        */\n-/*                                                                    */\n-/*   decimal64FromString(result, string, set);                        */\n-/*                                                                    */\n+/* to-number -- conversion from numeric string\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*   decimal64FromString(result, string, set);\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n /*  result  is the decimal64 format number which gets the result of   */\n-/*          the conversion                                            */\n+/*\t    the conversion\t\t\t\t\t      */\n /*  *string is the character string which should contain a valid      */\n-/*          number (which may be a special value)                     */\n-/*  set     is the context                                            */\n-/*                                                                    */\n+/*\t    number (which may be a special value)\t\t      */\n+/*  set\t    is the context\t\t\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n /* The context is supplied to this routine is used for error handling */\n /* (setting of status and traps) and for the rounding mode, only.     */\n /* If an error occurs, the result will be a valid decimal64 NaN.      */\n /* ------------------------------------------------------------------ */\n-decimal64 *\n-decimal64FromString (decimal64 * result, const char *string, decContext * set)\n-{\n-  decContext dc;\t\t/* work */\n-  decNumber dn;\t\t\t/* .. */\n+decimal64 * decimal64FromString(decimal64 *result, const char *string,\n+\t\t\t\tdecContext *set) {\n+  decContext dc;\t\t\t     /* work */\n+  decNumber dn;\t\t\t\t     /* .. */\n \n-  decContextDefault (&dc, DEC_INIT_DECIMAL64);\t/* no traps, please */\n-  dc.round = set->round;\t/* use supplied rounding */\n+  decContextDefault(&dc, DEC_INIT_DECIMAL64); /* no traps, please */\n+  dc.round=set->round;\t\t\t      /* use supplied rounding */\n \n-  decNumberFromString (&dn, string, &dc);\t/* will round if needed */\n+  decNumberFromString(&dn, string, &dc);     /* will round if needed */\n \n-  decimal64FromNumber (result, &dn, &dc);\n-  if (dc.status != 0)\n-    {\t\t\t\t/* something happened */\n-      decContextSetStatus (set, dc.status);\t/* .. pass it on */\n+  decimal64FromNumber(result, &dn, &dc);\n+  if (dc.status!=0) {\t\t\t     /* something happened */\n+    decContextSetStatus(set, dc.status);     /* .. pass it on */\n     }\n   return result;\n-}\n+  } /* decimal64FromString */\n+\n+/* ------------------------------------------------------------------ */\n+/* decimal64IsCanonical -- test whether encoding is canonical\t      */\n+/*   d64 is the source decimal64\t\t\t\t      */\n+/*   returns 1 if the encoding of d64 is canonical, 0 otherwise\t      */\n+/* No error is possible.\t\t\t\t\t      */\n+/* ------------------------------------------------------------------ */\n+uint32_t decimal64IsCanonical(const decimal64 *d64) {\n+  decNumber dn;\t\t\t\t/* work */\n+  decimal64 canon;\t\t\t/* .. */\n+  decContext dc;\t\t\t/* .. */\n+  decContextDefault(&dc, DEC_INIT_DECIMAL64);\n+  decimal64ToNumber(d64, &dn);\n+  decimal64FromNumber(&canon, &dn, &dc);/* canon will now be canonical */\n+  return memcmp(d64, &canon, DECIMAL64_Bytes)==0;\n+  } /* decimal64IsCanonical */\n+\n+/* ------------------------------------------------------------------ */\n+/* decimal64Canonical -- copy an encoding, ensuring it is canonical   */\n+/*   d64 is the source decimal64\t\t\t\t      */\n+/*   result is the target (may be the same decimal64)\t\t      */\n+/*   returns result\t\t\t\t\t\t      */\n+/* No error is possible.\t\t\t\t\t      */\n+/* ------------------------------------------------------------------ */\n+decimal64 * decimal64Canonical(decimal64 *result, const decimal64 *d64) {\n+  decNumber dn;\t\t\t\t/* work */\n+  decContext dc;\t\t\t/* .. */\n+  decContextDefault(&dc, DEC_INIT_DECIMAL64);\n+  decimal64ToNumber(d64, &dn);\n+  decimal64FromNumber(result, &dn, &dc);/* result will now be canonical */\n+  return result;\n+  } /* decimal64Canonical */\n \n #if DECTRACE || DECCHECK\n+/* Macros for accessing decimal64 fields.  These assume the\n+   argument is a reference (pointer) to the decimal64 structure,\n+   and the decimal64 is in network byte order (big-endian) */\n+/* Get sign */\n+#define decimal64Sign(d)       ((unsigned)(d)->bytes[0]>>7)\n+\n+/* Get combination field */\n+#define decimal64Comb(d)       (((d)->bytes[0] & 0x7c)>>2)\n+\n+/* Get exponent continuation [does not remove bias] */\n+#define decimal64ExpCon(d)     ((((d)->bytes[0] & 0x03)<<6)\t      \\\n+\t\t\t     | ((unsigned)(d)->bytes[1]>>2))\n+\n+/* Set sign [this assumes sign previously 0] */\n+#define decimal64SetSign(d, b) {\t\t\t\t      \\\n+  (d)->bytes[0]|=((unsigned)(b)<<7);}\n+\n+/* Set exponent continuation [does not apply bias] */\n+/* This assumes range has been checked and exponent previously 0; */\n+/* type of exponent must be unsigned */\n+#define decimal64SetExpCon(d, e) {\t\t\t\t      \\\n+  (d)->bytes[0]|=(uint8_t)((e)>>6);\t\t\t\t      \\\n+  (d)->bytes[1]|=(uint8_t)(((e)&0x3F)<<2);}\n+\n /* ------------------------------------------------------------------ */\n-/* decimal64Show -- display a single in hexadecimal [debug aid]       */\n-/*   d64 -- the number to show                                        */\n+/* decimal64Show -- display a decimal64 in hexadecimal [debug aid]    */\n+/*   d64 -- the number to show\t\t\t\t\t      */\n /* ------------------------------------------------------------------ */\n /* Also shows sign/cob/expconfields extracted */\n-void\n-decimal64Show (const decimal64 * d64)\n-{\n-  char buf[DECIMAL64_Bytes * 2 + 1];\n-  Int i, j;\n-  j = 0;\n-  for (i = 0; i < DECIMAL64_Bytes; i++)\n-    {\n-      sprintf (&buf[j], \"%02x\", d64->bytes[i]);\n-      j = j + 2;\n+void decimal64Show(const decimal64 *d64) {\n+  char buf[DECIMAL64_Bytes*2+1];\n+  Int i, j=0;\n+\n+  if (DECLITEND) {\n+    for (i=0; i<DECIMAL64_Bytes; i++, j+=2) {\n+      sprintf(&buf[j], \"%02x\", d64->bytes[7-i]);\n+      }\n+    printf(\" D64> %s [S:%d Cb:%02x Ec:%02x] LittleEndian\\n\", buf,\n+\t   d64->bytes[7]>>7, (d64->bytes[7]>>2)&0x1f,\n+\t   ((d64->bytes[7]&0x3)<<6)| (d64->bytes[6]>>2));\n+    }\n+   else { /* big-endian */\n+    for (i=0; i<DECIMAL64_Bytes; i++, j+=2) {\n+      sprintf(&buf[j], \"%02x\", d64->bytes[i]);\n+      }\n+    printf(\" D64> %s [S:%d Cb:%02x Ec:%02x] BigEndian\\n\", buf,\n+\t   decimal64Sign(d64), decimal64Comb(d64), decimal64ExpCon(d64));\n     }\n-  printf (\" D64> %s [S:%d Cb:%02x E:%d]\\n\", buf,\n-\t  decimal64Sign (d64), decimal64Comb (d64), decimal64ExpCon (d64));\n-}\n+  } /* decimal64Show */\n #endif\n+\n+/* ================================================================== */\n+/* Shared utility routines and tables\t\t\t\t      */\n+/* ================================================================== */\n+/* define and include the conversion tables to use for shared code */\n+#if DECDPUN==3\n+  #define DEC_DPD2BIN 1\n+#else\n+  #define DEC_DPD2BCD 1\n+#endif\n+#include \"decDPD.h\"\t      /* lookup tables */\n+\n+/* The maximum number of decNumberUnits needed for a working copy of */\n+/* the units array is the ceiling of digits/DECDPUN, where digits is */\n+/* the maximum number of digits in any of the formats for which this */\n+/* is used.  decimal128.h must not be included in this module, so, as */\n+/* a very special case, that number is defined as a literal here. */\n+#define DECMAX754   34\n+#define DECMAXUNITS ((DECMAX754+DECDPUN-1)/DECDPUN)\n+\n+/* ------------------------------------------------------------------ */\n+/* Combination field lookup tables (uInts to save measurable work)    */\n+/*\t\t\t\t\t\t\t\t      */\n+/*\tCOMBEXP - 2-bit most-significant-bits of exponent\t      */\n+/*\t\t  [11 if an Infinity or NaN]\t\t\t      */\n+/*\tCOMBMSD - 4-bit most-significant-digit\t\t\t      */\n+/*\t\t  [0=Infinity, 1=NaN if COMBEXP=11]\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* Both are indexed by the 5-bit combination field (0-31)\t      */\n+/* ------------------------------------------------------------------ */\n+const uInt COMBEXP[32]={0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t\t1, 1, 1, 1, 1, 1, 1, 1,\n+\t\t\t2, 2, 2, 2, 2, 2, 2, 2,\n+\t\t\t0, 0, 1, 1, 2, 2, 3, 3};\n+const uInt COMBMSD[32]={0, 1, 2, 3, 4, 5, 6, 7,\n+\t\t\t0, 1, 2, 3, 4, 5, 6, 7,\n+\t\t\t0, 1, 2, 3, 4, 5, 6, 7,\n+\t\t\t8, 9, 8, 9, 8, 9, 0, 1};\n+\n+/* ------------------------------------------------------------------ */\n+/* decDigitsToDPD -- pack coefficient into DPD form\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*   dn\t  is the source number (assumed valid, max DECMAX754 digits)  */\n+/*   targ is 1, 2, or 4-element uInt array, which the caller must     */\n+/*\t  have cleared to zeros\t\t\t\t\t      */\n+/*   shift is the number of 0 digits to add on the right (normally 0) */\n+/*\t\t\t\t\t\t\t\t      */\n+/* The coefficient must be known small enough to fit.  The full\t      */\n+/* coefficient is copied, including the leading 'odd' digit.  This    */\n+/* digit is retrieved and packed into the combination field by the    */\n+/* caller.\t\t\t\t\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* The target uInts are altered only as necessary to receive the      */\n+/* digits of the decNumber.  When more than one uInt is needed, they  */\n+/* are filled from left to right (that is, the uInt at offset 0 will  */\n+/* end up with the least-significant digits).\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* shift is used for 'fold-down' padding.\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* No error is possible.\t\t\t\t\t      */\n+/* ------------------------------------------------------------------ */\n+#if DECDPUN<=4\n+/* Constant multipliers for divide-by-power-of five using reciprocal */\n+/* multiply, after removing powers of 2 by shifting, and final shift */\n+/* of 17 [we only need up to **4] */\n+static const uInt multies[]={131073, 26215, 5243, 1049, 210};\n+/* QUOT10 -- macro to return the quotient of unit u divided by 10**n */\n+#define QUOT10(u, n) ((((uInt)(u)>>(n))*multies[n])>>17)\n+#endif\n+void decDigitsToDPD(const decNumber *dn, uInt *targ, Int shift) {\n+  Int  cut;\t\t      /* work */\n+  Int  n;\t\t      /* output bunch counter */\n+  Int  digits=dn->digits;     /* digit countdown */\n+  uInt dpd;\t\t      /* densely packed decimal value */\n+  uInt bin;\t\t      /* binary value 0-999 */\n+  uInt *uout=targ;\t      /* -> current output uInt */\n+  uInt\tuoff=0;\t\t      /* -> current output offset [from right] */\n+  const Unit *inu=dn->lsu;    /* -> current input unit */\n+  Unit\tuar[DECMAXUNITS];     /* working copy of units, iff shifted */\n+  #if DECDPUN!=3\t      /* not fast path */\n+    Unit in;\t\t      /* current unit */\n+  #endif\n+\n+  if (shift!=0) {\t      /* shift towards most significant required */\n+    /* shift the units array to the left by pad digits and copy */\n+    /* [this code is a special case of decShiftToMost, which could */\n+    /* be used instead if exposed and the array were copied first] */\n+    const Unit *source;\t\t\t/* .. */\n+    Unit  *target, *first;\t\t/* .. */\n+    uInt  next=0;\t\t\t/* work */\n+\n+    source=dn->lsu+D2U(digits)-1;\t/* where msu comes from */\n+    target=uar+D2U(digits)-1+D2U(shift);/* where upper part of first cut goes */\n+    cut=DECDPUN-MSUDIGITS(shift);\t/* where to slice */\n+    if (cut==0) {\t\t\t/* unit-boundary case */\n+      for (; source>=dn->lsu; source--, target--) *target=*source;\n+      }\n+     else {\n+      first=uar+D2U(digits+shift)-1;\t/* where msu will end up */\n+      for (; source>=dn->lsu; source--, target--) {\n+\t/* split the source Unit and accumulate remainder for next */\n+\t#if DECDPUN<=4\n+\t  uInt quot=QUOT10(*source, cut);\n+\t  uInt rem=*source-quot*DECPOWERS[cut];\n+\t  next+=quot;\n+\t#else\n+\t  uInt rem=*source%DECPOWERS[cut];\n+\t  next+=*source/DECPOWERS[cut];\n+\t#endif\n+\tif (target<=first) *target=(Unit)next; /* write to target iff valid */\n+\tnext=rem*DECPOWERS[DECDPUN-cut];       /* save remainder for next Unit */\n+\t}\n+      } /* shift-move */\n+    /* propagate remainder to one below and clear the rest */\n+    for (; target>=uar; target--) {\n+      *target=(Unit)next;\n+      next=0;\n+      }\n+    digits+=shift;\t\t   /* add count (shift) of zeros added */\n+    inu=uar;\t\t\t   /* use units in working array */\n+    }\n+\n+  /* now densely pack the coefficient into DPD declets */\n+\n+  #if DECDPUN!=3\t\t   /* not fast path */\n+    in=*inu;\t\t\t   /* current unit */\n+    cut=0;\t\t\t   /* at lowest digit */\n+    bin=0;\t\t\t   /* [keep compiler quiet] */\n+  #endif\n+\n+  for(n=0; digits>0; n++) {\t   /* each output bunch */\n+    #if DECDPUN==3\t\t   /* fast path, 3-at-a-time */\n+      bin=*inu;\t\t\t   /* 3 digits ready for convert */\n+      digits-=3;\t\t   /* [may go negative] */\n+      inu++;\t\t\t   /* may need another */\n+\n+    #else\t\t\t   /* must collect digit-by-digit */\n+      Unit dig;\t\t\t   /* current digit */\n+      Int j;\t\t\t   /* digit-in-declet count */\n+      for (j=0; j<3; j++) {\n+\t#if DECDPUN<=4\n+\t  Unit temp=(Unit)((uInt)(in*6554)>>16);\n+\t  dig=(Unit)(in-X10(temp));\n+\t  in=temp;\n+\t#else\n+\t  dig=in%10;\n+\t  in=in/10;\n+\t#endif\n+\tif (j==0) bin=dig;\n+\t else if (j==1)\t bin+=X10(dig);\n+\t else /* j==2 */ bin+=X100(dig);\n+\tdigits--;\n+\tif (digits==0) break;\t   /* [also protects *inu below] */\n+\tcut++;\n+\tif (cut==DECDPUN) {inu++; in=*inu; cut=0;}\n+\t}\n+    #endif\n+    /* here there are 3 digits in bin, or have used all input digits */\n+\n+    dpd=BIN2DPD[bin];\n+\n+    /* write declet to uInt array */\n+    *uout|=dpd<<uoff;\n+    uoff+=10;\n+    if (uoff<32) continue;\t   /* no uInt boundary cross */\n+    uout++;\n+    uoff-=32;\n+    *uout|=dpd>>(10-uoff);\t   /* collect top bits */\n+    } /* n declets */\n+  return;\n+  } /* decDigitsToDPD */\n+\n+/* ------------------------------------------------------------------ */\n+/* decDigitsFromDPD -- unpack a format's coefficient\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/*   dn is the target number, with 7, 16, or 34-digit space.\t      */\n+/*   sour is a 1, 2, or 4-element uInt array containing only declets  */\n+/*   declets is the number of (right-aligned) declets in sour to      */\n+/*     be processed.  This may be 1 more than the obvious number in   */\n+/*     a format, as any top digit is prefixed to the coefficient      */\n+/*     continuation field.  It also may be as small as 1, as the      */\n+/*     caller may pre-process leading zero declets.\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* When doing the 'extra declet' case care is taken to avoid writing  */\n+/* extra digits when there are leading zeros, as these could overflow */\n+/* the units array when DECDPUN is not 3.\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* The target uInts are used only as necessary to process declets     */\n+/* declets into the decNumber.\tWhen more than one uInt is needed,    */\n+/* they are used from left to right (that is, the uInt at offset 0    */\n+/* provides the least-significant digits).\t\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* dn->digits is set, but not the sign or exponent.\t\t      */\n+/* No error is possible [the redundant 888 codes are allowed].\t      */\n+/* ------------------------------------------------------------------ */\n+void decDigitsFromDPD(decNumber *dn, const uInt *sour, Int declets) {\n+\n+  uInt\tdpd;\t\t\t   /* collector for 10 bits */\n+  Int\tn;\t\t\t   /* counter */\n+  Unit\t*uout=dn->lsu;\t\t   /* -> current output unit */\n+  Unit\t*last=uout;\t\t   /* will be unit containing msd */\n+  const uInt *uin=sour;\t\t   /* -> current input uInt */\n+  uInt\tuoff=0;\t\t\t   /* -> current input offset [from right] */\n+\n+  #if DECDPUN!=3\n+  uInt\tbcd;\t\t\t   /* BCD result */\n+  uInt\tnibble;\t\t\t   /* work */\n+  Unit\tout=0;\t\t\t   /* accumulator */\n+  Int\tcut=0;\t\t\t   /* power of ten in current unit */\n+  #endif\n+  #if DECDPUN>4\n+  uInt const *pow;\t\t   /* work */\n+  #endif\n+\n+  /* Expand the densely-packed integer, right to left */\n+  for (n=declets-1; n>=0; n--) {   /* count down declets of 10 bits */\n+    dpd=*uin>>uoff;\n+    uoff+=10;\n+    if (uoff>32) {\t\t   /* crossed uInt boundary */\n+      uin++;\n+      uoff-=32;\n+      dpd|=*uin<<(10-uoff);\t   /* get waiting bits */\n+      }\n+    dpd&=0x3ff;\t\t\t   /* clear uninteresting bits */\n+\n+  #if DECDPUN==3\n+    if (dpd==0) *uout=0;\n+     else {\n+      *uout=DPD2BIN[dpd];\t   /* convert 10 bits to binary 0-999 */\n+      last=uout;\t\t   /* record most significant unit */\n+      }\n+    uout++;\n+    } /* n */\n+\n+  #else /* DECDPUN!=3 */\n+    if (dpd==0) {\t\t   /* fastpath [e.g., leading zeros] */\n+      /* write out three 0 digits (nibbles); out may have digit(s) */\n+      cut++;\n+      if (cut==DECDPUN) {*uout=out; if (out) {last=uout; out=0;} uout++; cut=0;}\n+      if (n==0) break;\t\t   /* [as below, works even if MSD=0] */\n+      cut++;\n+      if (cut==DECDPUN) {*uout=out; if (out) {last=uout; out=0;} uout++; cut=0;}\n+      cut++;\n+      if (cut==DECDPUN) {*uout=out; if (out) {last=uout; out=0;} uout++; cut=0;}\n+      continue;\n+      }\n+\n+    bcd=DPD2BCD[dpd];\t\t   /* convert 10 bits to 12 bits BCD */\n+\n+    /* now accumulate the 3 BCD nibbles into units */\n+    nibble=bcd & 0x00f;\n+    if (nibble) out=(Unit)(out+nibble*DECPOWERS[cut]);\n+    cut++;\n+    if (cut==DECDPUN) {*uout=out; if (out) {last=uout; out=0;} uout++; cut=0;}\n+    bcd>>=4;\n+\n+    /* if this is the last declet and the remaining nibbles in bcd */\n+    /* are 00 then process no more nibbles, because this could be */\n+    /* the 'odd' MSD declet and writing any more Units would then */\n+    /* overflow the unit array */\n+    if (n==0 && !bcd) break;\n+\n+    nibble=bcd & 0x00f;\n+    if (nibble) out=(Unit)(out+nibble*DECPOWERS[cut]);\n+    cut++;\n+    if (cut==DECDPUN) {*uout=out; if (out) {last=uout; out=0;} uout++; cut=0;}\n+    bcd>>=4;\n+\n+    nibble=bcd & 0x00f;\n+    if (nibble) out=(Unit)(out+nibble*DECPOWERS[cut]);\n+    cut++;\n+    if (cut==DECDPUN) {*uout=out; if (out) {last=uout; out=0;} uout++; cut=0;}\n+    } /* n */\n+  if (cut!=0) {\t\t\t\t/* some more left over */\n+    *uout=out;\t\t\t\t/* write out final unit */\n+    if (out) last=uout;\t\t\t/* and note if non-zero */\n+    }\n+  #endif\n+\n+  /* here, last points to the most significant unit with digits; */\n+  /* inspect it to get the final digits count -- this is essentially */\n+  /* the same code as decGetDigits in decNumber.c */\n+  dn->digits=(last-dn->lsu)*DECDPUN+1;\t/* floor of digits, plus */\n+\t\t\t\t\t/* must be at least 1 digit */\n+  #if DECDPUN>1\n+  if (*last<10) return;\t\t\t/* common odd digit or 0 */\n+  dn->digits++;\t\t\t\t/* must be 2 at least */\n+  #if DECDPUN>2\n+  if (*last<100) return;\t\t/* 10-99 */\n+  dn->digits++;\t\t\t\t/* must be 3 at least */\n+  #if DECDPUN>3\n+  if (*last<1000) return;\t\t/* 100-999 */\n+  dn->digits++;\t\t\t\t/* must be 4 at least */\n+  #if DECDPUN>4\n+  for (pow=&DECPOWERS[4]; *last>=*pow; pow++) dn->digits++;\n+  #endif\n+  #endif\n+  #endif\n+  #endif\n+  return;\n+  } /*decDigitsFromDPD */"}, {"sha": "549b626536c4dcd6afc0b20713cc49b06bd906c4", "filename": "libdecnumber/dpd/decimal64.h", "status": "modified", "additions": 70, "deletions": 93, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2Fdpd%2Fdecimal64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2Fdpd%2Fdecimal64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2Fdpd%2Fdecimal64.h?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb", "patch": "@@ -1,5 +1,5 @@\n-/* Decimal 64-bit format module header for the decNumber C Library\n-   Copyright (C) 2005 Free Software Foundation, Inc.\n+/* Decimal 64-bit format module header for the decNumber C Library.\n+   Copyright (C) 2005, 2007 Free Software Foundation, Inc.\n    Contributed by IBM Corporation.  Author Mike Cowlishaw.\n \n    This file is part of GCC.\n@@ -28,97 +28,74 @@\n    Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    02110-1301, USA.  */\n \n-#if !defined(DECIMAL64)\n-#define DECIMAL64\n-#define DEC64NAME     \"decimal64\"\t/* Short name */\n-#define DEC64FULLNAME \"Decimal 64-bit Number\"\t/* Verbose name */\n-#define DEC64AUTHOR   \"Mike Cowlishaw\"\t/* Who to blame */\n-\n-#if defined(DECIMAL32)\n-#error decimal64.h must precede decimal32.h for correct DECNUMDIGITS\n-#endif\n+/* ------------------------------------------------------------------ */\n+/* Decimal 64-bit format module header\t\t\t\t      */\n+/* ------------------------------------------------------------------ */\n \n-  /* parameters for decimal64s */\n-#define DECIMAL64_Bytes  8\t/* length */\n-#define DECIMAL64_Pmax   16\t/* maximum precision (digits) */\n-#define DECIMAL64_Emax   384\t/* maximum adjusted exponent */\n-#define DECIMAL64_Emin  -383\t/* minimum adjusted exponent */\n-#define DECIMAL64_Bias   398\t/* bias for the exponent */\n-#define DECIMAL64_String 24\t/* maximum string length, +1 */\n-  /* highest biased exponent (Elimit-1) */\n-#define DECIMAL64_Ehigh  (DECIMAL64_Emax+DECIMAL64_Bias-DECIMAL64_Pmax+1)\n-\n-#ifndef DECNUMDIGITS\n-#define DECNUMDIGITS DECIMAL64_Pmax\t/* size if not already defined */\n-#endif\n-#ifndef DECNUMBER\n-#include \"decNumber.h\"\t\t/* context and number library */\n-#endif\n-\n-  /* Decimal 64-bit type, accessible by bytes */\n-typedef struct\n-{\n-  uint8_t bytes[DECIMAL64_Bytes];\t/* decimal64: 1, 5, 8, 50 bits */\n-} decimal64;\n-\n-  /* special values [top byte excluding sign bit; last two bits are\n-     don't-care for Infinity on input, last bit don't-care for NaN] */\n-#if !defined(DECIMAL_NaN)\n-#define DECIMAL_NaN     0x7c\t/* 0 11111 00 NaN */\n-#define DECIMAL_sNaN    0x7e\t/* 0 11111 10 sNaN */\n-#define DECIMAL_Inf     0x78\t/* 0 11110 00 Infinity */\n-#endif\n-\n-  /* Macros for accessing decimal64 fields.  These assume the argument\n-     is a reference (pointer) to the decimal64 structure */\n-  /* Get sign */\n-#define decimal64Sign(d)       ((unsigned)(d)->bytes[0]>>7)\n-\n-  /* Get combination field */\n-#define decimal64Comb(d)       (((d)->bytes[0] & 0x7c)>>2)\n-\n-  /* Get exponent continuation [does not remove bias] */\n-#define decimal64ExpCon(d)     ((((d)->bytes[0] & 0x03)<<6)         \\\n-                               | ((unsigned)(d)->bytes[1]>>2))\n-\n-  /* Set sign [this assumes sign previously 0] */\n-#define decimal64SetSign(d, b) {                                    \\\n-    (d)->bytes[0]|=((unsigned)(b)<<7);}\n-\n-  /* Clear sign */\n-#define decimal64ClearSign(d) {(d)->bytes[0]&=~0x80;}\n-\n-  /* Flip sign */\n-#define decimal64FlipSign(d) {(d)->bytes[0]^=0x80;}\n-\n-  /* Set exponent continuation [does not apply bias] */\n-  /* This assumes range has been checked and exponent previously 0; type */\n-  /* of exponent must be unsigned */\n-#define decimal64SetExpCon(d, e) {                                  \\\n-    (d)->bytes[0]|=(uint8_t)((e)>>6);                                 \\\n-    (d)->bytes[1]|=(uint8_t)(((e)&0x3F)<<2);}\n-\n-  /* ------------------------------------------------------------------ */\n-  /* Routines                                                           */\n-  /* ------------------------------------------------------------------ */\n-\n-#ifdef IN_LIBGCC2\n-#ifndef decimal64FromString\n-#define decimal64FromString __decimal64FromString\n-#define decimal64ToString __decimal64ToString\n-#define decimal64ToEngString __decimal64ToEngString\n-#define decimal64FromNumber __decimal64FromNumber\n-#define decimal64ToNumber __decimal64ToNumber\n-#endif\n-#endif\n-\n-  /* String conversions */\n-decimal64 *decimal64FromString (decimal64 *, const char *, decContext *);\n-char *decimal64ToString (const decimal64 *, char *);\n-char *decimal64ToEngString (const decimal64 *, char *);\n-\n-  /* decNumber conversions */\n-decimal64 *decimal64FromNumber (decimal64 *, const decNumber *, decContext *);\n-decNumber *decimal64ToNumber (const decimal64 *, decNumber *);\n+#if !defined(DECIMAL64)\n+  #define DECIMAL64\n+  #define DEC64NAME\t\"decimal64\"\t\t      /* Short name   */\n+  #define DEC64FULLNAME \"Decimal 64-bit Number\"\t      /* Verbose name */\n+  #define DEC64AUTHOR\t\"Mike Cowlishaw\"\t      /* Who to blame */\n+\n+\n+  /* parameters for decimal64s\t\t\t\t\t      */\n+  #define DECIMAL64_Bytes  8\t\t/* length\t\t      */\n+  #define DECIMAL64_Pmax   16\t\t/* maximum precision (digits) */\n+  #define DECIMAL64_Emax   384\t\t/* maximum adjusted exponent  */\n+  #define DECIMAL64_Emin  -383\t\t/* minimum adjusted exponent  */\n+  #define DECIMAL64_Bias   398\t\t/* bias for the exponent      */\n+  #define DECIMAL64_String 24\t\t/* maximum string length, +1  */\n+  #define DECIMAL64_EconL  8\t\t/* exp. continuation length   */\n+  /* highest biased exponent (Elimit-1)\t\t\t\t      */\n+  #define DECIMAL64_Ehigh  (DECIMAL64_Emax+DECIMAL64_Bias-DECIMAL64_Pmax+1)\n+\n+  /* check enough digits, if pre-defined\t\t\t      */\n+  #if defined(DECNUMDIGITS)\n+    #if (DECNUMDIGITS<DECIMAL64_Pmax)\n+      #error decimal64.h needs pre-defined DECNUMDIGITS>=16 for safe use\n+    #endif\n+  #endif\n+\n+\n+  #ifndef DECNUMDIGITS\n+    #define DECNUMDIGITS DECIMAL64_Pmax /* size if not already defined*/\n+  #endif\n+  #ifndef DECNUMBER\n+    #include \"decNumber.h\"\t\t/* context and number library */\n+  #endif\n+\n+  /* Decimal 64-bit type, accessible by bytes\t\t\t      */\n+  typedef struct {\n+    uint8_t bytes[DECIMAL64_Bytes];\t/* decimal64: 1, 5, 8, 50 bits*/\n+    } decimal64;\n+\n+  /* special values [top byte excluding sign bit; last two bits are   */\n+  /* don't-care for Infinity on input, last bit don't-care for NaN]   */\n+  #if !defined(DECIMAL_NaN)\n+    #define DECIMAL_NaN\t    0x7c\t/* 0 11111 00 NaN\t      */\n+    #define DECIMAL_sNaN    0x7e\t/* 0 11111 10 sNaN\t      */\n+    #define DECIMAL_Inf\t    0x78\t/* 0 11110 00 Infinity\t      */\n+  #endif\n+\n+  /* ---------------------------------------------------------------- */\n+  /* Routines\t\t\t\t\t\t\t      */\n+  /* ---------------------------------------------------------------- */\n+\n+  #include \"decimal64Symbols.h\"\n+\n+  /* String conversions\t\t\t\t\t\t      */\n+  decimal64 * decimal64FromString(decimal64 *, const char *, decContext *);\n+  char * decimal64ToString(const decimal64 *, char *);\n+  char * decimal64ToEngString(const decimal64 *, char *);\n+\n+  /* decNumber conversions\t\t\t\t\t      */\n+  decimal64 * decimal64FromNumber(decimal64 *, const decNumber *,\n+\t\t\t\t  decContext *);\n+  decNumber * decimal64ToNumber(const decimal64 *, decNumber *);\n+\n+  /* Format-dependent utilities\t\t\t\t\t      */\n+  uint32_t    decimal64IsCanonical(const decimal64 *);\n+  decimal64 * decimal64Canonical(decimal64 *, const decimal64 *);\n \n #endif"}, {"sha": "cf965bf5bd8d0d58128f2e60682a7d35ed6d1b7b", "filename": "libdecnumber/dpd/decimal64Symbols.h", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2Fdpd%2Fdecimal64Symbols.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libdecnumber%2Fdpd%2Fdecimal64Symbols.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2Fdpd%2Fdecimal64Symbols.h?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb", "patch": "@@ -0,0 +1,16 @@\n+#if !defined(DECIMAL64SYMBOLS)\n+#define DECIMAL64SYMBOLS\n+\n+#ifdef IN_LIBGCC2\n+#define decDigitsFromDPD __decDigitsFromDPD\n+#define decDigitsToDPD __decDigitsToDPD\n+#define decimal64Canonical __decimal64Canonical\n+#define decimal64FromNumber __decimal64FromNumber\n+#define decimal64FromString __decimal64FromString\n+#define decimal64IsCanonical __decimal64IsCanonical\n+#define decimal64ToEngString __decimal64ToEngString\n+#define decimal64ToNumber __decimal64ToNumber\n+#define decimal64ToString __decimal64ToString\n+#endif\n+\n+#endif"}, {"sha": "e9fed197a8373af669def9f2302d5f182a82bf8e", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb", "patch": "@@ -1,3 +1,8 @@\n+2007-09-10  Janis Johnson  <janis187@us.ibm.com>\n+\n+\t* Makefile.in (dfp-filenames): Remove decUtility, add\n+\tdecDouble, decPacked, decQuad, decSingle.\n+\n 2007-08-27  Hans Kester  <hans.kester@ellips.nl>\n \n \t* config.host : Add x86_64-elf target."}, {"sha": "4b3bcc9df9c36ed92b1ab1689733e2f45dbaa01e", "filename": "libgcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libgcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2533577ff6607c4fe093acb0fb711a003a4b3eeb/libgcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FMakefile.in?ref=2533577ff6607c4fe093acb0fb711a003a4b3eeb", "patch": "@@ -488,7 +488,7 @@ dfp-filenames += decimal_globals decimal_data binarydecimal \\\n \t\t bid128_to_int32 bid128_to_int64 \\\n \t\t bid128_to_uint32 bid128_to_uint64\n else\n-dfp-filenames += decContext decNumber decExcept decRound decLibrary decUtility\n+dfp-filenames += decContext decNumber decExcept decRound decLibrary decDouble decPacked decQuad decSingle\n endif\n endif\n "}]}