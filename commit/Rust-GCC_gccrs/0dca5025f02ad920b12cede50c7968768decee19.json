{"sha": "0dca5025f02ad920b12cede50c7968768decee19", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGRjYTUwMjVmMDJhZDkyMGIxMmNlZGU1MGM3OTY4NzY4ZGVjZWUxOQ==", "commit": {"author": {"name": "Adam Butcher", "email": "adam@jessamine.co.uk", "date": "2013-11-12T20:17:33Z"}, "committer": {"name": "Adam Butcher", "email": "abutcher@gcc.gnu.org", "date": "2013-11-12T20:17:33Z"}, "message": "Refactor implicit function template implementation and fix 58534, 58536, 58548, 58549 and 58637.\n\ngcc/\n\t* tree.c (grow_tree_vec_stat): New function ...\n\t* tree.h (grow_tree_vec_stat) (grow_tree_vec): ... and its declaration\n\tand macro front-end.\n\ngcc/cp/\n\tPR c++/58534\n\tPR c++/58536\n\tPR c++/58548\n\tPR c++/58549\n\tPR c++/58637\n\t* parser.h (struct cp_parser): New members implicit_template_parms,\n\timplicit_template_scope and auto_is_implicit_function_template_parm_p.\n\t* parser.c (add_implicit_template_parms): Refactor as ...\n\t(synthesize_implicit_template_parm): ... this to append a new template\n\ttype parm to the current template parameter list (introducing a new list\n\tif necessary).  Removed push_deferring_access_checks.\n\t(finish_fully_implicit_template): Removed pop_deferring_access_checks.\n\t(cp_parser_new): Initialize new cp_parser members.\n\t(cp_parser_parameter_declaration_clause): Consider auto as implicit\n\ttemplate parm when parsing a parameter declaration (unless parsing an\n\texplicit specialization).\n\t(cp_parser_parameter_declaration_list): Remove local\n\timplicit_template_parms counter and reset cp_parser implicit template\n\tstate when complete.\n\t(cp_parser_lambda_expression): Reset implicit template cp_parser members\n\twhilst generating lambda class.\n\t(cp_parser_function_definition_after_declarator): Reset implicit\n\ttemplate cp_parser members whilst parsing function definition.\n\t(make_generic_type_name): Respell '<autoN>' as 'auto:N' which works\n\tbetter with template diagnostics.\n\t(cp_parser_simple_type_specifier): Synthesize implicit template parm on\n\tparsing 'auto' if auto_is_implicit_function_template_parm_p and provide\n\tdiagnostics ...\n\t* decl.c (grokdeclarator): ... that were previously done here.\n\ngcc/testsuite/g++.dg/\n\t* cpp1y/pr58534.C: New testcase.\n\t* cpp1y/pr58536.C: New testcase.\n\t* cpp1y/pr58548.C: New testcase.\n\t* cpp1y/pr58549.C: New testcase.\n\t* cpp1y/pr58637.C: New testcase.\n\nFrom-SVN: r204714", "tree": {"sha": "dd7d73f2767b4b7b3797611c8cc9aea5b69ed13d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd7d73f2767b4b7b3797611c8cc9aea5b69ed13d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0dca5025f02ad920b12cede50c7968768decee19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dca5025f02ad920b12cede50c7968768decee19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0dca5025f02ad920b12cede50c7968768decee19", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dca5025f02ad920b12cede50c7968768decee19/comments", "author": {"login": "abutcher-gh", "id": 10379705, "node_id": "MDQ6VXNlcjEwMzc5NzA1", "avatar_url": "https://avatars.githubusercontent.com/u/10379705?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abutcher-gh", "html_url": "https://github.com/abutcher-gh", "followers_url": "https://api.github.com/users/abutcher-gh/followers", "following_url": "https://api.github.com/users/abutcher-gh/following{/other_user}", "gists_url": "https://api.github.com/users/abutcher-gh/gists{/gist_id}", "starred_url": "https://api.github.com/users/abutcher-gh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abutcher-gh/subscriptions", "organizations_url": "https://api.github.com/users/abutcher-gh/orgs", "repos_url": "https://api.github.com/users/abutcher-gh/repos", "events_url": "https://api.github.com/users/abutcher-gh/events{/privacy}", "received_events_url": "https://api.github.com/users/abutcher-gh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "27297d2d1b7731db604400f335e4653da7c09a22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27297d2d1b7731db604400f335e4653da7c09a22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27297d2d1b7731db604400f335e4653da7c09a22"}], "stats": {"total": 452, "additions": 330, "deletions": 122}, "files": [{"sha": "630a082f7eb681fa66ddb24cbfc15bdbb1d91604", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dca5025f02ad920b12cede50c7968768decee19/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dca5025f02ad920b12cede50c7968768decee19/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0dca5025f02ad920b12cede50c7968768decee19", "patch": "@@ -1,3 +1,9 @@\n+2013-11-12  Adam Butcher  <adam@jessamine.co.uk>\n+\n+\t* tree.c (grow_tree_vec_stat): New function ...\n+\t* tree.h (grow_tree_vec_stat) (grow_tree_vec): ... and its declaration\n+\tand macro front-end.\n+\n 2013-11-12  Marek Polacek  <polacek@redhat.com>\n \n \t* final.c (update_alignments): Initialize label to NULL_RTX."}, {"sha": "3f7eb1aa9e2f40083c0f969f541decb86b156700", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dca5025f02ad920b12cede50c7968768decee19/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dca5025f02ad920b12cede50c7968768decee19/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0dca5025f02ad920b12cede50c7968768decee19", "patch": "@@ -1,3 +1,35 @@\n+2013-11-12  Adam Butcher  <adam@jessamine.co.uk>\n+\n+\tPR c++/58534\n+\tPR c++/58536\n+\tPR c++/58548\n+\tPR c++/58549\n+\tPR c++/58637\n+\t* parser.h (struct cp_parser): New members implicit_template_parms,\n+\timplicit_template_scope and auto_is_implicit_function_template_parm_p.\n+\t* parser.c (add_implicit_template_parms): Refactor as ...\n+\t(synthesize_implicit_template_parm): ... this to append a new template\n+\ttype parm to the current template parameter list (introducing a new list\n+\tif necessary).  Removed push_deferring_access_checks.\n+\t(finish_fully_implicit_template): Removed pop_deferring_access_checks.\n+\t(cp_parser_new): Initialize new cp_parser members.\n+\t(cp_parser_parameter_declaration_clause): Consider auto as implicit\n+\ttemplate parm when parsing a parameter declaration (unless parsing an\n+\texplicit specialization).\n+\t(cp_parser_parameter_declaration_list): Remove local\n+\timplicit_template_parms counter and reset cp_parser implicit template\n+\tstate when complete.\n+\t(cp_parser_lambda_expression): Reset implicit template cp_parser members\n+\twhilst generating lambda class.\n+\t(cp_parser_function_definition_after_declarator): Reset implicit\n+\ttemplate cp_parser members whilst parsing function definition.\n+\t(make_generic_type_name): Respell '<autoN>' as 'auto:N' which works\n+\tbetter with template diagnostics.\n+\t(cp_parser_simple_type_specifier): Synthesize implicit template parm on\n+\tparsing 'auto' if auto_is_implicit_function_template_parm_p and provide\n+\tdiagnostics ...\n+\t* decl.c (grokdeclarator): ... that were previously done here.\n+\n 2013-11-12  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/57734"}, {"sha": "7d9d5df8f1d9f94a70d385e60aa8a57b26d11a76", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 4, "deletions": 26, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dca5025f02ad920b12cede50c7968768decee19/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dca5025f02ad920b12cede50c7968768decee19/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=0dca5025f02ad920b12cede50c7968768decee19", "patch": "@@ -10381,33 +10381,11 @@ grokdeclarator (const cp_declarator *declarator,\n \n       if (type_uses_auto (type))\n \t{\n-\t  if (template_parm_flag)\n-\t    {\n-\t      error (\"template parameter declared %<auto%>\");\n-\t      type = error_mark_node;\n-\t    }\n-\t  else if (decl_context == CATCHPARM)\n-\t    {\n-\t      error (\"catch parameter declared %<auto%>\");\n-\t      type = error_mark_node;\n-\t    }\n-\t  else if (current_class_type && LAMBDA_TYPE_P (current_class_type))\n-\t    {\n-\t      if (cxx_dialect < cxx1y)\n-\t\tpedwarn (location_of (type), 0,\n-\t\t\t \"use of %<auto%> in lambda parameter declaration \"\n-\t\t\t \"only available with \"\n-\t\t\t \"-std=c++1y or -std=gnu++1y\");\n-\t    }\n-\t  else if (cxx_dialect < cxx1y)\n-\t    pedwarn (location_of (type), 0,\n-\t\t     \"use of %<auto%> in parameter declaration \"\n-\t\t     \"only available with \"\n-\t\t     \"-std=c++1y or -std=gnu++1y\");\n+\t  if (cxx_dialect >= cxx1y)\n+\t    error (\"%<auto%> parameter not permitted in this context\");\n \t  else\n-\t    pedwarn (location_of (type), OPT_Wpedantic,\n-\t\t     \"ISO C++ forbids use of %<auto%> in parameter \"\n-\t\t     \"declaration\");\n+\t    error (\"parameter declared %<auto%>\");\n+\t  type = error_mark_node;\n \t}\n \n       /* A parameter declared as an array of T is really a pointer to T."}, {"sha": "c48952abbb26f596220e0893d111ff6391b7cd5a", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 181, "deletions": 96, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dca5025f02ad920b12cede50c7968768decee19/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dca5025f02ad920b12cede50c7968768decee19/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=0dca5025f02ad920b12cede50c7968768decee19", "patch": "@@ -2107,8 +2107,8 @@ static bool cp_parser_ctor_initializer_opt_and_function_body\n static tree cp_parser_late_parsing_omp_declare_simd\n   (cp_parser *, tree);\n \n-static tree add_implicit_template_parms\n-  (cp_parser *, size_t, tree);\n+static tree synthesize_implicit_template_parm\n+  (cp_parser *);\n static tree finish_fully_implicit_template\n   (cp_parser *, tree);\n \n@@ -3443,7 +3443,10 @@ cp_parser_new (void)\n   parser->num_template_parameter_lists = 0;\n \n   /* Not declaring an implicit function template.  */\n+  parser->auto_is_implicit_function_template_parm_p = false;\n   parser->fully_implicit_function_template_p = false;\n+  parser->implicit_template_parms = 0;\n+  parser->implicit_template_scope = 0;\n \n   return parser;\n }\n@@ -8660,12 +8663,17 @@ cp_parser_lambda_expression (cp_parser* parser)\n         = parser->num_template_parameter_lists;\n     unsigned char in_statement = parser->in_statement;\n     bool in_switch_statement_p = parser->in_switch_statement_p;\n-    bool fully_implicit_function_template_p = parser->fully_implicit_function_template_p;\n+    bool fully_implicit_function_template_p\n+        = parser->fully_implicit_function_template_p;\n+    tree implicit_template_parms = parser->implicit_template_parms;\n+    cp_binding_level* implicit_template_scope = parser->implicit_template_scope;\n \n     parser->num_template_parameter_lists = 0;\n     parser->in_statement = 0;\n     parser->in_switch_statement_p = false;\n     parser->fully_implicit_function_template_p = false;\n+    parser->implicit_template_parms = 0;\n+    parser->implicit_template_scope = 0;\n \n     /* By virtue of defining a local class, a lambda expression has access to\n        the private variables of enclosing classes.  */\n@@ -8689,7 +8697,10 @@ cp_parser_lambda_expression (cp_parser* parser)\n     parser->num_template_parameter_lists = saved_num_template_parameter_lists;\n     parser->in_statement = in_statement;\n     parser->in_switch_statement_p = in_switch_statement_p;\n-    parser->fully_implicit_function_template_p = fully_implicit_function_template_p;\n+    parser->fully_implicit_function_template_p\n+\t= fully_implicit_function_template_p;\n+    parser->implicit_template_parms = implicit_template_parms;\n+    parser->implicit_template_scope = implicit_template_scope;\n   }\n \n   pop_deferring_access_checks ();\n@@ -14096,7 +14107,7 @@ cp_parser_explicit_specialization (cp_parser* parser)\n     cp_parser_single_declaration (parser,\n \t\t\t\t  /*checks=*/NULL,\n \t\t\t\t  /*member_p=*/false,\n-                                  /*explicit_specialization_p=*/true,\n+\t\t\t\t  /*explicit_specialization_p=*/true,\n \t\t\t\t  /*friend_p=*/NULL);\n   /* We're done with the specialization.  */\n   end_specialization ();\n@@ -14398,10 +14409,33 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n     case RID_VOID:\n       type = void_type_node;\n       break;\n-      \n+\n     case RID_AUTO:\n       maybe_warn_cpp0x (CPP0X_AUTO);\n-      type = make_auto ();\n+      if (parser->auto_is_implicit_function_template_parm_p)\n+\t{\n+\t  type = synthesize_implicit_template_parm (parser);\n+\n+\t  if (current_class_type && LAMBDA_TYPE_P (current_class_type))\n+\t    {\n+\t      if (cxx_dialect < cxx1y)\n+\t\tpedwarn (location_of (type), 0,\n+\t\t\t \"use of %<auto%> in lambda parameter declaration \"\n+\t\t\t \"only available with \"\n+\t\t\t \"-std=c++1y or -std=gnu++1y\");\n+\t    }\n+\t  else if (cxx_dialect < cxx1y)\n+\t    pedwarn (location_of (type), 0,\n+\t\t     \"use of %<auto%> in parameter declaration \"\n+\t\t     \"only available with \"\n+\t\t     \"-std=c++1y or -std=gnu++1y\");\n+\t  else\n+\t    pedwarn (location_of (type), OPT_Wpedantic,\n+\t\t     \"ISO C++ forbids use of %<auto%> in parameter \"\n+\t\t     \"declaration\");\n+\t}\n+      else\n+\ttype = make_auto ();\n       break;\n \n     case RID_DECLTYPE:\n@@ -17980,6 +18014,20 @@ cp_parser_parameter_declaration_clause (cp_parser* parser)\n   bool ellipsis_p;\n   bool is_error;\n \n+  struct cleanup {\n+    cp_parser* parser;\n+    int auto_is_implicit_function_template_parm_p;\n+    ~cleanup() {\n+      parser->auto_is_implicit_function_template_parm_p\n+\t= auto_is_implicit_function_template_parm_p;\n+    }\n+  } cleanup = { parser, parser->auto_is_implicit_function_template_parm_p };\n+\n+  (void) cleanup;\n+\n+  if (!processing_specialization)\n+    parser->auto_is_implicit_function_template_parm_p = true;\n+\n   /* Peek at the next token.  */\n   token = cp_lexer_peek_token (parser->lexer);\n   /* Check for trivial parameter-declaration-clauses.  */\n@@ -18067,7 +18115,6 @@ cp_parser_parameter_declaration_list (cp_parser* parser, bool *is_error)\n   tree *tail = &parameters; \n   bool saved_in_unbraced_linkage_specification_p;\n   int index = 0;\n-  int implicit_template_parms = 0;\n \n   /* Assume all will go well.  */\n   *is_error = false;\n@@ -18095,18 +18142,11 @@ cp_parser_parameter_declaration_list (cp_parser* parser, bool *is_error)\n       deprecated_state = DEPRECATED_SUPPRESS;\n \n       if (parameter)\n-\t{\n-\t  decl = grokdeclarator (parameter->declarator,\n-\t\t\t\t &parameter->decl_specifiers,\n-\t\t\t\t PARM,\n-\t\t\t\t parameter->default_argument != NULL_TREE,\n-\t\t\t\t &parameter->decl_specifiers.attributes);\n-\n-\t  if (TREE_TYPE (decl) != error_mark_node\n-\t      && parameter->decl_specifiers.type\n-\t      && is_auto_or_concept (parameter->decl_specifiers.type))\n-\t      ++implicit_template_parms;\n-\t}\n+\tdecl = grokdeclarator (parameter->declarator,\n+\t\t\t       &parameter->decl_specifiers,\n+\t\t\t       PARM,\n+\t\t\t       parameter->default_argument != NULL_TREE,\n+\t\t\t       &parameter->decl_specifiers.attributes);\n \n       deprecated_state = DEPRECATED_NORMAL;\n \n@@ -18194,10 +18234,12 @@ cp_parser_parameter_declaration_list (cp_parser* parser, bool *is_error)\n   parser->in_unbraced_linkage_specification_p\n     = saved_in_unbraced_linkage_specification_p;\n \n-  if (parameters != error_mark_node && implicit_template_parms)\n-    parameters = add_implicit_template_parms (parser,\n-\t\t\t\t\t      implicit_template_parms,\n-\t\t\t\t\t      parameters);\n+  if (cp_binding_level *its = parser->implicit_template_scope)\n+    if (current_binding_level->level_chain == its)\n+      {\n+\tparser->implicit_template_parms = 0;\n+\tparser->implicit_template_scope = 0;\n+      }\n \n   return parameters;\n }\n@@ -22461,6 +22503,15 @@ cp_parser_function_definition_after_declarator (cp_parser* parser,\n   bool saved_in_function_body;\n   unsigned saved_num_template_parameter_lists;\n   cp_token *token;\n+  bool fully_implicit_function_template_p\n+    = parser->fully_implicit_function_template_p;\n+  parser->fully_implicit_function_template_p = false;\n+  tree implicit_template_parms\n+    = parser->implicit_template_parms;\n+  parser->implicit_template_parms = 0;\n+  cp_binding_level* implicit_template_scope\n+    = parser->implicit_template_scope;\n+  parser->implicit_template_scope = 0;\n \n   saved_in_function_body = parser->in_function_body;\n   parser->in_function_body = true;\n@@ -22533,6 +22584,13 @@ cp_parser_function_definition_after_declarator (cp_parser* parser,\n     = saved_num_template_parameter_lists;\n   parser->in_function_body = saved_in_function_body;\n \n+  parser->fully_implicit_function_template_p\n+    = fully_implicit_function_template_p;\n+  parser->implicit_template_parms\n+    = implicit_template_parms;\n+  parser->implicit_template_scope\n+    = implicit_template_scope;\n+\n   if (parser->fully_implicit_function_template_p)\n     finish_fully_implicit_template (parser, /*member_decl_opt=*/0);\n \n@@ -31116,7 +31174,7 @@ static tree\n make_generic_type_name ()\n {\n   char buf[32];\n-  sprintf (buf, \"<auto%d>\", ++generic_parm_count);\n+  sprintf (buf, \"auto:%d\", ++generic_parm_count);\n   return get_identifier (buf);\n }\n \n@@ -31130,110 +31188,138 @@ tree_type_is_auto_or_concept (const_tree t)\n   return TREE_TYPE (t) && is_auto_or_concept (TREE_TYPE (t));\n }\n \n-/* Add EXPECT_COUNT implicit template parameters gleaned from the generic\n-   type parameters in PARAMETERS to the CURRENT_TEMPLATE_PARMS (creating a new\n-   template parameter list if necessary).  Returns PARAMETERS suitably rewritten\n-   to reference the newly created types or ERROR_MARK_NODE on failure.  */\n+/* Add an implicit template type parameter to the CURRENT_TEMPLATE_PARMS\n+   (creating a new template parameter list if necessary).  Returns the newly\n+   created template type parm.  */\n \n tree\n-add_implicit_template_parms (cp_parser *parser, size_t expect_count,\n-\t\t\t     tree parameters)\n+synthesize_implicit_template_parm  (cp_parser *parser)\n {\n   gcc_assert (current_binding_level->kind == sk_function_parms);\n \n-  cp_binding_level *fn_parms_scope = current_binding_level;\n-\n-  bool become_template =\n-    fn_parms_scope->level_chain->kind != sk_template_parms;\n-\n-  size_t synth_count = 0;\n+  /* We are either continuing a function template that already contains implicit\n+     template parameters, creating a new fully-implicit function template, or\n+     extending an existing explicit function template with implicit template\n+     parameters.  */\n \n-  /* Roll back a scope level and either introduce a new template parameter list\n-     or update an existing one.  The function scope is added back after template\n-     parameter synthesis below.  */\n-  current_binding_level = fn_parms_scope->level_chain;\n+  cp_binding_level *const entry_scope = current_binding_level;\n \n-  /* TPARMS tracks the function's template parameter list.  This is either a new\n-     chain in the case of a fully implicit function template or an extension of\n-     the function's explicitly specified template parameter list.  */\n-  tree tparms = NULL_TREE;\n+  bool become_template = false;\n+  cp_binding_level *parent_scope = 0;\n \n-  if (become_template)\n+  if (parser->implicit_template_scope)\n     {\n-      push_deferring_access_checks (dk_deferred);\n-      begin_template_parm_list ();\n+      gcc_assert (parser->implicit_template_parms);\n \n-      parser->fully_implicit_function_template_p = true;\n-      ++parser->num_template_parameter_lists;\n+      current_binding_level = parser->implicit_template_scope;\n     }\n   else\n     {\n-      /* Roll back the innermost template parameter list such that it may be\n-\t extended in the loop below as if it were being explicitly declared.  */\n-\n-      gcc_assert (current_template_parms);\n+      /* Roll back to the existing template parameter scope (in the case of\n+\t extending an explicit function template) or introduce a new template\n+\t parameter scope ahead of the function parameter scope (or class scope\n+\t in the case of out-of-line member definitions).  The function scope is\n+\t added back after template parameter synthesis below.  */\n \n-      /* Pop the innermost template parms into TPARMS.  */\n-      tree inner_vec = INNERMOST_TEMPLATE_PARMS (current_template_parms);\n-      current_template_parms = TREE_CHAIN (current_template_parms);\n+      cp_binding_level *scope = entry_scope;\n \n-      size_t inner_vec_len = TREE_VEC_LENGTH (inner_vec);\n-      if (inner_vec_len != 0)\n+      while (scope->kind == sk_function_parms)\n \t{\n-\t  tree t = tparms = TREE_VEC_ELT (inner_vec, 0);\n-\t  for (size_t n = 1; n < inner_vec_len; ++n)\n-\t    t = TREE_CHAIN (t) = TREE_VEC_ELT (inner_vec, n);\n+\t  parent_scope = scope;\n+\t  scope = scope->level_chain;\n \t}\n+      if (current_class_type && !LAMBDA_TYPE_P (current_class_type)\n+\t  && parser->num_classes_being_defined == 0)\n+\twhile (scope->kind == sk_class)\n+\t  {\n+\t    parent_scope = scope;\n+\t    scope = scope->level_chain;\n+\t  }\n \n-      ++processing_template_parmlist;\n-    }\n+      current_binding_level = scope;\n \n-  for (tree p = parameters; p && synth_count < expect_count; p = TREE_CHAIN (p))\n-    {\n-      tree generic_type_ptr\n-\t= find_type_usage (TREE_VALUE (p), tree_type_is_auto_or_concept);\n+      if (scope->kind != sk_template_parms)\n+\t{\n+\t  /* Introduce a new template parameter list for implicit template\n+\t     parameters.  */\n \n-      if (!generic_type_ptr)\n-\tcontinue;\n+\t  become_template = true;\n+\n+\t  parser->implicit_template_scope\n+\t      = begin_scope (sk_template_parms, NULL);\n \n-      ++synth_count;\n+\t  ++processing_template_decl;\n \n-      tree synth_id = make_generic_type_name ();\n-      tree synth_tmpl_parm = finish_template_type_parm (class_type_node,\n-\t\t\t\t\t\t\tsynth_id);\n-      tparms = process_template_parm (tparms, DECL_SOURCE_LOCATION (TREE_VALUE\n-\t\t\t\t\t\t\t\t    (p)),\n-\t\t\t\t      build_tree_list (NULL_TREE,\n-\t\t\t\t\t\t       synth_tmpl_parm),\n-\t\t\t\t      /*non_type=*/false,\n-\t\t\t\t      /*param_pack=*/false);\n+\t  parser->fully_implicit_function_template_p = true;\n+\t  ++parser->num_template_parameter_lists;\n+\t}\n+      else\n+\t{\n+\t  /* Synthesize implicit template parameters at the end of the explicit\n+\t     template parameter list.  */\n \n-      /* Rewrite the type of P to be the template_parm added above (getdecls is\n-         used to retrieve it since it is the most recent declaration in this\n-         scope).  Qualifiers need to be preserved also.  */\n+\t  gcc_assert (current_template_parms);\n \n-      tree& cur_type = TREE_TYPE (generic_type_ptr);\n-      tree new_type = TREE_TYPE (getdecls ());\n+\t  parser->implicit_template_scope = scope;\n \n-      if (TYPE_QUALS (cur_type))\n-\tcur_type = cp_build_qualified_type (new_type, TYPE_QUALS (cur_type));\n-      else\n-\tcur_type = new_type;\n+\t  tree v = INNERMOST_TEMPLATE_PARMS (current_template_parms);\n+\t  parser->implicit_template_parms\n+\t    = TREE_VEC_ELT (v, TREE_VEC_LENGTH (v) - 1);\n+\t}\n     }\n \n-  gcc_assert (synth_count == expect_count);\n+  /* Synthesize a new template parameter and track the current template\n+     parameter chain with implicit_template_parms.  */\n \n-  push_binding_level (fn_parms_scope);\n+  tree synth_id = make_generic_type_name ();\n+  tree synth_tmpl_parm = finish_template_type_parm (class_type_node,\n+\t\t\t\t\t\t    synth_id);\n+  tree new_parm\n+    = process_template_parm (parser->implicit_template_parms,\n+\t\t\t     input_location,\n+\t\t\t     build_tree_list (NULL_TREE, synth_tmpl_parm),\n+\t\t\t     /*non_type=*/false,\n+\t\t\t     /*param_pack=*/false);\n \n-  end_template_parm_list (tparms);\n \n-  return parameters;\n+  if (parser->implicit_template_parms)\n+    parser->implicit_template_parms\n+      = TREE_CHAIN (parser->implicit_template_parms);\n+  else\n+    parser->implicit_template_parms = new_parm;\n+\n+  tree new_type = TREE_TYPE (getdecls ());\n+\n+  /* If creating a fully implicit function template, start the new implicit\n+     template parameter list with this synthesized type, otherwise grow the\n+     current template parameter list.  */\n+\n+  if (become_template)\n+    {\n+      parent_scope->level_chain = current_binding_level;\n+\n+      tree new_parms = make_tree_vec (1);\n+      TREE_VEC_ELT (new_parms, 0) = parser->implicit_template_parms;\n+      current_template_parms = tree_cons (size_int (processing_template_decl),\n+\t\t\t\t\t  new_parms, current_template_parms);\n+    }\n+  else\n+    {\n+      tree& new_parms = INNERMOST_TEMPLATE_PARMS (current_template_parms);\n+      int new_parm_idx = TREE_VEC_LENGTH (new_parms);\n+      new_parms = grow_tree_vec_stat (new_parms, new_parm_idx + 1);\n+      TREE_VEC_ELT (new_parms, new_parm_idx) = parser->implicit_template_parms;\n+    }\n+\n+  current_binding_level = entry_scope;\n+\n+  return new_type;\n }\n \n /* Finish the declaration of a fully implicit function template.  Such a\n    template has no explicit template parameter list so has not been through the\n-   normal template head and tail processing.  add_implicit_template_parms tries\n-   to do the head; this tries to do the tail.  MEMBER_DECL_OPT should be\n+   normal template head and tail processing.  synthesize_implicit_template_parm\n+   tries to do the head; this tries to do the tail.  MEMBER_DECL_OPT should be\n    provided if the declaration is a class member such that its template\n    declaration can be completed.  If MEMBER_DECL_OPT is provided the finished\n    form is returned.  Otherwise NULL_TREE is returned. */\n@@ -31251,7 +31337,6 @@ finish_fully_implicit_template (cp_parser *parser, tree member_decl_opt)\n       DECL_VIRTUAL_P (member_decl_opt) = false;\n     }\n \n-  pop_deferring_access_checks ();\n   if (member_decl_opt)\n     member_decl_opt = finish_member_template_decl (member_decl_opt);\n   end_template_decl ();"}, {"sha": "1024024d42dc915435ba571afdbd562c3f3c6015", "filename": "gcc/cp/parser.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dca5025f02ad920b12cede50c7968768decee19/gcc%2Fcp%2Fparser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dca5025f02ad920b12cede50c7968768decee19/gcc%2Fcp%2Fparser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.h?ref=0dca5025f02ad920b12cede50c7968768decee19", "patch": "@@ -360,11 +360,30 @@ typedef struct GTY(()) cp_parser {\n      data structure with everything needed for parsing the clauses.  */\n   cp_omp_declare_simd_data * GTY((skip)) omp_declare_simd;\n \n+  /* Nonzero if parsing a parameter list where 'auto' should trigger an implicit\n+     template parameter.  */\n+  bool auto_is_implicit_function_template_parm_p;\n+\n   /* TRUE if the function being declared was made a template due to its\n      parameter list containing generic type specifiers (`auto' or concept\n      identifiers) rather than an explicit template parameter list.  */\n   bool fully_implicit_function_template_p;\n \n+  /* Tracks the function's template parameter list when declaring a function\n+     using generic type parameters.  This is either a new chain in the case of a\n+     fully implicit function template or an extension of the function's existing\n+     template parameter list.  This is tracked to optimize calls subsequent\n+     calls to synthesize_implicit_template_parm during\n+     cp_parser_parameter_declaration.  */\n+  tree implicit_template_parms;\n+\n+  /* The scope into which an implicit template parameter list has been\n+     introduced or an existing template parameter list is being extended with\n+     implicit template paramaters.  In most cases this is the sk_function_parms\n+     scope containing the use of a generic type.  In the case of an out-of-line\n+     member definition using a generic type, it is the sk_class scope.  */\n+  cp_binding_level* implicit_template_scope;\n+\n } cp_parser;\n \n /* In parser.c  */"}, {"sha": "f4cf0ae5126d3dfafdeabc2678a07236c77e9d10", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dca5025f02ad920b12cede50c7968768decee19/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dca5025f02ad920b12cede50c7968768decee19/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0dca5025f02ad920b12cede50c7968768decee19", "patch": "@@ -1,3 +1,16 @@\n+2013-11-12  Adam Butcher  <adam@jessamine.co.uk>\n+\n+\tPR c++/58534\n+\tPR c++/58536\n+\tPR c++/58548\n+\tPR c++/58549\n+\tPR c++/58637\n+\t* g++.dg/cpp1y/pr58534.C: New testcase.\n+\t* g++.dg/cpp1y/pr58536.C: New testcase.\n+\t* g++.dg/cpp1y/pr58548.C: New testcase.\n+\t* g++.dg/cpp1y/pr58549.C: New testcase.\n+\t* g++.dg/cpp1y/pr58637.C: New testcase.\n+\n 2013-11-12  Joseph Myers  <joseph@codesourcery.com>\n \n \t* gcc.dg/c90-thread-local-1.c, gcc.dg/c99-thread-local-1.c,"}, {"sha": "4aa4f4301898dc05f548cfb694917156b0af45d8", "filename": "gcc/testsuite/g++.dg/cpp1y/pr58534.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dca5025f02ad920b12cede50c7968768decee19/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr58534.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dca5025f02ad920b12cede50c7968768decee19/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr58534.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr58534.C?ref=0dca5025f02ad920b12cede50c7968768decee19", "patch": "@@ -0,0 +1,9 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++1y\" }\n+\n+// PR c++/58534\n+\n+template<typename> void foo(const auto&) {}\n+\n+template<typename, typename...T> void foo(const auto&, T...) {}\n+"}, {"sha": "8050c1957c83499304640e900c0936211261df6e", "filename": "gcc/testsuite/g++.dg/cpp1y/pr58536.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dca5025f02ad920b12cede50c7968768decee19/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr58536.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dca5025f02ad920b12cede50c7968768decee19/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr58536.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr58536.C?ref=0dca5025f02ad920b12cede50c7968768decee19", "patch": "@@ -0,0 +1,12 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++1y\" }\n+\n+// PR c++/58536\n+\n+struct A\n+{\n+  A(auto);\n+};\n+\n+A::A(auto) {}\n+"}, {"sha": "0ac2e1c341d0edbb2025466af8bad2f00d4c0433", "filename": "gcc/testsuite/g++.dg/cpp1y/pr58548.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dca5025f02ad920b12cede50c7968768decee19/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr58548.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dca5025f02ad920b12cede50c7968768decee19/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr58548.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr58548.C?ref=0dca5025f02ad920b12cede50c7968768decee19", "patch": "@@ -0,0 +1,10 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++1y\" }\n+\n+// PR c++/58548\n+\n+void foo(auto)\n+{\n+  struct A { int i; };\n+}\n+"}, {"sha": "b71bac9975af30f07acd2e826d18dc69f3ff57fb", "filename": "gcc/testsuite/g++.dg/cpp1y/pr58549.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dca5025f02ad920b12cede50c7968768decee19/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr58549.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dca5025f02ad920b12cede50c7968768decee19/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr58549.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr58549.C?ref=0dca5025f02ad920b12cede50c7968768decee19", "patch": "@@ -0,0 +1,10 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++1y\" }\n+\n+// PR c++/58549\n+\n+void foo(auto)\n+{\n+  void bar();\n+}\n+"}, {"sha": "46200ff1c5dd0f7110490b5a4b0032a609ff4e87", "filename": "gcc/testsuite/g++.dg/cpp1y/pr58637.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dca5025f02ad920b12cede50c7968768decee19/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr58637.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dca5025f02ad920b12cede50c7968768decee19/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr58637.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr58637.C?ref=0dca5025f02ad920b12cede50c7968768decee19", "patch": "@@ -0,0 +1,7 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++1y\" }\n+\n+// PR c++/58637\n+\n+template<> void foo(auto); // { dg-error \"auto|not a template\" }\n+"}, {"sha": "dd0371d0c04bf6f51154d2af5844081eac51f916", "filename": "gcc/tree.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dca5025f02ad920b12cede50c7968768decee19/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dca5025f02ad920b12cede50c7968768decee19/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=0dca5025f02ad920b12cede50c7968768decee19", "patch": "@@ -1864,6 +1864,28 @@ make_tree_vec_stat (int len MEM_STAT_DECL)\n \n   return t;\n }\n+\n+/* Grow a TREE_VEC node to new length LEN.  */\n+\n+tree\n+grow_tree_vec_stat (tree v, int len MEM_STAT_DECL)\n+{\n+  gcc_assert (TREE_CODE (v) == TREE_VEC);\n+\n+  int oldlen = TREE_VEC_LENGTH (v);\n+  gcc_assert (len > oldlen);\n+\n+  int oldlength = (oldlen - 1) * sizeof (tree) + sizeof (struct tree_vec);\n+  int length = (len - 1) * sizeof (tree) + sizeof (struct tree_vec);\n+\n+  record_node_allocation_statistics (TREE_VEC, length - oldlength);\n+\n+  v = (tree) ggc_realloc_stat (v, length PASS_MEM_STAT);\n+\n+  TREE_VEC_LENGTH (v) = len;\n+\n+  return v;\n+}\n \f\n /* Return 1 if EXPR is the integer constant zero or a complex constant\n    of zero.  */"}, {"sha": "9c2f2d010f7bd59e604cf3b60ec45b1845df8192", "filename": "gcc/tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dca5025f02ad920b12cede50c7968768decee19/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dca5025f02ad920b12cede50c7968768decee19/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=0dca5025f02ad920b12cede50c7968768decee19", "patch": "@@ -3430,6 +3430,11 @@ extern tree make_tree_binfo_stat (unsigned MEM_STAT_DECL);\n extern tree make_tree_vec_stat (int MEM_STAT_DECL);\n #define make_tree_vec(t) make_tree_vec_stat (t MEM_STAT_INFO)\n \n+/* Grow a TREE_VEC.  */\n+\n+extern tree grow_tree_vec_stat (tree v, int MEM_STAT_DECL);\n+#define grow_tree_vec(v, t) grow_tree_vec_stat (v, t MEM_STAT_INFO)\n+\n /* Return the (unique) IDENTIFIER_NODE node for a given name.\n    The name is supplied as a char *.  */\n "}]}