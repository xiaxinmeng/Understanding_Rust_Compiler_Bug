{"sha": "8da872d9cad373d8e74a75fddf79b36b8b924b38", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGRhODcyZDljYWQzNzNkOGU3NGE3NWZkZGY3OWIzNmI4YjkyNGIzOA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2017-09-29T00:30:35Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-09-29T00:30:35Z"}, "message": "re PR other/67165 (please enable libbacktrace to work with compressed debug sections)\n\n\tPR other/67165\n\t* elf.c (__builtin_prefetch): Define if not __GNUC__.\n\t(unlikely): Define.\n\t(SHF_UNCOMPRESSED, ELFCOMPRESS_ZLIB): Define.\n\t(b_elf_chdr): Define type.\n\t(enum debug_section): Add ZDEBUG_xxx values.\n\t(debug_section_names): Add names for new sections.\n\t(struct debug_section_info): Add compressed field.\n\t(elf_zlib_failed, elf_zlib_fetch): New static functions.\n\t(HUFFMAN_TABLE_SIZE, HUFFMAN_VALUE_MASK): Define.\n\t(HUFFMAN_BITS_SHIFT, HUFFMAN_BITS_MASK): Define.\n\t(HUFFMAN_SECONDARY_SHIFT): Define.\n\t(ZDEBUG_TABLE_SIZE): Define.\n\t(ZDEBUG_TABLE_CODELEN_OFFSET, ZDEBUG_TABLE_WORK_OFFSET): Define.\n\t(final_next_secondary): New static variable if\n\tBACKTRACE_GENERATE_FIXED_HUFFMAN_TABLE.\n\t(elf_zlib_inflate_table): New static function.\n\t(BACKTRACE_GENERATE_FIXED_HUFFMAN_TABLE): If define, define main\n\tfunction to produce fixed Huffman table.\n\t(elf_zlib_default_table): New static variable.\n\t(elf_zlib_inflate): New static function.\n\t(elf_zlib_verify_checksum): Likewise.\n\t(elf_zlib_inflate_and_verify): Likewise.\n\t(elf_uncompress_zdebug): Likewise.\n\t(elf_uncompress_chdr): Likewise.\n\t(backtrace_uncompress_zdebug): New extern function.\n\t(elf_add): Look for .zdebug sections and SHF_COMPRESSED debug\n\tsections, and uncompress them.\n\t* internal.h (backtrace_compress_zdebug): Declare.\n\t* ztest.c: New file.\n\t* configure.ac: Check for -lz and check whether the linker\n\tsupports --compress-debug-sections.\n\t* Makefile.am (ztest_SOURCES): New variable.\n\t(ztest_CFLAGS, ztest_LDADD): New variables.\n\t(check_PROGRAMS): Add ztest.\n\t(ctestg_SOURCES): New variable.\n\t(ctestg_CFLAGS, ctestg_LDFLAGS, ctestg_LDADD): New variables.\n\t(ctesta_SOURCES): New variable.\n\t(ctesta_CFLAGS, ctesta_LDFLAGS, ctesta_LDADD): New variables.\n\t(check_PROGRAMS): Add ctestg and ctesta.\n\t* configure, config.h.in, Makefile.in: Rebuild.\n\nFrom-SVN: r253275", "tree": {"sha": "79d215eb52246c9b3a7111290676e41ab7d5f96b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/79d215eb52246c9b3a7111290676e41ab7d5f96b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8da872d9cad373d8e74a75fddf79b36b8b924b38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8da872d9cad373d8e74a75fddf79b36b8b924b38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8da872d9cad373d8e74a75fddf79b36b8b924b38", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8da872d9cad373d8e74a75fddf79b36b8b924b38/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ddda3741f8ebc6d844312fc14beab60529f0a44c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddda3741f8ebc6d844312fc14beab60529f0a44c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddda3741f8ebc6d844312fc14beab60529f0a44c"}], "stats": {"total": 2392, "additions": 2377, "deletions": 15}, "files": [{"sha": "6b41ecb2c6c8557f757e02cd7710fecf0a53f56b", "filename": "libbacktrace/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da872d9cad373d8e74a75fddf79b36b8b924b38/libbacktrace%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da872d9cad373d8e74a75fddf79b36b8b924b38/libbacktrace%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FChangeLog?ref=8da872d9cad373d8e74a75fddf79b36b8b924b38", "patch": "@@ -1,3 +1,47 @@\n+2017-09-28  Ian Lance Taylor  <iant@golang.org>\n+\n+\tPR other/67165\n+\t* elf.c (__builtin_prefetch): Define if not __GNUC__.\n+\t(unlikely): Define.\n+\t(SHF_UNCOMPRESSED, ELFCOMPRESS_ZLIB): Define.\n+\t(b_elf_chdr): Define type.\n+\t(enum debug_section): Add ZDEBUG_xxx values.\n+\t(debug_section_names): Add names for new sections.\n+\t(struct debug_section_info): Add compressed field.\n+\t(elf_zlib_failed, elf_zlib_fetch): New static functions.\n+\t(HUFFMAN_TABLE_SIZE, HUFFMAN_VALUE_MASK): Define.\n+\t(HUFFMAN_BITS_SHIFT, HUFFMAN_BITS_MASK): Define.\n+\t(HUFFMAN_SECONDARY_SHIFT): Define.\n+\t(ZDEBUG_TABLE_SIZE): Define.\n+\t(ZDEBUG_TABLE_CODELEN_OFFSET, ZDEBUG_TABLE_WORK_OFFSET): Define.\n+\t(final_next_secondary): New static variable if\n+\tBACKTRACE_GENERATE_FIXED_HUFFMAN_TABLE.\n+\t(elf_zlib_inflate_table): New static function.\n+\t(BACKTRACE_GENERATE_FIXED_HUFFMAN_TABLE): If define, define main\n+\tfunction to produce fixed Huffman table.\n+\t(elf_zlib_default_table): New static variable.\n+\t(elf_zlib_inflate): New static function.\n+\t(elf_zlib_verify_checksum): Likewise.\n+\t(elf_zlib_inflate_and_verify): Likewise.\n+\t(elf_uncompress_zdebug): Likewise.\n+\t(elf_uncompress_chdr): Likewise.\n+\t(backtrace_uncompress_zdebug): New extern function.\n+\t(elf_add): Look for .zdebug sections and SHF_COMPRESSED debug\n+\tsections, and uncompress them.\n+\t* internal.h (backtrace_compress_zdebug): Declare.\n+\t* ztest.c: New file.\n+\t* configure.ac: Check for -lz and check whether the linker\n+\tsupports --compress-debug-sections.\n+\t* Makefile.am (ztest_SOURCES): New variable.\n+\t(ztest_CFLAGS, ztest_LDADD): New variables.\n+\t(check_PROGRAMS): Add ztest.\n+\t(ctestg_SOURCES): New variable.\n+\t(ctestg_CFLAGS, ctestg_LDFLAGS, ctestg_LDADD): New variables.\n+\t(ctesta_SOURCES): New variable.\n+\t(ctesta_CFLAGS, ctesta_LDFLAGS, ctesta_LDADD): New variables.\n+\t(check_PROGRAMS): Add ctestg and ctesta.\n+\t* configure, config.h.in, Makefile.in: Rebuild.\n+\n 2017-09-22  Ian Lance Taylor  <iant@golang.org>\n \n \tPR sanitizer/77631"}, {"sha": "11d94eb9befaa66e7149e8f71b7c6fe7fddbe0d0", "filename": "libbacktrace/Makefile.am", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da872d9cad373d8e74a75fddf79b36b8b924b38/libbacktrace%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da872d9cad373d8e74a75fddf79b36b8b924b38/libbacktrace%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FMakefile.am?ref=8da872d9cad373d8e74a75fddf79b36b8b924b38", "patch": "@@ -101,6 +101,16 @@ stest_LDADD = libbacktrace.la\n \n check_PROGRAMS += stest\n \n+ztest_SOURCES = ztest.c testlib.c\n+ztest_CFLAGS = -DSRCDIR=\\\"$(srcdir)\\\"\n+ztest_LDADD = libbacktrace.la\n+\n+if HAVE_ZLIB\n+ztest_LDADD += -lz\n+endif\n+\n+check_PROGRAMS += ztest\n+\n edtest_SOURCES = edtest.c edtest2_build.c testlib.c\n edtest_LDADD = libbacktrace.la\n \n@@ -132,6 +142,22 @@ dtest: btest\n \n endif HAVE_OBJCOPY_DEBUGLINK\n \n+if HAVE_COMPRESSED_DEBUG\n+\n+ctestg_SOURCES = btest.c testlib.c\n+ctestg_CFLAGS = $(AM_CFLAGS) -g\n+ctestg_LDFLAGS = -Wl,--compress-debug-sections=zlib-gnu\n+ctestg_LDADD = libbacktrace.la\n+\n+ctesta_SOURCES = btest.c testlib.c\n+ctesta_CFLAGS = $(AM_CFLAGS) -g\n+ctesta_LDFLAGS = -Wl,--compress-debug-sections=zlib-gabi\n+ctesta_LDADD = libbacktrace.la\n+\n+check_PROGRAMS += ctestg ctesta\n+\n+endif\n+\n endif NATIVE\n \n # We can't use automake's automatic dependency tracking, because it"}, {"sha": "ceb769dc677d97a7cc9f24faa2ff51144818ea91", "filename": "libbacktrace/Makefile.in", "status": "modified", "additions": 94, "deletions": 8, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da872d9cad373d8e74a75fddf79b36b8b924b38/libbacktrace%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da872d9cad373d8e74a75fddf79b36b8b924b38/libbacktrace%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FMakefile.in?ref=8da872d9cad373d8e74a75fddf79b36b8b924b38", "patch": "@@ -83,10 +83,12 @@ POST_UNINSTALL = :\n build_triplet = @build@\n host_triplet = @host@\n target_triplet = @target@\n-check_PROGRAMS = $(am__EXEEXT_1) $(am__EXEEXT_2)\n-@NATIVE_TRUE@am__append_1 = btest stest edtest\n-@HAVE_PTHREAD_TRUE@@NATIVE_TRUE@am__append_2 = ttest\n-@HAVE_OBJCOPY_DEBUGLINK_TRUE@@NATIVE_TRUE@am__append_3 = dtest\n+check_PROGRAMS = $(am__EXEEXT_1) $(am__EXEEXT_2) $(am__EXEEXT_3)\n+@NATIVE_TRUE@am__append_1 = btest stest ztest edtest\n+@HAVE_ZLIB_TRUE@@NATIVE_TRUE@am__append_2 = -lz\n+@HAVE_PTHREAD_TRUE@@NATIVE_TRUE@am__append_3 = ttest\n+@HAVE_OBJCOPY_DEBUGLINK_TRUE@@NATIVE_TRUE@am__append_4 = dtest\n+@HAVE_COMPRESSED_DEBUG_TRUE@@NATIVE_TRUE@am__append_5 = ctestg ctesta\n subdir = .\n DIST_COMMON = README ChangeLog $(srcdir)/Makefile.in \\\n \t$(srcdir)/Makefile.am $(top_srcdir)/configure \\\n@@ -116,15 +118,34 @@ am_libbacktrace_la_OBJECTS = atomic.lo dwarf.lo fileline.lo posix.lo \\\n \tprint.lo sort.lo state.lo\n libbacktrace_la_OBJECTS = $(am_libbacktrace_la_OBJECTS)\n @NATIVE_TRUE@am__EXEEXT_1 = btest$(EXEEXT) stest$(EXEEXT) \\\n-@NATIVE_TRUE@\tedtest$(EXEEXT)\n+@NATIVE_TRUE@\tztest$(EXEEXT) edtest$(EXEEXT)\n @HAVE_PTHREAD_TRUE@@NATIVE_TRUE@am__EXEEXT_2 = ttest$(EXEEXT)\n+@HAVE_COMPRESSED_DEBUG_TRUE@@NATIVE_TRUE@am__EXEEXT_3 =  \\\n+@HAVE_COMPRESSED_DEBUG_TRUE@@NATIVE_TRUE@\tctestg$(EXEEXT) \\\n+@HAVE_COMPRESSED_DEBUG_TRUE@@NATIVE_TRUE@\tctesta$(EXEEXT)\n @NATIVE_TRUE@am_btest_OBJECTS = btest-btest.$(OBJEXT) \\\n @NATIVE_TRUE@\tbtest-testlib.$(OBJEXT)\n btest_OBJECTS = $(am_btest_OBJECTS)\n @NATIVE_TRUE@btest_DEPENDENCIES = libbacktrace.la\n btest_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n \t--mode=link $(CCLD) $(btest_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \\\n \t$(LDFLAGS) -o $@\n+@HAVE_COMPRESSED_DEBUG_TRUE@@NATIVE_TRUE@am_ctesta_OBJECTS = ctesta-btest.$(OBJEXT) \\\n+@HAVE_COMPRESSED_DEBUG_TRUE@@NATIVE_TRUE@\tctesta-testlib.$(OBJEXT)\n+ctesta_OBJECTS = $(am_ctesta_OBJECTS)\n+@HAVE_COMPRESSED_DEBUG_TRUE@@NATIVE_TRUE@ctesta_DEPENDENCIES =  \\\n+@HAVE_COMPRESSED_DEBUG_TRUE@@NATIVE_TRUE@\tlibbacktrace.la\n+ctesta_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=link $(CCLD) $(ctesta_CFLAGS) $(CFLAGS) \\\n+\t$(ctesta_LDFLAGS) $(LDFLAGS) -o $@\n+@HAVE_COMPRESSED_DEBUG_TRUE@@NATIVE_TRUE@am_ctestg_OBJECTS = ctestg-btest.$(OBJEXT) \\\n+@HAVE_COMPRESSED_DEBUG_TRUE@@NATIVE_TRUE@\tctestg-testlib.$(OBJEXT)\n+ctestg_OBJECTS = $(am_ctestg_OBJECTS)\n+@HAVE_COMPRESSED_DEBUG_TRUE@@NATIVE_TRUE@ctestg_DEPENDENCIES =  \\\n+@HAVE_COMPRESSED_DEBUG_TRUE@@NATIVE_TRUE@\tlibbacktrace.la\n+ctestg_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=link $(CCLD) $(ctestg_CFLAGS) $(CFLAGS) \\\n+\t$(ctestg_LDFLAGS) $(LDFLAGS) -o $@\n @NATIVE_TRUE@am_edtest_OBJECTS = edtest.$(OBJEXT) \\\n @NATIVE_TRUE@\tedtest2_build.$(OBJEXT) testlib.$(OBJEXT)\n edtest_OBJECTS = $(am_edtest_OBJECTS)\n@@ -140,6 +161,14 @@ ttest_OBJECTS = $(am_ttest_OBJECTS)\n ttest_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n \t--mode=link $(CCLD) $(ttest_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \\\n \t$(LDFLAGS) -o $@\n+@NATIVE_TRUE@am_ztest_OBJECTS = ztest-ztest.$(OBJEXT) \\\n+@NATIVE_TRUE@\tztest-testlib.$(OBJEXT)\n+ztest_OBJECTS = $(am_ztest_OBJECTS)\n+@NATIVE_TRUE@ztest_DEPENDENCIES = libbacktrace.la \\\n+@NATIVE_TRUE@\t$(am__DEPENDENCIES_1)\n+ztest_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=link $(CCLD) $(ztest_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \\\n+\t$(LDFLAGS) -o $@\n DEFAULT_INCLUDES = -I.@am__isrc@\n depcomp =\n am__depfiles_maybe =\n@@ -153,8 +182,9 @@ LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n \t--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \\\n \t$(LDFLAGS) -o $@\n SOURCES = $(libbacktrace_la_SOURCES) $(EXTRA_libbacktrace_la_SOURCES) \\\n-\t$(btest_SOURCES) $(edtest_SOURCES) $(stest_SOURCES) \\\n-\t$(ttest_SOURCES)\n+\t$(btest_SOURCES) $(ctesta_SOURCES) $(ctestg_SOURCES) \\\n+\t$(edtest_SOURCES) $(stest_SOURCES) $(ttest_SOURCES) \\\n+\t$(ztest_SOURCES)\n MULTISRCTOP = \n MULTIBUILDTOP = \n MULTIDIRS = \n@@ -345,17 +375,28 @@ libbacktrace_la_LIBADD = \\\n \t$(ALLOC_FILE)\n \n libbacktrace_la_DEPENDENCIES = $(libbacktrace_la_LIBADD)\n-TESTS = $(check_PROGRAMS) $(am__append_3)\n+TESTS = $(check_PROGRAMS) $(am__append_4)\n @NATIVE_TRUE@btest_SOURCES = btest.c testlib.c\n @NATIVE_TRUE@btest_CFLAGS = $(AM_CFLAGS) -g -O\n @NATIVE_TRUE@btest_LDADD = libbacktrace.la\n @NATIVE_TRUE@stest_SOURCES = stest.c\n @NATIVE_TRUE@stest_LDADD = libbacktrace.la\n+@NATIVE_TRUE@ztest_SOURCES = ztest.c testlib.c\n+@NATIVE_TRUE@ztest_CFLAGS = -DSRCDIR=\\\"$(srcdir)\\\"\n+@NATIVE_TRUE@ztest_LDADD = libbacktrace.la $(am__append_2)\n @NATIVE_TRUE@edtest_SOURCES = edtest.c edtest2_build.c testlib.c\n @NATIVE_TRUE@edtest_LDADD = libbacktrace.la\n @HAVE_PTHREAD_TRUE@@NATIVE_TRUE@ttest_SOURCES = ttest.c testlib.c\n @HAVE_PTHREAD_TRUE@@NATIVE_TRUE@ttest_CFLAGS = $(AM_CFLAGS) -pthread\n @HAVE_PTHREAD_TRUE@@NATIVE_TRUE@ttest_LDADD = libbacktrace.la\n+@HAVE_COMPRESSED_DEBUG_TRUE@@NATIVE_TRUE@ctestg_SOURCES = btest.c testlib.c\n+@HAVE_COMPRESSED_DEBUG_TRUE@@NATIVE_TRUE@ctestg_CFLAGS = $(AM_CFLAGS) -g\n+@HAVE_COMPRESSED_DEBUG_TRUE@@NATIVE_TRUE@ctestg_LDFLAGS = -Wl,--compress-debug-sections=zlib-gnu\n+@HAVE_COMPRESSED_DEBUG_TRUE@@NATIVE_TRUE@ctestg_LDADD = libbacktrace.la\n+@HAVE_COMPRESSED_DEBUG_TRUE@@NATIVE_TRUE@ctesta_SOURCES = btest.c testlib.c\n+@HAVE_COMPRESSED_DEBUG_TRUE@@NATIVE_TRUE@ctesta_CFLAGS = $(AM_CFLAGS) -g\n+@HAVE_COMPRESSED_DEBUG_TRUE@@NATIVE_TRUE@ctesta_LDFLAGS = -Wl,--compress-debug-sections=zlib-gabi\n+@HAVE_COMPRESSED_DEBUG_TRUE@@NATIVE_TRUE@ctesta_LDADD = libbacktrace.la\n \n # We can't use automake's automatic dependency tracking, because it\n # breaks when using bootstrap-lean.  Automatic dependency tracking\n@@ -448,6 +489,12 @@ clean-checkPROGRAMS:\n btest$(EXEEXT): $(btest_OBJECTS) $(btest_DEPENDENCIES) $(EXTRA_btest_DEPENDENCIES) \n \t@rm -f btest$(EXEEXT)\n \t$(btest_LINK) $(btest_OBJECTS) $(btest_LDADD) $(LIBS)\n+ctesta$(EXEEXT): $(ctesta_OBJECTS) $(ctesta_DEPENDENCIES) $(EXTRA_ctesta_DEPENDENCIES) \n+\t@rm -f ctesta$(EXEEXT)\n+\t$(ctesta_LINK) $(ctesta_OBJECTS) $(ctesta_LDADD) $(LIBS)\n+ctestg$(EXEEXT): $(ctestg_OBJECTS) $(ctestg_DEPENDENCIES) $(EXTRA_ctestg_DEPENDENCIES) \n+\t@rm -f ctestg$(EXEEXT)\n+\t$(ctestg_LINK) $(ctestg_OBJECTS) $(ctestg_LDADD) $(LIBS)\n edtest$(EXEEXT): $(edtest_OBJECTS) $(edtest_DEPENDENCIES) $(EXTRA_edtest_DEPENDENCIES) \n \t@rm -f edtest$(EXEEXT)\n \t$(LINK) $(edtest_OBJECTS) $(edtest_LDADD) $(LIBS)\n@@ -457,6 +504,9 @@ stest$(EXEEXT): $(stest_OBJECTS) $(stest_DEPENDENCIES) $(EXTRA_stest_DEPENDENCIE\n ttest$(EXEEXT): $(ttest_OBJECTS) $(ttest_DEPENDENCIES) $(EXTRA_ttest_DEPENDENCIES) \n \t@rm -f ttest$(EXEEXT)\n \t$(ttest_LINK) $(ttest_OBJECTS) $(ttest_LDADD) $(LIBS)\n+ztest$(EXEEXT): $(ztest_OBJECTS) $(ztest_DEPENDENCIES) $(EXTRA_ztest_DEPENDENCIES) \n+\t@rm -f ztest$(EXEEXT)\n+\t$(ztest_LINK) $(ztest_OBJECTS) $(ztest_LDADD) $(LIBS)\n \n mostlyclean-compile:\n \t-rm -f *.$(OBJEXT)\n@@ -485,6 +535,30 @@ btest-testlib.o: testlib.c\n btest-testlib.obj: testlib.c\n \t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(btest_CFLAGS) $(CFLAGS) -c -o btest-testlib.obj `if test -f 'testlib.c'; then $(CYGPATH_W) 'testlib.c'; else $(CYGPATH_W) '$(srcdir)/testlib.c'; fi`\n \n+ctesta-btest.o: btest.c\n+\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ctesta_CFLAGS) $(CFLAGS) -c -o ctesta-btest.o `test -f 'btest.c' || echo '$(srcdir)/'`btest.c\n+\n+ctesta-btest.obj: btest.c\n+\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ctesta_CFLAGS) $(CFLAGS) -c -o ctesta-btest.obj `if test -f 'btest.c'; then $(CYGPATH_W) 'btest.c'; else $(CYGPATH_W) '$(srcdir)/btest.c'; fi`\n+\n+ctesta-testlib.o: testlib.c\n+\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ctesta_CFLAGS) $(CFLAGS) -c -o ctesta-testlib.o `test -f 'testlib.c' || echo '$(srcdir)/'`testlib.c\n+\n+ctesta-testlib.obj: testlib.c\n+\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ctesta_CFLAGS) $(CFLAGS) -c -o ctesta-testlib.obj `if test -f 'testlib.c'; then $(CYGPATH_W) 'testlib.c'; else $(CYGPATH_W) '$(srcdir)/testlib.c'; fi`\n+\n+ctestg-btest.o: btest.c\n+\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ctestg_CFLAGS) $(CFLAGS) -c -o ctestg-btest.o `test -f 'btest.c' || echo '$(srcdir)/'`btest.c\n+\n+ctestg-btest.obj: btest.c\n+\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ctestg_CFLAGS) $(CFLAGS) -c -o ctestg-btest.obj `if test -f 'btest.c'; then $(CYGPATH_W) 'btest.c'; else $(CYGPATH_W) '$(srcdir)/btest.c'; fi`\n+\n+ctestg-testlib.o: testlib.c\n+\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ctestg_CFLAGS) $(CFLAGS) -c -o ctestg-testlib.o `test -f 'testlib.c' || echo '$(srcdir)/'`testlib.c\n+\n+ctestg-testlib.obj: testlib.c\n+\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ctestg_CFLAGS) $(CFLAGS) -c -o ctestg-testlib.obj `if test -f 'testlib.c'; then $(CYGPATH_W) 'testlib.c'; else $(CYGPATH_W) '$(srcdir)/testlib.c'; fi`\n+\n ttest-ttest.o: ttest.c\n \t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ttest_CFLAGS) $(CFLAGS) -c -o ttest-ttest.o `test -f 'ttest.c' || echo '$(srcdir)/'`ttest.c\n \n@@ -497,6 +571,18 @@ ttest-testlib.o: testlib.c\n ttest-testlib.obj: testlib.c\n \t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ttest_CFLAGS) $(CFLAGS) -c -o ttest-testlib.obj `if test -f 'testlib.c'; then $(CYGPATH_W) 'testlib.c'; else $(CYGPATH_W) '$(srcdir)/testlib.c'; fi`\n \n+ztest-ztest.o: ztest.c\n+\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ztest_CFLAGS) $(CFLAGS) -c -o ztest-ztest.o `test -f 'ztest.c' || echo '$(srcdir)/'`ztest.c\n+\n+ztest-ztest.obj: ztest.c\n+\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ztest_CFLAGS) $(CFLAGS) -c -o ztest-ztest.obj `if test -f 'ztest.c'; then $(CYGPATH_W) 'ztest.c'; else $(CYGPATH_W) '$(srcdir)/ztest.c'; fi`\n+\n+ztest-testlib.o: testlib.c\n+\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ztest_CFLAGS) $(CFLAGS) -c -o ztest-testlib.o `test -f 'testlib.c' || echo '$(srcdir)/'`testlib.c\n+\n+ztest-testlib.obj: testlib.c\n+\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ztest_CFLAGS) $(CFLAGS) -c -o ztest-testlib.obj `if test -f 'testlib.c'; then $(CYGPATH_W) 'testlib.c'; else $(CYGPATH_W) '$(srcdir)/testlib.c'; fi`\n+\n mostlyclean-libtool:\n \t-rm -f *.lo\n "}, {"sha": "a9f70da85f2be579ce4b3e84bb25d21c48108128", "filename": "libbacktrace/config.h.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da872d9cad373d8e74a75fddf79b36b8b924b38/libbacktrace%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da872d9cad373d8e74a75fddf79b36b8b924b38/libbacktrace%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fconfig.h.in?ref=8da872d9cad373d8e74a75fddf79b36b8b924b38", "patch": "@@ -31,6 +31,9 @@\n /* Define to 1 if you have the <inttypes.h> header file. */\n #undef HAVE_INTTYPES_H\n \n+/* Define to 1 if you have the `z' library (-lz). */\n+#undef HAVE_LIBZ\n+\n /* Define to 1 if you have the <link.h> header file. */\n #undef HAVE_LINK_H\n \n@@ -76,6 +79,9 @@\n /* Define to 1 if you have the <unistd.h> header file. */\n #undef HAVE_UNISTD_H\n \n+/* Define if -lz is available. */\n+#undef HAVE_ZLIB\n+\n /* Define to the sub-directory in which libtool stores uninstalled libraries.\n    */\n #undef LT_OBJDIR"}, {"sha": "ece4151a0c62022b011b9e503fffbfe6466a54f5", "filename": "libbacktrace/configure", "status": "modified", "additions": 111, "deletions": 2, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da872d9cad373d8e74a75fddf79b36b8b924b38/libbacktrace%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da872d9cad373d8e74a75fddf79b36b8b924b38/libbacktrace%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fconfigure?ref=8da872d9cad373d8e74a75fddf79b36b8b924b38", "patch": "@@ -607,6 +607,10 @@ NATIVE_TRUE\n HAVE_OBJCOPY_DEBUGLINK_FALSE\n HAVE_OBJCOPY_DEBUGLINK_TRUE\n OBJCOPY\n+HAVE_COMPRESSED_DEBUG_FALSE\n+HAVE_COMPRESSED_DEBUG_TRUE\n+HAVE_ZLIB_FALSE\n+HAVE_ZLIB_TRUE\n HAVE_PTHREAD_FALSE\n HAVE_PTHREAD_TRUE\n PTHREAD_CFLAGS\n@@ -11141,7 +11145,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11144 \"configure\"\n+#line 11148 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -11247,7 +11251,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11250 \"configure\"\n+#line 11254 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -12779,6 +12783,103 @@ else\n fi\n \n \n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for compress in -lz\" >&5\n+$as_echo_n \"checking for compress in -lz... \" >&6; }\n+if test \"${ac_cv_lib_z_compress+set}\" = set; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  ac_check_lib_save_LIBS=$LIBS\n+LIBS=\"-lz  $LIBS\"\n+cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+\n+/* Override any GCC internal prototype to avoid an error.\n+   Use char because int might match the return type of a GCC\n+   builtin and then its argument prototype would still apply.  */\n+#ifdef __cplusplus\n+extern \"C\"\n+#endif\n+char compress ();\n+int\n+main ()\n+{\n+return compress ();\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_link \"$LINENO\"; then :\n+  ac_cv_lib_z_compress=yes\n+else\n+  ac_cv_lib_z_compress=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext \\\n+    conftest$ac_exeext conftest.$ac_ext\n+LIBS=$ac_check_lib_save_LIBS\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_z_compress\" >&5\n+$as_echo \"$ac_cv_lib_z_compress\" >&6; }\n+if test \"x$ac_cv_lib_z_compress\" = x\"\"yes; then :\n+  cat >>confdefs.h <<_ACEOF\n+#define HAVE_LIBZ 1\n+_ACEOF\n+\n+  LIBS=\"-lz $LIBS\"\n+\n+fi\n+\n+if test $ac_cv_lib_z_compress = \"yes\"; then\n+\n+$as_echo \"#define HAVE_ZLIB 1\" >>confdefs.h\n+\n+fi\n+ if test \"$ac_cv_lib_z_compress\" = yes; then\n+  HAVE_ZLIB_TRUE=\n+  HAVE_ZLIB_FALSE='#'\n+else\n+  HAVE_ZLIB_TRUE='#'\n+  HAVE_ZLIB_FALSE=\n+fi\n+\n+\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether --compress-debug-sections is supported\" >&5\n+$as_echo_n \"checking whether --compress-debug-sections is supported... \" >&6; }\n+if test \"${libgo_cv_ld_compress+set}\" = set; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  LDFLAGS_hold=$LDFLAGS\n+LDFLAGS=\"$LDFLAGS -Wl,--compress-debug-sections=zlib-gnu\"\n+cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+\n+int\n+main ()\n+{\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_link \"$LINENO\"; then :\n+  libgo_cv_ld_compress=yes\n+else\n+  libgo_cv_ld_compress=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext \\\n+    conftest$ac_exeext conftest.$ac_ext\n+LDFLAGS=$LDFLAGS_hold\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $libgo_cv_ld_compress\" >&5\n+$as_echo \"$libgo_cv_ld_compress\" >&6; }\n+ if test \"$libgo_cv_ld_compress\" = yes; then\n+  HAVE_COMPRESSED_DEBUG_TRUE=\n+  HAVE_COMPRESSED_DEBUG_FALSE='#'\n+else\n+  HAVE_COMPRESSED_DEBUG_TRUE='#'\n+  HAVE_COMPRESSED_DEBUG_FALSE=\n+fi\n+\n+\n \n # Extract the first word of \"objcopy\", so it can be a program name with args.\n set dummy objcopy; ac_word=$2\n@@ -13008,6 +13109,14 @@ if test -z \"${HAVE_PTHREAD_TRUE}\" && test -z \"${HAVE_PTHREAD_FALSE}\"; then\n   as_fn_error \"conditional \\\"HAVE_PTHREAD\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n fi\n+if test -z \"${HAVE_ZLIB_TRUE}\" && test -z \"${HAVE_ZLIB_FALSE}\"; then\n+  as_fn_error \"conditional \\\"HAVE_ZLIB\\\" was never defined.\n+Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n+fi\n+if test -z \"${HAVE_COMPRESSED_DEBUG_TRUE}\" && test -z \"${HAVE_COMPRESSED_DEBUG_FALSE}\"; then\n+  as_fn_error \"conditional \\\"HAVE_COMPRESSED_DEBUG\\\" was never defined.\n+Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n+fi\n if test -z \"${HAVE_OBJCOPY_DEBUGLINK_TRUE}\" && test -z \"${HAVE_OBJCOPY_DEBUGLINK_FALSE}\"; then\n   as_fn_error \"conditional \\\"HAVE_OBJCOPY_DEBUGLINK\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5"}, {"sha": "f389c72f9fd929161a9fd3dbebd2b251e5c533c6", "filename": "libbacktrace/configure.ac", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da872d9cad373d8e74a75fddf79b36b8b924b38/libbacktrace%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da872d9cad373d8e74a75fddf79b36b8b924b38/libbacktrace%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fconfigure.ac?ref=8da872d9cad373d8e74a75fddf79b36b8b924b38", "patch": "@@ -405,6 +405,23 @@ AC_SUBST(PTHREAD_CFLAGS)\n \n AM_CONDITIONAL(HAVE_PTHREAD, test \"$libgo_cv_lib_pthread\" = yes)\n \n+AC_CHECK_LIB([z], [compress], [])\n+if test $ac_cv_lib_z_compress = \"yes\"; then\n+  AC_DEFINE(HAVE_ZLIB, 1, [Define if -lz is available.])\n+fi\n+AM_CONDITIONAL(HAVE_ZLIB, test \"$ac_cv_lib_z_compress\" = yes)\n+\n+dnl Test whether the linker supports the --compress_debug_sections option.\n+AC_CACHE_CHECK([whether --compress-debug-sections is supported],\n+[libgo_cv_ld_compress],\n+[LDFLAGS_hold=$LDFLAGS\n+LDFLAGS=\"$LDFLAGS -Wl,--compress-debug-sections=zlib-gnu\"\n+AC_LINK_IFELSE([AC_LANG_PROGRAM(,)],\n+[libgo_cv_ld_compress=yes],\n+[libgo_cv_ld_compress=no])\n+LDFLAGS=$LDFLAGS_hold])\n+AM_CONDITIONAL(HAVE_COMPRESSED_DEBUG, test \"$libgo_cv_ld_compress\" = yes)\n+\n AC_ARG_VAR(OBJCOPY, [location of objcopy])\n AC_CHECK_PROG(OBJCOPY, objcopy, objcopy,)\n AC_CACHE_CHECK([whether objcopy supports debuglink],"}, {"sha": "bfedca9a9cbb484e891db7f41100bfbbd7f654bc", "filename": "libbacktrace/elf.c", "status": "modified", "additions": 1624, "deletions": 5, "changes": 1629, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da872d9cad373d8e74a75fddf79b36b8b924b38/libbacktrace%2Felf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da872d9cad373d8e74a75fddf79b36b8b924b38/libbacktrace%2Felf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Felf.c?ref=8da872d9cad373d8e74a75fddf79b36b8b924b38", "patch": "@@ -56,6 +56,13 @@ POSSIBILITY OF SUCH DAMAGE.  */\n  #define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)\n #endif\n \n+#ifndef __GNUC__\n+#define __builtin_prefetch(p, r, l)\n+#define unlikely(x) (x)\n+#else\n+#define unlikely(x) __builtin_expect(!!(x), 0)\n+#endif\n+\n #if !defined(HAVE_DECL_STRNLEN) || !HAVE_DECL_STRNLEN\n \n /* If strnlen is not declared, provide our own version.  */\n@@ -164,9 +171,11 @@ dl_iterate_phdr (int (*callback) (struct dl_phdr_info *,\n #undef SHT_SYMTAB\n #undef SHT_STRTAB\n #undef SHT_DYNSYM\n+#undef SHF_COMPRESSED\n #undef STT_OBJECT\n #undef STT_FUNC\n #undef NT_GNU_BUILD_ID\n+#undef ELFCOMPRESS_ZLIB\n \n /* Basic types.  */\n \n@@ -257,6 +266,8 @@ typedef struct {\n #define SHT_STRTAB 3\n #define SHT_DYNSYM 11\n \n+#define SHF_COMPRESSED 0x800\n+\n #if BACKTRACE_ELF_SIZE == 32\n \n typedef struct\n@@ -296,6 +307,29 @@ typedef struct\n \n #define NT_GNU_BUILD_ID 3\n \n+#if BACKTRACE_ELF_SIZE == 32\n+\n+typedef struct\n+{\n+  b_elf_word\tch_type;\t\t/* Compresstion algorithm */\n+  b_elf_word\tch_size;\t\t/* Uncompressed size */\n+  b_elf_word\tch_addralign;\t\t/* Alignment for uncompressed data */\n+} b_elf_chdr;  /* Elf_Chdr */\n+\n+#else /* BACKTRACE_ELF_SIZE != 32 */\n+\n+typedef struct\n+{\n+  b_elf_word\tch_type;\t\t/* Compression algorithm */\n+  b_elf_word\tch_reserved;\t\t/* Reserved */\n+  b_elf_xword\tch_size;\t\t/* Uncompressed size */\n+  b_elf_xword\tch_addralign;\t\t/* Alignment for uncompressed data */\n+} b_elf_chdr;  /* Elf_Chdr */\n+\n+#endif /* BACKTRACE_ELF_SIZE != 32 */\n+\n+#define ELFCOMPRESS_ZLIB 1\n+\n /* An index of ELF sections we care about.  */\n \n enum debug_section\n@@ -305,6 +339,15 @@ enum debug_section\n   DEBUG_ABBREV,\n   DEBUG_RANGES,\n   DEBUG_STR,\n+\n+  /* The old style compressed sections.  This list must correspond to\n+     the list of normal debug sections.  */\n+  ZDEBUG_INFO,\n+  ZDEBUG_LINE,\n+  ZDEBUG_ABBREV,\n+  ZDEBUG_RANGES,\n+  ZDEBUG_STR,\n+\n   DEBUG_MAX\n };\n \n@@ -316,7 +359,12 @@ static const char * const debug_section_names[DEBUG_MAX] =\n   \".debug_line\",\n   \".debug_abbrev\",\n   \".debug_ranges\",\n-  \".debug_str\"\n+  \".debug_str\",\n+  \".zdebug_info\",\n+  \".zdebug_line\",\n+  \".zdebug_abbrev\",\n+  \".zdebug_ranges\",\n+  \".zdebug_str\"\n };\n \n /* Information we gather for the sections we care about.  */\n@@ -329,6 +377,8 @@ struct debug_section_info\n   size_t size;\n   /* Section contents, after read from file.  */\n   const unsigned char *data;\n+  /* Whether the SHF_COMPRESSED flag is set for the section.  */\n+  int compressed;\n };\n \n /* Information we keep for an ELF symbol.  */\n@@ -965,6 +1015,1493 @@ elf_open_debugfile_by_debuglink (struct backtrace_state *state,\n   return ddescriptor;\n }\n \n+/* A function useful for setting a breakpoint for an inflation failure\n+   when this code is compiled with -g.  */\n+\n+static void\n+elf_zlib_failed(void)\n+{\n+}\n+\n+/* *PVAL is the current value being read from the stream, and *PBITS\n+   is the number of valid bits.  Ensure that *PVAL holds at least 15\n+   bits by reading additional bits from *PPIN, up to PINEND, as\n+   needed.  Updates *PPIN, *PVAL and *PBITS.  Returns 1 on success, 0\n+   on error.  */\n+\n+static int\n+elf_zlib_fetch (const unsigned char **ppin, const unsigned char *pinend,\n+\t\tuint32_t *pval, unsigned int *pbits)\n+{\n+  unsigned int bits;\n+  const unsigned char *pin;\n+  uint32_t val;\n+\n+  bits = *pbits;\n+  if (bits >= 15)\n+    return 1;\n+  pin = *ppin;\n+  val = *pval;\n+\n+  if (unlikely (pinend - pin < 2))\n+    {\n+      elf_zlib_failed ();\n+      return 0;\n+    }\n+  val |= pin[0] << bits;\n+  val |= pin[1] << (bits + 8);\n+  bits += 16;\n+  pin += 2;\n+\n+  /* We will need the next two bytes soon.  We ask for high temporal\n+     locality because we will need the whole cache line soon.  */\n+  __builtin_prefetch (pin, 0, 3);\n+  __builtin_prefetch (pin + 1, 0, 3);\n+\n+  *ppin = pin;\n+  *pval = val;\n+  *pbits = bits;\n+  return 1;\n+}\n+\n+/* Huffman code tables, like the rest of the zlib format, are defined\n+   by RFC 1951.  We store a Huffman code table as a series of tables\n+   stored sequentially in memory.  Each entry in a table is 16 bits.\n+   The first, main, table has 256 entries.  It is followed by a set of\n+   secondary tables of length 2 to 128 entries.  The maximum length of\n+   a code sequence in the deflate format is 15 bits, so that is all we\n+   need.  Each secondary table has an index, which is the offset of\n+   the table in the overall memory storage.\n+\n+   The deflate format says that all codes of a given bit length are\n+   lexicographically consecutive.  Perhaps we could have 130 values\n+   that require a 15-bit code, perhaps requiring three secondary\n+   tables of size 128.  I don't know if this is actually possible, but\n+   it suggests that the maximum size required for secondary tables is\n+   3 * 128 + 3 * 64 ... == 768.  The zlib enough program reports 660\n+   as the maximum.  We permit 768, since in addition to the 256 for\n+   the primary table, with two bytes per entry, and with the two\n+   tables we need, that gives us a page.\n+\n+   A single table entry needs to store a value or (for the main table\n+   only) the index and size of a secondary table.  Values range from 0\n+   to 285, inclusive.  Secondary table indexes, per above, range from\n+   0 to 510.  For a value we need to store the number of bits we need\n+   to determine that value (one value may appear multiple times in the\n+   table), which is 1 to 8.  For a secondary table we need to store\n+   the number of bits used to index into the table, which is 1 to 7.\n+   And of course we need 1 bit to decide whether we have a value or a\n+   secondary table index.  So each entry needs 9 bits for value/table\n+   index, 3 bits for size, 1 bit what it is.  For simplicity we use 16\n+   bits per entry.  */\n+\n+/* Number of entries we allocate to for one code table.  We get a page\n+   for the two code tables we need.  */\n+\n+#define HUFFMAN_TABLE_SIZE (1024)\n+\n+/* Bit masks and shifts for the values in the table.  */\n+\n+#define HUFFMAN_VALUE_MASK 0x01ff\n+#define HUFFMAN_BITS_SHIFT 9\n+#define HUFFMAN_BITS_MASK 0x7\n+#define HUFFMAN_SECONDARY_SHIFT 12\n+\n+/* For working memory while inflating we need two code tables, we need\n+   an array of code lengths (max value 15, so we use unsigned char),\n+   and an array of unsigned shorts used while building a table.  The\n+   latter two arrays must be large enough to hold the maximum number\n+   of code lengths, which RFC 1951 defines as 286 + 30.  */\n+\n+#define ZDEBUG_TABLE_SIZE \\\n+  (2 * HUFFMAN_TABLE_SIZE * sizeof (uint16_t) \\\n+   + (286 + 30) * sizeof (uint16_t)\t      \\\n+   + (286 + 30) * sizeof (unsigned char))\n+\n+#define ZDEBUG_TABLE_CODELEN_OFFSET \\\n+  (2 * HUFFMAN_TABLE_SIZE * sizeof (uint16_t) \\\n+   + (286 + 30) * sizeof (uint16_t))\n+\n+#define ZDEBUG_TABLE_WORK_OFFSET \\\n+  (2 * HUFFMAN_TABLE_SIZE * sizeof (uint16_t))\n+\n+#ifdef BACKTRACE_GENERATE_FIXED_HUFFMAN_TABLE\n+\n+/* Used by the main function that generates the fixed table to learn\n+   the table size.  */\n+static size_t final_next_secondary;\n+\n+#endif\n+\n+/* Build a Huffman code table from an array of lengths in CODES of\n+   length CODES_LEN.  The table is stored into *TABLE.  ZDEBUG_TABLE\n+   is the same as for elf_zlib_inflate, used to find some work space.\n+   Returns 1 on success, 0 on error.  */\n+\n+static int\n+elf_zlib_inflate_table (unsigned char *codes, size_t codes_len,\n+\t\t\tuint16_t *zdebug_table, uint16_t *table)\n+{\n+  uint16_t count[16];\n+  uint16_t start[16];\n+  uint16_t prev[16];\n+  uint16_t firstcode[7];\n+  uint16_t *next;\n+  size_t i;\n+  size_t j;\n+  unsigned int code;\n+  size_t next_secondary;\n+\n+  /* Count the number of code of each length.  Set NEXT[val] to be the\n+     next value after VAL with the same bit length.  */\n+\n+  next = (uint16_t *) (((unsigned char *) zdebug_table)\n+\t\t       + ZDEBUG_TABLE_WORK_OFFSET);\n+\n+  memset (&count[0], 0, 16 * sizeof (uint16_t));\n+  for (i = 0; i < codes_len; ++i)\n+    {\n+      if (unlikely (codes[i] >= 16))\n+\t{\n+\t  elf_zlib_failed ();\n+\t  return 0;\n+\t}\n+\n+      if (count[codes[i]] == 0)\n+\t{\n+\t  start[codes[i]] = i;\n+\t  prev[codes[i]] = i;\n+\t}\n+      else\n+\t{\n+\t  next[prev[codes[i]]] = i;\n+\t  prev[codes[i]] = i;\n+\t}\n+\n+      ++count[codes[i]];\n+    }\n+\n+  /* For each length, fill in the table for the codes of that\n+     length.  */\n+\n+  memset (table, 0, HUFFMAN_TABLE_SIZE * sizeof (uint16_t));\n+\n+  /* Handle the values that do not require a secondary table.  */\n+\n+  code = 0;\n+  for (j = 1; j <= 8; ++j)\n+    {\n+      unsigned int jcnt;\n+      unsigned int val;\n+\n+      jcnt = count[j];\n+      if (jcnt == 0)\n+\tcontinue;\n+\n+      if (unlikely (jcnt > (1U << j)))\n+\t{\n+\t  elf_zlib_failed ();\n+\t  return 0;\n+\t}\n+\n+      /* There are JCNT values that have this length, the values\n+\t starting from START[j] continuing through NEXT[VAL].  Those\n+\t values are assigned consecutive values starting at CODE.  */\n+\n+      val = start[j];\n+      for (i = 0; i < jcnt; ++i)\n+\t{\n+\t  uint16_t tval;\n+\t  size_t ind;\n+\t  unsigned int incr;\n+\n+\t  /* In the compressed bit stream, the value VAL is encoded as\n+\t     J bits with the value C.  */\n+\n+\t  if (unlikely ((val & ~HUFFMAN_VALUE_MASK) != 0))\n+\t    {\n+\t      elf_zlib_failed ();\n+\t      return 0;\n+\t    }\n+\n+\t  tval = val | ((j - 1) << HUFFMAN_BITS_SHIFT);\n+\n+\t  /* The table lookup uses 8 bits.  If J is less than 8, we\n+\t     don't know what the other bits will be.  We need to fill\n+\t     in all possibilities in the table.  Since the Huffman\n+\t     code is unambiguous, those entries can't be used for any\n+\t     other code.  */\n+\n+\t  for (ind = code; ind < 0x100; ind += 1 << j)\n+\t    {\n+\t      if (unlikely (table[ind] != 0))\n+\t\t{\n+\t\t  elf_zlib_failed ();\n+\t\t  return 0;\n+\t\t}\n+\t      table[ind] = tval;\n+\t    }\n+\n+\t  /* Advance to the next value with this length.  */\n+\t  if (i + 1 < jcnt)\n+\t    val = next[val];\n+\n+\t  /* The Huffman codes are stored in the bitstream with the\n+\t     most significant bit first, as is required to make them\n+\t     unambiguous.  The effect is that when we read them from\n+\t     the bitstream we see the bit sequence in reverse order:\n+\t     the most significant bit of the Huffman code is the least\n+\t     significant bit of the value we read from the bitstream.\n+\t     That means that to make our table lookups work, we need\n+\t     to reverse the bits of CODE.  Since reversing bits is\n+\t     tedious and in general requires using a table, we instead\n+\t     increment CODE in reverse order.  That is, if the number\n+\t     of bits we are currently using, here named J, is 3, we\n+\t     count as 000, 100, 010, 110, 001, 101, 011, 111, which is\n+\t     to say the numbers from 0 to 7 but with the bits\n+\t     reversed.  Going to more bits, aka incrementing J,\n+\t     effectively just adds more zero bits as the beginning,\n+\t     and as such does not change the numeric value of CODE.\n+\n+\t     To increment CODE of length J in reverse order, find the\n+\t     most significant zero bit and set it to one while\n+\t     clearing all higher bits.  In other words, add 1 modulo\n+\t     2^J, only reversed.  */\n+\n+\t  incr = 1U << (j - 1);\n+\t  while ((code & incr) != 0)\n+\t    incr >>= 1;\n+\t  if (incr == 0)\n+\t    code = 0;\n+\t  else\n+\t    {\n+\t      code &= incr - 1;\n+\t      code += incr;\n+\t    }\n+\t}\n+    }\n+\n+  /* Handle the values that require a secondary table.  */\n+\n+  /* Set FIRSTCODE, the number at which the codes start, for each\n+     length.  */\n+\n+  for (j = 9; j < 16; j++)\n+    {\n+      unsigned int jcnt;\n+      unsigned int k;\n+\n+      jcnt = count[j];\n+      if (jcnt == 0)\n+\tcontinue;\n+\n+      /* There are JCNT values that have this length, the values\n+\t starting from START[j].  Those values are assigned\n+\t consecutive values starting at CODE.  */\n+\n+      firstcode[j - 9] = code;\n+\n+      /* Reverse add JCNT to CODE modulo 2^J.  */\n+      for (k = 0; k < j; ++k)\n+\t{\n+\t  if ((jcnt & (1U << k)) != 0)\n+\t    {\n+\t      unsigned int m;\n+\t      unsigned int bit;\n+\n+\t      bit = 1U << (j - k - 1);\n+\t      for (m = 0; m < j - k; ++m, bit >>= 1)\n+\t\t{\n+\t\t  if ((code & bit) == 0)\n+\t\t    {\n+\t\t      code += bit;\n+\t\t      break;\n+\t\t    }\n+\t\t  code &= ~bit;\n+\t\t}\n+\t      jcnt &= ~(1U << k);\n+\t    }\n+\t}\n+      if (unlikely (jcnt != 0))\n+\t{\n+\t  elf_zlib_failed ();\n+\t  return 0;\n+\t}\n+    }\n+\n+  /* For J from 9 to 15, inclusive, we store COUNT[J] consecutive\n+     values starting at START[J] with consecutive codes starting at\n+     FIRSTCODE[J - 9].  In the primary table we need to point to the\n+     secondary table, and the secondary table will be indexed by J - 9\n+     bits.  We count down from 15 so that we install the larger\n+     secondary tables first, as the smaller ones may be embedded in\n+     the larger ones.  */\n+\n+  next_secondary = 0; /* Index of next secondary table (after primary).  */\n+  for (j = 15; j >= 9; j--)\n+    {\n+      unsigned int jcnt;\n+      unsigned int val;\n+      size_t primary; /* Current primary index.  */\n+      size_t secondary; /* Offset to current secondary table.  */\n+      size_t secondary_bits; /* Bit size of current secondary table.  */\n+\n+      jcnt = count[j];\n+      if (jcnt == 0)\n+\tcontinue;\n+\n+      val = start[j];\n+      code = firstcode[j - 9];\n+      primary = 0x100;\n+      secondary = 0;\n+      secondary_bits = 0;\n+      for (i = 0; i < jcnt; ++i)\n+\t{\n+\t  uint16_t tval;\n+\t  size_t ind;\n+\t  unsigned int incr;\n+\n+\t  if ((code & 0xff) != primary)\n+\t    {\n+\t      uint16_t tprimary;\n+\n+\t      /* Fill in a new primary table entry.  */\n+\n+\t      primary = code & 0xff;\n+\n+\t      tprimary = table[primary];\n+\t      if (tprimary == 0)\n+\t\t{\n+\t\t  /* Start a new secondary table.  */\n+\n+\t\t  if (unlikely ((next_secondary & HUFFMAN_VALUE_MASK)\n+\t\t\t\t!= next_secondary))\n+\t\t    {\n+\t\t      elf_zlib_failed ();\n+\t\t      return 0;\n+\t\t    }\n+\n+\t\t  secondary = next_secondary;\n+\t\t  secondary_bits = j - 8;\n+\t\t  next_secondary += 1 << secondary_bits;\n+\t\t  table[primary] = (secondary\n+\t\t\t\t    + ((j - 8) << HUFFMAN_BITS_SHIFT)\n+\t\t\t\t    + (1U << HUFFMAN_SECONDARY_SHIFT));\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* There is an existing entry.  It had better be a\n+\t\t     secondary table with enough bits.  */\n+\t\t  if (unlikely ((tprimary & (1U << HUFFMAN_SECONDARY_SHIFT))\n+\t\t\t\t== 0))\n+\t\t    {\n+\t\t      elf_zlib_failed ();\n+\t\t      return 0;\n+\t\t    }\n+\t\t  secondary = tprimary & HUFFMAN_VALUE_MASK;\n+\t\t  secondary_bits = ((tprimary >> HUFFMAN_BITS_SHIFT)\n+\t\t\t\t    & HUFFMAN_BITS_MASK);\n+\t\t  if (unlikely (secondary_bits < j - 8))\n+\t\t    {\n+\t\t      elf_zlib_failed ();\n+\t\t      return 0;\n+\t\t    }\n+\t\t}\n+\t    }\n+\n+\t  /* Fill in secondary table entries.  */\n+\n+\t  tval = val | ((j - 8) << HUFFMAN_BITS_SHIFT);\n+\n+\t  for (ind = code >> 8;\n+\t       ind < (1U << secondary_bits);\n+\t       ind += 1U << (j - 8))\n+\t    {\n+\t      if (unlikely (table[secondary + 0x100 + ind] != 0))\n+\t\t{\n+\t\t  elf_zlib_failed ();\n+\t\t  return 0;\n+\t\t}\n+\t      table[secondary + 0x100 + ind] = tval;\n+\t    }\n+\n+\t  if (i + 1 < jcnt)\n+\t    val = next[val];\n+\n+\t  incr = 1U << (j - 1);\n+\t  while ((code & incr) != 0)\n+\t    incr >>= 1;\n+\t  if (incr == 0)\n+\t    code = 0;\n+\t  else\n+\t    {\n+\t      code &= incr - 1;\n+\t      code += incr;\n+\t    }\n+\t}\n+    }\n+\n+#ifdef BACKTRACE_GENERATE_FIXED_HUFFMAN_TABLE\n+  final_next_secondary = next_secondary;\n+#endif\n+\n+  return 1;\n+}\n+\n+#ifdef BACKTRACE_GENERATE_FIXED_HUFFMAN_TABLE\n+\n+/* Used to generate the fixed Huffman table for block type 1.  */\n+\n+#include <stdio.h>\n+\n+static uint16_t table[ZDEBUG_TABLE_SIZE];\n+static unsigned char codes[287];\n+\n+int\n+main ()\n+{\n+  size_t i;\n+\n+  for (i = 0; i <= 143; ++i)\n+    codes[i] = 8;\n+  for (i = 144; i <= 255; ++i)\n+    codes[i] = 9;\n+  for (i = 256; i <= 279; ++i)\n+    codes[i] = 7;\n+  for (i = 280; i <= 287; ++i)\n+    codes[i] = 8;\n+  if (!elf_zlib_inflate_table (&codes[0], 287, &table[0], &table[0]))\n+    {\n+      fprintf (stderr, \"elf_zlib_inflate_table failed\\n\");\n+      exit (EXIT_FAILURE);\n+    }\n+\n+  printf (\"static const uint16_t elf_zlib_default_table[%#zx] =\\n\",\n+\t  final_next_secondary + 0x100);\n+  printf (\"{\\n\");\n+  for (i = 0; i < final_next_secondary + 0x100; i += 8)\n+    {\n+      size_t j;\n+\n+      printf (\" \");\n+      for (j = i; j < final_next_secondary + 0x100 && j < i + 8; ++j)\n+\tprintf (\" %#x,\", table[j]);\n+      printf (\"\\n\");\n+    }\n+  printf (\"};\\n\");\n+  return 0;\n+}\n+\n+#endif\n+\n+/* The fixed table generated by the #ifdef'ed out main function\n+   above.  */\n+\n+static const uint16_t elf_zlib_default_table[0x170] =\n+{\n+  0xd00, 0xe50, 0xe10, 0xf18, 0xd10, 0xe70, 0xe30, 0x1232,\n+  0xd08, 0xe60, 0xe20, 0x1212, 0xe00, 0xe80, 0xe40, 0x1252,\n+  0xd04, 0xe58, 0xe18, 0x1202, 0xd14, 0xe78, 0xe38, 0x1242,\n+  0xd0c, 0xe68, 0xe28, 0x1222, 0xe08, 0xe88, 0xe48, 0x1262,\n+  0xd02, 0xe54, 0xe14, 0xf1c, 0xd12, 0xe74, 0xe34, 0x123a,\n+  0xd0a, 0xe64, 0xe24, 0x121a, 0xe04, 0xe84, 0xe44, 0x125a,\n+  0xd06, 0xe5c, 0xe1c, 0x120a, 0xd16, 0xe7c, 0xe3c, 0x124a,\n+  0xd0e, 0xe6c, 0xe2c, 0x122a, 0xe0c, 0xe8c, 0xe4c, 0x126a,\n+  0xd01, 0xe52, 0xe12, 0xf1a, 0xd11, 0xe72, 0xe32, 0x1236,\n+  0xd09, 0xe62, 0xe22, 0x1216, 0xe02, 0xe82, 0xe42, 0x1256,\n+  0xd05, 0xe5a, 0xe1a, 0x1206, 0xd15, 0xe7a, 0xe3a, 0x1246,\n+  0xd0d, 0xe6a, 0xe2a, 0x1226, 0xe0a, 0xe8a, 0xe4a, 0x1266,\n+  0xd03, 0xe56, 0xe16, 0xf1e, 0xd13, 0xe76, 0xe36, 0x123e,\n+  0xd0b, 0xe66, 0xe26, 0x121e, 0xe06, 0xe86, 0xe46, 0x125e,\n+  0xd07, 0xe5e, 0xe1e, 0x120e, 0xd17, 0xe7e, 0xe3e, 0x124e,\n+  0xd0f, 0xe6e, 0xe2e, 0x122e, 0xe0e, 0xe8e, 0xe4e, 0x126e,\n+  0xd00, 0xe51, 0xe11, 0xf19, 0xd10, 0xe71, 0xe31, 0x1234,\n+  0xd08, 0xe61, 0xe21, 0x1214, 0xe01, 0xe81, 0xe41, 0x1254,\n+  0xd04, 0xe59, 0xe19, 0x1204, 0xd14, 0xe79, 0xe39, 0x1244,\n+  0xd0c, 0xe69, 0xe29, 0x1224, 0xe09, 0xe89, 0xe49, 0x1264,\n+  0xd02, 0xe55, 0xe15, 0xf1d, 0xd12, 0xe75, 0xe35, 0x123c,\n+  0xd0a, 0xe65, 0xe25, 0x121c, 0xe05, 0xe85, 0xe45, 0x125c,\n+  0xd06, 0xe5d, 0xe1d, 0x120c, 0xd16, 0xe7d, 0xe3d, 0x124c,\n+  0xd0e, 0xe6d, 0xe2d, 0x122c, 0xe0d, 0xe8d, 0xe4d, 0x126c,\n+  0xd01, 0xe53, 0xe13, 0xf1b, 0xd11, 0xe73, 0xe33, 0x1238,\n+  0xd09, 0xe63, 0xe23, 0x1218, 0xe03, 0xe83, 0xe43, 0x1258,\n+  0xd05, 0xe5b, 0xe1b, 0x1208, 0xd15, 0xe7b, 0xe3b, 0x1248,\n+  0xd0d, 0xe6b, 0xe2b, 0x1228, 0xe0b, 0xe8b, 0xe4b, 0x1268,\n+  0xd03, 0xe57, 0xe17, 0x1200, 0xd13, 0xe77, 0xe37, 0x1240,\n+  0xd0b, 0xe67, 0xe27, 0x1220, 0xe07, 0xe87, 0xe47, 0x1260,\n+  0xd07, 0xe5f, 0xe1f, 0x1210, 0xd17, 0xe7f, 0xe3f, 0x1250,\n+  0xd0f, 0xe6f, 0xe2f, 0x1230, 0xe0f, 0xe8f, 0xe4f, 0,\n+  0x290, 0x291, 0x292, 0x293, 0x294, 0x295, 0x296, 0x297,\n+  0x298, 0x299, 0x29a, 0x29b, 0x29c, 0x29d, 0x29e, 0x29f,\n+  0x2a0, 0x2a1, 0x2a2, 0x2a3, 0x2a4, 0x2a5, 0x2a6, 0x2a7,\n+  0x2a8, 0x2a9, 0x2aa, 0x2ab, 0x2ac, 0x2ad, 0x2ae, 0x2af,\n+  0x2b0, 0x2b1, 0x2b2, 0x2b3, 0x2b4, 0x2b5, 0x2b6, 0x2b7,\n+  0x2b8, 0x2b9, 0x2ba, 0x2bb, 0x2bc, 0x2bd, 0x2be, 0x2bf,\n+  0x2c0, 0x2c1, 0x2c2, 0x2c3, 0x2c4, 0x2c5, 0x2c6, 0x2c7,\n+  0x2c8, 0x2c9, 0x2ca, 0x2cb, 0x2cc, 0x2cd, 0x2ce, 0x2cf,\n+  0x2d0, 0x2d1, 0x2d2, 0x2d3, 0x2d4, 0x2d5, 0x2d6, 0x2d7,\n+  0x2d8, 0x2d9, 0x2da, 0x2db, 0x2dc, 0x2dd, 0x2de, 0x2df,\n+  0x2e0, 0x2e1, 0x2e2, 0x2e3, 0x2e4, 0x2e5, 0x2e6, 0x2e7,\n+  0x2e8, 0x2e9, 0x2ea, 0x2eb, 0x2ec, 0x2ed, 0x2ee, 0x2ef,\n+  0x2f0, 0x2f1, 0x2f2, 0x2f3, 0x2f4, 0x2f5, 0x2f6, 0x2f7,\n+  0x2f8, 0x2f9, 0x2fa, 0x2fb, 0x2fc, 0x2fd, 0x2fe, 0x2ff,\n+};\n+\n+/* Inflate a zlib stream from PIN/SIN to POUT/SOUT.  Return 1 on\n+   success, 0 on some error parsing the stream.  */\n+\n+static int\n+elf_zlib_inflate (const unsigned char *pin, size_t sin, uint16_t *zdebug_table,\n+\t\t  unsigned char *pout, size_t sout)\n+{\n+  unsigned char *porigout;\n+  const unsigned char *pinend;\n+  unsigned char *poutend;\n+\n+  /* We can apparently see multiple zlib streams concatenated\n+     together, so keep going as long as there is something to read.\n+     The last 4 bytes are the checksum.  */\n+  porigout = pout;\n+  pinend = pin + sin;\n+  poutend = pout + sout;\n+  while ((pinend - pin) > 4)\n+    {\n+      uint32_t val;\n+      unsigned int bits;\n+      int last;\n+\n+      /* Read the two byte zlib header.  */\n+\n+      if (unlikely ((pin[0] & 0xf) != 8)) /* 8 is zlib encoding.  */\n+\t{\n+\t  /* Unknown compression method.  */\n+\t  elf_zlib_failed ();\n+\t  return 0;\n+\t}\n+      if (unlikely ((pin[0] >> 4) > 7))\n+\t{\n+\t  /* Window size too large.  Other than this check, we don't\n+\t     care about the window size.  */\n+\t  elf_zlib_failed ();\n+\t  return 0;\n+\t}\n+      if (unlikely ((pin[1] & 0x20) != 0))\n+\t{\n+\t  /* Stream expects a predefined dictionary, but we have no\n+\t     dictionary.  */\n+\t  elf_zlib_failed ();\n+\t  return 0;\n+\t}\n+      val = (pin[0] << 8) | pin[1];\n+      if (unlikely (val % 31 != 0))\n+\t{\n+\t  /* Header check failure.  */\n+\t  elf_zlib_failed ();\n+\t  return 0;\n+\t}\n+      pin += 2;\n+\n+      /* Read blocks until one is marked last.  */\n+\n+      val = 0;\n+      bits = 0;\n+      last = 0;\n+\n+      while (!last)\n+\t{\n+\t  unsigned int type;\n+\t  const uint16_t *tlit;\n+\t  const uint16_t *tdist;\n+\n+\t  if (!elf_zlib_fetch (&pin, pinend, &val, &bits))\n+\t    return 0;\n+\n+\t  last = val & 1;\n+\t  type = (val >> 1) & 3;\n+\t  val >>= 3;\n+\t  bits -= 3;\n+\n+\t  if (unlikely (type == 3))\n+\t    {\n+\t      /* Invalid block type.  */\n+\t      elf_zlib_failed ();\n+\t      return 0;\n+\t    }\n+\n+\t  if (type == 0)\n+\t    {\n+\t      uint16_t len;\n+\t      uint16_t lenc;\n+\n+\t      /* An uncompressed block.  */\n+\n+\t      /* If we've read ahead more than a byte, back up.  */\n+\t      while (bits > 8)\n+\t\t{\n+\t\t  --pin;\n+\t\t  bits -= 8;\n+\t\t}\n+\n+\t      val = 0;\n+\t      bits = 0;\n+\t      if (unlikely ((pinend - pin) < 4))\n+\t\t{\n+\t\t  /* Missing length.  */\n+\t\t  elf_zlib_failed ();\n+\t\t  return 0;\n+\t\t}\n+\t      len = pin[0] | (pin[1] << 8);\n+\t      lenc = pin[2] | (pin[3] << 8);\n+\t      pin += 4;\n+\t      lenc = ~lenc;\n+\t      if (unlikely (len != lenc))\n+\t\t{\n+\t\t  /* Corrupt data.  */\n+\t\t  elf_zlib_failed ();\n+\t\t  return 0;\n+\t\t}\n+\t      if (unlikely (len > (unsigned int) (pinend - pin)\n+\t\t\t    || len > (unsigned int) (poutend - pout)))\n+\t\t{\n+\t\t  /* Not enough space in buffers.  */\n+\t\t  elf_zlib_failed ();\n+\t\t  return 0;\n+\t\t}\n+\t      memcpy (pout, pin, len);\n+\t      pout += len;\n+\t      pin += len;\n+\n+\t      /* Go around to read the next block.  */\n+\t      continue;\n+\t    }\n+\n+\t  if (type == 1)\n+\t    {\n+\t      tlit = elf_zlib_default_table;\n+\t      tdist = elf_zlib_default_table;\n+\t    }\n+\t  else\n+\t    {\n+\t      unsigned int nlit;\n+\t      unsigned int ndist;\n+\t      unsigned int nclen;\n+\t      unsigned char codebits[19];\n+\t      unsigned char *plenbase;\n+\t      unsigned char *plen;\n+\t      unsigned char *plenend;\n+\n+\t      /* Read a Huffman encoding table.  The various magic\n+\t\t numbers here are from RFC 1951.  */\n+\n+\t      if (!elf_zlib_fetch (&pin, pinend, &val, &bits))\n+\t\treturn 0;\n+\n+\t      nlit = (val & 0x1f) + 257;\n+\t      val >>= 5;\n+\t      ndist = (val & 0x1f) + 1;\n+\t      val >>= 5;\n+\t      nclen = (val & 0xf) + 4;\n+\t      val >>= 4;\n+\t      bits -= 14;\n+\t      if (unlikely (nlit > 286 || ndist > 30))\n+\t\t{\n+\t\t  /* Values out of range.  */\n+\t\t  elf_zlib_failed ();\n+\t\t  return 0;\n+\t\t}\n+\n+\t      /* Read and build the table used to compress the\n+\t\t literal, length, and distance codes.  */\n+\n+\t      memset(&codebits[0], 0, 19);\n+\n+\t      /* There are always at least 4 elements in the\n+\t\t table.  */\n+\n+\t      if (!elf_zlib_fetch (&pin, pinend, &val, &bits))\n+\t\treturn 0;\n+\n+\t      codebits[16] = val & 7;\n+\t      codebits[17] = (val >> 3) & 7;\n+\t      codebits[18] = (val >> 6) & 7;\n+\t      codebits[0] = (val >> 9) & 7;\n+\t      val >>= 12;\n+\t      bits -= 12;\n+\n+\t      if (nclen == 4)\n+\t\tgoto codebitsdone;\n+\n+\t      codebits[8] = val & 7;\n+\t      val >>= 3;\n+\t      bits -= 3;\n+\n+\t      if (nclen == 5)\n+\t\tgoto codebitsdone;\n+\n+\t      if (!elf_zlib_fetch (&pin, pinend, &val, &bits))\n+\t\treturn 0;\n+\n+\t      codebits[7] = val & 7;\n+\t      val >>= 3;\n+\t      bits -= 3;\n+\n+\t      if (nclen == 6)\n+\t\tgoto codebitsdone;\n+\n+\t      codebits[9] = val & 7;\n+\t      val >>= 3;\n+\t      bits -= 3;\n+\n+\t      if (nclen == 7)\n+\t\tgoto codebitsdone;\n+\n+\t      codebits[6] = val & 7;\n+\t      val >>= 3;\n+\t      bits -= 3;\n+\n+\t      if (nclen == 8)\n+\t\tgoto codebitsdone;\n+\n+\t      codebits[10] = val & 7;\n+\t      val >>= 3;\n+\t      bits -= 3;\n+\n+\t      if (nclen == 9)\n+\t\tgoto codebitsdone;\n+\n+\t      codebits[5] = val & 7;\n+\t      val >>= 3;\n+\t      bits -= 3;\n+\n+\t      if (nclen == 10)\n+\t\tgoto codebitsdone;\n+\n+\t      if (!elf_zlib_fetch (&pin, pinend, &val, &bits))\n+\t\treturn 0;\n+\n+\t      codebits[11] = val & 7;\n+\t      val >>= 3;\n+\t      bits -= 3;\n+\n+\t      if (nclen == 11)\n+\t\tgoto codebitsdone;\n+\n+\t      codebits[4] = val & 7;\n+\t      val >>= 3;\n+\t      bits -= 3;\n+\n+\t      if (nclen == 12)\n+\t\tgoto codebitsdone;\n+\n+\t      codebits[12] = val & 7;\n+\t      val >>= 3;\n+\t      bits -= 3;\n+\n+\t      if (nclen == 13)\n+\t\tgoto codebitsdone;\n+\n+\t      codebits[3] = val & 7;\n+\t      val >>= 3;\n+\t      bits -= 3;\n+\n+\t      if (nclen == 14)\n+\t\tgoto codebitsdone;\n+\n+\t      codebits[13] = val & 7;\n+\t      val >>= 3;\n+\t      bits -= 3;\n+\n+\t      if (nclen == 15)\n+\t\tgoto codebitsdone;\n+\n+\t      if (!elf_zlib_fetch (&pin, pinend, &val, &bits))\n+\t\treturn 0;\n+\n+\t      codebits[2] = val & 7;\n+\t      val >>= 3;\n+\t      bits -= 3;\n+\n+\t      if (nclen == 16)\n+\t\tgoto codebitsdone;\n+\n+\t      codebits[14] = val & 7;\n+\t      val >>= 3;\n+\t      bits -= 3;\n+\n+\t      if (nclen == 17)\n+\t\tgoto codebitsdone;\n+\n+\t      codebits[1] = val & 7;\n+\t      val >>= 3;\n+\t      bits -= 3;\n+\n+\t      if (nclen == 18)\n+\t\tgoto codebitsdone;\n+\n+\t      codebits[15] = val & 7;\n+\t      val >>= 3;\n+\t      bits -= 3;\n+\n+\t    codebitsdone:\n+\n+\t      if (!elf_zlib_inflate_table (codebits, 19, zdebug_table,\n+\t\t\t\t\t   zdebug_table))\n+\t\treturn 0;\n+\n+\t      /* Read the compressed bit lengths of the literal,\n+\t\t length, and distance codes.  We have allocated space\n+\t\t at the end of zdebug_table to hold them.  */\n+\n+\t      plenbase = (((unsigned char *) zdebug_table)\n+\t\t\t  + ZDEBUG_TABLE_CODELEN_OFFSET);\n+\t      plen = plenbase;\n+\t      plenend = plen + nlit + ndist;\n+\t      while (plen < plenend)\n+\t\t{\n+\t\t  uint16_t t;\n+\t\t  unsigned int b;\n+\t\t  uint16_t v;\n+\n+\t\t  if (!elf_zlib_fetch (&pin, pinend, &val, &bits))\n+\t\t    return 0;\n+\n+\t\t  t = zdebug_table[val & 0xff];\n+\n+\t\t  /* The compression here uses bit lengths up to 7, so\n+\t\t     a secondary table is never necessary.  */\n+\t\t  if (unlikely ((t & (1U << HUFFMAN_SECONDARY_SHIFT)) != 0))\n+\t\t    {\n+\t\t      elf_zlib_failed ();\n+\t\t      return 0;\n+\t\t    }\n+\n+\t\t  b = (t >> HUFFMAN_BITS_SHIFT) & HUFFMAN_BITS_MASK;\n+\t\t  val >>= b + 1;\n+\t\t  bits -= b + 1;\n+\n+\t\t  v = t & HUFFMAN_VALUE_MASK;\n+\t\t  if (v < 16)\n+\t\t    *plen++ = v;\n+\t\t  else if (v == 16)\n+\t\t    {\n+\t\t      unsigned int c;\n+\t\t      unsigned int prev;\n+\n+\t\t      /* Copy previous entry 3 to 6 times.  */\n+\n+\t\t      if (unlikely (plen == plenbase))\n+\t\t\t{\n+\t\t\t  elf_zlib_failed ();\n+\t\t\t  return 0;\n+\t\t\t}\n+\n+\t\t      /* We used up to 7 bits since the last\n+\t\t\t elf_zlib_fetch, so we have at least 8 bits\n+\t\t\t available here.  */\n+\n+\t\t      c = 3 + (val & 0x3);\n+\t\t      val >>= 2;\n+\t\t      bits -= 2;\n+\t\t      if (unlikely ((unsigned int) (plenend - plen) < c))\n+\t\t\t{\n+\t\t\t  elf_zlib_failed ();\n+\t\t\t  return 0;\n+\t\t\t}\n+\n+\t\t      prev = plen[-1];\n+\t\t      switch (c)\n+\t\t\t{\n+\t\t\tcase 6:\n+\t\t\t  *plen++ = prev;\n+\t\t\t  /* fallthrough */\n+\t\t\tcase 5:\n+\t\t\t  *plen++ = prev;\n+\t\t\t  /* fallthrough */\n+\t\t\tcase 4:\n+\t\t\t  *plen++ = prev;\n+\t\t\t}\n+\t\t      *plen++ = prev;\n+\t\t      *plen++ = prev;\n+\t\t      *plen++ = prev;\n+\t\t    }\n+\t\t  else if (v == 17)\n+\t\t    {\n+\t\t      unsigned int c;\n+\n+\t\t      /* Store zero 3 to 10 times.  */\n+\n+\t\t      /* We used up to 7 bits since the last\n+\t\t\t elf_zlib_fetch, so we have at least 8 bits\n+\t\t\t available here.  */\n+\n+\t\t      c = 3 + (val & 0x7);\n+\t\t      val >>= 3;\n+\t\t      bits -= 3;\n+\t\t      if (unlikely ((unsigned int) (plenend - plen) < c))\n+\t\t\t{\n+\t\t\t  elf_zlib_failed ();\n+\t\t\t  return 0;\n+\t\t\t}\n+\n+\t\t      switch (c)\n+\t\t\t{\n+\t\t\tcase 10:\n+\t\t\t  *plen++ = 0;\n+\t\t\t  /* fallthrough */\n+\t\t\tcase 9:\n+\t\t\t  *plen++ = 0;\n+\t\t\t  /* fallthrough */\n+\t\t\tcase 8:\n+\t\t\t  *plen++ = 0;\n+\t\t\t  /* fallthrough */\n+\t\t\tcase 7:\n+\t\t\t  *plen++ = 0;\n+\t\t\t  /* fallthrough */\n+\t\t\tcase 6:\n+\t\t\t  *plen++ = 0;\n+\t\t\t  /* fallthrough */\n+\t\t\tcase 5:\n+\t\t\t  *plen++ = 0;\n+\t\t\t  /* fallthrough */\n+\t\t\tcase 4:\n+\t\t\t  *plen++ = 0;\n+\t\t\t}\n+\t\t      *plen++ = 0;\n+\t\t      *plen++ = 0;\n+\t\t      *plen++ = 0;\n+\t\t    }\n+\t\t  else if (v == 18)\n+\t\t    {\n+\t\t      unsigned int c;\n+\n+\t\t      /* Store zero 11 to 138 times.  */\n+\n+\t\t      /* We used up to 7 bits since the last\n+\t\t\t elf_zlib_fetch, so we have at least 8 bits\n+\t\t\t available here.  */\n+\n+\t\t      c = 11 + (val & 0x7f);\n+\t\t      val >>= 7;\n+\t\t      bits -= 7;\n+\t\t      if (unlikely ((unsigned int) (plenend - plen) < c))\n+\t\t\t{\n+\t\t\t  elf_zlib_failed ();\n+\t\t\t  return 0;\n+\t\t\t}\n+\n+\t\t      memset (plen, 0, c);\n+\t\t      plen += c;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      elf_zlib_failed ();\n+\t\t      return 0;\n+\t\t    }\n+\t\t}\n+\n+\t      /* Make sure that the stop code can appear.  */\n+\n+\t      plen = plenbase;\n+\t      if (unlikely (plen[256] == 0))\n+\t\t{\n+\t\t  elf_zlib_failed ();\n+\t\t  return 0;\n+\t\t}\n+\n+\t      /* Build the decompression tables.  */\n+\n+\t      if (!elf_zlib_inflate_table (plen, nlit, zdebug_table,\n+\t\t\t\t\t   zdebug_table))\n+\t\treturn 0;\n+\t      if (!elf_zlib_inflate_table (plen + nlit, ndist, zdebug_table,\n+\t\t\t\t\t   zdebug_table + HUFFMAN_TABLE_SIZE))\n+\t\treturn 0;\n+\t      tlit = zdebug_table;\n+\t      tdist = zdebug_table + HUFFMAN_TABLE_SIZE;\n+\t    }\n+\n+\t  /* Inflate values until the end of the block.  This is the\n+\t     main loop of the inflation code.  */\n+\n+\t  while (1)\n+\t    {\n+\t      uint16_t t;\n+\t      unsigned int b;\n+\t      uint16_t v;\n+\t      unsigned int lit;\n+\n+\t      if (!elf_zlib_fetch (&pin, pinend, &val, &bits))\n+\t\treturn 0;\n+\n+\t      t = tlit[val & 0xff];\n+\t      b = (t >> HUFFMAN_BITS_SHIFT) & HUFFMAN_BITS_MASK;\n+\t      v = t & HUFFMAN_VALUE_MASK;\n+\n+\t      if ((t & (1U << HUFFMAN_SECONDARY_SHIFT)) == 0)\n+\t\t{\n+\t\t  lit = v;\n+\t\t  val >>= b + 1;\n+\t\t  bits -= b + 1;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  t = tlit[v + 0x100 + ((val >> 8) & ((1U << b) - 1))];\n+\t\t  b = (t >> HUFFMAN_BITS_SHIFT) & HUFFMAN_BITS_MASK;\n+\t\t  lit = t & HUFFMAN_VALUE_MASK;\n+\t\t  val >>= b + 8;\n+\t\t  bits -= b + 8;\n+\t\t}\n+\n+\t      if (lit < 256)\n+\t\t{\n+\t\t  if (unlikely (pout == poutend))\n+\t\t    {\n+\t\t      elf_zlib_failed ();\n+\t\t      return 0;\n+\t\t    }\n+\n+\t\t  *pout++ = lit;\n+\n+\t\t  /* We will need to write the next byte soon.  We ask\n+\t\t     for high temporal locality because we will write\n+\t\t     to the whole cache line soon.  */\n+\t\t  __builtin_prefetch (pout, 1, 3);\n+\t\t}\n+\t      else if (lit == 256)\n+\t\t{\n+\t\t  /* The end of the block.  */\n+\t\t  break;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  unsigned int dist;\n+\t\t  unsigned int len;\n+\n+\t\t  /* Convert lit into a length.  */\n+\n+\t\t  if (lit < 265)\n+\t\t    len = lit - 257 + 3;\n+\t\t  else if (lit == 285)\n+\t\t    len = 258;\n+\t\t  else if (unlikely (lit > 285))\n+\t\t    {\n+\t\t      elf_zlib_failed ();\n+\t\t      return 0;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      unsigned int extra;\n+\n+\t\t      if (!elf_zlib_fetch (&pin, pinend, &val, &bits))\n+\t\t\treturn 0;\n+\n+\t\t      /* This is an expression for the table of length\n+\t\t\t codes in RFC 1951 3.2.5.  */\n+\t\t      lit -= 265;\n+\t\t      extra = (lit >> 2) + 1;\n+\t\t      len = (lit & 3) << extra;\n+\t\t      len += 11;\n+\t\t      len += ((1U << (extra - 1)) - 1) << 3;\n+\t\t      len += val & ((1U << extra) - 1);\n+\t\t      val >>= extra;\n+\t\t      bits -= extra;\n+\t\t    }\n+\n+\t\t  if (!elf_zlib_fetch (&pin, pinend, &val, &bits))\n+\t\t    return 0;\n+\n+\t\t  t = tdist[val & 0xff];\n+\t\t  b = (t >> HUFFMAN_BITS_SHIFT) & HUFFMAN_BITS_MASK;\n+\t\t  v = t & HUFFMAN_VALUE_MASK;\n+\n+\t\t  if ((t & (1U << HUFFMAN_SECONDARY_SHIFT)) == 0)\n+\t\t    {\n+\t\t      dist = v;\n+\t\t      val >>= b + 1;\n+\t\t      bits -= b + 1;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      t = tdist[v + 0x100 + ((val >> 8) & ((1U << b) - 1))];\n+\t\t      b = (t >> HUFFMAN_BITS_SHIFT) & HUFFMAN_BITS_MASK;\n+\t\t      dist = t & HUFFMAN_VALUE_MASK;\n+\t\t      val >>= b + 8;\n+\t\t      bits -= b + 8;\n+\t\t    }\n+\n+\t\t  /* Convert dist to a distance.  */\n+\n+\t\t  if (dist == 0)\n+\t\t    {\n+\t\t      /* A distance of 1.  A common case, meaning\n+\t\t\t repeat the last character LEN times.  */\n+\n+\t\t      if (unlikely (pout == porigout))\n+\t\t\t{\n+\t\t\t  elf_zlib_failed ();\n+\t\t\t  return 0;\n+\t\t\t}\n+\n+\t\t      if (unlikely ((unsigned int) (poutend - pout) < len))\n+\t\t\t{\n+\t\t\t  elf_zlib_failed ();\n+\t\t\t  return 0;\n+\t\t\t}\n+\n+\t\t      memset (pout, pout[-1], len);\n+\t\t      pout += len;\n+\t\t    }\n+\t\t  else if (unlikely (dist > 29))\n+\t\t    {\n+\t\t      elf_zlib_failed ();\n+\t\t      return 0;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      if (dist < 4)\n+\t\t\tdist = dist + 1;\n+\t\t      else\n+\t\t\t{\n+\t\t\t  unsigned int extra;\n+\n+\t\t\t  if (!elf_zlib_fetch (&pin, pinend, &val, &bits))\n+\t\t\t    return 0;\n+\n+\t\t\t  /* This is an expression for the table of\n+\t\t\t     distance codes in RFC 1951 3.2.5.  */\n+\t\t\t  dist -= 4;\n+\t\t\t  extra = (dist >> 1) + 1;\n+\t\t\t  dist = (dist & 1) << extra;\n+\t\t\t  dist += 5;\n+\t\t\t  dist += ((1U << (extra - 1)) - 1) << 2;\n+\t\t\t  dist += val & ((1U << extra) - 1);\n+\t\t\t  val >>= extra;\n+\t\t\t  bits -= extra;\n+\t\t\t}\n+\n+\t\t      /* Go back dist bytes, and copy len bytes from\n+\t\t\t there.  */\n+\n+\t\t      if (unlikely ((unsigned int) (pout - porigout) < dist))\n+\t\t\t{\n+\t\t\t  elf_zlib_failed ();\n+\t\t\t  return 0;\n+\t\t\t}\n+\n+\t\t      if (unlikely ((unsigned int) (poutend - pout) < len))\n+\t\t\t{\n+\t\t\t  elf_zlib_failed ();\n+\t\t\t  return 0;\n+\t\t\t}\n+\n+\t\t      if (dist >= len)\n+\t\t\t{\n+\t\t\t  memcpy (pout, pout - dist, len);\n+\t\t\t  pout += len;\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  while (len > 0)\n+\t\t\t    {\n+\t\t\t      unsigned int copy;\n+\n+\t\t\t      copy = len < dist ? len : dist;\n+\t\t\t      memcpy (pout, pout - dist, copy);\n+\t\t\t      len -= copy;\n+\t\t\t      pout += copy;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  /* We should have filled the output buffer.  */\n+  if (unlikely (pout != poutend))\n+    {\n+      elf_zlib_failed ();\n+      return 0;\n+    }\n+\n+  return 1;\n+}\n+\n+/* Verify the zlib checksum.  The checksum is in the 4 bytes at\n+   CHECKBYTES, and the uncompressed data is at UNCOMPRESSED /\n+   UNCOMPRESSED_SIZE.  Returns 1 on success, 0 on failure.  */\n+\n+static int\n+elf_zlib_verify_checksum (const unsigned char *checkbytes,\n+\t\t\t  const unsigned char *uncompressed,\n+\t\t\t  size_t uncompressed_size)\n+{\n+  unsigned int i;\n+  unsigned int cksum;\n+  const unsigned char *p;\n+  uint32_t s1;\n+  uint32_t s2;\n+  size_t hsz;\n+\n+  cksum = 0;\n+  for (i = 0; i < 4; i++)\n+    cksum = (cksum << 8) | checkbytes[i];\n+\n+  s1 = 1;\n+  s2 = 0;\n+\n+  /* Minimize modulo operations.  */\n+\n+  p = uncompressed;\n+  hsz = uncompressed_size;\n+  while (hsz >= 5552)\n+    {\n+      for (i = 0; i < 5552; i += 16)\n+\t{\n+\t  /* Manually unroll loop 16 times.  */\n+\t  s1 = s1 + *p++;\n+\t  s2 = s2 + s1;\n+\t  s1 = s1 + *p++;\n+\t  s2 = s2 + s1;\n+\t  s1 = s1 + *p++;\n+\t  s2 = s2 + s1;\n+\t  s1 = s1 + *p++;\n+\t  s2 = s2 + s1;\n+\t  s1 = s1 + *p++;\n+\t  s2 = s2 + s1;\n+\t  s1 = s1 + *p++;\n+\t  s2 = s2 + s1;\n+\t  s1 = s1 + *p++;\n+\t  s2 = s2 + s1;\n+\t  s1 = s1 + *p++;\n+\t  s2 = s2 + s1;\n+\t  s1 = s1 + *p++;\n+\t  s2 = s2 + s1;\n+\t  s1 = s1 + *p++;\n+\t  s2 = s2 + s1;\n+\t  s1 = s1 + *p++;\n+\t  s2 = s2 + s1;\n+\t  s1 = s1 + *p++;\n+\t  s2 = s2 + s1;\n+\t  s1 = s1 + *p++;\n+\t  s2 = s2 + s1;\n+\t  s1 = s1 + *p++;\n+\t  s2 = s2 + s1;\n+\t  s1 = s1 + *p++;\n+\t  s2 = s2 + s1;\n+\t  s1 = s1 + *p++;\n+\t  s2 = s2 + s1;\n+\t}\n+      hsz -= 5552;\n+      s1 %= 65521;\n+      s2 %= 65521;\n+    }\n+\n+  while (hsz >= 16)\n+    {\n+      /* Manually unroll loop 16 times.  */\n+      s1 = s1 + *p++;\n+      s2 = s2 + s1;\n+      s1 = s1 + *p++;\n+      s2 = s2 + s1;\n+      s1 = s1 + *p++;\n+      s2 = s2 + s1;\n+      s1 = s1 + *p++;\n+      s2 = s2 + s1;\n+      s1 = s1 + *p++;\n+      s2 = s2 + s1;\n+      s1 = s1 + *p++;\n+      s2 = s2 + s1;\n+      s1 = s1 + *p++;\n+      s2 = s2 + s1;\n+      s1 = s1 + *p++;\n+      s2 = s2 + s1;\n+      s1 = s1 + *p++;\n+      s2 = s2 + s1;\n+      s1 = s1 + *p++;\n+      s2 = s2 + s1;\n+      s1 = s1 + *p++;\n+      s2 = s2 + s1;\n+      s1 = s1 + *p++;\n+      s2 = s2 + s1;\n+      s1 = s1 + *p++;\n+      s2 = s2 + s1;\n+      s1 = s1 + *p++;\n+      s2 = s2 + s1;\n+      s1 = s1 + *p++;\n+      s2 = s2 + s1;\n+      s1 = s1 + *p++;\n+      s2 = s2 + s1;\n+\n+      hsz -= 16;\n+    }\n+\n+  for (i = 0; i < hsz; ++i)\n+    {\n+      s1 = s1 + *p++;\n+      s2 = s2 + s1;\n+    }\n+\n+  s1 %= 65521;\n+  s2 %= 65521;\n+\n+  if (unlikely ((s2 << 16) + s1 != cksum))\n+    {\n+      elf_zlib_failed ();\n+      return 0;\n+    }\n+\n+  return 1;\n+}\n+\n+/* Inflate a zlib stream from PIN/SIN to POUT/SOUT, and verify the\n+   checksum.  Return 1 on success, 0 on error.  */\n+\n+static int\n+elf_zlib_inflate_and_verify (const unsigned char *pin, size_t sin,\n+\t\t\t     uint16_t *zdebug_table, unsigned char *pout,\n+\t\t\t     size_t sout)\n+{\n+  if (!elf_zlib_inflate (pin, sin, zdebug_table, pout, sout))\n+    return 0;\n+  if (!elf_zlib_verify_checksum (pin + sin - 4, pout, sout))\n+    return 0;\n+  return 1;\n+}\n+\n+/* Uncompress the old compressed debug format, the one emitted by\n+   --compress-debug-sections=zlib-gnu.  The compressed data is in\n+   COMPRESSED / COMPRESSED_SIZE, and the function writes to\n+   *UNCOMPRESSED / *UNCOMPRESSED_SIZE.  ZDEBUG_TABLE is work space to\n+   hold Huffman tables.  Returns 0 on error, 1 on successful\n+   decompression or if something goes wrong.  In general we try to\n+   carry on, by returning 1, even if we can't decompress.  */\n+\n+static int\n+elf_uncompress_zdebug (struct backtrace_state *state,\n+\t\t       const unsigned char *compressed, size_t compressed_size,\n+\t\t       uint16_t *zdebug_table,\n+\t\t       backtrace_error_callback error_callback, void *data,\n+\t\t       unsigned char **uncompressed, size_t *uncompressed_size)\n+{\n+  size_t sz;\n+  size_t i;\n+  unsigned char *po;\n+\n+  *uncompressed = NULL;\n+  *uncompressed_size = 0;\n+\n+  /* The format starts with the four bytes ZLIB, followed by the 8\n+     byte length of the uncompressed data in big-endian order,\n+     followed by a zlib stream.  */\n+\n+  if (compressed_size < 12 || memcmp (compressed, \"ZLIB\", 4) != 0)\n+    return 1;\n+\n+  sz = 0;\n+  for (i = 0; i < 8; i++)\n+    sz = (sz << 8) | compressed[i + 4];\n+\n+  if (*uncompressed != NULL && *uncompressed_size >= sz)\n+    po = *uncompressed;\n+  else\n+    {\n+      po = (unsigned char *) backtrace_alloc (state, sz, error_callback, data);\n+      if (po == NULL)\n+\treturn 0;\n+    }\n+\n+  if (!elf_zlib_inflate_and_verify (compressed + 12, compressed_size - 12,\n+\t\t\t\t    zdebug_table, po, sz))\n+    return 1;\n+\n+  *uncompressed = po;\n+  *uncompressed_size = sz;\n+\n+  return 1;\n+}\n+\n+/* Uncompress the new compressed debug format, the official standard\n+   ELF approach emitted by --compress-debug-sections=zlib-gabi.  The\n+   compressed data is in COMPRESSED / COMPRESSED_SIZE, and the\n+   function writes to *UNCOMPRESSED / *UNCOMPRESSED_SIZE.\n+   ZDEBUG_TABLE is work space as for elf_uncompress_zdebug.  Returns 0\n+   on error, 1 on successful decompression or if something goes wrong.\n+   In general we try to carry on, by returning 1, even if we can't\n+   decompress.  */\n+\n+static int\n+elf_uncompress_chdr (struct backtrace_state *state,\n+\t\t     const unsigned char *compressed, size_t compressed_size,\n+\t\t     uint16_t *zdebug_table,\n+\t\t     backtrace_error_callback error_callback, void *data,\n+\t\t     unsigned char **uncompressed, size_t *uncompressed_size)\n+{\n+  const b_elf_chdr *chdr;\n+  unsigned char *po;\n+\n+  *uncompressed = NULL;\n+  *uncompressed_size = 0;\n+\n+  /* The format starts with an ELF compression header.  */\n+  if (compressed_size < sizeof (b_elf_chdr))\n+    return 1;\n+\n+  chdr = (const b_elf_chdr *) compressed;\n+\n+  if (chdr->ch_type != ELFCOMPRESS_ZLIB)\n+    {\n+      /* Unsupported compression algorithm.  */\n+      return 1;\n+    }\n+\n+  if (*uncompressed != NULL && *uncompressed_size >= chdr->ch_size)\n+    po = *uncompressed;\n+  else\n+    {\n+      po = (unsigned char *) backtrace_alloc (state, chdr->ch_size,\n+\t\t\t\t\t      error_callback, data);\n+      if (po == NULL)\n+\treturn 0;\n+    }\n+\n+  if (!elf_zlib_inflate_and_verify (compressed + sizeof (b_elf_chdr),\n+\t\t\t\t    compressed_size - sizeof (b_elf_chdr),\n+\t\t\t\t    zdebug_table, po, chdr->ch_size))\n+    return 1;\n+\n+  *uncompressed = po;\n+  *uncompressed_size = chdr->ch_size;\n+\n+  return 1;\n+}\n+\n+/* This function is a hook for testing the zlib support.  It is only\n+   used by tests.  */\n+\n+int\n+backtrace_uncompress_zdebug (struct backtrace_state *state,\n+\t\t\t     const unsigned char *compressed,\n+\t\t\t     size_t compressed_size,\n+\t\t\t     backtrace_error_callback error_callback,\n+\t\t\t     void *data, unsigned char **uncompressed,\n+\t\t\t     size_t *uncompressed_size)\n+{\n+  uint16_t *zdebug_table;\n+  int ret;\n+\n+  zdebug_table = ((uint16_t *) backtrace_alloc (state, ZDEBUG_TABLE_SIZE,\n+\t\t\t\t\t\terror_callback, data));\n+  if (zdebug_table == NULL)\n+    return 0;\n+  ret = elf_uncompress_zdebug (state, compressed, compressed_size,\n+\t\t\t       zdebug_table, error_callback, data,\n+\t\t\t       uncompressed, uncompressed_size);\n+  backtrace_free (state, zdebug_table, ZDEBUG_TABLE_SIZE,\n+\t\t  error_callback, data);\n+  return ret;\n+}\n+\n /* Add the backtrace data for one ELF file.  Returns 1 on success,\n    0 on failure (in both cases descriptor is closed) or -1 if exe\n    is non-zero and the ELF file is ET_DYN, which tells the caller that\n@@ -1011,6 +2548,8 @@ elf_add (struct backtrace_state *state, const char *filename, int descriptor,\n   off_t max_offset;\n   struct backtrace_view debug_view;\n   int debug_view_valid;\n+  unsigned int using_debug_view;\n+  uint16_t *zdebug_table;\n \n   *found_sym = 0;\n   *found_dwarf = 0;\n@@ -1174,6 +2713,7 @@ elf_add (struct backtrace_state *state, const char *filename, int descriptor,\n \t    {\n \t      sections[j].offset = shdr->sh_offset;\n \t      sections[j].size = shdr->sh_size;\n+\t      sections[j].compressed = (shdr->sh_flags & SHF_COMPRESSED) != 0;\n \t      break;\n \t    }\n \t}\n@@ -1284,8 +2824,6 @@ elf_add (struct backtrace_state *state, const char *filename, int descriptor,\n       elf_add_syminfo_data (state, sdata);\n     }\n \n-  /* FIXME: Need to handle compressed debug sections.  */\n-\n   backtrace_release_view (state, &shdrs_view, error_callback, data);\n   shdrs_view_valid = 0;\n   backtrace_release_view (state, &names_view, error_callback, data);\n@@ -1373,13 +2911,94 @@ elf_add (struct backtrace_state *state, const char *filename, int descriptor,\n     goto fail;\n   descriptor = -1;\n \n+  using_debug_view = 0;\n   for (i = 0; i < (int) DEBUG_MAX; ++i)\n     {\n       if (sections[i].size == 0)\n \tsections[i].data = NULL;\n       else\n-\tsections[i].data = ((const unsigned char *) debug_view.data\n-\t\t\t    + (sections[i].offset - min_offset));\n+\t{\n+\t  sections[i].data = ((const unsigned char *) debug_view.data\n+\t\t\t      + (sections[i].offset - min_offset));\n+\t  if (i < ZDEBUG_INFO)\n+\t    ++using_debug_view;\n+\t}\n+    }\n+\n+  /* Uncompress the old format (--compress-debug-sections=zlib-gnu).  */\n+\n+  zdebug_table = NULL;\n+  for (i = 0; i < ZDEBUG_INFO; ++i)\n+    {\n+      struct debug_section_info *pz;\n+\n+      pz = &sections[i + ZDEBUG_INFO - DEBUG_INFO];\n+      if (sections[i].size == 0 && pz->size > 0)\n+\t{\n+\t  unsigned char *uncompressed_data;\n+\t  size_t uncompressed_size;\n+\n+\t  if (zdebug_table == NULL)\n+\t    {\n+\t      zdebug_table = ((uint16_t *)\n+\t\t\t      backtrace_alloc (state, ZDEBUG_TABLE_SIZE,\n+\t\t\t\t\t       error_callback, data));\n+\t      if (zdebug_table == NULL)\n+\t\tgoto fail;\n+\t    }\n+\n+\t  uncompressed_data = NULL;\n+\t  uncompressed_size = 0;\n+\t  if (!elf_uncompress_zdebug (state, pz->data, pz->size, zdebug_table,\n+\t\t\t\t      error_callback, data,\n+\t\t\t\t      &uncompressed_data, &uncompressed_size))\n+\t    goto fail;\n+\t  sections[i].data = uncompressed_data;\n+\t  sections[i].size = uncompressed_size;\n+\t  sections[i].compressed = 0;\n+\t}\n+    }\n+\n+  /* Uncompress the official ELF format\n+     (--compress-debug-sections=zlib-gabi).  */\n+  for (i = 0; i < ZDEBUG_INFO; ++i)\n+    {\n+      unsigned char *uncompressed_data;\n+      size_t uncompressed_size;\n+\n+      if (sections[i].size == 0 || !sections[i].compressed)\n+\tcontinue;\n+\n+      if (zdebug_table == NULL)\n+\t{\n+\t  zdebug_table = ((uint16_t *)\n+\t\t\t  backtrace_alloc (state, ZDEBUG_TABLE_SIZE,\n+\t\t\t\t\t   error_callback, data));\n+\t  if (zdebug_table == NULL)\n+\t    goto fail;\n+\t}\n+\n+      uncompressed_data = NULL;\n+      uncompressed_size = 0;\n+      if (!elf_uncompress_chdr (state, sections[i].data, sections[i].size,\n+\t\t\t\tzdebug_table, error_callback, data,\n+\t\t\t\t&uncompressed_data, &uncompressed_size))\n+\tgoto fail;\n+      sections[i].data = uncompressed_data;\n+      sections[i].size = uncompressed_size;\n+      sections[i].compressed = 0;\n+\n+      --using_debug_view;\n+    }\n+\n+  if (zdebug_table != NULL)\n+    backtrace_free (state, zdebug_table, ZDEBUG_TABLE_SIZE,\n+\t\t    error_callback, data);\n+\n+  if (debug_view_valid && using_debug_view == 0)\n+    {\n+      backtrace_release_view (state, &debug_view, error_callback, data);\n+      debug_view_valid = 0;\n     }\n \n   if (!backtrace_dwarf_add (state, base_address,"}, {"sha": "06179968de34c83db1bdc94c987335556621e492", "filename": "libbacktrace/internal.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da872d9cad373d8e74a75fddf79b36b8b924b38/libbacktrace%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da872d9cad373d8e74a75fddf79b36b8b924b38/libbacktrace%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Finternal.h?ref=8da872d9cad373d8e74a75fddf79b36b8b924b38", "patch": "@@ -292,4 +292,13 @@ extern int backtrace_dwarf_add (struct backtrace_state *state,\n \t\t\t\tbacktrace_error_callback error_callback,\n \t\t\t\tvoid *data, fileline *fileline_fn);\n \n+/* A test-only hook for elf_uncompress_zdebug.  */\n+\n+extern int backtrace_uncompress_zdebug (struct backtrace_state *,\n+\t\t\t\t\tconst unsigned char *compressed,\n+\t\t\t\t\tsize_t compressed_size,\n+\t\t\t\t\tbacktrace_error_callback, void *data,\n+\t\t\t\t\tunsigned char **uncompressed,\n+\t\t\t\t\tsize_t *uncompressed_size);\n+\n #endif"}, {"sha": "103ad65506603c8cba9e922cf885ac6a49b67cee", "filename": "libbacktrace/ztest.c", "status": "added", "additions": 446, "deletions": 0, "changes": 446, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da872d9cad373d8e74a75fddf79b36b8b924b38/libbacktrace%2Fztest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da872d9cad373d8e74a75fddf79b36b8b924b38/libbacktrace%2Fztest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fztest.c?ref=8da872d9cad373d8e74a75fddf79b36b8b924b38", "patch": "@@ -0,0 +1,446 @@\n+/* ztest.c -- Test for libbacktrace inflate code.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer.\n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.\n+\n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <time.h>\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+\n+#ifdef HAVE_ZLIB\n+#include <zlib.h>\n+#endif\n+\n+#include \"backtrace.h\"\n+#include \"backtrace-supported.h\"\n+\n+#include \"internal.h\"\n+#include \"testlib.h\"\n+\n+/* Some tests for the local zlib inflation code.  */\n+\n+struct zlib_test\n+{\n+  const char *name;\n+  const char *uncompressed;\n+  const char *compressed;\n+  size_t compressed_len;\n+};\n+\n+/* Error callback.  */\n+\n+static void\n+error_callback_compress (void *vdata, const char *msg, int errnum)\n+{\n+  fprintf (stderr, \"%s\", msg);\n+  if (errnum > 0)\n+    fprintf (stderr, \": %s\", strerror (errnum));\n+  fprintf (stderr, \"\\n\");\n+  exit (EXIT_FAILURE);\n+}\n+\n+static const struct zlib_test tests[] =\n+{\n+  {\n+    \"empty\",\n+    \"\",\n+    \"\\x78\\x9c\\x03\\x00\\x00\\x00\\x00\\x01\",\n+    8,\n+  },\n+  {\n+    \"hello\",\n+    \"hello, world\\n\",\n+    (\"\\x78\\x9c\\xca\\x48\\xcd\\xc9\\xc9\\xd7\\x51\\x28\\xcf\"\n+     \"\\x2f\\xca\\x49\\xe1\\x02\\x04\\x00\\x00\\xff\\xff\\x21\\xe7\\x04\\x93\"),\n+    25,\n+  },\n+  {\n+    \"goodbye\",\n+    \"goodbye, world\",\n+    (\"\\x78\\x9c\\x4b\\xcf\\xcf\\x4f\\x49\\xaa\"\n+     \"\\x4c\\xd5\\x51\\x28\\xcf\\x2f\\xca\\x49\"\n+     \"\\x01\\x00\\x28\\xa5\\x05\\x5e\"),\n+    22,\n+  }\n+};\n+\n+/* Test the hand coded samples.  */\n+\n+static void\n+test_samples (struct backtrace_state *state)\n+{\n+  size_t i;\n+\n+  for (i = 0; i < sizeof tests / sizeof tests[0]; ++i)\n+    {\n+      char *p;\n+      size_t v;\n+      size_t j;\n+      unsigned char *uncompressed;\n+      size_t uncompressed_len;\n+\n+      p = malloc (12 + tests[i].compressed_len);\n+      memcpy (p, \"ZLIB\", 4);\n+      v = strlen (tests[i].uncompressed);\n+      for (j = 0; j < 8; ++j)\n+\tp[j + 4] = (v >> ((7 - j) * 8)) & 0xff;\n+      memcpy (p + 12, tests[i].compressed, tests[i].compressed_len);\n+      uncompressed = NULL;\n+      uncompressed_len = 0;\n+      if (!backtrace_uncompress_zdebug (state, (unsigned char *) p,\n+\t\t\t\t\ttests[i].compressed_len + 12,\n+\t\t\t\t\terror_callback_compress, NULL,\n+\t\t\t\t\t&uncompressed, &uncompressed_len))\n+\t{\n+\t  fprintf (stderr, \"test %s: uncompress failed\\n\", tests[i].name);\n+\t  ++failures;\n+\t}\n+      else\n+\t{\n+\t  if (uncompressed_len != v)\n+\t    {\n+\t      fprintf (stderr,\n+\t\t       \"test %s: got uncompressed length %zu, want %zu\\n\",\n+\t\t       tests[i].name, uncompressed_len, v);\n+\t      ++failures;\n+\t    }\n+\t  else if (memcmp (tests[i].uncompressed, uncompressed, v) != 0)\n+\t    {\n+\t      size_t j;\n+\n+\t      fprintf (stderr, \"test %s: uncompressed data mismatch\\n\",\n+\t\t       tests[i].name);\n+\t      for (j = 0; j < v; ++j)\n+\t\tif (tests[i].uncompressed[j] != uncompressed[j])\n+\t\t  fprintf (stderr, \"  %zu: got %#x want %#x\\n\", j,\n+\t\t\t   uncompressed[j], tests[i].uncompressed[j]);\n+\t      ++failures;\n+\t    }\n+\t  else\n+\t    printf (\"PASS: inflate %s\\n\", tests[i].name);\n+\n+\t  backtrace_free (state, uncompressed, uncompressed_len,\n+\t\t\t  error_callback_compress, NULL);\n+\t}\n+    }\n+}\n+\n+#ifdef HAVE_ZLIB\n+\n+/* Given a set of TRIALS timings, discard the lowest and highest\n+   values and return the mean average of the rest.  */\n+\n+static size_t\n+average_time (const size_t *times, size_t trials)\n+{\n+  size_t imax;\n+  size_t max;\n+  size_t imin;\n+  size_t min;\n+  size_t i;\n+  size_t sum;\n+\n+  imin = 0;\n+  imax = 0;\n+  min = times[0];\n+  max = times[0];\n+  for (i = 1; i < trials; ++i)\n+    {\n+      if (times[i] < min)\n+\t{\n+\t  imin = i;\n+\t  min = times[i];\n+\t}\n+      if (times[i] > max)\n+\t{\n+\t  imax = i;\n+\t  max = times[i];\n+\t}\n+    }\n+\n+  sum = 0;\n+  for (i = 0; i < trials; ++i)\n+    {\n+      if (i != imax && i != imin)\n+\tsum += times[i];\n+    }\n+  return sum / (trials - 2);\n+}\n+\n+#endif\n+\n+/* Test a larger text, if available.  */\n+\n+static void\n+test_large (struct backtrace_state *state)\n+{\n+#ifdef HAVE_ZLIB\n+  unsigned char *orig_buf;\n+  size_t orig_bufsize;\n+  size_t i;\n+  char *compressed_buf;\n+  size_t compressed_bufsize;\n+  unsigned long compress_sizearg;\n+  unsigned char *uncompressed_buf;\n+  size_t uncompressed_bufsize;\n+  int r;\n+  clockid_t cid;\n+  struct timespec ts1;\n+  struct timespec ts2;\n+  size_t ctime;\n+  size_t ztime;\n+  const size_t trials = 16;\n+  size_t ctimes[16];\n+  size_t ztimes[16];\n+  static const char * const names[] = {\n+    \"Mark.Twain-Tom.Sawyer.txt\",\n+    \"../libgo/go/compress/testdata/Mark.Twain-Tom.Sawyer.txt\"\n+  };\n+\n+  orig_buf = NULL;\n+  orig_bufsize = 0;\n+  uncompressed_buf = NULL;\n+  compressed_buf = NULL;\n+\n+  for (i = 0; i < sizeof names / sizeof names[0]; ++i)\n+    {\n+      size_t len;\n+      char *namebuf;\n+      FILE *e;\n+      struct stat st;\n+      char *rbuf;\n+      size_t got;\n+\n+      len = strlen (SRCDIR) + strlen (names[i]) + 2;\n+      namebuf = malloc (len);\n+      if (namebuf == NULL)\n+\t{\n+\t  perror (\"malloc\");\n+\t  goto fail;\n+\t}\n+      snprintf (namebuf, len, \"%s/%s\", SRCDIR, names[i]);\n+      e = fopen (namebuf, \"r\");\n+      free (namebuf);\n+      if (e == NULL)\n+\tcontinue;\n+      if (fstat (fileno (e), &st) < 0)\n+\t{\n+\t  perror (\"fstat\");\n+\t  fclose (e);\n+\t  continue;\n+\t}\n+      rbuf = malloc (st.st_size);\n+      if (rbuf == NULL)\n+\t{\n+\t  perror (\"malloc\");\n+\t  goto fail;\n+\t}\n+      got = fread (rbuf, 1, st.st_size, e);\n+      fclose (e);\n+      if (got > 0)\n+\t{\n+\t  orig_buf = rbuf;\n+\t  orig_bufsize = got;\n+\t  break;\n+\t}\n+      free (rbuf);\n+    }\n+\n+  if (orig_buf == NULL)\n+    {\n+      /* We couldn't find an input file.  */\n+      printf (\"UNSUPPORTED: inflate large\\n\");\n+      return;\n+    }\n+\n+  compressed_bufsize = compressBound (orig_bufsize) + 12;\n+  compressed_buf = malloc (compressed_bufsize);\n+  if (compressed_buf == NULL)\n+    {\n+      perror (\"malloc\");\n+      goto fail;\n+    }\n+\n+  compress_sizearg = compressed_bufsize - 12;\n+  r = compress (compressed_buf + 12, &compress_sizearg,\n+\t\torig_buf, orig_bufsize);\n+  if (r != Z_OK)\n+    {\n+      fprintf (stderr, \"zlib compress failed: %d\\n\", r);\n+      goto fail;\n+    }\n+\n+  compressed_bufsize = compress_sizearg + 12;\n+\n+  /* Prepare the header that our library expects.  */\n+  memcpy (compressed_buf, \"ZLIB\", 4);\n+  for (i = 0; i < 8; ++i)\n+    compressed_buf[i + 4] = (orig_bufsize >> ((7 - i) * 8)) & 0xff;\n+\n+  uncompressed_buf = malloc (orig_bufsize);\n+  if (uncompressed_buf == NULL)\n+    {\n+      perror (\"malloc\");\n+      goto fail;\n+    }\n+  uncompressed_bufsize = orig_bufsize;\n+\n+  if (!backtrace_uncompress_zdebug (state, compressed_buf, compressed_bufsize,\n+\t\t\t\t    error_callback_compress, NULL,\n+\t\t\t\t    &uncompressed_buf, &uncompressed_bufsize))\n+    {\n+      fprintf (stderr, \"inflate large: backtrace_uncompress_zdebug failed\\n\");\n+      goto fail;\n+    }\n+\n+  if (uncompressed_bufsize != orig_bufsize)\n+    {\n+      fprintf (stderr,\n+\t       \"inflate large: got uncompressed length %zu, want %zu\\n\",\n+\t       uncompressed_bufsize, orig_bufsize);\n+      goto fail;\n+    }\n+\n+  if (memcmp (uncompressed_buf, orig_buf, uncompressed_bufsize) != 0)\n+    {\n+      fprintf (stderr, \"inflate large: uncompressed data mismatch\\n\");\n+      goto fail;\n+    }\n+\n+  printf (\"PASS: inflate large\\n\");\n+\n+  for (i = 0; i < trials; ++i)\n+    {\n+      cid = CLOCK_REALTIME;\n+#ifdef CLOCK_PROCESS_CPUTIME_ID\n+      cid = CLOCK_PROCESS_CPUTIME_ID;\n+#endif\n+      if (clock_gettime (cid, &ts1) < 0)\n+\t{\n+\t  perror (\"clock_gettime\");\n+\t  return;\n+\t}\n+\n+      if (!backtrace_uncompress_zdebug (state, compressed_buf,\n+\t\t\t\t\tcompressed_bufsize,\n+\t\t\t\t\terror_callback_compress, NULL,\n+\t\t\t\t\t&uncompressed_buf,\n+\t\t\t\t\t&uncompressed_bufsize))\n+\t{\n+\t  fprintf (stderr,\n+\t\t   (\"inflate large: \"\n+\t\t    \"benchmark backtrace_uncompress_zdebug failed\\n\"));\n+\t  return;\n+\t}\n+\n+      if (clock_gettime (cid, &ts2) < 0)\n+\t{\n+\t  perror (\"clock_gettime\");\n+\t  return;\n+\t}\n+\n+      ctime = (ts2.tv_sec - ts1.tv_sec) * 1000000000;\n+      ctime += ts2.tv_nsec - ts1.tv_nsec;\n+      ctimes[i] = ctime;\n+\n+      if (clock_gettime (cid, &ts1) < 0)\n+\t{\n+\t  perror(\"clock_gettime\");\n+\t  return;\n+\t}\n+\n+      r = uncompress (uncompressed_buf, &uncompressed_bufsize,\n+\t\t      compressed_buf + 12, compressed_bufsize - 12);\n+\n+      if (clock_gettime (cid, &ts2) < 0)\n+\t{\n+\t  perror (\"clock_gettime\");\n+\t  return;\n+\t}\n+\n+      if (r != Z_OK)\n+\t{\n+\t  fprintf (stderr,\n+\t\t   \"inflate large: benchmark zlib uncompress failed: %d\\n\",\n+\t\t   r);\n+\t  return;\n+\t}\n+\n+      ztime = (ts2.tv_sec - ts1.tv_sec) * 1000000000;\n+      ztime += ts2.tv_nsec - ts1.tv_nsec;\n+      ztimes[i] = ztime;\n+    }\n+\n+  /* Toss the highest and lowest times and average the rest.  */\n+  ctime = average_time (ctimes, trials);\n+  ztime = average_time (ztimes, trials);\n+\n+  printf (\"backtrace time: %zu ns\\n\", ctime);\n+  printf (\"zlib time:    : %zu ns\\n\", ztime);\n+  printf (\"percentage    : %g\\n\", (double) ztime / (double) ctime);\n+\n+  return;\n+\n+ fail:\n+  printf (\"FAIL: inflate large\\n\");\n+  ++failures;\n+\n+  if (orig_buf != NULL)\n+    free (orig_buf);\n+  if (compressed_buf != NULL)\n+    free (compressed_buf);\n+  if (uncompressed_buf != NULL)\n+    free (uncompressed_buf);\n+\n+#else /* !HAVE_ZLIB */\n+\n+ printf (\"UNSUPPORTED: inflate large\\n\");\n+\n+#endif /* !HAVE_ZLIB */\n+}\n+\n+int\n+main (int argc ATTRIBUTE_UNUSED, char **argv)\n+{\n+  struct backtrace_state *state;\n+\n+  state = backtrace_create_state (argv[0], BACKTRACE_SUPPORTS_THREADS,\n+\t\t\t\t  error_callback_create, NULL);\n+\n+  test_samples (state);\n+  test_large (state);\n+\n+  exit (failures != 0 ? EXIT_FAILURE : EXIT_SUCCESS);\n+}"}]}