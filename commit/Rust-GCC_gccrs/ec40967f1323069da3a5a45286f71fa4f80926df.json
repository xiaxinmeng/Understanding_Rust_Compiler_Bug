{"sha": "ec40967f1323069da3a5a45286f71fa4f80926df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWM0MDk2N2YxMzIzMDY5ZGEzYTVhNDUyODZmNzFmYTRmODA5MjZkZg==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-05-04T12:34:23Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-05-04T12:37:31Z"}, "message": "libstdc++: Make pmr::synchronized_pool_resource work without libpthread (PR 94936)\n\nI implicitly assumed that programs using pmr::synchronized_pool_resource\nwould also be using multiple threads, and so the weak symbols in\ngthr-posix.h would be resolved by linking to libpthread. If that isn't\ntrue then it crashes when trying to use pthread_key_create.\n\nThis commit makes the pool resource check __gthread_active_p() before\nusing thread-specific data, and just use a single set of memory pools\nwhen there's only a single thread.\n\n\tPR libstdc++/94936\n\t* src/c++17/memory_resource.cc (synchronized_pool_resource::_TPools):\n\tAdd comment about single-threaded behaviour.\n\t(synchronized_pool_resource::_TPools::move_nonempty_chunks()): Hoist\n\tclass member access out of loop.\n\t(synchronized_pool_resource::synchronized_pool_resource())\n\t(synchronized_pool_resource::~synchronized_pool_resource())\n\t(synchronized_pool_resource::release()): Check __gthread_active_p\n\tbefore creating and/or deleting the thread-specific data key.\n\t(synchronized_pool_resource::_M_thread_specific_pools()): Adjust\n\tassertions.\n\t(synchronized_pool_resource::do_allocate(size_t, size_t)): Add fast\n\tpath for single-threaded case.\n\t(synchronized_pool_resource::do_deallocate(void*, size_t, size_t)):\n\tLikewise. Return if unable to find a pool that owns the allocation.\n\t* testsuite/20_util/synchronized_pool_resource/allocate_single.cc:\n\tNew test.\n\t* testsuite/20_util/synchronized_pool_resource/cons_single.cc: New\n\ttest.\n\t* testsuite/20_util/synchronized_pool_resource/release_single.cc: New\n\ttest.", "tree": {"sha": "6f9c1c6e4015570d63161c8aa85461487135bd5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f9c1c6e4015570d63161c8aa85461487135bd5f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec40967f1323069da3a5a45286f71fa4f80926df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec40967f1323069da3a5a45286f71fa4f80926df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec40967f1323069da3a5a45286f71fa4f80926df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec40967f1323069da3a5a45286f71fa4f80926df/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9e1ea10e657af9fb02fafecf1a600740fd34409", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9e1ea10e657af9fb02fafecf1a600740fd34409", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9e1ea10e657af9fb02fafecf1a600740fd34409"}], "stats": {"total": 223, "additions": 179, "deletions": 44}, "files": [{"sha": "0624bb733ddec2b89adedc29aa3969ee87196816", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec40967f1323069da3a5a45286f71fa4f80926df/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec40967f1323069da3a5a45286f71fa4f80926df/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=ec40967f1323069da3a5a45286f71fa4f80926df", "patch": "@@ -1,3 +1,27 @@\n+2020-05-04  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\tPR libstdc++/94936\n+\t* src/c++17/memory_resource.cc (synchronized_pool_resource::_TPools):\n+\tAdd comment about single-threaded behaviour.\n+\t(synchronized_pool_resource::_TPools::move_nonempty_chunks()): Hoist\n+\tclass member access out of loop.\n+\t(synchronized_pool_resource::synchronized_pool_resource())\n+\t(synchronized_pool_resource::~synchronized_pool_resource())\n+\t(synchronized_pool_resource::release()): Check __gthread_active_p\n+\tbefore creating and/or deleting the thread-specific data key.\n+\t(synchronized_pool_resource::_M_thread_specific_pools()): Adjust\n+\tassertions.\n+\t(synchronized_pool_resource::do_allocate(size_t, size_t)): Add fast\n+\tpath for single-threaded case.\n+\t(synchronized_pool_resource::do_deallocate(void*, size_t, size_t)):\n+\tLikewise. Return if unable to find a pool that owns the allocation.\n+\t* testsuite/20_util/synchronized_pool_resource/allocate_single.cc:\n+\tNew test.\n+\t* testsuite/20_util/synchronized_pool_resource/cons_single.cc: New\n+\ttest.\n+\t* testsuite/20_util/synchronized_pool_resource/release_single.cc: New\n+\ttest.\n+\n 2020-05-03  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR libstdc++/94933"}, {"sha": "1acab19e306047ab19b2e375951e5869c12d8426", "filename": "libstdc++-v3/src/c++17/memory_resource.cc", "status": "modified", "additions": 83, "deletions": 44, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec40967f1323069da3a5a45286f71fa4f80926df/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fmemory_resource.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec40967f1323069da3a5a45286f71fa4f80926df/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fmemory_resource.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fmemory_resource.cc?ref=ec40967f1323069da3a5a45286f71fa4f80926df", "patch": "@@ -1043,7 +1043,8 @@ namespace pmr\n    * exposition as _M_tpools[_M_key]).\n    * The first element, _M_tpools[0], contains \"orphaned chunks\" which were\n    * allocated by a thread which has since exited, and so there is no\n-   * _M_tpools[_M_key] for that thread.\n+   * _M_tpools[_M_key] for that thread. Orphaned chunks are never reused,\n+   * they're only held in _M_tpools[0] so they can be deallocated.\n    * A thread can access its own thread-specific set of pools via _M_key\n    * while holding a shared lock on _M_mx. Accessing _M_impl._M_unpooled\n    * or _M_tpools[0] or any other thread's _M_tpools[_M_key] requires an\n@@ -1052,6 +1053,10 @@ namespace pmr\n    * any dereference of that pointer requires an exclusive lock.\n    * The _M_impl._M_opts and _M_impl._M_npools members are immutable,\n    * and can safely be accessed concurrently.\n+   *\n+   * In a single-threaded program (i.e. __gthread_active_p() == false)\n+   * the pool resource only needs one set of pools and never has orphaned\n+   * chunks, so just uses _M_tpools[0] directly, and _M_tpools->next is null.\n    */\n \n   extern \"C\" {\n@@ -1092,14 +1097,16 @@ namespace pmr\n     void move_nonempty_chunks()\n     {\n       __glibcxx_assert(pools);\n+      __glibcxx_assert(__gthread_active_p());\n       if (!pools)\n \treturn;\n-      memory_resource* r = owner.upstream_resource();\n+      memory_resource* const r = owner.upstream_resource();\n+      auto* const shared = owner._M_tpools->pools;\n       // move all non-empty chunks to the shared _TPools\n       for (int i = 0; i < owner._M_impl._M_npools; ++i)\n \tfor (auto& c : pools[i]._M_chunks)\n \t  if (!c.empty())\n-\t    owner._M_tpools->pools[i]._M_chunks.insert(std::move(c), r);\n+\t    shared[i]._M_chunks.insert(std::move(c), r);\n     }\n \n     synchronized_pool_resource& owner;\n@@ -1133,8 +1140,9 @@ namespace pmr\n \t\t\t     memory_resource* upstream)\n   : _M_impl(opts, upstream)\n   {\n-    if (int err = __gthread_key_create(&_M_key, destroy_TPools))\n-      __throw_system_error(err);\n+    if (__gthread_active_p())\n+      if (int err = __gthread_key_create(&_M_key, destroy_TPools))\n+\t__throw_system_error(err);\n     exclusive_lock l(_M_mx);\n     _M_tpools = _M_alloc_shared_tpools(l);\n   }\n@@ -1143,7 +1151,8 @@ namespace pmr\n   synchronized_pool_resource::~synchronized_pool_resource()\n   {\n     release();\n-    __gthread_key_delete(_M_key); // does not run destroy_TPools\n+    if (__gthread_active_p())\n+      __gthread_key_delete(_M_key); // does not run destroy_TPools\n   }\n \n   void\n@@ -1152,8 +1161,11 @@ namespace pmr\n     exclusive_lock l(_M_mx);\n     if (_M_tpools)\n       {\n-\t__gthread_key_delete(_M_key); // does not run destroy_TPools\n-\t__gthread_key_create(&_M_key, destroy_TPools);\n+\tif (__gthread_active_p())\n+\t  {\n+\t    __gthread_key_delete(_M_key); // does not run destroy_TPools\n+\t    __gthread_key_create(&_M_key, destroy_TPools);\n+\t  }\n \tpolymorphic_allocator<_TPools> a(upstream_resource());\n \t// destroy+deallocate each _TPools\n \tdo\n@@ -1175,10 +1187,11 @@ namespace pmr\n   synchronized_pool_resource::_M_thread_specific_pools() noexcept\n   {\n     __pool_resource::_Pool* pools = nullptr;\n+    __glibcxx_assert(__gthread_active_p());\n     if (auto tp = static_cast<_TPools*>(__gthread_getspecific(_M_key)))\n       {\n-      pools = tp->pools;\n-      __glibcxx_assert(tp->pools);\n+\tpools = tp->pools;\n+\t// __glibcxx_assert(tp->pools);\n       }\n     return pools;\n   }\n@@ -1189,32 +1202,42 @@ namespace pmr\n   do_allocate(size_t bytes, size_t alignment)\n   {\n     const auto block_size = std::max(bytes, alignment);\n-    if (block_size <= _M_impl._M_opts.largest_required_pool_block)\n+    const pool_options opts = _M_impl._M_opts;\n+    if (block_size <= opts.largest_required_pool_block)\n       {\n \tconst ptrdiff_t index = pool_index(block_size, _M_impl._M_npools);\n-\tmemory_resource* const r = upstream_resource();\n-\tconst pool_options opts = _M_impl._M_opts;\n-\t{\n-\t  // Try to allocate from the thread-specific pool\n-\t  shared_lock l(_M_mx);\n-\t  if (auto pools = _M_thread_specific_pools()) // [[likely]]\n-\t    {\n-\t      // Need exclusive lock to replenish so use try_allocate:\n-\t      if (void* p = pools[index].try_allocate())\n-\t\treturn p;\n-\t      // Need to take exclusive lock and replenish pool.\n-\t    }\n-\t  // Need to allocate or replenish thread-specific pools using\n-\t  // upstream resource, so need to hold exclusive lock.\n-\t}\n+\tif (__gthread_active_p())\n+\t  {\n+\t    // Try to allocate from the thread-specific pool.\n+\t    shared_lock l(_M_mx);\n+\t    if (auto pools = _M_thread_specific_pools()) // [[likely]]\n+\t      {\n+\t\t// Need exclusive lock to replenish so use try_allocate:\n+\t\tif (void* p = pools[index].try_allocate())\n+\t\t  return p;\n+\t\t// Need to take exclusive lock and replenish pool.\n+\t      }\n+\t    // Need to allocate or replenish thread-specific pools using\n+\t    // upstream resource, so need to hold exclusive lock.\n+\t  }\n+\telse // single-threaded\n+\t  {\n+\t    if (!_M_tpools) // [[unlikely]]\n+\t      {\n+\t\texclusive_lock dummy(_M_mx);\n+\t\t_M_tpools = _M_alloc_shared_tpools(dummy);\n+\t      }\n+\t    return _M_tpools->pools[index].allocate(upstream_resource(), opts);\n+\t  }\n+\n \t// N.B. Another thread could call release() now lock is not held.\n \texclusive_lock excl(_M_mx);\n \tif (!_M_tpools) // [[unlikely]]\n \t  _M_tpools = _M_alloc_shared_tpools(excl);\n \tauto pools = _M_thread_specific_pools();\n \tif (!pools)\n \t  pools = _M_alloc_tpools(excl)->pools;\n-\treturn pools[index].allocate(r, opts);\n+\treturn pools[index].allocate(upstream_resource(), opts);\n       }\n     exclusive_lock l(_M_mx);\n     return _M_impl.allocate(bytes, alignment); // unpooled allocation\n@@ -1230,30 +1253,45 @@ namespace pmr\n       {\n \tconst ptrdiff_t index = pool_index(block_size, _M_impl._M_npools);\n \t__glibcxx_assert(index != -1);\n-\t{\n-\t  shared_lock l(_M_mx);\n-\t  auto pools = _M_thread_specific_pools();\n-\t  if (pools)\n-\t    {\n-\t      // No need to lock here, no other thread is accessing this pool.\n-\t      if (pools[index].deallocate(upstream_resource(), p))\n-\t\treturn;\n-\t    }\n-\t  // Block might have come from a different thread's pool,\n-\t  // take exclusive lock and check every pool.\n-\t}\n+\tif (__gthread_active_p())\n+\t  {\n+\t    shared_lock l(_M_mx);\n+\t    if (auto pools = _M_thread_specific_pools())\n+\t      {\n+\t\t// No need to lock here, no other thread is accessing this pool.\n+\t\tif (pools[index].deallocate(upstream_resource(), p))\n+\t\t  return;\n+\t      }\n+\t    // Block might have come from a different thread's pool,\n+\t    // take exclusive lock and check every pool.\n+\t  }\n+\telse // single-threaded\n+\t  {\n+\t    __glibcxx_assert(_M_tpools != nullptr);\n+\t    if (_M_tpools) // [[likely]]\n+\t      _M_tpools->pools[index].deallocate(upstream_resource(), p);\n+\t    return;\n+\t  }\n+\n \t// TODO store {p, bytes, alignment} somewhere and defer returning\n \t// the block to the correct thread-specific pool until we next\n \t// take the exclusive lock.\n+\n \texclusive_lock excl(_M_mx);\n+\tauto my_pools = _M_thread_specific_pools();\n \tfor (_TPools* t = _M_tpools; t != nullptr; t = t->next)\n \t  {\n-\t    if (t->pools) // [[likely]]\n-\t      {\n-\t\tif (t->pools[index].deallocate(upstream_resource(), p))\n-\t\t  return;\n-\t      }\n+\t    if (t->pools != my_pools)\n+\t      if (t->pools) // [[likely]]\n+\t\t{\n+\t\t  if (t->pools[index].deallocate(upstream_resource(), p))\n+\t\t    return;\n+\t\t}\n \t  }\n+\t// Not necessarily an error to reach here, release() could have been\n+\t// called on another thread between releasing the shared lock and\n+\t// acquiring the exclusive lock.\n+\treturn;\n       }\n     exclusive_lock l(_M_mx);\n     _M_impl.deallocate(p, bytes, alignment);\n@@ -1265,6 +1303,7 @@ namespace pmr\n   -> _TPools*\n   {\n     __glibcxx_assert(_M_tpools != nullptr);\n+    __glibcxx_assert(__gthread_active_p());\n     // dump_list(_M_tpools);\n     polymorphic_allocator<_TPools> a(upstream_resource());\n     _TPools* p = a.allocate(1);"}, {"sha": "d5b7b1621462dd1672992ba994ff06d783a8a81b", "filename": "libstdc++-v3/testsuite/20_util/synchronized_pool_resource/allocate_single.cc", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec40967f1323069da3a5a45286f71fa4f80926df/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fsynchronized_pool_resource%2Fallocate_single.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec40967f1323069da3a5a45286f71fa4f80926df/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fsynchronized_pool_resource%2Fallocate_single.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fsynchronized_pool_resource%2Fallocate_single.cc?ref=ec40967f1323069da3a5a45286f71fa4f80926df", "patch": "@@ -0,0 +1,24 @@\n+// Copyright (C) 2018-2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run }\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-require-effective-target c++17 }\n+// { dg-require-gthreads \"\" }\n+\n+// This runs the same tests as allocate.cc but without -pthread\n+#include \"./allocate.cc\""}, {"sha": "060cd7628e5ede920ac8120f93eab85d87c2fdfe", "filename": "libstdc++-v3/testsuite/20_util/synchronized_pool_resource/cons_single.cc", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec40967f1323069da3a5a45286f71fa4f80926df/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fsynchronized_pool_resource%2Fcons_single.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec40967f1323069da3a5a45286f71fa4f80926df/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fsynchronized_pool_resource%2Fcons_single.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fsynchronized_pool_resource%2Fcons_single.cc?ref=ec40967f1323069da3a5a45286f71fa4f80926df", "patch": "@@ -0,0 +1,24 @@\n+// Copyright (C) 2018-2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run }\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-require-effective-target c++17 }\n+// { dg-require-gthreads \"\" }\n+\n+// This runs the same tests as cons.cc but without -pthread\n+#include \"./cons.cc\""}, {"sha": "32e80c1be3f73e6b74b3e3b70c7cb85310c07f81", "filename": "libstdc++-v3/testsuite/20_util/synchronized_pool_resource/release_single.cc", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec40967f1323069da3a5a45286f71fa4f80926df/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fsynchronized_pool_resource%2Frelease_single.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec40967f1323069da3a5a45286f71fa4f80926df/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fsynchronized_pool_resource%2Frelease_single.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fsynchronized_pool_resource%2Frelease_single.cc?ref=ec40967f1323069da3a5a45286f71fa4f80926df", "patch": "@@ -0,0 +1,24 @@\n+// Copyright (C) 2018-2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run }\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-require-effective-target c++17 }\n+// { dg-require-gthreads \"\" }\n+\n+// This runs the same tests as release.cc but without -pthread\n+#include \"./release.cc\""}]}