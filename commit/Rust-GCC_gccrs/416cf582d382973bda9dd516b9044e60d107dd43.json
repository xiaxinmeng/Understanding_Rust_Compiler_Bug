{"sha": "416cf582d382973bda9dd516b9044e60d107dd43", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDE2Y2Y1ODJkMzgyOTczYmRhOWRkNTE2YjkwNDRlNjBkMTA3ZGQ0Mw==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2003-08-23T00:17:35Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2003-08-23T00:17:35Z"}, "message": "s390-protos.h (s390_output_pool_entry): Declare.\n\n\t* config/s390/s390-protos.h (s390_output_pool_entry): Declare.\n\t* config/s390/s390.c (gen_consttable): Remove.\n\t(s390_dump_pool): Use UNSPECV_POOL_ENTRY for pool entry insns.\n\t(s390_output_pool_entry): New function.\n\t* config/s390/s390.md (UNSPECV_POOL_QI, UNSPECV_POOL_HI,\n\tUNSPECV_POOL_SI, UNSPECV_POOL_DI, UNSPECV_POOL_TI,\n\tUNSPECV_POOL_SF, UNSPECV_POOL_DF): Remove, replace by ...\n\t(UNSPECV_POOL_ENTRY): ... this new constant.\n\t(\"consttable_qi\", \"consttable_hi\", \"consttable_si\", \"consttable_di\",\n\t\"consttable_ti\", \"consttable_sf\", \"consttable_df\"): Remove ...\n\t(\"*pool_entry\"): ... and replace by this new insn.\n\t(\"literal_pool_31\"): Do not emit anchor label if pool empty.\n\n\t* config/s390/s390.c (struct machine_function): Add save_return_addr_p.\n\t(s390_optimize_prolog): Save RETURN_REGNUM if save_return_addr_p.\n\t(s390_fixup_clobbered_return_reg): Remove.\n\t(s390_reorg): Don't call s390_fixup_clobbered_return_reg.\n\t(s390_return_addr_rtx): Always retrieve return address from save area\n\tslot.  Use save_return_addr_p to force slot to be filled.\n\t(s390_emit_prologue): Remove has_hard_reg_initial_val test.\n\nFrom-SVN: r70714", "tree": {"sha": "38bcf08d7c2ad37558a5a82bec5bdd21862c3f61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/38bcf08d7c2ad37558a5a82bec5bdd21862c3f61"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/416cf582d382973bda9dd516b9044e60d107dd43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/416cf582d382973bda9dd516b9044e60d107dd43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/416cf582d382973bda9dd516b9044e60d107dd43", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/416cf582d382973bda9dd516b9044e60d107dd43/comments", "author": null, "committer": null, "parents": [{"sha": "27a9da797e245696cf705795f81b20602e884792", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27a9da797e245696cf705795f81b20602e884792", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27a9da797e245696cf705795f81b20602e884792"}], "stats": {"total": 270, "additions": 93, "deletions": 177}, "files": [{"sha": "cc8bd095b276f1f11debc12b7c0b3c0dc0ff30ea", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416cf582d382973bda9dd516b9044e60d107dd43/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416cf582d382973bda9dd516b9044e60d107dd43/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=416cf582d382973bda9dd516b9044e60d107dd43", "patch": "@@ -1,3 +1,26 @@\n+2003-08-23  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* config/s390/s390-protos.h (s390_output_pool_entry): Declare.\n+\t* config/s390/s390.c (gen_consttable): Remove.\n+\t(s390_dump_pool): Use UNSPECV_POOL_ENTRY for pool entry insns.\n+\t(s390_output_pool_entry): New function.\n+\t* config/s390/s390.md (UNSPECV_POOL_QI, UNSPECV_POOL_HI, \n+\tUNSPECV_POOL_SI, UNSPECV_POOL_DI, UNSPECV_POOL_TI, \n+\tUNSPECV_POOL_SF, UNSPECV_POOL_DF): Remove, replace by ...\n+\t(UNSPECV_POOL_ENTRY): ... this new constant.\n+\t(\"consttable_qi\", \"consttable_hi\", \"consttable_si\", \"consttable_di\",\n+\t\"consttable_ti\", \"consttable_sf\", \"consttable_df\"): Remove ...\n+\t(\"*pool_entry\"): ... and replace by this new insn.\n+\t(\"literal_pool_31\"): Do not emit anchor label if pool empty.\n+\n+\t* config/s390/s390.c (struct machine_function): Add save_return_addr_p.\n+\t(s390_optimize_prolog): Save RETURN_REGNUM if save_return_addr_p.\n+\t(s390_fixup_clobbered_return_reg): Remove.\n+\t(s390_reorg): Don't call s390_fixup_clobbered_return_reg.\n+\t(s390_return_addr_rtx): Always retrieve return address from save area\n+\tslot.  Use save_return_addr_p to force slot to be filled.\n+\t(s390_emit_prologue): Remove has_hard_reg_initial_val test.\n+\n 2003-08-22  Chris Demetriou  <cgd@broadcom.com>\n \n \t* config/mips/mips.h (MASK_FIX_SB1, TARGET_FIX_SB1): New defines."}, {"sha": "40026d3b85f66b056e3364c56be2ab9e416c7e13", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416cf582d382973bda9dd516b9044e60d107dd43/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416cf582d382973bda9dd516b9044e60d107dd43/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=416cf582d382973bda9dd516b9044e60d107dd43", "patch": "@@ -80,6 +80,8 @@ extern void s390_output_symbolic_const (FILE *, rtx);\n extern void print_operand_address (FILE *, rtx);\n extern void print_operand (FILE *, rtx, int);\n extern void s390_output_constant_pool (rtx, rtx);\n+extern void s390_output_pool_entry (FILE *, rtx, enum machine_mode, \n+\t\t\t\t    unsigned int);\n extern void s390_trampoline_template (FILE *);\n extern void s390_initialize_trampoline (rtx, rtx, rtx);\n extern rtx s390_gen_rtx_const_DI (int, int);"}, {"sha": "568a35b888e6c8f7373f5c37f9490acae27096a1", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 58, "deletions": 86, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416cf582d382973bda9dd516b9044e60d107dd43/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416cf582d382973bda9dd516b9044e60d107dd43/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=416cf582d382973bda9dd516b9044e60d107dd43", "patch": "@@ -189,6 +189,10 @@ struct machine_function GTY(())\n   /* Set, if some of the fprs 8-15 need to be saved (64 bit abi).  */\n   int save_fprs_p;\n \n+  /* Set if return address needs to be saved because the current\n+     function uses __builtin_return_addr (0).  */\n+  bool save_return_addr_p;\n+\n   /* Number of first and last gpr to be saved, restored.  */\n   int first_save_gpr;\n   int first_restore_gpr;\n@@ -220,7 +224,6 @@ static void replace_constant_pool_ref (rtx *, rtx, rtx);\n static rtx find_ltrel_base (rtx);\n static void replace_ltrel_base (rtx *, rtx);\n static void s390_optimize_prolog (int);\n-static bool s390_fixup_clobbered_return_reg (rtx);\n static int find_unused_clobbered_reg (void);\n static void s390_frame_info (void);\n static rtx save_fpr (rtx, int, int);\n@@ -4049,11 +4052,6 @@ enum machine_mode constant_modes[NR_C_MODES] =\n   QImode\n };\n \n-rtx (*gen_consttable[NR_C_MODES])(rtx) =\n-{\n-  gen_consttable_ti, gen_consttable_df, gen_consttable_di, gen_consttable_sf, gen_consttable_si, gen_consttable_hi, gen_consttable_qi\n-};\n-\n struct constant\n {\n   struct constant *next;\n@@ -4249,7 +4247,11 @@ s390_dump_pool (struct constant_pool *pool)\n \n \tinsn = emit_label_after (c->label, insn);\n \tINSN_ADDRESSES_NEW (insn, -1);\n-\tinsn = emit_insn_after (gen_consttable[i] (value), insn);\n+\n+\tvalue = gen_rtx_UNSPEC_VOLATILE (constant_modes[i], \n+\t\t\t\t\t gen_rtvec (1, value),\n+\t\t\t\t\t UNSPECV_POOL_ENTRY);\n+\tinsn = emit_insn_after (value, insn);\n \tINSN_ADDRESSES_NEW (insn, -1);\n       }\n \n@@ -4717,6 +4719,46 @@ s390_output_constant_pool (rtx start_label, rtx end_label)\n     }\n }\n \n+/* Output to FILE the constant pool entry EXP in mode MODE\n+   with alignment ALIGN.  */\n+\n+void\n+s390_output_pool_entry (FILE *file, rtx exp, enum machine_mode mode, \n+\t\t\tunsigned int align)\n+{\n+  REAL_VALUE_TYPE r;\n+\n+  switch (GET_MODE_CLASS (mode))\n+    {\n+    case MODE_FLOAT:\n+      if (GET_CODE (exp) != CONST_DOUBLE)\n+\tabort ();\n+\n+      REAL_VALUE_FROM_CONST_DOUBLE (r, exp);\n+      assemble_real (r, mode, align);\n+      break;\n+\n+    case MODE_INT:\n+      if (GET_CODE (exp) == CONST\n+\t  || GET_CODE (exp) == SYMBOL_REF\n+\t  || GET_CODE (exp) == LABEL_REF)\n+\t{\n+\t  fputs (integer_asm_op (GET_MODE_SIZE (mode), TRUE), file);\n+\t  s390_output_symbolic_const (file, exp);\n+\t  fputc ('\\n', file);\n+\t}\n+      else\n+\t{\n+\t  assemble_integer (exp, GET_MODE_SIZE (mode), align, 1);\n+\t}\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+}\n+\n+\n /* Rework the prolog/epilog to avoid saving/restoring\n    registers unnecessarily.  If TEMP_REGNO is nonnegative,\n    it specifies the number of a caller-saved register used\n@@ -4742,8 +4784,11 @@ s390_optimize_prolog (int temp_regno)\n     regs_ever_live[BASE_REGISTER] = 1;\n \n   /* In non-leaf functions, the prolog/epilog code relies\n-     on RETURN_REGNUM being saved in any case.  */\n-  if (!current_function_is_leaf)\n+     on RETURN_REGNUM being saved in any case.  We also need\n+     to save the return register if __builtin_return_address (0)\n+     was used in the current function.  */\n+  if (!current_function_is_leaf \n+      || cfun->machine->save_return_addr_p)\n     regs_ever_live[RETURN_REGNUM] = 1;\n \n   /* We need to save/restore the temporary register.  */\n@@ -4868,68 +4913,11 @@ s390_optimize_prolog (int temp_regno)\n     }\n }\n \n-/* Check whether any insn in the function makes use of the original\n-   value of RETURN_REG (e.g. for __builtin_return_address).\n-   If so, insert an insn reloading that value.\n-\n-   Return true if any such insn was found.  */\n-\n-static bool\n-s390_fixup_clobbered_return_reg (rtx return_reg)\n-{\n-  bool replacement_done = 0;\n-  rtx insn;\n-\n-  /* If we never called __builtin_return_address, register 14\n-     might have been used as temp during the prolog; we do\n-     not want to touch those uses.  */\n-  if (!has_hard_reg_initial_val (Pmode, REGNO (return_reg)))\n-    return false;\n-\n-  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-    {\n-      rtx reg, off, new_insn;\n-\n-      if (GET_CODE (insn) != INSN)\n-\tcontinue;\n-      if (!reg_referenced_p (return_reg, PATTERN (insn)))\n-\tcontinue;\n-      if (GET_CODE (PATTERN (insn)) == PARALLEL\n-\t  && store_multiple_operation (PATTERN (insn), VOIDmode))\n-\tcontinue;\n-\n-      if (frame_pointer_needed)\n-\treg = hard_frame_pointer_rtx;\n-      else\n-\treg = stack_pointer_rtx;\n-\n-      off = GEN_INT (cfun->machine->frame_size + REGNO (return_reg) * UNITS_PER_WORD);\n-      if (!DISP_IN_RANGE (INTVAL (off)))\n-\t{\n-\t  off = force_const_mem (Pmode, off);\n-\t  new_insn = gen_rtx_SET (Pmode, return_reg, off);\n-\t  new_insn = emit_insn_before (new_insn, insn);\n-\t  INSN_ADDRESSES_NEW (new_insn, -1);\n-\t  off = return_reg;\n-\t}\n-\n-      new_insn = gen_rtx_MEM (Pmode, gen_rtx_PLUS (Pmode, reg, off));\n-      new_insn = gen_rtx_SET (Pmode, return_reg, new_insn);\n-      new_insn = emit_insn_before (new_insn, insn);\n-      INSN_ADDRESSES_NEW (new_insn, -1);\n-\n-      replacement_done = 1;\n-    }\n-\n-  return replacement_done;\n-}\n-\n /* Perform machine-dependent processing.  */\n \n static void\n s390_reorg (void)\n {\n-  bool fixed_up_clobbered_return_reg = 0;\n   rtx temp_reg = gen_rtx_REG (Pmode, RETURN_REGNUM);\n   bool temp_used = 0;\n \n@@ -4985,21 +4973,6 @@ s390_reorg (void)\n           continue;\n         }\n \n-      /* Check whether we have clobbered a use of the return\n-\t register (e.g. for __builtin_return_address).  If so,\n-\t add insns reloading the register where necessary.  */\n-      if (temp_used && !fixed_up_clobbered_return_reg\n-\t  && s390_fixup_clobbered_return_reg (temp_reg))\n-\t{\n-\t  fixed_up_clobbered_return_reg = 1;\n-\n-\t  /* The fixup insns might have caused a jump to overflow.  */\n-\t  if (pool_list)\n-\t    s390_chunkify_cancel (pool_list);\n-\n-\t  continue;\n-\t}\n-\n       /* If we made it up to here, both conditions are satisfied.\n \t Finish up pool chunkification if required.  */\n       if (pool_list)\n@@ -5021,13 +4994,13 @@ s390_return_addr_rtx (int count, rtx frame)\n {\n   rtx addr;\n \n-  /* For the current frame, we use the initial value of RETURN_REGNUM.\n-     This works both in leaf and non-leaf functions.  */\n+  /* For the current frame, we need to make sure the initial\n+     value of RETURN_REGNUM is actually saved.  */\n \n   if (count == 0)\n-    return get_hard_reg_initial_val (Pmode, RETURN_REGNUM);\n+    cfun->machine->save_return_addr_p = true;\n \n-  /* For frames farther back, we read the stack slot where the\n+  /* To retrieve the return address we read the stack slot where the\n      corresponding RETURN_REGNUM value was saved.  */\n \n   addr = plus_constant (frame, RETURN_REGNUM * UNITS_PER_WORD);\n@@ -5343,7 +5316,6 @@ s390_emit_prologue (void)\n      See below for why TPF must use the register 1.  */\n \n   if (!current_function_is_leaf\n-      && !has_hard_reg_initial_val (Pmode, RETURN_REGNUM)\n       && get_pool_size () < S390_POOL_CHUNK_MAX / 2\n       && !TARGET_TPF)\n     temp_reg = gen_rtx_REG (Pmode, RETURN_REGNUM);"}, {"sha": "d4664092f69aa5c0b7c50f952f8d9336b2663cfe", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 10, "deletions": 91, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416cf582d382973bda9dd516b9044e60d107dd43/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416cf582d382973bda9dd516b9044e60d107dd43/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=416cf582d382973bda9dd516b9044e60d107dd43", "patch": "@@ -92,13 +92,7 @@\n    (UNSPECV_POOL\t\t200)\n    (UNSPECV_POOL_START\t\t201)\n    (UNSPECV_POOL_END\t\t202)\n-   (UNSPECV_POOL_QI\t\t203)\n-   (UNSPECV_POOL_HI\t\t204)\n-   (UNSPECV_POOL_SI\t\t205)\n-   (UNSPECV_POOL_DI\t\t206)\n-   (UNSPECV_POOL_TI\t\t207)\n-   (UNSPECV_POOL_SF\t\t208)\n-   (UNSPECV_POOL_DF\t\t209)\n+   (UNSPECV_POOL_ENTRY\t\t203)\n    (UNSPECV_MAIN_POOL\t\t300)\n \n    ; TLS support\n@@ -7058,88 +7052,19 @@\n ; Special literal pool access instruction pattern(s).\n ;\n \n-(define_insn \"consttable_qi\"\n-  [(unspec_volatile [(match_operand:QI 0 \"consttable_operand\" \"X\")]\n-\t\t    UNSPECV_POOL_QI)]\n+(define_insn \"*pool_entry\"\n+  [(unspec_volatile [(match_operand 0 \"consttable_operand\" \"X\")]\n+                    UNSPECV_POOL_ENTRY)]\n   \"\"\n {\n-  assemble_integer (operands[0], 1, BITS_PER_UNIT, 1);\n+  enum machine_mode mode = GET_MODE (PATTERN (insn));\n+  unsigned int align = GET_MODE_BITSIZE (mode);\n+  s390_output_pool_entry (asm_out_file, operands[0], mode, align);\n   return \"\";\n }\n-  [(set_attr \"op_type\"  \"NN\")\n-   (set_attr \"length\"   \"1\")])\n-\n-(define_insn \"consttable_hi\"\n-  [(unspec_volatile [(match_operand:HI 0 \"consttable_operand\" \"X\")]\n-\t\t    UNSPECV_POOL_HI)]\n-  \"\"\n-{\n-  assemble_integer (operands[0], 2, 2*BITS_PER_UNIT, 1);\n-  return \"\";\n-}\n-  [(set_attr \"op_type\"  \"NN\")\n-   (set_attr \"length\"   \"2\")])\n-\n-(define_insn \"consttable_si\"\n-  [(unspec_volatile [(match_operand:SI 0 \"consttable_operand\" \"X\")]\n-\t\t    UNSPECV_POOL_SI)]\n-  \"\"\n-  \".long\\t%0\"\n-  [(set_attr \"op_type\"  \"NN\")\n-   (set_attr \"length\"   \"4\")])\n-\n-(define_insn \"consttable_di\"\n-  [(unspec_volatile [(match_operand:DI 0 \"consttable_operand\" \"X\")]\n-\t\t    UNSPECV_POOL_DI)]\n-  \"\"\n-  \".quad\\t%0\"\n-  [(set_attr \"op_type\"  \"NN\")\n-   (set_attr \"length\"   \"8\")])\n-\n-(define_insn \"consttable_ti\"\n-  [(unspec_volatile [(match_operand:TI 0 \"consttable_operand\" \"X\")]\n-\t\t    UNSPECV_POOL_TI)]\n-  \"\"\n-{\n-  assemble_integer (operands[0], 16, 16*BITS_PER_UNIT, 1);\n-  return \"\";\n-}\n-  [(set_attr \"op_type\"  \"NN\")\n-   (set_attr \"length\"   \"16\")])\n-\n-(define_insn \"consttable_sf\"\n-  [(unspec_volatile [(match_operand:SF 0 \"consttable_operand\" \"X\")]\n-\t\t    UNSPECV_POOL_SF)]\n-  \"\"\n-{\n-  REAL_VALUE_TYPE r;\n-\n-  if (GET_CODE (operands[0]) != CONST_DOUBLE)\n-    abort ();\n-\n-  REAL_VALUE_FROM_CONST_DOUBLE (r, operands[0]);\n-  assemble_real (r, SFmode, 4*BITS_PER_UNIT);\n-  return \"\";\n-}\n-  [(set_attr \"op_type\"  \"NN\")\n-   (set_attr \"length\"   \"4\")])\n-\n-(define_insn \"consttable_df\"\n-  [(unspec_volatile [(match_operand:DF 0 \"consttable_operand\" \"X\")]\n-\t\t    UNSPECV_POOL_DF)]\n-  \"\"\n-{\n-  REAL_VALUE_TYPE r;\n-\n-  if (GET_CODE (operands[0]) != CONST_DOUBLE)\n-    abort ();\n-\n-  REAL_VALUE_FROM_CONST_DOUBLE (r, operands[0]);\n-  assemble_real (r, DFmode, 8*BITS_PER_UNIT);\n-  return \"\";\n-}\n-  [(set_attr \"op_type\"  \"NN\")\n-   (set_attr \"length\"   \"8\")])\n+  [(set_attr \"op_type\" \"NN\")\n+   (set (attr \"length\") \n+        (symbol_ref \"GET_MODE_SIZE (GET_MODE (PATTERN (insn)))\"))])\n \n (define_insn \"pool_start_31\"\n   [(unspec_volatile [(const_int 0)] UNSPECV_POOL_START)]\n@@ -7239,12 +7164,6 @@\n        output_asm_insn (\"bras\\t%0,%2\", operands);\n        s390_output_constant_pool (operands[1], operands[2]);\n      }\n-   else if (flag_pic)\n-     {\n-        /* We need the anchor label in any case.  */\n-        (*targetm.asm_out.internal_label) (asm_out_file, \"L\",\n-                                           CODE_LABEL_NUMBER (operands[1]));\n-     }\n \n    return \"\";\n }"}]}