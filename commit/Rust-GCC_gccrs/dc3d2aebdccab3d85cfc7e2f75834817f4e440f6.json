{"sha": "dc3d2aebdccab3d85cfc7e2f75834817f4e440f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGMzZDJhZWJkY2NhYjNkODVjZmM3ZTJmNzU4MzQ4MTdmNGU0NDBmNg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2015-12-04T14:02:27Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2015-12-04T14:02:27Z"}, "message": "nvptx.c (write_one_arg): Deal with prologue emission too.\n\n\t* config/nvptx/nvptx.c (write_one_arg): Deal with prologue\n\temission too. Change 'no_arg_types' to 'prototyped'.\n\t(write_fn_proto):  Use write_one_arg for stdarg, static chain &\n\tmain.\n\t(nvptx_declare_function_name): Use write_one_arg for prologue copies.\n\nFrom-SVN: r231267", "tree": {"sha": "0588ca2ad3d840316d88e2c875880cbf9c62939c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0588ca2ad3d840316d88e2c875880cbf9c62939c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc3d2aebdccab3d85cfc7e2f75834817f4e440f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc3d2aebdccab3d85cfc7e2f75834817f4e440f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc3d2aebdccab3d85cfc7e2f75834817f4e440f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc3d2aebdccab3d85cfc7e2f75834817f4e440f6/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "96d977a8f3ecfaedf634d86179af47fff7233f1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96d977a8f3ecfaedf634d86179af47fff7233f1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96d977a8f3ecfaedf634d86179af47fff7233f1e"}], "stats": {"total": 183, "additions": 88, "deletions": 95}, "files": [{"sha": "74c8080a20a7ba935bbe7a80ee416b3e50fc902e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc3d2aebdccab3d85cfc7e2f75834817f4e440f6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc3d2aebdccab3d85cfc7e2f75834817f4e440f6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dc3d2aebdccab3d85cfc7e2f75834817f4e440f6", "patch": "@@ -1,3 +1,11 @@\n+2015-12-04  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* config/nvptx/nvptx.c (write_one_arg): Deal with prologue\n+\temission too. Change 'no_arg_types' to 'prototyped'.\n+\t(write_fn_proto):  Use write_one_arg for stdarg, static chain &\n+\tmain.\n+\t(nvptx_declare_function_name): Use write_one_arg for prologue copies.\n+\n 2015-12-04  Richard Biener  <rguenther@suse.de>\n \n \t* tree-ssa-sccvn.c (sccvn_dom_walker): Add unreachable_dom"}, {"sha": "0f272cf43b37b9716bb1639376f98d8e5afac1de", "filename": "gcc/config/nvptx/nvptx.c", "status": "modified", "additions": 80, "deletions": 95, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc3d2aebdccab3d85cfc7e2f75834817f4e440f6/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc3d2aebdccab3d85cfc7e2f75834817f4e440f6/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.c?ref=dc3d2aebdccab3d85cfc7e2f75834817f4e440f6", "patch": "@@ -389,38 +389,67 @@ arg_promotion (machine_mode mode)\n   return mode;\n }\n \n-/* Write the declaration of a function arg of TYPE to S.  I is the index\n-   of the argument, MODE its mode.  NO_ARG_TYPES is true if this is for\n-   a decl with zero TYPE_ARG_TYPES, i.e. an old-style C decl.  */\n+/* Process function parameter TYPE, either emitting in a prototype\n+   argument, or as a copy a in a function prologue.  ARGNO is the\n+   index of this argument in the PTX function.  FOR_REG is negative,\n+   if we're emitting the PTX prototype.  It is zero if we're copying\n+   to an argument register and it is greater than zero if we're\n+   copying to a specific hard register.  PROTOTYPED is true, if this\n+   is a prototyped function, rather than an old-style C declaration.\n+\n+   The behaviour here must match the regular GCC function parameter\n+   marshalling machinery.  */\n \n static int\n-write_one_arg (std::stringstream &s, const char *sep, int i,\n-\t       tree type, machine_mode mode, bool no_arg_types)\n+write_one_arg (std::stringstream &s, int for_reg, int argno,\n+\t       tree type, bool prototyped)\n {\n+  machine_mode mode = TYPE_MODE (type);\n+\n   if (!PASS_IN_REG_P (mode, type))\n     mode = Pmode;\n \n   machine_mode split = maybe_split_mode (mode);\n   if (split != VOIDmode)\n     {\n-      i = write_one_arg (s, sep, i, TREE_TYPE (type), split, false);\n-      sep = \", \";\n       mode = split;\n+      argno = write_one_arg (s, for_reg, argno,\n+\t\t\t     TREE_TYPE (type), prototyped);\n     }\n \n-  if (no_arg_types && !AGGREGATE_TYPE_P (type))\n+  if (!prototyped && !AGGREGATE_TYPE_P (type))\n     {\n       if (mode == SFmode)\n \tmode = DFmode;\n       mode = arg_promotion (mode);\n     }\n \n-  s << sep;\n-  s << \".param\" << nvptx_ptx_type_from_mode (mode, false) << \" %in_ar\"\n-    << i << (mode == QImode || mode == HImode ? \"[1]\" : \"\");\n-  if (mode == BLKmode)\n-    s << \"[\" << int_size_in_bytes (type) << \"]\";\n-  return i + 1;\n+  if (for_reg < 0)\n+    {\n+      /* Writing PTX prototype.  */\n+      s << (argno ? \", \" : \" (\");\n+      s << \".param\" << nvptx_ptx_type_from_mode (mode, false)\n+\t<< \" %in_ar\" << argno;\n+      if (mode == QImode || mode == HImode)\n+\ts << \"[1]\";\n+    }\n+  else\n+    {\n+      mode = arg_promotion (mode);\n+      s << \"\\t.reg\" << nvptx_ptx_type_from_mode (mode, false) << \" \";\n+      if (for_reg)\n+\ts << reg_names[for_reg];\n+      else\n+\ts << \"%ar\" << argno;\n+      s << \";\\n\";\n+      s << \"\\tld.param\" << nvptx_ptx_type_from_mode (mode, false) << \" \";\n+      if (for_reg)\n+\ts << reg_names[for_reg];\n+      else\n+\ts << \"%ar\" << argno;\n+      s<< \", [%in_ar\" << argno << \"];\\n\";\n+    }\n+  return argno + 1;\n }\n \n /* Look for attributes in ATTRS that would indicate we must write a function\n@@ -507,63 +536,46 @@ write_fn_proto (std::stringstream &s, bool is_defn,\n \n   s << name;\n \n-  const char *sep = \" (\";\n-  int i = 0;\n+  int argno = 0;\n \n   /* Emit argument list.  */\n   if (return_in_mem)\n-    {\n-      s << sep << \".param.u\" << GET_MODE_BITSIZE (Pmode) << \" %in_ar0\";\n-      sep  = \", \";\n-      i++;\n-    }\n+    argno = write_one_arg (s, -1, argno, ptr_type_node, true);\n \n   /* We get:\n      NULL in TYPE_ARG_TYPES, for old-style functions\n      NULL in DECL_ARGUMENTS, for builtin functions without another\n        declaration.\n      So we have to pick the best one we have.  */\n   tree args = TYPE_ARG_TYPES (fntype);\n-  bool null_type_args = !args;\n-  if (null_type_args)\n-    args = DECL_ARGUMENTS (decl);\n+  bool prototyped = true;\n+  if (!args)\n+    {\n+      args = DECL_ARGUMENTS (decl);\n+      prototyped = false;\n+    }\n \n   for (; args; args = TREE_CHAIN (args))\n     {\n-      tree type = null_type_args ? TREE_TYPE (args) : TREE_VALUE (args);\n-      machine_mode mode = TYPE_MODE (type);\n+      tree type = prototyped ? TREE_VALUE (args) : TREE_TYPE (args);\n \n-      if (mode == VOIDmode)\n-\tbreak;\n-      i = write_one_arg (s, sep, i, type, mode, null_type_args);\n-      sep = \", \";\n+      if (type != void_type_node)\n+\targno = write_one_arg (s, -1, argno, type, prototyped);\n     }\n \n   if (stdarg_p (fntype))\n-    {\n-      s << sep << \".param.u\" << GET_MODE_BITSIZE (Pmode) << \" %in_argp\";\n-      i++;\n-      sep = \", \";\n-    }\n+    argno = write_one_arg (s, -1, argno, ptr_type_node, true);\n \n   if (DECL_STATIC_CHAIN (decl))\n-    {\n-      s << sep << \".reg.u\" << GET_MODE_BITSIZE (Pmode)\n-\t<< reg_names [STATIC_CHAIN_REGNUM];\n-      i++;\n-      sep = \", \";\n-    }\n+    argno = write_one_arg (s, -1, argno, ptr_type_node, true);\n \n-  if (!i && strcmp (name, \"main\") == 0)\n+  if (!argno && strcmp (name, \"main\") == 0)\n     {\n-      s << sep\n-\t<< \".param.u32 %argc, .param.u\" << GET_MODE_BITSIZE (Pmode)\n-\t<< \" %argv\";\n-      i++;\n-      sep = \", \";\n+      argno = write_one_arg (s, -1, argno, integer_type_node, true);\n+      argno = write_one_arg (s, -1, argno, ptr_type_node, true);\n     }\n \n-  if (i)\n+  if (argno)\n     s << \")\";\n \n   s << (is_defn ? \"\\n\" : \";\\n\");\n@@ -705,63 +717,43 @@ nvptx_declare_function_name (FILE *file, const char *name, const_tree decl)\n {\n   tree fntype = TREE_TYPE (decl);\n   tree result_type = TREE_TYPE (fntype);\n-  int argno  = 0;\n+  int argno = 0;\n \n+  /* We construct the initial part of the function into a string\n+     stream, in order to share the prototype writing code.  */\n   std::stringstream s;\n   write_fn_proto (s, true, name, decl);\n-  fprintf (file, \"%s\", s.str().c_str());\n-  fprintf (file, \"{\\n\");\n+  s << \"{\\n\";\n \n   bool return_in_mem = (TYPE_MODE (result_type) != VOIDmode\n \t\t\t&& !RETURN_IN_REG_P (TYPE_MODE (result_type)));\n   if (return_in_mem)\n-    {\n-      fprintf (file, \"\\t.reg.u%d %%ar%d;\\n\", GET_MODE_BITSIZE (Pmode), argno);\n-      fprintf (file, \"\\tld.param.u%d %%ar%d, [%%in_ar%d];\\n\",\n-\t       GET_MODE_BITSIZE (Pmode), argno, argno);\n-      argno++;\n-    }\n-\n+    argno = write_one_arg (s, 0, argno, ptr_type_node, true);\n+  \n   /* Declare and initialize incoming arguments.  */\n-  tree args = DECL_ARGUMENTS (decl);\n-  bool prototyped = false;\n-  if (TYPE_ARG_TYPES (fntype))\n+  tree args = TYPE_ARG_TYPES (fntype);\n+  bool prototyped = true;\n+  if (!args)\n     {\n-      args = TYPE_ARG_TYPES (fntype);\n-      prototyped = true;\n+      args = DECL_ARGUMENTS (decl);\n+      prototyped = false;\n     }\n \n   for (; args != NULL_TREE; args = TREE_CHAIN (args))\n     {\n       tree type = prototyped ? TREE_VALUE (args) : TREE_TYPE (args);\n-      machine_mode mode = TYPE_MODE (type);\n-      int count = 1;\n \n-      if (mode == VOIDmode)\n-\tbreak;\n+      if (type != void_type_node)\n+\targno = write_one_arg (s, 0, argno, type, prototyped);\n+    }\n \n-      if (!PASS_IN_REG_P (mode, type))\n-\tmode = Pmode;\n+  if (stdarg_p (fntype))\n+    argno = write_one_arg (s, ARG_POINTER_REGNUM, argno, ptr_type_node, true);\n \n-      machine_mode split = maybe_split_mode (mode);\n-      if (split != VOIDmode)\n-\t{\n-\t  count = 2;\n-\t  mode = split;\n-\t}\n-      else if (!prototyped && !AGGREGATE_TYPE_P (type) && mode == SFmode)\n-\tmode = DFmode;\n+  if (DECL_STATIC_CHAIN (decl))\n+    argno = write_one_arg (s, STATIC_CHAIN_REGNUM, argno, ptr_type_node, true);\n \n-      mode = arg_promotion (mode);\n-      while (count--)\n-\t{\n-\t  fprintf (file, \"\\t.reg%s %%ar%d;\\n\",\n-\t\t   nvptx_ptx_type_from_mode (mode, false), argno);\n-\t  fprintf (file, \"\\tld.param%s %%ar%d, [%%in_ar%d];\\n\",\n-\t\t   nvptx_ptx_type_from_mode (mode, false), argno, argno);\n-\t  argno++;\n-\t}\n-    }\n+  fprintf (file, \"%s\", s.str().c_str());\n \n   /* C++11 ABI causes us to return a reference to the passed in\n      pointer for return_in_mem.  */\n@@ -773,16 +765,9 @@ nvptx_declare_function_name (FILE *file, const char *name, const_tree decl)\n \t       nvptx_ptx_type_from_mode (mode, false));\n     }\n \n-  if (stdarg_p (fntype))\n-    {\n-      fprintf (file, \"\\t.reg.u%d %%argp;\\n\", GET_MODE_BITSIZE (Pmode));\n-      fprintf (file, \"\\tld.param.u%d %%argp, [%%in_argp];\\n\",\n-\t       GET_MODE_BITSIZE (Pmode));\n-    }\n-\n   fprintf (file, \"\\t.reg.u%d %s;\\n\", GET_MODE_BITSIZE (Pmode),\n \t   reg_names[OUTGOING_STATIC_CHAIN_REGNUM]);\n-\n+  \n   /* Declare the pseudos we have as ptx registers.  */\n   int maxregs = max_reg_num ();\n   for (int i = LAST_VIRTUAL_REGISTER + 1; i < maxregs; i++)"}]}