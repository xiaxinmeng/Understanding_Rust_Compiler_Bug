{"sha": "0eb7e7aa011a0e47a022580c1bc15c10654cb9a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGViN2U3YWEwMTFhMGU0N2EwMjI1ODBjMWJjMTVjMTA2NTRjYjlhMg==", "commit": {"author": {"name": "Razya Ladelsky", "email": "razya@il.ibm.com", "date": "2007-11-06T10:29:12Z"}, "committer": {"name": "Razya Ladelsky", "email": "razya@gcc.gnu.org", "date": "2007-11-06T10:29:12Z"}, "message": "tree-parloops.c (reduction_info): Remove reduction_init field.\n\n2007-11-04  Razya Ladelsky  <razya@il.ibm.com>\n\t\n\t* tree-parloops.c (reduction_info): Remove reduction_init field.\n\t(initialize_reductions): Remove creation of the reduction_init variable.\n\t(struct data_arg): Remove.\n\t(add_field_for_reduction, create_stores_for_reduction): New functions.\n\t(add_field_for_name): Remove reduction handling.\n\t(separate_decls_in_loop): Call add_field_for_reduction, \n\tcreate_stores_for_reduction.\n\nFrom-SVN: r129923", "tree": {"sha": "185bbc318bfc38860a9a39cc9cacdd17e338f4fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/185bbc318bfc38860a9a39cc9cacdd17e338f4fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0eb7e7aa011a0e47a022580c1bc15c10654cb9a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0eb7e7aa011a0e47a022580c1bc15c10654cb9a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0eb7e7aa011a0e47a022580c1bc15c10654cb9a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0eb7e7aa011a0e47a022580c1bc15c10654cb9a2/comments", "author": null, "committer": null, "parents": [{"sha": "b0eb6a8f727aa18463fef3014ad115b7292223a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0eb6a8f727aa18463fef3014ad115b7292223a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0eb6a8f727aa18463fef3014ad115b7292223a2"}], "stats": {"total": 340, "additions": 140, "deletions": 200}, "files": [{"sha": "ccfa88eed202be6b2d28b02f85c6c981e223787b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eb7e7aa011a0e47a022580c1bc15c10654cb9a2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eb7e7aa011a0e47a022580c1bc15c10654cb9a2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0eb7e7aa011a0e47a022580c1bc15c10654cb9a2", "patch": "@@ -1,3 +1,13 @@\n+2007-11-04  Razya Ladelsky  <razya@il.ibm.com>\n+\t\n+\t* tree-parloops.c (reduction_info): Remove reduction_init field.\n+\t(initialize_reductions): Remove creation of the reduction_init variable.\n+\t(struct data_arg): Remove.\n+\t(add_field_for_reduction, create_stores_for_reduction): New functions.\n+\t(add_field_for_name): Remove reduction handling.\n+\t(separate_decls_in_loop): Call add_field_for_reduction, \n+\tcreate_stores_for_reduction.\n+\n 2007-11-06  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/33458"}, {"sha": "ca829f79f43557ac76bf05547c1e5efe3ef1c0c9", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 130, "deletions": 200, "changes": 330, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eb7e7aa011a0e47a022580c1bc15c10654cb9a2/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eb7e7aa011a0e47a022580c1bc15c10654cb9a2/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=0eb7e7aa011a0e47a022580c1bc15c10654cb9a2", "patch": "@@ -67,36 +67,35 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n   currently we use vect_is_simple_reduction() to detect reduction patterns.\n   The code transformation will be introduced by an example.\n   \n-  source code:\n-\n+    \n parloop\n {\n   int sum=1;\n \n-  for (i = 0; i < N/1000; i++)\n+  for (i = 0; i < N; i++)\n    {\n     x[i] = i + 3;\n     sum+=x[i];\n    }\n }\n \n-gimple code:\n-\n+gimple-like code:\n header_bb:\n \n-  # sum_24 = PHI <sum_14(3), 1(2)>;\n-  # i_21 = PHI <i_15(3), 0(2)>;\n-<L0>:;\n-  D.2191_10 = i_21 + 3;\n-  x[i_21] = D.2191_10;\n-  sum_14 = D.2191_10 + sum_24;\n-  i_15 = i_21 + 1;\n-  if (N_8 > i_15) goto <L0>; else goto <L2>;\n+  # sum_29 = PHI <sum_11(5), 1(3)>\n+  # i_28 = PHI <i_12(5), 0(3)>\n+  D.1795_8 = i_28 + 3;\n+  x[i_28] = D.1795_8;\n+  sum_11 = D.1795_8 + sum_29;\n+  i_12 = i_28 + 1;\n+  if (N_6(D) > i_12)\n+    goto header_bb;\n+\n \n exit_bb:\n \n-  # sum_25 = PHI <sum_14(3)>;\n-<L2>:;\n+  # sum_21 = PHI <sum_11(4)>\n+  printf (&\"%d\"[0], sum_21);\n \n \n after reduction transformation (only relevant parts):\n@@ -106,141 +105,58 @@ parloop\n \n ....\n \n-<L16>:;\n-  D.2241_2 = (unsigned int) N_8;\n-  D.2242_26 = D.2241_2 - 1;\n-  if (D.2242_26 > 399) goto <L26>; else goto <L27>;\n-\n-#two new variables are created for each reduction: \n-\"reduction\" is the variable holding the neutral element \n-for the particular operation, e.g. 0 for PLUS_EXPR,\n-1 for MULT_EXPR, etc.\n-\"reduction_initial\" is the initial value given by the user.\n-It is kept and will be used after the parallel computing \n-is done.#\n-\n-<L26>:;\n-  reduction.38_42 = 0;     \n-  reduction_initial.39_43 = 1;        \n-  x.40_44 = &x;\n-  .paral_data_store.47.D.2261 = D.2242_26;\n-  .paral_data_store.47.reduction.38 = reduction.38_42;\n-  .paral_data_store.47.x.40 = x.40_44;\n-  __builtin_GOMP_parallel_start (parloop._loopfn.0, &.paral_data_store.47, 4);\n-  parloop._loopfn.0 (&.paral_data_store.47);\n-  __builtin_GOMP_parallel_end ();\n-\n-# collecting the result after the join of the threads is done at\n-  create_loads_for_reductions().  \n-  a new variable \"reduction_final\" is created.  It calculates the\n-  final value from the initial value and the value computed by \n-  the threads.  #\n+\n+  # A new variable is created for each reduction:\n+  \"reduction_initial\" is the initial value given by the user.\n+  It is kept and will be used after the parallel computing is done.  #\n+\n+  reduction_initial.24_46 = 1;\n   \n-  .paral_data_load.48_49 = &.paral_data_store.47;        \n-  reduction_final.49_50 = .paral_data_load.48_49->reduction.38;\n-  reduction_final.49_51 = reduction_initial.39_43 + reduction_final.49_50;\n-  ivtmp.37_36 = D.2242_26;\n-  i_37 = (int) ivtmp.37_36;\n-  D.2191_38 = i_37 + 3;\n-  x[i_37] = D.2191_38;\n-  sum_40 = D.2191_38 + reduction_final.49_51;\n-  i_41 = i_37 + 1;\n-  goto <bb 8> (<L2>);\n-\n-  # sum_25 = PHI <sum_40(4), sum_9(6)>;\n-<L2>:;\n-  printf (&\"sum is %d\\n\"[0], sum_25);\n+  # Storing the neutral value of the\n+  particular reduction's operation, e.g. 0 for PLUS_EXPR, \n+  1 for MULT_EXPR, etc. into the reduction field.\n+  This is done in create_stores_for_reduction.  #\n+ \n+  .paral_data_store.32.sum.27 = 0;\n+  \n+  #pragma omp parallel num_threads(4) \n \n-...\n+  #pragma omp for schedule(static)\n+  # sum.27_29 = PHI <sum.27_11, 0> # The neutral element replaces\n+ \t\t\t           the user's inital value.  #\n+  sum.27_11 = D.1827_8 + sum.27_29;\n+  OMP_CONTINUE\n \n-}\n+  # Adding this reduction phi is done at create_phi_for_local_result() #\n+  # sum.27_56 = PHI <sum.27_11, 0>\n+  OMP_RETURN\n+  \n+  # Creating the atomic operation is done at \n+  create_call_for_reduction_1()  #\n \n-parloop._loopfn.0 (.paral_data_param)\n-{\n- ...\n-\n-<L28>:;\n-  .paral_data_param_52 = .paral_data_param_75;\n-  .paral_data_load.48_48 = (struct .paral_data.46 *) .paral_data_param_52;\n-  D.2289_46 = .paral_data_load.48_48->D.2261;\n-  reduction.43_45 = .paral_data_load.48_48->reduction.38;\n-   x.45_47 = .paral_data_load.48_48->x.40;\n-  # SUCC: 23 [100.0%]  (fallthru)\n-\n-  # BLOCK 23\n-  # PRED: 21 [100.0%]  (fallthru)\n-<L30>:;\n-  D.2292_60 = __builtin_omp_get_num_threads ();\n-  D.2293_61 = (unsigned int) D.2292_60;\n-  D.2294_62 = __builtin_omp_get_thread_num ();\n-  D.2295_63 = (unsigned int) D.2294_62;\n-  D.2296_64 = D.2289_46 / D.2293_61;\n-  D.2297_65 = D.2293_61 * D.2296_64;\n-  D.2298_66 = D.2297_65 != D.2289_46;\n-  D.2299_67 = D.2296_64 + D.2298_66;\n-  D.2300_68 = D.2299_67 * D.2295_63;\n-  D.2301_69 = D.2299_67 + D.2300_68;\n-  D.2302_70 = MIN_EXPR <D.2301_69, D.2289_46>;\n-  ivtmp.41_54 = D.2300_68;\n-  if (D.2300_68 >= D.2302_70) goto <L31>; else goto <L32>;\n-  # SUCC: 26 [100.0%]  (false) 24 (true)\n-\n-  # BLOCK 26\n-  # PRED: 23 [100.0%]  (false)\n-<L32>:;\n-  # SUCC: 4 [100.0%]  (fallthru)\n-\n-  # BLOCK 4\n-  # PRED: 5 [100.0%]  (true) 26 [100.0%]  (fallthru)\n-  # ivtmp.41_31 = PHI <ivtmp.41_30(5), ivtmp.41_54(26)>;\n-  # sum.42_32 = PHI <sum.42_14(5), reduction.43_45(26)>;\n-<L0>:;\n-  # SUCC: 19 [100.0%]  (fallthru)\n-\n-  # BLOCK 19\n-  # PRED: 4 [100.0%]  (fallthru)\n-  # sum.42_24 = PHI <sum.42_32(4)>;\n-  # ivtmp.41_17 = PHI <ivtmp.41_31(4)>;\n-  i.44_21 = (int) ivtmp.41_17;\n-  D.2310_10 = i.44_21 + 3;\n-  (*x.45_47)[i.44_21] = D.2310_10;\n-  sum.42_14 = D.2310_10 + sum.42_24;\n-  i.44_15 = i.44_21 + 1;\n-  # SUCC: 5 [100.0%]  (fallthru)\n-\n-  # BLOCK 5\n-  # PRED: 19 [100.0%]  (fallthru)\n-<L17>:;\n-  ivtmp.41_30 = ivtmp.41_31 + 1;\n-  if (ivtmp.41_30 < D.2302_70) goto <L0>; else goto <L31>;\n-  # SUCC: 4 [100.0%]  (true) 24 (false)\n-\n-  # Adding this reduction phi is done at\n-  create_phi_for_local_result() #\n-\n-  # BLOCK 24\n-  # PRED: 5 (false) 23 (true)\n-  # reduction.38_56 = PHI <sum.42_14(5), 0(23)>;\n-    <L31>:;\n-  __builtin_GOMP_barrier ();\n-  # SUCC: 25 [100.0%]  (fallthru)\n-\n-  # Creating the atomic operation is\n-  done at create_call_for_reduction_1()  #\n-\n-  # BLOCK 25\n-  # PRED: 24 [100.0%]  (fallthru)\n-  D.2306_57 = &.paral_data_load.48_48->reduction.38;\n-  D.2307_58 = (unsigned int) reduction.38_56;\n-  D.2308_59 = __sync_fetch_and_add_4 (D.2306_57, D.2307_58);\n-  # SUCC: 22 [100.0%]  (fallthru)\n-\n-  # BLOCK 22\n-  # PRED: 25 [100.0%]  (fallthru)\n-  <L29>:;\n-  return;\n-  # SUCC: EXIT\n+  #pragma omp atomic_load\n+  D.1839_59 = *&.paral_data_load.33_51->reduction.23;\n+  D.1840_60 = sum.27_56 + D.1839_59;\n+  #pragma omp atomic_store (D.1840_60);\n   \n+  OMP_RETURN\n+  \n+ # collecting the result after the join of the threads is done at\n+  create_loads_for_reductions().\n+  a new variable \"reduction_final\" is created.  It calculates the final\n+  value from the initial value and the value computed by the threads #\n+ \n+  .paral_data_load.33_52 = &.paral_data_store.32;\n+  reduction_final.34_53 = .paral_data_load.33_52->sum.27;\n+  sum_37 = reduction_initial.24_46 + reduction_final.34_53;\n+  sum_43 = D.1795_41 + sum_37;\n+\n+  exit bb:\n+  # sum_21 = PHI <sum_43, sum_26>\n+  printf (&\"%d\"[0], sum_21);\n+\n+...\n+\n }\n \n */\n@@ -261,8 +177,6 @@ struct reduction_info\n   tree initial_value;\t\t/* An ssa name representing a new variable holding\n \t\t\t\t   the initial value of the reduction var before entering the loop.   */\n   tree field;\t\t\t/*  the name of the field in the parloop data structure intended for reduction.  */\n-  tree reduction_init;\t\t/* An ssa name representing a new variable which will be \n-\t\t\t\t   assigned the proper reduction initialization value (init).  */\n   tree init;\t\t\t/* reduction initialization value.  */\n   tree new_phi;\t\t\t/* (helper field) Newly created phi node whose result \n \t\t\t\t   will be passed to the atomic operation.  Represents\n@@ -576,9 +490,9 @@ take_address_of (tree var, tree type, struct loop *loop, htab_t decl_address)\n static int\n initialize_reductions (void **slot, void *data)\n {\n-  tree t, stmt;\n+  tree stmt;\n   tree init, c;\n-  tree name, name1;\n+  tree name1;\n   tree bvar, type, arg;\n   edge e;\n \n@@ -604,16 +518,13 @@ initialize_reductions (void **slot, void *data)\n   init = omp_reduction_init (c, TREE_TYPE (bvar));\n   reduc->init = init;\n \n-  t = build_gimple_modify_stmt (bvar, init);\n-  name = make_ssa_name (bvar, t);\n-\n-  GIMPLE_STMT_OPERAND (t, 0) = name;\n-  SSA_NAME_DEF_STMT (name) = t;\n-\n-  /* Replace the argument \n-     representing the initialization value.  Keeping the old value \n-     in a new variable \"reduction_initial\", that will be taken in \n-     consideration after the parallel computing is done.  */\n+  /* Replace the argument representing the initialization value \n+     with the initialization value for the reduction (neutral \n+     element for the particular operation, e.g. 0 for PLUS_EXPR, \n+     1 for MULT_EXPR, etc).  \n+     Keep the old value in a new variable \"reduction_initial\", \n+     that will be taken in consideration after the parallel \n+     computing is done.  */\n \n   e = loop_preheader_edge (loop);\n   arg = PHI_ARG_DEF_FROM_EDGE (reduc->reduc_phi, e);\n@@ -628,11 +539,9 @@ initialize_reductions (void **slot, void *data)\n   SSA_NAME_DEF_STMT (name1) = stmt;\n \n   bsi_insert_on_edge_immediate (e, stmt);\n-  bsi_insert_on_edge_immediate (e, t);\n   SET_USE (PHI_ARG_DEF_PTR_FROM_EDGE\n-\t   (reduc->reduc_phi, loop_preheader_edge (loop)), name);\n+\t   (reduc->reduc_phi, loop_preheader_edge (loop)), init);\n   reduc->initial_value = name1;\n-  reduc->reduction_init = name;\n   return 1;\n }\n \n@@ -857,49 +766,40 @@ separate_decls_in_loop_stmt (struct loop *loop, tree stmt,\n   }\n }\n \n-/* A helper structure for passing the TYPE and REDUCTION_LIST\n-   to the DATA parameter of add_field_for_name.  */\n-struct data_arg \n+/* Callback for htab_traverse.  Adds a field corresponding to the reduction\n+   specified in SLOT. The type is passed in DATA.  */\n+\n+static int\n+add_field_for_reduction (void **slot, void *data)\n {\n-  tree type;\n-  htab_t reduction_list;\n-};\n+  \n+  struct reduction_info *red = *slot;\n+  tree type = data;\n+  tree var = SSA_NAME_VAR (GIMPLE_STMT_OPERAND (red->reduc_stmt, 0));\n+  tree field = build_decl (FIELD_DECL, DECL_NAME (var), TREE_TYPE (var));\n+\n+  insert_field_into_struct (type, field);\n+\n+  red->field = field;\n+\n+  return 1;\n+}\n \n /* Callback for htab_traverse.  Adds a field corresponding to a ssa name\n-   described in SLOT. The type is passed in DATA.  The Reduction list\n-   is also passes in DATA.  */\n+   described in SLOT. The type is passed in DATA.  */ \n \n static int\n add_field_for_name (void **slot, void *data)\n {\n-  tree stmt;\n-  use_operand_p use_p = NULL;\n-\n   struct name_to_copy_elt *elt = *slot;\n-  struct data_arg *data_arg = (struct data_arg *) data;\n-  tree type = data_arg->type;\n+  tree type = data;\n   tree name = ssa_name (elt->version);\n   tree var = SSA_NAME_VAR (name);\n   tree field = build_decl (FIELD_DECL, DECL_NAME (var), TREE_TYPE (var));\n \n   insert_field_into_struct (type, field);\n   elt->field = field;\n \n-  /* Find uses of name to determine if this name is related to \n-     a reduction phi, and if so, record the field in the reduction struct.  */\n-\n-  if ((htab_elements (data_arg->reduction_list) > 0) \n-      && single_imm_use (elt->new_name, &use_p, &stmt)\n-      && TREE_CODE (stmt) == PHI_NODE)\n-    {\n-      /* check if STMT is a REDUC_PHI of some reduction.  */\n-      struct reduction_info *red;\n-\n-      red = reduction_phi (data_arg->reduction_list ,stmt);\n-      if (red)\n-\tred->field = field;\n-    }\n-\n   return 1;\n }\n \n@@ -934,7 +834,7 @@ create_phi_for_local_result (void **slot, void *data)\n     e = EDGE_PRED (store_bb, 1);\n   else\n     e = EDGE_PRED (store_bb, 0);\n-  local_res = make_ssa_name (SSA_NAME_VAR (reduc->reduction_init), NULL_TREE);\n+  local_res = make_ssa_name (SSA_NAME_VAR (GIMPLE_STMT_OPERAND (reduc->reduc_stmt, 0)), NULL_TREE);\n   new_phi = create_phi_node (local_res, store_bb);\n   SSA_NAME_DEF_STMT (local_res) = new_phi;\n   add_phi_arg (new_phi, reduc->init, e);\n@@ -1040,7 +940,7 @@ create_loads_for_reductions (void **slot, void *data)\n   struct clsn_data *clsn_data = data;\n   tree stmt;\n   block_stmt_iterator bsi;\n-  tree type = TREE_TYPE (red->reduction_init);\n+  tree type = TREE_TYPE (GIMPLE_STMT_OPERAND (red->reduc_stmt, 0));\n   tree struct_type = TREE_TYPE (TREE_TYPE (clsn_data->load));\n   tree load_struct;\n   tree bvar, name;\n@@ -1061,9 +961,7 @@ create_loads_for_reductions (void **slot, void *data)\n   name = make_ssa_name (bvar, stmt);\n   GIMPLE_STMT_OPERAND (stmt, 0) = name;\n   SSA_NAME_DEF_STMT (name) = stmt;\n-\n   bsi_insert_after (&bsi, stmt, BSI_NEW_STMT);\n-\n   x =\n     fold_build2 (red->reduction_code, TREE_TYPE (load_struct),\n \t\t name, red->initial_value);\n@@ -1103,6 +1001,33 @@ create_final_loads_for_reduction (htab_t reduction_list,\n \n }\n \n+/* Callback for htab_traverse.  Store the neutral value for the\n+  particular reduction's operation, e.g. 0 for PLUS_EXPR,\n+  1 for MULT_EXPR, etc. into the reduction field.\n+  The reduction is specified in SLOT. The store information is \n+  passed in DATA.  */  \n+\n+static int\n+create_stores_for_reduction (void **slot, void *data)\n+{\n+  struct reduction_info *red = *slot;\n+  struct clsn_data *clsn_data = data;\n+  tree stmt;\n+  block_stmt_iterator bsi;\n+  tree type = TREE_TYPE (GIMPLE_STMT_OPERAND (red->reduc_stmt, 0));\n+  \n+  bsi = bsi_last (clsn_data->store_bb);\n+  stmt =\n+    build_gimple_modify_stmt (build3\n+                              (COMPONENT_REF, type, clsn_data->store,\n+                               red->field, NULL_TREE),\n+                               red->init );\n+  mark_virtual_ops_for_renaming (stmt);\n+  bsi_insert_after (&bsi, stmt, BSI_NEW_STMT);\n+\n+  return 1;\n+}\n+\n /* Callback for htab_traverse.  Creates loads to a field of LOAD in LOAD_BB and\n    store to a field of STORE in STORE_BB for the ssa name and its duplicate\n    specified in SLOT.  */\n@@ -1213,19 +1138,21 @@ separate_decls_in_loop (struct loop *loop, htab_t reduction_list,\n     }\n   else\n     {\n-      struct data_arg data_arg;\n-\n       /* Create the type for the structure to store the ssa names to.  */\n       type = lang_hooks.types.make_type (RECORD_TYPE);\n       type_name = build_decl (TYPE_DECL, create_tmp_var_name (\".paral_data\"),\n \t\t\t      type);\n       TYPE_NAME (type) = type_name;\n \n-      data_arg.type = type;\n-      data_arg.reduction_list = reduction_list;\n-      htab_traverse (name_copies, add_field_for_name, &data_arg);\n+      htab_traverse (name_copies, add_field_for_name, type);\n+      if (htab_elements (reduction_list) > 0)\n+\t{\n+\t  /* Create the fields for reductions.  */\n+\t  htab_traverse (reduction_list, add_field_for_reduction,\n+                         type);\n+\t}\n       layout_type (type);\n-\n+ \n       /* Create the loads and stores.  */\n       *arg_struct = create_tmp_var (type, \".paral_data_store\");\n       add_referenced_var (*arg_struct);\n@@ -1237,13 +1164,16 @@ separate_decls_in_loop (struct loop *loop, htab_t reduction_list,\n       ld_st_data->load = *new_arg_struct;\n       ld_st_data->store_bb = bb0;\n       ld_st_data->load_bb = bb1;\n+\n       htab_traverse (name_copies, create_loads_and_stores_for_name,\n \t\t     ld_st_data);\n \n       /* Load the calculation from memory into a new \n          reduction variable (after the join of the threads).  */\n       if (htab_elements (reduction_list) > 0)\n \t{\n+\t  htab_traverse (reduction_list, create_stores_for_reduction,\n+                        ld_st_data); \n \t  clsn_data.load = make_ssa_name (nvar, NULL_TREE);\n \t  clsn_data.load_bb = single_dom_exit (loop)->dest;\n \t  clsn_data.store = ld_st_data->store;"}]}