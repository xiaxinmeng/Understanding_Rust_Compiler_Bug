{"sha": "eebc8f373b5c761dd9d92ff01cb4b6132dbb9081", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWViYzhmMzczYjVjNzYxZGQ5ZDkyZmYwMWNiNGI2MTMyZGJiOTA4MQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-08-05T16:17:46Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-08-05T16:17:46Z"}, "message": "re PR rtl-optimization/49977 (CFI notes are missed for delayed slot)\n\nPR rtl-opt/49977\n        * dwarf2cfi.c (scan_insn_after): Split out of ...\n        (scan_trace): ... here.  Correctly place notes wrt sequences.\n\nFrom-SVN: r177466", "tree": {"sha": "322910cdab185612d3da8d03235bce92660f2588", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/322910cdab185612d3da8d03235bce92660f2588"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eebc8f373b5c761dd9d92ff01cb4b6132dbb9081", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eebc8f373b5c761dd9d92ff01cb4b6132dbb9081", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eebc8f373b5c761dd9d92ff01cb4b6132dbb9081", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eebc8f373b5c761dd9d92ff01cb4b6132dbb9081/comments", "author": null, "committer": null, "parents": [{"sha": "6fe818aa72b3d739ece3470abc2954f07c288d9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fe818aa72b3d739ece3470abc2954f07c288d9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fe818aa72b3d739ece3470abc2954f07c288d9c"}], "stats": {"total": 100, "additions": 72, "deletions": 28}, "files": [{"sha": "80cce3209fc97dbbeac0a94a9bc445737215e3da", "filename": "gcc/dwarf2cfi.c", "status": "modified", "additions": 72, "deletions": 28, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eebc8f373b5c761dd9d92ff01cb4b6132dbb9081/gcc%2Fdwarf2cfi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eebc8f373b5c761dd9d92ff01cb4b6132dbb9081/gcc%2Fdwarf2cfi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.c?ref=eebc8f373b5c761dd9d92ff01cb4b6132dbb9081", "patch": "@@ -2355,13 +2355,23 @@ create_trace_edges (rtx insn)\n     }\n }\n \n+/* A subroutine of scan_trace.  Do what needs to be done \"after\" INSN.  */\n+\n+static void\n+scan_insn_after (rtx insn)\n+{\n+  if (RTX_FRAME_RELATED_P (insn))\n+    dwarf2out_frame_debug (insn);\n+  notice_args_size (insn);\n+}\n+\n /* Scan the trace beginning at INSN and create the CFI notes for the\n    instructions therein.  */\n \n static void\n scan_trace (dw_trace_info *trace)\n {\n-  rtx insn = trace->head;\n+  rtx prev, insn = trace->head;\n   dw_cfa_location this_cfa;\n \n   if (dump_file)\n@@ -2378,10 +2388,14 @@ scan_trace (dw_trace_info *trace)\n   this_cfa = cur_row->cfa;\n   cur_cfa = &this_cfa;\n \n-  for (insn = NEXT_INSN (insn); insn ; insn = NEXT_INSN (insn))\n+  for (prev = insn, insn = NEXT_INSN (insn);\n+       insn;\n+       prev = insn, insn = NEXT_INSN (insn))\n     {\n+      rtx control;\n+\n       /* Do everything that happens \"before\" the insn.  */\n-      add_cfi_insn = PREV_INSN (insn);\n+      add_cfi_insn = prev;\n \n       /* Notice the end of a trace.  */\n       if (BARRIER_P (insn))\n@@ -2401,34 +2415,25 @@ scan_trace (dw_trace_info *trace)\n       if (DEBUG_INSN_P (insn) || !inside_basic_block_p (insn))\n \tcontinue;\n \n-      /* Flush data before calls and jumps, and of course if necessary.  */\n-      if (can_throw_internal (insn))\n-\t{\n-\t  dwarf2out_flush_queued_reg_saves ();\n-\t  notice_eh_throw (insn);\n-\t}\n-      else if (!NONJUMP_INSN_P (insn)\n-\t       || clobbers_queued_reg_save (insn)\n-\t       || find_reg_note (insn, REG_CFA_FLUSH_QUEUE, NULL))\n-\tdwarf2out_flush_queued_reg_saves ();\n-\n-      /* Do everything that happens \"after\" the insn.  */\n-      add_cfi_insn = insn;\n-\n-      /* Handle changes to the row state.  */\n-      if (RTX_FRAME_RELATED_P (insn))\n-\tdwarf2out_frame_debug (insn);\n-\n-      /* Look for REG_ARGS_SIZE, and handle it.  */\n+      /* Handle all changes to the row state.  Sequences require special\n+\t handling for the positioning of the notes.  */\n       if (GET_CODE (PATTERN (insn)) == SEQUENCE)\n \t{\n \t  rtx elt, pat = PATTERN (insn);\n \t  int i, n = XVECLEN (pat, 0);\n \n-\t  if (INSN_ANNULLED_BRANCH_P (XVECEXP (pat, 0, 0)))\n+\t  control = XVECEXP (pat, 0, 0);\n+\t  if (can_throw_internal (control))\n+\t    notice_eh_throw (control);\n+\t  dwarf2out_flush_queued_reg_saves ();\n+\n+\t  if (INSN_ANNULLED_BRANCH_P (control))\n \t    {\n \t      /* ??? Hopefully multiple delay slots are not annulled.  */\n \t      gcc_assert (n == 2);\n+\t      gcc_assert (!RTX_FRAME_RELATED_P (control));\n+\t      gcc_assert (!find_reg_note (control, REG_ARGS_SIZE, NULL));\n+\n \t      elt = XVECEXP (pat, 0, 1);\n \n \t      /* If ELT is an instruction from target of an annulled branch,\n@@ -2438,11 +2443,16 @@ scan_trace (dw_trace_info *trace)\n \t\t{\n \t\t  HOST_WIDE_INT restore_args_size;\n \n+\t\t  add_cfi_insn = NULL;\n \t\t  restore_args_size = cur_trace->end_true_args_size;\n \t\t  cur_cfa = &cur_row->cfa;\n \n-\t\t  notice_args_size (elt);\n-\t\t  create_trace_edges (insn);\n+\t\t  scan_insn_after (elt);\n+\n+\t\t  /* ??? Should we instead save the entire row state?  */\n+\t\t  gcc_assert (!VEC_length (queued_reg_save, queued_reg_saves));\n+\n+\t\t  create_trace_edges (control);\n \n \t\t  cur_trace->end_true_args_size = restore_args_size;\n \t\t  cur_row->cfa = this_cfa;\n@@ -2451,14 +2461,48 @@ scan_trace (dw_trace_info *trace)\n \t\t}\n \t    }\n \n+\t  /* The insns in the delay slot should all be considered to happen\n+\t     \"before\" a call insn.  Consider a call with a stack pointer\n+\t     adjustment in the delay slot.  The backtrace from the callee\n+\t     should include the sp adjustment.  Unfortunately, that leaves\n+\t     us with an unavoidable unwinding error exactly at the call insn\n+\t     itself.  For jump insns we'd prefer to avoid this error by\n+\t     placing the notes after the sequence.  */\n+\t  if (JUMP_P (control))\n+\t    add_cfi_insn = insn;\n+\n \t  for (i = 1; i < n; ++i)\n \t    {\n \t      elt = XVECEXP (pat, 0, i);\n-\t      notice_args_size (elt);\n+\t      scan_insn_after (elt);\n \t    }\n+\n+\t  /* Make sure any register saves are visible at the jump target.  */\n+\t  dwarf2out_flush_queued_reg_saves ();\n+\n+          /* However, if there is some adjustment on the call itself, e.g.\n+\t     a call_pop, that action should be considered to happen after\n+\t     the call returns.  */\n+\t  add_cfi_insn = insn;\n+\t  scan_insn_after (control);\n \t}\n       else\n-\tnotice_args_size (insn);\n+\t{\n+\t  /* Flush data before calls and jumps, and of course if necessary.  */\n+\t  if (can_throw_internal (insn))\n+\t    {\n+\t      notice_eh_throw (insn);\n+\t      dwarf2out_flush_queued_reg_saves ();\n+\t    }\n+\t  else if (!NONJUMP_INSN_P (insn)\n+\t\t   || clobbers_queued_reg_save (insn)\n+\t\t   || find_reg_note (insn, REG_CFA_FLUSH_QUEUE, NULL))\n+\t    dwarf2out_flush_queued_reg_saves ();\n+\n+\t  add_cfi_insn = insn;\n+\t  scan_insn_after (insn);\n+\t  control = insn;\n+\t}\n \n       /* Between frame-related-p and args_size we might have otherwise\n \t emitted two cfa adjustments.  Do it now.  */\n@@ -2468,7 +2512,7 @@ scan_trace (dw_trace_info *trace)\n \t same tests as are done to actually create the edges.  So\n \t always call the routine and let it not create edges for\n \t non-control-flow insns.  */\n-      create_trace_edges (insn);\n+      create_trace_edges (control);\n     }\n \n   add_cfi_insn = NULL;"}]}