{"sha": "f5a1b0d2167f711c45f0d5991dcded3cd756bcf1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjVhMWIwZDIxNjdmNzExYzQ1ZjBkNTk5MWRjZGVkM2NkNzU2YmNmMQ==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "1999-02-22T16:47:59Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "1999-02-22T16:47:59Z"}, "message": "Apply ARM/Linux patches.\n\nRework cpu/architecture command line parsing.\n\nFrom-SVN: r25380", "tree": {"sha": "a2fe88d03bd68ea8ca2592dc1d58cf9345eeb24f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2fe88d03bd68ea8ca2592dc1d58cf9345eeb24f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f5a1b0d2167f711c45f0d5991dcded3cd756bcf1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5a1b0d2167f711c45f0d5991dcded3cd756bcf1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5a1b0d2167f711c45f0d5991dcded3cd756bcf1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5a1b0d2167f711c45f0d5991dcded3cd756bcf1/comments", "author": null, "committer": null, "parents": [{"sha": "956662b2f57bebdcbf8b97686cf24436521b2a22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/956662b2f57bebdcbf8b97686cf24436521b2a22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/956662b2f57bebdcbf8b97686cf24436521b2a22"}], "stats": {"total": 960, "additions": 581, "deletions": 379}, "files": [{"sha": "719f6c11e1708cbe0a2327e2cfffaee2932d5bfb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5a1b0d2167f711c45f0d5991dcded3cd756bcf1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5a1b0d2167f711c45f0d5991dcded3cd756bcf1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f5a1b0d2167f711c45f0d5991dcded3cd756bcf1", "patch": "@@ -1,3 +1,67 @@\n+1999-02-22  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* config/arm/arm.h: Add TARGET_CPU_strongarm1100.\n+\tAdd -mno-sched command line switch to disable scheduling of\n+\tinstructions into the function's prologue.\n+\t(enum processor_type): Remove.\n+\t(TARGET_OPTIONS): Add \"fpe=\" option to match documentation.\n+\t(struct arm_cpu_select): Replace 'set_tune_p' and 'set_arch_p'\n+\tfields with 'processors' field.\n+\t(CONDITIONAL_REGISTER_USAGE): Allow r10 to be used if stack\n+\tchecking is not enabled.\n+\t(RETURN_IN_MEMORY): Always call arm_return_in_memory.\n+\t\n+\t* config/arm/arm.c: (arm_cpu): Remove.\n+\t(tune_flags): Remove.\n+\t(arm_is_strong): New variable: true iff the target processor is a \n+\tStrongARM.\n+\t(arm_is_6_or_7): New variable: true iff the target processor is an\n+\tARM6 or and ARM7.\n+\t(arm_select): Fields reorganised.\n+\t(struct processors): processor_type field removed.\n+\t(all_procs): Remove.\n+\t(all_cores): New array: Definitions of all known ARM cpu cores.\n+\t(all_architectures): New array: Definitions of all known ARM\n+\tarchitectures. \n+\t(streq): New macro.\n+\t(FL_SCHED): New processor flag: processor required load\n+\tscheduling.\n+\t(FL_STRONG): New processor flag: processor is a StrongARM.\n+\t(arm_override_options): Reorganised to make code clearer.\n+\t(use_return_insn): Test for \"not (TARGET_APCS and\n+\tframe_pointer_needed)\".\n+\t(arm_return_in_memory): Improve handling of structures.\n+\t\n+\t* config/arm/arm.md: Remove \"cpu\" attribute.  Replace with\n+\t\"is_strongarm\" and \"is_arm_6_or_7\" attributes.\n+\t(zero_extendhisi2): Check for TARGET_SHORT_BY_BYTES before\n+\tarm_arch4.\n+\t(extendhisi2):  Check for TARGET_SHORT_BY_BYTES before arm_arch4. \n+\n+\t* invoke.texi (ARM Options): Document -mtune= and -mfp= options.\n+\t\n+1999-02-22  Philip Blundell  <philb@gnu.org>\n+\n+\t* config/arm/linux-gas.h (INITIALIZE_TRAMPOLINE): Replace default\n+\tdefinition with one including cache synchronisation.\n+\t(CLEAR_INSN_CACHE): Correct syscall number and enable definition.\n+\tMove definition of inhibit_libc to...\n+\t* config/arm/xm-linux.h: ... here.\n+\n+\t* config/arm/t-linux: Disable multilib configurations since the\n+\tonly effect for most people is to cause builds to fail.\n+\t\n+\t* config/arm/elf.h (ASM_FILE_START): Add .file directive.\n+\t(ASM_SPEC): Translate -mapcs-float to -mfloat for the assembler.\n+\n+\t* config/arm/linux-elf.h (DEFAULT_VTABLE_THUNKS): Define.\n+\t(HANDLE_SYSV_PRAGMA): Likewise.\n+\t(LIB_SPEC): Copy definition from generic Linux files.\n+\t(LIBGCC_SPEC): Include -lfloat if -msoft-float was given.\n+\t(FP_DEFAULT): Set to SOFT3 on 32-bit targets.\n+\t(DWARF2_DEBUGGING_INFO): Define.\n+\t(PREFERRED_DEBUGGING_TYPE): Define as DBX_DEBUG.\n+\n Mon Feb 22 16:54:18 EST 1999  Andrew MacLeod  <amacleod@cygnus.com>\n \n \t* loop.c (libcall_other_regs): Make extern."}, {"sha": "6866da554a4eb08046ceab201eb4f4415088fe26", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 339, "deletions": 233, "changes": 572, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5a1b0d2167f711c45f0d5991dcded3cd756bcf1/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5a1b0d2167f711c45f0d5991dcded3cd756bcf1/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=f5a1b0d2167f711c45f0d5991dcded3cd756bcf1", "patch": "@@ -42,8 +42,8 @@ Boston, MA 02111-1307, USA.  */\n    possible.  */\n static int max_insns_skipped = 5;\n \n+extern FILE * asm_out_file;\n /* Some function declarations.  */\n-extern FILE *asm_out_file;\n \n static HOST_WIDE_INT int_log2 PROTO ((HOST_WIDE_INT));\n static char *output_multi_immediate PROTO ((rtx *, char *, char *, int,\n@@ -74,9 +74,6 @@ static enum arm_cond_code get_arm_condition_code PROTO ((rtx));\n rtx arm_compare_op0, arm_compare_op1;\n int arm_compare_fp;\n \n-/* What type of cpu are we compiling for? */\n-enum processor_type arm_cpu;\n-\n /* What type of floating point are we tuning for? */\n enum floating_point_type arm_fpu;\n \n@@ -87,7 +84,7 @@ enum floating_point_type arm_fpu_arch;\n enum prog_mode_type arm_prgmode;\n \n /* Set by the -mfp=... option */\n-char *target_fp_name = NULL;\n+char * target_fp_name = NULL;\n \n /* Used to parse -mstructure_size_boundary command line option.  */\n char * structure_size_string = NULL;\n@@ -99,8 +96,14 @@ int arm_fast_multiply = 0;\n /* Nonzero if this chip supports the ARM Architecture 4 extensions */\n int arm_arch4 = 0;\n \n-/* Set to the features we should tune the code for (multiply speed etc). */\n-int tune_flags = 0;\n+/* Nonzero if this chip can benefit from laod scheduling.  */\n+int arm_ld_sched = 0;\n+\n+/* Nonzero if this chip is a StrongARM.  */\n+int arm_is_strong = 0;\n+\n+/* Nonzero if this chip is a an ARM6 or an ARM7.  */\n+int arm_is_6_or_7 = 0;\n \n /* In case of a PRE_INC, POST_INC, PRE_DEC, POST_DEC memory reference, we\n    must report the mode of the memory reference from PRINT_OPERAND to\n@@ -134,157 +137,139 @@ rtx arm_target_insn;\n int arm_target_label;\n \n /* The condition codes of the ARM, and the inverse function.  */\n-char *arm_condition_codes[] =\n+char * arm_condition_codes[] =\n {\n   \"eq\", \"ne\", \"cs\", \"cc\", \"mi\", \"pl\", \"vs\", \"vc\",\n   \"hi\", \"ls\", \"ge\", \"lt\", \"gt\", \"le\", \"al\", \"nv\"\n };\n \n static enum arm_cond_code get_arm_condition_code ();\n \n+#define streq(string1, string2) (strcmp (string1, string2) == 0)\n \f\n /* Initialization code */\n \n-struct arm_cpu_select arm_select[4] =\n-{\n-  /* switch\tname,\t\ttune\tarch */\n-  { (char *)0,\t\"--with-cpu=\",\t1,\t1 },\n-  { (char *)0,\t\"-mcpu=\",\t1,\t1 },\n-  { (char *)0,\t\"-march=\",\t0,\t1 },\n-  { (char *)0,\t\"-mtune=\",\t1,\t0 },\n-};\n-\n #define FL_CO_PROC    0x01            /* Has external co-processor bus */\n #define FL_FAST_MULT  0x02            /* Fast multiply */\n #define FL_MODE26     0x04            /* 26-bit mode support */\n #define FL_MODE32     0x08            /* 32-bit mode support */\n #define FL_ARCH4      0x10            /* Architecture rel 4 */\n #define FL_THUMB      0x20            /* Thumb aware */\n+#define FL_LDSCHED    0x40\t      /* Load scheduling necessary */\n+#define FL_STRONG     0x80\t      /* StrongARM */\n \n struct processors\n {\n-  char *name;\n-  enum processor_type type;\n+  char *       name;\n   unsigned int flags;\n };\n \n /* Not all of these give usefully different compilation alternatives,\n    but there is no simple way of generalizing them.  */\n-static struct processors all_procs[] =\n+static struct processors all_cores[] =\n {\n-  {\"arm2\",\tPROCESSOR_ARM2, FL_CO_PROC | FL_MODE26},\n-  {\"arm250\",\tPROCESSOR_ARM2, FL_CO_PROC | FL_MODE26},\n-  {\"arm3\",\tPROCESSOR_ARM2, FL_CO_PROC | FL_MODE26},\n-  {\"arm6\",\tPROCESSOR_ARM6, FL_CO_PROC | FL_MODE32 | FL_MODE26},\n-  {\"arm600\",\tPROCESSOR_ARM6, FL_CO_PROC | FL_MODE32 | FL_MODE26},\n-  {\"arm610\",\tPROCESSOR_ARM6, FL_MODE32 | FL_MODE26},\n-  {\"arm7\",\tPROCESSOR_ARM7, FL_CO_PROC | FL_MODE32 | FL_MODE26},\n-  /* arm7m doesn't exist on its own, only in conjunction with D, (and I), but\n-     those don't alter the code, so it is sometimes known as the arm7m */\n-  {\"arm7m\",\tPROCESSOR_ARM7, (FL_CO_PROC | FL_FAST_MULT | FL_MODE32\n-\t\t\t\t | FL_MODE26)},\n-  {\"arm7dm\",\tPROCESSOR_ARM7, (FL_CO_PROC | FL_FAST_MULT | FL_MODE32\n-\t\t\t\t | FL_MODE26)},\n-  {\"arm7dmi\",\tPROCESSOR_ARM7, (FL_CO_PROC | FL_FAST_MULT | FL_MODE32\n-\t\t\t\t | FL_MODE26)},\n-  {\"arm700\",\tPROCESSOR_ARM7, FL_CO_PROC | FL_MODE32 | FL_MODE26},\n-  {\"arm710\",\tPROCESSOR_ARM7, FL_MODE32 | FL_MODE26},\n-  {\"arm7100\",\tPROCESSOR_ARM7, FL_MODE32 | FL_MODE26},\n-  {\"arm7500\",\tPROCESSOR_ARM7, FL_MODE32 | FL_MODE26},\n-  /* Doesn't really have an external co-proc, but does have embedded fpu */\n-  {\"arm7500fe\",\tPROCESSOR_ARM7, FL_CO_PROC | FL_MODE32 | FL_MODE26},\n-  {\"arm7tdmi\",\tPROCESSOR_ARM7, (FL_CO_PROC | FL_FAST_MULT | FL_MODE32\n-\t\t\t\t | FL_ARCH4 | FL_THUMB)},\n-  {\"arm8\",\tPROCESSOR_ARM8, (FL_FAST_MULT | FL_MODE32 | FL_MODE26\n-\t\t\t\t | FL_ARCH4)},\n-  {\"arm810\",\tPROCESSOR_ARM8, (FL_FAST_MULT | FL_MODE32 | FL_MODE26\n-\t\t\t\t | FL_ARCH4)},\n-  /* The next two are the same, but arm9 only exists in the thumb variant */\n-  {\"arm9\",\tPROCESSOR_ARM9, (FL_FAST_MULT | FL_MODE32 | FL_ARCH4\n-\t\t\t\t | FL_THUMB)},\n-  {\"arm9tdmi\",\tPROCESSOR_ARM9, (FL_FAST_MULT | FL_MODE32 | FL_ARCH4\n-\t\t\t\t | FL_THUMB)},\n-  {\"strongarm\",\tPROCESSOR_STARM, (FL_FAST_MULT | FL_MODE32 | FL_MODE26\n-\t\t\t\t  | FL_ARCH4)},\n-  {\"strongarm110\", PROCESSOR_STARM, (FL_FAST_MULT | FL_MODE32 | FL_MODE26\n-\t\t\t\t     | FL_ARCH4)},\n-  {\"armv2\",\tPROCESSOR_NONE, FL_CO_PROC | FL_MODE26},\n-  {\"armv2a\",\tPROCESSOR_NONE, FL_CO_PROC | FL_MODE26},\n-  {\"armv3\",\tPROCESSOR_NONE, FL_CO_PROC | FL_MODE32 | FL_MODE26},\n-  {\"armv3m\",\tPROCESSOR_NONE, (FL_CO_PROC | FL_FAST_MULT | FL_MODE32\n-\t\t\t\t | FL_MODE26)},\n-  {\"armv4\",\tPROCESSOR_NONE, (FL_CO_PROC | FL_FAST_MULT | FL_MODE32\n-\t\t\t\t | FL_MODE26 | FL_ARCH4)},\n+  /* ARM Cores */\n+  \n+  {\"arm2\",\tFL_CO_PROC | FL_MODE26 },\n+  {\"arm250\",\tFL_CO_PROC | FL_MODE26 },\n+  {\"arm3\",\tFL_CO_PROC | FL_MODE26 },\n+  {\"arm6\",\tFL_CO_PROC | FL_MODE26 | FL_MODE32 },\n+  {\"arm60\",\tFL_CO_PROC | FL_MODE26 | FL_MODE32 },\n+  {\"arm600\",\tFL_CO_PROC | FL_MODE26 | FL_MODE32 },\n+  {\"arm610\",\t             FL_MODE26 | FL_MODE32 },\n+  {\"arm620\",\tFL_CO_PROC | FL_MODE26 | FL_MODE32 },\n+  {\"arm7\",\tFL_CO_PROC | FL_MODE26 | FL_MODE32 }, \n+  {\"arm7m\",\tFL_CO_PROC | FL_MODE26 | FL_MODE32 | FL_FAST_MULT }, /* arm7m doesn't exist on its own, */\n+  {\"arm7d\",\tFL_CO_PROC | FL_MODE26 | FL_MODE32 }, \t\t     /* but only with D, (and I),       */\n+  {\"arm7dm\",\tFL_CO_PROC | FL_MODE26 | FL_MODE32 | FL_FAST_MULT }, /* but those don't alter the code, */\n+  {\"arm7di\",\tFL_CO_PROC | FL_MODE26 | FL_MODE32 },\t\t     /* so arm7m is sometimes used.     */\n+  {\"arm7dmi\",\tFL_CO_PROC | FL_MODE26 | FL_MODE32 | FL_FAST_MULT },\n+  {\"arm70\",\tFL_CO_PROC | FL_MODE26 | FL_MODE32 },\n+  {\"arm700\",\tFL_CO_PROC | FL_MODE26 | FL_MODE32 },\n+  {\"arm700i\",\tFL_CO_PROC | FL_MODE26 | FL_MODE32 },\n+  {\"arm710\",\t             FL_MODE26 | FL_MODE32 },\n+  {\"arm710c\",\t             FL_MODE26 | FL_MODE32 },\n+  {\"arm7100\",\t             FL_MODE26 | FL_MODE32 },\n+  {\"arm7500\",\t             FL_MODE26 | FL_MODE32 },\n+  {\"arm7500fe\",\tFL_CO_PROC | FL_MODE26 | FL_MODE32 }, /* Doesn't really have an external co-proc, but does have embedded fpu.  */\n+  {\"arm7tdmi\",\tFL_CO_PROC |             FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB },\n+  {\"arm8\",\t             FL_MODE26 | FL_MODE32 | FL_FAST_MULT | FL_ARCH4 |            FL_LDSCHED },\n+  {\"arm810\",\t             FL_MODE26 | FL_MODE32 | FL_FAST_MULT | FL_ARCH4 |            FL_LDSCHED },\n+  {\"arm9\",\t                         FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB | FL_LDSCHED },\n+  {\"arm9tdmi\",\t                         FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB | FL_LDSCHED },\n+  {\"strongarm\",\t             FL_MODE26 | FL_MODE32 | FL_FAST_MULT | FL_ARCH4 |            FL_LDSCHED | FL_STRONG },\n+  {\"strongarm110\",           FL_MODE26 | FL_MODE32 | FL_FAST_MULT | FL_ARCH4 |            FL_LDSCHED | FL_STRONG },\n+  {\"strongarm1100\",          FL_MODE26 | FL_MODE32 | FL_FAST_MULT | FL_ARCH4 |            FL_LDSCHED | FL_STRONG },\n+  \n+  {NULL, 0}\n+};\n+\n+static struct processors all_architectures[] =\n+{\n+  /* ARM Architectures */\n+  \n+  {\"armv2\",     FL_CO_PROC | FL_MODE26 },\n+  {\"armv2a\",    FL_CO_PROC | FL_MODE26 },\n+  {\"armv3\",     FL_CO_PROC | FL_MODE26 | FL_MODE32 },\n+  {\"armv3m\",    FL_CO_PROC | FL_MODE26 | FL_MODE32 | FL_FAST_MULT },\n+  {\"armv4\",     FL_CO_PROC | FL_MODE26 | FL_MODE32 | FL_FAST_MULT | FL_ARCH4  },\n   /* Strictly, FL_MODE26 is a permitted option for v4t, but there are no\n      implementations that support it, so we will leave it out for now.  */\n-  {\"armv4t\",\tPROCESSOR_NONE, (FL_CO_PROC | FL_FAST_MULT | FL_MODE32\n-\t\t\t\t | FL_ARCH4)},\n-  {NULL, 0, 0}\n+  {\"armv4t\",    FL_CO_PROC |             FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB },\n+  {NULL, 0}\n+};\n+\n+/* This is a magic stucture.  The 'string' field is magically filled in\n+   with a pointer to the value specified by the user on the command line\n+   assuming that the user has specified such a value.  */\n+\n+struct arm_cpu_select arm_select[] =\n+{\n+  /* string\t  name            processors  */\t\n+  { NULL,\t\"-mcpu=\",\tall_cores  },\n+  { NULL,\t\"-march=\",\tall_architectures },\n+  { NULL,\t\"-mtune=\",\tall_cores }\n };\n \n /* Fix up any incompatible options that the user has specified.\n    This has now turned into a maze.  */\n void\n arm_override_options ()\n {\n-  int arm_thumb_aware = 0;\n-  int flags = 0;\n+  unsigned int flags = 0;\n   unsigned i;\n   struct arm_cpu_select * ptr;\n-  static struct cpu_default\n-  {\n-    int    cpu;\n-    char * name;\n-  }\n-  cpu_defaults[] =\n-  {\n-    { TARGET_CPU_arm2, \"arm2\" },\n-    { TARGET_CPU_arm6, \"arm6\" },\n-    { TARGET_CPU_arm610, \"arm610\" },\n-    { TARGET_CPU_arm7dm, \"arm7dm\" },\n-    { TARGET_CPU_arm7500fe, \"arm7500fe\" },\n-    { TARGET_CPU_arm7tdmi, \"arm7tdmi\" },\n-    { TARGET_CPU_arm8, \"arm8\" },\n-    { TARGET_CPU_arm810, \"arm810\" },\n-    { TARGET_CPU_strongarm, \"strongarm\" },\n-    { 0, 0 }\n-  };\n-  struct cpu_default *def;\n-\n-  /* Set the default.  */\n-  for (def = &cpu_defaults[0]; def->name; ++def)\n-    if (def->cpu == TARGET_CPU_DEFAULT)\n-      break;\n-  if (! def->name)\n-    abort ();\n-\n-  arm_select[0].string = def->name;\n-\n-  for (i = 0; i < sizeof (arm_select) / sizeof (arm_select[0]); i++)\n+  \n+  /* Set up the flags based on the cpu/architecture selected by the user.  */\n+  for (i = sizeof (arm_select) / sizeof (arm_select[0]); i--;)\n     {\n-      ptr = &arm_select[i];\n-      if (ptr->string != (char *)0 && ptr->string[0] != '\\0')\n+      struct arm_cpu_select * ptr = arm_select + i;\n+      \n+      if (ptr->string != NULL && ptr->string[0] != '\\0')\n         {\n-\t  struct processors *sel;\n+\t  struct processors * sel;\n \n-          for (sel = all_procs; sel->name != NULL; sel++)\n-            if (! strcmp (ptr->string, sel->name))\n+          for (sel = ptr->processors; sel->name != NULL; sel ++)\n+            if (streq (ptr->string, sel->name))\n               {\n-\t\t/* -march= is the only flag that can take an architecture\n-\t\t   type, so if we match when the tune bit is set, the\n-\t\t   option was invalid.  */\n-                if (ptr->set_tune_p)\n+\t\tif (flags != 0)\n \t\t  {\n-\t\t    if (sel->type == PROCESSOR_NONE)\n-\t\t      continue; /* Its an architecture, not a cpu */\n-\n-                    arm_cpu = sel->type;\n-\t\t    tune_flags = sel->flags;\n+\t\t    /* We scan the arm_select array in the order:\n+\t\t         tune -> arch -> cpu\n+\t\t       So if we have been asked to tune for, say, an ARM8,\n+\t\t       but we are told that the cpu is only an ARM6, then\n+\t\t       we have problems.  We detect this by seeing if the\n+\t\t       flags bits accumulated so far can be supported by the\n+\t\t       cpu/architecture type now being parsed.  If they can,\n+\t\t       then OR in any new bits.  If they cannot then report\n+\t\t       an error.  */\n+\t\t    if ((flags & sel->flags) != flags)\n+\t\t      error (\"switch %s%s overridden by another switch\",\n+\t\t\t     ptr->string, sel->name );\n \t\t  }\n \n-                if (ptr->set_arch_p)\n-\t\t  flags = sel->flags;\n-\n+\t\tflags = sel->flags;\n+\t\t\n                 break;\n               }\n \n@@ -293,23 +278,141 @@ arm_override_options ()\n         }\n     }\n \n+  /* If the user did not specify a processor, choose one for them.  */\n+  if (flags == 0)\n+    {\n+      struct processors * sel;\n+      int                 sought = 0;\n+      \n+      if (TARGET_THUMB_INTERWORK)\n+\t{\n+\t  sought |= FL_THUMB;\n+\n+\t  /* Force apcs-32 to be used for Thumb targets.  */\n+\t  target_flags |= ARM_FLAG_APCS_32;\n+\t}\n+      \n+      if (TARGET_APCS_32)\n+\tsought |= FL_MODE32;\n+      else\n+\tsought |= FL_MODE26;\n+\n+      if (sought != 0)\n+\t{\n+\t  for (sel = all_cores; sel->name != NULL; sel++)\n+\t    if ((sel->flags & sought) == sought)\n+\t      {\n+\t\tflags = sel->flags;\n+\t\tbreak;\n+\t      }\n+\t  \n+\t  if (sel->name == NULL)\n+\t    fatal (\"Unable to select a cpu that matches command line specification\");\n+\t}\n+      else\n+\t{\n+\t  /* The user did not specify any command line switches that require\n+\t     a certain kind of CPU.  Use TARGET_CPU_DEFAULT instead.  */\n+\n+\t  static struct cpu_default\n+\t  {\n+\t    int    cpu;\n+\t    char * name;\n+\t  }\n+\t  cpu_defaults[] =\n+\t  {\n+\t    { TARGET_CPU_arm2,      \"arm2\" },\n+\t    { TARGET_CPU_arm6,      \"arm6\" },\n+\t    { TARGET_CPU_arm610,    \"arm610\" },\n+\t    { TARGET_CPU_arm7m,     \"arm7m\" },\n+\t    { TARGET_CPU_arm7500fe, \"arm7500fe\" },\n+\t    { TARGET_CPU_arm7tdmi,  \"arm7tdmi\" },\n+\t    { TARGET_CPU_arm8,      \"arm8\" },\n+\t    { TARGET_CPU_arm810,    \"arm810\" },\n+\t    { TARGET_CPU_arm9,      \"arm9\" },\n+\t    { TARGET_CPU_strongarm, \"strongarm\" },\n+\t    { TARGET_CPU_generic,   \"arm\" },\n+\t    { 0, 0 }\n+\t  };\n+\t  struct cpu_default * def;\n+\t  \n+\t  /* Find the default.  */\n+\t  for (def = cpu_defaults; def->name; def ++)\n+\t    if (def->cpu == TARGET_CPU_DEFAULT)\n+\t      break;\n+\t  \n+\t  if (def->name == NULL)\n+\t    abort ();\n+\n+\t  /* Find the default CPU's flags.  */\n+\t  for (sel = all_cores; sel->name != NULL; sel ++)\n+\t    if (streq (def->name, sel->name))\n+\t      break;\n+\n+\t  if (sel->name == NULL)\n+\t    abort ();\n+\n+\t  flags = sel->flags;\n+\t}\n+    }\n+\n+  /* Cope with some redundant flags.  */\n+  if (TARGET_6)\n+    {\n+      warning (\"Option '-m6' deprecated.  Use: '-mapcs-32' or -mcpu=<proc>\");\n+      target_flags |= ARM_FLAG_APCS_32;\n+    }\n+  \n+  if (TARGET_3)\n+    {\n+      warning (\"Option '-m3' deprecated.  Use: '-mapcs-26' or -mcpu=<proc>\");\n+      target_flags &= ~ARM_FLAG_APCS_32;\n+    }\n+\n+  /* Make sure that the processor choice does not conflict with any of the\n+     other command line choices.  */\n+  if (TARGET_APCS_32 && !(flags & FL_MODE32))\n+    {\n+      warning (\"target CPU does not support APCS-32\" );\n+      target_flags &= ~ ARM_FLAG_APCS_32;\n+    }\n+  else if (! TARGET_APCS_32 && !(flags & FL_MODE26))\n+    {\n+      warning (\"target CPU does not support APCS-26\" );\n+      target_flags |= ARM_FLAG_APCS_32;\n+    }\n+  \n+  if (TARGET_THUMB_INTERWORK && !(flags & FL_THUMB))\n+    {\n+      warning (\"target CPU does not support interworking\" );\n+      target_flags &= ~ARM_FLAG_THUMB;\n+    }\n+  \n+  /* If interworking is enabled then APCS-32 must be selected as well.  */\n+  if (TARGET_THUMB_INTERWORK)\n+    {\n+      if (! TARGET_APCS_32)\n+\twarning (\"interworking forces APCS-32 to be used\" );\n+      target_flags |= ARM_FLAG_APCS_32;\n+    }\n+  \n+  if (TARGET_APCS_STACK && ! TARGET_APCS)\n+    {\n+      warning (\"-mapcs-stack-check incompatible with -mno-apcs-frame\");\n+      target_flags |= ARM_FLAG_APCS_FRAME;\n+    }\n+\n   if (write_symbols != NO_DEBUG && flag_omit_frame_pointer)\n     warning (\"-g with -fomit-frame-pointer may not give sensible debugging\");\n \n   if (TARGET_POKE_FUNCTION_NAME)\n     target_flags |= ARM_FLAG_APCS_FRAME;\n \n-  if (TARGET_6)\n-    warning (\"Option '-m6' deprecated.  Use: '-mapcs-32' or -mcpu=<proc>\");\n-\n-  if (TARGET_3)\n-    warning (\"Option '-m3' deprecated.  Use: '-mapcs-26' or -mcpu=<proc>\");\n-\n   if (TARGET_APCS_REENT && flag_pic)\n     fatal (\"-fpic and -mapcs-reent are incompatible\");\n \n   if (TARGET_APCS_REENT)\n-    warning (\"APCS reentrant code not supported.\");\n+    warning (\"APCS reentrant code not supported.  Ignored\");\n \n   /* If stack checking is disabled, we can use r10 as the PIC register,\n      which keeps r9 available.  */\n@@ -326,93 +429,45 @@ arm_override_options ()\n   if (TARGET_APCS_FLOAT)\n     warning (\"Passing floating point arguments in fp regs not yet supported\");\n \n-  if (TARGET_APCS_STACK && ! TARGET_APCS)\n-    {\n-      warning (\"-mapcs-stack-check incompatible with -mno-apcs-frame\");\n-      target_flags |= ARM_FLAG_APCS_FRAME;\n-    }\n-\n-  /* Default is to tune for an FPA */\n-  arm_fpu = FP_HARD;\n-\n+  /* Initialise booleans used elsewhere in this file, and in arm.md  */\n+  arm_fast_multiply = (flags & FL_FAST_MULT) != 0;\n+  arm_arch4         = (flags & FL_ARCH4) != 0;\n+  arm_ld_sched      = (flags & FL_LDSCHED) != 0;\n+  arm_is_strong     = (flags & FL_STRONG);\n+  \n+  /* The arm.md file needs to know if theprocessor is an ARM6 or an ARM7  */\n+  arm_is_6_or_7 = ((flags & (FL_MODE26 | FL_MODE32)) && !(flags & FL_ARCH4));\n+  \n   /* Default value for floating point code... if no co-processor\n      bus, then schedule for emulated floating point.  Otherwise,\n      assume the user has an FPA.\n      Note: this does not prevent use of floating point instructions,\n      -msoft-float does that.  */\n-  if ((tune_flags & FL_CO_PROC) == 0)\n+  if ((flags & FL_CO_PROC) == 0)\n     arm_fpu = FP_SOFT3;\n-\n-  arm_fast_multiply = (flags & FL_FAST_MULT) != 0;\n-  arm_arch4 = (flags & FL_ARCH4) != 0;\n-  arm_thumb_aware = (flags & FL_THUMB) != 0;\n-\n+  else\n+    arm_fpu = FP_HARD;\n+  \n   if (target_fp_name)\n     {\n-      if (strcmp (target_fp_name, \"2\") == 0)\n+      if (streq (target_fp_name, \"2\"))\n \tarm_fpu_arch = FP_SOFT2;\n-      else if (strcmp (target_fp_name, \"3\") == 0)\n-\tarm_fpu_arch = FP_HARD;\n+      else if (streq (target_fp_name, \"3\"))\n+\tarm_fpu_arch = FP_SOFT3;\n       else\n-\tfatal (\"Invalid floating point emulation option: -mfpe=%s\",\n+\tfatal (\"Invalid floating point emulation option: -mfpe-%s\",\n \t       target_fp_name);\n     }\n   else\n     arm_fpu_arch = FP_DEFAULT;\n+  \n+  if (TARGET_FPE && arm_fpu != FP_HARD)\n+    arm_fpu = FP_SOFT2;\n \n-  if (TARGET_THUMB_INTERWORK && ! arm_thumb_aware)\n-    {\n-      warning (\"This processor variant does not support Thumb interworking\");\n-      target_flags &= ~ARM_FLAG_THUMB;\n-    }\n-\n-  if (TARGET_FPE && arm_fpu == FP_HARD)\n-    arm_fpu = FP_SOFT3;\n-\n-  /* If optimizing for space, don't synthesize constants */\n-  if (optimize_size)\n-    arm_constant_limit = 1;\n-\n-  /* Override a few things based on the tuning pararmeters.  */\n-  switch (arm_cpu)\n-    {\n-    case PROCESSOR_ARM2:\n-    case PROCESSOR_ARM3:\n-      /* For arm2/3 there is no need to do any scheduling if there is\n-\t only a floating point emulator, or we are doing software\n-\t floating-point.  */\n-      if (TARGET_SOFT_FLOAT || arm_fpu != FP_HARD)\n-\tflag_schedule_insns = flag_schedule_insns_after_reload = 0;\n-      break;\n-\n-    case PROCESSOR_ARM6:\n-    case PROCESSOR_ARM7:\n-      break;\n-\n-    case PROCESSOR_ARM8:\n-    case PROCESSOR_ARM9:\n-      /* For these processors, it never costs more than 2 cycles to load a\n-\t constant, and the load scheduler may well reduce that to 1.  */\n-      arm_constant_limit = 1;\n-      break;\n-\n-    case PROCESSOR_STARM:\n-      /* Same as above */\n-      arm_constant_limit = 1;\n-      /* StrongARM has early execution of branches, a sequence that is worth\n-\t skipping is shorter.  */\n-      max_insns_skipped = 3;\n-      break;\n-\n-    default:\n-      fatal (\"Unknown cpu type selected\");\n-      break;\n-    }\n-\n-  /* If optimizing for size, bump the number of instructions that we\n-     are prepared to conditionally execute (even on a StrongARM).  */\n-  if (optimize_size)\n-    max_insns_skipped = 6;\n+  /* For arm2/3 there is no need to do any scheduling if there is only\n+     a floating point emulator, or we are doing software floating-point.  */\n+  if ((TARGET_SOFT_FLOAT || arm_fpu != FP_HARD) && (flags & FL_MODE32) == 0)\n+    flag_schedule_insns = flag_schedule_insns_after_reload = 0;\n \n   arm_prog_mode = TARGET_APCS_32 ? PROG_MODE_PROG32 : PROG_MODE_PROG26;\n   \n@@ -425,6 +480,21 @@ arm_override_options ()\n       else\n \twarning (\"Structure size boundary can only be set to 8 or 32\");\n     }\n+  \n+  /* If optimizing for space, don't synthesize constants.\n+     For processors with load scheduling, it never costs more than 2 cycles\n+     to load a constant, and the load scheduler may well reduce that to 1.  */\n+  if (optimize_size || (flags & FL_LDSCHED))\n+    arm_constant_limit = 1;\n+\n+  /* If optimizing for size, bump the number of instructions that we\n+     are prepared to conditionally execute (even on a StrongARM). \n+     Otherwise for the StrongARM, which has early execution of branches,\n+     a sequence that is worth skipping is shorter.  */\n+  if (optimize_size)\n+    max_insns_skipped = 6;\n+  else if (arm_is_strong)\n+    max_insns_skipped = 3;\n }\n \f\n /* Return 1 if it is possible to return using a single instruction */\n@@ -435,19 +505,20 @@ use_return_insn (iscond)\n {\n   int regno;\n \n-  if (!reload_completed ||current_function_pretend_args_size\n+  if (!reload_completed\n+      || current_function_pretend_args_size\n       || current_function_anonymous_args\n       || ((get_frame_size () + current_function_outgoing_args_size != 0)\n-\t  && !(TARGET_APCS || frame_pointer_needed)))\n+\t  && !(TARGET_APCS && frame_pointer_needed)))\n     return 0;\n \n   /* Can't be done if interworking with Thumb, and any registers have been\n      stacked.  Similarly, on StrongARM, conditional returns are expensive\n      if they aren't taken and registers have been stacked.  */\n-  if (iscond && arm_cpu == PROCESSOR_STARM && frame_pointer_needed)\n+  if (iscond && arm_is_strong && frame_pointer_needed)\n     return 0;\n-  else if ((iscond && arm_cpu == PROCESSOR_STARM)\n-\t   || TARGET_THUMB_INTERWORK)\n+  if ((iscond && arm_is_strong)\n+      || TARGET_THUMB_INTERWORK)\n     for (regno = 0; regno < 16; regno++)\n       if (regs_ever_live[regno] && ! call_used_regs[regno])\n \treturn 0;\n@@ -888,7 +959,7 @@ arm_gen_constant (code, mode, val, target, source, subtargets, generate)\n \t\t\t\t      gen_rtx_NOT (mode, \n \t\t\t\t\t\t   gen_rtx_ASHIFT (mode,\n \t\t\t\t\t\t\t\t   source, \n-\t\t\t\t\t\t    shift))));\n+\t\t\t\t\t\t\t\t   shift))));\n \t      emit_insn (gen_rtx_SET (VOIDmode, target,\n \t\t\t\t      gen_rtx_NOT (mode,\n \t\t\t\t\t\t   gen_rtx_LSHIFTRT (mode, sub,\n@@ -909,11 +980,11 @@ arm_gen_constant (code, mode, val, target, source, subtargets, generate)\n \t\t\t\t      gen_rtx_NOT (mode,\n \t\t\t\t\t\t   gen_rtx_LSHIFTRT (mode,\n \t\t\t\t\t\t\t\t     source,\n-\t\t\t\t\t\t    shift))));\n+\t\t\t\t\t\t\t\t     shift))));\n \t      emit_insn (gen_rtx_SET (VOIDmode, target,\n \t\t\t\t      gen_rtx_NOT (mode,\n \t\t\t\t\t\t   gen_rtx_ASHIFT (mode, sub,\n-\t\t\t\t\t\t    shift))));\n+\t\t\t\t\t\t\t\t   shift))));\n \t    }\n \t  return 2;\n \t}\n@@ -1192,24 +1263,55 @@ arm_canonicalize_comparison (code, op1)\n \n   return code;\n }\n-\t\n \n-/* Handle aggregates that are not laid out in a BLKmode element.\n-   This is a sub-element of RETURN_IN_MEMORY.  */\n+/* Decide whether a type should be returned in memory (true)\n+   or in a register (false).  This is called by the macro\n+   RETURN_IN_MEMORY.  */\n int\n arm_return_in_memory (type)\n      tree type;\n {\n-  if (TREE_CODE (type) == RECORD_TYPE)\n+  if (! AGGREGATE_TYPE_P (type))\n+    {\n+      /* All simple types are returned in registers. */\n+      return 0;\n+    }\n+  else if (int_size_in_bytes (type) > 4)\n+    {\n+      /* All structures/unions bigger than one word are returned in memory. */\n+      return 1;\n+    }\n+  else if (TREE_CODE (type) == RECORD_TYPE)\n     {\n       tree field;\n \n-      /* For a struct, we can return in a register if every element was a\n-\t bit-field.  */\n-      for (field = TYPE_FIELDS (type); field;  field = TREE_CHAIN (field))\n-\tif (TREE_CODE (field) != FIELD_DECL\n-\t    || ! DECL_BIT_FIELD_TYPE (field))\n-\t  return 1;\n+      /* For a struct the APCS says that we must return in a register if\n+\t every addressable element has an offset of zero.  For practical\n+\t purposes this means that the structure can have at most one non\n+\t bit-field element and that this element must be the first one in\n+\t the structure.  */\n+\n+      /* Find the first field, ignoring non FIELD_DECL things which will\n+\t have been created by C++.  */\n+      for (field = TYPE_FIELDS (type);\n+\t   field && TREE_CODE (field) != FIELD_DECL;\n+\t   field = TREE_CHAIN (field))\n+\tcontinue;\n+      \n+      if (field == NULL)\n+\treturn 0; /* An empty structure.  Allowed by an extension to ANSI C. */\n+\n+      /* Now check the remaining fields, if any. */\n+      for (field = TREE_CHAIN (field);\n+\t   field;\n+\t   field = TREE_CHAIN (field))\n+\t{\n+\t  if (TREE_CODE (field) != FIELD_DECL)\n+\t    continue;\n+\t  \n+\t  if (! DECL_BIT_FIELD_TYPE (field))\n+\t    return 1;\n+\t}\n \n       return 0;\n     }\n@@ -1219,16 +1321,20 @@ arm_return_in_memory (type)\n \n       /* Unions can be returned in registers if every element is\n \t integral, or can be returned in an integer register.  */\n-      for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+      for (field = TYPE_FIELDS (type);\n+\t   field;\n+\t   field = TREE_CHAIN (field))\n \t{\n-\t  if (TREE_CODE (field) != FIELD_DECL\n-\t      || (AGGREGATE_TYPE_P (TREE_TYPE (field))\n-\t\t  && RETURN_IN_MEMORY (TREE_TYPE (field)))\n-\t      || FLOAT_TYPE_P (TREE_TYPE (field)))\n+\t  if (TREE_CODE (field) != FIELD_DECL)\n+\t    continue;\n+\n+\t  if (RETURN_IN_MEMORY (TREE_TYPE (field)))\n \t    return 1;\n \t}\n+      \n       return 0;\n     }\n+  \n   /* XXX Not sure what should be done for other aggregates, so put them in\n      memory. */\n   return 1;\n@@ -1389,7 +1495,7 @@ arm_finalize_pic ()\n \t\t\t    gen_rtx_PLUS (Pmode, global_offset_table, pc_rtx));\n \n   pic_rtx = gen_rtx_CONST (Pmode, gen_rtx_MINUS (Pmode, pic_tmp2, pic_tmp));\n-\n+  \n   emit_insn (gen_pic_load_addr (pic_offset_table_rtx, pic_rtx));\n   emit_jump_insn (gen_pic_add_dot_plus_eight(l1, pic_offset_table_rtx));\n   emit_label (l1);\n@@ -1570,7 +1676,7 @@ arm_rtx_costs (x, code, outer_code)\n \t  int add_cost = const_ok_for_arm (i) ? 4 : 8;\n \t  int j;\n \t  /* Tune as appropriate */ \n-\t  int booth_unit_size = ((tune_flags & FL_FAST_MULT) ? 8 : 2);\n+\t  int booth_unit_size = (arm_fast_multiply ? 8 : 2);\n \t  \n \t  for (j = 0; i && j < 32; j += booth_unit_size)\n \t    {\n@@ -1581,7 +1687,7 @@ arm_rtx_costs (x, code, outer_code)\n \t  return add_cost;\n \t}\n \n-      return (((tune_flags & FL_FAST_MULT) ? 8 : 30)\n+      return ((arm_fast_multiply ? 8 : 30)\n \t      + (REG_OR_SUBREG_REG (XEXP (x, 0)) ? 0 : 4)\n \t      + (REG_OR_SUBREG_REG (XEXP (x, 1)) ? 0 : 4));\n \n@@ -2595,9 +2701,7 @@ load_multiple_sequence (operands, nops, regs, base, load_offset)\n \n   /* For ARM8,9 & StrongARM, 2 ldr instructions are faster than an ldm if\n      the offset isn't small enough */\n-  if (nops == 2\n-      && (arm_cpu == PROCESSOR_ARM8 || arm_cpu == PROCESSOR_ARM9\n-\t  || arm_cpu == PROCESSOR_STARM))\n+  if (nops == 2 && arm_ld_sched)\n     return 0;\n \n   /* Can't do it without setting up the offset, only do this if it takes\n@@ -5074,7 +5178,7 @@ output_func_epilogue (f, frame_size)\n   if (use_return_insn (FALSE) && return_used_this_function)\n     {\n       if ((frame_size + current_function_outgoing_args_size) != 0\n-\t  && !(frame_pointer_needed || TARGET_APCS))\n+\t  && !(frame_pointer_needed && TARGET_APCS))\n \tabort ();\n       goto epilogue_done;\n     }\n@@ -5217,8 +5321,10 @@ output_func_epilogue (f, frame_size)\n \t  if (TARGET_THUMB_INTERWORK)\n \t    {\n \t      if (! lr_save_eliminated)\n-\t\tprint_multi_reg(f, \"ldmfd\\t%ssp!\", live_regs_mask | 0x4000,\n-\t\t\t\tFALSE);\n+\t\tlive_regs_mask |= 0x4000;\n+\n+\t      if (live_regs_mask != 0)\n+\t\tprint_multi_reg (f, \"ldmfd\\t%ssp!\", live_regs_mask, FALSE);\n \n \t      fprintf (f, \"\\tbx\\t%slr\\n\", REGISTER_PREFIX);\n \t    }\n@@ -5329,7 +5435,6 @@ emit_sfm (base_reg, count)\n \t\t\t\t   gen_rtvec (1, gen_rtx_REG (XFmode, \n \t\t\t\t\t\t\t      base_reg++)),\n \t\t\t\t   2));\n-\n   for (i = 1; i < count; i++)\n     XVECEXP (par, 0, i) = gen_rtx_USE (VOIDmode, \n \t\t\t\t       gen_rtx_REG (XFmode, base_reg++));\n@@ -5443,8 +5548,9 @@ arm_expand_prologue ()\n     }\n \n   /* If we are profiling, make sure no instructions are scheduled before\n-     the call to mcount.  */\n-  if (profile_flag || profile_block_flag)\n+     the call to mcount.  Similarly if the user has requested no\n+     scheduling in the prolog.  */\n+  if (profile_flag || profile_block_flag || TARGET_NO_SCHED_PRO)\n     emit_insn (gen_blockage ());\n }\n   \n@@ -5784,10 +5890,10 @@ final_prescan_insn (insn, opvec, noperands)\n   if (arm_ccfsm_state == 4)\n     {\n       if (insn == arm_target_insn)\n-      {\n-\tarm_target_insn = NULL;\n-\tarm_ccfsm_state = 0;\n-      }\n+\t{\n+\t  arm_target_insn = NULL;\n+\t  arm_ccfsm_state = 0;\n+\t}\n       return;\n     }\n "}, {"sha": "15ac18be924764ebd7f6553f0517a676df3e5342", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 47, "deletions": 57, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5a1b0d2167f711c45f0d5991dcded3cd756bcf1/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5a1b0d2167f711c45f0d5991dcded3cd756bcf1/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=f5a1b0d2167f711c45f0d5991dcded3cd756bcf1", "patch": "@@ -1,4 +1,4 @@\n-/* Definitions of target machine for GNU compiler, for Acorn RISC Machine.\n+/* Definitions of target machine for GNU compiler, for ARM.\n    Copyright (C) 1991, 93, 94, 95, 96, 97, 98, 1999 Free Software Foundation, Inc.\n    Contributed by Pieter `Tiggr' Schoenmakers (rcpieter@win.tue.nl)\n    and Martin Simmons (@harleqn.co.uk).\n@@ -53,6 +53,7 @@ Boston, MA 02111-1307, USA.  */\n #define TARGET_CPU_arm810\t0x0020\n #define TARGET_CPU_strongarm\t0x0040\n #define TARGET_CPU_strongarm110 0x0040\n+#define TARGET_CPU_strongarm1100 0x0040\n #define TARGET_CPU_arm9\t\t0x0080\n #define TARGET_CPU_arm9tdmi\t0x0080\n /* Configure didn't specify */\n@@ -146,6 +147,7 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n %{march=arm9tdmi:-D__ARM_ARCH_4T__} \\\n %{march=strongarm:-D__ARM_ARCH_4__} \\\n %{march=strongarm110:-D__ARM_ARCH_4__} \\\n+%{march=strongarm1100:-D__ARM_ARCH_4__} \\\n %{march=armv2:-D__ARM_ARCH_2__} \\\n %{march=armv2a:-D__ARM_ARCH_2__} \\\n %{march=armv3:-D__ARM_ARCH_3__} \\\n@@ -175,6 +177,7 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n  %{mcpu=arm9tdmi:-D__ARM_ARCH_4T__} \\\n  %{mcpu=strongarm:-D__ARM_ARCH_4__} \\\n  %{mcpu=strongarm110:-D__ARM_ARCH_4__} \\\n+ %{mcpu=strongarm1100:-D__ARM_ARCH_4__} \\\n  %{!mcpu*:%{!m6:%{!m2:%{!m3:%(cpp_cpu_arch_default)}}}}} \\\n \"\n \n@@ -258,7 +261,7 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n extern int target_flags;\n \n /* The floating point instruction architecture, can be 2 or 3 */\n-extern char *target_fp_name;\n+extern char * target_fp_name;\n \n /* Nonzero if the function prologue (and epilogue) should obey\n    the ARM Procedure Call Standard.  */\n@@ -318,6 +321,9 @@ extern char *target_fp_name;\n    big-endian (for backwards compatibility with older versions of GCC).  */\n #define ARM_FLAG_LITTLE_WORDS\t(0x2000)\n \n+/* Nonzero if we need to protect the prolog from scheduling */\n+#define ARM_FLAG_NO_SCHED_PRO\t(0x4000)\n+\n /* Nonzero if a call to abort should be generated if a noreturn \n function tries to return. */\n #define ARM_FLAG_ABORT_NORETURN (0x8000)\n@@ -337,6 +343,7 @@ function tries to return. */\n #define TARGET_BIG_END\t\t\t(target_flags & ARM_FLAG_BIG_END)\n #define TARGET_THUMB_INTERWORK\t\t(target_flags & ARM_FLAG_THUMB)\n #define TARGET_LITTLE_WORDS\t\t(target_flags & ARM_FLAG_LITTLE_WORDS)\n+#define TARGET_NO_SCHED_PRO\t\t(target_flags & ARM_FLAG_NO_SCHED_PRO)\n #define TARGET_ABORT_NORETURN           (target_flags & ARM_FLAG_ABORT_NORETURN)\n \n /* SUBTARGET_SWITCHES is used to add flags on a per-config basis.\n@@ -391,68 +398,39 @@ function tries to return. */\n   {\"abort-on-noreturn\",         ARM_FLAG_ABORT_NORETURN,     \\\n    \"Generate a call to abort if a noreturn function returns\"}, \\\n   {\"no-abort-on-noreturn\",      -ARM_FLAG_ABORT_NORETURN, \"\"}, \\\n+  {\"sched-prolog\",             -ARM_FLAG_NO_SCHED_PRO, \t\\\n+     \"Do not move instructions into a function's prologue\" }, \\\n+  {\"no-sched-prolog\",           ARM_FLAG_NO_SCHED_PRO, \"\" }, \\\n   SUBTARGET_SWITCHES\t\t\t\t\t\\\n   {\"\",\t\t\t\tTARGET_DEFAULT }\t\\\n }\n \n #define TARGET_OPTIONS\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\\\n-  {\"cpu=\",\t\t\t\t\t\t\t\\\n-     &arm_select[1].string,\t\t\t\t\t\\\n-     \"Specify the name of the target CPU\"},\t\t\t\\\n-  {\"arch=\",\t\t\t\t\t\t\t\\\n-     &arm_select[2].string,\t\t\t\t\t\\\n-     \"Specify the name of the target architecture\"},\t\t\\\n-  {\"tune=\",\t\t\t\t\t\t\t\\\n-     &arm_select[3].string,\t\t\t\t\t\\\n-     \"Order instructions for best performance on this CPU\"},\t\\\n-  {\"fp=\",\t\t\t\t\t\t\t\\\n-     &target_fp_name,\t\t\t\t\t\t\\\n-     \"Specify the version of the floating point emulator\"},\t\\\n-  {\"structure-size-boundary=\",\t\t\t\t\t\\\n-     &structure_size_string,\t\t\t\t\t\\\n-     \"Specify the minumum bit alignment of structures\"}\t\t\\\n+  {\"cpu=\",  & arm_select[0].string,\t\t\t\t\\\n+     \"Specify the name of the target CPU\" },\t\t\t\\\n+  {\"arch=\", & arm_select[1].string,\t\t\t\t\\\n+     \"Specify the name of the target architecture\" }, \t\t\\\n+  {\"tune=\", & arm_select[2].string, \"\" }, \t\t\t\\\n+  {\"fpe=\",  & target_fp_name, \"\" }, \t\t\t\t\\\n+  {\"fp=\",   & target_fp_name,\t\t\t\t\t\\\n+     \"Specify the version of the floating point emulator\" },\t\\\n+  { \"structure-size-boundary=\", & structure_size_string, \t\\\n+      \"Specify the minumum bit alignment of structures\" } \t\\\n }\n \n-/* arm_select[0] is reserved for the default cpu.  */\n struct arm_cpu_select\n {\n-  char *string;\n-  char *name;\n-  int set_tune_p;\n-  int set_arch_p;\n+  char *              string;\n+  char *              name;\n+  struct processors * processors;\n };\n \n+/* This is a magic array.  If the user specifies a command line switch\n+   which matches one of the entries in TARGET_OPTIONS then the corresponding\n+   string pointer will be set to the value specified by the user.  */\n extern struct arm_cpu_select arm_select[];\n \n-#ifndef PROCESSOR_DEFAULT\n-#define PROCESSOR_DEFAULT PROCESSOR_ARM2\n-#endif\n-\n-#ifndef TARGET_CPU_DEFAULT\n-#define TARGET_CPU_DEFAULT ((char *) 0)\n-#endif\n-\n-/* Which processor we are running on, for instruction scheduling \n-   purposes.  */\n-enum processor_type \n-{\n-  PROCESSOR_ARM2,\n-  PROCESSOR_ARM3,\n-  PROCESSOR_ARM6,\n-  PROCESSOR_ARM7,\n-  PROCESSOR_ARM8,\n-  PROCESSOR_ARM9,\n-  PROCESSOR_STARM,\n-  PROCESSOR_NONE\t/* NOTE: This must be last, since it doesn't\n-\t\t\t   appear in the attr_cpu list */\n-};\n-\n-/* Recast the cpu class to be the cpu attribute.  */\n-#define arm_cpu_attr ((enum attr_cpu)arm_cpu)\n-\n-extern enum processor_type arm_cpu;\n-\n enum prog_mode_type\n {\n   prog_mode26,\n@@ -493,6 +471,15 @@ extern int arm_fast_multiply;\n /* Nonzero if this chip supports the ARM Architecture 4 extensions */\n extern int arm_arch4;\n \n+/* Nonzero if this chip can benefit from load scheduling.  */\n+extern int arm_ld_sched;\n+\n+/* Nonzero if this chip is a StrongARM.  */\n+extern int arm_is_strong;\n+\n+/* Nonzero if this chip is a an ARM6 or an ARM7.  */\n+extern int arm_is_6_or_7;\n+\n #ifndef TARGET_DEFAULT\n #define TARGET_DEFAULT  0\n #endif\n@@ -634,8 +621,8 @@ extern char * structure_size_string;\n \n \tr4-r8\t     S\tregister variable\n \tr9\t     S\t(rfp) register variable (real frame pointer)\n-\n-\tr10  \t   F S\t(sl) stack limit (not currently used)\n+\t\n+\tr10  \t   F S\t(sl) stack limit (used by -mapcs-stack-check)\n \tr11 \t   F S\t(fp) argument pointer\n \tr12\t\t(ip) temp workspace\n \tr13  \t   F S\t(sp) lower end of current stack frame\n@@ -730,6 +717,11 @@ extern char * structure_size_string;\n       fixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\t\\\n       call_used_regs[PIC_OFFSET_TABLE_REGNUM] = 0;\t\\\n     }\t\t\t\t\t\t\t\\\n+  else if (! TARGET_APCS_STACK)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      fixed_regs[10]     = 0;\t\t\t\t\\\n+      call_used_regs[10] = 0;\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n }\n \n /* Return number of consecutive hard regs needed starting at reg REGNO\n@@ -1062,9 +1054,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* How large values are returned */\n /* A C expression which can inhibit the returning of certain function values\n    in registers, based on the type of value. */\n-#define RETURN_IN_MEMORY(TYPE)\t\t\t\t\t\t\\\n-  (TYPE_MODE ((TYPE)) == BLKmode ||\t\t\t\t\t\\\n-   (AGGREGATE_TYPE_P ((TYPE)) && arm_return_in_memory ((TYPE))))\n+#define RETURN_IN_MEMORY(TYPE) arm_return_in_memory (TYPE)\n \n /* Define DEFAULT_PCC_STRUCT_RETURN to 1 if all structure and union return\n    values must be in memory.  On the ARM, they need only do so if larger\n@@ -1779,8 +1769,8 @@ extern int arm_pic_register;\n \n #define FINALIZE_PIC arm_finalize_pic ()\n \n-/* We can't directly access anything that contains a symbol, nor can\n-   we indirect via the constant pool */\n+/* We can't directly access anything that contains a symbol,\n+   nor can we indirect via the constant pool.  */\n #define LEGITIMATE_PIC_OPERAND_P(X)\t\t\t\t\\\n \t(! symbol_mentioned_p (X)\t\t\t\t\\\n \t && (! CONSTANT_POOL_ADDRESS_P (X)\t\t\t\\"}, {"sha": "a87932e8756c8fb23a5628ca73d591fbb1e94a6b", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 52, "deletions": 51, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5a1b0d2167f711c45f0d5991dcded3cd756bcf1/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5a1b0d2167f711c45f0d5991dcded3cd756bcf1/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=f5a1b0d2167f711c45f0d5991dcded3cd756bcf1", "patch": "@@ -45,10 +45,7 @@\n ; by the -mapcs-{32,26} flag, and possibly the -mcpu=... option.\n (define_attr \"prog_mode\" \"prog26,prog32\" (const (symbol_ref \"arm_prog_mode\")))\n \n-; CPU attribute is used to determine the best instruction mix for performance\n-; on the named processor.\n-(define_attr \"cpu\" \"arm2,arm3,arm6,arm7,arm8,arm9,st_arm\"\n-\t(const (symbol_ref \"arm_cpu_attr\")))\n+(define_attr \"is_strongarm\" \"no,yes\" (const (symbol_ref \"arm_is_strong\")))\n \n ; Floating Point Unit.  If we only have floating point emulation, then there\n ; is no point in scheduling the floating point insns.  (Well, for best\n@@ -100,11 +97,9 @@\n \t\"normal,mult,block,float,fdivx,fdivd,fdivs,fmul,ffmul,farith,ffarith,float_em,f_load,f_store,f_mem_r,r_mem_f,f_2_r,r_2_f,call,load,store1,store2,store3,store4\" \n \t(const_string \"normal\"))\n \n-; Load scheduling, set from the cpu characteristic\n-(define_attr \"ldsched\" \"no,yes\"\n-  (if_then_else (eq_attr \"cpu\" \"arm8,arm9,st_arm\")\n-\t\t(const_string \"yes\")\n-\t\t(const_string \"no\")))\n+; Load scheduling, set from the arm_ld_sched variable\n+; initialised by arm_override_options() \n+(define_attr \"ldsched\" \"no,yes\" (const (symbol_ref \"arm_ld_sched\")))\n \n ; condition codes: this one is used by final_prescan_insn to speed up\n ; conditionalizing instructions.  It saves having to scan the rtl to see if\n@@ -137,10 +132,7 @@\n ; have one.  Later ones, such as StrongARM, have write-back caches, so don't\n ; suffer blockages enough to warrent modelling this (and it can adversely\n ; affect the schedule).\n-(define_attr \"model_wbuf\" \"no,yes\"\n-  (if_then_else (eq_attr \"cpu\" \"arm6,arm7\")\n-\t\t(const_string \"yes\")\n-\t\t(const_string \"no\")))\n+(define_attr \"model_wbuf\" \"no,yes\" (const (symbol_ref \"arm_is_6_or_7\")))\n \n (define_attr \"write_conflict\" \"no,yes\"\n   (if_then_else (eq_attr \"type\"\n@@ -267,13 +259,15 @@\n   (and (eq_attr \"fpu\" \"fpa\") (eq_attr \"type\" \"f_mem_r\")) 7 7)\n \n (define_function_unit \"core\" 1 0\n-  (and (eq_attr \"cpu\" \"!arm8,st_arm\") (eq_attr \"type\" \"mult\")) 16 16)\n+  (and (eq_attr \"ldsched\" \"no\") (eq_attr \"type\" \"mult\")) 16 16)\n \n (define_function_unit \"core\" 1 0\n-  (and (eq_attr \"cpu\" \"arm8\") (eq_attr \"type\" \"mult\")) 4 4)\n+  (and (and (eq_attr \"ldsched\" \"yes\") (eq_attr \"is_strongarm\" \"no\"))\n+       (eq_attr \"type\" \"mult\")) 4 4)\n \n (define_function_unit \"core\" 1 0\n-  (and (eq_attr \"cpu\" \"st_arm\") (eq_attr \"type\" \"mult\")) 3 2)\n+  (and (and (eq_attr \"ldsched\" \"yes\") (eq_attr \"is_strongarm\" \"yes\"))\n+       (eq_attr \"type\" \"mult\")) 3 2)\n \n (define_function_unit \"core\" 1 0 (eq_attr \"type\" \"store2\") 3 3)\n \n@@ -1209,7 +1203,7 @@\n \t\t\t (const_int 0)))\n    (clobber (match_scratch:QI 3 \"=r\"))]\n   \"INTVAL (operands[2]) >= 0 && INTVAL (operands[1]) > 0\n-   && (INTVAL (operands[2]) + INTVAL (operands[1]) <= 8)\"\n+   && ((INTVAL (operands[2]) + INTVAL (operands[1])) <= 8)\"\n   \"*\n   operands[1] = GEN_INT (((1 << INTVAL (operands[1])) - 1)\n \t\t\t << INTVAL (operands[2]));\n@@ -1287,7 +1281,7 @@\n \n       emit_insn (gen_ashlsi3 (op0, operands[3], GEN_INT (32 - width)));\n       emit_insn (gen_iorsi3 (op1, gen_rtx_LSHIFTRT (SImode, operands[0],\n-\t\t\t\t\t\t    operands[1]),\n+\t\t\t\t\t\t\t    operands[1]),\n \t\t\t     op0));\n       emit_insn (gen_rotlsi3 (subtarget, op1, operands[1]));\n     }\n@@ -2173,16 +2167,20 @@\n   \"\"\n   \"\n {\n-  if (arm_arch4 && GET_CODE (operands[1]) == MEM)\n+  if (GET_CODE (operands[1]) == MEM)\n     {\n-      emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n-\t\t\t      gen_rtx_ZERO_EXTEND (SImode, operands[1])));\n-      DONE;\n-    }\n-  if (TARGET_SHORT_BY_BYTES && GET_CODE (operands[1]) == MEM)\n-    {\n-      emit_insn (gen_movhi_bytes (operands[0], operands[1]));\n-      DONE;\n+      if (TARGET_SHORT_BY_BYTES)\n+        {\n+\t  emit_insn (gen_movhi_bytes (operands[0], operands[1]));\n+          DONE;\n+        }\n+      else if (arm_arch4)\n+        {\n+          emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t\t  operands[0],\n+\t\t\t\t  gen_rtx_ZERO_EXTEND (SImode, operands[1])));\n+          DONE;\n+        }\n     }\n   if (! s_register_operand (operands[1], HImode))\n     operands[1] = copy_to_mode_reg (HImode, operands[1]);\n@@ -2274,19 +2272,21 @@\n \t\t     (const_int 16)))]\n   \"\"\n   \"\n-{ \n-  if (arm_arch4 && GET_CODE (operands[1]) == MEM)\n-    {\n-      emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n-\t\t gen_rtx_SIGN_EXTEND (SImode, operands[1])));\n-      DONE;\n-    }\n-\n-  if (TARGET_SHORT_BY_BYTES && GET_CODE (operands[1]) == MEM)\n+{\n+  if (GET_CODE (operands[1]) == MEM)\n     {\n-      emit_insn (gen_extendhisi2_mem (operands[0], operands[1]));\n-      DONE;\n-    }\n+      if (TARGET_SHORT_BY_BYTES)\n+        {\n+          emit_insn (gen_extendhisi2_mem (operands[0], operands[1]));\n+          DONE;\n+        }\n+      else if (arm_arch4)\n+        {\n+          emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n+\t\t     gen_rtx_SIGN_EXTEND (SImode, operands[1])));\n+          DONE;\n+        }\n+     }\n   if (! s_register_operand (operands[1], HImode))\n     operands[1] = copy_to_mode_reg (HImode, operands[1]);\n   operands[1] = gen_lowpart (SImode, operands[1]);\n@@ -2381,7 +2381,8 @@\n {\n   if (arm_arch4 && GET_CODE (operands[1]) == MEM)\n     {\n-      emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n+      emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t      operands[0],\n \t\t\t      gen_rtx_SIGN_EXTEND (HImode, operands[1])));\n       DONE;\n     }\n@@ -2437,8 +2438,8 @@\n \t     && GET_CODE (XEXP (operands[1], 1)) != CONST_INT\n \t     && ! s_register_operand (XEXP (operands[1], 1), VOIDmode))\n       operands[1] = gen_rtx_PLUS (GET_MODE (operands[1]),\n-\t\t\t\t  XEXP (operands[1], 1),\n-\t\t\t\t  XEXP (operands[1], 0));\n+\t\t\t\t\t   XEXP (operands[1], 1),\n+\t\t\t\t\t   XEXP (operands[1], 0));\n   }\n \")\n \n@@ -2454,7 +2455,8 @@\n {\n   if (arm_arch4 && GET_CODE (operands[1]) == MEM)\n     {\n-      emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n+      emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t      operands[0],\n \t\t\t      gen_rtx_SIGN_EXTEND (SImode, operands[1])));\n       DONE;\n     }\n@@ -2508,8 +2510,8 @@\n \t     && GET_CODE (XEXP (operands[1], 1)) != CONST_INT\n \t     && ! s_register_operand (XEXP (operands[1], 1), VOIDmode))\n       operands[1] = gen_rtx_PLUS (GET_MODE (operands[1]),\n-\t\t\t\t  XEXP (operands[1], 1),\n-\t\t\t\t  XEXP (operands[1], 0));\n+\t\t\t\t\t   XEXP (operands[1], 1),\n+\t\t\t\t\t   XEXP (operands[1], 0));\n   }\n \")\n \n@@ -3260,7 +3262,7 @@\n \t\t\t   XEXP (XEXP (operands[0], 0), 1)));\n \n   emit_insn (gen_rtx_SET (VOIDmode, gen_rtx_MEM (DFmode, operands[2]),\n-\t\t\t  operands[1]));\n+\t\t\t\t    operands[1]));\n \n   if (code == POST_DEC)\n     emit_insn (gen_addsi3 (operands[2], operands[2], GEN_INT (-8)));\n@@ -4184,10 +4186,10 @@\n   extern int arm_ccfsm_state;\n \n   if (arm_ccfsm_state == 1 || arm_ccfsm_state == 2)\n-  {\n-    arm_ccfsm_state += 2;\n-    return \\\"\\\";\n-  }\n+    {\n+      arm_ccfsm_state += 2;\n+      return \\\"\\\";\n+    }\n   return \\\"b%?\\\\t%l0\\\";\n }\")\n \n@@ -6136,7 +6138,6 @@\n }\n \")\n \n-\n ;; The next two patterns occur when an AND operation is followed by a\n ;; scc insn sequence \n "}, {"sha": "c244b8cb23cbf959174ef9aa6b2dbed1014e72df", "filename": "gcc/config/arm/elf.h", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5a1b0d2167f711c45f0d5991dcded3cd756bcf1/gcc%2Fconfig%2Farm%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5a1b0d2167f711c45f0d5991dcded3cd756bcf1/gcc%2Fconfig%2Farm%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Felf.h?ref=f5a1b0d2167f711c45f0d5991dcded3cd756bcf1", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler,\n    for ARM with ELF obj format.\n-   Copyright (C) 1995, 1996, 1997, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1995, 1996, 1997, 1998, 1999 Free Software Foundation, Inc.\n    Contributed by Philip Blundell <philb@gnu.org> and\n    Catherine Moore <clm@cygnus.com>\n    \n@@ -100,7 +100,7 @@ Boston, MA 02111-1307, USA.  */\n    by ASM_DECLARE_OBJECT_NAME when it was run for the same decl.  */\n #define ASM_FINISH_DECLARE_OBJECT(FILE, DECL, TOP_LEVEL, AT_END)\t \\\n do {\t\t\t\t\t\t\t\t\t \\\n-     char *name = XSTR (XEXP (DECL_RTL (DECL), 0), 0);\t\t\t \\\n+     char * name = XSTR (XEXP (DECL_RTL (DECL), 0), 0);\t\t\t \\\n      if (!flag_inhibit_size_directive && DECL_SIZE (DECL)\t\t \\\n          && ! AT_END && TOP_LEVEL\t\t\t\t\t \\\n \t && DECL_INITIAL (DECL) == error_mark_node\t\t\t \\\n@@ -143,7 +143,7 @@ do {\t\t\t\t\t\t\t\t\t \\\n \n #ifndef ASM_SPEC\n #define ASM_SPEC \"%{mbig-endian:-EB} %{mcpu=*:-m%*} %{march=*:-m%*} \\\n- %{mapcs-*:-mapcs-%*} %{mthumb-interwork:-mthumb-interwork}\"\n+ %{mapcs-*:-mapcs-%*} %{mthumb-interwork:-mthumb-interwork} %{mapcs-float:mfloat}\"\n #endif\n \n #ifndef LINK_SPEC\n@@ -198,9 +198,10 @@ arm_valid_machine_decl_attribute (DECL, ATTRIBUTES, IDENTIFIER, ARGS)\n #ifndef ASM_FILE_START\n #define ASM_FILE_START(STREAM) \\\n do {\t\t\t\t\t\t\t\t\\\n-  extern char *version_string;\t\t\t\t\t\\\n+  extern char * version_string;\t\t\t\t\t\\\n   fprintf (STREAM, \"%s Generated by gcc %s for ARM/elf\\n\",\t\\\n \t   ASM_COMMENT_START, version_string);\t\t\t\\\n+  output_file_directive ((STREAM), main_input_filename);\t\\\n } while (0)\n #endif\n      \n@@ -209,7 +210,7 @@ do {\t\t\t\t\t\t\t\t\\\n #define ASM_OUTPUT_INTERNAL_LABEL(STREAM, PREFIX, NUM)  \t\\\n   do                                    \t      \t   \t\\\n     {\t\t\t\t\t\t      \t   \t\\\n-      char *s = (char *) alloca (40 + strlen (PREFIX));\t   \t\\\n+      char * s = (char *) alloca (40 + strlen (PREFIX));\t\\\n       extern int arm_target_label, arm_ccfsm_state;\t   \t\\\n       extern rtx arm_target_insn;\t\t\t\t\\\n \t\t\t\t\t\t           \t\\\n@@ -332,6 +333,3 @@ do {\t\t\t\t\t\t\\\n        fputc ('\\n', FILE); } while (0)\n \n #include \"arm/aout.h\"\n-\n-\n-"}, {"sha": "97caad5da6274633554a75e4d61b6f2d58e4ba77", "filename": "gcc/config/arm/linux-elf.h", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5a1b0d2167f711c45f0d5991dcded3cd756bcf1/gcc%2Fconfig%2Farm%2Flinux-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5a1b0d2167f711c45f0d5991dcded3cd756bcf1/gcc%2Fconfig%2Farm%2Flinux-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Flinux-elf.h?ref=f5a1b0d2167f711c45f0d5991dcded3cd756bcf1", "patch": "@@ -34,8 +34,20 @@ Boston, MA 02111-1307, USA.  */\n \t\" %{mapcs-26:-mapcs-26} %(!mapcs-26:-mapcs-32}\"\n #endif\n \n+/* This was defined in linux.h.  Define it here also. */\n+#undef  DEFAULT_VTABLE_THUNKS\n+#define DEFAULT_VTABLE_THUNKS   1\n+\n+/* Handle #pragma weak and #pragma pack.  */\n+#define HANDLE_SYSV_PRAGMA\n+\n /* Now we define the strings used to build the spec file.  */\n-#define LIB_SPEC \"%{!shared:%{!symbolic:-lc}}\"\n+#define LIB_SPEC \\\n+  \"%{shared: -lc} \\\n+   %{!shared: %{pthread:-lpthread} \\\n+\t%{profile:-lc_p} %{!profile: -lc}}\"\n+\n+#define LIBGCC_SPEC \"%{msoft-float:-lfloat} -lgcc\"\n \n /* Add the compiler's crtend, and the library's crtn.  */\n #define ENDFILE_SPEC \"%{!shared:crtend.o%s} %{shared:crtendS.o%s} \\\n@@ -64,6 +76,10 @@ Boston, MA 02111-1307, USA.  */\n #ifndef SUBTARGET_DEFAULT_APCS26\n #undef  CPP_APCS_PC_DEFAULT_SPEC\n #define CPP_APCS_PC_DEFAULT_SPEC \"-D__APCS_32__\"\n+/* On 32-bit machine it is always safe to assume we have the \"new\"\n+   floating point system.  */\n+#undef  FP_DEFAULT\n+#define FP_DEFAULT FP_SOFT3\n #endif\n \n /* Allow #sccs in preprocessor.  */\n@@ -201,5 +217,10 @@ const_section ()\t\t\t\t\t\t\t\\\n        assemble_name (FILE, NAME2);\t \\\n        fputc ('\\n', FILE); } while (0)\n \n+/* Make DWARF2 an option, but keep DBX as the default for now.\n+   Use -gdwarf2 to turn on DWARF2.  */\n+#define DWARF2_DEBUGGING_INFO\n+#define PREFERRED_DEBUGGING_TYPE DBX_DEBUG\n+\n #include \"arm/elf.h\"\n #include \"arm/linux-gas.h\""}, {"sha": "f2b5d42e1e27f973fdbad7d6abb48214443791a3", "filename": "gcc/config/arm/linux-gas.h", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5a1b0d2167f711c45f0d5991dcded3cd756bcf1/gcc%2Fconfig%2Farm%2Flinux-gas.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5a1b0d2167f711c45f0d5991dcded3cd756bcf1/gcc%2Fconfig%2Farm%2Flinux-gas.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Flinux-gas.h?ref=f5a1b0d2167f711c45f0d5991dcded3cd756bcf1", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler.\n    ARM Linux-based GNU systems version.\n-   Copyright (C) 1997, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1997, 1998, 1999 Free Software Foundation, Inc.\n    Contributed by Russell King  <rmk92@ecs.soton.ac.uk>.\n \n This file is part of GNU CC.\n@@ -59,29 +59,25 @@ Boston, MA 02111-1307, USA.  */\n #undef  WCHAR_TYPE_SIZE\n #define WCHAR_TYPE_SIZE BITS_PER_WORD\n \n-#if 0\t\t/* not yet */\n+/* Emit code to set up a trampoline and synchronise the caches.  */\n+#undef  INITIALIZE_TRAMPOLINE\n+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant ((TRAMP), 8)),\t\\\n+\t\t  (CXT));\t\t\t\t\t\t\\\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant ((TRAMP), 12)),\t\\\n+\t\t  (FNADDR));\t\t\t\t\t\t\\\n+  emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__clear_cache\"),\t\\\n+\t\t     0, VOIDmode, 2, TRAMP, Pmode,\t\t\t\\\n+\t\t     plus_constant (TRAMP, TRAMPOLINE_SIZE), Pmode);\t\\\n+}\n \n /* Clear the instruction cache from `beg' to `end'.  This makes an\n-   inline system call to SYS_cacheflush.  The arguments are as\n-   follows:\n-\n-\tcacheflush (start, end, flags)\n-\n-*/\n-\n+   inline system call to SYS_cacheflush.  */\n #define CLEAR_INSN_CACHE(BEG, END)\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   register unsigned long _beg __asm (\"a1\") = (unsigned long) (BEG);\t\\\n   register unsigned long _end __asm (\"a2\") = (unsigned long) (END);\t\\\n   register unsigned long _flg __asm (\"a3\") = 0;\t\t\t\t\\\n-  __asm __volatile (\"swi 0x9000b8\");\t\t\t\t\t\\\n+  __asm __volatile (\"swi 0x9f0002\");\t\t\t\t\t\\\n }\n-\n-#endif\n-\n-/* If cross-compiling, don't require stdio.h etc to build libgcc.a.  */\n-#ifdef CROSS_COMPILE\n-#ifndef inhibit_libc\n-#define inhibit_libc\n-#endif\n-#endif"}, {"sha": "4d2efec9c5330d5129458b7c53e52a1bb2d88c16", "filename": "gcc/config/arm/t-arm-elf", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5a1b0d2167f711c45f0d5991dcded3cd756bcf1/gcc%2Fconfig%2Farm%2Ft-arm-elf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5a1b0d2167f711c45f0d5991dcded3cd756bcf1/gcc%2Fconfig%2Farm%2Ft-arm-elf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-arm-elf?ref=f5a1b0d2167f711c45f0d5991dcded3cd756bcf1", "patch": "@@ -23,9 +23,11 @@ dp-bit.c: $(srcdir)/config/fp-bit.c\n \techo '#endif' >> dp-bit.c\n \tcat $(srcdir)/config/fp-bit.c >> dp-bit.c\n \n-MULTILIB_OPTIONS  = mlittle-endian/mbig-endian mhard-float/msoft-float mapcs-32/mapcs-26 fno-leading-underscore/fleading-underscore\n-MULTILIB_DIRNAMES = le be fpu soft 32bit 26bit elf under\n-MULTILIB_MATCHES  = \n+# MULTILIB_OPTIONS  = mlittle-endian/mbig-endian mhard-float/msoft-float mapcs-32/mapcs-26 fno-leading-underscore/fleading-underscore\n+# MULTILIB_DIRNAMES = le be fpu soft 32bit 26bit elf under\n+# MULTILIB_MATCHES  = \n \n-LIBGCC = stmp-multilib\n-INSTALL_LIBGCC = install-multilib\n+# LIBGCC = stmp-multilib\n+# INSTALL_LIBGCC = install-multilib\n+\n+TARGET_LIBGCC2_CFLAGS = -Dinhibit_libc"}, {"sha": "9fdeae93c7a18b70513912230300231426bcf3a4", "filename": "gcc/config/arm/t-linux", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5a1b0d2167f711c45f0d5991dcded3cd756bcf1/gcc%2Fconfig%2Farm%2Ft-linux", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5a1b0d2167f711c45f0d5991dcded3cd756bcf1/gcc%2Fconfig%2Farm%2Ft-linux", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-linux?ref=f5a1b0d2167f711c45f0d5991dcded3cd756bcf1", "patch": "@@ -13,8 +13,10 @@ LIBGCC1 = libgcc1-asm.a\n LIB1ASMSRC = arm/lib1funcs.asm\n LIB1ASMFUNCS = _udivsi3 _divsi3 _umodsi3 _modsi3 _dvmd_lnx\n \n-MULTILIB_OPTIONS = mapcs-32\n-MULTILIB_DIRNAMES = apcs-32\n+# If you want to build both APCS variants as multilib options this is how\n+# to do it.\n+#MULTILIB_OPTIONS = mapcs-32/apcs-26\n+#MULTILIB_DIRNAMES = apcs-32 apcs-26\n \n LIBGCC = stmp-multilib\n INSTALL_LIBGCC = install-multilib"}, {"sha": "82a7737943f8b2545b1bac94ea1bffe250fdc640", "filename": "gcc/invoke.texi", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5a1b0d2167f711c45f0d5991dcded3cd756bcf1/gcc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5a1b0d2167f711c45f0d5991dcded3cd756bcf1/gcc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finvoke.texi?ref=f5a1b0d2167f711c45f0d5991dcded3cd756bcf1", "patch": "@@ -170,7 +170,7 @@ in the following sections.\n -idirafter @var{dir}\n -include @var{file}  -imacros @var{file}\n -iprefix @var{file}  -iwithprefix @var{dir}\n--iwithprefixbefore @var{dir}  -isystem @var{dir}\n+-iwithprefixbefore @var{dir}  -isystem @var{dir} -isystem-c++ @var{dir}\n -M  -MD  -MM  -MMD  -MG  -nostdinc  -P  -trigraphs\n -undef  -U@var{macro}  -Wp,@var{option}\n @end smallexample\n@@ -259,6 +259,8 @@ in the following sections.\n -mcpu= -march= -mfpe= \n -mstructure-size-boundary=\n -mbsd -mxopen -mno-symrename\n+-mabort-on-noreturn\n+-mno-sched-prolog\n \n @emph{Thumb Options}\n -mtpcs-frame -mno-tpcs-frame\n@@ -1155,6 +1157,11 @@ offsets for adjusting the @samp{this} pointer at the call site.  Newer\n implementations store a single pointer to a @samp{thunk} function which\n does any necessary adjustment and then calls the target function.\n \n+This option also enables a heuristic for controlling emission of\n+vtables; if a class has any non-inline virtual functions, the vtable\n+will be emitted in the translation unit containing the first one of\n+those.\n+\n Like all options that change the ABI, all C++ code, @emph{including\n libgcc.a} must be built with the same setting of this option.\n \n@@ -3796,13 +3803,17 @@ suppresses this pass.  The post-processor is never run when the\n compiler is built for cross-compilation.\n \n @item -mcpu=<name>\n+@item -mtune=<name>\n @kindex -mcpu=\n+@kindex -mtune=\n This specifies the name of the target ARM processor.  GCC uses this name\n to determine what kind of instructions it can use when generating\n assembly code.  Permissable names are: arm2, arm250, arm3, arm6, arm60,\n arm600, arm610, arm620, arm7, arm7m, arm7d, arm7dm, arm7di, arm7dmi,\n arm70, arm700, arm700i, arm710, arm710c, arm7100, arm7500, arm7500fe,\n-arm7tdmi, arm8, strongarm, strongarm110\n+arm7tdmi, arm8, strongarm, strongarm110, strongarm1100, arm8, arm810,\n+arm9, arm9tdmi.  @samp{-mtune=} is a synonym for @samp{-mcpue=} to\n+support older versions of GCC.\n \n @item -march=<name>\n @kindex -march=\n@@ -3813,9 +3824,12 @@ of the @samp{-mcpu=} option.  Permissable names are: armv2, armv2a,\n armv3, armv3m, armv4, armv4t\n \n @item -mfpe=<number>\n+@item -mfp=<number>\n @kindex -mfpe=\n+@kindex -mfp=\n This specifes the version of the floating point emulation available on\n-the target.  Permissable values are 2 and 3.\n+the target.  Permissable values are 2 and 3.  @samp{-mfp=} is a synonym\n+for @samp{-mfpe=} to support older versions of GCC.\n \n @item -mstructure-size-boundary=<n>\n @kindex -mstructure-size-boundary\n@@ -3830,6 +3844,12 @@ libraries compiled with the other value, if they exchange information\n using structures or unions.  Programmers are encouraged to use the 32\n value as future versions of the toolchain may default to this value.\n \n+@item -mabort-on-noreturn\n+@kindex -mabort-on-noreturn\n+@kindex -mnoabort-on-noreturn\n+Generate a call to the function abort at the end of a noreturn function.\n+It will be executed if the function tries to return.\n+\n @end table\n \n @node Thumb Options\n@@ -4666,7 +4686,9 @@ All modules should be compiled with the same @samp{-G @var{num}} value.\n @itemx -mno-regnames\n On System V.4 and embedded PowerPC systems do (do not) emit register\n names in the assembly language output using symbolic forms.\n+\n @end table\n+\n @node RT Options\n @subsection IBM RT Options\n @cindex RT options"}]}