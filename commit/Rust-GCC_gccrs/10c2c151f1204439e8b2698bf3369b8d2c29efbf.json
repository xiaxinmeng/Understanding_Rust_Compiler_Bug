{"sha": "10c2c151f1204439e8b2698bf3369b8d2c29efbf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBjMmMxNTFmMTIwNDQzOWU4YjI2OThiZjMzNjliOGQyYzI5ZWZiZg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-01-12T13:26:34Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-01-12T13:26:34Z"}, "message": "[multiple changes]\n\n2017-01-12  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch6.adb: Minor reformatting.\n\t* spark_xrefs.ads: minor cleanup of comments for SPARK xrefs\n\n2017-01-12  Bob Duff  <duff@adacore.com>\n\n\t* binde.adb (Forced): New reason for a dependence.\n\t(Force_Elab_Order): Implementation of the new switch.\n\t* binde.ads: Minor comment fixes.\n\t* bindusg.adb: Add -f switch. Apparently, there was an -f switch\n\tlong ago that is no longer supported; removed comment about that.\n\t* opt.ads (Force_Elab_Order_File): Name of file specified for\n\t-f switch.\n\t* switch-b.adb: Parse -f switch.\n\nFrom-SVN: r244355", "tree": {"sha": "80e49955bfd3f2d49c89a57866549b8b830d0bb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/80e49955bfd3f2d49c89a57866549b8b830d0bb6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10c2c151f1204439e8b2698bf3369b8d2c29efbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10c2c151f1204439e8b2698bf3369b8d2c29efbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10c2c151f1204439e8b2698bf3369b8d2c29efbf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10c2c151f1204439e8b2698bf3369b8d2c29efbf/comments", "author": null, "committer": null, "parents": [{"sha": "84e13614352202b592fd28fc12c18c07b5ae5d53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84e13614352202b592fd28fc12c18c07b5ae5d53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84e13614352202b592fd28fc12c18c07b5ae5d53"}], "stats": {"total": 446, "additions": 349, "deletions": 97}, "files": [{"sha": "787b324953d901fc5b9d95be02e48185b2250bb1", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c2c151f1204439e8b2698bf3369b8d2c29efbf/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c2c151f1204439e8b2698bf3369b8d2c29efbf/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=10c2c151f1204439e8b2698bf3369b8d2c29efbf", "patch": "@@ -1,3 +1,19 @@\n+2017-01-12  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch6.adb: Minor reformatting.\n+\t* spark_xrefs.ads: minor cleanup of comments for SPARK xrefs\n+\n+2017-01-12  Bob Duff  <duff@adacore.com>\n+\n+\t* binde.adb (Forced): New reason for a dependence.\n+\t(Force_Elab_Order): Implementation of the new switch.\n+\t* binde.ads: Minor comment fixes.\n+\t* bindusg.adb: Add -f switch. Apparently, there was an -f switch\n+\tlong ago that is no longer supported; removed comment about that.\n+\t* opt.ads (Force_Elab_Order_File): Name of file specified for\n+\t-f switch.\n+\t* switch-b.adb: Parse -f switch.\n+\n 2017-01-12  Justin Squirek  <squirek@adacore.com>\n \n \t* exp_ch6.adb (Check_View_Conversion): Created this function"}, {"sha": "7baf6857b9357e6b6d3b7b17ebd2e2bb8fc90296", "filename": "gcc/ada/binde.adb", "status": "modified", "additions": 271, "deletions": 61, "changes": 332, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c2c151f1204439e8b2698bf3369b8d2c29efbf/gcc%2Fada%2Fbinde.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c2c151f1204439e8b2698bf3369b8d2c29efbf/gcc%2Fada%2Fbinde.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbinde.adb?ref=10c2c151f1204439e8b2698bf3369b8d2c29efbf", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,6 +33,7 @@ with Osint;\n with Output;   use Output;\n \n with System.Case_Util; use System.Case_Util;\n+with System.OS_Lib;\n \n package body Binde is\n \n@@ -62,9 +63,13 @@ package body Binde is\n       --  After directly with's Before, so the spec of Before must be\n       --  elaborated before After is elaborated.\n \n+      Forced,\n+      --  Before and After come from a pair of lines in the forced elaboration\n+      --  order file.\n+\n       Elab,\n       --  After directly mentions Before in a pragma Elaborate, so the\n-      --  body of Before must be elaborate before After is elaborated.\n+      --  body of Before must be elaborated before After is elaborated.\n \n       Elab_All,\n       --  After either mentions Before directly in a pragma Elaborate_All,\n@@ -73,12 +78,12 @@ package body Binde is\n       --  traces the dependencies in the latter case.\n \n       Elab_All_Desirable,\n-      --  This is just like Elab_All, except that the elaborate all was not\n+      --  This is just like Elab_All, except that the Elaborate_All was not\n       --  explicitly present in the source, but rather was created by the\n       --  front end, which decided that it was \"desirable\".\n \n       Elab_Desirable,\n-      --  This is just like Elab, except that the elaborate was not\n+      --  This is just like Elab, except that the Elaborate was not\n       --  explicitly present in the source, but rather was created by the\n       --  front end, which decided that it was \"desirable\".\n \n@@ -111,19 +116,19 @@ package body Binde is\n       Elab_All_Link : Elab_All_Id;\n       --  If Reason = Elab_All or Elab_Desirable, then this points to the\n       --  first elment in a list of Elab_All entries that record the with\n-      --  chain leading resulting in this particular dependency.\n+      --  chain resulting in this particular dependency.\n \n    end record;\n \n    --  Note on handling of Elaborate_Body. Basically, if we have a pragma\n-   --  Elaborate_Body in a unit, it means that the spec and body have to\n-   --  be handled as a single entity from the point of view of determining\n-   --  an elaboration order. What we do is to essentially remove the body\n-   --  from consideration completely, and transfer all its links (other\n-   --  than the spec link) to the spec. Then when then the spec gets chosen,\n-   --  we choose the body right afterwards. We mark the links that get moved\n-   --  from the body to the spec by setting their Elab_Body flag True, so\n-   --  that we can understand what is going on.\n+   --  Elaborate_Body in a unit, it means that the spec and body have to be\n+   --  handled as a single entity from the point of view of determining an\n+   --  elaboration order. What we do is to essentially remove the body from\n+   --  consideration completely, and transfer all its links (other than the\n+   --  spec link) to the spec. Then when the spec gets chosen, we choose the\n+   --  body right afterwards. We mark the links that get moved from the body to\n+   --  the spec by setting their Elab_Body flag True, so that we can understand\n+   --  what is going on.\n \n    Succ_First : constant := 1;\n \n@@ -175,7 +180,7 @@ package body Binde is\n       --  Position in elaboration order (zero = not placed yet)\n \n       Visited : Boolean;\n-      --  Used in computing transitive closure for elaborate all and\n+      --  Used in computing transitive closure for Elaborate_All and\n       --  also in locating cycles and paths in the diagnose routines.\n \n       Elab_Position : Natural;\n@@ -233,15 +238,15 @@ package body Binde is\n \n    function Corresponding_Body (U : Unit_Id) return Unit_Id;\n    pragma Inline (Corresponding_Body);\n-   --  Given a unit which is a spec for which there is a separate body, return\n+   --  Given a unit that is a spec for which there is a separate body, return\n    --  the unit id of the body. It is an error to call this routine with a unit\n-   --  that is not a spec, or which does not have a separate body.\n+   --  that is not a spec, or that does not have a separate body.\n \n    function Corresponding_Spec (U : Unit_Id) return Unit_Id;\n    pragma Inline (Corresponding_Spec);\n-   --  Given a unit which is a body for which there is a separate spec, return\n+   --  Given a unit that is a body for which there is a separate spec, return\n    --  the unit id of the spec. It is an error to call this routine with a unit\n-   --  that is not a body, or which does not have a separate spec.\n+   --  that is not a body, or that does not have a separate spec.\n \n    procedure Diagnose_Elaboration_Problem;\n    --  Called when no elaboration order can be found. Outputs an appropriate\n@@ -254,20 +259,23 @@ package body Binde is\n       Link   : Elab_All_Id);\n    --  Used to compute the transitive closure of elaboration links for an\n    --  Elaborate_All pragma (Reason = Elab_All) or for an indication of\n-   --  Elaborate_All_Desirable (Reason = Elab_All_Desirable). Unit After has\n-   --  a pragma Elaborate_All or the front end has determined that a reference\n-   --  probably requires Elaborate_All is required, and unit Before must be\n-   --  previously elaborated. First a link is built making sure that unit\n-   --  Before is elaborated before After, then a recursive call ensures that\n-   --  we also build links for any units needed by Before (i.e. these units\n-   --  must/should also be elaborated before After). Link is used to build\n-   --  a chain of Elab_All_Entries to explain the reason for a link. The\n-   --  value passed is the chain so far.\n+   --  Elaborate_All_Desirable (Reason = Elab_All_Desirable). Unit After has a\n+   --  pragma Elaborate_All or the front end has determined that a reference\n+   --  probably requires Elaborate_All, and unit Before must be previously\n+   --  elaborated. First a link is built making sure that unit Before is\n+   --  elaborated before After, then a recursive call ensures that we also\n+   --  build links for any units needed by Before (i.e. these units must/should\n+   --  also be elaborated before After). Link is used to build a chain of\n+   --  Elab_All_Entries to explain the reason for a link. The value passed is\n+   --  the chain so far.\n \n    procedure Elab_Error_Msg (S : Successor_Id);\n    --  Given a successor link, outputs an error message of the form\n    --  \"$ must be elaborated before $ ...\" where ... is the reason.\n \n+   procedure Force_Elab_Order;\n+   --  Gather dependencies from the forced elaboration order file (-f switch)\n+\n    procedure Gather_Dependencies;\n    --  Compute dependencies, building the Succ and UNR tables\n \n@@ -281,10 +289,10 @@ package body Binde is\n \n    function Is_Waiting_Body (U : Unit_Id) return Boolean;\n    pragma Inline (Is_Waiting_Body);\n-   --  Determines if U is a waiting body, defined as a body which has\n+   --  Determines if U is a waiting body, defined as a body that has\n    --  not been elaborated, but whose spec has been elaborated.\n \n-   function Make_Elab_Entry\n+   function Make_Elab_All_Entry\n      (Unam : Unit_Name_Type;\n       Link : Elab_All_Id) return Elab_All_Id;\n    --  Make an Elab_All_Entries table entry with the given Unam and Link\n@@ -419,7 +427,7 @@ package body Binde is\n       --     body of A or B?\n \n       --  The normal waiting body preference would have placed the body of\n-      --  A before the spec of B if it could. Since it could not, there it\n+      --  A before the spec of B if it could. Since it could not, then it\n       --  must be the case that A depends on B. It is therefore a good idea\n       --  to put the body of B first.\n \n@@ -445,7 +453,7 @@ package body Binde is\n \n       if not Debug_Flag_O then\n \n-         --  The following deal with the case of specs which have been marked\n+         --  The following deal with the case of specs that have been marked\n          --  as Elaborate_Body_Desirable. We generally want to delay these\n          --  specs as long as possible, so that the bodies have a better chance\n          --  of being elaborated closer to the specs.\n@@ -521,13 +529,15 @@ package body Binde is\n       Cspec : Unit_Id;\n \n    begin\n-      Succ.Increment_Last;\n-      Succ.Table (Succ.Last).Before          := Before;\n-      Succ.Table (Succ.Last).Next            := UNR.Table (Before).Successors;\n-      UNR.Table (Before).Successors          := Succ.Last;\n-      Succ.Table (Succ.Last).Reason          := R;\n-      Succ.Table (Succ.Last).Reason_Unit     := Cur_Unit;\n-      Succ.Table (Succ.Last).Elab_All_Link   := Ea_Id;\n+      Succ.Append\n+        ((Before        => Before,\n+          After         => No_Unit_Id, -- filled in below\n+          Next          => UNR.Table (Before).Successors,\n+          Reason        => R,\n+          Elab_Body     => False, -- set correctly below\n+          Reason_Unit   => Cur_Unit,\n+          Elab_All_Link => Ea_Id));\n+      UNR.Table (Before).Successors := Succ.Last;\n \n       --  Deal with special Elab_Body case. If the After of this link is\n       --  a body whose spec has Elaborate_All set, and this is not the link\n@@ -721,7 +731,7 @@ package body Binde is\n                Choose (U);\n                return True;\n \n-            --  All done if already visited, otherwise mark as visited\n+            --  All done if already visited\n \n             elsif UNR.Table (U).Visited then\n                return False;\n@@ -751,7 +761,7 @@ package body Binde is\n       --  Start of processing for Find_Path\n \n       begin\n-         --  Initialize all non-chosen nodes to not visisted yet\n+         --  Initialize all non-chosen nodes to not visited yet\n \n          for U in Units.First .. Units.Last loop\n             UNR.Table (U).Visited := UNR.Table (U).Elab_Position /= 0;\n@@ -762,7 +772,7 @@ package body Binde is\n          return Find_Link (Ufrom, 0);\n       end Find_Path;\n \n-   --  Start of processing for Diagnose_Elaboration_Error\n+   --  Start of processing for Diagnose_Elaboration_Problem\n \n    begin\n       Set_Standard_Error;\n@@ -951,7 +961,7 @@ package body Binde is\n                  (Unit_Id_Of (Withs.Table (W).Uname),\n                   After,\n                   Reason,\n-                  Make_Elab_Entry (Withs.Table (W).Uname, Link));\n+                  Make_Elab_All_Entry (Withs.Table (W).Uname, Link));\n             end;\n          end if;\n       end loop;\n@@ -962,7 +972,7 @@ package body Binde is\n          Elab_All_Links\n            (Corresponding_Body (Before),\n             After, Reason,\n-            Make_Elab_Entry\n+            Make_Elab_All_Entry\n               (Units.Table (Corresponding_Body (Before)).Uname, Link));\n       end if;\n    end Elab_All_Links;\n@@ -1006,6 +1016,11 @@ package body Binde is\n               (\"     reason: with clause\",\n                Info => True);\n \n+         when Forced =>\n+            Error_Msg_Output\n+              (\"     reason: forced by -f switch\",\n+               Info => True);\n+\n          when Elab =>\n             Error_Msg_Output\n               (\"     reason: pragma Elaborate in unit $\",\n@@ -1075,12 +1090,13 @@ package body Binde is\n       --  Initialize unit table for elaboration control\n \n       for U in Units.First .. Units.Last loop\n-         UNR.Increment_Last;\n-         UNR.Table (UNR.Last).Successors    := No_Successor;\n-         UNR.Table (UNR.Last).Num_Pred      := 0;\n-         UNR.Table (UNR.Last).Nextnp        := No_Unit_Id;\n-         UNR.Table (UNR.Last).Elab_Order    := 0;\n-         UNR.Table (UNR.Last).Elab_Position := 0;\n+         UNR.Append\n+           ((Successors    => No_Successor,\n+             Num_Pred      => 0,\n+             Nextnp        => No_Unit_Id,\n+             Elab_Order    => 0,\n+             Visited       => False,\n+             Elab_Position => 0));\n       end loop;\n \n       --  Output warning if -p used with no -gnatE units\n@@ -1186,6 +1202,193 @@ package body Binde is\n       end loop Outer;\n    end Find_Elab_Order;\n \n+   ----------------------\n+   -- Force_Elab_Order --\n+   ----------------------\n+\n+   procedure Force_Elab_Order is\n+      use System.OS_Lib;\n+      --  There is a lot of fiddly string manipulation below, because we don't\n+      --  want to depend on misc utility packages like Ada.Characters.Handling.\n+\n+      function Read_File (Name : String) return String_Ptr;\n+      --  Read the entire contents of the named file\n+\n+      function Get_Line return String;\n+      --  Read the next line from the file content read by Read_File. Strip\n+      --  leading and trailing blanks. Convert \"(spec)\" or \"(body)\" to\n+      --  \"%s\"/\"%b\". Remove comments (Ada style; \"--\" to end of line).\n+\n+      function Read_File (Name : String) return String_Ptr is\n+         --  All of the following calls should succeed, because we checked the\n+         --  file in Switch.B, but we double check and raise Program_Error on\n+         --  failure, just in case.\n+\n+         F : constant File_Descriptor := Open_Read (Name, Binary);\n+\n+      begin\n+         if F = Invalid_FD then\n+            raise Program_Error;\n+         end if;\n+\n+         declare\n+            Len : constant Natural := Natural (File_Length (F));\n+            Result : constant String_Ptr := new String (1 .. Len);\n+            Len_Read : constant Natural := Read (F, Result (1)'Address, Len);\n+            Status : Boolean;\n+\n+         begin\n+            if Len_Read /= Len then\n+               raise Program_Error;\n+            end if;\n+\n+            Close (F, Status);\n+\n+            if not Status then\n+               raise Program_Error;\n+            end if;\n+\n+            return Result;\n+         end;\n+      end Read_File;\n+\n+      S : String_Ptr := Read_File (Force_Elab_Order_File.all);\n+      Cur : Positive := 1;\n+\n+      function Get_Line return String is\n+         First : Positive := Cur;\n+         Last : Natural;\n+      begin\n+         --  Skip to end of line\n+\n+         while Cur <= S'Last\n+           and then S (Cur) /= ASCII.LF\n+           and then S (Cur) /= ASCII.CR\n+         loop\n+            Cur := Cur + 1;\n+         end loop;\n+\n+         --  Strip leading blanks\n+\n+         while First <= S'Last and then S (First) = ' ' loop\n+            First := First + 1;\n+         end loop;\n+\n+         --  Strip trailing blanks and comment\n+\n+         Last := Cur - 1;\n+\n+         for J in First .. Last - 1 loop\n+            if S (J .. J + 1) = \"--\" then\n+               Last := J - 1;\n+               exit;\n+            end if;\n+         end loop;\n+\n+         while Last >= First and then S (Last) = ' ' loop\n+            Last := Last - 1;\n+         end loop;\n+\n+         --  Convert \"(spec)\" or \"(body)\" to \"%s\"/\"%b\", strip trailing blanks\n+         --  again.\n+\n+         declare\n+            Line : String renames S (First .. Last);\n+            Spec_String : constant String := \"(spec)\";\n+            SL : constant Positive := Spec_String'Length;\n+            Body_String : constant String := \"(body)\";\n+            BL : constant Positive := Body_String'Length;\n+            Is_Spec, Is_Body : Boolean := False;\n+         begin\n+            if Line'Length >= SL\n+              and then Line (Last - SL + 1 .. Last) = Spec_String\n+            then\n+               Is_Spec := True;\n+               Last := Last - SL;\n+            elsif Line'Length >= BL\n+              and then Line (Last - BL + 1 .. Last) = Body_String\n+            then\n+               Is_Body := True;\n+               Last := Last - BL;\n+            end if;\n+\n+            while Last >= First and then S (Last) = ' ' loop\n+               Last := Last - 1;\n+            end loop;\n+\n+            --  Skip past LF or CR/LF\n+\n+            if Cur <= S'Last and then S (Cur) = ASCII.CR then\n+               Cur := Cur + 1;\n+            end if;\n+\n+            if Cur <= S'Last and then S (Cur) = ASCII.LF then\n+               Cur := Cur + 1;\n+            end if;\n+\n+            if Is_Spec then\n+               return Line (First .. Last) & \"%s\";\n+            elsif Is_Body then\n+               return Line (First .. Last) & \"%b\";\n+            else\n+               return Line;\n+            end if;\n+         end;\n+      end Get_Line;\n+\n+      Empty_Name : constant Unit_Name_Type := Name_Find (\"\");\n+      Prev_Unit : Unit_Id := No_Unit_Id;\n+\n+   begin\n+      --  Loop through the file content, and build a dependency link for each\n+      --  pair of lines. Ignore lines that should be ignored.\n+\n+      while Cur <= S'Last loop\n+         declare\n+            Uname : constant Unit_Name_Type := Name_Find (Get_Line);\n+         begin\n+            if Uname = Empty_Name then\n+               null; -- silently skip blank lines\n+\n+            elsif Get_Name_Table_Int (Uname) = 0\n+              or else Unit_Id (Get_Name_Table_Int (Uname)) = No_Unit_Id\n+            then\n+               Write_Line\n+                 (\"\"\"\" & Get_Name_String (Uname) &\n+                  \"\"\": not present; ignored\");\n+\n+            else\n+               declare\n+                  Cur_Unit : constant Unit_Id := Unit_Id_Of (Uname);\n+               begin\n+                  if Is_Internal_File_Name (Units.Table (Cur_Unit).Sfile) then\n+                     Write_Line\n+                       (\"\"\"\" & Get_Name_String (Uname) &\n+                          \"\"\": predefined unit ignored\");\n+\n+                  else\n+                     if Prev_Unit /= No_Unit_Id then\n+                        Write_Unit_Name (Units.Table (Prev_Unit).Uname);\n+                        Write_Str (\" <-- \");\n+                        Write_Unit_Name (Units.Table (Cur_Unit).Uname);\n+                        Write_Eol;\n+\n+                        Build_Link\n+                          (Before => Prev_Unit,\n+                           After => Cur_Unit,\n+                           R => Forced);\n+                     end if;\n+\n+                     Prev_Unit := Cur_Unit;\n+                  end if;\n+               end;\n+            end if;\n+         end;\n+      end loop;\n+\n+      Free (S);\n+   end Force_Elab_Order;\n+\n    -------------------------\n    -- Gather_Dependencies --\n    -------------------------\n@@ -1250,7 +1453,7 @@ package body Binde is\n \n                      Elab_All_Links\n                        (Withed_Unit, U, Elab_All,\n-                        Make_Elab_Entry\n+                        Make_Elab_All_Entry\n                           (Withs.Table (W).Uname, No_Elab_All_Link));\n \n                   --  Elaborate_All_Desirable case, for this we establish the\n@@ -1269,7 +1472,7 @@ package body Binde is\n \n                      Elab_All_Links\n                        (Withed_Unit, U, Elab_All_Desirable,\n-                        Make_Elab_Entry\n+                        Make_Elab_All_Entry\n                           (Withs.Table (W).Uname, No_Elab_All_Link));\n \n                   --  Pragma Elaborate case. We must build a link for the\n@@ -1305,7 +1508,7 @@ package body Binde is\n                      end if;\n \n                   --  A limited_with does not establish an elaboration\n-                  --  dependence (that's the whole point)..\n+                  --  dependence (that's the whole point).\n \n                   elsif Withs.Table (W).Limited_With then\n                      null;\n@@ -1323,6 +1526,13 @@ package body Binde is\n             end loop;\n          end if;\n       end loop;\n+\n+      --  If -f<elab_order> switch was given, take into account dependences\n+      --  specified in the file <elab_order>.\n+\n+      if Force_Elab_Order_File /= null then\n+         Force_Elab_Order;\n+      end if;\n    end Gather_Dependencies;\n \n    ------------------\n@@ -1344,9 +1554,9 @@ package body Binde is\n       --  If we have a body with separate spec, test flags on the spec\n \n       if Units.Table (U).Utype = Is_Body then\n-         return Units.Table (U + 1).Preelab\n+         return Units.Table (Corresponding_Spec (U)).Preelab\n                   or else\n-                Units.Table (U + 1).Pure;\n+                Units.Table (Corresponding_Spec (U)).Pure;\n \n       --  Otherwise we have a spec or body acting as spec, test flags on unit\n \n@@ -1367,11 +1577,11 @@ package body Binde is\n         and then UNR.Table (Corresponding_Spec (U)).Elab_Position /= 0;\n    end Is_Waiting_Body;\n \n-   ---------------------\n-   -- Make_Elab_Entry --\n-   ---------------------\n+   -------------------------\n+   -- Make_Elab_All_Entry --\n+   -------------------------\n \n-   function Make_Elab_Entry\n+   function Make_Elab_All_Entry\n      (Unam : Unit_Name_Type;\n       Link : Elab_All_Id) return Elab_All_Id\n    is\n@@ -1380,7 +1590,7 @@ package body Binde is\n       Elab_All_Entries.Table (Elab_All_Entries.Last).Needed_By := Unam;\n       Elab_All_Entries.Table (Elab_All_Entries.Last).Next_Elab := Link;\n       return Elab_All_Entries.Last;\n-   end Make_Elab_Entry;\n+   end Make_Elab_All_Entry;\n \n    -------------------------------\n    -- Pessimistic_Better_Choice --\n@@ -1501,7 +1711,7 @@ package body Binde is\n       --     body of A or B?\n \n       --  The normal waiting body preference would have placed the body of\n-      --  A before the spec of B if it could. Since it could not, there it\n+      --  A before the spec of B if it could. Since it could not, then it\n       --  must be the case that A depends on B. It is therefore a good idea\n       --  to put the body of B last so that if there is an elaboration order\n       --  problem, we will find it (that's what pessimistic order is about)\n@@ -1528,7 +1738,7 @@ package body Binde is\n \n       if not Debug_Flag_O then\n \n-         --  The following deal with the case of specs which have been marked\n+         --  The following deal with the case of specs that have been marked\n          --  as Elaborate_Body_Desirable. In the normal case, we generally want\n          --  to delay the elaboration of these specs as long as possible, so\n          --  that bodies have better chance of being elaborated closer to the"}, {"sha": "4481ef207076ba52832c4a940e5e024ee1bb8cce", "filename": "gcc/ada/binde.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c2c151f1204439e8b2698bf3369b8d2c29efbf/gcc%2Fada%2Fbinde.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c2c151f1204439e8b2698bf3369b8d2c29efbf/gcc%2Fada%2Fbinde.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbinde.ads?ref=10c2c151f1204439e8b2698bf3369b8d2c29efbf", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -32,10 +32,10 @@ with Types; use Types;\n package Binde is\n \n    --  The following table records the chosen elaboration order. It is used\n-   --  by Gen_Elab_Call to generate the sequence of elaboration calls. Note\n+   --  by Gen_Elab_Calls to generate the sequence of elaboration calls. Note\n    --  that units are included in this table even if they have no elaboration\n    --  routine, since the table is also used to drive the generation of object\n-   --  files in the binder output. Gen_Elab_Call skips any units that have no\n+   --  files in the binder output. Gen_Elab_Calls skips any units that have no\n    --  elaboration routine.\n \n    package Elab_Order is new Table.Table ("}, {"sha": "ede1c0ca441f9bc33336b5c110ebe8b1699856a6", "filename": "gcc/ada/bindusg.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c2c151f1204439e8b2698bf3369b8d2c29efbf/gcc%2Fada%2Fbindusg.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c2c151f1204439e8b2698bf3369b8d2c29efbf/gcc%2Fada%2Fbindusg.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindusg.adb?ref=10c2c151f1204439e8b2698bf3369b8d2c29efbf", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -113,7 +113,9 @@ package body Bindusg is\n       Write_Line (\"            and enable symbolic tracebacks\");\n       Write_Line (\"  -E        Same as -Ea\");\n \n-      --  The -f switch is voluntarily omitted, because it is obsolete\n+      --  Line for -f switch\n+\n+      Write_Line (\"  -felab-order  Force elaboration order\");\n \n       --  Line for -F switch\n "}, {"sha": "145ae93ccca74d1d98717e091ece891add76c9dd", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c2c151f1204439e8b2698bf3369b8d2c29efbf/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c2c151f1204439e8b2698bf3369b8d2c29efbf/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=10c2c151f1204439e8b2698bf3369b8d2c29efbf", "patch": "@@ -2265,9 +2265,8 @@ package body Exp_Ch6 is\n       --  extra formal.\n \n       procedure Check_View_Conversion (Formal : Entity_Id; Actual : Node_Id);\n-      --  Adds Invariant checks for every intermediate type between\n-      --  the range of a view converted argument to its ancestor (from\n-      --  parent to child).\n+      --  Adds invariant checks for every intermediate type between the range\n+      --  of a view converted argument to its ancestor (from parent to child).\n \n       function Inherited_From_Formal (S : Entity_Id) return Entity_Id;\n       --  Within an instance, a type derived from an untagged formal derived\n@@ -2361,31 +2360,35 @@ package body Exp_Ch6 is\n \n       procedure Check_View_Conversion (Formal : Entity_Id; Actual : Node_Id) is\n          Arg        : Entity_Id;\n-         Curr_Typ   : Entity_Id := Empty;\n+         Curr_Typ   : Entity_Id;\n          Inv_Checks : List_Id;\n          Par_Typ    : Entity_Id;\n \n       begin\n          Inv_Checks := No_List;\n \n-         --  Extract actual object for type conversions\n+         --  Extract the argument from a potentially nested set of view\n+         --  conversions.\n \n          Arg := Actual;\n          while Nkind (Arg) = N_Type_Conversion loop\n             Arg := Expression (Arg);\n          end loop;\n \n-         --  Move up the derivation chain starting with the type of the\n-         --  the formal parameter down to the type of the actual object.\n+         --  Move up the derivation chain starting with the type of the formal\n+         --  parameter down to the type of the actual object.\n \n-         Par_Typ := Etype (Arg);\n+         Curr_Typ := Empty;\n+         Par_Typ  := Etype (Arg);\n          while Par_Typ /= Etype (Formal) and Par_Typ /= Curr_Typ loop\n             Curr_Typ := Par_Typ;\n+\n             if Has_Invariants (Curr_Typ)\n               and then Present (Invariant_Procedure (Curr_Typ))\n             then\n                --  Verify the invariate of the current type. Generate:\n-               --    Invariant_Check_Curr_Typ (Curr_Typ (Arg));\n+\n+               --    <Curr_Typ>Invariant (Curr_Typ (Arg));\n \n                Prepend_New_To (Inv_Checks,\n                  Make_Procedure_Call_Statement (Loc,\n@@ -3292,7 +3295,7 @@ package body Exp_Ch6 is\n          --  Invariant checks are performed for every intermediate type between\n          --  the range of a view converted argument to its ancestor (from\n          --  parent to child) if it is passed as an \"out\" or \"in out\" parameter\n-         --  after executing the call (RM 7.3.2 (11-14)).\n+         --  after executing the call (RM 7.3.2 (12/3, 13/3, 14/3)).\n \n          if Ekind (Formal) /= E_In_Parameter\n            and then Nkind (Actual) = N_Type_Conversion"}, {"sha": "1a57074d89c4fcbdb23ecbc82e7d634cd37af9bf", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c2c151f1204439e8b2698bf3369b8d2c29efbf/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c2c151f1204439e8b2698bf3369b8d2c29efbf/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=10c2c151f1204439e8b2698bf3369b8d2c29efbf", "patch": "@@ -702,6 +702,10 @@ package Opt is\n    --  GNATMAKE, GPRBUILD\n    --  Set to force recompilations even when the objects are up-to-date.\n \n+   Force_Elab_Order_File : String_Ptr := null;\n+   --  GNATBIND\n+   --  File name specified for -f switch (the forced elaboration order file)\n+\n    Front_End_Inlining : Boolean := False;\n    --  GNAT\n    --  Set True to activate inlining by front-end expansion (even on GCC"}, {"sha": "f3cbdfdbc768ec4bbacdb6798bb8cdf4b4f70dc5", "filename": "gcc/ada/spark_xrefs.ads", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c2c151f1204439e8b2698bf3369b8d2c29efbf/gcc%2Fada%2Fspark_xrefs.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c2c151f1204439e8b2698bf3369b8d2c29efbf/gcc%2Fada%2Fspark_xrefs.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fspark_xrefs.ads?ref=10c2c151f1204439e8b2698bf3369b8d2c29efbf", "patch": "@@ -25,9 +25,9 @@\n \n --  This package defines tables used to store information needed for the SPARK\n --  mode. It is used by procedures in Lib.Xref.SPARK_Specific to build the\n---  SPARK specific cross-references information before writing it out to the\n---  ALI file, and by Get_SPARK_Xrefs/Put_SPARK_Xrefs to read and write the text\n---  form that is used in the ALI file.\n+--  SPARK-specific cross-reference information before writing it to the ALI\n+--  file, and by Get_SPARK_Xrefs/Put_SPARK_Xrefs to read/write the textual\n+--  representation that is stored in the ALI file.\n \n with Types;      use Types;\n with GNAT.Table;\n@@ -128,8 +128,9 @@ package SPARK_Xrefs is\n    --  -- Xref Section --\n    --  ------------------\n \n-   --  A second section defines cross-references useful for computing the set\n-   --  of global variables read/written in each subprogram/package.\n+   --  A second section defines cross-references useful for computing global\n+   --  variables read/written in each subprogram/package/protected_type/\n+   --  task_type.\n \n    --    FX dependency-number filename . entity-number entity\n \n@@ -197,14 +198,13 @@ package SPARK_Xrefs is\n \n    --  The Generated Globals section is located at the end of the ALI file\n \n-   --  All lines introducing information related to the Generated Globals\n-   --  have the string \"GG\" appearing in the beginning. This string (\"GG\")\n-   --  should therefore not be used in the beginning of any line that does\n-   --  not relate to Generated Globals.\n+   --  All lines with information related to the Generated Globals begin with\n+   --  string \"GG\". This string should therefore not be used in the beginning\n+   --  of any line not related to Generated Globals.\n \n-   --  The processing (reading and writing) of this section happens in\n-   --  package Flow_Generated_Globals (from the SPARK 2014 sources), for\n-   --  further information please refer there.\n+   --  The processing (reading and writing) of this section happens in package\n+   --  Flow_Generated_Globals (from the SPARK 2014 sources), for further\n+   --  information please refer there.\n \n    ----------------\n    -- Xref Table --\n@@ -235,20 +235,20 @@ package SPARK_Xrefs is\n       --  Column number for the entity referenced\n \n       File_Num : Nat;\n-      --  Set to the file dependency number for the cross-reference. Note\n-      --  that if no file entry is present explicitly, this is just a copy\n-      --  of the reference for the current cross-reference section.\n+      --  File dependency number for the cross-reference. Note that if no file\n+      --  entry is present explicitly, this is just a copy of the reference for\n+      --  the current cross-reference section.\n \n       Scope_Num : Nat;\n-      --  Set to the scope number for the cross-reference. Note that if no\n-      --  scope entry is present explicitly, this is just a copy of the\n-      --  reference for the current cross-reference section.\n+      --  Scope number for the cross-reference. Note that if no scope entry is\n+      --  present explicitly, this is just a copy of the reference for the\n+      --  current cross-reference section.\n \n       Line : Nat;\n       --  Line number for the reference\n \n       Rtype : Character;\n-      --  Indicates type of reference, using code used in ALI file:\n+      --  Indicates type of the reference, using code used in ALI file:\n       --    r = reference\n       --    c = reference to constant object\n       --    m = modification\n@@ -348,7 +348,7 @@ package SPARK_Xrefs is\n \n       Unit_File_Name : String_Ptr;\n       --  Pointer to file name for unit in ALI file, when File_Name refers to a\n-      --  subunit. Otherwise null.\n+      --  subunit; otherwise null.\n \n       File_Num : Nat;\n       --  Dependency number in ALI file"}, {"sha": "71ee61ad42615020465b97737a1a5452b1dcf82e", "filename": "gcc/ada/switch-b.adb", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c2c151f1204439e8b2698bf3369b8d2c29efbf/gcc%2Fada%2Fswitch-b.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c2c151f1204439e8b2698bf3369b8d2c29efbf/gcc%2Fada%2Fswitch-b.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-b.adb?ref=10c2c151f1204439e8b2698bf3369b8d2c29efbf", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -28,6 +28,7 @@ with Debug;  use Debug;\n with Osint;  use Osint;\n with Opt;    use Opt;\n \n+with System.OS_Lib;  use System.OS_Lib;\n with System.WCh_Con; use System.WCh_Con;\n \n package body Switch.B is\n@@ -252,6 +253,22 @@ package body Switch.B is\n                Ptr := Ptr + 1;\n             end if;\n \n+         --  Processing for f switch\n+\n+         when 'f' =>\n+            if Ptr = Max then\n+               Bad_Switch (Switch_Chars);\n+            end if;\n+\n+            Force_Elab_Order_File :=\n+              new String'(Switch_Chars (Ptr + 1 .. Max));\n+\n+            Ptr := Max + 1;\n+\n+            if not Is_Read_Accessible_File (Force_Elab_Order_File.all) then\n+               Osint.Fail (Force_Elab_Order_File.all & \": file not found\");\n+            end if;\n+\n          --  Processing for F switch\n \n          when 'F' =>"}]}