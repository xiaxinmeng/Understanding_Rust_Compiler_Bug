{"sha": "8ca864d2a8cfd66dadfce83846651504c0975e3c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGNhODY0ZDJhOGNmZDY2ZGFkZmNlODM4NDY2NTE1MDRjMDk3NWUzYw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@libertysurf.fr", "date": "2005-04-22T13:25:57Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2005-04-22T13:25:57Z"}, "message": "predicates.md (arith_double_operand): Use trunc_int_for_mode if HOST_BITS_PER_WIDE_INT >=64.\n\n\t* config/sparc/predicates.md (arith_double_operand): Use\n\ttrunc_int_for_mode if HOST_BITS_PER_WIDE_INT >=64.\n\t* config/sparc/sparc.md (movqi, movhi, movsi, movqi): Use gen_int_mode.\n\t(DImode, DFmode constant splitters): Likewise.  Remove code for\n\tTARGET_ARCH64 && HOST_BITS_PER_WIDE_INT < 64.\n\t(logical constant splitters): Use const_int_operand predicate.\n\t(lshrsi3_extend): Remove code for TARGET_ARCH64 &&\n\tHOST_BITS_PER_WIDE_INT < 64.\n\nFrom-SVN: r98560", "tree": {"sha": "8422d0da8cd90e28928ed5f561f883de2f3b980d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8422d0da8cd90e28928ed5f561f883de2f3b980d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ca864d2a8cfd66dadfce83846651504c0975e3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ca864d2a8cfd66dadfce83846651504c0975e3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ca864d2a8cfd66dadfce83846651504c0975e3c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ca864d2a8cfd66dadfce83846651504c0975e3c/comments", "author": {"login": "ebotcazou", "id": 48091907, "node_id": "MDQ6VXNlcjQ4MDkxOTA3", "avatar_url": "https://avatars.githubusercontent.com/u/48091907?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebotcazou", "html_url": "https://github.com/ebotcazou", "followers_url": "https://api.github.com/users/ebotcazou/followers", "following_url": "https://api.github.com/users/ebotcazou/following{/other_user}", "gists_url": "https://api.github.com/users/ebotcazou/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebotcazou/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebotcazou/subscriptions", "organizations_url": "https://api.github.com/users/ebotcazou/orgs", "repos_url": "https://api.github.com/users/ebotcazou/repos", "events_url": "https://api.github.com/users/ebotcazou/events{/privacy}", "received_events_url": "https://api.github.com/users/ebotcazou/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "144d51f9df000e9be80c419cb73f3823b50e85eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/144d51f9df000e9be80c419cb73f3823b50e85eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/144d51f9df000e9be80c419cb73f3823b50e85eb"}], "stats": {"total": 86, "additions": 40, "deletions": 46}, "files": [{"sha": "5f59f262ab99c2d9cfa0b8fbb905178a179d0164", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ca864d2a8cfd66dadfce83846651504c0975e3c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ca864d2a8cfd66dadfce83846651504c0975e3c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8ca864d2a8cfd66dadfce83846651504c0975e3c", "patch": "@@ -1,3 +1,14 @@\n+2005-04-22  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\t* config/sparc/predicates.md (arith_double_operand): Use\n+\ttrunc_int_for_mode if HOST_BITS_PER_WIDE_INT >=64.\n+\t* config/sparc/sparc.md (movqi, movhi, movsi, movqi): Use gen_int_mode.\n+\t(DImode, DFmode constant splitters): Likewise.  Remove code for\n+\tTARGET_ARCH64 && HOST_BITS_PER_WIDE_INT < 64.\n+\t(logical constant splitters): Use const_int_operand predicate.\n+\t(lshrsi3_extend): Remove code for TARGET_ARCH64 &&\n+\tHOST_BITS_PER_WIDE_INT < 64.\n+\n 2005-04-22  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* config/pa/pa.c (legitimize_pic_address): Use gcc_assert and"}, {"sha": "8aba0e3cfb6c98efef49368bcd024dcacb2a77a8", "filename": "gcc/config/sparc/predicates.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ca864d2a8cfd66dadfce83846651504c0975e3c/gcc%2Fconfig%2Fsparc%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ca864d2a8cfd66dadfce83846651504c0975e3c/gcc%2Fconfig%2Fsparc%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fpredicates.md?ref=8ca864d2a8cfd66dadfce83846651504c0975e3c", "patch": "@@ -287,8 +287,8 @@\n #else\n   if (GET_CODE (op) != CONST_INT)\n     return false;\n-  m1 = INTVAL (op) & 0xffffffff;\n-  m2 = INTVAL (op) >> 32;\n+  m1 = trunc_int_for_mode (INTVAL (op), SImode);\n+  m2 = trunc_int_for_mode (INTVAL (op) >> 32, SImode);\n #endif\n \n   return SPARC_SIMM13_P (m1) && SPARC_SIMM13_P (m2);\n@@ -337,7 +337,7 @@\n \n ;; Return true if OP is valid for the lhs of a comparison insn.\n (define_predicate \"compare_operand\"\n-  (match_code \"reg, subreg, zero_extract\")\n+  (match_code \"reg,subreg,zero_extract\")\n {\n   if (GET_CODE (op) == ZERO_EXTRACT)\n     return (register_operand (XEXP (op, 0), mode)"}, {"sha": "084657986c6dde72c9c791371c0a0b891030f2dd", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 26, "deletions": 43, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ca864d2a8cfd66dadfce83846651504c0975e3c/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ca864d2a8cfd66dadfce83846651504c0975e3c/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=8ca864d2a8cfd66dadfce83846651504c0975e3c", "patch": "@@ -1727,10 +1727,7 @@\n   /* Working with CONST_INTs is easier, so convert\n      a double if needed.  */\n   if (GET_CODE (operands[1]) == CONST_DOUBLE)\n-    {\n-      operands[1] = GEN_INT (trunc_int_for_mode\n-\t\t\t     (CONST_DOUBLE_LOW (operands[1]), QImode));\n-    }\n+    operands[1] = gen_int_mode (CONST_DOUBLE_LOW (operands[1]), QImode);\n \n   /* Handle sets of MEM first.  */\n   if (GET_CODE (operands[0]) == MEM)\n@@ -1793,7 +1790,7 @@\n   /* Working with CONST_INTs is easier, so convert\n      a double if needed.  */\n   if (GET_CODE (operands[1]) == CONST_DOUBLE)\n-    operands[1] = GEN_INT (CONST_DOUBLE_LOW (operands[1]));\n+    operands[1] = gen_int_mode (CONST_DOUBLE_LOW (operands[1]), HImode);\n \n   /* Handle sets of MEM first.  */\n   if (GET_CODE (operands[0]) == MEM)\n@@ -1879,7 +1876,7 @@\n   /* Working with CONST_INTs is easier, so convert\n      a double if needed.  */\n   if (GET_CODE (operands[1]) == CONST_DOUBLE)\n-    operands[1] = GEN_INT (CONST_DOUBLE_LOW (operands[1]));\n+    operands[1] = gen_int_mode (CONST_DOUBLE_LOW (operands[1]), SImode);\n \n   /* Handle sets of MEM first.  */\n   if (GET_CODE (operands[0]) == MEM)\n@@ -2045,7 +2042,8 @@\n \t(match_operand:DI 1 \"general_operand\" \"\"))]\n   \"\"\n {\n-  /* Where possible, convert CONST_DOUBLE into a CONST_INT.  */\n+  /* Working with CONST_INTs is easier, so convert\n+     a double if needed.  */\n   if (GET_CODE (operands[1]) == CONST_DOUBLE\n #if HOST_BITS_PER_WIDE_INT == 32\n       && ((CONST_DOUBLE_HIGH (operands[1]) == 0\n@@ -2054,7 +2052,7 @@\n \t      && (CONST_DOUBLE_LOW (operands[1]) & 0x80000000) != 0))\n #endif\n       )\n-    operands[1] = GEN_INT (CONST_DOUBLE_LOW (operands[1]));\n+    operands[1] = gen_int_mode (CONST_DOUBLE_LOW (operands[1]), DImode);\n \n   /* Handle MEM cases first.  */\n   if (GET_CODE (operands[0]) == MEM)\n@@ -2481,8 +2479,8 @@\n   /* Slick... but this trick loses if this subreg constant part\n      can be done in one insn.  */\n   if (CONST_DOUBLE_LOW (operands[1]) == CONST_DOUBLE_HIGH (operands[1])\n-      && !(SPARC_SETHI32_P (CONST_DOUBLE_HIGH (operands[1]))\n-\t   || SPARC_SIMM13_P (CONST_DOUBLE_HIGH (operands[1]))))\n+      && ! SPARC_SETHI32_P (CONST_DOUBLE_HIGH (operands[1]))\n+      && ! SPARC_SIMM13_P (CONST_DOUBLE_HIGH (operands[1])))\n     {\n       emit_insn (gen_movsi (gen_lowpart (SImode, operands[0]),\n \t\t\t    gen_highpart (SImode, operands[0])));\n@@ -3090,35 +3088,34 @@\n \n   if (TARGET_ARCH64)\n     {\n-#if HOST_BITS_PER_WIDE_INT == 64\n+#if HOST_BITS_PER_WIDE_INT == 32\n+      gcc_unreachable ();\n+#else\n       HOST_WIDE_INT val;\n \n       val = ((HOST_WIDE_INT)(unsigned long)l[1] |\n              ((HOST_WIDE_INT)(unsigned long)l[0] << 32));\n-      emit_insn (gen_movdi (operands[0], GEN_INT (val)));\n-#else\n-      emit_insn (gen_movdi (operands[0],\n-                            immed_double_const (l[1], l[0], DImode)));\n+      emit_insn (gen_movdi (operands[0], gen_int_mode (val, DImode)));\n #endif\n     }\n   else\n     {\n       emit_insn (gen_movsi (gen_highpart (SImode, operands[0]),\n-\t\t\t    GEN_INT (l[0])));\n+\t\t\t    gen_int_mode (l[0], SImode)));\n \n       /* Slick... but this trick loses if this subreg constant part\n          can be done in one insn.  */\n       if (l[1] == l[0]\n-          && !(SPARC_SETHI32_P (l[0])\n-\t       || SPARC_SIMM13_P (l[0])))\n+\t  && ! SPARC_SETHI32_P (l[0])\n+\t  && ! SPARC_SIMM13_P (l[0]))\n         {\n           emit_insn (gen_movsi (gen_lowpart (SImode, operands[0]),\n \t\t\t        gen_highpart (SImode, operands[0])));\n         }\n       else\n         {\n           emit_insn (gen_movsi (gen_lowpart (SImode, operands[0]),\n-\t\t\t        GEN_INT (l[1])));\n+\t\t\t        gen_int_mode (l[1], SImode)));\n         }\n     }\n   DONE;\n@@ -5899,11 +5896,9 @@\n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(and:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t(match_operand:SI 2 \"\" \"\")))\n+\t\t(match_operand:SI 2 \"const_int_operand\" \"\")))\n    (clobber (match_operand:SI 3 \"register_operand\" \"\"))]\n-  \"GET_CODE (operands[2]) == CONST_INT\n-   && !SMALL_INT (operands[2])\n-   && (INTVAL (operands[2]) & 0x3ff) == 0x3ff\"\n+  \"!SMALL_INT (operands[2]) && (INTVAL (operands[2]) & 0x3ff) == 0x3ff\"\n   [(set (match_dup 3) (match_dup 4))\n    (set (match_dup 0) (and:SI (not:SI (match_dup 3)) (match_dup 1)))]\n {\n@@ -6002,11 +5997,9 @@\n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(ior:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t(match_operand:SI 2 \"\" \"\")))\n+\t\t(match_operand:SI 2 \"const_int_operand\" \"\")))\n    (clobber (match_operand:SI 3 \"register_operand\" \"\"))]\n-  \"GET_CODE (operands[2]) == CONST_INT\n-   && !SMALL_INT (operands[2])\n-   && (INTVAL (operands[2]) & 0x3ff) == 0x3ff\"\n+  \"!SMALL_INT (operands[2]) && (INTVAL (operands[2]) & 0x3ff) == 0x3ff\"\n   [(set (match_dup 3) (match_dup 4))\n    (set (match_dup 0) (ior:SI (not:SI (match_dup 3)) (match_dup 1)))]\n {\n@@ -6105,11 +6098,9 @@\n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(xor:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t(match_operand:SI 2 \"\" \"\")))\n+\t\t(match_operand:SI 2 \"const_int_operand\" \"\")))\n    (clobber (match_operand:SI 3 \"register_operand\" \"\"))]\n-  \"GET_CODE (operands[2]) == CONST_INT\n-   && !SMALL_INT (operands[2])\n-   && (INTVAL (operands[2]) & 0x3ff) == 0x3ff\"\n+   \"!SMALL_INT (operands[2]) && (INTVAL (operands[2]) & 0x3ff) == 0x3ff\"\n   [(set (match_dup 3) (match_dup 4))\n    (set (match_dup 0) (not:SI (xor:SI (match_dup 3) (match_dup 1))))]\n {\n@@ -6119,11 +6110,9 @@\n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(not:SI (xor:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t\t(match_operand:SI 2 \"\" \"\"))))\n+\t\t\t(match_operand:SI 2 \"const_int_operand\" \"\"))))\n    (clobber (match_operand:SI 3 \"register_operand\" \"\"))]\n-  \"GET_CODE (operands[2]) == CONST_INT\n-   && !SMALL_INT (operands[2])\n-   && (INTVAL (operands[2]) & 0x3ff) == 0x3ff\"\n+  \"!SMALL_INT (operands[2]) && (INTVAL (operands[2]) & 0x3ff) == 0x3ff\"\n   [(set (match_dup 3) (match_dup 4))\n    (set (match_dup 0) (xor:SI (match_dup 3) (match_dup 1)))]\n {\n@@ -7100,14 +7089,8 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(and:DI (subreg:DI (lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t\t   (match_operand:SI 2 \"arith_operand\" \"r\")) 0)\n-\t\t(match_operand 3 \"\" \"\")))]\n-  \"TARGET_ARCH64\n-   && ((GET_CODE (operands[3]) == CONST_DOUBLE\n-           && CONST_DOUBLE_HIGH (operands[3]) == 0\n-           && CONST_DOUBLE_LOW (operands[3]) == 0xffffffff)\n-       || (HOST_BITS_PER_WIDE_INT >= 64\n-\t   && GET_CODE (operands[3]) == CONST_INT\n-           && (unsigned HOST_WIDE_INT) INTVAL (operands[3]) == 0xffffffff))\"\n+\t\t(match_operand 3 \"const_int_operand\" \"\")))]\n+  \"TARGET_ARCH64 && (unsigned HOST_WIDE_INT) INTVAL (operands[3]) == 0xffffffff\"\n   \"srl\\t%1, %2, %0\"\n   [(set_attr \"type\" \"shift\")])\n "}]}