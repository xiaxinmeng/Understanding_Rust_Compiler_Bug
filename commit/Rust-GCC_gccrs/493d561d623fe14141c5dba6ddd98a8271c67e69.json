{"sha": "493d561d623fe14141c5dba6ddd98a8271c67e69", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDkzZDU2MWQ2MjNmZTE0MTQxYzVkYmE2ZGRkOThhODI3MWM2N2U2OQ==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@cygnus.com", "date": "2001-01-24T08:08:36Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "2001-01-24T08:08:36Z"}, "message": "class.c (layout_class): Don't lay the superclass out if it's already being laid out.\n\n2001-01-23  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n\t* class.c (layout_class): Don't lay the superclass out if it's\n\talready being laid out.\n\t* jcf-parse.c (handle_innerclass_attribute): New function.\n\t(HANDLE_INNERCLASSES_ATTRIBUTE): Invoke\n\thandle_innerclasses_attribute.\n\t(jcf_parse): Don't load an innerclasses if it's already being\n\tlaid out.\n\t* jcf-write.c (append_innerclass_attribute_entry): Static\n\t`anonymous_name' and its initialization deleted. `ocii' and `ini'\n\tto be zero for anonymous classes.\n\n2001-01-23  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n\t* class.c (set_constant_value): Set DECL_FIELD_FINAL_IUD if\n\tnecessary.\n\t* jcf-parse.c (set_source_filename): Use\n\tMAYBE_CREATE_VAR_LANG_DECL_SPECIFIC if necessary.\n\n2001-01-23  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n\t* expr.c (build_jni_stub): Set DECL_CONTEXT on `meth_var' so it\n\tgets a unique asm name.\n\n2001-01-23  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n\t* jcf-parse.c (HANDLE_END_METHODS): Nullify current_method.\n\t(HANDLE_START_FIELD): Invoke MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC\n\tif necessary.\n\t(HANDLE_SYNTHETIC_ATTRIBUTE): New macro.\n\t* jcf-reader.c (get_attribute): Handle `Synthetic' attribute.\n\t* parse.y (lookup_package_type_and_set_next): Deleted.\n\t(resolve_package): Removed unnecessary code.\n\t(find_applicable_accessible_methods_list): `finit$' can't be\n \tinherited.\n\t* verify.c (pop_argument_types): Added missing prototype.\n\n(http://gcc.gnu.org/ml/gcc-patches/2001-01/msg01812.html)\n\nFrom-SVN: r39230", "tree": {"sha": "b3ca35263ce6de5b0c268b75d5186f60cd6b2f19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b3ca35263ce6de5b0c268b75d5186f60cd6b2f19"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/493d561d623fe14141c5dba6ddd98a8271c67e69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/493d561d623fe14141c5dba6ddd98a8271c67e69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/493d561d623fe14141c5dba6ddd98a8271c67e69", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/493d561d623fe14141c5dba6ddd98a8271c67e69/comments", "author": null, "committer": null, "parents": [{"sha": "0851111417ad065a9513312dede39bcfa2491516", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0851111417ad065a9513312dede39bcfa2491516", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0851111417ad065a9513312dede39bcfa2491516"}], "stats": {"total": 232, "additions": 139, "deletions": 93}, "files": [{"sha": "c610918465c2a36d713902aa41244da52ba1ffee", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/493d561d623fe14141c5dba6ddd98a8271c67e69/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/493d561d623fe14141c5dba6ddd98a8271c67e69/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=493d561d623fe14141c5dba6ddd98a8271c67e69", "patch": "@@ -1,3 +1,41 @@\n+2001-01-23  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* class.c (layout_class): Don't lay the superclass out if it's\n+\talready being laid out.\n+\t* jcf-parse.c (handle_innerclass_attribute): New function.\n+\t(HANDLE_INNERCLASSES_ATTRIBUTE): Invoke\n+\thandle_innerclasses_attribute.\n+\t(jcf_parse): Don't load an innerclasses if it's already being\n+\tlaid out.\n+\t* jcf-write.c (append_innerclass_attribute_entry): Static\n+\t`anonymous_name' and its initialization deleted. `ocii' and `ini'\n+\tto be zero for anonymous classes.\n+\n+2001-01-23  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* class.c (set_constant_value): Set DECL_FIELD_FINAL_IUD if\n+\tnecessary.\n+\t* jcf-parse.c (set_source_filename): Use\n+\tMAYBE_CREATE_VAR_LANG_DECL_SPECIFIC if necessary.\n+\n+2001-01-23  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* expr.c (build_jni_stub): Set DECL_CONTEXT on `meth_var' so it\n+\tgets a unique asm name.\n+\n+2001-01-23  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* jcf-parse.c (HANDLE_END_METHODS): Nullify current_method.\n+\t(HANDLE_START_FIELD): Invoke MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC\n+\tif necessary.\n+\t(HANDLE_SYNTHETIC_ATTRIBUTE): New macro.\n+\t* jcf-reader.c (get_attribute): Handle `Synthetic' attribute.\n+\t* parse.y (lookup_package_type_and_set_next): Deleted.\n+\t(resolve_package): Removed unnecessary code.\n+\t(find_applicable_accessible_methods_list): `finit$' can't be\n+ \tinherited.\n+\t* verify.c (pop_argument_types): Added missing prototype.\n+\n 2001-01-23  Bryce McKinlay  <bryce@albatross.co.nz>\n \n \t* config-lang.in: Disable java by default."}, {"sha": "3d88143d36bc4aabef2fcaa2c626e5f09b513bdc", "filename": "gcc/java/class.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/493d561d623fe14141c5dba6ddd98a8271c67e69/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/493d561d623fe14141c5dba6ddd98a8271c67e69/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=493d561d623fe14141c5dba6ddd98a8271c67e69", "patch": "@@ -743,7 +743,11 @@ set_constant_value (field, constant)\n     warning (\"duplicate ConstanValue atribute for field '%s'\",\n \t     IDENTIFIER_POINTER (DECL_NAME (field)));\n   else\n-    DECL_INITIAL (field) = constant;\n+    {\n+      DECL_INITIAL (field) = constant;\n+      if (FIELD_FINAL (field))\n+\tDECL_FIELD_FINAL_IUD (field) = 1;\n+    }\n }\n \n /* Count the number of Unicode chars encoded in a given Ut8 string. */\n@@ -1655,7 +1659,7 @@ layout_class (this_class)\n     }\n   CLASS_BEING_LAIDOUT (this_class) = 1;\n \n-  if (super_class)\n+  if (super_class && !CLASS_BEING_LAIDOUT (super_class))\n     {\n       tree maybe_super_class \n \t= maybe_layout_super_class (super_class, this_class);"}, {"sha": "f42cc4510043542019ba9038f619aea73ba5b147", "filename": "gcc/java/expr.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/493d561d623fe14141c5dba6ddd98a8271c67e69/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/493d561d623fe14141c5dba6ddd98a8271c67e69/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=493d561d623fe14141c5dba6ddd98a8271c67e69", "patch": "@@ -2024,6 +2024,7 @@ build_jni_stub (method)\n   TREE_STATIC (meth_var) = 1;\n   TREE_PUBLIC (meth_var) = 0;\n   DECL_EXTERNAL (meth_var) = 0;\n+  DECL_CONTEXT (meth_var) = method;\n   make_decl_rtl (meth_var, NULL);\n   meth_var = pushdecl_top_level (meth_var);\n "}, {"sha": "10baf59dc5bdc1d927e1b58b660ee85a843a9301", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 63, "deletions": 24, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/493d561d623fe14141c5dba6ddd98a8271c67e69/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/493d561d623fe14141c5dba6ddd98a8271c67e69/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=493d561d623fe14141c5dba6ddd98a8271c67e69", "patch": "@@ -85,6 +85,7 @@ static tree parse_roots[3] = { NULL_TREE, NULL_TREE, NULL_TREE };\n static struct JCF main_jcf[1];\n \n /* Declarations of some functions used here.  */\n+static void handle_innerclass_attribute PARAMS ((int count, JCF *));\n static tree give_name_to_class PARAMS ((JCF *jcf, int index));\n static void parse_zip_file_entries PARAMS ((void));\n static void process_zip_dir PARAMS ((FILE *));\n@@ -158,7 +159,10 @@ set_source_filename (jcf, index)\n { int sig_index = SIGNATURE; \\\n   current_field = add_field (current_class, get_name_constant (jcf, NAME), \\\n \t\t\t     parse_signature (jcf, sig_index), ACCESS_FLAGS); \\\n- set_java_signature (TREE_TYPE (current_field), JPOOL_UTF (jcf, sig_index)); }\n+ set_java_signature (TREE_TYPE (current_field), JPOOL_UTF (jcf, sig_index)); \\\n+ if ((ACCESS_FLAGS) & ACC_FINAL) \\\n+   MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC (current_field); \\\n+}\n \n #define HANDLE_END_FIELDS() \\\n   (current_field = NULL_TREE)\n@@ -182,7 +186,8 @@ set_source_filename (jcf, index)\n \n #define HANDLE_END_METHODS() \\\n { tree handle_type = CLASS_TO_HANDLE_TYPE (current_class); \\\n-  if (handle_type != current_class) layout_type (handle_type); }\n+  if (handle_type != current_class) layout_type (handle_type); \\\n+  current_method = NULL_TREE; }\n \n #define HANDLE_CODE_ATTRIBUTE(MAX_STACK, MAX_LOCALS, CODE_LENGTH) \\\n { DECL_MAX_STACK (current_method) = (MAX_STACK); \\\n@@ -214,27 +219,16 @@ set_source_filename (jcf, index)\n \n /* Link seen inner classes to their outer context and register the\n    inner class to its outer context. They will be later loaded.  */\n-#define HANDLE_INNERCLASSES_ATTRIBUTE(COUNT)\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  int c = (count);\t\t\t\t\t\t\t  \\\n-  while (c--)\t\t\t\t\t\t\t\t  \\\n-    {\t\t\t\t\t\t\t\t\t  \\\n-      tree class = get_class_constant (jcf, JCF_readu2 (jcf));\t   \t  \\\n-      tree decl = TYPE_NAME (class);\t\t\t\t\t  \\\n-      if (DECL_P (decl) && !CLASS_COMPLETE_P (decl))\t\t\t  \\\n-\t{\t\t\t\t\t\t\t\t  \\\n-\t  tree outer = TYPE_NAME (get_class_constant (jcf, \t\t  \\\n-\t\t\t\t\t\t      JCF_readu2 (jcf))); \\\n-\t  tree alias = get_name_constant (jcf, JCF_readu2 (jcf));\t  \\\n-\t  JCF_SKIP (jcf, 2);\t\t\t\t\t     \t  \\\n-\t  DECL_CONTEXT (decl) = outer;\t\t\t\t\t  \\\n-\t  DECL_INNER_CLASS_LIST (outer) = \t\t\t\t  \\\n-\t    tree_cons (decl, alias, DECL_INNER_CLASS_LIST (outer));\t  \\\n-\t  CLASS_COMPLETE_P (decl) = 1;\t\t\t\t\t  \\\n-\t}\t\t\t\t\t\t\t\t  \\\n-      else\t\t\t\t\t\t\t\t  \\\n-\tJCF_SKIP (jcf, 6);\t\t\t\t\t\t  \\\n-    }\t\t\t\t\t\t\t\t\t  \\\n+#define HANDLE_INNERCLASSES_ATTRIBUTE(COUNT) \\\n+  handle_innerclass_attribute (COUNT, jcf)\n+\n+#define HANDLE_SYNTHETIC_ATTRIBUTE()\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  /* Irrelevant decls should have been nullified by the END macros. */ \\\n+  if (current_method)\t\t\t\t\t\t\t\\\n+    DECL_ARTIFICIAL (current_method) = 1;\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    DECL_ARTIFICIAL (current_field) = 1;\t\t\t\t\\\n }\n \n #include \"jcf-reader.c\"\n@@ -440,6 +434,46 @@ get_name_constant (jcf, index)\n   return name;\n }\n \n+/* Handle reading innerclass attributes. If a non zero entry (denoting\n+   a non anonymous entry) is found, We augment the inner class list of\n+   the outer context with the newly resolved innerclass.  */\n+\n+static void\n+handle_innerclass_attribute (count, jcf)\n+     int count;\n+     JCF *jcf;\n+{\n+  int c = (count);\n+  while (c--)\n+    {\n+      /* Read inner_class_info_index. This may be 0 */\n+      int icii = JCF_readu2 (jcf);\n+      /* Read outer_class_info_index. If the innerclasses attribute\n+\t entry isn't a member (like an inner class) the value is 0. */\n+      int ocii = JCF_readu2 (jcf);\n+      /* Read inner_name_index. If the class we're dealing with is\n+\t an annonymous class, it must be 0. */\n+      int ini = JCF_readu2 (jcf);\n+      /* If icii is 0, don't try to read the class. */\n+      if (icii >= 0)\n+\t{\n+\t  tree class = get_class_constant (jcf, icii);\n+\t  tree decl = TYPE_NAME (class);\n+          /* Skip reading further if ocii is null */\n+          if (DECL_P (decl) && !CLASS_COMPLETE_P (decl) && ocii)\n+\t    {\n+\t      tree outer = TYPE_NAME (get_class_constant (jcf, ocii));\n+\t      tree alias = (ini ? get_name_constant (jcf, ini) : NULL_TREE);\n+\t      DECL_CONTEXT (decl) = outer;\n+\t      DECL_INNER_CLASS_LIST (outer) =\n+\t\ttree_cons (decl, alias, DECL_INNER_CLASS_LIST (outer));\n+\t      CLASS_COMPLETE_P (decl) = 1;\n+            }\n+\t}\n+      JCF_SKIP (jcf, 2);\n+    }\n+}\n+\n static tree\n give_name_to_class (jcf, i)\n      JCF *jcf;\n@@ -677,7 +711,12 @@ jcf_parse (jcf)\n   /* And if we came across inner classes, load them now. */\n   for (current = DECL_INNER_CLASS_LIST (TYPE_NAME (current_class)); current;\n        current = TREE_CHAIN (current))\n-    load_class (DECL_NAME (TREE_PURPOSE (current)), 1);\n+    {\n+      tree name = DECL_NAME (TREE_PURPOSE (current));\n+      tree decl = IDENTIFIER_GLOBAL_VALUE (name);\n+      if (decl && !CLASS_BEING_LAIDOUT (TREE_TYPE (decl)))\n+\tload_class (name, 1);\n+    }\n }\n \n void"}, {"sha": "f34bddb6e755c5f2a7331a3bb8b64815c31dbd74", "filename": "gcc/java/jcf-reader.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/493d561d623fe14141c5dba6ddd98a8271c67e69/gcc%2Fjava%2Fjcf-reader.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/493d561d623fe14141c5dba6ddd98a8271c67e69/gcc%2Fjava%2Fjcf-reader.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-reader.c?ref=493d561d623fe14141c5dba6ddd98a8271c67e69", "patch": "@@ -205,6 +205,13 @@ DEFUN(get_attribute, (jcf),\n       HANDLE_INNERCLASSES_ATTRIBUTE (count);\n     }\n   else\n+#endif\n+#ifdef HANDLE_SYNTHETIC_ATTRIBUTE\n+  if (name_length == 9 && memcmp (name_data, \"Synthetic\", 9) == 0)\n+    {\n+      HANDLE_SYNTHETIC_ATTRIBUTE ();\n+    }\n+  else\n #endif\n     {\n #ifdef PROCESS_OTHER_ATTRIBUTE"}, {"sha": "1106a75953051b6aaf07433eb1cc1110f84160f3", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/493d561d623fe14141c5dba6ddd98a8271c67e69/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/493d561d623fe14141c5dba6ddd98a8271c67e69/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=493d561d623fe14141c5dba6ddd98a8271c67e69", "patch": "@@ -3216,27 +3216,24 @@ append_innerclasses_attribute_entry (state, decl, name)\n      struct jcf_partial *state;\n      tree decl, name;\n {\n-  static tree anonymous_name = NULL_TREE;\n-  int icii, ocii, ini, icaf;\n+  int icii, icaf;\n+  int ocii = 0, ini = 0;\n   unsigned char *ptr = append_chunk (NULL, 8, state);\n \n-  if (!anonymous_name)\n+  icii = find_class_constant (&state->cpool, TREE_TYPE (decl));\n+\n+  /* Sun's implementation seems to generate ocii to 0 for inner\n+     classes (which aren't considered members of the class they're\n+     in.) The specs are saying that if the class is anonymous,\n+     inner_name_index must be zero. */\n+  if (!ANONYMOUS_CLASS_P (TREE_TYPE (decl)))\n     {\n-      anonymous_name = get_identifier (\"\");\n-      ggc_add_tree_root (&anonymous_name, 1);\n+      ocii = find_class_constant (&state->cpool, \n+\t\t\t\t  TREE_TYPE (DECL_CONTEXT (decl)));\n+      ini = find_utf8_constant (&state->cpool, name);\n     }\n-\n-  icii = find_class_constant (&state->cpool, TREE_TYPE (decl));\n-  ocii = find_class_constant (&state->cpool, TREE_TYPE (DECL_CONTEXT (decl))); \n-\n-  /* The specs are saying that if the class is anonymous,\n-     inner_name_index must be zero. But the implementation makes it\n-     point to an empty string. */\n-  ini = find_utf8_constant (&state->cpool,\n-\t\t\t    (ANONYMOUS_CLASS_P (TREE_TYPE (decl)) ? \n-\t\t\t     anonymous_name : name));\n   icaf = get_access_flags (decl);\n-  \n+\n   PUT2 (icii); PUT2 (ocii); PUT2 (ini);  PUT2 (icaf);\n }\n "}, {"sha": "187c5e97c79ed6aa44fad4dbbe4cf75a10658aae", "filename": "gcc/java/parse.y", "status": "modified", "additions": 10, "deletions": 51, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/493d561d623fe14141c5dba6ddd98a8271c67e69/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/493d561d623fe14141c5dba6ddd98a8271c67e69/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=493d561d623fe14141c5dba6ddd98a8271c67e69", "patch": "@@ -113,7 +113,6 @@ static int check_pkg_class_access PARAMS ((tree, tree));\n static void register_package PARAMS ((tree));\n static tree resolve_package PARAMS ((tree, tree *));\n static tree lookup_package_type PARAMS ((const char *, int));\n-static tree lookup_package_type_and_set_next PARAMS ((const char *, int, tree *));\n static tree resolve_class PARAMS ((tree, tree, tree, tree));\n static void declare_local_variables PARAMS ((int, tree, tree));\n static void source_start_java_method PARAMS ((tree));\n@@ -6822,35 +6821,6 @@ resolve_package (pkg, next)\n \n   *next = EXPR_WFL_QUALIFICATION (pkg);\n \n-  /* Try the current package. */\n-  if (ctxp->package && !strncmp (name, IDENTIFIER_POINTER (ctxp->package),  \n-\t\t\t\t IDENTIFIER_LENGTH (ctxp->package)))\n-    {\n-      type_name = \n-\tlookup_package_type_and_set_next (name, \n-\t\t\t\t\t  IDENTIFIER_LENGTH (ctxp->package), \n-\t\t\t\t\t  next );\n-      if (type_name)\n-\treturn type_name;\n-    }\n-\n-  /* Search in imported package */\n-  for (current = ctxp->import_list; current; current = TREE_CHAIN (current))\n-    {\n-      tree current_pkg_name = EXPR_WFL_NODE (TREE_PURPOSE (current));\n-      int len = IDENTIFIER_LENGTH (current_pkg_name);\n-      if (!strncmp (name, IDENTIFIER_POINTER (current_pkg_name), len))\n-\t{\n-\t  tree left, dummy;\n-\t  \n-\t  breakdown_qualified (&left, &dummy, current_pkg_name);\n-\t  len = IDENTIFIER_LENGTH (left);\n-\t  type_name = lookup_package_type_and_set_next (name, len, next);\n-\t  if (type_name)\n-\t    break;\n-\t}\n-    }\n-\n   /* Try to progressively construct a type name */\n   if (TREE_CODE (pkg) == EXPR_WITH_FILE_LOCATION)\n     for (acc = NULL_TREE, current = EXPR_WFL_QUALIFICATION (pkg); \n@@ -6870,27 +6840,6 @@ resolve_package (pkg, next)\n   return type_name;\n }\n \n-static tree\n-lookup_package_type_and_set_next (name, len, next)\n-     const char *name;\n-     int len;\n-     tree *next;\n-{\n-  const char *ptr;\n-  tree type_name = lookup_package_type (name, len);\n-\n-  if (!type_name)\n-    return NULL;\n-  \n-  ptr = IDENTIFIER_POINTER (type_name);\n-  while (ptr && (ptr = strchr (ptr, '.'))) \n-    {\n-      *next = TREE_CHAIN (*next);\n-      ptr++;\n-    }\n-  return type_name;\n-}\n-\n static tree\n lookup_package_type (name, from)\n      const char *name;\n@@ -10559,6 +10508,16 @@ find_applicable_accessible_methods_list (lc, class, name, arglist)\n       search_applicable_methods_list (lc, TYPE_METHODS (class), \n \t\t\t\t      name, arglist, &list, &all_list);\n \n+      /* When looking finit$, we turn LC to 1 so that we only search\n+\t in class. Note that we should have found something at\n+\t this point. */\n+      if (ID_FINIT_P (name))\n+\t{\n+\t  lc = 1;\n+\t  if (!list)\n+\t    fatal (\"finit$ not found in class -- find_applicable_accessible_methods_list\");\n+\t}\n+\n       /* We must search all interfaces of this class */\n       if (!lc)\n       {"}, {"sha": "f25fff12bd881d0bf87e6897b051df850b0928e4", "filename": "gcc/java/verify.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/493d561d623fe14141c5dba6ddd98a8271c67e69/gcc%2Fjava%2Fverify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/493d561d623fe14141c5dba6ddd98a8271c67e69/gcc%2Fjava%2Fverify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fverify.c?ref=493d561d623fe14141c5dba6ddd98a8271c67e69", "patch": "@@ -38,6 +38,7 @@ static tree merge_types PARAMS ((tree, tree));\n static const char *check_pending_block PARAMS ((tree));\n static void type_stack_dup PARAMS ((int, int));\n static int start_pc_cmp PARAMS ((const PTR, const PTR));\n+static char *pop_argument_types PARAMS ((tree));\n \n extern int stack_pointer;\n "}]}