{"sha": "ffa0ae6eeef3ad15d3f288283e4c477193052f1a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmZhMGFlNmVlZWYzYWQxNWQzZjI4ODI4M2U0YzQ3NzE5MzA1MmYxYQ==", "commit": {"author": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2021-04-09T14:03:32Z"}, "committer": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2021-04-09T15:28:32Z"}, "message": "Add 'libgomp.oacc-c-c++-common/static-variable-1.c' [PR84991, PR84992, PR90779]\n\n\tlibgomp/\n\tPR middle-end/84991\n\tPR middle-end/84992\n\tPR middle-end/90779\n\t* testsuite/libgomp.oacc-c-c++-common/static-variable-1.c: New.", "tree": {"sha": "125330426d6d3d24a9697a1ea61cfc51b7436544", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/125330426d6d3d24a9697a1ea61cfc51b7436544"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ffa0ae6eeef3ad15d3f288283e4c477193052f1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffa0ae6eeef3ad15d3f288283e4c477193052f1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffa0ae6eeef3ad15d3f288283e4c477193052f1a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffa0ae6eeef3ad15d3f288283e4c477193052f1a/comments", "author": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "625dadaf5df5a2ae0d8c5660fd1eec8ba354479c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/625dadaf5df5a2ae0d8c5660fd1eec8ba354479c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/625dadaf5df5a2ae0d8c5660fd1eec8ba354479c"}], "stats": {"total": 460, "additions": 460, "deletions": 0}, "files": [{"sha": "1d415cdcf7699240d42a1654cc269cf237346f10", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/static-variable-1.c", "status": "added", "additions": 460, "deletions": 0, "changes": 460, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffa0ae6eeef3ad15d3f288283e4c477193052f1a/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fstatic-variable-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffa0ae6eeef3ad15d3f288283e4c477193052f1a/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fstatic-variable-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fstatic-variable-1.c?ref=ffa0ae6eeef3ad15d3f288283e4c477193052f1a", "patch": "@@ -0,0 +1,460 @@\n+/* \"Function scope\" (top-level block scope) 'static' variables\n+\n+   ... inside OpenACC compute construct regions as well as OpenACC 'routine'.\n+\n+   This is to document/verify aspects of GCC's observed behavior, not\n+   necessarily as it's (intended to be?) restricted by the OpenACC\n+   specification.  See also PR84991, PR84992, PR90779 etc., and\n+   <https://github.com/OpenACC/openacc-spec/issues/372> \"C/C++ 'static'\n+   variables\" (only visible to members of the GitHub OpenACC organization).\n+*/\n+\n+\n+#undef NDEBUG\n+#include <assert.h>\n+#include <string.h>\n+#include <openacc.h>\n+#include <gomp-constants.h>\n+\n+\n+#define IF_DEBUG if (0)\n+\n+\n+/* Without explicit 'num_gangs'.  */\n+\n+static void t0_c(void)\n+{\n+  IF_DEBUG\n+    __builtin_printf (\"%s\\n\", __FUNCTION__);\n+\n+  const int i_limit = 11;\n+  const int var_init = 16;\n+\n+  for (int i = 0; i < i_limit; ++i)\n+    {\n+      int result = 0;\n+      int num_gangs_actual = -1;\n+#pragma acc parallel \\\n+  reduction(max:num_gangs_actual) \\\n+  reduction(max:result)\n+      {\n+\tnum_gangs_actual = 1 + __builtin_goacc_parlevel_id(GOMP_DIM_GANG);\n+\n+\tstatic int var = var_init;\n+\n+#pragma acc atomic capture\n+\tresult = ++var;\n+\n+\t/* Irrespective of the order in which the gang-redundant threads\n+\t   execute, 'var' has now been incremented 'num_gangs_actual' times, and\n+\t   the final value captured as 'result'.  */\n+      }\n+      /* Without an explicit 'num_gangs' clause GCC assigns 'num_gangs(1)'\n+\t because it doesn't see any use of gang-level parallelism inside the\n+\t region.  */\n+      assert(num_gangs_actual == 1);\n+      assert(result == var_init + num_gangs_actual * (1 + i));\n+    }\n+}\n+\n+\n+/* Call a gang-level routine.  */\n+\n+static const int t0_r_var_init = 61;\n+\n+#pragma acc routine gang\n+__attribute__((noinline))\n+static int t0_r_r(void)\n+{\n+  static int var = t0_r_var_init;\n+\n+  int tmp;\n+#pragma acc atomic capture\n+  tmp = ++var;\n+\n+  return tmp;\n+}\n+\n+static void t0_r(void)\n+{\n+  IF_DEBUG\n+    __builtin_printf (\"%s\\n\", __FUNCTION__);\n+\n+  const int i_limit = 11;\n+\n+  for (int i = 0; i < i_limit; ++i)\n+    {\n+      int result = 0;\n+      int num_gangs_actual = -1;\n+#pragma acc parallel \\\n+  reduction(max:num_gangs_actual) \\\n+  reduction(max:result)\n+      {\n+\tnum_gangs_actual = 1 + __builtin_goacc_parlevel_id(GOMP_DIM_GANG);\n+\n+\tresult = t0_r_r();\n+\n+\t/* Irrespective of the order in which the gang-redundant threads\n+\t   execute, 'var' has now been incremented 'num_gangs_actual' times, and\n+\t   the final value captured as 'result'.  */\n+      }\n+      /* The number of gangs selected by the implemention ought to but must not\n+\t be bigger than one.  */\n+      IF_DEBUG\n+\t__builtin_printf (\"%d: num_gangs_actual: %d\\n\", i, num_gangs_actual);\n+      assert(num_gangs_actual >= 1);\n+      assert(result == t0_r_var_init + num_gangs_actual * (1 + i));\n+    }\n+}\n+\n+\n+/* Explicit 'num_gangs'.  */\n+\n+static void t1_c(void)\n+{\n+  IF_DEBUG\n+    __builtin_printf (\"%s\\n\", __FUNCTION__);\n+\n+  const int i_limit = 22;\n+  const int num_gangs_request = 444;\n+  const int var_init = 5;\n+\n+  for (int i = 0; i < i_limit; ++i)\n+    {\n+      int result = 0;\n+      int num_gangs_actual = -1;\n+#pragma acc parallel \\\n+  num_gangs(num_gangs_request) \\\n+  reduction(max:num_gangs_actual) \\\n+  reduction(max:result)\n+      {\n+\tnum_gangs_actual = 1 + __builtin_goacc_parlevel_id(GOMP_DIM_GANG);\n+\n+\tstatic int var = var_init;\n+\n+#pragma acc atomic capture\n+\tresult = ++var;\n+\n+\t/* Irrespective of the order in which the gang-redundant threads\n+\t   execute, 'var' has now been incremented 'num_gangs_actual' times, and\n+\t   the final value captured as 'result'.  */\n+      }\n+      if (acc_get_device_type() == acc_device_host)\n+\tassert(num_gangs_actual == 1);\n+      else\n+\tassert(num_gangs_actual == num_gangs_request);\n+      assert(result == var_init + num_gangs_actual * (1 + i));\n+    }\n+}\n+\n+\n+/* Check the same routine called from two compute constructs.  */\n+\n+static const int t1_r2_var_init = 166;\n+\n+#pragma acc routine gang\n+__attribute__((noinline))\n+static int t1_r2_r(void)\n+{\n+  static int var = t1_r2_var_init;\n+\n+  int tmp;\n+#pragma acc atomic capture\n+  tmp = ++var;\n+\n+  return tmp;\n+}\n+\n+static void t1_r2(void)\n+{\n+  IF_DEBUG\n+    __builtin_printf (\"%s\\n\", __FUNCTION__);\n+\n+  const int i_limit = 71;\n+  /* The checking assumes the same 'num_gangs' for all compute constructs.  */\n+  const int num_gangs_request = 333;\n+  int num_gangs_actual = -1;\n+  if (acc_get_device_type() == acc_device_host)\n+    num_gangs_actual = 1;\n+  else\n+    {\n+      /* We're assuming that the implementation is able to accomodate the\n+\t 'num_gangs' requested (which really ought to be true for\n+\t 'num_gangs').  */\n+      num_gangs_actual = num_gangs_request;\n+    }\n+\n+  for (int i = 0; i < i_limit; ++i)\n+    {\n+      int result_1 = 0;\n+#pragma acc parallel \\\n+  num_gangs(num_gangs_request) \\\n+  reduction(max:result_1)\n+      {\n+\tresult_1 = t1_r2_r();\n+\n+\t/* Irrespective of the order in which the gang-redundant threads\n+\t   execute, 'var' has now been incremented 'num_gangs_actual' times, and\n+\t   the final value captured as 'result_1'.  */\n+      }\n+      IF_DEBUG\n+\t__builtin_printf (\"%d: result_1: %d\\n\", i, result_1);\n+      assert(result_1 == t1_r2_var_init + num_gangs_actual * (1 + (i * 3 + 0)));\n+\n+      int result_2 = 0;\n+#pragma acc parallel \\\n+  num_gangs(num_gangs_request) \\\n+  reduction(max:result_2)\n+      {\n+\tresult_2 = t1_r2_r() + t1_r2_r();\n+\n+\t/* Irrespective of the order in which the gang-redundant threads\n+\t   execute, 'var' has now been incremented '2 * num_gangs_actual' times.\n+\t   However, the order of the two 't1_r2_r' function calls is not\n+\t   synchronized (between different gang-redundant threads).  We thus\n+\t   cannot verify the actual 'result_2' values in this case.  */\n+      }\n+      IF_DEBUG\n+\t__builtin_printf (\"%d: result_2: %d\\n\", i, result_2);\n+      if (num_gangs_actual == 1)\n+\t/* Per the rationale above, only in this case we can check the actual\n+\t   result.  */\n+\tassert(result_2 == (t1_r2_var_init + num_gangs_actual * (1 + (i * 3 + 1))\n+\t\t\t    + t1_r2_var_init + num_gangs_actual * (1 + (i * 3 + 2))));\n+      /* But we can generally check low and high limits.  */\n+      {\n+\t/* Must be bigger than '2 * result_1'.  */\n+\tint c = 2 * result_1;\n+\tIF_DEBUG\n+\t  __builtin_printf (\"  > %d\\n\", c);\n+\tassert(result_2 > c);\n+      }\n+      {\n+\t/* ..., but limited by the base value for next 'i'.  */\n+\tint c = 2 * (t1_r2_var_init + num_gangs_actual * (0 + ((i + 1) * 3 + 0)));\n+\tIF_DEBUG\n+\t  __builtin_printf (\"  < %d\\n\", c);\n+\tassert(result_2 < c);\n+      }\n+    }\n+}\n+\n+\n+/* Asynchronous execution.  */\n+\n+static const int t2_var_init_2 = -55;\n+\n+#pragma acc routine gang\n+__attribute__((noinline))\n+static int t2_r(void)\n+{\n+  static int var = t2_var_init_2;\n+\n+  int tmp;\n+#pragma acc atomic capture\n+  tmp = ++var;\n+\n+  return tmp;\n+}\n+\n+static void t2(void)\n+{\n+  IF_DEBUG\n+    __builtin_printf (\"%s\\n\", __FUNCTION__);\n+\n+  const int i_limit = 12;\n+  const int num_gangs_request_1 = 14;\n+  const int var_init_1 = 5;\n+  int results_1[i_limit][num_gangs_request_1];\n+  memset (results_1, 0, sizeof results_1);\n+  const int num_gangs_request_2 = 5;\n+  int results_2[i_limit][num_gangs_request_2];\n+  memset (results_2, 0, sizeof results_2);\n+  const int num_gangs_request_3 = 34;\n+  const int var_init_3 = 1250;\n+  int results_3[i_limit][num_gangs_request_3];\n+  memset (results_3, 0, sizeof results_3);\n+\n+#pragma acc data \\\n+  copy(results_1, results_2, results_3)\n+  {\n+    for (int i = 0; i < i_limit; ++i)\n+      {\n+\t/* The following 'async' clauses effect asynchronous execution, but\n+\t   using the same async-argument for each compute construct implies that\n+\t   the respective compute constructs' execution is synchronized with\n+\t   itself, meaning that all 'i = 0' execution has finished (on the\n+\t   device) before 'i = 1' is started (on the device), etc.  */\n+\n+#pragma acc parallel \\\n+  present(results_1) \\\n+  num_gangs(num_gangs_request_1) \\\n+  async(1)\n+\t{\n+\t  static int var = var_init_1;\n+\n+\t  int tmp;\n+#pragma acc atomic capture\n+\t  tmp = ++var;\n+\n+\t  results_1[i][__builtin_goacc_parlevel_id(GOMP_DIM_GANG)] += tmp;\n+\t}\n+\n+#pragma acc parallel \\\n+  present(results_2) \\\n+  num_gangs(num_gangs_request_2) \\\n+  async(2)\n+\t{\n+\t  results_2[i][__builtin_goacc_parlevel_id(GOMP_DIM_GANG)] += t2_r();\n+\t}\n+\n+#pragma acc parallel \\\n+  present(results_3) \\\n+  num_gangs(num_gangs_request_3) \\\n+  async(3)\n+\t{\n+\t  static int var = var_init_3;\n+\n+\t  int tmp;\n+#pragma acc atomic capture\n+\t  tmp = ++var;\n+\n+\t  results_3[i][__builtin_goacc_parlevel_id(GOMP_DIM_GANG)] += tmp;\n+\t}\n+      }\n+#pragma acc wait\n+  }\n+  int num_gangs_actual_1;\n+  int num_gangs_actual_2;\n+  int num_gangs_actual_3;\n+  if (acc_get_device_type() == acc_device_host)\n+    {\n+      num_gangs_actual_1 = 1;\n+      num_gangs_actual_2 = 1;\n+      num_gangs_actual_3 = 1;\n+    }\n+  else\n+    {\n+      /* We're assuming that the implementation is able to accomodate the\n+\t 'num_gangs' requested (which really ought to be true for\n+\t 'num_gangs').  */\n+      num_gangs_actual_1 = num_gangs_request_1;\n+      num_gangs_actual_2 = num_gangs_request_2;\n+      num_gangs_actual_3 = num_gangs_request_3;\n+    }\n+\n+  /* For 'i = 0', 'results_*[i][0..num_gangs_actual_*]' are expected to each\n+     contain one value of '(1 + var_init_*)..(var_init_* + num_gangs_actual_*)',\n+     and so on for increasing 'i'.  Their order however is unspecified due to\n+     the gang-redundant execution.  (Thus checking that their sums match.)  */\n+\n+  int result_1 = 0;\n+  int result_2 = 0;\n+  int result_3 = 0;\n+  for (int i = 0; i < i_limit; ++i)\n+    {\n+      int result_1_ = 0;\n+      for (int g = 0; g < num_gangs_actual_1; ++g)\n+\t{\n+\t  IF_DEBUG\n+\t    __builtin_printf (\"results_1[%d][%d]: %d\\n\", i, g, results_1[i][g]);\n+\t  result_1_ += results_1[i][g];\n+\t}\n+      IF_DEBUG\n+\t__builtin_printf (\"%d result_1_: %d\\n\", i, result_1_);\n+      assert (result_1_ == (((var_init_1 + num_gangs_actual_1 * (1 + i)) * (1 + var_init_1 + num_gangs_actual_1 * (1 + i)) / 2)\n+\t\t\t    - ((var_init_1 + num_gangs_actual_1 * (0 + i)) * (1 + var_init_1 + num_gangs_actual_1 * (0 + i)) / 2)));\n+      result_1 += result_1_;\n+\n+      int result_2_ = 0;\n+      for (int g = 0; g < num_gangs_actual_2; ++g)\n+\t{\n+\t  IF_DEBUG\n+\t    __builtin_printf (\"results_2[%d][%d]: %d\\n\", i, g, results_2[i][g]);\n+\t  result_2_ += results_2[i][g];\n+\t}\n+      IF_DEBUG\n+\t__builtin_printf (\"%d result_2_: %d\\n\", i, result_2_);\n+      assert (result_2_ == (((t2_var_init_2 + num_gangs_actual_2 * (1 + i)) * (1 + t2_var_init_2 + num_gangs_actual_2 * (1 + i)) / 2)\n+\t\t\t    - ((t2_var_init_2 + num_gangs_actual_2 * (0 + i)) * (1 + t2_var_init_2 + num_gangs_actual_2 * (0 + i)) / 2)));\n+      result_2 += result_2_;\n+\n+      int result_3_ = 0;\n+      for (int g = 0; g < num_gangs_actual_3; ++g)\n+\t{\n+\t  IF_DEBUG\n+\t    __builtin_printf (\"results_3[%d][%d]: %d\\n\", i, g, results_3[i][g]);\n+\t  result_3_ += results_3[i][g];\n+\t}\n+      IF_DEBUG\n+\t__builtin_printf (\"%d result_3_: %d\\n\", i, result_3_);\n+      assert (result_3_ == (((var_init_3 + num_gangs_actual_3 * (1 + i)) * (1 + var_init_3 + num_gangs_actual_3 * (1 + i)) / 2)\n+\t\t\t    - ((var_init_3 + num_gangs_actual_3 * (0 + i)) * (1 + var_init_3 + num_gangs_actual_3 * (0 + i)) / 2)));\n+      result_3 += result_3_;\n+    }\n+  IF_DEBUG\n+    __builtin_printf (\"result_1: %d\\n\", result_1);\n+  assert (result_1 == (((var_init_1 + num_gangs_actual_1 * i_limit) * (1 + var_init_1 + num_gangs_actual_1 * i_limit) / 2)\n+\t\t       - (var_init_1 * (var_init_1 + 1) / 2)));\n+  IF_DEBUG\n+    __builtin_printf (\"result_2: %d\\n\", result_2);\n+  assert (result_2 == (((t2_var_init_2 + num_gangs_actual_2 * i_limit) * (1 + t2_var_init_2 + num_gangs_actual_2 * i_limit) / 2)\n+\t\t       - (t2_var_init_2 * (t2_var_init_2 + 1) / 2)));\n+  IF_DEBUG\n+    __builtin_printf (\"result_3: %d\\n\", result_3);\n+  assert (result_3 == (((var_init_3 + num_gangs_actual_3 * i_limit) * (1 + var_init_3 + num_gangs_actual_3 * i_limit) / 2)\n+\t\t       - (var_init_3 * (var_init_3 + 1) / 2)));\n+}\n+\n+\n+#pragma acc routine seq\n+__attribute__((noinline))\n+static int pr84991_1_r_s(int n)\n+{\n+  static const int test[] = {1,2,3,4};\n+  return test[n];\n+}\n+\n+static void pr84991_1(void)\n+{\n+  int n[1];\n+  n[0] = 3;\n+#pragma acc parallel copy(n)\n+  {\n+    n[0] = pr84991_1_r_s(n[0]);\n+  }\n+  assert(n[0] == 4);\n+}\n+\n+\n+static void pr84992_1(void)\n+{\n+  int n[1];\n+  n[0] = 3;\n+#pragma acc parallel copy(n)\n+  {\n+    static const int test[] = {1,2,3,4};\n+    n[0] = test[n[0]];\n+  }\n+  assert(n[0] == 4);\n+}\n+\n+\n+int main(void)\n+{\n+  t0_c();\n+\n+  t0_r();\n+\n+  t1_c();\n+\n+  t1_r2();\n+\n+  t2();\n+\n+  pr84991_1();\n+\n+  pr84992_1();\n+\n+  return 0;\n+}"}]}