{"sha": "3f1e3e7010cf18ef218f107015b8f66fc75ed4d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2YxZTNlNzAxMGNmMThlZjIxOGYxMDcwMTViOGY2NmZjNzVlZDRkOQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2006-08-17T08:55:02Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2006-08-17T08:55:02Z"}, "message": "re PR target/28146 (-O2 produces invalid code on s390-linux-gnu: gcc-4.1.2 20060608)\n\nPR target/28146\n* reload.h (reg_equiv_alt_mem_list): New declaration.\n* reload1.c (reg_equiv_alt_mem_list): New definition.\n(reload): Initialize it and release it.\n(delete_output_reload): Use it.\n* reload.c (push_reg_equiv_alt_mem): New function.\n(find_reloads_toplev): Call it.\n(find_reloads_address, find_reloads_address_1): Likewise.\n(find_reloads_subreg_address): Likewise.\n\nFrom-SVN: r116215", "tree": {"sha": "5846cb80d97c878963127f9d3c488c23dfc9286c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5846cb80d97c878963127f9d3c488c23dfc9286c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f1e3e7010cf18ef218f107015b8f66fc75ed4d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f1e3e7010cf18ef218f107015b8f66fc75ed4d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f1e3e7010cf18ef218f107015b8f66fc75ed4d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f1e3e7010cf18ef218f107015b8f66fc75ed4d9/comments", "author": null, "committer": null, "parents": [{"sha": "d3b30e42b73d0a369046e53fcdbe69517c0195be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3b30e42b73d0a369046e53fcdbe69517c0195be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3b30e42b73d0a369046e53fcdbe69517c0195be"}], "stats": {"total": 66, "additions": 66, "deletions": 0}, "files": [{"sha": "9794ce2d5447ef18bfa673ded72756bfd3daabc6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f1e3e7010cf18ef218f107015b8f66fc75ed4d9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f1e3e7010cf18ef218f107015b8f66fc75ed4d9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3f1e3e7010cf18ef218f107015b8f66fc75ed4d9", "patch": "@@ -1,3 +1,15 @@\n+2006-08-17  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR target/28146\n+\t* reload.h (reg_equiv_alt_mem_list): New declaration.\n+\t* reload1.c (reg_equiv_alt_mem_list): New definition.\n+\t(reload): Initialize it and release it.\n+\t(delete_output_reload): Use it.\n+\t* reload.c (push_reg_equiv_alt_mem): New function.\n+\t(find_reloads_toplev): Call it.\n+\t(find_reloads_address, find_reloads_address_1): Likewise.\n+\t(find_reloads_subreg_address): Likewise.\n+\n 2006-08-17  Maxim Kuvyrkov  <mkuvyrkov@ispras.ru>\n \n \tPR rtl-optimization/28489"}, {"sha": "e1a4abc6953b60e47cdc3cfc94a71defb8a1f89a", "filename": "gcc/reload.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f1e3e7010cf18ef218f107015b8f66fc75ed4d9/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f1e3e7010cf18ef218f107015b8f66fc75ed4d9/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=3f1e3e7010cf18ef218f107015b8f66fc75ed4d9", "patch": "@@ -283,6 +283,23 @@ static int find_inc_amount (rtx, rtx);\n static int refers_to_mem_for_reload_p (rtx);\n static int refers_to_regno_for_reload_p (unsigned int, unsigned int,\n \t\t\t\t\t rtx, rtx *);\n+\n+/* Add NEW to reg_equiv_alt_mem_list[REGNO] if it's not present in the\n+   list yet.  */\n+\n+static void\n+push_reg_equiv_alt_mem (int regno, rtx mem)\n+{\n+  rtx it;\n+\n+  for (it = reg_equiv_alt_mem_list [regno]; it; it = XEXP (it, 1))\n+    if (rtx_equal_p (XEXP (it, 0), mem))\n+      return;\n+\n+  reg_equiv_alt_mem_list [regno]\n+    = alloc_EXPR_LIST (REG_EQUIV, mem,\n+\t\t       reg_equiv_alt_mem_list [regno]);\n+}\n \f\n /* Determine if any secondary reloads are needed for loading (if IN_P is\n    nonzero) or storing (if IN_P is zero) X to or from a reload register of\n@@ -4553,6 +4570,8 @@ find_reloads_toplev (rtx x, int opnum, enum reload_type type,\n \t      x = mem;\n \t      i = find_reloads_address (GET_MODE (x), &x, XEXP (x, 0), &XEXP (x, 0),\n \t\t\t\t\topnum, type, ind_levels, insn);\n+\t      if (x != mem)\n+\t\tpush_reg_equiv_alt_mem (regno, x);\n \t      if (address_reloaded)\n \t\t*address_reloaded = i;\n \t    }\n@@ -4761,9 +4780,13 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n \t      tem = make_memloc (ad, regno);\n \t      if (! strict_memory_address_p (GET_MODE (tem), XEXP (tem, 0)))\n \t\t{\n+\t\t  rtx orig = tem;\n+\n \t\t  find_reloads_address (GET_MODE (tem), &tem, XEXP (tem, 0),\n \t\t\t\t\t&XEXP (tem, 0), opnum,\n \t\t\t\t\tADDR_TYPE (type), ind_levels, insn);\n+\t\t  if (tem != orig)\n+\t\t    push_reg_equiv_alt_mem (regno, tem);\n \t\t}\n \t      /* We can avoid a reload if the register's equivalent memory\n \t\t expression is valid as an indirect memory address.\n@@ -5545,6 +5568,8 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \t    if (reg_equiv_address[regno]\n \t\t|| ! rtx_equal_p (tem, reg_equiv_mem[regno]))\n \t      {\n+\t\trtx orig = tem;\n+\n \t\t/* First reload the memory location's address.\n \t\t    We can't use ADDR_TYPE (type) here, because we need to\n \t\t    write back the value after reading it, hence we actually\n@@ -5554,6 +5579,9 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \t\t\t\t      RELOAD_OTHER,\n \t\t\t\t      ind_levels, insn);\n \n+\t\tif (tem != orig)\n+\t\t  push_reg_equiv_alt_mem (regno, tem);\n+\n \t\t/* Then reload the memory location into a base\n \t\t   register.  */\n \t\treloadnum = push_reload (tem, tem, &XEXP (x, 0),\n@@ -5609,13 +5637,17 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \t      if (reg_equiv_address[regno]\n \t\t  || ! rtx_equal_p (tem, reg_equiv_mem[regno]))\n \t\t{\n+\t\t  rtx orig = tem;\n+\n \t\t  /* First reload the memory location's address.\n \t\t     We can't use ADDR_TYPE (type) here, because we need to\n \t\t     write back the value after reading it, hence we actually\n \t\t     need two registers.  */\n \t\t  find_reloads_address (GET_MODE (tem), &tem, XEXP (tem, 0),\n \t\t\t\t\t&XEXP (tem, 0), opnum, type,\n \t\t\t\t\tind_levels, insn);\n+\t\t  if (tem != orig)\n+\t\t    push_reg_equiv_alt_mem (regno, tem);\n \t\t  /* Put this inside a new increment-expression.  */\n \t\t  x = gen_rtx_fmt_e (GET_CODE (x), GET_MODE (x), tem);\n \t\t  /* Proceed to reload that, as if it contained a register.  */\n@@ -5806,6 +5838,8 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \t\tfind_reloads_address (GET_MODE (x), &x, XEXP (x, 0),\n \t\t\t\t      &XEXP (x, 0), opnum, ADDR_TYPE (type),\n \t\t\t\t      ind_levels, insn);\n+\t\tif (x != tem)\n+\t\t  push_reg_equiv_alt_mem (regno, x);\n \t      }\n \t  }\n \n@@ -5993,6 +6027,7 @@ find_reloads_subreg_address (rtx x, int force_replace, int opnum,\n \t      unsigned outer_size = GET_MODE_SIZE (GET_MODE (x));\n \t      unsigned inner_size = GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)));\n \t      int offset;\n+\t      rtx orig = tem;\n \n \t      /* For big-endian paradoxical subregs, SUBREG_BYTE does not\n \t\t hold the correct (negative) byte offset.  */\n@@ -6028,6 +6063,9 @@ find_reloads_subreg_address (rtx x, int force_replace, int opnum,\n \t      find_reloads_address (GET_MODE (tem), &tem, XEXP (tem, 0),\n \t\t\t\t    &XEXP (tem, 0), opnum, type,\n \t\t\t\t    ind_levels, insn);\n+\t      /* ??? Do we need to handle nonzero offsets somehow?  */\n+\t      if (!offset && tem != orig)\n+\t\tpush_reg_equiv_alt_mem (regno, tem);\n \n \t      /* If this is not a toplevel operand, find_reloads doesn't see\n \t\t this substitution.  We have to emit a USE of the pseudo so"}, {"sha": "6de5e8471bfce4216b34a09ef86aa11b0923a2f4", "filename": "gcc/reload.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f1e3e7010cf18ef218f107015b8f66fc75ed4d9/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f1e3e7010cf18ef218f107015b8f66fc75ed4d9/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=3f1e3e7010cf18ef218f107015b8f66fc75ed4d9", "patch": "@@ -161,6 +161,7 @@ extern rtx *reg_equiv_invariant;\n extern rtx *reg_equiv_memory_loc;\n extern rtx *reg_equiv_address;\n extern rtx *reg_equiv_mem;\n+extern rtx *reg_equiv_alt_mem_list;\n \n /* Element N is the list of insns that initialized reg N from its equivalent\n    constant or memory slot.  */"}, {"sha": "8ce042fe2c4c47446d0de4425b0dd130c32af7a5", "filename": "gcc/reload1.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f1e3e7010cf18ef218f107015b8f66fc75ed4d9/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f1e3e7010cf18ef218f107015b8f66fc75ed4d9/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=3f1e3e7010cf18ef218f107015b8f66fc75ed4d9", "patch": "@@ -123,6 +123,10 @@ rtx *reg_equiv_address;\n    or zero if pseudo reg N is not equivalent to a memory slot.  */\n rtx *reg_equiv_mem;\n \n+/* Element N is an EXPR_LIST of REG_EQUIVs containing MEMs with\n+   alternate representations of the location of pseudo reg N.  */\n+rtx *reg_equiv_alt_mem_list;\n+\n /* Widest width in which each pseudo reg is referred to (via subreg).  */\n static unsigned int *reg_max_ref_width;\n \n@@ -703,6 +707,7 @@ reload (rtx first, int global)\n   reg_equiv_constant = XCNEWVEC (rtx, max_regno);\n   reg_equiv_invariant = XCNEWVEC (rtx, max_regno);\n   reg_equiv_mem = XCNEWVEC (rtx, max_regno);\n+  reg_equiv_alt_mem_list = XCNEWVEC (rtx, max_regno);\n   reg_equiv_address = XCNEWVEC (rtx, max_regno);\n   reg_max_ref_width = XCNEWVEC (unsigned int, max_regno);\n   reg_old_renumber = XCNEWVEC (short, max_regno);\n@@ -1260,6 +1265,11 @@ reload (rtx first, int global)\n   if (offsets_at)\n     free (offsets_at);\n \n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    if (reg_equiv_alt_mem_list[i])\n+      free_EXPR_LIST_list (&reg_equiv_alt_mem_list[i]);\n+  free (reg_equiv_alt_mem_list);\n+\n   free (reg_equiv_mem);\n   reg_equiv_init = 0;\n   free (reg_equiv_address);\n@@ -7849,6 +7859,11 @@ delete_output_reload (rtx insn, int j, int last_reload_reg)\n     n_occurrences += count_occurrences (PATTERN (insn),\n \t\t\t\t\teliminate_regs (substed, 0,\n \t\t\t\t\t\t\tNULL_RTX), 0);\n+  for (i1 = reg_equiv_alt_mem_list [REGNO (reg)]; i1; i1 = XEXP (i1, 1))\n+    {\n+      gcc_assert (!rtx_equal_p (XEXP (i1, 0), substed));\n+      n_occurrences += count_occurrences (PATTERN (insn), XEXP (i1, 0), 0);\n+    }\n   if (n_occurrences > n_inherited)\n     return;\n "}]}