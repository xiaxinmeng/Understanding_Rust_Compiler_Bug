{"sha": "e9baa644022b2d7d0f2f547baa5c7a4b477e7429", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTliYWE2NDQwMjJiMmQ3ZDBmMmY1NDdiYWE1YzdhNGI0NzdlNzQyOQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-01-11T00:23:47Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-01-11T00:23:47Z"}, "message": "(protect_from_queue): If (MEM (QUEUED ...)), modify a new MEM instead\nof the one we were passed.\n\nFrom-SVN: r6375", "tree": {"sha": "532ba5faff169dbd1e83db0933a6d999b20efbb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/532ba5faff169dbd1e83db0933a6d999b20efbb1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9baa644022b2d7d0f2f547baa5c7a4b477e7429", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9baa644022b2d7d0f2f547baa5c7a4b477e7429", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9baa644022b2d7d0f2f547baa5c7a4b477e7429", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9baa644022b2d7d0f2f547baa5c7a4b477e7429/comments", "author": null, "committer": null, "parents": [{"sha": "4a86a6d20f7aede7dd102d03b503eb496ff0eb97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a86a6d20f7aede7dd102d03b503eb496ff0eb97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a86a6d20f7aede7dd102d03b503eb496ff0eb97"}], "stats": {"total": 23, "additions": 14, "deletions": 9}, "files": [{"sha": "7361503ea06c3a310d9b761252cf78b3fbf10e5c", "filename": "gcc/expr.c", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9baa644022b2d7d0f2f547baa5c7a4b477e7429/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9baa644022b2d7d0f2f547baa5c7a4b477e7429/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=e9baa644022b2d7d0f2f547baa5c7a4b477e7429", "patch": "@@ -416,24 +416,29 @@ protect_from_queue (x, modify)\n \n   if (code != QUEUED)\n     {\n-      /* A special hack for read access to (MEM (QUEUED ...))\n-\t to facilitate use of autoincrement.\n-\t Make a copy of the contents of the memory location\n-\t rather than a copy of the address, but not\n-\t if the value is of mode BLKmode.  */\n+      /* A special hack for read access to (MEM (QUEUED ...)) to facilitate\n+\t use of autoincrement.  Make a copy of the contents of the memory\n+\t location rather than a copy of the address, but not if the value is\n+\t of mode BLKmode.  Don't modify X in place since it might be\n+\t shared.  */\n       if (code == MEM && GET_MODE (x) != BLKmode\n \t  && GET_CODE (XEXP (x, 0)) == QUEUED && !modify)\n \t{\n \t  register rtx y = XEXP (x, 0);\n-\t  XEXP (x, 0) = QUEUED_VAR (y);\n+\t  register rtx new = gen_rtx (MEM, GET_MODE (x), QUEUED_VAR (y));\n+\n+\t  MEM_IN_STRUCT_P (new) = MEM_IN_STRUCT_P (x);\n+\t  RTX_UNCHANGING_P (new) = RTX_UNCHANGING_P (x);\n+\t  MEM_VOLATILE_P (new) = MEM_VOLATILE_P (x);\n+\n \t  if (QUEUED_INSN (y))\n \t    {\n-\t      register rtx temp = gen_reg_rtx (GET_MODE (x));\n-\t      emit_insn_before (gen_move_insn (temp, x),\n+\t      register rtx temp = gen_reg_rtx (GET_MODE (new));\n+\t      emit_insn_before (gen_move_insn (temp, new),\n \t\t\t\tQUEUED_INSN (y));\n \t      return temp;\n \t    }\n-\t  return x;\n+\t  return new;\n \t}\n       /* Otherwise, recursively protect the subexpressions of all\n \t the kinds of rtx's that can contain a QUEUED.  */"}]}