{"sha": "695e4773c10dfbaadf7884216aa6719da7601c64", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njk1ZTQ3NzNjMTBkZmJhYWRmNzg4NDIxNmFhNjcxOWRhNzYwMWM2NA==", "commit": {"author": {"name": "Graham Stott", "email": "grahams@redhat.com", "date": "2000-11-15T11:07:44Z"}, "committer": {"name": "Graham Stott", "email": "grahams@gcc.gnu.org", "date": "2000-11-15T11:07:44Z"}, "message": "regrename.c (scan_rtx_rtx): Skip to the next chain on encountering a terminated chain.\n\n\n        * regrename.c (scan_rtx_rtx): Skip to the next chain on\n        encountering a terminated chain.\n\nFrom-SVN: r37473", "tree": {"sha": "5f2bcd8a7bf44b81330e322632977a9095164327", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f2bcd8a7bf44b81330e322632977a9095164327"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/695e4773c10dfbaadf7884216aa6719da7601c64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/695e4773c10dfbaadf7884216aa6719da7601c64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/695e4773c10dfbaadf7884216aa6719da7601c64", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/695e4773c10dfbaadf7884216aa6719da7601c64/comments", "author": null, "committer": null, "parents": [{"sha": "928c4ba2a71b2181fcead46d2740ebcb96009f69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/928c4ba2a71b2181fcead46d2740ebcb96009f69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/928c4ba2a71b2181fcead46d2740ebcb96009f69"}], "stats": {"total": 114, "additions": 66, "deletions": 48}, "files": [{"sha": "60efafb3265e22ff2f898909ac07f0e829012d81", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/695e4773c10dfbaadf7884216aa6719da7601c64/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/695e4773c10dfbaadf7884216aa6719da7601c64/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=695e4773c10dfbaadf7884216aa6719da7601c64", "patch": "@@ -1,3 +1,8 @@\n+2000-11-15  Graham Stott  <grahams@redhat.com>\n+\n+\t* regrename.c (scan_rtx_rtx): Skip to the next chain on\n+\tencountering a terminated chain.\n+\n 2000-11-14  Mark Mitchell  <mark@codesourcery.com>\n \n \t* configure.in: Move check for V3 above check for C++ header-file"}, {"sha": "c444af8326e1e5fcbf295620acddf906ac930bcf", "filename": "gcc/regrename.c", "status": "modified", "additions": 61, "deletions": 48, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/695e4773c10dfbaadf7884216aa6719da7601c64/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/695e4773c10dfbaadf7884216aa6719da7601c64/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=695e4773c10dfbaadf7884216aa6719da7601c64", "patch": "@@ -307,62 +307,75 @@ scan_rtx_reg (insn, loc, class, action, type)\n   for (p = &open_chains; *p;)\n     {\n       struct du_chain *this = *p;\n-      int regno = REGNO (*this->loc);\n-      int nregs = HARD_REGNO_NREGS (regno, GET_MODE (*this->loc));\n-      int exact_match = (regno == this_regno && nregs == this_nregs);\n \n-      if (regno + nregs <= this_regno\n-\t  || this_regno + this_nregs <= regno)\n-\tp = &this->next_chain;\n-      else if (action == mark_read)\n-\t{\n-\t  if (! exact_match)\n-\t    abort ();\n-\t  if (class == NO_REGS)\n-\t    abort ();\n+      /* Check if the chain has been terminated if it has then skip to\n+\t the next chain.\n \n-\t  this = (struct du_chain *)\n-\t    obstack_alloc (&rename_obstack, sizeof (struct du_chain));\n-\t  this->next_use = *p;\n-\t  this->next_chain = (*p)->next_chain;\n-\t  this->loc = loc;\n-\t  this->insn = insn;\n-\t  this->class = class;\n-\t  this->need_caller_save_reg = 0;\n-\t  *p = this;\n-\t  return;\n-\t}\n-      else if (action != terminate_overlapping_read || ! exact_match)\n-\t{\n-\t  struct du_chain *next = this->next_chain;\n-\n-\t  /* Whether the terminated chain can be used for renaming\n-\t     depends on the action and this being an exact match.\n-\t     In either case, we remove this element from open_chains.  */\n+\t This can happen when we've already appended the location to\n+\t the chain in Step 3, but are trying to hide in-out operands\n+\t from terminate_write in Step 5.  */\n \n-\t  if ((action == terminate_dead || action == terminate_write)\n-\t      && exact_match)\n+      if (*this->loc == cc0_rtx)\n+\tp = &this->next_chain;\n+      else\n+        {\n+\t  int regno = REGNO (*this->loc);\n+\t  int nregs = HARD_REGNO_NREGS (regno, GET_MODE (*this->loc));\n+\t  int exact_match = (regno == this_regno && nregs == this_nregs);\n+\n+\t  if (regno + nregs <= this_regno\n+\t      || this_regno + this_nregs <= regno)\n+\t    p = &this->next_chain;\n+\t  else if (action == mark_read)\n \t    {\n-\t      this->next_chain = closed_chains;\n-\t      closed_chains = this;\n-\t      if (rtl_dump_file)\n-\t\tfprintf (rtl_dump_file,\n-\t\t\t \"Closing chain %s at insn %d (%s)\\n\",\n-\t\t\t reg_names[REGNO (*this->loc)], INSN_UID (insn),\n-\t\t\t scan_actions_name[(int) action]);\n+\t      if (! exact_match)\n+\t\tabort ();\n+\t      if (class == NO_REGS)\n+\t\tabort ();\n+\n+\t      this = (struct du_chain *)\n+\t\tobstack_alloc (&rename_obstack, sizeof (struct du_chain));\n+\t      this->next_use = *p;\n+\t      this->next_chain = (*p)->next_chain;\n+\t      this->loc = loc;\n+\t      this->insn = insn;\n+\t      this->class = class;\n+\t      this->need_caller_save_reg = 0;\n+\t      *p = this;\n+\t      return;\n \t    }\n-\t  else\n+\t  else if (action != terminate_overlapping_read || ! exact_match)\n \t    {\n-\t      if (rtl_dump_file)\n-\t\tfprintf (rtl_dump_file,\n-\t\t\t \"Discarding chain %s at insn %d (%s)\\n\",\n-\t\t\t reg_names[REGNO (*this->loc)], INSN_UID (insn),\n-\t\t\t scan_actions_name[(int) action]);\n+\t      struct du_chain *next = this->next_chain;\n+\n+\t      /* Whether the terminated chain can be used for renaming\n+\t         depends on the action and this being an exact match.\n+\t         In either case, we remove this element from open_chains.  */\n+\n+\t      if ((action == terminate_dead || action == terminate_write)\n+\t\t  && exact_match)\n+\t\t{\n+\t\t  this->next_chain = closed_chains;\n+\t\t  closed_chains = this;\n+\t\t  if (rtl_dump_file)\n+\t\t    fprintf (rtl_dump_file,\n+\t\t\t     \"Closing chain %s at insn %d (%s)\\n\",\n+\t\t\t     reg_names[REGNO (*this->loc)], INSN_UID (insn),\n+\t\t\t     scan_actions_name[(int) action]);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (rtl_dump_file)\n+\t\t    fprintf (rtl_dump_file,\n+\t\t\t     \"Discarding chain %s at insn %d (%s)\\n\",\n+\t\t\t     reg_names[REGNO (*this->loc)], INSN_UID (insn),\n+\t\t\t     scan_actions_name[(int) action]);\n+\t\t}\n+\t      *p = next;\n \t    }\n-\t  *p = next;\n+\t  else\n+\t    p = &this->next_chain;\n \t}\n-      else\n-\tp = &this->next_chain;\n     }\n }\n "}]}