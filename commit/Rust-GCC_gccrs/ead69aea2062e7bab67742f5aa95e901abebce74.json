{"sha": "ead69aea2062e7bab67742f5aa95e901abebce74", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWFkNjlhZWEyMDYyZTdiYWI2Nzc0MmY1YWE5NWU5MDFhYmViY2U3NA==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-05-03T23:57:21Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-05-03T23:57:21Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r874", "tree": {"sha": "e03cd775f4ccbd9c88009380530f06a823936e85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e03cd775f4ccbd9c88009380530f06a823936e85"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ead69aea2062e7bab67742f5aa95e901abebce74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ead69aea2062e7bab67742f5aa95e901abebce74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ead69aea2062e7bab67742f5aa95e901abebce74", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ead69aea2062e7bab67742f5aa95e901abebce74/comments", "author": null, "committer": null, "parents": [{"sha": "c3de4fe6823c360513e47c2b832ee872e86abee5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3de4fe6823c360513e47c2b832ee872e86abee5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3de4fe6823c360513e47c2b832ee872e86abee5"}], "stats": {"total": 178, "additions": 165, "deletions": 13}, "files": [{"sha": "f02f77c42345416afd8d8f3cca1218b11f3a2003", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead69aea2062e7bab67742f5aa95e901abebce74/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead69aea2062e7bab67742f5aa95e901abebce74/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=ead69aea2062e7bab67742f5aa95e901abebce74", "patch": "@@ -2602,3 +2602,112 @@ sparc_type_code (type)\n         }\n     }\n }\n+\f\n+#ifdef HANDLE_PRAGMA\n+\n+/* Handle a pragma directive.  HANDLE_PRAGMA conspires to parse the\n+   input following #pragma into tokens based on yylex.  TOKEN is the\n+   current token, and STRING is its printable form.  */\n+\n+void\n+handle_pragma_token (string, token)\n+     char *string;\n+     tree token;\n+{\n+  static enum pragma_state\n+    {\n+      ps_start,\n+      ps_done,\n+      ps_bad,\n+      ps_weak,\n+      ps_name,\n+      ps_equals,\n+      ps_value,\n+      } state = ps_start, type;\n+  static char *name;\n+  static char *value;\n+  static int align;\n+\n+  if (string == 0)\n+    {\n+#ifdef WEAK_ASM_OP\n+      if (type == ps_weak)\n+\t{\n+\t  if (state == ps_name || state == ps_value)\n+\t    {\n+\t      fprintf (asm_out_file, \"\\t%s\\t\", WEAK_ASM_OP);\n+\t      ASM_OUTPUT_LABELREF (asm_out_file, name);\n+\t      fputc ('\\n', asm_out_file);\n+\t      if (state == ps_value)\n+\t\t{\n+\t\t  fputc ('\\t', asm_out_file);\n+\t\t  ASM_OUTPUT_LABELREF (asm_out_file, name);\n+\t\t  fputs (\" = \", asm_out_file);\n+\t\t  ASM_OUTPUT_LABELREF (asm_out_file, value);\n+\t\t  fputc ('\\n', asm_out_file);\n+\t\t}\n+\t    }\n+\t  else if (! (state == ps_done || state == ps_start))\n+\t    warning (\"ignoring malformed #pragma weak symbol [=value]\");\n+\t}\n+#endif /* WEAK_ASM_OP */\n+\n+      type = state = ps_start;\n+      return;\n+    }\n+\n+  switch (state)\n+    {\n+    case ps_start:\n+      if (token && TREE_CODE (token) == IDENTIFIER_NODE)\n+\t{\n+#ifdef WEAK_ASM_OP\n+\t  if (strcmp (IDENTIFIER_POINTER (token), \"weak\") == 0)\n+\t    type = state = ps_weak;\n+\t  else\n+#endif\n+\t    type = state = ps_done;\n+\t}\n+      else\n+\ttype = state = ps_done;\n+      break;\n+\n+#ifdef WEAK_ASM_OP\n+    case ps_weak:\n+      if (token && TREE_CODE (token) == IDENTIFIER_NODE)\n+\t{\n+\t  name = IDENTIFIER_POINTER (token);\n+\t  state = ps_name;\n+\t}\n+      else\n+\tstate = ps_bad;\n+      break;\n+\n+    case ps_name:\n+      state = (strcmp (string, \"=\") ? ps_bad : ps_equals);\n+      break;\n+\n+    case ps_equals:\n+      if (token && TREE_CODE (token) == IDENTIFIER_NODE)\n+\t{\n+\t  value = IDENTIFIER_POINTER (token);\n+\t  state = ps_value;\n+\t}\n+      else\n+\tstate = ps_bad;\n+      break;\n+\n+    case ps_value:\n+      state = ps_bad;\n+      break;\n+#endif /* WEAK_ASM_OP */\n+\n+    case ps_bad:\n+    case ps_done:\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+}\n+#endif /* HANDLE_PRAGMA */"}, {"sha": "857046c7c44a1d89e5e4b1bb245fd1d0eac7aba5", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead69aea2062e7bab67742f5aa95e901abebce74/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead69aea2062e7bab67742f5aa95e901abebce74/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=ead69aea2062e7bab67742f5aa95e901abebce74", "patch": "@@ -135,14 +135,12 @@\n ;; FiTOs/d\t9/5\n \n ;; The CY7C602 can only support 2 fp isnsn simultaneously.\n-;; More insns cause the chip to stall.  Until we handle this\n-;; better in the scheduler, we use excess cycle times to\n-;; more evenly spread out fp insns.\n-\n-(define_function_unit \"fp_alu\" 1 2 (eq_attr \"type\" \"fp\") 8 0)\n-(define_function_unit \"fp_mul\" 1 2 (eq_attr \"type\" \"fpmul\") 10 0)\n-(define_function_unit \"fp_div\" 1 2 (eq_attr \"type\" \"fpdiv\") 23 0)\n-(define_function_unit \"fp_sqrt\" 1 2 (eq_attr \"type\" \"fpsqrt\") 34 0)\n+;; More insns cause the chip to stall.\n+\n+(define_function_unit \"fp_alu\" 1 2 (eq_attr \"type\" \"fp\") 5 0)\n+(define_function_unit \"fp_mul\" 1 2 (eq_attr \"type\" \"fpmul\") 7 0)\n+(define_function_unit \"fp_div\" 1 2 (eq_attr \"type\" \"fpdiv\") 37 0)\n+(define_function_unit \"fp_sqrt\" 1 2 (eq_attr \"type\" \"fpsqrt\") 63 0)\n \f\n ;; Compare instructions.\n ;; This controls RTL generation and register allocation."}, {"sha": "3b9d5008db8caae77912fbbb97005e3850045d9f", "filename": "gcc/config/sparc/sysv4.h", "status": "modified", "additions": 48, "deletions": 1, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead69aea2062e7bab67742f5aa95e901abebce74/gcc%2Fconfig%2Fsparc%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead69aea2062e7bab67742f5aa95e901abebce74/gcc%2Fconfig%2Fsparc%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsysv4.h?ref=ead69aea2062e7bab67742f5aa95e901abebce74", "patch": "@@ -56,6 +56,24 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #define CPP_PREDEFINES \\\n   \"-Dsparc -Dunix -D__svr4__ -Asystem(unix) -Acpu(sparc) -Amachine(sparc)\"\n \n+/* The specialized code which needs to appear in the .init section prior\n+   to the prologue code for `__do_global_ctors' (see crtstuff.c).\n+\n+   On Sparcs running svr4, the /usr/ccs/lib/crti.o file (with gets linked\n+   in prior to the crtbegin.o file) has a single `save' instruction in its\n+   .init section.  That `save' instruction tries to setup a stack frame for\n+   the sake of any subsequent code in the .init section.  Unfortunately,\n+   the size it uses for the stack frame is only a guess, and is not really\n+   adequate for our purposes.  More importantly, we independently put our\n+   own standard function prologue (for __do_global_ctors) into the .init\n+   section and that function prologue includes its own `save' instruction!\n+   Thus, unless we do something to correct the situation, we'll get *two*\n+   stack frames allocated when crt0.o calls the code in the .init section,\n+   and havoc will ensue.  The following macro definition prevents such woes.\n+*/\n+\n+#define INIT_SECTION_PREAMBLE\tasm (\"restore\")\n+\n /* This is the string used to begin an assembly language comment for the\n    Sparc/svr4 assembler.  */\n \n@@ -83,7 +101,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n /* This is the format used to print a .pushsection pseudo-op (and its operand)\n    for the Sparc/svr4 assembler.  */\n \n-#define PUSHSECTION_FORMAT\t\"%s\\t\\\"%s\\\"\\n\"\n+#define PUSHSECTION_FORMAT\t\"\\t%s\\t\\\"%s\\\"\\n\"\n \n /* This is how to equate one symbol to another symbol.  The syntax used is\n    `SYM1=SYM2'.  Note that this is different from the way equates are done\n@@ -181,3 +199,32 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define INIT_SECTION_ASM_OP\t\".section\\t\\\".init\\\",#alloc\"\n #define CTORS_SECTION_ASM_OP    \".section\\t\\\".ctors\\\",#alloc\"\n #define DTORS_SECTION_ASM_OP    \".section\\t\\\".dtors\\\",#alloc\"\n+\n+/* Code to handle #pragma directives.  The interface is a bit messy,\n+   but there's no simpler way to do this while still using yylex.  */\n+#define HANDLE_PRAGMA(FILE)\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    while (c == ' ' || c == '\\t')\t\t\t\t\\\n+      c = getc (FILE);\t\t\t\t\t\t\\\n+    if (c == '\\n' || c == EOF)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\thandle_pragma_token (0, 0);\t\t\t\t\\\n+\treturn c;\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    ungetc (c, FILE);\t\t\t\t\t\t\\\n+    switch (yylex ())\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+      case IDENTIFIER:\t\t\t\t\t\t\\\n+      case TYPENAME:\t\t\t\t\t\t\\\n+      case STRING:\t\t\t\t\t\t\\\n+      case CONSTANT:\t\t\t\t\t\t\\\n+\thandle_pragma_token (token_buffer, yylval.ttype);\t\\\n+\tbreak;\t\t\t\t\t\t\t\\\n+      default:\t\t\t\t\t\t\t\\\n+\thandle_pragma_token (token_buffer, 0);\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    if (nextchar >= 0)\t\t\t\t\t\t\\\n+      c = nextchar, nextchar = -1;\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      c = getc (FILE);\t\t\t\t\t\t\\\n+  } while (1)"}, {"sha": "ce4e59d22d972a13091a938362a339c46e96a2e4", "filename": "gcc/sched.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead69aea2062e7bab67742f5aa95e901abebce74/gcc%2Fsched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead69aea2062e7bab67742f5aa95e901abebce74/gcc%2Fsched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched.c?ref=ead69aea2062e7bab67742f5aa95e901abebce74", "patch": "@@ -2391,11 +2391,9 @@ schedule_block (b, file)\n      high priorities to these insns to guarantee that they get scheduled last.\n      If these insns are ignored, as is currently done, the register life info\n      may be incorrectly computed.  */\n-  if (GET_CODE (tail) == INSN\n-      && GET_CODE (PATTERN (tail)) == USE\n-      && next_nonnote_insn (tail) == 0)\n+  if (GET_CODE (tail) == INSN && GET_CODE (PATTERN (tail)) == USE)\n     {\n-      /* Don't try to reorder any USE insns at the end of a function.\n+      /* Don't try to reorder any USE insns at the end of any block.\n \t They must be last to ensure proper register allocation.\n \t Exclude them all from scheduling.  */\n       do"}]}