{"sha": "565fad70aa35e354b628c5f94639e543a631e8e8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTY1ZmFkNzBhYTM1ZTM1NGI2MjhjNWY5NDYzOWU1NDNhNjMxZThlOA==", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2014-10-19T20:49:27Z"}, "committer": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2014-10-19T20:49:27Z"}, "message": "re PR fortran/48979 (FRACTION und EXPONENT return invalid results for infinity/NaN)\n\n\tPR fortran/48979\n\n\t* trans-const.c (gfc_build_nan): New function.\n\t* trans-const.h (gfc_build_nan): New prototype.\n\t* trans-intrinsic.c (gfc_conv_intrinsic_exponent): Handle special\n\tvalues.\n\t(gfc_conv_intrinsic_minmaxval): Use gfc_build_nan.\n\t(gfc_conv_intrinsic_fraction): Handle special values.\n\t(gfc_conv_intrinsic_spacing): Likewise.\n\t(gfc_conv_intrinsic_rrspacing): Likewise.\n\t(gfc_conv_intrinsic_set_exponent): Likewise.\n\n\t* gfortran.dg/ieee/intrinsics_2.F90: New test.\n\nFrom-SVN: r216443", "tree": {"sha": "39651a3e49d77383e3e4a37e968c07e84d8809ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39651a3e49d77383e3e4a37e968c07e84d8809ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/565fad70aa35e354b628c5f94639e543a631e8e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/565fad70aa35e354b628c5f94639e543a631e8e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/565fad70aa35e354b628c5f94639e543a631e8e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/565fad70aa35e354b628c5f94639e543a631e8e8/comments", "author": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d856054bc7b4d494010234816bcb25e837eea3b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d856054bc7b4d494010234816bcb25e837eea3b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d856054bc7b4d494010234816bcb25e837eea3b1"}], "stats": {"total": 208, "additions": 178, "deletions": 30}, "files": [{"sha": "6f05ef92925b0df1d4bf0d97bc7d6c4fac99b5fd", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/565fad70aa35e354b628c5f94639e543a631e8e8/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/565fad70aa35e354b628c5f94639e543a631e8e8/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=565fad70aa35e354b628c5f94639e543a631e8e8", "patch": "@@ -1,3 +1,16 @@\n+2014-10-19  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR fortran/48979\n+\t* trans-const.c (gfc_build_nan): New function.\n+\t* trans-const.h (gfc_build_nan): New prototype.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_exponent): Handle special\n+\tvalues.\n+\t(gfc_conv_intrinsic_minmaxval): Use gfc_build_nan.\n+\t(gfc_conv_intrinsic_fraction): Handle special values.\n+\t(gfc_conv_intrinsic_spacing): Likewise.\n+\t(gfc_conv_intrinsic_rrspacing): Likewise.\n+\t(gfc_conv_intrinsic_set_exponent): Likewise.\n+\n 2014-10-18  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/63553"}, {"sha": "99a18328be13210839523a5503f12e48da7f40ae", "filename": "gcc/fortran/trans-const.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/565fad70aa35e354b628c5f94639e543a631e8e8/gcc%2Ffortran%2Ftrans-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/565fad70aa35e354b628c5f94639e543a631e8e8/gcc%2Ffortran%2Ftrans-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-const.c?ref=565fad70aa35e354b628c5f94639e543a631e8e8", "patch": "@@ -256,6 +256,16 @@ gfc_build_inf_or_huge (tree type, int kind)\n     }\n }\n \n+/* Returns a floating-point NaN of a given type.  */\n+\n+tree\n+gfc_build_nan (tree type, const char *str)\n+{\n+  REAL_VALUE_TYPE real;\n+  real_nan (&real, str, 1, TYPE_MODE (type));\n+  return build_real (type, real);\n+}\n+\n /* Converts a backend tree into a real constant.  */\n \n void"}, {"sha": "b1f1910ff75920242ad658e031a382a9bdbe4f7a", "filename": "gcc/fortran/trans-const.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/565fad70aa35e354b628c5f94639e543a631e8e8/gcc%2Ffortran%2Ftrans-const.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/565fad70aa35e354b628c5f94639e543a631e8e8/gcc%2Ffortran%2Ftrans-const.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-const.h?ref=565fad70aa35e354b628c5f94639e543a631e8e8", "patch": "@@ -30,6 +30,10 @@ void gfc_conv_tree_to_mpfr (mpfr_ptr, tree);\n    not supported for the given type.  */\n tree gfc_build_inf_or_huge (tree, int);\n \n+/* Build a tree containing a NaN for the given type, with significand\n+   specified by second argument.  */\n+tree gfc_build_nan (tree, const char *);\n+\n /* Build a tree for a constant.  Must be an EXPR_CONSTANT gfc_expr.\n    For CHARACTER literal constants, the caller still has to set the\n    string length as a separate operation.  */"}, {"sha": "18159033e6554f59fa7d51759d1a98726333dff2", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 79, "deletions": 30, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/565fad70aa35e354b628c5f94639e543a631e8e8/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/565fad70aa35e354b628c5f94639e543a631e8e8/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=565fad70aa35e354b628c5f94639e543a631e8e8", "patch": "@@ -901,29 +901,40 @@ gfc_trans_same_strlen_check (const char* intr_name, locus* where,\n }\n \n \n-/* The EXPONENT(s) intrinsic function is translated into\n+/* The EXPONENT(X) intrinsic function is translated into\n        int ret;\n-       frexp (s, &ret);\n-       return ret;\n+       return isfinite(X) ? (frexp (X, &ret) , ret) : huge\n+   so that if X is a NaN or infinity, the result is HUGE(0).\n  */\n \n static void\n gfc_conv_intrinsic_exponent (gfc_se *se, gfc_expr *expr)\n {\n-  tree arg, type, res, tmp, frexp;\n+  tree arg, type, res, tmp, frexp, cond, huge;\n+  int i;\n \n   frexp = gfc_builtin_decl_for_float_kind (BUILT_IN_FREXP,\n \t\t\t\t       expr->value.function.actual->expr->ts.kind);\n \n   gfc_conv_intrinsic_function_args (se, expr, &arg, 1);\n+  arg = gfc_evaluate_now (arg, &se->pre);\n+\n+  i = gfc_validate_kind (BT_INTEGER, gfc_c_int_kind, false);\n+  huge = gfc_conv_mpz_to_tree (gfc_integer_kinds[i].huge, gfc_c_int_kind);\n+  cond = build_call_expr_loc (input_location,\n+\t\t\t      builtin_decl_explicit (BUILT_IN_ISFINITE),\n+\t\t\t      1, arg);\n \n   res = gfc_create_var (integer_type_node, NULL);\n   tmp = build_call_expr_loc (input_location, frexp, 2, arg,\n \t\t\t     gfc_build_addr_expr (NULL_TREE, res));\n-  gfc_add_expr_to_block (&se->pre, tmp);\n+  tmp = fold_build2_loc (input_location, COMPOUND_EXPR, integer_type_node,\n+\t\t\t tmp, res);\n+  se->expr = fold_build3_loc (input_location, COND_EXPR, integer_type_node,\n+\t\t\t      cond, tmp, huge);\n \n   type = gfc_typenode_for_spec (&expr->ts);\n-  se->expr = fold_convert (type, res);\n+  se->expr = fold_convert (type, se->expr);\n }\n \n \n@@ -4123,11 +4134,7 @@ gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, enum tree_code op)\n       else\n \ttmp = huge_cst;\n       if (HONOR_NANS (DECL_MODE (limit)))\n-\t{\n-\t  REAL_VALUE_TYPE real;\n-\t  real_nan (&real, \"\", 1, DECL_MODE (limit));\n-\t  nan_cst = build_real (type, real);\n-\t}\n+\tnan_cst = gfc_build_nan (type, \"\");\n       break;\n \n     case BT_INTEGER:\n@@ -5435,21 +5442,31 @@ gfc_conv_intrinsic_mask (gfc_se * se, gfc_expr * expr, int left)\n }\n \n \n-/* FRACTION (s) is translated into frexp (s, &dummy_int).  */\n+/* FRACTION (s) is translated into:\n+     isfinite (s) ? frexp (s, &dummy_int) : NaN  */\n static void\n gfc_conv_intrinsic_fraction (gfc_se * se, gfc_expr * expr)\n {\n-  tree arg, type, tmp, frexp;\n+  tree arg, type, tmp, res, frexp, cond;\n \n   frexp = gfc_builtin_decl_for_float_kind (BUILT_IN_FREXP, expr->ts.kind);\n \n   type = gfc_typenode_for_spec (&expr->ts);\n   gfc_conv_intrinsic_function_args (se, expr, &arg, 1);\n+  arg = gfc_evaluate_now (arg, &se->pre);\n+\n+  cond = build_call_expr_loc (input_location,\n+\t\t\t      builtin_decl_explicit (BUILT_IN_ISFINITE),\n+\t\t\t      1, arg);\n+\n   tmp = gfc_create_var (integer_type_node, NULL);\n-  se->expr = build_call_expr_loc (input_location, frexp, 2,\n-\t\t\t\t  fold_convert (type, arg),\n-\t\t\t\t  gfc_build_addr_expr (NULL_TREE, tmp));\n-  se->expr = fold_convert (type, se->expr);\n+  res = build_call_expr_loc (input_location, frexp, 2,\n+\t\t\t     fold_convert (type, arg),\n+\t\t\t     gfc_build_addr_expr (NULL_TREE, tmp));\n+  res = fold_convert (type, res);\n+\n+  se->expr = fold_build3_loc (input_location, COND_EXPR, type,\n+\t\t\t      cond, res, gfc_build_nan (type, \"\"));\n }\n \n \n@@ -5479,7 +5496,9 @@ gfc_conv_intrinsic_nearest (gfc_se * se, gfc_expr * expr)\n \n /* SPACING (s) is translated into\n     int e;\n-    if (s == 0)\n+    if (!isfinite (s))\n+      res = NaN;\n+    else if (s == 0)\n       res = tiny;\n     else\n     {\n@@ -5498,7 +5517,7 @@ static void\n gfc_conv_intrinsic_spacing (gfc_se * se, gfc_expr * expr)\n {\n   tree arg, type, prec, emin, tiny, res, e;\n-  tree cond, tmp, frexp, scalbn;\n+  tree cond, nan, tmp, frexp, scalbn;\n   int k;\n   stmtblock_t block;\n \n@@ -5533,12 +5552,19 @@ gfc_conv_intrinsic_spacing (gfc_se * se, gfc_expr * expr)\n \t\t\t build_real_from_int_cst (type, integer_one_node), e);\n   gfc_add_modify (&block, res, tmp);\n \n-  /* Finish by building the IF statement.  */\n+  /* Finish by building the IF statement for value zero.  */\n   cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, arg,\n \t\t\t  build_real_from_int_cst (type, integer_zero_node));\n   tmp = build3_v (COND_EXPR, cond, build2_v (MODIFY_EXPR, res, tiny),\n \t\t  gfc_finish_block (&block));\n \n+  /* And deal with infinities and NaNs.  */\n+  cond = build_call_expr_loc (input_location,\n+\t\t\t      builtin_decl_explicit (BUILT_IN_ISFINITE),\n+\t\t\t      1, arg);\n+  nan = gfc_build_nan (type, \"\");\n+  tmp = build3_v (COND_EXPR, cond, tmp, build2_v (MODIFY_EXPR, res, nan));\n+\n   gfc_add_expr_to_block (&se->pre, tmp);\n   se->expr = res;\n }\n@@ -5548,19 +5574,24 @@ gfc_conv_intrinsic_spacing (gfc_se * se, gfc_expr * expr)\n       int e;\n       real x;\n       x = fabs (s);\n-      if (x != 0)\n+      if (isfinite (x))\n       {\n-\tfrexp (s, &e);\n-\tx = scalbn (x, precision - e);\n+\tif (x != 0)\n+\t{\n+\t  frexp (s, &e);\n+\t  x = scalbn (x, precision - e);\n+\t}\n       }\n+      else\n+        x = NaN;\n       return x;\n \n  where precision is gfc_real_kinds[k].digits.  */\n \n static void\n gfc_conv_intrinsic_rrspacing (gfc_se * se, gfc_expr * expr)\n {\n-  tree arg, type, e, x, cond, stmt, tmp, frexp, scalbn, fabs;\n+  tree arg, type, e, x, cond, nan, stmt, tmp, frexp, scalbn, fabs;\n   int prec, k;\n   stmtblock_t block;\n \n@@ -5592,11 +5623,19 @@ gfc_conv_intrinsic_rrspacing (gfc_se * se, gfc_expr * expr)\n   gfc_add_modify (&block, x, tmp);\n   stmt = gfc_finish_block (&block);\n \n+  /* if (x != 0) */\n   cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node, x,\n \t\t\t  build_real_from_int_cst (type, integer_zero_node));\n   tmp = build3_v (COND_EXPR, cond, stmt, build_empty_stmt (input_location));\n-  gfc_add_expr_to_block (&se->pre, tmp);\n \n+  /* And deal with infinities and NaNs.  */\n+  cond = build_call_expr_loc (input_location,\n+\t\t\t      builtin_decl_explicit (BUILT_IN_ISFINITE),\n+\t\t\t      1, x);\n+  nan = gfc_build_nan (type, \"\");\n+  tmp = build3_v (COND_EXPR, cond, tmp, build2_v (MODIFY_EXPR, x, nan));\n+\n+  gfc_add_expr_to_block (&se->pre, tmp);\n   se->expr = fold_convert (type, x);\n }\n \n@@ -5619,25 +5658,35 @@ gfc_conv_intrinsic_scale (gfc_se * se, gfc_expr * expr)\n \n \n /* SET_EXPONENT (s, i) is translated into\n-   scalbn (frexp (s, &dummy_int), i).  */\n+   isfinite(s) ? scalbn (frexp (s, &dummy_int), i) : NaN  */\n static void\n gfc_conv_intrinsic_set_exponent (gfc_se * se, gfc_expr * expr)\n {\n-  tree args[2], type, tmp, frexp, scalbn;\n+  tree args[2], type, tmp, frexp, scalbn, cond, nan, res;\n \n   frexp = gfc_builtin_decl_for_float_kind (BUILT_IN_FREXP, expr->ts.kind);\n   scalbn = gfc_builtin_decl_for_float_kind (BUILT_IN_SCALBN, expr->ts.kind);\n \n   type = gfc_typenode_for_spec (&expr->ts);\n   gfc_conv_intrinsic_function_args (se, expr, args, 2);\n+  args[0] = gfc_evaluate_now (args[0], &se->pre);\n \n   tmp = gfc_create_var (integer_type_node, NULL);\n   tmp = build_call_expr_loc (input_location, frexp, 2,\n \t\t\t     fold_convert (type, args[0]),\n \t\t\t     gfc_build_addr_expr (NULL_TREE, tmp));\n-  se->expr = build_call_expr_loc (input_location, scalbn, 2, tmp,\n-\t\t\t\t  fold_convert (integer_type_node, args[1]));\n-  se->expr = fold_convert (type, se->expr);\n+  res = build_call_expr_loc (input_location, scalbn, 2, tmp,\n+\t\t\t     fold_convert (integer_type_node, args[1]));\n+  res = fold_convert (type, res);\n+\n+  /* Call to isfinite */\n+  cond = build_call_expr_loc (input_location,\n+\t\t\t      builtin_decl_explicit (BUILT_IN_ISFINITE),\n+\t\t\t      1, args[0]);\n+  nan = gfc_build_nan (type, \"\");\n+\n+  se->expr = fold_build3_loc (input_location, COND_EXPR, type, cond,\n+\t\t\t      res, nan);\n }\n \n "}, {"sha": "11ef72671590b99b06ff90ba6e8e3748381ec8cf", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/565fad70aa35e354b628c5f94639e543a631e8e8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/565fad70aa35e354b628c5f94639e543a631e8e8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=565fad70aa35e354b628c5f94639e543a631e8e8", "patch": "@@ -1,3 +1,8 @@\n+2014-10-19  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR fortran/48979\n+\t* gfortran.dg/ieee/intrinsics_2.F90: New test.\n+\n 2014-10-19  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/63567"}, {"sha": "a179da240900fe4f8f95d0e6b7989fb12798fa3d", "filename": "gcc/testsuite/gfortran.dg/ieee/intrinsics_2.F90", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/565fad70aa35e354b628c5f94639e543a631e8e8/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fintrinsics_2.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/565fad70aa35e354b628c5f94639e543a631e8e8/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fintrinsics_2.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fintrinsics_2.F90?ref=565fad70aa35e354b628c5f94639e543a631e8e8", "patch": "@@ -0,0 +1,67 @@\n+! { dg-do run }\n+! { dg-additional-options \"-fno-range-check\" }\n+!\n+! Check handling of special values by FRACTION, EXPONENT,\n+! SPACING, RRSPACING and SET_EXPONENT.\n+\n+program test\n+  implicit none\n+  real, parameter :: inf = 2 * huge(0.)\n+  real, parameter :: nan = 0. / 0.\n+\n+  real, volatile :: x\n+\n+  x = 0.\n+  call check_positive_zero(fraction(x))\n+  if (exponent(x) /= 0) call abort\n+  if (spacing(x) /= spacing(tiny(x))) call abort\n+  call check_positive_zero(rrspacing(x))\n+  call check_positive_zero(set_exponent(x,42))\n+\n+  x = -0.\n+  call check_negative_zero(fraction(x))\n+  if (exponent(x) /= 0) call abort\n+  if (spacing(x) /= spacing(tiny(x))) call abort\n+  call check_positive_zero(rrspacing(x))\n+  call check_negative_zero(set_exponent(x,42))\n+\n+  x = inf\n+  if (.not. isnan(fraction(x))) call abort\n+  if (exponent(x) /= huge(0)) call abort\n+  if (.not. isnan(spacing(x))) call abort\n+  if (.not. isnan(rrspacing(x))) call abort\n+  if (.not. isnan(set_exponent(x, 42))) call abort\n+\n+  x = -inf\n+  if (.not. isnan(fraction(x))) call abort\n+  if (exponent(x) /= huge(0)) call abort\n+  if (.not. isnan(spacing(x))) call abort\n+  if (.not. isnan(rrspacing(x))) call abort\n+  if (.not. isnan(set_exponent(x, 42))) call abort\n+\n+  x = nan\n+  if (.not. isnan(fraction(x))) call abort\n+  if (exponent(x) /= huge(0)) call abort\n+  if (.not. isnan(spacing(x))) call abort\n+  if (.not. isnan(rrspacing(x))) call abort\n+  if (.not. isnan(set_exponent(x, 42))) call abort\n+\n+contains\n+\n+  subroutine check_positive_zero(x)\n+    use ieee_arithmetic\n+    implicit none\n+    real, value :: x\n+\n+    if (ieee_class (x) /= ieee_positive_zero) call abort\n+  end\n+\n+  subroutine check_negative_zero(x)\n+    use ieee_arithmetic\n+    implicit none\n+    real, value :: x\n+\n+    if (ieee_class (x) /= ieee_negative_zero) call abort\n+  end\n+\n+end"}]}