{"sha": "92b6dff30288af56b6373689489a69d7e02f4193", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTJiNmRmZjMwMjg4YWY1NmI2MzczNjg5NDg5YTY5ZDdlMDJmNDE5Mw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2004-11-13T04:18:54Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2004-11-13T04:18:54Z"}, "message": "tree-cfg.c (hashtab.h): Include.\n\n\n\t* tree-cfg.c (hashtab.h): Include.\n\t(struct edge_to_case_leader_elt): New structure.\n\t(edge_to_case_leader): New.\n\t(edge_to_case_leader_hash): New hashtable hasing function.\n\t(edge_to_case_leader_eq): New hashtable equality function.\n\t(record_switch_edge): New function.\n\t(get_case_leader_for_edge, get_case_leader_for_edge): New functions.\n\t(make_switch_expr_edges): Build the edge-to-case-leader\n\thash table.  Tear down the hash table when we're done.\n\t(cleanup_dead_labels): Use CASE_LEADER_OR_LABEL instead of\n\tCASE_LABEL.\n\t(tree_node_can_be_shared): Allow sharing of CASE_LABEL_EXPR nodes.\n\t(tree_redirect_edge_and_branch, case SWITCH_EXPR): Update\n\tto use new concept of case leaders to reduce overhead of\n\tredirecting outgoing edges from switch statements.\n\t* tree.c (get_case_label): New function.\n\t* tree.h (CASE_LABEL): Define in terms of get_case_label.\n\t(CASE_LEADER_OR_LABEL): Define.\n\nFrom-SVN: r90570", "tree": {"sha": "f0bf0eacf8ffa54f821595a192ad4a94667a8d45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f0bf0eacf8ffa54f821595a192ad4a94667a8d45"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92b6dff30288af56b6373689489a69d7e02f4193", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92b6dff30288af56b6373689489a69d7e02f4193", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92b6dff30288af56b6373689489a69d7e02f4193", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92b6dff30288af56b6373689489a69d7e02f4193/comments", "author": null, "committer": null, "parents": [{"sha": "2256aa1cff25a0ea9c5b699795a773a93f11f565", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2256aa1cff25a0ea9c5b699795a773a93f11f565", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2256aa1cff25a0ea9c5b699795a773a93f11f565"}], "stats": {"total": 242, "additions": 228, "deletions": 14}, "files": [{"sha": "f48808db720645128c0ae250d89ebbeb41be5700", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92b6dff30288af56b6373689489a69d7e02f4193/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92b6dff30288af56b6373689489a69d7e02f4193/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=92b6dff30288af56b6373689489a69d7e02f4193", "patch": "@@ -1,3 +1,24 @@\n+2004-11-12  Jeff Law  <law@redhat.com>\n+\n+\t* tree-cfg.c (hashtab.h): Include.\n+\t(struct edge_to_case_leader_elt): New structure.\n+\t(edge_to_case_leader): New.\n+\t(edge_to_case_leader_hash): New hashtable hasing function.\n+\t(edge_to_case_leader_eq): New hashtable equality function.\n+\t(record_switch_edge): New function.\n+\t(get_case_leader_for_edge, get_case_leader_for_edge): New functions.\n+\t(make_switch_expr_edges): Build the edge-to-case-leader\n+\thash table.  Tear down the hash table when we're done.\n+\t(cleanup_dead_labels): Use CASE_LEADER_OR_LABEL instead of\n+\tCASE_LABEL.\n+\t(tree_node_can_be_shared): Allow sharing of CASE_LABEL_EXPR nodes.\n+\t(tree_redirect_edge_and_branch, case SWITCH_EXPR): Update\n+\tto use new concept of case leaders to reduce overhead of\n+\tredirecting outgoing edges from switch statements.\n+\t* tree.c (get_case_label): New function.\n+\t* tree.h (CASE_LABEL): Define in terms of get_case_label.\n+\t(CASE_LEADER_OR_LABEL): Define.\n+\n 2004-11-12  Ziemowit Laski  <zlaski@apple.com>\n \n \t* varasm.c (output_addressed_constants): For CONST_DECLs,"}, {"sha": "049da477da718a053fdc644a1f66ad14c876459f", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 182, "deletions": 11, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92b6dff30288af56b6373689489a69d7e02f4193/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92b6dff30288af56b6373689489a69d7e02f4193/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=92b6dff30288af56b6373689489a69d7e02f4193", "patch": "@@ -44,6 +44,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"except.h\"\n #include \"cfgloop.h\"\n #include \"cfglayout.h\"\n+#include \"hashtab.h\"\n \n /* This file contains functions for building the Control Flow Graph (CFG)\n    for a function tree.  */\n@@ -57,6 +58,30 @@ static const int initial_cfg_capacity = 20;\n    building of the CFG in code with lots of gotos.  */\n static GTY(()) varray_type label_to_block_map;\n \n+/* This hash table allows us to efficiently lookup the one and only one\n+   CASE_LABEL_EXPR which contains the LABEL_DECL for the target block\n+   of one or more case statements.  Efficient access to this node\n+   allows us to efficiently update the case vector in response to\n+   edge redirections and similar operations. \n+\n+   Right now this is only used to set up case label leaders.  In the\n+   future we hope to make this table more persistent and use it to\n+   more efficiently update case labels.  */\n+\n+struct edge_to_case_leader_elt\n+{\n+  /* The edge itself.  Necessary for hashing and equality tests.  */\n+  edge e;\n+\n+  /* The \"leader\" for all the CASE_LABEL_EXPRs which transfer control\n+     to E->dest.  When we change the destination of E, we will need to\n+     update the CASE_LEADER_OR_LABEL of this CASE_LABEL_EXPR (and no\n+     others).  */\n+  tree case_label;\n+};\n+\n+static htab_t edge_to_case_leader;\n+\n /* CFG statistics.  */\n struct cfg_stats_d\n {\n@@ -576,6 +601,122 @@ make_cond_expr_edges (basic_block bb)\n   make_edge (bb, else_bb, EDGE_FALSE_VALUE);\n }\n \n+/* Hashing routine for EDGE_TO_CASE_LEADER.  */\n+\n+static hashval_t\n+edge_to_case_leader_hash (const void *p)\n+{\n+  edge e = ((struct edge_to_case_leader_elt *)p)->e;\n+\n+  /* Hash on the edge itself (which is a pointer).  */\n+  return htab_hash_pointer (e);\n+}\n+\n+/* Equality routine for EDGE_TO_CASE_LEADER, edges are unique, so testing\n+   for equality is just a pointer comparison.  */\n+\n+static int\n+edge_to_case_leader_eq (const void *p1, const void *p2)\n+{\n+  edge e1 = ((struct edge_to_case_leader_elt *)p1)->e;\n+  edge e2 = ((struct edge_to_case_leader_elt *)p2)->e;\n+\n+  return e1 == e2;\n+}\n+\n+/* Record that CASE_LABEL (a CASE_LABEL_EXPR) references edge E.  */\n+\n+static void\n+record_switch_edge (edge e, tree case_label)\n+{\n+  struct edge_to_case_leader_elt *elt;\n+  void **slot;\n+\n+  /* Build a hash table element so we can see if E is already\n+     in the table.  */\n+  elt = xmalloc (sizeof (struct edge_to_case_leader_elt));\n+  elt->e = e;\n+  elt->case_label = case_label;\n+\n+  slot = htab_find_slot (edge_to_case_leader, elt, INSERT);\n+\n+  if (*slot == NULL)\n+    {\n+      /* E was not in the hash table.  Install E into the hash table.  */\n+      *slot = (void *)elt;\n+    }\n+  else\n+    {\n+      /* E was already in the hash table.  Free ELT as we do not need it\n+\t anymore.  */\n+      free (elt);\n+\n+      /* Get the entry stored in the hash table.  */\n+      elt = (struct edge_to_case_leader_elt *) *slot;\n+\n+      /* Make ELT->case_label the leader for CASE_LABEL.  */\n+      CASE_LEADER_OR_LABEL (case_label) = elt->case_label;\n+    }\n+}\n+\n+/* Subroutine of get_case_leader_for_edge; returns the case leader for the\n+   chain of CASE_LABEL_EXPRs associated with E using a hash table lookup.  */\n+\n+static tree\n+get_case_leader_for_edge_hash (edge e)\n+{\n+  struct edge_to_case_leader_elt elt, *elt_p;\n+  void **slot;\n+\n+  elt.e = e;\n+  elt.case_label = NULL;\n+  slot = htab_find_slot (edge_to_case_leader, &elt, NO_INSERT);\n+\n+  if (slot)\n+    {\n+      tree t;\n+\n+      elt_p = (struct edge_to_case_leader_elt *)*slot;\n+      t = elt_p->case_label;\n+\n+      while (TREE_CODE (CASE_LEADER_OR_LABEL (t)) == CASE_LABEL_EXPR)\n+\tt = CASE_LEADER_OR_LABEL (t);\n+      return t;\n+    }\n+\n+  return NULL;\n+}\n+\n+/* Given an edge E, return the case leader for the chain of CASE_LABEL_EXPRs\n+   which use E.  */\n+\n+static tree\n+get_case_leader_for_edge (edge e)\n+{\n+  tree vec, stmt;\n+  size_t i, n;\n+\n+  /* If we have a hash table, then use it as it's significantly faster.  */\n+  if (edge_to_case_leader)\n+    return get_case_leader_for_edge_hash (e);\n+\n+  /* No hash table.  We have to walk the case vector.  */\n+  stmt = bsi_stmt (bsi_last (e->src));\n+  vec = SWITCH_LABELS (stmt);\n+  n = TREE_VEC_LENGTH (vec);\n+\n+  for (i = 0; i < n; i++)\n+    {\n+      tree elt = TREE_VEC_ELT (vec, i);\n+      tree t = CASE_LEADER_OR_LABEL (elt);\n+\n+      if (TREE_CODE (t) == LABEL_DECL\n+\t  && label_to_block (t) == e->dest)\n+\treturn elt;\n+    }\n+\n+  abort ();\n+}\n \n /* Create the edges for a SWITCH_EXPR starting at block BB.\n    At this point, the switch body has been lowered and the\n@@ -591,12 +732,22 @@ make_switch_expr_edges (basic_block bb)\n   vec = SWITCH_LABELS (entry);\n   n = TREE_VEC_LENGTH (vec);\n \n+  edge_to_case_leader\n+    = htab_create (n, edge_to_case_leader_hash, edge_to_case_leader_eq, free);\n+\n   for (i = 0; i < n; ++i)\n     {\n       tree lab = CASE_LABEL (TREE_VEC_ELT (vec, i));\n       basic_block label_bb = label_to_block (lab);\n-      make_edge (bb, label_bb, 0);\n+      edge e = make_edge (bb, label_bb, 0);\n+\n+      if (!e)\n+\te = find_edge (bb, label_bb);\n+\n+      record_switch_edge (e, TREE_VEC_ELT (vec, i));\n     }\n+  htab_delete (edge_to_case_leader);\n+  edge_to_case_leader = NULL;\n }\n \n \n@@ -865,9 +1016,11 @@ cleanup_dead_labels (void)\n   \n \t    /* Replace all destination labels.  */\n \t    for (i = 0; i < n; ++i)\n-\t      CASE_LABEL (TREE_VEC_ELT (vec, i))\n-\t\t= main_block_label (CASE_LABEL (TREE_VEC_ELT (vec, i)));\n-  \n+\t      {\n+\t\ttree elt = TREE_VEC_ELT (vec, i);\n+\t\ttree label = main_block_label (CASE_LABEL (elt));\n+\t\tCASE_LEADER_OR_LABEL (elt) = label;\n+\t      }\n \t    break;\n \t  }\n \n@@ -3246,6 +3399,9 @@ tree_node_can_be_shared (tree t)\n       || TREE_CODE (t) == SSA_NAME)\n     return true;\n \n+  if (TREE_CODE (t) == CASE_LABEL_EXPR)\n+    return true;\n+\n   while (((TREE_CODE (t) == ARRAY_REF || TREE_CODE (t) == ARRAY_RANGE_REF)\n \t  /* We check for constants explicitly since they are not considered\n \t     gimple invariants if they overflowed.  */\n@@ -4134,17 +4290,32 @@ tree_redirect_edge_and_branch (edge e, basic_block dest)\n \n     case SWITCH_EXPR:\n       {\n-\ttree vec = SWITCH_LABELS (stmt);\n-\tsize_t i, n = TREE_VEC_LENGTH (vec);\n+\tedge e2;\n+\n+        /* We need to update the LABEL_DECL in the switch vector to\n+\t   reflect the edge redirection.\n \n-\tfor (i = 0; i < n; ++i)\n+\t   There is precisely one CASE_LABEL_EXPR in the switch vector\n+\t   which needs updating.  Either its label needs to be updated\n+\t   or it needs to be directed to a new case leader.   */\n+\te2 = find_edge (e->src, dest);\n+\tif (e2)\n \t  {\n-\t    tree elt = TREE_VEC_ELT (vec, i);\n-\t    if (label_to_block (CASE_LABEL (elt)) == e->dest)\n-\t      CASE_LABEL (elt) = label;\n+\t    /* In this case we need to change the case leader for the\n+\t       current leader of E to be the case leader for E2.   */\n+\t    tree e_leader = get_case_leader_for_edge (e);\n+\t    tree e2_leader = get_case_leader_for_edge (e2);\n+\t    CASE_LEADER_OR_LABEL (e_leader) = e2_leader;\n \t  }\n+\telse\n+\t  {\n+\t    /* No edge exists from E->src to DEST, so we will simply\n+\t       change E->dest.  The case leader does not change, but\n+\t       the LABEL_DECL for the leader does change.  */\n+\t    CASE_LEADER_OR_LABEL (get_case_leader_for_edge (e)) = label;\n+\t  }\n+\tbreak;\n       }\n-      break;\n \n     case RETURN_EXPR:\n       bsi_remove (&bsi);"}, {"sha": "8774107e3d558572b5a9ac3df78b2603bbcfb678", "filename": "gcc/tree.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92b6dff30288af56b6373689489a69d7e02f4193/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92b6dff30288af56b6373689489a69d7e02f4193/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=92b6dff30288af56b6373689489a69d7e02f4193", "patch": "@@ -6061,4 +6061,17 @@ signed_type_for (tree type)\n   return lang_hooks.types.signed_type (type);\n }\n \n+/* Return the LABEL_DECL associated with T, which must be a \n+   CASE_LABEL_EXPR.  This will walk through any CASE_LABEL_EXPRs\n+   appearing in operand 2 until it finds a CASE_LABEL_EXPR with\n+   a LABEL_DECL in operand 2.  */\n+\n+tree\n+get_case_label (tree t)\n+{\n+  while (TREE_CODE (CASE_LEADER_OR_LABEL (t)) == CASE_LABEL_EXPR)\n+    t = CASE_LEADER_OR_LABEL (t);\n+  return CASE_LEADER_OR_LABEL (t);\n+}\n+\n #include \"gt-tree.h\""}, {"sha": "e79470001cdf0edf8a68a5a53a29f735e1cbcd45", "filename": "gcc/tree.h", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92b6dff30288af56b6373689489a69d7e02f4193/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92b6dff30288af56b6373689489a69d7e02f4193/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=92b6dff30288af56b6373689489a69d7e02f4193", "patch": "@@ -1229,9 +1229,17 @@ struct tree_vec GTY(())\n \n /* CASE_LABEL_EXPR accessors. These give access to the high and low values\n    of a case label, respectively.  */\n-#define CASE_LOW(NODE)          TREE_OPERAND ((NODE), 0)\n-#define CASE_HIGH(NODE)         TREE_OPERAND ((NODE), 1)\n-#define CASE_LABEL(NODE)        TREE_OPERAND ((NODE), 2)\n+#define CASE_LOW(NODE)          \tTREE_OPERAND ((NODE), 0)\n+#define CASE_HIGH(NODE)         \tTREE_OPERAND ((NODE), 1)\n+\n+/* Operand 2 has two uses, it may either be a LABEL_DECL node or a\n+   another CASE_LABEL_EXPR node.  This accessor gets direct access\n+   to that operand.  Use it when you want to assign a value to\n+   operand 2 or when you want to conditionalalize actions based on\n+   whether operand 2 is a LABEL_DELC or CASE_LABEL_EXPR.  */\n+#define CASE_LEADER_OR_LABEL(NODE)\tTREE_OPERAND ((NODE), 2)\n+\n+#define CASE_LABEL(NODE) get_case_label (NODE)\n \n /* The operands of a BIND_EXPR.  */\n #define BIND_EXPR_VARS(NODE) (TREE_OPERAND (BIND_EXPR_CHECK (NODE), 0))\n@@ -3455,6 +3463,7 @@ extern void change_decl_assembler_name (tree, tree);\n extern int type_num_arguments (tree);\n extern bool associative_tree_code (enum tree_code);\n extern bool commutative_tree_code (enum tree_code);\n+extern tree get_case_label (tree);\n \n \f\n /* In stmt.c */"}]}