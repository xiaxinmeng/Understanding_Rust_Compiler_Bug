{"sha": "26026d3803c021234bb9ce9b46cba8792764b758", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjYwMjZkMzgwM2MwMjEyMzRiYjljZTliNDZjYmE4NzkyNzY0Yjc1OA==", "commit": {"author": {"name": "Alex Samuel", "email": "samuel@codesourcery.com", "date": "2000-04-28T06:18:14Z"}, "committer": {"name": "Alex Samuel", "email": "samuel@gcc.gnu.org", "date": "2000-04-28T06:18:14Z"}, "message": "Makefile.in (timevar.o): Depend on flags.h.\n\n\t* Makefile.in (timevar.o): Depend on flags.h.\n\t* timevar.c (unused_stack_instances): New variable.\n\t(timevar_push): Take a timevar_stack_def from\n\tunused_stack_instances if available.\n\t(timevar_pop): Push the popped timevar_stack_def onto\n\tunused_stack_instances.\n\t(TIMEVAR_ENABLE): New macro.\n\t(timevar_def): Make standalone a 1-bit field.  Add field used.\n\t(get_time): Rename parameter to now.  Return after clearing it if\n\tnot TIMEVAR_ENABLE.\n\t(init_timevar): Do nothing if not TIMEVAR_ENABLE.\n\t(timevar_pop): Likewise.\n\t(timevar_stop): Likewise.\n\t(timevar_push): Likewise.  Mark the timing variable as used.\n\t(timevar_start): Likewise.\n\t(timevar_print): Do nothing if not TIMEVAR_ENABLE.  Don't print\n\ttimevars that were never used.\n\nFrom-SVN: r33504", "tree": {"sha": "b3fd7fe7ab5425c77334ae61a111990fc9a108ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b3fd7fe7ab5425c77334ae61a111990fc9a108ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/26026d3803c021234bb9ce9b46cba8792764b758", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26026d3803c021234bb9ce9b46cba8792764b758", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26026d3803c021234bb9ce9b46cba8792764b758", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26026d3803c021234bb9ce9b46cba8792764b758/comments", "author": null, "committer": null, "parents": [{"sha": "5db2c9b839809d09cae6de830126b11793f2f12a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5db2c9b839809d09cae6de830126b11793f2f12a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5db2c9b839809d09cae6de830126b11793f2f12a"}], "stats": {"total": 135, "additions": 105, "deletions": 30}, "files": [{"sha": "58ad2c0c33dddd26547f61adfff1a9c6899a313a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26026d3803c021234bb9ce9b46cba8792764b758/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26026d3803c021234bb9ce9b46cba8792764b758/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=26026d3803c021234bb9ce9b46cba8792764b758", "patch": "@@ -1,3 +1,23 @@\n+2000-04-27  Alex Samuel  <samuel@codesourcery.com>\n+\n+\t* Makefile.in (timevar.o): Depend on flags.h.\n+\t* timevar.c (unused_stack_instances): New variable.\n+\t(timevar_push): Take a timevar_stack_def from\n+\tunused_stack_instances if available.\n+\t(timevar_pop): Push the popped timevar_stack_def onto\n+\tunused_stack_instances.\n+\t(TIMEVAR_ENABLE): New macro.\n+\t(timevar_def): Make standalone a 1-bit field.  Add field used.\n+\t(get_time): Rename parameter to now.  Return after clearing it if\n+\tnot TIMEVAR_ENABLE.\n+\t(init_timevar): Do nothing if not TIMEVAR_ENABLE.\n+\t(timevar_pop): Likewise.\n+\t(timevar_stop): Likewise.\n+\t(timevar_push): Likewise.  Mark the timing variable as used.\n+\t(timevar_start): Likewise.\n+\t(timevar_print): Do nothing if not TIMEVAR_ENABLE.  Don't print\n+\ttimevars that were never used.\n+\n 2000-04-27  Mark Mitchell  <mark@codesourcery.com>\n \n \t* c-commom.c (c_apply_type_quals_to_decl): REFERENCE_TYPES are"}, {"sha": "85d6890a9b291ca237324c5f3c6806d34c12612d", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26026d3803c021234bb9ce9b46cba8792764b758/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26026d3803c021234bb9ce9b46cba8792764b758/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=26026d3803c021234bb9ce9b46cba8792764b758", "patch": "@@ -1658,7 +1658,7 @@ lists.o: lists.c $(CONFIG_H) system.h toplev.h $(RTL_H) $(GGC_H)\n bb-reorder.o : bb-reorder.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n    insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h \\\n    $(RECOG_H) insn-flags.h function.h except.h $(EXPR_H)\n-timevar.o : timevar.c $(CONFIG_H) system.h timevar.h timevar.def\n+timevar.o : timevar.c $(CONFIG_H) system.h timevar.h timevar.def flags.h\n timevar.h : timevar.def\n \n regrename.o : regrename.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\"}, {"sha": "9eaee794efe8e769eec778c71793fdef36b0e967", "filename": "gcc/timevar.c", "status": "modified", "additions": 84, "deletions": 29, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26026d3803c021234bb9ce9b46cba8792764b758/gcc%2Ftimevar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26026d3803c021234bb9ce9b46cba8792764b758/gcc%2Ftimevar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.c?ref=26026d3803c021234bb9ce9b46cba8792764b758", "patch": "@@ -26,10 +26,14 @@\n # include <sys/times.h>\n #endif\n \n+#include \"flags.h\"\n #include \"timevar.h\"\n \n /* See timevar.h for an explanation of timing variables.  */\n \n+/* This macro evaluates to non-zero if timing variables are enabled. */\n+#define TIMEVAR_ENABLE (!quiet_flag)\n+\n /* A timing variable.  */\n \n struct timevar_def\n@@ -41,12 +45,16 @@ struct timevar_def\n      using timevar_start, this contains the start time.  */\n   struct timevar_time_def start_time;\n \n+  /* The name of this timing variable.  */\n+  const char *name;\n+\n   /* Non-zero if this timing variable is running as a standalone\n      timer.  */\n-  int standalone;\n+  unsigned standalone : 1;\n \n-  /* The name of this timing variable.  */\n-  const char *name;\n+  /* Non-zero if this timing variable was ever started or pushed onto\n+     the timing stack.  */\n+  unsigned used : 1;\n };\n \n /* An element on the timing stack.  Elapsed time is attributed to the\n@@ -68,6 +76,10 @@ static struct timevar_def timevars[TIMEVAR_LAST];\n /* The top of the timing stack.  */\n static struct timevar_stack_def *stack;\n \n+/* A list of unused (i.e. allocated and subsequently popped)\n+   timevar_stack_def instances.  */\n+static struct timevar_stack_def *unused_stack_instances;\n+\n /* The time at which the topmost element on the timing stack was\n    pushed.  Time elapsed since then is attributed to the topmost\n    element.  */\n@@ -86,19 +98,22 @@ static void timevar_accumulate\n    HAVA_WALL_TIME macros.  */\n \n static void\n-get_time (time)\n-     struct timevar_time_def *time;\n+get_time (now)\n+     struct timevar_time_def *now;\n {\n-  time->user = 0;\n-  time->sys  = 0;\n-  time->wall = 0;\n+  now->user = 0;\n+  now->sys  = 0;\n+  now->wall = 0;\n+\n+  if (!TIMEVAR_ENABLE)\n+    return;\n \n #ifdef __BEOS__\n   /* Nothing.  */\n #else /* not BeOS */\n #if defined (_WIN32) && !defined (__CYGWIN__)\n   if (clock () >= 0)\n-    time->user = clock () * 1000;\n+    now->user = clock () * 1000;\n #define HAVE_USER_TIME\n \n #else /* not _WIN32 */\n@@ -108,9 +123,9 @@ get_time (time)\n     struct tms tms;\n     if (tick == 0)\n       tick = 1000000 / sysconf (_SC_CLK_TCK);\n-    time->wall = times (&tms) * tick;\n-    time->user = tms.tms_utime * tick;\n-    time->sys = tms.tms_stime * tick;\n+    now->wall = times (&tms) * tick;\n+    now->user = tms.tms_utime * tick;\n+    now->sys = tms.tms_stime * tick;\n   }\n #define HAVE_USER_TIME\n #define HAVE_SYS_TIME\n@@ -129,9 +144,9 @@ get_time (time)\n #     define TICKS_PER_SECOND HZ /* traditional UNIX */\n #    endif\n #   endif\n-    time->wall = times (&tms) * (1000000 / TICKS_PER_SECOND);\n-    time->user = tms.tms_utime * (1000000 / TICKS_PER_SECOND);\n-    time->sys = tms.tms_stime * (1000000 / TICKS_PER_SECOND);\n+    now->wall = times (&tms) * (1000000 / TICKS_PER_SECOND);\n+    now->user = tms.tms_utime * (1000000 / TICKS_PER_SECOND);\n+    now->sys = tms.tms_stime * (1000000 / TICKS_PER_SECOND);\n   }\n #define HAVE_USER_TIME\n #define HAVE_SYS_TIME\n@@ -142,9 +157,9 @@ get_time (time)\n   {\n     struct rusage rusage;\n     getrusage (0, &rusage);\n-    time->user \n+    now->user \n       = rusage.ru_utime.tv_sec * 1000000 + rusage.ru_utime.tv_usec;\n-    time->sys \n+    now->sys \n       = rusage.ru_stime.tv_sec * 1000000 + rusage.ru_stime.tv_usec;\n   }\n #define HAVE_USER_TIME\n@@ -159,9 +174,9 @@ get_time (time)\n         int child_user_time;\n         int child_system_time;\n       } vms_times;\n-    time->wall = times ((void *) &vms_times) * 10000;\n-    time->user = vms_times.proc_user_time * 10000;\n-    time->sys = vms_times.proc_system_time * 10000;\n+    now->wall = times ((void *) &vms_times) * 10000;\n+    now->user = vms_times.proc_user_time * 10000;\n+    now->sys = vms_times.proc_system_time * 10000;\n   }\n #define HAVE_USER_TIME\n #define HAVE_SYS_TIME\n@@ -204,6 +219,9 @@ timevar_accumulate (timer, start_time, stop_time)\n void\n init_timevar (void)\n {\n+  if (!TIMEVAR_ENABLE)\n+    return;\n+\n   /* Zero all elapsed times.  */\n   memset ((void *) timevars, 0, sizeof (timevars));\n \n@@ -229,6 +247,12 @@ timevar_push (timevar)\n   struct timevar_stack_def *context;\n   struct timevar_time_def now;\n \n+  if (!TIMEVAR_ENABLE)\n+    return;\n+\n+  /* Mark this timing variable as used.  */\n+  tv->used = 1;\n+\n   /* Can't push a standalone timer.  */\n   if (tv->standalone)\n     abort ();\n@@ -245,9 +269,18 @@ timevar_push (timevar)\n      TIMEVAR. */\n   start_time = now;\n \n-  /* Create a new stack element, and push it.  */\n-  context = (struct timevar_stack_def *) \n-    xmalloc (sizeof (struct timevar_stack_def));\n+  /* See if we have a previously-allocated stack instance.  If so,\n+     take it off the list.  If not, malloc a new one.  */\n+  if (unused_stack_instances != NULL) \n+    {\n+      context = unused_stack_instances;\n+      unused_stack_instances = unused_stack_instances->next;\n+    }\n+  else\n+    context = (struct timevar_stack_def *) \n+      xmalloc (sizeof (struct timevar_stack_def));\n+\n+  /* Fill it in and put it on the stack.  */\n   context->timevar = tv;\n   context->next = stack;\n   stack = context;\n@@ -264,7 +297,10 @@ timevar_pop (timevar)\n      timevar_id_t timevar;\n {\n   struct timevar_time_def now;\n-  struct timevar_stack_def *next = stack->next;\n+  struct timevar_stack_def *popped = stack;\n+\n+  if (!TIMEVAR_ENABLE)\n+    return;\n \n   if (&timevars[timevar] != stack->timevar)\n     abort ();\n@@ -273,15 +309,19 @@ timevar_pop (timevar)\n   get_time (&now);\n \n   /* Attribute the elapsed time to the element we're popping.  */\n-  timevar_accumulate (&stack->timevar->elapsed, &start_time, &now);\n+  timevar_accumulate (&popped->timevar->elapsed, &start_time, &now);\n \n   /* Reset the start time; from now on, time is attributed to the\n      element just exposed on the stack.  */\n   start_time = now;\n \n-  /* Remove the stack element.  */\n-  free (stack);\n-  stack = next;\n+  /* Take the item off the stack.  */\n+  stack = stack->next;\n+\n+  /* Don't delete the stack element; instead, add it to the list of\n+     unused elements for later use.  */\n+  popped->next = unused_stack_instances;\n+  unused_stack_instances = popped;\n }\n \n /* Start timing TIMEVAR independently of the timing stack.  Elapsed\n@@ -294,6 +334,12 @@ timevar_start (timevar)\n {\n   struct timevar_def *tv = &timevars[timevar];\n \n+  if (!TIMEVAR_ENABLE)\n+    return;\n+\n+  /* Mark this timing variable as used.  */\n+  tv->used = 1;\n+\n   /* Don't allow the same timing variable to be started more than\n      once.  */\n   if (tv->standalone)\n@@ -313,6 +359,9 @@ timevar_stop (timevar)\n   struct timevar_def *tv = &timevars[timevar];\n   struct timevar_time_def now;\n \n+  if (!TIMEVAR_ENABLE)\n+    return;\n+\n   /* TIMEVAR must have been started via timevar_start.  */\n   if (!tv->standalone)\n     abort ();\n@@ -357,6 +406,9 @@ timevar_print (fp)\n   timevar_id_t id;\n   struct timevar_time_def *total = &timevars[TV_TOTAL].elapsed;\n \n+  if (!TIMEVAR_ENABLE)\n+    return;\n+\n   fprintf (fp, \"\\nExecution times (seconds)\\n\");\n   for (id = 0; id < TIMEVAR_LAST; ++id)\n     {\n@@ -367,6 +419,10 @@ timevar_print (fp)\n       if (id == TV_TOTAL)\n \tcontinue;\n \n+      /* Don't print timing variables that were never used.  */\n+      if (!tv->used)\n+\tcontinue;\n+\n       /* The timing variable name.  */\n       fprintf (fp, \" %-22s:\", tv->name);\n \n@@ -445,4 +501,3 @@ print_time (str, total)\n  \t   all_time == 0 ? 0\n  \t   : (long) (((100.0 * (double) total) / (double) all_time) + .5));\n }\n-"}]}