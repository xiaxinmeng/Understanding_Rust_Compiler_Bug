{"sha": "ca58f2bc5c2ad8d30514c32e2e0b5283d0486a3c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2E1OGYyYmM1YzJhZDhkMzA1MTRjMzJlMmUwYjUyODNkMDQ4NmEzYw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-02-01T20:57:22Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-02-01T20:57:22Z"}, "message": "re PR other/19696 (gcc.c-torture/execute/ieee/copysign1.c: Unsatisfied symbols: copysignl)\n\n        PR 19696\n        * optabs.c (expand_copysign_absneg): Export.\n        * optabs.h (expand_copysign_absneg): Declare.\n        * config/rs6000/rs6000.md (copysigntf3): New.\n\n        * gcc.c-torture/execute/ieee/copysign1.c: Special case sizeof\n        long double for ibm double-double format.\n        * gcc.c-torture/execute/ieee/copysign2.c: Likewise.\n\nFrom-SVN: r94559", "tree": {"sha": "d73391b5971c6c088a383a03dc2be2def07a0bc7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d73391b5971c6c088a383a03dc2be2def07a0bc7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca58f2bc5c2ad8d30514c32e2e0b5283d0486a3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca58f2bc5c2ad8d30514c32e2e0b5283d0486a3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca58f2bc5c2ad8d30514c32e2e0b5283d0486a3c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca58f2bc5c2ad8d30514c32e2e0b5283d0486a3c/comments", "author": null, "committer": null, "parents": [{"sha": "a1d13fa1672efeaf2886bb4184b6e73874c092ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1d13fa1672efeaf2886bb4184b6e73874c092ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1d13fa1672efeaf2886bb4184b6e73874c092ca"}], "stats": {"total": 68, "additions": 67, "deletions": 1}, "files": [{"sha": "054b745832ad3f6c347f7c8b7e8924fc02f52397", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca58f2bc5c2ad8d30514c32e2e0b5283d0486a3c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca58f2bc5c2ad8d30514c32e2e0b5283d0486a3c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ca58f2bc5c2ad8d30514c32e2e0b5283d0486a3c", "patch": "@@ -1,3 +1,10 @@\n+2005-02-01  Richard Henderson  <rth@redhat.com>\n+\n+\tPR 19696\n+\t* optabs.c (expand_copysign_absneg): Export.\n+\t* optabs.h (expand_copysign_absneg): Declare.\n+\t* config/rs6000/rs6000.md (copysigntf3): New.\n+\n 2005-02-01  Diego Novillo  <dnovillo@redhat.com>\n \n \tPR tree-optimization/19633"}, {"sha": "c2dd678d7670638ddcb1b7cf4d2781d9434b17ea", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca58f2bc5c2ad8d30514c32e2e0b5283d0486a3c/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca58f2bc5c2ad8d30514c32e2e0b5283d0486a3c/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=ca58f2bc5c2ad8d30514c32e2e0b5283d0486a3c", "patch": "@@ -8466,6 +8466,33 @@\n   operands[5] = simplify_gen_subreg (DFmode, operands[0], TFmode, hi_word);\n   operands[6] = simplify_gen_subreg (DFmode, operands[0], TFmode, lo_word);\n }\")\n+\n+(define_expand \"copysigntf3\"\n+  [(match_operand:TF 0 \"general_operand\" \"\")\n+   (match_operand:TF 1 \"general_operand\" \"\")\n+   (match_operand:TF 2 \"general_operand\" \"\")]\n+  \"(DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_DARWIN)\n+   && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_LONG_DOUBLE_128\"\n+{\n+  rtx target, op0, op1, temp;\n+  bool op0_is_abs = false;\n+\n+  target = operands[0];\n+  op0 = operands[1];\n+  op1 = operands[2];\n+\n+  if (GET_CODE (op0) == CONST_DOUBLE)\n+    {\n+      if (real_isneg (CONST_DOUBLE_REAL_VALUE (op0)))\n+\top0 = simplify_unary_operation (ABS, TFmode, op0, TFmode);\n+      op0_is_abs = true;\n+    }\n+\n+  temp = expand_copysign_absneg (TFmode, op0, op1, target, 127, op0_is_abs);\n+  if (temp != target)\n+    emit_move_insn (target, temp);\n+  DONE;\n+})\n \f\n ;; Next come the multi-word integer load and store and the load and store\n ;; multiple insns."}, {"sha": "889f9156dd165027a6d7954a0cffd5a02799dcaf", "filename": "gcc/optabs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca58f2bc5c2ad8d30514c32e2e0b5283d0486a3c/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca58f2bc5c2ad8d30514c32e2e0b5283d0486a3c/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=ca58f2bc5c2ad8d30514c32e2e0b5283d0486a3c", "patch": "@@ -2662,7 +2662,7 @@ expand_abs (enum machine_mode mode, rtx op0, rtx target,\n    is that we have a split register file, and leaving op0 in fp registers,\n    and not playing with subregs so much, will help the register allocator.  */\n \n-static rtx\n+rtx\n expand_copysign_absneg (enum machine_mode mode, rtx op0, rtx op1, rtx target,\n \t\t        int bitpos, bool op0_is_abs)\n {"}, {"sha": "613831a82496f48ee49a756856026bcf47b2d409", "filename": "gcc/optabs.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca58f2bc5c2ad8d30514c32e2e0b5283d0486a3c/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca58f2bc5c2ad8d30514c32e2e0b5283d0486a3c/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=ca58f2bc5c2ad8d30514c32e2e0b5283d0486a3c", "patch": "@@ -455,6 +455,7 @@ extern rtx expand_abs (enum machine_mode, rtx, rtx, int, int);\n \n /* Expand the copysign operation.  */\n extern rtx expand_copysign (rtx, rtx, rtx);\n+extern rtx expand_copysign_absneg (enum machine_mode, rtx, rtx, rtx, int, bool);\n \n /* Generate an instruction with a given INSN_CODE with an output and\n    an input.  */"}, {"sha": "ace5f5f5ce1bee7d936c670256ebc7375c350ee9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca58f2bc5c2ad8d30514c32e2e0b5283d0486a3c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca58f2bc5c2ad8d30514c32e2e0b5283d0486a3c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ca58f2bc5c2ad8d30514c32e2e0b5283d0486a3c", "patch": "@@ -1,3 +1,9 @@\n+2005-02-01  Richard Henderson  <rth@redhat.com>\n+\n+\t* gcc.c-torture/execute/ieee/copysign1.c: Special case sizeof\n+\tlong double for ibm double-double format.\n+\t* gcc.c-torture/execute/ieee/copysign2.c: Likewise.\n+\n 2005-02-01  Diego Novillo  <dnovillo@redhat.com>\n \n \tPR tree-optimization/19633"}, {"sha": "fa4097a748dceba2bad23e2af85d60d5bca4ace2", "filename": "gcc/testsuite/gcc.c-torture/execute/ieee/copysign1.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca58f2bc5c2ad8d30514c32e2e0b5283d0486a3c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Fcopysign1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca58f2bc5c2ad8d30514c32e2e0b5283d0486a3c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Fcopysign1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Fcopysign1.c?ref=ca58f2bc5c2ad8d30514c32e2e0b5283d0486a3c", "patch": "@@ -17,6 +17,19 @@\n # endif\n #endif\n \n+/* Work around the fact that the sign of the second double in the IBM\n+   double-double format is not strictly specified when it contains a zero.\n+   For instance, -0.0L can be represented with either (-0.0, +0.0) or\n+   (-0.0, -0.0).  The former is what we'll get from the compiler when it\n+   builds constants; the later is what we'll get from the negation operator\n+   at runtime.  */\n+/* ??? This hack only works for big-endian, which is fortunately true for\n+   all of AIX, Darwin, and Irix.  */\n+#if LDBL_MANT_DIG == 106\n+# undef fpsizeofl\n+# define fpsizeofl\tsizeof(double)\n+#endif\n+\n \n #define TEST(TYPE, EXT)\t\t\t\t\t\t\\\n TYPE c##EXT (TYPE x, TYPE y)\t\t\t\t\t\\"}, {"sha": "fac7ab3a530c6527ddc8c532d2e8086e36051554", "filename": "gcc/testsuite/gcc.c-torture/execute/ieee/copysign2.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca58f2bc5c2ad8d30514c32e2e0b5283d0486a3c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Fcopysign2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca58f2bc5c2ad8d30514c32e2e0b5283d0486a3c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Fcopysign2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Fcopysign2.c?ref=ca58f2bc5c2ad8d30514c32e2e0b5283d0486a3c", "patch": "@@ -17,6 +17,18 @@\n # endif\n #endif\n \n+/* Work around the fact that the sign of the second double in the IBM\n+   double-double format is not strictly specified when it contains a zero.\n+   For instance, -0.0L can be represented with either (-0.0, +0.0) or\n+   (-0.0, -0.0).  The former is what we'll get from the compiler when it\n+   builds constants; the later is what we'll get from the negation operator\n+   at runtime.  */\n+/* ??? This hack only works for big-endian, which is fortunately true for\n+   all of AIX, Darwin, and Irix.  */\n+#if LDBL_MANT_DIG == 106\n+# undef fpsizeofl\n+# define fpsizeofl\tsizeof(double)\n+#endif\n \n \n #define TEST(TYPE, EXT)\t\t\t\t\t\t\\"}]}