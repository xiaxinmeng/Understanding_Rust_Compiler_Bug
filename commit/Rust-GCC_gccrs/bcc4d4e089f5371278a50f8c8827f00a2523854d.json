{"sha": "bcc4d4e089f5371278a50f8c8827f00a2523854d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmNjNGQ0ZTA4OWY1MzcxMjc4YTUwZjhjODgyN2YwMGEyNTIzODU0ZA==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2011-11-03T21:55:48Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2011-11-03T21:55:48Z"}, "message": "trans.h (struct gfc_ss_info): New struct.\n\n\t* trans.h (struct gfc_ss_info): New struct.\n\t(gfc_get_ss_info): New macro.\n\t(struct gfc_ss): Move type field to struct gfc_ss_info.\n\tAdd an info field of type gfc_ss_info.\n\t* trans-array.c (free_ss_info): New function.\n\t(gfc_free_ss): Call free_ss_info.\n\t(gfc_get_array_ss, gfc_get_temp_ss, gfc_get_scalar_ss):\n\tAllocate gfc_ss_info field.\n\t(gfc_get_array_ss, gfc_get_temp_ss, gfc_get_scalar_ss,\n\tgfc_set_vector_loop_bounds, gfc_add_loop_ss_code,\n\tgfc_conv_array_index_offset, gfc_trans_preloop_setup,\n\tgfc_trans_scalarized_loop_boundary, gfc_conv_section_startstride,\n\tgfc_conv_ss_startstride, gfc_conv_resolve_dependencies,\n\tgfc_conv_loop_setup, transposed_dims, gfc_conv_expr_descriptor,\n\tgfc_walk_elemental_function_args): Update references to type.\n\t* trans-const.c (gfc_conv_constant): Factor common reference chains\n\tand update reference to type.\n\t* trans-expr.c (gfc_conv_procedure_call, gfc_trans_assignment_1):\n\tUpdate reference to type.\n\t(gfc_conv_array_constructor_expr, gfc_conv_expr,\n\tgfc_conv_expr_reference): Ditto. Factor common reference chains.\n\t* trans-intrinsic.c (walk_inline_intrinsic_transpose): Update references\n\tto type\n\t* trans-stmt.c (gfc_trans_where_assign): Ditto.\n\nFrom-SVN: r180867", "tree": {"sha": "ff589a308dabd6bbe950810923c3d1652734af73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff589a308dabd6bbe950810923c3d1652734af73"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bcc4d4e089f5371278a50f8c8827f00a2523854d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcc4d4e089f5371278a50f8c8827f00a2523854d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bcc4d4e089f5371278a50f8c8827f00a2523854d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcc4d4e089f5371278a50f8c8827f00a2523854d/comments", "author": null, "committer": null, "parents": [{"sha": "08dcec6137f763fee843acaca52cd9ac53312eee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08dcec6137f763fee843acaca52cd9ac53312eee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08dcec6137f763fee843acaca52cd9ac53312eee"}], "stats": {"total": 194, "additions": 141, "deletions": 53}, "files": [{"sha": "958cc7a22d3b84190bc110024b4b30d41280a3ad", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc4d4e089f5371278a50f8c8827f00a2523854d/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc4d4e089f5371278a50f8c8827f00a2523854d/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=bcc4d4e089f5371278a50f8c8827f00a2523854d", "patch": "@@ -1,3 +1,30 @@\n+2011-11-03  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\t* trans.h (struct gfc_ss_info): New struct.\n+\t(gfc_get_ss_info): New macro.\n+\t(struct gfc_ss): Move type field to struct gfc_ss_info.\n+\tAdd an info field of type gfc_ss_info.\n+\t* trans-array.c (free_ss_info): New function.\n+\t(gfc_free_ss): Call free_ss_info.\n+\t(gfc_get_array_ss, gfc_get_temp_ss, gfc_get_scalar_ss):\n+\tAllocate gfc_ss_info field.\n+\t(gfc_get_array_ss, gfc_get_temp_ss, gfc_get_scalar_ss,\n+\tgfc_set_vector_loop_bounds, gfc_add_loop_ss_code,\n+\tgfc_conv_array_index_offset, gfc_trans_preloop_setup,\n+\tgfc_trans_scalarized_loop_boundary, gfc_conv_section_startstride,\n+\tgfc_conv_ss_startstride, gfc_conv_resolve_dependencies,\n+\tgfc_conv_loop_setup, transposed_dims, gfc_conv_expr_descriptor,\n+\tgfc_walk_elemental_function_args): Update references to type.\n+\t* trans-const.c (gfc_conv_constant): Factor common reference chains\n+\tand update reference to type.\n+\t* trans-expr.c (gfc_conv_procedure_call, gfc_trans_assignment_1):\n+\tUpdate reference to type.\n+\t(gfc_conv_array_constructor_expr, gfc_conv_expr,\n+\tgfc_conv_expr_reference): Ditto. Factor common reference chains.\n+\t* trans-intrinsic.c (walk_inline_intrinsic_transpose): Update references\n+\tto type\n+\t* trans-stmt.c (gfc_trans_where_assign): Ditto.\n+\n 2011-11-03  Mikael Morin  <mikael@gcc.gnu.org>\n \n \t* trans.h (struct gfc_ss, struct gfc_array_info): Move shape field"}, {"sha": "80dadf4c4dbf56fa831e3ebebb36975c09c92928", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 76, "deletions": 37, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc4d4e089f5371278a50f8c8827f00a2523854d/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc4d4e089f5371278a50f8c8827f00a2523854d/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=bcc4d4e089f5371278a50f8c8827f00a2523854d", "patch": "@@ -486,14 +486,24 @@ gfc_free_ss_chain (gfc_ss * ss)\n }\n \n \n+static void\n+free_ss_info (gfc_ss_info *ss_info)\n+{\n+  free (ss_info);\n+}\n+\n+\n /* Free a SS.  */\n \n static void\n gfc_free_ss (gfc_ss * ss)\n {\n+  gfc_ss_info *ss_info;\n   int n;\n \n-  switch (ss->type)\n+  ss_info = ss->info;\n+\n+  switch (ss_info->type)\n     {\n     case GFC_SS_SECTION:\n       for (n = 0; n < ss->dimen; n++)\n@@ -507,6 +517,7 @@ gfc_free_ss (gfc_ss * ss)\n       break;\n     }\n \n+  free_ss_info (ss_info);\n   free (ss);\n }\n \n@@ -517,11 +528,15 @@ gfc_ss *\n gfc_get_array_ss (gfc_ss *next, gfc_expr *expr, int dimen, gfc_ss_type type)\n {\n   gfc_ss *ss;\n+  gfc_ss_info *ss_info;\n   int i;\n \n+  ss_info = gfc_get_ss_info ();\n+  ss_info->type = type;\n+\n   ss = gfc_get_ss ();\n+  ss->info = ss_info;\n   ss->next = next;\n-  ss->type = type;\n   ss->expr = expr;\n   ss->dimen = dimen;\n   for (i = 0; i < ss->dimen; i++)\n@@ -537,11 +552,15 @@ gfc_ss *\n gfc_get_temp_ss (tree type, tree string_length, int dimen)\n {\n   gfc_ss *ss;\n+  gfc_ss_info *ss_info;\n   int i;\n \n+  ss_info = gfc_get_ss_info ();\n+  ss_info->type = GFC_SS_TEMP;\n+\n   ss = gfc_get_ss ();\n+  ss->info = ss_info;\n   ss->next = gfc_ss_terminator;\n-  ss->type = GFC_SS_TEMP;\n   ss->string_length = string_length;\n   ss->data.temp.type = type;\n   ss->dimen = dimen;\n@@ -558,10 +577,14 @@ gfc_ss *\n gfc_get_scalar_ss (gfc_ss *next, gfc_expr *expr)\n {\n   gfc_ss *ss;\n+  gfc_ss_info *ss_info;\n+\n+  ss_info = gfc_get_ss_info ();\n+  ss_info->type = GFC_SS_SCALAR;\n \n   ss = gfc_get_ss ();\n+  ss->info = ss_info;\n   ss->next = next;\n-  ss->type = GFC_SS_SCALAR;\n   ss->expr = expr;\n \n   return ss;\n@@ -2118,7 +2141,7 @@ set_vector_loop_bounds (gfc_loopinfo * loop, gfc_ss * ss)\n \t     difference between the vector's upper and lower bounds.  */\n \t  gcc_assert (loop->from[n] == gfc_index_zero_node);\n \t  gcc_assert (info->subscript[dim]\n-\t\t      && info->subscript[dim]->type == GFC_SS_VECTOR);\n+\t\t      && info->subscript[dim]->info->type == GFC_SS_VECTOR);\n \n \t  gfc_init_se (&se, NULL);\n \t  desc = info->subscript[dim]->data.info.descriptor;\n@@ -2153,7 +2176,7 @@ gfc_add_loop_ss_code (gfc_loopinfo * loop, gfc_ss * ss, bool subscript,\n     {\n       gcc_assert (ss);\n \n-      switch (ss->type)\n+      switch (ss->info->type)\n \t{\n \tcase GFC_SS_SCALAR:\n \t  /* Scalar expression.  Evaluate this now.  This includes elemental\n@@ -2533,7 +2556,7 @@ conv_array_index_offset (gfc_se * se, gfc_ss * ss, int dim, int i,\n \tcase DIMEN_ELEMENT:\n \t  /* Elemental dimension.  */\n \t  gcc_assert (info->subscript[dim]\n-\t\t      && info->subscript[dim]->type == GFC_SS_SCALAR);\n+\t\t      && info->subscript[dim]->info->type == GFC_SS_SCALAR);\n \t  /* We've already translated this value outside the loop.  */\n \t  index = info->subscript[dim]->data.scalar.expr;\n \n@@ -2545,7 +2568,7 @@ conv_array_index_offset (gfc_se * se, gfc_ss * ss, int dim, int i,\n \tcase DIMEN_VECTOR:\n \t  gcc_assert (info && se->loop);\n \t  gcc_assert (info->subscript[dim]\n-\t\t      && info->subscript[dim]->type == GFC_SS_VECTOR);\n+\t\t      && info->subscript[dim]->info->type == GFC_SS_VECTOR);\n \t  desc = info->subscript[dim]->data.info.descriptor;\n \n \t  /* Get a zero-based index into the vector.  */\n@@ -2600,7 +2623,7 @@ conv_array_index_offset (gfc_se * se, gfc_ss * ss, int dim, int i,\n       /* Pointer functions can have stride[0] different from unity. \n \t Use the stride returned by the function call and stored in\n \t the descriptor for the temporary.  */ \n-      if (se->ss && se->ss->type == GFC_SS_FUNCTION\n+      if (se->ss && se->ss->info->type == GFC_SS_FUNCTION\n \t    && se->ss->expr\n \t    && se->ss->expr->symtree\n \t    && se->ss->expr->symtree->n.sym->result\n@@ -2854,6 +2877,7 @@ gfc_trans_preloop_setup (gfc_loopinfo * loop, int dim, int flag,\n {\n   tree stride;\n   gfc_array_info *info;\n+  gfc_ss_type ss_type;\n   gfc_ss *ss;\n   gfc_array_ref *ar;\n   int i;\n@@ -2865,9 +2889,11 @@ gfc_trans_preloop_setup (gfc_loopinfo * loop, int dim, int flag,\n       if ((ss->useflags & flag) == 0)\n \tcontinue;\n \n-      if (ss->type != GFC_SS_SECTION\n-\t  && ss->type != GFC_SS_FUNCTION && ss->type != GFC_SS_CONSTRUCTOR\n-\t  && ss->type != GFC_SS_COMPONENT)\n+      ss_type = ss->info->type;\n+      if (ss_type != GFC_SS_SECTION\n+\t  && ss_type != GFC_SS_FUNCTION\n+\t  && ss_type != GFC_SS_CONSTRUCTOR\n+\t  && ss_type != GFC_SS_COMPONENT)\n \tcontinue;\n \n       info = &ss->data.info;\n@@ -3134,12 +3160,16 @@ gfc_trans_scalarized_loop_boundary (gfc_loopinfo * loop, stmtblock_t * body)\n   /* Restore the initial offsets.  */\n   for (ss = loop->ss; ss != gfc_ss_terminator; ss = ss->loop_chain)\n     {\n+      gfc_ss_type ss_type;\n+\n       if ((ss->useflags & 2) == 0)\n \tcontinue;\n \n-      if (ss->type != GFC_SS_SECTION\n-\t  && ss->type != GFC_SS_FUNCTION && ss->type != GFC_SS_CONSTRUCTOR\n-\t  && ss->type != GFC_SS_COMPONENT)\n+      ss_type = ss->info->type;\n+      if (ss_type != GFC_SS_SECTION\n+\t  && ss_type != GFC_SS_FUNCTION\n+\t  && ss_type != GFC_SS_CONSTRUCTOR\n+\t  && ss_type != GFC_SS_COMPONENT)\n \tcontinue;\n \n       ss->data.info.offset = ss->data.info.saved_offset;\n@@ -3207,7 +3237,7 @@ gfc_conv_section_startstride (gfc_loopinfo * loop, gfc_ss * ss, int dim)\n   gfc_array_info *info;\n   gfc_array_ref *ar;\n \n-  gcc_assert (ss->type == GFC_SS_SECTION);\n+  gcc_assert (ss->info->type == GFC_SS_SECTION);\n \n   info = &ss->data.info;\n   ar = &info->ref->u.ar;\n@@ -3264,7 +3294,7 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n   /* Determine the rank of the loop.  */\n   for (ss = loop->ss; ss != gfc_ss_terminator; ss = ss->loop_chain)\n     {\n-      switch (ss->type)\n+      switch (ss->info->type)\n \t{\n \tcase GFC_SS_SECTION:\n \tcase GFC_SS_CONSTRUCTOR:\n@@ -3309,7 +3339,7 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n       if (ss->expr && ss->expr->shape && !info->shape)\n \tinfo->shape = ss->expr->shape;\n \n-      switch (ss->type)\n+      switch (ss->info->type)\n \t{\n \tcase GFC_SS_SECTION:\n \t  /* Get the descriptor for the array.  */\n@@ -3372,7 +3402,7 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t{\n \t  stmtblock_t inner;\n \n-\t  if (ss->type != GFC_SS_SECTION)\n+\t  if (ss->info->type != GFC_SS_SECTION)\n \t    continue;\n \n \t  /* Catch allocatable lhs in f2003.  */\n@@ -3757,7 +3787,7 @@ gfc_conv_resolve_dependencies (gfc_loopinfo * loop, gfc_ss * dest,\n \n   for (ss = rss; ss != gfc_ss_terminator; ss = ss->next)\n     {\n-      if (ss->type != GFC_SS_SECTION)\n+      if (ss->info->type != GFC_SS_SECTION)\n \tcontinue;\n \n       if (dest->expr->symtree->n.sym != ss->expr->symtree->n.sym)\n@@ -3874,7 +3904,7 @@ gfc_conv_loop_setup (gfc_loopinfo * loop, locus * where)\n \t{\n \t  gfc_ss_type ss_type;\n \n-\t  ss_type = ss->type;\n+\t  ss_type = ss->info->type;\n \t  if (ss_type == GFC_SS_SCALAR\n \t      || ss_type == GFC_SS_TEMP\n \t      || ss_type == GFC_SS_REFERENCE)\n@@ -3907,7 +3937,7 @@ gfc_conv_loop_setup (gfc_loopinfo * loop, locus * where)\n \t      continue;\n \t    }\n \n-\t  if (ss->type == GFC_SS_CONSTRUCTOR)\n+\t  if (ss_type == GFC_SS_CONSTRUCTOR)\n \t    {\n \t      gfc_constructor_base base;\n \t      /* An unknown size constructor will always be rank one.\n@@ -3928,7 +3958,7 @@ gfc_conv_loop_setup (gfc_loopinfo * loop, locus * where)\n \n \t  /* TODO: Pick the best bound if we have a choice between a\n \t     function and something else.  */\n-\t  if (ss->type == GFC_SS_FUNCTION)\n+\t  if (ss_type == GFC_SS_FUNCTION)\n \t    {\n \t      loopspec[n] = ss;\n \t      continue;\n@@ -3939,7 +3969,7 @@ gfc_conv_loop_setup (gfc_loopinfo * loop, locus * where)\n \t  if (loopspec[n] && ss->is_alloc_lhs)\n \t    continue;\n \n-\t  if (ss->type != GFC_SS_SECTION)\n+\t  if (ss_type != GFC_SS_SECTION)\n \t    continue;\n \n \t  if (!loopspec[n])\n@@ -3951,7 +3981,7 @@ gfc_conv_loop_setup (gfc_loopinfo * loop, locus * where)\n \t     known lower bound\n \t     known upper bound\n \t   */\n-\t  else if ((loopspec[n]->type == GFC_SS_CONSTRUCTOR && dynamic[n])\n+\t  else if ((loopspec[n]->info->type == GFC_SS_CONSTRUCTOR && dynamic[n])\n \t\t   || n >= loop->dimen)\n \t    loopspec[n] = ss;\n \t  else if (integer_onep (info->stride[dim])\n@@ -3997,7 +4027,7 @@ gfc_conv_loop_setup (gfc_loopinfo * loop, locus * where)\n       else\n \t{\n \t  loop->from[n] = info->start[dim];\n-\t  switch (loopspec[n]->type)\n+\t  switch (loopspec[n]->info->type)\n \t    {\n \t    case GFC_SS_CONSTRUCTOR:\n \t      /* The upper bound is calculated when we expand the\n@@ -4054,7 +4084,10 @@ gfc_conv_loop_setup (gfc_loopinfo * loop, locus * where)\n   /* If we want a temporary then create it.  */\n   if (tmp_ss != NULL)\n     {\n-      gcc_assert (loop->temp_ss->type == GFC_SS_TEMP);\n+      gfc_ss_info *tmp_ss_info;\n+\n+      tmp_ss_info = tmp_ss->info;\n+      gcc_assert (tmp_ss_info->type == GFC_SS_TEMP);\n \n       /* Make absolutely sure that this is a complete type.  */\n       if (loop->temp_ss->string_length)\n@@ -4065,7 +4098,7 @@ gfc_conv_loop_setup (gfc_loopinfo * loop, locus * where)\n \n       tmp = loop->temp_ss->data.temp.type;\n       memset (&loop->temp_ss->data.info, 0, sizeof (gfc_array_info));\n-      loop->temp_ss->type = GFC_SS_SECTION;\n+      tmp_ss_info->type = GFC_SS_SECTION;\n \n       gcc_assert (tmp_ss->dimen != 0);\n \n@@ -4087,9 +4120,12 @@ gfc_conv_loop_setup (gfc_loopinfo * loop, locus * where)\n   /* Calculate the translation from loop variables to array indices.  */\n   for (ss = loop->ss; ss != gfc_ss_terminator; ss = ss->loop_chain)\n     {\n-      if (ss->type != GFC_SS_SECTION && ss->type != GFC_SS_COMPONENT\n-\t    && ss->type != GFC_SS_CONSTRUCTOR)\n+      gfc_ss_type ss_type;\n \n+      ss_type = ss->info->type;\n+      if (ss_type != GFC_SS_SECTION\n+\t  && ss_type != GFC_SS_COMPONENT\n+\t  && ss_type != GFC_SS_CONSTRUCTOR)\n \tcontinue;\n \n       info = &ss->data.info;\n@@ -5702,6 +5738,7 @@ transposed_dims (gfc_ss *ss)\n void\n gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n {\n+  gfc_ss_type ss_type;\n   gfc_loopinfo loop;\n   gfc_array_info *info;\n   int need_tmp;\n@@ -5718,14 +5755,16 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n   gcc_assert (ss != NULL);\n   gcc_assert (ss != gfc_ss_terminator);\n \n+  ss_type = ss->info->type;\n+\n   /* Special case things we know we can pass easily.  */\n   switch (expr->expr_type)\n     {\n     case EXPR_VARIABLE:\n       /* If we have a linear array section, we can pass it directly.\n \t Otherwise we need to copy it into a temporary.  */\n \n-      gcc_assert (ss->type == GFC_SS_SECTION);\n+      gcc_assert (ss_type == GFC_SS_SECTION);\n       gcc_assert (ss->expr == expr);\n       info = &ss->data.info;\n \n@@ -5804,7 +5843,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \n       if (se->direct_byref)\n \t{\n-\t  gcc_assert (ss->type == GFC_SS_FUNCTION && ss->expr == expr);\n+\t  gcc_assert (ss_type == GFC_SS_FUNCTION && ss->expr == expr);\n \n \t  /* For pointer assignments pass the descriptor directly.  */\n \t  if (se->ss == NULL)\n@@ -5816,7 +5855,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t  return;\n \t}\n \n-      if (ss->expr != expr || ss->type != GFC_SS_FUNCTION)\n+      if (ss->expr != expr || ss_type != GFC_SS_FUNCTION)\n \t{\n \t  if (ss->expr != expr)\n \t    /* Elemental function.  */\n@@ -5825,7 +5864,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t\t\t|| (expr->value.function.isym != NULL\n \t\t\t    && expr->value.function.isym->elemental));\n \t  else\n-\t    gcc_assert (ss->type == GFC_SS_INTRINSIC);\n+\t    gcc_assert (ss_type == GFC_SS_INTRINSIC);\n \n \t  need_tmp = 1;\n \t  if (expr->ts.type == BT_CHARACTER\n@@ -5844,7 +5883,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \n     case EXPR_ARRAY:\n       /* Constant array constructors don't need a temporary.  */\n-      if (ss->type == GFC_SS_CONSTRUCTOR\n+      if (ss_type == GFC_SS_CONSTRUCTOR\n \t  && expr->ts.type != BT_CHARACTER\n \t  && gfc_constant_array_constructor_p (expr->value.constructor))\n \t{\n@@ -6055,7 +6094,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t      && info->ref->u.ar.dimen_type[n] == DIMEN_ELEMENT)\n \t    {\n \t      gcc_assert (info->subscript[n]\n-\t\t      && info->subscript[n]->type == GFC_SS_SCALAR);\n+\t\t\t  && info->subscript[n]->info->type == GFC_SS_SCALAR);\n \t      start = info->subscript[n]->data.scalar.expr;\n \t    }\n \t  else\n@@ -7811,7 +7850,7 @@ gfc_walk_elemental_function_args (gfc_ss * ss, gfc_actual_arglist *arg,\n \t  /* Scalar argument.  */\n \t  gcc_assert (type == GFC_SS_SCALAR || type == GFC_SS_REFERENCE);\n \t  newss = gfc_get_scalar_ss (head, arg->expr);\n-\t  newss->type = type;\n+\t  newss->info->type = type;\n \t}\n       else\n \tscalar = 0;"}, {"sha": "84a833910975850b526eebdb9a5bb9768adec0fb", "filename": "gcc/fortran/trans-const.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc4d4e089f5371278a50f8c8827f00a2523854d/gcc%2Ffortran%2Ftrans-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc4d4e089f5371278a50f8c8827f00a2523854d/gcc%2Ffortran%2Ftrans-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-const.c?ref=bcc4d4e089f5371278a50f8c8827f00a2523854d", "patch": "@@ -358,6 +358,8 @@ gfc_conv_constant_to_tree (gfc_expr * expr)\n void\n gfc_conv_constant (gfc_se * se, gfc_expr * expr)\n {\n+  gfc_ss *ss;\n+\n   /* We may be receiving an expression for C_NULL_PTR or C_NULL_FUNPTR.  If\n      so, the expr_type will not yet be an EXPR_CONSTANT.  We need to make\n      it so here.  */\n@@ -380,10 +382,11 @@ gfc_conv_constant (gfc_se * se, gfc_expr * expr)\n       return;\n     }\n \n-  if (se->ss != NULL)\n+  ss = se->ss;\n+  if (ss != NULL)\n     {\n-      gcc_assert (se->ss != gfc_ss_terminator);\n-      gcc_assert (se->ss->type == GFC_SS_SCALAR);\n+      gcc_assert (ss != gfc_ss_terminator);\n+      gcc_assert (ss->info->type == GFC_SS_SCALAR);\n       gcc_assert (se->ss->expr == expr);\n \n       se->expr = se->ss->data.scalar.expr;"}, {"sha": "5a946154818d3a5b387a92d15f1fced0c9068308", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc4d4e089f5371278a50f8c8827f00a2523854d/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc4d4e089f5371278a50f8c8827f00a2523854d/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=bcc4d4e089f5371278a50f8c8827f00a2523854d", "patch": "@@ -2893,7 +2893,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n     {\n       if (!sym->attr.elemental)\n \t{\n-\t  gcc_assert (se->ss->type == GFC_SS_FUNCTION);\n+\t  gcc_assert (se->ss->info->type == GFC_SS_FUNCTION);\n \t  if (se->ss->useflags)\n \t    {\n \t      gcc_assert ((!comp && gfc_return_by_reference (sym)\n@@ -4239,8 +4239,11 @@ is_zero_initializer_p (gfc_expr * expr)\n static void\n gfc_conv_array_constructor_expr (gfc_se * se, gfc_expr * expr)\n {\n-  gcc_assert (se->ss != NULL && se->ss != gfc_ss_terminator);\n-  gcc_assert (se->ss->expr == expr && se->ss->type == GFC_SS_CONSTRUCTOR);\n+  gfc_ss *ss;\n+\n+  ss = se->ss;\n+  gcc_assert (ss != NULL && ss != gfc_ss_terminator);\n+  gcc_assert (ss->expr == expr && ss->info->type == GFC_SS_CONSTRUCTOR);\n \n   gfc_conv_tmp_array_ref (se);\n }\n@@ -4821,13 +4824,17 @@ gfc_conv_substring_expr (gfc_se * se, gfc_expr * expr)\n void\n gfc_conv_expr (gfc_se * se, gfc_expr * expr)\n {\n-  if (se->ss && se->ss->expr == expr\n-      && (se->ss->type == GFC_SS_SCALAR || se->ss->type == GFC_SS_REFERENCE))\n+  gfc_ss *ss;\n+\n+  ss = se->ss;\n+  if (ss && ss->expr == expr\n+      && (ss->info->type == GFC_SS_SCALAR\n+\t  || ss->info->type == GFC_SS_REFERENCE))\n     {\n       /* Substitute a scalar expression evaluated outside the scalarization\n          loop.  */\n       se->expr = se->ss->data.scalar.expr;\n-      if (se->ss->type == GFC_SS_REFERENCE)\n+      if (ss->info->type == GFC_SS_REFERENCE)\n \tse->expr = gfc_build_addr_expr (NULL_TREE, se->expr);\n       se->string_length = se->ss->string_length;\n       gfc_advance_se_ss_chain (se);\n@@ -4946,10 +4953,12 @@ gfc_conv_expr_type (gfc_se * se, gfc_expr * expr, tree type)\n void\n gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr)\n {\n+  gfc_ss *ss;\n   tree var;\n \n-  if (se->ss && se->ss->expr == expr\n-      && se->ss->type == GFC_SS_REFERENCE)\n+  ss = se->ss;\n+  if (ss && ss->expr == expr\n+      && ss->info->type == GFC_SS_REFERENCE)\n     {\n       /* Returns a reference to the scalar evaluated outside the loop\n \t for this case.  */\n@@ -6154,7 +6163,7 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n \n       /* Find a non-scalar SS from the lhs.  */\n       while (lss_section != gfc_ss_terminator\n-\t     && lss_section->type != GFC_SS_SECTION)\n+\t     && lss_section->info->type != GFC_SS_SECTION)\n \tlss_section = lss_section->next;\n \n       gcc_assert (lss_section != gfc_ss_terminator);"}, {"sha": "dff16dc7af3343d27dfaf705804bdba908826311", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc4d4e089f5371278a50f8c8827f00a2523854d/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc4d4e089f5371278a50f8c8827f00a2523854d/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=bcc4d4e089f5371278a50f8c8827f00a2523854d", "patch": "@@ -6753,8 +6753,8 @@ walk_inline_intrinsic_transpose (gfc_ss *ss, gfc_expr *expr)\n \n   for (tmp_ss = arg_ss; ; tmp_ss = tmp_ss->next)\n     {\n-      if (tmp_ss->type != GFC_SS_SCALAR\n-\t  && tmp_ss->type != GFC_SS_REFERENCE)\n+      if (tmp_ss->info->type != GFC_SS_SCALAR\n+\t  && tmp_ss->info->type != GFC_SS_REFERENCE)\n \t{\n \t  int tmp_dim;\n "}, {"sha": "c89419a97284f53ca0fce8230337cbed2c4053e3", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc4d4e089f5371278a50f8c8827f00a2523854d/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc4d4e089f5371278a50f8c8827f00a2523854d/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=bcc4d4e089f5371278a50f8c8827f00a2523854d", "patch": "@@ -4048,7 +4048,7 @@ gfc_trans_where_assign (gfc_expr *expr1, gfc_expr *expr2,\n \n   /* Find a non-scalar SS from the lhs.  */\n   while (lss_section != gfc_ss_terminator\n-         && lss_section->type != GFC_SS_SECTION)\n+\t && lss_section->info->type != GFC_SS_SECTION)\n     lss_section = lss_section->next;\n \n   gcc_assert (lss_section != gfc_ss_terminator);"}, {"sha": "13d4c580e9a9b393a1ef105be30ac432cff18607", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc4d4e089f5371278a50f8c8827f00a2523854d/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc4d4e089f5371278a50f8c8827f00a2523854d/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=bcc4d4e089f5371278a50f8c8827f00a2523854d", "patch": "@@ -183,6 +183,15 @@ typedef enum\n gfc_ss_type;\n \n \n+typedef struct gfc_ss_info\n+{\n+  gfc_ss_type type;\n+}\n+gfc_ss_info;\n+\n+#define gfc_get_ss_info() XCNEW (gfc_ss_info)\n+\n+\n /* Scalarization State chain.  Created by walking an expression tree before\n    creating the scalarization loops.  Then passed as part of a gfc_se structure\n    to translate the expression inside the loop.  Note that these chains are\n@@ -193,7 +202,8 @@ gfc_ss_type;\n \n typedef struct gfc_ss\n {\n-  gfc_ss_type type;\n+  gfc_ss_info *info;\n+\n   gfc_expr *expr;\n   tree string_length;\n   union"}]}