{"sha": "edaf97c444037ec44ed25543d5909e10589d7e7c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWRhZjk3YzQ0NDAzN2VjNDRlZDI1NTQzZDU5MDllMTA1ODlkN2U3Yw==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-01-20T01:13:48Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-01-20T01:13:48Z"}, "message": "(sched_analyze_1...\n\n(sched_analyze_1, sched_analyze_2): Ifdef out code added\nfor handling psuedo register equivalents that was added Dec 31 1992.\n\nFrom-SVN: r3290", "tree": {"sha": "ff7968ec9bda75028a592175e30e5d7969d32df4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff7968ec9bda75028a592175e30e5d7969d32df4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/edaf97c444037ec44ed25543d5909e10589d7e7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edaf97c444037ec44ed25543d5909e10589d7e7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/edaf97c444037ec44ed25543d5909e10589d7e7c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edaf97c444037ec44ed25543d5909e10589d7e7c/comments", "author": null, "committer": null, "parents": [{"sha": "c6ad27a7f35f4c2c4431fee9f0648989854c79ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6ad27a7f35f4c2c4431fee9f0648989854c79ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6ad27a7f35f4c2c4431fee9f0648989854c79ec"}], "stats": {"total": 22, "additions": 22, "deletions": 0}, "files": [{"sha": "5483fc8375a66d81eaa2de9aece17874c7262b02", "filename": "gcc/sched.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edaf97c444037ec44ed25543d5909e10589d7e7c/gcc%2Fsched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edaf97c444037ec44ed25543d5909e10589d7e7c/gcc%2Fsched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched.c?ref=edaf97c444037ec44ed25543d5909e10589d7e7c", "patch": "@@ -1610,13 +1610,24 @@ sched_analyze_1 (x, insn)\n \t    add_dependence (insn, reg_last_sets[regno], REG_DEP_OUTPUT);\n \t  reg_last_sets[regno] = insn;\n \n+#if 0\n+\t  /* ??? This code has two serious problems:\n+\t     1) It can cause an infinite loop if regno is mentioned in\n+\t        its reg_known_value.\n+\t     2) It can cause execution time exponential in the size of the\n+\t        input if there are long chains of reg_known_values pointing\n+\t\tto other reg_known_values.\n+\t     This code was specifically added to handle fake argument pointers.\n+\t     It may need to be rewritten to just handle that specific case.  */\n+\n \t  /* Pseudos that are REG_EQUIV to something may be replaced\n \t     by that during reloading, so we can potentially read\n \t     quantities mentioned in those addresses. */\n \t  if (! reload_completed)\n \t    if (reg_known_value[regno] != regno_reg_rtx[regno])\n \t      if (GET_CODE (reg_known_value[regno]) == MEM)\n \t\tsched_analyze_2 (XEXP (reg_known_value[regno], 0), insn);\n+#endif\n \n \t  /* Don't let it cross a call after scheduling if it doesn't\n \t     already cross one.  */\n@@ -1770,11 +1781,22 @@ sched_analyze_2 (x, insn)\n \t    if (reg_last_sets[regno])\n \t      add_dependence (insn, reg_last_sets[regno], 0);\n \n+#if 0\n+\t  /* ??? This code has two serious problems:\n+\t     1) It can cause an infinite loop if regno is mentioned in\n+\t        its reg_known_value.\n+\t     2) It can cause execution time exponential in the size of the\n+\t        input if there are long chains of reg_known_values pointing\n+\t\tto other reg_known_values.\n+\t     This code was specifically added to handle fake argument pointers.\n+\t     It may need to be rewritten to just handle that specific case.  */\n+\n \t    /* Pseudos that are REG_EQUIV to something may be replaced\n \t       by that, so we depend on anything mentioned there too. */\n \t    if (! reload_completed)\n \t      if (reg_known_value[regno] != regno_reg_rtx[regno])\n \t\tsched_analyze_2 (reg_known_value[regno], insn);\n+#endif\n \n \t    /* If the register does not already cross any calls, then add this\n \t       insn to the sched_before_next_call list so that it will still"}]}