{"sha": "ac55736a0a271f62a2ed018a8d34039d6f458f60", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWM1NTczNmEwYTI3MWY2MmEyZWQwMThhOGQzNDAzOWQ2ZjQ1OGY2MA==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "joern.rennecke@superh.com", "date": "2003-04-08T17:31:24Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2003-04-08T17:31:24Z"}, "message": "sh.h (NORMAL_MODE): If interrupt handler and TARGET_FMOVD, this is FP_MODE_DOUBLE .\n\n\t* sh.h (NORMAL_MODE): If interrupt handler and TARGET_FMOVD,\n\tthis is FP_MODE_DOUBLE .\n\t* sh.c (ra.h): #include.\n\t(push_regs): Add second parameter.  Changed all callers.\n\tIf necessary, set fpscr before saving floating point registers.\n\t(calc_live_regs): If interrupt handler and TARGET_FMOVD, always\n\tdo saves / restores with SZ == 1.\n\t(sh_expand_prologue): If interrupt handler, don't use gen_toggle_sz.\n\t(sh_expand_epilogue): Likewise.  For TARGET_FMOVD, if floating point\n\tregisters are being restored, restore FPSCR only after restoring them.\n\nFrom-SVN: r65379", "tree": {"sha": "add95cedb7af8f7a17f8f508b45eb61409595cf9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/add95cedb7af8f7a17f8f508b45eb61409595cf9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac55736a0a271f62a2ed018a8d34039d6f458f60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac55736a0a271f62a2ed018a8d34039d6f458f60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac55736a0a271f62a2ed018a8d34039d6f458f60", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac55736a0a271f62a2ed018a8d34039d6f458f60/comments", "author": null, "committer": null, "parents": [{"sha": "f4f2b07a863686ad449b4959c880325a0ebc0dcf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4f2b07a863686ad449b4959c880325a0ebc0dcf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4f2b07a863686ad449b4959c880325a0ebc0dcf"}], "stats": {"total": 68, "additions": 56, "deletions": 12}, "files": [{"sha": "9d48969342f6aca9bb984bb21277180ba8aca3ce", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac55736a0a271f62a2ed018a8d34039d6f458f60/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac55736a0a271f62a2ed018a8d34039d6f458f60/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ac55736a0a271f62a2ed018a8d34039d6f458f60", "patch": "@@ -1,3 +1,16 @@\n+2003-04-08  J\"orn Rennecke <joern.rennecke@superh.com>\n+\n+\t* sh.h (NORMAL_MODE): If interrupt handler and TARGET_FMOVD,\n+\tthis is FP_MODE_DOUBLE .\n+\t* sh.c (ra.h): #include.\n+\t(push_regs): Add second parameter.  Changed all callers.\n+\tIf necessary, set fpscr before saving floating point registers.\n+\t(calc_live_regs): If interrupt handler and TARGET_FMOVD, always\n+\tdo saves / restores with SZ == 1.\n+\t(sh_expand_prologue): If interrupt handler, don't use gen_toggle_sz.\n+\t(sh_expand_epilogue): Likewise.  For TARGET_FMOVD, if floating point\n+\tregisters are being restored, restore FPSCR only after restoring them.\n+\n 2003-04-08  Aldy Hernandez  <aldyh@redhat.com>\n \n         * config/rs6000/rs6000.c (rs6000_init_builtins): Set opaque types"}, {"sha": "6cad65136eba7e80bf2d5cc81fd5edac95ca79de", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 41, "deletions": 11, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac55736a0a271f62a2ed018a8d34039d6f458f60/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac55736a0a271f62a2ed018a8d34039d6f458f60/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=ac55736a0a271f62a2ed018a8d34039d6f458f60", "patch": "@@ -46,6 +46,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"real.h\"\n #include \"langhooks.h\"\n #include \"basic-block.h\"\n+#include \"ra.h\"\n \n int code_for_indirect_jump_scratch = CODE_FOR_indirect_jump_scratch;\n \n@@ -189,7 +190,7 @@ static void output_stack_adjust PARAMS ((int, rtx, int, rtx (*) (rtx)));\n static rtx frame_insn PARAMS ((rtx));\n static rtx push PARAMS ((int));\n static void pop PARAMS ((int));\n-static void push_regs PARAMS ((HARD_REG_SET *));\n+static void push_regs PARAMS ((HARD_REG_SET *, int));\n static int calc_live_regs PARAMS ((HARD_REG_SET *));\n static void mark_use PARAMS ((rtx, rtx *));\n static HOST_WIDE_INT rounded_frame_size PARAMS ((int));\n@@ -4658,17 +4659,36 @@ pop (rn)\n /* Generate code to push the regs specified in the mask.  */\n \n static void\n-push_regs (mask)\n+push_regs (mask, interrupt_handler)\n      HARD_REG_SET *mask;\n+     int interrupt_handler;\n {\n   int i;\n+  int skip_fpscr = 0;\n \n   /* Push PR last; this gives better latencies after the prologue, and\n      candidates for the return delay slot when there are no general\n      registers pushed.  */\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    if (i != PR_REG && TEST_HARD_REG_BIT (*mask, i))\n-      push (i);\n+    {\n+      /* If this is an interrupt handler, and the SZ bit varies,\n+\t and we have to push any floating point register, we need\n+\t to switch to the correct precision first.  */\n+      if (i == FIRST_FP_REG && interrupt_handler && TARGET_FMOVD\n+\t  && hard_regs_intersect_p (mask, &reg_class_contents[DF_REGS]))\n+\t{\n+\t  HARD_REG_SET unsaved;\n+\n+\t  push (FPSCR_REG);\n+\t  COMPL_HARD_REG_SET(unsaved, *mask);\n+\t  fpscr_set_from_mem (NORMAL_MODE (FP_MODE), unsaved);\n+\t  skip_fpscr = 1;\n+\t}\n+      if (i != PR_REG\n+\t  && (i != FPSCR_REG || ! skip_fpscr)\n+\t  && TEST_HARD_REG_BIT (*mask, i))\n+\tpush (i);\n+    }\n   if (TEST_HARD_REG_BIT (*mask, PR_REG))\n     push (PR_REG);\n }\n@@ -4693,8 +4713,11 @@ calc_live_regs (live_regs_mask)\n \n   for (count = 0; 32 * count < FIRST_PSEUDO_REGISTER; count++)\n     CLEAR_HARD_REG_SET (*live_regs_mask);\n+  if (TARGET_SH4 && TARGET_FMOVD && interrupt_handler\n+      && regs_ever_live[FPSCR_REG])\n+    target_flags &= ~FPU_SINGLE_BIT;\n   /* If we can save a lot of saves by switching to double mode, do that.  */\n-  if (TARGET_SH4 && TARGET_FMOVD && TARGET_FPU_SINGLE)\n+  else if (TARGET_SH4 && TARGET_FMOVD && TARGET_FPU_SINGLE)\n     for (count = 0, reg = FIRST_FP_REG; reg <= LAST_FP_REG; reg += 2)\n       if (regs_ever_live[reg] && regs_ever_live[reg+1]\n \t  && (! call_used_regs[reg] || (interrupt_handler && ! pragma_trapa))\n@@ -4911,7 +4934,7 @@ sh_expand_prologue ()\n   d = calc_live_regs (&live_regs_mask);\n   /* ??? Maybe we could save some switching if we can move a mode switch\n      that already happens to be at the function start into the prologue.  */\n-  if (target_flags != save_flags)\n+  if (target_flags != save_flags && ! current_function_interrupt)\n     emit_insn (gen_toggle_sz ());\n     \n   if (TARGET_SH5)\n@@ -5068,7 +5091,7 @@ sh_expand_prologue ()\n \tabort ();\n     }\n   else\n-    push_regs (&live_regs_mask);\n+    push_regs (&live_regs_mask, current_function_interrupt);\n \n   if (flag_pic && regs_ever_live[PIC_OFFSET_TABLE_REGNUM])\n     {\n@@ -5102,7 +5125,7 @@ sh_expand_prologue ()\n \t\t (GEN_INT (-SHMEDIA_REGS_STACK_ADJUST ())));\n     }\n \n-  if (target_flags != save_flags)\n+  if (target_flags != save_flags && ! current_function_interrupt)\n     {\n       rtx insn = emit_insn (gen_toggle_sz ());\n \n@@ -5143,6 +5166,7 @@ sh_expand_epilogue ()\n \n   int save_flags = target_flags;\n   int frame_size;\n+  int fpscr_deferred = 0;\n \n   d = calc_live_regs (&live_regs_mask);\n \n@@ -5188,7 +5212,7 @@ sh_expand_epilogue ()\n \n   /* Pop all the registers.  */\n \n-  if (target_flags != save_flags)\n+  if (target_flags != save_flags && ! current_function_interrupt)\n     emit_insn (gen_toggle_sz ());\n   if (TARGET_SH5)\n     {\n@@ -5341,11 +5365,17 @@ sh_expand_epilogue ()\n     {\n       int j = (FIRST_PSEUDO_REGISTER - 1) - i;\n \n-      if (j != PR_REG && TEST_HARD_REG_BIT (live_regs_mask, j))\n+      if (j == FPSCR_REG && current_function_interrupt && TARGET_FMOVD\n+\t  && hard_regs_intersect_p (&live_regs_mask,\n+\t\t\t\t    &reg_class_contents[DF_REGS]))\n+\tfpscr_deferred = 1;\n+      else if (j != PR_REG && TEST_HARD_REG_BIT (live_regs_mask, j))\n \tpop (j);\n+      if (j == FIRST_FP_REG && fpscr_deferred)\n+\tpop (FPSCR_REG);\n     }\n  finish:\n-  if (target_flags != save_flags)\n+  if (target_flags != save_flags && ! current_function_interrupt)\n     emit_insn (gen_toggle_sz ());\n   target_flags = save_flags;\n "}, {"sha": "35fa7c6a15783b685a7b3324af3b799cc4f84349", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac55736a0a271f62a2ed018a8d34039d6f458f60/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac55736a0a271f62a2ed018a8d34039d6f458f60/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=ac55736a0a271f62a2ed018a8d34039d6f458f60", "patch": "@@ -3292,7 +3292,8 @@ extern int rtx_equal_function_value_matters;\n   (TARGET_FPU_SINGLE ? FP_MODE_SINGLE : FP_MODE_DOUBLE)\n \n #define NORMAL_MODE(ENTITY) \\\n-  (sh_cfun_interrupt_handler_p () ? FP_MODE_NONE \\\n+  (sh_cfun_interrupt_handler_p () \\\n+   ? (TARGET_FMOVD ? FP_MODE_DOUBLE : FP_MODE_NONE) \\\n    : ACTUAL_NORMAL_MODE (ENTITY))\n \n #define EPILOGUE_USES(REGNO)       ((TARGET_SH2E || TARGET_SH4)\t\t\\"}]}