{"sha": "45676a7c8a09579a591fb8d20db90df92a1713b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDU2NzZhN2M4YTA5NTc5YTU5MWZiOGQyMGRiOTBkZjkyYTE3MTNiMw==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2016-05-04T20:54:47Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2016-05-04T20:54:47Z"}, "message": "cfgcleanup: Fold jumps and conditional branches with returns\n\nThis patch makes cfgcleanup optimize jumps to returns.  There are three\ncases this handles:\n\n-- A jump to a return; this is simplified to just that return.\n-- A conditional branch to a return; simplified to a conditional return.\n-- A conditional branch that falls through to a return.  This is simplified\n   to a conditional return (with the condition inverted), falling through\n   to a jump to the original destination.  That jump can then be optimized\n   further, as usual.\n\nThis handles all cases the current function.c does, and a few it misses.\n\n\n\t* cfgcleanup.c (bb_is_just_return): New function.\n\t(try_optimize_cfg): Simplify jumps to return, branches to return,\n\tand branches around return.\n\nFrom-SVN: r235904", "tree": {"sha": "0b0bd030c7648340a035bf394fa67488d6f390a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b0bd030c7648340a035bf394fa67488d6f390a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45676a7c8a09579a591fb8d20db90df92a1713b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45676a7c8a09579a591fb8d20db90df92a1713b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45676a7c8a09579a591fb8d20db90df92a1713b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45676a7c8a09579a591fb8d20db90df92a1713b3/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1a8fb012bda277aa1b4373d2f426986bce76460d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a8fb012bda277aa1b4373d2f426986bce76460d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a8fb012bda277aa1b4373d2f426986bce76460d"}], "stats": {"total": 127, "additions": 127, "deletions": 0}, "files": [{"sha": "584f4e002c9b734bd1224f33c313e2c56360f336", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45676a7c8a09579a591fb8d20db90df92a1713b3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45676a7c8a09579a591fb8d20db90df92a1713b3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=45676a7c8a09579a591fb8d20db90df92a1713b3", "patch": "@@ -1,3 +1,9 @@\n+2016-05-04  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\t* cfgcleanup.c (bb_is_just_return): New function.\n+\t(try_optimize_cfg): Simplify jumps to return, branches to return,\n+\tand branches around return.\n+\n 2016-05-04  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* cfgcleanup.c (try_simplify_condjump): Don't try to simplify a"}, {"sha": "726c068eceb98dadec160a13038b56cf27f56f48", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45676a7c8a09579a591fb8d20db90df92a1713b3/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45676a7c8a09579a591fb8d20db90df92a1713b3/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=45676a7c8a09579a591fb8d20db90df92a1713b3", "patch": "@@ -2606,6 +2606,35 @@ trivially_empty_bb_p (basic_block bb)\n     }\n }\n \n+/* Return true if BB contains just a return and possibly a USE of the\n+   return value.  Fill in *RET and *USE with the return and use insns\n+   if any found, otherwise NULL.  */\n+\n+static bool\n+bb_is_just_return (basic_block bb, rtx_insn **ret, rtx_insn **use)\n+{\n+  *ret = *use = NULL;\n+  rtx_insn *insn;\n+\n+  if (bb == EXIT_BLOCK_PTR_FOR_FN (cfun))\n+    return false;\n+\n+  FOR_BB_INSNS (bb, insn)\n+    if (NONDEBUG_INSN_P (insn))\n+      {\n+\tif (!*ret && ANY_RETURN_P (PATTERN (insn)))\n+\t  *ret = insn;\n+\telse if (!*ret && !*use && GET_CODE (PATTERN (insn)) == USE\n+\t    && REG_P (XEXP (PATTERN (insn), 0))\n+\t    && REG_FUNCTION_VALUE_P (XEXP (PATTERN (insn), 0)))\n+\t  *use = insn;\n+\telse\n+\t  return false;\n+      }\n+\n+  return !!*ret;\n+}\n+\n /* Do simple CFG optimizations - basic block merging, simplifying of jump\n    instructions etc.  Return nonzero if changes were made.  */\n \n@@ -2792,6 +2821,98 @@ try_optimize_cfg (int mode)\n \t\t      }\n \t\t}\n \n+\t      /* Try to change a branch to a return to just that return.  */\n+\t      rtx_insn *ret, *use;\n+\t      if (single_succ_p (b)\n+\t\t  && onlyjump_p (BB_END (b))\n+\t\t  && bb_is_just_return (single_succ (b), &ret, &use))\n+\t\t{\n+\t\t  if (redirect_jump (as_a <rtx_jump_insn *> (BB_END (b)),\n+\t\t\t\t     PATTERN (ret), 0))\n+\t\t    {\n+\t\t      if (use)\n+\t\t\temit_insn_before (copy_insn (PATTERN (use)),\n+\t\t\t\t\t  BB_END (b));\n+\t\t      if (dump_file)\n+\t\t\tfprintf (dump_file, \"Changed jump %d->%d to return.\\n\",\n+\t\t\t\t b->index, single_succ (b)->index);\n+\t\t      redirect_edge_succ (single_succ_edge (b),\n+\t\t\t\t\t  EXIT_BLOCK_PTR_FOR_FN (cfun));\n+\t\t      single_succ_edge (b)->flags &= ~EDGE_CROSSING;\n+\t\t      changed_here = true;\n+\t\t    }\n+\t\t}\n+\n+\t      /* Try to change a conditional branch to a return to the\n+\t\t respective conditional return.  */\n+\t      if (EDGE_COUNT (b->succs) == 2\n+\t\t  && any_condjump_p (BB_END (b))\n+\t\t  && bb_is_just_return (BRANCH_EDGE (b)->dest, &ret, &use))\n+\t\t{\n+\t\t  if (redirect_jump (as_a <rtx_jump_insn *> (BB_END (b)),\n+\t\t\t\t     PATTERN (ret), 0))\n+\t\t    {\n+\t\t      if (use)\n+\t\t\temit_insn_before (copy_insn (PATTERN (use)),\n+\t\t\t\t\t  BB_END (b));\n+\t\t      if (dump_file)\n+\t\t\tfprintf (dump_file, \"Changed conditional jump %d->%d \"\n+\t\t\t\t \"to conditional return.\\n\",\n+\t\t\t\t b->index, BRANCH_EDGE (b)->dest->index);\n+\t\t      redirect_edge_succ (BRANCH_EDGE (b),\n+\t\t\t\t\t  EXIT_BLOCK_PTR_FOR_FN (cfun));\n+\t\t      BRANCH_EDGE (b)->flags &= ~EDGE_CROSSING;\n+\t\t      changed_here = true;\n+\t\t    }\n+\t\t}\n+\n+\t      /* Try to flip a conditional branch that falls through to\n+\t\t a return so that it becomes a conditional return and a\n+\t\t new jump to the original branch target.  */\n+\t      if (EDGE_COUNT (b->succs) == 2\n+\t\t  && any_condjump_p (BB_END (b))\n+\t\t  && bb_is_just_return (FALLTHRU_EDGE (b)->dest, &ret, &use))\n+\t\t{\n+\t\t  if (invert_jump (as_a <rtx_jump_insn *> (BB_END (b)),\n+\t\t\t\t   JUMP_LABEL (BB_END (b)), 0))\n+\t\t    {\n+\t\t      basic_block new_ft = BRANCH_EDGE (b)->dest;\n+\t\t      if (redirect_jump (as_a <rtx_jump_insn *> (BB_END (b)),\n+\t\t\t\t\t PATTERN (ret), 0))\n+\t\t\t{\n+\t\t\t  if (use)\n+\t\t\t    emit_insn_before (copy_insn (PATTERN (use)),\n+\t\t\t\t\t      BB_END (b));\n+\t\t\t  if (dump_file)\n+\t\t\t    fprintf (dump_file, \"Changed conditional jump \"\n+\t\t\t\t     \"%d->%d to conditional return, adding \"\n+\t\t\t\t     \"fall-through jump.\\n\",\n+\t\t\t\t     b->index, BRANCH_EDGE (b)->dest->index);\n+\t\t\t  redirect_edge_succ (BRANCH_EDGE (b),\n+\t\t\t\t\t      EXIT_BLOCK_PTR_FOR_FN (cfun));\n+\t\t\t  BRANCH_EDGE (b)->flags &= ~EDGE_CROSSING;\n+\t\t\t  std::swap (BRANCH_EDGE (b)->probability,\n+\t\t\t\t     FALLTHRU_EDGE (b)->probability);\n+\t\t\t  update_br_prob_note (b);\n+\t\t\t  basic_block jb = force_nonfallthru (FALLTHRU_EDGE (b));\n+\t\t\t  notice_new_block (jb);\n+\t\t\t  if (!redirect_jump (as_a <rtx_jump_insn *> (BB_END (jb)),\n+\t\t\t\t\t      block_label (new_ft), 0))\n+\t\t\t    gcc_unreachable ();\n+\t\t\t  redirect_edge_succ (single_succ_edge (jb), new_ft);\n+\t\t\t  changed_here = true;\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  /* Invert the jump back to what it was.  This should\n+\t\t\t     never fail.  */\n+\t\t\t  if (!invert_jump (as_a <rtx_jump_insn *> (BB_END (b)),\n+\t\t\t\t\t    JUMP_LABEL (BB_END (b)), 0))\n+\t\t\t    gcc_unreachable ();\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\n \t      /* Simplify branch over branch.  */\n \t      if ((mode & CLEANUP_EXPENSIVE)\n \t\t   && !(mode & CLEANUP_CFGLAYOUT)"}]}