{"sha": "8f9b40094d6e960d965e632f6537bf6eaa980ab5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGY5YjQwMDk0ZDZlOTYwZDk2NWU2MzJmNjUzN2JmNmVhYTk4MGFiNQ==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.co.uk", "date": "2003-07-29T22:26:13Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2003-07-29T22:26:13Z"}, "message": "Makefile.in (LIBCPP_DEPS): Add HASHTAB_H.\n\n\t* Makefile.in (LIBCPP_DEPS): Add HASHTAB_H.\n\t* cppfiles.c: Completely rewritten.\n\t* c-incpath.c (free_path, remove_duplicates, heads, tails, add_path):\n\tstruct cpp_path is now struct cpp_dir.\n\t(remove_duplicates): Don't simplify path names.\n\t* c-opts.c (c_common_parse_file): cpp_read_next_file renamed\n\tcpp_stack_file.\n\t* cpphash.h: Include hashtab.h.\n\t(_cpp_file): Declare.\n\t(struct cpp_buffer): struct include_file is now struct _cpp_file,\n\tand struct cpp_path is now struct cpp_dir.  Rename members.\n\t(struct cpp_reader): Similarly.  New members once_only_files,\n\tfile_hash, file_hash_entries, quote_ignores_source_dir,\n\tno_search_path, saw_pragma_once.  Remove all_include_files and\n\tmax_include_len.  Make some members bool.\n\t(_cpp_mark_only_only): Renamed from _cpp_never_reread.\n\t(_cpp_stack_file): Renamed from _cpp_read_file.\n\t(_cpp_stack_include): Renamed from _cpp_execute_include.\n\t(_cpp_init_files): Renamed from _cpp_init_includes.\n\t(_cpp_cleanup_files): Renamed from _cpp_cleanup_includes.\n\t* cppinit.c (cpp_create_reader): Initialize no_search_path.  Update.\n\t(cpp_read_next_file): Rename and move to cppfiles.c.\n\t(cpp_read_main_file): Update.\n\t* cpplib.c (run_directive): Update for renamed members.\n\t(do_include_common, _cpp_pop_buffer): Update.\n\t(do_import): Undeprecate #import.\n\t(do_pragma_once): Undeprecate.  Use _cpp_mark_file_once_only.\n\t* cpplib.h: Remove file_name_map_list.\n\t(cpp_options): Remove map_list.\n\t(cpp_dir): Rename from cpp_path.  New datatype for name_map.\n\t(cpp_set_include_chains, cpp_stack_file, cpp_included): Update.\ntestsuite:\n\t* gcc.dg/cpp/include2.c: Only expect one message.\n\nFrom-SVN: r69942", "tree": {"sha": "1789dbf490b4c620a39de9335b1d8002ee48603b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1789dbf490b4c620a39de9335b1d8002ee48603b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8f9b40094d6e960d965e632f6537bf6eaa980ab5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f9b40094d6e960d965e632f6537bf6eaa980ab5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f9b40094d6e960d965e632f6537bf6eaa980ab5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f9b40094d6e960d965e632f6537bf6eaa980ab5/comments", "author": {"login": "neilb-xx", "id": 160762, "node_id": "MDQ6VXNlcjE2MDc2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/160762?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neilb-xx", "html_url": "https://github.com/neilb-xx", "followers_url": "https://api.github.com/users/neilb-xx/followers", "following_url": "https://api.github.com/users/neilb-xx/following{/other_user}", "gists_url": "https://api.github.com/users/neilb-xx/gists{/gist_id}", "starred_url": "https://api.github.com/users/neilb-xx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neilb-xx/subscriptions", "organizations_url": "https://api.github.com/users/neilb-xx/orgs", "repos_url": "https://api.github.com/users/neilb-xx/repos", "events_url": "https://api.github.com/users/neilb-xx/events{/privacy}", "received_events_url": "https://api.github.com/users/neilb-xx/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ad96995ba1e08da3646502930168ea0c39a89ad7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad96995ba1e08da3646502930168ea0c39a89ad7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad96995ba1e08da3646502930168ea0c39a89ad7"}], "stats": {"total": 1958, "additions": 996, "deletions": 962}, "files": [{"sha": "d6887fad18a4db0380835d2fb1a3cd2eada6bb1b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f9b40094d6e960d965e632f6537bf6eaa980ab5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f9b40094d6e960d965e632f6537bf6eaa980ab5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8f9b40094d6e960d965e632f6537bf6eaa980ab5", "patch": "@@ -1,3 +1,37 @@\n+2003-07-29  Neil Booth  <neil@daikokuya.co.uk>\n+\n+\t* Makefile.in (LIBCPP_DEPS): Add HASHTAB_H.\n+\t* cppfiles.c: Completely rewritten.\n+\t* c-incpath.c (free_path, remove_duplicates, heads, tails, add_path):\n+\tstruct cpp_path is now struct cpp_dir.\n+\t(remove_duplicates): Don't simplify path names.\n+\t* c-opts.c (c_common_parse_file): cpp_read_next_file renamed\n+\tcpp_stack_file.\n+\t* cpphash.h: Include hashtab.h.\n+\t(_cpp_file): Declare.\n+\t(struct cpp_buffer): struct include_file is now struct _cpp_file,\n+\tand struct cpp_path is now struct cpp_dir.  Rename members.\n+\t(struct cpp_reader): Similarly.  New members once_only_files,\n+\tfile_hash, file_hash_entries, quote_ignores_source_dir,\n+\tno_search_path, saw_pragma_once.  Remove all_include_files and\n+\tmax_include_len.  Make some members bool.\n+\t(_cpp_mark_only_only): Renamed from _cpp_never_reread.\n+\t(_cpp_stack_file): Renamed from _cpp_read_file.\n+\t(_cpp_stack_include): Renamed from _cpp_execute_include.\n+\t(_cpp_init_files): Renamed from _cpp_init_includes.\n+\t(_cpp_cleanup_files): Renamed from _cpp_cleanup_includes.\n+\t* cppinit.c (cpp_create_reader): Initialize no_search_path.  Update.\n+\t(cpp_read_next_file): Rename and move to cppfiles.c.\n+\t(cpp_read_main_file): Update.\n+\t* cpplib.c (run_directive): Update for renamed members.\n+\t(do_include_common, _cpp_pop_buffer): Update.\n+\t(do_import): Undeprecate #import.\n+\t(do_pragma_once): Undeprecate.  Use _cpp_mark_file_once_only.\n+\t* cpplib.h: Remove file_name_map_list.\n+\t(cpp_options): Remove map_list.\n+\t(cpp_dir): Rename from cpp_path.  New datatype for name_map.\n+\t(cpp_set_include_chains, cpp_stack_file, cpp_included): Update.\n+\n 2003-07-29  Phil Edwards  <pme@gcc.gnu.org>\n \n \t* Makefile.in:  Make stamp-objdir safe for parallel builds."}, {"sha": "3754567a8bbfaea91d6c074e2b3d644121b42ca4", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f9b40094d6e960d965e632f6537bf6eaa980ab5/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f9b40094d6e960d965e632f6537bf6eaa980ab5/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=8f9b40094d6e960d965e632f6537bf6eaa980ab5", "patch": "@@ -2348,7 +2348,7 @@ LIBCPP_OBJS =\tcpplib.o cpplex.o cppmacro.o cppexp.o cppfiles.o cpptrad.o \\\n \t\thashtable.o line-map.o mkdeps.o cpppch.o\n \n LIBCPP_DEPS =\t$(CPPLIB_H) cpphash.h line-map.h hashtable.h intl.h \\\n-\t\t$(OBSTACK_H) $(CONFIG_H) $(SYSTEM_H)\n+\t\t$(HASHTAB_H) $(OBSTACK_H) $(CONFIG_H) $(SYSTEM_H)\n \n # Most of the other archives built/used by this makefile are for\n # targets.  This one is strictly for the host."}, {"sha": "e28114652a3e09e0f0b6a6c44b89e02d03e8f41e", "filename": "gcc/c-incpath.c", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f9b40094d6e960d965e632f6537bf6eaa980ab5/gcc%2Fc-incpath.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f9b40094d6e960d965e632f6537bf6eaa980ab5/gcc%2Fc-incpath.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-incpath.c?ref=8f9b40094d6e960d965e632f6537bf6eaa980ab5", "patch": "@@ -45,21 +45,21 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n \n static void add_env_var_paths (const char *, int);\n static void add_standard_paths (const char *, const char *, int);\n-static void free_path (struct cpp_path *, int);\n+static void free_path (struct cpp_dir *, int);\n static void merge_include_chains (cpp_reader *, int);\n-static struct cpp_path *remove_duplicates (cpp_reader *, struct cpp_path *,\n-\t\t\t\t\t   struct cpp_path *,\n-\t\t\t\t\t   struct cpp_path *, int);\n+static struct cpp_dir *remove_duplicates (cpp_reader *, struct cpp_dir *,\n+\t\t\t\t\t   struct cpp_dir *,\n+\t\t\t\t\t   struct cpp_dir *, int);\n \n /* Include chains heads and tails.  */\n-static struct cpp_path *heads[4];\n-static struct cpp_path *tails[4];\n+static struct cpp_dir *heads[4];\n+static struct cpp_dir *tails[4];\n static bool quote_ignores_source_dir;\n enum { REASON_QUIET = 0, REASON_NOENT, REASON_DUP, REASON_DUP_SYS };\n \n /* Free an element of the include chain, possibly giving a reason.  */\n static void\n-free_path (struct cpp_path *path, int reason)\n+free_path (struct cpp_dir *path, int reason)\n {\n   switch (reason)\n     {\n@@ -169,20 +169,19 @@ add_standard_paths (const char *sysroot, const char *iprefix, int cxx_stdinc)\n    JOIN, unless it duplicates JOIN in which case the last path is\n    removed.  Return the head of the resulting chain.  Any of HEAD,\n    JOIN and SYSTEM can be NULL.  */\n-static struct cpp_path *\n-remove_duplicates (cpp_reader *pfile, struct cpp_path *head,\n-\t\t   struct cpp_path *system, struct cpp_path *join,\n+static struct cpp_dir *\n+remove_duplicates (cpp_reader *pfile, struct cpp_dir *head,\n+\t\t   struct cpp_dir *system, struct cpp_dir *join,\n \t\t   int verbose)\n {\n-  struct cpp_path **pcur, *tmp, *cur;\n+  struct cpp_dir **pcur, *tmp, *cur;\n   struct stat st;\n \n   for (pcur = &head; *pcur; )\n     {\n       int reason = REASON_QUIET;\n \n       cur = *pcur;\n-      cpp_simplify_path (cur->name);\n \n       if (stat (cur->name, &st))\n \t{\n@@ -269,7 +268,7 @@ merge_include_chains (cpp_reader *pfile, int verbose)\n   /* If verbose, print the list of dirs to search.  */\n   if (verbose)\n     {\n-      struct cpp_path *p;\n+      struct cpp_dir *p;\n \n       fprintf (stderr, _(\"#include \\\"...\\\" search starts here:\\n\"));\n       for (p = heads[QUOTE];; p = p->next)\n@@ -304,9 +303,9 @@ split_quote_chain (void)\n void\n add_path (char *path, int chain, int cxx_aware)\n {\n-  struct cpp_path *p;\n+  struct cpp_dir *p;\n \n-  p = xmalloc (sizeof (struct cpp_path));\n+  p = xmalloc (sizeof (struct cpp_dir));\n   p->next = NULL;\n   p->name = path;\n   if (chain == SYSTEM || chain == AFTER)"}, {"sha": "44ac8dc8eaaaa32dd1971f861432b408d45f9fdd", "filename": "gcc/c-opts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f9b40094d6e960d965e632f6537bf6eaa980ab5/gcc%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f9b40094d6e960d965e632f6537bf6eaa980ab5/gcc%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-opts.c?ref=8f9b40094d6e960d965e632f6537bf6eaa980ab5", "patch": "@@ -1206,7 +1206,7 @@ c_common_parse_file (int set_yydebug ATTRIBUTE_UNUSED)\n \n \t  /* Reset cpplib's macros and start a new file.  */\n \t  cpp_undef_all (parse_in);\n-\t  cpp_read_next_file (parse_in, in_fnames[file_index]);\n+\t  cpp_stack_file (parse_in, in_fnames[file_index]);\n \t}\n \n       finish_options(in_fnames[file_index]);"}, {"sha": "562b0ab521c29884c6be422c64b2228bc5867e54", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 882, "deletions": 873, "changes": 1755, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f9b40094d6e960d965e632f6537bf6eaa980ab5/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f9b40094d6e960d965e632f6537bf6eaa980ab5/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=8f9b40094d6e960d965e632f6537bf6eaa980ab5", "patch": "@@ -1,10 +1,11 @@\n-/* Part of CPP library.  (include file handling)\n+/* Part of CPP library.  File handling.\n    Copyright (C) 1986, 1987, 1989, 1992, 1993, 1994, 1995, 1998,\n    1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n    Written by Per Bothner, 1994.\n    Based on CCCP program by Paul Rubin, June 1986\n    Adapted to ANSI C, Richard Stallman, Jan 1987\n    Split out of cpplib.c, Zack Weinberg, Oct 1998\n+   Reimplemented, Neil Booth, Jul 2003\n \n This program is free software; you can redistribute it and/or modify it\n under the terms of the GNU General Public License as published by the\n@@ -22,423 +23,398 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n #include \"system.h\"\n-#include <dirent.h>\n #include \"cpplib.h\"\n #include \"cpphash.h\"\n #include \"intl.h\"\n #include \"mkdeps.h\"\n-#include \"splay-tree.h\"\n+#include <dirent.h>\n \n-#ifndef O_BINARY\n-# define O_BINARY 0\n+/* Variable length record files on VMS will have a stat size that includes\n+   record control characters that won't be included in the read size.  */\n+#ifdef VMS\n+# define FAB_C_VAR 2 /* variable length records (see Starlet fabdef.h) */\n+# define STAT_SIZE_RELIABLE(ST) ((ST).st_fab_rfm != FAB_C_VAR)\n+#else\n+# define STAT_SIZE_RELIABLE(ST) true\n #endif\n \n-/* If errno is inspected immediately after a system call fails, it will be\n-   nonzero, and no error number will ever be zero.  */\n-#ifndef ENOENT\n-# define ENOENT 0\n+#ifdef __DJGPP__\n+  /* For DJGPP redirected input is opened in text mode.  */\n+#  define set_stdin_to_binary_mode() \\\n+     if (! isatty (0)) setmode (0, O_BINARY)\n+#else\n+#  define set_stdin_to_binary_mode() /* Nothing */\n+#endif\n+\n+#ifndef O_BINARY\n+# define O_BINARY 0\n #endif\n #ifndef ENOTDIR\n # define ENOTDIR 0\n #endif\n \n-/* This structure is used for the table of all includes.  */\n-struct include_file {\n-  const char *name;\t\t/* actual path name of file */\n-  const char *header_name;\t/* the original header found */\n-  const cpp_hashnode *cmacro;\t/* macro, if any, preventing reinclusion.  */\n-  const struct cpp_path *foundhere;\n-\t\t\t\t/* location in search path where file was\n-\t\t\t\t   found, for #include_next and sysp.  */\n-  const unsigned char *buffer;\t/* pointer to cached file contents */\n-  struct stat st;\t\t/* copy of stat(2) data for file */\n-  int fd;\t\t\t/* fd open on file (short term storage only) */\n-  int err_no;\t\t\t/* errno obtained if opening a file failed */\n-  unsigned short include_count;\t/* number of times file has been read */\n-  unsigned char pch;\t\t/* 0: file not known to be a PCH.\n-\t\t\t\t   1: file is a PCH \n-\t\t\t\t      (on return from find_include_file).\n-\t\t\t\t   2: file is not and never will be a valid\n-\t\t\t\t      precompiled header.\n-\t\t\t\t   3: file is always a valid precompiled\n-\t\t\t\t      header.  */\n-};\n+/* This structure represents a file searched for by CPP, whether it\n+   exists or not.  An instance may be pointed to by more than one\n+   file_hash_entry; at present no reference count is kept.  */\n+typedef struct _cpp_file _cpp_file;\n+struct _cpp_file\n+{\n+  /* Filename as given to #include or command line switch.  */\n+  const char *name;\n \n-/* Variable length record files on VMS will have a stat size that includes\n-   record control characters that won't be included in the read size.  */\n-#ifdef VMS\n-# define FAB_C_VAR 2 /* variable length records (see Starlet fabdef.h) */\n-# define STAT_SIZE_TOO_BIG(ST) ((ST).st_fab_rfm == FAB_C_VAR)\n-#else\n-# define STAT_SIZE_TOO_BIG(ST) 0\n-#endif\n+  /* The full path used to find the file.  */\n+  const char *path;\n \n-/* The cmacro works like this: If it's NULL, the file is to be\n-   included again.  If it's NEVER_REREAD, the file is never to be\n-   included again.  Otherwise it is a macro hashnode, and the file is\n-   to be included again if the macro is defined.  */\n-#define NEVER_REREAD ((const cpp_hashnode *) -1)\n-#define DO_NOT_REREAD(inc) \\\n-((inc)->cmacro && ((inc)->cmacro == NEVER_REREAD \\\n-\t\t   || (inc)->cmacro->type == NT_MACRO))\n-#define NO_INCLUDE_PATH ((struct include_file *) -1)\n-#define INCLUDE_PCH_P(F) (((F)->pch & 1) != 0)\n-\n-static struct file_name_map *read_name_map (cpp_reader *, const char *);\n-static char *read_filename_string (int, FILE *);\n-static char *remap_filename (cpp_reader *, char *, struct cpp_path *);\n-static struct cpp_path *search_from (cpp_reader *, enum include_type);\n-static struct include_file *find_include_file (cpp_reader *, const char *,\n-\t\t\t\t\t       int, enum include_type);\n-static struct include_file *open_file (cpp_reader *, const char *);\n-static struct include_file *validate_pch (cpp_reader *, const char *,\n-\t\t\t\t\t  const char *);\n-static struct include_file *open_file_pch (cpp_reader *, const char *);\n-static int read_include_file (cpp_reader *, struct include_file *);\n-static bool stack_include_file (cpp_reader *, struct include_file *);\n-static void purge_cache (struct include_file *);\n-static void destroy_node (splay_tree_value);\n-static int report_missing_guard (splay_tree_node, void *);\n-static splay_tree_node find_or_create_entry (cpp_reader *, const char *);\n-static void handle_missing_header (cpp_reader *, const char *, int);\n-static int remove_component_p (const char *);\n-\n-/* Set up the splay tree we use to store information about all the\n-   file names seen in this compilation.  We also have entries for each\n-   file we tried to open but failed; this saves system calls since we\n-   don't try to open it again in future.\n-\n-   The key of each node is the file name, after processing by\n-   cpp_simplify_path.  The path name may or may not be absolute.\n-   The path string has been malloced, as is automatically freed by\n-   registering free () as the splay tree key deletion function.\n-\n-   A node's value is a pointer to a struct include_file, and is never\n-   NULL.  */\n-void\n-_cpp_init_includes (cpp_reader *pfile)\n-{\n-  pfile->all_include_files\n-    = splay_tree_new ((splay_tree_compare_fn) strcmp,\n-\t\t      (splay_tree_delete_key_fn) free,\n-\t\t      destroy_node);\n-}\n+  /* The full path of the pch file.  */\n+  const char *pchname;\n \n-/* Tear down the splay tree.  */\n-void\n-_cpp_cleanup_includes (cpp_reader *pfile)\n-{\n-  splay_tree_delete (pfile->all_include_files);\n-}\n+  /* The file's path with the basename stripped, malloced.  NULL if it\n+     hasn't been calculated yet.  */\n+  const char *dir_name;\n \n-/* Free a node.  The path string is automatically freed.  */\n-static void\n-destroy_node (splay_tree_value v)\n-{\n-  struct include_file *f = (struct include_file *) v;\n+  /* Chain through #import-ed files or those  containing #pragma once.  */\n+  struct _cpp_file *once_only_next;\n \n-  if (f)\n-    {\n-      purge_cache (f);\n-      free (f);\n-    }\n-}\n+  /* The contents of NAME after calling read_file().  */\n+  const uchar *buffer;\n \n-/* Mark a file to not be reread (e.g. #import, read failure).  */\n-void\n-_cpp_never_reread (struct include_file *file)\n-{\n-  file->cmacro = NEVER_REREAD;\n-}\n+  /* The macro, if any, preventing re-inclusion.  */\n+  const cpp_hashnode *cmacro;\n \n-/* Lookup a filename, which is simplified after making a copy, and\n-   create an entry if none exists.  */\n-static splay_tree_node\n-find_or_create_entry (cpp_reader *pfile, const char *fname)\n-{\n-  splay_tree_node node;\n-  struct include_file *file;\n-  char *name = xstrdup (fname);\n-  int saved_errno;\n-\n-  cpp_simplify_path (name);\n-  saved_errno = errno;\n-  node = splay_tree_lookup (pfile->all_include_files, (splay_tree_key) name);\n-  if (node)\n-    free (name);\n-  else\n-    {\n-      file = xcnew (struct include_file);\n-      file->name = name;\n-      file->header_name = name;\n-      file->err_no = saved_errno;\n-      node = splay_tree_insert (pfile->all_include_files,\n-\t\t\t\t(splay_tree_key) file->name,\n-\t\t\t\t(splay_tree_value) file);\n-    }\n+  /* The directory in the search path where FILE was found.  Used for\n+     #include_next and determining whether a header is a system\n+     header.  Is NULL if the file was given as an absolute path, or\n+     opened with read_file.  */\n+  cpp_dir *dir;\n \n-  return node;\n-}\n+  /* As filled in by stat(2) for the file.  */\n+  struct stat st;\n \n-/* Enter a file name in the splay tree, for the sake of cpp_included.  */\n-void\n-_cpp_fake_include (cpp_reader *pfile, const char *fname)\n-{\n-  find_or_create_entry (pfile, fname);\n-}\n+  /* File descriptor.  Invalid if -1, otherwise open.  */\n+  int fd;\n \n-/* Given a file name, look it up in the cache; if there is no entry,\n-   create one with a non-NULL value (regardless of success in opening\n-   the file).  If the file doesn't exist or is inaccessible, this\n-   entry is flagged so we don't attempt to open it again in the\n-   future.  If the file isn't open, open it.  The empty string is\n-   interpreted as stdin.\n-\n-   Returns an include_file structure with an open file descriptor on\n-   success, or NULL on failure.  */\n-static struct include_file *\n-open_file (cpp_reader *pfile, const char *filename)\n-{\n-  splay_tree_node nd = find_or_create_entry (pfile, filename);\n-  struct include_file *file = (struct include_file *) nd->value;\n+  /* Zero if this file was successfully opened and stat()-ed,\n+     otherwise errno obtained from failure.  */\n+  int err_no;\n \n-  if (file->err_no)\n-    {\n-      /* Ugh.  handle_missing_header () needs errno to be set.  */\n-      errno = file->err_no;\n-      return 0;\n-    }\n+  /* Number of times the file has been stacked for preprocessing.  */\n+  unsigned short stack_count;\n \n-  /* Don't reopen an idempotent file.  */\n-  if (DO_NOT_REREAD (file))\n-    return file;\n+  /* If opened with #import.  */\n+  bool import;\n \n-  /* Don't reopen one which is already loaded.  */\n-  if (0 && file->buffer != NULL)\n-    return file;\n+  /* If contains #pragma once.  */\n+  bool pragma_once;\n \n-  /* We used to open files in nonblocking mode, but that caused more\n-     problems than it solved.  Do take care not to acquire a\n-     controlling terminal by mistake (this can't happen on sane\n-     systems, but paranoia is a virtue).\n+  /* If read() failed before.  */\n+  bool dont_read;\n \n-     Use the three-argument form of open even though we aren't\n-     specifying O_CREAT, to defend against broken system headers.\n+  /* If this file is the main file.  */\n+  bool main_file;\n \n-     O_BINARY tells some runtime libraries (notably DJGPP) not to do\n-     newline translation; we can handle DOS line breaks just fine\n-     ourselves.\n+  /* If BUFFER above contains the true contents of the file.  */\n+  bool buffer_valid;\n \n-     Special case: the empty string is translated to stdin.  */\n+  /* 0: file not known to be a PCH.\n+     1: file is a PCH (on return from find_include_file).\n+     2: file is not and never will be a valid precompiled header.\n+     3: file is always a valid precompiled header.  */\n+  uchar pch;\n+};\n \n-  if (filename[0] == '\\0')\n+/* A singly-linked list for all searches for a given file name, with\n+   its head pointed to by a slot in FILE_HASH.  The file name is what\n+   appeared between the quotes in a #include directive; it can be\n+   determined implicity from the hash table location or explicitly\n+   from FILE->fname.\n+\n+   FILE is a structure containing details about the file that was\n+   found with that search, or details of how the search failed.\n+\n+   START_DIR is the starting location of the search in the include\n+   chain.  The current directories for \"\" includes are also hashed in\n+   the hash table.  Files that are looked up without using a search\n+   path, such as absolute filenames and file names from the command\n+   line share a special starting directory so they don't get confused\n+   with normal include-chain lookups in the cache.\n+\n+   If START_DIR is NULL then the entry is for a directory, not a file,\n+   and the directory is in DIR.  Since the starting point in a file\n+   lookup chain is never NULL, this means that simple pointer\n+   comparisons against START_DIR can be made to determine cache hits\n+   in file lookups.\n+*/\n+struct file_hash_entry\n+{\n+  struct file_hash_entry *next;\n+  cpp_dir *start_dir;\n+  union\n+  {\n+    _cpp_file *file;\n+    cpp_dir *dir;\n+  } u;\n+};\n+\n+static bool open_file (_cpp_file *file);\n+static bool pch_open_file (cpp_reader *pfile, _cpp_file *file);\n+static bool open_file_in_dir (cpp_reader *pfile, _cpp_file *file);\n+static _cpp_file *find_file (cpp_reader *, const char *fname,\n+\t\t\t     cpp_dir *start_dir, bool fake);\n+static bool read_file_guts (cpp_reader *pfile, _cpp_file *file);\n+static bool read_file (cpp_reader *pfile, _cpp_file *file);\n+static bool stack_file (cpp_reader *, _cpp_file *file, bool import);\n+static bool once_only_file_p (cpp_reader *, _cpp_file *file, bool import);\n+static struct cpp_dir *search_path_head (cpp_reader *, const char *fname,\n+\t\t\t\t int angle_brackets, enum include_type);\n+static const char *dir_name_of_file (_cpp_file *file);\n+static void open_file_failed (cpp_reader *pfile, _cpp_file *file);\n+static struct file_hash_entry *search_cache (struct file_hash_entry *head,\n+\t\t\t\t\t     const cpp_dir *start_dir);\n+static _cpp_file *make_cpp_file (cpp_reader *, cpp_dir *, const char *fname);\n+static cpp_dir *make_cpp_dir (cpp_reader *, const char *dir_name, int sysp);\n+static void allocate_file_hash_entries (cpp_reader *pfile);\n+static struct file_hash_entry *new_file_hash_entry (cpp_reader *pfile);\n+static int report_missing_guard (void **slot, void *b);\n+static int hash_string_eq (const void *p, const void *q);\n+static char *read_filename_string (int ch, FILE *f);\n+static void read_name_map (cpp_dir *dir);\n+static char *remap_filename (cpp_reader *pfile, _cpp_file *file);\n+static char *append_file_to_dir (const char *fname, cpp_dir *dir);\n+static bool validate_pch (cpp_reader *, _cpp_file *file, const char *pchname);\n+static bool include_pch_p (_cpp_file *file);\n+\n+/* Given a filename in FILE->PATH, with the empty string interpreted\n+   as <stdin>, open it.\n+\n+   On success FILE contains an open file descriptor and stat\n+   information for the file.  On failure the file descriptor is -1 and\n+   the appropriate errno is also stored in FILE.  Returns TRUE iff\n+   successful.\n+\n+   We used to open files in nonblocking mode, but that caused more\n+   problems than it solved.  Do take care not to acquire a controlling\n+   terminal by mistake (this can't happen on sane systems, but\n+   paranoia is a virtue).\n+\n+   Use the three-argument form of open even though we aren't\n+   specifying O_CREAT, to defend against broken system headers.\n+\n+   O_BINARY tells some runtime libraries (notably DJGPP) not to do\n+   newline translation; we can handle DOS line breaks just fine\n+   ourselves.  */\n+static bool\n+open_file (_cpp_file *file)\n+{\n+  if (file->path[0] == '\\0')\n     {\n       file->fd = 0;\n-#ifdef __DJGPP__\n-      /* For DJGPP redirected input is opened in text mode. Change it\n-         to binary mode.  */\n-      if (! isatty (file->fd))\n-\tsetmode (file->fd, O_BINARY);\n-#endif\n+      set_stdin_to_binary_mode ();\n     }\n   else\n-    file->fd = open (file->name, O_RDONLY | O_NOCTTY | O_BINARY, 0666);\n+    file->fd = open (file->path, O_RDONLY | O_NOCTTY | O_BINARY, 0666);\n \n-  if (file->fd != -1 && fstat (file->fd, &file->st) == 0)\n+  if (file->fd != -1)\n     {\n-      if (!S_ISDIR (file->st.st_mode))\n-\treturn file;\n+      if (fstat (file->fd, &file->st) == 0)\n+\t{\n+\t  if (!S_ISDIR (file->st.st_mode))\n+\t    {\n+\t      file->err_no = 0;\n+\t      return true;\n+\t    }\n+\n+\t  /* Ignore a directory and continue the search.  The file we're\n+\t     looking for may be elsewhere in the search path.  */\n+\t  errno = ENOENT;\n+\t}\n \n-      /* If it's a directory, we return null and continue the search\n-\t as the file we're looking for may appear elsewhere in the\n-\t search path.  */\n-      errno = ENOENT;\n       close (file->fd);\n       file->fd = -1;\n     }\n \n   file->err_no = errno;\n-  return 0;\n+\n+  return false;\n }\n \n-static struct include_file *\n-validate_pch (cpp_reader *pfile, const char *filename, const char *pchname)\n+/* Temporary PCH intercept of opening a file.  */\n+static bool\n+pch_open_file (cpp_reader *pfile, _cpp_file *file)\n {\n-  struct include_file * file;\n-  \n-  file = open_file (pfile, pchname);\n-  if (file == NULL)\n-    return NULL;\n-  if ((file->pch & 2) == 0)\n-    file->pch = pfile->cb.valid_pch (pfile, pchname, file->fd);\n-  if (CPP_OPTION (pfile, print_include_names))\n-    {\n-      unsigned int i;\n-      for (i = 1; i < pfile->line_maps.depth; i++)\n-\tputc ('.', stderr);\n-      fprintf (stderr, \"%c %s\\n\", INCLUDE_PCH_P (file) ? '!' : 'x', pchname);\n-    }\n-  if (INCLUDE_PCH_P (file))\n-    {\n-      char *f = xstrdup (filename);\n-      cpp_simplify_path (f);\n-      file->header_name = f;\n-      return file;\n-    }\n-  close (file->fd);\n-  file->fd = -1;\n-  return NULL;\n-}\n+  static const char extension[] = \".gch\";\n+  const char *path = file->path;\n+  size_t len, flen;\n+  char *pchname;\n+  struct stat st;\n+  bool valid = false;\n+\n+  /* No PCH on <stdin> or if not requested.  */\n+  if (file->name[0] == '\\0' || !pfile->cb.valid_pch)\n+    return false;\n \n+  flen = strlen (path);\n+  len = flen + sizeof (extension);\n+  pchname = xmalloc (len);\n+  memcpy (pchname, path, flen);\n+  memcpy (pchname + flen, extension, sizeof (extension));\n \n-/* Like open_file, but also look for a precompiled header if (a) one exists\n-   and (b) it is valid.  */\n-static struct include_file *\n-open_file_pch (cpp_reader *pfile, const char *filename)\n-{\n-  if (filename[0] != '\\0'\n-      && pfile->cb.valid_pch != NULL)\n+  if (stat (pchname, &st) == 0)\n     {\n-      size_t namelen = strlen (filename);\n-      char *pchname = alloca (namelen + 5);\n-      struct include_file *file = NULL;\n-      struct stat st;\n-      \n-      memcpy (pchname, filename, namelen);\n-      memcpy (pchname + namelen, \".gch\", 5);\n-      cpp_simplify_path (pchname);\n-\n-      if (stat (pchname, &st) == 0 && S_ISDIR (st.st_mode))\n+      DIR *pchdir;\n+      struct dirent *d;\n+      size_t dlen, plen = len;\n+\n+      if (!S_ISDIR (st.st_mode))\n+\tvalid = validate_pch (pfile, file, pchname);\n+      else if ((pchdir = opendir (pchname)) != NULL)\n \t{\n-\t  DIR * thedir;\n-\t  struct dirent *d;\n-\t  size_t subname_len = namelen + 64;\n-\t  char *subname = xmalloc (subname_len);\n-\t      \n-\t  thedir = opendir (pchname);\n-\t  if (thedir == NULL)\n-\t    return NULL;\n-\t  memcpy (subname, pchname, namelen + 4);\n-\t  subname[namelen+4] = '/';\n-\t  while ((d = readdir (thedir)) != NULL)\n+\t  pchname[plen - 1] = '/';\n+\t  while ((d = readdir (pchdir)) != NULL)\n \t    {\n-\t      if (strlen (d->d_name) + namelen + 7 > subname_len)\n+\t      dlen = strlen (d->d_name) + 1;\n+\t      if (dlen + plen > len)\n \t\t{\n-\t\t  subname_len = strlen (d->d_name) + namelen + 64;\n-\t\t  subname = xrealloc (subname, subname_len);\n+\t\t  len += dlen + 64;\n+\t\t  pchname = xrealloc (pchname, len);\n \t\t}\n-\t      strcpy (subname + namelen + 5, d->d_name);\n-\t      file = validate_pch (pfile, filename, subname);\n-\t      if (file)\n+\t      memcpy (pchname + plen, d->d_name, dlen);\n+\t      valid = validate_pch (pfile, file, pchname);\n+\t      if (valid)\n \t\tbreak;\n \t    }\n-\t  closedir (thedir);\n-\t  free (subname);\n+\t  closedir (pchdir);\n \t}\n-      else\n-\tfile = validate_pch (pfile, filename, pchname);\n-\n-      if (file)\n-\treturn file;\n     }\n \n-  return open_file (pfile, filename);\n+  if (valid)\n+    file->pchname = pchname;\n+  else\n+    free (pchname);\n+\n+  return valid;\n }\n \n-/* Place the file referenced by INC into a new buffer on the buffer\n-   stack, unless there are errors, or the file is not re-included\n-   because of e.g. multiple-include guards.  Returns true if a buffer\n-   is stacked.  */\n+/* Try to open the path FILE->name appended to FILE->dir.  This is\n+   where remap and PCH intercept the file lookup process.  */\n static bool\n-stack_include_file (cpp_reader *pfile, struct include_file *inc)\n+open_file_in_dir (cpp_reader *pfile, _cpp_file *file)\n {\n-  cpp_buffer *fp;\n-  int sysp;\n-  const char *filename;\n+  char *path;\n \n-  if (DO_NOT_REREAD (inc))\n-    return false;\n+  if (CPP_OPTION (pfile, remap) && (path = remap_filename (pfile, file)))\n+    ;\n+  else\n+    path = append_file_to_dir (file->name, file->dir);\n \n-  sysp = MAX ((pfile->map ? pfile->map->sysp : 0),\n-\t      (inc->foundhere ? inc->foundhere->sysp : 0));\n+  file->path = path;\n+  if (pch_open_file (pfile, file))\n+    return true;\n \n-  /* Add the file to the dependencies on its first inclusion.  */\n-  if (CPP_OPTION (pfile, deps.style) > !!sysp && !inc->include_count)\n-    {\n-      if (pfile->buffer || CPP_OPTION (pfile, deps.ignore_main_file) == 0)\n-\tdeps_add_dep (pfile->deps, inc->name);\n-    }\n+  if (open_file (file))\n+    return true;\n \n-  /* PCH files get dealt with immediately.  */\n-  if (INCLUDE_PCH_P (inc))\n-    {\n-      pfile->cb.read_pch (pfile, inc->name, inc->fd, inc->header_name);\n-      close (inc->fd);\n-      inc->fd = -1;\n-      return false;\n-    }\n+  free (path);\n+  file->path = NULL;\n+  return false;\n+}\n+\n+/* Given a filename FNAME search for such a file in the include path\n+   starting from START_DIR.  If FNAME is the empty string it is\n+   interpreted as STDIN if START_DIR is PFILE->no_seach_path.\n+\n+   If the file is not found in the file cache fall back to the O/S and\n+   add the result to our cache.\n+\n+   If the file was not found in the filesystem, or there was an error\n+   opening it, then ERR_NO is non-zero and FD is -1.  If the file was\n+   found, then ERR_NO is zero and FD could be -1 or an open file\n+   descriptor.  FD can be -1 if the file was found in the cache and\n+   had previously been closed.  To open it again pass the return value\n+   to open_file().\n+*/\n+static _cpp_file *\n+find_file (cpp_reader *pfile, const char *fname, cpp_dir *start_dir, bool fake)\n+{\n+  struct file_hash_entry *entry, **hash_slot;\n+  _cpp_file *file;\n+\n+  /* Ensure we get no confusion between cached files and directories.  */\n+  if (start_dir == NULL)\n+    cpp_error (pfile, DL_ICE, \"NULL directory in find_file\");\n+\n+  hash_slot = (struct file_hash_entry **)\n+    htab_find_slot (pfile->file_hash, fname, INSERT);\n \n-  /* Not in cache?  */\n-  if (1 || ! inc->buffer)\n+  /* First check the cache before we resort to memory allocation.  */\n+  entry = search_cache (*hash_slot, start_dir);\n+  if (entry)\n+    return entry->u.file;\n+\n+  file = make_cpp_file (pfile, start_dir, fname);\n+\n+  /* Try each path in the include chain.  */\n+  for (; !fake ;)\n     {\n-      if (read_include_file (pfile, inc))\n+      if (open_file_in_dir (pfile, file))\n+\tbreak;\n+\n+      if (file->err_no != ENOENT || (file->dir = file->dir->next) == NULL)\n \t{\n-\t  /* If an error occurs, do not try to read this file again.  */\n-\t  _cpp_never_reread (inc);\n-\t  return false;\n+\t  open_file_failed (pfile, file);\n+\t  break;\n \t}\n-      /* Mark a regular, zero-length file never-reread.  We read it,\n-\t NUL-terminate it, and stack it once, so preprocessing a main\n-\t file of zero length does not raise an error.  */\n-      if (S_ISREG (inc->st.st_mode) && inc->st.st_size == 0)\n-\t_cpp_never_reread (inc);\n-      close (inc->fd);\n-      inc->fd = -1;\n-    }\n-\n-  if (pfile->buffer)\n-    /* We don't want MI guard advice for the main file.  */\n-    inc->include_count++;\n \n-  /* Push a buffer.  */\n-  fp = cpp_push_buffer (pfile, inc->buffer, inc->st.st_size,\n-\t\t\t/* from_stage3 */ CPP_OPTION (pfile, preprocessed), 0);\n-  fp->inc = inc;\n+      /* Only check the cache for the starting location (done above)\n+\t and the quote and bracket chain heads because there are no\n+\t other possible starting points for searches.  */\n+      if (file->dir != pfile->bracket_include\n+\t  && file->dir != pfile->quote_include)\n+\tcontinue;\n \n-  /* Initialize controlling macro state.  */\n-  pfile->mi_valid = true;\n-  pfile->mi_cmacro = 0;\n+      entry = search_cache (*hash_slot, file->dir);\n+      if (entry)\n+\t{\n+\t  /* Cache for START_DIR too, sharing the _cpp_file structure.  */\n+\t  free ((char *) file->name);\n+\t  free (file);\n+\t  file = entry->u.file;\n+\t  break;\n+\t}\n+    }\n \n-  /* Generate the call back.  */\n-  filename = inc->name;\n-  if (*filename == '\\0')\n-    filename = \"<stdin>\";\n-  _cpp_do_file_change (pfile, LC_ENTER, filename, 1, sysp);\n+  /* Store this new result in the hash table.  */\n+  entry = new_file_hash_entry (pfile);\n+  entry->next = *hash_slot;\n+  entry->start_dir = start_dir;\n+  entry->u.file = file;\n+  *hash_slot = entry;\n \n-  return true;\n+  return file;\n }\n \n-/* Read the file referenced by INC into the file cache.\n+/* Read a file into FILE->buffer, returning true on success.\n \n-   If fd points to a plain file, we might be able to mmap it; we can\n-   definitely allocate the buffer all at once.  If fd is a pipe or\n-   terminal, we can't do either.  If fd is something weird, like a\n-   block device, we don't want to read it at all.\n-\n-   Unfortunately, different systems use different st.st_mode values\n-   for pipes: some have S_ISFIFO, some S_ISSOCK, some are buggy and\n-   zero the entire struct stat except a couple fields.  Hence we don't\n-   even try to figure out what something is, except for plain files\n-   and block devices.\n+   If FILE->fd is something weird, like a block device, we don't want\n+   to read it at all.  Don't even try to figure out what something is,\n+   except for plain files and block devices, since there is no\n+   reliable portable way of doing this.\n \n    FIXME: Flush file cache and try again if we run out of memory.  */\n-static int\n-read_include_file (cpp_reader *pfile, struct include_file *inc)\n+static bool\n+read_file_guts (cpp_reader *pfile, _cpp_file *file)\n {\n-  ssize_t size, offset, count;\n+  ssize_t size, total, count;\n   uchar *buf;\n+  bool regular;\n+  \n+  if (S_ISBLK (file->st.st_mode))\n+    {\n+      cpp_error (pfile, DL_ERROR, \"%s is a block device\", file->name);\n+      return false;\n+    }\n \n-  if (S_ISREG (inc->st.st_mode))\n+  regular = S_ISREG (file->st.st_mode);\n+  if (regular)\n     {\n       /* off_t might have a wider range than ssize_t - in other words,\n \t the max size of a file might be bigger than the address\n@@ -448,191 +424,463 @@ read_include_file (cpp_reader *pfile, struct include_file *inc)\n \t SSIZE_MAX to be much smaller than the actual range of the\n \t type.  Use INTTYPE_MAXIMUM unconditionally to ensure this\n \t does not bite us.  */\n-      if (inc->st.st_size > INTTYPE_MAXIMUM (ssize_t))\n+      if (file->st.st_size > INTTYPE_MAXIMUM (ssize_t))\n \t{\n-\t  cpp_error (pfile, DL_ERROR, \"%s is too large\", inc->name);\n-\t  goto fail;\n+\t  cpp_error (pfile, DL_ERROR, \"%s is too large\", file->name);\n+\t  return false;\n \t}\n-      size = inc->st.st_size;\n \n+      size = file->st.st_size;\n+    }\n+  else\n+    /* 8 kilobytes is a sensible starting size.  It ought to be bigger\n+       than the kernel pipe buffer, and it's definitely bigger than\n+       the majority of C source files.  */\n+    size = 8 * 1024;\n+\n+  buf = xmalloc (size + 1);\n+  total = 0;\n+  while ((count = read (file->fd, buf + total, size - total)) > 0)\n+    {\n+      total += count;\n+\n+      if (total == size)\n \t{\n-\t  buf = xmalloc (size + 1);\n-\t  offset = 0;\n-\t  while (offset < size)\n-\t    {\n-\t      count = read (inc->fd, buf + offset, size - offset);\n-\t      if (count < 0)\n-\t\tgoto perror_fail;\n-\t      if (count == 0)\n-\t\t{\n-\t\t  if (!STAT_SIZE_TOO_BIG (inc->st))\n-\t\t    cpp_error (pfile, DL_WARNING,\n-\t\t\t       \"%s is shorter than expected\", inc->name);\n-\t\t  size = offset;\n-\t\t  buf = xrealloc (buf, size + 1);\n-\t\t  inc->st.st_size = size;\n-\t\t  break;\n-\t\t}\n-\t      offset += count;\n-\t    }\n-\t  /* The lexer requires that the buffer be \\n-terminated.  */\n-\t  buf[size] = '\\n';\n+\t  if (regular)\n+\t    break;\n+\t  size *= 2;\n+\t  buf = xrealloc (buf, size + 1);\n \t}\n     }\n-  else if (S_ISBLK (inc->st.st_mode))\n+\n+  if (count < 0)\n     {\n-      cpp_error (pfile, DL_ERROR, \"%s is a block device\", inc->name);\n-      goto fail;\n+      cpp_errno (pfile, DL_ERROR, file->name);\n+      return false;\n     }\n-  else\n+\n+  if (regular && total != size && STAT_SIZE_RELIABLE (file->st))\n+    cpp_error (pfile, DL_WARNING, \"%s is shorter than expected\", file->name);\n+\n+  /* Shrink buffer if we allocated substantially too much.  */\n+  if (total + 4096 < size)\n+    buf = xrealloc (buf, total + 1);\n+\n+  /* The lexer requires that the buffer be \\n-terminated.  */\n+  buf[total] = '\\n';\n+\n+  file->buffer = buf;\n+  file->st.st_size = total;\n+  file->buffer_valid = true;\n+\n+  return true;\n+}\n+\n+/* Convenience wrapper around read_file_guts that opens the file if\n+   necessary and closes the file desciptor after reading.  FILE must\n+   have been passed through find_file() at some stage.  */\n+static bool\n+read_file (cpp_reader *pfile, _cpp_file *file)\n+{\n+  /* Skip if the file had a header guard and the macro is defined.  */\n+  if (file->cmacro && file->cmacro->type == NT_MACRO)\n+    return false;\n+\n+  /* PCH files get dealt with immediately.  */\n+  if (include_pch_p (file))\n     {\n-      /* 8 kilobytes is a sensible starting size.  It ought to be\n-\t bigger than the kernel pipe buffer, and it's definitely\n-\t bigger than the majority of C source files.  */\n-      size = 8 * 1024;\n-\n-      buf = xmalloc (size + 1);\n-      offset = 0;\n-      while ((count = read (inc->fd, buf + offset, size - offset)) > 0)\n-\t{\n-\t  offset += count;\n-\t  if (offset == size)\n-\t    {\n-\t      size *= 2;\n-\t      buf = xrealloc (buf, size + 1);\n-\t    }\n-\t}\n-      if (count < 0)\n-\tgoto perror_fail;\n+      pfile->cb.read_pch (pfile, file->path, file->fd, file->pchname);\n+      close (file->fd);\n+      file->fd = -1;\n+      return false;\n+    }\n+\n+  /* If we already have its contents in memory, succeed immediately.  */\n+  if (file->buffer_valid)\n+    return true;\n \n-      if (offset + 1 < size)\n-\tbuf = xrealloc (buf, offset + 1);\n+  /* If an earlier read failed for some reason don't try again.  */\n+  if (file->dont_read || file->err_no)\n+    return false;\n \n-      /* The lexer requires that the buffer be \\n-terminated.  */\n-      buf[offset] = '\\n';\n-      inc->st.st_size = offset;\n+  if (file->fd == -1 && !open_file (file))\n+    {\n+      open_file_failed (pfile, file);\n+      return false;\n     }\n \n-  inc->buffer = buf;\n-  return 0;\n+  file->dont_read = !read_file_guts (pfile, file);\n+  close (file->fd);\n+  file->fd = -1;\n \n- perror_fail:\n-  cpp_errno (pfile, DL_ERROR, inc->name);\n- fail:\n-  return 1;\n+  return !file->dont_read;\n }\n \n-/* Drop INC's buffer from memory.  */\n-static void\n-purge_cache (struct include_file *inc)\n+/* Place the file referenced by FILE into a new buffer on the buffer\n+   stack if possible.  IMPORT is true if this stacking attempt is\n+   because of a #import directive.  Returns true if a buffer is\n+   stacked.  */\n+static bool\n+stack_file (cpp_reader *pfile, _cpp_file *file, bool import)\n {\n-  if (inc->buffer)\n+  cpp_buffer *buffer;\n+  int sysp;\n+  const char *fname;\n+\n+  if (once_only_file_p (pfile, file, import))\n+      return false;\n+\n+  sysp = MAX ((pfile->map ? pfile->map->sysp : 0),\n+\t      (file->dir ? file->dir->sysp : 0));\n+\n+  /* Add the file to the dependencies on its first inclusion.  */\n+  if (CPP_OPTION (pfile, deps.style) > !!sysp && !file->stack_count)\n     {\n-      free ((void *) inc->buffer);\n-      inc->buffer = NULL;\n+      if (!file->main_file || !CPP_OPTION (pfile, deps.ignore_main_file))\n+\tdeps_add_dep (pfile->deps, file->name);\n     }\n+\n+  if (!read_file (pfile, file))\n+    return false;\n+\n+  /* Clear buffer_valid since _cpp_clean_line messes it up.  */\n+  file->buffer_valid = false;\n+  file->stack_count++;\n+\n+  /* Stack the buffer.  */\n+  buffer = cpp_push_buffer (pfile, file->buffer, file->st.st_size,\n+\t\t\t    CPP_OPTION (pfile, preprocessed), 0);\n+  buffer->file = file;\n+\n+  /* Initialize controlling macro state.  */\n+  pfile->mi_valid = true;\n+  pfile->mi_cmacro = 0;\n+\n+  /* Generate the call back.  */\n+  fname = file->name;\n+  if (*fname == '\\0')\n+    fname = \"<stdin>\";\n+  _cpp_do_file_change (pfile, LC_ENTER, fname, 1, sysp);\n+\n+  return true;\n }\n \n-/* Return 1 if the file named by FNAME has been included before in\n-   any context, 0 otherwise.  */\n-int\n-cpp_included (cpp_reader *pfile, const char *fname)\n+/* Returns TRUE if FILE has been previously read and should not be\n+   read again.  */\n+static bool\n+once_only_file_p (cpp_reader *pfile, _cpp_file *file, bool import)\n {\n-  struct cpp_path *path;\n-  char *name, *n;\n-  splay_tree_node nd;\n+  _cpp_file *f;\n \n-  if (IS_ABSOLUTE_PATH (fname))\n+  /* Nothing to check if this isn't #import and there haven't been any\n+     #pragma_once directives.  */\n+  if (!import && !pfile->saw_pragma_once)\n+    return false;\n+\n+  /* Did this file contain #pragma once?  */\n+  if (file->pragma_once)\n+    return true;\n+\n+  /* Are we #import-ing a previously #import-ed file?  */\n+  if (import)\n     {\n-      /* Just look it up.  */\n-      nd = splay_tree_lookup (pfile->all_include_files, (splay_tree_key) fname);\n-      return (nd && nd->value);\n+      if (file->import)\n+\treturn true;\n+      _cpp_mark_file_once_only (pfile, file, true);\n     }\n \n-  /* Search directory path for the file.  */\n-  name = alloca (strlen (fname) + pfile->max_include_len + 2);\n-  for (path = pfile->quote_include; path; path = path->next)\n-    {\n-      memcpy (name, path->name, path->len);\n-      name[path->len] = '/';\n-      strcpy (&name[path->len + 1], fname);\n-      if (CPP_OPTION (pfile, remap))\n-\tn = remap_filename (pfile, name, path);\n-      else\n-\tn = name;\n+  /* Read the file contents now.  stack_file would do it later, and\n+     we're smart enough to not do it twice, so this is no loss.  */\n+  if (!read_file (pfile, file))\n+    return false;\n \n-      nd = splay_tree_lookup (pfile->all_include_files, (splay_tree_key) n);\n-      if (nd && nd->value)\n-\treturn 1;\n+  /* We may have #imported it under a different name, though.  Look\n+     for likely candidates and compare file contents to be sure.  */\n+  for (f = pfile->once_only_files; f; f = f->once_only_next)\n+    {\n+      if (f == file)\n+\tcontinue;\n+\n+      if (!f->pragma_once && !(f->import && import))\n+\tcontinue;\n+\n+      if (f->err_no == 0\n+\t  && f->st.st_mtime == file->st.st_mtime\n+\t  && f->st.st_size == file->st.st_size\n+\t  && read_file (pfile, f)\n+\t  /* Size might have changed in read_file().  */\n+\t  && f->st.st_size == file->st.st_size\n+\t  && !memcmp (f->buffer, file->buffer, f->st.st_size))\n+\treturn true;\n     }\n-  return 0;\n+\n+  return false;\n }\n \n-/* Search for FNAME.  Return 0 if there is no such file (or it's\n-   un-openable), in which case an error code will be in errno.  If\n-   there is no include path to use it returns NO_INCLUDE_PATH,\n-   otherwise an include_file structure.  If this request originates\n-   from a directive of TYPE #include_next, set INCLUDE_NEXT to true.  */\n-static struct include_file *\n-find_include_file (cpp_reader *pfile, const char *fname, int angle_brackets,\n-\t\t   enum include_type type)\n+/* Mark FILE to be included once only.  IMPORT is true if because of\n+   #import, otherwise it is assumed to be #pragma once.  */\n+void\n+_cpp_mark_file_once_only (cpp_reader *pfile, _cpp_file *file, bool import)\n {\n-  struct cpp_path *path;\n-  struct include_file *file;\n-  char *name, *n;\n+  if (import)\n+    file->import = true;\n+  else\n+    {\n+      pfile->saw_pragma_once = true;\n+      file->pragma_once = true;\n+    }\n \n-  if (*fname == '\\0')\n+  /* Put it on the once-only list if it's not on there already (an\n+     earlier #include with a #pragma once might have put it on there\n+     already).  */\n+  if (file->once_only_next == NULL)\n     {\n-      cpp_error (pfile, DL_ERROR, \"empty file name\");\n-      return NO_INCLUDE_PATH;\n+      file->once_only_next = pfile->once_only_files;\n+      pfile->once_only_files = file;\n     }\n+}\n+\n+/* Return the directory from which searching for FNAME should start,\n+   condiering the directive TYPE and ANGLE_BRACKETS.  If there is\n+   nothing left in the path, returns NULL.  */\n+static struct cpp_dir *\n+search_path_head (cpp_reader *pfile, const char *fname, int angle_brackets,\n+\t\t  enum include_type type)\n+{\n+  cpp_dir *dir;\n+  _cpp_file *file;\n \n   if (IS_ABSOLUTE_PATH (fname))\n-    return open_file_pch (pfile, fname);\n+    return &pfile->no_search_path;\n+\n+  file = pfile->buffer->file;\n \n   /* For #include_next, skip in the search path past the dir in which\n      the current file was found, but if it was found via an absolute\n      path use the normal search logic.  */\n-  if (type == IT_INCLUDE_NEXT && pfile->buffer->inc->foundhere)\n-    path = pfile->buffer->inc->foundhere->next;\n+  if (type == IT_INCLUDE_NEXT && file->dir)\n+    dir = file->dir->next;\n   else if (angle_brackets)\n-    path = pfile->bracket_include;\n+    dir = pfile->bracket_include;\n+  else if (type == IT_CMDLINE)\n+    /* -include and -imacros use the #include \"\" chain with the\n+       preprocessor's cwd prepended.  */\n+    return make_cpp_dir (pfile, \"./\", false);\n+  else if (pfile->quote_ignores_source_dir)\n+    dir = pfile->quote_include;\n   else\n-    path = search_from (pfile, type);\n+    return make_cpp_dir (pfile, dir_name_of_file (file), pfile->map->sysp);\n+\n+  if (dir == NULL)\n+    cpp_error (pfile, DL_ERROR,\n+\t       \"no include path in which to search for %s\", fname);\n+\n+  return dir;\n+}\n \n-  if (path == NULL)\n+/* Strip the basename from the file's path.  It ends with a slash if\n+   of non-zero length.  Note that this procedure also works for\n+   <stdin>, which is represented by the empty string.  */\n+static const char *\n+dir_name_of_file (_cpp_file *file)\n+{\n+  if (!file->dir_name)\n     {\n-      cpp_error (pfile, DL_ERROR, \"no include path in which to find %s\",\n-\t\t fname);\n-      return NO_INCLUDE_PATH;\n+      size_t len = lbasename (file->path) - file->path;\n+      char *dir_name = xmalloc (len + 1);\n+\n+      memcpy (dir_name, file->path, len);\n+      dir_name[len] = '\\0';\n+      file->dir_name = dir_name;\n     }\n \n-  /* Search directory path for the file.  */\n-  name = alloca (strlen (fname) + pfile->max_include_len + 2);\n-  for (; path; path = path->next)\n+  return file->dir_name;\n+}\n+\n+/* Push an input buffer with the contents of FNAME, the empty string\n+   for standard input.  Return true if a buffer was stacked.  */\n+bool\n+cpp_stack_file (cpp_reader *pfile, const char *fname)\n+{\n+  struct cpp_dir *dir = &pfile->no_search_path;\n+\n+  return stack_file (pfile, find_file (pfile, fname, dir, false), false);\n+}\n+\n+/* Handles #include-family directives (distinguished by TYPE),\n+   including HEADER, and the command line -imacros and -include.\n+   Returns true if a buffer was stacked.  */\n+bool\n+_cpp_stack_include (cpp_reader *pfile, const char *fname, int angle_brackets,\n+\t\t    enum include_type type)\n+{\n+  struct cpp_dir *dir;\n+\n+  dir = search_path_head (pfile, fname, angle_brackets, type);\n+  if (!dir)\n+    return false;\n+\n+  return stack_file (pfile, find_file (pfile, fname, dir, false),\n+\t\t     type == IT_IMPORT);\n+}\n+\n+/* Could not open FILE.  The complication is dependency output.  */\n+static void\n+open_file_failed (cpp_reader *pfile, _cpp_file *file)\n+{\n+  int sysp = pfile->map ? pfile->map->sysp: 0;\n+  bool print_dep = CPP_OPTION (pfile, deps.style) > !!sysp;\n+\n+  errno = file->err_no;\n+  if (print_dep && CPP_OPTION (pfile, deps.missing_files) && errno == ENOENT)\n+    deps_add_dep (pfile->deps, file->name);\n+  else\n     {\n-      int len = path->len;\n-      memcpy (name, path->name, len);\n-      /* Don't turn / into // or // into ///; // may be a namespace\n-\t escape.  */\n-      if (name[len-1] == '/')\n-\tlen--;\n-      name[len] = '/';\n-      strcpy (&name[len + 1], fname);\n-      if (CPP_OPTION (pfile, remap))\n-\tn = remap_filename (pfile, name, path);\n+      /* If we are outputting dependencies but not for this file then\n+\t don't error because we can still produce correct output.  */\n+      if (CPP_OPTION (pfile, deps.style) && ! print_dep)\n+\tcpp_errno (pfile, DL_WARNING, file->name);\n       else\n-\tn = name;\n-\n-      file = open_file_pch (pfile, n);\n-      if (file)\n-\t{\n-\t  file->foundhere = path;\n-\t  return file;\n-\t}\n+\tcpp_errno (pfile, DL_ERROR, file->name);\n     }\n+}\n \n-  return 0;\n+/* Search in the chain beginning at HEAD for a file whose search path\n+   started at START_DIR != NULL.  */\n+static struct file_hash_entry *\n+search_cache (struct file_hash_entry *head, const cpp_dir *start_dir)\n+{\n+  while (head && head->start_dir != start_dir)\n+    head = head->next;\n+\n+  return head;\n+}\n+\n+/* Allocate a new _cpp_file structure.  */\n+static _cpp_file *\n+make_cpp_file (cpp_reader *pfile, cpp_dir *dir, const char *fname)\n+{\n+  _cpp_file *file;\n+\n+  file = xcalloc (1, sizeof (_cpp_file));\n+  file->main_file = !pfile->buffer;\n+  file->fd = -1;\n+  file->dir = dir;\n+  file->name = xstrdup (fname);\n+\n+  return file;\n+}\n+\n+/* A hash of directory names.  The directory names are the path names\n+   of files which contain a #include \"\", the included file name is\n+   appended to this directories.\n+\n+   To avoid duplicate entries we follow the convention that all\n+   non-empty directory names should end in a '/'.  DIR_NAME must be\n+   stored in permanently allocated memory.  */\n+static cpp_dir *\n+make_cpp_dir (cpp_reader *pfile, const char *dir_name, int sysp)\n+{\n+  struct file_hash_entry *entry, **hash_slot;\n+  cpp_dir *dir;\n+\n+  hash_slot = (struct file_hash_entry **)\n+    htab_find_slot (pfile->file_hash, dir_name, INSERT);\n+\n+  /* Have we already hashed this directory?  */\n+  for (entry = *hash_slot; entry; entry = entry->next)\n+    if (entry->start_dir == NULL)\n+      return entry->u.dir;\n+\n+  dir = xcalloc (1, sizeof (cpp_dir));\n+  dir->next = pfile->quote_include;\n+  dir->name = (char *) dir_name;\n+  dir->len = strlen (dir_name);\n+  dir->sysp = sysp;\n+\n+  /* Store this new result in the hash table.  */\n+  entry = new_file_hash_entry (pfile);\n+  entry->next = *hash_slot;\n+  entry->start_dir = NULL;\n+  entry->u.dir = dir;\n+  *hash_slot = entry;\n+\n+  return dir;\n+}\n+\n+/* Create a new block of memory for file hash entries.  */\n+static void\n+allocate_file_hash_entries (cpp_reader *pfile)\n+{\n+  pfile->file_hash_entries_used = 0;\n+  pfile->file_hash_entries_allocated = 127;\n+  pfile->file_hash_entries = xmalloc\n+    (pfile->file_hash_entries_allocated * sizeof (struct file_hash_entry));\n+}\n+\n+/* Return a new file hash entry.  */\n+static struct file_hash_entry *\n+new_file_hash_entry (cpp_reader *pfile)\n+{\n+  if (pfile->file_hash_entries_used == pfile->file_hash_entries_allocated)\n+    allocate_file_hash_entries (pfile);\n+\n+  return &pfile->file_hash_entries[pfile->file_hash_entries_used++];\n+}\n+\n+/* Returns TRUE if a file FNAME has ever been successfully opened.\n+   This routine is not intended to correctly handle filenames aliased\n+   by links or redundant . or .. traversals etc.  */\n+bool\n+cpp_included (cpp_reader *pfile, const char *fname)\n+{\n+  struct file_hash_entry *entry;\n+\n+  entry = htab_find (pfile->file_hash, fname);\n+\n+  while (entry && (entry->start_dir == NULL || entry->u.file->err_no))\n+    entry = entry->next;\n+\n+  return entry != NULL;\n+}\n+\n+/* Compare a string Q against a file hash entry P.  */\n+static int\n+hash_string_eq (const void *p, const void *q)\n+{\n+  struct file_hash_entry *entry = (struct file_hash_entry *) p;\n+  const char *fname = (const char *) q;\n+  const char *hname;\n+\n+  if (entry->start_dir)\n+    hname = entry->u.file->name;\n+  else\n+    hname = entry->u.dir->name;\n+\n+  return strcmp (hname, fname) == 0;\n+}\n+\n+/* Initialize everything in this source file.  */\n+void\n+_cpp_init_files (cpp_reader *pfile)\n+{\n+  pfile->file_hash = htab_create_alloc (127, htab_hash_string, hash_string_eq,\n+\t\t\t\t\tNULL, xcalloc, free);\n+  allocate_file_hash_entries (pfile);\n+}\n+\n+/* Finalize everything in this source file.  */\n+void\n+_cpp_cleanup_files (cpp_reader *pfile)\n+{\n+  htab_delete (pfile->file_hash);\n+}\n+\n+/* Enter a file name in the hash for the sake of cpp_included.  */\n+void\n+_cpp_fake_include (cpp_reader *pfile, const char *fname)\n+{\n+  find_file (pfile, fname, pfile->buffer->file->dir, true);\n }\n \n /* Not everyone who wants to set system-header-ness on a buffer can\n@@ -660,79 +908,44 @@ cpp_change_file (cpp_reader *pfile, enum lc_reason reason,\n   _cpp_do_file_change (pfile, reason, new_name, 1, 0);\n }\n \n-/* Report on all files that might benefit from a multiple include guard.\n-   Triggered by -H.  */\n-void\n-_cpp_report_missing_guards (cpp_reader *pfile)\n-{\n-  int banner = 0;\n-  splay_tree_foreach (pfile->all_include_files, report_missing_guard, &banner);\n-}\n-\n-/* Callback function for splay_tree_foreach().  */\n+/* Callback function for htab_traverse.  */\n static int\n-report_missing_guard (splay_tree_node n, void *b)\n+report_missing_guard (void **slot, void *b)\n {\n-  struct include_file *f = (struct include_file *) n->value;\n+  struct file_hash_entry *entry = (struct file_hash_entry *) *slot;\n   int *bannerp = (int *) b;\n \n-  if (f && f->cmacro == 0 && f->include_count == 1)\n+  /* Skip directories.  */\n+  if (entry->start_dir != NULL)\n     {\n-      if (*bannerp == 0)\n+      _cpp_file *file = entry->u.file;\n+\n+      /* We don't want MI guard advice for the main file.  */\n+      if (file->cmacro == NULL && file->stack_count == 1 && !file->main_file)\n \t{\n-\t  fputs (_(\"Multiple include guards may be useful for:\\n\"), stderr);\n-\t  *bannerp = 1;\n+\t  if (*bannerp == 0)\n+\t    {\n+\t      fputs (_(\"Multiple include guards may be useful for:\\n\"),\n+\t\t     stderr);\n+\t      *bannerp = 1;\n+\t    }\n+\n+\t  fputs (entry->u.file->path, stderr);\n+\t  putc ('\\n', stderr);\n \t}\n-      fputs (f->name, stderr);\n-      putc ('\\n', stderr);\n     }\n-  return 0;\n-}\n \n-/* Create a dependency for file FNAME, or issue an error message as\n-   appropriate.  ANGLE_BRACKETS is nonzero if the file was bracketed\n-   like <..>.  */\n-static void\n-handle_missing_header (cpp_reader *pfile, const char *fname,\n-\t\t       int angle_brackets)\n-{\n-  bool print_dep\n-    = CPP_OPTION (pfile, deps.style) > (angle_brackets || pfile->map->sysp);\n-\n-  if (CPP_OPTION (pfile, deps.missing_files) && print_dep)\n-    deps_add_dep (pfile->deps, fname);\n-  /* If -M was specified, then don't count this as an error, because\n-     we can still produce correct output.  Otherwise, we can't produce\n-     correct output, because there may be dependencies we need inside\n-     the missing file, and we don't know what directory this missing\n-     file exists in.  */\n-  else\n-    cpp_errno (pfile, CPP_OPTION (pfile, deps.style) && ! print_dep\n-\t       ? DL_WARNING: DL_ERROR, fname);\n+  return 0;\n }\n \n-/* Handles #include-family directives (distinguished by TYPE),\n-   including HEADER, and the command line -imacros and -include.\n-   Returns true if a buffer was stacked.  */\n-bool\n-_cpp_execute_include (cpp_reader *pfile, const char *fname, int angle_brackets,\n-\t\t      enum include_type type)\n+/* Report on all files that might benefit from a multiple include guard.\n+   Triggered by -H.  */\n+void\n+_cpp_report_missing_guards (cpp_reader *pfile)\n {\n-  bool stacked = false;\n-  struct include_file *inc;\n-\n-  inc = find_include_file (pfile, fname, angle_brackets, type);\n-  if (inc == 0)\n-    handle_missing_header (pfile, fname, angle_brackets);\n-  else if (inc != NO_INCLUDE_PATH)\n-    {\n-      stacked = stack_include_file (pfile, inc);\n-\n-      if (type == IT_IMPORT)\n-\t_cpp_never_reread (inc);\n-    }\n+  int banner = 0;\n \n-  return stacked;\n+  htab_traverse (pfile->file_hash, report_missing_guard, &banner);\n }\n \n /* Locate HEADER, and determine whether it is newer than the current\n@@ -742,134 +955,96 @@ int\n _cpp_compare_file_date (cpp_reader *pfile, const char *fname,\n \t\t\tint angle_brackets)\n {\n-  struct include_file *inc;\n+  _cpp_file *file;\n+  struct cpp_dir *dir;\n \n-  inc = find_include_file (pfile, fname, angle_brackets, IT_INCLUDE);\n-  if (inc == NULL || inc == NO_INCLUDE_PATH)\n+  dir = search_path_head (pfile, fname, angle_brackets, IT_INCLUDE);\n+  if (!dir)\n     return -1;\n \n-  if (inc->fd > 0)\n-    {\n-      close (inc->fd);\n-      inc->fd = -1;\n-    }\n-\n-  return inc->st.st_mtime > pfile->buffer->inc->st.st_mtime;\n-}\n-\n-\n-/* Push an input buffer and load it up with the contents of FNAME.  If\n-   FNAME is \"\", read standard input.  Return true if a buffer was\n-   stacked.  */\n-bool\n-_cpp_read_file (cpp_reader *pfile, const char *fname)\n-{\n-  /* This uses open_file, because we don't allow a PCH to be used as\n-     the toplevel compilation (that would prevent re-compiling an\n-     existing PCH without deleting it first).  */\n-  struct include_file *f = open_file (pfile, fname);\n+  file = find_file (pfile, fname, dir, false);\n+  if (file->err_no)\n+    return -1;\n \n-  if (f == NULL)\n+  if (file->fd != -1)\n     {\n-      cpp_errno (pfile, DL_ERROR, fname);\n-      return false;\n+      close (file->fd);\n+      file->fd = -1;\n     }\n \n-  return stack_include_file (pfile, f);\n+  return file->st.st_mtime > pfile->buffer->file->st.st_mtime;\n }\n \n /* Pushes the given file onto the buffer stack.  Returns nonzero if\n    successful.  */\n bool\n-cpp_push_include (cpp_reader *pfile, const char *filename)\n+cpp_push_include (cpp_reader *pfile, const char *fname)\n {\n   /* Make the command line directive take up a line.  */\n   pfile->line++;\n-  return _cpp_execute_include (pfile, filename, false, IT_CMDLINE);\n+  return _cpp_stack_include (pfile, fname, false, IT_CMDLINE);\n }\n \n /* Do appropriate cleanup when a file INC's buffer is popped off the\n    input stack.  */\n void\n-_cpp_pop_file_buffer (cpp_reader *pfile, struct include_file *inc)\n+_cpp_pop_file_buffer (cpp_reader *pfile, _cpp_file *file)\n {\n   /* Record the inclusion-preventing macro, which could be NULL\n      meaning no controlling macro.  */\n-  if (pfile->mi_valid && inc->cmacro == NULL)\n-    inc->cmacro = pfile->mi_cmacro;\n+  if (pfile->mi_valid && file->cmacro == NULL)\n+    file->cmacro = pfile->mi_cmacro;\n \n   /* Invalidate control macros in the #including file.  */\n   pfile->mi_valid = false;\n \n-  purge_cache (inc);\n+  if (file->buffer)\n+    {\n+      free ((void *) file->buffer);\n+      file->buffer = NULL;\n+    }\n }\n \n-/* Returns the first place in the include chain to start searching for\n-   \"\" includes.  This involves stripping away the basename of the\n-   current file, unless -I- was specified.\n+/* Set the include chain for \"\" to QUOTE, for <> to BRACKET.  If\n+   QUOTE_IGNORES_SOURCE_DIR, then \"\" includes do not look in the\n+   directory of the including file.\n \n-   If we're handling -include or -imacros, use the \"\" chain, but with\n-   the preprocessor's cwd prepended.  */\n-static struct cpp_path *\n-search_from (cpp_reader *pfile, enum include_type type)\n+   If BRACKET does not lie in the QUOTE chain, it is set to QUOTE.  */\n+void\n+cpp_set_include_chains (cpp_reader *pfile, cpp_dir *quote, cpp_dir *bracket,\n+\t\t\tint quote_ignores_source_dir)\n {\n-  cpp_buffer *buffer = pfile->buffer;\n-  unsigned int dlen;\n-\n-  /* Command line uses the cwd, and does not cache the result.  */\n-  if (type == IT_CMDLINE)\n-    goto use_cwd;\n-\n-  /* Ignore the current file's directory?  */\n-  if (pfile->quote_ignores_source_dir)\n-    return pfile->quote_include;\n+  pfile->quote_include = quote;\n+  pfile->bracket_include = quote;\n+  pfile->quote_ignores_source_dir = quote_ignores_source_dir;\n \n-  if (! buffer->search_cached)\n+  for (; quote; quote = quote->next)\n     {\n-      buffer->search_cached = 1;\n-\n-      dlen = lbasename (buffer->inc->name) - buffer->inc->name;\n-\n-      if (dlen)\n-\t{\n-\t  /* We don't guarantee NAME is null-terminated.  This saves\n-\t     allocating and freeing memory.  Drop a trailing '/'.  */\n-\t  buffer->dir.name = (char *) buffer->inc->name;\n-\t  if (dlen > 1)\n-\t    dlen--;\n-\t}\n-      else\n-\t{\n-\tuse_cwd:\n-\t  buffer->dir.name = (char *) \".\";\n-\t  dlen = 1;\n-\t}\n-\n-      if (dlen > pfile->max_include_len)\n-\tpfile->max_include_len = dlen;\n-\n-      buffer->dir.len = dlen;\n-      buffer->dir.next = pfile->quote_include;\n-      buffer->dir.sysp = pfile->map->sysp;\n+      quote->name_map = NULL;\n+      quote->len = strlen (quote->name);\n+      if (quote == bracket)\n+\tpfile->bracket_include = bracket;\n     }\n-\n-  return &buffer->dir;\n }\n \n-/* The file_name_map structure holds a mapping of file names for a\n-   particular directory.  This mapping is read from the file named\n-   FILE_NAME_MAP_FILE in that directory.  Such a file can be used to\n-   map filenames on a file system with severe filename restrictions,\n-   such as DOS.  The format of the file name map file is just a series\n-   of lines with two tokens on each line.  The first token is the name\n-   to map, and the second token is the actual name to use.  */\n-struct file_name_map {\n-  struct file_name_map *map_next;\n-  char *map_from;\n-  char *map_to;\n-};\n-\n-#define FILE_NAME_MAP_FILE \"header.gcc\"\n+/* Append the file name to the directory to create the path, but don't\n+   turn / into // or // into ///; // may be a namespace escape.  */\n+static char *\n+append_file_to_dir (const char *fname, cpp_dir *dir)\n+{\n+  size_t dlen, flen;\n+  char *path;\n+\n+  dlen = dir->len;\n+  flen = strlen (fname);\n+  path = xmalloc (dlen + 1 + flen + 1);\n+  memcpy (path, dir->name, dlen);\n+  if (dlen && path[dlen - 1] != '/')\n+    path[dlen++] = '/';\n+  memcpy (&path[dlen], fname, flen + 1);\n+\n+  return path;\n+}\n \n /* Read a space delimited string of unlimited length from a stdio\n    file F.  */\n@@ -900,310 +1075,144 @@ read_filename_string (int ch, FILE *f)\n   return alloc;\n }\n \n-/* This structure holds a linked list of file name maps, one per directory.  */\n-struct file_name_map_list {\n-  struct file_name_map_list *map_list_next;\n-  char *map_list_name;\n-  struct file_name_map *map_list_map;\n-};\n-\n-/* Read the file name map file for DIRNAME.  */\n-static struct file_name_map *\n-read_name_map (cpp_reader *pfile, const char *dirname)\n+/* Read the file name map file for DIR.  */\n+static void\n+read_name_map (cpp_dir *dir)\n {\n-  struct file_name_map_list *map_list_ptr;\n+  static const char FILE_NAME_MAP_FILE[] = \"header.gcc\";\n   char *name;\n   FILE *f;\n-\n-  /* Check the cache of directories, and mappings in their remap file.  */\n-  for (map_list_ptr = CPP_OPTION (pfile, map_list); map_list_ptr;\n-       map_list_ptr = map_list_ptr->map_list_next)\n-    if (! strcmp (map_list_ptr->map_list_name, dirname))\n-      return map_list_ptr->map_list_map;\n-\n-  map_list_ptr = xmalloc (sizeof (struct file_name_map_list));\n-  map_list_ptr->map_list_name = xstrdup (dirname);\n-\n-  /* The end of the list ends in NULL.  */\n-  map_list_ptr->map_list_map = NULL;\n-\n-  name = alloca (strlen (dirname) + strlen (FILE_NAME_MAP_FILE) + 2);\n-  strcpy (name, dirname);\n-  if (*dirname)\n-    strcat (name, \"/\");\n-  strcat (name, FILE_NAME_MAP_FILE);\n+  size_t len, count = 0, room = 9;\n+\n+  len = dir->len;\n+  name = alloca (len + sizeof (FILE_NAME_MAP_FILE) + 1);\n+  memcpy (name, dir->name, len);\n+  if (len && name[len - 1] != '/')\n+    name[len++] = '/';\n+  strcpy (name + len, FILE_NAME_MAP_FILE);\n   f = fopen (name, \"r\");\n \n+  dir->name_map = xmalloc (room * sizeof (char *));\n+\n   /* Silently return NULL if we cannot open.  */\n   if (f)\n     {\n       int ch;\n \n       while ((ch = getc (f)) != EOF)\n \t{\n-\t  char *from, *to;\n-\t  struct file_name_map *ptr;\n+\t  char *to;\n \n \t  if (is_space (ch))\n \t    continue;\n-\t  from = read_filename_string (ch, f);\n+\n+\t  if (count + 2 > room)\n+\t    {\n+\t      room += 8;\n+\t      dir->name_map = xrealloc (dir->name_map, room * sizeof (char *));\n+\t    }\n+\n+\t  dir->name_map[count] = read_filename_string (ch, f);\n \t  while ((ch = getc (f)) != EOF && is_hspace (ch))\n \t    ;\n-\t  to = read_filename_string (ch, f);\n-\n-\t  ptr = xmalloc (sizeof (struct file_name_map));\n-\t  ptr->map_from = from;\n \n-\t  /* Make the real filename absolute.  */\n+\t  to = read_filename_string (ch, f);\n \t  if (IS_ABSOLUTE_PATH (to))\n-\t    ptr->map_to = to;\n+\t    dir->name_map[count + 1] = to;\n \t  else\n \t    {\n-\t      ptr->map_to = concat (dirname, \"/\", to, NULL);\n+\t      dir->name_map[count + 1] = append_file_to_dir (to, dir);\n \t      free (to);\n \t    }\n \n-\t  ptr->map_next = map_list_ptr->map_list_map;\n-\t  map_list_ptr->map_list_map = ptr;\n-\n+\t  count += 2;\n \t  while ((ch = getc (f)) != '\\n')\n \t    if (ch == EOF)\n \t      break;\n \t}\n+\n       fclose (f);\n     }\n \n-  /* Add this information to the cache.  */\n-  map_list_ptr->map_list_next = CPP_OPTION (pfile, map_list);\n-  CPP_OPTION (pfile, map_list) = map_list_ptr;\n-\n-  return map_list_ptr->map_list_map;\n+  /* Terminate the list of maps.  */\n+  dir->name_map[count] = NULL;\n }\n \n-/* Remap an unsimplified path NAME based on the file_name_map (if any)\n-   for LOC.  */\n+/* Remap a FILE's name based on the file_name_map, if any, for\n+   FILE->dir.  If the file name has any directory separators,\n+   recursively check those directories too.  */\n static char *\n-remap_filename (cpp_reader *pfile, char *name, struct cpp_path *loc)\n+remap_filename (cpp_reader *pfile, _cpp_file *file)\n {\n-  struct file_name_map *map;\n-  const char *from, *p;\n-  char *dir;\n-\n-  if (! loc->name_map)\n-    {\n-      /* Get a null-terminated path.  */\n-      char *dname = alloca (loc->len + 1);\n-      memcpy (dname, loc->name, loc->len);\n-      dname[loc->len] = '\\0';\n-\n-      loc->name_map = read_name_map (pfile, dname);\n-      if (! loc->name_map)\n-\treturn name;\n-    }\n-\n-  /* This works since NAME has not been simplified yet.  */\n-  from = name + loc->len + 1;\n-\n-  for (map = loc->name_map; map; map = map->map_next)\n-    if (!strcmp (map->map_from, from))\n-      return map->map_to;\n-\n-  /* Try to find a mapping file for the particular directory we are\n-     looking in.  Thus #include <sys/types.h> will look up sys/types.h\n-     in /usr/include/header.gcc and look up types.h in\n-     /usr/include/sys/header.gcc.  */\n-  p = strrchr (name, '/');\n-  if (!p)\n-    return name;\n-\n-  /* We know p != name as absolute paths don't call remap_filename.  */\n-  if (p == name)\n-    cpp_error (pfile, DL_ICE, \"absolute file name in remap_filename\");\n+  const char *fname, *p;\n+  char *new_dir;\n+  cpp_dir *dir;\n+  size_t index, len;\n \n-  dir = alloca (p - name + 1);\n-  memcpy (dir, name, p - name);\n-  dir[p - name] = '\\0';\n-  from = p + 1;\n+  dir = file->dir;\n+  fname = file->name;\n \n-  for (map = read_name_map (pfile, dir); map; map = map->map_next)\n-    if (! strcmp (map->map_from, from))\n-      return map->map_to;\n+  for (;;)\n+    {\n+      if (!dir->name_map)\n+\tread_name_map (dir);\n \n-  return name;\n-}\n+      for (index = 0; dir->name_map[index]; index += 2)\n+\tif (!strcmp (dir->name_map[index], fname))\n+\t    return xstrdup (dir->name_map[index + 1]);\n \n-/* Set the include chain for \"\" to QUOTE, for <> to BRACKET.  If\n-   QUOTE_IGNORES_SOURCE_DIR, then \"\" includes do not look in the\n-   directory of the including file.\n+      p = strchr (fname, '/');\n+      if (!p || p == fname)\n+\treturn NULL;\n \n-   If BRACKET does not lie in the QUOTE chain, it is set to QUOTE.  */\n-void\n-cpp_set_include_chains (cpp_reader *pfile, cpp_path *quote, cpp_path *bracket,\n-\t\t\tint quote_ignores_source_dir)\n-{\n-  pfile->quote_include = quote;\n-  pfile->bracket_include = quote;\n-  pfile->quote_ignores_source_dir = quote_ignores_source_dir;\n-  pfile->max_include_len = 0;\n+      len = dir->len + (p - fname + 1);\n+      new_dir = xmalloc (len + 1);\n+      memcpy (new_dir, dir->name, dir->len);\n+      memcpy (new_dir + dir->len, fname, p - fname + 1);\n+      new_dir[len] = '\\0';\n \n-  for (; quote; quote = quote->next)\n-    {\n-      quote->name_map = NULL;\n-      quote->len = strlen (quote->name);\n-      if (quote->len > pfile->max_include_len)\n-\tpfile->max_include_len = quote->len;\n-      if (quote == bracket)\n-\tpfile->bracket_include = bracket;\n+      dir = make_cpp_dir (pfile, new_dir, dir->sysp);\n+      fname = p + 1;\n     }\n }\n \n-/* Returns true if it is safe to remove the final component of path,\n-   when it is followed by a \"..\" component.  We use lstat to avoid\n-   symlinks if we have it.  If not, we can still catch errors with\n-   stat ().  */\n-static int\n-remove_component_p (const char *path)\n+/* Return true if FILE is usable by PCH.  */\n+static bool\n+include_pch_p (_cpp_file *file)\n {\n-  struct stat s;\n-  int result;\n-\n-#ifdef HAVE_LSTAT\n-  result = lstat (path, &s);\n-#else\n-  result = stat (path, &s);\n-#endif\n-\n-  /* There's no guarantee that errno will be unchanged, even on\n-     success.  Cygwin's lstat(), for example, will often set errno to\n-     ENOSYS.  In case of success, reset errno to zero.  */\n-  if (result == 0)\n-    errno = 0;\n-\n-  return result == 0 && S_ISDIR (s.st_mode);\n+  return file->pch & 1;\n }\n \n-/* Simplify a path name in place, deleting redundant components.  This\n-   reduces OS overhead and guarantees that equivalent paths compare\n-   the same (modulo symlinks).\n-\n-   Transforms made:\n-   foo/bar/../quux\tfoo/quux\n-   foo/./bar\t\tfoo/bar\n-   foo//bar\t\tfoo/bar\n-   /../quux\t\t/quux\n-   //quux\t\t//quux  (POSIX allows leading // as a namespace escape)\n-\n-   Guarantees no trailing slashes.  All transforms reduce the length\n-   of the string.  Returns PATH.  errno is 0 if no error occurred;\n-   nonzero if an error occurred when using stat () or lstat ().  */\n-void\n-cpp_simplify_path (char *path ATTRIBUTE_UNUSED)\n+/* Returns true if PCHNAME is a valid PCH file for FILE.  */\n+static bool\n+validate_pch (cpp_reader *pfile, _cpp_file *file, const char *pchname)\n {\n-#ifndef VMS\n-  char *from, *to;\n-  char *base, *orig_base;\n-  int absolute = 0;\n-\n-  errno = 0;\n-  /* Don't overflow the empty path by putting a '.' in it below.  */\n-  if (*path == '\\0')\n-    return;\n-\n-#if defined (HAVE_DOS_BASED_FILE_SYSTEM)\n-  /* Convert all backslashes to slashes.  */\n-  for (from = path; *from; from++)\n-    if (*from == '\\\\') *from = '/';\n-\n-  /* Skip over leading drive letter if present.  */\n-  if (ISALPHA (path[0]) && path[1] == ':')\n-    from = to = &path[2];\n-  else\n-    from = to = path;\n-#else\n-  from = to = path;\n-#endif\n+  const char *saved_path = file->path;\n \n-  /* Remove redundant leading /s.  */\n-  if (*from == '/')\n+  file->path = pchname;\n+  if (open_file (file))\n     {\n-      absolute = 1;\n-      to++;\n-      from++;\n-      if (*from == '/')\n+      if ((file->pch & 2) == 0)\n+\tfile->pch = pfile->cb.valid_pch (pfile, pchname, file->fd);\n+\n+      if (!include_pch_p (file))\n \t{\n-\t  if (*++from == '/')\n-\t    /* 3 or more initial /s are equivalent to 1 /.  */\n-\t    while (*++from == '/');\n-\t  else\n-\t    /* On some hosts // differs from /; Posix allows this.  */\n-\t    to++;\n+\t  close (file->fd);\n+\t  file->fd = -1;\n \t}\n-    }\n-\n-  base = orig_base = to;\n-  for (;;)\n-    {\n-      int move_base = 0;\n-\n-      while (*from == '/')\n-\tfrom++;\n-\n-      if (*from == '\\0')\n-\tbreak;\n \n-      if (*from == '.')\n+      if (CPP_OPTION (pfile, print_include_names))\n \t{\n-\t  if (from[1] == '\\0')\n-\t    break;\n-\t  if (from[1] == '/')\n-\t    {\n-\t      from += 2;\n-\t      continue;\n-\t    }\n-\t  else if (from[1] == '.' && (from[2] == '/' || from[2] == '\\0'))\n-\t    {\n-\t      /* Don't simplify if there was no previous component.  */\n-\t      if (absolute && orig_base == to)\n-\t\t{\n-\t\t  from += 2;\n-\t\t  continue;\n-\t\t}\n-\t      /* Don't simplify if the previous component was \"../\",\n-\t\t or if an error has already occurred with (l)stat.  */\n-\t      if (base != to && errno == 0)\n-\t\t{\n-\t\t  /* We don't back up if it's a symlink.  */\n-\t\t  *to = '\\0';\n-\t\t  if (remove_component_p (path))\n-\t\t    {\n-\t\t      while (to > base && *to != '/')\n-\t\t\tto--;\n-\t\t      from += 2;\n-\t\t      continue;\n-\t\t    }\n-\t\t}\n-\t      move_base = 1;\n-\t    }\n+\t  unsigned int i;\n+\t  for (i = 1; i < pfile->line_maps.depth; i++)\n+\t    putc ('.', stderr);\n+\t  fprintf (stderr, \"%c %s\\n\",\n+\t\t   include_pch_p (file) ? '!' : 'x', pchname);\n \t}\n-\n-      /* Add the component separator.  */\n-      if (to > orig_base)\n-\t*to++ = '/';\n-\n-      /* Copy this component until the trailing null or '/'.  */\n-      while (*from != '\\0' && *from != '/')\n-\t*to++ = *from++;\n-\n-      if (move_base)\n-\tbase = to;\n     }\n+  else\n+    file->pch = 2;\n \n-  /* Change the empty string to \".\" so that it is not treated as stdin.\n-     Null terminate.  */\n-  if (to == path)\n-    *to++ = '.';\n-  *to = '\\0';\n-#else  /* VMS */\n-  errno = 0;\n-#endif /* !VMS  */\n+  file->path = saved_path;\n+  return include_pch_p (file);\n }"}, {"sha": "e4378cb89d0556f43a40a5afed31278bcedf1e9d", "filename": "gcc/cpphash.h", "status": "modified", "additions": 32, "deletions": 25, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f9b40094d6e960d965e632f6537bf6eaa980ab5/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f9b40094d6e960d965e632f6537bf6eaa980ab5/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=8f9b40094d6e960d965e632f6537bf6eaa980ab5", "patch": "@@ -24,6 +24,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #define GCC_CPPHASH_H\n \n #include \"hashtable.h\"\n+#include \"hashtab.h\"\n \n #ifdef HAVE_ICONV\n #include <iconv.h>\n@@ -36,6 +37,7 @@ struct directive;\t\t/* Deliberately incomplete.  */\n struct pending_option;\n struct op;\n struct strbuf;\n+struct _cpp_file;\n \n typedef bool (*convert_f) (iconv_t, const unsigned char *, size_t,\n \t\t\t   struct strbuf *);\n@@ -281,9 +283,9 @@ struct cpp_buffer\n \n   struct cpp_buffer *prev;\n \n-  /* Pointer into the include table; non-NULL if this is a file\n-     buffer.  Used for include_next and to record control macros.  */\n-  struct include_file *inc;\n+  /* Pointer into the file table; non-NULL if this is a file buffer.\n+     Used for include_next and to record control macros.  */\n+  struct _cpp_file *file;\n \n   /* Value of if_stack at start of this file.\n      Used to prohibit unmatched #endif (etc) in an include file.  */\n@@ -314,7 +316,7 @@ struct cpp_buffer\n \n   /* The directory of the this buffer's file.  Its NAME member is not\n      allocated, so we don't need to worry about freeing it.  */\n-  struct cpp_path dir;\n+  struct cpp_dir dir;\n \n   /* Used for buffer overlays by cpptrad.c.  */\n   const uchar *saved_cur, *saved_rlimit;\n@@ -355,8 +357,24 @@ struct cpp_reader\n   const struct directive *directive;\n \n   /* Search paths for include files.  */\n-  struct cpp_path *quote_include;\t/* \"\" */\n-  struct cpp_path *bracket_include;\t/* <> */\n+  struct cpp_dir *quote_include;\t/* \"\" */\n+  struct cpp_dir *bracket_include;\t/* <> */\n+  struct cpp_dir no_search_path;\t/* No path.  */\n+\n+  /* Chain of files that were #import-ed or contain #pragma once.  */\n+  struct _cpp_file *once_only_files;\n+\n+  /* File and directory hash table.  */\n+  htab_t file_hash;\n+  struct file_hash_entry *file_hash_entries;\n+  unsigned int file_hash_entries_allocated, file_hash_entries_used;\n+\n+  /* Nonzero means don't look for #include \"foo\" the source-file\n+     directory.  */\n+  bool quote_ignores_source_dir;\n+\n+  /* Non-zero if any file has contained #pragma once.  */\n+  bool saw_pragma_once;\n \n   /* Multiple include optimization.  */\n   const cpp_hashnode *mi_cmacro;\n@@ -386,13 +404,6 @@ struct cpp_reader\n      wide execution character set.  */\n   struct cset_converter wide_cset_desc;\n \n-  /* Tree of other included files.  See cppfiles.c.  */\n-  struct splay_tree_s *all_include_files;\n-\n-  /* Current maximum length of directory names in the search path\n-     for include files.  (Altered as we get more of them.)  */\n-  unsigned int max_include_len;\n-\n   /* Date and time text.  Calculated together if either is requested.  */\n   const uchar *date;\n   const uchar *time;\n@@ -432,12 +443,8 @@ struct cpp_reader\n      preprocessor.  */\n   struct spec_nodes spec_nodes;\n \n-  /* Nonzero means don't look for #include \"foo\" the source-file\n-     directory.  */\n-  unsigned char quote_ignores_source_dir;\n-\n   /* Whether cpplib owns the hashtable.  */\n-  unsigned char our_hashtable;\n+  bool our_hashtable;\n \n   /* Traditional preprocessing output buffer (a logical line).  */\n   struct\n@@ -509,16 +516,16 @@ extern void _cpp_init_hashtable (cpp_reader *, hash_table *);\n extern void _cpp_destroy_hashtable (cpp_reader *);\n \n /* In cppfiles.c */\n+extern void _cpp_mark_file_once_only (cpp_reader *, struct _cpp_file *, bool);\n extern void _cpp_fake_include (cpp_reader *, const char *);\n-extern void _cpp_never_reread (struct include_file *);\n-extern bool _cpp_read_file (cpp_reader *, const char *);\n-extern bool _cpp_execute_include (cpp_reader *, const char *, int,\n-\t\t\t\t  enum include_type);\n+extern bool _cpp_stack_file (cpp_reader *, const char *);\n+extern bool _cpp_stack_include (cpp_reader *, const char *, int,\n+\t\t\t\tenum include_type);\n extern int _cpp_compare_file_date (cpp_reader *, const char *, int);\n extern void _cpp_report_missing_guards (cpp_reader *);\n-extern void _cpp_init_includes (cpp_reader *);\n-extern void _cpp_cleanup_includes (cpp_reader *);\n-extern void _cpp_pop_file_buffer (cpp_reader *, struct include_file *);\n+extern void _cpp_init_files (cpp_reader *);\n+extern void _cpp_cleanup_files (cpp_reader *);\n+extern void _cpp_pop_file_buffer (cpp_reader *, struct _cpp_file *);\n \n /* In cppexp.c */\n extern bool _cpp_parse_expr (cpp_reader *);"}, {"sha": "5f10e2730713f7f33e044932a407f5fc339087f0", "filename": "gcc/cppinit.c", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f9b40094d6e960d965e632f6537bf6eaa980ab5/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f9b40094d6e960d965e632f6537bf6eaa980ab5/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=8f9b40094d6e960d965e632f6537bf6eaa980ab5", "patch": "@@ -161,6 +161,12 @@ cpp_create_reader (enum c_lang lang, hash_table *table)\n   CPP_OPTION (pfile, narrow_charset) = 0;\n   CPP_OPTION (pfile, wide_charset) = 0;\n \n+  /* A fake empty \"directory\" used as the starting point for files\n+     looked up without a search path.  Name cannot be '/' because we\n+     don't want to prepend anything at all to filenames using it.  All\n+     other entries are correct zero-initialized.  */\n+  pfile->no_search_path.name = (char *) \"\";\n+\n   /* Initialize the line map.  Start at logical line 1, so we can use\n      a line number of zero for special states.  */\n   linemap_init (&pfile->line_maps);\n@@ -196,7 +202,7 @@ cpp_create_reader (enum c_lang lang, hash_table *table)\n \t\t  (void *(*) (long)) xmalloc,\n \t\t  (void (*) (void *)) free);\n \n-  _cpp_init_includes (pfile);\n+  _cpp_init_files (pfile);\n \n   _cpp_init_hashtable (pfile, table);\n \n@@ -231,7 +237,7 @@ cpp_destroy (cpp_reader *pfile)\n   obstack_free (&pfile->buffer_ob, 0);\n \n   _cpp_destroy_hashtable (pfile);\n-  _cpp_cleanup_includes (pfile);\n+  _cpp_cleanup_files (pfile);\n   _cpp_destroy_iconv (pfile);\n \n   _cpp_free_buff (pfile->a_buff);\n@@ -427,15 +433,6 @@ cpp_add_dependency_target (cpp_reader *pfile, const char *target, int quote)\n   deps_add_target (pfile->deps, target, quote);\n }\n \n-/* This sets up for processing input from the file FNAME.  \n-   It returns false on error.  */\n-bool\n-cpp_read_next_file (cpp_reader *pfile, const char *fname)\n-{\n-  /* Open the main input file.  */\n-  return _cpp_read_file (pfile, fname);\n-}\n-\n /* This is called after options have been parsed, and partially\n    processed.  Setup for processing input from the file named FNAME,\n    or stdin if it is the empty string.  Return the original filename\n@@ -461,7 +458,7 @@ cpp_read_main_file (cpp_reader *pfile, const char *fname)\n     }\n \n   pfile->line = 1;\n-  if (!cpp_read_next_file (pfile, fname))\n+  if (!cpp_stack_file (pfile, fname))\n     return NULL;\n \n   /* Set this here so the client can change the option if it wishes,"}, {"sha": "505f48201c3338b7f73c231fe2482700ffd826b0", "filename": "gcc/cpplib.c", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f9b40094d6e960d965e632f6537bf6eaa980ab5/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f9b40094d6e960d965e632f6537bf6eaa980ab5/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=8f9b40094d6e960d965e632f6537bf6eaa980ab5", "patch": "@@ -441,7 +441,7 @@ run_directive (cpp_reader *pfile, int dir_no, const char *buf, size_t count)\n \t\t   /* from_stage3 */ true, 1);\n   /* Disgusting hack.  */\n   if (dir_no == T_PRAGMA)\n-    pfile->buffer->inc = pfile->buffer->prev->inc;\n+    pfile->buffer->file = pfile->buffer->prev->file;\n   start_directive (pfile);\n \n   /* This is a short-term fix to prevent a leading '#' being\n@@ -454,7 +454,7 @@ run_directive (cpp_reader *pfile, int dir_no, const char *buf, size_t count)\n   pfile->directive->handler (pfile);\n   end_directive (pfile, 1);\n   if (dir_no == T_PRAGMA)\n-    pfile->buffer->inc = NULL;\n+    pfile->buffer->file = NULL;\n   _cpp_pop_buffer (pfile);\n }\n \n@@ -684,7 +684,7 @@ do_include_common (cpp_reader *pfile, enum include_type type)\n \tpfile->cb.include (pfile, pfile->directive_line,\n \t\t\t   pfile->directive->name, fname, angle_brackets);\n \n-      _cpp_execute_include (pfile, fname, angle_brackets, type);\n+      _cpp_stack_include (pfile, fname, angle_brackets, type);\n     }\n \n   free ((void *) fname);\n@@ -699,13 +699,6 @@ do_include (cpp_reader *pfile)\n static void\n do_import (cpp_reader *pfile)\n {\n-  if (CPP_OPTION (pfile, warn_import))\n-    {\n-      CPP_OPTION (pfile, warn_import) = 0;\n-      cpp_error (pfile, DL_WARNING,\n-   \"#import is obsolete, use an #ifndef wrapper in the header file\");\n-    }\n-\n   do_include_common (pfile, IT_IMPORT);\n }\n \n@@ -1170,15 +1163,11 @@ do_pragma (cpp_reader *pfile)\n static void\n do_pragma_once (cpp_reader *pfile)\n {\n-  if (CPP_OPTION (pfile, warn_deprecated))\n-    cpp_error (pfile, DL_WARNING, \"#pragma once is obsolete\");\n-\n   if (pfile->buffer->prev == NULL)\n     cpp_error (pfile, DL_WARNING, \"#pragma once in main file\");\n-  else\n-    _cpp_never_reread (pfile->buffer->inc);\n \n   check_eol (pfile);\n+  _cpp_mark_file_once_only (pfile, pfile->buffer->file, false);\n }\n \n /* Handle #pragma GCC poison, to poison one or more identifiers so\n@@ -1944,7 +1933,7 @@ void\n _cpp_pop_buffer (cpp_reader *pfile)\n {\n   cpp_buffer *buffer = pfile->buffer;\n-  struct include_file *inc = buffer->inc;\n+  struct _cpp_file *inc = buffer->file;\n   struct if_stack *ifs;\n \n   /* Walk back up the conditional stack till we reach its level at"}, {"sha": "7f5cfd4edd98477bf799d2fdb9d489e062f48d6d", "filename": "gcc/cpplib.h", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f9b40094d6e960d965e632f6537bf6eaa980ab5/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f9b40094d6e960d965e632f6537bf6eaa980ab5/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=8f9b40094d6e960d965e632f6537bf6eaa980ab5", "patch": "@@ -39,10 +39,9 @@ typedef struct cpp_string cpp_string;\n typedef struct cpp_hashnode cpp_hashnode;\n typedef struct cpp_macro cpp_macro;\n typedef struct cpp_callbacks cpp_callbacks;\n-typedef struct cpp_path cpp_path;\n+typedef struct cpp_dir cpp_dir;\n \n struct answer;\n-struct file_name_map_list;\n \n /* The first three groups, apart from '=', can appear in preprocessor\n    expressions (+= and -= are used to indicate unary + and - resp.).\n@@ -214,10 +213,6 @@ struct cpp_options\n   /* Characters between tab stops.  */\n   unsigned int tabstop;\n \n-  /* Map between header names and file names, used only on DOS where\n-     file names are limited in length.  */\n-  struct file_name_map_list *map_list;\n-\n   /* The language we're preprocessing.  */\n   enum c_lang lang;\n \n@@ -397,22 +392,22 @@ struct cpp_callbacks\n };\n \n /* Chain of directories to look for include files in.  */\n-struct cpp_path\n+struct cpp_dir\n {\n   /* NULL-terminated singly-linked list.  */\n-  struct cpp_path *next;\n+  struct cpp_dir *next;\n \n-  /* NAME need not be NUL-terminated once inside cpplib.  */\n+  /* NAME of the directory, NUL-terminated.  */\n   char *name;\n   unsigned int len;\n \n   /* One if a system header, two if a system header that has extern\n      \"C\" guards for C++.  */\n   unsigned char sysp;\n \n-  /* Mapping of file names for this directory for MS-DOS and\n-     related platforms.  */\n-  struct file_name_map *name_map;\n+  /* Mapping of file names for this directory for MS-DOS and related\n+     platforms.  A NULL-terminated array of (from, to) pairs.  */\n+  const char **name_map;\n     \n   /* The C front end uses these to recognize duplicated\n      directories in the search path.  */\n@@ -516,7 +511,7 @@ extern void cpp_set_lang (cpp_reader *, enum c_lang);\n extern void cpp_add_dependency_target (cpp_reader *, const char *, int);\n \n /* Set the include paths.  */\n-extern void cpp_set_include_chains (cpp_reader *, cpp_path *, cpp_path *, int);\n+extern void cpp_set_include_chains (cpp_reader *, cpp_dir *, cpp_dir *, int);\n \n /* Call these to get pointers to the options and callback structures\n    for a given reader.  These pointers are good until you call\n@@ -535,9 +530,9 @@ extern void cpp_set_callbacks (cpp_reader *, cpp_callbacks *);\n    too.  If there was an error opening the file, it returns NULL.  */\n extern const char *cpp_read_main_file (cpp_reader *, const char *);\n \n-/* This continues processing to a new file.  It will return false if\n-   there was an error opening the file.  */\n-extern bool cpp_read_next_file (cpp_reader *, const char *);\n+/* Stacks a new file.  It will return false if there was an error\n+   opening the file.  */\n+extern bool cpp_stack_file (cpp_reader *, const char *);\n \n /* Set up built-ins like __FILE__.  */\n extern void cpp_init_builtins (cpp_reader *, int);\n@@ -715,7 +710,7 @@ extern unsigned char *cpp_quote_string (unsigned char *, const unsigned char *,\n \t\t\t\t\tunsigned int);\n \n /* In cppfiles.c */\n-extern int cpp_included (cpp_reader *, const char *);\n+extern bool cpp_included (cpp_reader *, const char *);\n extern void cpp_make_system_header (cpp_reader *, int, int);\n extern void cpp_simplify_path (char *);\n extern bool cpp_push_include (cpp_reader *, const char *);"}, {"sha": "3a0ae1f29e126d7bfeaff67b4a17bfeb0cb4fdd9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f9b40094d6e960d965e632f6537bf6eaa980ab5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f9b40094d6e960d965e632f6537bf6eaa980ab5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8f9b40094d6e960d965e632f6537bf6eaa980ab5", "patch": "@@ -1,3 +1,7 @@\n+2003-07-29  Neil Booth  <neil@daikokuya.co.uk>\n+\n+\t* gcc.dg/cpp/include2.c: Only expect one message.\n+\n 2003-07-29  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tPR c++/9447"}, {"sha": "60edfccb0cd658181e7bf2658204a16cf87c588b", "filename": "gcc/testsuite/gcc.dg/cpp/include2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f9b40094d6e960d965e632f6537bf6eaa980ab5/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Finclude2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f9b40094d6e960d965e632f6537bf6eaa980ab5/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Finclude2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Finclude2.c?ref=8f9b40094d6e960d965e632f6537bf6eaa980ab5", "patch": "@@ -10,7 +10,7 @@\n #include <silly\\>>  /* { dg-warning \"extra tokens\" \"\" } */\n #include \"silly\\\"\"  /* { dg-warning \"extra tokens\" \"\" } */\n \n-/* These first 2 errors are No such file or directory.  However, this\n+/* These error is No such file or directory, just once.  However, this\n    message is locale-dependent, so don't test for it.  */\n /* { dg-error \"silly\" \"\" { target *-*-* } 10 } */\n-/* { dg-error \"silly\" \"\" { target *-*-* } 11 } */\n+"}]}