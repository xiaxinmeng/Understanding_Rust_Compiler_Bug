{"sha": "e9024729e2f52424472e893ac080289f7677c02e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTkwMjQ3MjllMmY1MjQyNDQ3MmU4OTNhYzA4MDI4OWY3Njc3YzAyZQ==", "commit": {"author": {"name": "Matthew Wahab", "email": "matthew.wahab@arm.com", "date": "2016-05-16T08:46:00Z"}, "committer": {"name": "Matthew Wahab", "email": "mwahab@gcc.gnu.org", "date": "2016-05-16T08:46:00Z"}, "message": "[AArch64] Remove an unused reload hook.\n\n    * config/aarch64/aarch64.h (LEGITIMIZE_RELOAD_ADDRESS): Remove.\n    * config/aarch64/arch64-protos.h\n    (aarch64_legitimize_reload_address): Remove.\n    * config/aarch64/aarch64.c (aarch64_legitimize_reload_address):\n    Remove.\n\nFrom-SVN: r236266", "tree": {"sha": "eaf36209a1d8070ced9725cd135d2872b041fa2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eaf36209a1d8070ced9725cd135d2872b041fa2e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9024729e2f52424472e893ac080289f7677c02e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9024729e2f52424472e893ac080289f7677c02e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9024729e2f52424472e893ac080289f7677c02e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9024729e2f52424472e893ac080289f7677c02e/comments", "author": null, "committer": null, "parents": [{"sha": "921d1e735e15a69b4b221cad3cdab6ebe3dfb257", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/921d1e735e15a69b4b221cad3cdab6ebe3dfb257", "html_url": "https://github.com/Rust-GCC/gccrs/commit/921d1e735e15a69b4b221cad3cdab6ebe3dfb257"}], "stats": {"total": 138, "additions": 8, "deletions": 130}, "files": [{"sha": "a50365496d66e92b56fda8f1d5c75d53f44ab760", "filename": "ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9024729e2f52424472e893ac080289f7677c02e/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9024729e2f52424472e893ac080289f7677c02e/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=e9024729e2f52424472e893ac080289f7677c02e", "patch": "@@ -1,3 +1,11 @@\n+2016-05-16  Matthew Wahab  <matthew.wahab@arm.com>\n+\n+    * config/aarch64/aarch64.h (LEGITIMIZE_RELOAD_ADDRESS): Remove.\n+    * config/aarch64/arch64-protos.h\n+    (aarch64_legitimize_reload_address): Remove.\n+    * config/aarch64/aarch64.c (aarch64_legitimize_reload_address):\n+    Remove.\n+\n 2016-05-09  Aaron Sawdey  <acsawdey@linux.vnet.ibm.com>\n \n \t* MAINTAINERS (Write After Approval): Add myself."}, {"sha": "6a8a850673853a98e12496046ebdcf4a3cd37cf8", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9024729e2f52424472e893ac080289f7677c02e/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9024729e2f52424472e893ac080289f7677c02e/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=e9024729e2f52424472e893ac080289f7677c02e", "patch": "@@ -339,7 +339,6 @@ int aarch64_simd_attr_length_move (rtx_insn *);\n int aarch64_uxt_size (int, HOST_WIDE_INT);\n int aarch64_vec_fpconst_pow_of_2 (rtx);\n rtx aarch64_final_eh_return_addr (void);\n-rtx aarch64_legitimize_reload_address (rtx *, machine_mode, int, int, int);\n rtx aarch64_mask_from_zextract_ops (rtx, rtx);\n const char *aarch64_output_move_struct (rtx *operands);\n rtx aarch64_return_addr (int, rtx);"}, {"sha": "e081b16f324afbec5bb2a188db32f3c20ddbecd7", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 0, "deletions": 114, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9024729e2f52424472e893ac080289f7677c02e/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9024729e2f52424472e893ac080289f7677c02e/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=e9024729e2f52424472e893ac080289f7677c02e", "patch": "@@ -5022,120 +5022,6 @@ aarch64_legitimize_address (rtx x, rtx /* orig_x  */, machine_mode mode)\n   return x;\n }\n \n-/* Try a machine-dependent way of reloading an illegitimate address\n-   operand.  If we find one, push the reload and return the new rtx.  */\n-\n-rtx\n-aarch64_legitimize_reload_address (rtx *x_p,\n-\t\t\t\t   machine_mode mode,\n-\t\t\t\t   int opnum, int type,\n-\t\t\t\t   int ind_levels ATTRIBUTE_UNUSED)\n-{\n-  rtx x = *x_p;\n-\n-  /* Do not allow mem (plus (reg, const)) if vector struct mode.  */\n-  if (aarch64_vect_struct_mode_p (mode)\n-      && GET_CODE (x) == PLUS\n-      && REG_P (XEXP (x, 0))\n-      && CONST_INT_P (XEXP (x, 1)))\n-    {\n-      rtx orig_rtx = x;\n-      x = copy_rtx (x);\n-      push_reload (orig_rtx, NULL_RTX, x_p, NULL,\n-\t\t   BASE_REG_CLASS, GET_MODE (x), VOIDmode, 0, 0,\n-\t\t   opnum, (enum reload_type) type);\n-      return x;\n-    }\n-\n-  /* We must recognize output that we have already generated ourselves.  */\n-  if (GET_CODE (x) == PLUS\n-      && GET_CODE (XEXP (x, 0)) == PLUS\n-      && REG_P (XEXP (XEXP (x, 0), 0))\n-      && CONST_INT_P (XEXP (XEXP (x, 0), 1))\n-      && CONST_INT_P (XEXP (x, 1)))\n-    {\n-      push_reload (XEXP (x, 0), NULL_RTX, &XEXP (x, 0), NULL,\n-\t\t   BASE_REG_CLASS, GET_MODE (x), VOIDmode, 0, 0,\n-\t\t   opnum, (enum reload_type) type);\n-      return x;\n-    }\n-\n-  /* We wish to handle large displacements off a base register by splitting\n-     the addend across an add and the mem insn.  This can cut the number of\n-     extra insns needed from 3 to 1.  It is only useful for load/store of a\n-     single register with 12 bit offset field.  */\n-  if (GET_CODE (x) == PLUS\n-      && REG_P (XEXP (x, 0))\n-      && CONST_INT_P (XEXP (x, 1))\n-      && HARD_REGISTER_P (XEXP (x, 0))\n-      && mode != TImode\n-      && mode != TFmode\n-      && aarch64_regno_ok_for_base_p (REGNO (XEXP (x, 0)), true))\n-    {\n-      HOST_WIDE_INT val = INTVAL (XEXP (x, 1));\n-      HOST_WIDE_INT low = val & 0xfff;\n-      HOST_WIDE_INT high = val - low;\n-      HOST_WIDE_INT offs;\n-      rtx cst;\n-      machine_mode xmode = GET_MODE (x);\n-\n-      /* In ILP32, xmode can be either DImode or SImode.  */\n-      gcc_assert (xmode == DImode || xmode == SImode);\n-\n-      /* Reload non-zero BLKmode offsets.  This is because we cannot ascertain\n-\t BLKmode alignment.  */\n-      if (GET_MODE_SIZE (mode) == 0)\n-\treturn NULL_RTX;\n-\n-      offs = low % GET_MODE_SIZE (mode);\n-\n-      /* Align misaligned offset by adjusting high part to compensate.  */\n-      if (offs != 0)\n-\t{\n-\t  if (aarch64_uimm12_shift (high + offs))\n-\t    {\n-\t      /* Align down.  */\n-\t      low = low - offs;\n-\t      high = high + offs;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Align up.  */\n-\t      offs = GET_MODE_SIZE (mode) - offs;\n-\t      low = low + offs;\n-\t      high = high + (low & 0x1000) - offs;\n-\t      low &= 0xfff;\n-\t    }\n-\t}\n-\n-      /* Check for overflow.  */\n-      if (high + low != val)\n-\treturn NULL_RTX;\n-\n-      cst = GEN_INT (high);\n-      if (!aarch64_uimm12_shift (high))\n-\tcst = force_const_mem (xmode, cst);\n-\n-      /* Reload high part into base reg, leaving the low part\n-\t in the mem instruction.\n-\t Note that replacing this gen_rtx_PLUS with plus_constant is\n-\t wrong in this case because we rely on the\n-\t (plus (plus reg c1) c2) structure being preserved so that\n-\t XEXP (*p, 0) in push_reload below uses the correct term.  */\n-      x = gen_rtx_PLUS (xmode,\n-\t\t\tgen_rtx_PLUS (xmode, XEXP (x, 0), cst),\n-\t\t\tGEN_INT (low));\n-\n-      push_reload (XEXP (x, 0), NULL_RTX, &XEXP (x, 0), NULL,\n-\t\t   BASE_REG_CLASS, xmode, VOIDmode, 0, 0,\n-\t\t   opnum, (enum reload_type) type);\n-      return x;\n-    }\n-\n-  return NULL_RTX;\n-}\n-\n-\n /* Return the reload icode required for a constant pool in mode.  */\n static enum insn_code\n aarch64_constant_pool_reload_icode (machine_mode mode)"}, {"sha": "6eb31e9537a01881d74e258ce159b5a2fb7e0e6f", "filename": "gcc/config/aarch64/aarch64.h", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9024729e2f52424472e893ac080289f7677c02e/gcc%2Fconfig%2Faarch64%2Faarch64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9024729e2f52424472e893ac080289f7677c02e/gcc%2Fconfig%2Faarch64%2Faarch64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.h?ref=e9024729e2f52424472e893ac080289f7677c02e", "patch": "@@ -652,21 +652,6 @@ typedef struct\n \n #define CONSTANT_ADDRESS_P(X)\t\taarch64_constant_address_p(X)\n \n-/* Try a machine-dependent way of reloading an illegitimate address\n-   operand.  If we find one, push the reload and jump to WIN.  This\n-   macro is used in only one place: `find_reloads_address' in reload.c.  */\n-\n-#define LEGITIMIZE_RELOAD_ADDRESS(X, MODE, OPNUM, TYPE, IND_L, WIN)\t     \\\n-do {\t\t\t\t\t\t\t\t\t     \\\n-  rtx new_x = aarch64_legitimize_reload_address (&(X), MODE, OPNUM, TYPE,    \\\n-\t\t\t\t\t\t IND_L);\t\t     \\\n-  if (new_x)\t\t\t\t\t\t\t\t     \\\n-    {\t\t\t\t\t\t\t\t\t     \\\n-      X = new_x;\t\t\t\t\t\t\t     \\\n-      goto WIN;\t\t\t\t\t\t\t\t     \\\n-    }\t\t\t\t\t\t\t\t\t     \\\n-} while (0)\n-\n #define REGNO_OK_FOR_BASE_P(REGNO)\t\\\n   aarch64_regno_ok_for_base_p (REGNO, true)\n "}]}