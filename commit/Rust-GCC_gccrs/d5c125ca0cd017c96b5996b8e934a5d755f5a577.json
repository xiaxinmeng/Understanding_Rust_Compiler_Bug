{"sha": "d5c125ca0cd017c96b5996b8e934a5d755f5a577", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDVjMTI1Y2EwY2QwMTdjOTZiNTk5NmI4ZTkzNGE1ZDc1NWY1YTU3Nw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-07-21T19:23:40Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-07-21T19:23:40Z"}, "message": "search.c (lookup_conversion_operator): Return overloads.\n\n\t* search.c (lookup_conversion_operator): Return overloads.\n\t(lookup_fnfields_idx_nolazy): Absorb into ...\n\t(lookup_fnfields_slot_nolaxy): ... here.\n\t(lookup_fnfields_1): Absorb into ...\n\t(lookup_fnfields_slot): ... here.\n\nFrom-SVN: r250440", "tree": {"sha": "970cb6f472c2c853be432b6100aa26c233b9f412", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/970cb6f472c2c853be432b6100aa26c233b9f412"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d5c125ca0cd017c96b5996b8e934a5d755f5a577", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5c125ca0cd017c96b5996b8e934a5d755f5a577", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5c125ca0cd017c96b5996b8e934a5d755f5a577", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5c125ca0cd017c96b5996b8e934a5d755f5a577/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "df206c6e77551b7eebfa1b7995b2556ac369f4fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df206c6e77551b7eebfa1b7995b2556ac369f4fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df206c6e77551b7eebfa1b7995b2556ac369f4fd"}], "stats": {"total": 113, "additions": 44, "deletions": 69}, "files": [{"sha": "d65dc55f6829a0f890b69c8c2eb01a21674a2956", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5c125ca0cd017c96b5996b8e934a5d755f5a577/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5c125ca0cd017c96b5996b8e934a5d755f5a577/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d5c125ca0cd017c96b5996b8e934a5d755f5a577", "patch": "@@ -1,5 +1,11 @@\n 2017-07-21  Nathan Sidwell  <nathan@acm.org>\n \n+\t* search.c (lookup_conversion_operator): Return overloads.\n+\t(lookup_fnfields_idx_nolazy): Absorb into ...\n+\t(lookup_fnfields_slot_nolaxy): ... here.\n+\t(lookup_fnfields_1): Absorb into ...\n+\t(lookup_fnfields_slot): ... here.\n+\n \tRemove special CDtor METHOD_VEC slots.\n \t* cp-tree.h (CLASSTYPE_CONSTRUCTOR_SLOT,\n \tCLASSTYPE_DESTRUCTOR_SLOT): Delete."}, {"sha": "469a88b4c6f44ab3da2aa8af586926fbb127a53c", "filename": "gcc/cp/search.c", "status": "modified", "additions": 38, "deletions": 69, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5c125ca0cd017c96b5996b8e934a5d755f5a577/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5c125ca0cd017c96b5996b8e934a5d755f5a577/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=d5c125ca0cd017c96b5996b8e934a5d755f5a577", "patch": "@@ -1530,62 +1530,53 @@ lookup_fnfields (tree xbasetype, tree name, int protect)\n   return rval;\n }\n \n-/* Return the index in the CLASSTYPE_METHOD_VEC for CLASS_TYPE\n-   corresponding to \"operator TYPE ()\", or -1 if there is no such\n-   operator.  Only CLASS_TYPE itself is searched; this routine does\n-   not scan the base classes of CLASS_TYPE.  */\n+/* Return the conversion operators in CLASS_TYPE corresponding to\n+   \"operator TYPE ()\".  Only CLASS_TYPE itself is searched; this\n+   routine does not scan the base classes of CLASS_TYPE.  */\n \n-static int\n+static tree\n lookup_conversion_operator (tree class_type, tree type)\n {\n-  int tpl_slot = -1;\n+  tree tpls = NULL_TREE;\n \n   if (TYPE_HAS_CONVERSION (class_type))\n     {\n-      int i;\n-      tree fn;\n+      tree fns;\n       vec<tree, va_gc> *methods = CLASSTYPE_METHOD_VEC (class_type);\n \n-      for (i = CLASSTYPE_FIRST_CONVERSION_SLOT;\n-\t   vec_safe_iterate (methods, i, &fn); ++i)\n+      for (int i = CLASSTYPE_FIRST_CONVERSION_SLOT;\n+\t   vec_safe_iterate (methods, i, &fns); ++i)\n \t{\n \t  /* All the conversion operators come near the beginning of\n \t     the class.  Therefore, if FN is not a conversion\n \t     operator, there is no matching conversion operator in\n \t     CLASS_TYPE.  */\n-\t  fn = OVL_FIRST (fn);\n+\t  tree fn = OVL_FIRST (fns);\n \t  if (!DECL_CONV_FN_P (fn))\n \t    break;\n \n \t  if (TREE_CODE (fn) == TEMPLATE_DECL)\n \t    /* All the templated conversion functions are on the same\n \t       slot, so remember it.  */\n-\t    tpl_slot = i;\n+\t    tpls = fns;\n \t  else if (same_type_p (DECL_CONV_FN_TYPE (fn), type))\n-\t    return i;\n+\t    return fns;\n \t}\n     }\n \n-  return tpl_slot;\n+  return tpls;\n }\n \n-/* TYPE is a class type. Return the index of the fields within\n-   the method vector with name NAME, or -1 if no such field exists.\n-   Does not lazily declare implicitly-declared member functions.  */\n+/* TYPE is a class type. Return the member functions in the method\n+   vector with name NAME.  Does not lazily declare implicitly-declared\n+   member functions.  */\n \n-static int\n-lookup_fnfields_idx_nolazy (tree type, tree name)\n+tree\n+lookup_fnfields_slot_nolazy (tree type, tree name)\n {\n-  vec<tree, va_gc> *method_vec;\n-  tree fn;\n-  size_t i;\n-\n-  if (!CLASS_TYPE_P (type))\n-    return -1;\n-\n-  method_vec = CLASSTYPE_METHOD_VEC (type);\n+  vec<tree, va_gc> *method_vec = CLASSTYPE_METHOD_VEC (type);\n   if (!method_vec)\n-    return -1;\n+    return NULL_TREE;\n \n   if (GATHER_STATISTICS)\n     n_calls_lookup_fnfields_1++;\n@@ -1594,10 +1585,12 @@ lookup_fnfields_idx_nolazy (tree type, tree name)\n     return lookup_conversion_operator (type, TREE_TYPE (name));\n \n   /* Skip the conversion operators.  */\n+  int i;\n+  tree fns;\n   for (i = CLASSTYPE_FIRST_CONVERSION_SLOT;\n-       vec_safe_iterate (method_vec, i, &fn);\n+       vec_safe_iterate (method_vec, i, &fns);\n        ++i)\n-    if (!DECL_CONV_FN_P (OVL_FIRST (fn)))\n+    if (!DECL_CONV_FN_P (OVL_FIRST (fns)))\n       break;\n \n   /* If the type is complete, use binary search.  */\n@@ -1615,36 +1608,35 @@ lookup_fnfields_idx_nolazy (tree type, tree name)\n \t  if (GATHER_STATISTICS)\n \t    n_outer_fields_searched++;\n \n-\t  tree tmp = (*method_vec)[i];\n-\t  tmp = OVL_NAME (tmp);\n-\t  if (tmp > name)\n+\t  fns = (*method_vec)[i];\n+\t  tree fn_name = OVL_NAME (fns);\n+\t  if (fn_name > name)\n \t    hi = i;\n-\t  else if (tmp < name)\n+\t  else if (fn_name < name)\n \t    lo = i + 1;\n \t  else\n-\t    return i;\n+\t    return fns;\n \t}\n     }\n   else\n-    for (; vec_safe_iterate (method_vec, i, &fn); ++i)\n+    for (; vec_safe_iterate (method_vec, i, &fns); ++i)\n       {\n \tif (GATHER_STATISTICS)\n \t  n_outer_fields_searched++;\n-\tif (OVL_NAME (fn) == name)\n-\t  return i;\n+\tif (OVL_NAME (fns) == name)\n+\t  return fns;\n       }\n \n-  return -1;\n+  return NULL_TREE;\n }\n \n-/* TYPE is a class type. Return the index of the fields within\n-   the method vector with name NAME, or -1 if no such field exists.  */\n+/* TYPE is a class type. Return the overloads in\n+   the method vector with name NAME.  Lazily create ctors etc.  */\n \n-static int\n-lookup_fnfields_1 (tree type, tree name)\n+tree\n+lookup_fnfields_slot (tree type, tree name)\n {\n-  if (!CLASS_TYPE_P (type))\n-    return -1;\n+  type = complete_type (type);\n \n   if (COMPLETE_TYPE_P (type))\n     {\n@@ -1671,30 +1663,7 @@ lookup_fnfields_1 (tree type, tree name)\n \t}\n     }\n \n-  return lookup_fnfields_idx_nolazy (type, name);\n-}\n-\n-/* TYPE is a class type. Return the field within the method vector with\n-   name NAME, or NULL_TREE if no such field exists.  */\n-\n-tree\n-lookup_fnfields_slot (tree type, tree name)\n-{\n-  int ix = lookup_fnfields_1 (complete_type (type), name);\n-  if (ix < 0)\n-    return NULL_TREE;\n-  return (*CLASSTYPE_METHOD_VEC (type))[ix];\n-}\n-\n-/* As above, but avoid lazily declaring functions.  */\n-\n-tree\n-lookup_fnfields_slot_nolazy (tree type, tree name)\n-{\n-  int ix = lookup_fnfields_idx_nolazy (complete_type (type), name);\n-  if (ix < 0)\n-    return NULL_TREE;\n-  return (*CLASSTYPE_METHOD_VEC (type))[ix];\n+  return lookup_fnfields_slot_nolazy (type, name);\n }\n \n /* Collect all the conversion operators of KLASS.  */"}]}