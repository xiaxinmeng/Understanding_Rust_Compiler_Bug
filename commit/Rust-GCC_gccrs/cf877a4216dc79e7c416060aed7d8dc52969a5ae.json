{"sha": "cf877a4216dc79e7c416060aed7d8dc52969a5ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Y4NzdhNDIxNmRjNzllN2M0MTYwNjBhZWQ3ZDhkYzUyOTY5YTVhZQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@cygnus.com", "date": "1998-04-14T14:56:05Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1998-04-14T14:56:05Z"}, "message": "Fix mips64vr4100-elf build failure.\n\n\t* mips.md (reload_outdi): Change the scratch mode from DImode to\n\tTImode.  New variable scratch, used instead of operand[2] in template.\n\tAdd code for MIPS16 HILO_REGNUM case where output reg is not M16_REG_P.\n\nFrom-SVN: r19210", "tree": {"sha": "984303815f5eda970dbfc96e5d2ef1b1b573d76a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/984303815f5eda970dbfc96e5d2ef1b1b573d76a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf877a4216dc79e7c416060aed7d8dc52969a5ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf877a4216dc79e7c416060aed7d8dc52969a5ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf877a4216dc79e7c416060aed7d8dc52969a5ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf877a4216dc79e7c416060aed7d8dc52969a5ae/comments", "author": null, "committer": null, "parents": [{"sha": "996d9dacc4ff00d5f8ff1cfbad6f9d4fc5005b99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/996d9dacc4ff00d5f8ff1cfbad6f9d4fc5005b99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/996d9dacc4ff00d5f8ff1cfbad6f9d4fc5005b99"}], "stats": {"total": 49, "additions": 37, "deletions": 12}, "files": [{"sha": "456424e01f8e675fa67decbba3277538d4b6bb64", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf877a4216dc79e7c416060aed7d8dc52969a5ae/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf877a4216dc79e7c416060aed7d8dc52969a5ae/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cf877a4216dc79e7c416060aed7d8dc52969a5ae", "patch": "@@ -1,3 +1,9 @@\n+Tue Apr 14 14:55:16 1998  Jim Wilson  <wilson@cygnus.com>\n+\n+\t* mips.md (reload_outdi): Change the scratch mode from DImode to\n+\tTImode.  New variable scratch, used instead of operand[2] in template.\n+\tAdd code for MIPS16 HILO_REGNUM case where output reg is not M16_REG_P.\n+\n Tue Apr 14 16:19:03 1998  Michael Meissner  <meissner@cygnus.com>\n \n \t* expr.c (MOVE_RATIO): Set to 3 if optimizing for space."}, {"sha": "25c7239a9b0d8a250e56b9f5a76f887d99b97a4b", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 31, "deletions": 12, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf877a4216dc79e7c416060aed7d8dc52969a5ae/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf877a4216dc79e7c416060aed7d8dc52969a5ae/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=cf877a4216dc79e7c416060aed7d8dc52969a5ae", "patch": "@@ -4639,20 +4639,25 @@ move\\\\t%0,%z4\\\\n\\\\\n \n ;; Handle output reloads in DImode.\n \n+;; Reloading HILO_REG in MIPS16 mode requires two scratch registers, so we\n+;; use a TImode scratch reg.\n+\n (define_expand \"reload_outdi\"\n   [(set (match_operand:DI 0 \"general_operand\" \"=b\")\n \t(match_operand:DI 1 \"se_register_operand\" \"b\"))\n-   (clobber (match_operand:DI 2 \"register_operand\" \"=&d\"))]\n+   (clobber (match_operand:TI 2 \"register_operand\" \"=&d\"))]\n   \"TARGET_64BIT\"\n   \"\n {\n+  rtx scratch = gen_rtx_REG (DImode, REGNO (operands[2]));\n+\n   if (GET_CODE (operands[0]) == REG && REGNO (operands[0]) == HILO_REGNUM)\n     {\n-      emit_insn (gen_ashrdi3 (operands[2], operands[1], GEN_INT (32)));\n-      emit_insn (gen_movdi (gen_rtx (REG, DImode, 64), operands[2]));\n-      emit_insn (gen_ashldi3 (operands[2], operands[1], GEN_INT (32)));\n-      emit_insn (gen_ashrdi3 (operands[2], operands[2], GEN_INT (32)));\n-      emit_insn (gen_movdi (gen_rtx (REG, DImode, 65), operands[2]));\n+      emit_insn (gen_ashrdi3 (scratch, operands[1], GEN_INT (32)));\n+      emit_insn (gen_movdi (gen_rtx (REG, DImode, 64), scratch));\n+      emit_insn (gen_ashldi3 (scratch, operands[1], GEN_INT (32)));\n+      emit_insn (gen_ashrdi3 (scratch, scratch, GEN_INT (32)));\n+      emit_insn (gen_movdi (gen_rtx (REG, DImode, 65), scratch));\n       DONE;\n     }\n   if (GET_CODE (operands[1]) == REG && REGNO (operands[1]) == HILO_REGNUM)\n@@ -4680,20 +4685,34 @@ move\\\\t%0,%z4\\\\n\\\\\n \t  emit_move_insn (scratch, gen_rtx (REG, SImode, 65));\n \t  emit_move_insn (loword, scratch);\n \t}\n+      else if (TARGET_MIPS16 && ! M16_REG_P (REGNO (operands[0])))\n+\t{\n+\t  /* Handle the case where operand[0] is not a 'd' register,\n+\t     and hence we can not directly move from the HILO register\n+\t     into it.  */\n+\t  rtx scratch2 = gen_rtx_REG (DImode, REGNO (operands[2]) + 1);\n+\t  emit_insn (gen_movdi (scratch, gen_rtx (REG, DImode, 65)));\n+\t  emit_insn (gen_ashldi3 (scratch, scratch, GEN_INT (32)));\n+\t  emit_insn (gen_lshrdi3 (scratch, scratch, GEN_INT (32)));\n+\t  emit_insn (gen_movdi (scratch2, gen_rtx (REG, DImode, 64)));\n+\t  emit_insn (gen_ashldi3 (scratch2, scratch2, GEN_INT (32)));\n+\t  emit_insn (gen_iordi3 (scratch, scratch, scratch2));\n+\t  emit_insn (gen_movdi (operands[0], scratch));\n+\t}\n       else\n \t{\n-\t  emit_insn (gen_movdi (operands[2], gen_rtx (REG, DImode, 65)));\n-\t  emit_insn (gen_ashldi3 (operands[2], operands[2], GEN_INT (32)));\n-\t  emit_insn (gen_lshrdi3 (operands[2], operands[2], GEN_INT (32)));\n+\t  emit_insn (gen_movdi (scratch, gen_rtx (REG, DImode, 65)));\n+\t  emit_insn (gen_ashldi3 (scratch, scratch, GEN_INT (32)));\n+\t  emit_insn (gen_lshrdi3 (scratch, scratch, GEN_INT (32)));\n \t  emit_insn (gen_movdi (operands[0], gen_rtx (REG, DImode, 64)));\n \t  emit_insn (gen_ashldi3 (operands[0], operands[0], GEN_INT (32)));\n-\t  emit_insn (gen_iordi3 (operands[0], operands[0], operands[2]));\n+\t  emit_insn (gen_iordi3 (operands[0], operands[0], scratch));\n \t}\n       DONE;\n     }\n   /* This handles moves between a float register and HI/LO.  */\n-  emit_move_insn (operands[2], operands[1]);\n-  emit_move_insn (operands[0], operands[2]);\n+  emit_move_insn (scratch, operands[1]);\n+  emit_move_insn (operands[0], scratch);\n   DONE;\n }\")\n "}]}