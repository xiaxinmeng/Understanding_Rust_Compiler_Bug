{"sha": "bd79363ce06f60a72c83463963bf67de05b06546", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQ3OTM2M2NlMDZmNjBhNzJjODM0NjM5NjNiZjY3ZGUwNWIwNjU0Ng==", "commit": {"author": {"name": "James Greenhalgh", "email": "james.greenhalgh@arm.com", "date": "2014-11-18T10:01:55Z"}, "committer": {"name": "James Greenhalgh", "email": "jgreenhalgh@gcc.gnu.org", "date": "2014-11-18T10:01:55Z"}, "message": "[Patch ARM Refactor Builtins 8/8] Neaten up the ARM Neon builtin infrastructure\n\ngcc/\n\n\t* config/arm/arm-builtins.c (CONVERT_QUALIFIERS): Delete.\n\t(COPYSIGNF_QUALIFIERS): Likewise.\n\t(CREATE_QUALIFIERS): Likewise.\n\t(DUP_QUALIFIERS): Likewise.\n\t(FLOAT_WIDEN_QUALIFIERS): Likewise.\n\t(FLOAT_NARROW_QUALIFIERS): Likewise.\n\t(REINTERP_QUALIFIERS): Likewise.\n\t(RINT_QUALIFIERS): Likewise.\n\t(SPLIT_QUALIFIERS): Likewise.\n\t(FIXCONV_QUALIFIERS): Likewise.\n\t(SCALARMUL_QUALIFIERS): Likewise.\n\t(SCALARMULL_QUALIFIERS): Likewise.\n\t(SCALARMULH_QUALIFIERS): Likewise.\n\t(SELECT_QUALIFIERS): Likewise.\n\t(VTBX_QUALIFIERS): Likewise.\n\t(SHIFTIMM_QUALIFIERS): Likewise.\n\t(SCALARMAC_QUALIFIERS): Likewise.\n\t(LANEMUL_QUALIFIERS): Likewise.\n\t(LANEMULH_QUALIFIERS): Likewise.\n\t(LANEMULL_QUALIFIERS): Likewise.\n\t(SHIFTACC_QUALIFIERS): Likewise.\n\t(SHIFTINSERT_QUALIFIERS): Likewise.\n\t(VTBL_QUALIFIERS): Likewise.\n\t(LOADSTRUCT_QUALIFIERS): Likewise.\n\t(LOADSTRUCTLANE_QUALIFIERS): Likewise.\n\t(STORESTRUCT_QUALIFIERS): Likewise.\n\t(STORESTRUCTLANE_QUALIFIERS): Likewise.\n\t(neon_builtin_type_mode): Delete.\n\t(v8qi_UP): Map to V8QImode.\n\t(v8qi_UP): Map to V8QImode.\n\t(v4hi_UP): Map to V4HImode.\n\t(v4hf_UP): Map to V4HFmode.\n\t(v2si_UP): Map to V2SImode.\n\t(v2sf_UP): Map to V2SFmode.\n\t(di_UP): Map to DImode.\n\t(v16qi_UP): Map to V16QImode.\n\t(v8hi_UP): Map to V8HImode.\n\t(v4si_UP): Map to V4SImode.\n\t(v4sf_UP): Map to V4SFmode.\n\t(v2di_UP): Map to V2DImode.\n\t(ti_UP): Map to TImode.\n\t(ei_UP): Map to EImode.\n\t(oi_UP): Map to OImode.\n\t(neon_itype): Delete.\n\t(neon_builtin_datum): Remove itype, make mode a machine_mode.\n\t(VAR1): Update accordingly.\n\t(arm_init_neon_builtins): Use machine_mode directly.\n\t(neon_dereference_pointer): Likewise.\n\t(arm_expand_neon_args): Use qualifiers to decide operand types.\n\t(arm_expand_neon_builtin): Likewise.\n\t* config/arm/arm_neon_builtins.def: Remap operation type for\n\tmany builtins.\n\nFrom-SVN: r217700", "tree": {"sha": "3d0d1a44b6ff428cf14f227d4cc2a5838b55f4f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d0d1a44b6ff428cf14f227d4cc2a5838b55f4f0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd79363ce06f60a72c83463963bf67de05b06546", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd79363ce06f60a72c83463963bf67de05b06546", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd79363ce06f60a72c83463963bf67de05b06546", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd79363ce06f60a72c83463963bf67de05b06546/comments", "author": {"login": "jgreenhalgh-arm", "id": 6104025, "node_id": "MDQ6VXNlcjYxMDQwMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6104025?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jgreenhalgh-arm", "html_url": "https://github.com/jgreenhalgh-arm", "followers_url": "https://api.github.com/users/jgreenhalgh-arm/followers", "following_url": "https://api.github.com/users/jgreenhalgh-arm/following{/other_user}", "gists_url": "https://api.github.com/users/jgreenhalgh-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jgreenhalgh-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jgreenhalgh-arm/subscriptions", "organizations_url": "https://api.github.com/users/jgreenhalgh-arm/orgs", "repos_url": "https://api.github.com/users/jgreenhalgh-arm/repos", "events_url": "https://api.github.com/users/jgreenhalgh-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/jgreenhalgh-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6276b63014a37a17a67724f1e6bbd8b0b0b31fff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6276b63014a37a17a67724f1e6bbd8b0b0b31fff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6276b63014a37a17a67724f1e6bbd8b0b0b31fff"}], "stats": {"total": 677, "additions": 280, "deletions": 397}, "files": [{"sha": "fa97da712547fd097ec906595825de48a1d2d1ca", "filename": "gcc/ChangeLog", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd79363ce06f60a72c83463963bf67de05b06546/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd79363ce06f60a72c83463963bf67de05b06546/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bd79363ce06f60a72c83463963bf67de05b06546", "patch": "@@ -1,3 +1,58 @@\n+2014-11-18  James Greenhalgh  <james.greenhalgh@arm.com>\n+\n+\t* config/arm/arm-builtins.c (CONVERT_QUALIFIERS): Delete.\n+\t(COPYSIGNF_QUALIFIERS): Likewise.\n+\t(CREATE_QUALIFIERS): Likewise.\n+\t(DUP_QUALIFIERS): Likewise.\n+\t(FLOAT_WIDEN_QUALIFIERS): Likewise.\n+\t(FLOAT_NARROW_QUALIFIERS): Likewise.\n+\t(REINTERP_QUALIFIERS): Likewise.\n+\t(RINT_QUALIFIERS): Likewise.\n+\t(SPLIT_QUALIFIERS): Likewise.\n+\t(FIXCONV_QUALIFIERS): Likewise.\n+\t(SCALARMUL_QUALIFIERS): Likewise.\n+\t(SCALARMULL_QUALIFIERS): Likewise.\n+\t(SCALARMULH_QUALIFIERS): Likewise.\n+\t(SELECT_QUALIFIERS): Likewise.\n+\t(VTBX_QUALIFIERS): Likewise.\n+\t(SHIFTIMM_QUALIFIERS): Likewise.\n+\t(SCALARMAC_QUALIFIERS): Likewise.\n+\t(LANEMUL_QUALIFIERS): Likewise.\n+\t(LANEMULH_QUALIFIERS): Likewise.\n+\t(LANEMULL_QUALIFIERS): Likewise.\n+\t(SHIFTACC_QUALIFIERS): Likewise.\n+\t(SHIFTINSERT_QUALIFIERS): Likewise.\n+\t(VTBL_QUALIFIERS): Likewise.\n+\t(LOADSTRUCT_QUALIFIERS): Likewise.\n+\t(LOADSTRUCTLANE_QUALIFIERS): Likewise.\n+\t(STORESTRUCT_QUALIFIERS): Likewise.\n+\t(STORESTRUCTLANE_QUALIFIERS): Likewise.\n+\t(neon_builtin_type_mode): Delete.\n+\t(v8qi_UP): Map to V8QImode.\n+\t(v8qi_UP): Map to V8QImode.\n+\t(v4hi_UP): Map to V4HImode.\n+\t(v4hf_UP): Map to V4HFmode.\n+\t(v2si_UP): Map to V2SImode.\n+\t(v2sf_UP): Map to V2SFmode.\n+\t(di_UP): Map to DImode.\n+\t(v16qi_UP): Map to V16QImode.\n+\t(v8hi_UP): Map to V8HImode.\n+\t(v4si_UP): Map to V4SImode.\n+\t(v4sf_UP): Map to V4SFmode.\n+\t(v2di_UP): Map to V2DImode.\n+\t(ti_UP): Map to TImode.\n+\t(ei_UP): Map to EImode.\n+\t(oi_UP): Map to OImode.\n+\t(neon_itype): Delete.\n+\t(neon_builtin_datum): Remove itype, make mode a machine_mode.\n+\t(VAR1): Update accordingly.\n+\t(arm_init_neon_builtins): Use machine_mode directly.\n+\t(neon_dereference_pointer): Likewise.\n+\t(arm_expand_neon_args): Use qualifiers to decide operand types.\n+\t(arm_expand_neon_builtin): Likewise.\n+\t* config/arm/arm_neon_builtins.def: Remap operation type for\n+\tmany builtins.\n+\n 2014-11-18  James Greenhalgh  <james.greenhalgh@arm.com>\n \n \t* config/arm/arm-builtins.c (arm_scalar_builtin_types): New."}, {"sha": "7787208d1a0bb07c0fec9623d0e57c12a433845a", "filename": "gcc/config/arm/arm-builtins.c", "status": "modified", "additions": 116, "deletions": 288, "changes": 404, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd79363ce06f60a72c83463963bf67de05b06546/gcc%2Fconfig%2Farm%2Farm-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd79363ce06f60a72c83463963bf67de05b06546/gcc%2Fconfig%2Farm%2Farm-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-builtins.c?ref=bd79363ce06f60a72c83463963bf67de05b06546", "patch": "@@ -73,15 +73,6 @@ enum arm_type_qualifiers\n static enum arm_type_qualifiers\n arm_unop_qualifiers[SIMD_MAX_BUILTIN_ARGS]\n   = { qualifier_none, qualifier_none, qualifier_internal };\n-#define CONVERT_QUALIFIERS (arm_unop_qualifiers)\n-#define COPYSIGNF_QUALIFIERS (arm_unop_qualifiers)\n-#define CREATE_QUALIFIERS (arm_unop_qualifiers)\n-#define DUP_QUALIFIERS (arm_unop_qualifiers)\n-#define FLOAT_WIDEN_QUALIFIERS (arm_unop_qualifiers)\n-#define FLOAT_NARROW_QUALIFIERS (arm_unop_qualifiers)\n-#define REINTERP_QUALIFIERS (arm_unop_qualifiers)\n-#define RINT_QUALIFIERS (arm_unop_qualifiers)\n-#define SPLIT_QUALIFIERS (arm_unop_qualifiers)\n #define UNOP_QUALIFIERS (arm_unop_qualifiers)\n \n /* unsigned T (unsigned T).  */\n@@ -95,66 +86,50 @@ static enum arm_type_qualifiers\n arm_binop_qualifiers[SIMD_MAX_BUILTIN_ARGS]\n   = { qualifier_none, qualifier_none, qualifier_maybe_immediate };\n #define BINOP_QUALIFIERS (arm_binop_qualifiers)\n-#define FIXCONV_QUALIFIERS (arm_binop_qualifiers)\n-#define SCALARMUL_QUALIFIERS (arm_binop_qualifiers)\n-#define SCALARMULL_QUALIFIERS (arm_binop_qualifiers)\n-#define SCALARMULH_QUALIFIERS (arm_binop_qualifiers)\n \n /* T (T, T, T).  */\n static enum arm_type_qualifiers\n arm_ternop_qualifiers[SIMD_MAX_BUILTIN_ARGS]\n   = { qualifier_none, qualifier_none, qualifier_none, qualifier_none };\n #define TERNOP_QUALIFIERS (arm_ternop_qualifiers)\n-#define SELECT_QUALIFIERS (arm_ternop_qualifiers)\n-#define VTBX_QUALIFIERS (arm_ternop_qualifiers)\n \n /* T (T, immediate).  */\n static enum arm_type_qualifiers\n arm_getlane_qualifiers[SIMD_MAX_BUILTIN_ARGS]\n   = { qualifier_none, qualifier_none, qualifier_immediate };\n #define GETLANE_QUALIFIERS (arm_getlane_qualifiers)\n-#define SHIFTIMM_QUALIFIERS (arm_getlane_qualifiers)\n \n /* T (T, T, T, immediate).  */\n static enum arm_type_qualifiers\n arm_lanemac_qualifiers[SIMD_MAX_BUILTIN_ARGS]\n   = { qualifier_none, qualifier_none, qualifier_none,\n       qualifier_none, qualifier_immediate };\n #define LANEMAC_QUALIFIERS (arm_lanemac_qualifiers)\n-#define SCALARMAC_QUALIFIERS (arm_lanemac_qualifiers)\n \n /* T (T, T, immediate).  */\n static enum arm_type_qualifiers\n arm_setlane_qualifiers[SIMD_MAX_BUILTIN_ARGS]\n   = { qualifier_none, qualifier_none, qualifier_none, qualifier_immediate };\n-#define LANEMUL_QUALIFIERS (arm_setlane_qualifiers)\n-#define LANEMULH_QUALIFIERS (arm_setlane_qualifiers)\n-#define LANEMULL_QUALIFIERS (arm_setlane_qualifiers)\n #define SETLANE_QUALIFIERS (arm_setlane_qualifiers)\n-#define SHIFTACC_QUALIFIERS (arm_setlane_qualifiers)\n-#define SHIFTINSERT_QUALIFIERS (arm_setlane_qualifiers)\n \n /* T (T, T).  */\n static enum arm_type_qualifiers\n arm_combine_qualifiers[SIMD_MAX_BUILTIN_ARGS]\n   = { qualifier_none, qualifier_none, qualifier_none };\n #define COMBINE_QUALIFIERS (arm_combine_qualifiers)\n-#define VTBL_QUALIFIERS (arm_combine_qualifiers)\n \n /* T ([T element type] *).  */\n static enum arm_type_qualifiers\n arm_load1_qualifiers[SIMD_MAX_BUILTIN_ARGS]\n   = { qualifier_none, qualifier_const_pointer_map_mode };\n #define LOAD1_QUALIFIERS (arm_load1_qualifiers)\n-#define LOADSTRUCT_QUALIFIERS (arm_load1_qualifiers)\n \n /* T ([T element type] *, T, immediate).  */\n static enum arm_type_qualifiers\n arm_load1_lane_qualifiers[SIMD_MAX_BUILTIN_ARGS]\n   = { qualifier_none, qualifier_const_pointer_map_mode,\n       qualifier_none, qualifier_immediate };\n #define LOAD1LANE_QUALIFIERS (arm_load1_lane_qualifiers)\n-#define LOADSTRUCTLANE_QUALIFIERS (arm_load1_lane_qualifiers)\n \n /* The first argument (return type) of a store should be void type,\n    which we represent with qualifier_void.  Their first operand will be\n@@ -167,108 +142,34 @@ static enum arm_type_qualifiers\n arm_store1_qualifiers[SIMD_MAX_BUILTIN_ARGS]\n   = { qualifier_void, qualifier_pointer_map_mode, qualifier_none };\n #define STORE1_QUALIFIERS (arm_store1_qualifiers)\n-#define STORESTRUCT_QUALIFIERS (arm_store1_qualifiers)\n \n    /* void ([T element type] *, T, immediate).  */\n static enum arm_type_qualifiers\n arm_storestruct_lane_qualifiers[SIMD_MAX_BUILTIN_ARGS]\n   = { qualifier_void, qualifier_pointer_map_mode,\n       qualifier_none, qualifier_immediate };\n #define STORE1LANE_QUALIFIERS (arm_storestruct_lane_qualifiers)\n-#define STORESTRUCTLANE_QUALIFIERS (arm_storestruct_lane_qualifiers)\n \n-typedef enum {\n-  T_V8QI,\n-  T_V4HI,\n-  T_V4HF,\n-  T_V2SI,\n-  T_V2SF,\n-  T_DI,\n-  T_V16QI,\n-  T_V8HI,\n-  T_V4SI,\n-  T_V4SF,\n-  T_V2DI,\n-  T_TI,\n-  T_EI,\n-  T_OI,\n-  T_MAX\t\t/* Size of enum.  Keep last.  */\n-} neon_builtin_type_mode;\n-\n-#define TYPE_MODE_BIT(X) (1 << (X))\n-\n-#define TB_DREG (TYPE_MODE_BIT (T_V8QI) | TYPE_MODE_BIT (T_V4HI)\t\\\n-\t\t | TYPE_MODE_BIT (T_V4HF) | TYPE_MODE_BIT (T_V2SI)\t\\\n-\t\t | TYPE_MODE_BIT (T_V2SF) | TYPE_MODE_BIT (T_DI))\n-#define TB_QREG (TYPE_MODE_BIT (T_V16QI) | TYPE_MODE_BIT (T_V8HI)\t\\\n-\t\t | TYPE_MODE_BIT (T_V4SI) | TYPE_MODE_BIT (T_V4SF)\t\\\n-\t\t | TYPE_MODE_BIT (T_V2DI) | TYPE_MODE_BIT (T_TI))\n-\n-#define v8qi_UP  T_V8QI\n-#define v4hi_UP  T_V4HI\n-#define v4hf_UP  T_V4HF\n-#define v2si_UP  T_V2SI\n-#define v2sf_UP  T_V2SF\n-#define di_UP    T_DI\n-#define v16qi_UP T_V16QI\n-#define v8hi_UP  T_V8HI\n-#define v4si_UP  T_V4SI\n-#define v4sf_UP  T_V4SF\n-#define v2di_UP  T_V2DI\n-#define ti_UP\t T_TI\n-#define ei_UP\t T_EI\n-#define oi_UP\t T_OI\n+#define v8qi_UP  V8QImode\n+#define v4hi_UP  V4HImode\n+#define v4hf_UP  V4HFmode\n+#define v2si_UP  V2SImode\n+#define v2sf_UP  V2SFmode\n+#define di_UP    DImode\n+#define v16qi_UP V16QImode\n+#define v8hi_UP  V8HImode\n+#define v4si_UP  V4SImode\n+#define v4sf_UP  V4SFmode\n+#define v2di_UP  V2DImode\n+#define ti_UP\t TImode\n+#define ei_UP\t EImode\n+#define oi_UP\t OImode\n \n #define UP(X) X##_UP\n \n-typedef enum {\n-  NEON_BINOP,\n-  NEON_TERNOP,\n-  NEON_UNOP,\n-  NEON_BSWAP,\n-  NEON_GETLANE,\n-  NEON_SETLANE,\n-  NEON_CREATE,\n-  NEON_RINT,\n-  NEON_COPYSIGNF,\n-  NEON_DUP,\n-  NEON_DUPLANE,\n-  NEON_COMBINE,\n-  NEON_SPLIT,\n-  NEON_LANEMUL,\n-  NEON_LANEMULL,\n-  NEON_LANEMULH,\n-  NEON_LANEMAC,\n-  NEON_SCALARMUL,\n-  NEON_SCALARMULL,\n-  NEON_SCALARMULH,\n-  NEON_SCALARMAC,\n-  NEON_CONVERT,\n-  NEON_FLOAT_WIDEN,\n-  NEON_FLOAT_NARROW,\n-  NEON_FIXCONV,\n-  NEON_SELECT,\n-  NEON_REINTERP,\n-  NEON_VTBL,\n-  NEON_VTBX,\n-  NEON_LOAD1,\n-  NEON_LOAD1LANE,\n-  NEON_STORE1,\n-  NEON_STORE1LANE,\n-  NEON_LOADSTRUCT,\n-  NEON_LOADSTRUCTLANE,\n-  NEON_STORESTRUCT,\n-  NEON_STORESTRUCTLANE,\n-  NEON_LOGICBINOP,\n-  NEON_SHIFTINSERT,\n-  NEON_SHIFTIMM,\n-  NEON_SHIFTACC\n-} neon_itype;\n-\n typedef struct {\n   const char *name;\n-  const neon_itype itype;\n-  const neon_builtin_type_mode mode;\n+  machine_mode mode;\n   const enum insn_code code;\n   unsigned int fcode;\n   enum arm_type_qualifiers *qualifiers;\n@@ -277,7 +178,7 @@ typedef struct {\n #define CF(N,X) CODE_FOR_neon_##N##X\n \n #define VAR1(T, N, A) \\\n-  {#N, NEON_##T, UP (A), CF (N, A), 0, T##_QUALIFIERS},\n+  {#N #A, UP (A), CF (N, A), 0, T##_QUALIFIERS},\n #define VAR2(T, N, A, B) \\\n   VAR1 (T, N, A) \\\n   VAR1 (T, N, B)\n@@ -310,10 +211,8 @@ typedef struct {\n    The mode entries in the following table correspond to the \"key\" type of the\n    instruction variant, i.e. equivalent to that which would be specified after\n    the assembler mnemonic, which usually refers to the last vector operand.\n-   (Signed/unsigned/polynomial types are not differentiated between though, and\n-   are all mapped onto the same mode for a given element size.) The modes\n-   listed per instruction should be the same as those defined for that\n-   instruction's pattern in neon.md.  */\n+   The modes listed per instruction should be the same as those defined for\n+   that instruction's pattern in neon.md.  */\n \n static neon_builtin_datum neon_builtin_data[] =\n {\n@@ -980,25 +879,10 @@ arm_init_neon_builtins (void)\n       bool print_type_signature_p = false;\n       char type_signature[SIMD_MAX_BUILTIN_ARGS] = { 0 };\n       neon_builtin_datum *d = &neon_builtin_data[i];\n-      const char *const modenames[] =\n-\t{\n-\t  \"v8qi\", \"v4hi\", \"v4hf\", \"v2si\", \"v2sf\", \"di\",\n-\t  \"v16qi\", \"v8hi\", \"v4si\", \"v4sf\", \"v2di\",\n-\t  \"ti\", \"ei\", \"oi\"\n-\t};\n-      const enum machine_mode modes[] =\n-\t{\n-\t  V8QImode, V4HImode, V4HFmode, V2SImode, V2SFmode, DImode,\n-\t  V16QImode, V8HImode, V4SImode, V4SFmode, V2DImode,\n-\t  TImode, EImode, OImode\n-\t};\n-\n       char namebuf[60];\n       tree ftype = NULL;\n       tree fndecl = NULL;\n \n-      gcc_assert (ARRAY_SIZE (modenames) == T_MAX);\n-\n       d->fcode = fcode;\n \n       /* We must track two variables here.  op_num is\n@@ -1046,7 +930,7 @@ arm_init_neon_builtins (void)\n \t  /* Some builtins have different user-facing types\n \t     for certain arguments, encoded in d->mode.  */\n \t  if (qualifiers & qualifier_map_mode)\n-\t      op_mode = modes[d->mode];\n+\t      op_mode = d->mode;\n \n \t  /* For pointers, we want a pointer to the basic type\n \t     of the vector.  */\n@@ -1080,11 +964,11 @@ arm_init_neon_builtins (void)\n       gcc_assert (ftype != NULL);\n \n       if (print_type_signature_p)\n-\tsnprintf (namebuf, sizeof (namebuf), \"__builtin_neon_%s%s_%s\",\n-\t\t  d->name, modenames[d->mode], type_signature);\n+\tsnprintf (namebuf, sizeof (namebuf), \"__builtin_neon_%s_%s\",\n+\t\t  d->name, type_signature);\n       else\n-\tsnprintf (namebuf, sizeof (namebuf), \"__builtin_neon_%s%s\",\n-\t\t  d->name, modenames[d->mode]);\n+\tsnprintf (namebuf, sizeof (namebuf), \"__builtin_neon_%s\",\n+\t\t  d->name);\n \n       fndecl = add_builtin_function (namebuf, ftype, fcode, BUILT_IN_MD,\n \t\t\t\t     NULL, NULL_TREE);\n@@ -2048,7 +1932,7 @@ typedef enum {\n static tree\n neon_dereference_pointer (tree exp, tree type, machine_mode mem_mode,\n \t\t\t  machine_mode reg_mode,\n-\t\t\t  neon_builtin_type_mode type_mode)\n+\t\t\t  machine_mode vector_mode)\n {\n   HOST_WIDE_INT reg_size, vector_size, nvectors, nelems;\n   tree elem_type, upper_bound, array_type;\n@@ -2057,8 +1941,7 @@ neon_dereference_pointer (tree exp, tree type, machine_mode mem_mode,\n   reg_size = GET_MODE_SIZE (reg_mode);\n \n   /* Work out the size of each vector in bytes.  */\n-  gcc_assert (TYPE_MODE_BIT (type_mode) & (TB_DREG | TB_QREG));\n-  vector_size = (TYPE_MODE_BIT (type_mode) & TB_QREG ? 16 : 8);\n+  vector_size = GET_MODE_SIZE (vector_mode);\n \n   /* Work out how many vectors there are.  */\n   gcc_assert (reg_size % vector_size == 0);\n@@ -2087,29 +1970,25 @@ neon_dereference_pointer (tree exp, tree type, machine_mode mem_mode,\n \n /* Expand a Neon builtin.  */\n static rtx\n-arm_expand_neon_args (rtx target, int icode, int have_retval,\n-\t\t      neon_builtin_type_mode type_mode,\n-\t\t      tree exp, int fcode, ...)\n+arm_expand_neon_args (rtx target, machine_mode map_mode, int fcode,\n+\t\t      int icode, int have_retval, tree exp, ...)\n {\n   va_list ap;\n   rtx pat;\n-  tree arg[NEON_MAX_BUILTIN_ARGS];\n-  rtx op[NEON_MAX_BUILTIN_ARGS];\n-  tree arg_type;\n-  tree formals;\n+  tree arg[SIMD_MAX_BUILTIN_ARGS];\n+  rtx op[SIMD_MAX_BUILTIN_ARGS];\n   machine_mode tmode = insn_data[icode].operand[0].mode;\n-  machine_mode mode[NEON_MAX_BUILTIN_ARGS];\n-  machine_mode other_mode;\n+  machine_mode mode[SIMD_MAX_BUILTIN_ARGS];\n+  tree formals;\n   int argc = 0;\n-  int opno;\n \n   if (have_retval\n       && (!target\n \t  || GET_MODE (target) != tmode\n \t  || !(*insn_data[icode].operand[0].predicate) (target, tmode)))\n     target = gen_reg_rtx (tmode);\n \n-  va_start (ap, fcode);\n+  va_start (ap, exp);\n \n   formals = TYPE_ARG_TYPES (TREE_TYPE (arm_builtin_decls[fcode]));\n \n@@ -2118,19 +1997,20 @@ arm_expand_neon_args (rtx target, int icode, int have_retval,\n       builtin_arg thisarg = (builtin_arg) va_arg (ap, int);\n \n       if (thisarg == NEON_ARG_STOP)\n-        break;\n+\tbreak;\n       else\n-        {\n-          opno = argc + have_retval;\n-          mode[argc] = insn_data[icode].operand[opno].mode;\n-          arg[argc] = CALL_EXPR_ARG (exp, argc);\n-\t  arg_type = TREE_VALUE (formals);\n+\t{\n+\t  int opno = argc + have_retval;\n+\t  arg[argc] = CALL_EXPR_ARG (exp, argc);\n+\t  mode[argc] = insn_data[icode].operand[opno].mode;\n           if (thisarg == NEON_ARG_MEMORY)\n             {\n-              other_mode = insn_data[icode].operand[1 - opno].mode;\n-              arg[argc] = neon_dereference_pointer (arg[argc], arg_type,\n+              machine_mode other_mode\n+\t\t= insn_data[icode].operand[1 - opno].mode;\n+              arg[argc] = neon_dereference_pointer (arg[argc],\n+\t\t\t\t\t\t    TREE_VALUE (formals),\n \t\t\t\t\t\t    mode[argc], other_mode,\n-\t\t\t\t\t\t    type_mode);\n+\t\t\t\t\t\t    map_mode);\n             }\n \n \t  /* Use EXPAND_MEMORY for NEON_ARG_MEMORY to ensure a MEM_P\n@@ -2139,22 +2019,23 @@ arm_expand_neon_args (rtx target, int icode, int have_retval,\n \t\t\t\t  (thisarg == NEON_ARG_MEMORY\n \t\t\t\t   ? EXPAND_MEMORY : EXPAND_NORMAL));\n \n-          switch (thisarg)\n-            {\n-            case NEON_ARG_COPY_TO_REG:\n-              /*gcc_assert (GET_MODE (op[argc]) == mode[argc]);*/\n-              if (!(*insn_data[icode].operand[opno].predicate)\n-                     (op[argc], mode[argc]))\n-                op[argc] = copy_to_mode_reg (mode[argc], op[argc]);\n-              break;\n-\n-            case NEON_ARG_CONSTANT:\n-              /* FIXME: This error message is somewhat unhelpful.  */\n-              if (!(*insn_data[icode].operand[opno].predicate)\n-                    (op[argc], mode[argc]))\n-\t\terror (\"argument must be a constant\");\n-              break;\n+\t  switch (thisarg)\n+\t    {\n+\t    case NEON_ARG_COPY_TO_REG:\n+\t      if (POINTER_TYPE_P (TREE_TYPE (arg[argc])))\n+\t\top[argc] = convert_memory_address (Pmode, op[argc]);\n+\t      /*gcc_assert (GET_MODE (op[argc]) == mode[argc]); */\n+\t      if (!(*insn_data[icode].operand[opno].predicate)\n+\t\t  (op[argc], mode[argc]))\n+\t\top[argc] = copy_to_mode_reg (mode[argc], op[argc]);\n+\t      break;\n \n+\t    case NEON_ARG_CONSTANT:\n+\t      if (!(*insn_data[icode].operand[opno].predicate)\n+\t\t  (op[argc], mode[argc]))\n+\t\terror_at (EXPR_LOCATION (exp), \"incompatible type for argument %d, \"\n+\t\t       \"expected %<const int%>\", argc + 1);\n+\t      break;\n             case NEON_ARG_MEMORY:\n \t      /* Check if expand failed.  */\n \t      if (op[argc] == const0_rtx)\n@@ -2166,18 +2047,17 @@ arm_expand_neon_args (rtx target, int icode, int have_retval,\n \t\t alias safe.  */\n \t      set_mem_alias_set (op[argc], 0);\n \t      if (!(*insn_data[icode].operand[opno].predicate)\n-                    (op[argc], mode[argc]))\n+                   (op[argc], mode[argc]))\n \t\top[argc] = (replace_equiv_address\n \t\t\t    (op[argc], force_reg (Pmode, XEXP (op[argc], 0))));\n               break;\n \n-            case NEON_ARG_STOP:\n-              gcc_unreachable ();\n-            }\n+\t    case NEON_ARG_STOP:\n+\t      gcc_unreachable ();\n+\t    }\n \n-          argc++;\n-\t  formals = TREE_CHAIN (formals);\n-        }\n+\t  argc++;\n+\t}\n     }\n \n   va_end (ap);\n@@ -2229,7 +2109,7 @@ arm_expand_neon_args (rtx target, int icode, int have_retval,\n \n       case 5:\n \tpat = GEN_FCN (icode) (op[0], op[1], op[2], op[3], op[4]);\n-        break;\n+\tbreak;\n \n       default:\n \tgcc_unreachable ();\n@@ -2249,113 +2129,61 @@ arm_expand_neon_args (rtx target, int icode, int have_retval,\n static rtx\n arm_expand_neon_builtin (int fcode, tree exp, rtx target)\n {\n-  neon_builtin_datum *d = &neon_builtin_data[fcode - ARM_BUILTIN_NEON_BASE];\n-  neon_itype itype = d->itype;\n+  neon_builtin_datum *d =\n+\t\t&neon_builtin_data[fcode - ARM_BUILTIN_NEON_BASE];\n   enum insn_code icode = d->code;\n-  neon_builtin_type_mode type_mode = d->mode;\n+  builtin_arg args[SIMD_MAX_BUILTIN_ARGS];\n+  int num_args = insn_data[d->code].n_operands;\n+  int is_void = 0;\n+  int k;\n+\n+  is_void = !!(d->qualifiers[0] & qualifier_void);\n \n-  switch (itype)\n+  num_args += is_void;\n+\n+  for (k = 1; k < num_args; k++)\n     {\n-    case NEON_UNOP:\n-    case NEON_CONVERT:\n-    case NEON_DUPLANE:\n-      return arm_expand_neon_args (target, icode, 1, type_mode, exp, fcode,\n-        NEON_ARG_COPY_TO_REG, NEON_ARG_STOP);\n-\n-    case NEON_BINOP:\n-    case NEON_LOGICBINOP:\n-    case NEON_SCALARMUL:\n-    case NEON_SCALARMULL:\n-    case NEON_SCALARMULH:\n-      return arm_expand_neon_args (target, icode, 1, type_mode, exp, fcode,\n-        NEON_ARG_COPY_TO_REG, NEON_ARG_COPY_TO_REG, NEON_ARG_STOP);\n-\n-    case NEON_TERNOP:\n-      return arm_expand_neon_args (target, icode, 1, type_mode, exp, fcode,\n-        NEON_ARG_COPY_TO_REG, NEON_ARG_COPY_TO_REG, NEON_ARG_COPY_TO_REG,\n-        NEON_ARG_STOP);\n-\n-    case NEON_GETLANE:\n-    case NEON_FIXCONV:\n-    case NEON_SHIFTIMM:\n-      return arm_expand_neon_args (target, icode, 1, type_mode, exp, fcode,\n-        NEON_ARG_COPY_TO_REG, NEON_ARG_CONSTANT,\n-        NEON_ARG_STOP);\n-\n-    case NEON_CREATE:\n-      return arm_expand_neon_args (target, icode, 1, type_mode, exp, fcode,\n-        NEON_ARG_COPY_TO_REG, NEON_ARG_STOP);\n-\n-    case NEON_DUP:\n-    case NEON_RINT:\n-    case NEON_SPLIT:\n-    case NEON_FLOAT_WIDEN:\n-    case NEON_FLOAT_NARROW:\n-    case NEON_BSWAP:\n-    case NEON_REINTERP:\n-      return arm_expand_neon_args (target, icode, 1, type_mode, exp, fcode,\n-        NEON_ARG_COPY_TO_REG, NEON_ARG_STOP);\n-\n-    case NEON_COPYSIGNF:\n-    case NEON_COMBINE:\n-    case NEON_VTBL:\n-      return arm_expand_neon_args (target, icode, 1, type_mode, exp, fcode,\n-        NEON_ARG_COPY_TO_REG, NEON_ARG_COPY_TO_REG, NEON_ARG_STOP);\n-\n-    case NEON_LANEMUL:\n-    case NEON_LANEMULL:\n-    case NEON_LANEMULH:\n-    case NEON_SETLANE:\n-    case NEON_SHIFTINSERT:\n-      return arm_expand_neon_args (target, icode, 1, type_mode, exp, fcode,\n-        NEON_ARG_COPY_TO_REG, NEON_ARG_COPY_TO_REG, NEON_ARG_CONSTANT,\n-        NEON_ARG_STOP);\n-\n-    case NEON_LANEMAC:\n-      return arm_expand_neon_args (target, icode, 1, type_mode, exp, fcode,\n-        NEON_ARG_COPY_TO_REG, NEON_ARG_COPY_TO_REG, NEON_ARG_COPY_TO_REG,\n-        NEON_ARG_CONSTANT, NEON_ARG_STOP);\n-\n-    case NEON_SHIFTACC:\n-      return arm_expand_neon_args (target, icode, 1, type_mode, exp, fcode,\n-        NEON_ARG_COPY_TO_REG, NEON_ARG_COPY_TO_REG, NEON_ARG_CONSTANT,\n-        NEON_ARG_STOP);\n-\n-    case NEON_SCALARMAC:\n-      return arm_expand_neon_args (target, icode, 1, type_mode, exp, fcode,\n-\tNEON_ARG_COPY_TO_REG, NEON_ARG_COPY_TO_REG, NEON_ARG_COPY_TO_REG,\n-        NEON_ARG_STOP);\n-\n-    case NEON_SELECT:\n-    case NEON_VTBX:\n-      return arm_expand_neon_args (target, icode, 1, type_mode, exp, fcode,\n-\tNEON_ARG_COPY_TO_REG, NEON_ARG_COPY_TO_REG, NEON_ARG_COPY_TO_REG,\n-        NEON_ARG_STOP);\n-\n-    case NEON_LOAD1:\n-    case NEON_LOADSTRUCT:\n-      return arm_expand_neon_args (target, icode, 1, type_mode, exp, fcode,\n-\tNEON_ARG_MEMORY, NEON_ARG_STOP);\n-\n-    case NEON_LOAD1LANE:\n-    case NEON_LOADSTRUCTLANE:\n-      return arm_expand_neon_args (target, icode, 1, type_mode, exp, fcode,\n-\tNEON_ARG_MEMORY, NEON_ARG_COPY_TO_REG, NEON_ARG_CONSTANT,\n-\tNEON_ARG_STOP);\n-\n-    case NEON_STORE1:\n-    case NEON_STORESTRUCT:\n-      return arm_expand_neon_args (target, icode, 0, type_mode, exp, fcode,\n-\tNEON_ARG_MEMORY, NEON_ARG_COPY_TO_REG, NEON_ARG_STOP);\n-\n-    case NEON_STORE1LANE:\n-    case NEON_STORESTRUCTLANE:\n-      return arm_expand_neon_args (target, icode, 0, type_mode, exp, fcode,\n-\tNEON_ARG_MEMORY, NEON_ARG_COPY_TO_REG, NEON_ARG_CONSTANT,\n-\tNEON_ARG_STOP);\n+      /* We have four arrays of data, each indexed in a different fashion.\n+\t qualifiers - element 0 always describes the function return type.\n+\t operands - element 0 is either the operand for return value (if\n+\t   the function has a non-void return type) or the operand for the\n+\t   first argument.\n+\t expr_args - element 0 always holds the first argument.\n+\t args - element 0 is always used for the return type.  */\n+      int qualifiers_k = k;\n+      int operands_k = k - is_void;\n+      int expr_args_k = k - 1;\n+\n+      if (d->qualifiers[qualifiers_k] & qualifier_immediate)\n+\targs[k] = NEON_ARG_CONSTANT;\n+      else if (d->qualifiers[qualifiers_k] & qualifier_maybe_immediate)\n+\t{\n+\t  rtx arg\n+\t    = expand_normal (CALL_EXPR_ARG (exp,\n+\t\t\t\t\t    (expr_args_k)));\n+\t  /* Handle constants only if the predicate allows it.  */\n+\t  bool op_const_int_p =\n+\t    (CONST_INT_P (arg)\n+\t     && (*insn_data[icode].operand[operands_k].predicate)\n+\t\t(arg, insn_data[icode].operand[operands_k].mode));\n+\t  args[k] = op_const_int_p ? NEON_ARG_CONSTANT : NEON_ARG_COPY_TO_REG;\n+\t}\n+      else if (d->qualifiers[qualifiers_k] & qualifier_pointer)\n+\targs[k] = NEON_ARG_MEMORY;\n+      else\n+\targs[k] = NEON_ARG_COPY_TO_REG;\n     }\n-\n-  gcc_unreachable ();\n+  args[k] = NEON_ARG_STOP;\n+\n+  /* The interface to arm_expand_neon_args expects a 0 if\n+     the function is void, and a 1 if it is not.  */\n+  return arm_expand_neon_args\n+\t  (target, d->mode, fcode, icode, !is_void, exp,\n+\t   args[1],\n+\t   args[2],\n+\t   args[3],\n+\t   args[4],\n+\t   NEON_ARG_STOP);\n }\n \n /* Expand an expression EXP that calls a built-in function,"}, {"sha": "b19dc23a4a963dea817277067545dc353d6fe27d", "filename": "gcc/config/arm/arm_neon_builtins.def", "status": "modified", "additions": 109, "deletions": 109, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd79363ce06f60a72c83463963bf67de05b06546/gcc%2Fconfig%2Farm%2Farm_neon_builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd79363ce06f60a72c83463963bf67de05b06546/gcc%2Fconfig%2Farm%2Farm_neon_builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm_neon_builtins.def?ref=bd79363ce06f60a72c83463963bf67de05b06546", "patch": "@@ -48,16 +48,16 @@ VAR2 (TERNOP, vqdmlsl, v4hi, v2si)\n VAR3 (BINOP, vmullp, v8qi, v4hi, v2si)\n VAR3 (BINOP, vmulls, v8qi, v4hi, v2si)\n VAR3 (BINOP, vmullu, v8qi, v4hi, v2si)\n-VAR2 (SCALARMULL, vmulls_n, v4hi, v2si)\n-VAR2 (SCALARMULL, vmullu_n, v4hi, v2si)\n-VAR2 (LANEMULL, vmulls_lane, v4hi, v2si)\n-VAR2 (LANEMULL, vmullu_lane, v4hi, v2si)\n-VAR2 (SCALARMULL, vqdmull_n, v4hi, v2si)\n-VAR2 (LANEMULL, vqdmull_lane, v4hi, v2si)\n-VAR4 (SCALARMULH, vqdmulh_n, v4hi, v2si, v8hi, v4si)\n-VAR4 (SCALARMULH, vqrdmulh_n, v4hi, v2si, v8hi, v4si)\n-VAR4 (LANEMULH, vqdmulh_lane, v4hi, v2si, v8hi, v4si)\n-VAR4 (LANEMULH, vqrdmulh_lane, v4hi, v2si, v8hi, v4si)\n+VAR2 (BINOP, vmulls_n, v4hi, v2si)\n+VAR2 (BINOP, vmullu_n, v4hi, v2si)\n+VAR2 (SETLANE, vmulls_lane, v4hi, v2si)\n+VAR2 (SETLANE, vmullu_lane, v4hi, v2si)\n+VAR2 (BINOP, vqdmull_n, v4hi, v2si)\n+VAR2 (SETLANE, vqdmull_lane, v4hi, v2si)\n+VAR4 (BINOP, vqdmulh_n, v4hi, v2si, v8hi, v4si)\n+VAR4 (BINOP, vqrdmulh_n, v4hi, v2si, v8hi, v4si)\n+VAR4 (SETLANE, vqdmulh_lane, v4hi, v2si, v8hi, v4si)\n+VAR4 (SETLANE, vqrdmulh_lane, v4hi, v2si, v8hi, v4si)\n VAR2 (BINOP, vqdmull, v4hi, v2si)\n VAR8 (BINOP, vshls, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)\n VAR8 (BINOP, vshlu, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)\n@@ -67,28 +67,28 @@ VAR8 (BINOP, vqshls, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)\n VAR8 (BINOP, vqshlu, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)\n VAR8 (BINOP, vqrshls, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)\n VAR8 (BINOP, vqrshlu, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)\n-VAR8 (SHIFTIMM, vshrs_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)\n-VAR8 (SHIFTIMM, vshru_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)\n-VAR8 (SHIFTIMM, vrshrs_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)\n-VAR8 (SHIFTIMM, vrshru_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)\n-VAR3 (SHIFTIMM, vshrn_n, v8hi, v4si, v2di)\n-VAR3 (SHIFTIMM, vrshrn_n, v8hi, v4si, v2di)\n-VAR3 (SHIFTIMM, vqshrns_n, v8hi, v4si, v2di)\n-VAR3 (SHIFTIMM, vqshrnu_n, v8hi, v4si, v2di)\n-VAR3 (SHIFTIMM, vqrshrns_n, v8hi, v4si, v2di)\n-VAR3 (SHIFTIMM, vqrshrnu_n, v8hi, v4si, v2di)\n-VAR3 (SHIFTIMM, vqshrun_n, v8hi, v4si, v2di)\n-VAR3 (SHIFTIMM, vqrshrun_n, v8hi, v4si, v2di)\n-VAR8 (SHIFTIMM, vshl_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)\n-VAR8 (SHIFTIMM, vqshl_s_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)\n-VAR8 (SHIFTIMM, vqshl_u_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)\n-VAR8 (SHIFTIMM, vqshlu_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)\n-VAR3 (SHIFTIMM, vshlls_n, v8qi, v4hi, v2si)\n-VAR3 (SHIFTIMM, vshllu_n, v8qi, v4hi, v2si)\n-VAR8 (SHIFTACC, vsras_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)\n-VAR8 (SHIFTACC, vsrau_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)\n-VAR8 (SHIFTACC, vrsras_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)\n-VAR8 (SHIFTACC, vrsrau_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)\n+VAR8 (GETLANE, vshrs_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)\n+VAR8 (GETLANE, vshru_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)\n+VAR8 (GETLANE, vrshrs_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)\n+VAR8 (GETLANE, vrshru_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)\n+VAR3 (GETLANE, vshrn_n, v8hi, v4si, v2di)\n+VAR3 (GETLANE, vrshrn_n, v8hi, v4si, v2di)\n+VAR3 (GETLANE, vqshrns_n, v8hi, v4si, v2di)\n+VAR3 (GETLANE, vqshrnu_n, v8hi, v4si, v2di)\n+VAR3 (GETLANE, vqrshrns_n, v8hi, v4si, v2di)\n+VAR3 (GETLANE, vqrshrnu_n, v8hi, v4si, v2di)\n+VAR3 (GETLANE, vqshrun_n, v8hi, v4si, v2di)\n+VAR3 (GETLANE, vqrshrun_n, v8hi, v4si, v2di)\n+VAR8 (GETLANE, vshl_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)\n+VAR8 (GETLANE, vqshl_s_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)\n+VAR8 (GETLANE, vqshl_u_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)\n+VAR8 (GETLANE, vqshlu_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)\n+VAR3 (GETLANE, vshlls_n, v8qi, v4hi, v2si)\n+VAR3 (GETLANE, vshllu_n, v8qi, v4hi, v2si)\n+VAR8 (SETLANE, vsras_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)\n+VAR8 (SETLANE, vsrau_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)\n+VAR8 (SETLANE, vrsras_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)\n+VAR8 (SETLANE, vrsrau_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)\n VAR2 (BINOP, vsub, v2sf, v4sf)\n VAR3 (BINOP, vsubls, v8qi, v4hi, v2si)\n VAR3 (BINOP, vsublu, v8qi, v4hi, v2si)\n@@ -140,8 +140,8 @@ VAR6 (BINOP, vpadals, v8qi, v4hi, v2si, v16qi, v8hi, v4si)\n VAR6 (BINOP, vpadalu, v8qi, v4hi, v2si, v16qi, v8hi, v4si)\n VAR2 (BINOP, vrecps, v2sf, v4sf)\n VAR2 (BINOP, vrsqrts, v2sf, v4sf)\n-VAR8 (SHIFTINSERT, vsri_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)\n-VAR8 (SHIFTINSERT, vsli_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)\n+VAR8 (SETLANE, vsri_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)\n+VAR8 (SETLANE, vsli_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)\n VAR8 (UNOP, vabs, v8qi, v4hi, v2si, v2sf, v16qi, v8hi, v4si, v4sf)\n VAR6 (UNOP, vqabs, v8qi, v4hi, v2si, v16qi, v8hi, v4si)\n VAR8 (UNOP, vneg, v8qi, v4hi, v2si, v2sf, v16qi, v8hi, v4si, v4sf)\n@@ -159,21 +159,21 @@ VAR10 (GETLANE, vget_lane,\n VAR6 (GETLANE, vget_laneu, v8qi, v4hi, v2si, v16qi, v8hi, v4si)\n VAR10 (SETLANE, vset_lane,\n \t v8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf, v2di)\n-VAR5 (CREATE, vcreate, v8qi, v4hi, v2si, v2sf, di)\n-VAR10 (DUP, vdup_n,\n+VAR5 (UNOP, vcreate, v8qi, v4hi, v2si, v2sf, di)\n+VAR10 (UNOP, vdup_n,\n \t v8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf, v2di)\n VAR10 (BINOP, vdup_lane,\n \t v8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf, v2di)\n VAR5 (COMBINE, vcombine, v8qi, v4hi, v2si, v2sf, di)\n-VAR5 (SPLIT, vget_high, v16qi, v8hi, v4si, v4sf, v2di)\n-VAR5 (SPLIT, vget_low, v16qi, v8hi, v4si, v4sf, v2di)\n+VAR5 (UNOP, vget_high, v16qi, v8hi, v4si, v4sf, v2di)\n+VAR5 (UNOP, vget_low, v16qi, v8hi, v4si, v4sf, v2di)\n VAR3 (UNOP, vmovn, v8hi, v4si, v2di)\n VAR3 (UNOP, vqmovns, v8hi, v4si, v2di)\n VAR3 (UNOP, vqmovnu, v8hi, v4si, v2di)\n VAR3 (UNOP, vqmovun, v8hi, v4si, v2di)\n VAR3 (UNOP, vmovls, v8qi, v4hi, v2si)\n VAR3 (UNOP, vmovlu, v8qi, v4hi, v2si)\n-VAR6 (LANEMUL, vmul_lane, v4hi, v2si, v2sf, v8hi, v4si, v4sf)\n+VAR6 (SETLANE, vmul_lane, v4hi, v2si, v2sf, v8hi, v4si, v4sf)\n VAR6 (LANEMAC, vmla_lane, v4hi, v2si, v2sf, v8hi, v4si, v4sf)\n VAR2 (LANEMAC, vmlals_lane, v4hi, v2si)\n VAR2 (LANEMAC, vmlalu_lane, v4hi, v2si)\n@@ -182,66 +182,66 @@ VAR6 (LANEMAC, vmls_lane, v4hi, v2si, v2sf, v8hi, v4si, v4sf)\n VAR2 (LANEMAC, vmlsls_lane, v4hi, v2si)\n VAR2 (LANEMAC, vmlslu_lane, v4hi, v2si)\n VAR2 (LANEMAC, vqdmlsl_lane, v4hi, v2si)\n-VAR6 (SCALARMUL, vmul_n, v4hi, v2si, v2sf, v8hi, v4si, v4sf)\n-VAR6 (SCALARMAC, vmla_n, v4hi, v2si, v2sf, v8hi, v4si, v4sf)\n-VAR2 (SCALARMAC, vmlals_n, v4hi, v2si)\n-VAR2 (SCALARMAC, vmlalu_n, v4hi, v2si)\n-VAR2 (SCALARMAC, vqdmlal_n, v4hi, v2si)\n-VAR6 (SCALARMAC, vmls_n, v4hi, v2si, v2sf, v8hi, v4si, v4sf)\n-VAR2 (SCALARMAC, vmlsls_n, v4hi, v2si)\n-VAR2 (SCALARMAC, vmlslu_n, v4hi, v2si)\n-VAR2 (SCALARMAC, vqdmlsl_n, v4hi, v2si)\n-VAR10 (SHIFTINSERT, vext,\n+VAR6 (BINOP, vmul_n, v4hi, v2si, v2sf, v8hi, v4si, v4sf)\n+VAR6 (LANEMAC, vmla_n, v4hi, v2si, v2sf, v8hi, v4si, v4sf)\n+VAR2 (LANEMAC, vmlals_n, v4hi, v2si)\n+VAR2 (LANEMAC, vmlalu_n, v4hi, v2si)\n+VAR2 (LANEMAC, vqdmlal_n, v4hi, v2si)\n+VAR6 (LANEMAC, vmls_n, v4hi, v2si, v2sf, v8hi, v4si, v4sf)\n+VAR2 (LANEMAC, vmlsls_n, v4hi, v2si)\n+VAR2 (LANEMAC, vmlslu_n, v4hi, v2si)\n+VAR2 (LANEMAC, vqdmlsl_n, v4hi, v2si)\n+VAR10 (SETLANE, vext,\n \t v8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf, v2di)\n VAR8 (UNOP, vrev64, v8qi, v4hi, v2si, v2sf, v16qi, v8hi, v4si, v4sf)\n VAR4 (UNOP, vrev32, v8qi, v4hi, v16qi, v8hi)\n VAR2 (UNOP, vrev16, v8qi, v16qi)\n-VAR4 (CONVERT, vcvts, v2si, v2sf, v4si, v4sf)\n-VAR4 (CONVERT, vcvtu, v2si, v2sf, v4si, v4sf)\n-VAR4 (FIXCONV, vcvts_n, v2si, v2sf, v4si, v4sf)\n-VAR4 (FIXCONV, vcvtu_n, v2si, v2sf, v4si, v4sf)\n-VAR1 (FLOAT_WIDEN, vcvtv4sf, v4hf)\n-VAR1 (FLOAT_NARROW, vcvtv4hf, v4sf)\n-VAR10 (SELECT, vbsl,\n+VAR4 (UNOP, vcvts, v2si, v2sf, v4si, v4sf)\n+VAR4 (UNOP, vcvtu, v2si, v2sf, v4si, v4sf)\n+VAR4 (BINOP, vcvts_n, v2si, v2sf, v4si, v4sf)\n+VAR4 (BINOP, vcvtu_n, v2si, v2sf, v4si, v4sf)\n+VAR1 (UNOP, vcvtv4sf, v4hf)\n+VAR1 (UNOP, vcvtv4hf, v4sf)\n+VAR10 (TERNOP, vbsl,\n \t v8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf, v2di)\n-VAR2 (COPYSIGNF, copysignf, v2sf, v4sf)\n-VAR2 (RINT, vrintn, v2sf, v4sf)\n-VAR2 (RINT, vrinta, v2sf, v4sf)\n-VAR2 (RINT, vrintp, v2sf, v4sf)\n-VAR2 (RINT, vrintm, v2sf, v4sf)\n-VAR2 (RINT, vrintz, v2sf, v4sf)\n-VAR2 (RINT, vrintx, v2sf, v4sf)\n-VAR1 (RINT, vcvtav2sf, v2si)\n-VAR1 (RINT, vcvtav4sf, v4si)\n-VAR1 (RINT, vcvtauv2sf, v2si)\n-VAR1 (RINT, vcvtauv4sf, v4si)\n-VAR1 (RINT, vcvtpv2sf, v2si)\n-VAR1 (RINT, vcvtpv4sf, v4si)\n-VAR1 (RINT, vcvtpuv2sf, v2si)\n-VAR1 (RINT, vcvtpuv4sf, v4si)\n-VAR1 (RINT, vcvtmv2sf, v2si)\n-VAR1 (RINT, vcvtmv4sf, v4si)\n-VAR1 (RINT, vcvtmuv2sf, v2si)\n-VAR1 (RINT, vcvtmuv4sf, v4si)\n-VAR1 (VTBL, vtbl1, v8qi)\n-VAR1 (VTBL, vtbl2, v8qi)\n-VAR1 (VTBL, vtbl3, v8qi)\n-VAR1 (VTBL, vtbl4, v8qi)\n-VAR1 (VTBX, vtbx1, v8qi)\n-VAR1 (VTBX, vtbx2, v8qi)\n-VAR1 (VTBX, vtbx3, v8qi)\n-VAR1 (VTBX, vtbx4, v8qi)\n-VAR5 (REINTERP, vreinterpretv8qi, v8qi, v4hi, v2si, v2sf, di)\n-VAR5 (REINTERP, vreinterpretv4hi, v8qi, v4hi, v2si, v2sf, di)\n-VAR5 (REINTERP, vreinterpretv2si, v8qi, v4hi, v2si, v2sf, di)\n-VAR5 (REINTERP, vreinterpretv2sf, v8qi, v4hi, v2si, v2sf, di)\n-VAR5 (REINTERP, vreinterpretdi, v8qi, v4hi, v2si, v2sf, di)\n-VAR6 (REINTERP, vreinterpretv16qi, v16qi, v8hi, v4si, v4sf, v2di, ti)\n-VAR6 (REINTERP, vreinterpretv8hi, v16qi, v8hi, v4si, v4sf, v2di, ti)\n-VAR6 (REINTERP, vreinterpretv4si, v16qi, v8hi, v4si, v4sf, v2di, ti)\n-VAR6 (REINTERP, vreinterpretv4sf, v16qi, v8hi, v4si, v4sf, v2di, ti)\n-VAR6 (REINTERP, vreinterpretv2di, v16qi, v8hi, v4si, v4sf, v2di, ti)\n-VAR6 (REINTERP, vreinterpretti, v16qi, v8hi, v4si, v4sf, v2di, ti)\n+VAR2 (UNOP, copysignf, v2sf, v4sf)\n+VAR2 (UNOP, vrintn, v2sf, v4sf)\n+VAR2 (UNOP, vrinta, v2sf, v4sf)\n+VAR2 (UNOP, vrintp, v2sf, v4sf)\n+VAR2 (UNOP, vrintm, v2sf, v4sf)\n+VAR2 (UNOP, vrintz, v2sf, v4sf)\n+VAR2 (UNOP, vrintx, v2sf, v4sf)\n+VAR1 (UNOP, vcvtav2sf, v2si)\n+VAR1 (UNOP, vcvtav4sf, v4si)\n+VAR1 (UNOP, vcvtauv2sf, v2si)\n+VAR1 (UNOP, vcvtauv4sf, v4si)\n+VAR1 (UNOP, vcvtpv2sf, v2si)\n+VAR1 (UNOP, vcvtpv4sf, v4si)\n+VAR1 (UNOP, vcvtpuv2sf, v2si)\n+VAR1 (UNOP, vcvtpuv4sf, v4si)\n+VAR1 (UNOP, vcvtmv2sf, v2si)\n+VAR1 (UNOP, vcvtmv4sf, v4si)\n+VAR1 (UNOP, vcvtmuv2sf, v2si)\n+VAR1 (UNOP, vcvtmuv4sf, v4si)\n+VAR1 (COMBINE, vtbl1, v8qi)\n+VAR1 (COMBINE, vtbl2, v8qi)\n+VAR1 (COMBINE, vtbl3, v8qi)\n+VAR1 (COMBINE, vtbl4, v8qi)\n+VAR1 (TERNOP, vtbx1, v8qi)\n+VAR1 (TERNOP, vtbx2, v8qi)\n+VAR1 (TERNOP, vtbx3, v8qi)\n+VAR1 (TERNOP, vtbx4, v8qi)\n+VAR5 (UNOP, vreinterpretv8qi, v8qi, v4hi, v2si, v2sf, di)\n+VAR5 (UNOP, vreinterpretv4hi, v8qi, v4hi, v2si, v2sf, di)\n+VAR5 (UNOP, vreinterpretv2si, v8qi, v4hi, v2si, v2sf, di)\n+VAR5 (UNOP, vreinterpretv2sf, v8qi, v4hi, v2si, v2sf, di)\n+VAR5 (UNOP, vreinterpretdi, v8qi, v4hi, v2si, v2sf, di)\n+VAR6 (UNOP, vreinterpretv16qi, v16qi, v8hi, v4si, v4sf, v2di, ti)\n+VAR6 (UNOP, vreinterpretv8hi, v16qi, v8hi, v4si, v4sf, v2di, ti)\n+VAR6 (UNOP, vreinterpretv4si, v16qi, v8hi, v4si, v4sf, v2di, ti)\n+VAR6 (UNOP, vreinterpretv4sf, v16qi, v8hi, v4si, v4sf, v2di, ti)\n+VAR6 (UNOP, vreinterpretv2di, v16qi, v8hi, v4si, v4sf, v2di, ti)\n+VAR6 (UNOP, vreinterpretti, v16qi, v8hi, v4si, v4sf, v2di, ti)\n VAR10 (LOAD1, vld1,\n         v8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf, v2di)\n VAR10 (LOAD1LANE, vld1_lane,\n@@ -252,30 +252,30 @@ VAR10 (STORE1, vst1,\n \tv8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf, v2di)\n VAR10 (STORE1LANE, vst1_lane,\n \tv8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf, v2di)\n-VAR9 (LOADSTRUCT, vld2,\n+VAR9 (LOAD1, vld2,\n \tv8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf)\n-VAR7 (LOADSTRUCTLANE, vld2_lane,\n+VAR7 (LOAD1LANE, vld2_lane,\n \tv8qi, v4hi, v2si, v2sf, v8hi, v4si, v4sf)\n-VAR5 (LOADSTRUCT, vld2_dup, v8qi, v4hi, v2si, v2sf, di)\n-VAR9 (STORESTRUCT, vst2,\n+VAR5 (LOAD1, vld2_dup, v8qi, v4hi, v2si, v2sf, di)\n+VAR9 (STORE1, vst2,\n \tv8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf)\n-VAR7 (STORESTRUCTLANE, vst2_lane,\n+VAR7 (STORE1LANE, vst2_lane,\n \tv8qi, v4hi, v2si, v2sf, v8hi, v4si, v4sf)\n-VAR9 (LOADSTRUCT, vld3,\n+VAR9 (LOAD1, vld3,\n \tv8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf)\n-VAR7 (LOADSTRUCTLANE, vld3_lane,\n+VAR7 (LOAD1LANE, vld3_lane,\n \tv8qi, v4hi, v2si, v2sf, v8hi, v4si, v4sf)\n-VAR5 (LOADSTRUCT, vld3_dup, v8qi, v4hi, v2si, v2sf, di)\n-VAR9 (STORESTRUCT, vst3,\n+VAR5 (LOAD1, vld3_dup, v8qi, v4hi, v2si, v2sf, di)\n+VAR9 (STORE1, vst3,\n \tv8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf)\n-VAR7 (STORESTRUCTLANE, vst3_lane,\n+VAR7 (STORE1LANE, vst3_lane,\n \tv8qi, v4hi, v2si, v2sf, v8hi, v4si, v4sf)\n-VAR9 (LOADSTRUCT, vld4,\n+VAR9 (LOAD1, vld4,\n \tv8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf)\n-VAR7 (LOADSTRUCTLANE, vld4_lane,\n+VAR7 (LOAD1LANE, vld4_lane,\n \tv8qi, v4hi, v2si, v2sf, v8hi, v4si, v4sf)\n-VAR5 (LOADSTRUCT, vld4_dup, v8qi, v4hi, v2si, v2sf, di)\n-VAR9 (STORESTRUCT, vst4,\n+VAR5 (LOAD1, vld4_dup, v8qi, v4hi, v2si, v2sf, di)\n+VAR9 (STORE1, vst4,\n \tv8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf)\n-VAR7 (STORESTRUCTLANE, vst4_lane,\n+VAR7 (STORE1LANE, vst4_lane,\n \tv8qi, v4hi, v2si, v2sf, v8hi, v4si, v4sf)"}]}