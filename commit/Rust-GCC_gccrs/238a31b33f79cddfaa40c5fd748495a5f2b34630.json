{"sha": "238a31b33f79cddfaa40c5fd748495a5f2b34630", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjM4YTMxYjMzZjc5Y2RkZmFhNDBjNWZkNzQ4NDk1YTVmMmIzNDYzMA==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2021-01-08T07:09:08Z"}, "committer": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2021-01-08T07:09:08Z"}, "message": "Merge branch 'master' of https://github.com/redbrain/gccrs", "tree": {"sha": "bc217d37b5e3ee41b0a69265341945389d1f4dfb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc217d37b5e3ee41b0a69265341945389d1f4dfb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/238a31b33f79cddfaa40c5fd748495a5f2b34630", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/238a31b33f79cddfaa40c5fd748495a5f2b34630", "html_url": "https://github.com/Rust-GCC/gccrs/commit/238a31b33f79cddfaa40c5fd748495a5f2b34630", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/238a31b33f79cddfaa40c5fd748495a5f2b34630/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5f86dca7e6b53ca3701ef01ae36070a760dff78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5f86dca7e6b53ca3701ef01ae36070a760dff78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5f86dca7e6b53ca3701ef01ae36070a760dff78"}, {"sha": "af04ea2222b6407fb3e83759ae332d600495380c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af04ea2222b6407fb3e83759ae332d600495380c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af04ea2222b6407fb3e83759ae332d600495380c"}], "stats": {"total": 1686, "additions": 1511, "deletions": 175}, "files": [{"sha": "c12e2fa2013af4374638915531b21ffef23a58cb", "filename": ".github/workflows/ccpp.yml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/238a31b33f79cddfaa40c5fd748495a5f2b34630/.github%2Fworkflows%2Fccpp.yml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/238a31b33f79cddfaa40c5fd748495a5f2b34630/.github%2Fworkflows%2Fccpp.yml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/.github%2Fworkflows%2Fccpp.yml?ref=238a31b33f79cddfaa40c5fd748495a5f2b34630", "patch": "@@ -49,4 +49,5 @@ jobs:\n     - name: Test\n       run: |\n            cd gccrs-build; \\\n-           make check-rust\n+           make check-rust | tee results.log; \\\n+           if [ `grep \"# of unexpected failures\" results.log | wc -l` != \"0\" ]; then exit 1; fi"}, {"sha": "556e584c50a019d6f6088f1326820e4f23f4224d", "filename": ".github/workflows/greetings.yml", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/238a31b33f79cddfaa40c5fd748495a5f2b34630/.github%2Fworkflows%2Fgreetings.yml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/238a31b33f79cddfaa40c5fd748495a5f2b34630/.github%2Fworkflows%2Fgreetings.yml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/.github%2Fworkflows%2Fgreetings.yml?ref=238a31b33f79cddfaa40c5fd748495a5f2b34630", "patch": "@@ -0,0 +1,13 @@\n+name: Greetings\n+\n+on: [pull_request, issues]\n+\n+jobs:\n+  greeting:\n+    runs-on: ubuntu-latest\n+    steps:\n+    - uses: actions/first-interaction@v1\n+      with:\n+        repo-token: ${{ secrets.GITHUB_TOKEN }}\n+        issue-message: 'Thanks for your contribution fellow Rustacean'\n+        pr-message: 'Thanks for your contribution, please be aware that this project is destined to be upstreamed to GCC. This will require copyright assignment, see https://gcc.gnu.org/contribute.html'"}, {"sha": "092ab0070cec104edcc6650a618c2d66bf710fa6", "filename": "gcc/rust/ast/rust-ast-full-test.cc", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-test.cc?ref=238a31b33f79cddfaa40c5fd748495a5f2b34630", "patch": "@@ -437,7 +437,7 @@ StaticItem::as_string () const\n       str += \" mut\";\n     }\n \n-  str += name;\n+  str += \" \" + name;\n \n   // DEBUG: null pointer check\n   if (type == nullptr)\n@@ -4947,28 +4947,30 @@ MacroParser::parse_literal ()\n     {\n     case CHAR_LITERAL:\n       skip_token ();\n-      return Literal (tok->as_string (), Literal::CHAR);\n+      return Literal (tok->as_string (), Literal::CHAR, tok->get_type_hint ());\n     case STRING_LITERAL:\n       skip_token ();\n-      return Literal (tok->as_string (), Literal::STRING);\n+      return Literal (tok->as_string (), Literal::STRING,\n+\t\t      tok->get_type_hint ());\n     case BYTE_CHAR_LITERAL:\n       skip_token ();\n-      return Literal (tok->as_string (), Literal::BYTE);\n+      return Literal (tok->as_string (), Literal::BYTE, tok->get_type_hint ());\n     case BYTE_STRING_LITERAL:\n       skip_token ();\n-      return Literal (tok->as_string (), Literal::BYTE_STRING);\n+      return Literal (tok->as_string (), Literal::BYTE_STRING,\n+\t\t      tok->get_type_hint ());\n     case INT_LITERAL:\n       skip_token ();\n-      return Literal (tok->as_string (), Literal::INT);\n+      return Literal (tok->as_string (), Literal::INT, tok->get_type_hint ());\n     case FLOAT_LITERAL:\n       skip_token ();\n-      return Literal (tok->as_string (), Literal::FLOAT);\n+      return Literal (tok->as_string (), Literal::FLOAT, tok->get_type_hint ());\n     case TRUE_LITERAL:\n       skip_token ();\n-      return Literal (\"true\", Literal::BOOL);\n+      return Literal (\"true\", Literal::BOOL, tok->get_type_hint ());\n     case FALSE_LITERAL:\n       skip_token ();\n-      return Literal (\"false\", Literal::BOOL);\n+      return Literal (\"false\", Literal::BOOL, tok->get_type_hint ());\n     default:\n       rust_error_at (tok->get_locus (), \"expected literal - found '%s'\",\n \t\t     get_token_description (tok->get_id ()));\n@@ -5291,7 +5293,8 @@ Token::to_token_stream () const\n Attribute\n MetaNameValueStr::to_attribute () const\n {\n-  LiteralExpr lit_expr (str, Literal::LitType::STRING, Location ());\n+  LiteralExpr lit_expr (str, Literal::LitType::STRING,\n+\t\t\tPrimitiveCoreType::CORETYPE_UNKNOWN, Location ());\n   return Attribute (SimplePath::from_str (ident),\n \t\t    std::unique_ptr<AttrInputLiteral> (\n \t\t      new AttrInputLiteral (std::move (lit_expr))));"}, {"sha": "b7baab42ec00974462756606696f629dc4a4983a", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=238a31b33f79cddfaa40c5fd748495a5f2b34630", "patch": "@@ -212,6 +212,8 @@ class Token : public TokenTree, public MacroMatch\n \n   Location get_locus () const { return locus; }\n \n+  PrimitiveCoreType get_type_hint () const { return type_hint; }\n+\n protected:\n   // No virtual for now as not polymorphic but can be in future\n   /*virtual*/ Token *clone_token_impl () const { return new Token (*this); }\n@@ -250,17 +252,25 @@ struct Literal\n    * (or generics) */\n   std::string value_as_string;\n   LitType type;\n+  PrimitiveCoreType type_hint;\n \n public:\n   std::string as_string () const { return value_as_string; }\n \n   LitType get_lit_type () const { return type; }\n \n-  Literal (std::string value_as_string, LitType type)\n-    : value_as_string (std::move (value_as_string)), type (type)\n+  PrimitiveCoreType get_type_hint () const { return type_hint; }\n+\n+  Literal (std::string value_as_string, LitType type,\n+\t   PrimitiveCoreType type_hint)\n+    : value_as_string (std::move (value_as_string)), type (type),\n+      type_hint (type_hint)\n   {}\n \n-  static Literal create_error () { return Literal (\"\", CHAR); }\n+  static Literal create_error ()\n+  {\n+    return Literal (\"\", CHAR, PrimitiveCoreType::CORETYPE_UNKNOWN);\n+  }\n \n   // Returns whether literal is in an invalid state.\n   bool is_error () const { return value_as_string == \"\"; }"}, {"sha": "eee654bcbc1498d410fabcd8e971a9145ec0bfa0", "filename": "gcc/rust/ast/rust-expr.h", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fast%2Frust-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fast%2Frust-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-expr.h?ref=238a31b33f79cddfaa40c5fd748495a5f2b34630", "patch": "@@ -50,10 +50,10 @@ class LiteralExpr : public ExprWithoutBlock\n   Literal::LitType get_lit_type () const { return literal.get_lit_type (); }\n \n   LiteralExpr (std::string value_as_string, Literal::LitType type,\n-\t       Location locus,\n+\t       PrimitiveCoreType type_hint, Location locus,\n \t       std::vector<Attribute> outer_attrs = std::vector<Attribute> ())\n     : ExprWithoutBlock (std::move (outer_attrs)),\n-      literal (std::move (value_as_string), type), locus (locus)\n+      literal (std::move (value_as_string), type, type_hint), locus (locus)\n   {}\n \n   LiteralExpr (Literal literal, Location locus,\n@@ -1572,9 +1572,16 @@ class StructExprField\n \n   virtual Location get_locus_slow () const = 0;\n \n+  NodeId get_node_id () const { return node_id; }\n+\n protected:\n   // pure virtual clone implementation\n   virtual StructExprField *clone_struct_expr_field_impl () const = 0;\n+\n+  StructExprField () : node_id (Analysis::Mappings::get ()->get_next_node_id ())\n+  {}\n+\n+  NodeId node_id;\n };\n \n // Identifier-only variant of StructExprField AST node\n@@ -1585,7 +1592,8 @@ class StructExprFieldIdentifier : public StructExprField\n \n public:\n   StructExprFieldIdentifier (Identifier field_identifier, Location locus)\n-    : field_name (std::move (field_identifier)), locus (locus)\n+    : StructExprField (), field_name (std::move (field_identifier)),\n+      locus (locus)\n   {}\n \n   std::string as_string () const override { return field_name; }\n@@ -1612,7 +1620,7 @@ class StructExprFieldWithVal : public StructExprField\n \n protected:\n   StructExprFieldWithVal (std::unique_ptr<Expr> field_value)\n-    : value (std::move (field_value))\n+    : StructExprField (), value (std::move (field_value))\n   {}\n \n   // Copy constructor requires clone\n@@ -1770,6 +1778,15 @@ class StructExprStructFields : public StructExprStruct\n     return fields;\n   }\n \n+  void iterate (std::function<bool (StructExprField *)> cb)\n+  {\n+    for (auto &field : fields)\n+      {\n+\tif (!cb (field.get ()))\n+\t  return;\n+      }\n+  }\n+\n   StructBase &get_struct_base () { return struct_base; }\n   const StructBase &get_struct_base () const { return struct_base; }\n "}, {"sha": "f558195c6603d32bf6bc0d7f84b212fbaa394cc4", "filename": "gcc/rust/ast/rust-item.h", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-item.h?ref=238a31b33f79cddfaa40c5fd748495a5f2b34630", "patch": "@@ -1748,6 +1748,8 @@ class Struct : public VisItem\n     return where_clause;\n   }\n \n+  Identifier get_identifier () const { return struct_name; }\n+\n protected:\n   Struct (Identifier struct_name,\n \t  std::vector<std::unique_ptr<GenericParam> > generic_params,\n@@ -1804,6 +1806,8 @@ struct StructField\n \n   // should this store location info?\n \n+  NodeId node_id;\n+\n public:\n   // Returns whether struct field has any outer attributes.\n   bool has_outer_attributes () const { return !outer_attrs.empty (); }\n@@ -1879,6 +1883,8 @@ struct StructField\n   }\n \n   Visibility get_visibility () const { return visibility; }\n+\n+  NodeId get_node_id () const { return node_id; }\n };\n \n // Rust struct declaration with true struct type AST node\n@@ -1924,6 +1930,15 @@ class StructStruct : public Struct\n   std::vector<StructField> &get_fields () { return fields; }\n   const std::vector<StructField> &get_fields () const { return fields; }\n \n+  void iterate (std::function<bool (StructField &)> cb)\n+  {\n+    for (auto &field : fields)\n+      {\n+\tif (!cb (field))\n+\t  return;\n+      }\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -2533,6 +2548,8 @@ class ConstantItem : public VisItem,\n     return type;\n   }\n \n+  std::string get_identifier () const { return identifier; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -2643,6 +2660,10 @@ class StaticItem : public VisItem\n     return type;\n   }\n \n+  bool is_mutable () const { return has_mut; }\n+\n+  Identifier get_identifier () const { return name; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */"}, {"sha": "e89fc625677b7e0203d9f886499dd22f1caa7479", "filename": "gcc/rust/ast/rust-pattern.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fast%2Frust-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fast%2Frust-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-pattern.h?ref=238a31b33f79cddfaa40c5fd748495a5f2b34630", "patch": "@@ -47,8 +47,8 @@ class LiteralPattern : public Pattern\n \n   LiteralPattern (std::string val, Literal::LitType type, Location locus,\n \t\t  bool has_minus = false)\n-    : lit (Literal (std::move (val), type)), has_minus (has_minus),\n-      locus (locus)\n+    : lit (Literal (std::move (val), type, PrimitiveCoreType::CORETYPE_STR)),\n+      has_minus (has_minus), locus (locus)\n   {}\n \n   Location get_locus () const { return locus; }"}, {"sha": "d241921933a931e676a722009a276fb1b0fc31f6", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=238a31b33f79cddfaa40c5fd748495a5f2b34630", "patch": "@@ -141,6 +141,21 @@ class Context\n     return true;\n   }\n \n+  void insert_const_decl (HirId id, ::Bexpression *expr)\n+  {\n+    compiled_consts[id] = expr;\n+  }\n+\n+  bool lookup_const_decl (HirId id, ::Bexpression **expr)\n+  {\n+    auto it = compiled_consts.find (id);\n+    if (it == compiled_consts.end ())\n+      return false;\n+\n+    *expr = it->second;\n+    return true;\n+  }\n+\n   void push_fn (::Bfunction *fn, ::Bvariable *ret_addr)\n   {\n     fn_stack.push_back (fncontext{fn, ret_addr});\n@@ -183,6 +198,7 @@ class Context\n   std::map<HirId, ::Bvariable *> compiled_var_decls;\n   std::map<HirId, ::Btype *> compiled_type_map;\n   std::map<HirId, ::Bfunction *> compiled_fn_map;\n+  std::map<HirId, ::Bexpression *> compiled_consts;\n   std::vector< ::std::vector<Bstatement *> > statements;\n   std::vector< ::Bblock *> scope_stack;\n \n@@ -211,6 +227,14 @@ class TyTyResolveCompile : public TyTy::TyVisitor\n \n   void visit (TyTy::FnType &type) override { gcc_unreachable (); }\n \n+  void visit (TyTy::ADTType &type) override\n+  {\n+    ::Btype *compiled_type = nullptr;\n+    bool ok = ctx->lookup_compiled_types (type.get_ref (), &compiled_type);\n+    rust_assert (ok);\n+    translated = compiled_type;\n+  }\n+\n   void visit (TyTy::ArrayType &type) override\n   {\n     mpz_t ival;\n@@ -248,6 +272,14 @@ class TyTyResolveCompile : public TyTy::TyVisitor\n     translated = compiled_type;\n   }\n \n+  void visit (TyTy::FloatType &type) override\n+  {\n+    ::Btype *compiled_type = nullptr;\n+    bool ok = ctx->lookup_compiled_types (type.get_ref (), &compiled_type);\n+    rust_assert (ok);\n+    translated = compiled_type;\n+  }\n+\n private:\n   TyTyResolveCompile (Context *ctx) : ctx (ctx) {}\n "}, {"sha": "90810007857c5ef61c34e155f196b61410689853", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 56, "deletions": 1, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=238a31b33f79cddfaa40c5fd748495a5f2b34630", "patch": "@@ -23,6 +23,7 @@\n #include \"rust-compile-tyty.h\"\n #include \"rust-compile-resolve-path.h\"\n #include \"rust-compile-block.h\"\n+#include \"rust-compile-struct-field-expr.h\"\n \n namespace Rust {\n namespace Compile {\n@@ -56,7 +57,7 @@ class CompileExpr : public HIRCompileBase\n \n   void visit (HIR::CallExpr &expr)\n   {\n-    Bexpression *fn = ResolvePath::Compile (expr.get_fnexpr (), ctx);\n+    Bexpression *fn = ResolvePathRef::Compile (expr.get_fnexpr (), ctx);\n     rust_assert (fn != nullptr);\n \n     std::vector<Bexpression *> args;\n@@ -105,6 +106,11 @@ class CompileExpr : public HIRCompileBase\n \treturn;\n       }\n \n+    // this could be a constant reference\n+    if (ctx->lookup_const_decl (ref, &translated))\n+      return;\n+\n+    // must be an identifier\n     Bvariable *var = nullptr;\n     if (!ctx->lookup_var_decl (ref, &var))\n       {\n@@ -149,6 +155,36 @@ class CompileExpr : public HIRCompileBase\n \t}\n \treturn;\n \n+\tcase HIR::Literal::FLOAT: {\n+\t  printf (\"FLOATY BOYO: [%s]\\n\", expr.as_string ().c_str ());\n+\n+\t  mpfr_t fval;\n+\t  if (mpfr_init_set_str (fval, expr.as_string ().c_str (), 10,\n+\t\t\t\t MPFR_RNDN)\n+\t      != 0)\n+\t    {\n+\t      rust_fatal_error (expr.get_locus (),\n+\t\t\t\t\"bad float number in literal\");\n+\t      return;\n+\t    }\n+\n+\t  TyTy::TyBase *tyty = nullptr;\n+\t  if (!ctx->get_tyctx ()->lookup_type (\n+\t\texpr.get_mappings ().get_hirid (), &tyty))\n+\t    {\n+\t      rust_fatal_error (expr.get_locus (),\n+\t\t\t\t\"did not resolve type for this literal expr\");\n+\t      return;\n+\t    }\n+\n+\t  printf (\"tyty float is [%s]\\n\", tyty->as_string ().c_str ());\n+\n+\t  Btype *type = TyTyResolveCompile::compile (ctx, tyty);\n+\t  translated\n+\t    = ctx->get_backend ()->float_constant_expression (type, fval);\n+\t}\n+\treturn;\n+\n       default:\n \trust_fatal_error (expr.get_locus (), \"unknown literal\");\n \treturn;\n@@ -350,6 +386,25 @@ class CompileExpr : public HIRCompileBase\n     ctx->add_statement (block_stmt);\n   }\n \n+  void visit (HIR::StructExprStructFields &struct_expr)\n+  {\n+    Btype *type\n+      = ResolvePathType::Compile (&struct_expr.get_struct_name (), ctx);\n+\n+    // this assumes all fields are in order from type resolution and if a base\n+    // struct was specified those fields are filed via accesors\n+    std::vector<Bexpression *> vals;\n+    struct_expr.iterate ([&] (HIR::StructExprField *field) mutable -> bool {\n+      Bexpression *expr = CompileStructExprField::Compile (field, ctx);\n+      vals.push_back (expr);\n+      return true;\n+    });\n+\n+    translated\n+      = ctx->get_backend ()->constructor_expression (type, vals,\n+\t\t\t\t\t\t     struct_expr.get_locus ());\n+  }\n+\n private:\n   CompileExpr (Context *ctx) : HIRCompileBase (ctx), translated (nullptr) {}\n "}, {"sha": "90630bb670f7d2c9fe687533597905bb5210356e", "filename": "gcc/rust/backend/rust-compile-item.h", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.h?ref=238a31b33f79cddfaa40c5fd748495a5f2b34630", "patch": "@@ -23,6 +23,7 @@\n #include \"rust-compile-tyty.h\"\n #include \"rust-compile-var-decl.h\"\n #include \"rust-compile-stmt.h\"\n+#include \"rust-compile-expr.h\"\n \n namespace Rust {\n namespace Compile {\n@@ -38,6 +39,81 @@ class CompileItem : public HIRCompileBase\n \n   virtual ~CompileItem () {}\n \n+  void visit (HIR::StructStruct &struct_decl)\n+  {\n+    std::vector<Backend::Btyped_identifier> fields;\n+    struct_decl.iterate ([&] (HIR::StructField &field) mutable -> bool {\n+      TyTy::TyBase *resolved_type = nullptr;\n+      bool ok\n+\t= ctx->get_tyctx ()->lookup_type (field.get_mappings ().get_hirid (),\n+\t\t\t\t\t  &resolved_type);\n+      rust_assert (ok);\n+\n+      Btype *compiled_field_ty\n+\t= TyTyCompile::compile (ctx->get_backend (), resolved_type);\n+\n+      Backend::Btyped_identifier f (field.field_name, compiled_field_ty,\n+\t\t\t\t    field.get_locus ());\n+      fields.push_back (std::move (f));\n+      return true;\n+    });\n+\n+    Btype *struct_type_record = ctx->get_backend ()->struct_type (fields);\n+    Btype *named_struct\n+      = ctx->get_backend ()->named_type (struct_decl.get_identifier (),\n+\t\t\t\t\t struct_type_record,\n+\t\t\t\t\t struct_decl.get_locus ());\n+    ctx->push_type (named_struct);\n+    ctx->insert_compiled_type (struct_decl.get_mappings ().get_hirid (),\n+\t\t\t       named_struct);\n+  }\n+\n+  void visit (HIR::StaticItem &var)\n+  {\n+    TyTy::TyBase *resolved_type = nullptr;\n+    bool ok = ctx->get_tyctx ()->lookup_type (var.get_mappings ().get_hirid (),\n+\t\t\t\t\t      &resolved_type);\n+    rust_assert (ok);\n+\n+    Btype *type = TyTyResolveCompile::compile (ctx, resolved_type);\n+    Bexpression *value = CompileExpr::Compile (var.get_expr (), ctx);\n+\n+    std::string name = var.get_identifier ();\n+    // FIXME need name mangling\n+    std::string asm_name = \"__\" + var.get_identifier ();\n+\n+    bool is_external = false;\n+    bool is_hidden = false;\n+    bool in_unique_section = true;\n+\n+    Bvariable *static_global\n+      = ctx->get_backend ()->global_variable (name, asm_name, type, is_external,\n+\t\t\t\t\t      is_hidden, in_unique_section,\n+\t\t\t\t\t      var.get_locus ());\n+    ctx->get_backend ()->global_variable_set_init (static_global, value);\n+\n+    ctx->insert_var_decl (var.get_mappings ().get_hirid (), static_global);\n+    ctx->push_var (static_global);\n+  }\n+\n+  void visit (HIR::ConstantItem &constant)\n+  {\n+    TyTy::TyBase *resolved_type = nullptr;\n+    bool ok\n+      = ctx->get_tyctx ()->lookup_type (constant.get_mappings ().get_hirid (),\n+\t\t\t\t\t&resolved_type);\n+    rust_assert (ok);\n+\n+    ::Btype *type = TyTyResolveCompile::compile (ctx, resolved_type);\n+    Bexpression *value = CompileExpr::Compile (constant.get_expr (), ctx);\n+\n+    Bexpression *const_expr = ctx->get_backend ()->named_constant_expression (\n+      type, constant.get_identifier (), value, constant.get_locus ());\n+\n+    ctx->push_const (const_expr);\n+    ctx->insert_const_decl (constant.get_mappings ().get_hirid (), const_expr);\n+  }\n+\n   void visit (HIR::Function &function)\n   {\n     // items can be forward compiled which means we may not need to invoke this"}, {"sha": "c24005e00c9cecce855221797c0fc05ccfa80036", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=238a31b33f79cddfaa40c5fd748495a5f2b34630", "patch": "@@ -25,7 +25,7 @@ namespace Rust {\n namespace Compile {\n \n void\n-ResolvePath::visit (HIR::PathInExpression &expr)\n+ResolvePathRef::visit (HIR::PathInExpression &expr)\n {\n   // need to look up the reference for this identifier\n   NodeId ref_node_id;\n@@ -70,5 +70,33 @@ ResolvePath::visit (HIR::PathInExpression &expr)\n     = ctx->get_backend ()->function_code_expression (fn, expr.get_locus ());\n }\n \n+void\n+ResolvePathType::visit (HIR::PathInExpression &expr)\n+{\n+  // need to look up the reference for this identifier\n+  NodeId ref_node_id;\n+  if (!ctx->get_resolver ()->lookup_resolved_name (\n+\texpr.get_mappings ().get_nodeid (), &ref_node_id))\n+    {\n+      rust_fatal_error (expr.get_locus (), \"failed to look up resolved name\");\n+      return;\n+    }\n+\n+  HirId ref;\n+  if (!ctx->get_mappings ()->lookup_node_to_hir (\n+\texpr.get_mappings ().get_crate_num (), ref_node_id, &ref))\n+    {\n+      rust_fatal_error (expr.get_locus (), \"reverse lookup failure\");\n+      return;\n+    }\n+\n+  // assumes paths are functions for now\n+  if (!ctx->lookup_compiled_types (ref, &resolved))\n+    {\n+      rust_fatal_error (expr.get_locus (), \"forward decl was not compiled\");\n+      return;\n+    }\n+}\n+\n } // namespace Compile\n } // namespace Rust"}, {"sha": "a5543d2bdbb070b84bcf1f02ef82049c1daf76ce", "filename": "gcc/rust/backend/rust-compile-resolve-path.h", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h?ref=238a31b33f79cddfaa40c5fd748495a5f2b34630", "patch": "@@ -25,27 +25,44 @@\n namespace Rust {\n namespace Compile {\n \n-class ResolvePath : public HIRCompileBase\n+class ResolvePathRef : public HIRCompileBase\n {\n public:\n   static Bexpression *Compile (HIR::Expr *expr, Context *ctx)\n   {\n-    ResolvePath resolver (ctx);\n+    ResolvePathRef resolver (ctx);\n     expr->accept_vis (resolver);\n     rust_assert (resolver.resolved != nullptr);\n     return resolver.resolved;\n   }\n \n-  virtual ~ResolvePath () {}\n-\n   void visit (HIR::PathInExpression &expr);\n \n private:\n-  ResolvePath (Context *ctx) : HIRCompileBase (ctx), resolved (nullptr) {}\n+  ResolvePathRef (Context *ctx) : HIRCompileBase (ctx), resolved (nullptr) {}\n \n   Bexpression *resolved;\n };\n \n+class ResolvePathType : public HIRCompileBase\n+{\n+public:\n+  static Btype *Compile (HIR::Expr *expr, Context *ctx)\n+  {\n+    ResolvePathType resolver (ctx);\n+    expr->accept_vis (resolver);\n+    rust_assert (resolver.resolved != nullptr);\n+    return resolver.resolved;\n+  }\n+\n+  void visit (HIR::PathInExpression &expr);\n+\n+private:\n+  ResolvePathType (Context *ctx) : HIRCompileBase (ctx), resolved (nullptr) {}\n+\n+  Btype *resolved;\n+};\n+\n } // namespace Compile\n } // namespace Rust\n "}, {"sha": "a394f7a88e44d883da6171caaa6d538f09d4050a", "filename": "gcc/rust/backend/rust-compile-struct-field-expr.h", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fbackend%2Frust-compile-struct-field-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fbackend%2Frust-compile-struct-field-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-struct-field-expr.h?ref=238a31b33f79cddfaa40c5fd748495a5f2b34630", "patch": "@@ -0,0 +1,52 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_COMPILE_STRUCT_FIELD_EXPR\n+#define RUST_COMPILE_STRUCT_FIELD_EXPR\n+\n+#include \"rust-compile-base.h\"\n+#include \"rust-compile-tyty.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+class CompileStructExprField : public HIRCompileBase\n+{\n+public:\n+  static Bexpression *Compile (HIR::StructExprField *field, Context *ctx)\n+  {\n+    CompileStructExprField compiler (ctx);\n+    field->accept_vis (compiler);\n+    rust_assert (compiler.translated != nullptr);\n+    return compiler.translated;\n+  }\n+\n+  void visit (HIR::StructExprFieldIdentifierValue &field);\n+\n+private:\n+  CompileStructExprField (Context *ctx)\n+    : HIRCompileBase (ctx), translated (nullptr)\n+  {}\n+\n+  Bexpression *translated;\n+};\n+\n+} // namespace Compile\n+} // namespace Rust\n+\n+#endif // RUST_COMPILE_STRUCT_FIELD_EXPR"}, {"sha": "528f90ef0f92dcde2cc49d14f2c70bf34c9469ae", "filename": "gcc/rust/backend/rust-compile-tyty.h", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h?ref=238a31b33f79cddfaa40c5fd748495a5f2b34630", "patch": "@@ -111,6 +111,18 @@ class TyTyCompile : public TyTy::TyVisitor\n \t  = backend->named_type (\"i32\", backend->integer_type (false, 32),\n \t\t\t\t Linemap::predeclared_location ());\n \treturn;\n+\n+      case TyTy::IntType::I64:\n+\ttranslated\n+\t  = backend->named_type (\"i64\", backend->integer_type (false, 64),\n+\t\t\t\t Linemap::predeclared_location ());\n+\treturn;\n+\n+      case TyTy::IntType::I128:\n+\ttranslated\n+\t  = backend->named_type (\"i128\", backend->integer_type (false, 128),\n+\t\t\t\t Linemap::predeclared_location ());\n+\treturn;\n       }\n     gcc_unreachable ();\n   }\n@@ -135,7 +147,37 @@ class TyTyCompile : public TyTy::TyVisitor\n \t  = backend->named_type (\"i32\", backend->integer_type (true, 32),\n \t\t\t\t Linemap::predeclared_location ());\n \treturn;\n+\n+      case TyTy::UintType::U64:\n+\ttranslated\n+\t  = backend->named_type (\"u64\", backend->integer_type (true, 64),\n+\t\t\t\t Linemap::predeclared_location ());\n+\treturn;\n+\n+      case TyTy::UintType::U128:\n+\ttranslated\n+\t  = backend->named_type (\"u128\", backend->integer_type (true, 128),\n+\t\t\t\t Linemap::predeclared_location ());\n+\treturn;\n+      }\n+    gcc_unreachable ();\n+  }\n+\n+  void visit (TyTy::FloatType &type) override\n+  {\n+    switch (type.get_kind ())\n+      {\n+      case TyTy::FloatType::F32:\n+\ttranslated = backend->named_type (\"f32\", backend->float_type (32),\n+\t\t\t\t\t  Linemap::predeclared_location ());\n+\treturn;\n+\n+      case TyTy::FloatType::F64:\n+\ttranslated = backend->named_type (\"f64\", backend->float_type (64),\n+\t\t\t\t\t  Linemap::predeclared_location ());\n+\treturn;\n       }\n+\n     gcc_unreachable ();\n   }\n "}, {"sha": "24b45ee3c883e7749c23f15a656c8bfffb879cab", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=238a31b33f79cddfaa40c5fd748495a5f2b34630", "patch": "@@ -19,6 +19,7 @@\n #include \"rust-compile.h\"\n #include \"rust-compile-item.h\"\n #include \"rust-compile-expr.h\"\n+#include \"rust-compile-struct-field-expr.h\"\n \n namespace Rust {\n namespace Compile {\n@@ -152,5 +153,13 @@ CompileConditionalBlocks::visit (HIR::IfExprConseqIf &expr)\n \t\t\t\t\t else_block, expr.get_locus ());\n }\n \n+// rust-compile-struct-field-expr.h\n+\n+void\n+CompileStructExprField::visit (HIR::StructExprFieldIdentifierValue &field)\n+{\n+  translated = CompileExpr::Compile (field.get_value (), ctx);\n+}\n+\n } // namespace Compile\n } // namespace Rust"}, {"sha": "87ba0dc1144a0706e649b7b0850f1282984ce725", "filename": "gcc/rust/hir/rust-ast-lower-expr.h", "status": "modified", "additions": 84, "deletions": 18, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h?ref=238a31b33f79cddfaa40c5fd748495a5f2b34630", "patch": "@@ -22,6 +22,7 @@\n #include \"rust-diagnostics.h\"\n #include \"rust-ast-lower-base.h\"\n #include \"rust-ast-lower-block.h\"\n+#include \"rust-ast-lower-struct-field-expr.h\"\n \n namespace Rust {\n namespace HIR {\n@@ -62,6 +63,47 @@ class ArrayCapacityConstant : public ASTLoweringBase\n   size_t result;\n }; // namespace Resolver\n \n+class ASTLowerPathInExpression : public ASTLoweringBase\n+{\n+public:\n+  static HIR::PathInExpression *translate (AST::PathInExpression *expr)\n+  {\n+    ASTLowerPathInExpression compiler;\n+    expr->accept_vis (compiler);\n+    rust_assert (compiler.translated);\n+    return compiler.translated;\n+  }\n+\n+  ~ASTLowerPathInExpression () {}\n+\n+  void visit (AST::PathInExpression &expr)\n+  {\n+    std::vector<HIR::PathExprSegment> path_segments;\n+    expr.iterate_path_segments ([&] (AST::PathExprSegment &s) mutable -> bool {\n+      rust_assert (s.has_generic_args () == false); // TODO\n+\n+      HIR::PathIdentSegment is (s.get_ident_segment ().as_string ());\n+      HIR::PathExprSegment seg (is, s.get_locus ());\n+      path_segments.push_back (seg);\n+      return true;\n+    });\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated = new HIR::PathInExpression (mapping, std::move (path_segments),\n+\t\t\t\t\t    expr.get_locus (),\n+\t\t\t\t\t    expr.opening_scope_resolution ());\n+  }\n+\n+private:\n+  ASTLowerPathInExpression () : translated (nullptr) {}\n+\n+  HIR::PathInExpression *translated;\n+};\n+\n class ASTLoweringExpr : public ASTLoweringBase\n {\n public:\n@@ -107,24 +149,7 @@ class ASTLoweringExpr : public ASTLoweringBase\n \n   void visit (AST::PathInExpression &expr)\n   {\n-    std::vector<HIR::PathExprSegment> path_segments;\n-    expr.iterate_path_segments ([&] (AST::PathExprSegment &s) mutable -> bool {\n-      rust_assert (s.has_generic_args () == false); // TODO\n-\n-      HIR::PathIdentSegment is (s.get_ident_segment ().as_string ());\n-      HIR::PathExprSegment seg (is, s.get_locus ());\n-      path_segments.push_back (seg);\n-      return true;\n-    });\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n-\n-    translated = new HIR::PathInExpression (mapping, std::move (path_segments),\n-\t\t\t\t\t    expr.get_locus (),\n-\t\t\t\t\t    expr.opening_scope_resolution ());\n+    translated = ASTLowerPathInExpression::translate (&expr);\n   }\n \n   void visit (AST::ReturnExpr &expr)\n@@ -303,6 +328,7 @@ class ASTLoweringExpr : public ASTLoweringBase\n \t\t\t\t   UNKNOWN_LOCAL_DEFID);\n \n     translated = new HIR::LiteralExpr (mapping, expr.as_string (), type,\n+\t\t\t\t       expr.get_literal ().get_type_hint (),\n \t\t\t\t       expr.get_locus ());\n   }\n \n@@ -431,6 +457,46 @@ class ASTLoweringExpr : public ASTLoweringBase\n \t\t\t\t  expr.get_locus ());\n   }\n \n+  void visit (AST::StructExprStructFields &struct_expr)\n+  {\n+    std::vector<HIR::Attribute> inner_attribs;\n+    std::vector<HIR::Attribute> outer_attribs;\n+\n+    // bit of a hack for now\n+    HIR::PathInExpression *path\n+      = ASTLowerPathInExpression::translate (&struct_expr.get_struct_name ());\n+    HIR::PathInExpression copied_path (*path);\n+    delete path;\n+\n+    HIR::StructBase *base = nullptr;\n+    if (struct_expr.has_struct_base ())\n+      {\n+\tHIR::Expr *translated_base = ASTLoweringExpr::translate (\n+\t  struct_expr.get_struct_base ().get_base_struct ().get ());\n+\tbase\n+\t  = new HIR::StructBase (std::unique_ptr<HIR::Expr> (translated_base));\n+      }\n+\n+    std::vector<std::unique_ptr<HIR::StructExprField> > fields;\n+    struct_expr.iterate ([&] (AST::StructExprField *field) mutable -> bool {\n+      HIR::StructExprField *translated\n+\t= ASTLowerStructExprField::translate (field);\n+      fields.push_back (std::unique_ptr<HIR::StructExprField> (translated));\n+      return true;\n+    });\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, struct_expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated\n+      = new HIR::StructExprStructFields (mapping, copied_path,\n+\t\t\t\t\t std::move (fields),\n+\t\t\t\t\t struct_expr.get_locus (), base,\n+\t\t\t\t\t inner_attribs, outer_attribs);\n+  }\n+\n private:\n   ASTLoweringExpr () : translated (nullptr), translated_array_elems (nullptr) {}\n "}, {"sha": "2a1788030c28d7527f20be9bc693cd8e7600b75b", "filename": "gcc/rust/hir/rust-ast-lower-item.h", "status": "modified", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h?ref=238a31b33f79cddfaa40c5fd748495a5f2b34630", "patch": "@@ -24,6 +24,7 @@\n #include \"rust-ast-lower-base.h\"\n #include \"rust-ast-lower-type.h\"\n #include \"rust-ast-lower-stmt.h\"\n+#include \"rust-ast-lower-expr.h\"\n #include \"rust-ast-lower-pattern.h\"\n #include \"rust-ast-lower-block.h\"\n \n@@ -42,6 +43,108 @@ class ASTLoweringItem : public ASTLoweringBase\n \n   virtual ~ASTLoweringItem () {}\n \n+  void visit (AST::StructStruct &struct_decl)\n+  {\n+    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+    HIR::WhereClause where_clause (std::move (where_clause_items));\n+    HIR::Visibility vis = HIR::Visibility::create_public ();\n+    std::vector<HIR::Attribute> outer_attrs;\n+\n+    bool is_unit = false;\n+    std::vector<HIR::StructField> fields;\n+    struct_decl.iterate ([&] (AST::StructField &field) mutable -> bool {\n+      std::vector<HIR::Attribute> outer_attrs;\n+      HIR::Visibility vis = HIR::Visibility::create_public ();\n+      HIR::Type *type\n+\t= ASTLoweringType::translate (field.get_field_type ().get ());\n+\n+      auto crate_num = mappings->get_current_crate ();\n+      Analysis::NodeMapping mapping (crate_num, field.get_node_id (),\n+\t\t\t\t     mappings->get_next_hir_id (crate_num),\n+\t\t\t\t     mappings->get_next_localdef_id (\n+\t\t\t\t       crate_num));\n+\n+      // FIXME\n+      // AST::StructField is missing Location info\n+      Location field_locus;\n+      HIR::StructField translated_field (mapping, field.get_field_name (),\n+\t\t\t\t\t std::unique_ptr<HIR::Type> (type), vis,\n+\t\t\t\t\t field_locus, outer_attrs);\n+      fields.push_back (std::move (translated_field));\n+      return true;\n+    });\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, struct_decl.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    translated = new HIR::StructStruct (mapping, std::move (fields),\n+\t\t\t\t\tstruct_decl.get_identifier (),\n+\t\t\t\t\tstd::move (generic_params),\n+\t\t\t\t\tstd::move (where_clause), is_unit, vis,\n+\t\t\t\t\tstd::move (outer_attrs),\n+\t\t\t\t\tstruct_decl.get_locus ());\n+\n+    mappings->insert_defid_mapping (mapping.get_defid (), translated);\n+    mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t       translated);\n+    mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t       struct_decl.get_locus ());\n+  }\n+\n+  void visit (AST::StaticItem &var)\n+  {\n+    std::vector<HIR::Attribute> outer_attrs;\n+    HIR::Visibility vis = HIR::Visibility::create_public ();\n+\n+    HIR::Type *type = ASTLoweringType::translate (var.get_type ().get ());\n+    HIR::Expr *expr = ASTLoweringExpr::translate (var.get_expr ().get ());\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, var.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    translated\n+      = new HIR::StaticItem (mapping, var.get_identifier (), var.is_mutable (),\n+\t\t\t     std::unique_ptr<HIR::Type> (type),\n+\t\t\t     std::unique_ptr<HIR::Expr> (expr), vis,\n+\t\t\t     outer_attrs, var.get_locus ());\n+\n+    mappings->insert_defid_mapping (mapping.get_defid (), translated);\n+    mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t       translated);\n+    mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t       var.get_locus ());\n+  }\n+\n+  void visit (AST::ConstantItem &constant)\n+  {\n+    std::vector<HIR::Attribute> outer_attrs;\n+    HIR::Visibility vis = HIR::Visibility::create_public ();\n+\n+    HIR::Type *type = ASTLoweringType::translate (constant.get_type ().get ());\n+    HIR::Expr *expr = ASTLoweringExpr::translate (constant.get_expr ().get ());\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, constant.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    translated = new HIR::ConstantItem (mapping, constant.get_identifier (),\n+\t\t\t\t\tvis, std::unique_ptr<HIR::Type> (type),\n+\t\t\t\t\tstd::unique_ptr<HIR::Expr> (expr),\n+\t\t\t\t\touter_attrs, constant.get_locus ());\n+\n+    mappings->insert_defid_mapping (mapping.get_defid (), translated);\n+    mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t       translated);\n+    mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t       constant.get_locus ());\n+  }\n+\n   void visit (AST::Function &function)\n   {\n     // ignore for now and leave empty"}, {"sha": "1b444a5a28b5d179031c58bf5b5db3f12238723a", "filename": "gcc/rust/hir/rust-ast-lower-struct-field-expr.h", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fhir%2Frust-ast-lower-struct-field-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fhir%2Frust-ast-lower-struct-field-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-struct-field-expr.h?ref=238a31b33f79cddfaa40c5fd748495a5f2b34630", "patch": "@@ -0,0 +1,58 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_LOWER_STRUCT_FIELD_EXPR\n+#define RUST_AST_LOWER_STRUCT_FIELD_EXPR\n+\n+#include \"rust-diagnostics.h\"\n+#include \"rust-ast-lower-base.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+class ASTLowerStructExprField : public ASTLoweringBase\n+{\n+public:\n+  static HIR::StructExprField *translate (AST::StructExprField *field)\n+  {\n+    ASTLowerStructExprField compiler;\n+    field->accept_vis (compiler);\n+    rust_assert (compiler.translated != nullptr);\n+\n+    // compiler.mappings->insert_hir_expr (\n+    //   compiler.translated->get_mappings ().get_crate_num (),\n+    //   compiler.translated->get_mappings ().get_hirid (),\n+    //   compiler.translated);\n+\n+    return compiler.translated;\n+  }\n+\n+  ~ASTLowerStructExprField () {}\n+\n+  void visit (AST::StructExprFieldIdentifierValue &field);\n+\n+private:\n+  ASTLowerStructExprField () : translated (nullptr) {}\n+\n+  HIR::StructExprField *translated;\n+};\n+\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif // RUST_AST_LOWER_STRUCT_FIELD_EXPR"}, {"sha": "8dd88007d8355f1437b38a2d05a8217e8135b616", "filename": "gcc/rust/hir/rust-ast-lower.cc", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower.cc?ref=238a31b33f79cddfaa40c5fd748495a5f2b34630", "patch": "@@ -149,5 +149,22 @@ ASTLoweringIfBlock::visit (AST::IfExprConseqIf &expr)\n \t\t\t       expr.get_locus ());\n }\n \n+// rust-ast-lower-struct-field-expr.h\n+\n+void\n+ASTLowerStructExprField::visit (AST::StructExprFieldIdentifierValue &field)\n+{\n+  HIR::Expr *value = ASTLoweringExpr::translate (field.get_value ().get ());\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, field.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated = new HIR::StructExprFieldIdentifierValue (\n+    mapping, field.get_field_name (), std::unique_ptr<HIR::Expr> (value),\n+    field.get_locus ());\n+}\n+\n } // namespace HIR\n } // namespace Rust"}, {"sha": "dc7ab5a9152349a007dda8e56b9f9c4f21690514", "filename": "gcc/rust/hir/tree/rust-hir-expr.h", "status": "modified", "additions": 56, "deletions": 33, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h?ref=238a31b33f79cddfaa40c5fd748495a5f2b34630", "patch": "@@ -66,10 +66,11 @@ class LiteralExpr : public ExprWithoutBlock\n   Literal::LitType get_lit_type () const { return literal.get_lit_type (); }\n \n   LiteralExpr (Analysis::NodeMapping mappings, std::string value_as_string,\n-\t       Literal::LitType type, Location locus,\n+\t       Literal::LitType type, PrimitiveCoreType type_hint,\n+\t       Location locus,\n \t       std::vector<Attribute> outer_attrs = std::vector<Attribute> ())\n     : ExprWithoutBlock (std::move (mappings), std::move (outer_attrs)),\n-      literal (std::move (value_as_string), type), locus (locus)\n+      literal (std::move (value_as_string), type, type_hint), locus (locus)\n   {}\n \n   LiteralExpr (Analysis::NodeMapping mappings, Literal literal, Location locus,\n@@ -1315,9 +1316,9 @@ class TupleIndexExpr : public ExprWithoutBlock\n // Base struct/tuple/union value creator HIR node (abstract)\n class StructExpr : public ExprWithoutBlock\n {\n+protected:\n   PathInExpression struct_name;\n \n-protected:\n   // Protected constructor to allow initialising struct_name\n   StructExpr (Analysis::NodeMapping mappings, PathInExpression struct_path,\n \t      std::vector<Attribute> outer_attribs)\n@@ -1326,7 +1327,7 @@ class StructExpr : public ExprWithoutBlock\n   {}\n \n public:\n-  const PathInExpression &get_struct_name () const { return struct_name; }\n+  PathInExpression &get_struct_name () { return struct_name; }\n \n   std::string as_string () const override;\n };\n@@ -1417,6 +1418,8 @@ struct StructBase\n   bool is_invalid () const { return base_struct == nullptr; }\n \n   std::string as_string () const;\n+\n+  Expr *get_base () { return base_struct.get (); }\n };\n \n /* Base HIR node for a single struct expression field (in struct instance\n@@ -1436,9 +1439,20 @@ class StructExprField\n \n   virtual void accept_vis (HIRVisitor &vis) = 0;\n \n+  Analysis::NodeMapping &get_mappings () { return mappings; }\n+\n+  Location get_locus () { return locus; }\n+\n protected:\n   // pure virtual clone implementation\n   virtual StructExprField *clone_struct_expr_field_impl () const = 0;\n+\n+  StructExprField (Analysis::NodeMapping mapping, Location locus)\n+    : mappings (mapping), locus (locus)\n+  {}\n+\n+  Analysis::NodeMapping mappings;\n+  Location locus;\n };\n \n // Identifier-only variant of StructExprField HIR node\n@@ -1449,8 +1463,10 @@ class StructExprFieldIdentifier : public StructExprField\n \n   // TODO: should this store location data?\n \n-  StructExprFieldIdentifier (Identifier field_identifier)\n-    : field_name (std::move (field_identifier))\n+  StructExprFieldIdentifier (Analysis::NodeMapping mapping,\n+\t\t\t     Identifier field_identifier, Location locus)\n+    : StructExprField (mapping, locus),\n+      field_name (std::move (field_identifier))\n   {}\n \n   std::string as_string () const override { return field_name; }\n@@ -1470,23 +1486,26 @@ class StructExprFieldIdentifier : public StructExprField\n  * abstract */\n class StructExprFieldWithVal : public StructExprField\n {\n-public:\n   std::unique_ptr<Expr> value;\n \n protected:\n-  StructExprFieldWithVal (std::unique_ptr<Expr> field_value)\n-    : value (std::move (field_value))\n+  StructExprFieldWithVal (Analysis::NodeMapping mapping,\n+\t\t\t  std::unique_ptr<Expr> field_value, Location locus)\n+    : StructExprField (mapping, locus), value (std::move (field_value))\n   {}\n \n   // Copy constructor requires clone\n   StructExprFieldWithVal (StructExprFieldWithVal const &other)\n-    : value (other.value->clone_expr ())\n+    : StructExprField (other.mappings, other.locus),\n+      value (other.value->clone_expr ())\n   {}\n \n   // Overload assignment operator to clone unique_ptr\n   StructExprFieldWithVal &operator= (StructExprFieldWithVal const &other)\n   {\n     value = other.value->clone_expr ();\n+    mappings = other.mappings;\n+    locus = other.locus;\n \n     return *this;\n   }\n@@ -1497,6 +1516,8 @@ class StructExprFieldWithVal : public StructExprField\n \n public:\n   std::string as_string () const override;\n+\n+  Expr *get_value () { return value.get (); }\n };\n \n // Identifier and value variant of StructExprField HIR node\n@@ -1507,9 +1528,11 @@ class StructExprFieldIdentifierValue : public StructExprFieldWithVal\n \n   // TODO: should this store location data?\n \n-  StructExprFieldIdentifierValue (Identifier field_identifier,\n-\t\t\t\t  std::unique_ptr<Expr> field_value)\n-    : StructExprFieldWithVal (std::move (field_value)),\n+  StructExprFieldIdentifierValue (Analysis::NodeMapping mapping,\n+\t\t\t\t  Identifier field_identifier,\n+\t\t\t\t  std::unique_ptr<Expr> field_value,\n+\t\t\t\t  Location locus)\n+    : StructExprFieldWithVal (mapping, std::move (field_value), locus),\n       field_name (std::move (field_identifier))\n   {}\n \n@@ -1534,9 +1557,11 @@ class StructExprFieldIndexValue : public StructExprFieldWithVal\n \n   // TODO: should this store location data?\n \n-  StructExprFieldIndexValue (TupleIndex tuple_index,\n-\t\t\t     std::unique_ptr<Expr> field_value)\n-    : StructExprFieldWithVal (std::move (field_value)), index (tuple_index)\n+  StructExprFieldIndexValue (Analysis::NodeMapping mapping,\n+\t\t\t     TupleIndex tuple_index,\n+\t\t\t     std::unique_ptr<Expr> field_value, Location locus)\n+    : StructExprFieldWithVal (mapping, std::move (field_value), locus),\n+      index (tuple_index)\n   {}\n \n   std::string as_string () const override;\n@@ -1560,31 +1585,24 @@ class StructExprStructFields : public StructExprStruct\n   std::vector<std::unique_ptr<StructExprField> > fields;\n \n   // bool has_struct_base;\n-  StructBase struct_base;\n+  // FIXME make unique_ptr\n+  StructBase *struct_base;\n \n   std::string as_string () const override;\n \n-  bool has_struct_base () const { return !struct_base.is_invalid (); }\n-\n-  /*inline std::vector<std::unique_ptr<StructExprField>> get_fields()\n-  const { return fields;\n-  }*/\n-\n-  /*inline StructBase get_struct_base() const {\n-      return has_struct_base ? struct_base : StructBase::error();\n-  }*/\n+  bool has_struct_base () const { return struct_base != nullptr; }\n \n   // Constructor for StructExprStructFields when no struct base is used\n   StructExprStructFields (\n     Analysis::NodeMapping mappings, PathInExpression struct_path,\n     std::vector<std::unique_ptr<StructExprField> > expr_fields, Location locus,\n-    StructBase base_struct = StructBase::error (),\n+    StructBase *base_struct,\n     std::vector<Attribute> inner_attribs = std::vector<Attribute> (),\n     std::vector<Attribute> outer_attribs = std::vector<Attribute> ())\n     : StructExprStruct (std::move (mappings), std::move (struct_path),\n \t\t\tstd::move (inner_attribs), std::move (outer_attribs),\n \t\t\tlocus),\n-      fields (std::move (expr_fields)), struct_base (std::move (base_struct))\n+      fields (std::move (expr_fields)), struct_base (base_struct)\n   {}\n \n   // copy constructor with vector clone\n@@ -1615,6 +1633,15 @@ class StructExprStructFields : public StructExprStruct\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  void iterate (std::function<bool (StructExprField *)> cb)\n+  {\n+    for (auto &field : fields)\n+      {\n+\tif (!cb (field.get ()))\n+\t  return;\n+      }\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1752,11 +1779,7 @@ class StructExprUnit : public StructExpr\n   Location locus;\n \n public:\n-  std::string as_string () const override\n-  {\n-    return get_struct_name ().as_string ();\n-    // return struct_name.as_string();\n-  }\n+  std::string as_string () const override { return struct_name.as_string (); }\n \n   StructExprUnit (Analysis::NodeMapping mappings, PathInExpression struct_path,\n \t\t  std::vector<Attribute> outer_attribs, Location locus)"}, {"sha": "b935376139230b26b01a351fbc8ca7248b6ce2e8", "filename": "gcc/rust/hir/tree/rust-hir-full-test.cc", "status": "modified", "additions": 6, "deletions": 35, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc?ref=238a31b33f79cddfaa40c5fd748495a5f2b34630", "patch": "@@ -3683,7 +3683,7 @@ StructExprStruct::as_string () const\n {\n   std::string str (\"StructExprStruct (or subclass): \");\n \n-  str += \"\\n Path: \" + get_struct_name ().as_string ();\n+  str += \"\\n Path: \" + struct_name.as_string ();\n \n   // inner attributes\n   str += \"\\n inner attributes: \";\n@@ -3761,7 +3761,7 @@ StructExprStructFields::as_string () const\n     }\n   else\n     {\n-      str += struct_base.as_string ();\n+      str += struct_base->as_string ();\n     }\n \n   return str;\n@@ -4904,38 +4904,8 @@ DelimTokenTree::to_token_stream () const\n Literal\n MacroParser::parse_literal ()\n {\n-  const std::unique_ptr<Token> &tok = peek_token ();\n-  switch (tok->get_id ())\n-    {\n-    case CHAR_LITERAL:\n-      skip_token ();\n-      return Literal (tok->as_string (), Literal::CHAR);\n-    case STRING_LITERAL:\n-      skip_token ();\n-      return Literal (tok->as_string (), Literal::STRING);\n-    case BYTE_CHAR_LITERAL:\n-      skip_token ();\n-      return Literal (tok->as_string (), Literal::BYTE);\n-    case BYTE_STRING_LITERAL:\n-      skip_token ();\n-      return Literal (tok->as_string (), Literal::BYTE_STRING);\n-    case INT_LITERAL:\n-      skip_token ();\n-      return Literal (tok->as_string (), Literal::INT);\n-    case FLOAT_LITERAL:\n-      skip_token ();\n-      return Literal (tok->as_string (), Literal::FLOAT);\n-    case TRUE_LITERAL:\n-      skip_token ();\n-      return Literal (\"true\", Literal::BOOL);\n-    case FALSE_LITERAL:\n-      skip_token ();\n-      return Literal (\"false\", Literal::BOOL);\n-    default:\n-      rust_error_at (tok->get_locus (), \"expected literal - found '%s'\",\n-\t\t     get_token_description (tok->get_id ()));\n-      return Literal::create_error ();\n-    }\n+  // marcos need to be removed from HIR\n+  gcc_unreachable ();\n }\n \n SimplePath\n@@ -5037,7 +5007,8 @@ Attribute\n MetaNameValueStr::to_attribute () const\n {\n   LiteralExpr lit_expr (Analysis::NodeMapping::get_error (), str,\n-\t\t\tLiteral::LitType::STRING, Location ());\n+\t\t\tLiteral::LitType::STRING,\n+\t\t\tPrimitiveCoreType::CORETYPE_STR, Location ());\n   return Attribute (SimplePath::from_str (ident),\n \t\t    std::unique_ptr<AttrInputLiteral> (\n \t\t      new AttrInputLiteral (std::move (lit_expr))));"}, {"sha": "69e39c8731dadde7a125166a46916434e1897f25", "filename": "gcc/rust/hir/tree/rust-hir-item.h", "status": "modified", "additions": 46, "deletions": 15, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h?ref=238a31b33f79cddfaa40c5fd748495a5f2b34630", "patch": "@@ -1390,7 +1390,7 @@ class TypeAlias : public VisItem, public TraitImplItem\n // Rust base struct declaration HIR node - abstract base class\n class Struct : public VisItem\n {\n-public:\n+protected:\n   // protected to enable access by derived classes - allows better as_string\n   Identifier struct_name;\n \n@@ -1403,6 +1403,9 @@ class Struct : public VisItem\n \n   Location locus;\n \n+public:\n+  Identifier get_identifier () const { return struct_name; }\n+\n   // Returns whether struct has generic parameters.\n   bool has_generics () const { return !generic_params.empty (); }\n \n@@ -1465,6 +1468,10 @@ struct StructField\n   Identifier field_name;\n   std::unique_ptr<Type> field_type;\n \n+  Analysis::NodeMapping mappings;\n+\n+  Location locus;\n+\n   // should this store location info?\n \n   // Returns whether struct field has any outer attributes.\n@@ -1473,18 +1480,19 @@ struct StructField\n   // Returns whether struct field has a non-private (non-default) visibility.\n   bool has_visibility () const { return !visibility.is_error (); }\n \n-  StructField (Identifier field_name, std::unique_ptr<Type> field_type,\n-\t       Visibility vis,\n+  StructField (Analysis::NodeMapping mappings, Identifier field_name,\n+\t       std::unique_ptr<Type> field_type, Visibility vis, Location locus,\n \t       std::vector<Attribute> outer_attrs = std::vector<Attribute> ())\n     : outer_attrs (std::move (outer_attrs)), visibility (std::move (vis)),\n-      field_name (std::move (field_name)), field_type (std::move (field_type))\n+      field_name (std::move (field_name)), field_type (std::move (field_type)),\n+      mappings (mappings), locus (locus)\n   {}\n \n   // Copy constructor\n   StructField (StructField const &other)\n     : outer_attrs (other.outer_attrs), visibility (other.visibility),\n       field_name (other.field_name),\n-      field_type (other.field_type->clone_type ())\n+      field_type (other.field_type->clone_type ()), mappings (other.mappings)\n   {}\n \n   ~StructField () = default;\n@@ -1496,6 +1504,7 @@ struct StructField\n     field_type = other.field_type->clone_type ();\n     visibility = other.visibility;\n     outer_attrs = other.outer_attrs;\n+    mappings = other.mappings;\n \n     return *this;\n   }\n@@ -1504,20 +1513,19 @@ struct StructField\n   StructField (StructField &&other) = default;\n   StructField &operator= (StructField &&other) = default;\n \n-  // Returns whether struct field is in an error state.\n-  bool is_error () const\n-  {\n-    return field_name.empty () && field_type == nullptr;\n-    // this should really be an or since neither are allowed\n-  }\n+  std::string as_string () const;\n \n-  // Creates an error state struct field.\n-  static StructField create_error ()\n+  Identifier get_field_name () const { return field_name; }\n+\n+  std::unique_ptr<Type> &get_field_type ()\n   {\n-    return StructField (std::string (\"\"), nullptr, Visibility::create_error ());\n+    rust_assert (field_type != nullptr);\n+    return field_type;\n   }\n \n-  std::string as_string () const;\n+  Analysis::NodeMapping get_mappings () const { return mappings; }\n+\n+  Location get_locus () { return locus; }\n };\n \n // Rust struct declaration with true struct type HIR node\n@@ -1560,6 +1568,15 @@ class StructStruct : public Struct\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  void iterate (std::function<bool (StructField &)> cb)\n+  {\n+    for (auto &field : fields)\n+      {\n+\tif (!cb (field))\n+\t  return;\n+      }\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -2055,6 +2072,12 @@ class ConstantItem : public VisItem,\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  Type *get_type () { return type.get (); }\n+\n+  Expr *get_expr () { return const_expr.get (); }\n+\n+  std::string get_identifier () { return identifier; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -2134,6 +2157,14 @@ class StaticItem : public VisItem\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  Identifier get_identifier () const { return name; }\n+\n+  bool is_mutable () const { return has_mut; }\n+\n+  Expr *get_expr () { return expr.get (); }\n+\n+  Type *get_type () { return type.get (); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */"}, {"sha": "d18d8db380660eea81ef18d267fe9607fe16fb8b", "filename": "gcc/rust/hir/tree/rust-hir-pattern.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-pattern.h?ref=238a31b33f79cddfaa40c5fd748495a5f2b34630", "patch": "@@ -47,8 +47,8 @@ class LiteralPattern : public Pattern\n \n   LiteralPattern (std::string val, Literal::LitType type, Location locus,\n \t\t  bool has_minus = false)\n-    : lit (Literal (std::move (val), type)), has_minus (has_minus),\n-      locus (locus)\n+    : lit (Literal (std::move (val), type, PrimitiveCoreType::CORETYPE_STR)),\n+      has_minus (has_minus), locus (locus)\n   {}\n \n   Location get_locus () const { return locus; }"}, {"sha": "7417a32d684c951c34c56c3cb1f2d9477010c4e2", "filename": "gcc/rust/hir/tree/rust-hir.h", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h?ref=238a31b33f79cddfaa40c5fd748495a5f2b34630", "patch": "@@ -235,21 +235,27 @@ struct Literal\n   };\n \n private:\n-  /* TODO: maybe make subclasses of each type of literal with their typed values\n-   * (or generics) */\n   std::string value_as_string;\n   LitType type;\n+  PrimitiveCoreType type_hint;\n \n public:\n   std::string as_string () const { return value_as_string; }\n \n   LitType get_lit_type () const { return type; }\n \n-  Literal (std::string value_as_string, LitType type)\n-    : value_as_string (std::move (value_as_string)), type (type)\n+  PrimitiveCoreType get_type_hint () const { return type_hint; }\n+\n+  Literal (std::string value_as_string, LitType type,\n+\t   PrimitiveCoreType type_hint)\n+    : value_as_string (std::move (value_as_string)), type (type),\n+      type_hint (type_hint)\n   {}\n \n-  static Literal create_error () { return Literal (\"\", CHAR); }\n+  static Literal create_error ()\n+  {\n+    return Literal (\"\", CHAR, PrimitiveCoreType::CORETYPE_UNKNOWN);\n+  }\n \n   // Returns whether literal is in an invalid state.\n   bool is_error () const { return value_as_string == \"\"; }"}, {"sha": "87e02ddc740856af9cbe47efab85962caa6ec797", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=238a31b33f79cddfaa40c5fd748495a5f2b34630", "patch": "@@ -791,7 +791,8 @@ Parser<ManagedTokenSource>::parse_attr_input ()\n \t  }\n \n \t// create actual LiteralExpr\n-\tAST::LiteralExpr lit_expr (t->get_str (), lit_type, t->get_locus ());\n+\tAST::LiteralExpr lit_expr (t->get_str (), lit_type, t->get_type_hint (),\n+\t\t\t\t   t->get_locus ());\n \n \tstd::unique_ptr<AST::AttrInputLiteral> attr_input_lit (\n \t  new AST::AttrInputLiteral (std::move (lit_expr)));\n@@ -7376,7 +7377,8 @@ Parser<ManagedTokenSource>::parse_literal_expr (\n   // create literal based on stuff in switch\n   return std::unique_ptr<AST::LiteralExpr> (\n     new AST::LiteralExpr (std::move (literal_value), std::move (type),\n-\t\t\t  t->get_locus (), std::move (outer_attrs)));\n+\t\t\t  t->get_type_hint (), t->get_locus (),\n+\t\t\t  std::move (outer_attrs)));\n }\n \n // Parses a return expression (including any expression to return).\n@@ -9952,7 +9954,8 @@ Parser<ManagedTokenSource>::parse_literal_or_range_pattern ()\n       lexer.skip_token ();\n       std::unique_ptr<AST::RangePatternBound> lower (\n \tnew AST::RangePatternBoundLiteral (\n-\t  AST::Literal (range_lower->get_str (), type),\n+\t  AST::Literal (range_lower->get_str (), type,\n+\t\t\tPrimitiveCoreType::CORETYPE_UNKNOWN),\n \t  range_lower->get_locus (), has_minus));\n \n       std::unique_ptr<AST::RangePatternBound> upper\n@@ -9993,26 +9996,30 @@ Parser<ManagedTokenSource>::parse_range_pattern_bound ()\n       lexer.skip_token ();\n       return std::unique_ptr<AST::RangePatternBoundLiteral> (\n \tnew AST::RangePatternBoundLiteral (\n-\t  AST::Literal (range_lower->get_str (), AST::Literal::CHAR),\n+\t  AST::Literal (range_lower->get_str (), AST::Literal::CHAR,\n+\t\t\trange_lower->get_type_hint ()),\n \t  range_lower_locus));\n     case BYTE_CHAR_LITERAL:\n       lexer.skip_token ();\n       return std::unique_ptr<AST::RangePatternBoundLiteral> (\n \tnew AST::RangePatternBoundLiteral (\n-\t  AST::Literal (range_lower->get_str (), AST::Literal::BYTE),\n+\t  AST::Literal (range_lower->get_str (), AST::Literal::BYTE,\n+\t\t\trange_lower->get_type_hint ()),\n \t  range_lower_locus));\n     case INT_LITERAL:\n       lexer.skip_token ();\n       return std::unique_ptr<AST::RangePatternBoundLiteral> (\n \tnew AST::RangePatternBoundLiteral (\n-\t  AST::Literal (range_lower->get_str (), AST::Literal::INT),\n+\t  AST::Literal (range_lower->get_str (), AST::Literal::INT,\n+\t\t\trange_lower->get_type_hint ()),\n \t  range_lower_locus));\n     case FLOAT_LITERAL:\n       lexer.skip_token ();\n       fprintf (stderr, \"warning: used deprecated float range pattern bound\");\n       return std::unique_ptr<AST::RangePatternBoundLiteral> (\n \tnew AST::RangePatternBoundLiteral (\n-\t  AST::Literal (range_lower->get_str (), AST::Literal::FLOAT),\n+\t  AST::Literal (range_lower->get_str (), AST::Literal::FLOAT,\n+\t\t\trange_lower->get_type_hint ()),\n \t  range_lower_locus));\n     case MINUS:\n       // branch on next token\n@@ -10023,15 +10030,17 @@ Parser<ManagedTokenSource>::parse_range_pattern_bound ()\n \t  lexer.skip_token (1);\n \t  return std::unique_ptr<AST::RangePatternBoundLiteral> (\n \t    new AST::RangePatternBoundLiteral (\n-\t      AST::Literal (range_lower->get_str (), AST::Literal::INT),\n+\t      AST::Literal (range_lower->get_str (), AST::Literal::INT,\n+\t\t\t    range_lower->get_type_hint ()),\n \t      range_lower_locus, true));\n \tcase FLOAT_LITERAL:\n \t  lexer.skip_token (1);\n \t  fprintf (stderr,\n \t\t   \"warning: used deprecated float range pattern bound\");\n \t  return std::unique_ptr<AST::RangePatternBoundLiteral> (\n \t    new AST::RangePatternBoundLiteral (\n-\t      AST::Literal (range_lower->get_str (), AST::Literal::FLOAT),\n+\t      AST::Literal (range_lower->get_str (), AST::Literal::FLOAT,\n+\t\t\t    range_lower->get_type_hint ()),\n \t      range_lower_locus, true));\n \tdefault:\n \t  rust_error_at (range_lower->get_locus (),\n@@ -12105,22 +12114,24 @@ Parser<ManagedTokenSource>::null_denotation (\n       // encode as int?\n       return std::unique_ptr<AST::LiteralExpr> (\n \tnew AST::LiteralExpr (tok->get_str (), AST::Literal::INT,\n-\t\t\t      tok->get_locus ()));\n+\t\t\t      tok->get_type_hint (), tok->get_locus ()));\n     case FLOAT_LITERAL:\n       // encode as float?\n       return std::unique_ptr<AST::LiteralExpr> (\n \tnew AST::LiteralExpr (tok->get_str (), AST::Literal::FLOAT,\n-\t\t\t      tok->get_locus ()));\n+\t\t\t      tok->get_type_hint (), tok->get_locus ()));\n     case STRING_LITERAL:\n       return std::unique_ptr<AST::LiteralExpr> (\n \tnew AST::LiteralExpr (tok->get_str (), AST::Literal::STRING,\n-\t\t\t      tok->get_locus ()));\n+\t\t\t      tok->get_type_hint (), tok->get_locus ()));\n     case TRUE_LITERAL:\n       return std::unique_ptr<AST::LiteralExpr> (\n-\tnew AST::LiteralExpr (\"true\", AST::Literal::BOOL, tok->get_locus ()));\n+\tnew AST::LiteralExpr (\"true\", AST::Literal::BOOL, tok->get_type_hint (),\n+\t\t\t      tok->get_locus ()));\n     case FALSE_LITERAL:\n       return std::unique_ptr<AST::LiteralExpr> (\n-\tnew AST::LiteralExpr (\"false\", AST::Literal::BOOL, tok->get_locus ()));\n+\tnew AST::LiteralExpr (\"false\", AST::Literal::BOOL,\n+\t\t\t      tok->get_type_hint (), tok->get_locus ()));\n       case LEFT_PAREN: { // have to parse whole expression if inside brackets\n \t/* recursively invoke parse_expression with lowest priority possible as\n \t * it it were a top-level expression. */"}, {"sha": "2292d16574a0b5fca97a4787117a790936a3dae2", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.h", "status": "modified", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h?ref=238a31b33f79cddfaa40c5fd748495a5f2b34630", "patch": "@@ -21,6 +21,7 @@\n \n #include \"rust-ast-resolve-base.h\"\n #include \"rust-ast-full.h\"\n+#include \"rust-ast-resolve-struct-expr-field.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -38,19 +39,22 @@ class ResolveExpr : public ResolverBase\n \n   void visit (AST::PathInExpression &expr)\n   {\n+    // name scope first\n     if (!resolver->get_name_scope ().lookup (expr.as_string (), &resolved_node))\n       {\n-\trust_error_at (expr.get_locus (), \"unknown path %s\",\n-\t\t       expr.as_string ().c_str ());\n-\treturn;\n-      }\n-    else\n-      {\n-\tresolver->insert_resolved_name (expr.get_node_id (), resolved_node);\n-\tresolver->insert_new_definition (expr.get_node_id (),\n-\t\t\t\t\t Definition{expr.get_node_id (),\n-\t\t\t\t\t\t    parent});\n+\t// check the type scope\n+\tif (!resolver->get_type_scope ().lookup (expr.as_string (),\n+\t\t\t\t\t\t &resolved_node))\n+\t  {\n+\t    rust_error_at (expr.get_locus (), \"unknown path %s\",\n+\t\t\t   expr.as_string ().c_str ());\n+\t    return;\n+\t  }\n       }\n+\n+    resolver->insert_resolved_name (expr.get_node_id (), resolved_node);\n+    resolver->insert_new_definition (expr.get_node_id (),\n+\t\t\t\t     Definition{expr.get_node_id (), parent});\n   }\n \n   void visit (AST::ReturnExpr &expr)\n@@ -154,6 +158,17 @@ class ResolveExpr : public ResolverBase\n     ResolveExpr::go (elems.get_elem_to_copy ().get (), elems.get_node_id ());\n   }\n \n+  void visit (AST::StructExprStructFields &struct_expr)\n+  {\n+    ResolveExpr::go (&struct_expr.get_struct_name (),\n+\t\t     struct_expr.get_node_id ());\n+    struct_expr.iterate (\n+      [&] (AST::StructExprField *struct_field) mutable -> bool {\n+\tResolveStructExprField::go (struct_field, struct_expr.get_node_id ());\n+\treturn true;\n+      });\n+  }\n+\n private:\n   ResolveExpr (NodeId parent) : ResolverBase (parent) {}\n };"}, {"sha": "c3b23120ee960279d65944b04d3037618aa42baa", "filename": "gcc/rust/resolve/rust-ast-resolve-item.h", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h?ref=238a31b33f79cddfaa40c5fd748495a5f2b34630", "patch": "@@ -39,6 +39,26 @@ class ResolveItem : public ResolverBase\n \n   ~ResolveItem () {}\n \n+  void visit (AST::StructStruct &struct_decl)\n+  {\n+    struct_decl.iterate ([&] (AST::StructField &field) mutable -> bool {\n+      ResolveType::go (field.get_field_type ().get (), field.get_node_id ());\n+      return true;\n+    });\n+  }\n+\n+  void visit (AST::StaticItem &var)\n+  {\n+    ResolveType::go (var.get_type ().get (), var.get_node_id ());\n+    ResolveExpr::go (var.get_expr ().get (), var.get_node_id ());\n+  }\n+\n+  void visit (AST::ConstantItem &constant)\n+  {\n+    ResolveType::go (constant.get_type ().get (), constant.get_node_id ());\n+    ResolveExpr::go (constant.get_expr ().get (), constant.get_node_id ());\n+  }\n+\n   void visit (AST::Function &function)\n   {\n     if (function.has_return_type ())"}, {"sha": "c705a0357b1891f617894cf1ae8ed27f2b285cbc", "filename": "gcc/rust/resolve/rust-ast-resolve-struct-expr-field.h", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fresolve%2Frust-ast-resolve-struct-expr-field.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fresolve%2Frust-ast-resolve-struct-expr-field.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-struct-expr-field.h?ref=238a31b33f79cddfaa40c5fd748495a5f2b34630", "patch": "@@ -0,0 +1,53 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_RESOLVE_STRUCT_EXPR_FIELD\n+#define RUST_AST_RESOLVE_STRUCT_EXPR_FIELD\n+\n+#include \"rust-ast-resolve-base.h\"\n+#include \"rust-ast-full.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+// this resolves values being assigned not that the field actually exists yet.\n+// We cant resolve the field to struct until type resolution since the HIR\n+// Mappings don't exist yet.\n+class ResolveStructExprField : public ResolverBase\n+{\n+public:\n+  static void go (AST::StructExprField *field, NodeId parent)\n+  {\n+    ResolveStructExprField resolver (parent);\n+    field->accept_vis (resolver);\n+  }\n+\n+  virtual ~ResolveStructExprField () {}\n+\n+  void visit (AST::StructExprFieldIdentifierValue &field);\n+\n+  // TODO\n+\n+private:\n+  ResolveStructExprField (NodeId parent) : ResolverBase (parent) {}\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_AST_RESOLVE_STRUCT_EXPR_FIELD"}, {"sha": "6a4395fde8b059db63d49caeead409dc64fee568", "filename": "gcc/rust/resolve/rust-ast-resolve-toplevel.h", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h?ref=238a31b33f79cddfaa40c5fd748495a5f2b34630", "patch": "@@ -36,6 +36,30 @@ class ResolveTopLevel : public ResolverBase\n \n   ~ResolveTopLevel () {}\n \n+  void visit (AST::StructStruct &struct_decl)\n+  {\n+    resolver->get_type_scope ().insert (struct_decl.get_identifier (),\n+\t\t\t\t\tstruct_decl.get_node_id ());\n+  }\n+\n+  void visit (AST::StaticItem &var)\n+  {\n+    resolver->get_name_scope ().insert (var.get_identifier (),\n+\t\t\t\t\tvar.get_node_id ());\n+    resolver->insert_new_definition (var.get_node_id (),\n+\t\t\t\t     Definition{var.get_node_id (),\n+\t\t\t\t\t\tvar.get_node_id ()});\n+  }\n+\n+  void visit (AST::ConstantItem &constant)\n+  {\n+    resolver->get_name_scope ().insert (constant.get_identifier (),\n+\t\t\t\t\tconstant.get_node_id ());\n+    resolver->insert_new_definition (constant.get_node_id (),\n+\t\t\t\t     Definition{constant.get_node_id (),\n+\t\t\t\t\t\tconstant.get_node_id ()});\n+  }\n+\n   void visit (AST::Function &function)\n   {\n     // function_names are simple std::String identifiers so this can be a"}, {"sha": "fe8d7e0a99aa317fea07c0748c96daedb555bf08", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=238a31b33f79cddfaa40c5fd748495a5f2b34630", "patch": "@@ -126,20 +126,38 @@ Resolver::generate_builtins ()\n     = new TyTy::UintType (mappings->get_next_hir_id (), TyTy::UintType::U16);\n   auto u32\n     = new TyTy::UintType (mappings->get_next_hir_id (), TyTy::UintType::U32);\n+  auto u64\n+    = new TyTy::UintType (mappings->get_next_hir_id (), TyTy::UintType::U64);\n+  auto u128\n+    = new TyTy::UintType (mappings->get_next_hir_id (), TyTy::UintType::U128);\n   auto i8 = new TyTy::IntType (mappings->get_next_hir_id (), TyTy::IntType::I8);\n   auto i16\n     = new TyTy::IntType (mappings->get_next_hir_id (), TyTy::IntType::I16);\n   auto i32\n     = new TyTy::IntType (mappings->get_next_hir_id (), TyTy::IntType::I32);\n+  auto i64\n+    = new TyTy::IntType (mappings->get_next_hir_id (), TyTy::IntType::I64);\n+  auto i128\n+    = new TyTy::IntType (mappings->get_next_hir_id (), TyTy::IntType::I128);\n   auto rbool = new TyTy::BoolType (mappings->get_next_hir_id ());\n+  auto f32\n+    = new TyTy::FloatType (mappings->get_next_hir_id (), TyTy::FloatType::F32);\n+  auto f64\n+    = new TyTy::FloatType (mappings->get_next_hir_id (), TyTy::FloatType::F64);\n \n   MKBUILTIN_TYPE (\"u8\", builtins, u8);\n   MKBUILTIN_TYPE (\"u16\", builtins, u16);\n   MKBUILTIN_TYPE (\"u32\", builtins, u32);\n+  MKBUILTIN_TYPE (\"u64\", builtins, u64);\n+  MKBUILTIN_TYPE (\"u128\", builtins, u128);\n   MKBUILTIN_TYPE (\"i8\", builtins, i8);\n   MKBUILTIN_TYPE (\"i16\", builtins, i16);\n   MKBUILTIN_TYPE (\"i32\", builtins, i32);\n+  MKBUILTIN_TYPE (\"i64\", builtins, i64);\n+  MKBUILTIN_TYPE (\"i128\", builtins, i128);\n   MKBUILTIN_TYPE (\"bool\", builtins, rbool);\n+  MKBUILTIN_TYPE (\"f32\", builtins, f32);\n+  MKBUILTIN_TYPE (\"f64\", builtins, f64);\n }\n \n void\n@@ -271,5 +289,13 @@ ResolveExpr::visit (AST::BlockExpr &expr)\n   resolver->get_type_scope ().pop ();\n }\n \n+// rust-ast-resolve-struct-expr-field.h\n+\n+void\n+ResolveStructExprField::visit (AST::StructExprFieldIdentifierValue &field)\n+{\n+  ResolveExpr::go (field.get_value ().get (), field.get_node_id ());\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "bfa760946d3bd67a365041df82c2cb28d4772a56", "filename": "gcc/rust/rust-gcc.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Frust-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Frust-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.cc?ref=238a31b33f79cddfaa40c5fd748495a5f2b34630", "patch": "@@ -2527,7 +2527,7 @@ Gcc_backend::global_variable_set_init (Bvariable *var, Bexpression *expr)\n     return;\n   DECL_INITIAL (var_decl) = expr_tree;\n \n-  // If this variable rustes in a unique section, it may need to rust into\n+  // If this variable goes in a unique section, it may need to go into\n   // a different one now that DECL_INITIAL is set.\n   if (symtab_node::get (var_decl)\n       && symtab_node::get (var_decl)->implicit_section)"}, {"sha": "c1df913fbfe14f2754fd39295d137ded4136b7b1", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=238a31b33f79cddfaa40c5fd748495a5f2b34630", "patch": "@@ -359,9 +359,10 @@ Session::enable_dump (std::string arg)\n    * created */\n   if (arg == \"all\")\n     {\n-      rust_error_at (Location (),\n-\t\t     \"dumping all is not supported as of now. choose %<lex%>, %<parse%>, \"\n-         \"or %<target_options%>\");\n+      rust_error_at (\n+\tLocation (),\n+\t\"dumping all is not supported as of now. choose %<lex%>, %<parse%>, \"\n+\t\"or %<target_options%>\");\n       return false;\n     }\n   else if (arg == \"lex\")\n@@ -409,10 +410,11 @@ Session::enable_dump (std::string arg)\n     }\n   else\n     {\n-      rust_error_at (Location (),\n-\t\t     \"dump option %qs was unrecognised. choose %<lex%>, %<parse%>, or \"\n-         \"%<target_options%>\",\n-\t\t     arg.c_str ());\n+      rust_error_at (\n+\tLocation (),\n+\t\"dump option %qs was unrecognised. choose %<lex%>, %<parse%>, or \"\n+\t\"%<target_options%>\",\n+\targ.c_str ());\n       return false;\n     }\n   return true;"}, {"sha": "a5440c096259fd1fbe2a8ec67c1cf5ea02c2e8df", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 55, "deletions": 7, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=238a31b33f79cddfaa40c5fd748495a5f2b34630", "patch": "@@ -24,6 +24,7 @@\n #include \"rust-tyty.h\"\n #include \"rust-tyty-call.h\"\n #include \"rust-tyty-resolver.h\"\n+#include \"rust-hir-type-check-struct-field.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -136,9 +137,8 @@ class TypeCheckExpr : public TypeCheckBase\n     TyTy::TyBase *lookup;\n     if (!context->lookup_type (ref, &lookup))\n       {\n-\t// FIXME we need to be able to lookup the location info for the\n-\t// reference here\n-\trust_error_at (expr.get_locus (), \"consider giving this a type: %s\",\n+\trust_error_at (mappings->lookup_location (ref),\n+\t\t       \"consider giving this a type: %s\",\n \t\t       expr.as_string ().c_str ());\n \treturn;\n       }\n@@ -152,10 +152,53 @@ class TypeCheckExpr : public TypeCheckBase\n     switch (expr.get_lit_type ())\n       {\n \tcase HIR::Literal::LitType::INT: {\n-\t  // FIXME:\n-\t  // assume i32 let the combiner functions figure it out\n-\t  // this should look at the suffix of the literal value to check\n-\t  auto ok = context->lookup_builtin (\"i32\", &infered);\n+\t  bool ok = false;\n+\n+\t  switch (expr.get_literal ()->get_type_hint ())\n+\t    {\n+\t    case CORETYPE_I8:\n+\t      ok = context->lookup_builtin (\"i8\", &infered);\n+\t      break;\n+\t    case CORETYPE_I16:\n+\t      ok = context->lookup_builtin (\"i16\", &infered);\n+\t      break;\n+\t    case CORETYPE_I32:\n+\t      ok = context->lookup_builtin (\"i32\", &infered);\n+\t      break;\n+\t    case CORETYPE_I64:\n+\t      ok = context->lookup_builtin (\"i64\", &infered);\n+\t      break;\n+\t    case CORETYPE_I128:\n+\t      ok = context->lookup_builtin (\"i128\", &infered);\n+\t      break;\n+\n+\t    case CORETYPE_U8:\n+\t      ok = context->lookup_builtin (\"u8\", &infered);\n+\t      break;\n+\t    case CORETYPE_U16:\n+\t      ok = context->lookup_builtin (\"u16\", &infered);\n+\t      break;\n+\t    case CORETYPE_U32:\n+\t      ok = context->lookup_builtin (\"u32\", &infered);\n+\t      break;\n+\t    case CORETYPE_U64:\n+\t      ok = context->lookup_builtin (\"u64\", &infered);\n+\t      break;\n+\t    case CORETYPE_U128:\n+\t      ok = context->lookup_builtin (\"u128\", &infered);\n+\t      break;\n+\n+\t    default:\n+\t      ok = context->lookup_builtin (\"i32\", &infered);\n+\t      break;\n+\t    }\n+\t  rust_assert (ok);\n+\t}\n+\tbreak;\n+\n+\tcase HIR::Literal::LitType::FLOAT: {\n+\t  // FIXME need to respect the suffix if applicable\n+\t  auto ok = context->lookup_builtin (\"f32\", &infered);\n \t  rust_assert (ok);\n \t}\n \tbreak;\n@@ -269,6 +312,11 @@ class TypeCheckExpr : public TypeCheckBase\n     infered_array_elems = TypeCheckExpr::Resolve (elems.get_elem_to_copy ());\n   }\n \n+  void visit (HIR::StructExprStructFields &struct_expr)\n+  {\n+    infered = TypeCheckStructExpr::Resolve (&struct_expr);\n+  }\n+\n private:\n   TypeCheckExpr ()\n     : TypeCheckBase (), infered (nullptr), infered_array_elems (nullptr)"}, {"sha": "727569db5cacd7d55d68486596b30d35b46f1b4b", "filename": "gcc/rust/typecheck/rust-hir-type-check-struct-field.h", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct-field.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct-field.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct-field.h?ref=238a31b33f79cddfaa40c5fd748495a5f2b34630", "patch": "@@ -0,0 +1,61 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_TYPE_CHECK_STRUCT_FIELD\n+#define RUST_HIR_TYPE_CHECK_STRUCT_FIELD\n+\n+#include \"rust-hir-type-check-base.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-hir-type-check-type.h\"\n+#include \"rust-tyty.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class TypeCheckStructExpr : public TypeCheckBase\n+{\n+public:\n+  static TyTy::TyBase *Resolve (HIR::StructExprStructFields *expr)\n+  {\n+    TypeCheckStructExpr resolver;\n+    expr->accept_vis (resolver);\n+    rust_assert (resolver.resolved != nullptr);\n+    return resolver.resolved;\n+  }\n+\n+  void visit (HIR::StructExprStructFields &struct_expr);\n+\n+  void visit (HIR::PathInExpression &path);\n+\n+  void visit (HIR::StructExprFieldIdentifierValue &field);\n+\n+private:\n+  TypeCheckStructExpr ()\n+    : TypeCheckBase (), resolved (nullptr), struct_path_resolved (nullptr)\n+  {}\n+\n+  TyTy::TyBase *resolved;\n+  TyTy::ADTType *struct_path_resolved;\n+  TyTy::TyBase *resolved_field;\n+  std::set<std::string> fields_assigned;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_TYPE_CHECK_STRUCT_FIELD"}, {"sha": "34e702065192e4e90480f337eff2ca20752097c1", "filename": "gcc/rust/typecheck/rust-hir-type-check-toplevel.h", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h?ref=238a31b33f79cddfaa40c5fd748495a5f2b34630", "patch": "@@ -22,6 +22,7 @@\n #include \"rust-hir-type-check-base.h\"\n #include \"rust-hir-full.h\"\n #include \"rust-hir-type-check-type.h\"\n+#include \"rust-hir-type-check-expr.h\"\n #include \"rust-tyty.h\"\n \n namespace Rust {\n@@ -36,6 +37,46 @@ class TypeCheckTopLevel : public TypeCheckBase\n     item->accept_vis (resolver);\n   }\n \n+  void visit (HIR::StructStruct &struct_decl)\n+  {\n+    std::vector<TyTy::StructFieldType *> fields;\n+    struct_decl.iterate ([&] (HIR::StructField &field) mutable -> bool {\n+      TyTy::TyBase *field_type\n+\t= TypeCheckType::Resolve (field.get_field_type ().get ());\n+      TyTy::StructFieldType *ty_field\n+\t= new TyTy::StructFieldType (field.get_mappings ().get_hirid (),\n+\t\t\t\t     field.get_field_name (), field_type);\n+      fields.push_back (ty_field);\n+      context->insert_type (field.get_mappings ().get_hirid (),\n+\t\t\t    ty_field->get_field_type ());\n+      return true;\n+    });\n+\n+    TyTy::TyBase *type\n+      = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),\n+\t\t\t   struct_decl.get_identifier (), std::move (fields));\n+\n+    context->insert_type (struct_decl.get_mappings ().get_hirid (), type);\n+  }\n+\n+  void visit (HIR::StaticItem &var)\n+  {\n+    TyTy::TyBase *type = TypeCheckType::Resolve (var.get_type ());\n+    TyTy::TyBase *expr_type = TypeCheckExpr::Resolve (var.get_expr ());\n+\n+    context->insert_type (var.get_mappings ().get_hirid (),\n+\t\t\t  type->combine (expr_type));\n+  }\n+\n+  void visit (HIR::ConstantItem &constant)\n+  {\n+    TyTy::TyBase *type = TypeCheckType::Resolve (constant.get_type ());\n+    TyTy::TyBase *expr_type = TypeCheckExpr::Resolve (constant.get_expr ());\n+\n+    context->insert_type (constant.get_mappings ().get_hirid (),\n+\t\t\t  type->combine (expr_type));\n+  }\n+\n   void visit (HIR::Function &function)\n   {\n     TyTy::TyBase *ret_type = nullptr;"}, {"sha": "8ff4c447e4f39381a2fb854236281d7f8a2e0d97", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h?ref=238a31b33f79cddfaa40c5fd748495a5f2b34630", "patch": "@@ -87,7 +87,8 @@ class TypeCheckType : public TypeCheckBase\n     if (!resolver->lookup_resolved_type (path.get_mappings ().get_nodeid (),\n \t\t\t\t\t &ref))\n       {\n-\trust_error_at (path.get_locus (), \"Type was not resolved\");\n+\trust_fatal_error (path.get_locus (),\n+\t\t\t  \"Failed to resolve node id to HIR\");\n \treturn;\n       }\n "}, {"sha": "e7d33666826adb2825d84374bd9bcd175f30fae0", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=238a31b33f79cddfaa40c5fd748495a5f2b34630", "patch": "@@ -21,6 +21,7 @@\n #include \"rust-hir-type-check-toplevel.h\"\n #include \"rust-hir-type-check-item.h\"\n #include \"rust-hir-type-check-expr.h\"\n+#include \"rust-hir-type-check-struct-field.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -45,5 +46,123 @@ TypeCheckExpr::visit (HIR::BlockExpr &expr)\n   });\n }\n \n+// RUST_HIR_TYPE_CHECK_STRUCT_FIELD\n+\n+void\n+TypeCheckStructExpr::visit (HIR::StructExprStructFields &struct_expr)\n+{\n+  struct_expr.get_struct_name ().accept_vis (*this);\n+  if (struct_path_resolved == nullptr)\n+    {\n+      rust_fatal_error (struct_expr.get_struct_name ().get_locus (),\n+\t\t\t\"Failed to resolve type\");\n+      return;\n+    }\n+\n+  struct_expr.iterate ([&] (HIR::StructExprField *field) mutable -> bool {\n+    resolved_field = nullptr;\n+    field->accept_vis (*this);\n+    if (resolved_field == nullptr)\n+      {\n+\trust_fatal_error (field->get_locus (),\n+\t\t\t  \"failed to resolve type for field\");\n+\treturn false;\n+      }\n+\n+    context->insert_type (field->get_mappings ().get_hirid (), resolved_field);\n+    return true;\n+  });\n+\n+  TyTy::TyBase *expr_type = struct_path_resolved;\n+  if (struct_expr.has_struct_base ())\n+    {\n+      TyTy::TyBase *base_resolved\n+\t= TypeCheckExpr::Resolve (struct_expr.struct_base->base_struct.get ());\n+      expr_type = expr_type->combine (base_resolved);\n+      if (resolved == nullptr)\n+\t{\n+\t  rust_fatal_error (\n+\t    struct_expr.struct_base->base_struct->get_locus_slow (),\n+\t    \"incompatible types for base struct reference\");\n+\t  return;\n+\t}\n+    }\n+  else if (fields_assigned.size () != struct_path_resolved->num_fields ())\n+    {\n+      rust_fatal_error (struct_expr.get_locus (),\n+\t\t\t\"some fields are not fully assigned\");\n+      return;\n+    }\n+\n+  resolved = expr_type;\n+}\n+\n+void\n+TypeCheckStructExpr::visit (HIR::PathInExpression &expr)\n+{\n+  NodeId ast_node_id = expr.get_mappings ().get_nodeid ();\n+\n+  // then lookup the reference_node_id\n+  NodeId ref_node_id;\n+  if (!resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n+    {\n+      rust_error_at (expr.get_locus (),\n+\t\t     \"Failed to lookup reference for node: %s\",\n+\t\t     expr.as_string ().c_str ());\n+      return;\n+    }\n+\n+  // node back to HIR\n+  HirId ref;\n+  if (!mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n+\t\t\t\t     ref_node_id, &ref))\n+    {\n+      rust_error_at (expr.get_locus (), \"reverse lookup failure\");\n+      return;\n+    }\n+\n+  // the base reference for this name _must_ have a type set\n+  TyTy::TyBase *lookup;\n+  if (!context->lookup_type (ref, &lookup))\n+    {\n+      rust_error_at (mappings->lookup_location (ref),\n+\t\t     \"consider giving this a type: %s\",\n+\t\t     expr.as_string ().c_str ());\n+      return;\n+    }\n+\n+  if (lookup->get_kind () != TyTy::TypeKind::ADT)\n+    {\n+      rust_fatal_error (mappings->lookup_location (ref),\n+\t\t\t\"expected an ADT type\");\n+      return;\n+    }\n+  struct_path_resolved = (TyTy::ADTType *) lookup;\n+}\n+\n+void\n+TypeCheckStructExpr::visit (HIR::StructExprFieldIdentifierValue &field)\n+{\n+  auto it = fields_assigned.find (field.field_name);\n+  if (it != fields_assigned.end ())\n+    {\n+      rust_fatal_error (field.get_locus (), \"used more than once\");\n+      return;\n+    }\n+\n+  TyTy::TyBase *value = TypeCheckExpr::Resolve (field.get_value ());\n+  TyTy::StructFieldType *field_type\n+    = struct_path_resolved->get_field (field.field_name);\n+  if (field_type == nullptr)\n+    {\n+      rust_error_at (field.get_locus (), \"unknown field\");\n+      return;\n+    }\n+\n+  resolved_field = field_type->get_field_type ()->combine (value);\n+  if (resolved_field != nullptr)\n+    fields_assigned.insert (field.field_name);\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "615ef80708bcaf2f8fa5bab8765ef89c25fa7274", "filename": "gcc/rust/typecheck/rust-tyty-rules.h", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h?ref=238a31b33f79cddfaa40c5fd748495a5f2b34630", "patch": "@@ -134,6 +134,24 @@ class InferRules : protected BaseRules\n   TyBase *resolved;\n };\n \n+class StructFieldTypeRules : protected BaseRules\n+{\n+public:\n+  StructFieldTypeRules (StructFieldType *base)\n+    : BaseRules (base), base (base), resolved (nullptr)\n+  {}\n+\n+  TyBase *combine (TyBase *other)\n+  {\n+    other->accept_vis (*this);\n+    return resolved;\n+  }\n+\n+private:\n+  StructFieldType *base;\n+  TyBase *resolved;\n+};\n+\n class UnitRules : protected BaseRules\n {\n public:\n@@ -298,6 +316,31 @@ class UintRules : protected BaseRules\n   TyBase *resolved;\n };\n \n+class FloatRules : protected BaseRules\n+{\n+public:\n+  FloatRules (FloatType *base)\n+    : BaseRules (base), base (base), resolved (nullptr)\n+  {}\n+  ~FloatRules () {}\n+\n+  TyBase *combine (TyBase *other)\n+  {\n+    other->accept_vis (*this);\n+    return resolved;\n+  }\n+\n+  void visit (FloatType &type) override\n+  {\n+    // FIXME we should look at the FloatKind and respect it\n+    resolved = new FloatType (type.get_ref (), type.get_kind ());\n+  }\n+\n+private:\n+  FloatType *base;\n+  TyBase *resolved;\n+};\n+\n } // namespace TyTy\n } // namespace Rust\n "}, {"sha": "40998ca3caad1105dce8c4513d89ceb975f7fe74", "filename": "gcc/rust/typecheck/rust-tyty-visitor.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Ftypecheck%2Frust-tyty-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Ftypecheck%2Frust-tyty-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-visitor.h?ref=238a31b33f79cddfaa40c5fd748495a5f2b34630", "patch": "@@ -29,12 +29,15 @@ class TyVisitor\n public:\n   virtual void visit (UnitType &type) {}\n   virtual void visit (InferType &type) {}\n+  virtual void visit (StructFieldType &type) {}\n+  virtual void visit (ADTType &type) {}\n   virtual void visit (FnType &type) {}\n   virtual void visit (ParamType &type) {}\n   virtual void visit (ArrayType &type) {}\n   virtual void visit (BoolType &type) {}\n   virtual void visit (IntType &type) {}\n   virtual void visit (UintType &type) {}\n+  virtual void visit (FloatType &type) {}\n };\n \n } // namespace TyTy"}, {"sha": "0cefab67ba9e13c623189900e5fd2a8325795ebf", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=238a31b33f79cddfaa40c5fd748495a5f2b34630", "patch": "@@ -63,6 +63,47 @@ InferType::combine (TyBase *other)\n   return r.combine (other);\n }\n \n+void\n+StructFieldType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+StructFieldType::as_string () const\n+{\n+  return name + \":\" + ty->as_string ();\n+}\n+\n+TyBase *\n+StructFieldType::combine (TyBase *other)\n+{\n+  StructFieldTypeRules r (this);\n+  return r.combine (other);\n+}\n+\n+void\n+ADTType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+ADTType::as_string () const\n+{\n+  std::string fields_buffer;\n+  for (auto &field : fields)\n+    fields_buffer += field->as_string () + \"\\n\";\n+\n+  return identifier + \"{\\n\" + fields_buffer + \"\\n}\";\n+}\n+\n+TyBase *\n+ADTType::combine (TyBase *other)\n+{\n+  return nullptr;\n+}\n+\n void\n FnType::accept_vis (TyVisitor &vis)\n {\n@@ -164,6 +205,10 @@ IntType::as_string () const\n       return \"i16\";\n     case I32:\n       return \"i32\";\n+    case I64:\n+      return \"i64\";\n+    case I128:\n+      return \"i128\";\n     }\n   gcc_unreachable ();\n   return \"__unknown_int_type\";\n@@ -193,6 +238,10 @@ UintType::as_string () const\n       return \"u16\";\n     case U32:\n       return \"u32\";\n+    case U64:\n+      return \"u64\";\n+    case U128:\n+      return \"u128\";\n     }\n   gcc_unreachable ();\n   return \"__unknown_uint_type\";\n@@ -205,6 +254,33 @@ UintType::combine (TyBase *other)\n   return r.combine (other);\n }\n \n+void\n+FloatType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+FloatType::as_string () const\n+{\n+  switch (float_kind)\n+    {\n+    case F32:\n+      return \"f32\";\n+    case F64:\n+      return \"f64\";\n+    }\n+  gcc_unreachable ();\n+  return \"__unknown_float_type\";\n+}\n+\n+TyBase *\n+FloatType::combine (TyBase *other)\n+{\n+  FloatRules r (this);\n+  return r.combine (other);\n+}\n+\n void\n TypeCheckCallExpr::visit (FnType &type)\n {"}, {"sha": "59c4bcb93fc9caacaac3a2261565620c22dc451c", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=238a31b33f79cddfaa40c5fd748495a5f2b34630", "patch": "@@ -41,6 +41,7 @@ enum TypeKind\n   UINT,\n   FLOAT,\n   UNIT,\n+  FIELD,\n   // there are more to add...\n };\n \n@@ -60,6 +61,8 @@ class TyBase\n \n   virtual bool is_unit () const { return kind == TypeKind::UNIT; }\n \n+  TypeKind get_kind () const { return kind; }\n+\n protected:\n   TyBase (HirId ref, TypeKind kind) : kind (kind), ref (ref) {}\n \n@@ -95,6 +98,65 @@ class UnitType : public TyBase\n   TyBase *combine (TyBase *other) override;\n };\n \n+class StructFieldType : public TyBase\n+{\n+public:\n+  StructFieldType (HirId ref, std::string name, TyBase *ty)\n+    : TyBase (ref, TypeKind::FIELD), name (name), ty (ty)\n+  {}\n+\n+  void accept_vis (TyVisitor &vis) override;\n+\n+  bool is_unit () const override { return ty->is_unit (); }\n+\n+  std::string as_string () const override;\n+\n+  TyBase *combine (TyBase *other) override;\n+\n+  std::string get_name () const { return name; }\n+\n+  TyBase *get_field_type () { return ty; }\n+\n+private:\n+  std::string name;\n+  TyBase *ty;\n+};\n+\n+class ADTType : public TyBase\n+{\n+public:\n+  ADTType (HirId ref, std::string identifier,\n+\t   std::vector<StructFieldType *> fields)\n+    : TyBase (ref, TypeKind::ADT), identifier (identifier), fields (fields)\n+  {}\n+\n+  void accept_vis (TyVisitor &vis) override;\n+\n+  bool is_unit () const override { return false; }\n+\n+  std::string as_string () const override;\n+\n+  TyBase *combine (TyBase *other) override;\n+\n+  size_t num_fields () const { return fields.size (); }\n+\n+  StructFieldType *get_field (size_t index) { return fields.at (index); }\n+\n+  StructFieldType *get_field (const std::string &lookup)\n+  {\n+    for (auto &field : fields)\n+      {\n+\tif (field->get_name ().compare (lookup) == 0)\n+\t  return field;\n+      }\n+    return nullptr;\n+  }\n+\n+private:\n+  std::string identifier;\n+  std::vector<StructFieldType *> fields;\n+};\n+\n class ParamType : public TyBase\n {\n public:\n@@ -185,6 +247,8 @@ class IntType : public TyBase\n     I8,\n     I16,\n     I32,\n+    I64,\n+    I128\n   };\n \n   IntType (HirId ref, IntKind kind)\n@@ -211,6 +275,8 @@ class UintType : public TyBase\n     U8,\n     U16,\n     U32,\n+    U64,\n+    U128\n   };\n \n   UintType (HirId ref, UintKind kind)\n@@ -229,6 +295,31 @@ class UintType : public TyBase\n   UintKind uint_kind;\n };\n \n+class FloatType : public TyBase\n+{\n+public:\n+  enum FloatKind\n+  {\n+    F32,\n+    F64\n+  };\n+\n+  FloatType (HirId ref, FloatKind kind)\n+    : TyBase (ref, TypeKind::FLOAT), float_kind (kind)\n+  {}\n+\n+  void accept_vis (TyVisitor &vis) override;\n+\n+  std::string as_string () const override;\n+\n+  TyBase *combine (TyBase *other) override;\n+\n+  FloatKind get_kind () const { return float_kind; }\n+\n+private:\n+  FloatKind float_kind;\n+};\n+\n } // namespace TyTy\n } // namespace Rust\n "}, {"sha": "e8ef96b206d456e1cab5a3880ec4267654ea45c7", "filename": "gcc/testsuite/rust.test/compilable/constant1.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fconstant1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fconstant1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fconstant1.rs?ref=238a31b33f79cddfaa40c5fd748495a5f2b34630", "patch": "@@ -0,0 +1,8 @@\n+const TEST_CONST:i32 = 10;\n+\n+fn main() {\n+    let mut x = TEST_CONST;\n+    x = x + 1;\n+\n+    let mut y = x + TEST_CONST;\n+}"}, {"sha": "57a746fa2e09a89e220c040b2171631bf085e574", "filename": "gcc/testsuite/rust.test/compilable/float1.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ffloat1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ffloat1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ffloat1.rs?ref=238a31b33f79cddfaa40c5fd748495a5f2b34630", "patch": "@@ -0,0 +1,8 @@\n+fn test(x: f32) -> f32 {\n+    return x + 1.0;\n+}\n+\n+fn main() {\n+    let a_float = 5.123;\n+    let call_test = test(a_float + 1.0);\n+}"}, {"sha": "22a916450bad513028a4b9d6d7ec07269e127a57", "filename": "gcc/testsuite/rust.test/compilable/integer_types.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Finteger_types.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Finteger_types.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Finteger_types.rs?ref=238a31b33f79cddfaa40c5fd748495a5f2b34630", "patch": "@@ -0,0 +1,25 @@\n+fn main() {\n+    let a1: i8 = 1i8;\n+    let a2: i16 = 2i16;\n+    let a3: i32 = 3i32;\n+    let a4: i64 = 4i64;\n+    let a5: i128 = 5i128;\n+\n+    let b1 = 1i8;\n+    let b2 = 2i16;\n+    let b3 = 3i32;\n+    let b4 = 4i64;\n+    let b5 = 5i128;\n+\n+    let c1: u8 = 1u8;\n+    let c2: u16 = 2u16;\n+    let c3: u32 = 3u32;\n+    let c4: u64 = 4u64;\n+    let c5: u128 = 5u128;\n+\n+    let d1 = 1u8;\n+    let d2 = 2u16;\n+    let d3 = 3u32;\n+    let d4 = 4u64;\n+    let d5 = 5u128;\n+}"}, {"sha": "8464f413b602433bfedfbcbddbd825bab2b8b295", "filename": "gcc/testsuite/rust.test/compilable/static_var1.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstatic_var1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstatic_var1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstatic_var1.rs?ref=238a31b33f79cddfaa40c5fd748495a5f2b34630", "patch": "@@ -0,0 +1,5 @@\n+static x:i32 = 3;\n+\n+fn main() {\n+    let y = x +1;\n+}"}, {"sha": "d94c8c15eddbeceb9d746d8f14ac3191ad819659", "filename": "gcc/testsuite/rust.test/fail_compilation/static_var1.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fstatic_var1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/238a31b33f79cddfaa40c5fd748495a5f2b34630/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fstatic_var1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fstatic_var1.rs?ref=238a31b33f79cddfaa40c5fd748495a5f2b34630", "patch": "@@ -0,0 +1,5 @@\n+static x = 3;\n+\n+fn main() {\n+    let y = x +1;\n+}"}]}