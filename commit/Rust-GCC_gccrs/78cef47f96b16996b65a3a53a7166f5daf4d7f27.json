{"sha": "78cef47f96b16996b65a3a53a7166f5daf4d7f27", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzhjZWY0N2Y5NmIxNjk5NmI2NWEzYTUzYTcxNjZmNWRhZjRkN2YyNw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-20T12:20:20Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-20T12:20:20Z"}, "message": "[multiple changes]\n\n2015-10-20  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch5.adb (Analyze_Loop_Statement): Attach generated loop\n\tidentifier to the tree, because it may be the root of a tree\n\ttraversal in Pop_Scope when freeze actions are pending.\n\n2015-10-20  Steve Baird  <baird@adacore.com>\n\n\t* pprint.ads (Expression_Image) Add new generic formal flag\n\tHide_Parameter_Blocks.\n\t* pprint.adb (Expression_Image) If new flag is set, then display\n\tdereferences of parameter block components accordingly.\n\nFrom-SVN: r229068", "tree": {"sha": "5b3d84e3434e373189d22f29f03d2d7cfc6cb2c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b3d84e3434e373189d22f29f03d2d7cfc6cb2c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/78cef47f96b16996b65a3a53a7166f5daf4d7f27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78cef47f96b16996b65a3a53a7166f5daf4d7f27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78cef47f96b16996b65a3a53a7166f5daf4d7f27", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78cef47f96b16996b65a3a53a7166f5daf4d7f27/comments", "author": null, "committer": null, "parents": [{"sha": "e5f2c03ceabe47ad4fc3162efb328508d74e78a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5f2c03ceabe47ad4fc3162efb328508d74e78a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5f2c03ceabe47ad4fc3162efb328508d74e78a6"}], "stats": {"total": 319, "additions": 209, "deletions": 110}, "files": [{"sha": "aa6d6ee6fa5a50c81b7de63a4a977d259567e448", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78cef47f96b16996b65a3a53a7166f5daf4d7f27/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78cef47f96b16996b65a3a53a7166f5daf4d7f27/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=78cef47f96b16996b65a3a53a7166f5daf4d7f27", "patch": "@@ -1,3 +1,16 @@\n+2015-10-20  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch5.adb (Analyze_Loop_Statement): Attach generated loop\n+\tidentifier to the tree, because it may be the root of a tree\n+\ttraversal in Pop_Scope when freeze actions are pending.\n+\n+2015-10-20  Steve Baird  <baird@adacore.com>\n+\n+\t* pprint.ads (Expression_Image) Add new generic formal flag\n+\tHide_Parameter_Blocks.\n+\t* pprint.adb (Expression_Image) If new flag is set, then display\n+\tdereferences of parameter block components accordingly.\n+\n 2015-10-20  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_prag.adb: Code clean up."}, {"sha": "102611fa3717b3a02500482fc93fd3d4ebcc5e53", "filename": "gcc/ada/pprint.adb", "status": "modified", "additions": 188, "deletions": 109, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78cef47f96b16996b65a3a53a7166f5daf4d7f27/gcc%2Fada%2Fpprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78cef47f96b16996b65a3a53a7166f5daf4d7f27/gcc%2Fada%2Fpprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpprint.adb?ref=78cef47f96b16996b65a3a53a7166f5daf4d7f27", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2008-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2008-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -43,13 +43,16 @@ package body Pprint is\n    -- Expression_Image --\n    ----------------------\n \n-   function Expression_Image (Expr : Node_Id; Default : String)\n-      return String is\n-      Left         : Node_Id := Original_Node (Expr);\n-      Right        : Node_Id := Original_Node (Expr);\n+   function Expression_Image\n+     (Expr    : Node_Id;\n+      Default : String) return String\n+   is\n       From_Source  : constant Boolean :=\n-        Comes_From_Source (Expr) and then not Opt.Debug_Generated_Code;\n+                       Comes_From_Source (Expr)\n+                         and then not Opt.Debug_Generated_Code;\n       Append_Paren : Boolean := False;\n+      Left         : Node_Id := Original_Node (Expr);\n+      Right        : Node_Id := Original_Node (Expr);\n \n       function Expr_Name\n         (Expr        : Node_Id;\n@@ -76,6 +79,10 @@ package body Pprint is\n          Add_Paren : Boolean := True) return String;\n       --  Return a string corresponding to List\n \n+      ---------------\n+      -- List_Name --\n+      ---------------\n+\n       function List_Name\n         (List      : Node_Id;\n          Add_Space : Boolean := True;\n@@ -87,6 +94,7 @@ package body Pprint is\n             Add_Space : Boolean := True;\n             Add_Paren : Boolean := True;\n             Num       : Natural := 1) return String;\n+         --  ??? what does this do\n \n          ------------------------\n          -- Internal_List_Name --\n@@ -100,6 +108,7 @@ package body Pprint is\n             Num       : Natural := 1) return String\n          is\n             function Prepend (S : String) return String;\n+            --  ??? what does this do\n \n             -------------\n             -- Prepend --\n@@ -137,20 +146,22 @@ package body Pprint is\n                end if;\n             end if;\n \n+            --  ??? the Internal_List_Name calls can be factored out\n+\n             if First then\n-               return Prepend\n-                 (Expr_Name (List)\n-                  & Internal_List_Name (Next (List),\n-                    First     => False,\n-                    Add_Paren => Add_Paren,\n-                    Num       => Num + 1));\n+               return Prepend (Expr_Name (List)\n+                 & Internal_List_Name\n+                     (List      => Next (List),\n+                      First     => False,\n+                      Add_Paren => Add_Paren,\n+                      Num       => Num + 1));\n             else\n-               return \", \" & Expr_Name (List) &\n-                 Internal_List_Name\n-                 (Next (List),\n-                  First     => False,\n-                  Add_Paren => Add_Paren,\n-                  Num       => Num + 1);\n+               return \", \" & Expr_Name (List)\n+                 & Internal_List_Name\n+                     (List      => Next (List),\n+                      First     => False,\n+                      Add_Paren => Add_Paren,\n+                      Num       => Num + 1);\n             end if;\n          end Internal_List_Name;\n \n@@ -164,10 +175,13 @@ package body Pprint is\n          end if;\n \n          List_Name_Count := List_Name_Count + 1;\n+\n          declare\n             Result : constant String :=\n-              Internal_List_Name\n-                (List, Add_Space => Add_Space, Add_Paren => Add_Paren);\n+                       Internal_List_Name\n+                         (List      => List,\n+                          Add_Space => Add_Space,\n+                          Add_Paren => Add_Paren);\n          begin\n             List_Name_Count := List_Name_Count - 1;\n             return Result;\n@@ -197,14 +211,14 @@ package body Pprint is\n             when N_Character_Literal =>\n                declare\n                   Char : constant Int :=\n-                    UI_To_Int (Char_Literal_Value (Expr));\n+                           UI_To_Int (Char_Literal_Value (Expr));\n                begin\n                   if Char in 32 .. 127 then\n                      return \"'\" & Character'Val (Char) & \"'\";\n                   else\n                      UI_Image (Char_Literal_Value (Expr));\n-                     return \"'\\\" & UI_Image_Buffer (1 .. UI_Image_Length)\n-                       & \"'\";\n+                     return\n+                       \"'\\\" & UI_Image_Buffer (1 .. UI_Image_Length) & \"'\";\n                   end if;\n                end;\n \n@@ -223,8 +237,10 @@ package body Pprint is\n \n             when N_Aggregate =>\n                if Present (Sinfo.Expressions (Expr)) then\n-                  return List_Name\n-                    (First (Sinfo.Expressions (Expr)), Add_Space => False);\n+                  return\n+                    List_Name\n+                      (List      => First (Sinfo.Expressions (Expr)),\n+                       Add_Space => False);\n \n                --  Do not return empty string for (others => <>) aggregate\n                --  of a componentless record type. At least one caller (the\n@@ -237,27 +253,30 @@ package body Pprint is\n                   return (\"(null record)\");\n \n                else\n-                  return List_Name\n-                    (First (Component_Associations (Expr)),\n-                     Add_Space => False, Add_Paren => False);\n+                  return\n+                    List_Name\n+                      (List      => First (Component_Associations (Expr)),\n+                       Add_Space => False,\n+                       Add_Paren => False);\n                end if;\n \n             when N_Extension_Aggregate =>\n-               return \"(\" & Expr_Name (Ancestor_Part (Expr)) &\n-                 \" with \" &\n-                 List_Name (First (Sinfo.Expressions (Expr)),\n-                            Add_Space => False, Add_Paren => False) &\n-                 \")\";\n+               return \"(\" & Expr_Name (Ancestor_Part (Expr)) & \" with \"\n+                 & List_Name\n+                     (List      => First (Sinfo.Expressions (Expr)),\n+                      Add_Space => False,\n+                      Add_Paren => False) & \")\";\n \n             when N_Attribute_Reference =>\n                if Take_Prefix then\n                   declare\n-                     Str    : constant String := Expr_Name (Prefix (Expr))\n-                       & \"'\" & Get_Name_String (Attribute_Name (Expr));\n                      Id     : constant Attribute_Id :=\n-                       Get_Attribute_Id (Attribute_Name (Expr));\n-                     Ranges : List_Id;\n+                                Get_Attribute_Id (Attribute_Name (Expr));\n+                     Str    : constant String :=\n+                                Expr_Name (Prefix (Expr)) & \"'\"\n+                                  & Get_Name_String (Attribute_Name (Expr));\n                      N      : Node_Id;\n+                     Ranges : List_Id;\n \n                   begin\n                      if (Id = Attribute_First or else Id = Attribute_Last)\n@@ -271,22 +290,26 @@ package body Pprint is\n                            end if;\n \n                            if Nkind (N) = N_Subtype_Declaration then\n-                              Ranges := Constraints (Constraint\n-                                                     (Subtype_Indication (N)));\n+                              Ranges :=\n+                                Constraints\n+                                  (Constraint (Subtype_Indication (N)));\n \n                               if List_Length (Ranges) = 1\n-                                and then Nkind_In\n-                                  (First (Ranges),\n-                                   N_Range,\n-                                   N_Real_Range_Specification,\n-                                   N_Signed_Integer_Type_Definition)\n+                                and then\n+                                  Nkind_In\n+                                    (First (Ranges),\n+                                     N_Range,\n+                                     N_Real_Range_Specification,\n+                                     N_Signed_Integer_Type_Definition)\n                               then\n                                  if Id = Attribute_First then\n-                                    return Expression_Image\n-                                      (Low_Bound (First (Ranges)), Str);\n+                                    return\n+                                      Expression_Image\n+                                        (Low_Bound (First (Ranges)), Str);\n                                  else\n-                                    return Expression_Image\n-                                      (High_Bound (First (Ranges)), Str);\n+                                    return\n+                                      Expression_Image\n+                                        (High_Bound (First (Ranges)), Str);\n                                  end if;\n                               end if;\n                            end if;\n@@ -300,39 +323,55 @@ package body Pprint is\n                end if;\n \n             when N_Explicit_Dereference =>\n-               if Take_Prefix then\n+\n+               --  Return \"Foo\" instead of \"Parameter_Block.Foo.all\"\n+\n+               if Hide_Parameter_Blocks\n+                 and then Nkind (Prefix (Expr)) = N_Selected_Component\n+                 and then Present (Etype (Prefix (Expr)))\n+                 and then Is_Access_Type (Etype (Prefix (Expr)))\n+                 and then Is_Param_Block_Component_Type (Etype (Prefix (Expr)))\n+               then\n+                  return Expr_Name (Selector_Name (Prefix (Expr)));\n+\n+               elsif Take_Prefix then\n                   return Expr_Name (Prefix (Expr)) & \".all\";\n                else\n                   return \".all\";\n                end if;\n \n             when N_Expanded_Name | N_Selected_Component =>\n                if Take_Prefix then\n-                  return Expr_Name (Prefix (Expr))\n-                    & \".\" & Expr_Name (Selector_Name (Expr));\n+                  return\n+                    Expr_Name (Prefix (Expr)) & \".\" &\n+                    Expr_Name (Selector_Name (Expr));\n                else\n                   return \".\" & Expr_Name (Selector_Name (Expr));\n                end if;\n \n             when N_Component_Association =>\n                return \"(\"\n-                 & List_Name (First (Choices (Expr)),\n-                              Add_Space => False, Add_Paren => False)\n+                 & List_Name\n+                     (List      => First (Choices (Expr)),\n+                      Add_Space => False,\n+                      Add_Paren => False)\n                  & \" => \" & Expr_Name (Expression (Expr)) & \")\";\n \n             when N_If_Expression =>\n                declare\n                   N : constant Node_Id := First (Sinfo.Expressions (Expr));\n                begin\n-                  return \"if \" & Expr_Name (N) & \" then \" &\n-                    Expr_Name (Next (N)) & \" else \" &\n-                    Expr_Name (Next (Next (N)));\n+                  return\n+                    \"if \" & Expr_Name (N) & \" then \"\n+                      & Expr_Name (Next (N)) & \" else \"\n+                      & Expr_Name (Next (Next (N)));\n                end;\n \n             when N_Qualified_Expression =>\n                declare\n                   Mark : constant String :=\n-                    Expr_Name (Subtype_Mark (Expr), Expand_Type => False);\n+                           Expr_Name\n+                             (Subtype_Mark (Expr), Expand_Type => False);\n                   Str  : constant String := Expr_Name (Expression (Expr));\n                begin\n                   if Str (Str'First) = '(' and then Str (Str'Last) = ')' then\n@@ -347,118 +386,145 @@ package body Pprint is\n \n             when N_Raise_Constraint_Error =>\n                if Present (Condition (Expr)) then\n-                  return \"[constraint_error when \" &\n-                    Expr_Name (Condition (Expr)) & \"]\";\n+                  return\n+                    \"[constraint_error when \"\n+                      & Expr_Name (Condition (Expr)) & \"]\";\n                else\n                   return \"[constraint_error]\";\n                end if;\n \n             when N_Raise_Program_Error =>\n                if Present (Condition (Expr)) then\n-                  return \"[program_error when \" &\n-                    Expr_Name (Condition (Expr)) & \"]\";\n+                  return\n+                    \"[program_error when \"\n+                      & Expr_Name (Condition (Expr)) & \"]\";\n                else\n                   return \"[program_error]\";\n                end if;\n \n             when N_Range =>\n-               return Expr_Name (Low_Bound (Expr)) & \"..\" &\n+               return\n+                 Expr_Name (Low_Bound (Expr)) & \"..\" &\n                  Expr_Name (High_Bound (Expr));\n \n             when N_Slice =>\n-               return Expr_Name (Prefix (Expr)) & \" (\" &\n+               return\n+                 Expr_Name (Prefix (Expr)) & \" (\" &\n                  Expr_Name (Discrete_Range (Expr)) & \")\";\n \n             when N_And_Then =>\n-               return Expr_Name (Left_Opnd (Expr)) & \" and then \" &\n+               return\n+                 Expr_Name (Left_Opnd (Expr)) & \" and then \" &\n                  Expr_Name (Right_Opnd (Expr));\n \n             when N_In =>\n-               return Expr_Name (Left_Opnd (Expr)) & \" in \" &\n+               return\n+                 Expr_Name (Left_Opnd (Expr)) & \" in \" &\n                  Expr_Name (Right_Opnd (Expr));\n \n             when N_Not_In =>\n-               return Expr_Name (Left_Opnd (Expr)) & \" not in \" &\n+               return\n+                 Expr_Name (Left_Opnd (Expr)) & \" not in \" &\n                  Expr_Name (Right_Opnd (Expr));\n \n             when N_Or_Else =>\n-               return Expr_Name (Left_Opnd (Expr)) & \" or else \" &\n+               return\n+                 Expr_Name (Left_Opnd (Expr)) & \" or else \" &\n                  Expr_Name (Right_Opnd (Expr));\n \n             when N_Op_And =>\n-               return Expr_Name (Left_Opnd (Expr)) & \" and \" &\n+               return\n+                 Expr_Name (Left_Opnd (Expr)) & \" and \" &\n                  Expr_Name (Right_Opnd (Expr));\n \n             when N_Op_Or =>\n-               return Expr_Name (Left_Opnd (Expr)) & \" or \" &\n+               return\n+                 Expr_Name (Left_Opnd (Expr)) & \" or \" &\n                  Expr_Name (Right_Opnd (Expr));\n \n             when N_Op_Xor =>\n-               return Expr_Name (Left_Opnd (Expr)) & \" xor \" &\n+               return\n+                 Expr_Name (Left_Opnd (Expr)) & \" xor \" &\n                  Expr_Name (Right_Opnd (Expr));\n \n             when N_Op_Eq =>\n-               return Expr_Name (Left_Opnd (Expr)) & \" = \" &\n+               return\n+                 Expr_Name (Left_Opnd (Expr)) & \" = \" &\n                  Expr_Name (Right_Opnd (Expr));\n \n             when N_Op_Ne =>\n-               return Expr_Name (Left_Opnd (Expr)) & \" /= \" &\n+               return\n+                 Expr_Name (Left_Opnd (Expr)) & \" /= \" &\n                  Expr_Name (Right_Opnd (Expr));\n \n             when N_Op_Lt =>\n-               return Expr_Name (Left_Opnd (Expr)) & \" < \" &\n+               return\n+                 Expr_Name (Left_Opnd (Expr)) & \" < \" &\n                  Expr_Name (Right_Opnd (Expr));\n \n             when N_Op_Le =>\n-               return Expr_Name (Left_Opnd (Expr)) & \" <= \" &\n+               return\n+                 Expr_Name (Left_Opnd (Expr)) & \" <= \" &\n                  Expr_Name (Right_Opnd (Expr));\n \n             when N_Op_Gt =>\n-               return Expr_Name (Left_Opnd (Expr)) & \" > \" &\n+               return\n+                 Expr_Name (Left_Opnd (Expr)) & \" > \" &\n                  Expr_Name (Right_Opnd (Expr));\n \n             when N_Op_Ge =>\n-               return Expr_Name (Left_Opnd (Expr)) & \" >= \" &\n+               return\n+                 Expr_Name (Left_Opnd (Expr)) & \" >= \" &\n                  Expr_Name (Right_Opnd (Expr));\n \n             when N_Op_Add =>\n-               return Expr_Name (Left_Opnd (Expr)) & \" + \" &\n+               return\n+                 Expr_Name (Left_Opnd (Expr)) & \" + \" &\n                  Expr_Name (Right_Opnd (Expr));\n \n             when N_Op_Subtract =>\n-               return Expr_Name (Left_Opnd (Expr)) & \" - \" &\n+               return\n+                 Expr_Name (Left_Opnd (Expr)) & \" - \" &\n                  Expr_Name (Right_Opnd (Expr));\n \n             when N_Op_Multiply =>\n-               return Expr_Name (Left_Opnd (Expr)) & \" * \" &\n+               return\n+                 Expr_Name (Left_Opnd (Expr)) & \" * \" &\n                  Expr_Name (Right_Opnd (Expr));\n \n             when N_Op_Divide =>\n-               return Expr_Name (Left_Opnd (Expr)) & \" / \" &\n+               return\n+                 Expr_Name (Left_Opnd (Expr)) & \" / \" &\n                  Expr_Name (Right_Opnd (Expr));\n \n             when N_Op_Mod =>\n-               return Expr_Name (Left_Opnd (Expr)) & \" mod \" &\n+               return\n+                 Expr_Name (Left_Opnd (Expr)) & \" mod \" &\n                  Expr_Name (Right_Opnd (Expr));\n \n             when N_Op_Rem =>\n-               return Expr_Name (Left_Opnd (Expr)) & \" rem \" &\n+               return\n+                 Expr_Name (Left_Opnd (Expr)) & \" rem \" &\n                  Expr_Name (Right_Opnd (Expr));\n \n             when N_Op_Expon =>\n-               return Expr_Name (Left_Opnd (Expr)) & \" ** \" &\n+               return\n+                 Expr_Name (Left_Opnd (Expr)) & \" ** \" &\n                  Expr_Name (Right_Opnd (Expr));\n \n             when N_Op_Shift_Left =>\n-               return Expr_Name (Left_Opnd (Expr)) & \" << \" &\n+               return\n+                 Expr_Name (Left_Opnd (Expr)) & \" << \" &\n                  Expr_Name (Right_Opnd (Expr));\n \n             when N_Op_Shift_Right | N_Op_Shift_Right_Arithmetic =>\n-               return Expr_Name (Left_Opnd (Expr)) & \" >> \" &\n+               return\n+                 Expr_Name (Left_Opnd (Expr)) & \" >> \" &\n                  Expr_Name (Right_Opnd (Expr));\n \n             when N_Op_Concat =>\n-               return Expr_Name (Left_Opnd (Expr)) & \" & \" &\n+               return\n+                 Expr_Name (Left_Opnd (Expr)) & \" & \" &\n                  Expr_Name (Right_Opnd (Expr));\n \n             when N_Op_Plus =>\n@@ -485,8 +551,9 @@ package body Pprint is\n \n             when N_Indexed_Component =>\n                if Take_Prefix then\n-                  return Expr_Name (Prefix (Expr)) &\n-                    List_Name (First (Sinfo.Expressions (Expr)));\n+                  return\n+                    Expr_Name (Prefix (Expr))\n+                      & List_Name (First (Sinfo.Expressions (Expr)));\n                else\n                   return List_Name (First (Sinfo.Expressions (Expr)));\n                end if;\n@@ -498,12 +565,15 @@ package body Pprint is\n                --  parentheses around function call to mark it specially.\n \n                if Default = \"\" then\n-                  return '(' & Expr_Name (Name (Expr)) &\n-                    List_Name (First (Sinfo.Parameter_Associations (Expr))) &\n-                      ')';\n+                  return '('\n+                    & Expr_Name (Name (Expr))\n+                    & List_Name (First (Sinfo.Parameter_Associations (Expr)))\n+                    & ')';\n                else\n-                  return Expr_Name (Name (Expr)) &\n-                    List_Name (First (Sinfo.Parameter_Associations (Expr)));\n+                  return\n+                    Expr_Name (Name (Expr))\n+                      & List_Name\n+                          (First (Sinfo.Parameter_Associations (Expr)));\n                end if;\n \n             when N_Null =>\n@@ -538,18 +608,24 @@ package body Pprint is\n \n       loop\n          case Nkind (Left) is\n-            when N_Binary_Op | N_Membership_Test |\n-                 N_And_Then  | N_Or_Else         =>\n+            when N_And_Then                   |\n+                 N_Binary_Op                  |\n+                 N_Membership_Test            |\n+                 N_Or_Else                    =>\n                Left := Original_Node (Left_Opnd (Left));\n \n-            when N_Attribute_Reference  | N_Expanded_Name      |\n-                 N_Explicit_Dereference | N_Indexed_Component  |\n-                 N_Reference            | N_Selected_Component |\n-                 N_Slice                                       =>\n+            when N_Attribute_Reference        |\n+                 N_Expanded_Name              |\n+                 N_Explicit_Dereference       |\n+                 N_Indexed_Component          |\n+                 N_Reference                  |\n+                 N_Selected_Component         |\n+                 N_Slice                      =>\n                Left := Original_Node (Prefix (Left));\n \n-            when N_Designator | N_Defining_Program_Unit_Name |\n-                 N_Function_Call                             =>\n+            when N_Defining_Program_Unit_Name |\n+                 N_Designator                 |\n+                 N_Function_Call              =>\n                Left := Original_Node (Name (Left));\n \n             when N_Range =>\n@@ -567,11 +643,14 @@ package body Pprint is\n \n       loop\n          case Nkind (Right) is\n-            when N_Op       | N_Membership_Test |\n-                 N_And_Then | N_Or_Else         =>\n+            when N_And_Then           |\n+                 N_Membership_Test    |\n+                 N_Op                 |\n+                 N_Or_Else            =>\n                Right := Original_Node (Right_Opnd (Right));\n \n-            when N_Selected_Component | N_Expanded_Name =>\n+            when N_Expanded_Name      |\n+                 N_Selected_Component =>\n                Right := Original_Node (Selector_Name (Right));\n \n             when N_Designator =>\n@@ -634,11 +713,11 @@ package body Pprint is\n       end loop;\n \n       declare\n-         Scn      : Source_Ptr := Original_Location (Sloc (Left));\n-         Src      : constant Source_Buffer_Ptr :=\n-           Source_Text (Get_Source_File_Index (Scn));\n          End_Sloc : constant Source_Ptr :=\n-           Original_Location (Sloc (Right));\n+                      Original_Location (Sloc (Right));\n+         Src      : constant Source_Buffer_Ptr :=\n+                      Source_Text (Get_Source_File_Index (Scn));\n+         Scn      : Source_Ptr := Original_Location (Sloc (Left));\n \n       begin\n          if Scn > End_Sloc then\n@@ -647,9 +726,9 @@ package body Pprint is\n \n          declare\n             Buffer           : String (1 .. Natural (End_Sloc - Scn));\n+            Index            : Natural := 0;\n             Skipping_Comment : Boolean := False;\n             Underscore       : Boolean := False;\n-            Index            : Natural := 0;\n \n          begin\n             if Right /= Expr then"}, {"sha": "23160a04801a5f0a2bc2ad4f51146c624cd750a3", "filename": "gcc/ada/pprint.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78cef47f96b16996b65a3a53a7166f5daf4d7f27/gcc%2Fada%2Fpprint.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78cef47f96b16996b65a3a53a7166f5daf4d7f27/gcc%2Fada%2Fpprint.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpprint.ads?ref=78cef47f96b16996b65a3a53a7166f5daf4d7f27", "patch": "@@ -46,6 +46,10 @@ package Pprint is\n       --  nodes\n       --  ??? Expand_Type argument should be removed\n \n+      Hide_Parameter_Blocks : Boolean := False;\n+      --  If true, then \"Parameter_Block.Field_Name.all\" is\n+      --  instead displayed as \"Field_Name\".\n+\n    function Expression_Image\n      (Expr    : Node_Id;\n       Default : String) return String;"}, {"sha": "13d447e33935a5c83466f441fff4da7f651d2481", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78cef47f96b16996b65a3a53a7166f5daf4d7f27/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78cef47f96b16996b65a3a53a7166f5daf4d7f27/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=78cef47f96b16996b65a3a53a7166f5daf4d7f27", "patch": "@@ -3217,12 +3217,15 @@ package body Sem_Ch5 is\n \n       --  Case of no identifier present. Create one and attach it to the\n       --  loop statement for use as a scope and as a reference for later\n-      --  expansions. Indicate that the label does not come from source.\n+      --  expansions. Indicate that the label does not come from source,\n+      --  and attach it to the loop statement so it is part of the tree,\n+      --  even without a full declaration.\n \n       else\n          Ent := New_Internal_Entity (E_Loop, Current_Scope, Loc, 'L');\n          Set_Etype  (Ent, Standard_Void_Type);\n          Set_Identifier (N, New_Occurrence_Of (Ent, Loc));\n+         Set_Parent (Ent, N);\n          Set_Has_Created_Identifier (N);\n       end if;\n "}]}