{"sha": "98fb902fb3029da33c5a8d2fd4bd7d7bcb7271ee", "node_id": "C_kwDOANBUbNoAKDk4ZmI5MDJmYjMwMjlkYTMzYzVhOGQyZmQ0YmQ3ZDdiY2I3MjcxZWU", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-11-25T15:28:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-11-25T15:28:54Z"}, "message": "Merge #820\n\n820: Bug fix mutability checks in can_eq for autoderef r=philberty a=philberty\n\nRust is permissive about mutablity in type checking for example, if we have\r\na function:\r\n\r\n  fn foo(a:&bar) { ... }\r\n\r\n  fn caller() {\r\n    let a:&mut bar = ...;\r\n    foo(a);\r\n  }\r\n\r\nThis is valid since the mutable reference to bar is valid to be turned into\r\nan immutable reference without any conversion. Like in C a non-const\r\npointer is valid to be passed to a const pointer inferface.\r\n\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "7f218adb953e271d4e9053a28d91554600df66d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7f218adb953e271d4e9053a28d91554600df66d9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98fb902fb3029da33c5a8d2fd4bd7d7bcb7271ee", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhn6u2CRBK7hj4Ov3rIwAA5OoIALDaLaAYP4+FTv5oqyOMIxV3\nbK3QOtjTqkmMqxK77jj+GOTTO7MtxGKfO4hV+0zPnGSUpmPJD0dM1rW8iUGb8vLq\n0/LnnvlX7Kul1HoM+fpLtRWG+HlDdHwcoS2jNRi0z8K3M6eZmFq62do8rUwcApr7\nyK5CMm+OPoaq74zCYqEm0CxhXaPqsXc26jWKl+sNy7t48q/SyAIMq34/s3pF5wE+\nHA+tMy2pfVAfDY91STiaFrXshXcf077lAJlz1emEequtpRHhUp2Z/SPvuLfRfOoh\ni8PZfR58AQ2jXqrxE66GWv74UtJN2ZQcSUN59HpMB0aOl/cxHsjOl92C72Yz2M8=\n=IQr4\n-----END PGP SIGNATURE-----\n", "payload": "tree 7f218adb953e271d4e9053a28d91554600df66d9\nparent 295f0ae16613b44c13a15ae5ada080761b62ff54\nparent a2f59f14ceace0b8e614f972beacd45acfb284c7\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1637854134 +0000\ncommitter GitHub <noreply@github.com> 1637854134 +0000\n\nMerge #820\n\n820: Bug fix mutability checks in can_eq for autoderef r=philberty a=philberty\n\nRust is permissive about mutablity in type checking for example, if we have\r\na function:\r\n\r\n  fn foo(a:&bar) { ... }\r\n\r\n  fn caller() {\r\n    let a:&mut bar = ...;\r\n    foo(a);\r\n  }\r\n\r\nThis is valid since the mutable reference to bar is valid to be turned into\r\nan immutable reference without any conversion. Like in C a non-const\r\npointer is valid to be passed to a const pointer inferface.\r\n\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98fb902fb3029da33c5a8d2fd4bd7d7bcb7271ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98fb902fb3029da33c5a8d2fd4bd7d7bcb7271ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98fb902fb3029da33c5a8d2fd4bd7d7bcb7271ee/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "295f0ae16613b44c13a15ae5ada080761b62ff54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/295f0ae16613b44c13a15ae5ada080761b62ff54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/295f0ae16613b44c13a15ae5ada080761b62ff54"}, {"sha": "a2f59f14ceace0b8e614f972beacd45acfb284c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2f59f14ceace0b8e614f972beacd45acfb284c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2f59f14ceace0b8e614f972beacd45acfb284c7"}], "stats": {"total": 60, "additions": 48, "deletions": 12}, "files": [{"sha": "067ae2c0d9ed0e26b600fd92d25c223e7daff4e5", "filename": "gcc/rust/typecheck/rust-hir-dot-operator.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98fb902fb3029da33c5a8d2fd4bd7d7bcb7271ee/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98fb902fb3029da33c5a8d2fd4bd7d7bcb7271ee/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.h?ref=98fb902fb3029da33c5a8d2fd4bd7d7bcb7271ee", "patch": "@@ -115,7 +115,7 @@ class MethodResolution\n \t    if (fn->is_method ())\n \t      {\n \t\tTyTy::BaseType *fn_self = fn->get_self_type ();\n-\t\tif (receiver->can_eq (fn_self, false, true))\n+\t\tif (fn_self->can_eq (receiver, false, true))\n \t\t  {\n \t\t    return &c;\n \t\t  }\n@@ -143,7 +143,7 @@ class MethodResolution\n \t    if (fn->is_method ())\n \t      {\n \t\tTyTy::BaseType *fn_self = fn->get_self_type ();\n-\t\tif (receiver->can_eq (fn_self, false, true))\n+\t\tif (fn_self->can_eq (receiver, false, true))\n \t\t  {\n \t\t    return &c;\n \t\t  }\n@@ -165,7 +165,7 @@ class MethodResolution\n \t    if (fn->is_method ())\n \t      {\n \t\tTyTy::BaseType *fn_self = fn->get_self_type ();\n-\t\tif (receiver->can_eq (fn_self, false, true))\n+\t\tif (fn_self->can_eq (receiver, false, true))\n \t\t  {\n \t\t    return &c;\n \t\t  }"}, {"sha": "a23855ed7de6d0694ce51d27b59bf25b92ca2226", "filename": "gcc/rust/typecheck/rust-tyty-cmp.h", "status": "modified", "additions": 36, "deletions": 6, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98fb902fb3029da33c5a8d2fd4bd7d7bcb7271ee/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98fb902fb3029da33c5a8d2fd4bd7d7bcb7271ee/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h?ref=98fb902fb3029da33c5a8d2fd4bd7d7bcb7271ee", "patch": "@@ -1169,9 +1169,23 @@ class ReferenceCmp : public BaseCmp\n     auto base_type = base->get_base ();\n     auto other_base_type = type.get_base ();\n \n-    ok = base_type->can_eq (other_base_type, emit_error_flag,\n-\t\t\t    autoderef_mode_flag)\n-\t && (base->is_mutable () == type.is_mutable ());\n+    // rust is permissive about mutablity here you can always go from mutable to\n+    // immutable but not the otherway round\n+    bool mutability_ok = base->is_mutable () ? type.is_mutable () : true;\n+    if (!mutability_ok)\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    if (!base_type->can_eq (other_base_type, emit_error_flag,\n+\t\t\t    autoderef_mode_flag))\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    ok = true;\n   }\n \n private:\n@@ -1193,9 +1207,23 @@ class PointerCmp : public BaseCmp\n     auto base_type = base->get_base ();\n     auto other_base_type = type.get_base ();\n \n-    ok = base_type->can_eq (other_base_type, emit_error_flag,\n-\t\t\t    autoderef_mode_flag)\n-\t && (base->is_mutable () == type.is_mutable ());\n+    // rust is permissive about mutablity here you can always go from mutable to\n+    // immutable but not the otherway round\n+    bool mutability_ok = base->is_mutable () ? type.is_mutable () : true;\n+    if (!mutability_ok)\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    if (!base_type->can_eq (other_base_type, emit_error_flag,\n+\t\t\t    autoderef_mode_flag))\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    ok = true;\n   }\n \n private:\n@@ -1276,6 +1304,8 @@ class ParamCmp : public BaseCmp\n \n   void visit (const NeverType &) override { ok = true; }\n \n+  void visit (const DynamicObjectType &) override { ok = true; }\n+\n   void visit (const PlaceholderType &type) override\n   {\n     ok = base->get_symbol ().compare (type.get_symbol ()) == 0;"}, {"sha": "f044d0e8ebc83117da728d15c072f4206b53530d", "filename": "gcc/rust/typecheck/rust-tyty-rules.h", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98fb902fb3029da33c5a8d2fd4bd7d7bcb7271ee/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98fb902fb3029da33c5a8d2fd4bd7d7bcb7271ee/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h?ref=98fb902fb3029da33c5a8d2fd4bd7d7bcb7271ee", "patch": "@@ -1209,7 +1209,10 @@ class ReferenceRules : public BaseRules\n \treturn;\n       }\n \n-    if (base->is_mutable () != type.is_mutable ())\n+    // rust is permissive about mutablity here you can always go from mutable to\n+    // immutable but not the otherway round\n+    bool mutability_ok = base->is_mutable () ? type.is_mutable () : true;\n+    if (!mutability_ok)\n       {\n \tBaseRules::visit (type);\n \treturn;\n@@ -1246,7 +1249,10 @@ class PointerRules : public BaseRules\n \treturn;\n       }\n \n-    if (base->is_mutable () != type.is_mutable ())\n+    // rust is permissive about mutablity here you can always go from mutable to\n+    // immutable but not the otherway round\n+    bool mutability_ok = base->is_mutable () ? type.is_mutable () : true;\n+    if (!mutability_ok)\n       {\n \tBaseRules::visit (type);\n \treturn;"}, {"sha": "25fdfa9db79d8a5a8348fd624c39e723a4d21183", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98fb902fb3029da33c5a8d2fd4bd7d7bcb7271ee/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98fb902fb3029da33c5a8d2fd4bd7d7bcb7271ee/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=98fb902fb3029da33c5a8d2fd4bd7d7bcb7271ee", "patch": "@@ -2786,7 +2786,7 @@ TypeCheckCallExpr::visit (FnPtr &type)\n void\n TypeCheckMethodCallExpr::visit (FnType &type)\n {\n-  adjusted_self->unify (type.get_self_type ());\n+  type.get_self_type ()->unify (adjusted_self);\n \n   // +1 for the receiver self\n   size_t num_args_to_call = call.num_params () + 1;"}]}