{"sha": "19b63d8ecd5c81353990274b249fced229e89e24", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTliNjNkOGVjZDVjODEzNTM5OTAyNzRiMjQ5ZmNlZDIyOWU4OWUyNA==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2004-10-11T14:33:25Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2004-10-11T14:33:25Z"}, "message": "s390-protos.h (s390_offset_p): Add prototype.\n\n\t* config/s390/s390-protos.h (s390_offset_p): Add prototype.\n\t* config/s390/s390.c (s390_offset_p): New function.\n\t* config/s390/s390.md (\"*cmpdi_cct\", \"*cmpsi_cct\", \"*cmpdi_ccu\",\n\t\"*cmpsi_ccu\", \"*cmphi_ccu\", \"*cmpqi_ccu\"): Use splitter to\n\ttransform Q->Q alternatives to *clc pattern.\n\t(\"*clc\"): Move.\n\t(\"movti\", \"*movdi_64\", \"*movdi_31\", \"*movsi_zarch\", \"*movsi_esa\",\n\t\"*movhi\", \"*movqi\", \"*movdf_64\", \"*movdf_31\", \"movsf\"): Use splitter\n\tto transform Q->Q alternatives to *mvc pattern.\n\t(\"*mvc\"): Move.  Add peephole to merge adjacent MVCs.\n\t(\"*anddi3\", \"*andsi3_zarch\", \"*andsi3_esa\", \"*andhi3_zarch\",\n\t\"*andhi3_esa\", \"*andqi3_zarch\", \"*andqi3_esa\"): Use splitter to\n\ttransform Q->Q alternatives to *nc pattern.\n\t(\"*nc\"): New insn.  New peephole to merge adjacent NCs.\n\t(\"*iordi3\", \"*iorsi3_zarch\", \"*iorsi3_esa\", \"*iorhi3_zarch\",\n\t\"*iorhi3_esa\", \"*iorqi3_zarch\", \"*iorqi3_esa\"): Use splitter to\n\ttransform Q->Q alternatives to *oc pattern.\n\t(\"*oc\"): New insn.  New peephole to merge adjacent OCs.\n\t(\"*xordi3\", \"*xorsi3\", \"*xorhi3\", \"*xorqi3\"): Use splitter to\n\ttransform Q->Q alternatives to *xc pattern.\n\t(\"*xc\"): New insn.  New peephole to merge adjacent XCs.\n\t(\"*xc_zero\"): Move.  Add peephole to merge adjacent XCs.\n\nFrom-SVN: r88878", "tree": {"sha": "73793bb26b5f0d1250e680cf1948fbc556d401ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73793bb26b5f0d1250e680cf1948fbc556d401ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/19b63d8ecd5c81353990274b249fced229e89e24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19b63d8ecd5c81353990274b249fced229e89e24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19b63d8ecd5c81353990274b249fced229e89e24", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19b63d8ecd5c81353990274b249fced229e89e24/comments", "author": null, "committer": null, "parents": [{"sha": "d775bc45ed5f595f432deebf542d772d27399018", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d775bc45ed5f595f432deebf542d772d27399018", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d775bc45ed5f595f432deebf542d772d27399018"}], "stats": {"total": 433, "additions": 370, "deletions": 63}, "files": [{"sha": "4df3feab870e0d7ee11a5c290c54a725dbc08fd0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b63d8ecd5c81353990274b249fced229e89e24/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b63d8ecd5c81353990274b249fced229e89e24/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=19b63d8ecd5c81353990274b249fced229e89e24", "patch": "@@ -1,3 +1,28 @@\n+2004-10-11  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* config/s390/s390-protos.h (s390_offset_p): Add prototype.\n+\t* config/s390/s390.c (s390_offset_p): New function.\n+\t* config/s390/s390.md (\"*cmpdi_cct\", \"*cmpsi_cct\", \"*cmpdi_ccu\",\n+\t\"*cmpsi_ccu\", \"*cmphi_ccu\", \"*cmpqi_ccu\"): Use splitter to\n+\ttransform Q->Q alternatives to *clc pattern.\n+\t(\"*clc\"): Move.\n+\t(\"movti\", \"*movdi_64\", \"*movdi_31\", \"*movsi_zarch\", \"*movsi_esa\",\n+\t\"*movhi\", \"*movqi\", \"*movdf_64\", \"*movdf_31\", \"movsf\"): Use splitter\n+\tto transform Q->Q alternatives to *mvc pattern.\n+\t(\"*mvc\"): Move.  Add peephole to merge adjacent MVCs.\n+\t(\"*anddi3\", \"*andsi3_zarch\", \"*andsi3_esa\", \"*andhi3_zarch\",\n+\t\"*andhi3_esa\", \"*andqi3_zarch\", \"*andqi3_esa\"): Use splitter to\n+\ttransform Q->Q alternatives to *nc pattern.\n+\t(\"*nc\"): New insn.  New peephole to merge adjacent NCs.\n+\t(\"*iordi3\", \"*iorsi3_zarch\", \"*iorsi3_esa\", \"*iorhi3_zarch\",\n+\t\"*iorhi3_esa\", \"*iorqi3_zarch\", \"*iorqi3_esa\"): Use splitter to\n+\ttransform Q->Q alternatives to *oc pattern.\n+\t(\"*oc\"): New insn.  New peephole to merge adjacent OCs.\n+\t(\"*xordi3\", \"*xorsi3\", \"*xorhi3\", \"*xorqi3\"): Use splitter to\n+\ttransform Q->Q alternatives to *xc pattern.\n+\t(\"*xc\"): New insn.  New peephole to merge adjacent XCs.\n+\t(\"*xc_zero\"): Move.  Add peephole to merge adjacent XCs.\n+\n 2004-10-11  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \t* gimplify.c (gimple_push_condition): Make sure that we don't"}, {"sha": "4b405f27a2b1292e3b5c73e06c237b9f08d520a0", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b63d8ecd5c81353990274b249fced229e89e24/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b63d8ecd5c81353990274b249fced229e89e24/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=19b63d8ecd5c81353990274b249fced229e89e24", "patch": "@@ -44,6 +44,7 @@ extern int store_multiple_operation (rtx, enum machine_mode);\n extern int s390_single_part (rtx, enum machine_mode, enum machine_mode, int);\n extern unsigned HOST_WIDE_INT s390_extract_part (rtx, enum machine_mode, int);\n extern bool s390_split_ok_p (rtx, rtx, enum machine_mode, int);\n+extern bool s390_offset_p (rtx, rtx, rtx);\n extern int tls_symbolic_operand (rtx);\n \n extern int s390_match_ccmode (rtx, enum machine_mode);"}, {"sha": "2a65365e1f4c51d617352e55c70a8bc5d082c141", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b63d8ecd5c81353990274b249fced229e89e24/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b63d8ecd5c81353990274b249fced229e89e24/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=19b63d8ecd5c81353990274b249fced229e89e24", "patch": "@@ -1096,6 +1096,28 @@ s390_split_ok_p (rtx dst, rtx src, enum machine_mode mode, int first_subword)\n   return true;\n }\n \n+/* Check whether the address of memory reference MEM2 equals exactly\n+   the address of memory reference MEM1 plus DELTA.  Return true if\n+   we can prove this to be the case, false otherwise.  */\n+\n+bool\n+s390_offset_p (rtx mem1, rtx mem2, rtx delta)\n+{\n+  rtx addr1, addr2, addr_delta;\n+\n+  if (GET_CODE (mem1) != MEM || GET_CODE (mem2) != MEM)\n+    return false;\n+\n+  addr1 = XEXP (mem1, 0);\n+  addr2 = XEXP (mem2, 0);\n+\n+  addr_delta = simplify_binary_operation (MINUS, Pmode, addr2, addr1);\n+  if (!addr_delta || !rtx_equal_p (addr_delta, delta))\n+    return false;\n+\n+  return true;\n+}\n+\n /* Expand logical operator CODE in mode MODE with operands OPERANDS.  */\n \n void"}, {"sha": "8d4377906002768217184e43485b7128e36f7565", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 322, "deletions": 63, "changes": 385, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b63d8ecd5c81353990274b249fced229e89e24/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b63d8ecd5c81353990274b249fced229e89e24/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=19b63d8ecd5c81353990274b249fced229e89e24", "patch": "@@ -534,7 +534,7 @@\n    cghi\\t%0,%c1\n    cg\\t%0,%1\n    cg\\t%1,%0\n-   clc\\t%O0(8,%R0),%1\"\n+   #\"\n   [(set_attr \"op_type\" \"RRE,RI,RXY,RXY,SS\")])\n \n (define_insn \"*cmpsi_cct\"\n@@ -550,7 +550,7 @@\n    cy\\t%0,%1\n    c\\t%1,%0\n    cy\\t%1,%0\n-   clc\\t%O0(4,%R0),%1\"\n+   #\"\n   [(set_attr \"op_type\" \"RR,RI,RX,RXY,RX,RXY,SS\")])\n \n \n@@ -621,7 +621,7 @@\n   \"@\n    clgr\\t%0,%1\n    clg\\t%0,%1\n-   clc\\t%O0(8,%R0),%1\"\n+   #\"\n   [(set_attr \"op_type\" \"RRE,RXY,SS\")])\n \n (define_insn \"*cmpsi_ccu\"\n@@ -634,7 +634,7 @@\n    clr\\t%0,%1\n    cl\\t%0,%1\n    cly\\t%0,%1\n-   clc\\t%O0(4,%R0),%1\"\n+   #\"\n   [(set_attr \"op_type\" \"RR,RX,RXY,SS\")])\n \n (define_insn \"*cmphi_ccu\"\n@@ -647,7 +647,7 @@\n   \"@\n    clm\\t%0,3,%1\n    clmy\\t%0,3,%1\n-   clc\\t%O0(2,%R0),%1\"\n+   #\"\n   [(set_attr \"op_type\" \"RS,RSY,SS\")])\n \n (define_insn \"*cmpqi_ccu\"\n@@ -662,10 +662,45 @@\n    clmy\\t%0,1,%1\n    cli\\t%0,%b1\n    cliy\\t%0,%b1\n-   clc\\t%O0(1,%R0),%1\"\n+   #\"\n   [(set_attr \"op_type\" \"RS,RSY,SI,SIY,SS\")])\n \n \n+; Block compare (CLC) instruction patterns.\n+\n+(define_insn \"*clc\"\n+  [(set (reg 33)\n+        (compare (match_operand:BLK 0 \"memory_operand\" \"=Q\")\n+                 (match_operand:BLK 1 \"memory_operand\" \"Q\")))\n+   (use (match_operand 2 \"const_int_operand\" \"n\"))]\n+  \"s390_match_ccmode (insn, CCUmode)\n+   && INTVAL (operands[2]) >= 1 && INTVAL (operands[2]) <= 256\"\n+  \"clc\\t%O0(%2,%R0),%1\"\n+  [(set_attr \"op_type\" \"SS\")\n+   (set_attr \"type\"    \"cs\")])\n+\n+(define_split\n+  [(set (reg 33)\n+        (compare (match_operand 0 \"memory_operand\" \"\")\n+                 (match_operand 1 \"memory_operand\" \"\")))]\n+  \"reload_completed\n+   && s390_match_ccmode (insn, CCUmode)\n+   && GET_MODE (operands[0]) == GET_MODE (operands[1])\n+   && GET_MODE_SIZE (GET_MODE (operands[0])) > 0\"\n+  [(parallel\n+    [(set (match_dup 0) (match_dup 1))\n+     (use (match_dup 2))])]\n+{\n+  operands[2] = GEN_INT (GET_MODE_SIZE (GET_MODE (operands[0])));\n+  operands[0] = adjust_address (operands[0], BLKmode, 0);\n+  operands[1] = adjust_address (operands[1], BLKmode, 0);\n+\n+  operands[1] = gen_rtx_COMPARE (GET_MODE (SET_DEST (PATTERN (curr_insn))),\n+\t\t\t\t operands[0], operands[1]);\n+  operands[0] = SET_DEST (PATTERN (curr_insn));\n+})\n+\n+\n ; DF instructions\n \n (define_insn \"*cmpdf_ccs_0\"\n@@ -769,7 +804,7 @@\n    stmg\\t%1,%N1,%0\n    #\n    #\n-   mvc\\t%O0(16,%R0),%1\"\n+   #\"\n   [(set_attr \"op_type\" \"RSY,RSY,NN,NN,SS\")\n    (set_attr \"type\" \"lm,stm,*,*,cs\")])\n \n@@ -869,7 +904,7 @@\n    ldy\\t%0,%1\n    std\\t%1,%0\n    stdy\\t%1,%0\n-   mvc\\t%O0(8,%R0),%1\"\n+   #\"\n   [(set_attr \"op_type\" \"RI,RI,RI,RI,RI,RXY,RRE,RXY,RXY,RR,RX,RXY,RX,RXY,SS\")\n    (set_attr \"type\" \"*,*,*,*,*,la,lr,load,store,floadd,floadd,floadd,\n                      fstored,fstored,cs\")])\n@@ -888,7 +923,7 @@\n    ldy\\t%0,%1\n    std\\t%1,%0\n    stdy\\t%1,%0\n-   mvc\\t%O0(8,%R0),%1\"\n+   #\"\n   [(set_attr \"op_type\" \"RS,RS,NN,NN,RR,RX,RXY,RX,RXY,SS\")\n    (set_attr \"type\" \"lm,stm,*,*,floadd,floadd,floadd,fstored,fstored,cs\")])\n \n@@ -1045,7 +1080,7 @@\n    ley\\t%0,%1\n    ste\\t%1,%0\n    stey\\t%1,%0\n-   mvc\\t%O0(4,%R0),%1\"\n+   #\"\n   [(set_attr \"op_type\" \"RI,RI,RI,RXY,RR,RX,RXY,RX,RXY,RR,RX,RXY,RX,RXY,SS\")\n    (set_attr \"type\" \"*,*,*,la,lr,load,load,store,store,floads,floads,floads,fstores,fstores,cs\")])\n \n@@ -1061,7 +1096,7 @@\n    ler\\t%0,%1\n    le\\t%0,%1\n    ste\\t%1,%0\n-   mvc\\t%O0(4,%R0),%1\"\n+   #\"\n   [(set_attr \"op_type\" \"RI,RR,RX,RX,RR,RX,RX,SS\")\n    (set_attr \"type\" \"*,lr,load,store,floads,floads,fstores,cs\")])\n \n@@ -1189,7 +1224,7 @@\n    lhy\\t%0,%1\n    sth\\t%1,%0\n    sthy\\t%1,%0\n-   mvc\\t%O0(2,%R0),%1\"\n+   #\"\n   [(set_attr \"op_type\" \"RR,RI,RX,RXY,RX,RXY,SS\")\n    (set_attr \"type\" \"lr,*,*,*,store,store,cs\")])\n \n@@ -1238,7 +1273,7 @@\n    stcy\\t%1,%0\n    mvi\\t%0,%b1\n    mviy\\t%0,%b1\n-   mvc\\t%O0(1,%R0),%1\"\n+   #\"\n   [(set_attr \"op_type\" \"RR,RI,RX,RXY,RX,RXY,SI,SIY,SS\")\n    (set_attr \"type\" \"lr,*,*,*,store,store,store,store,cs\")])\n \n@@ -1317,7 +1352,7 @@\n    lgr\\t%0,%1\n    lg\\t%0,%1\n    stg\\t%1,%0\n-   mvc\\t%O0(8,%R0),%1\"\n+   #\"\n   [(set_attr \"op_type\" \"RR,RX,RXY,RX,RXY,RRE,RXY,RXY,SS\")\n    (set_attr \"type\" \"floadd,floadd,floadd,fstored,fstored,lr,load,store,cs\")])\n \n@@ -1335,7 +1370,7 @@\n    stm\\t%1,%N1,%0\n    #\n    #\n-   mvc\\t%O0(8,%R0),%1\"\n+   #\"\n   [(set_attr \"op_type\" \"RR,RX,RXY,RX,RXY,RS,RS,NN,NN,SS\")\n    (set_attr \"type\" \"floadd,floadd,floadd,fstored,fstored,lm,stm,*,*,cs\")])\n \n@@ -1411,10 +1446,58 @@\n    ly\\t%0,%1\n    st\\t%1,%0\n    sty\\t%1,%0\n-   mvc\\t%O0(4,%R0),%1\"\n+   #\"\n   [(set_attr \"op_type\" \"RR,RX,RXY,RX,RXY,RR,RX,RXY,RX,RXY,SS\")\n    (set_attr \"type\" \"floads,floads,floads,fstores,fstores,lr,load,load,store,store,cs\")])\n \n+;\n+; Block move (MVC) patterns.\n+;\n+\n+(define_insn \"*mvc\"\n+  [(set (match_operand:BLK 0 \"memory_operand\" \"=Q\")\n+        (match_operand:BLK 1 \"memory_operand\" \"Q\"))\n+   (use (match_operand 2 \"const_int_operand\" \"n\"))]\n+  \"INTVAL (operands[2]) >= 1 && INTVAL (operands[2]) <= 256\"\n+  \"mvc\\t%O0(%2,%R0),%1\"\n+  [(set_attr \"op_type\" \"SS\")\n+   (set_attr \"type\"    \"cs\")])\n+\n+(define_split\n+  [(set (match_operand 0 \"memory_operand\" \"\")\n+        (match_operand 1 \"memory_operand\" \"\"))]\n+  \"reload_completed\n+   && GET_MODE (operands[0]) == GET_MODE (operands[1])\n+   && GET_MODE_SIZE (GET_MODE (operands[0])) > 0\"\n+  [(parallel\n+    [(set (match_dup 0) (match_dup 1))\n+     (use (match_dup 2))])]\n+{\n+  operands[2] = GEN_INT (GET_MODE_SIZE (GET_MODE (operands[0])));\n+  operands[0] = adjust_address (operands[0], BLKmode, 0);\n+  operands[1] = adjust_address (operands[1], BLKmode, 0);\n+})\n+\n+(define_peephole2\n+  [(parallel\n+    [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n+          (match_operand:BLK 1 \"memory_operand\" \"\"))\n+     (use (match_operand 2 \"const_int_operand\" \"\"))])\n+   (parallel\n+    [(set (match_operand:BLK 3 \"memory_operand\" \"\")\n+          (match_operand:BLK 4 \"memory_operand\" \"\"))\n+     (use (match_operand 5 \"const_int_operand\" \"\"))])]\n+  \"s390_offset_p (operands[0], operands[3], operands[2])\n+   && s390_offset_p (operands[1], operands[4], operands[2])\n+   && INTVAL (operands[2]) + INTVAL (operands[5]) <= 256\"\n+  [(parallel\n+    [(set (match_dup 6) (match_dup 7))\n+     (use (match_dup 8))])]\n+  \"operands[6] = gen_rtx_MEM (BLKmode, XEXP (operands[0], 0));\n+   operands[7] = gen_rtx_MEM (BLKmode, XEXP (operands[1], 0));\n+   operands[8] = GEN_INT (INTVAL (operands[2]) + INTVAL (operands[5]));\")\n+\n+\n ;\n ; load_multiple pattern(s).\n ;\n@@ -1776,15 +1859,6 @@\n      (use (const_int 1))])]\n   \"operands[4] = gen_label_rtx ();\")\n \n-(define_insn \"*mvc\"\n-  [(set (match_operand:BLK 0 \"memory_operand\" \"=Q\")\n-        (match_operand:BLK 1 \"memory_operand\" \"Q\"))\n-   (use (match_operand 2 \"const_int_operand\" \"n\"))]\n-  \"\"\n-  \"mvc\\t%O0(%2,%R0),%1\"\n-  [(set_attr \"op_type\" \"SS\")\n-   (set_attr \"type\"    \"cs\")])\n-\n ; Move a block of arbitrary length.\n \n (define_expand \"movmem_long\"\n@@ -1942,16 +2016,6 @@\n      (clobber (reg:CC 33))])]\n   \"operands[3] = gen_label_rtx ();\")\n \n-(define_insn \"*xc_zero\"\n-  [(set (match_operand:BLK 0 \"memory_operand\" \"=Q\")\n-        (const_int 0))\n-   (use (match_operand 1 \"const_int_operand\" \"n\"))\n-   (clobber (reg:CC 33))]\n-  \"\"\n-  \"xc\\t%O0(%1,%R0),%0\"\n-  [(set_attr \"op_type\" \"SS\")\n-   (set_attr \"type\"    \"cs\")])\n-\n ; Clear a block of arbitrary length.\n \n (define_expand \"clrmem_long\"\n@@ -2092,16 +2156,6 @@\n      (use (const_int 1))])]\n   \"operands[4] = gen_label_rtx ();\")\n \n-(define_insn \"*clc\"\n-  [(set (reg:CCU 33)\n-        (compare:CCU (match_operand:BLK 0 \"memory_operand\" \"=Q\")\n-                     (match_operand:BLK 1 \"memory_operand\" \"Q\")))\n-   (use (match_operand 2 \"const_int_operand\" \"n\"))]\n-  \"\"\n-  \"clc\\t%O0(%2,%R0),%1\"\n-  [(set_attr \"op_type\" \"SS\")\n-   (set_attr \"type\"    \"cs\")])\n-\n ; Compare a block of arbitrary length.\n \n (define_expand \"cmpmem_long\"\n@@ -5155,7 +5209,7 @@\n    ngr\\t%0,%2\n    ng\\t%0,%2\n    #\n-   nc\\t%O0(8,%R0),%2\"\n+   #\"\n   [(set_attr \"op_type\" \"RRE,RXE,RI,RI,RI,RI,RRE,RXY,SI,SS\")])\n \n (define_split\n@@ -5226,7 +5280,7 @@\n    n\\t%0,%2\n    ny\\t%0,%2\n    #\n-   nc\\t%O0(4,%R0),%2\"\n+   #\"\n   [(set_attr \"op_type\"  \"RRE,RXE,RI,RI,RR,RX,RXY,SI,SS\")])\n \n (define_insn \"*andsi3_esa\"\n@@ -5239,7 +5293,7 @@\n    nr\\t%0,%2\n    n\\t%0,%2\n    #\n-   nc\\t%O0(4,%R0),%2\"\n+   #\"\n   [(set_attr \"op_type\"  \"RR,RX,SI,SS\")])\n \n (define_split\n@@ -5274,7 +5328,7 @@\n    nr\\t%0,%2\n    nill\\t%0,%x2\n    #\n-   nc\\t%O0(2,%R0),%2\"\n+   #\"\n   [(set_attr \"op_type\"  \"RR,RI,SI,SS\")])\n \n (define_insn \"*andhi3_esa\"\n@@ -5286,7 +5340,7 @@\n   \"@\n    nr\\t%0,%2\n    #\n-   nc\\t%O0(2,%R0),%2\"\n+   #\"\n   [(set_attr \"op_type\"  \"RR,SI,SS\")])\n \n (define_split\n@@ -5322,7 +5376,7 @@\n    nill\\t%0,%b2\n    ni\\t%0,%b2\n    niy\\t%0,%b2\n-   nc\\t%O0(1,%R0),%2\"\n+   #\"\n   [(set_attr \"op_type\"  \"RR,RI,SI,SIY,SS\")])\n \n (define_insn \"*andqi3_esa\"\n@@ -5334,7 +5388,7 @@\n   \"@\n    nr\\t%0,%2\n    ni\\t%0,%b2\n-   nc\\t%O0(1,%R0),%2\"\n+   #\"\n   [(set_attr \"op_type\"  \"RR,SI,SS\")])\n \n (define_expand \"andqi3\"\n@@ -5345,6 +5399,63 @@\n   \"\"\n   \"s390_expand_logical_operator (AND, QImode, operands); DONE;\")\n \n+;\n+; Block and (NC) patterns.\n+;\n+\n+(define_insn \"*nc\"\n+  [(set (match_operand:BLK 0 \"memory_operand\" \"=Q\")\n+        (and:BLK (match_dup 0)\n+                 (match_operand:BLK 1 \"memory_operand\" \"Q\")))\n+   (use (match_operand 2 \"const_int_operand\" \"n\"))\n+   (clobber (reg:CC 33))]\n+  \"INTVAL (operands[2]) >= 1 && INTVAL (operands[2]) <= 256\"\n+  \"nc\\t%O0(%2,%R0),%1\"\n+  [(set_attr \"op_type\" \"SS\")\n+   (set_attr \"type\"    \"cs\")])\n+\n+(define_split\n+  [(set (match_operand 0 \"memory_operand\" \"\")\n+        (and (match_dup 0)\n+             (match_operand 1 \"memory_operand\" \"\")))\n+   (clobber (reg:CC 33))]\n+  \"reload_completed\n+   && GET_MODE (operands[0]) == GET_MODE (operands[1])\n+   && GET_MODE_SIZE (GET_MODE (operands[0])) > 0\"\n+  [(parallel\n+    [(set (match_dup 0) (and:BLK (match_dup 0) (match_dup 1)))\n+     (use (match_dup 2))\n+     (clobber (reg:CC 33))])]\n+{\n+  operands[2] = GEN_INT (GET_MODE_SIZE (GET_MODE (operands[0])));\n+  operands[0] = adjust_address (operands[0], BLKmode, 0);\n+  operands[1] = adjust_address (operands[1], BLKmode, 0);\n+})\n+\n+(define_peephole2\n+  [(parallel\n+    [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n+          (and:BLK (match_dup 0)\n+                   (match_operand:BLK 1 \"memory_operand\" \"\")))\n+     (use (match_operand 2 \"const_int_operand\" \"\"))\n+     (clobber (reg:CC 33))])\n+   (parallel\n+    [(set (match_operand:BLK 3 \"memory_operand\" \"\")\n+          (and:BLK (match_dup 3)\n+                   (match_operand:BLK 4 \"memory_operand\" \"\")))\n+     (use (match_operand 5 \"const_int_operand\" \"\"))\n+     (clobber (reg:CC 33))])]\n+  \"s390_offset_p (operands[0], operands[3], operands[2])\n+   && s390_offset_p (operands[1], operands[4], operands[2])\n+   && INTVAL (operands[2]) + INTVAL (operands[5]) <= 256\"\n+  [(parallel\n+    [(set (match_dup 6) (and:BLK (match_dup 6) (match_dup 7)))\n+     (use (match_dup 8))\n+     (clobber (reg:CC 33))])]\n+  \"operands[6] = gen_rtx_MEM (BLKmode, XEXP (operands[0], 0));\n+   operands[7] = gen_rtx_MEM (BLKmode, XEXP (operands[1], 0));\n+   operands[8] = GEN_INT (INTVAL (operands[2]) + INTVAL (operands[5]));\")\n+\n \n ;;\n ;;- Bit set (inclusive or) instructions.\n@@ -5394,7 +5505,7 @@\n    ogr\\t%0,%2\n    og\\t%0,%2\n    #\n-   oc\\t%O0(8,%R0),%2\"\n+   #\"\n   [(set_attr \"op_type\"  \"RI,RI,RI,RI,RRE,RXY,SI,SS\")])\n \n (define_split\n@@ -5459,7 +5570,7 @@\n    o\\t%0,%2\n    oy\\t%0,%2\n    #\n-   oc\\t%O0(4,%R0),%2\"\n+   #\"\n   [(set_attr \"op_type\"  \"RI,RI,RR,RX,RXY,SI,SS\")])\n \n (define_insn \"*iorsi3_esa\"\n@@ -5472,7 +5583,7 @@\n    or\\t%0,%2\n    o\\t%0,%2\n    #\n-   oc\\t%O0(4,%R0),%2\"\n+   #\"\n   [(set_attr \"op_type\"  \"RR,RX,SI,SS\")])\n \n (define_split\n@@ -5507,7 +5618,7 @@\n    or\\t%0,%2\n    oill\\t%0,%x2\n    #\n-   oc\\t%O0(2,%R0),%2\"\n+   #\"\n   [(set_attr \"op_type\"  \"RR,RI,SI,SS\")])\n \n (define_insn \"*iorhi3_esa\"\n@@ -5519,7 +5630,7 @@\n   \"@\n    or\\t%0,%2\n    #\n-   oc\\t%O0(2,%R0),%2\"\n+   #\"\n   [(set_attr \"op_type\"  \"RR,SI,SS\")])\n \n (define_split\n@@ -5555,7 +5666,7 @@\n    oill\\t%0,%b2\n    oi\\t%0,%b2\n    oiy\\t%0,%b2\n-   oc\\t%O0(1,%R0),%2\"\n+   #\"\n   [(set_attr \"op_type\"  \"RR,RI,SI,SIY,SS\")])\n \n (define_insn \"*iorqi3_esa\"\n@@ -5567,7 +5678,7 @@\n   \"@\n    or\\t%0,%2\n    oi\\t%0,%b2\n-   oc\\t%O0(1,%R0),%2\"\n+   #\"\n   [(set_attr \"op_type\"  \"RR,SI,SS\")])\n \n (define_expand \"iorqi3\"\n@@ -5578,6 +5689,63 @@\n   \"\"\n   \"s390_expand_logical_operator (IOR, QImode, operands); DONE;\")\n \n+;\n+; Block inclusive or (OC) patterns.\n+;\n+\n+(define_insn \"*oc\"\n+  [(set (match_operand:BLK 0 \"memory_operand\" \"=Q\")\n+        (ior:BLK (match_dup 0)\n+                 (match_operand:BLK 1 \"memory_operand\" \"Q\")))\n+   (use (match_operand 2 \"const_int_operand\" \"n\"))\n+   (clobber (reg:CC 33))]\n+  \"INTVAL (operands[2]) >= 1 && INTVAL (operands[2]) <= 256\"\n+  \"oc\\t%O0(%2,%R0),%1\"\n+  [(set_attr \"op_type\" \"SS\")\n+   (set_attr \"type\"    \"cs\")])\n+\n+(define_split\n+  [(set (match_operand 0 \"memory_operand\" \"\")\n+        (ior (match_dup 0)\n+             (match_operand 1 \"memory_operand\" \"\")))\n+   (clobber (reg:CC 33))]\n+  \"reload_completed\n+   && GET_MODE (operands[0]) == GET_MODE (operands[1])\n+   && GET_MODE_SIZE (GET_MODE (operands[0])) > 0\"\n+  [(parallel\n+    [(set (match_dup 0) (ior:BLK (match_dup 0) (match_dup 1)))\n+     (use (match_dup 2))\n+     (clobber (reg:CC 33))])]\n+{\n+  operands[2] = GEN_INT (GET_MODE_SIZE (GET_MODE (operands[0])));\n+  operands[0] = adjust_address (operands[0], BLKmode, 0);\n+  operands[1] = adjust_address (operands[1], BLKmode, 0);\n+})\n+\n+(define_peephole2\n+  [(parallel\n+    [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n+          (ior:BLK (match_dup 0)\n+                   (match_operand:BLK 1 \"memory_operand\" \"\")))\n+     (use (match_operand 2 \"const_int_operand\" \"\"))\n+     (clobber (reg:CC 33))])\n+   (parallel\n+    [(set (match_operand:BLK 3 \"memory_operand\" \"\")\n+          (ior:BLK (match_dup 3)\n+                   (match_operand:BLK 4 \"memory_operand\" \"\")))\n+     (use (match_operand 5 \"const_int_operand\" \"\"))\n+     (clobber (reg:CC 33))])]\n+  \"s390_offset_p (operands[0], operands[3], operands[2])\n+   && s390_offset_p (operands[1], operands[4], operands[2])\n+   && INTVAL (operands[2]) + INTVAL (operands[5]) <= 256\"\n+  [(parallel\n+    [(set (match_dup 6) (ior:BLK (match_dup 6) (match_dup 7)))\n+     (use (match_dup 8))\n+     (clobber (reg:CC 33))])]\n+  \"operands[6] = gen_rtx_MEM (BLKmode, XEXP (operands[0], 0));\n+   operands[7] = gen_rtx_MEM (BLKmode, XEXP (operands[1], 0));\n+   operands[8] = GEN_INT (INTVAL (operands[2]) + INTVAL (operands[5]));\")\n+\n \n ;;\n ;;- Xor instructions.\n@@ -5622,7 +5790,7 @@\n    xgr\\t%0,%2\n    xg\\t%0,%2\n    #\n-   xc\\t%O0(8,%R0),%2\"\n+   #\"\n   [(set_attr \"op_type\"  \"RRE,RXY,SI,SS\")])\n \n (define_split\n@@ -5685,7 +5853,7 @@\n    x\\t%0,%2\n    xy\\t%0,%2\n    #\n-   xc\\t%O0(4,%R0),%2\"\n+   #\"\n   [(set_attr \"op_type\"  \"RR,RX,RXY,SI,SS\")])\n \n (define_split\n@@ -5719,7 +5887,7 @@\n   \"@\n    xr\\t%0,%2\n    #\n-   xc\\t%O0(2,%R0),%2\"\n+   #\"\n   [(set_attr \"op_type\"  \"RR,SI,SS\")])\n \n (define_split\n@@ -5754,7 +5922,7 @@\n    xr\\t%0,%2\n    xi\\t%0,%b2\n    xiy\\t%0,%b2\n-   xc\\t%O0(1,%R0),%2\"\n+   #\"\n   [(set_attr \"op_type\"  \"RR,SI,SIY,SS\")])\n \n (define_expand \"xorqi3\"\n@@ -5765,6 +5933,97 @@\n   \"\"\n   \"s390_expand_logical_operator (XOR, QImode, operands); DONE;\")\n \n+;\n+; Block exclusive or (XC) patterns.\n+;\n+\n+(define_insn \"*xc\"\n+  [(set (match_operand:BLK 0 \"memory_operand\" \"=Q\")\n+        (xor:BLK (match_dup 0)\n+                 (match_operand:BLK 1 \"memory_operand\" \"Q\")))\n+   (use (match_operand 2 \"const_int_operand\" \"n\"))\n+   (clobber (reg:CC 33))]\n+  \"INTVAL (operands[2]) >= 1 && INTVAL (operands[2]) <= 256\"\n+  \"xc\\t%O0(%2,%R0),%1\"\n+  [(set_attr \"op_type\" \"SS\")\n+   (set_attr \"type\"    \"cs\")])\n+\n+(define_split\n+  [(set (match_operand 0 \"memory_operand\" \"\")\n+        (xor (match_dup 0)\n+             (match_operand 1 \"memory_operand\" \"\")))\n+   (clobber (reg:CC 33))]\n+  \"reload_completed\n+   && GET_MODE (operands[0]) == GET_MODE (operands[1])\n+   && GET_MODE_SIZE (GET_MODE (operands[0])) > 0\"\n+  [(parallel\n+    [(set (match_dup 0) (xor:BLK (match_dup 0) (match_dup 1)))\n+     (use (match_dup 2))\n+     (clobber (reg:CC 33))])]\n+{\n+  operands[2] = GEN_INT (GET_MODE_SIZE (GET_MODE (operands[0])));\n+  operands[0] = adjust_address (operands[0], BLKmode, 0);\n+  operands[1] = adjust_address (operands[1], BLKmode, 0);\n+})\n+\n+(define_peephole2\n+  [(parallel\n+    [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n+          (xor:BLK (match_dup 0)\n+                   (match_operand:BLK 1 \"memory_operand\" \"\")))\n+     (use (match_operand 2 \"const_int_operand\" \"\"))\n+     (clobber (reg:CC 33))])\n+   (parallel\n+    [(set (match_operand:BLK 3 \"memory_operand\" \"\")\n+          (xor:BLK (match_dup 3)\n+                   (match_operand:BLK 4 \"memory_operand\" \"\")))\n+     (use (match_operand 5 \"const_int_operand\" \"\"))\n+     (clobber (reg:CC 33))])]\n+  \"s390_offset_p (operands[0], operands[3], operands[2])\n+   && s390_offset_p (operands[1], operands[4], operands[2])\n+   && INTVAL (operands[2]) + INTVAL (operands[5]) <= 256\"\n+  [(parallel\n+    [(set (match_dup 6) (xor:BLK (match_dup 6) (match_dup 7)))\n+     (use (match_dup 8))\n+     (clobber (reg:CC 33))])]\n+  \"operands[6] = gen_rtx_MEM (BLKmode, XEXP (operands[0], 0));\n+   operands[7] = gen_rtx_MEM (BLKmode, XEXP (operands[1], 0));\n+   operands[8] = GEN_INT (INTVAL (operands[2]) + INTVAL (operands[5]));\")\n+\n+;\n+; Block xor (XC) patterns with src == dest.\n+;\n+\n+(define_insn \"*xc_zero\"\n+  [(set (match_operand:BLK 0 \"memory_operand\" \"=Q\")\n+        (const_int 0))\n+   (use (match_operand 1 \"const_int_operand\" \"n\"))\n+   (clobber (reg:CC 33))]\n+  \"INTVAL (operands[1]) >= 1 && INTVAL (operands[1]) <= 256\"\n+  \"xc\\t%O0(%1,%R0),%0\"\n+  [(set_attr \"op_type\" \"SS\")\n+   (set_attr \"type\"    \"cs\")])\n+\n+(define_peephole2\n+  [(parallel\n+    [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n+          (const_int 0))\n+     (use (match_operand 1 \"const_int_operand\" \"\"))\n+     (clobber (reg:CC 33))])\n+   (parallel\n+    [(set (match_operand:BLK 2 \"memory_operand\" \"\")\n+          (const_int 0))\n+     (use (match_operand 3 \"const_int_operand\" \"\"))\n+     (clobber (reg:CC 33))])]\n+  \"s390_offset_p (operands[0], operands[2], operands[1])\n+   && INTVAL (operands[1]) + INTVAL (operands[3]) <= 256\"\n+  [(parallel\n+    [(set (match_dup 4) (const_int 0))\n+     (use (match_dup 5))\n+     (clobber (reg:CC 33))])]\n+  \"operands[4] = gen_rtx_MEM (BLKmode, XEXP (operands[0], 0));\n+   operands[5] = GEN_INT (INTVAL (operands[1]) + INTVAL (operands[3]));\")\n+\n \n ;;\n ;;- Negate instructions."}]}