{"sha": "c590597c45948c6e6fa282878198fd226da95998", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzU5MDU5N2M0NTk0OGM2ZTZmYTI4Mjg3ODE5OGZkMjI2ZGE5NTk5OA==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2019-01-25T17:09:33Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2019-01-25T17:09:33Z"}, "message": "This is pretty unlikely in real code...\n\nThis is pretty unlikely in real code, but similar to Arm, the AArch64\nABI has a bug with the handling of 128-bit bit-fields, where if the\nbit-field dominates the overall alignment the back-end code may end up\npassing the argument correctly.  This is a regression that started in\ngcc-6 when the ABI support code was updated to support overaligned\ntypes.  The fix is very similar in concept to the Arm fix.  128-bit\nbit-fields are fortunately extremely rare, so I'd be very surprised if\nanyone has been bitten by this.\n\nPR target/88469\ngcc/\n\t* config/aarch64/aarch64.c (aarch64_function_arg_alignment): Add new\n\targument ABI_BREAK.  Set to true if the calculated alignment has\n\tchanged in gcc-9.  Check bit-fields for their base type alignment.\n\t(aarch64_layout_arg): Warn if argument passing has changed in gcc-9.\n\t(aarch64_function_arg_boundary): Likewise.\n\t(aarch64_gimplify_va_arg_expr): Likewise.\n\ngcc/testsuite/\n\t* gcc.target/aarch64/aapcs64/test_align-10.c: New test.\n\t* gcc.target/aarch64/aapcs64/test_align-11.c: New test.\n\t* gcc.target/aarch64/aapcs64/test_align-12.c: New test.\n\nFrom-SVN: r268273", "tree": {"sha": "59ba839dbbd2a98b9c31f9c29d59da3b5b69ad4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59ba839dbbd2a98b9c31f9c29d59da3b5b69ad4a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c590597c45948c6e6fa282878198fd226da95998", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c590597c45948c6e6fa282878198fd226da95998", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c590597c45948c6e6fa282878198fd226da95998", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c590597c45948c6e6fa282878198fd226da95998/comments", "author": null, "committer": null, "parents": [{"sha": "3c35efc322f7ff8d25b81cf9ebc01d0ec202bb89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c35efc322f7ff8d25b81cf9ebc01d0ec202bb89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c35efc322f7ff8d25b81cf9ebc01d0ec202bb89"}], "stats": {"total": 222, "additions": 208, "deletions": 14}, "files": [{"sha": "4b8b1bd1c879dcf594b48e71749932369c90738f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c590597c45948c6e6fa282878198fd226da95998/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c590597c45948c6e6fa282878198fd226da95998/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c590597c45948c6e6fa282878198fd226da95998", "patch": "@@ -1,3 +1,13 @@\n+2019-01-25  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\tPR target/88469\n+\t* config/aarch64/aarch64.c (aarch64_function_arg_alignment): Add new\n+\targument ABI_BREAK.  Set to true if the calculated alignment has\n+\tchanged in gcc-9.  Check bit-fields for their base type alignment.\n+\t(aarch64_layout_arg): Warn if argument passing has changed in gcc-9.\n+\t(aarch64_function_arg_boundary): Likewise.\n+\t(aarch64_gimplify_va_arg_expr): Likewise.\n+\n 2019-01-25  Richard Sandiford  <richard.sandiford@arm.com>\n \n \tPR middle-end/89037"}, {"sha": "d7c453cdad047ddafc3c1a6d4296a74b84b32f91", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 58, "deletions": 14, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c590597c45948c6e6fa282878198fd226da95998/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c590597c45948c6e6fa282878198fd226da95998/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=c590597c45948c6e6fa282878198fd226da95998", "patch": "@@ -3765,12 +3765,16 @@ aarch64_vfp_is_call_candidate (cumulative_args_t pcum_v, machine_mode mode,\n \n /* Given MODE and TYPE of a function argument, return the alignment in\n    bits.  The idea is to suppress any stronger alignment requested by\n-   the user and opt for the natural alignment (specified in AAPCS64 \\S 4.1).\n-   This is a helper function for local use only.  */\n+   the user and opt for the natural alignment (specified in AAPCS64 \\S\n+   4.1).  ABI_BREAK is set to true if the alignment was incorrectly\n+   calculated in versions of GCC prior to GCC-9.  This is a helper\n+   function for local use only.  */\n \n static unsigned int\n-aarch64_function_arg_alignment (machine_mode mode, const_tree type)\n+aarch64_function_arg_alignment (machine_mode mode, const_tree type,\n+\t\t\t\tbool *abi_break)\n {\n+  *abi_break = false;\n   if (!type)\n     return GET_MODE_ALIGNMENT (mode);\n \n@@ -3786,9 +3790,22 @@ aarch64_function_arg_alignment (machine_mode mode, const_tree type)\n     return TYPE_ALIGN (TREE_TYPE (type));\n \n   unsigned int alignment = 0;\n+  unsigned int bitfield_alignment = 0;\n   for (tree field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n     if (TREE_CODE (field) == FIELD_DECL)\n-      alignment = std::max (alignment, DECL_ALIGN (field));\n+      {\n+\talignment = std::max (alignment, DECL_ALIGN (field));\n+\tif (DECL_BIT_FIELD_TYPE (field))\n+\t  bitfield_alignment\n+\t    = std::max (bitfield_alignment,\n+\t\t\tTYPE_ALIGN (DECL_BIT_FIELD_TYPE (field)));\n+      }\n+\n+  if (bitfield_alignment > alignment)\n+    {\n+      *abi_break = true;\n+      return bitfield_alignment;\n+    }\n \n   return alignment;\n }\n@@ -3805,6 +3822,7 @@ aarch64_layout_arg (cumulative_args_t pcum_v, machine_mode mode,\n   int ncrn, nvrn, nregs;\n   bool allocate_ncrn, allocate_nvrn;\n   HOST_WIDE_INT size;\n+  bool abi_break;\n \n   /* We need to do this once per argument.  */\n   if (pcum->aapcs_arg_processed)\n@@ -3881,25 +3899,28 @@ aarch64_layout_arg (cumulative_args_t pcum_v, machine_mode mode,\n      entirely general registers.  */\n   if (allocate_ncrn && (ncrn + nregs <= NUM_ARG_REGS))\n     {\n-\n       gcc_assert (nregs == 0 || nregs == 1 || nregs == 2);\n \n       /* C.8 if the argument has an alignment of 16 then the NGRN is\n-         rounded up to the next even number.  */\n+\t rounded up to the next even number.  */\n       if (nregs == 2\n \t  && ncrn % 2\n \t  /* The == 16 * BITS_PER_UNIT instead of >= 16 * BITS_PER_UNIT\n \t     comparison is there because for > 16 * BITS_PER_UNIT\n \t     alignment nregs should be > 2 and therefore it should be\n \t     passed by reference rather than value.  */\n-\t  && aarch64_function_arg_alignment (mode, type) == 16 * BITS_PER_UNIT)\n+\t  && (aarch64_function_arg_alignment (mode, type, &abi_break)\n+\t      == 16 * BITS_PER_UNIT))\n \t{\n+\t  if (abi_break && warn_psabi && currently_expanding_gimple_stmt)\n+\t    inform (input_location, \"parameter passing for argument of type \"\n+\t\t    \"%qT changed in GCC 9.1\", type);\n \t  ++ncrn;\n \t  gcc_assert (ncrn + nregs <= NUM_ARG_REGS);\n \t}\n \n       /* NREGS can be 0 when e.g. an empty structure is to be passed.\n-         A reg is still generated for it, but the caller should be smart\n+\t A reg is still generated for it, but the caller should be smart\n \t enough not to use it.  */\n       if (nregs == 0 || nregs == 1 || GET_MODE_CLASS (mode) == MODE_INT)\n \tpcum->aapcs_reg = gen_rtx_REG (mode, R0_REGNUM + ncrn);\n@@ -3931,9 +3952,18 @@ aarch64_layout_arg (cumulative_args_t pcum_v, machine_mode mode,\n on_stack:\n   pcum->aapcs_stack_words = size / UNITS_PER_WORD;\n \n-  if (aarch64_function_arg_alignment (mode, type) == 16 * BITS_PER_UNIT)\n-    pcum->aapcs_stack_size = ROUND_UP (pcum->aapcs_stack_size,\n-\t\t\t\t       16 / UNITS_PER_WORD);\n+  if (aarch64_function_arg_alignment (mode, type, &abi_break)\n+      == 16 * BITS_PER_UNIT)\n+    {\n+      int new_size = ROUND_UP (pcum->aapcs_stack_size, 16 / UNITS_PER_WORD);\n+      if (pcum->aapcs_stack_size != new_size)\n+\t{\n+\t  if (abi_break && warn_psabi && currently_expanding_gimple_stmt)\n+\t    inform (input_location, \"parameter passing for argument of type \"\n+\t\t    \"%qT changed in GCC 9.1\", type);\n+\t  pcum->aapcs_stack_size = new_size;\n+\t}\n+    }\n   return;\n }\n \n@@ -4022,7 +4052,13 @@ aarch64_function_arg_regno_p (unsigned regno)\n static unsigned int\n aarch64_function_arg_boundary (machine_mode mode, const_tree type)\n {\n-  unsigned int alignment = aarch64_function_arg_alignment (mode, type);\n+  bool abi_break;\n+  unsigned int alignment = aarch64_function_arg_alignment (mode, type,\n+\t\t\t\t\t\t\t   &abi_break);\n+  if (abi_break & warn_psabi)\n+    inform (input_location, \"parameter passing for argument of type \"\n+\t    \"%qT changed in GCC 9.1\", type);\n+\n   return MIN (MAX (alignment, PARM_BOUNDARY), STACK_BOUNDARY);\n }\n \n@@ -13320,7 +13356,10 @@ aarch64_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n   stack = build3 (COMPONENT_REF, TREE_TYPE (f_stack), unshare_expr (valist),\n \t\t  f_stack, NULL_TREE);\n   size = int_size_in_bytes (type);\n-  align = aarch64_function_arg_alignment (mode, type) / BITS_PER_UNIT;\n+\n+  bool abi_break;\n+  align\n+    = aarch64_function_arg_alignment (mode, type, &abi_break) / BITS_PER_UNIT;\n \n   dw_align = false;\n   adjust = 0;\n@@ -13367,7 +13406,12 @@ aarch64_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n       nregs = rsize / UNITS_PER_WORD;\n \n       if (align > 8)\n-\tdw_align = true;\n+\t{\n+\t  if (abi_break && warn_psabi)\n+\t    inform (input_location, \"parameter passing for argument of type \"\n+\t\t    \"%qT changed in GCC 9.1\", type);\n+\t  dw_align = true;\n+\t}\n \n       if (BLOCK_REG_PADDING (mode, type, 1) == PAD_DOWNWARD\n \t  && size < UNITS_PER_WORD)"}, {"sha": "cdb816e9066c02b921759d0d4492ef48239ed8b3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c590597c45948c6e6fa282878198fd226da95998/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c590597c45948c6e6fa282878198fd226da95998/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c590597c45948c6e6fa282878198fd226da95998", "patch": "@@ -1,3 +1,10 @@\n+2019-01-25  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\tPR target/88469\n+\t* gcc.target/aarch64/aapcs64/test_align-10.c: New test.\n+\t* gcc.target/aarch64/aapcs64/test_align-11.c: New test.\n+\t* gcc.target/aarch64/aapcs64/test_align-12.c: New test.\n+\n 2019-01-25  Richard Sandiford  <richard.sandiford@arm.com>\n \n \tPR middle-end/89037"}, {"sha": "af0c8a1f4122272a00aff45076c465169fc82c91", "filename": "gcc/testsuite/gcc.target/aarch64/aapcs64/test_align-10.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c590597c45948c6e6fa282878198fd226da95998/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Faapcs64%2Ftest_align-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c590597c45948c6e6fa282878198fd226da95998/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Faapcs64%2Ftest_align-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Faapcs64%2Ftest_align-10.c?ref=c590597c45948c6e6fa282878198fd226da95998", "patch": "@@ -0,0 +1,44 @@\n+/* Test AAPCS layout (alignment).  */\n+\n+/* { dg-do run { target aarch64*-*-* } } */\n+\n+#ifndef IN_FRAMEWORK\n+#define TESTFILE \"test_align-10.c\"\n+\n+struct s\n+{\n+  /* Should have 128-bit alignment.  */\n+  __int128 y : 65;\n+  char z: 7;\n+};\n+\n+typedef struct s T;\n+\n+#define EXPECTED_STRUCT_SIZE 16\n+extern void link_failure (void);\n+int\n+foo ()\n+{\n+  /* Optimization gets rid of this before linking.  */\n+  if (sizeof (struct s) != EXPECTED_STRUCT_SIZE)\n+    link_failure ();\n+}\n+\n+T a = { 1, 4 };\n+T b = { 9, 16 };\n+T c = { 25, 36 };\n+\n+#include \"abitest.h\"\n+#else\n+  ARG (int, 3, W0)\n+  ARG (T, a, X2)\n+  ARG (int, 5, W4)\n+  ARG (T, b, X6)\n+#ifndef __AAPCS64_BIG_ENDIAN__\n+  ARG (int, 7, STACK)\n+#else\n+  ARG (int, 7, STACK + 4)\n+#endif\n+  /* Natural alignment should be 16.  */\n+  LAST_ARG (T, c, STACK + 16)\n+#endif"}, {"sha": "357694902cd6986800c2f6bbcc2c4e68091a0b40", "filename": "gcc/testsuite/gcc.target/aarch64/aapcs64/test_align-11.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c590597c45948c6e6fa282878198fd226da95998/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Faapcs64%2Ftest_align-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c590597c45948c6e6fa282878198fd226da95998/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Faapcs64%2Ftest_align-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Faapcs64%2Ftest_align-11.c?ref=c590597c45948c6e6fa282878198fd226da95998", "patch": "@@ -0,0 +1,44 @@\n+/* Test AAPCS layout (alignment).  */\n+\n+/* { dg-do run { target aarch64*-*-* } } */\n+\n+#ifndef IN_FRAMEWORK\n+#define TESTFILE \"test_align-11.c\"\n+\n+struct s\n+{\n+  /* Should have 128-bit alignment and still detected as a bitfield.  */\n+  __int128 y : 64;\n+  char z: 7;\n+};\n+\n+typedef struct s T;\n+\n+#define EXPECTED_STRUCT_SIZE 16\n+extern void link_failure (void);\n+int\n+foo ()\n+{\n+  /* Optimization gets rid of this before linking.  */\n+  if (sizeof (struct s) != EXPECTED_STRUCT_SIZE)\n+    link_failure ();\n+}\n+\n+T a = { 1, 4 };\n+T b = { 9, 16 };\n+T c = { 25, 36 };\n+\n+#include \"abitest.h\"\n+#else\n+  ARG (int, 3, W0)\n+  ARG (T, a, X2)\n+  ARG (int, 5, W4)\n+  ARG (T, b, X6)\n+#ifndef __AAPCS64_BIG_ENDIAN__\n+  ARG (int, 7, STACK)\n+#else\n+  ARG (int, 7, STACK + 4)\n+#endif\n+  /* Natural alignment should be 16.  */\n+  LAST_ARG (T, c, STACK + 16)\n+#endif"}, {"sha": "5b3f74b51dce113b95edc9093af2a1b087c90d31", "filename": "gcc/testsuite/gcc.target/aarch64/aapcs64/test_align-12.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c590597c45948c6e6fa282878198fd226da95998/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Faapcs64%2Ftest_align-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c590597c45948c6e6fa282878198fd226da95998/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Faapcs64%2Ftest_align-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Faapcs64%2Ftest_align-12.c?ref=c590597c45948c6e6fa282878198fd226da95998", "patch": "@@ -0,0 +1,45 @@\n+/* Test AAPCS layout (alignment).  */\n+\n+/* { dg-do run { target aarch64*-*-* } } */\n+\n+#ifndef IN_FRAMEWORK\n+#define TESTFILE \"test_align-12.c\"\n+\n+struct s\n+{\n+  /* Should have 64-bit alignment.  */\n+  long long y : 57;\n+  char z: 7;\n+};\n+\n+typedef struct s T;\n+\n+#define EXPECTED_STRUCT_SIZE 8\n+extern void link_failure (void);\n+int\n+foo ()\n+{\n+  /* Optimization gets rid of this before linking.  */\n+  if (sizeof (struct s) != EXPECTED_STRUCT_SIZE)\n+    link_failure ();\n+}\n+\n+T a = { 1, 4 };\n+T b = { 9, 16 };\n+T c = { 25, 36 };\n+\n+#include \"abitest.h\"\n+#else\n+  ARG (int, 3, W0)\n+  ARG (T, a, X1)\n+  ARG (int, 5, W2)\n+  ARG (T, b, X3)\n+  ARG (__int128, 11, X4)\n+  ARG (__int128, 13, X6)\n+#ifndef __AAPCS64_BIG_ENDIAN__\n+  ARG (int, 7, STACK)\n+#else\n+  ARG (int, 7, STACK + 4)\n+#endif\n+  LAST_ARG (T, c, STACK + 8)\n+#endif"}]}