{"sha": "7bc7696cbab2dbedf79274f891493eaa5a26b23f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2JjNzY5NmNiYWIyZGJlZGY3OTI3NGY4OTE0OTNlYWE1YTI2YjIzZg==", "commit": {"author": {"name": "Richard Earnshaw", "email": "erich@gnu.org", "date": "1994-06-02T18:41:52Z"}, "committer": {"name": "Richard Earnshaw", "email": "erich@gnu.org", "date": "1994-06-02T18:41:52Z"}, "message": "output_func_{prologue,epilogue}): Change declarations from output_{prologue,epilogue}.\n\noutput_func_{prologue,epilogue}): Change declarations from\noutput_{prologue,epilogue}.\n(arm_output_llc, arithmetic_instr, output_arithmetic_with_immediate_mulitply,\n output_arithmetic_with_shift, shift_instr): Delete function definition.\n(ASM_OUTPUT_OPCODE): Delete.\n(PRINT_OPERAND): Call arm_print_operand, instead of doing it directly.\n(ARM_COMMENT_CHAR): New macro.\n(ARM_REG_PREFIX): New macro.\n(ARM_SIGN_EXTEND): New macro.\n(PRINT_OPERAND_ADDRESS): Delete variable 'shift'.  Change type of\nvariable 'offset' to HOST_WIDE_INT.  Use arm_print_operand to handle\nshifts in addresses.\n\nFrom-SVN: r7426", "tree": {"sha": "7c6c17b0617d24463d78d28cbf22ed8ca4dcdd32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c6c17b0617d24463d78d28cbf22ed8ca4dcdd32"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7bc7696cbab2dbedf79274f891493eaa5a26b23f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bc7696cbab2dbedf79274f891493eaa5a26b23f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7bc7696cbab2dbedf79274f891493eaa5a26b23f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bc7696cbab2dbedf79274f891493eaa5a26b23f/comments", "author": null, "committer": null, "parents": [{"sha": "c63165beb43faf6f59aabac06c254d78c29d3bf9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c63165beb43faf6f59aabac06c254d78c29d3bf9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c63165beb43faf6f59aabac06c254d78c29d3bf9"}], "stats": {"total": 136, "additions": 29, "deletions": 107}, "files": [{"sha": "6a76fa366310087a2059ee2847e715034dd55530", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 29, "deletions": 107, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bc7696cbab2dbedf79274f891493eaa5a26b23f/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bc7696cbab2dbedf79274f891493eaa5a26b23f/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=7bc7696cbab2dbedf79274f891493eaa5a26b23f", "patch": "@@ -24,10 +24,8 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n    tm file can be used unchanged to build a GCC for RISC OS.\n    (Since in fact, it can't.)  */\n \n-extern void output_prologue ();\n-extern void output_epilogue ();\n-extern char *arm_output_llc ();\n-extern char *arithmetic_instr ();\n+extern void output_func_prologue ();\n+extern void output_func_epilogue ();\n extern char *output_add_immediate ();\n extern char *output_call ();\n extern char *output_call_mem ();\n@@ -39,14 +37,9 @@ extern char *output_mov_long_double_arm_from_fpu ();\n extern char *output_mov_long_double_arm_from_arm ();\n extern char *output_mov_immediate ();\n extern char *output_multi_immediate ();\n-extern char *output_shifted_move ();\n-extern char *output_shift_compare ();\n-extern char *output_arithmetic_with_immediate_multiply ();\n-extern char *output_arithmetic_with_shift ();\n extern char *output_return_instruction ();\n extern char *output_load_symbol ();\n extern char *fp_immediate_constant ();\n-extern char *shift_instr ();\n extern struct rtx_def *gen_compare_reg ();\n extern struct rtx_def *arm_gen_store_multiple ();\n extern struct rtx_def *arm_gen_load_multiple ();\n@@ -1616,86 +1609,34 @@ do { char dstr[30];\t\t\t\t\t\t\t\\\n #define TARGET_FF\t014\n #define TARGET_CR\t015\n \f\n-/* FINAL_PRESCAN_INSN is used to take a look at the insns, in order to delete\n-   small-distance conditional branches and have ASM_OUTPUT_OPCODE make the\n-   instructions conditional.  Suffixes like s (affect flags) and b (bytewise\n-   load/store) need to stay suffixes, so the possible condition code comes\n-   before these suffixes.  %d<n> or %D<n> may appear in the opcode if\n-   it can take a condition; a null rtx will cause no condition to be added,\n-   this is what we expect to happen if arm_ccfsm_state is non-zero. */\n-#define ASM_OUTPUT_OPCODE(STREAM, PTR)  \\\n-  {\t\t\t\t\t        \t\t      \\\n-    extern int arm_ccfsm_state, arm_current_cc;\t\t\t      \\\n-    extern char *arm_condition_codes[];\t\t\t\t      \\\n-    int i;\t\t\t\t\t\t\t      \\\n-\t\t\t\t\t\t\t\t      \\\n-    fflush (STREAM);\t    /* XXX for debugging only.  */\t      \\\n-    if (arm_ccfsm_state == 3 || arm_ccfsm_state == 4)\t  \t\t\\\n-      {\t\t\t\t\t        \t\t             \\\n-\tfor (i = 0; *(PTR) != ' ' && *(PTR) != '\\t' && *(PTR) != '%' && i < 3;\\\n-\t     i++, (PTR)++)  \t\t\t\t\t\t     \\\n-\t  putc (*(PTR), STREAM);\t        \t\t             \\\n-\tfprintf (STREAM, \"%s\", arm_condition_codes[arm_current_cc]);         \\\n-\tfor (; *(PTR) != ' ' && *(PTR) != '\\t' && *(PTR) != '%'; (PTR)++)    \\\n-\t  putc (*(PTR), STREAM);\t\t\t\t\t     \\\n-      }\t\t\t\t\t\t\t\t             \\\n-  }\n-\n /* Only perform branch elimination (by making instructions conditional) if\n    we're optimising.  Otherwise it's of no use anyway.  */\n #define FINAL_PRESCAN_INSN(INSN, OPVEC, NOPERANDS)  \\\n   if (optimize)\t\t\t\t\t    \\\n     final_prescan_insn (INSN, OPVEC, NOPERANDS)\n \n-/* Output an operand of an instruction.  If X is a REG and CODE is `M', output\n-   a ldm/stm style multi-reg.  */\n+#ifndef ARM_COMMENT_CHAR\n+#define ARM_COMMENT_CHAR '@'\n+#endif\n+\n+/* Default is for register names not to have a prefix.  */\n+#ifndef ARM_REG_PREFIX\n+#define ARM_REG_PREFIX \"\"\n+#endif\n+\n+#define PRINT_OPERAND_PUNCT_VALID_P(CODE)\t\\\n+  ((CODE) == '?' || (CODE) == '|' || (CODE) == '@')\n+/* Output an operand of an instruction.  */\n #define PRINT_OPERAND(STREAM, X, CODE)  \\\n-{\t\t\t\t\t        \t\t\t\\\n-  if ((CODE) == 'd')\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (X)\t\t\t\t\t\t\t\t\\\n-        fputs (arm_condition_codes[get_arm_condition_code (X)],\t\t\\\n-\t       (STREAM));\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else if ((CODE) == 'D')\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (X)\t\t\t\t\t\t\t\t\\\n-        fputs (arm_condition_codes[get_arm_condition_code (X) ^ 1], \t\\\n-\t       (STREAM));\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else if ((CODE) == 'R')\t\t\t                \t\\\n-    fputs (reg_names[REGNO (X) + 1], (STREAM));\t\t\t\t\\\n-  else if (GET_CODE (X) == REG)\t\t        \t\t\t\\\n-    {\t\t\t\t\t        \t\t\t\\\n-      if ((CODE) != 'M')\t\t\t\t\t\t\\\n-\tfputs (reg_names[REGNO (X)], (STREAM));\t\t\t\t\\\n-      else\t\t\t\t        \t\t\t\\\n-\tfprintf ((STREAM), \"{%s-%s}\",\t        \t\t\t\\\n-\t\t reg_names[REGNO (X)],\t        \t\t\t\\\n-\t\t reg_names[REGNO (X) - 1        \t\t\t\\\n-\t\t\t   + ((GET_MODE_SIZE (GET_MODE (X))\t\t\\\n-\t\t\t       + GET_MODE_SIZE (SImode) - 1)\t\t\\\n-\t\t\t      / GET_MODE_SIZE (SImode))]);\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      extern int output_memory_reference_mode;\t\t\t\t\\\n-      output_memory_reference_mode = GET_MODE (X);\t\t\t\\\n-      output_address (XEXP (X, 0));\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else if (GET_CODE(X) == CONST_DOUBLE)\t\t\t\t\t\\\n-    fprintf(STREAM,\"#%s\", fp_immediate_constant(X));\t\t\t\\\n-  else if (GET_CODE (X) == NEG)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fputc ('-', (STREAM));\t\t\t\t\t\t\\\n-      output_operand ((X), 0);\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fputc('#', STREAM);\t\t\t\t\t\t\\\n-      output_addr_const(STREAM, X);\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n+  arm_print_operand (STREAM, X, CODE)\n+\n+#define ARM_SIGN_EXTEND(x)  ((HOST_WIDE_INT)\t\t\\\n+  (HOST_BITS_PER_WIDE_INT <= 32 ? (x)\t\t\t\\\n+   : (((x) & (unsigned HOST_WIDE_INT) 0xffffffff) |\t\\\n+      (((x) & (unsigned HOST_WIDE_INT) 0x80000000)\t\\\n+       ? ((~ (HOST_WIDE_INT) 0)\t\t\t\t\\\n+\t  & ~ (unsigned HOST_WIDE_INT) 0xffffffff)\t\\\n+       : 0))))\n \n /* Output the address of an operand.  */\n #define PRINT_OPERAND_ADDRESS(STREAM,X)  \\\n@@ -1709,8 +1650,7 @@ do { char dstr[30];\t\t\t\t\t\t\t\\\n \trtx base = XEXP (X, 0);\t\t\t\t\t\t\\\n \trtx index = XEXP (X, 1);\t\t\t\t\t\\\n \tchar *base_reg_name;\t\t\t\t\t\t\\\n-\tint offset = 0; \t\t\t\t\t\t\\\n-\tint shift;\t\t\t\t\t\t\t\\\n+\tHOST_WIDE_INT offset = 0;\t\t\t\t\t\\\n \tif (GET_CODE (base) != REG)\t\t\t\t\t\\\n \t  {\t\t\t\t\t\t\t\t\\\n \t    /* Ensure that BASE is a register (one of them must be). */\t\\\n@@ -1734,34 +1674,16 @@ do { char dstr[30];\t\t\t\t\t\t\t\\\n \t    break;\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n \t  case MULT:\t\t\t\t\t\t\t\\\n-\t    if (GET_CODE (XEXP (index,0)) == CONST_INT)\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\tshift = int_log2 (INTVAL (XEXP (index, 0)));\t\t\\\n-\t\tindex = XEXP (index, 1);\t\t\t\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t    else if (GET_CODE(XEXP(index,1)) == CONST_INT)\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\tshift = int_log2 (INTVAL (XEXP (index, 1)));\t\t\\\n-\t\tindex = XEXP (index, 0);\t\t\t\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t    else\t\t\t\t\t\t\t\\\n-\t\tabort();\t\t\t\t\t\t\\\n-\t    fprintf (STREAM, \"[%s, %s%s, asl #%d]\", base_reg_name,\t\\\n-\t\t     is_minus ? \"-\" : \"\", reg_names[REGNO (index)],\t\\\n-\t\t     shift);\t\t\t\t\t\t\\\n-\t    break;\t\t\t\t\t\t\t\\\n \t  case ASHIFTRT:\t\t\t\t\t\t\\\n \t  case LSHIFTRT:\t\t\t\t\t\t\\\n \t  case ASHIFT:\t\t\t\t\t\t\t\\\n \t  case ROTATERT:\t\t\t\t\t\t\\\n \t  {\t\t\t\t\t\t\t\t\\\n-\t    char *shift_type = shift_instr (GET_CODE (index),\t\t\\\n-\t\t\t\t\t    &XEXP (index, 1));\t\t\\\n-\t    shift = INTVAL (XEXP (index, 1));\t\t\t\t\\\n-\t    index = XEXP (index, 0);\t\t\t\t\t\\\n-\t    fprintf (STREAM, \"[%s, %s%s, %s #%d]\", base_reg_name,\t\\\n-\t\t     is_minus ? \"-\" : \"\", reg_names[REGNO (index)],\t\\\n-\t\t     shift_type, shift);\t\t\t\t\\\n+\t    fprintf (STREAM, \"[%s, %s%s, \", base_reg_name,\t\t\\\n+\t\t     is_minus ? \"-\" : \"\", \t\t\t\t\\\n+\t\t     reg_names[REGNO (XEXP (index, 0))]);\t\t\\\n+\t    arm_print_operand (STREAM, index, 'S');\t\t\t\\\n+\t    fputs (\"]\", STREAM);\t\t\t\t\t\\\n \t    break;\t\t\t\t\t\t\t\\\n \t  }\t\t\t\t\t\t\t\t\\\n \t    \t\t\t\t\t\t\t\t\\"}]}