{"sha": "84b8b0e04d42732ea65d452aa74e3575f75de10b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODRiOGIwZTA0ZDQyNzMyZWE2NWQ0NTJhYTc0ZTM1NzVmNzVkZTEwYg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2004-06-20T08:34:54Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2004-06-20T08:34:54Z"}, "message": "c-common.h (has_c_linkage): New interface.\n\n\t* c-common.h (has_c_linkage): New interface.\n\t* c-cppbuiltin.c: Include target.h.\n\t(c_cpp_builtins): Define __PRAGMA_REDEFINE_EXTNAME and\n\t__PRAGMA_EXTERN_PREFIX when appropriate.\n\t* c-pragma.c: Include target.h.\n\tDocument clarified semantics of symbol-renaming #pragmas.\n\t(handle_pragma_redefine_extname, handle_pragma_extern_prefix)\n\t(maybe_apply_renaming_pragma): Rewrite according to clarified\n\tsemantics.  Always recognize, but do not necessarily execute.\n\t(init_pragma): Unconditionally register symbol-renaming pragmas.\n\t* system.h: Poison HANDLE_PRAGMA_REDEFINE_EXTNAME\n\tand HANDLE_PRAGMA_EXTERN_PREFIX.\n\t* target.h (struct gcc_target): Add handle_pragma_redefine_extname\n\tand handle_pragma_extern_prefix flags.\n\t* target-def.h: Add defaults for TARGET_HANDLE_PRAGMA_REDEFINE_EXTNAME\n\tand TARGET_HANDLE_PRAGMA_EXTERN_PREFIX.\n\t* Makefile.in (c-pragma.o, c-cppbuiltin.o): Update dependencies.\n\t* config/sol2.h: Define TARGET_HANDLE_PRAGMA_REDEFINE_EXTNAME,\n\tnot HANDLE_PRAGMA_REDEFINE_EXTNAME.\n\t(TARGET_OS_CPP_BUILTINS): No need to define __PRAGMA_REDEFINE_EXTNAME.\n\t(TRANSFER_FROM_TRAMPOLINE): Prototype mprotect.\n\t* config/alpha/osf.h: Define TARGET_HANDLE_PRAGMA_EXTERN_PREFIX,\n\tnot HANDLE_PRAGMA_EXTERN_PREFIX.\n\t(TARGET_OS_CPP_BUILTINS): No need to define __PRAGMA_EXTERN_PREFIX.\n\t* doc/extend.texi (Solaris Pragmas, Tru64 Pragmas): Combine\n\tinto one section \"Symbol-Renaming Pragmas\"; clarify; document\n\tadjusted semantics.\n\n\t* builtins.c (expand_builtin): Do not issue error for a builtin\n\twith no special case code and no DECL_ASSEMBLER_NAME; just do the\n\tlibrary call.\n\t* c-decl.c (builtin_function): Don't call make_decl_rtl.\n\t* c-objc-common.c (has_c_linkage): Stub implementation.\n\t* cgraphunit.c (cgraph_expand_function)\n\t(cgraph_remove_unreachable_nodes): Don't clear DECL_ARGUMENTS.\n\ncp:\n\t* cp-lang.c (has_c_linkage): Implement.\n\n\t* cp-tree.h (set_mangled_name_for_decl): Don't prototype.\n\t* decl.c (duplicate_decls): Use COPY_DECL_RTL.\n\t(builtin_function_1): Don't call make_decl_rtl.\n\t(build_cp_library_fn): Don't call set_mangled_name_for_decl.\n\t(grokvardecl): Don't call mangle_decl.\n\t* except.c (nothrow_libfn_p): Look at DECL_NAME, not\n\tDECL_ASSEMBLER_NAME.\n\t* method.c (set_mangled_name_for_decl): Delete.\n\t* name-lookup.c (pushdecl): When a local extern shadows a\n\tfile-scope declaration of the same object, give both DECLs the\n\tsame DECL_UID.\n\t* typeck.c (cxx_mark_addressable): Don't set TREE_ADDRESSABLE\n\ton DECL_ASSEMBLER_NAME.\n\ntestsuite:\n\t* g++.dg/expr/enum1.C, g++.dg/opt/const3.C: Declare abort with\n\textern \"C\".\n\t* g++.dg/other/pragma-re-1.C: Add comments.\n\nFrom-SVN: r83405", "tree": {"sha": "77c6f2ecee8dfe71ed0ec15fc16f213965dbd4dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77c6f2ecee8dfe71ed0ec15fc16f213965dbd4dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84b8b0e04d42732ea65d452aa74e3575f75de10b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84b8b0e04d42732ea65d452aa74e3575f75de10b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84b8b0e04d42732ea65d452aa74e3575f75de10b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84b8b0e04d42732ea65d452aa74e3575f75de10b/comments", "author": null, "committer": null, "parents": [{"sha": "14f661f16c1aabf017bcd7b0fea29786366b502f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14f661f16c1aabf017bcd7b0fea29786366b502f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14f661f16c1aabf017bcd7b0fea29786366b502f"}], "stats": {"total": 514, "additions": 351, "deletions": 163}, "files": [{"sha": "acb2bffd3f5be293e36cd031e81f594b0c0d7283", "filename": "gcc/ChangeLog", "status": "modified", "additions": 44, "deletions": 6, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=84b8b0e04d42732ea65d452aa74e3575f75de10b", "patch": "@@ -1,3 +1,41 @@\n+2004-06-20  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* c-common.h (has_c_linkage): New interface.\n+\t* c-cppbuiltin.c: Include target.h.\n+\t(c_cpp_builtins): Define __PRAGMA_REDEFINE_EXTNAME and\n+\t__PRAGMA_EXTERN_PREFIX when appropriate.\n+\t* c-pragma.c: Include target.h.\n+\tDocument clarified semantics of symbol-renaming #pragmas.\n+\t(handle_pragma_redefine_extname, handle_pragma_extern_prefix)\n+\t(maybe_apply_renaming_pragma): Rewrite according to clarified\n+\tsemantics.  Always recognize, but do not necessarily execute.\n+\t(init_pragma): Unconditionally register symbol-renaming pragmas.\n+\t* system.h: Poison HANDLE_PRAGMA_REDEFINE_EXTNAME\n+\tand HANDLE_PRAGMA_EXTERN_PREFIX.\n+\t* target.h (struct gcc_target): Add handle_pragma_redefine_extname\n+\tand handle_pragma_extern_prefix flags.\n+\t* target-def.h: Add defaults for TARGET_HANDLE_PRAGMA_REDEFINE_EXTNAME\n+\tand TARGET_HANDLE_PRAGMA_EXTERN_PREFIX.\n+\t* Makefile.in (c-pragma.o, c-cppbuiltin.o): Update dependencies.\n+\t* config/sol2.h: Define TARGET_HANDLE_PRAGMA_REDEFINE_EXTNAME,\n+\tnot HANDLE_PRAGMA_REDEFINE_EXTNAME.\n+\t(TARGET_OS_CPP_BUILTINS): No need to define __PRAGMA_REDEFINE_EXTNAME.\n+\t(TRANSFER_FROM_TRAMPOLINE): Prototype mprotect.\n+\t* config/alpha/osf.h: Define TARGET_HANDLE_PRAGMA_EXTERN_PREFIX,\n+\tnot HANDLE_PRAGMA_EXTERN_PREFIX.\n+\t(TARGET_OS_CPP_BUILTINS): No need to define __PRAGMA_EXTERN_PREFIX.\n+\t* doc/extend.texi (Solaris Pragmas, Tru64 Pragmas): Combine\n+\tinto one section \"Symbol-Renaming Pragmas\"; clarify; document\n+\tadjusted semantics.\n+\n+\t* builtins.c (expand_builtin): Do not issue error for a builtin\n+\twith no special case code and no DECL_ASSEMBLER_NAME; just do the\n+\tlibrary call.\n+\t* c-decl.c (builtin_function): Don't call make_decl_rtl.\n+\t* c-objc-common.c (has_c_linkage): Stub implementation.\n+\t* cgraphunit.c (cgraph_expand_function)\n+\t(cgraph_remove_unreachable_nodes): Don't clear DECL_ARGUMENTS.\n+\n 2004-06-19  Roger Sayle  <roger@eyesopen.com>\n \n \t* builtins.c (fold_builtin_unordered_cmp): Take an EXP argument\n@@ -104,7 +142,7 @@\n \n 2004-06-18  Richard Henderson  <rth@redhat.com>\n \n-\tPR c++/16036 \n+\tPR c++/16036\n \t* gimple-low.c (lower_function_body): Generate return statement for\n \tfall off the end of the function here ...\n \t* tree-cfg.c (make_edges): ... instead of here.\n@@ -267,10 +305,10 @@\n \tUTAG_RETHROWEXC_VAR, UTAG_EVALONCE_VAR, struct val_stack,\n \tcatch_count_stack, exc_binding_stack, if_nesting_count,\n \tblk_nesting_count, objc_enter_block, objc_exit_block,\n-\tobjc_declare_variable, val_stack_push, val_stack_pop, \n+\tobjc_declare_variable, val_stack_push, val_stack_pop,\n \tobjc_build_try_enter_fragment, objc_build_extract_expr,\n \tobjc_build_try_exit_fragment, objc_build_extract_fragment,\n-\tobjc_build_try_prologue, objc_build_try_epilogue, \n+\tobjc_build_try_prologue, objc_build_try_epilogue,\n \tobjc_build_catch_stmt, objc_build_catch_epilogue,\n \tobjc_build_finally_prologue, objc_build_finally_epilogue,\n \tobjc_build_try_catch_finally_stmt, objc_build_synchronized_prologue,\n@@ -381,9 +419,9 @@\n \t* tree-ssa-operands.h (struct def_optype_d):  Change underlying type.\n \t(struct use_optype_d):  Change underlying type.\n \t(def_operand_p, use_operand_p):  New types for pointers to operands.\n-\t(USE_OP, DEF_OP, V_MAY_DEF_RESULT, V_MAY_DEF_OP, VUSE_OP, \n+\t(USE_OP, DEF_OP, V_MAY_DEF_RESULT, V_MAY_DEF_OP, VUSE_OP,\n \tV_MUST_DEF_OP):  Use new pointer type instead of dereferencing directly.\n-\t(USE_FROM_PTR, DEF_FROM_PTR):  New macros to \"dereference\" operand \n+\t(USE_FROM_PTR, DEF_FROM_PTR):  New macros to \"dereference\" operand\n \tpointer types.\n \t(SET_USE, SET_DEF):  New macros to set operands from their pointer.\n \t(SET_USE_OP, SET_DEF_OP, SET_V_MAY_DEF_RESULT, SET_V_MAY_DEF_OP,\n@@ -411,7 +449,7 @@\n \t* tree.h (duplicate_ssa_name): Declare.\n \n 2004-06-17  David Ayers  <d.ayers@inode.at>\n- \n+\n \t* c-parse.in: Unify Objective-C token names.\n \n 2004-06-17  Zack Weinberg  <zack@codesourcery.com>"}, {"sha": "6c21b666a550fb7490686a6daad3279a00433ff4", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=84b8b0e04d42732ea65d452aa74e3575f75de10b", "patch": "@@ -1381,8 +1381,9 @@ c-aux-info.o : c-aux-info.c  $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_\n     $(C_TREE_H) $(FLAGS_H) toplev.h\n c-convert.o : c-convert.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n     $(FLAGS_H) toplev.h $(C_COMMON_H) real.h\n-c-pragma.o: c-pragma.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n-    function.h c-pragma.h toplev.h output.h $(GGC_H) $(TM_P_H) $(C_COMMON_H) gt-c-pragma.h\n+c-pragma.o: c-pragma.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n+    $(TREE_H) function.h c-pragma.h toplev.h output.h $(GGC_H) $(TM_P_H) \\\n+    $(C_COMMON_H) $(TARGET_H) gt-c-pragma.h\n graph.o: graph.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) toplev.h $(FLAGS_H) output.h \\\n     $(RTL_H) function.h hard-reg-set.h $(BASIC_BLOCK_H) graph.h\n sbitmap.o: sbitmap.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(FLAGS_H) \\\n@@ -1424,8 +1425,8 @@ c-opts.o : c-opts.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H)\t\t\\\n \t\t$< $(OUTPUT_OPTION) @TARGET_SYSTEM_ROOT_DEFINE@\n \n c-cppbuiltin.o : c-cppbuiltin.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n-\t$(TREE_H) version.h $(C_COMMON_H) c-pragma.h $(FLAGS_H) toplev.h langhooks.h \\\n-\toutput.h except.h real.h $(TM_P_H)\n+\t$(TREE_H) version.h $(C_COMMON_H) c-pragma.h $(FLAGS_H) toplev.h \\\n+\tlanghooks.h output.h except.h real.h $(TARGET_H) $(TM_P_H)\n \n # A file used by all variants of C and some other languages.\n "}, {"sha": "0959b1f32c8934c157a1195f87e99a43b973b532", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=84b8b0e04d42732ea65d452aa74e3575f75de10b", "patch": "@@ -6202,9 +6202,7 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n       break;\n \n     default:\t/* just do library call, if unknown builtin */\n-      if (!DECL_ASSEMBLER_NAME_SET_P (fndecl))\n-\terror (\"built-in function `%s' not currently supported\",\n-\t       IDENTIFIER_POINTER (DECL_NAME (fndecl)));\n+      break;\n     }\n \n   /* The switch statement above can drop through to cause the function"}, {"sha": "91a18869b2de021a9178f1682a1606f6ab2db30b", "filename": "gcc/c-common.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=84b8b0e04d42732ea65d452aa74e3575f75de10b", "patch": "@@ -303,6 +303,7 @@ extern int c_expand_decl (tree);\n extern int field_decl_cmp (const void *, const void *);\n extern void resort_sorted_fields (void *, void *, gt_pointer_operator, \n                                   void *);\n+extern bool has_c_linkage (tree decl);\n \f\n /* Switches common to the C front ends.  */\n "}, {"sha": "3f0f688861d0ed72fb83212f112ac87400bf0ea6", "filename": "gcc/c-cppbuiltin.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-cppbuiltin.c?ref=84b8b0e04d42732ea65d452aa74e3575f75de10b", "patch": "@@ -32,6 +32,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"except.h\"\t\t/* For USING_SJLJ_EXCEPTIONS.  */\n #include \"toplev.h\"\n #include \"tm_p.h\"\t\t/* Target prototypes.  */\n+#include \"target.h\"\n \n #ifndef TARGET_OS_CPP_BUILTINS\n # define TARGET_OS_CPP_BUILTINS()\n@@ -409,6 +410,13 @@ c_cpp_builtins (cpp_reader *pfile)\n   if (c_dialect_objc () && flag_next_runtime)\n     cpp_define (pfile, \"__NEXT_RUNTIME__\");\n \n+  /* Show the availability of some target pragmas.  */\n+  if (flag_mudflap || targetm.handle_pragma_redefine_extname)\n+    cpp_define (pfile, \"__PRAGMA_REDEFINE_EXTNAME\");\n+\n+  if (targetm.handle_pragma_extern_prefix)\n+    cpp_define (pfile, \"__PRAGMA_EXTERN_PREFIX\");\n+\n   /* A straightforward target hook doesn't work, because of problems\n      linking that hook's body when part of non-C front ends.  */\n # define preprocessing_asm_p() (cpp_get_options (pfile)->lang == CLK_ASM)"}, {"sha": "cbf5795b83d9bbb602c1571d1b711ff21dcb8edb", "filename": "gcc/c-decl.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=84b8b0e04d42732ea65d452aa74e3575f75de10b", "patch": "@@ -2382,7 +2382,6 @@ builtin_function (const char *name, tree type, int function_code,\n   DECL_FUNCTION_CODE (decl) = function_code;\n   if (library_name)\n     SET_DECL_ASSEMBLER_NAME (decl, get_identifier (library_name));\n-  make_decl_rtl (decl, NULL);\n \n   /* Should never be called on a symbol with a preexisting meaning.  */\n   if (I_SYMBOL_BINDING (id))"}, {"sha": "731e0631264fa2e798141354303e179936cbc183", "filename": "gcc/c-objc-common.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Fc-objc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Fc-objc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-objc-common.c?ref=84b8b0e04d42732ea65d452aa74e3575f75de10b", "patch": "@@ -314,3 +314,9 @@ c_objc_common_truthvalue_conversion (tree expr)\n   return c_common_truthvalue_conversion (expr);\n }\n \n+/* In C and ObjC, all decls have \"C\" linkage.  */\n+bool\n+has_c_linkage (tree decl ATTRIBUTE_UNUSED)\n+{\n+  return true;\n+}"}, {"sha": "93836ea8652ac2b4a88d32973a40747121fec395", "filename": "gcc/c-pragma.c", "status": "modified", "additions": 152, "deletions": 71, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.c?ref=84b8b0e04d42732ea65d452aa74e3575f75de10b", "patch": "@@ -34,6 +34,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"c-common.h\"\n #include \"output.h\"\n #include \"tm_p.h\"\n+#include \"target.h\"\n \n #define GCC_BAD(msgid) do { warning (msgid); return; } while (0)\n #define GCC_BAD2(msgid, arg) do { warning (msgid, arg); return; } while (0)\n@@ -350,56 +351,111 @@ maybe_apply_pragma_weak (tree decl ATTRIBUTE_UNUSED)\n }\n #endif /* HANDLE_PRAGMA_WEAK */\n \n+/* GCC supports two #pragma directives for renaming the external\n+   symbol associated with a declaration (DECL_ASSEMBLER_NAME), for\n+   compatibility with the Solaris and Tru64 system headers.  GCC also\n+   has its own notation for this, __asm__(\"name\") annotations.\n+\n+   Corner cases of these features and their interaction:\n+\n+   1) Both pragmas silently apply only to declarations with external\n+      linkage (that is, TREE_PUBLIC || DECL_EXTERNAL).  Asm labels\n+      do not have this restriction.\n+\n+   2) In C++, both #pragmas silently apply only to extern \"C\" declarations.\n+      Asm labels do not have this restriction.\n+\n+   3) If any of the three ways of changing DECL_ASSEMBLER_NAME is\n+      applied to a decl whose DECL_ASSEMBLER_NAME is already set, and the\n+      new name is different, a warning issues and the name does not change.\n+\n+   4) The \"source name\" for #pragma redefine_extname is the DECL_NAME,\n+      *not* the DECL_ASSEMBLER_NAME.\n+\n+   5) If #pragma extern_prefix is in effect and a declaration occurs\n+      with an __asm__ name, the #pragma extern_prefix is silently\n+      ignored for that declaration.\n+\n+   6) If #pragma extern_prefix and #pragma redefine_extname apply to\n+      the same declaration, whichever triggered first wins, and a warning\n+      is issued.  (We would like to have #pragma redefine_extname always\n+      win, but it can appear either before or after the declaration, and\n+      if it appears afterward, we have no way of knowing whether a modified\n+      DECL_ASSEMBLER_NAME is due to #pragma extern_prefix.)  */\n+\n static GTY(()) tree pending_redefine_extname;\n \n static void handle_pragma_redefine_extname (cpp_reader *);\n \n-/* #pragma redefined_extname oldname newname */\n+/* #pragma redefine_extname oldname newname */\n static void\n handle_pragma_redefine_extname (cpp_reader *dummy ATTRIBUTE_UNUSED)\n {\n   tree oldname, newname, decl, x;\n   enum cpp_ttype t;\n \n   if (c_lex (&oldname) != CPP_NAME)\n-    {\n-      warning (\"malformed #pragma redefine_extname, ignored\");\n-      return;\n-    }\n+    GCC_BAD (\"malformed #pragma redefine_extname, ignored\");\n   if (c_lex (&newname) != CPP_NAME)\n-    {\n-      warning (\"malformed #pragma redefine_extname, ignored\");\n-      return;\n-    }\n+    GCC_BAD (\"malformed #pragma redefine_extname, ignored\");\n   t = c_lex (&x);\n   if (t != CPP_EOF)\n     warning (\"junk at end of #pragma redefine_extname\");\n \n+  if (!flag_mudflap && !targetm.handle_pragma_redefine_extname)\n+    {\n+      if (warn_unknown_pragmas > in_system_header)\n+\twarning (\"#pragma redefine_extname not supported on this target\");\n+      return;\n+    }\n+\n   decl = identifier_global_value (oldname);\n-  if (decl && (TREE_CODE (decl) == FUNCTION_DECL\n-\t       || TREE_CODE (decl) == VAR_DECL))\n+  if (decl\n+      && (TREE_PUBLIC (decl) || DECL_EXTERNAL (decl))\n+      && (TREE_CODE (decl) == FUNCTION_DECL\n+\t  || TREE_CODE (decl) == VAR_DECL)\n+      && has_c_linkage (decl))\n     {\n-      if (DECL_ASSEMBLER_NAME_SET_P (decl)\n-\t  && DECL_ASSEMBLER_NAME (decl) != newname)\n-        warning (\"#pragma redefine_extname conflicts with declaration\");\n-      change_decl_assembler_name (decl, newname);\n+      if (DECL_ASSEMBLER_NAME_SET_P (decl))\n+\t{\n+\t  const char *name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n+\t  name = targetm.strip_name_encoding (name);\n+\n+\t  if (strcmp (name, IDENTIFIER_POINTER (newname)))\n+\t    warning (\"#pragma redefine_extname ignored due to conflict with \"\n+\t\t     \"previous rename\");\n+\t}\n+      else\n+\tchange_decl_assembler_name (decl, newname);\n     }\n   else\n-    add_to_renaming_pragma_list(oldname, newname);\n+    /* We have to add this to the rename list even if there's already\n+       a global value that doesn't meet the above criteria, because in\n+       C++ \"struct foo {...};\" puts \"foo\" in the current namespace but\n+       does *not* conflict with a subsequent declaration of a function\n+       or variable foo.  See g++.dg/other/pragma-re-2.C.  */\n+    add_to_renaming_pragma_list (oldname, newname);\n }\n \n+/* This is called from here and from ia64.c.  */\n void\n add_to_renaming_pragma_list (tree oldname, tree newname)\n {\n+  tree previous = purpose_member (oldname, pending_redefine_extname);\n+  if (previous)\n+    {\n+      if (TREE_VALUE (previous) != newname)\n+\twarning (\"#pragma redefine_extname ignored due to conflict with \"\n+\t\t \"previous #pragma redefine_extname\");\n+      return;\n+    }\n+  \n   pending_redefine_extname\n     = tree_cons (oldname, newname, pending_redefine_extname);\n }\n \n static GTY(()) tree pragma_extern_prefix;\n \n-#ifdef HANDLE_PRAGMA_EXTERN_PREFIX\n-static void handle_pragma_extern_prefix (cpp_reader *);\n-\n /* #pragma extern_prefix \"prefix\" */\n static void\n handle_pragma_extern_prefix (cpp_reader *dummy ATTRIBUTE_UNUSED)\n@@ -408,75 +464,106 @@ handle_pragma_extern_prefix (cpp_reader *dummy ATTRIBUTE_UNUSED)\n   enum cpp_ttype t;\n \n   if (c_lex (&prefix) != CPP_STRING)\n-    {\n-      warning (\"malformed #pragma extern_prefix, ignored\");\n-      return;\n-    }\n+    GCC_BAD (\"malformed #pragma extern_prefix, ignored\");\n   t = c_lex (&x);\n   if (t != CPP_EOF)\n     warning (\"junk at end of #pragma extern_prefix\");\n \n-  /* Note that the length includes the null terminator.  */\n-  pragma_extern_prefix = (TREE_STRING_LENGTH (prefix) > 1 ? prefix : NULL);\n+  if (targetm.handle_pragma_extern_prefix)\n+    /* Note that the length includes the null terminator.  */\n+    pragma_extern_prefix = (TREE_STRING_LENGTH (prefix) > 1 ? prefix : NULL);\n+  else if (warn_unknown_pragmas > in_system_header)\n+    warning (\"#pragma extern_prefix not supported on this target\");\n }\n-#endif\n \n /* Hook from the front ends to apply the results of one of the preceding\n    pragmas that rename variables.  */\n \n tree\n maybe_apply_renaming_pragma (tree decl, tree asmname)\n {\n-  tree oldname;\n-\n-  /* Copied from the check in set_decl_assembler_name.  */\n-  if (TREE_CODE (decl) == FUNCTION_DECL\n-      || (TREE_CODE (decl) == VAR_DECL \n-          && (TREE_STATIC (decl) \n-              || DECL_EXTERNAL (decl) \n-              || TREE_PUBLIC (decl))))\n-    oldname = DECL_ASSEMBLER_NAME (decl);\n-  else\n+  tree *p, t;\n+\n+  /* The renaming pragmas are only applied to declarations with\n+     external linkage.  */\n+  if ((TREE_CODE (decl) != FUNCTION_DECL && TREE_CODE (decl) != VAR_DECL)\n+      || (!TREE_PUBLIC (decl) && !DECL_EXTERNAL (decl))\n+      || !has_c_linkage (decl))\n     return asmname;\n \n-  /* If the name begins with a *, that's a sign of an asmname attached to\n-     a previous declaration.  */\n-  if (IDENTIFIER_POINTER (oldname)[0] == '*')\n+  /* If the DECL_ASSEMBLER_NAME is already set, it does not change,\n+     but we may warn about a rename that conflicts.  */\n+  if (DECL_ASSEMBLER_NAME_SET_P (decl))\n     {\n-      const char *oldasmname = IDENTIFIER_POINTER (oldname) + 1;\n-      if (asmname && strcmp (TREE_STRING_POINTER (asmname), oldasmname) != 0)\n-\twarning (\"asm declaration conflicts with previous rename\");\n-      asmname = build_string (strlen (oldasmname), oldasmname);\n+      const char *oldname = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n+      oldname = targetm.strip_name_encoding (oldname);\n+\n+      if (asmname && strcmp (TREE_STRING_POINTER (asmname), oldname))\n+\t  warning (\"asm declaration ignored due to \"\n+\t\t   \"conflict with previous rename\");\n+\n+      /* Take any pending redefine_extname off the list.  */\n+      for (p = &pending_redefine_extname; (t = *p); p = &TREE_CHAIN (t))\n+\tif (DECL_NAME (decl) == TREE_PURPOSE (t))\n+\t  {\n+\t    /* Only warn if there is a conflict.  */\n+\t    if (strcmp (IDENTIFIER_POINTER (TREE_VALUE (t)), oldname))\n+\t      warning (\"#pragma redefine_extname ignored due to \"\n+\t\t       \"conflict with previous rename\");\n+\n+\t    *p = TREE_CHAIN (t);\n+\t    break;\n+\t  }\n+      return 0;\n     }\n \n-  {\n-    tree *p, t;\n+  /* Find out if we have a pending #pragma redefine_extname.  */\n+  for (p = &pending_redefine_extname; (t = *p); p = &TREE_CHAIN (t))\n+    if (DECL_NAME (decl) == TREE_PURPOSE (t))\n+      {\n+\ttree newname = TREE_VALUE (t);\n+\t*p = TREE_CHAIN (t);\n \n-    for (p = &pending_redefine_extname; (t = *p) ; p = &TREE_CHAIN (t))\n-      if (oldname == TREE_PURPOSE (t))\n-\t{\n-\t  const char *newname = IDENTIFIER_POINTER (TREE_VALUE (t));\n+\t/* If we already have an asmname, #pragma redefine_extname is\n+ \t   ignored (with a warning if it conflicts).  */\n+\tif (asmname)\n+\t  {\n+\t    if (strcmp (TREE_STRING_POINTER (asmname),\n+\t\t\tIDENTIFIER_POINTER (newname)) != 0)\n+\t      warning (\"#pragma redefine_extname ignored due to \"\n+\t\t       \"conflict with __asm__ declaration\");\n+\t    return asmname;\n+\t  }\n \n-\t  if (asmname && strcmp (TREE_STRING_POINTER (asmname), newname) != 0)\n-            warning (\"#pragma redefine_extname conflicts with declaration\");\n-\t  *p = TREE_CHAIN (t);\n+\t/* Otherwise we use what we've got; #pragma extern_prefix is\n+\t   silently ignored.  */\n+\treturn build_string (IDENTIFIER_LENGTH (newname),\n+\t\t\t     IDENTIFIER_POINTER (newname));\n+      }\n \n-\t  return build_string (strlen (newname), newname);\n-\t}\n-  }\n+  /* If we've got an asmname, #pragma extern_prefix is silently ignored.  */\n+  if (asmname)\n+    return asmname;\n \n-#ifdef HANDLE_PRAGMA_EXTERN_PREFIX\n-  if (pragma_extern_prefix && !asmname)\n+  /* If #pragma extern_prefix is in effect, apply it.  */\n+  if (pragma_extern_prefix)\n     {\n-      char *x = concat (TREE_STRING_POINTER (pragma_extern_prefix),\n-\t\t\tIDENTIFIER_POINTER (oldname), NULL);\n-      asmname = build_string (strlen (x), x);\n-      free (x);\n-      return asmname;\n+      const char *prefix = TREE_STRING_POINTER (pragma_extern_prefix);\n+      size_t plen = TREE_STRING_LENGTH (pragma_extern_prefix) - 1;\n+\n+      const char *id = IDENTIFIER_POINTER (DECL_NAME (decl));\n+      size_t ilen = IDENTIFIER_LENGTH (DECL_NAME (decl));\n+\t\n+      char *newname = alloca (plen + ilen + 1);\n+\n+      memcpy (newname,        prefix, plen);\n+      memcpy (newname + plen, id, ilen + 1);\n+\n+      return build_string (plen + ilen, newname);\n     }\n-#endif\n \n-  return asmname;\n+  /* Nada.  */\n+  return 0;\n }\n \n /* Front-end wrapper for pragma registration to avoid dragging\n@@ -498,15 +585,9 @@ init_pragma (void)\n #ifdef HANDLE_PRAGMA_WEAK\n   c_register_pragma (0, \"weak\", handle_pragma_weak);\n #endif\n-#ifdef HANDLE_PRAGMA_REDEFINE_EXTNAME\n+\n   c_register_pragma (0, \"redefine_extname\", handle_pragma_redefine_extname);\n-#else\n-  if (flag_mudflap)\n-    c_register_pragma (0, \"redefine_extname\", handle_pragma_redefine_extname);\n-#endif\n-#ifdef HANDLE_PRAGMA_EXTERN_PREFIX\n   c_register_pragma (0, \"extern_prefix\", handle_pragma_extern_prefix);\n-#endif\n \n #ifdef REGISTER_TARGET_PRAGMAS\n   REGISTER_TARGET_PRAGMAS ();"}, {"sha": "67001f0dd127f72294dbd336657c7c35bd67e7b1", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=84b8b0e04d42732ea65d452aa74e3575f75de10b", "patch": "@@ -804,7 +804,6 @@ cgraph_expand_function (struct cgraph_node *node)\n     {\n       DECL_SAVED_TREE (node->decl) = NULL;\n       DECL_STRUCT_FUNCTION (node->decl) = NULL;\n-      DECL_ARGUMENTS (node->decl) = NULL;\n       DECL_INITIAL (node->decl) = error_mark_node;\n     }\n }\n@@ -965,7 +964,6 @@ cgraph_remove_unreachable_nodes (void)\n \t\t    {\n \t\t      DECL_SAVED_TREE (node->decl) = NULL;\n \t\t      DECL_STRUCT_FUNCTION (node->decl) = NULL;\n-\t\t      DECL_ARGUMENTS (node->decl) = NULL;\n \t\t      DECL_INITIAL (node->decl) = error_mark_node;\n \t\t    }\n \t\t  while (node->callees)"}, {"sha": "04b7bf1a3329abf5b4894bb89a54c0752a3406c5", "filename": "gcc/config/alpha/osf.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Fconfig%2Falpha%2Fosf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Fconfig%2Falpha%2Fosf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fosf.h?ref=84b8b0e04d42732ea65d452aa74e3575f75de10b", "patch": "@@ -41,7 +41,6 @@ Boston, MA 02111-1307, USA.  */\n \tbuiltin_define (\"__digital__\");\t\t\t\\\n \tbuiltin_define (\"__arch64__\");\t\t\t\\\n \tbuiltin_define (\"_LONGLONG\");\t\t\t\\\n-\tbuiltin_define (\"__PRAGMA_EXTERN_PREFIX\");\t\\\n \tbuiltin_assert (\"system=unix\");\t\t\t\\\n \tbuiltin_assert (\"system=xpg4\");\t\t\t\\\n \t/* Tru64 UNIX V5 has a 16 byte long\t\t\\\n@@ -211,4 +210,4 @@ __enable_execute_stack (void *addr)\t\t\t\t\t\\\n \n /* Handle #pragma extern_prefix.  Technically only needed for Tru64 5.x,\n    but easier to manipulate preprocessor bits from here.  */\n-#define HANDLE_PRAGMA_EXTERN_PREFIX 1\n+#define TARGET_HANDLE_PRAGMA_EXTERN_PREFIX 1"}, {"sha": "1ff6308329b3fef6c7b9db7357e87940ff28598c", "filename": "gcc/config/sol2.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Fconfig%2Fsol2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Fconfig%2Fsol2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsol2.h?ref=84b8b0e04d42732ea65d452aa74e3575f75de10b", "patch": "@@ -39,7 +39,7 @@ Boston, MA 02111-1307, USA.  */\n #undef\tWINT_TYPE_SIZE\n #define\tWINT_TYPE_SIZE BITS_PER_WORD\n \n-#define HANDLE_PRAGMA_REDEFINE_EXTNAME 1\n+#define TARGET_HANDLE_PRAGMA_REDEFINE_EXTNAME 1\n \n /* ??? Note: in order for -compat-bsd to work fully,\n    we must somehow arrange to fixincludes /usr/ucbinclude\n@@ -60,7 +60,6 @@ Boston, MA 02111-1307, USA.  */\n \tbuiltin_define_std (\"sun\");\t\t\t\\\n \tbuiltin_define (\"__svr4__\");\t\t\t\\\n \tbuiltin_define (\"__SVR4\");\t\t\t\\\n-\tbuiltin_define (\"__PRAGMA_REDEFINE_EXTNAME\");\t\\\n \tbuiltin_assert (\"system=unix\");\t\t\t\\\n \tbuiltin_assert (\"system=svr4\");\t\t\t\\\n \t/* For C++ we need to add some additional macro\t\\\n@@ -196,6 +195,7 @@ extern void __enable_execute_stack (void *);\t\t\t\t\\\n void\t\t\t\t\t\t\t\t\t\\\n __enable_execute_stack (void *addr)\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n+  extern int mprotect(void *, size_t, int);\t\t\t\t\\\n   if (!need_enable_exec_stack)\t\t\t\t\t\t\\\n     return;\t\t\t\t\t\t\t\t\\\n   else {\t\t\t\t\t\t\t\t\\"}, {"sha": "e3048d3dba08536b1c1f336f4dab1db452d504ce", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=84b8b0e04d42732ea65d452aa74e3575f75de10b", "patch": "@@ -1,3 +1,21 @@\n+2004-06-20  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* cp-lang.c (has_c_linkage): Implement.\n+\n+\t* cp-tree.h (set_mangled_name_for_decl): Don't prototype.\n+\t* decl.c (duplicate_decls): Use COPY_DECL_RTL.\n+\t(builtin_function_1): Don't call make_decl_rtl.\n+\t(build_cp_library_fn): Don't call set_mangled_name_for_decl.\n+\t(grokvardecl): Don't call mangle_decl.\n+\t* except.c (nothrow_libfn_p): Look at DECL_NAME, not\n+\tDECL_ASSEMBLER_NAME.\n+\t* method.c (set_mangled_name_for_decl): Delete.\n+\t* name-lookup.c (pushdecl): When a local extern shadows a\n+\tfile-scope declaration of the same object, give both DECLs the\n+\tsame DECL_UID.\n+\t* typeck.c (cxx_mark_addressable): Don't set TREE_ADDRESSABLE\n+\ton DECL_ASSEMBLER_NAME.\n+\n 2004-06-19  Richard Henderson  <rth@redhat.com>\n \n \t* cp-gimplify.c: Remove unnecessary prototypes.\n@@ -15,7 +33,7 @@\n \t(finish_cond): Rewrite to handle template DECL_STMTs specially.\n \tAssume that non-template decls go land before the conditional.\n \t(simplify_loop_decl_cond): Likewise.\n-\t(begin_if_stmt, finish_if_stmt_cond, begin_while_stmt, \n+\t(begin_if_stmt, finish_if_stmt_cond, begin_while_stmt,\n \tfinish_while_stmt_cond, finish_for_init_stmt, finish_for_cond,\n \tbegin_switch_stmt, finish_switch_cond): Update to match.\n \n@@ -165,7 +183,7 @@\n \t\t* cp-tree.h: Fix typo.\n \n \t\t* cp-tree.h: Include cgraph.h\n-\t\t(DECL_NEEDED_P): Use cgraph_*node on the decl instead of \n+\t\t(DECL_NEEDED_P): Use cgraph_*node on the decl instead of\n \t\tTREE_SYMBOL_REFERENCED on the DECL_ASSEMBLER_NAME of the decl.\n \n 2004-06-12  Jason Merrill  <jason@redhat.com>\n@@ -288,8 +306,8 @@\n \n \tPR c++/15554\n \t* pt.c (tsubst_copy): Do not try to substitute for an enumeration\n-\tconstant in a non-dependent context. \n-\t\n+\tconstant in a non-dependent context.\n+\n \tPR c++/15057\n \t* except.c (build_throw): Ensure that temp_expr has been\n \tinitialized.\n@@ -316,7 +334,7 @@\n \t* decl2.c (maybe_emit_vtables): If TARGET_WEAK_NOT_IN_ARCHIVE_TOC\n \tis nonzero, and if we see a noninline definition of a key method,\n \tmake the vtables nonweak.\n-\t\n+\n 2004-06-02  Matt Austern  <austern@apple.com>\n \n \t* cp-tree.h (instantiate_decl): new boolean parameter,\n@@ -335,7 +353,7 @@\n \tchange it to an implicit instantiation.\n \t(instantiate_pending_templates): Add new argument to instantiate_decl.\n \t* tree.c (cp_cannot_inline_tree_fn): Likewise.\n-\t\n+\n 2004-06-02  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \t* cp-tree.h: Fix typo."}, {"sha": "757ca08e845db45f949c3e8746c81fbd61970ad7", "filename": "gcc/cp/cp-lang.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Fcp%2Fcp-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Fcp%2Fcp-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-lang.c?ref=84b8b0e04d42732ea65d452aa74e3575f75de10b", "patch": "@@ -353,3 +353,10 @@ void\n pop_file_scope (void)\n {\n }\n+\n+/* c-pragma.c needs to query whether a decl has extern \"C\" linkage.  */\n+bool\n+has_c_linkage (tree decl)\n+{\n+  return DECL_EXTERN_C_P (decl);\n+}"}, {"sha": "1838c8288f9b6259792b251f5b2578d24ae12618", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=84b8b0e04d42732ea65d452aa74e3575f75de10b", "patch": "@@ -3855,7 +3855,6 @@ extern void cxx_finish (void);\n \n /* in method.c */\n extern void init_method\t(void);\n-extern void set_mangled_name_for_decl (tree);\n extern tree make_thunk (tree, bool, tree, tree);\n extern void finish_thunk (tree);\n extern void use_thunk (tree, bool);"}, {"sha": "dfdfe564991dfc683b45a0b45f1bd2f69a0a2151", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=84b8b0e04d42732ea65d452aa74e3575f75de10b", "patch": "@@ -1259,7 +1259,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t    return NULL_TREE;\n \n \t  /* Replace the old RTL to avoid problems with inlining.  */\n-\t  SET_DECL_RTL (olddecl, DECL_RTL (newdecl));\n+\t  COPY_DECL_RTL (newdecl, olddecl);\n \t}\n       /* Even if the types match, prefer the new declarations type\n \t for anticipated built-ins, for exception lists, etc...  */\n@@ -1288,7 +1288,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t     that all remnants of the builtin-ness of this function\n \t     will be banished.  */\n \t  SET_DECL_LANGUAGE (olddecl, DECL_LANGUAGE (newdecl));\n-\t  SET_DECL_RTL (olddecl, DECL_RTL (newdecl));\n+\t  COPY_DECL_RTL (newdecl, olddecl);\n \t}\n     }\n   else if (TREE_CODE (olddecl) != TREE_CODE (newdecl))\n@@ -1827,7 +1827,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t{\n \t  SET_DECL_LANGUAGE (olddecl, DECL_LANGUAGE (newdecl));\n \t  COPY_DECL_ASSEMBLER_NAME (newdecl, olddecl);\n-\t  SET_DECL_RTL (olddecl, DECL_RTL (newdecl));\n+\t  COPY_DECL_RTL (newdecl, olddecl);\n \t}\n       if (! types_match || new_defines_function)\n \t{\n@@ -1851,7 +1851,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t      DECL_FUNCTION_CODE (newdecl) = DECL_FUNCTION_CODE (olddecl);\n \t      /* If we're keeping the built-in definition, keep the rtl,\n \t\t regardless of declaration matches.  */\n-\t      SET_DECL_RTL (newdecl, DECL_RTL (olddecl));\n+\t      COPY_DECL_RTL (olddecl, newdecl);\n \t    }\n \n \t  DECL_RESULT (newdecl) = DECL_RESULT (olddecl);\n@@ -3183,7 +3183,6 @@ builtin_function_1 (const char* name,\n      function in the namespace.  */\n   if (libname)\n     SET_DECL_ASSEMBLER_NAME (decl, get_identifier (libname));\n-  make_decl_rtl (decl, NULL);\n \n   /* Warn if a function in the namespace for users\n      is used without an occasion to consider it declared.  */\n@@ -3271,7 +3270,6 @@ build_cp_library_fn (tree name, enum tree_code operator_code, tree type)\n   TREE_NOTHROW (fn) = TYPE_NOTHROW_P (type);\n   DECL_CONTEXT (fn) = FROB_CONTEXT (current_namespace);\n   SET_DECL_LANGUAGE (fn, lang_cplusplus);\n-  set_mangled_name_for_decl (fn);\n   return fn;\n }\n \n@@ -5829,12 +5827,6 @@ grokvardecl (tree type,\n   else\n     DECL_CONTEXT (decl) = scope;\n \n-  if (name && scope && current_lang_name != lang_name_c)\n-    /* We can't mangle lazily here because we don't have any\n-       way to recover whether or not a variable was `extern\n-       \"C\"' later.  */\n-    mangle_decl (decl);\n-\n   if (RIDBIT_SETP (RID_EXTERN, specbits))\n     {\n       DECL_THIS_EXTERN (decl) = 1;"}, {"sha": "e978a5416a8f53e18629d31bf3eb228c634008c9", "filename": "gcc/cp/except.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=84b8b0e04d42732ea65d452aa74e3575f75de10b", "patch": "@@ -841,7 +841,10 @@ nothrow_libfn_p (tree fn)\n     /* Can't be a C library function.  */\n     return 0;\n \n-  id = DECL_ASSEMBLER_NAME (fn);\n+  /* Being a C library function, DECL_ASSEMBLER_NAME == DECL_NAME\n+     unless the system headers are playing rename tricks, and if\n+     they are, we don't want to be confused by them.  */\n+  id = DECL_NAME (fn);\n   return !!libc_name_p (IDENTIFIER_POINTER (id), IDENTIFIER_LENGTH (id));\n }\n "}, {"sha": "357ea868ed327bc65892ed7942c17b570ff227e5", "filename": "gcc/cp/method.c", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=84b8b0e04d42732ea65d452aa74e3575f75de10b", "patch": "@@ -71,20 +71,6 @@ init_method (void)\n {\n   init_mangle ();\n }\n-\n-\f\n-/* Set the mangled name (DECL_ASSEMBLER_NAME) for DECL.  */\n-\n-void\n-set_mangled_name_for_decl (tree decl)\n-{\n-  if (processing_template_decl)\n-    /* There's no need to mangle the name of a template function.  */\n-    return;\n-\n-  mangle_decl (decl);\n-}\n-\n \f\n /* Return a this or result adjusting thunk to FUNCTION.  THIS_ADJUSTING\n    indicates whether it is a this or result adjusting thunk."}, {"sha": "1b755c92320a838873c64974057ce76c699860f6", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=84b8b0e04d42732ea65d452aa74e3575f75de10b", "patch": "@@ -677,9 +677,15 @@ pushdecl (tree x)\n \t      if (decls_match (x, t))\n \t\t/* The standard only says that the local extern\n \t\t   inherits linkage from the previous decl; in\n-\t\t   particular, default args are not shared.  It would\n-\t\t   be nice to propagate inlining info, though.  FIXME.  */\n-\t\tTREE_PUBLIC (x) = TREE_PUBLIC (t);\n+\t\t   particular, default args are not shared.  We must\n+\t\t   also tell cgraph to treat these decls as the same,\n+\t\t   or we may neglect to emit an \"unused\" static - we\n+\t\t   do this by making the DECL_UIDs equal, which should\n+\t\t   be viewed as a kludge.  FIXME.  */\n+\t\t{\n+\t\t  TREE_PUBLIC (x) = TREE_PUBLIC (t);\n+\t\t  DECL_UID (x) = DECL_UID (t);\n+\t\t}\n \t    }\n \t  else if (TREE_CODE (t) == PARM_DECL)\n \t    {"}, {"sha": "95040834cc8c39aecf248659c0dba132148b317f", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=84b8b0e04d42732ea65d452aa74e3575f75de10b", "patch": "@@ -4318,7 +4318,6 @@ cxx_mark_addressable (tree exp)\n \n       case FUNCTION_DECL:\n \tTREE_ADDRESSABLE (x) = 1;\n-\tTREE_ADDRESSABLE (DECL_ASSEMBLER_NAME (x)) = 1;\n \treturn true;\n \n       case CONSTRUCTOR:"}, {"sha": "6c8ea7d07543161cece95c66d28d6309cd3d2268", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 51, "deletions": 29, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=84b8b0e04d42732ea65d452aa74e3575f75de10b", "patch": "@@ -7197,8 +7197,7 @@ for further explanation.\n * ARM Pragmas::\n * RS/6000 and PowerPC Pragmas::\n * Darwin Pragmas::\n-* Solaris Pragmas::\n-* Tru64 Pragmas::\n+* Symbol-Renaming Pragmas::\n @end menu\n \n @node ARM Pragmas\n@@ -7282,45 +7281,68 @@ that of the @code{unused} attribute, except that this pragma may appear\n anywhere within the variables' scopes.\n @end table\n \n-@node Solaris Pragmas\n-@subsection Solaris Pragmas\n+@node Symbol-Renaming Pragmas\n+@subsection Symbol-Renaming Pragmas\n \n-For compatibility with the SunPRO compiler, the following pragma\n-is supported.\n+For compatibility with the Solaris and Tru64 UNIX system headers, GCC\n+supports two @code{#pragma} directives which change the name used in\n+assembly for a given declaration.  These pragmas are only available on\n+platforms whose system headers need them.  To get this effect on all\n+platforms supported by GCC, use the asm labels extension (@pxref{Asm\n+Labels}).\n \n @table @code\n @item redefine_extname @var{oldname} @var{newname}\n @cindex pragma, redefine_extname\n \n-This pragma gives the C function @var{oldname} the assembler label\n-@var{newname}.  The pragma must appear before the function declaration.\n-This pragma is equivalent to the asm labels extension (@pxref{Asm\n-Labels}).  The preprocessor defines @code{__PRAGMA_REDEFINE_EXTNAME}\n-if the pragma is available.\n-@end table\n-\n-@node Tru64 Pragmas\n-@subsection Tru64 Pragmas\n-\n-For compatibility with the Compaq C compiler, the following pragma\n-is supported.\n+This pragma gives the C function @var{oldname} the assembly symbol\n+@var{newname}.  The preprocessor macro @code{__PRAGMA_REDEFINE_EXTNAME}\n+will be defined if this pragma is available (currently only on\n+Solaris).\n \n-@table @code\n @item extern_prefix @var{string}\n @cindex pragma, extern_prefix\n \n-This pragma renames all subsequent function and variable declarations\n-such that @var{string} is prepended to the name.  This effect may be\n-terminated by using another @code{extern_prefix} pragma with the\n-empty string.\n-\n-This pragma is similar in intent to to the asm labels extension\n-(@pxref{Asm Labels}) in that the system programmer wants to change\n-the assembly-level ABI without changing the source-level API.  The\n-preprocessor defines @code{__PRAGMA_EXTERN_PREFIX} if the pragma is\n-available.\n+This pragma causes all subsequent external function and variable\n+declarations to have @var{string} prepended to their assembly symbols.\n+This effect may be terminated with another @code{extern_prefix} pragma\n+whose argument is an empty string.  The preprocessor macro\n+@code{__PRAGMA_EXTERN_PREFIX} will be defined if this pragma is\n+available (currently only on Tru64 UNIX).\n @end table\n \n+These pragmas and the asm labels extension interact in a complicated\n+manner.  Here are some corner cases you may want to be aware of.\n+\n+@enumerate\n+@item Both pragmas silently apply only to declarations with external\n+linkage.  Asm labels do not have this restriction.\n+\n+@item In C++, both pragmas silently apply only to declarations with\n+``C'' linkage.  Again, asm labels do not have this restriction.\n+\n+@item If any of the three ways of changing the assembly name of a\n+declaration is applied to a declaration whose assembly name has\n+already been determined (either by a previous use of one of these\n+features, or because the compiler needed the assembly name in order to\n+generate code), and the new name is different, a warning issues and\n+the name does not change.\n+\n+@item The @var{oldname} used by @code{#pragma redefine_extname} is\n+always the C-language name.\n+\n+@item If @code{#pragma extern_prefix} is in effect, and a declaration\n+occurs with an asm label attached, the prefix is silently ignored for\n+that declaration.\n+\n+@item If @code{#pragma extern_prefix} and @code{#pragma redefine_extname}\n+apply to the same declaration, whichever triggered first wins, and a\n+warning issues if they contradict each other.  (We would like to have\n+@code{#pragma redefine_extname} always win, for consistency with asm\n+labels, but if @code{#pragma extern_prefix} triggers first we have no\n+way of knowing that that happened.)\n+@end enumerate\n+\n @node Unnamed Fields\n @section Unnamed struct/union fields within structs/unions.\n @cindex struct"}, {"sha": "abbfb41752f948813d53ca9aa6618fbd3b903b3f", "filename": "gcc/system.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=84b8b0e04d42732ea65d452aa74e3575f75de10b", "patch": "@@ -579,7 +579,8 @@ extern int snprintf (char *, size_t, const char *, ...);\n \tSTRUCT_VALUE_INCOMING STRICT_ARGUMENT_NAMING\t\t\t\\\n \tPROMOTE_FUNCTION_RETURN PROMOTE_PROTOTYPES STRUCT_VALUE_REGNUM\t\\\n \tSETUP_INCOMING_VARARGS EXPAND_BUILTIN_SAVEREGS\t\t\t\\\n-\tDEFAULT_SHORT_ENUMS SPLIT_COMPLEX_ARGS MD_ASM_CLOBBERS\n+\tDEFAULT_SHORT_ENUMS SPLIT_COMPLEX_ARGS MD_ASM_CLOBBERS\t\t\\\n+\tHANDLE_PRAGMA_REDEFINE_EXTNAME HANDLE_PRAGMA_EXTERN_PREFIX\n \n /* Other obsolete target macros, or macros that used to be in target\n    headers and were not used, and may be obsolete or may never have"}, {"sha": "c537c9f70e0f82e052210870db1e4ef3df07f193", "filename": "gcc/target-def.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=84b8b0e04d42732ea65d452aa74e3575f75de10b", "patch": "@@ -381,6 +381,15 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n    TARGET_GIMPLIFY_VA_ARG_EXPR,\t\t\t\t\t\\\n    }\n \n+\n+#ifndef TARGET_HANDLE_PRAGMA_REDEFINE_EXTNAME\n+#define TARGET_HANDLE_PRAGMA_REDEFINE_EXTNAME 0\n+#endif\n+\n+#ifndef TARGET_HANDLE_PRAGMA_EXTERN_PREFIX\n+#define TARGET_HANDLE_PRAGMA_EXTERN_PREFIX 0\n+#endif\n+\n /* The whole shebang.  */\n #define TARGET_INITIALIZER\t\t\t\\\n {\t\t\t\t\t\t\\\n@@ -433,6 +442,8 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n   TARGET_TERMINATE_DW2_EH_FRAME_INFO,\t\t\\\n   TARGET_ASM_FILE_START_APP_OFF,\t\t\\\n   TARGET_ASM_FILE_START_FILE_DIRECTIVE,\t\t\\\n+  TARGET_HANDLE_PRAGMA_REDEFINE_EXTNAME,\t\\\n+  TARGET_HANDLE_PRAGMA_EXTERN_PREFIX,\t\t\\\n }\n \n #include \"hooks.h\""}, {"sha": "902db41fd9abff1a2214bb8346449e8e5d856d8d", "filename": "gcc/target.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=84b8b0e04d42732ea65d452aa74e3575f75de10b", "patch": "@@ -502,6 +502,12 @@ struct gcc_target\n      at the beginning of assembly output.  */\n   bool file_start_file_directive;\n \n+  /* True if #pragma redefine_extname is to be supported.  */\n+  bool handle_pragma_redefine_extname;\n+\n+  /* True if #pragma extern_prefix is to be supported.  */\n+  bool handle_pragma_extern_prefix;\n+\n   /* Leave the boolean fields at the end.  */\n };\n "}, {"sha": "3cee3778ddf818661ea2416beb4a7f2334520874", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=84b8b0e04d42732ea65d452aa74e3575f75de10b", "patch": "@@ -1,6 +1,12 @@\n+2004-06-20  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* g++.dg/expr/enum1.C, g++.dg/opt/const3.C: Declare abort with\n+\textern \"C\".\n+\t* g++.dg/other/pragma-re-1.C: Add comments.\n+\n 2004-06-19  Bud Davis  <bdavis9659@comcast.net>\n- \n-        PR gfortran/16080\n+\n+\tPR gfortran/16080\n \t* gfortran.fortran-torture/execute/read_null_string.f90: New file.\n \n 2004-06-19  Andrew Pinski  <pinskia@physics.uc.edu>"}, {"sha": "40dc5faf66da5415b961ed7a8e64cda129783cbf", "filename": "gcc/testsuite/g++.dg/expr/enum1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fenum1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fenum1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fenum1.C?ref=84b8b0e04d42732ea65d452aa74e3575f75de10b", "patch": "@@ -1,6 +1,6 @@\n // { dg-do run }\n \n-void abort();\n+extern \"C\" void abort();\n int main()\n {\n     enum { shelf = 4 } t = shelf;"}, {"sha": "c7c0a1645de77e1eb743842d656d2e482b1da364", "filename": "gcc/testsuite/g++.dg/opt/const3.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fconst3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fconst3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fconst3.C?ref=84b8b0e04d42732ea65d452aa74e3575f75de10b", "patch": "@@ -5,7 +5,7 @@\n // { dg-do run }\n // { dg-options \"-O2\" }\n \n-extern void abort(void);\n+extern \"C\" void abort(void);\n \n typedef __SIZE_TYPE__ size_t;\n "}, {"sha": "b29ac99ba4ee8a346da03c4bfc93b81167478a5b", "filename": "gcc/testsuite/g++.dg/other/pragma-re-1.C", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fpragma-re-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b8b0e04d42732ea65d452aa74e3575f75de10b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fpragma-re-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fpragma-re-1.C?ref=84b8b0e04d42732ea65d452aa74e3575f75de10b", "patch": "@@ -8,10 +8,13 @@\n #error \n #endif\n \n+/* This one is expected to work.  */\n #pragma redefine_extname foo bar\n extern \"C\" int foo(void);\n void *p = (void *)foo;\n \n+/* This one is expected not to work (redefine_extname\n+   can only be applied to extern \"C\" names).  */\n #pragma redefine_extname baz baq\n extern int baz(void);\n void *q = (void *)baz;"}]}