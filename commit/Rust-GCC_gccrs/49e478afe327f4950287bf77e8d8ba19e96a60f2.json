{"sha": "49e478afe327f4950287bf77e8d8ba19e96a60f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDllNDc4YWZlMzI3ZjQ5NTAyODdiZjc3ZThkOGJhMTllOTZhNjBmMg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-06-07T06:45:36Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-06-07T06:45:36Z"}, "message": "Clarify define_insn documentation\n\nThis patch tries to clarify some of the restrictions on define_insn\nconditions, and also on the use of \"#\".\n\n2017-06-06  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* doc/md.texi: Clarify the restrictions on a define_insn condition.\n\tSay that # requires an associated define_split to exist, and that\n\tthe define_split must be suitable for use after register allocation.\n\nFrom-SVN: r248946", "tree": {"sha": "e5044a5411513fdaa02c8c32f312b7ba54c89e92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e5044a5411513fdaa02c8c32f312b7ba54c89e92"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/49e478afe327f4950287bf77e8d8ba19e96a60f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49e478afe327f4950287bf77e8d8ba19e96a60f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49e478afe327f4950287bf77e8d8ba19e96a60f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49e478afe327f4950287bf77e8d8ba19e96a60f2/comments", "author": null, "committer": null, "parents": [{"sha": "6fcdf714130596ac05167398c56897d72ab3e759", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fcdf714130596ac05167398c56897d72ab3e759", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fcdf714130596ac05167398c56897d72ab3e759"}], "stats": {"total": 31, "additions": 27, "deletions": 4}, "files": [{"sha": "a5aaf47b5a4f2f6bfd825d82f87bc4b056af9ecd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49e478afe327f4950287bf77e8d8ba19e96a60f2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49e478afe327f4950287bf77e8d8ba19e96a60f2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=49e478afe327f4950287bf77e8d8ba19e96a60f2", "patch": "@@ -1,3 +1,9 @@\n+2017-06-07  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* doc/md.texi: Clarify the restrictions on a define_insn condition.\n+\tSay that # requires an associated define_split to exist, and that\n+\tthe define_split must be suitable for use after register allocation.\n+\n 2017-06-06  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* cfgbuild.c (find_bb_boundaries): Initialize profile of split blocks."}, {"sha": "5a00a2c45c7d24464094e42c20aedc51e74e5a22", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49e478afe327f4950287bf77e8d8ba19e96a60f2/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49e478afe327f4950287bf77e8d8ba19e96a60f2/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=49e478afe327f4950287bf77e8d8ba19e96a60f2", "patch": "@@ -115,7 +115,7 @@ A @code{define_insn} is an RTL expression containing four or five operands:\n \n @enumerate\n @item\n-An optional name.  The presence of a name indicate that this instruction\n+An optional name.  The presence of a name indicates that this instruction\n pattern can perform a certain standard job for the RTL-generation\n pass of the compiler.  This pass knows certain names and will use\n the instruction patterns with those names, if the names are defined\n@@ -166,9 +166,21 @@ individual insn, and only after the insn has matched the pattern's\n recognition template.  The insn's operands may be found in the vector\n @code{operands}.\n \n-For an insn where the condition has once matched, it\n-cannot later be used to control register allocation by excluding\n-certain register or value combinations.\n+An instruction condition cannot become more restrictive as compilation\n+progresses.  If the condition accepts a particular RTL instruction at\n+one stage of compilation, it must continue to accept that instruction\n+until the final pass.  For example, @samp{!reload_completed} and\n+@samp{can_create_pseudo_p ()} are both invalid instruction conditions,\n+because they are true during the earlier RTL passes and false during\n+the later ones.  For the same reason, if a condition accepts an\n+instruction before register allocation, it cannot later try to control\n+register allocation by excluding certain register or value combinations.\n+\n+Although a condition cannot become more restrictive as compilation\n+progresses, the condition for a nameless pattern @emph{can} become\n+more permissive.  For example, a nameless instruction can require\n+@samp{reload_completed} to be true, in which case it only matches\n+after register allocation.\n \n @item\n The @dfn{output template} or @dfn{output statement}: This is either\n@@ -561,6 +573,11 @@ already defined, then you can simply use @code{#} as the output template\n instead of writing an output template that emits the multiple assembler\n instructions.\n \n+Note that @code{#} only has an effect while generating assembly code;\n+it does not affect whether a split occurs earlier.  An associated\n+@code{define_split} must exist and it must be suitable for use after\n+register allocation.\n+\n If the macro @code{ASSEMBLER_DIALECT} is defined, you can use construct\n of the form @samp{@{option0|option1|option2@}} in the templates.  These\n describe multiple variants of assembler language syntax."}]}