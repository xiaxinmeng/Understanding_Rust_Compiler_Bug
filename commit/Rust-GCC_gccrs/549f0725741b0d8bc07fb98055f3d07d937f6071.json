{"sha": "549f0725741b0d8bc07fb98055f3d07d937f6071", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQ5ZjA3MjU3NDFiMGQ4YmMwN2ZiOTgwNTVmM2QwN2Q5MzdmNjA3MQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-05-08T22:08:25Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-05-08T22:08:25Z"}, "message": "ia64.c (ia64_encode_section_info): Exit early for global register variables...\n\n        * config/ia64/ia64.c (ia64_encode_section_info): Exit early\n        for global register variables; don't special case __[CD]TOR_LIST__;\n        mind ggc_p for string allocation.\n\nFrom-SVN: r33776", "tree": {"sha": "8b1cb8d390e04bef7419275be7bb7c3da31efa59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b1cb8d390e04bef7419275be7bb7c3da31efa59"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/549f0725741b0d8bc07fb98055f3d07d937f6071", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/549f0725741b0d8bc07fb98055f3d07d937f6071", "html_url": "https://github.com/Rust-GCC/gccrs/commit/549f0725741b0d8bc07fb98055f3d07d937f6071", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/549f0725741b0d8bc07fb98055f3d07d937f6071/comments", "author": null, "committer": null, "parents": [{"sha": "4fb9b83058f9bb7c27c2fde58ef724a316a7b97f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fb9b83058f9bb7c27c2fde58ef724a316a7b97f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fb9b83058f9bb7c27c2fde58ef724a316a7b97f"}], "stats": {"total": 90, "additions": 50, "deletions": 40}, "files": [{"sha": "bdecf41b7783566a30f5401eef7adf40dd8f0d86", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/549f0725741b0d8bc07fb98055f3d07d937f6071/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/549f0725741b0d8bc07fb98055f3d07d937f6071/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=549f0725741b0d8bc07fb98055f3d07d937f6071", "patch": "@@ -3,6 +3,10 @@\n \t* flow.c (init_propagate_block_info): Watch out for conditional\n \tbranch to next instruction, and thus one outgoing edge.\n \n+\t* config/ia64/ia64.c (ia64_encode_section_info): Exit early\n+\tfor global register variables; don't special case __[CD]TOR_LIST__;\n+\tmind ggc_p for string allocation.\n+\n 2000-05-08  Nick Clifton  <nickc@cygnus.com>\n \n \t* config/i386/i386.h (ELIMINABLE_REGS): Fix comment."}, {"sha": "e563d025ad35ca5e924bc424fea1936dfbb103b4", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 46, "deletions": 40, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/549f0725741b0d8bc07fb98055f3d07d937f6071/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/549f0725741b0d8bc07fb98055f3d07d937f6071/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=549f0725741b0d8bc07fb98055f3d07d937f6071", "patch": "@@ -2823,78 +2823,84 @@ void\n ia64_encode_section_info (decl)\n      tree decl;\n {\n+  const char *symbol_str;\n+\n   if (TREE_CODE (decl) == FUNCTION_DECL)\n-    SYMBOL_REF_FLAG (XEXP (DECL_RTL (decl), 0)) = 1;\n+    {\n+      SYMBOL_REF_FLAG (XEXP (DECL_RTL (decl), 0)) = 1;\n+      return;\n+    }\n+\n+  /* Careful not to prod global register variables.  */\n+  if (TREE_CODE (decl) != VAR_DECL\n+      || GET_CODE (DECL_RTL (decl)) != SYMBOL_REF)\n+    return;\n+    \n+  symbol_str = XSTR (XEXP (DECL_RTL (decl), 0), 0);\n+\n   /* We assume that -fpic is used only to create a shared library (dso).\n      With -fpic, no global data can ever be sdata.\n      Without -fpic, global common uninitialized data can never be sdata, since\n      it can unify with a real definition in a dso.  */\n   /* ??? Actually, we can put globals in sdata, as long as we don't use gprel\n      to access them.  The linker may then be able to do linker relaxation to\n      optimize references to them.  Currently sdata implies use of gprel.  */\n-  else if (! TARGET_NO_SDATA\n-\t   && TREE_CODE (decl) == VAR_DECL\n-\t   && TREE_STATIC (decl)\n-\t   && ! (DECL_ONE_ONLY (decl) || DECL_WEAK (decl))\n-\t   && ! (TREE_PUBLIC (decl)\n-\t\t && (flag_pic\n-\t\t     || (DECL_COMMON (decl)\n-\t\t\t && (DECL_INITIAL (decl) == 0\n-\t\t\t     || DECL_INITIAL (decl) == error_mark_node))))\n-\t   /* Either the variable must be declared without a section attribute,\n-\t      or the section must be sdata or sbss.  */\n-\t   && (DECL_SECTION_NAME (decl) == 0\n-\t       || ! strcmp (TREE_STRING_POINTER (DECL_SECTION_NAME (decl)),\n-\t\t\t    \".sdata\")\n-\t       || ! strcmp (TREE_STRING_POINTER (DECL_SECTION_NAME (decl)),\n-\t\t\t    \".sbss\")))\n+  if (! TARGET_NO_SDATA\n+      && TREE_STATIC (decl)\n+      && ! (DECL_ONE_ONLY (decl) || DECL_WEAK (decl))\n+      && ! (TREE_PUBLIC (decl)\n+\t    && (flag_pic\n+\t\t|| (DECL_COMMON (decl)\n+\t\t    && (DECL_INITIAL (decl) == 0\n+\t\t\t|| DECL_INITIAL (decl) == error_mark_node))))\n+      /* Either the variable must be declared without a section attribute,\n+\t or the section must be sdata or sbss.  */\n+      && (DECL_SECTION_NAME (decl) == 0\n+\t  || ! strcmp (TREE_STRING_POINTER (DECL_SECTION_NAME (decl)),\n+\t\t       \".sdata\")\n+\t  || ! strcmp (TREE_STRING_POINTER (DECL_SECTION_NAME (decl)),\n+\t\t       \".sbss\")))\n     {\n       int size = int_size_in_bytes (TREE_TYPE (decl));\n-      const char *str = XSTR (XEXP (DECL_RTL (decl), 0), 0);\n-\n-      /* ??? We should redeclare CTOR_LIST, DTOR_END so that we don't have to\n-\t special case them here.  Currently we put them in ctor/dtors sections\n-\t behind the compiler's back.  We should use section attributes\n-\t instead.  */\n-      if (! strcmp (str, \"__CTOR_LIST__\")\n-\t  || ! strcmp (str, \"__DTOR_END__\"))\n-\t;\n \n       /* If the variable has already been defined in the output file, then it\n \t is too late to put it in sdata if it wasn't put there in the first\n \t place.  The test is here rather than above, because if it is already\n \t in sdata, then it can stay there.  */\n \n-      else if (TREE_ASM_WRITTEN (decl))\n+      if (TREE_ASM_WRITTEN (decl))\n \t;\n \n       /* If this is an incomplete type with size 0, then we can't put it in\n \t sdata because it might be too big when completed.  */\n       else if (size > 0 && size <= ia64_section_threshold\n-\t       && str[0] != SDATA_NAME_FLAG_CHAR)\n+\t       && symbol_str[0] != SDATA_NAME_FLAG_CHAR)\n \t{\n-\t  int len = strlen (str);\n-\t  char *newstr = obstack_alloc (saveable_obstack, len + 2);\n+\t  int len = strlen (symbol_str);\n+\t  char *newstr;\n+\n+\t  if (ggc_p)\n+\t    newstr = ggc_alloc_string (NULL, len + 1);\n+\t  else\n+\t    newstr = obstack_alloc (saveable_obstack, len + 2);\n \n-\t  strcpy (newstr + 1, str);\n \t  *newstr = SDATA_NAME_FLAG_CHAR;\n+\t  memcpy (newstr + 1, symbol_str, len + 1);\n+\n \t  XSTR (XEXP (DECL_RTL (decl), 0), 0) = newstr;\n \t}\n     }\n   /* This decl is marked as being in small data/bss but it shouldn't\n      be; one likely explanation for this is that the decl has been\n      moved into a different section from the one it was in when\n      ENCODE_SECTION_INFO was first called.  Remove the '@'.*/\n-  else if (TREE_CODE (decl) == VAR_DECL\n-\t   && (XSTR (XEXP (DECL_RTL (decl), 0), 0)[0]\n-\t       == SDATA_NAME_FLAG_CHAR))\n+  else if (symbol_str[0] == SDATA_NAME_FLAG_CHAR)\n     {\n-      const char *str = XSTR (XEXP (DECL_RTL (decl), 0), 0);\n-      int len = strlen (str);\n-      char *newstr = obstack_alloc (saveable_obstack, len);\n-\n-      strcpy (newstr, str + 1);\n-      XSTR (XEXP (DECL_RTL (decl), 0), 0) = newstr;\n+      if (ggc_p)\n+\tXSTR (XEXP (DECL_RTL (decl), 0), 0)\n+\t  = ggc_alloc_string (symbol_str + 1, -1);\n+      else\n+        XSTR (XEXP (DECL_RTL (decl), 0), 0) = symbol_str + 1;\n     }\n }\n \f"}]}