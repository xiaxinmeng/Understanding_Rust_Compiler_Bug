{"sha": "c5cbcccf9019f6ed28209f903245cce9cfc73e40", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzVjYmNjY2Y5MDE5ZjZlZDI4MjA5ZjkwMzI0NWNjZTljZmM3M2U0MA==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2005-03-11T09:05:12Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2005-03-11T09:05:12Z"}, "message": "basic-block.h (single_succ_p, [...]): New inline functions.\n\n\t* basic-block.h (single_succ_p, single_pred_p, single_succ_edge,\n\tsingle_pred_edge, single_succ, single_pred): New inline functions.\n\t* bb-reorder.c (rotate_loop, find_traces_1_round,\n\tadd_labels_and_missing_jumps, fix_up_fall_thru_edges,\n\tduplicate_computed_gotos): Use the single_succ/pred functions.\n\t* cfganal.c (forwarder_block_p): Ditto.\n\t* cfgbuild.c (compute_outgoing_frequencies): Ditto.\n\t* cfgcleanup.c (try_simplify_condjump, try_forward_edges,\n\toutgoing_edges_match, try_crossjump_to_edge, try_optimize_cfg,\n\tmerge_seq_blocks): Ditto.\n\t* cfghooks.c (split_edge, tidy_fallthru_edges): Ditto.\n\t* cfglayout.c (fixup_reorder_chain): Ditto.\n\t* cfgloop.c (mark_single_exit_loops, update_latch_info,\n\tcanonicalize_loop_headers, verify_loop_structure): Ditto.\n\t* cfgloopmanip.c (remove_path, unloop, loop_delete_branch_edge,\n\tmfb_update_loops, create_preheader, force_single_succ_latches,\n\tcreate_loop_notes): Ditto.\n\t* cfgrtl.c (rtl_can_merge_blocks, try_redirect_by_replacing_jump,\n\tforce_nonfallthru_and_redirect, rtl_tidy_fallthru_edge,\n\tcommit_one_edge_insertion, purge_dead_edges,\n\tcfg_layout_can_merge_blocks_p): Ditto.\n\t* except.c (sjlj_emit_function_enter): Ditto.\n\t* flow.c (init_propagate_block_info): Ditto.\n\t* function.c (thread_prologue_and_epilogue_insns): Ditto.\n\t* gcse.c (find_implicit_sets, bypass_conditional_jumps,\n\tinsert_insn_end_bb): Ditto.\n\t* ifcvt.c (merge_if_block, find_if_block, find_if_case_1,\n\tfind_if_case_2): Ditto.\n\t* lambda-code.c (perfect_nestify): Ditto.\n\t* lcm.c (optimize_mode_switching): Ditto.\n\t* loop-doloop.c (doloop_modify): Ditto.\n\t* loop-init.c (loop_optimizer_init): Ditto.\n\t* loop-iv.c (simplify_using_initial_values): Ditto.\n\t* loop-unroll.c (unroll_loop_runtime_iterations): Ditto.\n\t* loop-unswitch.c (unswitch_loop): Ditto.\n\t* modulo-sched.c (generate_prolog_epilog): Ditto.\n\t* predict.c (combine_predictions_for_insn, estimate_probability,\n\ttree_estimate_probability, last_basic_block_p,\n\testimate_bb_frequencies): Ditto.\n\t* profile.c (branch_prob): Ditto.\n\t* regrename.c (copyprop_hardreg_forward): Ditto.\n\t* sched-rgn.c (is_cfg_nonregular, find_rgns, update_live): Ditto.\n\t* tracer.c (layout_superblocks): Ditto.\n\t* tree-cfg.c (tree_can_merge_blocks_p, tree_merge_blocks,\n\tcfg_remove_useless_stmts_bb, cleanup_control_flow,\n\tcleanup_control_expr_graph, disband_implicit_edges,\n\ttree_find_edge_insert_loc, bsi_commit_edge_inserts,\n\ttree_verify_flow_info, tree_make_forwarder_block,\n\ttree_forwarder_block_p, remove_forwarder_block,\n\tremove_forwarder_block_with_phi, merge_phi_nodes): Ditto.\n\t* tree-if-conv.c (tree_if_conversion): Ditto.\n\t* tree-mudflap.c (mf_build_check_statement_for): Ditto.\n\t* tree-ssa-dce.c (remove_dead_stmt): Ditto.\n\t* tree-ssa-dom.c (dom_opt_finalize_block): Ditto.\n\t* tree-ssa-loop-ch.c (should_duplicate_loop_header_p,\n\tcopy_loop_headers): Ditto.\n\t* tree-ssa-loop-im.c (loop_commit_inserts): Ditto.\n\t* tree-ssa-loop-ivopts.c (compute_phi_arg_on_exit): Ditto.\n\t* tree-ssa-loop-manip.c (split_loop_exit_edge, ip_normal_pos,\n\tlv_adjust_loop_entry_edge, tree_ssa_loop_version): Ditto.\n\t* tree-ssa-loop-niter.c (simplify_using_initial_conditions): Ditto.\n\t* tree-ssa-loop-unswitch.c (simplify_using_entry_checks): Ditto.\n\t* tree-ssa-phiopt.c (tree_ssa_phiopt, value_replacement): Ditto.\n\t* tree-ssa-pre.c (compute_antic_aux, insert_aux, init_pre): Ditto.\n\t* tree-ssa-threadupdate.c (redirect_edges): Ditto.\n\t* tree-tailcall.c (independent_of_stmt_p, find_tail_calls,\n\teliminate_tail_call, tree_optimize_tail_calls_1): Ditto.\n\t* tree-vect-analyze.c (vect_analyze_loop_form): Ditto.\n\t* tree-vect-transform.c (vect_update_ivs_after_vectorizer): Ditto.\n\t* tree-vectorizer.c (slpeel_update_phi_nodes_for_guard,\n\tslpeel_add_loop_guard): Ditto.\n\nFrom-SVN: r96292", "tree": {"sha": "c92921efb68fbb5a7e8dd2d9a10b526b2c5a61bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c92921efb68fbb5a7e8dd2d9a10b526b2c5a61bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5cbcccf9019f6ed28209f903245cce9cfc73e40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5cbcccf9019f6ed28209f903245cce9cfc73e40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5cbcccf9019f6ed28209f903245cce9cfc73e40", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5cbcccf9019f6ed28209f903245cce9cfc73e40/comments", "author": null, "committer": null, "parents": [{"sha": "0b2df4a7037bf50942bb43ae799f88a7d6c4c261", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b2df4a7037bf50942bb43ae799f88a7d6c4c261", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b2df4a7037bf50942bb43ae799f88a7d6c4c261"}], "stats": {"total": 772, "additions": 448, "deletions": 324}, "files": [{"sha": "575baac36c0637d36b88eb07d7f81a73f4217706", "filename": "gcc/ChangeLog", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -1,3 +1,77 @@\n+2005-03-11  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* basic-block.h (single_succ_p, single_pred_p, single_succ_edge,\n+\tsingle_pred_edge, single_succ, single_pred): New inline functions.\n+\t* bb-reorder.c (rotate_loop, find_traces_1_round,\n+\tadd_labels_and_missing_jumps, fix_up_fall_thru_edges,\n+\tduplicate_computed_gotos): Use the single_succ/pred functions.\n+\t* cfganal.c (forwarder_block_p): Ditto.\n+\t* cfgbuild.c (compute_outgoing_frequencies): Ditto.\n+\t* cfgcleanup.c (try_simplify_condjump, try_forward_edges,\n+\toutgoing_edges_match, try_crossjump_to_edge, try_optimize_cfg,\n+\tmerge_seq_blocks): Ditto.\n+\t* cfghooks.c (split_edge, tidy_fallthru_edges): Ditto.\n+\t* cfglayout.c (fixup_reorder_chain): Ditto.\n+\t* cfgloop.c (mark_single_exit_loops, update_latch_info,\n+\tcanonicalize_loop_headers, verify_loop_structure): Ditto.\n+\t* cfgloopmanip.c (remove_path, unloop, loop_delete_branch_edge,\n+\tmfb_update_loops, create_preheader, force_single_succ_latches,\n+\tcreate_loop_notes): Ditto.\n+\t* cfgrtl.c (rtl_can_merge_blocks, try_redirect_by_replacing_jump,\n+\tforce_nonfallthru_and_redirect, rtl_tidy_fallthru_edge,\n+\tcommit_one_edge_insertion, purge_dead_edges,\n+\tcfg_layout_can_merge_blocks_p): Ditto.\n+\t* except.c (sjlj_emit_function_enter): Ditto.\n+\t* flow.c (init_propagate_block_info): Ditto.\n+\t* function.c (thread_prologue_and_epilogue_insns): Ditto.\n+\t* gcse.c (find_implicit_sets, bypass_conditional_jumps,\n+\tinsert_insn_end_bb): Ditto.\n+\t* ifcvt.c (merge_if_block, find_if_block, find_if_case_1,\n+\tfind_if_case_2): Ditto.\n+\t* lambda-code.c (perfect_nestify): Ditto.\n+\t* lcm.c (optimize_mode_switching): Ditto.\n+\t* loop-doloop.c (doloop_modify): Ditto.\n+\t* loop-init.c (loop_optimizer_init): Ditto.\n+\t* loop-iv.c (simplify_using_initial_values): Ditto.\n+\t* loop-unroll.c (unroll_loop_runtime_iterations): Ditto.\n+\t* loop-unswitch.c (unswitch_loop): Ditto.\n+\t* modulo-sched.c (generate_prolog_epilog): Ditto.\n+\t* predict.c (combine_predictions_for_insn, estimate_probability,\n+\ttree_estimate_probability, last_basic_block_p,\n+\testimate_bb_frequencies): Ditto.\n+\t* profile.c (branch_prob): Ditto.\n+\t* regrename.c (copyprop_hardreg_forward): Ditto.\n+\t* sched-rgn.c (is_cfg_nonregular, find_rgns, update_live): Ditto.\n+\t* tracer.c (layout_superblocks): Ditto.\n+\t* tree-cfg.c (tree_can_merge_blocks_p, tree_merge_blocks,\n+\tcfg_remove_useless_stmts_bb, cleanup_control_flow,\n+\tcleanup_control_expr_graph, disband_implicit_edges,\n+\ttree_find_edge_insert_loc, bsi_commit_edge_inserts,\n+\ttree_verify_flow_info, tree_make_forwarder_block,\n+\ttree_forwarder_block_p, remove_forwarder_block,\n+\tremove_forwarder_block_with_phi, merge_phi_nodes): Ditto.\n+\t* tree-if-conv.c (tree_if_conversion): Ditto.\n+\t* tree-mudflap.c (mf_build_check_statement_for): Ditto.\n+\t* tree-ssa-dce.c (remove_dead_stmt): Ditto.\n+\t* tree-ssa-dom.c (dom_opt_finalize_block): Ditto.\n+\t* tree-ssa-loop-ch.c (should_duplicate_loop_header_p,\n+\tcopy_loop_headers): Ditto.\n+\t* tree-ssa-loop-im.c (loop_commit_inserts): Ditto.\n+\t* tree-ssa-loop-ivopts.c (compute_phi_arg_on_exit): Ditto.\n+\t* tree-ssa-loop-manip.c (split_loop_exit_edge, ip_normal_pos,\n+\tlv_adjust_loop_entry_edge, tree_ssa_loop_version): Ditto.\n+\t* tree-ssa-loop-niter.c (simplify_using_initial_conditions): Ditto.\n+\t* tree-ssa-loop-unswitch.c (simplify_using_entry_checks): Ditto.\n+\t* tree-ssa-phiopt.c (tree_ssa_phiopt, value_replacement): Ditto.\n+\t* tree-ssa-pre.c (compute_antic_aux, insert_aux, init_pre): Ditto.\n+\t* tree-ssa-threadupdate.c (redirect_edges): Ditto.\n+\t* tree-tailcall.c (independent_of_stmt_p, find_tail_calls,\n+\teliminate_tail_call, tree_optimize_tail_calls_1): Ditto.\n+\t* tree-vect-analyze.c (vect_analyze_loop_form): Ditto.\n+\t* tree-vect-transform.c (vect_update_ivs_after_vectorizer): Ditto.\n+\t* tree-vectorizer.c (slpeel_update_phi_nodes_for_guard,\n+\tslpeel_add_loop_guard): Ditto.\n+\n 2005-03-11  James A. Morrison  <phython@gcc.gnu.org>\n \n         PR tree-optimization/15784"}, {"sha": "576784d1ed5a296125d3c22aa5c555a0f9ba9864", "filename": "gcc/basic-block.h", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -547,6 +547,56 @@ struct edge_list\n #define EDGE_PRED(bb,i)\t\t\tVEC_index  (edge, (bb)->preds, (i))\n #define EDGE_SUCC(bb,i)\t\t\tVEC_index  (edge, (bb)->succs, (i))\n \n+/* Returns true if BB has precisely one successor.  */\n+\n+static inline bool\n+single_succ_p (basic_block bb)\n+{\n+  return EDGE_COUNT (bb->succs) == 1;\n+}\n+\n+/* Returns true if BB has precisely one predecessor.  */\n+\n+static inline bool\n+single_pred_p (basic_block bb)\n+{\n+  return EDGE_COUNT (bb->preds) == 1;\n+}\n+\n+/* Returns the single successor edge of basic block BB.  */\n+\n+static inline edge\n+single_succ_edge (basic_block bb)\n+{\n+  gcc_assert (single_succ_p (bb));\n+  return EDGE_SUCC (bb, 0);\n+}\n+\n+/* Returns the single predecessor edge of basic block BB.  */\n+\n+static inline edge\n+single_pred_edge (basic_block bb)\n+{\n+  gcc_assert (single_pred_p (bb));\n+  return EDGE_PRED (bb, 0);\n+}\n+\n+/* Returns the single successor block of basic block BB.  */\n+\n+static inline basic_block\n+single_succ (basic_block bb)\n+{\n+  return single_succ_edge (bb)->dest;\n+}\n+\n+/* Returns the single predecessor block of basic block BB.  */\n+\n+static inline basic_block\n+single_pred (basic_block bb)\n+{\n+  return single_pred_edge (bb)->src;\n+}\n+\n /* Iterator object for edges.  */\n \n typedef struct {"}, {"sha": "a94c9e4e4688fdfdd65362e4f396e6d5762e2c11", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -385,18 +385,16 @@ rotate_loop (edge back_edge, struct trace *trace, int trace_n)\n \t  prev_bb->rbi->next = best_bb->rbi->next;\n \n \t  /* Try to get rid of uncond jump to cond jump.  */\n-\t  if (EDGE_COUNT (prev_bb->succs) == 1)\n+\t  if (single_succ_p (prev_bb))\n \t    {\n-\t      basic_block header = EDGE_SUCC (prev_bb, 0)->dest;\n+\t      basic_block header = single_succ (prev_bb);\n \n \t      /* Duplicate HEADER if it is a small block containing cond jump\n \t\t in the end.  */\n \t      if (any_condjump_p (BB_END (header)) && copy_bb_p (header, 0)\n \t\t  && !find_reg_note (BB_END (header), REG_CROSSING_JUMP, \n \t\t\t\t     NULL_RTX))\n-\t\t{\n-\t\t  copy_bb (header, EDGE_SUCC (prev_bb, 0), prev_bb, trace_n);\n-\t\t}\n+\t\tcopy_bb (header, single_succ_edge (prev_bb), prev_bb, trace_n);\n \t    }\n \t}\n     }\n@@ -655,7 +653,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t\t\t{\n \t\t\t  /* The loop has less than 4 iterations.  */\n \n-\t\t\t  if (EDGE_COUNT (bb->succs) == 1\n+\t\t\t  if (single_succ_p (bb)\n \t\t\t      && copy_bb_p (best_edge->dest, !optimize_size))\n \t\t\t    {\n \t\t\t      bb = copy_bb (best_edge->dest, best_edge, bb,\n@@ -695,12 +693,13 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t\t\t&& (e->flags & EDGE_CAN_FALLTHRU)\n \t\t\t&& !(e->flags & EDGE_COMPLEX)\n \t\t\t&& !e->dest->rbi->visited\n-\t\t\t&& EDGE_COUNT (e->dest->preds) == 1\n+\t\t\t&& single_pred_p (e->dest)\n \t\t\t&& !(e->flags & EDGE_CROSSING)\n-\t\t\t&& EDGE_COUNT (e->dest->succs) == 1\n-\t\t\t&& (EDGE_SUCC (e->dest, 0)->flags & EDGE_CAN_FALLTHRU)\n-\t\t\t&& !(EDGE_SUCC (e->dest, 0)->flags & EDGE_COMPLEX)\n-\t\t\t&& EDGE_SUCC (e->dest, 0)->dest == best_edge->dest\n+\t\t\t&& single_succ_p (e->dest) == 1\n+\t\t\t&& (single_succ_edge (e->dest)->flags\n+\t\t\t    & EDGE_CAN_FALLTHRU)\n+\t\t\t&& !(single_succ_edge (e->dest)->flags & EDGE_COMPLEX)\n+\t\t\t&& single_succ (e->dest) == best_edge->dest\n \t\t\t&& 2 * e->dest->frequency >= EDGE_FREQUENCY (best_edge))\n \t\t      {\n \t\t\tbest_edge = e;\n@@ -1391,7 +1390,7 @@ add_labels_and_missing_jumps (edge *crossing_edges, int n_crossing_edges)\n  \t\t    /* bb just falls through.  */\n  \t\t    {\n  \t\t      /* make sure there's only one successor */\n-\t\t      gcc_assert (EDGE_COUNT (src->succs) == 1);\n+\t\t      gcc_assert (single_succ_p (src));\n \t\t      \n \t\t      /* Find label in dest block.  */\n \t\t      label = block_label (dest);\n@@ -1533,7 +1532,7 @@ fix_up_fall_thru_edges (void)\n \t\t\t partition as bb it's falling through from.  */\n \n \t\t      BB_COPY_PARTITION (new_bb, cur_bb);\n-\t\t      EDGE_SUCC (new_bb, 0)->flags |= EDGE_CROSSING;\n+\t\t      single_succ_edge (new_bb)->flags |= EDGE_CROSSING;\n  \t\t    }\n \t\t  \n  \t\t  /* Add barrier after new jump */\n@@ -2085,17 +2084,17 @@ duplicate_computed_gotos (void)\n       /* BB must have one outgoing edge.  That edge must not lead to\n          the exit block or the next block.\n \t The destination must have more than one predecessor.  */\n-      if (EDGE_COUNT(bb->succs) != 1\n-\t  || EDGE_SUCC(bb,0)->dest == EXIT_BLOCK_PTR\n-\t  || EDGE_SUCC(bb,0)->dest == bb->next_bb\n-\t  || EDGE_COUNT(EDGE_SUCC(bb,0)->dest->preds) <= 1)\n+      if (!single_succ_p (bb)\n+\t  || single_succ (bb) == EXIT_BLOCK_PTR\n+\t  || single_succ (bb) == bb->next_bb\n+\t  || single_pred_p (single_succ (bb)))\n \tcontinue;\n \n       /* The successor block has to be a duplication candidate.  */\n-      if (!bitmap_bit_p (candidates, EDGE_SUCC(bb,0)->dest->index))\n+      if (!bitmap_bit_p (candidates, single_succ (bb)->index))\n \tcontinue;\n \n-      new_bb = duplicate_block (EDGE_SUCC(bb,0)->dest, EDGE_SUCC(bb,0));\n+      new_bb = duplicate_block (single_succ (bb), single_succ_edge (bb));\n       new_bb->rbi->next = bb->rbi->next;\n       bb->rbi->next = new_bb;\n       new_bb->rbi->visited = 1;"}, {"sha": "7cecd984a02ab5ff0546d8de454323b4827aab5a", "filename": "gcc/cfganal.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -87,7 +87,7 @@ forwarder_block_p (basic_block bb)\n   rtx insn;\n \n   if (bb == EXIT_BLOCK_PTR || bb == ENTRY_BLOCK_PTR\n-      || EDGE_COUNT (bb->succs) != 1)\n+      || !single_succ_p (bb))\n     return false;\n \n   for (insn = BB_HEAD (bb); insn != BB_END (bb); insn = NEXT_INSN (insn))"}, {"sha": "a4882e2fca14f66b70911d67d527120c4f457e77", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -708,9 +708,9 @@ compute_outgoing_frequencies (basic_block b)\n \t}\n     }\n \n-  if (EDGE_COUNT (b->succs) == 1)\n+  if (single_succ_p (b))\n     {\n-      e = EDGE_SUCC (b, 0);\n+      e = single_succ_edge (b);\n       e->probability = REG_BR_PROB_BASE;\n       e->count = b->count;\n       return;"}, {"sha": "49cbb44a9f2152359ee5cd84c07ccf5fb1c36e99", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 52, "deletions": 49, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -139,11 +139,11 @@ try_simplify_condjump (basic_block cbranch_block)\n      be the last block in the function, and must contain just the\n      unconditional jump.  */\n   jump_block = cbranch_fallthru_edge->dest;\n-  if (EDGE_COUNT (jump_block->preds) >= 2\n+  if (!single_pred_p (jump_block)\n       || jump_block->next_bb == EXIT_BLOCK_PTR\n       || !FORWARDER_BLOCK_P (jump_block))\n     return false;\n-  jump_dest_block = EDGE_SUCC (jump_block, 0)->dest;\n+  jump_dest_block = single_succ (jump_block);\n \n   /* If we are partitioning hot/cold basic blocks, we don't want to\n      mess up unconditional or indirect jumps that cross between hot\n@@ -483,13 +483,13 @@ try_forward_edges (int mode, basic_block b)\n \t  may_thread |= target->flags & BB_DIRTY;\n \n \t  if (FORWARDER_BLOCK_P (target)\n-  \t      && !(EDGE_SUCC (target, 0)->flags & EDGE_CROSSING)\n-\t      && EDGE_SUCC (target, 0)->dest != EXIT_BLOCK_PTR)\n+  \t      && !(single_succ_edge (target)->flags & EDGE_CROSSING)\n+\t      && single_succ (target) != EXIT_BLOCK_PTR)\n \t    {\n \t      /* Bypass trivial infinite loops.  */\n-\t      if (target == EDGE_SUCC (target, 0)->dest)\n+\t      new_target = single_succ (target);\n+\t      if (target == new_target)\n \t\tcounter = n_basic_blocks;\n-\t      new_target = EDGE_SUCC (target, 0)->dest;\n \t    }\n \n \t  /* Allow to thread only over one edge at time to simplify updating\n@@ -618,7 +618,7 @@ try_forward_edges (int mode, basic_block b)\n \t    {\n \t      edge t;\n \n-\t      if (EDGE_COUNT (first->succs) > 1)\n+\t      if (!single_succ_p (first))\n \t\t{\n \t\t  gcc_assert (n < nthreaded_edges);\n \t\t  t = threaded_edges [n++];\n@@ -642,7 +642,7 @@ try_forward_edges (int mode, basic_block b)\n \t\t  if (n < nthreaded_edges\n \t\t      && first == threaded_edges [n]->src)\n \t\t    n++;\n-\t\t  t = EDGE_SUCC (first, 0);\n+\t\t  t = single_succ_edge (first);\n \t\t}\n \n \t      t->count -= edge_count;\n@@ -1233,11 +1233,12 @@ outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)\n \n   /* If BB1 has only one successor, we may be looking at either an\n      unconditional jump, or a fake edge to exit.  */\n-  if (EDGE_COUNT (bb1->succs) == 1\n-      && (EDGE_SUCC (bb1, 0)->flags & (EDGE_COMPLEX | EDGE_FAKE)) == 0\n+  if (single_succ_p (bb1)\n+      && (single_succ_edge (bb1)->flags & (EDGE_COMPLEX | EDGE_FAKE)) == 0\n       && (!JUMP_P (BB_END (bb1)) || simplejump_p (BB_END (bb1))))\n-    return (EDGE_COUNT (bb2->succs) == 1\n-\t    && (EDGE_SUCC (bb2, 0)->flags & (EDGE_COMPLEX | EDGE_FAKE)) == 0\n+    return (single_succ_p (bb2)\n+\t    && (single_succ_edge (bb2)->flags\n+\t\t& (EDGE_COMPLEX | EDGE_FAKE)) == 0\n \t    && (!JUMP_P (BB_END (bb2)) || simplejump_p (BB_END (bb2))));\n \n   /* Match conditional jumps - this may get tricky when fallthru and branch\n@@ -1264,10 +1265,10 @@ outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)\n       /* Get around possible forwarders on fallthru edges.  Other cases\n          should be optimized out already.  */\n       if (FORWARDER_BLOCK_P (f1->dest))\n-\tf1 = EDGE_SUCC (f1->dest, 0);\n+\tf1 = single_succ_edge (f1->dest);\n \n       if (FORWARDER_BLOCK_P (f2->dest))\n-\tf2 = EDGE_SUCC (f2->dest, 0);\n+\tf2 = single_succ_edge (f2->dest);\n \n       /* To simplify use of this function, return false if there are\n \t unneeded forwarder blocks.  These will get eliminated later\n@@ -1463,9 +1464,9 @@ outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)\n   if (fallthru1)\n     {\n       basic_block d1 = (forwarder_block_p (fallthru1->dest)\n-\t\t\t? EDGE_SUCC (fallthru1->dest, 0)->dest: fallthru1->dest);\n+\t\t\t? single_succ (fallthru1->dest): fallthru1->dest);\n       basic_block d2 = (forwarder_block_p (fallthru2->dest)\n-\t\t\t? EDGE_SUCC (fallthru2->dest, 0)->dest: fallthru2->dest);\n+\t\t\t? single_succ (fallthru2->dest): fallthru2->dest);\n \n       if (d1 != d2)\n \treturn false;\n@@ -1520,13 +1521,13 @@ try_crossjump_to_edge (int mode, edge e1, edge e2)\n      about multiple entry or chained forwarders, as they will be optimized\n      away.  We do this to look past the unconditional jump following a\n      conditional jump that is required due to the current CFG shape.  */\n-  if (EDGE_COUNT (src1->preds) == 1\n+  if (single_pred_p (src1)\n       && FORWARDER_BLOCK_P (src1))\n-    e1 = EDGE_PRED (src1, 0), src1 = e1->src;\n+    e1 = single_pred_edge (src1), src1 = e1->src;\n \n-  if (EDGE_COUNT (src2->preds) == 1\n+  if (single_pred_p (src2)\n       && FORWARDER_BLOCK_P (src2))\n-    e2 = EDGE_PRED (src2, 0), src2 = e2->src;\n+    e2 = single_pred_edge (src2), src2 = e2->src;\n \n   /* Nothing to do if we reach ENTRY, or a common source block.  */\n   if (src1 == ENTRY_BLOCK_PTR || src2 == ENTRY_BLOCK_PTR)\n@@ -1536,11 +1537,11 @@ try_crossjump_to_edge (int mode, edge e1, edge e2)\n \n   /* Seeing more than 1 forwarder blocks would confuse us later...  */\n   if (FORWARDER_BLOCK_P (e1->dest)\n-      && FORWARDER_BLOCK_P (EDGE_SUCC (e1->dest, 0)->dest))\n+      && FORWARDER_BLOCK_P (single_succ (e1->dest)))\n     return false;\n \n   if (FORWARDER_BLOCK_P (e2->dest)\n-      && FORWARDER_BLOCK_P (EDGE_SUCC (e2->dest, 0)->dest))\n+      && FORWARDER_BLOCK_P (single_succ (e2->dest)))\n     return false;\n \n   /* Likewise with dead code (possibly newly created by the other optimizations\n@@ -1623,13 +1624,13 @@ try_crossjump_to_edge (int mode, edge e1, edge e2)\n       basic_block d = s->dest;\n \n       if (FORWARDER_BLOCK_P (d))\n-\td = EDGE_SUCC (d, 0)->dest;\n+\td = single_succ (d);\n \n       FOR_EACH_EDGE (s2, ei, src1->succs)\n \t{\n \t  basic_block d2 = s2->dest;\n \t  if (FORWARDER_BLOCK_P (d2))\n-\t    d2 = EDGE_SUCC (d2, 0)->dest;\n+\t    d2 = single_succ (d2);\n \t  if (d == d2)\n \t    break;\n \t}\n@@ -1641,16 +1642,16 @@ try_crossjump_to_edge (int mode, edge e1, edge e2)\n          into infinite loop.  */\n       if (FORWARDER_BLOCK_P (s->dest))\n \t{\n-\t  EDGE_SUCC (s->dest, 0)->count += s2->count;\n+\t  single_succ_edge (s->dest)->count += s2->count;\n \t  s->dest->count += s2->count;\n \t  s->dest->frequency += EDGE_FREQUENCY (s);\n \t}\n \n       if (FORWARDER_BLOCK_P (s2->dest))\n \t{\n-\t  EDGE_SUCC (s2->dest, 0)->count -= s2->count;\n-\t  if (EDGE_SUCC (s2->dest, 0)->count < 0)\n-\t    EDGE_SUCC (s2->dest, 0)->count = 0;\n+\t  single_succ_edge (s2->dest)->count -= s2->count;\n+\t  if (single_succ_edge (s2->dest)->count < 0)\n+\t    single_succ_edge (s2->dest)->count = 0;\n \t  s2->dest->count -= s2->count;\n \t  s2->dest->frequency -= EDGE_FREQUENCY (s);\n \t  if (s2->dest->frequency < 0)\n@@ -1680,9 +1681,9 @@ try_crossjump_to_edge (int mode, edge e1, edge e2)\n     newpos1 = NEXT_INSN (newpos1);\n \n   redirect_from = split_block (src1, PREV_INSN (newpos1))->src;\n-  to_remove = EDGE_SUCC (redirect_from, 0)->dest;\n+  to_remove = single_succ (redirect_from);\n \n-  redirect_edge_and_branch_force (EDGE_SUCC (redirect_from, 0), redirect_to);\n+  redirect_edge_and_branch_force (single_succ_edge (redirect_from), redirect_to);\n   delete_basic_block (to_remove);\n \n   update_forwarder_flag (redirect_from);\n@@ -1884,20 +1885,20 @@ try_optimize_cfg (int mode)\n \t\t}\n \n \t      /* Remove code labels no longer used.  */\n-\t      if (EDGE_COUNT (b->preds) == 1\n-\t\t  && (EDGE_PRED (b, 0)->flags & EDGE_FALLTHRU)\n-\t\t  && !(EDGE_PRED (b, 0)->flags & EDGE_COMPLEX)\n+\t      if (single_pred_p (b)\n+\t\t  && (single_pred_edge (b)->flags & EDGE_FALLTHRU)\n+\t\t  && !(single_pred_edge (b)->flags & EDGE_COMPLEX)\n \t\t  && LABEL_P (BB_HEAD (b))\n \t\t  /* If the previous block ends with a branch to this\n \t\t     block, we can't delete the label.  Normally this\n \t\t     is a condjump that is yet to be simplified, but\n \t\t     if CASE_DROPS_THRU, this can be a tablejump with\n \t\t     some element going to the same place as the\n \t\t     default (fallthru).  */\n-\t\t  && (EDGE_PRED (b, 0)->src == ENTRY_BLOCK_PTR\n-\t\t      || !JUMP_P (BB_END (EDGE_PRED (b, 0)->src))\n+\t\t  && (single_pred (b) == ENTRY_BLOCK_PTR\n+\t\t      || !JUMP_P (BB_END (single_pred (b)))\n \t\t      || ! label_is_jump_target_p (BB_HEAD (b),\n-\t\t\t\t\t\t   BB_END (EDGE_PRED (b, 0)->src))))\n+\t\t\t\t\t\t   BB_END (single_pred (b)))))\n \t\t{\n \t\t  rtx label = BB_HEAD (b);\n \n@@ -1918,13 +1919,13 @@ try_optimize_cfg (int mode)\n \n \t      /* If we fall through an empty block, we can remove it.  */\n \t      if (!(mode & CLEANUP_CFGLAYOUT)\n-\t\t  && EDGE_COUNT (b->preds) == 1\n-\t\t  && (EDGE_PRED (b, 0)->flags & EDGE_FALLTHRU)\n+\t\t  && single_pred_p (b)\n+\t\t  && (single_pred_edge (b)->flags & EDGE_FALLTHRU)\n \t\t  && !LABEL_P (BB_HEAD (b))\n \t\t  && FORWARDER_BLOCK_P (b)\n \t\t  /* Note that forwarder_block_p true ensures that\n \t\t     there is a successor for this block.  */\n-\t\t  && (EDGE_SUCC (b, 0)->flags & EDGE_FALLTHRU)\n+\t\t  && (single_succ_edge (b)->flags & EDGE_FALLTHRU)\n \t\t  && n_basic_blocks > 1)\n \t\t{\n \t\t  if (dump_file)\n@@ -1933,17 +1934,18 @@ try_optimize_cfg (int mode)\n \t\t\t     b->index);\n \n \t\t  c = b->prev_bb == ENTRY_BLOCK_PTR ? b->next_bb : b->prev_bb;\n-\t\t  redirect_edge_succ_nodup (EDGE_PRED (b, 0), EDGE_SUCC (b, 0)->dest);\n+\t\t  redirect_edge_succ_nodup (single_pred_edge (b),\n+\t\t\t\t\t    single_succ (b));\n \t\t  delete_basic_block (b);\n \t\t  changed = true;\n \t\t  b = c;\n \t\t}\n \n-\t      if (EDGE_COUNT (b->succs) == 1\n-\t\t  && (s = EDGE_SUCC (b, 0))\n+\t      if (single_succ_p (b)\n+\t\t  && (s = single_succ_edge (b))\n \t\t  && !(s->flags & EDGE_COMPLEX)\n \t\t  && (c = s->dest) != EXIT_BLOCK_PTR\n-\t\t  && EDGE_COUNT (c->preds) == 1\n+\t\t  && single_pred_p (c)\n \t\t  && b != c)\n \t\t{\n \t\t  /* When not in cfg_layout mode use code aware of reordering\n@@ -1985,11 +1987,12 @@ try_optimize_cfg (int mode)\n \t\t non-trivial jump instruction without side-effects, we\n \t\t can either delete the jump entirely, or replace it\n \t\t with a simple unconditional jump.  */\n-\t      if (EDGE_COUNT (b->succs) == 1\n-\t\t  && EDGE_SUCC (b, 0)->dest != EXIT_BLOCK_PTR\n+\t      if (single_succ_p (b)\n+\t\t  && single_succ (b) != EXIT_BLOCK_PTR\n \t\t  && onlyjump_p (BB_END (b))\n \t\t  && !find_reg_note (BB_END (b), REG_CROSSING_JUMP, NULL_RTX)\n-\t\t  && try_redirect_by_replacing_jump (EDGE_SUCC (b, 0), EDGE_SUCC (b, 0)->dest,\n+\t\t  && try_redirect_by_replacing_jump (single_succ_edge (b),\n+\t\t\t\t\t\t     single_succ (b),\n \t\t\t\t\t\t     (mode & CLEANUP_CFGLAYOUT) != 0))\n \t\t{\n \t\t  update_forwarder_flag (b);\n@@ -2074,11 +2077,11 @@ merge_seq_blocks (void)\n \n   for (bb = ENTRY_BLOCK_PTR->next_bb; bb != EXIT_BLOCK_PTR; )\n     {\n-      if (EDGE_COUNT (bb->succs) == 1\n-\t  && can_merge_blocks_p (bb, EDGE_SUCC (bb, 0)->dest))\n+      if (single_succ_p (bb)\n+\t  && can_merge_blocks_p (bb, single_succ (bb)))\n \t{\n \t  /* Merge the blocks and retry.  */\n-\t  merge_blocks (bb, EDGE_SUCC (bb, 0)->dest);\n+\t  merge_blocks (bb, single_succ (bb));\n \t  changed = true;\n \t  continue;\n \t}"}, {"sha": "4f8f18a97c6ea44dd5f2da3f1eae463d321c1898", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -407,18 +407,18 @@ split_edge (edge e)\n   ret = cfg_hooks->split_edge (e);\n   ret->count = count;\n   ret->frequency = freq;\n-  EDGE_SUCC (ret, 0)->probability = REG_BR_PROB_BASE;\n-  EDGE_SUCC (ret, 0)->count = count;\n+  single_succ_edge (ret)->probability = REG_BR_PROB_BASE;\n+  single_succ_edge (ret)->count = count;\n \n   if (irr)\n     {\n       ret->flags |= BB_IRREDUCIBLE_LOOP;\n-      EDGE_PRED (ret, 0)->flags |= EDGE_IRREDUCIBLE_LOOP;\n-      EDGE_SUCC (ret, 0)->flags |= EDGE_IRREDUCIBLE_LOOP;\n+      single_pred_edge (ret)->flags |= EDGE_IRREDUCIBLE_LOOP;\n+      single_succ_edge (ret)->flags |= EDGE_IRREDUCIBLE_LOOP;\n     }\n \n   if (dom_computed[CDI_DOMINATORS])\n-    set_immediate_dominator (CDI_DOMINATORS, ret, EDGE_PRED (ret, 0)->src);\n+    set_immediate_dominator (CDI_DOMINATORS, ret, single_pred (ret));\n \n   if (dom_computed[CDI_DOMINATORS] >= DOM_NO_FAST_QUERY)\n     {\n@@ -431,22 +431,22 @@ split_edge (edge e)\n \t ret, provided that all other predecessors of e->dest are\n \t dominated by e->dest.  */\n \n-      if (get_immediate_dominator (CDI_DOMINATORS, EDGE_SUCC (ret, 0)->dest)\n-\t  == EDGE_PRED (ret, 0)->src)\n+      if (get_immediate_dominator (CDI_DOMINATORS, single_succ (ret))\n+\t  == single_pred (ret))\n \t{\n \t  edge_iterator ei;\n-\t  FOR_EACH_EDGE (f, ei, EDGE_SUCC (ret, 0)->dest->preds)\n+\t  FOR_EACH_EDGE (f, ei, single_succ (ret)->preds)\n \t    {\n-\t      if (f == EDGE_SUCC (ret, 0))\n+\t      if (f == single_succ_edge (ret))\n \t\tcontinue;\n \n \t      if (!dominated_by_p (CDI_DOMINATORS, f->src,\n-\t\t\t\t   EDGE_SUCC (ret, 0)->dest))\n+\t\t\t\t   single_succ (ret)))\n \t\tbreak;\n \t    }\n \n \t  if (!f)\n-\t    set_immediate_dominator (CDI_DOMINATORS, EDGE_SUCC (ret, 0)->dest, ret);\n+\t    set_immediate_dominator (CDI_DOMINATORS, single_succ (ret), ret);\n \t}\n     };\n \n@@ -657,9 +657,9 @@ tidy_fallthru_edges (void)\n \t merge the flags for the duplicate edges.  So we do not want to\n \t check that the edge is not a FALLTHRU edge.  */\n \n-      if (EDGE_COUNT (b->succs) == 1)\n+      if (single_succ_p (b))\n \t{\n-\t  s = EDGE_SUCC (b, 0);\n+\t  s = single_succ_edge (b);\n \t  if (! (s->flags & EDGE_COMPLEX)\n \t      && s->dest == c\n \t      && !find_reg_note (BB_END (b), REG_CROSSING_JUMP, NULL_RTX))"}, {"sha": "db556b124338bbff81d40257056bba63c4c08d05", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -776,11 +776,11 @@ fixup_reorder_chain (void)\n \t  /* Make sure new bb is tagged for correct section (same as\n \t     fall-thru source, since you cannot fall-throu across\n \t     section boundaries).  */\n-\t  BB_COPY_PARTITION (e_fall->src, EDGE_PRED (bb, 0)->src);\n+\t  BB_COPY_PARTITION (e_fall->src, single_pred (bb));\n \t  if (flag_reorder_blocks_and_partition\n \t      && targetm.have_named_sections)\n \t    {\n-\t      if (BB_PARTITION (EDGE_PRED (bb, 0)->src) == BB_COLD_PARTITION)\n+\t      if (BB_PARTITION (single_pred (bb)) == BB_COLD_PARTITION)\n \t\t{\n \t\t  rtx new_note;\n \t\t  rtx note = BB_HEAD (e_fall->src);\n@@ -796,7 +796,7 @@ fixup_reorder_chain (void)\n \t\t}\n \t      if (JUMP_P (BB_END (bb))\n \t\t  && !any_condjump_p (BB_END (bb))\n-  \t\t  && (EDGE_SUCC (bb, 0)->flags & EDGE_CROSSING))\n+  \t\t  && (single_succ_edge (bb)->flags & EDGE_CROSSING))\n \t\tREG_NOTES (BB_END (bb)) = gen_rtx_EXPR_LIST \n \t\t  (REG_CROSSING_JUMP, NULL_RTX, REG_NOTES (BB_END (bb)));\n \t    }"}, {"sha": "0e258c64a342eeed34e62d076a6be6d1d943039e", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -305,7 +305,7 @@ mark_single_exit_loops (struct loops *loops)\n \t      /* If we have already seen an exit, mark this by the edge that\n \t\t surely does not occur as any exit.  */\n \t      if (loop->single_exit)\n-\t\tloop->single_exit = EDGE_SUCC (ENTRY_BLOCK_PTR, 0);\n+\t\tloop->single_exit = single_succ_edge (ENTRY_BLOCK_PTR);\n \t      else\n \t\tloop->single_exit = e;\n \t    }\n@@ -318,7 +318,7 @@ mark_single_exit_loops (struct loops *loops)\n       if (!loop)\n \tcontinue;\n \n-      if (loop->single_exit == EDGE_SUCC (ENTRY_BLOCK_PTR, 0))\n+      if (loop->single_exit == single_succ_edge (ENTRY_BLOCK_PTR))\n \tloop->single_exit = NULL;\n     }\n \n@@ -430,9 +430,9 @@ update_latch_info (basic_block jump)\n {\n   alloc_aux_for_block (jump, sizeof (int));\n   HEADER_BLOCK (jump) = 0;\n-  alloc_aux_for_edge (EDGE_PRED (jump, 0), sizeof (int));\n-  LATCH_EDGE (EDGE_PRED (jump, 0)) = 0;\n-  set_immediate_dominator (CDI_DOMINATORS, jump, EDGE_PRED (jump, 0)->src);\n+  alloc_aux_for_edge (single_pred_edge (jump), sizeof (int));\n+  LATCH_EDGE (single_pred_edge (jump)) = 0;\n+  set_immediate_dominator (CDI_DOMINATORS, jump, single_pred (jump));\n }\n \n /* A callback for make_forwarder block, to redirect all edges except for\n@@ -494,16 +494,16 @@ canonicalize_loop_headers (void)\n \tHEADER_BLOCK (header) = num_latches;\n     }\n \n-  if (HEADER_BLOCK (EDGE_SUCC (ENTRY_BLOCK_PTR, 0)->dest))\n+  if (HEADER_BLOCK (single_succ (ENTRY_BLOCK_PTR)))\n     {\n       basic_block bb;\n \n       /* We could not redirect edges freely here. On the other hand,\n \t we can simply split the edge from entry block.  */\n-      bb = split_edge (EDGE_SUCC (ENTRY_BLOCK_PTR, 0));\n+      bb = split_edge (single_succ_edge (ENTRY_BLOCK_PTR));\n \n-      alloc_aux_for_edge (EDGE_SUCC (bb, 0), sizeof (int));\n-      LATCH_EDGE (EDGE_SUCC (bb, 0)) = 0;\n+      alloc_aux_for_edge (single_succ_edge (bb), sizeof (int));\n+      LATCH_EDGE (single_succ_edge (bb)) = 0;\n       alloc_aux_for_block (bb, sizeof (int));\n       HEADER_BLOCK (bb) = 0;\n     }\n@@ -1124,12 +1124,12 @@ verify_loop_structure (struct loops *loops)\n \t}\n       if (loops->state & LOOPS_HAVE_SIMPLE_LATCHES)\n \t{\n-\t  if (EDGE_COUNT (loop->latch->succs) != 1)\n+\t  if (!single_succ_p (loop->latch))\n \t    {\n \t      error (\"Loop %d's latch does not have exactly 1 successor.\", i);\n \t      err = 1;\n \t    }\n-\t  if (EDGE_SUCC (loop->latch, 0)->dest != loop->header)\n+\t  if (single_succ (loop->latch) != loop->header)\n \t    {\n \t      error (\"Loop %d's latch does not have header as successor.\", i);\n \t      err = 1;"}, {"sha": "bd55788483d29f0da7feb0f8dd5c76020f903637", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -331,8 +331,8 @@ remove_path (struct loops *loops, edge e)\n      e, but we only have basic block dominators.  This is easy to\n      fix -- when e->dest has exactly one predecessor, this corresponds\n      to blocks dominated by e->dest, if not, split the edge.  */\n-  if (EDGE_COUNT (e->dest->preds) > 1)\n-    e = EDGE_PRED (loop_split_edge_with (e, NULL_RTX), 0);\n+  if (!single_pred_p (e->dest))\n+    e = single_pred_edge (loop_split_edge_with (e, NULL_RTX));\n \n   /* It may happen that by removing path we remove one or more loops\n      we belong to.  In this case first unloop the loops, then proceed\n@@ -623,7 +623,7 @@ unloop (struct loops *loops, struct loop *loop)\n   loops->parray[loop->num] = NULL;\n   flow_loop_free (loop);\n \n-  remove_edge (EDGE_SUCC (latch, 0));\n+  remove_edge (single_succ_edge (latch));\n   fix_bb_placements (loops, latch);\n \n   /* If the loop was inside an irreducible region, we would have to somehow\n@@ -802,8 +802,8 @@ loop_delete_branch_edge (edge e, int really_delete)\n \n   if (!redirect_edge_and_branch (e, newdest))\n     return false;\n-  EDGE_SUCC (src, 0)->flags &= ~EDGE_IRREDUCIBLE_LOOP;\n-  EDGE_SUCC (src, 0)->flags |= irr;\n+  single_succ_edge (src)->flags &= ~EDGE_IRREDUCIBLE_LOOP;\n+  single_succ_edge (src)->flags |= irr;\n   \n   return true;\n }\n@@ -1121,10 +1121,10 @@ mfb_keep_just (edge e)\n static void\n mfb_update_loops (basic_block jump)\n {\n-  struct loop *loop = EDGE_SUCC (jump, 0)->dest->loop_father;\n+  struct loop *loop = single_succ (jump)->loop_father;\n \n   if (dom_computed[CDI_DOMINATORS])\n-    set_immediate_dominator (CDI_DOMINATORS, jump, EDGE_PRED (jump, 0)->src);\n+    set_immediate_dominator (CDI_DOMINATORS, jump, single_pred (jump));\n   add_bb_to_loop (jump, loop);\n   loop->latch = jump;\n }\n@@ -1154,7 +1154,7 @@ create_preheader (struct loop *loop, int flags)\n \tcontinue;\n       irred |= (e->flags & EDGE_IRREDUCIBLE_LOOP) != 0;\n       nentry++;\n-      if (EDGE_COUNT (e->src->succs) == 1)\n+      if (single_succ_p (e->src))\n \tone_succ_pred = e;\n     }\n   gcc_assert (nentry);\n@@ -1165,7 +1165,7 @@ create_preheader (struct loop *loop, int flags)\n       e = EDGE_PRED (loop->header,\n \t\t     EDGE_PRED (loop->header, 0)->src == loop->latch);\n \n-      if (!(flags & CP_SIMPLE_PREHEADERS) || EDGE_COUNT (e->src->succs) == 1)\n+      if (!(flags & CP_SIMPLE_PREHEADERS) || single_succ_p (e->src))\n \treturn NULL;\n     }\n \n@@ -1206,7 +1206,7 @@ create_preheader (struct loop *loop, int flags)\n   if (irred)\n     {\n       dummy->flags |= BB_IRREDUCIBLE_LOOP;\n-      EDGE_SUCC (dummy, 0)->flags |= EDGE_IRREDUCIBLE_LOOP;\n+      single_succ_edge (dummy)->flags |= EDGE_IRREDUCIBLE_LOOP;\n     }\n \n   if (dump_file)\n@@ -1239,7 +1239,7 @@ force_single_succ_latches (struct loops *loops)\n   for (i = 1; i < loops->num; i++)\n     {\n       loop = loops->parray[i];\n-      if (loop->latch != loop->header && EDGE_COUNT (loop->latch->succs) == 1)\n+      if (loop->latch != loop->header && single_succ_p (loop->latch))\n \tcontinue;\n \n       e = find_edge (loop->latch, loop->header);\n@@ -1341,9 +1341,9 @@ create_loop_notes (void)\n \t\t      && onlyjump_p (insn))\n \t\t    {\n \t\t      pbb = BLOCK_FOR_INSN (insn);\n-\t\t      gcc_assert (pbb && EDGE_COUNT (pbb->succs) == 1);\n+\t\t      gcc_assert (pbb && single_succ_p (pbb));\n \n-\t\t      if (!flow_bb_inside_loop_p (loop, EDGE_SUCC (pbb, 0)->dest))\n+\t\t      if (!flow_bb_inside_loop_p (loop, single_succ (pbb)))\n \t\t\tinsn = BB_HEAD (first[loop->num]);\n \t\t    }\n \t\t  else"}, {"sha": "92399068dcab727f5c26c6967363abe1642f454a", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -623,12 +623,12 @@ rtl_can_merge_blocks (basic_block a,basic_block b)\n     return false;\n \n   /* There must be exactly one edge in between the blocks.  */\n-  return (EDGE_COUNT (a->succs) == 1\n-\t  && EDGE_SUCC (a, 0)->dest == b\n-\t  && EDGE_COUNT (b->preds) == 1\n+  return (single_succ_p (a)\n+\t  && single_succ (a) == b\n+\t  && single_pred_p (b)\n \t  && a != b\n \t  /* Must be simple edge.  */\n-\t  && !(EDGE_SUCC (a, 0)->flags & EDGE_COMPLEX)\n+\t  && !(single_succ_edge (a)->flags & EDGE_COMPLEX)\n \t  && a->next_bb == b\n \t  && a != ENTRY_BLOCK_PTR && b != EXIT_BLOCK_PTR\n \t  /* If the jump insn has side effects,\n@@ -817,10 +817,11 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n     }\n \n   /* Keep only one edge out and set proper flags.  */\n-  while (EDGE_COUNT (src->succs) > 1)\n+  if (!single_succ_p (src))\n     remove_edge (e);\n+  gcc_assert (single_succ_p (src));\n \n-  e = EDGE_SUCC (src, 0);\n+  e = single_succ_edge (src);\n   if (fallthru)\n     e->flags = EDGE_FALLTHRU;\n   else\n@@ -1124,7 +1125,7 @@ force_nonfallthru_and_redirect (edge e, basic_block target)\n \t    }\n \t  if (JUMP_P (BB_END (jump_block))\n \t      && !any_condjump_p (BB_END (jump_block))\n-\t      && (EDGE_SUCC (jump_block, 0)->flags & EDGE_CROSSING))\n+\t      && (single_succ_edge (jump_block)->flags & EDGE_CROSSING))\n \t    REG_NOTES (BB_END (jump_block)) = gen_rtx_EXPR_LIST \n \t      (REG_CROSSING_JUMP, NULL_RTX, \n \t       REG_NOTES (BB_END (jump_block)));\n@@ -1226,7 +1227,7 @@ rtl_tidy_fallthru_edge (edge e)\n   if (JUMP_P (q)\n       && onlyjump_p (q)\n       && (any_uncondjump_p (q)\n-\t  || EDGE_COUNT (b->succs) == 1))\n+\t  || single_succ_p (b)))\n     {\n #ifdef HAVE_cc0\n       /* If this was a conditional jump, we need to also delete\n@@ -1544,7 +1545,7 @@ commit_one_edge_insertion (edge e, int watch_calls)\n   /* Special case -- avoid inserting code between call and storing\n      its return value.  */\n   if (watch_calls && (e->flags & EDGE_FALLTHRU)\n-      && EDGE_COUNT (e->dest->preds) == 1\n+      && single_pred_p (e->dest)\n       && e->src != ENTRY_BLOCK_PTR\n       && CALL_P (BB_END (e->src)))\n     {\n@@ -1564,7 +1565,7 @@ commit_one_edge_insertion (edge e, int watch_calls)\n     {\n       /* Figure out where to put these things.  If the destination has\n          one predecessor, insert there.  Except for the exit block.  */\n-      if (EDGE_COUNT (e->dest->preds) == 1 && e->dest != EXIT_BLOCK_PTR)\n+      if (single_pred_p (e->dest) && e->dest != EXIT_BLOCK_PTR)\n \t{\n \t  bb = e->dest;\n \n@@ -1590,7 +1591,7 @@ commit_one_edge_insertion (edge e, int watch_calls)\n       /* If the source has one successor and the edge is not abnormal,\n          insert there.  Except for the entry block.  */\n       else if ((e->flags & EDGE_ABNORMAL) == 0\n-\t       && EDGE_COUNT (e->src->succs) == 1\n+\t       && single_succ_p (e->src)\n \t       && e->src != ENTRY_BLOCK_PTR)\n \t{\n \t  bb = e->src;\n@@ -1645,7 +1646,7 @@ commit_one_edge_insertion (edge e, int watch_calls)\n \t      NOTE_BASIC_BLOCK (new_note) = bb;\n \t      if (JUMP_P (BB_END (bb))\n \t\t  && !any_condjump_p (BB_END (bb))\n-  \t\t  && (EDGE_SUCC (bb, 0)->flags & EDGE_CROSSING))\n+  \t\t  && (single_succ_edge (bb)->flags & EDGE_CROSSING))\n \t\tREG_NOTES (BB_END (bb)) = gen_rtx_EXPR_LIST \n \t\t  (REG_CROSSING_JUMP, NULL_RTX, REG_NOTES (BB_END (bb)));\n \t      if (after == bb_note)\n@@ -1671,9 +1672,9 @@ commit_one_edge_insertion (edge e, int watch_calls)\n          for the (single) epilogue, which already has a fallthru edge\n          to EXIT.  */\n \n-      e = EDGE_SUCC (bb, 0);\n+      e = single_succ_edge (bb);\n       gcc_assert (e->dest == EXIT_BLOCK_PTR\n-\t\t  && EDGE_COUNT (bb->succs) == 1 && (e->flags & EDGE_FALLTHRU));\n+\t\t  && single_succ_p (bb) && (e->flags & EDGE_FALLTHRU));\n \n       e->flags &= ~EDGE_FALLTHRU;\n       emit_barrier_after (last);\n@@ -2404,10 +2405,10 @@ purge_dead_edges (basic_block bb)\n \treturn purged;\n \n       /* Redistribute probabilities.  */\n-      if (EDGE_COUNT (bb->succs) == 1)\n+      if (single_succ_p (bb))\n \t{\n-\t  EDGE_SUCC (bb, 0)->probability = REG_BR_PROB_BASE;\n-\t  EDGE_SUCC (bb, 0)->count = bb->count;\n+\t  single_succ_edge (bb)->probability = REG_BR_PROB_BASE;\n+\t  single_succ_edge (bb)->count = bb->count;\n \t}\n       else\n \t{\n@@ -2431,8 +2432,9 @@ purge_dead_edges (basic_block bb)\n \t from non-local gotos and the like.  If there were, we shouldn't\n \t have created the sibcall in the first place.  Second, there\n \t should of course never have been a fallthru edge.  */\n-      gcc_assert (EDGE_COUNT (bb->succs) == 1);\n-      gcc_assert (EDGE_SUCC (bb, 0)->flags == (EDGE_SIBCALL | EDGE_ABNORMAL));\n+      gcc_assert (single_succ_p (bb));\n+      gcc_assert (single_succ_edge (bb)->flags\n+\t\t  == (EDGE_SIBCALL | EDGE_ABNORMAL));\n \n       return 0;\n     }\n@@ -2465,10 +2467,10 @@ purge_dead_edges (basic_block bb)\n \tei_next (&ei);\n     }\n \n-  gcc_assert (EDGE_COUNT (bb->succs) == 1);\n+  gcc_assert (single_succ_p (bb));\n \n-  EDGE_SUCC (bb, 0)->probability = REG_BR_PROB_BASE;\n-  EDGE_SUCC (bb, 0)->count = bb->count;\n+  single_succ_edge (bb)->probability = REG_BR_PROB_BASE;\n+  single_succ_edge (bb)->count = bb->count;\n \n   if (dump_file)\n     fprintf (dump_file, \"Purged non-fallthru edges from bb %i\\n\",\n@@ -2722,12 +2724,12 @@ cfg_layout_can_merge_blocks_p (basic_block a, basic_block b)\n     return false;\n \n   /* There must be exactly one edge in between the blocks.  */\n-  return (EDGE_COUNT (a->succs) == 1\n-\t  && EDGE_SUCC (a, 0)->dest == b\n-\t  && EDGE_COUNT (b->preds) == 1\n+  return (single_succ_p (a)\n+\t  && single_succ (a) == b\n+\t  && single_pred_p (b) == 1\n \t  && a != b\n \t  /* Must be simple edge.  */\n-\t  && !(EDGE_SUCC (a, 0)->flags & EDGE_COMPLEX)\n+\t  && !(single_succ_edge (a)->flags & EDGE_COMPLEX)\n \t  && a != ENTRY_BLOCK_PTR && b != EXIT_BLOCK_PTR\n \t  /* If the jump insn has side effects,\n \t     we can't kill the edge.  */"}, {"sha": "20014b93c6e3e6b7994384351fc3af2ca9b5bd6d", "filename": "gcc/except.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -1637,10 +1637,10 @@ sjlj_emit_function_enter (rtx dispatch_label)\n \t    || NOTE_LINE_NUMBER (fn_begin) == NOTE_INSN_BASIC_BLOCK))\n       break;\n   if (NOTE_LINE_NUMBER (fn_begin) == NOTE_INSN_FUNCTION_BEG)\n-    insert_insn_on_edge (seq, EDGE_SUCC (ENTRY_BLOCK_PTR, 0));\n+    insert_insn_on_edge (seq, single_succ_edge (ENTRY_BLOCK_PTR));\n   else\n     {\n-      rtx last = BB_END (EDGE_SUCC (ENTRY_BLOCK_PTR, 0)->dest);\n+      rtx last = BB_END (single_succ (ENTRY_BLOCK_PTR));\n       for (; ; fn_begin = NEXT_INSN (fn_begin))\n \tif ((NOTE_P (fn_begin)\n \t     && NOTE_LINE_NUMBER (fn_begin) == NOTE_INSN_FUNCTION_BEG)"}, {"sha": "c58fd499e3e2e08e5b700ca37bd91975ffe1f130", "filename": "gcc/flow.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -1962,7 +1962,7 @@ init_propagate_block_info (basic_block bb, regset live, regset local_set,\n \n       /* Identify the successor blocks.  */\n       bb_true = EDGE_SUCC (bb, 0)->dest;\n-      if (EDGE_COUNT (bb->succs) > 1)\n+      if (!single_succ_p (bb))\n \t{\n \t  bb_false = EDGE_SUCC (bb, 1)->dest;\n \n@@ -2059,8 +2059,8 @@ init_propagate_block_info (basic_block bb, regset live, regset local_set,\n \t\t(TREE_TYPE (current_function_decl))))\n       && (flags & PROP_SCAN_DEAD_STORES)\n       && (EDGE_COUNT (bb->succs) == 0\n-\t  || (EDGE_COUNT (bb->succs) == 1\n-\t      && EDGE_SUCC (bb, 0)->dest == EXIT_BLOCK_PTR\n+\t  || (single_succ_p (bb)\n+\t      && single_succ (bb) == EXIT_BLOCK_PTR\n \t      && ! current_function_calls_eh_return)))\n     {\n       rtx insn, set;"}, {"sha": "3354c13e049f70345272a1ad19660743c6e66175", "filename": "gcc/function.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -5130,9 +5130,9 @@ thread_prologue_and_epilogue_insns (rtx f ATTRIBUTE_UNUSED)\n       /* Can't deal with multiple successors of the entry block\n          at the moment.  Function should always have at least one\n          entry point.  */\n-      gcc_assert (EDGE_COUNT (ENTRY_BLOCK_PTR->succs) == 1);\n+      gcc_assert (single_succ_p (ENTRY_BLOCK_PTR));\n \n-      insert_insn_on_edge (seq, EDGE_SUCC (ENTRY_BLOCK_PTR, 0));\n+      insert_insn_on_edge (seq, single_succ_edge (ENTRY_BLOCK_PTR));\n       inserted = 1;\n     }\n #endif\n@@ -5228,7 +5228,7 @@ thread_prologue_and_epilogue_insns (rtx f ATTRIBUTE_UNUSED)\n \t\t  /* If this block has only one successor, it both jumps\n \t\t     and falls through to the fallthru block, so we can't\n \t\t     delete the edge.  */\n-\t\t  if (EDGE_COUNT (bb->succs) == 1)\n+\t\t  if (single_succ_p (bb))\n \t\t    {\n \t\t      ei_next (&ei2);\n \t\t      continue;\n@@ -5250,7 +5250,7 @@ thread_prologue_and_epilogue_insns (rtx f ATTRIBUTE_UNUSED)\n \t  emit_barrier_after (BB_END (last));\n \t  emit_return_into_block (last, epilogue_line_note);\n \t  epilogue_end = BB_END (last);\n-\t  EDGE_SUCC (last, 0)->flags &= ~EDGE_FALLTHRU;\n+\t  single_succ_edge (last)->flags &= ~EDGE_FALLTHRU;\n \t  goto epilogue_done;\n \t}\n     }"}, {"sha": "467a50aa706af0a890518f24a31ad5d1d8791c16", "filename": "gcc/gcse.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -3331,7 +3331,7 @@ find_implicit_sets (void)\n \t    dest = GET_CODE (cond) == EQ ? BRANCH_EDGE (bb)->dest\n \t\t\t\t\t : FALLTHRU_EDGE (bb)->dest;\n \n-\t    if (dest && EDGE_COUNT (dest->preds) == 1\n+\t    if (dest && single_pred_p (dest)\n \t\t&& dest != EXIT_BLOCK_PTR)\n \t      {\n \t\tnew = gen_rtx_SET (VOIDmode, XEXP (cond, 0),\n@@ -3662,7 +3662,7 @@ bypass_conditional_jumps (void)\n \t\t  EXIT_BLOCK_PTR, next_bb)\n     {\n       /* Check for more than one predecessor.  */\n-      if (EDGE_COUNT (bb->preds) > 1)\n+      if (!single_pred_p (bb))\n \t{\n \t  setcc = NULL_RTX;\n \t  for (insn = BB_HEAD (bb);\n@@ -3976,8 +3976,8 @@ insert_insn_end_bb (struct expr *expr, basic_block bb, int pre)\n \n   if (JUMP_P (insn)\n       || (NONJUMP_INSN_P (insn)\n-\t  && (EDGE_COUNT (bb->succs) > 1\n-\t      || EDGE_SUCC (bb, 0)->flags & EDGE_ABNORMAL)))\n+\t  && (!single_succ_p (bb)\n+\t      || single_succ_edge (bb)->flags & EDGE_ABNORMAL)))\n     {\n #ifdef HAVE_cc0\n       rtx note;\n@@ -4018,7 +4018,8 @@ insert_insn_end_bb (struct expr *expr, basic_block bb, int pre)\n   /* Likewise if the last insn is a call, as will happen in the presence\n      of exception handling.  */\n   else if (CALL_P (insn)\n-\t   && (EDGE_COUNT (bb->succs) > 1 || EDGE_SUCC (bb, 0)->flags & EDGE_ABNORMAL))\n+\t   && (!single_succ_p (bb)\n+\t       || single_succ_edge (bb)->flags & EDGE_ABNORMAL))\n     {\n       /* Keeping in mind SMALL_REGISTER_CLASSES and parameters in registers,\n \t we search backward and place the instructions before the first"}, {"sha": "b0df6dae3ac46f131c149b53fbf85213c0c575da", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -2278,13 +2278,12 @@ merge_if_block (struct ce_if_block * ce_info)\n \n       /* The outgoing edge for the current COMBO block should already\n \t be correct.  Verify this.  */\n-      if (EDGE_COUNT (combo_bb->succs) > 1\n-\t  || EDGE_SUCC (combo_bb, 0)->dest != join_bb)\n-\tabort ();\n+      gcc_assert (single_succ_p (combo_bb)\n+\t\t  && single_succ (combo_bb) == join_bb);\n \n       /* Remove the jump and cruft from the end of the COMBO block.  */\n       if (join_bb != EXIT_BLOCK_PTR)\n-\ttidy_fallthru_edge (EDGE_SUCC (combo_bb, 0));\n+\ttidy_fallthru_edge (single_succ_edge (combo_bb));\n     }\n \n   num_updated_if_blocks++;\n@@ -2456,10 +2455,10 @@ find_if_block (struct ce_if_block * ce_info)\n      were && tests (which jump to the else block) or || tests (which jump to\n      the then block).  */\n   if (HAVE_conditional_execution && reload_completed\n-      && EDGE_COUNT (test_bb->preds) == 1\n-      && EDGE_PRED (test_bb, 0)->flags == EDGE_FALLTHRU)\n+      && single_pred_p (test_bb)\n+      && single_pred_edge (test_bb)->flags == EDGE_FALLTHRU)\n     {\n-      basic_block bb = EDGE_PRED (test_bb, 0)->src;\n+      basic_block bb = single_pred (test_bb);\n       basic_block target_bb;\n       int max_insns = MAX_CONDITIONAL_EXECUTE;\n       int n_insns;\n@@ -2492,10 +2491,10 @@ find_if_block (struct ce_if_block * ce_info)\n \t      total_insns += n_insns;\n \t      blocks++;\n \n-\t      if (EDGE_COUNT (bb->preds) != 1)\n+\t      if (!single_pred_p (bb))\n \t\tbreak;\n \n-\t      bb = EDGE_PRED (bb, 0)->src;\n+\t      bb = single_pred (bb);\n \t      n_insns = block_jumps_and_fallthru_p (bb, target_bb);\n \t    }\n \t  while (n_insns >= 0 && (total_insns + n_insns) <= max_insns);\n@@ -2530,8 +2529,8 @@ find_if_block (struct ce_if_block * ce_info)\n \n   /* The THEN block of an IF-THEN combo must have zero or one successors.  */\n   if (EDGE_COUNT (then_bb->succs) > 0\n-      && (EDGE_COUNT (then_bb->succs) > 1\n-          || (EDGE_SUCC (then_bb, 0)->flags & EDGE_COMPLEX)\n+      && (!single_succ_p (then_bb)\n+          || (single_succ_edge (then_bb)->flags & EDGE_COMPLEX)\n \t  || (flow2_completed && tablejump_p (BB_END (then_bb), NULL, NULL))))\n     return FALSE;\n \n@@ -2543,7 +2542,7 @@ find_if_block (struct ce_if_block * ce_info)\n      code processing.  ??? we should fix this in the future.  */\n   if (EDGE_COUNT (then_bb->succs) == 0)\n     {\n-      if (EDGE_COUNT (else_bb->preds) == 1)\n+      if (single_pred_p (else_bb))\n \t{\n \t  rtx last_insn = BB_END (then_bb);\n \n@@ -2566,7 +2565,7 @@ find_if_block (struct ce_if_block * ce_info)\n \n   /* If the THEN block's successor is the other edge out of the TEST block,\n      then we have an IF-THEN combo without an ELSE.  */\n-  else if (EDGE_SUCC (then_bb, 0)->dest == else_bb)\n+  else if (single_succ (then_bb) == else_bb)\n     {\n       join_bb = else_bb;\n       else_bb = NULL_BLOCK;\n@@ -2575,12 +2574,12 @@ find_if_block (struct ce_if_block * ce_info)\n   /* If the THEN and ELSE block meet in a subsequent block, and the ELSE\n      has exactly one predecessor and one successor, and the outgoing edge\n      is not complex, then we have an IF-THEN-ELSE combo.  */\n-  else if (EDGE_COUNT (else_bb->succs) == 1\n-\t   && EDGE_SUCC (then_bb, 0)->dest == EDGE_SUCC (else_bb, 0)->dest\n-\t   && EDGE_COUNT (else_bb->preds) == 1\n-\t   && ! (EDGE_SUCC (else_bb, 0)->flags & EDGE_COMPLEX)\n+  else if (single_succ_p (else_bb)\n+\t   && single_succ (then_bb) == single_succ (else_bb)\n+\t   && single_pred_p (else_bb)\n+\t   && ! (single_succ_edge (else_bb)->flags & EDGE_COMPLEX)\n \t   && ! (flow2_completed && tablejump_p (BB_END (else_bb), NULL, NULL)))\n-    join_bb = EDGE_SUCC (else_bb, 0)->dest;\n+    join_bb = single_succ (else_bb);\n \n   /* Otherwise it is not an IF-THEN or IF-THEN-ELSE combination.  */\n   else\n@@ -2875,15 +2874,15 @@ find_if_case_1 (basic_block test_bb, edge then_edge, edge else_edge)\n     return FALSE;\n \n   /* THEN has one successor.  */\n-  if (EDGE_COUNT (then_bb->succs) != 1)\n+  if (!single_succ_p (then_bb))\n     return FALSE;\n \n   /* THEN does not fall through, but is not strange either.  */\n-  if (EDGE_SUCC (then_bb, 0)->flags & (EDGE_COMPLEX | EDGE_FALLTHRU))\n+  if (single_succ_edge (then_bb)->flags & (EDGE_COMPLEX | EDGE_FALLTHRU))\n     return FALSE;\n \n   /* THEN has one predecessor.  */\n-  if (EDGE_COUNT (then_bb->preds) != 1)\n+  if (!single_pred_p (then_bb))\n     return FALSE;\n \n   /* THEN must do something.  */\n@@ -2902,7 +2901,7 @@ find_if_case_1 (basic_block test_bb, edge then_edge, edge else_edge)\n \n   /* Registers set are dead, or are predicable.  */\n   if (! dead_or_predicable (test_bb, then_bb, else_bb,\n-\t\t\t    EDGE_SUCC (then_bb, 0)->dest, 1))\n+\t\t\t    single_succ (then_bb), 1))\n     return FALSE;\n \n   /* Conversion went ok, including moving the insns and fixing up the\n@@ -2980,17 +2979,17 @@ find_if_case_2 (basic_block test_bb, edge then_edge, edge else_edge)\n     return FALSE;\n \n   /* ELSE has one successor.  */\n-  if (EDGE_COUNT (else_bb->succs) != 1)\n+  if (!single_succ_p (else_bb))\n     return FALSE;\n   else\n-    else_succ = EDGE_SUCC (else_bb, 0);\n+    else_succ = single_succ_edge (else_bb);\n \n   /* ELSE outgoing edge is not complex.  */\n   if (else_succ->flags & EDGE_COMPLEX)\n     return FALSE;\n \n   /* ELSE has one predecessor.  */\n-  if (EDGE_COUNT (else_bb->preds) != 1)\n+  if (!single_pred_p (else_bb))\n     return FALSE;\n \n   /* THEN is not EXIT.  */"}, {"sha": "6c7fabba810c77bd009a2d30be50c6c536b0228c", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -2320,7 +2320,7 @@ perfect_nestify (struct loops *loops,\n       VEC_safe_push (tree, phis, PHI_RESULT (phi));\n       VEC_safe_push (tree, phis, PHI_ARG_DEF (phi, 0));\n     }\n-  e = redirect_edge_and_branch (EDGE_SUCC (preheaderbb, 0), headerbb);\n+  e = redirect_edge_and_branch (single_succ_edge (preheaderbb), headerbb);\n \n   /* Remove the exit phis from the old basic block.  Make sure to set\n      PHI_RESULT to null so it doesn't get released.  */\n@@ -2338,7 +2338,7 @@ perfect_nestify (struct loops *loops,\n       def = VEC_pop (tree, phis);\n       phiname = VEC_pop (tree, phis);      \n       phi = create_phi_node (phiname, preheaderbb);\n-      add_phi_arg (phi, def, EDGE_PRED (preheaderbb, 0));\n+      add_phi_arg (phi, def, single_pred_edge (preheaderbb));\n     }       \n   flush_pending_stmts (e);\n "}, {"sha": "4f2f4062ce6950bd0eaf6b6630f0241d392688ba", "filename": "gcc/lcm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -1194,7 +1194,7 @@ optimize_mode_switching (FILE *file)\n #if defined (MODE_ENTRY) && defined (MODE_EXIT)\n   /* Split the edge from the entry block, so that we can note that\n      there NORMAL_MODE is supplied.  */\n-  post_entry = split_edge (EDGE_SUCC (ENTRY_BLOCK_PTR, 0));\n+  post_entry = split_edge (single_succ_edge (ENTRY_BLOCK_PTR));\n   pre_exit = create_pre_exit (n_entities, entity_map, num_modes);\n #endif\n "}, {"sha": "737761b962c2a509f51b53d2e7fb041fed53dcce", "filename": "gcc/loop-doloop.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Floop-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Floop-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-doloop.c?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -359,11 +359,11 @@ doloop_modify (struct loop *loop, struct niter_desc *desc,\n       /* Expand the condition testing the assumptions and if it does not pass,\n \t reset the count register to 0.  */\n       add_test (XEXP (ass, 0), preheader, set_zero);\n-      EDGE_SUCC (preheader, 0)->flags &= ~EDGE_FALLTHRU;\n-      cnt = EDGE_SUCC (preheader, 0)->count;\n-      EDGE_SUCC (preheader, 0)->probability = 0;\n-      EDGE_SUCC (preheader, 0)->count = 0;\n-      irr = EDGE_SUCC (preheader, 0)->flags & EDGE_IRREDUCIBLE_LOOP;\n+      single_succ_edge (preheader)->flags &= ~EDGE_FALLTHRU;\n+      cnt = single_succ_edge (preheader)->count;\n+      single_succ_edge (preheader)->probability = 0;\n+      single_succ_edge (preheader)->count = 0;\n+      irr = single_succ_edge (preheader)->flags & EDGE_IRREDUCIBLE_LOOP;\n       te = make_edge (preheader, new_preheader, EDGE_FALLTHRU | irr);\n       te->probability = REG_BR_PROB_BASE;\n       te->count = cnt;\n@@ -375,7 +375,7 @@ doloop_modify (struct loop *loop, struct niter_desc *desc,\n       for (ass = XEXP (ass, 1); ass; ass = XEXP (ass, 1))\n \t{\n \t  bb = loop_split_edge_with (te, NULL_RTX);\n-\t  te = EDGE_SUCC (bb, 0);\n+\t  te = single_succ_edge (bb);\n \t  add_test (XEXP (ass, 0), bb, set_zero);\n \t  make_edge (bb, set_zero, irr);\n \t}"}, {"sha": "2eddb6d1d18f389b6b83efa977f6e9163fccbf0a", "filename": "gcc/loop-init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Floop-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Floop-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-init.c?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -49,7 +49,7 @@ loop_optimizer_init (FILE *dumpfile)\n      block.  */\n \n   for (ei = ei_start (EXIT_BLOCK_PTR->preds); (e = ei_safe_edge (ei)); )\n-    if ((e->flags & EDGE_FALLTHRU) && EDGE_COUNT (e->src->succs) > 1)\n+    if ((e->flags & EDGE_FALLTHRU) && !single_succ_p (e->src))\n       split_edge (e);\n     else\n       ei_next (&ei);"}, {"sha": "55faf4a7097fd3e2d04c3ef3c3fc27b6fc25ab05", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -1781,8 +1781,6 @@ simplify_using_initial_values (struct loop *loop, enum rtx_code op, rtx *expr)\n \n   while (1)\n     {\n-      basic_block tmp_bb;\n-\n       insn = BB_END (e->src);\n       if (any_condjump_p (insn))\n \t{\n@@ -1814,14 +1812,10 @@ simplify_using_initial_values (struct loop *loop, enum rtx_code op, rtx *expr)\n \t    }\n \t}\n \n-      /* This is a bit subtle.  Store away e->src in tmp_bb, since we\n-\t modify `e' and this can invalidate the subsequent count of\n-\t e->src's predecessors by looking at the wrong block.  */\n-      tmp_bb = e->src;\n-      e = EDGE_PRED (tmp_bb, 0);\n-      if (EDGE_COUNT (tmp_bb->preds) > 1\n-\t  || e->src == ENTRY_BLOCK_PTR)\n+      if (!single_pred_p (e->src)\n+\t  || single_pred (e->src) == ENTRY_BLOCK_PTR)\n \tbreak;\n+      e = single_pred_edge (e->src);\n     }\n \n   FREE_REG_SET (altered);"}, {"sha": "0112961ce53dd350cc72249b9f26d77ef285b7b7", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -1043,11 +1043,11 @@ unroll_loop_runtime_iterations (struct loops *loops, struct loop *loop)\n       branch_code = compare_and_jump_seq (copy_rtx (niter), GEN_INT (j), EQ,\n \t\t\t\t\t  block_label (preheader), p, NULL_RTX);\n \n-      swtch = loop_split_edge_with (EDGE_PRED (swtch, 0), branch_code);\n+      swtch = loop_split_edge_with (single_pred_edge (swtch), branch_code);\n       set_immediate_dominator (CDI_DOMINATORS, preheader, swtch);\n-      EDGE_SUCC (swtch, 0)->probability = REG_BR_PROB_BASE - p;\n+      single_pred_edge (swtch)->probability = REG_BR_PROB_BASE - p;\n       e = make_edge (swtch, preheader,\n-\t\t     EDGE_SUCC (swtch, 0)->flags & EDGE_IRREDUCIBLE_LOOP);\n+\t\t     single_succ_edge (swtch)->flags & EDGE_IRREDUCIBLE_LOOP);\n       e->probability = p;\n     }\n \n@@ -1060,11 +1060,11 @@ unroll_loop_runtime_iterations (struct loops *loops, struct loop *loop)\n       branch_code = compare_and_jump_seq (copy_rtx (niter), const0_rtx, EQ,\n \t\t\t\t\t  block_label (preheader), p, NULL_RTX);\n \n-      swtch = loop_split_edge_with (EDGE_SUCC (swtch, 0), branch_code);\n+      swtch = loop_split_edge_with (single_succ_edge (swtch), branch_code);\n       set_immediate_dominator (CDI_DOMINATORS, preheader, swtch);\n-      EDGE_SUCC (swtch, 0)->probability = REG_BR_PROB_BASE - p;\n+      single_succ_edge (swtch)->probability = REG_BR_PROB_BASE - p;\n       e = make_edge (swtch, preheader,\n-\t\t     EDGE_SUCC (swtch, 0)->flags & EDGE_IRREDUCIBLE_LOOP);\n+\t\t     single_succ_edge (swtch)->flags & EDGE_IRREDUCIBLE_LOOP);\n       e->probability = p;\n     }\n "}, {"sha": "bb014bde465b0a201bc16fa9bb1d012569d14a44", "filename": "gcc/loop-unswitch.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Floop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Floop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unswitch.c?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -443,7 +443,7 @@ unswitch_loop (struct loops *loops, struct loop *loop, basic_block unswitch_on,\n   unswitch_on_alt = unswitch_on->rbi->copy;\n   true_edge = BRANCH_EDGE (unswitch_on_alt);\n   false_edge = FALLTHRU_EDGE (unswitch_on);\n-  latch_edge = EDGE_SUCC (loop->latch->rbi->copy, 0);\n+  latch_edge = single_succ_edge (loop->latch->rbi->copy);\n \n   /* Create a block with the condition.  */\n   prob = true_edge->probability;\n@@ -474,7 +474,7 @@ unswitch_loop (struct loops *loops, struct loop *loop, basic_block unswitch_on,\n \n   /* Loopify from the copy of LOOP body, constructing the new loop.  */\n   nloop = loopify (loops, latch_edge,\n-\t\t   EDGE_PRED (loop->header->rbi->copy, 0), switch_bb,\n+\t\t   single_pred_edge (loop->header->rbi->copy), switch_bb,\n \t\t   BRANCH_EDGE (switch_bb), FALLTHRU_EDGE (switch_bb), true);\n \n   /* Remove branches that are now unreachable in new loops.  */"}, {"sha": "56717279436372d8bcb2289d862833d463db8c6a", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -739,7 +739,7 @@ generate_prolog_epilog (partial_schedule_ptr ps, rtx orig_loop_beg,\n       basic_block epilog_bb = BLOCK_FOR_INSN (last_epilog_insn);\n       basic_block precond_bb = BLOCK_FOR_INSN (precond_jump);\n       basic_block orig_loop_bb = BLOCK_FOR_INSN (precond_exit_label_insn);\n-      edge epilog_exit_edge = EDGE_SUCC (epilog_bb, 0);\n+      edge epilog_exit_edge = single_succ_edge (epilog_bb);\n \n       /* Do loop preconditioning to take care of cases were the loop count is\n \t less than the stage count.  Update the CFG properly.  */"}, {"sha": "efb12f7037c759ef255554850077d17091afc8bd", "filename": "gcc/predict.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -434,22 +434,22 @@ combine_predictions_for_insn (rtx insn, basic_block bb)\n \n       /* Save the prediction into CFG in case we are seeing non-degenerated\n \t conditional jump.  */\n-      if (EDGE_COUNT (bb->succs) > 1)\n+      if (!single_succ_p (bb))\n \t{\n \t  BRANCH_EDGE (bb)->probability = combined_probability;\n \t  FALLTHRU_EDGE (bb)->probability\n \t    = REG_BR_PROB_BASE - combined_probability;\n \t}\n     }\n-  else if (EDGE_COUNT (bb->succs) > 1)\n+  else if (!single_succ_p (bb))\n     {\n       int prob = INTVAL (XEXP (prob_note, 0));\n \n       BRANCH_EDGE (bb)->probability = prob;\n       FALLTHRU_EDGE (bb)->probability = REG_BR_PROB_BASE - prob;\n     }\n   else\n-    EDGE_SUCC (bb, 0)->probability = REG_BR_PROB_BASE;\n+    single_succ_edge (bb)->probability = REG_BR_PROB_BASE;\n }\n \n /* Combine predictions into single probability and store them into CFG.\n@@ -833,8 +833,8 @@ estimate_probability (struct loops *loops_info)\n \t     care for error returns and other are often used for fast paths\n \t     trought function.  */\n \t  if ((e->dest == EXIT_BLOCK_PTR\n-\t       || (EDGE_COUNT (e->dest->succs) == 1\n-\t\t   && EDGE_SUCC (e->dest, 0)->dest == EXIT_BLOCK_PTR))\n+\t       || (single_succ_p (e->dest)\n+\t\t   && single_succ (e->dest) == EXIT_BLOCK_PTR))\n \t       && !predicted_by_p (bb, PRED_NULL_RETURN)\n \t       && !predicted_by_p (bb, PRED_CONST_RETURN)\n \t       && !predicted_by_p (bb, PRED_NEGATIVE_RETURN)\n@@ -1314,7 +1314,7 @@ tree_estimate_probability (void)\n \t     fast paths trought function.  */\n \t  if (e->dest == EXIT_BLOCK_PTR\n \t      && TREE_CODE (last_stmt (bb)) == RETURN_EXPR\n-\t      && EDGE_COUNT (bb->preds) > 1)\n+\t      && !single_pred_p (bb))\n \t    {\n \t      edge e1;\n \t      edge_iterator ei1;\n@@ -1457,8 +1457,8 @@ last_basic_block_p (basic_block bb)\n \n   return (bb->next_bb == EXIT_BLOCK_PTR\n \t  || (bb->next_bb->next_bb == EXIT_BLOCK_PTR\n-\t      && EDGE_COUNT (bb->succs) == 1\n-\t      && EDGE_SUCC (bb, 0)->dest->next_bb == EXIT_BLOCK_PTR));\n+\t      && single_succ_p (bb)\n+\t      && single_succ (bb)->next_bb == EXIT_BLOCK_PTR));\n }\n \n /* Sets branch probabilities according to PREDiction and\n@@ -1811,7 +1811,7 @@ estimate_bb_frequencies (struct loops *loops)\n \n       mark_dfs_back_edges ();\n \n-      EDGE_SUCC (ENTRY_BLOCK_PTR, 0)->probability = REG_BR_PROB_BASE;\n+      single_succ_edge (ENTRY_BLOCK_PTR)->probability = REG_BR_PROB_BASE;\n \n       /* Set up block info for each basic block.  */\n       tovisit = BITMAP_ALLOC (NULL);"}, {"sha": "b879aa0322f84f59a02edf9af59f4be756ca956c", "filename": "gcc/profile.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -1052,10 +1052,10 @@ branch_prob (void)\n \n \t      /* Notice GOTO expressions we eliminated while constructing the\n \t\t CFG.  */\n-\t      if (EDGE_COUNT (bb->succs) == 1 && EDGE_SUCC (bb, 0)->goto_locus)\n+\t      if (single_succ_p (bb) && single_succ_edge (bb)->goto_locus)\n \t\t{\n \t\t  /* ??? source_locus type is marked deprecated in input.h.  */\n-\t\t  source_locus curr_location = EDGE_SUCC (bb, 0)->goto_locus;\n+\t\t  source_locus curr_location = single_succ_edge (bb)->goto_locus;\n \t\t  /* ??? The FILE/LINE API is inconsistent for these cases.  */\n #ifdef USE_MAPPED_LOCATION \n \t\t  output_location (LOCATION_FILE (curr_location),"}, {"sha": "1f0bafde116f2939eecc0de8917a29c3be1f22c6", "filename": "gcc/regrename.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -1766,11 +1766,11 @@ copyprop_hardreg_forward (void)\n \t processed, begin with the value data that was live at\n \t the end of the predecessor block.  */\n       /* ??? Ought to use more intelligent queuing of blocks.  */\n-      if (EDGE_COUNT (bb->preds) == 1\n+      if (single_pred_p (bb)\n \t  && TEST_BIT (visited,\n-\t\t       EDGE_PRED (bb, 0)->src->index - (INVALID_BLOCK + 1))\n-\t  && ! (EDGE_PRED (bb, 0)->flags & (EDGE_ABNORMAL_CALL | EDGE_EH)))\n-\tall_vd[bb->index] = all_vd[EDGE_PRED (bb, 0)->src->index];\n+\t\t       single_pred (bb)->index - (INVALID_BLOCK + 1))\n+\t  && ! (single_pred_edge (bb)->flags & (EDGE_ABNORMAL_CALL | EDGE_EH)))\n+\tall_vd[bb->index] = all_vd[single_pred (bb)->index];\n       else\n \tinit_value_data (all_vd + bb->index);\n "}, {"sha": "7c6afbe35810e195b99be572ca676addb30f1b25", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -337,8 +337,8 @@ is_cfg_nonregular (void)\n   FOR_EACH_BB (b)\n     {\n       if (EDGE_COUNT (b->preds) == 0\n-\t  || (EDGE_PRED (b, 0)->src == b\n-\t      && EDGE_COUNT (b->preds) == 1))\n+\t  || (single_pred_p (b)\n+\t      && single_pred (b) == b))\n \treturn 1;\n     }\n \n@@ -537,7 +537,7 @@ find_rgns (void)\n \n   /* DFS traversal to find inner loops in the cfg.  */\n \n-  current_edge = ei_start (EDGE_SUCC (ENTRY_BLOCK_PTR, 0)->dest->succs);\n+  current_edge = ei_start (single_succ (ENTRY_BLOCK_PTR)->succs);\n   sp = -1;\n \n   while (1)\n@@ -727,8 +727,8 @@ find_rgns (void)\n \t\t  FOR_EACH_BB (jbb)\n \t\t    /* Leaf nodes have only a single successor which must\n \t\t       be EXIT_BLOCK.  */\n-\t\t    if (EDGE_COUNT (jbb->succs) == 1\n-\t\t\t&& EDGE_SUCC (jbb, 0)->dest == EXIT_BLOCK_PTR)\n+\t\t    if (single_succ_p (jbb)\n+\t\t\t&& single_succ (jbb) == EXIT_BLOCK_PTR)\n \t\t      {\n \t\t\tqueue[++tail] = jbb->index;\n \t\t\tSET_BIT (in_queue, jbb->index);\n@@ -1323,7 +1323,7 @@ update_live (rtx insn, int src)\n   (bb_from == bb_to\t\t\t\t\t\t\t\\\n    || IS_RGN_ENTRY (bb_from)\t\t\t\t\t\t\\\n    || (TEST_BIT (ancestor_edges[bb_to],\t\t\t\t\t\\\n-\t EDGE_TO_BIT (EDGE_PRED (BASIC_BLOCK (BB_TO_BLOCK (bb_from)), 0)))))\n+\t EDGE_TO_BIT (single_pred_edge (BASIC_BLOCK (BB_TO_BLOCK (bb_from)))))))\n \n /* Turns on the fed_by_spec_load flag for insns fed by load_insn.  */\n "}, {"sha": "3045a62fea41e19df58c995139a60215f0b7b532", "filename": "gcc/tracer.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -321,8 +321,8 @@ tail_duplicate (void)\n static void\n layout_superblocks (void)\n {\n-  basic_block end = EDGE_SUCC (ENTRY_BLOCK_PTR, 0)->dest;\n-  basic_block bb = EDGE_SUCC (ENTRY_BLOCK_PTR, 0)->dest->next_bb;\n+  basic_block end = single_succ (ENTRY_BLOCK_PTR);\n+  basic_block bb = end->next_bb;\n \n   while (bb != EXIT_BLOCK_PTR)\n     {\n@@ -333,7 +333,7 @@ layout_superblocks (void)\n \n       FOR_EACH_EDGE (e, ei, end->succs)\n \tif (e->dest != EXIT_BLOCK_PTR\n-\t    && e->dest != EDGE_SUCC (ENTRY_BLOCK_PTR, 0)->dest\n+\t    && e->dest != single_succ (ENTRY_BLOCK_PTR)\n \t    && !e->dest->rbi->visited\n \t    && (!best || EDGE_FREQUENCY (e) > EDGE_FREQUENCY (best)))\n \t  best = e;"}, {"sha": "0adfb3bd91225154ebf3371fd31ebfcaa4e8e650", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 37, "deletions": 35, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -1260,16 +1260,16 @@ tree_can_merge_blocks_p (basic_block a, basic_block b)\n   tree stmt;\n   block_stmt_iterator bsi;\n \n-  if (EDGE_COUNT (a->succs) != 1)\n+  if (!single_succ_p (a))\n     return false;\n \n-  if (EDGE_SUCC (a, 0)->flags & EDGE_ABNORMAL)\n+  if (single_succ_edge (a)->flags & EDGE_ABNORMAL)\n     return false;\n \n-  if (EDGE_SUCC (a, 0)->dest != b)\n+  if (single_succ (a) != b)\n     return false;\n \n-  if (EDGE_COUNT (b->preds) > 1)\n+  if (!single_pred_p (b))\n     return false;\n \n   if (b == EXIT_BLOCK_PTR)\n@@ -1324,7 +1324,7 @@ tree_merge_blocks (basic_block a, basic_block b)\n   /* Ensure that B follows A.  */\n   move_block_after (b, a);\n \n-  gcc_assert (EDGE_SUCC (a, 0)->flags & EDGE_FALLTHRU);\n+  gcc_assert (single_succ_edge (a)->flags & EDGE_FALLTHRU);\n   gcc_assert (!last_stmt (a) || !stmt_ends_bb_p (last_stmt (a)));\n \n   /* Remove labels from B and set bb_for_stmt to A for other statements.  */\n@@ -1922,29 +1922,30 @@ cfg_remove_useless_stmts_bb (basic_block bb)\n \n   /* Check whether we come here from a condition, and if so, get the\n      condition.  */\n-  if (EDGE_COUNT (bb->preds) != 1\n-      || !(EDGE_PRED (bb, 0)->flags & (EDGE_TRUE_VALUE | EDGE_FALSE_VALUE)))\n+  if (!single_pred_p (bb)\n+      || !(single_pred_edge (bb)->flags\n+\t   & (EDGE_TRUE_VALUE | EDGE_FALSE_VALUE)))\n     return;\n \n-  cond = COND_EXPR_COND (last_stmt (EDGE_PRED (bb, 0)->src));\n+  cond = COND_EXPR_COND (last_stmt (single_pred (bb)));\n \n   if (TREE_CODE (cond) == VAR_DECL || TREE_CODE (cond) == PARM_DECL)\n     {\n       var = cond;\n-      val = (EDGE_PRED (bb, 0)->flags & EDGE_FALSE_VALUE\n+      val = (single_pred_edge (bb)->flags & EDGE_FALSE_VALUE\n \t     ? boolean_false_node : boolean_true_node);\n     }\n   else if (TREE_CODE (cond) == TRUTH_NOT_EXPR\n \t   && (TREE_CODE (TREE_OPERAND (cond, 0)) == VAR_DECL\n \t       || TREE_CODE (TREE_OPERAND (cond, 0)) == PARM_DECL))\n     {\n       var = TREE_OPERAND (cond, 0);\n-      val = (EDGE_PRED (bb, 0)->flags & EDGE_FALSE_VALUE\n+      val = (single_pred_edge (bb)->flags & EDGE_FALSE_VALUE\n \t     ? boolean_true_node : boolean_false_node);\n     }\n   else\n     {\n-      if (EDGE_PRED (bb, 0)->flags & EDGE_FALSE_VALUE)\n+      if (single_pred_edge (bb)->flags & EDGE_FALSE_VALUE)\n \tcond = invert_truthvalue (cond);\n       if (TREE_CODE (cond) == EQ_EXPR\n \t  && (TREE_CODE (TREE_OPERAND (cond, 0)) == VAR_DECL\n@@ -2208,10 +2209,10 @@ cleanup_control_flow (void)\n \t      else\n \t        {\n \t\t  /* Turn off the EDGE_ABNORMAL flag.  */\n-\t\t  EDGE_SUCC (bb, 0)->flags &= ~EDGE_ABNORMAL;\n+\t\t  e->flags &= ~EDGE_ABNORMAL;\n \n \t\t  /* And set EDGE_FALLTHRU.  */\n-\t\t  EDGE_SUCC (bb, 0)->flags |= EDGE_FALLTHRU;\n+\t\t  e->flags |= EDGE_FALLTHRU;\n \t\t  ei_next (&ei);\n \t\t}\n \t    }\n@@ -2249,7 +2250,7 @@ cleanup_control_expr_graph (basic_block bb, block_stmt_iterator bsi)\n   bool retval = false;\n   tree expr = bsi_stmt (bsi), val;\n \n-  if (EDGE_COUNT (bb->succs) > 1)\n+  if (!single_succ_p (bb))\n     {\n       edge e;\n       edge_iterator ei;\n@@ -2291,7 +2292,7 @@ cleanup_control_expr_graph (basic_block bb, block_stmt_iterator bsi)\n \ttaken_edge->probability = REG_BR_PROB_BASE;\n     }\n   else\n-    taken_edge = EDGE_SUCC (bb, 0);\n+    taken_edge = single_succ_edge (bb);\n \n   bsi_remove (&bsi);\n   taken_edge->flags = EDGE_FALLTHRU;\n@@ -2862,14 +2863,14 @@ disband_implicit_edges (void)\n \t{\n \t  /* Remove the RETURN_EXPR if we may fall though to the exit\n \t     instead.  */\n-\t  gcc_assert (EDGE_COUNT (bb->succs) == 1);\n-\t  gcc_assert (EDGE_SUCC (bb, 0)->dest == EXIT_BLOCK_PTR);\n+\t  gcc_assert (single_succ_p (bb));\n+\t  gcc_assert (single_succ (bb) == EXIT_BLOCK_PTR);\n \n \t  if (bb->next_bb == EXIT_BLOCK_PTR\n \t      && !TREE_OPERAND (stmt, 0))\n \t    {\n \t      bsi_remove (&last);\n-\t      EDGE_SUCC (bb, 0)->flags |= EDGE_FALLTHRU;\n+\t      single_succ_edge (bb)->flags |= EDGE_FALLTHRU;\n \t    }\n \t  continue;\n \t}\n@@ -3164,7 +3165,7 @@ tree_find_edge_insert_loc (edge e, block_stmt_iterator *bsi,\n      would have to examine the PHIs to prove that none of them used\n      the value set by the statement we want to insert on E.  That\n      hardly seems worth the effort.  */\n-  if (EDGE_COUNT (dest->preds) == 1\n+  if (single_pred_p (dest)\n       && ! phi_nodes (dest)\n       && dest != EXIT_BLOCK_PTR)\n     {\n@@ -3196,7 +3197,7 @@ tree_find_edge_insert_loc (edge e, block_stmt_iterator *bsi,\n      Except for the entry block.  */\n   src = e->src;\n   if ((e->flags & EDGE_ABNORMAL) == 0\n-      && EDGE_COUNT (src->succs) == 1\n+      && single_succ_p (src)\n       && src != ENTRY_BLOCK_PTR)\n     {\n       *bsi = bsi_last (src);\n@@ -3227,7 +3228,7 @@ tree_find_edge_insert_loc (edge e, block_stmt_iterator *bsi,\n   dest = split_edge (e);\n   if (new_bb)\n     *new_bb = dest;\n-  e = EDGE_PRED (dest, 0);\n+  e = single_pred_edge (dest);\n   goto restart;\n }\n \n@@ -3242,7 +3243,7 @@ bsi_commit_edge_inserts (void)\n   edge e;\n   edge_iterator ei;\n \n-  bsi_commit_one_edge_insert (EDGE_SUCC (ENTRY_BLOCK_PTR, 0), NULL);\n+  bsi_commit_one_edge_insert (single_succ_edge (ENTRY_BLOCK_PTR), NULL);\n \n   FOR_EACH_BB (bb)\n     FOR_EACH_EDGE (e, ei, bb->succs)\n@@ -3940,14 +3941,15 @@ tree_verify_flow_info (void)\n \t  break;\n \n \tcase RETURN_EXPR:\n-\t  if (EDGE_COUNT (bb->succs) != 1\n-\t      || (EDGE_SUCC (bb, 0)->flags & (EDGE_FALLTHRU | EDGE_ABNORMAL\n-\t\t  \t\t     | EDGE_TRUE_VALUE | EDGE_FALSE_VALUE)))\n+\t  if (!single_succ_p (bb)\n+\t      || (single_succ_edge (bb)->flags\n+\t\t  & (EDGE_FALLTHRU | EDGE_ABNORMAL\n+\t\t     | EDGE_TRUE_VALUE | EDGE_FALSE_VALUE)))\n \t    {\n \t      error (\"Wrong outgoing edge flags at end of bb %d\\n\", bb->index);\n \t      err = 1;\n \t    }\n-\t  if (EDGE_SUCC (bb, 0)->dest != EXIT_BLOCK_PTR)\n+\t  if (single_succ (bb) != EXIT_BLOCK_PTR)\n \t    {\n \t      error (\"Return edge does not point to exit in bb %d\\n\",\n \t\t     bb->index);\n@@ -4064,7 +4066,7 @@ tree_make_forwarder_block (edge fallthru)\n   dummy = fallthru->src;\n   bb = fallthru->dest;\n \n-  if (EDGE_COUNT (bb->preds) == 1)\n+  if (single_pred_p (bb))\n     return;\n \n   /* If we redirected a branch we must create new phi nodes at the\n@@ -4105,16 +4107,16 @@ tree_forwarder_block_p (basic_block bb, bool phi_wanted)\n   block_stmt_iterator bsi;\n \n   /* BB must have a single outgoing edge.  */\n-  if (EDGE_COUNT (bb->succs) != 1\n+  if (single_succ_p (bb) != 1\n       /* If PHI_WANTED is false, BB must not have any PHI nodes.\n \t Otherwise, BB must have PHI nodes.  */\n       || (phi_nodes (bb) != NULL_TREE) != phi_wanted\n       /* BB may not be a predecessor of EXIT_BLOCK_PTR.  */\n-      || EDGE_SUCC (bb, 0)->dest == EXIT_BLOCK_PTR\n+      || single_succ (bb) == EXIT_BLOCK_PTR\n       /* Nor should this be an infinite loop.  */\n-      || EDGE_SUCC (bb, 0)->dest == bb\n+      || single_succ (bb) == bb\n       /* BB may not have an abnormal outgoing edge.  */\n-      || (EDGE_SUCC (bb, 0)->flags & EDGE_ABNORMAL))\n+      || (single_succ_edge (bb)->flags & EDGE_ABNORMAL))\n     return false; \n \n #if ENABLE_CHECKING\n@@ -4179,7 +4181,7 @@ has_abnormal_incoming_edge_p (basic_block bb)\n static bool\n remove_forwarder_block (basic_block bb, basic_block **worklist)\n {\n-  edge succ = EDGE_SUCC (bb, 0), e, s;\n+  edge succ = single_succ_edge (bb), e, s;\n   basic_block dest = succ->dest;\n   tree label;\n   tree phi;\n@@ -4338,7 +4340,7 @@ cleanup_forwarder_blocks (void)\n static void\n remove_forwarder_block_with_phi (basic_block bb)\n {\n-  edge succ = EDGE_SUCC (bb, 0);\n+  edge succ = single_succ_edge (bb);\n   basic_block dest = succ->dest;\n   tree label;\n   basic_block dombb, domdest, dom;\n@@ -4379,7 +4381,7 @@ remove_forwarder_block_with_phi (basic_block bb)\n \t  /* PHI arguments are different.  Create a forwarder block by\n \t     splitting E so that we can merge PHI arguments on E to\n \t     DEST.  */\n-\t  e = EDGE_SUCC (split_edge (e), 0);\n+\t  e = single_succ_edge (split_edge (e));\n \t}\n \n       s = redirect_edge_and_branch (e, dest);\n@@ -4481,7 +4483,7 @@ merge_phi_nodes (void)\n       if (!tree_forwarder_block_p (bb, true))\n \tcontinue;\n \n-      dest = EDGE_SUCC (bb, 0)->dest;\n+      dest = single_succ (bb);\n \n       /* We have to feed into another basic block with PHI\n \t nodes.  */"}, {"sha": "74e2e74c33a2097e7e2d0514471e1ec48e0736bb", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -187,9 +187,9 @@ tree_if_conversion (struct loop *loop, bool for_vectorizer)\n \n       /* If current bb has only one successor, then consider it as an\n \t unconditional goto.  */\n-      if (EDGE_COUNT (bb->succs) == 1)\n+      if (single_succ_p (bb))\n \t{\n-\t  basic_block bb_n = EDGE_SUCC (bb, 0)->dest;\n+\t  basic_block bb_n = single_succ (bb);\n \t  if (cond != NULL_TREE)\n \t    add_to_predicate_list (bb_n, cond);\n \t  cond = NULL_TREE;"}, {"sha": "c2e09ad5c74cc6c22baa26b5475ca13d06b92b29", "filename": "gcc/tree-mudflap.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Ftree-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Ftree-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-mudflap.c?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -545,7 +545,7 @@ mf_build_check_statement_for (tree base, tree limit,\n \n   /* We expect that the conditional jump we will construct will not\n      be taken very often as it basically is an exception condition.  */\n-  predict_edge_def (EDGE_PRED (then_bb, 0), PRED_MUDFLAP, NOT_TAKEN);\n+  predict_edge_def (single_pred_edge (then_bb), PRED_MUDFLAP, NOT_TAKEN);\n \n   /* Mark the pseudo-fallthrough edge from cond_bb to join_bb.  */\n   e = find_edge (cond_bb, join_bb);"}, {"sha": "140282c8dc2202980f48f46b3c70dae50a686819", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -757,7 +757,7 @@ remove_dead_stmt (block_stmt_iterator *i, basic_block bb)\n \tEDGE_SUCC (bb, 0)->flags &= ~EDGE_FALLTHRU;\n \n       /* Remove the remaining the outgoing edges.  */\n-      while (EDGE_COUNT (bb->succs) != 1)\n+      while (!single_succ_p (bb))\n         remove_edge (EDGE_SUCC (bb, 1));\n     }\n   "}, {"sha": "3f5adf63f9286f5566783f2a44672b1039ba75be", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -995,13 +995,13 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n      the edge from BB through its successor.\n \n      Do this before we remove entries from our equivalence tables.  */\n-  if (EDGE_COUNT (bb->succs) == 1\n-      && (EDGE_SUCC (bb, 0)->flags & EDGE_ABNORMAL) == 0\n-      && (get_immediate_dominator (CDI_DOMINATORS, EDGE_SUCC (bb, 0)->dest) != bb\n-\t  || phi_nodes (EDGE_SUCC (bb, 0)->dest)))\n+  if (single_succ_p (bb)\n+      && (single_succ_edge (bb)->flags & EDGE_ABNORMAL) == 0\n+      && (get_immediate_dominator (CDI_DOMINATORS, single_succ (bb)) != bb\n+\t  || phi_nodes (single_succ (bb))))\n \t\n     {\n-      thread_across_edge (walk_data, EDGE_SUCC (bb, 0));\n+      thread_across_edge (walk_data, single_succ_edge (bb));\n     }\n   else if ((last = last_stmt (bb))\n \t   && TREE_CODE (last) == GOTO_EXPR"}, {"sha": "5a16822c844106f0c57dfb25928a2aecbd598d99", "filename": "gcc/tree-ssa-loop-ch.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Ftree-ssa-loop-ch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Ftree-ssa-loop-ch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ch.c?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -60,15 +60,15 @@ should_duplicate_loop_header_p (basic_block header, struct loop *loop,\n     return false;\n \n   gcc_assert (EDGE_COUNT (header->succs) > 0);\n-  if (EDGE_COUNT (header->succs) == 1)\n+  if (single_succ_p (header))\n     return false;\n   if (flow_bb_inside_loop_p (loop, EDGE_SUCC (header, 0)->dest)\n       && flow_bb_inside_loop_p (loop, EDGE_SUCC (header, 1)->dest))\n     return false;\n \n   /* If this is not the original loop header, we want it to have just\n      one predecessor in order to match the && pattern.  */\n-  if (header != loop->header && EDGE_COUNT (header->preds) >= 2)\n+  if (header != loop->header && !single_pred_p (header))\n     return false;\n \n   last = last_stmt (header);\n@@ -193,8 +193,8 @@ copy_loop_headers (void)\n \n       /* Ensure that the header will have just the latch as a predecessor\n \t inside the loop.  */\n-      if (EDGE_COUNT (exit->dest->preds) > 1)\n-\texit = EDGE_SUCC (loop_split_edge_with (exit, NULL), 0);\n+      if (!single_pred_p (exit->dest))\n+\texit = single_succ_edge (loop_split_edge_with (exit, NULL));\n \n       if (!tree_duplicate_sese_region (loop_preheader_edge (loop), exit,\n \t\t\t\t       bbs, n_bbs, NULL))"}, {"sha": "4b695aa98ce74d46c9f36e4f8e06e1eb33243151", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -644,8 +644,8 @@ loop_commit_inserts (void)\n     {\n       bb = BASIC_BLOCK (i);\n       add_bb_to_loop (bb,\n-\t\t      find_common_loop (EDGE_SUCC (bb, 0)->dest->loop_father,\n-\t\t\t\t\tEDGE_PRED (bb, 0)->src->loop_father));\n+\t\t      find_common_loop (single_pred (bb)->loop_father,\n+\t\t\t\t\tsingle_succ (bb)->loop_father));\n     }\n }\n "}, {"sha": "877f5e45a037482ca6da7f4b4342b2ebb017abdb", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -4987,7 +4987,7 @@ compute_phi_arg_on_exit (edge exit, tree stmts, tree op)\n   block_stmt_iterator bsi;\n   tree phi, stmt, def, next;\n \n-  if (EDGE_COUNT (exit->dest->preds) > 1)\n+  if (!single_pred_p (exit->dest))\n     split_loop_exit_edge (exit);\n \n   if (TREE_CODE (stmts) == STATEMENT_LIST)"}, {"sha": "71d3461481660c343b66c420e054170a5a535631", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -442,7 +442,7 @@ split_loop_exit_edge (edge exit)\n \n   for (phi = phi_nodes (dest); phi; phi = PHI_CHAIN (phi))\n     {\n-      op_p = PHI_ARG_DEF_PTR_FROM_EDGE (phi, EDGE_SUCC (bb, 0));\n+      op_p = PHI_ARG_DEF_PTR_FROM_EDGE (phi, single_succ_edge (bb));\n \n       name = USE_FROM_PTR (op_p);\n \n@@ -506,10 +506,10 @@ ip_normal_pos (struct loop *loop)\n   basic_block bb;\n   edge exit;\n \n-  if (EDGE_COUNT (loop->latch->preds) > 1)\n+  if (!single_pred_p (loop->latch))\n     return NULL;\n \n-  bb = EDGE_PRED (loop->latch, 0)->src;\n+  bb = single_pred (loop->latch);\n   last = last_stmt (bb);\n   if (TREE_CODE (last) != COND_EXPR)\n     return NULL;\n@@ -757,7 +757,7 @@ lv_adjust_loop_entry_edge (basic_block first_head,\n \n   /* Adjust edges appropriately to connect new head with first head\n      as well as second head.  */\n-  e0 = EDGE_SUCC (new_head, 0);\n+  e0 = single_succ_edge (new_head);\n   e0->flags &= ~EDGE_FALLTHRU;\n   e0->flags |= EDGE_FALSE_VALUE;\n   e1 = make_edge (new_head, first_head, EDGE_TRUE_VALUE);\n@@ -816,12 +816,12 @@ tree_ssa_loop_version (struct loops *loops, struct loop * loop,\n   *condition_bb = lv_adjust_loop_entry_edge (first_head, second_head, entry, \n \t\t\t\t\t    cond_expr); \n \n-  latch_edge = EDGE_SUCC (loop->latch->rbi->copy, 0);\n+  latch_edge = single_succ_edge (loop->latch->rbi->copy);\n   \n   extract_true_false_edges_from_block (*condition_bb, &true_edge, &false_edge);\n   nloop = loopify (loops, \n \t\t   latch_edge,\n-\t\t   EDGE_PRED (loop->header->rbi->copy, 0),\n+\t\t   single_pred_edge (loop->header->rbi->copy),\n \t\t   *condition_bb, true_edge, false_edge,\n \t\t   false /* Do not redirect all edges.  */);\n \n@@ -842,7 +842,7 @@ tree_ssa_loop_version (struct loops *loops, struct loop * loop,\n       (*condition_bb)->flags |= BB_IRREDUCIBLE_LOOP;\n       loop_preheader_edge (loop)->flags |= EDGE_IRREDUCIBLE_LOOP;\n       loop_preheader_edge (nloop)->flags |= EDGE_IRREDUCIBLE_LOOP;\n-      EDGE_PRED ((*condition_bb), 0)->flags |= EDGE_IRREDUCIBLE_LOOP;\n+      single_pred_edge ((*condition_bb))->flags |= EDGE_IRREDUCIBLE_LOOP;\n     }\n \n   /* At this point condition_bb is loop predheader with two successors, "}, {"sha": "abeb5002e1bc02200c274081231680e6c2840660", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -682,9 +682,9 @@ simplify_using_initial_conditions (struct loop *loop, tree expr,\n        bb != ENTRY_BLOCK_PTR;\n        bb = get_immediate_dominator (CDI_DOMINATORS, bb))\n     {\n-      e = EDGE_PRED (bb, 0);\n-      if (EDGE_COUNT (bb->preds) > 1)\n+      if (!single_pred_p (bb))\n \tcontinue;\n+      e = single_pred_edge (bb);\n \n       if (!(e->flags & (EDGE_TRUE_VALUE | EDGE_FALSE_VALUE)))\n \tcontinue;"}, {"sha": "8030bc38bdb603899dacb4797f8146e9fcdabbf5", "filename": "gcc/tree-ssa-loop-unswitch.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Ftree-ssa-loop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Ftree-ssa-loop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-unswitch.c?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -169,10 +169,10 @@ simplify_using_entry_checks (struct loop *loop, tree cond)\n \t\t? boolean_true_node\n \t\t: boolean_false_node);\n \n-      if (EDGE_COUNT (e->src->preds) > 1)\n+      if (!single_pred_p (e->src))\n \treturn cond;\n \n-      e = EDGE_PRED (e->src, 0);\n+      e = single_pred_edge (e->src);\n       if (e->src == ENTRY_BLOCK_PTR)\n \treturn cond;\n     }"}, {"sha": "84f7540aea8dd0cfb3183b9c8a7eecc85145555f", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -138,9 +138,9 @@ tree_ssa_phiopt (void)\n        continue;\n \n       /* If either bb1's succ or bb2 or bb2's succ is non NULL.  */\n-      if (EDGE_COUNT (bb1->succs) < 1\n+      if (EDGE_COUNT (bb1->succs) == 0\n           || bb2 == NULL\n-\t  || EDGE_COUNT (bb2->succs) < 1)\n+\t  || EDGE_COUNT (bb2->succs) == 0)\n         continue;\n \n       /* Find the bb which is the fall through to the other.  */\n@@ -161,13 +161,13 @@ tree_ssa_phiopt (void)\n       e1 = EDGE_SUCC (bb1, 0);\n \n       /* Make sure that bb1 is just a fall through.  */\n-      if (EDGE_COUNT (bb1->succs) > 1\n+      if (!single_succ_p (bb1) > 1\n \t  || (e1->flags & EDGE_FALLTHRU) == 0)\n         continue;\n \n       /* Also make that bb1 only have one pred and it is bb.  */\n-      if (EDGE_COUNT (bb1->preds) > 1\n-          || EDGE_PRED (bb1, 0)->src != bb)\n+      if (!single_pred_p (bb1)\n+          || single_pred (bb1) != bb)\n \tcontinue;\n \n       phi = phi_nodes (bb2);\n@@ -471,7 +471,7 @@ value_replacement (basic_block cond_bb, basic_block middle_bb,\n \t edge from OTHER_BLOCK which reaches BB and represents the desired\n \t path from COND_BLOCK.  */\n       if (e->dest == middle_bb)\n-\te = EDGE_SUCC (e->dest, 0);\n+\te = single_succ_edge (e->dest);\n \n       /* Now we know the incoming edge to BB that has the argument for the\n \t RHS of our new assignment statement.  */"}, {"sha": "01617ca1a61ac65793a1c4b0a3b98ff6d93ee573", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -1143,10 +1143,10 @@ compute_antic_aux (basic_block block, bool block_has_abnormal_pred_edge)\n     ;\n   /* If we have one successor, we could have some phi nodes to\n      translate through.  */\n-  else if (EDGE_COUNT (block->succs) == 1)\n+  else if (single_succ_p (block))\n     {\n-      phi_translate_set (ANTIC_OUT, ANTIC_IN(EDGE_SUCC (block, 0)->dest),\n-\t\t\t block, EDGE_SUCC (block, 0)->dest);\n+      phi_translate_set (ANTIC_OUT, ANTIC_IN(single_succ (block)),\n+\t\t\t block, single_succ (block));\n     }\n   /* If we have multiple successors, we take the intersection of all of\n      them.  */\n@@ -1554,7 +1554,7 @@ insert_aux (basic_block block)\n \t\t  bitmap_value_replace_in_set (AVAIL_OUT (block), ssa_name (i));\n \t\t}\n \t    }\n-\t  if (EDGE_COUNT (block->preds) > 1)\n+\t  if (!single_pred_p (block))\n \t    {\n \t      value_set_node_t node;\n \t      for (node = ANTIC_IN (block)->head;\n@@ -2138,9 +2138,9 @@ init_pre (bool do_fre)\n      ENTRY_BLOCK_PTR (FIXME, if ENTRY_BLOCK_PTR had an index number\n      different than -1 we wouldn't have to hack this.  tree-ssa-dce.c\n      needs a similar change).  */\n-  if (EDGE_COUNT (EDGE_SUCC (ENTRY_BLOCK_PTR, 0)->dest->preds) > 1)\n-    if (!(EDGE_SUCC (ENTRY_BLOCK_PTR, 0)->flags & EDGE_ABNORMAL))\n-      split_edge (EDGE_SUCC (ENTRY_BLOCK_PTR, 0));\n+  if (!single_pred_p (single_succ (ENTRY_BLOCK_PTR)))\n+    if (!(single_succ_edge (ENTRY_BLOCK_PTR)->flags & EDGE_ABNORMAL))\n+      split_edge (single_succ_edge (ENTRY_BLOCK_PTR));\n \n   FOR_ALL_BB (bb)\n     bb->aux = xcalloc (1, sizeof (struct bb_value_sets));"}, {"sha": "c0d5b47ec61b6e8dd91c02fc1d580ad33052a834", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -616,9 +616,9 @@ redirect_edges (void **slot, void *data)\n \t\t\t\t\t      rd->outgoing_edge->dest);\n \n \t  /* And fixup the flags on the single remaining edge.  */\n-\t  EDGE_SUCC (local_info->bb, 0)->flags\n+\t  single_succ_edge (local_info->bb)->flags\n \t    &= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE | EDGE_ABNORMAL);\n-\t  EDGE_SUCC (local_info->bb, 0)->flags |= EDGE_FALLTHRU;\n+\t  single_succ_edge (local_info->bb)->flags |= EDGE_FALLTHRU;\n \t}\n     }\n "}, {"sha": "8f4778da0b3607c1b3d74131ae9e6338edad192d", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -211,7 +211,7 @@ independent_of_stmt_p (tree expr, tree at, block_stmt_iterator bsi)\n   /* Mark the blocks in the chain leading to the end.  */\n   at_bb = bb_for_stmt (at);\n   call_bb = bb_for_stmt (bsi_stmt (bsi));\n-  for (bb = call_bb; bb != at_bb; bb = EDGE_SUCC (bb, 0)->dest)\n+  for (bb = call_bb; bb != at_bb; bb = single_succ (bb))\n     bb->aux = &bb->aux;\n   bb->aux = &bb->aux;\n \n@@ -255,7 +255,7 @@ independent_of_stmt_p (tree expr, tree at, block_stmt_iterator bsi)\n     }\n \n   /* Unmark the blocks.  */\n-  for (bb = call_bb; bb != at_bb; bb = EDGE_SUCC (bb, 0)->dest)\n+  for (bb = call_bb; bb != at_bb; bb = single_succ (bb))\n     bb->aux = NULL;\n   bb->aux = NULL;\n \n@@ -382,7 +382,7 @@ find_tail_calls (basic_block bb, struct tailcall **ret)\n   basic_block abb;\n   stmt_ann_t ann;\n \n-  if (EDGE_COUNT (bb->succs) > 1)\n+  if (!single_succ_p (bb))\n     return;\n \n   for (bsi = bsi_last (bb); !bsi_end_p (bsi); bsi_prev (&bsi))\n@@ -482,8 +482,8 @@ find_tail_calls (basic_block bb, struct tailcall **ret)\n \n       while (bsi_end_p (absi))\n \t{\n-\t  ass_var = propagate_through_phis (ass_var, EDGE_SUCC (abb, 0));\n-\t  abb = EDGE_SUCC (abb, 0)->dest;\n+\t  ass_var = propagate_through_phis (ass_var, single_succ_edge (abb));\n+\t  abb = single_succ (abb);\n \t  absi = bsi_start (abb);\n \t}\n \n@@ -701,7 +701,7 @@ eliminate_tail_call (struct tailcall *t)\n   if (TREE_CODE (stmt) == MODIFY_EXPR)\n     stmt = TREE_OPERAND (stmt, 1);\n \n-  first = EDGE_SUCC (ENTRY_BLOCK_PTR, 0)->dest;\n+  first = single_succ (ENTRY_BLOCK_PTR);\n \n   /* Remove the code after call_bsi that will become unreachable.  The\n      possibly unreachable code in other blocks is removed later in\n@@ -721,7 +721,7 @@ eliminate_tail_call (struct tailcall *t)\n     }\n \n   /* Replace the call by a jump to the start of function.  */\n-  e = redirect_edge_and_branch (EDGE_SUCC (t->call_block, 0), first);\n+  e = redirect_edge_and_branch (single_succ_edge (t->call_block), first);\n   gcc_assert (e);\n   PENDING_STMT (e) = NULL_TREE;\n \n@@ -776,7 +776,7 @@ eliminate_tail_call (struct tailcall *t)\n \t  var_ann (param)->default_def = new_name;\n \t  phi = create_phi_node (name, first);\n \t  SSA_NAME_DEF_STMT (name) = phi;\n-\t  add_phi_arg (phi, new_name, EDGE_SUCC (ENTRY_BLOCK_PTR, 0));\n+\t  add_phi_arg (phi, new_name, single_succ_edge (ENTRY_BLOCK_PTR));\n \n \t  /* For all calls the same set of variables should be clobbered.  This\n \t     means that there always should be the appropriate phi node except\n@@ -843,7 +843,7 @@ tree_optimize_tail_calls_1 (bool opt_tailcalls)\n   bool phis_constructed = false;\n   struct tailcall *tailcalls = NULL, *act, *next;\n   bool changed = false;\n-  basic_block first = EDGE_SUCC (ENTRY_BLOCK_PTR, 0)->dest;\n+  basic_block first = single_succ (ENTRY_BLOCK_PTR);\n   tree stmt, param, ret_type, tmp, phi;\n   edge_iterator ei;\n \n@@ -873,8 +873,8 @@ tree_optimize_tail_calls_1 (bool opt_tailcalls)\n       if (!phis_constructed)\n \t{\n \t  /* Ensure that there is only one predecessor of the block.  */\n-\t  if (EDGE_COUNT (first->preds) > 1)\n-\t    first = split_edge (EDGE_SUCC (ENTRY_BLOCK_PTR, 0));\n+\t  if (!single_pred_p (first))\n+\t    first = split_edge (single_succ_edge (ENTRY_BLOCK_PTR));\n \n \t  /* Copy the args if needed.  */\n \t  for (param = DECL_ARGUMENTS (current_function_decl);\n@@ -894,7 +894,7 @@ tree_optimize_tail_calls_1 (bool opt_tailcalls)\n \t      var_ann (param)->default_def = new_name;\n \t      phi = create_phi_node (name, first);\n \t      SSA_NAME_DEF_STMT (name) = phi;\n-\t      add_phi_arg (phi, new_name, EDGE_PRED (first, 0));\n+\t      add_phi_arg (phi, new_name, single_pred_edge (first));\n \t    }\n \t  phis_constructed = true;\n \t}\n@@ -911,7 +911,7 @@ tree_optimize_tail_calls_1 (bool opt_tailcalls)\n \t\t       /* RET_TYPE can be a float when -ffast-maths is\n \t\t\t  enabled.  */\n \t\t       fold_convert (ret_type, integer_zero_node),\n-\t\t       EDGE_PRED (first, 0));\n+\t\t       single_pred_edge (first));\n \t  a_acc = PHI_RESULT (phi);\n \t}\n \n@@ -927,7 +927,7 @@ tree_optimize_tail_calls_1 (bool opt_tailcalls)\n \t\t       /* RET_TYPE can be a float when -ffast-maths is\n \t\t\t  enabled.  */\n \t\t       fold_convert (ret_type, integer_one_node),\n-\t\t       EDGE_PRED (first, 0));\n+\t\t       single_pred_edge (first));\n \t  m_acc = PHI_RESULT (phi);\n \t}\n     }"}, {"sha": "29622b2fcf7a43e41adb02a93a5b3eb8795197bf", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -2309,7 +2309,7 @@ vect_analyze_loop_form (struct loop *loop)\n     }\n \n   /* Make sure there exists a single-predecessor exit bb:  */\n-  if (EDGE_COUNT (loop->single_exit->dest->preds) != 1)\n+  if (!single_pred_p (loop->single_exit->dest))\n     {\n       edge e = loop->single_exit;\n       if (!(e->flags & EDGE_ABNORMAL))"}, {"sha": "fb270baa319b9a788e1c3bfff0b15d1c7972e103", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -1322,7 +1322,7 @@ vect_update_ivs_after_vectorizer (loop_vec_info loop_vinfo, tree niters,\n   /* gcc_assert (vect_can_advance_ivs_p (loop_vinfo)); */\n \n   /* Make sure there exists a single-predecessor exit bb:  */\n-  gcc_assert (EDGE_COUNT (exit_bb->preds) == 1);\n+  gcc_assert (single_pred_p (exit_bb));\n \n   for (phi = phi_nodes (loop->header), phi1 = phi_nodes (update_bb); \n        phi && phi1; \n@@ -1373,7 +1373,7 @@ vect_update_ivs_after_vectorizer (loop_vec_info loop_vinfo, tree niters,\n \n       /* Fix phi expressions in the successor bb.  */\n       gcc_assert (PHI_ARG_DEF_FROM_EDGE (phi1, update_e) ==\n-                  PHI_ARG_DEF_FROM_EDGE (phi, EDGE_SUCC (loop->latch, 0)));\n+                  PHI_ARG_DEF_FROM_EDGE (phi, single_succ_edge (loop->latch)));\n       SET_PHI_ARG_DEF (phi1, update_e->dest_idx, ni_name);\n     }\n }"}, {"sha": "08a923ee6b8a7e0ef07c62fd9c2cd495fa1f49ec", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cbcccf9019f6ed28209f903245cce9cfc73e40/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=c5cbcccf9019f6ed28209f903245cce9cfc73e40", "patch": "@@ -501,7 +501,7 @@ slpeel_update_phi_nodes_for_guard (edge guard_edge,\n   tree orig_phi, new_phi, update_phi;\n   tree guard_arg, loop_arg;\n   basic_block new_merge_bb = guard_edge->dest;\n-  edge e = EDGE_SUCC (new_merge_bb, 0);\n+  edge e = single_succ_edge (new_merge_bb);\n   basic_block update_bb = e->dest;\n   basic_block orig_bb = (entry_phis ? loop->header : update_bb);\n \n@@ -742,7 +742,7 @@ slpeel_add_loop_guard (basic_block guard_bb, tree cond, basic_block exit_bb,\n   edge new_e, enter_e;\n   tree cond_stmt, then_label, else_label;\n \n-  enter_e = EDGE_SUCC (guard_bb, 0);\n+  enter_e = single_succ_edge (guard_bb);\n   enter_e->flags &= ~EDGE_FALLTHRU;\n   enter_e->flags |= EDGE_FALSE_VALUE;\n   bsi = bsi_last (guard_bb);"}]}