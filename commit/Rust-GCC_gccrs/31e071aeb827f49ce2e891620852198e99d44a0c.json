{"sha": "31e071aeb827f49ce2e891620852198e99d44a0c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzFlMDcxYWViODI3ZjQ5Y2UyZTg5MTYyMDg1MjE5OGU5OWQ0NGEwYw==", "commit": {"author": {"name": "Marek Polacek", "email": "mpolacek@gcc.gnu.org", "date": "2013-12-04T22:47:11Z"}, "committer": {"name": "Marek Polacek", "email": "mpolacek@gcc.gnu.org", "date": "2013-12-04T22:47:11Z"}, "message": "Implement -fsanitize=signed-integer-overflow.\n\nFrom-SVN: r205684", "tree": {"sha": "20fca81276f1e6d6224300c11a4e10fa89519d41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/20fca81276f1e6d6224300c11a4e10fa89519d41"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31e071aeb827f49ce2e891620852198e99d44a0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31e071aeb827f49ce2e891620852198e99d44a0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31e071aeb827f49ce2e891620852198e99d44a0c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31e071aeb827f49ce2e891620852198e99d44a0c/comments", "author": null, "committer": null, "parents": [{"sha": "59b6687cceaf95d8c49afee88248cf4fb0a33105", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59b6687cceaf95d8c49afee88248cf4fb0a33105", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59b6687cceaf95d8c49afee88248cf4fb0a33105"}], "stats": {"total": 1091, "additions": 1063, "deletions": 28}, "files": [{"sha": "6c5d257ec82550e00ca76db8704892abdb7321fe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=31e071aeb827f49ce2e891620852198e99d44a0c", "patch": "@@ -1,3 +1,50 @@\n+2013-12-04  Jakub Jelinek  <jakub@redhat.com>  \n+\t    Marek Polacek  <polacek@redhat.com>\n+\n+\t* opts.c (common_handle_option): Handle\n+\t-fsanitize=signed-integer-overflow.\n+\t* config/i386/i386.md (addv<mode>4, subv<mode>4, mulv<mode>4,\n+\tnegv<mode>3, negv<mode>3_1): Define expands.\n+\t(*addv<mode>4, *subv<mode>4, *mulv<mode>4, *negv<mode>3): Define\n+\tinsns.\n+\t* sanitizer.def (BUILT_IN_UBSAN_HANDLE_ADD_OVERFLOW,\n+\tBUILT_IN_UBSAN_HANDLE_SUB_OVERFLOW,\n+\tBUILT_IN_UBSAN_HANDLE_MUL_OVERFLOW,\n+\tBUILT_IN_UBSAN_HANDLE_NEGATE_OVERFLOW): Define.\n+\t* ubsan.h (PROB_VERY_UNLIKELY, PROB_EVEN, PROB_VERY_LIKELY,\n+\tPROB_ALWAYS): Define.\n+\t(ubsan_build_overflow_builtin): Declare.\n+\t* gimple-fold.c (gimple_fold_stmt_to_constant_1): Add folding of\n+\tinternal functions.\n+\t* ubsan.c (PROB_VERY_UNLIKELY): Don't define here.\n+\t(ubsan_build_overflow_builtin): New function.\n+\t(instrument_si_overflow): Likewise.\n+\t(ubsan_pass): Add signed integer overflow checking.\n+\t(gate_ubsan): Enable the pass also when SANITIZE_SI_OVERFLOW.\n+\t* flag-types.h (enum sanitize_code): Add SANITIZE_SI_OVERFLOW.\n+\t* internal-fn.c: Include ubsan.h and target.h.\n+\t(ubsan_expand_si_overflow_addsub_check): New function.\n+\t(ubsan_expand_si_overflow_neg_check): Likewise.\n+\t(ubsan_expand_si_overflow_mul_check): Likewise.\n+\t(expand_UBSAN_CHECK_ADD): Likewise.\n+\t(expand_UBSAN_CHECK_SUB): Likewise.\n+\t(expand_UBSAN_CHECK_MUL): Likewise.\n+\t* fold-const.c (fold_binary_loc): Don't fold A + (-B) -> A - B and\n+\t(-A) + B -> B - A when doing the signed integer overflow checking.\n+\t* internal-fn.def (UBSAN_CHECK_ADD, UBSAN_CHECK_SUB, UBSAN_CHECK_MUL):\n+\tDefine.\n+\t* tree-vrp.c (extract_range_basic): Handle internal calls.\n+\t* optabs.def (addv4_optab, subv4_optab, mulv4_optab, negv4_optab): New\n+\toptabs.\n+\t* asan.c: Include predict.h.\n+\t(PROB_VERY_UNLIKELY, PROB_ALWAYS): Don't define here.\n+\t* predict.c: Move the PROB_* macros...\n+\t* predict.h (enum br_predictor): ...here.\n+\t(PROB_LIKELY, PROB_UNLIKELY): Define.\n+\t* trans-mem.c: Include predict.h.\n+\t(PROB_VERY_UNLIKELY, PROB_ALWAYS, PROB_VERY_LIKELY,\n+\tPROB_LIKELY, PROB_UNLIKELY): Don't define here.\n+\n 2013-12-04  Jeff Law  <law@redhat.com>\n \n \t* expr.c (expand_assignment): Update comments."}, {"sha": "74140d65289e608f563521b2a9704f5c61733026", "filename": "gcc/asan.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=31e071aeb827f49ce2e891620852198e99d44a0c", "patch": "@@ -52,6 +52,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgloop.h\"\n #include \"gimple-builder.h\"\n #include \"ubsan.h\"\n+#include \"predict.h\"\n \n /* AddressSanitizer finds out-of-bounds and use-after-free bugs\n    with <2x slowdown on average.\n@@ -1311,9 +1312,6 @@ report_error_func (bool is_store, int size_in_bytes)\n   return builtin_decl_implicit (report[is_store][exact_log2 (size_in_bytes)]);\n }\n \n-#define PROB_VERY_UNLIKELY\t(REG_BR_PROB_BASE / 2000 - 1)\n-#define PROB_ALWAYS\t\t(REG_BR_PROB_BASE)\n-\n /* Split the current basic block and create a condition statement\n    insertion point right before or after the statement pointed to by\n    ITER.  Return an iterator to the point at which the caller might"}, {"sha": "35c00035e02783aeca40cccac1dbb62be87b17af", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=31e071aeb827f49ce2e891620852198e99d44a0c", "patch": "@@ -1,3 +1,9 @@\n+2013-12-04  Jakub Jelinek  <jakub@redhat.com>  \n+\t    Marek Polacek  <polacek@redhat.com>\n+\n+\t* c-gimplify.c (c_gimplify_expr): If doing the integer-overflow\n+\tsanitization, call unsigned_type_for only when !TYPE_OVERFLOW_WRAPS.\n+\n 2013-11-29   H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR c/59309"}, {"sha": "9f79ccb630d2eb1f92c2d834785e30bc6d257830", "filename": "gcc/c-family/c-gimplify.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Fc-family%2Fc-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Fc-family%2Fc-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-gimplify.c?ref=31e071aeb827f49ce2e891620852198e99d44a0c", "patch": "@@ -199,7 +199,9 @@ c_gimplify_expr (tree *expr_p, gimple_seq *pre_p ATTRIBUTE_UNUSED,\n \ttree type = TREE_TYPE (TREE_OPERAND (*expr_p, 0));\n \tif (INTEGRAL_TYPE_P (type) && c_promoting_integer_type_p (type))\n \t  {\n-\t    if (TYPE_OVERFLOW_UNDEFINED (type))\n+\t    if (TYPE_OVERFLOW_UNDEFINED (type)\n+\t\t|| ((flag_sanitize & SANITIZE_SI_OVERFLOW)\n+\t\t    && !TYPE_OVERFLOW_WRAPS (type)))\n \t      type = unsigned_type_for (type);\n \t    return gimplify_self_mod_expr (expr_p, pre_p, post_p, 1, type);\n \t  }"}, {"sha": "5ff66ccf1e59e25a7765558cdc217ec5c9f5065c", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 154, "deletions": 2, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=31e071aeb827f49ce2e891620852198e99d44a0c", "patch": "@@ -905,8 +905,8 @@\n \t\t\t   (TI \"TARGET_64BIT\")])\n \n ;; Double word integer modes as mode attribute.\n-(define_mode_attr DWI [(SI \"DI\") (DI \"TI\")])\n-(define_mode_attr dwi [(SI \"di\") (DI \"ti\")])\n+(define_mode_attr DWI [(QI \"HI\") (HI \"SI\") (SI \"DI\") (DI \"TI\")])\n+(define_mode_attr dwi [(QI \"hi\") (HI \"si\") (SI \"di\") (DI \"ti\")])\n \n ;; Half mode for double word integer modes.\n (define_mode_iterator DWIH [(SI \"!TARGET_64BIT\")\n@@ -6160,6 +6160,41 @@\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"QI\")])\n \n+;; Add with jump on overflow.\n+(define_expand \"addv<mode>4\"\n+  [(parallel [(set (reg:CCO FLAGS_REG)\n+\t\t   (eq:CCO (plus:<DWI>\n+\t\t\t      (sign_extend:<DWI>\n+\t\t\t\t (match_operand:SWI 1 \"nonimmediate_operand\"))\n+\t\t\t      (sign_extend:<DWI>\n+\t\t\t\t (match_operand:SWI 2 \"<general_operand>\")))\n+\t\t\t   (sign_extend:<DWI>\n+\t\t\t      (plus:SWI (match_dup 1) (match_dup 2)))))\n+\t      (set (match_operand:SWI 0 \"register_operand\")\n+\t\t   (plus:SWI (match_dup 1) (match_dup 2)))])\n+   (set (pc) (if_then_else\n+\t       (eq (reg:CCO FLAGS_REG) (const_int 0))\n+\t       (label_ref (match_operand 3))\n+\t       (pc)))]\n+  \"\"\n+  \"ix86_fixup_binary_operands_no_copy (PLUS, <MODE>mode, operands);\")\n+\n+(define_insn \"*addv<mode>4\"\n+  [(set (reg:CCO FLAGS_REG)\n+\t(eq:CCO (plus:<DWI>\n+\t\t   (sign_extend:<DWI>\n+\t\t      (match_operand:SWI 1 \"nonimmediate_operand\" \"%0,0\"))\n+\t\t   (sign_extend:<DWI>\n+\t\t      (match_operand:SWI 2 \"<general_operand>\" \"<g>,<r><i>\")))\n+\t\t(sign_extend:<DWI>\n+\t\t   (plus:SWI (match_dup 1) (match_dup 2)))))\n+   (set (match_operand:SWI 0 \"nonimmediate_operand\" \"=<r>,<r>m\")\n+\t(plus:SWI (match_dup 1) (match_dup 2)))]\n+  \"ix86_binary_operator_ok (PLUS, <MODE>mode, operands)\"\n+  \"add{<imodesuffix>}\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n ;; The lea patterns for modes less than 32 bits need to be matched by\n ;; several insns converted to real lea by splitters.\n \n@@ -6397,6 +6432,41 @@\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"SI\")])\n \n+;; Subtract with jump on overflow.\n+(define_expand \"subv<mode>4\"\n+  [(parallel [(set (reg:CCO FLAGS_REG)\n+\t\t   (eq:CCO (minus:<DWI>\n+\t\t\t      (sign_extend:<DWI>\n+\t\t\t\t (match_operand:SWI 1 \"nonimmediate_operand\"))\n+\t\t\t      (sign_extend:<DWI>\n+\t\t\t\t (match_operand:SWI 2 \"<general_operand>\")))\n+\t\t\t   (sign_extend:<DWI>\n+\t\t\t      (minus:SWI (match_dup 1) (match_dup 2)))))\n+\t      (set (match_operand:SWI 0 \"register_operand\")\n+\t\t   (minus:SWI (match_dup 1) (match_dup 2)))])\n+   (set (pc) (if_then_else\n+\t       (eq (reg:CCO FLAGS_REG) (const_int 0))\n+\t       (label_ref (match_operand 3))\n+\t       (pc)))]\n+  \"\"\n+  \"ix86_fixup_binary_operands_no_copy (MINUS, <MODE>mode, operands);\")\n+\n+(define_insn \"*subv<mode>4\"\n+  [(set (reg:CCO FLAGS_REG)\n+\t(eq:CCO (minus:<DWI>\n+\t\t   (sign_extend:<DWI>\n+\t\t      (match_operand:SWI 1 \"nonimmediate_operand\" \"0,0\"))\n+\t\t   (sign_extend:<DWI>\n+\t\t      (match_operand:SWI 2 \"<general_operand>\" \"<r><i>,<r>m\")))\n+\t\t(sign_extend:<DWI>\n+\t\t   (minus:SWI (match_dup 1) (match_dup 2)))))\n+   (set (match_operand:SWI 0 \"nonimmediate_operand\" \"=<r>m,<r>\")\n+\t(minus:SWI (match_dup 1) (match_dup 2)))]\n+  \"ix86_binary_operator_ok (MINUS, <MODE>mode, operands)\"\n+  \"sub{<imodesuffix>}\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n (define_insn \"*sub<mode>_3\"\n   [(set (reg FLAGS_REG)\n \t(compare (match_operand:SWI 1 \"nonimmediate_operand\" \"0,0\")\n@@ -6711,6 +6781,58 @@\n    (set_attr \"bdver1_decode\" \"direct\")\n    (set_attr \"mode\" \"QI\")])\n \n+;; Multiply with jump on overflow.\n+(define_expand \"mulv<mode>4\"\n+  [(parallel [(set (reg:CCO FLAGS_REG)\n+\t\t   (eq:CCO (mult:<DWI>\n+\t\t\t      (sign_extend:<DWI>\n+\t\t\t\t (match_operand:SWI48 1 \"register_operand\"))\n+\t\t\t      (sign_extend:<DWI>\n+\t\t\t\t (match_operand:SWI48 2 \"<general_operand>\")))\n+\t\t\t   (sign_extend:<DWI>\n+\t\t\t      (mult:SWI48 (match_dup 1) (match_dup 2)))))\n+\t      (set (match_operand:SWI48 0 \"register_operand\")\n+\t\t   (mult:SWI48 (match_dup 1) (match_dup 2)))])\n+   (set (pc) (if_then_else\n+\t       (eq (reg:CCO FLAGS_REG) (const_int 0))\n+\t       (label_ref (match_operand 3))\n+\t       (pc)))])\n+\n+(define_insn \"*mulv<mode>4\"\n+  [(set (reg:CCO FLAGS_REG)\n+\t(eq:CCO (mult:<DWI>\n+\t\t   (sign_extend:<DWI>\n+\t\t      (match_operand:SWI 1 \"nonimmediate_operand\" \"%rm,rm,0\"))\n+\t\t   (sign_extend:<DWI>\n+\t\t      (match_operand:SWI 2 \"<general_operand>\" \"K,<i>,mr\")))\n+\t\t(sign_extend:<DWI>\n+\t\t   (mult:SWI (match_dup 1) (match_dup 2)))))\n+   (set (match_operand:SWI 0 \"register_operand\" \"=r,r,r\")\n+\t(mult:SWI (match_dup 1) (match_dup 2)))]\n+  \"!(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n+  \"@\n+   imul{<imodesuffix>}\\t{%2, %1, %0|%0, %1, %2}\n+   imul{<imodesuffix>}\\t{%2, %1, %0|%0, %1, %2}\n+   imul{<imodesuffix>}\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"imul\")\n+   (set_attr \"prefix_0f\" \"0,0,1\")\n+   (set (attr \"athlon_decode\")\n+\t(cond [(eq_attr \"cpu\" \"athlon\")\n+\t\t  (const_string \"vector\")\n+\t       (eq_attr \"alternative\" \"1\")\n+\t\t  (const_string \"vector\")\n+\t       (and (eq_attr \"alternative\" \"2\")\n+\t\t    (match_operand 1 \"memory_operand\"))\n+\t\t  (const_string \"vector\")]\n+\t      (const_string \"direct\")))\n+   (set (attr \"amdfam10_decode\")\n+\t(cond [(and (eq_attr \"alternative\" \"0,1\")\n+\t\t    (match_operand 1 \"memory_operand\"))\n+\t\t  (const_string \"vector\")]\n+\t      (const_string \"direct\")))\n+   (set_attr \"bdver1_decode\" \"direct\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n (define_expand \"<u>mul<mode><dwi>3\"\n   [(parallel [(set (match_operand:<DWI> 0 \"register_operand\")\n \t\t   (mult:<DWI>\n@@ -8624,6 +8746,36 @@\n   [(set_attr \"type\" \"negnot\")\n    (set_attr \"mode\" \"SI\")])\n \n+;; Negate with jump on overflow.\n+(define_expand \"negv<mode>3\"\n+  [(parallel [(set (reg:CCO FLAGS_REG)\n+\t\t   (ne:CCO (match_operand:SWI 1 \"register_operand\")\n+\t\t\t   (match_dup 3)))\n+\t      (set (match_operand:SWI 0 \"register_operand\")\n+\t\t   (neg:SWI (match_dup 1)))])\n+   (set (pc) (if_then_else\n+\t       (eq (reg:CCO FLAGS_REG) (const_int 0))\n+\t       (label_ref (match_operand 2))\n+\t       (pc)))]\n+  \"\"\n+{\n+  operands[3]\n+    = gen_int_mode (HOST_WIDE_INT_1U << (GET_MODE_BITSIZE (<MODE>mode) - 1),\n+\t\t    <MODE>mode);\n+})\n+\n+(define_insn \"*negv<mode>3\"\n+  [(set (reg:CCO FLAGS_REG)\n+\t(ne:CCO (match_operand:SWI 1 \"nonimmediate_operand\" \"0\")\n+\t\t(match_operand:SWI 2 \"const_int_operand\")))\n+   (set (match_operand:SWI 0 \"nonimmediate_operand\" \"=<r>m\")\n+\t(neg:SWI (match_dup 1)))]\n+  \"ix86_unary_operator_ok (NEG, <MODE>mode, operands)\n+   && mode_signbit_p (<MODE>mode, operands[2])\"\n+  \"neg{<imodesuffix>}\\t%0\"\n+  [(set_attr \"type\" \"negnot\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n ;; Changing of sign for FP values is doable using integer unit too.\n \n (define_expand \"<code><mode>2\""}, {"sha": "bea268f9aba729650c36b2d5d77e6221b5d4c266", "filename": "gcc/flag-types.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Fflag-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Fflag-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflag-types.h?ref=31e071aeb827f49ce2e891620852198e99d44a0c", "patch": "@@ -215,8 +215,10 @@ enum sanitize_code {\n   SANITIZE_VLA = 1 << 6,\n   SANITIZE_NULL = 1 << 7,\n   SANITIZE_RETURN = 1 << 8,\n+  SANITIZE_SI_OVERFLOW = 1 << 9,\n   SANITIZE_UNDEFINED = SANITIZE_SHIFT | SANITIZE_DIVIDE | SANITIZE_UNREACHABLE\n \t\t       | SANITIZE_VLA | SANITIZE_NULL | SANITIZE_RETURN\n+\t\t       | SANITIZE_SI_OVERFLOW\n };\n \n /* flag_vtable_verify initialization levels. */"}, {"sha": "0781bdb52c8e1e9bdd4776e923c6c21da2b9af85", "filename": "gcc/fold-const.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=31e071aeb827f49ce2e891620852198e99d44a0c", "patch": "@@ -10350,14 +10350,16 @@ fold_binary_loc (location_t loc,\n \n     case PLUS_EXPR:\n       /* A + (-B) -> A - B */\n-      if (TREE_CODE (arg1) == NEGATE_EXPR)\n+      if (TREE_CODE (arg1) == NEGATE_EXPR\n+\t  && (flag_sanitize & SANITIZE_SI_OVERFLOW) == 0)\n \treturn fold_build2_loc (loc, MINUS_EXPR, type,\n \t\t\t    fold_convert_loc (loc, type, arg0),\n \t\t\t    fold_convert_loc (loc, type,\n \t\t\t\t\t      TREE_OPERAND (arg1, 0)));\n       /* (-A) + B -> B - A */\n       if (TREE_CODE (arg0) == NEGATE_EXPR\n-\t  && reorder_operands_p (TREE_OPERAND (arg0, 0), arg1))\n+\t  && reorder_operands_p (TREE_OPERAND (arg0, 0), arg1)\n+\t  && (flag_sanitize & SANITIZE_SI_OVERFLOW) == 0)\n \treturn fold_build2_loc (loc, MINUS_EXPR, type,\n \t\t\t    fold_convert_loc (loc, type, arg1),\n \t\t\t    fold_convert_loc (loc, type,"}, {"sha": "72893cd4aecdbc8b3a9799ba89adc37ddc77385a", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=31e071aeb827f49ce2e891620852198e99d44a0c", "patch": "@@ -2660,8 +2660,37 @@ gimple_fold_stmt_to_constant_1 (gimple stmt, tree (*valueize) (tree))\n \ttree fn;\n \n \tif (gimple_call_internal_p (stmt))\n-\t  /* No folding yet for these functions.  */\n-\t  return NULL_TREE;\n+\t  {\n+\t    enum tree_code subcode = ERROR_MARK;\n+\t    switch (gimple_call_internal_fn (stmt))\n+\t      {\n+\t      case IFN_UBSAN_CHECK_ADD:\n+\t\tsubcode = PLUS_EXPR;\n+\t\tbreak;\n+\t      case IFN_UBSAN_CHECK_SUB:\n+\t\tsubcode = MINUS_EXPR;\n+\t\tbreak;\n+\t      case IFN_UBSAN_CHECK_MUL:\n+\t\tsubcode = MULT_EXPR;\n+\t\tbreak;\n+\t      default:\n+\t\treturn NULL_TREE;\n+\t      }\n+\t    tree op0 = (*valueize) (gimple_call_arg (stmt, 0));\n+\t    tree op1 = (*valueize) (gimple_call_arg (stmt, 1));\n+\n+\t    if (TREE_CODE (op0) != INTEGER_CST\n+\t\t|| TREE_CODE (op1) != INTEGER_CST)\n+\t      return NULL_TREE;\n+\t    tree res = fold_binary_loc (loc, subcode,\n+\t\t\t\t\tTREE_TYPE (gimple_call_arg (stmt, 0)),\n+\t\t\t\t\top0, op1);\n+\t    if (res\n+\t\t&& TREE_CODE (res) == INTEGER_CST\n+\t\t&& !TREE_OVERFLOW (res))\n+\t      return res;\n+\t    return NULL_TREE;\n+\t  }\n \n \tfn = (*valueize) (gimple_call_fn (stmt));\n \tif (TREE_CODE (fn) == ADDR_EXPR"}, {"sha": "527b5ffaf7f8b973e7eadb44983f1ca732ff8e8f", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 302, "deletions": 0, "changes": 302, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=31e071aeb827f49ce2e891620852198e99d44a0c", "patch": "@@ -31,6 +31,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-expr.h\"\n #include \"is-a.h\"\n #include \"gimple.h\"\n+#include \"ubsan.h\"\n+#include \"target.h\"\n+#include \"predict.h\"\n \n /* The names of each internal function, indexed by function number.  */\n const char *const internal_fn_name_array[] = {\n@@ -153,6 +156,305 @@ expand_UBSAN_NULL (gimple stmt ATTRIBUTE_UNUSED)\n   gcc_unreachable ();\n }\n \n+/* Add sub/add overflow checking to the statement STMT.\n+   CODE says whether the operation is +, or -.  */\n+\n+void\n+ubsan_expand_si_overflow_addsub_check (tree_code code, gimple stmt)\n+{\n+  rtx res, op0, op1;\n+  tree lhs, fn, arg0, arg1;\n+  rtx done_label, do_error, target = NULL_RTX;\n+\n+  lhs = gimple_call_lhs (stmt);\n+  arg0 = gimple_call_arg (stmt, 0);\n+  arg1 = gimple_call_arg (stmt, 1);\n+  done_label = gen_label_rtx ();\n+  do_error = gen_label_rtx ();\n+  fn = ubsan_build_overflow_builtin (code, gimple_location (stmt),\n+\t\t\t\t     TREE_TYPE (arg0), arg0, arg1);\n+  do_pending_stack_adjust ();\n+  op0 = expand_normal (arg0);\n+  op1 = expand_normal (arg1);\n+\n+  enum machine_mode mode = TYPE_MODE (TREE_TYPE (arg0));\n+  if (lhs)\n+    target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+\n+  enum insn_code icode\n+    = optab_handler (code == PLUS_EXPR ? addv4_optab : subv4_optab, mode);\n+  if (icode != CODE_FOR_nothing)\n+    {\n+      struct expand_operand ops[4];\n+      rtx last = get_last_insn ();\n+\n+      res = gen_reg_rtx (mode);\n+      create_output_operand (&ops[0], res, mode);\n+      create_input_operand (&ops[1], op0, mode);\n+      create_input_operand (&ops[2], op1, mode);\n+      create_fixed_operand (&ops[3], do_error);\n+      if (maybe_expand_insn (icode, 4, ops))\n+\t{\n+\t  last = get_last_insn ();\n+\t  if (profile_status != PROFILE_ABSENT\n+\t      && JUMP_P (last)\n+\t      && any_condjump_p (last)\n+\t      && !find_reg_note (last, REG_BR_PROB, 0))\n+\t    add_int_reg_note (last, REG_BR_PROB, PROB_VERY_UNLIKELY);\n+\t  emit_jump (done_label);\n+        }\n+      else\n+\t{\n+\t  delete_insns_since (last);\n+\t  icode = CODE_FOR_nothing;\n+\t}\n+    }\n+\n+  if (icode == CODE_FOR_nothing)\n+    {\n+      rtx sub_check = gen_label_rtx ();\n+\n+      /* Compute the operation.  On RTL level, the addition is always\n+\t unsigned.  */\n+      res = expand_binop (mode, add_optab, op0, op1,\n+\t\t\t  NULL_RTX, false, OPTAB_LIB_WIDEN);\n+\n+      /* If the op1 is negative, we have to use a different check.  */\n+      emit_cmp_and_jump_insns (op1, const0_rtx, LT, NULL_RTX, mode,\n+\t\t\t       false, sub_check, PROB_EVEN);\n+\n+      /* Compare the result of the addition with one of the operands.  */\n+      emit_cmp_and_jump_insns (res, op0, code == PLUS_EXPR ? GE : LE,\n+\t\t\t       NULL_RTX, mode, false, done_label,\n+\t\t\t       PROB_VERY_LIKELY);\n+      /* If we get here, we have to print the error.  */\n+      emit_jump (do_error);\n+\n+      emit_label (sub_check);\n+      /* We have k = a + b for b < 0 here.  k <= a must hold.  */\n+      emit_cmp_and_jump_insns (res, op0, code == PLUS_EXPR ? LE : GE,\n+\t\t\t       NULL_RTX, mode, false, done_label,\n+\t\t\t       PROB_VERY_LIKELY);\n+    }\n+\n+   emit_label (do_error);\n+   /* Expand the ubsan builtin call.  */\n+   expand_normal (fn);\n+   do_pending_stack_adjust ();\n+\n+   /* We're done.  */\n+   emit_label (done_label);\n+\n+  if (lhs)\n+    emit_move_insn (target, res);\n+}\n+\n+/* Add negate overflow checking to the statement STMT.  */\n+\n+void\n+ubsan_expand_si_overflow_neg_check (gimple stmt)\n+{\n+  rtx res, op1;\n+  tree lhs, fn, arg1;\n+  rtx done_label, do_error, target = NULL_RTX;\n+\n+  lhs = gimple_call_lhs (stmt);\n+  arg1 = gimple_call_arg (stmt, 1);\n+  done_label = gen_label_rtx ();\n+  do_error = gen_label_rtx ();\n+  fn = ubsan_build_overflow_builtin (NEGATE_EXPR, gimple_location (stmt),\n+\t\t\t\t     TREE_TYPE (arg1), arg1, NULL_TREE);\n+\n+  do_pending_stack_adjust ();\n+  op1 = expand_normal (arg1);\n+\n+  enum machine_mode mode = TYPE_MODE (TREE_TYPE (arg1));\n+  if (lhs)\n+    target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+\n+  enum insn_code icode = optab_handler (negv3_optab, mode);\n+  if (icode != CODE_FOR_nothing)\n+    {\n+      struct expand_operand ops[3];\n+      rtx last = get_last_insn ();\n+\n+      res = gen_reg_rtx (mode);\n+      create_output_operand (&ops[0], res, mode);\n+      create_input_operand (&ops[1], op1, mode);\n+      create_fixed_operand (&ops[2], do_error);\n+      if (maybe_expand_insn (icode, 3, ops))\n+\t{\n+\t  last = get_last_insn ();\n+\t  if (profile_status != PROFILE_ABSENT\n+\t      && JUMP_P (last)\n+\t      && any_condjump_p (last)\n+\t      && !find_reg_note (last, REG_BR_PROB, 0))\n+\t    add_int_reg_note (last, REG_BR_PROB, PROB_VERY_UNLIKELY);\n+\t  emit_jump (done_label);\n+        }\n+      else\n+\t{\n+\t  delete_insns_since (last);\n+\t  icode = CODE_FOR_nothing;\n+\t}\n+    }\n+\n+  if (icode == CODE_FOR_nothing)\n+    {\n+      /* Compute the operation.  On RTL level, the addition is always\n+\t unsigned.  */\n+      res = expand_unop (mode, neg_optab, op1, NULL_RTX, false);\n+\n+      /* Compare the operand with the most negative value.  */\n+      rtx minv = expand_normal (TYPE_MIN_VALUE (TREE_TYPE (arg1)));\n+      emit_cmp_and_jump_insns (op1, minv, NE, NULL_RTX, mode, false,\n+\t\t\t       done_label, PROB_VERY_LIKELY);\n+    }\n+\n+  emit_label (do_error);\n+  /* Expand the ubsan builtin call.  */\n+  expand_normal (fn);\n+  do_pending_stack_adjust ();\n+\n+  /* We're done.  */\n+  emit_label (done_label);\n+\n+  if (lhs)\n+    emit_move_insn (target, res);\n+}\n+\n+/* Add mul overflow checking to the statement STMT.  */\n+\n+void\n+ubsan_expand_si_overflow_mul_check (gimple stmt)\n+{\n+  rtx res, op0, op1;\n+  tree lhs, fn, arg0, arg1;\n+  rtx done_label, do_error, target = NULL_RTX;\n+\n+  lhs = gimple_call_lhs (stmt);\n+  arg0 = gimple_call_arg (stmt, 0);\n+  arg1 = gimple_call_arg (stmt, 1);\n+  done_label = gen_label_rtx ();\n+  do_error = gen_label_rtx ();\n+  fn = ubsan_build_overflow_builtin (MULT_EXPR, gimple_location (stmt),\n+\t\t\t\t     TREE_TYPE (arg0), arg0, arg1);\n+\n+  do_pending_stack_adjust ();\n+  op0 = expand_normal (arg0);\n+  op1 = expand_normal (arg1);\n+\n+  enum machine_mode mode = TYPE_MODE (TREE_TYPE (arg0));\n+  if (lhs)\n+    target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+\n+  enum insn_code icode = optab_handler (mulv4_optab, mode);\n+  if (icode != CODE_FOR_nothing)\n+    {\n+      struct expand_operand ops[4];\n+      rtx last = get_last_insn ();\n+\n+      res = gen_reg_rtx (mode);\n+      create_output_operand (&ops[0], res, mode);\n+      create_input_operand (&ops[1], op0, mode);\n+      create_input_operand (&ops[2], op1, mode);\n+      create_fixed_operand (&ops[3], do_error);\n+      if (maybe_expand_insn (icode, 4, ops))\n+\t{\n+\t  last = get_last_insn ();\n+\t  if (profile_status != PROFILE_ABSENT\n+\t      && JUMP_P (last)\n+\t      && any_condjump_p (last)\n+\t      && !find_reg_note (last, REG_BR_PROB, 0))\n+\t    add_int_reg_note (last, REG_BR_PROB, PROB_VERY_UNLIKELY);\n+\t  emit_jump (done_label);\n+        }\n+      else\n+\t{\n+\t  delete_insns_since (last);\n+\t  icode = CODE_FOR_nothing;\n+\t}\n+    }\n+\n+  if (icode == CODE_FOR_nothing)\n+    {\n+      struct separate_ops ops;\n+      ops.op0 = arg0;\n+      ops.op1 = arg1;\n+      ops.op2 = NULL_TREE;\n+      ops.location = gimple_location (stmt);\n+      if (GET_MODE_2XWIDER_MODE (mode) != VOIDmode\n+\t  && targetm.scalar_mode_supported_p (GET_MODE_2XWIDER_MODE (mode)))\n+\t{\n+\t  enum machine_mode wmode = GET_MODE_2XWIDER_MODE (mode);\n+\t  ops.code = WIDEN_MULT_EXPR;\n+\t  ops.type\n+\t    = build_nonstandard_integer_type (GET_MODE_PRECISION (wmode), 0);\n+\n+\t  res = expand_expr_real_2 (&ops, NULL_RTX, wmode, EXPAND_NORMAL);\n+\t  rtx hipart = expand_shift (RSHIFT_EXPR, wmode, res,\n+\t\t\t\t     GET_MODE_PRECISION (mode), NULL_RTX, 0);\n+\t  hipart = gen_lowpart (mode, hipart);\n+\t  res = gen_lowpart (mode, res);\n+\t  rtx signbit = expand_shift (RSHIFT_EXPR, mode, res,\n+\t\t\t\t      GET_MODE_PRECISION (mode) - 1,\n+\t\t\t\t      NULL_RTX, 0);\n+\t  /* RES is low half of the double width result, HIPART\n+\t     the high half.  There was overflow if\n+\t     HIPART is different from RES < 0 ? -1 : 0.  */\n+\t  emit_cmp_and_jump_insns (signbit, hipart, EQ, NULL_RTX, mode,\n+\t\t\t\t   false, done_label, PROB_VERY_LIKELY);\n+\t}\n+      else\n+\t{\n+\t  /* For now we don't instrument this.  See __mulvDI3 in libgcc2.c\n+\t     for what could be done.  */\n+\t  ops.code = MULT_EXPR;\n+\t  ops.type = TREE_TYPE (arg0);\n+\t  res = expand_expr_real_2 (&ops, NULL_RTX, mode, EXPAND_NORMAL);\n+\t  emit_jump (done_label);\n+\t}\n+    }\n+\n+  emit_label (do_error);\n+  /* Expand the ubsan builtin call.  */\n+  expand_normal (fn);\n+  do_pending_stack_adjust ();\n+\n+  /* We're done.  */\n+  emit_label (done_label);\n+\n+  if (lhs)\n+    emit_move_insn (target, res);\n+}\n+\n+/* Expand UBSAN_CHECK_ADD call STMT.  */\n+\n+static void\n+expand_UBSAN_CHECK_ADD (gimple stmt)\n+{\n+  ubsan_expand_si_overflow_addsub_check (PLUS_EXPR, stmt);\n+}\n+\n+/* Expand UBSAN_CHECK_SUB call STMT.  */\n+\n+static void\n+expand_UBSAN_CHECK_SUB (gimple stmt)\n+{\n+  if (integer_zerop (gimple_call_arg (stmt, 0)))\n+    ubsan_expand_si_overflow_neg_check (stmt);\n+  else\n+    ubsan_expand_si_overflow_addsub_check (MINUS_EXPR, stmt);\n+}\n+\n+/* Expand UBSAN_CHECK_MUL call STMT.  */\n+\n+static void\n+expand_UBSAN_CHECK_MUL (gimple stmt)\n+{\n+  ubsan_expand_si_overflow_mul_check (stmt);\n+}\n+\n /* Routines to expand each internal function, indexed by function number.\n    Each routine has the prototype:\n "}, {"sha": "08a514eeec2135d9ed87a7b3a91a8b05288a0c33", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=31e071aeb827f49ce2e891620852198e99d44a0c", "patch": "@@ -45,3 +45,6 @@ DEF_INTERNAL_FN (GOMP_SIMD_VF, ECF_CONST | ECF_LEAF | ECF_NOTHROW)\n DEF_INTERNAL_FN (GOMP_SIMD_LAST_LANE, ECF_CONST | ECF_LEAF | ECF_NOTHROW)\n DEF_INTERNAL_FN (ANNOTATE,  ECF_CONST | ECF_LEAF | ECF_NOTHROW)\n DEF_INTERNAL_FN (UBSAN_NULL, ECF_LEAF | ECF_NOTHROW)\n+DEF_INTERNAL_FN (UBSAN_CHECK_ADD, ECF_CONST | ECF_LEAF | ECF_NOTHROW)\n+DEF_INTERNAL_FN (UBSAN_CHECK_SUB, ECF_CONST | ECF_LEAF | ECF_NOTHROW)\n+DEF_INTERNAL_FN (UBSAN_CHECK_MUL, ECF_CONST | ECF_LEAF | ECF_NOTHROW)"}, {"sha": "cad96d2aea5b3bbfdfa2b610776516050b15e7ab", "filename": "gcc/optabs.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Foptabs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Foptabs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.def?ref=31e071aeb827f49ce2e891620852198e99d44a0c", "patch": "@@ -187,6 +187,10 @@ OPTAB_D (movcc_optab, \"mov$acc\")\n OPTAB_D (cmov_optab, \"cmov$a6\")\n OPTAB_D (cstore_optab, \"cstore$a4\")\n OPTAB_D (ctrap_optab, \"ctrap$a4\")\n+OPTAB_D (addv4_optab, \"addv$I$a4\")\n+OPTAB_D (subv4_optab, \"subv$I$a4\")\n+OPTAB_D (mulv4_optab, \"mulv$I$a4\")\n+OPTAB_D (negv3_optab, \"negv$I$a3\")\n \n OPTAB_D (smul_highpart_optab, \"smul$a3_highpart\")\n OPTAB_D (umul_highpart_optab, \"umul$a3_highpart\")"}, {"sha": "7e61cbce7f86fd3556c7b4931fb71ecfb3add8c2", "filename": "gcc/opts.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=31e071aeb827f49ce2e891620852198e99d44a0c", "patch": "@@ -1460,6 +1460,8 @@ common_handle_option (struct gcc_options *opts,\n \t      { \"vla-bound\", SANITIZE_VLA, sizeof \"vla-bound\" - 1 },\n \t      { \"return\", SANITIZE_RETURN, sizeof \"return\" - 1 },\n \t      { \"null\", SANITIZE_NULL, sizeof \"null\" - 1 },\n+\t      { \"signed-integer-overflow\", SANITIZE_SI_OVERFLOW,\n+\t\tsizeof \"signed-integer-overflow\" -1 },\n \t      { NULL, 0, 0 }\n \t    };\n \t    const char *comma;"}, {"sha": "1cd3fa621ea5103f3d16761b23b8a9cd81a96b6c", "filename": "gcc/predict.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=31e071aeb827f49ce2e891620852198e99d44a0c", "patch": "@@ -74,14 +74,6 @@ along with GCC; see the file COPYING3.  If not see\n static sreal real_zero, real_one, real_almost_one, real_br_prob_base,\n \t     real_inv_br_prob_base, real_one_half, real_bb_freq_max;\n \n-/* Random guesstimation given names.\n-   PROV_VERY_UNLIKELY should be small enough so basic block predicted\n-   by it gets below HOT_BB_FREQUENCY_FRACTION.  */\n-#define PROB_VERY_UNLIKELY\t(REG_BR_PROB_BASE / 2000 - 1)\n-#define PROB_EVEN\t\t(REG_BR_PROB_BASE / 2)\n-#define PROB_VERY_LIKELY\t(REG_BR_PROB_BASE - PROB_VERY_UNLIKELY)\n-#define PROB_ALWAYS\t\t(REG_BR_PROB_BASE)\n-\n static void combine_predictions_for_insn (rtx, basic_block);\n static void dump_prediction (FILE *, enum br_predictor, int, basic_block, int);\n static void predict_paths_leading_to (basic_block, enum br_predictor, enum prediction);"}, {"sha": "23435dc2c99d0ebf068a47e870cbb13a2306a2f6", "filename": "gcc/predict.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Fpredict.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Fpredict.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.h?ref=31e071aeb827f49ce2e891620852198e99d44a0c", "patch": "@@ -20,6 +20,16 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_PREDICT_H\n #define GCC_PREDICT_H\n \n+/* Random guesstimation given names.\n+   PROB_VERY_UNLIKELY should be small enough so basic block predicted\n+   by it gets below HOT_BB_FREQUENCY_FRACTION.  */\n+#define PROB_VERY_UNLIKELY\t(REG_BR_PROB_BASE / 2000 - 1)\n+#define PROB_EVEN\t\t(REG_BR_PROB_BASE / 2)\n+#define PROB_VERY_LIKELY\t(REG_BR_PROB_BASE - PROB_VERY_UNLIKELY)\n+#define PROB_ALWAYS\t\t(REG_BR_PROB_BASE)\n+#define PROB_UNLIKELY           (REG_BR_PROB_BASE / 5 - 1)\n+#define PROB_LIKELY             (PROB_ALWAYS - PROB_VERY_LIKELY)\n+\n #define DEF_PREDICTOR(ENUM, NAME, HITRATE, FLAGS) ENUM,\n enum br_predictor\n {"}, {"sha": "9c94650321ee6df77f6ad46dbfff74a43d72639e", "filename": "gcc/sanitizer.def", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Fsanitizer.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Fsanitizer.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsanitizer.def?ref=31e071aeb827f49ce2e891620852198e99d44a0c", "patch": "@@ -315,3 +315,19 @@ DEF_SANITIZER_BUILTIN(BUILT_IN_UBSAN_HANDLE_TYPE_MISMATCH,\n \t\t      \"__ubsan_handle_type_mismatch\",\n \t\t      BT_FN_VOID_PTR_PTR,\n \t\t      ATTR_COLD_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_UBSAN_HANDLE_ADD_OVERFLOW,\n+\t\t      \"__ubsan_handle_add_overflow\",\n+\t\t      BT_FN_VOID_PTR_PTR_PTR,\n+\t\t      ATTR_COLD_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_UBSAN_HANDLE_SUB_OVERFLOW,\n+\t\t      \"__ubsan_handle_sub_overflow\",\n+\t\t      BT_FN_VOID_PTR_PTR_PTR,\n+\t\t      ATTR_COLD_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_UBSAN_HANDLE_MUL_OVERFLOW,\n+\t\t      \"__ubsan_handle_mul_overflow\",\n+\t\t      BT_FN_VOID_PTR_PTR_PTR,\n+\t\t      ATTR_COLD_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_UBSAN_HANDLE_NEGATE_OVERFLOW,\n+\t\t      \"__ubsan_handle_negate_overflow\",\n+\t\t      BT_FN_VOID_PTR_PTR,\n+\t\t      ATTR_COLD_NOTHROW_LEAF_LIST)"}, {"sha": "6703e6a87ddfd216cf3c20b7135816466263f80b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=31e071aeb827f49ce2e891620852198e99d44a0c", "patch": "@@ -1,3 +1,13 @@\n+2013-12-04  Marek Polacek  <polacek@redhat.com>\n+\n+\t* c-c++-common/ubsan/overflow-mul-2.c: New test.\n+\t* c-c++-common/ubsan/overflow-add-1.c: New test.\n+\t* c-c++-common/ubsan/overflow-add-2.c: New test.\n+\t* c-c++-common/ubsan/overflow-mul-1.c: New test.\n+\t* c-c++-common/ubsan/overflow-sub-1.c: New test.\n+\t* c-c++-common/ubsan/overflow-sub-2.c: New test.\n+\t* c-c++-common/ubsan/overflow-negate-1.c: New test.\n+\n 2013-12-04  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/54113"}, {"sha": "436082d21d95b7799fbeac5194d8c6f2d0160671", "filename": "gcc/testsuite/c-c++-common/ubsan/overflow-add-1.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Foverflow-add-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Foverflow-add-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Foverflow-add-1.c?ref=31e071aeb827f49ce2e891620852198e99d44a0c", "patch": "@@ -0,0 +1,61 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fsanitize=signed-integer-overflow -Wno-unused-variable\" } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-flto\" } { \"\" } } */\n+\n+#define SCHAR_MAX __SCHAR_MAX__\n+#define SHRT_MAX __SHRT_MAX__\n+#define INT_MAX __INT_MAX__\n+#define INT_MIN (-__INT_MAX__ - 1)\n+\n+void __attribute__((noinline,noclone))\n+check (int i, int j)\n+{\n+  if (i != j)\n+    __builtin_abort ();\n+}\n+\n+int\n+main (void)\n+{\n+#if __INT_MAX__ == 2147483647\n+  /* Here, nothing should fail.  */\n+  volatile int j = INT_MAX;\n+  volatile int i = -1;\n+  volatile int k = j + i;\n+  check (k, 2147483646);\n+  k = i + j;\n+  check (k, 2147483646);\n+  j--;\n+  check (j, 2147483646);\n+\n+  i = 1;\n+  j = INT_MIN;\n+  k = i + j;\n+  check (k, -2147483647);\n+  k = j + i;\n+  check (k, -2147483647);\n+  j++;\n+  check (j, -2147483647);\n+#endif\n+\n+  /* Test integer promotion.  */\n+#if __SCHAR_MAX__ == 127\n+  volatile signed char a = SCHAR_MAX;\n+  volatile signed char b = 1;\n+  volatile signed char c = a + b;\n+  check (c, -128);\n+  a++;\n+  check (a, -128);\n+#endif\n+\n+#if __SHRT_MAX__ == 32767\n+  volatile short d = SHRT_MAX;\n+  volatile short e = 1;\n+  volatile short f = d + e;\n+  check (f, -32768);\n+  d++;\n+  check (d, -32768);\n+#endif\n+\n+  return 0;\n+}"}, {"sha": "de2cd2d0f88f634a55a12df9ad085ccb3b2fbf1f", "filename": "gcc/testsuite/c-c++-common/ubsan/overflow-add-2.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Foverflow-add-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Foverflow-add-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Foverflow-add-2.c?ref=31e071aeb827f49ce2e891620852198e99d44a0c", "patch": "@@ -0,0 +1,61 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fsanitize=signed-integer-overflow -Wno-unused-variable\" } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-flto\" } { \"\" } } */\n+\n+#define INT_MAX __INT_MAX__\n+#define INT_MIN (-__INT_MAX__ - 1)\n+#define LONG_MAX __LONG_MAX__\n+#define LONG_MIN (-__LONG_MAX__ - 1L)\n+#define LLONG_MAX __LONG_LONG_MAX__\n+#define LLONG_MIN (-__LONG_LONG_MAX__ - 1L)\n+\n+int\n+main (void)\n+{\n+  volatile int j = INT_MAX;\n+  volatile int i = 1;\n+  volatile int k = j + i;\n+  k = i + j;\n+  j++;\n+  j = INT_MAX - 100;\n+  j += (1 << 10);\n+\n+  j = INT_MIN;\n+  i = -1;\n+  k = i + j;\n+  k = j + i;\n+  j = INT_MIN + 100;\n+  j += -(1 << 10);\n+\n+  volatile long int m = LONG_MAX;\n+  volatile long int n = 1;\n+  volatile long int o = m + n;\n+  o = n + m;\n+  m++;\n+  m = LONG_MAX - 100;\n+  m += (1 << 10);\n+\n+  m = LONG_MIN;\n+  n = -1;\n+  o = m + n;\n+  o = n + m;\n+  m = LONG_MIN + 100;\n+  m += -(1 << 10);\n+\n+  return 0;\n+}\n+\n+/* { dg-output \"signed integer overflow: 2147483647 \\\\+ 1 cannot be represented in type 'int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*signed integer overflow: 1 \\\\+ 2147483647 cannot be represented in type 'int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*signed integer overflow: 2147483647 \\\\+ 1 cannot be represented in type 'int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*signed integer overflow: 2147483547 \\\\+ 1024 cannot be represented in type 'int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*signed integer overflow: -1 \\\\+ -2147483648 cannot be represented in type 'int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*signed integer overflow: -2147483648 \\\\+ -1 cannot be represented in type 'int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*signed integer overflow: -2147483548 \\\\+ -1024 cannot be represented in type 'int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*signed integer overflow: \\[^\\n\\r]* \\\\+ 1 cannot be represented in type 'long int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*signed integer overflow: 1 \\\\+ \\[^\\n\\r]* cannot be represented in type 'long int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*signed integer overflow: \\[^\\n\\r]* \\\\+ 1 cannot be represented in type 'long int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*signed integer overflow: \\[^\\n\\r]* \\\\+ 1024 cannot be represented in type 'long int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*signed integer overflow: -\\[^\\n\\r]* \\\\+ -1 cannot be represented in type 'long int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*signed integer overflow: -1 \\\\+ -\\[^\\n\\r]* cannot be represented in type 'long int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*signed integer overflow: -\\[^\\n\\r]* \\\\+ -1024 cannot be represented in type 'long int'(\\n|\\r\\n|\\r)\" } */"}, {"sha": "0f2ea59df491ac4692dbe7c5c4d9c41135d50922", "filename": "gcc/testsuite/c-c++-common/ubsan/overflow-mul-1.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Foverflow-mul-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Foverflow-mul-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Foverflow-mul-1.c?ref=31e071aeb827f49ce2e891620852198e99d44a0c", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fsanitize=signed-integer-overflow -Wno-unused-variable\" } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-flto\" } { \"\" } } */\n+\n+#define SCHAR_MAX __SCHAR_MAX__\n+#define SHRT_MAX __SHRT_MAX__\n+#define INT_MAX __INT_MAX__\n+#define INT_MIN (-__INT_MAX__ - 1)\n+\n+void __attribute__((noinline,noclone))\n+check (int i, int j)\n+{\n+  if (i != j)\n+    __builtin_abort ();\n+}\n+\n+int\n+main (void)\n+{\n+  /* Test integer promotion.  */\n+#if __SCHAR_MAX__ == 127\n+  volatile signed char a = -2;\n+  volatile signed char b = SCHAR_MAX;\n+  volatile signed char c = a * b;\n+  check (c, 2);\n+#endif\n+\n+#if __SHRT_MAX__ == 32767\n+  volatile short d = SHRT_MAX;\n+  volatile short e = 2;\n+  volatile short f = d * e;\n+  check (f, -2);\n+#endif\n+\n+#if __INT_MAX__ == 2147483647\n+  volatile int m = INT_MAX;\n+  volatile int n = 1;\n+  volatile int o = m * n;\n+  check (o, INT_MAX);\n+\n+  m = INT_MIN;\n+  o = m * n;\n+  check (o, INT_MIN);\n+#endif\n+\n+  return 0;\n+}"}, {"sha": "adcbfe1a76196e40ee7975c9adef0f9f8e969b04", "filename": "gcc/testsuite/c-c++-common/ubsan/overflow-mul-2.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Foverflow-mul-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Foverflow-mul-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Foverflow-mul-2.c?ref=31e071aeb827f49ce2e891620852198e99d44a0c", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fsanitize=signed-integer-overflow -Wno-unused-variable\" } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-flto\" } { \"\" } } */\n+\n+#define INT_MAX __INT_MAX__\n+#define LONG_MAX __LONG_MAX__\n+\n+int\n+main (void)\n+{\n+  volatile int j = INT_MAX;\n+  volatile int i = 2;\n+  volatile int k = j * i;\n+  k = i * j;\n+\n+  volatile long int m = LONG_MAX;\n+  volatile long int n = 2;\n+  volatile long int o = m * n;\n+  o = n * m;\n+\n+  return 0;\n+}\n+\n+/* { dg-output \"signed integer overflow: 2147483647 \\\\* 2 cannot be represented in type 'int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*signed integer overflow: 2 \\\\* 2147483647 cannot be represented in type 'int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*signed integer overflow: \\[^\\n\\r]* \\\\* 2 cannot be represented in type 'long int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*signed integer overflow: 2 \\\\* \\[^\\n\\r]* cannot be represented in type 'long int'(\\n|\\r\\n|\\r)\" } */"}, {"sha": "9baada41007deded1ebe9e3848ffc3e4a2844552", "filename": "gcc/testsuite/c-c++-common/ubsan/overflow-negate-1.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Foverflow-negate-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Foverflow-negate-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Foverflow-negate-1.c?ref=31e071aeb827f49ce2e891620852198e99d44a0c", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do run { target int128 } } */\n+/* { dg-options \"-fsanitize=signed-integer-overflow -Wno-unused-variable\" } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-flto\" } { \"\" } } */\n+\n+#define INT_MIN (-__INT_MAX__ - 1)\n+\n+int\n+main (void)\n+{\n+  int j = INT_MIN;\n+  return -j;\n+}\n+\n+/* { dg-output \"negation of -2147483648 cannot be represented in type 'int'; cast to an unsigned type to negate this value to itself(\\n|\\r\\n|\\r)\" } */"}, {"sha": "3b955279ba79bd18ffcdbb60142eb90c5836b18b", "filename": "gcc/testsuite/c-c++-common/ubsan/overflow-sub-1.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Foverflow-sub-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Foverflow-sub-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Foverflow-sub-1.c?ref=31e071aeb827f49ce2e891620852198e99d44a0c", "patch": "@@ -0,0 +1,63 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fsanitize=signed-integer-overflow -Wno-unused-variable\" } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-flto\" } { \"\" } } */\n+\n+#define SCHAR_MAX __SCHAR_MAX__\n+#define SCHAR_MIN (-__SCHAR_MAX__ - 1)\n+#define SHRT_MAX __SHRT_MAX__\n+#define SHRT_MIN (-__SHRT_MAX__ - 1)\n+#define INT_MAX __INT_MAX__\n+#define INT_MIN (-__INT_MAX__ - 1)\n+\n+void __attribute__((noinline,noclone))\n+check (int i, int j)\n+{\n+  if (i != j)\n+    __builtin_abort ();\n+}\n+\n+int\n+main (void)\n+{\n+#if __INT_MAX__ == 2147483647\n+  /* Here, nothing should fail.  */\n+  volatile int i = -1;\n+  volatile int j = INT_MIN;\n+  volatile int k = j - i;\n+  check (k, -2147483647);\n+  k = i - j;\n+  check (k, 2147483647);\n+  j++;\n+  check (j, -2147483647);\n+\n+  i = 1;\n+  j = INT_MAX;\n+  k = i - j;\n+  check (k, -2147483646);\n+  k = j - i;\n+  check (k, 2147483646);\n+  j--;\n+  check (k, 2147483646);\n+#endif\n+\n+  /* Test integer promotion.  */\n+#if __SCHAR_MAX__ == 127\n+  volatile signed char a = SCHAR_MIN;\n+  volatile signed char b = 1;\n+  volatile signed char c = a - b;\n+  check (c, 127);\n+  a--;\n+  check (a, 127);\n+#endif\n+\n+#if __SHRT_MAX__ == 32767\n+  volatile short d = SHRT_MIN;\n+  volatile short e = 1;\n+  volatile short f = d - e;\n+  check (f, 32767);\n+  d--;\n+  check (d, 32767);\n+#endif\n+\n+  return 0;\n+}"}, {"sha": "e06e3f6e891ae3e31abf6aac01507b69fa70dd30", "filename": "gcc/testsuite/c-c++-common/ubsan/overflow-sub-2.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Foverflow-sub-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Foverflow-sub-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Foverflow-sub-2.c?ref=31e071aeb827f49ce2e891620852198e99d44a0c", "patch": "@@ -0,0 +1,55 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fsanitize=signed-integer-overflow -Wno-unused-variable\" } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-flto\" } { \"\" } } */\n+\n+#define INT_MAX __INT_MAX__\n+#define INT_MIN (-__INT_MAX__ - 1)\n+#define LONG_MAX __LONG_MAX__\n+#define LONG_MIN (-__LONG_MAX__ - 1L)\n+#define LLONG_MAX __LONG_LONG_MAX__\n+#define LLONG_MIN (-__LONG_LONG_MAX__ - 1L)\n+\n+int\n+main (void)\n+{\n+  volatile int j = INT_MIN;\n+  volatile int i = 1;\n+  volatile int k = j - i;\n+  j--;\n+  j = INT_MIN + 100;\n+  j -= (1 << 10);\n+\n+  j = INT_MIN;\n+  i = -1;\n+  k = j - -i;\n+\n+  i = INT_MIN + 1000;\n+  i -= (1 << 20);\n+\n+  volatile long int l = LONG_MIN;\n+  volatile long int m = 1;\n+  volatile long int n = l - m;\n+  l--;\n+  l = LONG_MIN + 100;\n+  l -= (1 << 10);\n+\n+  l = LONG_MIN;\n+  m = -1;\n+  n = l - -m;\n+\n+  m = LONG_MIN + 1000;\n+  m -= (1 << 20);\n+\n+  return 0;\n+}\n+\n+/* { dg-output \"signed integer overflow: -2147483648 - 1 cannot be represented in type 'int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*signed integer overflow: -2147483648 \\\\+ -1 cannot be represented in type 'int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*signed integer overflow: -2147483548 \\\\+ -1024 cannot be represented in type 'int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*signed integer overflow: -2147483648 \\\\+ -1 cannot be represented in type 'int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*signed integer overflow: -2147482648 \\\\+ -1048576 cannot be represented in type 'int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*signed integer overflow: -\\[^\\n\\r]* - 1 cannot be represented in type 'long int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*signed integer overflow: -\\[^\\n\\r]* \\\\+ -1 cannot be represented in type 'long int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*signed integer overflow: -\\[^\\n\\r]* \\\\+ -1024 cannot be represented in type 'long int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*signed integer overflow: -\\[^\\n\\r]* \\\\+ -1 cannot be represented in type 'long int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*signed integer overflow: -\\[^\\n\\r]* \\\\+ -1048576 cannot be represented in type 'long int'(\\n|\\r\\n|\\r)\" } */"}, {"sha": "b2adc3d03e9b31bba1ae25263797933d6756a17d", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=31e071aeb827f49ce2e891620852198e99d44a0c", "patch": "@@ -55,14 +55,9 @@\n #include \"gimple-pretty-print.h\"\n #include \"cfgloop.h\"\n #include \"tree-ssa-address.h\"\n+#include \"predict.h\"\n \n \n-#define PROB_VERY_UNLIKELY\t(REG_BR_PROB_BASE / 2000 - 1)\n-#define PROB_VERY_LIKELY\t(PROB_ALWAYS - PROB_VERY_UNLIKELY)\n-#define PROB_UNLIKELY\t\t(REG_BR_PROB_BASE / 5 - 1)\n-#define PROB_LIKELY\t\t(PROB_ALWAYS - PROB_VERY_LIKELY)\n-#define PROB_ALWAYS\t\t(REG_BR_PROB_BASE)\n-\n #define A_RUNINSTRUMENTEDCODE\t0x0001\n #define A_RUNUNINSTRUMENTEDCODE\t0x0002\n #define A_SAVELIVEVARIABLES\t0x0004"}, {"sha": "d98b7764b400c9c9e4e3aa0b5b7cdd8ee91d08dd", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=31e071aeb827f49ce2e891620852198e99d44a0c", "patch": "@@ -3757,6 +3757,47 @@ extract_range_basic (value_range_t *vr, gimple stmt)\n \t  break;\n \t}\n     }\n+  else if (is_gimple_call (stmt)\n+\t   && gimple_call_internal_p (stmt))\n+    {\n+      enum tree_code subcode = ERROR_MARK;\n+      switch (gimple_call_internal_fn (stmt))\n+\t{\n+\tcase IFN_UBSAN_CHECK_ADD:\n+\t  subcode = PLUS_EXPR;\n+\t  break;\n+\tcase IFN_UBSAN_CHECK_SUB:\n+\t  subcode = MINUS_EXPR;\n+\t  break;\n+\tcase IFN_UBSAN_CHECK_MUL:\n+\t  subcode = MULT_EXPR;\n+\t  break;\n+\tdefault:\n+\t  break;\n+\t}\n+      if (subcode != ERROR_MARK)\n+\t{\n+\t  bool saved_flag_wrapv = flag_wrapv;\n+\t  /* Pretend the arithmetics is wrapping.  If there is\n+\t     any overflow, we'll complain, but will actually do\n+\t     wrapping operation.  */\n+\t  flag_wrapv = 1;\n+\t  extract_range_from_binary_expr (vr, subcode, type,\n+\t\t\t\t\t  gimple_call_arg (stmt, 0),\n+\t\t\t\t\t  gimple_call_arg (stmt, 1));\n+\t  flag_wrapv = saved_flag_wrapv;\n+\n+\t  /* If for both arguments vrp_valueize returned non-NULL,\n+\t     this should have been already folded and if not, it\n+\t     wasn't folded because of overflow.  Avoid removing the\n+\t     UBSAN_CHECK_* calls in that case.  */\n+\t  if (vr->type == VR_RANGE\n+\t      && (vr->min == vr->max\n+\t\t  || operand_equal_p (vr->min, vr->max, 0)))\n+\t    set_value_range_to_varying (vr);\n+\t  return;\n+\t}\n+    }\n   if (INTEGRAL_TYPE_P (type)\n       && gimple_stmt_nonnegative_warnv_p (stmt, &sop))\n     set_value_range_to_nonnegative (vr, type,"}, {"sha": "aaf74acb546e3bb6ea9198d5bbecf6f978853353", "filename": "gcc/ubsan.c", "status": "modified", "additions": 97, "deletions": 4, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Fubsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Fubsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fubsan.c?ref=31e071aeb827f49ce2e891620852198e99d44a0c", "patch": "@@ -41,9 +41,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ubsan.h\"\n #include \"c-family/c-common.h\"\n \n-/* From trans-mem.c.  */\n-#define PROB_VERY_UNLIKELY      (REG_BR_PROB_BASE / 2000 - 1)\n-\n /* Map from a tree to a VAR_DECL tree.  */\n \n struct GTY(()) tree_type_map {\n@@ -632,6 +629,98 @@ instrument_null (gimple_stmt_iterator gsi, bool is_lhs)\n     instrument_member_call (&gsi);\n }\n \n+/* Build an ubsan builtin call for the signed-integer-overflow\n+   sanitization.  CODE says what kind of builtin are we building,\n+   LOC is a location, LHSTYPE is the type of LHS, OP0 and OP1\n+   are operands of the binary operation.  */\n+\n+tree\n+ubsan_build_overflow_builtin (tree_code code, location_t loc, tree lhstype,\n+\t\t\t      tree op0, tree op1)\n+{\n+  tree data = ubsan_create_data (\"__ubsan_overflow_data\", loc, NULL,\n+\t\t\t\t ubsan_type_descriptor (lhstype, false),\n+\t\t\t\t NULL_TREE);\n+  enum built_in_function fn_code;\n+\n+  switch (code)\n+    {\n+    case PLUS_EXPR:\n+      fn_code = BUILT_IN_UBSAN_HANDLE_ADD_OVERFLOW;\n+      break;\n+    case MINUS_EXPR:\n+      fn_code = BUILT_IN_UBSAN_HANDLE_SUB_OVERFLOW;\n+      break;\n+    case MULT_EXPR:\n+      fn_code = BUILT_IN_UBSAN_HANDLE_MUL_OVERFLOW;\n+      break;\n+    case NEGATE_EXPR:\n+      fn_code = BUILT_IN_UBSAN_HANDLE_NEGATE_OVERFLOW;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+  tree fn = builtin_decl_explicit (fn_code);\n+  return build_call_expr_loc (loc, fn, 2 + (code != NEGATE_EXPR),\n+\t\t\t      build_fold_addr_expr_loc (loc, data),\n+\t\t\t      ubsan_encode_value (op0),\n+\t\t\t      op1 ? ubsan_encode_value (op1) : NULL_TREE);\n+}\n+\n+/* Perform the signed integer instrumentation.  GSI is the iterator\n+   pointing at statement we are trying to instrument.  */\n+\n+static void\n+instrument_si_overflow (gimple_stmt_iterator gsi)\n+{\n+  gimple stmt = gsi_stmt (gsi);\n+  tree_code code = gimple_assign_rhs_code (stmt);\n+  tree lhs = gimple_assign_lhs (stmt);\n+  tree lhstype = TREE_TYPE (lhs);\n+  tree a, b;\n+  gimple g;\n+\n+  /* If this is not a signed operation, don't instrument anything here.\n+     Also punt on bit-fields.  */\n+  if (!INTEGRAL_TYPE_P (lhstype)\n+      || TYPE_OVERFLOW_WRAPS (lhstype)\n+      || GET_MODE_BITSIZE (TYPE_MODE (lhstype)) != TYPE_PRECISION (lhstype))\n+    return;\n+\n+  switch (code)\n+    {\n+    case MINUS_EXPR:\n+    case PLUS_EXPR:\n+    case MULT_EXPR:\n+      /* Transform\n+\t i = u {+,-,*} 5;\n+\t into\n+\t i = UBSAN_CHECK_{ADD,SUB,MUL} (u, 5);  */\n+      a = gimple_assign_rhs1 (stmt);\n+      b = gimple_assign_rhs2 (stmt);\n+      g = gimple_build_call_internal (code == PLUS_EXPR\n+\t\t\t\t      ? IFN_UBSAN_CHECK_ADD\n+\t\t\t\t      : code == MINUS_EXPR\n+\t\t\t\t      ? IFN_UBSAN_CHECK_SUB\n+\t\t\t\t      : IFN_UBSAN_CHECK_MUL, 2, a, b);\n+      gimple_call_set_lhs (g, lhs);\n+      gsi_replace (&gsi, g, false);\n+      break;\n+    case NEGATE_EXPR:\n+      /* Represent i = -u;\n+\t as\n+\t i = UBSAN_CHECK_SUB (0, u);  */\n+      a = build_int_cst (lhstype, 0);\n+      b = gimple_assign_rhs1 (stmt);\n+      g = gimple_build_call_internal (IFN_UBSAN_CHECK_SUB, 2, a, b);\n+      gimple_call_set_lhs (g, lhs);\n+      gsi_replace (&gsi, g, false);\n+      break;\n+    default:\n+      break;\n+    }\n+}\n+\n /* Gate and execute functions for ubsan pass.  */\n \n static unsigned int\n@@ -651,6 +740,10 @@ ubsan_pass (void)\n \t      continue;\n \t    }\n \n+\t  if ((flag_sanitize & SANITIZE_SI_OVERFLOW)\n+\t      && is_gimple_assign (stmt))\n+\t    instrument_si_overflow (gsi);\n+\n \t  if (flag_sanitize & SANITIZE_NULL)\n \t    {\n \t      if (gimple_store_p (stmt))\n@@ -668,7 +761,7 @@ ubsan_pass (void)\n static bool\n gate_ubsan (void)\n {\n-  return flag_sanitize & SANITIZE_NULL;\n+  return flag_sanitize & (SANITIZE_NULL | SANITIZE_SI_OVERFLOW);\n }\n \n namespace {"}, {"sha": "0aced4aac67e86a80329e06da433813b8440a92f", "filename": "gcc/ubsan.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Fubsan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e071aeb827f49ce2e891620852198e99d44a0c/gcc%2Fubsan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fubsan.h?ref=31e071aeb827f49ce2e891620852198e99d44a0c", "patch": "@@ -43,6 +43,7 @@ extern tree ubsan_create_data (const char *, location_t,\n extern tree ubsan_type_descriptor (tree, bool);\n extern tree ubsan_encode_value (tree);\n extern bool is_ubsan_builtin_p (tree);\n+extern tree ubsan_build_overflow_builtin (tree_code, location_t, tree, tree, tree);\n \n #endif  /* GCC_UBSAN_H  */\n "}]}