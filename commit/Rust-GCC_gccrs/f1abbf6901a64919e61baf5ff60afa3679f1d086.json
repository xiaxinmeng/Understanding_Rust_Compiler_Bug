{"sha": "f1abbf6901a64919e61baf5ff60afa3679f1d086", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjFhYmJmNjkwMWE2NDkxOWU2MWJhZjVmZjYwYWZhMzY3OWYxZDA4Ng==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2015-05-06T20:23:48Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2015-05-06T20:23:48Z"}, "message": "re PR fortran/37131 (inline matmul for small matrix sizes)\n\n2015-05-06  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/37131\n\t* gfortran.h (gfc_isym_id):  Add GFC_ISYM_FE_RUNTIME_ERROR.\n\t(gfc_intrinsic_sym):  Add vararg.\n\t* intrinsic.h (gfc_check_fe_runtime_error):  Add prototype.\n\t(gfc_resolve_re_runtime_error):  Likewise.\n\tAdd prototype for gfc_is_reallocatable_lhs.\n\t* trans-array.h (gfc_is_reallocatable_lhs):  Remove prototype.\n\t* check.c (gfc_check_fe_runtime_error):  New function.\n\t* intrinsic.c (add_sym_1p):  New function.\n\t(make_vararg):  New function.\n\t(add_subroutines):  Add fe_runtime_error.\n\t(gfc_intrinsic_sub_interface): Skip sorting for variable number\n\tof arguments.\n\t* iresolve.c (gfc_resolve_fe_runtime_error):  New function.\n\t* lang.opt (inline-matmul-limit):  New option.\n\t(gfc_post_options): If no inline matmul limit has been set and\n\tBLAS is called externally, use the BLAS limit.\n\t* frontend-passes.c:  Include intrinsic.h.\n\t(var_num):  New global counter for naming temporary variablbles.\n\t(matrix_case):  Enum for differentiating the different matmul\n\tcases.\n\t(realloc_string_callback):  Add \"trim\" to the variable name.\n\t(create_var): Add optional argument vname as part of the name.\n\tUse var_num. Set dimension of result correctly. Split off block\n\tcreation into\n\t(insert_block): New function.\n\t(cfe_expr_0): Use \"fcn\" as part of temporary variable name.\n\t(optimize_namesapce): Also set gfc_current_ns. Call\n\tinline_matmul_assign.\n\t(combine_array_constructor):  Use \"constr\" as part of\n\ttemporary name.\n\t(get_array_inq_function):  New function.\n\t(build_logical_expr):  New function.\n\t(get_operand):  new function.\n\t(inline_limit_check):  New function.\n\t(runtime_error_ne):  New function.\n\t(matmul_lhs_realloc):  New function.\n\t(is_functino_or_op):  New function.\n\t(has_function_or_op):  New function.\n\t(freeze_expr):  New function.\n\t(freeze_references):  New function.\n\t(convert_to_index_kind):  New function.\n\t(create_do_loop):  New function.\n\t(get_size_m1):  New function.\n\t(scalarized_expr):  New function.\n\t(inline_matmul_assign):  New function.\n\t* simplify.c (simplify_bound):  Simplify the case of the\n\tlower bound of an assumed-shape argument.\n\n2015-05-06  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/37131\n\t* gfortran.dg/dependency_26.f90: Add option to suppress inlining\n\tmatmul.\n\t* gfortran.dg/function_optimize_1.f90:  Likewise.\n\t* gfortran.dg/function_optimize_2.f90:  Likewise.\n\t* gfortran.dg/function_optimize_5.f90:  Likewise.\n\t* gfortran.dg/function_optimize_7.f90:  Likewise.\n\t* gfortran.dg/inline_matmul_1.f90:  New test.\n\t* gfortran.dg/inline_matmul_2.f90:  New test.\n\t* gfortran.dg/inline_matmul_3.f90:  New test.\n\t* gfortran.dg/inline_matmul_4.f90:  New test.\n\t* gfortran.dg/inline_matmul_5.f90:  New test.\n\t* gfortran.dg/inline_matmul_6.f90:  New test.\n\nFrom-SVN: r222864", "tree": {"sha": "bcbdcbcffefce1c189dafd0e4b29a080eefe1575", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bcbdcbcffefce1c189dafd0e4b29a080eefe1575"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1abbf6901a64919e61baf5ff60afa3679f1d086", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1abbf6901a64919e61baf5ff60afa3679f1d086", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1abbf6901a64919e61baf5ff60afa3679f1d086", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1abbf6901a64919e61baf5ff60afa3679f1d086/comments", "author": null, "committer": null, "parents": [{"sha": "5631585aa6c408bcf716e2762cf53c1d25cee066", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5631585aa6c408bcf716e2762cf53c1d25cee066", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5631585aa6c408bcf716e2762cf53c1d25cee066"}], "stats": {"total": 1696, "additions": 1652, "deletions": 44}, "files": [{"sha": "3e0ce5c86249862ed603e19b1c8ad213fc93ac86", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1abbf6901a64919e61baf5ff60afa3679f1d086/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1abbf6901a64919e61baf5ff60afa3679f1d086/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=f1abbf6901a64919e61baf5ff60afa3679f1d086", "patch": "@@ -5527,6 +5527,36 @@ gfc_check_random_seed (gfc_expr *size, gfc_expr *put, gfc_expr *get)\n   return true;\n }\n \n+bool\n+gfc_check_fe_runtime_error (gfc_actual_arglist *a)\n+{\n+  gfc_expr *e;\n+  int len, i;\n+  int num_percent, nargs;\n+\n+  e = a->expr;\n+  if (e->expr_type != EXPR_CONSTANT)\n+    return true;\n+\n+  len = e->value.character.length;\n+  if (e->value.character.string[len-1] != '\\0')\n+    gfc_internal_error (\"fe_runtime_error string must be null terminated\");\n+\n+  num_percent = 0;\n+  for (i=0; i<len-1; i++)\n+    if (e->value.character.string[i] == '%')\n+      num_percent ++;\n+\n+  nargs = 0;\n+  for (; a; a = a->next)\n+    nargs ++;\n+\n+  if (nargs -1 != num_percent)\n+    gfc_internal_error (\"fe_runtime_error: Wrong number of arguments (%d instead of %d)\",\n+\t\t\tnargs, num_percent++);\n+\n+  return true;\n+}\n \n bool\n gfc_check_second_sub (gfc_expr *time)"}, {"sha": "62d10634a8ef6927612198dce3013cafa37e4b3d", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 1106, "deletions": 29, "changes": 1135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1abbf6901a64919e61baf5ff60afa3679f1d086/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1abbf6901a64919e61baf5ff60afa3679f1d086/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=f1abbf6901a64919e61baf5ff60afa3679f1d086", "patch": "@@ -27,6 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dependency.h\"\n #include \"constructor.h\"\n #include \"opts.h\"\n+#include \"intrinsic.h\"\n \n /* Forward declarations.  */\n \n@@ -43,7 +44,11 @@ static void doloop_warn (gfc_namespace *);\n static void optimize_reduction (gfc_namespace *);\n static int callback_reduction (gfc_expr **, int *, void *);\n static void realloc_strings (gfc_namespace *);\n-static gfc_expr *create_var (gfc_expr *);\n+static gfc_expr *create_var (gfc_expr *, const char *vname=NULL);\n+static int inline_matmul_assign (gfc_code **, int *, void *);\n+static gfc_code * create_do_loop (gfc_expr *, gfc_expr *, gfc_expr *,\n+\t\t\t\t  locus *, gfc_namespace *, \n+\t\t\t\t  char *vname=NULL);\n \n /* How deep we are inside an argument list.  */\n \n@@ -93,6 +98,19 @@ struct my_struct *evec;\n \n static bool in_assoc_list;\n \n+/* Counter for temporary variables.  */\n+\n+static int var_num = 1;\n+\n+/* What sort of matrix we are dealing with when inlining MATMUL.  */\n+\n+enum matrix_case { none=0, A2B2, A2B1, A1B2 };\n+\n+/* Keep track of the number of expressions we have inserted so far \n+   using create_var.  */\n+\n+int n_vars;\n+\n /* Entry point - run all passes for a namespace.  */\n \n void\n@@ -157,7 +175,7 @@ realloc_string_callback (gfc_code **c, int *walk_subtrees,\n     return 0;\n   \n   current_code = c;\n-  n = create_var (expr2);\n+  n = create_var (expr2, \"trim\");\n   co->expr2 = n;\n   return 0;\n }\n@@ -524,28 +542,13 @@ constant_string_length (gfc_expr *e)\n \n }\n \n-/* Returns a new expression (a variable) to be used in place of the old one,\n-   with an assignment statement before the current statement to set\n-   the value of the variable. Creates a new BLOCK for the statement if\n-   that hasn't already been done and puts the statement, plus the\n-   newly created variables, in that block.  Special cases:  If the\n-   expression is constant or a temporary which has already\n-   been created, just copy it.  */\n+/* Insert a block at the current position unless it has already\n+   been inserted; in this case use the one already there.  */\n \n-static gfc_expr*\n-create_var (gfc_expr * e)\n+static gfc_namespace*\n+insert_block ()\n {\n-  char name[GFC_MAX_SYMBOL_LEN +1];\n-  static int num = 1;\n-  gfc_symtree *symtree;\n-  gfc_symbol *symbol;\n-  gfc_expr *result;\n-  gfc_code *n;\n   gfc_namespace *ns;\n-  int i;\n-\n-  if (e->expr_type == EXPR_CONSTANT || is_fe_temp (e))\n-    return gfc_copy_expr (e);\n \n   /* If the block hasn't already been created, do so.  */\n   if (inserted_block == NULL)\n@@ -578,7 +581,37 @@ create_var (gfc_expr * e)\n   else\n     ns = inserted_block->ext.block.ns;\n \n-  sprintf(name, \"__var_%d\",num++);\n+  return ns;\n+}\n+\n+/* Returns a new expression (a variable) to be used in place of the old one,\n+   with an optional assignment statement before the current statement to set\n+   the value of the variable. Creates a new BLOCK for the statement if that\n+   hasn't already been done and puts the statement, plus the newly created\n+   variables, in that block.  Special cases: If the expression is constant or\n+   a temporary which has already been created, just copy it.  */\n+\n+static gfc_expr*\n+create_var (gfc_expr * e, const char *vname)\n+{\n+  char name[GFC_MAX_SYMBOL_LEN +1];\n+  gfc_symtree *symtree;\n+  gfc_symbol *symbol;\n+  gfc_expr *result;\n+  gfc_code *n;\n+  gfc_namespace *ns;\n+  int i;\n+\n+  if (e->expr_type == EXPR_CONSTANT || is_fe_temp (e))\n+    return gfc_copy_expr (e);\n+\n+  ns = insert_block ();\n+\n+  if (vname)\n+    snprintf (name, GFC_MAX_SYMBOL_LEN, \"__var_%d_%s\", var_num++, vname);\n+  else\n+    snprintf (name, GFC_MAX_SYMBOL_LEN, \"__var_%d\", var_num++);\n+\n   if (gfc_get_sym_tree (name, ns, &symtree, false) != 0)\n     gcc_unreachable ();\n \n@@ -651,6 +684,7 @@ create_var (gfc_expr * e)\n       result->ref->type = REF_ARRAY;\n       result->ref->u.ar.type = AR_FULL;\n       result->ref->u.ar.where = e->where;\n+      result->ref->u.ar.dimen = e->rank;\n       result->ref->u.ar.as = symbol->ts.type == BT_CLASS\n \t\t\t     ? CLASS_DATA (symbol)->as : symbol->as;\n       if (warn_array_temporaries)\n@@ -666,6 +700,7 @@ create_var (gfc_expr * e)\n   n->expr1 = gfc_copy_expr (result);\n   n->expr2 = e;\n   *changed_statement = n;\n+  n_vars ++;\n \n   return result;\n }\n@@ -724,7 +759,7 @@ cfe_expr_0 (gfc_expr **e, int *walk_subtrees,\n \t  if (gfc_dep_compare_functions (*ei, *ej, true) == 0)\n \t    {\n \t      if (newvar == NULL)\n-\t\tnewvar = create_var (*ei);\n+\t\tnewvar = create_var (*ei, \"fcn\");\n \n \t      if (warn_function_elimination)\n \t\tdo_warn_function_elimination (*ej);\n@@ -931,13 +966,15 @@ convert_elseif (gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,\n   /*  Don't walk subtrees.  */\n   return 0;\n }\n+\n /* Optimize a namespace, including all contained namespaces.  */\n \n static void\n optimize_namespace (gfc_namespace *ns)\n {\n-\n+  gfc_namespace *saved_ns = gfc_current_ns;\n   current_ns = ns;\n+  gfc_current_ns = ns;\n   forall_level = 0;\n   iterator_level = 0;\n   in_assoc_list = false;\n@@ -947,13 +984,17 @@ optimize_namespace (gfc_namespace *ns)\n   gfc_code_walker (&ns->code, convert_elseif, dummy_expr_callback, NULL);\n   gfc_code_walker (&ns->code, cfe_code, cfe_expr_0, NULL);\n   gfc_code_walker (&ns->code, optimize_code, optimize_expr, NULL);\n+  if (flag_inline_matmul_limit != 0)\n+    gfc_code_walker (&ns->code, inline_matmul_assign, dummy_expr_callback,\n+\t\t     NULL);\n \n   /* BLOCKs are handled in the expression walker below.  */\n   for (ns = ns->contained; ns; ns = ns->sibling)\n     {\n       if (ns->code == NULL || ns->code->op != EXEC_BLOCK)\n \toptimize_namespace (ns);\n     }\n+  gfc_current_ns = saved_ns;\n }\n \n /* Handle dependencies for allocatable strings which potentially redefine\n@@ -968,10 +1009,7 @@ realloc_strings (gfc_namespace *ns)\n   for (ns = ns->contained; ns; ns = ns->sibling)\n     {\n       if (ns->code == NULL || ns->code->op != EXEC_BLOCK)\n-\t{\n-\t  // current_ns = ns;\n-\t  realloc_strings (ns);\n-\t}\n+\trealloc_strings (ns);\n     }\n \n }\n@@ -1222,7 +1260,7 @@ combine_array_constructor (gfc_expr *e)\n   if (op2->ts.type == BT_CHARACTER)\n     return false;\n \n-  scalar = create_var (gfc_copy_expr (op2));\n+  scalar = create_var (gfc_copy_expr (op2), \"constr\");\n \n   oldbase = op1->value.constructor;\n   newbase = NULL;\n@@ -1939,6 +1977,1045 @@ doloop_warn (gfc_namespace *ns)\n   gfc_code_walker (&ns->code, doloop_code, do_function, NULL);\n }\n \n+/* This selction deals with inlining calls to MATMUL.  */\n+\n+/* Auxiliary function to build and simplify an array inquiry function.\n+   dim is zero-based.  */\n+\n+static gfc_expr *\n+get_array_inq_function (gfc_isym_id id, gfc_expr *e, int dim)\n+{\n+  gfc_expr *fcn;\n+  gfc_expr *dim_arg, *kind;\n+  const char *name;\n+  gfc_expr *ec;\n+\n+  switch (id)\n+    {\n+    case GFC_ISYM_LBOUND:\n+      name = \"_gfortran_lbound\";\n+      break;\n+\n+    case GFC_ISYM_UBOUND:\n+      name = \"_gfortran_ubound\";\n+      break;\n+\n+    case GFC_ISYM_SIZE:\n+      name = \"_gfortran_size\";\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  dim_arg =  gfc_get_int_expr (gfc_default_integer_kind, &e->where, dim);\n+  kind = gfc_get_int_expr (gfc_default_integer_kind, &e->where,\n+\t\t\t   gfc_index_integer_kind);\n+\n+  ec = gfc_copy_expr (e);\n+  fcn = gfc_build_intrinsic_call (current_ns, id, name, e->where, 3,\n+\t\t\t\t  ec, dim_arg,  kind);\n+  gfc_simplify_expr (fcn, 0);\n+  return fcn;\n+}\n+\n+/* Builds a logical expression.  */\n+\n+static gfc_expr*\n+build_logical_expr (gfc_intrinsic_op op, gfc_expr *e1, gfc_expr *e2)\n+{\n+  gfc_typespec ts;\n+  gfc_expr *res;\n+\n+  ts.type = BT_LOGICAL;\n+  ts.kind = gfc_default_logical_kind;\n+  res = gfc_get_expr ();\n+  res->where = e1->where;\n+  res->expr_type = EXPR_OP;\n+  res->value.op.op = op;\n+  res->value.op.op1 = e1;\n+  res->value.op.op2 = e2;\n+  res->ts = ts;\n+\n+  return res;\n+}\n+\n+\n+/* Return an operation of one two gfc_expr (one if e2 is NULL). This assumes\n+   compatible typespecs.  */\n+\n+static gfc_expr *\n+get_operand (gfc_intrinsic_op op, gfc_expr *e1, gfc_expr *e2)\n+{\n+  gfc_expr *res;\n+\n+  res = gfc_get_expr ();\n+  res->ts = e1->ts;\n+  res->where = e1->where;\n+  res->expr_type = EXPR_OP;\n+  res->value.op.op = op;\n+  res->value.op.op1 = e1;\n+  res->value.op.op2 = e2;\n+  gfc_simplify_expr (res, 0);\n+  return res;\n+}\n+\n+/* Generate the IF statement for a runtime check if we want to do inlining or\n+   not - putting in the code for both branches and putting it into the syntax\n+   tree is the caller's responsibility.  For fixed array sizes, this should be\n+   removed by DCE. Only called for rank-two matrices A and B.  */\n+\n+static gfc_code *\n+inline_limit_check (gfc_expr *a, gfc_expr *b, enum matrix_case m_case)\n+{\n+  gfc_expr *inline_limit;\n+  gfc_code *if_1, *if_2, *else_2;\n+  gfc_expr *b2, *a2, *a1, *m1, *m2;\n+  gfc_typespec ts;\n+  gfc_expr *cond;\n+\n+  gcc_assert (m_case == A2B2);\n+\n+  /* Calculation is done in real to avoid integer overflow.  */\n+\n+  inline_limit = gfc_get_constant_expr (BT_REAL, gfc_default_real_kind,\n+\t\t\t\t\t&a->where);\n+  mpfr_set_si (inline_limit->value.real, flag_inline_matmul_limit,\n+\t       GFC_RND_MODE);\n+  mpfr_pow_ui (inline_limit->value.real, inline_limit->value.real, 3,\n+\t       GFC_RND_MODE);\n+\n+  a1 = get_array_inq_function (GFC_ISYM_SIZE, a, 1);\n+  a2 = get_array_inq_function (GFC_ISYM_SIZE, a, 2);\n+  b2 = get_array_inq_function (GFC_ISYM_SIZE, b, 2);\n+\n+  gfc_clear_ts (&ts);\n+  ts.type = BT_REAL;\n+  ts.kind = gfc_default_real_kind;\n+  gfc_convert_type_warn (a1, &ts, 2, 0);\n+  gfc_convert_type_warn (a2, &ts, 2, 0);\n+  gfc_convert_type_warn (b2, &ts, 2, 0);\n+\n+  m1 = get_operand (INTRINSIC_TIMES, a1, a2);\n+  m2 = get_operand (INTRINSIC_TIMES, m1, b2);\n+\n+  cond = build_logical_expr (INTRINSIC_LE, m2, inline_limit);\n+  gfc_simplify_expr (cond, 0);\n+\n+  else_2 = XCNEW (gfc_code);\n+  else_2->op = EXEC_IF;\n+  else_2->loc = a->where;\n+\n+  if_2 = XCNEW (gfc_code);\n+  if_2->op = EXEC_IF;\n+  if_2->expr1 = cond;\n+  if_2->loc = a->where;\n+  if_2->block = else_2;\n+\n+  if_1 = XCNEW (gfc_code);\n+  if_1->op = EXEC_IF;\n+  if_1->block = if_2;\n+  if_1->loc = a->where;\n+\n+  return if_1;\n+}\n+\n+\n+/* Insert code to issue a runtime error if the expressions are not equal.  */\n+\n+static gfc_code *\n+runtime_error_ne (gfc_expr *e1, gfc_expr *e2, const char *msg)\n+{\n+  gfc_expr *cond;\n+  gfc_code *if_1, *if_2;\n+  gfc_code *c;\n+  gfc_actual_arglist *a1, *a2, *a3;\n+\n+  gcc_assert (e1->where.lb);\n+  /* Build the call to runtime_error.  */\n+  c = XCNEW (gfc_code);\n+  c->op = EXEC_CALL;\n+  c->loc = e1->where;\n+\n+  /* Get a null-terminated message string.  */\n+\n+  a1 = gfc_get_actual_arglist ();\n+  a1->expr = gfc_get_character_expr (gfc_default_character_kind, &e1->where,\n+\t\t\t\t     msg, strlen(msg)+1);\n+  c->ext.actual = a1;\n+\n+  /* Pass the value of the first expression.  */\n+  a2 = gfc_get_actual_arglist ();\n+  a2->expr = gfc_copy_expr (e1);\n+  a1->next = a2;\n+\n+  /* Pass the value of the second expression.  */\n+  a3 = gfc_get_actual_arglist ();\n+  a3->expr = gfc_copy_expr (e2);\n+  a2->next = a3;\n+\n+  gfc_check_fe_runtime_error (c->ext.actual);\n+  gfc_resolve_fe_runtime_error (c);\n+\n+  if_2 = XCNEW (gfc_code);\n+  if_2->op = EXEC_IF;\n+  if_2->loc = e1->where;\n+  if_2->next = c;\n+\n+  if_1 = XCNEW (gfc_code);\n+  if_1->op = EXEC_IF;\n+  if_1->block = if_2;\n+  if_1->loc = e1->where;\n+\n+  cond = build_logical_expr (INTRINSIC_NE, e1, e2);\n+  gfc_simplify_expr (cond, 0);\n+  if_2->expr1 = cond;\n+\n+  return if_1;\n+}\n+\n+/* Handle matrix reallocation.  Caller is responsible to insert into\n+   the code tree.\n+\n+   For the two-dimensional case, build \n+\n+  if (allocated(c)) then\n+     if (size(c,1) /= size(a,1) .or. size(c,2) /= size(b,2)) then\n+        deallocate(c)\n+        allocate (c(size(a,1), size(b,2)))\n+     end if\n+  else\n+     allocate (c(size(a,1),size(b,2)))\n+  end if\n+\n+  and for the other cases correspondingly.\n+*/\n+\n+static gfc_code *\n+matmul_lhs_realloc (gfc_expr *c, gfc_expr *a, gfc_expr *b,\n+\t\t    enum matrix_case m_case)\n+{\n+\n+  gfc_expr *allocated, *alloc_expr;\n+  gfc_code *if_alloc_1, *if_alloc_2, *if_size_1, *if_size_2;\n+  gfc_code *else_alloc;\n+  gfc_code *deallocate, *allocate1, *allocate_else;\n+  gfc_array_ref *ar;\n+  gfc_expr *cond, *ne1, *ne2;\n+\n+  if (warn_realloc_lhs)\n+    gfc_warning (OPT_Wrealloc_lhs,\n+\t\t \"Code for reallocating the allocatable array at %L will \"\n+\t\t \"be added\", &c->where);\n+\n+  alloc_expr = gfc_copy_expr (c);\n+\n+  ar = gfc_find_array_ref (alloc_expr);\n+  gcc_assert (ar && ar->type == AR_FULL);\n+\n+  /* c comes in as a full ref.  Change it into a copy and make it into an\n+     element ref so it has the right form for for ALLOCATE.  In the same\n+     switch statement, also generate the size comparison for the secod IF\n+     statement.  */\n+\n+  ar->type = AR_ELEMENT;\n+\n+  switch (m_case)\n+    {\n+    case A2B2:\n+      ar->start[0] = get_array_inq_function (GFC_ISYM_SIZE, a, 1);\n+      ar->start[1] = get_array_inq_function (GFC_ISYM_SIZE, b, 2);\n+      ne1 = build_logical_expr (INTRINSIC_NE,\n+\t\t\t\tget_array_inq_function (GFC_ISYM_SIZE, c, 1),\n+\t\t\t\tget_array_inq_function (GFC_ISYM_SIZE, a, 1));\n+      ne2 = build_logical_expr (INTRINSIC_NE,\n+\t\t\t\tget_array_inq_function (GFC_ISYM_SIZE, c, 2),\n+\t\t\t\tget_array_inq_function (GFC_ISYM_SIZE, b, 2));\n+      cond = build_logical_expr (INTRINSIC_OR, ne1, ne2);\n+      break;\n+\n+    case A2B1:\n+      ar->start[0] = get_array_inq_function (GFC_ISYM_SIZE, a, 1);\n+      cond = build_logical_expr (INTRINSIC_NE,\n+\t\t\t\t get_array_inq_function (GFC_ISYM_SIZE, c, 1),\n+\t\t\t\t get_array_inq_function (GFC_ISYM_SIZE, a, 2));\n+      break;\n+\n+    case A1B2:\n+      ar->start[0] = get_array_inq_function (GFC_ISYM_SIZE, b, 1);\n+      cond = build_logical_expr (INTRINSIC_NE,\n+\t\t\t\t get_array_inq_function (GFC_ISYM_SIZE, c, 1),\n+\t\t\t\t get_array_inq_function (GFC_ISYM_SIZE, b, 2));\n+      break;\n+\n+    default:\n+      gcc_unreachable();\n+\n+    }\n+\n+  gfc_simplify_expr (cond, 0);\n+\n+  /* We need two identical allocate statements in two\n+     branches of the IF statement.  */\n+  \n+  allocate1 = XCNEW (gfc_code);\n+  allocate1->op = EXEC_ALLOCATE;\n+  allocate1->ext.alloc.list = gfc_get_alloc ();\n+  allocate1->loc = c->where;\n+  allocate1->ext.alloc.list->expr = gfc_copy_expr (alloc_expr);\n+\n+  allocate_else = XCNEW (gfc_code);\n+  allocate_else->op = EXEC_ALLOCATE;\n+  allocate_else->ext.alloc.list = gfc_get_alloc ();\n+  allocate_else->loc = c->where;\n+  allocate_else->ext.alloc.list->expr = alloc_expr;\n+\n+  allocated = gfc_build_intrinsic_call (current_ns, GFC_ISYM_ALLOCATED,\n+\t\t\t\t\t\"_gfortran_allocated\", c->where,\n+\t\t\t\t\t1, gfc_copy_expr (c));\n+\n+  deallocate = XCNEW (gfc_code);\n+  deallocate->op = EXEC_DEALLOCATE;\n+  deallocate->ext.alloc.list = gfc_get_alloc ();\n+  deallocate->ext.alloc.list->expr = gfc_copy_expr (c);\n+  deallocate->next = allocate1;\n+  deallocate->loc = c->where;\n+  \n+  if_size_2 = XCNEW (gfc_code);\n+  if_size_2->op = EXEC_IF;\n+  if_size_2->expr1 = cond;\n+  if_size_2->loc = c->where;\n+  if_size_2->next = deallocate;\n+\n+  if_size_1 = XCNEW (gfc_code);\n+  if_size_1->op = EXEC_IF;\n+  if_size_1->block = if_size_2;\n+  if_size_1->loc = c->where;\n+\n+  else_alloc = XCNEW (gfc_code);\n+  else_alloc->op = EXEC_IF;\n+  else_alloc->loc = c->where;\n+  else_alloc->next = allocate_else;\n+\n+  if_alloc_2 = XCNEW (gfc_code);\n+  if_alloc_2->op = EXEC_IF;\n+  if_alloc_2->expr1 = allocated;\n+  if_alloc_2->loc = c->where;\n+  if_alloc_2->next = if_size_1;\n+  if_alloc_2->block = else_alloc;\n+\n+  if_alloc_1 = XCNEW (gfc_code);\n+  if_alloc_1->op = EXEC_IF;\n+  if_alloc_1->block = if_alloc_2;\n+  if_alloc_1->loc = c->where;\n+\n+  return if_alloc_1;\n+}\n+\n+/* Callback function for has_function_or_op.  */\n+\n+static int\n+is_function_or_op (gfc_expr **e, int *walk_subtrees ATTRIBUTE_UNUSED,\n+\t     void *data ATTRIBUTE_UNUSED)\n+{\n+  if ((*e) == 0)\n+    return 0;\n+  else\n+    return (*e)->expr_type == EXPR_FUNCTION\n+      || (*e)->expr_type == EXPR_OP;\n+}\n+\n+/* Returns true if the expression contains a function.  */\n+\n+static bool\n+has_function_or_op (gfc_expr **e)\n+{\n+  if (e == NULL)\n+    return false;\n+  else\n+    return gfc_expr_walker (e, is_function_or_op, NULL);\n+}\n+\n+/* Freeze (assign to a temporary variable) a single expression.  */\n+\n+static void\n+freeze_expr (gfc_expr **ep)\n+{\n+  gfc_expr *ne;\n+  if (has_function_or_op (ep))\n+    {\n+      ne = create_var (*ep, \"freeze\");\n+      *ep = ne;\n+    }\n+}\n+\n+/* Go through an expression's references and assign them to temporary\n+   variables if they contain functions.  This is usually done prior to\n+   front-end scalarization to avoid multiple invocations of functions.  */\n+\n+static void\n+freeze_references (gfc_expr *e)\n+{\n+  gfc_ref *r;\n+  gfc_array_ref *ar;\n+  int i;\n+\n+  for (r=e->ref; r; r=r->next)\n+    {\n+      if (r->type == REF_SUBSTRING)\n+\t{\n+\t  if (r->u.ss.start != NULL)\n+\t    freeze_expr (&r->u.ss.start);\n+\n+\t  if (r->u.ss.end != NULL)\n+\t    freeze_expr (&r->u.ss.end);\n+\t}\n+      else if (r->type == REF_ARRAY)\n+\t{\n+\t  ar = &r->u.ar;\n+\t  switch (ar->type)\n+\t    {\n+\t    case AR_FULL:\n+\t      break;\n+\n+\t    case AR_SECTION:\n+\t      for (i=0; i<ar->dimen; i++)\n+\t\t{\n+\t\t  if (ar->dimen_type[i] == DIMEN_RANGE)\n+\t\t    {\n+\t\t      freeze_expr (&ar->start[i]);\n+\t\t      freeze_expr (&ar->end[i]);\n+\t\t      freeze_expr (&ar->stride[i]);\n+\t\t    }\n+\t\t  else if (ar->dimen_type[i] == DIMEN_ELEMENT)\n+\t\t    {\n+\t\t      freeze_expr (&ar->start[i]);\n+\t\t    }\n+\t\t}\n+\t      break;\n+\n+\t    case AR_ELEMENT:\n+\t      for (i=0; i<ar->dimen; i++)\n+\t\tfreeze_expr (&ar->start[i]);\n+\t      break;\n+\n+\t    default:\n+\t      break;\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Convert to gfc_index_integer_kind if needed, just do a copy otherwise.  */\n+\n+static gfc_expr *\n+convert_to_index_kind (gfc_expr *e)\n+{\n+  gfc_expr *res;\n+\n+  gcc_assert (e != NULL);\n+\n+  res = gfc_copy_expr (e);\n+\n+  gcc_assert (e->ts.type == BT_INTEGER);\n+\n+  if (res->ts.kind != gfc_index_integer_kind)\n+    {\n+      gfc_typespec ts;\n+      gfc_clear_ts (&ts);\n+      ts.type = BT_INTEGER;\n+      ts.kind = gfc_index_integer_kind;\n+\n+      gfc_convert_type_warn (e, &ts, 2, 0);\n+    }\n+\n+  return res;\n+}\n+\n+/* Function to create a DO loop including creation of the\n+   iteration variable.  gfc_expr are copied.*/\n+\n+static gfc_code *\n+create_do_loop (gfc_expr *start, gfc_expr *end, gfc_expr *step, locus *where,\n+\t\tgfc_namespace *ns, char *vname)\n+{\n+\n+  char name[GFC_MAX_SYMBOL_LEN +1];\n+  gfc_symtree *symtree;\n+  gfc_symbol *symbol;\n+  gfc_expr *i;\n+  gfc_code *n, *n2;\n+\n+  /* Create an expression for the iteration variable.  */\n+  if (vname)\n+    sprintf (name, \"__var_%d_do_%s\", var_num++, vname);\n+  else\n+    sprintf (name, \"__var_%d_do\", var_num++);\n+\n+\n+  if (gfc_get_sym_tree (name, ns, &symtree, false) != 0)\n+    gcc_unreachable ();\n+\n+  /* Create the loop variable.  */\n+\n+  symbol = symtree->n.sym;\n+  symbol->ts.type = BT_INTEGER;\n+  symbol->ts.kind = gfc_index_integer_kind;\n+  symbol->attr.flavor = FL_VARIABLE;\n+  symbol->attr.referenced = 1;\n+  symbol->attr.dimension = 0;\n+  symbol->attr.fe_temp = 1;\n+  gfc_commit_symbol (symbol);\n+\n+  i = gfc_get_expr ();\n+  i->expr_type = EXPR_VARIABLE;\n+  i->ts = symbol->ts;\n+  i->rank = 0;\n+  i->where = *where;\n+  i->symtree = symtree;\n+\n+  /* ... and the nested DO statements.  */\n+  n = XCNEW (gfc_code);\n+  n->op = EXEC_DO;\n+  n->loc = *where;\n+  n->ext.iterator = gfc_get_iterator ();\n+  n->ext.iterator->var = i;\n+  n->ext.iterator->start = convert_to_index_kind (start);\n+  n->ext.iterator->end = convert_to_index_kind (end);\n+  if (step)\n+    n->ext.iterator->step = convert_to_index_kind (step);\n+  else\n+    n->ext.iterator->step = gfc_get_int_expr (gfc_index_integer_kind,\n+\t\t\t\t\t      where, 1);\n+\n+  n2 = XCNEW (gfc_code);\n+  n2->op = EXEC_DO;\n+  n2->loc = *where;\n+  n2->next = NULL;\n+  n->block = n2;\n+  return n;\n+}\n+\n+/* Get the upper bound of the DO loops for matmul along a dimension.  This\n+ is one-based.  */\n+\n+static gfc_expr*\n+get_size_m1 (gfc_expr *e, int dimen)\n+{\n+  mpz_t size;\n+  gfc_expr *res;\n+\n+  if (gfc_array_dimen_size (e, dimen - 1, &size))\n+    {\n+      res = gfc_get_constant_expr (BT_INTEGER,\n+\t\t\t\t   gfc_index_integer_kind, &e->where);\n+      mpz_sub_ui (res->value.integer, size, 1);\n+      mpz_clear (size);\n+    }\n+  else\n+    {\n+      res = get_operand (INTRINSIC_MINUS,\n+\t\t\t get_array_inq_function (GFC_ISYM_SIZE, e, dimen),\n+\t\t\t gfc_get_int_expr (gfc_index_integer_kind,\n+\t\t\t\t\t   &e->where, 1));\n+      gfc_simplify_expr (res, 0);\n+    }\n+\n+  return res;\n+}\n+\n+/* Function to return a scalarized expression. It is assumed that indices are\n+ zero based to make generation of DO loops easier.  A zero as index will\n+ access the first element along a dimension.  Single element references will\n+ be skipped.  A NULL as an expression will be replaced by a full reference.\n+ This assumes that the index loops have gfc_index_integer_kind, and that all\n+ references have been frozen.  */\n+\n+static gfc_expr*\n+scalarized_expr (gfc_expr *e_in, gfc_expr **index, int count_index)\n+{\n+  gfc_array_ref *ar;\n+  int i;\n+  int rank;\n+  gfc_expr *e;\n+  int i_index;\n+  bool was_fullref;\n+\n+  e = gfc_copy_expr(e_in);\n+\n+  rank = e->rank;\n+\n+  ar = gfc_find_array_ref (e);\n+\n+  /* We scalarize count_index variables, reducing the rank by count_index.  */\n+\n+  e->rank = rank - count_index;\n+\n+  was_fullref = ar->type == AR_FULL;\n+\n+  if (e->rank == 0)\n+    ar->type = AR_ELEMENT;\n+  else\n+    ar->type = AR_SECTION;\n+\n+  /* Loop over the indices.  For each index, create the expression\n+     index * stride + lbound(e, dim).  */\n+  \n+  i_index = 0;\n+  for (i=0; i < ar->dimen; i++)\n+    {\n+      if (was_fullref || ar->dimen_type[i] == DIMEN_RANGE)\n+\t{\n+\t  if (index[i_index] != NULL)\n+\t    {\n+\t      gfc_expr *lbound, *nindex;\n+\t      gfc_expr *loopvar;\n+\t      \n+\t      loopvar = gfc_copy_expr (index[i_index]); \n+\t      \n+\t      if (ar->stride[i])\n+\t\t{\n+\t\t  gfc_expr *tmp;\n+\n+\t\t  tmp = gfc_copy_expr(ar->stride[i]);\n+\t\t  if (tmp->ts.kind != gfc_index_integer_kind)\n+\t\t    {\n+\t\t      gfc_typespec ts;\n+\t\t      gfc_clear_ts (&ts);\n+\t\t      ts.type = BT_INTEGER;\n+\t\t      ts.kind = gfc_index_integer_kind;\n+\t\t      gfc_convert_type (tmp, &ts, 2);\n+\t\t    }\n+\t\t  nindex = get_operand (INTRINSIC_TIMES, loopvar, tmp);\n+\t\t}\n+\t      else\n+\t\tnindex = loopvar;\n+\t      \n+\t      /* Calculate the lower bound of the expression.  */\n+\t      if (ar->start[i])\n+\t\t{\n+\t\t  lbound = gfc_copy_expr (ar->start[i]);\n+\t\t  if (lbound->ts.kind != gfc_index_integer_kind)\n+\t\t    {\n+\t\t      gfc_typespec ts;\n+\t\t      gfc_clear_ts (&ts);\n+\t\t      ts.type = BT_INTEGER;\n+\t\t      ts.kind = gfc_index_integer_kind;\n+\t\t      gfc_convert_type (lbound, &ts, 2);\n+\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (!was_fullref)\n+\t\t    {\n+\t\t      /* Look at full individual sections, like a(:).  The first index\n+\t\t\t is the lbound of a full ref.  */\n+\n+\t\t      gfc_array_ref *ar;\n+\n+\t\t      ar = gfc_find_array_ref (e_in);\n+\t\t      ar->type = AR_FULL;\n+\t\t    }\n+\t\t  lbound = get_array_inq_function (GFC_ISYM_LBOUND, e_in,\n+\t\t\t\t\t\t   i_index + 1);\n+\t\t}\n+\t      \n+\t      ar->dimen_type[i] = DIMEN_ELEMENT;\n+\n+\t      gfc_free_expr (ar->start[i]);\n+\t      ar->start[i] = get_operand (INTRINSIC_PLUS, nindex, lbound);\n+\t      \n+\t      gfc_free_expr (ar->end[i]);\n+\t      ar->end[i] = NULL;\n+\t      gfc_free_expr (ar->stride[i]);\n+\t      ar->stride[i] = NULL;\n+\t      gfc_simplify_expr (ar->start[i], 0);\n+\t    }\n+\t  else if (was_fullref)\n+\t    {\n+\t      gfc_internal_error (\"Scalarization using DIMEN_RANGE unimplemented\");\n+\t    }\n+\t  i_index ++;\n+\t}\n+    }\n+  return e;\n+}\n+\n+\n+/* Inline assignments of the form c = matmul(a,b).\n+   Handle only the cases currently where b and c are rank-two arrays.\n+\n+   This basically translates the code to\n+\n+   BLOCK\n+     integer i,j,k\n+     c = 0\n+     do j=0, size(b,2)-1\n+       do k=0, size(a, 2)-1\n+         do i=0, size(a, 1)-1\n+            c(i * stride(c,1) + lbound(c,1), j * stride(c,2) + lbound(c,2)) =\n+\t    c(i * stride(c,1) + lbound(c,1), j * stride(c,2) + lbound(c,2)) +\n+            a(i * stride(a,1) + lbound(a,1), k * stride(a,2) + lbound(a,2)) *\n+            b(k * stride(b,1) + lbound(b,1), j * stride(b,2) + lbound(b,2))\n+         end do\n+       end do\n+     end do\n+   END BLOCK\n+   \n+*/\n+\n+static int\n+inline_matmul_assign (gfc_code **c, int *walk_subtrees,\n+\t\t\t  void *data ATTRIBUTE_UNUSED)\n+{\n+  gfc_code *co = *c;\n+  gfc_expr *expr1, *expr2;\n+  gfc_expr *matrix_a, *matrix_b;\n+  gfc_actual_arglist *a, *b;\n+  gfc_code *do_1, *do_2, *do_3, *assign_zero, *assign_matmul;\n+  gfc_expr *zero_e;\n+  gfc_expr *u1, *u2, *u3;\n+  gfc_expr *list[2];\n+  gfc_expr *ascalar, *bscalar, *cscalar;\n+  gfc_expr *mult;\n+  gfc_expr *var_1, *var_2, *var_3;\n+  gfc_expr *zero;\n+  gfc_namespace *ns;\n+  gfc_intrinsic_op op_times, op_plus;\n+  enum matrix_case m_case;\n+  int i;\n+  gfc_code *if_limit = NULL;\n+  gfc_code **next_code_point;\n+\n+  if (co->op != EXEC_ASSIGN)\n+    return 0;\n+\n+  expr1 = co->expr1;\n+  expr2 = co->expr2;\n+  if (expr2->expr_type != EXPR_FUNCTION\n+      || expr2->value.function.isym == NULL\n+      || expr2->value.function.isym->id != GFC_ISYM_MATMUL)\n+    return 0;\n+\n+  current_code = c;\n+  inserted_block = NULL;\n+  changed_statement = NULL;\n+\n+  a = expr2->value.function.actual;\n+  matrix_a = a->expr;\n+  b = a->next;\n+  matrix_b = b->expr;\n+\n+  /* Currently only handling direct variables.  Transpose etc. will come\n+     later.  */\n+\n+  if (matrix_a->expr_type != EXPR_VARIABLE\n+      || matrix_b->expr_type != EXPR_VARIABLE)\n+    return 0;\n+\n+  if (matrix_a->rank == 2)\n+    m_case = matrix_b->rank == 1 ? A2B1 : A2B2;\n+  else\n+    m_case = A1B2;\n+\n+  /* We do not handle data dependencies yet.  */\n+  if (gfc_check_dependency (expr1, matrix_a, true)\n+      || gfc_check_dependency (expr1, matrix_b, true))\n+    return 0;\n+\n+  ns = insert_block ();\n+\n+  /* Assign the type of the zero expression for initializing the resulting\n+     array, and the expression (+ and * for real, integer and complex;\n+     .and. and .or for logical.  */\n+\n+  switch(expr1->ts.type)\n+    {\n+    case BT_INTEGER:\n+      zero_e = gfc_get_int_expr (expr1->ts.kind, &expr1->where, 0);\n+      op_times = INTRINSIC_TIMES;\n+      op_plus = INTRINSIC_PLUS;\n+      break;\n+\n+    case BT_LOGICAL:\n+      op_times = INTRINSIC_AND;\n+      op_plus = INTRINSIC_OR;\n+      zero_e = gfc_get_logical_expr (expr1->ts.kind, &expr1->where,\n+\t\t\t\t     0);\n+      break;\n+    case BT_REAL:\n+      zero_e = gfc_get_constant_expr (BT_REAL, expr1->ts.kind,\n+\t\t\t\t      &expr1->where);\n+      mpfr_set_si (zero_e->value.real, 0, GFC_RND_MODE);\n+      op_times = INTRINSIC_TIMES;\n+      op_plus = INTRINSIC_PLUS;\n+      break;\n+\n+    case BT_COMPLEX:\n+      zero_e = gfc_get_constant_expr (BT_COMPLEX, expr1->ts.kind,\n+\t\t\t\t      &expr1->where);\n+      mpc_set_si_si (zero_e->value.complex, 0, 0, GFC_RND_MODE);\n+      op_times = INTRINSIC_TIMES;\n+      op_plus = INTRINSIC_PLUS;\n+\n+      break;\n+\n+    default:\n+      gcc_unreachable();\n+    }\n+\n+  current_code = &ns->code;\n+\n+  /* Freeze the references, keeping track of how many temporary variables were\n+     created.  */\n+  n_vars = 0;\n+  freeze_references (matrix_a);\n+  freeze_references (matrix_b);\n+  freeze_references (expr1);\n+\n+  if (n_vars == 0)\n+    next_code_point = current_code;\n+  else\n+    {\n+      next_code_point = &ns->code;\n+      for (i=0; i<n_vars; i++)\n+\tnext_code_point = &(*next_code_point)->next;\n+    }\n+\n+  /* Take care of the inline flag.  If the limit check evaluates to a\n+     constant, dead code elimination will eliminate the unneeded branch.  */\n+\n+  if (m_case == A2B2 && flag_inline_matmul_limit > 0)\n+    {\n+      if_limit = inline_limit_check (matrix_a, matrix_b, m_case);\n+\n+      /* Insert the original statement into the else branch.  */\n+      if_limit->block->block->next = co;\n+      co->next = NULL;\n+\n+      /* ... and the new ones go into the original one.  */\n+      *next_code_point = if_limit;\n+      next_code_point = &if_limit->block->next;\n+    }\n+\n+  assign_zero = XCNEW (gfc_code);\n+  assign_zero->op = EXEC_ASSIGN;\n+  assign_zero->loc = co->loc;\n+  assign_zero->expr1 = gfc_copy_expr (expr1);\n+  assign_zero->expr2 = zero_e;\n+\n+  /* Handle the reallocation, if needed.  */\n+  if (flag_realloc_lhs && gfc_is_reallocatable_lhs (expr1))\n+    {\n+      gfc_code *lhs_alloc;\n+\n+      /* Only need to check a single dimension for the A2B2 case for\n+\t bounds checking, the rest will be allocated.  */\n+\n+      if (gfc_option.rtcheck & GFC_RTCHECK_BOUNDS && m_case == A2B2)\n+\t{\n+\t  gfc_code *test;\n+\t  gfc_expr *a2, *b1;\n+\n+\t  a2 = get_array_inq_function (GFC_ISYM_SIZE, matrix_a, 2);\n+\t  b1 = get_array_inq_function (GFC_ISYM_SIZE, matrix_b, 1);\n+\t  test = runtime_error_ne (b1, a2, \"Dimension of array B incorrect \"\n+\t\t\t\t   \"in MATMUL intrinsic: Is %ld, should be %ld\");\n+\t  *next_code_point = test;\n+\t  next_code_point = &test->next;\n+\t}\n+\n+\n+      lhs_alloc = matmul_lhs_realloc (expr1, matrix_a, matrix_b, m_case);\n+\n+      *next_code_point = lhs_alloc;\n+      next_code_point = &lhs_alloc->next;\n+\n+    }\n+  else if (gfc_option.rtcheck & GFC_RTCHECK_BOUNDS)\n+    {\n+      gfc_code *test;\n+      gfc_expr *a2, *b1, *c1, *c2, *a1, *b2;\n+\n+      if (m_case == A2B2 || m_case == A2B1)\n+\t{\n+\t  a2 = get_array_inq_function (GFC_ISYM_SIZE, matrix_a, 2);\n+\t  b1 = get_array_inq_function (GFC_ISYM_SIZE, matrix_b, 1);\n+\t  test = runtime_error_ne (b1, a2, \"Dimension of array B incorrect \"\n+\t\t\t\t   \"in MATMUL intrinsic: Is %ld, should be %ld\");\n+\t  *next_code_point = test;\n+\t  next_code_point = &test->next;\n+\n+\t  c1 = get_array_inq_function (GFC_ISYM_SIZE, expr1, 1);\n+\t  a1 = get_array_inq_function (GFC_ISYM_SIZE, matrix_a, 1);\n+\n+\t  if (m_case == A2B2)\n+\t    test = runtime_error_ne (c1, a1, \"Incorrect extent in return array in \"\n+\t\t\t\t     \"MATMUL intrinsic for dimension 1: \"\n+\t\t\t\t     \"is %ld, should be %ld\");\n+\t  else if (m_case == A2B1)\n+\t    test = runtime_error_ne (c1, a1, \"Incorrect extent in return array in \"\n+\t\t\t\t     \"MATMUL intrinsic: \"\n+\t\t\t\t     \"is %ld, should be %ld\");\n+\n+\n+\t  *next_code_point = test;\n+\t  next_code_point = &test->next;\n+\t}\n+      else if (m_case == A1B2)\n+\t{\n+\t  a1 = get_array_inq_function (GFC_ISYM_SIZE, matrix_a, 1);\n+\t  b1 = get_array_inq_function (GFC_ISYM_SIZE, matrix_b, 1);\n+\t  test = runtime_error_ne (b1, a1, \"Dimension of array B incorrect \"\n+\t\t\t\t   \"in MATMUL intrinsic: Is %ld, should be %ld\");\n+\t  *next_code_point = test;\n+\t  next_code_point = &test->next;\n+\n+\t  c1 = get_array_inq_function (GFC_ISYM_SIZE, expr1, 1);\n+\t  b2 = get_array_inq_function (GFC_ISYM_SIZE, matrix_b, 2);\n+\n+\t  test = runtime_error_ne (c1, b2, \"Incorrect extent in return array in \"\n+\t\t\t\t   \"MATMUL intrinsic: \"\n+\t\t\t\t   \"is %ld, should be %ld\");\n+\n+\t  *next_code_point = test;\n+\t  next_code_point = &test->next;\n+\t}\n+\n+      if (m_case == A2B2)\n+\t{\n+\t  c2 = get_array_inq_function (GFC_ISYM_SIZE, expr1, 2);\n+\t  b2 = get_array_inq_function (GFC_ISYM_SIZE, matrix_b, 2);\n+\t  test = runtime_error_ne (c2, b2, \"Incorrect extent in return array in \"\n+\t\t\t\t   \"MATMUL intrinsic for dimension 2: is %ld, should be %ld\");\n+\n+\t  *next_code_point = test;\n+\t  next_code_point = &test->next;\n+\t}\n+    }\n+\n+  *next_code_point = assign_zero;\n+\n+  zero = gfc_get_int_expr (gfc_index_integer_kind, &co->loc, 0);\n+\n+  assign_matmul = XCNEW (gfc_code);\n+  assign_matmul->op = EXEC_ASSIGN;\n+  assign_matmul->loc = co->loc;\n+\n+  /* Get the bounds for the loops, create them and create the scalarized\n+     expressions.  */\n+\n+  switch (m_case)\n+    {\n+    case A2B2:\n+      inline_limit_check (matrix_a, matrix_b, m_case);\n+\n+      u1 = get_size_m1 (matrix_b, 2);\n+      u2 = get_size_m1 (matrix_a, 2);\n+      u3 = get_size_m1 (matrix_a, 1);\n+\n+      do_1 = create_do_loop (gfc_copy_expr (zero), u1, NULL, &co->loc, ns);\n+      do_2 = create_do_loop (gfc_copy_expr (zero), u2, NULL, &co->loc, ns);\n+      do_3 = create_do_loop (gfc_copy_expr (zero), u3, NULL, &co->loc, ns);\n+\n+      do_1->block->next = do_2;\n+      do_2->block->next = do_3;\n+      do_3->block->next = assign_matmul;\n+\n+      var_1 = do_1->ext.iterator->var;\n+      var_2 = do_2->ext.iterator->var;\n+      var_3 = do_3->ext.iterator->var;\n+\n+      list[0] = var_3;\n+      list[1] = var_1;\n+      cscalar = scalarized_expr (gfc_copy_expr (co->expr1), list, 2);\n+\n+      list[0] = var_3;\n+      list[1] = var_2;\n+      ascalar = scalarized_expr (gfc_copy_expr (matrix_a), list, 2);\n+\n+      list[0] = var_2;\n+      list[1] = var_1;\n+      bscalar = scalarized_expr (gfc_copy_expr (matrix_b), list, 2);\n+\n+      break;\n+\n+    case A2B1:\n+      u1 = get_size_m1 (matrix_b, 1);\n+      u2 = get_size_m1 (matrix_a, 1);\n+\n+      do_1 = create_do_loop (gfc_copy_expr (zero), u1, NULL, &co->loc, ns);\n+      do_2 = create_do_loop (gfc_copy_expr (zero), u2, NULL, &co->loc, ns);\n+\n+      do_1->block->next = do_2;\n+      do_2->block->next = assign_matmul;\n+\n+      var_1 = do_1->ext.iterator->var;\n+      var_2 = do_2->ext.iterator->var;\n+\n+      list[0] = var_2;\n+      cscalar = scalarized_expr (gfc_copy_expr (co->expr1), list, 1);\n+\n+      list[0] = var_2;\n+      list[1] = var_1;\n+      ascalar = scalarized_expr (gfc_copy_expr (matrix_a), list, 2);\n+\n+      list[0] = var_1;\n+      bscalar = scalarized_expr (gfc_copy_expr (matrix_b), list, 1);\n+\n+      break;\n+\n+    case A1B2:\n+      u1 = get_size_m1 (matrix_b, 2);\n+      u2 = get_size_m1 (matrix_a, 1);\n+\n+      do_1 = create_do_loop (gfc_copy_expr (zero), u1, NULL, &co->loc, ns);\n+      do_2 = create_do_loop (gfc_copy_expr (zero), u2, NULL, &co->loc, ns);\n+\n+      do_1->block->next = do_2;\n+      do_2->block->next = assign_matmul;\n+\n+      var_1 = do_1->ext.iterator->var;\n+      var_2 = do_2->ext.iterator->var;\n+\n+      list[0] = var_1;\n+      cscalar = scalarized_expr (gfc_copy_expr (co->expr1), list, 1);\n+\n+      list[0] = var_2;\n+      ascalar = scalarized_expr (gfc_copy_expr (matrix_a), list, 1);\n+\n+      list[0] = var_2;\n+      list[1] = var_1;\n+      bscalar = scalarized_expr (gfc_copy_expr (matrix_b), list, 2);\n+\n+      break;\n+\n+    default:\n+      gcc_unreachable();\n+    }\n+\n+  /* First loop comes after the zero assignment.  */\n+  assign_zero->next = do_1;\n+\n+  /* Build the assignment expression in the loop.  */\n+  assign_matmul->expr1 = gfc_copy_expr (cscalar);\n+\n+  mult = get_operand (op_times, ascalar, bscalar);\n+  assign_matmul->expr2 = get_operand (op_plus, cscalar, mult);\n+\n+  /* If we don't want to keep the original statement around in\n+     the else branch, we can free it.  */\n+\n+  if (if_limit == NULL)\n+    gfc_free_statements(co);\n+  else\n+    co->next = NULL;\n+\n+  gfc_free_expr (zero);\n+  *walk_subtrees = 0;\n+  return 0;\n+}\n \n #define WALK_SUBEXPR(NODE) \\\n   do\t\t\t\t\t\t\t\\"}, {"sha": "6c54da87182e20dd1d0b80766019df1785bd7549", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1abbf6901a64919e61baf5ff60afa3679f1d086/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1abbf6901a64919e61baf5ff60afa3679f1d086/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=f1abbf6901a64919e61baf5ff60afa3679f1d086", "patch": "@@ -419,6 +419,7 @@ enum gfc_isym_id\n   GFC_ISYM_EXPONENT,\n   GFC_ISYM_EXTENDS_TYPE_OF,\n   GFC_ISYM_FDATE,\n+  GFC_ISYM_FE_RUNTIME_ERROR,\n   GFC_ISYM_FGET,\n   GFC_ISYM_FGETC,\n   GFC_ISYM_FLOOR,\n@@ -1001,7 +1002,6 @@ typedef struct\n   bool cp_was_assumed; /* AS_ASSUMED_SIZE cp arrays are converted to\n \t\t\tAS_EXPLICIT, but we want to remember that we\n \t\t\tdid this.  */\n-\n }\n gfc_array_spec;\n \n@@ -1907,7 +1907,7 @@ typedef struct gfc_intrinsic_sym\n   gfc_typespec ts;\n   unsigned elemental:1, inquiry:1, transformational:1, pure:1,\n     generic:1, specific:1, actual_ok:1, noreturn:1, conversion:1,\n-    from_module:1;\n+    from_module:1, vararg:1;\n \n   int standard;\n \n@@ -3231,4 +3231,8 @@ int gfc_code_walker (gfc_code **, walk_code_fn_t, walk_expr_fn_t, void *);\n \n void gfc_convert_mpz_to_signed (mpz_t, int);\n \n+/* trans-array.c  */\n+\n+bool gfc_is_reallocatable_lhs (gfc_expr *);\n+\n #endif /* GCC_GFORTRAN_H  */"}, {"sha": "1c0c388c5121e234d930257796f4856f5213f662", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 46, "deletions": 1, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1abbf6901a64919e61baf5ff60afa3679f1d086/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1abbf6901a64919e61baf5ff60afa3679f1d086/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=f1abbf6901a64919e61baf5ff60afa3679f1d086", "patch": "@@ -520,6 +520,29 @@ add_sym_1s (const char *name, gfc_isym_id id, enum klass cl, bt type, int kind,\n \t   (void *) 0);\n }\n \n+/* Add a symbol to the subroutine ilst where the subroutine takes one\n+   printf-style character argument and a variable number of arguments\n+   to follow.  */\n+\n+static void\n+add_sym_1p (const char *name, gfc_isym_id id, enum klass cl, bt type, int kind,\n+\t    int standard, bool (*check) (gfc_actual_arglist *),\n+\t    gfc_expr *(*simplify) (gfc_expr*), void (*resolve) (gfc_code *),\n+\t    const char *a1, bt type1, int kind1, int optional1, sym_intent intent1)\n+{\n+  gfc_check_f cf;\n+  gfc_simplify_f sf;\n+  gfc_resolve_f rf;\n+\n+  cf.f1m = check;\n+  sf.f1 = simplify;\n+  rf.s1 = resolve;\n+\n+  add_sym (name, id, cl, ACTUAL_NO, type, kind, standard, cf, sf, rf,\n+\t   a1, type1, kind1, optional1, intent1,\n+\t   (void *) 0);\n+}\n+\n \n /* Add a symbol from the MAX/MIN family of intrinsic functions to the\n    function.  MAX et al take 2 or more arguments.  */\n@@ -1159,6 +1182,17 @@ make_from_module (void)\n     next_sym[-1].from_module = 1;\n }\n \n+\n+/* Mark the current subroutine as having a variable number of\n+   arguments.  */\n+\n+static void\n+make_vararg (void)\n+{\n+  if (sizing == SZ_NOTHING)\n+    next_sym[-1].vararg = 1;\n+}\n+\n /* Set the attr.value of the current procedure.  */\n \n static void\n@@ -3292,6 +3326,17 @@ add_subroutines (void)\n \t      \"fptr\", BT_UNKNOWN, 0, REQUIRED, INTENT_OUT);\n   make_from_module();\n \n+  /* Internal subroutine for emitting a runtime error.  */\n+\n+  add_sym_1p (\"fe_runtime_error\", GFC_ISYM_FE_RUNTIME_ERROR, CLASS_IMPURE,\n+\t      BT_UNKNOWN, 0, GFC_STD_GNU,\n+\t      gfc_check_fe_runtime_error, NULL, gfc_resolve_fe_runtime_error,\n+\t      \"msg\", BT_CHARACTER, dc, REQUIRED, INTENT_IN);\n+\n+  make_noreturn ();\n+  make_vararg ();\n+  make_from_module ();\n+\n   /* Coarray collectives.  */\n   add_sym_4s (\"co_broadcast\", GFC_ISYM_CO_BROADCAST, CLASS_IMPURE,\n \t      BT_UNKNOWN, 0, GFC_STD_F2008_TS,\n@@ -4501,7 +4546,7 @@ gfc_intrinsic_sub_interface (gfc_code *c, int error_flag)\n \n   init_arglist (isym);\n \n-  if (!sort_actual (name, &c->ext.actual, isym->formal, &c->loc))\n+  if (!isym->vararg && !sort_actual (name, &c->ext.actual, isym->formal, &c->loc))\n     goto fail;\n \n   if (!do_ts29113_check (isym, c->ext.actual))"}, {"sha": "a9f16f52743f1c04a085df4486ee16c19b612333", "filename": "gcc/fortran/intrinsic.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1abbf6901a64919e61baf5ff60afa3679f1d086/gcc%2Ffortran%2Fintrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1abbf6901a64919e61baf5ff60afa3679f1d086/gcc%2Ffortran%2Fintrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.h?ref=f1abbf6901a64919e61baf5ff60afa3679f1d086", "patch": "@@ -190,6 +190,7 @@ bool gfc_check_system_clock (gfc_expr *, gfc_expr *, gfc_expr *);\n bool gfc_check_date_and_time (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n bool gfc_check_exit (gfc_expr *);\n bool gfc_check_fdate_sub (gfc_expr *);\n+bool gfc_check_fe_runtime_error (gfc_actual_arglist *);\n bool gfc_check_flush (gfc_expr *);\n bool gfc_check_free (gfc_expr *);\n bool gfc_check_fstat_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n@@ -602,6 +603,7 @@ void gfc_resolve_ctime_sub (gfc_code *);\n void gfc_resolve_execute_command_line (gfc_code *);\n void gfc_resolve_exit (gfc_code *);\n void gfc_resolve_fdate_sub (gfc_code *);\n+void gfc_resolve_fe_runtime_error (gfc_code *);\n void gfc_resolve_flush (gfc_code *);\n void gfc_resolve_free (gfc_code *);\n void gfc_resolve_fseek_sub (gfc_code *);"}, {"sha": "fc9f1b0fa1d12b1eb1ca6badf8ba9b5733a2b1ca", "filename": "gcc/fortran/invoke.texi", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1abbf6901a64919e61baf5ff60afa3679f1d086/gcc%2Ffortran%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1abbf6901a64919e61baf5ff60afa3679f1d086/gcc%2Ffortran%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finvoke.texi?ref=f1abbf6901a64919e61baf5ff60afa3679f1d086", "patch": "@@ -178,6 +178,7 @@ and warnings}.\n -finit-character=@var{n} -finit-integer=@var{n} -finit-local-zero @gol\n -finit-logical=@var{<true|false>}\n -finit-real=@var{<zero|inf|-inf|nan|snan>} @gol\n+-finline-matmul-limit=@var{n} @gol\n -fmax-array-constructor=@var{n} -fmax-stack-var-size=@var{n}\n -fno-align-commons @gol\n -fno-automatic -fno-protect-parens -fno-underscoring @gol\n@@ -1537,6 +1538,22 @@ geometric mean of the dimensions of the argument and result matrices.\n \n The default value for @var{n} is 30.\n \n+@item -finline-matmul-limit=@var{n}\n+@opindex @code{finline-matmul-limit}\n+When front-end optimiztion is active, some calls to the @code{MATMUL}\n+intrinsic function will be inlined.  This may result in code size\n+increase if the size of the matrix cannot be determined at compile\n+time, as code for both cases is generated.  Setting\n+@code{-finline-matmul-limit=0} will disable inlining in all cases.\n+Setting this option with a value of @var{n} will produce inline code\n+for matrices with size up to @var{n}. If the matrices involved are not\n+square, the size comparison is performed using the geometric mean of\n+the dimensions of the argument and result matrices.\n+\n+The default value for @var{n} is the value specified for\n+@code{-fblas-matmul-limit} if this option is specified, or unlimitited\n+otherwise.\n+\n @item -frecursive\n @opindex @code{frecursive}\n Allow indirect recursion by forcing all local arrays to be allocated\n@@ -1632,11 +1649,12 @@ if @option{-ffrontend-optimize} is in effect.\n @cindex Front-end optimization\n This option performs front-end optimization, based on manipulating\n parts the Fortran parse tree.  Enabled by default by any @option{-O}\n-option.  Optimizations enabled by this option include elimination of\n-identical function calls within expressions, removing unnecessary\n-calls to @code{TRIM} in comparisons and assignments and replacing\n-@code{TRIM(a)} with @code{a(1:LEN_TRIM(a))}. \n-It can be deselected by specifying @option{-fno-frontend-optimize}.\n+option.  Optimizations enabled by this option include inlining calls\n+to @code{MATMUL}, elimination of identical function calls within\n+expressions, removing unnecessary calls to @code{TRIM} in comparisons\n+and assignments and replacing @code{TRIM(a)} with\n+@code{a(1:LEN_TRIM(a))}.  It can be deselected by specifying\n+@option{-fno-frontend-optimize}.\n @end table\n \n @xref{Code Gen Options,,Options for Code Generation Conventions,"}, {"sha": "32ef0719eade56384a0271c30b2f42edb8a5450e", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1abbf6901a64919e61baf5ff60afa3679f1d086/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1abbf6901a64919e61baf5ff60afa3679f1d086/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=f1abbf6901a64919e61baf5ff60afa3679f1d086", "patch": "@@ -2197,6 +2197,19 @@ gfc_resolve_rrspacing (gfc_expr *f, gfc_expr *x)\n   f->value.function.name = gfc_get_string (\"__rrspacing_%d\", x->ts.kind);\n }\n \n+void\n+gfc_resolve_fe_runtime_error (gfc_code *c)\n+{\n+  const char *name;\n+  gfc_actual_arglist *a;\n+\n+  name = gfc_get_string (PREFIX (\"runtime_error\"));\n+\n+  for (a = c->ext.actual->next; a; a = a->next)\n+    a->name = \"%VAL\";\n+\n+  c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n+}\n \n void\n gfc_resolve_scale (gfc_expr *f, gfc_expr *x, gfc_expr *i ATTRIBUTE_UNUSED)"}, {"sha": "a81c4c52b943a467b9004d7bbaabfb1ced063262", "filename": "gcc/fortran/lang.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1abbf6901a64919e61baf5ff60afa3679f1d086/gcc%2Ffortran%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1abbf6901a64919e61baf5ff60afa3679f1d086/gcc%2Ffortran%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Flang.opt?ref=f1abbf6901a64919e61baf5ff60afa3679f1d086", "patch": "@@ -542,6 +542,10 @@ Enum(gfc_init_local_real) String(inf) Value(GFC_INIT_REAL_INF)\n EnumValue\n Enum(gfc_init_local_real) String(-inf) Value(GFC_INIT_REAL_NEG_INF)\n \n+finline-matmul-limit=\n+Fortran RejectNegative Joined UInteger Var(flag_inline_matmul_limit) Init(-1)\n+-finline-matmul-limit=<n>\tSpecify the size of the largest matrix for which matmul will be inlined\n+\n fmax-array-constructor=\n Fortran RejectNegative Joined UInteger Var(flag_max_array_constructor) Init(65535)\n -fmax-array-constructor=<n>\tMaximum number of objects in an array constructor"}, {"sha": "d47cf2acc1c4e309583cb987df34775ff4d6f512", "filename": "gcc/fortran/options.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1abbf6901a64919e61baf5ff60afa3679f1d086/gcc%2Ffortran%2Foptions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1abbf6901a64919e61baf5ff60afa3679f1d086/gcc%2Ffortran%2Foptions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Foptions.c?ref=f1abbf6901a64919e61baf5ff60afa3679f1d086", "patch": "@@ -378,6 +378,11 @@ gfc_post_options (const char **pfilename)\n   if (!flag_automatic)\n     flag_max_stack_var_size = 0;\n   \n+  /* If we call BLAS directly, only inline up to the BLAS limit.  */\n+\n+  if (flag_external_blas && flag_inline_matmul_limit < 0)\n+    flag_inline_matmul_limit = flag_blas_matmul_limit;\n+\n   /* Optimization implies front end optimization, unless the user\n      specified it directly.  */\n "}, {"sha": "2310b659a49fcb0d4bae237211b42b250f30758f", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1abbf6901a64919e61baf5ff60afa3679f1d086/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1abbf6901a64919e61baf5ff60afa3679f1d086/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=f1abbf6901a64919e61baf5ff60afa3679f1d086", "patch": "@@ -64,8 +64,6 @@ tree gfc_copy_only_alloc_comp (gfc_symbol *, tree, tree, int);\n \n tree gfc_alloc_allocatable_for_assignment (gfc_loopinfo*, gfc_expr*, gfc_expr*);\n \n-bool gfc_is_reallocatable_lhs (gfc_expr *);\n-\n /* Add initialization for deferred arrays.  */\n void gfc_trans_deferred_array (gfc_symbol *, gfc_wrapped_block *);\n /* Generate an initializer for a static pointer or allocatable array.  */"}, {"sha": "0be18a35a8d576b106e4a5439fcc15c4de03d4ad", "filename": "gcc/testsuite/gfortran.dg/dependency_26.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1abbf6901a64919e61baf5ff60afa3679f1d086/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_26.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1abbf6901a64919e61baf5ff60afa3679f1d086/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_26.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_26.f90?ref=f1abbf6901a64919e61baf5ff60afa3679f1d086", "patch": "@@ -1,5 +1,5 @@\n ! { dg-do compile }\n-! { dg-options \"-fdump-tree-original\" }\n+! { dg-options \"-finline-matmul-limit=0 -fdump-tree-original\" }\n !\n ! Test the fix for PR36932 and PR36933, in which unnecessary\n ! temporaries were being generated.  The module m2 tests the"}, {"sha": "88527a3334ee13f63ec89297710b55e703951e56", "filename": "gcc/testsuite/gfortran.dg/function_optimize_1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1abbf6901a64919e61baf5ff60afa3679f1d086/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_optimize_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1abbf6901a64919e61baf5ff60afa3679f1d086/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_optimize_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_optimize_1.f90?ref=f1abbf6901a64919e61baf5ff60afa3679f1d086", "patch": "@@ -1,5 +1,5 @@\n ! { dg-do compile }\n-! { dg-options \"-O -fdump-tree-original -Warray-temporaries\" }\n+! { dg-options \"-O -fdump-tree-original -finline-matmul-limit=0 -Warray-temporaries\" }\n program main\n   implicit none\n   real, dimension(2,2) :: a, b, c, d"}, {"sha": "153270b5312ff809c5aa1edd8c7a13aa7a4f3a15", "filename": "gcc/testsuite/gfortran.dg/function_optimize_2.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1abbf6901a64919e61baf5ff60afa3679f1d086/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_optimize_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1abbf6901a64919e61baf5ff60afa3679f1d086/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_optimize_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_optimize_2.f90?ref=f1abbf6901a64919e61baf5ff60afa3679f1d086", "patch": "@@ -1,5 +1,5 @@\n ! { dg-do compile }\n-! { dg-options \"-O -faggressive-function-elimination -fdump-tree-original\" }\n+! { dg-options \"-O -finline-matmul-limit=0 -faggressive-function-elimination -fdump-tree-original\" }\n program main\n   implicit none\n   real, dimension(2,2) :: a, b, c, d"}, {"sha": "b563e932b1f94984f6f4289b6d47750aff32be57", "filename": "gcc/testsuite/gfortran.dg/function_optimize_5.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1abbf6901a64919e61baf5ff60afa3679f1d086/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_optimize_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1abbf6901a64919e61baf5ff60afa3679f1d086/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_optimize_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_optimize_5.f90?ref=f1abbf6901a64919e61baf5ff60afa3679f1d086", "patch": "@@ -1,5 +1,5 @@\n ! { dg-do compile }\n-! { dg-options \"-ffrontend-optimize -Wfunction-elimination\" }\n+! { dg-options \"-ffrontend-optimize -finline-matmul-limit=0 -Wfunction-elimination\" }\n ! Check the -ffrontend-optimize (in the absence of -O) and\n ! -Wfunction-elimination options.\n program main"}, {"sha": "115a5a66bbb84901002256e9be4b97a3f7fb8699", "filename": "gcc/testsuite/gfortran.dg/function_optimize_7.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1abbf6901a64919e61baf5ff60afa3679f1d086/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_optimize_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1abbf6901a64919e61baf5ff60afa3679f1d086/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_optimize_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_optimize_7.f90?ref=f1abbf6901a64919e61baf5ff60afa3679f1d086", "patch": "@@ -1,5 +1,5 @@\n ! { dg-do compile }\n-! { dg-options \"-O -fdump-tree-original -Warray-temporaries\" }\n+! { dg-options \"-O -fdump-tree-original -Warray-temporaries -finline-matmul-limit=0\" }\n subroutine xx(n, m, a, b, c, d, x, z, i, s_in, s_out)\n   implicit none\n   integer, intent(in) :: n, m"}, {"sha": "266aad073d4e8429a5ea6e5648737594e15b9b2c", "filename": "gcc/testsuite/gfortran.dg/inline_matmul_1.f90", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1abbf6901a64919e61baf5ff60afa3679f1d086/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_matmul_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1abbf6901a64919e61baf5ff60afa3679f1d086/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_matmul_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_matmul_1.f90?ref=f1abbf6901a64919e61baf5ff60afa3679f1d086", "patch": "@@ -0,0 +1,152 @@\n+! { dg-do  run }\n+! { dg-options \"-ffrontend-optimize -fdump-tree-original -Wrealloc-lhs\" }\n+! PR 37131 - check basic functionality of inlined matmul, making\n+! sure that the library is not called, with and without reallocation.\n+\n+program main\n+  implicit none\n+  integer, parameter :: offset = -2\n+  real, dimension(3,2) :: a\n+  real, dimension(2,4) :: b\n+  real, dimension(3,4) :: c\n+  real, dimension(3,4) :: cres\n+  real, dimension(:,:), allocatable :: c_alloc\n+  integer, parameter :: a1_lower_p = 1 + offset, a1_upper_p = size(a,1) + offset\n+  integer, parameter :: a2_lower_p = 1 + offset, a2_upper_p = size(a,2) + offset\n+  integer, parameter :: b1_lower_p = 1 + offset, b1_upper_p = size(b,1) + offset\n+  integer, parameter :: b2_lower_p = 1 + offset, b2_upper_p = size(b,2) + offset\n+  integer, parameter :: c1_lower_p = 1 + offset, c1_upper_p = size(c,1) + offset\n+  integer, parameter :: c2_lower_p = 1 + offset, c2_upper_p = size(c,2) + offset\n+  real, dimension(a1_lower_p:a1_upper_p, a2_lower_p:a2_upper_p) :: ap\n+  real, dimension(b1_lower_p:b1_upper_p, b2_lower_p:b2_upper_p) :: bp\n+  real, dimension(c1_lower_p:c1_upper_p, c2_lower_p:c2_upper_p) :: cp\n+  real, dimension(4,8,4) :: f, fresult\n+  integer :: eight = 8, two = 2\n+\n+  type foo\n+     real :: a\n+     integer :: i\n+  end type foo\n+\n+  type(foo), dimension(3,2) :: afoo\n+  type(foo), dimension(2,4) :: bfoo\n+  type(foo), dimension(3,4) :: cfoo\n+\n+  data a / 2.,  -3.,  5.,  -7., 11., -13./\n+  data b /17., -23., 29., -31., 37., -39., 41., -47./\n+  data cres /195., -304.,  384.,  275., -428.,  548.,  347., -540.,  692.,  411., -640.,  816./\n+  data fresult / &\n+   0.,   0., 195.,   0.,   0.,  17.,   0.,   0.,   0., -23.,-304.,   0.,   0.,   0.,   0.,   0., &\n+   0.,   0., 384.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0., &\n+   2.,   0., 275.,   0.,  -3.,  29.,   0.,   0.,   5., -31.,-428.,   0.,   0.,   0.,   0.,   0., &\n+   0.,   0., 548.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0., &\n+  -7.,   0., 347.,   0.,  11.,  37.,   0.,   0., -13., -39.,-540.,   0.,   0.,   0.,   0.,   0., &\n+   0.,   0., 692.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0., &\n+   0.,   0., 411.,   0.,   0.,  41.,   0.,   0.,   0., -47.,-640.,   0.,   0.,   0.,   0.,   0., &\n+   0.,   0., 816.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0./\n+\n+  integer :: a1 = size(a,1), a2 = size(a,2)\n+  integer :: b1 = size(b,1), b2 = size(b,2)\n+  integer :: c1 = size(c,1), c2 = size(c,2)\n+\n+  integer :: a1_lower, a1_upper, a2_lower, a2_upper\n+  integer :: b1_lower, b1_upper, b2_lower, b2_upper\n+  integer :: c1_lower, c1_upper, c2_lower, c2_upper\n+\n+  a1_lower = 1 + offset ; a1_upper = a1 + offset\n+  a2_lower = 1 + offset ; a2_upper = a2 + offset\n+  b1_lower = 1 + offset ; b1_upper = b1 + offset\n+  b2_lower = 1 + offset ; b2_upper = b2 + offset\n+  c1_lower = 1 + offset ; c1_upper = c1 + offset\n+  c2_lower = 1 + offset ; c2_upper = c2 + offset\n+\n+  c = matmul(a,b)\n+  if (sum(abs(c-cres))>1e-4) call abort\n+\n+  c_alloc = matmul(a,b)      ! { dg-warning \"Code for reallocating the allocatable array\" }\n+  if (sum(abs(c_alloc-cres))>1e-4) call abort\n+  if (any([size(c_alloc,1), size(c_alloc,2)] /= [3,4])) call abort\n+  deallocate(c_alloc)\n+\n+  allocate(c_alloc(4,4))\n+  c_alloc = matmul(a,b)      ! { dg-warning \"Code for reallocating the allocatable array\" }\n+  if (sum(abs(c_alloc-cres))>1e-4) call abort\n+  if (any([size(c_alloc,1), size(c_alloc,2)] /= [3,4])) call abort\n+  deallocate(c_alloc)\n+\n+  allocate(c_alloc(3,3))\n+  c_alloc = matmul(a,b)      ! { dg-warning \"Code for reallocating the allocatable array\" }\n+  if (sum(abs(c_alloc-cres))>1e-4) call abort\n+  if (any([size(c_alloc,1), size(c_alloc,2)] /= [3,4])) call abort\n+\n+  c_alloc = 42.\n+  c_alloc(:,:) = matmul(a,b)\n+  if (sum(abs(c_alloc-cres))>1e-4) call abort\n+  if (any([size(c_alloc,1), size(c_alloc,2)] /= [3,4])) call abort\n+\n+  deallocate(c_alloc)\n+  \n+  ap = a\n+  bp = b\n+  cp = matmul(ap, bp)\n+  if (sum(abs(cp-cres)) > 1e-4) call abort\n+\n+  f = 0\n+  f(1,1:3,2:3) = a\n+  f(2,2:3,:) = b\n+  c = matmul(f(1,1:3,2:3), f(2,2:3,:))\n+  if (sum(abs(c-cres))>1e-4) call abort\n+\n+  f(3,1:eight:2,:) = matmul(a, b)\n+  if (sum(abs(f(3,1:eight:2,:)-cres))>1e-4) call abort\n+\n+  afoo%a = a\n+  bfoo%a = b\n+  cfoo%a = matmul(afoo%a, bfoo%a)\n+\n+  if (sum(abs(cfoo%a-cres)) > 1e-4) call abort\n+\n+  block\n+    real :: aa(a1, a2), bb(b1, b2), cc(c1, c2)\n+    real :: am(a1_lower:a1_upper, a2_lower:a2_upper)\n+    real :: bm(b1_lower:b1_upper, b2_lower:b2_upper)\n+    real :: cm(c1_lower:c1_upper, c2_lower:c2_upper)\n+\n+    aa = a\n+    bb = b\n+    am = a\n+    bm = b\n+\n+    cc = matmul(aa,bb)\n+    if (sum(cc-cres)>1e-4) call abort\n+    c_alloc = matmul(aa,bb)    ! { dg-warning \"Code for reallocating the allocatable array\" }\n+    if (sum(abs(c_alloc-cres))>1e-4) call abort\n+    if (any([size(c_alloc,1), size(c_alloc,2)] /= [3,4])) call abort\n+    c_alloc = 42.\n+    deallocate(c_alloc)\n+\n+    allocate(c_alloc(4,4))\n+    c_alloc = matmul(aa,bb)   ! { dg-warning \"Code for reallocating the allocatable array\" }\n+    if (sum(abs(c_alloc-cres))>1e-4) call abort\n+    if (any([size(c_alloc,1), size(c_alloc,2)] /= [3,4])) call abort\n+    deallocate(c_alloc)\n+\n+    allocate(c_alloc(3,3))\n+    c_alloc = matmul(aa,bb)  ! { dg-warning \"Code for reallocating the allocatable array\" }\n+    if (sum(abs(c_alloc-cres))>1e-4) call abort\n+    if (any([size(c_alloc,1), size(c_alloc,2)] /= [3,4])) call abort\n+    deallocate(c_alloc)\n+\n+    cm = matmul(am, bm)\n+    if (sum(abs(cm-cres)) > 1e-4) call abort\n+\n+    cm = 42.\n+\n+    cm(:,:) = matmul(a,bm)\n+    if (sum(abs(cm-cres)) > 1e-4) call abort\n+\n+  end block\n+\n+end program main\n+\n+! { dg-final { scan-tree-dump-times \"_gfortran_matmul\" 0 \"original\" } }"}, {"sha": "6f56f65e0b08ffdf7181be22dc054daab61c39ae", "filename": "gcc/testsuite/gfortran.dg/inline_matmul_2.f90", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1abbf6901a64919e61baf5ff60afa3679f1d086/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_matmul_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1abbf6901a64919e61baf5ff60afa3679f1d086/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_matmul_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_matmul_2.f90?ref=f1abbf6901a64919e61baf5ff60afa3679f1d086", "patch": "@@ -0,0 +1,65 @@\n+! { dg-do compile }\n+! { dg-options \"-ffrontend-optimize -finline-matmul-limit=0 -fdump-tree-original\" }\n+! PR 37131 - no inlining with -finline-matmul-limit=0\n+program main\n+  real, dimension(3,2) :: a\n+  real, dimension(2,4) :: b\n+  real, dimension(3,4) :: c\n+  real, dimension(3,4) :: cres\n+  real, dimension(:,:), allocatable :: calloc\n+  integer :: a1 = size(a,1), a2 = size(a,2)\n+  integer :: b1 = size(b,1), b2 = size(b,2)\n+  integer :: c1 = size(c,1), c2 = size(c,2)\n+\n+  data a / 2.,  -3.,  5.,  -7., 11., -13./\n+  data b /17., -23., 29., -31., 37., -39., 41., -47./\n+  data cres /195., -304.,  384.,  275., -428.,  548.,  347., -540.,  692.,  411., -640.,  816./\n+  c = matmul(a,b)\n+  if (sum(c-cres)>1e-4) call abort\n+\n+  calloc = matmul(a,b)\n+  if (sum(calloc-cres)>1e-4) call abort\n+  if (any([size(calloc,1), size(calloc,2)] /= [3,4])) call abort\n+  deallocate(calloc)\n+\n+  allocate(calloc(4,4))\n+  calloc = matmul(a,b)\n+  if (sum(calloc-cres)>1e-4) call abort\n+  if (any([size(calloc,1), size(calloc,2)] /= [3,4])) call abort\n+  deallocate(calloc)\n+\n+  allocate(calloc(3,3))\n+  calloc = matmul(a,b)\n+  if (sum(calloc-cres)>1e-4) call abort\n+  if (any([size(calloc,1), size(calloc,2)] /= [3,4])) call abort\n+  deallocate(calloc)\n+  \n+  block\n+    real :: aa(a1, a2), bb(b1, b2), cc(c1, c2)\n+    aa = a\n+    bb = b\n+\n+    cc = matmul(aa,bb)\n+    if (sum(cc-cres)>1e-4) call abort\n+    calloc = matmul(aa,bb)\n+    if (sum(calloc-cres)>1e-4) call abort\n+    if (any([size(calloc,1), size(calloc,2)] /= [3,4])) call abort\n+    calloc = 42.\n+    deallocate(calloc)\n+\n+    allocate(calloc(4,4))\n+    calloc = matmul(aa,bb)\n+    if (sum(calloc-cres)>1e-4) call abort\n+    if (any([size(calloc,1), size(calloc,2)] /= [3,4])) call abort\n+    deallocate(calloc)\n+\n+    allocate(calloc(3,3))\n+    calloc = matmul(aa,bb)\n+    if (sum(calloc-cres)>1e-4) call abort\n+    if (any([size(calloc,1), size(calloc,2)] /= [3,4])) call abort\n+    deallocate(calloc)\n+  end block\n+\n+end program main\n+! { dg-final { scan-tree-dump-times \"_gfortran_matmul\" 8 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "4f00c1a292101d65bba452ec3a7f552b5aa748ca", "filename": "gcc/testsuite/gfortran.dg/inline_matmul_3.f90", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1abbf6901a64919e61baf5ff60afa3679f1d086/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_matmul_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1abbf6901a64919e61baf5ff60afa3679f1d086/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_matmul_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_matmul_3.f90?ref=f1abbf6901a64919e61baf5ff60afa3679f1d086", "patch": "@@ -0,0 +1,65 @@\n+! { dg-do  run }\n+! { dg-options \"-O3 -finline-matmul-limit=2 -fdump-tree-optimized\" }\n+! PR 37131 - all calls to matmul should be kept\n+program main\n+  real, dimension(3,2) :: a\n+  real, dimension(2,4) :: b\n+  real, dimension(3,4) :: c\n+  real, dimension(3,4) :: cres\n+  real, dimension(:,:), allocatable :: calloc\n+  integer :: a1 = size(a,1), a2 = size(a,2)\n+  integer :: b1 = size(b,1), b2 = size(b,2)\n+  integer :: c1 = size(c,1), c2 = size(c,2)\n+\n+  data a / 2.,  -3.,  5.,  -7., 11., -13./\n+  data b /17., -23., 29., -31., 37., -39., 41., -47./\n+  data cres /195., -304.,  384.,  275., -428.,  548.,  347., -540.,  692.,  411., -640.,  816./\n+  c = matmul(a,b)\n+  if (sum(c-cres)>1e-4) call abort\n+\n+  calloc = matmul(a,b)\n+  if (sum(calloc-cres)>1e-4) call abort\n+  if (any([size(calloc,1), size(calloc,2)] /= [3,4])) call abort\n+  deallocate(calloc)\n+\n+  allocate(calloc(4,4))\n+  calloc = matmul(a,b)\n+  if (sum(calloc-cres)>1e-4) call abort\n+  if (any([size(calloc,1), size(calloc,2)] /= [3,4])) call abort\n+  deallocate(calloc)\n+\n+  allocate(calloc(3,3))\n+  calloc = matmul(a,b)\n+  if (sum(calloc-cres)>1e-4) call abort\n+  if (any([size(calloc,1), size(calloc,2)] /= [3,4])) call abort\n+  deallocate(calloc)\n+  \n+  block\n+    real :: aa(a1, a2), bb(b1, b2), cc(c1, c2)\n+    aa = a\n+    bb = b\n+\n+    cc = matmul(aa,bb)\n+    if (sum(cc-cres)>1e-4) call abort\n+    calloc = matmul(aa,bb)\n+    if (sum(calloc-cres)>1e-4) call abort\n+    if (any([size(calloc,1), size(calloc,2)] /= [3,4])) call abort\n+    calloc = 42.\n+    deallocate(calloc)\n+\n+    allocate(calloc(4,4))\n+    calloc = matmul(aa,bb)\n+    if (sum(calloc-cres)>1e-4) call abort\n+    if (any([size(calloc,1), size(calloc,2)] /= [3,4])) call abort\n+    deallocate(calloc)\n+\n+    allocate(calloc(3,3))\n+    calloc = matmul(aa,bb)\n+    if (sum(calloc-cres)>1e-4) call abort\n+    if (any([size(calloc,1), size(calloc,2)] /= [3,4])) call abort\n+    deallocate(calloc)\n+  end block\n+\n+end program main\n+! { dg-final { scan-tree-dump-times \"_gfortran_matmul\" 8 \"optimized\" } }\n+! { dg-final { cleanup-tree-dump \"optimized\" } }"}, {"sha": "b2253b14daa66803b65f02e92f643ab89ba07adb", "filename": "gcc/testsuite/gfortran.dg/inline_matmul_4.f90", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1abbf6901a64919e61baf5ff60afa3679f1d086/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_matmul_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1abbf6901a64919e61baf5ff60afa3679f1d086/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_matmul_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_matmul_4.f90?ref=f1abbf6901a64919e61baf5ff60afa3679f1d086", "patch": "@@ -0,0 +1,68 @@\n+! { dg-do  run }\n+! { dg-options \"-O3 -finline-matmul-limit=10 -fdump-tree-optimized -fdump-tree-original\" }\n+! PR 37131 - all calls to matmul should be optimized away with -O3\n+! and the high limit.\n+program main\n+  real, dimension(3,2) :: a\n+  real, dimension(2,4) :: b\n+  real, dimension(3,4) :: c\n+  real, dimension(3,4) :: cres\n+  real, dimension(:,:), allocatable :: calloc\n+  integer :: a1 = size(a,1), a2 = size(a,2)\n+  integer :: b1 = size(b,1), b2 = size(b,2)\n+  integer :: c1 = size(c,1), c2 = size(c,2)\n+\n+  data a / 2.,  -3.,  5.,  -7., 11., -13./\n+  data b /17., -23., 29., -31., 37., -39., 41., -47./\n+  data cres /195., -304.,  384.,  275., -428.,  548.,  347., -540.,  692.,  411., -640.,  816./\n+  c = matmul(a,b)\n+  if (sum(c-cres)>1e-4) call abort\n+\n+  calloc = matmul(a,b)\n+  if (sum(calloc-cres)>1e-4) call abort\n+  if (any([size(calloc,1), size(calloc,2)] /= [3,4])) call abort\n+  deallocate(calloc)\n+\n+  allocate(calloc(4,4))\n+  calloc = matmul(a,b)\n+  if (sum(calloc-cres)>1e-4) call abort\n+  if (any([size(calloc,1), size(calloc,2)] /= [3,4])) call abort\n+  deallocate(calloc)\n+\n+  allocate(calloc(3,3))\n+  calloc = matmul(a,b)\n+  if (sum(calloc-cres)>1e-4) call abort\n+  if (any([size(calloc,1), size(calloc,2)] /= [3,4])) call abort\n+  deallocate(calloc)\n+  \n+  block\n+    real :: aa(a1, a2), bb(b1, b2), cc(c1, c2)\n+    aa = a\n+    bb = b\n+\n+    cc = matmul(aa,bb)\n+    if (sum(cc-cres)>1e-4) call abort\n+    calloc = matmul(aa,bb)\n+    if (sum(calloc-cres)>1e-4) call abort\n+    if (any([size(calloc,1), size(calloc,2)] /= [3,4])) call abort\n+    calloc = 42.\n+    deallocate(calloc)\n+\n+    allocate(calloc(4,4))\n+    calloc = matmul(aa,bb)\n+    if (sum(calloc-cres)>1e-4) call abort\n+    if (any([size(calloc,1), size(calloc,2)] /= [3,4])) call abort\n+    deallocate(calloc)\n+\n+    allocate(calloc(3,3))\n+    calloc = matmul(aa,bb)\n+    if (sum(calloc-cres)>1e-4) call abort\n+    if (any([size(calloc,1), size(calloc,2)] /= [3,4])) call abort\n+    deallocate(calloc)\n+  end block\n+\n+end program main\n+! { dg-final { scan-tree-dump-times \"_gfortran_matmul\" 4 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_matmul\" 0 \"optimized\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }\n+! { dg-final { cleanup-tree-dump \"optimized\" } }"}, {"sha": "bed1cb6a0afc946cb78e0ab3e7f86293fdaaf2e7", "filename": "gcc/testsuite/gfortran.dg/inline_matmul_5.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1abbf6901a64919e61baf5ff60afa3679f1d086/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_matmul_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1abbf6901a64919e61baf5ff60afa3679f1d086/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_matmul_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_matmul_5.f90?ref=f1abbf6901a64919e61baf5ff60afa3679f1d086", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do  run }\n+! { dg-options \"-ffrontend-optimize\" }\n+program main\n+\n+  real, dimension(2,2) :: a,b,c\n+\n+  data a /2., 4., 8., 16. /\n+  data b /3., 9., 27., 81./\n+\n+  c = matmul(a,b)\n+  a = matmul(a,b)\n+  if (any(a /= c)) call abort\n+end program main"}, {"sha": "54b0ecc230e8f92c1005ad93e1eefc558328e0cd", "filename": "gcc/testsuite/gfortran.dg/inline_matmul_6.f90", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1abbf6901a64919e61baf5ff60afa3679f1d086/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_matmul_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1abbf6901a64919e61baf5ff60afa3679f1d086/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_matmul_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_matmul_6.f90?ref=f1abbf6901a64919e61baf5ff60afa3679f1d086", "patch": "@@ -0,0 +1,49 @@\n+! { dg-do run }\n+! { dg-options \"-ffrontend-optimize -fdump-tree-original\" }\n+! PR 37131 - check rank1/rank2 and rank2/rank1 cases for inline matmul.\n+\n+module foo\n+  implicit none\n+contains\n+  subroutine a1b2(a,b,c)\n+    real, dimension(:), intent(in) :: a\n+    real, dimension(:,:), intent(in) :: b\n+    real, dimension(:), intent(out) :: c\n+\n+    c = matmul(a,b)\n+  end subroutine a1b2\n+\n+  subroutine a2b1(a,b,c)\n+    real, dimension(:,:), intent(in) :: a\n+    real, dimension(:), intent(in) :: b\n+    real, dimension(:), intent(out) :: c\n+\n+    c = matmul(a,b)\n+  end subroutine a2b1\n+end module foo\n+\n+program main\n+  use foo\n+  implicit none\n+  real, dimension(3) :: a1\n+  real, dimension(3,2) :: b1\n+  real, dimension(2) :: c1\n+\n+  real, dimension(3,2) :: a2\n+  real, dimension(2) :: b2\n+  real, dimension(3) :: c2\n+\n+  data a1 /17., -23., 29./\n+  data b1 / 2.,  -3.,  5.,  -7., 11., -13./\n+\n+  data b2/-2.,5./\n+\n+  a2 = -b1\n+  call a1b2(a1,b1,c1)\n+  if (any(abs(c1 - (/248., -749./)) > 1e-3)) call abort\n+  call a2b1(a2,b2,c2)\n+  if (any(abs(c2 - (/39., -61., 75./)) > 1e-3)) call abort\n+end program main\n+\n+! { dg-final { scan-tree-dump-times \"_gfortran_matmul\" 0 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}]}