{"sha": "86f0e17adccb1d1f127d6e489ac1cf7a3bb2f517", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODZmMGUxN2FkY2NiMWQxZjEyN2Q2ZTQ4OWFjMWNmN2EzYmIyZjUxNw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-10-24T09:19:15Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-10-24T09:19:15Z"}, "message": "2011-10-24  Sergey Rybin  <rybin@adacore.com frybin>\n\n\t* gnat_ugn.texi: For gnatelim, move the note about using the GNAT\n\tdriver for getting the project support into gnatelim section.\n\n2011-10-24  Robert Dewar  <dewar@adacore.com>\n\n\t* gnat_rm.texi: Minor correction to documentation on address\n\tclause.\n\n2011-10-24  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* s-finmas.adb (Attach): Synchronize and call the unprotected version.\n\t(Attach_Unprotected): New routine.\n\t(Delete_Finalize_Address): Removed.\n\t(Delete_Finalize_Address_Unprotected): New routine.\n\t(Detach): Synchronize and call the unprotected version.\n\t(Detach_Unprotected): Remove locking.\n\t(Finalize): Add various comment on synchronization. Lock the critical\n\tregion and call the unprotected versions of routines.\n\t(Finalize_Address): Removed.\n\t(Finalize_Address_Unprotected): New routine.\n\t(Set_Finalize_Address): Synchronize and call\n\tthe unprotected version.\n\t(Set_Finalize_Address_Unprotected): New routine.\n\t(Set_Heterogeneous_Finalize_Address): Removed.\n\t(Set_Heterogeneous_Finalize_Address_Unprotected): New routine.\n\t(Set_Is_Heterogeneous): Add comment on synchronization and\n\tlocking.\n\t* s-finmas.ads: Flag Finalization_Started is no longer atomic\n\tbecause synchronization uses task locking / unlocking.\n\t(Attach): Add comment on usage.\n\t(Attach_Unprotected): New routine.\n\t(Delete_Finalize_Address): Renamed to\n\tDelete_Finalize_Address_Unprotected.\n\t(Detach): Add comment on usage.\n\t(Detach_Unprotected): New routine.\n\t(Finalize_Address): Renamed to Finalize_Address_Unprotected.\n\t(Set_Finalize_Address): Add comment on usage.\n\t(Set_Finalize_Address_Unprotected): New routine.\n\t(Set_Heterogeneous_Finalize_Address): Renamed to\n\tSet_Heterogeneous_Finalize_Address_Unprotected.\n\t* s-stposu.adb (Allocate_Any_Controlled): Add local variable\n\tAllocation_Locked. Add various comments on synchronization. Lock\n\tthe critical region and call the unprotected version of\n\troutines.\n\t(Deallocate_Any_Controlled): Add various comments on\n\tsynchronization. Lock the critical region and call the unprotected\n\tversion of routines.\n\n2011-10-24  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch3.adb (Set_Fixed_Range): The bounds of a fixed point type\n\tare universal and must carry the corresponding type.\n\t* sem_eval.adb (Check_Non_Static_Context): If the type of the\n\texpression is universal real, as may be the case for a fixed point\n\texpression with constant operands in the context of a conversion,\n\tthere is nothing to check.\n\t* s-finmas.adb: Minor reformatting\n\nFrom-SVN: r180368", "tree": {"sha": "d89cf897a9a425f8c25bed513a2012ba82a689ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d89cf897a9a425f8c25bed513a2012ba82a689ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86f0e17adccb1d1f127d6e489ac1cf7a3bb2f517", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86f0e17adccb1d1f127d6e489ac1cf7a3bb2f517", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86f0e17adccb1d1f127d6e489ac1cf7a3bb2f517", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86f0e17adccb1d1f127d6e489ac1cf7a3bb2f517/comments", "author": null, "committer": null, "parents": [{"sha": "02b76a8d709b488c9de95820add27ef9d964aa92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02b76a8d709b488c9de95820add27ef9d964aa92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02b76a8d709b488c9de95820add27ef9d964aa92"}], "stats": {"total": 426, "additions": 301, "deletions": 125}, "files": [{"sha": "297470c39fdc77b1c9b0f237af89ee06b7572ff7", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86f0e17adccb1d1f127d6e489ac1cf7a3bb2f517/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86f0e17adccb1d1f127d6e489ac1cf7a3bb2f517/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=86f0e17adccb1d1f127d6e489ac1cf7a3bb2f517", "patch": "@@ -1,3 +1,63 @@\n+2011-10-24  Sergey Rybin  <rybin@adacore.com frybin>\n+\n+\t* gnat_ugn.texi: For gnatelim, move the note about using the GNAT\n+\tdriver for getting the project support into gnatelim section.\n+\n+2011-10-24  Robert Dewar  <dewar@adacore.com>\n+\n+\t* gnat_rm.texi: Minor correction to documentation on address\n+\tclause.\n+\n+2011-10-24  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* s-finmas.adb (Attach): Synchronize and call the unprotected version.\n+\t(Attach_Unprotected): New routine.\n+\t(Delete_Finalize_Address): Removed.\n+\t(Delete_Finalize_Address_Unprotected): New routine.\n+\t(Detach): Synchronize and call the unprotected version.\n+\t(Detach_Unprotected): Remove locking.\n+\t(Finalize): Add various comment on synchronization. Lock the critical\n+\tregion and call the unprotected versions of routines.\n+\t(Finalize_Address): Removed.\n+\t(Finalize_Address_Unprotected): New routine.\n+\t(Set_Finalize_Address): Synchronize and call\n+\tthe unprotected version.\n+\t(Set_Finalize_Address_Unprotected): New routine.\n+\t(Set_Heterogeneous_Finalize_Address): Removed.\n+\t(Set_Heterogeneous_Finalize_Address_Unprotected): New routine.\n+\t(Set_Is_Heterogeneous): Add comment on synchronization and\n+\tlocking.\n+\t* s-finmas.ads: Flag Finalization_Started is no longer atomic\n+\tbecause synchronization uses task locking / unlocking.\n+\t(Attach): Add comment on usage.\n+\t(Attach_Unprotected): New routine.\n+\t(Delete_Finalize_Address): Renamed to\n+\tDelete_Finalize_Address_Unprotected.\n+\t(Detach): Add comment on usage.\n+\t(Detach_Unprotected): New routine.\n+\t(Finalize_Address): Renamed to Finalize_Address_Unprotected.\n+\t(Set_Finalize_Address): Add comment on usage.\n+\t(Set_Finalize_Address_Unprotected): New routine.\n+\t(Set_Heterogeneous_Finalize_Address): Renamed to\n+\tSet_Heterogeneous_Finalize_Address_Unprotected.\n+\t* s-stposu.adb (Allocate_Any_Controlled): Add local variable\n+\tAllocation_Locked. Add various comments on synchronization. Lock\n+\tthe critical region and call the unprotected version of\n+\troutines.\n+\t(Deallocate_Any_Controlled): Add various comments on\n+\tsynchronization. Lock the critical region and call the unprotected\n+\tversion of routines.\n+\n+2011-10-24  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch3.adb (Set_Fixed_Range): The bounds of a fixed point type\n+\tare universal and must carry the corresponding type.\n+\t* sem_eval.adb (Check_Non_Static_Context): If the type of the\n+\texpression is universal real, as may be the case for a fixed point\n+\texpression with constant operands in the context of a conversion,\n+\tthere is nothing to check.\n+\t* s-finmas.adb: Minor reformatting\n+\n 2011-10-23  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (create_concat_name): Add explicit cast."}, {"sha": "24893911525f973991e825ef5c1077d63a5576f8", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86f0e17adccb1d1f127d6e489ac1cf7a3bb2f517/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86f0e17adccb1d1f127d6e489ac1cf7a3bb2f517/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=86f0e17adccb1d1f127d6e489ac1cf7a3bb2f517", "patch": "@@ -11925,9 +11925,7 @@ The type of the item is non-elementary (e.g.@: a record or array).\n \n @item\n There is explicit or implicit initialization required for the object.\n-Note that access values are always implicitly initialized, and also\n-in GNAT, certain bit-packed arrays (those having a dynamic length or\n-a length greater than 64) will also be implicitly initialized to zero.\n+Note that access values are always implicitly initialized.\n \n @item\n The address value is non-static.  Here GNAT is more permissive than the"}, {"sha": "377eb75bd1a39c15d4ba79769d3e2e4fc0b8f42d", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86f0e17adccb1d1f127d6e489ac1cf7a3bb2f517/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86f0e17adccb1d1f127d6e489ac1cf7a3bb2f517/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=86f0e17adccb1d1f127d6e489ac1cf7a3bb2f517", "patch": "@@ -10092,9 +10092,6 @@ and some of the techniques for making your program run faster.\n It then documents the @command{gnatelim} tool and unused subprogram/data\n elimination feature, which can reduce the size of program executables.\n \n-Note: to invoke @command{gnatelim} with a project file, use the @code{gnat}\n-driver (see @ref{The GNAT Driver and Project Files}).\n-\n @ifnottex\n @menu\n * Performance Considerations::\n@@ -11018,6 +11015,10 @@ indicate that the analysed set of sources is incomplete to make up a\n partition and that some subprogram bodies are missing are not generated.\n @end table\n \n+@noindent\n+Note: to invoke @command{gnatelim} with a project file, use the @code{gnat}\n+driver (see @ref{The GNAT Driver and Project Files}).\n+\n @node Processing Precompiled Libraries\n @subsection Processing Precompiled Libraries\n \n@@ -12832,6 +12833,7 @@ the configuration file describing the corresponding naming scheme;\n see the description of the @command{gnatpp}\n switches below. Another possibility is to use a project file and to\n call @command{gnatpp} through the @command{gnat} driver\n+(see @ref{The GNAT Driver and Project Files}).\n \n The @command{gnatpp} command has the form\n \n@@ -13959,7 +13961,7 @@ in files with names that do not follow the GNAT file naming rules, you have to\n provide the configuration file describing the corresponding naming scheme (see\n the description of the @command{gnatmetric} switches below.)\n Alternatively, you may use a project file and invoke @command{gnatmetric}\n-through the @command{gnat} driver.\n+through the @command{gnat} driver (see @ref{The GNAT Driver and Project Files}).\n \n The @command{gnatmetric} command has the form\n "}, {"sha": "8474ff4a8f3f0161138b55673782bd7f8e515b09", "filename": "gcc/ada/s-finmas.adb", "status": "modified", "additions": 110, "deletions": 59, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86f0e17adccb1d1f127d6e489ac1cf7a3bb2f517/gcc%2Fada%2Fs-finmas.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86f0e17adccb1d1f127d6e489ac1cf7a3bb2f517/gcc%2Fada%2Fs-finmas.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-finmas.adb?ref=86f0e17adccb1d1f127d6e489ac1cf7a3bb2f517", "patch": "@@ -77,18 +77,28 @@ package body System.Finalization_Masters is\n    procedure Attach (N : not null FM_Node_Ptr; L : not null FM_Node_Ptr) is\n    begin\n       Lock_Task.all;\n-\n-      L.Next.Prev := N;\n-      N.Next := L.Next;\n-      L.Next := N;\n-      N.Prev := L;\n-\n+      Attach_Unprotected (N, L);\n       Unlock_Task.all;\n \n       --  Note: No need to unlock in case of an exception because the above\n       --  code can never raise one.\n    end Attach;\n \n+   ------------------------\n+   -- Attach_Unprotected --\n+   ------------------------\n+\n+   procedure Attach_Unprotected\n+     (N : not null FM_Node_Ptr;\n+      L : not null FM_Node_Ptr)\n+   is\n+   begin\n+      L.Next.Prev := N;\n+      N.Next := L.Next;\n+      L.Next := N;\n+      N.Prev := L;\n+   end Attach_Unprotected;\n+\n    ---------------\n    -- Base_Pool --\n    ---------------\n@@ -100,37 +110,42 @@ package body System.Finalization_Masters is\n       return Master.Base_Pool;\n    end Base_Pool;\n \n-   -----------------------------\n-   -- Delete_Finalize_Address --\n-   -----------------------------\n+   -----------------------------------------\n+   -- Delete_Finalize_Address_Unprotected --\n+   -----------------------------------------\n \n-   procedure Delete_Finalize_Address (Obj : System.Address) is\n+   procedure Delete_Finalize_Address_Unprotected (Obj : System.Address) is\n    begin\n-      Lock_Task.all;\n       Finalize_Address_Table.Remove (Obj);\n-      Unlock_Task.all;\n-   end Delete_Finalize_Address;\n+   end Delete_Finalize_Address_Unprotected;\n \n    ------------\n    -- Detach --\n    ------------\n \n    procedure Detach (N : not null FM_Node_Ptr) is\n    begin\n-      if N.Prev /= null and then N.Next /= null then\n-         Lock_Task.all;\n+      Lock_Task.all;\n+      Detach_Unprotected (N);\n+      Unlock_Task.all;\n+\n+      --  Note: No need to unlock in case of an exception because the above\n+      --  code can never raise one.\n+   end Detach;\n \n+   ------------------------\n+   -- Detach_Unprotected --\n+   ------------------------\n+\n+   procedure Detach_Unprotected (N : not null FM_Node_Ptr) is\n+   begin\n+      if N.Prev /= null and then N.Next /= null then\n          N.Prev.Next := N.Next;\n          N.Next.Prev := N.Prev;\n          N.Prev := null;\n          N.Next := null;\n-\n-         Unlock_Task.all;\n-\n-         --  Note: No need to unlock in case of an exception because the above\n-         --  code can never raise one.\n       end if;\n-   end Detach;\n+   end Detach_Unprotected;\n \n    --------------\n    -- Finalize --\n@@ -158,10 +173,14 @@ package body System.Finalization_Masters is\n    --  Start of processing for Finalize\n \n    begin\n-      --  It is possible for multiple tasks to cause the finalization of the\n-      --  same master. Let only one task finalize the objects.\n+      Lock_Task.all;\n+\n+      --  Synchronization:\n+      --    Read  - allocation, finalization\n+      --    Write - finalization\n \n       if Master.Finalization_Started then\n+         Unlock_Task.all;\n          return;\n       end if;\n \n@@ -170,12 +189,19 @@ package body System.Finalization_Masters is\n       --  is explicitly deallocated or the associated access type is about to\n       --  go out of scope.\n \n+      --  Synchronization:\n+      --    Read  - allocation, finalization\n+      --    Write - finalization\n+\n       Master.Finalization_Started := True;\n \n       while not Is_Empty_List (Master.Objects'Unchecked_Access) loop\n          Curr_Ptr := Master.Objects.Next;\n \n-         Detach (Curr_Ptr);\n+         --  Synchronization:\n+         --    Write - allocation, deallocation, finalization\n+\n+         Detach_Unprotected (Curr_Ptr);\n \n          --  Skip the list header in order to offer proper object layout for\n          --  finalization.\n@@ -185,20 +211,28 @@ package body System.Finalization_Masters is\n          --  Retrieve TSS primitive Finalize_Address depending on the master's\n          --  mode of operation.\n \n+         --  Synchronization:\n+         --    Read  - allocation, finalization\n+         --    Write - outside\n+\n          if Master.Is_Homogeneous then\n+\n+            --  Synchronization:\n+            --    Read  - finalization\n+            --    Write - allocation, outside\n+\n             Cleanup := Master.Finalize_Address;\n-         else\n-            Cleanup := Finalize_Address (Obj_Addr);\n-         end if;\n \n-         --  If Finalize_Address is not available, then this is most likely an\n-         --  error in the expansion of the designated type or the allocator.\n+         else\n+            --  Synchronization:\n+            --    Read  - finalization\n+            --    Write - allocation, deallocation\n \n-         pragma Assert (Cleanup /= null);\n+            Cleanup := Finalize_Address_Unprotected (Obj_Addr);\n+         end if;\n \n          begin\n             Cleanup (Obj_Addr);\n-\n          exception\n             when Fin_Occur : others =>\n                if not Raised then\n@@ -210,11 +244,22 @@ package body System.Finalization_Masters is\n          --  When the master is a heterogeneous collection, destroy the object\n          --  - Finalize_Address pair since it is no longer needed.\n \n+         --  Synchronization:\n+         --    Read  - finalization\n+         --    Write - outside\n+\n          if not Master.Is_Homogeneous then\n-            Delete_Finalize_Address (Obj_Addr);\n+\n+            --  Synchronization:\n+            --    Read  - finalization\n+            --    Write - allocation, deallocation, finalization\n+\n+            Delete_Finalize_Address_Unprotected (Obj_Addr);\n          end if;\n       end loop;\n \n+      Unlock_Task.all;\n+\n       --  If the finalization of a particular object failed or Finalize_Address\n       --  was not set, reraise the exception now.\n \n@@ -234,20 +279,16 @@ package body System.Finalization_Masters is\n       return Master.Finalize_Address;\n    end Finalize_Address;\n \n-   ----------------------\n-   -- Finalize_Address --\n-   ----------------------\n+   ----------------------------------\n+   -- Finalize_Address_Unprotected --\n+   ----------------------------------\n \n-   function Finalize_Address\n+   function Finalize_Address_Unprotected\n      (Obj : System.Address) return Finalize_Address_Ptr\n    is\n-      Result : Finalize_Address_Ptr;\n    begin\n-      Lock_Task.all;\n-      Result := Finalize_Address_Table.Get (Obj);\n-      Unlock_Task.all;\n-      return Result;\n-   end Finalize_Address;\n+      return Finalize_Address_Table.Get (Obj);\n+   end Finalize_Address_Unprotected;\n \n    --------------------------\n    -- Finalization_Started --\n@@ -463,44 +504,54 @@ package body System.Finalization_Masters is\n       Fin_Addr_Ptr : Finalize_Address_Ptr)\n    is\n    begin\n-      --  TSS primitive Finalize_Address is set at the point of allocation,\n-      --  either through Allocate_Any_Controlled or through this routine.\n-      --  Since multiple tasks can allocate on the same finalization master,\n-      --  access to this attribute must be protected.\n+      --  Synchronization:\n+      --    Read  - finalization\n+      --    Write - allocation, outside\n \n       Lock_Task.all;\n+      Set_Finalize_Address_Unprotected (Master, Fin_Addr_Ptr);\n+      Unlock_Task.all;\n+   end Set_Finalize_Address;\n \n+   --------------------------------------\n+   -- Set_Finalize_Address_Unprotected --\n+   --------------------------------------\n+\n+   procedure Set_Finalize_Address_Unprotected\n+     (Master       : in out Finalization_Master;\n+      Fin_Addr_Ptr : Finalize_Address_Ptr)\n+   is\n+   begin\n       if Master.Finalize_Address = null then\n          Master.Finalize_Address := Fin_Addr_Ptr;\n       end if;\n+   end Set_Finalize_Address_Unprotected;\n \n-      Unlock_Task.all;\n-   end Set_Finalize_Address;\n-\n-   ----------------------------------------\n-   -- Set_Heterogeneous_Finalize_Address --\n-   ----------------------------------------\n+   ----------------------------------------------------\n+   -- Set_Heterogeneous_Finalize_Address_Unprotected --\n+   ----------------------------------------------------\n \n-   procedure Set_Heterogeneous_Finalize_Address\n+   procedure Set_Heterogeneous_Finalize_Address_Unprotected\n      (Obj          : System.Address;\n       Fin_Addr_Ptr : Finalize_Address_Ptr)\n    is\n    begin\n-      --  Protected access is required in this case because\n-      --  Finalize_Address_Table is a global data structure.\n-\n-      Lock_Task.all;\n       Finalize_Address_Table.Set (Obj, Fin_Addr_Ptr);\n-      Unlock_Task.all;\n-   end Set_Heterogeneous_Finalize_Address;\n+   end Set_Heterogeneous_Finalize_Address_Unprotected;\n \n    --------------------------\n    -- Set_Is_Heterogeneous --\n    --------------------------\n \n    procedure Set_Is_Heterogeneous (Master : in out Finalization_Master) is\n    begin\n+      --  Synchronization:\n+      --    Read  - finalization\n+      --    Write - outside\n+\n+      Lock_Task.all;\n       Master.Is_Homogeneous := False;\n+      Unlock_Task.all;\n    end Set_Is_Heterogeneous;\n \n end System.Finalization_Masters;"}, {"sha": "f0dd5b8767e1beffa7417f236c13b2b54522d0ce", "filename": "gcc/ada/s-finmas.ads", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86f0e17adccb1d1f127d6e489ac1cf7a3bb2f517/gcc%2Fada%2Fs-finmas.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86f0e17adccb1d1f127d6e489ac1cf7a3bb2f517/gcc%2Fada%2Fs-finmas.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-finmas.ads?ref=86f0e17adccb1d1f127d6e489ac1cf7a3bb2f517", "patch": "@@ -74,13 +74,23 @@ package System.Finalization_Masters is\n    for Finalization_Master_Ptr'Storage_Size use 0;\n \n    procedure Attach (N : not null FM_Node_Ptr; L : not null FM_Node_Ptr);\n+   --  Compiler interface, do not call from withing the run-time. Prepend a\n+   --  node to a specific finalization master.\n+\n+   procedure Attach_Unprotected\n+     (N : not null FM_Node_Ptr;\n+      L : not null FM_Node_Ptr);\n    --  Prepend a node to a specific finalization master\n \n-   procedure Delete_Finalize_Address (Obj : System.Address);\n+   procedure Delete_Finalize_Address_Unprotected (Obj : System.Address);\n    --  Destroy the relation pair object - Finalize_Address from the internal\n    --  hash table.\n \n    procedure Detach (N : not null FM_Node_Ptr);\n+   --  Compiler interface, do not call from within the run-time. Remove a node\n+   --  from an arbitrary finalization master.\n+\n+   procedure Detach_Unprotected (N : not null FM_Node_Ptr);\n    --  Remove a node from an arbitrary finalization master\n \n    overriding procedure Finalize (Master : in out Finalization_Master);\n@@ -93,7 +103,7 @@ package System.Finalization_Masters is\n    --  Return a reference to the TSS primitive Finalize_Address associated with\n    --  a master.\n \n-   function Finalize_Address\n+   function Finalize_Address_Unprotected\n      (Obj : System.Address) return Finalize_Address_Ptr;\n    --  Retrieve the Finalize_Address primitive associated with a particular\n    --  object.\n@@ -119,9 +129,15 @@ package System.Finalization_Masters is\n    procedure Set_Finalize_Address\n      (Master       : in out Finalization_Master;\n       Fin_Addr_Ptr : Finalize_Address_Ptr);\n+   --  Compiler interface, do not call from within the run-time. Set the clean\n+   --  up routine of a finalization master\n+\n+   procedure Set_Finalize_Address_Unprotected\n+     (Master       : in out Finalization_Master;\n+      Fin_Addr_Ptr : Finalize_Address_Ptr);\n    --  Set the clean up routine of a finalization master\n \n-   procedure Set_Heterogeneous_Finalize_Address\n+   procedure Set_Heterogeneous_Finalize_Address_Unprotected\n      (Obj          : System.Address;\n       Fin_Addr_Ptr : Finalize_Address_Ptr);\n    --  Add a relation pair object - Finalize_Address to the internal hash\n@@ -165,11 +181,9 @@ private\n       --  is used only when the master is in homogeneous mode.\n \n       Finalization_Started : Boolean := False;\n-      pragma Atomic (Finalization_Started);\n       --  A flag used to detect allocations which occur during the finalization\n       --  of a master. The allocations must raise Program_Error. This scenario\n-      --  may arise in a multitask environment. The flag is atomic because it\n-      --  is accessed without Lock_Task / Unlock_Task.\n+      --  may arise in a multitask environment.\n    end record;\n \n    --  Since RTSfind cannot contain names of the form RE_\"+\", the following"}, {"sha": "4bbff767d968847a2f6c804992fb67509ed905de", "filename": "gcc/ada/s-stposu.adb", "status": "modified", "additions": 53, "deletions": 12, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86f0e17adccb1d1f127d6e489ac1cf7a3bb2f517/gcc%2Fada%2Fs-stposu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86f0e17adccb1d1f127d6e489ac1cf7a3bb2f517/gcc%2Fada%2Fs-stposu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stposu.adb?ref=86f0e17adccb1d1f127d6e489ac1cf7a3bb2f517", "patch": "@@ -109,6 +109,9 @@ package body System.Storage_Pools.Subpools is\n       N_Size  : Storage_Count;\n       Subpool : Subpool_Handle := null;\n \n+      Allocation_Locked : Boolean;\n+      --  This flag stores the state of the associated collection\n+\n       Header_And_Padding : Storage_Offset;\n       --  This offset includes the size of a FM_Node plus any additional\n       --  padding due to a larger alignment.\n@@ -156,22 +159,22 @@ package body System.Storage_Pools.Subpools is\n          --  failed to create one. This is a serious error.\n \n          if Context_Master = null then\n-            raise Program_Error with \"missing master in pool allocation\";\n-         end if;\n+            raise Program_Error\n+              with \"missing master in pool allocation\";\n \n          --  If a subpool is present, then this is the result of erroneous\n          --  allocator expansion. This is not a serious error, but it should\n          --  still be detected.\n \n-         if Context_Subpool /= null then\n-            raise Program_Error with \"subpool not required in pool allocation\";\n-         end if;\n+         elsif Context_Subpool /= null then\n+            raise Program_Error\n+              with \"subpool not required in pool allocation\";\n \n          --  If the allocation is intended to be on a subpool, but the access\n          --  type's pool does not support subpools, then this is the result of\n          --  erroneous end-user code.\n \n-         if On_Subpool then\n+         elsif On_Subpool then\n             raise Program_Error\n               with \"pool of access type does not support subpools\";\n          end if;\n@@ -187,10 +190,18 @@ package body System.Storage_Pools.Subpools is\n \n       if Is_Controlled then\n \n+         --  Synchronization:\n+         --    Read  - allocation, finalization\n+         --    Write - finalization\n+\n+         Lock_Task.all;\n+         Allocation_Locked := Finalization_Started (Master.all);\n+         Unlock_Task.all;\n+\n          --  Do not allow the allocation of controlled objects while the\n          --  associated master is being finalized.\n \n-         if Finalization_Started (Master.all) then\n+         if Allocation_Locked then\n             raise Program_Error with \"allocation after finalization started\";\n          end if;\n \n@@ -240,6 +251,7 @@ package body System.Storage_Pools.Subpools is\n       --  Step 4: Attachment\n \n       if Is_Controlled then\n+         Lock_Task.all;\n \n          --  Map the allocated memory into a FM_Node record. This converts the\n          --  top of the allocated bits into a list header. If there is padding\n@@ -262,7 +274,10 @@ package body System.Storage_Pools.Subpools is\n \n          --  Prepend the allocated object to the finalization master\n \n-         Attach (N_Ptr, Objects (Master.all));\n+         --  Synchronization:\n+         --    Write - allocation, deallocation, finalization\n+\n+         Attach_Unprotected (N_Ptr, Objects (Master.all));\n \n          --  Move the address from the hidden list header to the start of the\n          --  object. This operation effectively hides the list header.\n@@ -275,19 +290,34 @@ package body System.Storage_Pools.Subpools is\n          --    2) Named access types\n          --    3) Most cases of anonymous access types usage\n \n+         --  Synchronization:\n+         --    Read  - allocation, finalization\n+         --    Write - outside\n+\n          if Master.Is_Homogeneous then\n-            Set_Finalize_Address (Master.all, Fin_Address);\n+\n+            --  Synchronization:\n+            --    Read  - finalization\n+            --    Write - allocation, outside\n+\n+            Set_Finalize_Address_Unprotected (Master.all, Fin_Address);\n \n          --  Heterogeneous masters service the following:\n \n          --    1) Allocations on / Deallocations from subpools\n          --    2) Certain cases of anonymous access types usage\n \n          else\n-            Set_Heterogeneous_Finalize_Address (Addr, Fin_Address);\n+            --  Synchronization:\n+            --    Read  - finalization\n+            --    Write - allocation, deallocation\n+\n+            Set_Heterogeneous_Finalize_Address_Unprotected (Addr, Fin_Address);\n             Finalize_Address_Table_In_Use := True;\n          end if;\n \n+         Unlock_Task.all;\n+\n       --  Non-controlled allocation\n \n       else\n@@ -341,12 +371,18 @@ package body System.Storage_Pools.Subpools is\n       --  Step 1: Detachment\n \n       if Is_Controlled then\n+         Lock_Task.all;\n \n          --  Destroy the relation pair object - Finalize_Address since it is no\n          --  longer needed.\n \n          if Finalize_Address_Table_In_Use then\n-            Delete_Finalize_Address (Addr);\n+\n+            --  Synchronization:\n+            --    Read  - finalization\n+            --    Write - allocation, deallocation\n+\n+            Delete_Finalize_Address_Unprotected (Addr);\n          end if;\n \n          --  Account for possible padding space before the header due to a\n@@ -376,7 +412,10 @@ package body System.Storage_Pools.Subpools is\n          --  action does not need to know the prior context used during\n          --  allocation.\n \n-         Detach (N_Ptr);\n+         --  Synchronization:\n+         --    Write - allocation, deallocation, finalization\n+\n+         Detach_Unprotected (N_Ptr);\n \n          --  Move the address from the object to the beginning of the list\n          --  header.\n@@ -388,6 +427,8 @@ package body System.Storage_Pools.Subpools is\n \n          N_Size := Storage_Size + Header_And_Padding;\n \n+         Unlock_Task.all;\n+\n       else\n          N_Addr := Addr;\n          N_Size := Storage_Size;"}, {"sha": "98169b276d1fb0e140ea355f8743f128b9bb9ecb", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86f0e17adccb1d1f127d6e489ac1cf7a3bb2f517/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86f0e17adccb1d1f127d6e489ac1cf7a3bb2f517/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=86f0e17adccb1d1f127d6e489ac1cf7a3bb2f517", "patch": "@@ -19570,17 +19570,16 @@ package body Sem_Ch3 is\n    --  do not know the exact end points at the time of the declaration. This\n    --  is true for three reasons:\n \n-   --     A size clause may affect the fudging of the end-points\n-   --     A small clause may affect the values of the end-points\n-   --     We try to include the end-points if it does not affect the size\n+   --     A size clause may affect the fudging of the end-points.\n+   --     A small clause may affect the values of the end-points.\n+   --     We try to include the end-points if it does not affect the size.\n \n-   --  This means that the actual end-points must be established at the point\n-   --  when the type is frozen. Meanwhile, we first narrow the range as\n-   --  permitted (so that it will fit if necessary in a small specified size),\n-   --  and then build a range subtree with these narrowed bounds.\n-\n-   --  Set_Fixed_Range constructs the range from real literal values, and sets\n-   --  the range as the Scalar_Range of the given fixed-point type entity.\n+   --  This means that the actual end-points must be established at the\n+   --  point when the type is frozen. Meanwhile, we first narrow the range\n+   --  as permitted (so that it will fit if necessary in a small specified\n+   --  size), and then build a range subtree with these narrowed bounds.\n+   --  Set_Fixed_Range constructs the range from real literal values, and\n+   --  sets the range as the Scalar_Range of the given fixed-point type entity.\n \n    --  The parent of this range is set to point to the entity so that it is\n    --  properly hooked into the tree (unlike normal Scalar_Range entries for\n@@ -19605,6 +19604,12 @@ package body Sem_Ch3 is\n    begin\n       Set_Scalar_Range (E, S);\n       Set_Parent (S, E);\n+\n+      --  Before the freeze point, the bounds of a fixed point are universal\n+      --  and carry the corresponding type.\n+\n+      Set_Etype (Low_Bound (S),  Universal_Real);\n+      Set_Etype (High_Bound (S), Universal_Real);\n    end Set_Fixed_Range;\n \n    ----------------------------------"}, {"sha": "64db8d634b621d579733363baf28159c4c0cbed1", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 36, "deletions": 31, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86f0e17adccb1d1f127d6e489ac1cf7a3bb2f517/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86f0e17adccb1d1f127d6e489ac1cf7a3bb2f517/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=86f0e17adccb1d1f127d6e489ac1cf7a3bb2f517", "patch": "@@ -250,27 +250,32 @@ package body Sem_Eval is\n                       and not Range_Checks_Suppressed (T);\n \n    begin\n-      --  Ignore cases of non-scalar types or error types\n+      --  Ignore cases of non-scalar types, error types, or universal real\n+      --  types that have no usable bounds.\n \n-      if T = Any_Type or else not Is_Scalar_Type (T) then\n+      if T = Any_Type\n+        or else not Is_Scalar_Type (T)\n+        or else T = Universal_Fixed\n+        or else T = Universal_Real\n+      then\n          return;\n       end if;\n \n-      --  At this stage we have a scalar type. If we have an expression\n-      --  that raises CE, then we already issued a warning or error msg\n-      --  so there is nothing more to be done in this routine.\n+      --  At this stage we have a scalar type. If we have an expression that\n+      --  raises CE, then we already issued a warning or error msg so there\n+      --  is nothing more to be done in this routine.\n \n       if Raises_Constraint_Error (N) then\n          return;\n       end if;\n \n-      --  Now we have a scalar type which is not marked as raising a\n-      --  constraint error exception. The main purpose of this routine\n-      --  is to deal with static expressions appearing in a non-static\n-      --  context. That means that if we do not have a static expression\n-      --  then there is not much to do. The one case that we deal with\n-      --  here is that if we have a floating-point value that is out of\n-      --  range, then we post a warning that an infinity will result.\n+      --  Now we have a scalar type which is not marked as raising a constraint\n+      --  error exception. The main purpose of this routine is to deal with\n+      --  static expressions appearing in a non-static context. That means\n+      --  that if we do not have a static expression then there is not much\n+      --  to do. The one case that we deal with here is that if we have a\n+      --  floating-point value that is out of range, then we post a warning\n+      --  that an infinity will result.\n \n       if not Is_Static_Expression (N) then\n          if Is_Floating_Point_Type (T)\n@@ -283,17 +288,17 @@ package body Sem_Eval is\n          return;\n       end if;\n \n-      --  Here we have the case of outer level static expression of\n-      --  scalar type, where the processing of this procedure is needed.\n+      --  Here we have the case of outer level static expression of scalar\n+      --  type, where the processing of this procedure is needed.\n \n       --  For real types, this is where we convert the value to a machine\n-      --  number (see RM 4.9(38)). Also see ACVC test C490001. We should\n-      --  only need to do this if the parent is a constant declaration,\n-      --  since in other cases, gigi should do the necessary conversion\n-      --  correctly, but experimentation shows that this is not the case\n-      --  on all machines, in particular if we do not convert all literals\n-      --  to machine values in non-static contexts, then ACVC test C490001\n-      --  fails on Sparc/Solaris and SGI/Irix.\n+      --  number (see RM 4.9(38)). Also see ACVC test C490001. We should only\n+      --  need to do this if the parent is a constant declaration, since in\n+      --  other cases, gigi should do the necessary conversion correctly, but\n+      --  experimentation shows that this is not the case on all machines, in\n+      --  particular if we do not convert all literals to machine values in\n+      --  non-static contexts, then ACVC test C490001 fails on Sparc/Solaris\n+      --  and SGI/Irix.\n \n       if Nkind (N) = N_Real_Literal\n         and then not Is_Machine_Number (N)\n@@ -320,12 +325,12 @@ package body Sem_Eval is\n \n          elsif not UR_Is_Zero (Realval (N)) then\n \n-            --  Note: even though RM 4.9(38) specifies biased rounding,\n-            --  this has been modified by AI-100 in order to prevent\n-            --  confusing differences in rounding between static and\n-            --  non-static expressions. AI-100 specifies that the effect\n-            --  of such rounding is implementation dependent, and in GNAT\n-            --  we round to nearest even to match the run-time behavior.\n+            --  Note: even though RM 4.9(38) specifies biased rounding, this\n+            --  has been modified by AI-100 in order to prevent confusing\n+            --  differences in rounding between static and non-static\n+            --  expressions. AI-100 specifies that the effect of such rounding\n+            --  is implementation dependent, and in GNAT we round to nearest\n+            --  even to match the run-time behavior.\n \n             Set_Realval\n               (N, Machine (Base_Type (T), Realval (N), Round_Even, N));\n@@ -455,10 +460,10 @@ package body Sem_Eval is\n       --  simple cases can be recognized.\n \n       function Is_Same_Value (L, R : Node_Id) return Boolean;\n-      --  Returns True iff L and R represent expressions that definitely\n-      --  have identical (but not necessarily compile time known) values\n-      --  Indeed the caller is expected to have already dealt with the\n-      --  cases of compile time known values, so these are not tested here.\n+      --  Returns True iff L and R represent expressions that definitely have\n+      --  identical (but not necessarily compile time known) values Indeed the\n+      --  caller is expected to have already dealt with the cases of compile\n+      --  time known values, so these are not tested here.\n \n       -----------------------\n       -- Compare_Decompose --"}]}