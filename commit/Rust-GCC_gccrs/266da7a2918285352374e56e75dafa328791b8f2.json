{"sha": "266da7a2918285352374e56e75dafa328791b8f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjY2ZGE3YTI5MTgyODUzNTIzNzRlNTZlNzVkYWZhMzI4NzkxYjhmMg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-02-14T22:47:54Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-02-14T22:47:54Z"}, "message": "invoke.texi (-mreg-alloc): Nuke.\n\n\t* invoke.texi (-mreg-alloc): Nuke.\n\t* i386.c (ix86_reg_alloc_order, regs_allocated,\n\torder_regs_for_local_alloc): Nuke.\n\t(override_options): Kill reg_alloc code.\n\t* i386.h (TARGET_OPTIONS): Kill reg-alloc.\n\t(REG_ALLOC_ORDER): SSE goes before I387.\n\t(ORDER_REGS_FOR_LOCAL_ALLOC): Kill.\n\t(ix86_reg_alloc_order): Likewise.\n\t* i386-protos.h (ix86_reg_alloc_order): Kill.\n\nFrom-SVN: r39697", "tree": {"sha": "c2151c630e23d84fe3662611ca9d41b0a1fd0928", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c2151c630e23d84fe3662611ca9d41b0a1fd0928"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/266da7a2918285352374e56e75dafa328791b8f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/266da7a2918285352374e56e75dafa328791b8f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/266da7a2918285352374e56e75dafa328791b8f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/266da7a2918285352374e56e75dafa328791b8f2/comments", "author": null, "committer": null, "parents": [{"sha": "121bc96b8a046913e125d89f9dee9879eec086a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/121bc96b8a046913e125d89f9dee9879eec086a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/121bc96b8a046913e125d89f9dee9879eec086a7"}], "stats": {"total": 139, "additions": 17, "deletions": 122}, "files": [{"sha": "a691a9578636173ad6e0cb6b8359656c76545d17", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/266da7a2918285352374e56e75dafa328791b8f2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/266da7a2918285352374e56e75dafa328791b8f2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=266da7a2918285352374e56e75dafa328791b8f2", "patch": "@@ -1,3 +1,15 @@\n+Wed Feb 14 12:37:37 CET 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* invoke.texi (-mreg-alloc): Nuke.\n+\t* i386.c (ix86_reg_alloc_order, regs_allocated,\n+\torder_regs_for_local_alloc): Nuke.\n+\t(override_options): Kill reg_alloc code.\n+\t* i386.h (TARGET_OPTIONS): Kill reg-alloc.\n+\t(REG_ALLOC_ORDER): SSE goes before I387.\n+\t(ORDER_REGS_FOR_LOCAL_ALLOC): Kill.\n+\t(ix86_reg_alloc_order): Likewise.\n+\t* i386-protos.h (ix86_reg_alloc_order): Kill.\n+\n 2001-02-14  Richard Henderson  <rth@redhat.com>\n \n \t* toplev.c (f_options): Clarify -fschedule-insns2 documentation."}, {"sha": "72ea6d99eaa66757be530d8d0f79ffb1546e7493", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/266da7a2918285352374e56e75dafa328791b8f2/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/266da7a2918285352374e56e75dafa328791b8f2/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=266da7a2918285352374e56e75dafa328791b8f2", "patch": "@@ -21,7 +21,6 @@ Boston, MA 02111-1307, USA. */\n \n /* Functions in i386.c */\n extern void override_options PARAMS ((void));\n-extern void order_regs_for_local_alloc PARAMS ((void));\n extern void optimization_options PARAMS ((int, int));\n \n extern int ix86_can_use_return_insn_p PARAMS ((void));"}, {"sha": "0333ce36e82320071edd1262e36bf551e65882ac", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 0, "deletions": 92, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/266da7a2918285352374e56e75dafa328791b8f2/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/266da7a2918285352374e56e75dafa328791b8f2/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=266da7a2918285352374e56e75dafa328791b8f2", "patch": "@@ -412,10 +412,6 @@ int ix86_arch;\n const char *ix86_cpu_string;\t\t/* for -mcpu=<xxx> */\n const char *ix86_arch_string;\t\t/* for -march=<xxx> */\n \n-/* Register allocation order */\n-const char *ix86_reg_alloc_order;\n-static char regs_allocated[FIRST_PSEUDO_REGISTER];\n-\n /* # of registers to use to pass arguments.  */\n const char *ix86_regparm_string;\n \n@@ -611,39 +607,6 @@ override_options ()\n   mark_machine_status = ix86_mark_machine_status;\n   free_machine_status = ix86_free_machine_status;\n \n-  /* Validate registers in register allocation order.  */\n-  if (ix86_reg_alloc_order)\n-    {\n-      int  ch;\n-\n-      for (i = 0; (ch = ix86_reg_alloc_order[i]) != '\\0'; i++)\n-\t{\n-\t  int regno = -1;\n-\n-\t  switch (ch)\n-\t    {\n-\t    case 'a':\tregno = 0;\tbreak;\n-\t    case 'd':\tregno = 1;\tbreak;\n-\t    case 'c':\tregno = 2;\tbreak;\n-\t    case 'b':\tregno = 3;\tbreak;\n-\t    case 'S':\tregno = 4;\tbreak;\n-\t    case 'D':\tregno = 5;\tbreak;\n-\t    case 'B':\tregno = 6;\tbreak;\n-\n-\t    default:\terror (\"Register '%c' is unknown\", ch);\n-\t    }\n-\n-\t  if (regno >= 0)\n-\t    {\n-\t      if (regs_allocated[regno])\n-\t\terror (\"Register '%c' already specified in allocation order\",\n-\t\t       ch);\n-\n-\t      regs_allocated[regno] = 1;\n-\t    }\n-\t}\n-    }\n-\n   /* Validate -mregparm= value.  */\n   if (ix86_regparm_string)\n     {\n@@ -726,61 +689,6 @@ override_options ()\n     target_flags |= MASK_MMX;\n }\n \f\n-/* A C statement (sans semicolon) to choose the order in which to\n-   allocate hard registers for pseudo-registers local to a basic\n-   block.\n-\n-   Store the desired register order in the array `reg_alloc_order'.\n-   Element 0 should be the register to allocate first; element 1, the\n-   next register; and so on.\n-\n-   The macro body should not assume anything about the contents of\n-   `reg_alloc_order' before execution of the macro.\n-\n-   On most machines, it is not necessary to define this macro.  */\n-\n-void\n-order_regs_for_local_alloc ()\n-{\n-  int i, ch, order;\n-\n-  /* User specified the register allocation order.  */\n-\n-  if (ix86_reg_alloc_order)\n-    {\n-      for (i = order = 0; (ch = ix86_reg_alloc_order[i]) != '\\0'; i++)\n-\t{\n-\t  int regno = 0;\n-\n-\t  switch (ch)\n-\t    {\n-\t    case 'a':\tregno = 0;\tbreak;\n-\t    case 'd':\tregno = 1;\tbreak;\n-\t    case 'c':\tregno = 2;\tbreak;\n-\t    case 'b':\tregno = 3;\tbreak;\n-\t    case 'S':\tregno = 4;\tbreak;\n-\t    case 'D':\tregno = 5;\tbreak;\n-\t    case 'B':\tregno = 6;\tbreak;\n-\t    }\n-\n-\t  reg_alloc_order[order++] = regno;\n-\t}\n-\n-      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t{\n-\t  if (! regs_allocated[i])\n-\t    reg_alloc_order[order++] = i;\n-\t}\n-    }\n-\n-  /* If user did not specify a register allocation order, use natural order.  */\n-  else\n-    {\n-      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\treg_alloc_order[i] = i;\n-    }\n-}\n-\f\n void\n optimization_options (level, size)\n      int level;"}, {"sha": "cab8511be0933d7c4d9023f78711d80606ed0d4f", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 4, "deletions": 20, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/266da7a2918285352374e56e75dafa328791b8f2/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/266da7a2918285352374e56e75dafa328791b8f2/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=266da7a2918285352374e56e75dafa328791b8f2", "patch": "@@ -366,8 +366,6 @@ extern int ix86_arch;\n     N_(\"Schedule code for given CPU\")},\t\t\t\t\\\n   { \"arch=\",\t\t&ix86_arch_string,\t\t\t\\\n     N_(\"Generate code for given CPU\")},\t\t\t\t\\\n-  { \"reg-alloc=\",\t&ix86_reg_alloc_order,\t\t\t\\\n-    N_(\"Control allocation order of integer registers\") },\t\\\n   { \"regparm=\",\t\t&ix86_regparm_string,\t\t\t\\\n     N_(\"Number of registers used to pass integer arguments\") },\t\\\n   { \"align-loops=\",\t&ix86_align_loops_string,\t\t\\\n@@ -717,30 +715,17 @@ extern int ix86_arch;\n    generated by allocating edx first, so restore the 'natural' order of things. */\n \n #define REG_ALLOC_ORDER \t\t\t\t\t\\\n-/*ax,dx,cx,bx,si,di,bp,sp,st,st1,st2,st3,st4,st5,st6,st7*/\t\\\n-{  0, 1, 2, 3, 4, 5, 6, 7, 8,  9, 10, 11, 12, 13, 14, 15,\t\\\n+/*ax,dx,cx,bx,si,di,bp,sp*/\t\t\t\t\t\\\n+{  0, 1, 2, 3, 4, 5, 6, 7,\t\t\t\t\t\\\n /*,arg,cc,fpsr,dir,frame*/\t\t\t\t\t\\\n      16,17, 18, 19,   20,\t\t\t\t\t\\\n /*xmm0,xmm1,xmm2,xmm3,xmm4,xmm5,xmm6,xmm7*/\t\t\t\\\n     21,  22,  23,  24,  25,  26,  27,  28,\t\t\t\\\n+/*st,st1,st2,st3,st4,st5,st6,st7*/\t\t\t\t\\\n+   8,  9, 10, 11, 12, 13, 14, 15,\t\t\t\t\\\n /*mmx0,mmx1,mmx2,mmx3,mmx4,mmx5,mmx6,mmx7*/\t\t\t\\\n     29,  30,  31,  32,  33,  34,  35,  36 }\n \n-/* A C statement (sans semicolon) to choose the order in which to\n-   allocate hard registers for pseudo-registers local to a basic\n-   block.\n-\n-   Store the desired register order in the array `reg_alloc_order'.\n-   Element 0 should be the register to allocate first; element 1, the\n-   next register; and so on.\n-\n-   The macro body should not assume anything about the contents of\n-   `reg_alloc_order' before execution of the macro.\n-\n-   On most machines, it is not necessary to define this macro.  */\n-\n-#define ORDER_REGS_FOR_LOCAL_ALLOC order_regs_for_local_alloc ()\n-\n /* Macro to conditionally modify fixed_regs/call_used_regs.  */\n #define CONDITIONAL_REGISTER_USAGE\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\t\\\n@@ -2897,7 +2882,6 @@ do { long l;\t\t\t\t\t\t\\\n /* Variables in i386.c */\n extern const char *ix86_cpu_string;\t\t/* for -mcpu=<xxx> */\n extern const char *ix86_arch_string;\t\t/* for -march=<xxx> */\n-extern const char *ix86_reg_alloc_order;\t/* register allocation order */\n extern const char *ix86_regparm_string;\t\t/* # registers to use to pass args */\n extern const char *ix86_align_loops_string;\t/* power of two alignment for loops */\n extern const char *ix86_align_jumps_string;\t/* power of two alignment for non-loop jumps */"}, {"sha": "7b1af1f99400d62db50d8601a48639b6a61954dd", "filename": "gcc/invoke.texi", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/266da7a2918285352374e56e75dafa328791b8f2/gcc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/266da7a2918285352374e56e75dafa328791b8f2/gcc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finvoke.texi?ref=266da7a2918285352374e56e75dafa328791b8f2", "patch": "@@ -457,12 +457,11 @@ in the following sections.\n -mintel-syntax -mieee-fp  -mno-fancy-math-387 @gol\n -mno-fp-ret-in-387  -msoft-float  -msvr3-shlib @gol\n -mno-wide-multiply  -mrtd  -malign-double @gol\n--mreg-alloc=@var{list}  -mregparm=@var{num} @gol\n -malign-jumps=@var{num}  -malign-loops=@var{num} @gol\n -malign-functions=@var{num} -mpreferred-stack-boundary=@var{num} @gol\n -mthreads -mno-align-stringops -minline-all-stringops @gol\n -mpush-args -maccumulate-outgoing-args -m128bit-long-double @gol\n--m96bit-long-double}\n+-m96bit-long-double} -mregparm=@var{num} @gol\n \n @emph{HPPA Options}\n @gccoptlist{\n@@ -6646,13 +6645,6 @@ In addition, seriously incorrect code will result if you call a\n function with too many arguments.  (Normally, extra arguments are\n harmlessly ignored.)\n \n-@item -mreg-alloc=@var{regs}\n-Control the default allocation order of integer registers.  The\n-string @var{regs} is a series of letters specifying a register.  The\n-supported letters are: @code{a} allocate EAX; @code{b} allocate EBX;\n-@code{c} allocate ECX; @code{d} allocate EDX; @code{S} allocate ESI;\n-@code{D} allocate EDI; @code{B} allocate EBP.\n-\n @item -mregparm=@var{num}\n Control how many registers are used to pass integer arguments.  By\n default, no registers are used to pass arguments, and at most 3"}]}