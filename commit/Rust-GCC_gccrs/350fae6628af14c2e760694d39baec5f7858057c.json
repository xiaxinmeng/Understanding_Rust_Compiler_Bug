{"sha": "350fae6628af14c2e760694d39baec5f7858057c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzUwZmFlNjYyOGFmMTRjMmU3NjA2OTRkMzliYWVjNWY3ODU4MDU3Yw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2004-06-26T21:11:23Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2004-06-26T21:11:23Z"}, "message": "c-common.c (c_safe_from_p, [...]): Deleted.\n\n2004-06-26  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n\n        * c-common.c (c_safe_from_p, c_walk_subtrees): Deleted.\n        * c-common.def (DECL_STMT): Remove.\n        * c-common.h (DECL_STMT_DECL): Deleted.\n        (COMPOUNT_LITERAL_EXPR_DECL): Use DECL_EXPR_DECL.\n        (c_safe_from_p, c_walk_subtrees): Deleted.\n        * c-decl.c, c-parse.in, c-pretty-print.c: DECL_STMT now DECL_EXPR.\n        * c-dump.c (c_dump_tree, case DECL_STMT): Deleted.\n        * c-gimplify.c (gimplify_decl_stmt): Deleted.\n        (gimplify_compound_literal_expr): Use DECL_EXPR_DECL\n        and gimplify_and_add.\n        (c_gimplify_expr, case DECL_EXPR): New case.\n        (c_gimplify_expr, case DECL_STMT): Deleted.\n        * c-lang.c (LANG_HOOKS_SAFE_FROM_P): Likewise.\n        (LANG_HOOKS_TREE_INLINING_WALK_SUBTREES): Likewise.\n        * expr.c (safe_from_p, case 's'): New case.\n        * gimplify.c (gimplify_decl_expr): New function.\n        (gimplify_expr, case DECL_EXPR): New case.\n        * tree-inline.c (walk_tree): Walk into all fields of a type and\n        decl only if they are in a DECL_EXPR.\n        (mark_local_for_remap_r): Minor code cleanup.\n        * tree-outof-ssa.c (discover_nonconstant_array_refs_r): Add else.\n        * tree.c (has_cleanups, case DECL_EXPR): New case.\n        * tree.def (DECL_EXPR): New code.\n        * tree.h (DECL_EXPR_DECL): New macro.\n\n        * objc/objc-lang.c (LANG_HOOKS_SAFE_FROM_P): Deleted.\n\nFrom-SVN: r83721", "tree": {"sha": "ec365de72a39a5ef2d0a252b8496e9199f69fb3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec365de72a39a5ef2d0a252b8496e9199f69fb3d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/350fae6628af14c2e760694d39baec5f7858057c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/350fae6628af14c2e760694d39baec5f7858057c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/350fae6628af14c2e760694d39baec5f7858057c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/350fae6628af14c2e760694d39baec5f7858057c/comments", "author": null, "committer": null, "parents": [{"sha": "6573a10434b3aa2784f052d6ffc3905d8490464e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6573a10434b3aa2784f052d6ffc3905d8490464e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6573a10434b3aa2784f052d6ffc3905d8490464e"}], "stats": {"total": 604, "additions": 270, "deletions": 334}, "files": [{"sha": "f48ac09fbdd05d8fa0272871c188375a1afa5e82", "filename": "gcc/c-common.c", "status": "modified", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=350fae6628af14c2e760694d39baec5f7858057c", "patch": "@@ -3718,28 +3718,6 @@ c_expand_expr (tree exp, rtx target, enum machine_mode tmode,\n     }\n }\n \n-/* Hook used by safe_from_p to handle language-specific tree codes.  */\n-\n-int\n-c_safe_from_p (rtx target, tree exp)\n-{\n-  /* We can see statements here when processing the body of a\n-     statement-expression.  For a declaration statement declaring a\n-     variable, look at the variable's initializer.  */\n-  if (TREE_CODE (exp) == DECL_STMT)\n-    {\n-      tree decl = DECL_STMT_DECL (exp);\n-\n-      if (TREE_CODE (decl) == VAR_DECL\n-\t  && DECL_INITIAL (decl)\n-\t  && !safe_from_p (target, DECL_INITIAL (decl), /*top_p=*/0))\n-\treturn 0;\n-    }\n-\n-  /* Assume everything else is safe.  */\n-  return 1;\n-}\n-\n /* Hook used by unsafe_for_reeval to handle language-specific tree codes.  */\n \n int\n@@ -5125,53 +5103,6 @@ check_function_arguments_recurse (void (*callback)\n   (*callback) (ctx, param, param_num);\n }\n \n-/* C implementation of lang_hooks.tree_inlining.walk_subtrees.  Tracks the\n-   locus from EXPR_LOCUS and handles DECL_STMT specially.  */\n-\n-tree \n-c_walk_subtrees (tree *tp, int *walk_subtrees_p ATTRIBUTE_UNUSED,\n-\t\t walk_tree_fn func, void *data, void *htab)\n-{\n-  enum tree_code code = TREE_CODE (*tp);\n-  location_t save_locus;\n-  tree result;\n-\n-#define WALK_SUBTREE(NODE)\t\t\t\t\\\n-  do\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      result = walk_tree (&(NODE), func, data, htab);\t\\\n-      if (result) goto out;\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-  if (code != DECL_STMT)\n-    return NULL_TREE;\n-\n-  /* Set input_location here so we get the right instantiation context\n-     if we call instantiate_decl from inlinable_function_p.  */\n-  save_locus = input_location;\n-  if (EXPR_LOCUS (*tp))\n-    input_location = *EXPR_LOCUS (*tp);\n-\n-  /* Walk the DECL_INITIAL and DECL_SIZE.  We don't want to walk\n-     into declarations that are just mentioned, rather than\n-     declared; they don't really belong to this part of the tree.\n-     And, we can see cycles: the initializer for a declaration can\n-     refer to the declaration itself.  */\n-  WALK_SUBTREE (DECL_INITIAL (DECL_STMT_DECL (*tp)));\n-  WALK_SUBTREE (DECL_SIZE (DECL_STMT_DECL (*tp)));\n-  WALK_SUBTREE (DECL_SIZE_UNIT (DECL_STMT_DECL (*tp)));\n-  WALK_SUBTREE (TREE_CHAIN (*tp));\n-  *walk_subtrees_p = 0;\n-\n-  /* We didn't find what we were looking for.  */\n- out:\n-  input_location = save_locus;\n-  return result;\n-\n-#undef WALK_SUBTREE\n-}\n-\n /* Function to help qsort sort FIELD_DECLs by name order.  */\n \n int"}, {"sha": "fa45ad0526a5ec149868f69df9893014819072e6", "filename": "gcc/c-common.def", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fc-common.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fc-common.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.def?ref=350fae6628af14c2e760694d39baec5f7858057c", "patch": "@@ -33,10 +33,6 @@ DEFTREECODE (ALIGNOF_EXPR, \"alignof_expr\", '1', 1)\n    obtain the expression.  */\n DEFTREECODE (EXPR_STMT, \"expr_stmt\", 'e', 1)\n \n-/* Used to represent a local declaration. The operand is\n-   DECL_STMT_DECL.  */\n-DEFTREECODE (DECL_STMT, \"decl_stmt\", 'e', 1)\n-\n /* Used to represent a `for' statement. The operands are\n    FOR_INIT_STMT, FOR_COND, FOR_EXPR, and FOR_BODY, respectively.  */\n DEFTREECODE (FOR_STMT, \"for_stmt\", 'e', 4)"}, {"sha": "454d4899237c172a49dd4872ab0d04416c0aa384", "filename": "gcc/c-common.h", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=350fae6628af14c2e760694d39baec5f7858057c", "patch": "@@ -733,10 +733,6 @@ extern void finish_file\t(void);\n \n #define SWITCH_TYPE(NODE)\tTREE_OPERAND (SWITCH_STMT_CHECK (NODE), 2)\n \n-/* DECL_STMT accessor. This gives access to the DECL associated with\n-   the given declaration statement.  */\n-#define DECL_STMT_DECL(NODE)    TREE_OPERAND (DECL_STMT_CHECK (NODE), 0)\n-\n /* STMT_EXPR accessor.  */\n #define STMT_EXPR_STMT(NODE)    TREE_OPERAND (STMT_EXPR_CHECK (NODE), 0)\n \n@@ -748,7 +744,7 @@ extern void finish_file\t(void);\n #define COMPOUND_LITERAL_EXPR_DECL_STMT(NODE)\t\t\\\n   TREE_OPERAND (COMPOUND_LITERAL_EXPR_CHECK (NODE), 0)\n #define COMPOUND_LITERAL_EXPR_DECL(NODE)\t\t\t\\\n-  DECL_STMT_DECL (COMPOUND_LITERAL_EXPR_DECL_STMT (NODE))\n+  DECL_EXPR_DECL (COMPOUND_LITERAL_EXPR_DECL_STMT (NODE))\n \n #define DEFTREECODE(SYM, NAME, TYPE, LENGTH) SYM,\n \n@@ -761,7 +757,7 @@ enum c_tree_code {\n #undef DEFTREECODE\n \n #define c_common_stmt_codes\t\t\t\t\\\n-   EXPR_STMT,\t\tDECL_STMT,\tFOR_STMT,\t\\\n+   EXPR_STMT,\t\tFOR_STMT,\t\t\t\\\n    WHILE_STMT,\t\tDO_STMT,\t\t\t\\\n    BREAK_STMT,\t\tCONTINUE_STMT,\tSWITCH_STMT\n \n@@ -844,8 +840,6 @@ extern int vector_types_convertible_p (tree t1, tree t2);\n \n extern rtx c_expand_expr (tree, rtx, enum machine_mode, int, rtx *);\n \n-extern int c_safe_from_p (rtx, tree);\n-\n extern int c_staticp (tree);\n \n extern int c_common_unsafe_for_reeval (tree);\n@@ -872,8 +866,6 @@ extern void dump_time_statistics (void);\n \n extern bool c_dump_tree (void *, tree);\n \n-extern tree c_walk_subtrees (tree*, int*, walk_tree_fn, void*, void*);\n-\n extern void c_warn_unused_result (tree *);\n \n extern void verify_sequence_points (tree);"}, {"sha": "4591ec95d7a954ba4be8136dfadb50987ec8b73b", "filename": "gcc/c-decl.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=350fae6628af14c2e760694d39baec5f7858057c", "patch": "@@ -2943,7 +2943,7 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n \t    }\n \n \t  if (TREE_CODE (decl) != FUNCTION_DECL)\n-\t    add_stmt (build_stmt (DECL_STMT, decl));\n+\t    add_stmt (build_stmt (DECL_EXPR, decl));\n \t}\n \n       if (!DECL_FILE_SCOPE_P (decl))\n@@ -2970,7 +2970,7 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n     {\n       if (!DECL_FILE_SCOPE_P (decl)\n \t  && variably_modified_type_p (TREE_TYPE (decl)))\n-\tadd_stmt (build_stmt (DECL_STMT, decl));\n+\tadd_stmt (build_stmt (DECL_EXPR, decl));\n \n       rest_of_decl_compilation (decl, NULL, DECL_FILE_SCOPE_P (decl), 0);\n     }\n@@ -3072,7 +3072,7 @@ build_compound_literal (tree type, tree init)\n {\n   /* We do not use start_decl here because we have a type, not a declarator;\n      and do not use finish_decl because the decl should be stored inside\n-     the COMPOUND_LITERAL_EXPR rather than added elsewhere as a DECL_STMT.  */\n+     the COMPOUND_LITERAL_EXPR rather than added elsewhere as a DECL_EXPR.  */\n   tree decl = build_decl (VAR_DECL, NULL_TREE, type);\n   tree complit;\n   tree stmt;\n@@ -3096,7 +3096,7 @@ build_compound_literal (tree type, tree init)\n   if (type == error_mark_node || !COMPLETE_TYPE_P (type))\n     return error_mark_node;\n \n-  stmt = build_stmt (DECL_STMT, decl);\n+  stmt = build_stmt (DECL_EXPR, decl);\n   complit = build1 (COMPOUND_LITERAL_EXPR, TREE_TYPE (decl), stmt);\n   TREE_SIDE_EFFECTS (complit) = 1;\n "}, {"sha": "73b973e235a80a90741749df82db1cb4a8151f1a", "filename": "gcc/c-dump.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fc-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fc-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-dump.c?ref=350fae6628af14c2e760694d39baec5f7858057c", "patch": "@@ -60,11 +60,6 @@ c_dump_tree (void *dump_info, tree t)\n       dump_stmt (di, t);\n       break;\n \n-    case DECL_STMT:\n-      dump_stmt (di, t);\n-      dump_child (\"decl\", DECL_STMT_DECL (t));\n-      break;\n-\n     case DO_STMT:\n       dump_stmt (di, t);\n       dump_child (\"body\", DO_BODY (t));"}, {"sha": "d899ba3593cf316721b67f408654ee6ddb6888b0", "filename": "gcc/c-gimplify.c", "status": "modified", "additions": 16, "deletions": 80, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fc-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fc-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-gimplify.c?ref=350fae6628af14c2e760694d39baec5f7858057c", "patch": "@@ -465,99 +465,25 @@ gimplify_switch_stmt (tree *stmt_p)\n   return GS_ALL_DONE;\n }\n \n-/* Gimplifies a DECL_STMT node *STMT_P by making any necessary allocation\n-   and initialization explicit.  */\n-\n-static enum gimplify_status\n-gimplify_decl_stmt (tree *stmt_p)\n-{\n-  tree stmt = *stmt_p;\n-  tree decl = DECL_STMT_DECL (stmt);\n-\n-  *stmt_p = NULL_TREE;\n-\n-  if (TREE_TYPE (decl) == error_mark_node)\n-    return GS_ERROR;\n-\n-  if (TREE_CODE (decl) == TYPE_DECL)\n-    gimplify_type_sizes (TREE_TYPE (decl), stmt_p);\n-\n-  else if (TREE_CODE (decl) == VAR_DECL && !DECL_EXTERNAL (decl))\n-    {\n-      tree init = DECL_INITIAL (decl);\n-\n-      if (!TREE_CONSTANT (DECL_SIZE (decl)))\n-\t{\n-\t  /* This is a variable-sized decl.  Simplify its size and mark it\n-\t     for deferred expansion.  Note that mudflap depends on the format\n-\t     of the emitted code: see mx_register_decls().  */\n-\n-\t  tree t, args;\n-\n-\t  gimplify_type_sizes (TREE_TYPE (decl), stmt_p);\n-\t  gimplify_one_sizepos (&DECL_SIZE (decl), stmt_p);\n-\t  gimplify_one_sizepos (&DECL_SIZE_UNIT (decl), stmt_p);\n-\n-\t  args = tree_cons (NULL, DECL_SIZE_UNIT (decl), NULL);\n-\t  t = build_fold_addr_expr (decl);\n-\t  args = tree_cons (NULL, t, args);\n-\t  t = implicit_built_in_decls[BUILT_IN_STACK_ALLOC];\n-\t  t = build_function_call_expr (t, args);\n-\n-\t  gimplify_and_add (t, stmt_p);\n-\t  DECL_DEFER_OUTPUT (decl) = 1;\n-\t}\n-\n-      if (init && init != error_mark_node)\n-\t{\n-\t  if (!TREE_STATIC (decl))\n-\t    {\n-              /* Do not warn about int x = x; as it is a GCC extension\n-                 to turn off this warning but only if warn_init_self\n-\t\t is zero.  */\n-              if (init == decl && !warn_init_self)\n-                TREE_NO_WARNING (decl) = 1;\n-              \n-\t      DECL_INITIAL (decl) = NULL_TREE;\n-\t      init = build (MODIFY_EXPR, void_type_node, decl, init);\n-\t      gimplify_and_add (init, stmt_p);\n-\t    }\n-\t  else\n-\t    /* We must still examine initializers for static variables\n-\t       as they may contain a label address.  */\n-\t    walk_tree (&init, force_labels_r, NULL, NULL);\n-\t}\n-\n-      /* This decl isn't mentioned in the enclosing block, so add it to the\n-\t list of temps.  FIXME it seems a bit of a kludge to say that\n-\t anonymous artificial vars aren't pushed, but everything else is.  */\n-      if (DECL_ARTIFICIAL (decl) && DECL_NAME (decl) == NULL_TREE)\n-\tgimple_add_tmp_var (decl);\n-    }\n-\n-  return GS_ALL_DONE;\n-}\n-\n /* Gimplification of expression trees.  */\n \n /* Gimplify a C99 compound literal expression.  This just means adding the\n-   DECL_STMT before the current EXPR_STMT and using its anonymous decl\n+   DECL_EXPR before the current EXPR_STMT and using its anonymous decl\n    instead.  */\n \n static enum gimplify_status\n gimplify_compound_literal_expr (tree *expr_p, tree *pre_p)\n {\n   tree decl_s = COMPOUND_LITERAL_EXPR_DECL_STMT (*expr_p);\n-  tree decl = DECL_STMT_DECL (decl_s);\n+  tree decl = DECL_EXPR_DECL (decl_s);\n \n   /* This decl isn't mentioned in the enclosing block, so add it to the\n      list of temps.  FIXME it seems a bit of a kludge to say that\n      anonymous artificial vars aren't pushed, but everything else is.  */\n   if (DECL_NAME (decl) == NULL_TREE)\n     gimple_add_tmp_var (decl);\n \n-  gimplify_decl_stmt (&decl_s);\n-  append_to_statement_list (decl_s, pre_p);\n+  gimplify_and_add (decl_s, pre_p);\n   *expr_p = decl;\n   return GS_OK;\n }\n@@ -571,6 +497,19 @@ c_gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p ATTRIBUTE_UNUSED)\n \n   switch (code)\n     {\n+    case DECL_EXPR:\n+      /* This is handled mostly by gimplify.c, but we have to deal with\n+\t not warning about int x = x; as it is a GCC extension to turn off\n+\t this warning but only if warn_init_self is zero.  */\n+      if (TREE_CODE (DECL_EXPR_DECL (*expr_p)) == VAR_DECL\n+\t  && !DECL_EXTERNAL (DECL_EXPR_DECL (*expr_p))\n+\t  && !TREE_STATIC (DECL_EXPR_DECL (*expr_p))\n+\t  && (DECL_INITIAL (DECL_EXPR_DECL (*expr_p))\n+\t      == DECL_EXPR_DECL (*expr_p))\n+\t  && !warn_init_self)\n+\tTREE_NO_WARNING (DECL_EXPR_DECL (*expr_p)) = 1;\n+      return GS_UNHANDLED;\n+      \n     case COMPOUND_LITERAL_EXPR:\n       return gimplify_compound_literal_expr (expr_p, pre_p);\n \n@@ -589,9 +528,6 @@ c_gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p ATTRIBUTE_UNUSED)\n     case EXPR_STMT:\n       return gimplify_expr_stmt (expr_p);\n \n-    case DECL_STMT:\n-      return gimplify_decl_stmt (expr_p);\n-\n     case CONTINUE_STMT:\n       *expr_p = build_bc_goto (bc_continue);\n       return GS_ALL_DONE;"}, {"sha": "03b05b26efa3c49dabdcc2e7884620dcadb60e67", "filename": "gcc/c-lang.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lang.c?ref=350fae6628af14c2e760694d39baec5f7858057c", "patch": "@@ -60,8 +60,6 @@ enum c_language_kind c_language = clk_c;\n #define LANG_HOOKS_POST_OPTIONS c_common_post_options\n #undef LANG_HOOKS_GET_ALIAS_SET\n #define LANG_HOOKS_GET_ALIAS_SET c_common_get_alias_set\n-#undef LANG_HOOKS_SAFE_FROM_P\n-#define LANG_HOOKS_SAFE_FROM_P c_safe_from_p\n #undef LANG_HOOKS_EXPAND_EXPR\n #define LANG_HOOKS_EXPAND_EXPR c_expand_expr\n #undef LANG_HOOKS_EXPAND_DECL\n@@ -103,9 +101,6 @@ enum c_language_kind c_language = clk_c;\n #undef LANG_HOOKS_FORMAT_ATTRIBUTE_TABLE\n #define LANG_HOOKS_FORMAT_ATTRIBUTE_TABLE c_common_format_attribute_table\n \n-#undef LANG_HOOKS_TREE_INLINING_WALK_SUBTREES\n-#define LANG_HOOKS_TREE_INLINING_WALK_SUBTREES \\\n-  c_walk_subtrees\n #undef LANG_HOOKS_TREE_INLINING_CANNOT_INLINE_TREE_FN\n #define LANG_HOOKS_TREE_INLINING_CANNOT_INLINE_TREE_FN \\\n   c_cannot_inline_tree_fn"}, {"sha": "9646827924573bf7858772d07291c2604cea3fae", "filename": "gcc/c-parse.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=350fae6628af14c2e760694d39baec5f7858057c", "patch": "@@ -1537,7 +1537,7 @@ nested_function:\n \t\t  add_stmt ($6);\n \t\t  finish_function ();\n \t\t  pop_function_context ();\n-\t\t  add_stmt (build_stmt (DECL_STMT, decl)); }\n+\t\t  add_stmt (build_stmt (DECL_EXPR, decl)); }\n \t;\n \n notype_nested_function:\n@@ -1567,7 +1567,7 @@ notype_nested_function:\n \t\t  add_stmt ($6);\n \t\t  finish_function ();\n \t\t  pop_function_context ();\n-\t\t  add_stmt (build_stmt (DECL_STMT, decl)); }\n+\t\t  add_stmt (build_stmt (DECL_EXPR, decl)); }\n \t;\n \n /* Any kind of declarator (thus, all declarators allowed\n@@ -2016,7 +2016,7 @@ label_decl:\n \t\t    {\n \t\t      tree label = declare_label (TREE_VALUE (link));\n \t\t      C_DECLARED_LABEL_FLAG (label) = 1;\n-\t\t      add_stmt (build_stmt (DECL_STMT, label));\n+\t\t      add_stmt (build_stmt (DECL_EXPR, label));\n \t\t    }\n \t\t}\n \t;"}, {"sha": "fd3ef82ac0270c6d1d55a2463bf2a7800713cbfe", "filename": "gcc/c-pretty-print.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pretty-print.c?ref=350fae6628af14c2e760694d39baec5f7858057c", "patch": "@@ -261,6 +261,13 @@ pp_c_pointer (c_pretty_printer *pp, tree t)\n       pp_c_type_qualifier_list (pp, t);\n       break;\n \n+      /* ??? This node is now in GENERIC and so shouldn't be here.  But\n+\t we'll fix that later.  */\n+    case DECL_EXPR:\n+      pp_declaration (pp, DECL_EXPR_DECL (t));\n+      pp_needs_newline (pp) = true;\n+      break;\n+\n     default:\n       pp_unsupported_tree (pp, t);\n     }\n@@ -1982,11 +1989,6 @@ pp_c_statement (c_pretty_printer *pp, tree stmt)\n       pp_needs_newline (pp) = true;\n       break;\n \n-    case DECL_STMT:\n-      pp_declaration (pp, DECL_STMT_DECL (stmt));\n-      pp_needs_newline (pp) = true;\n-      break;\n-\n     default:\n       dump_generic_node (pp_base (pp), stmt, pp_indentation (pp), 0, true);\n       break;"}, {"sha": "6812f8b86a3eed81eec9ea756161c58e1ca6c206", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=350fae6628af14c2e760694d39baec5f7858057c", "patch": "@@ -1,3 +1,11 @@\n+2004-06-26  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* call.c, cp-tree.h, cxx-pretty-print.c, decl.c, decl2.c:\n+\tRename DECL_STMT to DECL_EXPR.\n+\t* init.c, name-lookup.c, parser.c, pt.c, semantics.c: Likewise.\n+\t* cp-lang.c (LANG_HOOKS_SAFE_FROM_P): Deleted.\n+\t* tree.c (cp_walk_subtrees): Don't call c_walk_subtrees.\n+\n 2004-06-26  Jan Hubicka  <jh@suse.cz>\n \n \tPR C++/14865"}, {"sha": "5cbf808d8ece9b4bb32fd7321a2c8dd17d13439f", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=350fae6628af14c2e760694d39baec5f7858057c", "patch": "@@ -6468,7 +6468,7 @@ initialize_reference (tree type, tree expr, tree decl, tree *cleanup)\n \t  init = build (INIT_EXPR, type, var, expr);\n \t  if (at_function_scope_p ())\n \t    {\n-\t      add_decl_stmt (var);\n+\t      add_decl_expr (var);\n \t      *cleanup = cxx_maybe_build_cleanup (var);\n \n \t      /* We must be careful to destroy the temporary only"}, {"sha": "98b94581793e160a942448764bf353163dad3676", "filename": "gcc/cp/cp-lang.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fcp%2Fcp-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fcp%2Fcp-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-lang.c?ref=350fae6628af14c2e760694d39baec5f7858057c", "patch": "@@ -72,8 +72,6 @@ static void cxx_initialize_diagnostics (diagnostic_context *);\n #define LANG_HOOKS_EXPAND_EXPR cxx_expand_expr\n #undef LANG_HOOKS_EXPAND_DECL\n #define LANG_HOOKS_EXPAND_DECL c_expand_decl\n-#undef LANG_HOOKS_SAFE_FROM_P\n-#define LANG_HOOKS_SAFE_FROM_P c_safe_from_p\n #undef LANG_HOOKS_PARSE_FILE\n #define LANG_HOOKS_PARSE_FILE c_common_parse_file\n #undef LANG_HOOKS_DUP_LANG_SPECIFIC_DECL"}, {"sha": "f2ebb649988af6d8d7ff4a5bcc2e0a5073d44641", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=350fae6628af14c2e760694d39baec5f7858057c", "patch": "@@ -4147,7 +4147,7 @@ extern void pop_to_parent_deferring_access_checks\t(void);\n extern void perform_deferred_access_checks\t(void);\n extern void perform_or_defer_access_check\t(tree, tree);\n extern void init_cp_semantics                   (void);\n-extern void add_decl_stmt\t\t\t(tree);\n+extern void add_decl_expr\t\t\t(tree);\n extern tree finish_expr_stmt                    (tree);\n extern tree begin_if_stmt                       (void);\n extern void finish_if_stmt_cond                 (tree, tree);"}, {"sha": "c1337a925eabb3b0475c92277ad166947fbb3938", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=350fae6628af14c2e760694d39baec5f7858057c", "patch": "@@ -1446,7 +1446,7 @@ pp_cxx_template_argument_list (cxx_pretty_printer *pp, tree t)\n static void\n pp_cxx_exception_declaration (cxx_pretty_printer *pp, tree t)\n {\n-  t = DECL_STMT_DECL (t);\n+  t = DECL_EXPR_DECL (t);\n   pp_cxx_type_specifier_seq (pp, t);\n   if (TYPE_P (t))\n     pp_cxx_abstract_declarator (pp, t);"}, {"sha": "9d2aedb8123ba0bd1e1547dd6a8a56d1c6753088", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=350fae6628af14c2e760694d39baec5f7858057c", "patch": "@@ -3873,8 +3873,8 @@ grok_reference_init (tree decl, tree type, tree init, tree *cleanup)\n \n   /* Convert INIT to the reference type TYPE.  This may involve the\n      creation of a temporary, whose lifetime must be the same as that\n-     of the reference.  If so, a DECL_STMT for the temporary will be\n-     added just after the DECL_STMT for DECL.  That's why we don't set\n+     of the reference.  If so, a DECL_EXPR for the temporary will be\n+     added just after the DECL_EXPR for DECL.  That's why we don't set\n      DECL_INITIAL for local references (instead assigning to them\n      explicitly); we need to allow the temporary to be initialized\n      first.  */\n@@ -4527,7 +4527,7 @@ make_rtl_for_nonlocal_decl (tree decl, tree init, const char* asmspec)\n     return;\n \n   /* We defer emission of local statics until the corresponding\n-     DECL_STMT is expanded.  */\n+     DECL_EXPR is expanded.  */\n   defer_p = DECL_FUNCTION_SCOPE_P (decl) || DECL_VIRTUAL_P (decl);\n \n   /* We try to defer namespace-scope static constants so that they are\n@@ -4702,7 +4702,7 @@ cp_finish_decl (tree decl, tree init, tree asmspec_tree, int flags)\n     {\n       /* Add this declaration to the statement-tree.  */\n       if (at_function_scope_p ())\n-\tadd_decl_stmt (decl);\n+\tadd_decl_expr (decl);\n \n       if (init && DECL_INITIAL (decl))\n \tDECL_INITIAL (decl) = init;\n@@ -4808,10 +4808,10 @@ cp_finish_decl (tree decl, tree init, tree asmspec_tree, int flags)\n     }\n \n   /* Add this declaration to the statement-tree.  This needs to happen\n-     after the call to check_initializer so that the DECL_STMT for a\n-     reference temp is added before the DECL_STMT for the reference itself.  */\n+     after the call to check_initializer so that the DECL_EXPR for a\n+     reference temp is added before the DECL_EXPR for the reference itself.  */\n   if (at_function_scope_p ())\n-    add_decl_stmt (decl);\n+    add_decl_expr (decl);\n \n   if (TREE_CODE (decl) == VAR_DECL)\n     layout_var_decl (decl);"}, {"sha": "142bd4b7f871bf0fb4b23c6895eae404ac25fa90", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=350fae6628af14c2e760694d39baec5f7858057c", "patch": "@@ -1227,7 +1227,7 @@ finish_anon_union (tree anon_union_decl)\n   pushdecl (anon_union_decl);\n   if (building_stmt_tree ()\n       && at_function_scope_p ())\n-    add_decl_stmt (anon_union_decl);\n+    add_decl_expr (anon_union_decl);\n   else if (!processing_template_decl)\n     rest_of_decl_compilation (anon_union_decl, NULL,\n \t\t\t      toplevel_bindings_p (), at_eof);"}, {"sha": "425a853186dc3a843b6086299450da22c57b1a52", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=350fae6628af14c2e760694d39baec5f7858057c", "patch": "@@ -2360,7 +2360,7 @@ get_temp_regvar (tree type, tree init)\n   tree decl;\n \n   decl = create_temporary_var (type);\n-  add_decl_stmt (decl);\n+  add_decl_expr (decl);\n   \n   finish_expr_stmt (build_modify_expr (decl, INIT_EXPR, init));\n "}, {"sha": "b650d7443d1cd83e41328be7a93f44bf34597c89", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=350fae6628af14c2e760694d39baec5f7858057c", "patch": "@@ -2269,7 +2269,7 @@ do_local_using_decl (tree decl, tree scope, tree name)\n \n   if (building_stmt_tree ()\n       && at_function_scope_p ())\n-    add_decl_stmt (decl);\n+    add_decl_expr (decl);\n \n   oldval = lookup_name_current_level (name);\n   oldtype = lookup_type_current_level (name);"}, {"sha": "e6b1f9208155948b268c7d3f23c718617f3a2e31", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=350fae6628af14c2e760694d39baec5f7858057c", "patch": "@@ -10695,7 +10695,7 @@ cp_parser_init_declarator (cp_parser* parser,\n \n   /* Leave the SCOPE, now that we have processed the initializer.  It\n      is important to do this before calling cp_finish_decl because it\n-     makes decisions about whether to create DECL_STMTs or not based\n+     makes decisions about whether to create DECL_EXPRs or not based\n      on the current scope.  */\n   if (pop_p)\n     pop_scope (scope);"}, {"sha": "a1142f3b358402d7b2bde79f9af830e448d4d8ac", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=350fae6628af14c2e760694d39baec5f7858057c", "patch": "@@ -4587,7 +4587,7 @@ struct pair_fn_data\n /* Called from for_each_template_parm via walk_tree.  */\n \n static tree\n-for_each_template_parm_r (tree* tp, int* walk_subtrees, void* d)\n+for_each_template_parm_r (tree *tp, int *walk_subtrees, void *d)\n {\n   tree t = *tp;\n   struct pair_fn_data *pfd = (struct pair_fn_data *) d;\n@@ -7764,12 +7764,12 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t\t\t\t       args, complain, in_decl));\n       break;\n       \n-    case DECL_STMT:\n+    case DECL_EXPR:\n       {\n \ttree decl;\n \ttree init;\n \n-\tdecl = DECL_STMT_DECL (t);\n+\tdecl = DECL_EXPR_DECL (t);\n \tif (TREE_CODE (decl) == LABEL_DECL)\n \t  finish_label_decl (DECL_NAME (decl));\n \telse if (TREE_CODE (decl) == USING_DECL)\n@@ -7825,7 +7825,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t      }\n \t  }\n \n-\t/* A DECL_STMT can also be used as an expression, in the condition\n+\t/* A DECL_EXPR can also be used as an expression, in the condition\n \t   clause of an if/for/while construct.  */\n \treturn decl;\n       }"}, {"sha": "b48946072019964271972992199b3516b681b162", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=350fae6628af14c2e760694d39baec5f7858057c", "patch": "@@ -316,9 +316,9 @@ maybe_cleanup_point_expr (tree expr)\n /* Create a declaration statement for the declaration given by the DECL.  */\n \n void\n-add_decl_stmt (tree decl)\n+add_decl_expr (tree decl)\n {\n-  tree r = build_stmt (DECL_STMT, decl);\n+  tree r = build_stmt (DECL_EXPR, decl);\n   if (DECL_INITIAL (decl))\n     r = maybe_cleanup_point_expr (r);\n   add_stmt (r);\n@@ -382,7 +382,7 @@ push_cleanup (tree decl, tree cleanup, bool eh_only)\n /* Begin a conditional that might contain a declaration.  When generating\n    normal code, we want the declaration to appear before the statement\n    containing the conditional.  When generating template code, we want the\n-   conditional to be rendered as the raw DECL_STMT.  */\n+   conditional to be rendered as the raw DECL_EXPR.  */\n \n static void\n begin_cond (tree *cond_p)\n@@ -399,7 +399,7 @@ finish_cond (tree *cond_p, tree expr)\n   if (processing_template_decl)\n     {\n       tree cond = pop_stmt_list (*cond_p);\n-      if (TREE_CODE (cond) == DECL_STMT)\n+      if (TREE_CODE (cond) == DECL_EXPR)\n \texpr = cond;\n     }\n   *cond_p = expr;\n@@ -1141,7 +1141,7 @@ void\n finish_label_decl (tree name)\n {\n   tree decl = declare_local_label (name);\n-  add_decl_stmt (decl);\n+  add_decl_expr (decl);\n }\n \n /* When DECL goes out of scope, make sure that CLEANUP is executed.  */\n@@ -2950,10 +2950,10 @@ finalize_nrv_r (tree* tp, int* walk_subtrees, void* data)\n   else if (TREE_CODE (*tp) == CLEANUP_STMT\n \t   && CLEANUP_DECL (*tp) == dp->var)\n     CLEANUP_EH_ONLY (*tp) = 1;\n-  /* Replace the DECL_STMT for the NRV with an initialization of the\n+  /* Replace the DECL_EXPR for the NRV with an initialization of the\n      RESULT_DECL, if needed.  */\n-  else if (TREE_CODE (*tp) == DECL_STMT\n-\t   && DECL_STMT_DECL (*tp) == dp->var)\n+  else if (TREE_CODE (*tp) == DECL_EXPR\n+\t   && DECL_EXPR_DECL (*tp) == dp->var)\n     {\n       tree init;\n       if (DECL_INITIAL (dp->var)"}, {"sha": "4ae07798dee6800dea20f9ae41067a2f8f04203e", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=350fae6628af14c2e760694d39baec5f7858057c", "patch": "@@ -1962,14 +1962,11 @@ cp_build_type_attribute_variant (tree type, tree attributes)\n }\n \n /* Apply FUNC to all language-specific sub-trees of TP in a pre-order\n-   traversal.  Called from walk_tree().  */\n+   traversal.  Called from walk_tree.  */\n \n tree \n-cp_walk_subtrees (tree* tp, \n-                  int* walk_subtrees_p, \n-                  walk_tree_fn func, \n-                  void* data, \n-                  void* htab)\n+cp_walk_subtrees (tree *tp, int *walk_subtrees_p, walk_tree_fn func,\n+\t\t  void *data, void *htab)\n {\n   enum tree_code code = TREE_CODE (*tp);\n   location_t save_locus;\n@@ -2030,7 +2027,7 @@ cp_walk_subtrees (tree* tp,\n \n     default:\n       input_location = save_locus;\n-      return c_walk_subtrees (tp, walk_subtrees_p, func, data, htab);\n+      return NULL_TREE;\n     }\n \n   /* We didn't find what we were looking for.  */\n@@ -2201,7 +2198,7 @@ init_tree (void)\n   list_hash_table = htab_create_ggc (31, list_hash, list_hash_eq, NULL);\n }\n \n-/* Called via walk_tree.  If *TP points to a DECL_STMT for a local\n+/* Called via walk_tree.  If *TP points to a DECL_EXPR for a local\n    declaration, copies the declaration and enters it in the splay_tree\n    pointed to by DATA (which is really a `splay_tree *').  */\n \n@@ -2215,9 +2212,9 @@ mark_local_for_remap_r (tree* tp,\n   tree decl;\n \n   \n-  if (TREE_CODE (t) == DECL_STMT\n-      && nonstatic_local_decl_p (DECL_STMT_DECL (t)))\n-    decl = DECL_STMT_DECL (t);\n+  if (TREE_CODE (t) == DECL_EXPR\n+      && nonstatic_local_decl_p (DECL_EXPR_DECL (t)))\n+    decl = DECL_EXPR_DECL (t);\n   else if (TREE_CODE (t) == LABEL_EXPR)\n     decl = LABEL_EXPR_LABEL (t);\n   else if (TREE_CODE (t) == TARGET_EXPR"}, {"sha": "a92eab6f9d92c065417af099c3d83d6a723d1473", "filename": "gcc/expr.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=350fae6628af14c2e760694d39baec5f7858057c", "patch": "@@ -6002,6 +6002,14 @@ safe_from_p (rtx x, tree exp, int top_p)\n       else\n \treturn 0;\n \n+    case 's':\n+      /* The only case we look at here is the DECL_INITIAL inside a\n+\t DECL_EXPR.  */\n+      return (TREE_CODE (exp) != DECL_EXPR\n+\t      || TREE_CODE (DECL_EXPR_DECL (exp)) != VAR_DECL\n+\t      || !DECL_INITIAL (DECL_EXPR_DECL (exp))\n+\t      || safe_from_p (x, DECL_INITIAL (DECL_EXPR_DECL (exp)), 0));\n+\n     case '2':\n     case '<':\n       if (!safe_from_p (x, TREE_OPERAND (exp, 1), 0))"}, {"sha": "7ef88b565b303768e00a1329bfd08f8f6367206b", "filename": "gcc/gimplify.c", "status": "modified", "additions": 71, "deletions": 1, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=350fae6628af14c2e760694d39baec5f7858057c", "patch": "@@ -660,7 +660,7 @@ copy_if_shared_r (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n   /* Special-case BIND_EXPR.  We should never be copying these, therefore\n      we can omit examining BIND_EXPR_VARS.  Which also avoids problems with\n      double processing of the DECL_INITIAL, which could be seen via both\n-     the BIND_EXPR_VARS and a DECL_STMT.  */\n+     the BIND_EXPR_VARS and a DECL_EXPR.  */\n   else if (code == BIND_EXPR)\n     {\n       if (TREE_VISITED (t))\n@@ -1004,6 +1004,72 @@ gimplify_return_expr (tree stmt, tree *pre_p)\n   return GS_ALL_DONE;\n }\n \n+/* Gimplifies a DECL_EXPR node *STMT_P by making any necessary allocation\n+   and initialization explicit.  */\n+\n+static enum gimplify_status\n+gimplify_decl_expr (tree *stmt_p)\n+{\n+  tree stmt = *stmt_p;\n+  tree decl = DECL_EXPR_DECL (stmt);\n+\n+  *stmt_p = NULL_TREE;\n+\n+  if (TREE_TYPE (decl) == error_mark_node)\n+    return GS_ERROR;\n+\n+  else if (TREE_CODE (decl) == TYPE_DECL)\n+    gimplify_type_sizes (TREE_TYPE (decl), stmt_p);\n+\n+  else if (TREE_CODE (decl) == VAR_DECL && !DECL_EXTERNAL (decl))\n+    {\n+      tree init = DECL_INITIAL (decl);\n+\n+      if (!TREE_CONSTANT (DECL_SIZE (decl)))\n+\t{\n+\t  /* This is a variable-sized decl.  Simplify its size and mark it\n+\t     for deferred expansion.  Note that mudflap depends on the format\n+\t     of the emitted code: see mx_register_decls().  */\n+\t  tree t, args;\n+\n+\t  gimplify_type_sizes (TREE_TYPE (decl), stmt_p);\n+\t  gimplify_one_sizepos (&DECL_SIZE (decl), stmt_p);\n+\t  gimplify_one_sizepos (&DECL_SIZE_UNIT (decl), stmt_p);\n+\n+\t  args = tree_cons (NULL, DECL_SIZE_UNIT (decl), NULL);\n+\t  t = build_fold_addr_expr (decl);\n+\t  args = tree_cons (NULL, t, args);\n+\t  t = implicit_built_in_decls[BUILT_IN_STACK_ALLOC];\n+\t  t = build_function_call_expr (t, args);\n+\n+\t  gimplify_and_add (t, stmt_p);\n+\t  DECL_DEFER_OUTPUT (decl) = 1;\n+\t}\n+\n+      if (init && init != error_mark_node)\n+\t{\n+\t  if (!TREE_STATIC (decl))\n+\t    {\n+\t      DECL_INITIAL (decl) = NULL_TREE;\n+\t      init = build (MODIFY_EXPR, void_type_node, decl, init);\n+\t      gimplify_and_add (init, stmt_p);\n+\t    }\n+\t  else\n+\t    /* We must still examine initializers for static variables\n+\t       as they may contain a label address.  */\n+\t    walk_tree (&init, force_labels_r, NULL, NULL);\n+\t}\n+\n+      /* This decl isn't mentioned in the enclosing block, so add it to the\n+\t list of temps.  FIXME it seems a bit of a kludge to say that\n+\t anonymous artificial vars aren't pushed, but everything else is.  */\n+      if (DECL_ARTIFICIAL (decl) && DECL_NAME (decl) == NULL_TREE)\n+\tgimple_add_tmp_var (decl);\n+    }\n+\n+  return GS_ALL_DONE;\n+}\n+\n /* Gimplify a LOOP_EXPR.  Normally this just involves gimplifying the body\n    and replacing the LOOP_EXPR with goto, but if the loop contains an\n    EXIT_EXPR, we need to append a label for it to jump to.  */\n@@ -3521,6 +3587,10 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t  *expr_p = DECL_INITIAL (*expr_p);\n \t  break;\n \n+\tcase DECL_EXPR:\n+\t  ret = gimplify_decl_expr (expr_p);\n+\t  break;\n+\n \tcase EXC_PTR_EXPR:\n \t  /* FIXME make this a decl.  */\n \t  ret = GS_ALL_DONE;"}, {"sha": "aa0f388e84357b600f8acd6a7d3034edb26e855a", "filename": "gcc/objc/objc-lang.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fobjc%2Fobjc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Fobjc%2Fobjc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-lang.c?ref=350fae6628af14c2e760694d39baec5f7858057c", "patch": "@@ -53,8 +53,6 @@ enum c_language_kind c_language = clk_objc;\n #define LANG_HOOKS_POST_OPTIONS c_common_post_options\n #undef LANG_HOOKS_GET_ALIAS_SET\n #define LANG_HOOKS_GET_ALIAS_SET c_common_get_alias_set\n-#undef LANG_HOOKS_SAFE_FROM_P\n-#define LANG_HOOKS_SAFE_FROM_P c_safe_from_p\n #undef LANG_HOOKS_PARSE_FILE\n #define LANG_HOOKS_PARSE_FILE c_common_parse_file\n #undef LANG_HOOKS_CLEAR_BINDING_STACK"}, {"sha": "ac5256220bcd405810a026dda4df590a0d2c5861", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 105, "deletions": 106, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=350fae6628af14c2e760694d39baec5f7858057c", "patch": "@@ -2032,10 +2032,63 @@ walk_tree (tree *tp, walk_tree_fn func, void *data, void *htab_)\n   if (result || ! walk_subtrees)\n     return result;\n \n-  if (code != EXIT_BLOCK_EXPR\n-      && code != SAVE_EXPR\n-      && code != BIND_EXPR\n-      && IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (code)))\n+  /* If this is a DECL_EXPR, walk into various fields of the type or variable\n+     that it's defining.  We only want to walk into these fields of a decl\n+     or type in this case.\n+\n+     ??? Precisely which fields of types that we are supposed to walk in\n+     this case vs. the normal case aren't well defined.  */\n+  if (code == DECL_EXPR\n+      && TREE_CODE (DECL_EXPR_DECL (*tp)) != ERROR_MARK\n+      && TREE_CODE (TREE_TYPE (DECL_EXPR_DECL (*tp))) != ERROR_MARK)\n+    {\n+      tree decl = DECL_EXPR_DECL (*tp);\n+      tree type = TREE_TYPE (decl);\n+\n+      /* Walk into fields of the DECL if it's not a type, then into fields\n+\t of the type in both cases.  */\n+\n+      if (TREE_CODE (decl) != TYPE_DECL\n+\t  && TREE_CODE (decl) != FIELD_DECL && TREE_CODE (decl) != PARM_DECL)\n+\t{\n+\t  WALK_SUBTREE (DECL_INITIAL (decl));\n+\t  WALK_SUBTREE (DECL_SIZE (decl));\n+\t  WALK_SUBTREE (DECL_SIZE_UNIT (decl));\n+\t}\n+\n+      /* First do the common fields via recursion, then the fields we only\n+\t do when we are declaring the type or object.  */\n+      WALK_SUBTREE (type);\n+      WALK_SUBTREE (TYPE_SIZE (type));\n+      WALK_SUBTREE (TYPE_SIZE_UNIT (type));\n+\n+      /* If this is a record type, also walk the fields.  */\n+      if (TREE_CODE (type) == RECORD_TYPE || TREE_CODE (type) == UNION_TYPE\n+\t  || TREE_CODE (type) == QUAL_UNION_TYPE)\n+\t{\n+\t  tree field;\n+\n+\t  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+\t    {\n+\t      /* We'd like to look at the type of the field, but we can easily\n+\t\t get infinite recursion.  So assume it's pointed to elsewhere\n+\t\t in the tree.  Also, ignore things that aren't fields.  */\n+\t      if (TREE_CODE (field) != FIELD_DECL)\n+\t\tcontinue;\n+\n+\t      WALK_SUBTREE (DECL_FIELD_OFFSET (field));\n+\t      WALK_SUBTREE (DECL_SIZE (field));\n+\t      WALK_SUBTREE (DECL_SIZE_UNIT (field));\n+\t      if (TREE_CODE (type) == QUAL_UNION_TYPE)\n+\t\tWALK_SUBTREE (DECL_QUALIFIER (field));\n+\t    }\n+\t}\n+    }\n+\n+  else if (code != EXIT_BLOCK_EXPR\n+\t   && code != SAVE_EXPR\n+\t   && code != BIND_EXPR\n+\t   && IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (code)))\n     {\n       int i, len;\n \n@@ -2068,24 +2121,8 @@ walk_tree (tree *tp, walk_tree_fn func, void *data, void *htab_)\n #endif\n     }\n \n-  /* Look inside the sizes of decls, but we don't ever use the values for\n-     FIELD_DECL and RESULT_DECL, so ignore them.  */\n-  else if (TREE_CODE_CLASS (code) == 'd'\n-\t   && code != FIELD_DECL && code != RESULT_DECL)\n-    {\n-      WALK_SUBTREE (DECL_SIZE (*tp));\n-      WALK_SUBTREE (DECL_SIZE_UNIT (*tp));\n-      WALK_SUBTREE_TAIL (TREE_TYPE (*tp));\n-    }\n   else\n     {\n-      if (TREE_CODE_CLASS (code) == 't')\n-\t{\n-\t  WALK_SUBTREE (TYPE_SIZE (*tp));\n-\t  WALK_SUBTREE (TYPE_SIZE_UNIT (*tp));\n-\t  /* Also examine various special fields, below.  */\n-\t}\n-\n       /* Not one of the easy cases.  We must explicitly go through the\n \t children.  */\n       switch (code)\n@@ -2107,12 +2144,6 @@ walk_tree (tree *tp, walk_tree_fn func, void *data, void *htab_)\n \t     above.  */\n \t  break;\n \n-\tcase POINTER_TYPE:\n-\tcase REFERENCE_TYPE:\n-\tcase COMPLEX_TYPE:\n-\t  WALK_SUBTREE_TAIL (TREE_TYPE (*tp));\n-\t  break;\n-\n \tcase TREE_LIST:\n \t  WALK_SUBTREE (TREE_VALUE (*tp));\n \t  WALK_SUBTREE_TAIL (TREE_CHAIN (*tp));\n@@ -2140,6 +2171,44 @@ walk_tree (tree *tp, walk_tree_fn func, void *data, void *htab_)\n \tcase CONSTRUCTOR:\n \t  WALK_SUBTREE_TAIL (CONSTRUCTOR_ELTS (*tp));\n \n+\tcase EXIT_BLOCK_EXPR:\n+\t  WALK_SUBTREE_TAIL (TREE_OPERAND (*tp, 1));\n+\n+\tcase SAVE_EXPR:\n+\t  WALK_SUBTREE_TAIL (TREE_OPERAND (*tp, 0));\n+\n+\tcase BIND_EXPR:\n+\t  {\n+\t    tree decl;\n+\t    for (decl = BIND_EXPR_VARS (*tp); decl; decl = TREE_CHAIN (decl))\n+\t      {\n+\t\t/* Walk the DECL_INITIAL and DECL_SIZE.  We don't want to walk\n+\t\t   into declarations that are just mentioned, rather than\n+\t\t   declared; they don't really belong to this part of the tree.\n+\t\t   And, we can see cycles: the initializer for a declaration\n+\t\t   can refer to the declaration itself.  */\n+\t\tWALK_SUBTREE (DECL_INITIAL (decl));\n+\t\tWALK_SUBTREE (DECL_SIZE (decl));\n+\t\tWALK_SUBTREE (DECL_SIZE_UNIT (decl));\n+\t\tWALK_SUBTREE (TREE_TYPE (decl));\n+\t      }\n+\t    WALK_SUBTREE_TAIL (BIND_EXPR_BODY (*tp));\n+\t  }\n+\n+\tcase STATEMENT_LIST:\n+\t  {\n+\t    tree_stmt_iterator i;\n+\t    for (i = tsi_start (*tp); !tsi_end_p (i); tsi_next (&i))\n+\t      WALK_SUBTREE (*tsi_stmt_ptr (i));\n+\t  }\n+\t  break;\n+\n+\tcase POINTER_TYPE:\n+\tcase REFERENCE_TYPE:\n+\tcase COMPLEX_TYPE:\n+\t  WALK_SUBTREE_TAIL (TREE_TYPE (*tp));\n+\t  break;\n+\n \tcase METHOD_TYPE:\n \t  WALK_SUBTREE (TYPE_METHOD_BASETYPE (*tp));\n \n@@ -2148,38 +2217,14 @@ walk_tree (tree *tp, walk_tree_fn func, void *data, void *htab_)\n \tcase FUNCTION_TYPE:\n \t  WALK_SUBTREE (TREE_TYPE (*tp));\n \t  {\n-\t    tree arg = TYPE_ARG_TYPES (*tp);\n+\t    tree arg;\n \n \t    /* We never want to walk into default arguments.  */\n-\t    for (; arg; arg = TREE_CHAIN (arg))\n+\t    for (arg = TYPE_ARG_TYPES (*tp); arg; arg = TREE_CHAIN (arg))\n \t      WALK_SUBTREE (TREE_VALUE (arg));\n \t  }\n \t  break;\n \n-\tcase RECORD_TYPE:\n-\tcase UNION_TYPE:\n-\tcase QUAL_UNION_TYPE:\n-\t  {\n-\t    tree field;\n-\n-\t    for (field = TYPE_FIELDS (*tp); field; field = TREE_CHAIN (field))\n-\t      {\n-\t\t/* We would like to look at the type of the field, but we\n-\t\t   can easily get infinite recursion.  So assume it's\n-\t\t   pointed to elsewhere in the tree.  Also, ignore things that\n-\t\t   aren't fields.  */\n-\t\tif (TREE_CODE (field) != FIELD_DECL)\n-\t\t  continue;\n-\n-\t\tWALK_SUBTREE (DECL_FIELD_OFFSET (field));\n-\t\tWALK_SUBTREE (DECL_SIZE (field));\n-\t\tWALK_SUBTREE (DECL_SIZE_UNIT (field));\n-\t\tif (code == QUAL_UNION_TYPE)\n-\t\t  WALK_SUBTREE (DECL_QUALIFIER (field));\n-\t      }\n-\t  }\n-\t  break;\n-\n \tcase ARRAY_TYPE:\n \t  /* Don't follow this nodes's type if a pointer for fear that we'll\n \t     have infinite recursion.  Those types are uninteresting anyway. */\n@@ -2200,38 +2245,6 @@ walk_tree (tree *tp, walk_tree_fn func, void *data, void *htab_)\n \t  WALK_SUBTREE (TREE_TYPE (*tp));\n \t  WALK_SUBTREE_TAIL (TYPE_OFFSET_BASETYPE (*tp));\n \n-\tcase EXIT_BLOCK_EXPR:\n-\t  WALK_SUBTREE_TAIL (TREE_OPERAND (*tp, 1));\n-\n-\tcase SAVE_EXPR:\n-\t  WALK_SUBTREE_TAIL (TREE_OPERAND (*tp, 0));\n-\n-\tcase BIND_EXPR:\n-\t  {\n-\t    tree decl;\n-\t    for (decl = BIND_EXPR_VARS (*tp); decl; decl = TREE_CHAIN (decl))\n-\t      {\n-\t\t/* Walk the DECL_INITIAL and DECL_SIZE.  We don't want to walk\n-\t\t   into declarations that are just mentioned, rather than\n-\t\t   declared; they don't really belong to this part of the tree.\n-\t\t   And, we can see cycles: the initializer for a declaration\n-\t\t   can refer to the declaration itself.  */\n-\t\tWALK_SUBTREE (DECL_INITIAL (decl));\n-\t\tWALK_SUBTREE (DECL_SIZE (decl));\n-\t\tWALK_SUBTREE (DECL_SIZE_UNIT (decl));\n-\t\tWALK_SUBTREE (TREE_TYPE (decl));\n-\t      }\n-\t    WALK_SUBTREE_TAIL (BIND_EXPR_BODY (*tp));\n-\t  }\n-\n-\tcase STATEMENT_LIST:\n-\t  {\n-\t    tree_stmt_iterator i;\n-\t    for (i = tsi_start (*tp); !tsi_end_p (i); tsi_next (&i))\n-\t      WALK_SUBTREE (*tsi_stmt_ptr (i));\n-\t  }\n-\t  break;\n-\n \tdefault:\n \t  /* ??? This could be a language-defined node.  We really should make\n \t     a hook for it, but right now just ignore it.  */\n@@ -2358,34 +2371,20 @@ static tree\n mark_local_for_remap_r (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n \t\t\tvoid *data)\n {\n-  tree t = *tp;\n   inline_data *id = (inline_data *) data;\n-  tree decl;\n \n   /* Don't walk into types.  */\n-  if (TYPE_P (t))\n-    {\n-      *walk_subtrees = 0;\n-      return NULL_TREE;\n-    }\n-\n-  if (TREE_CODE (t) == LABEL_EXPR)\n-    decl = TREE_OPERAND (t, 0);\n-  else\n-    /* We don't need to handle anything else ahead of time.  */\n-    decl = NULL_TREE;\n+  if (TYPE_P (*tp))\n+    *walk_subtrees = 0;\n \n-  if (decl)\n+  else if (TREE_CODE (*tp) == LABEL_EXPR)\n     {\n-      tree copy;\n-\n-      /* Make a copy.  */\n-      copy = copy_decl_for_inlining (decl, \n-\t\t\t\t     DECL_CONTEXT (decl), \n-\t\t\t\t     DECL_CONTEXT (decl));\n+      tree decl = TREE_OPERAND (*tp, 0);\n \n-      /* Remember the copy.  */\n-      insert_decl_map (id, decl, copy);\n+      /* Copy the decl and remember the copy.  */\n+      insert_decl_map (id, decl,\n+\t\t       copy_decl_for_inlining (decl, DECL_CONTEXT (decl), \n+\t\t\t\t\t       DECL_CONTEXT (decl)));\n     }\n \n   return NULL_TREE;"}, {"sha": "d1899981c1f0881e9e351f3de5616608dc42c39f", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=350fae6628af14c2e760694d39baec5f7858057c", "patch": "@@ -1763,7 +1763,7 @@ discover_nonconstant_array_refs_r (tree * tp, int *walk_subtrees,\n \n   if (TYPE_P (t) || DECL_P (t))\n     *walk_subtrees = 0;\n-  if (TREE_CODE (t) == ARRAY_REF || TREE_CODE (t) == ARRAY_RANGE_REF)\n+  else if (TREE_CODE (t) == ARRAY_REF || TREE_CODE (t) == ARRAY_RANGE_REF)\n     {\n       while (((TREE_CODE (t) == ARRAY_REF || TREE_CODE (t) == ARRAY_RANGE_REF)\n \t      && is_gimple_min_invariant (TREE_OPERAND (t, 1))"}, {"sha": "e0a1c46ea36020ceba135f7c0fb6ca3254037b83", "filename": "gcc/tree.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=350fae6628af14c2e760694d39baec5f7858057c", "patch": "@@ -1856,6 +1856,10 @@ has_cleanups (tree exp)\n \t}\n       return 0;\n \n+    case DECL_EXPR:\n+      return (DECL_INITIAL (DECL_EXPR_DECL (exp))\n+\t      && has_cleanups (DECL_INITIAL (DECL_EXPR_DECL (exp))));\n+\n     default:\n       break;\n     }"}, {"sha": "422817d3215e4380c0fc395382e888c48220ed08", "filename": "gcc/tree.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=350fae6628af14c2e760694d39baec5f7858057c", "patch": "@@ -805,6 +805,9 @@ DEFTREECODE (TRY_FINALLY_EXPR, \"try_finally\", 's', 2)\n /* These types of expressions have no useful value,\n    and always have side effects.  */\n \n+/* Used to represent a local declaration. The operand is DECL_EXPR_DECL.  */\n+DEFTREECODE (DECL_EXPR, \"decl_expr\", 's', 1)\n+\n /* A label definition, encapsulated as a statement.\n    Operand 0 is the LABEL_DECL node for the label that appears here.\n    The type should be void and the value should be ignored.  */"}, {"sha": "57d1970b7c70158f34b01d9c4429c1fb1c03d317", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350fae6628af14c2e760694d39baec5f7858057c/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=350fae6628af14c2e760694d39baec5f7858057c", "patch": "@@ -1065,6 +1065,10 @@ struct tree_vec GTY(())\n #define TARGET_EXPR_INITIAL(NODE) TREE_OPERAND_CHECK_CODE (NODE, TARGET_EXPR, 1)\n #define TARGET_EXPR_CLEANUP(NODE) TREE_OPERAND_CHECK_CODE (NODE, TARGET_EXPR, 2)\n \n+/* DECL_EXPR accessor. This gives access to the DECL associated with\n+   the given declaration statement.  */\n+#define DECL_EXPR_DECL(NODE)    TREE_OPERAND (DECL_EXPR_CHECK (NODE), 0)\n+\n #define EXIT_EXPR_COND(NODE)\t     TREE_OPERAND (EXIT_EXPR_CHECK (NODE), 0)\n \n /* SWITCH_EXPR accessors. These give access to the condition, body and"}]}