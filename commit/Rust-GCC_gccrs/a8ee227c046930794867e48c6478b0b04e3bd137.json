{"sha": "a8ee227c046930794867e48c6478b0b04e3bd137", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YThlZTIyN2MwNDY5MzA3OTQ4NjdlNDhjNjQ3OGIwYjA0ZTNiZDEzNw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2009-03-28T09:08:52Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2009-03-28T09:08:52Z"}, "message": "tree-eh.c (inlinable_call_p): New function.\n\n\t* tree-eh.c (inlinable_call_p): New function.\n\t(make_eh_edges): Use it.\n\t(verify_eh_edges): Use it.\n\t(stmt_can_throw_external, stmt_can_throw_internal): Use it.\n\t* except.c (reachable_next_level): Add inlinable_function argument\n\t(sjlj_find_directly_reachable_regions): Update.\n\t(add_reachable_handler): Do not set saw_any_handlers.\n\t(reachable_next_level): Handle MUST_NOT_THROW more curefully.\n\t(foreach_reachable_handler, can_throw_internal_1, can_throw_external_1):\n\tAdd new inlinable call parameter.\n\t(can_throw_internal, can_throw_external): Update.\n\t* except.h (can_throw_internal_1, can_throw_external_1,\n\tforeach_reachable_handler): Update declaration.\n\nFrom-SVN: r145166", "tree": {"sha": "4ebe94b877890d5f85418fb99ec4730610bcb172", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ebe94b877890d5f85418fb99ec4730610bcb172"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a8ee227c046930794867e48c6478b0b04e3bd137", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8ee227c046930794867e48c6478b0b04e3bd137", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8ee227c046930794867e48c6478b0b04e3bd137", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8ee227c046930794867e48c6478b0b04e3bd137/comments", "author": null, "committer": null, "parents": [{"sha": "aa2785717fa51750bfd24c965744283c405be851", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa2785717fa51750bfd24c965744283c405be851", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa2785717fa51750bfd24c965744283c405be851"}], "stats": {"total": 109, "additions": 79, "deletions": 30}, "files": [{"sha": "f327b671e89ac728d95209da29f5859a28bc6491", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8ee227c046930794867e48c6478b0b04e3bd137/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8ee227c046930794867e48c6478b0b04e3bd137/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a8ee227c046930794867e48c6478b0b04e3bd137", "patch": "@@ -1,3 +1,19 @@\n+2009-03-28  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree-eh.c (inlinable_call_p): New function.\n+\t(make_eh_edges): Use it.\n+\t(verify_eh_edges): Use it.\n+\t(stmt_can_throw_external, stmt_can_throw_internal): Use it.\n+\t* except.c (reachable_next_level): Add inlinable_function argument\n+\t(sjlj_find_directly_reachable_regions): Update.\n+\t(add_reachable_handler): Do not set saw_any_handlers.\n+\t(reachable_next_level): Handle MUST_NOT_THROW more curefully.\n+\t(foreach_reachable_handler, can_throw_internal_1, can_throw_external_1):\n+\tAdd new inlinable call parameter.\n+\t(can_throw_internal, can_throw_external): Update.\n+\t* except.h (can_throw_internal_1, can_throw_external_1,\n+\tforeach_reachable_handler): Update declaration.\n+\n 2009-03-28  Joseph Myers  <joseph@codesourcery.com>\n \n \t* config/arm/t-arm-coff, config/h8300/coff.h,"}, {"sha": "91af716f631760ec3dadc08267225fddec14d9d9", "filename": "gcc/except.c", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8ee227c046930794867e48c6478b0b04e3bd137/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8ee227c046930794867e48c6478b0b04e3bd137/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=a8ee227c046930794867e48c6478b0b04e3bd137", "patch": "@@ -271,7 +271,7 @@ enum reachable_code\n \n struct reachable_info;\n static enum reachable_code reachable_next_level (struct eh_region *, tree,\n-\t\t\t\t\t\t struct reachable_info *);\n+\t\t\t\t\t\t struct reachable_info *, bool);\n \n static int action_record_eq (const void *, const void *);\n static hashval_t action_record_hash (const void *);\n@@ -1660,7 +1660,7 @@ sjlj_find_directly_reachable_regions (struct sjlj_lp_info *lp_info)\n       rc = RNL_NOT_CAUGHT;\n       for (; region; region = region->outer)\n \t{\n-\t  rc = reachable_next_level (region, type_thrown, NULL);\n+\t  rc = reachable_next_level (region, type_thrown, NULL, false);\n \t  if (rc != RNL_NOT_CAUGHT)\n \t    break;\n \t}\n@@ -2359,8 +2359,6 @@ add_reachable_handler (struct reachable_info *info,\n   if (! info)\n     return;\n \n-  info->saw_any_handlers = true;\n-\n   if (crtl->eh.built_landing_pads)\n     info->callback (lp_region, info->callback_data);\n   else\n@@ -2374,7 +2372,8 @@ add_reachable_handler (struct reachable_info *info,\n \n static enum reachable_code\n reachable_next_level (struct eh_region *region, tree type_thrown,\n-\t\t      struct reachable_info *info)\n+\t\t      struct reachable_info *info,\n+\t\t      bool maybe_resx)\n {\n   switch (region->type)\n     {\n@@ -2510,15 +2509,16 @@ reachable_next_level (struct eh_region *region, tree type_thrown,\n \n     case ERT_MUST_NOT_THROW:\n       /* Here we end our search, since no exceptions may propagate.\n-\t If we've touched down at some landing pad previous, then the\n-\t explicit function call we generated may be used.  Otherwise\n-\t the call is made by the runtime.\n+        \n+         Local landing pads of ERT_MUST_NOT_THROW instructions are reachable\n+\t only via locally handled RESX instructions.  \n \n-         Before inlining, do not perform this optimization.  We may\n-\t inline a subroutine that contains handlers, and that will\n-\t change the value of saw_any_handlers.  */\n+\t When we inline a function call, we can bring in new handlers.  In order\n+\t to avoid ERT_MUST_NOT_THROW landing pads from being deleted as unreachable\n+\t assume that such handlers exists prior for any inlinable call prior\n+\t inlining decisions are fixed.  */\n \n-      if ((info && info->saw_any_handlers) || !cfun->after_inlining)\n+      if (maybe_resx)\n \t{\n \t  add_reachable_handler (info, region, region);\n \t  return RNL_CAUGHT;\n@@ -2539,7 +2539,7 @@ reachable_next_level (struct eh_region *region, tree type_thrown,\n /* Invoke CALLBACK on each region reachable from REGION_NUMBER.  */\n \n void\n-foreach_reachable_handler (int region_number, bool is_resx,\n+foreach_reachable_handler (int region_number, bool is_resx, bool inlinable_call,\n \t\t\t   void (*callback) (struct eh_region *, void *),\n \t\t\t   void *callback_data)\n {\n@@ -2570,7 +2570,8 @@ foreach_reachable_handler (int region_number, bool is_resx,\n \n   while (region)\n     {\n-      if (reachable_next_level (region, type_thrown, &info) >= RNL_CAUGHT)\n+      if (reachable_next_level (region, type_thrown, &info,\n+      \t\t\t\tinlinable_call || is_resx) >= RNL_CAUGHT)\n \tbreak;\n       /* If we have processed one cleanup, there is no point in\n \t processing any more of them.  Each cleanup will have an edge\n@@ -2622,7 +2623,7 @@ reachable_handlers (rtx insn)\n       region_number = INTVAL (XEXP (note, 0));\n     }\n \n-  foreach_reachable_handler (region_number, is_resx,\n+  foreach_reachable_handler (region_number, is_resx, false,\n \t\t\t     (crtl->eh.built_landing_pads\n \t\t\t      ? arh_to_landing_pad\n \t\t\t      : arh_to_label),\n@@ -2635,7 +2636,7 @@ reachable_handlers (rtx insn)\n    within the function.  */\n \n bool\n-can_throw_internal_1 (int region_number, bool is_resx)\n+can_throw_internal_1 (int region_number, bool is_resx, bool inlinable_call)\n {\n   struct eh_region *region;\n   tree type_thrown;\n@@ -2656,7 +2657,8 @@ can_throw_internal_1 (int region_number, bool is_resx)\n      regions, which also do not require processing internally.  */\n   for (; region; region = region->outer)\n     {\n-      enum reachable_code how = reachable_next_level (region, type_thrown, 0);\n+      enum reachable_code how = reachable_next_level (region, type_thrown, 0,\n+      \t\t\t\t\t\t      inlinable_call || is_resx);\n       if (how == RNL_BLOCKED)\n \treturn false;\n       if (how != RNL_NOT_CAUGHT)\n@@ -2677,7 +2679,7 @@ can_throw_internal (const_rtx insn)\n   if (JUMP_P (insn)\n       && GET_CODE (PATTERN (insn)) == RESX\n       && XINT (PATTERN (insn), 0) > 0)\n-    return can_throw_internal_1 (XINT (PATTERN (insn), 0), true);\n+    return can_throw_internal_1 (XINT (PATTERN (insn), 0), true, false);\n \n   if (NONJUMP_INSN_P (insn)\n       && GET_CODE (PATTERN (insn)) == SEQUENCE)\n@@ -2688,14 +2690,14 @@ can_throw_internal (const_rtx insn)\n   if (!note || INTVAL (XEXP (note, 0)) <= 0)\n     return false;\n \n-  return can_throw_internal_1 (INTVAL (XEXP (note, 0)), false);\n+  return can_throw_internal_1 (INTVAL (XEXP (note, 0)), false, false);\n }\n \n /* Determine if the given INSN can throw an exception that is\n    visible outside the function.  */\n \n bool\n-can_throw_external_1 (int region_number, bool is_resx)\n+can_throw_external_1 (int region_number, bool is_resx, bool inlinable_call)\n {\n   struct eh_region *region;\n   tree type_thrown;\n@@ -2714,7 +2716,8 @@ can_throw_external_1 (int region_number, bool is_resx)\n   /* If the exception is caught or blocked by any containing region,\n      then it is not seen by any calling function.  */\n   for (; region ; region = region->outer)\n-    if (reachable_next_level (region, type_thrown, NULL) >= RNL_CAUGHT)\n+    if (reachable_next_level (region, type_thrown, NULL,\n+    \tinlinable_call || is_resx) >= RNL_CAUGHT)\n       return false;\n \n   return true;\n@@ -2731,7 +2734,7 @@ can_throw_external (const_rtx insn)\n   if (JUMP_P (insn)\n       && GET_CODE (PATTERN (insn)) == RESX\n       && XINT (PATTERN (insn), 0) > 0)\n-    return can_throw_external_1 (XINT (PATTERN (insn), 0), true);\n+    return can_throw_external_1 (XINT (PATTERN (insn), 0), true, false);\n \n   if (NONJUMP_INSN_P (insn)\n       && GET_CODE (PATTERN (insn)) == SEQUENCE)\n@@ -2752,7 +2755,7 @@ can_throw_external (const_rtx insn)\n   if (INTVAL (XEXP (note, 0)) <= 0)\n     return false;\n \n-  return can_throw_external_1 (INTVAL (XEXP (note, 0)), false);\n+  return can_throw_external_1 (INTVAL (XEXP (note, 0)), false, false);\n }\n \n /* Set TREE_NOTHROW and crtl->all_throwers_are_sibcalls.  */"}, {"sha": "b32312ea373505d08e546cb5dc9c39c1ca2054d6", "filename": "gcc/except.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8ee227c046930794867e48c6478b0b04e3bd137/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8ee227c046930794867e48c6478b0b04e3bd137/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=a8ee227c046930794867e48c6478b0b04e3bd137", "patch": "@@ -44,9 +44,9 @@ extern void for_each_eh_label (void (*) (rtx));\n extern void for_each_eh_region (void (*) (struct eh_region *));\n \n /* Determine if the given INSN can throw an exception.  */\n-extern bool can_throw_internal_1 (int, bool);\n+extern bool can_throw_internal_1 (int, bool, bool);\n extern bool can_throw_internal (const_rtx);\n-extern bool can_throw_external_1 (int, bool);\n+extern bool can_throw_external_1 (int, bool, bool);\n extern bool can_throw_external (const_rtx);\n \n /* Set TREE_NOTHROW and cfun->all_throwers_are_sibcalls.  */\n@@ -97,7 +97,7 @@ extern bool get_eh_region_may_contain_throw (struct eh_region *);\n extern tree get_eh_region_tree_label (struct eh_region *);\n extern void set_eh_region_tree_label (struct eh_region *, tree);\n \n-extern void foreach_reachable_handler (int, bool,\n+extern void foreach_reachable_handler (int, bool, bool,\n \t\t\t\t       void (*) (struct eh_region *, void *),\n \t\t\t\t       void *);\n "}, {"sha": "c789acbd118c7231d4008f9140415ed19d9d92dd", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8ee227c046930794867e48c6478b0b04e3bd137/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8ee227c046930794867e48c6478b0b04e3bd137/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=a8ee227c046930794867e48c6478b0b04e3bd137", "patch": "@@ -1946,11 +1946,34 @@ make_eh_edge (struct eh_region *region, void *data)\n   make_edge (src, dst, EDGE_ABNORMAL | EDGE_EH);\n }\n \n+/* See if STMT is call that might be inlined.  */\n+\n+static bool\n+inlinable_call_p (gimple stmt)\n+{\n+  tree decl;\n+  if (gimple_code (stmt) != GIMPLE_CALL)\n+    return false;\n+  if (cfun->after_inlining)\n+    return false;\n+  /* Indirect calls can be propagated to direct call\n+     and inlined.  */\n+  decl = gimple_call_fndecl (stmt);\n+  if (!decl)\n+    return true;\n+  if (cgraph_function_flags_ready\n+      && cgraph_function_body_availability (cgraph_node (decl))\n+      < AVAIL_OVERWRITABLE)\n+    return false;\n+  return !DECL_UNINLINABLE (decl);\n+}\n+\n void\n make_eh_edges (gimple stmt)\n {\n   int region_nr;\n   bool is_resx;\n+  bool inlinable = false;\n \n   if (gimple_code (stmt) == GIMPLE_RESX)\n     {\n@@ -1963,9 +1986,10 @@ make_eh_edges (gimple stmt)\n       if (region_nr < 0)\n \treturn;\n       is_resx = false;\n+      inlinable = inlinable_call_p (stmt);\n     }\n \n-  foreach_reachable_handler (region_nr, is_resx, make_eh_edge, stmt);\n+  foreach_reachable_handler (region_nr, is_resx, inlinable, make_eh_edge, stmt);\n }\n \n static bool mark_eh_edge_found_error;\n@@ -2019,6 +2043,7 @@ verify_eh_edges (gimple stmt)\n   basic_block bb = gimple_bb (stmt);\n   edge_iterator ei;\n   edge e;\n+  bool inlinable = false;\n \n   FOR_EACH_EDGE (e, ei, bb->succs)\n     gcc_assert (!e->aux);\n@@ -2046,10 +2071,11 @@ verify_eh_edges (gimple stmt)\n \t  error (\"BB %i last statement has incorrectly set region\", bb->index);\n \t  return true;\n \t}\n+      inlinable = inlinable_call_p (stmt);\n       is_resx = false;\n     }\n \n-  foreach_reachable_handler (region_nr, is_resx, mark_eh_edge, stmt);\n+  foreach_reachable_handler (region_nr, is_resx, inlinable, mark_eh_edge, stmt);\n   FOR_EACH_EDGE (e, ei, bb->succs)\n     {\n       if ((e->flags & EDGE_EH) && !e->aux)\n@@ -2393,19 +2419,23 @@ stmt_can_throw_internal (gimple stmt)\n {\n   int region_nr;\n   bool is_resx = false;\n+  bool inlinable_call = false;\n \n   if (gimple_code (stmt) == GIMPLE_RESX)\n     {\n       region_nr = gimple_resx_region (stmt);\n       is_resx = true;\n     }\n   else\n-    region_nr = lookup_stmt_eh_region (stmt);\n+    {\n+      region_nr = lookup_stmt_eh_region (stmt);\n+      inlinable_call = inlinable_call_p (stmt);\n+    }\n \n   if (region_nr < 0)\n     return false;\n \n-  return can_throw_internal_1 (region_nr, is_resx);\n+  return can_throw_internal_1 (region_nr, is_resx, inlinable_call);\n }\n \n "}]}