{"sha": "da9a21f490ab6f3bba0a5861bb1575ad46db5f55", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGE5YTIxZjQ5MGFiNmYzYmJhMGE1ODYxYmIxNTc1YWQ0NmRiNWY1NQ==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebpop@gmail.com", "date": "2007-06-20T23:42:28Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2007-06-20T23:42:28Z"}, "message": "re PR tree-optimization/32075 (can't determine dependence between p->a[x+i] and p->a[x+i+1] where x is invariant but defined in the function)\n\n\tPR tree-optimization/32075\n\t* tree-data-ref.c (subscript_dependence_tester_1, \n\tanalyze_miv_subscript, analyze_overlapping_iterations,\n\tadd_distance_for_zero_overlaps, build_classic_dist_vector,\n\tsubscript_dependence_tester_1, analyze_overlapping_iterations,\n\tsubscript_dependence_tester, access_functions_are_affine_or_constant_p,\n\tcompute_affine_dependence, compute_all_dependences): Pass loop_nest \n\tto evolution_function_is_affine_multivariate_p.\n\nFrom-SVN: r125900", "tree": {"sha": "edcfe2da4e7cbccae2aa302c567f2220a3d932f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/edcfe2da4e7cbccae2aa302c567f2220a3d932f6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da9a21f490ab6f3bba0a5861bb1575ad46db5f55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da9a21f490ab6f3bba0a5861bb1575ad46db5f55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da9a21f490ab6f3bba0a5861bb1575ad46db5f55", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da9a21f490ab6f3bba0a5861bb1575ad46db5f55/comments", "author": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14d4217b595cf79d91c481b8492dfac980aaa054", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14d4217b595cf79d91c481b8492dfac980aaa054", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14d4217b595cf79d91c481b8492dfac980aaa054"}], "stats": {"total": 97, "additions": 55, "deletions": 42}, "files": [{"sha": "f9ec83615883902e9a4dee752e2ed9419adf56c6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da9a21f490ab6f3bba0a5861bb1575ad46db5f55/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da9a21f490ab6f3bba0a5861bb1575ad46db5f55/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=da9a21f490ab6f3bba0a5861bb1575ad46db5f55", "patch": "@@ -128,7 +128,7 @@\n \toffsets->locals_base to avoid negative stack size.\n \t(thumb1_expand_prologue): Assert on negative stack size.\n \n-2007-04-11  Sebastian Pop  <sebpop@gmail.com>\n+2007-04-19  Sebastian Pop  <sebpop@gmail.com>\n \n \tPR tree-optimization/32367\n \t* tree-chrec.h (build_polynomial_chrec): Verify that the left hand side "}, {"sha": "54980a36609ac97f993dd465d79b31f0b26fec7b", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 54, "deletions": 41, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da9a21f490ab6f3bba0a5861bb1575ad46db5f55/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da9a21f490ab6f3bba0a5861bb1575ad46db5f55/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=da9a21f490ab6f3bba0a5861bb1575ad46db5f55", "patch": "@@ -124,7 +124,8 @@ static struct datadep_stats\n \n static bool subscript_dependence_tester_1 (struct data_dependence_relation *,\n \t\t\t\t\t   struct data_reference *,\n-\t\t\t\t\t   struct data_reference *);\n+\t\t\t\t\t   struct data_reference *,\n+\t\t\t\t\t   struct loop *);\n /* Returns true iff A divides B.  */\n \n static inline bool \n@@ -2417,10 +2418,11 @@ gcd_of_steps_may_divide_p (tree chrec, tree cst)\n   return val % cd == 0;\n }\n \n-/* Analyze a MIV (Multiple Index Variable) subscript.  *OVERLAPS_A and\n-   *OVERLAPS_B are initialized to the functions that describe the\n-   relation between the elements accessed twice by CHREC_A and\n-   CHREC_B.  For k >= 0, the following property is verified:\n+/* Analyze a MIV (Multiple Index Variable) subscript with respect to\n+   LOOP_NEST.  *OVERLAPS_A and *OVERLAPS_B are initialized to the\n+   functions that describe the relation between the elements accessed\n+   twice by CHREC_A and CHREC_B.  For k >= 0, the following property\n+   is verified:\n \n    CHREC_A (*OVERLAPS_A (k)) = CHREC_B (*OVERLAPS_B (k)).  */\n \n@@ -2429,7 +2431,8 @@ analyze_miv_subscript (tree chrec_a,\n \t\t       tree chrec_b, \n \t\t       conflict_function **overlaps_a, \n \t\t       conflict_function **overlaps_b, \n-\t\t       tree *last_conflicts)\n+\t\t       tree *last_conflicts,\n+\t\t       struct loop *loop_nest)\n {\n   /* FIXME:  This is a MIV subscript, not yet handled.\n      Example: (A[{1, +, 1}_1] vs. A[{1, +, 1}_2]) that comes from \n@@ -2461,7 +2464,8 @@ analyze_miv_subscript (tree chrec_a,\n   \n   else if (evolution_function_is_constant_p (difference)\n \t   /* For the moment, the following is verified:\n-\t      evolution_function_is_affine_multivariate_p (chrec_a, 0) */\n+\t      evolution_function_is_affine_multivariate_p (chrec_a,\n+\t      loop_nest->num) */\n \t   && !gcd_of_steps_may_divide_p (chrec_a, difference))\n     {\n       /* testsuite/.../ssa-chrec-33.c\n@@ -2475,9 +2479,9 @@ analyze_miv_subscript (tree chrec_a,\n       dependence_stats.num_miv_independent++;\n     }\n   \n-  else if (evolution_function_is_affine_multivariate_p (chrec_a, 0)\n+  else if (evolution_function_is_affine_multivariate_p (chrec_a, loop_nest->num)\n \t   && !chrec_contains_symbols (chrec_a)\n-\t   && evolution_function_is_affine_multivariate_p (chrec_b, 0)\n+\t   && evolution_function_is_affine_multivariate_p (chrec_b, loop_nest->num)\n \t   && !chrec_contains_symbols (chrec_b))\n     {\n       /* testsuite/.../ssa-chrec-35.c\n@@ -2523,10 +2527,10 @@ analyze_miv_subscript (tree chrec_a,\n     fprintf (dump_file, \")\\n\");\n }\n \n-/* Determines the iterations for which CHREC_A is equal to CHREC_B.\n-   OVERLAP_ITERATIONS_A and OVERLAP_ITERATIONS_B are initialized with\n-   two functions that describe the iterations that contain conflicting\n-   elements.\n+/* Determines the iterations for which CHREC_A is equal to CHREC_B in\n+   with respect to LOOP_NEST.  OVERLAP_ITERATIONS_A and\n+   OVERLAP_ITERATIONS_B are initialized with two functions that\n+   describe the iterations that contain conflicting elements.\n    \n    Remark: For an integer k >= 0, the following equality is true:\n    \n@@ -2538,8 +2542,10 @@ analyze_overlapping_iterations (tree chrec_a,\n \t\t\t\ttree chrec_b, \n \t\t\t\tconflict_function **overlap_iterations_a, \n \t\t\t\tconflict_function **overlap_iterations_b, \n-\t\t\t\ttree *last_conflicts)\n+\t\t\t\ttree *last_conflicts, struct loop *loop_nest)\n {\n+  unsigned int lnn = loop_nest->num;\n+\n   dependence_stats.num_subscript_tests++;\n   \n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -2566,7 +2572,7 @@ analyze_overlapping_iterations (tree chrec_a,\n   /* If they are the same chrec, and are affine, they overlap \n      on every iteration.  */\n   else if (eq_evolutions_p (chrec_a, chrec_b)\n-\t   && evolution_function_is_affine_multivariate_p (chrec_a, 0))\n+\t   && evolution_function_is_affine_multivariate_p (chrec_a, lnn))\n     {\n       dependence_stats.num_same_subscript_function++;\n       *overlap_iterations_a = conflict_fn (1, affine_fn_cst (integer_zero_node));\n@@ -2578,8 +2584,8 @@ analyze_overlapping_iterations (tree chrec_a,\n      yet. */\n   else if ((chrec_contains_symbols (chrec_a) \n \t    || chrec_contains_symbols (chrec_b))\n-\t   && (!evolution_function_is_affine_multivariate_p (chrec_a, 0)\n-\t       || !evolution_function_is_affine_multivariate_p (chrec_b, 0)))\n+\t   && (!evolution_function_is_affine_multivariate_p (chrec_a, lnn)\n+\t       || !evolution_function_is_affine_multivariate_p (chrec_b, lnn)))\n     {\n       dependence_stats.num_subscript_undetermined++;\n       *overlap_iterations_a = conflict_fn_not_known ();\n@@ -2599,7 +2605,7 @@ analyze_overlapping_iterations (tree chrec_a,\n   else\n     analyze_miv_subscript (chrec_a, chrec_b, \n \t\t\t   overlap_iterations_a, overlap_iterations_b,\n-\t\t\t   last_conflicts);\n+\t\t\t   last_conflicts, loop_nest);\n   \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -2926,7 +2932,8 @@ add_distance_for_zero_overlaps (struct data_dependence_relation *ddr)\n    to represent the data dependence as a distance vector.  */\n \n static bool\n-build_classic_dist_vector (struct data_dependence_relation *ddr)\n+build_classic_dist_vector (struct data_dependence_relation *ddr,\n+\t\t\t   struct loop *loop_nest)\n {\n   bool init_b = false;\n   int index_carry = DDR_NB_LOOPS (ddr);\n@@ -2985,7 +2992,8 @@ build_classic_dist_vector (struct data_dependence_relation *ddr)\n       if (!lambda_vector_lexico_pos (dist_v, DDR_NB_LOOPS (ddr)))\n \t{\n \t  lambda_vector save_v = lambda_vector_new (DDR_NB_LOOPS (ddr));\n-\t  subscript_dependence_tester_1 (ddr, DDR_B (ddr), DDR_A (ddr));\n+\t  subscript_dependence_tester_1 (ddr, DDR_B (ddr), DDR_A (ddr),\n+\t\t\t\t\t loop_nest);\n \t  compute_subscript_distance (ddr);\n \t  build_classic_dist_vector_1 (ddr, DDR_B (ddr), DDR_A (ddr),\n \t\t\t\t       save_v, &init_b, &index_carry);\n@@ -3023,7 +3031,8 @@ build_classic_dist_vector (struct data_dependence_relation *ddr)\n \t    {\n \t      lambda_vector opposite_v = lambda_vector_new (DDR_NB_LOOPS (ddr));\n \n-\t      subscript_dependence_tester_1 (ddr, DDR_B (ddr), DDR_A (ddr));\n+\t      subscript_dependence_tester_1 (ddr, DDR_B (ddr), DDR_A (ddr),\n+\t\t\t\t\t     loop_nest);\n \t      compute_subscript_distance (ddr);\n \t      build_classic_dist_vector_1 (ddr, DDR_B (ddr), DDR_A (ddr),\n \t\t\t\t\t   opposite_v, &init_b, &index_carry);\n@@ -3106,7 +3115,8 @@ build_classic_dir_vector (struct data_dependence_relation *ddr)\n static bool\n subscript_dependence_tester_1 (struct data_dependence_relation *ddr,\n \t\t\t       struct data_reference *dra,\n-\t\t\t       struct data_reference *drb)\n+\t\t\t       struct data_reference *drb,\n+\t\t\t       struct loop *loop_nest)\n {\n   unsigned int i;\n   tree last_conflicts;\n@@ -3120,7 +3130,7 @@ subscript_dependence_tester_1 (struct data_dependence_relation *ddr,\n       analyze_overlapping_iterations (DR_ACCESS_FN (dra, i), \n \t\t\t\t      DR_ACCESS_FN (drb, i),\n \t\t\t\t      &overlaps_a, &overlaps_b, \n-\t\t\t\t      &last_conflicts);\n+\t\t\t\t      &last_conflicts, loop_nest);\n \n       if (CF_NOT_KNOWN_P (overlaps_a)\n  \t  || CF_NOT_KNOWN_P (overlaps_b))\n@@ -3153,39 +3163,41 @@ subscript_dependence_tester_1 (struct data_dependence_relation *ddr,\n   return true;\n }\n \n-/* Computes the conflicting iterations, and initialize DDR.  */\n+/* Computes the conflicting iterations in LOOP_NEST, and initialize DDR.  */\n \n static void\n-subscript_dependence_tester (struct data_dependence_relation *ddr)\n+subscript_dependence_tester (struct data_dependence_relation *ddr,\n+\t\t\t     struct loop *loop_nest)\n {\n   \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"(subscript_dependence_tester \\n\");\n   \n-  if (subscript_dependence_tester_1 (ddr, DDR_A (ddr), DDR_B (ddr)))\n+  if (subscript_dependence_tester_1 (ddr, DDR_A (ddr), DDR_B (ddr), loop_nest))\n     dependence_stats.num_dependence_dependent++;\n \n   compute_subscript_distance (ddr);\n-  if (build_classic_dist_vector (ddr))\n+  if (build_classic_dist_vector (ddr, loop_nest))\n     build_classic_dir_vector (ddr);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \")\\n\");\n }\n \n /* Returns true when all the access functions of A are affine or\n-   constant.  */\n+   constant with respect to LOOP_NEST.  */\n \n static bool \n-access_functions_are_affine_or_constant_p (struct data_reference *a)\n+access_functions_are_affine_or_constant_p (struct data_reference *a,\n+\t\t\t\t\t   struct loop *loop_nest)\n {\n   unsigned int i;\n   VEC(tree,heap) *fns = DR_ACCESS_FNS (a);\n   tree t;\n \n   for (i = 0; VEC_iterate (tree, fns, i, t); i++)\n-    if (!evolution_function_is_constant_p (t)\n-\t&& !evolution_function_is_affine_multivariate_p (t, 0))\n+    if (!evolution_function_is_invariant_p (t, loop_nest->num)\n+\t&& !evolution_function_is_affine_multivariate_p (t, loop_nest->num))\n       return false;\n   \n   return true;\n@@ -3715,17 +3727,18 @@ ddr_consistent_p (FILE *file,\n   return true;  \n }\n \n-/* This computes the affine dependence relation between A and B.\n-   CHREC_KNOWN is used for representing the independence between two\n-   accesses, while CHREC_DONT_KNOW is used for representing the unknown\n-   relation.\n+/* This computes the affine dependence relation between A and B with\n+   respect to LOOP_NEST.  CHREC_KNOWN is used for representing the\n+   independence between two accesses, while CHREC_DONT_KNOW is used\n+   for representing the unknown relation.\n    \n    Note that it is possible to stop the computation of the dependence\n    relation the first time we detect a CHREC_KNOWN element for a given\n    subscript.  */\n \n static void\n-compute_affine_dependence (struct data_dependence_relation *ddr)\n+compute_affine_dependence (struct data_dependence_relation *ddr,\n+\t\t\t   struct loop *loop_nest)\n {\n   struct data_reference *dra = DDR_A (ddr);\n   struct data_reference *drb = DDR_B (ddr);\n@@ -3745,13 +3758,13 @@ compute_affine_dependence (struct data_dependence_relation *ddr)\n     {\n       dependence_stats.num_dependence_tests++;\n \n-      if (access_functions_are_affine_or_constant_p (dra)\n-\t  && access_functions_are_affine_or_constant_p (drb))\n+      if (access_functions_are_affine_or_constant_p (dra, loop_nest)\n+\t  && access_functions_are_affine_or_constant_p (drb, loop_nest))\n \t{\n \t  if (flag_check_data_deps)\n \t    {\n \t      /* Compute the dependences using the first algorithm.  */\n-\t      subscript_dependence_tester (ddr);\n+\t      subscript_dependence_tester (ddr, loop_nest);\n \n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t{\n@@ -3789,7 +3802,7 @@ compute_affine_dependence (struct data_dependence_relation *ddr)\n \t\t}\n \t    }\n \t  else\n-\t    subscript_dependence_tester (ddr);\n+\t    subscript_dependence_tester (ddr, loop_nest);\n \t}\n      \n       /* As a last case, if the dependence cannot be determined, or if\n@@ -3865,7 +3878,7 @@ compute_all_dependences (VEC (data_reference_p, heap) *datarefs,\n \t{\n \t  ddr = initialize_data_dependence_relation (a, b, loop_nest);\n \t  VEC_safe_push (ddr_p, heap, *dependence_relations, ddr);\n-\t  compute_affine_dependence (ddr);\n+\t  compute_affine_dependence (ddr, VEC_index (loop_p, loop_nest, 0));\n \t}\n \n   if (compute_self_and_rr)"}]}