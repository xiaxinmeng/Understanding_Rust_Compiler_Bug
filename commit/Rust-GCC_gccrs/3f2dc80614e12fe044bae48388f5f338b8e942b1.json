{"sha": "3f2dc80614e12fe044bae48388f5f338b8e942b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2YyZGM4MDYxNGUxMmZlMDQ0YmFlNDgzODhmNWYzMzhiOGU5NDJiMQ==", "commit": {"author": {"name": "Andrew Stubbs", "email": "ams@codesourcery.com", "date": "2012-11-13T13:31:50Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2012-11-13T13:31:50Z"}, "message": "arm.c (arm_emit_coreregs_64bit_shift): Fix comment.\n\n2012-11-13  Andrew Stubbs  <ams@codesourcery.com>\n            Ulrich Weigand  <ulrich.weigand@linaro.org>\n\n\t* config/arm/arm.c (arm_emit_coreregs_64bit_shift): Fix comment.\n\t* config/arm/arm.md (opt, opt_enabled): New attributes.\n\t(enabled): Use opt_enabled.\n\t(ashldi3, ashrdi3, lshrdi3): Add TARGET_NEON case.\n\t(ashldi3): Allow general operands for TARGET_NEON case.\n\t* config/arm/iterators.md (rshifts): New code iterator.\n\t(shift, shifttype): New code attributes.\n\t* config/arm/neon.md (UNSPEC_LOAD_COUNT): New unspec type.\n\t(neon_load_count, ashldi3_neon_noclobber, ashldi3_neon,\n\tsigned_shift_di3_neon, unsigned_shift_di3_neon,\n\tashrdi3_neon_imm_noclobber, lshrdi3_neon_imm_noclobber,\n\t<shift>di3_neon): New patterns.\n\nCo-Authored-By: Ulrich Weigand <ulrich.weigand@linaro.org>\n\nFrom-SVN: r193476", "tree": {"sha": "5bb8c5af3bd87edc10bb08d1f3b4154d65894d09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5bb8c5af3bd87edc10bb08d1f3b4154d65894d09"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f2dc80614e12fe044bae48388f5f338b8e942b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f2dc80614e12fe044bae48388f5f338b8e942b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f2dc80614e12fe044bae48388f5f338b8e942b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f2dc80614e12fe044bae48388f5f338b8e942b1/comments", "author": {"login": "ams-cs", "id": 2235130, "node_id": "MDQ6VXNlcjIyMzUxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2235130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ams-cs", "html_url": "https://github.com/ams-cs", "followers_url": "https://api.github.com/users/ams-cs/followers", "following_url": "https://api.github.com/users/ams-cs/following{/other_user}", "gists_url": "https://api.github.com/users/ams-cs/gists{/gist_id}", "starred_url": "https://api.github.com/users/ams-cs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ams-cs/subscriptions", "organizations_url": "https://api.github.com/users/ams-cs/orgs", "repos_url": "https://api.github.com/users/ams-cs/repos", "events_url": "https://api.github.com/users/ams-cs/events{/privacy}", "received_events_url": "https://api.github.com/users/ams-cs/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2b12109c4a5fda3d9af269a2e6c1c685dd5818de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b12109c4a5fda3d9af269a2e6c1c685dd5818de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b12109c4a5fda3d9af269a2e6c1c685dd5818de"}], "stats": {"total": 273, "additions": 265, "deletions": 8}, "files": [{"sha": "863190fe1d1f80bf36db4e8d546cf578d09274ed", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f2dc80614e12fe044bae48388f5f338b8e942b1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f2dc80614e12fe044bae48388f5f338b8e942b1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3f2dc80614e12fe044bae48388f5f338b8e942b1", "patch": "@@ -1,3 +1,19 @@\n+2012-11-13  Andrew Stubbs  <ams@codesourcery.com>\n+\t    Ulrich Weigand  <ulrich.weigand@linaro.org>\n+\n+\t* config/arm/arm.c (arm_emit_coreregs_64bit_shift): Fix comment.\n+\t* config/arm/arm.md (opt, opt_enabled): New attributes.\n+\t(enabled): Use opt_enabled.\n+\t(ashldi3, ashrdi3, lshrdi3): Add TARGET_NEON case.\n+\t(ashldi3): Allow general operands for TARGET_NEON case.\n+\t* config/arm/iterators.md (rshifts): New code iterator.\n+\t(shift, shifttype): New code attributes.\n+\t* config/arm/neon.md (UNSPEC_LOAD_COUNT): New unspec type.\n+\t(neon_load_count, ashldi3_neon_noclobber, ashldi3_neon,\n+\tsigned_shift_di3_neon, unsigned_shift_di3_neon,\n+\tashrdi3_neon_imm_noclobber, lshrdi3_neon_imm_noclobber,\n+\t<shift>di3_neon): New patterns.\n+\n 2012-11-13  Jakub Jelinek  <jakub@redhat.com>\n \n \t* Makefile.in (asan.o): Depend on $(TM_P_H)."}, {"sha": "3bec7c57421ced32836bd8952824c88bc8688c43", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f2dc80614e12fe044bae48388f5f338b8e942b1/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f2dc80614e12fe044bae48388f5f338b8e942b1/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=3f2dc80614e12fe044bae48388f5f338b8e942b1", "patch": "@@ -26635,8 +26635,7 @@ arm_autoinc_modes_ok_p (enum machine_mode mode, enum arm_auto_incmodes code)\n    Input requirements:\n     - It is safe for the input and output to be the same register, but\n       early-clobber rules apply for the shift amount and scratch registers.\n-    - Shift by register requires both scratch registers.  Shift by a constant\n-      less than 32 in Thumb2 mode requires SCRATCH1 only.  In all other cases\n+    - Shift by register requires both scratch registers.  In all other cases\n       the scratch registers may be NULL.\n     - Ashiftrt by a register also clobbers the CC register.  */\n void"}, {"sha": "7e92b69ad861fe90ed409494d451854f30888462", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 56, "deletions": 6, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f2dc80614e12fe044bae48388f5f338b8e942b1/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f2dc80614e12fe044bae48388f5f338b8e942b1/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=3f2dc80614e12fe044bae48388f5f338b8e942b1", "patch": "@@ -249,18 +249,38 @@\n \n \t(const_string \"no\")))\n \n+(define_attr \"opt\" \"any,speed,size\"\n+  (const_string \"any\"))\n+\n+(define_attr \"opt_enabled\" \"no,yes\"\n+  (cond [(eq_attr \"opt\" \"any\")\n+         (const_string \"yes\")\n+\n+\t (and (eq_attr \"opt\" \"speed\")\n+\t      (match_test \"optimize_function_for_speed_p (cfun)\"))\n+\t (const_string \"yes\")\n+\n+\t (and (eq_attr \"opt\" \"size\")\n+\t      (match_test \"optimize_function_for_size_p (cfun)\"))\n+\t (const_string \"yes\")]\n+\t(const_string \"no\")))\n+\n ; Allows an insn to disable certain alternatives for reasons other than\n ; arch support.\n (define_attr \"insn_enabled\" \"no,yes\"\n   (const_string \"yes\"))\n \n ; Enable all alternatives that are both arch_enabled and insn_enabled.\n  (define_attr \"enabled\" \"no,yes\"\n-   (if_then_else (eq_attr \"insn_enabled\" \"yes\")\n-               (if_then_else (eq_attr \"arch_enabled\" \"yes\")\n-                             (const_string \"yes\")\n-                             (const_string \"no\"))\n-                (const_string \"no\")))\n+   (cond [(eq_attr \"insn_enabled\" \"no\")\n+\t  (const_string \"no\")\n+\n+\t  (eq_attr \"arch_enabled\" \"no\")\n+\t  (const_string \"no\")\n+\n+\t  (eq_attr \"opt_enabled\" \"no\")\n+\t  (const_string \"no\")]\n+\t (const_string \"yes\")))\n \n ; POOL_RANGE is how far away from a constant pool entry that this insn\n ; can be placed.  If the distance is zero, then this insn will never\n@@ -3489,9 +3509,23 @@\n (define_expand \"ashldi3\"\n   [(set (match_operand:DI            0 \"s_register_operand\" \"\")\n         (ashift:DI (match_operand:DI 1 \"s_register_operand\" \"\")\n-                   (match_operand:SI 2 \"reg_or_int_operand\" \"\")))]\n+                   (match_operand:SI 2 \"general_operand\" \"\")))]\n   \"TARGET_32BIT\"\n   \"\n+  if (TARGET_NEON)\n+    {\n+      /* Delay the decision whether to use NEON or core-regs until\n+\t register allocation.  */\n+      emit_insn (gen_ashldi3_neon (operands[0], operands[1], operands[2]));\n+      DONE;\n+    }\n+  else\n+    {\n+      /* Only the NEON case can handle in-memory shift counts.  */\n+      if (!reg_or_int_operand (operands[2], SImode))\n+        operands[2] = force_reg (SImode, operands[2]);\n+    }\n+\n   if (!CONST_INT_P (operands[2]) && TARGET_REALLY_IWMMXT)\n     ; /* No special preparation statements; expand pattern as above.  */\n   else\n@@ -3566,6 +3600,14 @@\n                      (match_operand:SI 2 \"reg_or_int_operand\" \"\")))]\n   \"TARGET_32BIT\"\n   \"\n+  if (TARGET_NEON)\n+    {\n+      /* Delay the decision whether to use NEON or core-regs until\n+\t register allocation.  */\n+      emit_insn (gen_ashrdi3_neon (operands[0], operands[1], operands[2]));\n+      DONE;\n+    }\n+\n   if (!CONST_INT_P (operands[2]) && TARGET_REALLY_IWMMXT)\n     ; /* No special preparation statements; expand pattern as above.  */\n   else\n@@ -3638,6 +3680,14 @@\n                      (match_operand:SI 2 \"reg_or_int_operand\" \"\")))]\n   \"TARGET_32BIT\"\n   \"\n+  if (TARGET_NEON)\n+    {\n+      /* Delay the decision whether to use NEON or core-regs until\n+\t register allocation.  */\n+      emit_insn (gen_lshrdi3_neon (operands[0], operands[1], operands[2]));\n+      DONE;\n+    }\n+\n   if (!CONST_INT_P (operands[2]) && TARGET_REALLY_IWMMXT)\n     ; /* No special preparation statements; expand pattern as above.  */\n   else"}, {"sha": "0a34c82974a4b3f65bbd40032c5d33cc862be095", "filename": "gcc/config/arm/iterators.md", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f2dc80614e12fe044bae48388f5f338b8e942b1/gcc%2Fconfig%2Farm%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f2dc80614e12fe044bae48388f5f338b8e942b1/gcc%2Fconfig%2Farm%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fiterators.md?ref=3f2dc80614e12fe044bae48388f5f338b8e942b1", "patch": "@@ -188,6 +188,9 @@\n ;; A list of widening operators\n (define_code_iterator SE [sign_extend zero_extend])\n \n+;; Right shifts\n+(define_code_iterator rshifts [ashiftrt lshiftrt])\n+\n ;;----------------------------------------------------------------------------\n ;; Mode attributes\n ;;----------------------------------------------------------------------------\n@@ -449,3 +452,8 @@\n \n ;; Assembler mnemonics for signedness of widening operations.\n (define_code_attr US [(sign_extend \"s\") (zero_extend \"u\")])\n+\n+;; Right shifts\n+(define_code_attr shift [(ashiftrt \"ashr\") (lshiftrt \"lshr\")])\n+(define_code_attr shifttype [(ashiftrt \"signed\") (lshiftrt \"unsigned\")])\n+"}, {"sha": "21035808c0e5964d29b7c903b5721210223153e0", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f2dc80614e12fe044bae48388f5f338b8e942b1/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f2dc80614e12fe044bae48388f5f338b8e942b1/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=3f2dc80614e12fe044bae48388f5f338b8e942b1", "patch": "@@ -23,6 +23,7 @@\n (define_c_enum \"unspec\" [\n   UNSPEC_ASHIFT_SIGNED\n   UNSPEC_ASHIFT_UNSIGNED\n+  UNSPEC_LOAD_COUNT\n   UNSPEC_VABD\n   UNSPEC_VABDL\n   UNSPEC_VADD\n@@ -1200,6 +1201,189 @@\n   DONE;\n })\n \n+;; 64-bit shifts\n+\n+;; This pattern loads a 32-bit shift count into a 64-bit NEON register,\n+;; leaving the upper half uninitalized.  This is OK since the shift\n+;; instruction only looks at the low 8 bits anyway.  To avoid confusing\n+;; data flow analysis however, we pretend the full register is set\n+;; using an unspec.\n+(define_insn \"neon_load_count\"\n+  [(set (match_operand:DI 0 \"s_register_operand\" \"=w,w\")\n+        (unspec:DI [(match_operand:SI 1 \"nonimmediate_operand\" \"Um,r\")]\n+                   UNSPEC_LOAD_COUNT))]\n+  \"TARGET_NEON\"\n+  \"@\n+   vld1.32\\t{%P0[0]}, %A1\n+   vmov.32\\t%P0[0], %1\"\n+  [(set_attr \"neon_type\" \"neon_vld1_vld2_lane,neon_mcr\")]\n+)\n+\n+(define_insn \"ashldi3_neon_noclobber\"\n+  [(set (match_operand:DI 0 \"s_register_operand\"\t    \"=w,w\")\n+\t(ashift:DI (match_operand:DI 1 \"s_register_operand\" \" w,w\")\n+\t\t   (match_operand:DI 2 \"reg_or_int_operand\" \" i,w\")))]\n+  \"TARGET_NEON && reload_completed\n+   && (!CONST_INT_P (operands[2])\n+       || (INTVAL (operands[2]) >= 0 && INTVAL (operands[2]) < 64))\"\n+  \"@\n+   vshl.u64\\t%P0, %P1, %2\n+   vshl.u64\\t%P0, %P1, %P2\"\n+  [(set_attr \"neon_type\" \"neon_vshl_ddd,neon_vshl_ddd\")]\n+)\n+\n+(define_insn_and_split \"ashldi3_neon\"\n+  [(set (match_operand:DI 0 \"s_register_operand\"\t    \"= w, w,?&r,?r, ?w,w\")\n+\t(ashift:DI (match_operand:DI 1 \"s_register_operand\" \" 0w, w, 0r, r, 0w,w\")\n+\t\t   (match_operand:SI 2 \"general_operand\"    \"rUm, i,  r, i,rUm,i\")))\n+   (clobber (match_scratch:SI 3\t\t\t\t    \"= X, X,?&r, X,  X,X\"))\n+   (clobber (match_scratch:SI 4\t\t\t\t    \"= X, X,?&r, X,  X,X\"))\n+   (clobber (match_scratch:DI 5\t\t\t\t    \"=&w, X,  X, X, &w,X\"))\n+   (clobber (reg:CC_C CC_REGNUM))]\n+  \"TARGET_NEON\"\n+  \"#\"\n+  \"TARGET_NEON && reload_completed\"\n+  [(const_int 0)]\n+  \"\n+  {\n+    if (IS_VFP_REGNUM (REGNO (operands[0])))\n+      {\n+        if (CONST_INT_P (operands[2]))\n+\t  {\n+\t    if (INTVAL (operands[2]) < 1)\n+\t      {\n+\t        emit_insn (gen_movdi (operands[0], operands[1]));\n+\t\tDONE;\n+\t      }\n+\t    else if (INTVAL (operands[2]) > 63)\n+\t      operands[2] = gen_rtx_CONST_INT (VOIDmode, 63);\n+\t  }\n+\telse\n+\t  {\n+\t    emit_insn (gen_neon_load_count (operands[5], operands[2]));\n+\t    operands[2] = operands[5];\n+\t  }\n+\n+\t/* Ditch the unnecessary clobbers.  */\n+\temit_insn (gen_ashldi3_neon_noclobber (operands[0], operands[1],\n+\t\t\t\t\t       operands[2]));\n+      }\n+    else\n+      {\n+\tif (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 1)\n+\t  /* This clobbers CC.  */\n+\t  emit_insn (gen_arm_ashldi3_1bit (operands[0], operands[1]));\n+\telse\n+\t  arm_emit_coreregs_64bit_shift (ASHIFT, operands[0], operands[1],\n+\t\t\t\t\t operands[2], operands[3], operands[4]);\n+      }\n+    DONE;\n+  }\"\n+  [(set_attr \"arch\" \"nota8,nota8,*,*,onlya8,onlya8\")\n+   (set_attr \"opt\" \"*,*,speed,speed,*,*\")]\n+)\n+\n+; The shift amount needs to be negated for right-shifts\n+(define_insn \"signed_shift_di3_neon\"\n+  [(set (match_operand:DI 0 \"s_register_operand\"\t     \"=w\")\n+\t(unspec:DI [(match_operand:DI 1 \"s_register_operand\" \" w\")\n+\t\t    (match_operand:DI 2 \"s_register_operand\" \" w\")]\n+\t\t   UNSPEC_ASHIFT_SIGNED))]\n+  \"TARGET_NEON && reload_completed\"\n+  \"vshl.s64\\t%P0, %P1, %P2\"\n+  [(set_attr \"neon_type\" \"neon_vshl_ddd\")]\n+)\n+\n+; The shift amount needs to be negated for right-shifts\n+(define_insn \"unsigned_shift_di3_neon\"\n+  [(set (match_operand:DI 0 \"s_register_operand\"\t     \"=w\")\n+\t(unspec:DI [(match_operand:DI 1 \"s_register_operand\" \" w\")\n+\t\t    (match_operand:DI 2 \"s_register_operand\" \" w\")]\n+\t\t   UNSPEC_ASHIFT_UNSIGNED))]\n+  \"TARGET_NEON && reload_completed\"\n+  \"vshl.u64\\t%P0, %P1, %P2\"\n+  [(set_attr \"neon_type\" \"neon_vshl_ddd\")]\n+)\n+\n+(define_insn \"ashrdi3_neon_imm_noclobber\"\n+  [(set (match_operand:DI 0 \"s_register_operand\"\t      \"=w\")\n+\t(ashiftrt:DI (match_operand:DI 1 \"s_register_operand\" \" w\")\n+\t\t     (match_operand:DI 2 \"const_int_operand\"  \" i\")))]\n+  \"TARGET_NEON && reload_completed\n+   && INTVAL (operands[2]) > 0 && INTVAL (operands[2]) <= 64\"\n+  \"vshr.s64\\t%P0, %P1, %2\"\n+  [(set_attr \"neon_type\" \"neon_vshl_ddd\")]\n+)\n+\n+(define_insn \"lshrdi3_neon_imm_noclobber\"\n+  [(set (match_operand:DI 0 \"s_register_operand\"\t      \"=w\")\n+\t(lshiftrt:DI (match_operand:DI 1 \"s_register_operand\" \" w\")\n+\t\t     (match_operand:DI 2 \"const_int_operand\"  \" i\")))]\n+  \"TARGET_NEON && reload_completed\n+   && INTVAL (operands[2]) > 0 && INTVAL (operands[2]) <= 64\"\n+  \"vshr.u64\\t%P0, %P1, %2\"\n+  [(set_attr \"neon_type\" \"neon_vshl_ddd\")]\n+)\n+\n+;; ashrdi3_neon\n+;; lshrdi3_neon\n+(define_insn_and_split \"<shift>di3_neon\"\n+  [(set (match_operand:DI 0 \"s_register_operand\"\t     \"= w, w,?&r,?r,?w,?w\")\n+\t(rshifts:DI (match_operand:DI 1 \"s_register_operand\" \" 0w, w, 0r, r,0w, w\")\n+\t\t    (match_operand:SI 2 \"reg_or_int_operand\" \"  r, i,  r, i, r, i\")))\n+   (clobber (match_scratch:SI 3\t\t\t\t     \"=2r, X, &r, X,2r, X\"))\n+   (clobber (match_scratch:SI 4\t\t\t\t     \"= X, X, &r, X, X, X\"))\n+   (clobber (match_scratch:DI 5\t\t\t\t     \"=&w, X,  X, X,&w, X\"))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"TARGET_NEON\"\n+  \"#\"\n+  \"TARGET_NEON && reload_completed\"\n+  [(const_int 0)]\n+  \"\n+  {\n+    if (IS_VFP_REGNUM (REGNO (operands[0])))\n+      {\n+\tif (CONST_INT_P (operands[2]))\n+\t  {\n+\t    if (INTVAL (operands[2]) < 1)\n+\t      {\n+\t        emit_insn (gen_movdi (operands[0], operands[1]));\n+\t\tDONE;\n+\t      }\n+\t    else if (INTVAL (operands[2]) > 64)\n+\t      operands[2] = gen_rtx_CONST_INT (VOIDmode, 64);\n+\n+\t    /* Ditch the unnecessary clobbers.  */\n+\t    emit_insn (gen_<shift>di3_neon_imm_noclobber (operands[0],\n+\t\t\t\t\t\t\t  operands[1],\n+\t\t\t\t\t\t\t  operands[2]));\n+\t  }\n+\telse \n+\t  {\n+\t    /* We must use a negative left-shift.  */\n+\t    emit_insn (gen_negsi2 (operands[3], operands[2]));\n+\t    emit_insn (gen_neon_load_count (operands[5], operands[3]));\n+\t    emit_insn (gen_<shifttype>_shift_di3_neon (operands[0], operands[1],\n+\t\t\t\t\t\t       operands[5]));\n+\t  }\n+      }\n+    else\n+      {\n+\tif (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 1)\n+\t  /* This clobbers CC.  */\n+\t  emit_insn (gen_arm_<shift>di3_1bit (operands[0], operands[1]));\n+\telse\n+\t  /* This clobbers CC (ASHIFTRT by register only).  */\n+\t  arm_emit_coreregs_64bit_shift (<CODE>, operands[0], operands[1],\n+\t\t\t\t \t operands[2], operands[3], operands[4]);\n+      }\n+\n+    DONE;\n+  }\"\n+  [(set_attr \"arch\" \"nota8,nota8,*,*,onlya8,onlya8\")\n+   (set_attr \"opt\" \"*,*,speed,speed,*,*\")]\n+)\n+\n ;; Widening operations\n \n (define_insn \"widen_ssum<mode>3\""}]}