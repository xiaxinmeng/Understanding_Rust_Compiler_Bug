{"sha": "5046aff56bbd9b2911799ad1e26b7c538fcc513e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTA0NmFmZjU2YmJkOWIyOTExNzk5YWQxZTI2YjdjNTM4ZmNjNTEzZQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-10-08T16:21:55Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-10-08T16:21:55Z"}, "message": "[multiple changes]\n\n2006-10-05  Erik Edelmann <edelmann@gcc.gnu.org>\n\t    Paul Thomas <pault@gcc.gnu.org>\n\n\tPR fortran/20541\n\t* interface.c (gfc_compare_derived_types): Add comparison of\n\tthe allocatable field.\n\t* intrinsic.c (add_subroutines): Add MOVE_ALLOC.\n\t* trans-expr.c (gfc_conv_aliased_arg, gfc_trans_subarray_assign,\n\tgfc_trans_subcomponent_assign, gfc_conv_string_parameter,\n\tgfc_trans_scalar_assign): Add extra arguments l_is_temp\n\tand r_is_var to references to latter function.\n\t(gfc_conv_function_call): Add enum for types of argument and\n\tan associated variable parm_kind. Deallocate components of\n\tINTENT(OUT) and non-variable arrays.\n\t(gfc_trans_subcomponent_assign): Add block to assign arrays\n\tto allocatable components.\n\t(gfc_trans_scalar_assign): Add block to handle assignments of\n\tderived types with allocatable components, using the above new\n\targuments to control allocation/deallocation of memory and the\n\tcopying of allocated arrays.\n\t* trans-array.c (gfc_array_allocate): Remove old identification \n\tof pointer and replace with that of an allocatable array. Add\n\tnullify of structures with allocatable components. \n\t(gfc_conv_array_initializer): Treat EXPR_NULL.\n\t(gfc_conv_array_parameter): Deallocate allocatable components\n\tof non-variable structures.\n\t(gfc_trans_dealloc_allocated): Use second argument of library\n\tdeallocate to inhibit, without error, freeing NULL pointers.\n\t(get_full_array_size): New function to return the size of a\n\tfull array.\n\t(gfc_duplicate_allocatable): New function to allocate and copy\n\tallocated data.\n\t(structure_alloc_comps): New recursive function to deallocate,\n\tnullify or copy allocatable components.\n\t(gfc_nullify_alloc_comp, gfc_deallocate_alloc_comp,\n\tgfc_copy_alloc_comp): New interface functions to call previous.\n\t(gfc_trans_deferred_array): Add the code to nullify allocatable\n\tcomponents, when entering scope, and to deallocate them on\n\tleaving. Do not call gfc_trans_static_array_pointer and return\n\tfor structures with allocatable components and default\n\tinitializers.\n\t* symbol.c (gfc_set_component_attr): Set allocatable field.\n\t(gfc_get_component_attr): Set the allocatable attribute.\n\t* intrinsic.h : Prototype for gfc_check_move_alloc.\n\t* decl.c (build_struct): Apply TR15581 constraints for\n\tallocatable components.\n\t(variable_decl): Default initializer is always NULL for\n\tallocatable components.\n\t(match_attr_spec): Allow, or not, allocatable components,\n\taccording to the standard in force.\n\t* trans-array.h : Prototypes for gfc_nullify_alloc_comp,\n\tgfc_deallocate_alloc_comp, gfc_copy_alloc_comp and\n\tgfc_duplicate_allocatable.\n\t* gfortran.texi : Add mention of TR15581 extensions.\n\t* gfortran.h : Add attribute alloc_comp, add\n\tgfc_components field allocatable and add the prototype\n\tfor gfc_expr_to_initialize.\n\t* trans-stmt.c (generate_loop_for_temp_to_lhs,\n\tgenerate_loop_for_rhs_to_temp, gfc_trans_where_assign,\n\tgfc_trans_where_3): Add extra arguments to calls to\n\tgfc_trans_scalar_assign and set appropriately.\n\t(gfc_trans_allocate): Nullify allocatable components.\n\t(gfc_trans_deallocate): Deallocate to ultimate allocatable\n\tcomponents but stop at ultimate pointer components.\n\t* module.c (mio_symbol_attribute, mio_symbol_attribute,\n\tmio_component): Add module support for allocatable\n\tcomponents.\n\t* trans-types.c (gfc_get_derived_type): Treat allocatable\n\tcomponents.\n\t* trans.h : Add two boolean arguments to\n\tgfc_trans_scalar_assign.\n\t* resolve.c (resolve_structure_cons): Check conformance of\n\tconstructor element and the component.\n\t(resolve_allocate_expr): Add expression to nullify the\n\tconstructor expression for allocatable components.\n\t(resolve_transfer): Inhibit I/O of derived types with\n\tallocatable components.\n\t(resolve_fl_derived): Skip check of bounds of allocatable\n\tcomponents.\n\t* trans-decl.c (gfc_get_symbol_decl): Add derived types\n\twith allocatable components to deferred variable.\n\t(gfc_trans_deferred_vars): Make calls for derived types\n\twith allocatable components to gfc_trans_deferred_array.\n\t(gfc_generate_function_code): Nullify allocatable\n\tcomponent function result on entry.\n\t* parse.c (parse_derived): Set symbol attr.allocatable if\n\tallocatable components are present.\n\t* check.c (gfc_check_allocated): Enforce attr.allocatable\n\tfor intrinsic arguments.\n\t(gfc_check_move_alloc): Check arguments of move_alloc.\n\t* primary.c (gfc_variable_attr): Set allocatable attribute.\n\t* intrinsic.texi : Add index entry and section for\n\tfor move_alloc.\n\n\tPR fortran/29115\n\t* resolve.c (resolve_structure_cons): It is an error if the\n\tpointer component elements of a derived type constructor are\n\tnot pointer or target.\n\n\n\tPR fortran/29211\n\t* trans-stmt.c (generate_loop_for_temp_to_lhs,\n\tgenerate_loop_for_rhs_to_temp): Provide a string length for\n\tthe temporary by copying that of the other side of the scalar\n\tassignment.\n\n\n2006-10-05  Paul Thomas  <pault@gcc.gnu.org>\n\t    Erik Edelmann  <edelmann@gcc.gnu.org>\n\n\tPR libgfortran/20541\n\t* Makefile.in : Add move_alloc.\n\t* intrinsics/move_alloc.c: New function.\n\t* Makefile.am : Add move_alloc.\n\n\n\n2006-10-05  Erik Edelmann  <edelmann@gcc.gnu.org>\n\t    Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/20541\n\t* gfortran.dg/alloc_comp_basics_1.f90: New test.\n\t* gfortran.dg/alloc_comp_basics_2.f90: New test.\n\t* gfortran.dg/alloc_comp_assign_1.f90: New test.\n\t* gfortran.dg/alloc_comp_assign_2.f90: New test.\n\t* gfortran.dg/alloc_comp_assign_3.f90: New test.\n\t* gfortran.dg/alloc_comp_assign_4.f90: New test.\n\t* gfortran.dg/alloc_comp_constraint_1.f90: New test.\n\t* gfortran.dg/alloc_comp_constraint_2.f90: New test.\n\t* gfortran.dg/alloc_comp_constraint_3.f90: New test.\n\t* gfortran.dg/alloc_comp_constructor_1.f90: New test.\n\t* gfortran.dg/alloc_comp_constructor_2.f90: New test.\n\t* gfortran.dg/alloc_comp_initializer_1.f90: New test.\n\t* gfortran.dg/alloc_comp_std.f90: New test.\n\t* gfortran.dg/move_alloc.f90: New test.\n\n\tPR fortran/29115\n\t* gfortran.dg/derived_constructor_comps_2.f90: New test.\n\n\tPR fortran/29211\n\t* gfortran.dg/forall_char_dependencies_1.f90: New test.\n\nFrom-SVN: r117558", "tree": {"sha": "fdb6be945aa00dac05524839d5b40aa79575f789", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fdb6be945aa00dac05524839d5b40aa79575f789"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5046aff56bbd9b2911799ad1e26b7c538fcc513e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5046aff56bbd9b2911799ad1e26b7c538fcc513e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5046aff56bbd9b2911799ad1e26b7c538fcc513e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5046aff56bbd9b2911799ad1e26b7c538fcc513e/comments", "author": null, "committer": null, "parents": [{"sha": "4afa41f130aad8e6b78d825b99abcd0b36faa0c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4afa41f130aad8e6b78d825b99abcd0b36faa0c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4afa41f130aad8e6b78d825b99abcd0b36faa0c4"}], "stats": {"total": 1978, "additions": 1875, "deletions": 103}, "files": [{"sha": "9406e5b29f1262e69cee7a1bae0da5750f9bb8ea", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=5046aff56bbd9b2911799ad1e26b7c538fcc513e", "patch": "@@ -1,3 +1,111 @@\n+2006-10-08  Erik Edelmann <edelmann@gcc.gnu.org>\n+\t    Paul Thomas <pault@gcc.gnu.org>\n+\n+\tPR fortran/20541\n+\t* interface.c (gfc_compare_derived_types): Add comparison of\n+\tthe allocatable field.\n+\t* intrinsic.c (add_subroutines): Add MOVE_ALLOC.\n+\t* trans-expr.c (gfc_conv_aliased_arg, gfc_trans_subarray_assign,\n+\tgfc_trans_subcomponent_assign, gfc_conv_string_parameter,\n+\tgfc_trans_scalar_assign): Add extra arguments l_is_temp\n+\tand r_is_var to references to latter function.\n+\t(gfc_conv_function_call): Add enum for types of argument and\n+\tan associated variable parm_kind. Deallocate components of\n+\tINTENT(OUT) and non-variable arrays.\n+\t(gfc_trans_subcomponent_assign): Add block to assign arrays\n+\tto allocatable components.\n+\t(gfc_trans_scalar_assign): Add block to handle assignments of\n+\tderived types with allocatable components, using the above new\n+\targuments to control allocation/deallocation of memory and the\n+\tcopying of allocated arrays.\n+\t* trans-array.c (gfc_array_allocate): Remove old identification \n+\tof pointer and replace with that of an allocatable array. Add\n+\tnullify of structures with allocatable components. \n+\t(gfc_conv_array_initializer): Treat EXPR_NULL.\n+\t(gfc_conv_array_parameter): Deallocate allocatable components\n+\tof non-variable structures.\n+\t(gfc_trans_dealloc_allocated): Use second argument of library\n+\tdeallocate to inhibit, without error, freeing NULL pointers.\n+\t(get_full_array_size): New function to return the size of a\n+\tfull array.\n+\t(gfc_duplicate_allocatable): New function to allocate and copy\n+\tallocated data.\n+\t(structure_alloc_comps): New recursive function to deallocate,\n+\tnullify or copy allocatable components.\n+\t(gfc_nullify_alloc_comp, gfc_deallocate_alloc_comp,\n+\tgfc_copy_alloc_comp): New interface functions to call previous.\n+\t(gfc_trans_deferred_array): Add the code to nullify allocatable\n+\tcomponents, when entering scope, and to deallocate them on\n+\tleaving. Do not call gfc_trans_static_array_pointer and return\n+\tfor structures with allocatable components and default\n+\tinitializers.\n+\t* symbol.c (gfc_set_component_attr): Set allocatable field.\n+\t(gfc_get_component_attr): Set the allocatable attribute.\n+\t* intrinsic.h : Prototype for gfc_check_move_alloc.\n+\t* decl.c (build_struct): Apply TR15581 constraints for\n+\tallocatable components.\n+\t(variable_decl): Default initializer is always NULL for\n+\tallocatable components.\n+\t(match_attr_spec): Allow, or not, allocatable components,\n+\taccording to the standard in force.\n+\t* trans-array.h : Prototypes for gfc_nullify_alloc_comp,\n+\tgfc_deallocate_alloc_comp, gfc_copy_alloc_comp and\n+\tgfc_duplicate_allocatable.\n+\t* gfortran.texi : Add mention of TR15581 extensions.\n+\t* gfortran.h : Add attribute alloc_comp, add\n+\tgfc_components field allocatable and add the prototype\n+\tfor gfc_expr_to_initialize.\n+\t* trans-stmt.c (generate_loop_for_temp_to_lhs,\n+\tgenerate_loop_for_rhs_to_temp, gfc_trans_where_assign,\n+\tgfc_trans_where_3): Add extra arguments to calls to\n+\tgfc_trans_scalar_assign and set appropriately.\n+\t(gfc_trans_allocate): Nullify allocatable components.\n+\t(gfc_trans_deallocate): Deallocate to ultimate allocatable\n+\tcomponents but stop at ultimate pointer components.\n+\t* module.c (mio_symbol_attribute, mio_symbol_attribute,\n+\tmio_component): Add module support for allocatable\n+\tcomponents.\n+\t* trans-types.c (gfc_get_derived_type): Treat allocatable\n+\tcomponents.\n+\t* trans.h : Add two boolean arguments to\n+\tgfc_trans_scalar_assign.\n+\t* resolve.c (resolve_structure_cons): Check conformance of\n+\tconstructor element and the component.\n+\t(resolve_allocate_expr): Add expression to nullify the\n+\tconstructor expression for allocatable components.\n+\t(resolve_transfer): Inhibit I/O of derived types with\n+\tallocatable components.\n+\t(resolve_fl_derived): Skip check of bounds of allocatable\n+\tcomponents.\n+\t* trans-decl.c (gfc_get_symbol_decl): Add derived types\n+\twith allocatable components to deferred variable.\n+\t(gfc_trans_deferred_vars): Make calls for derived types\n+\twith allocatable components to gfc_trans_deferred_array.\n+\t(gfc_generate_function_code): Nullify allocatable\n+\tcomponent function result on entry.\n+\t* parse.c (parse_derived): Set symbol attr.allocatable if\n+\tallocatable components are present.\n+\t* check.c (gfc_check_allocated): Enforce attr.allocatable\n+\tfor intrinsic arguments.\n+\t(gfc_check_move_alloc): Check arguments of move_alloc.\n+\t* primary.c (gfc_variable_attr): Set allocatable attribute.\n+\t* intrinsic.texi : Add index entry and section for\n+\tfor move_alloc.\n+\n+2006-10-08  Paul Thomas <pault@gcc.gnu.org>\n+\n+\tPR fortran/29115\n+\t* resolve.c (resolve_structure_cons): It is an error if the\n+\tpointer component elements of a derived type constructor are\n+\tnot pointer or target.\n+\n+\n+\tPR fortran/29211\n+\t* trans-stmt.c (generate_loop_for_temp_to_lhs,\n+\tgenerate_loop_for_rhs_to_temp): Provide a string length for\n+\tthe temporary by copying that of the other side of the scalar\n+\tassignment.\n+\n 2006-10-08  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/28585"}, {"sha": "fdbd0038835a7e3fb64d963b103fad1c69da32cd", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 62, "deletions": 1, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=5046aff56bbd9b2911799ad1e26b7c538fcc513e", "patch": "@@ -477,13 +477,16 @@ gfc_check_all_any (gfc_expr * mask, gfc_expr * dim)\n try\n gfc_check_allocated (gfc_expr * array)\n {\n+  symbol_attribute attr;\n+\n   if (variable_check (array, 0) == FAILURE)\n     return FAILURE;\n \n   if (array_check (array, 0) == FAILURE)\n     return FAILURE;\n \n-  if (!array->symtree->n.sym->attr.allocatable)\n+  attr = gfc_variable_attr (array, NULL);\n+  if (!attr.allocatable)\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L must be ALLOCATABLE\",\n \t\t gfc_current_intrinsic_arg[0], gfc_current_intrinsic,\n@@ -1814,6 +1817,64 @@ gfc_check_merge (gfc_expr * tsource, gfc_expr * fsource, gfc_expr * mask)\n   return SUCCESS;\n }\n \n+try\n+gfc_check_move_alloc (gfc_expr * from, gfc_expr * to)\n+{\n+  symbol_attribute attr;\n+\n+  if (variable_check (from, 0) == FAILURE)\n+    return FAILURE;\n+\n+  if (array_check (from, 0) == FAILURE)\n+    return FAILURE;\n+\n+  attr = gfc_variable_attr (from, NULL);\n+  if (!attr.allocatable)\n+    {\n+      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be ALLOCATABLE\",\n+\t\t gfc_current_intrinsic_arg[0], gfc_current_intrinsic,\n+\t\t &from->where);\n+      return FAILURE;\n+    }\n+\n+  if (variable_check (to, 0) == FAILURE)\n+    return FAILURE;\n+\n+  if (array_check (to, 0) == FAILURE)\n+    return FAILURE;\n+\n+  attr = gfc_variable_attr (to, NULL);\n+  if (!attr.allocatable)\n+    {\n+      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be ALLOCATABLE\",\n+\t\t gfc_current_intrinsic_arg[0], gfc_current_intrinsic,\n+\t\t &to->where);\n+      return FAILURE;\n+    }\n+\n+  if (same_type_check (from, 0, to, 1) == FAILURE)\n+    return FAILURE;\n+\n+  if (to->rank != from->rank)\n+    {\n+      gfc_error (\"the '%s' and '%s' arguments of '%s' intrinsic at %L must \"\n+\t\t \"have the same rank %d/%d\", gfc_current_intrinsic_arg[0],\n+\t\t gfc_current_intrinsic_arg[1], gfc_current_intrinsic,\n+\t\t &to->where,  from->rank, to->rank);\n+      return FAILURE;\n+    }\n+\n+  if (to->ts.kind != from->ts.kind)\n+    {\n+      gfc_error (\"the '%s' and '%s' arguments of '%s' intrinsic at %L must \"\n+\t\t \"be of the same kind %d/%d\", gfc_current_intrinsic_arg[0],\n+\t\t gfc_current_intrinsic_arg[1], gfc_current_intrinsic,\n+\t\t &to->where, from->ts.kind, to->ts.kind);\n+      return FAILURE;\n+    }\n+\n+  return SUCCESS;\n+}\n \n try\n gfc_check_nearest (gfc_expr * x, gfc_expr * s)"}, {"sha": "a9a11c048515bf4112a52b47bb4571148cfdd55e", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 49, "deletions": 10, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=5046aff56bbd9b2911799ad1e26b7c538fcc513e", "patch": "@@ -962,14 +962,31 @@ build_struct (const char *name, gfc_charlen * cl, gfc_expr ** init,\n \n   /* Check array components.  */\n   if (!c->dimension)\n-    return SUCCESS;\n+    {\n+      if (c->allocatable)\n+\t{\n+\t  gfc_error (\"Allocatable component at %C must be an array\");\n+\t  return FAILURE;\n+\t}\n+      else\n+\treturn SUCCESS;\n+    }\n \n   if (c->pointer)\n     {\n       if (c->as->type != AS_DEFERRED)\n \t{\n-\t  gfc_error (\"Pointer array component of structure at %C \"\n-\t\t     \"must have a deferred shape\");\n+\t  gfc_error (\"Pointer array component of structure at %C must have a \"\n+\t\t     \"deferred shape\");\n+\t  return FAILURE;\n+\t}\n+    }\n+  else if (c->allocatable)\n+    {\n+      if (c->as->type != AS_DEFERRED)\n+\t{\n+\t  gfc_error (\"Allocatable component of structure at %C must have a \"\n+\t\t     \"deferred shape\");\n \t  return FAILURE;\n \t}\n     }\n@@ -1284,6 +1301,14 @@ variable_decl (int elem)\n \t}\n     }\n \n+  if (initializer != NULL && current_attr.allocatable\n+\t&& gfc_current_state () == COMP_DERIVED)\n+    {\n+      gfc_error (\"Initialization of allocatable component at %C is not allowed\");\n+      m = MATCH_ERROR;\n+      goto cleanup;\n+    }\n+\n   /* Check if we are parsing an enumeration and if the current enumerator\n      variable has an initializer or not. If it does not have an\n      initializer, the initialization value of the previous enumerator \n@@ -1315,8 +1340,9 @@ variable_decl (int elem)\n     t = add_init_expr_to_sym (name, &initializer, &var_locus);\n   else\n     {\n-      if (current_ts.type == BT_DERIVED && !current_attr.pointer\n-\t  && !initializer)\n+      if (current_ts.type == BT_DERIVED\n+\t    && !current_attr.pointer\n+\t    && !initializer)\n \tinitializer = gfc_default_initializer (&current_ts);\n       t = build_struct (name, cl, &initializer, &as);\n     }\n@@ -2141,11 +2167,24 @@ match_attr_spec (void)\n \t  && d != DECL_DIMENSION && d != DECL_POINTER\n \t  && d != DECL_COLON && d != DECL_NONE)\n \t{\n-\n-\t  gfc_error (\"Attribute at %L is not allowed in a TYPE definition\",\n-\t\t     &seen_at[d]);\n-\t  m = MATCH_ERROR;\n-\t  goto cleanup;\n+\t  if (d == DECL_ALLOCATABLE)\n+\t    {\n+\t      if (gfc_notify_std (GFC_STD_F2003, \n+\t\t\t\t   \"In the selected standard, the ALLOCATABLE \"\n+\t\t\t\t   \"attribute at %C is not allowed in a TYPE \"\n+\t\t\t\t   \"definition\") == FAILURE)         \n+\t\t{\n+\t\t  m = MATCH_ERROR;\n+\t\t  goto cleanup;\n+\t\t}\n+            }\n+          else\n+\t    {\n+\t      gfc_error (\"Attribute at %L is not allowed in a TYPE definition\",\n+\t\t\t  &seen_at[d]);\n+\t      m = MATCH_ERROR;\n+\t      goto cleanup;\n+\t    }\n \t}\n \n       if ((d == DECL_PRIVATE || d == DECL_PUBLIC)"}, {"sha": "2bf980cfa2590c474bbde355fd7daf7e14432c7d", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=5046aff56bbd9b2911799ad1e26b7c538fcc513e", "patch": "@@ -2406,7 +2406,7 @@ gfc_default_initializer (gfc_typespec *ts)\n   /* See if we have a default initializer.  */\n   for (c = ts->derived->components; c; c = c->next)\n     {\n-      if (c->initializer && init == NULL)\n+      if ((c->initializer || c->allocatable) && init == NULL)\n         init = gfc_get_expr ();\n     }\n \n@@ -2430,6 +2430,13 @@ gfc_default_initializer (gfc_typespec *ts)\n \n       if (c->initializer)\n         tail->expr = gfc_copy_expr (c->initializer);\n+\n+      if (c->allocatable)\n+\t{\n+\t  tail->expr = gfc_get_expr ();\n+\t  tail->expr->expr_type = EXPR_NULL;\n+\t  tail->expr->ts = c->ts;\n+\t}\n     }\n   return init;\n }"}, {"sha": "5ba7ad4fc849bd52e34086fd5519789b2908daf8", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=5046aff56bbd9b2911799ad1e26b7c538fcc513e", "patch": "@@ -532,6 +532,9 @@ typedef struct\n   /* Special attributes for Cray pointers, pointees.  */\n   unsigned cray_pointer:1, cray_pointee:1;\n \n+  /* The symbol is a derived type with allocatable components, possibly nested.\n+   */\n+  unsigned alloc_comp:1;\n }\n symbol_attribute;\n \n@@ -649,7 +652,7 @@ typedef struct gfc_component\n   const char *name;\n   gfc_typespec ts;\n \n-  int pointer, dimension;\n+  int pointer, allocatable, dimension;\n   gfc_array_spec *as;\n \n   tree backend_decl;\n@@ -1972,6 +1975,7 @@ void gfc_resolve_omp_do_blocks (gfc_code *, gfc_namespace *);\n void gfc_free_actual_arglist (gfc_actual_arglist *);\n gfc_actual_arglist *gfc_copy_actual_arglist (gfc_actual_arglist *);\n const char *gfc_extract_int (gfc_expr *, int *);\n+gfc_expr *gfc_expr_to_initialize (gfc_expr *);\n \n gfc_expr *gfc_build_conversion (gfc_expr *);\n void gfc_free_ref_list (gfc_ref *);"}, {"sha": "a3c80f2293a3cc0e523f61c63dd07c07a90c959a", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=5046aff56bbd9b2911799ad1e26b7c538fcc513e", "patch": "@@ -374,6 +374,9 @@ gfc_compare_derived_types (gfc_symbol * derived1, gfc_symbol * derived2)\n       if (dt1->dimension != dt2->dimension)\n \treturn 0;\n \n+     if (dt1->allocatable != dt2->allocatable)\n+\treturn 0;\n+\n       if (dt1->dimension && gfc_compare_array_spec (dt1->as, dt2->as) == 0)\n \treturn 0;\n "}, {"sha": "b0e32ecff4b5bac25c979aae4b1700463cbb2d6d", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=5046aff56bbd9b2911799ad1e26b7c538fcc513e", "patch": "@@ -2424,6 +2424,11 @@ add_subroutines (void)\n \t      length, BT_INTEGER, di, OPTIONAL, st, BT_INTEGER, di, OPTIONAL,\n \t      trim_name, BT_LOGICAL, dl, OPTIONAL);\n \n+  add_sym_2s (\"move_alloc\", 0, BT_UNKNOWN, 0, GFC_STD_F2003,\n+\t      gfc_check_move_alloc, NULL, NULL,\n+\t      f, BT_UNKNOWN, 0, REQUIRED,\n+\t      t, BT_UNKNOWN, 0, REQUIRED);\n+\n   add_sym_5s (\"mvbits\", 1, BT_UNKNOWN, 0, GFC_STD_F95,\n \t      gfc_check_mvbits, gfc_simplify_mvbits, gfc_resolve_mvbits,\n \t      f, BT_INTEGER, di, REQUIRED, fp, BT_INTEGER, di, REQUIRED,"}, {"sha": "15af912013337e037f066051a4c99873caedf335", "filename": "gcc/fortran/intrinsic.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ffortran%2Fintrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ffortran%2Fintrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.h?ref=5046aff56bbd9b2911799ad1e26b7c538fcc513e", "patch": "@@ -154,6 +154,7 @@ try gfc_check_free (gfc_expr *);\n try gfc_check_fstat_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n try gfc_check_gerror (gfc_expr *);\n try gfc_check_getlog (gfc_expr *);\n+try gfc_check_move_alloc (gfc_expr *, gfc_expr *);\n try gfc_check_mvbits (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *,\n \t\t      gfc_expr *);\n try gfc_check_random_number (gfc_expr *);"}, {"sha": "f77595615c2cbc467da121f57481f8250d9731b3", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=5046aff56bbd9b2911799ad1e26b7c538fcc513e", "patch": "@@ -181,6 +181,7 @@ Some intrinsics have documentation yet to be completed as indicated by 'document\n * @code{MINVAL}:        MINVAL,    Minimum value of an array\n * @code{MOD}:           MOD,       Remainder function\n * @code{MODULO}:        MODULO,    Modulo function\n+* @code{MOVE_ALLOC}:    MOVE_ALLOC, Move allocation from one object to another\n * @code{MVBITS}:        MVBITS,    Move bits from one integer to another\n * @code{NEAREST}:       NEAREST,   Nearest representable number\n * @code{NEW_LINE}:      NEW_LINE,  New line character\n@@ -5834,6 +5835,50 @@ Elemental subroutine\n \n \n \n+@node MOVE_ALLOC\n+@section @code{MOVE_ALLOC} --- Move allocation from one object to another\n+@findex @code{MOVE_ALLOC} intrinsic\n+@cindex MOVE_ALLOC\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{MOVE_ALLOC(SRC, DEST)} moves the allocation from @var{SRC} to\n+@var{DEST}.  @var{SRC} will become deallocated in the process.\n+\n+@item @emph{Option}:\n+f2003, gnu\n+\n+@item @emph{Class}:\n+Subroutine\n+\n+@item @emph{Syntax}:\n+@code{CALL MOVE_ALLOC(SRC, DEST)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .80\n+@item @var{SRC} @tab @code{ALLOCATABLE}, @code{INTENT(INOUT)}, may be of any type and kind.\n+@item @var{DEST} @tab @code{ALLOCATABLE}, @code{INTENT(OUT)}, shall be of the same type, kind and rank as @var{SRC}\n+@end multitable\n+\n+@item @emph{Return value}:\n+None\n+\n+@item @emph{Example}:\n+@smallexample\n+program test_move_alloc\n+    integer, allocatable :: a(:), b(:)\n+\n+    allocate(a(3))\n+    a = [ 1, 2, 3 ]\n+    call move_alloc(a, b)\n+    print *, allocated(a), allocated(b)\n+    print *, b\n+end program test_move_alloc\n+@end smallexample\n+@end table\n+\n+\n+\n @node NEAREST\n @section @code{NEAREST} --- Nearest representable number\n @findex @code{NEAREST} intrinsic"}, {"sha": "599342e5299b15fcb899f6443c56d836cf2a1187", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=5046aff56bbd9b2911799ad1e26b7c538fcc513e", "patch": "@@ -1435,7 +1435,7 @@ typedef enum\n   AB_DATA, AB_IN_NAMELIST, AB_IN_COMMON, \n   AB_FUNCTION, AB_SUBROUTINE, AB_SEQUENCE, AB_ELEMENTAL, AB_PURE,\n   AB_RECURSIVE, AB_GENERIC, AB_ALWAYS_EXPLICIT, AB_CRAY_POINTER,\n-  AB_CRAY_POINTEE, AB_THREADPRIVATE\n+  AB_CRAY_POINTEE, AB_THREADPRIVATE, AB_ALLOC_COMP\n }\n ab_attribute;\n \n@@ -1465,6 +1465,7 @@ static const mstring attr_bits[] =\n     minit (\"ALWAYS_EXPLICIT\", AB_ALWAYS_EXPLICIT),\n     minit (\"CRAY_POINTER\", AB_CRAY_POINTER),\n     minit (\"CRAY_POINTEE\", AB_CRAY_POINTEE),\n+    minit (\"ALLOC_COMP\", AB_ALLOC_COMP),\n     minit (NULL, -1)\n };\n \n@@ -1555,6 +1556,8 @@ mio_symbol_attribute (symbol_attribute * attr)\n \tMIO_NAME(ab_attribute) (AB_CRAY_POINTER, attr_bits);\n       if (attr->cray_pointee)\n \tMIO_NAME(ab_attribute) (AB_CRAY_POINTEE, attr_bits);\n+      if (attr->alloc_comp)\n+\tMIO_NAME(ab_attribute) (AB_ALLOC_COMP, attr_bits);\n \n       mio_rparen ();\n \n@@ -1644,6 +1647,9 @@ mio_symbol_attribute (symbol_attribute * attr)\n \t    case AB_CRAY_POINTEE:\n \t      attr->cray_pointee = 1;\n \t      break;\n+\t    case AB_ALLOC_COMP:\n+\t      attr->alloc_comp = 1;\n+\t      break;\n \t    }\n \t}\n     }\n@@ -1951,6 +1957,7 @@ mio_component (gfc_component * c)\n \n   mio_integer (&c->dimension);\n   mio_integer (&c->pointer);\n+  mio_integer (&c->allocatable);\n \n   mio_expr (&c->initializer);\n   mio_rparen ();"}, {"sha": "8861e161d6d9397a766a471e55fc70315363d830", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=5046aff56bbd9b2911799ad1e26b7c538fcc513e", "patch": "@@ -1499,6 +1499,8 @@ parse_derived (void)\n   int compiling_type, seen_private, seen_sequence, seen_component, error_flag;\n   gfc_statement st;\n   gfc_state_data s;\n+  gfc_symbol *sym;\n+  gfc_component *c;\n \n   error_flag = 0;\n \n@@ -1595,6 +1597,18 @@ parse_derived (void)\n \t}\n     }\n \n+  /* Look for allocatable components.  */\n+  sym = gfc_current_block ();\n+  for (c = sym->components; c; c = c->next)\n+    {\n+      if (c->allocatable || (c->ts.type == BT_DERIVED\n+\t\t    \t     && c->ts.derived->attr.alloc_comp))\n+\t{\n+\t  sym->attr.alloc_comp = 1;\n+\t  break;\n+\t}\n+     }\n+\n   pop_state ();\n }\n "}, {"sha": "1dd8626d5cf513cf7ad494017e05ff9dcc964c05", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=5046aff56bbd9b2911799ad1e26b7c538fcc513e", "patch": "@@ -1715,7 +1715,7 @@ match_varspec (gfc_expr * primary, int equiv_flag)\n symbol_attribute\n gfc_variable_attr (gfc_expr * expr, gfc_typespec * ts)\n {\n-  int dimension, pointer, target;\n+  int dimension, pointer, allocatable, target;\n   symbol_attribute attr;\n   gfc_ref *ref;\n \n@@ -1727,6 +1727,7 @@ gfc_variable_attr (gfc_expr * expr, gfc_typespec * ts)\n \n   dimension = attr.dimension;\n   pointer = attr.pointer;\n+  allocatable = attr.allocatable;\n \n   target = attr.target;\n   if (pointer)\n@@ -1747,12 +1748,12 @@ gfc_variable_attr (gfc_expr * expr, gfc_typespec * ts)\n \t    break;\n \n \t  case AR_SECTION:\n-\t    pointer = 0;\n+\t    allocatable = pointer = 0;\n \t    dimension = 1;\n \t    break;\n \n \t  case AR_ELEMENT:\n-\t    pointer = 0;\n+\t    allocatable = pointer = 0;\n \t    break;\n \n \t  case AR_UNKNOWN:\n@@ -1767,18 +1768,20 @@ gfc_variable_attr (gfc_expr * expr, gfc_typespec * ts)\n \t  *ts = ref->u.c.component->ts;\n \n \tpointer = ref->u.c.component->pointer;\n+\tallocatable = ref->u.c.component->allocatable;\n \tif (pointer)\n \t  target = 1;\n \n \tbreak;\n \n       case REF_SUBSTRING:\n-\tpointer = 0;\n+\tallocatable = pointer = 0;\n \tbreak;\n       }\n \n   attr.dimension = dimension;\n   attr.pointer = pointer;\n+  attr.allocatable = allocatable;\n   attr.target = target;\n \n   return attr;"}, {"sha": "e795044a9ae2bcdf5874c5dba7f9c8f20fdc1232", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 66, "deletions": 14, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=5046aff56bbd9b2911799ad1e26b7c538fcc513e", "patch": "@@ -593,6 +593,7 @@ resolve_structure_cons (gfc_expr * expr)\n   gfc_constructor *cons;\n   gfc_component *comp;\n   try t;\n+  symbol_attribute a;\n \n   t = SUCCESS;\n   cons = expr->value.constructor;\n@@ -615,6 +616,17 @@ resolve_structure_cons (gfc_expr * expr)\n \t  continue;\n \t}\n \n+      if (cons->expr->expr_type != EXPR_NULL\n+\t    && comp->as && comp->as->rank != cons->expr->rank\n+\t    && (comp->allocatable || cons->expr->rank))\n+\t{\n+\t  gfc_error (\"The rank of the element in the derived type \"\n+\t\t     \"constructor at %L does not match that of the \"\n+\t\t     \"component (%d/%d)\", &cons->expr->where,\n+\t\t     cons->expr->rank, comp->as ? comp->as->rank : 0);\n+\t  t = FAILURE;\n+\t}\n+\n       /* If we don't have the right type, try to convert it.  */\n \n       if (!gfc_compare_types (&cons->expr->ts, &comp->ts))\n@@ -629,6 +641,19 @@ resolve_structure_cons (gfc_expr * expr)\n \t  else\n \t    t = gfc_convert_type (cons->expr, &comp->ts, 1);\n \t}\n+\n+      if (!comp->pointer || cons->expr->expr_type == EXPR_NULL)\n+\tcontinue;\n+\n+      a = gfc_expr_attr (cons->expr);\n+\n+      if (!a.pointer && !a.target)\n+\t{\n+\t  t = FAILURE;\n+\t  gfc_error (\"The element in the derived type constructor at %L, \"\n+\t\t     \"for pointer component '%s' should be a POINTER or \"\n+\t\t     \"a TARGET\", &cons->expr->where, comp->name);\n+\t}\n     }\n \n   return t;\n@@ -3408,7 +3433,8 @@ find_sym_in_expr (gfc_symbol *sym, gfc_expr *e)\n \n /* Given the expression node e for an allocatable/pointer of derived type to be\n    allocated, get the expression node to be initialized afterwards (needed for\n-   derived types with default initializers).  */\n+   derived types with default initializers, and derived types with allocatable\n+   components that need nullification.)  */\n \n static gfc_expr *\n expr_to_initialize (gfc_expr * e)\n@@ -3532,8 +3558,7 @@ resolve_allocate_expr (gfc_expr * e, gfc_code * code)\n         init_st->loc = code->loc;\n         init_st->op = EXEC_ASSIGN;\n         init_st->expr = expr_to_initialize (e);\n-        init_st->expr2 = init_e;\n-\n+\tinit_st->expr2 = init_e;\n         init_st->next = code->next;\n         code->next = init_st;\n     }\n@@ -4164,6 +4189,13 @@ resolve_transfer (gfc_code * code)\n \t  return;\n \t}\n \n+      if (ts->derived->attr.alloc_comp)\n+\t{\n+\t  gfc_error (\"Data transfer element at %L cannot have \"\n+\t\t     \"ALLOCATABLE components\", &code->loc);\n+\t  return;\n+\t}\n+\n       if (derived_inaccessible (ts->derived))\n \t{\n \t  gfc_error (\"Data transfer element at %L cannot have \"\n@@ -5545,7 +5577,7 @@ resolve_fl_derived (gfc_symbol *sym)\n \t    }\n \t}\n \n-      if (c->pointer || c->as == NULL)\n+      if (c->pointer || c->allocatable ||  c->as == NULL)\n \tcontinue;\n \n       for (i = 0; i < c->as->rank; i++)\n@@ -5606,16 +5638,28 @@ resolve_fl_namelist (gfc_symbol *sym)\n \t}\n     }\n \n-    /* Reject namelist arrays that are not constant shape.  */\n-    for (nl = sym->namelist; nl; nl = nl->next)\n-      {\n-\tif (is_non_constant_shape_array (nl->sym))\n-\t  {\n-\t    gfc_error (\"The array '%s' must have constant shape to be \"\n-\t\t       \"a NAMELIST object at %L\", nl->sym->name,\n-\t\t       &sym->declared_at);\n-\t    return FAILURE;\n-\t  }\n+  /* Reject namelist arrays that are not constant shape.  */\n+  for (nl = sym->namelist; nl; nl = nl->next)\n+    {\n+      if (is_non_constant_shape_array (nl->sym))\n+\t{\n+\t  gfc_error (\"The array '%s' must have constant shape to be \"\n+\t\t     \"a NAMELIST object at %L\", nl->sym->name,\n+\t\t     &sym->declared_at);\n+\t  return FAILURE;\n+\t}\n+    }\n+\n+  /* Namelist objects cannot have allocatable components.  */\n+  for (nl = sym->namelist; nl; nl = nl->next)\n+    {\n+      if (nl->sym->ts.type == BT_DERIVED\n+\t    && nl->sym->ts.derived->attr.alloc_comp)\n+\t{\n+\t  gfc_error (\"NAMELIST object '%s' at %L cannot have ALLOCATABLE \"\n+\t\t     \"components\", nl->sym->name, &sym->declared_at);\n+\t  return FAILURE;\n+\t}\n     }\n \n   /* 14.1.2 A module or internal procedure represent local entities\n@@ -6370,6 +6414,14 @@ resolve_equivalence_derived (gfc_symbol *derived, gfc_symbol *sym, gfc_expr *e)\n       return FAILURE;\n     }\n \n+  /* Shall not have allocatable components. */\n+  if (derived->attr.alloc_comp)\n+    {\n+      gfc_error (\"Derived type variable '%s' at %L cannot have ALLOCATABLE \"\n+\t\t \"components to be an EQUIVALENCE object\",sym->name, &e->where);\n+      return FAILURE;\n+    }\n+\n   for (; c ; c = c->next)\n     {\n       d = c->ts.derived;"}, {"sha": "cd38ef8dae49786309d0d32a7bdaa5583bc035dd", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=5046aff56bbd9b2911799ad1e26b7c538fcc513e", "patch": "@@ -1523,6 +1523,7 @@ gfc_set_component_attr (gfc_component * c, symbol_attribute * attr)\n \n   c->dimension = attr->dimension;\n   c->pointer = attr->pointer;\n+  c->allocatable = attr->allocatable;\n }\n \n \n@@ -1536,6 +1537,7 @@ gfc_get_component_attr (symbol_attribute * attr, gfc_component * c)\n   gfc_clear_attr (attr);\n   attr->dimension = c->dimension;\n   attr->pointer = c->pointer;\n+  attr->allocatable = c->allocatable;\n }\n \n "}, {"sha": "f4d7ba5cca2687fb2a011d970835adfe3a31b13c", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 372, "deletions": 36, "changes": 408, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=5046aff56bbd9b2911799ad1e26b7c538fcc513e", "patch": "@@ -3236,32 +3236,27 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree pstat)\n   tree size;\n   gfc_expr **lower;\n   gfc_expr **upper;\n-  gfc_ref *ref;\n-  int allocatable_array;\n-  int must_be_pointer;\n+  gfc_ref *ref, *prev_ref = NULL;\n+  bool allocatable_array;\n \n   ref = expr->ref;\n \n-  /* In Fortran 95, components can only contain pointers, so that,\n-     in ALLOCATE (foo%bar(2)), bar must be a pointer component.\n-     We test this by checking for ref->next.\n-     An implementation of TR 15581 would need to change this.  */\n-\n-  if (ref)\n-    must_be_pointer = ref->next != NULL;\n-  else\n-    must_be_pointer = 0;\n-  \n   /* Find the last reference in the chain.  */\n   while (ref && ref->next != NULL)\n     {\n       gcc_assert (ref->type != REF_ARRAY || ref->u.ar.type == AR_ELEMENT);\n+      prev_ref = ref;\n       ref = ref->next;\n     }\n \n   if (ref == NULL || ref->type != REF_ARRAY)\n     return false;\n \n+  if (!prev_ref)\n+    allocatable_array = expr->symtree->n.sym->attr.allocatable;\n+  else\n+    allocatable_array = prev_ref->u.c.component->allocatable;\n+\n   /* Figure out the size of the array.  */\n   switch (ref->u.ar.type)\n     {\n@@ -3294,11 +3289,6 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree pstat)\n   tmp = gfc_conv_descriptor_data_addr (se->expr);\n   pointer = gfc_evaluate_now (tmp, &se->pre);\n \n-  if (must_be_pointer)\n-    allocatable_array = 0;\n-  else\n-    allocatable_array = expr->symtree->n.sym->attr.allocatable;\n-\n   if (TYPE_PRECISION (gfc_array_index_type) == 32)\n     {\n       if (allocatable_array)\n@@ -3325,6 +3315,14 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree pstat)\n   tmp = gfc_conv_descriptor_offset (se->expr);\n   gfc_add_modify_expr (&se->pre, tmp, offset);\n \n+  if (expr->ts.type == BT_DERIVED\n+\t&& expr->ts.derived->attr.alloc_comp)\n+    {\n+      tmp = gfc_nullify_alloc_comp (expr->ts.derived, se->expr,\n+\t\t\t\t    ref->u.ar.as->rank);\n+      gfc_add_expr_to_block (&se->pre, tmp);\n+    }\n+\n   return true;\n }\n \n@@ -3465,6 +3463,9 @@ gfc_conv_array_initializer (tree type, gfc_expr * expr)\n         }\n       break;\n \n+    case EXPR_NULL:\n+      return gfc_build_null_descriptor (type);\n+\n     default:\n       gcc_unreachable ();\n     }\n@@ -4547,6 +4548,17 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, int g77)\n   se->want_pointer = 1;\n   gfc_conv_expr_descriptor (se, expr, ss);\n \n+  /* Deallocate the allocatable components of structures that are\n+     not variable.  */\n+  if (expr->ts.type == BT_DERIVED\n+\t&& expr->ts.derived->attr.alloc_comp\n+\t&& expr->expr_type != EXPR_VARIABLE)\n+    {\n+      tmp = build_fold_indirect_ref (se->expr);\n+      tmp = gfc_deallocate_alloc_comp (expr->ts.derived, tmp, expr->rank);\n+      gfc_add_expr_to_block (&se->post, tmp);\n+    }\n+\n   if (g77)\n     {\n       desc = se->expr;\n@@ -4595,25 +4607,322 @@ tree\n gfc_trans_dealloc_allocated (tree descriptor)\n { \n   tree tmp;\n-  tree deallocate;\n+  tree ptr;\n+  tree var;\n   stmtblock_t block;\n \n   gfc_start_block (&block);\n-  deallocate = gfc_array_deallocate (descriptor, null_pointer_node);\n \n-  tmp = gfc_conv_descriptor_data_get (descriptor);\n-  tmp = build2 (NE_EXPR, boolean_type_node, tmp,\n-                build_int_cst (TREE_TYPE (tmp), 0));\n-  tmp = build3_v (COND_EXPR, tmp, deallocate, build_empty_stmt ());\n+  tmp = gfc_conv_descriptor_data_addr (descriptor);\n+  var = gfc_evaluate_now (tmp, &block);\n+  tmp = gfc_create_var (gfc_array_index_type, NULL);\n+  ptr = build_fold_addr_expr (tmp);\n+\n+  /* Call array_deallocate with an int* present in the second argument.\n+     Although it is ignored here, it's presence ensures that arrays that\n+     are already deallocated are ignored.  */\n+  tmp = gfc_chainon_list (NULL_TREE, var);\n+  tmp = gfc_chainon_list (tmp, ptr);\n+  tmp = build_function_call_expr (gfor_fndecl_deallocate, tmp);\n   gfc_add_expr_to_block (&block, tmp);\n+  return gfc_finish_block (&block);\n+}\n+\n+\n+/* This helper function calculates the size in words of a full array.  */\n+\n+static tree\n+get_full_array_size (stmtblock_t *block, tree decl, int rank)\n+{\n+  tree idx;\n+  tree nelems;\n+  tree tmp;\n+  idx = gfc_rank_cst[rank - 1];\n+  nelems = gfc_conv_descriptor_ubound (decl, idx);\n+  tmp = gfc_conv_descriptor_lbound (decl, idx);\n+  tmp = build2 (MINUS_EXPR, gfc_array_index_type, nelems, tmp);\n+  tmp = build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\ttmp, gfc_index_one_node);\n+  tmp = gfc_evaluate_now (tmp, block);\n+\n+  nelems = gfc_conv_descriptor_stride (decl, idx);\n+  tmp = build2 (MULT_EXPR, gfc_array_index_type, nelems, tmp);\n+  return gfc_evaluate_now (tmp, block);\n+}\n+\n+\n+/* Allocate dest to the same size as src, and copy src -> dest.  */\n+\n+tree\n+gfc_duplicate_allocatable(tree dest, tree src, tree type, int rank)\n+{\n+  tree tmp;\n+  tree size;\n+  tree nelems;\n+  tree args;\n+  tree null_cond;\n+  tree null_data;\n+  stmtblock_t block;\n+\n+  /* If the source is null, set the destination to null. */\n+  gfc_init_block (&block);\n+  gfc_conv_descriptor_data_set (&block, dest, null_pointer_node);\n+  null_data = gfc_finish_block (&block);\n+\n+  gfc_init_block (&block);\n+\n+  nelems = get_full_array_size (&block, src, rank);\n+  size = fold_build2 (MULT_EXPR, gfc_array_index_type, nelems,\n+\t\t      TYPE_SIZE_UNIT (gfc_get_element_type (type)));\n \n+  /* Allocate memory to the destination.  */\n+  tmp = gfc_chainon_list (NULL_TREE, size);\n+  if (gfc_index_integer_kind == 4)\n+    tmp = build_function_call_expr (gfor_fndecl_internal_malloc, tmp);\n+  else if (gfc_index_integer_kind == 8)\n+    tmp = build_function_call_expr (gfor_fndecl_internal_malloc64, tmp);\n+  else\n+    gcc_unreachable ();\n+  tmp = fold (convert (TREE_TYPE (gfc_conv_descriptor_data_get (src)),\n+\t      tmp));\n+  gfc_conv_descriptor_data_set (&block, dest, tmp);\n+\n+  /* We know the temporary and the value will be the same length,\n+     so can use memcpy.  */\n+  tmp = gfc_conv_descriptor_data_get (dest);\n+  args = gfc_chainon_list (NULL_TREE, tmp);\n+  tmp = gfc_conv_descriptor_data_get (src);\n+  args = gfc_chainon_list (args, tmp);\n+  args = gfc_chainon_list (args, size);\n+  tmp = built_in_decls[BUILT_IN_MEMCPY];\n+  tmp = build_function_call_expr (tmp, args);\n+  gfc_add_expr_to_block (&block, tmp);\n   tmp = gfc_finish_block (&block);\n \n-  return tmp;\n+  /* Null the destination if the source is null; otherwise do\n+     the allocate and copy.  */\n+  null_cond = gfc_conv_descriptor_data_get (src);\n+  null_cond = convert (pvoid_type_node, null_cond);\n+  null_cond = build2 (NE_EXPR, boolean_type_node, null_cond,\n+\t\t      null_pointer_node);\n+  return build3_v (COND_EXPR, null_cond, tmp, null_data);\n }\n \n \n-/* NULLIFY an allocatable/pointer array on function entry, free it on exit.  */\n+/* Recursively traverse an object of derived type, generating code to\n+   deallocate, nullify or copy allocatable components.  This is the work horse\n+   function for the functions named in this enum.  */\n+\n+enum {DEALLOCATE_ALLOC_COMP = 1, NULLIFY_ALLOC_COMP, COPY_ALLOC_COMP};\n+\n+static tree\n+structure_alloc_comps (gfc_symbol * der_type, tree decl,\n+\t\t       tree dest, int rank, int purpose)\n+{\n+  gfc_component *c;\n+  gfc_loopinfo loop;\n+  stmtblock_t fnblock;\n+  stmtblock_t loopbody;\n+  tree tmp;\n+  tree comp;\n+  tree dcmp;\n+  tree nelems;\n+  tree index;\n+  tree var;\n+  tree cdecl;\n+  tree ctype;\n+  tree vref, dref;\n+  tree null_cond = NULL_TREE;\n+\n+  gfc_init_block (&fnblock);\n+\n+  /* If this an array of derived types with allocatable components\n+     build a loop and recursively call this function.  */\n+  if (TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE\n+\t|| GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (decl)))\n+    {\n+      tmp = gfc_conv_array_data (decl);\n+      var = build_fold_indirect_ref (tmp);\n+\t\n+      /* Get the number of elements - 1 and set the counter.  */\n+      if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (decl)))\n+\t{\n+\t  /* Use the descriptor for an allocatable array.  Since this\n+\t     is a full array reference, we only need the descriptor\n+\t     information from dimension = rank.  */\n+\t  tmp = get_full_array_size (&fnblock, decl, rank);\n+\t  tmp = build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\ttmp, gfc_index_one_node);\n+\n+\t  null_cond = gfc_conv_descriptor_data_get (decl);\n+\t  null_cond = build2 (NE_EXPR, boolean_type_node, null_cond,\n+\t\t\t      build_int_cst (TREE_TYPE (tmp), 0));\n+\t}\n+      else\n+\t{\n+\t  /*  Otherwise use the TYPE_DOMAIN information.  */\n+\t  tmp =  array_type_nelts (TREE_TYPE (decl));\n+\t  tmp = fold_convert (gfc_array_index_type, tmp);\n+\t}\n+\n+      /* Remember that this is, in fact, the no. of elements - 1.  */\n+      nelems = gfc_evaluate_now (tmp, &fnblock);\n+      index = gfc_create_var (gfc_array_index_type, \"S\");\n+\n+      /* Build the body of the loop.  */\n+      gfc_init_block (&loopbody);\n+\n+      vref = gfc_build_array_ref (var, index);\n+\n+      if (purpose == COPY_ALLOC_COMP)\n+        {\n+          tmp = gfc_duplicate_allocatable (dest, decl, TREE_TYPE(decl), rank);\n+\t  gfc_add_expr_to_block (&fnblock, tmp);\n+\n+\t  tmp = build_fold_indirect_ref (gfc_conv_descriptor_data_get (dest));\n+\t  dref = gfc_build_array_ref (tmp, index);\n+\t  tmp = structure_alloc_comps (der_type, vref, dref, rank, purpose);\n+\t}\n+      else\n+        tmp = structure_alloc_comps (der_type, vref, NULL_TREE, rank, purpose);\n+\n+      gfc_add_expr_to_block (&loopbody, tmp);\n+\n+      /* Build the loop and return. */\n+      gfc_init_loopinfo (&loop);\n+      loop.dimen = 1;\n+      loop.from[0] = gfc_index_zero_node;\n+      loop.loopvar[0] = index;\n+      loop.to[0] = nelems;\n+      gfc_trans_scalarizing_loops (&loop, &loopbody);\n+      gfc_add_block_to_block (&fnblock, &loop.pre);\n+\n+      tmp = gfc_finish_block (&fnblock);\n+      if (null_cond != NULL_TREE)\n+\ttmp = build3_v (COND_EXPR, null_cond, tmp, build_empty_stmt ());\n+\n+      return tmp;\n+    }\n+\n+  /* Otherwise, act on the components or recursively call self to\n+     act on a chain of components. */\n+  for (c = der_type->components; c; c = c->next)\n+    {\n+      bool cmp_has_alloc_comps = (c->ts.type == BT_DERIVED)\n+\t\t\t\t    && c->ts.derived->attr.alloc_comp;\n+      cdecl = c->backend_decl;\n+      ctype = TREE_TYPE (cdecl);\n+\n+      switch (purpose)\n+\t{\n+\tcase DEALLOCATE_ALLOC_COMP:\n+\t  /* Do not deallocate the components of ultimate pointer\n+\t     components.  */\n+\t  if (cmp_has_alloc_comps && !c->pointer)\n+\t    {\n+\t      comp = build3 (COMPONENT_REF, ctype, decl, cdecl, NULL_TREE);\n+\t      rank = c->as ? c->as->rank : 0;\n+\t      tmp = structure_alloc_comps (c->ts.derived, comp, NULL_TREE,\n+\t\t\t\t\t   rank, purpose);\n+\t      gfc_add_expr_to_block (&fnblock, tmp);\n+\t    }\n+\n+\t  if (c->allocatable)\n+\t    {\n+\t      comp = build3 (COMPONENT_REF, ctype, decl, cdecl, NULL_TREE);\n+\t      tmp = gfc_trans_dealloc_allocated (comp);\n+\t      gfc_add_expr_to_block (&fnblock, tmp);\n+\t    }\n+\t  break;\n+\n+\tcase NULLIFY_ALLOC_COMP:\n+\t  if (c->pointer)\n+\t    continue;\n+\t  else if (c->allocatable)\n+\t    {\n+\t      comp = build3 (COMPONENT_REF, ctype, decl, cdecl, NULL_TREE);\n+\t      gfc_conv_descriptor_data_set (&fnblock, comp, null_pointer_node);\n+\t    }\n+          else if (cmp_has_alloc_comps)\n+\t    {\n+\t      comp = build3 (COMPONENT_REF, ctype, decl, cdecl, NULL_TREE);\n+\t      rank = c->as ? c->as->rank : 0;\n+\t      tmp = structure_alloc_comps (c->ts.derived, comp, NULL_TREE,\n+\t\t\t\t\t   rank, purpose);\n+\t      gfc_add_expr_to_block (&fnblock, tmp);\n+\t    }\n+\t  break;\n+\n+\tcase COPY_ALLOC_COMP:\n+\t  if (c->pointer)\n+\t    continue;\n+\n+\t  /* We need source and destination components.  */\n+\t  comp = build3 (COMPONENT_REF, ctype, decl, cdecl, NULL_TREE);\n+\t  dcmp = build3 (COMPONENT_REF, ctype, dest, cdecl, NULL_TREE);\n+\t  dcmp = fold_convert (TREE_TYPE (comp), dcmp);\n+\n+\t  if (c->allocatable && !cmp_has_alloc_comps)\n+\t    {\n+\t      tmp = gfc_duplicate_allocatable(dcmp, comp, ctype, c->as->rank);\n+\t      gfc_add_expr_to_block (&fnblock, tmp);\n+\t    }\n+\n+          if (cmp_has_alloc_comps)\n+\t    {\n+\t      rank = c->as ? c->as->rank : 0;\n+\t      tmp = fold_convert (TREE_TYPE (dcmp), comp);\n+\t      gfc_add_modify_expr (&fnblock, dcmp, tmp);\n+\t      tmp = structure_alloc_comps (c->ts.derived, comp, dcmp,\n+\t\t\t\t\t   rank, purpose);\n+\t      gfc_add_expr_to_block (&fnblock, tmp);\n+\t    }\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t  break;\n+\t}\n+    }\n+\n+  return gfc_finish_block (&fnblock);\n+}\n+\n+/* Recursively traverse an object of derived type, generating code to\n+   nullify allocatable components.  */\n+\n+tree\n+gfc_nullify_alloc_comp (gfc_symbol * der_type, tree decl, int rank)\n+{\n+  return structure_alloc_comps (der_type, decl, NULL_TREE, rank,\n+\t\t\t\tNULLIFY_ALLOC_COMP);\n+}\n+\n+\n+/* Recursively traverse an object of derived type, generating code to\n+   deallocate allocatable components.  */\n+\n+tree\n+gfc_deallocate_alloc_comp (gfc_symbol * der_type, tree decl, int rank)\n+{\n+  return structure_alloc_comps (der_type, decl, NULL_TREE, rank,\n+\t\t\t\tDEALLOCATE_ALLOC_COMP);\n+}\n+\n+\n+/* Recursively traverse an object of derived type, generating code to\n+   copy its allocatable components.  */\n+\n+tree\n+gfc_copy_alloc_comp (gfc_symbol * der_type, tree decl, tree dest, int rank)\n+{\n+  return structure_alloc_comps (der_type, decl, dest, rank, COPY_ALLOC_COMP);\n+}\n+\n+\n+/* NULLIFY an allocatable/pointer array on function entry, free it on exit.\n+   Do likewise, recursively if necessary, with the allocatable components of\n+   derived types.  */\n \n tree\n gfc_trans_deferred_array (gfc_symbol * sym, tree body)\n@@ -4623,16 +4932,22 @@ gfc_trans_deferred_array (gfc_symbol * sym, tree body)\n   tree descriptor;\n   stmtblock_t fnblock;\n   locus loc;\n+  int rank;\n+  bool sym_has_alloc_comp;\n+\n+  sym_has_alloc_comp = (sym->ts.type == BT_DERIVED)\n+\t\t\t  && sym->ts.derived->attr.alloc_comp;\n \n   /* Make sure the frontend gets these right.  */\n-  if (!(sym->attr.pointer || sym->attr.allocatable))\n-    fatal_error\n-      (\"Possible frontend bug: Deferred array size without pointer or allocatable attribute.\");\n+  if (!(sym->attr.pointer || sym->attr.allocatable || sym_has_alloc_comp))\n+    fatal_error (\"Possible frontend bug: Deferred array size without pointer, \"\n+\t\t \"allocatable attribute or derived type without allocatable \"\n+\t\t \"components.\");\n \n   gfc_init_block (&fnblock);\n \n   gcc_assert (TREE_CODE (sym->backend_decl) == VAR_DECL\n-                || TREE_CODE (sym->backend_decl) == PARM_DECL);\n+\t\t|| TREE_CODE (sym->backend_decl) == PARM_DECL);\n \n   if (sym->ts.type == BT_CHARACTER\n       && !INTEGER_CST_P (sym->ts.cl->backend_decl))\n@@ -4653,7 +4968,10 @@ gfc_trans_deferred_array (gfc_symbol * sym, tree body)\n   gfc_set_backend_locus (&sym->declared_at);\n   descriptor = sym->backend_decl;\n \n-  if (TREE_STATIC (descriptor))\n+  /* Although static, derived types with deafult initializers and\n+     allocatable components must not be nulled wholesale; instead they\n+     are treated component by component.  */\n+  if (TREE_STATIC (descriptor) && !sym_has_alloc_comp)\n     {\n       /* SAVEd variables are not freed on exit.  */\n       gfc_trans_static_array_pointer (sym);\n@@ -4662,22 +4980,40 @@ gfc_trans_deferred_array (gfc_symbol * sym, tree body)\n \n   /* Get the descriptor type.  */\n   type = TREE_TYPE (sym->backend_decl);\n-  if (!GFC_DESCRIPTOR_TYPE_P (type))\n+    \n+  if (sym_has_alloc_comp && !(sym->attr.pointer || sym->attr.allocatable))\n+    {\n+      rank = sym->as ? sym->as->rank : 0;\n+      tmp = gfc_nullify_alloc_comp (sym->ts.derived, descriptor, rank);\n+      gfc_add_expr_to_block (&fnblock, tmp);\n+    }\n+  else if (!GFC_DESCRIPTOR_TYPE_P (type))\n     {\n       /* If the backend_decl is not a descriptor, we must have a pointer\n \t to one.  */\n       descriptor = build_fold_indirect_ref (sym->backend_decl);\n       type = TREE_TYPE (descriptor);\n-      gcc_assert (GFC_DESCRIPTOR_TYPE_P (type));\n     }\n-\n+  \n   /* NULLIFY the data pointer.  */\n-  gfc_conv_descriptor_data_set (&fnblock, descriptor, null_pointer_node);\n+  if (GFC_DESCRIPTOR_TYPE_P (type))\n+    gfc_conv_descriptor_data_set (&fnblock, descriptor, null_pointer_node);\n \n   gfc_add_expr_to_block (&fnblock, body);\n \n   gfc_set_backend_locus (&loc);\n-  /* Allocatable arrays need to be freed when they go out of scope.  */\n+\n+  /* Allocatable arrays need to be freed when they go out of scope.\n+     The allocatable components of pointers must not be touched.  */\n+  if (sym_has_alloc_comp && !(sym->attr.function || sym->attr.result)\n+      && !sym->attr.pointer)\n+    {\n+      int rank;\n+      rank = sym->as ? sym->as->rank : 0;\n+      tmp = gfc_deallocate_alloc_comp (sym->ts.derived, descriptor, rank);\n+      gfc_add_expr_to_block (&fnblock, tmp);\n+    }\n+\n   if (sym->attr.allocatable)\n     {\n       tmp = gfc_trans_dealloc_allocated (sym->backend_decl);"}, {"sha": "3374c4ceac9eb14cd34778e7226f3e8573f5f87c", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=5046aff56bbd9b2911799ad1e26b7c538fcc513e", "patch": "@@ -43,6 +43,15 @@ tree gfc_trans_dummy_array_bias (gfc_symbol *, tree, tree);\n tree gfc_trans_g77_array (gfc_symbol *, tree);\n /* Generate code to deallocate an array, if it is allocated.  */\n tree gfc_trans_dealloc_allocated (tree);\n+\n+tree gfc_duplicate_allocatable(tree dest, tree src, tree type, int rank);\n+\n+tree gfc_nullify_alloc_comp (gfc_symbol *, tree, int);\n+\n+tree gfc_deallocate_alloc_comp (gfc_symbol *, tree, int);\n+\n+tree gfc_copy_alloc_comp (gfc_symbol *, tree, tree, int);\n+\n /* Add initialization for deferred arrays.  */\n tree gfc_trans_deferred_array (gfc_symbol *, tree);\n /* Generate an initializer for a static pointer or allocatable array.  */"}, {"sha": "4d410b101a7fbd8f47436112798f890614895787", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=5046aff56bbd9b2911799ad1e26b7c538fcc513e", "patch": "@@ -964,6 +964,9 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n \tGFC_DECL_PACKED_ARRAY (decl) = 1;\n     }\n \n+  if (sym->ts.type == BT_DERIVED && sym->ts.derived->attr.alloc_comp)\n+    gfc_defer_symbol_init (sym);\n+\n   gfc_finish_var_decl (decl, sym);\n \n   if (sym->ts.type == BT_CHARACTER)\n@@ -2572,6 +2575,8 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, tree fnbody)\n \n   for (sym = proc_sym->tlink; sym != proc_sym; sym = sym->tlink)\n     {\n+      bool sym_has_alloc_comp = (sym->ts.type == BT_DERIVED)\n+\t\t\t\t   && sym->ts.derived->attr.alloc_comp;\n       if (sym->attr.dimension)\n \t{\n \t  switch (sym->as->type)\n@@ -2614,13 +2619,18 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, tree fnbody)\n \t      break;\n \n \t    case AS_DEFERRED:\n-\t      fnbody = gfc_trans_deferred_array (sym, fnbody);\n+\t      if (!sym_has_alloc_comp)\n+\t\tfnbody = gfc_trans_deferred_array (sym, fnbody);\n \t      break;\n \n \t    default:\n \t      gcc_unreachable ();\n \t    }\n+\t  if (sym_has_alloc_comp)\n+\t    fnbody = gfc_trans_deferred_array (sym, fnbody);\n \t}\n+      else if (sym_has_alloc_comp)\n+\tfnbody = gfc_trans_deferred_array (sym, fnbody);\n       else if (sym->ts.type == BT_CHARACTER)\n \t{\n \t  gfc_get_backend_locus (&loc);\n@@ -2972,10 +2982,12 @@ gfc_generate_function_code (gfc_namespace * ns)\n   tree old_context;\n   tree decl;\n   tree tmp;\n+  tree tmp2;\n   stmtblock_t block;\n   stmtblock_t body;\n   tree result;\n   gfc_symbol *sym;\n+  int rank;\n \n   sym = ns->proc_name;\n \n@@ -3135,7 +3147,6 @@ gfc_generate_function_code (gfc_namespace * ns)\n   tmp = gfc_finish_block (&body);\n   /* Add code to create and cleanup arrays.  */\n   tmp = gfc_trans_deferred_vars (sym, tmp);\n-  gfc_add_expr_to_block (&block, tmp);\n \n   if (TREE_TYPE (DECL_RESULT (fndecl)) != void_type_node)\n     {\n@@ -3150,7 +3161,18 @@ gfc_generate_function_code (gfc_namespace * ns)\n       else\n \tresult = sym->result->backend_decl;\n \n-      if (result == NULL_TREE)\n+      if (result != NULL_TREE && sym->attr.function\n+\t    && sym->ts.type == BT_DERIVED\n+\t    && sym->ts.derived->attr.alloc_comp)\n+\t{\n+\t  rank = sym->as ? sym->as->rank : 0;\n+\t  tmp2 = gfc_nullify_alloc_comp (sym->ts.derived, result, rank);\n+\t  gfc_add_expr_to_block (&block, tmp2);\n+\t}\n+\n+     gfc_add_expr_to_block (&block, tmp);\n+\n+     if (result == NULL_TREE)\n \twarning (0, \"Function return value not set\");\n       else\n \t{\n@@ -3161,6 +3183,9 @@ gfc_generate_function_code (gfc_namespace * ns)\n \t  gfc_add_expr_to_block (&block, tmp);\n \t}\n     }\n+  else\n+    gfc_add_expr_to_block (&block, tmp);\n+\n \n   /* Add all the decls we created during processing.  */\n   decl = saved_function_decls;"}, {"sha": "c5a4be3917f7b3ebf053b5831e45eac6da9e0a6b", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 185, "deletions": 17, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=5046aff56bbd9b2911799ad1e26b7c538fcc513e", "patch": "@@ -1701,7 +1701,7 @@ gfc_conv_aliased_arg (gfc_se * parmse, gfc_expr * expr,\n \n   if (intent != INTENT_OUT)\n     {\n-      tmp = gfc_trans_scalar_assign (&lse, &rse, expr->ts.type);\n+      tmp = gfc_trans_scalar_assign (&lse, &rse, expr->ts, true, false);\n       gfc_add_expr_to_block (&body, tmp);\n       gcc_assert (rse.ss == gfc_ss_terminator);\n       gfc_trans_scalarizing_loops (&loop, &body);\n@@ -1792,7 +1792,7 @@ gfc_conv_aliased_arg (gfc_se * parmse, gfc_expr * expr,\n \n   gcc_assert (lse.ss == gfc_ss_terminator);\n \n-  tmp = gfc_trans_scalar_assign (&lse, &rse, expr->ts.type);\n+  tmp = gfc_trans_scalar_assign (&lse, &rse, expr->ts, false, false);\n   gfc_add_expr_to_block (&body, tmp);\n   \n   /* Generate the copying loops.  */\n@@ -1864,6 +1864,7 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n   gfc_ss *argss;\n   gfc_ss_info *info;\n   int byref;\n+  int parm_kind;\n   tree type;\n   tree var;\n   tree len;\n@@ -1877,6 +1878,7 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n   gfc_expr *e;\n   gfc_symbol *fsym;\n   stmtblock_t post;\n+  enum {MISSING = 0, ELEMENTAL, SCALAR, SCALAR_POINTER, ARRAY};\n \n   arglist = NULL_TREE;\n   retargs = NULL_TREE;\n@@ -1919,6 +1921,7 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n     {\n       e = arg->expr;\n       fsym = formal ? formal->sym : NULL;\n+      parm_kind = MISSING;\n       if (e == NULL)\n \t{\n \n@@ -1947,6 +1950,7 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t  /* An elemental function inside a scalarized loop.  */\n           gfc_init_se (&parmse, se);\n           gfc_conv_expr_reference (&parmse, e);\n+\t  parm_kind = ELEMENTAL;\n \t}\n       else\n \t{\n@@ -1957,12 +1961,14 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t  if (argss == gfc_ss_terminator)\n             {\n \t      gfc_conv_expr_reference (&parmse, e);\n+\t      parm_kind = SCALAR;\n               if (fsym && fsym->attr.pointer\n \t\t  && e->expr_type != EXPR_NULL)\n                 {\n                   /* Scalar pointer dummy args require an extra level of\n \t\t  indirection. The null pointer already contains\n \t\t  this level of indirection.  */\n+\t\t  parm_kind = SCALAR_POINTER;\n                   parmse.expr = build_fold_addr_expr (parmse.expr);\n                 }\n             }\n@@ -2050,6 +2056,49 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n       gfc_add_block_to_block (&se->pre, &parmse.pre);\n       gfc_add_block_to_block (&post, &parmse.post);\n \n+      /* Allocated allocatable components of derived types must be\n+\t deallocated for INTENT(OUT) dummy arguments and non-variable\n+         scalars.  Non-variable arrays are dealt with in trans-array.c\n+         (gfc_conv_array_parameter).  */\n+      if (e && e->ts.type == BT_DERIVED\n+\t    && e->ts.derived->attr.alloc_comp\n+\t    && ((formal && formal->sym->attr.intent == INTENT_OUT)\n+\t\t   ||\n+\t\t(e->expr_type != EXPR_VARIABLE && !e->rank)))\n+        {\n+\t  int parm_rank;\n+\t  tmp = build_fold_indirect_ref (parmse.expr);\n+\t  parm_rank = e->rank;\n+\t  switch (parm_kind)\n+\t    {\n+\t    case (ELEMENTAL):\n+\t    case (SCALAR):\n+\t      parm_rank = 0;\n+\t      break;\n+\n+\t    case (SCALAR_POINTER):\n+              tmp = build_fold_indirect_ref (tmp);\n+\t      break;\n+\t    case (ARRAY):\n+              tmp = parmse.expr;\n+\t      break;\n+\t    }\n+\n+          tmp = gfc_deallocate_alloc_comp (e->ts.derived, tmp, parm_rank);\n+\t  if (e->expr_type == EXPR_VARIABLE && e->symtree->n.sym->attr.optional)\n+\t    tmp = build3_v (COND_EXPR, gfc_conv_expr_present (e->symtree->n.sym),\n+\t\t\t    tmp, build_empty_stmt ());\n+\n+\t  if (e->expr_type != EXPR_VARIABLE)\n+\t    /* Don't deallocate non-variables until they have been used.  */\n+\t    gfc_add_expr_to_block (&se->post, tmp);\n+\t  else \n+\t    {\n+\t      gcc_assert (formal && formal->sym->attr.intent == INTENT_OUT);\n+\t      gfc_add_expr_to_block (&se->pre, tmp);\n+\t    }\n+        }\n+\n       /* Character strings are passed as two parameters, a length and a\n          pointer.  */\n       if (parmse.string_length != NULL_TREE)\n@@ -2636,7 +2685,7 @@ gfc_trans_subarray_assign (tree dest, gfc_component * cm, gfc_expr * expr)\n \n   gfc_conv_expr (&rse, expr);\n \n-  tmp = gfc_trans_scalar_assign (&lse, &rse, cm->ts.type);\n+  tmp = gfc_trans_scalar_assign (&lse, &rse, cm->ts, true, false);\n   gfc_add_expr_to_block (&body, tmp);\n \n   gcc_assert (rse.ss == gfc_ss_terminator);\n@@ -2657,17 +2706,22 @@ gfc_trans_subarray_assign (tree dest, gfc_component * cm, gfc_expr * expr)\n   return gfc_finish_block (&block);\n }\n \n+\n /* Assign a single component of a derived type constructor.  */\n \n static tree\n gfc_trans_subcomponent_assign (tree dest, gfc_component * cm, gfc_expr * expr)\n {\n   gfc_se se;\n+  gfc_se lse;\n   gfc_ss *rss;\n   stmtblock_t block;\n   tree tmp;\n+  tree offset;\n+  int n;\n \n   gfc_start_block (&block);\n+\n   if (cm->pointer)\n     {\n       gfc_init_se (&se, NULL);\n@@ -2700,8 +2754,68 @@ gfc_trans_subcomponent_assign (tree dest, gfc_component * cm, gfc_expr * expr)\n     }\n   else if (cm->dimension)\n     {\n-      tmp = gfc_trans_subarray_assign (dest, cm, expr);\n-      gfc_add_expr_to_block (&block, tmp);\n+      if (cm->allocatable && expr->expr_type == EXPR_NULL)\n+ \tgfc_conv_descriptor_data_set (&block, dest, null_pointer_node);\n+      else if (cm->allocatable)\n+        {\n+          tree tmp2;\n+\n+          gfc_init_se (&se, NULL);\n+ \n+\t  rss = gfc_walk_expr (expr);\n+          se.want_pointer = 0;\n+          gfc_conv_expr_descriptor (&se, expr, rss);\n+\t  gfc_add_block_to_block (&block, &se.pre);\n+\n+\t  tmp = fold_convert (TREE_TYPE (dest), se.expr);\n+\t  gfc_add_modify_expr (&block, dest, tmp);\n+\n+          if (cm->ts.type == BT_DERIVED && cm->ts.derived->attr.alloc_comp)\n+\t    tmp = gfc_copy_alloc_comp (cm->ts.derived, se.expr, dest,\n+\t\t\t\t       cm->as->rank);\n+\t  else\n+            tmp = gfc_duplicate_allocatable (dest, se.expr,\n+\t\t\t\t\t     TREE_TYPE(cm->backend_decl),\n+\t\t\t\t\t     cm->as->rank);\n+\n+          gfc_add_expr_to_block (&block, tmp);\n+\n+          gfc_add_block_to_block (&block, &se.post);\n+          gfc_conv_descriptor_data_set (&block, se.expr, null_pointer_node);\n+\n+          /* Shift the lbound and ubound of temporaries to being unity, rather\n+             than zero, based.  Calculate the offset for all cases.  */\n+          offset = gfc_conv_descriptor_offset (dest);\n+          gfc_add_modify_expr (&block, offset, gfc_index_zero_node);\n+          tmp2 =gfc_create_var (gfc_array_index_type, NULL);\n+          for (n = 0; n < expr->rank; n++)\n+            {\n+              if (expr->expr_type != EXPR_VARIABLE\n+                  && expr->expr_type != EXPR_CONSTANT)\n+                {\n+                  tmp = gfc_conv_descriptor_ubound (dest, gfc_rank_cst[n]);\n+                  gfc_add_modify_expr (&block, tmp,\n+                                       fold_build2 (PLUS_EXPR,\n+\t\t\t\t      \t\t    gfc_array_index_type,\n+                                                    tmp, gfc_index_one_node));\n+                  tmp = gfc_conv_descriptor_lbound (dest, gfc_rank_cst[n]);\n+                  gfc_add_modify_expr (&block, tmp, gfc_index_one_node);\n+                }\n+              tmp = fold_build2 (MULT_EXPR, gfc_array_index_type,\n+                                 gfc_conv_descriptor_lbound (dest,\n+\t\t\t\t\t\t\t     gfc_rank_cst[n]),\n+                                 gfc_conv_descriptor_stride (dest,\n+\t\t\t\t\t\t\t     gfc_rank_cst[n]));\n+              gfc_add_modify_expr (&block, tmp2, tmp);\n+              tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type, offset, tmp2);\n+              gfc_add_modify_expr (&block, offset, tmp);\n+            }\n+        }\n+      else\n+        {\n+\t  tmp = gfc_trans_subarray_assign (dest, cm, expr);\n+\t  gfc_add_expr_to_block (&block, tmp);\n+        }\n     }\n   else if (expr->ts.type == BT_DERIVED)\n     {\n@@ -2722,16 +2836,14 @@ gfc_trans_subcomponent_assign (tree dest, gfc_component * cm, gfc_expr * expr)\n   else\n     {\n       /* Scalar component.  */\n-      gfc_se lse;\n-\n       gfc_init_se (&se, NULL);\n       gfc_init_se (&lse, NULL);\n \n       gfc_conv_expr (&se, expr);\n       if (cm->ts.type == BT_CHARACTER)\n \tlse.string_length = cm->ts.cl->backend_decl;\n       lse.expr = dest;\n-      tmp = gfc_trans_scalar_assign (&lse, &se, cm->ts.type);\n+      tmp = gfc_trans_scalar_assign (&lse, &se, cm->ts, true, false);\n       gfc_add_expr_to_block (&block, tmp);\n     }\n   return gfc_finish_block (&block);\n@@ -2791,10 +2903,14 @@ gfc_conv_structure (gfc_se * se, gfc_expr * expr, int init)\n     }\n \n   cm = expr->ts.derived->components;\n+\n   for (c = expr->value.constructor; c; c = c->next, cm = cm->next)\n     {\n-      /* Skip absent members in default initializers.  */\n-      if (!c->expr)\n+      /* Skip absent members in default initializers and allocatable\n+\t components.  Although the latter have a default initializer\n+\t of EXPR_NULL,... by default, the static nullify is not needed\n+\t since this is done every time we come into scope.  */\n+      if (!c->expr || cm->allocatable)\n         continue;\n \n       val = gfc_conv_initializer (c->expr, &cm->ts,\n@@ -3089,16 +3205,19 @@ gfc_conv_string_parameter (gfc_se * se)\n \n \n /* Generate code for assignment of scalar variables.  Includes character\n-   strings.  */\n+   strings and derived types with allocatable components.  */\n \n tree\n-gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, bt type)\n+gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, gfc_typespec ts,\n+\t\t\t bool l_is_temp, bool r_is_var)\n {\n   stmtblock_t block;\n+  tree tmp;\n+  tree cond;\n \n   gfc_init_block (&block);\n \n-  if (type == BT_CHARACTER)\n+  if (ts.type == BT_CHARACTER)\n     {\n       gcc_assert (lse->string_length != NULL_TREE\n \t      && rse->string_length != NULL_TREE);\n@@ -3112,6 +3231,50 @@ gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, bt type)\n       gfc_trans_string_copy (&block, lse->string_length, lse->expr,\n \t\t\t     rse->string_length, rse->expr);\n     }\n+  else if (ts.type == BT_DERIVED && ts.derived->attr.alloc_comp)\n+    {\n+      cond = NULL_TREE;\n+\t\n+      /* Are the rhs and the lhs the same?  */\n+      if (r_is_var)\n+\t{\n+\t  cond = fold_build2 (EQ_EXPR, boolean_type_node,\n+\t\t\t      build_fold_addr_expr (lse->expr),\n+\t\t\t      build_fold_addr_expr (rse->expr));\n+\t  cond = gfc_evaluate_now (cond, &lse->pre);\n+\t}\n+\n+      /* Deallocate the lhs allocated components as long as it is not\n+\t the same as the rhs.  */\n+      if (!l_is_temp)\n+\t{\n+\t  tmp = gfc_deallocate_alloc_comp (ts.derived, lse->expr, 0);\n+\t  if (r_is_var)\n+\t    tmp = build3_v (COND_EXPR, cond, build_empty_stmt (), tmp);\n+\t  gfc_add_expr_to_block (&lse->pre, tmp);\n+\t}\n+\t\n+      gfc_add_block_to_block (&block, &lse->pre);\n+      gfc_add_block_to_block (&block, &rse->pre);\n+\n+      gfc_add_modify_expr (&block, lse->expr,\n+\t\t\t   fold_convert (TREE_TYPE (lse->expr), rse->expr));\n+\n+      /* Do a deep copy if the rhs is a variable, if it is not the\n+\t same as the lhs.  Otherwise, nullify the data fields so that the\n+\t lhs retains the allocated resources.  */\n+      if (r_is_var)\n+\t{\n+\t  tmp = gfc_copy_alloc_comp (ts.derived, rse->expr, lse->expr, 0);\n+\t  tmp = build3_v (COND_EXPR, cond, build_empty_stmt (), tmp);\n+\t  gfc_add_expr_to_block (&block, tmp);\n+\t}\n+      else\n+\t{\n+\t  tmp = gfc_nullify_alloc_comp (ts.derived, rse->expr, 0);\n+\t  gfc_add_expr_to_block (&block, tmp);\n+\t}\n+    }\n   else\n     {\n       gfc_add_block_to_block (&block, &lse->pre);\n@@ -3217,6 +3380,7 @@ gfc_trans_assignment (gfc_expr * expr1, gfc_expr * expr2)\n   tree tmp;\n   stmtblock_t block;\n   stmtblock_t body;\n+  bool l_is_temp;\n \n   /* Special case a single function returning an array.  */\n   if (expr2->expr_type == EXPR_FUNCTION && expr2->rank > 0)\n@@ -3295,18 +3459,21 @@ gfc_trans_assignment (gfc_expr * expr1, gfc_expr * expr2)\n   else\n     gfc_init_block (&body);\n \n+  l_is_temp = (lss != gfc_ss_terminator && loop.temp_ss != NULL);\n+\n   /* Translate the expression.  */\n   gfc_conv_expr (&rse, expr2);\n \n-  if (lss != gfc_ss_terminator && loop.temp_ss != NULL)\n+  if (l_is_temp)\n     {\n       gfc_conv_tmp_array_ref (&lse);\n       gfc_advance_se_ss_chain (&lse);\n     }\n   else\n     gfc_conv_expr (&lse, expr1);\n \n-  tmp = gfc_trans_scalar_assign (&lse, &rse, expr1->ts.type);\n+  tmp = gfc_trans_scalar_assign (&lse, &rse, expr1->ts, l_is_temp,\n+\t\t\t\t expr2->expr_type == EXPR_VARIABLE);\n   gfc_add_expr_to_block (&body, tmp);\n \n   if (lss == gfc_ss_terminator)\n@@ -3319,7 +3486,7 @@ gfc_trans_assignment (gfc_expr * expr1, gfc_expr * expr2)\n       gcc_assert (lse.ss == gfc_ss_terminator\n \t\t  && rse.ss == gfc_ss_terminator);\n \n-      if (loop.temp_ss != NULL)\n+      if (l_is_temp)\n \t{\n \t  gfc_trans_scalarized_loop_boundary (&loop, &body);\n \n@@ -3339,9 +3506,10 @@ gfc_trans_assignment (gfc_expr * expr1, gfc_expr * expr2)\n \t  gcc_assert (lse.ss == gfc_ss_terminator\n \t\t      && rse.ss == gfc_ss_terminator);\n \n-\t  tmp = gfc_trans_scalar_assign (&lse, &rse, expr1->ts.type);\n+\t  tmp = gfc_trans_scalar_assign (&lse, &rse, expr1->ts, false, false);\n \t  gfc_add_expr_to_block (&body, tmp);\n \t}\n+\n       /* Generate the copying loops.  */\n       gfc_trans_scalarizing_loops (&loop, &body);\n "}, {"sha": "25d41eec604ec002153cdf6866f6ccc9217e8d46", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 38, "deletions": 6, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=5046aff56bbd9b2911799ad1e26b7c538fcc513e", "patch": "@@ -1802,7 +1802,8 @@ generate_loop_for_temp_to_lhs (gfc_expr *expr, tree tmp1, tree count3,\n       gfc_conv_expr (&lse, expr);\n \n       /* Use the scalar assignment.  */\n-      tmp = gfc_trans_scalar_assign (&lse, &rse, expr->ts.type);\n+      rse.string_length = lse.string_length;\n+      tmp = gfc_trans_scalar_assign (&lse, &rse, expr->ts, false, false);\n \n       /* Form the mask expression according to the mask tree list.  */\n       if (wheremask)\n@@ -1897,7 +1898,9 @@ generate_loop_for_rhs_to_temp (gfc_expr *expr2, tree tmp1, tree count3,\n     }\n \n   /* Use the scalar assignment.  */\n-  tmp = gfc_trans_scalar_assign (&lse, &rse, expr2->ts.type);\n+  lse.string_length = rse.string_length;\n+  tmp = gfc_trans_scalar_assign (&lse, &rse, expr2->ts, true,\n+\t\t\t\t expr2->expr_type == EXPR_VARIABLE);\n \n   /* Form the mask expression according to the mask tree list.  */\n   if (wheremask)\n@@ -2978,7 +2981,8 @@ gfc_trans_where_assign (gfc_expr *expr1, gfc_expr *expr2,\n     maskexpr = fold_build1 (TRUTH_NOT_EXPR, TREE_TYPE (maskexpr), maskexpr);\n \n   /* Use the scalar assignment as is.  */\n-  tmp = gfc_trans_scalar_assign (&lse, &rse, expr1->ts.type);\n+  tmp = gfc_trans_scalar_assign (&lse, &rse, expr1->ts,\n+\t\t\t\t loop.temp_ss != NULL, false);\n   tmp = build3_v (COND_EXPR, maskexpr, tmp, build_empty_stmt ());\n \n   gfc_add_expr_to_block (&body, tmp);\n@@ -3031,7 +3035,7 @@ gfc_trans_where_assign (gfc_expr *expr1, gfc_expr *expr2,\n \t\t\t\t    maskexpr);\n \n           /* Use the scalar assignment as is.  */\n-          tmp = gfc_trans_scalar_assign (&lse, &rse, expr1->ts.type);\n+          tmp = gfc_trans_scalar_assign (&lse, &rse, expr1->ts, false, false);\n           tmp = build3_v (COND_EXPR, maskexpr, tmp, build_empty_stmt ());\n           gfc_add_expr_to_block (&body, tmp);\n \n@@ -3406,8 +3410,8 @@ gfc_trans_where_3 (gfc_code * cblock, gfc_code * eblock)\n         gfc_conv_expr (&edse, edst);\n     }\n \n-  tstmt = gfc_trans_scalar_assign (&tdse, &tsse, tdst->ts.type);\n-  estmt = eblock ? gfc_trans_scalar_assign (&edse, &esse, edst->ts.type)\n+  tstmt = gfc_trans_scalar_assign (&tdse, &tsse, tdst->ts, false, false);\n+  estmt = eblock ? gfc_trans_scalar_assign (&edse, &esse, edst->ts, false, false)\n \t\t : build_empty_stmt ();\n   tmp = build3_v (COND_EXPR, cexpr, tstmt, estmt);\n   gfc_add_expr_to_block (&body, tmp);\n@@ -3591,6 +3595,14 @@ gfc_trans_allocate (gfc_code * code)\n \t\t\t\t parm, tmp, build_empty_stmt ());\n \t      gfc_add_expr_to_block (&se.pre, tmp);\n \t    }\n+\n+\t  if (expr->ts.type == BT_DERIVED && expr->ts.derived->attr.alloc_comp)\n+\t    {\n+\t      tmp = build_fold_indirect_ref (se.expr);\n+\t      tmp = gfc_nullify_alloc_comp (expr->ts.derived, tmp, 0);\n+\t      gfc_add_expr_to_block (&se.pre, tmp);\n+\t    }\n+\n \t}\n \n       tmp = gfc_finish_block (&se.pre);\n@@ -3675,6 +3687,26 @@ gfc_trans_deallocate (gfc_code * code)\n       se.descriptor_only = 1;\n       gfc_conv_expr (&se, expr);\n \n+      if (expr->ts.type == BT_DERIVED\n+\t    && expr->ts.derived->attr.alloc_comp)\n+        {\n+\t  gfc_ref *ref;\n+\t  gfc_ref *last = NULL;\n+\t  for (ref = expr->ref; ref; ref = ref->next)\n+\t    if (ref->type == REF_COMPONENT)\n+\t      last = ref;\n+\n+\t  /* Do not deallocate the components of a derived type\n+\t     ultimate pointer component.  */\n+\t  if (!(last && last->u.c.component->pointer)\n+\t\t   && !(!last && expr->symtree->n.sym->attr.pointer))\n+\t    {\n+\t      tmp = gfc_deallocate_alloc_comp (expr->ts.derived, se.expr,\n+\t\t\t\t\t\texpr->rank);\n+\t      gfc_add_expr_to_block (&se.pre, tmp);\n+\t    }\n+\t}\n+\n       if (expr->rank)\n \ttmp = gfc_array_deallocate (se.expr, pstat);\n       else"}, {"sha": "bff025cbb7e62e73c0e5ec03c1204722ee1c9e0b", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=5046aff56bbd9b2911799ad1e26b7c538fcc513e", "patch": "@@ -1486,12 +1486,15 @@ gfc_get_derived_type (gfc_symbol * derived)\n       /* Derived types in an interface body obtain their parent reference\n \t through the proc_name symbol.  */\n       ns = derived->ns->parent ? derived->ns->parent\n-\t\t\t       : derived->ns->proc_name->ns->parent;\n+\t\t\t       : derived->ns->proc_name->ns;\n \n       for (; ns; ns = ns->parent)\n \t{\n \t  for (dt = ns->derived_types; dt; dt = dt->next)\n \t    {\n+\t      if (dt->derived == derived)\n+\t\tcontinue;\n+\n \t      if (dt->derived->backend_decl == NULL\n \t\t    && gfc_compare_derived_types (dt->derived, derived))\n \t\tgfc_get_derived_type (dt->derived);\n@@ -1550,7 +1553,7 @@ gfc_get_derived_type (gfc_symbol * derived)\n          required.  */\n       if (c->dimension)\n \t{\n-\t  if (c->pointer)\n+\t  if (c->pointer || c->allocatable)\n \t    {\n \t      /* Pointers to arrays aren't actually pointer types.  The\n \t         descriptors are separate, but the data is common.  */"}, {"sha": "bdee57892ff5094675ae185ebce26a3e0b582a0d", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=5046aff56bbd9b2911799ad1e26b7c538fcc513e", "patch": "@@ -307,7 +307,7 @@ int gfc_conv_function_call (gfc_se *, gfc_symbol *, gfc_actual_arglist *);\n /* gfc_trans_* shouldn't call push/poplevel, use gfc_push/pop_scope */\n \n /* Generate code for a scalar assignment.  */\n-tree gfc_trans_scalar_assign (gfc_se *, gfc_se *, bt);\n+tree gfc_trans_scalar_assign (gfc_se *, gfc_se *, gfc_typespec, bool, bool);\n \n /* Translate COMMON blocks.  */\n void gfc_trans_common (gfc_namespace *);"}, {"sha": "6d463b5f7ce5861df7e78c1f4afe5846f3a8f290", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5046aff56bbd9b2911799ad1e26b7c538fcc513e", "patch": "@@ -1,3 +1,30 @@\n+2006-10-08  Erik Edelmann  <edelmann@gcc.gnu.org>\n+\t    Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/20541\n+\t* gfortran.dg/alloc_comp_basics_1.f90: New test.\n+\t* gfortran.dg/alloc_comp_basics_2.f90: New test.\n+\t* gfortran.dg/alloc_comp_assign_1.f90: New test.\n+\t* gfortran.dg/alloc_comp_assign_2.f90: New test.\n+\t* gfortran.dg/alloc_comp_assign_3.f90: New test.\n+\t* gfortran.dg/alloc_comp_assign_4.f90: New test.\n+\t* gfortran.dg/alloc_comp_constraint_1.f90: New test.\n+\t* gfortran.dg/alloc_comp_constraint_2.f90: New test.\n+\t* gfortran.dg/alloc_comp_constraint_3.f90: New test.\n+\t* gfortran.dg/alloc_comp_constructor_1.f90: New test.\n+\t* gfortran.dg/alloc_comp_constructor_2.f90: New test.\n+\t* gfortran.dg/alloc_comp_initializer_1.f90: New test.\n+\t* gfortran.dg/alloc_comp_std.f90: New test.\n+\t* gfortran.dg/move_alloc.f90: New test.\n+\n+2006-10-08  Paul Thomas <pault@gcc.gnu.org>\n+\n+\tPR fortran/29115\n+\t* gfortran.dg/derived_constructor_comps_2.f90: New test.\n+\n+\tPR fortran/29211\n+\t* gfortran.dg/forall_char_dependencies_1.f90: New test.\n+\n 2006-10-08  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/28585"}, {"sha": "9d87af2f84729d1ed5aec1d1219ff9236a288afd", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_assign_1.f90", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_assign_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_assign_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_assign_1.f90?ref=5046aff56bbd9b2911799ad1e26b7c538fcc513e", "patch": "@@ -0,0 +1,57 @@\n+! { dg-do run }\n+! Test assignments of derived type with allocatable components (PR 20541).\n+!\n+! Contributed by Erik Edelmann  <eedelmann@gcc.gnu.org>\n+!            and Paul Thomas  <pault@gcc.gnu.org>\n+!\n+  type :: ivs\n+    character(1), allocatable :: chars(:)\n+  end type ivs\n+\n+  type(ivs) :: a, b\n+  type(ivs) :: x(3), y(3)\n+  \n+  allocate(a%chars(5))\n+  a%chars = (/\"h\",\"e\",\"l\",\"l\",\"o\"/)\n+\n+! An intrinsic assignment must deallocate the l-value and copy across\n+! the array from the r-value.\n+  b = a\n+  if (any (b%chars .ne. (/\"h\",\"e\",\"l\",\"l\",\"o\"/))) call abort ()\n+  if (allocated (a%chars) .eqv. .false.) call abort ()\n+\n+! Scalar to array needs to copy the derived type, to its ultimate components,\n+! to each of the l-value elements.  */\n+  x = b\n+  x(2)%chars = (/\"g\",\"'\",\"d\",\"a\",\"y\"/)\n+  if (any (x(1)%chars .ne. (/\"h\",\"e\",\"l\",\"l\",\"o\"/))) call abort ()\n+  if (any (x(2)%chars .ne. (/\"g\",\"'\",\"d\",\"a\",\"y\"/))) call abort ()\n+  if (allocated (b%chars) .eqv. .false.) call abort ()\n+  deallocate (x(1)%chars, x(2)%chars, x(3)%chars)\n+\n+! Array intrinsic assignments are like their scalar counterpart and\n+! must deallocate each element of the l-value and copy across the\n+! arrays from the r-value elements.\n+  allocate(x(1)%chars(5), x(2)%chars(5), x(3)%chars(5))\n+  x(1)%chars = (/\"h\",\"e\",\"l\",\"l\",\"o\"/)\n+  x(2)%chars = (/\"g\",\"'\",\"d\",\"a\",\"y\"/)\n+  x(3)%chars = (/\"g\",\"o\",\"d\",\"a\",\"g\"/)\n+  y(2:1:-1) = x(1:2)\n+  if (any (y(1)%chars .ne. (/\"g\",\"'\",\"d\",\"a\",\"y\"/))) call abort ()\n+  if (any (y(2)%chars .ne. (/\"h\",\"e\",\"l\",\"l\",\"o\"/))) call abort ()\n+  if (any (x(3)%chars .ne. (/\"g\",\"o\",\"d\",\"a\",\"g\"/))) call abort ()\n+\n+! In the case of an assignment where there is a dependency, so that a\n+! temporary is necessary, each element must be copied to its\n+! destination after it has been deallocated.\n+  y(2:3) = y(1:2)\n+  if (any (y(1)%chars .ne. (/\"g\",\"'\",\"d\",\"a\",\"y\"/))) call abort ()\n+  if (any (y(2)%chars .ne. (/\"g\",\"'\",\"d\",\"a\",\"y\"/))) call abort ()\n+  if (any (y(3)%chars .ne. (/\"h\",\"e\",\"l\",\"l\",\"o\"/))) call abort ()\n+\n+! An identity assignment must not do any deallocation....!\n+  y = y\n+  if (any (y(1)%chars .ne. (/\"g\",\"'\",\"d\",\"a\",\"y\"/))) call abort ()\n+  if (any (y(2)%chars .ne. (/\"g\",\"'\",\"d\",\"a\",\"y\"/))) call abort ()\n+  if (any (y(3)%chars .ne. (/\"h\",\"e\",\"l\",\"l\",\"o\"/))) call abort ()\n+end"}, {"sha": "817026e41c7916c1c34a08b3846755ca4d5440ff", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_assign_2.f90", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_assign_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_assign_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_assign_2.f90?ref=5046aff56bbd9b2911799ad1e26b7c538fcc513e", "patch": "@@ -0,0 +1,57 @@\n+! { dg-do run }\n+! Test FORALL and WHERE with derived types with allocatable components (PR 20541).\n+!\n+! Contributed by Erik Edelmann  <eedelmann@gcc.gnu.org>\n+!            and Paul Thomas  <pault@gcc.gnu.org>\n+!\n+  type :: a\n+    integer, allocatable :: i(:)\n+  end type a\n+\n+  type :: b\n+    type (a), allocatable :: at(:)\n+  end type b\n+\n+  type(a) :: x(2)\n+  type(b) :: y(2), z(2)\n+  integer i, m(4)\n+\n+! Start with scalar and array element assignments in FORALL.\n+\n+  x(1) = a ((/1, 2, 3, 4/))\n+  x(2) = a ((/1, 2, 3, 4/) + 10)\n+  forall (j = 1:2, i = 1:4, x(j)%i(i) > 2 + (j-1)*10)  x(j)%i(i) =  j*4-i\n+  if (any ((/((x(i)%i(j), j = 1,4), i = 1,2)/) .ne. &\n+          (/1, 2, 1, 0, 11, 12, 5, 4/))) call abort ()\n+\n+  y(1) = b ((/x(1),x(2)/))\n+  y(2) = b ((/x(2),x(1)/))\n+  forall (k = 1:2, j=1:2, i = 1:4, y(k)%at(j)%i(i) <= 10)\n+    y(k)%at(j)%i(i) =  j*4-i+k\n+  end forall\n+  if (any ((/(((y(k)%at(i)%i(j), j = 1,4), i = 1,2), k = 1,2)/) .ne. &\n+         (/4,3,2,1,11,12,6,5,11,12,3,2,9,8,7,6/))) call abort () \n+\n+! Now simple assignments in WHERE.\n+\n+  where (y(1)%at(1)%i > 2) y(1)%at(1)%i = 0\n+  if (any( (/(((y(k)%at(i)%i(j), j = 1,4), i = 1,2), k = 1,2)/) .ne. &\n+         (/0,0,2,1,11,12,6,5,11,12,3,2,9,8,7,6/))) call abort () \n+\n+  where (y((2))%at(:)%i(2) > 8)\n+    y(2)%at(:)%i(2) = 77\n+  end where\n+  if (any ((/(((y(k)%at(i)%i(j), j = 1,4), i = 1,2), k = 1,2)/) .ne. &\n+         (/0,0,2,1,11,12,6,5,11,77,3,2,9,8,7,6/))) call abort ()\n+\n+! Check that temporaries and full array  alloctable component assignments\n+! are correctly handled in FORALL.\n+\n+  x = (/a ((/1,2,3,4/)),a ((/5,6,7,8/))/)\n+  forall (i=1:2) y(i) = b ((/x(i)/))\n+  forall (i=1:2) y(i) = y(3-i)      ! This needs a temporary.\n+  forall (i=1:2) z(i) = y(i)\n+  if (any ((/(((z(k)%at(i)%i(j), j = 1,4), i = 1,1), k = 1,2)/) .ne. &\n+         (/(/5,6,7,8/),(/1,2,3,4/)/))) call abort ()\n+\n+end"}, {"sha": "5be6bd9909177e1ee1fa76292501dc02985687ec", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_assign_3.f90", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_assign_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_assign_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_assign_3.f90?ref=5046aff56bbd9b2911799ad1e26b7c538fcc513e", "patch": "@@ -0,0 +1,36 @@\n+! { dg-do run }\n+! Test assignments of nested derived types with allocatable components(PR 20541).\n+!\n+! Contributed by Erik Edelmann  <eedelmann@gcc.gnu.org>\n+!            and Paul Thomas  <pault@gcc.gnu.org>\n+!\n+  type :: a\n+    integer, allocatable :: i(:)\n+  end type a\n+\n+  type :: b\n+    type (a), allocatable :: at(:)\n+  end type b\n+\n+  type(a) :: x(2)\n+  type(b) :: y(2), z(2)\n+  integer i, m(4)\n+\n+  x(1) = a((/1,2,3,4/))\n+  x(2) = a((/1,2,3,4/)+10)\n+\n+  y(1) = b((/x(1),x(2)/))\n+  y(2) = b((/x(2),x(1)/))\n+\n+  y(2) = y(1)\n+  forall (j=1:2,k=1:4, y(1)%at(j)%i(k) .ne. y(2)%at(j)%i(k)) &\n+                             y(1)%at(j)%i(k) = 999\n+  if (any ((/((y(1)%at(j)%i(k), k=1,4),j=1,2)/) .eq. 999)) call abort ()\n+\n+\n+  z = y\n+  forall (i=1:2,j=1:2,k=1:4, z(i)%at(j)%i(k) .ne. y(i)%at(j)%i(k)) &\n+                             z(i)%at(j)%i(k) = 999\n+  if (any ((/(((z(i)%at(j)%i(k), k=1,4),j=1,2),i=1,2)/) .eq. 999)) call abort ()\n+\n+end"}, {"sha": "b204106da2d1de9b9373a718097c7b44396a62de", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_assign_4.f90", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_assign_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_assign_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_assign_4.f90?ref=5046aff56bbd9b2911799ad1e26b7c538fcc513e", "patch": "@@ -0,0 +1,63 @@\n+! { dg-do run }\n+! Test assignments of nested derived types with character allocatable\n+! components(PR 20541). Subroutine test_ab6 checks out a bug in a test\n+! version of gfortran's allocatable arrays.\n+!\n+! Contributed by Erik Edelmann  <eedelmann@gcc.gnu.org>\n+!            and Paul Thomas  <pault@gcc.gnu.org>\n+!\n+  type :: a\n+    character(4), allocatable :: ch(:)\n+  end type a\n+\n+  type :: b\n+    type (a), allocatable :: at(:)\n+  end type b\n+\n+  type(a) :: x(2)\n+  type(b) :: y(2), z(2)\n+\n+  character(4) :: chr1(4) = (/\"abcd\",\"efgh\",\"ijkl\",\"mnop\"/)\n+  character(4) :: chr2(4) = (/\"qrst\",\"uvwx\",\"yz12\",\"3456\"/)\n+\n+  x(1) = a(chr1)\n+\n+ ! Check constructor with character array constructors.\n+  x(2) = a((/\"qrst\",\"uvwx\",\"yz12\",\"3456\"/))\n+\n+  y(1) = b((/x(1),x(2)/))\n+  y(2) = b((/x(2),x(1)/))\n+\n+  y(2) = y(1)\n+\n+  if (any((/((y(2)%at(i)%ch(j),j=1,4),i=1,2)/) .ne. &\n+          (/chr1, chr2/))) call abort ()\n+\n+  call test_ab6 ()\n+\n+contains\n+\n+  subroutine test_ab6 ()\n+! This subroutine tests the presence of a scalar derived type, intermediate\n+! in a chain of derived types with allocatable components.\n+! Contributed by Salvatore Filippone  <salvatore.filippone@uniroma2.it>\n+\n+    type b\n+      type(a)  :: a\n+    end type b\n+\n+    type c\n+      type(b), allocatable :: b(:) \n+    end type c\n+\n+    type(c)    :: p\n+    type(b)   :: bv\n+\n+    p = c((/b(a((/\"Mary\",\"Lamb\"/)))/))\n+    bv = p%b(1)\n+\n+    if (any ((bv%a%ch(:)) .ne. (/\"Mary\",\"Lamb\"/))) call abort ()\n+\n+end subroutine test_ab6\n+\n+end"}, {"sha": "06989d3b5569c9c16c6602810aeb04908786f820", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_basics_1.f90", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_basics_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_basics_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_basics_1.f90?ref=5046aff56bbd9b2911799ad1e26b7c538fcc513e", "patch": "@@ -0,0 +1,143 @@\n+! { dg-do run}\n+! { dg-options \"-O2 -fdump-tree-original\" }\n+!\n+! Check some basic functionality of allocatable components, including that they\n+! are nullified when created and automatically deallocated when\n+! 1. A variable goes out of scope\n+! 2. INTENT(OUT) dummies\n+! 3. Function results\n+!\n+!\n+! Contributed by Erik Edelmann  <eedelmann@gcc.gnu.org>\n+!            and Paul Thomas  <pault@gcc.gnu.org>\n+!\n+module alloc_m\n+\n+    implicit none\n+\n+    type :: alloc1\n+        real, allocatable :: x(:)\n+    end type alloc1\n+\n+end module alloc_m\n+\n+\n+program alloc\n+\n+    use alloc_m\n+\n+    implicit none\n+\n+    type :: alloc2\n+        type(alloc1), allocatable :: a1(:)\n+        integer, allocatable :: a2(:)\n+    end type alloc2\n+\n+    type(alloc2) :: b\n+    integer :: i\n+    type(alloc2), allocatable :: c(:)\n+\n+    if (allocated(b%a2) .OR. allocated(b%a1)) then\n+        write (0, *) 'main - 1'\n+        call abort()\n+    end if\n+\n+    ! 3 calls to _gfortran_deallocate (INTENT(OUT) dummy)\n+    call allocate_alloc2(b)\n+    call check_alloc2(b)\n+\n+    do i = 1, size(b%a1)\n+        ! 1 call to _gfortran_deallocate\n+        deallocate(b%a1(i)%x)\n+    end do\n+\n+    ! 3 calls to _gfortran_deallocate (INTENT(OUT) dummy)\n+    call allocate_alloc2(b)\n+\n+    call check_alloc2(return_alloc2())\n+    ! 3 calls to _gfortran_deallocate (function result)\n+\n+    allocate(c(1))\n+    ! 3 calls to _gfortran_deallocate (INTENT(OUT) dummy)\n+    call allocate_alloc2(c(1))\n+    ! 4 calls to _gfortran_deallocate\n+    deallocate(c)\n+\n+    ! 7 calls to _gfortran_deallocate (b (3) and c(4) goes aout of scope)\n+\n+contains\n+\n+    subroutine allocate_alloc2(b)\n+        type(alloc2), intent(out) :: b\n+        integer :: i\n+\n+        if (allocated(b%a2) .OR. allocated(b%a1)) then\n+            write (0, *) 'allocate_alloc2 - 1'\n+            call abort()\n+        end if\n+\n+        allocate (b%a2(3))\n+        b%a2 = [ 1, 2, 3 ]\n+\n+        allocate (b%a1(3))\n+\n+        do i = 1, 3\n+            if (allocated(b%a1(i)%x)) then\n+                write (0, *) 'allocate_alloc2 - 2', i\n+                call abort()\n+            end if\n+            allocate (b%a1(i)%x(3))\n+            b%a1(i)%x = i + [ 1.0, 2.0, 3.0 ]\n+        end do\n+\n+    end subroutine allocate_alloc2\n+\n+\n+    type(alloc2) function return_alloc2() result(b)\n+        if (allocated(b%a2) .OR. allocated(b%a1)) then\n+            write (0, *) 'return_alloc2 - 1'\n+            call abort()\n+        end if\n+\n+        allocate (b%a2(3))\n+        b%a2 = [ 1, 2, 3 ]\n+\n+        allocate (b%a1(3))\n+\n+        do i = 1, 3\n+            if (allocated(b%a1(i)%x)) then\n+                write (0, *) 'return_alloc2 - 2', i\n+                call abort()\n+            end if\n+            allocate (b%a1(i)%x(3))\n+            b%a1(i)%x = i + [ 1.0, 2.0, 3.0 ]\n+        end do\n+    end function return_alloc2\n+\n+\n+    subroutine check_alloc2(b)\n+        type(alloc2), intent(in) :: b\n+\n+        if (.NOT.(allocated(b%a2) .AND. allocated(b%a1))) then\n+            write (0, *) 'check_alloc2 - 1'\n+            call abort()\n+        end if\n+        if (any(b%a2 /= [ 1, 2, 3 ])) then\n+            write (0, *) 'check_alloc2 - 2'\n+            call abort()\n+        end if\n+        do i = 1, 3\n+            if (.NOT.allocated(b%a1(i)%x)) then\n+                write (0, *) 'check_alloc2 - 3', i\n+                call abort()\n+            end if\n+            if (any(b%a1(i)%x /= i + [ 1.0, 2.0, 3.0 ])) then\n+                write (0, *) 'check_alloc2 - 4', i\n+                call abort()\n+            end if\n+        end do\n+    end subroutine check_alloc2\n+\n+end program alloc\n+! { dg-final { scan-tree-dump-times \"deallocate\" 38 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "170a8871f715f68175dbd7da4e1ffb533e0196e8", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_basics_2.f90", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_basics_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_basics_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_basics_2.f90?ref=5046aff56bbd9b2911799ad1e26b7c538fcc513e", "patch": "@@ -0,0 +1,39 @@\n+! { dg-do run }\r\n+! Check \"double\" allocations of allocatable components (PR 20541).\r\n+!\r\n+! Contributed by Erik Edelmann  <eedelmann@gcc.gnu.org>\r\n+!            and Paul Thomas  <pault@gcc.gnu.org>\r\n+!\r\n+program main\r\n+\r\n+  implicit none\r\n+\r\n+  type foo\r\n+     integer, dimension(:), allocatable :: array\r\n+  end type foo\r\n+\r\n+  type(foo),allocatable,dimension(:) :: mol\r\n+  type(foo),pointer,dimension(:) :: molp\r\n+  integer :: i\r\n+\r\n+  allocate (mol(1))\r\n+  allocate (mol(1), stat=i)\r\n+  !print *, i  ! /= 0\r\n+  if (i == 0) call abort()\r\n+\r\n+  allocate (mol(1)%array(5))\r\n+  allocate (mol(1)%array(5),stat=i)\r\n+  !print *, i  ! /= 0\r\n+  if (i == 0) call abort()\r\n+\r\n+  allocate (molp(1))\r\n+  allocate (molp(1), stat=i)\r\n+  !print *, i  ! == 0\r\n+  if (i /= 0) call abort()\r\n+\r\n+  allocate (molp(1)%array(5))\r\n+  allocate (molp(1)%array(5),stat=i)\r\n+  !print *, i  ! /= 0\r\n+  if (i == 0) call abort()\r\n+\r\n+end program main\r"}, {"sha": "cb5ac0611d6d41c1dcace1f0598c0259044eb3cf", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_constraint_1.f90", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_constraint_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_constraint_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_constraint_1.f90?ref=5046aff56bbd9b2911799ad1e26b7c538fcc513e", "patch": "@@ -0,0 +1,22 @@\n+! { dg-do compile }\n+! Check that we don't allow IO or NAMELISTs with types with allocatable\n+! components (PR 20541)\n+program main\n+\n+    type :: foo\n+        integer, allocatable :: x(:)\n+    end type foo\n+\n+    type :: bar\n+        type(foo) :: x\n+    end type bar\n+\n+    type(foo) :: a\n+    type(bar) :: b\n+    namelist /blah/ a ! { dg-error \"cannot have ALLOCATABLE components\" }\n+\n+    write (*, *) a  ! { dg-error \"cannot have ALLOCATABLE components\" }\n+\n+    read (*, *) b  ! { dg-error \"cannot have ALLOCATABLE components\" }\n+\n+end program main"}, {"sha": "c37edb6bc48a929f4e07a7f1fc03837ff07bf55c", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_constraint_2.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_constraint_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_constraint_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_constraint_2.f90?ref=5046aff56bbd9b2911799ad1e26b7c538fcc513e", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do compile }\n+! Check that equivalence with allocatable components isn't allowed (PR 20541)\n+program main\n+\n+    type :: foo\n+        sequence\n+        integer, allocatable :: x(:)\n+    end type foo\n+\n+    type(foo) :: a\n+    integer :: b\n+\n+    equivalence (a, b) ! { dg-error \"cannot have ALLOCATABLE components\" }\n+\n+end program main"}, {"sha": "58a0e74633141cf65ebc670dfdc2f53824a111d5", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_constraint_3.f90", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_constraint_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_constraint_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_constraint_3.f90?ref=5046aff56bbd9b2911799ad1e26b7c538fcc513e", "patch": "@@ -0,0 +1,12 @@\n+! { dg-do compile }\n+! Check that default initializer for allocatable components isn't accepted (PR\n+! 20541)\n+program main\n+\n+    type :: foo\n+        integer, allocatable :: a(:) = [ 1 ] ! { dg-error \"Initialization of allocatable\" }\n+\n+        integer :: x ! Just to avoid \"extra\" error messages about empty type.\n+    end type foo\n+\n+end program main"}, {"sha": "9beca6d0b7fb7711a79db46c31a491492ed6c964", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_constructor_1.f90", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_constructor_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_constructor_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_constructor_1.f90?ref=5046aff56bbd9b2911799ad1e26b7c538fcc513e", "patch": "@@ -0,0 +1,108 @@\n+! { dg-do run }\r\n+! { dg-options \"-fdump-tree-original\" }\r\n+! Test constructors of derived type with allocatable components (PR 20541).\r\n+!\r\n+! Contributed by Erik Edelmann  <eedelmann@gcc.gnu.org>\r\n+!            and Paul Thomas  <pault@gcc.gnu.org>\r\n+!\r\n+\r\n+Program test_constructor\r\n+\r\n+    implicit none\r\n+\r\n+    type :: thytype\r\n+        integer(4) :: a(2,2)\r\n+    end type thytype\r\n+\r\n+    type :: mytype\r\n+        integer(4), allocatable :: a(:, :)\r\n+        type(thytype), allocatable :: q(:)\r\n+    end type mytype\r\n+\r\n+    type (mytype) :: x\r\n+    type (thytype) :: foo = thytype(reshape ([43, 100, 54, 76], [2,2]))\r\n+    integer :: y(0:1, -1:0) = reshape ([42, 99, 55, 77], [2,2])\r\n+    integer, allocatable :: yy(:,:)\r\n+    type (thytype), allocatable :: bar(:)\r\n+    integer :: i\r\n+\r\n+    ! Check that null() works\r\n+    x = mytype(null(), null())\r\n+    if (allocated(x%a) .or. allocated(x%q)) call abort()\r\n+\r\n+    ! Check that unallocated allocatables work\r\n+    x = mytype(yy, bar)\r\n+    if (allocated(x%a) .or. allocated(x%q)) call abort()\r\n+\r\n+    ! Check that non-allocatables work\r\n+    x = mytype(y, [foo, foo])\r\n+    if (.not.allocated(x%a) .or. .not.allocated(x%q)) call abort()\r\n+    if (any(lbound(x%a) /= lbound(y))) call abort()\r\n+    if (any(ubound(x%a) /= ubound(y))) call abort()\r\n+    if (any(x%a /= y)) call abort()\r\n+    if (size(x%q) /= 2) call abort()\r\n+    do i = 1, 2\r\n+        if (any(x%q(i)%a /= foo%a)) call abort()\r\n+    end do\r\n+\r\n+    ! Check that allocated allocatables work\r\n+    allocate(yy(size(y,1), size(y,2)))\r\n+    yy = y\r\n+    allocate(bar(2))\r\n+    bar = [foo, foo]\r\n+    x = mytype(yy, bar)\r\n+    if (.not.allocated(x%a) .or. .not.allocated(x%q)) call abort()\r\n+    if (any(x%a /= y)) call abort()\r\n+    if (size(x%q) /= 2) call abort()\r\n+    do i = 1, 2\r\n+        if (any(x%q(i)%a /= foo%a)) call abort()\r\n+    end do\r\n+\r\n+    ! Functions returning arrays\r\n+    x = mytype(bluhu(), null())\r\n+    if (.not.allocated(x%a) .or. allocated(x%q)) call abort()\r\n+    if (any(x%a /= reshape ([41, 98, 54, 76], [2,2]))) call abort()\r\n+\r\n+    ! Functions returning allocatable arrays\r\n+    x = mytype(blaha(), null())\r\n+    if (.not.allocated(x%a) .or. allocated(x%q)) call abort()\r\n+    if (any(x%a /= reshape ([40, 97, 53, 75], [2,2]))) call abort()\r\n+\r\n+    ! Check that passing the constructor to a procedure works\r\n+    call check_mytype (mytype(y, [foo, foo]))\r\n+\r\n+contains\r\n+\r\n+    subroutine check_mytype(x)\r\n+        type(mytype), intent(in) :: x\r\n+        integer :: i\r\n+\r\n+        if (.not.allocated(x%a) .or. .not.allocated(x%q)) call abort()\r\n+        if (any(lbound(x%a) /= lbound(y))) call abort()\r\n+        if (any(ubound(x%a) /= ubound(y))) call abort()\r\n+        if (any(x%a /= y)) call abort()\r\n+        if (size(x%q) /= 2) call abort()\r\n+        do i = 1, 2\r\n+            if (any(x%q(i)%a /= foo%a)) call abort()\r\n+        end do\r\n+\r\n+    end subroutine check_mytype\r\n+\r\n+\r\n+    function bluhu()\r\n+        integer :: bluhu(2,2)\r\n+\r\n+        bluhu = reshape ([41, 98, 54, 76], [2,2])\r\n+    end function bluhu\r\n+\r\n+\r\n+    function blaha()\r\n+        integer, allocatable :: blaha(:,:)\r\n+\r\n+        allocate(blaha(2,2))\r\n+        blaha = reshape ([40, 97, 53, 75], [2,2])\r\n+    end function blaha\r\n+\r\n+end program test_constructor\r\n+! { dg-final { scan-tree-dump-times \"deallocate\" 18 \"original\" } }\r\n+! { dg-final { cleanup-tree-dump \"original\" } }\r"}, {"sha": "08c3bdf696ebdfaec0eac3dd6ac4b3f471e0f525", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_constructor_2.f90", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_constructor_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_constructor_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_constructor_2.f90?ref=5046aff56bbd9b2911799ad1e26b7c538fcc513e", "patch": "@@ -0,0 +1,26 @@\n+! { dg-do run }\n+! Test constructors of nested derived types with allocatable components(PR 20541).\n+!\n+! Contributed by Erik Edelmann  <eedelmann@gcc.gnu.org>\n+!            and Paul Thomas  <pault@gcc.gnu.org>\n+!\n+  type :: thytype\n+    integer(4), allocatable :: h(:)\n+  end type thytype\n+\n+  type :: mytype\n+    type(thytype), allocatable :: q(:)\n+  end type mytype\n+\n+  type (mytype) :: x\n+  type (thytype) :: w(2)\n+  integer :: y(2) =(/1,2/)\n+\n+  w = (/thytype(y), thytype (2*y)/)\n+  x = mytype (w)\n+  if (any ((/((x%q(j)%h(i),j=1,2),i=1,2)/) .ne. (/1,2,2,4/))) call abort ()\n+\n+  x = mytype ((/thytype(3*y), thytype (4*y)/))\n+  if (any ((/((x%q(j)%h(i),j=1,2),i=1,2)/) .ne. (/3,4,6,8/))) call abort ()\n+\n+end"}, {"sha": "1976509aaaecd6d09eb42d31d90ca1aea68a9d92", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_initializer_1.f90", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_initializer_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_initializer_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_initializer_1.f90?ref=5046aff56bbd9b2911799ad1e26b7c538fcc513e", "patch": "@@ -0,0 +1,71 @@\n+! { dg-do run }\n+! This checks the correct functioning of derived types with default initializers\n+! and allocatable components.\n+!\n+! Contributed by Salvatore Filippone  <salvatore.filippone@uniroma2.it>\n+!\n+module p_type_mod\n+\n+  type m_type\n+    integer, allocatable :: p(:)\n+  end type m_type\n+\n+  type basep_type\n+    type(m_type), allocatable :: av(:)\n+    type(m_type), pointer :: ap => null ()\n+    integer :: i = 101\n+  end type basep_type\n+\n+  type p_type\n+    type(basep_type), allocatable :: basepv(:)\n+    integer :: p1 , p2 = 1\n+  end type p_type\n+end module p_type_mod\n+\n+program foo\n+ \n+ use p_type_mod\n+  implicit none\n+\n+  type(m_type), target :: a\n+  type(p_type) :: pre\n+  type(basep_type) :: wee\n+\n+  call test_ab8 ()\n+\n+  a = m_type ((/101,102/))  \n+\n+  call p_bld (a, pre)\n+\n+  if (associated (wee%ap) .or. wee%i /= 101) call abort ()\n+  wee%ap => a\n+  if (.not.associated (wee%ap) .or. allocated (wee%av)) call abort ()\n+  wee = basep_type ((/m_type ((/201, 202, 203/))/), null (), 99)\n+  if (.not.allocated (wee%av) .or. associated (wee%ap) .or. (wee%i .ne. 99)) call abort () \n+\n+contains\n+\n+! Check that allocatable components are nullified after allocation.\n+  subroutine test_ab8 ()\n+    type(p_type)    :: p\n+    integer :: ierr\n+  \n+    if (.not.allocated(p%basepv)) then \n+      allocate(p%basepv(1),stat=ierr)\n+    endif\n+    if (allocated (p%basepv) .neqv. .true.) call abort ()\n+    if (allocated (p%basepv(1)%av) .neqv. .false.) call abort\n+    if (p%basepv(1)%i .ne. 101) call abort ()\n+\n+  end subroutine test_ab8\n+\n+    subroutine p_bld (a, p)\n+      use p_type_mod\n+      type (m_type) :: a\n+      type(p_type) :: p\n+      if (any (a%p .ne. (/101,102/))) call abort ()\n+      if (allocated (p%basepv) .or. (p%p2 .ne. 1)) call abort ()\n+    end subroutine p_bld\n+\n+end program foo\n+! { dg-final { cleanup-modules \"p_type_mod\" } }"}, {"sha": "58a0e74633141cf65ebc670dfdc2f53824a111d5", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_initializer_2.f90", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_initializer_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_initializer_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_initializer_2.f90?ref=5046aff56bbd9b2911799ad1e26b7c538fcc513e", "patch": "@@ -0,0 +1,12 @@\n+! { dg-do compile }\n+! Check that default initializer for allocatable components isn't accepted (PR\n+! 20541)\n+program main\n+\n+    type :: foo\n+        integer, allocatable :: a(:) = [ 1 ] ! { dg-error \"Initialization of allocatable\" }\n+\n+        integer :: x ! Just to avoid \"extra\" error messages about empty type.\n+    end type foo\n+\n+end program main"}, {"sha": "2ca7f0ac369ef9a7fd1ac3f5df5fe9a00a7f84d5", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_std.f90", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_std.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_std.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_std.f90?ref=5046aff56bbd9b2911799ad1e26b7c538fcc513e", "patch": "@@ -0,0 +1,14 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f95\" }\n+!\n+! Check that we don't accept allocatable components for -std=f95 (PR 20541)\n+!\n+program main\n+\n+    type :: foo\n+        integer, allocatable :: bar(:) ! { dg-error \"ALLOCATABLE attribute\" }\n+\n+        integer :: x ! Just to avoid \"extra\" error messages about empty type.\n+    end type foo\n+\n+end program main"}, {"sha": "f69e10064132b50374d1a1339f80555b2fb5b402", "filename": "gcc/testsuite/gfortran.dg/derived_constructor_comps_2.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ftestsuite%2Fgfortran.dg%2Fderived_constructor_comps_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ftestsuite%2Fgfortran.dg%2Fderived_constructor_comps_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fderived_constructor_comps_2.f90?ref=5046aff56bbd9b2911799ad1e26b7c538fcc513e", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do compile }\n+! Tests fix for PR29115, in which an ICE would be produced by \n+! non-pointer elements being supplied to the pointer components\n+! in a derived type constructor.\n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+!\n+  type :: homer\n+    integer, pointer :: bart(:)\n+  end type homer\n+  type(homer) :: marge\n+  integer :: duff_beer\n+  marge = homer (duff_beer) ! { dg-error \"should be a POINTER or a TARGET\" }\n+end\n+"}, {"sha": "cad85fb2643ace27b579af4958ef69b8373135d8", "filename": "gcc/testsuite/gfortran.dg/forall_char_dependencies_1.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ftestsuite%2Fgfortran.dg%2Fforall_char_dependencies_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ftestsuite%2Fgfortran.dg%2Fforall_char_dependencies_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fforall_char_dependencies_1.f90?ref=5046aff56bbd9b2911799ad1e26b7c538fcc513e", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do compile }\n+! Tests fix for PR29211, in which an ICE would be produced by FORALL assignments\n+! with dependencies.\n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+!\n+  character(12), dimension(2) :: a, b\n+  a= (/\"abcdefghijkl\",\"mnopqrstuvwx\"/)\n+! OK because it uses gfc_trans_assignment\n+  forall (i=1:2) b(i) = a(i)\n+! Was broken - gfc_trans_assign_need_temp had no handling of string lengths\n+  forall (i=1:2) a(3-i) = a(i)\n+end"}, {"sha": "2d8217750d1b434d98ea771dd4482657ac2ad619", "filename": "gcc/testsuite/gfortran.dg/move_alloc.f90", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ftestsuite%2Fgfortran.dg%2Fmove_alloc.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5046aff56bbd9b2911799ad1e26b7c538fcc513e/gcc%2Ftestsuite%2Fgfortran.dg%2Fmove_alloc.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmove_alloc.f90?ref=5046aff56bbd9b2911799ad1e26b7c538fcc513e", "patch": "@@ -0,0 +1,39 @@\n+! { dg-do run }\n+! Test the move_alloc intrinsic.\n+!\n+! Contributed by Erik Edelmann  <eedelmann@gcc.gnu.org>\n+!            and Paul Thomas  <pault@gcc.gnu.org>\n+!\n+program test_move_alloc\n+\n+    implicit none\n+    integer, allocatable :: x(:), y(:), temp(:)\n+    character(4), allocatable :: a(:), b(:)\n+    integer :: i\n+\n+    allocate (x(2))\n+    allocate (a(2))\n+\n+    x = [ 42, 77 ]\n+\n+    call move_alloc (x, y)\n+    if (allocated(x)) call abort()\n+    if (.not.allocated(y)) call abort()\n+    if (any(y /= [ 42, 77 ])) call abort()\n+\n+    a = [ \"abcd\", \"efgh\" ]\n+    call move_alloc (a, b)\n+    if (allocated(a)) call abort()\n+    if (.not.allocated(b)) call abort()\n+    if (any(b /= [ \"abcd\", \"efgh\" ])) call abort()\n+\n+    ! Now one of the intended applications of move_alloc; resizing\n+\n+    call move_alloc (y, temp)\n+    allocate (y(6), stat=i)\n+    if (i /= 0) call abort()\n+    y(1:2) = temp\n+    y(3:) = 99\n+    deallocate(temp)\n+    if (any(y /= [ 42, 77, 99, 99, 99, 99 ])) call abort()\n+end program test_move_alloc"}, {"sha": "42b35f4ed3f0b7b9290af61c4154d9c1f61acdeb", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5046aff56bbd9b2911799ad1e26b7c538fcc513e/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5046aff56bbd9b2911799ad1e26b7c538fcc513e/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=5046aff56bbd9b2911799ad1e26b7c538fcc513e", "patch": "@@ -1,3 +1,11 @@\n+2006-10-08  Paul Thomas  <pault@gcc.gnu.org>\n+\t    Erik Edelmann  <edelmann@gcc.gnu.org>\n+\n+\tPR libgfortran/20541\n+\t* Makefile.in : Add move_alloc.\n+\t* intrinsics/move_alloc.c: New function.\n+\t* Makefile.am : Add move_alloc.\n+\n 2006-10-08  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n \n \tPR libfortran/26540"}, {"sha": "32cdf4048162ac78ef375d14b71655b3109abffc", "filename": "libgfortran/Makefile.in", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5046aff56bbd9b2911799ad1e26b7c538fcc513e/libgfortran%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5046aff56bbd9b2911799ad1e26b7c538fcc513e/libgfortran%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.in?ref=5046aff56bbd9b2911799ad1e26b7c538fcc513e", "patch": "@@ -169,12 +169,12 @@ am__objects_30 = associated.lo abort.lo access.lo args.lo bessel.lo \\\n \teoshift2.lo etime.lo exit.lo fget.lo flush.lo fnum.lo ftell.lo \\\n \tgerror.lo getcwd.lo getlog.lo getXid.lo hyper.lo hostnm.lo \\\n \tkill.lo ierrno.lo ishftc.lo link.lo malloc.lo mvbits.lo \\\n-\tpack_generic.lo perror.lo signal.lo size.lo sleep.lo \\\n-\tspread_generic.lo string_intrinsics.lo system.lo rand.lo \\\n-\trandom.lo rename.lo reshape_generic.lo reshape_packed.lo \\\n-\tselected_int_kind.lo selected_real_kind.lo stat.lo symlnk.lo \\\n-\tsystem_clock.lo time.lo transpose_generic.lo tty.lo umask.lo \\\n-\tunlink.lo unpack_generic.lo in_pack_generic.lo \\\n+\tmove_alloc.lo pack_generic.lo perror.lo signal.lo size.lo \\\n+\tsleep.lo spread_generic.lo string_intrinsics.lo system.lo \\\n+\trand.lo random.lo rename.lo reshape_generic.lo \\\n+\treshape_packed.lo selected_int_kind.lo selected_real_kind.lo \\\n+\tstat.lo symlnk.lo system_clock.lo time.lo transpose_generic.lo \\\n+\ttty.lo umask.lo unlink.lo unpack_generic.lo in_pack_generic.lo \\\n \tin_unpack_generic.lo\n am__objects_31 =\n am__objects_32 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \\\n@@ -427,6 +427,7 @@ intrinsics/ishftc.c \\\n intrinsics/link.c \\\n intrinsics/malloc.c \\\n intrinsics/mvbits.c \\\n+intrinsics/move_alloc.c \\\n intrinsics/pack_generic.c \\\n intrinsics/perror.c \\\n intrinsics/signal.c \\\n@@ -2409,6 +2410,9 @@ malloc.lo: intrinsics/malloc.c\n mvbits.lo: intrinsics/mvbits.c\n \t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o mvbits.lo `test -f 'intrinsics/mvbits.c' || echo '$(srcdir)/'`intrinsics/mvbits.c\n \n+move_alloc.lo: intrinsics/move_alloc.c\n+\t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o move_alloc.lo `test -f 'intrinsics/move_alloc.c' || echo '$(srcdir)/'`intrinsics/move_alloc.c\n+\n pack_generic.lo: intrinsics/pack_generic.c\n \t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o pack_generic.lo `test -f 'intrinsics/pack_generic.c' || echo '$(srcdir)/'`intrinsics/pack_generic.c\n "}, {"sha": "b73ef4b77a0a8daf9bf82d9370ee6b1a3839ed90", "filename": "libgfortran/intrinsics/move_alloc.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5046aff56bbd9b2911799ad1e26b7c538fcc513e/libgfortran%2Fintrinsics%2Fmove_alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5046aff56bbd9b2911799ad1e26b7c538fcc513e/libgfortran%2Fintrinsics%2Fmove_alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fmove_alloc.c?ref=5046aff56bbd9b2911799ad1e26b7c538fcc513e", "patch": "@@ -0,0 +1,67 @@\n+/* Generic implementation of the MOVE_ALLOC intrinsic\n+   Copyright (C) 2006 Free Software Foundation, Inc.\n+   Contributed by Paul Thomas\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+\n+extern void move_alloc (gfc_array_char *, gfc_array_char *);\n+export_proto(move_alloc);\n+\n+void\n+move_alloc (gfc_array_char * from, gfc_array_char * to)\n+{\n+  int i;\n+\n+  internal_free (to->data);\n+\n+  for (i = 0; i < GFC_DESCRIPTOR_RANK (from); i++)\n+    {\n+      to->dim[i].lbound = from->dim[i].lbound;\n+      to->dim[i].ubound = from->dim[i].ubound;\n+      to->dim[i].stride = from->dim[i].stride;\n+      from->dim[i].stride = 0;\n+      from->dim[i].ubound = from->dim[i].lbound;\n+    }\n+\n+  to->offset = from->offset;\n+  to->dtype = from->dtype;\n+  to->data = from->data;\n+  from->data = NULL;\n+}\n+\n+extern void move_alloc_c (gfc_array_char *, GFC_INTEGER_4,\n+\t\t\t  gfc_array_char *, GFC_INTEGER_4);\n+export_proto(move_alloc_c);\n+\n+void\n+move_alloc_c (gfc_array_char * from, GFC_INTEGER_4 from_length __attribute__((unused)),\n+\t      gfc_array_char * to, GFC_INTEGER_4 to_length __attribute__((unused)))\n+{\n+  move_alloc (from, to);\n+}"}]}