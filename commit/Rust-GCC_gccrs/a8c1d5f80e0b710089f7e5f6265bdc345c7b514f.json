{"sha": "a8c1d5f80e0b710089f7e5f6265bdc345c7b514f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YThjMWQ1ZjgwZTBiNzEwMDg5ZjdlNWY2MjY1YmRjMzQ1YzdiNTE0Zg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard@codesourcery.com", "date": "2006-03-09T21:03:17Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2006-03-09T21:03:17Z"}, "message": "mips-protos.h (mips_output_conditional_branch): Change interface.\n\n\t* config/mips/mips-protos.h (mips_output_conditional_branch): Change\n\tinterface.\n\t(mips_output_order_conditional_branch): Declare.\n\t* config/mips/mips.h (MIPS_BRANCH): New macro.\n\t* config/mips/mips.c (gen_conditional_branch): Use VOIDmode\n\tfor the comparison.  Use gen_condjump.\n\t(mips_output_conditional_branch): Rework interface to take the\n\tasm templates for a direct branch and the inverse of a direct branch.\n\t(mips_output_order_conditional_branch): New function.\n\t(mips_builtin_branch_and_move): New function.\n\t(mips_expand_builtin_compare): Use it.  Use VOIDmode for the\n\tbranch condition.  Use gen_single_cc as the condition for\n\t__builtin_mips_upper_* or __builtin_mips_lower_*.\n\t(mips_expand_builtin_bposge): Use mips_builtin_branch_and_move.\n\tUse VOIDmode for the branch condition.\n\t* config/mips/predicates.md (order_operator): New predicate.\n\t* config/mips/mips.md (UNSPEC_SINGLE_CC): New constant.\n\t(branch_fp): Rename to...\n\t(*branch_fp): ...this.  Remove mode from comparison operator.\n\tUse new mips_output_conditional_branch interface.\n\t(branch_fp_inverted): Rename to...\n\t(*branch_fp_inverted): ...this and update as for *branch_fp.\n\t(*branch_zero<mode>): Rename to...\n\t(*branch_order<mode>): ...this.  Remove mode from comparison operator.\n\tUse mips_output_order_conditional_branch.  Only accept ordered\n\tcomparisons.  \n\t(*branch_zero<mode>_inverted): Rename to...\n\t(*branch_order<mode>_inverted): ...this and update as for\n\t*branch_order<mode>.\n\t(*branch_equality<mode>): Accept zero as the second operand to\n\tthe equality operator.  Use the new mips_output_conditional_branch\n\tinterface.\n\t(*branch_equality<mode>_inverted): Likewise.\n\t(condjump): New expander.\n\t* config/mips/mips-dsp.md (mips_bposge): Remove mode from comparison\n\toperator.\n\t* config/mips/mips-ps-3d.md (bc1any4t, bc1any4f): Likewise.\n\t(bc1any2t, bc1any2f): Likewise.\n\t(single_cc): New expander.\n\t(*branch_upper_lower, *branch_upper_lower_inverted): New patterns.\n\nFrom-SVN: r111909", "tree": {"sha": "158c3ae50f6fe3219c35b26ac707baac94ae4ad9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/158c3ae50f6fe3219c35b26ac707baac94ae4ad9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a8c1d5f80e0b710089f7e5f6265bdc345c7b514f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8c1d5f80e0b710089f7e5f6265bdc345c7b514f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8c1d5f80e0b710089f7e5f6265bdc345c7b514f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8c1d5f80e0b710089f7e5f6265bdc345c7b514f/comments", "author": null, "committer": null, "parents": [{"sha": "1fea4e6c4301b2b69d6e2fa72c3c62ffdc8cfb78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fea4e6c4301b2b69d6e2fa72c3c62ffdc8cfb78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fea4e6c4301b2b69d6e2fa72c3c62ffdc8cfb78"}], "stats": {"total": 678, "additions": 320, "deletions": 358}, "files": [{"sha": "32155a4e9330cfd67c8a75d9b1382b2f15740248", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c1d5f80e0b710089f7e5f6265bdc345c7b514f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c1d5f80e0b710089f7e5f6265bdc345c7b514f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a8c1d5f80e0b710089f7e5f6265bdc345c7b514f", "patch": "@@ -1,3 +1,46 @@\n+2006-03-09  Richard Sandiford  <richard@codesourcery.com>\n+\n+\t* config/mips/mips-protos.h (mips_output_conditional_branch): Change\n+\tinterface.\n+\t(mips_output_order_conditional_branch): Declare.\n+\t* config/mips/mips.h (MIPS_BRANCH): New macro.\n+\t* config/mips/mips.c (gen_conditional_branch): Use VOIDmode\n+\tfor the comparison.  Use gen_condjump.\n+\t(mips_output_conditional_branch): Rework interface to take the\n+\tasm templates for a direct branch and the inverse of a direct branch.\n+\t(mips_output_order_conditional_branch): New function.\n+\t(mips_builtin_branch_and_move): New function.\n+\t(mips_expand_builtin_compare): Use it.  Use VOIDmode for the\n+\tbranch condition.  Use gen_single_cc as the condition for\n+\t__builtin_mips_upper_* or __builtin_mips_lower_*.\n+\t(mips_expand_builtin_bposge): Use mips_builtin_branch_and_move.\n+\tUse VOIDmode for the branch condition.\n+\t* config/mips/predicates.md (order_operator): New predicate.\n+\t* config/mips/mips.md (UNSPEC_SINGLE_CC): New constant.\n+\t(branch_fp): Rename to...\n+\t(*branch_fp): ...this.  Remove mode from comparison operator.\n+\tUse new mips_output_conditional_branch interface.\n+\t(branch_fp_inverted): Rename to...\n+\t(*branch_fp_inverted): ...this and update as for *branch_fp.\n+\t(*branch_zero<mode>): Rename to...\n+\t(*branch_order<mode>): ...this.  Remove mode from comparison operator.\n+\tUse mips_output_order_conditional_branch.  Only accept ordered\n+\tcomparisons.  \n+\t(*branch_zero<mode>_inverted): Rename to...\n+\t(*branch_order<mode>_inverted): ...this and update as for\n+\t*branch_order<mode>.\n+\t(*branch_equality<mode>): Accept zero as the second operand to\n+\tthe equality operator.  Use the new mips_output_conditional_branch\n+\tinterface.\n+\t(*branch_equality<mode>_inverted): Likewise.\n+\t(condjump): New expander.\n+\t* config/mips/mips-dsp.md (mips_bposge): Remove mode from comparison\n+\toperator.\n+\t* config/mips/mips-ps-3d.md (bc1any4t, bc1any4f): Likewise.\n+\t(bc1any2t, bc1any2f): Likewise.\n+\t(single_cc): New expander.\n+\t(*branch_upper_lower, *branch_upper_lower_inverted): New patterns.\n+\n 2006-03-09  Richard Sandiford  <richard@codesourcery.com>\n \n \t* doc/md.texi: Update documentation of MIPS constraints."}, {"sha": "3fdcc5930019b1d43b21a546e4bb4c8eaa0af6be", "filename": "gcc/config/mips/mips-dsp.md", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c1d5f80e0b710089f7e5f6265bdc345c7b514f/gcc%2Fconfig%2Fmips%2Fmips-dsp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c1d5f80e0b710089f7e5f6265bdc345c7b514f/gcc%2Fconfig%2Fmips%2Fmips-dsp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-dsp.md?ref=a8c1d5f80e0b710089f7e5f6265bdc345c7b514f", "patch": "@@ -1046,11 +1046,10 @@\n ;; BPOSGE32\n (define_insn \"mips_bposge\"\n   [(set (pc)\n-\t(if_then_else\n-\t   (ge:CCDSP (reg:CCDSP CCDSP_PO_REGNUM)\n-\t\t     (match_operand:SI 0 \"immediate_operand\" \"I\"))\n-\t   (label_ref (match_operand 1 \"\" \"\"))\n-\t   (pc)))]\n+\t(if_then_else (ge (reg:CCDSP CCDSP_PO_REGNUM)\n+\t\t\t  (match_operand:SI 0 \"immediate_operand\" \"I\"))\n+\t\t      (label_ref (match_operand 1 \"\" \"\"))\n+\t\t      (pc)))]\n   \"TARGET_DSP\"\n   \"%*bposge%0\\t%1%/\"\n   [(set_attr \"type\"\t\"branch\")"}, {"sha": "1dc31f565ebeeb3d72b8a6a11f0e99e10a74e03e", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c1d5f80e0b710089f7e5f6265bdc345c7b514f/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c1d5f80e0b710089f7e5f6265bdc345c7b514f/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=a8c1d5f80e0b710089f7e5f6265bdc345c7b514f", "patch": "@@ -212,8 +212,9 @@ extern int mips_register_move_cost (enum machine_mode, enum reg_class,\n \n extern int mips_adjust_insn_length (rtx, int);\n extern const char *mips_output_load_label (void);\n-extern const char *mips_output_conditional_branch (rtx, rtx *, int, int,\n-\t\t\t\t\t\t   int, int);\n+extern const char *mips_output_conditional_branch (rtx, rtx *, const char *,\n+\t\t\t\t\t\t   const char *);\n+extern const char *mips_output_order_conditional_branch (rtx, rtx *, bool);\n extern const char *mips_output_division (const char *, rtx *);\n extern unsigned int mips_hard_regno_nregs (int, enum machine_mode);\n extern bool mips_linked_madd_p (rtx, rtx);"}, {"sha": "6a4c2b93e0a4bc4e7561ea507899f5e5f3eae0b7", "filename": "gcc/config/mips/mips-ps-3d.md", "status": "modified", "additions": 61, "deletions": 8, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c1d5f80e0b710089f7e5f6265bdc345c7b514f/gcc%2Fconfig%2Fmips%2Fmips-ps-3d.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c1d5f80e0b710089f7e5f6265bdc345c7b514f/gcc%2Fconfig%2Fmips%2Fmips-ps-3d.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-ps-3d.md?ref=a8c1d5f80e0b710089f7e5f6265bdc345c7b514f", "patch": "@@ -389,8 +389,8 @@\n ; Branch on Any of Four Floating Point Condition Codes True\n (define_insn \"bc1any4t\"\n   [(set (pc)\n-\t(if_then_else (ne:CCV4 (match_operand:CCV4 0 \"register_operand\" \"z\")\n-\t\t\t       (const_int 0))\n+\t(if_then_else (ne (match_operand:CCV4 0 \"register_operand\" \"z\")\n+\t\t\t  (const_int 0))\n \t\t      (label_ref (match_operand 1 \"\" \"\"))\n \t\t      (pc)))]\n   \"TARGET_MIPS3D\"\n@@ -401,8 +401,8 @@\n ; Branch on Any of Four Floating Point Condition Codes False\n (define_insn \"bc1any4f\"\n   [(set (pc)\n-\t(if_then_else (ne:CCV4 (match_operand:CCV4 0 \"register_operand\" \"z\")\n-\t\t\t       (const_int -1))\n+\t(if_then_else (ne (match_operand:CCV4 0 \"register_operand\" \"z\")\n+\t\t\t  (const_int -1))\n \t\t      (label_ref (match_operand 1 \"\" \"\"))\n \t\t      (pc)))]\n   \"TARGET_MIPS3D\"\n@@ -413,8 +413,8 @@\n ; Branch on Any of Two Floating Point Condition Codes True\n (define_insn \"bc1any2t\"\n   [(set (pc)\n-\t(if_then_else (ne:CCV2 (match_operand:CCV2 0 \"register_operand\" \"z\")\n-\t\t\t       (const_int 0))\n+\t(if_then_else (ne (match_operand:CCV2 0 \"register_operand\" \"z\")\n+\t\t\t  (const_int 0))\n \t\t      (label_ref (match_operand 1 \"\" \"\"))\n \t\t      (pc)))]\n   \"TARGET_MIPS3D\"\n@@ -425,15 +425,68 @@\n ; Branch on Any of Two Floating Point Condition Codes False\n (define_insn \"bc1any2f\"\n   [(set (pc)\n-\t(if_then_else (ne:CCV2 (match_operand:CCV2 0 \"register_operand\" \"z\")\n-\t\t\t       (const_int -1))\n+\t(if_then_else (ne (match_operand:CCV2 0 \"register_operand\" \"z\")\n+\t\t\t  (const_int -1))\n \t\t      (label_ref (match_operand 1 \"\" \"\"))\n \t\t      (pc)))]\n   \"TARGET_MIPS3D\"\n   \"%*bc1any2f\\t%0,%1%/\"\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"mode\" \"none\")])\n \n+; Used to access one register in a CCV2 pair.  Operand 0 is the register\n+; pair and operand 1 is the index of the register we want (a CONST_INT).\n+(define_expand \"single_cc\"\n+  [(ne (unspec:CC [(match_operand 0) (match_operand 1)] UNSPEC_SINGLE_CC)\n+       (const_int 0))])\n+\n+; This is a normal floating-point branch pattern, but rather than check\n+; a single CCmode register, it checks one register in a CCV2 pair.\n+; Operand 2 is the register pair and operand 3 is the index of the\n+; register we want.\n+(define_insn \"*branch_upper_lower\"\n+  [(set (pc)\n+        (if_then_else\n+\t (match_operator 0 \"equality_operator\"\n+\t    [(unspec:CC [(match_operand:CCV2 2 \"register_operand\" \"z\")\n+\t\t\t (match_operand 3 \"const_int_operand\")]\n+\t\t\tUNSPEC_SINGLE_CC)\n+\t     (const_int 0)])\n+\t (label_ref (match_operand 1 \"\" \"\"))\n+\t (pc)))]\n+  \"TARGET_HARD_FLOAT\"\n+{\n+  operands[2]\n+    = gen_rtx_REG (CCmode, REGNO (operands[2]) + INTVAL (operands[3]));\n+  return mips_output_conditional_branch (insn, operands,\n+\t\t\t\t\t MIPS_BRANCH (\"b%F0\", \"%2,%1\"),\n+\t\t\t\t\t MIPS_BRANCH (\"b%W0\", \"%2,%1\"));\n+}\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"mode\" \"none\")])\n+\n+; As above, but with the sense of the condition reversed.\n+(define_insn \"*branch_upper_lower_inverted\"\n+  [(set (pc)\n+        (if_then_else\n+\t (match_operator 0 \"equality_operator\"\n+\t    [(unspec:CC [(match_operand:CCV2 2 \"register_operand\" \"z\")\n+\t\t\t (match_operand 3 \"const_int_operand\")]\n+\t\t\tUNSPEC_SINGLE_CC)\n+\t     (const_int 0)])\n+\t (pc)\n+\t (label_ref (match_operand 1 \"\" \"\"))))]\n+  \"TARGET_HARD_FLOAT\"\n+{\n+  operands[2]\n+    = gen_rtx_REG (CCmode, REGNO (operands[2]) + INTVAL (operands[3]));\n+  return mips_output_conditional_branch (insn, operands,\n+\t\t\t\t\t MIPS_BRANCH (\"b%W0\", \"%2,%1\"),\n+\t\t\t\t\t MIPS_BRANCH (\"b%F0\", \"%2,%1\"));\n+}\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"mode\" \"none\")])\n+\n ;----------------------------------------------------------------------------\n ; Floating Point Reduced Precision Reciprocal Square Root Instructions.\n ;----------------------------------------------------------------------------"}, {"sha": "daa748804e164dc5bd2020941ed355b5773c3fcb", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 159, "deletions": 284, "changes": 443, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c1d5f80e0b710089f7e5f6265bdc345c7b514f/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c1d5f80e0b710089f7e5f6265bdc345c7b514f/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=a8c1d5f80e0b710089f7e5f6265bdc345c7b514f", "patch": "@@ -3186,15 +3186,11 @@ mips_emit_scc (enum rtx_code code, rtx target)\n void\n gen_conditional_branch (rtx *operands, enum rtx_code code)\n {\n-  rtx op0, op1, target;\n+  rtx op0, op1, condition;\n \n   mips_emit_compare (&code, &op0, &op1, TARGET_MIPS16);\n-  target = gen_rtx_IF_THEN_ELSE (VOIDmode,\n-\t\t\t\t gen_rtx_fmt_ee (code, GET_MODE (op0),\n-\t\t\t\t\t\t op0, op1),\n-\t\t\t\t gen_rtx_LABEL_REF (VOIDmode, operands[0]),\n-\t\t\t\t pc_rtx);\n-  emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx, target));\n+  condition = gen_rtx_fmt_ee (code, VOIDmode, op0, op1);\n+  emit_jump_insn (gen_condjump (condition, operands[0]));\n }\n \n /* Emit the common code for conditional moves.  OPERANDS is the array\n@@ -9127,217 +9123,126 @@ mips_output_load_label (void)\n     }\n }\n \n+/* Return the assembly code for INSN, which has the operands given by\n+   OPERANDS, and which branches to OPERANDS[1] if some condition is true.\n+   BRANCH_IF_TRUE is the asm template that should be used if OPERANDS[1]\n+   is in range of a direct branch.  BRANCH_IF_FALSE is an inverted\n+   version of BRANCH_IF_TRUE.  */\n \n-/* Output assembly instructions to peform a conditional branch.\n-\n-   INSN is the branch instruction.  OPERANDS[0] is the condition.\n-   OPERANDS[1] is the target of the branch.  OPERANDS[2] is the target\n-   of the first operand to the condition.  If TWO_OPERANDS_P is\n-   nonzero the comparison takes two operands; OPERANDS[3] will be the\n-   second operand.\n-\n-   If INVERTED_P is nonzero we are to branch if the condition does\n-   not hold.  If FLOAT_P is nonzero this is a floating-point comparison.\n-\n-   LENGTH is the length (in bytes) of the sequence we are to generate.\n-   That tells us whether to generate a simple conditional branch, or a\n-   reversed conditional branch around a `jr' instruction.  */\n const char *\n-mips_output_conditional_branch (rtx insn, rtx *operands, int two_operands_p,\n-\t\t\t\tint float_p, int inverted_p, int length)\n-{\n-  static char buffer[200];\n-  /* The kind of comparison we are doing.  */\n-  enum rtx_code code = GET_CODE (operands[0]);\n-  /* Nonzero if the opcode for the comparison needs a `z' indicating\n-     that it is a comparison against zero.  */\n-  int need_z_p;\n-  /* A string to use in the assembly output to represent the first\n-     operand.  */\n-  const char *op1 = \"%z2\";\n-  /* A string to use in the assembly output to represent the second\n-     operand.  Use the hard-wired zero register if there's no second\n-     operand.  */\n-  const char *op2 = (two_operands_p ? \",%z3\" : \",%.\");\n-  /* The operand-printing string for the comparison.  */\n-  const char *const comp = (float_p ? \"%F0\" : \"%C0\");\n-  /* The operand-printing string for the inverted comparison.  */\n-  const char *const inverted_comp = (float_p ? \"%W0\" : \"%N0\");\n-\n-  /* The MIPS processors (for levels of the ISA at least two), have\n-     \"likely\" variants of each branch instruction.  These instructions\n-     annul the instruction in the delay slot if the branch is not\n-     taken.  */\n-  mips_branch_likely = (final_sequence && INSN_ANNULLED_BRANCH_P (insn));\n-\n-  if (!two_operands_p)\n-    {\n-      /* To compute whether than A > B, for example, we normally\n-\t subtract B from A and then look at the sign bit.  But, if we\n-\t are doing an unsigned comparison, and B is zero, we don't\n-\t have to do the subtraction.  Instead, we can just check to\n-\t see if A is nonzero.  Thus, we change the CODE here to\n-\t reflect the simpler comparison operation.  */\n-      switch (code)\n-\t{\n-\tcase GTU:\n-\t  code = NE;\n-\t  break;\n+mips_output_conditional_branch (rtx insn, rtx *operands,\n+\t\t\t\tconst char *branch_if_true,\n+\t\t\t\tconst char *branch_if_false)\n+{\n+  unsigned int length;\n+  rtx taken, not_taken;\n \n-\tcase LEU:\n-\t  code = EQ;\n-\t  break;\n+  length = get_attr_length (insn);\n+  if (length <= 8)\n+    {\n+      /* Just a simple conditional branch.  */\n+      mips_branch_likely = (final_sequence && INSN_ANNULLED_BRANCH_P (insn));\n+      return branch_if_true;\n+    }\n \n-\tcase GEU:\n-\t  /* A condition which will always be true.  */\n-\t  code = EQ;\n-\t  op1 = \"%.\";\n-\t  break;\n+  /* Generate a reversed branch around a direct jump.  This fallback does\n+     not use branch-likely instructions.  */\n+  mips_branch_likely = false;\n+  not_taken = gen_label_rtx ();\n+  taken = operands[1];\n \n-\tcase LTU:\n-\t  /* A condition which will always be false.  */\n-\t  code = NE;\n-\t  op1 = \"%.\";\n-\t  break;\n+  /* Generate the reversed branch to NOT_TAKEN.  */\n+  operands[1] = not_taken;\n+  output_asm_insn (branch_if_false, operands);\n \n-\tdefault:\n-\t  /* Not a special case.  */\n-\t  break;\n+  /* If INSN has a delay slot, we must provide delay slots for both the\n+     branch to NOT_TAKEN and the conditional jump.  We must also ensure\n+     that INSN's delay slot is executed in the appropriate cases.  */\n+  if (final_sequence)\n+    {\n+      /* This first delay slot will always be executed, so use INSN's\n+\t delay slot if is not annulled.  */\n+      if (!INSN_ANNULLED_BRANCH_P (insn))\n+\t{\n+\t  final_scan_insn (XVECEXP (final_sequence, 0, 1),\n+\t\t\t   asm_out_file, optimize, 1, NULL);\n+\t  INSN_DELETED_P (XVECEXP (final_sequence, 0, 1)) = 1;\n \t}\n+      else\n+\toutput_asm_insn (\"nop\", 0);\n+      fprintf (asm_out_file, \"\\n\");\n     }\n \n-  /* Relative comparisons are always done against zero.  But\n-     equality comparisons are done between two operands, and therefore\n-     do not require a `z' in the assembly language output.  */\n-  need_z_p = (!float_p && code != EQ && code != NE);\n-  /* For comparisons against zero, the zero is not provided\n-     explicitly.  */\n-  if (need_z_p)\n-    op2 = \"\";\n-\n-  /* Begin by terminating the buffer.  That way we can always use\n-     strcat to add to it.  */\n-  buffer[0] = '\\0';\n+  /* Output the unconditional branch to TAKEN.  */\n+  if (length <= 16)\n+    output_asm_insn (\"j\\t%0%/\", &taken);\n+  else\n+    {\n+      output_asm_insn (mips_output_load_label (), &taken);\n+      output_asm_insn (\"jr\\t%@%]%/\", 0);\n+    }\n \n-  switch (length)\n+  /* Now deal with its delay slot; see above.  */\n+  if (final_sequence)\n     {\n-    case 4:\n-    case 8:\n-      /* Just a simple conditional branch.  */\n-      if (float_p)\n-\tsprintf (buffer, \"%%*b%s%%?\\t%%Z2%%1%%/\",\n-\t\t inverted_p ? inverted_comp : comp);\n+      /* This delay slot will only be executed if the branch is taken.\n+\t Use INSN's delay slot if is annulled.  */\n+      if (INSN_ANNULLED_BRANCH_P (insn))\n+\t{\n+\t  final_scan_insn (XVECEXP (final_sequence, 0, 1),\n+\t\t\t   asm_out_file, optimize, 1, NULL);\n+\t  INSN_DELETED_P (XVECEXP (final_sequence, 0, 1)) = 1;\n+\t}\n       else\n-\tsprintf (buffer, \"%%*b%s%s%%?\\t%s%s,%%1%%/\",\n-\t\t inverted_p ? inverted_comp : comp,\n-\t\t need_z_p ? \"z\" : \"\",\n-\t\t op1,\n-\t\t op2);\n-      return buffer;\n-\n-    case 12:\n-    case 16:\n-    case 24:\n-    case 28:\n-      {\n-\t/* Generate a reversed conditional branch around ` j'\n-\t   instruction:\n-\n-\t\t.set noreorder\n-\t\t.set nomacro\n-\t\tbc    l\n-\t\tdelay_slot or #nop\n-\t\tj     target\n-\t\t#nop\n-\t     l:\n-\t\t.set macro\n-\t\t.set reorder\n-\n-\t   If the original branch was a likely branch, the delay slot\n-\t   must be executed only if the branch is taken, so generate:\n-\n-\t\t.set noreorder\n-\t\t.set nomacro\n-\t\tbc    l\n-\t\t#nop\n-\t\tj     target\n-\t\tdelay slot or #nop\n-\t     l:\n-\t\t.set macro\n-\t\t.set reorder\n-\n-\t   When generating PIC, instead of:\n-\n-\t        j     target\n-\n-\t   we emit:\n-\n-\t        .set noat\n-\t        la    $at, target\n-\t\tjr    $at\n-\t\t.set at\n-\t*/\n-\n-        rtx orig_target;\n-\trtx target = gen_label_rtx ();\n-\n-        orig_target = operands[1];\n-        operands[1] = target;\n-\t/* Generate the reversed comparison.  This takes four\n-\t   bytes.  */\n-\tif (float_p)\n-\t  sprintf (buffer, \"%%*b%s\\t%%Z2%%1\",\n-\t\t   inverted_p ? comp : inverted_comp);\n-\telse\n-\t  sprintf (buffer, \"%%*b%s%s\\t%s%s,%%1\",\n-\t\t   inverted_p ? comp : inverted_comp,\n-\t\t   need_z_p ? \"z\" : \"\",\n-\t\t   op1,\n-\t\t   op2);\n-        output_asm_insn (buffer, operands);\n-\n-        if (length != 16 && length != 28 && ! mips_branch_likely)\n-          {\n-            /* Output delay slot instruction.  */\n-            rtx insn = final_sequence;\n-            final_scan_insn (XVECEXP (insn, 0, 1), asm_out_file,\n-                             optimize, 1, NULL);\n-            INSN_DELETED_P (XVECEXP (insn, 0, 1)) = 1;\n-          }\n-\telse\n-\t  output_asm_insn (\"%#\", 0);\n+\toutput_asm_insn (\"nop\", 0);\n+      fprintf (asm_out_file, \"\\n\");\n+    }\n \n-\tif (length <= 16)\n-\t  output_asm_insn (\"j\\t%0\", &orig_target);\n-\telse\n-\t  {\n-\t    output_asm_insn (mips_output_load_label (), &orig_target);\n-\t    output_asm_insn (\"jr\\t%@%]\", 0);\n-\t  }\n+  /* Output NOT_TAKEN.  */\n+  (*targetm.asm_out.internal_label) (asm_out_file, \"L\",\n+\t\t\t\t     CODE_LABEL_NUMBER (not_taken));\n+  return \"\";\n+}\n \n-        if (length != 16 && length != 28 && mips_branch_likely)\n-          {\n-            /* Output delay slot instruction.  */\n-            rtx insn = final_sequence;\n-            final_scan_insn (XVECEXP (insn, 0, 1), asm_out_file,\n-                             optimize, 1, NULL);\n-            INSN_DELETED_P (XVECEXP (insn, 0, 1)) = 1;\n-          }\n-\telse\n-\t  output_asm_insn (\"%#\", 0);\n+/* Return the assembly code for INSN, which branches to OPERANDS[1]\n+   if some ordered condition is true.  The condition is given by\n+   OPERANDS[0] if !INVERTED_P, otherwise it is the inverse of\n+   OPERANDS[0].  OPERANDS[2] is the comparison's first operand;\n+   its second is always zero.  */\n \n-        (*targetm.asm_out.internal_label) (asm_out_file, \"L\",\n-                                   CODE_LABEL_NUMBER (target));\n+const char *\n+mips_output_order_conditional_branch (rtx insn, rtx *operands, bool inverted_p)\n+{\n+  const char *branch[2];\n \n-        return \"\";\n-      }\n+  /* Make BRANCH[1] branch to OPERANDS[1] when the condition is true.\n+     Make BRANCH[0] branch on the inverse condition.  */\n+  switch (GET_CODE (operands[0]))\n+    {\n+      /* These cases are equivalent to comparisons against zero.  */\n+    case LEU:\n+      inverted_p = !inverted_p;\n+      /* Fall through.  */\n+    case GTU:\n+      branch[!inverted_p] = MIPS_BRANCH (\"bne\", \"%2,%.,%1\");\n+      branch[inverted_p] = MIPS_BRANCH (\"beq\", \"%2,%.,%1\");\n+      break;\n+\n+      /* These cases are always true or always false.  */\n+    case LTU:\n+      inverted_p = !inverted_p;\n+      /* Fall through.  */\n+    case GEU:\n+      branch[!inverted_p] = MIPS_BRANCH (\"beq\", \"%.,%.,%1\");\n+      branch[inverted_p] = MIPS_BRANCH (\"bne\", \"%.,%.,%1\");\n+      break;\n \n     default:\n-      gcc_unreachable ();\n+      branch[!inverted_p] = MIPS_BRANCH (\"b%C0z\", \"%2,%1\");\n+      branch[inverted_p] = MIPS_BRANCH (\"b%N0z\", \"%2,%1\");\n+      break;\n     }\n-\n-  /* NOTREACHED */\n-  return 0;\n+  return mips_output_conditional_branch (insn, operands, branch[1], branch[0]);\n }\n \f\n /* Used to output div or ddiv instruction DIVISION, which has the operands\n@@ -10591,6 +10496,34 @@ mips_expand_builtin_movtf (enum mips_builtin_type type,\n   return target;\n }\n \n+/* Move VALUE_IF_TRUE into TARGET if CONDITION is true; move VALUE_IF_FALSE\n+   into TARGET otherwise.  Return TARGET.  */\n+\n+static rtx\n+mips_builtin_branch_and_move (rtx condition, rtx target,\n+\t\t\t      rtx value_if_true, rtx value_if_false)\n+{\n+  rtx true_label, done_label;\n+\n+  true_label = gen_label_rtx ();\n+  done_label = gen_label_rtx ();\n+\n+  /* First assume that CONDITION is false.  */\n+  emit_move_insn (target, value_if_false);\n+\n+  /* Branch to TRUE_LABEL if CONDITION is true and DONE_LABEL otherwise.  */\n+  emit_jump_insn (gen_condjump (condition, true_label));\n+  emit_jump_insn (gen_jump (done_label));\n+  emit_barrier ();\n+\n+  /* Fix TARGET if CONDITION is true.  */\n+  emit_label (true_label);\n+  emit_move_insn (target, value_if_true);\n+\n+  emit_label (done_label);\n+  return target;\n+}\n+\n /* Expand a comparison builtin of type BUILTIN_TYPE.  ICODE is the code\n    of the comparison instruction and COND is the condition it should test.\n    ARGLIST is the list of function arguments and TARGET, if nonnull,\n@@ -10601,10 +10534,8 @@ mips_expand_builtin_compare (enum mips_builtin_type builtin_type,\n \t\t\t     enum insn_code icode, enum mips_fp_condition cond,\n \t\t\t     rtx target, tree arglist)\n {\n-  rtx label1, label2, if_then_else;\n-  rtx pat, cmp_result, ops[MAX_RECOG_OPERANDS];\n-  rtx target_if_equal, target_if_unequal;\n-  int cmp_value, i;\n+  rtx offset, condition, cmp_result, ops[MAX_RECOG_OPERANDS];\n+  int i;\n \n   if (target == 0 || GET_MODE (target) != SImode)\n     target = gen_reg_rtx (SImode);\n@@ -10617,12 +10548,12 @@ mips_expand_builtin_compare (enum mips_builtin_type builtin_type,\n   switch (insn_data[icode].n_operands)\n     {\n     case 4:\n-      pat = GEN_FCN (icode) (cmp_result, ops[1], ops[2], GEN_INT (cond));\n+      emit_insn (GEN_FCN (icode) (cmp_result, ops[1], ops[2], GEN_INT (cond)));\n       break;\n \n     case 6:\n-      pat = GEN_FCN (icode) (cmp_result, ops[1], ops[2],\n-\t\t\t     ops[3], ops[4], GEN_INT (cond));\n+      emit_insn (GEN_FCN (icode) (cmp_result, ops[1], ops[2],\n+\t\t\t\t  ops[3], ops[4], GEN_INT (cond)));\n       break;\n \n     default:\n@@ -10631,71 +10562,35 @@ mips_expand_builtin_compare (enum mips_builtin_type builtin_type,\n \n   /* If the comparison sets more than one register, we define the result\n      to be 0 if all registers are false and -1 if all registers are true.\n-     The value of the complete result is indeterminate otherwise.  It is\n-     possible to test individual registers using SUBREGs.\n-\n-     Set up CMP_RESULT, CMP_VALUE, TARGET_IF_EQUAL and TARGET_IF_UNEQUAL so\n-     that the result should be TARGET_IF_EQUAL if (EQ CMP_RESULT CMP_VALUE)\n-     and TARGET_IF_UNEQUAL otherwise.  */\n-  if (builtin_type == MIPS_BUILTIN_CMP_ALL)\n-    {\n-      cmp_value = -1;\n-      target_if_equal = const1_rtx;\n-      target_if_unequal = const0_rtx;\n-    }\n-  else\n+     The value of the complete result is indeterminate otherwise.  */\n+  switch (builtin_type)\n     {\n-      cmp_value = 0;\n-      target_if_equal = const0_rtx;\n-      target_if_unequal = const1_rtx;\n-      if (builtin_type == MIPS_BUILTIN_CMP_UPPER)\n-\tcmp_result = simplify_gen_subreg (CCmode, cmp_result, CCV2mode, 4);\n-      else if (builtin_type == MIPS_BUILTIN_CMP_LOWER)\n-\tcmp_result = simplify_gen_subreg (CCmode, cmp_result, CCV2mode, 0);\n-    }\n-\n-  /* First assume that CMP_RESULT == CMP_VALUE.  */\n-  emit_move_insn (target, target_if_equal);\n-\n-  /* Branch to LABEL1 if CMP_RESULT != CMP_VALUE.  */\n-  emit_insn (pat);\n-  label1 = gen_label_rtx ();\n-  label2 = gen_label_rtx ();\n-  if_then_else\n-    = gen_rtx_IF_THEN_ELSE (VOIDmode,\n-\t\t\t    gen_rtx_fmt_ee (NE, GET_MODE (cmp_result),\n-\t\t\t\t\t    cmp_result, GEN_INT (cmp_value)),\n-\t\t\t    gen_rtx_LABEL_REF (VOIDmode, label1), pc_rtx);\n-  emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx, if_then_else));\n-  emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx,\n-\t\t\t       gen_rtx_LABEL_REF (VOIDmode, label2)));\n-  emit_barrier ();\n-  emit_label (label1);\n+    case MIPS_BUILTIN_CMP_ALL:\n+      condition = gen_rtx_NE (VOIDmode, cmp_result, constm1_rtx);\n+      return mips_builtin_branch_and_move (condition, target,\n+\t\t\t\t\t   const0_rtx, const1_rtx);\n \n-  /* Fix TARGET for CMP_RESULT != CMP_VALUE.  */\n-  emit_move_insn (target, target_if_unequal);\n-  emit_label (label2);\n+    case MIPS_BUILTIN_CMP_UPPER:\n+    case MIPS_BUILTIN_CMP_LOWER:\n+      offset = GEN_INT (builtin_type == MIPS_BUILTIN_CMP_UPPER);\n+      condition = gen_single_cc (cmp_result, offset);\n+      return mips_builtin_branch_and_move (condition, target,\n+\t\t\t\t\t   const1_rtx, const0_rtx);\n \n-  return target;\n+    default:\n+      condition = gen_rtx_NE (VOIDmode, cmp_result, const0_rtx);\n+      return mips_builtin_branch_and_move (condition, target,\n+\t\t\t\t\t   const1_rtx, const0_rtx);\n+    }\n }\n \n /* Expand a bposge builtin of type BUILTIN_TYPE.  TARGET, if nonnull,\n-   suggests a good place to put the boolean result.\n-\n-   The sequence we want is\n-\n-\tli\ttarget, 0\n-\tbposge*\tlabel1\n-\tj\tlabel2\n-   label1:\n-\tli \ttarget, 1\n-   label2:  */\n+   suggests a good place to put the boolean result.  */\n \n static rtx\n mips_expand_builtin_bposge (enum mips_builtin_type builtin_type, rtx target)\n {\n-  rtx label1, label2, if_then_else;\n-  rtx cmp_result;\n+  rtx condition, cmp_result;\n   int cmp_value;\n \n   if (target == 0 || GET_MODE (target) != SImode)\n@@ -10708,29 +10603,9 @@ mips_expand_builtin_bposge (enum mips_builtin_type builtin_type, rtx target)\n   else\n     gcc_assert (0);\n \n-  /* Move 0 to target */\n-  emit_move_insn (target, const0_rtx);\n-\n-  /* Generate two labels */\n-  label1 = gen_label_rtx ();\n-  label2 = gen_label_rtx ();\n-\n-  /* Generate if_then_else */\n-  if_then_else\n-    = gen_rtx_IF_THEN_ELSE (VOIDmode,\n-\t\t\t    gen_rtx_fmt_ee (GE, CCDSPmode,\n-\t\t\t\t\t    cmp_result, GEN_INT (cmp_value)),\n-\t\t\t    gen_rtx_LABEL_REF (VOIDmode, label1), pc_rtx);\n-\n-  emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx, if_then_else));\n-  emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx,\n-                               gen_rtx_LABEL_REF (VOIDmode, label2)));\n-  emit_barrier ();\n-  emit_label (label1);\n-  emit_move_insn (target, const1_rtx);\n-  emit_label (label2);\n-\n-  return target;\n+  condition = gen_rtx_GE (VOIDmode, cmp_result, GEN_INT (cmp_value));\n+  return mips_builtin_branch_and_move (condition, target,\n+\t\t\t\t       const1_rtx, const0_rtx);\n }\n \f\n /* Set SYMBOL_REF_FLAGS for the SYMBOL_REF inside RTL, which belongs to DECL."}, {"sha": "b0ae120d5be264e7345f152d87175517f0d078cf", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c1d5f80e0b710089f7e5f6265bdc345c7b514f/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c1d5f80e0b710089f7e5f6265bdc345c7b514f/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=a8c1d5f80e0b710089f7e5f6265bdc345c7b514f", "patch": "@@ -2272,6 +2272,12 @@ typedef struct mips_args {\n    be updated with the correct length of the insn.  */\n #define ADJUST_INSN_LENGTH(INSN, LENGTH) \\\n   ((LENGTH) = mips_adjust_insn_length ((INSN), (LENGTH)))\n+\n+/* Return the asm template for a non-MIPS16 conditional branch instruction.\n+   OPCODE is the opcode's mnemonic and OPERANDS is the asm template for\n+   its operands.  */\n+#define MIPS_BRANCH(OPCODE, OPERANDS) \\\n+  \"%*\" OPCODE \"%?\\t\" OPERANDS \"%/\"\n \f\n /* Control the assembler format that we output.  */\n "}, {"sha": "01653d621434158e1132246a02c13089bca3b00f", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 41, "deletions": 59, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c1d5f80e0b710089f7e5f6265bdc345c7b514f/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c1d5f80e0b710089f7e5f6265bdc345c7b514f/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=a8c1d5f80e0b710089f7e5f6265bdc345c7b514f", "patch": "@@ -72,6 +72,7 @@\n    (UNSPEC_RSQRT2\t\t209)\n    (UNSPEC_RECIP1\t\t210)\n    (UNSPEC_RECIP2\t\t211)\n+   (UNSPEC_SINGLE_CC\t\t212)\n \n    ;; MIPS DSP ASE Revision 0.98 3/24/2005\n    (UNSPEC_ADDQ\t\t\t300)\n@@ -4272,85 +4273,65 @@\n \n ;; Conditional branches on floating-point equality tests.\n \n-(define_insn \"branch_fp\"\n+(define_insn \"*branch_fp\"\n   [(set (pc)\n         (if_then_else\n-         (match_operator:CC 0 \"comparison_operator\"\n-                            [(match_operand:CC 2 \"register_operand\" \"z\")\n-\t\t\t     (const_int 0)])\n+         (match_operator 0 \"equality_operator\"\n+                         [(match_operand:CC 2 \"register_operand\" \"z\")\n+\t\t\t  (const_int 0)])\n          (label_ref (match_operand 1 \"\" \"\"))\n          (pc)))]\n   \"TARGET_HARD_FLOAT\"\n {\n-  return mips_output_conditional_branch (insn,\n-\t\t\t\t\t operands,\n-\t\t\t\t\t /*two_operands_p=*/0,\n-\t\t\t\t\t /*float_p=*/1,\n-\t\t\t\t\t /*inverted_p=*/0,\n-\t\t\t\t\t get_attr_length (insn));\n+  return mips_output_conditional_branch (insn, operands,\n+\t\t\t\t\t MIPS_BRANCH (\"b%F0\", \"%2,%1\"),\n+\t\t\t\t\t MIPS_BRANCH (\"b%W0\", \"%2,%1\"));\n }\n-  [(set_attr \"type\"\t\"branch\")\n-   (set_attr \"mode\"\t\"none\")])\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"mode\" \"none\")])\n \n-(define_insn \"branch_fp_inverted\"\n+(define_insn \"*branch_fp_inverted\"\n   [(set (pc)\n         (if_then_else\n-         (match_operator:CC 0 \"comparison_operator\"\n-                            [(match_operand:CC 2 \"register_operand\" \"z\")\n-\t\t\t     (const_int 0)])\n+         (match_operator 0 \"equality_operator\"\n+                         [(match_operand:CC 2 \"register_operand\" \"z\")\n+\t\t\t  (const_int 0)])\n          (pc)\n          (label_ref (match_operand 1 \"\" \"\"))))]\n   \"TARGET_HARD_FLOAT\"\n {\n-  return mips_output_conditional_branch (insn,\n-\t\t\t\t\t operands,\n-\t\t\t\t\t /*two_operands_p=*/0,\n-\t\t\t\t\t /*float_p=*/1,\n-\t\t\t\t\t /*inverted_p=*/1,\n-\t\t\t\t\t get_attr_length (insn));\n+  return mips_output_conditional_branch (insn, operands,\n+\t\t\t\t\t MIPS_BRANCH (\"b%W0\", \"%2,%1\"),\n+\t\t\t\t\t MIPS_BRANCH (\"b%F0\", \"%2,%1\"));\n }\n-  [(set_attr \"type\"\t\"branch\")\n-   (set_attr \"mode\"\t\"none\")])\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"mode\" \"none\")])\n \n-;; Conditional branches on comparisons with zero.\n+;; Conditional branches on ordered comparisons with zero.\n \n-(define_insn \"*branch_zero<mode>\"\n+(define_insn \"*branch_order<mode>\"\n   [(set (pc)\n \t(if_then_else\n-\t (match_operator 0 \"comparison_operator\"\n+\t (match_operator 0 \"order_operator\"\n \t\t\t [(match_operand:GPR 2 \"register_operand\" \"d\")\n \t\t\t  (const_int 0)])\n \t (label_ref (match_operand 1 \"\" \"\"))\n \t (pc)))]\n   \"!TARGET_MIPS16\"\n-{\n-  return mips_output_conditional_branch (insn,\n-\t\t\t\t\t operands,\n-\t\t\t\t\t /*two_operands_p=*/0,\n-\t\t\t\t\t /*float_p=*/0,\n-\t\t\t\t\t /*inverted_p=*/0,\n-\t\t\t\t\t get_attr_length (insn));\n-}\n+  { return mips_output_order_conditional_branch (insn, operands, false); }\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"mode\" \"none\")])\n \n-(define_insn \"*branch_zero<mode>_inverted\"\n+(define_insn \"*branch_order<mode>_inverted\"\n   [(set (pc)\n \t(if_then_else\n-\t (match_operator 0 \"comparison_operator\"\n+\t (match_operator 0 \"order_operator\"\n \t\t\t [(match_operand:GPR 2 \"register_operand\" \"d\")\n \t\t\t  (const_int 0)])\n \t (pc)\n \t (label_ref (match_operand 1 \"\" \"\"))))]\n   \"!TARGET_MIPS16\"\n-{\n-  return mips_output_conditional_branch (insn,\n-\t\t\t\t\t operands,\n-\t\t\t\t\t /*two_operands_p=*/0,\n-\t\t\t\t\t /*float_p=*/0,\n-\t\t\t\t\t /*inverted_p=*/1,\n-\t\t\t\t\t get_attr_length (insn));\n-}\n+  { return mips_output_order_conditional_branch (insn, operands, true); }\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"mode\" \"none\")])\n \n@@ -4361,17 +4342,14 @@\n \t(if_then_else\n \t (match_operator 0 \"equality_operator\"\n \t\t\t [(match_operand:GPR 2 \"register_operand\" \"d\")\n-\t\t\t  (match_operand:GPR 3 \"register_operand\" \"d\")])\n+\t\t\t  (match_operand:GPR 3 \"reg_or_0_operand\" \"dJ\")])\n \t (label_ref (match_operand 1 \"\" \"\"))\n \t (pc)))]\n   \"!TARGET_MIPS16\"\n {\n-  return mips_output_conditional_branch (insn,\n-\t\t\t\t\t operands,\n-\t\t\t\t\t /*two_operands_p=*/1,\n-\t\t\t\t\t /*float_p=*/0,\n-\t\t\t\t\t /*inverted_p=*/0,\n-\t\t\t\t\t get_attr_length (insn));\n+  return mips_output_conditional_branch (insn, operands,\n+\t\t\t\t\t MIPS_BRANCH (\"b%C0\", \"%2,%z3,%1\"),\n+\t\t\t\t\t MIPS_BRANCH (\"b%N0\", \"%2,%z3,%1\"));\n }\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"mode\" \"none\")])\n@@ -4381,17 +4359,14 @@\n \t(if_then_else\n \t (match_operator 0 \"equality_operator\"\n \t\t\t [(match_operand:GPR 2 \"register_operand\" \"d\")\n-\t\t\t  (match_operand:GPR 3 \"register_operand\" \"d\")])\n+\t\t\t  (match_operand:GPR 3 \"reg_or_0_operand\" \"dJ\")])\n \t (pc)\n \t (label_ref (match_operand 1 \"\" \"\"))))]\n   \"!TARGET_MIPS16\"\n {\n-  return mips_output_conditional_branch (insn,\n-\t\t\t\t\t operands,\n-\t\t\t\t\t /*two_operands_p=*/1,\n-\t\t\t\t\t /*float_p=*/0,\n-\t\t\t\t\t /*inverted_p=*/1,\n-\t\t\t\t\t get_attr_length (insn));\n+  return mips_output_conditional_branch (insn, operands,\n+\t\t\t\t\t MIPS_BRANCH (\"b%N0\", \"%2,%z3,%1\"),\n+\t\t\t\t\t MIPS_BRANCH (\"b%C0\", \"%2,%z3,%1\"));\n }\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"mode\" \"none\")])\n@@ -4438,6 +4413,13 @@\n   gen_conditional_branch (operands, <CODE>);\n   DONE;\n })\n+\n+;; Used to implement built-in functions.\n+(define_expand \"condjump\"\n+  [(set (pc)\n+\t(if_then_else (match_operand 0)\n+\t\t      (label_ref (match_operand 1))\n+\t\t      (pc)))])\n \f\n ;;\n ;;  ...................."}, {"sha": "d93621d7d7200dd38620f2d5de36d6c0fd2272d2", "filename": "gcc/config/mips/predicates.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c1d5f80e0b710089f7e5f6265bdc345c7b514f/gcc%2Fconfig%2Fmips%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c1d5f80e0b710089f7e5f6265bdc345c7b514f/gcc%2Fconfig%2Fmips%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fpredicates.md?ref=a8c1d5f80e0b710089f7e5f6265bdc345c7b514f", "patch": "@@ -212,6 +212,9 @@\n (define_predicate \"trap_comparison_operator\"\n   (match_code \"eq,ne,lt,ltu,ge,geu\"))\n \n+(define_predicate \"order_operator\"\n+  (match_code \"lt,ltu,le,leu,ge,geu,gt,gtu\"))\n+\n \n (define_predicate \"small_data_pattern\"\n   (and (match_code \"set,parallel,unspec,unspec_volatile,prefetch\")"}]}