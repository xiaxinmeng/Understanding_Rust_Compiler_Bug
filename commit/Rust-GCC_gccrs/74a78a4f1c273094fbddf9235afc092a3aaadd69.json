{"sha": "74a78a4f1c273094fbddf9235afc092a3aaadd69", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzRhNzhhNGYxYzI3MzA5NGZiZGRmOTIzNWFmYzA5MmEzYWFhZGQ2OQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-08T08:59:32Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-08T08:59:32Z"}, "message": "[multiple changes]\n\n2017-09-08  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_spark.adb (Expand_SPARK_N_Object_Renaming_Declaration):\n\tReimplemented.\n\t(Expand_SPARK_Potential_Renaming): Code clean up.\n\t* sem_prag.adb (Analyze_Initialization_Item): Add a guard in case\n\tthe item does not have a proper entity.\n\t(Analyze_Input_Item): Add a guard in case the item does not have a\n\tproper entity.\n\t(Collect_States_And_Objects): Include object renamings in the\n\titems being collected.\n\t(Resolve_State): Update the documentation of this routine.\n\t* sem_util.adb (Entity_Of): Add circuitry to handle\n\trenamings of function results.\n\t(Remove_Entity): New routine.\n\t(Remove_Overloaded_Entity): Take advantage of factorization.\n\t* sem_util.ads (Entity_Of): Update the documentation\n\tof this routine.\n\t(Remove_Entity): New routine.\n\t(Remove_Overloaded_Entity): Update the documentation of this\n\troutine.\n\n2017-09-08  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* repinfo.adb (List_Record_Info): During first loop,\n\tdo not override the normalized position and first bit\n\tif they have already been set.\tMove fallback code\n\tfor the packed case to the case where it belongs.\n\t* sem_ch13.adb (Adjust_Record_For_Reverse_Bit_Order):\n\tAlso adjust the normalized position of components.\n\t(Adjust_Record_For_Reverse_Bit_Order_Ada_95): Likewise.\n\n2017-09-08  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_disp.adb (Make_DT, Set_All_DT_Position): Handle properly\n\tthe placement of a primitive operation O that renames an operation\n\tR declared in an inner package, and which is thus not a primitive\n\tof the dispatching type of O. In this case O is a new primitive\n\tand does not inherit its dispatch table position from R (which\n\thas none).\n\n2017-09-08  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_dim.adb (Analyze_Dimension_If_Expression,\n\tAnalyze_Dimension_Case_Expression): new subprograms to verify\n\tthe dimensional correctness of Ada2012 conditional expressions,\n\tand set properly the dimensions of the construct.\n\t* sem_res.adb (Resolve_If_Expression, Resolve_Case_Expression)):\n\tcall Analyze_Dimension.\n\n2017-09-08  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_type.adb (Expand_Interface_Conversion): Prevent an infinite\n\tloop on an interface declared as a private extension of another\n\tsynchronized interface.\n\nFrom-SVN: r251868", "tree": {"sha": "12c45476b5dca94550dbf46eb9c38a546d8e00e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/12c45476b5dca94550dbf46eb9c38a546d8e00e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/74a78a4f1c273094fbddf9235afc092a3aaadd69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74a78a4f1c273094fbddf9235afc092a3aaadd69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74a78a4f1c273094fbddf9235afc092a3aaadd69", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74a78a4f1c273094fbddf9235afc092a3aaadd69/comments", "author": null, "committer": null, "parents": [{"sha": "133de112314c89d6467742ea3bcf3a4cf623532e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/133de112314c89d6467742ea3bcf3a4cf623532e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/133de112314c89d6467742ea3bcf3a4cf623532e"}], "stats": {"total": 453, "additions": 341, "deletions": 112}, "files": [{"sha": "1014e0e87da5d0d0e0364e796a748b51ce454dfb", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74a78a4f1c273094fbddf9235afc092a3aaadd69/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74a78a4f1c273094fbddf9235afc092a3aaadd69/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=74a78a4f1c273094fbddf9235afc092a3aaadd69", "patch": "@@ -1,3 +1,59 @@\n+2017-09-08  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_spark.adb (Expand_SPARK_N_Object_Renaming_Declaration):\n+\tReimplemented.\n+\t(Expand_SPARK_Potential_Renaming): Code clean up.\n+\t* sem_prag.adb (Analyze_Initialization_Item): Add a guard in case\n+\tthe item does not have a proper entity.\n+\t(Analyze_Input_Item): Add a guard in case the item does not have a\n+\tproper entity.\n+\t(Collect_States_And_Objects): Include object renamings in the\n+\titems being collected.\n+\t(Resolve_State): Update the documentation of this routine.\n+\t* sem_util.adb (Entity_Of): Add circuitry to handle\n+\trenamings of function results.\n+\t(Remove_Entity): New routine.\n+\t(Remove_Overloaded_Entity): Take advantage of factorization.\n+\t* sem_util.ads (Entity_Of): Update the documentation\n+\tof this routine.\n+\t(Remove_Entity): New routine.\n+\t(Remove_Overloaded_Entity): Update the documentation of this\n+\troutine.\n+\n+2017-09-08  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* repinfo.adb (List_Record_Info): During first loop,\n+\tdo not override the normalized position and first bit\n+\tif they have already been set.\tMove fallback code\n+\tfor the packed case to the case where it belongs.\n+\t* sem_ch13.adb (Adjust_Record_For_Reverse_Bit_Order):\n+\tAlso adjust the normalized position of components.\n+\t(Adjust_Record_For_Reverse_Bit_Order_Ada_95): Likewise.\n+\n+2017-09-08  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_disp.adb (Make_DT, Set_All_DT_Position): Handle properly\n+\tthe placement of a primitive operation O that renames an operation\n+\tR declared in an inner package, and which is thus not a primitive\n+\tof the dispatching type of O. In this case O is a new primitive\n+\tand does not inherit its dispatch table position from R (which\n+\thas none).\n+\n+2017-09-08  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_dim.adb (Analyze_Dimension_If_Expression,\n+\tAnalyze_Dimension_Case_Expression): new subprograms to verify\n+\tthe dimensional correctness of Ada2012 conditional expressions,\n+\tand set properly the dimensions of the construct.\n+\t* sem_res.adb (Resolve_If_Expression, Resolve_Case_Expression)):\n+\tcall Analyze_Dimension.\n+\n+2017-09-08  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_type.adb (Expand_Interface_Conversion): Prevent an infinite\n+\tloop on an interface declared as a private extension of another\n+\tsynchronized interface.\n+\n 2017-09-08  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch12.adb (Check_Generic_Parent): New procedure within"}, {"sha": "e5e2c61538730dbeafbce16989543debfe69201d", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 34, "deletions": 12, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74a78a4f1c273094fbddf9235afc092a3aaadd69/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74a78a4f1c273094fbddf9235afc092a3aaadd69/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=74a78a4f1c273094fbddf9235afc092a3aaadd69", "patch": "@@ -5896,6 +5896,16 @@ package body Exp_Disp is\n                   --  handling of renamings and eliminated primitives.\n \n                   E        := Ultimate_Alias (Prim);\n+\n+                  --  If the alias is not a primitive operation then Prim does\n+                  --  not rename another primitive, but rather an operation\n+                  --  declared elsewhere (e.g. in another scope) and therefore\n+                  --  Prim is a new primitive.\n+\n+                  if No (Find_Dispatching_Type (E)) then\n+                     E := Prim;\n+                  end if;\n+\n                   Prim_Pos := UI_To_Int (DT_Position (E));\n \n                   --  Skip predefined primitives because they are located in a\n@@ -7781,24 +7791,36 @@ package body Exp_Disp is\n                Set_DT_Position_Value (Alias (Prim), DT_Position (E));\n                Set_Fixed_Prim (UI_To_Int (DT_Position (Prim)));\n \n-            --  Overriding primitives must use the same entry as the\n-            --  overridden primitive.\n+            --  Overriding primitives must use the same entry as the overridden\n+            --  primitive. Note that the Alias of the operation is set when the\n+            --  operation is declared by a renaming, in which case it is not\n+            --  overriding. If it renames another primitive it will use the\n+            --  same dispatch table slot, but if it renames an operation in a\n+            --  nested package it's a new primitive and will have its own slot.\n \n             elsif not Present (Interface_Alias (Prim))\n               and then Present (Alias (Prim))\n               and then Chars (Prim) = Chars (Alias (Prim))\n-              and then Find_Dispatching_Type (Alias (Prim)) /= Typ\n-              and then Is_Ancestor\n-                         (Find_Dispatching_Type (Alias (Prim)), Typ,\n-                          Use_Full_View => True)\n-              and then Present (DTC_Entity (Alias (Prim)))\n+              and then Nkind (Unit_Declaration_Node (Prim)) /=\n+                         N_Subprogram_Renaming_Declaration\n             then\n-               E := Alias (Prim);\n-               Set_DT_Position_Value (Prim, DT_Position (E));\n+               declare\n+                  Par_Type : constant Entity_Id :=\n+                    Find_Dispatching_Type (Alias (Prim));\n+               begin\n+                  if Present (Par_Type)\n+                    and then Par_Type /= Typ\n+                    and then Is_Ancestor (Par_Type, Typ, Use_Full_View => True)\n+                    and then Present (DTC_Entity (Alias (Prim)))\n+                  then\n+                     E := Alias (Prim);\n+                     Set_DT_Position_Value (Prim, DT_Position (E));\n \n-               if not Is_Predefined_Dispatching_Alias (E) then\n-                  Set_Fixed_Prim (UI_To_Int (DT_Position (E)));\n-               end if;\n+                     if not Is_Predefined_Dispatching_Alias (E) then\n+                        Set_Fixed_Prim (UI_To_Int (DT_Position (E)));\n+                     end if;\n+                  end if;\n+               end;\n             end if;\n \n             Next_Elmt (Prim_Elmt);"}, {"sha": "211fea360cd19989d684c7e69de1c27e106f0739", "filename": "gcc/ada/exp_spark.adb", "status": "modified", "additions": 59, "deletions": 13, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74a78a4f1c273094fbddf9235afc092a3aaadd69/gcc%2Fada%2Fexp_spark.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74a78a4f1c273094fbddf9235afc092a3aaadd69/gcc%2Fada%2Fexp_spark.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_spark.adb?ref=74a78a4f1c273094fbddf9235afc092a3aaadd69", "patch": "@@ -292,10 +292,55 @@ package body Exp_SPARK is\n    ------------------------------------------------\n \n    procedure Expand_SPARK_N_Object_Renaming_Declaration (N : Node_Id) is\n+      CFS    : constant Boolean    := Comes_From_Source (N);\n+      Loc    : constant Source_Ptr := Sloc (N);\n+      Obj_Id : constant Entity_Id  := Defining_Entity (N);\n+      Nam    : constant Node_Id    := Name (N);\n+      Typ    : constant Entity_Id  := Etype (Subtype_Mark (N));\n+\n    begin\n-      --  Unconditionally remove all side effects from the name\n+      --  Transform a renaming of the form\n+\n+      --    Obj_Id : <subtype mark> renames <function call>;\n+\n+      --  into\n+\n+      --    Obj_Id : constant <subtype mark> := <function call>;\n+\n+      --  Invoking Evaluate_Name and ultimately Remove_Side_Effects introduces\n+      --  a temporary to capture the function result. Once potential renamings\n+      --  are rewritten for SPARK, the temporary may be leaked out into source\n+      --  constructs and lead to confusing error diagnostics. Using an object\n+      --  declaration prevents this unwanted side effect.\n+\n+      if Nkind (Nam) = N_Function_Call then\n+         Rewrite (N,\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Obj_Id,\n+             Constant_Present    => True,\n+             Object_Definition   => New_Occurrence_Of (Typ, Loc),\n+             Expression          => Nam));\n+\n+         --  Inherit the original Comes_From_Source status of the renaming\n \n-      Evaluate_Name (Name (N));\n+         Set_Comes_From_Source (N, CFS);\n+\n+         --  Sever the link to the renamed function result because the entity\n+         --  will no longer alias anything.\n+\n+         Set_Renamed_Object (Obj_Id, Empty);\n+\n+         --  Remove the entity of the renaming declaration from visibility as\n+         --  the analysis of the object declaration will reintroduce it again.\n+\n+         Remove_Entity (Obj_Id);\n+         Analyze (N);\n+\n+      --  Otherwise unconditionally remove all side effects from the name\n+\n+      else\n+         Evaluate_Name (Nam);\n+      end if;\n    end Expand_SPARK_N_Object_Renaming_Declaration;\n \n    ------------------------\n@@ -324,29 +369,30 @@ package body Exp_SPARK is\n \n    procedure Expand_SPARK_Potential_Renaming (N : Node_Id) is\n       Loc    : constant Source_Ptr := Sloc (N);\n-      Ren_Id : constant Entity_Id  := Entity (N);\n+      Obj_Id : constant Entity_Id  := Entity (N);\n       Typ    : constant Entity_Id  := Etype (N);\n-      Obj_Id : Node_Id;\n+      Ren    : Node_Id;\n \n    begin\n       --  Replace a reference to a renaming with the actual renamed object\n \n-      if Ekind (Ren_Id) in Object_Kind then\n-         Obj_Id := Renamed_Object (Ren_Id);\n+      if Ekind (Obj_Id) in Object_Kind then\n+         Ren := Renamed_Object (Obj_Id);\n \n-         if Present (Obj_Id) then\n+         if Present (Ren) then\n \n-            --  The renamed object is an entity when instantiating generics\n-            --  or inlining bodies. In this case the renaming is part of the\n-            --  mapping \"prologue\" which links actuals to formals.\n+            --  Instantiations and inlining of subprograms employ \"prologues\"\n+            --  which map actual to formal parameters by means of renamings.\n+            --  Replace a reference to a formal by the corresponding actual\n+            --  parameter.\n \n-            if Nkind (Obj_Id) in N_Entity then\n-               Rewrite (N, New_Occurrence_Of (Obj_Id, Loc));\n+            if Nkind (Ren) in N_Entity then\n+               Rewrite (N, New_Occurrence_Of (Ren, Loc));\n \n             --  Otherwise the renamed object denotes a name\n \n             else\n-               Rewrite (N, New_Copy_Tree (Obj_Id, New_Sloc => Loc));\n+               Rewrite (N, New_Copy_Tree (Ren, New_Sloc => Loc));\n                Reset_Analyzed_Flags (N);\n             end if;\n "}, {"sha": "2634ee8b7c6caae2784eb49d75660ed8077f2614", "filename": "gcc/ada/repinfo.adb", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74a78a4f1c273094fbddf9235afc092a3aaadd69/gcc%2Fada%2Frepinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74a78a4f1c273094fbddf9235afc092a3aaadd69/gcc%2Fada%2Frepinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frepinfo.adb?ref=74a78a4f1c273094fbddf9235afc092a3aaadd69", "patch": "@@ -894,30 +894,30 @@ package body Repinfo is\n             Cfbit := Component_Bit_Offset (Comp);\n \n             if Rep_Not_Constant (Cfbit) then\n-               UI_Image_Length := 2;\n+               --  If the record is not packed, then we know that all fields\n+               --  whose position is not specified have a starting normalized\n+               --  bit position of zero.\n \n+               if Unknown_Normalized_First_Bit (Comp)\n+                 and then not Is_Packed (Ent)\n+               then\n+                  Set_Normalized_First_Bit (Comp, Uint_0);\n+               end if;\n+\n+               UI_Image_Length := 2; -- For \"??\" marker\n             else\n                --  Complete annotation in case not done\n \n-               Set_Normalized_Position (Comp, Cfbit / SSU);\n-               Set_Normalized_First_Bit (Comp, Cfbit mod SSU);\n+               if Unknown_Normalized_First_Bit (Comp) then\n+                  Set_Normalized_Position (Comp, Cfbit / SSU);\n+                  Set_Normalized_First_Bit (Comp, Cfbit mod SSU);\n+               end if;\n \n                Sunit := Cfbit / SSU;\n                UI_Image (Sunit);\n             end if;\n \n-            --  If the record is not packed, then we know that all fields\n-            --  whose position is not specified have a starting normalized\n-            --  bit position of zero.\n-\n-            if Unknown_Normalized_First_Bit (Comp)\n-              and then not Is_Packed (Ent)\n-            then\n-               Set_Normalized_First_Bit (Comp, Uint_0);\n-            end if;\n-\n-            Max_Suni_Length :=\n-              Natural'Max (Max_Suni_Length, UI_Image_Length);\n+            Max_Suni_Length := Natural'Max (Max_Suni_Length, UI_Image_Length);\n          end if;\n \n          Next_Component_Or_Discriminant (Comp);"}, {"sha": "9b97f8f59ac3e1dc04256ef8c6cb4cf148fc2a4c", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74a78a4f1c273094fbddf9235afc092a3aaadd69/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74a78a4f1c273094fbddf9235afc092a3aaadd69/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=74a78a4f1c273094fbddf9235afc092a3aaadd69", "patch": "@@ -627,6 +627,7 @@ package body Sem_Ch13 is\n                   end if;\n \n                   Set_Component_Bit_Offset (Comp, Pos * SSU + NFB);\n+                  Set_Normalized_Position  (Comp, Pos + NFB / SSU);\n                   Set_Normalized_First_Bit (Comp, NFB mod SSU);\n                end;\n             end loop;\n@@ -750,6 +751,9 @@ package body Sem_Ch13 is\n                       (System_Storage_Unit - 1) -\n                       (Start_Bit + CSZ - 1));\n \n+                  Set_Normalized_Position (Comp,\n+                    Component_Bit_Offset (Comp) / System_Storage_Unit);\n+\n                   Set_Normalized_First_Bit (Comp,\n                     Component_Bit_Offset (Comp) mod System_Storage_Unit);\n                end if;"}, {"sha": "6e829f916919329775e29cb664e02b44acfad975", "filename": "gcc/ada/sem_dim.adb", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74a78a4f1c273094fbddf9235afc092a3aaadd69/gcc%2Fada%2Fsem_dim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74a78a4f1c273094fbddf9235afc092a3aaadd69/gcc%2Fada%2Fsem_dim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_dim.adb?ref=74a78a4f1c273094fbddf9235afc092a3aaadd69", "patch": "@@ -194,6 +194,8 @@ package body Sem_Dim is\n \n    OK_For_Dimension : constant array (Node_Kind) of Boolean :=\n      (N_Attribute_Reference       => True,\n+      N_Case_Expression           => True,\n+      N_If_Expression             => True,\n       N_Expanded_Name             => True,\n       N_Explicit_Dereference      => True,\n       N_Defining_Identifier       => True,\n@@ -254,6 +256,12 @@ package body Sem_Dim is\n    --    N_Type_Conversion\n    --    N_Unchecked_Type_Conversion\n \n+   procedure Analyze_Dimension_Case_Expression (N : Node_Id);\n+   --  Verify that all alternatives have the same dimension\n+\n+   procedure Analyze_Dimension_If_Expression (N : Node_Id);\n+   --  Verify that all alternatives have the same dimension\n+\n    procedure Analyze_Dimension_Number_Declaration (N : Node_Id);\n    --  Procedure to analyze dimension of expression in a number declaration.\n    --  This allows a named number to have nontrivial dimensions, while by\n@@ -1179,6 +1187,12 @@ package body Sem_Dim is\n          =>\n             Analyze_Dimension_Has_Etype (N);\n \n+         when N_Case_Expression =>\n+            Analyze_Dimension_Case_Expression (N);\n+\n+         when N_If_Expression =>\n+            Analyze_Dimension_If_Expression (N);\n+\n          --  In the presence of a repaired syntax error, an identifier\n          --  may be introduced without a usable type.\n \n@@ -1768,6 +1782,27 @@ package body Sem_Dim is\n       end if;\n    end Analyze_Dimension_Call;\n \n+   ---------------------------------------\n+   -- Analyze_Dimension_Case_Expression --\n+   ---------------------------------------\n+\n+   procedure Analyze_Dimension_Case_Expression (N : Node_Id) is\n+      Alt : Node_Id;\n+      Frst : constant Node_Id := First (Alternatives (N));\n+      Dims : constant Dimension_Type := Dimensions_Of (Expression (Frst));\n+   begin\n+      Alt := Next (Frst);\n+      while Present (Alt) loop\n+         if Dimensions_Of (Expression (Alt)) /= Dims then\n+            Error_Msg_N (\"dimension mismatch in case expression\", Alt);\n+            exit;\n+         end if;\n+\n+         Next (Alt);\n+      end loop;\n+      Copy_Dimensions (Expression (Frst), N);\n+   end Analyze_Dimension_Case_Expression;\n+\n    ---------------------------------------------\n    -- Analyze_Dimension_Component_Declaration --\n    ---------------------------------------------\n@@ -2102,6 +2137,21 @@ package body Sem_Dim is\n       end case;\n    end Analyze_Dimension_Has_Etype;\n \n+   -------------------------------------\n+   -- Analyze_Dimension_If_Expression --\n+   -------------------------------------\n+\n+   procedure Analyze_Dimension_If_Expression (N : Node_Id) is\n+      Then_Expr : constant Node_Id := Next (First (Expressions (N)));\n+      Else_Expr : constant Node_Id := Next (Then_Expr);\n+   begin\n+      if Dimensions_Of (Then_Expr) /= Dimensions_Of (Else_Expr) then\n+         Error_Msg_N (\"dimensions mismatch in conditional expression\", N);\n+      else\n+         Copy_Dimensions (Then_Expr, N);\n+      end if;\n+   end Analyze_Dimension_If_Expression;\n+\n    ------------------------------------------\n    -- Analyze_Dimension_Number_Declaration --\n    ------------------------------------------"}, {"sha": "dc0f8308482d671b2257afac3118694729966296", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74a78a4f1c273094fbddf9235afc092a3aaadd69/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74a78a4f1c273094fbddf9235afc092a3aaadd69/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=74a78a4f1c273094fbddf9235afc092a3aaadd69", "patch": "@@ -283,9 +283,9 @@ package body Sem_Prag is\n    --  reference for future checks (see Analyze_Refined_State_In_Decls).\n \n    procedure Resolve_State (N : Node_Id);\n-   --  Handle the overloading of state names by parameterless functions. When N\n-   --  denotes a function, this routine finds the corresponding state and sets\n-   --  the entity of N to that of the state.\n+   --  Handle the overloading of state names by functions. When N denotes a\n+   --  function, this routine finds the corresponding state and sets the entity\n+   --  of N to that of the state.\n \n    procedure Rewrite_Assertion_Kind\n      (N           : Node_Id;\n@@ -2811,9 +2811,10 @@ package body Sem_Prag is\n             if Is_Entity_Name (Item) then\n                Item_Id := Entity_Of (Item);\n \n-               if Ekind_In (Item_Id, E_Abstract_State,\n-                                     E_Constant,\n-                                     E_Variable)\n+               if Present (Item_Id)\n+                 and then Ekind_In (Item_Id, E_Abstract_State,\n+                                             E_Constant,\n+                                             E_Variable)\n                then\n                   --  The state or variable must be declared in the visible\n                   --  declarations of the package (SPARK RM 7.1.5(7)).\n@@ -2918,14 +2919,15 @@ package body Sem_Prag is\n                if Is_Entity_Name (Input) then\n                   Input_Id := Entity_Of (Input);\n \n-                  if Ekind_In (Input_Id, E_Abstract_State,\n-                                         E_Constant,\n-                                         E_Generic_In_Out_Parameter,\n-                                         E_Generic_In_Parameter,\n-                                         E_In_Parameter,\n-                                         E_In_Out_Parameter,\n-                                         E_Out_Parameter,\n-                                         E_Variable)\n+                  if Present (Input_Id)\n+                    and then Ekind_In (Input_Id, E_Abstract_State,\n+                                                 E_Constant,\n+                                                 E_Generic_In_Out_Parameter,\n+                                                 E_Generic_In_Parameter,\n+                                                 E_In_Parameter,\n+                                                 E_In_Out_Parameter,\n+                                                 E_Out_Parameter,\n+                                                 E_Variable)\n                   then\n                      --  The input cannot denote states or objects declared\n                      --  within the related package (SPARK RM 7.1.5(4)).\n@@ -3073,7 +3075,8 @@ package body Sem_Prag is\n             Decl := First (Visible_Declarations (Pack_Spec));\n             while Present (Decl) loop\n                if Comes_From_Source (Decl)\n-                 and then Nkind (Decl) = N_Object_Declaration\n+                 and then Nkind_In (Decl, N_Object_Declaration,\n+                                          N_Object_Renaming_Declaration)\n                then\n                   Append_New_Elmt (Defining_Entity (Decl), States_And_Objs);\n "}, {"sha": "ed96c533f6c0f5e66dec271b30b67fa6a987fb53", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74a78a4f1c273094fbddf9235afc092a3aaadd69/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74a78a4f1c273094fbddf9235afc092a3aaadd69/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=74a78a4f1c273094fbddf9235afc092a3aaadd69", "patch": "@@ -6772,6 +6772,7 @@ package body Sem_Res is\n \n       Set_Etype (N, Typ);\n       Eval_Case_Expression (N);\n+      Analyze_Dimension (N);\n    end Resolve_Case_Expression;\n \n    -------------------------------\n@@ -8357,6 +8358,8 @@ package body Sem_Res is\n       if not Error_Posted (N) then\n          Eval_If_Expression (N);\n       end if;\n+\n+      Analyze_Dimension (N);\n    end Resolve_If_Expression;\n \n    -------------------------------"}, {"sha": "c9d8f4b324b3132b44a374785489b81836fdd4d6", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74a78a4f1c273094fbddf9235afc092a3aaadd69/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74a78a4f1c273094fbddf9235afc092a3aaadd69/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=74a78a4f1c273094fbddf9235afc092a3aaadd69", "patch": "@@ -2947,11 +2947,14 @@ package body Sem_Type is\n             --  Continue climbing\n \n             else\n-               --  Use the full-view of private types (if allowed)\n+               --  Use the full-view of private types (if allowed).\n+               --  Guard against infinite loops when full view has same\n+               --  type as parent, as can happen with interface extensions,\n \n                if Use_Full_View\n                  and then Is_Private_Type (Par)\n                  and then Present (Full_View (Par))\n+                 and then Par /= Etype (Full_View (Par))\n                then\n                   Par := Etype (Full_View (Par));\n                else"}, {"sha": "968de988e9c177edab6c27f1ee99200cb441345e", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 86, "deletions": 51, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74a78a4f1c273094fbddf9235afc092a3aaadd69/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74a78a4f1c273094fbddf9235afc092a3aaadd69/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=74a78a4f1c273094fbddf9235afc092a3aaadd69", "patch": "@@ -7117,23 +7117,46 @@ package body Sem_Util is\n    ---------------\n \n    function Entity_Of (N : Node_Id) return Entity_Id is\n-      Id : Entity_Id;\n+      Id  : Entity_Id;\n+      Ren : Node_Id;\n \n    begin\n+      --  Assume that the arbitrary node does not have an entity\n+\n       Id := Empty;\n \n       if Is_Entity_Name (N) then\n          Id := Entity (N);\n \n-         --  Follow a possible chain of renamings to reach the root renamed\n-         --  object.\n+         --  Follow a possible chain of renamings to reach the earliest renamed\n+         --  source object.\n \n          while Present (Id)\n            and then Is_Object (Id)\n            and then Present (Renamed_Object (Id))\n          loop\n-            if Is_Entity_Name (Renamed_Object (Id)) then\n-               Id := Entity (Renamed_Object (Id));\n+            Ren := Renamed_Object (Id);\n+\n+            --  The reference renames an abstract state or a whole object\n+\n+            --    Obj : ...;\n+            --    Ren : ... renames Obj;\n+\n+            if Is_Entity_Name (Ren) then\n+               Id := Entity (Ren);\n+\n+            --  The reference renames a function result. Check the original\n+            --  node in case expansion relocates the function call.\n+\n+            --    Ren : ... renames Func_Call;\n+\n+            elsif Nkind (Original_Node (Ren)) = N_Function_Call then\n+               exit;\n+\n+            --  Otherwise the reference renames something which does not yield\n+            --  an abstract state or a whole object. Treat the reference as not\n+            --  having a proper entity for SPARK legality purposes.\n+\n             else\n                Id := Empty;\n                exit;\n@@ -20369,6 +20392,61 @@ package body Sem_Util is\n       end if;\n    end References_Generic_Formal_Type;\n \n+   -------------------\n+   -- Remove_Entity --\n+   -------------------\n+\n+   procedure Remove_Entity (Id : Entity_Id) is\n+      Scop    : constant Entity_Id := Scope (Id);\n+      Prev_Id : Entity_Id;\n+\n+   begin\n+      --  Remove the entity from the homonym chain. When the entity is the\n+      --  head of the chain, associate the entry in the name table with its\n+      --  homonym effectively making it the new head of the chain.\n+\n+      if Current_Entity (Id) = Id then\n+         Set_Name_Entity_Id (Chars (Id), Homonym (Id));\n+\n+      --  Otherwise link the previous and next homonyms\n+\n+      else\n+         Prev_Id := Current_Entity (Id);\n+         while Present (Prev_Id) and then Homonym (Prev_Id) /= Id loop\n+            Prev_Id := Homonym (Prev_Id);\n+         end loop;\n+\n+         Set_Homonym (Prev_Id, Homonym (Id));\n+      end if;\n+\n+      --  Remove the entity from the scope entity chain. When the entity is\n+      --  the head of the chain, set the next entity as the new head of the\n+      --  chain.\n+\n+      if First_Entity (Scop) = Id then\n+         Prev_Id := Empty;\n+         Set_First_Entity (Scop, Next_Entity (Id));\n+\n+      --  Otherwise the entity is either in the middle of the chain or it acts\n+      --  as its tail. Traverse and link the previous and next entities.\n+\n+      else\n+         Prev_Id := First_Entity (Scop);\n+         while Present (Prev_Id) and then Next_Entity (Prev_Id) /= Id loop\n+            Next_Entity (Prev_Id);\n+         end loop;\n+\n+         Set_Next_Entity (Prev_Id, Next_Entity (Id));\n+      end if;\n+\n+      --  Handle the case where the entity acts as the tail of the scope entity\n+      --  chain.\n+\n+      if Last_Entity (Scop) = Id then\n+         Set_Last_Entity (Scop, Prev_Id);\n+      end if;\n+   end Remove_Entity;\n+\n    --------------------\n    -- Remove_Homonym --\n    --------------------\n@@ -20428,57 +20506,14 @@ package body Sem_Util is\n \n       --  Local variables\n \n-      Scop    : constant Entity_Id := Scope (Id);\n-      Formal  : Entity_Id;\n-      Prev_Id : Entity_Id;\n+      Formal : Entity_Id;\n \n    --  Start of processing for Remove_Overloaded_Entity\n \n    begin\n-      --  Remove the entity from the homonym chain. When the entity is the\n-      --  head of the chain, associate the entry in the name table with its\n-      --  homonym effectively making it the new head of the chain.\n-\n-      if Current_Entity (Id) = Id then\n-         Set_Name_Entity_Id (Chars (Id), Homonym (Id));\n-\n-      --  Otherwise link the previous and next homonyms\n-\n-      else\n-         Prev_Id := Current_Entity (Id);\n-         while Present (Prev_Id) and then Homonym (Prev_Id) /= Id loop\n-            Prev_Id := Homonym (Prev_Id);\n-         end loop;\n-\n-         Set_Homonym (Prev_Id, Homonym (Id));\n-      end if;\n-\n-      --  Remove the entity from the scope entity chain. When the entity is\n-      --  the head of the chain, set the next entity as the new head of the\n-      --  chain.\n-\n-      if First_Entity (Scop) = Id then\n-         Prev_Id := Empty;\n-         Set_First_Entity (Scop, Next_Entity (Id));\n+      --  Remove the entity from both the homonym and scope chains\n \n-      --  Otherwise the entity is either in the middle of the chain or it acts\n-      --  as its tail. Traverse and link the previous and next entities.\n-\n-      else\n-         Prev_Id := First_Entity (Scop);\n-         while Present (Prev_Id) and then Next_Entity (Prev_Id) /= Id loop\n-            Next_Entity (Prev_Id);\n-         end loop;\n-\n-         Set_Next_Entity (Prev_Id, Next_Entity (Id));\n-      end if;\n-\n-      --  Handle the case where the entity acts as the tail of the scope entity\n-      --  chain.\n-\n-      if Last_Entity (Scop) = Id then\n-         Set_Last_Entity (Scop, Prev_Id);\n-      end if;\n+      Remove_Entity (Id);\n \n       --  The entity denotes a primitive subprogram. Remove it from the list of\n       --  primitives of the associated controlling type."}, {"sha": "58a362b1584e8c6eef90c91fdca3c1bdee3dbe97", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74a78a4f1c273094fbddf9235afc092a3aaadd69/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74a78a4f1c273094fbddf9235afc092a3aaadd69/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=74a78a4f1c273094fbddf9235afc092a3aaadd69", "patch": "@@ -689,8 +689,9 @@ package Sem_Util is\n    --  are entered using Sem_Ch6.Enter_Overloadable_Entity.\n \n    function Entity_Of (N : Node_Id) return Entity_Id;\n-   --  Return the entity of N or Empty. If N is a renaming, return the entity\n-   --  of the root renamed object.\n+   --  Obtain the entity of arbitrary node N. If N is a renaming, return the\n+   --  entity of the earliest renamed source abstract state or whole object.\n+   --  If no suitable entity is available, return Empty.\n \n    procedure Explain_Limited_Type (T : Entity_Id; N : Node_Id);\n    --  This procedure is called after issuing a message complaining about an\n@@ -2265,14 +2266,20 @@ package Sem_Util is\n    --  Returns True if the expression Expr contains any references to a generic\n    --  type. This can only happen within a generic template.\n \n+   procedure Remove_Entity (Id : Entity_Id);\n+   --  Remove arbitrary entity Id from both the homonym and scope chains. Use\n+   --  Remove_Overloaded_Entity for overloadable entities. Note: the removal\n+   --  performed by this routine does not affect the visibility of existing\n+   --  homonyms.\n+\n    procedure Remove_Homonym (E : Entity_Id);\n    --  Removes E from the homonym chain\n \n    procedure Remove_Overloaded_Entity (Id : Entity_Id);\n    --  Remove arbitrary entity Id from the homonym chain, the scope chain and\n-   --  the primitive operations list of the associated controlling type. NOTE:\n-   --  the removal performed by this routine does not affect the visibility of\n-   --  existing homonyms.\n+   --  the primitive operations list of the associated controlling type. Use\n+   --  Remove_Entity for non-overloadable entities. Note: the removal performed\n+   --  by this routine does not affect the visibility of existing homonyms.\n \n    function Remove_Suffix (E : Entity_Id; Suffix : Character) return Name_Id;\n    --  Returns the name of E without Suffix"}]}