{"sha": "b3f89a4510031af1913f70aad9b3ba559d326fb0", "node_id": "C_kwDOANBUbNoAKGIzZjg5YTQ1MTAwMzFhZjE5MTNmNzBhYWQ5YjNiYTU1OWQzMjZmYjA", "commit": {"author": {"name": "Yannick Moy", "email": "moy@adacore.com", "date": "2021-11-26T07:55:13Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-12-02T16:26:29Z"}, "message": "[Ada] Amend proof of System.Arith_Double to remove justifications\n\ngcc/ada/\n\n\t* libgnat/s-aridou.adb (Log_Single_Size, Big_0): New ghost\n\tconstants.\n\t(Lemma_Mult_Non_Negative, Lemma_Mult_Non_Positive,\n\tLemma_Not_In_Range_Big2xx64): New lemmas on big integers.\n\t(Double_Divide): Remove justifications. Amend for that local\n\tlemma Prove_Overflow_Case.\n\t(Scaled_Divide): Remove justifications. Insert for that local\n\tlemmas Prove_Negative_Dividend, Prove_Positive_Dividend and\n\tProve_Q_Too_Big, and amend local lemma Prove_Overflow.  To prove\n\tthe loop invariant on (Shift mod 2 = 0), introduce local ghost\n\tvariable Iter to count loop iterations, and relate its value to\n\tthe value of Shift through Log_Single_Size, with the help of\n\tlocal lemma Prove_Power. Deal with proof regression by adding\n\tnew local lemma Prove_First_Iteration and local ghost variable\n\tD123.\n\t* libgnat/s-arit64.ads (Multiply_With_Ovflo_Check64): Remove\n\tunnecessary Pure_Function on function as package is Pure.", "tree": {"sha": "d92a4028c6fa802ffdf5b067e3cec24d6fe2331b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d92a4028c6fa802ffdf5b067e3cec24d6fe2331b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3f89a4510031af1913f70aad9b3ba559d326fb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3f89a4510031af1913f70aad9b3ba559d326fb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3f89a4510031af1913f70aad9b3ba559d326fb0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3f89a4510031af1913f70aad9b3ba559d326fb0/comments", "author": {"login": "yannickmoy", "id": 859440, "node_id": "MDQ6VXNlcjg1OTQ0MA==", "avatar_url": "https://avatars.githubusercontent.com/u/859440?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yannickmoy", "html_url": "https://github.com/yannickmoy", "followers_url": "https://api.github.com/users/yannickmoy/followers", "following_url": "https://api.github.com/users/yannickmoy/following{/other_user}", "gists_url": "https://api.github.com/users/yannickmoy/gists{/gist_id}", "starred_url": "https://api.github.com/users/yannickmoy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yannickmoy/subscriptions", "organizations_url": "https://api.github.com/users/yannickmoy/orgs", "repos_url": "https://api.github.com/users/yannickmoy/repos", "events_url": "https://api.github.com/users/yannickmoy/events{/privacy}", "received_events_url": "https://api.github.com/users/yannickmoy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce79e7e24acdc83620782dae9b954b1ad2bdb988", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce79e7e24acdc83620782dae9b954b1ad2bdb988", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce79e7e24acdc83620782dae9b954b1ad2bdb988"}], "stats": {"total": 246, "additions": 183, "deletions": 63}, "files": [{"sha": "0a75f08fcb98d9c3448584263a6fcba3cd47cd9c", "filename": "gcc/ada/libgnat/s-aridou.adb", "status": "modified", "additions": 182, "deletions": 61, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f89a4510031af1913f70aad9b3ba559d326fb0/gcc%2Fada%2Flibgnat%2Fs-aridou.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f89a4510031af1913f70aad9b3ba559d326fb0/gcc%2Fada%2Flibgnat%2Fs-aridou.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-aridou.adb?ref=b3f89a4510031af1913f70aad9b3ba559d326fb0", "patch": "@@ -55,6 +55,15 @@ is\n    Double_Size : constant Natural := Double_Int'Size;\n    Single_Size : constant Natural := Double_Int'Size / 2;\n \n+   --  Log of Single_Size in base 2, so that Single_Size = 2 ** Log_Single_Size\n+   Log_Single_Size : constant Natural :=\n+     (case Single_Size is\n+        when 32  => 5,\n+        when 64  => 6,\n+        when 128 => 7,\n+        when others => raise Program_Error)\n+   with Ghost;\n+\n    --  Power-of-two constants. Use the names Big_2xx32, Big_2xx63 and Big_2xx64\n    --  even if Single_Size might not be 32 and Double_Size might not be 64, as\n    --  this facilitates code and proof understanding, compared to more generic\n@@ -66,6 +75,9 @@ is\n    pragma Warnings\n      (Off, \"non-static constant in preelaborated unit\",\n       Reason => \"Ghost code is not compiled\");\n+   Big_0 : constant Big_Integer :=\n+     Big (Double_Uns'(0))\n+   with Ghost;\n    Big_2xx32 : constant Big_Integer :=\n      Big (Double_Int'(2 ** Single_Size))\n    with Ghost;\n@@ -198,6 +210,20 @@ is\n      Ghost,\n      Post => abs (X * Y) = abs X * abs Y;\n \n+   procedure Lemma_Mult_Non_Negative (X, Y : Big_Integer)\n+   with\n+     Ghost,\n+     Pre  => (X >= Big_0 and then Y >= Big_0)\n+       or else (X <= Big_0 and then Y <= Big_0),\n+     Post => X * Y >= Big_0;\n+\n+   procedure Lemma_Mult_Non_Positive (X, Y : Big_Integer)\n+   with\n+     Ghost,\n+     Pre  => (X <= Big_0 and then Y >= Big_0)\n+       or else (X >= Big_0 and then Y <= Big_0),\n+     Post => X * Y <= Big_0;\n+\n    procedure Lemma_Abs_Rem_Commutation (X, Y : Big_Integer)\n    with\n      Ghost,\n@@ -407,6 +433,11 @@ is\n      Pre  => Y /= 0,\n      Post => X rem Y = X rem (-Y);\n \n+   procedure Lemma_Not_In_Range_Big2xx64\n+   with\n+     Post => not In_Double_Int_Range (Big_2xx64)\n+       and then not In_Double_Int_Range (-Big_2xx64);\n+\n    procedure Lemma_Powers_Of_2 (M, N : Natural)\n    with\n      Ghost,\n@@ -551,7 +582,10 @@ is\n    procedure Lemma_Mult_Commutation (X, Y : Double_Int) is null;\n    procedure Lemma_Mult_Commutation (X, Y, Z : Double_Uns) is null;\n    procedure Lemma_Mult_Distribution (X, Y, Z : Big_Integer) is null;\n+   procedure Lemma_Mult_Non_Negative (X, Y : Big_Integer) is null;\n+   procedure Lemma_Mult_Non_Positive (X, Y : Big_Integer) is null;\n    procedure Lemma_Neg_Rem (X, Y : Big_Integer) is null;\n+   procedure Lemma_Not_In_Range_Big2xx64 is null;\n    procedure Lemma_Rem_Commutation (X, Y : Double_Uns) is null;\n    procedure Lemma_Rem_Is_Ident (X, Y : Big_Integer) is null;\n    procedure Lemma_Rem_Sign (X, Y : Big_Integer) is null;\n@@ -722,21 +756,15 @@ is\n \n       --  Local lemmas\n \n-      function Is_Division_By_Zero_Case return Boolean is\n-        (Y = 0 or else Z = 0)\n-      with Ghost;\n-\n-      function Is_Overflow_Case return Boolean is\n-        (not In_Double_Int_Range (Big (X) / (Big (Y) * Big (Z))))\n-      with\n-        Ghost,\n-        Pre => Y /= 0 and Z /= 0;\n-\n       procedure Prove_Overflow_Case\n       with\n         Ghost,\n         Pre  => X = Double_Int'First and then Big (Y) * Big (Z) = -1,\n-        Post => Is_Overflow_Case;\n+        Post => not In_Double_Int_Range (Big (X) / (Big (Y) * Big (Z)))\n+          and then not In_Double_Int_Range\n+            (Round_Quotient (Big (X), Big (Y) * Big (Z),\n+                             Big (X) / (Big (Y) * Big (Z)),\n+                             Big (X) rem (Big (Y) * Big (Z))));\n       --  Proves the special case where -2**(Double_Size - 1) is divided by -1,\n       --  generating an overflow.\n \n@@ -852,11 +880,7 @@ is\n \n    begin\n       if Yu = 0 or else Zu = 0 then\n-         pragma Assert (Is_Division_By_Zero_Case);\n          Raise_Error;\n-         pragma Annotate\n-           (GNATprove, Intentional, \"call to nonreturning subprogram\",\n-            \"Constraint_Error is raised in case of division by zero\");\n       end if;\n \n       pragma Assert (Mult /= 0);\n@@ -998,9 +1022,6 @@ is\n       if X = Double_Int'First and then Du = 1 and then not Den_Pos then\n          Prove_Overflow_Case;\n          Raise_Error;\n-         pragma Annotate\n-           (GNATprove, Intentional, \"call to nonreturning subprogram\",\n-            \"Constraint_Error is raised in case of overflow\");\n       end if;\n \n       --  Perform the actual division\n@@ -1624,11 +1645,10 @@ is\n       Quot  : Big_Integer with Ghost;\n       Big_R : Big_Integer with Ghost;\n       Big_Q : Big_Integer with Ghost;\n+      Inter : Natural with Ghost;\n \n       --  Local lemmas\n \n-      function Is_Division_By_Zero_Case return Boolean is (Z = 0) with Ghost;\n-\n       procedure Prove_Dividend_Scaling\n       with\n         Ghost,\n@@ -1666,13 +1686,61 @@ is\n       --  Proves correctness of the multiplication of divisor by quotient to\n       --  compute amount to subtract.\n \n+      procedure Prove_Negative_Dividend\n+      with\n+        Ghost,\n+        Pre  => Z /= 0\n+          and then Big (Qu) = abs Big_Q\n+          and then In_Double_Int_Range (Big_Q)\n+          and then Big (Ru) = abs Big_R\n+          and then ((X >= 0 and Y < 0) or (X < 0 and Y >= 0))\n+          and then Big_Q =\n+            (if Round then Round_Quotient (Big (X) * Big (Y), Big (Z),\n+                                           Big (X) * Big (Y) / Big (Z),\n+                                           Big (X) * Big (Y) rem Big (Z))\n+             else Big (X) * Big (Y) / Big (Z))\n+          and then Big_R = Big (X) * Big (Y) rem Big (Z),\n+         Post =>\n+           (if Z > 0 then Big_Q <= Big_0\n+              and then In_Double_Int_Range (-Big (Qu))\n+            else Big_Q >= Big_0\n+              and then In_Double_Int_Range (Big (Qu)))\n+           and then In_Double_Int_Range (-Big (Ru));\n+      --  Proves the sign of rounded quotient when dividend is non-positive\n+\n       procedure Prove_Overflow\n       with\n         Ghost,\n         Pre  => Z /= 0 and then Mult >= Big_2xx64 * Big (Double_Uns'(abs Z)),\n-        Post => not In_Double_Int_Range (Big (X) * Big (Y) / Big (Z));\n+        Post => not In_Double_Int_Range (Big (X) * Big (Y) / Big (Z))\n+          and then not In_Double_Int_Range\n+            (Round_Quotient (Big (X) * Big (Y), Big (Z),\n+                             Big (X) * Big (Y) / Big (Z),\n+                             Big (X) * Big (Y) rem Big (Z)));\n       --  Proves overflow case when the quotient has at least 3 digits\n \n+      procedure Prove_Positive_Dividend\n+      with\n+        Ghost,\n+        Pre  => Z /= 0\n+          and then Big (Qu) = abs Big_Q\n+          and then In_Double_Int_Range (Big_Q)\n+          and then Big (Ru) = abs Big_R\n+          and then ((X >= 0 and Y >= 0) or (X < 0 and Y < 0))\n+          and then Big_Q =\n+            (if Round then Round_Quotient (Big (X) * Big (Y), Big (Z),\n+                                           Big (X) * Big (Y) / Big (Z),\n+                                           Big (X) * Big (Y) rem Big (Z))\n+             else Big (X) * Big (Y) / Big (Z))\n+          and then Big_R = Big (X) * Big (Y) rem Big (Z),\n+        Post =>\n+           (if Z > 0 then Big_Q >= Big_0\n+              and then In_Double_Int_Range (Big (Qu))\n+            else Big_Q <= Big_0\n+              and then In_Double_Int_Range (-Big (Qu)))\n+           and then In_Double_Int_Range (Big (Ru));\n+      --  Proves the sign of rounded quotient when dividend is non-negative\n+\n       procedure Prove_Qd_Calculation_Part_1 (J : Integer)\n       with\n         Ghost,\n@@ -1689,6 +1757,14 @@ is\n       --  by the first digit of the divisor is not an underestimate (so\n       --  readjusting down works).\n \n+      procedure Prove_Q_Too_Big\n+      with\n+        Ghost,\n+        Pre  => In_Double_Int_Range (Big_Q)\n+          and then abs Big_Q = Big_2xx64,\n+        Post => False;\n+      --  Proves the inconsistency when Q is equal to Big_2xx64\n+\n       procedure Prove_Rescaling\n       with\n         Ghost,\n@@ -1846,6 +1922,15 @@ is\n               Big (Double_Uns (S1)));\n       end Prove_Multiplication;\n \n+      -----------------------------\n+      -- Prove_Negative_Dividend --\n+      -----------------------------\n+\n+      procedure Prove_Negative_Dividend is\n+      begin\n+         Lemma_Mult_Non_Positive (Big (X), Big (Y));\n+      end Prove_Negative_Dividend;\n+\n       --------------------\n       -- Prove_Overflow --\n       --------------------\n@@ -1857,6 +1942,15 @@ is\n          Lemma_Abs_Div_Commutation (Big (X) * Big (Y), Big (Z));\n       end Prove_Overflow;\n \n+      -----------------------------\n+      -- Prove_Positive_Dividend --\n+      -----------------------------\n+\n+      procedure Prove_Positive_Dividend is\n+      begin\n+         Lemma_Mult_Non_Negative (Big (X), Big (Y));\n+      end Prove_Positive_Dividend;\n+\n       ---------------------------------\n       -- Prove_Qd_Calculation_Part_1 --\n       ---------------------------------\n@@ -1888,6 +1982,16 @@ is\n                        Big (Double_Uns (Qd (J))) + 1, Big (Zu));\n       end Prove_Qd_Calculation_Part_1;\n \n+      ---------------------\n+      -- Prove_Q_Too_Big --\n+      ---------------------\n+\n+      procedure Prove_Q_Too_Big is\n+      begin\n+         pragma Assert (Big_Q = Big_2xx64 or Big_Q = -Big_2xx64);\n+         Lemma_Not_In_Range_Big2xx64;\n+      end Prove_Q_Too_Big;\n+\n       ---------------------\n       -- Prove_Rescaling --\n       ---------------------\n@@ -1974,11 +2078,7 @@ is\n \n    begin\n       if Z = 0 then\n-         pragma Assert (Is_Division_By_Zero_Case);\n          Raise_Error;\n-         pragma Annotate\n-           (GNATprove, Intentional, \"call to nonreturning subprogram\",\n-            \"Constraint_Error is raised in case of division by zero\");\n       end if;\n \n       Quot := Big (X) * Big (Y) / Big (Z);\n@@ -2136,9 +2236,6 @@ is\n \n             Prove_Overflow;\n             Raise_Error;\n-            pragma Annotate\n-              (GNATprove, Intentional, \"call to nonreturning subprogram\",\n-               \"Constraint_Error is raised in case of overflow\");\n \n          --  Here we are dividing at most three digits by one digit\n \n@@ -2159,9 +2256,6 @@ is\n          Lemma_Ge_Commutation (D (1) & D (2), Zu);\n          Prove_Overflow;\n          Raise_Error;\n-         pragma Annotate\n-           (GNATprove, Intentional, \"call to nonreturning subprogram\",\n-            \"Constraint_Error is raised in case of overflow\");\n \n       --  This is the complex case where we definitely have a double digit\n       --  divisor and a dividend of at least three digits. We use the classical\n@@ -2177,6 +2271,7 @@ is\n          Mask  := Single_Uns'Last;\n          Scale := 0;\n \n+         Inter := 0;\n          pragma Assert (Big_2xx (Scale) = 1);\n \n          while Shift > 1 loop\n@@ -2187,18 +2282,27 @@ is\n             pragma Loop_Invariant (Zu = Shift_Left (abs Z, Scale));\n             pragma Loop_Invariant (Big (Zu) =\n               Big (Double_Uns'(abs Z)) * Big_2xx (Scale));\n+            pragma Loop_Invariant (Inter in 0 .. Log_Single_Size - 1);\n+            pragma Loop_Invariant (Shift = 2 ** (Log_Single_Size - Inter));\n             pragma Loop_Invariant (Shift mod 2 = 0);\n-            pragma Annotate\n-              (GNATprove, False_Positive, \"loop invariant\",\n-               \"Shift actually is a power of 2\");\n-            --  Note : this scaling algorithm only works when Single_Size is a\n-            --  power of 2.\n \n             declare\n+               --  Local ghost variables\n+\n                Shift_Prev : constant Natural := Shift with Ghost;\n                Mask_Prev  : constant Single_Uns := Mask with Ghost;\n                Zu_Prev    : constant Double_Uns := Zu with Ghost;\n \n+               --  Local lemmas\n+\n+               procedure Prove_Power\n+               with\n+                 Ghost,\n+                 Pre  => Inter in 0 .. Log_Single_Size - 1\n+                   and then Shift = 2 ** (Log_Single_Size - Inter),\n+                 Post => Shift / 2 = 2 ** (Log_Single_Size - (Inter + 1))\n+                   and then (Shift = 2 or (Shift / 2) mod 2 = 0);\n+\n                procedure Prove_Shifting\n                with\n                  Ghost,\n@@ -2211,15 +2315,24 @@ is\n                    and then (Hi (Zu_Prev) and Mask_Prev and not Mask) /= 0,\n                  Post => (Hi (Zu) and Mask) /= 0;\n \n+               -----------------\n+               -- Prove_Power --\n+               -----------------\n+\n+               procedure Prove_Power is null;\n+\n                --------------------\n                -- Prove_Shifting --\n                --------------------\n \n                procedure Prove_Shifting is null;\n \n             begin\n+               Prove_Power;\n+\n                Shift := Shift / 2;\n \n+               Inter := Inter + 1;\n                pragma Assert (Shift_Prev = 2 * Shift);\n \n                Mask := Shift_Left (Mask, Shift);\n@@ -2306,7 +2419,29 @@ is\n          --  Loop to compute quotient digits, runs twice for Qd (1) and Qd (2)\n \n          declare\n-            Qd1 : Single_Uns := 0 with Ghost;\n+            --  Local lemmas\n+\n+            procedure Prove_First_Iteration (X1, X2, X3, X4 : Single_Uns)\n+            with\n+              Ghost,\n+              Pre  => X1 = 0,\n+              Post =>\n+                Big_2xx32 * Big3 (X1, X2, X3) + Big (Double_Uns (X4))\n+                  = Big3 (X2, X3, X4);\n+\n+            ---------------------------\n+            -- Prove_First_Iteration --\n+            ---------------------------\n+\n+            procedure Prove_First_Iteration (X1, X2, X3, X4 : Single_Uns) is\n+            null;\n+\n+            --  Local ghost variables\n+\n+            Qd1  : Single_Uns := 0 with Ghost;\n+            D123 : constant Big_Integer := Big3 (D (1), D (2), D (3))\n+              with Ghost;\n+\n          begin\n             for J in 1 .. 2 loop\n                Lemma_Hi_Lo (D (J) & D (J + 1), D (J), D (J + 1));\n@@ -2432,12 +2567,11 @@ is\n \n                if J = 1 then\n                   Qd1 := Qd (1);\n-                  pragma Assert\n-                    (Big_2xx32 * Big_2xx32 * Big (Double_Uns (D (1))) = 0);\n-                  pragma Assert\n-                    (Mult * Big_2xx (Scale) =\n-                       Big_2xx32 * Big3 (S1, S2, S3)\n-                     + Big3 (D (2), D (3), D (4)));\n+                  Lemma_Substitution\n+                    (Mult * Big_2xx (Scale), Big_2xx32, D123,\n+                     Big3 (D (1), D (2), D (3)) + Big3 (S1, S2, S3),\n+                     Big (Double_Uns (D (4))));\n+                  Prove_First_Iteration (D (1), D (2), D (3), D (4));\n                   Lemma_Substitution (Mult * Big_2xx (Scale), Big_2xx32,\n                                       Big3 (S1, S2, S3),\n                                       Big (Double_Uns (Qd1)) * Big (Zu),\n@@ -2510,11 +2644,8 @@ is\n             --  an overflow when the quotient is too large.\n \n             if Qu = Double_Uns'Last then\n-               pragma Assert (abs Big_Q = Big_2xx64);\n+               Prove_Q_Too_Big;\n                Raise_Error;\n-               pragma Annotate\n-                 (GNATprove, Intentional, \"call to nonreturning subprogram\",\n-                  \"Constraint_Error is raised in case of overflow\");\n             end if;\n \n             Lemma_Add_One (Qu);\n@@ -2530,28 +2661,18 @@ is\n       --  Case of dividend (X * Y) sign positive\n \n       if (X >= 0 and then Y >= 0) or else (X < 0 and then Y < 0) then\n-         R := To_Pos_Int (Ru);\n-         pragma Annotate\n-           (GNATprove, Intentional, \"precondition\",\n-            \"Constraint_Error is raised in case of overflow\");\n+         Prove_Positive_Dividend;\n \n+         R := To_Pos_Int (Ru);\n          Q := (if Z > 0 then To_Pos_Int (Qu) else To_Neg_Int (Qu));\n-         pragma Annotate\n-           (GNATprove, Intentional, \"precondition\",\n-            \"Constraint_Error is raised in case of overflow\");\n \n       --  Case of dividend (X * Y) sign negative\n \n       else\n-         R := To_Neg_Int (Ru);\n-         pragma Annotate\n-           (GNATprove, Intentional, \"precondition\",\n-            \"Constraint_Error is raised in case of overflow\");\n+         Prove_Negative_Dividend;\n \n+         R := To_Neg_Int (Ru);\n          Q := (if Z > 0 then To_Neg_Int (Qu) else To_Pos_Int (Qu));\n-         pragma Annotate\n-           (GNATprove, Intentional, \"precondition\",\n-            \"Constraint_Error is raised in case of overflow\");\n       end if;\n \n       Prove_Sign_R;"}, {"sha": "9e8492d1ee2851be7ed81d4ee32499fd89877de5", "filename": "gcc/ada/libgnat/s-arit64.ads", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f89a4510031af1913f70aad9b3ba559d326fb0/gcc%2Fada%2Flibgnat%2Fs-arit64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f89a4510031af1913f70aad9b3ba559d326fb0/gcc%2Fada%2Flibgnat%2Fs-arit64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-arit64.ads?ref=b3f89a4510031af1913f70aad9b3ba559d326fb0", "patch": "@@ -60,7 +60,7 @@ is\n \n    subtype Big_Integer is\n      Ada.Numerics.Big_Numbers.Big_Integers_Ghost.Big_Integer\n-     with Ghost;\n+   with Ghost;\n \n    package Signed_Conversion is new\n      Ada.Numerics.Big_Numbers.Big_Integers_Ghost.Signed_Conversions\n@@ -91,7 +91,6 @@ is\n \n    function Multiply_With_Ovflo_Check64 (X, Y : Int64) return Int64\n    with\n-     Pure_Function,\n      Pre  => In_Int64_Range (Big (X) * Big (Y)),\n      Post => Multiply_With_Ovflo_Check64'Result = X * Y;\n    pragma Export (C, Multiply_With_Ovflo_Check64, \"__gnat_mulv64\");"}]}