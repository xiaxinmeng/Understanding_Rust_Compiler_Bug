{"sha": "34c878297e0f842d688d0e1b08c382098a123b72", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzRjODc4Mjk3ZTBmODQyZDY4OGQwZTFiMDhjMzgyMDk4YTEyM2I3Mg==", "commit": {"author": {"name": "Matt Austern", "email": "austern@apple.com", "date": "2003-12-23T00:09:26Z"}, "committer": {"name": "Matt Austern", "email": "austern@gcc.gnu.org", "date": "2003-12-23T00:09:26Z"}, "message": "stl_bvector.h (_Bvector_alloc_base): Eliminate.\n\n\n        * include/bits/stl_bvector.h (_Bvector_alloc_base): Eliminate.\n        (_Bvector_base): Inherit directly from word allocator.\n        * include/bits/stl_tree.h (_Rb_tree_alloc_base): Eliminate.\n        (_Rb_tree_base): Eliminate.\n        (_Rb_tree): Inherit directly from node allocator.\n        * include/ext/slist (_Alist_alloc_base): Eliminate.\n        (_Slist_base): Inherit direcly from node allocator.\n\nFrom-SVN: r74955", "tree": {"sha": "aafece8c832b2bcaa5f99d0efb33218e6603c50d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aafece8c832b2bcaa5f99d0efb33218e6603c50d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/34c878297e0f842d688d0e1b08c382098a123b72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34c878297e0f842d688d0e1b08c382098a123b72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34c878297e0f842d688d0e1b08c382098a123b72", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34c878297e0f842d688d0e1b08c382098a123b72/comments", "author": null, "committer": null, "parents": [{"sha": "7813d14ccc5089fc5ef8eceb5377f41ab6a9844d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7813d14ccc5089fc5ef8eceb5377f41ab6a9844d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7813d14ccc5089fc5ef8eceb5377f41ab6a9844d"}], "stats": {"total": 268, "additions": 68, "deletions": 200}, "files": [{"sha": "666f7806bcc5f0c2bbf07f45be96753aa0f87265", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34c878297e0f842d688d0e1b08c382098a123b72/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34c878297e0f842d688d0e1b08c382098a123b72/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=34c878297e0f842d688d0e1b08c382098a123b72", "patch": "@@ -1,3 +1,13 @@\n+2003-12-22  Matt Austern  <austern@apple.com>\n+\n+\t* include/bits/stl_bvector.h (_Bvector_alloc_base): Eliminate.\n+\t(_Bvector_base): Inherit directly from word allocator.\n+\t* include/bits/stl_tree.h (_Rb_tree_alloc_base): Eliminate.\n+\t(_Rb_tree_base): Eliminate.\n+\t(_Rb_tree): Inherit directly from node allocator.\n+\t* include/ext/slist (_Alist_alloc_base): Eliminate.\n+\t(_Slist_base): Inherit direcly from node allocator.\n+\t\n 2003-12-22  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* testsuite/18_support/numeric_limits.cc: Add _GLIBCXX_ASSERT to"}, {"sha": "884256151f431dd78a875bbd4e24307e0487a2e3", "filename": "libstdc++-v3/include/bits/stl_bvector.h", "status": "modified", "additions": 16, "deletions": 60, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34c878297e0f842d688d0e1b08c382098a123b72/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34c878297e0f842d688d0e1b08c382098a123b72/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h?ref=34c878297e0f842d688d0e1b08c382098a123b72", "patch": "@@ -261,77 +261,33 @@ inline _Bit_const_iterator\n operator+(ptrdiff_t __n, const _Bit_const_iterator& __x) { return __x + __n; }\n \n \n-// Bit-vector base class, which encapsulates the difference between\n-// old SGI-style allocators and standard-conforming allocators.\n-\n-// Base class for ordinary allocators.\n-template <class _Allocator, bool __is_static>\n-class _Bvector_alloc_base {\n-public:\n-  typedef typename _Alloc_traits<bool, _Allocator>::allocator_type\n-          allocator_type;\n-  allocator_type get_allocator() const { return _M_data_allocator; }\n-\n-  _Bvector_alloc_base(const allocator_type& __a)\n-    : _M_data_allocator(__a), _M_start(), _M_finish(), _M_end_of_storage(0) {}\n-\n-protected:\n-  _Bit_type * _M_bit_alloc(size_t __n) \n-    { return _M_data_allocator.allocate((__n + _S_word_bit - 1)/_S_word_bit); }\n-  void _M_deallocate() {\n-    if (_M_start._M_p)\n-      _M_data_allocator.deallocate(_M_start._M_p, \n-                                   _M_end_of_storage - _M_start._M_p);\n-  }  \n-\n-  typename _Alloc_traits<_Bit_type, _Allocator>::allocator_type \n-          _M_data_allocator;\n-  _Bit_iterator _M_start;\n-  _Bit_iterator _M_finish;\n-  _Bit_type * _M_end_of_storage;\n-};\n-\n-// Specialization for instanceless allocators.\n-template <class _Allocator>\n-class _Bvector_alloc_base<_Allocator, true> {\n+template <class _Alloc>\n+class _Bvector_base\n+  : public _Alloc::template rebind<_Bit_type>::other\n+{\n+  typedef typename _Alloc::template rebind<_Bit_type>::other _Bit_alloc_type;\n public:\n-  typedef typename _Alloc_traits<bool, _Allocator>::allocator_type\n-          allocator_type;\n-  allocator_type get_allocator() const { return allocator_type(); }\n+  typedef _Alloc allocator_type;\n+  allocator_type get_allocator() const {\n+    return *static_cast<const _Bit_alloc_type*>(this);\n+  }\n \n-  _Bvector_alloc_base(const allocator_type&)\n-    : _M_start(), _M_finish(), _M_end_of_storage(0) {}\n+  _Bvector_base(const allocator_type& __a)\n+    : _Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage(0) { }\n+  ~_Bvector_base() { this->_M_deallocate(); }\n \n protected:\n-  typedef typename _Alloc_traits<_Bit_type, _Allocator>::_Alloc_type\n-          _Alloc_type;\n-          \n-  _Bit_type * _M_bit_alloc(size_t __n) \n-    { return _Alloc_type::allocate((__n + _S_word_bit - 1)/_S_word_bit); }\n+  _Bit_type* _M_bit_alloc(size_t __n) {\n+    return _Bit_alloc_type::allocate((__n + _S_word_bit - 1)/_S_word_bit);\n+  }\n   void _M_deallocate() {\n     if (_M_start._M_p)\n-      _Alloc_type::deallocate(_M_start._M_p,\n-                              _M_end_of_storage - _M_start._M_p);\n+      _Bit_alloc_type::deallocate(_M_start._M_p, _M_end_of_storage - _M_start._M_p);\n   }  \n \n   _Bit_iterator _M_start;\n   _Bit_iterator _M_finish;\n   _Bit_type * _M_end_of_storage;\n-};  \n-\n-template <class _Alloc>\n-class _Bvector_base\n-  : public _Bvector_alloc_base<_Alloc,\n-                               _Alloc_traits<bool, _Alloc>::_S_instanceless>\n-{\n-  typedef _Bvector_alloc_base<_Alloc,\n-                              _Alloc_traits<bool, _Alloc>::_S_instanceless>\n-          _Base;\n-public:\n-  typedef typename _Base::allocator_type allocator_type;\n-\n-  _Bvector_base(const allocator_type& __a) : _Base(__a) {}\n-  ~_Bvector_base() { _Base::_M_deallocate(); }\n };\n \n } // namespace __gnu_norm"}, {"sha": "d0739e10a57bc0cd56ccb58debf9626a8c92f764", "filename": "libstdc++-v3/include/bits/stl_tree.h", "status": "modified", "additions": 30, "deletions": 81, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34c878297e0f842d688d0e1b08c382098a123b72/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34c878297e0f842d688d0e1b08c382098a123b72/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h?ref=34c878297e0f842d688d0e1b08c382098a123b72", "patch": "@@ -261,79 +261,14 @@ namespace std\n   _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* const __z, \n \t\t\t       _Rb_tree_node_base& \t __header);\n \n-  // Base class to encapsulate the differences between old SGI-style\n-  // allocators and standard-conforming allocators.  In order to avoid\n-  // having an empty base class, we arbitrarily move one of rb_tree's\n-  // data members into the base class.\n-\n-  // _Base for general standard-conforming allocators.\n-  template<typename _Tp, typename _Alloc, bool _S_instanceless>\n-    class _Rb_tree_alloc_base \n-    {\n-    public:\n-    typedef typename _Alloc_traits<_Tp, _Alloc>::allocator_type allocator_type;\n-\n-      allocator_type \n-      get_allocator() const { return _M_node_allocator; }\n-\n-      _Rb_tree_alloc_base(const allocator_type& __a)\n-      : _M_node_allocator(__a) {}\n-\n-    protected:\n-      typename _Alloc_traits<_Rb_tree_node<_Tp>, _Alloc>::allocator_type\n-      _M_node_allocator;\n-\n-      _Rb_tree_node_base _M_header;\n-      \n-      _Rb_tree_node<_Tp>* \n-      _M_get_node()  { return _M_node_allocator.allocate(1); }\n-\n-      void \n-      _M_put_node(_Rb_tree_node<_Tp>* __p) \n-      { _M_node_allocator.deallocate(__p, 1); }\n-    };\n-\n-  // Specialization for instanceless allocators.\n-  template<typename _Tp, typename _Alloc>\n-    class _Rb_tree_alloc_base<_Tp, _Alloc, true> \n-    {\n-    public:\n-    typedef typename _Alloc_traits<_Tp, _Alloc>::allocator_type allocator_type;\n-      allocator_type get_allocator() const { return allocator_type(); }\n-\n-      _Rb_tree_alloc_base(const allocator_type&) {}\n-\n-    protected:\n-      _Rb_tree_node_base _M_header;\n-      \n-      typedef typename _Alloc_traits<_Rb_tree_node<_Tp>, _Alloc>::_Alloc_type\n-      _Alloc_type;\n-      \n-      _Rb_tree_node<_Tp>* \n-      _M_get_node() { return _Alloc_type::allocate(1); }\n-\n-      void \n-      _M_put_node(_Rb_tree_node<_Tp>* __p) { _Alloc_type::deallocate(__p, 1); }\n-    };\n-  \n-  template<typename _Tp, typename _Alloc>\n-    struct _Rb_tree_base : public _Rb_tree_alloc_base<_Tp, _Alloc, \n-                                  _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n-    {\n-      typedef _Rb_tree_alloc_base<_Tp, \n-\t_Alloc, _Alloc_traits<_Tp, _Alloc>::_S_instanceless> _Base;\n-      typedef typename _Base::allocator_type allocator_type;\n-\n-      _Rb_tree_base(const allocator_type& __a) \n-      : _Base(__a) {}\n-    };\n-\n \n   template<typename _Key, typename _Val, typename _KeyOfValue, \n            typename _Compare, typename _Alloc = allocator<_Val> >\n-    class _Rb_tree : protected _Rb_tree_base<_Val, _Alloc> \n+    class _Rb_tree\n+      : protected _Alloc::template rebind<_Rb_tree_node<_Val> >::other\n     {\n-      typedef _Rb_tree_base<_Val, _Alloc> _Base;\n+      typedef typename _Alloc::template rebind<_Rb_tree_node<_Val> >::other\n+              _Node_allocator;\n       \n     protected:\n       typedef _Rb_tree_node_base* _Base_ptr;\n@@ -352,18 +287,22 @@ namespace std\n       typedef size_t size_type;\n       typedef ptrdiff_t difference_type;\n       \n-      typedef typename _Base::allocator_type allocator_type;\n-      allocator_type get_allocator() const { return _Base::get_allocator(); }\n+      typedef _Alloc allocator_type;\n+      allocator_type get_allocator() const {\n+\treturn *static_cast<const _Node_allocator*>(this);\n+      }\n       \n     protected:\n-      using _Base::_M_get_node;\n-      using _Base::_M_put_node;\n-      using _Base::_M_header;\n+      _Rb_tree_node*\n+      _M_get_node() { return _Node_allocator::allocate(1); }\n+\n+      void \n+      _M_put_node(_Rb_tree_node* __p) { _Node_allocator::deallocate(__p, 1); }\n       \n       _Link_type\n       _M_create_node(const value_type& __x)\n       {\n-\t_Link_type __tmp = this->_M_get_node();\n+\t_Link_type __tmp = _M_get_node();\n \ttry \n \t  { std::_Construct(&__tmp->_M_value_field, __x); }\n \tcatch(...)\n@@ -391,9 +330,12 @@ namespace std\n \t_M_put_node(__p);\n       }\n \n+    protected:\n+      _Rb_tree_node_base _M_header;\n       size_type _M_node_count; // keeps track of size of tree\n       _Compare _M_key_compare;\n-\n+      \n+    protected:\n       _Base_ptr&\n       _M_root() { return this->_M_header._M_parent; }\n \n@@ -485,20 +427,27 @@ namespace std\n     public:\n       // allocation/deallocation\n       _Rb_tree()\n-\t: _Base(allocator_type()), _M_node_count(0), _M_key_compare()\n+\t: _Node_allocator(allocator_type()),\n+\t  _M_node_count(0),\n+\t  _M_key_compare()\n       { _M_empty_initialize(); }\n \n       _Rb_tree(const _Compare& __comp)\n-\t: _Base(allocator_type()), _M_node_count(0), _M_key_compare(__comp) \n+\t: _Node_allocator(allocator_type()),\n+\t  _M_node_count(0),\n+\t  _M_key_compare(__comp) \n       { _M_empty_initialize(); }\n \n       _Rb_tree(const _Compare& __comp, const allocator_type& __a)\n-\t: _Base(__a), _M_node_count(0), _M_key_compare(__comp) \n+\t: _Node_allocator(__a),\n+\t  _M_node_count(0),\n+\t  _M_key_compare(__comp) \n       { _M_empty_initialize(); }\n \n       _Rb_tree(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x) \n-\t: _Base(__x.get_allocator()), _M_node_count(0), \n-\t\t _M_key_compare(__x._M_key_compare)\n+\t: _Node_allocator(__x.get_allocator()),\n+\t  _M_node_count(0), \n+\t  _M_key_compare(__x._M_key_compare)\n       { \n \tif (__x._M_root() == 0)\n \t  _M_empty_initialize();"}, {"sha": "4b5852030184e23244b7dff29799c6e49bc06929", "filename": "libstdc++-v3/include/ext/slist", "status": "modified", "additions": 12, "deletions": 59, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34c878297e0f842d688d0e1b08c382098a123b72/libstdc%2B%2B-v3%2Finclude%2Fext%2Fslist", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34c878297e0f842d688d0e1b08c382098a123b72/libstdc%2B%2B-v3%2Finclude%2Fext%2Fslist", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fslist?ref=34c878297e0f842d688d0e1b08c382098a123b72", "patch": "@@ -60,7 +60,6 @@ namespace __gnu_cxx\n {\n using std::size_t;\n using std::ptrdiff_t;\n-using std::_Alloc_traits;\n using std::_Construct;\n using std::_Destroy;\n using std::allocator;\n@@ -201,73 +200,27 @@ struct _Slist_iterator : public _Slist_iterator_base\n   }\n };\n \n-\n-// Base class that encapsulates details of allocators.  Three cases:\n-// an ordinary standard-conforming allocator, a standard-conforming\n-// allocator with no non-static data, and an SGI-style allocator.\n-// This complexity is necessary only because we're worrying about backward\n-// compatibility and because we want to avoid wasting storage on an\n-// allocator instance if it isn't necessary.\n-\n-// Base for general standard-conforming allocators.\n-template <class _Tp, class _Allocator, bool _IsStatic>\n-class _Slist_alloc_base {\n-public:\n-  typedef typename _Alloc_traits<_Tp,_Allocator>::allocator_type\n-          allocator_type;\n-  allocator_type get_allocator() const { return _M_node_allocator; }\n-\n-  _Slist_alloc_base(const allocator_type& __a) : _M_node_allocator(__a) {}\n-\n-protected:\n-  _Slist_node<_Tp>* _M_get_node()\n-    { return _M_node_allocator.allocate(1); }\n-  void _M_put_node(_Slist_node<_Tp>* __p)\n-    { _M_node_allocator.deallocate(__p, 1); }\n-\n-protected:\n-  typename _Alloc_traits<_Slist_node<_Tp>,_Allocator>::allocator_type\n-           _M_node_allocator;\n-  _Slist_node_base _M_head;\n-};\n-\n-// Specialization for instanceless allocators.\n-template <class _Tp, class _Allocator>\n-class _Slist_alloc_base<_Tp,_Allocator, true> {\n-public:\n-  typedef typename _Alloc_traits<_Tp,_Allocator>::allocator_type\n-          allocator_type;\n-  allocator_type get_allocator() const { return allocator_type(); }\n-\n-  _Slist_alloc_base(const allocator_type&) {}\n-\n-protected:\n-  typedef typename _Alloc_traits<_Slist_node<_Tp>, _Allocator>::_Alloc_type\n-          _Alloc_type;\n-  _Slist_node<_Tp>* _M_get_node() { return _Alloc_type::allocate(1); }\n-  void _M_put_node(_Slist_node<_Tp>* __p) { _Alloc_type::deallocate(__p, 1); }\n-\n-protected:\n-  _Slist_node_base _M_head;\n-};\n-\n-\n template <class _Tp, class _Alloc>\n struct _Slist_base\n-  : public _Slist_alloc_base<_Tp, _Alloc,\n-                             _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n+  : public _Alloc::template rebind<_Slist_node<_Tp> >::other\n {\n-  typedef _Slist_alloc_base<_Tp, _Alloc,\n-                            _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n-          _Base;\n-  typedef typename _Base::allocator_type allocator_type;\n+  typedef typename _Alloc::template rebind<_Slist_node<_Tp> >::other _Node_alloc;\n+  typedef _Alloc allocator_type;\n+  allocator_type get_allocator() const {\n+    return *static_cast<const _Node_alloc*>(this);\n+  }\n \n   _Slist_base(const allocator_type& __a)\n-    : _Base(__a) { this->_M_head._M_next = 0; }\n+    : _Node_alloc(__a) { this->_M_head._M_next = 0; }\n   ~_Slist_base() { _M_erase_after(&this->_M_head, 0); }\n \n protected:\n+  _Slist_node_base _M_head;\n+\n+  _Slist_node<_Tp>* _M_get_node() { return _Node_alloc::allocate(1); }\n+  void _M_put_node(_Slist_node<_Tp>* __p) { _Node_alloc::deallocate(__p, 1); }\n \n+protected:\n   _Slist_node_base* _M_erase_after(_Slist_node_base* __pos)\n   {\n     _Slist_node<_Tp>* __next = (_Slist_node<_Tp>*) (__pos->_M_next);"}]}