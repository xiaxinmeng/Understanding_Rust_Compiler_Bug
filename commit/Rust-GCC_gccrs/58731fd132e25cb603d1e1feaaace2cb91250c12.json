{"sha": "58731fd132e25cb603d1e1feaaace2cb91250c12", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTg3MzFmZDEzMmUyNWNiNjAzZDFlMWZlYWFhY2UyY2I5MTI1MGMxMg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2002-10-15T18:07:24Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2002-10-15T18:07:24Z"}, "message": "class.c (check_field_decls): Remove empty_p parameter.\n\n\t* class.c (check_field_decls): Remove empty_p parameter.  Instead,\n\tclear CLASSTYPE_EMPTY_P.\n\t(build_base_field): Likewise.\n\t(build_base_fields): Likewise.\n\t(check_bases_and_members): Likewise.\n\t(create_vtbl_ptr): Likewise.\n\t(layout_class_type): Likewise.  Ensure that empty classes have\n\tsize zero when used as base classes in the 3.2 ABI.\n\t(finish_struct_1): Initialize CLASSTYPE_EMPTY_P and\n\tCLASSTYPE_NEARLY_EMPTY_P.  Adjust calls to avoid passing empty_p\n\tparameter.\n\t(is_empty_class): Correct definition when using post-3.2 ABI.\n\t* cp-tree.h (lang_type_class): Add empty_p.\n\t(CLASSTYPE_EMPTY_P): New macro.\n\nFrom-SVN: r58170", "tree": {"sha": "540eba52f5bcd4dc6ad66ca792f75b01a15d0874", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/540eba52f5bcd4dc6ad66ca792f75b01a15d0874"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/58731fd132e25cb603d1e1feaaace2cb91250c12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58731fd132e25cb603d1e1feaaace2cb91250c12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58731fd132e25cb603d1e1feaaace2cb91250c12", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58731fd132e25cb603d1e1feaaace2cb91250c12/comments", "author": null, "committer": null, "parents": [{"sha": "a2ee89d82d9ccb19e489ceed121057f23a34da4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2ee89d82d9ccb19e489ceed121057f23a34da4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2ee89d82d9ccb19e489ceed121057f23a34da4f"}], "stats": {"total": 161, "additions": 104, "deletions": 57}, "files": [{"sha": "9087df7fe428460ff0b1ad90945aa2fbc09628ad", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58731fd132e25cb603d1e1feaaace2cb91250c12/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58731fd132e25cb603d1e1feaaace2cb91250c12/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=58731fd132e25cb603d1e1feaaace2cb91250c12", "patch": "@@ -1,3 +1,20 @@\n+2002-10-14  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* class.c (check_field_decls): Remove empty_p parameter.  Instead,\n+\tclear CLASSTYPE_EMPTY_P.\n+\t(build_base_field): Likewise.\n+\t(build_base_fields): Likewise.\n+\t(check_bases_and_members): Likewise.\n+\t(create_vtbl_ptr): Likewise.\n+\t(layout_class_type): Likewise.  Ensure that empty classes have\n+\tsize zero when used as base classes in the 3.2 ABI.\n+\t(finish_struct_1): Initialize CLASSTYPE_EMPTY_P and\n+\tCLASSTYPE_NEARLY_EMPTY_P.  Adjust calls to avoid passing empty_p\n+\tparameter.\n+\t(is_empty_class): Correct definition when using post-3.2 ABI.\n+\t* cp-tree.h (lang_type_class): Add empty_p.\n+\t(CLASSTYPE_EMPTY_P): New macro.\n+\n 2002-10-12  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* init.c (build_delete): Do not apply save_expr for arrays."}, {"sha": "59f5ce37fc1201fa01da3c5cf888813ec5eef0d4", "filename": "gcc/cp/class.c", "status": "modified", "additions": 63, "deletions": 56, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58731fd132e25cb603d1e1feaaace2cb91250c12/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58731fd132e25cb603d1e1feaaace2cb91250c12/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=58731fd132e25cb603d1e1feaaace2cb91250c12", "patch": "@@ -134,20 +134,17 @@ static tree build_vtbl_initializer PARAMS ((tree, tree, tree, tree, int *));\n static int count_fields PARAMS ((tree));\n static int add_fields_to_vec PARAMS ((tree, tree, int));\n static void check_bitfield_decl PARAMS ((tree));\n-static void check_field_decl PARAMS ((tree, tree, int *, int *, int *, int *));\n-static void check_field_decls PARAMS ((tree, tree *, int *, int *, int *, \n-\t\t\t\t     int *));\n-static tree *build_base_field PARAMS ((record_layout_info, tree, int *,\n-\t\t\t\t       splay_tree, tree *));\n-static void build_base_fields PARAMS ((record_layout_info, int *,\n-\t\t\t\t      splay_tree, tree *));\n+static void check_field_decl (tree, tree, int *, int *, int *, int *);\n+static void check_field_decls (tree, tree *, int *, int *, int *);\n+static tree *build_base_field (record_layout_info, tree, splay_tree, tree *);\n+static void build_base_fields (record_layout_info, splay_tree, tree *);\n static void check_methods PARAMS ((tree));\n static void remove_zero_width_bit_fields PARAMS ((tree));\n static void check_bases PARAMS ((tree, int *, int *, int *));\n-static void check_bases_and_members PARAMS ((tree, int *));\n-static tree create_vtable_ptr PARAMS ((tree, int *, tree *));\n+static void check_bases_and_members (tree);\n+static tree create_vtable_ptr (tree, tree *);\n static void include_empty_classes (record_layout_info);\n-static void layout_class_type PARAMS ((tree, int *, int *, tree *));\n+static void layout_class_type (tree, int *, tree *);\n static void fixup_pending_inline PARAMS ((tree));\n static void fixup_inline_methods PARAMS ((tree));\n static void set_primary_base PARAMS ((tree, tree, int *));\n@@ -3201,15 +3198,10 @@ check_field_decl (field, t, cant_have_const_ctor,\n    fields can be added by adding to this chain.  */\n \n static void\n-check_field_decls (t, access_decls, empty_p, \n-\t\t   cant_have_default_ctor_p, cant_have_const_ctor_p,\n-\t\t   no_const_asn_ref_p)\n-     tree t;\n-     tree *access_decls;\n-     int *empty_p;\n-     int *cant_have_default_ctor_p;\n-     int *cant_have_const_ctor_p;\n-     int *no_const_asn_ref_p;\n+check_field_decls (tree t, tree *access_decls,\n+\t\t   int *cant_have_default_ctor_p, \n+\t\t   int *cant_have_const_ctor_p,\n+\t\t   int *no_const_asn_ref_p)\n {\n   tree *field;\n   tree *next;\n@@ -3245,7 +3237,7 @@ check_field_decls (t, access_decls, empty_p,\n \t  else\n \t    {\n \t      /* The class is non-empty.  */\n-\t      *empty_p = 0;\n+\t      CLASSTYPE_EMPTY_P (t) = 0;\n \t      /* The class is not even nearly empty.  */\n \t      CLASSTYPE_NEARLY_EMPTY_P (t) = 0;\n \t    }\n@@ -3821,8 +3813,7 @@ layout_empty_base (binfo, eoc, offsets, t)\n }\n \n /* Layout the the base given by BINFO in the class indicated by RLI.\n-   If the new object is non-empty, and EMPTY_P is non-NULL, clear\n-   *EMPTY_P.  *BASE_ALIGN is a running maximum of the alignments of\n+   *BASE_ALIGN is a running maximum of the alignments of\n    any base class.  OFFSETS gives the location of empty base\n    subobjects.  T is the most derived type.  Return nonzero if the new\n    object cannot be nearly-empty.  A new FIELD_DECL is inserted at\n@@ -3831,7 +3822,7 @@ layout_empty_base (binfo, eoc, offsets, t)\n    Returns the location at which the next field should be inserted.  */\n \n static tree *\n-build_base_field (record_layout_info rli, tree binfo, int *empty_p, \n+build_base_field (record_layout_info rli, tree binfo,\n \t\t  splay_tree offsets, tree *next_field)\n {\n   tree t = rli->t;\n@@ -3849,8 +3840,7 @@ build_base_field (record_layout_info rli, tree binfo, int *empty_p,\n \n       /* The containing class is non-empty because it has a non-empty\n \t base class.  */\n-      if (empty_p)\n-\t*empty_p = 0;\n+      CLASSTYPE_EMPTY_P (t) = 0;\n       \n       /* Create the FIELD_DECL.  */\n       decl = build_decl (FIELD_DECL, NULL_TREE, CLASSTYPE_AS_BASE (basetype));\n@@ -3888,6 +3878,11 @@ build_base_field (record_layout_info rli, tree binfo, int *empty_p,\n \t create CONSTRUCTORs for the class by iterating over the\n \t FIELD_DECLs, and the back end does not handle overlapping\n \t FIELD_DECLs.  */\n+\n+      /* An empty virtual base causes a class to be non-empty\n+\t -- but in that case we do not need to clear CLASSTYPE_EMPTY_P\n+\t here because that was already done when the virtual table\n+\t pointer was created.  */\n     }\n \n   /* Record the offsets of BINFO and its base subobjects.  */\n@@ -3906,7 +3901,7 @@ build_base_field (record_layout_info rli, tree binfo, int *empty_p,\n    *NEXT_FIELD.  */\n \n static void\n-build_base_fields (record_layout_info rli, int *empty_p, \n+build_base_fields (record_layout_info rli,\n \t\t   splay_tree offsets, tree *next_field)\n {\n   /* Chain to hold all the new FIELD_DECLs which stand in for base class\n@@ -3918,7 +3913,7 @@ build_base_fields (record_layout_info rli, int *empty_p,\n   /* The primary base class is always allocated first.  */\n   if (CLASSTYPE_HAS_PRIMARY_BASE_P (t))\n     next_field = build_base_field (rli, CLASSTYPE_PRIMARY_BINFO (t),\n-\t\t\t\t   empty_p, offsets, next_field);\n+\t\t\t\t   offsets, next_field);\n \n   /* Now allocate the rest of the bases.  */\n   for (i = 0; i < n_baseclasses; ++i)\n@@ -3939,7 +3934,7 @@ build_base_fields (record_layout_info rli, int *empty_p,\n \t  && !BINFO_PRIMARY_P (base_binfo))\n \tcontinue;\n \n-      next_field = build_base_field (rli, base_binfo, empty_p,\n+      next_field = build_base_field (rli, base_binfo,\n \t\t\t\t     offsets, next_field);\n     }\n }\n@@ -4330,9 +4325,7 @@ type_requires_array_cookie (type)\n    level: i.e., independently of the ABI in use.  */\n \n static void\n-check_bases_and_members (t, empty_p)\n-     tree t;\n-     int *empty_p;\n+check_bases_and_members (tree t)\n {\n   /* Nonzero if we are not allowed to generate a default constructor\n      for this case.  */\n@@ -4351,16 +4344,12 @@ check_bases_and_members (t, empty_p)\n   cant_have_const_ctor = 0;\n   no_const_asn_ref = 0;\n \n-  /* Assume that the class is nearly empty; we'll clear this flag if\n-     it turns out not to be nearly empty.  */\n-  CLASSTYPE_NEARLY_EMPTY_P (t) = 1;\n-\n   /* Check all the base-classes.  */\n   check_bases (t, &cant_have_default_ctor, &cant_have_const_ctor,\n \t       &no_const_asn_ref);\n \n   /* Check all the data member declarations.  */\n-  check_field_decls (t, &access_decls, empty_p,\n+  check_field_decls (t, &access_decls,\n \t\t     &cant_have_default_ctor,\n \t\t     &cant_have_const_ctor,\n \t\t     &no_const_asn_ref);\n@@ -4423,9 +4412,8 @@ check_bases_and_members (t, empty_p)\n    on VIRTUALS_P.  */\n \n static tree\n-create_vtable_ptr (t, empty_p, virtuals_p)\n+create_vtable_ptr (t, virtuals_p)\n      tree t;\n-     int *empty_p;\n      tree *virtuals_p;\n {\n   tree fn;\n@@ -4483,7 +4471,7 @@ create_vtable_ptr (t, empty_p, virtuals_p)\n       TYPE_VFIELD (t) = field;\n       \n       /* This class is non-empty.  */\n-      *empty_p = 0;\n+      CLASSTYPE_EMPTY_P (t) = 0;\n \n       if (CLASSTYPE_N_BASECLASSES (t))\n \t/* If there were any baseclasses, they can't possibly be at\n@@ -4688,7 +4676,7 @@ layout_virtual_bases (record_layout_info rli, splay_tree offsets)\n \n \t  /* This virtual base is not a primary base of any class in the\n \t     hierarchy, so we have to add space for it.  */\n-\t  next_field = build_base_field (rli, vbase, /*empty_p=*/NULL, \n+\t  next_field = build_base_field (rli, vbase,\n \t\t\t\t\t offsets, next_field);\n \n \t  /* If the first virtual base might have been placed at a\n@@ -4843,11 +4831,7 @@ include_empty_classes (record_layout_info rli)\n    pointer.  Accumulate declared virtual functions on VIRTUALS_P.  */\n \n static void\n-layout_class_type (t, empty_p, vfuns_p, virtuals_p)\n-     tree t;\n-     int *empty_p;\n-     int *vfuns_p;\n-     tree *virtuals_p;\n+layout_class_type (tree t, int *vfuns_p, tree *virtuals_p)\n {\n   tree non_static_data_members;\n   tree field;\n@@ -4874,7 +4858,7 @@ layout_class_type (t, empty_p, vfuns_p, virtuals_p)\n   determine_primary_base (t, vfuns_p);\n \n   /* Create a pointer to our virtual function table.  */\n-  vptr = create_vtable_ptr (t, empty_p, virtuals_p);\n+  vptr = create_vtable_ptr (t, virtuals_p);\n \n   /* The vptr is always the first thing in the class.  */\n   if (vptr)\n@@ -4890,7 +4874,7 @@ layout_class_type (t, empty_p, vfuns_p, virtuals_p)\n   /* Build FIELD_DECLs for all of the non-virtual base-types.  */\n   empty_base_offsets = splay_tree_new (splay_tree_compare_integer_csts, \n \t\t\t\t       NULL, NULL);\n-  build_base_fields (rli, empty_p, empty_base_offsets, next_field);\n+  build_base_fields (rli, empty_base_offsets, next_field);\n   \n   /* Layout the non-static data members.  */\n   for (field = non_static_data_members; field; field = TREE_CHAIN (field))\n@@ -5028,13 +5012,27 @@ layout_class_type (t, empty_p, vfuns_p, virtuals_p)\n   /* Create the version of T used for virtual bases.  We do not use\n      make_aggr_type for this version; this is an artificial type.  For\n      a POD type, we just reuse T.  */\n-  if (CLASSTYPE_NON_POD_P (t) || *empty_p)\n+  if (CLASSTYPE_NON_POD_P (t) || CLASSTYPE_EMPTY_P (t))\n     {\n       base_t = make_node (TREE_CODE (t));\n       \n-      /* Set the size and alignment for the new type.  */\n-      TYPE_SIZE (base_t) = rli_size_so_far (rli);\n-      TYPE_SIZE_UNIT (base_t) = rli_size_unit_so_far (rli);\n+      /* Set the size and alignment for the new type.  In G++ 3.2, all\n+\t empty classes were considered to have size zero when used as\n+\t base classes.  */\n+      if (!abi_version_at_least (2) && CLASSTYPE_EMPTY_P (t))\n+\t{\n+\t  TYPE_SIZE (base_t) = bitsize_zero_node;\n+\t  TYPE_SIZE_UNIT (base_t) = size_zero_node;\n+\t  if (warn_abi && !integer_zerop (rli_size_unit_so_far (rli)))\n+\t    warning (\"layout of classes derived from empty class `%T' \"\n+\t\t     \"may change in a future version of GCC\",\n+\t\t     t);\n+\t}\n+      else\n+\t{\n+\t  TYPE_SIZE (base_t) = rli_size_so_far (rli);\n+\t  TYPE_SIZE_UNIT (base_t) = rli_size_unit_so_far (rli);\n+\t}\n       TYPE_ALIGN (base_t) = rli->record_align;\n       TYPE_USER_ALIGN (base_t) = TYPE_USER_ALIGN (t);\n \n@@ -5075,7 +5073,7 @@ layout_class_type (t, empty_p, vfuns_p, virtuals_p)\n   include_empty_classes(rli);\n \n   /* Make sure not to create any structures with zero size.  */\n-  if (integer_zerop (rli_size_unit_so_far (rli)) && *empty_p)\n+  if (integer_zerop (rli_size_unit_so_far (rli)) && CLASSTYPE_EMPTY_P (t))\n     place_field (rli, \n \t\t build_decl (FIELD_DECL, NULL_TREE, char_type_node));\n \n@@ -5126,7 +5124,6 @@ finish_struct_1 (t)\n   tree virtuals = NULL_TREE;\n   int n_fields = 0;\n   tree vfield;\n-  int empty = 1;\n \n   if (COMPLETE_TYPE_P (t))\n     {\n@@ -5148,12 +5145,17 @@ finish_struct_1 (t)\n \n   fixup_inline_methods (t);\n   \n+  /* Assume that the class is both empty and nearly empty; we'll clear\n+     these flag if necessary.  */\n+  CLASSTYPE_EMPTY_P (t) = 1;\n+  CLASSTYPE_NEARLY_EMPTY_P (t) = 1;\n+\n   /* Do end-of-class semantic processing: checking the validity of the\n      bases and members and add implicitly generated methods.  */\n-  check_bases_and_members (t, &empty);\n+  check_bases_and_members (t);\n \n   /* Layout the class itself.  */\n-  layout_class_type (t, &empty, &vfuns, &virtuals);\n+  layout_class_type (t, &vfuns, &virtuals);\n \n   /* Make sure that we get our own copy of the vfield FIELD_DECL.  */\n   vfield = TYPE_VFIELD (t);\n@@ -6437,7 +6439,12 @@ is_empty_class (type)\n   if (! IS_AGGR_TYPE (type))\n     return 0;\n \n-  return integer_zerop (CLASSTYPE_SIZE (type));\n+  /* In G++ 3.2, whether or not a class was empty was determined by\n+     looking at its size.  */\n+  if (abi_version_at_least (2))\n+    return CLASSTYPE_EMPTY_P (type);\n+  else\n+    return integer_zerop (CLASSTYPE_SIZE (type));\n }\n \n /* Returns true if TYPE contains an empty class.  */"}, {"sha": "c834440616228537057385b9d14732108810f441", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58731fd132e25cb603d1e1feaaace2cb91250c12/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58731fd132e25cb603d1e1feaaace2cb91250c12/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=58731fd132e25cb603d1e1feaaace2cb91250c12", "patch": "@@ -1134,6 +1134,7 @@ struct lang_type_class GTY(())\n \n   unsigned anon_aggr : 1;\n   unsigned non_zero_init : 1;\n+  unsigned empty_p : 1;\n \n   /* When adding a flag here, consider whether or not it ought to\n      apply to a template instance if it applies to the template.  If\n@@ -1142,7 +1143,7 @@ struct lang_type_class GTY(())\n   /* There are some bits left to fill out a 32-bit word.  Keep track\n      of this by updating the size of this bitfield whenever you add or\n      remove a flag.  */\n-  unsigned dummy : 6;\n+  unsigned dummy : 5;\n \n   int vsize;\n \n@@ -1447,6 +1448,10 @@ struct lang_type GTY(())\n #define CLASSTYPE_NON_ZERO_INIT_P(NODE) \\\n   (LANG_TYPE_CLASS_CHECK (NODE)->non_zero_init)\n \n+/* Nonzero if this class is \"empty\" in the sense of the C++ ABI.  */\n+#define CLASSTYPE_EMPTY_P(NODE) \\\n+  (LANG_TYPE_CLASS_CHECK (NODE)->empty_p)\n+\n /* Nonzero if this class is \"nearly empty\", i.e., contains only a\n    virtual function table pointer.  */\n #define CLASSTYPE_NEARLY_EMPTY_P(NODE) \\"}, {"sha": "20de7631d65daf1191bc2e81298097966dbc9bcf", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58731fd132e25cb603d1e1feaaace2cb91250c12/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58731fd132e25cb603d1e1feaaace2cb91250c12/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=58731fd132e25cb603d1e1feaaace2cb91250c12", "patch": "@@ -1,3 +1,7 @@\n+2002-10-14  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* g++.dg/abi/empty8.C: New test.\n+\n 2002-10-15  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* g++.dg/init/ctor1.C: New test."}, {"sha": "a5287b15fa0b3591768ce3a4ac9c49b8eb4d02e1", "filename": "gcc/testsuite/g++.dg/abi/empty8.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58731fd132e25cb603d1e1feaaace2cb91250c12/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fempty8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58731fd132e25cb603d1e1feaaace2cb91250c12/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fempty8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fempty8.C?ref=58731fd132e25cb603d1e1feaaace2cb91250c12", "patch": "@@ -0,0 +1,14 @@\n+// { dg-do run }\n+// { dg-options \"-fabi-version=0\" }\n+\n+struct E1 {};\n+struct E2 : public E1 {};\n+struct S1 { int i; };\n+struct S2 : public S1, E2 {};\n+\n+S2 s2;\n+\n+int main () {\n+  if ((char *)(E2*) &s2 != (char *)&s2)\n+    return 1;\n+}"}]}