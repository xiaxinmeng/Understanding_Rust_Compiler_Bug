{"sha": "7f54a8510be3f690e7d90c52d57f7d0a9dd8dca8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Y1NGE4NTEwYmUzZjY5MGU3ZDkwYzUyZDU3ZjdkMGE5ZGQ4ZGNhOA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2001-07-24T08:56:12Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2001-07-24T08:56:12Z"}, "message": "Simplify rtti, now we've only one ABI.\n\n\t* cp-tree.h (cp_tree_index): Remove CPTI_TINFO_DECL_ID,\n\tCPTI_TINFO_VAR_ID.\n\t(tinfo_decl_id, tinfo_var_id): Remove.\n\t(get_typeid_1): Remove.\n\t* rtti.c\n\t(init_rtti_processing): Remove tinfo_decl_id & tinfo_var_id.\n\t(typeid_ok_p): New function.\n\t(build_type_id): Call typeid_ok_p. Don't call tinfo_from_decl.\n\t(get_tinfo_decl): Remove old abi documentation.\n\t(tinfo_from_decl): Remove.\n\t(get_type_id): Call typeid_ok_p. Absorb get_typeid_1.\n\t(get_typeid_1): Remove.\n\t(get_base_offset): Remove.\n\t(synthesize_tinfo_var): Absorb get_base_offset.\n\t(create_real_tinfo_var): Don't use tinfo_decl_id.\n\nFrom-SVN: r44291", "tree": {"sha": "ee470380ada8005d8b6a7b87fcf4811521bc9c01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ee470380ada8005d8b6a7b87fcf4811521bc9c01"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7f54a8510be3f690e7d90c52d57f7d0a9dd8dca8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f54a8510be3f690e7d90c52d57f7d0a9dd8dca8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f54a8510be3f690e7d90c52d57f7d0a9dd8dca8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f54a8510be3f690e7d90c52d57f7d0a9dd8dca8/comments", "author": null, "committer": null, "parents": [{"sha": "8f54d2fffdddf8dab5a7820d284c4aeaa0e837b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f54d2fffdddf8dab5a7820d284c4aeaa0e837b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f54d2fffdddf8dab5a7820d284c4aeaa0e837b2"}], "stats": {"total": 145, "additions": 56, "deletions": 89}, "files": [{"sha": "2933ee3cf6cff0406a53df530bc617b33377c11f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f54a8510be3f690e7d90c52d57f7d0a9dd8dca8/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f54a8510be3f690e7d90c52d57f7d0a9dd8dca8/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7f54a8510be3f690e7d90c52d57f7d0a9dd8dca8", "patch": "@@ -1,3 +1,22 @@\n+2001-07-24  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tSimplify rtti, now we've only one ABI.\n+\t* cp-tree.h (cp_tree_index): Remove CPTI_TINFO_DECL_ID,\n+\tCPTI_TINFO_VAR_ID.\n+\t(tinfo_decl_id, tinfo_var_id): Remove.\n+\t(get_typeid_1): Remove.\n+\t* rtti.c\n+\t(init_rtti_processing): Remove tinfo_decl_id & tinfo_var_id.\n+\t(typeid_ok_p): New function.\n+\t(build_type_id): Call typeid_ok_p. Don't call tinfo_from_decl.\n+\t(get_tinfo_decl): Remove old abi documentation.\n+\t(tinfo_from_decl): Remove.\n+\t(get_type_id): Call typeid_ok_p. Absorb get_typeid_1.\n+\t(get_typeid_1): Remove.\n+\t(get_base_offset): Remove.\n+\t(synthesize_tinfo_var): Absorb get_base_offset.\n+\t(create_real_tinfo_var): Don't use tinfo_decl_id.\n+\n 2001-07-23  Graham Stott  <grahams@redhat.com>\n \n \t* cp/class.c (type_requires_array_cookie): Fix use of uninitialised"}, {"sha": "4809acab51b5f34583b5b9b8a7f1e10374780faa", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f54a8510be3f690e7d90c52d57f7d0a9dd8dca8/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f54a8510be3f690e7d90c52d57f7d0a9dd8dca8/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=7f54a8510be3f690e7d90c52d57f7d0a9dd8dca8", "patch": "@@ -529,9 +529,7 @@ enum cp_tree_index\n     CPTI_FAKE_STD,\n     CPTI_ABI,\n     CPTI_TYPE_INFO_TYPE,\n-    CPTI_TINFO_DECL_ID,\n     CPTI_TINFO_DECL_TYPE,\n-    CPTI_TINFO_VAR_ID,\n     CPTI_ABORT_FNDECL,\n     CPTI_GLOBAL_DELETE_FNDECL,\n     CPTI_AGGR_TAG,\n@@ -625,9 +623,7 @@ extern tree cp_global_trees[CPTI_MAX];\n #define fake_std_node                   cp_global_trees[CPTI_FAKE_STD]\n #define abi_node                        cp_global_trees[CPTI_ABI]\n #define type_info_type_node\t\tcp_global_trees[CPTI_TYPE_INFO_TYPE]\n-#define tinfo_decl_id\t\t\tcp_global_trees[CPTI_TINFO_DECL_ID]\n #define tinfo_decl_type\t\t\tcp_global_trees[CPTI_TINFO_DECL_TYPE]\n-#define tinfo_var_id                    cp_global_trees[CPTI_TINFO_VAR_ID]\n #define abort_fndecl\t\t\tcp_global_trees[CPTI_ABORT_FNDECL]\n #define global_delete_fndecl\t\tcp_global_trees[CPTI_GLOBAL_DELETE_FNDECL]\n #define current_aggr\t\t\tcp_global_trees[CPTI_AGGR_TAG]\n@@ -4027,7 +4023,6 @@ extern void init_rtti_processing\t\tPARAMS((void));\n extern tree build_typeid\t\t\tPARAMS((tree));\n extern tree get_tinfo_decl                      PARAMS((tree));\n extern tree get_typeid\t\t\t\tPARAMS((tree));\n-extern tree get_typeid_1\t\t\tPARAMS((tree));\n extern tree build_dynamic_cast\t\t\tPARAMS((tree, tree));\n extern void emit_support_tinfos                 PARAMS((void));\n extern int tinfo_decl_p                         PARAMS((tree, void *));"}, {"sha": "20e238fb5a6429bc53c503c8b3f667c512e35896", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 37, "deletions": 84, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f54a8510be3f690e7d90c52d57f7d0a9dd8dca8/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f54a8510be3f690e7d90c52d57f7d0a9dd8dca8/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=7f54a8510be3f690e7d90c52d57f7d0a9dd8dca8", "patch": "@@ -45,12 +45,11 @@ static tree build_headof_sub PARAMS((tree));\n static tree build_headof PARAMS((tree));\n static tree ifnonnull PARAMS((tree, tree));\n static tree tinfo_name PARAMS((tree));\n-static tree get_base_offset PARAMS((tree, tree));\n static tree build_dynamic_cast_1 PARAMS((tree, tree));\n static tree throw_bad_cast PARAMS((void));\n static tree throw_bad_typeid PARAMS((void));\n static tree get_tinfo_decl_dynamic PARAMS((tree));\n-static tree tinfo_from_decl PARAMS((tree));\n+static bool typeid_ok_p PARAMS ((void));\n static int qualifier_flags PARAMS((tree));\n static int target_incomplete_p PARAMS((tree));\n static tree tinfo_base_init PARAMS((tree, tree));\n@@ -79,9 +78,6 @@ init_rtti_processing ()\n     (class_type_node, get_identifier (\"type_info\"), 1);\n   if (flag_honor_std)\n     pop_namespace ();\n-  /* FIXME: These identifier prefixes are not set in stone yet.  */\n-  tinfo_decl_id = get_identifier (\"__ti\");\n-  tinfo_var_id = get_identifier (\"__tn\");\n   tinfo_decl_type = \n     build_qualified_type (type_info_type_node, TYPE_QUAL_CONST);\n }\n@@ -231,25 +227,34 @@ get_tinfo_decl_dynamic (exp)\n   return build_unary_op (ADDR_EXPR, exp, 0);\n }\n \n-tree\n-build_typeid (exp)\n-     tree exp;\n+static bool\n+typeid_ok_p ()\n {\n-  tree cond = NULL_TREE;\n-  int nonnull = 0;\n-\n   if (! flag_rtti)\n     {\n       error (\"cannot use typeid with -fno-rtti\");\n-      return error_mark_node;\n+      return false;\n     }\n   \n   if (!COMPLETE_TYPE_P (type_info_type_node))\n     {\n       error (\"must #include <typeinfo> before using typeid\");\n-      return error_mark_node;\n+      return false;\n     }\n   \n+  return true;\n+}\n+\n+tree\n+build_typeid (exp)\n+     tree exp;\n+{\n+  tree cond = NULL_TREE;\n+  int nonnull = 0;\n+\n+  if (exp == error_mark_node || !typeid_ok_p ())\n+    return error_mark_node;\n+\n   if (processing_template_decl)\n     return build_min_nt (TYPEID_EXPR, exp);\n \n@@ -268,7 +273,7 @@ build_typeid (exp)\n   if (exp == error_mark_node)\n     return error_mark_node;\n \n-  exp = tinfo_from_decl (exp);\n+  exp = build_indirect_ref (exp, NULL);\n \n   if (cond)\n     {\n@@ -293,13 +298,9 @@ tinfo_name (type)\n   return name_string;\n }\n \n-/* Returns a decl for a function or variable which can be used to obtain a\n-   type_info object for TYPE.  The old-abi uses functions, the new-abi\n-   uses the type_info object directly.  You can take the address of the\n-   returned decl, to save the decl.  To use the decl call\n-   tinfo_from_decl.  You must arrange that the decl is mark_used, if\n-   actually use it --- decls in vtables are only used if the vtable is\n-   output.  */ \n+/* Returns a decl for the type_info variable for TYPE.  You must\n+   arrange that the decl is mark_used, if actually use it --- decls in\n+   vtables are only used if the vtable is output.  */ \n \n tree\n get_tinfo_decl (type)\n@@ -356,48 +357,14 @@ get_tinfo_decl (type)\n   return d;\n }\n \n-/* Given an expr produced by get_tinfo_decl, return an expr which\n-   produces a reference to the type_info object.  */\n-\n-static tree\n-tinfo_from_decl (expr)\n-     tree expr;\n-{\n-  tree t;\n-  \n-  if (TREE_CODE (TREE_TYPE (expr)) == POINTER_TYPE)\n-    t = build_indirect_ref (expr, NULL);\n-  else\n-    t = expr;\n-  \n-  return t;\n-}\n-\n-tree\n-get_typeid_1 (type)\n-     tree type;\n-{\n-  tree t;\n-\n-  t = get_tinfo_decl (type);\n-  t = tinfo_from_decl (t);\n-  return convert_from_reference (t);\n-}\n-  \n /* Return the type_info object for TYPE.  */\n \n tree\n get_typeid (type)\n      tree type;\n {\n-  if (type == error_mark_node)\n+  if (type == error_mark_node || !typeid_ok_p ())\n     return error_mark_node;\n-\n-  if (!COMPLETE_TYPE_P (type_info_type_node))\n-    {\n-      error (\"must #include <typeinfo> before using typeid\");\n-      return error_mark_node;\n-    }\n   \n   if (processing_template_decl)\n     return build_min_nt (TYPEID_EXPR, type);\n@@ -418,7 +385,7 @@ get_typeid (type)\n   if (!type)\n     return error_mark_node;\n \n-  return get_typeid_1 (type);\n+  return get_tinfo_decl (type);\n }\n \n /* Check whether TEST is null before returning RESULT.  If TEST is used in\n@@ -434,25 +401,6 @@ ifnonnull (test, result)\n \t\tresult);\n }\n \n-/* Generate the constant expression describing where direct base BINFO\n-   appears within the PARENT. How to interpret this expression depends on\n-   details of the ABI, which the runtime must be aware of.  */\n-\n-static tree\n-get_base_offset (binfo, parent)\n-     tree binfo;\n-     tree parent;\n-{\n-  if (! TREE_VIA_VIRTUAL (binfo))\n-    return BINFO_OFFSET (binfo);\n-  else\n-    /* We store the vtable offset at which the virtual base offset can\n-       be found.  */\n-    return convert (sizetype,\n-\t\t    BINFO_VPTR_FIELD (binfo_for_vbase (BINFO_TYPE (binfo),\n-\t\t\t\t\t\t       parent)));\n-}\n-\n /* Execute a dynamic cast, as described in section 5.2.6 of the 9/93 working\n    paper.  */\n \n@@ -1110,13 +1058,21 @@ synthesize_tinfo_var (target_type, real_name)\n               tree tinfo;\n               tree offset;\n               \n-              if (TREE_VIA_VIRTUAL (base_binfo))\n-                flags |= 1;\n               if (TREE_PUBLIC (base_binfo))\n                 flags |= 2;\n               tinfo = get_tinfo_decl (BINFO_TYPE (base_binfo));\n               tinfo = build_unary_op (ADDR_EXPR, tinfo, 0);\n-              offset = get_base_offset (base_binfo, target_type);\n+\t      if (TREE_VIA_VIRTUAL (base_binfo))\n+\t\t{\n+\t\t   /* We store the vtable offset at which the virtual\n+       \t\t      base offset can be found.  */\n+\t\t  offset = BINFO_VPTR_FIELD (binfo_for_vbase (BINFO_TYPE (base_binfo),\n+\t\t\t\t\t\t\t      target_type));\n+\t\t  offset = convert (sizetype, offset);\n+\t\t  flags |= 1;\n+\t\t}\n+\t      else\n+\t\toffset = BINFO_OFFSET (base_binfo);\n               \n               /* is it a single public inheritance? */\n               if (is_simple && flags == 2 && integer_zerop (offset))\n@@ -1170,7 +1126,6 @@ synthesize_tinfo_var (target_type, real_name)\n       my_friendly_abort (20000117);\n     }\n   \n-  \n   return create_real_tinfo_var (target_type,\n \t\t\t\treal_name, TINFO_PSEUDO_TYPE (var_type),\n                                 var_init, non_public);\n@@ -1192,9 +1147,7 @@ create_real_tinfo_var (target_type, name, type, init, non_public)\n   tree hidden_name;\n   char hidden[30];\n   \n-  sprintf (hidden, \"%.*s_%d\",\n-           IDENTIFIER_LENGTH (tinfo_decl_id), IDENTIFIER_POINTER (tinfo_decl_id),\n-           count++);\n+  sprintf (hidden, \"__ti_%d\", count++);\n   hidden_name = get_identifier (hidden);\n   \n   decl = build_lang_decl (VAR_DECL, hidden_name,\n@@ -1433,7 +1386,7 @@ create_tinfo_types ()\n /* Emit the type_info descriptors which are guaranteed to be in the runtime\n    support.  Generating them here guarantees consistency with the other\n    structures.  We use the following heuristic to determine when the runtime\n-   is being generated.  If std::__fundamental_type_info is defined, and it's\n+   is being generated.  If std::__fundamental_type_info is defined, and its\n    destructor is defined, then the runtime is being built.  */\n \n void"}]}