{"sha": "2778a719bebf7a32c34638cb39e9697c93ed484a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjc3OGE3MTliZWJmN2EzMmMzNDYzOGNiMzllOTY5N2M5M2VkNDg0YQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-06-13T10:10:05Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-06-13T10:10:05Z"}, "message": "tree-vectorizer.h (vect_loop_vectorized_call): Declare.\n\n2019-06-13  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (vect_loop_vectorized_call): Declare.\n\t* tree-vectorizer.c (vect_loop_vectorized_call): Export and\n\talso return the condition stmt.\n\t* tree-vect-loop-manip.c (vect_loop_versioning): Compute outermost\n\tloop we can version and version that, reusing the loop version\n\tcreated by if-conversion instead of versioning again.\n\n\t* gcc.dg/vect/vect-version-1.c: New testcase.\n\t* gcc.dg/vect/vect-version-2.c: Likewise.\n\nFrom-SVN: r272239", "tree": {"sha": "b0fd6841c2d5a59a0187fd41497e3a2c69e4a2a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0fd6841c2d5a59a0187fd41497e3a2c69e4a2a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2778a719bebf7a32c34638cb39e9697c93ed484a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2778a719bebf7a32c34638cb39e9697c93ed484a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2778a719bebf7a32c34638cb39e9697c93ed484a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2778a719bebf7a32c34638cb39e9697c93ed484a/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fa8ba8b84cf4f1caf581b09d808d6e57b1ff2843", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa8ba8b84cf4f1caf581b09d808d6e57b1ff2843", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa8ba8b84cf4f1caf581b09d808d6e57b1ff2843"}], "stats": {"total": 268, "additions": 188, "deletions": 80}, "files": [{"sha": "7fe06d26f49b49d0a1a59f902e762d89f4d7dce8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2778a719bebf7a32c34638cb39e9697c93ed484a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2778a719bebf7a32c34638cb39e9697c93ed484a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2778a719bebf7a32c34638cb39e9697c93ed484a", "patch": "@@ -1,3 +1,12 @@\n+2019-06-13  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vectorizer.h (vect_loop_vectorized_call): Declare.\n+\t* tree-vectorizer.c (vect_loop_vectorized_call): Export and\n+\talso return the condition stmt.\n+\t* tree-vect-loop-manip.c (vect_loop_versioning): Compute outermost\n+\tloop we can version and version that, reusing the loop version\n+\tcreated by if-conversion instead of versioning again.\n+\n 2019-06-13  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* gimple-loop-versioning.cc (prune_loop_conditions): Use"}, {"sha": "ac0290971eb6929319fc90681a4559433889be44", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2778a719bebf7a32c34638cb39e9697c93ed484a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2778a719bebf7a32c34638cb39e9697c93ed484a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2778a719bebf7a32c34638cb39e9697c93ed484a", "patch": "@@ -1,3 +1,8 @@\n+2019-06-13  Richard Biener  <rguenther@suse.de>\n+\n+\t* gcc.dg/vect/vect-version-1.c: New testcase.\n+\t* gcc.dg/vect/vect-version-2.c: Likewise.\n+\n 2019-06-13  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* g++.dg/diagnostic/variably-modified-type-1.C: New."}, {"sha": "4540a11b36ca8b78192db000dbe1c88ebfdab4a8", "filename": "gcc/testsuite/gcc.dg/vect/vect-version-1.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2778a719bebf7a32c34638cb39e9697c93ed484a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-version-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2778a719bebf7a32c34638cb39e9697c93ed484a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-version-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-version-1.c?ref=2778a719bebf7a32c34638cb39e9697c93ed484a", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_double } */\n+/* { dg-require-effective-target vect_condition } */\n+\n+void foo (double *x, double *y, int m, int n, int o, int p)\n+{\n+  for (int i = 0; i < m; ++i)\n+    for (int j = 0; j < n; ++j)\n+      for (int k = 0; k < o; ++k)\n+\tfor (int l = 0; l < p; ++l)\n+\t  {\n+\t    double tem = x[l] + y[l];\n+\t    if (tem != 0.)\n+\t      y[l] = x[l];\n+\t    else\n+\t      y[l] = 0.;\n+\t  }\n+}\n+\n+/* { dg-final { scan-tree-dump \"applying loop versioning to outer loop 1\" \"vect\" } } */"}, {"sha": "0ea39e318018d4b1658fceceed273ee693a05c30", "filename": "gcc/testsuite/gcc.dg/vect/vect-version-2.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2778a719bebf7a32c34638cb39e9697c93ed484a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-version-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2778a719bebf7a32c34638cb39e9697c93ed484a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-version-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-version-2.c?ref=2778a719bebf7a32c34638cb39e9697c93ed484a", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_double } */\n+/* { dg-require-effective-target vect_condition } */\n+\n+void foo (double *x, double *y, int m, int n, int o, int p)\n+{\n+  for (int i = 0; i < m; ++i)\n+    for (int j = 0; j < n; ++j)\n+      for (int k = 0; k < o; ++k)\n+\tfor (int l = 0; l < k; ++l)\n+\t  {\n+\t    double tem = x[l] + y[l];\n+\t    if (tem != 0.)\n+\t      y[l] = x[l];\n+\t    else\n+\t      y[l] = 0.;\n+\t  }\n+}\n+\n+/* { dg-final { scan-tree-dump \"reusing loop version created by if conversion\" \"vect\" } } */"}, {"sha": "ee0d92a625a5e6c8289126354a525c2b16aa65e5", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 128, "deletions": 78, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2778a719bebf7a32c34638cb39e9697c93ed484a/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2778a719bebf7a32c34638cb39e9697c93ed484a/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=2778a719bebf7a32c34638cb39e9697c93ed484a", "patch": "@@ -3016,7 +3016,8 @@ vect_loop_versioning (loop_vec_info loop_vinfo,\n     vect_create_cond_for_niters_checks (loop_vinfo, &cond_expr);\n \n   if (cond_expr)\n-    cond_expr = force_gimple_operand_1 (cond_expr, &cond_expr_stmt_list,\n+    cond_expr = force_gimple_operand_1 (unshare_expr (cond_expr),\n+\t\t\t\t\t&cond_expr_stmt_list,\n \t\t\t\t\tis_gimple_condexpr, NULL_TREE);\n \n   if (version_align)\n@@ -3060,45 +3061,136 @@ vect_loop_versioning (loop_vec_info loop_vinfo,\n \t\t\t\t      is_gimple_condexpr, NULL_TREE);\n   gimple_seq_add_seq (&cond_expr_stmt_list, gimplify_stmt_list);\n \n-  initialize_original_copy_tables ();\n-  if (scalar_loop)\n+  /* Compute the outermost loop cond_expr and cond_expr_stmt_list are\n+     invariant in.  */\n+  struct loop *outermost = outermost_invariant_loop_for_expr (loop, cond_expr);\n+  for (gimple_stmt_iterator gsi = gsi_start (cond_expr_stmt_list);\n+       !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      edge scalar_e;\n-      basic_block preheader, scalar_preheader;\n+      gimple *stmt = gsi_stmt (gsi);\n+      update_stmt (stmt);\n+      ssa_op_iter iter;\n+      use_operand_p use_p;\n+      basic_block def_bb;\n+      FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE)\n+\tif ((def_bb = gimple_bb (SSA_NAME_DEF_STMT (USE_FROM_PTR (use_p))))\n+\t    && flow_bb_inside_loop_p (outermost, def_bb))\n+\t  outermost = superloop_at_depth (loop, bb_loop_depth (def_bb) + 1);\n+    }\n \n-      /* We don't want to scale SCALAR_LOOP's frequencies, we need to\n-\t scale LOOP's frequencies instead.  */\n-      nloop = loop_version (scalar_loop, cond_expr, &condition_bb,\n-\t\t\t    prob, prob.invert (), prob, prob.invert (), true);\n-      scale_loop_frequencies (loop, prob);\n-      /* CONDITION_BB was created above SCALAR_LOOP's preheader,\n-\t while we need to move it above LOOP's preheader.  */\n-      e = loop_preheader_edge (loop);\n-      scalar_e = loop_preheader_edge (scalar_loop);\n-      /* The vector loop preheader might not be empty, since new\n-\t invariants could have been created while analyzing the loop.  */\n-      gcc_assert (single_pred_p (e->src));\n-      gcc_assert (empty_block_p (scalar_e->src)\n-\t\t  && single_pred_p (scalar_e->src));\n-      gcc_assert (single_pred_p (condition_bb));\n-      preheader = e->src;\n-      scalar_preheader = scalar_e->src;\n-      scalar_e = find_edge (condition_bb, scalar_preheader);\n-      e = single_pred_edge (preheader);\n-      redirect_edge_and_branch_force (single_pred_edge (condition_bb),\n-\t\t\t\t      scalar_preheader);\n-      redirect_edge_and_branch_force (scalar_e, preheader);\n-      redirect_edge_and_branch_force (e, condition_bb);\n-      set_immediate_dominator (CDI_DOMINATORS, condition_bb,\n-\t\t\t       single_pred (condition_bb));\n-      set_immediate_dominator (CDI_DOMINATORS, scalar_preheader,\n-\t\t\t       single_pred (scalar_preheader));\n-      set_immediate_dominator (CDI_DOMINATORS, preheader,\n-\t\t\t       condition_bb);\n+  /* Search for the outermost loop we can version.  Avoid versioning of\n+     non-perfect nests but allow if-conversion versioned loops inside.  */\n+  struct loop *loop_to_version = loop;\n+  if (flow_loop_nested_p (outermost, loop))\n+    { \n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"trying to apply versioning to outer loop %d\\n\",\n+\t\t\t outermost->num);\n+      if (outermost->num == 0)\n+\toutermost = superloop_at_depth (loop, 1);\n+      /* And avoid applying versioning on non-perfect nests.  */\n+      while (loop_to_version != outermost\n+\t     && single_exit (loop_outer (loop_to_version))\n+\t     && (!loop_outer (loop_to_version)->inner->next\n+\t\t || vect_loop_vectorized_call (loop_to_version))\n+\t     && (!loop_outer (loop_to_version)->inner->next\n+\t\t || !loop_outer (loop_to_version)->inner->next->next))\n+\tloop_to_version = loop_outer (loop_to_version);\n+    }\n+\n+  /* Apply versioning.  If there is already a scalar version created by\n+     if-conversion re-use that.  */\n+  gcond *cond;\n+  if (gimple *call = vect_loop_vectorized_call (loop_to_version, &cond))\n+    {\n+      gcc_assert (scalar_loop);\n+      condition_bb = gimple_bb (cond);\n+      gimple_cond_set_condition_from_tree (cond, cond_expr);\n+      update_stmt (cond);\n+\n+      if (cond_expr_stmt_list)\n+\t{\n+\t  cond_exp_gsi = gsi_for_stmt (call);\n+\t  gsi_insert_seq_before (&cond_exp_gsi, cond_expr_stmt_list,\n+\t\t\t\t GSI_SAME_STMT);\n+\t}\n+\n+      /* ???  if-conversion uses profile_probability::always () but\n+         prob below is profile_probability::likely ().  */\n+      nloop = scalar_loop;\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"reusing %sloop version created by if conversion\\n\",\n+\t\t\t loop_to_version != loop ? \"outer \" : \"\");\n     }\n   else\n-    nloop = loop_version (loop, cond_expr, &condition_bb,\n-\t\t\t  prob, prob.invert (), prob, prob.invert (), true);\n+    {\n+      if (loop_to_version != loop\n+\t  && dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"applying loop versioning to outer loop %d\\n\",\n+\t\t\t loop_to_version->num);\n+\n+      initialize_original_copy_tables ();\n+      nloop = loop_version (loop_to_version, cond_expr, &condition_bb,\n+\t\t\t    prob, prob.invert (), prob, prob.invert (), true);\n+      gcc_assert (nloop);\n+      nloop = get_loop_copy (loop);\n+\n+      /* Kill off IFN_LOOP_VECTORIZED_CALL in the copy, nobody will\n+         reap those otherwise;  they also refer to the original\n+\t loops.  */\n+      struct loop *l = loop;\n+      while (gimple *call = vect_loop_vectorized_call (l))\n+\t{\n+\t  call = SSA_NAME_DEF_STMT (get_current_def (gimple_call_lhs (call)));\n+\t  fold_loop_internal_call (call, boolean_false_node);\n+\t  l = loop_outer (l);\n+\t}\n+      free_original_copy_tables ();\n+\n+      if (cond_expr_stmt_list)\n+\t{\n+\t  cond_exp_gsi = gsi_last_bb (condition_bb);\n+\t  gsi_insert_seq_before (&cond_exp_gsi, cond_expr_stmt_list,\n+\t\t\t\t GSI_SAME_STMT);\n+\t}\n+\n+      /* Loop versioning violates an assumption we try to maintain during\n+\t vectorization - that the loop exit block has a single predecessor.\n+\t After versioning, the exit block of both loop versions is the same\n+\t basic block (i.e. it has two predecessors). Just in order to simplify\n+\t following transformations in the vectorizer, we fix this situation\n+\t here by adding a new (empty) block on the exit-edge of the loop,\n+\t with the proper loop-exit phis to maintain loop-closed-form.\n+\t If loop versioning wasn't done from loop, but scalar_loop instead,\n+\t merge_bb will have already just a single successor.  */\n+\n+      merge_bb = single_exit (loop_to_version)->dest;\n+      if (EDGE_COUNT (merge_bb->preds) >= 2)\n+\t{\n+\t  gcc_assert (EDGE_COUNT (merge_bb->preds) >= 2);\n+\t  new_exit_bb = split_edge (single_exit (loop_to_version));\n+\t  new_exit_e = single_exit (loop_to_version);\n+\t  e = EDGE_SUCC (new_exit_bb, 0);\n+\n+\t  for (gsi = gsi_start_phis (merge_bb); !gsi_end_p (gsi);\n+\t       gsi_next (&gsi))\n+\t    {\n+\t      tree new_res;\n+\t      orig_phi = gsi.phi ();\n+\t      new_res = copy_ssa_name (PHI_RESULT (orig_phi));\n+\t      new_phi = create_phi_node (new_res, new_exit_bb);\n+\t      arg = PHI_ARG_DEF_FROM_EDGE (orig_phi, e);\n+\t      add_phi_arg (new_phi, arg, new_exit_e,\n+\t\t\t   gimple_phi_arg_location_from_edge (orig_phi, e));\n+\t      adjust_phi_and_debug_stmts (orig_phi, e, PHI_RESULT (new_phi));\n+\t    }\n+\t}\n+\n+      update_ssa (TODO_update_ssa);\n+    }\n \n   if (version_niter)\n     {\n@@ -3125,48 +3217,6 @@ vect_loop_versioning (loop_vec_info loop_vinfo,\n \t\t\t \"alignment\\n\");\n \n     }\n-  free_original_copy_tables ();\n-\n-  /* Loop versioning violates an assumption we try to maintain during\n-     vectorization - that the loop exit block has a single predecessor.\n-     After versioning, the exit block of both loop versions is the same\n-     basic block (i.e. it has two predecessors). Just in order to simplify\n-     following transformations in the vectorizer, we fix this situation\n-     here by adding a new (empty) block on the exit-edge of the loop,\n-     with the proper loop-exit phis to maintain loop-closed-form.\n-     If loop versioning wasn't done from loop, but scalar_loop instead,\n-     merge_bb will have already just a single successor.  */\n-\n-  merge_bb = single_exit (loop)->dest;\n-  if (scalar_loop == NULL || EDGE_COUNT (merge_bb->preds) >= 2)\n-    {\n-      gcc_assert (EDGE_COUNT (merge_bb->preds) >= 2);\n-      new_exit_bb = split_edge (single_exit (loop));\n-      new_exit_e = single_exit (loop);\n-      e = EDGE_SUCC (new_exit_bb, 0);\n-\n-      for (gsi = gsi_start_phis (merge_bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-\t{\n-\t  tree new_res;\n-\t  orig_phi = gsi.phi ();\n-\t  new_res = copy_ssa_name (PHI_RESULT (orig_phi));\n-\t  new_phi = create_phi_node (new_res, new_exit_bb);\n-\t  arg = PHI_ARG_DEF_FROM_EDGE (orig_phi, e);\n-\t  add_phi_arg (new_phi, arg, new_exit_e,\n-\t\t       gimple_phi_arg_location_from_edge (orig_phi, e));\n-\t  adjust_phi_and_debug_stmts (orig_phi, e, PHI_RESULT (new_phi));\n-\t}\n-    }\n-\n-  /* End loop-exit-fixes after versioning.  */\n-\n-  if (cond_expr_stmt_list)\n-    {\n-      cond_exp_gsi = gsi_last_bb (condition_bb);\n-      gsi_insert_seq_before (&cond_exp_gsi, cond_expr_stmt_list,\n-\t\t\t     GSI_SAME_STMT);\n-    }\n-  update_ssa (TODO_update_ssa);\n \n   return nloop;\n }"}, {"sha": "325ef58722d21a65ab896a9358677b07111b060b", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2778a719bebf7a32c34638cb39e9697c93ed484a/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2778a719bebf7a32c34638cb39e9697c93ed484a/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=2778a719bebf7a32c34638cb39e9697c93ed484a", "patch": "@@ -727,8 +727,8 @@ vect_free_loop_info_assumptions (struct loop *loop)\n /* If LOOP has been versioned during ifcvt, return the internal call\n    guarding it.  */\n \n-static gimple *\n-vect_loop_vectorized_call (struct loop *loop)\n+gimple *\n+vect_loop_vectorized_call (struct loop *loop, gcond **cond)\n {\n   basic_block bb = loop_preheader_edge (loop)->src;\n   gimple *g;\n@@ -744,6 +744,8 @@ vect_loop_vectorized_call (struct loop *loop)\n   while (1);\n   if (g && gimple_code (g) == GIMPLE_COND)\n     {\n+      if (cond)\n+\t*cond = as_a <gcond *> (g);\n       gimple_stmt_iterator gsi = gsi_for_stmt (g);\n       gsi_prev (&gsi);\n       if (!gsi_end_p (gsi))"}, {"sha": "19a8af090a64f0f9936e19f3b17203366f42f989", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2778a719bebf7a32c34638cb39e9697c93ed484a/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2778a719bebf7a32c34638cb39e9697c93ed484a/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=2778a719bebf7a32c34638cb39e9697c93ed484a", "patch": "@@ -1656,5 +1656,7 @@ void vect_pattern_recog (vec_info *);\n /* In tree-vectorizer.c.  */\n unsigned vectorize_loops (void);\n void vect_free_loop_info_assumptions (struct loop *);\n+gimple *vect_loop_vectorized_call (struct loop *, gcond **cond = NULL);\n+\n \n #endif  /* GCC_TREE_VECTORIZER_H  */"}]}