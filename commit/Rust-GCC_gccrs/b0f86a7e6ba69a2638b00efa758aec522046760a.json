{"sha": "b0f86a7e6ba69a2638b00efa758aec522046760a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjBmODZhN2U2YmE2OWEyNjM4YjAwZWZhNzU4YWVjNTIyMDQ2NzYwYQ==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel1@de.ibm.com", "date": "2009-08-20T09:21:13Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2009-08-20T09:21:13Z"}, "message": "s390.c (Z10_PREDICT_DISTANCE): New macro.\n\n2009-08-20  Andreas Krebbel  <krebbel1@de.ibm.com>\n\n\t* config/s390/s390.c (Z10_PREDICT_DISTANCE): New macro.\n\t(s390_z10_fix_long_loop_prediction): New function.\n\t(s390_z10_optimize_cmp): INSN walk moved to callee - s390_reorg.\n\t(s390_reorg): Walk over the INSNs and invoke\n\ts390_z10_fix_long_loop_prediction and s390_z10_optimize_cmp.\n\nFrom-SVN: r150955", "tree": {"sha": "afda1be14ded3ba00c068699a37d39589fa35754", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/afda1be14ded3ba00c068699a37d39589fa35754"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0f86a7e6ba69a2638b00efa758aec522046760a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0f86a7e6ba69a2638b00efa758aec522046760a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0f86a7e6ba69a2638b00efa758aec522046760a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0f86a7e6ba69a2638b00efa758aec522046760a/comments", "author": null, "committer": null, "parents": [{"sha": "f1149235142d434a76ceec242944c85c9749d3d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1149235142d434a76ceec242944c85c9749d3d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1149235142d434a76ceec242944c85c9749d3d4"}], "stats": {"total": 297, "additions": 220, "deletions": 77}, "files": [{"sha": "76a3fe442ae0ac49fda4b302d6db7ba12be827b5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0f86a7e6ba69a2638b00efa758aec522046760a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0f86a7e6ba69a2638b00efa758aec522046760a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b0f86a7e6ba69a2638b00efa758aec522046760a", "patch": "@@ -1,3 +1,11 @@\n+2009-08-20  Andreas Krebbel  <krebbel1@de.ibm.com>\n+\n+\t* config/s390/s390.c (Z10_PREDICT_DISTANCE): New macro.\n+\t(s390_z10_fix_long_loop_prediction): New function.\n+\t(s390_z10_optimize_cmp): INSN walk moved to callee - s390_reorg.\n+\t(s390_reorg): Walk over the INSNs and invoke\n+\ts390_z10_fix_long_loop_prediction and s390_z10_optimize_cmp.\n+\n 2009-08-20  Andreas Krebbel  <krebbel1@de.ibm.com>\n \n \t* config/s390/s390.md (\"*brx_stage1_<GPR:mode>\", \"*brxg_64bit\","}, {"sha": "47b939c676a5b6d605700ffc6e3ddd4123cf1d1a", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 154, "deletions": 77, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0f86a7e6ba69a2638b00efa758aec522046760a/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0f86a7e6ba69a2638b00efa758aec522046760a/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=b0f86a7e6ba69a2638b00efa758aec522046760a", "patch": "@@ -345,6 +345,10 @@ struct GTY(()) machine_function\n #define REGNO_PAIR_OK(REGNO, MODE)                               \\\n   (HARD_REGNO_NREGS ((REGNO), (MODE)) == 1 || !((REGNO) & 1))\n \n+/* That's the read ahead of the dynamic branch prediction unit in\n+   bytes on a z10 CPU.  */\n+#define Z10_PREDICT_DISTANCE 384\n+\n static enum machine_mode\n s390_libgcc_cmp_return_mode (void)\n {\n@@ -9661,6 +9665,66 @@ s390_optimize_prologue (void)\n     }\n }\n \n+/* On z10 the dynamic branch prediction must see the backward jump in\n+   a window of 384 bytes. If not it falls back to the static\n+   prediction.  This function rearranges the loop backward branch in a\n+   way which makes the static prediction always correct.  The function\n+   returns true if it added an instruction.  */\n+static bool\n+s390_z10_fix_long_loop_prediction (rtx insn)\n+{\n+  rtx set = single_set (insn);\n+  rtx code_label, label_ref, new_label;\n+  rtx uncond_jump;\n+  rtx cur_insn;\n+  rtx tmp;\n+  int distance;\n+\n+  /* This will exclude branch on count and branch on index patterns\n+     since these are correctly statically predicted.  */\n+  if (!set\n+      || SET_DEST (set) != pc_rtx\n+      || GET_CODE (SET_SRC(set)) != IF_THEN_ELSE)\n+    return false;\n+\n+  label_ref = (GET_CODE (XEXP (SET_SRC (set), 1)) == LABEL_REF ?\n+\t       XEXP (SET_SRC (set), 1) : XEXP (SET_SRC (set), 2));\n+\n+  gcc_assert (GET_CODE (label_ref) == LABEL_REF);\n+\n+  code_label = XEXP (label_ref, 0);\n+\n+  if (INSN_ADDRESSES (INSN_UID (code_label)) == -1\n+      || INSN_ADDRESSES (INSN_UID (insn)) == -1\n+      || (INSN_ADDRESSES (INSN_UID (insn))\n+\t  - INSN_ADDRESSES (INSN_UID (code_label)) < Z10_PREDICT_DISTANCE))\n+    return false;\n+\n+  for (distance = 0, cur_insn = PREV_INSN (insn);\n+       distance < Z10_PREDICT_DISTANCE - 6;\n+       distance += get_attr_length (cur_insn), cur_insn = PREV_INSN (cur_insn))\n+    if (!cur_insn || JUMP_P (cur_insn) || LABEL_P (cur_insn))\n+      return false;\n+\n+  new_label = gen_label_rtx ();\n+  uncond_jump = emit_jump_insn_after (\n+\t\t  gen_rtx_SET (VOIDmode, pc_rtx,\n+\t\t\t       gen_rtx_LABEL_REF (VOIDmode, code_label)),\n+\t\t  insn);\n+  emit_label_after (new_label, uncond_jump);\n+\n+  tmp = XEXP (SET_SRC (set), 1);\n+  XEXP (SET_SRC (set), 1) = XEXP (SET_SRC (set), 2);\n+  XEXP (SET_SRC (set), 2) = tmp;\n+  INSN_CODE (insn) = -1;\n+\n+  XEXP (label_ref, 0) = new_label;\n+  JUMP_LABEL (insn) = new_label;\n+  JUMP_LABEL (uncond_jump) = code_label;\n+\n+  return true;\n+}\n+\n /* Returns 1 if INSN reads the value of REG for purposes not related\n    to addressing of memory, and 0 otherwise.  */\n static int\n@@ -9743,97 +9807,87 @@ s390_swap_cmp (rtx cond, rtx *op0, rtx *op1, rtx insn)\n    if that register's value is delivered via a bypass, then the\n    pipeline recycles, thereby causing significant performance decline.\n    This function locates such situations and exchanges the two\n-   operands of the compare.  */\n-static void\n-s390_z10_optimize_cmp (void)\n+   operands of the compare.  The function return true whenever it\n+   added an insn.  */\n+static bool\n+s390_z10_optimize_cmp (rtx insn)\n {\n-  rtx insn, prev_insn, next_insn;\n-  int added_NOPs = 0;\n+  rtx prev_insn, next_insn;\n+  bool insn_added_p = false;\n+  rtx cond, *op0, *op1;\n \n-  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+  if (GET_CODE (PATTERN (insn)) == PARALLEL)\n     {\n-      rtx cond, *op0, *op1;\n+      /* Handle compare and branch and branch on count\n+\t instructions.  */\n+      rtx pattern = single_set (insn);\n \n-      if (!INSN_P (insn) || INSN_CODE (insn) <= 0)\n-\tcontinue;\n-\n-      if (GET_CODE (PATTERN (insn)) == PARALLEL)\n-\t{\n-\t  /* Handle compare and branch and branch on count\n-\t     instructions.  */\n-\t  rtx pattern = single_set (insn);\n-\n-\t  if (!pattern\n-\t      || SET_DEST (pattern) != pc_rtx\n-\t      || GET_CODE (SET_SRC (pattern)) != IF_THEN_ELSE)\n-\t    continue;\n+      if (!pattern\n+\t  || SET_DEST (pattern) != pc_rtx\n+\t  || GET_CODE (SET_SRC (pattern)) != IF_THEN_ELSE)\n+\treturn false;\n \n-\t  cond = XEXP (SET_SRC (pattern), 0);\n-\t  op0 = &XEXP (cond, 0);\n-\t  op1 = &XEXP (cond, 1);\n-\t}\n-      else if (GET_CODE (PATTERN (insn)) == SET)\n-\t{\n-\t  rtx src, dest;\n+      cond = XEXP (SET_SRC (pattern), 0);\n+      op0 = &XEXP (cond, 0);\n+      op1 = &XEXP (cond, 1);\n+    }\n+  else if (GET_CODE (PATTERN (insn)) == SET)\n+    {\n+      rtx src, dest;\n \n-\t  /* Handle normal compare instructions.  */\n-\t  src = SET_SRC (PATTERN (insn));\n-\t  dest = SET_DEST (PATTERN (insn));\n+      /* Handle normal compare instructions.  */\n+      src = SET_SRC (PATTERN (insn));\n+      dest = SET_DEST (PATTERN (insn));\n \n-\t  if (!REG_P (dest)\n-\t      || !CC_REGNO_P (REGNO (dest))\n-\t      || GET_CODE (src) != COMPARE)\n-\t    continue;\n+      if (!REG_P (dest)\n+\t  || !CC_REGNO_P (REGNO (dest))\n+\t  || GET_CODE (src) != COMPARE)\n+\treturn false;\n \n-\t  /* s390_swap_cmp will try to find the conditional\n-\t     jump when passing NULL_RTX as condition.  */\n-\t  cond = NULL_RTX;\n-\t  op0 = &XEXP (src, 0);\n-\t  op1 = &XEXP (src, 1);\n-\t}\n-      else\n-\tcontinue;\n+      /* s390_swap_cmp will try to find the conditional\n+\t jump when passing NULL_RTX as condition.  */\n+      cond = NULL_RTX;\n+      op0 = &XEXP (src, 0);\n+      op1 = &XEXP (src, 1);\n+    }\n+  else\n+    return false;\n \n-      if (!REG_P (*op0) || !REG_P (*op1))\n-\tcontinue;\n+  if (!REG_P (*op0) || !REG_P (*op1))\n+    return false;\n \n-      /* Swap the COMPARE arguments and its mask if there is a\n-\t conflicting access in the previous insn.  */\n-      prev_insn = PREV_INSN (insn);\n+  /* Swap the COMPARE arguments and its mask if there is a\n+     conflicting access in the previous insn.  */\n+  prev_insn = PREV_INSN (insn);\n+  if (prev_insn != NULL_RTX && INSN_P (prev_insn)\n+      && reg_referenced_p (*op1, PATTERN (prev_insn)))\n+    s390_swap_cmp (cond, op0, op1, insn);\n+\n+  /* Check if there is a conflict with the next insn. If there\n+     was no conflict with the previous insn, then swap the\n+     COMPARE arguments and its mask.  If we already swapped\n+     the operands, or if swapping them would cause a conflict\n+     with the previous insn, issue a NOP after the COMPARE in\n+     order to separate the two instuctions.  */\n+  next_insn = NEXT_INSN (insn);\n+  if (next_insn != NULL_RTX && INSN_P (next_insn)\n+      && s390_non_addr_reg_read_p (*op1, next_insn))\n+    {\n       if (prev_insn != NULL_RTX && INSN_P (prev_insn)\n-\t  && reg_referenced_p (*op1, PATTERN (prev_insn)))\n-\ts390_swap_cmp (cond, op0, op1, insn);\n-\n-      /* Check if there is a conflict with the next insn. If there\n-\t was no conflict with the previous insn, then swap the\n-\t COMPARE arguments and its mask.  If we already swapped\n-\t the operands, or if swapping them would cause a conflict\n-\t with the previous insn, issue a NOP after the COMPARE in\n-\t order to separate the two instuctions.  */\n-      next_insn = NEXT_INSN (insn);\n-      if (next_insn != NULL_RTX && INSN_P (next_insn)\n-\t  && s390_non_addr_reg_read_p (*op1, next_insn))\n+\t  && s390_non_addr_reg_read_p (*op0, prev_insn))\n \t{\n-\t  if (prev_insn != NULL_RTX && INSN_P (prev_insn)\n-\t      && s390_non_addr_reg_read_p (*op0, prev_insn))\n-\t    {\n-\t      if (REGNO (*op1) == 0)\n-\t\temit_insn_after (gen_nop1 (), insn);\n-\t      else\n-\t\temit_insn_after (gen_nop (), insn);\n-\t      added_NOPs = 1;\n-\t    }\n+\t  if (REGNO (*op1) == 0)\n+\t    emit_insn_after (gen_nop1 (), insn);\n \t  else\n-\t    s390_swap_cmp (cond, op0, op1, insn);\n+\t    emit_insn_after (gen_nop (), insn);\n+\t  insn_added_p = true;\n \t}\n+      else\n+\ts390_swap_cmp (cond, op0, op1, insn);\n     }\n-\n-  /* Adjust branches if we added new instructions.  */\n-  if (added_NOPs)\n-    shorten_branches (get_insns ());\n+  return insn_added_p;\n }\n \n-\n /* Perform machine-dependent processing.  */\n \n static void\n@@ -9944,10 +9998,33 @@ s390_reorg (void)\n   /* Try to optimize prologue and epilogue further.  */\n   s390_optimize_prologue ();\n \n-  /* Eliminate z10-specific pipeline recycles related to some compare\n-     instructions.  */\n+  /* Walk over the insns and do some z10 specific changes.  */\n   if (s390_tune == PROCESSOR_2097_Z10)\n-    s390_z10_optimize_cmp ();\n+    {\n+      rtx insn;\n+      bool insn_added_p = false;\n+\n+      /* The insn lengths and addresses have to be up to date for the\n+\t following manipulations.  */\n+      shorten_branches (get_insns ());\n+\n+      for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+\t{\n+\t  if (!INSN_P (insn) || INSN_CODE (insn) <= 0)\n+\t    continue;\n+\n+\t  if (JUMP_P (insn))\n+\t    insn_added_p |= s390_z10_fix_long_loop_prediction (insn);\n+\n+\t  if (GET_CODE (PATTERN (insn)) == PARALLEL\n+\t      || GET_CODE (PATTERN (insn)) == SET)\n+\t    insn_added_p |= s390_z10_optimize_cmp (insn);\n+\t}\n+\n+      /* Adjust branches if we added new instructions.  */\n+      if (insn_added_p)\n+\tshorten_branches (get_insns ());\n+    }\n }\n \n "}, {"sha": "0a4361ff2675824c1582da60ac14475c04a0b86f", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0f86a7e6ba69a2638b00efa758aec522046760a/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0f86a7e6ba69a2638b00efa758aec522046760a/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=b0f86a7e6ba69a2638b00efa758aec522046760a", "patch": "@@ -1046,6 +1046,64 @@\n                       (const_int 6) (const_int 12)))]) ; 8 byte for clr/jg\n                                                        ; 10 byte for clgr/jg\n \n+; And now the same two patterns as above but with a negated CC mask.\n+\n+; cij, cgij, crj, cgrj, cfi, cgfi, cr, cgr\n+; The following instructions do a complementary access of their second\n+; operand (z01 only): crj_c, cgrjc, cr, cgr\n+(define_insn \"*icmp_and_br_signed_<mode>\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"s390_signed_integer_comparison\"\n+\t\t\t[(match_operand:GPR 1 \"register_operand\"  \"d,d\")\n+\t\t\t (match_operand:GPR 2 \"nonmemory_operand\" \"d,C\")])\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"TARGET_Z10\"\n+{\n+  if (get_attr_length (insn) == 6)\n+    return which_alternative ?\n+      \"c<g>ij%D0\\t%1,%c2,%l3\" : \"c<g>rj%D0\\t%1,%2,%l3\";\n+  else\n+    return which_alternative ?\n+      \"c<g>fi\\t%1,%c2\\;jg%D0\\t%l3\" : \"c<g>r\\t%1,%2\\;jg%D0\\t%l3\";\n+}\n+  [(set_attr \"op_type\" \"RIE\")\n+   (set_attr \"type\"    \"branch\")\n+   (set_attr \"z10prop\" \"z10_super_c,z10_super\")\n+   (set (attr \"length\")\n+        (if_then_else (lt (abs (minus (pc) (match_dup 3))) (const_int 60000))\n+                      (const_int 6) (const_int 12)))]) ; 8 byte for cr/jg\n+                                                       ; 10 byte for cgr/jg\n+\n+; clij, clgij, clrj, clgrj, clfi, clgfi, clr, clgr\n+; The following instructions do a complementary access of their second\n+; operand (z10 only): clrj, clgrj, clr, clgr\n+(define_insn \"*icmp_and_br_unsigned_<mode>\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"s390_unsigned_integer_comparison\"\n+\t\t\t[(match_operand:GPR 1 \"register_operand\"  \"d,d\")\n+\t\t\t (match_operand:GPR 2 \"nonmemory_operand\" \"d,I\")])\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"TARGET_Z10\"\n+{\n+  if (get_attr_length (insn) == 6)\n+    return which_alternative ?\n+      \"cl<g>ij%D0\\t%1,%b2,%l3\" : \"cl<g>rj%D0\\t%1,%2,%l3\";\n+  else\n+    return which_alternative ?\n+      \"cl<g>fi\\t%1,%b2\\;jg%D0\\t%l3\" : \"cl<g>r\\t%1,%2\\;jg%D0\\t%l3\";\n+}\n+  [(set_attr \"op_type\" \"RIE\")\n+   (set_attr \"type\"    \"branch\")\n+   (set_attr \"z10prop\" \"z10_super_c,z10_super\")\n+   (set (attr \"length\")\n+        (if_then_else (lt (abs (minus (pc) (match_dup 3))) (const_int 60000))\n+                      (const_int 6) (const_int 12)))]) ; 8 byte for clr/jg\n+                                                       ; 10 byte for clgr/jg\n+\n ;;\n ;;- Move instructions.\n ;;"}]}