{"sha": "68f3759eff5ee498b52490213650b42b1ad89f16", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjhmMzc1OWVmZjVlZTQ5OGI1MjQ5MDIxMzY1MGI0MmIxYWQ4OWYxNg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-01-30T00:36:25Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-01-30T00:40:19Z"}, "message": "runtime: update netpoll_hurd.go for go1.14beta1 changes\n\nPatch from Svante Signell.\n\nUpdates PR go/93468\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/216958", "tree": {"sha": "5290a87a91bba5612b699880a26389586bc2d947", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5290a87a91bba5612b699880a26389586bc2d947"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68f3759eff5ee498b52490213650b42b1ad89f16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68f3759eff5ee498b52490213650b42b1ad89f16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68f3759eff5ee498b52490213650b42b1ad89f16", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68f3759eff5ee498b52490213650b42b1ad89f16/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e3b6c052b6a0569aa8f89c50db1ac376c42e41e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3b6c052b6a0569aa8f89c50db1ac376c42e41e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3b6c052b6a0569aa8f89c50db1ac376c42e41e0"}], "stats": {"total": 79, "additions": 45, "deletions": 34}, "files": [{"sha": "8d08e91211dba9ea8aeef778a4f348623c5869aa", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68f3759eff5ee498b52490213650b42b1ad89f16/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68f3759eff5ee498b52490213650b42b1ad89f16/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=68f3759eff5ee498b52490213650b42b1ad89f16", "patch": "@@ -1,4 +1,4 @@\n-132e0e61d59aaa52f8fdb03a925300c1ced2a0f2\n+5b438257e6fe5f344ae2f973313f394cda85bf62\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "3d3fa4b76d3a9915ae1cbc10747def0996765038", "filename": "libgo/go/runtime/netpoll_hurd.go", "status": "modified", "additions": 44, "deletions": 33, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68f3759eff5ee498b52490213650b42b1ad89f16/libgo%2Fgo%2Fruntime%2Fnetpoll_hurd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68f3759eff5ee498b52490213650b42b1ad89f16/libgo%2Fgo%2Fruntime%2Fnetpoll_hurd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fnetpoll_hurd.go?ref=68f3759eff5ee498b52490213650b42b1ad89f16", "patch": "@@ -85,6 +85,10 @@ func netpolldescriptor() uintptr {\n \treturn uintptr(rdwake<<16 | wrwake)\n }\n \n+func netpollIsPollDescriptor(fd uintptr) bool {\n+\treturn fd == uintptr(rdwake) || fd == uintptr(wrwake)\n+}\n+\n // netpollwakeup writes on wrwake to wakeup poll before any changes.\n func netpollwakeup() {\n \tif pendingUpdates == 0 {\n@@ -158,58 +162,70 @@ func netpollarm(pd *pollDesc, mode int) {\n \tunlock(&mtxset)\n }\n \n-// polls for ready network connections\n-// returns list of goroutines that become runnable\n+// netpollBreak interrupts an epollwait.\n+func netpollBreak() {\n+\tnetpollwakeup()\n+}\n+\n+// netpoll checks for ready network connections.\n+// Returns list of goroutines that become runnable.\n+// delay < 0: blocks indefinitely\n+// delay == 0: does not block, just polls\n+// delay > 0: block for up to that many nanoseconds\n //go:nowritebarrierrec\n-func netpoll(block bool) gList {\n+func netpoll(delay int64) gList {\n \ttimeout := int32(0)\n-\tif !block {\n+\tif delay < 0 {\n \t\ttimeout = 0\n+\t} else if delay == 0 {\n+\t\t// TODO: call poll with timeout == 0\n \t\treturn gList{}\n-\t}\n-\tif pollVerbose {\n-\t\tprintln(\"*** netpoll\", block)\n+\t} else if delay < 1e6 {\n+\t\ttimeout = 1\n+\t} else if delay < 1e15 {\n+\t\ttimeout = int32(delay / 1e6)\n+\t} else {\n+\t\t// An arbitrary cap on how long to wait for a timer.\n+\t\t// 1e9 ms == ~11.5 days.\n+\t\ttimeout = 1e9\n \t}\n retry:\n \tlock(&mtxpoll)\n \tlock(&mtxset)\n \tpendingUpdates = 0\n \tunlock(&mtxpoll)\n \n-\tif pollVerbose {\n-\t\tprintln(\"*** netpoll before poll\")\n-\t}\n \tn := libc_poll(&pfds[0], int32(len(pfds)), timeout)\n-\tif pollVerbose {\n-\t\tprintln(\"*** netpoll after poll\", n)\n-\t}\n \tif n < 0 {\n \t\te := errno()\n \t\tif e != _EINTR {\n \t\t\tprintln(\"errno=\", e, \" len(pfds)=\", len(pfds))\n \t\t\tthrow(\"poll failed\")\n \t\t}\n-\t\tif pollVerbose {\n-\t\t\tprintln(\"*** poll failed\")\n-\t\t}\n \t\tunlock(&mtxset)\n+\t\t// If a timed sleep was interrupted, just return to\n+\t\t// recalculate how long we should sleep now.\n+\t\tif timeout > 0 {\n+\t\t\treturn gList{}\n+\t\t}\n \t\tgoto retry\n \t}\n \t// Check if some descriptors need to be changed\n \tif n != 0 && pfds[0].revents&(_POLLIN|_POLLHUP|_POLLERR) != 0 {\n-\t\tvar b [1]byte\n-\t\tfor read(rdwake, unsafe.Pointer(&b[0]), 1) == 1 {\n-\t\t\tif pollVerbose {\n-\t\t\t\tprintln(\"*** read 1 byte from pipe\")\n+\t\tif delay != 0 {\n+\t\t\t// A netpollwakeup could be picked up by a\n+\t\t\t// non-blocking poll. Only clear the wakeup\n+\t\t\t// if blocking.\n+\t\t\tvar b [1]byte\n+\t\t\tfor read(rdwake, unsafe.Pointer(&b[0]), 1) == 1 {\n \t\t\t}\n \t\t}\n-\t\t// Do not look at the other fds in this case as the mode may have changed\n-\t\t// XXX only additions of flags are made, so maybe it is ok\n-\t\tunlock(&mtxset)\n-\t\tgoto retry\n+\t\t// Still look at the other fds even if the mode may have\n+\t\t// changed, as netpollBreak might have been called.\n+\t\tn--\n \t}\n \tvar toRun gList\n-\tfor i := 0; i < len(pfds) && n > 0; i++ {\n+\tfor i := 1; i < len(pfds) && n > 0; i++ {\n \t\tpfd := &pfds[i]\n \n \t\tvar mode int32\n@@ -222,19 +238,14 @@ retry:\n \t\t\tpfd.events &= ^_POLLOUT\n \t\t}\n \t\tif mode != 0 {\n-\t\t\tif pollVerbose {\n-\t\t\t\tprintln(\"*** netpollready i=\", i, \"revents=\", pfd.revents, \"events=\", pfd.events, \"pd=\", pds[i])\n+\t\t\tpds[i].everr = false\n+\t\t\tif pfd.revents == _POLLERR {\n+\t\t\t\tpds[i].everr = true\n \t\t\t}\n \t\t\tnetpollready(&toRun, pds[i], mode)\n \t\t\tn--\n \t\t}\n \t}\n \tunlock(&mtxset)\n-\tif block && toRun.empty() {\n-\t\tgoto retry\n-\t}\n-\tif pollVerbose {\n-\t\tprintln(\"*** netpoll returning end\")\n-\t}\n \treturn toRun\n }"}]}