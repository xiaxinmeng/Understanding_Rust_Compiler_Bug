{"sha": "cc9cd2324922575c1aa1eadf6340c2af47f011c4", "node_id": "C_kwDOANBUbNoAKGNjOWNkMjMyNDkyMjU3NWMxYWExZWFkZjYzNDBjMmFmNDdmMDExYzQ", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-12-21T23:02:15Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-01-10T09:38:46Z"}, "message": "[Ada] Fix internal error on unchecked union with component clauses\n\ngcc/ada/\n\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Record_Type>: Fix\n\tcomputation of boolean result in the unchecked union case.\n\t(components_to_record): Rename MAYBE_UNUSED parameter to IN_VARIANT\n\tand remove local variable of the same name.  Pass NULL recursively\n\tas P_GNU_REP_LIST for nested variants in the unchecked union case.", "tree": {"sha": "a8daaa44c852067e55632e0ba7dffe542f9124b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8daaa44c852067e55632e0ba7dffe542f9124b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc9cd2324922575c1aa1eadf6340c2af47f011c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc9cd2324922575c1aa1eadf6340c2af47f011c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc9cd2324922575c1aa1eadf6340c2af47f011c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc9cd2324922575c1aa1eadf6340c2af47f011c4/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c6fbbfc83a8faefb74232cbb29fa1f79348b3e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c6fbbfc83a8faefb74232cbb29fa1f79348b3e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c6fbbfc83a8faefb74232cbb29fa1f79348b3e5"}], "stats": {"total": 29, "additions": 17, "deletions": 12}, "files": [{"sha": "39a90929d4cc8a0e4892909dbac8b9fd27d73df7", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc9cd2324922575c1aa1eadf6340c2af47f011c4/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc9cd2324922575c1aa1eadf6340c2af47f011c4/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=cc9cd2324922575c1aa1eadf6340c2af47f011c4", "patch": "@@ -3059,7 +3059,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t       Present (gnat_field);\n \t       gnat_field = Next_Entity (gnat_field))\n \t    if ((Ekind (gnat_field) == E_Component\n-\t\t || Ekind (gnat_field) == E_Discriminant)\n+\t\t || (Ekind (gnat_field) == E_Discriminant\n+\t\t     && !is_unchecked_union))\n \t\t&& No (Component_Clause (gnat_field)))\n \t      {\n \t\tall_rep = false;\n@@ -7874,8 +7875,7 @@ typedef struct vinfo\n \n    DEBUG_INFO is true if we need to write debug information about the type.\n \n-   MAYBE_UNUSED is true if this type may be unused in the end; this doesn't\n-   mean that its contents may be unused as well, only the container itself.\n+   IN_VARIANT is true if the componennt list is that of a variant.\n \n    FIRST_FREE_POS, if nonzero, is the first (lowest) free field position in\n    the outer record type down to this variant level.  It is nonzero only if\n@@ -7890,7 +7890,7 @@ components_to_record (Node_Id gnat_component_list, Entity_Id gnat_record_type,\n \t\t      tree gnu_field_list, tree gnu_record_type, int packed,\n \t\t      bool definition, bool cancel_alignment, bool all_rep,\n \t\t      bool unchecked_union, bool artificial, bool debug_info,\n-\t\t      bool maybe_unused, tree first_free_pos,\n+\t\t      bool in_variant, tree first_free_pos,\n \t\t      tree *p_gnu_rep_list)\n {\n   const bool needs_xv_encodings\n@@ -8075,15 +8075,21 @@ components_to_record (Node_Id gnat_component_list, Entity_Id gnat_record_type,\n \t\t= TYPE_SIZE_UNIT (gnu_record_type);\n \t    }\n \n-\t  /* Add the fields into the record type for the variant.  Note that\n-\t     we aren't sure to really use it at this point, see below.  */\n+\t  /* Add the fields into the record type for the variant but note that\n+\t     we aren't sure to really use it at this point, see below.  In the\n+\t     case of an unchecked union, we force the fields with a rep clause\n+\t     present in a nested variant to be moved to the outermost variant,\n+\t     so as to flatten the rep-ed layout as much as possible, the reason\n+\t     being that we cannot do any flattening when a subtype statically\n+\t     selects a variant later on, for example for an aggregate.  */\n \t  has_rep\n \t    = components_to_record (Component_List (variant), gnat_record_type,\n \t\t\t\t    NULL_TREE, gnu_variant_type, packed,\n \t\t\t\t    definition, !all_rep_and_size, all_rep,\n \t\t\t\t    unchecked_union, true, needs_xv_encodings,\n \t\t\t\t    true, this_first_free_pos,\n-\t\t\t\t    all_rep || this_first_free_pos\n+\t\t\t\t    (all_rep || this_first_free_pos)\n+\t\t\t\t    && !(in_variant && unchecked_union)\n \t\t\t\t    ? NULL : &gnu_rep_list);\n \n \t  /* Translate the qualifier and annotate the GNAT node.  */\n@@ -8206,9 +8212,9 @@ components_to_record (Node_Id gnat_component_list, Entity_Id gnat_record_type,\n \t  finish_record_type (gnu_union_type, nreverse (gnu_variant_list),\n \t\t\t      all_rep_and_size ? 1 : 0, needs_xv_encodings);\n \n-\t  /* If GNU_UNION_TYPE is our record type, it means we must have an\n-\t     Unchecked_Union with no fields.  Verify that and, if so, just\n-\t     return.  */\n+\t  /* If GNU_UNION_TYPE is our record type, this means that we must have\n+\t     an Unchecked_Union whose fields are all in the variant part.  Now\n+\t     verify that and, if so, just return.  */\n \t  if (gnu_union_type == gnu_record_type)\n \t    {\n \t      gcc_assert (unchecked_union\n@@ -8275,7 +8281,6 @@ components_to_record (Node_Id gnat_component_list, Entity_Id gnat_record_type,\n     = (Convention (gnat_record_type) == Convention_Ada\n        && Warn_On_Questionable_Layout\n        && !(No_Reordering (gnat_record_type) && GNAT_Mode));\n-  const bool in_variant = (p_gnu_rep_list != NULL);\n   tree gnu_zero_list = NULL_TREE;\n   tree gnu_self_list = NULL_TREE;\n   tree gnu_var_list = NULL_TREE;\n@@ -8640,7 +8645,7 @@ components_to_record (Node_Id gnat_component_list, Entity_Id gnat_record_type,\n   TYPE_ARTIFICIAL (gnu_record_type) = artificial;\n \n   finish_record_type (gnu_record_type, gnu_field_list, layout_with_rep ? 1 : 0,\n-\t\t      debug_info && !maybe_unused);\n+\t\t      debug_info && !in_variant);\n \n   /* Chain the fields with zero size at the beginning of the field list.  */\n   if (gnu_zero_list)"}]}