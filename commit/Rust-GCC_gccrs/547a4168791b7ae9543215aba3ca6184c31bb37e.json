{"sha": "547a4168791b7ae9543215aba3ca6184c31bb37e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQ3YTQxNjg3OTFiN2FlOTU0MzIxNWFiYTNjYTYxODRjMzFiYjM3ZQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-12-12T01:08:52Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-12-12T01:08:52Z"}, "message": "compiler, reflect, runtime: Implement method values in reflect.\n\nFrom-SVN: r205913", "tree": {"sha": "6d22f3392a75c3aaa5aa1da655668fca943b1d10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d22f3392a75c3aaa5aa1da655668fca943b1d10"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/547a4168791b7ae9543215aba3ca6184c31bb37e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/547a4168791b7ae9543215aba3ca6184c31bb37e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/547a4168791b7ae9543215aba3ca6184c31bb37e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/547a4168791b7ae9543215aba3ca6184c31bb37e/comments", "author": null, "committer": null, "parents": [{"sha": "24fd676aa8b79e264e3b6dac48f7d18d0921761e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24fd676aa8b79e264e3b6dac48f7d18d0921761e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24fd676aa8b79e264e3b6dac48f7d18d0921761e"}], "stats": {"total": 219, "additions": 155, "deletions": 64}, "files": [{"sha": "33c23e56092b53aef7326ae5d984a3518f33a360", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 29, "deletions": 20, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/547a4168791b7ae9543215aba3ca6184c31bb37e/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/547a4168791b7ae9543215aba3ca6184c31bb37e/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=547a4168791b7ae9543215aba3ca6184c31bb37e", "patch": "@@ -2261,26 +2261,9 @@ Type::method_constructor(Gogo*, Type* method_type,\n \n   ++p;\n   go_assert(p->is_field_name(\"typ\"));\n-  if (!only_value_methods && m->is_value_method())\n-    {\n-      // This is a value method on a pointer type.  Change the type of\n-      // the method to use a pointer receiver.  The implementation\n-      // always uses a pointer receiver anyhow.\n-      Type* rtype = mtype->receiver()->type();\n-      Type* prtype = Type::make_pointer_type(rtype);\n-      Typed_identifier* receiver =\n-\tnew Typed_identifier(mtype->receiver()->name(), prtype,\n-\t\t\t     mtype->receiver()->location());\n-      mtype = Type::make_function_type(receiver,\n-\t\t\t\t       (mtype->parameters() == NULL\n-\t\t\t\t\t? NULL\n-\t\t\t\t\t: mtype->parameters()->copy()),\n-\t\t\t\t       (mtype->results() == NULL\n-\t\t\t\t\t? NULL\n-\t\t\t\t\t: mtype->results()->copy()),\n-\t\t\t\t       mtype->location());\n-    }\n-  vals->push_back(Expression::make_type_descriptor(mtype, bloc));\n+  bool want_pointer_receiver = !only_value_methods && m->is_value_method();\n+  nonmethod_type = mtype->copy_with_receiver_as_param(want_pointer_receiver);\n+  vals->push_back(Expression::make_type_descriptor(nonmethod_type, bloc));\n \n   ++p;\n   go_assert(p->is_field_name(\"tfn\"));\n@@ -4008,6 +3991,32 @@ Function_type::copy_with_receiver(Type* receiver_type) const\n   return ret;\n }\n \n+// Make a copy of a function type with the receiver as the first\n+// parameter.\n+\n+Function_type*\n+Function_type::copy_with_receiver_as_param(bool want_pointer_receiver) const\n+{\n+  go_assert(this->is_method());\n+  Typed_identifier_list* new_params = new Typed_identifier_list();\n+  Type* rtype = this->receiver_->type();\n+  if (want_pointer_receiver)\n+    rtype = Type::make_pointer_type(rtype);\n+  Typed_identifier receiver(this->receiver_->name(), rtype,\n+\t\t\t    this->receiver_->location());\n+  new_params->push_back(receiver);\n+  const Typed_identifier_list* orig_params = this->parameters_;\n+  if (orig_params != NULL && !orig_params->empty())\n+    {\n+      for (Typed_identifier_list::const_iterator p = orig_params->begin();\n+\t   p != orig_params->end();\n+\t   ++p)\n+\tnew_params->push_back(*p);\n+    }\n+  return Type::make_function_type(NULL, new_params, this->results_,\n+\t\t\t\t  this->location_);\n+}\n+\n // Make a copy of a function type ignoring any receiver and adding a\n // closure parameter.\n "}, {"sha": "9f9659161319f2a7083b53369570504c642af052", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/547a4168791b7ae9543215aba3ca6184c31bb37e/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/547a4168791b7ae9543215aba3ca6184c31bb37e/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=547a4168791b7ae9543215aba3ca6184c31bb37e", "patch": "@@ -1797,6 +1797,12 @@ class Function_type : public Type\n   Function_type*\n   copy_with_receiver(Type*) const;\n \n+  // Return a copy of this type with the receiver treated as the first\n+  // parameter.  If WANT_POINTER_RECEIVER is true, the receiver is\n+  // forced to be a pointer.\n+  Function_type*\n+  copy_with_receiver_as_param(bool want_pointer_receiver) const;\n+\n   // Return a copy of this type ignoring any receiver and using dummy\n   // names for all parameters.  This is used for thunks for method\n   // values."}, {"sha": "f9700ce2fb5d9bb8b3f8877f2777b812c5699635", "filename": "libgo/go/reflect/all_test.go", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/547a4168791b7ae9543215aba3ca6184c31bb37e/libgo%2Fgo%2Freflect%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/547a4168791b7ae9543215aba3ca6184c31bb37e/libgo%2Fgo%2Freflect%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fall_test.go?ref=547a4168791b7ae9543215aba3ca6184c31bb37e", "patch": "@@ -1631,9 +1631,13 @@ func TestMethod(t *testing.T) {\n \t}\n }\n \n-/* Not yet implemented for gccgo\n-\n func TestMethodValue(t *testing.T) {\n+\tswitch runtime.GOARCH {\n+\tcase \"amd64\", \"386\":\n+\tdefault:\n+\t\tt.Skip(\"reflect method values not implemented for \" + runtime.GOARCH)\n+\t}\n+\n \tp := Point{3, 4}\n \tvar i int64\n \n@@ -1721,8 +1725,6 @@ func TestMethodValue(t *testing.T) {\n \t}\n }\n \n-*/\n-\n // Reflect version of $GOROOT/test/method5.go\n \n // Concrete types implementing M method.\n@@ -1807,14 +1809,18 @@ type Tm4 struct {\n func (t4 Tm4) M(x int, b byte) (byte, int) { return b, x + 40 }\n \n func TestMethod5(t *testing.T) {\n-\t/* Not yet used for gccgo\n+\tswitch runtime.GOARCH {\n+\tcase \"amd64\", \"386\":\n+\tdefault:\n+\t\tt.Skip(\"reflect method values not implemented for \" + runtime.GOARCH)\n+\t}\n+\n \tCheckF := func(name string, f func(int, byte) (byte, int), inc int) {\n \t\tb, x := f(1000, 99)\n \t\tif b != 99 || x != 1000+inc {\n \t\t\tt.Errorf(\"%s(1000, 99) = %v, %v, want 99, %v\", name, b, x, 1000+inc)\n \t\t}\n \t}\n-\t*/\n \n \tCheckV := func(name string, i Value, inc int) {\n \t\tbx := i.Method(0).Call([]Value{ValueOf(1000), ValueOf(byte(99))})\n@@ -1824,9 +1830,7 @@ func TestMethod5(t *testing.T) {\n \t\t\tt.Errorf(\"direct %s.M(1000, 99) = %v, %v, want 99, %v\", name, b, x, 1000+inc)\n \t\t}\n \n-\t\t/* Not yet implemented for gccgo\n \t\tCheckF(name+\".M\", i.Method(0).Interface().(func(int, byte) (byte, int)), inc)\n-\t\t*/\n \t}\n \n \tvar TinterType = TypeOf(new(Tinter)).Elem()"}, {"sha": "935a3d3be02c62608bf1a21a98017f600ae40d00", "filename": "libgo/go/reflect/makefunc.go", "status": "modified", "additions": 87, "deletions": 3, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/547a4168791b7ae9543215aba3ca6184c31bb37e/libgo%2Fgo%2Freflect%2Fmakefunc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/547a4168791b7ae9543215aba3ca6184c31bb37e/libgo%2Fgo%2Freflect%2Fmakefunc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fmakefunc.go?ref=547a4168791b7ae9543215aba3ca6184c31bb37e", "patch": "@@ -17,6 +17,11 @@ type makeFuncImpl struct {\n \tcode uintptr\n \ttyp  *funcType\n \tfn   func([]Value) []Value\n+\n+\t// For gccgo we use the same entry point for functions and for\n+\t// method values.\n+\tmethod int\n+\trcvr   Value\n }\n \n // MakeFunc returns a new function of the given Type\n@@ -61,7 +66,7 @@ func MakeFunc(typ Type, fn func(args []Value) (results []Value)) Value {\n \tdummy := makeFuncStub\n \tcode := **(**uintptr)(unsafe.Pointer(&dummy))\n \n-\timpl := &makeFuncImpl{code: code, typ: ftyp, fn: fn}\n+\timpl := &makeFuncImpl{code: code, typ: ftyp, fn: fn, method: -1}\n \n \treturn Value{t, unsafe.Pointer(&impl), flag(Func<<flagKindShift) | flagIndir}\n }\n@@ -85,15 +90,94 @@ func makeMethodValue(op string, v Value) Value {\n \t\tpanic(\"reflect: internal error: invalid use of makePartialFunc\")\n \t}\n \n+\tswitch runtime.GOARCH {\n+\tcase \"amd64\", \"386\":\n+\tdefault:\n+\t\tpanic(\"reflect.makeMethodValue not implemented for \" + runtime.GOARCH)\n+\t}\n+\n \t// Ignoring the flagMethod bit, v describes the receiver, not the method type.\n \tfl := v.flag & (flagRO | flagAddr | flagIndir)\n \tfl |= flag(v.typ.Kind()) << flagKindShift\n \trcvr := Value{v.typ, v.val, fl}\n \n+\t// v.Type returns the actual type of the method value.\n+\tft := v.Type().(*rtype)\n+\n+\t// Indirect Go func value (dummy) to obtain\n+\t// actual code address. (A Go func value is a pointer\n+\t// to a C function pointer. http://golang.org/s/go11func.)\n+\tdummy := makeFuncStub\n+\tcode := **(**uintptr)(unsafe.Pointer(&dummy))\n+\n \t// Cause panic if method is not appropriate.\n \t// The panic would still happen during the call if we omit this,\n \t// but we want Interface() and other operations to fail early.\n-\tmethodReceiver(op, rcvr, int(v.flag)>>flagMethodShift)\n+\tt, _, _ := methodReceiver(op, rcvr, int(v.flag)>>flagMethodShift)\n+\n+\tfv := &makeFuncImpl{\n+\t\tcode:   code,\n+\t\ttyp:    (*funcType)(unsafe.Pointer(t)),\n+\t\tmethod: int(v.flag) >> flagMethodShift,\n+\t\trcvr:   rcvr,\n+\t}\n+\n+\treturn Value{ft, unsafe.Pointer(&fv), v.flag&flagRO | flag(Func)<<flagKindShift | flagIndir}\n+}\n+\n+// makeValueMethod takes a method function and returns a function that\n+// takes a value receiver and calls the real method with a pointer to\n+// it.\n+func makeValueMethod(v Value) Value {\n+\ttyp := v.typ\n+\tif typ.Kind() != Func {\n+\t\tpanic(\"reflect: call of makeValueMethod with non-Func type\")\n+\t}\n+\tif v.flag&flagMethodFn == 0 {\n+\t\tpanic(\"reflect: call of makeValueMethod with non-MethodFn\")\n+\t}\n \n-\tpanic(\"reflect makeMethodValue not implemented\")\n+\tswitch runtime.GOARCH {\n+\tcase \"amd64\", \"386\":\n+\tdefault:\n+\t\tpanic(\"reflect.makeValueMethod not implemented for \" + runtime.GOARCH)\n+\t}\n+\n+\tt := typ.common()\n+\tftyp := (*funcType)(unsafe.Pointer(t))\n+\n+\t// Indirect Go func value (dummy) to obtain\n+\t// actual code address. (A Go func value is a pointer\n+\t// to a C function pointer. http://golang.org/s/go11func.)\n+\tdummy := makeFuncStub\n+\tcode := **(**uintptr)(unsafe.Pointer(&dummy))\n+\n+\timpl := &makeFuncImpl{\n+\t\tcode:   code,\n+\t\ttyp:    ftyp,\n+\t\tmethod: -2,\n+\t\trcvr:   v,\n+\t}\n+\n+\treturn Value{t, unsafe.Pointer(&impl), flag(Func<<flagKindShift) | flagIndir}\n+}\n+\n+// Call the function represented by a makeFuncImpl.\n+func (c *makeFuncImpl) call(in []Value) []Value {\n+\tif c.method == -1 {\n+\t\treturn c.fn(in)\n+\t} else if c.method == -2 {\n+\t\tif c.typ.IsVariadic() {\n+\t\t\treturn c.rcvr.CallSlice(in)\n+\t\t} else {\n+\t\t\treturn c.rcvr.Call(in)\n+\t\t}\n+\t} else {\n+\t\tm := c.rcvr.Method(c.method)\n+\t\tif c.typ.IsVariadic() {\n+\t\t\treturn m.CallSlice(in)\n+\t\t} else {\n+\t\t\treturn m.Call(in)\n+\t\t}\n+\t}\n }"}, {"sha": "71957b61b3dbc9cdbf3be58180fc5b47c2fc143f", "filename": "libgo/go/reflect/makefuncgo_386.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/547a4168791b7ae9543215aba3ca6184c31bb37e/libgo%2Fgo%2Freflect%2Fmakefuncgo_386.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/547a4168791b7ae9543215aba3ca6184c31bb37e/libgo%2Fgo%2Freflect%2Fmakefuncgo_386.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fmakefuncgo_386.go?ref=547a4168791b7ae9543215aba3ca6184c31bb37e", "patch": "@@ -80,7 +80,7 @@ func MakeFuncStubGo(regs *i386Regs, c *makeFuncImpl) {\n \n \t// Call the real function.\n \n-\tout := c.fn(in)\n+\tout := c.call(in)\n \n \tif len(out) != len(ftyp.out) {\n \t\tpanic(\"reflect: wrong return count from function created by MakeFunc\")"}, {"sha": "42fe03a9310894d2fbd0bebf745894d964b7aba1", "filename": "libgo/go/reflect/makefuncgo_amd64.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/547a4168791b7ae9543215aba3ca6184c31bb37e/libgo%2Fgo%2Freflect%2Fmakefuncgo_amd64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/547a4168791b7ae9543215aba3ca6184c31bb37e/libgo%2Fgo%2Freflect%2Fmakefuncgo_amd64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fmakefuncgo_amd64.go?ref=547a4168791b7ae9543215aba3ca6184c31bb37e", "patch": "@@ -319,7 +319,7 @@ argloop:\n \t// All the real arguments have been found and turned into\n \t// Value's.  Call the real function.\n \n-\tout := c.fn(in)\n+\tout := c.call(in)\n \n \tif len(out) != len(ftyp.out) {\n \t\tpanic(\"reflect: wrong return count from function created by MakeFunc\")"}, {"sha": "a930d64607a6942c93868788cfc130b4bc033e51", "filename": "libgo/go/reflect/type.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/547a4168791b7ae9543215aba3ca6184c31bb37e/libgo%2Fgo%2Freflect%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/547a4168791b7ae9543215aba3ca6184c31bb37e/libgo%2Fgo%2Freflect%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Ftype.go?ref=547a4168791b7ae9543215aba3ca6184c31bb37e", "patch": "@@ -517,7 +517,7 @@ func (t *uncommonType) Method(i int) (m Method) {\n \tm.Type = toType(mt)\n \tx := new(unsafe.Pointer)\n \t*x = unsafe.Pointer(&p.tfn)\n-\tm.Func = Value{mt, unsafe.Pointer(x), fl | flagIndir}\n+\tm.Func = Value{mt, unsafe.Pointer(x), fl | flagIndir | flagMethodFn}\n \tm.Index = i\n \treturn\n }"}, {"sha": "fc7dfae23d2ce9043b49cb88bcf0cc03c48f8718", "filename": "libgo/go/reflect/value.go", "status": "modified", "additions": 13, "deletions": 30, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/547a4168791b7ae9543215aba3ca6184c31bb37e/libgo%2Fgo%2Freflect%2Fvalue.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/547a4168791b7ae9543215aba3ca6184c31bb37e/libgo%2Fgo%2Freflect%2Fvalue.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fvalue.go?ref=547a4168791b7ae9543215aba3ca6184c31bb37e", "patch": "@@ -98,6 +98,7 @@ const (\n \tflagIndir\n \tflagAddr\n \tflagMethod\n+\tflagMethodFn         // gccgo: first fn parameter is always pointer\n \tflagKindShift        = iota\n \tflagKindWidth        = 5 // there are 27 kinds\n \tflagKindMask    flag = 1<<flagKindWidth - 1\n@@ -433,7 +434,7 @@ func (v Value) call(op string, in []Value) []Value {\n \tif v.flag&flagMethod != 0 {\n \t\tnin++\n \t}\n-\tfirstPointer := len(in) > 0 && t.In(0).Kind() != Ptr && v.flag&flagMethod == 0 && isMethod(v.typ)\n+\tfirstPointer := len(in) > 0 && t.In(0).Kind() != Ptr && v.flag&flagMethodFn != 0\n \tparams := make([]unsafe.Pointer, nin)\n \toff := 0\n \tif v.flag&flagMethod != 0 {\n@@ -484,33 +485,6 @@ func (v Value) call(op string, in []Value) []Value {\n \treturn ret\n }\n \n-// gccgo specific test to see if typ is a method.  We can tell by\n-// looking at the string to see if there is a receiver.  We need this\n-// because for gccgo all methods take pointer receivers.\n-func isMethod(t *rtype) bool {\n-\tif Kind(t.kind) != Func {\n-\t\treturn false\n-\t}\n-\ts := *t.string\n-\tparens := 0\n-\tparams := 0\n-\tsawRet := false\n-\tfor i, c := range s {\n-\t\tif c == '(' {\n-\t\t\tif parens == 0 {\n-\t\t\t\tparams++\n-\t\t\t}\n-\t\t\tparens++\n-\t\t} else if c == ')' {\n-\t\t\tparens--\n-\t\t} else if parens == 0 && c == ' ' && s[i+1] != '(' && !sawRet {\n-\t\t\tparams++\n-\t\t\tsawRet = true\n-\t\t}\n-\t}\n-\treturn params > 2\n-}\n-\n // methodReceiver returns information about the receiver\n // described by v. The Value v may or may not have the\n // flagMethod bit set, so the kind cached in v.flag should\n@@ -873,6 +847,16 @@ func valueInterface(v Value, safe bool) interface{} {\n \t\tv = makeMethodValue(\"Interface\", v)\n \t}\n \n+\tif v.flag&flagMethodFn != 0 {\n+\t\tif v.typ.Kind() != Func {\n+\t\t\tpanic(\"reflect: MethodFn of non-Func\")\n+\t\t}\n+\t\tft := (*funcType)(unsafe.Pointer(v.typ))\n+\t\tif ft.in[0].Kind() != Ptr {\n+\t\t\tv = makeValueMethod(v)\n+\t\t}\n+\t}\n+\n \tk := v.kind()\n \tif k == Interface {\n \t\t// Special case: return the element inside the interface.\n@@ -1187,8 +1171,7 @@ func (v Value) Pointer() uintptr {\n \t\t\t// created via reflect have the same underlying code pointer,\n \t\t\t// so their Pointers are equal. The function used here must\n \t\t\t// match the one used in makeMethodValue.\n-\t\t\t// This is not properly implemented for gccgo.\n-\t\t\tf := Zero\n+\t\t\tf := makeFuncStub\n \t\t\treturn **(**uintptr)(unsafe.Pointer(&f))\n \t\t}\n \t\tp := v.val"}, {"sha": "ceb9b572582d9680d660f7906fdc72e406130eb8", "filename": "libgo/runtime/go-recover.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/547a4168791b7ae9543215aba3ca6184c31bb37e/libgo%2Fruntime%2Fgo-recover.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/547a4168791b7ae9543215aba3ca6184c31bb37e/libgo%2Fruntime%2Fgo-recover.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-recover.c?ref=547a4168791b7ae9543215aba3ca6184c31bb37e", "patch": "@@ -84,6 +84,11 @@ __go_can_recover (const void *retaddr)\n   if (name[0] == 'f' && name[1] == 'f' && name[2] == 'i' && name[3] == '_')\n     return 1;\n \n+  /* We may also be called by reflect.makeFuncImpl.call, for a\n+     function created by reflect.MakeFunc.  */\n+  if (__builtin_strstr ((const char *) name, \"makeFuncImpl\") != NULL)\n+    return 1;\n+\n   return 0;\n }\n "}]}