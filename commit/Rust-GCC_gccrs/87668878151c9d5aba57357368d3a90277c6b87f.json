{"sha": "87668878151c9d5aba57357368d3a90277c6b87f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODc2Njg4NzgxNTFjOWQ1YWJhNTczNTczNjhkM2E5MDI3N2M2Yjg3Zg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2018-07-07T10:36:54Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2018-07-07T10:36:54Z"}, "message": "decl.c (gnat_to_gnu_entity): Add GNAT_DECL local variable and use it throughout.\n\n\t* gcc-interface/decl.c (gnat_to_gnu_entity): Add GNAT_DECL local\n\tvariable and use it throughout.\n\t<E_Variable>: If the nominal subtype of the object is unconstrained,\n\tcompute the Ada size separately and put in on the padding type if the\n\tsize is not fixed.\n\t<E_Record_Type>: Minor tweak.\n\t* gcc-interface/misc.c (gnat_type_max_size): Rename max_size_unit\n\tinto max_size_unit throughout.\n\nFrom-SVN: r262498", "tree": {"sha": "2ae3078df0700c2e8fd2ada470b8e1aa6dff0612", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2ae3078df0700c2e8fd2ada470b8e1aa6dff0612"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/87668878151c9d5aba57357368d3a90277c6b87f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87668878151c9d5aba57357368d3a90277c6b87f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87668878151c9d5aba57357368d3a90277c6b87f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87668878151c9d5aba57357368d3a90277c6b87f/comments", "author": null, "committer": null, "parents": [{"sha": "56b8aa0c875022911e96cbe3c9f87a98e4ecd76b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56b8aa0c875022911e96cbe3c9f87a98e4ecd76b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56b8aa0c875022911e96cbe3c9f87a98e4ecd76b"}], "stats": {"total": 155, "additions": 109, "deletions": 46}, "files": [{"sha": "ab7d5a178a677b2db64dfa5216576f7ff0767df4", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87668878151c9d5aba57357368d3a90277c6b87f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87668878151c9d5aba57357368d3a90277c6b87f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=87668878151c9d5aba57357368d3a90277c6b87f", "patch": "@@ -1,3 +1,14 @@\n+2018-07-07  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity): Add GNAT_DECL local\n+\tvariable and use it throughout.\n+\t<E_Variable>: If the nominal subtype of the object is unconstrained,\n+\tcompute the Ada size separately and put in on the padding type if the\n+\tsize is not fixed.\n+\t<E_Record_Type>: Minor tweak.\n+\t* gcc-interface/misc.c (gnat_type_max_size): Rename max_size_unit\n+\tinto max_size_unit throughout.\n+\n 2018-07-07  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/gigi.h (add_decl_expr): Adjust prototype."}, {"sha": "b98a4581b9304f57d34a04aab311a8e65342e524", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 54, "deletions": 38, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87668878151c9d5aba57357368d3a90277c6b87f/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87668878151c9d5aba57357368d3a90277c6b87f/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=87668878151c9d5aba57357368d3a90277c6b87f", "patch": "@@ -273,7 +273,9 @@ static bool intrin_profiles_compatible_p (intrin_binding_t *);\n tree\n gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n {\n-  /* Contains the kind of the input GNAT node.  */\n+  /* The construct that declared the entity.  */\n+  const Node_Id gnat_decl = Declaration_Node (gnat_entity);\n+  /* The kind of the entity.  */\n   const Entity_Kind kind = Ekind (gnat_entity);\n   /* True if this is a type.  */\n   const bool is_type = IN (kind, Type_Kind);\n@@ -578,7 +580,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n       if (definition\n \t  && !gnu_expr\n \t  && No (Address_Clause (gnat_entity))\n-\t  && !No_Initialization (Declaration_Node (gnat_entity))\n+\t  && !No_Initialization (gnat_decl)\n \t  && No (Renamed_Object (gnat_entity)))\n \t{\n \t  gnu_decl = error_mark_node;\n@@ -611,9 +613,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t may contain N_Expression_With_Actions nodes and thus declarations of\n \t objects from other units that we need to discard.  */\n       if (!definition\n-\t  && !No_Initialization (Declaration_Node (gnat_entity))\n+\t  && !No_Initialization (gnat_decl)\n \t  && !Is_Dispatch_Table_Entity (gnat_entity)\n-\t  && Present (gnat_temp = Expression (Declaration_Node (gnat_entity)))\n+\t  && Present (gnat_temp = Expression (gnat_decl))\n \t  && Nkind (gnat_temp) != N_Allocator\n \t  && (!type_annotate_only || Compile_Time_Known_Value (gnat_temp)))\n \tgnu_expr = gnat_to_gnu_external (gnat_temp);\n@@ -634,9 +636,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t     && !(kind == E_Variable\n \t\t  && Present (Linker_Section_Pragma (gnat_entity)))\n \t     && !Treat_As_Volatile (gnat_entity)\n-\t     && (((Nkind (Declaration_Node (gnat_entity))\n-\t\t   == N_Object_Declaration)\n-\t\t  && Present (Expression (Declaration_Node (gnat_entity))))\n+\t     && (((Nkind (gnat_decl) == N_Object_Declaration)\n+\t\t  && Present (Expression (gnat_decl)))\n \t\t || Present (Renamed_Object (gnat_entity))\n \t\t || imported_p));\n \tbool inner_const_flag = const_flag;\n@@ -650,7 +651,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \tbool used_by_ref = false;\n \ttree gnu_ext_name = NULL_TREE;\n \ttree renamed_obj = NULL_TREE;\n-\ttree gnu_object_size;\n+\ttree gnu_ada_size = NULL_TREE;\n \n \t/* We need to translate the renamed object even though we are only\n \t   referencing the renaming.  But it may contain a call for which\n@@ -755,8 +756,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t  {\n \t    if (gnu_expr && kind == E_Constant)\n \t      {\n-\t\ttree size = TYPE_SIZE (TREE_TYPE (gnu_expr));\n-\t\tif (CONTAINS_PLACEHOLDER_P (size))\n+\t\tgnu_size = TYPE_SIZE (TREE_TYPE (gnu_expr));\n+\t\tgnu_ada_size = TYPE_ADA_SIZE (TREE_TYPE (gnu_expr));\n+\t\tif (CONTAINS_PLACEHOLDER_P (gnu_size))\n \t\t  {\n \t\t    /* If the initializing expression is itself a constant,\n \t\t       despite having a nominal type with self-referential\n@@ -768,27 +770,38 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t\t&& (TREE_READONLY (TREE_OPERAND (gnu_expr, 0))\n \t\t\t    || DECL_READONLY_ONCE_ELAB\n \t\t\t       (TREE_OPERAND (gnu_expr, 0))))\n-\t\t      gnu_size = DECL_SIZE (TREE_OPERAND (gnu_expr, 0));\n+\t\t      {\n+\t\t\tgnu_size = DECL_SIZE (TREE_OPERAND (gnu_expr, 0));\n+\t\t\tgnu_ada_size = gnu_size;\n+\t\t      }\n \t\t    else\n-\t\t      gnu_size\n-\t\t\t= SUBSTITUTE_PLACEHOLDER_IN_EXPR (size, gnu_expr);\n+\t\t      {\n+\t\t\tgnu_size\n+\t\t\t  = SUBSTITUTE_PLACEHOLDER_IN_EXPR (gnu_size,\n+\t\t\t\t\t\t\t    gnu_expr);\n+\t\t\tgnu_ada_size\n+\t\t\t  = SUBSTITUTE_PLACEHOLDER_IN_EXPR (gnu_ada_size,\n+\t\t\t\t\t\t\t    gnu_expr);\n+\t\t      }\n \t\t  }\n-\t\telse\n-\t\t  gnu_size = size;\n \t      }\n \t    /* We may have no GNU_EXPR because No_Initialization is\n \t       set even though there's an Expression.  */\n \t    else if (kind == E_Constant\n-\t\t     && (Nkind (Declaration_Node (gnat_entity))\n-\t\t\t == N_Object_Declaration)\n-\t\t     && Present (Expression (Declaration_Node (gnat_entity))))\n-\t      gnu_size\n-\t\t= TYPE_SIZE (gnat_to_gnu_type\n-\t\t\t     (Etype\n-\t\t\t      (Expression (Declaration_Node (gnat_entity)))));\n+\t\t     && Nkind (gnat_decl) == N_Object_Declaration\n+\t\t     && Present (Expression (gnat_decl)))\n+\t      {\n+\t\ttree gnu_expr_type\n+\t\t  = gnat_to_gnu_type (Etype (Expression (gnat_decl)));\n+\t\tgnu_size = TYPE_SIZE (gnu_expr_type);\n+\t\tgnu_ada_size = TYPE_ADA_SIZE (gnu_expr_type);\n+\t      }\n \t    else\n \t      {\n \t\tgnu_size = max_size (TYPE_SIZE (gnu_type), true);\n+\t\t/* We can be called on unconstrained arrays in this mode.  */\n+\t\tif (!type_annotate_only)\n+\t\t  gnu_ada_size = max_size (TYPE_ADA_SIZE (gnu_type), true);\n \t\tmutable_p = true;\n \t      }\n \n@@ -904,14 +917,21 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t/* Make a new type with the desired size and alignment, if needed.\n \t   But do not take into account alignment promotions to compute the\n \t   size of the object.  */\n-\tgnu_object_size = gnu_size ? gnu_size : TYPE_SIZE (gnu_type);\n+\ttree gnu_object_size = gnu_size ? gnu_size : TYPE_SIZE (gnu_type);\n \tif (gnu_size || align > 0)\n \t  {\n \t    tree orig_type = gnu_type;\n \n \t    gnu_type = maybe_pad_type (gnu_type, gnu_size, align, gnat_entity,\n \t\t\t\t       false, false, definition, true);\n \n+\t    /* If the nominal subtype of the object is unconstrained and its\n+\t       size is not fixed, compute the Ada size from the Ada size of\n+\t       the subtype and/or the expression; this will make it possible\n+\t       for gnat_type_max_size to easily compute a maximum size.  */\n+\t    if (gnu_ada_size && gnu_size && !TREE_CONSTANT (gnu_size))\n+\t      SET_TYPE_ADA_SIZE (gnu_type, gnu_ada_size);\n+\n \t    /* If a padding record was made, declare it now since it will\n \t       never be declared otherwise.  This is necessary to ensure\n \t       that its subtrees are properly marked.  */\n@@ -2941,23 +2961,19 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n        the tree.  */\n \n     case E_Record_Type:\n-      if (Has_Complex_Representation (gnat_entity))\n-\t{\n-\t  gnu_type\n-\t    = build_complex_type\n-\t      (get_unpadded_type\n-\t       (Etype (Defining_Entity\n-\t\t       (First (Component_Items\n-\t\t\t       (Component_List\n-\t\t\t\t(Type_Definition\n-\t\t\t\t (Declaration_Node (gnat_entity)))))))));\n+      {\n+\tNode_Id record_definition = Type_Definition (gnat_decl);\n \n-\t  break;\n-\t}\n+\tif (Has_Complex_Representation (gnat_entity))\n+\t  {\n+\t    const Node_Id first_component\n+\t      = First (Component_Items (Component_List (record_definition)));\n+\t    tree gnu_component_type\n+\t      = get_unpadded_type (Etype (Defining_Entity (first_component)));\n+\t    gnu_type = build_complex_type (gnu_component_type);\n+\t    break;\n+\t  }\n \n-      {\n-\tNode_Id full_definition = Declaration_Node (gnat_entity);\n-\tNode_Id record_definition = Type_Definition (full_definition);\n \tNode_Id gnat_constr;\n \tEntity_Id gnat_field, gnat_parent_type;\n \ttree gnu_field, gnu_field_list = NULL_TREE;"}, {"sha": "0bcd385de72d7ca2a5239f0ba301955026b5aa1b", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87668878151c9d5aba57357368d3a90277c6b87f/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87668878151c9d5aba57357368d3a90277c6b87f/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=87668878151c9d5aba57357368d3a90277c6b87f", "patch": "@@ -736,25 +736,25 @@ gnat_type_max_size (const_tree gnu_type)\n   /* First see what we can get from TYPE_SIZE_UNIT, which might not\n      be constant even for simple expressions if it has already been\n      elaborated and possibly replaced by a VAR_DECL.  */\n-  tree max_unitsize = max_size (TYPE_SIZE_UNIT (gnu_type), true);\n+  tree max_size_unit = max_size (TYPE_SIZE_UNIT (gnu_type), true);\n \n   /* If we don't have a constant, try to look at attributes which should have\n      stayed untouched.  */\n-  if (!tree_fits_uhwi_p (max_unitsize))\n+  if (!tree_fits_uhwi_p (max_size_unit))\n     {\n       /* For record types, see what we can get from TYPE_ADA_SIZE.  */\n       if (RECORD_OR_UNION_TYPE_P (gnu_type)\n \t  && !TYPE_FAT_POINTER_P (gnu_type)\n \t  && TYPE_ADA_SIZE (gnu_type))\n \t{\n-\t  tree max_adasize = max_size (TYPE_ADA_SIZE (gnu_type), true);\n+\t  tree max_ada_size = max_size (TYPE_ADA_SIZE (gnu_type), true);\n \n \t  /* If we have succeeded in finding a constant, round it up to the\n \t     type's alignment and return the result in units.  */\n-\t  if (tree_fits_uhwi_p (max_adasize))\n-\t    max_unitsize\n+\t  if (tree_fits_uhwi_p (max_ada_size))\n+\t    max_size_unit\n \t      = size_binop (CEIL_DIV_EXPR,\n-\t\t\t    round_up (max_adasize, TYPE_ALIGN (gnu_type)),\n+\t\t\t    round_up (max_ada_size, TYPE_ALIGN (gnu_type)),\n \t\t\t    bitsize_unit_node);\n \t}\n \n@@ -784,7 +784,7 @@ gnat_type_max_size (const_tree gnu_type)\n \t\t    = fold_build2 (PLUS_EXPR, ctype,\n \t\t\t\t   fold_build2 (MINUS_EXPR, ctype, hb, lb),\n \t\t\t\t   build_int_cst (ctype, 1));\n-\t\t  max_unitsize\n+\t\t  max_size_unit\n \t\t    = fold_build2 (MULT_EXPR, sizetype,\n \t\t\t\t   fold_convert (sizetype, length),\n \t\t\t\t   TYPE_SIZE_UNIT (TREE_TYPE (gnu_type)));\n@@ -793,7 +793,7 @@ gnat_type_max_size (const_tree gnu_type)\n \t}\n     }\n \n-  return max_unitsize;\n+  return max_size_unit;\n }\n \n static tree get_array_bit_stride (tree);"}, {"sha": "1534e922320b0c32cf0e01e8d50261f9046c2ea7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87668878151c9d5aba57357368d3a90277c6b87f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87668878151c9d5aba57357368d3a90277c6b87f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=87668878151c9d5aba57357368d3a90277c6b87f", "patch": "@@ -1,3 +1,8 @@\n+2018-07-07  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/stack_usage6.adb: New test.\n+\t* gnat.dg/stack_usage6_pkg.ads: New helper.\n+\n 2018-07-07  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/pure_function3a.adb: New test."}, {"sha": "d02da6ced258fe2b7f7bc4bb2ba55a76f15b8270", "filename": "gcc/testsuite/gnat.dg/stack_usage6.adb", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87668878151c9d5aba57357368d3a90277c6b87f/gcc%2Ftestsuite%2Fgnat.dg%2Fstack_usage6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87668878151c9d5aba57357368d3a90277c6b87f/gcc%2Ftestsuite%2Fgnat.dg%2Fstack_usage6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fstack_usage6.adb?ref=87668878151c9d5aba57357368d3a90277c6b87f", "patch": "@@ -0,0 +1,12 @@\n+-- { dg-do compile }\n+-- { dg-options \"-Wstack-usage=512\" }\n+\n+with Stack_Usage6_Pkg; use Stack_Usage6_Pkg;\n+\n+procedure Stack_Usage6 (I : Index_Type) is\n+   R : constant Rec := A (I);\n+begin\n+   if R.D then\n+     raise Program_Error;\n+   end if;\n+end;"}, {"sha": "f855376fbd00569461fa264864fded1ee731f50d", "filename": "gcc/testsuite/gnat.dg/stack_usage6_pkg.ads", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87668878151c9d5aba57357368d3a90277c6b87f/gcc%2Ftestsuite%2Fgnat.dg%2Fstack_usage6_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87668878151c9d5aba57357368d3a90277c6b87f/gcc%2Ftestsuite%2Fgnat.dg%2Fstack_usage6_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fstack_usage6_pkg.ads?ref=87668878151c9d5aba57357368d3a90277c6b87f", "patch": "@@ -0,0 +1,19 @@\n+package Stack_Usage6_Pkg is\n+\n+   type Rec (D : Boolean := False) is record\n+      case D is\n+         when False =>\n+            Foo : Integer;\n+            Bar : Integer;\n+         when True =>\n+            null;\n+      end case;\n+   end record;\n+\n+   type Index_Type is new Integer range 0 .. 5;\n+\n+   type Arr is array (Index_Type) of Rec;\n+\n+   A : Arr;\n+   \n+end Stack_Usage6_Pkg;"}]}