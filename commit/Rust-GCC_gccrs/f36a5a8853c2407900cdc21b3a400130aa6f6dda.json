{"sha": "f36a5a8853c2407900cdc21b3a400130aa6f6dda", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjM2YTVhODg1M2MyNDA3OTAwY2RjMjFiM2E0MDAxMzBhYTZmNmRkYQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@nildram.co.uk", "date": "2008-01-30T11:18:27Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2008-01-30T11:18:27Z"}, "message": "re PR rtl-optimization/34998 (gcc.c-torture/execute/20040709-1.c fails for -EL -mips16 -O3)\n\ngcc/\n\tPR rtl-optimization/34998\n\t* global.c (build_insn_chain): Treat non-subreg_lowpart\n\tSUBREGs of pseudos as clobbering all the words covered by the\n\tSUBREG, not just all the bytes.\n\t* ra-conflict.c (clear_reg_in_live): Likewise.  Take the\n\toriginal df_ref rather than an extract parameter.\n\t(global_conflicts): Update call accordingly.\n\nFrom-SVN: r131960", "tree": {"sha": "6593f73075d1b463fa35f873cbf27a2fb1776eb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6593f73075d1b463fa35f873cbf27a2fb1776eb3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f36a5a8853c2407900cdc21b3a400130aa6f6dda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f36a5a8853c2407900cdc21b3a400130aa6f6dda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f36a5a8853c2407900cdc21b3a400130aa6f6dda", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f36a5a8853c2407900cdc21b3a400130aa6f6dda/comments", "author": null, "committer": null, "parents": [{"sha": "393c005884c547ee6d4cebb2fb938e6214714e9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/393c005884c547ee6d4cebb2fb938e6214714e9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/393c005884c547ee6d4cebb2fb938e6214714e9e"}], "stats": {"total": 46, "additions": 37, "deletions": 9}, "files": [{"sha": "f2021d2c51ad73353f661a163735f0e1e159feb4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f36a5a8853c2407900cdc21b3a400130aa6f6dda/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f36a5a8853c2407900cdc21b3a400130aa6f6dda/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f36a5a8853c2407900cdc21b3a400130aa6f6dda", "patch": "@@ -1,3 +1,13 @@\n+2008-01-30  Richard Sandiford  <rsandifo@nildram.co.uk>\n+\n+\tPR rtl-optimization/34998\n+\t* global.c (build_insn_chain): Treat non-subreg_lowpart\n+\tSUBREGs of pseudos as clobbering all the words covered by the\n+\tSUBREG, not just all the bytes.\n+\t* ra-conflict.c (clear_reg_in_live): Likewise.  Take the\n+\toriginal df_ref rather than an extract parameter.\n+\t(global_conflicts): Update call accordingly.\n+\n 2008-01-30  Andreas Krebbel  <krebbel1@de.ibm.com>\n \n \t* config/s390/fixdfdi.h (__fixunstfdi, __fixtfdi): Rearrange"}, {"sha": "12641a60cba593f782417be9274fccdf64c4ee8c", "filename": "gcc/global.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f36a5a8853c2407900cdc21b3a400130aa6f6dda/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f36a5a8853c2407900cdc21b3a400130aa6f6dda/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=f36a5a8853c2407900cdc21b3a400130aa6f6dda", "patch": "@@ -1501,6 +1501,17 @@ build_insn_chain (void)\n \t\t\t\t\t\t  live_subregs, \n \t\t\t\t\t\t  live_subregs_used,\n \t\t\t\t\t\t  regno, reg);\n+\n+\t\t\t    if (!DF_REF_FLAGS_IS_SET\n+\t\t\t\t(def, DF_REF_STRICT_LOWER_PART))\n+\t\t\t      {\n+\t\t\t\t/* Expand the range to cover entire words.\n+\t\t\t\t   Bytes added here are \"don't care\".  */\n+\t\t\t\tstart = start / UNITS_PER_WORD * UNITS_PER_WORD;\n+\t\t\t\tlast = ((last + UNITS_PER_WORD - 1)\n+\t\t\t\t\t/ UNITS_PER_WORD * UNITS_PER_WORD);\n+\t\t\t      }\n+\n \t\t\t    /* Ignore the paradoxical bits.  */\n \t\t\t    if ((int)last > live_subregs_used[regno])\n \t\t\t      last = live_subregs_used[regno];"}, {"sha": "78d4f9246f07935201361bb5ff82ed719b087067", "filename": "gcc/ra-conflict.c", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f36a5a8853c2407900cdc21b3a400130aa6f6dda/gcc%2Fra-conflict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f36a5a8853c2407900cdc21b3a400130aa6f6dda/gcc%2Fra-conflict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-conflict.c?ref=f36a5a8853c2407900cdc21b3a400130aa6f6dda", "patch": "@@ -441,32 +441,39 @@ ra_init_live_subregs (bool init_value,\n \n \n /* Set REG to be not live in the sets ALLOCNOS_LIVE, LIVE_SUBREGS,\n-   HARD_REGS_LIVE.  If EXTRACT is false, assume that the entire reg is\n-   set not live even if REG is a subreg.  */\n+   HARD_REGS_LIVE.  DEF is the definition of the register.  */\n \n inline static void\n clear_reg_in_live (sparseset allocnos_live,\n \t\t   sbitmap *live_subregs, \n \t\t   int *live_subregs_used,\n \t\t   HARD_REG_SET *hard_regs_live, \n-\t\t   rtx reg,\n-\t\t   bool extract)\n+\t\t   rtx reg, struct df_ref *def)\n {\n   unsigned int regno = (GET_CODE (reg) == SUBREG) \n     ? REGNO (SUBREG_REG (reg)): REGNO (reg);\n   int allocnum = reg_allocno[regno];\n \n   if (allocnum >= 0)\n     {\n-      if ((GET_CODE (reg) == SUBREG) && !extract)\n-\n+      if (GET_CODE (reg) == SUBREG\n+\t  && !DF_REF_FLAGS_IS_SET (def, DF_REF_EXTRACT))\n \t{\n \t  unsigned int start = SUBREG_BYTE (reg);\n \t  unsigned int last = start + GET_MODE_SIZE (GET_MODE (reg));\n \n \t  ra_init_live_subregs (sparseset_bit_p (allocnos_live, allocnum), \n \t\t\t\tlive_subregs, live_subregs_used, allocnum, reg);\n \n+\t  if (!DF_REF_FLAGS_IS_SET (def, DF_REF_STRICT_LOWER_PART))\n+\t    {\n+\t      /* Expand the range to cover entire words.\n+\t\t Bytes added here are \"don't care\".  */\n+\t      start = start / UNITS_PER_WORD * UNITS_PER_WORD;\n+\t      last = ((last + UNITS_PER_WORD - 1)\n+\t\t      / UNITS_PER_WORD * UNITS_PER_WORD);\n+\t    }\n+\n \t  /* Ignore the paradoxical bits.  */\n \t  if ((int)last > live_subregs_used[allocnum])\n \t    last = live_subregs_used[allocnum];\n@@ -503,7 +510,8 @@ clear_reg_in_live (sparseset allocnos_live,\n   if (! fixed_regs[regno])\n     {\n       unsigned int start = regno;\n-      if ((GET_CODE (reg) == SUBREG) && !extract)\n+      if (GET_CODE (reg) == SUBREG\n+\t  && !DF_REF_FLAGS_IS_SET (def, DF_REF_EXTRACT))\n \t{\n \t  unsigned int last;\n \t  start += SUBREG_BYTE (reg);\n@@ -890,8 +898,7 @@ global_conflicts (void)\n \t\t  rtx reg = DF_REF_REG (def);\n \n \t\t  clear_reg_in_live (allocnos_live, live_subregs, live_subregs_used,\n-\t\t\t\t     &hard_regs_live, reg,\n-\t\t\t\t     DF_REF_FLAGS_IS_SET (def, DF_REF_EXTRACT));\n+\t\t\t\t     &hard_regs_live, reg, def);\n \t\t  if (dump_file)\n \t\t    dump_ref (dump_file, \"  clearing def\", \"\\n\", \n \t\t\t      reg, DF_REF_REGNO (def), live_subregs, live_subregs_used);"}]}