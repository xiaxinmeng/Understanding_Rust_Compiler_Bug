{"sha": "6e4d01d61f2bec57a247de1c5ee538f122ec34a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmU0ZDAxZDYxZjJiZWM1N2EyNDdkZTFjNWVlNTM4ZjEyMmVjMzRhOA==", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2019-12-06T13:06:53Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2019-12-06T13:06:53Z"}, "message": "[OpenMP/OpenACC/Fortran] Fix mapping of optional (present|absent) arguments\n\n2019-12-06  Tobias Burnus  <tobias@codesourcery.com>\n            Kwok Cheung Yeung <kcy@codesourcery.com>\n\n        gcc/fortran/\n        * trans-openmp.c (gfc_build_conditional_assign,\n        gfc_build_conditional_assign_expr): New static functions.\n        (gfc_omp_finish_clause, gfc_trans_omp_clauses): Handle mapping of\n        absent optional arguments and fix mapping of present optional args.\n\n        gcc/\n        * omp-low.c (lower_omp_target): For optional arguments, deref once\n        more to obtain the type.\n\n        libgomp/\n        * oacc-mem.c (update_dev_host, gomp_acc_insert_pointer): Just return\n        if input it a NULL pointer.\n        * testsuite/libgomp.oacc-c-c++-common/lib-43.c: Remove; dependent on\n        diagnostic of NULL pointer.\n        * testsuite/libgomp.oacc-c-c++-common/lib-47.c: Ditto.\n        * testsuite/libgomp.fortran/optional-map.f90: New.\n        * testsuite/libgomp.fortran/use_device_addr-1.f90\n        (test_dummy_opt_callee_1_absent): New.\n        (test_dummy_opt_call_1): Call it.\n        * testsuite/libgomp.fortran/use_device_addr-2.f90: Likewise.\n        * testsuite/libgomp.fortran/use_device_addr-3.f90: Likewise.\n        * testsuite/libgomp.fortran/use_device_addr-4.f90: Likewise.\n        * testsuite/libgomp.oacc-fortran/optional-cache.f95: New.\n        * testsuite/libgomp.oacc-fortran/optional-data-copyin-by-value.f90: New.\n        * testsuite/libgomp.oacc-fortran/optional-data-copyin.f90: New.\n        * testsuite/libgomp.oacc-fortran/optional-data-copyout.f90: New.\n        * testsuite/libgomp.oacc-fortran/optional-data-enter-exit.f90: New.\n        * testsuite/libgomp.oacc-fortran/optional-declare.f90: New.\n        * testsuite/libgomp.oacc-fortran/optional-firstprivate.f90: New.\n        * testsuite/libgomp.oacc-fortran/optional-host_data.f90: New.\n        * testsuite/libgomp.oacc-fortran/optional-nested-calls.f90: New.\n        * testsuite/libgomp.oacc-fortran/optional-private.f90: New.\n        * testsuite/libgomp.oacc-fortran/optional-reduction.f90: New.\n        * testsuite/libgomp.oacc-fortran/optional-update-device.f90: New.\n        * testsuite/libgomp.oacc-fortran/optional-update-host.f90: New.\n\n\nCo-Authored-By: Kwok Cheung Yeung <kcy@codesourcery.com>\n\nFrom-SVN: r279043", "tree": {"sha": "ca87082ee159a2583e98c36758a14a6e66b9b9c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca87082ee159a2583e98c36758a14a6e66b9b9c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e4d01d61f2bec57a247de1c5ee538f122ec34a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e4d01d61f2bec57a247de1c5ee538f122ec34a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e4d01d61f2bec57a247de1c5ee538f122ec34a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e150da383346adc762bc904342f9877f2f071265", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e150da383346adc762bc904342f9877f2f071265", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e150da383346adc762bc904342f9877f2f071265"}], "stats": {"total": 1784, "additions": 1672, "deletions": 112}, "files": [{"sha": "ed7878c8d2338b9f4a79ce215e3d129721041bee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6e4d01d61f2bec57a247de1c5ee538f122ec34a8", "patch": "@@ -1,3 +1,9 @@\n+2019-12-06  Tobias Burnus  <tobias@codesourcery.com>\n+\t    Kwok Cheung Yeung <kcy@codesourcery.com>\n+\n+\t* omp-low.c (lower_omp_target): For optional arguments, deref once\n+\tmore to obtain the type.\n+\n 2019-12-06  Richard Biener  <rguenther@suse.de>\n \n \t* match.pd (nop_convert): Remove empty match.  Use nop_convert?"}, {"sha": "682a10c88690ee07dd5d6ef5a9b113dfca301357", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=6e4d01d61f2bec57a247de1c5ee538f122ec34a8", "patch": "@@ -1,3 +1,11 @@\n+2019-12-06  Tobias Burnus  <tobias@codesourcery.com>\n+\t    Kwok Cheung Yeung <kcy@codesourcery.com>\n+\n+\t* trans-openmp.c (gfc_build_conditional_assign, \n+\tgfc_build_conditional_assign_expr): New static functions.\n+\t(gfc_omp_finish_clause, gfc_trans_omp_clauses): Handle mapping of\n+\tabsent optional arguments and fix mapping of present optional args.\n+\n 2019-12-05  Tobias Burnus  <tobias@codesourcery.com>\n \n \t* trans-openmp.c (gfc_omp_is_optional_argument,"}, {"sha": "0649a34b9eb21d1b51a226f25c6bae0cc3431549", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 199, "deletions": 11, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=6e4d01d61f2bec57a247de1c5ee538f122ec34a8", "patch": "@@ -1180,6 +1180,59 @@ gfc_omp_clause_dtor (tree clause, tree decl)\n   return tem;\n }\n \n+/* Build a conditional expression in BLOCK.  If COND_VAL is not\n+   null, then the block THEN_B is executed, otherwise ELSE_VAL\n+   is assigned to VAL.  */\n+\n+static void\n+gfc_build_cond_assign (stmtblock_t *block, tree val, tree cond_val,\n+\t\t       tree then_b, tree else_val)\n+{\n+  stmtblock_t cond_block;\n+  tree cond, else_b = NULL_TREE;\n+  tree val_ty = TREE_TYPE (val);\n+\n+  if (else_val)\n+    {\n+      gfc_init_block (&cond_block);\n+      gfc_add_modify (&cond_block, val, fold_convert (val_ty, else_val));\n+      else_b = gfc_finish_block (&cond_block);\n+    }\n+  cond = fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t  logical_type_node,\n+\t\t\t  cond_val, null_pointer_node);\n+  gfc_add_expr_to_block (block,\n+\t\t\t build3_loc (input_location,\n+\t\t\t\t     COND_EXPR,\n+\t\t\t\t     void_type_node,\n+\t\t\t\t     cond, then_b,\n+\t\t\t\t     else_b));\n+}\n+\n+/* Build a conditional expression in BLOCK, returning a temporary\n+   variable containing the result.  If COND_VAL is not null, then\n+   THEN_VAL will be assigned to the variable, otherwise ELSE_VAL\n+   is assigned.\n+ */\n+\n+static tree\n+gfc_build_cond_assign_expr (stmtblock_t *block, tree cond_val,\n+\t\t\t    tree then_val, tree else_val)\n+{\n+  tree val;\n+  tree val_ty = TREE_TYPE (then_val);\n+  stmtblock_t cond_block;\n+\n+  val = create_tmp_var (val_ty);\n+\n+  gfc_init_block (&cond_block);\n+  gfc_add_modify (&cond_block, val, then_val);\n+  tree then_b = gfc_finish_block (&cond_block);\n+\n+  gfc_build_cond_assign (block, val, cond_val, then_b, else_val);\n+\n+  return val;\n+}\n \n void\n gfc_omp_finish_clause (tree c, gimple_seq *pre_p)\n@@ -1204,6 +1257,8 @@ gfc_omp_finish_clause (tree c, gimple_seq *pre_p)\n     }\n \n   tree c2 = NULL_TREE, c3 = NULL_TREE, c4 = NULL_TREE;\n+  tree present = (gfc_omp_is_optional_argument (decl)\n+\t\t  ? gfc_omp_check_optional_argument (decl, true) : NULL_TREE);\n   if (POINTER_TYPE_P (TREE_TYPE (decl)))\n     {\n       if (!gfc_omp_privatize_by_reference (decl)\n@@ -1218,8 +1273,30 @@ gfc_omp_finish_clause (tree c, gimple_seq *pre_p)\n       OMP_CLAUSE_DECL (c4) = decl;\n       OMP_CLAUSE_SIZE (c4) = size_int (0);\n       decl = build_fold_indirect_ref (decl);\n-      OMP_CLAUSE_DECL (c) = decl;\n-      OMP_CLAUSE_SIZE (c) = NULL_TREE;\n+      if (present\n+\t  && (GFC_DECL_GET_SCALAR_POINTER (orig_decl)\n+\t      || GFC_DECL_GET_SCALAR_ALLOCATABLE (orig_decl)))\n+\t{\n+\t  c2 = build_omp_clause (input_location, OMP_CLAUSE_MAP);\n+\t  OMP_CLAUSE_SET_MAP_KIND (c2, GOMP_MAP_POINTER);\n+\t  OMP_CLAUSE_DECL (c2) = decl;\n+\t  OMP_CLAUSE_SIZE (c2) = size_int (0);\n+\n+\t  stmtblock_t block;\n+\t  gfc_start_block (&block);\n+\t  tree ptr = decl;\n+\t  ptr = gfc_build_cond_assign_expr (&block, present, decl,\n+\t\t\t\t\t    null_pointer_node);\n+\t  gimplify_and_add (gfc_finish_block (&block), pre_p);\n+\t  ptr = build_fold_indirect_ref (ptr);\n+\t  OMP_CLAUSE_DECL (c) = ptr;\n+\t  OMP_CLAUSE_SIZE (c) = TYPE_SIZE_UNIT (TREE_TYPE (ptr));\n+\t}\n+      else\n+\t{\n+\t  OMP_CLAUSE_DECL (c) = decl;\n+\t  OMP_CLAUSE_SIZE (c) = NULL_TREE;\n+\t}\n       if (TREE_CODE (TREE_TYPE (orig_decl)) == REFERENCE_TYPE\n \t  && (GFC_DECL_GET_SCALAR_POINTER (orig_decl)\n \t      || GFC_DECL_GET_SCALAR_ALLOCATABLE (orig_decl)))\n@@ -1238,16 +1315,38 @@ gfc_omp_finish_clause (tree c, gimple_seq *pre_p)\n       gfc_start_block (&block);\n       tree type = TREE_TYPE (decl);\n       tree ptr = gfc_conv_descriptor_data_get (decl);\n+\n+      if (present)\n+\tptr = gfc_build_cond_assign_expr (&block, present, ptr,\n+\t\t\t\t\t  null_pointer_node);\n       ptr = fold_convert (build_pointer_type (char_type_node), ptr);\n       ptr = build_fold_indirect_ref (ptr);\n       OMP_CLAUSE_DECL (c) = ptr;\n       c2 = build_omp_clause (input_location, OMP_CLAUSE_MAP);\n       OMP_CLAUSE_SET_MAP_KIND (c2, GOMP_MAP_TO_PSET);\n-      OMP_CLAUSE_DECL (c2) = decl;\n+      if (present)\n+\t{\n+\t  ptr = create_tmp_var (TREE_TYPE (TREE_OPERAND (decl, 0)));\n+\t  gfc_add_modify (&block, ptr, TREE_OPERAND (decl, 0));\n+\n+\t  OMP_CLAUSE_DECL (c2) = build_fold_indirect_ref (ptr);\n+\t}\n+      else\n+\tOMP_CLAUSE_DECL (c2) = decl;\n       OMP_CLAUSE_SIZE (c2) = TYPE_SIZE_UNIT (type);\n       c3 = build_omp_clause (OMP_CLAUSE_LOCATION (c), OMP_CLAUSE_MAP);\n       OMP_CLAUSE_SET_MAP_KIND (c3, GOMP_MAP_POINTER);\n-      OMP_CLAUSE_DECL (c3) = gfc_conv_descriptor_data_get (decl);\n+      if (present)\n+\t{\n+\t  ptr = gfc_conv_descriptor_data_get (decl);\n+\t  ptr = gfc_build_addr_expr (NULL, ptr);\n+\t  ptr = gfc_build_cond_assign_expr (&block, present,\n+\t\t\t\t\t    ptr, null_pointer_node);\n+\t  ptr = build_fold_indirect_ref (ptr);\n+\t  OMP_CLAUSE_DECL (c3) = ptr;\n+\t}\n+      else\n+\tOMP_CLAUSE_DECL (c3) = gfc_conv_descriptor_data_get (decl);\n       OMP_CLAUSE_SIZE (c3) = size_int (0);\n       tree size = create_tmp_var (gfc_array_index_type);\n       tree elemsz = TYPE_SIZE_UNIT (gfc_get_element_type (type));\n@@ -1273,11 +1372,35 @@ gfc_omp_finish_clause (tree c, gimple_seq *pre_p)\n \t  tem = gfc_conv_descriptor_data_get (decl);\n \t  tem = fold_convert (pvoid_type_node, tem);\n \t  cond = fold_build2_loc (input_location, NE_EXPR,\n-\t\t\t\t  logical_type_node, tem, null_pointer_node);\n+\t\t\t\t  boolean_type_node, tem, null_pointer_node);\n+\t  if (present)\n+\t    {\n+\t      tem = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t\t     present, null_pointer_node);\n+\t      cond = fold_build2_loc (input_location, TRUTH_ANDIF_EXPR,\n+\t\t\t\t      boolean_type_node, tem, cond);\n+\t    }\n \t  gfc_add_expr_to_block (&block, build3_loc (input_location, COND_EXPR,\n \t\t\t\t\t\t     void_type_node, cond,\n \t\t\t\t\t\t     then_b, else_b));\n \t}\n+      else if (present)\n+\t{\n+\t  stmtblock_t cond_block;\n+\t  tree then_b;\n+\n+\t  gfc_init_block (&cond_block);\n+\t  gfc_add_modify (&cond_block, size,\n+\t\t\t  gfc_full_array_size (&cond_block, decl,\n+\t\t\t\t\t       GFC_TYPE_ARRAY_RANK (type)));\n+\t  gfc_add_modify (&cond_block, size,\n+\t\t\t  fold_build2 (MULT_EXPR, gfc_array_index_type,\n+\t\t\t\t       size, elemsz));\n+\t  then_b = gfc_finish_block (&cond_block);\n+\n+\t  gfc_build_cond_assign (&block, size, present, then_b,\n+\t\t\t\t build_int_cst (gfc_array_index_type, 0));\n+\t}\n       else\n \t{\n \t  gfc_add_modify (&block, size,\n@@ -2257,6 +2380,9 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\tTREE_ADDRESSABLE (decl) = 1;\n \t      if (n->expr == NULL || n->expr->ref->u.ar.type == AR_FULL)\n \t\t{\n+\t\t  tree present = (gfc_omp_is_optional_argument (decl)\n+\t\t\t\t  ? gfc_omp_check_optional_argument (decl, true)\n+\t\t\t\t  : NULL_TREE);\n \t\t  if (POINTER_TYPE_P (TREE_TYPE (decl))\n \t\t      && (gfc_omp_privatize_by_reference (decl)\n \t\t\t  || GFC_DECL_GET_SCALAR_POINTER (decl)\n@@ -2289,6 +2415,9 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t    {\n \t\t      tree type = TREE_TYPE (decl);\n \t\t      tree ptr = gfc_conv_descriptor_data_get (decl);\n+\t\t      if (present)\n+\t\t\tptr = gfc_build_cond_assign_expr (block, present, ptr,\n+\t\t\t\t\t\t\t  null_pointer_node);\n \t\t      ptr = fold_convert (build_pointer_type (char_type_node),\n \t\t\t\t\t  ptr);\n \t\t      ptr = build_fold_indirect_ref (ptr);\n@@ -2301,8 +2430,18 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t      node3 = build_omp_clause (input_location,\n \t\t\t\t\t\tOMP_CLAUSE_MAP);\n \t\t      OMP_CLAUSE_SET_MAP_KIND (node3, GOMP_MAP_POINTER);\n-\t\t      OMP_CLAUSE_DECL (node3)\n-\t\t\t= gfc_conv_descriptor_data_get (decl);\n+\t\t      if (present)\n+\t\t\t{\n+\t\t\t  ptr = gfc_conv_descriptor_data_get (decl);\n+\t\t\t  ptr = gfc_build_addr_expr (NULL, ptr);\n+\t\t\t  ptr = gfc_build_cond_assign_expr (block, present, ptr,\n+\t\t\t\t\t\t\t    null_pointer_node);\n+\t\t\t  ptr = build_fold_indirect_ref (ptr);\n+\t\t\t  OMP_CLAUSE_DECL (node3) = ptr;\n+\t\t\t}\n+\t\t      else\n+\t\t\tOMP_CLAUSE_DECL (node3)\n+\t\t\t  = gfc_conv_descriptor_data_get (decl);\n \t\t      OMP_CLAUSE_SIZE (node3) = size_int (0);\n \n \t\t      /* We have to check for n->sym->attr.dimension because\n@@ -2327,8 +2466,20 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t\t  tem = gfc_conv_descriptor_data_get (decl);\n \t\t\t  tem = fold_convert (pvoid_type_node, tem);\n \t\t\t  cond = fold_build2_loc (input_location, NE_EXPR,\n-\t\t\t\t\t\t  logical_type_node,\n+\t\t\t\t\t\t  boolean_type_node,\n \t\t\t\t\t\t  tem, null_pointer_node);\n+\t\t\t  if (present)\n+\t\t\t    {\n+\t\t\t      tree tmp = fold_build2_loc (input_location,\n+\t\t\t\t\t\t\t  NE_EXPR,\n+\t\t\t\t\t\t\t  boolean_type_node,\n+\t\t\t\t\t\t\t  present,\n+\t\t\t\t\t\t\t  null_pointer_node);\n+\t\t\t      cond = fold_build2_loc (input_location,\n+\t\t\t\t\t\t      TRUTH_ANDIF_EXPR,\n+\t\t\t\t\t\t      boolean_type_node,\n+\t\t\t\t\t\t      tmp, cond);\n+\t\t\t    }\n \t\t\t  gfc_add_expr_to_block (block,\n \t\t\t\t\t\t build3_loc (input_location,\n \t\t\t\t\t\t\t     COND_EXPR,\n@@ -2338,9 +2489,34 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t\t  OMP_CLAUSE_SIZE (node) = size;\n \t\t\t}\n \t\t      else if (n->sym->attr.dimension)\n-\t\t\tOMP_CLAUSE_SIZE (node)\n-\t\t\t  = gfc_full_array_size (block, decl,\n-\t\t\t\t\t\t GFC_TYPE_ARRAY_RANK (type));\n+\t\t\t{\n+\t\t\t  stmtblock_t cond_block;\n+\t\t\t  gfc_init_block (&cond_block);\n+\t\t\t  tree size = gfc_full_array_size (&cond_block, decl,\n+\t\t\t\t\tGFC_TYPE_ARRAY_RANK (type));\n+\t\t\t  if (present)\n+\t\t\t    {\n+\t\t\t      tree var = gfc_create_var (gfc_array_index_type,\n+\t\t\t\t\t\t\t NULL);\n+\t\t\t      tree cond = fold_build2_loc (input_location,\n+\t\t\t\t\t\t\t   NE_EXPR,\n+\t\t\t\t\t\t\t   boolean_type_node,\n+\t\t\t\t\t\t\t   present,\n+\t\t\t\t\t\t\t   null_pointer_node);\n+\t\t\t      gfc_add_modify (&cond_block, var, size);\n+\t\t\t      cond = build3_loc (input_location, COND_EXPR,\n+\t\t\t\t\t\t void_type_node, cond,\n+\t\t\t\t\t\t gfc_finish_block (&cond_block),\n+\t\t\t\t\t\t NULL_TREE);\n+\t\t\t      gfc_add_expr_to_block (block, cond);\n+\t\t\t      OMP_CLAUSE_SIZE (node) = var;\n+\t\t\t    }\n+\t\t\t  else\n+\t\t\t    {\n+\t\t\t      gfc_add_block_to_block (block, &cond_block);\n+\t\t\t      OMP_CLAUSE_SIZE (node) = size;\n+\t\t\t    }\n+\t\t\t}\n \t\t      if (n->sym->attr.dimension)\n \t\t\t{\n \t\t\t  tree elemsz\n@@ -2351,6 +2527,18 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t\t\t\t   OMP_CLAUSE_SIZE (node), elemsz);\n \t\t\t}\n \t\t    }\n+\t\t  else if (present\n+\t\t\t   && TREE_CODE (decl) == INDIRECT_REF\n+\t\t\t   && (TREE_CODE (TREE_OPERAND (decl, 0))\n+\t\t\t       == INDIRECT_REF))\n+\t\t    {\n+\t\t      /* A single indirectref is handled by the middle end.  */\n+\t\t      gcc_assert (!POINTER_TYPE_P (TREE_TYPE (decl)));\n+\t\t      decl = TREE_OPERAND (decl, 0);\n+\t\t      decl = gfc_build_cond_assign_expr (block, present, decl,\n+\t\t\t\t\t\t\t null_pointer_node);\n+\t\t      OMP_CLAUSE_DECL (node) = build_fold_indirect_ref (decl);\n+\t\t    }\n \t\t  else\n \t\t    OMP_CLAUSE_DECL (node) = decl;\n \t\t}"}, {"sha": "ad26f7918a5485ffbd07f93aa90b878245ceaabc", "filename": "gcc/omp-low.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=6e4d01d61f2bec57a247de1c5ee538f122ec34a8", "patch": "@@ -11817,7 +11817,8 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t      {\n \t\tgcc_checking_assert (is_gimple_omp_oacc (ctx->stmt));\n \t\ts = TREE_TYPE (ovar);\n-\t\tif (TREE_CODE (s) == REFERENCE_TYPE)\n+\t\tif (TREE_CODE (s) == REFERENCE_TYPE\n+\t\t    || omp_check_optional_argument (ovar, false))\n \t\t  s = TREE_TYPE (s);\n \t\ts = TYPE_SIZE_UNIT (s);\n \t      }"}, {"sha": "8351196dcb7af78557dd2392e720aa46ed56a0aa", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=6e4d01d61f2bec57a247de1c5ee538f122ec34a8", "patch": "@@ -1,3 +1,32 @@\n+2019-12-06  Tobias Burnus  <tobias@codesourcery.com>\n+\t    Kwok Cheung Yeung <kcy@codesourcery.com>\n+\n+\t* oacc-mem.c (update_dev_host, gomp_acc_insert_pointer): Just return\n+\tif input it a NULL pointer.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-43.c: Remove; dependent on\n+\tdiagnostic of NULL pointer.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-47.c: Ditto.\n+\t* testsuite/libgomp.fortran/optional-map.f90: New.\n+\t* testsuite/libgomp.fortran/use_device_addr-1.f90\n+\t(test_dummy_opt_callee_1_absent): New.\n+\t(test_dummy_opt_call_1): Call it.\n+\t* testsuite/libgomp.fortran/use_device_addr-2.f90: Likewise.\n+\t* testsuite/libgomp.fortran/use_device_addr-3.f90: Likewise.\n+\t* testsuite/libgomp.fortran/use_device_addr-4.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/optional-cache.f95: New.\n+\t* testsuite/libgomp.oacc-fortran/optional-data-copyin-by-value.f90: New.\n+\t* testsuite/libgomp.oacc-fortran/optional-data-copyin.f90: New.\n+\t* testsuite/libgomp.oacc-fortran/optional-data-copyout.f90: New.\n+\t* testsuite/libgomp.oacc-fortran/optional-data-enter-exit.f90: New.\n+\t* testsuite/libgomp.oacc-fortran/optional-declare.f90: New.\n+\t* testsuite/libgomp.oacc-fortran/optional-firstprivate.f90: New.\n+\t* testsuite/libgomp.oacc-fortran/optional-host_data.f90: New.\n+\t* testsuite/libgomp.oacc-fortran/optional-nested-calls.f90: New.\n+\t* testsuite/libgomp.oacc-fortran/optional-private.f90: New.\n+\t* testsuite/libgomp.oacc-fortran/optional-reduction.f90: New.\n+\t* testsuite/libgomp.oacc-fortran/optional-update-device.f90: New.\n+\t* testsuite/libgomp.oacc-fortran/optional-update-host.f90: New.\n+\n 2019-12-05  Tobias Burnus  <tobias@codesourcery.com>\n \n \t* testsuite/libgomp.oacc-fortran/error_stop-1.f: Also don't"}, {"sha": "55c195bd8197cbcd3bb907a5b3625f5baa750eb0", "filename": "libgomp/oacc-mem.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/libgomp%2Foacc-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/libgomp%2Foacc-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-mem.c?ref=6e4d01d61f2bec57a247de1c5ee538f122ec34a8", "patch": "@@ -829,6 +829,12 @@ update_dev_host (int is_dev, void *h, size_t s, int async)\n   if (acc_dev->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n     return;\n \n+  /* Fortran optional arguments that are non-present result in a\n+     NULL host address here.  This can safely be ignored as it is\n+     not possible to 'update' a non-present optional argument.  */\n+  if (h == NULL)\n+    return;\n+\n   acc_prof_info prof_info;\n   acc_api_info api_info;\n   bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);\n@@ -899,6 +905,9 @@ gomp_acc_insert_pointer (size_t mapnum, void **hostaddrs, size_t *sizes,\n   struct goacc_thread *thr = goacc_thread ();\n   struct gomp_device_descr *acc_dev = thr->dev;\n \n+  if (*hostaddrs == NULL)\n+    return;\n+\n   if (acc_is_present (*hostaddrs, *sizes))\n     {\n       splay_tree_key n;"}, {"sha": "eebe58cc45cd13ccc3d30fac6ce503d81d519618", "filename": "libgomp/testsuite/libgomp.fortran/optional-map.f90", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/libgomp%2Ftestsuite%2Flibgomp.fortran%2Foptional-map.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/libgomp%2Ftestsuite%2Flibgomp.fortran%2Foptional-map.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Foptional-map.f90?ref=6e4d01d61f2bec57a247de1c5ee538f122ec34a8", "patch": "@@ -0,0 +1,121 @@\n+! { dg-do run }\n+!\n+implicit none (type, external)\n+call sub()\n+call sub2()\n+call call_present_1()\n+call call_present_2()\n+\n+contains\n+\n+subroutine call_present_1()\n+  integer :: ii, ival, iarr, iptr, iparr\n+  pointer :: iptr, iparr\n+  dimension :: iarr(2), iparr(:)\n+  allocate(iptr,iparr(2))\n+  ii = 101\n+  ival = 102\n+  iptr = 103\n+  iarr = 104\n+  iparr = 105\n+  call sub_present(ii, ival, iarr, iptr, iparr)\n+  deallocate(iptr,iparr)\n+end subroutine\n+\n+subroutine call_present_2()\n+  integer :: ii, ival, iarr, iptr, iparr\n+  pointer :: iptr, iparr\n+  dimension :: iarr(2), iparr(:)\n+  allocate(iptr,iparr(2))\n+  ii = 201\n+  ival = 202\n+  iptr = 203\n+  iarr = 204\n+  iparr = 205\n+  call sub2_present(ii, ival, iarr, iptr, iparr)\n+  deallocate(iptr,iparr)\n+end subroutine\n+\n+subroutine sub(ii, ival, iarr, iptr, iparr)\n+  integer, optional :: ii, ival, iarr, iptr, iparr\n+  pointer :: iptr, iparr\n+  dimension :: iarr(:), iparr(:)\n+  value :: ival\n+  integer :: err\n+  err = 42\n+  !$omp target map(ii, ival, iarr, iptr, iparr, err)\n+  if (present(ii)) then\n+    ii = iptr + ival\n+    iarr = iparr\n+  else\n+    err = 0\n+  end if\n+  if (present(ii)) err = 1\n+  if (present(ival)) err = 2\n+  if (present(iarr)) err = 3\n+  if (present(iptr)) err = 4\n+  if (present(iparr)) err = 5\n+  !$omp end target\n+  if (err /= 0) stop 1\n+end subroutine sub\n+\n+subroutine sub2(ii, ival, iarr, iptr, iparr)\n+  integer, optional :: ii, ival, iarr, iptr, iparr\n+  pointer :: iptr, iparr\n+  dimension :: iarr(:), iparr(:)\n+  value :: ival\n+  integer :: err(1) ! otherwise, implied defaultmap is firstprivate\n+  err(1) = 42\n+  !$omp target  ! automatic mapping with implied defaultmap(tofrom) \n+  if (present(ii)) then\n+    ii = iptr + ival\n+    iarr = iparr\n+  else\n+    err(1) = 0\n+  end if\n+  if (present(ii)) err(1) = 1\n+  if (present(ival)) err(1) = 2\n+  if (present(iarr)) err(1) = 3\n+  if (present(iptr)) err(1) = 4\n+  if (present(iparr)) err(1) = 5\n+  !$omp end target\n+  if (err(1) /= 0) stop 2\n+end subroutine sub2\n+\n+subroutine sub_present(ii, ival, iarr, iptr, iparr)\n+  integer, optional :: ii, ival, iarr, iptr, iparr\n+  pointer :: iptr, iparr\n+  dimension :: iarr(:), iparr(:)\n+  value :: ival\n+  integer :: err\n+  err = 42\n+  !$omp target map(ii, ival, iarr, iptr, iparr, err)\n+  if (.not.present(ii)) err = 1\n+  if (.not.present(ival)) err = 2\n+  if (.not.present(iarr)) err = 3\n+  if (.not.present(iptr)) err = 4\n+  if (.not.present(iparr)) err = 5\n+  err = err - 42 - 101-102-103-104-105 + ii+ival+iarr(2)+iptr+iparr(2)\n+  !$omp end target\n+  if (err /= 0) stop 3\n+end subroutine sub_present\n+\n+subroutine sub2_present(ii, ival, iarr, iptr, iparr)\n+  integer, optional :: ii, ival, iarr, iptr, iparr\n+  pointer :: iptr, iparr\n+  dimension :: iarr(:), iparr(:)\n+  value :: ival\n+  integer :: err(1) ! otherwise, implied defaultmap is firstprivate\n+  err(1) = 53\n+  !$omp target  ! automatic mapping with implied defaultmap(tofrom) \n+  ! Note: OpenMP 4.5's 'defaultmap' is not yet supported, PR 92568\n+  if (.not.present(ii)) err = 1\n+  if (.not.present(ival)) err = 2\n+  if (.not.present(iarr)) err = 3\n+  if (.not.present(iptr)) err = 4\n+  if (.not.present(iparr)) err = 5\n+  err = err - 53 - 201-202-203-204-205 + ii+ival+iarr(2)+iptr+iparr(2)\n+  !$omp end target\n+  if (err(1) /= 0) stop 4\n+end subroutine sub2_present\n+end"}, {"sha": "0254f2dc1960e35b090f463be5516bd60ac5904a", "filename": "libgomp/testsuite/libgomp.fortran/use_device_addr-1.f90", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fuse_device_addr-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fuse_device_addr-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fuse_device_addr-1.f90?ref=6e4d01d61f2bec57a247de1c5ee538f122ec34a8", "patch": "@@ -472,6 +472,7 @@ subroutine test_dummy_opt_call_1()\n      hh = 88.0_c_double\n \n      call test_dummy_opt_callee_1(aa, bb, cc, dd, ee, ff, gg, hh, N)\n+     call test_dummy_opt_callee_1_absent(N=N)\n      deallocate(ee, ff) ! pointers, only\n   end subroutine test_dummy_opt_call_1\n \n@@ -527,6 +528,41 @@ subroutine test_dummy_opt_callee_1(aa, bb, cc, dd, ee, ff, gg, hh, N)\n      if (any(abs(3.0_c_double * gg - hh) > 10.0_c_double * epsilon(gg))) stop 72\n   end subroutine test_dummy_opt_callee_1\n \n+  subroutine test_dummy_opt_callee_1_absent(aa, bb, cc, dd, ee, ff, gg, hh, N)\n+     ! scalars\n+     real(c_double), optional, target :: aa, bb\n+     real(c_double), optional, target, allocatable :: cc, dd\n+     real(c_double), optional, pointer :: ee, ff\n+\n+     ! non-descriptor arrays\n+     real(c_double), optional, target :: gg(N), hh(N)\n+     integer, value :: N\n+\n+     integer :: err\n+\n+     ! All shall be absent\n+     if (present(aa) .or. present(bb)) stop 243\n+     if (present(cc) .or. present(dd)) stop 244\n+     if (present(ee) .or. present(ff)) stop 245\n+     if (present(gg) .or. present(hh)) stop 246\n+\n+     !$omp target data map(to:aa) map(from:bb) use_device_addr(aa,bb)\n+     if (present(aa) .or. present(bb)) stop 247\n+     !$omp end target data\n+\n+     !$omp target data map(to:cc) map(from:dd) use_device_addr(cc,dd)\n+     if (present(cc) .or. present(dd)) stop 248\n+     !$omp end target data\n+\n+     !$omp target data map(to:ee) map(from:ff) use_device_addr(ee,ff)\n+     if (present(ee) .or. present(ff)) stop 249\n+     !$omp end target data\n+\n+     !$omp target data map(to:gg) map(from:hh) use_device_addr(gg,hh)\n+     if (present(gg) .or. present(hh)) stop 250\n+     !$omp end target data\n+  end subroutine test_dummy_opt_callee_1_absent\n+\n   ! Save device ptr - and recall pointer\n   subroutine test_dummy_opt_call_2()\n      integer, parameter :: N = 1000"}, {"sha": "3dd1f90f04c733233bcddeb8c35f70d32a7aefe9", "filename": "libgomp/testsuite/libgomp.fortran/use_device_addr-2.f90", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fuse_device_addr-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fuse_device_addr-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fuse_device_addr-2.f90?ref=6e4d01d61f2bec57a247de1c5ee538f122ec34a8", "patch": "@@ -472,6 +472,7 @@ subroutine test_dummy_opt_call_1()\n      hh = 88.0_c_float\n \n      call test_dummy_opt_callee_1(aa, bb, cc, dd, ee, ff, gg, hh, N)\n+     call test_dummy_opt_callee_1_absent(N=N)\n      deallocate(ee, ff) ! pointers, only\n   end subroutine test_dummy_opt_call_1\n \n@@ -527,6 +528,41 @@ subroutine test_dummy_opt_callee_1(aa, bb, cc, dd, ee, ff, gg, hh, N)\n      if (any(abs(3.0_c_float * gg - hh) > 10.0_c_float * epsilon(gg))) stop 72\n   end subroutine test_dummy_opt_callee_1\n \n+  subroutine test_dummy_opt_callee_1_absent(aa, bb, cc, dd, ee, ff, gg, hh, N)\n+     ! scalars\n+     real(c_float), optional, target :: aa, bb\n+     real(c_float), optional, target, allocatable :: cc, dd\n+     real(c_float), optional, pointer :: ee, ff\n+\n+     ! non-descriptor arrays\n+     real(c_float), optional, target :: gg(N), hh(N)\n+     integer, value :: N\n+\n+     integer :: err\n+\n+     ! All shall be absent\n+     if (present(aa) .or. present(bb)) stop 243\n+     if (present(cc) .or. present(dd)) stop 244\n+     if (present(ee) .or. present(ff)) stop 245\n+     if (present(gg) .or. present(hh)) stop 246\n+\n+     !$omp target data map(to:aa) map(from:bb) use_device_addr(aa,bb)\n+     if (present(aa) .or. present(bb)) stop 247\n+     !$omp end target data\n+\n+     !$omp target data map(to:cc) map(from:dd) use_device_addr(cc,dd)\n+     if (present(cc) .or. present(dd)) stop 248\n+     !$omp end target data\n+\n+     !$omp target data map(to:ee) map(from:ff) use_device_addr(ee,ff)\n+     if (present(ee) .or. present(ff)) stop 249\n+     !$omp end target data\n+\n+     !$omp target data map(to:gg) map(from:hh) use_device_addr(gg,hh)\n+     if (present(gg) .or. present(hh)) stop 250\n+     !$omp end target data\n+  end subroutine test_dummy_opt_callee_1_absent\n+\n   ! Save device ptr - and recall pointer\n   subroutine test_dummy_opt_call_2()\n      integer, parameter :: N = 1000"}, {"sha": "82cf9ac8070e8f2c8b81827a4957cd1f1b978657", "filename": "libgomp/testsuite/libgomp.fortran/use_device_addr-3.f90", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fuse_device_addr-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fuse_device_addr-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fuse_device_addr-3.f90?ref=6e4d01d61f2bec57a247de1c5ee538f122ec34a8", "patch": "@@ -290,6 +290,7 @@ subroutine test_dummy_opt_call_1()\n      ff = 66.0_c_double\n \n      call test_dummy_opt_callee_1(aa, bb, cc, dd, ee, ff, N)\n+     call test_dummy_opt_callee_1_absent(N=N)\n      deallocate(ee, ff) ! pointers, only\n   end subroutine test_dummy_opt_call_1\n \n@@ -336,6 +337,32 @@ subroutine test_dummy_opt_callee_1(aa, bb, cc, dd, ee, ff, N)\n      if (any(abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee))) stop 1\n   end subroutine test_dummy_opt_callee_1\n \n+  subroutine test_dummy_opt_callee_1_absent(aa, bb, cc, dd, ee, ff, N)\n+     ! scalars\n+     real(c_double), optional, target :: aa(:), bb(:)\n+     real(c_double), optional, target, allocatable :: cc(:), dd(:)\n+     real(c_double), optional, pointer :: ee(:), ff(:)\n+\n+     integer, value :: N\n+\n+     ! All shall be absent\n+     if (present(aa) .or. present(bb)) stop 1\n+     if (present(cc) .or. present(dd)) stop 1\n+     if (present(ee) .or. present(ff)) stop 1\n+\n+     !$omp target data map(to:aa) map(from:bb) use_device_addr(aa,bb)\n+     if (present(aa) .or. present(bb)) stop 1\n+     !$omp end target data\n+\n+     !$omp target data map(to:cc) map(from:dd) use_device_addr(cc,dd)\n+     if (present(cc) .or. present(dd)) stop 1\n+     !$omp end target data\n+\n+     !$omp target data map(to:ee) map(from:ff) use_device_addr(ee,ff)\n+     if (present(ee) .or. present(ff)) stop 1\n+     !$omp end target data\n+  end subroutine test_dummy_opt_callee_1_absent\n+\n   ! Save device ptr - and recall pointer\n   subroutine test_dummy_opt_call_2()\n      integer, parameter :: N = 1000"}, {"sha": "d17249de2bc9fe2e58447d6f5cfaa1b4701f3631", "filename": "libgomp/testsuite/libgomp.fortran/use_device_addr-4.f90", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fuse_device_addr-4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fuse_device_addr-4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fuse_device_addr-4.f90?ref=6e4d01d61f2bec57a247de1c5ee538f122ec34a8", "patch": "@@ -290,6 +290,7 @@ subroutine test_dummy_opt_call_1()\n      ff = 66.0_c_float\n \n      call test_dummy_opt_callee_1(aa, bb, cc, dd, ee, ff, N)\n+     call test_dummy_opt_callee_1_absent(N=N)\n      deallocate(ee, ff) ! pointers, only\n   end subroutine test_dummy_opt_call_1\n \n@@ -336,6 +337,32 @@ subroutine test_dummy_opt_callee_1(aa, bb, cc, dd, ee, ff, N)\n      if (any(abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee))) stop 1\n   end subroutine test_dummy_opt_callee_1\n \n+  subroutine test_dummy_opt_callee_1_absent(aa, bb, cc, dd, ee, ff, N)\n+     ! scalars\n+     real(c_float), optional, target :: aa(:), bb(:)\n+     real(c_float), optional, target, allocatable :: cc(:), dd(:)\n+     real(c_float), optional, pointer :: ee(:), ff(:)\n+\n+     integer, value :: N\n+\n+     ! All shall be absent\n+     if (present(aa) .or. present(bb)) stop 1\n+     if (present(cc) .or. present(dd)) stop 1\n+     if (present(ee) .or. present(ff)) stop 1\n+\n+     !$omp target data map(to:aa) map(from:bb) use_device_addr(aa,bb)\n+     if (present(aa) .or. present(bb)) stop 1\n+     !$omp end target data\n+\n+     !$omp target data map(to:cc) map(from:dd) use_device_addr(cc,dd)\n+     if (present(cc) .or. present(dd)) stop 1\n+     !$omp end target data\n+\n+     !$omp target data map(to:ee) map(from:ff) use_device_addr(ee,ff)\n+     if (present(ee) .or. present(ff)) stop 1\n+     !$omp end target data\n+  end subroutine test_dummy_opt_callee_1_absent\n+\n   ! Save device ptr - and recall pointer\n   subroutine test_dummy_opt_call_2()\n      integer, parameter :: N = 1000"}, {"sha": "5db29124e9ec5bc48667aa14e4d3b62ae558129f", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/lib-43.c", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e150da383346adc762bc904342f9877f2f071265/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-43.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e150da383346adc762bc904342f9877f2f071265/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-43.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-43.c?ref=e150da383346adc762bc904342f9877f2f071265", "patch": "@@ -1,51 +0,0 @@\n-/* Exercise acc_update_device with a NULL data address on nvidia targets.  */\n-\n-/* { dg-do run { target openacc_nvidia_accel_selected } } */\n-\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <openacc.h>\n-\n-int\n-main (int argc, char **argv)\n-{\n-  const int N = 256;\n-  int i;\n-  unsigned char *h;\n-  void *d;\n-\n-  h = (unsigned char *) malloc (N);\n-\n-  for (i = 0; i < N; i++)\n-    {\n-      h[i] = i;\n-    }\n-\n-  d = acc_copyin (h, N);\n-  if (!d)\n-    abort ();\n-\n-  for (i = 0; i < N; i++)\n-    {\n-      h[i] = 0xab;\n-    }\n-\n-  fprintf (stderr, \"CheCKpOInT\\n\");\n-  acc_update_device (0, N);\n-\n-  acc_copyout (h, N);\n-\n-  for (i = 0; i < N; i++)\n-    {\n-      if (h[i] != 0xab)\n-\tabort ();\n-    }\n-\n-  free (h);\n-\n-  return 0;\n-}\n-\n-/* { dg-output \"CheCKpOInT(\\n|\\r\\n|\\r).*\" } */\n-/* { dg-output \"\\\\\\[\\[^\\n\\r]*,256\\\\\\] is not mapped\" } */\n-/* { dg-shouldfail \"\" } */"}, {"sha": "c2140429cb1edd115d792baa44397493c7a5b70f", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/lib-47.c", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e150da383346adc762bc904342f9877f2f071265/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-47.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e150da383346adc762bc904342f9877f2f071265/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-47.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-47.c?ref=e150da383346adc762bc904342f9877f2f071265", "patch": "@@ -1,49 +0,0 @@\n-/* Exercise acc_update_self with a NULL data mapping on nvidia targets.  */\n-\n-/* { dg-do run { target openacc_nvidia_accel_selected } } */\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include <stdlib.h>\n-#include <openacc.h>\n-\n-int\n-main (int argc, char **argv)\n-{\n-  const int N = 256;\n-  int i;\n-  unsigned char *h;\n-  void *d;\n-\n-  h = (unsigned char *) malloc (N);\n-\n-  for (i = 0; i < N; i++)\n-    {\n-      h[i] = i;\n-    }\n-\n-  d = acc_copyin (h, N);\n-  if (!d)\n-    abort ();\n-\n-  memset (&h[0], 0, N);\n-\n-  fprintf (stderr, \"CheCKpOInT\\n\");\n-  acc_update_self (0, N);\n-\n-  for (i = 0; i < N; i++)\n-    {\n-      if (h[i] != i)\n-\tabort ();\n-    }\n-\n-  acc_delete (h, N);\n-\n-  free (h);\n-\n-  return 0;\n-}\n-\n-/* { dg-output \"CheCKpOInT(\\n|\\r\\n|\\r).*\" } */\n-/* { dg-output \"\\\\\\[\\[^\\n\\r]*,256\\\\\\] is not mapped\" } */\n-/* { dg-shouldfail \"\" } */"}, {"sha": "00f7472ae6ec9b6340458e789bae4d285612f004", "filename": "libgomp/testsuite/libgomp.oacc-fortran/optional-cache.f95", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Foptional-cache.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Foptional-cache.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Foptional-cache.f95?ref=6e4d01d61f2bec57a247de1c5ee538f122ec34a8", "patch": "@@ -0,0 +1,23 @@\n+! Test that the cache directives work with optional arguments.  The effect\n+! of giving a non-present argument to the cache directive is not tested as\n+! it is undefined.  The test is based on gfortran.dg/goacc/cache-1.f95.\n+\n+! { dg-additional-options \"-std=f2008\" }\n+\n+program cache_test\n+  implicit none\n+  integer :: d(10), e(7,13)\n+\n+  call do_test(d, e)\n+contains\n+  subroutine do_test(d, e)\n+    integer, optional :: d(10), e(7,13)\n+    integer :: i\n+    do concurrent (i=1:5)\n+      !$acc cache (d(1:3))\n+      !$acc cache (d(i:i+2))\n+      !$acc cache (e(1:3,2:4))\n+      !$acc cache (e(i:i+2,i+1:i+3))\n+    enddo\n+  end\n+end"}, {"sha": "5cadeed44b4c695c2492f2528181908c9ba430e7", "filename": "libgomp/testsuite/libgomp.oacc-fortran/optional-data-copyin-by-value.f90", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Foptional-data-copyin-by-value.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Foptional-data-copyin-by-value.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Foptional-data-copyin-by-value.f90?ref=6e4d01d61f2bec57a247de1c5ee538f122ec34a8", "patch": "@@ -0,0 +1,29 @@\n+! Test OpenACC data regions with optional arguments passed by value.\n+\n+! { dg-do run }\n+\n+program test\n+  implicit none\n+\n+  integer :: res\n+\n+  if (foo(27) .ne. 27) stop 1\n+  if (foo(16, 18) .ne. 288) stop 1\n+contains\n+  function foo(x, y)\n+    integer, value :: x\n+    integer, value, optional :: y\n+    integer :: res, foo\n+\n+    !$acc data copyin(x, y) copyout(res)\n+    !$acc parallel\n+    res = x\n+    if (present(y)) then\n+      res = res * y\n+    end if\n+    !$acc end parallel\n+    !$acc end data\n+\n+    foo = res\n+  end function foo\n+end program test"}, {"sha": "a30908d61a5def7c8e8c346f5340025510b36edd", "filename": "libgomp/testsuite/libgomp.oacc-fortran/optional-data-copyin.f90", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Foptional-data-copyin.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Foptional-data-copyin.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Foptional-data-copyin.f90?ref=6e4d01d61f2bec57a247de1c5ee538f122ec34a8", "patch": "@@ -0,0 +1,140 @@\n+! Test OpenACC data regions with a copy-in of optional arguments.\n+\n+! { dg-do run }\n+\n+program test\n+  implicit none\n+\n+  integer, parameter :: n = 64\n+  integer :: i\n+  integer :: a_int, b_int, c_int, res_int\n+  integer :: a_arr(n), b_arr(n), c_arr(n), res_arr(n)\n+  integer, allocatable :: a_alloc(:), b_alloc(:), c_alloc(:), res_alloc(:)\n+\n+  a_int = 7\n+  b_int = 3\n+  c_int = 11\n+\n+  call test_int(res_int, a_int)\n+  if (res_int .ne. a_int) stop 1\n+\n+  call test_int(res_int, a_int, b_int)\n+  if (res_int .ne. a_int * b_int) stop 2\n+\n+  call test_int(res_int, a_int, b_int, c_int)\n+  if (res_int .ne. a_int * b_int + c_int) stop 3\n+\n+  do i = 1, n\n+    a_arr(i) = i\n+    b_arr(i) = n - i + 1\n+    c_arr(i) = i * 3\n+  end do\n+\n+  call test_array(res_arr, a_arr)\n+  do i = 1, n\n+    if (res_arr(i) .ne. a_arr(i)) stop 4\n+  end do\n+\n+  call test_array(res_arr, a_arr, b_arr)\n+  do i = 1, n\n+    if (res_arr(i) .ne. a_arr(i) * b_arr(i)) stop 5\n+  end do\n+\n+  call test_array(res_arr, a_arr, b_arr, c_arr)\n+  do i = 1, n\n+    if (res_arr(i) .ne. a_arr(i) * b_arr(i) + c_arr(i)) stop 6\n+  end do\n+\n+  allocate (a_alloc(n))\n+  allocate (b_alloc(n))\n+  allocate (c_alloc(n))\n+  allocate (res_alloc(n))\n+\n+  do i = 1, n\n+    a_alloc(i) = i\n+    b_alloc(i) = n - i + 1\n+    c_alloc(i) = i * 3\n+  end do\n+\n+  call test_allocatable(res_alloc, a_alloc)\n+  do i = 1, n\n+    if (res_alloc(i) .ne. a_alloc(i)) stop 7\n+  end do\n+\n+  call test_allocatable(res_alloc, a_alloc, b_alloc)\n+  do i = 1, n\n+    if (res_alloc(i) .ne. a_alloc(i) * b_alloc(i)) stop 8\n+  end do\n+\n+  call test_allocatable(res_alloc, a_alloc, b_alloc, c_alloc)\n+  do i = 1, n\n+    if (res_alloc(i) .ne. a_alloc(i) * b_alloc(i) + c_alloc(i)) stop 9\n+  end do\n+\n+  deallocate (a_alloc)\n+  deallocate (b_alloc)\n+  deallocate (c_alloc)\n+  deallocate (res_alloc)\n+contains\n+  subroutine test_int(res, a, b, c)\n+    integer :: res\n+    integer :: a\n+    integer, optional :: b, c\n+\n+    !$acc data copyin(a, b, c) copyout(res)\n+    !$acc parallel\n+    res = a\n+\n+    if (present(b)) res = res * b\n+\n+    if (present(c)) res = res + c\n+    !$acc end parallel\n+    !$acc end data\n+  end subroutine test_int\n+\n+  subroutine test_array(res, a, b, c)\n+    integer :: res(n)\n+    integer :: a(n)\n+    integer, optional :: b(n), c(n)\n+\n+    !$acc data copyin(a, b, c) copyout(res)\n+    !$acc parallel loop\n+    do i = 1, n\n+      res(i) = a(i)\n+    end do\n+\n+    !$acc parallel loop\n+    do i = 1, n\n+      if (present(b)) res(i) = res(i) * b(i)\n+    end do\n+\n+    !$acc parallel loop\n+    do i = 1, n\n+      if (present(c)) res(i) = res(i) + c(i)\n+    end do\n+    !$acc end data\n+  end subroutine test_array\n+\n+  subroutine test_allocatable(res, a, b, c)\n+    integer, allocatable :: res(:)\n+    integer, allocatable  :: a(:)\n+    integer, allocatable, optional :: b(:), c(:)\n+\n+    !$acc data copyin(a, b, c) copyout(res)\n+    !$acc parallel loop\n+    do i = 1, n\n+      res(i) = a(i)\n+    end do\n+\n+    !$acc parallel loop\n+    do i = 1, n\n+      if (present(b)) res(i) = res(i) * b(i)\n+    end do\n+\n+    !$acc parallel loop\n+    do i = 1, n\n+      if (present(c)) res(i) = res(i) + c(i)\n+    end do\n+    !$acc end data\n+  end subroutine test_allocatable\n+end program test"}, {"sha": "feaa31fa4239d47a13e6de106c69095d88cbf2c1", "filename": "libgomp/testsuite/libgomp.oacc-fortran/optional-data-copyout.f90", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Foptional-data-copyout.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Foptional-data-copyout.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Foptional-data-copyout.f90?ref=6e4d01d61f2bec57a247de1c5ee538f122ec34a8", "patch": "@@ -0,0 +1,96 @@\n+! Test OpenACC data regions with a copy-out of optional arguments.\n+\n+! { dg-do run }\n+\n+program test\n+  implicit none\n+\n+  integer, parameter :: n = 64\n+  integer :: i\n+  integer :: a_int, b_int, res_int\n+  integer :: a_arr(n), b_arr(n), res_arr(n)\n+  integer, allocatable :: a_alloc(:), b_alloc(:), res_alloc(:)\n+\n+  res_int = 0\n+\n+  call test_int(a_int, b_int)\n+  if (res_int .ne. 0) stop 1\n+\n+  call test_int(a_int, b_int, res_int)\n+  if (res_int .ne. a_int * b_int) stop 2\n+\n+  res_arr(:) = 0\n+  do i = 1, n\n+    a_arr(i) = i\n+    b_arr(i) = n - i + 1\n+  end do\n+\n+  call test_array(a_arr, b_arr)\n+  do i = 1, n\n+    if (res_arr(i) .ne. 0) stop 3\n+  end do\n+\n+  call test_array(a_arr, b_arr, res_arr)\n+  do i = 1, n\n+    if (res_arr(i) .ne. a_arr(i) * b_arr(i)) stop 4\n+  end do\n+\n+  allocate (a_alloc(n))\n+  allocate (b_alloc(n))\n+  allocate (res_alloc(n))\n+\n+  res_alloc(:) = 0\n+  do i = 1, n\n+    a_alloc(i) = i\n+    b_alloc(i) = n - i + 1\n+  end do\n+\n+  call test_allocatable(a_alloc, b_alloc)\n+  do i = 1, n\n+    if (res_alloc(i) .ne. 0) stop 5\n+  end do\n+\n+  call test_allocatable(a_alloc, b_alloc, res_alloc)\n+  do i = 1, n\n+    if (res_alloc(i) .ne. a_alloc(i) * b_alloc(i)) stop 6\n+  end do\n+\n+  deallocate (a_alloc)\n+  deallocate (b_alloc)\n+  deallocate (res_alloc)\n+contains\n+  subroutine test_int(a, b, res)\n+    integer :: a, b\n+    integer, optional :: res\n+\n+    !$acc data copyin(a, b) copyout(res)\n+    !$acc parallel\n+    if (present(res)) res = a * b\n+    !$acc end parallel\n+    !$acc end data\n+  end subroutine test_int\n+\n+  subroutine test_array(a, b, res)\n+    integer :: a(n), b(n)\n+    integer, optional :: res(n)\n+\n+    !$acc data copyin(a, b) copyout(res)\n+    !$acc parallel loop\n+    do i = 1, n\n+      if (present(res)) res(i) = a(i) * b(i)\n+    end do\n+    !$acc end data\n+  end subroutine test_array\n+\n+  subroutine test_allocatable(a, b, res)\n+    integer, allocatable :: a(:), b(:)\n+    integer, allocatable, optional :: res(:)\n+\n+    !$acc data copyin(a, b) copyout(res)\n+    !$acc parallel loop\n+    do i = 1, n\n+      if (present(res)) res(i) = a(i) * b(i)\n+    end do\n+    !$acc end data\n+  end subroutine test_allocatable\n+end program test"}, {"sha": "9ed0f753ea5cffe7f7d0166e5e9cf6171444732e", "filename": "libgomp/testsuite/libgomp.oacc-fortran/optional-data-enter-exit.f90", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Foptional-data-enter-exit.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Foptional-data-enter-exit.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Foptional-data-enter-exit.f90?ref=6e4d01d61f2bec57a247de1c5ee538f122ec34a8", "patch": "@@ -0,0 +1,91 @@\n+! Test OpenACC unstructured enter data/exit data regions with optional\n+! arguments.\n+\n+! { dg-do run }\n+\n+program test\n+  implicit none\n+\n+  integer, parameter :: n = 64\n+  integer :: a(n), b(n), c(n), res(n)\n+  integer :: x, y, z, r, i\n+\n+  do i = 1, n\n+    a(i) = i\n+    b(i) = n - i + 1\n+    c(i) = i * 3\n+  end do\n+\n+  res = test_array(a)\n+  do i = 1, n\n+    if (res(i) .ne. a(i)) stop 1\n+  end do\n+\n+  res = test_array(a, b)\n+  do i = 1, n\n+    if (res(i) .ne. a(i) * b(i)) stop 2\n+  end do\n+\n+  res = test_array(a, b, c)\n+  do i = 1, n\n+    if (res(i) .ne. a(i) * b(i) + c(i)) stop 3\n+  end do\n+\n+  x = 7\n+  y = 3\n+  z = 11\n+\n+  r = test_int(x)\n+  if (r .ne. x) stop 4\n+\n+  r = test_int(x, y)\n+  if (r .ne. x * y) stop 5\n+\n+  r = test_int(x, y, z)\n+  if (r .ne. x * y + z) stop 6\n+contains\n+  function test_array(a, b, c)\n+    integer :: a(n)\n+    integer, optional :: b(n), c(n)\n+    integer :: test_array(n), res(n)\n+\n+    !$acc enter data copyin(a, b, c) create(res)\n+    !$acc parallel loop\n+    do i = 1, n\n+      res(i) = a(i)\n+    end do\n+\n+    !$acc parallel loop\n+    do i = 1, n\n+      if (present(b)) then\n+        res(i) = res(i) * b(i)\n+      end if\n+    end do\n+\n+    !$acc parallel loop\n+    do i = 1, n\n+      if (present(c)) then\n+        res(i) = res(i) + c(i)\n+      end if\n+    end do\n+    !$acc exit data copyout(res) delete(a, b, c)\n+\n+    test_array = res\n+  end function test_array\n+\n+  function test_int(a, b, c)\n+    integer :: a\n+    integer, optional :: b, c\n+    integer :: test_int, res\n+\n+    !$acc enter data copyin(a, b, c) create(res)\n+    !$acc parallel present(a, b, c, res)\n+    res = a\n+    if (present(b)) res = res * b\n+    if (present(c)) res = res + c\n+    !$acc end parallel\n+    !$acc exit data copyout(res) delete(a, b, c)\n+\n+    test_int = res\n+  end function test_int\n+end program test"}, {"sha": "074e5a2abb618789e38eab378d430658f38dfa33", "filename": "libgomp/testsuite/libgomp.oacc-fortran/optional-declare.f90", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Foptional-declare.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Foptional-declare.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Foptional-declare.f90?ref=6e4d01d61f2bec57a247de1c5ee538f122ec34a8", "patch": "@@ -0,0 +1,87 @@\n+! Test OpenACC declare directives with optional arguments.\n+\n+! { dg-do run }\n+\n+program test\n+  implicit none\n+\n+  integer, parameter :: n = 64\n+  integer :: i\n+  integer :: a_int, b_int, c_int, res_int\n+  integer :: a_arr(n), b_arr(n), c_arr(n), res_arr(n)\n+\n+  a_int = 7\n+  b_int = 3\n+  c_int = 11\n+\n+  call test_int(res_int, a_int)\n+  if (res_int .ne. a_int) stop 1\n+\n+  call test_int(res_int, a_int, b_int)\n+  if (res_int .ne. a_int * b_int) stop 2\n+\n+  call test_int(res_int, a_int, b_int, c_int)\n+  if (res_int .ne. a_int * b_int + c_int) stop 3\n+\n+  do i = 1, n\n+    a_arr(i) = i\n+    b_arr(i) = n - i + 1\n+    c_arr(i) = i * 3\n+  end do\n+\n+  call test_array(res_arr, a_arr)\n+  do i = 1, n\n+    if (res_arr(i) .ne. a_arr(i)) stop 4\n+  end do\n+\n+  call test_array(res_arr, a_arr, b_arr)\n+  do i = 1, n\n+    if (res_arr(i) .ne. a_arr(i) * b_arr(i)) stop 5\n+  end do\n+\n+  call test_array(res_arr, a_arr, b_arr, c_arr)\n+  do i = 1, n\n+    if (res_arr(i) .ne. a_arr(i) * b_arr(i) + c_arr(i)) stop 6\n+  end do\n+contains\n+  subroutine test_int(res, a, b, c)\n+    integer :: a\n+    integer, optional :: b, c\n+    !$acc declare present_or_copyin(a, b, c)\n+    integer :: res\n+    !$acc declare present_or_copyout(res)\n+\n+    !$acc parallel\n+    res = a\n+    if (present(b)) res = res * b\n+    if (present(c)) res = res + c\n+    !$acc end parallel\n+  end subroutine test_int\n+\n+  subroutine test_array(res, a, b, c)\n+    integer :: a(n)\n+    integer, optional :: b(n), c(n)\n+    !$acc declare present_or_copyin(a, b, c)\n+    integer :: res(n)\n+    !$acc declare present_or_copyout(res)\n+\n+    !$acc parallel loop\n+    do i = 1, n\n+      res(i) = a(i)\n+    end do\n+\n+    !$acc parallel loop\n+    do i = 1, n\n+      if (present(b)) then\n+        res(i) = res(i) * b(i)\n+      end if\n+    end do\n+\n+    !$acc parallel loop\n+    do i = 1, n\n+      if (present(c)) then\n+        res(i) = res(i) + c(i)\n+      end if\n+    end do\n+  end subroutine test_array\n+end program test"}, {"sha": "693e6118489e5fc273588ebf5ec75153ec0e3982", "filename": "libgomp/testsuite/libgomp.oacc-fortran/optional-firstprivate.f90", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Foptional-firstprivate.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Foptional-firstprivate.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Foptional-firstprivate.f90?ref=6e4d01d61f2bec57a247de1c5ee538f122ec34a8", "patch": "@@ -0,0 +1,112 @@\n+! Test that optional arguments work in firstprivate clauses.  The effect of\n+! non-present arguments in firstprivate clauses is undefined, and is not\n+! tested for.\n+\n+! { dg-do run }\n+\n+program test_firstprivate\n+  implicit none\n+  integer, parameter :: n = 64\n+\n+  integer :: i, j\n+  integer :: a_int, b_int, c_int, res_int\n+  integer :: a_arr(n), b_arr(n), c_arr(n), res_arr(n)\n+  integer, allocatable :: a_alloc(:), b_alloc(:), c_alloc(:), res_alloc(:)\n+\n+  a_int = 14\n+  b_int = 5\n+  c_int = 12\n+\n+  call test_int(res_int, a_int, b_int, c_int)\n+  if (res_int .ne. a_int * b_int + c_int) stop 1\n+\n+  do i = 1, n\n+    a_arr(i) = i\n+    b_arr(i) = n - i + 1\n+    c_arr(i) = i * 3\n+  end do\n+\n+  call test_array(res_arr, a_arr, b_arr, c_arr)\n+  do i = 1, n\n+    if (res_arr(i) .ne. a_arr(i) * b_arr(i) + c_arr(i)) stop 2\n+  end do\n+\n+  allocate(a_alloc(n))\n+  allocate(b_alloc(n))\n+  allocate(c_alloc(n))\n+  allocate(res_alloc(n))\n+\n+  do i = 1, n\n+    a_arr(i) = i\n+    b_arr(i) = n - i + 1\n+    c_arr(i) = i * 3\n+  end do\n+\n+  call test_allocatable(res_alloc, a_alloc, b_alloc, c_alloc)\n+  do i = 1, n\n+    if (res_alloc(i) .ne. a_alloc(i) * b_alloc(i) + c_alloc(i)) stop 2\n+  end do\n+\n+  deallocate(a_alloc)\n+  deallocate(b_alloc)\n+  deallocate(c_alloc)\n+  deallocate(res_alloc)\n+contains\n+  subroutine test_int(res, a, b, c)\n+    integer :: a\n+    integer, optional :: b, c\n+    integer :: res\n+\n+    !$acc parallel firstprivate(a, b, c) copyout(res)\n+    res = a\n+    if (present(b)) res = res * b\n+    if (present(c)) res = res + c\n+    !$acc end parallel\n+  end subroutine test_int\n+\n+  subroutine test_array(res, a, b, c)\n+    integer :: a(n)\n+    integer, optional :: b(n), c(n)\n+    integer :: res(n)\n+\n+    !$acc data copyin(a, b, c) copyout(res)\n+    !$acc parallel loop firstprivate(a)\n+    do i = 1, n\n+      res(i) = a(i)\n+    end do\n+\n+    !$acc parallel loop firstprivate(b)\n+    do i = 1, n\n+      if (present(b)) res(i) = res(i) * b(i)\n+    end do\n+\n+    !$acc parallel loop firstprivate(c)\n+    do i = 1, n\n+      if (present(c)) res(i) = res(i) + c(i)\n+    end do\n+    !$acc end data\n+  end subroutine test_array\n+\n+  subroutine test_allocatable(res, a, b, c)\n+    integer, allocatable :: a(:)\n+    integer, allocatable, optional :: b(:), c(:)\n+    integer, allocatable :: res(:)\n+\n+    !$acc data copyin(a, b, c) copyout(res)\n+    !$acc parallel loop firstprivate(a)\n+    do i = 1, n\n+      res(i) = a(i)\n+    end do\n+\n+    !$acc parallel loop firstprivate(b)\n+    do i = 1, n\n+      if (present(b)) res(i) = res(i) * b(i)\n+    end do\n+\n+    !$acc parallel loop firstprivate(c)\n+    do i = 1, n\n+      if (present(c)) res(i) = res(i) + c(i)\n+    end do\n+    !$acc end data\n+  end subroutine test_allocatable\n+end program test_firstprivate"}, {"sha": "a6e41e28b0b3c14056211066bfa8136051ad0a7c", "filename": "libgomp/testsuite/libgomp.oacc-fortran/optional-host_data.f90", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Foptional-host_data.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Foptional-host_data.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Foptional-host_data.f90?ref=6e4d01d61f2bec57a247de1c5ee538f122ec34a8", "patch": "@@ -0,0 +1,39 @@\n+! Test the host_data construct with optional arguments.\n+! Based on host_data-1.f90.\n+\n+! { dg-do run }\n+! { dg-additional-options \"-cpp\" }\n+\n+program test\n+  implicit none\n+\n+  integer, target :: i\n+  integer, pointer :: ip, iph\n+\n+  ! Assign the same targets\n+  ip => i\n+  iph => i\n+\n+  call foo(iph)\n+  call foo(iph, ip)\n+contains\n+  subroutine foo(iph, ip)\n+    integer, pointer :: iph\n+    integer, pointer, optional :: ip\n+\n+    !$acc data copyin(i)\n+    !$acc host_data use_device(ip)\n+\n+    ! Test how the pointers compare inside a host_data construct\n+    if (present(ip)) then\n+#if ACC_MEM_SHARED\n+      if (.not. associated(ip, iph)) STOP 1\n+#else\n+      if (associated(ip, iph)) STOP 2\n+#endif\n+    end if\n+\n+    !$acc end host_data\n+    !$acc end data\n+  end subroutine foo\n+end program test"}, {"sha": "279139f7c5948fb05e84d70dfb02b6462697a1da", "filename": "libgomp/testsuite/libgomp.oacc-fortran/optional-nested-calls.f90", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Foptional-nested-calls.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Foptional-nested-calls.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Foptional-nested-calls.f90?ref=6e4d01d61f2bec57a247de1c5ee538f122ec34a8", "patch": "@@ -0,0 +1,135 @@\n+! Test propagation of optional arguments from within an OpenACC parallel region.\n+\n+! { dg-do run }\n+\n+program test\n+  implicit none\n+\n+  integer, parameter :: n = 64\n+  integer :: i\n+  integer :: res_int\n+  integer :: a_arr(n), b_arr(n), res_arr(n)\n+  integer, allocatable :: a_alloc(:), b_alloc(:), res_alloc(:)\n+\n+  call test_int_caller(res_int, 5)\n+  if (res_int .ne. 10) stop 1\n+\n+  call test_int_caller(res_int, 2, 3)\n+  if (res_int .ne. 11) stop 2\n+\n+  do i = 1, n\n+    a_arr(i) = i\n+    b_arr(i) = n - i + 1\n+  end do\n+\n+  call test_array_caller(res_arr, a_arr)\n+  do i = 1, n\n+    if (res_arr(i) .ne. 2 * a_arr(i)) stop 3\n+  end do\n+\n+  call test_array_caller(res_arr, a_arr, b_arr)\n+  do i = 1, n\n+    if (res_arr(i) .ne. a_arr(i) * b_arr(i) + a_arr(i) + b_arr(i)) stop 4\n+  end do\n+\n+  allocate(a_alloc(n))\n+  allocate(b_alloc(n))\n+  allocate(res_alloc(n))\n+\n+  do i = 1, n\n+    a_alloc(i) = i\n+    b_alloc(i) = n - i + 1\n+  end do\n+\n+  call test_array_caller(res_arr, a_arr)\n+  do i = 1, n\n+    if (res_arr(i) .ne. 2 * a_alloc(i)) stop 5\n+  end do\n+\n+  call test_array_caller(res_arr, a_arr, b_arr)\n+  do i = 1, n\n+    if (res_arr(i) .ne. a_arr(i) * b_alloc(i) + a_alloc(i) + b_alloc(i)) stop 6\n+  end do\n+\n+  deallocate(a_alloc)\n+  deallocate(b_alloc)\n+  deallocate(res_alloc)\n+contains\n+  subroutine test_int_caller(res, a, b)\n+    integer :: res, a\n+    integer, optional :: b\n+\n+    !$acc data copyin(a, b) copyout (res)\n+    !$acc parallel\n+    res = a\n+    if (present(b)) res = res * b\n+    call test_int_callee(res, a, b)\n+    !$acc end parallel\n+    !$acc end data\n+  end subroutine test_int_caller\n+\n+  subroutine test_int_callee(res, a, b)\n+    !$acc routine seq\n+    integer :: res, a\n+    integer, optional :: b\n+\n+    res = res + a\n+    if (present(b)) res = res + b\n+  end subroutine test_int_callee\n+\n+  subroutine test_array_caller(res, a, b)\n+    integer :: res(n), a(n), i\n+    integer, optional :: b(n)\n+\n+    !$acc data copyin(a, b) copyout(res)\n+    !$acc parallel\n+    !$acc loop seq\n+    do i = 1, n\n+      res(i) = a(i)\n+      if (present(b)) res(i) = res(i) * b(i)\n+    end do\n+    call test_array_callee(res, a, b)\n+    !$acc end parallel\n+    !$acc end data\n+  end subroutine test_array_caller\n+\n+  subroutine test_array_callee(res, a, b)\n+    !$acc routine seq\n+    integer :: res(n), a(n), i\n+    integer, optional :: b(n)\n+\n+    do i = 1, n\n+      res(i) = res(i) + a(i)\n+      if (present(b)) res(i) = res(i) + b(i)\n+    end do\n+  end subroutine test_array_callee\n+\n+  subroutine test_allocatable_caller(res, a, b)\n+    integer :: i\n+    integer, allocatable :: res(:), a(:)\n+    integer, allocatable, optional :: b(:)\n+\n+    !$acc data copyin(a, b) copyout(res)\n+    !$acc parallel\n+    !$acc loop seq\n+    do i = 1, n\n+      res(i) = a(i)\n+      if (present(b)) res(i) = res(i) * b(i)\n+    end do\n+    call test_array_callee(res, a, b)\n+    !$acc end parallel\n+    !$acc end data\n+  end subroutine test_allocatable_caller\n+\n+  subroutine test_allocatable_callee(res, a, b)\n+    !$acc routine seq\n+    integer :: i\n+    integer, allocatable :: res(:), a(:)\n+    integer, allocatable, optional :: b(:)\n+\n+    do i = 1, n\n+      res(i) = res(i) + a(i)\n+      if (present(b)) res(i) = res(i) + b(i)\n+    end do\n+  end subroutine test_allocatable_callee\n+end program test"}, {"sha": "0320bbb3bc99ca2e91e22ba3a931b86942095a26", "filename": "libgomp/testsuite/libgomp.oacc-fortran/optional-private.f90", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Foptional-private.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Foptional-private.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Foptional-private.f90?ref=6e4d01d61f2bec57a247de1c5ee538f122ec34a8", "patch": "@@ -0,0 +1,115 @@\n+! Test that optional arguments work in private clauses.  The effect of\n+! non-present arguments in private clauses is undefined, and is not tested\n+! for.  The tests are based on those in private-variables.f90.\n+\n+! { dg-do run }\n+\n+program main\n+  implicit none\n+\n+  type vec3\n+     integer x, y, z, attr(13)\n+  end type vec3\n+  integer :: x\n+  type(vec3) :: pt\n+  integer :: arr(2)\n+\n+  call t1(x)\n+  call t2(pt)\n+  call t3(arr)\n+contains\n+\n+  ! Test of gang-private variables declared on loop directive.\n+\n+  subroutine t1(x)\n+    integer, optional :: x\n+    integer :: i, arr(32)\n+\n+    do i = 1, 32\n+       arr(i) = i\n+    end do\n+\n+    !$acc parallel copy(arr) num_gangs(32) num_workers(8) vector_length(32)\n+    !$acc loop gang private(x)\n+    do i = 1, 32\n+       x = i * 2;\n+       arr(i) = arr(i) + x\n+    end do\n+    !$acc end parallel\n+\n+    do i = 1, 32\n+       if (arr(i) .ne. i * 3) STOP 1\n+    end do\n+  end subroutine t1\n+\n+\n+  ! Test of gang-private addressable variable declared on loop directive, with\n+  ! broadcasting to partitioned workers.\n+\n+  subroutine t2(pt)\n+    integer i, j, arr(0:32*32)\n+    type(vec3), optional :: pt\n+\n+    do i = 0, 32*32-1\n+       arr(i) = i\n+    end do\n+\n+    !$acc parallel copy(arr) num_gangs(32) num_workers(8) vector_length(32)\n+    !$acc loop gang private(pt)\n+    do i = 0, 31\n+       pt%x = i\n+       pt%y = i * 2\n+       pt%z = i * 4\n+       pt%attr(5) = i * 6\n+\n+       !$acc loop vector\n+       do j = 0, 31\n+          arr(i * 32 + j) = arr(i * 32 + j) + pt%x + pt%y + pt%z + pt%attr(5);\n+       end do\n+    end do\n+    !$acc end parallel\n+\n+    do i = 0, 32 * 32 - 1\n+       if (arr(i) .ne. i + (i / 32) * 13) STOP 2\n+    end do\n+  end subroutine t2\n+\n+  ! Test of vector-private variables declared on loop directive. Array type.\n+\n+  subroutine t3(pt)\n+    integer, optional :: pt(2)\n+    integer :: i, j, k, idx, arr(0:32*32*32)\n+\n+    do i = 0, 32*32*32-1\n+       arr(i) = i\n+    end do\n+\n+    !$acc parallel copy(arr) num_gangs(32) num_workers(8) vector_length(32)\n+    !$acc loop gang\n+    do i = 0, 31\n+       !$acc loop worker\n+       do j = 0, 31\n+          !$acc loop vector private(pt)\n+          do k = 0, 31\n+             pt(1) = ieor(i, j * 3)\n+             pt(2) = ior(i, j * 5)\n+             arr(i * 1024 + j * 32 + k) = arr(i * 1024 + j * 32 + k) + pt(1) * k\n+             arr(i * 1024 + j * 32 + k) = arr(i * 1024 + j * 32 + k) + pt(2) * k\n+          end do\n+       end do\n+    end do\n+    !$acc end parallel\n+\n+    do i = 0, 32 - 1\n+       do j = 0, 32 -1\n+          do k = 0, 32 - 1\n+             idx = i * 1024 + j * 32 + k\n+             if (arr(idx) .ne. idx + ieor(i, j * 3) * k + ior(i, j * 5) * k) then\n+                STOP 3\n+             end if\n+          end do\n+       end do\n+    end do\n+  end subroutine t3\n+\n+end program main"}, {"sha": "b76db3ef6d3046a9991c2c9ac46c4106009f242f", "filename": "libgomp/testsuite/libgomp.oacc-fortran/optional-reduction.f90", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Foptional-reduction.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Foptional-reduction.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Foptional-reduction.f90?ref=6e4d01d61f2bec57a247de1c5ee538f122ec34a8", "patch": "@@ -0,0 +1,69 @@\n+! Test optional arguments in reduction clauses.  The effect of\n+! non-present arguments in reduction clauses is undefined, and is not tested\n+! for.  The tests are based on those in reduction-1.f90.\n+\n+! { dg-do run }\n+! { dg-additional-options \"-w\" }\n+\n+program optional_reduction\n+  implicit none\n+\n+  integer :: rg, rw, rv, rc\n+\n+  rg = 0\n+  rw = 0\n+  rv = 0\n+  rc = 0\n+\n+  call do_test(rg, rw, rv, rc)\n+contains\n+  subroutine do_test(rg, rw, rv, rc)\n+    integer, parameter     :: n = 10, ng = 8, nw = 4, vl = 32\n+    integer, optional      :: rg, rw, rv, rc\n+    integer                :: i, vresult\n+    integer, dimension (n) :: array\n+\n+    vresult = 0\n+    do i = 1, n\n+       array(i) = i\n+    end do\n+\n+    !$acc parallel num_gangs(ng) copy(rg)\n+    !$acc loop reduction(+:rg) gang\n+    do i = 1, n\n+       rg = rg + array(i)\n+    end do\n+    !$acc end parallel\n+\n+    !$acc parallel num_workers(nw) copy(rw)\n+    !$acc loop reduction(+:rw) worker\n+    do i = 1, n\n+       rw = rw + array(i)\n+    end do\n+    !$acc end parallel\n+\n+    !$acc parallel vector_length(vl) copy(rv)\n+    !$acc loop reduction(+:rv) vector\n+    do i = 1, n\n+       rv = rv + array(i)\n+    end do\n+    !$acc end parallel\n+\n+    !$acc parallel num_gangs(ng) num_workers(nw) vector_length(vl) copy(rc)\n+    !$acc loop reduction(+:rc) gang worker vector\n+    do i = 1, n\n+       rc = rc + array(i)\n+    end do\n+    !$acc end parallel\n+\n+    ! Verify the results\n+    do i = 1, n\n+       vresult = vresult + array(i)\n+    end do\n+\n+    if (rg .ne. vresult) STOP 1\n+    if (rw .ne. vresult) STOP 2\n+    if (rv .ne. vresult) STOP 3\n+    if (rc .ne. vresult) STOP 4\n+  end subroutine do_test\n+end program optional_reduction"}, {"sha": "57f69001d3d45948b8517c08650ff20056509b37", "filename": "libgomp/testsuite/libgomp.oacc-fortran/optional-update-device.f90", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Foptional-update-device.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Foptional-update-device.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Foptional-update-device.f90?ref=6e4d01d61f2bec57a247de1c5ee538f122ec34a8", "patch": "@@ -0,0 +1,121 @@\n+! Test OpenACC update to device with an optional argument.\n+\n+! { dg-do run }\n+\n+program optional_update_device\n+  implicit none\n+\n+  integer, parameter :: n = 64\n+  integer :: i\n+  integer :: a_int, b_int, res_int\n+  integer :: a_arr(n), b_arr(n), res_arr(n)\n+  integer, allocatable :: a_alloc(:), b_alloc(:), res_alloc(:)\n+\n+  a_int = 5\n+  b_int = 11\n+\n+  call test_int(res_int, a_int)\n+  if (res_int .ne. a_int) stop 1\n+\n+  call test_int(res_int, a_int, b_int)\n+  if (res_int .ne. a_int * b_int) stop 2\n+\n+  res_arr(:) = 0\n+  do i = 1, n\n+    a_arr(i) = i\n+    b_arr(i) = n - i + 1\n+  end do\n+\n+  call test_array(res_arr, a_arr)\n+  do i = 1, n\n+    if (res_arr(i) .ne. a_arr(i)) stop 3\n+  end do\n+\n+  call test_array(res_arr, a_arr, b_arr)\n+  do i = 1, n\n+    if (res_arr(i) .ne. a_arr(i) * b_arr(i)) stop 4\n+  end do\n+\n+  allocate (a_alloc(n))\n+  allocate (b_alloc(n))\n+  allocate (res_alloc(n))\n+\n+  res_alloc(:) = 0\n+  do i = 1, n\n+    a_alloc(i) = i\n+    b_alloc(i) = n - i + 1\n+  end do\n+\n+  call test_allocatable(res_alloc, a_alloc)\n+  do i = 1, n\n+    if (res_alloc(i) .ne. a_alloc(i)) stop 5\n+  end do\n+\n+  call test_allocatable(res_alloc, a_alloc, b_alloc)\n+  do i = 1, n\n+    if (res_alloc(i) .ne. a_alloc(i) * b_alloc(i)) stop 6\n+  end do\n+\n+  deallocate (a_alloc)\n+  deallocate (b_alloc)\n+  deallocate (res_alloc)\n+contains\n+  subroutine test_int(res, a, b)\n+    integer :: res\n+    integer :: a\n+    integer, optional :: b\n+\n+    !$acc data create(a, b, res)\n+    !$acc update device(a, b)\n+    !$acc parallel\n+    res = a\n+    if (present(b)) res = res * b\n+    !$acc end parallel\n+    !$acc update self(res)\n+    !$acc end data\n+  end subroutine test_int\n+\n+  subroutine test_array(res, a, b)\n+    integer :: res(n)\n+    integer :: a(n)\n+    integer, optional :: b(n)\n+\n+    !$acc data create(a, b, res)\n+    !$acc update device(a, b)\n+    !$acc parallel loop\n+    do i = 1, n\n+      res(i) = a(i)\n+    end do\n+\n+    !$acc parallel loop\n+    do i = 1, n\n+      if (present(b)) then\n+        res(i) = res(i) * b(i)\n+      end if\n+    end do\n+    !$acc update self(res)\n+    !$acc end data\n+  end subroutine test_array\n+\n+  subroutine test_allocatable(res, a, b)\n+    integer, allocatable :: res(:)\n+    integer, allocatable :: a(:)\n+    integer, allocatable, optional :: b(:)\n+\n+    !$acc data create(a, b, res)\n+    !$acc update device(a, b)\n+    !$acc parallel loop\n+    do i = 1, n\n+      res(i) = a(i)\n+    end do\n+\n+    !$acc parallel loop\n+    do i = 1, n\n+      if (present(b)) then\n+        res(i) = res(i) * b(i)\n+      end if\n+    end do\n+    !$acc update self(res)\n+    !$acc end data\n+  end subroutine test_allocatable\n+end program optional_update_device"}, {"sha": "36b94241b11abd9dc26f62d23c4b967fbf683c2e", "filename": "libgomp/testsuite/libgomp.oacc-fortran/optional-update-host.f90", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Foptional-update-host.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4d01d61f2bec57a247de1c5ee538f122ec34a8/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Foptional-update-host.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Foptional-update-host.f90?ref=6e4d01d61f2bec57a247de1c5ee538f122ec34a8", "patch": "@@ -0,0 +1,115 @@\n+! Test OpenACC update to host with an optional argument.\n+\n+! { dg-do run }\n+\n+program optional_update_host\n+  implicit none\n+\n+  integer, parameter :: n = 64\n+  integer :: i\n+  integer :: a_int, b_int, res_int\n+  integer :: a_arr(n), b_arr(n), res_arr(n)\n+  integer, allocatable :: a_alloc(:), b_alloc(:), res_alloc(:)\n+\n+  a_int = 5\n+  b_int = 11\n+  res_int = 0\n+\n+  call test_int(a_int, b_int)\n+  if (res_int .ne. 0) stop 1\n+\n+  call test_int(a_int, b_int, res_int)\n+  if (res_int .ne. a_int * b_int) stop 2\n+\n+  res_arr(:) = 0\n+  do i = 1, n\n+    a_arr(i) = i\n+    b_arr(i) = n - i + 1\n+  end do\n+\n+  call test_array(a_arr, b_arr)\n+  do i = 1, n\n+    if (res_arr(i) .ne. 0) stop 1\n+  end do\n+\n+  call test_array(a_arr, b_arr, res_arr)\n+  do i = 1, n\n+    if (res_arr(i) .ne. a_arr(i) * b_arr(i)) stop 2\n+  end do\n+\n+  allocate(a_alloc(n))\n+  allocate(b_alloc(n))\n+  allocate(res_alloc(n))\n+\n+  res_alloc(:) = 0\n+  do i = 1, n\n+    a_alloc(i) = i\n+    b_alloc(i) = n - i + 1\n+  end do\n+\n+  call test_allocatable(a_alloc, b_alloc)\n+  do i = 1, n\n+    if (res_alloc(i) .ne. 0) stop 1\n+  end do\n+\n+  call test_allocatable(a_alloc, b_alloc, res_alloc)\n+  do i = 1, n\n+    if (res_alloc(i) .ne. a_alloc(i) * b_alloc(i)) stop 2\n+  end do\n+\n+  deallocate(a_alloc)\n+  deallocate(b_alloc)\n+  deallocate(res_alloc)\n+contains\n+  subroutine test_int(a, b, res)\n+    integer :: a, b\n+    integer, optional :: res\n+\n+    !$acc data create(a, b, res)\n+    !$acc update device(a, b)\n+    !$acc parallel\n+    if (present(res)) res = a\n+    if (present(res)) res = res * b\n+    !$acc end parallel\n+    !$acc update self(res)\n+    !$acc end data\n+  end subroutine test_int\n+\n+  subroutine test_array(a, b, res)\n+    integer :: a(n), b(n)\n+    integer, optional :: res(n)\n+\n+    !$acc data create(a, b, res)\n+    !$acc update device(a, b)\n+    !$acc parallel loop\n+    do i = 1, n\n+      if (present(res)) res(i) = a(i)\n+    end do\n+\n+    !$acc parallel loop\n+    do i = 1, n\n+      if (present(res)) res(i) = res(i) * b(i)\n+    end do\n+    !$acc update self(res)\n+    !$acc end data\n+  end subroutine test_array\n+\n+  subroutine test_allocatable(a, b, res)\n+    integer, allocatable :: a(:), b(:)\n+    integer, allocatable, optional :: res(:)\n+\n+    !$acc data create(a, b, res)\n+    !$acc update device(a, b)\n+    !$acc parallel loop\n+    do i = 1, n\n+      if (present(res)) res(i) = a(i)\n+    end do\n+\n+    !$acc parallel loop\n+    do i = 1, n\n+      if (present(res)) res(i) = res(i) * b(i)\n+    end do\n+    !$acc update self(res)\n+    !$acc end data\n+  end subroutine test_allocatable\n+end program optional_update_host "}]}