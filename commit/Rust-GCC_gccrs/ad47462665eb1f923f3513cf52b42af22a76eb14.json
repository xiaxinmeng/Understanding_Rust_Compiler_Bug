{"sha": "ad47462665eb1f923f3513cf52b42af22a76eb14", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWQ0NzQ2MjY2NWViMWY5MjNmMzUxM2NmNTJiNDJhZjIyYTc2ZWIxNA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-09-12T13:29:05Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-09-12T13:29:05Z"}, "message": "Convert hard_regno_nregs to a function\n\nThis patch converts hard_regno_nregs into an inline function, which\nin turn allows hard_regno_nregs to be used as the name of a targetm\nfield.  This is just a mechanical change.\n\n2017-09-12  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* regs.h (hard_regno_nregs): Turn into a function.\n\t(end_hard_regno): Update accordingly.\n\t* caller-save.c (setup_save_areas): Likewise.\n\t(save_call_clobbered_regs): Likewise.\n\t(replace_reg_with_saved_mem): Likewise.\n\t(insert_restore): Likewise.\n\t(insert_save): Likewise.\n\t* combine.c (can_change_dest_mode): Likewise.\n\t(move_deaths): Likewise.\n\t(distribute_notes): Likewise.\n\t* config/mips/mips.c (mips_hard_regno_call_part_clobbered): Likewise.\n\t* config/powerpcspe/powerpcspe.c (rs6000_cannot_change_mode_class)\n\t(rs6000_split_multireg_move): Likewise.\n\t(rs6000_register_move_cost): Likewise.\n\t(rs6000_memory_move_cost): Likewise.\n\t* config/rs6000/rs6000.c (rs6000_cannot_change_mode_class): Likewise.\n\t(rs6000_split_multireg_move): Likewise.\n\t(rs6000_register_move_cost): Likewise.\n\t(rs6000_memory_move_cost): Likewise.\n\t* cselib.c (cselib_reset_table): Likewise.\n\t(cselib_lookup_1): Likewise.\n\t* emit-rtl.c (set_mode_and_regno): Likewise.\n\t* function.c (aggregate_value_p): Likewise.\n\t* ira-color.c (setup_profitable_hard_regs): Likewise.\n\t(check_hard_reg_p): Likewise.\n\t(calculate_saved_nregs): Likewise.\n\t(assign_hard_reg): Likewise.\n\t(improve_allocation): Likewise.\n\t(calculate_spill_cost): Likewise.\n\t* ira-emit.c (modify_move_list): Likewise.\n\t* ira-int.h (ira_hard_reg_set_intersection_p): Likewise.\n\t(ira_hard_reg_in_set_p): Likewise.\n\t* ira.c (setup_reg_mode_hard_regset): Likewise.\n\t(clarify_prohibited_class_mode_regs): Likewise.\n\t(check_allocation): Likewise.\n\t* lra-assigns.c (find_hard_regno_for_1): Likewise.\n\t(lra_setup_reg_renumber): Likewise.\n\t(setup_try_hard_regno_pseudos): Likewise.\n\t(spill_for): Likewise.\n\t(assign_hard_regno): Likewise.\n\t(setup_live_pseudos_and_spill_after_risky_transforms): Likewise.\n\t* lra-constraints.c (in_class_p): Likewise.\n\t(lra_constraint_offset): Likewise.\n\t(simplify_operand_subreg): Likewise.\n\t(lra_constraints): Likewise.\n\t(split_reg): Likewise.\n\t(split_if_necessary): Likewise.\n\t(invariant_p): Likewise.\n\t(inherit_in_ebb): Likewise.\n\t* lra-lives.c (process_bb_lives): Likewise.\n\t* lra-remat.c (reg_overlap_for_remat_p): Likewise.\n\t(get_hard_regs): Likewise.\n\t(do_remat): Likewise.\n\t* lra-spills.c (assign_spill_hard_regs): Likewise.\n\t* mode-switching.c (create_pre_exit): Likewise.\n\t* postreload.c (reload_combine_recognize_pattern): Likewise.\n\t* recog.c (peep2_find_free_register): Likewise.\n\t* regcprop.c (kill_value_regno): Likewise.\n\t(set_value_regno): Likewise.\n\t(copy_value): Likewise.\n\t(maybe_mode_change): Likewise.\n\t(find_oldest_value_reg): Likewise.\n\t(copyprop_hardreg_forward_1): Likewise.\n\t* regrename.c (check_new_reg_p): Likewise.\n\t(regrename_do_replace): Likewise.\n\t* reload.c (push_reload): Likewise.\n\t(combine_reloads): Likewise.\n\t(find_dummy_reload): Likewise.\n\t(operands_match_p): Likewise.\n\t(find_reloads): Likewise.\n\t(find_equiv_reg): Likewise.\n\t(reload_adjust_reg_for_mode): Likewise.\n\t* reload1.c (count_pseudo): Likewise.\n\t(count_spilled_pseudo): Likewise.\n\t(find_reg): Likewise.\n\t(clear_reload_reg_in_use): Likewise.\n\t(free_for_value_p): Likewise.\n\t(allocate_reload_reg): Likewise.\n\t(choose_reload_regs): Likewise.\n\t(reload_adjust_reg_for_temp): Likewise.\n\t(emit_reload_insns): Likewise.\n\t(delete_output_reload): Likewise.\n\t* rtlanal.c (subreg_get_info): Likewise.\n\t* sched-deps.c (sched_analyze_reg): Likewise.\n\t* sel-sched.c (init_regs_for_mode): Likewise.\n\t(mark_unavailable_hard_regs): Likewise.\n\t(choose_best_reg_1): Likewise.\n\t(verify_target_availability): Likewise.\n\t* valtrack.c (dead_debug_insert_temp): Likewise.\n\t* var-tracking.c (track_loc_p): Likewise.\n\t(emit_note_insn_var_location): Likewise.\n\t* varasm.c (make_decl_rtl): Likewise.\n\t* reginfo.c (choose_hard_reg_mode): Likewise.\n\t(init_reg_modes_target): Refer directly to\n\tthis_target_regs->x_hard_regno_nregs.\n\nFrom-SVN: r252014", "tree": {"sha": "39903780452660d7041b07767c2136d8b43fefaa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39903780452660d7041b07767c2136d8b43fefaa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad47462665eb1f923f3513cf52b42af22a76eb14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad47462665eb1f923f3513cf52b42af22a76eb14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad47462665eb1f923f3513cf52b42af22a76eb14", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad47462665eb1f923f3513cf52b42af22a76eb14/comments", "author": null, "committer": null, "parents": [{"sha": "c1b52c0ef6eeb91b5326eee18bb2652e3f732162", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1b52c0ef6eeb91b5326eee18bb2652e3f732162", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1b52c0ef6eeb91b5326eee18bb2652e3f732162"}], "stats": {"total": 451, "additions": 281, "deletions": 170}, "files": [{"sha": "87f5885342f04d7e612da1f92b6b625d838f3453", "filename": "gcc/ChangeLog", "status": "modified", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ad47462665eb1f923f3513cf52b42af22a76eb14", "patch": "@@ -1,3 +1,101 @@\n+2017-09-12  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* regs.h (hard_regno_nregs): Turn into a function.\n+\t(end_hard_regno): Update accordingly.\n+\t* caller-save.c (setup_save_areas): Likewise.\n+\t(save_call_clobbered_regs): Likewise.\n+\t(replace_reg_with_saved_mem): Likewise.\n+\t(insert_restore): Likewise.\n+\t(insert_save): Likewise.\n+\t* combine.c (can_change_dest_mode): Likewise.\n+\t(move_deaths): Likewise.\n+\t(distribute_notes): Likewise.\n+\t* config/mips/mips.c (mips_hard_regno_call_part_clobbered): Likewise.\n+\t* config/powerpcspe/powerpcspe.c (rs6000_cannot_change_mode_class)\n+\t(rs6000_split_multireg_move): Likewise.\n+\t(rs6000_register_move_cost): Likewise.\n+\t(rs6000_memory_move_cost): Likewise.\n+\t* config/rs6000/rs6000.c (rs6000_cannot_change_mode_class): Likewise.\n+\t(rs6000_split_multireg_move): Likewise.\n+\t(rs6000_register_move_cost): Likewise.\n+\t(rs6000_memory_move_cost): Likewise.\n+\t* cselib.c (cselib_reset_table): Likewise.\n+\t(cselib_lookup_1): Likewise.\n+\t* emit-rtl.c (set_mode_and_regno): Likewise.\n+\t* function.c (aggregate_value_p): Likewise.\n+\t* ira-color.c (setup_profitable_hard_regs): Likewise.\n+\t(check_hard_reg_p): Likewise.\n+\t(calculate_saved_nregs): Likewise.\n+\t(assign_hard_reg): Likewise.\n+\t(improve_allocation): Likewise.\n+\t(calculate_spill_cost): Likewise.\n+\t* ira-emit.c (modify_move_list): Likewise.\n+\t* ira-int.h (ira_hard_reg_set_intersection_p): Likewise.\n+\t(ira_hard_reg_in_set_p): Likewise.\n+\t* ira.c (setup_reg_mode_hard_regset): Likewise.\n+\t(clarify_prohibited_class_mode_regs): Likewise.\n+\t(check_allocation): Likewise.\n+\t* lra-assigns.c (find_hard_regno_for_1): Likewise.\n+\t(lra_setup_reg_renumber): Likewise.\n+\t(setup_try_hard_regno_pseudos): Likewise.\n+\t(spill_for): Likewise.\n+\t(assign_hard_regno): Likewise.\n+\t(setup_live_pseudos_and_spill_after_risky_transforms): Likewise.\n+\t* lra-constraints.c (in_class_p): Likewise.\n+\t(lra_constraint_offset): Likewise.\n+\t(simplify_operand_subreg): Likewise.\n+\t(lra_constraints): Likewise.\n+\t(split_reg): Likewise.\n+\t(split_if_necessary): Likewise.\n+\t(invariant_p): Likewise.\n+\t(inherit_in_ebb): Likewise.\n+\t* lra-lives.c (process_bb_lives): Likewise.\n+\t* lra-remat.c (reg_overlap_for_remat_p): Likewise.\n+\t(get_hard_regs): Likewise.\n+\t(do_remat): Likewise.\n+\t* lra-spills.c (assign_spill_hard_regs): Likewise.\n+\t* mode-switching.c (create_pre_exit): Likewise.\n+\t* postreload.c (reload_combine_recognize_pattern): Likewise.\n+\t* recog.c (peep2_find_free_register): Likewise.\n+\t* regcprop.c (kill_value_regno): Likewise.\n+\t(set_value_regno): Likewise.\n+\t(copy_value): Likewise.\n+\t(maybe_mode_change): Likewise.\n+\t(find_oldest_value_reg): Likewise.\n+\t(copyprop_hardreg_forward_1): Likewise.\n+\t* regrename.c (check_new_reg_p): Likewise.\n+\t(regrename_do_replace): Likewise.\n+\t* reload.c (push_reload): Likewise.\n+\t(combine_reloads): Likewise.\n+\t(find_dummy_reload): Likewise.\n+\t(operands_match_p): Likewise.\n+\t(find_reloads): Likewise.\n+\t(find_equiv_reg): Likewise.\n+\t(reload_adjust_reg_for_mode): Likewise.\n+\t* reload1.c (count_pseudo): Likewise.\n+\t(count_spilled_pseudo): Likewise.\n+\t(find_reg): Likewise.\n+\t(clear_reload_reg_in_use): Likewise.\n+\t(free_for_value_p): Likewise.\n+\t(allocate_reload_reg): Likewise.\n+\t(choose_reload_regs): Likewise.\n+\t(reload_adjust_reg_for_temp): Likewise.\n+\t(emit_reload_insns): Likewise.\n+\t(delete_output_reload): Likewise.\n+\t* rtlanal.c (subreg_get_info): Likewise.\n+\t* sched-deps.c (sched_analyze_reg): Likewise.\n+\t* sel-sched.c (init_regs_for_mode): Likewise.\n+\t(mark_unavailable_hard_regs): Likewise.\n+\t(choose_best_reg_1): Likewise.\n+\t(verify_target_availability): Likewise.\n+\t* valtrack.c (dead_debug_insert_temp): Likewise.\n+\t* var-tracking.c (track_loc_p): Likewise.\n+\t(emit_note_insn_var_location): Likewise.\n+\t* varasm.c (make_decl_rtl): Likewise.\n+\t* reginfo.c (choose_hard_reg_mode): Likewise.\n+\t(init_reg_modes_target): Refer directly to\n+\tthis_target_regs->x_hard_regno_nregs.\n+\n 2017-09-12  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* ira-costs.c (record_operand_costs): Use in_hard_reg_set_p"}, {"sha": "6e4ffc173d5e8bacd62697b65418dc54626b637e", "filename": "gcc/caller-save.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=ad47462665eb1f923f3513cf52b42af22a76eb14", "patch": "@@ -480,7 +480,7 @@ setup_save_areas (void)\n \t  if (r < 0 || regno_reg_rtx[regno] == cheap)\n \t    continue;\n \n-\t  bound = r + hard_regno_nregs[r][PSEUDO_REGNO_MODE (regno)];\n+\t  bound = r + hard_regno_nregs (r, PSEUDO_REGNO_MODE (regno));\n \t  for (; r < bound; r++)\n \t    if (TEST_HARD_REG_BIT (used_regs, r))\n \t      {\n@@ -559,7 +559,7 @@ setup_save_areas (void)\n \t      if (r < 0 || regno_reg_rtx[regno] == cheap)\n \t\tcontinue;\n \n-\t      bound = r + hard_regno_nregs[r][PSEUDO_REGNO_MODE (regno)];\n+\t      bound = r + hard_regno_nregs (r, PSEUDO_REGNO_MODE (regno));\n \t      for (; r < bound; r++)\n \t\tif (TEST_HARD_REG_BIT (used_regs, r))\n \t\t  call_saved_regs[call_saved_regs_num++] = hard_reg_map[r];\n@@ -835,7 +835,7 @@ save_call_clobbered_regs (void)\n \n \t\t  if (r < 0 || regno_reg_rtx[regno] == cheap)\n \t\t    continue;\n-\t\t  nregs = hard_regno_nregs[r][PSEUDO_REGNO_MODE (regno)];\n+\t\t  nregs = hard_regno_nregs (r, PSEUDO_REGNO_MODE (regno));\n \t\t  mode = HARD_REGNO_CALLER_SAVE_MODE\n \t\t    (r, nregs, PSEUDO_REGNO_MODE (regno));\n \t\t  if (partial_subreg_p (save_mode[r], mode))\n@@ -1103,7 +1103,7 @@ replace_reg_with_saved_mem (rtx *loc,\n \t\t\t    int regno,\n \t\t\t    void *arg)\n {\n-  unsigned int i, nregs = hard_regno_nregs [regno][mode];\n+  unsigned int i, nregs = hard_regno_nregs (regno, mode);\n   rtx mem;\n   machine_mode *save_mode = (machine_mode *)arg;\n \n@@ -1125,7 +1125,7 @@ replace_reg_with_saved_mem (rtx *loc,\n     {\n       mem = copy_rtx (regno_save_mem[regno][nregs]);\n \n-      if (nregs == (unsigned int) hard_regno_nregs[regno][save_mode[regno]])\n+      if (nregs == hard_regno_nregs (regno, save_mode[regno]))\n \tmem = adjust_address_nv (mem, save_mode[regno], 0);\n \n       if (GET_MODE (mem) != mode)\n@@ -1159,7 +1159,7 @@ replace_reg_with_saved_mem (rtx *loc,\n \t  {\n \t    machine_mode smode = save_mode[regno];\n \t    gcc_assert (smode != VOIDmode);\n-\t    if (hard_regno_nregs [regno][smode] > 1)\n+\t    if (hard_regno_nregs (regno, smode) > 1)\n \t      smode = mode_for_size (GET_MODE_SIZE (mode) / nregs,\n \t\t\t\t     GET_MODE_CLASS (mode), 0).require ();\n \t    XVECEXP (mem, 0, i) = gen_rtx_REG (smode, regno + i);\n@@ -1232,7 +1232,7 @@ insert_restore (struct insn_chain *chain, int before_p, int regno,\n   mem = regno_save_mem [regno][numregs];\n   if (save_mode [regno] != VOIDmode\n       && save_mode [regno] != GET_MODE (mem)\n-      && numregs == (unsigned int) hard_regno_nregs[regno][save_mode [regno]]\n+      && numregs == hard_regno_nregs (regno, save_mode [regno])\n       /* Check that insn to restore REGNO in save_mode[regno] is\n \t correct.  */\n       && reg_save_code (regno, save_mode[regno]) >= 0)\n@@ -1311,7 +1311,7 @@ insert_save (struct insn_chain *chain, int before_p, int regno,\n   mem = regno_save_mem [regno][numregs];\n   if (save_mode [regno] != VOIDmode\n       && save_mode [regno] != GET_MODE (mem)\n-      && numregs == (unsigned int) hard_regno_nregs[regno][save_mode [regno]]\n+      && numregs == hard_regno_nregs (regno, save_mode [regno])\n       /* Check that insn to save REGNO in save_mode[regno] is\n \t correct.  */\n       && reg_save_code (regno, save_mode[regno]) >= 0)"}, {"sha": "84ce873610734607f8f45aa32a91a6ebb67d7a43", "filename": "gcc/combine.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=ad47462665eb1f923f3513cf52b42af22a76eb14", "patch": "@@ -2456,7 +2456,7 @@ can_change_dest_mode (rtx x, int added_sets, machine_mode mode)\n      registers than the old mode.  */\n   if (regno < FIRST_PSEUDO_REGISTER)\n     return (targetm.hard_regno_mode_ok (regno, mode)\n-\t    && REG_NREGS (x) >= hard_regno_nregs[regno][mode]);\n+\t    && REG_NREGS (x) >= hard_regno_nregs (regno, mode));\n \n   /* Or a pseudo that is only used once.  */\n   return (regno < reg_n_sets_max\n@@ -13925,7 +13925,7 @@ move_deaths (rtx x, rtx maybe_kill_insn, int from_luid, rtx_insn *to_insn,\n \t      rtx oldnotes = 0;\n \n \t      if (note)\n-\t\toffset = hard_regno_nregs[regno][GET_MODE (XEXP (note, 0))];\n+\t\toffset = hard_regno_nregs (regno, GET_MODE (XEXP (note, 0)));\n \t      else\n \t\toffset = 1;\n \n@@ -14537,7 +14537,7 @@ distribute_notes (rtx notes, rtx_insn *from_insn, rtx_insn *i3, rtx_insn *i2,\n \t\t\t not already dead or set.  */\n \n \t\t      for (i = regno; i < endregno;\n-\t\t\t   i += hard_regno_nregs[i][reg_raw_mode[i]])\n+\t\t\t   i += hard_regno_nregs (i, reg_raw_mode[i]))\n \t\t\t{\n \t\t\t  rtx piece = regno_reg_rtx[i];\n \t\t\t  basic_block bb = this_basic_block;"}, {"sha": "fd838a366bfabf453a0bcd5c318740d7c2cd15b6", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=ad47462665eb1f923f3513cf52b42af22a76eb14", "patch": "@@ -12877,7 +12877,7 @@ static bool\n mips_hard_regno_call_part_clobbered (unsigned int regno, machine_mode mode)\n {\n   if (TARGET_FLOATXX\n-      && hard_regno_nregs[regno][mode] == 1\n+      && hard_regno_nregs (regno, mode) == 1\n       && FP_REG_P (regno)\n       && (regno & 1) != 0)\n     return true;"}, {"sha": "c93bbc57cce86e8a83b689369472a41eecf252d5", "filename": "gcc/config/powerpcspe/powerpcspe.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c?ref=ad47462665eb1f923f3513cf52b42af22a76eb14", "patch": "@@ -23306,8 +23306,8 @@ rs6000_cannot_change_mode_class (machine_mode from,\n \n       if (reg_classes_intersect_p (xclass, rclass))\n \t{\n-\t  unsigned to_nregs = hard_regno_nregs[FIRST_FPR_REGNO][to];\n-\t  unsigned from_nregs = hard_regno_nregs[FIRST_FPR_REGNO][from];\n+\t  unsigned to_nregs = hard_regno_nregs (FIRST_FPR_REGNO, to);\n+\t  unsigned from_nregs = hard_regno_nregs (FIRST_FPR_REGNO, from);\n \t  bool to_float128_vector_p = FLOAT128_VECTOR_P (to);\n \t  bool from_float128_vector_p = FLOAT128_VECTOR_P (from);\n \n@@ -23365,8 +23365,8 @@ rs6000_cannot_change_mode_class (machine_mode from,\n   if (TARGET_VSX && VSX_REG_CLASS_P (rclass))\n     {\n       unsigned num_regs = (from_size + 15) / 16;\n-      if (hard_regno_nregs[FIRST_FPR_REGNO][to] > num_regs\n-\t  || hard_regno_nregs[FIRST_FPR_REGNO][from] > num_regs)\n+      if (hard_regno_nregs (FIRST_FPR_REGNO, to) > num_regs\n+\t  || hard_regno_nregs (FIRST_FPR_REGNO, from) > num_regs)\n \treturn true;\n \n       return (from_size != 8 && from_size != 16);\n@@ -26769,7 +26769,7 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n \n   reg = REG_P (dst) ? REGNO (dst) : REGNO (src);\n   mode = GET_MODE (dst);\n-  nregs = hard_regno_nregs[reg][mode];\n+  nregs = hard_regno_nregs (reg, mode);\n   if (FP_REGNO_P (reg))\n     reg_mode = DECIMAL_FLOAT_MODE_P (mode) ? DDmode : \n \t((TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT) ? DFmode : SFmode);\n@@ -37836,18 +37836,18 @@ rs6000_register_move_cost (machine_mode mode,\n \t\t|| rs6000_cpu == PROCESSOR_POWER8\n \t\t|| rs6000_cpu == PROCESSOR_POWER9)\n \t       && reg_classes_intersect_p (rclass, LINK_OR_CTR_REGS))\n-        ret = 6 * hard_regno_nregs[0][mode];\n+        ret = 6 * hard_regno_nregs (0, mode);\n \n       else\n \t/* A move will cost one instruction per GPR moved.  */\n-\tret = 2 * hard_regno_nregs[0][mode];\n+\tret = 2 * hard_regno_nregs (0, mode);\n     }\n \n   /* If we have VSX, we can easily move between FPR or Altivec registers.  */\n   else if (VECTOR_MEM_VSX_P (mode)\n \t   && reg_classes_intersect_p (to, VSX_REGS)\n \t   && reg_classes_intersect_p (from, VSX_REGS))\n-    ret = 2 * hard_regno_nregs[FIRST_FPR_REGNO][mode];\n+    ret = 2 * hard_regno_nregs (FIRST_FPR_REGNO, mode);\n \n   /* Moving between two similar registers is just one instruction.  */\n   else if (reg_classes_intersect_p (to, from))\n@@ -37884,12 +37884,12 @@ rs6000_memory_move_cost (machine_mode mode, reg_class_t rclass,\n     dbg_cost_ctrl++;\n \n   if (reg_classes_intersect_p (rclass, GENERAL_REGS))\n-    ret = 4 * hard_regno_nregs[0][mode];\n+    ret = 4 * hard_regno_nregs (0, mode);\n   else if ((reg_classes_intersect_p (rclass, FLOAT_REGS)\n \t    || reg_classes_intersect_p (rclass, VSX_REGS)))\n-    ret = 4 * hard_regno_nregs[32][mode];\n+    ret = 4 * hard_regno_nregs (32, mode);\n   else if (reg_classes_intersect_p (rclass, ALTIVEC_REGS))\n-    ret = 4 * hard_regno_nregs[FIRST_ALTIVEC_REGNO][mode];\n+    ret = 4 * hard_regno_nregs (FIRST_ALTIVEC_REGNO, mode);\n   else\n     ret = 4 + rs6000_register_move_cost (mode, rclass, GENERAL_REGS);\n "}, {"sha": "bc7e2a0dd9c2e6643ebb8b5700a23af865c8374a", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=ad47462665eb1f923f3513cf52b42af22a76eb14", "patch": "@@ -20644,8 +20644,8 @@ rs6000_cannot_change_mode_class (machine_mode from,\n \n       if (reg_classes_intersect_p (xclass, rclass))\n \t{\n-\t  unsigned to_nregs = hard_regno_nregs[FIRST_FPR_REGNO][to];\n-\t  unsigned from_nregs = hard_regno_nregs[FIRST_FPR_REGNO][from];\n+\t  unsigned to_nregs = hard_regno_nregs (FIRST_FPR_REGNO, to);\n+\t  unsigned from_nregs = hard_regno_nregs (FIRST_FPR_REGNO, from);\n \t  bool to_float128_vector_p = FLOAT128_VECTOR_P (to);\n \t  bool from_float128_vector_p = FLOAT128_VECTOR_P (from);\n \n@@ -20693,8 +20693,8 @@ rs6000_cannot_change_mode_class (machine_mode from,\n   if (TARGET_VSX && VSX_REG_CLASS_P (rclass))\n     {\n       unsigned num_regs = (from_size + 15) / 16;\n-      if (hard_regno_nregs[FIRST_FPR_REGNO][to] > num_regs\n-\t  || hard_regno_nregs[FIRST_FPR_REGNO][from] > num_regs)\n+      if (hard_regno_nregs (FIRST_FPR_REGNO, to) > num_regs\n+\t  || hard_regno_nregs (FIRST_FPR_REGNO, from) > num_regs)\n \treturn true;\n \n       return (from_size != 8 && from_size != 16);\n@@ -23827,7 +23827,7 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n \n   reg = REG_P (dst) ? REGNO (dst) : REGNO (src);\n   mode = GET_MODE (dst);\n-  nregs = hard_regno_nregs[reg][mode];\n+  nregs = hard_regno_nregs (reg, mode);\n   if (FP_REGNO_P (reg))\n     reg_mode = DECIMAL_FLOAT_MODE_P (mode) ? DDmode : \n \t((TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT) ? DFmode : SFmode);\n@@ -34647,18 +34647,18 @@ rs6000_register_move_cost (machine_mode mode,\n \t\t|| rs6000_cpu == PROCESSOR_POWER8\n \t\t|| rs6000_cpu == PROCESSOR_POWER9)\n \t       && reg_classes_intersect_p (rclass, LINK_OR_CTR_REGS))\n-        ret = 6 * hard_regno_nregs[0][mode];\n+        ret = 6 * hard_regno_nregs (0, mode);\n \n       else\n \t/* A move will cost one instruction per GPR moved.  */\n-\tret = 2 * hard_regno_nregs[0][mode];\n+\tret = 2 * hard_regno_nregs (0, mode);\n     }\n \n   /* If we have VSX, we can easily move between FPR or Altivec registers.  */\n   else if (VECTOR_MEM_VSX_P (mode)\n \t   && reg_classes_intersect_p (to, VSX_REGS)\n \t   && reg_classes_intersect_p (from, VSX_REGS))\n-    ret = 2 * hard_regno_nregs[FIRST_FPR_REGNO][mode];\n+    ret = 2 * hard_regno_nregs (FIRST_FPR_REGNO, mode);\n \n   /* Moving between two similar registers is just one instruction.  */\n   else if (reg_classes_intersect_p (to, from))\n@@ -34695,12 +34695,12 @@ rs6000_memory_move_cost (machine_mode mode, reg_class_t rclass,\n     dbg_cost_ctrl++;\n \n   if (reg_classes_intersect_p (rclass, GENERAL_REGS))\n-    ret = 4 * hard_regno_nregs[0][mode];\n+    ret = 4 * hard_regno_nregs (0, mode);\n   else if ((reg_classes_intersect_p (rclass, FLOAT_REGS)\n \t    || reg_classes_intersect_p (rclass, VSX_REGS)))\n-    ret = 4 * hard_regno_nregs[32][mode];\n+    ret = 4 * hard_regno_nregs (32, mode);\n   else if (reg_classes_intersect_p (rclass, ALTIVEC_REGS))\n-    ret = 4 * hard_regno_nregs[FIRST_ALTIVEC_REGNO][mode];\n+    ret = 4 * hard_regno_nregs (FIRST_ALTIVEC_REGNO, mode);\n   else\n     ret = 4 + rs6000_register_move_cost (mode, rclass, GENERAL_REGS);\n "}, {"sha": "ab7d523087f848642eb57f70ce91a7f3f6e08f48", "filename": "gcc/cselib.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=ad47462665eb1f923f3513cf52b42af22a76eb14", "patch": "@@ -530,7 +530,8 @@ cselib_reset_table (unsigned int num)\n       n_used_regs = new_used_regs;\n       used_regs[0] = regno;\n       max_value_regs\n-\t= hard_regno_nregs[regno][GET_MODE (cfa_base_preserved_val->locs->loc)];\n+\t= hard_regno_nregs (regno,\n+\t\t\t    GET_MODE (cfa_base_preserved_val->locs->loc));\n     }\n   else\n     {\n@@ -2001,7 +2002,7 @@ cselib_lookup_1 (rtx x, machine_mode mode,\n \n       if (i < FIRST_PSEUDO_REGISTER)\n \t{\n-\t  unsigned int n = hard_regno_nregs[i][mode];\n+\t  unsigned int n = hard_regno_nregs (i, mode);\n \n \t  if (n > max_value_regs)\n \t    max_value_regs = n;\n@@ -2040,7 +2041,7 @@ cselib_lookup_1 (rtx x, machine_mode mode,\n \t      {\n \t\tstruct elt_loc_list *el;\n \t\tif (i < FIRST_PSEUDO_REGISTER\n-\t\t    && hard_regno_nregs[i][lmode] != 1)\n+\t\t    && hard_regno_nregs (i, lmode) != 1)\n \t\t  continue;\n \t\tfor (el = l->elt->locs; el; el = el->next)\n \t\t  if (!REG_P (el->loc))"}, {"sha": "e36a7ddcec3ebe688bf63a0bf9b2c6f6bbf29f63", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=ad47462665eb1f923f3513cf52b42af22a76eb14", "patch": "@@ -419,7 +419,7 @@ void\n set_mode_and_regno (rtx x, machine_mode mode, unsigned int regno)\n {\n   unsigned int nregs = (HARD_REGISTER_NUM_P (regno)\n-\t\t\t? hard_regno_nregs[regno][mode]\n+\t\t\t? hard_regno_nregs (regno, mode)\n \t\t\t: 1);\n   PUT_MODE_RAW (x, mode);\n   set_regno_raw (x, regno, nregs);"}, {"sha": "3fc2d0e43feca2fcf066694cb52844f1cd037d26", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=ad47462665eb1f923f3513cf52b42af22a76eb14", "patch": "@@ -2100,7 +2100,7 @@ aggregate_value_p (const_tree exp, const_tree fntype)\n     return 0;\n \n   regno = REGNO (reg);\n-  nregs = hard_regno_nregs[regno][TYPE_MODE (type)];\n+  nregs = hard_regno_nregs (regno, TYPE_MODE (type));\n   for (i = 0; i < nregs; i++)\n     if (! call_used_regs[regno + i])\n       return 1;"}, {"sha": "22fdb88274db4c22f919400045ddbfb3a4bed079", "filename": "gcc/ira-color.c", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=ad47462665eb1f923f3513cf52b42af22a76eb14", "patch": "@@ -1061,7 +1061,7 @@ setup_profitable_hard_regs (void)\n \t  || (hard_regno = ALLOCNO_HARD_REGNO (a)) < 0)\n \tcontinue;\n       mode = ALLOCNO_MODE (a);\n-      nregs = hard_regno_nregs[hard_regno][mode];\n+      nregs = hard_regno_nregs (hard_regno, mode);\n       nobj = ALLOCNO_NUM_OBJECTS (a);\n       for (k = 0; k < nobj; k++)\n \t{\n@@ -1593,7 +1593,7 @@ check_hard_reg_p (ira_allocno_t a, int hard_regno,\n   /* Checking only profitable hard regs.  */\n   if (! TEST_HARD_REG_BIT (profitable_regs, hard_regno))\n     return false;\n-  nregs = hard_regno_nregs[hard_regno][mode];\n+  nregs = hard_regno_nregs (hard_regno, mode);\n   nwords = ALLOCNO_NUM_OBJECTS (a);\n   for (j = 0; j < nregs; j++)\n     {\n@@ -1627,7 +1627,7 @@ calculate_saved_nregs (int hard_regno, machine_mode mode)\n   int nregs = 0;\n \n   ira_assert (hard_regno >= 0);\n-  for (i = hard_regno_nregs[hard_regno][mode] - 1; i >= 0; i--)\n+  for (i = hard_regno_nregs (hard_regno, mode) - 1; i >= 0; i--)\n     if (!allocated_hardreg_p[hard_regno + i]\n \t&& !TEST_HARD_REG_BIT (call_used_reg_set, hard_regno + i)\n \t&& !LOCAL_REGNO (hard_regno + i))\n@@ -1760,7 +1760,7 @@ assign_hard_reg (ira_allocno_t a, bool retry_p)\n \t\t  int conflict_nregs;\n \n \t\t  mode = ALLOCNO_MODE (conflict_a);\n-\t\t  conflict_nregs = hard_regno_nregs[hard_regno][mode];\n+\t\t  conflict_nregs = hard_regno_nregs (hard_regno, mode);\n \t\t  if (conflict_nregs == n_objects && conflict_nregs > 1)\n \t\t    {\n \t\t      int num = OBJECT_SUBWORD (conflict_obj);\n@@ -1858,7 +1858,8 @@ assign_hard_reg (ira_allocno_t a, bool retry_p)\n \t    rclass = REGNO_REG_CLASS (hard_regno);\n \t    add_cost = ((ira_memory_move_cost[mode][rclass][0]\n \t\t         + ira_memory_move_cost[mode][rclass][1])\n-\t\t        * saved_nregs / hard_regno_nregs[hard_regno][mode] - 1);\n+\t\t        * saved_nregs / hard_regno_nregs (hard_regno,\n+\t\t\t\t\t\t\t  mode) - 1);\n \t    cost += add_cost;\n \t    full_cost += add_cost;\n \t  }\n@@ -1885,7 +1886,7 @@ assign_hard_reg (ira_allocno_t a, bool retry_p)\n  fail:\n   if (best_hard_regno >= 0)\n     {\n-      for (i = hard_regno_nregs[best_hard_regno][mode] - 1; i >= 0; i--)\n+      for (i = hard_regno_nregs (best_hard_regno, mode) - 1; i >= 0; i--)\n \tallocated_hardreg_p[best_hard_regno + i] = true;\n     }\n   if (! retry_p)\n@@ -2890,8 +2891,8 @@ improve_allocation (void)\n \t\tspill_cost -= ALLOCNO_UPDATED_CLASS_COST (conflict_a);\n \t      spill_cost\n \t\t+= allocno_copy_cost_saving (conflict_a, conflict_hregno);\n-\t      conflict_nregs\n-\t\t= hard_regno_nregs[conflict_hregno][ALLOCNO_MODE (conflict_a)];\n+\t      conflict_nregs = hard_regno_nregs (conflict_hregno,\n+\t\t\t\t\t\t ALLOCNO_MODE (conflict_a));\n \t      for (r = conflict_hregno;\n \t\t   r >= 0 && (int) end_hard_regno (mode, r) > conflict_hregno;\n \t\t   r--)\n@@ -2926,7 +2927,7 @@ improve_allocation (void)\n \t   by spilling some conflicting allocnos does not improve the\n \t   allocation cost.  */\n \tcontinue;\n-      nregs = hard_regno_nregs[best][mode];\n+      nregs = hard_regno_nregs (best, mode);\n       /* Now spill conflicting allocnos which contain a hard register\n \t of A when we assign the best chosen hard register to it.  */\n       for (word = 0; word < nwords; word++)\n@@ -2941,8 +2942,8 @@ improve_allocation (void)\n \n \t      if ((conflict_hregno = ALLOCNO_HARD_REGNO (conflict_a)) < 0)\n \t\tcontinue;\n-\t      conflict_nregs\n-\t\t= hard_regno_nregs[conflict_hregno][ALLOCNO_MODE (conflict_a)];\n+\t      conflict_nregs = hard_regno_nregs (conflict_hregno,\n+\t\t\t\t\t\t ALLOCNO_MODE (conflict_a));\n \t      if (best + nregs <= conflict_hregno\n \t\t  || conflict_hregno + conflict_nregs <= best)\n \t\t/* No intersection.  */\n@@ -4669,7 +4670,7 @@ calculate_spill_cost (int *regnos, rtx in, rtx out, rtx_insn *insn,\n       a = ira_regno_allocno_map[regno];\n       length += ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (a) / ALLOCNO_NUM_OBJECTS (a);\n       cost += ALLOCNO_MEMORY_COST (a) - ALLOCNO_CLASS_COST (a);\n-      nregs = hard_regno_nregs[hard_regno][ALLOCNO_MODE (a)];\n+      nregs = hard_regno_nregs (hard_regno, ALLOCNO_MODE (a));\n       for (j = 0; j < nregs; j++)\n \tif (! TEST_HARD_REG_BIT (call_used_reg_set, hard_regno + j))\n \t  break;"}, {"sha": "77fd72adbf2b3dded5847180addbb5d0331ca695", "filename": "gcc/ira-emit.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Fira-emit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Fira-emit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-emit.c?ref=ad47462665eb1f923f3513cf52b42af22a76eb14", "patch": "@@ -783,7 +783,7 @@ modify_move_list (move_t list)\n       to = move->to;\n       if ((hard_regno = ALLOCNO_HARD_REGNO (to)) < 0)\n \tcontinue;\n-      nregs = hard_regno_nregs[hard_regno][ALLOCNO_MODE (to)];\n+      nregs = hard_regno_nregs (hard_regno, ALLOCNO_MODE (to));\n       for (i = 0; i < nregs; i++)\n \t{\n \t  hard_regno_last_set[hard_regno + i] = move;\n@@ -796,7 +796,7 @@ modify_move_list (move_t list)\n       to = move->to;\n       if ((hard_regno = ALLOCNO_HARD_REGNO (from)) >= 0)\n \t{\n-\t  nregs = hard_regno_nregs[hard_regno][ALLOCNO_MODE (from)];\n+\t  nregs = hard_regno_nregs (hard_regno, ALLOCNO_MODE (from));\n \t  for (n = i = 0; i < nregs; i++)\n \t    if (hard_regno_last_set_check[hard_regno + i] == curr_tick\n \t\t&& (ALLOCNO_REGNO (hard_regno_last_set[hard_regno + i]->to)\n@@ -834,7 +834,7 @@ modify_move_list (move_t list)\n       to = move->to;\n       if ((hard_regno = ALLOCNO_HARD_REGNO (from)) >= 0)\n \t{\n-\t  nregs = hard_regno_nregs[hard_regno][ALLOCNO_MODE (from)];\n+\t  nregs = hard_regno_nregs (hard_regno, ALLOCNO_MODE (from));\n \t  for (i = 0; i < nregs; i++)\n \t    if (hard_regno_last_set_check[hard_regno + i] == curr_tick\n \t\t&& ALLOCNO_HARD_REGNO\n@@ -886,7 +886,7 @@ modify_move_list (move_t list)\n \t}\n       if ((hard_regno = ALLOCNO_HARD_REGNO (to)) < 0)\n \tcontinue;\n-      nregs = hard_regno_nregs[hard_regno][ALLOCNO_MODE (to)];\n+      nregs = hard_regno_nregs (hard_regno, ALLOCNO_MODE (to));\n       for (i = 0; i < nregs; i++)\n \t{\n \t  hard_regno_last_set[hard_regno + i] = move;"}, {"sha": "6296a4fd661c61195020605460c60f04e8c6de7a", "filename": "gcc/ira-int.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=ad47462665eb1f923f3513cf52b42af22a76eb14", "patch": "@@ -1393,7 +1393,7 @@ ira_hard_reg_set_intersection_p (int hard_regno, machine_mode mode,\n   int i;\n \n   gcc_assert (hard_regno >= 0);\n-  for (i = hard_regno_nregs[hard_regno][mode] - 1; i >= 0; i--)\n+  for (i = hard_regno_nregs (hard_regno, mode) - 1; i >= 0; i--)\n     if (TEST_HARD_REG_BIT (hard_regset, hard_regno + i))\n       return true;\n   return false;\n@@ -1421,7 +1421,7 @@ ira_hard_reg_in_set_p (int hard_regno, machine_mode mode,\n   int i;\n \n   ira_assert (hard_regno >= 0);\n-  for (i = hard_regno_nregs[hard_regno][mode] - 1; i >= 0; i--)\n+  for (i = hard_regno_nregs (hard_regno, mode) - 1; i >= 0; i--)\n     if (!TEST_HARD_REG_BIT (hard_regset, hard_regno + i))\n       return false;\n   return true;"}, {"sha": "046ce3bc49508145fb205561d4ef270009448685", "filename": "gcc/ira.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=ad47462665eb1f923f3513cf52b42af22a76eb14", "patch": "@@ -449,7 +449,8 @@ setup_reg_mode_hard_regset (void)\n     for (hard_regno = 0; hard_regno < FIRST_PSEUDO_REGISTER; hard_regno++)\n       {\n \tCLEAR_HARD_REG_SET (ira_reg_mode_hard_regset[hard_regno][m]);\n-\tfor (i = hard_regno_nregs[hard_regno][m] - 1; i >= 0; i--)\n+\tfor (i = hard_regno_nregs (hard_regno, (machine_mode) m) - 1;\n+\t     i >= 0; i--)\n \t  if (hard_regno + i < FIRST_PSEUDO_REGISTER)\n \t    SET_HARD_REG_BIT (ira_reg_mode_hard_regset[hard_regno][m],\n \t\t\t      hard_regno + i);\n@@ -1540,7 +1541,7 @@ clarify_prohibited_class_mode_regs (void)\n \t    hard_regno = ira_class_hard_regs[cl][k];\n \t    if (TEST_HARD_REG_BIT (ira_prohibited_class_mode_regs[cl][j], hard_regno))\n \t      continue;\n-\t    nregs = hard_regno_nregs[hard_regno][j];\n+\t    nregs = hard_regno_nregs (hard_regno, (machine_mode) j);\n \t    if (hard_regno + nregs > FIRST_PSEUDO_REGISTER)\n \t      {\n \t\tSET_HARD_REG_BIT (ira_prohibited_class_mode_regs[cl][j],\n@@ -2509,7 +2510,7 @@ check_allocation (void)\n       if (ALLOCNO_CAP_MEMBER (a) != NULL\n \t  || (hard_regno = ALLOCNO_HARD_REGNO (a)) < 0)\n \tcontinue;\n-      nregs = hard_regno_nregs[hard_regno][ALLOCNO_MODE (a)];\n+      nregs = hard_regno_nregs (hard_regno, ALLOCNO_MODE (a));\n       if (nregs == 1)\n \t/* We allocated a single hard register.  */\n \tn = 1;\n@@ -2538,9 +2539,8 @@ check_allocation (void)\n \t      if (conflict_hard_regno < 0)\n \t\tcontinue;\n \n-\t      conflict_nregs\n-\t\t= (hard_regno_nregs\n-\t\t   [conflict_hard_regno][ALLOCNO_MODE (conflict_a)]);\n+\t      conflict_nregs = hard_regno_nregs (conflict_hard_regno,\n+\t\t\t\t\t\t ALLOCNO_MODE (conflict_a));\n \n \t      if (ALLOCNO_NUM_OBJECTS (conflict_a) > 1\n \t\t  && conflict_nregs == ALLOCNO_NUM_OBJECTS (conflict_a))"}, {"sha": "9208fccfd597f1619f10ee2498234eb8bb8fa37b", "filename": "gcc/lra-assigns.c", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Flra-assigns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Flra-assigns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-assigns.c?ref=ad47462665eb1f923f3513cf52b42af22a76eb14", "patch": "@@ -568,8 +568,8 @@ find_hard_regno_for_1 (int regno, int *cost, int try_only_hard_regno,\n       if (lra_reg_val_equal_p (conflict_regno, val, offset))\n \t{\n \t  conflict_hr = live_pseudos_reg_renumber[conflict_regno];\n-\t  nregs = (hard_regno_nregs[conflict_hr]\n-\t\t   [lra_reg_info[conflict_regno].biggest_mode]);\n+\t  nregs = hard_regno_nregs (conflict_hr,\n+\t\t\t\t    lra_reg_info[conflict_regno].biggest_mode);\n \t  /* Remember about multi-register pseudos.  For example, 2\n \t     hard register pseudos can start on the same hard register\n \t     but can not start on HR and HR+1/HR-1.  */\n@@ -587,12 +587,12 @@ find_hard_regno_for_1 (int regno, int *cost, int try_only_hard_regno,\n \t  machine_mode biggest_conflict_mode\n \t    = lra_reg_info[conflict_regno].biggest_mode;\n \t  int biggest_conflict_nregs\n-\t    = hard_regno_nregs[conflict_hr][biggest_conflict_mode];\n+\t    = hard_regno_nregs (conflict_hr, biggest_conflict_mode);\n \t  \n-\t  nregs_diff = (biggest_conflict_nregs\n-\t\t\t- (hard_regno_nregs\n-\t\t\t   [conflict_hr]\n-\t\t\t   [PSEUDO_REGNO_MODE (conflict_regno)]));\n+\t  nregs_diff\n+\t    = (biggest_conflict_nregs\n+\t       - hard_regno_nregs (conflict_hr,\n+\t\t\t\t   PSEUDO_REGNO_MODE (conflict_regno)));\n \t  add_to_hard_reg_set (&conflict_set,\n \t\t\t       biggest_conflict_mode,\n \t\t\t       conflict_hr\n@@ -627,9 +627,9 @@ find_hard_regno_for_1 (int regno, int *cost, int try_only_hard_regno,\n   rclass_size = ira_class_hard_regs_num[rclass];\n   best_hard_regno = -1;\n   hard_regno = ira_class_hard_regs[rclass][0];\n-  biggest_nregs = hard_regno_nregs[hard_regno][biggest_mode];\n+  biggest_nregs = hard_regno_nregs (hard_regno, biggest_mode);\n   nregs_diff = (biggest_nregs\n-\t\t- hard_regno_nregs[hard_regno][PSEUDO_REGNO_MODE (regno)]);\n+\t\t- hard_regno_nregs (hard_regno, PSEUDO_REGNO_MODE (regno)));\n   COPY_HARD_REG_SET (available_regs, reg_class_contents[rclass]);\n   AND_COMPL_HARD_REG_SET (available_regs, lra_no_alloc_regs);\n   for (i = 0; i < rclass_size; i++)\n@@ -664,7 +664,7 @@ find_hard_regno_for_1 (int regno, int *cost, int try_only_hard_regno,\n \t      hard_regno_costs[hard_regno] = 0;\n \t    }\n \t  for (j = 0;\n-\t       j < hard_regno_nregs[hard_regno][PSEUDO_REGNO_MODE (regno)];\n+\t       j < hard_regno_nregs (hard_regno, PSEUDO_REGNO_MODE (regno));\n \t       j++)\n \t    if (! TEST_HARD_REG_BIT (call_used_reg_set, hard_regno + j)\n \t\t&& ! df_regs_ever_live_p (hard_regno + j))\n@@ -799,7 +799,7 @@ lra_setup_reg_renumber (int regno, int hard_regno, bool print_p)\n     hr = reg_renumber[regno];\n   reg_renumber[regno] = hard_regno;\n   lra_assert (hr >= 0);\n-  for (i = 0; i < hard_regno_nregs[hr][PSEUDO_REGNO_MODE (regno)]; i++)\n+  for (i = 0; i < hard_regno_nregs (hr, PSEUDO_REGNO_MODE (regno)); i++)\n     if (hard_regno < 0)\n       lra_hard_reg_usage[hr + i] -= lra_reg_info[regno].freq;\n     else\n@@ -851,7 +851,7 @@ setup_try_hard_regno_pseudos (int p, enum reg_class rclass)\n       if (overlaps_hard_reg_set_p (reg_class_contents[rclass],\n \t\t\t\t   mode, hard_regno))\n \t{\n-\t  for (i = hard_regno_nregs[hard_regno][mode] - 1; i >= 0; i--)\n+\t  for (i = hard_regno_nregs (hard_regno, mode) - 1; i >= 0; i--)\n \t    {\n \t      if (try_hard_reg_pseudos_check[hard_regno + i]\n \t\t  != curr_pseudo_check)\n@@ -974,7 +974,7 @@ spill_for (int regno, bitmap spilled_pseudo_bitmap, bool first_p)\n     {\n       hard_regno = ira_class_hard_regs[rclass][i];\n       bitmap_clear (&spill_pseudos_bitmap);\n-      for (j = hard_regno_nregs[hard_regno][mode] - 1; j >= 0; j--)\n+      for (j = hard_regno_nregs (hard_regno, mode) - 1; j >= 0; j--)\n \t{\n \t  if (try_hard_reg_pseudos_check[hard_regno + j] != curr_pseudo_check)\n \t    continue;\n@@ -1132,7 +1132,7 @@ assign_hard_regno (int hard_regno, int regno)\n   lra_setup_reg_renumber (regno, hard_regno, true);\n   update_lives (regno, false);\n   for (i = 0;\n-       i < hard_regno_nregs[hard_regno][lra_reg_info[regno].biggest_mode];\n+       i < hard_regno_nregs (hard_regno, lra_reg_info[regno].biggest_mode);\n        i++)\n     df_set_regs_ever_live (hard_regno + i, true);\n }\n@@ -1214,11 +1214,12 @@ setup_live_pseudos_and_spill_after_risky_transforms (bitmap\n \t  {\n \t    int conflict_hard_regno = reg_renumber[conflict_regno];\n \t    machine_mode biggest_mode = lra_reg_info[conflict_regno].biggest_mode;\n-\t    int biggest_nregs = hard_regno_nregs[conflict_hard_regno][biggest_mode];\n-\t    int nregs_diff = (biggest_nregs\n-\t\t\t      - (hard_regno_nregs\n-\t\t\t\t [conflict_hard_regno]\n-\t\t\t\t [PSEUDO_REGNO_MODE (conflict_regno)]));\n+\t    int biggest_nregs = hard_regno_nregs (conflict_hard_regno,\n+\t\t\t\t\t\t  biggest_mode);\n+\t    int nregs_diff\n+\t      = (biggest_nregs\n+\t\t - hard_regno_nregs (conflict_hard_regno,\n+\t\t\t\t     PSEUDO_REGNO_MODE (conflict_regno)));\n \t    add_to_hard_reg_set (&conflict_set,\n \t\t\t\t biggest_mode,\n \t\t\t\t conflict_hard_regno\n@@ -1231,7 +1232,7 @@ setup_live_pseudos_and_spill_after_risky_transforms (bitmap\n \t}\n       bitmap_set_bit (spilled_pseudo_bitmap, regno);\n       for (j = 0;\n-\t   j < hard_regno_nregs[hard_regno][PSEUDO_REGNO_MODE (regno)];\n+\t   j < hard_regno_nregs (hard_regno, PSEUDO_REGNO_MODE (regno));\n \t   j++)\n \tlra_hard_reg_usage[hard_regno + j] -= lra_reg_info[regno].freq;\n       reg_renumber[regno] = -1;"}, {"sha": "4859c584121d5aaf820ef54ec90f748c488944b1", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=ad47462665eb1f923f3513cf52b42af22a76eb14", "patch": "@@ -291,7 +291,7 @@ in_class_p (rtx reg, enum reg_class cl, enum reg_class *new_class)\n       for (i = 0; i < class_size; i++)\n \t{\n \t  hard_regno = ira_class_hard_regs[common_class][i];\n-\t  nregs = hard_regno_nregs[hard_regno][reg_mode];\n+\t  nregs = hard_regno_nregs (hard_regno, reg_mode);\n \t  if (nregs == 1)\n \t    return true;\n \t  for (j = 0; j < nregs; j++)\n@@ -676,7 +676,7 @@ lra_constraint_offset (int regno, machine_mode mode)\n   if (WORDS_BIG_ENDIAN\n       && is_a <scalar_int_mode> (mode, &int_mode)\n       && GET_MODE_SIZE (int_mode) > UNITS_PER_WORD)\n-    return hard_regno_nregs[regno][mode] - 1;\n+    return hard_regno_nregs (regno, mode) - 1;\n   return 0;\n }\n \n@@ -1655,8 +1655,8 @@ simplify_operand_subreg (int nop, machine_mode reg_mode)\n        && (hard_regno = lra_get_regno_hard_regno (REGNO (reg))) >= 0\n        /* Don't reload paradoxical subregs because we could be looping\n \t  having repeatedly final regno out of hard regs range.  */\n-       && (hard_regno_nregs[hard_regno][innermode]\n-\t   >= hard_regno_nregs[hard_regno][mode])\n+       && (hard_regno_nregs (hard_regno, innermode)\n+\t   >= hard_regno_nregs (hard_regno, mode))\n        && simplify_subreg_regno (hard_regno, innermode,\n \t\t\t\t SUBREG_BYTE (operand), mode) < 0\n        /* Don't reload subreg for matching reload.  It is actually\n@@ -1726,8 +1726,8 @@ simplify_operand_subreg (int nop, machine_mode reg_mode)\n   else if (REG_P (reg)\n \t   && REGNO (reg) >= FIRST_PSEUDO_REGISTER\n \t   && (hard_regno = lra_get_regno_hard_regno (REGNO (reg))) >= 0\n-\t   && (hard_regno_nregs[hard_regno][innermode]\n-\t       < hard_regno_nregs[hard_regno][mode])\n+\t   && (hard_regno_nregs (hard_regno, innermode)\n+\t       < hard_regno_nregs (hard_regno, mode))\n \t   && (regclass = lra_get_allocno_class (REGNO (reg)))\n \t   && (type != OP_IN\n \t       || !in_hard_reg_set_p (reg_class_contents[regclass],\n@@ -4668,7 +4668,7 @@ lra_constraints (bool first_p)\n       {\n \tint j, nregs;\n \n-\tnregs = hard_regno_nregs[hard_regno][lra_reg_info[i].biggest_mode];\n+\tnregs = hard_regno_nregs (hard_regno, lra_reg_info[i].biggest_mode);\n \tfor (j = 0; j < nregs; j++)\n \t  df_set_regs_ever_live (hard_regno + j, true);\n       }\n@@ -4865,7 +4865,8 @@ lra_constraints (bool first_p)\n \tif (lra_reg_info[i].nrefs != 0\n \t    && (hard_regno = lra_get_regno_hard_regno (i)) >= 0)\n \t  {\n-\t    int j, nregs = hard_regno_nregs[hard_regno][PSEUDO_REGNO_MODE (i)];\n+\t    int j, nregs = hard_regno_nregs (hard_regno,\n+\t\t\t\t\t     PSEUDO_REGNO_MODE (i));\n \n \t    for (j = 0; j < nregs; j++)\n \t      lra_assert (df_regs_ever_live_p (hard_regno + j));\n@@ -5477,7 +5478,7 @@ split_reg (bool before_p, int original_regno, rtx_insn *insn,\n     {\n       mode = PSEUDO_REGNO_MODE (original_regno);\n       hard_regno = reg_renumber[original_regno];\n-      nregs = hard_regno_nregs[hard_regno][mode];\n+      nregs = hard_regno_nregs (hard_regno, mode);\n       rclass = lra_get_allocno_class (original_regno);\n       original_reg = regno_reg_rtx[original_regno];\n       call_save_p = need_for_call_save_p (original_regno);\n@@ -5490,7 +5491,7 @@ split_reg (bool before_p, int original_regno, rtx_insn *insn,\n   if (call_save_p)\n     {\n       mode = HARD_REGNO_CALLER_SAVE_MODE (hard_regno,\n-\t\t\t\t\t  hard_regno_nregs[hard_regno][mode],\n+\t\t\t\t\t  hard_regno_nregs (hard_regno, mode),\n \t\t\t\t\t  mode);\n       new_reg = lra_create_new_reg (mode, NULL_RTX, NO_REGS, \"save\");\n     }\n@@ -5639,7 +5640,7 @@ split_if_necessary (int regno, machine_mode mode,\n   rtx next_usage_insns;\n \n   if (regno < FIRST_PSEUDO_REGISTER)\n-    nregs = hard_regno_nregs[regno][mode];\n+    nregs = hard_regno_nregs (regno, mode);\n   for (i = 0; i < nregs; i++)\n     if (usage_insns[regno + i].check == curr_usage_insns_check\n \t&& (next_usage_insns = usage_insns[regno + i].insns) != NULL_RTX\n@@ -5685,7 +5686,7 @@ invariant_p (const_rtx x)\n \t  || TEST_HARD_REG_BIT (eliminable_regset, regno)\n \t  || GET_MODE_CLASS (GET_MODE (x)) == MODE_CC)\n \treturn false;\n-      nregs = hard_regno_nregs[regno][mode];\n+      nregs = hard_regno_nregs (regno, mode);\n       for (i = 0; i < nregs; i++)\n \tif (! fixed_regs[regno + i]\n \t    /* A hard register may be clobbered in the current insn\n@@ -6207,7 +6208,8 @@ inherit_in_ebb (rtx_insn *head, rtx_insn *tail)\n \t\t\tusage_insns[dst_regno].check = -(int) INSN_UID (curr_insn);\n \t\t      else\n \t\t\t{\n-\t\t\t  nregs = hard_regno_nregs[dst_regno][reg->biggest_mode];\n+\t\t\t  nregs = hard_regno_nregs (dst_regno,\n+\t\t\t\t\t\t    reg->biggest_mode);\n \t\t\t  for (i = 0; i < nregs; i++)\n \t\t\t    usage_insns[dst_regno + i].check\n \t\t\t      = -(int) INSN_UID (curr_insn);"}, {"sha": "4648eca5ace8af61875832324c997050125d4192", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=ad47462665eb1f923f3513cf52b42af22a76eb14", "patch": "@@ -726,7 +726,7 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \t\t but implicitly it can be used in natural mode as a\n \t\t part of multi-register group.  Process this case\n \t\t here.  */\n-\t      for (i = 1; i < hard_regno_nregs[regno][reg->biggest_mode]; i++)\n+\t      for (i = 1; i < hard_regno_nregs (regno, reg->biggest_mode); i++)\n \t\tif (partial_subreg_p (lra_reg_info[regno + i].biggest_mode,\n \t\t\t\t      GET_MODE (regno_reg_rtx[regno + i])))\n \t\t  lra_reg_info[regno + i].biggest_mode"}, {"sha": "768a6c976547455b196dd989f565c6c6a017e10e", "filename": "gcc/lra-remat.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Flra-remat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Flra-remat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-remat.c?ref=ad47462665eb1f923f3513cf52b42af22a76eb14", "patch": "@@ -667,7 +667,7 @@ reg_overlap_for_remat_p (lra_insn_reg *reg, rtx_insn *insn)\n   if (regno >= FIRST_PSEUDO_REGISTER)\n     nregs = 1;\n   else\n-    nregs = hard_regno_nregs[regno][reg->biggest_mode];\n+    nregs = hard_regno_nregs (regno, reg->biggest_mode);\n \n   struct lra_insn_reg *reg2;\n \n@@ -686,7 +686,7 @@ reg_overlap_for_remat_p (lra_insn_reg *reg, rtx_insn *insn)\n \tif (regno2 >= FIRST_PSEUDO_REGISTER)\n \t  nregs2 = 1;\n \telse\n-\t  nregs2 = hard_regno_nregs[regno2][reg->biggest_mode];\n+\t  nregs2 = hard_regno_nregs (regno2, reg->biggest_mode);\n \n \tif ((regno2 + nregs2 - 1 >= regno && regno2 < regno + nregs)\n \t    || (regno + nregs - 1 >= regno2 && regno < regno2 + nregs2))\n@@ -1011,7 +1011,7 @@ get_hard_regs (struct lra_insn_reg *reg, int &nregs)\n   int hard_regno = regno < FIRST_PSEUDO_REGISTER ? regno : reg_renumber[regno];\n \n   if (hard_regno >= 0)\n-    nregs = hard_regno_nregs[hard_regno][reg->biggest_mode];\n+    nregs = hard_regno_nregs (hard_regno, reg->biggest_mode);\n   return hard_regno;\n }\n \n@@ -1135,7 +1135,7 @@ do_remat (void)\n \t\t? dst_regno : reg_renumber[dst_regno];\n \t      gcc_assert (dst_hard_regno >= 0);\n \t      machine_mode mode = GET_MODE (SET_DEST (set));\n-\t      dst_nregs = hard_regno_nregs[dst_hard_regno][mode];\n+\t      dst_nregs = hard_regno_nregs (dst_hard_regno, mode);\n \n \t      for (reg = cand_id->regs; reg != NULL; reg = reg->next)\n \t\tif (reg->type != OP_IN && reg->regno != ignore_regno)"}, {"sha": "ab33dd4241229e34d1621e6510755fd756511866", "filename": "gcc/lra-spills.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Flra-spills.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Flra-spills.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-spills.c?ref=ad47462665eb1f923f3513cf52b42af22a76eb14", "patch": "@@ -294,7 +294,8 @@ assign_spill_hard_regs (int *pseudo_regnos, int n)\n       spill_hard_reg[regno]\n \t= gen_raw_REG (PSEUDO_REGNO_MODE (regno), hard_regno);\n       for (nr = 0;\n-\t   nr < hard_regno_nregs[hard_regno][lra_reg_info[regno].biggest_mode];\n+\t   nr < hard_regno_nregs (hard_regno,\n+\t\t\t\t  lra_reg_info[regno].biggest_mode);\n \t   nr++)\n \t/* Just loop.  */\n \tdf_set_regs_ever_live (hard_regno + nr, true);"}, {"sha": "c391c0b123876e69719e3c7de579d22f27d594b5", "filename": "gcc/mode-switching.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Fmode-switching.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Fmode-switching.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmode-switching.c?ref=ad47462665eb1f923f3513cf52b42af22a76eb14", "patch": "@@ -361,8 +361,8 @@ create_pre_exit (int n_entities, int *entity_map, const int *num_modes)\n \t\t    if (!targetm.calls.function_value_regno_p (copy_start))\n \t\t      copy_num = 0;\n \t\t    else\n-\t\t      copy_num\n-\t\t\t= hard_regno_nregs[copy_start][GET_MODE (copy_reg)];\n+\t\t      copy_num = hard_regno_nregs (copy_start,\n+\t\t\t\t\t\t   GET_MODE (copy_reg));\n \n \t\t    /* If the return register is not likely spilled, - as is\n \t\t       the case for floating point on SH4 - then it might"}, {"sha": "4660df2d6468a8a28c95f9d842d4aa4c9a308d2c", "filename": "gcc/postreload.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=ad47462665eb1f923f3513cf52b42af22a76eb14", "patch": "@@ -1136,7 +1136,7 @@ reload_combine_recognize_pattern (rtx_insn *insn)\n \t\t  && (call_used_regs[i] || df_regs_ever_live_p (i))\n \t\t  && (!frame_pointer_needed || i != HARD_FRAME_POINTER_REGNUM)\n \t\t  && !fixed_regs[i] && !global_regs[i]\n-\t\t  && hard_regno_nregs[i][GET_MODE (reg)] == 1\n+\t\t  && hard_regno_nregs (i, GET_MODE (reg)) == 1\n \t\t  && targetm.hard_regno_scratch_ok (i))\n \t\t{\n \t\t  index_reg = gen_rtx_REG (GET_MODE (reg), i);"}, {"sha": "78c26d617a960d6c6ebd79c8e0029c8c8b407414", "filename": "gcc/recog.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=ad47462665eb1f923f3513cf52b42af22a76eb14", "patch": "@@ -3163,7 +3163,7 @@ peep2_find_free_register (int from, int to, const char *class_str,\n \tcontinue;\n \n       success = 1;\n-      for (j = 0; success && j < hard_regno_nregs[regno][mode]; j++)\n+      for (j = 0; success && j < hard_regno_nregs (regno, mode); j++)\n \t{\n \t  /* Don't allocate fixed registers.  */\n \t  if (fixed_regs[regno + j])"}, {"sha": "6db7fdd72402074ce3be6bcb8d1fcb8507b406bd", "filename": "gcc/regcprop.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Fregcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Fregcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregcprop.c?ref=ad47462665eb1f923f3513cf52b42af22a76eb14", "patch": "@@ -176,7 +176,7 @@ kill_value_regno (unsigned int regno, unsigned int nregs,\n       unsigned int i, n;\n       if (vd->e[j].mode == VOIDmode)\n \tcontinue;\n-      n = hard_regno_nregs[j][vd->e[j].mode];\n+      n = hard_regno_nregs (j, vd->e[j].mode);\n       if (j + n > regno)\n \tfor (i = 0; i < n; ++i)\n \t  kill_value_one_regno (j + i, vd);\n@@ -209,7 +209,7 @@ set_value_regno (unsigned int regno, machine_mode mode,\n \n   vd->e[regno].mode = mode;\n \n-  nregs = hard_regno_nregs[regno][mode];\n+  nregs = hard_regno_nregs (regno, mode);\n   if (nregs > vd->max_value_regs)\n     vd->max_value_regs = nregs;\n }\n@@ -344,15 +344,15 @@ copy_value (rtx dest, rtx src, struct value_data *vd)\n \n      We can't properly represent the latter case in our tables, so don't\n      record anything then.  */\n-  else if (sn < (unsigned int) hard_regno_nregs[sr][vd->e[sr].mode]\n+  else if (sn < hard_regno_nregs (sr, vd->e[sr].mode)\n \t   && (GET_MODE_SIZE (vd->e[sr].mode) > UNITS_PER_WORD\n \t       ? WORDS_BIG_ENDIAN : BYTES_BIG_ENDIAN))\n     return;\n \n   /* If SRC had been assigned a mode narrower than the copy, we can't\n      link DEST into the chain, because not all of the pieces of the\n      copy came from oldest_regno.  */\n-  else if (sn > (unsigned int) hard_regno_nregs[sr][vd->e[sr].mode])\n+  else if (sn > hard_regno_nregs (sr, vd->e[sr].mode))\n     return;\n \n   /* Link DR at the end of the value chain used by SR.  */\n@@ -408,8 +408,8 @@ maybe_mode_change (machine_mode orig_mode, machine_mode copy_mode,\n     return gen_raw_REG (new_mode, regno);\n   else if (mode_change_ok (orig_mode, new_mode, regno))\n     {\n-      int copy_nregs = hard_regno_nregs[copy_regno][copy_mode];\n-      int use_nregs = hard_regno_nregs[copy_regno][new_mode];\n+      int copy_nregs = hard_regno_nregs (copy_regno, copy_mode);\n+      int use_nregs = hard_regno_nregs (copy_regno, new_mode);\n       int copy_offset\n \t= GET_MODE_SIZE (copy_mode) / copy_nregs * (copy_nregs - use_nregs);\n       int offset\n@@ -445,7 +445,7 @@ find_oldest_value_reg (enum reg_class cl, rtx reg, struct value_data *vd)\n \t(set (...) (reg:DI r9))\n      Replacing r9 with r11 is invalid.  */\n   if (mode != vd->e[regno].mode\n-      && REG_NREGS (reg) > hard_regno_nregs[regno][vd->e[regno].mode])\n+      && REG_NREGS (reg) > hard_regno_nregs (regno, vd->e[regno].mode))\n     return NULL_RTX;\n \n   for (i = vd->e[regno].oldest_regno; i != regno; i = vd->e[i].next_regno)\n@@ -869,12 +869,12 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n \t  if (mode != vd->e[regno].mode)\n \t    {\n \t      if (REG_NREGS (src)\n-\t\t  > hard_regno_nregs[regno][vd->e[regno].mode])\n+\t\t  > hard_regno_nregs (regno, vd->e[regno].mode))\n \t\tgoto no_move_special_case;\n \n \t      /* And likewise, if we are narrowing on big endian the transformation\n \t\t is also invalid.  */\n-\t      if (REG_NREGS (src) < hard_regno_nregs[regno][vd->e[regno].mode]\n+\t      if (REG_NREGS (src) < hard_regno_nregs (regno, vd->e[regno].mode)\n \t\t  && (GET_MODE_SIZE (vd->e[regno].mode) > UNITS_PER_WORD\n \t\t      ? WORDS_BIG_ENDIAN : BYTES_BIG_ENDIAN))\n \t\tgoto no_move_special_case;"}, {"sha": "36412ae9f529863b54911fe49c6fb6a826d8737d", "filename": "gcc/reginfo.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=ad47462665eb1f923f3513cf52b42af22a76eb14", "patch": "@@ -508,7 +508,8 @@ init_reg_modes_target (void)\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     for (j = 0; j < MAX_MACHINE_MODE; j++)\n-      hard_regno_nregs[i][j] = HARD_REGNO_NREGS (i, (machine_mode)j);\n+      this_target_regs->x_hard_regno_nregs[i][j]\n+\t= HARD_REGNO_NREGS (i, (machine_mode)j);\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     {\n@@ -518,7 +519,7 @@ init_reg_modes_target (void)\n \t if it is suitable, otherwise fall back on word_mode.  */\n       if (reg_raw_mode[i] == VOIDmode)\n     \t{\n-\t  if (i > 0 && hard_regno_nregs[i][reg_raw_mode[i - 1]] == 1)\n+\t  if (i > 0 && hard_regno_nregs (i, reg_raw_mode[i - 1]) == 1)\n \t    reg_raw_mode[i] = reg_raw_mode[i - 1];\n \t  else\n \t    reg_raw_mode[i] = word_mode;\n@@ -633,31 +634,31 @@ choose_hard_reg_mode (unsigned int regno ATTRIBUTE_UNUSED,\n      If we still didn't find a valid mode, try CCmode.  */\n \n   FOR_EACH_MODE_IN_CLASS (mode, MODE_INT)\n-    if ((unsigned) hard_regno_nregs[regno][mode] == nregs\n+    if (hard_regno_nregs (regno, mode) == nregs\n \t&& targetm.hard_regno_mode_ok (regno, mode)\n \t&& (!call_saved\n \t    || !targetm.hard_regno_call_part_clobbered (regno, mode))\n \t&& GET_MODE_SIZE (mode) > GET_MODE_SIZE (found_mode))\n       found_mode = mode;\n \n   FOR_EACH_MODE_IN_CLASS (mode, MODE_FLOAT)\n-    if ((unsigned) hard_regno_nregs[regno][mode] == nregs\n+    if (hard_regno_nregs (regno, mode) == nregs\n \t&& targetm.hard_regno_mode_ok (regno, mode)\n \t&& (!call_saved\n \t    || !targetm.hard_regno_call_part_clobbered (regno, mode))\n \t&& GET_MODE_SIZE (mode) > GET_MODE_SIZE (found_mode))\n       found_mode = mode;\n \n   FOR_EACH_MODE_IN_CLASS (mode, MODE_VECTOR_FLOAT)\n-    if ((unsigned) hard_regno_nregs[regno][mode] == nregs\n+    if (hard_regno_nregs (regno, mode) == nregs\n \t&& targetm.hard_regno_mode_ok (regno, mode)\n \t&& (!call_saved\n \t    || !targetm.hard_regno_call_part_clobbered (regno, mode))\n \t&& GET_MODE_SIZE (mode) > GET_MODE_SIZE (found_mode))\n       found_mode = mode;\n \n   FOR_EACH_MODE_IN_CLASS (mode, MODE_VECTOR_INT)\n-    if ((unsigned) hard_regno_nregs[regno][mode] == nregs\n+    if (hard_regno_nregs (regno, mode) == nregs\n \t&& targetm.hard_regno_mode_ok (regno, mode)\n \t&& (!call_saved\n \t    || !targetm.hard_regno_call_part_clobbered (regno, mode))\n@@ -671,7 +672,7 @@ choose_hard_reg_mode (unsigned int regno ATTRIBUTE_UNUSED,\n   for (m = (unsigned int) CCmode; m < (unsigned int) NUM_MACHINE_MODES; ++m)\n     {\n       mode = (machine_mode) m;\n-      if ((unsigned) hard_regno_nregs[regno][mode] == nregs\n+      if (hard_regno_nregs (regno, mode) == nregs\n \t  && targetm.hard_regno_mode_ok (regno, mode)\n \t  && (!call_saved\n \t      || !targetm.hard_regno_call_part_clobbered (regno, mode)))"}, {"sha": "7fbfa3162ca6dbdc4cf26f2486934642e3626d52", "filename": "gcc/regrename.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=ad47462665eb1f923f3513cf52b42af22a76eb14", "patch": "@@ -312,7 +312,7 @@ check_new_reg_p (int reg ATTRIBUTE_UNUSED, int new_reg,\n \t\t struct du_head *this_head, HARD_REG_SET this_unavailable)\n {\n   machine_mode mode = GET_MODE (*this_head->first->loc);\n-  int nregs = hard_regno_nregs[new_reg][mode];\n+  int nregs = hard_regno_nregs (new_reg, mode);\n   int i;\n   struct du_chain *tmp;\n \n@@ -990,7 +990,7 @@ regrename_do_replace (struct du_head *head, int reg)\n   mode = GET_MODE (*head->first->loc);\n   head->renamed = 1;\n   head->regno = reg;\n-  head->nregs = hard_regno_nregs[reg][mode];\n+  head->nregs = hard_regno_nregs (reg, mode);\n   return true;\n }\n "}, {"sha": "8225355e3f3658cd6fcedc946f24f4e454678807", "filename": "gcc/regs.h", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=ad47462665eb1f923f3513cf52b42af22a76eb14", "patch": "@@ -232,9 +232,6 @@ extern struct target_regs *this_target_regs;\n #else\n #define this_target_regs (&default_target_regs)\n #endif\n-\n-#define hard_regno_nregs \\\n-  (this_target_regs->x_hard_regno_nregs)\n #define reg_raw_mode \\\n   (this_target_regs->x_reg_raw_mode)\n #define have_regs_of_mode \\\n@@ -250,13 +247,21 @@ extern struct target_regs *this_target_regs;\n #define float_extend_from_mem \\\n   (this_target_regs->x_float_extend_from_mem)\n \n+/* Return the number of hard registers in (reg:MODE REGNO).  */\n+\n+ALWAYS_INLINE unsigned char\n+hard_regno_nregs (unsigned int regno, machine_mode mode)\n+{\n+  return this_target_regs->x_hard_regno_nregs[regno][mode];\n+}\n+\n /* Return an exclusive upper bound on the registers occupied by hard\n    register (reg:MODE REGNO).  */\n \n static inline unsigned int\n end_hard_regno (machine_mode mode, unsigned int regno)\n {\n-  return regno + hard_regno_nregs[regno][(int) mode];\n+  return regno + hard_regno_nregs (regno, mode);\n }\n \n /* Add to REGS all the registers required to store a value of mode MODE"}, {"sha": "a5dd47ccab672670b54293eb22a9150261f8e80c", "filename": "gcc/reload.c", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=ad47462665eb1f923f3513cf52b42af22a76eb14", "patch": "@@ -1625,8 +1625,8 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t    && targetm.hard_regno_mode_ok (regno, outmode))\n \t  {\n \t    unsigned int offs;\n-\t    unsigned int nregs = MAX (hard_regno_nregs[regno][inmode],\n-\t\t\t\t      hard_regno_nregs[regno][outmode]);\n+\t    unsigned int nregs = MAX (hard_regno_nregs (regno, inmode),\n+\t\t\t\t      hard_regno_nregs (regno, outmode));\n \n \t    for (offs = 0; offs < nregs; offs++)\n \t      if (fixed_regs[regno + offs]\n@@ -1905,7 +1905,7 @@ combine_reloads (void)\n \t&& targetm.hard_regno_mode_ok (regno, rld[output_reload].outmode)\n \t&& TEST_HARD_REG_BIT (reg_class_contents[(int) rld[output_reload].rclass],\n \t\t\t      regno)\n-\t&& (hard_regno_nregs[regno][rld[output_reload].outmode]\n+\t&& (hard_regno_nregs (regno, rld[output_reload].outmode)\n \t    <= REG_NREGS (XEXP (note, 0)))\n \t/* Ensure that a secondary or tertiary reload for this output\n \t   won't want this register.  */\n@@ -2005,7 +2005,7 @@ find_dummy_reload (rtx real_in, rtx real_out, rtx *inloc, rtx *outloc,\n       && REGNO (out) < FIRST_PSEUDO_REGISTER)\n     {\n       unsigned int regno = REGNO (out) + out_offset;\n-      unsigned int nwords = hard_regno_nregs[regno][outmode];\n+      unsigned int nwords = hard_regno_nregs (regno, outmode);\n       rtx saved_rtx;\n \n       /* When we consider whether the insn uses OUT,\n@@ -2090,7 +2090,7 @@ find_dummy_reload (rtx real_in, rtx real_out, rtx *inloc, rtx *outloc,\n \t      && REG_NREGS (in) == 1)))\n     {\n       unsigned int regno = REGNO (in) + in_offset;\n-      unsigned int nwords = hard_regno_nregs[regno][inmode];\n+      unsigned int nwords = hard_regno_nregs (regno, inmode);\n \n       if (! refers_to_regno_for_reload_p (regno, regno + nwords, out, (rtx*) 0)\n \t  && ! hard_reg_set_here_p (regno, regno + nwords,\n@@ -2264,13 +2264,13 @@ operands_match_p (rtx x, rtx y)\n \t  && is_a <scalar_int_mode> (GET_MODE (x), &xmode)\n \t  && GET_MODE_SIZE (xmode) > UNITS_PER_WORD\n \t  && i < FIRST_PSEUDO_REGISTER)\n-\ti += hard_regno_nregs[i][xmode] - 1;\n+\ti += hard_regno_nregs (i, xmode) - 1;\n       scalar_int_mode ymode;\n       if (REG_WORDS_BIG_ENDIAN\n \t  && is_a <scalar_int_mode> (GET_MODE (y), &ymode)\n \t  && GET_MODE_SIZE (ymode) > UNITS_PER_WORD\n \t  && j < FIRST_PSEUDO_REGISTER)\n-\tj += hard_regno_nregs[j][ymode] - 1;\n+\tj += hard_regno_nregs (j, ymode) - 1;\n \n       return i == j;\n     }\n@@ -4576,7 +4576,7 @@ find_reloads (rtx_insn *insn, int replace, int ind_levels, int live_known,\n \t    && TEST_HARD_REG_BIT (reg_class_contents[rld[i].rclass], regno)\n \t    && targetm.hard_regno_mode_ok (regno, rld[i].mode))\n \t  {\n-\t    int nr = hard_regno_nregs[regno][rld[i].mode];\n+\t    int nr = hard_regno_nregs (regno, rld[i].mode);\n \t    int ok = 1, nri;\n \n \t    for (nri = 1; nri < nr; nri ++)\n@@ -6856,10 +6856,10 @@ find_equiv_reg (rtx goal, rtx_insn *insn, enum reg_class rclass, int other,\n   /* Reject registers that overlap GOAL.  */\n \n   if (regno >= 0 && regno < FIRST_PSEUDO_REGISTER)\n-    nregs = hard_regno_nregs[regno][mode];\n+    nregs = hard_regno_nregs (regno, mode);\n   else\n     nregs = 1;\n-  valuenregs = hard_regno_nregs[valueno][mode];\n+  valuenregs = hard_regno_nregs (valueno, mode);\n \n   if (!goal_mem && !goal_const\n       && regno + nregs > valueno && regno < valueno + valuenregs)\n@@ -7234,7 +7234,8 @@ reload_adjust_reg_for_mode (rtx reloadreg, machine_mode mode)\n   regno = REGNO (reloadreg);\n \n   if (REG_WORDS_BIG_ENDIAN)\n-    regno += (int) REG_NREGS (reloadreg) - (int) hard_regno_nregs[regno][mode];\n+    regno += ((int) REG_NREGS (reloadreg)\n+\t      - (int) hard_regno_nregs (regno, mode));\n \n   return gen_rtx_REG (mode, regno);\n }"}, {"sha": "e59f6d900da69146ea59407b3cb122ccd7a732d6", "filename": "gcc/reload1.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=ad47462665eb1f923f3513cf52b42af22a76eb14", "patch": "@@ -1711,7 +1711,7 @@ count_pseudo (int reg)\n   gcc_assert (r >= 0);\n \n   spill_add_cost[r] += freq;\n-  nregs = hard_regno_nregs[r][PSEUDO_REGNO_MODE (reg)];\n+  nregs = hard_regno_nregs (r, PSEUDO_REGNO_MODE (reg));\n   while (nregs-- > 0)\n     {\n       hard_regno_to_pseudo_regno[r + nregs] = reg;\n@@ -1788,7 +1788,7 @@ count_spilled_pseudo (int spilled, int spilled_nregs, int reg)\n \n   gcc_assert (r >= 0);\n \n-  nregs = hard_regno_nregs[r][PSEUDO_REGNO_MODE (reg)];\n+  nregs = hard_regno_nregs (r, PSEUDO_REGNO_MODE (reg));\n \n   if (REGNO_REG_SET_P (&spilled_pseudos, reg)\n       || spilled + spilled_nregs <= r || r + nregs <= spilled)\n@@ -1849,7 +1849,7 @@ find_reg (struct insn_chain *chain, int order)\n \t{\n \t  int this_cost = spill_cost[regno];\n \t  int ok = 1;\n-\t  unsigned int this_nregs = hard_regno_nregs[regno][rl->mode];\n+\t  unsigned int this_nregs = hard_regno_nregs (regno, rl->mode);\n \n \t  for (j = 1; j < this_nregs; j++)\n \t    {\n@@ -1920,7 +1920,7 @@ find_reg (struct insn_chain *chain, int order)\n   if (dump_file)\n     fprintf (dump_file, \"Using reg %d for reload %d\\n\", best_reg, rnum);\n \n-  rl->nregs = hard_regno_nregs[best_reg][rl->mode];\n+  rl->nregs = hard_regno_nregs (best_reg, rl->mode);\n   rl->regno = best_reg;\n \n   EXECUTE_IF_SET_IN_REG_SET\n@@ -5068,7 +5068,7 @@ static void\n clear_reload_reg_in_use (unsigned int regno, int opnum,\n \t\t\t enum reload_type type, machine_mode mode)\n {\n-  unsigned int nregs = hard_regno_nregs[regno][mode];\n+  unsigned int nregs = hard_regno_nregs (regno, mode);\n   unsigned int start_regno, end_regno, r;\n   int i;\n   /* A complication is that for some reload types, inheritance might\n@@ -6026,7 +6026,7 @@ free_for_value_p (int regno, machine_mode mode, int opnum,\n \t\t  enum reload_type type, rtx value, rtx out, int reloadnum,\n \t\t  int ignore_address_reloads)\n {\n-  int nregs = hard_regno_nregs[regno][mode];\n+  int nregs = hard_regno_nregs (regno, mode);\n   while (nregs-- > 0)\n     if (! reload_reg_free_for_value_p (regno, regno + nregs, opnum, type,\n \t\t\t\t       value, out, reloadnum,\n@@ -6222,7 +6222,7 @@ allocate_reload_reg (struct insn_chain *chain ATTRIBUTE_UNUSED, int r,\n \t\t      && ! TEST_HARD_REG_BIT (reload_reg_used_for_inherit,\n \t\t\t\t\t      regnum))))\n \t    {\n-\t      int nr = hard_regno_nregs[regnum][rld[r].mode];\n+\t      int nr = hard_regno_nregs (regnum, rld[r].mode);\n \n \t      /* During the second pass we want to avoid reload registers\n \t\t which are \"bad\" for this reload.  */\n@@ -6608,7 +6608,7 @@ choose_reload_regs (struct insn_chain *chain)\n \t\t    {\n \t\t      /* If a group is needed, verify that all the subsequent\n \t\t\t registers still have their values intact.  */\n-\t\t      int nr = hard_regno_nregs[i][rld[r].mode];\n+\t\t      int nr = hard_regno_nregs (i, rld[r].mode);\n \t\t      int k;\n \n \t\t      for (k = 1; k < nr; k++)\n@@ -6838,7 +6838,7 @@ choose_reload_regs (struct insn_chain *chain)\n \t\t  && (regno != HARD_FRAME_POINTER_REGNUM\n \t\t      || !frame_pointer_needed))\n \t\t{\n-\t\t  int nr = hard_regno_nregs[regno][rld[r].mode];\n+\t\t  int nr = hard_regno_nregs (regno, rld[r].mode);\n \t\t  int k;\n \t\t  rld[r].reg_rtx = equiv;\n \t\t  reload_spill_index[r] = regno;\n@@ -7075,7 +7075,7 @@ choose_reload_regs (struct insn_chain *chain)\n \t  int nr = 1;\n \n \t  if (nregno < FIRST_PSEUDO_REGISTER)\n-\t    nr = hard_regno_nregs[nregno][rld[r].mode];\n+\t    nr = hard_regno_nregs (nregno, rld[r].mode);\n \n \t  while (--nr >= 0)\n \t    SET_REGNO_REG_SET (&reg_has_output_reload,\n@@ -7150,7 +7150,7 @@ reload_adjust_reg_for_temp (rtx *reload_reg, rtx alt_reload_reg,\n \t{\n \t  if (!targetm.hard_regno_mode_ok (regno, new_mode))\n \t    continue;\n-\t  if (hard_regno_nregs[regno][new_mode] > REG_NREGS (reg))\n+\t  if (hard_regno_nregs (regno, new_mode) > REG_NREGS (reg))\n \t    continue;\n \t  reg = reload_adjust_reg_for_mode (reg, new_mode);\n \t}\n@@ -8194,7 +8194,7 @@ emit_reload_insns (struct insn_chain *chain)\n \n       if (i >= 0 && rld[r].reg_rtx != 0)\n \t{\n-\t  int nr = hard_regno_nregs[i][GET_MODE (rld[r].reg_rtx)];\n+\t  int nr = hard_regno_nregs (i, GET_MODE (rld[r].reg_rtx));\n \t  int k;\n \n \t  /* For a multi register reload, we need to check if all or part\n@@ -8238,7 +8238,7 @@ emit_reload_insns (struct insn_chain *chain)\n /* AUTO_INC */\t\t     : XEXP (rld[r].in_reg, 0));\n \t\t  int out_regno = REGNO (out);\n \t\t  int out_nregs = (!HARD_REGISTER_NUM_P (out_regno) ? 1\n-\t\t\t\t   : hard_regno_nregs[out_regno][mode]);\n+\t\t\t\t   : hard_regno_nregs (out_regno, mode));\n \t\t  bool piecemeal;\n \n \t\t  spill_reg_store[regno] = new_spill_reg_store[regno];\n@@ -8320,7 +8320,7 @@ emit_reload_insns (struct insn_chain *chain)\n \t\t  in_regno = REGNO (in);\n \n \t\t  in_nregs = (!HARD_REGISTER_NUM_P (in_regno) ? 1\n-\t\t\t      : hard_regno_nregs[in_regno][mode]);\n+\t\t\t      : hard_regno_nregs (in_regno, mode));\n \n \t\t  reg_last_reload_reg[in_regno] = reg;\n \n@@ -8449,7 +8449,7 @@ emit_reload_insns (struct insn_chain *chain)\n \n \t\t  gcc_assert (GET_MODE (src_reg) == mode);\n \t\t  src_regno = REGNO (src_reg);\n-\t\t  src_nregs = hard_regno_nregs[src_regno][mode];\n+\t\t  src_nregs = hard_regno_nregs (src_regno, mode);\n \t\t  /* The place where to find a death note varies with\n \t\t     PRESERVE_DEATH_INFO_REGNO_P .  The condition is not\n \t\t     necessarily checked exactly in the code that moves\n@@ -8488,7 +8488,7 @@ emit_reload_insns (struct insn_chain *chain)\n \t    }\n \t  else\n \t    {\n-\t      int k, out_nregs = hard_regno_nregs[out_regno][mode];\n+\t      int k, out_nregs = hard_regno_nregs (out_regno, mode);\n \n \t      for (k = 0; k < out_nregs; k++)\n \t\treg_last_reload_reg[out_regno + k] = 0;\n@@ -8860,7 +8860,7 @@ delete_output_reload (rtx_insn *insn, int j, int last_reload_reg,\n     }\n \n   /* We will be deleting the insn.  Remove the spill reg information.  */\n-  for (k = hard_regno_nregs[last_reload_reg][GET_MODE (reg)]; k-- > 0; )\n+  for (k = hard_regno_nregs (last_reload_reg, GET_MODE (reg)); k-- > 0; )\n     {\n       spill_reg_store[last_reload_reg + k] = 0;\n       spill_reg_stored_to[last_reload_reg + k] = 0;"}, {"sha": "af149bf8dcabee327dd986eadaef2e76bdc50840", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=ad47462665eb1f923f3513cf52b42af22a76eb14", "patch": "@@ -3667,8 +3667,8 @@ subreg_get_info (unsigned int xregno, machine_mode xmode,\n       gcc_assert (nregs_xmode\n \t\t  == (nunits\n \t\t      * HARD_REGNO_NREGS_WITH_PADDING (xregno, xmode_unit)));\n-      gcc_assert (hard_regno_nregs[xregno][xmode]\n-\t\t  == hard_regno_nregs[xregno][xmode_unit] * nunits);\n+      gcc_assert (hard_regno_nregs (xregno, xmode)\n+\t\t  == hard_regno_nregs (xregno, xmode_unit) * nunits);\n \n       /* You can only ask for a SUBREG of a value with holes in the middle\n \t if you don't cross the holes.  (Such a SUBREG should be done by\n@@ -3687,9 +3687,9 @@ subreg_get_info (unsigned int xregno, machine_mode xmode,\n \t}\n     }\n   else\n-    nregs_xmode = hard_regno_nregs[xregno][xmode];\n+    nregs_xmode = hard_regno_nregs (xregno, xmode);\n \n-  nregs_ymode = hard_regno_nregs[xregno][ymode];\n+  nregs_ymode = hard_regno_nregs (xregno, ymode);\n \n   /* Paradoxical subregs are otherwise valid.  */\n   if (!rknown && offset == 0 && ysize > xsize)"}, {"sha": "e7c4b879f55276b2f2f2c28eab30734fc33b5be4", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=ad47462665eb1f923f3513cf52b42af22a76eb14", "patch": "@@ -2308,7 +2308,7 @@ sched_analyze_reg (struct deps_desc *deps, int regno, machine_mode mode,\n      If so, mark all of them just like the first.  */\n   if (regno < FIRST_PSEUDO_REGISTER)\n     {\n-      int i = hard_regno_nregs[regno][mode];\n+      int i = hard_regno_nregs (regno, mode);\n       if (ref == SET)\n \t{\n \t  while (--i >= 0)"}, {"sha": "87a483a231e8f6b4a719aa3e958e867f78258dd4", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=ad47462665eb1f923f3513cf52b42af22a76eb14", "patch": "@@ -1079,7 +1079,7 @@ init_regs_for_mode (machine_mode mode)\n       if (!targetm.hard_regno_mode_ok (cur_reg, mode))\n         continue;\n \n-      nregs = hard_regno_nregs[cur_reg][mode];\n+      nregs = hard_regno_nregs (cur_reg, mode);\n \n       for (i = nregs - 1; i >= 0; --i)\n         if (fixed_regs[cur_reg + i]\n@@ -1262,7 +1262,7 @@ mark_unavailable_hard_regs (def_t def, struct reg_rename *reg_rename_p,\n       int nregs;\n       int i;\n \n-      nregs = hard_regno_nregs[cur_reg][mode];\n+      nregs = hard_regno_nregs (cur_reg, mode);\n       gcc_assert (nregs > 0);\n \n       for (i = nregs - 1; i >= 0; --i)\n@@ -1372,7 +1372,7 @@ choose_best_reg_1 (HARD_REG_SET hard_regs_used,\n     if (! TEST_HARD_REG_BIT (hard_regs_used, cur_reg))\n       {\n \t/* Check that all hard regs for mode are available.  */\n-\tfor (i = 1, n = hard_regno_nregs[cur_reg][mode]; i < n; i++)\n+\tfor (i = 1, n = hard_regno_nregs (cur_reg, mode); i < n; i++)\n \t  if (TEST_HARD_REG_BIT (hard_regs_used, cur_reg + i)\n \t      || !TEST_HARD_REG_BIT (reg_rename_p->available_for_renaming,\n \t\t\t\t     cur_reg + i))\n@@ -1535,7 +1535,7 @@ verify_target_availability (expr_t expr, regset used_regs,\n   regno = expr_dest_regno (expr);\n   mode = GET_MODE (EXPR_LHS (expr));\n   target_available = EXPR_TARGET_AVAILABLE (expr) == 1;\n-  n = HARD_REGISTER_NUM_P (regno) ? hard_regno_nregs[regno][mode] : 1;\n+  n = HARD_REGISTER_NUM_P (regno) ? hard_regno_nregs (regno, mode) : 1;\n \n   live_available = hard_available = true;\n   for (i = 0; i < n; i++)"}, {"sha": "38af3f0ce51d8a4a3d12dc5320eb281469866768", "filename": "gcc/valtrack.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Fvaltrack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Fvaltrack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvaltrack.c?ref=ad47462665eb1f923f3513cf52b42af22a76eb14", "patch": "@@ -701,7 +701,7 @@ dead_debug_insert_temp (struct dead_debug_local *debug, unsigned int uregno,\n \t     the debug temp to.  */\n \t  else if (REGNO (reg) < FIRST_PSEUDO_REGISTER\n \t\t   && (REG_NREGS (reg)\n-\t\t       != hard_regno_nregs[REGNO (reg)][GET_MODE (dest)]))\n+\t\t       != hard_regno_nregs (REGNO (reg), GET_MODE (dest))))\n \t    breg = NULL;\n \t  /* Yay, we can use SRC, just adjust its mode.  */\n \t  else"}, {"sha": "51e519a743f0a5803bbc8cfc2d03a1d69d9d61c1", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=ad47462665eb1f923f3513cf52b42af22a76eb14", "patch": "@@ -5312,7 +5312,7 @@ track_loc_p (rtx loc, tree expr, HOST_WIDE_INT offset, bool store_reg_p,\n   if ((paradoxical_subreg_p (mode, DECL_MODE (expr))\n        || (store_reg_p\n \t   && !COMPLEX_MODE_P (DECL_MODE (expr))\n-\t   && hard_regno_nregs[REGNO (loc)][DECL_MODE (expr)] == 1))\n+\t   && hard_regno_nregs (REGNO (loc), DECL_MODE (expr)) == 1))\n       && offset + byte_lowpart_offset (DECL_MODE (expr), mode) == 0)\n     {\n       mode = DECL_MODE (expr);\n@@ -8722,8 +8722,8 @@ emit_note_insn_var_location (variable **varp, emit_note_data *data)\n \t  rtx new_loc = NULL;\n \n \t  if (REG_P (loc[n_var_parts])\n-\t      && hard_regno_nregs[REGNO (loc[n_var_parts])][mode] * 2\n-\t\t == hard_regno_nregs[REGNO (loc[n_var_parts])][wider_mode]\n+\t      && hard_regno_nregs (REGNO (loc[n_var_parts]), mode) * 2\n+\t\t == hard_regno_nregs (REGNO (loc[n_var_parts]), wider_mode)\n \t      && end_hard_regno (mode, REGNO (loc[n_var_parts]))\n \t\t == REGNO (loc2))\n \t    {"}, {"sha": "1c66c26ce5cf35acd3a07caa1b05b8b952227d21", "filename": "gcc/varasm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad47462665eb1f923f3513cf52b42af22a76eb14/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=ad47462665eb1f923f3513cf52b42af22a76eb14", "patch": "@@ -1432,7 +1432,7 @@ make_decl_rtl (tree decl)\n \t      name = IDENTIFIER_POINTER (DECL_NAME (decl));\n \t      ASM_DECLARE_REGISTER_GLOBAL (asm_out_file, decl, reg_number, name);\n #endif\n-\t      nregs = hard_regno_nregs[reg_number][mode];\n+\t      nregs = hard_regno_nregs (reg_number, mode);\n \t      while (nregs > 0)\n \t\tglobalize_reg (decl, reg_number + --nregs);\n \t    }"}]}