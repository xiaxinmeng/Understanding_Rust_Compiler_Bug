{"sha": "9e7fc6b946e8a9f616ce12a458017bad8357247e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWU3ZmM2Yjk0NmU4YTlmNjE2Y2UxMmE0NTgwMTdiYWQ4MzU3MjQ3ZQ==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2006-10-18T23:13:33Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2006-10-18T23:13:33Z"}, "message": "re PR fortran/29277 (Formated stream output: Translate \"\\n\" / achar(10) into \"\\r\\n\" on some platforms)\n\n2006-10-18  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR libgfortran/29277\n\t* io/write.c (write_a): Add conversion of LF to CR-LF for systems with\n\t#define HAVE_CRLF.\n\nFrom-SVN: r117866", "tree": {"sha": "bbdfab311ddfa41a621df118efe7d19a03ba516a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bbdfab311ddfa41a621df118efe7d19a03ba516a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e7fc6b946e8a9f616ce12a458017bad8357247e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e7fc6b946e8a9f616ce12a458017bad8357247e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e7fc6b946e8a9f616ce12a458017bad8357247e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e7fc6b946e8a9f616ce12a458017bad8357247e/comments", "author": null, "committer": null, "parents": [{"sha": "1368453c6a59c0441fcf9fef79d1821a74a71565", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1368453c6a59c0441fcf9fef79d1821a74a71565", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1368453c6a59c0441fcf9fef79d1821a74a71565"}], "stats": {"total": 83, "additions": 75, "deletions": 8}, "files": [{"sha": "9001e2c979ea31e09fd0449c49f9dfcc54b2d9a8", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e7fc6b946e8a9f616ce12a458017bad8357247e/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e7fc6b946e8a9f616ce12a458017bad8357247e/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=9e7fc6b946e8a9f616ce12a458017bad8357247e", "patch": "@@ -1,4 +1,10 @@\n-2006-10-16  Tobias Burnus  <burnus@net-b.de>\n+2006-10-18  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR libgfortran/29277\n+\t* io/write.c (write_a): Add conversion of LF to CR-LF for systems with\n+\t#define HAVE_CRLF.\n+\n+2006-10-18  Tobias Burnus  <burnus@net-b.de>\n \n \t* m4/in_pack.m4: Fixed a typo.\n \t* m4/iforeach.m4: Fixed a typo."}, {"sha": "9ff48049dac1fad27210f0b69e144fa13c1c2018", "filename": "libgfortran/io/write.c", "status": "modified", "additions": 68, "deletions": 7, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e7fc6b946e8a9f616ce12a458017bad8357247e/libgfortran%2Fio%2Fwrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e7fc6b946e8a9f616ce12a458017bad8357247e/libgfortran%2Fio%2Fwrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite.c?ref=9e7fc6b946e8a9f616ce12a458017bad8357247e", "patch": "@@ -54,17 +54,78 @@ write_a (st_parameter_dt *dtp, const fnode *f, const char *source, int len)\n \n   wlen = f->u.string.length < 0 ? len : f->u.string.length;\n \n-  p = write_block (dtp, wlen);\n-  if (p == NULL)\n-    return;\n+#ifdef HAVE_CRLF\n+  /* If this is formatted STREAM IO convert any embedded line feed characters\n+     to CR_LF on systems that use that sequence for newlines.  See F2003\n+     Standard sections 10.6.3 and 9.9 for further information.  */\n+  if (is_stream_io (dtp))\n+    {\n+      const char crlf[] = \"\\r\\n\";\n+      int i, q, bytes;\n+      q = bytes = 0;\n+\n+      /* Write out any padding if needed.  */\n+      if (len < wlen)\n+\t{\n+\t  p = write_block (dtp, wlen - len);\n+\t  if (p == NULL)\n+\t    return;\n+\t  memset (p, ' ', wlen - len);\n+\t}\n \n-  if (wlen < len)\n-    memcpy (p, source, wlen);\n+      /* Scan the source string looking for '\\n' and convert it if found.  */\n+      for (i = 0; i < wlen; i++)\n+\t{\n+\t  if (source[i] == '\\n')\n+\t    {\n+\t      /* Write out the previously scanned characters in the string.  */\n+\t      if (bytes > 0)\n+\t\t{\n+\t\t  p = write_block (dtp, bytes);\n+\t\t  if (p == NULL)\n+\t\t    return;\n+\t\t  memcpy (p, &source[q], bytes);\n+\t\t  q += bytes;\n+\t\t  bytes = 0;\n+\t\t}\n+\n+\t      /* Write out the CR_LF sequence.  */ \n+\t      q++;\n+\t      p = write_block (dtp, 2);\n+              if (p == NULL)\n+                return;\n+\t      memcpy (p, crlf, 2);\n+\t    }\n+\t  else\n+\t    bytes++;\n+\t}\n+\n+      /*  Write out any remaining bytes if no LF was found.  */\n+      if (bytes > 0)\n+\t{\n+\t  p = write_block (dtp, bytes);\n+\t  if (p == NULL)\n+\t    return;\n+\t  memcpy (p, &source[q], bytes);\n+\t}\n+    }\n   else\n     {\n-      memset (p, ' ', wlen - len);\n-      memcpy (p + wlen - len, source, len);\n+#endif\n+      p = write_block (dtp, wlen);\n+      if (p == NULL)\n+\treturn;\n+\n+      if (wlen < len)\n+\tmemcpy (p, source, wlen);\n+      else\n+\t{\n+\t  memset (p, ' ', wlen - len);\n+\t  memcpy (p + wlen - len, source, len);\n+\t}\n+#ifdef HAVE_CRLF\n     }\n+#endif\n }\n \n static GFC_INTEGER_LARGEST"}]}