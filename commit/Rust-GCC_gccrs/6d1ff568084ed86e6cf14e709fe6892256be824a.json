{"sha": "6d1ff568084ed86e6cf14e709fe6892256be824a", "node_id": "C_kwDOANBUbNoAKDZkMWZmNTY4MDg0ZWQ4NmU2Y2YxNGU3MDlmZTY4OTIyNTZiZTgyNGE", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-02-08T17:56:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-08T17:56:41Z"}, "message": "Merge #912\n\n912: Handle generic substitution on path expressions r=philberty a=philberty\n\nIn this bug the path expression failed to take Foo::<i32> and apply this\r\nbound generic argument into the impl block. The fn type for this function\r\ntest is:\r\n\r\nfn <T,Y>test(a:T, b:Y);\r\n\r\nBut the impl block has a Self of Foo<T> so we need to inherit the T\r\nargument from the previous Foo::<i32> which was missing.\r\n\r\nFixes #893\r\n\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "75dee6b1d9b1328ab2f88f8804cf1aa29d99b291", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/75dee6b1d9b1328ab2f88f8804cf1aa29d99b291"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d1ff568084ed86e6cf14e709fe6892256be824a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiAq7aCRBK7hj4Ov3rIwAAzpMIAB3I+MYC8JQQco0rjITLOeEw\nDwcpln3auKg49ZkwEf4ESEwKnTD4LOD5zKXvLtt46LBmAxKOJAhooPprt1FzS1DH\n/8d8FMXJi/l/nwcwjS7xbZQ1+duEpKx9ng0z3f7rDJudJzd6wy4ntim6UGG/xdU1\nYrDwj/PTPn7qabqbewVA/qp22MIp64cNMZtBkzTR8OQQzU4EYb0KwLPv6bio7CrG\nCN5Q3cqW8Aj+dAC0LpFaD72bwZJX9tn0EukOe8sPC9yUjTF5hI+8c2g+PQCm0qVU\n5nX3zdj1zAheCb1aTnqbM+5TuoSFtgNJ0pESjzgimcHTjrunIUOcoZ+5nfjMjuw=\n=w1uW\n-----END PGP SIGNATURE-----\n", "payload": "tree 75dee6b1d9b1328ab2f88f8804cf1aa29d99b291\nparent 055ca34daa803f5353ced57d2d30041b93701c8c\nparent 257bf55827474e500d83d96b7a8f8ebacbd11e7d\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1644343001 +0000\ncommitter GitHub <noreply@github.com> 1644343001 +0000\n\nMerge #912\n\n912: Handle generic substitution on path expressions r=philberty a=philberty\n\nIn this bug the path expression failed to take Foo::<i32> and apply this\r\nbound generic argument into the impl block. The fn type for this function\r\ntest is:\r\n\r\nfn <T,Y>test(a:T, b:Y);\r\n\r\nBut the impl block has a Self of Foo<T> so we need to inherit the T\r\nargument from the previous Foo::<i32> which was missing.\r\n\r\nFixes #893\r\n\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d1ff568084ed86e6cf14e709fe6892256be824a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d1ff568084ed86e6cf14e709fe6892256be824a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d1ff568084ed86e6cf14e709fe6892256be824a/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "055ca34daa803f5353ced57d2d30041b93701c8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/055ca34daa803f5353ced57d2d30041b93701c8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/055ca34daa803f5353ced57d2d30041b93701c8c"}, {"sha": "257bf55827474e500d83d96b7a8f8ebacbd11e7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/257bf55827474e500d83d96b7a8f8ebacbd11e7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/257bf55827474e500d83d96b7a8f8ebacbd11e7d"}], "stats": {"total": 242, "additions": 219, "deletions": 23}, "files": [{"sha": "cd6d67a56ff4f1584f82b1dc5089f3506d216641", "filename": "gcc/rust/typecheck/rust-hir-type-check-path.cc", "status": "modified", "additions": 62, "deletions": 23, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d1ff568084ed86e6cf14e709fe6892256be824a/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d1ff568084ed86e6cf14e709fe6892256be824a/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc?ref=6d1ff568084ed86e6cf14e709fe6892256be824a", "patch": "@@ -133,11 +133,6 @@ TypeCheckExpr::visit (HIR::PathInExpression &expr)\n \n   size_t offset = -1;\n   TyTy::BaseType *tyseg = resolve_root_path (expr, &offset, &resolved_node_id);\n-\n-  if (tyseg == nullptr)\n-    {\n-      rust_debug_loc (expr.get_locus (), \"failed to resolve root_seg\");\n-    }\n   rust_assert (tyseg != nullptr);\n \n   if (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n@@ -318,12 +313,12 @@ TypeCheckExpr::resolve_segments (NodeId root_resolved_node_id,\n {\n   NodeId resolved_node_id = root_resolved_node_id;\n   TyTy::BaseType *prev_segment = tyseg;\n+  bool reciever_is_generic = prev_segment->get_kind () == TyTy::TypeKind::PARAM;\n+\n   for (size_t i = offset; i < segments.size (); i++)\n     {\n       HIR::PathExprSegment &seg = segments.at (i);\n \n-      bool reciever_is_generic\n-\t= prev_segment->get_kind () == TyTy::TypeKind::PARAM;\n       bool probe_bounds = true;\n       bool probe_impls = !reciever_is_generic;\n       bool ignore_mandatory_trait_items = !reciever_is_generic;\n@@ -359,6 +354,7 @@ TypeCheckExpr::resolve_segments (NodeId root_resolved_node_id,\n       prev_segment = tyseg;\n       tyseg = candidate.ty;\n \n+      HIR::ImplBlock *associated_impl_block = nullptr;\n       if (candidate.is_enum_candidate ())\n \t{\n \t  const TyTy::VariantDef *variant = candidate.item.enum_field.variant;\n@@ -380,6 +376,8 @@ TypeCheckExpr::resolve_segments (NodeId root_resolved_node_id,\n \t{\n \t  resolved_node_id\n \t    = candidate.item.impl.impl_item->get_impl_mappings ().get_nodeid ();\n+\n+\t  associated_impl_block = candidate.item.impl.parent;\n \t}\n       else\n \t{\n@@ -403,6 +401,52 @@ TypeCheckExpr::resolve_segments (NodeId root_resolved_node_id,\n \t      // we need a new ty_ref_id for this trait item\n \t      tyseg = tyseg->clone ();\n \t      tyseg->set_ty_ref (mappings->get_next_hir_id ());\n+\n+\t      // get the associated impl block\n+\t      associated_impl_block = impl;\n+\t    }\n+\t}\n+\n+      if (associated_impl_block != nullptr)\n+\t{\n+\t  // get the type of the parent Self\n+\t  HirId impl_ty_id\n+\t    = associated_impl_block->get_type ()->get_mappings ().get_hirid ();\n+\t  TyTy::BaseType *impl_block_ty = nullptr;\n+\t  bool ok = context->lookup_type (impl_ty_id, &impl_block_ty);\n+\t  rust_assert (ok);\n+\n+\t  if (prev_segment->needs_generic_substitutions ())\n+\t    {\n+\t      if (!impl_block_ty->needs_generic_substitutions ())\n+\t\t{\n+\t\t  prev_segment = impl_block_ty;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  HIR::PathExprSegment &pseg = segments.at (i - 1);\n+\t\t  Location locus = pseg.get_locus ();\n+\t\t  prev_segment = SubstMapper::InferSubst (prev_segment, locus);\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (tyseg->needs_generic_substitutions ())\n+\t{\n+\t  if (!prev_segment->needs_generic_substitutions ())\n+\t    {\n+\t      auto used_args_in_prev_segment\n+\t\t= GetUsedSubstArgs::From (prev_segment);\n+\n+\t      if (!used_args_in_prev_segment.is_error ())\n+\t\t{\n+\t\t  if (SubstMapperInternal::mappings_are_bound (\n+\t\t\ttyseg, used_args_in_prev_segment))\n+\t\t    {\n+\t\t      tyseg = SubstMapperInternal::Resolve (\n+\t\t\ttyseg, used_args_in_prev_segment);\n+\t\t    }\n+\t\t}\n \t    }\n \t}\n \n@@ -420,30 +464,25 @@ TypeCheckExpr::resolve_segments (NodeId root_resolved_node_id,\n \t  if (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n \t    return;\n \t}\n-    }\n-\n-  context->insert_receiver (expr_mappings.get_hirid (), prev_segment);\n-  if (tyseg->needs_generic_substitutions ())\n-    {\n-      Location locus = segments.back ().get_locus ();\n-      if (!prev_segment->needs_generic_substitutions ())\n-\t{\n-\t  auto used_args_in_prev_segment\n-\t    = GetUsedSubstArgs::From (prev_segment);\n-\t  if (!used_args_in_prev_segment.is_error ())\n-\t    tyseg\n-\t      = SubstMapperInternal::Resolve (tyseg, used_args_in_prev_segment);\n-\t}\n-      else\n+      else if (tyseg->needs_generic_substitutions () && !reciever_is_generic)\n \t{\n+\t  Location locus = seg.get_locus ();\n \t  tyseg = SubstMapper::InferSubst (tyseg, locus);\n+\t  if (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n+\t    return;\n \t}\n+    }\n \n+  rust_assert (resolved_node_id != UNKNOWN_NODEID);\n+  if (tyseg->needs_generic_substitutions () && !reciever_is_generic)\n+    {\n+      Location locus = segments.back ().get_locus ();\n+      tyseg = SubstMapper::InferSubst (tyseg, locus);\n       if (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n \treturn;\n     }\n \n-  rust_assert (resolved_node_id != UNKNOWN_NODEID);\n+  context->insert_receiver (expr_mappings.get_hirid (), prev_segment);\n \n   // lookup if the name resolver was able to canonically resolve this or not\n   NodeId path_resolved_id = UNKNOWN_NODEID;"}, {"sha": "f96b9b3ee7a8f95b373ab40a9b8bdae6f0aa3580", "filename": "gcc/rust/typecheck/rust-substitution-mapper.cc", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d1ff568084ed86e6cf14e709fe6892256be824a/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d1ff568084ed86e6cf14e709fe6892256be824a/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.cc?ref=6d1ff568084ed86e6cf14e709fe6892256be824a", "patch": "@@ -43,5 +43,23 @@ SubstMapperInternal::Resolve (TyTy::BaseType *base,\n   return mapper.resolved;\n }\n \n+bool\n+SubstMapperInternal::mappings_are_bound (\n+  TyTy::BaseType *tyseg, TyTy::SubstitutionArgumentMappings &mappings)\n+{\n+  if (tyseg->get_kind () == TyTy::TypeKind::ADT)\n+    {\n+      TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (tyseg);\n+      return adt->are_mappings_bound (mappings);\n+    }\n+  else if (tyseg->get_kind () == TyTy::TypeKind::FNDEF)\n+    {\n+      TyTy::FnType *fn = static_cast<TyTy::FnType *> (tyseg);\n+      return fn->are_mappings_bound (mappings);\n+    }\n+\n+  return false;\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "4ea4762b4b30e2720c5c03123b40a9394040d3ca", "filename": "gcc/rust/typecheck/rust-substitution-mapper.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d1ff568084ed86e6cf14e709fe6892256be824a/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d1ff568084ed86e6cf14e709fe6892256be824a/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h?ref=6d1ff568084ed86e6cf14e709fe6892256be824a", "patch": "@@ -156,6 +156,9 @@ class SubstMapperInternal : public TyTy::TyVisitor\n   static TyTy::BaseType *Resolve (TyTy::BaseType *base,\n \t\t\t\t  TyTy::SubstitutionArgumentMappings &mappings);\n \n+  static bool mappings_are_bound (TyTy::BaseType *ty,\n+\t\t\t\t  TyTy::SubstitutionArgumentMappings &mappings);\n+\n   void visit (TyTy::FnType &type) override\n   {\n     TyTy::SubstitutionArgumentMappings adjusted"}, {"sha": "0dde2998bf264f5153638823ad12b00c39a974b9", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d1ff568084ed86e6cf14e709fe6892256be824a/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d1ff568084ed86e6cf14e709fe6892256be824a/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=6d1ff568084ed86e6cf14e709fe6892256be824a", "patch": "@@ -636,6 +636,45 @@ SubstitutionRef::adjust_mappings_for_this (\n \t\t\t\t       mappings.get_locus ());\n }\n \n+bool\n+SubstitutionRef::are_mappings_bound (SubstitutionArgumentMappings &mappings)\n+{\n+  std::vector<SubstitutionArg> resolved_mappings;\n+  for (size_t i = 0; i < substitutions.size (); i++)\n+    {\n+      auto &subst = substitutions.at (i);\n+\n+      SubstitutionArg arg = SubstitutionArg::error ();\n+      if (mappings.size () == substitutions.size ())\n+\t{\n+\t  mappings.get_argument_at (i, &arg);\n+\t}\n+      else\n+\t{\n+\t  if (subst.needs_substitution ())\n+\t    {\n+\t      // get from passed in mappings\n+\t      mappings.get_argument_for_symbol (subst.get_param_ty (), &arg);\n+\t    }\n+\t  else\n+\t    {\n+\t      // we should already have this somewhere\n+\t      used_arguments.get_argument_for_symbol (subst.get_param_ty (),\n+\t\t\t\t\t\t      &arg);\n+\t    }\n+\t}\n+\n+      bool ok = !arg.is_error ();\n+      if (ok)\n+\t{\n+\t  SubstitutionArg adjusted (&subst, arg.get_tyty ());\n+\t  resolved_mappings.push_back (std::move (adjusted));\n+\t}\n+    }\n+\n+  return !resolved_mappings.empty ();\n+}\n+\n // this function assumes that the mappings being passed are for the same type as\n // this new substitution reference so ordering matters here\n SubstitutionArgumentMappings"}, {"sha": "036d7723bad6551f935addd1bb86ab66fff503fd", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d1ff568084ed86e6cf14e709fe6892256be824a/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d1ff568084ed86e6cf14e709fe6892256be824a/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=6d1ff568084ed86e6cf14e709fe6892256be824a", "patch": "@@ -906,6 +906,57 @@ class SubstitutionRef\n   SubstitutionArgumentMappings\n   adjust_mappings_for_this (SubstitutionArgumentMappings &mappings);\n \n+  // Are the mappings here actually bound to this type. For example imagine the\n+  // case:\n+  //\n+  // struct Foo<T>(T);\n+  // impl<T> Foo<T> {\n+  //   fn test(self) { ... }\n+  // }\n+  //\n+  // In this case we have a generic ADT of Foo and an impl block of a generic T\n+  // on Foo for the Self type. When we it comes to path resolution we can have:\n+  //\n+  // Foo::<i32>::test()\n+  //\n+  // This means the first segment of Foo::<i32> returns the ADT Foo<i32> not the\n+  // Self ADT bound to the T from the impl block. This means when it comes to\n+  // the next segment of test which resolves to the function we need to check\n+  // wether the arguments in the struct definition of foo can be bound here\n+  // before substituting the previous segments type here. This functions acts as\n+  // a guard for the solve_mappings_from_receiver_for_self to handle the case\n+  // where arguments are not bound. This is important for this next case:\n+  //\n+  // struct Baz<A, B>(A, B);\n+  // impl Baz<i32, f32> {\n+  //   fn test<X>(a: X) -> X {\n+  //       a\n+  //   }\n+  // }\n+  //\n+  // In this case Baz has been already substituted for the impl's Self to become\n+  // ADT<i32, f32> so that the function test only has 1 generic argument of X.\n+  // The path for this will be:\n+  //\n+  // Baz::test::<_>(123)\n+  //\n+  // So the first segment here will be Baz<_, _> to try and infer the arguments\n+  // which will be taken from the impl's Self type in this case since it is\n+  // already substituted and like the previous case the check to see if we need\n+  // to inherit the previous segments generic arguments takes place but the\n+  // generic arguments are not bound to this type as they have already been\n+  // substituted.\n+  //\n+  // Its important to remember from the first example the FnType actually looks\n+  // like:\n+  //\n+  // fn <T>test(self :Foo<T>(T))\n+  //\n+  // As the generic parameters are \"bound\" to each of the items in the impl\n+  // block. So this check is about wether the arguments we have here can\n+  // actually be bound to this type.\n+  bool are_mappings_bound (SubstitutionArgumentMappings &mappings);\n+\n   // struct Foo<A, B>(A, B);\n   //\n   // impl<T> Foo<T, f32>;"}, {"sha": "88a865d66dcfc47d9ed65d5a08a77cc99986c77f", "filename": "gcc/testsuite/rust/compile/torture/issue-893-2.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d1ff568084ed86e6cf14e709fe6892256be824a/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fissue-893-2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d1ff568084ed86e6cf14e709fe6892256be824a/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fissue-893-2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fissue-893-2.rs?ref=6d1ff568084ed86e6cf14e709fe6892256be824a", "patch": "@@ -0,0 +1,35 @@\n+// { dg-additional-options \"-w\" }\n+struct Foo<T>(T);\n+impl<T> Foo<T> {\n+    fn new<Y>(a: T, b: Y) -> Self {\n+        Self(a)\n+    }\n+}\n+\n+struct Bar<T>(T);\n+impl Bar<i32> {\n+    fn baz(self) {}\n+\n+    fn test() -> i32 {\n+        123\n+    }\n+}\n+\n+struct Baz<A, B>(A, B);\n+impl Baz<i32, f32> {\n+    fn test<X>(a: X) -> X {\n+        a\n+    }\n+}\n+\n+pub fn main() {\n+    let a = Foo::<i32>::new::<f32>(123, 456f32);\n+    let b = Foo::new::<f32>(123, 456f32);\n+\n+    let c = Bar::<i32>(123);\n+    let d = Bar::baz(c);\n+\n+    let e = Bar::test();\n+\n+    let f = Baz::test::<bool>(true);\n+}"}, {"sha": "d8245f3e0d851a734247e48afecac66f0b64a3ed", "filename": "gcc/testsuite/rust/compile/torture/issue-893.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d1ff568084ed86e6cf14e709fe6892256be824a/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fissue-893.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d1ff568084ed86e6cf14e709fe6892256be824a/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fissue-893.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fissue-893.rs?ref=6d1ff568084ed86e6cf14e709fe6892256be824a", "patch": "@@ -0,0 +1,11 @@\n+// { dg-additional-options \"-w\" }\n+struct Foo<T>(T);\n+impl<T> Foo<T> {\n+    fn new<Y>(a: T, b: Y) -> Self {\n+        Self(a)\n+    }\n+}\n+\n+pub fn test() {\n+    let a = Foo::<i32>::new::<f32>(123, 456f32);\n+}"}]}