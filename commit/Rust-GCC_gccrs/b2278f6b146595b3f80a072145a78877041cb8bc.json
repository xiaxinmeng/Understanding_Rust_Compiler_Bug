{"sha": "b2278f6b146595b3f80a072145a78877041cb8bc", "node_id": "C_kwDOANBUbNoAKGIyMjc4ZjZiMTQ2NTk1YjNmODBhMDcyMTQ1YTc4ODc3MDQxY2I4YmM", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-10-18T09:32:02Z"}, "committer": {"name": "Marc Poulhi\u00e8s", "email": "poulhies@adacore.com", "date": "2022-11-08T08:35:03Z"}, "message": "ada: Fix oversight in implementation of allocators for storage models\n\nWhen the allocator is of an unconstrained array type and has an initializing\nexpression, the copy of the initializing expression must be done separately\nfrom that of the bounds.\n\ngcc/ada/\n\n\t* gcc-interface/utils2.cc (build_allocator): For unconstrained\n\tarray types with a storage model and an initializing expression,\n\tcopy the initialization expression separately from the bounds. In\n\tall cases with a storage model, pass the locally computed size for\n\tthe store.", "tree": {"sha": "78f57407fc72c37b5db3acf12a88855551bab6ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78f57407fc72c37b5db3acf12a88855551bab6ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b2278f6b146595b3f80a072145a78877041cb8bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2278f6b146595b3f80a072145a78877041cb8bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2278f6b146595b3f80a072145a78877041cb8bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2278f6b146595b3f80a072145a78877041cb8bc/comments", "author": null, "committer": {"login": "dkm", "id": 87603, "node_id": "MDQ6VXNlcjg3NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/87603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dkm", "html_url": "https://github.com/dkm", "followers_url": "https://api.github.com/users/dkm/followers", "following_url": "https://api.github.com/users/dkm/following{/other_user}", "gists_url": "https://api.github.com/users/dkm/gists{/gist_id}", "starred_url": "https://api.github.com/users/dkm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dkm/subscriptions", "organizations_url": "https://api.github.com/users/dkm/orgs", "repos_url": "https://api.github.com/users/dkm/repos", "events_url": "https://api.github.com/users/dkm/events{/privacy}", "received_events_url": "https://api.github.com/users/dkm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10f193eb043e30741d9631999bc869d71d43264c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10f193eb043e30741d9631999bc869d71d43264c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10f193eb043e30741d9631999bc869d71d43264c"}], "stats": {"total": 33, "additions": 26, "deletions": 7}, "files": [{"sha": "80d550c91e190119c4439f833bcc830a9555de63", "filename": "gcc/ada/gcc-interface/utils2.cc", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2278f6b146595b3f80a072145a78877041cb8bc/gcc%2Fada%2Fgcc-interface%2Futils2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2278f6b146595b3f80a072145a78877041cb8bc/gcc%2Fada%2Fgcc-interface%2Futils2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.cc?ref=b2278f6b146595b3f80a072145a78877041cb8bc", "patch": "@@ -2439,8 +2439,8 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n       tree storage_ptr_type = build_pointer_type (storage_type);\n       tree lhs, rhs;\n \n-      size = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TYPE_SIZE_UNIT (storage_type),\n-\t\t\t\t\t     init);\n+      size = TYPE_SIZE_UNIT (storage_type);\n+      size = SUBSTITUTE_PLACEHOLDER_IN_EXPR (size, init);\n \n       /* If the size overflows, pass -1 so Storage_Error will be raised.  */\n       if (TREE_CODE (size) == INTEGER_CST && !valid_constant_size_p (size))\n@@ -2454,8 +2454,10 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n \n       /* If there is an initializing expression, then make a constructor for\n \t the entire object including the bounds and copy it into the object.\n-\t If there is no initializing expression, just set the bounds.  */\n-      if (init)\n+\t If there is no initializing expression, just set the bounds.  Note\n+\t that, if we have a storage model, we need to copy the initializing\n+\t expression separately from the bounds.  */\n+      if (init && !pool_is_storage_model)\n \t{\n \t  vec<constructor_elt, va_gc> *v;\n \t  vec_alloc (v, 2);\n@@ -2472,11 +2474,28 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n \t{\n \t  lhs = build_component_ref (storage_deref, TYPE_FIELDS (storage_type),\n \t\t\t\t     false);\n-\t  rhs = build_template (template_type, type, NULL_TREE);\n+\t  rhs = build_template (template_type, type, init);\n \t}\n \n       if (pool_is_storage_model)\n-\tstorage_init = build_storage_model_store (gnat_pool, lhs, rhs);\n+\t{\n+\t  storage_init = build_storage_model_store (gnat_pool, lhs, rhs);\n+\t  if (init)\n+\t    {\n+\t      start_stmt_group ();\n+\t      add_stmt (storage_init);\n+\t      lhs\n+\t\t= build_component_ref (storage_deref,\n+\t\t\t\t       DECL_CHAIN (TYPE_FIELDS (storage_type)),\n+\t\t\t\t       false);\n+\t      rhs = init;\n+\t      size = TYPE_SIZE_UNIT (TREE_TYPE (lhs));\n+\t      size = SUBSTITUTE_PLACEHOLDER_IN_EXPR (size, init);\n+\t      tree t = build_storage_model_store (gnat_pool, lhs, rhs, size);\n+\t      add_stmt (t);\n+\t      storage_init = end_stmt_group ();\n+\t    }\n+\t}\n       else\n \tstorage_init = build_binary_op (INIT_EXPR, NULL_TREE, lhs, rhs);\n \n@@ -2520,7 +2539,7 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n       TREE_THIS_NOTRAP (storage_deref) = 1;\n       if (pool_is_storage_model)\n \tstorage_init\n-\t  = build_storage_model_store (gnat_pool, storage_deref, init);\n+\t  = build_storage_model_store (gnat_pool, storage_deref, init, size);\n       else\n \tstorage_init\n \t  = build_binary_op (INIT_EXPR, NULL_TREE, storage_deref, init);"}]}