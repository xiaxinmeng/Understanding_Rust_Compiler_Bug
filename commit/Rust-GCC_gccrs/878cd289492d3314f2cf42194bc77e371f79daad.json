{"sha": "878cd289492d3314f2cf42194bc77e371f79daad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODc4Y2QyODk0OTJkMzMxNGYyY2Y0MjE5NGJjNzdlMzcxZjc5ZGFhZA==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1995-05-27T00:15:16Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1995-05-27T00:15:16Z"}, "message": "73rd Cygnus<->FSF merge\n\nFrom-SVN: r9826", "tree": {"sha": "a6c853d77ddd60a2d65623f5f185787018135bf3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a6c853d77ddd60a2d65623f5f185787018135bf3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/878cd289492d3314f2cf42194bc77e371f79daad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/878cd289492d3314f2cf42194bc77e371f79daad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/878cd289492d3314f2cf42194bc77e371f79daad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/878cd289492d3314f2cf42194bc77e371f79daad/comments", "author": null, "committer": null, "parents": [{"sha": "73b73053ff8f411935a1d8688c6238dcf23c7394", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73b73053ff8f411935a1d8688c6238dcf23c7394", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73b73053ff8f411935a1d8688c6238dcf23c7394"}], "stats": {"total": 291, "additions": 213, "deletions": 78}, "files": [{"sha": "44ede234c7236af5af9c3b51de31322c0ec62569", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/878cd289492d3314f2cf42194bc77e371f79daad/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/878cd289492d3314f2cf42194bc77e371f79daad/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=878cd289492d3314f2cf42194bc77e371f79daad", "patch": "@@ -17,8 +17,66 @@ Mon May 22 17:38:48 1995  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)\n \t(c++.mostlyclean, stage[1-4]): Use $(objext) in object file names.\n \t* Makefile.in (../cc1plus): Use $(exeext) in name of executable.\n \n+Wed May 24 01:39:03 1995  Jason Merrill  <jason@deneb.cygnus.com>\n+\n+\t* call.c (build_method_call): parms can be null, duh.\n+\n+Tue May 23 01:32:09 1995  Jason Merrill  <jason@deneb.cygnus.com>\n+\n+\t* call.c (build_method_call): If convert_arguments failed, just bail.\n+\n+Fri May 19 10:31:11 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* cvt.c (convert_force): Pass LOOKUP_NORMAL to cp_convert.\n+\n+\t* tree.c (copy_to_permanent): Oops.\n+\n+Fri May 19 10:01:07 1995  Brendan Kehoe  (brendan@lisa.cygnus.com)\n+\n+\t* cp-tree.h (break_out_target_exprs): Add decl.\n+\n+Thu May 18 13:02:30 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* decl.c (start_function): Move *all* interface handling stuff after\n+\tthe pushdecl.\n+\n+\t* tree.c (mapcar): Renamed from make_deep_copy and generalized.\n+\t(perm_manip): Return t if permanent, otherwise 0.\n+\t(copy_to_permanent): Use them.\n+\t(bot_manip): Helper for break_out_target_exprs.\n+\t(break_out_target_exprs): New function.  Uses mapcar.\n+\n+\t* typeck.c (convert_arguments): Use it.\n+\n+\t* method.c (hack_identifier): Use convert_from_reference to\n+\tdereference a reference.\n+\n+Wed May 17 17:54:54 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* call.c (convert_harshness): Move reference bashing before pointer\n+\tto member bashing.\n+\n+Wed May 17 16:57:53 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* cvt.c (convert_to_reference): Only complain, if complaints are\n+\twanted.\n+\ttypeck.c (build_function_call_real): Ditto.  If LOOKUP_SPECULATIVELY\n+\tis set and something won't work, return NULL_TREE.\n+\tcvt.c (cp_convert): Ditto.  Pass flags down to build_method_call.\n+\t(convert): Pass LOOKUP_NORMAL to cp_convert.\n+\ttypeck.c (convert_for_assignment): Ditto.\n+\t(convert_force): Pass LOOKUP_COMPLAIN to cp_convert.\n+\ttypeck.c (convert_arguments): Get out early if we get an\n+\terror_mark_node.\n+\t(convert_for_initialization): Use cp_convert instead of convert so\n+\tthat we can pass flags down.\n+\t* cp-tree.h (LOOKUP_SPECULATIVELY): Added documentation.\n+\n Wed May 17 01:43:58 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n \n+\t* typeck2.c (store_init_value): Don't take the MAIN_VARIANT of the\n+\tdecl type.\n+\n \t* class.c (finish_struct): Don't complain about a class with no\n \tuser-defined constructors but with a member that has no default\n \tconstructor, as this is OK for aggregates."}, {"sha": "f594addfccac935875f4319ce525aa7397367bfe", "filename": "gcc/cp/call.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/878cd289492d3314f2cf42194bc77e371f79daad/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/878cd289492d3314f2cf42194bc77e371f79daad/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=878cd289492d3314f2cf42194bc77e371f79daad", "patch": "@@ -129,11 +129,6 @@ convert_harshness (type, parmtype, parm)\n   n_convert_harshness++;\n #endif\n \n-  if (TYPE_PTRMEMFUNC_P (type))\n-    type = TYPE_PTRMEMFUNC_FN_TYPE (type);\n-  if (TYPE_PTRMEMFUNC_P (parmtype))\n-    parmtype = TYPE_PTRMEMFUNC_FN_TYPE (parmtype);\n-\n   if (TREE_CODE (parmtype) == REFERENCE_TYPE)\n     {\n       if (parm)\n@@ -146,6 +141,11 @@ convert_harshness (type, parmtype, parm)\n   else\n     lvalue = 0;\n \n+  if (TYPE_PTRMEMFUNC_P (type))\n+    type = TYPE_PTRMEMFUNC_FN_TYPE (type);\n+  if (TYPE_PTRMEMFUNC_P (parmtype))\n+    parmtype = TYPE_PTRMEMFUNC_FN_TYPE (parmtype);\n+\n   codel = TREE_CODE (type);\n   coder = TREE_CODE (parmtype);\n \n@@ -2635,6 +2635,10 @@ build_method_call (instance, name, parms, basetype_path, flags)\n     }\n #endif\n \n+  if (parms == error_mark_node\n+      || (parms && TREE_CHAIN (parms) == error_mark_node))\n+    return error_mark_node;\n+\n   if (need_vtbl == needed)\n     {\n       function = build_vfn_ref (&TREE_VALUE (parms), instance,"}, {"sha": "ce523ecdd6c61c8277a466ba256f3832a135ea1f", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/878cd289492d3314f2cf42194bc77e371f79daad/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/878cd289492d3314f2cf42194bc77e371f79daad/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=878cd289492d3314f2cf42194bc77e371f79daad", "patch": "@@ -1825,6 +1825,9 @@ extern tree current_class_type;\t/* _TYPE: the type of the current class */\n    LOOKUP_HAS_IN_CHARGE means that the \"in charge\" variable is already\n      in the parameter list.\n    LOOKUP_ONLYCONVERTING means that non-conversion constructors are not tried.\n+   LOOKUP_SPECULATIVELY means return NULL_TREE if we cannot find what we are\n+     after.  Note, LOOKUP_COMPLAIN is checked and error messages printed\n+     before LOOKUP_SPECULATIVELY is checked.\n    LOOKUP_NO_CONVERSION means that user-defined conversions are not\n      permitted.  Built-in conversions are permitted.\n    LOOKUP_DESTRUCTOR means explicit call to destructor.  */\n@@ -2361,6 +2364,7 @@ extern void print_lang_statistics\t\tPROTO((void));\n /* skip __eprintf */\n extern tree array_type_nelts_total\t\tPROTO((tree));\n extern tree array_type_nelts_top\t\tPROTO((tree));\n+extern tree break_out_target_exprs\t\tPROTO((tree));\n \n /* in typeck.c */\n extern tree condition_conversion\t\tPROTO((tree));"}, {"sha": "ce781fbdd6f40d3492eafe6211d4c63e030b1997", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 32, "deletions": 14, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/878cd289492d3314f2cf42194bc77e371f79daad/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/878cd289492d3314f2cf42194bc77e371f79daad/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=878cd289492d3314f2cf42194bc77e371f79daad", "patch": "@@ -836,12 +836,12 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n \n   my_friendly_assert (TREE_CODE (intype) != OFFSET_TYPE, 189);\n \n+  if (flags & LOOKUP_COMPLAIN)\n+    cp_error (\"cannot convert type `%T' to type `%T'\", intype, reftype);\n+\n   if (flags & LOOKUP_SPECULATIVELY)\n     return NULL_TREE;\n \n-  else if (flags & LOOKUP_COMPLAIN)\n-    cp_error (\"cannot convert type `%T' to type `%T'\", intype, reftype);\n-\n   return error_mark_node;\n }\n \n@@ -1190,6 +1190,10 @@ convert_pointer_to_vbase (binfo, expr)\n   return NULL_TREE;\n }\n \f\n+/* Conversion...\n+\n+   FLAGS indicates how we should behave.  */\n+\n tree\n cp_convert (type, expr, convtype, flags)\n      tree type, expr;\n@@ -1259,7 +1263,10 @@ cp_convert (type, expr, convtype, flags)\n \t  rval = build_type_conversion (CONVERT_EXPR, type, e, 1);\n \t  if (rval)\n \t    return rval;\n-\t  cp_error (\"`%#T' used where a `%T' was expected\", intype, type);\n+\t  if (flags & LOOKUP_COMPLAIN)\n+\t    cp_error (\"`%#T' used where a `%T' was expected\", intype, type);\n+\t  if (flags & LOOKUP_SPECULATIVELY)\n+\t    return NULL_TREE;\n \t  return error_mark_node;\n \t}\n       if (code == BOOLEAN_TYPE)\n@@ -1278,8 +1285,9 @@ cp_convert (type, expr, convtype, flags)\n \t  if (rval)\n \t    return rval;\n \t  else\n-\t    cp_error (\"`%#T' used where a floating point value was expected\",\n-\t\t      TREE_TYPE (e));\n+\t    if (flags & LOOKUP_COMPLAIN)\n+\t      cp_error (\"`%#T' used where a floating point value was expected\",\n+\t\t\tTREE_TYPE (e));\n \t}\n       return fold (convert_to_real (type, e));\n     }\n@@ -1331,27 +1339,34 @@ cp_convert (type, expr, convtype, flags)\n \n       if (conversion == error_mark_node)\n \t{\n-\t  error (\"ambiguous pointer conversion\");\n+\t  if (flags & LOOKUP_COMPLAIN)\n+\t    error (\"ambiguous pointer conversion\");\n \t  return conversion;\n \t}\n \n       if (TYPE_HAS_CONSTRUCTOR (type))\n \tctor = build_method_call (NULL_TREE, constructor_name_full (type),\n \t\t\t\t  build_tree_list (NULL_TREE, e),\n \t\t\t\t  TYPE_BINFO (type),\n-\t\t\t\t  LOOKUP_NORMAL | LOOKUP_SPECULATIVELY\n+\t\t\t\t  (flags & LOOKUP_NORMAL) | LOOKUP_SPECULATIVELY\n \t\t\t\t  | (convtype&CONV_NONCONVERTING ? 0 : LOOKUP_ONLYCONVERTING)\n \t\t\t\t  | (conversion ? LOOKUP_NO_CONVERSION : 0));\n \n       if (ctor == error_mark_node)\n \t{\n-\t  cp_error (\"in conversion to type `%T'\", type);\n+\t  if (flags & LOOKUP_COMPLAIN)\n+\t    cp_error (\"in conversion to type `%T'\", type);\n+\t  if (flags & LOOKUP_SPECULATIVELY)\n+\t    return NULL_TREE;\n \t  return error_mark_node;\n \t}\n       \n       if (conversion && ctor)\n \t{\n-\t  error (\"both constructor and type conversion operator apply\");\n+\t  if (flags & LOOKUP_COMPLAIN)\n+\t    error (\"both constructor and type conversion operator apply\");\n+\t  if (flags & LOOKUP_SPECULATIVELY)\n+\t    return NULL_TREE;\n \t  return error_mark_node;\n \t}\n       else if (conversion)\n@@ -1408,8 +1423,11 @@ cp_convert (type, expr, convtype, flags)\n       && index_type_equal (TYPE_DOMAIN (TREE_TYPE (e)), TYPE_DOMAIN (type)))\n     return e;\n \n-  cp_error (\"conversion from `%T' to non-scalar type `%T' requested\",\n-\t    TREE_TYPE (expr), type);\n+  if (flags & LOOKUP_COMPLAIN)\n+    cp_error (\"conversion from `%T' to non-scalar type `%T' requested\",\n+\t      TREE_TYPE (expr), type);\n+  if (flags & LOOKUP_SPECULATIVELY)\n+    return NULL_TREE;\n   return error_mark_node;\n }\n \n@@ -1423,7 +1441,7 @@ tree\n convert (type, expr)\n      tree type, expr;\n {\n-  return cp_convert (type, expr, CONV_OLD_CONVERT, 0);\n+  return cp_convert (type, expr, CONV_OLD_CONVERT, LOOKUP_NORMAL);\n }\n \n /* Like convert, except permit conversions to take place which\n@@ -1459,7 +1477,7 @@ convert_force (type, expr, convtype)\n       return build_ptrmemfunc (TYPE_PTRMEMFUNC_FN_TYPE (type), e, 1);\n     }\n \n-  return cp_convert (type, e, CONV_C_CAST|convtype, 0);\n+  return cp_convert (type, e, CONV_C_CAST|convtype, LOOKUP_NORMAL);\n }\n \n /* Subroutine of build_type_conversion.  */"}, {"sha": "2803912cf6ef3fb2df42c34e87d778af3e5db00b", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/878cd289492d3314f2cf42194bc77e371f79daad/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/878cd289492d3314f2cf42194bc77e371f79daad/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=878cd289492d3314f2cf42194bc77e371f79daad", "patch": "@@ -11129,6 +11129,19 @@ start_function (declspecs, declarator, raises, pre_parsed_p)\n      (This does not mean `static' in the C sense!)  */\n   TREE_STATIC (decl1) = 1;\n \n+  /* Record the decl so that the function name is defined.\n+     If we already have a decl for this name, and it is a FUNCTION_DECL,\n+     use the old decl.  */\n+\n+  if (pre_parsed_p == 0)\n+    {\n+      current_function_decl = decl1 = pushdecl (decl1);\n+      DECL_MAIN_VARIANT (decl1) = decl1;\n+      fntype = TREE_TYPE (decl1);\n+    }\n+  else\n+    current_function_decl = decl1;\n+\n   if (DECL_INTERFACE_KNOWN (decl1))\n     {\n       if (DECL_NOT_REALLY_EXTERN (decl1))\n@@ -11154,27 +11167,15 @@ start_function (declspecs, declarator, raises, pre_parsed_p)\n \t So clear DECL_EXTERNAL.  */\n       DECL_EXTERNAL (decl1) = 0;\n \n-      if (DECL_C_STATIC (decl1))\n-\tTREE_PUBLIC (decl1) = 0;\n-    }\n-\n-  /* Record the decl so that the function name is defined.\n-     If we already have a decl for this name, and it is a FUNCTION_DECL,\n-     use the old decl.  */\n-\n-  if (pre_parsed_p == 0)\n-    {\n-      current_function_decl = decl1 = pushdecl (decl1);\n-      DECL_MAIN_VARIANT (decl1) = decl1;\n-      fntype = TREE_TYPE (decl1);\n+      if (DECL_THIS_INLINE (decl1) && ! DECL_INTERFACE_KNOWN (decl1))\n+\tDECL_DEFER_OUTPUT (decl1) = 1;\n+      else\n+\t{\n+\t  DECL_INTERFACE_KNOWN (decl1) = 1;\n+\t  if (DECL_C_STATIC (decl1))\n+\t    TREE_PUBLIC (decl1) = 0;\n+\t}\n     }\n-  else\n-    current_function_decl = decl1;\n-\n-  if (DECL_THIS_INLINE (decl1) && ! DECL_INTERFACE_KNOWN (decl1))\n-    DECL_DEFER_OUTPUT (decl1) = 1;\n-  else\n-    DECL_INTERFACE_KNOWN (decl1) = 1;\n \n   if (ctype != NULL_TREE && DECL_STATIC_FUNCTION_P (decl1))\n     {"}, {"sha": "7d06b02ad55d14b3ce68bfafee74c0d4413ce4e4", "filename": "gcc/cp/method.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/878cd289492d3314f2cf42194bc77e371f79daad/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/878cd289492d3314f2cf42194bc77e371f79daad/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=878cd289492d3314f2cf42194bc77e371f79daad", "patch": "@@ -1567,8 +1567,7 @@ hack_identifier (value, name, yychar)\n       my_friendly_assert (TREE_CODE (value) == VAR_DECL\n \t\t\t  || TREE_CODE (value) == PARM_DECL\n \t\t\t  || TREE_CODE (value) == RESULT_DECL, 252);\n-      if (DECL_REFERENCE_SLOT (value))\n-\treturn DECL_REFERENCE_SLOT (value);\n+      return convert_from_reference (value);\n     }\n   return value;\n }"}, {"sha": "110f41e8c8b665536f6ca065acdcc27f037594a5", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 68, "deletions": 32, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/878cd289492d3314f2cf42194bc77e371f79daad/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/878cd289492d3314f2cf42194bc77e371f79daad/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=878cd289492d3314f2cf42194bc77e371f79daad", "patch": "@@ -1614,15 +1614,21 @@ build_exception_variant (ctype, type, raises)\n \n    Assuming T is a node build bottom-up, make it all exist on\n    permanent obstack, if it is not permanent already.  */\n-static tree\n-make_deep_copy (t)\n+\n+tree\n+mapcar (t, func)\n      tree t;\n+     tree (*func)();\n {\n   enum tree_code code;\n+  tree tmp;\n \n-  if (t == NULL_TREE || TREE_PERMANENT (t))\n+  if (t == NULL_TREE)\n     return t;\n \n+  if (tmp = func (t), tmp != NULL_TREE)\n+    return tmp;\n+\n   switch (code = TREE_CODE (t))\n     {\n     case ERROR_MARK:\n@@ -1637,20 +1643,20 @@ make_deep_copy (t)\n       {\n \ttree chain = TREE_CHAIN (t);\n \tt = copy_node (t);\n-\tTREE_CHAIN (t) = make_deep_copy (chain);\n-\tTREE_TYPE (t) = make_deep_copy (TREE_TYPE (t));\n-\tDECL_INITIAL (t) = make_deep_copy (DECL_INITIAL (t));\n-\tDECL_SIZE (t) = make_deep_copy (DECL_SIZE (t));\n+\tTREE_CHAIN (t) = mapcar (chain, func);\n+\tTREE_TYPE (t) = mapcar (TREE_TYPE (t), func);\n+\tDECL_INITIAL (t) = mapcar (DECL_INITIAL (t), func);\n+\tDECL_SIZE (t) = mapcar (DECL_SIZE (t), func);\n \treturn t;\n       }\n \n     case TREE_LIST:\n       {\n \ttree chain = TREE_CHAIN (t);\n \tt = copy_node (t);\n-\tTREE_PURPOSE (t) = make_deep_copy (TREE_PURPOSE (t));\n-\tTREE_VALUE (t) = make_deep_copy (TREE_VALUE (t));\n-\tTREE_CHAIN (t) = make_deep_copy (chain);\n+\tTREE_PURPOSE (t) = mapcar (TREE_PURPOSE (t), func);\n+\tTREE_VALUE (t) = mapcar (TREE_VALUE (t), func);\n+\tTREE_CHAIN (t) = mapcar (chain, func);\n \treturn t;\n       }\n \n@@ -1660,7 +1666,7 @@ make_deep_copy (t)\n \n \tt = copy_node (t);\n \twhile (len--)\n-\t  TREE_VEC_ELT (t, len) = make_deep_copy (TREE_VEC_ELT (t, len));\n+\t  TREE_VEC_ELT (t, len) = mapcar (TREE_VEC_ELT (t, len), func);\n \treturn t;\n       }\n \n@@ -1673,14 +1679,14 @@ make_deep_copy (t)\n     case TARGET_EXPR:\n     case NEW_EXPR:\n       t = copy_node (t);\n-      TREE_OPERAND (t, 0) = make_deep_copy (TREE_OPERAND (t, 0));\n-      TREE_OPERAND (t, 1) = make_deep_copy (TREE_OPERAND (t, 1));\n-      TREE_OPERAND (t, 2) = make_deep_copy (TREE_OPERAND (t, 2));\n+      TREE_OPERAND (t, 0) = mapcar (TREE_OPERAND (t, 0), func);\n+      TREE_OPERAND (t, 1) = mapcar (TREE_OPERAND (t, 1), func);\n+      TREE_OPERAND (t, 2) = mapcar (TREE_OPERAND (t, 2), func);\n       return t;\n \n     case SAVE_EXPR:\n       t = copy_node (t);\n-      TREE_OPERAND (t, 0) = make_deep_copy (TREE_OPERAND (t, 0));\n+      TREE_OPERAND (t, 0) = mapcar (TREE_OPERAND (t, 0), func);\n       return t;\n \n     case MODIFY_EXPR:\n@@ -1718,8 +1724,8 @@ make_deep_copy (t)\n     case POSTINCREMENT_EXPR:\n     case CALL_EXPR:\n       t = copy_node (t);\n-      TREE_OPERAND (t, 0) = make_deep_copy (TREE_OPERAND (t, 0));\n-      TREE_OPERAND (t, 1) = make_deep_copy (TREE_OPERAND (t, 1));\n+      TREE_OPERAND (t, 0) = mapcar (TREE_OPERAND (t, 0), func);\n+      TREE_OPERAND (t, 1) = mapcar (TREE_OPERAND (t, 1), func);\n       return t;\n \n     case CONVERT_EXPR:\n@@ -1731,36 +1737,36 @@ make_deep_copy (t)\n     case NOP_EXPR:\n     case COMPONENT_REF:\n       t = copy_node (t);\n-      TREE_OPERAND (t, 0) = make_deep_copy (TREE_OPERAND (t, 0));\n+      TREE_OPERAND (t, 0) = mapcar (TREE_OPERAND (t, 0), func);\n       return t;\n \n     case POINTER_TYPE:\n-      return build_pointer_type (make_deep_copy (TREE_TYPE (t)));\n+      return build_pointer_type (mapcar (TREE_TYPE (t), func));\n     case REFERENCE_TYPE:\n-      return build_reference_type (make_deep_copy (TREE_TYPE (t)));\n+      return build_reference_type (mapcar (TREE_TYPE (t), func));\n     case FUNCTION_TYPE:\n-      return build_function_type (make_deep_copy (TREE_TYPE (t)),\n-\t\t\t\t  make_deep_copy (TYPE_ARG_TYPES (t)));\n+      return build_function_type (mapcar (TREE_TYPE (t), func),\n+\t\t\t\t  mapcar (TYPE_ARG_TYPES (t), func));\n     case ARRAY_TYPE:\n-      return build_array_type (make_deep_copy (TREE_TYPE (t)),\n-\t\t\t       make_deep_copy (TYPE_DOMAIN (t)));\n+      return build_array_type (mapcar (TREE_TYPE (t), func),\n+\t\t\t       mapcar (TYPE_DOMAIN (t), func));\n     case INTEGER_TYPE:\n-      return build_index_type (make_deep_copy (TYPE_MAX_VALUE (t)));\n+      return build_index_type (mapcar (TYPE_MAX_VALUE (t), func));\n \n     case OFFSET_TYPE:\n-      return build_offset_type (make_deep_copy (TYPE_OFFSET_BASETYPE (t)),\n-\t\t\t\tmake_deep_copy (TREE_TYPE (t)));\n+      return build_offset_type (mapcar (TYPE_OFFSET_BASETYPE (t), func),\n+\t\t\t\tmapcar (TREE_TYPE (t), func));\n     case METHOD_TYPE:\n       return build_method_type\n-\t(make_deep_copy (TYPE_METHOD_BASETYPE (t)),\n+\t(mapcar (TYPE_METHOD_BASETYPE (t), func),\n \t build_function_type\n-\t (make_deep_copy (TREE_TYPE (t)),\n-\t  make_deep_copy (TREE_CHAIN (TYPE_ARG_TYPES (t)))));\n+\t (mapcar (TREE_TYPE (t), func),\n+\t  mapcar (TREE_CHAIN (TYPE_ARG_TYPES (t)), func)));\n \n     case RECORD_TYPE:\n       if (TYPE_PTRMEMFUNC_P (t))\n \treturn build_ptrmemfunc_type\n-\t  (make_deep_copy (TYPE_PTRMEMFUNC_FN_TYPE (t)));\n+\t  (mapcar (TYPE_PTRMEMFUNC_FN_TYPE (t), func));\n       /* else fall through */\n       \n       /*  This list is incomplete, but should suffice for now.\n@@ -1776,6 +1782,15 @@ make_deep_copy (t)\n   return NULL_TREE;\n }\n \n+static tree\n+perm_manip (t)\n+     tree t;\n+{\n+  if (TREE_PERMANENT (t))\n+    return t;\n+  return NULL_TREE;\n+}\n+\n /* Assuming T is a node built bottom-up, make it all exist on\n    permanent obstack, if it is not permanent already.  */\n tree\n@@ -1793,7 +1808,7 @@ copy_to_permanent (t)\n   current_obstack = saveable_obstack;\n   resume = suspend_momentary ();\n \n-  t = make_deep_copy (t);\n+  t = mapcar (t, perm_manip);\n \n   resume_momentary (resume);\n   current_obstack = ambient_obstack;\n@@ -1866,3 +1881,24 @@ array_type_nelts_total (type)\n     }\n   return sz;\n }\n+\n+static\n+tree\n+bot_manip (t)\n+     tree t;\n+{\n+  if (TREE_CODE (t) != TREE_LIST && ! TREE_SIDE_EFFECTS (t))\n+    return t;\n+  else if (TREE_CODE (t) == TARGET_EXPR)\n+    return build_cplus_new (TREE_TYPE (t),\n+\t\t\t    break_out_target_exprs (TREE_OPERAND (t, 1)), 0);\n+  return NULL_TREE;\n+}\n+  \n+/* Actually, we'll just clean out the target exprs for the moment.  */\n+tree\n+break_out_target_exprs (t)\n+     tree t;\n+{\n+  return mapcar (t, bot_manip);\n+}"}, {"sha": "7e917daea878229c3f9522cf80e8939a508c5018", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/878cd289492d3314f2cf42194bc77e371f79daad/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/878cd289492d3314f2cf42194bc77e371f79daad/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=878cd289492d3314f2cf42194bc77e371f79daad", "patch": "@@ -2453,7 +2453,10 @@ build_function_call_real (function, params, require_complete, flags)\n \t\t\t\t\tparams, fndecl, 0);\n \n   if (coerced_params == error_mark_node)\n-    return error_mark_node;\n+    if (flags & LOOKUP_SPECULATIVELY)\n+      return NULL_TREE;\n+    else\n+      return error_mark_node;\n \n   /* Check for errors in format strings.  */\n \n@@ -2689,6 +2692,10 @@ convert_arguments (return_loc, typelist, values, fndecl, flags)\n \t\tparmval = default_conversion (parmval);\n #endif\n \t    }\n+\n+\t  if (parmval == error_mark_node)\n+\t    return error_mark_node;\n+\n \t  result = tree_cons (NULL_TREE, parmval, result);\n \t}\n       else\n@@ -2736,7 +2743,7 @@ convert_arguments (return_loc, typelist, values, fndecl, flags)\n \t  for (; typetail != void_list_node; ++i)\n \t    {\n \t      tree type = TREE_VALUE (typetail);\n-\t      tree val = TREE_PURPOSE (typetail);\n+\t      tree val = break_out_target_exprs (TREE_PURPOSE (typetail));\n \t      tree parmval;\n \n \t      if (val == NULL_TREE)\n@@ -2763,6 +2770,9 @@ convert_arguments (return_loc, typelist, values, fndecl, flags)\n #endif\n \t\t}\n \n+\t      if (parmval == error_mark_node)\n+\t\treturn error_mark_node;\n+\n \t      if (flag_gc\n \t\t  && type_needs_gc_entry (TREE_TYPE (parmval))\n \t\t  && ! value_safe_from_gc (NULL_TREE, parmval))\n@@ -6526,7 +6536,7 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \t   || (coder == ENUMERAL_TYPE\n \t       && (INTEGRAL_CODE_P (codel) || codel == REAL_TYPE)))\n     {\n-      return cp_convert (type, rhs, CONV_IMPLICIT, 0);\n+      return cp_convert (type, rhs, CONV_IMPLICIT, LOOKUP_NORMAL);\n     }\n   /* Conversions among pointers */\n   else if (codel == POINTER_TYPE\n@@ -6898,7 +6908,9 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n    latter (X(X&)).\n \n    If using constructor make sure no conversion operator exists, if one does\n-   exist, an ambiguity exists.  */\n+   exist, an ambiguity exists.\n+\n+   If flags doesn't include LOOKUP_COMPLAIN, don't complain about anything.  */\n tree\n convert_for_initialization (exp, type, rhs, flags, errtype, fndecl, parmnum)\n      tree exp, type, rhs;\n@@ -7069,7 +7081,7 @@ convert_for_initialization (exp, type, rhs, flags, errtype, fndecl, parmnum)\n \t  return rhs;\n \t}\n \n-      return convert (type, rhs);\n+      return cp_convert (type, rhs, CONV_OLD_CONVERT, flags);\n     }\n \n   if (type == TREE_TYPE (rhs))"}, {"sha": "593930ef9f59539912922a1f58b78c0f961af5ef", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/878cd289492d3314f2cf42194bc77e371f79daad/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/878cd289492d3314f2cf42194bc77e371f79daad/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=878cd289492d3314f2cf42194bc77e371f79daad", "patch": "@@ -537,8 +537,11 @@ store_init_value (decl, init)\n   if (TREE_CODE (type) == ERROR_MARK)\n     return NULL_TREE;\n \n+#if 0\n+  /* This breaks arrays, and should not have any effect for other decls.  */\n   /* Take care of C++ business up here.  */\n   type = TYPE_MAIN_VARIANT (type);\n+#endif\n \n   if (IS_AGGR_TYPE (type))\n     {"}]}