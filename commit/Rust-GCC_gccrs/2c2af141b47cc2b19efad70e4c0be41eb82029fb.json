{"sha": "2c2af141b47cc2b19efad70e4c0be41eb82029fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmMyYWYxNDFiNDdjYzJiMTllZmFkNzBlNGMwYmU0MWViODIwMjlmYg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2013-11-18T21:57:35Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2013-11-18T21:57:35Z"}, "message": "tree-ssa-threadupdate.c (redirection_data): Record two duplicated blocks instead of just one.\n\n\t* tree-ssa-threadupdate.c (redirection_data): Record two\n\tduplicated blocks instead of just one.\n\t(local_info): Explain why we don't create a template for the\n\tsecond duplicated block in a thread path.\n\t(create_block_for_threading): Accept argument indicating array\n\tindex into redirection_data to store its result.\n\t(lookup_redirection_data): Initialize both duplicate blocks.\n\t(ssa_create_duplicates): If a jump threading path needs multiple\n\tblocks duplicated, then duplicate them.\n\t(ssa_fix_duplicate_block_edges): Corresponding changes.\n\t(ssa_fixup_template_block, thread_single_edge):  Likewise.\n\nFrom-SVN: r204982", "tree": {"sha": "e8518d1b6b6c88f8ffcd34ddf7a3b4bd7aac6bd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e8518d1b6b6c88f8ffcd34ddf7a3b4bd7aac6bd2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c2af141b47cc2b19efad70e4c0be41eb82029fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c2af141b47cc2b19efad70e4c0be41eb82029fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c2af141b47cc2b19efad70e4c0be41eb82029fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c2af141b47cc2b19efad70e4c0be41eb82029fb/comments", "author": null, "committer": null, "parents": [{"sha": "fc78704b1a9664e8c7b0698fff189ac3f2511d9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc78704b1a9664e8c7b0698fff189ac3f2511d9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc78704b1a9664e8c7b0698fff189ac3f2511d9a"}], "stats": {"total": 124, "additions": 88, "deletions": 36}, "files": [{"sha": "8bbe5e79e49f2fd232e490a7f8ddff1df19af6a3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c2af141b47cc2b19efad70e4c0be41eb82029fb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c2af141b47cc2b19efad70e4c0be41eb82029fb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2c2af141b47cc2b19efad70e4c0be41eb82029fb", "patch": "@@ -1,3 +1,17 @@\n+2013-11-18  Jeff Law  <law@redhat.com>\n+\n+\t* tree-ssa-threadupdate.c (redirection_data): Record two\n+\tduplicated blocks instead of just one.\n+\t(local_info): Explain why we don't create a template for the\n+\tsecond duplicated block in a thread path.\n+\t(create_block_for_threading): Accept argument indicating array\n+\tindex into redirection_data to store its result.\n+\t(lookup_redirection_data): Initialize both duplicate blocks.\n+\t(ssa_create_duplicates): If a jump threading path needs multiple\n+\tblocks duplicated, then duplicate them.\n+\t(ssa_fix_duplicate_block_edges): Corresponding changes.\n+\t(ssa_fixup_template_block, thread_single_edge):  Likewise.\n+\t\n 2013-11-18  Marek Polacek  <polacek@redhat.com>\n \n \t* doc/invoke.texi: Extend -fsanitize=undefined documentation."}, {"sha": "97dc6cbce34a6584e9ba6651f84014f522504fde", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 74, "deletions": 36, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c2af141b47cc2b19efad70e4c0be41eb82029fb/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c2af141b47cc2b19efad70e4c0be41eb82029fb/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=2c2af141b47cc2b19efad70e4c0be41eb82029fb", "patch": "@@ -112,9 +112,20 @@ struct el\n \n struct redirection_data : typed_free_remove<redirection_data>\n {\n-  /* A duplicate of B with the trailing control statement removed and which\n-     targets a single successor of B.  */\n-  basic_block dup_block;\n+  /* We support wiring up two block duplicates in a jump threading path.\n+\n+     One is a normal block copy where we remove the control statement\n+     and wire up its single remaining outgoing edge to the thread path.\n+\n+     The other is a joiner block where we leave the control statement\n+     in place, but wire one of the outgoing edges to a thread path. \n+\n+     In theory we could have multiple block duplicates in a jump\n+     threading path, but I haven't tried that.\n+\n+     The duplicate blocks appear in this array in the same order in\n+     which they appear in the jump thread path.  */\n+  basic_block dup_blocks[2];\n \n   /* The jump threading path.  */\n   vec<jump_thread_edge *> *path;\n@@ -168,8 +179,11 @@ struct ssa_local_info_t\n   /* The current block we are working on.  */\n   basic_block bb;\n \n-  /* A template copy of BB with no outgoing edges or control statement that\n-     we use for creating copies.  */\n+  /* We only create a template block for the first duplicated block in a\n+     jump threading path as we may need many duplicates of that block.\n+\n+     The second duplicate block in a path is specific to that path.  Creating\n+     and sharing a template for that block is considerably more difficult.  */\n   basic_block template_block;\n \n   /* TRUE if we thread one or more jumps, FALSE otherwise.  */\n@@ -231,24 +245,27 @@ remove_ctrl_stmt_and_useless_edges (basic_block bb, basic_block dest_bb)\n     }\n }\n \n-/* Create a duplicate of BB.  Record the duplicate block in RD.  */\n+/* Create a duplicate of BB.  Record the duplicate block in an array\n+   indexed by COUNT stored in RD.  */\n \n static void\n-create_block_for_threading (basic_block bb, struct redirection_data *rd)\n+create_block_for_threading (basic_block bb,\n+\t\t\t    struct redirection_data *rd,\n+\t\t\t    unsigned int count)\n {\n   edge_iterator ei;\n   edge e;\n \n   /* We can use the generic block duplication code and simply remove\n      the stuff we do not need.  */\n-  rd->dup_block = duplicate_block (bb, NULL, NULL);\n+  rd->dup_blocks[count] = duplicate_block (bb, NULL, NULL);\n \n-  FOR_EACH_EDGE (e, ei, rd->dup_block->succs)\n+  FOR_EACH_EDGE (e, ei, rd->dup_blocks[count]->succs)\n     e->aux = NULL;\n \n   /* Zero out the profile, since the block is unreachable for now.  */\n-  rd->dup_block->frequency = 0;\n-  rd->dup_block->count = 0;\n+  rd->dup_blocks[count]->frequency = 0;\n+  rd->dup_blocks[count]->count = 0;\n }\n \n /* Main data structure to hold information for duplicates of BB.  */\n@@ -272,7 +289,8 @@ lookup_redirection_data (edge e, enum insert_option insert)\n      in the table.  */\n   elt = XNEW (struct redirection_data);\n   elt->path = path;\n-  elt->dup_block = NULL;\n+  elt->dup_blocks[0] = NULL;\n+  elt->dup_blocks[1] = NULL;\n   elt->incoming_edges = NULL;\n \n   slot = redirection_data.find_slot (elt, insert);\n@@ -420,11 +438,11 @@ ssa_fix_duplicate_block_edges (struct redirection_data *rd,\n \n       /* This updates the PHIs at the destination of the duplicate\n \t block.  */\n-      update_destination_phis (local_info->bb, rd->dup_block);\n+      update_destination_phis (local_info->bb, rd->dup_blocks[0]);\n \n       /* Find the edge from the duplicate block to the block we're\n \t threading through.  That's the edge we want to redirect.  */\n-      victim = find_edge (rd->dup_block, (*path)[1]->e->dest);\n+      victim = find_edge (rd->dup_blocks[0], (*path)[1]->e->dest);\n       e2 = redirect_edge_and_branch (victim, path->last ()->e->dest);\n       e2->count = path->last ()->e->count;\n \n@@ -436,8 +454,8 @@ ssa_fix_duplicate_block_edges (struct redirection_data *rd,\n     }\n   else\n     {\n-      remove_ctrl_stmt_and_useless_edges (rd->dup_block, NULL);\n-      create_edge_and_update_destination_phis (rd, rd->dup_block);\n+      remove_ctrl_stmt_and_useless_edges (rd->dup_blocks[0], NULL);\n+      create_edge_and_update_destination_phis (rd, rd->dup_blocks[0]);\n     }\n }\n /* Hash table traversal callback routine to create duplicate blocks.  */\n@@ -448,20 +466,40 @@ ssa_create_duplicates (struct redirection_data **slot,\n {\n   struct redirection_data *rd = *slot;\n \n+  /* The second duplicated block in a jump threading path is specific\n+     to the path.  So it gets stored in RD rather than in LOCAL_DATA. \n+\t\n+     Each time we're called, we have to look through the path and see\n+     if a second block needs to be duplicated. \n+\n+     Note the search starts with the third edge on the path.  The first\n+     edge is the incoming edge, the second edge always has its source\n+     duplicated.  Thus we start our search with the third edge.  */\n+  vec<jump_thread_edge *> *path = rd->path;\n+  for (unsigned int i = 2; i < path->length (); i++)\n+    {\n+      if ((*path)[i]->type == EDGE_COPY_SRC_BLOCK\n+\t  || (*path)[i]->type == EDGE_COPY_SRC_JOINER_BLOCK)\n+\t{\n+\t  create_block_for_threading ((*path)[i]->e->src, rd, 1);\n+\t  break;\n+\t}\n+    }\n+  \n   /* Create a template block if we have not done so already.  Otherwise\n      use the template to create a new block.  */\n   if (local_info->template_block == NULL)\n     {\n-      create_block_for_threading (local_info->bb, rd);\n-      local_info->template_block = rd->dup_block;\n+      create_block_for_threading ((*path)[1]->e->src, rd, 0);\n+      local_info->template_block = rd->dup_blocks[0];\n \n       /* We do not create any outgoing edges for the template.  We will\n \t take care of that in a later traversal.  That way we do not\n \t create edges that are going to just be deleted.  */\n     }\n   else\n     {\n-      create_block_for_threading (local_info->template_block, rd);\n+      create_block_for_threading (local_info->template_block, rd, 0);\n \n       /* Go ahead and wire up outgoing edges and update PHIs for the duplicate\n \t block.   */\n@@ -489,7 +527,7 @@ ssa_fixup_template_block (struct redirection_data **slot,\n      to keep its control statement and redirect an outgoing edge.\n      Else we want to remove the control statement & edges, then create\n      a new outgoing edge.  In both cases we may need to update PHIs.  */\n-  if (rd->dup_block && rd->dup_block == local_info->template_block)\n+  if (rd->dup_blocks[0] && rd->dup_blocks[0] == local_info->template_block)\n     {\n       ssa_fix_duplicate_block_edges (rd, local_info);\n       return 0;\n@@ -523,30 +561,30 @@ ssa_redirect_edges (struct redirection_data **slot,\n \n       thread_stats.num_threaded_edges++;\n \n-      if (rd->dup_block)\n+      if (rd->dup_blocks[0])\n \t{\n \t  edge e2;\n \n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file, \"  Threaded jump %d --> %d to %d\\n\",\n-\t\t     e->src->index, e->dest->index, rd->dup_block->index);\n+\t\t     e->src->index, e->dest->index, rd->dup_blocks[0]->index);\n \n-\t  rd->dup_block->count += e->count;\n+\t  rd->dup_blocks[0]->count += e->count;\n \n \t  /* Excessive jump threading may make frequencies large enough so\n \t     the computation overflows.  */\n-\t  if (rd->dup_block->frequency < BB_FREQ_MAX * 2)\n-\t    rd->dup_block->frequency += EDGE_FREQUENCY (e);\n+\t  if (rd->dup_blocks[0]->frequency < BB_FREQ_MAX * 2)\n+\t    rd->dup_blocks[0]->frequency += EDGE_FREQUENCY (e);\n \n \t  /* In the case of threading through a joiner block, the outgoing\n \t     edges from the duplicate block were updated when they were\n \t     redirected during ssa_fix_duplicate_block_edges.  */\n \t  if ((*path)[1]->type != EDGE_COPY_SRC_JOINER_BLOCK)\n-\t    EDGE_SUCC (rd->dup_block, 0)->count += e->count;\n+\t    EDGE_SUCC (rd->dup_blocks[0], 0)->count += e->count;\n \n \t  /* Redirect the incoming edge (possibly to the joiner block) to the\n \t     appropriate duplicate block.  */\n-\t  e2 = redirect_edge_and_branch (e, rd->dup_block);\n+\t  e2 = redirect_edge_and_branch (e, rd->dup_blocks[0]);\n \t  gcc_assert (e == e2);\n \t  flush_pending_stmts (e2);\n \t}\n@@ -827,21 +865,21 @@ thread_single_edge (edge e)\n   npath->safe_push (x);\n   rd.path = npath;\n \n-  create_block_for_threading (bb, &rd);\n-  remove_ctrl_stmt_and_useless_edges (rd.dup_block, NULL);\n-  create_edge_and_update_destination_phis (&rd, rd.dup_block);\n+  create_block_for_threading (bb, &rd, 0);\n+  remove_ctrl_stmt_and_useless_edges (rd.dup_blocks[0], NULL);\n+  create_edge_and_update_destination_phis (&rd, rd.dup_blocks[0]);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"  Threaded jump %d --> %d to %d\\n\",\n-\t     e->src->index, e->dest->index, rd.dup_block->index);\n+\t     e->src->index, e->dest->index, rd.dup_blocks[0]->index);\n \n-  rd.dup_block->count = e->count;\n-  rd.dup_block->frequency = EDGE_FREQUENCY (e);\n-  single_succ_edge (rd.dup_block)->count = e->count;\n-  redirect_edge_and_branch (e, rd.dup_block);\n+  rd.dup_blocks[0]->count = e->count;\n+  rd.dup_blocks[0]->frequency = EDGE_FREQUENCY (e);\n+  single_succ_edge (rd.dup_blocks[0])->count = e->count;\n+  redirect_edge_and_branch (e, rd.dup_blocks[0]);\n   flush_pending_stmts (e);\n \n-  return rd.dup_block;\n+  return rd.dup_blocks[0];\n }\n \n /* Callback for dfs_enumerate_from.  Returns true if BB is different"}]}