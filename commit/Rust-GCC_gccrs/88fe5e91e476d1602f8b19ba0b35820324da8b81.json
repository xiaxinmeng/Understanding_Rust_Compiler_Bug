{"sha": "88fe5e91e476d1602f8b19ba0b35820324da8b81", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODhmZTVlOTFlNDc2ZDE2MDJmOGIxOWJhMGIzNTgyMDMyNGRhOGI4MQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2014-05-14T22:09:26Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2014-05-14T22:09:26Z"}, "message": "sparc-protos.h (sparc_absnegfloat_split_legitimate): Delete.\n\n\t* config/sparc/sparc-protos.h (sparc_absnegfloat_split_legitimate):\n\tDelete.\n\t* config/sparc/sparc.c (sparc_absnegfloat_split_legitimate): Likewise.\n\t* config/sparc/sparc.md (fptype_ut699): New attribute.\n\t(in_branch_delay): Return false if -mfix-ut699 is specified and\n\tfptype_ut699 is set to single.\n\t(truncdfsf2): Add fptype_ut699 attribute.\n\t(fix_truncdfsi2): Likewise.\n\t(floatsisf2): Change fptype attribute.\n\t(fix_truncsfsi2): Likewise.\n\t(negtf2_notv9): Delete.\n\t(negtf2_v9): Likewise.\n\t(negtf2_hq): New instruction.\n\t(negtf2): New instruction and splitter.\n\t(negdf2_notv9): Rewrite.\n\t(abstf2_notv9): Delete.\n\t(abstf2_hq_v9): Likewise.\n\t(abstf2_v9): Likewise.\n\t(abstf2_hq): New instruction.\n\t(abstf2): New instruction and splitter.\n\t(absdf2_notv9): Rewrite.\n\nFrom-SVN: r210444", "tree": {"sha": "254cfc75b7944d8444fa7eec466ea33ce4485c7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/254cfc75b7944d8444fa7eec466ea33ce4485c7a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88fe5e91e476d1602f8b19ba0b35820324da8b81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88fe5e91e476d1602f8b19ba0b35820324da8b81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88fe5e91e476d1602f8b19ba0b35820324da8b81", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88fe5e91e476d1602f8b19ba0b35820324da8b81/comments", "author": null, "committer": null, "parents": [{"sha": "0263d678037179ced1f0543660743d33f7801b59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0263d678037179ced1f0543660743d33f7801b59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0263d678037179ced1f0543660743d33f7801b59"}], "stats": {"total": 332, "additions": 185, "deletions": 147}, "files": [{"sha": "8cbbc952d83d941f16db1cbc305501a981782455", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fe5e91e476d1602f8b19ba0b35820324da8b81/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fe5e91e476d1602f8b19ba0b35820324da8b81/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=88fe5e91e476d1602f8b19ba0b35820324da8b81", "patch": "@@ -1,3 +1,27 @@\n+2014-05-14  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* config/sparc/sparc-protos.h (sparc_absnegfloat_split_legitimate):\n+\tDelete.\n+\t* config/sparc/sparc.c (sparc_absnegfloat_split_legitimate): Likewise.\n+\t* config/sparc/sparc.md (fptype_ut699): New attribute.\n+\t(in_branch_delay): Return false if -mfix-ut699 is specified and\n+\tfptype_ut699 is set to single.\n+\t(truncdfsf2): Add fptype_ut699 attribute.\n+\t(fix_truncdfsi2): Likewise.\n+\t(floatsisf2): Change fptype attribute.\n+\t(fix_truncsfsi2): Likewise.\n+\t(negtf2_notv9): Delete.\n+\t(negtf2_v9): Likewise.\n+\t(negtf2_hq): New instruction.\n+\t(negtf2): New instruction and splitter.\n+\t(negdf2_notv9): Rewrite.\n+\t(abstf2_notv9): Delete.\n+\t(abstf2_hq_v9): Likewise.\n+\t(abstf2_v9): Likewise.\n+\t(abstf2_hq): New instruction.\n+\t(abstf2): New instruction and splitter.\n+\t(absdf2_notv9): Rewrite.\n+\n 2014-05-14  Cary Coutant  <ccoutant@google.com>\n \n         PR debug/61013"}, {"sha": "ee2091bb8e00246578c29f39c04a769d22d5fc32", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fe5e91e476d1602f8b19ba0b35820324da8b81/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fe5e91e476d1602f8b19ba0b35820324da8b81/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=88fe5e91e476d1602f8b19ba0b35820324da8b81", "patch": "@@ -69,7 +69,6 @@ extern bool sparc_expand_move (enum machine_mode, rtx *);\n extern void sparc_emit_set_symbolic_const64 (rtx, rtx, rtx);\n extern int sparc_splitdi_legitimate (rtx, rtx);\n extern int sparc_split_regreg_legitimate (rtx, rtx);\n-extern int sparc_absnegfloat_split_legitimate (rtx, rtx);\n extern const char *output_ubranch (rtx, rtx);\n extern const char *output_cbranch (rtx, rtx, int, int, int, rtx);\n extern const char *output_return (rtx);"}, {"sha": "4b84760ec251a638744798bbddd0cd3d1d02fe9e", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fe5e91e476d1602f8b19ba0b35820324da8b81/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fe5e91e476d1602f8b19ba0b35820324da8b81/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=88fe5e91e476d1602f8b19ba0b35820324da8b81", "patch": "@@ -8543,22 +8543,6 @@ sparc_split_regreg_legitimate (rtx reg1, rtx reg2)\n   return 0;\n }\n \n-/* Return 1 if x and y are some kind of REG and they refer to\n-   different hard registers.  This test is guaranteed to be\n-   run after reload.  */\n-\n-int\n-sparc_absnegfloat_split_legitimate (rtx x, rtx y)\n-{\n-  if (GET_CODE (x) != REG)\n-    return 0;\n-  if (GET_CODE (y) != REG)\n-    return 0;\n-  if (REGNO (x) == REGNO (y))\n-    return 0;\n-  return 1;\n-}\n-\n /* Return 1 if REGNO (reg1) is even and REGNO (reg1) == REGNO (reg2) - 1.\n    This makes them candidates for using ldd and std insns.\n "}, {"sha": "b6cd7f026855981f2517340d727a4114dffa1202", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 161, "deletions": 130, "changes": 291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fe5e91e476d1602f8b19ba0b35820324da8b81/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fe5e91e476d1602f8b19ba0b35820324da8b81/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=88fe5e91e476d1602f8b19ba0b35820324da8b81", "patch": "@@ -424,6 +424,10 @@\n (define_attr \"fptype\" \"single,double\"\n   (const_string \"single\"))\n \n+;; FP precision specific to the UT699.\n+(define_attr \"fptype_ut699\" \"none,single\"\n+  (const_string \"none\"))\n+\n ;; UltraSPARC-III integer load type.\n (define_attr \"us3load_type\" \"2cycle,3cycle\"\n   (const_string \"2cycle\"))\n@@ -464,7 +468,8 @@\n \t   (const_string \"false\")\n \t (and (eq_attr \"fix_ut699\" \"true\")\n \t      (and (eq_attr \"type\" \"fpload,fp,fpmove,fpmul,fpdivs,fpsqrts\")\n-\t\t   (eq_attr \"fptype\" \"single\")))\n+\t\t   (ior (eq_attr \"fptype\" \"single\")\n+\t\t        (eq_attr \"fptype_ut699\" \"single\"))))\n \t   (const_string \"false\")\n \t (eq_attr \"length\" \"1\")\n \t   (const_string \"true\")\n@@ -3455,7 +3460,8 @@\n   \"TARGET_FPU\"\n   \"fdtos\\t%1, %0\"\n   [(set_attr \"type\" \"fp\")\n-   (set_attr \"fptype\" \"double\")])\n+   (set_attr \"fptype\" \"double\")\n+   (set_attr \"fptype_ut699\" \"single\")])\n \n (define_expand \"trunctfsf2\"\n   [(set (match_operand:SF 0 \"register_operand\" \"\")\n@@ -3496,7 +3502,7 @@\n   \"TARGET_FPU\"\n   \"fitos\\t%1, %0\"\n   [(set_attr \"type\" \"fp\")\n-   (set_attr \"fptype\" \"double\")])\n+   (set_attr \"fptype\" \"single\")])\n \n (define_insn \"floatsidf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=e\")\n@@ -3583,15 +3589,16 @@\n   \"TARGET_FPU\"\n   \"fstoi\\t%1, %0\"\n   [(set_attr \"type\" \"fp\")\n-   (set_attr \"fptype\" \"double\")])\n+   (set_attr \"fptype\" \"single\")])\n \n (define_insn \"fix_truncdfsi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=f\")\n \t(fix:SI (fix:DF (match_operand:DF 1 \"register_operand\" \"e\"))))]\n   \"TARGET_FPU\"\n   \"fdtoi\\t%1, %0\"\n   [(set_attr \"type\" \"fp\")\n-   (set_attr \"fptype\" \"double\")])\n+   (set_attr \"fptype\" \"double\")\n+   (set_attr \"fptype_ut699\" \"single\")])\n \n (define_expand \"fix_trunctfsi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n@@ -5554,53 +5561,52 @@\n   [(set_attr \"type\" \"fpdivs\")])\n \n (define_expand \"negtf2\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"=e,e\")\n-\t(neg:TF (match_operand:TF 1 \"register_operand\" \"0,e\")))]\n+  [(set (match_operand:TF 0 \"register_operand\" \"\")\n+\t(neg:TF (match_operand:TF 1 \"register_operand\" \"\")))]\n   \"TARGET_FPU\"\n   \"\")\n \n-(define_insn_and_split \"*negtf2_notv9\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"=e,e\")\n-\t(neg:TF (match_operand:TF 1 \"register_operand\" \"0,e\")))]\n-  ; We don't use quad float insns here so we don't need TARGET_HARD_QUAD.\n-  \"TARGET_FPU\n-   && ! TARGET_V9\"\n-  \"@\n-  fnegs\\t%0, %0\n-  #\"\n-  \"&& reload_completed\n-   && sparc_absnegfloat_split_legitimate (operands[0], operands[1])\"\n-  [(set (match_dup 2) (neg:SF (match_dup 3)))\n-   (set (match_dup 4) (match_dup 5))\n-   (set (match_dup 6) (match_dup 7))]\n-  \"operands[2] = gen_rtx_raw_REG (SFmode, REGNO (operands[0]));\n-   operands[3] = gen_rtx_raw_REG (SFmode, REGNO (operands[1]));\n-   operands[4] = gen_rtx_raw_REG (SFmode, REGNO (operands[0]) + 1);\n-   operands[5] = gen_rtx_raw_REG (SFmode, REGNO (operands[1]) + 1);\n-   operands[6] = gen_rtx_raw_REG (DFmode, REGNO (operands[0]) + 2);\n-   operands[7] = gen_rtx_raw_REG (DFmode, REGNO (operands[1]) + 2);\"\n-  [(set_attr \"type\" \"fpmove,*\")\n-   (set_attr \"length\" \"*,2\")])\n-\n-(define_insn_and_split \"*negtf2_v9\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"=e,e\")\n-\t(neg:TF (match_operand:TF 1 \"register_operand\" \"0,e\")))]\n-  ; We don't use quad float insns here so we don't need TARGET_HARD_QUAD.\n-  \"TARGET_FPU && TARGET_V9\"\n-  \"@\n-  fnegd\\t%0, %0\n-  #\"\n-  \"&& reload_completed\n-   && sparc_absnegfloat_split_legitimate (operands[0], operands[1])\"\n-  [(set (match_dup 2) (neg:DF (match_dup 3)))\n-   (set (match_dup 4) (match_dup 5))]\n-  \"operands[2] = gen_rtx_raw_REG (DFmode, REGNO (operands[0]));\n-   operands[3] = gen_rtx_raw_REG (DFmode, REGNO (operands[1]));\n-   operands[4] = gen_rtx_raw_REG (DFmode, REGNO (operands[0]) + 2);\n-   operands[5] = gen_rtx_raw_REG (DFmode, REGNO (operands[1]) + 2);\"\n-  [(set_attr \"type\" \"fpmove,*\")\n-   (set_attr \"length\" \"*,2\")\n-   (set_attr \"fptype\" \"double\")])\n+(define_insn \"*negtf2_hq\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n+\t(neg:TF (match_operand:TF 1 \"register_operand\" \"e\")))]\n+  \"TARGET_FPU && TARGET_HARD_QUAD\"\n+  \"fnegq\\t%1, %0\"\n+  [(set_attr \"type\" \"fpmove\")])\n+\n+(define_insn_and_split \"*negtf2\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n+\t(neg:TF (match_operand:TF 1 \"register_operand\" \"e\")))]\n+  \"TARGET_FPU && !TARGET_HARD_QUAD\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(clobber (const_int 0))]\n+{\n+  rtx set_dest = operands[0];\n+  rtx set_src = operands[1];\n+  rtx dest1, dest2;\n+  rtx src1, src2;\n+\n+  dest1 = gen_df_reg (set_dest, 0);\n+  dest2 = gen_df_reg (set_dest, 1);\n+  src1 = gen_df_reg (set_src, 0);\n+  src2 = gen_df_reg (set_src, 1);\n+\n+  /* Now emit using the real source and destination we found, swapping\n+     the order if we detect overlap.  */\n+  if (reg_overlap_mentioned_p (dest1, src2))\n+    {\n+      emit_insn (gen_movdf (dest2, src2));\n+      emit_insn (gen_negdf2 (dest1, src1));\n+    }\n+  else\n+    {\n+      emit_insn (gen_negdf2 (dest1, src1));\n+      if (REGNO (dest2) != REGNO (src2))\n+\temit_insn (gen_movdf (dest2, src2));\n+    }\n+  DONE;\n+}\n+  [(set_attr \"length\" \"2\")])\n \n (define_expand \"negdf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"\")\n@@ -5609,22 +5615,39 @@\n   \"\")\n \n (define_insn_and_split \"*negdf2_notv9\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=e,e\")\n-\t(neg:DF (match_operand:DF 1 \"register_operand\" \"0,e\")))]\n-  \"TARGET_FPU && ! TARGET_V9\"\n-  \"@\n-  fnegs\\t%0, %0\n-  #\"\n-  \"&& reload_completed\n-   && sparc_absnegfloat_split_legitimate (operands[0], operands[1])\"\n-  [(set (match_dup 2) (neg:SF (match_dup 3)))\n-   (set (match_dup 4) (match_dup 5))]\n-  \"operands[2] = gen_rtx_raw_REG (SFmode, REGNO (operands[0]));\n-   operands[3] = gen_rtx_raw_REG (SFmode, REGNO (operands[1]));\n-   operands[4] = gen_rtx_raw_REG (SFmode, REGNO (operands[0]) + 1);\n-   operands[5] = gen_rtx_raw_REG (SFmode, REGNO (operands[1]) + 1);\"\n-  [(set_attr \"type\" \"fpmove,*\")\n-   (set_attr \"length\" \"*,2\")])\n+  [(set (match_operand:DF 0 \"register_operand\" \"=e\")\n+\t(neg:DF (match_operand:DF 1 \"register_operand\" \"e\")))]\n+  \"TARGET_FPU && !TARGET_V9\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(clobber (const_int 0))]\n+{\n+  rtx set_dest = operands[0];\n+  rtx set_src = operands[1];\n+  rtx dest1, dest2;\n+  rtx src1, src2;\n+\n+  dest1 = gen_highpart (SFmode, set_dest);\n+  dest2 = gen_lowpart (SFmode, set_dest);\n+  src1 = gen_highpart (SFmode, set_src);\n+  src2 = gen_lowpart (SFmode, set_src);\n+\n+  /* Now emit using the real source and destination we found, swapping\n+     the order if we detect overlap.  */\n+  if (reg_overlap_mentioned_p (dest1, src2))\n+    {\n+      emit_insn (gen_movsf (dest2, src2));\n+      emit_insn (gen_negsf2 (dest1, src1));\n+    }\n+  else\n+    {\n+      emit_insn (gen_negsf2 (dest1, src1));\n+      if (REGNO (dest2) != REGNO (src2))\n+\temit_insn (gen_movsf (dest2, src2));\n+    }\n+  DONE;\n+}\n+  [(set_attr \"length\" \"2\")])\n \n (define_insn \"*negdf2_v9\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=e\")\n@@ -5647,56 +5670,47 @@\n   \"TARGET_FPU\"\n   \"\")\n \n-(define_insn_and_split \"*abstf2_notv9\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"=e,e\")\n-\t(abs:TF (match_operand:TF 1 \"register_operand\" \"0,e\")))]\n-  ; We don't use quad float insns here so we don't need TARGET_HARD_QUAD.\n-  \"TARGET_FPU && ! TARGET_V9\"\n-  \"@\n-  fabss\\t%0, %0\n-  #\"\n-  \"&& reload_completed\n-   && sparc_absnegfloat_split_legitimate (operands[0], operands[1])\"\n-  [(set (match_dup 2) (abs:SF (match_dup 3)))\n-   (set (match_dup 4) (match_dup 5))\n-   (set (match_dup 6) (match_dup 7))]\n-  \"operands[2] = gen_rtx_raw_REG (SFmode, REGNO (operands[0]));\n-   operands[3] = gen_rtx_raw_REG (SFmode, REGNO (operands[1]));\n-   operands[4] = gen_rtx_raw_REG (SFmode, REGNO (operands[0]) + 1);\n-   operands[5] = gen_rtx_raw_REG (SFmode, REGNO (operands[1]) + 1);\n-   operands[6] = gen_rtx_raw_REG (DFmode, REGNO (operands[0]) + 2);\n-   operands[7] = gen_rtx_raw_REG (DFmode, REGNO (operands[1]) + 2);\"\n-  [(set_attr \"type\" \"fpmove,*\")\n-   (set_attr \"length\" \"*,2\")])\n-\n-(define_insn \"*abstf2_hq_v9\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"=e,e\")\n-\t(abs:TF (match_operand:TF 1 \"register_operand\" \"0,e\")))]\n-  \"TARGET_FPU && TARGET_V9 && TARGET_HARD_QUAD\"\n-  \"@\n-  fabsd\\t%0, %0\n-  fabsq\\t%1, %0\"\n-  [(set_attr \"type\" \"fpmove\")\n-   (set_attr \"fptype\" \"double,*\")])\n+(define_insn \"*abstf2_hq\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n+\t(abs:TF (match_operand:TF 1 \"register_operand\" \"e\")))]\n+  \"TARGET_FPU && TARGET_HARD_QUAD\"\n+  \"fabsq\\t%1, %0\"\n+  [(set_attr \"type\" \"fpmove\")])\n \n-(define_insn_and_split \"*abstf2_v9\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"=e,e\")\n-\t(abs:TF (match_operand:TF 1 \"register_operand\" \"0,e\")))]\n-  \"TARGET_FPU && TARGET_V9 && !TARGET_HARD_QUAD\"\n-  \"@\n-  fabsd\\t%0, %0\n-  #\"\n-  \"&& reload_completed\n-   && sparc_absnegfloat_split_legitimate (operands[0], operands[1])\"\n-  [(set (match_dup 2) (abs:DF (match_dup 3)))\n-   (set (match_dup 4) (match_dup 5))]\n-  \"operands[2] = gen_rtx_raw_REG (DFmode, REGNO (operands[0]));\n-   operands[3] = gen_rtx_raw_REG (DFmode, REGNO (operands[1]));\n-   operands[4] = gen_rtx_raw_REG (DFmode, REGNO (operands[0]) + 2);\n-   operands[5] = gen_rtx_raw_REG (DFmode, REGNO (operands[1]) + 2);\"\n-  [(set_attr \"type\" \"fpmove,*\")\n-   (set_attr \"length\" \"*,2\")\n-   (set_attr \"fptype\" \"double,*\")])\n+(define_insn_and_split \"*abstf2\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n+\t(abs:TF (match_operand:TF 1 \"register_operand\" \"e\")))]\n+  \"TARGET_FPU && !TARGET_HARD_QUAD\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(clobber (const_int 0))]\n+{\n+  rtx set_dest = operands[0];\n+  rtx set_src = operands[1];\n+  rtx dest1, dest2;\n+  rtx src1, src2;\n+\n+  dest1 = gen_df_reg (set_dest, 0);\n+  dest2 = gen_df_reg (set_dest, 1);\n+  src1 = gen_df_reg (set_src, 0);\n+  src2 = gen_df_reg (set_src, 1);\n+\n+  /* Now emit using the real source and destination we found, swapping\n+     the order if we detect overlap.  */\n+  if (reg_overlap_mentioned_p (dest1, src2))\n+    {\n+      emit_insn (gen_movdf (dest2, src2));\n+      emit_insn (gen_absdf2 (dest1, src1));\n+    }\n+  else\n+    {\n+      emit_insn (gen_absdf2 (dest1, src1));\n+      if (REGNO (dest2) != REGNO (src2))\n+\temit_insn (gen_movdf (dest2, src2));\n+    }\n+  DONE;\n+}\n+  [(set_attr \"length\" \"2\")])\n \n (define_expand \"absdf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"\")\n@@ -5705,22 +5719,39 @@\n   \"\")\n \n (define_insn_and_split \"*absdf2_notv9\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=e,e\")\n-\t(abs:DF (match_operand:DF 1 \"register_operand\" \"0,e\")))]\n-  \"TARGET_FPU && ! TARGET_V9\"\n-  \"@\n-  fabss\\t%0, %0\n-  #\"\n-  \"&& reload_completed\n-   && sparc_absnegfloat_split_legitimate (operands[0], operands[1])\"\n-  [(set (match_dup 2) (abs:SF (match_dup 3)))\n-   (set (match_dup 4) (match_dup 5))]\n-  \"operands[2] = gen_rtx_raw_REG (SFmode, REGNO (operands[0]));\n-   operands[3] = gen_rtx_raw_REG (SFmode, REGNO (operands[1]));\n-   operands[4] = gen_rtx_raw_REG (SFmode, REGNO (operands[0]) + 1);\n-   operands[5] = gen_rtx_raw_REG (SFmode, REGNO (operands[1]) + 1);\"\n-  [(set_attr \"type\" \"fpmove,*\")\n-   (set_attr \"length\" \"*,2\")])\n+  [(set (match_operand:DF 0 \"register_operand\" \"=e\")\n+\t(abs:DF (match_operand:DF 1 \"register_operand\" \"e\")))]\n+  \"TARGET_FPU && !TARGET_V9\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(clobber (const_int 0))]\n+{\n+  rtx set_dest = operands[0];\n+  rtx set_src = operands[1];\n+  rtx dest1, dest2;\n+  rtx src1, src2;\n+\n+  dest1 = gen_highpart (SFmode, set_dest);\n+  dest2 = gen_lowpart (SFmode, set_dest);\n+  src1 = gen_highpart (SFmode, set_src);\n+  src2 = gen_lowpart (SFmode, set_src);\n+\n+  /* Now emit using the real source and destination we found, swapping\n+     the order if we detect overlap.  */\n+  if (reg_overlap_mentioned_p (dest1, src2))\n+    {\n+      emit_insn (gen_movsf (dest2, src2));\n+      emit_insn (gen_abssf2 (dest1, src1));\n+    }\n+  else\n+    {\n+      emit_insn (gen_abssf2 (dest1, src1));\n+      if (REGNO (dest2) != REGNO (src2))\n+\temit_insn (gen_movsf (dest2, src2));\n+    }\n+  DONE;\n+}\n+  [(set_attr \"length\" \"2\")])\n \n (define_insn \"*absdf2_v9\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=e\")"}]}