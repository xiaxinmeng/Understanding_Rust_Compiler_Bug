{"sha": "ce3039af7dc478d4ac6d0fdeda3d1c3e0f97c943", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2UzMDM5YWY3ZGM0NzhkNGFjNmQwZmRlZGEzZDFjM2UwZjk3Yzk0Mw==", "commit": {"author": {"name": "Jerry Quinn", "email": "jlquinn@optonline.net", "date": "2003-02-11T21:55:49Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2003-02-11T21:55:49Z"}, "message": "locale_facets.h (__num_base): Add _S_atoms_out.\n\n\n2003-02-11 Jerry Quinn  <jlquinn@optonline.net>\n           Benjamin Kosnik  <benjamin@redhat.com>\n\n\t* include/bits/locale_facets.h (__num_base): Add _S_atoms_out.\n\tAdd indexes into this array.\n\t(__num_base::_S_atoms): To _S_atoms_in.\n\t(num_put::_M_insert): Rename to _M_pad.\n\t(num_put::_M_convert_int): Adjust remove __mod, __modl arguments.\n\t(num_put::_M_widen_int): Rename to _M_group_int.\n\t(num_put::_M_widen_float): Rename to _M_group_float.\n\t* include/bits/locale_facets.tcc (__int_to_char): New inline\n\tfunction and adapter functions.\n\t(num_put::_M_group_int): Streamline.\n\t(num_put::_M_group_float): Streamline.\n\t(num_put::_M_convert_int): Remove unused parameter names. Choose\n\tlarge enough buffer for text.  Use __int_to_char instead of\n\t__convert_from_v.  Formatted text is now at the end of the buffer.\n\t(num_put::_M_convert_float): Preliminary fixups.\n\t* src/locale-inst.cc (__convert_from_v<long long>): Add ifdef.\n\t(__int_to_char<unsigned long long>): Same.\n\t(__int_to_char<char, unsigned long>): New.\n\t(__int_to_char<char, unsigned long long>): New.\n\t(__int_to_char<wchar_t, unsigned long>): New.\n\t(__int_to_char<wchar_t, unsigned long long>): New.\n\nCo-Authored-By: Benjamin Kosnik <bkoz@redhat.com>\n\nFrom-SVN: r62731", "tree": {"sha": "ae05f85f062db887de7dda075837f8e2c8f428a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae05f85f062db887de7dda075837f8e2c8f428a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce3039af7dc478d4ac6d0fdeda3d1c3e0f97c943", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce3039af7dc478d4ac6d0fdeda3d1c3e0f97c943", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce3039af7dc478d4ac6d0fdeda3d1c3e0f97c943", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce3039af7dc478d4ac6d0fdeda3d1c3e0f97c943/comments", "author": {"login": "jlquinn", "id": 826841, "node_id": "MDQ6VXNlcjgyNjg0MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/826841?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jlquinn", "html_url": "https://github.com/jlquinn", "followers_url": "https://api.github.com/users/jlquinn/followers", "following_url": "https://api.github.com/users/jlquinn/following{/other_user}", "gists_url": "https://api.github.com/users/jlquinn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jlquinn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jlquinn/subscriptions", "organizations_url": "https://api.github.com/users/jlquinn/orgs", "repos_url": "https://api.github.com/users/jlquinn/repos", "events_url": "https://api.github.com/users/jlquinn/events{/privacy}", "received_events_url": "https://api.github.com/users/jlquinn/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a3259be8e3a8e67a512227abb5d059e114369c4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3259be8e3a8e67a512227abb5d059e114369c4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3259be8e3a8e67a512227abb5d059e114369c4d"}], "stats": {"total": 645, "additions": 425, "deletions": 220}, "files": [{"sha": "b85048d439195647b88f4e2cbcf6a891d01054e8", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce3039af7dc478d4ac6d0fdeda3d1c3e0f97c943/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce3039af7dc478d4ac6d0fdeda3d1c3e0f97c943/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=ce3039af7dc478d4ac6d0fdeda3d1c3e0f97c943", "patch": "@@ -1,3 +1,28 @@\n+2003-02-11 Jerry Quinn  <jlquinn@optonline.net>\n+           Benjamin Kosnik  <benjamin@redhat.com>\n+\t\n+\t* include/bits/locale_facets.h (__num_base): Add _S_atoms_out.\n+\tAdd indexes into this array.\n+\t(__num_base::_S_atoms): To _S_atoms_in.\n+\t(num_put::_M_insert): Rename to _M_pad.\n+\t(num_put::_M_convert_int): Adjust remove __mod, __modl arguments.\n+\t(num_put::_M_widen_int): Rename to _M_group_int.\n+\t(num_put::_M_widen_float): Rename to _M_group_float.\t\n+\t* include/bits/locale_facets.tcc (__int_to_char): New inline\n+\tfunction and adapter functions.\n+\t(num_put::_M_group_int): Streamline.\n+\t(num_put::_M_group_float): Streamline.\t\n+\t(num_put::_M_convert_int): Remove unused parameter names. Choose\n+\tlarge enough buffer for text.  Use __int_to_char instead of\n+\t__convert_from_v.  Formatted text is now at the end of the buffer.\n+\t(num_put::_M_convert_float): Preliminary fixups.\n+\t* src/locale-inst.cc (__convert_from_v<long long>): Add ifdef.\n+\t(__int_to_char<unsigned long long>): Same.\n+\t(__int_to_char<char, unsigned long>): New.\n+\t(__int_to_char<char, unsigned long long>): New.\n+\t(__int_to_char<wchar_t, unsigned long>): New.\n+\t(__int_to_char<wchar_t, unsigned long long>): New.\n+\t\n 2003-02-11  Scott Snyder  <snyder@fnal.gov>\n \n \tPR libstdc++/9659"}, {"sha": "1feb960c2cfbbb24911dde57376a8a3a56412fee", "filename": "libstdc++-v3/include/bits/locale_facets.h", "status": "modified", "additions": 38, "deletions": 14, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce3039af7dc478d4ac6d0fdeda3d1c3e0f97c943/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce3039af7dc478d4ac6d0fdeda3d1c3e0f97c943/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h?ref=ce3039af7dc478d4ac6d0fdeda3d1c3e0f97c943", "patch": "@@ -527,14 +527,37 @@ namespace std\n   // 22.2.1.5  Template class codecvt\n   #include <bits/codecvt.h>\n \n-\n   // 22.2.2  The numeric category.\n   class __num_base \n   {\n+  public:\n+    // NB: Code depends on the order of _M_atoms_out elements.\n+    // Below are the indices into _M_atoms_out.\n+    enum \n+      {  \n+        _S_minus, \n+        _S_plus, \n+        _S_x, \n+        _S_X, \n+        _S_digits,\n+        _S_digits_end = _S_digits + 16,\n+        _S_udigits = _S_digits_end,  \n+        _S_udigits_end = _S_udigits + 16,\n+        _S_e = _S_digits + 14, // For scientific notation, 'e'\n+        _S_E = _S_udigits + 14 // For scientific notation, 'E'\n+      };\n+    \n+    // A list of valid numeric literals for output. \n+    // This array contains the chars after having been passed through\n+    // the current locale's ctype<_CharT>.widen().\n+    // For the standard \"C\" locale, this is \n+    // \"-+xX0123456789abcdef0123456789ABCDEF\".\n+    static const char* _S_atoms_out;\n+\n   protected:\n     // String literal of acceptable (narrow) input, for num_get.\n     // \"0123456789eEabcdfABCDF\"\n-    static const char _S_atoms[];\n+    static const char* _S_atoms_in;\n \n     enum \n     {  \n@@ -827,7 +850,6 @@ namespace std\n       // Types:\n       typedef _CharT       \tchar_type;\n       typedef _OutIter     \titer_type;\n-\n       static locale::id\t\tid;\n \n       explicit \n@@ -877,22 +899,24 @@ namespace std\n         _M_convert_float(iter_type, ios_base& __io, char_type __fill, \n \t\t\t char __mod, _ValueT __v) const;\n \n+      void\n+      _M_group_float(const string& __grouping, char_type __sep, \n+\t\t     const char_type* __p, char_type* __new, char_type* __cs,\n+\t\t     int& __len) const;\n+\n       template<typename _ValueT>\n         iter_type\n         _M_convert_int(iter_type, ios_base& __io, char_type __fill, \n-\t\t       char __mod, char __modl, _ValueT __v) const;\n-\n-      iter_type\n-      _M_widen_float(iter_type, ios_base& __io, char_type __fill, char* __cs, \n-\t\t     int __len) const;\n+\t\t       _ValueT __v) const;\n \n-      iter_type\n-      _M_widen_int(iter_type, ios_base& __io, char_type __fill, char* __cs, \n-\t\t   int __len) const;\n+      void\n+      _M_group_int(const string& __grouping, char_type __sep, \n+\t\t   ios_base& __io, char_type* __new, char_type* __cs, \n+\t\t   int& __len) const;\n \n-      iter_type\n-      _M_insert(iter_type, ios_base& __io, char_type __fill, \n-\t\tconst char_type* __ws, int __len) const;\n+      void\n+      _M_pad(char_type __fill, streamsize __w, ios_base& __io, \n+\t     char_type* __new, const char_type* __cs, int& __len) const;\n \n       virtual \n       ~num_put() { };"}, {"sha": "c8eaa2e5b15863cae14abeb47cd97534137c5845", "filename": "libstdc++-v3/include/bits/locale_facets.tcc", "status": "modified", "additions": 317, "deletions": 190, "changes": 507, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce3039af7dc478d4ac6d0fdeda3d1c3e0f97c943/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce3039af7dc478d4ac6d0fdeda3d1c3e0f97c943/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc?ref=ce3039af7dc478d4ac6d0fdeda3d1c3e0f97c943", "patch": "@@ -113,7 +113,7 @@ namespace std\n \t}\n \n       // Next, strip leading zeros.\n-      const char_type __zero = __ctype.widen(_S_atoms[_M_zero]);\n+      const char_type __zero = __ctype.widen(_S_atoms_in[_M_zero]);\n       bool __found_zero = false;\n       while (__traits_type::eq(__c, __zero) && __beg != __end)\n \t{\n@@ -122,14 +122,14 @@ namespace std\n \t}\n       if (__found_zero)\n \t{\n-\t  __xtrc += _S_atoms[_M_zero];\n+\t  __xtrc += _S_atoms_in[_M_zero];\n \t  ++__pos;\n \t}\n \n       // Only need acceptable digits for floating point numbers.\n       const size_t __len = _M_E - _M_zero + 1;\n       char_type  __watoms[__len];\n-      __ctype.widen(_S_atoms, _S_atoms + __len, __watoms);\n+      __ctype.widen(_S_atoms_in, _S_atoms_in + __len, __watoms);\n       bool __found_dec = false;\n       bool __found_sci = false;\n       const char_type __dec = __np.decimal_point();\n@@ -150,7 +150,7 @@ namespace std\n \t    {\n \t      // Try first for acceptable digit; record it if found.\n \t      ++__pos;\n-\t      __xtrc += _S_atoms[__p - __watoms];\n+\t      __xtrc += _S_atoms_in[__p - __watoms];\n \t      ++__sep_pos;\n \t      __c = *(++__beg);\n \t    }\n@@ -261,7 +261,7 @@ namespace std\n \t}\n \n       // Next, strip leading zeros and check required digits for base formats.\n-      const char_type __zero = __ctype.widen(_S_atoms[_M_zero]);\n+      const char_type __zero = __ctype.widen(_S_atoms_in[_M_zero]);\n       const char_type __x = __ctype.widen('x');\n       const char_type __X = __ctype.widen('X');\n       if (__base == 10)\n@@ -274,7 +274,7 @@ namespace std\n \t    }\n \t  if (__found_zero)\n \t    {\n-\t      __xtrc += _S_atoms[_M_zero];\n+\t      __xtrc += _S_atoms_in[_M_zero];\n \t      ++__pos;\n \t      if (__basefield == 0)\n \t\t{\t      \n@@ -296,7 +296,7 @@ namespace std\n \t{\n \t  if (__traits_type::eq(__c, __zero) && __beg != __end)\n \t    {\n-\t      __xtrc += _S_atoms[_M_zero];\n+\t      __xtrc += _S_atoms_in[_M_zero];\n \t      ++__pos;\n \t      __c = *(++__beg); \n \t      if ((__traits_type::eq(__c, __x) || __traits_type::eq(__c, __X))\n@@ -319,7 +319,7 @@ namespace std\n \n       // Extract.\n       char_type __watoms[_M_size];\n-      __ctype.widen(_S_atoms, _S_atoms + __len, __watoms);\n+      __ctype.widen(_S_atoms_in, _S_atoms_in + __len, __watoms);\n       string __found_grouping;\n       const string __grouping = __np.grouping();\n       bool __check_grouping = __grouping.size();\n@@ -333,7 +333,7 @@ namespace std\n           if (__p && !__traits_type::eq(__c, char_type()))\n \t    {\n \t      // Try first for acceptable digit; record it if found.\n-\t      __xtrc += _S_atoms[__p - __watoms];\n+\t      __xtrc += _S_atoms_in[__p - __watoms];\n \t      ++__pos;\n \t      ++__sep_pos;\n \t      __c = *(++__beg);\n@@ -606,14 +606,256 @@ namespace std\n       return __beg;\n     }\n \n-  // The following code uses snprintf (or sprintf(), when _GLIBCPP_USE_C99\n-  // is not defined) to convert floating point values for insertion into a\n-  // stream.  An optimization would be to replace them with code that works\n-  // directly on a wide buffer and then use __pad to do the padding.\n-  // It would be good to replace them anyway to gain back the efficiency\n-  // that C++ provides by knowing up front the type of the values to insert.\n-  // Also, sprintf is dangerous since may lead to accidental buffer overruns.\n-  // This implementation follows the C++ standard fairly directly as\n+  // For use by integer and floating-point types after they have been\n+  // converted into a char_type string.\n+  template<typename _CharT, typename _OutIter>\n+    void\n+    num_put<_CharT, _OutIter>::\n+    _M_pad(_CharT __fill, streamsize __w, ios_base& __io, \n+\t   _CharT* __new, const _CharT* __cs, int& __len) const\n+    {\n+      // [22.2.2.2.2] Stage 3.\n+      // If necessary, pad.\n+      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new, __cs, \n+\t\t\t\t\t\t  __w, __len, true);\n+      __len = static_cast<int>(__w);\n+    }\n+\n+  // Forwarding functions to peel signed from unsigned integer types.\n+  template<typename _CharT>\n+    inline int\n+    __int_to_char(_CharT* __out, const int __size, long __v,\n+\t\t       const _CharT* __lit, ios_base::fmtflags __flags)\n+    {\n+      unsigned long __ul = static_cast<unsigned long>(__v);\n+      bool __neg = false;\n+      if (__v < 0) \n+\t{\n+\t  __ul = -__ul;\n+\t  __neg = true;\n+\t}\n+      return __int_to_char(__out, __size, __ul, __lit, __flags, __neg); \n+    }\n+\n+  template<typename _CharT>\n+    inline int\n+    __int_to_char(_CharT* __out, const int __size, unsigned long __v,\n+\t\t       const _CharT* __lit, ios_base::fmtflags __flags)\n+    { return __int_to_char(__out, __size, __v, __lit, __flags, false); }\n+\n+#ifdef _GLIBCPP_USE_LONG_LONG\n+  template<typename _CharT>\n+    inline int\n+    __int_to_char(_CharT* __out, const int __size, long long __v,\n+\t\t       const _CharT* __lit, ios_base::fmtflags __flags)\n+    { \n+      unsigned long long __ull = static_cast<unsigned long long>(__v);\n+      bool __neg = false;\n+      if (__v < 0) \n+\t{\n+\t  __ull = -__ull;\n+\t  __neg = true;\n+\t}\n+      return __int_to_char(__out, __size, __ull, __lit, __flags, __neg); \n+    }\n+\n+  template<typename _CharT>\n+    inline int\n+    __int_to_char(_CharT* __out, const int __size, unsigned long long __v,\n+\t\t       const _CharT* __lit, ios_base::fmtflags __flags)\n+    { return __int_to_char(__out, __size, __v, __lit, __flags, false); }\n+#endif\n+      \n+  template<typename _CharT, typename _ValueT>\n+    int\n+    __int_to_char(_CharT* __out, const int __size, _ValueT __v,\n+\t\t  const _CharT* __lit, ios_base::fmtflags __flags, bool __neg)\n+    {\n+      // Don't write base if already 0.\n+      const bool __showbase = (__flags & ios_base::showbase) && __v;\n+      const ios_base::fmtflags __basefield = __flags & ios_base::basefield;\n+      _CharT* __buf = __out + __size - 1;\n+      _CharT* __bufend = __out + __size;\n+\n+      if (__builtin_expect(__basefield == ios_base::oct, false))\n+\t{\n+\t  // Octal.\n+\t  do \n+\t    {\n+\t      *__buf-- = __lit[(__v & 0x7) + __num_base::_S_digits];\n+\t      __v >>= 3;\n+\t    } \n+\t  while (__v != 0);\n+\t  if (__showbase)\n+\t    *__buf-- = __lit[__num_base::_S_digits];\n+\t}\n+      else if (__builtin_expect(__basefield == ios_base::hex, false))\n+\t{\n+\t  // Hex.\n+\t  const bool __uppercase = __flags & ios_base::uppercase;\n+\t  int __case_offset = __uppercase\n+\t                      ? __num_base::_S_udigits : __num_base::_S_digits;\n+\t  do \n+\t    {\n+\t      *__buf-- = __lit[(__v & 0xf) + __case_offset];\n+\t      __v >>= 4;\n+\t    } \n+\t  while (__v != 0);\n+\t  if (__showbase)\n+\t    {\n+\t      // 'x' or 'X'\n+\t      *__buf-- = __lit[__num_base::_S_x + __uppercase];\n+\t      // '0'\n+\t      *__buf-- = __lit[__num_base::_S_digits];\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  // Decimal.\n+\t  do \n+\t    {\n+\t      *__buf-- = __lit[(__v % 10) + __num_base::_S_digits];\n+\t      __v /= 10;\n+\t    } \n+\t  while (__v != 0);\n+\t  if (__neg)\n+\t    *__buf-- = __lit[__num_base::_S_minus];\n+\t  else if (__flags & ios_base::showpos)\n+\t    *__buf-- = __lit[__num_base::_S_plus];\n+\t}\n+      int __ret = __bufend - __buf - 1;\n+      return __ret;\n+    }\n+\n+  template<typename _CharT, typename _OutIter>\n+    void\n+    num_put<_CharT, _OutIter>::\n+    _M_group_int(const string& __grouping, _CharT __sep, ios_base& __io, \n+\t\t _CharT* __new, _CharT* __cs, int& __len) const\n+    {\n+      // By itself __add_grouping cannot deal correctly with __ws when\n+      // ios::showbase is set and ios_base::oct || ios_base::hex.\n+      // Therefore we take care \"by hand\" of the initial 0, 0x or 0X.\n+      // However, remember that the latter do not occur if the number\n+      // printed is '0' (__len == 1).\n+      streamsize __off = 0;\n+      const ios_base::fmtflags __basefield = __io.flags() \n+\t                                     & ios_base::basefield;\n+      if ((__io.flags() & ios_base::showbase) && __len > 1)\n+\tif (__basefield == ios_base::oct)\n+\t  {\n+\t    __off = 1;\n+\t    *__new = *__cs;\n+\t  }\n+\telse if (__basefield == ios_base::hex)\n+\t  {\n+\t    __off = 2;\n+\t    *__new = *__cs;\n+\t    *(__new + 1) = *(__cs + 1);\n+\t  }\n+      _CharT* __p;\n+      __p = __add_grouping(__new + __off, __sep, \n+\t\t\t   __grouping.c_str(),\n+\t\t\t   __grouping.c_str() + __grouping.size(),\n+\t\t\t   __cs + __off, __cs + __len);\n+      __len = __p - __new;\n+    }\n+\n+  template<typename _CharT, typename _OutIter>\n+    template<typename _ValueT>\n+      _OutIter\n+      num_put<_CharT, _OutIter>::\n+      _M_convert_int(_OutIter __s, ios_base& __io, _CharT __fill, \n+\t\t     _ValueT __v) const\n+      {\n+\t// Buildup list of digits given the current ctype.\n+\t_CharT __lit[_S_udigits_end];\n+\tconst locale __loc = __io.getloc();\n+\tif (__builtin_expect(has_facet< ctype<_CharT> >(__loc), true))\n+\t  {\n+\t    const ctype<_CharT>& __ct = use_facet< ctype<_CharT> >(__loc);\n+\t    __ct.widen(_S_atoms_out, _S_atoms_out + _S_udigits_end, __lit);\n+\t  }\n+\n+\t// Long enough to hold hex, dec, and octal representations.\n+\tint __ilen = 4 * sizeof(_ValueT);\n+\t_CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) \n+\t\t\t\t\t\t\t     * __ilen));\n+\n+\t// [22.2.2.2.2] Stage 1, numeric conversion to character.\n+\t// Result is returned right-justified in the buffer.\n+\tint __len;\n+\t__len = __int_to_char(&__cs[0], __ilen, __v, __lit, __io.flags());\n+\t__cs = __cs + __ilen - __len;\n+\t\n+\t// Add grouping, if necessary. \n+\t_CharT* __cs2;\n+\tconst numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);\n+\tconst string __grouping = __np.grouping();\n+\tif (__grouping.size())\n+\t  {\n+\t    // Grouping can add (almost) as many separators as the\n+\t    // number of digits, but no more.\n+\t    __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) \n+\t\t\t\t\t\t\t  * __len * 2));\n+\t    _M_group_int(__grouping, __np.thousands_sep(), __io, \n+\t\t\t __cs2, __cs, __len);\n+\t    __cs = __cs2;\n+\t  }\n+\t\n+\t// Pad.\n+\t_CharT* __cs3;\n+\tstreamsize __w = __io.width();\n+\tif (__w > static_cast<streamsize>(__len))\n+\t  {\n+\t    __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) \n+\t\t\t\t\t\t\t  * __w));\n+\t    _M_pad(__fill, __w, __io, __cs3, __cs, __len);\n+\t    __cs = __cs3;\n+\t  }\n+\t__io.width(0);\n+\n+\t// [22.2.2.2.2] Stage 4.\n+\t// Write resulting, fully-formatted string to output iterator.\n+\treturn __write(__s, __cs, __len);\n+      } \n+\n+  template<typename _CharT, typename _OutIter>\n+    void\n+    num_put<_CharT, _OutIter>::\n+    _M_group_float(const string& __grouping, _CharT __sep, const _CharT* __p, \n+\t\t   _CharT* __new, _CharT* __cs, int& __len) const\n+    {\n+#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n+      //282. What types does numpunct grouping refer to?\n+      // Add grouping, if necessary. \n+      _CharT* __p2;\n+      int __declen = __p ? __p - __cs : __len;\n+      __p2 = __add_grouping(__new, __sep, \n+\t\t\t    __grouping.c_str(),\n+\t\t\t    __grouping.c_str() + __grouping.size(),\n+\t\t\t    __cs, __cs + __declen);\n+      \n+      // Tack on decimal part.\n+      int __newlen = __p2 - __new;\n+      if (__p)\n+\t{\n+\t  char_traits<_CharT>::copy(__p2, __p, __len - __declen);\n+\t  __newlen += __len - __declen;\n+\t}    \n+      __len = __newlen;\n+#endif\n+    }\n+\n+  // The following code uses snprintf (or sprintf(), when\n+  // _GLIBCPP_USE_C99 is not defined) to convert floating point values\n+  // for insertion into a stream.  An optimization would be to replace\n+  // them with code that works directly on a wide buffer and then use\n+  // __pad to do the padding.  It would be good to replace them anyway\n+  // to gain back the efficiency that C++ provides by knowing up front\n+  // the type of the values to insert.  Also, sprintf is dangerous\n+  // since may lead to accidental buffer overruns.  This\n+  // implementation follows the C++ standard fairly directly as\n   // outlined in 22.2.2.2 [lib.locale.num.put]\n   template<typename _CharT, typename _OutIter>\n     template<typename _ValueT>\n@@ -622,30 +864,30 @@ namespace std\n       _M_convert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,\n \t\t       _ValueT __v) const\n       {\n-\t// Note: digits10 is rounded down: we need to add 1 to ensure\n-\t// we get the full available precision.\n-\t// Then, in general, one more 1 needs to be added since, when the\n-\t// %{g,G} conversion specifiers are chosen inside _S_format_float, the\n-\t// precision field is \"the maximum number of significant digits\", *not*\n-\t// the \"number of digits to appear after the decimal point\", as happens\n-\t// for %{e,E,f,F} (C99, 7.19.6.1,4).\n+\t// Note: digits10 is rounded down: add 1 to ensure the maximum\n+\t// available precision.  Then, in general, one more 1 needs to\n+\t// be added since, when the %{g,G} conversion specifiers are\n+\t// chosen inside _S_format_float, the precision field is \"the\n+\t// maximum number of significant digits\", *not* the \"number of\n+\t// digits to appear after the decimal point\", as happens for\n+\t// %{e,E,f,F} (C99, 7.19.6.1,4).\n \tconst int __max_digits = numeric_limits<_ValueT>::digits10 + 2;\n-\tstreamsize __prec = __io.precision();\n \n+\t// Use default precision if out of range.\n+\tstreamsize __prec = __io.precision();\n \tif (__prec > static_cast<streamsize>(__max_digits))\n \t  __prec = static_cast<streamsize>(__max_digits);\n \telse if (__prec < static_cast<streamsize>(0))\n-\t  // Default precision.\n \t  __prec = static_cast<streamsize>(6);\n \n+\t// [22.2.2.2.2] Stage 1, numeric conversion to character.\n+\tint __len;\n \t// Long enough for the max format spec.\n \tchar __fbuf[16];\n \n-\t// [22.2.2.2.2] Stage 1, numeric conversion to character.\n-\tint __len;\n #ifdef _GLIBCPP_USE_C99\n-\t// First try a buffer perhaps big enough (for sure sufficient for\n-\t// non-ios_base::fixed outputs)\n+\t// First try a buffer perhaps big enough (for sure sufficient\n+\t// for non-ios_base::fixed outputs)\n \tint __cs_size = __max_digits * 3;\n \tchar* __cs = static_cast<char*>(__builtin_alloca(__cs_size));\n \n@@ -665,6 +907,7 @@ namespace std\n \t// Consider the possibility of long ios_base::fixed outputs\n \tconst bool __fixed = __io.flags() & ios_base::fixed;\n \tconst int __max_exp = numeric_limits<_ValueT>::max_exponent10;\n+\n \t// ios_base::fixed outputs may need up to __max_exp+1 chars\n \t// for the integer part + up to __max_digits chars for the\n \t// fractional part + 3 chars for sign, decimal point, '\\0'. On\n@@ -677,181 +920,53 @@ namespace std\n \t_S_format_float(__io, __fbuf, __mod);\n \t__len = __convert_from_v(__cs, 0, __fbuf, __v, _S_c_locale, __prec);\n #endif\n-\treturn _M_widen_float(__s, __io, __fill, __cs, __len);\n-      }\n \n-  template<typename _CharT, typename _OutIter>\n-    template<typename _ValueT>\n-      _OutIter\n-      num_put<_CharT, _OutIter>::\n-      _M_convert_int(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,\n-\t\t     char __modl, _ValueT __v) const\n-      {\n-\t// [22.2.2.2.2] Stage 1, numeric conversion to character.\n-\n-\t// Long enough for the max format spec.\n-\tchar __fbuf[16];\n-\t_S_format_int(__io, __fbuf, __mod, __modl);\n-#ifdef _GLIBCPP_USE_C99\n-\t// First try a buffer perhaps big enough.\n-\tint __cs_size = 64;\n-\tchar* __cs = static_cast<char*>(__builtin_alloca(__cs_size));\n-\tint __len = __convert_from_v(__cs, __cs_size, __fbuf, __v, \n-\t\t\t\t     _S_c_locale);\n-\t// If the buffer was not large enough, try again with the correct size.\n-\tif (__len >= __cs_size)\n-\t  {\n-\t    __cs_size = __len + 1;\n-\t    __cs = static_cast<char*>(__builtin_alloca(__cs_size));\n-\t    __len = __convert_from_v(__cs, __cs_size, __fbuf, __v, \n-\t\t\t\t     _S_c_locale);\n-\t  }\n-#else\n-\t// Leave room for \"+/-,\" \"0x,\" and commas. This size is\n-\t// arbitrary, but should be largely sufficient.\n-\tchar __cs[128];\n-\tint __len = __convert_from_v(__cs, 0, __fbuf, __v, _S_c_locale);\n-#endif\n-\treturn _M_widen_int(__s, __io, __fill, __cs, __len);\n-      }\n-\n-  template<typename _CharT, typename _OutIter>\n-    _OutIter\n-    num_put<_CharT, _OutIter>::\n-    _M_widen_float(_OutIter __s, ios_base& __io, _CharT __fill, char* __cs, \n-\t\t   int __len) const\n-    {\n-      typedef char_traits<_CharT> \t\t__traits_type;\n       // [22.2.2.2.2] Stage 2, convert to char_type, using correct\n       // numpunct.decimal_point() values for '.' and adding grouping.\n       const locale __loc = __io.getloc();\n       const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n+      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);\n+\n       _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) \n \t\t\t\t\t\t\t   * __len));\n-      // Grouping can add (almost) as many separators as the number of\n-      // digits, but no more.\n-      _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) \n-\t\t\t \t\t\t\t    * __len * 2));\n       __ctype.widen(__cs, __cs + __len, __ws);\n       \n       // Replace decimal point.\n+      const _CharT __cdec = __ctype.widen('.');\n+      const _CharT __dec = __np.decimal_point();\n       const _CharT* __p;\n-      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);\n-      if (__p = __traits_type::find(__ws, __len, __ctype.widen('.')))\n-\t__ws[__p - __ws] = __np.decimal_point();\n-\n-#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n-//282. What types does numpunct grouping refer to?\n-      // Add grouping, if necessary. \n-      const string __grouping = __np.grouping();\n-      if (__grouping.size())\n-\t{\n-\t  _CharT* __p2;\n-\t  int __declen = __p ? __p - __ws : __len;\n-\t  __p2 = __add_grouping(__ws2, __np.thousands_sep(), \n-\t\t\t\t__grouping.c_str(),\n-\t\t\t\t__grouping.c_str() + __grouping.size(),\n-\t\t\t\t__ws, __ws + __declen);\n-\t  int __newlen = __p2 - __ws2;\n-\t\n-\t  // Tack on decimal part.\n-\t  if (__p)\n-\t    {\n-\t      __traits_type::copy(__p2, __p, __len - __declen);\n-\t      __newlen += __len - __declen;\n-\t    }    \n-\n-\t  // Switch strings, establish correct new length.\n-\t  __ws = __ws2;\n-\t  __len = __newlen;\n-\t}\n-#endif\n-      return _M_insert(__s, __io, __fill, __ws, __len);\n-    }\n-\n-  template<typename _CharT, typename _OutIter>\n-    _OutIter\n-    num_put<_CharT, _OutIter>::\n-    _M_widen_int(_OutIter __s, ios_base& __io, _CharT __fill, char* __cs, \n-\t\t int __len) const\n-    {\n-      // [22.2.2.2.2] Stage 2, convert to char_type, using correct\n-      // numpunct.decimal_point() values for '.' and adding grouping.\n-      const locale __loc = __io.getloc();\n-      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n-      _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) \n-\t\t\t\t\t\t\t   * __len));\n-      // Grouping can add (almost) as many separators as the number of\n-      // digits, but no more.\n-      _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) \n-\t\t\t\t\t\t\t    * __len * 2));\n-      __ctype.widen(__cs, __cs + __len, __ws);\n+      if (__p = char_traits<_CharT>::find(__ws, __len, __cdec))\n+\t__ws[__p - __ws] = __dec;\n \n       // Add grouping, if necessary. \n-      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);\n+      _CharT* __ws2;\n       const string __grouping = __np.grouping();\n       if (__grouping.size())\n \t{\n-\t  // By itself __add_grouping cannot deal correctly with __ws when\n-\t  // ios::showbase is set and ios_base::oct || ios_base::hex.\n-\t  // Therefore we take care \"by hand\" of the initial 0, 0x or 0X.\n-\t  // However, remember that the latter do not occur if the number\n-\t  // printed is '0' (__len == 1).\n-\t  streamsize __off = 0;\n-\t  const ios_base::fmtflags __basefield = __io.flags() \n-\t    \t\t\t\t\t & ios_base::basefield;\n-\t  if ((__io.flags() & ios_base::showbase) && __len > 1)\n-\t    if (__basefield == ios_base::oct)\n-\t      {\n-\t\t__off = 1;\n-\t\t*__ws2 = *__ws;\n-\t      }\n-\t    else if (__basefield == ios_base::hex)\n-\t      {\n-\t\t__off = 2;\n-\t\t*__ws2 = *__ws;\n-\t\t*(__ws2 + 1) = *(__ws + 1);\n-\t      }\n-\t  _CharT* __p;\n-\t  __p = __add_grouping(__ws2 + __off, __np.thousands_sep(), \n-\t\t\t       __grouping.c_str(),\n-\t\t\t       __grouping.c_str() + __grouping.size(),\n-\t\t\t       __ws + __off, __ws + __len);\n-\t  __len = __p - __ws2;\n-\t  // Switch strings.\n-\t  __ws = __ws2;\n+\t    // Grouping can add (almost) as many separators as the\n+\t    // number of digits, but no more.\n+\t    __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) \n+\t\t\t\t\t\t\t  * __len * 2));\n+\t    _M_group_float(__grouping, __np.thousands_sep(), __p, \n+\t\t\t   __ws2, __ws, __len);\n+\t    __ws = __ws2;\n \t}\n-      return _M_insert(__s, __io, __fill, __ws, __len);\n-    }\n \n-  // For use by integer and floating-point types after they have been\n-  // converted into a char_type string.\n-  template<typename _CharT, typename _OutIter>\n-    _OutIter\n-    num_put<_CharT, _OutIter>::\n-    _M_insert(_OutIter __s, ios_base& __io, _CharT __fill, const _CharT* __ws, \n-\t      int __len) const\n-    {\n-      typedef char_traits<_CharT> \t\t__traits_type;\n-      // [22.2.2.2.2] Stage 3.\n-      // If necessary, pad.\n+      // Pad.\n+      _CharT* __ws3;\n       streamsize __w = __io.width();\n-      _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) \n-\t\t\t\t\t\t\t    * __w));\n       if (__w > static_cast<streamsize>(__len))\n \t{\n-\t  __pad<_CharT, __traits_type>::_S_pad(__io, __fill, __ws2, __ws, \n-\t\t\t\t\t       __w, __len, true);\n-\t  __len = static_cast<int>(__w);\n-\t  // Switch strings.\n-\t  __ws = __ws2;\n+\t  __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __w));\n+\t  _M_pad(__fill, __w, __io, __ws3, __ws, __len);\n+\t  __ws = __ws3;\n \t}\n       __io.width(0);\n-\n+      \n       // [22.2.2.2.2] Stage 4.\n       // Write resulting, fully-formatted string to output iterator.\n       return __write(__s, __ws, __len);\n-    }\n+      }\n \n   template<typename _CharT, typename _OutIter>\n     _OutIter\n@@ -862,19 +977,32 @@ namespace std\n       if ((__flags & ios_base::boolalpha) == 0)\n         {\n           unsigned long __uv = __v;\n-          __s = _M_convert_int(__s, __io, __fill, 'u', char(), __uv);\n+          __s = _M_convert_int(__s, __io, __fill, __uv);\n         }\n       else\n         {\n-\t  typedef basic_string<_CharT> __string_type;\n           locale __loc = __io.getloc();\n \t  const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc); \n+\t  typedef basic_string<_CharT> \t__string_type;\n \t  __string_type __name;\n           if (__v)\n \t    __name = __np.truename();\n           else\n \t    __name = __np.falsename();\n-\t  __s = _M_insert(__s, __io, __fill, __name.c_str(), __name.size()); \n+\n+\t  const _CharT* __cs = __name.c_str();\n+\t  int __len = __name.size();\n+\t  _CharT* __cs3;\n+\t  streamsize __w = __io.width();\n+\t  if (__w > static_cast<streamsize>(__len))\n+\t    {\n+\t      __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) \n+\t\t\t\t\t\t\t    * __w));\n+\t      _M_pad(__fill, __w, __io, __cs3, __cs, __len);\n+\t      __cs = __cs3;\n+\t    }\n+\t  __io.width(0);\n+\t  __s = __write(__s, __cs, __len);\n \t}\n       return __s;\n     }\n@@ -883,28 +1011,28 @@ namespace std\n     _OutIter\n     num_put<_CharT, _OutIter>::\n     do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const\n-    { return _M_convert_int(__s, __io, __fill, 'd', char(), __v); }\n+    { return _M_convert_int(__s, __io, __fill, __v); }\n \n   template<typename _CharT, typename _OutIter>\n     _OutIter\n     num_put<_CharT, _OutIter>::\n     do_put(iter_type __s, ios_base& __io, char_type __fill,\n            unsigned long __v) const\n-    { return _M_convert_int(__s, __io, __fill, 'u', char(), __v); }\n+    { return _M_convert_int(__s, __io, __fill, __v); }\n \n #ifdef _GLIBCPP_USE_LONG_LONG\n   template<typename _CharT, typename _OutIter>\n     _OutIter\n     num_put<_CharT, _OutIter>::\n     do_put(iter_type __s, ios_base& __b, char_type __fill, long long __v) const\n-    { return _M_convert_int(__s, __b, __fill, 'd', 'l', __v); }\n+    { return _M_convert_int(__s, __b, __fill, __v); }\n \n   template<typename _CharT, typename _OutIter>\n     _OutIter\n     num_put<_CharT, _OutIter>::\n     do_put(iter_type __s, ios_base& __io, char_type __fill,\n            unsigned long long __v) const\n-    { return _M_convert_int(__s, __io, __fill, 'u', 'l', __v); }\n+    { return _M_convert_int(__s, __io, __fill, __v); }\n #endif\n \n   template<typename _CharT, typename _OutIter>\n@@ -932,7 +1060,7 @@ namespace std\n       __io.flags(__flags & __fmt | (ios_base::hex | ios_base::showbase));\n       try \n \t{\n-\t  __s = _M_convert_int(__s, __io, __fill, 'u', char(),\n+\t  __s = _M_convert_int(__s, __io, __fill, \n \t\t\t       reinterpret_cast<unsigned long>(__v));\n \t  __io.flags(__flags);\n \t}\n@@ -1622,7 +1750,7 @@ namespace std\n \tif (__c == __names[__i1][0])\n \t  __matches[__nmatches++] = __i1;\n       \n-      while(__nmatches > 1)\n+      while (__nmatches > 1)\n \t{\n \t  // Find smallest matching string.\n \t  size_t __minlen = 10;\n@@ -1847,8 +1975,7 @@ namespace std\n \t\t}\n \t      else\n \t\t__format = __c;\n-\t      __s = this->do_put(__s, __io, char_type(), __tm, __format, \n-\t\t\t\t __mod);\n+\t      __s = this->do_put(__s, __io, _CharT(), __tm, __format, __mod);\n \t    }\n \t  else\n \t    {"}, {"sha": "954e51709986f8b48b2877af3cbbbd54fbb719de", "filename": "libstdc++-v3/src/locale-inst.cc", "status": "modified", "additions": 43, "deletions": 15, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce3039af7dc478d4ac6d0fdeda3d1c3e0f97c943/libstdc%2B%2B-v3%2Fsrc%2Flocale-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce3039af7dc478d4ac6d0fdeda3d1c3e0f97c943/libstdc%2B%2B-v3%2Fsrc%2Flocale-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flocale-inst.cc?ref=ce3039af7dc478d4ac6d0fdeda3d1c3e0f97c943", "patch": "@@ -1,6 +1,6 @@\n // Locale support -*- C++ -*-\n \n-// Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+// Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -64,26 +64,26 @@ namespace std\n   template\n     ostreambuf_iterator<char>\n     num_put<char, ostreambuf_iterator<char> >::\n-    _M_convert_int(ostreambuf_iterator<char>, ios_base&, char, char, char, \n+    _M_convert_int(ostreambuf_iterator<char>, ios_base&, char, \n \t\t   long) const;\n \n   template\n     ostreambuf_iterator<char>\n     num_put<char, ostreambuf_iterator<char> >::\n-    _M_convert_int(ostreambuf_iterator<char>, ios_base&, char, char, char, \n+    _M_convert_int(ostreambuf_iterator<char>, ios_base&, char, \n \t\t   unsigned long) const;\n \n #ifdef _GLIBCPP_USE_LONG_LONG\n   template\n     ostreambuf_iterator<char>\n     num_put<char, ostreambuf_iterator<char> >::\n-    _M_convert_int(ostreambuf_iterator<char>, ios_base&, char, char, char, \n+    _M_convert_int(ostreambuf_iterator<char>, ios_base&, char, \n \t\t   long long) const;\n \n   template\n     ostreambuf_iterator<char>\n     num_put<char, ostreambuf_iterator<char> >::\n-    _M_convert_int(ostreambuf_iterator<char>, ios_base&, char, char, char,\n+    _M_convert_int(ostreambuf_iterator<char>, ios_base&, char, \n \t\t   unsigned long long) const;\n #endif\n \n@@ -97,8 +97,8 @@ namespace std\n     ostreambuf_iterator<char>\n     num_put<char, ostreambuf_iterator<char> >::\n     _M_convert_float(ostreambuf_iterator<char>, ios_base&, char, char, \n-\t\t    long double) const;\n-\n+\t\t     long double) const;\n+  \n #ifdef _GLIBCPP_USE_WCHAR_T\n   template class numpunct<wchar_t>;\n   template class numpunct_byname<wchar_t>;\n@@ -108,27 +108,27 @@ namespace std\n   template\n     ostreambuf_iterator<wchar_t>\n     num_put<wchar_t, ostreambuf_iterator<wchar_t> >::\n-    _M_convert_int(ostreambuf_iterator<wchar_t>, ios_base&, wchar_t, char, \n-\t\t   char, long) const;\n+    _M_convert_int(ostreambuf_iterator<wchar_t>, ios_base&, wchar_t, \n+\t\t   long) const;\n \n   template\n     ostreambuf_iterator<wchar_t>\n     num_put<wchar_t, ostreambuf_iterator<wchar_t> >::\n-    _M_convert_int(ostreambuf_iterator<wchar_t>, ios_base&, wchar_t, char, \n-\t\t   char, unsigned long) const;\n+    _M_convert_int(ostreambuf_iterator<wchar_t>, ios_base&, wchar_t, \n+\t\t   unsigned long) const;\n \n #ifdef _GLIBCPP_USE_LONG_LONG\n   template\n     ostreambuf_iterator<wchar_t>\n     num_put<wchar_t, ostreambuf_iterator<wchar_t> >::\n-    _M_convert_int(ostreambuf_iterator<wchar_t>, ios_base&, wchar_t, char, \n-\t\t   char, long long) const;\n+    _M_convert_int(ostreambuf_iterator<wchar_t>, ios_base&, wchar_t,\n+\t\t   long long) const;\n \n   template\n     ostreambuf_iterator<wchar_t>\n     num_put<wchar_t, ostreambuf_iterator<wchar_t> >::\n-    _M_convert_int(ostreambuf_iterator<wchar_t>, ios_base&, wchar_t, char, \n-\t\t   char, unsigned long long) const;\n+    _M_convert_int(ostreambuf_iterator<wchar_t>, ios_base&, wchar_t,\n+\t\t   unsigned long long) const;\n #endif\n \n   template\n@@ -451,6 +451,7 @@ namespace std\n     __convert_from_v(char*, const int, const char*, unsigned long, \n \t\t     const __c_locale&, int);\n \n+#ifdef _GLIBCPP_USE_LONG_LONG\n   template\n     int\n     __convert_from_v(char*, const int, const char*, long long, \n@@ -460,4 +461,31 @@ namespace std\n     int\n     __convert_from_v(char*, const int, const char*, unsigned long long, \n \t\t     const __c_locale&, int);\n+#endif\n+\n+  template\n+    int\n+    __int_to_char(char*, const int, unsigned long, const char*, \n+\t\t  ios_base::fmtflags, bool);\n+\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  template\n+    int\n+    __int_to_char(wchar_t*, const int, unsigned long, const wchar_t*, \n+\t\t  ios_base::fmtflags, bool);\n+#endif\n+\n+#ifdef _GLIBCPP_USE_LONG_LONG\n+  template\n+    int\n+    __int_to_char(char*, const int, unsigned long long, const char*, \n+\t\t  ios_base::fmtflags, bool);\n+\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  template\n+    int\n+    __int_to_char(wchar_t*, const int, unsigned long long, const wchar_t*,\n+\t\t  ios_base::fmtflags, bool);\n+#endif\n+#endif\n } // namespace std"}, {"sha": "e27f7690c2160ea229056da4e965bbdf5c0bd3b2", "filename": "libstdc++-v3/src/locale.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce3039af7dc478d4ac6d0fdeda3d1c3e0f97c943/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce3039af7dc478d4ac6d0fdeda3d1c3e0f97c943/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc?ref=ce3039af7dc478d4ac6d0fdeda3d1c3e0f97c943", "patch": "@@ -503,7 +503,8 @@ namespace std\n   const money_base::pattern \n   money_base::_S_default_pattern =  { {symbol, sign, none, value} };\n \n-  const char __num_base::_S_atoms[] = \"0123456789eEabcdfABCDF\";\n+  const char* __num_base::_S_atoms_in = \"0123456789eEabcdfABCDF\";\n+  const char* __num_base::_S_atoms_out =\"-+xX0123456789abcdef0123456789ABCDEF\";\n \n   // _GLIBCPP_RESOLVE_LIB_DEFECTS\n   // According to the resolution of DR 231, about 22.2.2.2.2, p11,"}]}