{"sha": "4fc2610a8301198367c590759a578b03167a1868", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGZjMjYxMGE4MzAxMTk4MzY3YzU5MDc1OWE1NzhiMDMxNjdhMTg2OA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-01-17T18:37:39Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-03T10:01:49Z"}, "message": "[Ada] Fix for missing calls to Adjust primitive with nested generics\n\n2020-06-03  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* sem_ch12.adb (Denotes_Previous_Actual): Delete.\n\t(Check_Generic_Actuals): Do not special case array types whose\n\tcomponent type denotes a previous actual.  Do not special case\n\taccess types whose base type is private.\n\t(Check_Private_View): Remove code dealing with secondary types.\n\tDo not switch the views of an array because of its component.\n\t(Copy_Generic_Node): Add special handling for a comparison\n\toperator on array types.\n\t(Instantiate_Type): Do not special case access types whose\n\tdesignated type is private.\n\t(Set_Global_Type): Do not special case array types whose\n\tcomponent type is private.", "tree": {"sha": "5ceea2da69602a29712db0ccc6767162adc32ef9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ceea2da69602a29712db0ccc6767162adc32ef9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4fc2610a8301198367c590759a578b03167a1868", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fc2610a8301198367c590759a578b03167a1868", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fc2610a8301198367c590759a578b03167a1868", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fc2610a8301198367c590759a578b03167a1868/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48b185bd015b72e43736e79887afe31296ae5fe2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48b185bd015b72e43736e79887afe31296ae5fe2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48b185bd015b72e43736e79887afe31296ae5fe2"}], "stats": {"total": 207, "additions": 81, "deletions": 126}, "files": [{"sha": "32a6333b49665cde5eb849e7919e25c5b5fda2b4", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 81, "deletions": 126, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fc2610a8301198367c590759a578b03167a1868/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fc2610a8301198367c590759a578b03167a1868/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=4fc2610a8301198367c590759a578b03167a1868", "patch": "@@ -6794,48 +6794,6 @@ package body Sem_Ch12 is\n       E      : Entity_Id;\n       Astype : Entity_Id;\n \n-      function Denotes_Previous_Actual (Typ : Entity_Id) return Boolean;\n-      --  For a formal that is an array type, the component type is often a\n-      --  previous formal in the same unit. The privacy status of the component\n-      --  type will have been examined earlier in the traversal of the\n-      --  corresponding actuals, and this status should not be modified for\n-      --  the array (sub)type itself. However, if the base type of the array\n-      --  (sub)type is private, its full view must be restored in the body to\n-      --  be consistent with subsequent index subtypes, etc.\n-      --\n-      --  To detect this case we have to rescan the list of formals, which is\n-      --  usually short enough to ignore the resulting inefficiency.\n-\n-      -----------------------------\n-      -- Denotes_Previous_Actual --\n-      -----------------------------\n-\n-      function Denotes_Previous_Actual (Typ : Entity_Id) return Boolean is\n-         Prev : Entity_Id;\n-\n-      begin\n-         Prev := First_Entity (Instance);\n-         while Present (Prev) loop\n-            if Is_Type (Prev)\n-              and then Nkind (Parent (Prev)) = N_Subtype_Declaration\n-              and then Is_Entity_Name (Subtype_Indication (Parent (Prev)))\n-              and then Entity (Subtype_Indication (Parent (Prev))) = Typ\n-            then\n-               return True;\n-\n-            elsif Prev = E then\n-               return False;\n-\n-            else\n-               Next_Entity (Prev);\n-            end if;\n-         end loop;\n-\n-         return False;\n-      end Denotes_Previous_Actual;\n-\n-   --  Start of processing for Check_Generic_Actuals\n-\n    begin\n       E := First_Entity (Instance);\n       while Present (E) loop\n@@ -6844,14 +6802,7 @@ package body Sem_Ch12 is\n            and then Scope (Etype (E)) /= Instance\n            and then Is_Entity_Name (Subtype_Indication (Parent (E)))\n          then\n-            if Is_Array_Type (E)\n-              and then not Is_Private_Type (Etype (E))\n-              and then Denotes_Previous_Actual (Component_Type (E))\n-            then\n-               null;\n-            else\n-               Check_Private_View (Subtype_Indication (Parent (E)));\n-            end if;\n+            Check_Private_View (Subtype_Indication (Parent (E)));\n \n             Set_Is_Generic_Actual_Type (E);\n \n@@ -6886,15 +6837,6 @@ package body Sem_Ch12 is\n \n             if Is_Discrete_Or_Fixed_Point_Type (E) then\n                Set_RM_Size (E, RM_Size (Astype));\n-\n-            --  In nested instances, the base type of an access actual may\n-            --  itself be private, and need to be exchanged.\n-\n-            elsif Is_Access_Type (E)\n-              and then Is_Private_Type (Etype (E))\n-            then\n-               Check_Private_View\n-                 (New_Occurrence_Of (Etype (E), Sloc (Instance)));\n             end if;\n \n          elsif Ekind (E) = E_Package then\n@@ -7451,63 +7393,6 @@ package body Sem_Ch12 is\n             Prepend_Elmt (T, Exchanged_Views);\n             Exchange_Declarations (Etype (Get_Associated_Node (N)));\n \n-         --  For composite types with inconsistent representation exchange\n-         --  component types accordingly.\n-\n-         elsif Is_Access_Type (T)\n-           and then Is_Private_Type (Designated_Type (T))\n-           and then not Has_Private_View (N)\n-           and then Present (Full_View (Designated_Type (T)))\n-         then\n-            Switch_View (Designated_Type (T));\n-\n-         elsif Is_Array_Type (T) then\n-            if Is_Private_Type (Component_Type (T))\n-              and then not Has_Private_View (N)\n-              and then Present (Full_View (Component_Type (T)))\n-            then\n-               Switch_View (Component_Type (T));\n-            end if;\n-\n-            --  The normal exchange mechanism relies on the setting of a\n-            --  flag on the reference in the generic. However, an additional\n-            --  mechanism is needed for types that are not explicitly\n-            --  mentioned in the generic, but may be needed in expanded code\n-            --  in the instance. This includes component types of arrays and\n-            --  designated types of access types. This processing must also\n-            --  include the index types of arrays which we take care of here.\n-\n-            declare\n-               Indx : Node_Id;\n-               Typ  : Entity_Id;\n-\n-            begin\n-               Indx := First_Index (T);\n-               while Present (Indx) loop\n-                  Typ := Base_Type (Etype (Indx));\n-\n-                  if Is_Private_Type (Typ)\n-                    and then Present (Full_View (Typ))\n-                  then\n-                     Switch_View (Typ);\n-                  end if;\n-\n-                  Next_Index (Indx);\n-               end loop;\n-            end;\n-\n-         --  The following case does not test Has_Private_View (N) so it may\n-         --  end up switching views when they are not supposed to be switched.\n-         --  This might be in keeping with Set_Global_Type setting the flag\n-         --  for an array type even if it is not private ???\n-\n-         elsif Is_Private_Type (T)\n-           and then Present (Full_View (T))\n-           and then Is_Array_Type (Full_View (T))\n-           and then Is_Private_Type (Component_Type (Full_View (T)))\n-         then\n-            Switch_View (T);\n-\n          --  Finally, a non-private subtype may have a private base type, which\n          --  must be exchanged for consistency. This can happen when a package\n          --  body is instantiated, when the scope stack is empty but in fact\n@@ -7911,6 +7796,85 @@ package body Sem_Ch12 is\n                      Set_Entity (New_N, Entity (Assoc));\n                      Check_Private_View (N);\n \n+                     --  Here we deal with a very peculiar case for which the\n+                     --  Has_Private_View mechanism is not sufficient, because\n+                     --  the reference to the type is implicit in the tree,\n+                     --  that is to say, it's not referenced from a node but\n+                     --  only from another type, namely through Component_Type.\n+\n+                     --    package P is\n+\n+                     --      type Pt is private;\n+\n+                     --      generic\n+                     --        type Ft is array (Positive range <>) of Pt;\n+                     --      package G is\n+                     --        procedure Check (F1, F2 : Ft; Lt : Boolean);\n+                     --      end G;\n+\n+                     --    private\n+                     --      type Pt is new Boolean;\n+                     --    end P;\n+\n+                     --    package body P is\n+                     --      package body G is\n+                     --        procedure Check (F1, F2 : Ft; Lt : Boolean) is\n+                     --        begin\n+                     --          if (F1 < F2) /= Lt then\n+                     --            null;\n+                     --          end if;\n+                     --        end Check;\n+                     --      end G;\n+                     --    end P;\n+\n+                     --    type Arr is array (Positive range <>) of P.Pt;\n+\n+                     --    package Inst is new P.G (Arr);\n+\n+                     --  Pt is a global type for the generic package G and it\n+                     --  is not referenced in its body, but only as component\n+                     --  type of Ft, which is a local type. This means that no\n+                     --  references to Pt or Ft are seen during the copy of the\n+                     --  body, the only reference to Pt being seen is when the\n+                     --  actuals are checked by Check_Generic_Actuals, but Pt\n+                     --  is still private at this point. In the end, the views\n+                     --  of Pt are not switched in the body and, therefore, the\n+                     --  array comparison is rejected because the component is\n+                     --  still private.\n+\n+                     --  Adding e.g. a dummy variable of type Pt in the body is\n+                     --  sufficient to make everything work, so we generate an\n+                     --  artificial reference to Pt on the fly and thus force\n+                     --  the switcthing of views on the ground that, if the\n+                     --  comparison was accepted during the semantics analysis\n+                     --  of the generic, this means that the component cannot\n+                     --  have been private (see Sem_Type.Valid_Comparison_Arg).\n+\n+                     if Nkind (Assoc) in N_Op_Compare\n+                       and then Present (Etype (Left_Opnd (Assoc)))\n+                       and then Is_Array_Type (Etype (Left_Opnd (Assoc)))\n+                       and then Present (Etype (Right_Opnd (Assoc)))\n+                       and then Is_Array_Type (Etype (Right_Opnd (Assoc)))\n+                     then\n+                        declare\n+                           Ltyp : constant Entity_Id :=\n+                                                     Etype (Left_Opnd (Assoc));\n+                           Rtyp : constant Entity_Id :=\n+                                                    Etype (Right_Opnd (Assoc));\n+                        begin\n+                           if Is_Private_Type (Component_Type (Ltyp)) then\n+                              Check_Private_View\n+                                (New_Occurrence_Of (Component_Type (Ltyp),\n+                                 Sloc (N)));\n+                           end if;\n+                           if Is_Private_Type (Component_Type (Rtyp)) then\n+                              Check_Private_View\n+                                (New_Occurrence_Of (Component_Type (Rtyp),\n+                                 Sloc (N)));\n+                           end if;\n+                        end;\n+                     end if;\n+\n                   --  The node is a reference to a global type and acts as the\n                   --  subtype mark of a qualified expression created in order\n                   --  to aid resolution of accidental overloading in instances.\n@@ -13641,11 +13605,6 @@ package body Sem_Ch12 is\n \n       if Is_Private_Type (Act_T) then\n          Set_Has_Private_View (Subtype_Indication (Decl_Node));\n-\n-      elsif Is_Access_Type (Act_T)\n-        and then Is_Private_Type (Designated_Type (Act_T))\n-      then\n-         Set_Has_Private_View (Subtype_Indication (Decl_Node));\n       end if;\n \n       --  In Ada 2012 the actual may be a limited view. Indicate that\n@@ -15213,11 +15172,7 @@ package body Sem_Ch12 is\n             --  If not a private type, nothing else to do\n \n             if not Is_Private_Type (Typ) then\n-               if Is_Array_Type (Typ)\n-                 and then Is_Private_Type (Component_Type (Typ))\n-               then\n-                  Set_Has_Private_View (N);\n-               end if;\n+               null;\n \n             --  If it is a derivation of a private type in a context where no\n             --  full view is needed, nothing to do either."}]}