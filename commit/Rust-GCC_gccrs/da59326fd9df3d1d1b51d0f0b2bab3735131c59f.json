{"sha": "da59326fd9df3d1d1b51d0f0b2bab3735131c59f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGE1OTMyNmZkOWRmM2QxZDFiNTFkMGYwYjJiYWIzNzM1MTMxYzU5Zg==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2007-11-08T00:08:02Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2007-11-08T00:08:02Z"}, "message": "floatformat.h (struct floatformat): Add split_half field.\n\ninclude:\n2007-11-07  Joseph Myers  <joseph@codesourcery.com>\n\t    Daniel Jacobowitz  <dan@codesourcery.com>\n\n\t* floatformat.h (struct floatformat): Add split_half field.\n\t(floatformat_ibm_long_double): New.\n\nlibiberty:\n2007-11-07  Joseph Myers  <joseph@codesourcery.com>\n\t    Daniel Jacobowitz  <dan@codesourcery.com>\n\n\t* floatformat.c (mant_bits_set): New.\n\t(floatformat_to_double): Use it.  Note no special handling of\n\tsplit formats.\n\t(floatformat_from_double): Note no special handing of split\n\tformats.\n\t(floatformat_ibm_long_double_is_valid,\n\tfloatformat_ibm_long_double): New.\n\t(floatformat_ieee_single_big, floatformat_ieee_single_little,\n\tfloatformat_ieee_double_big, floatformat_ieee_double_little,\n\tfloatformat_ieee_double_littlebyte_bigword, floatformat_vax_f,\n\tfloatformat_vax_d, floatformat_vax_g, floatformat_i387_ext,\n\tfloatformat_m68881_ext, floatformat_i960_ext,\n\tfloatformat_m88110_ext, floatformat_m88110_harris_ext,\n\tfloatformat_arm_ext_big, floatformat_arm_ext_littlebyte_bigword,\n\tfloatformat_ia64_spill_big, floatformat_ia64_spill_little,\n\tfloatformat_ia64_quad_big, floatformat_ia64_quad_little): Update\n\tfor addition of split_half field.\n\nCo-Authored-By: Daniel Jacobowitz <dan@codesourcery.com>\n\nFrom-SVN: r129977", "tree": {"sha": "2718810d3dbd721573771aeedc82387f62a2e273", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2718810d3dbd721573771aeedc82387f62a2e273"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da59326fd9df3d1d1b51d0f0b2bab3735131c59f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da59326fd9df3d1d1b51d0f0b2bab3735131c59f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da59326fd9df3d1d1b51d0f0b2bab3735131c59f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da59326fd9df3d1d1b51d0f0b2bab3735131c59f/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f09f3140c724335069034b6b43d391867d43267", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f09f3140c724335069034b6b43d391867d43267", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f09f3140c724335069034b6b43d391867d43267"}], "stats": {"total": 245, "additions": 206, "deletions": 39}, "files": [{"sha": "7ea34d2d9c1f1fded2045a48d2861ec1b46d71ef", "filename": "include/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da59326fd9df3d1d1b51d0f0b2bab3735131c59f/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da59326fd9df3d1d1b51d0f0b2bab3735131c59f/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=da59326fd9df3d1d1b51d0f0b2bab3735131c59f", "patch": "@@ -1,3 +1,9 @@\n+2007-11-07  Joseph Myers  <joseph@codesourcery.com>\n+\t    Daniel Jacobowitz  <dan@codesourcery.com>\n+\n+\t* floatformat.h (struct floatformat): Add split_half field.\n+\t(floatformat_ibm_long_double): New.\n+\n 2007-09-06  Tom Tromey  <tromey@redhat.com>\n \n \t* libiberty.h (pex_free): Document process killing."}, {"sha": "c5f60a3cd93a285dfb8d3e063a614bd196a7a125", "filename": "include/floatformat.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da59326fd9df3d1d1b51d0f0b2bab3735131c59f/include%2Ffloatformat.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da59326fd9df3d1d1b51d0f0b2bab3735131c59f/include%2Ffloatformat.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Ffloatformat.h?ref=da59326fd9df3d1d1b51d0f0b2bab3735131c59f", "patch": "@@ -85,6 +85,13 @@ struct floatformat\n \n   /* Validator method.  */\n   int (*is_valid) (const struct floatformat *fmt, const void *from);\n+\n+  /* Is the format actually the sum of two smaller floating point\n+     formats (IBM long double, as described in\n+     gcc/config/rs6000/darwin-ldouble-format)?  If so, this is the\n+     smaller format in question, and the fields sign_start through\n+     intbit describe the first half.  If not, this is NULL.  */\n+  const struct floatformat *split_half;\n };\n \n /* floatformats for IEEE single and double, big and little endian.  */\n@@ -118,6 +125,8 @@ extern const struct floatformat floatformat_ia64_spill_big;\n extern const struct floatformat floatformat_ia64_spill_little;\n extern const struct floatformat floatformat_ia64_quad_big;\n extern const struct floatformat floatformat_ia64_quad_little;\n+/* IBM long double (double+double).  */\n+extern const struct floatformat floatformat_ibm_long_double;\n \n /* Convert from FMT to a double.\n    FROM is the address of the extended float."}, {"sha": "78e74e52e225961f35c9a16274de90b42e9975fe", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da59326fd9df3d1d1b51d0f0b2bab3735131c59f/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da59326fd9df3d1d1b51d0f0b2bab3735131c59f/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=da59326fd9df3d1d1b51d0f0b2bab3735131c59f", "patch": "@@ -1,3 +1,24 @@\n+2007-11-07  Joseph Myers  <joseph@codesourcery.com>\n+\t    Daniel Jacobowitz  <dan@codesourcery.com>\n+\n+\t* floatformat.c (mant_bits_set): New.\n+\t(floatformat_to_double): Use it.  Note no special handling of\n+\tsplit formats.\n+\t(floatformat_from_double): Note no special handing of split\n+\tformats.\n+\t(floatformat_ibm_long_double_is_valid,\n+\tfloatformat_ibm_long_double): New.\n+\t(floatformat_ieee_single_big, floatformat_ieee_single_little,\n+\tfloatformat_ieee_double_big, floatformat_ieee_double_little,\n+\tfloatformat_ieee_double_littlebyte_bigword, floatformat_vax_f,\n+\tfloatformat_vax_d, floatformat_vax_g, floatformat_i387_ext,\n+\tfloatformat_m68881_ext, floatformat_i960_ext,\n+\tfloatformat_m88110_ext, floatformat_m88110_harris_ext,\n+\tfloatformat_arm_ext_big, floatformat_arm_ext_littlebyte_bigword,\n+\tfloatformat_ia64_spill_big, floatformat_ia64_spill_little,\n+\tfloatformat_ia64_quad_big, floatformat_ia64_quad_little): Update\n+\tfor addition of split_half field.\n+\n 2007-09-06  Tom Tromey  <tromey@redhat.com>\n \n \t* pexecute.txh (pex_free): Document process killing."}, {"sha": "07af7264df499c932b3d07662513a4a86304cc14", "filename": "libiberty/floatformat.c", "status": "modified", "additions": 170, "deletions": 39, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da59326fd9df3d1d1b51d0f0b2bab3735131c59f/libiberty%2Ffloatformat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da59326fd9df3d1d1b51d0f0b2bab3735131c59f/libiberty%2Ffloatformat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ffloatformat.c?ref=da59326fd9df3d1d1b51d0f0b2bab3735131c59f", "patch": "@@ -56,6 +56,7 @@ Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.\n #endif\n #endif\n \n+static int mant_bits_set (const struct floatformat *, const unsigned char *);\n static unsigned long get_field (const unsigned char *,\n                                 enum floatformat_byteorders,\n                                 unsigned int,\n@@ -82,28 +83,32 @@ const struct floatformat floatformat_ieee_single_big =\n   floatformat_big, 32, 0, 1, 8, 127, 255, 9, 23,\n   floatformat_intbit_no,\n   \"floatformat_ieee_single_big\",\n-  floatformat_always_valid\n+  floatformat_always_valid,\n+  NULL\n };\n const struct floatformat floatformat_ieee_single_little =\n {\n   floatformat_little, 32, 0, 1, 8, 127, 255, 9, 23,\n   floatformat_intbit_no,\n   \"floatformat_ieee_single_little\",\n-  floatformat_always_valid\n+  floatformat_always_valid,\n+  NULL\n };\n const struct floatformat floatformat_ieee_double_big =\n {\n   floatformat_big, 64, 0, 1, 11, 1023, 2047, 12, 52,\n   floatformat_intbit_no,\n   \"floatformat_ieee_double_big\",\n-  floatformat_always_valid\n+  floatformat_always_valid,\n+  NULL\n };\n const struct floatformat floatformat_ieee_double_little =\n {\n   floatformat_little, 64, 0, 1, 11, 1023, 2047, 12, 52,\n   floatformat_intbit_no,\n   \"floatformat_ieee_double_little\",\n-  floatformat_always_valid\n+  floatformat_always_valid,\n+  NULL\n };\n \n /* floatformat for IEEE double, little endian byte order, with big endian word\n@@ -114,7 +119,8 @@ const struct floatformat floatformat_ieee_double_littlebyte_bigword =\n   floatformat_littlebyte_bigword, 64, 0, 1, 11, 1023, 2047, 12, 52,\n   floatformat_intbit_no,\n   \"floatformat_ieee_double_littlebyte_bigword\",\n-  floatformat_always_valid\n+  floatformat_always_valid,\n+  NULL\n };\n \n /* floatformat for VAX.  Not quite IEEE, but close enough.  */\n@@ -124,21 +130,24 @@ const struct floatformat floatformat_vax_f =\n   floatformat_vax, 32, 0, 1, 8, 129, 0, 9, 23,\n   floatformat_intbit_no,\n   \"floatformat_vax_f\",\n-  floatformat_always_valid\n+  floatformat_always_valid,\n+  NULL\n };\n const struct floatformat floatformat_vax_d =\n {\n   floatformat_vax, 64, 0, 1, 8, 129, 0, 9, 55,\n   floatformat_intbit_no,\n   \"floatformat_vax_d\",\n-  floatformat_always_valid\n+  floatformat_always_valid,\n+  NULL\n };\n const struct floatformat floatformat_vax_g =\n {\n   floatformat_vax, 64, 0, 1, 11, 1025, 0, 12, 52,\n   floatformat_intbit_no,\n   \"floatformat_vax_g\",\n-  floatformat_always_valid\n+  floatformat_always_valid,\n+  NULL\n };\n \n static int floatformat_i387_ext_is_valid (const struct floatformat *fmt,\n@@ -170,30 +179,34 @@ const struct floatformat floatformat_i387_ext =\n   floatformat_little, 80, 0, 1, 15, 0x3fff, 0x7fff, 16, 64,\n   floatformat_intbit_yes,\n   \"floatformat_i387_ext\",\n-  floatformat_i387_ext_is_valid\n+  floatformat_i387_ext_is_valid,\n+  NULL\n };\n const struct floatformat floatformat_m68881_ext =\n {\n   /* Note that the bits from 16 to 31 are unused.  */\n   floatformat_big, 96, 0, 1, 15, 0x3fff, 0x7fff, 32, 64,\n   floatformat_intbit_yes,\n   \"floatformat_m68881_ext\",\n-  floatformat_always_valid\n+  floatformat_always_valid,\n+  NULL\n };\n const struct floatformat floatformat_i960_ext =\n {\n   /* Note that the bits from 0 to 15 are unused.  */\n   floatformat_little, 96, 16, 17, 15, 0x3fff, 0x7fff, 32, 64,\n   floatformat_intbit_yes,\n   \"floatformat_i960_ext\",\n-  floatformat_always_valid\n+  floatformat_always_valid,\n+  NULL\n };\n const struct floatformat floatformat_m88110_ext =\n {\n   floatformat_big, 80, 0, 1, 15, 0x3fff, 0x7fff, 16, 64,\n   floatformat_intbit_yes,\n   \"floatformat_m88110_ext\",\n-  floatformat_always_valid\n+  floatformat_always_valid,\n+  NULL\n };\n const struct floatformat floatformat_m88110_harris_ext =\n {\n@@ -202,58 +215,187 @@ const struct floatformat floatformat_m88110_harris_ext =\n   floatformat_big,128, 0, 1, 11,  0x3ff,  0x7ff, 12, 52,\n   floatformat_intbit_no,\n   \"floatformat_m88110_ext_harris\",\n-  floatformat_always_valid\n+  floatformat_always_valid,\n+  NULL\n };\n const struct floatformat floatformat_arm_ext_big =\n {\n   /* Bits 1 to 16 are unused.  */\n   floatformat_big, 96, 0, 17, 15, 0x3fff, 0x7fff, 32, 64,\n   floatformat_intbit_yes,\n   \"floatformat_arm_ext_big\",\n-  floatformat_always_valid\n+  floatformat_always_valid,\n+  NULL\n };\n const struct floatformat floatformat_arm_ext_littlebyte_bigword =\n {\n   /* Bits 1 to 16 are unused.  */\n   floatformat_littlebyte_bigword, 96, 0, 17, 15, 0x3fff, 0x7fff, 32, 64,\n   floatformat_intbit_yes,\n   \"floatformat_arm_ext_littlebyte_bigword\",\n-  floatformat_always_valid\n+  floatformat_always_valid,\n+  NULL\n };\n const struct floatformat floatformat_ia64_spill_big =\n {\n   floatformat_big, 128, 0, 1, 17, 65535, 0x1ffff, 18, 64,\n   floatformat_intbit_yes,\n   \"floatformat_ia64_spill_big\",\n-  floatformat_always_valid\n+  floatformat_always_valid,\n+  NULL\n };\n const struct floatformat floatformat_ia64_spill_little =\n {\n   floatformat_little, 128, 0, 1, 17, 65535, 0x1ffff, 18, 64,\n   floatformat_intbit_yes,\n   \"floatformat_ia64_spill_little\",\n-  floatformat_always_valid\n+  floatformat_always_valid,\n+  NULL\n };\n const struct floatformat floatformat_ia64_quad_big =\n {\n   floatformat_big, 128, 0, 1, 15, 16383, 0x7fff, 16, 112,\n   floatformat_intbit_no,\n   \"floatformat_ia64_quad_big\",\n-  floatformat_always_valid\n+  floatformat_always_valid,\n+  NULL\n };\n const struct floatformat floatformat_ia64_quad_little =\n {\n   floatformat_little, 128, 0, 1, 15, 16383, 0x7fff, 16, 112,\n   floatformat_intbit_no,\n   \"floatformat_ia64_quad_little\",\n-  floatformat_always_valid\n+  floatformat_always_valid,\n+  NULL\n+};\n+\n+static int\n+floatformat_ibm_long_double_is_valid (const struct floatformat *fmt,\n+\t\t\t\t      const void *from)\n+{\n+  const unsigned char *ufrom = (const unsigned char *) from;\n+  const struct floatformat *hfmt = fmt->split_half;\n+  long top_exp, bot_exp;\n+  int top_nan = 0;\n+\n+  top_exp = get_field (ufrom, hfmt->byteorder, hfmt->totalsize,\n+\t\t       hfmt->exp_start, hfmt->exp_len);\n+  bot_exp = get_field (ufrom + 8, hfmt->byteorder, hfmt->totalsize,\n+\t\t       hfmt->exp_start, hfmt->exp_len);\n+\n+  if (top_exp == hfmt->exp_nan)\n+    top_nan = mant_bits_set (hfmt, ufrom);\n+\n+  /* A NaN is valid with any low part.  */\n+  if (top_nan)\n+    return 1;\n+\n+  /* An infinity, zero or denormal requires low part 0 (positive or\n+     negative).  */\n+  if (top_exp == hfmt->exp_nan || top_exp == 0)\n+    {\n+      unsigned int mant_bits, mant_off;\n+      int mant_bits_left;\n+\n+      if (bot_exp != 0)\n+\treturn 0;\n+\n+      return !mant_bits_set (hfmt, ufrom + 8);\n+    }\n+\n+  /* The top part is now a finite normal value.  The long double value\n+     is the sum of the two parts, and the top part must equal the\n+     result of rounding the long double value to nearest double.  Thus\n+     the bottom part must be <= 0.5ulp of the top part in absolute\n+     value, and if it is < 0.5ulp then the long double is definitely\n+     valid.  */\n+  if (bot_exp < top_exp - 53)\n+    return 1;\n+  if (bot_exp > top_exp - 53 && bot_exp != 0)\n+    return 0;\n+  if (bot_exp == 0)\n+    {\n+      /* The bottom part is 0 or denormal.  Determine which, and if\n+\t denormal the first two set bits.  */\n+      int first_bit = -1, second_bit = -1, cur_bit;\n+      for (cur_bit = 0; cur_bit < hfmt->man_len; cur_bit++)\n+\tif (get_field (ufrom + 8, hfmt->byteorder, hfmt->totalsize,\n+\t\t       hfmt->man_start + cur_bit, 1))\n+\t  {\n+\t    if (first_bit == -1)\n+\t      first_bit = cur_bit;\n+\t    else\n+\t      {\n+\t\tsecond_bit = cur_bit;\n+\t\tbreak;\n+\t      }\n+\t  }\n+      /* Bottom part 0 is OK.  */\n+      if (first_bit == -1)\n+\treturn 1;\n+      /* The real exponent of the bottom part is -first_bit.  */\n+      if (-first_bit < top_exp - 53)\n+\treturn 1;\n+      if (-first_bit > top_exp - 53)\n+\treturn 0;\n+      /* The bottom part is at least 0.5ulp of the top part.  For this\n+\t to be OK, the bottom part must be exactly 0.5ulp (i.e. no\n+\t more bits set) and the top part must have last bit 0.  */\n+      if (second_bit != -1)\n+\treturn 0;\n+      return !get_field (ufrom, hfmt->byteorder, hfmt->totalsize,\n+\t\t\t hfmt->man_start + hfmt->man_len - 1, 1);\n+    }\n+  else\n+    {\n+      /* The bottom part is at least 0.5ulp of the top part.  For this\n+\t to be OK, it must be exactly 0.5ulp (i.e. no explicit bits\n+\t set) and the top part must have last bit 0.  */\n+      if (get_field (ufrom, hfmt->byteorder, hfmt->totalsize,\n+\t\t     hfmt->man_start + hfmt->man_len - 1, 1))\n+\treturn 0;\n+      return !mant_bits_set (hfmt, ufrom + 8);\n+    }\n+}\n+\n+const struct floatformat floatformat_ibm_long_double =\n+{\n+  floatformat_big, 128, 0, 1, 11, 1023, 2047, 12, 52,\n+  floatformat_intbit_no,\n+  \"floatformat_ibm_long_double\",\n+  floatformat_always_valid,\n+  &floatformat_ieee_double_big\n };\n \f\n \n #ifndef min\n #define min(a, b) ((a) < (b) ? (a) : (b))\n #endif\n \n+/* Return 1 if any bits are explicitly set in the mantissa of UFROM,\n+   format FMT, 0 otherwise.  */\n+static int\n+mant_bits_set (const struct floatformat *fmt, const unsigned char *ufrom)\n+{\n+  unsigned int mant_bits, mant_off;\n+  int mant_bits_left;\n+\n+  mant_off = fmt->man_start;\n+  mant_bits_left = fmt->man_len;\n+  while (mant_bits_left > 0)\n+    {\n+      mant_bits = min (mant_bits_left, 32);\n+\n+      if (get_field (ufrom, fmt->byteorder, fmt->totalsize,\n+\t\t     mant_off, mant_bits) != 0)\n+\treturn 1;\n+\n+      mant_off += mant_bits;\n+      mant_bits_left -= mant_bits;\n+    }\n+  return 0;\n+}\n+\n /* Extract a field which starts at START and is LEN bits long.  DATA and\n    TOTAL_LEN are the thing we are extracting it from, in byteorder ORDER.  */\n static unsigned long\n@@ -310,6 +452,10 @@ floatformat_to_double (const struct floatformat *fmt,\n   int mant_bits_left;\n   int special_exponent;\t\t/* It's a NaN, denorm or zero */\n \n+  /* Split values are not handled specially, since the top half has\n+     the correctly rounded double value (in the only supported case of\n+     split values).  */\n+\n   exponent = get_field (ufrom, fmt->byteorder, fmt->totalsize,\n \t\t\tfmt->exp_start, fmt->exp_len);\n \n@@ -318,26 +464,7 @@ floatformat_to_double (const struct floatformat *fmt,\n      don't try to preserve the type of NaN.  FIXME.  */\n   if ((unsigned long) exponent == fmt->exp_nan)\n     {\n-      int nan;\n-\n-      mant_off = fmt->man_start;\n-      mant_bits_left = fmt->man_len;\n-      nan = 0;\n-      while (mant_bits_left > 0)\n-\t{\n-\t  mant_bits = min (mant_bits_left, 32);\n-\n-\t  if (get_field (ufrom, fmt->byteorder, fmt->totalsize,\n-\t\t\t mant_off, mant_bits) != 0)\n-\t    {\n-\t      /* This is a NaN.  */\n-\t      nan = 1;\n-\t      break;\n-\t    }\n-\n-\t  mant_off += mant_bits;\n-\t  mant_bits_left -= mant_bits;\n-\t}\n+      int nan = mant_bits_set (fmt, ufrom);\n \n       /* On certain systems (such as GNU/Linux), the use of the\n \t INFINITY macro below may generate a warning that can not be\n@@ -474,6 +601,10 @@ floatformat_from_double (const struct floatformat *fmt,\n   dfrom = *from;\n   memset (uto, 0, fmt->totalsize / FLOATFORMAT_CHAR_BIT);\n \n+  /* Split values are not handled specially, since a bottom half of\n+     zero is correct for any value representable as double (in the\n+     only supported case of split values).  */\n+\n   /* If negative, set the sign bit.  */\n   if (dfrom < 0)\n     {"}]}