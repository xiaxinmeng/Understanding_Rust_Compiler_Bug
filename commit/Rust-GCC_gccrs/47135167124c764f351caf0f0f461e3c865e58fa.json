{"sha": "47135167124c764f351caf0f0f461e3c865e58fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDcxMzUxNjcxMjRjNzY0ZjM1MWNhZjBmMGY0NjFlM2M4NjVlNThmYQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2016-10-28T18:10:14Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2016-10-28T18:10:14Z"}, "message": "dojump.c (do_jump_by_parts_greater_rtx): Invert probability when swapping the arms of the branch.\n\n\t* dojump.c (do_jump_by_parts_greater_rtx): Invert probability when\n\tswapping the arms of the branch.\n\t* internal-fn.c (expand_addsub_overflow): Use a straight-line code\n\tsequence for the generic signed-signed-signed case.\n\nFrom-SVN: r241656", "tree": {"sha": "a4bdbd149ff48c14eae8a3cceb5f24cbd7dda2f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a4bdbd149ff48c14eae8a3cceb5f24cbd7dda2f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47135167124c764f351caf0f0f461e3c865e58fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47135167124c764f351caf0f0f461e3c865e58fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47135167124c764f351caf0f0f461e3c865e58fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47135167124c764f351caf0f0f461e3c865e58fa/comments", "author": null, "committer": null, "parents": [{"sha": "eae2ada50349a429549a99145c5810e58807f809", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eae2ada50349a429549a99145c5810e58807f809", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eae2ada50349a429549a99145c5810e58807f809"}], "stats": {"total": 90, "additions": 55, "deletions": 35}, "files": [{"sha": "a3b49ecec754c0a3e753318960fdd9311fcef78b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47135167124c764f351caf0f0f461e3c865e58fa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47135167124c764f351caf0f0f461e3c865e58fa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=47135167124c764f351caf0f0f461e3c865e58fa", "patch": "@@ -1,3 +1,10 @@\n+2016-10-28  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* dojump.c (do_jump_by_parts_greater_rtx): Invert probability when\n+\tswapping the arms of the branch.\n+\t* internal-fn.c (expand_addsub_overflow): Use a straight-line code\n+\tsequence for the generic signed-signed-signed case.\n+\n 2016-10-28  Jeff Law  <law@redhat.com>\n \n \t* config/bfin/bfin.c (bfin_legitimate_address_p): Add missing"}, {"sha": "e6ddf78898dcff5b3b71af0d47867afe45ef744f", "filename": "gcc/dojump.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47135167124c764f351caf0f0f461e3c865e58fa/gcc%2Fdojump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47135167124c764f351caf0f0f461e3c865e58fa/gcc%2Fdojump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.c?ref=47135167124c764f351caf0f0f461e3c865e58fa", "patch": "@@ -703,6 +703,7 @@ do_jump_by_parts_greater_rtx (machine_mode mode, int unsignedp, rtx op0,\n       if_false_label = drop_through_label;\n       drop_through_if_true = false;\n       drop_through_if_false = true;\n+      prob = inv (prob);\n     }\n \n   /* Compare a word at a time, high order first.  */"}, {"sha": "156ba31047c0a81ace4ad088adf65c27a6d31e02", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 47, "deletions": 35, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47135167124c764f351caf0f0f461e3c865e58fa/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47135167124c764f351caf0f0f461e3c865e58fa/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=47135167124c764f351caf0f0f461e3c865e58fa", "patch": "@@ -847,56 +847,68 @@ expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n \tdelete_insns_since (last);\n       }\n \n-    rtx_code_label *sub_check = gen_label_rtx ();\n-    int pos_neg = 3;\n-\n     /* Compute the operation.  On RTL level, the addition is always\n        unsigned.  */\n     res = expand_binop (mode, code == PLUS_EXPR ? add_optab : sub_optab,\n \t\t\top0, op1, NULL_RTX, false, OPTAB_LIB_WIDEN);\n \n-    /* If we can prove one of the arguments (for MINUS_EXPR only\n+    /* If we can prove that one of the arguments (for MINUS_EXPR only\n        the second operand, as subtraction is not commutative) is always\n        non-negative or always negative, we can do just one comparison\n-       and conditional jump instead of 2 at runtime, 3 present in the\n-       emitted code.  If one of the arguments is CONST_INT, all we\n-       need is to make sure it is op1, then the first\n-       do_compare_rtx_and_jump will be just folded.  Otherwise try\n-       to use range info if available.  */\n-    if (code == PLUS_EXPR && CONST_INT_P (op0))\n-      std::swap (op0, op1);\n-    else if (CONST_INT_P (op1))\n-      ;\n-    else if (code == PLUS_EXPR && TREE_CODE (arg0) == SSA_NAME)\n+       and conditional jump.  */\n+    int pos_neg = get_range_pos_neg (arg1);\n+    if (code == PLUS_EXPR)\n       {\n-        pos_neg = get_range_pos_neg (arg0);\n-        if (pos_neg != 3)\n-\t  std::swap (op0, op1);\n+\tint pos_neg0 = get_range_pos_neg (arg0);\n+\tif (pos_neg0 != 3 && pos_neg == 3)\n+\t  {\n+\t    std::swap (op0, op1);\n+\t    pos_neg = pos_neg0;\n+\t  }\n       }\n-    if (pos_neg == 3 && !CONST_INT_P (op1) && TREE_CODE (arg1) == SSA_NAME)\n-      pos_neg = get_range_pos_neg (arg1);\n \n-    /* If the op1 is negative, we have to use a different check.  */\n+    /* Addition overflows if and only if the two operands have the same sign,\n+       and the result has the opposite sign.  Subtraction overflows if and\n+       only if the two operands have opposite sign, and the subtrahend has\n+       the same sign as the result.  Here 0 is counted as positive.  */\n     if (pos_neg == 3)\n-      do_compare_rtx_and_jump (op1, const0_rtx, LT, false, mode, NULL_RTX,\n-\t\t\t       NULL, sub_check, PROB_EVEN);\n+      {\n+\t/* Compute op0 ^ op1 (operands have opposite sign).  */\n+        rtx op_xor = expand_binop (mode, xor_optab, op0, op1, NULL_RTX, false,\n+\t\t\t\t   OPTAB_LIB_WIDEN);\n \n-    /* Compare the result of the operation with one of the operands.  */\n-    if (pos_neg & 1)\n-      do_compare_rtx_and_jump (res, op0, code == PLUS_EXPR ? GE : LE,\n-\t\t\t       false, mode, NULL_RTX, NULL, done_label,\n-\t\t\t       PROB_VERY_LIKELY);\n+\t/* Compute res ^ op1 (result and 2nd operand have opposite sign).  */\n+\trtx res_xor = expand_binop (mode, xor_optab, res, op1, NULL_RTX, false,\n+\t\t\t\t    OPTAB_LIB_WIDEN);\n \n-    /* If we get here, we have to print the error.  */\n-    if (pos_neg == 3)\n-      {\n-\temit_jump (do_error);\n-\temit_label (sub_check);\n+\trtx tem;\n+\tif (code == PLUS_EXPR)\n+\t  {\n+\t    /* Compute (res ^ op1) & ~(op0 ^ op1).  */\n+\t    tem = expand_unop (mode, one_cmpl_optab, op_xor, NULL_RTX, false);\n+\t    tem = expand_binop (mode, and_optab, res_xor, tem, NULL_RTX, false,\n+\t\t\t\tOPTAB_LIB_WIDEN);\n+\t  }\n+\telse\n+\t  {\n+\t    /* Compute (op0 ^ op1) & ~(res ^ op1).  */\n+\t    tem = expand_unop (mode, one_cmpl_optab, res_xor, NULL_RTX, false);\n+\t    tem = expand_binop (mode, and_optab, op_xor, tem, NULL_RTX, false,\n+\t\t\t\tOPTAB_LIB_WIDEN);\n+\t  }\n+\n+\t/* No overflow if the result has bit sign cleared.  */\n+\tdo_compare_rtx_and_jump (tem, const0_rtx, GE, false, mode, NULL_RTX,\n+\t\t\t\t NULL, done_label, PROB_VERY_LIKELY);\n       }\n \n-    /* We have k = a + b for b < 0 here.  k <= a must hold.  */\n-    if (pos_neg & 2)\n-      do_compare_rtx_and_jump (res, op0, code == PLUS_EXPR ? LE : GE,\n+    /* Compare the result of the operation with the first operand.\n+       No overflow for addition if second operand is positive and result\n+       is larger or second operand is negative and result is smaller.\n+       Likewise for subtraction with sign of second operand flipped.  */\n+    else\n+      do_compare_rtx_and_jump (res, op0,\n+\t\t\t       (pos_neg == 1) ^ (code == MINUS_EXPR) ? GE : LE,\n \t\t\t       false, mode, NULL_RTX, NULL, done_label,\n \t\t\t       PROB_VERY_LIKELY);\n   }"}]}