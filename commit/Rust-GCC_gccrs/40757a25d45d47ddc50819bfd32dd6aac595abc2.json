{"sha": "40757a25d45d47ddc50819bfd32dd6aac595abc2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDA3NTdhMjVkNDVkNDdkZGM1MDgxOWJmZDMyZGQ2YWFjNTk1YWJjMg==", "commit": {"author": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2017-11-08T18:27:57Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "ktkachov@gcc.gnu.org", "date": "2017-11-08T18:27:57Z"}, "message": "vec_merge + vec_duplicate + vec_concat simplification\n\nAnother vec_merge simplification that's missing is transforming:\n(vec_merge (vec_duplicate x) (vec_concat (y) (z)) (const_int N))\ninto\n(vec_concat x z) if N == 1 (0b01) or\n(vec_concat y x) if N == 2 (0b10)\n\nFor the testcase in this patch on aarch64 this allows us to try matching during combine the pattern:\n(set (reg:V2DI 78 [ x ])\n    (vec_concat:V2DI\n        (mem:DI (reg/v/f:DI 76 [ y ]) [1 *y_4(D)+0 S8 A64])\n        (mem:DI (plus:DI (reg/v/f:DI 76 [ y ])\n                (const_int 8 [0x8])) [1 MEM[(long long int *)y_4(D) + 8B]+0 S8 A64])))\n\nrather than the more complex:\n(set (reg:V2DI 78 [ x ])\n    (vec_merge:V2DI (vec_duplicate:V2DI (mem:DI (plus:DI (reg/v/f:DI 76 [ y ])\n                    (const_int 8 [0x8])) [1 MEM[(long long int *)y_4(D) + 8B]+0 S8 A64]))\n        (vec_duplicate:V2DI (mem:DI (reg/v/f:DI 76 [ y ]) [1 *y_4(D)+0 S8 A64]))\n        (const_int 2 [0x2])))\n\nWe don't actually have an aarch64 pattern for the simplified version above, but it's a simple enough\nform to add, so this patch adds such a pattern that performs a concatenated load of two 64-bit vectors\nin adjacent memory locations as a single Q-register LDR. The new aarch64 pattern is needed to demonstrate\nthe effectiveness of the simplify-rtx change, so I've kept them together as one patch.\n\nNow for the testcase in the patch we can generate:\nconstruct_lanedi:\n        ldr     q0, [x0]\n        ret\n\nconstruct_lanedf:\n        ldr     q0, [x0]\n        ret\n\ninstead of:\nconstruct_lanedi:\n        ld1r    {v0.2d}, [x0]\n        ldr     x0, [x0, 8]\n        ins     v0.d[1], x0\n        ret\n\nconstruct_lanedf:\n        ld1r    {v0.2d}, [x0]\n        ldr     d1, [x0, 8]\n        ins     v0.d[1], v1.d[0]\n        ret\n\nThe new memory constraint Utq is needed because we need to allow only the Q-register addressing modes but\nthe MEM expressions in the RTL pattern have 64-bit vector modes, and if we don't constrain them they will\nallow the D-register addressing modes during register allocation/address mode selection, which will produce\ninvalid assembly.\n\nBootstrapped and tested on aarch64-none-linux-gnu. \n\n\t* simplify-rtx.c (simplify_ternary_operation, VEC_MERGE):\n\tSimplify vec_merge of vec_duplicate and vec_concat.\n\t* config/aarch64/constraints.md (Utq): New constraint.\n\t* config/aarch64/aarch64-simd.md (load_pair_lanes<mode>): New\n\tdefine_insn.\n\n\t* gcc.target/aarch64/load_v2vec_lanes_1.c: New test.\n\nFrom-SVN: r254549", "tree": {"sha": "1fb9af62f06e3359a9e04ec7f5be8782fad1a802", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1fb9af62f06e3359a9e04ec7f5be8782fad1a802"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40757a25d45d47ddc50819bfd32dd6aac595abc2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40757a25d45d47ddc50819bfd32dd6aac595abc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40757a25d45d47ddc50819bfd32dd6aac595abc2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40757a25d45d47ddc50819bfd32dd6aac595abc2/comments", "author": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6432f025b4fccaaca8564e0c2518cdba869c4bf5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6432f025b4fccaaca8564e0c2518cdba869c4bf5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6432f025b4fccaaca8564e0c2518cdba869c4bf5"}], "stats": {"total": 78, "additions": 78, "deletions": 0}, "files": [{"sha": "9b50bca81512f69e6823905e943c749c3d790453", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40757a25d45d47ddc50819bfd32dd6aac595abc2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40757a25d45d47ddc50819bfd32dd6aac595abc2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=40757a25d45d47ddc50819bfd32dd6aac595abc2", "patch": "@@ -1,3 +1,11 @@\n+2017-11-08  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\t* simplify-rtx.c (simplify_ternary_operation, VEC_MERGE):\n+\tSimplify vec_merge of vec_duplicate and vec_concat.\n+\t* config/aarch64/constraints.md (Utq): New constraint.\n+\t* config/aarch64/aarch64-simd.md (load_pair_lanes<mode>): New\n+\tdefine_insn.\n+\n 2017-11-08  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* simplify-rtx.c (simplify_ternary_operation, VEC_MERGE):"}, {"sha": "1f5c911fc4b773a709571d2d2247695aefaa9c59", "filename": "gcc/config/aarch64/aarch64-simd.md", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40757a25d45d47ddc50819bfd32dd6aac595abc2/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40757a25d45d47ddc50819bfd32dd6aac595abc2/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md?ref=40757a25d45d47ddc50819bfd32dd6aac595abc2", "patch": "@@ -2935,6 +2935,20 @@\n   [(set_attr \"type\" \"neon_to_gp<q>, neon_dup<q>, neon_store1_one_lane<q>\")]\n )\n \n+(define_insn \"load_pair_lanes<mode>\"\n+  [(set (match_operand:<VDBL> 0 \"register_operand\" \"=w\")\n+\t(vec_concat:<VDBL>\n+\t   (match_operand:VDC 1 \"memory_operand\" \"Utq\")\n+\t   (match_operand:VDC 2 \"memory_operand\" \"m\")))]\n+  \"TARGET_SIMD && !STRICT_ALIGNMENT\n+   && rtx_equal_p (XEXP (operands[2], 0),\n+\t\t   plus_constant (Pmode,\n+\t\t\t\t  XEXP (operands[1], 0),\n+\t\t\t\t  GET_MODE_SIZE (<MODE>mode)))\"\n+  \"ldr\\\\t%q0, %1\"\n+  [(set_attr \"type\" \"neon_load1_1reg_q\")]\n+)\n+\n ;; In this insn, operand 1 should be low, and operand 2 the high part of the\n ;; dest vector.\n "}, {"sha": "4ef7a50ac1ad11d902e25007b0ef8d4d683d62d4", "filename": "gcc/config/aarch64/constraints.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40757a25d45d47ddc50819bfd32dd6aac595abc2/gcc%2Fconfig%2Faarch64%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40757a25d45d47ddc50819bfd32dd6aac595abc2/gcc%2Fconfig%2Faarch64%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fconstraints.md?ref=40757a25d45d47ddc50819bfd32dd6aac595abc2", "patch": "@@ -178,6 +178,13 @@\n   (and (match_code \"mem\")\n        (match_test \"aarch64_simd_mem_operand_p (op)\")))\n \n+(define_memory_constraint \"Utq\"\n+  \"@internal\n+   An address valid for loading or storing a 128-bit AdvSIMD register\"\n+  (and (match_code \"mem\")\n+       (match_test \"aarch64_legitimate_address_p (V2DImode, XEXP (op, 0),\n+\t\t\t\t\t\t  MEM, 1)\")))\n+\n (define_constraint \"Ufc\"\n   \"A floating point constant which can be used with an\\\n    FMOV immediate operation.\""}, {"sha": "92c783af5a6a32bcfad5daf5ccfcce7e33661007", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40757a25d45d47ddc50819bfd32dd6aac595abc2/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40757a25d45d47ddc50819bfd32dd6aac595abc2/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=40757a25d45d47ddc50819bfd32dd6aac595abc2", "patch": "@@ -5765,6 +5765,25 @@ simplify_ternary_operation (enum rtx_code code, machine_mode mode,\n \t\tstd::swap (newop0, newop1);\n \t      return simplify_gen_binary (VEC_CONCAT, mode, newop0, newop1);\n \t    }\n+\t  /* Replace (vec_merge (vec_duplicate x) (vec_concat (y) (z)) (const_int N))\n+\t     with (vec_concat x z) if N == 1, or (vec_concat y x) if N == 2.\n+\t     Only applies for vectors of two elements.  */\n+\t  if (GET_CODE (op0) == VEC_DUPLICATE\n+\t      && GET_CODE (op1) == VEC_CONCAT\n+\t      && GET_MODE_NUNITS (GET_MODE (op0)) == 2\n+\t      && GET_MODE_NUNITS (GET_MODE (op1)) == 2\n+\t      && IN_RANGE (sel, 1, 2))\n+\t    {\n+\t      rtx newop0 = XEXP (op0, 0);\n+\t      rtx newop1 = XEXP (op1, 2 - sel);\n+\t      rtx otherop = XEXP (op1, sel - 1);\n+\t      if (sel == 2)\n+\t\tstd::swap (newop0, newop1);\n+\t      /* Don't want to throw away the other part of the vec_concat if\n+\t\t it has side-effects.  */\n+\t      if (!side_effects_p (otherop))\n+\t\treturn simplify_gen_binary (VEC_CONCAT, mode, newop0, newop1);\n+\t    }\n \t}\n \n       if (rtx_equal_p (op0, op1)"}, {"sha": "3d9c337bf404fbac514d363696d8395408c3e1a3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40757a25d45d47ddc50819bfd32dd6aac595abc2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40757a25d45d47ddc50819bfd32dd6aac595abc2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=40757a25d45d47ddc50819bfd32dd6aac595abc2", "patch": "@@ -1,3 +1,7 @@\n+2017-11-08  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\t* gcc.target/aarch64/load_v2vec_lanes_1.c: New test.\n+\n 2017-11-08  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* gcc.target/aarch64/construct_lane_zero_1.c: New test."}, {"sha": "3c31b340154b5469fca858a579e9a6ab90ee0d22", "filename": "gcc/testsuite/gcc.target/aarch64/load_v2vec_lanes_1.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40757a25d45d47ddc50819bfd32dd6aac595abc2/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fload_v2vec_lanes_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40757a25d45d47ddc50819bfd32dd6aac595abc2/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fload_v2vec_lanes_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fload_v2vec_lanes_1.c?ref=40757a25d45d47ddc50819bfd32dd6aac595abc2", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+typedef long long v2di __attribute__ ((vector_size (16)));\n+typedef double v2df __attribute__ ((vector_size (16)));\n+\n+v2di\n+construct_lanedi (long long *y)\n+{\n+  v2di x = { y[0], y[1] };\n+  return x;\n+}\n+\n+v2df\n+construct_lanedf (double *y)\n+{\n+  v2df x = { y[0], y[1] };\n+  return x;\n+}\n+\n+/* We can use the load_pair_lanes<mode> pattern to vec_concat two DI/DF\n+   values from consecutive memory into a 2-element vector by using\n+   a Q-reg LDR.  */\n+\n+/* { dg-final { scan-assembler-times \"ldr\\tq\\[0-9\\]+\" 2 } } */\n+/* { dg-final { scan-assembler-not \"ins\\t\" } } */"}]}