{"sha": "10791753c191d1f9d886e8977ff331b28d48398d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTA3OTE3NTNjMTkxZDFmOWQ4ODZlODk3N2ZmMzMxYjI4ZDQ4Mzk4ZA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2017-05-16T19:52:26Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2017-05-16T19:52:26Z"}, "message": "C++: fix-it hints suggesting accessors for private fields\n\ngcc/cp/ChangeLog:\n\t* call.c (enforce_access): Add access_failure_info * param and use\n\tit to record access failures.\n\t* cp-tree.h (class access_failure_info): New class.\n\t(enforce_access): Add access_failure_info * param, defaulting to\n\tNULL.\n\t(lookup_member): Likewise.\n\t(locate_field_accessor): New function decl.\n\t(perform_or_defer_access_check): Add access_failure_info * param,\n\tdefaulting to NULL.\n\t* search.c (lookup_member): Add access_failure_info * param and\n\tpass it on to call to perform_or_defer_access_check.\n\t(matches_code_and_type_p): New function.\n\t(field_access_p): New function.\n\t(direct_accessor_p): New function.\n\t(reference_accessor_p): New function.\n\t(field_accessor_p): New function.\n\t(struct locate_field_data): New struct.\n\t(dfs_locate_field_accessor_pre): New function.\n\t(locate_field_accessor): New function.\n\t* semantics.c (perform_or_defer_access_check): Add\n\taccess_failure_info * param, and pass it on to call to\n\tenforce_access.\n\t* typeck.c (access_failure_info::record_access_failure): New method.\n\t(access_failure_info::maybe_suggest_accessor): New method.\n\t(finish_class_member_access_expr): Pass an access_failure_info\n\tinstance to the lookup_member call, and call its\n\tmaybe_suggest_accessor method afterwards.\n\ngcc/testsuite/ChangeLog:\n\t* g++.dg/other/accessor-fixits-1.C: New test case.\n\t* g++.dg/other/accessor-fixits-2.C: New test case.\n\t* g++.dg/other/accessor-fixits-3.C: New test case.\n\t* g++.dg/other/accessor-fixits-4.C: New test case.\n\nFrom-SVN: r248128", "tree": {"sha": "7300ba80786b3a4015ecd026d0743b85a9c3b7cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7300ba80786b3a4015ecd026d0743b85a9c3b7cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10791753c191d1f9d886e8977ff331b28d48398d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10791753c191d1f9d886e8977ff331b28d48398d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10791753c191d1f9d886e8977ff331b28d48398d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10791753c191d1f9d886e8977ff331b28d48398d/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "727577c2300f8a1c4cf757e784267e11034f6b4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/727577c2300f8a1c4cf757e784267e11034f6b4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/727577c2300f8a1c4cf757e784267e11034f6b4a"}], "stats": {"total": 714, "additions": 703, "deletions": 11}, "files": [{"sha": "d659fb9b8f141a6968f46388e31c336de4e6166f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10791753c191d1f9d886e8977ff331b28d48398d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10791753c191d1f9d886e8977ff331b28d48398d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=10791753c191d1f9d886e8977ff331b28d48398d", "patch": "@@ -1,3 +1,33 @@\n+2017-05-16  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* call.c (enforce_access): Add access_failure_info * param and use\n+\tit to record access failures.\n+\t* cp-tree.h (class access_failure_info): New class.\n+\t(enforce_access): Add access_failure_info * param, defaulting to\n+\tNULL.\n+\t(lookup_member): Likewise.\n+\t(locate_field_accessor): New function decl.\n+\t(perform_or_defer_access_check): Add access_failure_info * param,\n+\tdefaulting to NULL.\n+\t* search.c (lookup_member): Add access_failure_info * param and\n+\tpass it on to call to perform_or_defer_access_check.\n+\t(matches_code_and_type_p): New function.\n+\t(field_access_p): New function.\n+\t(direct_accessor_p): New function.\n+\t(reference_accessor_p): New function.\n+\t(field_accessor_p): New function.\n+\t(struct locate_field_data): New struct.\n+\t(dfs_locate_field_accessor_pre): New function.\n+\t(locate_field_accessor): New function.\n+\t* semantics.c (perform_or_defer_access_check): Add\n+\taccess_failure_info * param, and pass it on to call to\n+\tenforce_access.\n+\t* typeck.c (access_failure_info::record_access_failure): New method.\n+\t(access_failure_info::maybe_suggest_accessor): New method.\n+\t(finish_class_member_access_expr): Pass an access_failure_info\n+\tinstance to the lookup_member call, and call its\n+\tmaybe_suggest_accessor method afterwards.\n+\n 2017-05-16  Marek Polacek  <polacek@redhat.com>\n \n \tPR sanitizer/80536"}, {"sha": "cc642025a7e1ca0f8e6ae61aeccd4d6907b5c33b", "filename": "gcc/cp/call.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10791753c191d1f9d886e8977ff331b28d48398d/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10791753c191d1f9d886e8977ff331b28d48398d/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=10791753c191d1f9d886e8977ff331b28d48398d", "patch": "@@ -6396,7 +6396,7 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n \n bool\n enforce_access (tree basetype_path, tree decl, tree diag_decl,\n-\t\ttsubst_flags_t complain)\n+\t\ttsubst_flags_t complain, access_failure_info *afi)\n {\n   gcc_assert (TREE_CODE (basetype_path) == TREE_BINFO);\n \n@@ -6422,17 +6422,23 @@ enforce_access (tree basetype_path, tree decl, tree diag_decl,\n \t      error (\"%q#D is private within this context\", diag_decl);\n \t      inform (DECL_SOURCE_LOCATION (diag_decl),\n \t\t      \"declared private here\");\n+\t      if (afi)\n+\t\tafi->record_access_failure (basetype_path, diag_decl);\n \t    }\n \t  else if (TREE_PROTECTED (decl))\n \t    {\n \t      error (\"%q#D is protected within this context\", diag_decl);\n \t      inform (DECL_SOURCE_LOCATION (diag_decl),\n \t\t      \"declared protected here\");\n+\t      if (afi)\n+\t\tafi->record_access_failure (basetype_path, diag_decl);\n \t    }\n \t  else\n \t    {\n \t      error (\"%q#D is inaccessible within this context\", diag_decl);\n \t      inform (DECL_SOURCE_LOCATION (diag_decl), \"declared here\");\n+\t      if (afi)\n+\t\tafi->record_access_failure (basetype_path, diag_decl);\n \t    }\n \t}\n       return false;"}, {"sha": "0efc5dbbe9b4f65b4023ffa0e7dafbc15224e154", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10791753c191d1f9d886e8977ff331b28d48398d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10791753c191d1f9d886e8977ff331b28d48398d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=10791753c191d1f9d886e8977ff331b28d48398d", "patch": "@@ -5758,8 +5758,30 @@ extern bool can_convert_arg\t\t\t(tree, tree, tree, int,\n \t\t\t\t\t\t tsubst_flags_t);\n extern bool can_convert_arg_bad\t\t\t(tree, tree, tree, int,\n \t\t\t\t\t\t tsubst_flags_t);\n+\n+/* A class for recording information about access failures (e.g. private\n+   fields), so that we can potentially supply a fix-it hint about\n+   an accessor (from a context in which the constness of the object\n+   is known).  */\n+\n+class access_failure_info\n+{\n+ public:\n+  access_failure_info () : m_was_inaccessible (false), m_basetype_path (NULL_TREE),\n+    m_field_decl (NULL_TREE) {}\n+\n+  void record_access_failure (tree basetype_path, tree field_decl);\n+  void maybe_suggest_accessor (bool const_p) const;\n+\n+ private:\n+  bool m_was_inaccessible;\n+  tree m_basetype_path;\n+  tree m_field_decl;\n+};\n+\n extern bool enforce_access\t\t\t(tree, tree, tree,\n-\t\t\t\t\t\t tsubst_flags_t);\n+\t\t\t\t\t\t tsubst_flags_t,\n+\t\t\t\t\t\t access_failure_info *afi = NULL);\n extern void push_defarg_context\t\t\t(tree);\n extern void pop_defarg_context\t\t\t(void);\n extern tree convert_default_arg\t\t\t(tree, tree, tree, int,\n@@ -6412,8 +6434,10 @@ extern tree lookup_fnfields_slot_nolazy\t\t(tree, tree);\n extern int class_method_index_for_fn\t\t(tree, tree);\n extern tree lookup_fnfields\t\t\t(tree, tree, int);\n extern tree lookup_member\t\t\t(tree, tree, int, bool,\n-\t\t\t\t\t\t tsubst_flags_t);\n+\t\t\t\t\t\t tsubst_flags_t,\n+\t\t\t\t\t\t access_failure_info *afi = NULL);\n extern tree lookup_member_fuzzy\t\t(tree, tree, bool);\n+extern tree locate_field_accessor\t\t(tree, tree, bool);\n extern int look_for_overrides\t\t\t(tree, tree);\n extern void get_pure_virtuals\t\t\t(tree);\n extern void maybe_suppress_debug_info\t\t(tree);\n@@ -6468,7 +6492,8 @@ extern bool perform_access_checks (vec<deferred_access_check, va_gc> *,\n \t\t\t\t   tsubst_flags_t);\n extern bool perform_deferred_access_checks\t(tsubst_flags_t);\n extern bool perform_or_defer_access_check\t(tree, tree, tree,\n-\t\t\t\t\t\t tsubst_flags_t);\n+\t\t\t\t\t\t tsubst_flags_t,\n+\t\t\t\t\t\t access_failure_info *afi = NULL);\n \n /* RAII sentinel to ensures that deferred access checks are popped before\n   a function returns.  */"}, {"sha": "61bdb93bd511ac9b57cbca85f7199f0d8b381809", "filename": "gcc/cp/search.c", "status": "modified", "additions": 237, "deletions": 3, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10791753c191d1f9d886e8977ff331b28d48398d/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10791753c191d1f9d886e8977ff331b28d48398d/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=10791753c191d1f9d886e8977ff331b28d48398d", "patch": "@@ -1232,11 +1232,13 @@ build_baselink (tree binfo, tree access_binfo, tree functions, tree optype)\n \n    WANT_TYPE is 1 when we should only return TYPE_DECLs.\n \n-   If nothing can be found return NULL_TREE and do not issue an error.  */\n+   If nothing can be found return NULL_TREE and do not issue an error.\n+\n+   If non-NULL, failure information is written back to AFI.  */\n \n tree\n lookup_member (tree xbasetype, tree name, int protect, bool want_type,\n-\t       tsubst_flags_t complain)\n+\t       tsubst_flags_t complain, access_failure_info *afi)\n {\n   tree rval, rval_binfo = NULL_TREE;\n   tree type = NULL_TREE, basetype_path = NULL_TREE;\n@@ -1337,7 +1339,7 @@ lookup_member (tree xbasetype, tree name, int protect, bool want_type,\n       tree decl = is_overloaded_fn (rval) ? get_first_fn (rval) : rval;\n       if (!DECL_NONSTATIC_MEMBER_FUNCTION_P (decl)\n \t  && !perform_or_defer_access_check (basetype_path, decl, decl,\n-\t\t\t\t\t     complain))\n+\t\t\t\t\t     complain, afi))\n \trval = error_mark_node;\n     }\n \n@@ -1993,6 +1995,238 @@ dfs_walk_once_accessible (tree binfo, bool friends_p,\n   return rval;\n }\n \n+/* Return true iff the code of T is CODE, and it has compatible\n+   type with TYPE.  */\n+\n+static bool\n+matches_code_and_type_p (tree t, enum tree_code code, tree type)\n+{\n+  if (TREE_CODE (t) != code)\n+    return false;\n+  if (!cxx_types_compatible_p (TREE_TYPE (t), type))\n+    return false;\n+  return true;\n+}\n+\n+/* Subroutine of direct_accessor_p and reference_accessor_p.\n+   Determine if COMPONENT_REF is a simple field lookup of this->FIELD_DECL.\n+   We expect a tree of the form:\n+\t     <component_ref:\n+\t       <indirect_ref:S>\n+\t\t <nop_expr:P*\n+\t\t   <parm_decl (this)>\n+\t\t <field_decl (FIELD_DECL)>>>.  */\n+\n+static bool\n+field_access_p (tree component_ref, tree field_decl, tree field_type)\n+{\n+  if (!matches_code_and_type_p (component_ref, COMPONENT_REF, field_type))\n+    return false;\n+\n+  tree indirect_ref = TREE_OPERAND (component_ref, 0);\n+  if (TREE_CODE (indirect_ref) != INDIRECT_REF)\n+    return false;\n+\n+  tree ptr = STRIP_NOPS (TREE_OPERAND (indirect_ref, 0));\n+  if (!is_this_parameter (ptr))\n+    return false;\n+\n+  /* Must access the correct field.  */\n+  if (TREE_OPERAND (component_ref, 1) != field_decl)\n+    return false;\n+  return true;\n+}\n+\n+/* Subroutine of field_accessor_p.\n+\n+   Assuming that INIT_EXPR has already had its code and type checked,\n+   determine if it is a simple accessor for FIELD_DECL\n+   (of type FIELD_TYPE).\n+\n+   Specifically, a simple accessor within struct S of the form:\n+       T get_field () { return m_field; }\n+   should have a DECL_SAVED_TREE of the form:\n+       <return_expr\n+\t <init_expr:T\n+\t   <result_decl:T\n+\t   <nop_expr:T\n+\t     <component_ref:\n+\t       <indirect_ref:S>\n+\t\t <nop_expr:P*\n+\t\t   <parm_decl (this)>\n+\t\t <field_decl (FIELD_DECL)>>>.  */\n+\n+static bool\n+direct_accessor_p (tree init_expr, tree field_decl, tree field_type)\n+{\n+  tree result_decl = TREE_OPERAND (init_expr, 0);\n+  if (!matches_code_and_type_p (result_decl, RESULT_DECL, field_type))\n+    return false;\n+\n+  tree component_ref = STRIP_NOPS (TREE_OPERAND (init_expr, 1));\n+  if (!field_access_p (component_ref, field_decl, field_type))\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Subroutine of field_accessor_p.\n+\n+   Assuming that INIT_EXPR has already had its code and type checked,\n+   determine if it is a \"reference\" accessor for FIELD_DECL\n+   (of type FIELD_REFERENCE_TYPE).\n+\n+   Specifically, a simple accessor within struct S of the form:\n+       T& get_field () { return m_field; }\n+   should have a DECL_SAVED_TREE of the form:\n+       <return_expr\n+\t <init_expr:T&\n+\t   <result_decl:T&\n+\t   <nop_expr: T&\n+\t     <addr_expr: T*\n+\t       <component_ref:T\n+\t\t <indirect_ref:S\n+\t\t   <nop_expr\n+\t\t     <parm_decl (this)>>\n+\t\t   <field (FIELD_DECL)>>>>>>.  */\n+static bool\n+reference_accessor_p (tree init_expr, tree field_decl, tree field_type,\n+\t\t      tree field_reference_type)\n+{\n+  tree result_decl = TREE_OPERAND (init_expr, 0);\n+  if (!matches_code_and_type_p (result_decl, RESULT_DECL, field_reference_type))\n+    return false;\n+\n+  tree field_pointer_type = build_pointer_type (field_type);\n+  tree addr_expr = STRIP_NOPS (TREE_OPERAND (init_expr, 1));\n+  if (!matches_code_and_type_p (addr_expr, ADDR_EXPR, field_pointer_type))\n+    return false;\n+\n+  tree component_ref = STRIP_NOPS (TREE_OPERAND (addr_expr, 0));\n+\n+  if (!field_access_p (component_ref, field_decl, field_type))\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Return true if FN is an accessor method for FIELD_DECL.\n+   i.e. a method of the form { return FIELD; }, with no\n+   conversions.\n+\n+   If CONST_P, then additionally require that FN be a const\n+   method.  */\n+\n+static bool\n+field_accessor_p (tree fn, tree field_decl, bool const_p)\n+{\n+  if (TREE_CODE (fn) != FUNCTION_DECL)\n+    return false;\n+\n+  /* We don't yet support looking up static data, just fields.  */\n+  if (TREE_CODE (field_decl) != FIELD_DECL)\n+    return false;\n+\n+  tree fntype = TREE_TYPE (fn);\n+  if (TREE_CODE (fntype) != METHOD_TYPE)\n+    return false;\n+\n+  /* If the field is accessed via a const \"this\" argument, verify\n+     that the \"this\" parameter is const.  */\n+  if (const_p)\n+    {\n+      tree this_type = type_of_this_parm (fntype);\n+      if (!TYPE_READONLY (this_type))\n+\treturn false;\n+    }\n+\n+  tree saved_tree = DECL_SAVED_TREE (fn);\n+\n+  if (saved_tree == NULL_TREE)\n+    return false;\n+\n+  if (TREE_CODE (saved_tree) != RETURN_EXPR)\n+    return false;\n+\n+  tree init_expr = TREE_OPERAND (saved_tree, 0);\n+  if (TREE_CODE (init_expr) != INIT_EXPR)\n+    return false;\n+\n+  /* Determine if this is a simple accessor within struct S of the form:\n+       T get_field () { return m_field; }.  */\n+   tree field_type = TREE_TYPE (field_decl);\n+  if (cxx_types_compatible_p (TREE_TYPE (init_expr), field_type))\n+    return direct_accessor_p (init_expr, field_decl, field_type);\n+\n+  /* Failing that, determine if it is an accessor of the form:\n+       T& get_field () { return m_field; }.  */\n+  tree field_reference_type = cp_build_reference_type (field_type, false);\n+  if (cxx_types_compatible_p (TREE_TYPE (init_expr), field_reference_type))\n+    return reference_accessor_p (init_expr, field_decl, field_type,\n+\t\t\t\t field_reference_type);\n+\n+  return false;\n+}\n+\n+/* Callback data for dfs_locate_field_accessor_pre.  */\n+\n+struct locate_field_data\n+{\n+  locate_field_data (tree field_decl_, bool const_p_)\n+  : field_decl (field_decl_), const_p (const_p_) {}\n+\n+  tree field_decl;\n+  bool const_p;\n+};\n+\n+/* Return a FUNCTION_DECL that is an \"accessor\" method for DATA, a FIELD_DECL,\n+   callable via binfo, if one exists, otherwise return NULL_TREE.\n+\n+   Callback for dfs_walk_once_accessible for use within\n+   locate_field_accessor.  */\n+\n+static tree\n+dfs_locate_field_accessor_pre (tree binfo, void *data)\n+{\n+  locate_field_data *lfd = (locate_field_data *)data;\n+  tree type = BINFO_TYPE (binfo);\n+\n+  vec<tree, va_gc> *method_vec;\n+  tree fn;\n+  size_t i;\n+\n+  if (!CLASS_TYPE_P (type))\n+    return NULL_TREE;\n+\n+  method_vec = CLASSTYPE_METHOD_VEC (type);\n+  if (!method_vec)\n+    return NULL_TREE;\n+\n+  for (i = 0; vec_safe_iterate (method_vec, i, &fn); ++i)\n+    if (fn)\n+      if (field_accessor_p (fn, lfd->field_decl, lfd->const_p))\n+\treturn fn;\n+\n+  return NULL_TREE;\n+}\n+\n+/* Return a FUNCTION_DECL that is an \"accessor\" method for FIELD_DECL,\n+   callable via BASETYPE_PATH, if one exists, otherwise return NULL_TREE.  */\n+\n+tree\n+locate_field_accessor (tree basetype_path, tree field_decl, bool const_p)\n+{\n+  if (TREE_CODE (basetype_path) != TREE_BINFO)\n+    return NULL_TREE;\n+\n+  /* Walk the hierarchy, looking for a method of some base class that allows\n+     access to the field.  */\n+  locate_field_data lfd (field_decl, const_p);\n+  return dfs_walk_once_accessible (basetype_path, /*friends=*/true,\n+\t\t\t\t   dfs_locate_field_accessor_pre,\n+\t\t\t\t   NULL, &lfd);\n+}\n+\n /* Check that virtual overrider OVERRIDER is acceptable for base function\n    BASEFN. Issue diagnostic, and return zero, if unacceptable.  */\n "}, {"sha": "d3249fedd8d89131329a2f69ff020cc59c4b102b", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10791753c191d1f9d886e8977ff331b28d48398d/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10791753c191d1f9d886e8977ff331b28d48398d/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=10791753c191d1f9d886e8977ff331b28d48398d", "patch": "@@ -305,11 +305,13 @@ perform_deferred_access_checks (tsubst_flags_t complain)\n \n /* Defer checking the accessibility of DECL, when looked up in\n    BINFO. DIAG_DECL is the declaration to use to print diagnostics.\n-   Return value like perform_access_checks above.  */\n+   Return value like perform_access_checks above.\n+   If non-NULL, report failures to AFI.  */\n \n bool\n perform_or_defer_access_check (tree binfo, tree decl, tree diag_decl,\n-\t\t\t       tsubst_flags_t complain)\n+\t\t\t       tsubst_flags_t complain,\n+\t\t\t       access_failure_info *afi)\n {\n   int i;\n   deferred_access *ptr;\n@@ -328,7 +330,7 @@ perform_or_defer_access_check (tree binfo, tree decl, tree diag_decl,\n   /* If we are not supposed to defer access checks, just check now.  */\n   if (ptr->deferring_access_checks_kind == dk_no_deferred)\n     {\n-      bool ok = enforce_access (binfo, decl, diag_decl, complain);\n+      bool ok = enforce_access (binfo, decl, diag_decl, complain, afi);\n       return (complain & tf_error) ? true : ok;\n     }\n "}, {"sha": "8c94d20388773f0bd7724f153c87caf9e1f142c6", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 44, "deletions": 1, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10791753c191d1f9d886e8977ff331b28d48398d/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10791753c191d1f9d886e8977ff331b28d48398d/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=10791753c191d1f9d886e8977ff331b28d48398d", "patch": "@@ -2647,6 +2647,46 @@ check_template_keyword (tree decl)\n     }\n }\n \n+/* Record that an access failure occurred on BASETYPE_PATH attempting\n+   to access FIELD_DECL.  */\n+\n+void\n+access_failure_info::record_access_failure (tree basetype_path,\n+\t\t\t\t\t    tree field_decl)\n+{\n+  m_was_inaccessible = true;\n+  m_basetype_path = basetype_path;\n+  m_field_decl = field_decl;\n+}\n+\n+/* If an access failure was recorded, then attempt to locate an\n+   accessor function for the pertinent field, and if one is\n+   available, add a note and fix-it hint suggesting using it.  */\n+\n+void\n+access_failure_info::maybe_suggest_accessor (bool const_p) const\n+{\n+  if (!m_was_inaccessible)\n+    return;\n+\n+  tree accessor\n+    = locate_field_accessor (m_basetype_path, m_field_decl, const_p);\n+  if (!accessor)\n+    return;\n+\n+  /* The accessor must itself be accessible for it to be a reasonable\n+     suggestion.  */\n+  if (!accessible_p (m_basetype_path, accessor, true))\n+    return;\n+\n+  rich_location richloc (line_table, input_location);\n+  pretty_printer pp;\n+  pp_printf (&pp, \"%s()\", IDENTIFIER_POINTER (DECL_NAME (accessor)));\n+  richloc.add_fixit_replace (pp_formatted_text (&pp));\n+  inform_at_rich_loc (&richloc, \"field %q#D can be accessed via %q#D\",\n+\t\t      m_field_decl, accessor);\n+}\n+\n /* This function is called by the parser to process a class member\n    access expression of the form OBJECT.NAME.  NAME is a node used by\n    the parser to represent a name; it is not yet a DECL.  It may,\n@@ -2829,8 +2869,11 @@ finish_class_member_access_expr (cp_expr object, tree name, bool template_p,\n       else\n \t{\n \t  /* Look up the member.  */\n+\t  access_failure_info afi;\n \t  member = lookup_member (access_path, name, /*protect=*/1,\n-\t\t\t\t  /*want_type=*/false, complain);\n+\t\t\t\t  /*want_type=*/false, complain,\n+\t\t\t\t  &afi);\n+\t  afi.maybe_suggest_accessor (TYPE_READONLY (object_type));\n \t  if (member == NULL_TREE)\n \t    {\n \t      if (dependent_type_p (object_type))"}, {"sha": "b3dd772e7da1089d8ffd981d221f3be2f8393a02", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10791753c191d1f9d886e8977ff331b28d48398d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10791753c191d1f9d886e8977ff331b28d48398d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=10791753c191d1f9d886e8977ff331b28d48398d", "patch": "@@ -1,3 +1,10 @@\n+2017-05-16  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* g++.dg/other/accessor-fixits-1.C: New test case.\n+\t* g++.dg/other/accessor-fixits-2.C: New test case.\n+\t* g++.dg/other/accessor-fixits-3.C: New test case.\n+\t* g++.dg/other/accessor-fixits-4.C: New test case.\n+\n 2017-05-16  Carl Love  <cel@us.ibm.com>\n \n \t* gcc.target/powerpc/builtins-3.c: New vec_mule, vec_mulo test cases."}, {"sha": "cc96b8776710ed004e0943f73399a5d943e01063", "filename": "gcc/testsuite/g++.dg/other/accessor-fixits-1.C", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10791753c191d1f9d886e8977ff331b28d48398d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Faccessor-fixits-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10791753c191d1f9d886e8977ff331b28d48398d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Faccessor-fixits-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Faccessor-fixits-1.C?ref=10791753c191d1f9d886e8977ff331b28d48398d", "patch": "@@ -0,0 +1,178 @@\n+// { dg-options \"-fdiagnostics-show-caret\" }\n+\n+class t1\n+{\n+public:\n+  int get_color () const { return m_color; }\n+  int get_shape () const { return m_shape; }\n+\n+private:\n+  int m_color;\n+\n+protected:\n+  int m_shape;\n+};\n+\n+int test_access_t1_color (t1 &ref)\n+{\n+  return ref.m_color; // { dg-error \".int t1::m_color. is private within this context\" }\n+  /* { dg-begin-multiline-output \"\" }\n+   return ref.m_color;\n+              ^~~~~~~\n+     { dg-end-multiline-output \"\" } */\n+\n+  // { dg-message \"declared private here\" \"\" { target *-*-* } 10 }\n+  /* { dg-begin-multiline-output \"\" }\n+   int m_color;\n+       ^~~~~~~\n+     { dg-end-multiline-output \"\" } */\n+\n+  // { dg-message \"field .int t1::m_color. can be accessed via .int t1::get_color\\\\(\\\\) const.\" \"\" { target *-*-* } .-12 }\n+  /* { dg-begin-multiline-output \"\" }\n+   return ref.m_color;\n+              ^~~~~~~\n+              get_color()\n+     { dg-end-multiline-output \"\" } */\n+}\n+\n+int test_access_t1_shape (t1 &ref)\n+{\n+  return ref.m_shape; // { dg-error \".int t1::m_shape. is protected within this context\" }\n+  /* { dg-begin-multiline-output \"\" }\n+   return ref.m_shape;\n+              ^~~~~~~\n+     { dg-end-multiline-output \"\" } */\n+\n+  // { dg-message \"declared protected here\" \"\" { target *-*-* } 13 }\n+  /* { dg-begin-multiline-output \"\" }\n+   int m_shape;\n+       ^~~~~~~\n+     { dg-end-multiline-output \"\" } */\n+\n+  // { dg-message \"field .int t1::m_shape. can be accessed via .int t1::get_shape\\\\(\\\\) const.\" \"\" { target *-*-* } .-12 }\n+  /* { dg-begin-multiline-output \"\" }\n+   return ref.m_shape;\n+              ^~~~~~~\n+              get_shape()\n+     { dg-end-multiline-output \"\" } */\n+}\n+\n+int test_deref_t1_color (t1 *ptr)\n+{\n+  return ptr->m_color; // { dg-error \".int t1::m_color. is private within this context\" }\n+  /* { dg-begin-multiline-output \"\" }\n+   return ptr->m_color;\n+               ^~~~~~~\n+     { dg-end-multiline-output \"\" } */\n+\n+\n+  /* { dg-begin-multiline-output \"\" }\n+   int m_color;\n+       ^~~~~~~\n+     { dg-end-multiline-output \"\" } */\n+\n+  // { dg-message \"field .int t1::m_color. can be accessed via .int t1::get_color\\\\(\\\\) const.\" \"\" { target *-*-* } .-12 }\n+  /* { dg-begin-multiline-output \"\" }\n+   return ptr->m_color;\n+               ^~~~~~~\n+               get_color()\n+     { dg-end-multiline-output \"\" } */\n+}\n+\n+int test_deref_t1_shape (t1 *ptr)\n+{\n+  return ptr->m_shape; // { dg-error \".int t1::m_shape. is protected within this context\" }\n+  /* { dg-begin-multiline-output \"\" }\n+   return ptr->m_shape;\n+               ^~~~~~~\n+     { dg-end-multiline-output \"\" } */\n+\n+\n+  /* { dg-begin-multiline-output \"\" }\n+   int m_shape;\n+       ^~~~~~~\n+     { dg-end-multiline-output \"\" } */\n+\n+  // { dg-message \"field .int t1::m_shape. can be accessed via .int t1::get_shape\\\\(\\\\) const.\" \"\" { target *-*-* } .-12 }\n+  /* { dg-begin-multiline-output \"\" }\n+   return ptr->m_shape;\n+               ^~~~~~~\n+               get_shape()\n+     { dg-end-multiline-output \"\" } */\n+}\n+\n+/* Example of public inheritance.  */\n+\n+class t2 : public t1\n+{\n+};\n+\n+int test_deref_t2_color (t2 *ptr)\n+{\n+  return ptr->m_color; // { dg-error \".int t1::m_color. is private within this context\" }\n+  /* { dg-begin-multiline-output \"\" }\n+   return ptr->m_color;\n+               ^~~~~~~\n+     { dg-end-multiline-output \"\" } */\n+\n+\n+  /* { dg-begin-multiline-output \"\" }\n+   int m_color;\n+       ^~~~~~~\n+     { dg-end-multiline-output \"\" } */\n+\n+  // { dg-message \"field .int t1::m_color. can be accessed via .int t1::get_color\\\\(\\\\) const.\" \"\" { target *-*-* } .-12 }\n+  /* { dg-begin-multiline-output \"\" }\n+   return ptr->m_color;\n+               ^~~~~~~\n+               get_color()\n+     { dg-end-multiline-output \"\" } */\n+}\n+\n+/* Example of private inheritance.  */\n+\n+class t3 : private t1\n+{\n+};\n+\n+int test_deref_t3_color (t3 *ptr)\n+{\n+  return ptr->m_color; // { dg-error \".int t1::m_color. is private within this context\" }\n+  /* { dg-begin-multiline-output \"\" }\n+   return ptr->m_color;\n+               ^~~~~~~\n+     { dg-end-multiline-output \"\" } */\n+\n+  /* { dg-begin-multiline-output \"\" }\n+   int m_color;\n+       ^~~~~~~\n+     { dg-end-multiline-output \"\" } */\n+\n+  /* We shouldn't provide a fix-it hint for this case due to the\n+     private inheritance.  */\n+}\n+\n+/* Example of non-public \"accessor\".  */\n+\n+class t4\n+{\n+  int m_field;\n+  int get_field () { return m_field; }\n+};\n+\n+int test_deref_t4_field (t4 *ptr)\n+{\n+  return ptr->m_field; // { dg-error \".int t4::m_field. is private within this context\" }\n+  /* { dg-begin-multiline-output \"\" }\n+   return ptr->m_field;\n+               ^~~~~~~\n+     { dg-end-multiline-output \"\" } */\n+\n+  /* { dg-begin-multiline-output \"\" }\n+   int m_field;\n+       ^~~~~~~\n+     { dg-end-multiline-output \"\" } */\n+\n+  /* We shouldn't provide a fix-it hint for this case, as the accessor is\n+     itself private.  */\n+}"}, {"sha": "e1a2b7865b56c95d2533792c2261eef17fca6759", "filename": "gcc/testsuite/g++.dg/other/accessor-fixits-2.C", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10791753c191d1f9d886e8977ff331b28d48398d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Faccessor-fixits-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10791753c191d1f9d886e8977ff331b28d48398d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Faccessor-fixits-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Faccessor-fixits-2.C?ref=10791753c191d1f9d886e8977ff331b28d48398d", "patch": "@@ -0,0 +1,104 @@\n+// { dg-options \"-fdiagnostics-show-caret\" }\n+\n+/* Test of accessors that return references.  */\n+\n+class t1\n+{\n+public:\n+  int& get_color () { return m_color; }\n+  int& get_shape () { return m_shape; }\n+\n+private:\n+  int m_color;\n+\n+protected:\n+  int m_shape;\n+};\n+\n+int test_access_t1_color (t1 &ref)\n+{\n+  return ref.m_color; // { dg-error \".int t1::m_color. is private within this context\" }\n+  /* { dg-begin-multiline-output \"\" }\n+   return ref.m_color;\n+              ^~~~~~~\n+     { dg-end-multiline-output \"\" } */\n+\n+  // { dg-message \"declared private here\" \"\" { target *-*-* } 12 }\n+  /* { dg-begin-multiline-output \"\" }\n+   int m_color;\n+       ^~~~~~~\n+     { dg-end-multiline-output \"\" } */\n+\n+  // { dg-message \"field .int t1::m_color. can be accessed via .int& t1::get_color\\\\(\\\\).\" \"\" { target *-*-* } .-12 }\n+  /* { dg-begin-multiline-output \"\" }\n+   return ref.m_color;\n+              ^~~~~~~\n+              get_color()\n+     { dg-end-multiline-output \"\" } */\n+}\n+\n+int test_access_t1_shape (t1 &ref)\n+{\n+  return ref.m_shape; // { dg-error \".int t1::m_shape. is protected within this context\" }\n+  /* { dg-begin-multiline-output \"\" }\n+   return ref.m_shape;\n+              ^~~~~~~\n+     { dg-end-multiline-output \"\" } */\n+\n+  // { dg-message \"declared protected here\" \"\" { target *-*-* } 15 }\n+  /* { dg-begin-multiline-output \"\" }\n+   int m_shape;\n+       ^~~~~~~\n+     { dg-end-multiline-output \"\" } */\n+\n+  // { dg-message \"field .int t1::m_shape. can be accessed via .int& t1::get_shape\\\\(\\\\).\" \"\" { target *-*-* } .-12 }\n+  /* { dg-begin-multiline-output \"\" }\n+   return ref.m_shape;\n+              ^~~~~~~\n+              get_shape()\n+     { dg-end-multiline-output \"\" } */\n+}\n+\n+int test_deref_t1_color (t1 *ptr)\n+{\n+  return ptr->m_color; // { dg-error \".int t1::m_color. is private within this context\" }\n+  /* { dg-begin-multiline-output \"\" }\n+   return ptr->m_color;\n+               ^~~~~~~\n+     { dg-end-multiline-output \"\" } */\n+\n+\n+  /* { dg-begin-multiline-output \"\" }\n+   int m_color;\n+       ^~~~~~~\n+     { dg-end-multiline-output \"\" } */\n+\n+  // { dg-message \"field .int t1::m_color. can be accessed via .int& t1::get_color\\\\(\\\\).\" \"\" { target *-*-* } .-12 }\n+  /* { dg-begin-multiline-output \"\" }\n+   return ptr->m_color;\n+               ^~~~~~~\n+               get_color()\n+     { dg-end-multiline-output \"\" } */\n+}\n+\n+int test_deref_t1_shape (t1 *ptr)\n+{\n+  return ptr->m_shape; // { dg-error \".int t1::m_shape. is protected within this context\" }\n+  /* { dg-begin-multiline-output \"\" }\n+   return ptr->m_shape;\n+               ^~~~~~~\n+     { dg-end-multiline-output \"\" } */\n+\n+\n+  /* { dg-begin-multiline-output \"\" }\n+   int m_shape;\n+       ^~~~~~~\n+     { dg-end-multiline-output \"\" } */\n+\n+  // { dg-message \"field .int t1::m_shape. can be accessed via .int& t1::get_shape\\\\(\\\\).\" \"\" { target *-*-* } .-12 }\n+  /* { dg-begin-multiline-output \"\" }\n+   return ptr->m_shape;\n+               ^~~~~~~\n+               get_shape()\n+     { dg-end-multiline-output \"\" } */\n+}"}, {"sha": "27d2eb4d0481db670c0716fe5c39d85935c56db7", "filename": "gcc/testsuite/g++.dg/other/accessor-fixits-3.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10791753c191d1f9d886e8977ff331b28d48398d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Faccessor-fixits-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10791753c191d1f9d886e8977ff331b28d48398d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Faccessor-fixits-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Faccessor-fixits-3.C?ref=10791753c191d1f9d886e8977ff331b28d48398d", "patch": "@@ -0,0 +1,15 @@\n+class foo\n+{\n+public:\n+  static foo& get_singleton () { return s_singleton; }\n+\n+private:\n+  static foo s_singleton;\n+};\n+\n+foo & test_access_singleton ()\n+{\n+  return foo::s_singleton; // { dg-error \".foo foo::s_singleton. is private within this context\" }\n+  // { dg-message \"declared private here\" \"\" { target *-*-* } 7 }\n+  // We don't yet support generating a fix-it hint for this case.\n+}"}, {"sha": "c03dd4ea487e8cb7693462265105ad9a67d26d0a", "filename": "gcc/testsuite/g++.dg/other/accessor-fixits-4.C", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10791753c191d1f9d886e8977ff331b28d48398d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Faccessor-fixits-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10791753c191d1f9d886e8977ff331b28d48398d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Faccessor-fixits-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Faccessor-fixits-4.C?ref=10791753c191d1f9d886e8977ff331b28d48398d", "patch": "@@ -0,0 +1,48 @@\n+// { dg-options \"-fdiagnostics-show-caret\" }\n+\n+class t1\n+{\n+public:\n+  int& get_color () { return m_color; }\n+  int& get_shape () { return m_shape; }\n+\n+private:\n+  int m_color; // { dg-line color_decl }\n+  int m_shape; // { dg-line shape_decl }\n+};\n+\n+int test_const_ptr (const t1 *ptr)\n+{\n+  return ptr->m_color; // { dg-error \".int t1::m_color. is private within this context\" }\n+  /* { dg-begin-multiline-output \"\" }\n+   return ptr->m_color;\n+               ^~~~~~~\n+     { dg-end-multiline-output \"\" } */\n+\n+  // { dg-message \"declared private here\" \"\" { target *-*-* } color_decl }\n+  /* { dg-begin-multiline-output \"\" }\n+   int m_color;\n+       ^~~~~~~\n+     { dg-end-multiline-output \"\" } */\n+\n+  /* We shouldn't issue a suggestion: the accessor is non-const, and we\n+     only have a const ptr.  */\n+}\n+\n+int test_const_reference (const t1 &ref)\n+{\n+  return ref.m_shape; // { dg-error \".int t1::m_shape. is private within this context\" }\n+  /* { dg-begin-multiline-output \"\" }\n+   return ref.m_shape;\n+              ^~~~~~~\n+     { dg-end-multiline-output \"\" } */\n+\n+  // { dg-message \"declared private here\" \"\" { target *-*-* } shape_decl }\n+  /* { dg-begin-multiline-output \"\" }\n+   int m_shape;\n+       ^~~~~~~\n+     { dg-end-multiline-output \"\" } */\n+\n+  /* We shouldn't issue a suggestion: the accessor is non-const, and we\n+     only have a const ptr.  */\n+}"}]}