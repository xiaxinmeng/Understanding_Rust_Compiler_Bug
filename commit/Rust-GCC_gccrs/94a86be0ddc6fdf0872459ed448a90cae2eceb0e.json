{"sha": "94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTRhODZiZTBkZGM2ZmRmMDg3MjQ1OWVkNDQ4YTkwY2FlMmVjZWIwZQ==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2010-11-02T02:35:28Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2010-11-02T02:35:28Z"}, "message": "libstdc++: N3126 draft support.\n\n\t* include/std/chrono: Extend constexpr application.\n\t* testsuite/util/testsuite_common_types.h\n\t(constexpr_default_constructible, constexpr_single_value_constructible)\n\t: Add comments about implied constraints.\n\t* testsuite/20_util/duration/cons/constexpr.cc: Activate all tests.\n\t* testsuite/20_util/time_point/cons/constexpr.cc: Same.\n\t* testsuite/20_util/time_point/requirements/constexpr_functions.cc:\n\tSame.\n\t* testsuite/20_util/ratio/cons/cons_overflow_neg.cc: Adjust line\n\tnumbers.\n\t* testsuite/20_util/time_point_cast/constexpr.cc: New.\n\n\t* include/std/bitset: Use __SIZEOF_* macros to re-create original\n\tlogic instead of slipshod application of\n\tstd::numeric_limits<T>::max() macros.\n\t* testsuite/util/testsuite_common_types.h\n\t(constexpr_default_constructible): Modify.\n\n\t* include/std/chrono: Tested constexpr.\n\t* testsuite/20_util/duration_cast/constexpr.cc: New.\n\t* testsuite/20_util/time_point/cons/constexpr.cc: New.\n\n\t* testsuite/20_util/duration/cons/constexpr.cc: Add single_value tests.\n\t* testsuite/20_util/duration/requirements/typedefs_neg1.cc: Adjust\n\tline numbers.\n\t* testsuite/20_util/duration/requirements/typedefs_neg2.cc: Same.\n\t* testsuite/20_util/duration/requirements/typedefs_neg3.cc: Same.\n\t* testsuite/20_util/time_point/cons/constexpr.cc: Add single_value\n\ttests.\n\t* testsuite/20_util/time_point/requirements/constexpr_functions.cc: Add.\n\n\t* testsuite/util/testsuite_common_types.h: Adjust init.\n\n\t* include/std/chrono (duration): Remove defaulted constructor,\n\treplace with mem-init list.\n\t* testsuite/20_util/duration/cons/constexpr.cc: Add single value.\n\t* testsuite/20_util/duration/requirements/constexpr_functions.cc:\n\tAdd non-static member functions.\n\n\t* testsuite/20_util/default_delete/cons/constexpr.cc: New, xfail.\n\t* testsuite/20_util/enable_shared_from_this/cons/constexpr.cc: Same.\n\t* testsuite/20_util/shared_ptr/cons/constexpr.cc: Same.\n\t* testsuite/20_util/time_point/requirements/constexpr_functions.cc:\n\tSame.\n\t* testsuite/20_util/unique_ptr/cons/constexpr.cc: Same.\n\t* testsuite/20_util/weak_ptr/cons/constexpr.cc: Same.\n\n\t* include/std/bitset: Add constexpr as per N3126 draft.\n\t* testsuite/23_containers/bitset/cons/constexpr.cc: New.\n\t* testsuite/23_containers/bitset/requirements/constexpr_functions.cc:\n\tNew.\n\n\t* testsuite/util/testsuite_common_types.h: Reset condition.\n\n\t* include/bits/random.h: Remove misleading comments.\n\t* include/bits/regex.h: Add constexpr.\n\t* testsuite/28_regex/05_constants/syntax_option_type.cc: Add tests.\n\t* testsuite/28_regex/08_basic_regex/requirements/constexpr_data.cc: New.\n\n\tPR libstdc++/46134\n\t* include/std/chrono: Use default constructor.\n\t* testsuite/util/testsuite_common_types.h\n\t(constexpr_default_constructible): Adjust condition.\n\n\tPR libstdc++/46133\n\t* include/std/complex: Adjust complex specialization default\n\tconstructors for constexpr.\n\t* testsuite/26_numerics/complex/cons/constexpr.cc: Enable tests.\n\n\t* include/bits/random.h: Adjust for constexpr as per N3126 draft.\n\t* testsuite/26_numerics/random/discard_block_engine/requirements/\n\tconstexpr_data.cc: New.\n\t* testsuite/26_numerics/random/discard_block_engine/requirements/\n\tconstexpr_functions.cc: New.\n\t* testsuite/26_numerics/random/independent_bits_engine/requirements/\n\tconstexpr_functions.cc: New.\n\t* testsuite/26_numerics/random/linear_congruential_engine/requirements/\n\tconstexpr_data.cc: New.\n\t* testsuite/26_numerics/random/linear_congruential_engine/requirements/\n\tconstexpr_functions.cc: New.\n\t* testsuite/26_numerics/random/mersenne_twister_engine/requirements/\n\tconstexpr_data.cc: New.\n\t* testsuite/26_numerics/random/mersenne_twister_engine/requirements/\n\tconstexpr_functions.cc: New.\n\t* testsuite/26_numerics/random/shuffle_order_engine/requirements/\n\tconstexpr_data.cc: New.\n\t* testsuite/26_numerics/random/shuffle_order_engine/requirements/\n\tconstexpr_functions.cc: New.\n\t* testsuite/26_numerics/random/subtract_with_carry_engine/requirements/\n\tconstexpr_data.cc: New.\n\t* testsuite/26_numerics/random/subtract_with_carry_engine/requirements/\n\tconstexpr_functions.cc: New.\n\n\t* include/bits/stream_iterator.h: Add constexpr as per N3126 draft.\n\t* include/bits/streambuf_iterator.h: Same.\n\t* include/std/complex: Same.\n\t* testsuite/24_iterators/istream_iterator/cons/constexpr.cc: New.\n\t* testsuite/24_iterators/istreambuf_iterator/cons/constexpr.cc: New.\n\t* testsuite/26_numerics/complex/cons/constexpr.cc: New.\n\t* testsuite/26_numerics/complex/requirements/constexpr_functions.cc:\n\tNew.\n\n\t* include/bits/char_traits.h: Add constexpr as per N3126 draft.\n\t* testsuite/21_strings/char_traits/requirements/constexpr_functions.cc:\n\tNew.\n\n\t* include/tr1_impl/array: Add constexpr as per N3126 draft.\n\t* testsuite/23_containers/array/requirements/\n\tconstexpr_functions.cc: New.\n\n\t* include/bits/shared_ptr.h: Revert changes.\n\t* include/bits/unique_ptr.h: Same.\n\n\t* include/std/chrono: Adjust.\n\t* include/tr1_impl/type_traits: Same.\n\n\t* testsuite/util/testsuite_common_types.h: Add test functors.\n\t* testsuite/20_util/duration/cons/constexpr.cc: New.\n\t* testsuite/20_util/duration/requirements/constexpr_functions.cc: Same.\n\t* testsuite/20_util/pair/cons/constexpr.cc: Same.\n\t* testsuite/20_util/ratio/requirements/constexpr_data.cc: Same.\n\t* testsuite/27_io/ios_base/types/fmtflags/constexpr_operators.cc: Same.\n\t* testsuite/27_io/ios_base/types/iostate/constexpr_operators.cc: Same.\n\t* testsuite/27_io/ios_base/types/openmode/constexpr_operators.cc: Same.\n\t* testsuite/30_threads/call_once/constexpr.cc: Same.\n\t* testsuite/30_threads/mutex/cons/constexpr.cc: Same.\n\t* testsuite/30_threads/once_flag/cons/constexpr.cc: Same.\n\t* testsuite/tr1/4_metaprogramming/integral_constant/requirements/\n\tconstexpr_data.cc: Same.\n\n\t* testsuite/29_atomics/atomic/cons/assign_neg.cc: Adjust line numbers.\n\t* testsuite/29_atomics/atomic/cons/copy_neg.cc: Same.\n\t* testsuite/29_atomics/atomic_integral/cons/assign_neg.cc: Same.\n\t* testsuite/29_atomics/atomic_integral/cons/copy_neg.cc: Same.\n\t* testsuite/29_atomics/atomic_integral/operators/bitwise_neg.cc: Same.\n\n\t* include/bits/allocator.h: Add constexpr as per N3126 draft.\n\t* include/bits/ios_base.h: Same.\n\t* include/bits/shared_ptr.h: Same.\n\t* include/bits/unique_ptr.h: Same.\n\t* include/bits/stl_iterator.h: Same.\n\t* include/bits/stl_pair.h: Same.\n\t* include/std/tuple: Same.\n\t* include/tr1_impl/type_traits: Same.\n\t* include/std/chrono: Same.\n\t* include/std/ratio: Same.\n\t* include/std/mutex: Same.\n\t* src/mutex.cc: Same.\n\t* testsuite/20_util/duration/requirements/typedefs_neg1.cc: Adjust.\n\t* testsuite/20_util/duration/requirements/typedefs_neg2.cc: Same.\n\t* testsuite/20_util/duration/requirements/typedefs_neg3.cc: Same.\n\t* testsuite/20_util/weak_ptr/comparison/cmp_neg.cc: Same.\n\t* testsuite/27_io/ios_base/cons/assign_neg.cc: Same.\n\t* testsuite/27_io/ios_base/cons/copy_neg.cc: Same.\n\n\t* doc/doxygen/user.cfg.in: Replace _GLIBCXX_USE_CONSTEXPR,\n\t_GLIBCXX_CONSTEXPR for doxygen generation.\n\n\t* src/limits.cc: Undef.\n\t* testsuite/29_atomics/atomic/cons/constexpr.cc: Adjust.\n\t* testsuite/29_atomics/atomic_address/cons/constexpr.cc: Same.\n\t* testsuite/29_atomics/atomic_integral/cons/constexpr.cc: Same.\n\t* testsuite/29_atomics/atomic_integral/operators/bitwise_neg.c: Same.\n\t* testsuite/18_support/numeric_limits/constexpr.cc: To...\n\t* testsuite/18_support/numeric_limits/requirements/\n\tconstexpr_data.cc, constexpr_functions.cc: ...this\n\n\t* testsuite/util/testsuite_common_types.h\n\t(constexpr_single_value_constructible): Add.\n\t* testsuite/29_atomics/atomic/cons/constexpr.cc: Adjust name.\n\t* testsuite/29_atomics/atomic_integral/cons/constexpr.cc: Same.\n\t* testsuite/29_atomics/atomic_address/cons/constexpr.cc: New.\n\t* testsuite/18_support/numeric_limits/constexpr.cc: New.\n\n\t* testsuite/29_atomics/atomic/cons/assign_neg.cc: Adjust line numbers.\n\t* testsuite/29_atomics/atomic/cons/constexpr.cc: Same.\n\t* testsuite/29_atomics/atomic/cons/copy_neg.cc: Same.\n\t* testsuite/29_atomics/atomic_integral/cons/assign_neg.cc: Same.\n\t* testsuite/29_atomics/atomic_integral/cons/constexpr.cc: Same.\n\t* testsuite/29_atomics/atomic_integral/cons/copy_neg.cc: Same.\n\t* testsuite/29_atomics/atomic_integral/operators/bitwise_neg.cc: Same.\n\t* testsuite/29_atomics/atomic_integral/operators/decrement_neg.cc: Same.\n\t* testsuite/29_atomics/atomic_integral/operators/increment_neg.cc: Same.\n\n\t* include/bits/c++config (_GLIBCXX_CONSTEXPR): Add.\n\t(_GLIBCXX_USE_CONSTEXPR): Add.\n\t* include/std/limits: Use it.\n\t* src/limits.cc: Adjust.\n\t* testsuite/ext/profile/mutex_extensions.cc: Change line number.\n\n\t* include/bits/atomic_0.h: Rework for N3126 draft, add constexpr.\n\t* include/bits/atomic_2.h: Same.\n\t* include/bits/atomic_base.h: Same.\n\t* include/std/atomic: Same.\n\t* src/atomic.cc: Same.\n\t* include/bits/atomicfwd_c.h: Remove.\n\t* include/bits/atomicfwd_cxx.h: Remove.\n\t* include/c_compatibility/stdatomic.h: Remove.\n\t* include/Makefile.am: Remove atomicfwd_c.h, atomicfwd_cxx.h,\n\tstdatomic.h.\n\t* include/Makefile.in: Regenerate.\n\t* doc/xml/manual/using.xml: Update list of header files for changes.\n\t* testsuite/util/testsuite_common_types.h\n\t(constexpr_constructible): Add.\n\t* testsuite/29_atomics/atomic/cons/constexpr.cc: New.\n\t* testsuite/29_atomics/atomic_integral/cons/constexpr.cc: New.\n\t* testsuite/17_intro/headers/c++200x/stdc++.cc: Modify.\n\t* testsuite/29_atomics/atomic/cons/assign_neg.cc: Same.\n\t* testsuite/29_atomics/atomic_address/cons/assign_neg.cc: Same.\n\t* testsuite/29_atomics/atomic_flag/cons/1.cc: Same.\n\t* testsuite/29_atomics/atomic_integral/cons/assign_neg.cc: Same.\n\t* testsuite/29_atomics/headers/atomic/macros.cc: Same.\n\t* testsuite/29_atomics/headers/atomic/types_std_c++0x.cc: Same.\n\t* testsuite/29_atomics/headers/atomic/types_std_c++0x_neg.cc: Same.\n\t* testsuite/29_atomics/atomic_flag/test_and_set/implicit.c: Remove.\n\t* testsuite/29_atomics/atomic_flag/test_and_set/explicit.c: Same.\n\t* testsuite/29_atomics/atomic_flag/clear/1.c: Same.\n\t* testsuite/29_atomics/headers/stdatomic.h/debug_mode.c: Same.\n\t* testsuite/29_atomics/headers/stdatomic.h/functions.c: Same.\n\t* testsuite/29_atomics/headers/stdatomic.h/macros.c: Same.\n\t* testsuite/29_atomics/headers/stdatomic.h/types.c: Same.\n\n\t* testsuite/util/testsuite_abi.cc: Add GLIBCXX_3.4.16.\n\nFrom-SVN: r166171", "tree": {"sha": "0e6b797a6c1a23c50603805706926a5eaa2184f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e6b797a6c1a23c50603805706926a5eaa2184f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/comments", "author": null, "committer": null, "parents": [{"sha": "900484dee595d91a71c7ae63734c199bd137afc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/900484dee595d91a71c7ae63734c199bd137afc6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/900484dee595d91a71c7ae63734c199bd137afc6"}], "stats": {"total": 9050, "additions": 6177, "deletions": 2873}, "files": [{"sha": "c78c71f2bf991fc9bc10c5d5dada821fdec6e7db", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -1,3 +1,229 @@\n+2010-11-01  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* include/std/chrono: Extend constexpr application.\n+\t* testsuite/util/testsuite_common_types.h\n+\t(constexpr_default_constructible, constexpr_single_value_constructible)\n+\t: Add comments about implied constraints.\n+\t* testsuite/20_util/duration/cons/constexpr.cc: Activate all tests.\n+\t* testsuite/20_util/time_point/cons/constexpr.cc: Same.\n+\t* testsuite/20_util/time_point/requirements/constexpr_functions.cc:\n+\tSame.\n+\t* testsuite/20_util/ratio/cons/cons_overflow_neg.cc: Adjust line\n+\tnumbers.\n+\t* testsuite/20_util/time_point_cast/constexpr.cc: New.\n+\n+\t* include/std/bitset: Use __SIZEOF_* macros to re-create original\n+\tlogic instead of slipshod application of\n+\tstd::numeric_limits<T>::max() macros.\n+\t* testsuite/util/testsuite_common_types.h\n+\t(constexpr_default_constructible): Modify.\n+\n+\t* include/std/chrono: Tested constexpr.\n+\t* testsuite/20_util/duration_cast/constexpr.cc: New.\n+\t* testsuite/20_util/time_point/cons/constexpr.cc: New.\n+\n+\t* testsuite/20_util/duration/cons/constexpr.cc: Add single_value tests.\n+\t* testsuite/20_util/duration/requirements/typedefs_neg1.cc: Adjust\n+\tline numbers.\n+\t* testsuite/20_util/duration/requirements/typedefs_neg2.cc: Same.\n+\t* testsuite/20_util/duration/requirements/typedefs_neg3.cc: Same.\n+\t* testsuite/20_util/time_point/cons/constexpr.cc: Add single_value\n+\ttests.\n+\t* testsuite/20_util/time_point/requirements/constexpr_functions.cc: Add.\n+\n+\t* testsuite/util/testsuite_common_types.h: Adjust init.\n+\n+\t* include/std/chrono (duration): Remove defaulted constructor,\n+\treplace with mem-init list.\n+\t* testsuite/20_util/duration/cons/constexpr.cc: Add single value.\n+\t* testsuite/20_util/duration/requirements/constexpr_functions.cc:\n+\tAdd non-static member functions.\n+\n+\t* testsuite/20_util/default_delete/cons/constexpr.cc: New, xfail.\n+\t* testsuite/20_util/enable_shared_from_this/cons/constexpr.cc: Same.\n+\t* testsuite/20_util/shared_ptr/cons/constexpr.cc: Same.\n+\t* testsuite/20_util/time_point/requirements/constexpr_functions.cc:\n+\tSame.\n+\t* testsuite/20_util/unique_ptr/cons/constexpr.cc: Same.\n+\t* testsuite/20_util/weak_ptr/cons/constexpr.cc: Same.\n+\n+\t* include/std/bitset: Add constexpr as per N3126 draft.\n+\t* testsuite/23_containers/bitset/cons/constexpr.cc: New.\n+\t* testsuite/23_containers/bitset/requirements/constexpr_functions.cc:\n+\tNew.\n+\n+\t* testsuite/util/testsuite_common_types.h: Reset condition.\n+\n+\t* include/bits/random.h: Remove misleading comments.\n+\t* include/bits/regex.h: Add constexpr.\n+\t* testsuite/28_regex/05_constants/syntax_option_type.cc: Add tests.\n+\t* testsuite/28_regex/08_basic_regex/requirements/constexpr_data.cc: New.\n+\n+\tPR libstdc++/46134\n+\t* include/std/chrono: Use default constructor.\n+\t* testsuite/util/testsuite_common_types.h\n+\t(constexpr_default_constructible): Adjust condition.\n+\n+\tPR libstdc++/46133\n+\t* include/std/complex: Adjust complex specialization default\n+\tconstructors for constexpr.\n+\t* testsuite/26_numerics/complex/cons/constexpr.cc: Enable tests.\n+\n+\t* include/bits/random.h: Adjust for constexpr as per N3126 draft.\n+\t* testsuite/26_numerics/random/discard_block_engine/requirements/\n+\tconstexpr_data.cc: New.\n+\t* testsuite/26_numerics/random/discard_block_engine/requirements/\n+\tconstexpr_functions.cc: New.\n+\t* testsuite/26_numerics/random/independent_bits_engine/requirements/\n+\tconstexpr_functions.cc: New.\n+\t* testsuite/26_numerics/random/linear_congruential_engine/requirements/\n+\tconstexpr_data.cc: New.\n+\t* testsuite/26_numerics/random/linear_congruential_engine/requirements/\n+\tconstexpr_functions.cc: New.\n+\t* testsuite/26_numerics/random/mersenne_twister_engine/requirements/\n+\tconstexpr_data.cc: New.\n+\t* testsuite/26_numerics/random/mersenne_twister_engine/requirements/\n+\tconstexpr_functions.cc: New.\n+\t* testsuite/26_numerics/random/shuffle_order_engine/requirements/\n+\tconstexpr_data.cc: New.\n+\t* testsuite/26_numerics/random/shuffle_order_engine/requirements/\n+\tconstexpr_functions.cc: New.\n+\t* testsuite/26_numerics/random/subtract_with_carry_engine/requirements/\n+\tconstexpr_data.cc: New.\n+\t* testsuite/26_numerics/random/subtract_with_carry_engine/requirements/\n+\tconstexpr_functions.cc: New.\n+\n+\t* include/bits/stream_iterator.h: Add constexpr as per N3126 draft.\n+\t* include/bits/streambuf_iterator.h: Same.\n+\t* include/std/complex: Same.\n+\t* testsuite/24_iterators/istream_iterator/cons/constexpr.cc: New.\n+\t* testsuite/24_iterators/istreambuf_iterator/cons/constexpr.cc: New.\n+\t* testsuite/26_numerics/complex/cons/constexpr.cc: New.\n+\t* testsuite/26_numerics/complex/requirements/constexpr_functions.cc:\n+\tNew.\n+\n+\t* include/bits/char_traits.h: Add constexpr as per N3126 draft.\n+\t* testsuite/21_strings/char_traits/requirements/constexpr_functions.cc:\n+\tNew.\n+\n+\t* include/tr1_impl/array: Add constexpr as per N3126 draft.\n+\t* testsuite/23_containers/array/requirements/\n+\tconstexpr_functions.cc: New.\n+\n+\t* include/bits/shared_ptr.h: Revert changes.\n+\t* include/bits/unique_ptr.h: Same.\n+\n+\t* include/std/chrono: Adjust.\n+\t* include/tr1_impl/type_traits: Same.\n+\n+\t* testsuite/util/testsuite_common_types.h: Add test functors.\n+\t* testsuite/20_util/duration/cons/constexpr.cc: New.\n+\t* testsuite/20_util/duration/requirements/constexpr_functions.cc: Same.\n+\t* testsuite/20_util/pair/cons/constexpr.cc: Same.\n+\t* testsuite/20_util/ratio/requirements/constexpr_data.cc: Same.\n+\t* testsuite/27_io/ios_base/types/fmtflags/constexpr_operators.cc: Same.\n+\t* testsuite/27_io/ios_base/types/iostate/constexpr_operators.cc: Same.\n+\t* testsuite/27_io/ios_base/types/openmode/constexpr_operators.cc: Same.\n+\t* testsuite/30_threads/call_once/constexpr.cc: Same.\n+\t* testsuite/30_threads/mutex/cons/constexpr.cc: Same.\n+\t* testsuite/30_threads/once_flag/cons/constexpr.cc: Same.\n+\t* testsuite/tr1/4_metaprogramming/integral_constant/requirements/\n+\tconstexpr_data.cc: Same.\n+\n+\t* testsuite/29_atomics/atomic/cons/assign_neg.cc: Adjust line numbers.\n+\t* testsuite/29_atomics/atomic/cons/copy_neg.cc: Same.\n+\t* testsuite/29_atomics/atomic_integral/cons/assign_neg.cc: Same.\n+\t* testsuite/29_atomics/atomic_integral/cons/copy_neg.cc: Same.\n+\t* testsuite/29_atomics/atomic_integral/operators/bitwise_neg.cc: Same.\n+\n+\t* include/bits/allocator.h: Add constexpr as per N3126 draft.\n+\t* include/bits/ios_base.h: Same.\n+\t* include/bits/shared_ptr.h: Same.\n+\t* include/bits/unique_ptr.h: Same.\n+\t* include/bits/stl_iterator.h: Same.\n+\t* include/bits/stl_pair.h: Same.\n+\t* include/std/tuple: Same.\n+\t* include/tr1_impl/type_traits: Same.\n+\t* include/std/chrono: Same.\n+\t* include/std/ratio: Same.\n+\t* include/std/mutex: Same.\n+\t* src/mutex.cc: Same.\n+\t* testsuite/20_util/duration/requirements/typedefs_neg1.cc: Adjust.\n+\t* testsuite/20_util/duration/requirements/typedefs_neg2.cc: Same.\n+\t* testsuite/20_util/duration/requirements/typedefs_neg3.cc: Same.\n+\t* testsuite/20_util/weak_ptr/comparison/cmp_neg.cc: Same.\n+\t* testsuite/27_io/ios_base/cons/assign_neg.cc: Same.\n+\t* testsuite/27_io/ios_base/cons/copy_neg.cc: Same.\n+\n+\t* doc/doxygen/user.cfg.in: Replace _GLIBCXX_USE_CONSTEXPR,\n+\t_GLIBCXX_CONSTEXPR for doxygen generation.\n+\n+\t* src/limits.cc: Undef.\n+\t* testsuite/29_atomics/atomic/cons/constexpr.cc: Adjust.\n+\t* testsuite/29_atomics/atomic_address/cons/constexpr.cc: Same.\n+\t* testsuite/29_atomics/atomic_integral/cons/constexpr.cc: Same.\n+\t* testsuite/29_atomics/atomic_integral/operators/bitwise_neg.c: Same.\n+\t* testsuite/18_support/numeric_limits/constexpr.cc: To...\n+\t* testsuite/18_support/numeric_limits/requirements/\n+\tconstexpr_data.cc, constexpr_functions.cc: ...this\n+\n+\t* testsuite/util/testsuite_common_types.h\n+\t(constexpr_single_value_constructible): Add.\n+\t* testsuite/29_atomics/atomic/cons/constexpr.cc: Adjust name.\n+\t* testsuite/29_atomics/atomic_integral/cons/constexpr.cc: Same.\n+\t* testsuite/29_atomics/atomic_address/cons/constexpr.cc: New.\n+\t* testsuite/18_support/numeric_limits/constexpr.cc: New.\n+\n+\t* testsuite/29_atomics/atomic/cons/assign_neg.cc: Adjust line numbers.\n+\t* testsuite/29_atomics/atomic/cons/constexpr.cc: Same.\n+\t* testsuite/29_atomics/atomic/cons/copy_neg.cc: Same.\n+\t* testsuite/29_atomics/atomic_integral/cons/assign_neg.cc: Same.\n+\t* testsuite/29_atomics/atomic_integral/cons/constexpr.cc: Same.\n+\t* testsuite/29_atomics/atomic_integral/cons/copy_neg.cc: Same.\n+\t* testsuite/29_atomics/atomic_integral/operators/bitwise_neg.cc: Same.\n+\t* testsuite/29_atomics/atomic_integral/operators/decrement_neg.cc: Same.\n+\t* testsuite/29_atomics/atomic_integral/operators/increment_neg.cc: Same.\n+\n+\t* include/bits/c++config (_GLIBCXX_CONSTEXPR): Add.\n+\t(_GLIBCXX_USE_CONSTEXPR): Add.\n+\t* include/std/limits: Use it.\n+\t* src/limits.cc: Adjust.\n+\t* testsuite/ext/profile/mutex_extensions.cc: Change line number.\n+\n+\t* include/bits/atomic_0.h: Rework for N3126 draft, add constexpr.\n+\t* include/bits/atomic_2.h: Same.\n+\t* include/bits/atomic_base.h: Same.\n+\t* include/std/atomic: Same.\n+\t* src/atomic.cc: Same.\n+\t* include/bits/atomicfwd_c.h: Remove.\n+\t* include/bits/atomicfwd_cxx.h: Remove.\n+\t* include/c_compatibility/stdatomic.h: Remove.\n+\t* include/Makefile.am: Remove atomicfwd_c.h, atomicfwd_cxx.h,\n+\tstdatomic.h.\n+\t* include/Makefile.in: Regenerate.\n+\t* doc/xml/manual/using.xml: Update list of header files for changes.\n+\t* testsuite/util/testsuite_common_types.h\n+\t(constexpr_constructible): Add.\n+\t* testsuite/29_atomics/atomic/cons/constexpr.cc: New.\n+\t* testsuite/29_atomics/atomic_integral/cons/constexpr.cc: New.\n+\t* testsuite/17_intro/headers/c++200x/stdc++.cc: Modify.\n+\t* testsuite/29_atomics/atomic/cons/assign_neg.cc: Same.\n+\t* testsuite/29_atomics/atomic_address/cons/assign_neg.cc: Same.\n+\t* testsuite/29_atomics/atomic_flag/cons/1.cc: Same.\n+\t* testsuite/29_atomics/atomic_integral/cons/assign_neg.cc: Same.\n+\t* testsuite/29_atomics/headers/atomic/macros.cc: Same.\n+\t* testsuite/29_atomics/headers/atomic/types_std_c++0x.cc: Same.\n+\t* testsuite/29_atomics/headers/atomic/types_std_c++0x_neg.cc: Same.\n+\t* testsuite/29_atomics/atomic_flag/test_and_set/implicit.c: Remove.\n+\t* testsuite/29_atomics/atomic_flag/test_and_set/explicit.c: Same.\n+\t* testsuite/29_atomics/atomic_flag/clear/1.c: Same.\n+\t* testsuite/29_atomics/headers/stdatomic.h/debug_mode.c: Same.\n+\t* testsuite/29_atomics/headers/stdatomic.h/functions.c: Same.\n+\t* testsuite/29_atomics/headers/stdatomic.h/macros.c: Same.\n+\t* testsuite/29_atomics/headers/stdatomic.h/types.c: Same.\n+\n+\t* testsuite/util/testsuite_abi.cc: Add GLIBCXX_3.4.16.\n+\n 2010-11-01  Jason Merrill  <jason@redhat.com>\n \n \t* libsupc++/initializer_list: Decorate with constexpr."}, {"sha": "eec63a016da63e3972ef86f3625aa08bf8f54bf4", "filename": "libstdc++-v3/config/abi/pre/gnu.ver", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -1193,6 +1193,13 @@ GLIBCXX_3.4.15 {\n \n } GLIBCXX_3.4.14;\n \n+GLIBCXX_3.4.16 {\n+\n+    # std::future_category is now a function\n+    _ZSt15future_categoryv;\n+\n+} GLIBCXX_3.4.15;\n+\n # Symbols in the support library (libsupc++) have their own tag.\n CXXABI_1.3 {\n "}, {"sha": "8550aa54bf16477322b9a87bafcb21e067d2a03a", "filename": "libstdc++-v3/doc/doxygen/user.cfg.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Fdoc%2Fdoxygen%2Fuser.cfg.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Fdoc%2Fdoxygen%2Fuser.cfg.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fdoxygen%2Fuser.cfg.in?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -599,6 +599,7 @@ INPUT                  = @srcdir@/doc/doxygen/doxygroups.cc \\\n                          include/complex \\\n                          include/condition_variable \\\n                          include/deque \\\n+                         include/forward_list \\\n                          include/fstream \\\n                          include/functional \\\n                          include/future \\\n@@ -1539,6 +1540,8 @@ PREDEFINED             = __cplusplus \\\n                          _GLIBCXX_END_NESTED_NAMESPACE=} \\\n                          \"_GLIBCXX_TEMPLATE_ARGS=...  \" \\\n                          _GLIBCXX_DEPRECATED \\\n+                         _GLIBCXX_CONSTEXPR=constexpr \\\n+                         _GLIBCXX_USE_CONSTEXPR=constexpr \\\n                          _GLIBCXX_USE_WCHAR_T \\\n                          _GLIBCXX_USE_LONG_LONG \\\n                          _GLIBCXX_USE_C99_STDINT_TR1 \\"}, {"sha": "6e3123e11b120f02ac040ea55a63ab6e7fe469da", "filename": "libstdc++-v3/doc/xml/manual/using.xml", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fusing.xml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fusing.xml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fusing.xml?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -354,10 +354,6 @@ mode, i.e. <literal>-std=c++0x</literal> or <literal>-std=gnu++0x</literal>.\n <entry><filename class=\"headerfile\">cwchar</filename></entry>\n <entry><filename class=\"headerfile\">cwctype</filename></entry>\n </row>\n-<row>\n-<entry><filename class=\"headerfile\">stdatomic.h</filename></entry>\n-</row>\n-\n </tbody>\n </tgroup>\n </table>"}, {"sha": "d1ac203aee7b279753ea5b851fac5e4d6d21364e", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -1,4 +1,4 @@\n-#o# Makefile for the include subdirectory of the GNU C++ Standard library.\n+## Makefile for the include subdirectory of the GNU C++ Standard library.\n ##\n ## Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n ## Free Software Foundation, Inc.\n@@ -80,8 +80,6 @@ bits_headers = \\\n         ${bits_srcdir}/algorithmfwd.h \\\n \t${bits_srcdir}/allocator.h \\\n \t${bits_srcdir}/atomic_base.h \\\n-\t${bits_srcdir}/atomicfwd_c.h \\\n-\t${bits_srcdir}/atomicfwd_cxx.h \\\n \t${bits_srcdir}/atomic_0.h \\\n \t${bits_srcdir}/atomic_2.h \\\n \t${bits_srcdir}/basic_ios.h \\\n@@ -679,8 +677,7 @@ if GLIBCXX_C_HEADERS_C_GLOBAL\n c_compatibility_headers = \\\n \t${c_compatibility_srcdir}/complex.h \\\n \t${c_compatibility_srcdir}/fenv.h \\\n-\t${c_compatibility_srcdir}/tgmath.h \\\n-\t${c_compatibility_srcdir}/stdatomic.h\n+\t${c_compatibility_srcdir}/tgmath.h\n endif\n \n if GLIBCXX_C_HEADERS_C"}, {"sha": "778b0c0445aae84f7e23dd07ab7fd117fa7e4495", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -14,8 +14,6 @@\n # PARTICULAR PURPOSE.\n \n @SET_MAKE@\n-\n-#o# Makefile for the include subdirectory of the GNU C++ Standard library.\n VPATH = @srcdir@\n pkgdatadir = $(datadir)/@PACKAGE@\n pkgincludedir = $(includedir)/@PACKAGE@\n@@ -322,8 +320,6 @@ bits_headers = \\\n         ${bits_srcdir}/algorithmfwd.h \\\n \t${bits_srcdir}/allocator.h \\\n \t${bits_srcdir}/atomic_base.h \\\n-\t${bits_srcdir}/atomicfwd_c.h \\\n-\t${bits_srcdir}/atomicfwd_cxx.h \\\n \t${bits_srcdir}/atomic_0.h \\\n \t${bits_srcdir}/atomic_2.h \\\n \t${bits_srcdir}/basic_ios.h \\\n@@ -914,8 +910,7 @@ c_compatibility_builddir = .\n @GLIBCXX_C_HEADERS_C_GLOBAL_TRUE@c_compatibility_headers = \\\n @GLIBCXX_C_HEADERS_C_GLOBAL_TRUE@\t${c_compatibility_srcdir}/complex.h \\\n @GLIBCXX_C_HEADERS_C_GLOBAL_TRUE@\t${c_compatibility_srcdir}/fenv.h \\\n-@GLIBCXX_C_HEADERS_C_GLOBAL_TRUE@\t${c_compatibility_srcdir}/tgmath.h \\\n-@GLIBCXX_C_HEADERS_C_GLOBAL_TRUE@\t${c_compatibility_srcdir}/stdatomic.h\n+@GLIBCXX_C_HEADERS_C_GLOBAL_TRUE@\t${c_compatibility_srcdir}/tgmath.h\n \n @GLIBCXX_C_HEADERS_C_STD_TRUE@c_compatibility_headers = \n @GLIBCXX_C_HEADERS_C_TRUE@c_compatibility_headers = \\"}, {"sha": "70327acd25b566fddcc27840245414105d14859e", "filename": "libstdc++-v3/include/bits/allocator.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator.h?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -208,7 +208,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n   /// [allocator.tag]\n   struct allocator_arg_t { };\n \n-  static const allocator_arg_t allocator_arg = allocator_arg_t();\n+  constexpr allocator_arg_t allocator_arg = allocator_arg_t();\n \n _GLIBCXX_HAS_NESTED_TYPE(allocator_type)\n "}, {"sha": "cd73e43caefaad2e765c7afcf645c74e0b35e639", "filename": "libstdc++-v3/include/bits/atomic_0.h", "status": "modified", "additions": 400, "deletions": 120, "changes": 520, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_0.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_0.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_0.h?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -1,6 +1,6 @@\n // -*- C++ -*- header.\n \n-// Copyright (C) 2008, 2009\n+// Copyright (C) 2008, 2009, 2010\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -33,24 +33,42 @@\n \n #pragma GCC system_header\n \n-// _GLIBCXX_BEGIN_NAMESPACE(std)\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n \n-  // 0 == __atomic0 == Never lock-free\n+// 0 == __atomic0 == Never lock-free\n namespace __atomic0\n {\n-  struct atomic_flag;\n+  _GLIBCXX_BEGIN_EXTERN_C\n+\n+  void\n+  atomic_flag_clear_explicit(__atomic_flag_base*, memory_order)\n+  _GLIBCXX_NOTHROW;\n+\n+  void\n+  __atomic_flag_wait_explicit(__atomic_flag_base*, memory_order)\n+  _GLIBCXX_NOTHROW;\n+\n+  _GLIBCXX_CONST __atomic_flag_base*\n+  __atomic_flag_for_address(const volatile void* __z) _GLIBCXX_NOTHROW;\n+\n+  _GLIBCXX_END_EXTERN_C\n+\n+  // Implementation specific defines.\n+#define _ATOMIC_MEMBER_ _M_i\n \n   // Implementation specific defines.\n #define _ATOMIC_LOAD_(__a, __x)\t\t\t\t\t\t   \\\n-  ({__typeof__ _ATOMIC_MEMBER_* __p = &_ATOMIC_MEMBER_;\t   \t\t   \\\n+  ({typedef __typeof__(_ATOMIC_MEMBER_) __i_type;                          \\\n+    __i_type* __p = &_ATOMIC_MEMBER_;\t   \t\t\t\t   \\\n     __atomic_flag_base* __g = __atomic_flag_for_address(__p);\t  \t   \\\n     __atomic_flag_wait_explicit(__g, __x);\t\t\t\t   \\\n-    __typeof__ _ATOMIC_MEMBER_ __r = *__p;\t\t\t\t   \\\n+    __i_type __r = *__p;\t\t\t\t\t\t   \\\n     atomic_flag_clear_explicit(__g, __x);\t\t       \t\t   \\\n     __r; })\n \n #define _ATOMIC_STORE_(__a, __m, __x)\t\t\t\t\t   \\\n-  ({__typeof__ _ATOMIC_MEMBER_* __p = &_ATOMIC_MEMBER_;\t   \t\t   \\\n+  ({typedef __typeof__(_ATOMIC_MEMBER_) __i_type;                          \\\n+    __i_type* __p = &_ATOMIC_MEMBER_;\t   \t\t\t\t   \\\n     __typeof__(__m) __v = (__m);\t\t\t       \t\t   \\\n     __atomic_flag_base* __g = __atomic_flag_for_address(__p);\t  \t   \\\n     __atomic_flag_wait_explicit(__g, __x);\t\t\t\t   \\\n@@ -59,34 +77,42 @@ namespace __atomic0\n     __v; })\n \n #define _ATOMIC_MODIFY_(__a, __o, __m, __x)\t\t\t\t   \\\n-  ({__typeof__ _ATOMIC_MEMBER_* __p = &_ATOMIC_MEMBER_;\t   \t\t   \\\n+  ({typedef __typeof__(_ATOMIC_MEMBER_) __i_type;                          \\\n+    __i_type* __p = &_ATOMIC_MEMBER_;\t   \t\t\t\t   \\\n     __typeof__(__m) __v = (__m);\t\t\t       \t\t   \\\n     __atomic_flag_base* __g = __atomic_flag_for_address(__p);\t  \t   \\\n     __atomic_flag_wait_explicit(__g, __x);\t\t\t\t   \\\n-    __typeof__ _ATOMIC_MEMBER_ __r = *__p;\t\t\t\t   \\\n+    __i_type __r = *__p;\t\t       \t\t\t\t   \\\n     *__p __o __v;\t\t\t\t\t       \t\t   \\\n     atomic_flag_clear_explicit(__g, __x);\t\t       \t\t   \\\n     __r; })\n \n #define _ATOMIC_CMPEXCHNG_(__a, __e, __m, __x)\t\t\t\t   \\\n-  ({__typeof__ _ATOMIC_MEMBER_* __p = &_ATOMIC_MEMBER_;\t   \t\t   \\\n+  ({typedef __typeof__(_ATOMIC_MEMBER_) __i_type;                          \\\n+    __i_type* __p = &_ATOMIC_MEMBER_;\t   \t\t\t\t   \\\n     __typeof__(__e) __q = (__e);\t\t\t       \t\t   \\\n     __typeof__(__m) __v = (__m);\t\t\t       \t\t   \\\n     bool __r;\t\t\t\t\t\t       \t\t   \\\n     __atomic_flag_base* __g = __atomic_flag_for_address(__p);\t   \t   \\\n     __atomic_flag_wait_explicit(__g, __x);\t\t\t\t   \\\n-    __typeof__ _ATOMIC_MEMBER_ __t__ = *__p;\t\t       \t\t   \\\n-    if (__t__ == *__q) { *__p = __v; __r = true; }\t\t\t   \\\n-    else { *__q = __t__; __r = false; }\t\t       \t\t\t   \\\n+    __i_type __t = *__p;\t\t       \t\t\t\t   \\\n+    if (*__q == __t) \t\t\t\t\t\t\t   \\\n+    {                                                                      \\\n+      *__p = const_cast<__i_type>(__v);\t \t\t\t\t   \\\n+      __r = true;                                                          \\\n+    }\t\t\t\t\t\t\t\t\t   \\\n+    else { *__q = __t; __r = false; }\t\t       \t\t\t   \\\n     atomic_flag_clear_explicit(__g, __x);\t\t       \t\t   \\\n     __r; })\n \n+\n   /// atomic_flag\n   struct atomic_flag : public __atomic_flag_base\n   {\n     atomic_flag() = default;\n     ~atomic_flag() = default;\n     atomic_flag(const atomic_flag&) = delete;\n+    atomic_flag& operator=(const atomic_flag&) = delete;\n     atomic_flag& operator=(const atomic_flag&) volatile = delete;\n \n     // Conversion to ATOMIC_FLAG_INIT.\n@@ -95,11 +121,18 @@ namespace __atomic0\n     bool\n     test_and_set(memory_order __m = memory_order_seq_cst);\n \n+    bool\n+    test_and_set(memory_order __m = memory_order_seq_cst) volatile;\n+\n     void\n     clear(memory_order __m = memory_order_seq_cst);\n+\n+    void\n+    clear(memory_order __m = memory_order_seq_cst) volatile;\n   };\n \n-  /// 29.4.2, address types\n+\n+  /// atomic_address\n   struct atomic_address\n   {\n   private:\n@@ -109,13 +142,16 @@ namespace __atomic0\n     atomic_address() = default;\n     ~atomic_address() = default;\n     atomic_address(const atomic_address&) = delete;\n+    atomic_address& operator=(const atomic_address&) = delete;\n     atomic_address& operator=(const atomic_address&) volatile = delete;\n \n-    atomic_address(void* __v) { _M_i = __v; }\n+    constexpr atomic_address(void* __v): _M_i (__v) { }\n+\n+    bool\n+    is_lock_free() const { return false; }\n \n     bool\n-    is_lock_free() const\n-    { return false; }\n+    is_lock_free() const volatile { return false; }\n \n     void\n     store(void* __v, memory_order __m = memory_order_seq_cst)\n@@ -126,6 +162,15 @@ namespace __atomic0\n       _ATOMIC_STORE_(this, __v, __m);\n     }\n \n+    void\n+    store(void* __v, memory_order __m = memory_order_seq_cst) volatile\n+    {\n+      __glibcxx_assert(__m != memory_order_acquire);\n+      __glibcxx_assert(__m != memory_order_acq_rel);\n+      __glibcxx_assert(__m != memory_order_consume);\n+      _ATOMIC_STORE_(this, __v, __m);\n+    }\n+\n     void*\n     load(memory_order __m = memory_order_seq_cst) const\n     {\n@@ -134,10 +179,22 @@ namespace __atomic0\n       return _ATOMIC_LOAD_(this, __m);\n     }\n \n+    void*\n+    load(memory_order __m = memory_order_seq_cst) const volatile\n+    {\n+      __glibcxx_assert(__m != memory_order_release);\n+      __glibcxx_assert(__m != memory_order_acq_rel);\n+      return _ATOMIC_LOAD_(this, __m);\n+    }\n+\n     void*\n     exchange(void* __v, memory_order __m = memory_order_seq_cst)\n     { return _ATOMIC_MODIFY_(this, =, __v, __m); }\n \n+    void*\n+    exchange(void* __v, memory_order __m = memory_order_seq_cst) volatile\n+    { return _ATOMIC_MODIFY_(this, =, __v, __m); }\n+\n     bool\n     compare_exchange_weak(void*& __v1, void* __v2, memory_order __m1,\n \t\t\t  memory_order __m2)\n@@ -148,6 +205,16 @@ namespace __atomic0\n       return _ATOMIC_CMPEXCHNG_(this, &__v1, __v2, __m1);\n     }\n \n+    bool\n+    compare_exchange_weak(void*& __v1, void* __v2, memory_order __m1,\n+\t\t\t  memory_order __m2) volatile\n+    {\n+      __glibcxx_assert(__m2 != memory_order_release);\n+      __glibcxx_assert(__m2 != memory_order_acq_rel);\n+      __glibcxx_assert(__m2 <= __m1);\n+      return _ATOMIC_CMPEXCHNG_(this, &__v1, __v2, __m1);\n+    }\n+\n     bool\n     compare_exchange_weak(void*& __v1, void* __v2,\n \t\t\t  memory_order __m = memory_order_seq_cst)\n@@ -156,6 +223,50 @@ namespace __atomic0\n \t\t\t\t   __calculate_memory_order(__m));\n     }\n \n+    bool\n+    compare_exchange_weak(void*& __v1, void* __v2,\n+\t\t\t  memory_order __m = memory_order_seq_cst) volatile\n+    {\n+      return compare_exchange_weak(__v1, __v2, __m,\n+\t\t\t\t   __calculate_memory_order(__m));\n+    }\n+\n+    bool\n+    compare_exchange_weak(const void*& __v1, const void* __v2,\n+\t\t\t  memory_order __m1, memory_order __m2)\n+    {\n+      __glibcxx_assert(__m2 != memory_order_release);\n+      __glibcxx_assert(__m2 != memory_order_acq_rel);\n+      __glibcxx_assert(__m2 <= __m1);\n+      return _ATOMIC_CMPEXCHNG_(this, &__v1, __v2, __m1);\n+    }\n+\n+    bool\n+    compare_exchange_weak(const void*& __v1, const void* __v2,\n+\t\t\t  memory_order __m1, memory_order __m2) volatile\n+    {\n+      __glibcxx_assert(__m2 != memory_order_release);\n+      __glibcxx_assert(__m2 != memory_order_acq_rel);\n+      __glibcxx_assert(__m2 <= __m1);\n+      return _ATOMIC_CMPEXCHNG_(this, &__v1, __v2, __m1);\n+    }\n+\n+    bool\n+    compare_exchange_weak(const void*& __v1, const void* __v2,\n+\t\t\t  memory_order __m = memory_order_seq_cst)\n+    {\n+      return compare_exchange_weak(__v1, __v2, __m,\n+\t\t\t\t   __calculate_memory_order(__m));\n+    }\n+\n+    bool\n+    compare_exchange_weak(const void*& __v1, const void* __v2,\n+\t\t\t  memory_order __m = memory_order_seq_cst) volatile\n+    {\n+      return compare_exchange_weak(__v1, __v2, __m,\n+\t\t\t\t   __calculate_memory_order(__m));\n+    }\n+\n     bool\n     compare_exchange_strong(void*& __v1, void* __v2, memory_order __m1,\n \t\t\t    memory_order __m2)\n@@ -166,9 +277,63 @@ namespace __atomic0\n       return _ATOMIC_CMPEXCHNG_(this, &__v1, __v2, __m1);\n     }\n \n+    bool\n+    compare_exchange_strong(void*& __v1, void* __v2, memory_order __m1,\n+\t\t\t    memory_order __m2) volatile\n+    {\n+      __glibcxx_assert(__m2 != memory_order_release);\n+      __glibcxx_assert(__m2 != memory_order_acq_rel);\n+      __glibcxx_assert(__m2 <= __m1);\n+      return _ATOMIC_CMPEXCHNG_(this, &__v1, __v2, __m1);\n+    }\n+\n     bool\n     compare_exchange_strong(void*& __v1, void* __v2,\n-\t\t\t  memory_order __m = memory_order_seq_cst)\n+\t\t\t    memory_order __m = memory_order_seq_cst)\n+    {\n+      return compare_exchange_strong(__v1, __v2, __m,\n+\t\t\t\t     __calculate_memory_order(__m));\n+    }\n+\n+    bool\n+    compare_exchange_strong(void*& __v1, void* __v2,\n+\t\t\t    memory_order __m = memory_order_seq_cst) volatile\n+    {\n+      return compare_exchange_strong(__v1, __v2, __m,\n+\t\t\t\t     __calculate_memory_order(__m));\n+    }\n+\n+    bool\n+    compare_exchange_strong(const void*& __v1, const void* __v2,\n+\t\t\t    memory_order __m1, memory_order __m2)\n+    {\n+      __glibcxx_assert(__m2 != memory_order_release);\n+      __glibcxx_assert(__m2 != memory_order_acq_rel);\n+      __glibcxx_assert(__m2 <= __m1);\n+      return _ATOMIC_CMPEXCHNG_(this, &__v1, __v2, __m1);\n+    }\n+\n+    bool\n+    compare_exchange_strong(const void*& __v1, const void* __v2,\n+\t\t\t    memory_order __m1, memory_order __m2) volatile\n+    {\n+      __glibcxx_assert(__m2 != memory_order_release);\n+      __glibcxx_assert(__m2 != memory_order_acq_rel);\n+      __glibcxx_assert(__m2 <= __m1);\n+      return _ATOMIC_CMPEXCHNG_(this, &__v1, __v2, __m1);\n+    }\n+\n+    bool\n+    compare_exchange_strong(const void*& __v1, const void* __v2,\n+\t\t\t    memory_order __m = memory_order_seq_cst)\n+    {\n+      return compare_exchange_strong(__v1, __v2, __m,\n+\t\t\t\t     __calculate_memory_order(__m));\n+    }\n+\n+    bool\n+    compare_exchange_strong(const void*& __v1, const void* __v2,\n+\t\t\t    memory_order __m = memory_order_seq_cst) volatile\n     {\n       return compare_exchange_strong(__v1, __v2, __m,\n \t\t\t\t     __calculate_memory_order(__m));\n@@ -186,6 +351,18 @@ namespace __atomic0\n       return __r;\n     }\n \n+    void*\n+    fetch_add(ptrdiff_t __d, memory_order __m = memory_order_seq_cst) volatile\n+    {\n+      void* volatile* __p = &(_M_i);\n+      __atomic_flag_base* __g = __atomic_flag_for_address(__p);\n+      __atomic_flag_wait_explicit(__g, __m);\n+      void* __r = *__p;\n+      *__p = (void*)((char*)(*__p) + __d);\n+      atomic_flag_clear_explicit(__g, __m);\n+      return __r;\n+    }\n+\n     void*\n     fetch_sub(ptrdiff_t __d, memory_order __m = memory_order_seq_cst)\n     {\n@@ -198,27 +375,59 @@ namespace __atomic0\n       return __r;\n     }\n \n+    void*\n+    fetch_sub(ptrdiff_t __d, memory_order __m = memory_order_seq_cst) volatile\n+    {\n+      void* volatile* __p = &(_M_i);\n+      __atomic_flag_base* __g = __atomic_flag_for_address(__p);\n+      __atomic_flag_wait_explicit(__g, __m);\n+      void* __r = *__p;\n+      *__p = (void*)((char*)(*__p) - __d);\n+      atomic_flag_clear_explicit(__g, __m);\n+      return __r;\n+    }\n+\n     operator void*() const\n     { return load(); }\n \n+    operator void*() const volatile\n+    { return load(); }\n+\n+    // XXX\n     void*\n     operator=(void* __v)\n     {\n       store(__v);\n       return __v;\n     }\n \n+    void*\n+    operator=(void* __v) volatile\n+    {\n+      store(__v);\n+      return __v;\n+    }\n+\n     void*\n     operator+=(ptrdiff_t __d)\n     { return fetch_add(__d) + __d; }\n \n+    void*\n+    operator+=(ptrdiff_t __d) volatile\n+    { return fetch_add(__d) + __d; }\n+\n     void*\n     operator-=(ptrdiff_t __d)\n     { return fetch_sub(__d) - __d; }\n+\n+    void*\n+    operator-=(ptrdiff_t __d) volatile\n+    { return fetch_sub(__d) - __d; }\n   };\n \n \n-  // 29.3.1 atomic integral types\n+  /// Base class for atomic integrals.\n+  //\n   // For each of the integral types, define atomic_[integral type] struct\n   //\n   // atomic_bool     bool\n@@ -244,92 +453,164 @@ namespace __atomic0\n     struct __atomic_base\n     {\n     private:\n-      typedef _ITp \t__integral_type;\n+      typedef _ITp \t__int_type;\n \n-      __integral_type \t_M_i;\n+      __int_type \t_M_i;\n \n     public:\n       __atomic_base() = default;\n       ~__atomic_base() = default;\n       __atomic_base(const __atomic_base&) = delete;\n+      __atomic_base& operator=(const __atomic_base&) = delete;\n       __atomic_base& operator=(const __atomic_base&) volatile = delete;\n \n-      // Requires __integral_type convertible to _M_base._M_i.\n-      __atomic_base(__integral_type __i) { _M_i = __i; }\n+      // Requires __int_type convertible to _M_base._M_i.\n+      constexpr __atomic_base(__int_type __i): _M_i (__i) { }\n \n-      operator __integral_type() const\n+      operator __int_type() const\n       { return load(); }\n \n-      __integral_type\n-      operator=(__integral_type __i)\n+      operator __int_type() const volatile\n+      { return load(); }\n+\n+      __int_type\n+      operator=(__int_type __i)\n       {\n \tstore(__i);\n \treturn __i;\n       }\n \n-      __integral_type\n+      __int_type\n+      operator=(__int_type __i) volatile\n+      {\n+\tstore(__i);\n+\treturn __i;\n+      }\n+\n+      __int_type\n       operator++(int)\n       { return fetch_add(1); }\n \n-      __integral_type\n+      __int_type\n+      operator++(int) volatile\n+      { return fetch_add(1); }\n+\n+      __int_type\n       operator--(int)\n       { return fetch_sub(1); }\n \n-      __integral_type\n+      __int_type\n+      operator--(int) volatile\n+      { return fetch_sub(1); }\n+\n+      __int_type\n       operator++()\n       { return fetch_add(1) + 1; }\n \n-      __integral_type\n+      __int_type\n+      operator++() volatile\n+      { return fetch_add(1) + 1; }\n+\n+      __int_type\n       operator--()\n       { return fetch_sub(1) - 1; }\n \n-      __integral_type\n-      operator+=(__integral_type __i)\n+      __int_type\n+      operator--() volatile\n+      { return fetch_sub(1) - 1; }\n+\n+      __int_type\n+      operator+=(__int_type __i)\n       { return fetch_add(__i) + __i; }\n \n-      __integral_type\n-      operator-=(__integral_type __i)\n+      __int_type\n+      operator+=(__int_type __i) volatile\n+      { return fetch_add(__i) + __i; }\n+\n+      __int_type\n+      operator-=(__int_type __i)\n       { return fetch_sub(__i) - __i; }\n \n-      __integral_type\n-      operator&=(__integral_type __i)\n+      __int_type\n+      operator-=(__int_type __i) volatile\n+      { return fetch_sub(__i) - __i; }\n+\n+      __int_type\n+      operator&=(__int_type __i)\n+      { return fetch_and(__i) & __i; }\n+\n+      __int_type\n+      operator&=(__int_type __i) volatile\n       { return fetch_and(__i) & __i; }\n \n-      __integral_type\n-      operator|=(__integral_type __i)\n+      __int_type\n+      operator|=(__int_type __i)\n       { return fetch_or(__i) | __i; }\n \n-      __integral_type\n-      operator^=(__integral_type __i)\n+      __int_type\n+      operator|=(__int_type __i) volatile\n+      { return fetch_or(__i) | __i; }\n+\n+      __int_type\n+      operator^=(__int_type __i)\n+      { return fetch_xor(__i) ^ __i; }\n+\n+      __int_type\n+      operator^=(__int_type __i) volatile\n       { return fetch_xor(__i) ^ __i; }\n \n       bool\n       is_lock_free() const\n       { return false; }\n \n+      bool\n+      is_lock_free() const volatile\n+      { return false; }\n+\n+      void\n+      store(__int_type __i, memory_order __m = memory_order_seq_cst)\n+      {\n+\t__glibcxx_assert(__m != memory_order_acquire);\n+\t__glibcxx_assert(__m != memory_order_acq_rel);\n+\t__glibcxx_assert(__m != memory_order_consume);\n+\t_ATOMIC_STORE_(this, __i, __m);\n+      }\n+\n       void\n-      store(__integral_type __i, memory_order __m = memory_order_seq_cst)\n+      store(__int_type __i, memory_order __m = memory_order_seq_cst) volatile\n       {\n \t__glibcxx_assert(__m != memory_order_acquire);\n \t__glibcxx_assert(__m != memory_order_acq_rel);\n \t__glibcxx_assert(__m != memory_order_consume);\n \t_ATOMIC_STORE_(this, __i, __m);\n       }\n \n-      __integral_type\n+      __int_type\n       load(memory_order __m = memory_order_seq_cst) const\n       {\n \t__glibcxx_assert(__m != memory_order_release);\n \t__glibcxx_assert(__m != memory_order_acq_rel);\n \treturn _ATOMIC_LOAD_(this, __m);\n       }\n \n-      __integral_type\n-      exchange(__integral_type __i, memory_order __m = memory_order_seq_cst)\n+      __int_type\n+      load(memory_order __m = memory_order_seq_cst) const volatile\n+      {\n+\t__glibcxx_assert(__m != memory_order_release);\n+\t__glibcxx_assert(__m != memory_order_acq_rel);\n+\treturn _ATOMIC_LOAD_(this, __m);\n+      }\n+\n+      __int_type\n+      exchange(__int_type __i, memory_order __m = memory_order_seq_cst)\n+      { return _ATOMIC_MODIFY_(this, =, __i, __m); }\n+\n+      __int_type\n+      exchange(__int_type __i, memory_order __m = memory_order_seq_cst) volatile\n       { return _ATOMIC_MODIFY_(this, =, __i, __m); }\n \n       bool\n-      compare_exchange_weak(__integral_type& __i1, __integral_type __i2,\n+      compare_exchange_weak(__int_type& __i1, __int_type __i2,\n \t\t\t    memory_order __m1, memory_order __m2)\n       {\n \t__glibcxx_assert(__m2 != memory_order_release);\n@@ -339,15 +620,33 @@ namespace __atomic0\n       }\n \n       bool\n-      compare_exchange_weak(__integral_type& __i1, __integral_type __i2,\n+      compare_exchange_weak(__int_type& __i1, __int_type __i2,\n+\t\t\t    memory_order __m1, memory_order __m2) volatile\n+      {\n+\t__glibcxx_assert(__m2 != memory_order_release);\n+\t__glibcxx_assert(__m2 != memory_order_acq_rel);\n+\t__glibcxx_assert(__m2 <= __m1);\n+\treturn _ATOMIC_CMPEXCHNG_(this, &__i1, __i2, __m1);\n+      }\n+\n+      bool\n+      compare_exchange_weak(__int_type& __i1, __int_type __i2,\n \t\t\t    memory_order __m = memory_order_seq_cst)\n       {\n \treturn compare_exchange_weak(__i1, __i2, __m,\n \t\t\t\t     __calculate_memory_order(__m));\n       }\n \n       bool\n-      compare_exchange_strong(__integral_type& __i1, __integral_type __i2,\n+      compare_exchange_weak(__int_type& __i1, __int_type __i2,\n+\t\t\t    memory_order __m = memory_order_seq_cst) volatile\n+      {\n+\treturn compare_exchange_weak(__i1, __i2, __m,\n+\t\t\t\t     __calculate_memory_order(__m));\n+      }\n+\n+      bool\n+      compare_exchange_strong(__int_type& __i1, __int_type __i2,\n \t\t\t      memory_order __m1, memory_order __m2)\n       {\n \t__glibcxx_assert(__m2 != memory_order_release);\n@@ -357,101 +656,82 @@ namespace __atomic0\n       }\n \n       bool\n-      compare_exchange_strong(__integral_type& __i1, __integral_type __i2,\n+      compare_exchange_strong(__int_type& __i1, __int_type __i2,\n+\t\t\t      memory_order __m1, memory_order __m2) volatile\n+      {\n+\t__glibcxx_assert(__m2 != memory_order_release);\n+\t__glibcxx_assert(__m2 != memory_order_acq_rel);\n+\t__glibcxx_assert(__m2 <= __m1);\n+\treturn _ATOMIC_CMPEXCHNG_(this, &__i1, __i2, __m1);\n+      }\n+\n+      bool\n+      compare_exchange_strong(__int_type& __i1, __int_type __i2,\n \t\t\t      memory_order __m = memory_order_seq_cst)\n       {\n \treturn compare_exchange_strong(__i1, __i2, __m,\n \t\t\t\t       __calculate_memory_order(__m));\n       }\n \n-      __integral_type\n-      fetch_add(__integral_type __i, memory_order __m = memory_order_seq_cst)\n-      { return _ATOMIC_MODIFY_(this, +=, __i, __m); }\n-\n-      __integral_type\n-      fetch_sub(__integral_type __i, memory_order __m = memory_order_seq_cst)\n-      { return _ATOMIC_MODIFY_(this, -=, __i, __m); }\n-\n-      __integral_type\n-      fetch_and(__integral_type __i, memory_order __m = memory_order_seq_cst)\n-      { return _ATOMIC_MODIFY_(this, &=, __i, __m); }\n-\n-      __integral_type\n-      fetch_or(__integral_type __i, memory_order __m = memory_order_seq_cst)\n-      { return _ATOMIC_MODIFY_(this, |=, __i, __m); }\n-\n-      __integral_type\n-      fetch_xor(__integral_type __i, memory_order __m = memory_order_seq_cst)\n-      { return _ATOMIC_MODIFY_(this, ^=, __i, __m); }\n-    };\n-\n-\n-  /// atomic_bool\n-  // NB: No operators or fetch-operations for this type.\n-  struct atomic_bool\n-  {\n-  private:\n-    __atomic_base<bool>\t_M_base;\n-\n-  public:\n-    atomic_bool() = default;\n-    ~atomic_bool() = default;\n-    atomic_bool(const atomic_bool&) = delete;\n-    atomic_bool& operator=(const atomic_bool&) volatile = delete;\n-\n-    atomic_bool(bool __i) : _M_base(__i) { }\n-\n-    bool\n-    operator=(bool __i)\n-    { return _M_base.operator=(__i); }\n+      bool\n+      compare_exchange_strong(__int_type& __i1, __int_type __i2,\n+\t\t\t      memory_order __m = memory_order_seq_cst) volatile\n+      {\n+\treturn compare_exchange_strong(__i1, __i2, __m,\n+\t\t\t\t       __calculate_memory_order(__m));\n+      }\n \n-    operator bool() const\n-    { return _M_base.load(); }\n+      __int_type\n+      fetch_add(__int_type __i, memory_order __m = memory_order_seq_cst)\n+      { return _ATOMIC_MODIFY_(this, +=, __i, __m); }\n \n-    bool\n-    is_lock_free() const\n-    { return _M_base.is_lock_free(); }\n+      __int_type\n+      fetch_add(__int_type __i,\n+\t\tmemory_order __m = memory_order_seq_cst) volatile\n+      { return _ATOMIC_MODIFY_(this, +=, __i, __m); }\n \n-    void\n-    store(bool __i, memory_order __m = memory_order_seq_cst)\n-    { _M_base.store(__i, __m); }\n+      __int_type\n+      fetch_sub(__int_type __i, memory_order __m = memory_order_seq_cst)\n+      { return _ATOMIC_MODIFY_(this, -=, __i, __m); }\n \n-    bool\n-    load(memory_order __m = memory_order_seq_cst) const\n-    { return _M_base.load(__m); }\n+      __int_type\n+      fetch_sub(__int_type __i,\n+\t\tmemory_order __m = memory_order_seq_cst) volatile\n+      { return _ATOMIC_MODIFY_(this, -=, __i, __m); }\n \n-    bool\n-    exchange(bool __i, memory_order __m = memory_order_seq_cst)\n-    { return _M_base.exchange(__i, __m); }\n+      __int_type\n+      fetch_and(__int_type __i, memory_order __m = memory_order_seq_cst)\n+      { return _ATOMIC_MODIFY_(this, &=, __i, __m); }\n \n-    bool\n-    compare_exchange_weak(bool& __i1, bool __i2, memory_order __m1,\n-\t\t\t  memory_order __m2)\n-    { return _M_base.compare_exchange_weak(__i1, __i2, __m1, __m2); }\n+      __int_type\n+      fetch_and(__int_type __i,\n+\t\tmemory_order __m = memory_order_seq_cst) volatile\n+      { return _ATOMIC_MODIFY_(this, &=, __i, __m); }\n \n-    bool\n-    compare_exchange_weak(bool& __i1, bool __i2,\n-\t\t\t  memory_order __m = memory_order_seq_cst)\n-    { return _M_base.compare_exchange_weak(__i1, __i2, __m); }\n+      __int_type\n+      fetch_or(__int_type __i, memory_order __m = memory_order_seq_cst)\n+      { return _ATOMIC_MODIFY_(this, |=, __i, __m); }\n \n-    bool\n-    compare_exchange_strong(bool& __i1, bool __i2, memory_order __m1,\n-\t\t\t    memory_order __m2)\n-    { return _M_base.compare_exchange_strong(__i1, __i2, __m1, __m2); }\n+      __int_type\n+      fetch_or(__int_type __i, memory_order __m = memory_order_seq_cst) volatile\n+      { return _ATOMIC_MODIFY_(this, |=, __i, __m); }\n \n+      __int_type\n+      fetch_xor(__int_type __i, memory_order __m = memory_order_seq_cst)\n+      { return _ATOMIC_MODIFY_(this, ^=, __i, __m); }\n \n-    bool\n-    compare_exchange_strong(bool& __i1, bool __i2,\n-\t\t\t    memory_order __m = memory_order_seq_cst)\n-    { return _M_base.compare_exchange_strong(__i1, __i2, __m); }\n-  };\n+      __int_type\n+      fetch_xor(__int_type __i,\n+\t\tmemory_order __m = memory_order_seq_cst) volatile\n+      { return _ATOMIC_MODIFY_(this, ^=, __i, __m); }\n+    };\n \n #undef _ATOMIC_LOAD_\n #undef _ATOMIC_STORE_\n #undef _ATOMIC_MODIFY_\n #undef _ATOMIC_CMPEXCHNG_\n } // namespace __atomic0\n \n-// _GLIBCXX_END_NAMESPACE\n+_GLIBCXX_END_NAMESPACE\n \n #endif"}, {"sha": "e4cf24dc94d97ef41b7fdfd8ec3894012dfbb002", "filename": "libstdc++-v3/include/bits/atomic_2.h", "status": "modified", "additions": 424, "deletions": 124, "changes": 548, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_2.h?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -1,6 +1,6 @@\n // -*- C++ -*- header.\n \n-// Copyright (C) 2008, 2009\n+// Copyright (C) 2008, 2009, 2010\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -33,7 +33,7 @@\n \n #pragma GCC system_header\n \n-// _GLIBCXX_BEGIN_NAMESPACE(std)\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n \n // 2 == __atomic2 == Always lock-free\n // Assumed:\n@@ -49,6 +49,7 @@ namespace __atomic2\n     atomic_flag() = default;\n     ~atomic_flag() = default;\n     atomic_flag(const atomic_flag&) = delete;\n+    atomic_flag& operator=(const atomic_flag&) = delete;\n     atomic_flag& operator=(const atomic_flag&) volatile = delete;\n \n     // Conversion to ATOMIC_FLAG_INIT.\n@@ -63,6 +64,15 @@ namespace __atomic2\n       return __sync_lock_test_and_set(&_M_i, 1);\n     }\n \n+    bool\n+    test_and_set(memory_order __m = memory_order_seq_cst) volatile\n+    {\n+      // Redundant synchronize if built-in for lock is a full barrier.\n+      if (__m != memory_order_acquire && __m != memory_order_acq_rel)\n+\t__sync_synchronize();\n+      return __sync_lock_test_and_set(&_M_i, 1);\n+    }\n+\n     void\n     clear(memory_order __m = memory_order_seq_cst)\n     {\n@@ -74,10 +84,22 @@ namespace __atomic2\n       if (__m != memory_order_acquire && __m != memory_order_acq_rel)\n \t__sync_synchronize();\n     }\n+\n+    void\n+    clear(memory_order __m = memory_order_seq_cst) volatile\n+    {\n+      __glibcxx_assert(__m != memory_order_consume);\n+      __glibcxx_assert(__m != memory_order_acquire);\n+      __glibcxx_assert(__m != memory_order_acq_rel);\n+\n+      __sync_lock_release(&_M_i);\n+      if (__m != memory_order_acquire && __m != memory_order_acq_rel)\n+\t__sync_synchronize();\n+    }\n   };\n \n \n-  /// 29.4.2, address types\n+  /// atomic_address\n   struct atomic_address\n   {\n   private:\n@@ -87,13 +109,16 @@ namespace __atomic2\n     atomic_address() = default;\n     ~atomic_address() = default;\n     atomic_address(const atomic_address&) = delete;\n+    atomic_address& operator=(const atomic_address&) = delete;\n     atomic_address& operator=(const atomic_address&) volatile = delete;\n \n-    atomic_address(void* __v) { _M_i = __v; }\n+    constexpr atomic_address(void* __v): _M_i (__v) {  }\n \n     bool\n-    is_lock_free() const\n-    { return true; }\n+    is_lock_free() const { return true; }\n+\n+    bool\n+    is_lock_free() const volatile { return true; }\n \n     void\n     store(void* __v, memory_order __m = memory_order_seq_cst)\n@@ -113,6 +138,24 @@ namespace __atomic2\n \t}\n     }\n \n+    void\n+    store(void* __v, memory_order __m = memory_order_seq_cst) volatile\n+    {\n+      __glibcxx_assert(__m != memory_order_acquire);\n+      __glibcxx_assert(__m != memory_order_acq_rel);\n+      __glibcxx_assert(__m != memory_order_consume);\n+\n+      if (__m == memory_order_relaxed)\n+\t_M_i = __v;\n+      else\n+\t{\n+\t  // write_mem_barrier();\n+\t  _M_i = __v;\n+\t  if (__m == memory_order_seq_cst)\n+\t    __sync_synchronize();\n+\t}\n+    }\n+\n     void*\n     load(memory_order __m = memory_order_seq_cst) const\n     {\n@@ -125,26 +168,84 @@ namespace __atomic2\n       return __ret;\n     }\n \n+    void*\n+    load(memory_order __m = memory_order_seq_cst) const volatile\n+    {\n+      __glibcxx_assert(__m != memory_order_release);\n+      __glibcxx_assert(__m != memory_order_acq_rel);\n+\n+      __sync_synchronize();\n+      void* __ret = _M_i;\n+      __sync_synchronize();\n+      return __ret;\n+    }\n+\n     void*\n     exchange(void* __v, memory_order __m = memory_order_seq_cst)\n     {\n       // XXX built-in assumes memory_order_acquire.\n       return __sync_lock_test_and_set(&_M_i, __v);\n     }\n \n+    void*\n+    exchange(void* __v, memory_order __m = memory_order_seq_cst) volatile\n+    {\n+      // XXX built-in assumes memory_order_acquire.\n+      return __sync_lock_test_and_set(&_M_i, __v);\n+    }\n+\n     bool\n     compare_exchange_weak(void*& __v1, void* __v2, memory_order __m1,\n \t\t\t  memory_order __m2)\n     { return compare_exchange_strong(__v1, __v2, __m1, __m2); }\n \n+    bool\n+    compare_exchange_weak(void*& __v1, void* __v2, memory_order __m1,\n+\t\t\t  memory_order __m2) volatile\n+    { return compare_exchange_strong(__v1, __v2, __m1, __m2); }\n+\n+    bool\n+    compare_exchange_weak(void*& __v1, void* __v2,\n+\t\t\t  memory_order __m = memory_order_seq_cst)\n+    {\n+      return compare_exchange_weak(__v1, __v2, __m,\n+\t\t\t\t   __calculate_memory_order(__m));\n+    }\n+\n     bool\n     compare_exchange_weak(void*& __v1, void* __v2,\n+\t\t\t  memory_order __m = memory_order_seq_cst) volatile\n+    {\n+      return compare_exchange_weak(__v1, __v2, __m,\n+\t\t\t\t   __calculate_memory_order(__m));\n+    }\n+\n+    bool\n+    compare_exchange_weak(const void*& __v1, const void* __v2,\n+\t\t\t  memory_order __m1, memory_order __m2)\n+    { return compare_exchange_strong(__v1, __v2, __m1, __m2); }\n+\n+    bool\n+    compare_exchange_weak(const void*& __v1, const void* __v2,\n+\t\t\t  memory_order __m1, memory_order __m2) volatile\n+    { return compare_exchange_strong(__v1, __v2, __m1, __m2); }\n+\n+    bool\n+    compare_exchange_weak(const void*& __v1, const void* __v2,\n \t\t\t  memory_order __m = memory_order_seq_cst)\n     {\n       return compare_exchange_weak(__v1, __v2, __m,\n \t\t\t\t   __calculate_memory_order(__m));\n     }\n \n+    bool\n+    compare_exchange_weak(const void*& __v1, const void* __v2,\n+\t\t\t  memory_order __m = memory_order_seq_cst) volatile\n+    {\n+      return compare_exchange_weak(__v1, __v2, __m,\n+\t\t\t\t   __calculate_memory_order(__m));\n+    }\n+\n     bool\n     compare_exchange_strong(void*& __v1, void* __v2, memory_order __m1,\n \t\t\t    memory_order __m2)\n@@ -161,9 +262,81 @@ namespace __atomic2\n       return __v1o == __v1n;\n     }\n \n+    bool\n+    compare_exchange_strong(void*& __v1, void* __v2, memory_order __m1,\n+\t\t\t    memory_order __m2) volatile\n+    {\n+      __glibcxx_assert(__m2 != memory_order_release);\n+      __glibcxx_assert(__m2 != memory_order_acq_rel);\n+      __glibcxx_assert(__m2 <= __m1);\n+\n+      void* __v1o = __v1;\n+      void* __v1n = __sync_val_compare_and_swap(&_M_i, __v1o, __v2);\n+\n+      // Assume extra stores (of same value) allowed in true case.\n+      __v1 = __v1n;\n+      return __v1o == __v1n;\n+    }\n+\n     bool\n     compare_exchange_strong(void*& __v1, void* __v2,\n-\t\t\t  memory_order __m = memory_order_seq_cst)\n+\t\t\t    memory_order __m = memory_order_seq_cst)\n+    {\n+      return compare_exchange_strong(__v1, __v2, __m,\n+\t\t\t\t     __calculate_memory_order(__m));\n+    }\n+\n+    bool\n+    compare_exchange_strong(void*& __v1, void* __v2,\n+\t\t\t    memory_order __m = memory_order_seq_cst) volatile\n+    {\n+      return compare_exchange_strong(__v1, __v2, __m,\n+\t\t\t\t     __calculate_memory_order(__m));\n+    }\n+\n+    bool\n+    compare_exchange_strong(const void*& __v1, const void* __v2,\n+\t\t\t    memory_order __m1, memory_order __m2)\n+    {\n+      __glibcxx_assert(__m2 != memory_order_release);\n+      __glibcxx_assert(__m2 != memory_order_acq_rel);\n+      __glibcxx_assert(__m2 <= __m1);\n+\n+      const void* __v1o = __v1;\n+      const void* __v1n = __sync_val_compare_and_swap(&_M_i, __v1o, __v2);\n+\n+      // Assume extra stores (of same value) allowed in true case.\n+      __v1 = __v1n;\n+      return __v1o == __v1n;\n+    }\n+\n+    bool\n+    compare_exchange_strong(const void*& __v1, const void* __v2,\n+\t\t\t    memory_order __m1, memory_order __m2) volatile\n+    {\n+      __glibcxx_assert(__m2 != memory_order_release);\n+      __glibcxx_assert(__m2 != memory_order_acq_rel);\n+      __glibcxx_assert(__m2 <= __m1);\n+\n+      const void* __v1o = __v1;\n+      const void* __v1n = __sync_val_compare_and_swap(&_M_i, __v1o, __v2);\n+\n+      // Assume extra stores (of same value) allowed in true case.\n+      __v1 = __v1n;\n+      return __v1o == __v1n;\n+    }\n+\n+    bool\n+    compare_exchange_strong(const void*& __v1, const void* __v2,\n+\t\t\t    memory_order __m = memory_order_seq_cst)\n+    {\n+      return compare_exchange_strong(__v1, __v2, __m,\n+\t\t\t\t     __calculate_memory_order(__m));\n+    }\n+\n+    bool\n+    compare_exchange_strong(const void*& __v1, const void* __v2,\n+\t\t\t    memory_order __m = memory_order_seq_cst) volatile\n     {\n       return compare_exchange_strong(__v1, __v2, __m,\n \t\t\t\t     __calculate_memory_order(__m));\n@@ -173,15 +346,47 @@ namespace __atomic2\n     fetch_add(ptrdiff_t __d, memory_order __m = memory_order_seq_cst)\n     { return __sync_fetch_and_add(&_M_i, __d); }\n \n+    void*\n+    fetch_add(ptrdiff_t __d, memory_order __m = memory_order_seq_cst) volatile\n+    { return __sync_fetch_and_add(&_M_i, __d); }\n+\n     void*\n     fetch_sub(ptrdiff_t __d, memory_order __m = memory_order_seq_cst)\n     { return __sync_fetch_and_sub(&_M_i, __d); }\n \n+    void*\n+    fetch_sub(ptrdiff_t __d, memory_order __m = memory_order_seq_cst) volatile\n+    { return __sync_fetch_and_sub(&_M_i, __d); }\n+\n     operator void*() const\n     { return load(); }\n \n+    operator void*() const volatile\n+    { return load(); }\n+\n     void*\n-    operator=(void* __v)\n+#if 0\n+    // XXX as specified but won't compile as store takes void*,\n+    // invalid conversion from const void* to void*\n+    // CD1 had this signature\n+    operator=(const void* __v)\n+#else\n+    operator=(void* __v)      \n+#endif\n+    {\n+      store(__v);\n+      return __v;\n+    }\n+\n+    void*\n+#if 0\n+    // XXX as specified but won't compile as store takes void*,\n+    // invalid conversion from const void* to void*\n+    // CD1 had this signature, but store and this could both be const void*?\n+    operator=(const void* __v) volatile\n+#else\n+    operator=(void* __v) volatile\n+#endif\n     {\n       store(__v);\n       return __v;\n@@ -191,12 +396,22 @@ namespace __atomic2\n     operator+=(ptrdiff_t __d)\n     { return __sync_add_and_fetch(&_M_i, __d); }\n \n+    void*\n+    operator+=(ptrdiff_t __d) volatile\n+    { return __sync_add_and_fetch(&_M_i, __d); }\n+\n     void*\n     operator-=(ptrdiff_t __d)\n     { return __sync_sub_and_fetch(&_M_i, __d); }\n+\n+    void*\n+    operator-=(ptrdiff_t __d) volatile\n+    { return __sync_sub_and_fetch(&_M_i, __d); }\n   };\n \n-  // 29.3.1 atomic integral types\n+\n+  /// Base class for atomic integrals.\n+  //\n   // For each of the integral types, define atomic_[integral type] struct\n   //\n   // atomic_bool     bool\n@@ -214,79 +429,148 @@ namespace __atomic2\n   // atomic_char16_t char16_t\n   // atomic_char32_t char32_t\n   // atomic_wchar_t  wchar_t\n-\n-  // Base type.\n-  // NB: Assuming _ITp is an integral scalar type that is 1, 2, 4, or 8 bytes,\n-  // since that is what GCC built-in functions for atomic memory access work on.\n+  //\n+  // NB: Assuming _ITp is an integral scalar type that is 1, 2, 4, or\n+  // 8 bytes, since that is what GCC built-in functions for atomic\n+  // memory access expect.\n   template<typename _ITp>\n     struct __atomic_base\n     {\n     private:\n-      typedef _ITp \t__integral_type;\n+      typedef _ITp \t__int_type;\n \n-      __integral_type \t_M_i;\n+      __int_type \t_M_i;\n \n     public:\n       __atomic_base() = default;\n       ~__atomic_base() = default;\n       __atomic_base(const __atomic_base&) = delete;\n+      __atomic_base& operator=(const __atomic_base&) = delete;\n       __atomic_base& operator=(const __atomic_base&) volatile = delete;\n \n-      // Requires __integral_type convertible to _M_base._M_i.\n-      __atomic_base(__integral_type __i) { _M_i = __i; }\n+      // Requires __int_type convertible to _M_i.\n+      constexpr __atomic_base(__int_type __i): _M_i (__i) { }\n \n-      operator __integral_type() const\n+      operator __int_type() const\n       { return load(); }\n \n-      __integral_type\n-      operator=(__integral_type __i)\n+      operator __int_type() const volatile\n+      { return load(); }\n+\n+      __int_type\n+      operator=(__int_type __i)\n+      {\n+\tstore(__i);\n+\treturn __i;\n+      }\n+\n+      __int_type\n+      operator=(__int_type __i) volatile\n       {\n \tstore(__i);\n \treturn __i;\n       }\n \n-      __integral_type\n+      __int_type\n       operator++(int)\n       { return fetch_add(1); }\n \n-      __integral_type\n+      __int_type\n+      operator++(int) volatile\n+      { return fetch_add(1); }\n+\n+      __int_type\n       operator--(int)\n       { return fetch_sub(1); }\n \n-      __integral_type\n+      __int_type\n+      operator--(int) volatile\n+      { return fetch_sub(1); }\n+\n+      __int_type\n       operator++()\n       { return __sync_add_and_fetch(&_M_i, 1); }\n \n-      __integral_type\n+      __int_type\n+      operator++() volatile\n+      { return __sync_add_and_fetch(&_M_i, 1); }\n+\n+      __int_type\n       operator--()\n       { return __sync_sub_and_fetch(&_M_i, 1); }\n \n-      __integral_type\n-      operator+=(__integral_type __i)\n+      __int_type\n+      operator--() volatile\n+      { return __sync_sub_and_fetch(&_M_i, 1); }\n+\n+      __int_type\n+      operator+=(__int_type __i)\n+      { return __sync_add_and_fetch(&_M_i, __i); }\n+\n+      __int_type\n+      operator+=(__int_type __i) volatile\n       { return __sync_add_and_fetch(&_M_i, __i); }\n \n-      __integral_type\n-      operator-=(__integral_type __i)\n+      __int_type\n+      operator-=(__int_type __i)\n       { return __sync_sub_and_fetch(&_M_i, __i); }\n \n-      __integral_type\n-      operator&=(__integral_type __i)\n+      __int_type\n+      operator-=(__int_type __i) volatile\n+      { return __sync_sub_and_fetch(&_M_i, __i); }\n+\n+      __int_type\n+      operator&=(__int_type __i)\n       { return __sync_and_and_fetch(&_M_i, __i); }\n \n-      __integral_type\n-      operator|=(__integral_type __i)\n+      __int_type\n+      operator&=(__int_type __i) volatile\n+      { return __sync_and_and_fetch(&_M_i, __i); }\n+\n+      __int_type\n+      operator|=(__int_type __i)\n+      { return __sync_or_and_fetch(&_M_i, __i); }\n+\n+      __int_type\n+      operator|=(__int_type __i) volatile\n       { return __sync_or_and_fetch(&_M_i, __i); }\n \n-      __integral_type\n-      operator^=(__integral_type __i)\n+      __int_type\n+      operator^=(__int_type __i)\n+      { return __sync_xor_and_fetch(&_M_i, __i); }\n+\n+      __int_type\n+      operator^=(__int_type __i) volatile\n       { return __sync_xor_and_fetch(&_M_i, __i); }\n \n       bool\n       is_lock_free() const\n       { return true; }\n \n+      bool\n+      is_lock_free() const volatile\n+      { return true; }\n+\n+      void\n+      store(__int_type __i, memory_order __m = memory_order_seq_cst)\n+      {\n+\t__glibcxx_assert(__m != memory_order_acquire);\n+\t__glibcxx_assert(__m != memory_order_acq_rel);\n+\t__glibcxx_assert(__m != memory_order_consume);\n+\n+\tif (__m == memory_order_relaxed)\n+\t  _M_i = __i;\n+\telse\n+\t  {\n+\t    // write_mem_barrier();\n+\t    _M_i = __i;\n+\t    if (__m == memory_order_seq_cst)\n+\t      __sync_synchronize();\n+\t  }\n+      }\n+\n       void\n-      store(__integral_type __i, memory_order __m = memory_order_seq_cst)\n+      store(__int_type __i, memory_order __m = memory_order_seq_cst) volatile\n       {\n \t__glibcxx_assert(__m != memory_order_acquire);\n \t__glibcxx_assert(__m != memory_order_acq_rel);\n@@ -303,150 +587,166 @@ namespace __atomic2\n \t  }\n       }\n \n-      __integral_type\n-      load(memory_order __m = memory_order_seq_cst) const \n+      __int_type\n+      load(memory_order __m = memory_order_seq_cst) const\n       {\n \t__glibcxx_assert(__m != memory_order_release);\n \t__glibcxx_assert(__m != memory_order_acq_rel);\n \n \t__sync_synchronize();\n-\t__integral_type __ret = _M_i;\n+\t__int_type __ret = _M_i;\n \t__sync_synchronize();\n \treturn __ret;\n       }\n \n-      __integral_type\n-      exchange(__integral_type __i, memory_order __m = memory_order_seq_cst)\n+      __int_type\n+      load(memory_order __m = memory_order_seq_cst) const volatile\n+      {\n+\t__glibcxx_assert(__m != memory_order_release);\n+\t__glibcxx_assert(__m != memory_order_acq_rel);\n+\n+\t__sync_synchronize();\n+\t__int_type __ret = _M_i;\n+\t__sync_synchronize();\n+\treturn __ret;\n+      }\n+\n+      __int_type\n+      exchange(__int_type __i, memory_order __m = memory_order_seq_cst)\n+      {\n+\t// XXX built-in assumes memory_order_acquire.\n+\treturn __sync_lock_test_and_set(&_M_i, __i);\n+      }\n+\n+\n+      __int_type\n+      exchange(__int_type __i, memory_order __m = memory_order_seq_cst) volatile\n       {\n \t// XXX built-in assumes memory_order_acquire.\n \treturn __sync_lock_test_and_set(&_M_i, __i);\n       }\n \n       bool\n-      compare_exchange_weak(__integral_type& __i1, __integral_type __i2,\n+      compare_exchange_weak(__int_type& __i1, __int_type __i2,\n \t\t\t    memory_order __m1, memory_order __m2)\n       { return compare_exchange_strong(__i1, __i2, __m1, __m2); }\n \n       bool\n-      compare_exchange_weak(__integral_type& __i1, __integral_type __i2,\n+      compare_exchange_weak(__int_type& __i1, __int_type __i2,\n+\t\t\t    memory_order __m1, memory_order __m2) volatile\n+      { return compare_exchange_strong(__i1, __i2, __m1, __m2); }\n+\n+      bool\n+      compare_exchange_weak(__int_type& __i1, __int_type __i2,\n \t\t\t    memory_order __m = memory_order_seq_cst)\n       {\n \treturn compare_exchange_weak(__i1, __i2, __m,\n \t\t\t\t     __calculate_memory_order(__m));\n       }\n \n       bool\n-      compare_exchange_strong(__integral_type& __i1, __integral_type __i2,\n-\t\t\t      memory_order __m1, memory_order __m2) \n+      compare_exchange_weak(__int_type& __i1, __int_type __i2,\n+\t\t\t    memory_order __m = memory_order_seq_cst) volatile\n+      {\n+\treturn compare_exchange_weak(__i1, __i2, __m,\n+\t\t\t\t     __calculate_memory_order(__m));\n+      }\n+\n+      bool\n+      compare_exchange_strong(__int_type& __i1, __int_type __i2,\n+\t\t\t      memory_order __m1, memory_order __m2)\n+      {\n+\t__glibcxx_assert(__m2 != memory_order_release);\n+\t__glibcxx_assert(__m2 != memory_order_acq_rel);\n+\t__glibcxx_assert(__m2 <= __m1);\n+\n+\t__int_type __i1o = __i1;\n+\t__int_type __i1n = __sync_val_compare_and_swap(&_M_i, __i1o, __i2);\n+\n+\t// Assume extra stores (of same value) allowed in true case.\n+\t__i1 = __i1n;\n+\treturn __i1o == __i1n;\n+      }\n+\n+      bool\n+      compare_exchange_strong(__int_type& __i1, __int_type __i2,\n+\t\t\t      memory_order __m1, memory_order __m2) volatile\n       {\n \t__glibcxx_assert(__m2 != memory_order_release);\n \t__glibcxx_assert(__m2 != memory_order_acq_rel);\n \t__glibcxx_assert(__m2 <= __m1);\n \n-\t__integral_type __i1o = __i1;\n-\t__integral_type __i1n = __sync_val_compare_and_swap(&_M_i, __i1o, __i2);\n+\t__int_type __i1o = __i1;\n+\t__int_type __i1n = __sync_val_compare_and_swap(&_M_i, __i1o, __i2);\n \n \t// Assume extra stores (of same value) allowed in true case.\n \t__i1 = __i1n;\n \treturn __i1o == __i1n;\n       }\n \n       bool\n-      compare_exchange_strong(__integral_type& __i1, __integral_type __i2,\n+      compare_exchange_strong(__int_type& __i1, __int_type __i2,\n \t\t\t      memory_order __m = memory_order_seq_cst)\n       {\n \treturn compare_exchange_strong(__i1, __i2, __m,\n \t\t\t\t       __calculate_memory_order(__m));\n       }\n \n-      __integral_type\n-      fetch_add(__integral_type __i,\n-\t\tmemory_order __m = memory_order_seq_cst)\n-      { return __sync_fetch_and_add(&_M_i, __i); }\n-\n-      __integral_type\n-      fetch_sub(__integral_type __i,\n-\t\tmemory_order __m = memory_order_seq_cst) \n-      { return __sync_fetch_and_sub(&_M_i, __i); }\n-\n-      __integral_type\n-      fetch_and(__integral_type __i,\n-\t\tmemory_order __m = memory_order_seq_cst) \n-      { return __sync_fetch_and_and(&_M_i, __i); }\n-\n-      __integral_type\n-      fetch_or(__integral_type __i,\n-\t       memory_order __m = memory_order_seq_cst) \n-      { return __sync_fetch_and_or(&_M_i, __i); }\n-\n-      __integral_type\n-      fetch_xor(__integral_type __i,\n-\t\tmemory_order __m = memory_order_seq_cst)\n-      { return __sync_fetch_and_xor(&_M_i, __i); }\n-    };\n-\n-\n-  /// atomic_bool\n-  // NB: No operators or fetch-operations for this type.\n-  struct atomic_bool\n-  {\n-  private:\n-    __atomic_base<bool>\t_M_base;\n-\n-  public:\n-    atomic_bool() = default;\n-    ~atomic_bool() = default;\n-    atomic_bool(const atomic_bool&) = delete;\n-    atomic_bool& operator=(const atomic_bool&) volatile = delete;\n-\n-    atomic_bool(bool __i) : _M_base(__i) { }\n-\n-    bool\n-    operator=(bool __i)\n-    { return _M_base.operator=(__i); }\n+      bool\n+      compare_exchange_strong(__int_type& __i1, __int_type __i2,\n+\t\t\t      memory_order __m = memory_order_seq_cst) volatile\n+      {\n+\treturn compare_exchange_strong(__i1, __i2, __m,\n+\t\t\t\t       __calculate_memory_order(__m));\n+      }\n \n-    operator bool() const \n-    { return _M_base.load(); }\n+      __int_type\n+      fetch_add(__int_type __i, memory_order __m = memory_order_seq_cst)\n+      { return __sync_fetch_and_add(&_M_i, __i); }\n \n-    bool\n-    is_lock_free() const\n-    { return _M_base.is_lock_free(); }\n+      __int_type\n+      fetch_add(__int_type __i,\n+\t\tmemory_order __m = memory_order_seq_cst) volatile\n+      { return __sync_fetch_and_add(&_M_i, __i); }\n \n-    void\n-    store(bool __i, memory_order __m = memory_order_seq_cst)\n-    { _M_base.store(__i, __m); }\n+      __int_type\n+      fetch_sub(__int_type __i, memory_order __m = memory_order_seq_cst)\n+      { return __sync_fetch_and_sub(&_M_i, __i); }\n \n-    bool\n-    load(memory_order __m = memory_order_seq_cst) const\n-    { return _M_base.load(__m); }\n+      __int_type\n+      fetch_sub(__int_type __i,\n+\t\tmemory_order __m = memory_order_seq_cst) volatile\n+      { return __sync_fetch_and_sub(&_M_i, __i); }\n \n-    bool\n-    exchange(bool __i, memory_order __m = memory_order_seq_cst)\n-    { return _M_base.exchange(__i, __m); }\n+      __int_type\n+      fetch_and(__int_type __i, memory_order __m = memory_order_seq_cst)\n+      { return __sync_fetch_and_and(&_M_i, __i); }\n \n-    bool\n-    compare_exchange_weak(bool& __i1, bool __i2, memory_order __m1,\n-\t\t\t  memory_order __m2)\n-    { return _M_base.compare_exchange_weak(__i1, __i2, __m1, __m2); }\n+      __int_type\n+      fetch_and(__int_type __i,\n+\t\tmemory_order __m = memory_order_seq_cst) volatile\n+      { return __sync_fetch_and_and(&_M_i, __i); }\n \n-    bool\n-    compare_exchange_weak(bool& __i1, bool __i2,\n-\t\t\t  memory_order __m = memory_order_seq_cst)\n-    { return _M_base.compare_exchange_weak(__i1, __i2, __m); }\n+      __int_type\n+      fetch_or(__int_type __i, memory_order __m = memory_order_seq_cst)\n+      { return __sync_fetch_and_or(&_M_i, __i); }\n \n-    bool\n-    compare_exchange_strong(bool& __i1, bool __i2, memory_order __m1,\n-\t\t\t    memory_order __m2)\n-    { return _M_base.compare_exchange_strong(__i1, __i2, __m1, __m2); }\n+      __int_type\n+      fetch_or(__int_type __i,\n+\t       memory_order __m = memory_order_seq_cst) volatile\n+      { return __sync_fetch_and_or(&_M_i, __i); }\n \n+      __int_type\n+      fetch_xor(__int_type __i, memory_order __m = memory_order_seq_cst)\n+      { return __sync_fetch_and_xor(&_M_i, __i); }\n \n-    bool\n-    compare_exchange_strong(bool& __i1, bool __i2,\n-\t\t\t    memory_order __m = memory_order_seq_cst)\n-    { return _M_base.compare_exchange_strong(__i1, __i2, __m); }\n-  };\n+      __int_type\n+      fetch_xor(__int_type __i,\n+\t\tmemory_order __m = memory_order_seq_cst) volatile\n+      { return __sync_fetch_and_xor(&_M_i, __i); }\n+    };\n } // namespace __atomic2\n \n-// _GLIBCXX_END_NAMESPACE\n+_GLIBCXX_END_NAMESPACE\n \n #endif"}, {"sha": "7c89de22e5d614ccc5105b10b744de45456f0ac2", "filename": "libstdc++-v3/include/bits/atomic_base.h", "status": "modified", "additions": 215, "deletions": 149, "changes": 364, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_base.h?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -1,6 +1,6 @@\n-// -*- C++ -*- compatibility header.\n+// -*- C++ -*- header.\n \n-// Copyright (C) 2008, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -23,18 +23,21 @@\n // <http://www.gnu.org/licenses/>.\n \n /** @file bits/atomic_base.h\n- *  This is a Standard C++ Library header.\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n  */\n \n-#include <bits/c++config.h>\n-#include <stddef.h>\n-#include <stdbool.h> // XXX need to define bool w/o stdbool.h in tr1/cstdbool\n-\n #ifndef _GLIBCXX_ATOMIC_BASE_H\n #define _GLIBCXX_ATOMIC_BASE_H 1\n \n+#pragma GCC system_header\n+\n+#include <bits/c++config.h>\n+#include <stddef.h>\n+#include <stdbool.h>\n+#include <stdint.h>\n+\n _GLIBCXX_BEGIN_NAMESPACE(std)\n-_GLIBCXX_BEGIN_EXTERN_C\n \n   /**\n    * @defgroup atomics Atomics\n@@ -54,15 +57,85 @@ _GLIBCXX_BEGIN_EXTERN_C\n       memory_order_seq_cst\n     } memory_order;\n \n-  // Base for atomic_flag.\n-  typedef struct __atomic_flag_base\n+  inline memory_order\n+  __calculate_memory_order(memory_order __m)\n+  {\n+    const bool __cond1 = __m == memory_order_release;\n+    const bool __cond2 = __m == memory_order_acq_rel;\n+    memory_order __mo1(__cond1 ? memory_order_relaxed : __m);\n+    memory_order __mo2(__cond2 ? memory_order_acquire : __mo1);\n+    return __mo2;\n+  }\n+\n+  /// kill_dependency\n+  template<typename _Tp>\n+    inline _Tp\n+    kill_dependency(_Tp __y)\n+    {\n+      _Tp ret(__y);\n+      return ret;\n+    }\n+\n+  /**\n+   *  @brief Base type for atomic_flag. \n+   *\n+   *  Base type is POD with data, allowing atomic_flag to derive from\n+   *  it and meet the standard layout type requirement. In addition to\n+   *  compatibilty with a C interface, this allows different\n+   *  implementations of atomic_flag to use the same atomic operation\n+   *  functions, via a standard conversion to the __atomic_flag_base\n+   *  argument.\n+  */\n+  _GLIBCXX_BEGIN_EXTERN_C\n+\n+  struct __atomic_flag_base\n   {\n     bool _M_i;\n-  } __atomic_flag_base;\n+  };\n+\n+  _GLIBCXX_END_EXTERN_C\n \n #define ATOMIC_FLAG_INIT { false }\n \n-  /// 29.2 Lock-free Property\n+\n+  // Base types for atomics.\n+  //\n+  // Three nested namespaces for atomic implementation details.\n+  //\n+  // The nested namespace inlined into std:: is determined by the value\n+  // of the _GLIBCXX_ATOMIC_PROPERTY macro and the resulting\n+  // ATOMIC_*_LOCK_FREE macros.\n+  //\n+  // 0 == __atomic0 == Never lock-free\n+  // 1 == __atomic1 == Best available, sometimes lock-free\n+  // 2 == __atomic2 == Always lock-free\n+\n+  namespace __atomic0\n+  {\n+    struct atomic_flag;\n+    struct atomic_address;\n+\n+    template<typename _IntTp>\n+      struct __atomic_base;\n+  } \n+\n+  namespace __atomic2\n+  {\n+    struct atomic_flag;\n+    struct atomic_address;\n+\n+    template<typename _IntTp>\n+      struct __atomic_base;\n+  } \n+\n+  namespace __atomic1\n+  {\n+    using __atomic2::atomic_flag;\n+    using __atomic0::atomic_address;\n+    using __atomic0::__atomic_base;\n+  } \n+\n+  /// Lock-free Property\n #if defined(_GLIBCXX_ATOMIC_BUILTINS_1) && defined(_GLIBCXX_ATOMIC_BUILTINS_2) \\\n   && defined(_GLIBCXX_ATOMIC_BUILTINS_4) && defined(_GLIBCXX_ATOMIC_BUILTINS_8)\n # define _GLIBCXX_ATOMIC_PROPERTY 2\n@@ -75,150 +148,143 @@ _GLIBCXX_BEGIN_EXTERN_C\n # define _GLIBCXX_ATOMIC_NAMESPACE __atomic0\n #endif\n \n-#define ATOMIC_INTEGRAL_LOCK_FREE _GLIBCXX_ATOMIC_PROPERTY\n+#define ATOMIC_CHAR_LOCK_FREE _GLIBCXX_ATOMIC_PROPERTY\n+#define ATOMIC_CHAR16_T_LOCK_FREE _GLIBCXX_ATOMIC_PROPERTY\n+#define ATOMIC_CHAR32_T_LOCK_FREE _GLIBCXX_ATOMIC_PROPERTY\n+#define ATOMIC_WCHAR_T_LOCK_FREE _GLIBCXX_ATOMIC_PROPERTY\n+#define ATOMIC_SHORT_LOCK_FREE _GLIBCXX_ATOMIC_PROPERTY\n+#define ATOMIC_INT_LOCK_FREE _GLIBCXX_ATOMIC_PROPERTY\n+#define ATOMIC_LONG_LOCK_FREE _GLIBCXX_ATOMIC_PROPERTY\n+#define ATOMIC_LLONG_LOCK_FREE _GLIBCXX_ATOMIC_PROPERTY\n #define ATOMIC_ADDRESS_LOCK_FREE _GLIBCXX_ATOMIC_PROPERTY\n \n-  // Switch atomic integral base types based on C or C++.  In\n-  // addition, for \"C\" only provide type-generic macros for atomic\n-  // operations. (As C++ accomplishes the same thing with sets of\n-  // overloaded functions.\n-#ifdef __cplusplus\n   inline namespace _GLIBCXX_ATOMIC_NAMESPACE { }\n-# include <bits/atomicfwd_cxx.h>\n-#else\n-# include <bits/atomicfwd_c.h>\n-#endif\n \n-  // Typedefs for other atomic integral types.\n-  typedef atomic_schar \t\tatomic_int_least8_t;\n-  typedef atomic_uchar \t\tatomic_uint_least8_t;\n-  typedef atomic_short \t\tatomic_int_least16_t;\n-  typedef atomic_ushort \tatomic_uint_least16_t;\n-  typedef atomic_int \t\tatomic_int_least32_t;\n-  typedef atomic_uint \t\tatomic_uint_least32_t;\n-  typedef atomic_llong \t\tatomic_int_least64_t;\n-  typedef atomic_ullong \tatomic_uint_least64_t;\n-\n-  typedef atomic_schar \t\tatomic_int_fast8_t;\n-  typedef atomic_uchar \t\tatomic_uint_fast8_t;\n-  typedef atomic_short \t\tatomic_int_fast16_t;\n-  typedef atomic_ushort \tatomic_uint_fast16_t;\n-  typedef atomic_int \t\tatomic_int_fast32_t;\n-  typedef atomic_uint \t\tatomic_uint_fast32_t;\n-  typedef atomic_llong \t\tatomic_int_fast64_t;\n-  typedef atomic_ullong \tatomic_uint_fast64_t;\n-\n-  typedef atomic_long \t\tatomic_intptr_t;\n-  typedef atomic_ulong \t\tatomic_uintptr_t;\n-\n-  typedef atomic_long \t\tatomic_ssize_t;\n-  typedef atomic_ulong \t\tatomic_size_t;\n-\n-  typedef atomic_llong \t\tatomic_intmax_t;\n-  typedef atomic_ullong \tatomic_uintmax_t;\n-\n-  typedef atomic_long \t\tatomic_ptrdiff_t;\n-\n-  // Accessor functions for base atomic_flag type.\n-  bool\n-  atomic_flag_test_and_set_explicit(__atomic_flag_base*, memory_order)\n-  _GLIBCXX_NOTHROW;\n-\n-  inline bool\n-  atomic_flag_test_and_set(__atomic_flag_base* __a)\n-  { return atomic_flag_test_and_set_explicit(__a, memory_order_seq_cst); }\n-\n-  void\n-  atomic_flag_clear_explicit(__atomic_flag_base*, memory_order)\n-  _GLIBCXX_NOTHROW;\n-\n-  inline void\n-  atomic_flag_clear(__atomic_flag_base* __a)\n-  { atomic_flag_clear_explicit(__a, memory_order_seq_cst); }\n-\n-  void\n-  __atomic_flag_wait_explicit(__atomic_flag_base*, memory_order)\n-  _GLIBCXX_NOTHROW;\n-\n-  _GLIBCXX_CONST __atomic_flag_base*\n-  __atomic_flag_for_address(const void* __z) _GLIBCXX_NOTHROW;\n-\n-  // Implementation specific defines.\n-#define _ATOMIC_LOAD_(__a, __x)\t\t\t\t\t\t\\\n-  ({__typeof__ _ATOMIC_MEMBER_* __p = &_ATOMIC_MEMBER_;\t\t\t\\\n-    atomic_flag* __g = __atomic_flag_for_address(__p); \t\t\t\\\n-    __atomic_flag_wait_explicit(__g, __x);\t\t\t\t\\\n-    __typeof__ _ATOMIC_MEMBER_ __r = *__p;\t\t\t\t\\\n-    atomic_flag_clear_explicit(__g, __x);\t\t       \t\t\\\n-    __r; })\n-\n-#define _ATOMIC_STORE_(__a, __m, __x)\t\t\t\t\t\\\n-  ({__typeof__ _ATOMIC_MEMBER_* __p = &_ATOMIC_MEMBER_;\t\t\t\\\n-    __typeof__(__m) __v = (__m);\t\t\t       \t\t\\\n-    atomic_flag* __g = __atomic_flag_for_address(__p); \t\t\t\\\n-    __atomic_flag_wait_explicit(__g, __x);\t\t\t\t\\\n-    *__p = __v;\t\t\t\t\t\t\t\t\\\n-    atomic_flag_clear_explicit(__g, __x);\t\t       \t\t\\\n-    __v; })\n-\n-#define _ATOMIC_MODIFY_(__a, __o, __m, __x)\t\t\t\t\\\n-  ({__typeof__ _ATOMIC_MEMBER_* __p = &_ATOMIC_MEMBER_;\t\t\t\\\n-    __typeof__(__m) __v = (__m);\t\t\t       \t\t\\\n-    atomic_flag* __g = __atomic_flag_for_address(__p); \t\t\t\\\n-    __atomic_flag_wait_explicit(__g, __x);\t\t\t\t\\\n-    __typeof__ _ATOMIC_MEMBER_ __r = *__p;\t\t\t\t\\\n-    *__p __o __v;\t\t\t\t\t       \t\t\\\n-    atomic_flag_clear_explicit(__g, __x);\t\t       \t\t\\\n-    __r; })\n-\n-#define _ATOMIC_CMPEXCHNG_(__a, __e, __m, __x)\t\t\t\t\\\n-  ({__typeof__ _ATOMIC_MEMBER_* __p = &_ATOMIC_MEMBER_;\t\t\t\\\n-    __typeof__(__e) __q = (__e);\t\t\t       \t\t\\\n-    __typeof__(__m) __v = (__m);\t\t\t       \t\t\\\n-    bool __r;\t\t\t\t\t\t       \t\t\\\n-    atomic_flag* __g = __atomic_flag_for_address(__p); \t\t\t\\\n-    __atomic_flag_wait_explicit(__g, __x);\t\t\t\t\\\n-    __typeof__ _ATOMIC_MEMBER_ __t__ = *__p;\t\t       \t\t\\\n-    if (__t__ == *__q) { *__p = __v; __r = true; }\t\t\t\\\n-    else { *__q = __t__; __r = false; }\t\t       \t\t\t\\\n-    atomic_flag_clear_explicit(__g, __x);\t\t       \t\t\\\n-    __r; })\n+\n+  /// atomic_char\n+  typedef __atomic_base<char>  \t       \t\tatomic_char;\n+\n+  /// atomic_schar\n+  typedef __atomic_base<signed char>         \tatomic_schar;\n+\n+  /// atomic_uchar\n+  typedef __atomic_base<unsigned char>  \tatomic_uchar;\n+\n+  /// atomic_short\n+  typedef __atomic_base<short>  \t\tatomic_short;\n+\n+  /// atomic_ushort\n+  typedef __atomic_base<unsigned short>  \tatomic_ushort;\n+\n+  /// atomic_int\n+  typedef __atomic_base<int>  \t       \t\tatomic_int;\n+\n+  /// atomic_uint\n+  typedef __atomic_base<unsigned int>        \tatomic_uint;\n+\n+  /// atomic_long\n+  typedef __atomic_base<long>  \t       \t\tatomic_long;\n+\n+  /// atomic_ulong\n+  typedef __atomic_base<unsigned long>  \tatomic_ulong;\n+\n+  /// atomic_llong\n+  typedef __atomic_base<long long>  \t\tatomic_llong;\n+\n+  /// atomic_ullong\n+  typedef __atomic_base<unsigned long long> \tatomic_ullong;\n+\n+  /// atomic_wchar_t\n+  typedef __atomic_base<wchar_t>  \t\tatomic_wchar_t;\n+\n+  /// atomic_char16_t\n+  typedef __atomic_base<char16_t>  \t\tatomic_char16_t;\n+\n+  /// atomic_char32_t\n+  typedef __atomic_base<char32_t>  \t\tatomic_char32_t;\n+\n+  /// atomic_char32_t\n+  typedef __atomic_base<char32_t>  \t\tatomic_char32_t;\n+\n+\n+  /// atomic_int_least8_t\n+  typedef __atomic_base<int_least8_t>  \t\tatomic_int_least8_t;\n+\n+  /// atomic_uint_least8_t\n+  typedef __atomic_base<uint_least8_t>         \tatomic_uint_least8_t;\n+\n+  /// atomic_int_least16_t\n+  typedef __atomic_base<int_least16_t>         \tatomic_int_least16_t;\n+\n+  /// atomic_uint_least16_t\n+  typedef __atomic_base<uint_least16_t>        \tatomic_uint_least16_t;\n+\n+  /// atomic_int_least32_t\n+  typedef __atomic_base<int_least32_t>         \tatomic_int_least32_t;\n+\n+  /// atomic_uint_least32_t\n+  typedef __atomic_base<uint_least32_t>        \tatomic_uint_least32_t;\n+\n+  /// atomic_int_least64_t\n+  typedef __atomic_base<int_least64_t>         \tatomic_int_least64_t;\n+\n+  /// atomic_uint_least64_t\n+  typedef __atomic_base<uint_least64_t>        \tatomic_uint_least64_t;\n+\n+\n+  /// atomic_int_fast8_t\n+  typedef __atomic_base<int_fast8_t>  \t\tatomic_int_fast8_t;\n+\n+  /// atomic_uint_fast8_t\n+  typedef __atomic_base<uint_fast8_t>         \tatomic_uint_fast8_t;\n+\n+  /// atomic_int_fast16_t\n+  typedef __atomic_base<int_fast16_t>         \tatomic_int_fast16_t;\n+\n+  /// atomic_uint_fast16_t\n+  typedef __atomic_base<uint_fast16_t>        \tatomic_uint_fast16_t;\n+\n+  /// atomic_int_fast32_t\n+  typedef __atomic_base<int_fast32_t>         \tatomic_int_fast32_t;\n+\n+  /// atomic_uint_fast32_t\n+  typedef __atomic_base<uint_fast32_t>        \tatomic_uint_fast32_t;\n+\n+  /// atomic_int_fast64_t\n+  typedef __atomic_base<int_fast64_t>         \tatomic_int_fast64_t;\n+\n+  /// atomic_uint_fast64_t\n+  typedef __atomic_base<uint_fast64_t>        \tatomic_uint_fast64_t;\n+\n+\n+  /// atomic_intptr_t\n+  typedef __atomic_base<intptr_t>  \t       \tatomic_intptr_t;\n+\n+  /// atomic_uintptr_t\n+  typedef __atomic_base<uintptr_t>  \t       \tatomic_uintptr_t;\n+\n+  /// atomic_size_t\n+  typedef __atomic_base<size_t>  \t       \tatomic_size_t;\n+\n+  /// atomic_intmax_t\n+  typedef __atomic_base<intmax_t>  \t       \tatomic_intmax_t;\n+\n+  /// atomic_uintmax_t\n+  typedef __atomic_base<uintmax_t>  \t       \tatomic_uintmax_t;\n+\n+  /// atomic_ptrdiff_t\n+  typedef __atomic_base<ptrdiff_t>  \t       \tatomic_ptrdiff_t;\n+\n+\n+  struct atomic_bool;\n+\n+#define ATOMIC_VAR_INIT(_VI) { _VI }\n+\n+  template<typename _Tp>\n+    struct atomic;\n \n   // @} group atomics\n \n-_GLIBCXX_END_EXTERN_C\n _GLIBCXX_END_NAMESPACE\n \n-// Inject into global namespace.\n-#ifdef __cplusplus\n-\n-#include <atomic>\n-\n-using std::memory_order;\n-using std::memory_order_relaxed;\n-using std::memory_order_consume;\n-using std::memory_order_acquire;\n-using std::memory_order_release;\n-using std::memory_order_acq_rel;\n-using std::memory_order_seq_cst;\n-using std::atomic_flag;\n-using std::atomic_bool;\n-using std::atomic_char;\n-using std::atomic_schar;\n-using std::atomic_uchar;\n-using std::atomic_short;\n-using std::atomic_ushort;\n-using std::atomic_int;\n-using std::atomic_uint;\n-using std::atomic_long;\n-using std::atomic_ulong;\n-using std::atomic_llong;\n-using std::atomic_ullong;\n-using std::atomic_wchar_t;\n-using std::atomic_char16_t;\n-using std::atomic_char32_t;\n-using std::atomic_address;\n-using std::atomic;\n-#endif\n-\n #endif"}, {"sha": "0841843934517c5d63a5a7cd14126ca240aff4b1", "filename": "libstdc++-v3/include/bits/atomicfwd_c.h", "status": "removed", "additions": 0, "deletions": 174, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/900484dee595d91a71c7ae63734c199bd137afc6/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomicfwd_c.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/900484dee595d91a71c7ae63734c199bd137afc6/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomicfwd_c.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomicfwd_c.h?ref=900484dee595d91a71c7ae63734c199bd137afc6", "patch": "@@ -1,174 +0,0 @@\n-// -*- C++ -*- header.\n-\n-// Copyright (C) 2008, 2009\n-// Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 3, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// Under Section 7 of GPL version 3, you are granted additional\n-// permissions described in the GCC Runtime Library Exception, version\n-// 3.1, as published by the Free Software Foundation.\n-\n-// You should have received a copy of the GNU General Public License and\n-// a copy of the GCC Runtime Library Exception along with this program;\n-// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-// <http://www.gnu.org/licenses/>.\n-\n-/** @file bits/atomicfwd_c.h\n- *  This is an internal header file, included by other library headers.\n- *  You should not attempt to use it directly.\n- */\n-\n-// \"C\" only bits.\n-\n-#define _ATOMIC_MEMBER_ ((__a)->_M_i)\n-\n-  // POD base classes for atomic intgral types.\n-  struct __atomic_bool_base\n-  {\n-    bool _M_i;\n-  };\n-\n-  struct __atomic_char_base\n-  {\n-    char _M_i;\n-  };\n-\n-  struct __atomic_schar_base\n-  {\n-    signed char _M_i;\n-  };\n-\n-  struct __atomic_uchar_base\n-  {\n-    unsigned char _M_i;\n-  };\n-\n-  struct __atomic_short_base\n-  {\n-    short _M_i;\n-  };\n-\n-  struct __atomic_ushort_base\n-  {\n-    unsigned short _M_i;\n-  };\n-\n-  struct __atomic_int_base\n-  {\n-    int _M_i;\n-  };\n-\n-  struct __atomic_uint_base\n-  {\n-    unsigned int _M_i;\n-  };\n-\n-  struct __atomic_long_base\n-  {\n-    long _M_i;\n-  };\n-\n-  struct __atomic_ulong_base\n-  {\n-    unsigned long _M_i;\n-  };\n-\n-  struct __atomic_llong_base\n-  {\n-    long long _M_i;\n-  };\n-\n-  struct __atomic_ullong_base\n-  {\n-    unsigned long long\t_M_i;\n-  };\n-\n-  struct __atomic_wchar_t_base\n-  {\n-    wchar_t _M_i;\n-  };\n-\n-  typedef struct __atomic_flag_base \t\tatomic_flag;\n-  typedef struct __atomic_address_base \t\tatomic_address;\n-  typedef struct __atomic_bool_base\t\tatomic_bool;\n-  typedef struct __atomic_char_base \t\tatomic_char;\n-  typedef struct __atomic_schar_base \t\tatomic_schar;\n-  typedef struct __atomic_uchar_base \t\tatomic_uchar;\n-  typedef struct __atomic_short_base \t\tatomic_short;\n-  typedef struct __atomic_ushort_base \t\tatomic_ushort;\n-  typedef struct __atomic_int_base \t\tatomic_int;\n-  typedef struct __atomic_uint_base \t\tatomic_uint;\n-  typedef struct __atomic_long_base \t\tatomic_long;\n-  typedef struct __atomic_ulong_base \t\tatomic_ulong;\n-  typedef struct __atomic_llong_base \t\tatomic_llong;\n-  typedef struct __atomic_ullong_base \t\tatomic_ullong;\n-  typedef struct __atomic_wchar_t_base \t\tatomic_wchar_t;\n-  typedef struct __atomic_short_base \t\tatomic_char16_t;\n-  typedef struct __atomic_int_base \t\tatomic_char32_t;\n-\n-#define atomic_is_lock_free(__a)\t\t\t\t\t\\\n-  false\n-\n-#define atomic_load_explicit(__a, __x)\t\t\t\t\t\\\n-  _ATOMIC_LOAD_(__a, __x)\n-\n-#define atomic_load(__a)\t\t\t\t\t\t\\\n-  atomic_load_explicit(__a, memory_order_seq_cst)\n-\n-#define atomic_store_explicit(__a, __m, __x)\t\t\t\t\\\n-  _ATOMIC_STORE_(__a, __m, __x)\n-\n-#define atomic_store(__a, __m)\t\t\t\t\t\t\\\n-  atomic_store_explicit(__a, __m, memory_order_seq_cst)\n-\n-#define atomic_exchange_explicit(__a, __m, __x)\t\t\t\t\\\n-  _ATOMIC_MODIFY_(__a, =, __m, __x)\n-\n-#define atomic_exchange(__a, __m)\t\t\t\t\t\\\n-  atomic_exchange_explicit(__a, __m, memory_order_seq_cst)\n-\n-#define atomic_compare_exchange_explicit(__a, __e, __m, __x, __y)\t\\\n-  _ATOMIC_CMPEXCHNG_(__a, __e, __m, __x)\n-\n-#define atomic_compare_exchange(__a, __e, __m)\t\t\t\t\\\n-  _ATOMIC_CMPEXCHNG_(__a, __e, __m, memory_order_seq_cst)\n-\n-#define atomic_fetch_add_explicit(__a, __m, __x)\t\t\t\\\n-  _ATOMIC_MODIFY_(__a, +=, __m, __x)\n-\n-#define atomic_fetch_add(__a, __m)\t\t\t\t\t\\\n-  atomic_fetch_add_explicit(__a, __m, memory_order_seq_cst)\n-\n-#define atomic_fetch_sub_explicit(__a, __m, __x)\t\t\t\\\n-  _ATOMIC_MODIFY_(__a, -=, __m, __x)\n-\n-#define atomic_fetch_sub(__a, __m)\t\t\t\t\t\\\n-  atomic_fetch_sub_explicit(__a, __m, memory_order_seq_cst)\n-\n-#define atomic_fetch_and_explicit(__a, __m, __x)\t\t\t\\\n-  _ATOMIC_MODIFY_(__a, &=, __m, __x)\n-\n-#define atomic_fetch_and(__a, __m)\t\t\t\t\t\\\n-  atomic_fetch_and_explicit(__a, __m, memory_order_seq_cst)\n-\n-#define atomic_fetch_or_explicit(__a, __m, __x) \t\t\t\\\n-  _ATOMIC_MODIFY_(__a, |=, __m, __x)\n-\n-#define atomic_fetch_or(__a, __m)\t\t\t\t\t\\\n-  atomic_fetch_or_explicit(__a, __m, memory_order_seq_cst)\n-\n-#define atomic_fetch_xor_explicit(__a, __m, __x)\t\t\t\\\n-  _ATOMIC_MODIFY_(__a, ^=, __m, __x)\n-\n-#define atomic_fetch_xor(__a, __m)\t\t\t\t\t\\\n-  atomic_fetch_xor_explicit(__a, __m, memory_order_seq_cst)"}, {"sha": "8ef25e622cc84381a9f30501d80c0005fa753d83", "filename": "libstdc++-v3/include/bits/atomicfwd_cxx.h", "status": "removed", "additions": 0, "deletions": 117, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/900484dee595d91a71c7ae63734c199bd137afc6/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomicfwd_cxx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/900484dee595d91a71c7ae63734c199bd137afc6/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomicfwd_cxx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomicfwd_cxx.h?ref=900484dee595d91a71c7ae63734c199bd137afc6", "patch": "@@ -1,117 +0,0 @@\n-// -*- C++ -*- header.\n-\n-// Copyright (C) 2008, 2009, 2010\n-// Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 3, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// Under Section 7 of GPL version 3, you are granted additional\n-// permissions described in the GCC Runtime Library Exception, version\n-// 3.1, as published by the Free Software Foundation.\n-\n-// You should have received a copy of the GNU General Public License and\n-// a copy of the GCC Runtime Library Exception along with this program;\n-// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-// <http://www.gnu.org/licenses/>.\n-\n-/** @file bits/atomicfwd_cxx.h\n- *  This is an internal header file, included by other library headers.\n- *  You should not attempt to use it directly.\n- */\n-\n-// \"C++\" only bits.\n-\n-#define _ATOMIC_MEMBER_ _M_i\n-\n-_GLIBCXX_END_EXTERN_C\n-\n-  namespace __atomic0\n-  {\n-    template<typename _IntTp>\n-      struct __atomic_base;\n-\n-    struct atomic_flag;\n-    struct atomic_address;\n-    struct atomic_bool;\n-  } \n-\n-  namespace __atomic2\n-  {\n-    template<typename _IntTp>\n-      struct __atomic_base;\n-\n-    struct atomic_flag;\n-    struct atomic_address;\n-    struct atomic_bool;\n-  } \n-\n-  namespace __atomic1\n-  {\n-    using __atomic2::atomic_flag;\n-    using __atomic2::atomic_bool;\n-    using __atomic0::atomic_address;\n-    using __atomic0::__atomic_base;\n-  } \n-\n-  /**\n-   * @addtogroup atomics\n-   * @{\n-   */\n-\n-  /// atomic_char\n-  typedef __atomic_base<char>  \t       \t\tatomic_char;\n-\n-  /// atomic_schar\n-  typedef __atomic_base<signed char>         \tatomic_schar;\n-\n-  /// atomic_uchar\n-  typedef __atomic_base<unsigned char>  \tatomic_uchar;\n-\n-  /// atomic_short\n-  typedef __atomic_base<short>  \t\tatomic_short;\n-\n-  /// atomic_ushort\n-  typedef __atomic_base<unsigned short>  \tatomic_ushort;\n-\n-  /// atomic_int\n-  typedef __atomic_base<int>  \t       \t\tatomic_int;\n-\n-  /// atomic_uint\n-  typedef __atomic_base<unsigned int>        \tatomic_uint;\n-\n-  /// atomic_long\n-  typedef __atomic_base<long>  \t       \t\tatomic_long;\n-\n-  /// atomic_ulong\n-  typedef __atomic_base<unsigned long>  \tatomic_ulong;\n-\n-  /// atomic_llong\n-  typedef __atomic_base<long long>  \t\tatomic_llong;\n-\n-  /// atomic_ullong\n-  typedef __atomic_base<unsigned long long> \tatomic_ullong;\n-\n-  /// atomic_wchar_t\n-  typedef __atomic_base<wchar_t>  \t\tatomic_wchar_t;\n-\n-  /// atomic_char16_t\n-  typedef __atomic_base<char16_t>  \t\tatomic_char16_t;\n-\n-  /// atomic_char32_t\n-  typedef __atomic_base<char32_t>  \t\tatomic_char32_t;\n-\n-  template<typename _Tp>\n-    struct atomic;\n-\n-  // @} group atomics\n-\n-_GLIBCXX_BEGIN_EXTERN_C"}, {"sha": "1c556eb5b4e6117bf0b54a6b0f0964024e7b8972", "filename": "libstdc++-v3/include/bits/c++config", "status": "modified", "additions": 82, "deletions": 67, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -34,6 +34,27 @@\n // The current version of the C++ library in compressed ISO date format.\n #define __GLIBCXX__ \n \n+// Macros for various attributes.\n+#ifndef _GLIBCXX_PURE\n+# define _GLIBCXX_PURE __attribute__ ((__pure__))\n+#endif\n+\n+#ifndef _GLIBCXX_CONST\n+# define _GLIBCXX_CONST __attribute__ ((__const__))\n+#endif\n+\n+#ifndef _GLIBCXX_NORETURN\n+# define _GLIBCXX_NORETURN __attribute__ ((__noreturn__))\n+#endif\n+\n+#ifndef _GLIBCXX_NOTHROW\n+# ifdef __cplusplus\n+#  define _GLIBCXX_NOTHROW throw() \n+# else\n+#  define _GLIBCXX_NOTHROW __attribute__((__nothrow__))\n+# endif\n+#endif\n+\n // Macros for visibility.\n // _GLIBCXX_HAVE_ATTRIBUTE_VISIBILITY\n // _GLIBCXX_VISIBILITY_ATTR\n@@ -60,33 +81,39 @@\n # define _GLIBCXX_DEPRECATED_ATTR\n #endif\n \n-// Macros for race detectors.\n-// _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(A) and\n-// _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(A) should be used to explain\n-// atomic (lock-free) synchronization to race detectors:\n-// the race detector will infer a happens-before arc from the former to the\n-// latter when they share the same argument pointer.\n-//\n-// The most frequent use case for these macros (and the only case in the\n-// current implementation of the library) is atomic reference counting:\n-//   void _M_remove_reference()\n-//   {\n-//     _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);\n-//     if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount, -1) <= 0)\n-//       {\n-//         _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);\n-//         _M_destroy(__a);\n-//       }\n-//   }\n-// The annotations in this example tell the race detector that all memory\n-// accesses occurred when the refcount was positive do not race with\n-// memory accesses which occurred after the refcount became zero.\n+#if __cplusplus\n \n-#ifndef _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE\n-# define  _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(A)\n+namespace std\n+{\n+  typedef __SIZE_TYPE__ \tsize_t;\n+  typedef __PTRDIFF_TYPE__\tptrdiff_t;\n+  \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+  typedef decltype(nullptr)\tnullptr_t;\n #endif\n-#ifndef _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER\n-# define  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(A)\n+}\n+\n+// Macros for C compatibility. In particular, define extern \"C\"\n+// linkage only when using C++.\n+# define _GLIBCXX_BEGIN_EXTERN_C extern \"C\" {\n+# define _GLIBCXX_END_EXTERN_C }\n+\n+\n+// Macro for constexpr, to support in mixed 03/0x mode.\n+#ifndef _GLIBCXX_CONSTEXPR\n+# ifdef __GXX_EXPERIMENTAL_CXX0X__\n+#  define _GLIBCXX_CONSTEXPR constexpr\n+# else\n+#  define _GLIBCXX_CONSTEXPR \n+# endif\n+#endif\n+\n+#ifndef _GLIBCXX_USE_CONSTEXPR\n+# ifdef __GXX_EXPERIMENTAL_CXX0X__\n+#  define _GLIBCXX_USE_CONSTEXPR constexpr\n+# else\n+#  define _GLIBCXX_USE_CONSTEXPR const\n+# endif\n #endif\n \n // Macros for activating various namespace association modes.\n@@ -106,7 +133,6 @@\n     namespace tr1 { }\n   }\n */\n-#if __cplusplus\n \n #ifdef _GLIBCXX_DEBUG\n # define _GLIBCXX_NAMESPACE_ASSOCIATION_DEBUG 1\n@@ -136,6 +162,7 @@\n // _GLIBCXX_STD\n // _GLIBCXX_STD_D\n // _GLIBCXX_STD_P\n+// _GLIBCXX_STD_PR\n //\n // Macros for enclosing namespaces and possibly nested namespaces.\n // _GLIBCXX_BEGIN_NAMESPACE\n@@ -283,19 +310,42 @@ namespace std\n # define _GLIBCXX_END_LDBL_NAMESPACE\n #endif\n \n+// Macros for race detectors.\n+// _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(A) and\n+// _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(A) should be used to explain\n+// atomic (lock-free) synchronization to race detectors:\n+// the race detector will infer a happens-before arc from the former to the\n+// latter when they share the same argument pointer.\n+//\n+// The most frequent use case for these macros (and the only case in the\n+// current implementation of the library) is atomic reference counting:\n+//   void _M_remove_reference()\n+//   {\n+//     _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);\n+//     if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount, -1) <= 0)\n+//       {\n+//         _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);\n+//         _M_destroy(__a);\n+//       }\n+//   }\n+// The annotations in this example tell the race detector that all memory\n+// accesses occurred when the refcount was positive do not race with\n+// memory accesses which occurred after the refcount became zero.\n \n-// Defines for C compatibility. In particular, define extern \"C\"\n-// linkage only when using C++.\n-# define _GLIBCXX_BEGIN_EXTERN_C extern \"C\" {\n-# define _GLIBCXX_END_EXTERN_C }\n+#ifndef _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE\n+# define  _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(A)\n+#endif\n+#ifndef _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER\n+# define  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(A)\n+#endif\n \n #else // !__cplusplus\n+# define _GLIBCXX_BEGIN_EXTERN_C\n+# define _GLIBCXX_END_EXTERN_C \n # undef _GLIBCXX_BEGIN_NAMESPACE\n # undef _GLIBCXX_END_NAMESPACE\n # define _GLIBCXX_BEGIN_NAMESPACE(X) \n # define _GLIBCXX_END_NAMESPACE \n-# define _GLIBCXX_BEGIN_EXTERN_C\n-# define _GLIBCXX_END_EXTERN_C \n #endif\n \n // First includes.\n@@ -385,39 +435,4 @@ _GLIBCXX_END_NAMESPACE\n #undef min\n #undef max\n \n-#ifndef _GLIBCXX_PURE\n-# define _GLIBCXX_PURE __attribute__ ((__pure__))\n-#endif\n-\n-#ifndef _GLIBCXX_CONST\n-# define _GLIBCXX_CONST __attribute__ ((__const__))\n-#endif\n-\n-#ifndef _GLIBCXX_NORETURN\n-# define _GLIBCXX_NORETURN __attribute__ ((__noreturn__))\n-#endif\n-\n-#ifndef _GLIBCXX_NOTHROW\n-# ifdef __cplusplus\n-#  define _GLIBCXX_NOTHROW throw() \n-# else\n-#  define _GLIBCXX_NOTHROW __attribute__((__nothrow__))\n-# endif\n-#endif\n-\n-#ifdef __cplusplus\n-\n-_GLIBCXX_BEGIN_NAMESPACE(std)\n-\n-  typedef __SIZE_TYPE__         size_t;\n-  typedef __PTRDIFF_TYPE__   ptrdiff_t;\n-\n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n-  typedef decltype(nullptr)  nullptr_t;\n-#endif\n-\n-_GLIBCXX_END_NAMESPACE\n-\n-#endif // __cplusplus\n-\n // End of prewritten config; the discovered settings follow."}, {"sha": "2c1a5fd6b3c266d91e92770cc46dbfc0d9c98a89", "filename": "libstdc++-v3/include/bits/char_traits.h", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fchar_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fchar_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fchar_traits.h?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -92,11 +92,11 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n       assign(char_type& __c1, const char_type& __c2)\n       { __c1 = __c2; }\n \n-      static bool\n+      static _GLIBCXX_CONSTEXPR bool\n       eq(const char_type& __c1, const char_type& __c2)\n       { return __c1 == __c2; }\n \n-      static bool\n+      static _GLIBCXX_CONSTEXPR bool\n       lt(const char_type& __c1, const char_type& __c2)\n       { return __c1 < __c2; }\n \n@@ -118,23 +118,23 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n       static char_type*\n       assign(char_type* __s, std::size_t __n, char_type __a);\n \n-      static char_type\n+      static _GLIBCXX_CONSTEXPR char_type\n       to_char_type(const int_type& __c)\n       { return static_cast<char_type>(__c); }\n \n-      static int_type\n+      static _GLIBCXX_CONSTEXPR int_type\n       to_int_type(const char_type& __c)\n       { return static_cast<int_type>(__c); }\n \n-      static bool\n+      static _GLIBCXX_CONSTEXPR bool\n       eq_int_type(const int_type& __c1, const int_type& __c2)\n       { return __c1 == __c2; }\n \n-      static int_type\n+      static _GLIBCXX_CONSTEXPR int_type\n       eof()\n       { return static_cast<int_type>(_GLIBCXX_STDIO_EOF); }\n \n-      static int_type\n+      static _GLIBCXX_CONSTEXPR int_type\n       not_eof(const int_type& __c)\n       { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }\n     };\n@@ -239,11 +239,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       assign(char_type& __c1, const char_type& __c2)\n       { __c1 = __c2; }\n \n-      static bool\n+      static _GLIBCXX_CONSTEXPR bool\n       eq(const char_type& __c1, const char_type& __c2)\n       { return __c1 == __c2; }\n \n-      static bool\n+      static _GLIBCXX_CONSTEXPR bool\n       lt(const char_type& __c1, const char_type& __c2)\n       { return __c1 < __c2; }\n \n@@ -271,25 +271,25 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       assign(char_type* __s, size_t __n, char_type __a)\n       { return static_cast<char_type*>(__builtin_memset(__s, __a, __n)); }\n \n-      static char_type\n+      static _GLIBCXX_CONSTEXPR char_type\n       to_char_type(const int_type& __c)\n       { return static_cast<char_type>(__c); }\n \n       // To keep both the byte 0xff and the eof symbol 0xffffffff\n       // from ending up as 0xffffffff.\n-      static int_type\n+      static _GLIBCXX_CONSTEXPR int_type\n       to_int_type(const char_type& __c)\n       { return static_cast<int_type>(static_cast<unsigned char>(__c)); }\n \n-      static bool\n+      static _GLIBCXX_CONSTEXPR bool\n       eq_int_type(const int_type& __c1, const int_type& __c2)\n       { return __c1 == __c2; }\n \n-      static int_type\n+      static _GLIBCXX_CONSTEXPR int_type\n       eof()\n       { return static_cast<int_type>(_GLIBCXX_STDIO_EOF); }\n \n-      static int_type\n+      static _GLIBCXX_CONSTEXPR int_type\n       not_eof(const int_type& __c)\n       { return (__c == eof()) ? 0 : __c; }\n   };\n@@ -310,11 +310,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       assign(char_type& __c1, const char_type& __c2)\n       { __c1 = __c2; }\n \n-      static bool\n+      static _GLIBCXX_CONSTEXPR bool\n       eq(const char_type& __c1, const char_type& __c2)\n       { return __c1 == __c2; }\n \n-      static bool\n+      static _GLIBCXX_CONSTEXPR bool\n       lt(const char_type& __c1, const char_type& __c2)\n       { return __c1 < __c2; }\n \n@@ -342,23 +342,23 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       assign(char_type* __s, size_t __n, char_type __a)\n       { return wmemset(__s, __a, __n); }\n \n-      static char_type\n+      static _GLIBCXX_CONSTEXPR char_type\n       to_char_type(const int_type& __c)\n       { return char_type(__c); }\n \n-      static int_type\n+      static _GLIBCXX_CONSTEXPR int_type\n       to_int_type(const char_type& __c)\n       { return int_type(__c); }\n \n-      static bool\n+      static _GLIBCXX_CONSTEXPR bool\n       eq_int_type(const int_type& __c1, const int_type& __c2)\n       { return __c1 == __c2; }\n \n-      static int_type\n+      static _GLIBCXX_CONSTEXPR int_type\n       eof()\n       { return static_cast<int_type>(WEOF); }\n \n-      static int_type\n+      static _GLIBCXX_CONSTEXPR int_type\n       not_eof(const int_type& __c)\n       { return eq_int_type(__c, eof()) ? 0 : __c; }\n   };\n@@ -386,11 +386,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       assign(char_type& __c1, const char_type& __c2)\n       { __c1 = __c2; }\n \n-      static bool\n+      static _GLIBCXX_CONSTEXPR bool\n       eq(const char_type& __c1, const char_type& __c2)\n       { return __c1 == __c2; }\n \n-      static bool\n+      static _GLIBCXX_CONSTEXPR bool\n       lt(const char_type& __c1, const char_type& __c2)\n       { return __c1 < __c2; }\n \n@@ -445,23 +445,23 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \treturn __s;\n       }\n \n-      static char_type\n+      static _GLIBCXX_CONSTEXPR char_type\n       to_char_type(const int_type& __c)\n       { return char_type(__c); }\n \n-      static int_type\n+      static _GLIBCXX_CONSTEXPR int_type\n       to_int_type(const char_type& __c)\n       { return int_type(__c); }\n \n-      static bool\n+      static _GLIBCXX_CONSTEXPR bool\n       eq_int_type(const int_type& __c1, const int_type& __c2)\n       { return __c1 == __c2; }\n \n-      static int_type\n+      static _GLIBCXX_CONSTEXPR int_type\n       eof()\n       { return static_cast<int_type>(-1); }\n \n-      static int_type\n+      static _GLIBCXX_CONSTEXPR int_type\n       not_eof(const int_type& __c)\n       { return eq_int_type(__c, eof()) ? 0 : __c; }\n     };\n@@ -479,11 +479,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       assign(char_type& __c1, const char_type& __c2)\n       { __c1 = __c2; }\n \n-      static bool\n+      static _GLIBCXX_CONSTEXPR bool\n       eq(const char_type& __c1, const char_type& __c2)\n       { return __c1 == __c2; }\n \n-      static bool\n+      static _GLIBCXX_CONSTEXPR bool\n       lt(const char_type& __c1, const char_type& __c2)\n       { return __c1 < __c2; }\n \n@@ -538,23 +538,23 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \treturn __s;\n       }\n \n-      static char_type\n+      static _GLIBCXX_CONSTEXPR char_type\n       to_char_type(const int_type& __c)\n       { return char_type(__c); }\n \n-      static int_type\n+      static _GLIBCXX_CONSTEXPR int_type\n       to_int_type(const char_type& __c)\n       { return int_type(__c); }\n \n-      static bool\n+      static _GLIBCXX_CONSTEXPR bool\n       eq_int_type(const int_type& __c1, const int_type& __c2)\n       { return __c1 == __c2; }\n \n-      static int_type\n+      static _GLIBCXX_CONSTEXPR int_type\n       eof()\n       { return static_cast<int_type>(-1); }\n \n-      static int_type\n+      static _GLIBCXX_CONSTEXPR int_type\n       not_eof(const int_type& __c)\n       { return eq_int_type(__c, eof()) ? 0 : __c; }\n     };"}, {"sha": "f161a4d997c190a41a8364c675ae8f3106e66e58", "filename": "libstdc++-v3/include/bits/ios_base.h", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fios_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fios_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fios_base.h?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -71,34 +71,34 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       _S_ios_fmtflags_end = 1L << 16 \n     };\n \n-  inline _Ios_Fmtflags\n+  inline _GLIBCXX_CONSTEXPR _Ios_Fmtflags\n   operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)\n   { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }\n \n-  inline _Ios_Fmtflags\n+  inline _GLIBCXX_CONSTEXPR _Ios_Fmtflags\n   operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)\n   { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }\n \n-  inline _Ios_Fmtflags\n+  inline _GLIBCXX_CONSTEXPR _Ios_Fmtflags\n   operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)\n   { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }\n \n-  inline _Ios_Fmtflags&\n+  inline _GLIBCXX_CONSTEXPR _Ios_Fmtflags\n+  operator~(_Ios_Fmtflags __a)\n+  { return _Ios_Fmtflags(~static_cast<int>(__a)); }\n+\n+  inline const _Ios_Fmtflags&\n   operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)\n   { return __a = __a | __b; }\n \n-  inline _Ios_Fmtflags&\n+  inline const _Ios_Fmtflags&\n   operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)\n   { return __a = __a & __b; }\n \n-  inline _Ios_Fmtflags&\n+  inline const _Ios_Fmtflags&\n   operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)\n   { return __a = __a ^ __b; }\n \n-  inline _Ios_Fmtflags\n-  operator~(_Ios_Fmtflags __a)\n-  { return _Ios_Fmtflags(~static_cast<int>(__a)); }\n-\n \n   enum _Ios_Openmode \n     { \n@@ -111,34 +111,34 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       _S_ios_openmode_end = 1L << 16 \n     };\n \n-  inline _Ios_Openmode\n+  inline _GLIBCXX_CONSTEXPR _Ios_Openmode\n   operator&(_Ios_Openmode __a, _Ios_Openmode __b)\n   { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }\n \n-  inline _Ios_Openmode\n+  inline _GLIBCXX_CONSTEXPR _Ios_Openmode\n   operator|(_Ios_Openmode __a, _Ios_Openmode __b)\n   { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }\n \n-  inline _Ios_Openmode\n+  inline _GLIBCXX_CONSTEXPR _Ios_Openmode\n   operator^(_Ios_Openmode __a, _Ios_Openmode __b)\n   { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }\n \n-  inline _Ios_Openmode&\n+  inline _GLIBCXX_CONSTEXPR _Ios_Openmode\n+  operator~(_Ios_Openmode __a)\n+  { return _Ios_Openmode(~static_cast<int>(__a)); }\n+\n+  inline const _Ios_Openmode&\n   operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)\n   { return __a = __a | __b; }\n \n-  inline _Ios_Openmode&\n+  inline const _Ios_Openmode&\n   operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)\n   { return __a = __a & __b; }\n \n-  inline _Ios_Openmode&\n+  inline const _Ios_Openmode&\n   operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)\n   { return __a = __a ^ __b; }\n \n-  inline _Ios_Openmode\n-  operator~(_Ios_Openmode __a)\n-  { return _Ios_Openmode(~static_cast<int>(__a)); }\n-\n \n   enum _Ios_Iostate\n     { \n@@ -149,33 +149,34 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       _S_ios_iostate_end = 1L << 16 \n     };\n \n-  inline _Ios_Iostate\n+  inline _GLIBCXX_CONSTEXPR _Ios_Iostate\n   operator&(_Ios_Iostate __a, _Ios_Iostate __b)\n   { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }\n \n-  inline _Ios_Iostate\n+  inline _GLIBCXX_CONSTEXPR _Ios_Iostate\n   operator|(_Ios_Iostate __a, _Ios_Iostate __b)\n   { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }\n \n-  inline _Ios_Iostate\n+  inline _GLIBCXX_CONSTEXPR _Ios_Iostate\n   operator^(_Ios_Iostate __a, _Ios_Iostate __b)\n   { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }\n \n-  inline _Ios_Iostate&\n+  inline _GLIBCXX_CONSTEXPR _Ios_Iostate\n+  operator~(_Ios_Iostate __a)\n+  { return _Ios_Iostate(~static_cast<int>(__a)); }\n+\n+  inline const _Ios_Iostate&\n   operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)\n   { return __a = __a | __b; }\n \n-  inline _Ios_Iostate&\n+  inline const _Ios_Iostate&\n   operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)\n   { return __a = __a & __b; }\n \n-  inline _Ios_Iostate&\n+  inline const  _Ios_Iostate&\n   operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)\n   { return __a = __a ^ __b; }\n \n-  inline _Ios_Iostate\n-  operator~(_Ios_Iostate __a)\n-  { return _Ios_Iostate(~static_cast<int>(__a)); }\n \n   enum _Ios_Seekdir \n     { "}, {"sha": "28ced236e2741aa9c15d65111ee14fdaf768b06c", "filename": "libstdc++-v3/include/bits/random.h", "status": "modified", "additions": 57, "deletions": 93, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Frandom.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Frandom.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Frandom.h?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -169,12 +169,12 @@ namespace std\n       typedef _UIntType result_type;\n \n       /** The multiplier. */\n-      static const result_type multiplier   = __a;\n+      static constexpr result_type multiplier   = __a;\n       /** An increment. */\n-      static const result_type increment    = __c;\n+      static constexpr result_type increment    = __c;\n       /** The modulus. */\n-      static const result_type modulus      = __m;\n-      static const result_type default_seed = 1u;\n+      static constexpr result_type modulus      = __m;\n+      static constexpr result_type default_seed = 1u;\n \n       /**\n        * @brief Constructs a %linear_congruential_engine random number\n@@ -225,26 +225,20 @@ namespace std\n        *\n        * The minimum depends on the @p __c parameter: if it is zero, the\n        * minimum generated must be > 0, otherwise 0 is allowed.\n-       *\n-       * @todo This should be constexpr.\n        */\n-      result_type\n-      min() const\n+      static constexpr result_type\n+      min()\n       { return __c == 0u ? 1u : 0u; }\n \n       /**\n        * @brief Gets the largest possible value in the output range.\n-       *\n-       * @todo This should be constexpr.\n        */\n-      result_type\n-      max() const\n+      static constexpr result_type\n+      max()\n       { return __m - 1u; }\n \n       /**\n        * @brief Discard a sequence of random numbers.\n-       *\n-       * @todo Look for a faster way to do discard.\n        */\n       void\n       discard(unsigned long long __z)\n@@ -402,20 +396,20 @@ namespace std\n       typedef _UIntType result_type;\n \n       // parameter values\n-      static const size_t      word_size                 = __w;\n-      static const size_t      state_size                = __n;\n-      static const size_t      shift_size                = __m;\n-      static const size_t      mask_bits                 = __r;\n-      static const result_type xor_mask                  = __a;\n-      static const size_t      tempering_u               = __u;\n-      static const result_type tempering_d               = __d;\n-      static const size_t      tempering_s               = __s;\n-      static const result_type tempering_b               = __b;\n-      static const size_t      tempering_t               = __t;\n-      static const result_type tempering_c               = __c;\n-      static const size_t      tempering_l               = __l;\n-      static const result_type initialization_multiplier = __f;\n-      static const result_type default_seed = 5489u;\n+      static constexpr size_t      word_size                 = __w;\n+      static constexpr size_t      state_size                = __n;\n+      static constexpr size_t      shift_size                = __m;\n+      static constexpr size_t      mask_bits                 = __r;\n+      static constexpr result_type xor_mask                  = __a;\n+      static constexpr size_t      tempering_u               = __u;\n+      static constexpr result_type tempering_d               = __d;\n+      static constexpr size_t      tempering_s               = __s;\n+      static constexpr result_type tempering_b               = __b;\n+      static constexpr size_t      tempering_t               = __t;\n+      static constexpr result_type tempering_c               = __c;\n+      static constexpr size_t      tempering_l               = __l;\n+      static constexpr result_type initialization_multiplier = __f;\n+      static constexpr result_type default_seed = 5489u;\n \n       // constructors and member function\n       explicit\n@@ -444,26 +438,20 @@ namespace std\n \n       /**\n        * @brief Gets the smallest possible value in the output range.\n-       *\n-       * @todo This should be constexpr.\n        */\n-      result_type\n-      min() const\n+      static constexpr result_type\n+      min()\n       { return 0; };\n \n       /**\n        * @brief Gets the largest possible value in the output range.\n-       *\n-       * @todo This should be constexpr.\n        */\n-      result_type\n-      max() const\n+      static constexpr result_type\n+      max()\n       { return __detail::_Shift<_UIntType, __w>::__value - 1; }\n \n       /**\n        * @brief Discard a sequence of random numbers.\n-       *\n-       * @todo Look for a faster way to do discard.\n        */\n       void\n       discard(unsigned long long __z)\n@@ -608,10 +596,10 @@ namespace std\n       typedef _UIntType result_type;\n \n       // parameter values\n-      static const size_t      word_size    = __w;\n-      static const size_t      short_lag    = __s;\n-      static const size_t      long_lag     = __r;\n-      static const result_type default_seed = 19780503u;\n+      static constexpr size_t      word_size    = __w;\n+      static constexpr size_t      short_lag    = __s;\n+      static constexpr size_t      long_lag     = __r;\n+      static constexpr result_type default_seed = 19780503u;\n \n       /**\n        * @brief Constructs an explicitly seeded % subtract_with_carry_engine\n@@ -660,27 +648,21 @@ namespace std\n       /**\n        * @brief Gets the inclusive minimum value of the range of random\n        * integers returned by this generator.\n-       *\n-       * @todo This should be constexpr.\n        */\n-      result_type\n-      min() const\n+      static constexpr result_type\n+      min()\n       { return 0; }\n \n       /**\n        * @brief Gets the inclusive maximum value of the range of random\n        * integers returned by this generator.\n-       *\n-       * @todo This should be constexpr.\n        */\n-      result_type\n-      max() const\n+      static constexpr result_type\n+      max()\n       { return __detail::_Shift<_UIntType, __w>::__value - 1; }\n \n       /**\n        * @brief Discard a sequence of random numbers.\n-       *\n-       * @todo Look for a faster way to do discard.\n        */\n       void\n       discard(unsigned long long __z)\n@@ -794,8 +776,8 @@ namespace std\n       typedef typename _RandomNumberEngine::result_type result_type;\n \n       // parameter values\n-      static const size_t block_size = __p;\n-      static const size_t used_block = __r;\n+      static constexpr size_t block_size = __p;\n+      static constexpr size_t used_block = __r;\n \n       /**\n        * @brief Constructs a default %discard_block_engine engine.\n@@ -894,26 +876,20 @@ namespace std\n \n       /**\n        * @brief Gets the minimum value in the generated random number range.\n-       *\n-       * @todo This should be constexpr.\n        */\n-      result_type\n-      min() const\n-      { return _M_b.min(); }\n+      static constexpr result_type\n+      min()\n+      { return _RandomNumberEngine::min(); }\n \n       /**\n        * @brief Gets the maximum value in the generated random number range.\n-       *\n-       * @todo This should be constexpr.\n        */\n-      result_type\n-      max() const\n-      { return _M_b.max(); }\n+      static constexpr result_type\n+      max()\n+      { return _RandomNumberEngine::max(); }\n \n       /**\n        * @brief Discard a sequence of random numbers.\n-       *\n-       * @todo Look for a faster way to do discard.\n        */\n       void\n       discard(unsigned long long __z)\n@@ -1109,26 +1085,20 @@ namespace std\n \n       /**\n        * @brief Gets the minimum value in the generated random number range.\n-       *\n-       * @todo This should be constexpr.\n        */\n-      result_type\n-      min() const\n+      static constexpr result_type\n+      min()\n       { return 0U; }\n \n       /**\n        * @brief Gets the maximum value in the generated random number range.\n-       *\n-       * @todo This should be constexpr.\n        */\n-      result_type\n-      max() const\n+      static constexpr result_type\n+      max()\n       { return __detail::_Shift<_UIntType, __w>::__value - 1; }\n \n       /**\n        * @brief Discard a sequence of random numbers.\n-       *\n-       * @todo Look for a faster way to do discard.\n        */\n       void\n       discard(unsigned long long __z)\n@@ -1243,7 +1213,7 @@ namespace std\n       /** The type of the generated random value. */\n       typedef typename _RandomNumberEngine::result_type result_type;\n \n-      static const size_t table_size = __k;\n+      static constexpr size_t table_size = __k;\n \n       /**\n        * @brief Constructs a default %shuffle_order_engine engine.\n@@ -1345,26 +1315,20 @@ namespace std\n \n       /**\n        * Gets the minimum value in the generated random number range.\n-       *\n-       * @todo This should be constexpr.\n        */\n-      result_type\n-      min() const\n-      { return _M_b.min(); }\n+      static constexpr result_type\n+      min()\n+      { return _RandomNumberEngine::min(); }\n \n       /**\n        * Gets the maximum value in the generated random number range.\n-       *\n-       * @todo This should be constexpr.\n        */\n-      result_type\n-      max() const\n-      { return _M_b.max(); }\n+      static constexpr result_type\n+      max()\n+      { return _RandomNumberEngine::max(); }\n \n       /**\n        * Discard a sequence of random numbers.\n-       *\n-       * @todo Look for a faster way to do discard.\n        */\n       void\n       discard(unsigned long long __z)\n@@ -1617,7 +1581,7 @@ namespace std\n    */\n \n   /**\n-   * @addtogroup random_distributions_uniform Uniform\n+   * @addtogroup random_distributions_uniform Uniform Distributions\n    * @ingroup random_distributions\n    * @{\n    */\n@@ -1975,7 +1939,7 @@ namespace std\n   /* @} */ // group random_distributions_uniform\n \n   /**\n-   * @addtogroup random_distributions_normal Normal\n+   * @addtogroup random_distributions_normal Normal Distributions\n    * @ingroup random_distributions\n    * @{\n    */\n@@ -3229,7 +3193,7 @@ namespace std\n   /* @} */ // group random_distributions_normal\n \n   /**\n-   * @addtogroup random_distributions_bernoulli Bernoulli\n+   * @addtogroup random_distributions_bernoulli Bernoulli Distributions\n    * @ingroup random_distributions\n    * @{\n    */\n@@ -3960,7 +3924,7 @@ namespace std\n   /* @} */ // group random_distributions_bernoulli\n \n   /**\n-   * @addtogroup random_distributions_poisson Poisson\n+   * @addtogroup random_distributions_poisson Poisson Distributions\n    * @ingroup random_distributions\n    * @{\n    */"}, {"sha": "bfc43887b02cdc42aef648d27fa25b49fbe6f291", "filename": "libstdc++-v3/include/bits/random.tcc", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Frandom.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Frandom.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Frandom.tcc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -104,19 +104,19 @@ namespace std\n \n \n   template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>\n-    const _UIntType\n+    constexpr _UIntType\n     linear_congruential_engine<_UIntType, __a, __c, __m>::multiplier;\n \n   template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>\n-    const _UIntType\n+    constexpr _UIntType\n     linear_congruential_engine<_UIntType, __a, __c, __m>::increment;\n \n   template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>\n-    const _UIntType\n+    constexpr _UIntType\n     linear_congruential_engine<_UIntType, __a, __c, __m>::modulus;\n \n   template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>\n-    const _UIntType\n+    constexpr _UIntType\n     linear_congruential_engine<_UIntType, __a, __c, __m>::default_seed;\n \n   /**\n@@ -205,7 +205,7 @@ namespace std\n \t   _UIntType __a, size_t __u, _UIntType __d, size_t __s,\n \t   _UIntType __b, size_t __t, _UIntType __c, size_t __l,\n \t   _UIntType __f>\n-    const size_t\n+    constexpr size_t\n     mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,\n \t\t\t    __s, __b, __t, __c, __l, __f>::word_size;\n \n@@ -214,7 +214,7 @@ namespace std\n \t   _UIntType __a, size_t __u, _UIntType __d, size_t __s,\n \t   _UIntType __b, size_t __t, _UIntType __c, size_t __l,\n \t   _UIntType __f>\n-    const size_t\n+    constexpr size_t\n     mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,\n \t\t\t    __s, __b, __t, __c, __l, __f>::state_size;\n \n@@ -223,7 +223,7 @@ namespace std\n \t   _UIntType __a, size_t __u, _UIntType __d, size_t __s,\n \t   _UIntType __b, size_t __t, _UIntType __c, size_t __l,\n \t   _UIntType __f>\n-    const size_t\n+    constexpr size_t\n     mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,\n \t\t\t    __s, __b, __t, __c, __l, __f>::shift_size;\n \n@@ -232,7 +232,7 @@ namespace std\n \t   _UIntType __a, size_t __u, _UIntType __d, size_t __s,\n \t   _UIntType __b, size_t __t, _UIntType __c, size_t __l,\n \t   _UIntType __f>\n-    const size_t\n+    constexpr size_t\n     mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,\n \t\t\t    __s, __b, __t, __c, __l, __f>::mask_bits;\n \n@@ -241,7 +241,7 @@ namespace std\n \t   _UIntType __a, size_t __u, _UIntType __d, size_t __s,\n \t   _UIntType __b, size_t __t, _UIntType __c, size_t __l,\n \t   _UIntType __f>\n-    const _UIntType\n+    constexpr _UIntType\n     mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,\n \t\t\t    __s, __b, __t, __c, __l, __f>::xor_mask;\n \n@@ -250,7 +250,7 @@ namespace std\n \t   _UIntType __a, size_t __u, _UIntType __d, size_t __s,\n \t   _UIntType __b, size_t __t, _UIntType __c, size_t __l,\n \t   _UIntType __f>\n-    const size_t\n+    constexpr size_t\n     mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,\n \t\t\t    __s, __b, __t, __c, __l, __f>::tempering_u;\n    \n@@ -259,7 +259,7 @@ namespace std\n \t   _UIntType __a, size_t __u, _UIntType __d, size_t __s,\n \t   _UIntType __b, size_t __t, _UIntType __c, size_t __l,\n \t   _UIntType __f>\n-    const _UIntType\n+    constexpr _UIntType\n     mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,\n \t\t\t    __s, __b, __t, __c, __l, __f>::tempering_d;\n \n@@ -268,7 +268,7 @@ namespace std\n \t   _UIntType __a, size_t __u, _UIntType __d, size_t __s,\n \t   _UIntType __b, size_t __t, _UIntType __c, size_t __l,\n \t   _UIntType __f>\n-    const size_t\n+    constexpr size_t\n     mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,\n \t\t\t    __s, __b, __t, __c, __l, __f>::tempering_s;\n \n@@ -277,7 +277,7 @@ namespace std\n \t   _UIntType __a, size_t __u, _UIntType __d, size_t __s,\n \t   _UIntType __b, size_t __t, _UIntType __c, size_t __l,\n \t   _UIntType __f>\n-    const _UIntType\n+    constexpr _UIntType\n     mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,\n \t\t\t    __s, __b, __t, __c, __l, __f>::tempering_b;\n \n@@ -286,7 +286,7 @@ namespace std\n \t   _UIntType __a, size_t __u, _UIntType __d, size_t __s,\n \t   _UIntType __b, size_t __t, _UIntType __c, size_t __l,\n \t   _UIntType __f>\n-    const size_t\n+    constexpr size_t\n     mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,\n \t\t\t    __s, __b, __t, __c, __l, __f>::tempering_t;\n \n@@ -295,7 +295,7 @@ namespace std\n \t   _UIntType __a, size_t __u, _UIntType __d, size_t __s,\n \t   _UIntType __b, size_t __t, _UIntType __c, size_t __l,\n \t   _UIntType __f>\n-    const _UIntType\n+    constexpr _UIntType\n     mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,\n \t\t\t    __s, __b, __t, __c, __l, __f>::tempering_c;\n \n@@ -304,7 +304,7 @@ namespace std\n \t   _UIntType __a, size_t __u, _UIntType __d, size_t __s,\n \t   _UIntType __b, size_t __t, _UIntType __c, size_t __l,\n \t   _UIntType __f>\n-    const size_t\n+    constexpr size_t\n     mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,\n \t\t\t    __s, __b, __t, __c, __l, __f>::tempering_l;\n \n@@ -313,7 +313,7 @@ namespace std\n \t   _UIntType __a, size_t __u, _UIntType __d, size_t __s,\n \t   _UIntType __b, size_t __t, _UIntType __c, size_t __l,\n \t   _UIntType __f>\n-    const _UIntType\n+    constexpr _UIntType\n     mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,\n \t\t\t    __s, __b, __t, __c, __l, __f>::\n                                               initialization_multiplier;\n@@ -323,7 +323,7 @@ namespace std\n \t   _UIntType __a, size_t __u, _UIntType __d, size_t __s,\n \t   _UIntType __b, size_t __t, _UIntType __c, size_t __l,\n \t   _UIntType __f>\n-    const _UIntType\n+    constexpr _UIntType\n     mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,\n \t\t\t    __s, __b, __t, __c, __l, __f>::default_seed;\n \n@@ -500,19 +500,19 @@ namespace std\n \n \n   template<typename _UIntType, size_t __w, size_t __s, size_t __r>\n-    const size_t\n+    constexpr size_t\n     subtract_with_carry_engine<_UIntType, __w, __s, __r>::word_size;\n \n   template<typename _UIntType, size_t __w, size_t __s, size_t __r>\n-    const size_t\n+    constexpr size_t\n     subtract_with_carry_engine<_UIntType, __w, __s, __r>::short_lag;\n \n   template<typename _UIntType, size_t __w, size_t __s, size_t __r>\n-    const size_t\n+    constexpr size_t\n     subtract_with_carry_engine<_UIntType, __w, __s, __r>::long_lag;\n \n   template<typename _UIntType, size_t __w, size_t __s, size_t __r>\n-    const _UIntType\n+    constexpr _UIntType\n     subtract_with_carry_engine<_UIntType, __w, __s, __r>::default_seed;\n \n   template<typename _UIntType, size_t __w, size_t __s, size_t __r>\n@@ -651,11 +651,11 @@ namespace std\n \n \n   template<typename _RandomNumberEngine, size_t __p, size_t __r>\n-    const size_t\n+    constexpr size_t\n     discard_block_engine<_RandomNumberEngine, __p, __r>::block_size;\n \n   template<typename _RandomNumberEngine, size_t __p, size_t __r>\n-    const size_t\n+    constexpr size_t\n     discard_block_engine<_RandomNumberEngine, __p, __r>::used_block;\n \n   template<typename _RandomNumberEngine, size_t __p, size_t __r>\n@@ -761,7 +761,7 @@ namespace std\n \n \n   template<typename _RandomNumberEngine, size_t __k>\n-    const size_t\n+    constexpr size_t\n     shuffle_order_engine<_RandomNumberEngine, __k>::table_size;\n \n   template<typename _RandomNumberEngine, size_t __k>"}, {"sha": "65de55322897fdc6b3d836354386b297b8a9f637", "filename": "libstdc++-v3/include/bits/regex.h", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -349,28 +349,27 @@ namespace std\n       /**\n        * @name Constants\n        * std [28.8.1](1)\n-       * @todo These should be constexpr.\n        */\n       //@{\n-      static const regex_constants::syntax_option_type icase\n+      static constexpr regex_constants::syntax_option_type icase\n         = regex_constants::icase;\n-      static const regex_constants::syntax_option_type nosubs\n+      static constexpr regex_constants::syntax_option_type nosubs\n         = regex_constants::nosubs;\n-      static const regex_constants::syntax_option_type optimize\n+      static constexpr regex_constants::syntax_option_type optimize\n         = regex_constants::optimize;\n-      static const regex_constants::syntax_option_type collate\n+      static constexpr regex_constants::syntax_option_type collate\n         = regex_constants::collate;\n-      static const regex_constants::syntax_option_type ECMAScript\n+      static constexpr regex_constants::syntax_option_type ECMAScript\n         = regex_constants::ECMAScript;\n-      static const regex_constants::syntax_option_type basic\n+      static constexpr regex_constants::syntax_option_type basic\n         = regex_constants::basic;\n-      static const regex_constants::syntax_option_type extended\n+      static constexpr regex_constants::syntax_option_type extended\n         = regex_constants::extended;\n-      static const regex_constants::syntax_option_type awk\n+      static constexpr regex_constants::syntax_option_type awk\n         = regex_constants::awk;\n-      static const regex_constants::syntax_option_type grep\n+      static constexpr regex_constants::syntax_option_type grep\n         = regex_constants::grep;\n-      static const regex_constants::syntax_option_type egrep\n+      static constexpr regex_constants::syntax_option_type egrep\n         = regex_constants::egrep;\n       //@}\n "}, {"sha": "cf543baebd0e244c907e9d6f07105cd78c0bf0f8", "filename": "libstdc++-v3/include/bits/stl_iterator.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator.h?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -709,7 +709,7 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n       typedef typename __traits_type::reference \treference;\n       typedef typename __traits_type::pointer   \tpointer;\n \n-      __normal_iterator() : _M_current(_Iterator()) { }\n+      _GLIBCXX_CONSTEXPR __normal_iterator() : _M_current(_Iterator()) { }\n \n       explicit\n       __normal_iterator(const _Iterator& __i) : _M_current(__i) { }"}, {"sha": "0e651e7ba7681db8c2fd395d8afec124f176274b", "filename": "libstdc++-v3/include/bits/stl_pair.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -66,10 +66,11 @@\n _GLIBCXX_BEGIN_NAMESPACE(std)\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n+  /// piecewise_construct_t\n   struct piecewise_construct_t { };\n \n-  static const piecewise_construct_t piecewise_construct\n-    = piecewise_construct_t();\n+  /// piecewise_construct\n+  constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();\n \n   // forward declarations\n   template<typename...>\n@@ -93,7 +94,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       // 265.  std::pair::pair() effects overly restrictive\n       /** The default constructor creates @c first and @c second using their\n        *  respective default constructors.  */\n-      pair()\n+      _GLIBCXX_CONSTEXPR pair()\n       : first(), second() { }\n \n       /** Two objects may be passed to a @c pair constructor to be copied.  */"}, {"sha": "a5675cb14159a56c9e24991bc6de63823f6d7c05", "filename": "libstdc++-v3/include/bits/stream_iterator.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstream_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstream_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstream_iterator.h?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -1,6 +1,6 @@\n // Stream iterators\n \n-// Copyright (C) 2001, 2004, 2005, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2004, 2005, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -59,7 +59,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \n     public:\n       ///  Construct end of input stream iterator.\n-      istream_iterator()\n+      _GLIBCXX_CONSTEXPR istream_iterator()\n       : _M_stream(0), _M_value(), _M_ok(false) {}\n \n       ///  Construct start of input stream iterator."}, {"sha": "3ec1df180927c73930d68bfcd5b898eb62da6b31", "filename": "libstdc++-v3/include/bits/streambuf_iterator.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf_iterator.h?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -1,7 +1,7 @@\n // Streambuf iterators\n \n // Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,\n-// 2006, 2007, 2009\n+// 2006, 2007, 2009, 2010\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -93,7 +93,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \n     public:\n       ///  Construct end of input stream iterator.\n-      istreambuf_iterator() throw()\n+      _GLIBCXX_CONSTEXPR istreambuf_iterator() throw()\n       : _M_sbuf(0), _M_c(traits_type::eof()) { }\n \n       ///  Construct start of input stream iterator."}, {"sha": "ebbc521873a4c39632391fc839efc03b21c10b1a", "filename": "libstdc++-v3/include/bits/unique_ptr.h", "status": "modified", "additions": 76, "deletions": 77, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funique_ptr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funique_ptr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funique_ptr.h?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -44,7 +44,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n    */\n \n   /// Primary template, default_delete.\n-  template<typename _Tp> \n+  template<typename _Tp>\n     struct default_delete\n       {\n \tdefault_delete() { }\n@@ -65,7 +65,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n   // _GLIBCXX_RESOLVE_LIB_DEFECTS\n   // DR 740 - omit specialization for array objects with a compile time length\n   /// Specialization, default_delete.\n-  template<typename _Tp> \n+  template<typename _Tp>\n     struct default_delete<_Tp[]>\n     {\n       void\n@@ -78,11 +78,9 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n     };\n \n   /// 20.7.12.2 unique_ptr for single objects.\n-  template <typename _Tp, typename _Dp = default_delete<_Tp> > \n+  template <typename _Tp, typename _Dp = default_delete<_Tp> >\n     class unique_ptr\n     {\n-      typedef std::tuple<_Tp*, _Dp>  __tuple_type;\n-\n       // use SFINAE to determine whether _Del::pointer exists\n       class _Pointer\n       {\n@@ -95,19 +93,24 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \ttypedef typename remove_reference<_Dp>::type _Del;\n \n       public:\n-\ttypedef decltype( __test<_Del>(0) ) type;\n+\ttypedef decltype( __test<_Del>(0)) type;\n       };\n \n+      typedef std::tuple<_Tp*, _Dp>  \t__tuple_type;\n+      __tuple_type \t\t\t_M_t;\n+\n     public:\n       typedef typename _Pointer::type\tpointer;\n       typedef _Tp                       element_type;\n       typedef _Dp                       deleter_type;\n \n+      static_assert(!std::is_pointer<deleter_type>::value,\n+\t\t    \"constructed with null function pointer deleter\");\n+\n       // Constructors.\n       unique_ptr()\n       : _M_t(pointer(), deleter_type())\n-      { static_assert(!std::is_pointer<deleter_type>::value,\n-\t\t      \"constructed with null function pointer deleter\"); }\n+      { }\n \n       explicit\n       unique_ptr(pointer __p)\n@@ -116,22 +119,22 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t\t     \"constructed with null function pointer deleter\"); }\n \n       unique_ptr(pointer __p,\n-          typename std::conditional<std::is_reference<deleter_type>::value, \n-            deleter_type, const deleter_type&>::type __d)\n+\t  typename std::conditional<std::is_reference<deleter_type>::value,\n+\t    deleter_type, const deleter_type&>::type __d)\n       : _M_t(__p, __d) { }\n \n       unique_ptr(pointer __p,\n-          typename std::remove_reference<deleter_type>::type&& __d)\n+\t  typename std::remove_reference<deleter_type>::type&& __d)\n       : _M_t(std::move(__p), std::move(__d))\n-      { static_assert(!std::is_reference<deleter_type>::value, \n+      { static_assert(!std::is_reference<deleter_type>::value,\n \t\t      \"rvalue deleter bound to reference\"); }\n \n       unique_ptr(nullptr_t)\n       : _M_t(pointer(), deleter_type())\n       { }\n \n       // Move constructors.\n-      unique_ptr(unique_ptr&& __u) \n+      unique_ptr(unique_ptr&& __u)\n       : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter())) { }\n \n       template<typename _Up, typename _Ep, typename = typename\n@@ -143,17 +146,17 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t\t&& std::is_same<_Ep, _Dp>::value)\n \t       || (!std::is_reference<_Dp>::value\n \t\t   && std::is_convertible<_Ep, _Dp>::value))>\n-             ::type>\n-        unique_ptr(unique_ptr<_Up, _Ep>&& __u) \n-        : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter()))\n+\t     ::type>\n+\tunique_ptr(unique_ptr<_Up, _Ep>&& __u)\n+\t: _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter()))\n \t{ }\n \n #if _GLIBCXX_DEPRECATED\n       template<typename _Up, typename = typename\n \tstd::enable_if<std::is_convertible<_Up*, _Tp*>::value\n \t\t       && std::is_same<_Dp,\n \t\t\t\t       default_delete<_Tp>>::value>::type>\n-        unique_ptr(auto_ptr<_Up>&& __u)\n+\tunique_ptr(auto_ptr<_Up>&& __u)\n \t: _M_t(__u.release(), deleter_type()) { }\n #endif\n \n@@ -163,24 +166,24 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       // Assignment.\n       unique_ptr&\n       operator=(unique_ptr&& __u)\n-      { \n-        reset(__u.release()); \n-        get_deleter() = std::move(__u.get_deleter()); \n-        return *this;\n+      {\n+\treset(__u.release());\n+\tget_deleter() = std::move(__u.get_deleter());\n+\treturn *this;\n       }\n \n       template<typename _Up, typename _Ep, typename = typename\n-        std::enable_if\n+\tstd::enable_if\n \t  <std::is_convertible<typename unique_ptr<_Up, _Ep>::pointer,\n \t\t\t       pointer>::value\n-\t   && !std::is_array<_Up>::value>::type> \n-        unique_ptr&\n-        operator=(unique_ptr<_Up, _Ep>&& __u)\n+\t   && !std::is_array<_Up>::value>::type>\n+\tunique_ptr&\n+\toperator=(unique_ptr<_Up, _Ep>&& __u)\n \t{\n-          reset(__u.release()); \n-          get_deleter() = std::move(__u.get_deleter()); \n-          return *this;\n-        }\n+\t  reset(__u.release());\n+\t  get_deleter() = std::move(__u.get_deleter());\n+\t  return *this;\n+\t}\n \n       unique_ptr&\n       operator=(nullptr_t)\n@@ -221,7 +224,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \n       // Modifiers.\n       pointer\n-      release() \n+      release()\n       {\n \tpointer __p = get();\n \tstd::get<0>(_M_t) = pointer();\n@@ -247,46 +250,45 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       // Disable copy from lvalue.\n       unique_ptr(const unique_ptr&) = delete;\n       unique_ptr& operator=(const unique_ptr&) = delete;\n-\n-    private:\n-      __tuple_type _M_t;\n   };\n- \n+\n   /// 20.7.12.3 unique_ptr for array objects with a runtime length\n   // [unique.ptr.runtime]\n   // _GLIBCXX_RESOLVE_LIB_DEFECTS\n   // DR 740 - omit specialization for array objects with a compile time length\n   template<typename _Tp, typename _Dp>\n     class unique_ptr<_Tp[], _Dp>\n     {\n-      typedef std::tuple<_Tp*, _Dp>  __tuple_type;\n+      typedef std::tuple<_Tp*, _Dp>  \t__tuple_type;\n+      __tuple_type \t\t\t_M_t;\n \n     public:\n-      typedef _Tp*               pointer;\n-      typedef _Tp                element_type;      \n-      typedef _Dp        deleter_type;\n+      typedef _Tp*\t\t \tpointer;\n+      typedef _Tp\t\t \telement_type;\n+      typedef _Dp                       deleter_type;\n+\n+      static_assert(!std::is_pointer<deleter_type>::value,\n+\t\t    \"constructed with null function pointer deleter\");\n \n       // Constructors.\n       unique_ptr()\n       : _M_t(pointer(), deleter_type())\n-      { static_assert(!std::is_pointer<deleter_type>::value,\n-\t\t      \"constructed with null function pointer deleter\"); }\n+      { }\n \n       explicit\n       unique_ptr(pointer __p)\n       : _M_t(__p, deleter_type())\n-      { static_assert(!std::is_pointer<deleter_type>::value,\n-\t\t      \"constructed with null function pointer deleter\"); }\n+      { }\n \n       unique_ptr(pointer __p,\n-          typename std::conditional<std::is_reference<deleter_type>::value, \n-              deleter_type, const deleter_type&>::type __d) \n+\t  typename std::conditional<std::is_reference<deleter_type>::value,\n+\t      deleter_type, const deleter_type&>::type __d)\n       : _M_t(__p, __d) { }\n \n       unique_ptr(pointer __p,\n \t\t typename std::remove_reference<deleter_type>::type && __d)\n       : _M_t(std::move(__p), std::move(__d))\n-      { static_assert(!std::is_reference<deleter_type>::value, \n+      { static_assert(!std::is_reference<deleter_type>::value,\n \t\t      \"rvalue deleter bound to reference\"); }\n \n       /* TODO: use delegating constructor */\n@@ -295,11 +297,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       { }\n \n       // Move constructors.\n-      unique_ptr(unique_ptr&& __u) \n+      unique_ptr(unique_ptr&& __u)\n       : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter())) { }\n \n-      template<typename _Up, typename _Ep> \n-        unique_ptr(unique_ptr<_Up, _Ep>&& __u) \n+      template<typename _Up, typename _Ep>\n+\tunique_ptr(unique_ptr<_Up, _Ep>&& __u)\n \t: _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter()))\n \t{ }\n \n@@ -311,18 +313,18 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       operator=(unique_ptr&& __u)\n       {\n \treset(__u.release());\n-\tget_deleter() = std::move(__u.get_deleter()); \n-\treturn *this; \n+\tget_deleter() = std::move(__u.get_deleter());\n+\treturn *this;\n       }\n \n-      template<typename _Up, typename _Ep> \n-        unique_ptr&\n-        operator=(unique_ptr<_Up, _Ep>&& __u)\n+      template<typename _Up, typename _Ep>\n+\tunique_ptr&\n+\toperator=(unique_ptr<_Up, _Ep>&& __u)\n \t{\n-          reset(__u.release());\n-          get_deleter() = std::move(__u.get_deleter()); \n-          return *this;\n-        }\n+\t  reset(__u.release());\n+\t  get_deleter() = std::move(__u.get_deleter());\n+\t  return *this;\n+\t}\n \n       unique_ptr&\n       operator=(nullptr_t)\n@@ -332,8 +334,8 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       }\n \n       // Observers.\n-      typename std::add_lvalue_reference<element_type>::type \n-      operator[](size_t __i) const \n+      typename std::add_lvalue_reference<element_type>::type\n+      operator[](size_t __i) const\n       {\n \t_GLIBCXX_DEBUG_ASSERT(get() != pointer());\n \treturn get()[__i];\n@@ -343,28 +345,28 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       get() const\n       { return std::get<0>(_M_t); }\n \n-      deleter_type& \n+      deleter_type&\n       get_deleter()\n       { return std::get<1>(_M_t); }\n \n       const deleter_type&\n       get_deleter() const\n-      { return std::get<1>(_M_t); }    \n+      { return std::get<1>(_M_t); }\n \n-      explicit operator bool() const \n+      explicit operator bool() const\n       { return get() == pointer() ? false : true; }\n-    \n+\n       // Modifiers.\n       pointer\n-      release() \n+      release()\n       {\n \tpointer __p = get();\n \tstd::get<0>(_M_t) = pointer();\n \treturn __p;\n       }\n \n       void\n-      reset(pointer __p = pointer()) \n+      reset(pointer __p = pointer())\n       {\n \tusing std::swap;\n \tswap(std::get<0>(_M_t), __p);\n@@ -383,7 +385,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \n       // DR 821.\n       template<typename _Up>\n-        void reset(_Up) = delete;\n+\tvoid reset(_Up) = delete;\n \n       void\n       swap(unique_ptr& __u)\n@@ -399,27 +401,24 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       // Disable construction from convertible pointer types.\n       // (N2315 - 20.6.5.3.1)\n       template<typename _Up>\n-        unique_ptr(_Up*, typename\n+\tunique_ptr(_Up*, typename\n \t\t   std::conditional<std::is_reference<deleter_type>::value,\n \t\t   deleter_type, const deleter_type&>::type,\n-\t\t   typename std::enable_if<std::is_convertible<_Up*, \n+\t\t   typename std::enable_if<std::is_convertible<_Up*,\n \t\t   pointer>::value>::type* = 0) = delete;\n \n       template<typename _Up>\n-        unique_ptr(_Up*, typename std::remove_reference<deleter_type>::type&&,\n-\t\t   typename std::enable_if<std::is_convertible<_Up*, \n+\tunique_ptr(_Up*, typename std::remove_reference<deleter_type>::type&&,\n+\t\t   typename std::enable_if<std::is_convertible<_Up*,\n \t\t   pointer>::value>::type* = 0) = delete;\n \n       template<typename _Up>\n-        explicit\n-        unique_ptr(_Up*, typename std::enable_if<std::is_convertible<_Up*, \n+\texplicit\n+\tunique_ptr(_Up*, typename std::enable_if<std::is_convertible<_Up*,\n \t\t   pointer>::value>::type* = 0) = delete;\n-\n-    private:\n-      __tuple_type _M_t;\n   };\n-  \n-  template<typename _Tp, typename _Dp> \n+\n+  template<typename _Tp, typename _Dp>\n     inline void\n     swap(unique_ptr<_Tp, _Dp>& __x,\n \t unique_ptr<_Tp, _Dp>& __y)"}, {"sha": "1b24b494f1136970a88c034eddfe07694cf93664", "filename": "libstdc++-v3/include/c_compatibility/stdatomic.h", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/900484dee595d91a71c7ae63734c199bd137afc6/libstdc%2B%2B-v3%2Finclude%2Fc_compatibility%2Fstdatomic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/900484dee595d91a71c7ae63734c199bd137afc6/libstdc%2B%2B-v3%2Finclude%2Fc_compatibility%2Fstdatomic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_compatibility%2Fstdatomic.h?ref=900484dee595d91a71c7ae63734c199bd137afc6", "patch": "@@ -1,37 +0,0 @@\n-// -*- C++ -*- compatibility header.\n-\n-// Copyright (C) 2008, 2009 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 3, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// Under Section 7 of GPL version 3, you are granted additional\n-// permissions described in the GCC Runtime Library Exception, version\n-// 3.1, as published by the Free Software Foundation.\n-\n-// You should have received a copy of the GNU General Public License and\n-// a copy of the GCC Runtime Library Exception along with this program;\n-// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-// <http://www.gnu.org/licenses/>.\n-\n-/** @file stdatomic.h\n- *  This is a Standard C++ Library header.\n- */\n-\n-#include <bits/atomic_base.h>\n-\n-#ifndef _GLIBCXX_STDATOMIC_H\n-#define _GLIBCXX_STDATOMIC_H 1\n-\n-#ifdef _GLIBCXX_NAMESPACE_C\n-#endif\n-\n-#endif"}, {"sha": "fc4cb86c49d708f83024d26e57c4154ee398b928", "filename": "libstdc++-v3/include/std/atomic", "status": "modified", "additions": 645, "deletions": 115, "changes": 760, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fatomic", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fatomic", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fatomic?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -38,8 +38,9 @@\n # include <bits/c++0x_warning.h>\n #endif\n \n-#include <bits/c++config.h>\n #include <bits/atomic_base.h>\n+#include <bits/atomic_0.h>\n+#include <bits/atomic_2.h>\n \n _GLIBCXX_BEGIN_NAMESPACE(std)\n \n@@ -48,37 +49,103 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n    * @{\n    */\n \n-  /// kill_dependency\n-  template<typename _Tp>\n-    inline _Tp\n-    kill_dependency(_Tp __y)\n-    {\n-      _Tp ret(__y);\n-      return ret;\n-    }\n-\n-  inline memory_order\n-  __calculate_memory_order(memory_order __m)\n+  /// atomic_bool\n+  // NB: No operators or fetch-operations for this type.\n+  struct atomic_bool\n   {\n-    const bool __cond1 = __m == memory_order_release;\n-    const bool __cond2 = __m == memory_order_acq_rel;\n-    memory_order __mo1(__cond1 ? memory_order_relaxed : __m);\n-    memory_order __mo2(__cond2 ? memory_order_acquire : __mo1);\n-    return __mo2;\n-  }\n+  private:\n+    __atomic_base<bool>\t_M_base;\n+\n+  public:\n+    atomic_bool() = default;\n+    ~atomic_bool() = default;\n+    atomic_bool(const atomic_bool&) = delete;\n+    atomic_bool& operator=(const atomic_bool&) = delete;\n+    atomic_bool& operator=(const atomic_bool&) volatile = delete;\n+\n+    constexpr atomic_bool(bool __i) : _M_base(__i) { }\n+\n+    bool\n+    operator=(bool __i)\n+    { return _M_base.operator=(__i); }\n+\n+    operator bool() const\n+    { return _M_base.load(); }\n+\n+    operator bool() const volatile\n+    { return _M_base.load(); }\n+\n+    bool\n+    is_lock_free() const { return _M_base.is_lock_free(); }\n+\n+    bool\n+    is_lock_free() const volatile { return _M_base.is_lock_free(); }\n+\n+    void\n+    store(bool __i, memory_order __m = memory_order_seq_cst)\n+    { _M_base.store(__i, __m); }\n+\n+    void\n+    store(bool __i, memory_order __m = memory_order_seq_cst) volatile\n+    { _M_base.store(__i, __m); }\n+\n+    bool\n+    load(memory_order __m = memory_order_seq_cst) const\n+    { return _M_base.load(__m); }\n+\n+    bool\n+    load(memory_order __m = memory_order_seq_cst) const volatile\n+    { return _M_base.load(__m); }\n+\n+    bool\n+    exchange(bool __i, memory_order __m = memory_order_seq_cst)\n+    { return _M_base.exchange(__i, __m); }\n+\n+    bool\n+    exchange(bool __i, memory_order __m = memory_order_seq_cst) volatile\n+    { return _M_base.exchange(__i, __m); }\n+\n+    bool\n+    compare_exchange_weak(bool& __i1, bool __i2, memory_order __m1,\n+\t\t\t  memory_order __m2)\n+    { return _M_base.compare_exchange_weak(__i1, __i2, __m1, __m2); }\n+\n+    bool\n+    compare_exchange_weak(bool& __i1, bool __i2, memory_order __m1,\n+\t\t\t  memory_order __m2) volatile\n+    { return _M_base.compare_exchange_weak(__i1, __i2, __m1, __m2); }\n+\n+    bool\n+    compare_exchange_weak(bool& __i1, bool __i2,\n+\t\t\t  memory_order __m = memory_order_seq_cst)\n+    { return _M_base.compare_exchange_weak(__i1, __i2, __m); }\n+\n+    bool\n+    compare_exchange_weak(bool& __i1, bool __i2,\n+\t\t\t  memory_order __m = memory_order_seq_cst) volatile\n+    { return _M_base.compare_exchange_weak(__i1, __i2, __m); }\n+\n+    bool\n+    compare_exchange_strong(bool& __i1, bool __i2, memory_order __m1,\n+\t\t\t    memory_order __m2)\n+    { return _M_base.compare_exchange_strong(__i1, __i2, __m1, __m2); }\n+\n+    bool\n+    compare_exchange_strong(bool& __i1, bool __i2, memory_order __m1,\n+\t\t\t    memory_order __m2) volatile\n+    { return _M_base.compare_exchange_strong(__i1, __i2, __m1, __m2); }\n+\n+    bool\n+    compare_exchange_strong(bool& __i1, bool __i2,\n+\t\t\t    memory_order __m = memory_order_seq_cst)\n+    { return _M_base.compare_exchange_strong(__i1, __i2, __m); }\n+\n+    bool\n+    compare_exchange_strong(bool& __i1, bool __i2,\n+\t\t\t    memory_order __m = memory_order_seq_cst) volatile\n+    { return _M_base.compare_exchange_strong(__i1, __i2, __m); }\n+  };\n \n-  //\n-  // Three nested namespaces for atomic implementation details.\n-  //\n-  // The nested namespace inlined into std:: is determined by the value\n-  // of the _GLIBCXX_ATOMIC_PROPERTY macro and the resulting\n-  // ATOMIC_*_LOCK_FREE macros. See file atomic_base.h.\n-  //\n-  // 0 == __atomic0 == Never lock-free\n-  // 1 == __atomic1 == Best available, sometimes lock-free\n-  // 2 == __atomic2 == Always lock-free\n-#include <bits/atomic_0.h>\n-#include <bits/atomic_2.h>\n \n   /// atomic\n   /// 29.4.3, Generic atomic type, primary class template.\n@@ -92,37 +159,67 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       atomic() = default;\n       ~atomic() = default;\n       atomic(const atomic&) = delete;\n+      atomic& operator=(const atomic&) = delete;\n       atomic& operator=(const atomic&) volatile = delete;\n \n-      atomic(_Tp __i) : _M_i(__i) { }\n+      constexpr atomic(_Tp __i) : _M_i(__i) { }\n \n       operator _Tp() const;\n \n+      operator _Tp() const volatile;\n+\n       _Tp\n       operator=(_Tp __i) { store(__i); return __i; }\n \n+      _Tp\n+      operator=(_Tp __i) volatile { store(__i); return __i; }\n+\n+      bool\n+      is_lock_free() const;\n+\n       bool\n       is_lock_free() const volatile;\n \n+      void\n+      store(_Tp, memory_order = memory_order_seq_cst);\n+\n       void\n       store(_Tp, memory_order = memory_order_seq_cst) volatile;\n \n+      _Tp\n+      load(memory_order = memory_order_seq_cst) const;\n+\n       _Tp\n       load(memory_order = memory_order_seq_cst) const volatile;\n \n+      _Tp\n+      exchange(_Tp __i, memory_order = memory_order_seq_cst);\n+\n       _Tp\n       exchange(_Tp __i, memory_order = memory_order_seq_cst) volatile;\n \n+      bool\n+      compare_exchange_weak(_Tp&, _Tp, memory_order, memory_order);\n+\n       bool\n       compare_exchange_weak(_Tp&, _Tp, memory_order, memory_order) volatile;\n \n       bool\n-      compare_exchange_strong(_Tp&, _Tp, memory_order, memory_order) volatile;\n+      compare_exchange_weak(_Tp&, _Tp, memory_order = memory_order_seq_cst);\n \n       bool\n       compare_exchange_weak(_Tp&, _Tp,\n \t\t\t    memory_order = memory_order_seq_cst) volatile;\n \n+      bool\n+      compare_exchange_strong(_Tp&, _Tp, memory_order, memory_order);\n+\n+      bool\n+      compare_exchange_strong(_Tp&, _Tp, memory_order, memory_order) volatile;\n+\n+      bool\n+      compare_exchange_strong(_Tp&, _Tp, memory_order = memory_order_seq_cst);\n+\n       bool\n       compare_exchange_strong(_Tp&, _Tp,\n \t\t\t      memory_order = memory_order_seq_cst) volatile;\n@@ -138,86 +235,123 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       atomic(const atomic&) = delete;\n       atomic& operator=(const atomic&) volatile = delete;\n \n-      atomic(_Tp* __v) : atomic_address(__v) { }\n+      constexpr atomic(_Tp* __v) : atomic_address(__v) { }\n+\n+      void\n+      store(_Tp*, memory_order = memory_order_seq_cst);\n \n       void\n-      store(_Tp* __v, memory_order __m = memory_order_seq_cst)\n-      { atomic_address::store(__v, __m); }\n+      store(_Tp*, memory_order = memory_order_seq_cst) volatile;\n \n       _Tp*\n-      load(memory_order __m = memory_order_seq_cst) const\n-      { return static_cast<_Tp*>(atomic_address::load(__m)); }\n+      load(memory_order = memory_order_seq_cst) const;\n \n       _Tp*\n-      exchange(_Tp* __v, memory_order __m = memory_order_seq_cst)\n-      { return static_cast<_Tp*>(atomic_address::exchange(__v, __m)); }\n+      load(memory_order = memory_order_seq_cst) const volatile;\n+\n+      _Tp*\n+      exchange(_Tp*, memory_order = memory_order_seq_cst);\n+\n+      _Tp*\n+      exchange(_Tp*, memory_order = memory_order_seq_cst) volatile;\n \n       bool\n       compare_exchange_weak(_Tp*&, _Tp*, memory_order, memory_order);\n \n       bool\n-      compare_exchange_strong(_Tp*&, _Tp*, memory_order, memory_order);\n+      compare_exchange_weak(_Tp*&, _Tp*, memory_order, memory_order) volatile;\n \n       bool\n       compare_exchange_weak(_Tp*&, _Tp*, memory_order = memory_order_seq_cst);\n \n+      bool\n+      compare_exchange_weak(_Tp*&, _Tp*,\n+\t\t\t    memory_order = memory_order_seq_cst) volatile;\n+\n+      bool\n+      compare_exchange_strong(_Tp*&, _Tp*, memory_order, memory_order);\n+\n+      bool\n+      compare_exchange_strong(_Tp*&, _Tp*, memory_order, memory_order) volatile;\n+\n       bool\n       compare_exchange_strong(_Tp*&, _Tp*, memory_order = memory_order_seq_cst);\n \n+      bool\n+      compare_exchange_strong(_Tp*&, _Tp*,\n+\t\t\t      memory_order = memory_order_seq_cst) volatile;\n+\n       _Tp*\n       fetch_add(ptrdiff_t, memory_order = memory_order_seq_cst);\n \n+      _Tp*\n+      fetch_add(ptrdiff_t, memory_order = memory_order_seq_cst) volatile;\n+\n       _Tp*\n       fetch_sub(ptrdiff_t, memory_order = memory_order_seq_cst);\n \n+      _Tp*\n+      fetch_sub(ptrdiff_t, memory_order = memory_order_seq_cst) volatile;\n+\n       operator _Tp*() const\n       { return load(); }\n \n+      operator _Tp*() const volatile\n+      { return load(); }\n+\n       _Tp*\n       operator=(_Tp* __v)\n       {\n \tstore(__v);\n \treturn __v;\n       }\n \n+      _Tp*\n+      operator=(_Tp* __v) volatile\n+      {\n+\tstore(__v);\n+\treturn __v;\n+      }\n+\n       _Tp*\n       operator++(int) { return fetch_add(1); }\n \n+      _Tp*\n+      operator++(int) volatile { return fetch_add(1); }\n+\n       _Tp*\n       operator--(int) { return fetch_sub(1); }\n \n+      _Tp*\n+      operator--(int) volatile { return fetch_sub(1); }\n+\n       _Tp*\n       operator++() { return fetch_add(1) + 1; }\n \n+      _Tp*\n+      operator++() volatile { return fetch_add(1) + 1; }\n+\n       _Tp*\n       operator--() { return fetch_sub(1) - 1; }\n \n+      _Tp*\n+      operator--() volatile { return fetch_sub(1) - 1; }\n+\n       _Tp*\n       operator+=(ptrdiff_t __d)\n       { return fetch_add(__d) + __d; }\n \n+      _Tp*\n+      operator+=(ptrdiff_t __d) volatile\n+      { return fetch_add(__d) + __d; }\n+\n       _Tp*\n       operator-=(ptrdiff_t __d)\n       { return fetch_sub(__d) - __d; }\n-    };\n-\n-\n-  /// Explicit specialization for void*\n-  template<>\n-    struct atomic<void*> : public atomic_address\n-    {\n-      typedef void* \t\t\t__integral_type;\n-      typedef atomic_address \t\t__base_type;\n-\n-      atomic() = default;\n-      ~atomic() = default;\n-      atomic(const atomic&) = delete;\n-      atomic& operator=(const atomic&) volatile = delete;\n-\n-      atomic(__integral_type __i) : __base_type(__i) { }\n \n-      using __base_type::operator __integral_type;\n-      using __base_type::operator=;\n+      _Tp*\n+      operator-=(ptrdiff_t __d) volatile\n+      { return fetch_sub(__d) - __d; }\n     };\n \n   /// Explicit specialization for bool.\n@@ -230,9 +364,10 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       atomic() = default;\n       ~atomic() = default;\n       atomic(const atomic&) = delete;\n+      atomic& operator=(const atomic&) = delete;\n       atomic& operator=(const atomic&) volatile = delete;\n \n-      atomic(__integral_type __i) : __base_type(__i) { }\n+      constexpr atomic(__integral_type __i) : __base_type(__i) { }\n \n       using __base_type::operator __integral_type;\n       using __base_type::operator=;\n@@ -248,9 +383,10 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       atomic() = default;\n       ~atomic() = default;\n       atomic(const atomic&) = delete;\n+      atomic& operator=(const atomic&) = delete;\n       atomic& operator=(const atomic&) volatile = delete;\n \n-      atomic(__integral_type __i) : __base_type(__i) { }\n+      constexpr atomic(__integral_type __i) : __base_type(__i) { }\n \n       using __base_type::operator __integral_type;\n       using __base_type::operator=;\n@@ -266,9 +402,10 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       atomic() = default;\n       ~atomic() = default;\n       atomic(const atomic&) = delete;\n+      atomic& operator=(const atomic&) = delete;\n       atomic& operator=(const atomic&) volatile = delete;\n \n-      atomic(__integral_type __i) : __base_type(__i) { }\n+      constexpr atomic(__integral_type __i) : __base_type(__i) { }\n \n       using __base_type::operator __integral_type;\n       using __base_type::operator=;\n@@ -284,9 +421,10 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       atomic() = default;\n       ~atomic() = default;\n       atomic(const atomic&) = delete;\n+      atomic& operator=(const atomic&) = delete;\n       atomic& operator=(const atomic&) volatile = delete;\n \n-      atomic(__integral_type __i) : __base_type(__i) { }\n+      constexpr atomic(__integral_type __i) : __base_type(__i) { }\n \n       using __base_type::operator __integral_type;\n       using __base_type::operator=;\n@@ -302,9 +440,10 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       atomic() = default;\n       ~atomic() = default;\n       atomic(const atomic&) = delete;\n+      atomic& operator=(const atomic&) = delete;\n       atomic& operator=(const atomic&) volatile = delete;\n \n-      atomic(__integral_type __i) : __base_type(__i) { }\n+      constexpr atomic(__integral_type __i) : __base_type(__i) { }\n \n       using __base_type::operator __integral_type;\n       using __base_type::operator=;\n@@ -320,9 +459,10 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       atomic() = default;\n       ~atomic() = default;\n       atomic(const atomic&) = delete;\n+      atomic& operator=(const atomic&) = delete;\n       atomic& operator=(const atomic&) volatile = delete;\n \n-      atomic(__integral_type __i) : __base_type(__i) { }\n+      constexpr atomic(__integral_type __i) : __base_type(__i) { }\n \n       using __base_type::operator __integral_type;\n       using __base_type::operator=;\n@@ -338,9 +478,10 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       atomic() = default;\n       ~atomic() = default;\n       atomic(const atomic&) = delete;\n+      atomic& operator=(const atomic&) = delete;\n       atomic& operator=(const atomic&) volatile = delete;\n \n-      atomic(__integral_type __i) : __base_type(__i) { }\n+      constexpr atomic(__integral_type __i) : __base_type(__i) { }\n \n       using __base_type::operator __integral_type;\n       using __base_type::operator=;\n@@ -356,9 +497,10 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       atomic() = default;\n       ~atomic() = default;\n       atomic(const atomic&) = delete;\n+      atomic& operator=(const atomic&) = delete;\n       atomic& operator=(const atomic&) volatile = delete;\n \n-      atomic(__integral_type __i) : __base_type(__i) { }\n+      constexpr atomic(__integral_type __i) : __base_type(__i) { }\n \n       using __base_type::operator __integral_type;\n       using __base_type::operator=;\n@@ -374,9 +516,10 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       atomic() = default;\n       ~atomic() = default;\n       atomic(const atomic&) = delete;\n+      atomic& operator=(const atomic&) = delete;\n       atomic& operator=(const atomic&) volatile = delete;\n \n-      atomic(__integral_type __i) : __base_type(__i) { }\n+      constexpr atomic(__integral_type __i) : __base_type(__i) { }\n \n       using __base_type::operator __integral_type;\n       using __base_type::operator=;\n@@ -392,9 +535,10 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       atomic() = default;\n       ~atomic() = default;\n       atomic(const atomic&) = delete;\n+      atomic& operator=(const atomic&) = delete;\n       atomic& operator=(const atomic&) volatile = delete;\n \n-      atomic(__integral_type __i) : __base_type(__i) { }\n+      constexpr atomic(__integral_type __i) : __base_type(__i) { }\n \n       using __base_type::operator __integral_type;\n       using __base_type::operator=;\n@@ -410,9 +554,10 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       atomic() = default;\n       ~atomic() = default;\n       atomic(const atomic&) = delete;\n+      atomic& operator=(const atomic&) = delete;\n       atomic& operator=(const atomic&) volatile = delete;\n \n-      atomic(__integral_type __i) : __base_type(__i) { }\n+      constexpr atomic(__integral_type __i) : __base_type(__i) { }\n \n       using __base_type::operator __integral_type;\n       using __base_type::operator=;\n@@ -428,9 +573,10 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       atomic() = default;\n       ~atomic() = default;\n       atomic(const atomic&) = delete;\n+      atomic& operator=(const atomic&) = delete;\n       atomic& operator=(const atomic&) volatile = delete;\n \n-      atomic(__integral_type __i) : __base_type(__i) { }\n+      constexpr atomic(__integral_type __i) : __base_type(__i) { }\n \n       using __base_type::operator __integral_type;\n       using __base_type::operator=;\n@@ -446,9 +592,10 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       atomic() = default;\n       ~atomic() = default;\n       atomic(const atomic&) = delete;\n+      atomic& operator=(const atomic&) = delete;\n       atomic& operator=(const atomic&) volatile = delete;\n \n-      atomic(__integral_type __i) : __base_type(__i) { }\n+      constexpr atomic(__integral_type __i) : __base_type(__i) { }\n \n       using __base_type::operator __integral_type;\n       using __base_type::operator=;\n@@ -464,9 +611,10 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       atomic() = default;\n       ~atomic() = default;\n       atomic(const atomic&) = delete;\n+      atomic& operator=(const atomic&) = delete;\n       atomic& operator=(const atomic&) volatile = delete;\n \n-      atomic(__integral_type __i) : __base_type(__i) { }\n+      constexpr atomic(__integral_type __i) : __base_type(__i) { }\n \n       using __base_type::operator __integral_type;\n       using __base_type::operator=;\n@@ -482,14 +630,36 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       atomic() = default;\n       ~atomic() = default;\n       atomic(const atomic&) = delete;\n+      atomic& operator=(const atomic&) = delete;\n       atomic& operator=(const atomic&) volatile = delete;\n \n-      atomic(__integral_type __i) : __base_type(__i) { }\n+      constexpr atomic(__integral_type __i) : __base_type(__i) { }\n \n       using __base_type::operator __integral_type;\n       using __base_type::operator=;\n     };\n \n+\n+  template<typename _Tp>\n+    _Tp*\n+    atomic<_Tp*>::load(memory_order __m) const\n+    { return static_cast<_Tp*>(atomic_address::load(__m)); }\n+\n+  template<typename _Tp>\n+    _Tp*\n+    atomic<_Tp*>::load(memory_order __m) const volatile\n+    { return static_cast<_Tp*>(atomic_address::load(__m)); }\n+\n+  template<typename _Tp>\n+    _Tp*\n+    atomic<_Tp*>::exchange(_Tp* __v, memory_order __m)\n+    { return static_cast<_Tp*>(atomic_address::exchange(__v, __m)); }\n+\n+  template<typename _Tp>\n+    _Tp*\n+    atomic<_Tp*>::exchange(_Tp* __v, memory_order __m) volatile\n+    { return static_cast<_Tp*>(atomic_address::exchange(__v, __m)); }\n+\n   template<typename _Tp>\n     bool\n     atomic<_Tp*>::compare_exchange_weak(_Tp*& __r, _Tp* __v, memory_order __m1,\n@@ -500,6 +670,33 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       return atomic_address::compare_exchange_weak(*__vr, __vv, __m1, __m2);\n     }\n \n+  template<typename _Tp>\n+    bool\n+    atomic<_Tp*>::compare_exchange_weak(_Tp*& __r, _Tp* __v, memory_order __m1,\n+\t\t\t\t\tmemory_order __m2) volatile\n+    {\n+      void** __vr = reinterpret_cast<void**>(&__r);\n+      void* __vv = static_cast<void*>(__v);\n+      return atomic_address::compare_exchange_weak(*__vr, __vv, __m1, __m2);\n+    }\n+\n+  template<typename _Tp>\n+    bool\n+    atomic<_Tp*>::compare_exchange_weak(_Tp*& __r, _Tp* __v, memory_order __m)\n+    {\n+      return compare_exchange_weak(__r, __v, __m,\n+\t\t\t\t   __calculate_memory_order(__m));\n+    }\n+\n+  template<typename _Tp>\n+    bool\n+    atomic<_Tp*>::compare_exchange_weak(_Tp*& __r, _Tp* __v,\n+\t\t\t\t\tmemory_order __m) volatile\n+    {\n+      return compare_exchange_weak(__r, __v, __m,\n+\t\t\t\t   __calculate_memory_order(__m));\n+    }\n+\n   template<typename _Tp>\n     bool\n     atomic<_Tp*>::compare_exchange_strong(_Tp*& __r, _Tp* __v,\n@@ -513,17 +710,28 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \n   template<typename _Tp>\n     bool\n-    atomic<_Tp*>::compare_exchange_weak(_Tp*& __r, _Tp* __v,\n-\t\t\t\t\tmemory_order __m)\n+    atomic<_Tp*>::compare_exchange_strong(_Tp*& __r, _Tp* __v,\n+\t\t\t\t\t  memory_order __m1,\n+\t\t\t\t\t  memory_order __m2) volatile\n     {\n-      return compare_exchange_weak(__r, __v, __m,\n-\t\t\t\t   __calculate_memory_order(__m));\n+      void** __vr = reinterpret_cast<void**>(&__r);\n+      void* __vv = static_cast<void*>(__v);\n+      return atomic_address::compare_exchange_strong(*__vr, __vv, __m1, __m2);\n+    }\n+\n+  template<typename _Tp>\n+    bool\n+    atomic<_Tp*>::compare_exchange_strong(_Tp*& __r, _Tp* __v,\n+\t\t\t\t\t  memory_order __m)\n+    {\n+      return compare_exchange_strong(__r, __v, __m,\n+\t\t\t\t     __calculate_memory_order(__m));\n     }\n \n   template<typename _Tp>\n     bool\n     atomic<_Tp*>::compare_exchange_strong(_Tp*& __r, _Tp* __v,\n-\t\t\t\t\tmemory_order __m)\n+\t\t\t\t\t  memory_order __m) volatile\n     {\n       return compare_exchange_strong(__r, __v, __m,\n \t\t\t\t     __calculate_memory_order(__m));\n@@ -537,6 +745,14 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       return static_cast<_Tp*>(__p);\n     }\n \n+  template<typename _Tp>\n+    _Tp*\n+    atomic<_Tp*>::fetch_add(ptrdiff_t __d, memory_order __m) volatile\n+    {\n+      void* __p = atomic_fetch_add_explicit(this, sizeof(_Tp) * __d, __m);\n+      return static_cast<_Tp*>(__p);\n+    }\n+\n   template<typename _Tp>\n     _Tp*\n     atomic<_Tp*>::fetch_sub(ptrdiff_t __d, memory_order __m)\n@@ -545,44 +761,127 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       return static_cast<_Tp*>(__p);\n     }\n \n-  // Convenience function definitions, atomic_flag.\n+  template<typename _Tp>\n+    _Tp*\n+    atomic<_Tp*>::fetch_sub(ptrdiff_t __d, memory_order __m) volatile\n+    {\n+      void* __p = atomic_fetch_sub_explicit(this, sizeof(_Tp) * __d, __m);\n+      return static_cast<_Tp*>(__p);\n+    }\n+\n+\n+  // Function definitions, atomic_flag operations.\n   inline bool\n   atomic_flag_test_and_set_explicit(atomic_flag* __a, memory_order __m)\n   { return __a->test_and_set(__m); }\n \n+  inline bool\n+  atomic_flag_test_and_set_explicit(volatile atomic_flag* __a, \n+\t\t\t\t    memory_order __m)\n+  { return __a->test_and_set(__m); }\n+\n   inline void\n   atomic_flag_clear_explicit(atomic_flag* __a, memory_order __m)\n-  { return __a->clear(__m); }\n+  { __a->clear(__m); }\n+\n+  inline void\n+  atomic_flag_clear_explicit(volatile atomic_flag* __a, memory_order __m)\n+  { __a->clear(__m); }\n \n+  inline bool\n+  atomic_flag_test_and_set(atomic_flag* __a)\n+  { return atomic_flag_test_and_set_explicit(__a, memory_order_seq_cst); }\n \n-  // Convenience function definitions, atomic_address.\n+  inline bool\n+  atomic_flag_test_and_set(volatile atomic_flag* __a)\n+  { return atomic_flag_test_and_set_explicit(__a, memory_order_seq_cst); }\n+\n+  inline void\n+  atomic_flag_clear(atomic_flag* __a)\n+  { atomic_flag_clear_explicit(__a, memory_order_seq_cst); }\n+\n+  inline void\n+  atomic_flag_clear(volatile atomic_flag* __a)\n+  { atomic_flag_clear_explicit(__a, memory_order_seq_cst); }\n+ \n+\n+  // Function definitions, atomic_address operations.\n   inline bool\n   atomic_is_lock_free(const atomic_address* __a)\n   { return __a->is_lock_free(); }\n \n+  inline bool\n+  atomic_is_lock_free(const volatile atomic_address* __a)\n+  { return __a->is_lock_free(); }\n+\n+  inline void \n+  atomic_init(atomic_address* __a, void* __v);\n+\n+  inline void \n+  atomic_init(volatile atomic_address* __a, void* __v);\n+\n+  inline void\n+  atomic_store_explicit(atomic_address* __a, void* __v, memory_order __m)\n+  { __a->store(__v, __m); }\n+\n+  inline void\n+  atomic_store_explicit(volatile atomic_address* __a, void* __v, \n+\t\t\tmemory_order __m)\n+  { __a->store(__v, __m); }\n+\n   inline void\n   atomic_store(atomic_address* __a, void* __v)\n   { __a->store(__v); }\n \n   inline void\n-  atomic_store_explicit(atomic_address* __a, void* __v, memory_order __m)\n-  { __a->store(__v, __m); }\n+  atomic_store(volatile atomic_address* __a, void* __v)\n+  { __a->store(__v); }\n+\n+  inline void*\n+  atomic_load_explicit(const atomic_address* __a, memory_order __m)\n+  { return __a->load(__m); }\n+\n+  inline void*\n+  atomic_load_explicit(const volatile atomic_address* __a, memory_order __m)\n+  { return __a->load(__m); }\n \n   inline void*\n   atomic_load(const atomic_address* __a)\n   { return __a->load(); }\n \n   inline void*\n-  atomic_load_explicit(const atomic_address* __a, memory_order __m)\n-  { return __a->load(__m); }\n+  atomic_load(const volatile atomic_address* __a)\n+  { return __a->load(); }\n+\n+  inline void*\n+  atomic_exchange_explicit(atomic_address* __a, void* __v, memory_order __m)\n+  { return __a->exchange(__v, __m); }\n+\n+  inline void*\n+  atomic_exchange_explicit(volatile atomic_address* __a, void* __v, \n+\t\t\t   memory_order __m)\n+  { return __a->exchange(__v, __m); }\n \n   inline void*\n   atomic_exchange(atomic_address* __a, void* __v)\n   { return __a->exchange(__v); }\n \n   inline void*\n-  atomic_exchange_explicit(atomic_address* __a, void* __v, memory_order __m)\n-  { return __a->exchange(__v, __m); }\n+  atomic_exchange(volatile atomic_address* __a, void* __v)\n+  { return __a->exchange(__v); }\n+\n+\n+  inline bool\n+  atomic_compare_exchange_weak_explicit(atomic_address* __a,\n+\t\t\t\t\tvoid** __v1, void* __v2,\n+\t\t\t\t\tmemory_order __m1, memory_order __m2)\n+  { return __a->compare_exchange_weak(*__v1, __v2, __m1, __m2); }\n+\n+  inline bool\n+  atomic_compare_exchange_weak_explicit(volatile atomic_address* __a,\n+\t\t\t\t\tvoid** __v1, void* __v2,\n+\t\t\t\t\tmemory_order __m1, memory_order __m2)\n+  { return __a->compare_exchange_weak(*__v1, __v2, __m1, __m2); }\n \n   inline bool\n   atomic_compare_exchange_weak(atomic_address* __a, void** __v1, void* __v2)\n@@ -592,72 +891,152 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n   }\n \n   inline bool\n-  atomic_compare_exchange_strong(atomic_address* __a,\n-\t\t\t       void** __v1, void* __v2)\n+  atomic_compare_exchange_weak(volatile atomic_address* __a, void** __v1, \n+\t\t\t       void* __v2)\n   {\n-    return __a->compare_exchange_strong(*__v1, __v2, memory_order_seq_cst,\n+    return __a->compare_exchange_weak(*__v1, __v2, memory_order_seq_cst,\n \t\t\t\t      memory_order_seq_cst);\n   }\n \n   inline bool\n-  atomic_compare_exchange_weak_explicit(atomic_address* __a,\n-\t\t\t\t\tvoid** __v1, void* __v2,\n-\t\t\t\t\tmemory_order __m1, memory_order __m2)\n-  { return __a->compare_exchange_weak(*__v1, __v2, __m1, __m2); }\n+  atomic_compare_exchange_strong_explicit(atomic_address* __a,\n+\t\t\t\t\t  void** __v1, void* __v2,\n+\t\t\t\t\t  memory_order __m1, memory_order __m2)\n+  { return __a->compare_exchange_strong(*__v1, __v2, __m1, __m2); }\n \n   inline bool\n-  atomic_compare_exchange_strong_explicit(atomic_address* __a,\n+  atomic_compare_exchange_strong_explicit(volatile atomic_address* __a,\n \t\t\t\t\t  void** __v1, void* __v2,\n \t\t\t\t\t  memory_order __m1, memory_order __m2)\n   { return __a->compare_exchange_strong(*__v1, __v2, __m1, __m2); }\n \n+  inline bool\n+  atomic_compare_exchange_strong(atomic_address* __a, void** __v1, void* __v2)\n+  {\n+    return __a->compare_exchange_strong(*__v1, __v2, memory_order_seq_cst,\n+\t\t\t\t\tmemory_order_seq_cst);\n+  }\n+\n+  inline bool\n+  atomic_compare_exchange_strong(volatile atomic_address* __a,\n+\t\t\t\t void** __v1, void* __v2)\n+  {\n+    return __a->compare_exchange_strong(*__v1, __v2, memory_order_seq_cst,\n+\t\t\t\t\tmemory_order_seq_cst);\n+  }\n+\n   inline void*\n   atomic_fetch_add_explicit(atomic_address* __a, ptrdiff_t __d,\n \t\t\t    memory_order __m)\n   { return __a->fetch_add(__d, __m); }\n \n+  inline void*\n+  atomic_fetch_add_explicit(volatile atomic_address* __a, ptrdiff_t __d,\n+\t\t\t    memory_order __m)\n+  { return __a->fetch_add(__d, __m); }\n+\n   inline void*\n   atomic_fetch_add(atomic_address* __a, ptrdiff_t __d)\n   { return __a->fetch_add(__d); }\n \n+  inline void*\n+  atomic_fetch_add(volatile atomic_address* __a, ptrdiff_t __d)\n+  { return __a->fetch_add(__d); }\n+\n   inline void*\n   atomic_fetch_sub_explicit(atomic_address* __a, ptrdiff_t __d,\n \t\t\t    memory_order __m)\n   { return __a->fetch_sub(__d, __m); }\n \n+  inline void*\n+  atomic_fetch_sub_explicit(volatile atomic_address* __a, ptrdiff_t __d,\n+\t\t\t    memory_order __m)\n+  { return __a->fetch_sub(__d, __m); }\n+\n   inline void*\n   atomic_fetch_sub(atomic_address* __a, ptrdiff_t __d)\n   { return __a->fetch_sub(__d); }\n \n+  inline void*\n+  atomic_fetch_sub(volatile atomic_address* __a, ptrdiff_t __d)\n+  { return __a->fetch_sub(__d); }\n+\n \n-  // Convenience function definitions, atomic_bool.\n+  // Function definitions, atomic_bool operations.\n   inline bool\n   atomic_is_lock_free(const atomic_bool* __a)\n   { return __a->is_lock_free(); }\n \n+  inline bool\n+  atomic_is_lock_free(const volatile atomic_bool* __a)\n+  { return __a->is_lock_free(); }\n+\n+  inline void \n+  atomic_init(atomic_bool* __a, bool __b);\n+\n+  inline void \n+  atomic_init(volatile atomic_bool* __a, bool __b);\n+\n+  inline void\n+  atomic_store_explicit(atomic_bool* __a, bool __i, memory_order __m)\n+  { __a->store(__i, __m); }\n+\n+  inline void\n+  atomic_store_explicit(volatile atomic_bool* __a, bool __i, memory_order __m)\n+  { __a->store(__i, __m); }\n+\n   inline void\n   atomic_store(atomic_bool* __a, bool __i)\n   { __a->store(__i); }\n \n   inline void\n-  atomic_store_explicit(atomic_bool* __a, bool __i, memory_order __m)\n-  { __a->store(__i, __m); }\n+  atomic_store(volatile atomic_bool* __a, bool __i)\n+  { __a->store(__i); }\n+\n+  inline bool\n+  atomic_load_explicit(const atomic_bool* __a, memory_order __m)\n+  { return __a->load(__m); }\n+\n+  inline bool\n+  atomic_load_explicit(const volatile atomic_bool* __a, memory_order __m)\n+  { return __a->load(__m); }\n \n   inline bool\n   atomic_load(const atomic_bool* __a)\n   { return __a->load(); }\n \n   inline bool\n-  atomic_load_explicit(const atomic_bool* __a, memory_order __m)\n-  { return __a->load(__m); }\n+  atomic_load(const volatile atomic_bool* __a)\n+  { return __a->load(); }\n+\n+  inline bool\n+  atomic_exchange_explicit(atomic_bool* __a, bool __i, memory_order __m)\n+  { return __a->exchange(__i, __m); }\n+\n+  inline bool\n+  atomic_exchange_explicit(volatile atomic_bool* __a, bool __i, \n+\t\t\t   memory_order __m)\n+  { return __a->exchange(__i, __m); }\n \n   inline bool\n   atomic_exchange(atomic_bool* __a, bool __i)\n   { return __a->exchange(__i); }\n \n   inline bool\n-  atomic_exchange_explicit(atomic_bool* __a, bool __i, memory_order __m)\n-  { return __a->exchange(__i, __m); }\n+  atomic_exchange(volatile atomic_bool* __a, bool __i)\n+  { return __a->exchange(__i); }\n+\n+  inline bool\n+  atomic_compare_exchange_weak_explicit(atomic_bool* __a, bool* __i1,\n+\t\t\t\t\tbool __i2, memory_order __m1,\n+\t\t\t\t\tmemory_order __m2)\n+  { return __a->compare_exchange_weak(*__i1, __i2, __m1, __m2); }\n+\n+  inline bool\n+  atomic_compare_exchange_weak_explicit(volatile atomic_bool* __a, bool* __i1,\n+\t\t\t\t\tbool __i2, memory_order __m1,\n+\t\t\t\t\tmemory_order __m2)\n+  { return __a->compare_exchange_weak(*__i1, __i2, __m1, __m2); }\n \n   inline bool\n   atomic_compare_exchange_weak(atomic_bool* __a, bool* __i1, bool __i2)\n@@ -667,51 +1046,109 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n   }\n \n   inline bool\n-  atomic_compare_exchange_strong(atomic_bool* __a, bool* __i1, bool __i2)\n+  atomic_compare_exchange_weak(volatile atomic_bool* __a, bool* __i1, bool __i2)\n   {\n-    return __a->compare_exchange_strong(*__i1, __i2, memory_order_seq_cst,\n-\t\t\t\t\tmemory_order_seq_cst);\n+    return __a->compare_exchange_weak(*__i1, __i2, memory_order_seq_cst,\n+\t\t\t\t      memory_order_seq_cst);\n   }\n \n   inline bool\n-  atomic_compare_exchange_weak_explicit(atomic_bool* __a, bool* __i1,\n-\t\t\t\t\tbool __i2, memory_order __m1,\n-\t\t\t\t\tmemory_order __m2)\n-  { return __a->compare_exchange_weak(*__i1, __i2, __m1, __m2); }\n+  atomic_compare_exchange_strong_explicit(atomic_bool* __a,\n+\t\t\t\t\t  bool* __i1, bool __i2,\n+\t\t\t\t\t  memory_order __m1, memory_order __m2)\n+  { return __a->compare_exchange_strong(*__i1, __i2, __m1, __m2); }\n \n   inline bool\n-  atomic_compare_exchange_strong_explicit(atomic_bool* __a,\n+  atomic_compare_exchange_strong_explicit(volatile atomic_bool* __a,\n \t\t\t\t\t  bool* __i1, bool __i2,\n \t\t\t\t\t  memory_order __m1, memory_order __m2)\n   { return __a->compare_exchange_strong(*__i1, __i2, __m1, __m2); }\n \n+  inline bool\n+  atomic_compare_exchange_strong(atomic_bool* __a, bool* __i1, bool __i2)\n+  {\n+    return __a->compare_exchange_strong(*__i1, __i2, memory_order_seq_cst,\n+\t\t\t\t\tmemory_order_seq_cst);\n+  }\n \n+  inline bool\n+  atomic_compare_exchange_strong(volatile atomic_bool* __a, \n+\t\t\t\t bool* __i1, bool __i2)\n+  {\n+    return __a->compare_exchange_strong(*__i1, __i2, memory_order_seq_cst,\n+\t\t\t\t\tmemory_order_seq_cst);\n+  }\n+\n+\n+  // Function templates for atomic_integral operations, using\n+  // __atomic_base . Template argument should be constricted to\n+  // intergral types as specified in the standard.\n+  template<typename _ITp>\n+    inline bool\n+    atomic_is_lock_free(const __atomic_base<_ITp>* __a)\n+    { return __a->is_lock_free(); }\n+\n+  template<typename _ITp>\n+    inline bool\n+    atomic_is_lock_free(const volatile __atomic_base<_ITp>* __a)\n+    { return __a->is_lock_free(); }\n+\n+  template<typename _ITp>\n+    inline void \n+    atomic_init(__atomic_base<_ITp>* __a, _ITp __i);\n+\n+  template<typename _ITp>\n+    inline void \n+    atomic_init(volatile __atomic_base<_ITp>* __a, _ITp __i);\n \n-  // Free standing functions. Template argument should be constricted\n-  // to intergral types as specified in the standard.\n   template<typename _ITp>\n     inline void\n     atomic_store_explicit(__atomic_base<_ITp>* __a, _ITp __i, memory_order __m)\n     { __a->store(__i, __m); }\n \n+  template<typename _ITp>\n+    inline void\n+    atomic_store_explicit(volatile __atomic_base<_ITp>* __a, _ITp __i, \n+\t\t\t  memory_order __m)\n+    { __a->store(__i, __m); }\n+\n   template<typename _ITp>\n     inline _ITp\n     atomic_load_explicit(const __atomic_base<_ITp>* __a, memory_order __m)\n     { return __a->load(__m); }\n \n+  template<typename _ITp>\n+    inline _ITp\n+    atomic_load_explicit(const volatile __atomic_base<_ITp>* __a, \n+\t\t\t memory_order __m)\n+    { return __a->load(__m); }\n+\n   template<typename _ITp>\n     inline _ITp\n     atomic_exchange_explicit(__atomic_base<_ITp>* __a, _ITp __i,\n \t\t\t     memory_order __m)\n     { return __a->exchange(__i, __m); }\n \n+  template<typename _ITp>\n+    inline _ITp\n+    atomic_exchange_explicit(volatile __atomic_base<_ITp>* __a, _ITp __i,\n+\t\t\t     memory_order __m)\n+    { return __a->exchange(__i, __m); }\n+\n   template<typename _ITp>\n     inline bool\n     atomic_compare_exchange_weak_explicit(__atomic_base<_ITp>* __a,\n \t\t\t\t\t  _ITp* __i1, _ITp __i2,\n \t\t\t\t\t  memory_order __m1, memory_order __m2)\n     { return __a->compare_exchange_weak(*__i1, __i2, __m1, __m2); }\n \n+  template<typename _ITp>\n+    inline bool\n+    atomic_compare_exchange_weak_explicit(volatile __atomic_base<_ITp>* __a,\n+\t\t\t\t\t  _ITp* __i1, _ITp __i2,\n+\t\t\t\t\t  memory_order __m1, memory_order __m2)\n+    { return __a->compare_exchange_weak(*__i1, __i2, __m1, __m2); }\n+\n   template<typename _ITp>\n     inline bool\n     atomic_compare_exchange_strong_explicit(__atomic_base<_ITp>* __a,\n@@ -720,56 +1157,104 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t\t\t\t\t    memory_order __m2)\n     { return __a->compare_exchange_strong(*__i1, __i2, __m1, __m2); }\n \n+  template<typename _ITp>\n+    inline bool\n+    atomic_compare_exchange_strong_explicit(volatile __atomic_base<_ITp>* __a,\n+\t\t\t\t\t    _ITp* __i1, _ITp __i2,\n+\t\t\t\t\t    memory_order __m1,\n+\t\t\t\t\t    memory_order __m2)\n+    { return __a->compare_exchange_strong(*__i1, __i2, __m1, __m2); }\n+\n   template<typename _ITp>\n     inline _ITp\n     atomic_fetch_add_explicit(__atomic_base<_ITp>* __a, _ITp __i,\n \t\t\t      memory_order __m)\n     { return __a->fetch_add(__i, __m); }\n \n+  template<typename _ITp>\n+    inline _ITp\n+    atomic_fetch_add_explicit(volatile __atomic_base<_ITp>* __a, _ITp __i,\n+\t\t\t      memory_order __m)\n+    { return __a->fetch_add(__i, __m); }\n+\n   template<typename _ITp>\n     inline _ITp\n     atomic_fetch_sub_explicit(__atomic_base<_ITp>* __a, _ITp __i,\n \t\t\t      memory_order __m)\n     { return __a->fetch_sub(__i, __m); }\n \n+  template<typename _ITp>\n+    inline _ITp\n+    atomic_fetch_sub_explicit(volatile __atomic_base<_ITp>* __a, _ITp __i,\n+\t\t\t      memory_order __m)\n+    { return __a->fetch_sub(__i, __m); }\n+\n   template<typename _ITp>\n     inline _ITp\n     atomic_fetch_and_explicit(__atomic_base<_ITp>* __a, _ITp __i,\n \t\t\t      memory_order __m)\n     { return __a->fetch_and(__i, __m); }\n \n+  template<typename _ITp>\n+    inline _ITp\n+    atomic_fetch_and_explicit(volatile __atomic_base<_ITp>* __a, _ITp __i,\n+\t\t\t      memory_order __m)\n+    { return __a->fetch_and(__i, __m); }\n+\n   template<typename _ITp>\n     inline _ITp\n     atomic_fetch_or_explicit(__atomic_base<_ITp>* __a, _ITp __i,\n \t\t\t     memory_order __m)\n     { return __a->fetch_or(__i, __m); }\n \n+  template<typename _ITp>\n+    inline _ITp\n+    atomic_fetch_or_explicit(volatile __atomic_base<_ITp>* __a, _ITp __i,\n+\t\t\t     memory_order __m)\n+    { return __a->fetch_or(__i, __m); }\n+\n   template<typename _ITp>\n     inline _ITp\n     atomic_fetch_xor_explicit(__atomic_base<_ITp>* __a, _ITp __i,\n \t\t\t      memory_order __m)\n     { return __a->fetch_xor(__i, __m); }\n \n   template<typename _ITp>\n-    inline bool\n-    atomic_is_lock_free(const __atomic_base<_ITp>* __a)\n-    { return __a->is_lock_free(); }\n+    inline _ITp\n+    atomic_fetch_xor_explicit(volatile __atomic_base<_ITp>* __a, _ITp __i,\n+\t\t\t      memory_order __m)\n+    { return __a->fetch_xor(__i, __m); }\n \n   template<typename _ITp>\n     inline void\n     atomic_store(__atomic_base<_ITp>* __a, _ITp __i)\n     { atomic_store_explicit(__a, __i, memory_order_seq_cst); }\n \n+  template<typename _ITp>\n+    inline void\n+    atomic_store(volatile __atomic_base<_ITp>* __a, _ITp __i)\n+    { atomic_store_explicit(__a, __i, memory_order_seq_cst); }\n+\n   template<typename _ITp>\n     inline _ITp\n     atomic_load(const __atomic_base<_ITp>* __a)\n     { return atomic_load_explicit(__a, memory_order_seq_cst); }\n \n+  template<typename _ITp>\n+    inline _ITp\n+    atomic_load(const volatile __atomic_base<_ITp>* __a)\n+    { return atomic_load_explicit(__a, memory_order_seq_cst); }\n+\n   template<typename _ITp>\n     inline _ITp\n     atomic_exchange(__atomic_base<_ITp>* __a, _ITp __i)\n     { return atomic_exchange_explicit(__a, __i, memory_order_seq_cst); }\n \n+  template<typename _ITp>\n+    inline _ITp\n+    atomic_exchange(volatile __atomic_base<_ITp>* __a, _ITp __i)\n+    { return atomic_exchange_explicit(__a, __i, memory_order_seq_cst); }\n+\n   template<typename _ITp>\n     inline bool\n     atomic_compare_exchange_weak(__atomic_base<_ITp>* __a,\n@@ -780,6 +1265,16 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t\t\t\t\t\t   memory_order_seq_cst);\n     }\n \n+  template<typename _ITp>\n+    inline bool\n+    atomic_compare_exchange_weak(volatile __atomic_base<_ITp>* __a,\n+\t\t\t\t _ITp* __i1, _ITp __i2)\n+    {\n+      return atomic_compare_exchange_weak_explicit(__a, __i1, __i2,\n+\t\t\t\t\t\t   memory_order_seq_cst,\n+\t\t\t\t\t\t   memory_order_seq_cst);\n+    }\n+\n   template<typename _ITp>\n     inline bool\n     atomic_compare_exchange_strong(__atomic_base<_ITp>* __a,\n@@ -790,31 +1285,66 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t\t\t\t\t\t     memory_order_seq_cst);\n     }\n \n+  template<typename _ITp>\n+    inline bool\n+    atomic_compare_exchange_strong(volatile __atomic_base<_ITp>* __a,\n+\t\t\t\t   _ITp* __i1, _ITp __i2)\n+    {\n+      return atomic_compare_exchange_strong_explicit(__a, __i1, __i2,\n+\t\t\t\t\t\t     memory_order_seq_cst,\n+\t\t\t\t\t\t     memory_order_seq_cst);\n+    }\n+\n   template<typename _ITp>\n     inline _ITp\n     atomic_fetch_add(__atomic_base<_ITp>* __a, _ITp __i)\n     { return atomic_fetch_add_explicit(__a, __i, memory_order_seq_cst); }\n \n+  template<typename _ITp>\n+    inline _ITp\n+    atomic_fetch_add(volatile __atomic_base<_ITp>* __a, _ITp __i)\n+    { return atomic_fetch_add_explicit(__a, __i, memory_order_seq_cst); }\n+\n   template<typename _ITp>\n     inline _ITp\n     atomic_fetch_sub(__atomic_base<_ITp>* __a, _ITp __i)\n     { return atomic_fetch_sub_explicit(__a, __i, memory_order_seq_cst); }\n \n+  template<typename _ITp>\n+    inline _ITp\n+    atomic_fetch_sub(volatile __atomic_base<_ITp>* __a, _ITp __i)\n+    { return atomic_fetch_sub_explicit(__a, __i, memory_order_seq_cst); }\n+\n   template<typename _ITp>\n     inline _ITp\n     atomic_fetch_and(__atomic_base<_ITp>* __a, _ITp __i)\n     { return atomic_fetch_and_explicit(__a, __i, memory_order_seq_cst); }\n \n+  template<typename _ITp>\n+    inline _ITp\n+    atomic_fetch_and(volatile __atomic_base<_ITp>* __a, _ITp __i)\n+    { return atomic_fetch_and_explicit(__a, __i, memory_order_seq_cst); }\n+\n   template<typename _ITp>\n     inline _ITp\n     atomic_fetch_or(__atomic_base<_ITp>* __a, _ITp __i)\n     { return atomic_fetch_or_explicit(__a, __i, memory_order_seq_cst); }\n \n+  template<typename _ITp>\n+    inline _ITp\n+    atomic_fetch_or(volatile __atomic_base<_ITp>* __a, _ITp __i)\n+    { return atomic_fetch_or_explicit(__a, __i, memory_order_seq_cst); }\n+\n   template<typename _ITp>\n     inline _ITp\n     atomic_fetch_xor(__atomic_base<_ITp>* __a, _ITp __i)\n     { return atomic_fetch_xor_explicit(__a, __i, memory_order_seq_cst); }\n \n+  template<typename _ITp>\n+    inline _ITp\n+    atomic_fetch_xor(volatile __atomic_base<_ITp>* __a, _ITp __i)\n+    { return atomic_fetch_xor_explicit(__a, __i, memory_order_seq_cst); }\n+\n   // @} group atomics\n \n _GLIBCXX_END_NAMESPACE"}, {"sha": "fafbb32dd0c32601e51f55cd91294fdeb2419c1c", "filename": "libstdc++-v3/include/std/bitset", "status": "modified", "additions": 60, "deletions": 44, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fbitset", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fbitset", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fbitset?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -72,36 +72,39 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       /// 0 is the least significant word.\n       _WordT \t\t_M_w[_Nw];\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      constexpr _Base_bitset() : _M_w({ }) { }\n+\n+      constexpr _Base_bitset(unsigned long long __val)\n+      : _M_w({ __val\n+#if __SIZEOF_LONG_LONG__ > __SIZEOF_LONG__\n+\t       , __val >> _GLIBCXX_BITSET_BITS_PER_WORD\n+#endif\n+       }) { }\n+#else\n       _Base_bitset()\n       { _M_do_reset(); }\n \n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      _Base_bitset(unsigned long long __val)\n-#else\n       _Base_bitset(unsigned long __val)\n-#endif\n       {\n \t_M_do_reset();\n \t_M_w[0] = __val;\n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n-\tif (sizeof(unsigned long long) > sizeof(unsigned long))\n-\t  _M_w[1] = __val >> _GLIBCXX_BITSET_BITS_PER_WORD;\n-#endif\n       }\n+#endif\n \n-      static size_t\n+      static _GLIBCXX_CONSTEXPR size_t\n       _S_whichword(size_t __pos )\n       { return __pos / _GLIBCXX_BITSET_BITS_PER_WORD; }\n \n-      static size_t\n+      static _GLIBCXX_CONSTEXPR size_t\n       _S_whichbyte(size_t __pos )\n       { return (__pos % _GLIBCXX_BITSET_BITS_PER_WORD) / __CHAR_BIT__; }\n \n-      static size_t\n+      static _GLIBCXX_CONSTEXPR size_t\n       _S_whichbit(size_t __pos )\n       { return __pos % _GLIBCXX_BITSET_BITS_PER_WORD; }\n \n-      static _WordT\n+      static _GLIBCXX_CONSTEXPR _WordT\n       _S_maskbit(size_t __pos )\n       { return (static_cast<_WordT>(1)) << _S_whichbit(__pos); }\n \n@@ -123,7 +126,7 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       _M_hiword()\n       { return _M_w[_Nw - 1]; }\n \n-      _WordT\n+      _GLIBCXX_CONSTEXPR _WordT\n       _M_hiword() const\n       { return _M_w[_Nw - 1]; }\n \n@@ -368,31 +371,31 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       typedef unsigned long _WordT;\n       _WordT _M_w;\n \n-      _Base_bitset(void)\n+      _GLIBCXX_CONSTEXPR _Base_bitset()\n       : _M_w(0)\n       { }\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      _Base_bitset(unsigned long long __val)\n+      constexpr _Base_bitset(unsigned long long __val)\n #else\n       _Base_bitset(unsigned long __val)\n #endif\n       : _M_w(__val)\n       { }\n \n-      static size_t\n+      static _GLIBCXX_CONSTEXPR size_t\n       _S_whichword(size_t __pos )\n       { return __pos / _GLIBCXX_BITSET_BITS_PER_WORD; }\n \n-      static size_t\n+      static _GLIBCXX_CONSTEXPR size_t\n       _S_whichbyte(size_t __pos )\n       { return (__pos % _GLIBCXX_BITSET_BITS_PER_WORD) / __CHAR_BIT__; }\n \n-      static size_t\n+      static _GLIBCXX_CONSTEXPR size_t\n       _S_whichbit(size_t __pos )\n       {  return __pos % _GLIBCXX_BITSET_BITS_PER_WORD; }\n \n-      static _WordT\n+      static _GLIBCXX_CONSTEXPR _WordT\n       _S_maskbit(size_t __pos )\n       { return (static_cast<_WordT>(1)) << _S_whichbit(__pos); }\n \n@@ -414,7 +417,7 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       _M_hiword()\n       { return _M_w; }\n \n-      _WordT\n+      _GLIBCXX_CONSTEXPR _WordT\n       _M_hiword() const\n       { return _M_w; }\n \n@@ -511,29 +514,29 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n     {\n       typedef unsigned long _WordT;\n \n-      _Base_bitset()\n+      _GLIBCXX_CONSTEXPR _Base_bitset()\n       { }\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      _Base_bitset(unsigned long long)\n+      constexpr _Base_bitset(unsigned long long)\n #else\n       _Base_bitset(unsigned long)\n #endif\n       { }\n \n-      static size_t\n+      static _GLIBCXX_CONSTEXPR size_t\n       _S_whichword(size_t __pos )\n       { return __pos / _GLIBCXX_BITSET_BITS_PER_WORD; }\n \n-      static size_t\n+      static _GLIBCXX_CONSTEXPR size_t\n       _S_whichbyte(size_t __pos )\n       { return (__pos % _GLIBCXX_BITSET_BITS_PER_WORD) / __CHAR_BIT__; }\n \n-      static size_t\n+      static _GLIBCXX_CONSTEXPR size_t\n       _S_whichbit(size_t __pos )\n       {  return __pos % _GLIBCXX_BITSET_BITS_PER_WORD; }\n \n-      static _WordT\n+      static _GLIBCXX_CONSTEXPR _WordT\n       _S_maskbit(size_t __pos )\n       { return (static_cast<_WordT>(1)) << _S_whichbit(__pos); }\n \n@@ -545,13 +548,17 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       // make an unchecked call; all the memory ugliness is therefore\n       // localized to this single should-never-get-this-far function.\n       _WordT&\n-      _M_getword(size_t) const\n+      _M_getword(size_t)\n       { \n \t__throw_out_of_range(__N(\"_Base_bitset::_M_getword\")); \n \treturn *new _WordT; \n       }\n \n       _WordT\n+      _M_getword(size_t __pos) const\n+      { return 0; }\n+\n+      _GLIBCXX_CONSTEXPR _WordT\n       _M_hiword() const\n       { return 0; }\n \n@@ -632,13 +639,21 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n   template<size_t _Extrabits>\n     struct _Sanitize\n     {\n-      static void _S_do_sanitize(unsigned long& __val)\n-      { __val &= ~((~static_cast<unsigned long>(0)) << _Extrabits); }\n+      typedef unsigned long _WordT;\n+\n+      static void \n+      _S_do_sanitize(_WordT& __val)\n+      { __val &= ~((~static_cast<_WordT>(0)) << _Extrabits); }\n     };\n \n   template<>\n     struct _Sanitize<0>\n-    { static void _S_do_sanitize(unsigned long) {} };\n+    { \n+      typedef unsigned long _WordT;\n+\n+      static void \n+      _S_do_sanitize(_WordT) { } \n+    };\n \n   /**\n    *  @brief  The %bitset class represents a @e fixed-size sequence of bits.\n@@ -713,11 +728,11 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       typedef unsigned long _WordT;\n \n       void\n-\t_M_do_sanitize()\n-\t{\n-\t  _Sanitize<_Nb % _GLIBCXX_BITSET_BITS_PER_WORD>::\n-\t    _S_do_sanitize(this->_M_hiword());\n-\t}\n+      _M_do_sanitize()\n+      { \n+\ttypedef _Sanitize<_Nb % _GLIBCXX_BITSET_BITS_PER_WORD> __sanitize_type;\n+\t__sanitize_type::_S_do_sanitize(this->_M_hiword());\n+      }\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n       template<typename> friend class hash;\n@@ -740,8 +755,8 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       {\n \tfriend class bitset;\n \n-\t_WordT *_M_wp;\n-\tsize_t _M_bpos;\n+\t_WordT*\t_M_wp;\n+\tsize_t \t_M_bpos;\n \t\n \t// left undefined\n \treference();\n@@ -799,17 +814,18 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n \n       // 23.3.5.1 constructors:\n       /// All bits set to zero.\n-      bitset()\n+      _GLIBCXX_CONSTEXPR bitset()\n       { }\n \n       /// Initial bits bitwise-copied from a single word (others set to zero).\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      bitset(unsigned long long __val)\n+      constexpr bitset(unsigned long long __val)\n+      : _Base(__val) { }\n #else\n       bitset(unsigned long __val)\n-#endif\n       : _Base(__val)\n       { _M_do_sanitize(); }\n+#endif\n \n       /**\n        *  @brief  Use a subset of a string.\n@@ -1088,8 +1104,8 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       /**\n        *  @brief  Array-indexing support.\n        *  @param  position  Index into the %bitset.\n-       *  @return  A bool for a <em>const %bitset</em>.  For non-const bitsets, an\n-       *           instance of the reference proxy class.\n+       *  @return A bool for a <em>const %bitset</em>.  For non-const\n+       *           bitsets, an instance of the reference proxy class.\n        *  @note  These operators do no range checking and throw no exceptions,\n        *         as required by DR 11 to the standard.\n        *\n@@ -1101,7 +1117,7 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n        */\n       reference\n       operator[](size_t __position)\n-      { return reference(*this,__position); }\n+      { return reference(*this, __position); }\n \n       bool\n       operator[](size_t __position) const\n@@ -1236,7 +1252,7 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       { return this->_M_do_count(); }\n \n       /// Returns the total number of bits.\n-      size_t\n+      _GLIBCXX_CONSTEXPR size_t\n       size() const\n       { return _Nb; }\n "}, {"sha": "1d9552a99149fe689c4e4bb3bbb31effe8d96ad9", "filename": "libstdc++-v3/include/std/chrono", "status": "modified", "additions": 287, "deletions": 289, "changes": 576, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fchrono", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fchrono", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fchrono?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -46,7 +46,7 @@\n \n #ifdef _GLIBCXX_USE_C99_STDINT_TR1\n \n-namespace std \n+namespace std\n {\n   /**\n    * @defgroup chrono Time\n@@ -71,71 +71,75 @@ namespace std\n   // 20.8.2.3 specialization of common_type (for duration)\n   template<typename _Rep1, typename _Period1, typename _Rep2, typename _Period2>\n     struct common_type<chrono::duration<_Rep1, _Period1>,\n-                       chrono::duration<_Rep2, _Period2>>\n+\t\t       chrono::duration<_Rep2, _Period2>>\n     {\n       typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,\n-        ratio<__static_gcd<_Period1::num, _Period2::num>::value,\n-        (_Period1::den / __static_gcd<_Period1::den, _Period2::den>::value)\n-        * _Period2::den>> type;\n+\tratio<__static_gcd<_Period1::num, _Period2::num>::value,\n+\t(_Period1::den / __static_gcd<_Period1::den, _Period2::den>::value)\n+\t* _Period2::den>> type;\n     };\n-  \n+\n   // 20.8.2.3 specialization of common_type (for time_point)\n   template<typename _Clock, typename _Duration1, typename _Duration2>\n     struct common_type<chrono::time_point<_Clock, _Duration1>,\n-                       chrono::time_point<_Clock, _Duration2>>\n+\t\t       chrono::time_point<_Clock, _Duration2>>\n     {\n-      typedef chrono::time_point<_Clock, \n-        typename common_type<_Duration1, _Duration2>::type> type;\n+      typedef chrono::time_point<_Clock,\n+\ttypename common_type<_Duration1, _Duration2>::type> type;\n     };\n \n-  namespace chrono \n+  namespace chrono\n   {\n     // Primary template for duration_cast impl.\n     template<typename _ToDuration, typename _CF, typename _CR,\n-             bool _NumIsOne = false, bool _DenIsOne = false>\n+\t     bool _NumIsOne = false, bool _DenIsOne = false>\n       struct __duration_cast_impl\n       {\n-        template<typename _Rep, typename _Period>\n-          static _ToDuration __cast(const duration<_Rep, _Period>& __d)\n-          {\n-            return _ToDuration(static_cast<\n-              typename _ToDuration::rep>(static_cast<_CR>(__d.count())\n-              * static_cast<_CR>(_CF::num)\n-              / static_cast<_CR>(_CF::den)));\n-          }\n+\ttemplate<typename _Rep, typename _Period>\n+\t  static constexpr _ToDuration \n+\t  __cast(const duration<_Rep, _Period>& __d)\n+\t  {\n+\t    return _ToDuration(static_cast<\n+\t      typename _ToDuration::rep>(static_cast<_CR>(__d.count())\n+\t      * static_cast<_CR>(_CF::num)\n+\t      / static_cast<_CR>(_CF::den)));\n+\t  }\n       };\n \n     template<typename _ToDuration, typename _CF, typename _CR>\n       struct __duration_cast_impl<_ToDuration, _CF, _CR, true, true>\n       {\n-        template<typename _Rep, typename _Period>\n-          static _ToDuration __cast(const duration<_Rep, _Period>& __d)\n-          {\n-            return _ToDuration(\n-              static_cast<typename _ToDuration::rep>(__d.count()));\n-          }\n+\ttemplate<typename _Rep, typename _Period>\n+\t  static constexpr _ToDuration \n+\t  __cast(const duration<_Rep, _Period>& __d)\n+\t  {\n+\t    return _ToDuration(\n+\t      static_cast<typename _ToDuration::rep>(__d.count()));\n+\t  }\n       };\n \n     template<typename _ToDuration, typename _CF, typename _CR>\n       struct __duration_cast_impl<_ToDuration, _CF, _CR, true, false>\n       {\n-        template<typename _Rep, typename _Period>\n-          static _ToDuration __cast(const duration<_Rep, _Period>& __d)\n-          {\n-            return _ToDuration(static_cast<typename _ToDuration::rep>(\n-              static_cast<_CR>(__d.count()) / static_cast<_CR>(_CF::den))); \n-          }\n+\ttemplate<typename _Rep, typename _Period>\n+\t  static constexpr _ToDuration \n+\t  __cast(const duration<_Rep, _Period>& __d)\n+\t  {\n+\t    return _ToDuration(static_cast<typename _ToDuration::rep>(\n+\t      static_cast<_CR>(__d.count()) / static_cast<_CR>(_CF::den)));\n+\t  }\n       };\n \n     template<typename _ToDuration, typename _CF, typename _CR>\n       struct __duration_cast_impl<_ToDuration, _CF, _CR, false, true>\n       {\n-        template<typename _Rep, typename _Period>\n-          static _ToDuration __cast(const duration<_Rep, _Period>& __d)\n-          {\n-            return _ToDuration(static_cast<typename _ToDuration::rep>(\n-              static_cast<_CR>(__d.count()) * static_cast<_CR>(_CF::num)));\n-          }\n+\ttemplate<typename _Rep, typename _Period>\n+\t  static constexpr _ToDuration \n+\t  __cast(const duration<_Rep, _Period>& __d)\n+\t  {\n+\t    return _ToDuration(static_cast<typename _ToDuration::rep>(\n+\t      static_cast<_CR>(__d.count()) * static_cast<_CR>(_CF::num)));\n+\t  }\n       };\n \n     template<typename _Tp>\n@@ -150,17 +154,17 @@ namespace std\n \n     /// duration_cast\n     template<typename _ToDuration, typename _Rep, typename _Period>\n-      inline typename enable_if<__is_duration<_ToDuration>::value,\n+      inline constexpr typename enable_if<__is_duration<_ToDuration>::value,\n \t\t\t\t_ToDuration>::type\n       duration_cast(const duration<_Rep, _Period>& __d)\n       {\n-        typedef typename\n-          ratio_divide<_Period, typename _ToDuration::period>::type __cf;\n-        typedef typename\n-          common_type<typename _ToDuration::rep, _Rep, intmax_t>::type __cr;\n+\ttypedef typename\n+\t  ratio_divide<_Period, typename _ToDuration::period>::type __cf;\n+\ttypedef typename\n+\t  common_type<typename _ToDuration::rep, _Rep, intmax_t>::type __cr;\n \n-        return __duration_cast_impl<_ToDuration, __cf, __cr,\n-          __cf::num == 1, __cf::den == 1>::__cast(__d);\n+\treturn __duration_cast_impl<_ToDuration, __cf, __cr,\n+\t  __cf::num == 1, __cf::den == 1>::__cast(__d);\n       }\n \n     /// treat_as_floating_point\n@@ -173,17 +177,17 @@ namespace std\n     template<typename _Rep>\n       struct duration_values\n       {\n-        static const _Rep\n-        zero()\n-        { return _Rep(0); }\n-        \n-        static const _Rep\n-        max()\n-        { return numeric_limits<_Rep>::max(); }\n-        \n-        static const _Rep\n-        min()\n-        { return numeric_limits<_Rep>::min(); }\n+\tstatic constexpr _Rep\n+\tzero()\n+\t{ return _Rep(0); }\n+\n+\tstatic constexpr _Rep\n+\tmax()\n+\t{ return numeric_limits<_Rep>::max(); }\n+\n+\tstatic constexpr _Rep\n+\tmin()\n+\t{ return numeric_limits<_Rep>::min(); }\n       };\n \n     template<typename T>\n@@ -200,98 +204,98 @@ namespace std\n     template<typename _Rep, typename _Period>\n       struct duration\n       {\n+\ttypedef _Rep    rep;\n+\ttypedef _Period period;\n+\n \tstatic_assert(!__is_duration<_Rep>::value, \"rep cannot be a duration\");\n-\tstatic_assert(__is_ratio<_Period>::value, \n+\tstatic_assert(__is_ratio<_Period>::value,\n \t\t      \"period must be a specialization of ratio\");\n-        static_assert(_Period::num > 0, \"period must be positive\");\n-        \n-        typedef _Rep    rep;\n-        typedef _Period period;\n-        \n-        // 20.8.3.1 construction / copy / destroy\n-\tduration() = default;\n-\n-        template<typename _Rep2, typename = typename\n+\tstatic_assert(_Period::num > 0, \"period must be positive\");\n+\n+\t// 20.8.3.1 construction / copy / destroy\n+\tconstexpr duration() : __r() { }\n+\n+\ttemplate<typename _Rep2, typename = typename\n \t       enable_if<is_convertible<_Rep2, rep>::value\n \t\t\t && (treat_as_floating_point<rep>::value\n \t\t\t     || !treat_as_floating_point<_Rep2>::value)>::type>\n-          explicit duration(const _Rep2& __rep)\n-          : __r(static_cast<rep>(__rep)) { }\n+\t  constexpr explicit duration(const _Rep2& __rep)\n+\t    : __r(static_cast<rep>(__rep)) { }\n \n-        template<typename _Rep2, typename _Period2, typename = typename\n-\t       enable_if<treat_as_floating_point<rep>::value \n+\ttemplate<typename _Rep2, typename _Period2, typename = typename\n+\t       enable_if<treat_as_floating_point<rep>::value\n \t\t\t || (ratio_divide<_Period2, period>::type::den == 1\n \t\t\t     && !treat_as_floating_point<_Rep2>::value)>::type>\n-          duration(const duration<_Rep2, _Period2>& __d)\n-          : __r(duration_cast<duration>(__d).count()) { }\n+\t  constexpr duration(const duration<_Rep2, _Period2>& __d)\n+\t  : __r(duration_cast<duration>(__d).count()) { }\n \n \t~duration() = default;\n \tduration(const duration&) = default;\n \tduration& operator=(const duration&) = default;\n \n-        // 20.8.3.2 observer\n-        rep\n-        count() const\n-        { return __r; }\n-\n-        // 20.8.3.3 arithmetic\n-        duration\n-        operator+() const \n-        { return *this; }\n-\n-        duration\n-        operator-() const\n-        { return duration(-__r); }\n-\n-        duration&\n-        operator++()\n-        {\n-          ++__r;\n-          return *this;\n-        }\n-\n-        duration\n-        operator++(int)\n-        { return duration(__r++); }\n-\n-        duration&\n-        operator--()\n-        {\n-          --__r;\n-          return *this;\n-        }\n-\n-        duration\n-        operator--(int)\n-        { return duration(__r--); }\n-        \n-        duration&\n-        operator+=(const duration& __d)\n-        {\n-          __r += __d.count();\n-          return *this;\n-        }\n-\n-        duration&\n-        operator-=(const duration& __d)\n-        {\n-          __r -= __d.count();\n-          return *this;\n-        }\n-\n-        duration&\n-        operator*=(const rep& __rhs)\n-        {\n-          __r *= __rhs;\n-          return *this;\n-        }\n-\n-        duration&\n-        operator/=(const rep& __rhs)\n-        {\n-          __r /= __rhs;\n-          return *this;\n-        }\n+\t// 20.8.3.2 observer\n+\tconstexpr rep\n+\tcount() const\n+\t{ return __r; }\n+\n+\t// 20.8.3.3 arithmetic\n+\tconstexpr duration\n+\toperator+() const\n+\t{ return *this; }\n+\n+\tconstexpr duration\n+\toperator-() const\n+\t{ return duration(-__r); }\n+\n+\tduration&\n+\toperator++()\n+\t{\n+\t  ++__r;\n+\t  return *this;\n+\t}\n+\n+\tduration\n+\toperator++(int)\n+\t{ return duration(__r++); }\n+\n+\tduration&\n+\toperator--()\n+\t{\n+\t  --__r;\n+\t  return *this;\n+\t}\n+\n+\tduration\n+\toperator--(int)\n+\t{ return duration(__r--); }\n+\n+\tduration&\n+\toperator+=(const duration& __d)\n+\t{\n+\t  __r += __d.count();\n+\t  return *this;\n+\t}\n+\n+\tduration&\n+\toperator-=(const duration& __d)\n+\t{\n+\t  __r -= __d.count();\n+\t  return *this;\n+\t}\n+\n+\tduration&\n+\toperator*=(const rep& __rhs)\n+\t{\n+\t  __r *= __rhs;\n+\t  return *this;\n+\t}\n+\n+\tduration&\n+\toperator/=(const rep& __rhs)\n+\t{\n+\t  __r /= __rhs;\n+\t  return *this;\n+\t}\n \n \t// DR 934.\n \ttemplate<typename _Rep2 = rep>\n@@ -312,46 +316,45 @@ namespace std\n \t    return *this;\n \t  }\n \n-        // 20.8.3.4 special values\n-        // TODO: These should be constexprs.\n-        static const duration\n-        zero()\n-        { return duration(duration_values<rep>::zero()); }\n+\t// 20.8.3.4 special values\n+\tstatic constexpr duration\n+\tzero()\n+\t{ return duration(duration_values<rep>::zero()); }\n+\n+\tstatic constexpr duration\n+\tmin()\n+\t{ return duration(duration_values<rep>::min()); }\n \n-        static const duration\n-        min()\n-        { return duration(duration_values<rep>::min()); }\n-      \n-        static const duration\n-        max()\n-        { return duration(duration_values<rep>::max()); }\n+\tstatic constexpr duration\n+\tmax()\n+\t{ return duration(duration_values<rep>::max()); }\n \n       private:\n-        rep __r;\n+\trep __r;\n       };\n \n     template<typename _Rep1, typename _Period1,\n-             typename _Rep2, typename _Period2>\n-      inline typename common_type<duration<_Rep1, _Period1>, \n-                                  duration<_Rep2, _Period2>>::type\n-      operator+(const duration<_Rep1, _Period1>& __lhs, \n-                const duration<_Rep2, _Period2>& __rhs)\n+\t     typename _Rep2, typename _Period2>\n+      inline typename common_type<duration<_Rep1, _Period1>,\n+\t\t\t\t  duration<_Rep2, _Period2>>::type\n+      operator+(const duration<_Rep1, _Period1>& __lhs,\n+\t\tconst duration<_Rep2, _Period2>& __rhs)\n       {\n-        typedef typename common_type<duration<_Rep1, _Period1>, \n-                                     duration<_Rep2, _Period2>>::type __ct;\n-        return __ct(__lhs) += __rhs;\n+\ttypedef typename common_type<duration<_Rep1, _Period1>,\n+\t\t\t\t     duration<_Rep2, _Period2>>::type __ct;\n+\treturn __ct(__lhs) += __rhs;\n       }\n \n-    template<typename _Rep1, typename _Period1, \n-             typename _Rep2, typename _Period2>\n-      inline typename common_type<duration<_Rep1, _Period1>, \n-                                  duration<_Rep2, _Period2>>::type\n-      operator-(const duration<_Rep1, _Period1>& __lhs, \n-                const duration<_Rep2, _Period2>& __rhs)\n+    template<typename _Rep1, typename _Period1,\n+\t     typename _Rep2, typename _Period2>\n+      inline typename common_type<duration<_Rep1, _Period1>,\n+\t\t\t\t  duration<_Rep2, _Period2>>::type\n+      operator-(const duration<_Rep1, _Period1>& __lhs,\n+\t\tconst duration<_Rep2, _Period2>& __rhs)\n       {\n-        typedef typename common_type<duration<_Rep1, _Period1>,\n-                                     duration<_Rep2, _Period2>>::type __ct;\n-        return __ct(__lhs) -= __rhs;\n+\ttypedef typename common_type<duration<_Rep1, _Period1>,\n+\t\t\t\t     duration<_Rep2, _Period2>>::type __ct;\n+\treturn __ct(__lhs) -= __rhs;\n       }\n \n     template<typename _Rep1, typename _Rep2, bool =\n@@ -361,21 +364,21 @@ namespace std\n \n     template<typename _Rep1, typename _Rep2>\n       struct __common_rep_type<_Rep1, _Rep2, true>\n-      { typedef typename common_type<_Rep1, _Rep2>::type type; };     \n+      { typedef typename common_type<_Rep1, _Rep2>::type type; };\n \n     template<typename _Rep1, typename _Period, typename _Rep2>\n       inline duration<typename __common_rep_type<_Rep1, _Rep2>::type, _Period>\n       operator*(const duration<_Rep1, _Period>& __d, const _Rep2& __s)\n       {\n-        typedef typename common_type<_Rep1, _Rep2>::type __cr;\n-        return duration<__cr, _Period>(__d) *= __s;\n+\ttypedef typename common_type<_Rep1, _Rep2>::type __cr;\n+\treturn duration<__cr, _Period>(__d) *= __s;\n       }\n \n     template<typename _Rep1, typename _Period, typename _Rep2>\n       inline duration<typename __common_rep_type<_Rep2, _Rep1>::type, _Period>\n       operator*(const _Rep1& __s, const duration<_Rep2, _Period>& __d)\n       { return __d * __s; }\n- \n+\n     template<typename _Rep1, typename _Period, typename _Rep2>\n       inline duration<typename __common_rep_type<_Rep1, typename\n \tenable_if<!__is_duration<_Rep2>::value, _Rep2>::type>::type, _Period>\n@@ -388,12 +391,12 @@ namespace std\n      template<typename _Rep1, typename _Period1,\n \t      typename _Rep2, typename _Period2>\n       inline typename common_type<_Rep1, _Rep2>::type\n-      operator/(const duration<_Rep1, _Period1>& __lhs, \n-                const duration<_Rep2, _Period2>& __rhs)\n+      operator/(const duration<_Rep1, _Period1>& __lhs,\n+\t\tconst duration<_Rep2, _Period2>& __rhs)\n       {\n-        typedef typename common_type<duration<_Rep1, _Period1>, \n-                                     duration<_Rep2, _Period2>>::type __ct;\n-        return __ct(__lhs).count() / __ct(__rhs).count();\n+\ttypedef typename common_type<duration<_Rep1, _Period1>,\n+\t\t\t\t     duration<_Rep2, _Period2>>::type __ct;\n+\treturn __ct(__lhs).count() / __ct(__rhs).count();\n       }\n \n     // DR 934.\n@@ -408,237 +411,240 @@ namespace std\n \n      template<typename _Rep1, typename _Period1,\n \t      typename _Rep2, typename _Period2>\n-      inline typename common_type<duration<_Rep1, _Period1>, \n-                                  duration<_Rep2, _Period2>>::type\n-      operator%(const duration<_Rep1, _Period1>& __lhs, \n-                const duration<_Rep2, _Period2>& __rhs)\n+      inline typename common_type<duration<_Rep1, _Period1>,\n+\t\t\t\t  duration<_Rep2, _Period2>>::type\n+      operator%(const duration<_Rep1, _Period1>& __lhs,\n+\t\tconst duration<_Rep2, _Period2>& __rhs)\n       {\n-        typedef typename common_type<duration<_Rep1, _Period1>, \n-                                     duration<_Rep2, _Period2>>::type __ct;\n-        return __ct(__lhs) %= __rhs;\n+\ttypedef typename common_type<duration<_Rep1, _Period1>,\n+\t\t\t\t     duration<_Rep2, _Period2>>::type __ct;\n+\treturn __ct(__lhs) %= __rhs;\n       }\n \n     // comparisons\n     template<typename _Rep1, typename _Period1,\n-             typename _Rep2, typename _Period2>\n-      inline bool\n-      operator==(const duration<_Rep1, _Period1>& __lhs, \n-                 const duration<_Rep2, _Period2>& __rhs)\n+\t     typename _Rep2, typename _Period2>\n+      inline constexpr bool\n+      operator==(const duration<_Rep1, _Period1>& __lhs,\n+\t\t const duration<_Rep2, _Period2>& __rhs)\n       {\n-        typedef typename common_type<duration<_Rep1, _Period1>, \n-                                     duration<_Rep2, _Period2>>::type __ct;\n-        return __ct(__lhs).count() == __ct(__rhs).count();\n+\ttypedef typename common_type<duration<_Rep1, _Period1>,\n+\t\t\t\t     duration<_Rep2, _Period2>>::type __ct;\n+\treturn __ct(__lhs).count() == __ct(__rhs).count();\n       }\n \n     template<typename _Rep1, typename _Period1,\n-             typename _Rep2, typename _Period2>\n-      inline bool\n-      operator<(const duration<_Rep1, _Period1>& __lhs, \n-                const duration<_Rep2, _Period2>& __rhs)\n+\t     typename _Rep2, typename _Period2>\n+      inline constexpr bool\n+      operator<(const duration<_Rep1, _Period1>& __lhs,\n+\t\tconst duration<_Rep2, _Period2>& __rhs)\n       {\n-        typedef typename common_type<duration<_Rep1, _Period1>, \n-                                     duration<_Rep2, _Period2>>::type __ct;\n-        return __ct(__lhs).count() < __ct(__rhs).count();\n+\ttypedef typename common_type<duration<_Rep1, _Period1>,\n+\t\t\t\t     duration<_Rep2, _Period2>>::type __ct;\n+\treturn __ct(__lhs).count() < __ct(__rhs).count();\n       }\n \n     template<typename _Rep1, typename _Period1,\n-             typename _Rep2, typename _Period2>\n-      inline bool\n-      operator!=(const duration<_Rep1, _Period1>& __lhs, \n-                 const duration<_Rep2, _Period2>& __rhs)\n+\t     typename _Rep2, typename _Period2>\n+      inline constexpr bool\n+      operator!=(const duration<_Rep1, _Period1>& __lhs,\n+\t\t const duration<_Rep2, _Period2>& __rhs)\n       { return !(__lhs == __rhs); }\n \n     template<typename _Rep1, typename _Period1,\n-             typename _Rep2, typename _Period2>\n-      inline bool\n-      operator<=(const duration<_Rep1, _Period1>& __lhs, \n-                 const duration<_Rep2, _Period2>& __rhs)\n+\t     typename _Rep2, typename _Period2>\n+      inline constexpr bool\n+      operator<=(const duration<_Rep1, _Period1>& __lhs,\n+\t\t const duration<_Rep2, _Period2>& __rhs)\n       { return !(__rhs < __lhs); }\n \n     template<typename _Rep1, typename _Period1,\n-             typename _Rep2, typename _Period2>\n-      inline bool \n-      operator>(const duration<_Rep1, _Period1>& __lhs, \n-                const duration<_Rep2, _Period2>& __rhs)\n+\t     typename _Rep2, typename _Period2>\n+      inline constexpr bool\n+      operator>(const duration<_Rep1, _Period1>& __lhs,\n+\t\tconst duration<_Rep2, _Period2>& __rhs)\n       { return __rhs < __lhs; }\n \n-    template<typename _Rep1, typename _Period1, \n-             typename _Rep2, typename _Period2>\n-      inline bool\n-      operator>=(const duration<_Rep1, _Period1>& __lhs, \n-                 const duration<_Rep2, _Period2>& __rhs)\n+    template<typename _Rep1, typename _Period1,\n+\t     typename _Rep2, typename _Period2>\n+      inline constexpr bool\n+      operator>=(const duration<_Rep1, _Period1>& __lhs,\n+\t\t const duration<_Rep2, _Period2>& __rhs)\n       { return !(__lhs < __rhs); }\n \n     /// nanoseconds\n-    typedef duration<int64_t,        nano> nanoseconds;\n+    typedef duration<int64_t, nano> \tnanoseconds;\n \n     /// microseconds\n-    typedef duration<int64_t,       micro> microseconds;\n+    typedef duration<int64_t, micro> \tmicroseconds;\n \n     /// milliseconds\n-    typedef duration<int64_t,       milli> milliseconds;\n-    \n+    typedef duration<int64_t, milli> \tmilliseconds;\n+\n     /// seconds\n-    typedef duration<int64_t             > seconds;\n+    typedef duration<int64_t> \t\tseconds;\n \n     /// minutes\n-    typedef duration<int,     ratio<  60>> minutes;\n+    typedef duration<int, ratio< 60>> \tminutes;\n \n     /// hours\n-    typedef duration<int,     ratio<3600>> hours;\n+    typedef duration<int, ratio<3600>> \thours;\n \n     /// time_point\n     template<typename _Clock, typename _Duration>\n       struct time_point\n       {\n-\ttypedef _Clock                    clock;\n-\ttypedef _Duration                 duration;\n-\ttypedef typename duration::rep    rep;\n-\ttypedef typename duration::period period;\n+\ttypedef _Clock\t\t\t  \tclock;\n+\ttypedef _Duration\t\t  \tduration;\n+\ttypedef typename duration::rep\t  \trep;\n+\ttypedef typename duration::period\tperiod;\n \n-\ttime_point() : __d(duration::zero())\n+\tconstexpr time_point() : __d(duration::zero())\n \t{ }\n \n-\texplicit time_point(const duration& __dur) \n-\t: __d(duration::zero() + __dur)\n+\tconstexpr explicit time_point(const duration& __dur)\n+\t: __d(__dur)\n \t{ }\n \n \t// conversions\n \ttemplate<typename _Duration2>\n-\t  time_point(const time_point<clock, _Duration2>& __t)\n+\t  constexpr time_point(const time_point<clock, _Duration2>& __t)\n \t  : __d(__t.time_since_epoch())\n \t  { }\n \n \t// observer\n-\tduration\n+\tconstexpr duration\n \ttime_since_epoch() const\n \t{ return __d; }\n-\t\n+\n \t// arithmetic\n \ttime_point&\n \toperator+=(const duration& __dur)\n \t{\n \t  __d += __dur;\n \t  return *this;\n \t}\n-\t\n+\n \ttime_point&\n \toperator-=(const duration& __dur)\n \t{\n \t  __d -= __dur;\n \t  return *this;\n \t}\n-\t\n+\n \t// special values\n-\t// TODO: These should be constexprs.\n-\tstatic const time_point\n+\tstatic constexpr time_point\n \tmin()\n \t{ return time_point(duration::min()); }\n-\t\n-\tstatic const time_point\n+\n+\tstatic constexpr time_point\n \tmax()\n \t{ return time_point(duration::max()); }\n-\t\n+\n       private:\n \tduration __d;\n       };\n-  \n+\n     /// time_point_cast\n     template<typename _ToDuration, typename _Clock, typename _Duration>\n-      inline typename enable_if<__is_duration<_ToDuration>::value,\n+      inline constexpr typename enable_if<__is_duration<_ToDuration>::value,\n \t\t\t\ttime_point<_Clock, _ToDuration>>::type\n       time_point_cast(const time_point<_Clock, _Duration>& __t)\n       {\n-        return time_point<_Clock, _ToDuration>(\n-          duration_cast<_ToDuration>(__t.time_since_epoch()));  \n+\treturn time_point<_Clock, _ToDuration>(\n+\t  duration_cast<_ToDuration>(__t.time_since_epoch()));\n       }\n \n     template<typename _Clock, typename _Duration1,\n-             typename _Rep2, typename _Period2>\n-      inline time_point<_Clock, \n-        typename common_type<_Duration1, duration<_Rep2, _Period2>>::type>\n-      operator+(const time_point<_Clock, _Duration1>& __lhs, \n-                const duration<_Rep2, _Period2>& __rhs)\n+\t     typename _Rep2, typename _Period2>\n+      inline time_point<_Clock,\n+\ttypename common_type<_Duration1, duration<_Rep2, _Period2>>::type>\n+      operator+(const time_point<_Clock, _Duration1>& __lhs,\n+\t\tconst duration<_Rep2, _Period2>& __rhs)\n       {\n-        typedef time_point<_Clock, \n-          typename common_type<_Duration1, \n-                               duration<_Rep2, _Period2>>::type> __ct;\n-        return __ct(__lhs) += __rhs;\n+\ttypedef time_point<_Clock,\n+\t  typename common_type<_Duration1,\n+\t\t\t       duration<_Rep2, _Period2>>::type> __ct;\n+\treturn __ct(__lhs) += __rhs;\n       }\n \n     template<typename _Rep1, typename _Period1,\n-             typename _Clock, typename _Duration2>\n-      inline time_point<_Clock, \n-        typename common_type<duration<_Rep1, _Period1>, _Duration2>::type>\n-      operator+(const duration<_Rep1, _Period1>& __lhs, \n-                const time_point<_Clock, _Duration2>& __rhs)\n+\t     typename _Clock, typename _Duration2>\n+      inline time_point<_Clock,\n+\ttypename common_type<duration<_Rep1, _Period1>, _Duration2>::type>\n+      operator+(const duration<_Rep1, _Period1>& __lhs,\n+\t\tconst time_point<_Clock, _Duration2>& __rhs)\n       { return __rhs + __lhs; }\n \n     template<typename _Clock, typename _Duration1,\n-             typename _Rep2, typename _Period2>\n-      inline time_point<_Clock, \n-        typename common_type<_Duration1, duration<_Rep2, _Period2>>::type>\n-      operator-(const time_point<_Clock, _Duration1>& __lhs, \n-                const duration<_Rep2, _Period2>& __rhs)\n+\t     typename _Rep2, typename _Period2>\n+      inline time_point<_Clock,\n+\ttypename common_type<_Duration1, duration<_Rep2, _Period2>>::type>\n+      operator-(const time_point<_Clock, _Duration1>& __lhs,\n+\t\tconst duration<_Rep2, _Period2>& __rhs)\n       { return __lhs + (-__rhs); }\n \n     template<typename _Clock, typename _Duration1, typename _Duration2>\n       inline typename common_type<_Duration1, _Duration2>::type\n-      operator-(const time_point<_Clock, _Duration1>& __lhs, \n-                const time_point<_Clock, _Duration2>& __rhs)\n+      operator-(const time_point<_Clock, _Duration1>& __lhs,\n+\t\tconst time_point<_Clock, _Duration2>& __rhs)\n       { return __lhs.time_since_epoch() - __rhs.time_since_epoch(); }\n \n     template<typename _Clock, typename _Duration1, typename _Duration2>\n-      inline bool\n+      inline constexpr bool\n       operator==(const time_point<_Clock, _Duration1>& __lhs,\n-                 const time_point<_Clock, _Duration2>& __rhs)\n+\t\t const time_point<_Clock, _Duration2>& __rhs)\n       { return __lhs.time_since_epoch() == __rhs.time_since_epoch(); }\n \n     template<typename _Clock, typename _Duration1, typename _Duration2>\n-      inline bool\n+      inline constexpr bool\n       operator!=(const time_point<_Clock, _Duration1>& __lhs,\n-                 const time_point<_Clock, _Duration2>& __rhs)\n+\t\t const time_point<_Clock, _Duration2>& __rhs)\n       { return !(__lhs == __rhs); }\n \n     template<typename _Clock, typename _Duration1, typename _Duration2>\n-      inline bool\n+      inline constexpr bool\n       operator<(const time_point<_Clock, _Duration1>& __lhs,\n-                const time_point<_Clock, _Duration2>& __rhs)\n+\t\tconst time_point<_Clock, _Duration2>& __rhs)\n       { return  __lhs.time_since_epoch() < __rhs.time_since_epoch(); }\n \n     template<typename _Clock, typename _Duration1, typename _Duration2>\n-      inline bool\n+      inline constexpr bool\n       operator<=(const time_point<_Clock, _Duration1>& __lhs,\n-                 const time_point<_Clock, _Duration2>& __rhs)\n+\t\t const time_point<_Clock, _Duration2>& __rhs)\n       { return !(__rhs < __lhs); }\n \n     template<typename _Clock, typename _Duration1, typename _Duration2>\n-      inline bool\n+      inline constexpr bool\n       operator>(const time_point<_Clock, _Duration1>& __lhs,\n-                const time_point<_Clock, _Duration2>& __rhs)\n+\t\tconst time_point<_Clock, _Duration2>& __rhs)\n       { return __rhs < __lhs; }\n \n     template<typename _Clock, typename _Duration1, typename _Duration2>\n-      inline bool\n+      inline constexpr bool\n       operator>=(const time_point<_Clock, _Duration1>& __lhs,\n-                 const time_point<_Clock, _Duration2>& __rhs)\n+\t\t const time_point<_Clock, _Duration2>& __rhs)\n       { return !(__lhs < __rhs); }\n \n     /// system_clock\n     struct system_clock\n     {\n #ifdef _GLIBCXX_USE_CLOCK_REALTIME\n-      typedef chrono::nanoseconds     duration;      \n+      typedef chrono::nanoseconds     duration;\n #elif defined(_GLIBCXX_USE_GETTIMEOFDAY)\n-      typedef chrono::microseconds    duration;      \n+      typedef chrono::microseconds    duration;\n #else\n-      typedef chrono::seconds         duration;      \n+      typedef chrono::seconds         duration;\n #endif\n \n       typedef duration::rep    rep;\n       typedef duration::period period;\n       typedef chrono::time_point<system_clock, duration> time_point;\n \n+      static_assert(system_clock::duration::min()\n+\t\t    < system_clock::duration::zero(),\n+\t\t    \"a clock's minimum duration cannot be less than its epoch\");\n+\n       static const bool is_monotonic = false;\n \n       static time_point\n@@ -648,25 +654,17 @@ namespace std\n       static std::time_t\n       to_time_t(const time_point& __t)\n       {\n-        return std::time_t(\n-          duration_cast<chrono::seconds>(__t.time_since_epoch()).count());\n+\treturn std::time_t(\n+\t  duration_cast<chrono::seconds>(__t.time_since_epoch()).count());\n       }\n \n       static time_point\n       from_time_t(std::time_t __t)\n-      { \n-        return time_point_cast<system_clock::duration>(\n-          chrono::time_point<system_clock, chrono::seconds>(\n-            chrono::seconds(__t)));\n+      {\n+\treturn time_point_cast<system_clock::duration>(\n+\t  chrono::time_point<system_clock, chrono::seconds>(\n+\t    chrono::seconds(__t)));\n       }\n-\n-      // TODO: requires constexpr\n-      /*  \n-      static_assert(\n-        system_clock::duration::min() < \n-        system_clock::duration::zero(), \n-        \"a clock's minimum duration cannot be less than its epoch\");\n-      */\n     };\n \n #ifdef _GLIBCXX_USE_CLOCK_MONOTONIC"}, {"sha": "6f0fe44eefcf3add319f5c8edbe91ee5a555ee22", "filename": "libstdc++-v3/include/std/complex", "status": "modified", "additions": 89, "deletions": 97, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcomplex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcomplex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcomplex?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -126,49 +126,49 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       \n       ///  Default constructor.  First parameter is x, second parameter is y.\n       ///  Unspecified parameters default to 0.\n-      complex(const _Tp& __r = _Tp(), const _Tp& __i = _Tp())\n+      _GLIBCXX_CONSTEXPR complex(const _Tp& __r = _Tp(), const _Tp& __i = _Tp())\n       : _M_real(__r), _M_imag(__i) { }\n \n       // Lets the compiler synthesize the copy constructor   \n       // complex (const complex<_Tp>&);\n       ///  Copy constructor.\n       template<typename _Up>\n-        complex(const complex<_Up>& __z)\n+        _GLIBCXX_CONSTEXPR complex(const complex<_Up>& __z)\n \t: _M_real(__z.real()), _M_imag(__z.imag()) { }\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // DR 387. std::complex over-encapsulated.\n-      _Tp real() const\n-      { return _M_real; }\n+      constexpr _Tp \n+      real() const { return _M_real; }\n \n-      _Tp imag() const\n-      { return _M_imag; }\n+      constexpr _Tp \n+      imag() const { return _M_imag; }\n #else\n       ///  Return real part of complex number.\n-      _Tp& real()\n-      { return _M_real; }\n+      _Tp& \n+      real() { return _M_real; }\n \n       ///  Return real part of complex number.\n-      const _Tp& real() const\n-      { return _M_real; }\n+      const _Tp& \n+      real() const { return _M_real; }\n \n       ///  Return imaginary part of complex number.\n-      _Tp& imag()\n-      { return _M_imag; }\n+      _Tp& \n+      imag() { return _M_imag; }\n \n       ///  Return imaginary part of complex number.\n-      const _Tp& imag() const\n-      { return _M_imag; }\n+      const _Tp& \n+      imag() const { return _M_imag; }\n #endif\n \n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // DR 387. std::complex over-encapsulated.\n-      void real(_Tp __val)\n-      { _M_real = __val; }\n+      void \n+      real(_Tp __val) { _M_real = __val; }\n \n-      void imag(_Tp __val)\n-      { _M_imag = __val; }\n+      void \n+      imag(_Tp __val) { _M_imag = __val; }\n \n       /// Assign this complex number to scalar @a t.\n       complex<_Tp>& operator=(const _Tp&);\n@@ -215,7 +215,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       template<typename _Up>\n         complex<_Tp>& operator/=(const complex<_Up>&);\n \n-      const complex& __rep() const\n+      _GLIBCXX_USE_CONSTEXPR complex __rep() const\n       { return *this; }\n \n     private:\n@@ -1041,46 +1041,43 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       typedef float value_type;\n       typedef __complex__ float _ComplexT;\n \n-      complex(_ComplexT __z) : _M_value(__z) { }\n+      _GLIBCXX_CONSTEXPR complex(_ComplexT __z) : _M_value(__z) { }\n \n-      complex(float __r = 0.0f, float __i = 0.0f)\n-      {\n-\t__real__ _M_value = __r;\n-\t__imag__ _M_value = __i;\n-      }\n+      _GLIBCXX_CONSTEXPR complex(float __r = 0.0f, float __i = 0.0f)\n+      : _M_value(__r + __i * 1.0fi) { }\n \n-      explicit complex(const complex<double>&);\n-      explicit complex(const complex<long double>&);\t\n+      explicit _GLIBCXX_CONSTEXPR complex(const complex<double>&);\n+      explicit _GLIBCXX_CONSTEXPR complex(const complex<long double>&);\t\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // DR 387. std::complex over-encapsulated.\n-      float real() const\n-      { return __real__ _M_value; }\n+      constexpr float \n+      real() const { return __real__ _M_value; }\n \n-      float imag() const\n-      { return __imag__ _M_value; }\n+      constexpr float \n+      imag() const { return __imag__ _M_value; }\n #else\n-      float& real()\n-      { return __real__ _M_value; }\n+      float& \n+      real() { return __real__ _M_value; }\n \n-      const float& real() const\n-      { return __real__ _M_value; }      \n+      const float& \n+      real() const { return __real__ _M_value; }      \n \n-      float& imag()\n-      { return __imag__ _M_value; }\n+      float& \n+      imag() { return __imag__ _M_value; }\n \n-      const float& imag() const\n-      { return __imag__ _M_value; }\n+      const float& \n+      imag() const { return __imag__ _M_value; }\n #endif\n \n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // DR 387. std::complex over-encapsulated.\n-      void real(float __val)\n-      { __real__ _M_value = __val; }\n+      void \n+      real(float __val) { __real__ _M_value = __val; }\n \n-      void imag(float __val)\n-      { __imag__ _M_value = __val; }\n+      void \n+      imag(float __val) { __imag__ _M_value = __val; }\n \n       complex&\n       operator=(float __f)\n@@ -1170,7 +1167,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t  return *this;\n \t}\n \n-      const _ComplexT& __rep() const { return _M_value; }\n+      _GLIBCXX_USE_CONSTEXPR _ComplexT __rep() const { return _M_value; }\n \n     private:\n       _ComplexT _M_value;\n@@ -1184,48 +1181,45 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       typedef double value_type;\n       typedef __complex__ double _ComplexT;\n \n-      complex(_ComplexT __z) : _M_value(__z) { }\n+      _GLIBCXX_CONSTEXPR complex(_ComplexT __z) : _M_value(__z) { }\n \n-      complex(double __r = 0.0, double __i = 0.0)\n-      {\n-\t__real__ _M_value = __r;\n-\t__imag__ _M_value = __i;\n-      }\n+      _GLIBCXX_CONSTEXPR complex(double __r = 0.0, double __i = 0.0)\n+      : _M_value(__r + __i * 1.0i) { }\n \n-      complex(const complex<float>& __z)\n+      _GLIBCXX_CONSTEXPR complex(const complex<float>& __z)\n       : _M_value(__z.__rep()) { }\n \n-      explicit complex(const complex<long double>&);\t\n+      explicit _GLIBCXX_CONSTEXPR complex(const complex<long double>&);\t\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // DR 387. std::complex over-encapsulated.\n-      double real() const\n-      { return __real__ _M_value; }\n+      constexpr double \n+      real() const { return __real__ _M_value; }\n \n-      double imag() const\n-      { return __imag__ _M_value; }\n+      constexpr double \n+      imag() const { return __imag__ _M_value; }\n #else\n-      double& real()\n-      { return __real__ _M_value; }\n+      double& \n+      real() { return __real__ _M_value; }\n \n-      const double& real() const\n-      { return __real__ _M_value; }\n+      const double& \n+      real() const { return __real__ _M_value; }\n \n-      double& imag()\n-      { return __imag__ _M_value; }\n+      double& \n+      imag() { return __imag__ _M_value; }\n \n-      const double& imag() const\n-      { return __imag__ _M_value; }\n+      const double& \n+      imag() const { return __imag__ _M_value; }\n #endif\n \n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // DR 387. std::complex over-encapsulated.\n-      void real(double __val)\n-      { __real__ _M_value = __val; }\n+      void \n+      real(double __val) { __real__ _M_value = __val; }\n \n-      void imag(double __val)\n-      { __imag__ _M_value = __val; }\n+      void \n+      imag(double __val) { __imag__ _M_value = __val; }\n \n       complex&\n       operator=(double __d)\n@@ -1314,7 +1308,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t  return *this;\n \t}\n \n-      const _ComplexT& __rep() const { return _M_value; }\n+      _GLIBCXX_USE_CONSTEXPR _ComplexT __rep() const { return _M_value; }\n \n     private:\n       _ComplexT _M_value;\n@@ -1328,49 +1322,47 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       typedef long double value_type;\n       typedef __complex__ long double _ComplexT;\n \n-      complex(_ComplexT __z) : _M_value(__z) { }\n+      _GLIBCXX_CONSTEXPR complex(_ComplexT __z) : _M_value(__z) { }\n \n-      complex(long double __r = 0.0L, long double __i = 0.0L)\n-      {\n-\t__real__ _M_value = __r;\n-\t__imag__ _M_value = __i;\n-      }\n+      _GLIBCXX_CONSTEXPR complex(long double __r = 0.0L, \n+\t\t\t\t long double __i = 0.0L)\n+      : _M_value(__r + __i * 1.0Li) { }\n \n-      complex(const complex<float>& __z)\n+      _GLIBCXX_CONSTEXPR complex(const complex<float>& __z)\n       : _M_value(__z.__rep()) { }\n \n-      complex(const complex<double>& __z)\n+      _GLIBCXX_CONSTEXPR complex(const complex<double>& __z)\n       : _M_value(__z.__rep()) { }\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // DR 387. std::complex over-encapsulated.\n-      long double real() const\n-      { return __real__ _M_value; }\n+      constexpr long double \n+      real() const { return __real__ _M_value; }\n \n-      long double imag() const\n-      { return __imag__ _M_value; }\n+      constexpr long double \n+      imag() const { return __imag__ _M_value; }\n #else\n-      long double& real()\n-      { return __real__ _M_value; }\n+      long double& \n+      real() { return __real__ _M_value; }\n \n-      const long double& real() const\n-      { return __real__ _M_value; }\n+      const long double& \n+      real() const { return __real__ _M_value; }\n \n-      long double& imag()\n-      { return __imag__ _M_value; }\n+      long double& \n+      imag() { return __imag__ _M_value; }\n \n-      const long double& imag() const\n-      { return __imag__ _M_value; }\n+      const long double& \n+      imag() const { return __imag__ _M_value; }\n #endif\n \n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // DR 387. std::complex over-encapsulated.\n-      void real(long double __val)\n-      { __real__ _M_value = __val; }\n+      void \n+      real(long double __val) { __real__ _M_value = __val; }\n \n-      void imag(long double __val)\n-      { __imag__ _M_value = __val; }\n+      void \n+      imag(long double __val) { __imag__ _M_value = __val; }\n \n       complex&\n       operator=(long double __r)\n@@ -1459,23 +1451,23 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t  return *this;\n \t}\n \n-      const _ComplexT& __rep() const { return _M_value; }\n+      _GLIBCXX_USE_CONSTEXPR _ComplexT __rep() const { return _M_value; }\n \n     private:\n       _ComplexT _M_value;\n     };\n \n   // These bits have to be at the end of this file, so that the\n   // specializations have all been defined.\n-  inline\n+  inline _GLIBCXX_CONSTEXPR\n   complex<float>::complex(const complex<double>& __z)\n   : _M_value(__z.__rep()) { }\n \n-  inline\n+  inline _GLIBCXX_CONSTEXPR\n   complex<float>::complex(const complex<long double>& __z)\n   : _M_value(__z.__rep()) { }\n \n-  inline\n+  inline _GLIBCXX_CONSTEXPR\n   complex<double>::complex(const complex<long double>& __z)\n   : _M_value(__z.__rep()) { }\n "}, {"sha": "aff0a33db305648650ddc7b4400bd82bc0657328", "filename": "libstdc++-v3/include/std/future", "status": "modified", "additions": 29, "deletions": 8, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -64,19 +64,23 @@ namespace std\n     no_state\n   };\n \n+  /// Specialization.\n   template<>\n     struct is_error_code_enum<future_errc> : public true_type { };\n \n   /// Points to a statically-allocated object derived from error_category.\n-  extern const error_category* const future_category;\n+  const error_category&\n+  future_category();\n \n-  // TODO: requires constexpr\n-  inline error_code make_error_code(future_errc __errc)\n-  { return error_code(static_cast<int>(__errc), *future_category); }\n+  /// Overload for make_error_code.\n+  inline error_code \n+  make_error_code(future_errc __errc)\n+  { return error_code(static_cast<int>(__errc), future_category()); }\n \n-  // TODO: requires constexpr\n-  inline error_condition make_error_condition(future_errc __errc)\n-  { return error_condition(static_cast<int>(__errc), *future_category); }\n+  /// Overload for make_error_condition.\n+  inline error_condition \n+  make_error_condition(future_errc __errc)\n+  { return error_condition(static_cast<int>(__errc), future_category()); }\n \n   /**\n    *  @brief Exception type thrown by futures.\n@@ -116,7 +120,21 @@ namespace std\n   template<typename _Res>\n     class promise;\n \n-  enum class launch { any, async, sync };\n+  /// Launch code for futures\n+  enum class launch \n+  { \n+    any, \n+    async, \n+    sync \n+  };\n+\n+  /// Status code for futures\n+  enum class future_status \n+  {\n+    ready,\n+    timeout,\n+    deferred\n+  };\n \n   template<typename _Fn, typename... _Args>\n     future<typename result_of<_Fn(_Args...)>::type>\n@@ -1242,6 +1260,7 @@ namespace std\n       }\n     };\n \n+  /// swap\n   template<typename _Res, typename... _ArgTypes>\n     inline void\n     swap(packaged_task<_Res(_ArgTypes...)>& __x,\n@@ -1307,6 +1326,7 @@ namespace std\n       thread _M_thread;\n     };\n \n+  /// async \n   template<typename _Fn, typename... _Args>\n     future<typename result_of<_Fn(_Args...)>::type>\n     async(launch __policy, _Fn&& __fn, _Args&&... __args)\n@@ -1328,6 +1348,7 @@ namespace std\n       return future<result_type>(__state);\n     }\n \n+  /// async, potential overload\n   template<typename _Fn, typename... _Args>\n     inline typename\n     enable_if<!is_same<typename decay<_Fn>::type, launch>::value,"}, {"sha": "ce557d6a76c700d96ca08d7804baa0b65db98603", "filename": "libstdc++-v3/include/std/limits", "status": "modified", "additions": 1102, "deletions": 885, "changes": 1987, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Flimits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Flimits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Flimits?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -1,4 +1,4 @@\n-// The template and inlines for the numeric_limits classes. -*- C++ -*- \n+// The template and inlines for the numeric_limits classes. -*- C++ -*-\n \n // Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,\n // 2008, 2009, 2010  Free Software Foundation, Inc.\n@@ -47,7 +47,7 @@\n // of fundamental arithmetic data types (integers and floating points).\n // From Standard C++ point of view, there are 14 such types:\n //   * integers\n-//         bool\t\t\t\t\t\t        (1)\n+//         bool\t\t\t\t\t\t\t(1)\n //         char, signed char, unsigned char, wchar_t            (4)\n //         short, unsigned short\t\t\t\t(2)\n //         int, unsigned\t\t\t\t\t(2)\n@@ -190,83 +190,101 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n   struct __numeric_limits_base\n   {\n     /** This will be true for all fundamental types (which have\n-        specializations), and false for everything else.  */\n-    static const bool is_specialized = false;\n+\tspecializations), and false for everything else.  */\n+    static _GLIBCXX_USE_CONSTEXPR bool is_specialized = false;\n \n     /** The number of @c radix digits that be represented without change:  for\n-        integer types, the number of non-sign bits in the mantissa; for\n-        floating types, the number of @c radix digits in the mantissa.  */\n-    static const int digits = 0;\n+\tinteger types, the number of non-sign bits in the mantissa; for\n+\tfloating types, the number of @c radix digits in the mantissa.  */\n+    static _GLIBCXX_USE_CONSTEXPR int digits = 0;\n+\n     /** The number of base 10 digits that can be represented without change. */\n-    static const int digits10 = 0;\n+    static _GLIBCXX_USE_CONSTEXPR int digits10 = 0;\n+\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n     /** The number of base 10 digits required to ensure that values which\n \tdiffer are always differentiated.  */\n-    static const int max_digits10 = 0;\n+    static constexpr int max_digits10 = 0;\n #endif\n+\n     /** True if the type is signed.  */\n-    static const bool is_signed = false;\n+    static _GLIBCXX_USE_CONSTEXPR bool is_signed = false;\n+\n     /** True if the type is integer.\n      *  Is this supposed to be <em>if the type is integral?</em>  */\n-    static const bool is_integer = false;\n+    static _GLIBCXX_USE_CONSTEXPR bool is_integer = false;\n+\n     /** True if the type uses an exact representation. <em>All integer types are\n-        exact, but not all exact types are integer.  For example, rational and\n-        fixed-exponent representations are exact but not integer.</em>\n-        [18.2.1.2]/15  */\n-    static const bool is_exact = false;\n+\texact, but not all exact types are integer.  For example, rational and\n+\tfixed-exponent representations are exact but not integer.</em>\n+\t[18.2.1.2]/15  */\n+    static _GLIBCXX_USE_CONSTEXPR bool is_exact = false;\n+\n     /** For integer types, specifies the base of the representation.  For\n-        floating types, specifies the base of the exponent representation.  */\n-    static const int radix = 0;\n+\tfloating types, specifies the base of the exponent representation.  */\n+    static _GLIBCXX_USE_CONSTEXPR int radix = 0;\n \n     /** The minimum negative integer such that @c radix raised to the power of\n-        (one less than that integer) is a normalized floating point number.  */\n-    static const int min_exponent = 0;\n+\t(one less than that integer) is a normalized floating point number.  */\n+    static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;\n+\n     /** The minimum negative integer such that 10 raised to that power is in\n-        the range of normalized floating point numbers.  */\n-    static const int min_exponent10 = 0;\n+\tthe range of normalized floating point numbers.  */\n+    static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;\n+\n     /** The maximum positive integer such that @c radix raised to the power of\n-        (one less than that integer) is a representable finite floating point\n+\t(one less than that integer) is a representable finite floating point\n \tnumber.  */\n-    static const int max_exponent = 0;\n+    static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;\n+\n     /** The maximum positive integer such that 10 raised to that power is in\n-        the range of representable finite floating point numbers.  */\n-    static const int max_exponent10 = 0;\n+\tthe range of representable finite floating point numbers.  */\n+    static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;\n \n     /** True if the type has a representation for positive infinity.  */\n-    static const bool has_infinity = false;\n+    static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;\n+\n     /** True if the type has a representation for a quiet (non-signaling)\n-        <em>Not a Number</em>.  */\n-    static const bool has_quiet_NaN = false;\n+\t<em>Not a Number</em>.  */\n+    static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;\n+\n     /** True if the type has a representation for a signaling\n-        <em>Not a Number</em>.  */\n-    static const bool has_signaling_NaN = false;\n+\t<em>Not a Number</em>.  */\n+    static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;\n+\n     /** See std::float_denorm_style for more information.  */\n-    static const float_denorm_style has_denorm = denorm_absent;\n+    static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm = denorm_absent;\n+\n     /** <em>True if loss of accuracy is detected as a denormalization loss,\n-        rather than as an inexact result.</em> [18.2.1.2]/42  */\n-    static const bool has_denorm_loss = false;\n+\trather than as an inexact result.</em> [18.2.1.2]/42  */\n+    static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;\n \n     /** True if-and-only-if the type adheres to the IEC 559 standard, also\n-        known as IEEE 754.  (Only makes sense for floating point types.)  */\n-    static const bool is_iec559 = false;\n+\tknown as IEEE 754.  (Only makes sense for floating point types.)  */\n+    static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;\n+\n     /** <em>True if the set of values representable by the type is\n-        finite.  All built-in types are bounded, this member would be\n-        false for arbitrary precision types.</em> [18.2.1.2]/54  */\n-    static const bool is_bounded = false;\n+\tfinite.  All built-in types are bounded, this member would be\n+\tfalse for arbitrary precision types.</em> [18.2.1.2]/54  */\n+    static _GLIBCXX_USE_CONSTEXPR bool is_bounded = false;\n+\n     /** True if the type is @e modulo, that is, if it is possible to add two\n-        positive numbers and have a result that wraps around to a third number\n-        that is less.  Typically false for floating types, true for unsigned\n-        integers, and true for signed integers.  */\n-    static const bool is_modulo = false;\n+\tpositive numbers and have a result that wraps around to a third number\n+\tthat is less.  Typically false for floating types, true for unsigned\n+\tintegers, and true for signed integers.  */\n+    static _GLIBCXX_USE_CONSTEXPR bool is_modulo = false;\n \n     /** True if trapping is implemented for this type.  */\n-    static const bool traps = false;\n+    static _GLIBCXX_USE_CONSTEXPR bool traps = false;\n+\n     /** True if tininess is detected before rounding.  (see IEC 559)  */\n-    static const bool tinyness_before = false;\n+    static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;\n+\n     /** See std::float_round_style for more information.  This is only\n-        meaningful for floating types; integer types will all be\n+\tmeaningful for floating types; integer types will all be\n \tround_toward_zero.  */\n-    static const float_round_style round_style = round_toward_zero;\n+    static _GLIBCXX_USE_CONSTEXPR float_round_style round_style = \n+\t\t\t\t\t\t    round_toward_zero;\n   };\n \n   /**\n@@ -284,33 +302,49 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n     struct numeric_limits : public __numeric_limits_base\n     {\n       /** The minimum finite value, or for floating types with\n-          denormalization, the minimum positive normalized value.  */\n-      static _Tp min() throw() { return static_cast<_Tp>(0); }\n+\t  denormalization, the minimum positive normalized value.  */\n+      static _GLIBCXX_CONSTEXPR _Tp\n+      min() throw() { return static_cast<_Tp>(0); }\n+\n       /** The maximum finite value.  */\n-      static _Tp max() throw() { return static_cast<_Tp>(0); }\n+      static _GLIBCXX_CONSTEXPR _Tp\n+      max() throw() { return static_cast<_Tp>(0); }\n+\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n       /** A finite value x such that there is no other finite value y\n        *  where y < x.  */\n-      static _Tp lowest() throw() { return static_cast<_Tp>(0); }\n+      static constexpr _Tp\n+      lowest() throw() { return static_cast<_Tp>(0); }\n #endif\n+\n       /** The @e machine @e epsilon:  the difference between 1 and the least\n-          value greater than 1 that is representable.  */\n-      static _Tp epsilon() throw() { return static_cast<_Tp>(0); }\n+\t  value greater than 1 that is representable.  */\n+      static _GLIBCXX_CONSTEXPR _Tp\n+      epsilon() throw() { return static_cast<_Tp>(0); }\n+\n       /** The maximum rounding error measurement (see LIA-1).  */\n-      static _Tp round_error() throw() { return static_cast<_Tp>(0); }\n+      static _GLIBCXX_CONSTEXPR _Tp\n+      round_error() throw() { return static_cast<_Tp>(0); }\n+\n       /** The representation of positive infinity, if @c has_infinity.  */\n-      static _Tp infinity() throw()  { return static_cast<_Tp>(0); }\n+      static _GLIBCXX_CONSTEXPR _Tp\n+      infinity() throw()  { return static_cast<_Tp>(0); }\n \n-      /** The representation of a quiet <em>Not a Number</em>, \n+      /** The representation of a quiet <em>Not a Number</em>,\n \t  if @c has_quiet_NaN. */\n-      static _Tp quiet_NaN() throw() { return static_cast<_Tp>(0); }\n+      static _GLIBCXX_CONSTEXPR _Tp\n+      quiet_NaN() throw() { return static_cast<_Tp>(0); }\n+\n       /** The representation of a signaling <em>Not a Number</em>, if\n-          @c has_signaling_NaN. */\n-      static _Tp signaling_NaN() throw() { return static_cast<_Tp>(0); }\n+\t  @c has_signaling_NaN. */\n+      static _GLIBCXX_CONSTEXPR _Tp\n+      signaling_NaN() throw() { return static_cast<_Tp>(0); }\n+\n       /** The minimum positive denormalized value.  For types where\n-          @c has_denorm is false, this is the minimum positive normalized\n+\t  @c has_denorm is false, this is the minimum positive normalized\n \t  value.  */\n-      static _Tp denorm_min() throw() { return static_cast<_Tp>(0); }\n+      static _GLIBCXX_CONSTEXPR _Tp\n+      denorm_min() throw() { return static_cast<_Tp>(0); }\n     };\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n@@ -334,935 +368,1099 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n   template<>\n     struct numeric_limits<bool>\n     {\n-      static const bool is_specialized = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;\n+\n+      static _GLIBCXX_CONSTEXPR bool \n+      min() throw() { return false; }\n+\n+      static _GLIBCXX_CONSTEXPR bool \n+      max() throw()  { return true; }\n \n-      static bool min() throw()\n-      { return false; }\n-      static bool max() throw()\n-      { return true; }\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      static bool lowest() throw()\n-      { return min(); }\n+      static constexpr bool\n+      lowest() throw() { return min(); }\n #endif\n-      static const int digits = 1;\n-      static const int digits10 = 0;\n+      static _GLIBCXX_USE_CONSTEXPR int digits = 1;\n+      static _GLIBCXX_USE_CONSTEXPR int digits10 = 0;\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      static const int max_digits10 = 0;\n+      static constexpr int max_digits10 = 0;\n #endif\n-      static const bool is_signed = false;\n-      static const bool is_integer = true;\n-      static const bool is_exact = true;\n-      static const int radix = 2;\n-      static bool epsilon() throw()\n-      { return false; }\n-      static bool round_error() throw()\n-      { return false; }\n-\n-      static const int min_exponent = 0;\n-      static const int min_exponent10 = 0;\n-      static const int max_exponent = 0;\n-      static const int max_exponent10 = 0;\n-\n-      static const bool has_infinity = false;\n-      static const bool has_quiet_NaN = false;\n-      static const bool has_signaling_NaN = false;\n-      static const float_denorm_style has_denorm = denorm_absent;\n-      static const bool has_denorm_loss = false;\n-\n-      static bool infinity() throw()\n-      { return false; }\n-      static bool quiet_NaN() throw()\n-      { return false; }\n-      static bool signaling_NaN() throw()\n-      { return false; }\n-      static bool denorm_min() throw()\n-      { return false; }\n-\n-      static const bool is_iec559 = false;\n-      static const bool is_bounded = true;\n-      static const bool is_modulo = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_signed = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;\n+      static _GLIBCXX_USE_CONSTEXPR int radix = 2;\n+\n+      static _GLIBCXX_CONSTEXPR bool \n+      epsilon() throw() { return false; }\n+\n+      static _GLIBCXX_CONSTEXPR bool \n+      round_error() throw() { return false; }\n+\n+      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;\n+      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;\n+      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;\n+      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;\n+      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm \n+       = denorm_absent;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;\n+\n+      static _GLIBCXX_CONSTEXPR bool \n+      infinity() throw() { return false; }\n+\n+      static _GLIBCXX_CONSTEXPR bool \n+      quiet_NaN() throw() { return false; }\n+\n+      static _GLIBCXX_CONSTEXPR bool \n+      signaling_NaN() throw() { return false; }\n+\n+      static _GLIBCXX_CONSTEXPR bool \n+      denorm_min() throw() { return false; }\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = false;\n \n       // It is not clear what it means for a boolean type to trap.\n       // This is a DR on the LWG issue list.  Here, I use integer\n       // promotion semantics.\n-      static const bool traps = __glibcxx_integral_traps;\n-      static const bool tinyness_before = false;\n-      static const float_round_style round_style = round_toward_zero;\n+      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;\n+      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;\n+      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style \n+       = round_toward_zero;\n     };\n \n   /// numeric_limits<char> specialization.\n   template<>\n     struct numeric_limits<char>\n     {\n-      static const bool is_specialized = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;\n+\n+      static _GLIBCXX_CONSTEXPR char \n+      min() throw() { return __glibcxx_min(char); }\n+\n+      static _GLIBCXX_CONSTEXPR char \n+      max() throw() { return __glibcxx_max(char); }\n \n-      static char min() throw()\n-      { return __glibcxx_min(char); }\n-      static char max() throw()\n-      { return __glibcxx_max(char); }\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      static char lowest() throw()\n-      { return min(); }\n+      static constexpr char \n+      lowest() throw() { return min(); }\n #endif\n \n-      static const int digits = __glibcxx_digits (char);\n-      static const int digits10 = __glibcxx_digits10 (char);\n+      static _GLIBCXX_USE_CONSTEXPR int digits = __glibcxx_digits (char);\n+      static _GLIBCXX_USE_CONSTEXPR int digits10 = __glibcxx_digits10 (char);\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      static const int max_digits10 = 0;\n+      static constexpr int max_digits10 = 0;\n #endif\n-      static const bool is_signed = __glibcxx_signed (char);\n-      static const bool is_integer = true;\n-      static const bool is_exact = true;\n-      static const int radix = 2;\n-      static char epsilon() throw()\n-      { return 0; }\n-      static char round_error() throw()\n-      { return 0; }\n-\n-      static const int min_exponent = 0;\n-      static const int min_exponent10 = 0;\n-      static const int max_exponent = 0;\n-      static const int max_exponent10 = 0;\n-\n-      static const bool has_infinity = false;\n-      static const bool has_quiet_NaN = false;\n-      static const bool has_signaling_NaN = false;\n-      static const float_denorm_style has_denorm = denorm_absent;\n-      static const bool has_denorm_loss = false;\n-\n-      static char infinity() throw()\n-      { return char(); }\n-      static char quiet_NaN() throw()\n-      { return char(); }\n-      static char signaling_NaN() throw()\n-      { return char(); }\n-      static char denorm_min() throw()\n-      { return static_cast<char>(0); }\n-\n-      static const bool is_iec559 = false;\n-      static const bool is_bounded = true;\n-      static const bool is_modulo = true;\n-\n-      static const bool traps = __glibcxx_integral_traps;\n-      static const bool tinyness_before = false;\n-      static const float_round_style round_style = round_toward_zero;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_signed = __glibcxx_signed (char);\n+      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;\n+      static _GLIBCXX_USE_CONSTEXPR int radix = 2;\n+\n+      static _GLIBCXX_CONSTEXPR char \n+      epsilon() throw() { return 0; }\n+\n+      static _GLIBCXX_CONSTEXPR char \n+      round_error() throw() { return 0; }\n+\n+      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;\n+      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;\n+      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;\n+      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;\n+      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm \n+       = denorm_absent;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;\n+\n+      static _GLIBCXX_CONSTEXPR \n+      char infinity() throw()  { return char(); }\n+\n+      static _GLIBCXX_CONSTEXPR char \n+      quiet_NaN() throw() { return char(); }\n+\n+      static _GLIBCXX_CONSTEXPR char \n+      signaling_NaN() throw() { return char(); }\n+\n+      static _GLIBCXX_CONSTEXPR char \n+      denorm_min() throw() { return static_cast<char>(0); }\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = true;\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;\n+      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;\n+      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style \n+       = round_toward_zero;\n     };\n \n   /// numeric_limits<signed char> specialization.\n   template<>\n     struct numeric_limits<signed char>\n     {\n-      static const bool is_specialized = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;\n+\n+      static _GLIBCXX_CONSTEXPR signed char \n+      min() throw() { return -__SCHAR_MAX__ - 1; }\n+\n+      static _GLIBCXX_CONSTEXPR signed char \n+      max() throw() { return __SCHAR_MAX__; }\n \n-      static signed char min() throw()\n-      { return -__SCHAR_MAX__ - 1; }\n-      static signed char max() throw()\n-      { return __SCHAR_MAX__; }\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      static signed char lowest() throw()\n-      { return min(); }\n+      static constexpr signed char \n+      lowest() throw() { return min(); }\n #endif\n \n-      static const int digits = __glibcxx_digits (signed char);\n-      static const int digits10 = __glibcxx_digits10 (signed char);\n+      static _GLIBCXX_USE_CONSTEXPR int digits = __glibcxx_digits (signed char);\n+      static _GLIBCXX_USE_CONSTEXPR int digits10 \n+       = __glibcxx_digits10 (signed char);\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      static const int max_digits10 = 0;\n+      static constexpr int max_digits10 = 0;\n #endif\n-      static const bool is_signed = true;\n-      static const bool is_integer = true;\n-      static const bool is_exact = true;\n-      static const int radix = 2;\n-      static signed char epsilon() throw()\n-      { return 0; }\n-      static signed char round_error() throw()\n-      { return 0; }\n-\n-      static const int min_exponent = 0;\n-      static const int min_exponent10 = 0;\n-      static const int max_exponent = 0;\n-      static const int max_exponent10 = 0;\n-\n-      static const bool has_infinity = false;\n-      static const bool has_quiet_NaN = false;\n-      static const bool has_signaling_NaN = false;\n-      static const float_denorm_style has_denorm = denorm_absent;\n-      static const bool has_denorm_loss = false;\n-\n-      static signed char infinity() throw()\n-      { return static_cast<signed char>(0); }\n-      static signed char quiet_NaN() throw()\n-      { return static_cast<signed char>(0); }\n-      static signed char signaling_NaN() throw()\n-      { return static_cast<signed char>(0); }\n-      static signed char denorm_min() throw()\n-      { return static_cast<signed char>(0); }\n-\n-      static const bool is_iec559 = false;\n-      static const bool is_bounded = true;\n-      static const bool is_modulo = true;\n-\n-      static const bool traps = __glibcxx_integral_traps;\n-      static const bool tinyness_before = false;\n-      static const float_round_style round_style = round_toward_zero;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_signed = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;\n+      static _GLIBCXX_USE_CONSTEXPR int radix = 2;\n+\n+      static _GLIBCXX_CONSTEXPR signed char \n+      epsilon() throw() { return 0; }\n+\n+      static _GLIBCXX_CONSTEXPR signed char \n+      round_error() throw() { return 0; }\n+\n+      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;\n+      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;\n+      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;\n+      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;\n+      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm \n+       = denorm_absent;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;\n+\n+      static _GLIBCXX_CONSTEXPR signed char \n+      infinity() throw() { return static_cast<signed char>(0); }\n+\n+      static _GLIBCXX_CONSTEXPR signed char \n+      quiet_NaN() throw() { return static_cast<signed char>(0); }\n+\n+      static _GLIBCXX_CONSTEXPR signed char \n+      signaling_NaN() throw() { return static_cast<signed char>(0); }\n+\n+      static _GLIBCXX_CONSTEXPR signed char \n+      denorm_min() throw() { return static_cast<signed char>(0); }\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = true;\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;\n+      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;\n+      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style \n+       = round_toward_zero;\n     };\n \n   /// numeric_limits<unsigned char> specialization.\n   template<>\n     struct numeric_limits<unsigned char>\n     {\n-      static const bool is_specialized = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;\n+\n+      static _GLIBCXX_CONSTEXPR unsigned char \n+      min() throw() { return 0; }\n+\n+      static _GLIBCXX_CONSTEXPR unsigned char \n+      max() throw() { return __SCHAR_MAX__ * 2U + 1; }\n \n-      static unsigned char min() throw()\n-      { return 0; }\n-      static unsigned char max() throw()\n-      { return __SCHAR_MAX__ * 2U + 1; }\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      static unsigned char lowest() throw()\n-      { return min(); }\n+      static constexpr unsigned char \n+      lowest() throw() { return min(); }\n #endif\n \n-      static const int digits = __glibcxx_digits (unsigned char);\n-      static const int digits10 = __glibcxx_digits10 (unsigned char);\n+      static _GLIBCXX_USE_CONSTEXPR int digits \n+       = __glibcxx_digits (unsigned char);\n+      static _GLIBCXX_USE_CONSTEXPR int digits10 \n+       = __glibcxx_digits10 (unsigned char);\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      static const int max_digits10 = 0;\n+      static constexpr int max_digits10 = 0;\n #endif\n-      static const bool is_signed = false;\n-      static const bool is_integer = true;\n-      static const bool is_exact = true;\n-      static const int radix = 2;\n-      static unsigned char epsilon() throw()\n-      { return 0; }\n-      static unsigned char round_error() throw()\n-      { return 0; }\n-\n-      static const int min_exponent = 0;\n-      static const int min_exponent10 = 0;\n-      static const int max_exponent = 0;\n-      static const int max_exponent10 = 0;\n-\n-      static const bool has_infinity = false;\n-      static const bool has_quiet_NaN = false;\n-      static const bool has_signaling_NaN = false;\n-      static const float_denorm_style has_denorm = denorm_absent;\n-      static const bool has_denorm_loss = false;\n-\n-      static unsigned char infinity() throw()\n-      { return static_cast<unsigned char>(0); }\n-      static unsigned char quiet_NaN() throw()\n-      { return static_cast<unsigned char>(0); }\n-      static unsigned char signaling_NaN() throw()\n-      { return static_cast<unsigned char>(0); }\n-      static unsigned char denorm_min() throw()\n-      { return static_cast<unsigned char>(0); }\n-\n-      static const bool is_iec559 = false;\n-      static const bool is_bounded = true;\n-      static const bool is_modulo = true;\n-\n-      static const bool traps = __glibcxx_integral_traps;\n-      static const bool tinyness_before = false;\n-      static const float_round_style round_style = round_toward_zero;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_signed = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;\n+      static _GLIBCXX_USE_CONSTEXPR int radix = 2;\n+\n+      static _GLIBCXX_CONSTEXPR unsigned char \n+      epsilon() throw() { return 0; }\n+\n+      static _GLIBCXX_CONSTEXPR unsigned char \n+      round_error() throw() { return 0; }\n+\n+      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;\n+      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;\n+      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;\n+      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;\n+      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm \n+       = denorm_absent;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;\n+\n+      static _GLIBCXX_CONSTEXPR unsigned char \n+      infinity() throw() { return static_cast<unsigned char>(0); }\n+\n+      static _GLIBCXX_CONSTEXPR unsigned char \n+      quiet_NaN() throw() { return static_cast<unsigned char>(0); }\n+\n+      static _GLIBCXX_CONSTEXPR unsigned char \n+      signaling_NaN() throw() { return static_cast<unsigned char>(0); }\n+\n+      static _GLIBCXX_CONSTEXPR unsigned char \n+      denorm_min() throw() { return static_cast<unsigned char>(0); }\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = true;\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;\n+      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;\n+      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style \n+       = round_toward_zero;\n     };\n \n   /// numeric_limits<wchar_t> specialization.\n   template<>\n     struct numeric_limits<wchar_t>\n     {\n-      static const bool is_specialized = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;\n+\n+      static _GLIBCXX_CONSTEXPR wchar_t \n+      min() throw() { return __glibcxx_min (wchar_t); }\n+\n+      static _GLIBCXX_CONSTEXPR wchar_t \n+      max() throw()  { return __glibcxx_max (wchar_t); }\n \n-      static wchar_t min() throw()\n-      { return __glibcxx_min (wchar_t); }\n-      static wchar_t max() throw()\n-      { return __glibcxx_max (wchar_t); }\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      static wchar_t lowest() throw()\n-      { return min(); }\n+      static constexpr wchar_t \n+      lowest() throw() { return min(); }\n #endif\n \n-      static const int digits = __glibcxx_digits (wchar_t);\n-      static const int digits10 = __glibcxx_digits10 (wchar_t);\n+      static _GLIBCXX_USE_CONSTEXPR int digits = __glibcxx_digits (wchar_t);\n+      static _GLIBCXX_USE_CONSTEXPR int digits10 \n+       = __glibcxx_digits10 (wchar_t);\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      static const int max_digits10 = 0;\n+      static constexpr int max_digits10 = 0;\n #endif\n-      static const bool is_signed = __glibcxx_signed (wchar_t);\n-      static const bool is_integer = true;\n-      static const bool is_exact = true;\n-      static const int radix = 2;\n-      static wchar_t epsilon() throw()\n-      { return 0; }\n-      static wchar_t round_error() throw()\n-      { return 0; }\n-\n-      static const int min_exponent = 0;\n-      static const int min_exponent10 = 0;\n-      static const int max_exponent = 0;\n-      static const int max_exponent10 = 0;\n-\n-      static const bool has_infinity = false;\n-      static const bool has_quiet_NaN = false;\n-      static const bool has_signaling_NaN = false;\n-      static const float_denorm_style has_denorm = denorm_absent;\n-      static const bool has_denorm_loss = false;\n-\n-      static wchar_t infinity() throw()\n-      { return wchar_t(); }\n-      static wchar_t quiet_NaN() throw()\n-      { return wchar_t(); }\n-      static wchar_t signaling_NaN() throw()\n-      { return wchar_t(); }\n-      static wchar_t denorm_min() throw()\n-      { return wchar_t(); }\n-\n-      static const bool is_iec559 = false;\n-      static const bool is_bounded = true;\n-      static const bool is_modulo = true;\n-\n-      static const bool traps = __glibcxx_integral_traps;\n-      static const bool tinyness_before = false;\n-      static const float_round_style round_style = round_toward_zero;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_signed = __glibcxx_signed (wchar_t);\n+      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;\n+      static _GLIBCXX_USE_CONSTEXPR int radix = 2;\n+\n+      static _GLIBCXX_CONSTEXPR wchar_t \n+      epsilon() throw() { return 0; }\n+\n+      static _GLIBCXX_CONSTEXPR wchar_t \n+      round_error() throw() { return 0; }\n+\n+      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;\n+      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;\n+      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;\n+      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;\n+      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm \n+       = denorm_absent;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;\n+\n+      static _GLIBCXX_CONSTEXPR wchar_t \n+      infinity() throw() { return wchar_t(); }\n+\n+      static _GLIBCXX_CONSTEXPR wchar_t \n+      quiet_NaN() throw() { return wchar_t(); }\n+\n+      static _GLIBCXX_CONSTEXPR wchar_t \n+      signaling_NaN() throw() { return wchar_t(); }\n+\n+      static _GLIBCXX_CONSTEXPR wchar_t \n+      denorm_min() throw() { return wchar_t(); }\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = true;\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;\n+      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;\n+      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style \n+       = round_toward_zero;\n     };\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n   /// numeric_limits<char16_t> specialization.\n   template<>\n     struct numeric_limits<char16_t>\n     {\n-      static const bool is_specialized = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;\n+\n+      static _GLIBCXX_CONSTEXPR char16_t \n+      min() throw() { return __glibcxx_min (char16_t); }\n+\n+      static _GLIBCXX_CONSTEXPR char16_t \n+      max() throw() { return __glibcxx_max (char16_t); }\n \n-      static char16_t min() throw()\n-      { return __glibcxx_min (char16_t); }\n-      static char16_t max() throw()\n-      { return __glibcxx_max (char16_t); }\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      static char16_t lowest() throw()\n-      { return min(); }\n+      static constexpr char16_t \n+      lowest() throw() { return min(); }\n #endif\n \n-      static const int digits = __glibcxx_digits (char16_t);\n-      static const int digits10 = __glibcxx_digits10 (char16_t);\n+      static _GLIBCXX_USE_CONSTEXPR int digits \n+       = __glibcxx_digits (char16_t);\n+      static _GLIBCXX_USE_CONSTEXPR int digits10 \n+       = __glibcxx_digits10 (char16_t);\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      static const int max_digits10 = 0;\n+      static constexpr int max_digits10 = 0;\n #endif\n-      static const bool is_signed = __glibcxx_signed (char16_t);\n-      static const bool is_integer = true;\n-      static const bool is_exact = true;\n-      static const int radix = 2;\n-      static char16_t epsilon() throw()\n-      { return 0; }\n-      static char16_t round_error() throw()\n-      { return 0; }\n-\n-      static const int min_exponent = 0;\n-      static const int min_exponent10 = 0;\n-      static const int max_exponent = 0;\n-      static const int max_exponent10 = 0;\n-\n-      static const bool has_infinity = false;\n-      static const bool has_quiet_NaN = false;\n-      static const bool has_signaling_NaN = false;\n-      static const float_denorm_style has_denorm = denorm_absent;\n-      static const bool has_denorm_loss = false;\n-\n-      static char16_t infinity() throw()\n-      { return char16_t(); }\n-      static char16_t quiet_NaN() throw()\n-      { return char16_t(); }\n-      static char16_t signaling_NaN() throw()\n-      { return char16_t(); }\n-      static char16_t denorm_min() throw()\n-      { return char16_t(); }\n-\n-      static const bool is_iec559 = false;\n-      static const bool is_bounded = true;\n-      static const bool is_modulo = true;\n-\n-      static const bool traps = __glibcxx_integral_traps;\n-      static const bool tinyness_before = false;\n-      static const float_round_style round_style = round_toward_zero;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_signed \n+       = __glibcxx_signed (char16_t);\n+      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;\n+      static _GLIBCXX_USE_CONSTEXPR int radix = 2;\n+\n+      static _GLIBCXX_CONSTEXPR char16_t \n+      epsilon() throw() { return 0; }\n+\n+      static _GLIBCXX_CONSTEXPR char16_t \n+      round_error() throw() { return 0; }\n+\n+      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;\n+      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;\n+      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;\n+      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;\n+      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm \n+       = denorm_absent;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;\n+\n+      static _GLIBCXX_CONSTEXPR char16_t \n+      infinity() throw()  { return char16_t(); }\n+\n+      static _GLIBCXX_CONSTEXPR char16_t \n+      quiet_NaN() throw() { return char16_t(); }\n+\n+      static _GLIBCXX_CONSTEXPR char16_t \n+      signaling_NaN() throw() { return char16_t(); }\n+\n+      static _GLIBCXX_CONSTEXPR char16_t \n+      denorm_min() throw() { return char16_t(); }\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = true;\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;\n+      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;\n+      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style \n+       = round_toward_zero;\n     };\n \n   /// numeric_limits<char32_t> specialization.\n   template<>\n     struct numeric_limits<char32_t>\n     {\n-      static const bool is_specialized = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;\n+\n+      static _GLIBCXX_CONSTEXPR char32_t \n+      min() throw() { return __glibcxx_min (char32_t); }\n+\n+      static _GLIBCXX_CONSTEXPR char32_t \n+      max() throw() { return __glibcxx_max (char32_t); }\n \n-      static char32_t min() throw()\n-      { return __glibcxx_min (char32_t); }\n-      static char32_t max() throw()\n-      { return __glibcxx_max (char32_t); }\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      static char32_t lowest() throw()\n-      { return min(); }\n+      static constexpr char32_t \n+      lowest() throw() { return min(); }\n #endif\n \n-      static const int digits = __glibcxx_digits (char32_t);\n-      static const int digits10 = __glibcxx_digits10 (char32_t);\n+      static _GLIBCXX_USE_CONSTEXPR int digits = __glibcxx_digits (char32_t);\n+      static _GLIBCXX_USE_CONSTEXPR int digits10 \n+       = __glibcxx_digits10 (char32_t);\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      static const int max_digits10 = 0;\n+      static constexpr int max_digits10 = 0;\n #endif\n-      static const bool is_signed = __glibcxx_signed (char32_t);\n-      static const bool is_integer = true;\n-      static const bool is_exact = true;\n-      static const int radix = 2;\n-      static char32_t epsilon() throw()\n-      { return 0; }\n-      static char32_t round_error() throw()\n-      { return 0; }\n-\n-      static const int min_exponent = 0;\n-      static const int min_exponent10 = 0;\n-      static const int max_exponent = 0;\n-      static const int max_exponent10 = 0;\n-\n-      static const bool has_infinity = false;\n-      static const bool has_quiet_NaN = false;\n-      static const bool has_signaling_NaN = false;\n-      static const float_denorm_style has_denorm = denorm_absent;\n-      static const bool has_denorm_loss = false;\n-\n-      static char32_t infinity() throw()\n-      { return char32_t(); }\n-      static char32_t quiet_NaN() throw()\n-      { return char32_t(); }\n-      static char32_t signaling_NaN() throw()\n-      { return char32_t(); }\n-      static char32_t denorm_min() throw()\n-      { return char32_t(); }\n-\n-      static const bool is_iec559 = false;\n-      static const bool is_bounded = true;\n-      static const bool is_modulo = true;\n-\n-      static const bool traps = __glibcxx_integral_traps;\n-      static const bool tinyness_before = false;\n-      static const float_round_style round_style = round_toward_zero;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_signed \n+       = __glibcxx_signed (char32_t);\n+      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;\n+      static _GLIBCXX_USE_CONSTEXPR int radix = 2;\n+\n+      static _GLIBCXX_CONSTEXPR char32_t \n+      epsilon() throw() { return 0; }\n+\n+      static _GLIBCXX_CONSTEXPR char32_t \n+      round_error() throw() { return 0; }\n+\n+      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;\n+      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;\n+      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;\n+      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;\n+      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm \n+       = denorm_absent;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;\n+\n+      static _GLIBCXX_CONSTEXPR char32_t \n+      infinity() throw() { return char32_t(); }\n+\n+      static _GLIBCXX_CONSTEXPR char32_t \n+      quiet_NaN() throw() { return char32_t(); }\n+\n+      static _GLIBCXX_CONSTEXPR char32_t \n+      signaling_NaN() throw() { return char32_t(); }\n+\n+      static _GLIBCXX_CONSTEXPR char32_t \n+      denorm_min() throw() { return char32_t(); }\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = true;\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;\n+      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;\n+      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style \n+       = round_toward_zero;\n     };\n #endif\n \n   /// numeric_limits<short> specialization.\n   template<>\n     struct numeric_limits<short>\n     {\n-      static const bool is_specialized = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;\n+\n+      static _GLIBCXX_CONSTEXPR short \n+      min() throw() { return -__SHRT_MAX__ - 1; }\n+\n+      static _GLIBCXX_CONSTEXPR short \n+      max() throw() { return __SHRT_MAX__; }\n \n-      static short min() throw()\n-      { return -__SHRT_MAX__ - 1; }\n-      static short max() throw()\n-      { return __SHRT_MAX__; }\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      static short lowest() throw()\n-      { return min(); }\n+      static constexpr short \n+      lowest() throw() { return min(); }\n #endif\n \n-      static const int digits = __glibcxx_digits (short);\n-      static const int digits10 = __glibcxx_digits10 (short);\n+      static _GLIBCXX_USE_CONSTEXPR int digits = __glibcxx_digits (short);\n+      static _GLIBCXX_USE_CONSTEXPR int digits10 = __glibcxx_digits10 (short);\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      static const int max_digits10 = 0;\n+      static constexpr int max_digits10 = 0;\n #endif\n-      static const bool is_signed = true;\n-      static const bool is_integer = true;\n-      static const bool is_exact = true;\n-      static const int radix = 2;\n-      static short epsilon() throw()\n-      { return 0; }\n-      static short round_error() throw()\n-      { return 0; }\n-\n-      static const int min_exponent = 0;\n-      static const int min_exponent10 = 0;\n-      static const int max_exponent = 0;\n-      static const int max_exponent10 = 0;\n-\n-      static const bool has_infinity = false;\n-      static const bool has_quiet_NaN = false;\n-      static const bool has_signaling_NaN = false;\n-      static const float_denorm_style has_denorm = denorm_absent;\n-      static const bool has_denorm_loss = false;\n-\n-      static short infinity() throw()\n-      { return short(); }\n-      static short quiet_NaN() throw()\n-      { return short(); }\n-      static short signaling_NaN() throw()\n-      { return short(); }\n-      static short denorm_min() throw()\n-      { return short(); }\n-\n-      static const bool is_iec559 = false;\n-      static const bool is_bounded = true;\n-      static const bool is_modulo = true;\n-\n-      static const bool traps = __glibcxx_integral_traps;\n-      static const bool tinyness_before = false;\n-      static const float_round_style round_style = round_toward_zero;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_signed = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;\n+      static _GLIBCXX_USE_CONSTEXPR int radix = 2;\n+\n+      static _GLIBCXX_CONSTEXPR short \n+      epsilon() throw() { return 0; }\n+\n+      static _GLIBCXX_CONSTEXPR short \n+      round_error() throw() { return 0; }\n+\n+      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;\n+      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;\n+      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;\n+      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;\n+      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm \n+       = denorm_absent;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;\n+\n+      static _GLIBCXX_CONSTEXPR short \n+      infinity() throw() { return short(); }\n+\n+      static _GLIBCXX_CONSTEXPR short \n+      quiet_NaN() throw() { return short(); }\n+\n+      static _GLIBCXX_CONSTEXPR short \n+      signaling_NaN() throw() { return short(); }\n+\n+      static _GLIBCXX_CONSTEXPR short \n+      denorm_min() throw() { return short(); }\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = true;\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;\n+      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;\n+      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style \n+       = round_toward_zero;\n     };\n \n   /// numeric_limits<unsigned short> specialization.\n   template<>\n     struct numeric_limits<unsigned short>\n     {\n-      static const bool is_specialized = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;\n+\n+      static _GLIBCXX_CONSTEXPR unsigned short \n+      min() throw() { return 0; }\n+\n+      static _GLIBCXX_CONSTEXPR unsigned short \n+      max() throw() { return __SHRT_MAX__ * 2U + 1; }\n \n-      static unsigned short min() throw()\n-      { return 0; }\n-      static unsigned short max() throw()\n-      { return __SHRT_MAX__ * 2U + 1; }\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      static unsigned short lowest() throw()\n-      { return min(); }\n+      static constexpr unsigned short \n+      lowest() throw() { return min(); }\n #endif\n \n-      static const int digits = __glibcxx_digits (unsigned short);\n-      static const int digits10 = __glibcxx_digits10 (unsigned short);\n+      static _GLIBCXX_USE_CONSTEXPR int digits \n+       = __glibcxx_digits (unsigned short);\n+      static _GLIBCXX_USE_CONSTEXPR int digits10 \n+       = __glibcxx_digits10 (unsigned short);\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      static const int max_digits10 = 0;\n+      static constexpr int max_digits10 = 0;\n #endif\n-      static const bool is_signed = false;\n-      static const bool is_integer = true;\n-      static const bool is_exact = true;\n-      static const int radix = 2;\n-      static unsigned short epsilon() throw()\n-      { return 0; }\n-      static unsigned short round_error() throw()\n-      { return 0; }\n-\n-      static const int min_exponent = 0;\n-      static const int min_exponent10 = 0;\n-      static const int max_exponent = 0;\n-      static const int max_exponent10 = 0;\n-\n-      static const bool has_infinity = false;\n-      static const bool has_quiet_NaN = false;\n-      static const bool has_signaling_NaN = false;\n-      static const float_denorm_style has_denorm = denorm_absent;\n-      static const bool has_denorm_loss = false;\n-\n-      static unsigned short infinity() throw()\n-      { return static_cast<unsigned short>(0); }\n-      static unsigned short quiet_NaN() throw()\n-      { return static_cast<unsigned short>(0); }\n-      static unsigned short signaling_NaN() throw()\n-      { return static_cast<unsigned short>(0); }\n-      static unsigned short denorm_min() throw()\n-      { return static_cast<unsigned short>(0); }\n-\n-      static const bool is_iec559 = false;\n-      static const bool is_bounded = true;\n-      static const bool is_modulo = true;\n-\n-      static const bool traps = __glibcxx_integral_traps;\n-      static const bool tinyness_before = false;\n-      static const float_round_style round_style = round_toward_zero;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_signed = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;\n+      static _GLIBCXX_USE_CONSTEXPR int radix = 2;\n+\n+      static _GLIBCXX_CONSTEXPR unsigned short \n+      epsilon() throw() { return 0; }\n+\n+      static _GLIBCXX_CONSTEXPR unsigned short \n+      round_error() throw() { return 0; }\n+\n+      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;\n+      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;\n+      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;\n+      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;\n+      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm \n+       = denorm_absent;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;\n+\n+      static _GLIBCXX_CONSTEXPR unsigned short \n+      infinity() throw() { return static_cast<unsigned short>(0); }\n+\n+      static _GLIBCXX_CONSTEXPR unsigned short \n+      quiet_NaN() throw() { return static_cast<unsigned short>(0); }\n+\n+      static _GLIBCXX_CONSTEXPR unsigned short \n+      signaling_NaN() throw() { return static_cast<unsigned short>(0); }\n+\n+      static _GLIBCXX_CONSTEXPR unsigned short \n+      denorm_min() throw() { return static_cast<unsigned short>(0); }\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = true;\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;\n+      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;\n+      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style \n+       = round_toward_zero;\n     };\n \n   /// numeric_limits<int> specialization.\n   template<>\n     struct numeric_limits<int>\n     {\n-      static const bool is_specialized = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;\n+\n+      static _GLIBCXX_CONSTEXPR int \n+      min() throw() { return -__INT_MAX__ - 1; }\n+\n+      static _GLIBCXX_CONSTEXPR int \n+      max() throw() { return __INT_MAX__; }\n \n-      static int min() throw()\n-      { return -__INT_MAX__ - 1; }\n-      static int max() throw()\n-      { return __INT_MAX__; }\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      static int lowest() throw()\n-      { return min(); }\n+      static constexpr int \n+      lowest() throw() { return min(); }\n #endif\n \n-      static const int digits = __glibcxx_digits (int);\n-      static const int digits10 = __glibcxx_digits10 (int);\n+      static _GLIBCXX_USE_CONSTEXPR int digits = __glibcxx_digits (int);\n+      static _GLIBCXX_USE_CONSTEXPR int digits10 = __glibcxx_digits10 (int);\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      static const int max_digits10 = 0;\n+      static constexpr int max_digits10 = 0;\n #endif\n-      static const bool is_signed = true;\n-      static const bool is_integer = true;\n-      static const bool is_exact = true;\n-      static const int radix = 2;\n-      static int epsilon() throw()\n-      { return 0; }\n-      static int round_error() throw()\n-      { return 0; }\n-\n-      static const int min_exponent = 0;\n-      static const int min_exponent10 = 0;\n-      static const int max_exponent = 0;\n-      static const int max_exponent10 = 0;\n-\n-      static const bool has_infinity = false;\n-      static const bool has_quiet_NaN = false;\n-      static const bool has_signaling_NaN = false;\n-      static const float_denorm_style has_denorm = denorm_absent;\n-      static const bool has_denorm_loss = false;\n-\n-      static int infinity() throw()\n-      { return static_cast<int>(0); }\n-      static int quiet_NaN() throw()\n-      { return static_cast<int>(0); }\n-      static int signaling_NaN() throw()\n-      { return static_cast<int>(0); }\n-      static int denorm_min() throw()\n-      { return static_cast<int>(0); }\n-\n-      static const bool is_iec559 = false;\n-      static const bool is_bounded = true;\n-      static const bool is_modulo = true;\n-\n-      static const bool traps = __glibcxx_integral_traps;\n-      static const bool tinyness_before = false;\n-      static const float_round_style round_style = round_toward_zero;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_signed = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;\n+      static _GLIBCXX_USE_CONSTEXPR int radix = 2;\n+\n+      static _GLIBCXX_CONSTEXPR int \n+      epsilon() throw() { return 0; }\n+\n+      static _GLIBCXX_CONSTEXPR int \n+      round_error() throw() { return 0; }\n+\n+      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;\n+      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;\n+      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;\n+      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;\n+      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm \n+       = denorm_absent;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;\n+\n+      static _GLIBCXX_CONSTEXPR int \n+      infinity() throw() { return static_cast<int>(0); }\n+\n+      static _GLIBCXX_CONSTEXPR int \n+      quiet_NaN() throw() { return static_cast<int>(0); }\n+\n+      static _GLIBCXX_CONSTEXPR int \n+      signaling_NaN() throw() { return static_cast<int>(0); }\n+\n+      static _GLIBCXX_CONSTEXPR int \n+      denorm_min() throw() { return static_cast<int>(0); }\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = true;\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;\n+      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;\n+      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style \n+       = round_toward_zero;\n     };\n \n   /// numeric_limits<unsigned int> specialization.\n   template<>\n     struct numeric_limits<unsigned int>\n     {\n-      static const bool is_specialized = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;\n+\n+      static _GLIBCXX_CONSTEXPR unsigned int \n+      min() throw() { return 0; }\n+\n+      static _GLIBCXX_CONSTEXPR unsigned int \n+      max() throw() { return __INT_MAX__ * 2U + 1; }\n \n-      static unsigned int min() throw()\n-      { return 0; }\n-      static unsigned int max() throw()\n-      { return __INT_MAX__ * 2U + 1; }\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      static unsigned int lowest() throw()\n-      { return min(); }\n+      static constexpr unsigned int \n+      lowest() throw() { return min(); }\n #endif\n \n-      static const int digits = __glibcxx_digits (unsigned int);\n-      static const int digits10 = __glibcxx_digits10 (unsigned int);\n+      static _GLIBCXX_USE_CONSTEXPR int digits \n+       = __glibcxx_digits (unsigned int);\n+      static _GLIBCXX_USE_CONSTEXPR int digits10 \n+       = __glibcxx_digits10 (unsigned int);\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      static const int max_digits10 = 0;\n+      static constexpr int max_digits10 = 0;\n #endif\n-      static const bool is_signed = false;\n-      static const bool is_integer = true;\n-      static const bool is_exact = true;\n-      static const int radix = 2;\n-      static unsigned int epsilon() throw()\n-      { return 0; }\n-      static unsigned int round_error() throw()\n-      { return 0; }\n-\n-      static const int min_exponent = 0;\n-      static const int min_exponent10 = 0;\n-      static const int max_exponent = 0;\n-      static const int max_exponent10 = 0;\n-\n-      static const bool has_infinity = false;\n-      static const bool has_quiet_NaN = false;\n-      static const bool has_signaling_NaN = false;\n-      static const float_denorm_style has_denorm = denorm_absent;\n-      static const bool has_denorm_loss = false;\n-\n-      static unsigned int infinity() throw()\n-      { return static_cast<unsigned int>(0); }\n-      static unsigned int quiet_NaN() throw()\n-      { return static_cast<unsigned int>(0); }\n-      static unsigned int signaling_NaN() throw()\n-      { return static_cast<unsigned int>(0); }\n-      static unsigned int denorm_min() throw()\n-      { return static_cast<unsigned int>(0); }\n-\n-      static const bool is_iec559 = false;\n-      static const bool is_bounded = true;\n-      static const bool is_modulo = true;\n-\n-      static const bool traps = __glibcxx_integral_traps;\n-      static const bool tinyness_before = false;\n-      static const float_round_style round_style = round_toward_zero;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_signed = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;\n+      static _GLIBCXX_USE_CONSTEXPR int radix = 2;\n+\n+      static _GLIBCXX_CONSTEXPR unsigned int \n+      epsilon() throw() { return 0; }\n+\n+      static _GLIBCXX_CONSTEXPR unsigned int \n+      round_error() throw() { return 0; }\n+\n+      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;\n+      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;\n+      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;\n+      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;\n+      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm \n+       = denorm_absent;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;\n+\n+      static _GLIBCXX_CONSTEXPR unsigned int \n+      infinity() throw() { return static_cast<unsigned int>(0); }\n+\n+      static _GLIBCXX_CONSTEXPR unsigned int \n+      quiet_NaN() throw() { return static_cast<unsigned int>(0); }\n+\n+      static _GLIBCXX_CONSTEXPR unsigned int \n+      signaling_NaN() throw() { return static_cast<unsigned int>(0); }\n+\n+      static _GLIBCXX_CONSTEXPR unsigned int \n+      denorm_min() throw() { return static_cast<unsigned int>(0); }\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = true;\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;\n+      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;\n+      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style \n+       = round_toward_zero;\n     };\n \n   /// numeric_limits<long> specialization.\n   template<>\n     struct numeric_limits<long>\n     {\n-      static const bool is_specialized = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;\n+\n+      static _GLIBCXX_CONSTEXPR long\n+      min() throw() { return -__LONG_MAX__ - 1; }\n+\n+      static _GLIBCXX_CONSTEXPR long \n+      max() throw() { return __LONG_MAX__; }\n \n-      static long min() throw()\n-      { return -__LONG_MAX__ - 1; }\n-      static long max() throw()\n-      { return __LONG_MAX__; }\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      static long lowest() throw()\n-      { return min(); }\n+      static constexpr long \n+      lowest() throw() { return min(); }\n #endif\n \n-      static const int digits = __glibcxx_digits (long);\n-      static const int digits10 = __glibcxx_digits10 (long);\n+      static _GLIBCXX_USE_CONSTEXPR int digits = __glibcxx_digits (long);\n+      static _GLIBCXX_USE_CONSTEXPR int digits10 = __glibcxx_digits10 (long);\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      static const int max_digits10 = 0;\n+      static constexpr int max_digits10 = 0;\n #endif\n-      static const bool is_signed = true;\n-      static const bool is_integer = true;\n-      static const bool is_exact = true;\n-      static const int radix = 2;\n-      static long epsilon() throw()\n-      { return 0; }\n-      static long round_error() throw()\n-      { return 0; }\n-\n-      static const int min_exponent = 0;\n-      static const int min_exponent10 = 0;\n-      static const int max_exponent = 0;\n-      static const int max_exponent10 = 0;\n-\n-      static const bool has_infinity = false;\n-      static const bool has_quiet_NaN = false;\n-      static const bool has_signaling_NaN = false;\n-      static const float_denorm_style has_denorm = denorm_absent;\n-      static const bool has_denorm_loss = false;\n-\n-      static long infinity() throw()\n-      { return static_cast<long>(0); }\n-      static long quiet_NaN() throw()\n-      { return static_cast<long>(0); }\n-      static long signaling_NaN() throw()\n-      { return static_cast<long>(0); }\n-      static long denorm_min() throw()\n-      { return static_cast<long>(0); }\n-\n-      static const bool is_iec559 = false;\n-      static const bool is_bounded = true;\n-      static const bool is_modulo = true;\n-\n-      static const bool traps = __glibcxx_integral_traps;\n-      static const bool tinyness_before = false;\n-      static const float_round_style round_style = round_toward_zero;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_signed = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;\n+      static _GLIBCXX_USE_CONSTEXPR int radix = 2;\n+\n+      static _GLIBCXX_CONSTEXPR long \n+      epsilon() throw() { return 0; }\n+\n+      static _GLIBCXX_CONSTEXPR long \n+      round_error() throw() { return 0; }\n+\n+      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;\n+      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;\n+      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;\n+      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;\n+      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm \n+       = denorm_absent;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;\n+\n+      static _GLIBCXX_CONSTEXPR long \n+      infinity() throw() { return static_cast<long>(0); }\n+\n+      static _GLIBCXX_CONSTEXPR long \n+      quiet_NaN() throw() { return static_cast<long>(0); }\n+\n+      static _GLIBCXX_CONSTEXPR long \n+      signaling_NaN() throw() { return static_cast<long>(0); }\n+\n+      static _GLIBCXX_CONSTEXPR long \n+      denorm_min() throw() { return static_cast<long>(0); }\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = true;\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;\n+      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;\n+      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style \n+       = round_toward_zero;\n     };\n \n   /// numeric_limits<unsigned long> specialization.\n   template<>\n     struct numeric_limits<unsigned long>\n     {\n-      static const bool is_specialized = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;\n+\n+      static _GLIBCXX_CONSTEXPR unsigned long \n+      min() throw() { return 0; }\n+\n+      static _GLIBCXX_CONSTEXPR unsigned long \n+      max() throw() { return __LONG_MAX__ * 2UL + 1; }\n \n-      static unsigned long min() throw()\n-      { return 0; }\n-      static unsigned long max() throw()\n-      { return __LONG_MAX__ * 2UL + 1; }\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      static unsigned long lowest() throw()\n-      { return min(); }\n+      static constexpr unsigned long \n+      lowest() throw() { return min(); }\n #endif\n \n-      static const int digits = __glibcxx_digits (unsigned long);\n-      static const int digits10 = __glibcxx_digits10 (unsigned long);\n+      static _GLIBCXX_USE_CONSTEXPR int digits \n+       = __glibcxx_digits (unsigned long);\n+      static _GLIBCXX_USE_CONSTEXPR int digits10 \n+       = __glibcxx_digits10 (unsigned long);\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      static const int max_digits10 = 0;\n+      static constexpr int max_digits10 = 0;\n #endif\n-      static const bool is_signed = false;\n-      static const bool is_integer = true;\n-      static const bool is_exact = true;\n-      static const int radix = 2;\n-      static unsigned long epsilon() throw()\n-      { return 0; }\n-      static unsigned long round_error() throw()\n-      { return 0; }\n-\n-      static const int min_exponent = 0;\n-      static const int min_exponent10 = 0;\n-      static const int max_exponent = 0;\n-      static const int max_exponent10 = 0;\n-\n-      static const bool has_infinity = false;\n-      static const bool has_quiet_NaN = false;\n-      static const bool has_signaling_NaN = false;\n-      static const float_denorm_style has_denorm = denorm_absent;\n-      static const bool has_denorm_loss = false;\n-\n-      static unsigned long infinity() throw()\n-      { return static_cast<unsigned long>(0); }\n-      static unsigned long quiet_NaN() throw()\n-      { return static_cast<unsigned long>(0); }\n-      static unsigned long signaling_NaN() throw()\n-      { return static_cast<unsigned long>(0); }\n-      static unsigned long denorm_min() throw()\n-      { return static_cast<unsigned long>(0); }\n-\n-      static const bool is_iec559 = false;\n-      static const bool is_bounded = true;\n-      static const bool is_modulo = true;\n-\n-      static const bool traps = __glibcxx_integral_traps;\n-      static const bool tinyness_before = false;\n-      static const float_round_style round_style = round_toward_zero;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_signed = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;\n+      static _GLIBCXX_USE_CONSTEXPR int radix = 2;\n+\n+      static _GLIBCXX_CONSTEXPR unsigned long \n+      epsilon() throw() { return 0; }\n+\n+      static _GLIBCXX_CONSTEXPR unsigned long \n+      round_error() throw() { return 0; }\n+\n+      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;\n+      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;\n+      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;\n+      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;\n+      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm \n+       = denorm_absent;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;\n+\n+      static _GLIBCXX_CONSTEXPR unsigned long \n+      infinity() throw() { return static_cast<unsigned long>(0); }\n+\n+      static _GLIBCXX_CONSTEXPR unsigned long \n+      quiet_NaN() throw() { return static_cast<unsigned long>(0); }\n+\n+      static _GLIBCXX_CONSTEXPR unsigned long \n+      signaling_NaN() throw() { return static_cast<unsigned long>(0); }\n+\n+      static _GLIBCXX_CONSTEXPR unsigned long \n+      denorm_min() throw() { return static_cast<unsigned long>(0); }\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = true;\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;\n+      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;\n+      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style \n+       = round_toward_zero;\n     };\n \n   /// numeric_limits<long long> specialization.\n   template<>\n     struct numeric_limits<long long>\n     {\n-      static const bool is_specialized = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;\n+\n+      static _GLIBCXX_CONSTEXPR long long \n+      min() throw() { return -__LONG_LONG_MAX__ - 1; }\n+\n+      static _GLIBCXX_CONSTEXPR long long \n+      max() throw() { return __LONG_LONG_MAX__; }\n \n-      static long long min() throw()\n-      { return -__LONG_LONG_MAX__ - 1; }\n-      static long long max() throw()\n-      { return __LONG_LONG_MAX__; }\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      static long long lowest() throw()\n-      { return min(); }\n+      static constexpr long long \n+      lowest() throw() { return min(); }\n #endif\n \n-      static const int digits = __glibcxx_digits (long long);\n-      static const int digits10 = __glibcxx_digits10 (long long);\n+      static _GLIBCXX_USE_CONSTEXPR int digits \n+       = __glibcxx_digits (long long);\n+      static _GLIBCXX_USE_CONSTEXPR int digits10 \n+       = __glibcxx_digits10 (long long);\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      static const int max_digits10 = 0;\n+      static constexpr int max_digits10 = 0;\n #endif\n-      static const bool is_signed = true;\n-      static const bool is_integer = true;\n-      static const bool is_exact = true;\n-      static const int radix = 2;\n-      static long long epsilon() throw()\n-      { return 0; }\n-      static long long round_error() throw()\n-      { return 0; }\n-\n-      static const int min_exponent = 0;\n-      static const int min_exponent10 = 0;\n-      static const int max_exponent = 0;\n-      static const int max_exponent10 = 0;\n-\n-      static const bool has_infinity = false;\n-      static const bool has_quiet_NaN = false;\n-      static const bool has_signaling_NaN = false;\n-      static const float_denorm_style has_denorm = denorm_absent;\n-      static const bool has_denorm_loss = false;\n-\n-      static long long infinity() throw()\n-      { return static_cast<long long>(0); }\n-      static long long quiet_NaN() throw()\n-      { return static_cast<long long>(0); }\n-      static long long signaling_NaN() throw()\n-      { return static_cast<long long>(0); }\n-      static long long denorm_min() throw()\n-      { return static_cast<long long>(0); }\n-\n-      static const bool is_iec559 = false;\n-      static const bool is_bounded = true;\n-      static const bool is_modulo = true;\n-\n-      static const bool traps = __glibcxx_integral_traps;\n-      static const bool tinyness_before = false;\n-      static const float_round_style round_style = round_toward_zero;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_signed = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;\n+      static _GLIBCXX_USE_CONSTEXPR int radix = 2;\n+\n+      static _GLIBCXX_CONSTEXPR long long \n+      epsilon() throw() { return 0; }\n+\n+      static _GLIBCXX_CONSTEXPR long long \n+      round_error() throw() { return 0; }\n+\n+      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;\n+      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;\n+      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;\n+      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;\n+      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm \n+       = denorm_absent;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;\n+\n+      static _GLIBCXX_CONSTEXPR long long \n+      infinity() throw() { return static_cast<long long>(0); }\n+\n+      static _GLIBCXX_CONSTEXPR long long \n+      quiet_NaN() throw() { return static_cast<long long>(0); }\n+\n+      static _GLIBCXX_CONSTEXPR long long \n+      signaling_NaN() throw() { return static_cast<long long>(0); }\n+\n+      static _GLIBCXX_CONSTEXPR long long \n+      denorm_min() throw() { return static_cast<long long>(0); }\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = true;\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;\n+      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;\n+      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style \n+       = round_toward_zero;\n     };\n \n   /// numeric_limits<unsigned long long> specialization.\n   template<>\n     struct numeric_limits<unsigned long long>\n     {\n-      static const bool is_specialized = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;\n+\n+      static _GLIBCXX_CONSTEXPR unsigned long long \n+      min() throw() { return 0; }\n+\n+      static _GLIBCXX_CONSTEXPR unsigned long long \n+      max() throw() { return __LONG_LONG_MAX__ * 2ULL + 1; }\n \n-      static unsigned long long min() throw()\n-      { return 0; }\n-      static unsigned long long max() throw()\n-      { return __LONG_LONG_MAX__ * 2ULL + 1; }\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      static unsigned long long lowest() throw()\n-      { return min(); }\n+      static constexpr unsigned long long \n+      lowest() throw() { return min(); }\n #endif\n \n-      static const int digits = __glibcxx_digits (unsigned long long);\n-      static const int digits10 = __glibcxx_digits10 (unsigned long long);\n+      static _GLIBCXX_USE_CONSTEXPR int digits \n+       = __glibcxx_digits (unsigned long long);\n+      static _GLIBCXX_USE_CONSTEXPR int digits10 \n+       = __glibcxx_digits10 (unsigned long long);\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      static const int max_digits10 = 0;\n+      static constexpr int max_digits10 = 0;\n #endif\n-      static const bool is_signed = false;\n-      static const bool is_integer = true;\n-      static const bool is_exact = true;\n-      static const int radix = 2;\n-      static unsigned long long epsilon() throw()\n-      { return 0; }\n-      static unsigned long long round_error() throw()\n-      { return 0; }\n-\n-      static const int min_exponent = 0;\n-      static const int min_exponent10 = 0;\n-      static const int max_exponent = 0;\n-      static const int max_exponent10 = 0;\n-\n-      static const bool has_infinity = false;\n-      static const bool has_quiet_NaN = false;\n-      static const bool has_signaling_NaN = false;\n-      static const float_denorm_style has_denorm = denorm_absent;\n-      static const bool has_denorm_loss = false;\n-\n-      static unsigned long long infinity() throw()\n-      { return static_cast<unsigned long long>(0); }\n-      static unsigned long long quiet_NaN() throw()\n-      { return static_cast<unsigned long long>(0); }\n-      static unsigned long long signaling_NaN() throw()\n-      { return static_cast<unsigned long long>(0); }\n-      static unsigned long long denorm_min() throw()\n-      { return static_cast<unsigned long long>(0); }\n-\n-      static const bool is_iec559 = false;\n-      static const bool is_bounded = true;\n-      static const bool is_modulo = true;\n-\n-      static const bool traps = __glibcxx_integral_traps;\n-      static const bool tinyness_before = false;\n-      static const float_round_style round_style = round_toward_zero;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_signed = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;\n+      static _GLIBCXX_USE_CONSTEXPR int radix = 2;\n+\n+      static _GLIBCXX_CONSTEXPR unsigned long long \n+      epsilon() throw() { return 0; }\n+\n+      static _GLIBCXX_CONSTEXPR unsigned long long \n+      round_error() throw() { return 0; }\n+\n+      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;\n+      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;\n+      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;\n+      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;\n+      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm \n+       = denorm_absent;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;\n+\n+      static _GLIBCXX_CONSTEXPR unsigned long long \n+      infinity() throw() { return static_cast<unsigned long long>(0); }\n+\n+      static _GLIBCXX_CONSTEXPR unsigned long long \n+      quiet_NaN() throw() { return static_cast<unsigned long long>(0); }\n+\n+      static _GLIBCXX_CONSTEXPR unsigned long long \n+      signaling_NaN() throw() { return static_cast<unsigned long long>(0); }\n+\n+      static _GLIBCXX_CONSTEXPR unsigned long long \n+      denorm_min() throw() { return static_cast<unsigned long long>(0); }\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = true;\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;\n+      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;\n+      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style \n+       = round_toward_zero;\n     };\n \n   /// numeric_limits<float> specialization.\n   template<>\n     struct numeric_limits<float>\n     {\n-      static const bool is_specialized = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;\n+\n+      static _GLIBCXX_CONSTEXPR float \n+      min() throw() { return __FLT_MIN__; }\n+\n+      static _GLIBCXX_CONSTEXPR float \n+      max() throw() { return __FLT_MAX__; }\n \n-      static float min() throw()\n-      { return __FLT_MIN__; }\n-      static float max() throw()\n-      { return __FLT_MAX__; }\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      static float lowest() throw()\n-      { return -__FLT_MAX__; }\n+      static constexpr float \n+      lowest() throw() { return -__FLT_MAX__; }\n #endif\n \n-      static const int digits = __FLT_MANT_DIG__;\n-      static const int digits10 = __FLT_DIG__;\n+      static _GLIBCXX_USE_CONSTEXPR int digits = __FLT_MANT_DIG__;\n+      static _GLIBCXX_USE_CONSTEXPR int digits10 = __FLT_DIG__;\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      static const int max_digits10\n+      static constexpr int max_digits10\n \t = __glibcxx_max_digits10 (__FLT_MANT_DIG__);\n #endif\n-      static const bool is_signed = true;\n-      static const bool is_integer = false;\n-      static const bool is_exact = false;\n-      static const int radix = __FLT_RADIX__;\n-      static float epsilon() throw()\n-      { return __FLT_EPSILON__; }\n-      static float round_error() throw()\n-      { return 0.5F; }\n-\n-      static const int min_exponent = __FLT_MIN_EXP__;\n-      static const int min_exponent10 = __FLT_MIN_10_EXP__;\n-      static const int max_exponent = __FLT_MAX_EXP__;\n-      static const int max_exponent10 = __FLT_MAX_10_EXP__;\n-\n-      static const bool has_infinity = __FLT_HAS_INFINITY__;\n-      static const bool has_quiet_NaN = __FLT_HAS_QUIET_NAN__;\n-      static const bool has_signaling_NaN = has_quiet_NaN;\n-      static const float_denorm_style has_denorm\n+      static _GLIBCXX_USE_CONSTEXPR bool is_signed = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_integer = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_exact = false;\n+      static _GLIBCXX_USE_CONSTEXPR int radix = __FLT_RADIX__;\n+\n+      static _GLIBCXX_CONSTEXPR float \n+      epsilon() throw() { return __FLT_EPSILON__; }\n+\n+      static _GLIBCXX_CONSTEXPR float \n+      round_error() throw() { return 0.5F; }\n+\n+      static _GLIBCXX_USE_CONSTEXPR int min_exponent = __FLT_MIN_EXP__;\n+      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = __FLT_MIN_10_EXP__;\n+      static _GLIBCXX_USE_CONSTEXPR int max_exponent = __FLT_MAX_EXP__;\n+      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = __FLT_MAX_10_EXP__;\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = __FLT_HAS_INFINITY__;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = __FLT_HAS_QUIET_NAN__;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = has_quiet_NaN;\n+      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm\n \t= bool(__FLT_HAS_DENORM__) ? denorm_present : denorm_absent;\n-      static const bool has_denorm_loss = __glibcxx_float_has_denorm_loss;\n-\n-      static float infinity() throw()\n-      { return __builtin_huge_valf (); }\n-      static float quiet_NaN() throw()\n-      { return __builtin_nanf (\"\"); }\n-      static float signaling_NaN() throw()\n-      { return __builtin_nansf (\"\"); }\n-      static float denorm_min() throw()\n-      { return __FLT_DENORM_MIN__; }\n-\n-      static const bool is_iec559\n-\t= has_infinity && has_quiet_NaN && has_denorm == denorm_present;\n-      static const bool is_bounded = true;\n-      static const bool is_modulo = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss \n+       = __glibcxx_float_has_denorm_loss;\n+\n+      static _GLIBCXX_CONSTEXPR float \n+      infinity() throw() { return __builtin_huge_valf (); }\n \n-      static const bool traps = __glibcxx_float_traps;\n-      static const bool tinyness_before = __glibcxx_float_tinyness_before;\n-      static const float_round_style round_style = round_to_nearest;\n+      static _GLIBCXX_CONSTEXPR float \n+      quiet_NaN() throw() { return __builtin_nanf (\"\"); }\n+\n+      static _GLIBCXX_CONSTEXPR float \n+      signaling_NaN() throw() { return __builtin_nansf (\"\"); }\n+\n+      static _GLIBCXX_CONSTEXPR float \n+      denorm_min() throw() { return __FLT_DENORM_MIN__; }\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool is_iec559\n+\t= has_infinity && has_quiet_NaN && has_denorm == denorm_present;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = false;\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_float_traps;\n+      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before \n+       = __glibcxx_float_tinyness_before;\n+      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style \n+       = round_to_nearest;\n     };\n \n #undef __glibcxx_float_has_denorm_loss\n@@ -1273,61 +1471,71 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n   template<>\n     struct numeric_limits<double>\n     {\n-      static const bool is_specialized = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;\n+\n+      static _GLIBCXX_CONSTEXPR double \n+      min() throw()  { return __DBL_MIN__; }\n+\n+      static _GLIBCXX_CONSTEXPR double \n+      max() throw() { return __DBL_MAX__; }\n \n-      static double min() throw()\n-      { return __DBL_MIN__; }\n-      static double max() throw()\n-      { return __DBL_MAX__; }\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      static double lowest() throw()\n-      { return -__DBL_MAX__; }\n+      static constexpr double \n+      lowest() throw() { return -__DBL_MAX__; }\n #endif\n \n-      static const int digits = __DBL_MANT_DIG__;\n-      static const int digits10 = __DBL_DIG__;\n+      static _GLIBCXX_USE_CONSTEXPR int digits = __DBL_MANT_DIG__;\n+      static _GLIBCXX_USE_CONSTEXPR int digits10 = __DBL_DIG__;\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      static const int max_digits10\n+      static constexpr int max_digits10\n \t = __glibcxx_max_digits10 (__DBL_MANT_DIG__);\n #endif\n-      static const bool is_signed = true;\n-      static const bool is_integer = false;\n-      static const bool is_exact = false;\n-      static const int radix = __FLT_RADIX__;\n-      static double epsilon() throw()\n-      { return __DBL_EPSILON__; }\n-      static double round_error() throw()\n-      { return 0.5; }\n-\n-      static const int min_exponent = __DBL_MIN_EXP__;\n-      static const int min_exponent10 = __DBL_MIN_10_EXP__;\n-      static const int max_exponent = __DBL_MAX_EXP__;\n-      static const int max_exponent10 = __DBL_MAX_10_EXP__;\n-\n-      static const bool has_infinity = __DBL_HAS_INFINITY__;\n-      static const bool has_quiet_NaN = __DBL_HAS_QUIET_NAN__;\n-      static const bool has_signaling_NaN = has_quiet_NaN;\n-      static const float_denorm_style has_denorm\n+      static _GLIBCXX_USE_CONSTEXPR bool is_signed = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_integer = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_exact = false;\n+      static _GLIBCXX_USE_CONSTEXPR int radix = __FLT_RADIX__;\n+\n+      static _GLIBCXX_CONSTEXPR double \n+      epsilon() throw() { return __DBL_EPSILON__; }\n+\n+      static _GLIBCXX_CONSTEXPR double \n+      round_error() throw() { return 0.5; }\n+\n+      static _GLIBCXX_USE_CONSTEXPR int min_exponent = __DBL_MIN_EXP__;\n+      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = __DBL_MIN_10_EXP__;\n+      static _GLIBCXX_USE_CONSTEXPR int max_exponent = __DBL_MAX_EXP__;\n+      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = __DBL_MAX_10_EXP__;\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = __DBL_HAS_INFINITY__;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = __DBL_HAS_QUIET_NAN__;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = has_quiet_NaN;\n+      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm\n \t= bool(__DBL_HAS_DENORM__) ? denorm_present : denorm_absent;\n-      static const bool has_denorm_loss = __glibcxx_double_has_denorm_loss;\n-\n-      static double infinity() throw()\n-      { return __builtin_huge_val(); }\n-      static double quiet_NaN() throw()\n-      { return __builtin_nan (\"\"); }\n-      static double signaling_NaN() throw()\n-      { return __builtin_nans (\"\"); }\n-      static double denorm_min() throw()\n-      { return __DBL_DENORM_MIN__; }\n-\n-      static const bool is_iec559\n-\t= has_infinity && has_quiet_NaN && has_denorm == denorm_present;\n-      static const bool is_bounded = true;\n-      static const bool is_modulo = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss \n+        = __glibcxx_double_has_denorm_loss;\n+\n+      static _GLIBCXX_CONSTEXPR double \n+      infinity() throw() { return __builtin_huge_val(); }\n+\n+      static _GLIBCXX_CONSTEXPR double \n+      quiet_NaN() throw() { return __builtin_nan (\"\"); }\n \n-      static const bool traps = __glibcxx_double_traps;\n-      static const bool tinyness_before = __glibcxx_double_tinyness_before;\n-      static const float_round_style round_style = round_to_nearest;\n+      static _GLIBCXX_CONSTEXPR double \n+      signaling_NaN() throw() { return __builtin_nans (\"\"); }\n+\n+      static _GLIBCXX_CONSTEXPR double \n+      denorm_min() throw() { return __DBL_DENORM_MIN__; }\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool is_iec559\n+\t= has_infinity && has_quiet_NaN && has_denorm == denorm_present;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = false;\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_double_traps;\n+      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before \n+       = __glibcxx_double_tinyness_before;\n+      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style \n+       = round_to_nearest;\n     };\n \n #undef __glibcxx_double_has_denorm_loss\n@@ -1338,62 +1546,71 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n   template<>\n     struct numeric_limits<long double>\n     {\n-      static const bool is_specialized = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;\n+\n+      static _GLIBCXX_CONSTEXPR long double \n+      min() throw() { return __LDBL_MIN__; }\n+\n+      static _GLIBCXX_CONSTEXPR long double \n+      max() throw() { return __LDBL_MAX__; }\n \n-      static long double min() throw()\n-      { return __LDBL_MIN__; }\n-      static long double max() throw()\n-      { return __LDBL_MAX__; }\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      static long double lowest() throw()\n-      { return -__LDBL_MAX__; }\n+      static constexpr long double \n+      lowest() throw() { return -__LDBL_MAX__; }\n #endif\n \n-      static const int digits = __LDBL_MANT_DIG__;\n-      static const int digits10 = __LDBL_DIG__;\n+      static _GLIBCXX_USE_CONSTEXPR int digits = __LDBL_MANT_DIG__;\n+      static _GLIBCXX_USE_CONSTEXPR int digits10 = __LDBL_DIG__;\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      static const int max_digits10\n+      static _GLIBCXX_USE_CONSTEXPR int max_digits10\n \t = __glibcxx_max_digits10 (__LDBL_MANT_DIG__);\n #endif\n-      static const bool is_signed = true;\n-      static const bool is_integer = false;\n-      static const bool is_exact = false;\n-      static const int radix = __FLT_RADIX__;\n-      static long double epsilon() throw()\n-      { return __LDBL_EPSILON__; }\n-      static long double round_error() throw()\n-      { return 0.5L; }\n-\n-      static const int min_exponent = __LDBL_MIN_EXP__;\n-      static const int min_exponent10 = __LDBL_MIN_10_EXP__;\n-      static const int max_exponent = __LDBL_MAX_EXP__;\n-      static const int max_exponent10 = __LDBL_MAX_10_EXP__;\n-\n-      static const bool has_infinity = __LDBL_HAS_INFINITY__;\n-      static const bool has_quiet_NaN = __LDBL_HAS_QUIET_NAN__;\n-      static const bool has_signaling_NaN = has_quiet_NaN;\n-      static const float_denorm_style has_denorm\n+      static _GLIBCXX_USE_CONSTEXPR bool is_signed = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_integer = false;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_exact = false;\n+      static _GLIBCXX_USE_CONSTEXPR int radix = __FLT_RADIX__;\n+\n+      static _GLIBCXX_CONSTEXPR long double \n+      epsilon() throw() { return __LDBL_EPSILON__; }\n+\n+      static _GLIBCXX_CONSTEXPR long double \n+      round_error() throw() { return 0.5L; }\n+\n+      static _GLIBCXX_USE_CONSTEXPR int min_exponent = __LDBL_MIN_EXP__;\n+      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = __LDBL_MIN_10_EXP__;\n+      static _GLIBCXX_USE_CONSTEXPR int max_exponent = __LDBL_MAX_EXP__;\n+      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = __LDBL_MAX_10_EXP__;\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = __LDBL_HAS_INFINITY__;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = __LDBL_HAS_QUIET_NAN__;\n+      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = has_quiet_NaN;\n+      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm\n \t= bool(__LDBL_HAS_DENORM__) ? denorm_present : denorm_absent;\n-      static const bool has_denorm_loss\n+      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss\n \t= __glibcxx_long_double_has_denorm_loss;\n \n-      static long double infinity() throw()\n-      { return __builtin_huge_vall (); }\n-      static long double quiet_NaN() throw()\n-      { return __builtin_nanl (\"\"); }\n-      static long double signaling_NaN() throw()\n-      { return __builtin_nansl (\"\"); }\n-      static long double denorm_min() throw()\n-      { return __LDBL_DENORM_MIN__; }\n+      static _GLIBCXX_CONSTEXPR long double \n+      infinity() throw() { return __builtin_huge_vall (); }\n \n-      static const bool is_iec559\n-\t= has_infinity && has_quiet_NaN && has_denorm == denorm_present;\n-      static const bool is_bounded = true;\n-      static const bool is_modulo = false;\n+      static _GLIBCXX_CONSTEXPR long double \n+      quiet_NaN() throw() { return __builtin_nanl (\"\"); }\n \n-      static const bool traps = __glibcxx_long_double_traps;\n-      static const bool tinyness_before = __glibcxx_long_double_tinyness_before;\n-      static const float_round_style round_style = round_to_nearest;\n+      static _GLIBCXX_CONSTEXPR long double \n+      signaling_NaN() throw() { return __builtin_nansl (\"\"); }\n+\n+      static _GLIBCXX_CONSTEXPR long double \n+      denorm_min() throw() { return __LDBL_DENORM_MIN__; }\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool is_iec559\n+\t= has_infinity && has_quiet_NaN && has_denorm == denorm_present;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;\n+      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = false;\n+\n+      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_long_double_traps;\n+      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = \n+\t\t\t\t\t __glibcxx_long_double_tinyness_before;\n+      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style = \n+\t\t\t\t\t\t      round_to_nearest;\n     };\n \n #undef __glibcxx_long_double_has_denorm_loss"}, {"sha": "8a2780247dcbee91752dc87694b619cc6ef888e3", "filename": "libstdc++-v3/include/std/mutex", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -67,16 +67,15 @@ namespace std\n   public:\n     typedef __native_type* \t\t\tnative_handle_type;\n \n+#ifdef __GTHREAD_MUTEX_INIT\n+    constexpr mutex() : _M_mutex(__GTHREAD_MUTEX_INIT) { }\n+#else\n     mutex()\n     {\n       // XXX EAGAIN, ENOMEM, EPERM, EBUSY(may), EINVAL(may)\n-#ifdef __GTHREAD_MUTEX_INIT\n-      __native_type __tmp = __GTHREAD_MUTEX_INIT;\n-      _M_mutex = __tmp;\n-#else\n       __GTHREAD_MUTEX_INIT_FUNCTION(&_M_mutex);\n-#endif\n     }\n+#endif\n \n     mutex(const mutex&) = delete;\n     mutex& operator=(const mutex&) = delete;\n@@ -381,9 +380,9 @@ namespace std\n   /// and manage it.\n   struct adopt_lock_t { };\n \n-  extern const defer_lock_t\tdefer_lock;\n-  extern const try_to_lock_t\ttry_to_lock;\n-  extern const adopt_lock_t\tadopt_lock;\n+  constexpr defer_lock_t\tdefer_lock { };\n+  constexpr try_to_lock_t\ttry_to_lock { };\n+  constexpr adopt_lock_t\tadopt_lock { };\n \n   /// @brief  Scoped lock idiom.\n   // Acquire the mutex here with a constructor call, then release with\n@@ -679,11 +678,7 @@ namespace std\n     __native_type  _M_once;\n \n   public:\n-    once_flag()\n-    {\n-      __native_type __tmp = __GTHREAD_ONCE_INIT;\n-      _M_once = __tmp;\n-    }\n+    constexpr once_flag() : _M_once(__GTHREAD_ONCE_INIT) { }\n \n     once_flag(const once_flag&) = delete;\n     once_flag& operator=(const once_flag&) = delete;"}, {"sha": "3688ea46d7cd824ffc255a8826dc8ea6f4d2d7c9", "filename": "libstdc++-v3/include/std/ratio", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fratio", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fratio", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fratio?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -155,20 +155,20 @@ namespace std\n \t\t    \"out of range\");\n \n       // Note: sign(N) * abs(N) == N\n-      static const intmax_t num =\n+      static constexpr intmax_t num =\n         _Num * __static_sign<_Den>::value / __static_gcd<_Num, _Den>::value;\n \n-      static const intmax_t den =\n+      static constexpr intmax_t den =\n         __static_abs<_Den>::value / __static_gcd<_Num, _Den>::value;\n \n       typedef ratio<num, den> type;\n     };\n \n   template<intmax_t _Num, intmax_t _Den>\n-    const intmax_t ratio<_Num, _Den>::num;\n+    constexpr intmax_t ratio<_Num, _Den>::num;\n \n   template<intmax_t _Num, intmax_t _Den>\n-    const intmax_t ratio<_Num, _Den>::den;\n+    constexpr intmax_t ratio<_Num, _Den>::den;\n \n   /// ratio_add\n   template<typename _R1, typename _R2>"}, {"sha": "d0260deef9ac443d3ebd0921c5c7015aed2b2ec3", "filename": "libstdc++-v3/include/std/tuple", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -225,7 +225,7 @@ namespace std\n       typedef _Tuple_impl<0, _Elements...> _Inherited;\n \n     public:\n-      tuple()\n+      _GLIBCXX_CONSTEXPR tuple()\n       : _Inherited() { }\n \n       explicit"}, {"sha": "a4c20edf7266e785811a9fa21f5ebb7ea2a4d115", "filename": "libstdc++-v3/include/tr1_impl/array", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Farray", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Farray", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Farray?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -132,13 +132,13 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n #endif\n \n       // Capacity.\n-      size_type \n+      _GLIBCXX_CONSTEXPR size_type \n       size() const { return _Nm; }\n \n-      size_type \n+      _GLIBCXX_CONSTEXPR size_type \n       max_size() const { return _Nm; }\n \n-      bool \n+      _GLIBCXX_CONSTEXPR bool \n       empty() const { return size() == 0; }\n \n       // Element access."}, {"sha": "2f6080a19bf1866cc9b5e830417aa63b30fc5321", "filename": "libstdc++-v3/include/tr1_impl/type_traits", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Ftype_traits?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -1,6 +1,6 @@\n // TR1 type_traits -*- C++ -*-\n \n-// Copyright (C) 2007, 2008, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -66,9 +66,13 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n   template<typename _Tp, _Tp __v>\n     struct integral_constant\n     {\n-      static const _Tp                      value = __v;\n+      static _GLIBCXX_USE_CONSTEXPR  _Tp    value = __v;\n       typedef _Tp                           value_type;\n       typedef integral_constant<_Tp, __v>   type;\n+\n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+      constexpr operator value_type() { return value; }\n+#endif\n     };\n   \n   /// typedef for true_type\n@@ -78,7 +82,7 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n   typedef integral_constant<bool, false>    false_type;\n \n   template<typename _Tp, _Tp __v>\n-    const _Tp integral_constant<_Tp, __v>::value;\n+    _GLIBCXX_USE_CONSTEXPR _Tp integral_constant<_Tp, __v>::value;\n \n   /// remove_cv\n   template<typename>"}, {"sha": "08d4d03ac8c535680312054aa62506e0bde76854", "filename": "libstdc++-v3/src/atomic.cc", "status": "modified", "additions": 37, "deletions": 35, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Fsrc%2Fatomic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Fsrc%2Fatomic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fatomic.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -72,47 +72,49 @@ namespace std\n #endif\n       _M_i = false;\n     }\n+\n+  _GLIBCXX_BEGIN_EXTERN_C\n+\n+  bool\n+  atomic_flag_test_and_set_explicit(__atomic_flag_base* __a,\n+\t\t\t\t    memory_order __m) _GLIBCXX_NOTHROW\n+  {\n+    atomic_flag* d = static_cast<atomic_flag*>(__a);\n+    return d->test_and_set(__m);\n   }\n \n-  extern \"C\"\n+  void\n+  atomic_flag_clear_explicit(__atomic_flag_base* __a,\n+\t\t\t     memory_order __m) _GLIBCXX_NOTHROW\n   {\n-    bool\n-    atomic_flag_test_and_set_explicit(__atomic_flag_base* __a,\n-\t\t\t\t      memory_order __m) throw()\n-    {\n-      atomic_flag* d = static_cast<volatile atomic_flag*>(__a);\n-      return d->test_and_set(__m);\n-    }\n+    atomic_flag* d = static_cast<atomic_flag*>(__a);\n+    return d->clear(__m);\n+  }\n \n-    void\n-    atomic_flag_clear_explicit(__atomic_flag_base* __a, \n-\t\t\t       memory_order __m) throw()\n-    {\n-      atomic_flag* d = static_cast<volatile atomic_flag*>(__a);\n-      return d->clear(__m);\n-    }\n+  void\n+  __atomic_flag_wait_explicit(__atomic_flag_base* __a,\n+\t\t\t      memory_order __x) _GLIBCXX_NOTHROW\n+  {\n+    while (atomic_flag_test_and_set_explicit(__a, __x))\n+      { };\n+  }\n \n-    void\n-    __atomic_flag_wait_explicit(__atomic_flag_base* __a,\n-\t\t\t\tmemory_order __x) throw()\n-    {\n-      while (atomic_flag_test_and_set_explicit(__a, __x))\n-\t{ };\n-    }\n+  _GLIBCXX_CONST __atomic_flag_base*\n+  __atomic_flag_for_address(const volatile void* __z) _GLIBCXX_NOTHROW\n+  {\n+    uintptr_t __u = reinterpret_cast<uintptr_t>(__z);\n+    __u += (__u >> 2) + (__u << 4);\n+    __u += (__u >> 7) + (__u << 5);\n+    __u += (__u >> 17) + (__u << 13);\n+    if (sizeof(uintptr_t) > 4)\n+      __u += (__u >> 31);\n+    __u &= ~((~uintptr_t(0)) << LOGSIZE);\n+    return flag_table + __u;\n+  }\n \n-    __atomic_flag_base*\n-    __atomic_flag_for_address(const void* __z) throw()\n-    {\n-      uintptr_t __u = reinterpret_cast<uintptr_t>(__z);\n-      __u += (__u >> 2) + (__u << 4);\n-      __u += (__u >> 7) + (__u << 5);\n-      __u += (__u >> 17) + (__u << 13);\n-      if (sizeof(uintptr_t) > 4)\n-\t__u += (__u >> 31);\n-      __u &= ~((~uintptr_t(0)) << LOGSIZE);\n-      return flag_table + __u;\n-    }\n-  } // extern \"C\"\n+  _GLIBCXX_END_EXTERN_C\n+\n+  } // namespace __atomic0\n } // namespace std\n \n "}, {"sha": "1c9151972af0ff353c57b77836bbbc8f8baac11c", "filename": "libstdc++-v3/src/future.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Fsrc%2Ffuture.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Fsrc%2Ffuture.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Ffuture.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -66,7 +66,8 @@ namespace\n \n namespace std\n {\n-  const error_category* const future_category = &__future_category_instance();\n+  const error_category& future_category()\n+  { return __future_category_instance(); }\n \n   future_error::~future_error() throw() { }\n "}, {"sha": "ac46cf03a60f807dcbfe8ba741736134929f2a39", "filename": "libstdc++-v3/src/limits.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Fsrc%2Flimits.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Fsrc%2Flimits.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flimits.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -34,6 +34,8 @@\n \n _GLIBCXX_BEGIN_NAMESPACE(std)\n \n+#define const _GLIBCXX_USE_CONSTEXPR\n+\n   const bool __numeric_limits_base::is_specialized;\n   const int  __numeric_limits_base::digits;\n   const int  __numeric_limits_base::digits10;\n@@ -510,6 +512,8 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n   const bool numeric_limits<char32_t>::tinyness_before;\n   const float_round_style numeric_limits<char32_t>::round_style;\n \n+#undef const\n+\n _GLIBCXX_END_NAMESPACE\n \n // XXX GLIBCXX_ABI Deprecated"}, {"sha": "2e9124d3d5f9a5e1e9af9e75b0b250282a4bc66f", "filename": "libstdc++-v3/src/mutex.cc", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Fsrc%2Fmutex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Fsrc%2Fmutex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fmutex.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -1,6 +1,6 @@\n // mutex -*- C++ -*-\n \n-// Copyright (C) 2008, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -39,10 +39,6 @@ namespace\n \n namespace std\n {\n-  const defer_lock_t defer_lock = defer_lock_t();\n-  const try_to_lock_t try_to_lock = try_to_lock_t();\n-  const adopt_lock_t adopt_lock = adopt_lock_t();\n-\n #ifdef _GLIBCXX_HAVE_TLS\n   __thread void* __once_callable;\n   __thread void (*__once_call)();\n@@ -94,4 +90,28 @@ namespace std\n   }\n }\n \n+// XXX GLIBCXX_ABI Deprecated\n+// gcc-4.6.0\n+// <mutex> export changes\n+#if defined(_GLIBCXX_SYMVER_GNU) && defined(PIC) \\\n+    && defined(_GLIBCXX_HAVE_AS_SYMVER_DIRECTIVE) \\\n+    && defined(_GLIBCXX_HAVE_SYMVER_SYMBOL_RENAMING_RUNTIME_SUPPORT)\n+\n+namespace __gnu_cxx\n+{\n+  std::defer_lock_t defer_lock;\n+  std::try_to_lock_t try_to_lock;\n+  std::adopt_lock_t adopt_lock;\n+}\n+\n+#define _GLIBCXX_ASM_SYMVER(cur, old, version) \\\n+   asm (\".symver \" #cur \",\" #old \"@@\" #version);\n+\n+_GLIBCXX_ASM_SYMVER(_ZN9__gnu_cxx10adopt_lockE, _ZSt10adopt_lock, GLIBCXX_3.4.11)\n+_GLIBCXX_ASM_SYMVER(_ZN9__gnu_cxx10defer_lockE, _ZSt10defer_lock, GLIBCXX_3.4.11)\n+_GLIBCXX_ASM_SYMVER(_ZN9__gnu_cxx11try_to_lockE, _ZSt11try_to_lock, GLIBCXX_3.4.11)\n+\n+\n+#endif\n+\n #endif // _GLIBCXX_HAS_GTHREADS && _GLIBCXX_USE_C99_STDINT_TR1"}, {"sha": "357373a0a82eac6e7c925130d47f388ae32857d9", "filename": "libstdc++-v3/testsuite/17_intro/headers/c++200x/stdc++.cc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F17_intro%2Fheaders%2Fc%2B%2B200x%2Fstdc%2B%2B.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F17_intro%2Fheaders%2Fc%2B%2B200x%2Fstdc%2B%2B.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F17_intro%2Fheaders%2Fc%2B%2B200x%2Fstdc%2B%2B.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -3,7 +3,7 @@\n // { dg-options \"-std=gnu++0x\" }\n // { dg-do compile }\n \n-// Copyright (C) 2007, 2008, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -44,7 +44,6 @@\n #include <math.h>\n #include <setjmp.h>\n #include <signal.h>\n-#include <stdatomic.h>\n #include <stdarg.h>\n #ifdef _GLIBCXX_HAVE_STDBOOL_H\n #include <stdbool.h>"}, {"sha": "6b492569c3d212bc8d85cce0885c9768f86375ea", "filename": "libstdc++-v3/testsuite/18_support/numeric_limits/cons/default.cc", "status": "renamed", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fnumeric_limits%2Fcons%2Fdefault.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fnumeric_limits%2Fcons%2Fdefault.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fnumeric_limits%2Fcons%2Fdefault.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -1,6 +1,4 @@\n-// { dg-options \"-x c -shared-libgcc -lstdc++\" }\n-\n-// Copyright (C) 2008, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -17,14 +15,12 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-#include <stdatomic.h>\n+#include <limits>\n+#include <testsuite_common_types.h>\n \n int main()\n {\n-  atomic_flag af = ATOMIC_FLAG_INIT;\n-\n-  if (!atomic_flag_test_and_set(&af))\n-    atomic_flag_clear(&af);\n-\n+  __gnu_test::default_constructible test;\n+  __gnu_cxx::typelist::apply_generator(test, __gnu_test::limits_tl());\n   return 0;\n }", "previous_filename": "libstdc++-v3/testsuite/29_atomics/atomic_flag/test_and_set/implicit.c"}, {"sha": "17ee4c79e87b29b4840a4a50618c7bfbc70cc1f7", "filename": "libstdc++-v3/testsuite/18_support/numeric_limits/cons/default_c++0x.cc", "status": "renamed", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fnumeric_limits%2Fcons%2Fdefault_c%2B%2B0x.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fnumeric_limits%2Fcons%2Fdefault_c%2B%2B0x.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fnumeric_limits%2Fcons%2Fdefault_c%2B%2B0x.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -1,6 +1,6 @@\n-// { dg-options \"-x c -shared-libgcc -lstdc++\" }\n+// { dg-options \"-std=gnu++0x\" }\n \n-// Copyright (C) 2008, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -17,14 +17,12 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-#include <stdatomic.h>\n+#include <limits>\n+#include <testsuite_common_types.h>\n \n int main()\n {\n-  atomic_flag af = ATOMIC_FLAG_INIT;\n-\n-  if (!atomic_flag_test_and_set_explicit(&af, memory_order_acquire))\n-    atomic_flag_clear_explicit(&af, memory_order_release);\n-\n+  __gnu_test::default_constructible test;\n+  __gnu_cxx::typelist::apply_generator(test, __gnu_test::limits_tl());\n   return 0;\n }", "previous_filename": "libstdc++-v3/testsuite/29_atomics/atomic_flag/test_and_set/explicit.c"}, {"sha": "d5f3b3f3926e78c0b6a9eb432bf68e2616bd37bf", "filename": "libstdc++-v3/testsuite/18_support/numeric_limits/requirements/constexpr_data.cc", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fnumeric_limits%2Frequirements%2Fconstexpr_data.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fnumeric_limits%2Frequirements%2Fconstexpr_data.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fnumeric_limits%2Frequirements%2Fconstexpr_data.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -0,0 +1,75 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <limits>\n+#include <testsuite_common_types.h>\n+\n+namespace __gnu_test\n+{\n+  struct constexpr_member_data\n+  {\n+    template<typename _Ttesttype>\n+      void\n+      operator()()\n+      {\n+\tstruct _Concept\n+\t{\n+\t  void __constraint()\n+\t  { \n+\t    using std::float_denorm_style;\n+\t    using std::float_round_style;\n+\t    constexpr bool v1(_Ttesttype::is_specialized);\n+\t    constexpr int v2(_Ttesttype::digits);\n+\t    constexpr int v3(_Ttesttype::digits10);\n+\t    constexpr int v4(_Ttesttype::max_digits10);\n+\t    constexpr bool v5(_Ttesttype::is_signed);\n+\t    constexpr bool v6(_Ttesttype::is_integer);\n+\t    constexpr bool v7(_Ttesttype::is_exact);\n+\t    constexpr int v8(_Ttesttype::radix);\n+\t    constexpr int v9(_Ttesttype::min_exponent);\n+\t    constexpr int v10(_Ttesttype::min_exponent10);\n+\t    constexpr int v11(_Ttesttype::max_exponent);\n+\t    constexpr int v12(_Ttesttype::max_exponent10);\n+\t    constexpr bool v13(_Ttesttype::has_infinity);\n+\t    constexpr bool v14(_Ttesttype::has_quiet_NaN);\n+\t    constexpr bool v15(_Ttesttype::has_signaling_NaN);\n+\t    constexpr float_denorm_style v16(_Ttesttype::has_denorm);\n+\t    constexpr bool v17(_Ttesttype::has_denorm_loss);\n+\t    constexpr bool v18(_Ttesttype::is_iec559);\n+\t    constexpr bool v19(_Ttesttype::is_bounded);\n+\t    constexpr bool v20(_Ttesttype::is_modulo);\n+\t    constexpr bool v21(_Ttesttype::traps);\n+\t    constexpr bool v22(_Ttesttype::tinyness_before);\n+\t    constexpr float_round_style v23(_Ttesttype::round_style);\n+\t  }\n+\t};\n+\n+\t_Concept c;\n+\tc.__constraint();\n+      }\n+  };\n+}\n+\n+int main()\n+{\n+  __gnu_test::constexpr_member_data test;\n+  __gnu_cxx::typelist::apply_generator(test, __gnu_test::limits_tl());\n+  return 0;\n+}"}, {"sha": "7c4852b2bbb54ded2aa5f16ec89539b57366ce74", "filename": "libstdc++-v3/testsuite/18_support/numeric_limits/requirements/constexpr_functions.cc", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fnumeric_limits%2Frequirements%2Fconstexpr_functions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fnumeric_limits%2Frequirements%2Fconstexpr_functions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fnumeric_limits%2Frequirements%2Fconstexpr_functions.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -0,0 +1,61 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <limits>\n+#include <testsuite_common_types.h>\n+\n+namespace __gnu_test\n+{\n+  struct constexpr_member_functions\n+  {\n+    template<typename _Ttesttype, typename _Tbasetype>\n+      void\n+      operator()()\n+      {\n+\tstruct _Concept\n+\t{\n+\t  void __constraint()\n+\t  { \n+\t    constexpr _Tbasetype v1(_Ttesttype::min());\n+\t    constexpr _Tbasetype v2(_Ttesttype::max());\n+\t    constexpr _Tbasetype v3(_Ttesttype::lowest());\n+\t    constexpr _Tbasetype v4(_Ttesttype::epsilon());\n+\t    constexpr _Tbasetype v5(_Ttesttype::round_error());\n+\t    constexpr _Tbasetype v6(_Ttesttype::infinity());\n+\t    constexpr _Tbasetype v7(_Ttesttype::quiet_NaN());\n+\t    constexpr _Tbasetype v8(_Ttesttype::signaling_NaN());\n+\t    constexpr _Tbasetype v9(_Ttesttype::denorm_min());\n+\t  }\n+\t};\n+\n+\t_Concept c;\n+\tc.__constraint();\n+      }\n+  };\n+}\n+\n+int main()\n+{\n+  __gnu_test::constexpr_member_functions test;\n+  __gnu_cxx::typelist::apply_generator(test,\n+\t\t\t\t       __gnu_test::limits_tl(),\n+\t\t\t\t       __gnu_test::integral_types::type());\n+  return 0;\n+}"}, {"sha": "897394a57b2464a34cbcd2c48de09db393422e4a", "filename": "libstdc++-v3/testsuite/20_util/default_delete/cons/constexpr.cc", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdefault_delete%2Fcons%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdefault_delete%2Fcons%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdefault_delete%2Fcons%2Fconstexpr.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -0,0 +1,29 @@\n+// { dg-do compile { xfail *-*-* } }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <memory>\n+#include <testsuite_common_types.h>\n+\n+int main()\n+{\n+  __gnu_test::constexpr_default_constructible test;\n+  test.operator()<std::default_delete<int>>(); // { dg-excess-errors \"\" }\n+  return 0;\n+}"}, {"sha": "6f78dbb37e380c1f502d8ae5a9e597abca058ddc", "filename": "libstdc++-v3/testsuite/20_util/duration/cons/constexpr.cc", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fduration%2Fcons%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fduration%2Fcons%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fduration%2Fcons%2Fconstexpr.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -0,0 +1,33 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <chrono>\n+#include <testsuite_common_types.h>\n+\n+int main()\n+{\n+  __gnu_test::constexpr_default_constructible test1;\n+  test1.operator()<std::chrono::seconds>();\n+\n+  __gnu_test::constexpr_single_value_constructible test2;\n+  test2.operator()<std::chrono::seconds, std::chrono::seconds::rep>();\n+  test2.operator()<std::chrono::minutes, std::chrono::hours>();\n+  return 0;\n+}"}, {"sha": "3986659f064354ebec64d9658cd8b03c9e78a02b", "filename": "libstdc++-v3/testsuite/20_util/duration/requirements/constexpr_functions.cc", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fduration%2Frequirements%2Fconstexpr_functions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fduration%2Frequirements%2Fconstexpr_functions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fduration%2Frequirements%2Fconstexpr_functions.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -0,0 +1,58 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <chrono>\n+#include <testsuite_common_types.h>\n+\n+namespace __gnu_test\n+{\n+  struct constexpr_member_functions\n+  {\n+    template<typename _Ttesttype>\n+      void\n+      operator()()\n+      {\n+\tstruct _Concept\n+\t{\n+\t  void __constraint()\n+\t  { \n+\t    constexpr auto v1(_Ttesttype::min());\n+\t    constexpr auto v2(_Ttesttype::max());\n+\t    constexpr auto v3(_Ttesttype::zero());\n+\n+\t    constexpr _Ttesttype obj { };\n+\t    constexpr auto v4 = obj.count();\n+\t    constexpr auto v5 = -obj;\n+\t    constexpr auto v6 = +obj;\n+\t  }\n+\t};\n+\n+\t_Concept c;\n+\tc.__constraint();\n+      }\n+  };\n+}\n+\n+int main()\n+{\n+  __gnu_test::constexpr_member_functions test;\n+  test.operator()<std::chrono::nanoseconds>();\n+  return 0;\n+}"}, {"sha": "7dab6f1297719a6a15b256b1b82d39a9e7211fff", "filename": "libstdc++-v3/testsuite/20_util/duration/requirements/typedefs_neg1.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fduration%2Frequirements%2Ftypedefs_neg1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fduration%2Frequirements%2Ftypedefs_neg1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fduration%2Frequirements%2Ftypedefs_neg1.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -3,7 +3,7 @@\n // { dg-require-cstdint \"\" }\n // 2008-07-31 Chris Fairles <chris.fairles@gmail.com>\n \n-// Copyright (C) 2008, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -31,5 +31,5 @@ void test01()\n   test_type d;\n }\n \n-// { dg-error \"rep cannot be a duration\" \"\" { target *-*-* } 203 }\n+// { dg-error \"rep cannot be a duration\" \"\" { target *-*-* } 210 }\n // { dg-error \"instantiated from here\" \"\" { target *-*-* } 31 }"}, {"sha": "640574991bf1b98fa0e7231134d8168e891efd4d", "filename": "libstdc++-v3/testsuite/20_util/duration/requirements/typedefs_neg2.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fduration%2Frequirements%2Ftypedefs_neg2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fduration%2Frequirements%2Ftypedefs_neg2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fduration%2Frequirements%2Ftypedefs_neg2.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -32,6 +32,6 @@ void test01()\n   test_type d;\n }\n \n-// { dg-error \"must be a specialization of ratio\" \"\" { target *-*-* } 204 }\n+// { dg-error \"must be a specialization of ratio\" \"\" { target *-*-* } 211 }\n // { dg-error \"instantiated from here\" \"\" { target *-*-* } 32 }\n // { dg-excess-errors \"In instantiation of\" }"}, {"sha": "d6163867fb52426bf42a5a0a419d7147c20ef6c4", "filename": "libstdc++-v3/testsuite/20_util/duration/requirements/typedefs_neg3.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fduration%2Frequirements%2Ftypedefs_neg3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fduration%2Frequirements%2Ftypedefs_neg3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fduration%2Frequirements%2Ftypedefs_neg3.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -33,5 +33,5 @@ void test01()\n   test_type d;\n }\n \n-// { dg-error \"period must be positive\" \"\" { target *-*-* } 206 }\n+// { dg-error \"period must be positive\" \"\" { target *-*-* } 213 }\n // { dg-error \"instantiated from here\" \"\" { target *-*-* } 33 }"}, {"sha": "a68aed6d45df05c81dfdddf5b9c059802d61f237", "filename": "libstdc++-v3/testsuite/20_util/duration_cast/constexpr.cc", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fduration_cast%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fduration_cast%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fduration_cast%2Fconstexpr.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -0,0 +1,37 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <chrono>\n+#include <testsuite_common_types.h>\n+\n+int main()\n+{\n+  using namespace std::chrono;\n+\n+  // non-constexpr\n+  minutes mn1(6000);\n+  hours hr1 = duration_cast<hours>(mn1);\n+\n+  // constexpr\n+  constexpr minutes mn2(6000);\n+  constexpr hours hr2 = duration_cast<hours>(mn2);\n+\n+  return 0;\n+}"}, {"sha": "0df6dcf3896a1e7e47b93d8d043f8193923378e2", "filename": "libstdc++-v3/testsuite/20_util/enable_shared_from_this/cons/constexpr.cc", "status": "renamed", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fenable_shared_from_this%2Fcons%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fenable_shared_from_this%2Fcons%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fenable_shared_from_this%2Fcons%2Fconstexpr.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -1,6 +1,7 @@\n-// { dg-options \"-x c -shared-libgcc -lstdc++\" }\n+// { dg-do compile { xfail *-*-* } }\n+// { dg-options \"-std=gnu++0x\" }\n \n-// Copyright (C) 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -17,18 +18,18 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-#include <cassert>\n-#include <stdatomic.h>\n+#include <memory>\n+#include <testsuite_common_types.h>\n \n-// libstdc++/40826\n-// libstdc++/40654\n-int main()\n+struct derived : public std::enable_shared_from_this<int>\n {\n-  atomic_flag f = ATOMIC_FLAG_INIT;\n-\n-  atomic_flag_clear(&f); // set to false\n-  assert( false == atomic_flag_test_and_set(&f) ); // return previous false, set to true\n-  assert( true == atomic_flag_test_and_set(&f) ); // return true\n+  constexpr derived() { }\n+};\n \n+int main()\n+{\n+  __gnu_test::constexpr_default_constructible test;\n+  test.operator()<derived>();  // { dg-excess-errors \"\" }\n+  derived d;\n   return 0;\n }", "previous_filename": "libstdc++-v3/testsuite/29_atomics/atomic_flag/clear/1.c"}, {"sha": "7bf6b71162dc8b73a7637fba77e9e35378702c5e", "filename": "libstdc++-v3/testsuite/20_util/pair/cons/constexpr.cc", "status": "renamed", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2Fcons%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2Fcons%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2Fcons%2Fconstexpr.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -1,7 +1,7 @@\n-// { dg-options \"-x c\" }\n // { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n \n-// Copyright (C) 2008, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -18,19 +18,12 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-#include <stdatomic.h>\n+#include <memory>\n+#include <testsuite_common_types.h>\n \n int main()\n {\n-  atomic_flag f;\n-  atomic_flag* p = &f;\n-  memory_order m = memory_order_relaxed;\n-\n-  // For position only.\n-  atomic_flag_test_and_set(p);\n-  atomic_flag_test_and_set_explicit(p, m);\n-  atomic_flag_clear(p);\n-  atomic_flag_clear_explicit(p, m);\n-\n+  __gnu_test::constexpr_default_constructible test;\n+  test.operator()<std::pair<int, int>>();\n   return 0;\n }", "previous_filename": "libstdc++-v3/testsuite/29_atomics/headers/stdatomic.h/functions.c"}, {"sha": "bc90adce0b007736abf11f11036a5a41a18de51c", "filename": "libstdc++-v3/testsuite/20_util/ratio/requirements/constexpr_data.cc", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fratio%2Frequirements%2Fconstexpr_data.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fratio%2Frequirements%2Fconstexpr_data.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fratio%2Frequirements%2Fconstexpr_data.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -0,0 +1,52 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <ratio>\n+#include <testsuite_common_types.h>\n+\n+namespace __gnu_test\n+{\n+  struct constexpr_member_data\n+  {\n+    template<typename _Ttesttype>\n+      void\n+      operator()()\n+      {\n+\tstruct _Concept\n+\t{\n+\t  void __constraint()\n+\t  {\n+\t    constexpr intmax_t v1(_Ttesttype::num);\n+\t    constexpr intmax_t v2(_Ttesttype::den);\n+\t  }\n+\t};\n+\n+\t_Concept c;\n+\tc.__constraint();\n+      }\n+  };\n+}\n+\n+int main()\n+{\n+  __gnu_test::constexpr_member_data test;\n+  test.operator()<std::ratio<600, 900>>();\n+  return 0;\n+}"}, {"sha": "d040ea4966694920c424c8ff3d353a5c8da593d5", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/cons/constexpr.cc", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Fconstexpr.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -0,0 +1,33 @@\n+// { dg-do compile { xfail *-*-* } }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <memory>\n+#include <testsuite_common_types.h>\n+\n+int main()\n+{\n+  __gnu_test::constexpr_default_constructible test1;\n+  test1.operator()<std::shared_ptr<int>>();  // { dg-excess-errors \"\" }\n+\n+  __gnu_test::constexpr_single_value_constructible test2;\n+  test2.operator()<std::shared_ptr<int>, std::nullptr_t>();  // { dg-excess-errors \"\" }\n+\n+  return 0;\n+}"}, {"sha": "d12d2f164c992867cbfe574aa8daa76692053afc", "filename": "libstdc++-v3/testsuite/20_util/time_point/cons/constexpr.cc", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftime_point%2Fcons%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftime_point%2Fcons%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftime_point%2Fcons%2Fconstexpr.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -0,0 +1,37 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <chrono>\n+#include <testsuite_common_types.h>\n+\n+int main()\n+{\n+  using namespace std::chrono;\n+\n+  __gnu_test::constexpr_default_constructible test1;\n+  test1.operator()<time_point<system_clock>>();\n+\n+  __gnu_test::constexpr_single_value_constructible test2;\n+  test2.operator()<time_point<system_clock>, seconds>();\n+  test2.operator()<time_point<system_clock, seconds>,\n+\t\t   time_point<system_clock, minutes>>();\n+\n+  return 0;\n+}"}, {"sha": "feb77fb17faeac04659d0551ef3aec8f91727f95", "filename": "libstdc++-v3/testsuite/20_util/time_point/requirements/constexpr_functions.cc", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftime_point%2Frequirements%2Fconstexpr_functions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftime_point%2Frequirements%2Fconstexpr_functions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftime_point%2Frequirements%2Fconstexpr_functions.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -0,0 +1,56 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <chrono>\n+#include <testsuite_common_types.h>\n+\n+namespace __gnu_test\n+{\n+  struct constexpr_member_functions\n+  {\n+    template<typename _Ttesttype>\n+      void\n+      operator()()\n+      {\n+\tstruct _Concept\n+\t{\n+\t  void __constraint()\n+\t  {\n+\t    constexpr auto v1(_Ttesttype::min());\n+\t    constexpr auto v2(_Ttesttype::max());\n+\n+\t    constexpr _Ttesttype obj;\n+\t    constexpr auto v3 = obj.time_since_epoch();\n+\t  }\n+\t};\n+\n+\t_Concept c;\n+\tc.__constraint();\n+      }\n+  };\n+}\n+\n+int main()\n+{\n+  using namespace std::chrono;\n+  __gnu_test::constexpr_member_functions test;\n+  test.operator()<time_point<system_clock>>();\n+  return 0;\n+}"}, {"sha": "436a4fbfc6c976daf6a6caeed811507e4a46e78c", "filename": "libstdc++-v3/testsuite/20_util/time_point_cast/constexpr.cc", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftime_point_cast%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftime_point_cast%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftime_point_cast%2Fconstexpr.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -0,0 +1,39 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <chrono>\n+#include <testsuite_common_types.h>\n+\n+int main()\n+{\n+  using namespace std::chrono;\n+  typedef time_point<system_clock, hours> \tto_type;\n+  typedef time_point<system_clock, minutes> \tfrom_type;\n+\n+  // constexpr\n+  constexpr minutes m(6000);\n+  constexpr hours h(19);\n+  constexpr to_type tpm(h); // time_point object with minutes\n+  constexpr from_type tph(m); // time_point object with hours\n+\n+  constexpr auto res(time_point_cast<hours>(tpm));\n+\n+  return 0;\n+}"}, {"sha": "20db7615ba860e5adc8468be9255cab8bc1bd836", "filename": "libstdc++-v3/testsuite/20_util/unique_ptr/cons/constexpr.cc", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fcons%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fcons%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fcons%2Fconstexpr.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -0,0 +1,32 @@\n+// { dg-do compile { xfail *-*-* } }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <memory>\n+#include <testsuite_common_types.h>\n+\n+int main()\n+{\n+  __gnu_test::constexpr_default_constructible test1;\n+  test1.operator()<std::unique_ptr<int>>();  // { dg-excess-errors \"\" }\n+\n+  __gnu_test::constexpr_single_value_constructible test2;\n+  test2.operator()<std::unique_ptr<int>, std::nullptr_t>();  // { dg-excess-errors \"\" }\n+  return 0;\n+}"}, {"sha": "b8cf6d8c08c7aa082eb94cdf641bd7b073923983", "filename": "libstdc++-v3/testsuite/20_util/weak_ptr/comparison/cmp_neg.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fweak_ptr%2Fcomparison%2Fcmp_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fweak_ptr%2Fcomparison%2Fcmp_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fweak_ptr%2Fcomparison%2Fcmp_neg.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -42,10 +42,10 @@ main()\n }\n \n // { dg-warning \"note\" \"\" { target *-*-* } 347 }\n-// { dg-warning \"note\" \"\" { target *-*-* } 466 }\n+// { dg-warning \"note\" \"\" { target *-*-* } 465 }\n // { dg-warning \"note\" \"\" { target *-*-* } 883 }\n // { dg-warning \"note\" \"\" { target *-*-* } 580 }\n // { dg-warning \"note\" \"\" { target *-*-* } 1027 }\n // { dg-warning \"note\" \"\" { target *-*-* } 340 }\n // { dg-warning \"note\" \"\" { target *-*-* } 290 }\n-// { dg-warning \"note\" \"\" { target *-*-* } 200 }\n+// { dg-warning \"note\" \"\" { target *-*-* } 201 }"}, {"sha": "3b43769bff31befffc797e253458ab72d67d2e8b", "filename": "libstdc++-v3/testsuite/20_util/weak_ptr/cons/constexpr.cc", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fweak_ptr%2Fcons%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fweak_ptr%2Fcons%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fweak_ptr%2Fcons%2Fconstexpr.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -0,0 +1,32 @@\n+// { dg-do compile { xfail *-*-* } }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <memory>\n+#include <testsuite_common_types.h>\n+\n+int main()\n+{\n+  __gnu_test::constexpr_default_constructible test;\n+  test.operator()<std::weak_ptr<int>>();  // { dg-excess-errors \"\" }\n+  //  test.operator()<std::__weak_ptr<int>>();\n+  //  test.operator()<std::__weak_count<__gnu_cxx::__default_lock_policy>>();\n+  // test.operator()<std::_Sp_counted_base<__gnu_cxx::__default_lock_policy>>();\n+  return 0;\n+}"}, {"sha": "ecb9a3e243ab86d21376499447a24c9b6f5db6d5", "filename": "libstdc++-v3/testsuite/21_strings/char_traits/requirements/constexpr_functions.cc", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fchar_traits%2Frequirements%2Fconstexpr_functions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fchar_traits%2Frequirements%2Fconstexpr_functions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fchar_traits%2Frequirements%2Fconstexpr_functions.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -0,0 +1,67 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <string>\n+#include <testsuite_common_types.h>\n+\n+namespace __gnu_test\n+{\n+  struct constexpr_member_functions\n+  {\n+    template<typename _Ttesttype>\n+      void\n+      operator()()\n+      {\n+\tstruct _Concept\n+\t{\n+\t  void __constraint()\n+\t  { \n+\t    typedef typename _Ttesttype::char_type char_type;\n+\t    typedef typename _Ttesttype::int_type int_type;\n+\t    const char_type c1(0);\n+\t    const char_type c2 = c1;\n+\t    const int_type i(0);\n+\t    constexpr auto v1(_Ttesttype::eq(c1, c2));\n+\t    constexpr auto v2(_Ttesttype::lt(c1, c2));\n+\t    constexpr auto v3(_Ttesttype::to_char_type(i));\n+\t    constexpr auto v4(_Ttesttype::to_int_type(c1));\n+\t    constexpr auto v5(_Ttesttype::eq_int_type(i, i));\n+\t    constexpr auto v6(_Ttesttype::eof());\n+\t    constexpr auto v7(_Ttesttype::not_eof(i));\n+\t  }\n+\t};\n+\n+\t_Concept c;\n+\tc.__constraint();\n+      }\n+  };\n+}\n+\n+int main()\n+{\n+  __gnu_test::constexpr_member_functions test;\n+  test.operator()<std::char_traits<char>>();\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+  test.operator()<std::char_traits<wchar_t>>();\n+#endif\n+  test.operator()<std::char_traits<char16_t>>();\n+  test.operator()<std::char_traits<char32_t>>();\n+  return 0;\n+}"}, {"sha": "494a8dedd6fc07fd6e8369393533061bed1a410d", "filename": "libstdc++-v3/testsuite/23_containers/array/requirements/constexpr_functions.cc", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Farray%2Frequirements%2Fconstexpr_functions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Farray%2Frequirements%2Fconstexpr_functions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Farray%2Frequirements%2Fconstexpr_functions.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -0,0 +1,54 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <array>\n+#include <testsuite_common_types.h>\n+\n+namespace __gnu_test\n+{\n+  struct constexpr_member_functions\n+  {\n+    template<typename _Ttesttype>\n+      void\n+      operator()()\n+      {\n+\tstruct _Concept\n+\t{\n+\t  void __constraint()\n+\t  { \n+\t    constexpr _Ttesttype a = { };\n+\t    constexpr auto v1 = a.size();\n+\t    constexpr auto v2 = a.max_size();\n+\t    constexpr auto v3 = a.empty();\n+\t  }\n+\t};\n+\n+\t_Concept c;\n+\tc.__constraint();\n+      }\n+  };\n+}\n+\n+int main()\n+{\n+  __gnu_test::constexpr_member_functions test;\n+  test.operator()<std::array<long, 60>>();\n+  return 0;\n+}"}, {"sha": "aea50301375ad5bc0362e9be450bbca0865626d8", "filename": "libstdc++-v3/testsuite/23_containers/bitset/cons/constexpr.cc", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fbitset%2Fcons%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fbitset%2Fcons%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fbitset%2Fcons%2Fconstexpr.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -0,0 +1,37 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <bitset>\n+#include <testsuite_common_types.h>\n+\n+int main()\n+{\n+  __gnu_test::constexpr_default_constructible test1;\n+  test1.operator()<std::bitset<0>>();\n+  test1.operator()<std::bitset<1>>();\n+  test1.operator()<std::bitset<256>>();\n+\n+  __gnu_test::constexpr_single_value_constructible test2;\n+  test2.operator()<std::bitset<0>, unsigned long long>();\n+  test2.operator()<std::bitset<1>, unsigned long long>();\n+  test2.operator()<std::bitset<256>, unsigned long long>();\n+\n+  return 0;\n+}"}, {"sha": "ac9a07f379c070da3f54ac126f4211fd73aca018", "filename": "libstdc++-v3/testsuite/23_containers/bitset/requirements/constexpr_functions.cc", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fbitset%2Frequirements%2Fconstexpr_functions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fbitset%2Frequirements%2Fconstexpr_functions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fbitset%2Frequirements%2Fconstexpr_functions.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -0,0 +1,55 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <bitset>\n+#include <testsuite_common_types.h>\n+\n+namespace __gnu_test\n+{\n+  struct constexpr_member_functions\n+  {\n+    template<typename _Ttesttype>\n+      void\n+      operator()()\n+      {\n+\tstruct _Concept\n+\t{\n+\t  void __constraint()\n+\t  { \n+            constexpr _Ttesttype obj;\n+            constexpr auto v1 = obj.size();\n+\t    //\t    constexpr auto v2 = obj[4];\n+\t  }\n+\t};\n+\n+\t_Concept c;\n+\tc.__constraint();\n+      }\n+  };\n+}\n+\n+int main()\n+{\n+  __gnu_test::constexpr_member_functions test;\n+  test.operator()<std::bitset<0>>();\n+  test.operator()<std::bitset<1>>();\n+  test.operator()<std::bitset<64>>();\n+  return 0;\n+}"}, {"sha": "20b419973035f9c1230d4c7ff8e0ed5a06ec7795", "filename": "libstdc++-v3/testsuite/24_iterators/istream_iterator/cons/constexpr.cc", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fistream_iterator%2Fcons%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fistream_iterator%2Fcons%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fistream_iterator%2Fcons%2Fconstexpr.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -0,0 +1,29 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <iterator>\n+#include <testsuite_common_types.h>\n+\n+int main()\n+{\n+  __gnu_test::constexpr_default_constructible test;\n+  test.operator()<std::istream_iterator<char>>();\n+  return 0;\n+}"}, {"sha": "0a6980ec1f008132e823b840c2d6852d2457be8a", "filename": "libstdc++-v3/testsuite/24_iterators/istreambuf_iterator/cons/constexpr.cc", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fistreambuf_iterator%2Fcons%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fistreambuf_iterator%2Fcons%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fistreambuf_iterator%2Fcons%2Fconstexpr.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -0,0 +1,29 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <iterator>\n+#include <testsuite_common_types.h>\n+\n+int main()\n+{\n+  __gnu_test::constexpr_default_constructible test;\n+  test.operator()<std::istreambuf_iterator<char, std::char_traits<char>>>();\n+  return 0;\n+}"}, {"sha": "13d3c81685f1a5311512e088fa2eba8ffe939157", "filename": "libstdc++-v3/testsuite/26_numerics/complex/cons/constexpr.cc", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fcomplex%2Fcons%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fcomplex%2Fcons%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fcomplex%2Fcons%2Fconstexpr.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -0,0 +1,37 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <complex>\n+#include <testsuite_common_types.h>\n+\n+int main()\n+{\n+  __gnu_test::constexpr_default_constructible test1;\n+  test1.operator()<std::complex<float>>();\n+  test1.operator()<std::complex<double>>();\n+  test1.operator()<std::complex<long double>>();\n+\n+  __gnu_test::constexpr_single_value_constructible test2;\n+  test2.operator()<std::complex<float>, float>();\n+  test2.operator()<std::complex<double>, double>();\n+  test2.operator()<std::complex<long double>, long double>();\n+\n+  return 0;\n+}"}, {"sha": "74f7bf5515fa9ce607fb4a9d39bf8cc8fb84f682", "filename": "libstdc++-v3/testsuite/26_numerics/complex/requirements/constexpr_functions.cc", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fcomplex%2Frequirements%2Fconstexpr_functions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fcomplex%2Frequirements%2Fconstexpr_functions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fcomplex%2Frequirements%2Fconstexpr_functions.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -0,0 +1,57 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <complex>\n+#include <testsuite_common_types.h>\n+\n+namespace __gnu_test\n+{\n+  struct constexpr_member_functions\n+  {\n+    template<typename _Ttesttype>\n+      void\n+      operator()()\n+      {\n+\tstruct _Concept\n+\t{\n+\t  void __constraint()\n+\t  { \n+\t    typedef typename _Ttesttype::_ComplexT _ComplexT;\n+\t    const _ComplexT cc = { 1.1 };\n+\t    constexpr _Ttesttype a(cc);\n+\t    constexpr auto v1 = a.real();\n+\t    constexpr auto v2 = a.imag();\n+\t  }\n+\t};\n+\n+\t_Concept c;\n+\tc.__constraint();\n+      }\n+  };\n+}\n+\n+int main()\n+{\n+  __gnu_test::constexpr_member_functions test;\n+  test.operator()<std::complex<float>>();\n+  test.operator()<std::complex<double>>();\n+  test.operator()<std::complex<long double>>();\n+  return 0;\n+}"}, {"sha": "7f82bfee55f770c021fa2f335fe600d33698680b", "filename": "libstdc++-v3/testsuite/26_numerics/random/discard_block_engine/requirements/constexpr_data.cc", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Fdiscard_block_engine%2Frequirements%2Fconstexpr_data.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Fdiscard_block_engine%2Frequirements%2Fconstexpr_data.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Fdiscard_block_engine%2Frequirements%2Fconstexpr_data.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -0,0 +1,57 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <random>\n+#include <testsuite_common_types.h>\n+\n+namespace __gnu_test\n+{\n+  struct constexpr_member_data\n+  {\n+    template<typename _Ttesttype>\n+      void\n+      operator()()\n+      {\n+\tstruct _Concept\n+\t{\n+\t  void __constraint()\n+\t  {\n+\t    constexpr auto v1(_Ttesttype::block_size);\n+\t    constexpr auto v2(_Ttesttype::used_block);\n+\t  }\n+\t};\n+\n+\t_Concept c;\n+\tc.__constraint();\n+      }\n+  };\n+}\n+\n+int main()\n+{\n+  __gnu_test::constexpr_member_data test;\n+  typedef std::discard_block_engine\n+    <\n+    std::subtract_with_carry_engine<unsigned long, 24, 10, 24>,\n+    389, 24\n+    > type;\n+  test.operator()<type>();\n+  return 0;\n+}"}, {"sha": "faec5bfad2fb658f3c31b38b2353ea1f5fe194d0", "filename": "libstdc++-v3/testsuite/26_numerics/random/discard_block_engine/requirements/constexpr_functions.cc", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Fdiscard_block_engine%2Frequirements%2Fconstexpr_functions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Fdiscard_block_engine%2Frequirements%2Fconstexpr_functions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Fdiscard_block_engine%2Frequirements%2Fconstexpr_functions.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -0,0 +1,57 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <random>\n+#include <testsuite_common_types.h>\n+\n+namespace __gnu_test\n+{\n+  struct constexpr_member_functions\n+  {\n+    template<typename _Ttesttype>\n+      void\n+      operator()()\n+      {\n+\tstruct _Concept\n+\t{\n+\t  void __constraint()\n+\t  { \n+\t    constexpr auto v1(_Ttesttype::min());\n+\t    constexpr auto v2(_Ttesttype::max());\n+\t  }\n+\t};\n+\n+\t_Concept c;\n+\tc.__constraint();\n+      }\n+  };\n+}\n+\n+int main()\n+{\n+  __gnu_test::constexpr_member_functions test;\n+  typedef std::discard_block_engine\n+    <\n+    std::subtract_with_carry_engine<unsigned long, 24, 10, 24>,\n+    389, 24\n+    > type;\n+  test.operator()<type>();\n+  return 0;\n+}"}, {"sha": "2b84ec855df2429459efb66f277a0af1b9930c2e", "filename": "libstdc++-v3/testsuite/26_numerics/random/independent_bits_engine/requirements/constexpr_functions.cc", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Findependent_bits_engine%2Frequirements%2Fconstexpr_functions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Findependent_bits_engine%2Frequirements%2Fconstexpr_functions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Findependent_bits_engine%2Frequirements%2Fconstexpr_functions.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -0,0 +1,60 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <random>\n+#include <testsuite_common_types.h>\n+\n+namespace __gnu_test\n+{\n+  struct constexpr_member_functions\n+  {\n+    template<typename _Ttesttype>\n+      void\n+      operator()()\n+      {\n+\tstruct _Concept\n+\t{\n+\t  void __constraint()\n+\t  { \n+\t    constexpr auto v1(_Ttesttype::min());\n+\t    constexpr auto v2(_Ttesttype::max());\n+\t  }\n+\t};\n+\n+\t_Concept c;\n+\tc.__constraint();\n+      }\n+  };\n+}\n+\n+int main()\n+{\n+  __gnu_test::constexpr_member_functions test;\n+  typedef std::independent_bits_engine\n+    <\n+      std::subtract_with_carry_engine\n+        <\n+          uint_fast64_t, 48, 5, 12\n+        >,\n+      48, uint_fast64_t\n+    > type;\n+  test.operator()<type>();\n+  return 0;\n+}"}, {"sha": "e7e9fc053110d22f69947e4c941f3bd0ac4924af", "filename": "libstdc++-v3/testsuite/26_numerics/random/linear_congruential_engine/requirements/constexpr_data.cc", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Flinear_congruential_engine%2Frequirements%2Fconstexpr_data.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Flinear_congruential_engine%2Frequirements%2Fconstexpr_data.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Flinear_congruential_engine%2Frequirements%2Fconstexpr_data.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -0,0 +1,55 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <random>\n+#include <testsuite_common_types.h>\n+\n+namespace __gnu_test\n+{\n+  struct constexpr_member_data\n+  {\n+    template<typename _Ttesttype>\n+      void\n+      operator()()\n+      {\n+\tstruct _Concept\n+\t{\n+\t  void __constraint()\n+\t  {\n+\t    constexpr auto v1(_Ttesttype::multiplier);\n+\t    constexpr auto v2(_Ttesttype::increment);\n+\t    constexpr auto v3(_Ttesttype::modulus);\n+\t    constexpr auto v4(_Ttesttype::default_seed);\n+\t  }\n+\t};\n+\n+\t_Concept c;\n+\tc.__constraint();\n+      }\n+  };\n+}\n+\n+int main()\n+{\n+  __gnu_test::constexpr_member_data test;\n+  typedef std::linear_congruential_engine<unsigned int, 41, 0, 2147483647> type;\n+  test.operator()<type>();\n+  return 0;\n+}"}, {"sha": "cff1a67caf18398f8c2053b4c2031fd52f9ca282", "filename": "libstdc++-v3/testsuite/26_numerics/random/linear_congruential_engine/requirements/constexpr_functions.cc", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Flinear_congruential_engine%2Frequirements%2Fconstexpr_functions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Flinear_congruential_engine%2Frequirements%2Fconstexpr_functions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Flinear_congruential_engine%2Frequirements%2Fconstexpr_functions.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -0,0 +1,53 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <random>\n+#include <testsuite_common_types.h>\n+\n+namespace __gnu_test\n+{\n+  struct constexpr_member_functions\n+  {\n+    template<typename _Ttesttype>\n+      void\n+      operator()()\n+      {\n+\tstruct _Concept\n+\t{\n+\t  void __constraint()\n+\t  { \n+\t    constexpr auto v1(_Ttesttype::min());\n+\t    constexpr auto v2(_Ttesttype::max());\n+\t  }\n+\t};\n+\n+\t_Concept c;\n+\tc.__constraint();\n+      }\n+  };\n+}\n+\n+int main()\n+{\n+  __gnu_test::constexpr_member_functions test;\n+  typedef std::linear_congruential_engine<unsigned int, 41, 0, 2147483647> type;\n+  test.operator()<type>();\n+  return 0;\n+}"}, {"sha": "17c89e13bf9063eadb6c9b47593627cb02b1c2a3", "filename": "libstdc++-v3/testsuite/26_numerics/random/mersenne_twister_engine/requirements/constexpr_data.cc", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Fmersenne_twister_engine%2Frequirements%2Fconstexpr_data.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Fmersenne_twister_engine%2Frequirements%2Fconstexpr_data.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Fmersenne_twister_engine%2Frequirements%2Fconstexpr_data.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -0,0 +1,65 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <random>\n+#include <testsuite_common_types.h>\n+\n+namespace __gnu_test\n+{\n+  struct constexpr_member_data\n+  {\n+    template<typename _Ttesttype>\n+      void\n+      operator()()\n+      {\n+\tstruct _Concept\n+\t{\n+\t  void __constraint()\n+\t  {\n+\t    constexpr auto v1(_Ttesttype::word_size);\n+\t    constexpr auto v2(_Ttesttype::state_size);\n+\t    constexpr auto v3(_Ttesttype::shift_size);\n+\t    constexpr auto v4(_Ttesttype::mask_bits);\n+\t    constexpr auto v5(_Ttesttype::xor_mask);\n+\t    constexpr auto v6(_Ttesttype::tempering_u);\n+\t    constexpr auto v7(_Ttesttype::tempering_d);\n+\t    constexpr auto v8(_Ttesttype::tempering_s);\n+\t    constexpr auto v9(_Ttesttype::tempering_b);\n+\t    constexpr auto v10(_Ttesttype::tempering_t);\n+\t    constexpr auto v11(_Ttesttype::tempering_c);\n+\t    constexpr auto v12(_Ttesttype::tempering_l);\n+\t    constexpr auto v13(_Ttesttype::initialization_multiplier);\n+\t    constexpr auto v14(_Ttesttype::default_seed);\n+\t  }\n+\t};\n+\n+\t_Concept c;\n+\tc.__constraint();\n+      }\n+  };\n+}\n+\n+int main()\n+{\n+  __gnu_test::constexpr_member_data test;\n+  typedef std::mt19937 type;\n+  test.operator()<type>();\n+  return 0;\n+}"}, {"sha": "dd350e7fbd8ef7df8f05cebfa813b9c8d77831a7", "filename": "libstdc++-v3/testsuite/26_numerics/random/mersenne_twister_engine/requirements/constexpr_functions.cc", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Fmersenne_twister_engine%2Frequirements%2Fconstexpr_functions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Fmersenne_twister_engine%2Frequirements%2Fconstexpr_functions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Fmersenne_twister_engine%2Frequirements%2Fconstexpr_functions.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -0,0 +1,53 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <random>\n+#include <testsuite_common_types.h>\n+\n+namespace __gnu_test\n+{\n+  struct constexpr_member_functions\n+  {\n+    template<typename _Ttesttype>\n+      void\n+      operator()()\n+      {\n+\tstruct _Concept\n+\t{\n+\t  void __constraint()\n+\t  { \n+\t    constexpr auto v1(_Ttesttype::min());\n+\t    constexpr auto v2(_Ttesttype::max());\n+\t  }\n+\t};\n+\n+\t_Concept c;\n+\tc.__constraint();\n+      }\n+  };\n+}\n+\n+int main()\n+{\n+  __gnu_test::constexpr_member_functions test;\n+  typedef std::mt19937 type;\n+  test.operator()<type>();\n+  return 0;\n+}"}, {"sha": "8a158fb9a42e521a86d059bab9df6a57ba5fd355", "filename": "libstdc++-v3/testsuite/26_numerics/random/shuffle_order_engine/requirements/constexpr_data.cc", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Fshuffle_order_engine%2Frequirements%2Fconstexpr_data.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Fshuffle_order_engine%2Frequirements%2Fconstexpr_data.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Fshuffle_order_engine%2Frequirements%2Fconstexpr_data.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -0,0 +1,59 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <random>\n+#include <testsuite_common_types.h>\n+\n+namespace __gnu_test\n+{\n+  struct constexpr_member_data\n+  {\n+    template<typename _Ttesttype>\n+      void\n+      operator()()\n+      {\n+\tstruct _Concept\n+\t{\n+\t  void __constraint()\n+\t  {\n+\t    constexpr auto v1(_Ttesttype::table_size);\n+\t  }\n+\t};\n+\n+\t_Concept c;\n+\tc.__constraint();\n+      }\n+  };\n+}\n+\n+int main()\n+{\n+  __gnu_test::constexpr_member_data test;\n+  typedef std::shuffle_order_engine\n+    <\n+      std::linear_congruential_engine\n+        <\n+          uint_fast32_t,16807UL, 0UL, 2147483647UL\n+        >,\n+      256\n+    > type;\n+  test.operator()<type>();\n+  return 0;\n+}"}, {"sha": "65e2e5612d5f7fcb264349e436dae6900b96956a", "filename": "libstdc++-v3/testsuite/26_numerics/random/shuffle_order_engine/requirements/constexpr_functions.cc", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Fshuffle_order_engine%2Frequirements%2Fconstexpr_functions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Fshuffle_order_engine%2Frequirements%2Fconstexpr_functions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Fshuffle_order_engine%2Frequirements%2Fconstexpr_functions.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -0,0 +1,60 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <random>\n+#include <testsuite_common_types.h>\n+\n+namespace __gnu_test\n+{\n+  struct constexpr_member_functions\n+  {\n+    template<typename _Ttesttype>\n+      void\n+      operator()()\n+      {\n+\tstruct _Concept\n+\t{\n+\t  void __constraint()\n+\t  { \n+\t    constexpr auto v1(_Ttesttype::min());\n+\t    constexpr auto v2(_Ttesttype::max());\n+\t  }\n+\t};\n+\n+\t_Concept c;\n+\tc.__constraint();\n+      }\n+  };\n+}\n+\n+int main()\n+{\n+  __gnu_test::constexpr_member_functions test;\n+  typedef std::shuffle_order_engine\n+    <\n+      std::linear_congruential_engine\n+        <\n+          uint_fast32_t,16807UL, 0UL, 2147483647UL\n+        >,\n+      256\n+    > type;\n+  test.operator()<type>();\n+  return 0;\n+}"}, {"sha": "0b51727b1cd524a5fc1fe98fab9801b91384853b", "filename": "libstdc++-v3/testsuite/26_numerics/random/subtract_with_carry_engine/requirements/constexpr_data.cc", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Fsubtract_with_carry_engine%2Frequirements%2Fconstexpr_data.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Fsubtract_with_carry_engine%2Frequirements%2Fconstexpr_data.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Fsubtract_with_carry_engine%2Frequirements%2Fconstexpr_data.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -0,0 +1,55 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <random>\n+#include <testsuite_common_types.h>\n+\n+namespace __gnu_test\n+{\n+  struct constexpr_member_data\n+  {\n+    template<typename _Ttesttype>\n+      void\n+      operator()()\n+      {\n+\tstruct _Concept\n+\t{\n+\t  void __constraint()\n+\t  {\n+\t    constexpr auto v1(_Ttesttype::word_size);\n+\t    constexpr auto v2(_Ttesttype::short_lag);\n+\t    constexpr auto v3(_Ttesttype::long_lag);\n+\t    constexpr auto v4(_Ttesttype::default_seed);\n+\t  }\n+\t};\n+\n+\t_Concept c;\n+\tc.__constraint();\n+      }\n+  };\n+}\n+\n+int main()\n+{\n+  __gnu_test::constexpr_member_data test;\n+  typedef std::ranlux24_base type;\n+  test.operator()<type>();\n+  return 0;\n+}"}, {"sha": "b05710a9e67aaaa5ed7e4cec943a47dcc7500385", "filename": "libstdc++-v3/testsuite/26_numerics/random/subtract_with_carry_engine/requirements/constexpr_functions.cc", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Fsubtract_with_carry_engine%2Frequirements%2Fconstexpr_functions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Fsubtract_with_carry_engine%2Frequirements%2Fconstexpr_functions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Fsubtract_with_carry_engine%2Frequirements%2Fconstexpr_functions.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -0,0 +1,53 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <random>\n+#include <testsuite_common_types.h>\n+\n+namespace __gnu_test\n+{\n+  struct constexpr_member_functions\n+  {\n+    template<typename _Ttesttype>\n+      void\n+      operator()()\n+      {\n+\tstruct _Concept\n+\t{\n+\t  void __constraint()\n+\t  { \n+\t    constexpr auto v1(_Ttesttype::min());\n+\t    constexpr auto v2(_Ttesttype::max());\n+\t  }\n+\t};\n+\n+\t_Concept c;\n+\tc.__constraint();\n+      }\n+  };\n+}\n+\n+int main()\n+{\n+  __gnu_test::constexpr_member_functions test;\n+  typedef std::ranlux24_base type;\n+  test.operator()<type>();\n+  return 0;\n+}"}, {"sha": "8e97d329942bd24051a1ff55fc4184b5a54b4e4c", "filename": "libstdc++-v3/testsuite/27_io/ios_base/cons/assign_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fios_base%2Fcons%2Fassign_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fios_base%2Fcons%2Fassign_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fios_base%2Fcons%2Fassign_neg.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -34,5 +34,5 @@ void test01()\n }\n // { dg-error \"synthesized\" \"\" { target *-*-* } 33 } \n // { dg-error \"within this context\" \"\" { target *-*-* } 26 } \n-// { dg-error \"is private\" \"\" { target *-*-* } 788 }\n+// { dg-error \"is private\" \"\" { target *-*-* } 789 }\n // { dg-error \"operator=\" \"\" { target *-*-* } 0 } "}, {"sha": "6e527cdc2627929b14551e08efa77374d47a47d4", "filename": "libstdc++-v3/testsuite/27_io/ios_base/cons/copy_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fios_base%2Fcons%2Fcopy_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fios_base%2Fcons%2Fcopy_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fios_base%2Fcons%2Fcopy_neg.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -34,5 +34,5 @@ void test02()\n }\n // { dg-error \"within this context\" \"\" { target *-*-* } 26 }\n // { dg-error \"synthesized\" \"\" { target *-*-* } 33 } \n-// { dg-error \"is private\" \"\" { target *-*-* } 785 } \n+// { dg-error \"is private\" \"\" { target *-*-* } 786 } \n // { dg-error \"copy constructor\" \"\" { target *-*-* } 0 } "}, {"sha": "349f7f9f2d0e0d4fb3204e5437c1d1617a3ca395", "filename": "libstdc++-v3/testsuite/27_io/ios_base/types/fmtflags/constexpr_operators.cc", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fios_base%2Ftypes%2Ffmtflags%2Fconstexpr_operators.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fios_base%2Ftypes%2Ffmtflags%2Fconstexpr_operators.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fios_base%2Ftypes%2Ffmtflags%2Fconstexpr_operators.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -0,0 +1,28 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <ios>\n+#include <testsuite_common_types.h>\n+\n+int main()\n+{\n+  __gnu_test::constexpr_bitwise_operators<std::ios_base::fmtflags>();\n+  return 0;\n+}"}, {"sha": "fd3ce10553bc970cc4b0e20a8701eea099ae34f7", "filename": "libstdc++-v3/testsuite/27_io/ios_base/types/iostate/constexpr_operators.cc", "status": "renamed", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fios_base%2Ftypes%2Fiostate%2Fconstexpr_operators.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fios_base%2Ftypes%2Fiostate%2Fconstexpr_operators.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fios_base%2Ftypes%2Fiostate%2Fconstexpr_operators.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -1,7 +1,7 @@\n-// { dg-options \"-x c -D_GLIBCXX_DEBUG\" }\n // { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n \n-// Copyright (C) 2008, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -18,5 +18,11 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// libstdc++/36130\n-#include <stdatomic.h>\n+#include <ios>\n+#include <testsuite_common_types.h>\n+\n+int main()\n+{\n+  __gnu_test::constexpr_bitwise_operators<std::ios_base::iostate>();\n+  return 0;\n+}", "previous_filename": "libstdc++-v3/testsuite/29_atomics/headers/stdatomic.h/debug_mode.c"}, {"sha": "66041b87e1f194b6c5d454b58b08310676425640", "filename": "libstdc++-v3/testsuite/27_io/ios_base/types/openmode/constexpr_operators.cc", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fios_base%2Ftypes%2Fopenmode%2Fconstexpr_operators.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fios_base%2Ftypes%2Fopenmode%2Fconstexpr_operators.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fios_base%2Ftypes%2Fopenmode%2Fconstexpr_operators.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -0,0 +1,28 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <ios>\n+#include <testsuite_common_types.h>\n+\n+int main()\n+{\n+  __gnu_test::constexpr_bitwise_operators<std::ios_base::openmode>();\n+  return 0;\n+}"}, {"sha": "71a11ef21064e5f27686be6e108441607953b7ff", "filename": "libstdc++-v3/testsuite/28_regex/05_constants/syntax_option_type.cc", "status": "modified", "additions": 52, "deletions": 13, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F05_constants%2Fsyntax_option_type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F05_constants%2Fsyntax_option_type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F05_constants%2Fsyntax_option_type.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -23,29 +23,68 @@\n // 28.5.1 \n \n #include <regex>\n-#include <testsuite_hooks.h>\n \n void\n test01()\n {\n-  bool test __attribute__((unused)) = true;\n+  std::regex_constants::syntax_option_type option { };\n+  option = option | std::regex_constants::icase;\n+  option = option | std::regex_constants::nosubs;\n+  option = option | std::regex_constants::optimize;\n+  option = option | std::regex_constants::collate;\n+  option = option | std::regex_constants::ECMAScript;\n+  option = option | std::regex_constants::basic;\n+  option = option | std::regex_constants::extended;\n+  option = option | std::regex_constants::awk;\n+  option = option | std::regex_constants::grep;\n+  option = option | std::regex_constants::egrep;\n+}\n+\n+void\n+test02()\n+{\n+  std::regex_constants::syntax_option_type option { };\n+  option = option & std::regex_constants::icase;\n+  option = option & std::regex_constants::nosubs;\n+  option = option & std::regex_constants::optimize;\n+  option = option & std::regex_constants::collate;\n+  option = option & std::regex_constants::ECMAScript;\n+  option = option & std::regex_constants::basic;\n+  option = option & std::regex_constants::extended;\n+  option = option & std::regex_constants::awk;\n+  option = option & std::regex_constants::grep;\n+  option = option & std::regex_constants::egrep;\n+}\n \n-\tstd::regex_constants::syntax_option_type option = 0;\n+void\n+test03()\n+{\n+  std::regex_constants::syntax_option_type option { };\n+  option = ~std::regex_constants::icase;\n+  option = ~std::regex_constants::nosubs;\n+  option = ~std::regex_constants::optimize;\n+  option = ~std::regex_constants::collate;\n+  option = ~std::regex_constants::ECMAScript;\n+  option = ~std::regex_constants::basic;\n+  option = ~std::regex_constants::extended;\n+  option = ~std::regex_constants::awk;\n+  option = ~std::regex_constants::grep;\n+  option = ~std::regex_constants::egrep;\n+}\n \n-\toption |= std::regex_constants::icase;\n-\toption |= std::regex_constants::nosubs;\n-\toption |= std::regex_constants::optimize;\n-\toption |= std::regex_constants::collate;\n-\toption |= std::regex_constants::ECMAScript;\n-\toption |= std::regex_constants::basic;\n-\toption |= std::regex_constants::extended;\n-\toption |= std::regex_constants::awk;\n-\toption |= std::regex_constants::grep;\n-\toption |= std::regex_constants::egrep;\n+void\n+test04_constexpr()\n+{\n+  using namespace std::regex_constants;\n+  constexpr auto a1 = icase | awk;\n+  constexpr auto a2 = icase & awk;\n+  constexpr auto a3 = ~grep;\n }\n \n int main()\n {\n   test01();\n+  test02();\n+  test03();\n   return 0;\n }"}, {"sha": "7db1bbd5a4a373a2d354fd867fe643b28c64c6ad", "filename": "libstdc++-v3/testsuite/28_regex/08_basic_regex/requirements/constexpr_data.cc", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Frequirements%2Fconstexpr_data.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Frequirements%2Fconstexpr_data.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Frequirements%2Fconstexpr_data.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -0,0 +1,61 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <regex>\n+#include <testsuite_common_types.h>\n+\n+namespace __gnu_test\n+{\n+  struct constexpr_member_data\n+  {\n+    template<typename _Ttesttype>\n+      void\n+      operator()()\n+      {\n+\tstruct _Concept\n+\t{\n+\t  void __constraint()\n+\t  {\n+\t    constexpr auto v1(_Ttesttype::icase);\n+\t    constexpr auto v2(_Ttesttype::nosubs);\n+\t    constexpr auto v3(_Ttesttype::optimize);\n+\t    constexpr auto v4(_Ttesttype::collate);\n+\t    constexpr auto v5(_Ttesttype::ECMAScript);\n+\t    constexpr auto v6(_Ttesttype::basic);\n+\t    constexpr auto v7(_Ttesttype::extended);\n+\t    constexpr auto v8(_Ttesttype::awk);\n+\t    constexpr auto v9(_Ttesttype::grep);\n+\t    constexpr auto v10(_Ttesttype::egrep);\n+\t  }\n+\t};\n+\n+\t_Concept c;\n+\tc.__constraint();\n+      }\n+  };\n+}\n+\n+int main()\n+{\n+  __gnu_test::constexpr_member_data test;\n+  test.operator()<std::regex>();\n+  test.operator()<std::wregex>();\n+  return 0;\n+}"}, {"sha": "9272c7eb3da4b9b5cd93b95a5b8230aabba121cc", "filename": "libstdc++-v3/testsuite/29_atomics/atomic/cons/assign_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fcons%2Fassign_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fcons%2Fassign_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fcons%2Fassign_neg.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -28,5 +28,5 @@ int main()\n   return 0;\n }\n \n-// { dg-error \"ambiguous\" \"\" { target *-*-* } 522 }\n+// { dg-error \"deleted\" \"\" { target *-*-* } 544 }\n // { dg-prune-output \"include\" }"}, {"sha": "875c5490053bfc7a484727d7d0b1fd8f132a667a", "filename": "libstdc++-v3/testsuite/29_atomics/atomic/cons/constexpr.cc", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fcons%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fcons%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fcons%2Fconstexpr.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -0,0 +1,32 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <atomic>\n+#include <testsuite_common_types.h>\n+\n+int main()\n+{\n+  __gnu_test::constexpr_single_value_constructible test;\n+\n+  // test.operator()<std::atomic<int>, int>();\n+  __gnu_cxx::typelist::apply_generator(test, __gnu_test::atomics_tl(),\n+\t\t\t\t       __gnu_test::integral_types::type());\n+  return 0;\n+}"}, {"sha": "19b3a150c19d1005cab56c9803ed780a65661af7", "filename": "libstdc++-v3/testsuite/29_atomics/atomic/cons/copy_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fcons%2Fcopy_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fcons%2Fcopy_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fcons%2Fcopy_neg.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -28,5 +28,5 @@ int main()\n   return 0;\n }\n \n-// { dg-error \"deleted\" \"\" { target *-*-* } 561 }\n+// { dg-error \"deleted\" \"\" { target *-*-* } 583 }\n // { dg-prune-output \"include\" }"}, {"sha": "fad25935446123a631e2e0e1bf91394059992025", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_address/cons/assign_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_address%2Fcons%2Fassign_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_address%2Fcons%2Fassign_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_address%2Fcons%2Fassign_neg.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -26,6 +26,6 @@ void test01()\n   typedef std::atomic_address test_type;\n   test_type t1;\n   test_type t2;\n-  t1 = t2;\t\t\t// { dg-error \"ambiguous\" }\n+  t1 = t2;\t\t\t// { dg-error \"deleted\" }\n }\n // { dg-prune-output \"include\" }"}, {"sha": "6b4963512a418bc35eda3197320a3ac5160c22c7", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_address/cons/constexpr.cc", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_address%2Fcons%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_address%2Fcons%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_address%2Fcons%2Fconstexpr.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -0,0 +1,29 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <atomic>\n+#include <testsuite_common_types.h>\n+\n+int main()\n+{\n+  __gnu_test::constexpr_single_value_constructible test;\n+  test.operator()<std::atomic_address, void*>();\n+  return 0;\n+}"}, {"sha": "b91de1126501f6d83a8d2701447dc19cdc412372", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_flag/cons/1.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_flag%2Fcons%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_flag%2Fcons%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_flag%2Fcons%2F1.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -18,7 +18,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-#include <stdatomic.h>\n+#include <atomic>\n \n void test01()\n {"}, {"sha": "12da321abd81b0e20323caa96dd481495afec168", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_integral/cons/assign_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Fcons%2Fassign_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Fcons%2Fassign_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Fcons%2Fassign_neg.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -29,5 +29,5 @@ int main()\n   return 0;\n }\n \n-// { dg-error \"ambiguous\" \"\" { target *-*-* } 522 }\n+// { dg-error \"deleted\" \"\" { target *-*-* } 544 }\n // { dg-prune-output \"include\" }"}, {"sha": "a91db8d66a08219f1a75506f86277c725e320341", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_integral/cons/constexpr.cc", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Fcons%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Fcons%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Fcons%2Fconstexpr.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -0,0 +1,31 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <atomic>\n+#include <testsuite_common_types.h>\n+\n+int main()\n+{\n+  __gnu_test::constexpr_single_value_constructible test;\n+  __gnu_cxx::typelist::apply_generator(test,\n+\t\t\t\t       __gnu_test::atomic_integrals::type(),\n+\t\t\t\t       __gnu_test::integral_types::type());\n+  return 0;\n+}"}, {"sha": "e334f1b044763685063b0aee1b5e6e6586fd8ae9", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_integral/cons/copy_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Fcons%2Fcopy_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Fcons%2Fcopy_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Fcons%2Fcopy_neg.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -29,5 +29,5 @@ int main()\n   return 0;\n }\n \n-// { dg-error \"deleted\" \"\" { target *-*-* } 561 }\n+// { dg-error \"deleted\" \"\" { target *-*-* } 583 }\n // { dg-prune-output \"include\" }"}, {"sha": "b2f1ea4e3bf51a390da1aad1de0031a6439bdba6", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_integral/operators/bitwise_neg.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Foperators%2Fbitwise_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Foperators%2Fbitwise_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Foperators%2Fbitwise_neg.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -27,7 +27,7 @@ int main()\n   return 0;\n }\n \n-// { dg-error \"operator\" \"\" { target *-*-* } 405 }\n-// { dg-error \"operator\" \"\" { target *-*-* } 406 }\n-// { dg-error \"operator\" \"\" { target *-*-* } 407 }\n+// { dg-error \"operator\" \"\" { target *-*-* } 427 }\n+// { dg-error \"operator\" \"\" { target *-*-* } 428 }\n+// { dg-error \"operator\" \"\" { target *-*-* } 429 }\n // { dg-excess-errors \"In file included from\" }"}, {"sha": "dd84c836d9b21e83679c0468776c1e6c8c590fee", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_integral/operators/decrement_neg.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Foperators%2Fdecrement_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Foperators%2Fdecrement_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Foperators%2Fdecrement_neg.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -28,6 +28,6 @@ int main()\n   return 0;\n }\n \n-// { dg-error \"operator\" \"\" { target *-*-* } 376 }\n-// { dg-error \"operator\" \"\" { target *-*-* } 377 }\n-// { dg-error \"operator\" \"\" { target *-*-* } 378 }\n+// { dg-error \"operator\" \"\" { target *-*-* } 384 }\n+// { dg-error \"operator\" \"\" { target *-*-* } 385 }\n+// { dg-error \"operator\" \"\" { target *-*-* } 386 }"}, {"sha": "90b75556d1889ab40447a3fbc5f35bb97517ec75", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_integral/operators/increment_neg.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Foperators%2Fincrement_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Foperators%2Fincrement_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Foperators%2Fincrement_neg.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -28,6 +28,6 @@ int main()\n   return 0;\n }\n \n-// { dg-error \"operator\" \"\" { target *-*-* } 354 }\n-// { dg-error \"operator\" \"\" { target *-*-* } 355 }\n-// { dg-error \"operator\" \"\" { target *-*-* } 356 }\n+// { dg-error \"operator\" \"\" { target *-*-* } 362 }\n+// { dg-error \"operator\" \"\" { target *-*-* } 363 }\n+// { dg-error \"operator\" \"\" { target *-*-* } 364 }"}, {"sha": "022cd90b250f0214e10be7c28ccd981ef670b3d4", "filename": "libstdc++-v3/testsuite/29_atomics/headers/atomic/macros.cc", "status": "modified", "additions": 76, "deletions": 9, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fheaders%2Fatomic%2Fmacros.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fheaders%2Fatomic%2Fmacros.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fheaders%2Fatomic%2Fmacros.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -1,7 +1,7 @@\n // { dg-options \"-std=gnu++0x\" }\n // { dg-do compile }\n \n-// Copyright (C) 2008, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -22,24 +22,91 @@\n \n namespace gnu\n {\n-#ifndef ATOMIC_INTEGRAL_LOCK_FREE\n-# error \"ATOMIC_INTEGRAL_LOCK_FREE must be a macro\"\n+#ifndef ATOMIC_CHAR_LOCK_FREE \n+# error \"ATOMIC_CHAR_LOCK_FREE must be a macro\"\n #else\n-# if ATOMIC_INTEGRAL_LOCK_FREE != 0 \\\n-    && ATOMIC_INTEGRAL_LOCK_FREE != 1 && ATOMIC_INTEGRAL_LOCK_FREE != 2\n-# error \"ATOMIC_INTEGRAL_LOCK_FREE must be 0, 1, or 2\"\n+# if ATOMIC_CHAR_LOCK_FREE != 0 \\\n+    && ATOMIC_CHAR_LOCK_FREE != 1 && ATOMIC_CHAR_LOCK_FREE != 2\n+# error \"ATOMIC_CHAR_LOCK_FREE must be 0, 1, or 2\"\n+# endif\n+#endif\n+\n+#ifndef ATOMIC_CHAR16_T_LOCK_FREE \n+# error \"ATOMIC_CHAR16_T_LOCK_FREE must be a macro\"\n+#else\n+# if ATOMIC_CHAR16_T_LOCK_FREE != 0 \\\n+    && ATOMIC_CHAR16_T_LOCK_FREE != 1 && ATOMIC_CHAR16_T_LOCK_FREE != 2\n+# error \"ATOMIC_CHAR16_T_LOCK_FREE must be 0, 1, or 2\"\n+# endif\n+#endif\n+\n+#ifndef ATOMIC_CHAR32_T_LOCK_FREE \n+# error \"ATOMIC_CHAR32_T_LOCK_FREE must be a macro\"\n+#else\n+# if ATOMIC_CHAR32_T_LOCK_FREE != 0 \\\n+    && ATOMIC_CHAR32_T_LOCK_FREE != 1 && ATOMIC_CHAR32_T_LOCK_FREE != 2\n+# error \"ATOMIC_CHAR32_T_LOCK_FREE must be 0, 1, or 2\"\n+# endif\n+#endif\n+\n+#ifndef ATOMIC_WCHAR_T_LOCK_FREE \n+# error \"ATOMIC_WCHAR_T_LOCK_FREE must be a macro\"\n+#else\n+# if ATOMIC_WCHAR_T_LOCK_FREE != 0 \\\n+    && ATOMIC_WCHAR_T_LOCK_FREE != 1 && ATOMIC_WCHAR_T_LOCK_FREE != 2\n+# error \"ATOMIC_WCHAR_T_LOCK_FREE must be 0, 1, or 2\"\n+# endif\n+#endif\n+\n+#ifndef ATOMIC_SHORT_LOCK_FREE \n+# error \"ATOMIC_SHORT_LOCK_FREE must be a macro\"\n+#else\n+# if ATOMIC_SHORT_LOCK_FREE != 0 \\\n+    && ATOMIC_SHORT_LOCK_FREE != 1 && ATOMIC_SHORT_LOCK_FREE != 2\n+# error \"ATOMIC_SHORT_LOCK_FREE must be 0, 1, or 2\"\n+# endif\n+#endif\n+\n+#ifndef ATOMIC_INT_LOCK_FREE \n+# error \"ATOMIC_INT_LOCK_FREE must be a macro\"\n+#else\n+# if ATOMIC_INT_LOCK_FREE != 0 \\\n+    && ATOMIC_INT_LOCK_FREE != 1 && ATOMIC_INT_LOCK_FREE != 2\n+# error \"ATOMIC_INT_LOCK_FREE must be 0, 1, or 2\"\n+# endif\n+#endif\n+\n+#ifndef ATOMIC_LONG_LOCK_FREE \n+# error \"ATOMIC_LONG_LOCK_FREE must be a macro\"\n+#else\n+# if ATOMIC_LONG_LOCK_FREE != 0 \\\n+    && ATOMIC_LONG_LOCK_FREE != 1 && ATOMIC_LONG_LOCK_FREE != 2\n+# error \"ATOMIC_LONG_LOCK_FREE must be 0, 1, or 2\"\n+# endif\n+#endif\n+\n+#ifndef ATOMIC_LLONG_LOCK_FREE \n+# error \"ATOMIC_LLONG_LOCK_FREE must be a macro\"\n+#else\n+# if ATOMIC_LLONG_LOCK_FREE != 0 \\\n+    && ATOMIC_LLONG_LOCK_FREE != 1 && ATOMIC_LLONG_LOCK_FREE != 2\n+# error \"ATOMIC_LLONG_LOCK_FREE must be 0, 1, or 2\"\n # endif\n #endif\n \n #ifndef ATOMIC_ADDRESS_LOCK_FREE\n # error \"ATOMIC_ADDRESS_LOCK_FREE must be a macro\"\n-# if ATOMIC_INTEGRAL_LOCK_FREE != 0 \\\n-    && ATOMIC_INTEGRAL_LOCK_FREE != 1 && ATOMIC_INTEGRAL_LOCK_FREE != 2\n-# error \"ATOMIC_INTEGRAL_LOCK_FREE must be 0, 1, or 2\"\n+# if ATOMIC_ADDRESS_LOCK_FREE != 0 \\\n+    && ATOMIC_ADDRESS_LOCK_FREE != 1 && ATOMIC_ADDRESS_LOCK_FREE != 2\n+# error \"ATOMIC_ADDRESS_LOCK_FREE must be 0, 1, or 2\"\n # endif\n #endif\n \n #ifndef ATOMIC_FLAG_INIT\n     #error \"ATOMIC_FLAG_INIT_must_be_a_macro\"\n #endif\n+\n+#ifndef ATOMIC_VAR_INIT\n+    #error \"ATOMIC_VAR_INIT_must_be_a_macro\"\n+#endif\n }"}, {"sha": "13e4949e9b14bdb30084945f5428fb04b83038ab", "filename": "libstdc++-v3/testsuite/29_atomics/headers/atomic/types_std_c++0x.cc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fheaders%2Fatomic%2Ftypes_std_c%2B%2B0x.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fheaders%2Fatomic%2Ftypes_std_c%2B%2B0x.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fheaders%2Fatomic%2Ftypes_std_c%2B%2B0x.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -1,7 +1,7 @@\n // { dg-options \"-std=gnu++0x\" }\n // { dg-do compile }\n \n-// Copyright (C) 2008, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -69,7 +69,6 @@ void test01()\n   using std::atomic_intptr_t;\n   using std::atomic_uintptr_t;\n   using std::atomic_size_t;\n-  using std::atomic_ssize_t;\n   using std::atomic_ptrdiff_t;\n   using std::atomic_intmax_t;\n   using std::atomic_uintmax_t;"}, {"sha": "57907734304f236bcfa5fbcd7d0e5d9b756efdcb", "filename": "libstdc++-v3/testsuite/29_atomics/headers/atomic/types_std_c++0x_neg.cc", "status": "modified", "additions": 93, "deletions": 1, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fheaders%2Fatomic%2Ftypes_std_c%2B%2B0x_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fheaders%2Fatomic%2Ftypes_std_c%2B%2B0x_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fheaders%2Fatomic%2Ftypes_std_c%2B%2B0x_neg.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -1,7 +1,7 @@\n // { dg-options \"-std=gnu++0x\" }\n // { dg-do compile }\n \n-// Copyright (C) 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -49,6 +49,29 @@ void test01()\n   using atomic_char16_t;\n   using atomic_char32_t;\n \n+  using atomic_int_least8_t;\n+  using atomic_uint_least8_t;\n+  using atomic_int_least16_t;\n+  using atomic_uint_least16_t;\n+  using atomic_int_least32_t;\n+  using atomic_uint_least32_t;\n+  using atomic_int_least64_t;\n+  using atomic_uint_least64_t;\n+  using atomic_int_fast8_t;\n+  using atomic_uint_fast8_t;\n+  using atomic_int_fast16_t;\n+  using atomic_uint_fast16_t;\n+  using atomic_int_fast32_t;\n+  using atomic_uint_fast32_t;\n+  using atomic_int_fast64_t;\n+  using atomic_uint_fast64_t;\n+  using atomic_intptr_t;\n+  using atomic_uintptr_t;\n+  using atomic_size_t;\n+  using atomic_ptrdiff_t;\n+  using atomic_intmax_t;\n+  using atomic_uintmax_t;\n+\n   using atomic_address;\n }\n \n@@ -76,3 +99,72 @@ void test01()\n // { dg-error \"expected nested-name-specifier\" \"\" { target *-*-* } 49 }\n // { dg-error \"expected nested-name-specifier\" \"\" { target *-*-* } 50 }\n // { dg-error \"expected nested-name-specifier\" \"\" { target *-*-* } 52 }\n+// { dg-error \"expected nested-name-specifier\" \"\" { target *-*-* } 53 }\n+// { dg-error \"expected nested-name-specifier\" \"\" { target *-*-* } 54 }\n+// { dg-error \"expected nested-name-specifier\" \"\" { target *-*-* } 55 }\n+// { dg-error \"expected nested-name-specifier\" \"\" { target *-*-* } 56 }\n+// { dg-error \"expected nested-name-specifier\" \"\" { target *-*-* } 57 }\n+// { dg-error \"expected nested-name-specifier\" \"\" { target *-*-* } 58 }\n+// { dg-error \"expected nested-name-specifier\" \"\" { target *-*-* } 59 }\n+// { dg-error \"expected nested-name-specifier\" \"\" { target *-*-* } 60 }\n+// { dg-error \"expected nested-name-specifier\" \"\" { target *-*-* } 61 }\n+// { dg-error \"expected nested-name-specifier\" \"\" { target *-*-* } 62 }\n+// { dg-error \"expected nested-name-specifier\" \"\" { target *-*-* } 63 }\n+// { dg-error \"expected nested-name-specifier\" \"\" { target *-*-* } 64 }\n+// { dg-error \"expected nested-name-specifier\" \"\" { target *-*-* } 65 }\n+// { dg-error \"expected nested-name-specifier\" \"\" { target *-*-* } 66 }\n+// { dg-error \"expected nested-name-specifier\" \"\" { target *-*-* } 67 }\n+// { dg-error \"expected nested-name-specifier\" \"\" { target *-*-* } 68 }\n+// { dg-error \"expected nested-name-specifier\" \"\" { target *-*-* } 69 }\n+// { dg-error \"expected nested-name-specifier\" \"\" { target *-*-* } 70 }\n+// { dg-error \"expected nested-name-specifier\" \"\" { target *-*-* } 71 }\n+// { dg-error \"expected nested-name-specifier\" \"\" { target *-*-* } 72 }\n+// { dg-error \"expected nested-name-specifier\" \"\" { target *-*-* } 73 }\n+// { dg-error \"expected nested-name-specifier\" \"\" { target *-*-* } 75 }\n+\n+// { dg-error \"declared\" \"\" { target *-*-* } 26 }\n+// { dg-error \"declared\" \"\" { target *-*-* } 27 }\n+// { dg-error \"declared\" \"\" { target *-*-* } 28 }\n+// { dg-error \"declared\" \"\" { target *-*-* } 29 }\n+// { dg-error \"declared\" \"\" { target *-*-* } 30 }\n+// { dg-error \"declared\" \"\" { target *-*-* } 31 }\n+// { dg-error \"declared\" \"\" { target *-*-* } 32 }\n+// { dg-error \"declared\" \"\" { target *-*-* } 34 }\n+// { dg-error \"declared\" \"\" { target *-*-* } 36 }\n+// { dg-error \"declared\" \"\" { target *-*-* } 37 }\n+// { dg-error \"declared\" \"\" { target *-*-* } 38 }\n+// { dg-error \"declared\" \"\" { target *-*-* } 39 }\n+// { dg-error \"declared\" \"\" { target *-*-* } 40 }\n+// { dg-error \"declared\" \"\" { target *-*-* } 41 }\n+// { dg-error \"declared\" \"\" { target *-*-* } 42 }\n+// { dg-error \"declared\" \"\" { target *-*-* } 43 }\n+// { dg-error \"declared\" \"\" { target *-*-* } 44 }\n+// { dg-error \"declared\" \"\" { target *-*-* } 45 }\n+// { dg-error \"declared\" \"\" { target *-*-* } 46 }\n+// { dg-error \"declared\" \"\" { target *-*-* } 47 }\n+// { dg-error \"declared\" \"\" { target *-*-* } 48 }\n+// { dg-error \"declared\" \"\" { target *-*-* } 49 }\n+// { dg-error \"declared\" \"\" { target *-*-* } 50 }\n+// { dg-error \"declared\" \"\" { target *-*-* } 52 }\n+// { dg-error \"declared\" \"\" { target *-*-* } 53 }\n+// { dg-error \"declared\" \"\" { target *-*-* } 54 }\n+// { dg-error \"declared\" \"\" { target *-*-* } 55 }\n+// { dg-error \"declared\" \"\" { target *-*-* } 56 }\n+// { dg-error \"declared\" \"\" { target *-*-* } 57 }\n+// { dg-error \"declared\" \"\" { target *-*-* } 58 }\n+// { dg-error \"declared\" \"\" { target *-*-* } 59 }\n+// { dg-error \"declared\" \"\" { target *-*-* } 60 }\n+// { dg-error \"declared\" \"\" { target *-*-* } 61 }\n+// { dg-error \"declared\" \"\" { target *-*-* } 62 }\n+// { dg-error \"declared\" \"\" { target *-*-* } 63 }\n+// { dg-error \"declared\" \"\" { target *-*-* } 64 }\n+// { dg-error \"declared\" \"\" { target *-*-* } 65 }\n+// { dg-error \"declared\" \"\" { target *-*-* } 66 }\n+// { dg-error \"declared\" \"\" { target *-*-* } 67 }\n+// { dg-error \"declared\" \"\" { target *-*-* } 68 }\n+// { dg-error \"declared\" \"\" { target *-*-* } 69 }\n+// { dg-error \"declared\" \"\" { target *-*-* } 70 }\n+// { dg-error \"declared\" \"\" { target *-*-* } 71 }\n+// { dg-error \"declared\" \"\" { target *-*-* } 72 }\n+// { dg-error \"declared\" \"\" { target *-*-* } 73 }\n+// { dg-error \"declared\" \"\" { target *-*-* } 75 }"}, {"sha": "7d6992e4a38ccc6b6ad26e44556cb67ab732f3bc", "filename": "libstdc++-v3/testsuite/29_atomics/headers/stdatomic.h/macros.c", "status": "removed", "additions": 0, "deletions": 114, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/900484dee595d91a71c7ae63734c199bd137afc6/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fheaders%2Fstdatomic.h%2Fmacros.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/900484dee595d91a71c7ae63734c199bd137afc6/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fheaders%2Fstdatomic.h%2Fmacros.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fheaders%2Fstdatomic.h%2Fmacros.c?ref=900484dee595d91a71c7ae63734c199bd137afc6", "patch": "@@ -1,114 +0,0 @@\n-// { dg-options \"-x c\" }\n-// { dg-do compile }\n-\n-// Copyright (C) 2008, 2009 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 3, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING3.  If not see\n-// <http://www.gnu.org/licenses/>.\n-\n-#include <stdatomic.h>\n-\n-int main()\n-{\n-#ifndef ATOMIC_INTEGRAL_LOCK_FREE\n-    #error \"ATOMIC_INTEGRAL_LOCK_FREE_must_be_a_macro\"\n-#endif\n-\n-#ifndef ATOMIC_ADDRESS_LOCK_FREE\n-    #error \"ATOMIC_ADDRESS_LOCK_FREE_must_be_a_macro\"\n-#endif\n-\n-#ifndef ATOMIC_FLAG_INIT\n-    #error \"ATOMIC_FLAG_INIT_must_be_a_macro\"\n-#endif\n-\n-#ifndef atomic_is_lock_free\n-    #error \"atomic_is_lock_free_must_be_a_macro\"\n-#endif\n-\n-#ifndef atomic_load\n-    #error \"atomic_load_must_be_a_macro\"\n-#endif\n-\n-#ifndef atomic_load_explicit\n-    #error \"atomic_load_explicit_must_be_a_macro\"\n-#endif\n-\n-#ifndef atomic_store_explicit\n-    #error \"atomic_store_explicit_must_be_a_macro\"\n-#endif\n-\n-#ifndef atomic_store\n-    #error \"atomic_store_must_be_a_macro\"\n-#endif\n-\n-#ifndef atomic_exchange_explicit\n-    #error \"atomic_exchange_explicit_must_be_a_macro\"\n-#endif\n-\n-#ifndef atomic_exchange\n-    #error \"atomic_exchange_must_be_a_macro\"\n-#endif\n-\n-#ifndef atomic_compare_exchange\n-    #error \"atomic_compare_exchange_must_be_a_macro\"\n-#endif\n-\n-#ifndef atomic_compare_exchange_explicit\n-    #error \"atomic_compare_exchange_explicit_must_be_a_macro\"\n-#endif\n-\n-#ifndef atomic_fetch_add_explicit\n-    #error \"atomic_fetch_add_explicit_must_be_a_macro\"\n-#endif\n-\n-#ifndef atomic_fetch_add\n-    #error \"atomic_fetch_add_must_be_a_macro\"\n-#endif\n-\n-#ifndef atomic_fetch_sub_explicit\n-    #error \"atomic_fetch_sub_explicit_must_be_a_macro\"\n-#endif\n-\n-#ifndef atomic_fetch_sub\n-    #error \"atomic_fetch_sub_must_be_a_macro\"\n-#endif\n-\n-#ifndef atomic_fetch_and_explicit\n-    #error \"atomic_fetch_and_explicit_must_be_a_macro\"\n-#endif\n- \n-#ifndef atomic_fetch_and\n-    #error \"atomic_fetch_and_must_be_a_macro\"\n-#endif\n-\n-#ifndef atomic_fetch_or_explicit\n-    #error \"atomic_fetch_or_explicit_must_be_a_macro\"\n-#endif\n-\n-#ifndef atomic_fetch_or\n-    #error \"atomic_fetch_or_must_be_a_macro\"\n-#endif\n-\n-#ifndef atomic_fetch_xor_explicit\n-    #error \"atomic_fetch_xor_explicit_must_be_a_macro\"\n-#endif\n-\n-#ifndef atomic_fetch_xor\n-    #error \"atomic_fetch_xor_must_be_a_macro\"\n-#endif\n-\n-  return 0;\n-}"}, {"sha": "48d6d92675993dde8119c0b405128e2cd36b9f90", "filename": "libstdc++-v3/testsuite/29_atomics/headers/stdatomic.h/types.c", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/900484dee595d91a71c7ae63734c199bd137afc6/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fheaders%2Fstdatomic.h%2Ftypes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/900484dee595d91a71c7ae63734c199bd137afc6/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fheaders%2Fstdatomic.h%2Ftypes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fheaders%2Fstdatomic.h%2Ftypes.c?ref=900484dee595d91a71c7ae63734c199bd137afc6", "patch": "@@ -1,77 +0,0 @@\n-// { dg-options \"-x c\" }\n-// { dg-do compile }\n-\n-// Copyright (C) 2008, 2009 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 3, or (at your option)\n-// any later version.\n-//\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-//\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING3.  If not see\n-// <http://www.gnu.org/licenses/>.\n-\n-#include <stdatomic.h>\n-\n-void test01()\n-{\n-  typedef memory_order t_01;\n-  memory_order t_02 __attribute__((unused)) = memory_order_relaxed;\n-  memory_order t_03 __attribute__((unused)) = memory_order_acquire;\n-  memory_order t_04 __attribute__((unused)) = memory_order_release;\n-  memory_order t_05 __attribute__((unused)) = memory_order_acq_rel;\n-  memory_order t_06 __attribute__((unused)) = memory_order_seq_cst;\n-\n-  typedef atomic_flag t_07;\n-\n-  // atomics for builtins types\n-  typedef atomic_bool t_08;\n-  typedef atomic_char t_09;\n-  typedef atomic_schar t_10;\n-  typedef atomic_uchar t_11;\n-  typedef atomic_short t_12;\n-  typedef atomic_ushort t_13;\n-  typedef atomic_int t_14;\n-  typedef atomic_uint t_15;\n-  typedef atomic_long t_16;\n-  typedef atomic_ulong t_17;\n-  typedef atomic_llong t_18;\n-  typedef atomic_ullong t_19;\n-  typedef atomic_wchar_t t_20;\n-  typedef atomic_char16_t t_21;\n-  typedef atomic_char32_t t_22;\n-\n-  // atomics for standard typedefs\n-  typedef atomic_int_least8_t t_23;\n-  typedef atomic_uint_least8_t t_24;\n-  typedef atomic_int_least16_t t_25;\n-  typedef atomic_uint_least16_t t_26;\n-  typedef atomic_int_least32_t t_27;\n-  typedef atomic_uint_least32_t t_28;\n-  typedef atomic_int_least64_t t_29;\n-  typedef atomic_uint_least64_t t_30;\n-  typedef atomic_int_fast8_t t_31;\n-  typedef atomic_uint_fast8_t t_32;\n-  typedef atomic_int_fast16_t t_33;\n-  typedef atomic_uint_fast16_t t_34;\n-  typedef atomic_int_fast32_t t_35;\n-  typedef atomic_uint_fast32_t t_36;\n-  typedef atomic_int_fast64_t t_37;\n-  typedef atomic_uint_fast64_t t_38;\n-  typedef atomic_intptr_t t_39;\n-  typedef atomic_uintptr_t t_40;\n-  typedef atomic_size_t t_41;\n-  typedef atomic_ssize_t t_42;\n-  typedef atomic_ptrdiff_t t_43;\n-  typedef atomic_intmax_t t_44;\n-  typedef atomic_uintmax_t t_45;\n-\n-  typedef atomic_address t_46;\n-}"}, {"sha": "9518b72ea9262f92f19a1e5e5c1d417629c42169", "filename": "libstdc++-v3/testsuite/30_threads/call_once/constexpr.cc", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcall_once%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcall_once%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcall_once%2Fconstexpr.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -0,0 +1,29 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <mutex>\n+#include <testsuite_common_types.h>\n+\n+int main()\n+{\n+  __gnu_test::constexpr_default_constructible test;\n+  test.operator()<std::mutex>();\n+  return 0;\n+}"}, {"sha": "9518b72ea9262f92f19a1e5e5c1d417629c42169", "filename": "libstdc++-v3/testsuite/30_threads/mutex/cons/constexpr.cc", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fmutex%2Fcons%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fmutex%2Fcons%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fmutex%2Fcons%2Fconstexpr.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -0,0 +1,29 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <mutex>\n+#include <testsuite_common_types.h>\n+\n+int main()\n+{\n+  __gnu_test::constexpr_default_constructible test;\n+  test.operator()<std::mutex>();\n+  return 0;\n+}"}, {"sha": "52f3b5d3d4d35731da3962bb6b630b4da7d672d6", "filename": "libstdc++-v3/testsuite/30_threads/once_flag/cons/constexpr.cc", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fonce_flag%2Fcons%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fonce_flag%2Fcons%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fonce_flag%2Fcons%2Fconstexpr.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -0,0 +1,29 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <mutex>\n+#include <testsuite_common_types.h>\n+\n+int main()\n+{\n+  __gnu_test::constexpr_default_constructible test;\n+  test.operator()<std::once_flag>();\n+  return 0;\n+}"}, {"sha": "7f8072427cae3c2b866ccc326f4ee2d0d955a6f3", "filename": "libstdc++-v3/testsuite/ext/profile/mutex_extensions.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fprofile%2Fmutex_extensions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fprofile%2Fmutex_extensions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fprofile%2Fmutex_extensions.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -22,4 +22,4 @@\n \n #include <vector>\n \n-// { dg-error \"Cannot use -D_GLIBCXX_PROFILE with \" \"\" { target *-*-* } 196 }\n+// { dg-error \"Cannot use -D_GLIBCXX_PROFILE with \" \"\" { target *-*-* } 223 }"}, {"sha": "a44cace607c284749ab8ef78997900d021e78426", "filename": "libstdc++-v3/testsuite/tr1/4_metaprogramming/integral_constant/requirements/constexpr_data.cc", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F4_metaprogramming%2Fintegral_constant%2Frequirements%2Fconstexpr_data.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F4_metaprogramming%2Fintegral_constant%2Frequirements%2Fconstexpr_data.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F4_metaprogramming%2Fintegral_constant%2Frequirements%2Fconstexpr_data.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -0,0 +1,52 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <type_traits>\n+#include <testsuite_common_types.h>\n+\n+namespace __gnu_test\n+{\n+  struct constexpr_member_data\n+  {\n+    template<typename _Ttesttype>\n+      void\n+      operator()()\n+      {\n+\tstruct _Concept\n+\t{\n+\t  void __constraint()\n+\t  {\n+\t    constexpr auto v(_Ttesttype::value);\n+\t  }\n+\t};\n+\n+\t_Concept c;\n+\tc.__constraint();\n+      }\n+  };\n+}\n+\n+int main()\n+{\n+  __gnu_test::constexpr_member_data test;\n+  test.operator()<std::integral_constant<unsigned short, 69>>();\n+  test.operator()<std::integral_constant<bool, true>>();\n+  return 0;\n+}"}, {"sha": "91f4aefde619eeee1dfa8d1f3ce9c8175dd2bc19", "filename": "libstdc++-v3/testsuite/util/testsuite_abi.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_abi.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_abi.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_abi.cc?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -193,6 +193,7 @@ check_version(symbol& test, bool added)\n       known_versions.push_back(\"GLIBCXX_3.4.13\");\n       known_versions.push_back(\"GLIBCXX_3.4.14\");\n       known_versions.push_back(\"GLIBCXX_3.4.15\");\n+      known_versions.push_back(\"GLIBCXX_3.4.16\");\n       known_versions.push_back(\"GLIBCXX_LDBL_3.4\");\n       known_versions.push_back(\"GLIBCXX_LDBL_3.4.7\");\n       known_versions.push_back(\"GLIBCXX_LDBL_3.4.10\");"}, {"sha": "4da2634367cea7405da33cd5690757eae9d5ecf2", "filename": "libstdc++-v3/testsuite/util/testsuite_common_types.h", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_common_types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a86be0ddc6fdf0872459ed448a90cae2eceb0e/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_common_types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_common_types.h?ref=94a86be0ddc6fdf0872459ed448a90cae2eceb0e", "patch": "@@ -339,6 +339,14 @@ namespace __gnu_test\n   typedef transform<integral_types::type, atomics>::type atomics_tl;\n #endif\n \n+  template<typename Tp>\n+    struct numeric_limits\n+    {\n+      typedef Tp\t\t\tvalue_type;\n+      typedef std::numeric_limits<value_type>\ttype;\n+    };\n+\n+  typedef transform<integral_types::type, numeric_limits>::type limits_tl;\n \n   struct has_increment_operators\n   {\n@@ -384,6 +392,20 @@ namespace __gnu_test\n       }\n   };\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+  template<typename _Tp>\n+    void\n+    constexpr_bitwise_operators()\n+    {\n+      constexpr _Tp a = _Tp();\n+      constexpr _Tp b = _Tp();\n+      constexpr _Tp c1 = a | b;\n+      constexpr _Tp c2 = a & b;\n+      constexpr _Tp c3 = a ^ b;\n+      constexpr _Tp c4 = ~b;\n+    }\n+#endif\n+\n   template<typename _Tp>\n     void\n     bitwise_operators()\n@@ -588,6 +610,53 @@ namespace __gnu_test\n       }\n   };\n \n+  // Generator to test constexpr constructor\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+  // Generator to test default constructor.\n+  struct constexpr_default_constructible\n+  {\n+    template<typename _Tp>\n+      void \n+      operator()()\n+      {\n+\tstruct _Concept\n+\t{\n+\t  // Have to have user-defined default ctor for this to work.\n+\t  void __constraint()\n+\t  { constexpr _Tp __v; }\n+\t};\n+\n+\tvoid (_Concept::*__x)() __attribute__((unused))\n+\t  = &_Concept::__constraint;\n+      }\n+  };\n+\n+  struct constexpr_single_value_constructible\n+  {\n+    template<typename _Ttesttype, typename _Tbasetype>\n+      void\n+      operator()()\n+      {\n+\tstruct _Concept\n+\t{\n+\t  // Additional constraint on _Tbasetype needed.\n+\t  // Either assume user-defined default ctor as per\n+\t  // constexpr_default_constructible and provide no\n+\t  // initializer, provide an initializer, or assume empty-list\n+\t  // init-able. Choose the latter.\n+\t  void __constraint()\n+\t  {\n+\t    constexpr _Tbasetype __v { };\n+\t    constexpr _Ttesttype __t(__v);\n+\t  }\n+\t};\n+\n+\t_Concept c;\n+\tc.__constraint();\n+      }\n+  };\n+#endif\n+\n   // Generator to test direct list initialization\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n   struct direct_list_initializable"}]}