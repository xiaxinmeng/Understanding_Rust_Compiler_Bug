{"sha": "1fa0c1800466eaf6c7cdec4a5c684975b379a07a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWZhMGMxODAwNDY2ZWFmNmM3Y2RlYzRhNWM2ODQ5NzViMzc5YTA3YQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2012-06-04T13:18:16Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2012-06-04T13:18:16Z"}, "message": "tree-data-ref.c (struct rdg_vertex_info): Remove.\n\n2012-06-04  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-data-ref.c (struct rdg_vertex_info): Remove.\n\t(rdg_vertex_for_stmt): Simplify using gimple_uid.\n\t(create_rdg_vertices): Pass loop argument, remove stmt to RDG index\n\thashtable.   Record stmt data-references.\n\t(hash_stmt_vertex_info): Remove.\n\t(eq_stmt_vertex_info): Likewise.\n\t(hash_stmt_vertex_del): Likewise.\n\t(build_empty_rdg): Simplify.\n\t(build_rdg): Adjust.\n\t(free_rdg): Likewise.\n\t(ref_base_address): Remove.\n\t(have_similar_memory_accesses): Likewise.\n\t* tree-data-ref.h (create_rdg_vertices): Remove.\n\t(struct rdg_vertex): Add datarefs member.\n\t(RDGV_DATAREFS): New define.\n\t(RDG_DATAREFS): Likewise.\n\t(have_similar_memory_accesses): Remove.\n\t(rdg_has_similar_memory_accesses): Likewise.\n\t* tree-loop-distribution.c (ref_base_address): Re-implement here.\n\t(similar_memory_accesses): Re-implement using existing data-references.\n\t(tree_loop_distribution): Initialize stmt uids for the stmt to\n\tRDG index mapping.\n\t* tree-vect-loop.c (vect_create_epilog_for_reduction): Only\n\taccess stmt vinfo for stmts in loop.\n\nFrom-SVN: r188180", "tree": {"sha": "63dd9ca1454b35898d9f0311c13337a73db0d703", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/63dd9ca1454b35898d9f0311c13337a73db0d703"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1fa0c1800466eaf6c7cdec4a5c684975b379a07a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fa0c1800466eaf6c7cdec4a5c684975b379a07a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fa0c1800466eaf6c7cdec4a5c684975b379a07a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fa0c1800466eaf6c7cdec4a5c684975b379a07a/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "143015c4f89bbd7eb31a36947587096caf1fd83a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/143015c4f89bbd7eb31a36947587096caf1fd83a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/143015c4f89bbd7eb31a36947587096caf1fd83a"}], "stats": {"total": 275, "additions": 110, "deletions": 165}, "files": [{"sha": "7722dd587e7ca2db2be7b70cddd24cb9fd760568", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fa0c1800466eaf6c7cdec4a5c684975b379a07a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fa0c1800466eaf6c7cdec4a5c684975b379a07a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1fa0c1800466eaf6c7cdec4a5c684975b379a07a", "patch": "@@ -1,3 +1,30 @@\n+2012-06-04  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-data-ref.c (struct rdg_vertex_info): Remove.\n+\t(rdg_vertex_for_stmt): Simplify using gimple_uid.\n+\t(create_rdg_vertices): Pass loop argument, remove stmt to RDG index\n+\thashtable.   Record stmt data-references.\n+\t(hash_stmt_vertex_info): Remove.\n+\t(eq_stmt_vertex_info): Likewise.\n+\t(hash_stmt_vertex_del): Likewise.\n+\t(build_empty_rdg): Simplify.\n+\t(build_rdg): Adjust.\n+\t(free_rdg): Likewise.\n+\t(ref_base_address): Remove.\n+\t(have_similar_memory_accesses): Likewise.\n+\t* tree-data-ref.h (create_rdg_vertices): Remove.\n+\t(struct rdg_vertex): Add datarefs member.\n+\t(RDGV_DATAREFS): New define.\n+\t(RDG_DATAREFS): Likewise.\n+\t(have_similar_memory_accesses): Remove.\n+\t(rdg_has_similar_memory_accesses): Likewise.\n+\t* tree-loop-distribution.c (ref_base_address): Re-implement here.\n+\t(similar_memory_accesses): Re-implement using existing data-references.\n+\t(tree_loop_distribution): Initialize stmt uids for the stmt to\n+\tRDG index mapping.\n+\t* tree-vect-loop.c (vect_create_epilog_for_reduction): Only\n+\taccess stmt vinfo for stmts in loop.\n+\n 2012-06-04  Andreas Schwab  <schwab@linux-m68k.org>\n \n \tPR target/53461"}, {"sha": "bf1d859178b46969adfb507c0ec943afce7a215c", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 26, "deletions": 146, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fa0c1800466eaf6c7cdec4a5c684975b379a07a/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fa0c1800466eaf6c7cdec4a5c684975b379a07a/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=1fa0c1800466eaf6c7cdec4a5c684975b379a07a", "patch": "@@ -4924,29 +4924,14 @@ dot_rdg (struct graph *rdg)\n #endif\n }\n \n-/* This structure is used for recording the mapping statement index in\n-   the RDG.  */\n-\n-struct GTY(()) rdg_vertex_info\n-{\n-  gimple stmt;\n-  int index;\n-};\n-\n /* Returns the index of STMT in RDG.  */\n \n int\n-rdg_vertex_for_stmt (struct graph *rdg, gimple stmt)\n+rdg_vertex_for_stmt (struct graph *rdg ATTRIBUTE_UNUSED, gimple stmt)\n {\n-  struct rdg_vertex_info rvi, *slot;\n-\n-  rvi.stmt = stmt;\n-  slot = (struct rdg_vertex_info *) htab_find (rdg->indices, &rvi);\n-\n-  if (!slot)\n-    return -1;\n-\n-  return slot->index;\n+  int index = gimple_uid (stmt);\n+  gcc_checking_assert (index == -1 || RDG_STMT (rdg, index) == stmt);\n+  return index;\n }\n \n /* Creates an edge in RDG for each distance vector from DDR.  The\n@@ -5041,8 +5026,8 @@ create_rdg_edges (struct graph *rdg, VEC (ddr_p, heap) *ddrs)\n \n /* Build the vertices of the reduced dependence graph RDG.  */\n \n-void\n-create_rdg_vertices (struct graph *rdg, VEC (gimple, heap) *stmts)\n+static void\n+create_rdg_vertices (struct graph *rdg, VEC (gimple, heap) *stmts, loop_p loop)\n {\n   int i, j;\n   gimple stmt;\n@@ -5052,33 +5037,31 @@ create_rdg_vertices (struct graph *rdg, VEC (gimple, heap) *stmts)\n       VEC (data_ref_loc, heap) *references;\n       data_ref_loc *ref;\n       struct vertex *v = &(rdg->vertices[i]);\n-      struct rdg_vertex_info *rvi = XNEW (struct rdg_vertex_info);\n-      struct rdg_vertex_info **slot;\n \n-      rvi->stmt = stmt;\n-      rvi->index = i;\n-      slot = (struct rdg_vertex_info **) htab_find_slot (rdg->indices, rvi, INSERT);\n-\n-      if (!*slot)\n-\t*slot = rvi;\n-      else\n-\tfree (rvi);\n+      /* Record statement to vertex mapping.  */\n+      gimple_set_uid (stmt, i);\n \n       v->data = XNEW (struct rdg_vertex);\n-      RDG_STMT (rdg, i) = stmt;\n-\n-      RDG_MEM_WRITE_STMT (rdg, i) = false;\n-      RDG_MEM_READS_STMT (rdg, i) = false;\n+      RDGV_STMT (v) = stmt;\n+      RDGV_DATAREFS (v) = NULL;\n+      RDGV_HAS_MEM_WRITE (v) = false;\n+      RDGV_HAS_MEM_READS (v) = false;\n       if (gimple_code (stmt) == GIMPLE_PHI)\n \tcontinue;\n \n       get_references_in_stmt (stmt, &references);\n       FOR_EACH_VEC_ELT (data_ref_loc, references, j, ref)\n-\tif (!ref->is_read)\n-\t  RDG_MEM_WRITE_STMT (rdg, i) = true;\n-\telse\n-\t  RDG_MEM_READS_STMT (rdg, i) = true;\n-\n+\t{\n+\t  data_reference_p dr;\n+\t  if (!ref->is_read)\n+\t    RDGV_HAS_MEM_WRITE (v) = true;\n+\t  else\n+\t    RDGV_HAS_MEM_READS (v) = true;\n+\t  dr = create_data_ref (loop, loop_containing_stmt (stmt),\n+\t\t\t\t*ref->pos, stmt, ref->is_read);\n+\t  if (dr)\n+\t    VEC_safe_push (data_reference_p, heap, RDGV_DATAREFS (v), dr);\n+\t}\n       VEC_free (data_ref_loc, heap, references);\n     }\n }\n@@ -5130,49 +5113,14 @@ known_dependences_p (VEC (ddr_p, heap) *dependence_relations)\n   return true;\n }\n \n-/* Computes a hash function for element ELT.  */\n-\n-static hashval_t\n-hash_stmt_vertex_info (const void *elt)\n-{\n-  const struct rdg_vertex_info *const rvi =\n-    (const struct rdg_vertex_info *) elt;\n-  gimple stmt = rvi->stmt;\n-\n-  return htab_hash_pointer (stmt);\n-}\n-\n-/* Compares database elements E1 and E2.  */\n-\n-static int\n-eq_stmt_vertex_info (const void *e1, const void *e2)\n-{\n-  const struct rdg_vertex_info *elt1 = (const struct rdg_vertex_info *) e1;\n-  const struct rdg_vertex_info *elt2 = (const struct rdg_vertex_info *) e2;\n-\n-  return elt1->stmt == elt2->stmt;\n-}\n-\n-/* Free the element E.  */\n-\n-static void\n-hash_stmt_vertex_del (void *e)\n-{\n-  free (e);\n-}\n-\n /* Build the Reduced Dependence Graph (RDG) with one vertex per\n    statement of the loop nest, and one edge per data dependence or\n    scalar dependence.  */\n \n struct graph *\n build_empty_rdg (int n_stmts)\n {\n-  int nb_data_refs = 10;\n   struct graph *rdg = new_graph (n_stmts);\n-\n-  rdg->indices = htab_create (nb_data_refs, hash_stmt_vertex_info,\n-\t\t\t      eq_stmt_vertex_info, hash_stmt_vertex_del);\n   return rdg;\n }\n \n@@ -5195,7 +5143,7 @@ build_rdg (struct loop *loop,\n       VEC (gimple, heap) *stmts = VEC_alloc (gimple, heap, 10);\n       stmts_from_loop (loop, &stmts);\n       rdg = build_empty_rdg (VEC_length (gimple, stmts));\n-      create_rdg_vertices (rdg, stmts);\n+      create_rdg_vertices (rdg, stmts, loop);\n       create_rdg_edges (rdg, *dependence_relations);\n       VEC_free (gimple, heap, stmts);\n     }\n@@ -5218,10 +5166,11 @@ free_rdg (struct graph *rdg)\n       for (e = v->succ; e; e = e->succ_next)\n \tfree (e->data);\n \n+      gimple_set_uid (RDGV_STMT (v), -1);\n+      free_data_refs (RDGV_DATAREFS (v));\n       free (v->data);\n     }\n \n-  htab_delete (rdg->indices);\n   free_graph (rdg);\n }\n \n@@ -5307,40 +5256,6 @@ stores_zero_from_loop (struct loop *loop, VEC (gimple, heap) **stmts)\n   free (bbs);\n }\n \n-/* For a data reference REF, return the declaration of its base\n-   address or NULL_TREE if the base is not determined.  */\n-\n-static inline tree\n-ref_base_address (gimple stmt, data_ref_loc *ref)\n-{\n-  tree base = NULL_TREE;\n-  tree base_address;\n-  struct data_reference *dr = XCNEW (struct data_reference);\n-\n-  DR_STMT (dr) = stmt;\n-  DR_REF (dr) = *ref->pos;\n-  dr_analyze_innermost (dr, loop_containing_stmt (stmt));\n-  base_address = DR_BASE_ADDRESS (dr);\n-\n-  if (!base_address)\n-    goto end;\n-\n-  switch (TREE_CODE (base_address))\n-    {\n-    case ADDR_EXPR:\n-      base = TREE_OPERAND (base_address, 0);\n-      break;\n-\n-    default:\n-      base = base_address;\n-      break;\n-    }\n-\n- end:\n-  free_data_ref (dr);\n-  return base;\n-}\n-\n /* Determines whether the statement from vertex V of the RDG has a\n    definition used outside the loop that contains this statement.  */\n \n@@ -5368,38 +5283,3 @@ rdg_defs_used_in_other_loops_p (struct graph *rdg, int v)\n \n   return false;\n }\n-\n-/* Determines whether statements S1 and S2 access to similar memory\n-   locations.  Two memory accesses are considered similar when they\n-   have the same base address declaration, i.e. when their\n-   ref_base_address is the same.  */\n-\n-bool\n-have_similar_memory_accesses (gimple s1, gimple s2)\n-{\n-  bool res = false;\n-  unsigned i, j;\n-  VEC (data_ref_loc, heap) *refs1, *refs2;\n-  data_ref_loc *ref1, *ref2;\n-\n-  get_references_in_stmt (s1, &refs1);\n-  get_references_in_stmt (s2, &refs2);\n-\n-  FOR_EACH_VEC_ELT (data_ref_loc, refs1, i, ref1)\n-    {\n-      tree base1 = ref_base_address (s1, ref1);\n-\n-      if (base1)\n-\tFOR_EACH_VEC_ELT (data_ref_loc, refs2, j, ref2)\n-\t  if (base1 == ref_base_address (s2, ref2))\n-\t    {\n-\t      res = true;\n-\t      goto end;\n-\t    }\n-    }\n-\n- end:\n-  VEC_free (data_ref_loc, heap, refs1);\n-  VEC_free (data_ref_loc, heap, refs2);\n-  return res;\n-}"}, {"sha": "2edddc03d441bae102c4a82da6d11ad43d64a22e", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fa0c1800466eaf6c7cdec4a5c684975b379a07a/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fa0c1800466eaf6c7cdec4a5c684975b379a07a/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=1fa0c1800466eaf6c7cdec4a5c684975b379a07a", "patch": "@@ -403,7 +403,6 @@ extern bool compute_all_dependences (VEC (data_reference_p, heap) *,\n extern tree find_data_references_in_bb (struct loop *, basic_block,\n                                         VEC (data_reference_p, heap) **);\n \n-extern void create_rdg_vertices (struct graph *, VEC (gimple, heap) *);\n extern bool dr_may_alias_p (const struct data_reference *,\n \t\t\t    const struct data_reference *, bool);\n extern bool dr_equal_offsets_p (struct data_reference *,\n@@ -525,6 +524,9 @@ typedef struct rdg_vertex\n   /* The statement represented by this vertex.  */\n   gimple stmt;\n \n+  /* Vector of data-references in this statement.  */\n+  VEC(data_reference_p, heap) *datarefs;\n+\n   /* True when the statement contains a write to memory.  */\n   bool has_mem_write;\n \n@@ -533,9 +535,11 @@ typedef struct rdg_vertex\n } *rdg_vertex_p;\n \n #define RDGV_STMT(V)     ((struct rdg_vertex *) ((V)->data))->stmt\n+#define RDGV_DATAREFS(V) ((struct rdg_vertex *) ((V)->data))->datarefs\n #define RDGV_HAS_MEM_WRITE(V) ((struct rdg_vertex *) ((V)->data))->has_mem_write\n #define RDGV_HAS_MEM_READS(V) ((struct rdg_vertex *) ((V)->data))->has_mem_reads\n #define RDG_STMT(RDG, I) RDGV_STMT (&(RDG->vertices[I]))\n+#define RDG_DATAREFS(RDG, I) RDGV_DATAREFS (&(RDG->vertices[I]))\n #define RDG_MEM_WRITE_STMT(RDG, I) RDGV_HAS_MEM_WRITE (&(RDG->vertices[I]))\n #define RDG_MEM_READS_STMT(RDG, I) RDGV_HAS_MEM_READS (&(RDG->vertices[I]))\n \n@@ -608,7 +612,6 @@ index_in_loop_nest (int var, VEC (loop_p, heap) *loop_nest)\n void stores_from_loop (struct loop *, VEC (gimple, heap) **);\n void stores_zero_from_loop (struct loop *, VEC (gimple, heap) **);\n bool rdg_defs_used_in_other_loops_p (struct graph *, int);\n-bool have_similar_memory_accesses (gimple, gimple);\n bool stmt_with_adjacent_zero_store_dr_p (gimple);\n \n /* Returns true when STRIDE is equal in absolute value to the size of\n@@ -623,16 +626,6 @@ stride_of_unit_type_p (tree stride, tree type)\n \t\t\t\t TYPE_SIZE_UNIT (type)));\n }\n \n-/* Determines whether RDG vertices V1 and V2 access to similar memory\n-   locations, in which case they have to be in the same partition.  */\n-\n-static inline bool\n-rdg_has_similar_memory_accesses (struct graph *rdg, int v1, int v2)\n-{\n-  return have_similar_memory_accesses (RDG_STMT (rdg, v1),\n-\t\t\t\t       RDG_STMT (rdg, v2));\n-}\n-\n /* In tree-data-ref.c  */\n void split_constant_offset (tree , tree *, tree *);\n "}, {"sha": "f4476cbcf316e12c64be8115836baa8c58503052", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 46, "deletions": 3, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fa0c1800466eaf6c7cdec4a5c684975b379a07a/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fa0c1800466eaf6c7cdec4a5c684975b379a07a/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=1fa0c1800466eaf6c7cdec4a5c684975b379a07a", "patch": "@@ -878,24 +878,57 @@ classify_partition (loop_p loop, struct graph *rdg, partition_t partition)\n     partition->kind = PKIND_MEMSET;\n }\n \n+/* For a data reference REF, return the declaration of its base\n+   address or NULL_TREE if the base is not determined.  */\n+\n+static tree\n+ref_base_address (data_reference_p dr)\n+{\n+  tree base_address = DR_BASE_ADDRESS (dr);\n+  if (base_address\n+      && TREE_CODE (base_address) == ADDR_EXPR)\n+    return TREE_OPERAND (base_address, 0);\n+\n+  return base_address;\n+}\n+\n /* Returns true when PARTITION1 and PARTITION2 have similar memory\n    accesses in RDG.  */\n \n static bool\n similar_memory_accesses (struct graph *rdg, partition_t partition1,\n \t\t\t partition_t partition2)\n {\n-  unsigned i, j;\n+  unsigned i, j, k, l;\n   bitmap_iterator bi, bj;\n+  data_reference_p ref1, ref2;\n+\n+  /* First check whether in the intersection of the two partitions are\n+     any loads or stores.  Common loads are the situation that happens\n+     most often.  */\n+  EXECUTE_IF_AND_IN_BITMAP (partition1->stmts, partition2->stmts, 0, i, bi)\n+    if (RDG_MEM_WRITE_STMT (rdg, i)\n+\t|| RDG_MEM_READS_STMT (rdg, i))\n+      return true;\n \n+  /* Then check all data-references against each other.  */\n   EXECUTE_IF_SET_IN_BITMAP (partition1->stmts, 0, i, bi)\n     if (RDG_MEM_WRITE_STMT (rdg, i)\n \t|| RDG_MEM_READS_STMT (rdg, i))\n       EXECUTE_IF_SET_IN_BITMAP (partition2->stmts, 0, j, bj)\n \tif (RDG_MEM_WRITE_STMT (rdg, j)\n \t    || RDG_MEM_READS_STMT (rdg, j))\n-\t  if (rdg_has_similar_memory_accesses (rdg, i, j))\n-\t    return true;\n+\t  {\n+\t    FOR_EACH_VEC_ELT (data_reference_p, RDG_DATAREFS (rdg, i), k, ref1)\n+\t      {\n+\t\ttree base1 = ref_base_address (ref1);\n+\t\tif (base1)\n+\t\t  FOR_EACH_VEC_ELT (data_reference_p,\n+\t\t\t\t    RDG_DATAREFS (rdg, j), l, ref2)\n+\t\t    if (base1 == ref_base_address (ref2))\n+\t\t      return true;\n+\t      }\n+\t  }\n \n   return false;\n }\n@@ -1252,6 +1285,16 @@ tree_loop_distribution (void)\n   struct loop *loop;\n   loop_iterator li;\n   bool changed = false;\n+  basic_block bb;\n+\n+  FOR_ALL_BB (bb)\n+    {\n+      gimple_stmt_iterator gsi;\n+      for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\tgimple_set_uid (gsi_stmt (gsi), -1);\n+      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\tgimple_set_uid (gsi_stmt (gsi), -1);\n+    }\n \n   /* We can at the moment only distribute non-nested loops, thus restrict\n      walking to innermost loops.  */"}, {"sha": "93a785a5f913c3246f10a6ab1f1724e42e5d881f", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fa0c1800466eaf6c7cdec4a5c684975b379a07a/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fa0c1800466eaf6c7cdec4a5c684975b379a07a/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=1fa0c1800466eaf6c7cdec4a5c684975b379a07a", "patch": "@@ -4211,7 +4211,7 @@ vect_create_epilog_for_reduction (VEC (tree, heap) *vect_defs, gimple stmt,\n               orig_name = PHI_RESULT (exit_phi);\n               FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, orig_name)\n                 {\n-                  stmt_vec_info use_stmt_vinfo = vinfo_for_stmt (use_stmt);\n+                  stmt_vec_info use_stmt_vinfo;\n                   stmt_vec_info new_phi_vinfo;\n                   tree vect_phi_init, preheader_arg, vect_phi_res, init_def;\n                   basic_block bb = gimple_bb (use_stmt);\n@@ -4221,11 +4221,13 @@ vect_create_epilog_for_reduction (VEC (tree, heap) *vect_defs, gimple stmt,\n                      node.  */\n                   if (gimple_code (use_stmt) != GIMPLE_PHI\n                       || gimple_phi_num_args (use_stmt) != 2\n-                      || !use_stmt_vinfo\n-                      || STMT_VINFO_DEF_TYPE (use_stmt_vinfo)\n-                          != vect_double_reduction_def\n                       || bb->loop_father != outer_loop)\n                     continue;\n+                  use_stmt_vinfo = vinfo_for_stmt (use_stmt);\n+                  if (!use_stmt_vinfo\n+                      || STMT_VINFO_DEF_TYPE (use_stmt_vinfo)\n+                          != vect_double_reduction_def)\n+\t\t    continue;\n \n                   /* Create vector phi node for double reduction:\n                      vs1 = phi <vs0, vs2>"}]}