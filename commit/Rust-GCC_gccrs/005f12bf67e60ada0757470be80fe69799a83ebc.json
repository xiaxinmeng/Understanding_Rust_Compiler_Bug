{"sha": "005f12bf67e60ada0757470be80fe69799a83ebc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDA1ZjEyYmY2N2U2MGFkYTA3NTc0NzBiZTgwZmU2OTc5OWE4M2ViYw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2017-03-31T06:05:47Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2017-03-31T06:05:47Z"}, "message": "re PR debug/80025 (ICE w/ -O2 (-O3, -Ofast) -g -ftracer (infinite recursion in rtx_equal_for_cselib_1))\n\n\tPR debug/80025\n\t* cselib.h (rtx_equal_for_cselib_1): Add depth argument.\n\t(rtx_equal_for_cselib_p): Pass 0 to it.\n\t* cselib.c (cselib_hasher::equal): Likewise.\n\t(rtx_equal_for_cselib_1): Add depth argument.  If depth\n\tis 128, don't look up VALUE locs and punt.  Increment\n\tdepth in recursive calls when walking VALUE locs.\n\n\t* gcc.dg/torture/pr80025.c: New test.\n\nFrom-SVN: r246606", "tree": {"sha": "fed7ca22248ee3191aed93f460ee299ae4d40758", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fed7ca22248ee3191aed93f460ee299ae4d40758"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/005f12bf67e60ada0757470be80fe69799a83ebc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/005f12bf67e60ada0757470be80fe69799a83ebc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/005f12bf67e60ada0757470be80fe69799a83ebc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/005f12bf67e60ada0757470be80fe69799a83ebc/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "62a767024c694e9ab52b142689180979213e9684", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62a767024c694e9ab52b142689180979213e9684", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62a767024c694e9ab52b142689180979213e9684"}], "stats": {"total": 75, "additions": 62, "deletions": 13}, "files": [{"sha": "1dca2cfb1963b72e061ff3a5d26bb62346f0fa7e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/005f12bf67e60ada0757470be80fe69799a83ebc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/005f12bf67e60ada0757470be80fe69799a83ebc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=005f12bf67e60ada0757470be80fe69799a83ebc", "patch": "@@ -1,3 +1,13 @@\n+2017-03-31  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR debug/80025\n+\t* cselib.h (rtx_equal_for_cselib_1): Add depth argument.\n+\t(rtx_equal_for_cselib_p): Pass 0 to it.\n+\t* cselib.c (cselib_hasher::equal): Likewise.\n+\t(rtx_equal_for_cselib_1): Add depth argument.  If depth\n+\tis 128, don't look up VALUE locs and punt.  Increment\n+\tdepth in recursive calls when walking VALUE locs.\n+\n 2017-03-31  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n \n \t* gcov.c (md5sum_to_hex): Fix output of MD5 hex bytes."}, {"sha": "74c25ac1f97f89f0c7683f2044cf808e32cb0149", "filename": "gcc/cselib.c", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/005f12bf67e60ada0757470be80fe69799a83ebc/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/005f12bf67e60ada0757470be80fe69799a83ebc/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=005f12bf67e60ada0757470be80fe69799a83ebc", "patch": "@@ -125,7 +125,7 @@ cselib_hasher::equal (const cselib_val *v, const key *x_arg)\n   /* We don't guarantee that distinct rtx's have different hash values,\n      so we need to do a comparison.  */\n   for (l = v->locs; l; l = l->next)\n-    if (rtx_equal_for_cselib_1 (l->loc, x, memmode))\n+    if (rtx_equal_for_cselib_1 (l->loc, x, memmode, 0))\n       {\n \tpromote_debug_loc (l);\n \treturn true;\n@@ -834,7 +834,7 @@ autoinc_split (rtx x, rtx *off, machine_mode memmode)\n    addresses, MEMMODE should be VOIDmode.  */\n \n int\n-rtx_equal_for_cselib_1 (rtx x, rtx y, machine_mode memmode)\n+rtx_equal_for_cselib_1 (rtx x, rtx y, machine_mode memmode, int depth)\n {\n   enum rtx_code code;\n   const char *fmt;\n@@ -867,6 +867,9 @@ rtx_equal_for_cselib_1 (rtx x, rtx y, machine_mode memmode)\n       if (GET_CODE (y) == VALUE)\n \treturn e == canonical_cselib_val (CSELIB_VAL_PTR (y));\n \n+      if (depth == 128)\n+\treturn 0;\n+\n       for (l = e->locs; l; l = l->next)\n \t{\n \t  rtx t = l->loc;\n@@ -876,7 +879,7 @@ rtx_equal_for_cselib_1 (rtx x, rtx y, machine_mode memmode)\n \t     list.  */\n \t  if (REG_P (t) || MEM_P (t) || GET_CODE (t) == VALUE)\n \t    continue;\n-\t  else if (rtx_equal_for_cselib_1 (t, y, memmode))\n+\t  else if (rtx_equal_for_cselib_1 (t, y, memmode, depth + 1))\n \t    return 1;\n \t}\n \n@@ -887,13 +890,16 @@ rtx_equal_for_cselib_1 (rtx x, rtx y, machine_mode memmode)\n       cselib_val *e = canonical_cselib_val (CSELIB_VAL_PTR (y));\n       struct elt_loc_list *l;\n \n+      if (depth == 128)\n+\treturn 0;\n+\n       for (l = e->locs; l; l = l->next)\n \t{\n \t  rtx t = l->loc;\n \n \t  if (REG_P (t) || MEM_P (t) || GET_CODE (t) == VALUE)\n \t    continue;\n-\t  else if (rtx_equal_for_cselib_1 (x, t, memmode))\n+\t  else if (rtx_equal_for_cselib_1 (x, t, memmode, depth + 1))\n \t    return 1;\n \t}\n \n@@ -914,12 +920,12 @@ rtx_equal_for_cselib_1 (rtx x, rtx y, machine_mode memmode)\n       if (!xoff != !yoff)\n \treturn 0;\n \n-      if (xoff && !rtx_equal_for_cselib_1 (xoff, yoff, memmode))\n+      if (xoff && !rtx_equal_for_cselib_1 (xoff, yoff, memmode, depth))\n \treturn 0;\n \n       /* Don't recurse if nothing changed.  */\n       if (x != xorig || y != yorig)\n-\treturn rtx_equal_for_cselib_1 (x, y, memmode);\n+\treturn rtx_equal_for_cselib_1 (x, y, memmode, depth);\n \n       return 0;\n     }\n@@ -953,7 +959,8 @@ rtx_equal_for_cselib_1 (rtx x, rtx y, machine_mode memmode)\n     case MEM:\n       /* We have to compare any autoinc operations in the addresses\n \t using this MEM's mode.  */\n-      return rtx_equal_for_cselib_1 (XEXP (x, 0), XEXP (y, 0), GET_MODE (x));\n+      return rtx_equal_for_cselib_1 (XEXP (x, 0), XEXP (y, 0), GET_MODE (x),\n+\t\t\t\t     depth);\n \n     default:\n       break;\n@@ -988,17 +995,20 @@ rtx_equal_for_cselib_1 (rtx x, rtx y, machine_mode memmode)\n \t  /* And the corresponding elements must match.  */\n \t  for (j = 0; j < XVECLEN (x, i); j++)\n \t    if (! rtx_equal_for_cselib_1 (XVECEXP (x, i, j),\n-\t\t\t\t\t  XVECEXP (y, i, j), memmode))\n+\t\t\t\t\t  XVECEXP (y, i, j), memmode, depth))\n \t      return 0;\n \t  break;\n \n \tcase 'e':\n \t  if (i == 1\n \t      && targetm.commutative_p (x, UNKNOWN)\n-\t      && rtx_equal_for_cselib_1 (XEXP (x, 1), XEXP (y, 0), memmode)\n-\t      && rtx_equal_for_cselib_1 (XEXP (x, 0), XEXP (y, 1), memmode))\n+\t      && rtx_equal_for_cselib_1 (XEXP (x, 1), XEXP (y, 0), memmode,\n+\t\t\t\t\t depth)\n+\t      && rtx_equal_for_cselib_1 (XEXP (x, 0), XEXP (y, 1), memmode,\n+\t\t\t\t\t depth))\n \t    return 1;\n-\t  if (! rtx_equal_for_cselib_1 (XEXP (x, i), XEXP (y, i), memmode))\n+\t  if (! rtx_equal_for_cselib_1 (XEXP (x, i), XEXP (y, i), memmode,\n+\t\t\t\t\tdepth))\n \t    return 0;\n \t  break;\n "}, {"sha": "dd949196b7d4a46f2b157ae3874241ee116d022d", "filename": "gcc/cselib.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/005f12bf67e60ada0757470be80fe69799a83ebc/gcc%2Fcselib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/005f12bf67e60ada0757470be80fe69799a83ebc/gcc%2Fcselib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.h?ref=005f12bf67e60ada0757470be80fe69799a83ebc", "patch": "@@ -82,7 +82,7 @@ extern void cselib_finish (void);\n extern void cselib_process_insn (rtx_insn *);\n extern bool fp_setter_insn (rtx_insn *);\n extern machine_mode cselib_reg_set_mode (const_rtx);\n-extern int rtx_equal_for_cselib_1 (rtx, rtx, machine_mode);\n+extern int rtx_equal_for_cselib_1 (rtx, rtx, machine_mode, int);\n extern int references_value_p (const_rtx, int);\n extern rtx cselib_expand_value_rtx (rtx, bitmap, int);\n typedef rtx (*cselib_expand_callback)(rtx, bitmap, int, void *);\n@@ -134,7 +134,7 @@ rtx_equal_for_cselib_p (rtx x, rtx y)\n   if (x == y)\n     return 1;\n \n-  return rtx_equal_for_cselib_1 (x, y, VOIDmode);\n+  return rtx_equal_for_cselib_1 (x, y, VOIDmode, 0);\n }\n \n #endif /* GCC_CSELIB_H */"}, {"sha": "1b30193e01b927241648e0b36f1d057c1d6f0c84", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/005f12bf67e60ada0757470be80fe69799a83ebc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/005f12bf67e60ada0757470be80fe69799a83ebc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=005f12bf67e60ada0757470be80fe69799a83ebc", "patch": "@@ -1,3 +1,8 @@\n+2017-03-31  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR debug/80025\n+\t* gcc.dg/torture/pr80025.c: New test.\n+\n 2017-03-30  Matthew Fortune  <matthew.fortune@imgtec.com>\n \n \t* gcc.target/mips/pr52125.c: Add -msym32."}, {"sha": "e53eaad61995642446d0f721047d17daae2dfd7b", "filename": "gcc/testsuite/gcc.dg/torture/pr80025.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/005f12bf67e60ada0757470be80fe69799a83ebc/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr80025.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/005f12bf67e60ada0757470be80fe69799a83ebc/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr80025.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr80025.c?ref=005f12bf67e60ada0757470be80fe69799a83ebc", "patch": "@@ -0,0 +1,24 @@\n+/* PR debug/80025 */\n+/* { dg-do compile } */\n+/* { dg-options \"-g -ftracer -w\" } */\n+\n+int a;\n+long int b, c;\n+\n+long int\n+foo (void)\n+{\n+}\n+\n+void\n+bar (int x, short int y, unsigned short int z)\n+{\n+}\n+\n+int\n+baz (void)\n+{\n+  a -= b;\n+  b = !foo ();\n+  bar (b ^= (c ^ 1) ? (c ^ 1) : foo (), (__INTPTR_TYPE__) &bar, a);\n+}"}]}