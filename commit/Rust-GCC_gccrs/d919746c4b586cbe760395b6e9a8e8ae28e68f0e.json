{"sha": "d919746c4b586cbe760395b6e9a8e8ae28e68f0e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDkxOTc0NmM0YjU4NmNiZTc2MDM5NWI2ZTlhOGU4YWUyOGU2OGYwZQ==", "commit": {"author": {"name": "Dave Love", "email": "fx@gcc.gnu.org", "date": "1998-09-08T14:58:01Z"}, "committer": {"name": "Dave Love", "email": "fx@gcc.gnu.org", "date": "1998-09-08T14:58:01Z"}, "message": "New file, somewhat altered from libf2c/libU77 version.\n\nFrom-SVN: r22332", "tree": {"sha": "1417d55893c8afa1ad475feb6716d198bb17fbbb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1417d55893c8afa1ad475feb6716d198bb17fbbb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d919746c4b586cbe760395b6e9a8e8ae28e68f0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d919746c4b586cbe760395b6e9a8e8ae28e68f0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d919746c4b586cbe760395b6e9a8e8ae28e68f0e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d919746c4b586cbe760395b6e9a8e8ae28e68f0e/comments", "author": null, "committer": null, "parents": [{"sha": "5f5fc7ebfddbb3ce685fe1dc625ac59b111af686", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f5fc7ebfddbb3ce685fe1dc625ac59b111af686", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f5fc7ebfddbb3ce685fe1dc625ac59b111af686"}], "stats": {"total": 296, "additions": 296, "deletions": 0}, "files": [{"sha": "5219f3442f1d88c4b54dd8ed0f8f097a0b6f091e", "filename": "gcc/testsuite/g77.f-torture/execute/u77-test.f", "status": "added", "additions": 296, "deletions": 0, "changes": 296, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d919746c4b586cbe760395b6e9a8e8ae28e68f0e/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Fu77-test.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d919746c4b586cbe760395b6e9a8e8ae28e68f0e/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Fu77-test.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Fu77-test.f?ref=d919746c4b586cbe760395b6e9a8e8ae28e68f0e", "patch": "@@ -0,0 +1,296 @@\n+***   Some random stuff for testing libU77.  Should be done better.  It's\n+*     hard to test things where you can't guarantee the result.  Have a\n+*     good squint at what it prints, though detected errors will cause \n+*     starred messages.\n+\n+      implicit none\n+      integer i, j, k, ltarray (9), idat (3), count, rate, count_max,\n+     +     pid, mask\n+      real tarray1(2), tarray2(2), r1, r2, sum\n+      intrinsic getpid, getuid, getgid, ierrno, gerror,\n+     +     fnum, isatty, getarg, access, unlink, fstat,\n+     +     stat, lstat, getcwd, gmtime, hostnm, etime, chmod,\n+     +     chdir, fgetc, fputc, system_clock, second, idate, secnds,\n+     +     time, ctime, fdate, ttynam, date_and_time\n+      external lenstr, ctrlc\n+      integer lenstr\n+      logical l\n+      character gerr*80, c*1\n+      character ctim*25, line*80, lognam*20, wd*100, line2*80, ddate*8,\n+     +     ttime*10, zone*5\n+      integer fstatb (13), statb (13)\n+      integer *2 i2zero\n+      integer values(8)\n+      integer(kind=7) sigret\n+\n+      ctim = ctime(time())\n+      WRITE (6,'(A/)') '1 GNU libU77 test at: ' // ctim\n+      write (6,'(A,I3,'', '',I3)')\n+     +     ' Logical units 5 and 6 correspond (FNUM) to'\n+     +     // ' Unix i/o units ', fnum(5), fnum(6)\n+      if (lnblnk('foo ').ne.3 .or. len_trim('foo ').ne.3) then\n+        print *, 'LNBLNK or LEN_TRIM failed'\n+        call abort\n+      end if\n+      l= isatty(6)\n+      line2 = ttynam(6)\n+      if (l) then\n+        line = 'and 6 is a tty device (ISATTY) named '//line2\n+      else\n+        line = 'and 6 isn''t a tty device (ISATTY)'\n+      end if\n+      write (6,'(1X,A)') line(:lenstr(line))\n+      \n+*     regression test for compiler crash fixed by JCB 1998-08-04 com.c\n+      sigret = signal(2, ctrlc)\n+\n+      pid = getpid()\n+      WRITE (6,'(A,I10)') ' Process id (GETPID): ', pid\n+      WRITE (6,'(A,I10)') ' User id (GETUID): ', GETUID ()\n+      WRITE (6,'(A,I10)') ' Group id (GETGID): ', GETGID ()\n+      WRITE (6, *) 'If you have the `id'' program, the following call'\n+      write (6, *) 'of SYSTEM should agree with the above:'\n+      call flush(6)\n+      CALL SYSTEM ('echo \" \" `id`')\n+      call flush\n+      lognam = 'blahblahblah'\n+      call getlog (lognam)\n+      write (6,*) 'Login name (GETLOG): ', lognam\n+      call umask(0, mask)\n+      write(6,*) 'UMASK returns', mask\n+      call umask(mask)\n+\n+      ctim = fdate()\n+      write (6,*) 'FDATE returns: ', ctim\n+      j=time()\n+      call ltime (j, ltarray)\n+      write (6,'(1x,a,9i4)') 'LTIME returns:', ltarray\n+      call gmtime (j, ltarray)\n+      write (6,'(1x,a,9i4)') 'GMTIME returns:', ltarray\n+      call system_clock(count)  ! omitting optional args\n+      call system_clock(count, rate, count_max)\n+      write(6,*) 'SYSTEM_CLOCK returns: ', count, rate, count_max\n+      call date_and_time(ddate)  ! omitting optional args\n+      call date_and_time(ddate, ttime, zone, values)\n+      write(6, *) 'DATE_AND_TIME returns: ', ddate, ' ', ttime, ' ',\n+     +     zone, ' ', values\n+\n+      write (6,*) 'Sleeping for 1 second (SLEEP) ...'\n+      call sleep (1)\n+\n+c consistency-check etime vs. dtime for first call\n+      r1 = etime (tarray1)\n+      if (r1.ne.tarray1(1)+tarray1(2)) then\n+        write (6,*) '*** ETIME didn''t return sum of the array: ',\n+     +       r1, ' /= ', tarray1(1), '+', tarray1(2)\n+        call abort\n+      end if\n+      r2 = dtime (tarray2)\n+      if (abs (r1-r2).gt.1.0) then\n+        write (6,*)\n+     +       'Results of ETIME and DTIME differ by more than a second:',\n+     +       r1, r2\n+      call abort\n+      end if\n+      call sgladd (sum, tarray1(1), tarray1(2))\n+      if (r1 .ne. sum) then\n+        write (6,*) '*** ETIME didn''t return sum of the array: ',\n+     +       r1, ' /= ', tarray1(1), '+', tarray1(2)\n+        call abort\n+      end if\n+      call sgladd (sum, tarray2(1), tarray2(2))\n+      if (r2 .ne. sum) then\n+        write (6,*) '*** DTIME didn''t return sum of the array: ',\n+     +       r2, ' /= ', tarray2(1), '+', tarray2(2)\n+        call abort\n+      end if\n+      write (6, '(A,3F10.3)')\n+     +     ' Elapsed total, user, system time (ETIME): ',\n+     +     r1, tarray1\n+\n+c now try to get times to change enough to see in etime/dtime\n+      write (6,*) 'Looping until clock ticks at least once...'\n+      do i = 1,1000\n+      do j = 1,1000\n+      end do\n+      r2 = dtime (tarray2)\n+      if (tarray2(1) .ne. 0. .or. tarray2(2) .ne. 0.) exit\n+      end do\n+      r1 = etime (tarray1)\n+      call sgladd (sum, tarray1(1), tarray1(2))\n+      if (r1 .ne. sum) then\n+        write (6,*) '*** ETIME didn''t return sum of the array: ',\n+     +       r1, ' /= ', tarray1(1), '+', tarray1(2)\n+        call abort\n+      end if\n+      call sgladd (sum, tarray2(1), tarray2(2))\n+      if (r2 .ne. sum) then\n+        write (6,*) '*** DTIME didn''t return sum of the array: ',\n+     +       r2, ' /= ', tarray2(1), '+', tarray2(2)\n+        call abort\n+      end if\n+      write (6, '(A,3F10.3)')\n+     +     ' Differences in total, user, system time (DTIME): ',\n+     +     r2, tarray2\n+      write (6, '(A,3F10.3)')\n+     +     ' Elapsed total, user, system time (ETIME): ',\n+     +     r1, tarray1\n+      write (6, *) '(Clock-tick detected after ', i, ' 1K loops.)'\n+\n+      call idate (i,j,k)\n+      call idate (idat)\n+      write (6,*) 'IDATE d,m,y: ',idat\n+      print *,  '... and the VXT version: ', i,j,k\n+      if (i/=idat(2) .or. j/=idat(1) .or. k/=idat(3)) then\n+        print *, '*** vxy and u77 versions don''t agree'\n+        call abort\n+      end if\n+      call time(line(:8))\n+      print *, 'TIME: ', line(:8)\n+      write (6,*) 'SECNDS(0.0) returns: ',secnds(0.0)\n+      write (6,*) 'SECOND returns: ', second()\n+      call dumdum(r1)\n+      call second(r1)\n+      write (6,*) 'CALL SECOND returns: ', r1\n+      i = getcwd(wd)\n+      if (i.ne.0) then\n+        call perror ('*** getcwd')\n+        call abort\n+      else\n+        write (6,*) 'Current directory is \"'//wd(:lenstr(wd))//'\"'\n+      end if\n+      call chdir ('.',i)\n+      if (i.ne.0) then\n+        write (6,*) '***CHDIR to \".\": ', i\n+        call abort\n+      end if\n+      i=hostnm(wd)\n+      if(i.ne.0) then\n+        call perror ('*** hostnm')\n+        call abort\n+      else\n+        write (6,*) 'Host name is ', wd(:lenstr(wd))\n+      end if\n+      i = access('/dev/null ', 'rw')\n+      if (i.ne.0) write (6,*) '***Read/write ACCESS to /dev/null: ', i\n+      write (6,*) 'Creating file \"foo\" for testing...'\n+      open (3,file='foo',status='UNKNOWN')\n+      rewind 3\n+      call fputc(3, 'c',i)\n+      call fputc(3, 'd',j)      \n+      if (i+j.ne.0) write(6,*) '***FPUTC: ', i\n+C     why is it necessary to reopen?  (who wrote this?)\n+C     the better to test with, my dear!  (-- burley)\n+      close(3)\n+      open(3,file='foo',status='old')\n+      call fseek(3,0,0,*10)\n+      go to 20\n+ 10   write(6,*) '***FSEEK failed'\n+      call abort\n+ 20   call fgetc(3, c,i)\n+      if (i.ne.0) then\n+        write(6,*) '***FGETC: ', i\n+        call abort\n+      end if\n+      if (c.ne.'c') then\n+        write(6,*) '***FGETC read the wrong thing: ', ichar(c)\n+        call abort\n+      end if\n+      i= ftell(3)\n+      if (i.ne.1) then\n+        write(6,*) '***FTELL offset: ', i\n+        call abort\n+      end if\n+      call chmod ('foo', 'a+w',i)\n+      if (i.ne.0) then\n+        write (6,*) '***CHMOD of \"foo\": ', i\n+        call abort\n+      end if\n+      i = fstat (3, fstatb)\n+      if (i.ne.0) then\n+        write (6,*) '***FSTAT of \"foo\": ', i\n+        call abort\n+      end if\n+      i = stat ('foo', statb)\n+      if (i.ne.0) then\n+        write (6,*) '***STAT of \"foo\": ', i\n+        call abort\n+      end if\n+      write (6,*) '  with stat array ', statb\n+      if (statb(5).ne.getuid () .or. statb(6).ne.getgid() .or. statb(4)\n+     +     .ne. 1) then\n+        write (6,*) '*** FSTAT uid, gid or nlink is wrong'\n+        call abort\n+      end if\n+      do i=1,13\n+        if (fstatb (i) .ne. statb (i)) then\n+          write (6,*) '*** FSTAT and STAT don''t agree on '// '\n+     +         array element ', i, ' value ', fstatb (i), statb (i)\n+          call abort\n+        end if\n+      end do\n+      i = lstat ('foo', fstatb)\n+      do i=1,13\n+        if (fstatb (i) .ne. statb (i)) then\n+          write (6,*) '*** LSTAT and STAT don''t agree on '// '\n+     +         array element ', i, ' value ', fstatb (i), statb (i)\n+          call abort\n+        end if\n+      end do\n+\n+C     in case it exists already:\n+      call unlink ('bar',i)\n+      call link ('foo ', 'bar ',i)\n+      if (i.ne.0) then\n+        write (6,*) '***LINK \"foo\" to \"bar\" failed: ', i\n+        call abort\n+      end if\n+      call unlink ('foo',i)\n+      if (i.ne.0) then\n+        write (6,*) '***UNLINK \"foo\" failed: ', i\n+        call abort\n+      end if\n+      call unlink ('foo',i)\n+      if (i.eq.0) then\n+        write (6,*) '***UNLINK \"foo\" again: ', i\n+        call abort\n+      end if\n+      call gerror (gerr)\n+      i = ierrno()\n+      write (6,'(A,I3,A/1X,A)') ' The current error number is: ',\n+     +     i,\n+     +     ' and the corresponding message is:', gerr(:lenstr(gerr))\n+      write (6,*) 'This is sent to stderr prefixed by the program name'\n+      call getarg (0, line)\n+      call perror (line (:lenstr (line)))\n+      call unlink ('bar')\n+C      WRITE (6,*) 'You should see exit status 1'\n+      CALL EXIT(0)\n+ 99   END\n+\n+      integer function lenstr (str)\n+C     return length of STR not including trailing blanks, but always\n+C     return >0\n+      character *(*) str\n+      if (str.eq.' ') then\n+        lenstr=1\n+      else\n+        lenstr = lnblnk (str)\n+      end if\n+      end\n+* just make sure SECOND() doesn't \"magically\" work the second time.\n+      subroutine dumdum(r)\n+      r = 3.14159\n+      end\n+* do an add that is most likely to be done in single precision.\n+      subroutine sgladd(sum,left,right)\n+      implicit none\n+      real sum,left,right\n+      sum = left+right\n+      end\n+\n+*     signal handler\n+      subroutine ctrlc\n+      print *, 'Got ^C'\n+      call abort\n+      end"}]}