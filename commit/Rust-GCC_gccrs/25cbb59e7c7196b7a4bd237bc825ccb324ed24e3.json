{"sha": "25cbb59e7c7196b7a4bd237bc825ccb324ed24e3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjVjYmI1OWU3YzcxOTZiN2E0YmQyMzdiYzgyNWNjYjMyNGVkMjRlMw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-04-01T12:02:06Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-04-01T12:02:06Z"}, "message": "General code cleanup.\n\nAdd prototypes for static functions.\nRemove unnecessary casts to (char *); add casts to (U_CHAR *).\nAdd parentheses suggested by `gcc -Wparentheses'.\nRename local variables as suggested by `gcc -Wshadow'.\n<fcntl.h>, <stdlib.h>, <string.h>, <unistd.h>: New includes.\n<sys/time.h>, <sys/resource.h>: Include only if defined(RLIMIT_STACK).\n<time.h>: Include, unless <sys/time.h> already does.\n(HAVE_FCNTL_H, HAVE_STDLIB_H, HAVE_SYS_TIME_H): New symbols.\n(HAVE_UNISTD_H, STDC_HEADERS, TIME_WITH_SYS_TIME): Likewise.\n(__attribute__, PROTO, VA_START, PRINTF_ALIST, PRINTF_DCL): New macros.\n(PRINTF_PROTO{,_1,_2,_3}, DO_PROTO): Likewise.\n(bcopy, bzero, bcmp): If #defined by configuration file, use that.\nIf STDC_HEADERS is defined, use standard C functions.\nIf BSTRING is defined, or USG and VMS are not defined, use\nthe C library.  Otherwise, use my_bcopy, my_bzero, my_bcmp.\n(localtime): Remove no-longer-necessary explicit declaration.\n(getenv, index, rindex): Don't declare explicitly if the appropriate system\neader should declare it.\n(fdopen): Remove no-longer-used declaration.\n(vprintf): Define a subsitute macro if !defined(HAVE_VPRINTF).\n(main): Replace `fdopen (dup (fileno (stdout)), \"w\"))' with `stdout'.\n(get_lintcmd, rescan, create_definition): Use bcmp instead of strncmp when both\noperands are known to be free of null bytes.\n(check_macro_name, compare_defs, collect_expansion): Likewise.\n(do_assert, compare_token_lists, assertion_lookup, do_line): Likewise.\n(skip_if_group, lookup): Likewise.\n(rescan): Remove unused label `startagain'.\nAbort instead of printing nonsense if the stack is corrupted when there was an\nunterminated successful conditional.\n(pcfinclude): Include explicit double-cast through GENERICPTR to identify\nparticularly egregious type puns.\n(create_definition, do_define, check_macro_name): Use %.*s printf format to\navoid painful copying-and-casting.\n(do_once): Return void, not (unused) int.\n(do_ident, do_pragma, do_sccs): Accept extra arguments so that all\ndirective-handler's types match.\n(do_sccs): Define only if SCCS_DIRECTIVE is defined.\n(skip_if_group, dump_single_macro): Add `default: break;' to keep -Wswitch\nhappy.\n(error, warning, error_with_line, vwarning_with_line, pedwarn): Use\nstdarg/vararg/vfprintf instead of passing bogus char * args around.\n(pedwarn_with_line, pedwarn_with_file_and_line, fatal):  Likewise.\n(verror, vwarning, verror_with_line, vwarning_with_line): New fcns.\n(dump_single_macro): Abort if ap points to garbage.\n(make_definition, make_undef, make_assertion): Parameter now char *.\n(xmalloc, xrealloc, xcalloc, savestring, index0): Make sizes size_t\ninstead of unsigned; make pointer parameters GENERICPTR, not char *.\n(xcalloc): Use bzero to clear memory instead of using own loop.\n\nFrom-SVN: r9278", "tree": {"sha": "edc8f36367448824d407fe6a733d892632f782c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/edc8f36367448824d407fe6a733d892632f782c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/25cbb59e7c7196b7a4bd237bc825ccb324ed24e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25cbb59e7c7196b7a4bd237bc825ccb324ed24e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25cbb59e7c7196b7a4bd237bc825ccb324ed24e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25cbb59e7c7196b7a4bd237bc825ccb324ed24e3/comments", "author": null, "committer": null, "parents": [{"sha": "3378918eed6e1f5b263726908c2d7f9b8e5f6b68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3378918eed6e1f5b263726908c2d7f9b8e5f6b68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3378918eed6e1f5b263726908c2d7f9b8e5f6b68"}], "stats": {"total": 1009, "additions": 597, "deletions": 412}, "files": [{"sha": "59d1cdd34081282f2ab527fc3494e8fac9f19fed", "filename": "gcc/cccp.c", "status": "modified", "additions": 597, "deletions": 412, "changes": 1009, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25cbb59e7c7196b7a4bd237bc825ccb324ed24e3/gcc%2Fcccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25cbb59e7c7196b7a4bd237bc825ccb324ed24e3/gcc%2Fcccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcccp.c?ref=25cbb59e7c7196b7a4bd237bc825ccb324ed24e3", "patch": "@@ -62,33 +62,174 @@ typedef unsigned char U_CHAR;\n #define PATH_SEPARATOR ':'\n #endif\n \n-/* In case config.h defines these.  */\n-#undef bcopy\n-#undef bzero\n-#undef bcmp\n-\n #include <sys/types.h>\n #include <sys/stat.h>\n #include <ctype.h>\n #include <stdio.h>\n #include <signal.h>\n \n-#ifndef VMS\n-#ifndef USG\n-#include <sys/time.h>\t\t/* for __DATE__ and __TIME__ */\n-#include <sys/resource.h>\n+/* The following symbols should be autoconfigured:\n+\tHAVE_FCNTL_H\n+\tHAVE_STDLIB_H\n+\tHAVE_SYS_TIME_H\n+\tHAVE_UNISTD_H\n+\tSTDC_HEADERS\n+\tTIME_WITH_SYS_TIME\n+   In the mean time, we'll get by with approximations based\n+   on existing GCC configuration symbols.  */\n+\n+#ifdef POSIX\n+# ifndef HAVE_STDLIB_H\n+# define HAVE_STDLIB_H 1\n+# endif\n+# ifndef HAVE_UNISTD_H\n+# define HAVE_UNISTD_H 1\n+# endif\n+# ifndef STDC_HEADERS\n+# define STDC_HEADERS 1\n+# endif\n+#endif /* defined (POSIX) */\n+\n+#if defined (POSIX) || (defined (USG) && !defined (VMS))\n+# ifndef HAVE_FCNTL_H\n+# define HAVE_FCNTL_H 1\n+# endif\n+#endif\n+\n+#ifndef RLIMIT_STACK\n+# include <time.h>\n #else\n-#include <time.h>\n-#include <fcntl.h>\n-#endif /* USG */\n-#endif /* not VMS */\n+# if TIME_WITH_SYS_TIME\n+#  include <sys/time.h>\n+#  include <time.h>\n+# else\n+#  if HAVE_SYS_TIME_H\n+#   include <sys/time.h>\n+#  else\n+#   include <time.h>\n+#  endif\n+# endif\n+# include <sys/resource.h>\n+#endif\n+\n+#if HAVE_FCNTL_H\n+# include <fcntl.h>\n+#endif\n \n /* This defines \"errno\" properly for VMS, and gives us EACCES. */\n #include <errno.h>\n \n+#if HAVE_STDLIB_H\n+# include <stdlib.h>\n+#else\n+char *getenv ();\n+#endif\n+\n+#if STDC_HEADERS\n+# include <string.h>\n+# ifndef bcmp\n+# define bcmp(a, b, n) memcmp (a, b, n)\n+# endif\n+# ifndef bcopy\n+# define bcopy(s, d, n) memcpy (d, s, n)\n+# endif\n+# ifndef bzero\n+# define bzero(d, n) memset (d, 0, n)\n+# endif\n+#else /* !STDC_HEADERS */\n+char *index ();\n+char *rindex ();\n+\n+# if !defined (BSTRING) && (defined (USG) || defined (VMS))\n+\n+#  ifndef bcmp\n+#  define bcmp my_bcmp\n+static int\n+my_bcmp (a, b, n)\n+     register char *a;\n+     register char *b;\n+     register unsigned n;\n+{\n+   while (n-- > 0)\n+     if (*a++ != *b++)\n+       return 1;\n+\n+   return 0;\n+}\n+#  endif /* !defined (bcmp) */\n+\n+#  ifndef bcopy\n+#  define bcopy my_bcopy\n+static void\n+my_bcopy (s, d, n)\n+     register char *s;\n+     register char *d;\n+     register unsigned n;\n+{\n+  while (n-- > 0)\n+    *d++ = *s++;\n+}\n+#  endif /* !defined (bcopy) */\n+\n+#  ifndef bzero\n+#  define bzero my_bzero\n+static void\n+my_bzero (b, length)\n+     register char *b;\n+     register unsigned length;\n+{\n+  while (length-- > 0)\n+    *b++ = 0;\n+}\n+#  endif /* !defined (bzero) */\n+\n+# endif /* !defined (BSTRING) && (defined (USG) || defined (VMS)) */\n+#endif /* ! STDC_HEADERS */\n+\n+#if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 6)\n+# define __attribute__(x)\n+#endif\n+\n+#ifndef PROTO\n+# if defined (USE_PROTOTYPES) ? USE_PROTOTYPES : defined (__STDC__)\n+#  define PROTO(ARGS) ARGS\n+# else\n+#  define PROTO(ARGS) ()\n+# endif\n+#endif\n+\n+#if defined (__STDC__) && defined (HAVE_VPRINTF)\n+# include <stdarg.h>\n+# define VA_START(va_list, var) va_start (va_list, var)\n+# define PRINTF_ALIST(msg) char *msg, ...\n+# define PRINTF_DCL(msg)\n+# define PRINTF_PROTO(ARGS, m, n) PROTO (ARGS) __attribute__ ((format (printf, m, n)))\n+#else\n+# include <varargs.h>\n+# define VA_START(va_list, var) va_start (va_list)\n+# define PRINTF_ALIST(msg) msg, va_alist\n+# define PRINTF_DCL(msg) char *msg; va_dcl\n+# define PRINTF_PROTO(ARGS, m, n) () __attribute__ ((format (printf, m, n)))\n+# define vfprintf(file, msg, args) \\\n+    { \\\n+      char *a0 = va_arg(args, char *); \\\n+      char *a1 = va_arg(args, char *); \\\n+      char *a2 = va_arg(args, char *); \\\n+      char *a3 = va_arg(args, char *); \\\n+      fprintf (file, msg, a0, a1, a2, a3); \\\n+    }\n+#endif\n+\n+#define PRINTF_PROTO_1(ARGS) PRINTF_PROTO(ARGS, 1, 2)\n+#define PRINTF_PROTO_2(ARGS) PRINTF_PROTO(ARGS, 2, 3)\n+#define PRINTF_PROTO_3(ARGS) PRINTF_PROTO(ARGS, 3, 4)\n+\n+#if HAVE_UNISTD_H\n+# include <unistd.h>\n+#endif\n+\n /* VMS-specific definitions */\n #ifdef VMS\n-#include <time.h>\n #include <descrip.h>\n #define O_RDONLY\t0\t/* Open arg for Read/Only  */\n #define O_WRONLY\t1\t/* Open arg for Write/Only */\n@@ -112,9 +253,6 @@ typedef struct { unsigned :16, :16, :16; } vms_ino_t;\n #define BSTRING\t\t\t/* VMS/GCC supplies the bstring routines */\n #endif /* __GNUC__ */\n #endif /* VMS */\n-  \n-extern char *index ();\n-extern char *rindex ();\n \n #ifndef O_RDONLY\n #define O_RDONLY 0\n@@ -169,18 +307,9 @@ extern char *rindex ();\n #define INCLUDE_LEN_FUDGE 0\n #endif\n \n-/* Forward declarations.  */\n-\n-char *xmalloc ();\n-void error ();\n-void warning ();\n-\n /* External declarations.  */\n \n-extern char *getenv ();\n-extern FILE *fdopen ();\n extern char *version_string;\n-extern struct tm *localtime ();\n #ifndef VMS\n #ifndef HAVE_STRERROR\n extern int sys_nerr;\n@@ -195,137 +324,12 @@ char *strerror ();\n #else\t/* VMS */\n char *strerror (int,...);\n #endif\n-extern int parse_escape ();\n-extern HOST_WIDE_INT parse_c_expression ();\n+int parse_escape PROTO((char **));\n+HOST_WIDE_INT parse_c_expression PROTO((char *));\n \n #ifndef errno\n extern int errno;\n #endif\n-\n-/* Forward declarations.  */\n-\n-struct directive;\n-struct file_buf;\n-struct arglist;\n-struct argdata;\n-\n-#if defined(USG) || defined(VMS)\n-#ifndef BSTRING\n-void bcopy ();\n-void bzero ();\n-int bcmp ();\n-#endif\n-#endif\n-\n-/* These functions are declared to return int instead of void since they\n-   are going to be placed in a table and some old compilers have trouble with\n-   pointers to functions returning void.  */\n-\n-static int do_define ();\n-static int do_line ();\n-static int do_include ();\n-static int do_undef ();\n-static int do_error ();\n-static int do_pragma ();\n-static int do_ident ();\n-static int do_if ();\n-static int do_xifdef ();\n-static int do_else ();\n-static int do_elif ();\n-static int do_endif ();\n-static int do_sccs ();\n-static int do_once ();\n-static int do_assert ();\n-static int do_unassert ();\n-static int do_warning ();\n-\n-static void add_import ();\n-static void append_include_chain ();\n-static void deps_output ();\n-static void make_undef ();\n-static void make_definition ();\n-static void make_assertion ();\n-static void path_include ();\n-static void initialize_builtins ();\n-static void initialize_char_syntax ();\n-static void dump_arg_n ();\n-static void dump_defn_1 ();\n-static void delete_macro ();\n-static void trigraph_pcp ();\n-static void rescan ();\n-static void finclude ();\n-static void validate_else ();\n-static int comp_def_part ();\n-static void error_from_errno ();\n-static void error_with_line ();\n-void pedwarn ();\n-void pedwarn_with_line ();\n-static void pedwarn_with_file_and_line ();\n-static void fatal ();\n-void fancy_abort ();\n-static void pfatal_with_name ();\n-static void perror_with_name ();\n-static void pipe_closed ();\n-static void print_containing_files ();\n-static int lookup_import ();\n-static int redundant_include_p ();\n-static is_system_include ();\n-static struct file_name_map *read_name_map ();\n-static char *read_filename_string ();\n-static int open_include_file ();\n-static int check_preconditions ();\n-static void pcfinclude ();\n-static void pcstring_used ();\n-static void write_output ();\n-static int check_macro_name ();\n-static int compare_defs ();\n-static int compare_token_lists ();\n-static HOST_WIDE_INT eval_if_expression ();\n-static int discard_comments ();\n-static int change_newlines ();\n-static int line_for_error ();\n-static int hashf ();\n-static int file_size_and_mode ();\n-\n-static struct arglist *read_token_list ();\n-static void free_token_list ();\n-\n-static struct hashnode *install ();\n-struct hashnode *lookup ();\n-\n-static struct assertion_hashnode *assertion_install ();\n-static struct assertion_hashnode *assertion_lookup ();\n-\n-static char *xrealloc ();\n-static char *xcalloc ();\n-static char *savestring ();\n-\n-static void delete_assertion ();\n-static void macroexpand ();\n-static void dump_all_macros ();\n-static void conditional_skip ();\n-static void skip_if_group ();\n-static void output_line_directive ();\n-\n-/* Last arg to output_line_directive.  */\n-enum file_change_code {same_file, enter_file, leave_file};\n-\n-static int grow_outbuf ();\n-static int handle_directive ();\n-static void memory_full ();\n-\n-static U_CHAR *macarg1 ();\n-static char *macarg ();\n-\n-static U_CHAR *skip_to_end_of_comment ();\n-static U_CHAR *skip_quoted_string ();\n-static U_CHAR *skip_paren_group ();\n-static char *quote_string ();\n-\n-static char *check_precompiled ();\n-/* static struct macrodef create_definition ();\t[moved below] */\n-static void dump_single_macro ();\n-static void output_dots ();\n \f\n #ifndef FAILURE_EXIT_CODE\n #define FAILURE_EXIT_CODE 33\t/* gnu cc command understands this */\n@@ -673,9 +677,6 @@ struct macrodef\n   U_CHAR *symnam;\n   int symlen;\n };\n-\n-static struct macrodef create_definition ();\n-\n \f\n enum sharp_token_type {\n   NO_SHARP_TOKEN,\t\t/* token not present */\n@@ -923,16 +924,41 @@ static int assertions_flag;\n \f\n /* `struct directive' defines one #-directive, including how to handle it.  */\n \n+#define DO_PROTO PROTO((U_CHAR *, U_CHAR *, FILE_BUF *, struct directive *))\n+\n struct directive {\n   int length;\t\t\t/* Length of name */\n-  int (*func)();\t\t/* Function to handle directive */\n+  int (*func) DO_PROTO;\t/* Function to handle directive */\n   char *name;\t\t\t/* Name of directive */\n   enum node_type type;\t\t/* Code which describes which directive. */\n   char angle_brackets;\t\t/* Nonzero => <...> is special.  */\n   char traditional_comments;\t/* Nonzero: keep comments if -traditional.  */\n   char pass_thru;\t\t/* Copy preprocessed directive to output file.  */\n };\n \n+/* These functions are declared to return int instead of void since they\n+   are going to be placed in the table and some old compilers have trouble with\n+   pointers to functions returning void.  */\n+\n+static int do_assert DO_PROTO;\n+static int do_define DO_PROTO;\n+static int do_elif DO_PROTO;\n+static int do_else DO_PROTO;\n+static int do_endif DO_PROTO;\n+static int do_error DO_PROTO;\n+static int do_ident DO_PROTO;\n+static int do_if DO_PROTO;\n+static int do_include DO_PROTO;\n+static int do_line DO_PROTO;\n+static int do_pragma DO_PROTO;\n+#ifdef SCCS_DIRECTIVE\n+static int do_sccs DO_PROTO;\n+#endif\n+static int do_unassert DO_PROTO;\n+static int do_undef DO_PROTO;\n+static int do_warning DO_PROTO;\n+static int do_xifdef DO_PROTO;\n+\n /* Here is the actual list of #-directives, most-often-used first.  */\n \n static struct directive directive_table[] = {\n@@ -995,9 +1021,6 @@ static int dollars_in_ident;\n #define DOLLARS_IN_IDENTIFIERS 1\n #endif\n \n-static FILE_BUF expand_to_temp_buffer ();\n-\n-static DEFINITION *collect_expansion ();\n \n /* Stack of conditionals currently in progress\n    (including both successful and failing conditionals).  */\n@@ -1031,6 +1054,152 @@ static int deps_column;\n    so don't look for #include \"foo\" the source-file directory.  */\n static int ignore_srcdir;\n \f\n+static int safe_read PROTO((int, char *, int));\n+static void safe_write PROTO((int, char *, int));\n+\n+int main PROTO((int, char **));\n+\n+static void path_include PROTO((char *));\n+\n+static U_CHAR *index0 PROTO((U_CHAR *, int, size_t));\n+\n+static void trigraph_pcp PROTO((FILE_BUF *));\n+\n+static void newline_fix PROTO((U_CHAR *));\n+static void name_newline_fix PROTO((U_CHAR *));\n+\n+static char *get_lintcmd PROTO((U_CHAR *, U_CHAR *, U_CHAR **, int *, int *));\n+\n+static void rescan PROTO((FILE_BUF *, int));\n+\n+static FILE_BUF expand_to_temp_buffer PROTO((U_CHAR *, U_CHAR *, int, int));\n+\n+static int handle_directive PROTO((FILE_BUF *, FILE_BUF *));\n+\n+static struct tm *timestamp PROTO((void));\n+static void special_symbol PROTO((HASHNODE *, FILE_BUF *));\n+\n+static int redundant_include_p PROTO((char *));\n+static is_system_include PROTO((char *));\n+\n+static char *read_filename_string PROTO((int, FILE *));\n+static struct file_name_map *read_name_map PROTO((char *));\n+static int open_include_file PROTO((char *, struct file_name_list *));\n+\n+static void finclude PROTO((int, char *, FILE_BUF *, int, struct file_name_list *));\n+static void record_control_macro PROTO((char *, U_CHAR *));\n+\n+static int import_hash PROTO((char *));\n+static int lookup_import PROTO((char *, struct file_name_list *));\n+static void add_import PROTO((int, char *));\n+\n+static char *check_precompiled PROTO((int, char *, char **));\n+static int check_preconditions PROTO((char *));\n+static void pcfinclude PROTO((U_CHAR *, U_CHAR *, U_CHAR *, FILE_BUF *));\n+static void pcstring_used PROTO((HASHNODE *));\n+static void write_output PROTO((void));\n+static void pass_thru_directive PROTO((U_CHAR *, U_CHAR *, FILE_BUF *, struct directive *));\n+\n+static MACRODEF create_definition PROTO((U_CHAR *, U_CHAR *, FILE_BUF *));\n+\n+static int check_macro_name PROTO((U_CHAR *, char *));\n+static int compare_defs PROTO((DEFINITION *, DEFINITION *));\n+static int comp_def_part PROTO((int, U_CHAR *, int, U_CHAR *, int, int));\n+\n+static DEFINITION *collect_expansion  PROTO((U_CHAR *, U_CHAR *, int, struct arglist *));\n+\n+int check_assertion PROTO((U_CHAR *, int, int, struct arglist *));\n+static int compare_token_lists PROTO((struct arglist *, struct arglist *));\n+\n+static struct arglist *read_token_list PROTO((U_CHAR **, U_CHAR *, int *));\n+static void free_token_list PROTO((struct arglist *));\n+\n+static ASSERTION_HASHNODE *assertion_install PROTO((U_CHAR *, int, int));\n+static ASSERTION_HASHNODE *assertion_lookup PROTO((U_CHAR *, int, int));\n+static void delete_assertion PROTO((ASSERTION_HASHNODE *));\n+\n+static void do_once PROTO((void));\n+\n+static HOST_WIDE_INT eval_if_expression PROTO((U_CHAR *, int));\n+static void conditional_skip PROTO((FILE_BUF *, int, enum node_type, U_CHAR *, FILE_BUF *));\n+static void skip_if_group PROTO((FILE_BUF *, int, FILE_BUF *));\n+static void validate_else PROTO((U_CHAR *));\n+\n+static U_CHAR *skip_to_end_of_comment PROTO((FILE_BUF *, int *, int));\n+static U_CHAR *skip_quoted_string PROTO((U_CHAR *, U_CHAR *, int, int *, int *, int *));\n+static char *quote_string PROTO((char *, char *));\n+static U_CHAR *skip_paren_group PROTO((FILE_BUF *));\n+\n+/* Last arg to output_line_directive.  */\n+enum file_change_code {same_file, enter_file, leave_file};\n+static void output_line_directive PROTO((FILE_BUF *, FILE_BUF *, int, enum file_change_code));\n+\n+static void macroexpand PROTO((HASHNODE *, FILE_BUF *));\n+\n+struct argdata;\n+static char *macarg PROTO((struct argdata *, int));\n+\n+static U_CHAR *macarg1 PROTO((U_CHAR *, U_CHAR *, int *, int *, int *, int));\n+\n+static int discard_comments PROTO((U_CHAR *, int, int));\n+\n+static int change_newlines PROTO((U_CHAR *, int));\n+\n+char *my_strerror PROTO((int));\n+void error PRINTF_PROTO_1((char *, ...));\n+static void verror PROTO((char *, va_list));\n+static void error_from_errno PROTO((char *));\n+void warning PRINTF_PROTO_1((char *, ...));\n+static void vwarning PROTO((char *, va_list));\n+static void error_with_line PRINTF_PROTO_2((int, char *, ...));\n+static void verror_with_line PROTO((int, char *, va_list));\n+static void vwarning_with_line PROTO((int, char *, va_list));\n+void pedwarn PRINTF_PROTO_1((char *, ...));\n+void pedwarn_with_line PRINTF_PROTO_2((int, char *, ...));\n+static void pedwarn_with_file_and_line PRINTF_PROTO_3((char *, int, char *, ...));\n+\n+static void print_containing_files PROTO((void));\n+\n+static int line_for_error PROTO((int));\n+static int grow_outbuf PROTO((FILE_BUF *, int));\n+\n+static HASHNODE *install PROTO((U_CHAR *, int, enum node_type, char *, int));\n+HASHNODE *lookup PROTO((U_CHAR *, int, int));\n+static void delete_macro PROTO((HASHNODE *));\n+static int hashf PROTO((U_CHAR *, int, int));\n+\n+static void dump_single_macro PROTO((HASHNODE *, FILE *));\n+static void dump_all_macros PROTO((void));\n+static void dump_defn_1 PROTO((U_CHAR *, int, int, FILE *));\n+static void dump_arg_n PROTO((DEFINITION *, int, FILE *));\n+\n+static void initialize_char_syntax PROTO((void));\n+static void initialize_builtins PROTO((FILE_BUF *, FILE_BUF *));\n+\n+static void make_definition PROTO((char *, FILE_BUF *));\n+static void make_undef PROTO((char *, FILE_BUF *));\n+\n+static void make_assertion PROTO((char *, char *));\n+\n+static void append_include_chain PROTO((struct file_name_list *, struct file_name_list *));\n+\n+static void deps_output PROTO((char *, int));\n+\n+static void fatal PRINTF_PROTO_1((char *, ...)) __attribute__ ((noreturn));\n+void fancy_abort PROTO((void)) __attribute__ ((noreturn));\n+static void perror_with_name PROTO((char *));\n+static void pfatal_with_name PROTO((char *)) __attribute__ ((noreturn));\n+static void pipe_closed PROTO((int)) __attribute__ ((noreturn));\n+\n+static void memory_full PROTO((void)) __attribute__ ((noreturn));\n+GENERIC_PTR xmalloc PROTO((size_t));\n+static GENERIC_PTR xrealloc PROTO((GENERIC_PTR, size_t));\n+static GENERIC_PTR xcalloc PROTO((size_t, size_t));\n+static char *savestring PROTO((char *));\n+\n+static int file_size_and_mode PROTO((int, int *, long int *));\n+static void output_dots PROTO((FILE *, int));\n+\f\n /* Read LEN bytes at PTR from descriptor DESC, for file FILENAME,\n    retrying if necessary.  Return a negative value if an error occurs,\n    otherwise return the actual number of bytes read,\n@@ -1093,7 +1262,7 @@ main (argc, argv)\n   int st_mode;\n   long st_size;\n   char *in_fname;\n-  char *p;\n+  char *cp;\n   int f, i;\n   FILE_BUF *fp;\n   char **pend_files = (char **) xmalloc (argc * sizeof (char *));\n@@ -1143,18 +1312,19 @@ main (argc, argv)\n   signal (SIGPIPE, pipe_closed);\n #endif\n \n-  p = argv[0] + strlen (argv[0]);\n-  while (p != argv[0] && p[-1] != '/'\n+  cp = argv[0] + strlen (argv[0]);\n+  while (cp != argv[0] && cp[-1] != '/'\n #ifdef DIR_SEPARATOR\n-\t && p[-1] != DIR_SEPARATOR\n+\t && cp[-1] != DIR_SEPARATOR\n #endif\n \t )\n-    --p;\n-  progname = p;\n+    --cp;\n+  progname = cp;\n \n #ifdef VMS\n   {\n     /* Remove directories from PROGNAME.  */\n+    char *p;\n     char *s = progname;\n \n     if ((p = rindex (s, ':')) != 0) s = p + 1;\t/* skip device */\n@@ -1238,7 +1408,7 @@ main (argc, argv)\n \t  dirtmp->next = 0;\n \t  dirtmp->control_macro = 0;\n \t  dirtmp->c_system_include_path = 1;\n-\t  dirtmp->fname = (char *) xmalloc (strlen (argv[i+1]) + 1);\n+\t  dirtmp->fname = xmalloc (strlen (argv[i+1]) + 1);\n \t  strcpy (dirtmp->fname, argv[++i]);\n \t  dirtmp->got_name_map = 0;\n \n@@ -1271,8 +1441,7 @@ main (argc, argv)\n \t  if (i + 1 == argc)\n \t    fatal (\"Directory name missing after `-iwithprefix' option\");\n \n-\t  dirtmp->fname = (char *) xmalloc (strlen (argv[i+1])\n-\t\t\t\t\t    + strlen (prefix) + 1);\n+\t  dirtmp->fname = xmalloc (strlen (argv[i+1]) + strlen (prefix) + 1);\n \t  strcpy (dirtmp->fname, prefix);\n \t  strcat (dirtmp->fname, argv[++i]);\n \t  dirtmp->got_name_map = 0;\n@@ -1306,8 +1475,7 @@ main (argc, argv)\n \t  if (i + 1 == argc)\n \t    fatal (\"Directory name missing after `-iwithprefixbefore' option\");\n \n-\t  dirtmp->fname = (char *) xmalloc (strlen (argv[i+1])\n-\t\t\t\t\t    + strlen (prefix) + 1);\n+\t  dirtmp->fname = xmalloc (strlen (argv[i+1]) + strlen (prefix) + 1);\n \t  strcpy (dirtmp->fname, prefix);\n \t  strcat (dirtmp->fname, argv[++i]);\n \t  dirtmp->got_name_map = 0;\n@@ -1361,7 +1529,7 @@ main (argc, argv)\n \t  pcp_outfile = \n \t    ((pcp_fname[0] != '-' || pcp_fname[1] != '\\0')\n \t     ? fopen (pcp_fname, \"w\")\n-\t     : fdopen (dup (fileno (stdout)), \"w\"));\n+\t     : stdout);\n \t  if (pcp_outfile == 0)\n \t    pfatal_with_name (pcp_fname);\n \t  no_precomp = 1;\n@@ -1481,7 +1649,7 @@ main (argc, argv)\n \t{\n \t  char *p = argv[i] + 2;\n \t  char c;\n-\t  while (c = *p++) {\n+\t  while ((c = *p++)) {\n \t    /* Arg to -d specifies what parts of macros to dump */\n \t    switch (c) {\n \t    case 'M':\n@@ -1643,9 +1811,9 @@ main (argc, argv)\n   /* Some people say that CPATH should replace the standard include dirs,\n      but that seems pointless: it comes before them, so it overrides them\n      anyway.  */\n-  p = (char *) getenv (\"CPATH\");\n-  if (p != 0 && ! no_standard_includes)\n-    path_include (p);\n+  cp = getenv (\"CPATH\");\n+  if (cp && ! no_standard_includes)\n+    path_include (cp);\n \n   /* Now that dollars_in_ident is known, initialize is_idchar.  */\n   initialize_char_syntax ();\n@@ -1860,7 +2028,7 @@ main (argc, argv)\n \t    struct file_name_list *new\n \t      = (struct file_name_list *) xmalloc (sizeof (struct file_name_list));\n \t    int this_len = strlen (specd_prefix) + strlen (p->fname) - default_len;\n-\t    char *str = (char *) xmalloc (this_len + 1);\n+\t    char *str = xmalloc (this_len + 1);\n \t    strcpy (str, specd_prefix);\n \t    strcat (str, p->fname + default_len);\n \t    new->fname = str;\n@@ -1964,7 +2132,7 @@ main (argc, argv)\n     while (*s != 0 && *s != ' ') s++;\n     if (*s != 0) {\n       deps_target = s + 1;\n-      output_file = (char *) xmalloc (s - spec + 1);\n+      output_file = xmalloc (s - spec + 1);\n       bcopy (spec, output_file, s - spec);\n       output_file[s - spec] = 0;\n     }\n@@ -1981,7 +2149,7 @@ main (argc, argv)\n      as the target of this Make-rule.  */\n   if (print_deps) {\n     deps_allocated_size = 200;\n-    deps_buffer = (char *) xmalloc (deps_allocated_size);\n+    deps_buffer = xmalloc (deps_allocated_size);\n     deps_buffer[0] = 0;\n     deps_size = 0;\n     deps_column = 0;\n@@ -2062,7 +2230,7 @@ main (argc, argv)\n     size = 0;\n     fp->buf = (U_CHAR *) xmalloc (bsize + 2);\n     for (;;) {\n-      cnt = safe_read (f, fp->buf + size, bsize - size);\n+      cnt = safe_read (f, (char *) fp->buf + size, bsize - size);\n       if (cnt < 0) goto perror;\t/* error! */\n       size += cnt;\n       if (size != bsize) break;\t/* End of file */\n@@ -2074,7 +2242,7 @@ main (argc, argv)\n     /* Read a file whose size we can determine in advance.\n        For the sake of VMS, st_size is just an upper bound.  */\n     fp->buf = (U_CHAR *) xmalloc (st_size + 2);\n-    fp->length = safe_read (f, fp->buf, st_size);\n+    fp->length = safe_read (f, (char *) fp->buf, st_size);\n     if (fp->length < 0) goto perror;\n   }\n   fp->bufp = fp->buf;\n@@ -2188,12 +2356,12 @@ path_include (path)\n       while (*q != 0 && *q != PATH_SEPARATOR) q++;\n       if (p == q) {\n \t/* An empty name in the path stands for the current directory.  */\n-\tname = (char *) xmalloc (2);\n+\tname = xmalloc (2);\n \tname[0] = '.';\n \tname[1] = 0;\n       } else {\n \t/* Otherwise use the directory that is named.  */\n-\tname = (char *) xmalloc (q - p + 1);\n+\tname = xmalloc (q - p + 1);\n \tbcopy (p, name, q - p);\n \tname[q - p] = 0;\n       }\n@@ -2226,18 +2394,19 @@ static U_CHAR *\n index0 (s, c, n)\n      U_CHAR *s;\n      int c;\n-     int n;\n+     size_t n;\n {\n+  char *p = (char *) s;\n   for (;;) {\n-    char *q = index (s, c);\n+    char *q = index (p, c);\n     if (q)\n       return (U_CHAR *) q;\n     else {\n-      int l = strlen (s);\n+      size_t l = strlen (p);\n       if (l == n)\n \treturn 0;\n       l++;\n-      s += l;\n+      p += l;\n       n -= l;\n     }\n   }\n@@ -2261,7 +2430,7 @@ trigraph_pcp (buf)\n \n   fptr = bptr = sptr = buf->buf;\n   lptr = fptr + buf->length;\n-  while ((sptr = (U_CHAR *) index0 (sptr, '?', lptr - sptr)) != NULL) {\n+  while ((sptr = index0 (sptr, '?', (size_t) (lptr - sptr))) != NULL) {\n     if (*++sptr != '?')\n       continue;\n     switch (*++sptr) {\n@@ -2417,19 +2586,19 @@ get_lintcmd (ibp, limit, argstart, arglen, cmdlen)\n   linsize = limit - ibp;\n   \n   /* Oh, I wish C had lexical functions... hell, I'll just open-code the set */\n-  if ((linsize >= 10) && !strncmp (ibp, \"NOTREACHED\", 10)) {\n+  if ((linsize >= 10) && !bcmp (ibp, \"NOTREACHED\", 10)) {\n     *cmdlen = 10;\n     return \"NOTREACHED\";\n   }\n-  if ((linsize >= 8) && !strncmp (ibp, \"ARGSUSED\", 8)) {\n+  if ((linsize >= 8) && !bcmp (ibp, \"ARGSUSED\", 8)) {\n     *cmdlen = 8;\n     return \"ARGSUSED\";\n   }\n-  if ((linsize >= 11) && !strncmp (ibp, \"LINTLIBRARY\", 11)) {\n+  if ((linsize >= 11) && !bcmp (ibp, \"LINTLIBRARY\", 11)) {\n     *cmdlen = 11;\n     return \"LINTLIBRARY\";\n   }\n-  if ((linsize >= 7) && !strncmp (ibp, \"VARARGS\", 7)) {\n+  if ((linsize >= 7) && !bcmp (ibp, \"VARARGS\", 7)) {\n     *cmdlen = 7;\n     ibp += 7; linsize -= 7;\n     if ((linsize == 0) || ! isdigit (*ibp)) return \"VARARGS\";\n@@ -3151,7 +3320,6 @@ do { ip = &instack[indepth];\t\t\\\n \t   backed over.  OBP-IDENT_LENGTH points to the identifier.  */\n \n \tif (!pcp_outfile || pcp_inside_if) {\n-startagain:\n \t  for (hp = hashtab[MAKE_POS (hash) % HASHSIZE]; hp != NULL;\n \t       hp = hp->next) {\n \t    \n@@ -3367,7 +3535,7 @@ do { ip = &instack[indepth];\t\t\\\n  ending:\n   if (if_stack != ip->if_stack)\n     {\n-      char *str = \"unknown\";\n+      char *str;\n \n       switch (if_stack->type)\n \t{\n@@ -3386,6 +3554,8 @@ do { ip = &instack[indepth];\t\t\\\n \tcase T_ELIF:\n \t  str = \"elif\";\n \t  break;\n+\tdefault:\n+\t  abort ();\n \t}\n \n       error_with_line (line_for_error (if_stack->lineno),\n@@ -3589,7 +3759,7 @@ handle_directive (ip, op)\n    * routine, after moving the input pointer up to the next line.\n    */\n   for (kt = directive_table; kt->length > 0; kt++) {\n-    if (kt->length == ident_length && !strncmp (kt->name, ident, ident_length)) {\n+    if (kt->length == ident_length && !bcmp (kt->name, ident, ident_length)) {\n       register U_CHAR *buf;\n       register U_CHAR *limit;\n       int unterminated;\n@@ -3607,7 +3777,8 @@ handle_directive (ip, op)\n       already_output = 0;\n       keep_comments = traditional && kt->traditional_comments;\n       /* #import is defined only in Objective C, or when on the NeXT.  */\n-      if (kt->type == T_IMPORT && !(objc || lookup (\"__NeXT__\", -1, -1)))\n+      if (kt->type == T_IMPORT\n+\t  && !(objc || lookup ((U_CHAR *) \"__NeXT__\", -1, -1)))\n \tbreak;\n \n       /* Find the end of this directive (first newline not backslashed\n@@ -4025,7 +4196,7 @@ special_symbol (hp, op)\n \n     if (!is_idstart[*ip->bufp])\n       goto oops;\n-    if (hp = lookup (ip->bufp, -1, -1)) {\n+    if ((hp = lookup (ip->bufp, -1, -1))) {\n       if (pcp_outfile && pcp_inside_if\n \t  && (hp->type == T_CONST\n \t      || (hp->type == T_MACRO && hp->value.defn->predefined)))\n@@ -4300,7 +4471,7 @@ do_include (buf, limit, op, keyword)\n \n   /* Allocate this permanently, because it gets stored in the definitions\n      of macros.  */\n-  fname = (char *) xmalloc (max_include_len + flen + 4);\n+  fname = xmalloc (max_include_len + flen + 4);\n   /* + 2 above for slash and terminating null.  */\n   /* + 2 added for '.h' on VMS (to support '#include filename') */\n \n@@ -4311,7 +4482,7 @@ do_include (buf, limit, op, keyword)\n       || *fbeg == DIR_SEPARATOR\n #endif\n       ) {\n-    strncpy (fname, fbeg, flen);\n+    strncpy (fname, (char *) fbeg, flen);\n     fname[flen] = 0;\n     if (redundant_include_p (fname))\n       return 0;\n@@ -4338,7 +4509,7 @@ do_include (buf, limit, op, keyword)\n       } else {\n \tfname[0] = 0;\n       }\n-      strncat (fname, fbeg, flen);\n+      strncat (fname, (char *) fbeg, flen);\n #ifdef VMS\n       /* Change this 1/2 Unix 1/2 VMS file specification into a\n          full VMS file specification */\n@@ -4378,7 +4549,7 @@ do_include (buf, limit, op, keyword)\n   if (f < 0) {\n     /* A file that was not found.  */\n \n-    strncpy (fname, fbeg, flen);\n+    strncpy (fname, (char *) fbeg, flen);\n     fname[flen] = 0;\n     /* If generating dependencies and -MG was specified, we assume missing\n        files are leaf files, living in the same directory as the source file\n@@ -4516,7 +4687,8 @@ do_include (buf, limit, op, keyword)\n     if (pcfbuf) {\n       pcfname = xmalloc (strlen (pcftry) + 1);\n       strcpy (pcfname, pcftry);\n-      pcfinclude (pcfbuf, pcfbuflimit, fname, op);\n+      pcfinclude ((U_CHAR *) pcfbuf, (U_CHAR *) pcfbuflimit,\n+\t\t  (U_CHAR *) fname, op);\n     }\n     else\n       finclude (f, fname, op, is_system_include (fname), searchptr);\n@@ -4842,7 +5014,7 @@ finclude (f, fname, op, system_header_p, dirptr)\n \n     /* Read the file contents, knowing that st_size is an upper bound\n        on the number of bytes we can read.  */\n-    fp->length = safe_read (f, fp->buf, st_size);\n+    fp->length = safe_read (f, (char *) fp->buf, st_size);\n     if (fp->length < 0) goto nope;\n   }\n   else if (S_ISDIR (st_mode)) {\n@@ -4860,7 +5032,7 @@ finclude (f, fname, op, system_header_p, dirptr)\n     fp->buf = (U_CHAR *) xmalloc (bsize + 2);\n \n     for (;;) {\n-      i = safe_read (f, fp->buf + st_size, bsize - st_size);\n+      i = safe_read (f, (char *) fp->buf + st_size, bsize - st_size);\n       if (i < 0)\n \tgoto nope;      /* error! */\n       st_size += i;\n@@ -5026,7 +5198,7 @@ add_import (fd, fname)\n   hashval = import_hash (fname);\n   fstat (fd, &sb);\n   i = (struct import_file *)xmalloc (sizeof (struct import_file));\n-  i->name = (char *)xmalloc (strlen (fname)+1);\n+  i->name = xmalloc (strlen (fname)+1);\n   strcpy (i->name, fname);\n   bcopy ((char *) &sb.st_ino, (char *) &i->inode, sizeof (sb.st_ino));\n   i->dev = sb.st_dev;\n@@ -5109,7 +5281,7 @@ check_preconditions (prec)\n   char *lineend;\n   \n   while (*prec) {\n-    lineend = (char *) index (prec, '\\n');\n+    lineend = index (prec, '\\n');\n     \n     if (*prec++ != '#') {\n       error (\"Bad format encountered while reading precompiled file\");\n@@ -5119,7 +5291,7 @@ check_preconditions (prec)\n       HASHNODE *hp;\n       \n       prec += 6;\n-      mdef = create_definition (prec, lineend, NULL_PTR);\n+      mdef = create_definition ((U_CHAR *) prec, (U_CHAR *) lineend, NULL_PTR);\n \n       if (mdef.defn == 0)\n \tabort ();\n@@ -5144,7 +5316,7 @@ check_preconditions (prec)\n \tprec++;\n       len = prec - name;\n       \n-      if (lookup (name, len, -1))\n+      if (lookup ((U_CHAR *) name, len, -1))\n \treturn 0;\n     } else {\n       error (\"Bad format encountered while reading precompiled file\");\n@@ -5196,7 +5368,7 @@ pcfinclude (buf, limit, name, op)\n       cp += 4 - ((HOST_WIDE_INT) cp & 3);\n     \n     /* Now get the string. */\n-    str = (STRINGDEF *) cp;\n+    str = (STRINGDEF *) (GENERIC_PTR) cp;\n     string_start = cp += sizeof (STRINGDEF);\n     \n     for (; *cp; cp++)\t\t/* skip the string */\n@@ -5231,15 +5403,15 @@ pcfinclude (buf, limit, name, op)\n     else\n       /* Otherwise, for each key, */\n       for (; nkeys--; free (tmpbuf.buf), cp = endofthiskey + 1) {\n-\tKEYDEF *kp = (KEYDEF *) cp;\n+\tKEYDEF *kp = (KEYDEF *) (GENERIC_PTR) cp;\n \tHASHNODE *hp;\n \t\n \t/* It starts with a KEYDEF structure */\n \tcp += sizeof (KEYDEF);\n \t\n \t/* Find the end of the key.  At the end of this for loop we\n \t   advance CP to the start of the next key using this variable. */\n-\tendofthiskey = cp + strlen (cp);\n+\tendofthiskey = cp + strlen ((char *) cp);\n \tkp->str = str;\n \t\n \t/* Expand the key, and enter it into the hash table. */\n@@ -5308,16 +5480,17 @@ write_output ()\n     if (next_string\n \t&& cur_buf_loc - outbuf.buf == next_string->output_mark) {\n       if (next_string->writeflag) {\n-\tlen = 4 * strlen (next_string->filename) + 32;\n+\tlen = 4 * strlen ((char *) next_string->filename) + 32;\n \twhile (len > line_directive_len)\n \t  line_directive = xrealloc (line_directive, \n \t\t\t\t     line_directive_len *= 2);\n \tsprintf (line_directive, \"\\n# %d \", next_string->lineno);\n \tstrcpy (quote_string (line_directive + strlen (line_directive),\n-\t\t              next_string->filename),\n+\t\t\t      (char *) next_string->filename),\n \t\t\"\\n\");\n \tsafe_write (fileno (stdout), line_directive, strlen (line_directive));\n-\tsafe_write (fileno (stdout), next_string->contents, next_string->len);\n+\tsafe_write (fileno (stdout),\n+\t\t    (char *) next_string->contents, next_string->len);\n       }\t      \n       next_string = next_string->chain;\n     }\n@@ -5327,7 +5500,7 @@ write_output ()\n \t\t- (cur_buf_loc - outbuf.buf))\n \t     : outbuf.bufp - cur_buf_loc);\n       \n-      safe_write (fileno (stdout), cur_buf_loc, len);\n+      safe_write (fileno (stdout), (char *) cur_buf_loc, len);\n       cur_buf_loc += len;\n     }\n   }\n@@ -5444,7 +5617,7 @@ create_definition (buf, limit, op)\n \tbp++;\n \t/* do we have a \"special\" rest-args extension here? */\n \tif (limit - bp > REST_EXTENSION_LENGTH &&\n-\t    strncmp (rest_extension, bp, REST_EXTENSION_LENGTH) == 0) {\n+\t    bcmp (rest_extension, bp, REST_EXTENSION_LENGTH) == 0) {\n \t  rest_args = 1;\n \t  temp->rest_args = 1;\n \t  break;\n@@ -5477,13 +5650,9 @@ create_definition (buf, limit, op)\n \n \tfor (otemp = temp->next; otemp != NULL; otemp = otemp->next)\n \t  if (temp->length == otemp->length &&\n-\t    strncmp (temp->name, otemp->name, temp->length) == 0) {\n-\t      U_CHAR *name;\n-\n-\t      name = (U_CHAR *) alloca (temp->length + 1);\n-\t      (void) strncpy (name, temp->name, temp->length);\n-\t      name[temp->length] = '\\0';\n-\t      error (\"duplicate argument name `%s' in `#define'\", name);\n+\t      bcmp (temp->name, otemp->name, temp->length) == 0) {\n+\t      error (\"duplicate argument name `%.*s' in `#define'\",\n+\t\t     temp->length, temp->name);\n \t      goto nope;\n \t  }\n       }\n@@ -5598,18 +5767,12 @@ do_define (buf, limit, op, keyword)\n         ok = ! done_initializing;\n       /* Print the warning if it's not ok.  */\n       if (!ok) {\n-\tU_CHAR *msg;\t\t/* what pain... */\n-\n         /* If we are passing through #define and #undef directives, do\n \t   that for this re-definition now.  */\n         if (debug_output && op)\n \t  pass_thru_directive (buf, limit, op, keyword);\n \n-\tmsg = (U_CHAR *) alloca (mdef.symlen + 22);\n-\t*msg = '`';\n-\tbcopy ((char *) mdef.symnam, (char *) (msg + 1), mdef.symlen);\n-\tstrcpy ((char *) (msg + mdef.symlen + 1), \"' redefined\");\n-\tpedwarn (msg);\n+\tpedwarn (\"`%.*s' redefined\", mdef.symlen, mdef.symnam);\n \tif (hp->type == T_MACRO)\n \t  pedwarn_with_file_and_line (hp->value.defn->file, hp->value.defn->line,\n \t\t\t\t      \"this is the location of the previous definition\");\n@@ -5650,16 +5813,9 @@ check_macro_name (symname, usage)\n   sym_length = p - symname;\n   if (sym_length == 0)\n     error (\"invalid %s name\", usage);\n-  else if (!is_idstart[*symname]) {\n-    U_CHAR *msg;\t\t\t/* what pain... */\n-    msg = (U_CHAR *) alloca (sym_length + 1);\n-    bcopy ((char *) symname, (char *) msg, sym_length);\n-    msg[sym_length] = 0;\n-    error (\"invalid %s name `%s'\", usage, msg);\n-  } else {\n-    if (! strncmp (symname, \"defined\", 7) && sym_length == 7)\n-      error (\"invalid %s name `defined'\", usage);\n-  }\n+  else if (!is_idstart[*symname]\n+\t   || (sym_length == 7 && ! bcmp (symname, \"defined\", 7)))\n+    error (\"invalid %s name `%.*s'\", usage, sym_length, symname);\n   return sym_length;\n }\n \n@@ -5681,7 +5837,7 @@ compare_defs (d1, d2)\n     return 1;\n   for (a1 = d1->pattern, a2 = d2->pattern; a1 && a2;\n        a1 = a1->next, a2 = a2->next) {\n-    if (!((a1->nchars == a2->nchars && ! strncmp (p1, p2, a1->nchars))\n+    if (!((a1->nchars == a2->nchars && ! bcmp (p1, p2, a1->nchars))\n \t  || ! comp_def_part (first, p1, a1->nchars, p2, a2->nchars, 0))\n \t|| a1->argno != a2->argno\n \t|| a1->stringify != a2->stringify\n@@ -5968,7 +6124,7 @@ collect_expansion (buf, end, nargs, arglist)\n \n \t  if (arg->name[0] == c\n \t      && arg->length == id_len\n-\t      && strncmp (arg->name, id_beg, id_len) == 0) {\n+\t      && bcmp (arg->name, id_beg, id_len) == 0) {\n \t    if (expected_delimiter && warn_stringify) {\n \t      if (traditional) {\n \t\twarning (\"macro argument `%.*s' is stringified.\",\n@@ -6116,7 +6272,7 @@ do_assert (buf, limit, op, keyword)\n \n     hp = assertion_lookup (symname, sym_length, hashcode);\n     if (hp == NULL) {\n-      if (sym_length == 7 && ! strncmp (symname, \"defined\", sym_length))\n+      if (sym_length == 7 && ! bcmp (symname, \"defined\", 7))\n \terror (\"`defined' redefined as assertion\");\n       hp = assertion_install (symname, sym_length, hashcode);\n     }\n@@ -6280,7 +6436,7 @@ compare_token_lists (l1, l2)\n   while (l1 && l2) {\n     if (l1->length != l2->length)\n       return 0;\n-    if (strncmp (l1->name, l2->name, l1->length))\n+    if (bcmp (l1->name, l2->name, l1->length))\n       return 0;\n     l1 = l1->next;\n     l2 = l2->next;\n@@ -6432,7 +6588,7 @@ assertion_lookup (name, len, hash)\n \n   bucket = assertion_hashtab[hash];\n   while (bucket) {\n-    if (bucket->length == len && strncmp (bucket->name, name, len) == 0)\n+    if (bucket->length == len && bcmp (bucket->name, name, len) == 0)\n       return bucket;\n     bucket = bucket->next;\n   }\n@@ -6490,7 +6646,7 @@ do_line (buf, limit, op, keyword)\n   /* The Newline at the end of this line remains to be processed.\n      To put the next line at the specified line number,\n      we must store a line number now that is one less.  */\n-  new_lineno = atoi (bp) - 1;\n+  new_lineno = atoi ((char *) bp) - 1;\n \n   /* NEW_LINENO is one less than the actual line number here.  */\n   if (pedantic && new_lineno < 0)\n@@ -6584,7 +6740,7 @@ do_line (buf, limit, op, keyword)\n       &fname_table[hashf (fname, fname_length, FNAME_HASHSIZE)];\n     for (hp = *hash_bucket; hp != NULL; hp = hp->next)\n       if (hp->length == fname_length &&\n-\t  strncmp (hp->value.cpval, fname, fname_length) == 0) {\n+\t  bcmp (hp->value.cpval, fname, fname_length) == 0) {\n \tip->nominal_fname = hp->value.cpval;\n \tbreak;\n       }\n@@ -6696,7 +6852,7 @@ do_warning (buf, limit, op, keyword)\n /* Remember the name of the current file being read from so that we can\n    avoid ever including it again.  */\n \n-static int\n+static void\n do_once ()\n {\n   int i;\n@@ -6719,18 +6875,18 @@ do_once ()\n     new->got_name_map = 0;\n     new->c_system_include_path = 0;\n   }\n-  return 0;\n }\n \n /* #ident has already been copied to the output file, so just ignore it.  */\n \n static int\n-do_ident (buf, limit)\n+do_ident (buf, limit, op, keyword)\n      U_CHAR *buf, *limit;\n+     FILE_BUF *op;\n+     struct directive *keyword;\n {\n   FILE_BUF trybuf;\n   int len;\n-  FILE_BUF *op = &outbuf;\n \n   /* Allow #ident in system headers, since that's not user's fault.  */\n   if (pedantic && !instack[indepth].system_header_p)\n@@ -6760,19 +6916,21 @@ do_ident (buf, limit)\n    Just check for some recognized pragmas that need validation here.  */\n \n static int\n-do_pragma (buf, limit)\n+do_pragma (buf, limit, op, keyword)\n      U_CHAR *buf, *limit;\n+     FILE_BUF *op;\n+     struct directive *keyword;\n {\n   SKIP_WHITE_SPACE (buf);\n-  if (!strncmp (buf, \"once\", 4)) {\n+  if (!strncmp ((char *) buf, \"once\", 4)) {\n     /* Allow #pragma once in system headers, since that's not the user's\n        fault.  */\n     if (!instack[indepth].system_header_p)\n       warning (\"`#pragma once' is obsolete\");\n     do_once ();\n   }\n \n-  if (!strncmp (buf, \"implementation\", 14)) {\n+  if (!strncmp ((char *) buf, \"implementation\", 14)) {\n     /* Be quiet about `#pragma implementation' for a file only if it hasn't\n        been included yet.  */\n     struct file_name_list *ptr;\n@@ -6782,13 +6940,13 @@ do_pragma (buf, limit)\n       return 0;\n \n     fname = p + 1;\n-    if (p = (U_CHAR *) index (fname, '\\\"'))\n+    if ((p = (U_CHAR *) index ((char *) fname, '\\\"')))\n       *p = '\\0';\n     \n     for (ptr = all_include_files; ptr; ptr = ptr->next) {\n       inc_fname = (U_CHAR *) rindex (ptr->fname, '/');\n       inc_fname = inc_fname ? inc_fname + 1 : (U_CHAR *) ptr->fname;\n-      if (inc_fname && !strcmp (inc_fname, fname))\n+      if (inc_fname && !strcmp ((char *) inc_fname, (char *) fname))\n \twarning (\"`#pragma implementation' for `%s' appears after file is included\",\n \t\t fname);\n     }\n@@ -6824,15 +6982,22 @@ do_pragma ()\n }\n #endif\n \n+#ifdef SCCS_DIRECTIVE\n+\n /* Just ignore #sccs, on systems where we define it at all.  */\n \n static int\n-do_sccs ()\n+do_sccs (buf, limit, op, keyword)\n+     U_CHAR *buf, *limit;\n+     FILE_BUF *op;\n+     struct directive *keyword;\n {\n   if (pedantic)\n     pedwarn (\"ANSI C does not allow `#sccs'\");\n   return 0;\n }\n+\n+#endif /* defined (SCCS_DIRECTIVE) */\n \f\n /*\n  * handle #if directive by\n@@ -6917,13 +7082,14 @@ eval_if_expression (buf, length)\n   HASHNODE *save_defined;\n   HOST_WIDE_INT value;\n \n-  save_defined = install (\"defined\", -1, T_SPEC_DEFINED, NULL_PTR, -1);\n+  save_defined = install ((U_CHAR *) \"defined\", -1, T_SPEC_DEFINED,\n+\t\t\t  NULL_PTR, -1);\n   pcp_inside_if = 1;\n   temp_obuf = expand_to_temp_buffer (buf, buf + length, 0, 1);\n   pcp_inside_if = 0;\n   delete_macro (save_defined);\t/* clean up special symbol */\n \n-  value = parse_c_expression (temp_obuf.buf);\n+  value = parse_c_expression ((char *) temp_obuf.buf);\n \n   free (temp_obuf.buf);\n \n@@ -7261,7 +7427,7 @@ skip_if_group (ip, any, op)\n       for (kt = directive_table; kt->length >= 0; kt++) {\n \tIF_STACK_FRAME *temp;\n \tif (ident_length == kt->length\n-\t    && strncmp (cp, kt->name, kt->length) == 0) {\n+\t    && bcmp (cp, kt->name, kt->length) == 0) {\n \t  /* If we are asked to return on next directive, do so now.  */\n \t  if (any)\n \t    goto done;\n@@ -7300,6 +7466,9 @@ skip_if_group (ip, any, op)\n \t    if_stack = if_stack->next;\n \t    free (temp);\n \t    break;\n+\n+\t   default:\n+\t    break;\n \t  }\n \t  break;\n \t}\n@@ -8690,9 +8859,20 @@ my_strerror (errnum)\n  */\n \n void\n-error (msg, arg1, arg2, arg3)\n+error (PRINTF_ALIST (msg))\n+     PRINTF_DCL (msg)\n+{\n+  va_list args;\n+\n+  VA_START (args, msg);\n+  verror (msg, args);\n+  va_end (args);\n+}\n+\n+static void\n+verror (msg, args)\n      char *msg;\n-     char *arg1, *arg2, *arg3;\n+     va_list args;\n {\n   int i;\n   FILE_BUF *ip = NULL;\n@@ -8707,7 +8887,7 @@ error (msg, arg1, arg2, arg3)\n \n   if (ip != NULL)\n     fprintf (stderr, \"%s:%d: \", ip->nominal_fname, ip->lineno);\n-  fprintf (stderr, msg, arg1, arg2, arg3);\n+  vfprintf (stderr, msg, args);\n   fprintf (stderr, \"\\n\");\n   errors++;\n }\n@@ -8740,9 +8920,20 @@ error_from_errno (name)\n /* Print error message but don't count it.  */\n \n void\n-warning (msg, arg1, arg2, arg3)\n+warning (PRINTF_ALIST (msg))\n+     PRINTF_DCL (msg)\n+{\n+  va_list args;\n+\n+  VA_START (args, msg);\n+  vwarning (msg, args);\n+  va_end (args);\n+}\n+\n+static void\n+vwarning (msg, args)\n      char *msg;\n-     char *arg1, *arg2, *arg3;\n+     va_list args;\n {\n   int i;\n   FILE_BUF *ip = NULL;\n@@ -8764,15 +8955,31 @@ warning (msg, arg1, arg2, arg3)\n   if (ip != NULL)\n     fprintf (stderr, \"%s:%d: \", ip->nominal_fname, ip->lineno);\n   fprintf (stderr, \"warning: \");\n-  fprintf (stderr, msg, arg1, arg2, arg3);\n+  vfprintf (stderr, msg, args);\n   fprintf (stderr, \"\\n\");\n }\n \n static void\n-error_with_line (line, msg, arg1, arg2, arg3)\n+#if defined (__STDC__) && defined (HAVE_VPRINTF)\n+error_with_line (int line, PRINTF_ALIST (msg))\n+#else\n+error_with_line (line, PRINTF_ALIST (msg))\n+     int line;\n+     PRINTF_DCL (msg)\n+#endif\n+{\n+  va_list args;\n+\n+  VA_START (args, msg);\n+  verror_with_line (line, msg, args);\n+  va_end (args);\n+}\n+\n+static void\n+verror_with_line (line, msg, args)\n      int line;\n      char *msg;\n-     char *arg1, *arg2, *arg3;\n+     va_list args;\n {\n   int i;\n   FILE_BUF *ip = NULL;\n@@ -8787,16 +8994,16 @@ error_with_line (line, msg, arg1, arg2, arg3)\n \n   if (ip != NULL)\n     fprintf (stderr, \"%s:%d: \", ip->nominal_fname, line);\n-  fprintf (stderr, msg, arg1, arg2, arg3);\n+  vfprintf (stderr, msg, args);\n   fprintf (stderr, \"\\n\");\n   errors++;\n }\n \n static void\n-warning_with_line (line, msg, arg1, arg2, arg3)\n+vwarning_with_line (line, msg, args)\n      int line;\n      char *msg;\n-     char *arg1, *arg2, *arg3;\n+     va_list args;\n {\n   int i;\n   FILE_BUF *ip = NULL;\n@@ -8818,45 +9025,60 @@ warning_with_line (line, msg, arg1, arg2, arg3)\n   if (ip != NULL)\n     fprintf (stderr, \"%s:%d: \", ip->nominal_fname, line);\n   fprintf (stderr, \"warning: \");\n-  fprintf (stderr, msg, arg1, arg2, arg3);\n+  vfprintf (stderr, msg, args);\n   fprintf (stderr, \"\\n\");\n }\n \n /* print an error message and maybe count it.  */\n \n void\n-pedwarn (msg, arg1, arg2, arg3)\n-     char *msg;\n-     char *arg1, *arg2, *arg3;\n+pedwarn (PRINTF_ALIST (msg))\n+     PRINTF_DCL (msg)\n {\n+  va_list args;\n+\n+  VA_START (args, msg);\n   if (pedantic_errors)\n-    error (msg, arg1, arg2, arg3);\n+    verror (msg, args);\n   else\n-    warning (msg, arg1, arg2, arg3);\n+    vwarning (msg, args);\n+  va_end (args);\n }\n \n void\n-pedwarn_with_line (line, msg, arg1, arg2, arg3)\n+#if defined (__STDC__) && defined (HAVE_VPRINTF)\n+pedwarn_with_line (int line, PRINTF_ALIST (msg))\n+#else\n+pedwarn_with_line (line, PRINTF_ALIST (msg))\n      int line;\n-     char *msg;\n-     char *arg1, *arg2, *arg3;\n+     PRINTF_DCL (msg)\n+#endif\n {\n+  va_list args;\n+\n+  VA_START (args, msg);\n   if (pedantic_errors)\n-    error_with_line (line, msg, arg1, arg2, arg3);\n+    verror_with_line (line, msg, args);\n   else\n-    warning_with_line (line, msg, arg1, arg2, arg3);\n+    vwarning_with_line (line, msg, args);\n+  va_end (args);\n }\n \n /* Report a warning (or an error if pedantic_errors)\n    giving specified file name and line number, not current.  */\n \n static void\n-pedwarn_with_file_and_line (file, line, msg, arg1, arg2, arg3)\n+#if defined (__STDC__) && defined (HAVE_VPRINTF)\n+pedwarn_with_file_and_line (char *file, int line, PRINTF_ALIST (msg))\n+#else\n+pedwarn_with_file_and_line (file, line, PRINTF_ALIST (msg))\n      char *file;\n      int line;\n-     char *msg;\n-     char *arg1, *arg2, *arg3;\n+     PRINTF_DCL (msg)\n+#endif\n {\n+  va_list args;\n+\n   if (!pedantic_errors && inhibit_warnings)\n     return;\n   if (file != NULL)\n@@ -8865,7 +9087,9 @@ pedwarn_with_file_and_line (file, line, msg, arg1, arg2, arg3)\n     errors++;\n   if (!pedantic_errors)\n     fprintf (stderr, \"warning: \");\n-  fprintf (stderr, msg, arg1, arg2, arg3);\n+  VA_START (args, msg);\n+  vfprintf (stderr, msg, args);\n+  va_end (args);\n   fprintf (stderr, \"\\n\");\n }\n \f\n@@ -9068,7 +9292,7 @@ lookup (name, len, hash)\n \n   bucket = hashtab[hash];\n   while (bucket) {\n-    if (bucket->length == len && strncmp (bucket->name, name, len) == 0)\n+    if (bucket->length == len && bcmp (bucket->name, name, len) == 0)\n       return bucket;\n     bucket = bucket->next;\n   }\n@@ -9182,6 +9406,7 @@ dump_single_macro (hp, of)\n \t case WHITE_SHARP_TOKEN: fprintf (of, \"# \"); break;\n \t case PERCENT_COLON_TOKEN: fprintf (of, \"%%:\"); break;\n \t case WHITE_PERCENT_COLON_TOKEN: fprintf (of, \"%%: \"); break;\n+\t default: abort ();\n \t}\n       }\n       if (ap->raw_before) {\n@@ -9191,13 +9416,16 @@ dump_single_macro (hp, of)\n \t   case WHITE_PERCENT_COLON_TOKEN:\n \t    fprintf (of, \" \");\n \t    break;\n+\t   default:\n+\t    break;\n \t  }\n \t} else {\n \t  switch (ap->raw_before) {\n \t   case SHARP_TOKEN: fprintf (of, \"##\"); break;\n \t   case WHITE_SHARP_TOKEN: fprintf (of, \"## \"); break;\n \t   case PERCENT_COLON_TOKEN: fprintf (of, \"%%:%%:\"); break;\n \t   case WHITE_PERCENT_COLON_TOKEN: fprintf (of, \"%%:%%: \"); break;\n+\t   default: abort ();\n \t  }\n \t}\n       }\n@@ -9210,6 +9438,7 @@ dump_single_macro (hp, of)\n        case WHITE_SHARP_TOKEN: fprintf (of, \" ##\"); break;\n        case PERCENT_COLON_TOKEN: fprintf (of, \"%%:%%:\"); break;\n        case WHITE_PERCENT_COLON_TOKEN: fprintf (of, \" %%:%%:\"); break;\n+       default: abort ();\n       }\n       concat = 1;\n     }\n@@ -9282,7 +9511,7 @@ dump_arg_n (defn, argnum, of)\n {\n   register U_CHAR *p = defn->args.argnames;\n   while (argnum + 1 < defn->nargs) {\n-    p = (U_CHAR *) index (p, ' ') + 1;\n+    p = (U_CHAR *) index ((char *) p, ' ') + 1;\n     argnum++;\n   }\n \n@@ -9344,86 +9573,96 @@ initialize_builtins (inp, outp)\n      FILE_BUF *inp;\n      FILE_BUF *outp;\n {\n-  install (\"__LINE__\", -1, T_SPECLINE, NULL_PTR, -1);\n-  install (\"__DATE__\", -1, T_DATE, NULL_PTR, -1);\n-  install (\"__FILE__\", -1, T_FILE, NULL_PTR, -1);\n-  install (\"__BASE_FILE__\", -1, T_BASE_FILE, NULL_PTR, -1);\n-  install (\"__INCLUDE_LEVEL__\", -1, T_INCLUDE_LEVEL, NULL_PTR, -1);\n-  install (\"__VERSION__\", -1, T_VERSION, NULL_PTR, -1);\n+  install ((U_CHAR *) \"__LINE__\", -1, T_SPECLINE, NULL_PTR, -1);\n+  install ((U_CHAR *) \"__DATE__\", -1, T_DATE, NULL_PTR, -1);\n+  install ((U_CHAR *) \"__FILE__\", -1, T_FILE, NULL_PTR, -1);\n+  install ((U_CHAR *) \"__BASE_FILE__\", -1, T_BASE_FILE, NULL_PTR, -1);\n+  install ((U_CHAR *) \"__INCLUDE_LEVEL__\", -1, T_INCLUDE_LEVEL, NULL_PTR, -1);\n+  install ((U_CHAR *) \"__VERSION__\", -1, T_VERSION, NULL_PTR, -1);\n #ifndef NO_BUILTIN_SIZE_TYPE\n-  install (\"__SIZE_TYPE__\", -1, T_SIZE_TYPE, NULL_PTR, -1);\n+  install ((U_CHAR *) \"__SIZE_TYPE__\", -1, T_SIZE_TYPE, NULL_PTR, -1);\n #endif\n #ifndef NO_BUILTIN_PTRDIFF_TYPE\n-  install (\"__PTRDIFF_TYPE__ \", -1, T_PTRDIFF_TYPE, NULL_PTR, -1);\n+  install ((U_CHAR *) \"__PTRDIFF_TYPE__ \", -1, T_PTRDIFF_TYPE, NULL_PTR, -1);\n #endif\n-  install (\"__WCHAR_TYPE__\", -1, T_WCHAR_TYPE, NULL_PTR, -1);\n-  install (\"__USER_LABEL_PREFIX__\",-1,T_USER_LABEL_PREFIX_TYPE, NULL_PTR, -1);\n-  install (\"__REGISTER_PREFIX__\", -1, T_REGISTER_PREFIX_TYPE, NULL_PTR, -1);\n-  install (\"__TIME__\", -1, T_TIME, NULL_PTR, -1);\n+  install ((U_CHAR *) \"__WCHAR_TYPE__\", -1, T_WCHAR_TYPE, NULL_PTR, -1);\n+  install ((U_CHAR *) \"__USER_LABEL_PREFIX__\", -1, T_USER_LABEL_PREFIX_TYPE,\n+\t   NULL_PTR, -1);\n+  install ((U_CHAR *) \"__REGISTER_PREFIX__\", -1, T_REGISTER_PREFIX_TYPE,\n+\t   NULL_PTR, -1);\n+  install ((U_CHAR *) \"__TIME__\", -1, T_TIME, NULL_PTR, -1);\n   if (!traditional) {\n-    install (\"__STDC__\", -1, T_CONST, \"1\", -1);\n-    install (\"__STDC_VERSION__\", -1, T_CONST, \"199409L\", -1);\n+    install ((U_CHAR *) \"__STDC__\", -1, T_CONST, \"1\", -1);\n+    install ((U_CHAR *) \"__STDC_VERSION__\", -1, T_CONST, \"199409L\", -1);\n   }\n   if (objc)\n-    install (\"__OBJC__\", -1, T_CONST, \"1\", -1);\n+    install ((U_CHAR *) \"__OBJC__\", -1, T_CONST, \"1\", -1);\n /*  This is supplied using a -D by the compiler driver\n     so that it is present only when truly compiling with GNU C.  */\n-/*  install (\"__GNUC__\", -1, T_CONST, \"2\", -1);  */\n+/*  install ((U_CHAR *) \"__GNUC__\", -1, T_CONST, \"2\", -1);  */\n \n   if (debug_output)\n     {\n       char directive[2048];\n+      U_CHAR *udirective = (U_CHAR *) directive;\n       register struct directive *dp = &directive_table[0];\n       struct tm *timebuf = timestamp ();\n \n       sprintf (directive, \" __BASE_FILE__ \\\"%s\\\"\\n\",\n \t       instack[0].nominal_fname);\n       output_line_directive (inp, outp, 0, same_file);\n-      pass_thru_directive (directive, &directive[strlen (directive)], outp, dp);\n+      pass_thru_directive (udirective, &udirective[strlen (directive)],\n+\t\t\t   outp, dp);\n \n       sprintf (directive, \" __VERSION__ \\\"%s\\\"\\n\", version_string);\n       output_line_directive (inp, outp, 0, same_file);\n-      pass_thru_directive (directive, &directive[strlen (directive)], outp, dp);\n+      pass_thru_directive (udirective, &udirective[strlen (directive)],\n+\t\t\t   outp, dp);\n \n #ifndef NO_BUILTIN_SIZE_TYPE\n       sprintf (directive, \" __SIZE_TYPE__ %s\\n\", SIZE_TYPE);\n       output_line_directive (inp, outp, 0, same_file);\n-      pass_thru_directive (directive, &directive[strlen (directive)], outp, dp);\n+      pass_thru_directive (udirective, &udirective[strlen (directive)],\n+\t\t\t   outp, dp);\n #endif\n \n #ifndef NO_BUILTIN_PTRDIFF_TYPE\n       sprintf (directive, \" __PTRDIFF_TYPE__ %s\\n\", PTRDIFF_TYPE);\n       output_line_directive (inp, outp, 0, same_file);\n-      pass_thru_directive (directive, &directive[strlen (directive)], outp, dp);\n+      pass_thru_directive (udirective, &udirective[strlen (directive)],\n+\t\t\t   outp, dp);\n #endif\n \n       sprintf (directive, \" __WCHAR_TYPE__ %s\\n\", wchar_type);\n       output_line_directive (inp, outp, 0, same_file);\n-      pass_thru_directive (directive, &directive[strlen (directive)], outp, dp);\n+      pass_thru_directive (udirective, &udirective[strlen (directive)],\n+\t\t\t   outp, dp);\n \n       sprintf (directive, \" __DATE__ \\\"%s %2d %4d\\\"\\n\",\n \t       monthnames[timebuf->tm_mon],\n \t       timebuf->tm_mday, timebuf->tm_year + 1900);\n       output_line_directive (inp, outp, 0, same_file);\n-      pass_thru_directive (directive, &directive[strlen (directive)], outp, dp);\n+      pass_thru_directive (udirective, &udirective[strlen (directive)],\n+\t\t\t   outp, dp);\n \n       sprintf (directive, \" __TIME__ \\\"%02d:%02d:%02d\\\"\\n\",\n \t       timebuf->tm_hour, timebuf->tm_min, timebuf->tm_sec);\n       output_line_directive (inp, outp, 0, same_file);\n-      pass_thru_directive (directive, &directive[strlen (directive)], outp, dp);\n+      pass_thru_directive (udirective, &udirective[strlen (directive)],\n+\t\t\t   outp, dp);\n \n       if (!traditional)\n \t{\n           sprintf (directive, \" __STDC__ 1\");\n           output_line_directive (inp, outp, 0, same_file);\n-          pass_thru_directive (directive, &directive[strlen (directive)],\n+          pass_thru_directive (udirective, &udirective[strlen (directive)],\n \t\t\t       outp, dp);\n \t}\n       if (objc)\n \t{\n           sprintf (directive, \" __OBJC__ 1\");\n           output_line_directive (inp, outp, 0, same_file);\n-          pass_thru_directive (directive, &directive[strlen (directive)],\n+          pass_thru_directive (udirective, &udirective[strlen (directive)],\n \t\t\t       outp, dp);\n \t}\n     }\n@@ -9438,15 +9677,14 @@ initialize_builtins (inp, outp)\n \n static void\n make_definition (str, op)\n-     U_CHAR *str;\n+     char *str;\n      FILE_BUF *op;\n {\n   FILE_BUF *ip;\n   struct directive *kt;\n   U_CHAR *buf, *p;\n \n-  buf = str;\n-  p = str;\n+  p = buf = (U_CHAR *) str;\n   if (!is_idstart[*p]) {\n     error (\"malformed option `-D %s'\", str);\n     return;\n@@ -9457,7 +9695,7 @@ make_definition (str, op)\n     while (is_idchar[*++p] || *p == ',' || is_hor_space[*p])\n       ;\n     if (*p++ != ')')\n-      p = str;\t\t\t/* Error */\n+      p = (U_CHAR *) str;\t\t\t/* Error */\n   }\n   if (*p == 0) {\n     buf = (U_CHAR *) alloca (p - buf + 4);\n@@ -9470,16 +9708,16 @@ make_definition (str, op)\n     U_CHAR *q;\n     /* Copy the entire option so we can modify it.  */\n     buf = (U_CHAR *) alloca (2 * strlen (str) + 1);\n-    strncpy (buf, str, p - str);\n+    strncpy ((char *) buf, str, p - (U_CHAR *) str);\n     /* Change the = to a space.  */\n-    buf[p - str] = ' ';\n+    buf[p - (U_CHAR *) str] = ' ';\n     /* Scan for any backslash-newline and remove it.  */\n     p++;\n-    q = &buf[p - str];\n+    q = &buf[p - (U_CHAR *) str];\n     while (*p) {\n       if (*p == '\\\"' || *p == '\\'') {\n \tint unterminated = 0;\n-\tU_CHAR *p1 = skip_quoted_string (p, p + strlen (p), 0,\n+\tU_CHAR *p1 = skip_quoted_string (p, p + strlen ((char *) p), 0,\n \t\t\t\t\t NULL_PTR, NULL_PTR, &unterminated);\n \tif (unterminated)\n \t  return;\n@@ -9507,7 +9745,7 @@ make_definition (str, op)\n   ip->nominal_fname = ip->fname = \"*Initialization*\";\n \n   ip->buf = ip->bufp = buf;\n-  ip->length = strlen (buf);\n+  ip->length = strlen ((char *) buf);\n   ip->lineno = 1;\n   ip->macro = 0;\n   ip->free_ptr = 0;\n@@ -9518,15 +9756,15 @@ make_definition (str, op)\n     ;\n \n   /* Pass NULL instead of OP, since this is a \"predefined\" macro.  */\n-  do_define (buf, buf + strlen (buf), NULL_PTR, kt);\n+  do_define (buf, buf + strlen ((char *) buf), NULL_PTR, kt);\n   --indepth;\n }\n \n /* JF, this does the work for the -U option */\n \n static void\n make_undef (str, op)\n-     U_CHAR *str;\n+     char *str;\n      FILE_BUF *op;\n {\n   FILE_BUF *ip;\n@@ -9535,7 +9773,7 @@ make_undef (str, op)\n   ip = &instack[++indepth];\n   ip->nominal_fname = ip->fname = \"*undef*\";\n \n-  ip->buf = ip->bufp = str;\n+  ip->buf = ip->bufp = (U_CHAR *) str;\n   ip->length = strlen (str);\n   ip->lineno = 1;\n   ip->macro = 0;\n@@ -9546,7 +9784,7 @@ make_undef (str, op)\n   for (kt = directive_table; kt->type != T_UNDEF; kt++)\n     ;\n \n-  do_undef (str, str + strlen (str), op, kt);\n+  do_undef ((U_CHAR *) str, (U_CHAR *) str + strlen (str), op, kt);\n   --indepth;\n }\n \f\n@@ -9556,7 +9794,7 @@ make_undef (str, op)\n static void\n make_assertion (option, str)\n      char *option;\n-     U_CHAR *str;\n+     char *str;\n {\n   FILE_BUF *ip;\n   struct directive *kt;\n@@ -9592,7 +9830,7 @@ make_assertion (option, str)\n   ip->nominal_fname = ip->fname = \"*Initialization*\";\n \n   ip->buf = ip->bufp = buf;\n-  ip->length = strlen (buf);\n+  ip->length = strlen ((char *) buf);\n   ip->lineno = 1;\n   ip->macro = 0;\n   ip->free_ptr = 0;\n@@ -9604,7 +9842,7 @@ make_assertion (option, str)\n \n   /* pass NULL as output ptr to do_define since we KNOW it never\n      does any output.... */\n-  do_assert (buf, buf + strlen (buf) , NULL_PTR, kt);\n+  do_assert (buf, buf + strlen ((char *) buf) , NULL_PTR, kt);\n   --indepth;\n }\n \f\n@@ -9669,7 +9907,7 @@ deps_output (string, spacer)\n \n   if (deps_size + size + 8 > deps_allocated_size) {\n     deps_allocated_size = (deps_size + size + 50) * 2;\n-    deps_buffer = (char *) xrealloc (deps_buffer, deps_allocated_size);\n+    deps_buffer = xrealloc (deps_buffer, deps_allocated_size);\n   }\n   if (spacer == ' ' && deps_column > 0)\n     deps_buffer[deps_size++] = ' ';\n@@ -9680,51 +9918,17 @@ deps_output (string, spacer)\n     deps_buffer[deps_size++] = ':';\n   deps_buffer[deps_size] = 0;\n }\n-\f\n-#if defined(USG) || defined(VMS)\n-#ifndef BSTRING\n-\n-void\n-bzero (b, length)\n-     register char *b;\n-     register unsigned length;\n-{\n-  while (length-- > 0)\n-    *b++ = 0;\n-}\n-\n-void\n-bcopy (b1, b2, length)\n-     register char *b1;\n-     register char *b2;\n-     register unsigned length;\n-{\n-  while (length-- > 0)\n-    *b2++ = *b1++;\n-}\n-\n-int\n-bcmp (b1, b2, length)\t/* This could be a macro! */\n-     register char *b1;\n-     register char *b2;\n-     register unsigned length;\n-{\n-   while (length-- > 0)\n-     if (*b1++ != *b2++)\n-       return 1;\n-\n-   return 0;\n-}\n-#endif /* not BSTRING */\n-#endif /* USG or VMS */\n-\n \f\n static void\n-fatal (str, arg)\n-     char *str, *arg;\n+fatal (PRINTF_ALIST (msg))\n+     PRINTF_DCL (msg)\n {\n+  va_list args;\n+\n   fprintf (stderr, \"%s: \", progname);\n-  fprintf (stderr, str, arg);\n+  VA_START (args, msg);\n+  vfprintf (stderr, msg, args);\n+  va_end (args);\n   fprintf (stderr, \"\\n\");\n   exit (FAILURE_EXIT_CODE);\n }\n@@ -9776,63 +9980,44 @@ memory_full ()\n }\n \n \n-char *\n+GENERIC_PTR\n xmalloc (size)\n-     unsigned size;\n+     size_t size;\n {\n-  register char *ptr = (char *) malloc (size);\n-  if (ptr != 0) return (ptr);\n-  memory_full ();\n-  /*NOTREACHED*/\n-  return 0;\n+  register GENERIC_PTR ptr = (GENERIC_PTR) malloc (size);\n+  if (!ptr)\n+    memory_full ();\n+  return ptr;\n }\n \n-static char *\n+static GENERIC_PTR\n xrealloc (old, size)\n-     char *old;\n-     unsigned size;\n+     GENERIC_PTR old;\n+     size_t size;\n {\n-  register char *ptr = (char *) realloc (old, size);\n-  if (ptr != 0) return (ptr);\n-  memory_full ();\n-  /*NOTREACHED*/\n-  return 0;\n+  register GENERIC_PTR ptr = (GENERIC_PTR) realloc (old, size);\n+  if (!ptr)\n+    memory_full ();\n+  return ptr;\n }\n \n-static char *\n+static GENERIC_PTR\n xcalloc (number, size)\n-     unsigned number, size;\n+     size_t number, size;\n {\n-  register unsigned total = number * size;\n-  register char *ptr = (char *) malloc (total);\n-  if (ptr != 0) {\n-    if (total > 100)\n-      bzero (ptr, total);\n-    else {\n-      /* It's not too long, so loop, zeroing by longs.\n-\t It must be safe because malloc values are always well aligned.  */\n-      register long *zp = (long *) ptr;\n-      register long *zl = (long *) (ptr + total - 4);\n-      register int i = total - 4;\n-      while (zp < zl)\n-\t*zp++ = 0;\n-      if (i < 0)\n-\ti = 0;\n-      while (i < total)\n-\tptr[i++] = 0;\n-    }\n-    return ptr;\n-  }\n-  memory_full ();\n-  /*NOTREACHED*/\n-  return 0;\n+  register size_t total = number * size;\n+  register GENERIC_PTR ptr = (GENERIC_PTR) malloc (total);\n+  if (!ptr)\n+    memory_full ();\n+  bzero (ptr, total);\n+  return ptr;\n }\n \n static char *\n savestring (input)\n      char *input;\n {\n-  unsigned size = strlen (input);\n+  size_t size = strlen (input);\n   char *output = xmalloc (size + 1);\n   strcpy (output, input);\n   return output;"}]}