{"sha": "7e3ce73849fef8b50efb427ec96f317e88c0e6cf", "node_id": "C_kwDOANBUbNoAKDdlM2NlNzM4NDlmZWY4YjUwZWZiNDI3ZWM5NmYzMTdlODhjMGU2Y2Y", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2022-11-10T00:35:26Z"}, "committer": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2022-11-10T18:17:09Z"}, "message": "c++: Extend -Wdangling-reference for std::minmax\n\nThis patch extends -Wdangling-reference to also warn for\n\n  auto v = std::minmax(1, 2);\n\nwhich dangles because this overload of std::minmax returns\na std::pair<const int&, const int&> where the two references are\nbound to the temporaries created for the arguments of std::minmax.\nThis is a common footgun, also described at\n<https://en.cppreference.com/w/cpp/algorithm/minmax> in Notes.\n\nIt works by extending do_warn_dangling_reference to also warn when the\nfunction returns a std::pair<const T&, const T&>.  std_pair_ref_ref_p\nis a new helper to check that.\n\ngcc/cp/ChangeLog:\n\n\t* call.cc (std_pair_ref_ref_p): New.\n\t(do_warn_dangling_reference): Also warn when the function returns\n\tstd::pair<const T&, const T&>.  Recurse into TARGET_EXPR_INITIAL.\n\t(maybe_warn_dangling_reference): Don't return early if we're\n\tinitializing a std_pair_ref_ref_p.\n\ngcc/ChangeLog:\n\n\t* doc/gcc/gcc-command-options/options-controlling-c++-dialect.rst:\n\tExtend the description of -Wdangling-reference.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/warn/Wdangling-reference6.C: New test.", "tree": {"sha": "0e4432ebd86e247c6b999b8ead2b122b72da2607", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e4432ebd86e247c6b999b8ead2b122b72da2607"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e3ce73849fef8b50efb427ec96f317e88c0e6cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e3ce73849fef8b50efb427ec96f317e88c0e6cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e3ce73849fef8b50efb427ec96f317e88c0e6cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e3ce73849fef8b50efb427ec96f317e88c0e6cf/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "740cf7d6ab266cf4249fc5c247187622cb6a2c8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/740cf7d6ab266cf4249fc5c247187622cb6a2c8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/740cf7d6ab266cf4249fc5c247187622cb6a2c8f"}], "stats": {"total": 100, "additions": 94, "deletions": 6}, "files": [{"sha": "bd3b64a7e262d6e6de69da26358544545c8156db", "filename": "gcc/cp/call.cc", "status": "modified", "additions": 46, "deletions": 6, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e3ce73849fef8b50efb427ec96f317e88c0e6cf/gcc%2Fcp%2Fcall.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e3ce73849fef8b50efb427ec96f317e88c0e6cf/gcc%2Fcp%2Fcall.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.cc?ref=7e3ce73849fef8b50efb427ec96f317e88c0e6cf", "patch": "@@ -13527,6 +13527,34 @@ initialize_reference (tree type, tree expr,\n   return expr;\n }\n \n+/* Return true if T is std::pair<const T&, const T&>.  */\n+\n+static bool\n+std_pair_ref_ref_p (tree t)\n+{\n+  /* First, check if we have std::pair.  */\n+  if (!NON_UNION_CLASS_TYPE_P (t)\n+      || !CLASSTYPE_TEMPLATE_INSTANTIATION (t))\n+    return false;\n+  tree tdecl = TYPE_NAME (TYPE_MAIN_VARIANT (t));\n+  if (!decl_in_std_namespace_p (tdecl))\n+    return false;\n+  tree name = DECL_NAME (tdecl);\n+  if (!name || !id_equal (name, \"pair\"))\n+    return false;\n+\n+  /* Now see if the template arguments are both const T&.  */\n+  tree args = CLASSTYPE_TI_ARGS (t);\n+  if (TREE_VEC_LENGTH (args) != 2)\n+    return false;\n+  for (int i = 0; i < 2; i++)\n+    if (!TYPE_REF_OBJ_P (TREE_VEC_ELT (args, i))\n+\t|| !CP_TYPE_CONST_P (TREE_TYPE (TREE_VEC_ELT (args, i))))\n+      return false;\n+\n+  return true;\n+}\n+\n /* Helper for maybe_warn_dangling_reference to find a problematic CALL_EXPR\n    that initializes the LHS (and at least one of its arguments represents\n    a temporary, as outlined in maybe_warn_dangling_reference), or NULL_TREE\n@@ -13556,11 +13584,6 @@ do_warn_dangling_reference (tree expr)\n \t    || warning_suppressed_p (fndecl, OPT_Wdangling_reference)\n \t    || !warning_enabled_at (DECL_SOURCE_LOCATION (fndecl),\n \t\t\t\t    OPT_Wdangling_reference)\n-\t    /* If the function doesn't return a reference, don't warn.  This\n-\t       can be e.g.\n-\t\t const int& z = std::min({1, 2, 3, 4, 5, 6, 7});\n-\t       which doesn't dangle: std::min here returns an int.  */\n-\t    || !TYPE_REF_OBJ_P (TREE_TYPE (TREE_TYPE (fndecl)))\n \t    /* Don't emit a false positive for:\n \t\tstd::vector<int> v = ...;\n \t\tstd::vector<int>::const_iterator it = v.begin();\n@@ -13573,6 +13596,20 @@ do_warn_dangling_reference (tree expr)\n \t\t&& DECL_OVERLOADED_OPERATOR_IS (fndecl, INDIRECT_REF)))\n \t  return NULL_TREE;\n \n+\ttree rettype = TREE_TYPE (TREE_TYPE (fndecl));\n+\t/* If the function doesn't return a reference, don't warn.  This\n+\t   can be e.g.\n+\t     const int& z = std::min({1, 2, 3, 4, 5, 6, 7});\n+\t   which doesn't dangle: std::min here returns an int.\n+\n+\t   If the function returns a std::pair<const T&, const T&>, we\n+\t   warn, to detect e.g.\n+\t     std::pair<const int&, const int&> v = std::minmax(1, 2);\n+\t   which also creates a dangling reference, because std::minmax\n+\t   returns std::pair<const T&, const T&>(b, a).  */\n+\tif (!(TYPE_REF_OBJ_P (rettype) || std_pair_ref_ref_p (rettype)))\n+\t  return NULL_TREE;\n+\n \t/* Here we're looking to see if any of the arguments is a temporary\n \t   initializing a reference parameter.  */\n \tfor (int i = 0; i < call_expr_nargs (expr); ++i)\n@@ -13614,6 +13651,8 @@ do_warn_dangling_reference (tree expr)\n       return do_warn_dangling_reference (TREE_OPERAND (expr, 2));\n     case PAREN_EXPR:\n       return do_warn_dangling_reference (TREE_OPERAND (expr, 0));\n+    case TARGET_EXPR:\n+      return do_warn_dangling_reference (TARGET_EXPR_INITIAL (expr));\n     default:\n       return NULL_TREE;\n     }\n@@ -13640,7 +13679,8 @@ maybe_warn_dangling_reference (const_tree decl, tree init)\n {\n   if (!warn_dangling_reference)\n     return;\n-  if (!TYPE_REF_P (TREE_TYPE (decl)))\n+  if (!(TYPE_REF_OBJ_P (TREE_TYPE (decl))\n+\t|| std_pair_ref_ref_p (TREE_TYPE (decl))))\n     return;\n   /* Don't suppress the diagnostic just because the call comes from\n      a system header.  If the DECL is not in a system header, or if"}, {"sha": "8d2a2789ef6fb73d417f1d43e1f169536fd4013f", "filename": "gcc/doc/gcc/gcc-command-options/options-controlling-c++-dialect.rst", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e3ce73849fef8b50efb427ec96f317e88c0e6cf/gcc%2Fdoc%2Fgcc%2Fgcc-command-options%2Foptions-controlling-c%2B%2B-dialect.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e3ce73849fef8b50efb427ec96f317e88c0e6cf/gcc%2Fdoc%2Fgcc%2Fgcc-command-options%2Foptions-controlling-c%2B%2B-dialect.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgcc%2Fgcc-command-options%2Foptions-controlling-c%2B%2B-dialect.rst?ref=7e3ce73849fef8b50efb427ec96f317e88c0e6cf", "patch": "@@ -855,6 +855,16 @@ In addition, these warning options have meanings only for C++ programs:\n     const T& foo (const T&) { ... }\n     #pragma GCC diagnostic pop\n \n+  :option:`-Wdangling-reference` also warns about code like\n+\n+  .. code-block:: c++\n+\n+    auto p = std::minmax(1, 2);\n+\n+  where ``std::minmax`` returns ``std::pair<const int&, const int&>``, and\n+  both references dangle after the end of the full expression that contains\n+  the call to `std::minmax``.\n+\n   This warning is enabled by :option:`-Wall`.\n \n .. option:: -Wno-dangling-reference"}, {"sha": "bf849e290d9ca012b761345e924687476cb3071e", "filename": "gcc/testsuite/g++.dg/warn/Wdangling-reference6.C", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e3ce73849fef8b50efb427ec96f317e88c0e6cf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWdangling-reference6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e3ce73849fef8b50efb427ec96f317e88c0e6cf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWdangling-reference6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWdangling-reference6.C?ref=7e3ce73849fef8b50efb427ec96f317e88c0e6cf", "patch": "@@ -0,0 +1,38 @@\n+// { dg-do compile { target c++17 } }\n+// { dg-options \"-Wdangling-reference\" }\n+// Test -Wdangling-reference with std::minmax.\n+\n+#include <algorithm>\n+\n+using U = std::pair<const int&, const int&>;\n+\n+int\n+fn1 ()\n+{\n+  std::pair<const int&, const int&> v = std::minmax(1, 2); // { dg-warning \"dangling reference\" }\n+  U v2 = std::minmax(1, 2); // { dg-warning \"dangling reference\" }\n+  auto v3 = std::minmax(1, 2); // { dg-warning \"dangling reference\" }\n+  return v.first + v2.second + v3.first;\n+}\n+\n+int\n+fn2 ()\n+{\n+  int n = 1;\n+  auto p = std::minmax(n, n + 1); // { dg-warning \"dangling reference\" }\n+  int m = p.first; // ok\n+  int x = p.second; // undefined behavior\n+\n+  // Note that structured bindings have the same issue\n+  auto [mm, xx] = std::minmax(n, n + 1); // { dg-warning \"dangling reference\" }\n+  (void) xx; // undefined behavior\n+\n+  return m + x;\n+}\n+\n+int\n+fn3 ()\n+{\n+  auto v = std::minmax({1, 2});\n+  return v.first;\n+}"}]}