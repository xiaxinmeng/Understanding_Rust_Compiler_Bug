{"sha": "804f7040cfeac59248f90852a80531f069e859c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODA0ZjcwNDBjZmVhYzU5MjQ4ZjkwODUyYTgwNTMxZjA2OWU4NTljOA==", "commit": {"author": {"name": "Vincent Celier", "email": "celier@adacore.com", "date": "2007-06-06T10:28:20Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-06T10:28:20Z"}, "message": "frontend.adb (Frontend): Return immediately if the main source could not be parsed...\n\n2007-04-20  Vincent Celier  <celier@adacore.com>\n\t    Robert Dewar  <dewar@adacore.com>\n\n\t* frontend.adb (Frontend): Return immediately if the main source could\n\tnot be parsed, because of preprocessing errors.\n\n\t* gnat1drv.adb (gnat1drv): Handle RE_Not_Available gracefully.\n\t(Gnat1drv): Exit with errors if the main source could not be parsed,\n\tbecause of preprocessing errors.\n\t(Check_Rep_Info): New procedure\n\nFrom-SVN: r125411", "tree": {"sha": "df83e6dc366f99ae70040eaadf579657a8c0ee80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df83e6dc366f99ae70040eaadf579657a8c0ee80"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/804f7040cfeac59248f90852a80531f069e859c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/804f7040cfeac59248f90852a80531f069e859c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/804f7040cfeac59248f90852a80531f069e859c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/804f7040cfeac59248f90852a80531f069e859c8/comments", "author": {"login": "vcelier", "id": 8888056, "node_id": "MDQ6VXNlcjg4ODgwNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/8888056?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vcelier", "html_url": "https://github.com/vcelier", "followers_url": "https://api.github.com/users/vcelier/followers", "following_url": "https://api.github.com/users/vcelier/following{/other_user}", "gists_url": "https://api.github.com/users/vcelier/gists{/gist_id}", "starred_url": "https://api.github.com/users/vcelier/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vcelier/subscriptions", "organizations_url": "https://api.github.com/users/vcelier/orgs", "repos_url": "https://api.github.com/users/vcelier/repos", "events_url": "https://api.github.com/users/vcelier/events{/privacy}", "received_events_url": "https://api.github.com/users/vcelier/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0712790c364b9d0de4d023ebd22fa9249afc35d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0712790c364b9d0de4d023ebd22fa9249afc35d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0712790c364b9d0de4d023ebd22fa9249afc35d5"}], "stats": {"total": 374, "additions": 224, "deletions": 150}, "files": [{"sha": "cc5c2cb849f37d4f1f5da74acb1187f0dc2de4d7", "filename": "gcc/ada/frontend.adb", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/804f7040cfeac59248f90852a80531f069e859c8/gcc%2Fada%2Ffrontend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/804f7040cfeac59248f90852a80531f069e859c8/gcc%2Fada%2Ffrontend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffrontend.adb?ref=804f7040cfeac59248f90852a80531f069e859c8", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -24,7 +24,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with GNAT.Strings; use GNAT.Strings;\n+with System.Strings; use System.Strings;\n \n with Atree;    use Atree;\n with Checks;\n@@ -34,7 +34,6 @@ with Elists;\n with Exp_Dbug;\n with Fmap;\n with Fname.UF;\n-with Hostparm; use Hostparm;\n with Inline;   use Inline;\n with Lib;      use Lib;\n with Lib.Load; use Lib.Load;\n@@ -56,6 +55,7 @@ with Sem_Warn; use Sem_Warn;\n with Sinfo;    use Sinfo;\n with Sinput;   use Sinput;\n with Sinput.L; use Sinput.L;\n+with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Types;    use Types;\n \n@@ -107,6 +107,12 @@ begin\n \n    Lib.Load.Load_Main_Source;\n \n+   --  Return immediately if the main source could not be parsed\n+\n+   if Sinput.Main_Source_File = No_Source_File then\n+      return;\n+   end if;\n+\n    --  Read and process configuration pragma files if present\n \n    declare\n@@ -208,6 +214,12 @@ begin\n \n    Opt.Register_Opt_Config_Switches;\n \n+   --  Check for file which contains No_Body pragma\n+\n+   if Source_File_Is_No_Body (Source_Index (Main_Unit)) then\n+      Change_Main_Unit_To_Spec;\n+   end if;\n+\n    --  Initialize the scanner. Note that we do this after the call to\n    --  Create_Standard, which uses the scanner in its processing of\n    --  floating-point bounds.\n@@ -318,11 +330,11 @@ begin\n    end if;\n \n    --  Qualify all entity names in inner packages, package bodies, etc.,\n-   --  except when compiling for the JVM back end, which depends on\n+   --  except when compiling for the VM back-ends, which depend on\n    --  having unqualified names in certain cases and handles the\n    --  generation of qualified names when needed.\n \n-   if not Java_VM then\n+   if VM_Target = No_VM then\n       Exp_Dbug.Qualify_All_Entity_Names;\n    end if;\n "}, {"sha": "a08d8fcb4eb8d04cddc4f5f55db58fc07adb7217", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 207, "deletions": 145, "changes": 352, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/804f7040cfeac59248f90852a80531f069e859c8/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/804f7040cfeac59248f90852a80531f069e859c8/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=804f7040cfeac59248f90852a80531f069e859c8", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -49,6 +49,7 @@ with Output;   use Output;\n with Prepcomp;\n with Repinfo;  use Repinfo;\n with Restrict;\n+with Rtsfind;\n with Sem;\n with Sem_Ch8;\n with Sem_Ch12;\n@@ -61,7 +62,7 @@ with Sinput.L; use Sinput.L;\n with Snames;\n with Sprint;   use Sprint;\n with Stringt;\n-with Targparm;\n+with Targparm; use Targparm;\n with Tree_Gen;\n with Treepr;   use Treepr;\n with Ttypes;\n@@ -83,6 +84,174 @@ procedure Gnat1drv is\n    Back_End_Mode : Back_End.Back_End_Mode_Type;\n    --  Record back end mode\n \n+   procedure Check_Bad_Body;\n+   --  Called to check if the unit we are compiling has a bad body\n+\n+   procedure Check_Rep_Info;\n+   --  Called when we are not generating code, to check if -gnatR was requested\n+   --  and if so, explain that we will not be honoring the request.\n+\n+   --------------------\n+   -- Check_Bad_Body --\n+   --------------------\n+\n+   procedure Check_Bad_Body is\n+      Sname   : Unit_Name_Type;\n+      Src_Ind : Source_File_Index;\n+      Fname   : File_Name_Type;\n+\n+      procedure Bad_Body_Error (Msg : String);\n+      --  Issue message for bad body found\n+\n+      --------------------\n+      -- Bad_Body_Error --\n+      --------------------\n+\n+      procedure Bad_Body_Error (Msg : String) is\n+      begin\n+         Error_Msg_N (Msg, Main_Unit_Node);\n+         Error_Msg_File_1 := Fname;\n+         Error_Msg_N (\"remove incorrect body in file{!\", Main_Unit_Node);\n+      end Bad_Body_Error;\n+\n+      --  Start of processing for Check_Bad_Body\n+\n+   begin\n+      --  Nothing to do if we are only checking syntax, because we don't know\n+      --  enough to know if we require or forbid a body in this case.\n+\n+      if Operating_Mode = Check_Syntax then\n+         return;\n+      end if;\n+\n+      --  Check for body not allowed\n+\n+      if (Main_Kind = N_Package_Declaration\n+           and then not Body_Required (Main_Unit_Node))\n+        or else (Main_Kind = N_Generic_Package_Declaration\n+                  and then not Body_Required (Main_Unit_Node))\n+        or else Main_Kind = N_Package_Renaming_Declaration\n+        or else Main_Kind = N_Subprogram_Renaming_Declaration\n+        or else Nkind (Original_Node (Unit (Main_Unit_Node)))\n+                         in N_Generic_Instantiation\n+      then\n+         Sname := Unit_Name (Main_Unit);\n+\n+         --  If we do not already have a body name, then get the body name\n+         --  (but how can we have a body name here ???)\n+\n+         if not Is_Body_Name (Sname) then\n+            Sname := Get_Body_Name (Sname);\n+         end if;\n+\n+         Fname := Get_File_Name (Sname, Subunit => False);\n+         Src_Ind := Load_Source_File (Fname);\n+\n+         --  Case where body is present and it is not a subunit. Exclude\n+         --  the subunit case, because it has nothing to do with the\n+         --  package we are compiling. It is illegal for a child unit and a\n+         --  subunit with the same expanded name (RM 10.2(9)) to appear\n+         --  together in a partition, but there is nothing to stop a\n+         --  compilation environment from having both, and the test here\n+         --  simply allows that. If there is an attempt to include both in\n+         --  a partition, this is diagnosed at bind time. In Ada 83 mode\n+         --  this is not a warning case.\n+\n+         --  Note: if weird file names are being used, we can have\n+         --  situation where the file name that supposedly contains body,\n+         --  in fact contains a spec, or we can't tell what it contains.\n+         --  Skip the error message in these cases.\n+\n+         --  Also ignore body that is nothing but pragma No_Body; (that's the\n+         --  whole point of this pragma, to be used this way and to cause the\n+         --  body file to be ignored in this context).\n+\n+         if Src_Ind /= No_Source_File\n+           and then Get_Expected_Unit_Type (Fname) = Expect_Body\n+           and then not Source_File_Is_Subunit (Src_Ind)\n+           and then not Source_File_Is_No_Body (Src_Ind)\n+         then\n+            Errout.Finalize;\n+\n+            Error_Msg_Unit_1 := Sname;\n+\n+            --  Ada 83 case of a package body being ignored. This is not an\n+            --  error as far as the Ada 83 RM is concerned, but it is almost\n+            --  certainly not what is wanted so output a warning. Give this\n+            --  message only if there were no errors, since otherwise it may\n+            --  be incorrect (we may have misinterpreted a junk spec as not\n+            --  needing a body when it really does).\n+\n+            if Main_Kind = N_Package_Declaration\n+              and then Ada_Version = Ada_83\n+              and then Operating_Mode = Generate_Code\n+              and then Distribution_Stub_Mode /= Generate_Caller_Stub_Body\n+              and then not Compilation_Errors\n+            then\n+               Error_Msg_N\n+                 (\"package $$ does not require a body?\", Main_Unit_Node);\n+               Error_Msg_File_1 := Fname;\n+               Error_Msg_N (\"body in file{? will be ignored\", Main_Unit_Node);\n+\n+               --  Ada 95 cases of a body file present when no body is\n+               --  permitted. This we consider to be an error.\n+\n+            else\n+               --  For generic instantiations, we never allow a body\n+\n+               if Nkind (Original_Node (Unit (Main_Unit_Node)))\n+               in N_Generic_Instantiation\n+               then\n+                  Bad_Body_Error\n+                    (\"generic instantiation for $$ does not allow a body\");\n+\n+                  --  A library unit that is a renaming never allows a body\n+\n+               elsif Main_Kind in N_Renaming_Declaration then\n+                  Bad_Body_Error\n+                    (\"renaming declaration for $$ does not allow a body!\");\n+\n+                  --  Remaining cases are packages and generic packages. Here\n+                  --  we only do the test if there are no previous errors,\n+                  --  because if there are errors, they may lead us to\n+                  --  incorrectly believe that a package does not allow a body\n+                  --  when in fact it does.\n+\n+               elsif not Compilation_Errors then\n+                  if Main_Kind = N_Package_Declaration then\n+                     Bad_Body_Error\n+                       (\"package $$ does not allow a body!\");\n+\n+                  elsif Main_Kind = N_Generic_Package_Declaration then\n+                     Bad_Body_Error\n+                       (\"generic package $$ does not allow a body!\");\n+                  end if;\n+               end if;\n+\n+            end if;\n+         end if;\n+      end if;\n+   end Check_Bad_Body;\n+\n+   --------------------\n+   -- Check_Rep_Info --\n+   --------------------\n+\n+   procedure Check_Rep_Info is\n+   begin\n+      if List_Representation_Info /= 0\n+        or else List_Representation_Info_Mechanisms\n+      then\n+         Write_Eol;\n+         Write_Str\n+           (\"cannot generate representation information, no code generated\");\n+         Write_Eol;\n+         Write_Eol;\n+      end if;\n+   end Check_Rep_Info;\n+\n+--  Start of processing for Gnat1drv\n+\n begin\n    --  This inner block is set up to catch assertion errors and constraint\n    --  errors. Since the code for handling these errors can cause another\n@@ -91,8 +260,7 @@ begin\n \n    begin\n       --  Lib.Initialize need to be called before Scan_Compiler_Arguments,\n-      --  because it initialize a table that is filled by\n-      --  Scan_Compiler_Arguments.\n+      --  because it initializes a table filled by Scan_Compiler_Arguments.\n \n       Osint.Initialize;\n       Fmap.Reset_Tables;\n@@ -125,7 +293,7 @@ begin\n          use Sinput;\n \n          S : Source_File_Index;\n-         N : Name_Id;\n+         N : File_Name_Type;\n \n       begin\n          Name_Buffer (1 .. 10) := \"system.ads\";\n@@ -147,9 +315,9 @@ begin\n          end if;\n \n          Targparm.Get_Target_Parameters\n-           (System_Text  => Source_Text (S),\n+           (System_Text  => Source_Text  (S),\n             Source_First => Source_First (S),\n-            Source_Last  => Source_Last (S));\n+            Source_Last  => Source_Last  (S));\n \n          --  Acquire configuration pragma information from Targparm\n \n@@ -173,7 +341,7 @@ begin\n       --  Output copyright notice if full list mode unless we have a list\n       --  file, in which case we defer this so that it is output in the file\n \n-      if (Verbose_Mode or else (Full_List and Full_List_File_Name = null))\n+      if (Verbose_Mode or else (Full_List and then Full_List_File_Name = null))\n         and then not Debug_Flag_7\n       then\n          Write_Eol;\n@@ -230,9 +398,9 @@ begin\n          Suppress_Options (Overflow_Check) := True;\n       end if;\n \n-      --  Check we have exactly one source file, this happens only in the case\n-      --  where the driver is called directly, it cannot happen when gnat1 is\n-      --  invoked from gcc in the normal case.\n+      --  Check we do not have more than one source file, this happens only in\n+      --  the case where the driver is called directly, it cannot happen when\n+      --  gnat1 is invoked from gcc in the normal case.\n \n       if Osint.Number_Of_Files /= 1 then\n          Usage;\n@@ -245,145 +413,27 @@ begin\n \n       Original_Operating_Mode := Operating_Mode;\n       Frontend;\n-      Main_Unit_Node := Cunit (Main_Unit);\n-      Main_Kind := Nkind (Unit (Main_Unit_Node));\n-\n-      --  Check for suspicious or incorrect body present if we are doing\n-      --  semantic checking. We omit this check in syntax only mode, because\n-      --  in that case we do not know if we need a body or not.\n-\n-      if Operating_Mode /= Check_Syntax\n-        and then\n-          ((Main_Kind = N_Package_Declaration\n-             and then not Body_Required (Main_Unit_Node))\n-           or else (Main_Kind = N_Generic_Package_Declaration\n-                     and then not Body_Required (Main_Unit_Node))\n-           or else Main_Kind = N_Package_Renaming_Declaration\n-           or else Main_Kind = N_Subprogram_Renaming_Declaration\n-           or else Nkind (Original_Node (Unit (Main_Unit_Node)))\n-                           in N_Generic_Instantiation)\n-      then\n-         Bad_Body : declare\n-            Sname   : Unit_Name_Type := Unit_Name (Main_Unit);\n-            Src_Ind : Source_File_Index;\n-            Fname   : File_Name_Type;\n-\n-            procedure Bad_Body_Error (Msg : String);\n-            --  Issue message for bad body found\n-\n-            --------------------\n-            -- Bad_Body_Error --\n-            --------------------\n-\n-            procedure Bad_Body_Error (Msg : String) is\n-            begin\n-               Error_Msg_N (Msg, Main_Unit_Node);\n-               Error_Msg_Name_1 := Fname;\n-               Error_Msg_N\n-                 (\"remove incorrect body in file{!\", Main_Unit_Node);\n-            end Bad_Body_Error;\n-\n-         --  Start of processing for Bad_Body\n \n-         begin\n-            Sname := Unit_Name (Main_Unit);\n+      --  Exit with errors if the main source could not be parsed\n \n-            --  If we do not already have a body name, then get the body name\n-            --  (but how can we have a body name here ???)\n-\n-            if not Is_Body_Name (Sname) then\n-               Sname := Get_Body_Name (Sname);\n-            end if;\n-\n-            Fname := Get_File_Name (Sname, Subunit => False);\n-            Src_Ind := Load_Source_File (Fname);\n-\n-            --  Case where body is present and it is not a subunit. Exclude\n-            --  the subunit case, because it has nothing to do with the\n-            --  package we are compiling. It is illegal for a child unit and a\n-            --  subunit with the same expanded name (RM 10.2(9)) to appear\n-            --  together in a partition, but there is nothing to stop a\n-            --  compilation environment from having both, and the test here\n-            --  simply allows that. If there is an attempt to include both in\n-            --  a partition, this is diagnosed at bind time. In Ada 83 mode\n-            --  this is not a warning case.\n-\n-            --  Note: if weird file names are being used, we can have\n-            --  situation where the file name that supposedly contains body,\n-            --  in fact contains a spec, or we can't tell what it contains.\n-            --  Skip the error message in these cases.\n-\n-            if Src_Ind /= No_Source_File\n-              and then Get_Expected_Unit_Type (Fname) = Expect_Body\n-              and then not Source_File_Is_Subunit (Src_Ind)\n-            then\n-               Error_Msg_Name_1 := Sname;\n-\n-               --  Ada 83 case of a package body being ignored. This is not an\n-               --  error as far as the Ada 83 RM is concerned, but it is\n-               --  almost certainly not what is wanted so output a warning.\n-               --  Give this message only if there were no errors, since\n-               --  otherwise it may be incorrect (we may have misinterpreted a\n-               --  junk spec as not needing a body when it really does).\n-\n-               if Main_Kind = N_Package_Declaration\n-                 and then Ada_Version = Ada_83\n-                 and then Operating_Mode = Generate_Code\n-                 and then Distribution_Stub_Mode /= Generate_Caller_Stub_Body\n-                 and then not Compilation_Errors\n-               then\n-                  Error_Msg_N\n-                    (\"package % does not require a body?\", Main_Unit_Node);\n-                  Error_Msg_Name_1 := Fname;\n-                  Error_Msg_N\n-                    (\"body in file{? will be ignored\", Main_Unit_Node);\n-\n-               --  Ada 95 cases of a body file present when no body is\n-               --  permitted. This we consider to be an error.\n-\n-               else\n-                  --  For generic instantiations, we never allow a body\n-\n-                  if Nkind (Original_Node (Unit (Main_Unit_Node)))\n-                      in N_Generic_Instantiation\n-                  then\n-                     Bad_Body_Error\n-                       (\"generic instantiation for % does not allow a body\");\n-\n-                  --  A library unit that is a renaming never allows a body\n-\n-                  elsif Main_Kind in N_Renaming_Declaration then\n-                     Bad_Body_Error\n-                       (\"renaming declaration for % does not allow a body!\");\n-\n-                  --  Remaining cases are packages and generic packages. Here\n-                  --  we only do the test if there are no previous errors,\n-                  --  because if there are errors, they may lead us to\n-                  --  incorrectly believe that a package does not allow a body\n-                  --  when in fact it does.\n-\n-                  elsif not Compilation_Errors then\n-                     if Main_Kind = N_Package_Declaration then\n-                        Bad_Body_Error\n-                          (\"package % does not allow a body!\");\n-\n-                     elsif Main_Kind = N_Generic_Package_Declaration then\n-                        Bad_Body_Error\n-                          (\"generic package % does not allow a body!\");\n-                     end if;\n-                  end if;\n-\n-               end if;\n-            end if;\n-         end Bad_Body;\n+      if Sinput.Main_Source_File = No_Source_File then\n+         Errout.Finalize;\n+         Errout.Output_Messages;\n+         Exit_Program (E_Errors);\n       end if;\n \n+      Main_Unit_Node := Cunit (Main_Unit);\n+      Main_Kind := Nkind (Unit (Main_Unit_Node));\n+      Check_Bad_Body;\n+\n       --  Exit if compilation errors detected\n \n+      Errout.Finalize;\n+\n       if Compilation_Errors then\n          Treepr.Tree_Dump;\n          Sem_Ch13.Validate_Unchecked_Conversions;\n-         Errout.Finalize;\n+         Errout.Output_Messages;\n          Namet.Finalize;\n \n          --  Generate ALI file if specially requested\n@@ -417,8 +467,10 @@ begin\n       if Original_Operating_Mode = Check_Syntax then\n          Treepr.Tree_Dump;\n          Errout.Finalize;\n+         Errout.Output_Messages;\n          Tree_Gen;\n          Namet.Finalize;\n+         Check_Rep_Info;\n \n          --  Use a goto instead of calling Exit_Program so that finalization\n          --  occurs normally.\n@@ -561,10 +613,12 @@ begin\n \n          Sem_Ch13.Validate_Unchecked_Conversions;\n          Errout.Finalize;\n+         Errout.Output_Messages;\n          Treepr.Tree_Dump;\n          Tree_Gen;\n          Write_ALI (Object => False);\n          Namet.Finalize;\n+         Check_Rep_Info;\n \n          --  Exit program with error indication, to kill object file\n \n@@ -581,20 +635,22 @@ begin\n       --  enabled, because the front end determines representations.\n \n       --  Annotation is also suppressed in the case of compiling for\n-      --  the Java VM, since representations are largely symbolic there.\n+      --  a VM, since representations are largely symbolic there.\n \n       if Back_End_Mode = Declarations_Only\n         and then (not Back_Annotate_Rep_Info\n-                    or else Main_Kind = N_Subunit\n-                    or else Targparm.Frontend_Layout_On_Target\n-                    or else Hostparm.Java_VM)\n+                   or else Main_Kind = N_Subunit\n+                   or else Targparm.Frontend_Layout_On_Target\n+                   or else Targparm.VM_Target /= No_VM)\n       then\n          Sem_Ch13.Validate_Unchecked_Conversions;\n          Errout.Finalize;\n+         Errout.Output_Messages;\n          Write_ALI (Object => False);\n          Tree_Dump;\n          Tree_Gen;\n          Namet.Finalize;\n+         Check_Rep_Info;\n          return;\n       end if;\n \n@@ -624,6 +680,7 @@ begin\n \n       --  Here we call the back end to generate the output code\n \n+      Generating_Code := True;\n       Back_End.Call_Back_End (Back_End_Mode);\n \n       --  Once the backend is complete, we unlock the names table. This call\n@@ -644,6 +701,7 @@ begin\n       --  representation information for List_Rep_Info.\n \n       Errout.Finalize;\n+      Errout.Output_Messages;\n       List_Rep_Info;\n \n       --  Only write the library if the backend did not generate any error\n@@ -673,6 +731,9 @@ begin\n    exception\n       --  Handle fatal internal compiler errors\n \n+      when Rtsfind.RE_Not_Available =>\n+         Comperr.Compiler_Abort (\"RE_Not_Available\");\n+\n       when System.Assertions.Assert_Failure =>\n          Comperr.Compiler_Abort (\"Assert_Failure\");\n \n@@ -698,6 +759,7 @@ begin\n exception\n    when Unrecoverable_Error =>\n       Errout.Finalize;\n+      Errout.Output_Messages;\n \n       Set_Standard_Error;\n       Write_Str (\"compilation abandoned\");"}]}