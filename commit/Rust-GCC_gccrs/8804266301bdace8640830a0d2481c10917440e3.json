{"sha": "8804266301bdace8640830a0d2481c10917440e3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODgwNDI2NjMwMWJkYWNlODY0MDgzMGEwZDI0ODFjMTA5MTc0NDBlMw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-08-19T05:25:53Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-08-19T05:25:53Z"}, "message": "mcore.c (mode_from_align): Remove DImode.\n\n        * config/mcore/mcore.c (mode_from_align): Remove DImode.\n        (block_move_sequence): Rewrite to use adjust_address.\n        (mcore_expand_block_move): Cleanup logic.  Accept only operands.\n        Return boolean indicating success/failure.\n        * config/mcore/mcore-protos.h (mcore_expand_block_move): Update decl.\n        * config/mcore/mcore.md (movmemsi): Update to match.\n\nFrom-SVN: r86234", "tree": {"sha": "01216a0943b59c1d93a0635b12ccf67dcd3bd4bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01216a0943b59c1d93a0635b12ccf67dcd3bd4bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8804266301bdace8640830a0d2481c10917440e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8804266301bdace8640830a0d2481c10917440e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8804266301bdace8640830a0d2481c10917440e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8804266301bdace8640830a0d2481c10917440e3/comments", "author": null, "committer": null, "parents": [{"sha": "27ab0504a862cd9441a549c288d6b9716306de8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27ab0504a862cd9441a549c288d6b9716306de8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27ab0504a862cd9441a549c288d6b9716306de8f"}], "stats": {"total": 184, "additions": 90, "deletions": 94}, "files": [{"sha": "725fb34eca932be81bd0994ddc637e1320aa2bfe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8804266301bdace8640830a0d2481c10917440e3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8804266301bdace8640830a0d2481c10917440e3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8804266301bdace8640830a0d2481c10917440e3", "patch": "@@ -1,3 +1,12 @@\n+2004-08-18  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/mcore/mcore.c (mode_from_align): Remove DImode.\n+\t(block_move_sequence): Rewrite to use adjust_address.\n+\t(mcore_expand_block_move): Cleanup logic.  Accept only operands.\n+\tReturn boolean indicating success/failure.\n+\t* config/mcore/mcore-protos.h (mcore_expand_block_move): Update decl.\n+\t* config/mcore/mcore.md (movmemsi): Update to match.\n+\n 2004-08-18  Mike Stump  <mrs@apple.com>\n \n \t* doc/invoke.texi (-mfix-and-continue): Add support for"}, {"sha": "35cb69b75a038155e0d6df67c79c830eea4cb115", "filename": "gcc/config/mcore/mcore-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8804266301bdace8640830a0d2481c10917440e3/gcc%2Fconfig%2Fmcore%2Fmcore-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8804266301bdace8640830a0d2481c10917440e3/gcc%2Fconfig%2Fmcore%2Fmcore-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore-protos.h?ref=8804266301bdace8640830a0d2481c10917440e3", "patch": "@@ -57,7 +57,7 @@ extern char *       mcore_output_call          \t\t(rtx *, int);\n extern int          mcore_is_dead                \t(rtx, rtx);\n extern int          mcore_expand_insv            \t(rtx *);\n extern int          mcore_modify_comparison      \t(RTX_CODE);\n-extern void         mcore_expand_block_move      \t(rtx, rtx, rtx *);\n+extern bool         mcore_expand_block_move      \t(rtx *);\n extern const char * mcore_output_andn          \t\t(rtx, rtx *);\n extern void         mcore_print_operand_address  \t(FILE *, rtx);\n extern void         mcore_print_operand          \t(FILE *, rtx, int);"}, {"sha": "d121848209a519828c4ad5b73eac045c0e26b354", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 76, "deletions": 87, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8804266301bdace8640830a0d2481c10917440e3/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8804266301bdace8640830a0d2481c10917440e3/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=8804266301bdace8640830a0d2481c10917440e3", "patch": "@@ -122,7 +122,6 @@ static int        calc_live_regs                (int *);\n static int        const_ok_for_mcore            (int);\n static int        try_constant_tricks           (long, int *, int *);\n static const char *     output_inline_const     (enum machine_mode, rtx *);\n-static void       block_move_sequence           (rtx, rtx, rtx, rtx, int, int, int);\n static void       layout_mcore_frame            (struct mcore_frame *);\n static void       mcore_setup_incoming_varargs\t(CUMULATIVE_ARGS *, enum machine_mode, tree, int *, int);\n static cond_type  is_cond_candidate             (rtx);\n@@ -1824,127 +1823,117 @@ mcore_store_multiple_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n static const enum machine_mode mode_from_align[] =\n {\n   VOIDmode, QImode, HImode, VOIDmode, SImode,\n-  VOIDmode, VOIDmode, VOIDmode, DImode\n };\n \n static void\n-block_move_sequence (rtx dest, rtx dst_mem, rtx src, rtx src_mem,\n-\t\t     int size, int align, int offset)\n+block_move_sequence (rtx dst_mem, rtx src_mem, int size, int align)\n {\n   rtx temp[2];\n   enum machine_mode mode[2];\n   int amount[2];\n-  int active[2];\n+  bool active[2];\n   int phase = 0;\n   int next;\n-  int offset_ld = offset;\n-  int offset_st = offset;\n+  int offset_ld = 0;\n+  int offset_st = 0;\n+  rtx x;\n \n-  active[0] = active[1] = FALSE;\n-\n-  /* Establish parameters for the first load and for the second load if\n-     it is known to be the same mode as the first.  */\n-  amount[0] = amount[1] = align;\n-\n-  mode[0] = mode_from_align[align];\n+  x = XEXP (dst_mem, 0);\n+  if (!REG_P (x))\n+    {\n+      x = force_reg (Pmode, x);\n+      dst_mem = replace_equiv_address (dst_mem, x);\n+    }\n \n-  temp[0] = gen_reg_rtx (mode[0]);\n-  \n-  if (size >= 2 * align)\n+  x = XEXP (src_mem, 0);\n+  if (!REG_P (x))\n     {\n-      mode[1] = mode[0];\n-      temp[1] = gen_reg_rtx (mode[1]);\n+      x = force_reg (Pmode, x);\n+      src_mem = replace_equiv_address (src_mem, x);\n     }\n \n+  active[0] = active[1] = false;\n+\n   do\n     {\n-      rtx srcp, dstp;\n-      \n       next = phase;\n-      phase = !phase;\n+      phase ^= 1;\n \n       if (size > 0)\n \t{\n-\t  /* Change modes as the sequence tails off.  */\n-\t  if (size < amount[next])\n-\t    {\n-\t      amount[next] = (size >= 4 ? 4 : (size >= 2 ? 2 : 1));\n-\t      mode[next] = mode_from_align[amount[next]];\n-\t      temp[next] = gen_reg_rtx (mode[next]);\n-\t    }\n-\t  \n-\t  size -= amount[next];\n-\t  srcp = gen_rtx_MEM (\n-#if 0\n-\t\t\t  MEM_IN_STRUCT_P (src_mem) ? mode[next] : BLKmode,\n-#else\n-\t\t\t  mode[next],\n-#endif\n-\t\t\t  gen_rtx_PLUS (Pmode, src, GEN_INT (offset_ld)));\n-\t  \n-\t  MEM_READONLY_P (srcp) = MEM_READONLY_P (src_mem);\n-\t  MEM_VOLATILE_P (srcp) = MEM_VOLATILE_P (src_mem);\n-\t  MEM_IN_STRUCT_P (srcp) = 1;\n-\t  emit_insn (gen_rtx_SET (VOIDmode, temp[next], srcp));\n-\t  offset_ld += amount[next];\n-\t  active[next] = TRUE;\n+\t  int next_amount;\n+\n+\t  next_amount = (size >= 4 ? 4 : (size >= 2 ? 2 : 1));\n+\t  next_amount = MIN (next_amount, align);\n+\n+\t  amount[next] = next_amount;\n+\t  mode[next] = mode_from_align[next_amount];\n+\t  temp[next] = gen_reg_rtx (mode[next]);\n+\n+\t  x = adjust_address (src_mem, mode[next], offset_ld);\n+\t  emit_insn (gen_rtx_SET (VOIDmode, temp[next], x));\n+\n+\t  offset_ld += next_amount;\n+\t  size -= next_amount;\n+\t  active[next] = true;\n \t}\n \n       if (active[phase])\n \t{\n-\t  active[phase] = FALSE;\n-\t  \n-\t  dstp = gen_rtx_MEM (\n-#if 0\n-\t\t\t  MEM_IN_STRUCT_P (dst_mem) ? mode[phase] : BLKmode,\n-#else\n-\t\t\t  mode[phase],\n-#endif\n-\t\t\t  gen_rtx_PLUS (Pmode, dest, GEN_INT (offset_st)));\n+\t  active[phase] = false;\n \t  \n-\t  MEM_READONLY_P (dstp) = MEM_READONLY_P (dst_mem);\n-\t  MEM_VOLATILE_P (dstp) = MEM_VOLATILE_P (dst_mem);\n-\t  MEM_IN_STRUCT_P (dstp) = 1;\n-\t  emit_insn (gen_rtx_SET (VOIDmode, dstp, temp[phase]));\n+\t  x = adjust_address (dst_mem, mode[phase], offset_st);\n+\t  emit_insn (gen_rtx_SET (VOIDmode, x, temp[phase]));\n+\n \t  offset_st += amount[phase];\n \t}\n     }\n   while (active[next]);\n }\n \n-void\n-mcore_expand_block_move (rtx dst_mem, rtx src_mem, rtx * operands)\n+bool\n+mcore_expand_block_move (rtx *operands)\n {\n-  int align = INTVAL (operands[3]);\n-  int bytes;\n+  HOST_WIDE_INT align, bytes, max;\n+\n+  if (GET_CODE (operands[2]) != CONST_INT)\n+    return false;\n+\n+  bytes = INTVAL (operands[2]);\n+  align = INTVAL (operands[3]);\n \n-  if (GET_CODE (operands[2]) == CONST_INT)\n+  if (bytes <= 0)\n+    return false;\n+  if (align > 4)\n+    align = 4;\n+\n+  switch (align)\n     {\n-      bytes = INTVAL (operands[2]);\n-      \n-      if (bytes <= 0)\n-\treturn;\n-      if (align > 4)\n-\talign = 4;\n-      \n-      /* RBE: bumped 1 and 2 byte align from 1 and 2 to 4 and 8 bytes before\n-         we give up and go to memcpy.  */\n-      if ((align == 4 && (bytes <= 4*4\n-\t\t\t  || ((bytes & 01) == 0 && bytes <= 8*4)\n-\t\t\t  || ((bytes & 03) == 0 && bytes <= 16*4)))\n-\t  || (align == 2 && bytes <= 4*2)\n-\t  || (align == 1 && bytes <= 4*1))\n-\t{\n-\t  block_move_sequence (operands[0], dst_mem, operands[1], src_mem,\n-\t\t\t       bytes, align, 0);\n-\t  return;\n-\t}\n+    case 4:\n+      if (bytes & 1)\n+\tmax = 4*4;\n+      else if (bytes & 3)\n+\tmax = 8*4;\n+      else\n+\tmax = 16*4;\n+      break;\n+    case 2:\n+      max = 4*2;\n+      break;\n+    case 1:\n+      max = 4*1;\n+      break;\n+    default:\n+      abort ();\n+    }\n+\n+  if (bytes <= max)\n+    {\n+      block_move_sequence (operands[0], operands[1], bytes, align);\n+      return true;\n     }\n \n-  /* If we get here, just use the library routine.  */\n-  emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"memcpy\"), 0, VOIDmode, 3,\n-\t\t     operands[0], Pmode, operands[1], Pmode, operands[2],\n-\t\t     SImode);\n+  return false;\n }\n \f\n \n@@ -3104,7 +3093,7 @@ mcore_function_arg (CUMULATIVE_ARGS cum, enum machine_mode mode,\n {\n   int arg_reg;\n   \n-  if (! named)\n+  if (! named || mode == VOIDmode)\n     return 0;\n \n   if (targetm.calls.must_pass_in_stack (mode, type))"}, {"sha": "b45a3c6c815a725f18b8591cd2af225cfd9c3747", "filename": "gcc/config/mcore/mcore.md", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8804266301bdace8640830a0d2481c10917440e3/gcc%2Fconfig%2Fmcore%2Fmcore.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8804266301bdace8640830a0d2481c10917440e3/gcc%2Fconfig%2Fmcore%2Fmcore.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.md?ref=8804266301bdace8640830a0d2481c10917440e3", "patch": "@@ -2854,12 +2854,10 @@\n   \"\"\n   \"\n {\n-  rtx dest_mem = operands[0];\n-  rtx src_mem = operands[1];\n-  operands[0] = copy_to_mode_reg (SImode, XEXP (operands[0], 0));\n-  operands[1] = copy_to_mode_reg (SImode, XEXP (operands[1], 0));\n-  mcore_expand_block_move (dest_mem, src_mem, operands);\n-  DONE;\n+  if (mcore_expand_block_move (operands))\n+    DONE;\n+  else\n+    FAIL;\n }\")\n \n ;; ;;; ??? These patterns are meant to be generated from expand_block_move,"}]}