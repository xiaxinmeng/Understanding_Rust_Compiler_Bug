{"sha": "13112239f8d4e4b2f27fdd9698df558614b4321c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTMxMTIyMzlmOGQ0ZTRiMmYyN2ZkZDk2OThkZjU1ODYxNGI0MzIxYw==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2021-01-04T20:28:55Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-05-04T09:17:31Z"}, "message": "[Ada] Ongoing work for AI12-0212: container aggregates\n\ngcc/ada/\n\n\t* exp_aggr.adb (Build_Siz_Exp): new function, subsidiary of\n\tExpand_Container_Aggregate, to create an expression to be used\n\tin the dynamic allocation of a container with a single container\n\telement association.\n\t(Add_Range): Handle static bounds of ranges over enumerations.\n\t(Expand_Container_Aggregate): Add declaration for size\n\texpression when needed, and use it in container object\n\tdeclaration for container.", "tree": {"sha": "dd7e4e14ffbb32d231073173f5c86851088a904c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd7e4e14ffbb32d231073173f5c86851088a904c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/13112239f8d4e4b2f27fdd9698df558614b4321c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13112239f8d4e4b2f27fdd9698df558614b4321c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13112239f8d4e4b2f27fdd9698df558614b4321c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13112239f8d4e4b2f27fdd9698df558614b4321c/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "213c9dc78ecb2027e4691a6097c5fda6c2f06a63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/213c9dc78ecb2027e4691a6097c5fda6c2f06a63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/213c9dc78ecb2027e4691a6097c5fda6c2f06a63"}], "stats": {"total": 236, "additions": 180, "deletions": 56}, "files": [{"sha": "3a37f380d0166b0ccb9bdb732c334d5d2fff0fb5", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 180, "deletions": 56, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13112239f8d4e4b2f27fdd9698df558614b4321c/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13112239f8d4e4b2f27fdd9698df558614b4321c/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=13112239f8d4e4b2f27fdd9698df558614b4321c", "patch": "@@ -6982,11 +6982,24 @@ package body Exp_Aggr is\n       Init_Stat : Node_Id;\n       Siz       : Int;\n \n+      --  The following are used when the size of the aggregate is not\n+      --  static and requires a dynamic evaluation.\n+      Siz_Decl   : Node_Id;\n+      Siz_Exp    : Node_Id := Empty;\n+      Count_Type : Entity_Id;\n+\n       function Aggregate_Size return Int;\n       --  Compute number of entries in aggregate, including choices\n-      --  that cover a range, as well as iterated constructs.\n+      --  that cover a range or subtype, as well as iterated constructs.\n       --  Return -1 if the size is not known statically, in which case\n-      --  we allocate a default size for the aggregate.\n+      --  allocate a default size for the aggregate, or build an expression\n+      --  to estimate the size dynamically.\n+\n+      function Build_Siz_Exp (Comp : Node_Id) return Int;\n+      --  When the aggregate contains a single Iterated_Component_Association\n+      --  or Element_Association with non-static bounds, build an expression\n+      --  to be used as the allocated size of the container. This may be an\n+      --  overestimate if a filter is present, but is a safe approximation.\n \n       procedure Expand_Iterated_Component (Comp : Node_Id);\n       --  Handle iterated_component_association and iterated_Element\n@@ -7005,34 +7018,54 @@ package body Exp_Aggr is\n          Siz     : Int := 0;\n \n          procedure Add_Range_Size;\n-         --  Compute size of component association given by\n-         --  range or subtype name.\n+         --  Compute number of components specified by a component association\n+         --  given by a range or subtype name.\n+\n+         --------------------\n+         -- Add_Range_Size --\n+         --------------------\n \n          procedure Add_Range_Size is\n          begin\n+            --  The bounds of the discrete range are integers or enumeration\n+            --  literals\n+\n             if Nkind (Lo) = N_Integer_Literal then\n                Siz := Siz + UI_To_Int (Intval (Hi))\n-                 - UI_To_Int (Intval (Lo)) + 1;\n+                          - UI_To_Int (Intval (Lo)) + 1;\n+            else\n+               Siz := Siz + UI_To_Int (Enumeration_Pos (Hi))\n+                          - UI_To_Int (Enumeration_Pos (Lo)) + 1;\n             end if;\n          end Add_Range_Size;\n \n       begin\n+         --  Aggregate is either all positional or all named.\n+\n          if Present (Expressions (N)) then\n             Siz := List_Length (Expressions (N));\n          end if;\n \n          if Present (Component_Associations (N)) then\n             Comp := First (Component_Associations (N));\n-\n-            --  If the component is an Iterated_Element_Association\n-            --  it includes an iterator or a loop parameter, possibly\n-            --  with a filter, so we do not attempt to compute its\n-            --  size. Room for future optimization ???\n-\n-            if Nkind (Comp) = N_Iterated_Element_Association then\n-               return -1;\n+            --  If there is a single component association it can be\n+            --  an iterated component with dynamic bounds or an element\n+            --  iterator over an iterable object. If it is an array\n+            --  we can use the attribute Length to get its size;\n+            --  for a predefined container the function Length plays\n+            --  the same role. There is no available mechanism for\n+            --  user-defined containers. For now we treat all of these\n+            --  as dynamic.\n+\n+            if List_Length (Component_Associations (N)) = 1\n+              and then Nkind (Comp) in N_Iterated_Component_Association |\n+                                       N_Iterated_Element_Association\n+            then\n+               return Build_Siz_Exp (Comp);\n             end if;\n \n+            --  Otherwise all associations must specify static sizes.\n+\n             while Present (Comp) loop\n                Choice := First (Choice_List (Comp));\n \n@@ -7042,26 +7075,14 @@ package body Exp_Aggr is\n                   if Nkind (Choice) = N_Range then\n                      Lo := Low_Bound (Choice);\n                      Hi := High_Bound (Choice);\n-                     if Nkind (Lo) /= N_Integer_Literal\n-                       or else Nkind (Hi) /= N_Integer_Literal\n-                     then\n-                        return -1;\n-                     else\n-                        Add_Range_Size;\n-                     end if;\n+                     Add_Range_Size;\n \n                   elsif Is_Entity_Name (Choice)\n                     and then Is_Type (Entity (Choice))\n                   then\n                      Lo := Type_Low_Bound (Entity (Choice));\n                      Hi := Type_High_Bound (Entity (Choice));\n-                     if Nkind (Lo) /= N_Integer_Literal\n-                       or else Nkind (Hi) /= N_Integer_Literal\n-                     then\n-                        return -1;\n-                     else\n-                        Add_Range_Size;\n-                     end if;\n+                     Add_Range_Size;\n \n                      Rewrite (Choice,\n                        Make_Range (Loc,\n@@ -7084,6 +7105,55 @@ package body Exp_Aggr is\n          return Siz;\n       end Aggregate_Size;\n \n+      -------------------\n+      -- Build_Siz_Exp --\n+      -------------------\n+\n+      function Build_Siz_Exp (Comp : Node_Id) return Int is\n+         Lo, Hi : Node_Id;\n+      begin\n+         if Nkind (Comp) = N_Range then\n+            Lo := Low_Bound (Comp);\n+            Hi := High_Bound (Comp);\n+            Analyze (Lo);\n+            Analyze (Hi);\n+\n+            --  Compute static size when possible.\n+\n+            if Is_Static_Expression (Lo)\n+              and then Is_Static_Expression (Hi)\n+            then\n+               if Nkind (Lo) = N_Integer_Literal then\n+                  Siz := UI_To_Int (Intval (Hi)) - UI_To_Int (Intval (Lo)) + 1;\n+               else\n+                  Siz := UI_To_Int (Enumeration_Pos (Hi))\n+                       - UI_To_Int (Enumeration_Pos (Lo)) + 1;\n+               end if;\n+               return Siz;\n+\n+            else\n+               Siz_Exp :=\n+                 Make_Op_Add (Sloc (Comp),\n+                   Left_Opnd =>\n+                     Make_Op_Subtract (Sloc (Comp),\n+                       Left_Opnd => New_Copy_Tree (Hi),\n+                       Right_Opnd => New_Copy_Tree (Lo)),\n+                   Right_Opnd =>\n+                     Make_Integer_Literal (Loc, 1));\n+               return -1;\n+            end if;\n+\n+         elsif Nkind (Comp) = N_Iterated_Component_Association then\n+            return Build_Siz_Exp (First (Discrete_Choices (Comp)));\n+\n+         elsif Nkind (Comp) = N_Iterated_Element_Association then\n+            return -1;    --  TBD, build expression for size of the domain\n+\n+         else\n+            return -1;\n+         end if;\n+      end Build_Siz_Exp;\n+\n       -------------------------------\n       -- Expand_Iterated_Component --\n       -------------------------------\n@@ -7171,7 +7241,9 @@ package body Exp_Aggr is\n          --  parameter. Otherwise the key is given by the loop parameter\n          --  itself.\n \n-         if Present (Add_Unnamed_Subp) then\n+         if Present (Add_Unnamed_Subp)\n+           and then No (Add_Named_Subp)\n+         then\n             Stats := New_List\n               (Make_Procedure_Call_Statement (Loc,\n                  Name => New_Occurrence_Of (Entity (Add_Unnamed_Subp), Loc),\n@@ -7216,38 +7288,80 @@ package body Exp_Aggr is\n \n       --  The constructor for bounded containers is a function with\n       --  a parameter that sets the size of the container. If the\n-      --  size cannot be determined statically we use a default value.\n+      --  size cannot be determined statically we use a default value\n+      --  or a dynamic expression.\n \n       Siz := Aggregate_Size;\n-      if Siz < 0 then\n-         Siz := 10;\n-      end if;\n \n       if Ekind (Entity (Empty_Subp)) = E_Function\n         and then Present (First_Formal (Entity (Empty_Subp)))\n       then\n          Default := Default_Value (First_Formal (Entity (Empty_Subp)));\n-         --  If aggregate size is not static, use default value of\n-         --  formal parameter for allocation. We assume that this\n+\n+         --  If aggregate size is not static, we can use default value\n+         --  of formal parameter for allocation. We assume that this\n          --  (implementation-dependent) value is static, even though\n-         --   the AI does not require it ???.\n+         --   the AI does not require it.\n \n-         if Siz < 0 then\n-            Siz := UI_To_Int (Intval (Default));\n-         end if;\n+         --  Create declaration for size: a constant literal in the simple\n+         --  case, an expression if iterated component associations may be\n+         --  involved, the default otherwise.\n \n-         Init_Stat :=\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => Temp,\n-             Object_Definition   => New_Occurrence_Of (Typ, Loc),\n-             Expression => Make_Function_Call (Loc,\n-               Name => New_Occurrence_Of (Entity (Empty_Subp), Loc),\n-               Parameter_Associations =>\n-                 New_List (Make_Integer_Literal (Loc, Siz))));\n+         Count_Type := Etype (First_Formal (Entity (Empty_Subp)));\n+         if Siz = -1 then\n+            if No (Siz_Exp) then\n+               Siz := UI_To_Int (Intval (Default));\n+               Siz_Exp := Make_Integer_Literal (Loc, Siz);\n+\n+            else\n+               Siz_Exp := Make_Type_Conversion (Loc,\n+                  Subtype_Mark =>\n+                    New_Occurrence_Of (Count_Type, Loc),\n+                  Expression => Siz_Exp);\n+            end if;\n+\n+         else\n+            Siz_Exp := Make_Integer_Literal (Loc, Siz);\n+         end if;\n+\n+         Siz_Decl := Make_Object_Declaration (Loc,\n+            Defining_Identifier => Make_Temporary (Loc, 'S', N),\n+            Object_Definition =>\n+               New_Occurrence_Of (Count_Type, Loc),\n+               Expression => Siz_Exp);\n+         Append (Siz_Decl, Aggr_Code);\n+\n+         if Nkind (Siz_Exp) = N_Integer_Literal then\n+            Init_Stat :=\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Temp,\n+                Object_Definition   => New_Occurrence_Of (Typ, Loc),\n+                Expression => Make_Function_Call (Loc,\n+                  Name => New_Occurrence_Of (Entity (Empty_Subp), Loc),\n+                  Parameter_Associations =>\n+                    New_List\n+                      (New_Occurrence_Of\n+                        (Defining_Identifier (Siz_Decl), Loc))));\n+\n+         else\n+            Init_Stat :=\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Temp,\n+                Object_Definition   => New_Occurrence_Of (Typ, Loc),\n+                Expression => Make_Function_Call (Loc,\n+                  Name =>\n+                    New_Occurrence_Of (Entity (New_Indexed_Subp), Loc),\n+                  Parameter_Associations =>\n+                    New_List (\n+                      Make_Integer_Literal (Loc, 1),\n+                      New_Occurrence_Of\n+                        (Defining_Identifier (Siz_Decl), Loc))));\n+         end if;\n \n          Append (Init_Stat, Aggr_Code);\n \n-         --  Use default value when aggregate size is not static.\n+         --  Size is dynamic: Create declaration for object, and intitialize\n+         --  with a call to the null container, or an assignment to it.\n \n       else\n          Decl :=\n@@ -7256,11 +7370,16 @@ package body Exp_Aggr is\n              Object_Definition   => New_Occurrence_Of (Typ, Loc));\n \n          Insert_Action (N, Decl);\n+\n+         --  The Empty entity is either a parameterless function, or\n+         --  a constant.\n+\n          if Ekind (Entity (Empty_Subp)) = E_Function then\n             Init_Stat := Make_Assignment_Statement (Loc,\n               Name => New_Occurrence_Of (Temp, Loc),\n               Expression => Make_Function_Call (Loc,\n                 Name => New_Occurrence_Of (Entity (Empty_Subp), Loc)));\n+\n          else\n             Init_Stat := Make_Assignment_Statement (Loc,\n               Name => New_Occurrence_Of (Temp, Loc),\n@@ -7277,9 +7396,7 @@ package body Exp_Aggr is\n       --  If the aggregate is positional the aspect must include\n       --  an Add_Unnamed subprogram.\n \n-      if Present (Add_Unnamed_Subp)\n-        and then No (Component_Associations (N))\n-      then\n+      if Present (Add_Unnamed_Subp) then\n          if Present (Expressions (N)) then\n             declare\n                Insert : constant Entity_Id := Entity (Add_Unnamed_Subp);\n@@ -7300,13 +7417,18 @@ package body Exp_Aggr is\n             end;\n          end if;\n \n-         --  Iterated component associations may also be present.\n+         --  Indexed aggregates are handled below. Unnamed aggregates\n+         --  such as sets may include iterated component associations.\n \n-         Comp := First (Component_Associations (N));\n-         while Present (Comp) loop\n-            Expand_Iterated_Component (Comp);\n-            Next (Comp);\n-         end loop;\n+         if No (New_Indexed_Subp) then\n+            Comp := First (Component_Associations (N));\n+            while Present (Comp) loop\n+               if Nkind (Comp) = N_Iterated_Component_Association then\n+                  Expand_Iterated_Component (Comp);\n+               end if;\n+               Next (Comp);\n+            end loop;\n+         end if;\n \n       ---------------------\n       -- Named_Aggregate --\n@@ -7357,6 +7479,8 @@ package body Exp_Aggr is\n       --  subprogram. Note that unlike array aggregates, a container\n       --  aggregate must be fully positional or fully indexed. In the\n       --  first case the expansion has already taken place.\n+      --  TBA: the keys for an indexed aggregate must provide a dense\n+      --  range with no repetitions.\n \n       if Present (Assign_Indexed_Subp)\n         and then Present (Component_Associations (N))"}]}