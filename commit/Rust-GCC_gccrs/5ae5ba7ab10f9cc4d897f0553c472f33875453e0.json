{"sha": "5ae5ba7ab10f9cc4d897f0553c472f33875453e0", "node_id": "C_kwDOANBUbNoAKDVhZTViYTdhYjEwZjljYzRkODk3ZjA1NTNjNDcyZjMzODc1NDUzZTA", "commit": {"author": {"name": "Piotr Trojanek", "email": "trojanek@adacore.com", "date": "2021-11-22T16:58:06Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-12-02T16:26:24Z"}, "message": "[Ada] Separate building of equality from other dispatching routines\n\ngcc/ada/\n\n\t* exp_ch3.adb (Make_Predefined_Primitive_Specs): Move code for\n\tspec of dispatching equality.\n\t(Predefined_Primitive_Bodies): Move code for body if dispatching\n\tequality.\n\t(Make_Predefined_Primitive_Eq_Spec): Separated code for spec of\n\tdispatching equality.\n\t(Predefined_Primitive_Eq_Body): Separated code for body of\n\tdispatching equality.\n\t* exp_ch3.ads: Update.", "tree": {"sha": "1765f4a5192d7260987f9256decb9d846b4e4594", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1765f4a5192d7260987f9256decb9d846b4e4594"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ae5ba7ab10f9cc4d897f0553c472f33875453e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ae5ba7ab10f9cc4d897f0553c472f33875453e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ae5ba7ab10f9cc4d897f0553c472f33875453e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ae5ba7ab10f9cc4d897f0553c472f33875453e0/comments", "author": {"login": "ptroja", "id": 161602, "node_id": "MDQ6VXNlcjE2MTYwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/161602?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ptroja", "html_url": "https://github.com/ptroja", "followers_url": "https://api.github.com/users/ptroja/followers", "following_url": "https://api.github.com/users/ptroja/following{/other_user}", "gists_url": "https://api.github.com/users/ptroja/gists{/gist_id}", "starred_url": "https://api.github.com/users/ptroja/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ptroja/subscriptions", "organizations_url": "https://api.github.com/users/ptroja/orgs", "repos_url": "https://api.github.com/users/ptroja/repos", "events_url": "https://api.github.com/users/ptroja/events{/privacy}", "received_events_url": "https://api.github.com/users/ptroja/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a83c4eea27122fe2f90ff35d813ca34e8f542387", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a83c4eea27122fe2f90ff35d813ca34e8f542387", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a83c4eea27122fe2f90ff35d813ca34e8f542387"}], "stats": {"total": 390, "additions": 222, "deletions": 168}, "files": [{"sha": "c75e98e796b22769412ebce1d830dd2721f4a9aa", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 197, "deletions": 168, "changes": 365, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ae5ba7ab10f9cc4d897f0553c472f33875453e0/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ae5ba7ab10f9cc4d897f0553c472f33875453e0/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=5ae5ba7ab10f9cc4d897f0553c472f33875453e0", "patch": "@@ -287,13 +287,7 @@ package body Exp_Ch3 is\n    --  controlled components that require finalization actions (the deep\n    --  in the name refers to the fact that the action applies to components).\n    --\n-   --  The list is returned in Predef_List. The Parameter Renamed_Eq either\n-   --  returns the value Empty, or else the defining unit name for the\n-   --  predefined equality function in the case where the type has a primitive\n-   --  operation that is a renaming of predefined equality (but only if there\n-   --  is also an overriding user-defined equality function). The returned\n-   --  Renamed_Eq will be passed to the corresponding parameter of\n-   --  Predefined_Primitive_Bodies.\n+   --  The list of specs is returned in Predef_List\n \n    function Has_New_Non_Standard_Rep (T : Entity_Id) return Boolean;\n    --  Returns True if there are representation clauses for type T that are not\n@@ -10366,13 +10360,13 @@ package body Exp_Ch3 is\n       return Decl_List;\n    end Make_Null_Procedure_Specs;\n \n-   -------------------------------------\n-   -- Make_Predefined_Primitive_Specs --\n-   -------------------------------------\n+   ---------------------------------------\n+   -- Make_Predefined_Primitive_Eq_Spec --\n+   ---------------------------------------\n \n-   procedure Make_Predefined_Primitive_Specs\n+   procedure Make_Predefined_Primitive_Eq_Spec\n      (Tag_Typ     : Entity_Id;\n-      Predef_List : out List_Id;\n+      Predef_List : List_Id;\n       Renamed_Eq  : out Entity_Id)\n    is\n       function Is_Predefined_Eq_Renaming (Prim : Node_Id) return Boolean;\n@@ -10394,21 +10388,152 @@ package body Exp_Ch3 is\n \n       --  Local variables\n \n-      Loc       : constant Source_Ptr := Sloc (Tag_Typ);\n-      Res       : constant List_Id    := New_List;\n-      Eq_Name   : Name_Id             := Name_Op_Eq;\n-      Eq_Needed : Boolean;\n+      Loc : constant Source_Ptr := Sloc (Tag_Typ);\n+\n+      Eq_Name   : Name_Id := Name_Op_Eq;\n+      Eq_Needed : Boolean := True;\n       Eq_Spec   : Node_Id;\n       Prim      : Elmt_Id;\n \n       Has_Predef_Eq_Renaming : Boolean := False;\n       --  Set to True if Tag_Typ has a primitive that renames the predefined\n       --  equality operator. Used to implement (RM 8-5-4(8)).\n \n-      use Exp_Put_Image;\n-\n    --  Start of processing for Make_Predefined_Primitive_Specs\n \n+   begin\n+      Renamed_Eq := Empty;\n+\n+      Prim := First_Elmt (Primitive_Operations (Tag_Typ));\n+      while Present (Prim) loop\n+\n+         --  If a primitive is encountered that renames the predefined equality\n+         --  operator before reaching any explicit equality primitive, then we\n+         --  still need to create a predefined equality function, because calls\n+         --  to it can occur via the renaming. A new name is created for the\n+         --  equality to avoid conflicting with any user-defined equality.\n+         --  (Note that this doesn't account for renamings of equality nested\n+         --  within subpackages???)\n+\n+         if Is_Predefined_Eq_Renaming (Node (Prim)) then\n+            Has_Predef_Eq_Renaming := True;\n+            Eq_Name := New_External_Name (Chars (Node (Prim)), 'E');\n+\n+         --  User-defined equality\n+\n+         elsif Is_User_Defined_Equality (Node (Prim)) then\n+            if No (Alias (Node (Prim)))\n+              or else Nkind (Unit_Declaration_Node (Node (Prim))) =\n+                        N_Subprogram_Renaming_Declaration\n+            then\n+               Eq_Needed := False;\n+               exit;\n+\n+            --  If the parent is not an interface type and has an abstract\n+            --  equality function explicitly defined in the sources, then the\n+            --  inherited equality is abstract as well, and no body can be\n+            --  created for it.\n+\n+            elsif not Is_Interface (Etype (Tag_Typ))\n+              and then Present (Alias (Node (Prim)))\n+              and then Comes_From_Source (Alias (Node (Prim)))\n+              and then Is_Abstract_Subprogram (Alias (Node (Prim)))\n+            then\n+               Eq_Needed := False;\n+               exit;\n+\n+            --  If the type has an equality function corresponding with a\n+            --  primitive defined in an interface type, the inherited equality\n+            --  is abstract as well, and no body can be created for it.\n+\n+            elsif Present (Alias (Node (Prim)))\n+              and then Comes_From_Source (Ultimate_Alias (Node (Prim)))\n+              and then\n+                Is_Interface\n+                  (Find_Dispatching_Type (Ultimate_Alias (Node (Prim))))\n+            then\n+               Eq_Needed := False;\n+               exit;\n+            end if;\n+         end if;\n+\n+         Next_Elmt (Prim);\n+      end loop;\n+\n+      --  If a renaming of predefined equality was found but there was no\n+      --  user-defined equality (so Eq_Needed is still true), then set the name\n+      --  back to Name_Op_Eq. But in the case where a user-defined equality was\n+      --  located after such a renaming, then the predefined equality function\n+      --  is still needed, so Eq_Needed must be set back to True.\n+\n+      if Eq_Name /= Name_Op_Eq then\n+         if Eq_Needed then\n+            Eq_Name := Name_Op_Eq;\n+         else\n+            Eq_Needed := True;\n+         end if;\n+      end if;\n+\n+      if Eq_Needed then\n+         Eq_Spec := Predef_Spec_Or_Body (Loc,\n+           Tag_Typ => Tag_Typ,\n+           Name    => Eq_Name,\n+           Profile => New_List (\n+             Make_Parameter_Specification (Loc,\n+               Defining_Identifier =>\n+                 Make_Defining_Identifier (Loc, Name_X),\n+               Parameter_Type      => New_Occurrence_Of (Tag_Typ, Loc)),\n+\n+             Make_Parameter_Specification (Loc,\n+               Defining_Identifier =>\n+                 Make_Defining_Identifier (Loc, Name_Y),\n+               Parameter_Type      => New_Occurrence_Of (Tag_Typ, Loc))),\n+             Ret_Type => Standard_Boolean);\n+         Append_To (Predef_List, Eq_Spec);\n+\n+         if Has_Predef_Eq_Renaming then\n+            Renamed_Eq := Defining_Unit_Name (Specification (Eq_Spec));\n+\n+            Prim := First_Elmt (Primitive_Operations (Tag_Typ));\n+            while Present (Prim) loop\n+\n+               --  Any renamings of equality that appeared before an overriding\n+               --  equality must be updated to refer to the entity for the\n+               --  predefined equality, otherwise calls via the renaming would\n+               --  get incorrectly resolved to call the user-defined equality\n+               --  function.\n+\n+               if Is_Predefined_Eq_Renaming (Node (Prim)) then\n+                  Set_Alias (Node (Prim), Renamed_Eq);\n+\n+               --  Exit upon encountering a user-defined equality\n+\n+               elsif Chars (Node (Prim)) = Name_Op_Eq\n+                 and then No (Alias (Node (Prim)))\n+               then\n+                  exit;\n+               end if;\n+\n+               Next_Elmt (Prim);\n+            end loop;\n+         end if;\n+      end if;\n+   end Make_Predefined_Primitive_Eq_Spec;\n+\n+   -------------------------------------\n+   -- Make_Predefined_Primitive_Specs --\n+   -------------------------------------\n+\n+   procedure Make_Predefined_Primitive_Specs\n+     (Tag_Typ     : Entity_Id;\n+      Predef_List : out List_Id;\n+      Renamed_Eq  : out Entity_Id)\n+   is\n+      Loc : constant Source_Ptr := Sloc (Tag_Typ);\n+      Res : constant List_Id    := New_List;\n+\n+      use Exp_Put_Image;\n+\n    begin\n       Renamed_Eq := Empty;\n \n@@ -10462,126 +10587,10 @@ package body Exp_Ch3 is\n \n       --  Spec of \"=\" is expanded if the type is not limited and if a user\n       --  defined \"=\" was not already declared for the non-full view of a\n-      --  private extension\n+      --  private extension.\n \n       if not Is_Limited_Type (Tag_Typ) then\n-         Eq_Needed := True;\n-         Prim := First_Elmt (Primitive_Operations (Tag_Typ));\n-         while Present (Prim) loop\n-\n-            --  If a primitive is encountered that renames the predefined\n-            --  equality operator before reaching any explicit equality\n-            --  primitive, then we still need to create a predefined equality\n-            --  function, because calls to it can occur via the renaming. A\n-            --  new name is created for the equality to avoid conflicting with\n-            --  any user-defined equality. (Note that this doesn't account for\n-            --  renamings of equality nested within subpackages???)\n-\n-            if Is_Predefined_Eq_Renaming (Node (Prim)) then\n-               Has_Predef_Eq_Renaming := True;\n-               Eq_Name := New_External_Name (Chars (Node (Prim)), 'E');\n-\n-            --  User-defined equality\n-\n-            elsif Is_User_Defined_Equality (Node (Prim)) then\n-               if No (Alias (Node (Prim)))\n-                 or else Nkind (Unit_Declaration_Node (Node (Prim))) =\n-                           N_Subprogram_Renaming_Declaration\n-               then\n-                  Eq_Needed := False;\n-                  exit;\n-\n-               --  If the parent is not an interface type and has an abstract\n-               --  equality function explicitly defined in the sources, then\n-               --  the inherited equality is abstract as well, and no body can\n-               --  be created for it.\n-\n-               elsif not Is_Interface (Etype (Tag_Typ))\n-                 and then Present (Alias (Node (Prim)))\n-                 and then Comes_From_Source (Alias (Node (Prim)))\n-                 and then Is_Abstract_Subprogram (Alias (Node (Prim)))\n-               then\n-                  Eq_Needed := False;\n-                  exit;\n-\n-               --  If the type has an equality function corresponding with\n-               --  a primitive defined in an interface type, the inherited\n-               --  equality is abstract as well, and no body can be created\n-               --  for it.\n-\n-               elsif Present (Alias (Node (Prim)))\n-                 and then Comes_From_Source (Ultimate_Alias (Node (Prim)))\n-                 and then\n-                   Is_Interface\n-                     (Find_Dispatching_Type (Ultimate_Alias (Node (Prim))))\n-               then\n-                  Eq_Needed := False;\n-                  exit;\n-               end if;\n-            end if;\n-\n-            Next_Elmt (Prim);\n-         end loop;\n-\n-         --  If a renaming of predefined equality was found but there was no\n-         --  user-defined equality (so Eq_Needed is still true), then set the\n-         --  name back to Name_Op_Eq. But in the case where a user-defined\n-         --  equality was located after such a renaming, then the predefined\n-         --  equality function is still needed, so Eq_Needed must be set back\n-         --  to True.\n-\n-         if Eq_Name /= Name_Op_Eq then\n-            if Eq_Needed then\n-               Eq_Name := Name_Op_Eq;\n-            else\n-               Eq_Needed := True;\n-            end if;\n-         end if;\n-\n-         if Eq_Needed then\n-            Eq_Spec := Predef_Spec_Or_Body (Loc,\n-              Tag_Typ => Tag_Typ,\n-              Name    => Eq_Name,\n-              Profile => New_List (\n-                Make_Parameter_Specification (Loc,\n-                  Defining_Identifier =>\n-                    Make_Defining_Identifier (Loc, Name_X),\n-                  Parameter_Type      => New_Occurrence_Of (Tag_Typ, Loc)),\n-\n-                Make_Parameter_Specification (Loc,\n-                  Defining_Identifier =>\n-                    Make_Defining_Identifier (Loc, Name_Y),\n-                  Parameter_Type      => New_Occurrence_Of (Tag_Typ, Loc))),\n-                Ret_Type => Standard_Boolean);\n-            Append_To (Res, Eq_Spec);\n-\n-            if Has_Predef_Eq_Renaming then\n-               Renamed_Eq := Defining_Unit_Name (Specification (Eq_Spec));\n-\n-               Prim := First_Elmt (Primitive_Operations (Tag_Typ));\n-               while Present (Prim) loop\n-\n-                  --  Any renamings of equality that appeared before an\n-                  --  overriding equality must be updated to refer to the\n-                  --  entity for the predefined equality, otherwise calls via\n-                  --  the renaming would get incorrectly resolved to call the\n-                  --  user-defined equality function.\n-\n-                  if Is_Predefined_Eq_Renaming (Node (Prim)) then\n-                     Set_Alias (Node (Prim), Renamed_Eq);\n-\n-                  --  Exit upon encountering a user-defined equality\n-\n-                  elsif Chars (Node (Prim)) = Name_Op_Eq\n-                    and then No (Alias (Node (Prim)))\n-                  then\n-                     exit;\n-                  end if;\n-\n-                  Next_Elmt (Prim);\n-               end loop;\n-            end if;\n-         end if;\n+         Make_Predefined_Primitive_Eq_Spec (Tag_Typ, Res, Renamed_Eq);\n \n          --  Spec for dispatching assignment\n \n@@ -10926,31 +10935,21 @@ package body Exp_Ch3 is\n            For_Body => False);\n    end Predef_Stream_Attr_Spec;\n \n-   ---------------------------------\n-   -- Predefined_Primitive_Bodies --\n-   ---------------------------------\n+   ----------------------------------\n+   -- Predefined_Primitive_Eq_Body --\n+   ----------------------------------\n \n-   function Predefined_Primitive_Bodies\n-     (Tag_Typ    : Entity_Id;\n-      Renamed_Eq : Entity_Id) return List_Id\n+   procedure Predefined_Primitive_Eq_Body\n+     (Tag_Typ     : Entity_Id;\n+      Predef_List : List_Id;\n+      Renamed_Eq  : Entity_Id)\n    is\n-      Loc       : constant Source_Ptr := Sloc (Tag_Typ);\n-      Res       : constant List_Id    := New_List;\n-      Adj_Call  : Node_Id;\n       Decl      : Node_Id;\n-      Fin_Call  : Node_Id;\n-      Prim      : Elmt_Id;\n       Eq_Needed : Boolean;\n       Eq_Name   : Name_Id;\n-      Ent       : Entity_Id;\n-\n-      pragma Warnings (Off, Ent);\n-\n-      use Exp_Put_Image;\n+      Prim      : Elmt_Id;\n \n    begin\n-      pragma Assert (not Is_Interface (Tag_Typ));\n-\n       --  See if we have a predefined \"=\" operator\n \n       if Present (Renamed_Eq) then\n@@ -11004,6 +11003,48 @@ package body Exp_Ch3 is\n          end loop;\n       end if;\n \n+      --  If equality is needed, we will have its name\n+\n+      pragma Assert (Eq_Needed = Present (Eq_Name));\n+\n+      --  Body for equality\n+\n+      if Eq_Needed then\n+         Decl := Make_Eq_Body (Tag_Typ, Eq_Name);\n+         Append_To (Predef_List, Decl);\n+      end if;\n+\n+      --  Body for inequality (if required)\n+\n+      Decl := Make_Neq_Body (Tag_Typ);\n+\n+      if Present (Decl) then\n+         Append_To (Predef_List, Decl);\n+      end if;\n+   end Predefined_Primitive_Eq_Body;\n+\n+   ---------------------------------\n+   -- Predefined_Primitive_Bodies --\n+   ---------------------------------\n+\n+   function Predefined_Primitive_Bodies\n+     (Tag_Typ    : Entity_Id;\n+      Renamed_Eq : Entity_Id) return List_Id\n+   is\n+      Loc      : constant Source_Ptr := Sloc (Tag_Typ);\n+      Res      : constant List_Id    := New_List;\n+      Adj_Call : Node_Id;\n+      Decl     : Node_Id;\n+      Fin_Call : Node_Id;\n+      Ent      : Entity_Id;\n+\n+      pragma Warnings (Off, Ent);\n+\n+      use Exp_Put_Image;\n+\n+   begin\n+      pragma Assert (not Is_Interface (Tag_Typ));\n+\n       --  Body of _Size\n \n       Decl := Predef_Spec_Or_Body (Loc,\n@@ -11118,21 +11159,9 @@ package body Exp_Ch3 is\n       end if;\n \n       if not Is_Limited_Type (Tag_Typ) then\n+         --  Body for equality and inequality\n \n-         --  Body for equality\n-\n-         if Eq_Needed then\n-            Decl := Make_Eq_Body (Tag_Typ, Eq_Name);\n-            Append_To (Res, Decl);\n-         end if;\n-\n-         --  Body for inequality (if required)\n-\n-         Decl := Make_Neq_Body (Tag_Typ);\n-\n-         if Present (Decl) then\n-            Append_To (Res, Decl);\n-         end if;\n+         Predefined_Primitive_Eq_Body (Tag_Typ, Res, Renamed_Eq);\n \n          --  Body for dispatching assignment\n "}, {"sha": "61595eba8bd215ff294605fba46544a2fa98ad80", "filename": "gcc/ada/exp_ch3.ads", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ae5ba7ab10f9cc4d897f0553c472f33875453e0/gcc%2Fada%2Fexp_ch3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ae5ba7ab10f9cc4d897f0553c472f33875453e0/gcc%2Fada%2Fexp_ch3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.ads?ref=5ae5ba7ab10f9cc4d897f0553c472f33875453e0", "patch": "@@ -155,6 +155,20 @@ package Exp_Ch3 is\n    --  initialized; if Variable_Comps is True then tags components located at\n    --  variable positions of Target are initialized.\n \n+   procedure Make_Predefined_Primitive_Eq_Spec\n+     (Tag_Typ     : Entity_Id;\n+      Predef_List : List_Id;\n+      Renamed_Eq  : out Entity_Id);\n+   --  Creates spec for the predefined equality on a tagged type Tag_Typ, if\n+   --  required. If created, it will be appended to Predef_List.\n+   --\n+   --  The Parameter Renamed_Eq either returns the value Empty, or else\n+   --  the defining unit name for the predefined equality function in the\n+   --  case where the type has a primitive operation that is a renaming\n+   --  of predefined equality (but only if there is also an overriding\n+   --  user-defined equality function). The returned Renamed_Eq will be\n+   --  passed to the corresponding parameter of Predefined_Primitive_Bodies.\n+\n    function Make_Tag_Assignment (N : Node_Id) return Node_Id;\n    --  An object declaration that has an initialization for a tagged object\n    --  requires a separate reassignment of the tag of the given type, because\n@@ -163,4 +177,15 @@ package Exp_Ch3 is\n    --  clause the assignment is handled as part of the freezing of the object,\n    --  see Check_Address_Clause.\n \n+   procedure Predefined_Primitive_Eq_Body\n+     (Tag_Typ     : Entity_Id;\n+      Predef_List : List_Id;\n+      Renamed_Eq  : Entity_Id);\n+   --  Creates body for the predefined equality (and ineqality, if required) on\n+   --  a tagged type Tag_Typ. If created they will be appended to Predef_List.\n+   --\n+   --  The spec for the equality function has been created by\n+   --  Make_Predefined_Primitive_Eq_Spec; see there for description of\n+   --  the Renamed_Eq parameter.\n+\n end Exp_Ch3;"}]}