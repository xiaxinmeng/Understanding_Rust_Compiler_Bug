{"sha": "a1b8572cac7c96128e10c2e93f8c7ef71d3d6d5d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTFiODU3MmNhYzdjOTYxMjhlMTBjMmU5M2Y4YzdlZjcxZDNkNmQ1ZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-01-14T09:14:03Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-01-14T09:14:03Z"}, "message": "i386.c (ix86_expand_compare): Add bypass_test and second_test parameters.\n\n\n\t* i386.c (ix86_expand_compare): Add bypass_test and second_test\n\tparameters.\n\t(ix86_expand_branch): Update.\n\t(ix86_expand_setcc): Update to handle multiple test conditions.\n\t(expand_int_movcc): Likewise.\n\t(expand_fp_movcc): Likewise.\n\t* i386-protos.h (ix86_expand_compare): New.\n\t* i386.md (andqi_?_slp, orqi_?_slp): New.\n\t(conditional trap expander): Update call to ix86_expand_compare.\n\nFrom-SVN: r39005", "tree": {"sha": "ef4ee7257a074a8c3351697865670bbd0a49b8bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef4ee7257a074a8c3351697865670bbd0a49b8bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1b8572cac7c96128e10c2e93f8c7ef71d3d6d5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1b8572cac7c96128e10c2e93f8c7ef71d3d6d5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1b8572cac7c96128e10c2e93f8c7ef71d3d6d5d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1b8572cac7c96128e10c2e93f8c7ef71d3d6d5d/comments", "author": null, "committer": null, "parents": [{"sha": "264ddbaa683da65a254b012d178149830339d502", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/264ddbaa683da65a254b012d178149830339d502", "html_url": "https://github.com/Rust-GCC/gccrs/commit/264ddbaa683da65a254b012d178149830339d502"}], "stats": {"total": 168, "additions": 155, "deletions": 13}, "files": [{"sha": "7d82db9d3ba63e4e8844ddc55a48d151cb608627", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1b8572cac7c96128e10c2e93f8c7ef71d3d6d5d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1b8572cac7c96128e10c2e93f8c7ef71d3d6d5d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a1b8572cac7c96128e10c2e93f8c7ef71d3d6d5d", "patch": "@@ -1,3 +1,15 @@\n+Sun Jan 14 10:09:48 MET 2001  Jan hubicka  <jh@suse.cz>\n+\n+\t* i386.c (ix86_expand_compare): Add bypass_test and second_test\n+\tparameters.\n+\t(ix86_expand_branch): Update.\n+\t(ix86_expand_setcc): Update to handle multiple test conditions.\n+\t(expand_int_movcc): Likewise.\n+\t(expand_fp_movcc): Likewise.\n+\t* i386-protos.h (ix86_expand_compare): New.\n+\t* i386.md (andqi_?_slp, orqi_?_slp): New.\n+\t(conditional trap expander): Update call to ix86_expand_compare.\n+\n 2001-01-14  Richard Henderson  <rth@redhat.com>\n \n \t* config/vax/vax.md: Use nonimmediate_operand instead of"}, {"sha": "cd44c4b3cbda93cb0108886a9f260819e85d0ef8", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1b8572cac7c96128e10c2e93f8c7ef71d3d6d5d/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1b8572cac7c96128e10c2e93f8c7ef71d3d6d5d/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=a1b8572cac7c96128e10c2e93f8c7ef71d3d6d5d", "patch": "@@ -101,7 +101,7 @@ extern void ix86_expand_unary_operator PARAMS ((enum rtx_code, enum machine_mode\n extern int ix86_unary_operator_ok PARAMS ((enum rtx_code, enum machine_mode,\n \t\t\t\t\t rtx[]));\n extern int ix86_match_ccmode PARAMS ((rtx, enum machine_mode));\n-extern rtx ix86_expand_compare PARAMS ((enum rtx_code));\n+extern rtx ix86_expand_compare PARAMS ((enum rtx_code, rtx *, rtx *));\n extern int ix86_use_fcomi_compare PARAMS ((enum rtx_code));\n extern void ix86_expand_branch PARAMS ((enum rtx_code, rtx));\n extern int ix86_expand_setcc PARAMS ((enum rtx_code, rtx));"}, {"sha": "65084780f8128b706cf96a1b103e9ff4f2d39f45", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 95, "deletions": 11, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1b8572cac7c96128e10c2e93f8c7ef71d3d6d5d/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1b8572cac7c96128e10c2e93f8c7ef71d3d6d5d/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=a1b8572cac7c96128e10c2e93f8c7ef71d3d6d5d", "patch": "@@ -5161,16 +5161,22 @@ ix86_expand_fp_compare (code, op0, op1, scratch, second_test, bypass_test)\n }\n \n rtx\n-ix86_expand_compare (code)\n+ix86_expand_compare (code, second_test, bypass_test)\n      enum rtx_code code;\n+     rtx *second_test, *bypass_test;\n {\n   rtx op0, op1, ret;\n   op0 = ix86_compare_op0;\n   op1 = ix86_compare_op1;\n \n+  if (second_test)\n+    *second_test = NULL_RTX;\n+  if (bypass_test)\n+    *bypass_test = NULL_RTX;\n+\n   if (GET_MODE_CLASS (GET_MODE (op0)) == MODE_FLOAT)\n     ret = ix86_expand_fp_compare (code, op0, op1, gen_reg_rtx (HImode),\n-\t\t    \t\t  NULL, NULL);\n+\t\t    \t\t  second_test, bypass_test);\n   else\n     ret = ix86_expand_int_compare (code, op0, op1);\n \n@@ -5189,7 +5195,7 @@ ix86_expand_branch (code, label)\n     case QImode:\n     case HImode:\n     case SImode:\n-      tmp = ix86_expand_compare (code);\n+      tmp = ix86_expand_compare (code, NULL, NULL);\n       tmp = gen_rtx_IF_THEN_ELSE (VOIDmode, tmp,\n \t\t\t\t  gen_rtx_LABEL_REF (VOIDmode, label),\n \t\t\t\t  pc_rtx);\n@@ -5404,7 +5410,8 @@ ix86_expand_setcc (code, dest)\n      enum rtx_code code;\n      rtx dest;\n {\n-  rtx ret, tmp;\n+  rtx ret, tmp, tmpreg;\n+  rtx second_test, bypass_test;\n   int type;\n \n   if (GET_MODE (ix86_compare_op0) == DImode)\n@@ -5430,13 +5437,15 @@ ix86_expand_setcc (code, dest)\n   if (type == 0)\n     emit_move_insn (dest, const0_rtx);\n \n-  ret = ix86_expand_compare (code);\n+  ret = ix86_expand_compare (code, &second_test, &bypass_test);\n   PUT_MODE (ret, QImode);\n \n   tmp = dest;\n+  tmpreg = dest;\n   if (type == 0)\n     {\n       tmp = gen_lowpart (QImode, dest);\n+      tmpreg = tmp;\n       tmp = gen_rtx_STRICT_LOW_PART (VOIDmode, tmp);\n     }\n   else if (type == 1)\n@@ -5445,9 +5454,31 @@ ix86_expand_setcc (code, dest)\n \ttmp = gen_reg_rtx (QImode);\n       else\n         tmp = gen_lowpart (QImode, dest);\n+      tmpreg = tmp;\n     }\n \n   emit_insn (gen_rtx_SET (VOIDmode, tmp, ret));\n+  if (bypass_test || second_test)\n+    {\n+      rtx test = second_test;\n+      int bypass = 0;\n+      rtx tmp2 = gen_reg_rtx (QImode);\n+      if (bypass_test)\n+\t{\n+\t  if (second_test)\n+\t    abort();\n+\t  test = bypass_test;\n+\t  bypass = 1;\n+\t  PUT_CODE (test, reverse_condition_maybe_unordered (GET_CODE (test)));\n+\t}\n+      PUT_MODE (test, QImode);\n+      emit_insn (gen_rtx_SET (VOIDmode, tmp2, test));\n+\n+      if (bypass)\n+\temit_insn (gen_andqi3 (tmp, tmpreg, tmp2));\n+      else\n+\temit_insn (gen_iorqi3 (tmp, tmpreg, tmp2));\n+    }\n \n   if (type == 1)\n     {\n@@ -5469,6 +5500,7 @@ ix86_expand_int_movcc (operands)\n {\n   enum rtx_code code = GET_CODE (operands[1]), compare_code;\n   rtx compare_seq, compare_op;\n+  rtx second_test, bypass_test;\n \n   /* When the compare code is not LTU or GEU, we can not use sbbl case.\n      In case comparsion is done with immediate, we can convert it to LTU or\n@@ -5489,7 +5521,7 @@ ix86_expand_int_movcc (operands)\n     }\n \n   start_sequence ();\n-  compare_op = ix86_expand_compare (code);\n+  compare_op = ix86_expand_compare (code, &second_test, &bypass_test);\n   compare_seq = gen_sequence ();\n   end_sequence ();\n \n@@ -5507,7 +5539,8 @@ ix86_expand_int_movcc (operands)\n       HOST_WIDE_INT cf = INTVAL (operands[3]);\n       HOST_WIDE_INT diff;\n \n-      if (compare_code == LTU || compare_code == GEU)\n+      if ((compare_code == LTU || compare_code == GEU)\n+\t  && !second_test && !bypass_test)\n \t{\n \n \t  /* Detect overlap between destination and compare sources.  */\n@@ -5796,11 +5829,36 @@ ix86_expand_int_movcc (operands)\n   if (! nonimmediate_operand (operands[3], GET_MODE (operands[0])))\n     operands[3] = force_reg (GET_MODE (operands[0]), operands[3]);\n \n+  if (bypass_test && reg_overlap_mentioned_p (operands[0], operands[3]))\n+    {\n+      rtx tmp = gen_reg_rtx (GET_MODE (operands[0]));\n+      emit_move_insn (tmp, operands[3]);\n+      operands[3] = tmp;\n+    }\n+  if (second_test && reg_overlap_mentioned_p (operands[0], operands[2]))\n+    {\n+      rtx tmp = gen_reg_rtx (GET_MODE (operands[0]));\n+      emit_move_insn (tmp, operands[2]);\n+      operands[2] = tmp;\n+    }\n+\n   emit_insn (compare_seq);\n   emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n \t\t\t  gen_rtx_IF_THEN_ELSE (GET_MODE (operands[0]),\n \t\t\t\t\t\tcompare_op, operands[2],\n \t\t\t\t\t\toperands[3])));\n+  if (bypass_test)\n+    emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n+\t\t\t    gen_rtx_IF_THEN_ELSE (GET_MODE (operands[0]),\n+\t\t\t\t  bypass_test,\n+\t\t\t\t  operands[3],\n+\t\t\t\t  operands[0])));\n+  if (second_test)\n+    emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n+\t\t\t    gen_rtx_IF_THEN_ELSE (GET_MODE (operands[0]),\n+\t\t\t\t  second_test,\n+\t\t\t\t  operands[2],\n+\t\t\t\t  operands[0])));\n \n   return 1; /* DONE */\n }\n@@ -5811,32 +5869,58 @@ ix86_expand_fp_movcc (operands)\n {\n   enum rtx_code code;\n   rtx tmp;\n-  rtx compare_op;\n+  rtx compare_op, second_test, bypass_test;\n \n   /* The floating point conditional move instructions don't directly\n      support conditions resulting from a signed integer comparison.  */\n \n   code = GET_CODE (operands[1]);\n-  compare_op = ix86_expand_compare (code);\n+  compare_op = ix86_expand_compare (code, &second_test, &bypass_test);\n \n   /* The floating point conditional move instructions don't directly\n      support signed integer comparisons.  */\n \n-  if (!fcmov_comparison_operator (compare_op, GET_MODE (XEXP (compare_op, 0))))\n+  if (!fcmov_comparison_operator (compare_op, VOIDmode))\n     {\n+      if (second_test != NULL || bypass_test != NULL)\n+\tabort();\n       tmp = gen_reg_rtx (QImode);\n       ix86_expand_setcc (code, tmp);\n       code = NE;\n       ix86_compare_op0 = tmp;\n       ix86_compare_op1 = const0_rtx;\n-      compare_op = ix86_expand_compare (code);\n+      compare_op = ix86_expand_compare (code,  &second_test, &bypass_test);\n+    }\n+  if (bypass_test && reg_overlap_mentioned_p (operands[0], operands[3]))\n+    {\n+      tmp = gen_reg_rtx (GET_MODE (operands[0]));\n+      emit_move_insn (tmp, operands[3]);\n+      operands[3] = tmp;\n+    }\n+  if (second_test && reg_overlap_mentioned_p (operands[0], operands[2]))\n+    {\n+      tmp = gen_reg_rtx (GET_MODE (operands[0]));\n+      emit_move_insn (tmp, operands[2]);\n+      operands[2] = tmp;\n     }\n \n   emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n \t\t\t  gen_rtx_IF_THEN_ELSE (GET_MODE (operands[0]),\n \t\t\t\tcompare_op,\n \t\t\t\toperands[2],\n \t\t\t\toperands[3])));\n+  if (bypass_test)\n+    emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n+\t\t\t    gen_rtx_IF_THEN_ELSE (GET_MODE (operands[0]),\n+\t\t\t\t  bypass_test,\n+\t\t\t\t  operands[3],\n+\t\t\t\t  operands[0])));\n+  if (second_test)\n+    emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n+\t\t\t    gen_rtx_IF_THEN_ELSE (GET_MODE (operands[0]),\n+\t\t\t\t  second_test,\n+\t\t\t\t  operands[2],\n+\t\t\t\t  operands[0])));\n \n   return 1;\n }"}, {"sha": "5e53f14895c85ada431d9ae5f05564ebda0de280", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 47, "deletions": 1, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1b8572cac7c96128e10c2e93f8c7ef71d3d6d5d/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1b8572cac7c96128e10c2e93f8c7ef71d3d6d5d/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=a1b8572cac7c96128e10c2e93f8c7ef71d3d6d5d", "patch": "@@ -6263,6 +6263,16 @@\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"QI,QI,SI\")])\n \n+(define_insn \"*andqi_1_slp\"\n+  [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+qm,q\"))\n+\t(and:QI (match_dup 0)\n+\t\t(match_operand:QI 1 \"general_operand\" \"qi,qmi\")))\n+   (clobber (reg:CC 17))]\n+  \"\"\n+  \"and{b}\\\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"alu1\")\n+   (set_attr \"mode\" \"QI\")])\n+\n (define_insn \"*andqi_2\"\n   [(set (reg 17)\n \t(compare (and:QI\n@@ -6280,6 +6290,19 @@\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"QI,QI,SI\")])\n \n+(define_insn \"*andqi_2_slp\"\n+  [(set (reg 17)\n+\t(compare (and:QI\n+\t\t   (match_operand:QI 0 \"nonimmediate_operand\" \"+q,qm\")\n+\t\t   (match_operand:QI 1 \"nonimmediate_operand\" \"qmi,qi\"))\n+\t\t (const_int 0)))\n+   (set (strict_low_part (match_dup 0))\n+\t(and:QI (match_dup 0) (match_dup 1)))]\n+  \"ix86_match_ccmode (insn, CCNOmode)\"\n+  \"and{b}\\\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"alu1\")\n+   (set_attr \"mode\" \"QI\")])\n+\n ;; ??? A bug in recog prevents it from recognizing a const_int as an\n ;; operand to zero_extend in andqi_ext_1.  It was checking explicitly\n ;; for a QImode operand, which of course failed.\n@@ -6479,6 +6502,16 @@\n    or{b}\\\\t{%2, %0|%0, %2}\n    or{l}\\\\t{%k2, %k0|%k0, %k2}\"\n   [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"QI,QI,SI\")])\n+\n+(define_insn \"*iorqi_1_slp\"\n+  [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+q,m\"))\n+\t(ior:QI (match_dup 0)\n+\t\t(match_operand:QI 1 \"general_operand\" \"qmi,qi\")))\n+   (clobber (reg:CC 17))]\n+  \"\"\n+  \"or{b}\\\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"alu1\")\n    (set_attr \"mode\" \"QI\")])\n \n (define_insn \"*iorqi_2\"\n@@ -6494,6 +6527,18 @@\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"QI\")])\n \n+(define_insn \"*iorqi_2_slp\"\n+  [(set (reg 17)\n+\t(compare (ior:QI (match_operand:QI 0 \"nonimmediate_operand\" \"+q,qm\")\n+\t\t\t (match_operand:QI 1 \"general_operand\" \"qim,qi\"))\n+\t\t (const_int 0)))\n+   (set (strict_low_part (match_dup 0))\n+\t(ior:QI (match_dup 0) (match_dup 1)))]\n+  \"ix86_match_ccmode (insn, CCNOmode)\"\n+  \"or{b}\\\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"alu1\")\n+   (set_attr \"mode\" \"QI\")])\n+\n (define_insn \"*iorqi_3\"\n   [(set (reg 17)\n \t(compare (ior:QI (match_operand:QI 1 \"nonimmediate_operand\" \"%0\")\n@@ -12496,7 +12541,8 @@\n   \"\n {\n   emit_insn (gen_rtx_TRAP_IF (VOIDmode,\n-\t\t\t      ix86_expand_compare (GET_CODE (operands[0])),\n+\t\t\t      ix86_expand_compare (GET_CODE (operands[0]),\n+\t\t\t\t\t\t   NULL_RTX, NULL_RTX),\n \t\t\t      operands[1]));\n   DONE;\n }\")"}]}