{"sha": "fef939d6a96bde0f924152e6b9e22701c28f8880", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmVmOTM5ZDZhOTZiZGUwZjkyNDE1MmU2YjllMjI3MDFjMjhmODg4MA==", "commit": {"author": {"name": "James Bowman", "email": "james.bowman@ftdichip.com", "date": "2015-05-16T23:49:08Z"}, "committer": {"name": "James Bowman", "email": "jamesbowman@gcc.gnu.org", "date": "2015-05-16T23:49:08Z"}, "message": "FT32 target added. Approved by Jeff Law [law@redhat.com]\n\nFrom-SVN: r223261", "tree": {"sha": "5e4897f8e04c41bd78ca2cb6244476efaf07df39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e4897f8e04c41bd78ca2cb6244476efaf07df39"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fef939d6a96bde0f924152e6b9e22701c28f8880", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fef939d6a96bde0f924152e6b9e22701c28f8880", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fef939d6a96bde0f924152e6b9e22701c28f8880", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fef939d6a96bde0f924152e6b9e22701c28f8880/comments", "author": null, "committer": null, "parents": [{"sha": "9261aa4364af939b3fd91f20bf20c8e329434600", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9261aa4364af939b3fd91f20bf20c8e329434600", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9261aa4364af939b3fd91f20bf20c8e329434600"}], "stats": {"total": 4258, "additions": 4257, "deletions": 1}, "files": [{"sha": "d742bf253d04115bcd48795da7d4fcebe04f5f00", "filename": "ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef939d6a96bde0f924152e6b9e22701c28f8880/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef939d6a96bde0f924152e6b9e22701c28f8880/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=fef939d6a96bde0f924152e6b9e22701c28f8880", "patch": "@@ -1,3 +1,14 @@\n+2015-05-16  James Bowman  <james.bowman@ftdichip.com>\n+\n+\t* configure.ac: FT32 target added.\n+\t* libgcc/config.host: FT32 target added.\n+\t* gcc/config/ft32/: FT32 target added.\n+\t* libgcc/config/ft32/: FT32 target added.\n+\t* gcc/doc/install.texi, invoke.texi, md.texi: FT32 details added.\n+\t* gcc/doc/contrib.texi: self added.\n+\t* contrib/config-list.mk: FT32 target added.\n+\t* configure: Regenerated.\n+\n 2015-05-16  Iain Buclaw  <ibuclaw@gdcproject.org>\n \n \t* MAINTAINERS (Write After Approval): Add myself."}, {"sha": "d8043298ad0908298ccb53267d8e6f4e59b22b0d", "filename": "configure", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef939d6a96bde0f924152e6b9e22701c28f8880/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef939d6a96bde0f924152e6b9e22701c28f8880/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=fef939d6a96bde0f924152e6b9e22701c28f8880", "patch": "@@ -3363,6 +3363,9 @@ if test \"${ENABLE_LIBSTDCXX}\" = \"default\" ; then\n     avr-*-*)\n       noconfigdirs=\"$noconfigdirs target-libstdc++-v3\"\n       ;;\n+    ft32-*-*)\n+      noconfigdirs=\"$noconfigdirs target-libstdc++-v3\"\n+      ;;\n   esac\n fi\n "}, {"sha": "4da04b76fdf80fcd679f2ff4e7161c3796397455", "filename": "configure.ac", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef939d6a96bde0f924152e6b9e22701c28f8880/configure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef939d6a96bde0f924152e6b9e22701c28f8880/configure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.ac?ref=fef939d6a96bde0f924152e6b9e22701c28f8880", "patch": "@@ -710,6 +710,9 @@ if test \"${ENABLE_LIBSTDCXX}\" = \"default\" ; then\n     avr-*-*)\n       noconfigdirs=\"$noconfigdirs target-libstdc++-v3\"\n       ;;\n+    ft32-*-*)\n+      noconfigdirs=\"$noconfigdirs target-libstdc++-v3\"\n+      ;;\n   esac\n fi\n "}, {"sha": "0f080d34b35ed42b883d664ee8321ae7ba5ada8f", "filename": "contrib/config-list.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef939d6a96bde0f924152e6b9e22701c28f8880/contrib%2Fconfig-list.mk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef939d6a96bde0f924152e6b9e22701c28f8880/contrib%2Fconfig-list.mk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fconfig-list.mk?ref=fef939d6a96bde0f924152e6b9e22701c28f8880", "patch": "@@ -22,7 +22,7 @@ LIST = aarch64-elf aarch64-linux-gnu \\\n   bfin-elf bfin-uclinux bfin-linux-uclibc bfin-rtems bfin-openbsd \\\n   c6x-elf c6x-uclinux cr16-elf cris-elf cris-linux crisv32-elf crisv32-linux \\\n   epiphany-elf epiphany-elfOPT-with-stack-offset=16 fido-elf \\\n-  fr30-elf frv-elf frv-linux h8300-elf h8300-rtems hppa-linux-gnu \\\n+  fr30-elf frv-elf frv-linux ft32-elf h8300-elf h8300-rtems hppa-linux-gnu \\\n   hppa-linux-gnuOPT-enable-sjlj-exceptions=yes hppa64-linux-gnu \\\n   hppa2.0-hpux10.1 hppa64-hpux11.3 \\\n   hppa64-hpux11.0OPT-enable-sjlj-exceptions=yes hppa2.0-hpux11.9 \\"}, {"sha": "91fbf86e86d4a7b189fa40936166100d1de16e01", "filename": "gcc/config.gcc", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef939d6a96bde0f924152e6b9e22701c28f8880/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef939d6a96bde0f924152e6b9e22701c28f8880/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=fef939d6a96bde0f924152e6b9e22701c28f8880", "patch": "@@ -340,6 +340,9 @@ crisv32-*)\n frv*)\tcpu_type=frv\n \textra_options=\"${extra_options} g.opt\"\n \t;;\n+ft32*)\tcpu_type=ft32\n+\ttarget_has_targetm_common=no\n+\t;;\n moxie*)\tcpu_type=moxie\n \ttarget_has_targetm_common=no\n \t;;\n@@ -1194,6 +1197,12 @@ frv-*-*linux*)\n \t         gnu-user.h linux.h glibc-stdint.h frv/linux.h\"\n \ttmake_file=\"${tmake_file} frv/t-frv frv/t-linux\"\n \t;;\n+ft32-*-elf)\n+\tgas=yes\n+\tgnu_ld=yes\n+\ttm_file=\"dbxelf.h elfos.h newlib-stdint.h ${tm_file}\"\n+\ttmake_file=\"${tmake_file} ft32/t-ft32\"\n+\t;;\n moxie-*-elf)\n \tgas=yes\n \tgnu_ld=yes"}, {"sha": "8bd838930da4e8b5cac301bf475f4cdffdecd264", "filename": "gcc/config/ft32/constraints.md", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef939d6a96bde0f924152e6b9e22701c28f8880/gcc%2Fconfig%2Fft32%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef939d6a96bde0f924152e6b9e22701c28f8880/gcc%2Fconfig%2Fft32%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fft32%2Fconstraints.md?ref=fef939d6a96bde0f924152e6b9e22701c28f8880", "patch": "@@ -0,0 +1,113 @@\n+;; Constraint definitions for FT32\n+;; Copyright (C) 2015 Free Software Foundation, Inc.\n+;; Contributed by FTDI <support@ftdi.com>\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 3, or (at your\n+;; option) any later version.\n+\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+;; -------------------------------------------------------------------------\n+;; Constraints\n+;; -------------------------------------------------------------------------\n+\n+(define_memory_constraint \"A\"\n+  \"An absolute address.\"\n+  (and (match_code \"mem\")\n+       (match_test \"(!ft32_is_mem_pm(op))\")\n+       (ior (match_test \"GET_CODE (XEXP (op, 0)) == SYMBOL_REF\")\n+            (match_test \"GET_CODE (XEXP (op, 0)) == LABEL_REF\")\n+            (match_test \"GET_CODE (XEXP (op, 0)) == CONST_INT\")\n+            (and (match_test \"(GET_CODE (XEXP (op, 0)) == PLUS)\")\n+                 (ior (match_test \"GET_CODE (XEXP (XEXP (op, 0), 0)) == SYMBOL_REF\")\n+                      (match_test \"GET_CODE (XEXP (XEXP (op, 0), 0)) == LABEL_REF\")\n+                      (match_test \"GET_CODE (XEXP (XEXP (op, 0), 0)) == CONST_INT\"))\n+                 (ior (match_test \"GET_CODE (XEXP (XEXP (op, 0), 1)) == SYMBOL_REF\")\n+                      (match_test \"GET_CODE (XEXP (XEXP (op, 0), 1)) == LABEL_REF\")\n+                      (match_test \"GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT\"))))))\n+\n+(define_memory_constraint \"B\"\n+  \"An offset address.\"\n+  (and (match_code \"mem\")\n+       (match_test \"(!ft32_is_mem_pm(op))\")\n+       (match_test \"(GET_CODE (XEXP (op, 0)) == PLUS)\")))\n+\n+(define_memory_constraint \"W\"\n+  \"A register indirect memory operand.\"\n+  (and (match_code \"mem\")\n+       (match_test \"!ft32_is_mem_pm(op)\n+        && REG_P (XEXP (op, 0))\n+\t\t    && REGNO_OK_FOR_BASE_P (REGNO (XEXP (op, 0)))\")))\n+\n+(define_memory_constraint \"e\"\n+  \"An offset address.\"\n+  (and (match_code \"mem\")\n+       (match_test \"ft32_is_mem_pm(op) && (\n+          (GET_CODE (XEXP (op, 0)) == SYMBOL_REF) ||\n+          (GET_CODE (XEXP (op, 0)) == LABEL_REF) ||\n+          (GET_CODE (XEXP (op, 0)) == CONST_INT) ||\n+          (GET_CODE (XEXP (op, 0)) == CONST))\"\n+       )))\n+\n+(define_memory_constraint \"f\"\n+  \"An offset address.\"\n+  (and (match_code \"mem\")\n+       (match_test \"ft32_is_mem_pm(op) && (\n+          ((GET_CODE (XEXP (op, 0)) == PLUS)) ||\n+          (GET_CODE (XEXP (op, 0)) == REG))\"\n+       )))\n+\n+(define_constraint \"O\"\n+  \"The constant zero or one\"\n+  (and (match_code \"const_int\")\n+       (match_test \"((ival == 0) || (ival == 1))\")))\n+\n+(define_constraint \"I\"\n+  \"A 16-bit signed constant (-32768..32767)\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= -32768 && ival <= 32767\")))\n+\n+(define_constraint \"w\"\n+  \"A bitfield mask suitable for bext or bins\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ft32_as_bitfield(ival) != -1\")))\n+\n+(define_constraint \"x\"\n+  \"An inverted bitfield mask suitable for bext or bins\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ft32_as_bitfield(0xffffffff ^ ival) != -1\")))\n+\n+(define_constraint \"L\"\n+  \"A 16-bit unsigned constant, multiple of 4 (-65532..0)\"\n+  (and (match_code \"const_int\")\n+       (match_test \"-65532 <= ival && ival <= 0 && (ival & 3) == 0\")))\n+\n+(define_constraint \"S\"\n+  \"A 20-bit signed constant (-524288..524287)\"\n+  (ior\n+    (and (match_code \"const_int\")\n+         (match_test \"ival >= -524288 && ival <= 524287\"))\n+    (match_test \"GET_CODE (op) == LABEL_REF\")\n+    (match_test \"GET_CODE (op) == SYMBOL_REF\")\n+    (match_test \"GET_CODE (op) == CONST\")))\n+\n+(define_constraint \"b\"\n+  \"A constant for a bitfield width (1..16)\"\n+  (and (match_code \"const_int\")\n+       (match_test \"1 <= ival && ival <= 16\")))\n+\n+(define_constraint \"KA\"\n+  \"A 10-bit signed constant (-512..511)\"\n+  (and (match_code \"const_int\")\n+       (match_test \"-512 <= ival && ival <= 511\")))"}, {"sha": "8e8e6da6817e5e63ff2fe6c7ca4ff9fe4a105454", "filename": "gcc/config/ft32/ft32-protos.h", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef939d6a96bde0f924152e6b9e22701c28f8880/gcc%2Fconfig%2Fft32%2Fft32-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef939d6a96bde0f924152e6b9e22701c28f8880/gcc%2Fconfig%2Fft32%2Fft32-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fft32%2Fft32-protos.h?ref=fef939d6a96bde0f924152e6b9e22701c28f8880", "patch": "@@ -0,0 +1,26 @@\n+/* Prototypes for ft32.c functions used in the md file & elsewhere.\n+   Copyright (C) 2015 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+extern void        ft32_expand_prologue (void);\n+extern void        ft32_expand_epilogue (void);\n+extern int         ft32_initial_elimination_offset (int, int);\n+extern void        ft32_print_operand (FILE *, rtx, int);\n+extern void        ft32_print_operand_address (FILE *, rtx);\n+extern const char* ft32_load_immediate(rtx, int32_t i);\n+extern int         ft32_as_bitfield(unsigned int x);"}, {"sha": "7c7dbd5374cc3ae11f536c97e93ea188c48299f4", "filename": "gcc/config/ft32/ft32.c", "status": "added", "additions": 921, "deletions": 0, "changes": 921, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef939d6a96bde0f924152e6b9e22701c28f8880/gcc%2Fconfig%2Fft32%2Fft32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef939d6a96bde0f924152e6b9e22701c28f8880/gcc%2Fconfig%2Fft32%2Fft32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fft32%2Fft32.c?ref=fef939d6a96bde0f924152e6b9e22701c28f8880", "patch": "@@ -0,0 +1,921 @@\n+/* Target Code for ft32\n+   Copyright (C) 2015  Free Software Foundation\n+   Contributed by FTDI <support@ftdi.com>\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"insn-flags.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\n+#include \"flags.h\"\n+#include \"recog.h\"\n+#include \"reload.h\"\n+#include \"diagnostic-core.h\"\n+#include \"obstack.h\"\n+#include \"hash-set.h\"\n+#include \"machmode.h\"\n+#include \"vec.h\"\n+#include \"double-int.h\"\n+#include \"input.h\"\n+#include \"alias.h\"\n+#include \"symtab.h\"\n+#include \"wide-int.h\"\n+#include \"inchash.h\"\n+#include \"tree.h\"\n+#include \"stor-layout.h\"\n+#include \"calls.h\"\n+#include \"expr.h\"\n+#include \"optabs.h\"\n+#include \"except.h\"\n+#include \"function.h\"\n+#include \"ggc.h\"\n+#include \"target.h\"\n+#include \"target-def.h\"\n+#include \"tm_p.h\"\n+#include \"langhooks.h\"\n+#include \"dominance.h\"\n+#include \"cfg.h\"\n+#include \"cfgrtl.h\"\n+#include \"cfganal.h\"\n+#include \"lcm.h\"\n+#include \"cfgbuild.h\"\n+#include \"cfgcleanup.h\"\n+#include \"predict.h\"\n+#include \"basic-block.h\"\n+#include \"df.h\"\n+#include \"builtins.h\"\n+\n+\n+#include <stdint.h>\n+\n+#define LOSE_AND_RETURN(msgid, x)               \\\n+  do                                            \\\n+    {                                           \\\n+      ft32_operand_lossage (msgid, x);            \\\n+      return;                                   \\\n+    } while (0)\n+\n+/* Worker function for TARGET_RETURN_IN_MEMORY.  */\n+\n+static bool\n+ft32_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n+{\n+  const HOST_WIDE_INT size = int_size_in_bytes (type);\n+  return (size == -1 || size > 2 * UNITS_PER_WORD);\n+}\n+\n+/* Define how to find the value returned by a function.\n+   VALTYPE is the data type of the value (as a tree).\n+   If the precise function being called is known, FUNC is its\n+   FUNCTION_DECL; otherwise, FUNC is 0.\n+\n+   We always return values in register $r0 for ft32.  */\n+\n+static rtx\n+ft32_function_value (const_tree valtype,\n+                     const_tree fntype_or_decl ATTRIBUTE_UNUSED,\n+                     bool outgoing ATTRIBUTE_UNUSED)\n+{\n+  return gen_rtx_REG (TYPE_MODE (valtype), FT32_R0);\n+}\n+\n+/* Define how to find the value returned by a library function.\n+\n+   We always return values in register $r0 for ft32.  */\n+\n+static rtx\n+ft32_libcall_value (enum machine_mode mode, const_rtx fun ATTRIBUTE_UNUSED)\n+{\n+  return gen_rtx_REG (mode, FT32_R0);\n+}\n+\n+/* Handle TARGET_FUNCTION_VALUE_REGNO_P.\n+\n+   We always return values in register $r0 for ft32.  */\n+\n+static bool\n+ft32_function_value_regno_p (const unsigned int regno)\n+{\n+  return (regno == FT32_R0);\n+}\n+\n+/* Emit an error message when we're in an asm, and a fatal error for\n+   \"normal\" insns.  Formatted output isn't easily implemented, since we\n+   use output_operand_lossage to output the actual message and handle the\n+   categorization of the error.  */\n+\n+static void\n+ft32_operand_lossage (const char *msgid, rtx op)\n+{\n+  debug_rtx (op);\n+  output_operand_lossage (\"%s\", msgid);\n+}\n+\n+/* The PRINT_OPERAND_ADDRESS worker.  */\n+\n+void\n+ft32_print_operand_address (FILE * file, rtx x)\n+{\n+  switch (GET_CODE (x))\n+    {\n+    case REG:\n+      fprintf (file, \"%s,0\", reg_names[REGNO (x)]);\n+      break;\n+\n+    case PLUS:\n+      switch (GET_CODE (XEXP (x, 1)))\n+        {\n+        case CONST_INT:\n+          fprintf (file, \"%s,%ld\",\n+                   reg_names[REGNO (XEXP (x, 0))], INTVAL (XEXP (x, 1)));\n+          break;\n+        case SYMBOL_REF:\n+          output_addr_const (file, XEXP (x, 1));\n+          fprintf (file, \"(%s)\", reg_names[REGNO (XEXP (x, 0))]);\n+          break;\n+        case CONST:\n+          {\n+            rtx plus = XEXP (XEXP (x, 1), 0);\n+            if (GET_CODE (XEXP (plus, 0)) == SYMBOL_REF\n+                && CONST_INT_P (XEXP (plus, 1)))\n+              {\n+                output_addr_const (file, XEXP (plus, 0));\n+                fprintf (file, \"+%ld(%s)\", INTVAL (XEXP (plus, 1)),\n+                         reg_names[REGNO (XEXP (x, 0))]);\n+              }\n+            else\n+              abort ();\n+          }\n+          break;\n+        default:\n+          abort ();\n+        }\n+      break;\n+\n+    default:\n+      output_addr_const (file, x);\n+      break;\n+    }\n+}\n+\n+/* The PRINT_OPERAND worker.  */\n+\n+void\n+ft32_print_operand (FILE * file, rtx x, int code)\n+{\n+  rtx operand = x;\n+\n+  /* New code entries should just be added to the switch below.  If\n+     handling is finished, just return.  If handling was just a\n+     modification of the operand, the modified operand should be put in\n+     \"operand\", and then do a break to let default handling\n+     (zero-modifier) output the operand.  */\n+\n+  switch (code)\n+    {\n+    case 0:\n+      /* No code, print as usual.  */\n+      break;\n+\n+    case 'h':\n+      if (GET_CODE (operand) != REG)\n+        internal_error (\"'h' applied to non-register operand\");\n+      fprintf (file, \"%s\", reg_names[REGNO (operand) + 1]);\n+      return;\n+\n+    case 'm':\n+      fprintf (file, \"%d\", -INTVAL(x));\n+      return;\n+\n+    case 'd':                   // a DW spec, from an integer alignment (for BLKmode insns)\n+      {\n+        int i = INTVAL (x);\n+        char dwspec;\n+        switch (i)\n+          {\n+          case 1:\n+            dwspec = 'b';\n+            break;\n+          case 2:\n+            dwspec = 's';\n+            break;\n+          case 4:\n+            dwspec = 'l';\n+            break;\n+          default:\n+            if ((i % 4) != 0)\n+              internal_error (\"bad alignment: %d\", i);\n+            else\n+              dwspec = 'l';\n+            break;\n+          }\n+        fprintf (file, \"%c\", dwspec);\n+        return;\n+      }\n+\n+    case 'f':\n+      {\n+        int bf = ft32_as_bitfield (INTVAL (x));\n+        fprintf (file, \"512|(%d<<5)|%d\", bf >> 5, bf & 31);\n+        return;\n+      }\n+\n+    case 'g':\n+      {\n+        int bf = ft32_as_bitfield (0xffffffff ^ INTVAL (x));\n+        fprintf (file, \"(%d<<5)|%d\", bf >> 5, bf & 31);\n+        return;\n+      }\n+\n+    case 'b':\n+      {\n+        ft32_print_operand (file, XEXP (x, 0), 0);\n+        return;\n+      }\n+\n+    default:\n+      LOSE_AND_RETURN (\"invalid operand modifier letter\", x);\n+    }\n+\n+  /* Print an operand as without a modifier letter.  */\n+  switch (GET_CODE (operand))\n+    {\n+    case REG:\n+      fprintf (file, \"%s\", reg_names[REGNO (operand)]);\n+      return;\n+\n+    case MEM:\n+      output_address (XEXP (operand, 0));\n+      return;\n+\n+    default:\n+      /* No need to handle all strange variants, let output_addr_const\n+         do it for us.  */\n+      if (CONSTANT_P (operand))\n+        {\n+          output_addr_const (file, operand);\n+          return;\n+        }\n+\n+      LOSE_AND_RETURN (\"unexpected operand\", x);\n+    }\n+}\n+\n+const char *\n+ft32_load_immediate (rtx dst, int32_t i)\n+{\n+  char pattern[100];\n+\n+  if ((-524288 <= i) && (i <= 524287))\n+    {\n+      sprintf (pattern, \"ldk.l  %%0,%d\", i);\n+      output_asm_insn (pattern, &dst);\n+    }\n+  else if ((-536870912 <= i) && (i <= 536870911))\n+    {\n+      ft32_load_immediate (dst, i >> 10);\n+      sprintf (pattern, \"ldl.l  %%0,%%0,%d\", i & 1023);\n+      output_asm_insn (pattern, &dst);\n+    }\n+  else\n+    {\n+      int rd;                   // rotate distance\n+      uint32_t u = i;\n+      for (rd = 1; rd < 32; rd++)\n+        {\n+          u = ((u >> 31) & 1) | (u << 1);\n+          if ((-524288 <= (int32_t) u) && ((int32_t) u <= 524287))\n+            {\n+              ft32_load_immediate (dst, (int32_t) u);\n+              sprintf (pattern, \"ror.l  %%0,%%0,%d\", rd);\n+              output_asm_insn (pattern, &dst);\n+              return \"\";\n+            }\n+        }\n+      ft32_load_immediate (dst, i >> 10);\n+      sprintf (pattern, \"ldl.l  %%0,%%0,%d\", i & 1023);\n+      output_asm_insn (pattern, &dst);\n+    }\n+\n+  return \"\";\n+}\n+\n+// x is a bit mask, for example:\n+//    00000000000000000000001111111110\n+// If x contains a single bit mask, return the bitfield spec.\n+// in the above case it returns ((9 << 5) | 1)\n+// Otherwise return -1.\n+//\n+\n+#define NBITS(n)  ((1U << (n)) - 1U)\n+\n+int\n+ft32_as_bitfield (unsigned int x)\n+{\n+  int lobit, hibit;\n+\n+  if (x == 0)\n+    return -1;\n+\n+  for (lobit = 0; lobit < 32; lobit++)\n+    if (x & (1 << lobit))\n+      break;\n+  for (hibit = 31; hibit >= 0; hibit--)\n+    if (x & (1 << hibit))\n+      break;\n+\n+  int width = 1 + hibit - lobit;\n+  if (width > 16)\n+    return -1;\n+\n+  if (x != (NBITS (width) << lobit))\n+    return -1;                  // not a clean bitfield\n+\n+  return ((width & 15) << 5) | lobit;\n+}\n+\n+/* Per-function machine data.  */\n+struct GTY (()) machine_function\n+{\n+  /* Number of bytes saved on the stack for callee saved registers.  */\n+  int callee_saved_reg_size;\n+\n+  /* Number of bytes saved on the stack for local variables.  */\n+  int local_vars_size;\n+\n+  /* The sum of 2 sizes: locals vars and padding byte for saving the\n+   * registers.  Used in expand_prologue () and expand_epilogue ().  */\n+  int size_for_adjusting_sp;\n+};\n+\n+/* Zero initialization is OK for all current fields.  */\n+\n+static struct machine_function *\n+ft32_init_machine_status (void)\n+{\n+  return ggc_cleared_alloc < machine_function > ();\n+}\n+\n+\n+/* The TARGET_OPTION_OVERRIDE worker.\n+   All this curently does is set init_machine_status.  */\n+static void\n+ft32_option_override (void)\n+{\n+  /* Set the per-function-data initializer.  */\n+  init_machine_status = ft32_init_machine_status;\n+}\n+\n+/* Implement targetm.select_section.  */\n+static section *\n+ft32_select_section (tree decl, int reloc, unsigned HOST_WIDE_INT align)\n+{\n+  /* Variables and constants defined in the __ea address space\n+     go into a special section named \"._ea\".  */\n+  if (TREE_TYPE (decl) != error_mark_node\n+      && TYPE_ADDR_SPACE (TREE_TYPE (decl)) == ADDR_SPACE_PM)\n+    {\n+      /* We might get called with string constants, but get_named_section\n+         doesn't like them as they are not DECLs.  Also, we need to set\n+         flags in that case.  */\n+      if (!DECL_P (decl))\n+        return get_section (\"._pm\", SECTION_WRITE | SECTION_DEBUG, NULL);\n+\n+      return get_named_section (decl, \"._pm\", reloc);\n+    }\n+\n+  return default_elf_select_section (decl, reloc, align);\n+}\n+\n+/* Compute the size of the local area and the size to be adjusted by the\n+ * prologue and epilogue.  */\n+\n+static void\n+ft32_compute_frame (void)\n+{\n+  /* For aligning the local variables.  */\n+  int stack_alignment = STACK_BOUNDARY / BITS_PER_UNIT;\n+  int padding_locals;\n+  int regno;\n+\n+  /* Padding needed for each element of the frame.  */\n+  cfun->machine->local_vars_size = get_frame_size ();\n+\n+  /* Align to the stack alignment.  */\n+  padding_locals = cfun->machine->local_vars_size % stack_alignment;\n+  if (padding_locals)\n+    padding_locals = stack_alignment - padding_locals;\n+\n+  cfun->machine->local_vars_size += padding_locals;\n+\n+  cfun->machine->callee_saved_reg_size = 0;\n+\n+  /* Save callee-saved registers.  */\n+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    if (df_regs_ever_live_p (regno) && (!call_used_regs[regno]))\n+      cfun->machine->callee_saved_reg_size += 4;\n+\n+  cfun->machine->size_for_adjusting_sp =\n+    crtl->args.pretend_args_size\n+    + cfun->machine->local_vars_size\n+    + (ACCUMULATE_OUTGOING_ARGS ? crtl->outgoing_args_size : 0);\n+}\n+\n+// Must use LINK/UNLINK when...\n+// the frame is bigger than 512 bytes so cannot just \"SUB\" from SP\n+// the function actually uses $fp\n+\n+static int\n+must_link (void)\n+{\n+  int bigframe = (cfun->machine->size_for_adjusting_sp >= 512);\n+  return (bigframe || frame_pointer_needed || df_regs_ever_live_p (FT32_FP)\n+          || df_regs_ever_live_p (FT32_FP));\n+}\n+\n+void\n+ft32_expand_prologue (void)\n+{\n+  int regno;\n+  rtx insn;\n+\n+  ft32_compute_frame ();\n+\n+  if (!must_link () && (cfun->machine->callee_saved_reg_size == 4))\n+    {\n+      insn =\n+        emit_insn (gen_link\n+                   (gen_rtx_REG (Pmode, FT32_R13),\n+                    GEN_INT (-cfun->machine->size_for_adjusting_sp)));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+      return;\n+    }\n+  /* Save callee-saved registers.  */\n+  if (optimize_size)\n+    {\n+      for (regno = FIRST_PSEUDO_REGISTER; regno-- > 0;)\n+        {\n+          if (!fixed_regs[regno] && !call_used_regs[regno]\n+              && df_regs_ever_live_p (regno))\n+            {\n+              rtx preg = gen_rtx_REG (Pmode, regno);\n+              emit_insn (gen_call_prolog (preg));\n+              break;\n+            }\n+        }\n+    }\n+  else\n+    {\n+      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+        {\n+          if (!fixed_regs[regno] && df_regs_ever_live_p (regno)\n+              && !call_used_regs[regno])\n+            {\n+              insn = emit_insn (gen_movsi_push (gen_rtx_REG (Pmode, regno)));\n+              RTX_FRAME_RELATED_P (insn) = 1;\n+            }\n+        }\n+    }\n+\n+  if (65536 <= cfun->machine->size_for_adjusting_sp)\n+    {\n+      error (\"stack frame must be smaller than 64K\");\n+      return;\n+    }\n+  if (must_link ())\n+    {\n+      insn =\n+        emit_insn (gen_link\n+                   (gen_rtx_REG (Pmode, FT32_FP),\n+                    GEN_INT (-cfun->machine->size_for_adjusting_sp)));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+  else if (cfun->machine->size_for_adjusting_sp > 0)\n+    {\n+      insn = emit_insn (gen_addsi3 (gen_rtx_REG (SImode, FT32_SP),\n+                                    gen_rtx_REG (SImode, FT32_SP),\n+                                    GEN_INT (-(cfun->machine->\n+                                               size_for_adjusting_sp))));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+}\n+\n+void\n+ft32_expand_epilogue (void)\n+{\n+  int regno;\n+\n+  if (!must_link ()\n+      && (cfun->machine->size_for_adjusting_sp == 24)\n+      && (cfun->machine->callee_saved_reg_size == 0))\n+    {\n+      emit_jump_insn (gen_returner24 ());\n+      return;\n+    }\n+\n+  // Set when the epilog code will also add 24 to $sp\n+  int epilog24 = (!must_link ()\n+                  && (cfun->machine->size_for_adjusting_sp == 24)\n+                  && optimize_size);\n+\n+  if (must_link ())\n+    {\n+      emit_insn (gen_unlink ());\n+    }\n+  else if (!epilog24 && (cfun->machine->size_for_adjusting_sp > 0))\n+    {\n+      emit_insn (gen_addsi3 (gen_rtx_REG (SImode, FT32_SP),\n+                             gen_rtx_REG (SImode, FT32_SP),\n+                             GEN_INT (cfun->machine->size_for_adjusting_sp)));\n+    }\n+\n+  if (cfun->machine->callee_saved_reg_size != 0)\n+    {\n+      for (regno = FIRST_PSEUDO_REGISTER; regno-- > 0;)\n+        {\n+          if (!fixed_regs[regno] && !call_used_regs[regno]\n+              && df_regs_ever_live_p (regno))\n+            {\n+              rtx preg = gen_rtx_REG (Pmode, regno);\n+              if (optimize_size)\n+                {\n+                  if (epilog24)\n+                    emit_insn (gen_jump_epilog24 (preg));\n+                  else\n+                    emit_insn (gen_jump_epilog (preg));\n+                  return;\n+                }\n+              emit_insn (gen_movsi_pop (preg));\n+            }\n+        }\n+    }\n+\n+  emit_jump_insn (gen_returner ());\n+}\n+\n+#undef TARGET_FRAME_POINTER_REQUIRED\n+#define TARGET_FRAME_POINTER_REQUIRED ft32_frame_pointer_required\n+static bool\n+ft32_frame_pointer_required (void)\n+{\n+  return cfun->calls_alloca;\n+}\n+\n+#undef  TARGET_CAN_ELIMINATE\n+#define TARGET_CAN_ELIMINATE ft32_can_eliminate\n+\n+/* Return true if register FROM can be eliminated via register TO.  */\n+\n+static bool\n+ft32_can_eliminate (const int from ATTRIBUTE_UNUSED, const int to)\n+{\n+  return 1;\n+  return (to == FRAME_POINTER_REGNUM) || !ft32_frame_pointer_required ();\n+}\n+\n+/* Implements the macro INITIAL_ELIMINATION_OFFSET, return the OFFSET.  */\n+\n+int\n+ft32_initial_elimination_offset (int from, int to)\n+{\n+  ft32_compute_frame ();\n+\n+  if (from == ARG_POINTER_REGNUM && to == FRAME_POINTER_REGNUM)\n+    {\n+      return cfun->machine->callee_saved_reg_size + 2 * UNITS_PER_WORD;\n+    }\n+\n+  if (from == ARG_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n+    {\n+      int arg_offset;\n+      arg_offset = must_link ()? 2 : 1;\n+      return ((cfun->machine->callee_saved_reg_size\n+               + arg_offset * UNITS_PER_WORD)\n+              + cfun->machine->size_for_adjusting_sp);\n+    }\n+\n+  if ((from == FRAME_POINTER_REGNUM) && (to == STACK_POINTER_REGNUM))\n+    {\n+      return cfun->machine->size_for_adjusting_sp;\n+    }\n+\n+  gcc_unreachable ();\n+}\n+\n+/* Worker function for TARGET_SETUP_INCOMING_VARARGS.  */\n+\n+static void\n+ft32_setup_incoming_varargs (cumulative_args_t cum_v,\n+                             enum machine_mode mode ATTRIBUTE_UNUSED,\n+                             tree type ATTRIBUTE_UNUSED,\n+                             int *pretend_size, int no_rtl)\n+{\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+  int regno;\n+  int regs = 8 - *cum;\n+\n+  *pretend_size = regs < 0 ? 0 : GET_MODE_SIZE (SImode) * regs;\n+\n+  if (no_rtl)\n+    return;\n+\n+  for (regno = *cum; regno < 8; regno++)\n+    {\n+      rtx reg = gen_rtx_REG (SImode, regno);\n+      rtx slot = gen_rtx_PLUS (Pmode,\n+                               gen_rtx_REG (SImode, ARG_POINTER_REGNUM),\n+                               GEN_INT (UNITS_PER_WORD * (regno - FT32_R0)));\n+\n+      emit_move_insn (gen_rtx_MEM (SImode, slot), reg);\n+    }\n+}\n+\n+\n+/* Return the fixed registers used for condition codes.  */\n+\n+static bool\n+ft32_fixed_condition_code_regs (unsigned int *p1, unsigned int *p2)\n+{\n+  *p1 = CC_REG;\n+  *p2 = INVALID_REGNUM;\n+  return true;\n+}\n+\n+/* Return the next register to be used to hold a function argument or\n+   NULL_RTX if there's no more space.  */\n+\n+static rtx\n+ft32_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n+                   const_tree type ATTRIBUTE_UNUSED,\n+                   bool named ATTRIBUTE_UNUSED)\n+{\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+\n+  if (*cum < 8)\n+    return gen_rtx_REG (mode, *cum);\n+  else\n+    return NULL_RTX;\n+}\n+\n+#define FT32_FUNCTION_ARG_SIZE(MODE, TYPE)      \\\n+  ((MODE) != BLKmode ? GET_MODE_SIZE (MODE)     \\\n+   : (unsigned) int_size_in_bytes (TYPE))\n+\n+static void\n+ft32_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n+                           const_tree type, bool named ATTRIBUTE_UNUSED)\n+{\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+\n+  *cum = (*cum < FT32_R6\n+          ? *cum + ((3 + FT32_FUNCTION_ARG_SIZE (mode, type)) / 4) : *cum);\n+}\n+\n+/* Return non-zero if the function argument described by TYPE is to be\n+   passed by reference.  */\n+\n+static bool\n+ft32_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n+                        enum machine_mode mode, const_tree type,\n+                        bool named ATTRIBUTE_UNUSED)\n+{\n+  unsigned HOST_WIDE_INT size;\n+\n+  if (type)\n+    {\n+      if (AGGREGATE_TYPE_P (type))\n+        return true;\n+      size = int_size_in_bytes (type);\n+    }\n+  else\n+    size = GET_MODE_SIZE (mode);\n+\n+  return size > 4 * 6;\n+}\n+\n+/* Some function arguments will only partially fit in the registers\n+   that hold arguments.  Given a new arg, return the number of bytes\n+   that fit in argument passing registers.  */\n+\n+static int\n+ft32_arg_partial_bytes (cumulative_args_t cum_v,\n+                        enum machine_mode mode, tree type, bool named)\n+{\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+  int bytes_left, size;\n+\n+  if (*cum >= 8)\n+    return 0;\n+\n+  if (ft32_pass_by_reference (cum_v, mode, type, named))\n+    size = 4;\n+  else if (type)\n+    {\n+      if (AGGREGATE_TYPE_P (type))\n+        return 0;\n+      size = int_size_in_bytes (type);\n+    }\n+  else\n+    size = GET_MODE_SIZE (mode);\n+\n+  bytes_left = (4 * 6) - ((*cum - 2) * 4);\n+\n+  if (size > bytes_left)\n+    return bytes_left;\n+  else\n+    return 0;\n+}\n+\n+/* Used by constraints.md to distinguish between GENERIC and PM\n+   memory addresses.  */\n+\n+int\n+ft32_is_mem_pm (rtx o)\n+{\n+  if (GET_CODE (o) != MEM)\n+    return false;\n+  if (MEM_EXPR (o))\n+    return TYPE_ADDR_SPACE (TREE_TYPE (MEM_EXPR (o))) == ADDR_SPACE_PM;\n+  else\n+    return MEM_ADDR_SPACE (o) == ADDR_SPACE_PM;\n+}\n+\n+/* The Global `targetm' Variable.  */\n+\n+/* Initialize the GCC target structure.  */\n+\n+#undef  TARGET_PROMOTE_PROTOTYPES\n+#define TARGET_PROMOTE_PROTOTYPES       hook_bool_const_tree_true\n+\n+#undef  TARGET_RETURN_IN_MEMORY\n+#define TARGET_RETURN_IN_MEMORY         ft32_return_in_memory\n+#undef  TARGET_MUST_PASS_IN_STACK\n+#define TARGET_MUST_PASS_IN_STACK       must_pass_in_stack_var_size\n+#undef  TARGET_PASS_BY_REFERENCE\n+#define TARGET_PASS_BY_REFERENCE        ft32_pass_by_reference\n+#undef  TARGET_ARG_PARTIAL_BYTES\n+#define TARGET_ARG_PARTIAL_BYTES        ft32_arg_partial_bytes\n+#undef  TARGET_FUNCTION_ARG\n+#define TARGET_FUNCTION_ARG             ft32_function_arg\n+#undef  TARGET_FUNCTION_ARG_ADVANCE\n+#define TARGET_FUNCTION_ARG_ADVANCE     ft32_function_arg_advance\n+\n+\n+#undef  TARGET_SETUP_INCOMING_VARARGS\n+#define TARGET_SETUP_INCOMING_VARARGS   ft32_setup_incoming_varargs\n+\n+#undef  TARGET_FIXED_CONDITION_CODE_REGS\n+#define TARGET_FIXED_CONDITION_CODE_REGS ft32_fixed_condition_code_regs\n+\n+/* Define this to return an RTX representing the place where a\n+   function returns or receives a value of data type RET_TYPE, a tree\n+   node node representing a data type.  */\n+#undef TARGET_FUNCTION_VALUE\n+#define TARGET_FUNCTION_VALUE ft32_function_value\n+#undef TARGET_LIBCALL_VALUE\n+#define TARGET_LIBCALL_VALUE ft32_libcall_value\n+#undef TARGET_FUNCTION_VALUE_REGNO_P\n+#define TARGET_FUNCTION_VALUE_REGNO_P ft32_function_value_regno_p\n+\n+#undef TARGET_OPTION_OVERRIDE\n+#define TARGET_OPTION_OVERRIDE ft32_option_override\n+\n+#undef TARGET_ASM_SELECT_SECTION\n+#define TARGET_ASM_SELECT_SECTION  ft32_select_section\n+\n+#undef TARGET_VALID_POINTER_MODE\n+#define TARGET_VALID_POINTER_MODE ft32_valid_pointer_mode\n+static bool\n+ft32_valid_pointer_mode (enum machine_mode mode)\n+{\n+  if (mode == SImode)\n+    return 1;\n+  return 0;\n+}\n+\n+#undef TARGET_ADDR_SPACE_POINTER_MODE\n+#define TARGET_ADDR_SPACE_POINTER_MODE ft32_addr_space_pointer_mode\n+static enum machine_mode\n+ft32_addr_space_pointer_mode (addr_space_t addrspace ATTRIBUTE_UNUSED)\n+{\n+  return Pmode;\n+}\n+\n+#undef TARGET_ADDR_SPACE_ADDRESS_MODE\n+#define TARGET_ADDR_SPACE_ADDRESS_MODE ft32_addr_space_address_mode\n+static enum machine_mode\n+ft32_addr_space_address_mode (addr_space_t addrspace ATTRIBUTE_UNUSED)\n+{\n+  return Pmode;\n+}\n+\n+#undef TARGET_ADDR_SPACE_SUBSET_P\n+#define TARGET_ADDR_SPACE_SUBSET_P ft32_addr_space_subset_p\n+static bool\n+ft32_addr_space_subset_p (addr_space_t subset ATTRIBUTE_UNUSED,\n+                          addr_space_t superset ATTRIBUTE_UNUSED)\n+{\n+  return false;\n+}\n+\n+#undef TARGET_CASE_VALUES_THRESHOLD\n+#define TARGET_CASE_VALUES_THRESHOLD ft32_target_case_values_threshold\n+\n+static unsigned int\n+ft32_target_case_values_threshold (void)\n+{\n+  return 4;\n+}\n+\n+#undef TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P\n+#define TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P \\\n+  ft32_addr_space_legitimate_address_p\n+\n+\n+// Enabling LRA gives the infamous\n+//    internal compiler error: Max. number of generated reload insns per insn is achieved (90)\n+// errors e.g. when compiling sieve.c\n+\n+static bool\n+ft32_lra_p (void)\n+{\n+  return ft32_lra_flag;\n+}\n+\n+#undef TARGET_LRA_P\n+#define TARGET_LRA_P ft32_lra_p\n+\n+static bool\n+reg_ok_for_base_p (rtx r, bool strict)\n+{\n+  int NUM = REGNO (r);\n+  if (strict)\n+    return (HARD_REGNO_OK_FOR_BASE_P (NUM)\n+            || HARD_REGNO_OK_FOR_BASE_P (reg_renumber[(NUM)]));\n+  else\n+    return ((NUM) >= FIRST_PSEUDO_REGISTER || HARD_REGNO_OK_FOR_BASE_P (NUM));\n+}\n+\n+static bool\n+ft32_addr_space_legitimate_address_p (enum machine_mode mode, rtx x,\n+                                      bool strict,\n+                                      addr_space_t as ATTRIBUTE_UNUSED)\n+{\n+  if (mode != BLKmode)\n+    {\n+      if (GET_CODE (x) == PLUS)\n+        {\n+          rtx op1, op2;\n+          op1 = XEXP (x, 0);\n+          op2 = XEXP (x, 1);\n+          if (GET_CODE (op1) == REG\n+              && CONST_INT_P (op2)\n+              && INTVAL (op2) >= -128\n+              && INTVAL (op2) < 128 && reg_ok_for_base_p (op1, strict))\n+            goto yes;\n+          if (GET_CODE (op1) == SYMBOL_REF && CONST_INT_P (op2))\n+            goto yes;\n+        }\n+      if (REG_P (x) && reg_ok_for_base_p (x, strict))\n+        goto yes;\n+      if (GET_CODE (x) == SYMBOL_REF\n+          || GET_CODE (x) == LABEL_REF || CONST_INT_P (x))\n+        goto yes;\n+    }\n+  else\n+    {\n+      if (REG_P (x) && reg_ok_for_base_p (x, strict))\n+        goto yes;\n+    }\n+\n+  return 0;\n+yes:\n+  return 1;\n+}\n+\n+struct gcc_target targetm = TARGET_INITIALIZER;\n+\n+#include \"gt-ft32.h\""}, {"sha": "0835aaef2865e0f7d30c482416984f0cb0b008b4", "filename": "gcc/config/ft32/ft32.h", "status": "added", "additions": 518, "deletions": 0, "changes": 518, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef939d6a96bde0f924152e6b9e22701c28f8880/gcc%2Fconfig%2Fft32%2Fft32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef939d6a96bde0f924152e6b9e22701c28f8880/gcc%2Fconfig%2Fft32%2Fft32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fft32%2Fft32.h?ref=fef939d6a96bde0f924152e6b9e22701c28f8880", "patch": "@@ -0,0 +1,518 @@\n+/* Target Definitions for ft32.\n+   Copyright (C) 2015 Free Software Foundation, Inc.\n+   Contributed by FTDI <support@ftdi.com>\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_FT32_H\n+#define GCC_FT32_H\n+\n+#undef  STARTFILE_SPEC\n+#define STARTFILE_SPEC \"crt0%O%s %{msim:crti.o%s} %{!msim:crti-hw.o%s} crtbegin.o%s\"\n+\n+/* Provide an ENDFILE_SPEC appropriate for svr4.  Here we tack on our own\n+   magical crtend.o file (see crtstuff.c) which provides part of the\n+   support for getting C++ file-scope static object constructed before\n+   entering `main', followed by the normal svr3/svr4 \"finalizer\" file,\n+   which is either `gcrtn.o' or `crtn.o'.  */\n+\n+#undef  ENDFILE_SPEC\n+#define ENDFILE_SPEC \"crtend.o%s crtn.o%s\"\n+\n+/* Provide a LIB_SPEC appropriate for svr4.  Here we tack on the default\n+   standard C library (unless we are building a shared library) and\n+   the simulator BSP code.  */\n+\n+#undef LIB_SPEC\n+#define LIB_SPEC \"%{!shared:%{!symbolic:-lc}} \\\n+                   %{msim:-Tsim.ld}\"\n+\n+#undef  LINK_SPEC\n+#define LINK_SPEC \"%{h*} %{v:-V} \\\n+                   %{static:-Bstatic} %{shared:-shared} %{symbolic:-Bsymbolic}\"\n+\n+/* Layout of Source Language Data Types */\n+\n+#define INT_TYPE_SIZE 32\n+#define SHORT_TYPE_SIZE 16\n+#define LONG_TYPE_SIZE 32\n+#define LONG_LONG_TYPE_SIZE 64\n+\n+#define FLOAT_TYPE_SIZE 32\n+#define DOUBLE_TYPE_SIZE 64\n+#define LONG_DOUBLE_TYPE_SIZE 64\n+\n+#define DEFAULT_SIGNED_CHAR 1\n+\n+#undef  SIZE_TYPE\n+#define SIZE_TYPE \"unsigned int\"\n+\n+#undef  PTRDIFF_TYPE\n+#define PTRDIFF_TYPE \"int\"\n+\n+#undef  WCHAR_TYPE\n+#define WCHAR_TYPE \"long int\"\n+\n+#undef  WCHAR_TYPE_SIZE\n+#define WCHAR_TYPE_SIZE BITS_PER_WORD\n+\n+#define REGISTER_NAMES {        \\\n+  \"$fp\", \"$sp\", \"$r0\", \"$r1\",   \\\n+  \"$r2\", \"$r3\", \"$r4\", \"$r5\",   \\\n+  \"$r6\", \"$r7\", \"$r8\", \"$r9\",   \\\n+  \"$r10\", \"$r11\", \"$r12\", \"$r13\",   \\\n+  \"$r14\", \"$r15\", \"$r16\", \"$r17\", \"$r18\", \"$r19\", \"$r20\", \"$r21\", \"$r22\", \"$r23\", \"$r24\", \"$r25\", \"$r26\", \"$r27\", \"$r28\", \"$cc\", \\\n+  \"?fp\", \"?ap\", \"$pc\", \"?cc\" }\n+\n+#define FT32_FP     0\n+#define FT32_SP     1\n+#define FT32_R0     2\n+#define FT32_R1     3\n+#define FT32_R2     4\n+#define FT32_R3     5\n+#define FT32_R4     6\n+#define FT32_R5     7\n+#define FT32_R6     8\n+#define FT32_R7     9\n+#define FT32_R8     10\n+#define FT32_R9     11\n+#define FT32_R10    12\n+#define FT32_R11    13\n+#define FT32_R12    14\n+#define FT32_R13    15\n+#define FT32_R14    16\n+#define FT32_R15    17\n+#define FT32_R16    18\n+#define FT32_R17    19\n+#define FT32_R18    20\n+#define FT32_R19    21\n+#define FT32_R20    22\n+#define FT32_R21    23\n+#define FT32_R22    24\n+#define FT32_R23    25\n+#define FT32_R24    26\n+#define FT32_R25    27\n+#define FT32_R26    28\n+#define FT32_R27    29\n+#define FT32_R28    30\n+#define FT32_R29    31\n+#define FT32_QAP    (32 + 1)\n+#define FT32_PC     (32 + 2)\n+#define FT32_CC     (32 + 3)\n+#define FIRST_PSEUDO_REGISTER (32 + 4)\n+\n+enum reg_class\n+{\n+  NO_REGS,\n+  GENERAL_REGS,\n+  SPECIAL_REGS,\n+  CC_REGS,\n+  ALL_REGS,\n+  LIM_REG_CLASSES\n+};\n+\n+#define REG_CLASS_CONTENTS \\\n+{ { 0x00000000, 0x00000000 }, /* Empty */                      \\\n+  { 0xFFFFFFFF, 0x00000003 }, /* $fp, $sp, $r0 to $r13, ?fp */ \\\n+  { 0x00000000, 0x00000004 }, /* $pc */                        \\\n+  { 0x00000000, 0x00000008 }, /* ?cc */                        \\\n+  { 0xFFFFFFFF, 0x0000000F }  /* All registers */              \\\n+}\n+\n+#define N_REG_CLASSES LIM_REG_CLASSES\n+\n+#define REG_CLASS_NAMES {\\\n+    \"NO_REGS\", \\\n+    \"GENERAL_REGS\", \\\n+    \"SPECIAL_REGS\", \\\n+    \"CC_REGS\", \\\n+    \"ALL_REGS\" }\n+\n+#define FIXED_REGISTERS  /*  fp  sp  r0  r1 */   { 1, 1, 0, 0, \\\n+                         /*  r2  r3  r4  r5 */     0, 0, 0, 0, \\\n+                         /*  r6  r7  r8  r9 */     0, 0, 0, 0, \\\n+                         /* r10 r11 r12 r13 */     0, 0, 0, 0, \\\n+                         /* r14 r15 r16 r17 */     0, 0, 0, 0, \\\n+                         /* r18 r19 r20 r21 */     0, 0, 0, 0, \\\n+                         /* r22 r23 r24 r25 */     0, 0, 0, 0, \\\n+                         /* r26 r27 r28 r29 */     0, 0, 1, 1, \\\n+                         /* r30 r31         */     1, 1, 1, 1 }\n+\n+#define CALL_USED_REGISTERS \\\n+                         /*  fp  sp  r0  r1 */   { 1, 1, 1, 1, \\\n+                         /*  r2  r3  r4  r5 */     1, 1, 1, 1, \\\n+                         /*  r6  r7  r8  r9 */     1, 1, 1, 1, \\\n+                         /* r10 r11 r12 r13 */     1, 1, 1, 0, \\\n+                         /* r14 r15 r16 r17 */     0, 0, 0, 0, \\\n+                         /* r18 r19 r20 r21 */     0, 0, 0, 0, \\\n+                         /* r22 r23 r24 r25 */     0, 0, 0, 0, \\\n+                         /* r26 r27 r28 r29 */     0, 0, 1, 1, \\\n+                         /* r30 r31         */     1, 1, 1, 1 }\n+\n+/* We can't copy to or from our CC register. */\n+#define AVOID_CCMODE_COPIES 1\n+\n+/* A C expression that is nonzero if it is permissible to store a\n+   value of mode MODE in hard register number REGNO (or in several\n+   registers starting with that one).  All gstore registers are\n+   equivalent, so we can set this to 1.  */\n+#define HARD_REGNO_MODE_OK(R,M) 1\n+\n+/* A C expression whose value is a register class containing hard\n+   register REGNO.  */\n+#define REGNO_REG_CLASS(R) ((R < FT32_PC) ? GENERAL_REGS :                \\\n+                            (R == FT32_CC ? CC_REGS : SPECIAL_REGS))\n+\n+/* A C expression for the number of consecutive hard registers,\n+   starting at register number REGNO, required to hold a value of mode\n+   MODE.  */\n+#define HARD_REGNO_NREGS(REGNO, MODE)                      \\\n+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1)             \\\n+   / UNITS_PER_WORD)\n+\n+/* A C expression that is nonzero if a value of mode MODE1 is\n+   accessible in mode MODE2 without copying.  */\n+#define MODES_TIEABLE_P(MODE1, MODE2) 1\n+\n+/* The Overall Framework of an Assembler File */\n+\n+#undef  ASM_SPEC\n+#define ASM_COMMENT_START \"#\"\n+#define ASM_APP_ON \"\"\n+#define ASM_APP_OFF \"\"\n+\n+#define FILE_ASM_OP     \"\\t.file\\n\"\n+\n+/* Switch to the text or data segment.  */\n+#define TEXT_SECTION_ASM_OP  \"\\t.text\"\n+#define DATA_SECTION_ASM_OP  \"\\t.data\"\n+\n+/* Assembler Commands for Alignment */\n+\n+#define ASM_OUTPUT_ALIGN(STREAM,POWER) \\\n+        fprintf (STREAM, \"\\t.p2align\\t%d\\n\", POWER);\n+\n+/* A C compound statement to output to stdio stream STREAM the\n+   assembler syntax for an instruction operand X.  */\n+#define PRINT_OPERAND(STREAM, X, CODE) ft32_print_operand (STREAM, X, CODE)\n+\n+#define PRINT_OPERAND_ADDRESS(STREAM ,X) ft32_print_operand_address (STREAM, X)\n+\n+/* Output and Generation of Labels */\n+\n+#define GLOBAL_ASM_OP \"\\t.global\\t\"\n+\n+#define JUMP_TABLES_IN_TEXT_SECTION 1\n+\n+/* This is how to output an element of a case-vector that is absolute.  */\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n+    fprintf (FILE, \"\\tjmp\\t.L%d\\n\", VALUE);\t\t\t\t\\\n+\n+/* Passing Arguments in Registers */\n+\n+/* A C type for declaring a variable that is used as the first\n+   argument of `FUNCTION_ARG' and other related values.  */\n+#define CUMULATIVE_ARGS unsigned int\n+\n+/* If defined, the maximum amount of space required for outgoing arguments\n+   will be computed and placed into the variable\n+   `current_function_outgoing_args_size'.  No space will be pushed\n+   onto the stack for each call; instead, the function prologue should\n+   increase the stack frame size by this amount.  */\n+#define ACCUMULATE_OUTGOING_ARGS 1\n+\n+/* A C statement (sans semicolon) for initializing the variable CUM\n+   for the state at the beginning of the argument list.\n+   For ft32, the first arg is passed in register 2 (aka $r0).  */\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,FNDECL,N_NAMED_ARGS) \\\n+  (CUM = FT32_R0)\n+\n+/* How Scalar Function Values Are Returned */\n+\n+/* STACK AND CALLING */\n+\n+/* Define this macro if pushing a word onto the stack moves the stack\n+   pointer to a smaller address.  */\n+#define STACK_GROWS_DOWNWARD\n+\n+#define INITIAL_FRAME_POINTER_OFFSET(DEPTH) (DEPTH) = 0\n+\n+/* Offset from the frame pointer to the first local variable slot to\n+   be allocated.  */\n+#define STARTING_FRAME_OFFSET 0\n+\n+/* Define this if the above stack space is to be considered part of the\n+   space allocated by the caller.  */\n+#define OUTGOING_REG_PARM_STACK_SPACE(FNTYPE) 1\n+/* #define STACK_PARMS_IN_REG_PARM_AREA */\n+\n+/* Define this if it is the responsibility of the caller to allocate\n+   the area reserved for arguments passed in registers.  */\n+#define REG_PARM_STACK_SPACE(FNDECL) (6 * UNITS_PER_WORD)\n+\n+/* Offset from the argument pointer register to the first argument's\n+   address.  On some machines it may depend on the data type of the\n+   function.  */\n+#define FIRST_PARM_OFFSET(F) 0\n+\n+/* Define this macro to nonzero value if the addresses of local variable slots\n+   are at negative offsets from the frame pointer.  */\n+#define FRAME_GROWS_DOWNWARD 1\n+\n+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n+   the stack pointer does not matter.  The value is tested only in\n+   functions that have frame pointers.\n+   No definition is equivalent to always zero.  */\n+\n+#define EXIT_IGNORE_STACK 0\n+\n+/* Define this macro as a C expression that is nonzero for registers that are\n+   used by the epilogue or the return pattern.  The stack and frame\n+   pointer registers are already assumed to be used as needed.  */\n+#define EPILOGUE_USES(R) (R == FT32_R5)\n+\n+/* A C expression whose value is RTL representing the location of the\n+   incoming return address at the beginning of any function, before\n+   the prologue.  */\n+#define INCOMING_RETURN_ADDR_RTX                                        \\\n+  gen_frame_mem (Pmode,                                                 \\\n+                 plus_constant (Pmode, stack_pointer_rtx, 333 * UNITS_PER_WORD))\n+\n+#define RETURN_ADDR_RTX(COUNT, FRAMEADDR)\t\t\t\t\\\n+  ((COUNT) == 0\t\t\t\t\t\t\t\t\\\n+   ? gen_rtx_MEM (Pmode, gen_rtx_PLUS (Pmode, arg_pointer_rtx, GEN_INT (-4))) \\\n+   : NULL_RTX)\n+\n+/* Describe how we implement __builtin_eh_return.  */\n+#define EH_RETURN_DATA_REGNO(N) ((N) < 4 ? (N+2) : INVALID_REGNUM)\n+\n+/* Store the return handler into the call frame.  */\n+#define EH_RETURN_HANDLER_RTX                                           \\\n+  gen_frame_mem (Pmode,                                                 \\\n+                 plus_constant (Pmode, frame_pointer_rtx, UNITS_PER_WORD))\n+\n+/* Storage Layout */\n+\n+#define BITS_BIG_ENDIAN 0\n+#define BYTES_BIG_ENDIAN 0\n+#define WORDS_BIG_ENDIAN 0\n+\n+/* Alignment required for a function entry point, in bits.  */\n+#define FUNCTION_BOUNDARY 32\n+\n+#define BRANCH_COST(speed_p, predictable_p)     2\n+\n+/* Define this macro as a C expression which is nonzero if accessing\n+   less than a word of memory (i.e. a `char' or a `short') is no\n+   faster than accessing a word of memory.  */\n+#define SLOW_BYTE_ACCESS 1\n+\n+#define STORE_FLAG_VALUE                        1\n+\n+#define MOVE_RATIO(speed) ((speed) ? 6 : 2)\n+\n+/* Number of storage units in a word; normally the size of a\n+   general-purpose register, a power of two from 1 or 8.  */\n+#define UNITS_PER_WORD 4\n+\n+/* Define this macro to the minimum alignment enforced by hardware\n+   for the stack pointer on this machine.  The definition is a C\n+   expression for the desired alignment (measured in bits).  */\n+#define STACK_BOUNDARY 32\n+\n+/* Normal alignment required for function parameters on the stack, in\n+   bits.  All stack parameters receive at least this much alignment\n+   regardless of data type.  */\n+#define PARM_BOUNDARY 32\n+\n+/* Alignment of field after `int : 0' in a structure.  */\n+#define EMPTY_FIELD_BOUNDARY  32\n+\n+/* No data type wants to be aligned rounder than this.  */\n+#define BIGGEST_ALIGNMENT 32\n+\n+/* The best alignment to use in cases where we have a choice.  */\n+#define FASTEST_ALIGNMENT 32\n+\n+/* Align definitions of arrays, unions and structures so that\n+   initializations and copies can be made more efficient.  This is not\n+   ABI-changing, so it only affects places where we can see the\n+   definition. Increasing the alignment tends to introduce padding,\n+   so don't do this when optimizing for size/conserving stack space. */\n+#define FT32_EXPAND_ALIGNMENT(COND, EXP, ALIGN)\t\t\t\t\\\n+  (((COND) && ((ALIGN) < BITS_PER_WORD)\t\t\t\t\t\\\n+    && (TREE_CODE (EXP) == ARRAY_TYPE\t\t\t\t\t\\\n+\t|| TREE_CODE (EXP) == UNION_TYPE\t\t\t\t\\\n+\t|| TREE_CODE (EXP) == RECORD_TYPE)) ? BITS_PER_WORD : (ALIGN))\n+\n+/* Make arrays of chars word-aligned for the same reasons.  */\n+#define DATA_ALIGNMENT(TYPE, ALIGN)             \\\n+  (TREE_CODE (TYPE) == ARRAY_TYPE               \\\n+   && TYPE_MODE (TREE_TYPE (TYPE)) == QImode    \\\n+   && (ALIGN) < FASTEST_ALIGNMENT ? FASTEST_ALIGNMENT : (ALIGN))\n+\n+/* Similarly, make sure that objects on the stack are sensibly aligned.  */\n+#define LOCAL_ALIGNMENT(EXP, ALIGN)\t\t\t\t\\\n+  FT32_EXPAND_ALIGNMENT(/*!flag_conserve_stack*/ 1, EXP, ALIGN)\n+\n+/* Every structures size must be a multiple of 8 bits.  */\n+#define STRUCTURE_SIZE_BOUNDARY 8\n+\n+/* Look at the fundamental type that is used for a bit-field and use\n+   that to impose alignment on the enclosing structure.\n+   struct s {int a:8}; should have same alignment as \"int\", not \"char\".  */\n+#define PCC_BITFIELD_TYPE_MATTERS       1\n+\n+/* Largest integer machine mode for structures.  If undefined, the default\n+   is GET_MODE_SIZE(DImode).  */\n+#define MAX_FIXED_MODE_SIZE 32\n+\n+/* Make strings word-aligned so strcpy from constants will be faster.  */\n+#define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n+  ((TREE_CODE (EXP) == STRING_CST       \\\n+    && (ALIGN) < FASTEST_ALIGNMENT)     \\\n+   ? FASTEST_ALIGNMENT : (ALIGN))\n+\n+/* Set this nonzero if move instructions will actually fail to work\n+   when given unaligned data.  */\n+#define STRICT_ALIGNMENT 1\n+\n+/* Generating Code for Profiling */\n+#define FUNCTION_PROFILER(FILE,LABELNO) (abort (), 0)\n+\n+/* Trampolines for Nested Functions.  */\n+#define TRAMPOLINE_SIZE (2 + 6 + 6 + 2 + 2 + 6)\n+\n+/* Alignment required for trampolines, in bits.  */\n+#define TRAMPOLINE_ALIGNMENT 32\n+\n+/* An alias for the machine mode for pointers.  */\n+#define Pmode         SImode\n+\n+#define PROMOTE_MODE(MODE, UNSIGNEDP, TYPE) \\\n+do { \\\n+  if (((MODE) == HImode) \\\n+   || ((MODE) == QImode)) \\\n+       (MODE) = SImode;  \\\n+} while (0)\n+\n+/* An alias for the machine mode used for memory references to\n+   functions being called, in `call' RTL expressions.  */\n+#define FUNCTION_MODE QImode\n+\n+#define STATIC_CHAIN_REGNUM  FT32_R28\n+\n+/* The register number of the stack pointer register, which must also\n+   be a fixed register according to `FIXED_REGISTERS'.  */\n+#define STACK_POINTER_REGNUM FT32_SP\n+\n+/* The register number of the frame pointer register, which is used to\n+   access automatic variables in the stack frame.  */\n+#define FRAME_POINTER_REGNUM FT32_FP\n+\n+/* The register number of the arg pointer register, which is used to\n+   access the function's argument list.  */\n+#define ARG_POINTER_REGNUM FT32_QAP\n+\n+#define ELIMINABLE_REGS\t\t\t\t\t\\\n+{{ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\t\\\n+ {ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM},\t\t\\\n+ {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}}\n+\n+\n+/* This macro is similar to `INITIAL_FRAME_POINTER_OFFSET'.  It\n+   specifies the initial difference between the specified pair of\n+   registers.  This macro must be defined if `ELIMINABLE_REGS' is\n+   defined.  */\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)                    \\\n+  do {                                                                  \\\n+    (OFFSET) = ft32_initial_elimination_offset ((FROM), (TO));            \\\n+  } while (0)\n+\n+/* A C expression that is nonzero if REGNO is the number of a hard\n+   register in which function arguments are sometimes passed.  */\n+#define FUNCTION_ARG_REGNO_P(r) (r >= FT32_R0 && r <= FT32_R5)\n+\n+/* A macro whose definition is the name of the class to which a valid\n+   base register must belong.  A base register is one used in an\n+   address which is the register value plus a displacement.  */\n+#define BASE_REG_CLASS GENERAL_REGS\n+\n+#define INDEX_REG_CLASS NO_REGS\n+\n+#define HARD_REGNO_OK_FOR_BASE_P(NUM) \\\n+  ((unsigned) (NUM) < FIRST_PSEUDO_REGISTER \\\n+   && (REGNO_REG_CLASS(NUM) == GENERAL_REGS \\\n+       || (NUM) == HARD_FRAME_POINTER_REGNUM))\n+\n+/* A C expression which is nonzero if register number NUM is suitable\n+   for use as a base register in operand addresses.  */\n+#ifdef REG_OK_STRICT\n+#define REGNO_OK_FOR_BASE_P(NUM)                 \\\n+  (HARD_REGNO_OK_FOR_BASE_P(NUM)                 \\\n+   || HARD_REGNO_OK_FOR_BASE_P(reg_renumber[(NUM)]))\n+#else\n+#define REGNO_OK_FOR_BASE_P(NUM)                 \\\n+  ((NUM) >= FIRST_PSEUDO_REGISTER || HARD_REGNO_OK_FOR_BASE_P(NUM))\n+#endif\n+\n+/* A C expression which is nonzero if register number NUM is suitable\n+   for use as an index register in operand addresses.  */\n+#define REGNO_OK_FOR_INDEX_P(NUM) FT32_FP\n+\n+/* The maximum number of bytes that a single instruction can move\n+   quickly between memory and registers or between two memory\n+   locations.  */\n+#define MOVE_MAX 4\n+#define TRULY_NOOP_TRUNCATION(op,ip) 1\n+\n+/* Define this to be nonzero if shift instructions ignore all but the low-order\n+   few bits.  */\n+#define SHIFT_COUNT_TRUNCATED 1\n+\n+/* All load operations zero extend.  */\n+#define LOAD_EXTEND_OP(MEM) ZERO_EXTEND\n+\n+/* A number, the maximum number of registers that can appear in a\n+   valid memory address.  */\n+#define MAX_REGS_PER_ADDRESS 1\n+\n+/* An alias for a machine mode name.  This is the machine mode that\n+   elements of a jump-table should have.  */\n+#define CASE_VECTOR_MODE SImode\n+\n+/* Run-time Target Specification */\n+\n+#define TARGET_CPU_CPP_BUILTINS() \\\n+  { \\\n+    builtin_define (\"__FT32__\");          \\\n+  }\n+\n+#define HAS_LONG_UNCOND_BRANCH true\n+\n+#define NO_FUNCTION_CSE 1\n+\n+#define ADDR_SPACE_PM 1\n+\n+#define REGISTER_TARGET_PRAGMAS() do { \\\n+  c_register_addr_space (\"__flash__\", ADDR_SPACE_PM); \\\n+} while (0);\n+\n+extern int ft32_is_mem_pm(rtx o);\n+\n+#endif /* GCC_FT32_H */"}, {"sha": "68dc683023d3cd57b807570677313186f486cb3a", "filename": "gcc/config/ft32/ft32.md", "status": "added", "additions": 932, "deletions": 0, "changes": 932, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef939d6a96bde0f924152e6b9e22701c28f8880/gcc%2Fconfig%2Fft32%2Fft32.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef939d6a96bde0f924152e6b9e22701c28f8880/gcc%2Fconfig%2Fft32%2Fft32.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fft32%2Fft32.md?ref=fef939d6a96bde0f924152e6b9e22701c28f8880", "patch": "@@ -0,0 +1,932 @@\n+;; Machine description for FT32\n+;; Copyright (C) 2015 Free Software Foundation, Inc.\n+;; Contributed by FTDI <support@ftdi.com>\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 3, or (at your\n+;; option) any later version.\n+\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+;; -------------------------------------------------------------------------\n+;; FT32 specific constraints, predicates and attributes\n+;; -------------------------------------------------------------------------\n+\n+(include \"constraints.md\")\n+(include \"predicates.md\")\n+\n+(define_constants [\n+  (FP_REG 0)\n+  (SP_REG 1)\n+  (CC_REG 35)\n+])\n+\n+(define_c_enum \"unspec\"\n+  [UNSPEC_STRLEN\n+   UNSPEC_MOVMEM\n+   UNSPEC_SETMEM\n+   UNSPEC_STPCPY\n+   UNSPEC_INDEX_JMP\n+   UNSPEC_LPM\n+   UNSPEC_FMUL\n+   UNSPEC_FMULS\n+   UNSPEC_FMULSU\n+   UNSPEC_COPYSIGN\n+   UNSPEC_IDENTITY\n+   UNSPEC_INSERT_BITS\n+   UNSPEC_JMP_EPILOG\n+   UNSPEC_JMP_EPILOG24\n+   UNSPEC_JMP_PROLOG\n+   UNSPEC_XCHG\n+   ])\n+\n+;; -------------------------------------------------------------------------\n+;; nop instruction\n+;; -------------------------------------------------------------------------\n+\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"nop\")\n+\n+;; -------------------------------------------------------------------------\n+;; Arithmetic instructions\n+;; -------------------------------------------------------------------------\n+\n+(define_insn \"addsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+          (plus:SI\n+           (match_operand:SI 1 \"register_operand\" \"r,r\")\n+           (match_operand:SI 2 \"ft32_rimm_operand\" \"KA,r\")))\n+   ]\n+  \"\"\n+  \"add.l  %0,%1,%2\")\n+\n+(define_insn \"subsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+          (minus:SI\n+           (match_operand:SI 1 \"register_operand\" \"r,r\")\n+           (match_operand:SI 2 \"ft32_rimm_operand\" \"KA,r\")))]\n+  \"\"\n+  \"sub.l  %0,%1,%2\")\n+\n+(define_insn \"mulsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+          (mult:SI\n+           (match_operand:SI 1 \"register_operand\" \"r,r\")\n+           (match_operand:SI 2 \"ft32_rimm_operand\" \"KA,r\")))]\n+  \"\"\n+  \"mul.l  %0,%1,%2\")\n+\n+(define_insn \"umulsidi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+    (mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"r,r\"))\n+         (zero_extend:DI (match_operand:SI 2 \"ft32_rimm_operand\" \"r,KA\"))))\n+   (clobber (reg:CC CC_REG))]\n+  \"\"\n+  \"mul.l  $cc,%1,%2\\;muluh.l %h0,%1,%2\\;move.l   %0,$cc\")\n+\n+(define_insn \"divsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+          (div:SI\n+           (match_operand:SI 1 \"register_operand\" \"r,r\")\n+           (match_operand:SI 2 \"ft32_rimm_operand\" \"r,KA\")))]\n+  \"\"\n+  \"div.l  %0,%1,%2\")\n+\n+(define_insn \"modsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+          (mod:SI\n+           (match_operand:SI 1 \"register_operand\" \"r,r\")\n+           (match_operand:SI 2 \"ft32_rimm_operand\" \"r,KA\")))]\n+  \"\"\n+  \"mod.l  %0,%1,%2\")\n+\n+(define_insn \"udivsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+          (udiv:SI\n+           (match_operand:SI 1 \"register_operand\" \"r,r\")\n+           (match_operand:SI 2 \"ft32_rimm_operand\" \"r,KA\")))]\n+  \"\"\n+  \"udiv.l %0,%1,%2\")\n+\n+(define_insn \"umodsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+          (umod:SI\n+           (match_operand:SI 1 \"register_operand\" \"r,r\")\n+           (match_operand:SI 2 \"register_operand\" \"r,KA\")))]\n+  \"\"\n+  \"umod.l %0,%1,%2\")\n+\n+(define_insn \"extvsi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (sign_extract:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+                      (match_operand:SI 2 \"ft32_bwidth_operand\" \"b\")\n+                      (match_operand:SI 3 \"const_int_operand\" \"i\")))]\n+  \"\"\n+  \"bexts.l %0,%1,((15 & %2) << 5) | (%3)\")\n+\n+(define_insn \"extzvsi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (zero_extract:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+                      (match_operand:SI 2 \"ft32_bwidth_operand\" \"b\")\n+                      (match_operand:SI 3 \"const_int_operand\" \"i\")))]\n+  \"\"\n+  \"bextu.l %0,%1,((15 & %2) << 5) | (%3)\")\n+\n+(define_insn \"insvsi\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"+r,r\")\n+                         (match_operand:SI 1 \"ft32_bwidth_operand\" \"b,b\")\n+                         (match_operand:SI 2 \"const_int_operand\" \"i,i\"))\n+        (match_operand:SI 3 \"general_operand\" \"r,O\"))\n+   (clobber (match_scratch:SI 4 \"=&r,r\"))]\n+  \"\"\n+  {\n+    if (which_alternative == 0)\n+      {\n+        return \\\"ldl.l %4,%3,((%1&15)<<5)|(%2)\\;bins.l %0,%0,%4\\\";\n+      }\n+    else\n+      {\n+        if ((INTVAL(operands[3]) == 0) || (INTVAL(operands[1]) == 1))\n+          return \\\"bins.l %0,%0,(%3<<9)|((%1&15)<<5)|(%2)\\\";\n+        else\n+          return \\\"ldk.l %4,(%3<<10)|((%1&15)<<5)|(%2)\\;bins.l %0,%0,%4\\\";\n+      }\n+  })\n+\n+;; -------------------------------------------------------------------------\n+;; Unary arithmetic instructions\n+;; -------------------------------------------------------------------------\n+\n+(define_insn \"one_cmplsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (not:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"xor.l    %0,%1,-1\")\n+\n+;; -------------------------------------------------------------------------\n+;; Logical operators\n+;; -------------------------------------------------------------------------\n+\n+(define_insn \"andsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n+        (and:SI (match_operand:SI 1 \"register_operand\" \"r,r,r\")\n+                (match_operand:SI 2 \"general_operand\"  \"r,x,KA\")))]\n+  \"\"\n+  \"@\n+  and.l  %0,%1,%2\n+  bins.l %0,%1,%g2\n+  and.l  %0,%1,%2\")\n+\n+(define_insn \"andqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r,r,r\")\n+        (and:QI (match_operand:QI 1 \"register_operand\" \"r,r,r\")\n+                (match_operand:QI 2 \"general_operand\"  \"r,x,KA\")))]\n+  \"\"\n+  \"@\n+  and.b  %0,%1,%2\n+  bins.b %0,%1,%g2\n+  and.b  %0,%1,%2\")\n+\n+(define_insn \"xorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+        (xor:SI (match_operand:SI 1 \"register_operand\" \"r,r\")\n+                (match_operand:SI 2 \"ft32_rimm_operand\" \"r,KA\")))]\n+  \"\"\n+{\n+  return \"xor.l  %0,%1,%2\";\n+})\n+\n+(define_insn \"iorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n+        (ior:SI (match_operand:SI 1 \"register_operand\" \"r,r,r\")\n+                (match_operand:SI 2 \"general_operand\"  \"r,w,KA\")))]\n+  \"\"\n+  \"@\n+  or.l   %0,%1,%2\n+  bins.l %0,%1,%f2\n+  or.l   %0,%1,%2\")\n+\n+;; -------------------------------------------------------------------------\n+;; Shifters\n+;; -------------------------------------------------------------------------\n+\n+(define_insn \"ashlsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+        (ashift:SI (match_operand:SI 1 \"register_operand\" \"r,r\")\n+                   (match_operand:SI 2 \"ft32_rimm_operand\" \"r,KA\")))]\n+  \"\"\n+{\n+  return \"ashl.l %0,%1,%2\";\n+})\n+\n+(define_insn \"ashrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+        (ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"r,r\")\n+                     (match_operand:SI 2 \"ft32_rimm_operand\" \"r,KA\")))]\n+  \"\"\n+{\n+  return \"ashr.l %0,%1,%2\";\n+})\n+\n+(define_insn \"lshrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+        (lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"r,r\")\n+                     (match_operand:SI 2 \"ft32_rimm_operand\" \"r,KA\")))]\n+  \"\"\n+{\n+  return \"lshr.l %0,%1,%2\";\n+})\n+\n+;; -------------------------------------------------------------------------\n+;; Move instructions\n+;; -------------------------------------------------------------------------\n+\n+;; SImode\n+\n+;; Push a register onto the stack\n+(define_insn \"movsi_push\"\n+  [(set (mem:SI (pre_dec:SI (reg:SI SP_REG)))\n+        (match_operand:SI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"push.l %0\")\n+\n+;; Pop a register from the stack\n+(define_insn \"movsi_pop\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (mem:SI (post_inc:SI (reg:SI SP_REG))))]\n+  \"\"\n+  \"pop.l  %0\")\n+\n+(define_expand \"movsi\"\n+   [(set (match_operand:SI 0 \"general_operand\" \"\")\n+        (match_operand:SI 1 \"general_operand\" \"\"))]\n+   \"\"\n+{\n+  /* If this is a store, force the value into a register.  */\n+  if (!(reload_in_progress || reload_completed))\n+    {\n+      if (MEM_P (operands[0]))\n+        {\n+          operands[1] = force_reg (SImode, operands[1]);\n+          if (MEM_P (XEXP (operands[0], 0)))\n+            operands[0] = gen_rtx_MEM (SImode, force_reg (SImode, XEXP (operands[0], 0)));\n+        }\n+      else\n+        {\n+          if (MEM_P (operands[1]) && MEM_P (XEXP (operands[1], 0)))\n+            operands[1] = gen_rtx_MEM (SImode, force_reg (SImode, XEXP (operands[1], 0)));\n+        }\n+      /*\n+      if (MEM_P (operands[0])) {\n+        rtx o = XEXP (operands[0], 0);\n+        if (!REG_P(o) &&\n+            !CONST_INT_P(o) &&\n+            GET_CODE(o) != SYMBOL_REF &&\n+            GET_CODE(o) != LABEL_REF) {\n+          operands[0] = gen_rtx_MEM (SImode, force_reg (SImode, XEXP (operands[0], 0)));\n+        }\n+      }\n+      */\n+    }\n+})\n+\n+(define_insn \"*rtestsi\"\n+  [(set (reg:SI CC_REG)\n+        (match_operand:SI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"cmp.l  %0,0\"\n+)\n+\n+(define_insn \"*rtestqi\"\n+  [(set (reg:QI CC_REG)\n+        (match_operand:QI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"cmp.b  %0,0\"\n+)\n+\n+(define_insn \"*movsi\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\"         \"=r,BW,r,r,r,r,A,r,r\")\n+        (match_operand:SI 1 \"ft32_general_movsrc_operand\"   \"r,r,BW,A,S,i,r,e,f\"))]\n+  \"register_operand (operands[0], SImode) || register_operand (operands[1], SImode)\"\n+  \"@\n+   move.l %0,%1\n+   sti.l  %0,%1\n+   ldi.l  %0,%1\n+   lda.l  %0,%1\n+   ldk.l  %0,%1\n+   *return ft32_load_immediate(operands[0], INTVAL(operands[1]));\n+   sta.l  %0,%1\n+   lpm.l  %0,%1\n+   lpmi.l %0,%1\"\n+)\n+\n+(define_expand \"movqi\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"\")\n+        (match_operand:QI 1 \"general_operand\" \"\"))]\n+  \"\"\n+{\n+  /* If this is a store, force the value into a register.  */\n+  if (!(reload_in_progress || reload_completed))\n+    {\n+      if (MEM_P (operands[0]))\n+        {\n+          operands[1] = force_reg (QImode, operands[1]);\n+          if (MEM_P (XEXP (operands[0], 0)))\n+            operands[0] = gen_rtx_MEM (QImode, force_reg (SImode, XEXP (operands[0], 0)));\n+        }\n+      else\n+        {\n+          if (MEM_P (operands[1]) && MEM_P (XEXP (operands[1], 0)))\n+            operands[1] = gen_rtx_MEM (QImode, force_reg (SImode, XEXP (operands[1], 0)));\n+        }\n+      if (MEM_P (operands[0]) && !REG_P(XEXP (operands[0], 0)))\n+        {\n+          operands[0] = gen_rtx_MEM (QImode, force_reg (SImode, XEXP (operands[0], 0)));\n+        }\n+    }\n+})\n+\n+(define_insn \"zero_extendqisi2\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r\")\n+    (zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"BW,r,f\")))]\n+  \"\"\n+  \"@\n+  ldi.b  %0,%1\n+  and.l  %0,%1,255\n+  lpmi.b %0,%1\"\n+)\n+\n+(define_insn \"extendqisi2\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r\")\n+    (sign_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"r\")))]\n+  \"\"\n+  \"bexts.l %0,%1,(8<<5)|0\"\n+)\n+\n+(define_insn \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r\")\n+    (zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"BW,r,f\")))]\n+  \"\"\n+  \"@\n+  ldi.s  %0,%1\n+  bextu.l %0,%1,(0<<5)|0\n+  lpmi.s %0,%1\"\n+)\n+\n+(define_insn \"extendhisi2\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r\")\n+    (sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"r\")))]\n+  \"\"\n+  \"bexts.l %0,%1,(0<<5)|0\"\n+)\n+\n+(define_insn \"*movqi\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\"           \"=r,BW,r,r,A,r,r,r\")\n+        (match_operand:QI 1 \"ft32_general_movsrc_operand\"  \"r,r,BW,A,r,I,e,f\"))]\n+  \"register_operand (operands[0], QImode)\n+   || register_operand (operands[1], QImode)\"\n+  \"@\n+   move.b %0,%1\n+   sti.b  %0,%1\n+   ldi.b  %0,%1\n+   lda.b  %0,%1\n+   sta.b  %0,%1\n+   ldk.b  %0,%1\n+   lpm.b  %0,%1\n+   lpmi.b %0,%1\"\n+)\n+\n+(define_expand \"movhi\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"\")\n+        (match_operand:HI 1 \"general_operand\" \"\"))]\n+  \"\"\n+{\n+  /* If this is a store, force the value into a register.  */\n+  if (!(reload_in_progress || reload_completed))\n+    {\n+      if (MEM_P (operands[0]))\n+        {\n+          operands[1] = force_reg (HImode, operands[1]);\n+          if (MEM_P (XEXP (operands[0], 0)))\n+            operands[0] = gen_rtx_MEM (HImode, force_reg (SImode, XEXP (operands[0], 0)));\n+        }\n+      else\n+        {\n+          if (MEM_P (operands[1]) && MEM_P (XEXP (operands[1], 0)))\n+            operands[1] = gen_rtx_MEM (HImode, force_reg (SImode, XEXP (operands[1], 0)));\n+        }\n+      if (MEM_P (operands[0]))\n+        {\n+          rtx o = XEXP (operands[0], 0);\n+          if (!REG_P(o) &&\n+              !CONST_INT_P(o) &&\n+              GET_CODE(o) != SYMBOL_REF &&\n+              GET_CODE(o) != LABEL_REF) {\n+            operands[0] = gen_rtx_MEM (HImode, force_reg (SImode, XEXP (operands[0], 0)));\n+          }\n+        }\n+    }\n+})\n+\n+(define_insn \"*movhi\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,BW,r,r,A,r,r,r\")\n+        (match_operand:HI 1 \"ft32_general_movsrc_operand\"  \"r,r,BW,A,r,I,e,f\"))]\n+  \"(register_operand (operands[0], HImode)\n+    || register_operand (operands[1], HImode))\"\n+  \"@\n+   move.s %0,%1\n+   sti.s  %0,%1\n+   ldi.s  %0,%1\n+   lda.s  %0,%1\n+   sta.s  %0,%1\n+   ldk.s  %0,%1\n+   lpm.s  %0,%1\n+   lpmi.s %0,%1\"\n+)\n+\n+(define_expand \"movsf\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"\")\n+        (match_operand:SF 1 \"general_operand\" \"\"))]\n+  \"\"\n+{\n+  /* If this is a store, force the value into a register.  */\n+  if (MEM_P (operands[0]))\n+    operands[1] = force_reg (SFmode, operands[1]);\n+  if (CONST_DOUBLE_P(operands[1]))\n+    operands[1] = force_const_mem(SFmode, operands[1]);\n+})\n+\n+(define_insn \"*movsf\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=r,BW,r,r,A,r,r\")\n+        (match_operand:SF 1 \"ft32_general_movsrc_operand\"  \"r,r,BW,A,r,I,f\"))]\n+  \"(register_operand (operands[0], SFmode)\n+    || register_operand (operands[1], SFmode))\"\n+  \"@\n+   move.l %0,%1\n+   sti.l  %0,%1\n+   ldi.l  %0,%1\n+   lda.l  %0,%1\n+   sta.l  %0,%1\n+   ldk.l  %0,%1\n+   lpmi.l %0,%1\"\n+)\n+\n+;; -------------------------------------------------------------------------\n+;; Compare instructions\n+;; -------------------------------------------------------------------------\n+\n+(define_expand \"cbranchsi4\"\n+  [(set (reg:CC CC_REG)\n+        (compare:CC\n+         (match_operand:SI 1 \"register_operand\" \"\")\n+         (match_operand:SI 2 \"ft32_rimm_operand\" \"\")))\n+   (set (pc)\n+        (if_then_else (match_operator 0 \"comparison_operator\"\n+                       [(reg:CC CC_REG) (const_int 0)])\n+                      (label_ref (match_operand 3 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"cmpsi\"\n+  [(set (reg:CC CC_REG)\n+        (compare:CC\n+         (match_operand:SI 0 \"register_operand\" \"r,r\")\n+         (match_operand:SI 1 \"ft32_rimm_operand\" \"r,KA\")))]\n+  \"\"\n+  \"cmp.l  %0,%1\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (ne (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t      (const_int 1)\n+\t\t\t      (match_operand:SI 1 \"const_int_operand\" \"i\"))\n+\t     (const_int 0))\n+\t (label_ref (match_operand 2 \"\" \"\"))\n+\t (pc)))\n+   (clobber (reg:CC CC_REG))]\n+  \"\"\n+  \"btst.l %0,(1<<5)|%1\\;jmpc   nz,%l2\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (eq (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t      (const_int 1)\n+\t\t\t      (match_operand:SI 1 \"const_int_operand\" \"i\"))\n+\t     (const_int 0))\n+\t (label_ref (match_operand 2 \"\" \"\"))\n+\t (pc)))\n+   (clobber (reg:CC CC_REG))]\n+  \"\"\n+  \"btst.l %0,(1<<5)|%1\\;jmpc   z,%l2\")\n+\n+(define_expand \"cbranchqi4\"\n+  [(set (reg:CC CC_REG)\n+        (compare:CC\n+         (match_operand:QI 1 \"register_operand\" \"\")\n+         (match_operand:QI 2 \"ft32_rimm_operand\" \"\")))\n+   (set (pc)\n+        (if_then_else (match_operator 0 \"comparison_operator\"\n+                       [(reg:CC CC_REG) (const_int 0)])\n+                      (label_ref (match_operand 3 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*cmpqi\"\n+  [(set (reg:CC CC_REG)\n+        (compare:CC\n+         (match_operand:QI 0 \"register_operand\" \"r,r\")\n+         (match_operand:QI 1 \"ft32_rimm_operand\" \"r,KA\")))]\n+  \"\"\n+  \"cmp.b  %0,%1\")\n+\n+;; -------------------------------------------------------------------------\n+;; Branch instructions\n+;; -------------------------------------------------------------------------\n+\n+(define_code_iterator cond [ne eq lt ltu gt gtu ge le geu leu])\n+(define_code_attr CC [(ne \"nz\") (eq \"z\") (lt \"lt\") (ltu \"b\")\n+                      (gt \"gt\") (gtu \"a\") (ge \"gte\") (le \"lte\")\n+                      (geu \"ae\") (leu \"be\") ])\n+(define_code_attr rCC [(ne \"z\") (eq \"nz\") (lt \"gte\") (ltu \"ae\")\n+                       (gt \"lte\") (gtu \"be\") (ge \"lt\") (le \"gt\")\n+                       (geu \"b\") (leu \"a\") ])\n+\n+(define_insn \"*b<cond:code>\"\n+  [(set (pc)\n+        (if_then_else (cond (reg:CC CC_REG)\n+                            (const_int 0))\n+                      (label_ref (match_operand 0 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+{\n+  return \"jmpc   <CC>,%l0\";\n+}\n+)\n+\n+(define_expand \"cstoresi4\"\n+  [(set (reg:CC CC_REG)\n+ \t(compare:CC (match_operand:SI 2 \"register_operand\" \"r,r\")\n+ \t\t    (match_operand:SI 3 \"ft32_rimm_operand\" \"r,KA\")))\n+   (set (match_operand:SI 0 \"register_operand\")\n+\t(match_operator:SI 1 \"ordered_comparison_operator\"\n+\t[(reg:CC CC_REG) (const_int 0)]))]\n+  \"\"\n+{\n+  rtx test;\n+\n+  switch (GET_CODE (operands[1])) {\n+  case NE:\n+  case GEU:\n+  case LT:\n+  case LE:\n+  case LEU:\n+    test = gen_rtx_fmt_ee (reverse_condition (GET_CODE (operands[1])),\n+       \t\t     SImode, operands[2], operands[3]);\n+    emit_insn(gen_cstoresi4(operands[0], test, operands[2], operands[3]));\n+    emit_insn(gen_xorsi3(operands[0], operands[0], gen_int_mode(1, SImode)));\n+    DONE;\n+  default:\n+    ;\n+  }\n+})\n+\n+(define_insn \"*seq\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (eq:SI (reg CC_REG) (const_int 0)))]\n+  \"\"\n+  \"bextu.l %0,$cc,32|0\"\n+)\n+\n+(define_insn \"*sltu\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (ltu:SI (reg CC_REG) (const_int 0)))]\n+  \"\"\n+  \"bextu.l %0,$cc,32|1\"\n+)\n+\n+(define_insn \"*sge\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (ge:SI (reg CC_REG) (const_int 0)))]\n+  \"\"\n+  \"bextu.l %0,$cc,32|4\"\n+)\n+\n+(define_insn \"*sgt\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (gt:SI (reg CC_REG) (const_int 0)))]\n+  \"\"\n+  \"bextu.l %0,$cc,32|5\"\n+)\n+\n+(define_insn \"*sgtu\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (gtu:SI (reg CC_REG) (const_int 0)))]\n+  \"\"\n+  \"bextu.l %0,$cc,32|6\"\n+)\n+\n+;; -------------------------------------------------------------------------\n+;; Call and Jump instructions\n+;; -------------------------------------------------------------------------\n+\n+(define_expand \"call\"\n+  [(call (match_operand:QI 0 \"memory_operand\" \"\")\n+                (match_operand 1 \"general_operand\" \"\"))]\n+  \"\"\n+{\n+  gcc_assert (MEM_P (operands[0]));\n+})\n+\n+(define_insn \"*call\"\n+  [(call (mem:QI (match_operand:SI\n+                  0 \"nonmemory_operand\" \"i,r\"))\n+         (match_operand 1 \"\" \"\"))]\n+  \"\"\n+  \"@\n+   call   %0\n+   calli  %0\"\n+)\n+\n+(define_expand \"call_value\"\n+  [(set (match_operand 0 \"\" \"\")\n+                (call (match_operand:QI 1 \"memory_operand\" \"\")\n+                 (match_operand 2 \"\" \"\")))]\n+  \"\"\n+{\n+  gcc_assert (MEM_P (operands[1]));\n+})\n+\n+(define_insn \"*call_value\"\n+  [(set (match_operand 0 \"register_operand\" \"=r\")\n+        (call (mem:QI (match_operand:SI\n+                       1 \"immediate_operand\" \"i\"))\n+              (match_operand 2 \"\" \"\")))]\n+  \"\"\n+  \"call   %1\"\n+)\n+\n+(define_insn \"*call_value_indirect\"\n+  [(set (match_operand 0 \"register_operand\" \"=r\")\n+        (call (mem:QI (match_operand:SI\n+                       1 \"register_operand\" \"r\"))\n+              (match_operand 2 \"\" \"\")))]\n+  \"\"\n+  \"calli  %1\"\n+)\n+\n+(define_insn \"indirect_jump\"\n+  [(set (pc) (match_operand:SI 0 \"nonimmediate_operand\" \"r\"))]\n+  \"\"\n+  \"jmpi   %0\")\n+\n+(define_insn \"jump\"\n+  [(set (pc)\n+        (label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"jmp    %l0\"\n+)\n+\n+(define_insn \"call_prolog\"\n+  [(unspec:SI [(match_operand 0 \"\" \"\")]\n+                   UNSPEC_JMP_PROLOG)]\n+  \"\"\n+  \"call   __prolog_%0\"\n+)\n+\n+(define_insn \"jump_epilog\"\n+  [(unspec:SI [(match_operand 0 \"\" \"\")]\n+                   UNSPEC_JMP_EPILOG)]\n+  \"\"\n+  \"jmp    __epilog_%0\"\n+)\n+\n+(define_insn \"jump_epilog24\"\n+  [(unspec:SI [(match_operand 0 \"\" \"\")]\n+                   UNSPEC_JMP_EPILOG24)]\n+  \"\"\n+  \"jmp    __epilog24_%0\"\n+)\n+\n+\n+;; Subroutines of \"casesi\".\n+;; operand 0 is index\n+;; operand 1 is the minimum bound\n+;; operand 2 is the maximum bound - minimum bound + 1\n+;; operand 3 is CODE_LABEL for the table;\n+;; operand 4 is the CODE_LABEL to go to if index out of range.\n+\n+(define_expand \"casesi\"\n+  [(match_operand:SI 0 \"general_operand\" \"\")\n+   (match_operand:SI 1 \"const_int_operand\" \"\")\n+   (match_operand:SI 2 \"const_int_operand\" \"\")\n+   (match_operand 3 \"\" \"\")\n+   (match_operand 4 \"\" \"\")]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[0]) != REG)\n+    operands[0] = force_reg (SImode, operands[0]);\n+\n+  if (operands[1] != const0_rtx)\n+    {\n+      rtx index = gen_reg_rtx (SImode);\n+      rtx offset = gen_reg_rtx (SImode);\n+\n+      emit_insn (gen_movsi (offset, operands[1]));\n+      emit_insn (gen_subsi3 (index, operands[0], offset));\n+      operands[0] = index;\n+    }\n+\n+  {\n+    rtx test = gen_rtx_GTU (VOIDmode, operands[0], operands[2]);\n+    emit_jump_insn (gen_cbranchsi4 (test, operands[0], operands[2], operands[4]));\n+  }\n+\n+  emit_jump_insn (gen_casesi0 (operands[0], operands[3]));\n+  DONE;\n+}\")\n+\n+(define_insn \"casesi0\"\n+  [(set (pc) (mem:SI (plus:SI\n+\t\t       (mult:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t\t(const_int 4))\n+\t\t       (label_ref (match_operand 1 \"\" \"\")))))\n+   (clobber (match_scratch:SI 2 \"=&r\"))\n+  ]\n+  \"\"\n+  \"ldk.l\\t$cc,%l1\\;ashl.l\\t%2,%0,2\\;add.l\\t%2,%2,$cc\\;jmpi\\t%2\"\n+  )\n+\n+;; -------------------------------------------------------------------------\n+;; Atomic exchange instruction\n+;; -------------------------------------------------------------------------\n+\n+(define_insn \"atomic_exchangesi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&r,r\")\t;; output\n+\t(match_operand:SI 1 \"memory_operand\" \"+BW,A\"))\t;; memory\n+   (set (match_dup 1)\n+\t(unspec:SI\n+\t  [(match_operand:SI 2 \"register_operand\" \"0,0\")\t;; input\n+\t   (match_operand:SI 3 \"const_int_operand\")]\t\t;; model\n+\t  UNSPEC_XCHG))]\n+  \"\"\n+  \"@\n+   exi.l  %0,%1\n+   exa.l  %0,%1\")\n+\n+(define_insn \"atomic_exchangehi\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=&r,r\")\t;; output\n+\t(match_operand:HI 1 \"memory_operand\" \"+BW,A\"))\t;; memory\n+   (set (match_dup 1)\n+\t(unspec:HI\n+\t  [(match_operand:HI 2 \"register_operand\" \"0,0\")\t;; input\n+\t   (match_operand:HI 3 \"const_int_operand\")]\t\t;; model\n+\t  UNSPEC_XCHG))]\n+  \"\"\n+  \"@\n+   exi.s  %0,%1\n+   exa.s  %0,%1\")\n+\n+(define_insn \"atomic_exchangeqi\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=&r,r\")\t;; output\n+\t(match_operand:QI 1 \"memory_operand\" \"+BW,A\"))\t;; memory\n+   (set (match_dup 1)\n+\t(unspec:QI\n+\t  [(match_operand:QI 2 \"register_operand\" \"0,0\")\t;; input\n+\t   (match_operand:QI 3 \"const_int_operand\")]\t\t;; model\n+\t  UNSPEC_XCHG))]\n+  \"\"\n+  \"@\n+   exi.b  %0,%1\n+   exa.b  %0,%1\")\n+\n+;; -------------------------------------------------------------------------\n+;; String instructions\n+;; -------------------------------------------------------------------------\n+\n+(define_insn \"cmpstrsi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+        (compare:SI (match_operand:BLK 1 \"memory_operand\" \"W,BW\")\n+                    (match_operand:BLK 2 \"memory_operand\" \"W,BW\")))\n+   (clobber (match_operand:SI 3))\n+   ]\n+  \"\"\n+  \"strcmp.%d3 %0,%b1,%b2\"\n+)\n+\n+(define_insn \"movstr\"\n+[(set (match_operand:BLK 1 \"memory_operand\" \"=W\")\n+      (match_operand:BLK 2 \"memory_operand\" \"W\"))\n+      (use (match_operand:SI 0))\n+      (clobber (match_dup 0))\n+ ]\n+\"0\"\n+\"stpcpy %b1,%b2 # %0 %b1 %b2\"\n+)\n+\n+(define_insn \"movmemsi\"\n+  [(set (match_operand:BLK 0 \"memory_operand\" \"=W,W,BW\")\n+        (match_operand:BLK 1 \"memory_operand\" \"W,W,BW\"))\n+        (use (match_operand:SI 2 \"ft32_rimm_operand\" \"r,KA,rKA\"))\n+        (use (match_operand:SI 3))\n+   ]\n+  \"\"\n+  \"memcpy.%d3 %b0,%b1,%2 # %3!\"\n+)\n+\n+(define_insn \"setmemsi\"\n+  [(set (match_operand:BLK 0 \"memory_operand\" \"=BW,BW\") (unspec:BLK [\n+     (use (match_operand:QI 2 \"register_operand\" \"r,r\"))\n+     (use (match_operand:SI 1 \"ft32_rimm_operand\" \"r,KA\"))\n+   ] UNSPEC_SETMEM))\n+   (use (match_operand:SI 3))\n+   ]\n+  \"\"\n+  \"memset.%d3 %b0,%2,%1\"\n+)\n+\n+(define_insn \"strlensi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (unspec:SI [(match_operand:BLK 1 \"memory_operand\" \"W\")\n+                    (match_operand:QI 2 \"const_int_operand\" \"\")\n+                    (match_operand:SI 3 \"ft32_rimm_operand\" \"\")]\n+                   UNSPEC_STRLEN))]\n+  \"\"\n+  \"strlen.%d3 %0,%b1 # %2 %3\"\n+)\n+\n+;; -------------------------------------------------------------------------\n+;; Prologue & Epilogue\n+;; -------------------------------------------------------------------------\n+\n+(define_expand \"prologue\"\n+  [(clobber (const_int 0))]\n+  \"\"\n+{\n+  extern void ft32_expand_prologue();\n+  ft32_expand_prologue ();\n+  DONE;\n+})\n+\n+(define_expand \"epilogue\"\n+  [(return)]\n+  \"\"\n+{\n+  extern void ft32_expand_epilogue();\n+  ft32_expand_epilogue ();\n+  DONE;\n+})\n+\n+(define_insn \"link\"\n+  [\n+;;   (set (mem:SI (pre_dec:SI (reg:SI SP_REG)))\n+;;        (reg:SI FP_REG))\n+   (set (match_operand:SI 0)\n+        (reg:SI SP_REG))\n+   (set (reg:SI SP_REG)\n+        (plus:SI (reg:SI SP_REG)\n+                 (match_operand:SI 1 \"general_operand\" \"L\")))]\n+  \"\"\n+  \"link   %0,%m1\"\n+)\n+\n+(define_insn \"unlink\"\n+  [(set (reg:SI FP_REG)\n+        (mem:SI (reg:SI FP_REG)))\n+   (set (reg:SI SP_REG)\n+        (plus:SI (reg:SI FP_REG)\n+                 (const_int 4)))]\n+  \"\"\n+  \"unlink $r29\"\n+)\n+\n+(define_insn \"returner\"\n+  [(return)]\n+  \"reload_completed\"\n+  \"return\")\n+\n+(define_insn \"returner24\"\n+  [\n+  (set (reg:SI SP_REG)\n+          (plus:SI\n+           (reg:SI SP_REG)\n+           (const_int 24)))\n+  (return)]\n+  \"\"\n+  \"jmp    __epilog24\")"}, {"sha": "00816ec6a5a5d6b3242b9823e13aa71e3d7b1799", "filename": "gcc/config/ft32/ft32.opt", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef939d6a96bde0f924152e6b9e22701c28f8880/gcc%2Fconfig%2Fft32%2Fft32.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef939d6a96bde0f924152e6b9e22701c28f8880/gcc%2Fconfig%2Fft32%2Fft32.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fft32%2Fft32.opt?ref=fef939d6a96bde0f924152e6b9e22701c28f8880", "patch": "@@ -0,0 +1,27 @@\n+; Options for the FT32 port of the compiler.\n+\n+; Copyright (C) 2015 Free Software Foundation, Inc.\n+;\n+; This file is part of GCC.\n+;\n+; GCC is free software; you can redistribute it and/or modify it under\n+; the terms of the GNU General Public License as published by the Free\n+; Software Foundation; either version 3, or (at your option) any later\n+; version.\n+;\n+; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+; for more details.\n+;\n+; You should have received a copy of the GNU General Public License\n+; along with GCC; see the file COPYING3.  If not see\n+; <http://www.gnu.org/licenses/>.\n+\n+msim\n+Target Report Mask(SIM)\n+target the software simulator\n+\n+mlra\n+Target Report Var(ft32_lra_flag) Init(0) Save\n+Use LRA instead of reload"}, {"sha": "ac800ae03f077167afb5cf6aaa36e3f92890dec6", "filename": "gcc/config/ft32/predicates.md", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef939d6a96bde0f924152e6b9e22701c28f8880/gcc%2Fconfig%2Fft32%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef939d6a96bde0f924152e6b9e22701c28f8880/gcc%2Fconfig%2Fft32%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fft32%2Fpredicates.md?ref=fef939d6a96bde0f924152e6b9e22701c28f8880", "patch": "@@ -0,0 +1,85 @@\n+;; Predicate definitions for FT32\n+;; Copyright (C) 2015 Free Software Foundation, Inc.\n+;; Contributed by FTDI <support@ftdi.com>\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 3, or (at your\n+;; option) any later version.\n+\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+;; -------------------------------------------------------------------------\n+;; Predicates\n+;; -------------------------------------------------------------------------\n+\n+;; Nonzero if OP can be source of a simple move operation.\n+\n+(define_predicate \"ft32_general_movsrc_operand\"\n+  (match_code \"mem,const_int,reg,subreg,symbol_ref,label_ref,const\")\n+{\n+  /* Any (MEM LABEL_REF) is OK.  That is a pc-relative load.  */\n+  if (MEM_P (op) && GET_CODE (XEXP (op, 0)) == LABEL_REF)\n+    return 1;\n+\n+  if (MEM_P (op)\n+      && GET_CODE (XEXP (op, 0)) == PLUS\n+      && GET_CODE (XEXP (XEXP (op, 0), 0)) == REG\n+      && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST)\n+    return 1;\n+\n+  return general_operand (op, mode);\n+})\n+\n+(define_predicate \"ft32_general_movdst_operand\"\n+  (match_code \"mem,const_int,reg,subreg,symbol_ref,label_ref,const\")\n+{\n+  if (MEM_P (op)\n+      && GET_CODE (XEXP (op, 0)) == PLUS\n+      && GET_CODE (XEXP (XEXP (op, 0), 0)) == REG\n+      && CONST_INT_P (XEXP (XEXP (op, 0), 1)))\n+    return 1;\n+  if (MEM_P (op) && GET_CODE (XEXP (op, 0)) == SYMBOL_REF)\n+    return 1;\n+  return REG_P(op) ||\n+         (MEM_P(op) && REG_P(XEXP (op, 0)));\n+})\n+\n+(define_predicate \"reg_indirect\"\n+  (match_code \"mem\")\n+{\n+  return (MEM_P(op) && REG_P(XEXP (op, 0)));\n+})\n+\n+;; Nonzero if OP can be an operand to an add/inc/dec instruction.\n+\n+(define_predicate \"ft32_add_operand\"\n+  (ior (match_code \"reg\")\n+       (and (match_code \"const_int\")\n+            (match_test \"IN_RANGE (INTVAL (op), -32768, 32767)\"))))\n+\n+;; Nonzero if OP can be an operand to an sub/dec instruction.\n+\n+(define_predicate \"ft32_sub_operand\"\n+  (ior (match_code \"reg\")\n+       (and (match_code \"const_int\")\n+            (match_test \"IN_RANGE (INTVAL (op), -32767, 32768)\"))))\n+\n+\n+(define_predicate \"ft32_rimm_operand\"\n+  (ior (match_code \"reg\")\n+       (and (match_code \"const_int\")\n+            (match_test \"IN_RANGE (INTVAL (op), -512, 511)\"))))\n+\n+(define_predicate \"ft32_bwidth_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (INTVAL (op), 1, 16)\")))"}, {"sha": "937631300686711f2623b41c3ad6d0f183809950", "filename": "gcc/config/ft32/t-ft32", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef939d6a96bde0f924152e6b9e22701c28f8880/gcc%2Fconfig%2Fft32%2Ft-ft32", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef939d6a96bde0f924152e6b9e22701c28f8880/gcc%2Fconfig%2Fft32%2Ft-ft32", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fft32%2Ft-ft32?ref=fef939d6a96bde0f924152e6b9e22701c28f8880", "patch": "@@ -0,0 +1,19 @@\n+# Target Makefile Fragment for ft32\n+# Copyright (C) 2015  Free Software Foundation, Inc.\n+# Contributed by FTDI <support@ftdi.com>\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published\n+# by the Free Software Foundation; either version 3, or (at your\n+# option) any later version.\n+#\n+# GCC is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+# License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>."}, {"sha": "82dadac2719e95eaca8719222cabe3882dc97e84", "filename": "gcc/doc/contrib.texi", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef939d6a96bde0f924152e6b9e22701c28f8880/gcc%2Fdoc%2Fcontrib.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef939d6a96bde0f924152e6b9e22701c28f8880/gcc%2Fdoc%2Fcontrib.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcontrib.texi?ref=fef939d6a96bde0f924152e6b9e22701c28f8880", "patch": "@@ -112,6 +112,9 @@ Devon Bowen helped port GCC to the Tahoe.\n @item\n Don Bowman for mips-vxworks contributions.\n \n+@item\n+James Bowman for the FT32 port.\n+\n @item\n Dave Brolley for work on cpplib and Chill.\n "}, {"sha": "04332c1ae376182595a891f8e3a72d5f0a4e6ecb", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef939d6a96bde0f924152e6b9e22701c28f8880/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef939d6a96bde0f924152e6b9e22701c28f8880/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=fef939d6a96bde0f924152e6b9e22701c28f8880", "patch": "@@ -3662,6 +3662,14 @@ results.  However, it is currently known that boehm-gc (which itself\n is required for java) may not configure properly on FreeBSD prior to\n the FreeBSD 7.0 release with GNU binutils after 2.16.1.\n \n+@html\n+<hr />\n+@end html\n+@anchor{ft32-x-elf}\n+@heading ft32-*-elf\n+The FT32 processor.\n+This configuration is intended for embedded systems.\n+\n @html\n <hr />\n @end html"}, {"sha": "14e762c6360b0db455bc2061c299e006131d0af4", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef939d6a96bde0f924152e6b9e22701c28f8880/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef939d6a96bde0f924152e6b9e22701c28f8880/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=fef939d6a96bde0f924152e6b9e22701c28f8880", "patch": "@@ -651,6 +651,9 @@ Objective-C and Objective-C++ Dialects}.\n @emph{FR30 Options}\n @gccoptlist{-msmall-model -mno-lsim}\n \n+@emph{FT32 Options}\n+@gccoptlist{-msim -mlra}\n+\n @emph{FRV Options}\n @gccoptlist{-mgpr-32  -mgpr-64  -mfpr-32  -mfpr-64 @gol\n -mhard-float  -msoft-float @gol\n@@ -12278,6 +12281,7 @@ platform.\n * Darwin Options::\n * DEC Alpha Options::\n * FR30 Options::\n+* FT32 Options::\n * FRV Options::\n * GNU/Linux Options::\n * H8/300 Options::\n@@ -15111,6 +15115,29 @@ command line.\n \n @end table\n \n+@node FT32 Options\n+@subsection FT32 Options\n+@cindex FT32 Options\n+\n+These options are defined specifically for the FT32 port.\n+\n+@table @gcctabopt\n+\n+@item -msim\n+@opindex msim\n+Specifies that the program will be run on the simulator.  This causes\n+an alternate runtime startup and library to be linked.\n+You must not use this option when generating programs that will run on\n+real hardware; you must provide your own runtime library for whatever\n+I/O functions are needed.\n+\n+@item -mlra\n+@opindex mlra\n+Enable Local Register Allocation.  This is still experimental for FT32,\n+so by default the compiler uses standard reload.\n+\n+@end table\n+\n @node FRV Options\n @subsection FRV Options\n @cindex FRV Options"}, {"sha": "30d7775aba7d013aa233136ab67205c242eff313", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef939d6a96bde0f924152e6b9e22701c28f8880/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef939d6a96bde0f924152e6b9e22701c28f8880/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=fef939d6a96bde0f924152e6b9e22701c28f8880", "patch": "@@ -2247,6 +2247,49 @@ range of 1 to 2047.\n \n @end table\n \n+@item FT32---@file{config/ft32/constraints.md}\n+@table @code\n+@item A\n+An absolute address\n+\n+@item B\n+An offset address\n+\n+@item W\n+A register indirect memory operand\n+\n+@item e\n+An offset address.\n+\n+@item f\n+An offset address.\n+\n+@item O\n+The constant zero or one\n+\n+@item I\n+A 16-bit signed constant (@minus{}32768 @dots{} 32767)\n+\n+@item w\n+A bitfield mask suitable for bext or bins\n+\n+@item x\n+An inverted bitfield mask suitable for bext or bins\n+\n+@item L\n+A 16-bit unsigned constant, multiple of 4 (0 @dots{} 65532)\n+\n+@item S\n+A 20-bit signed constant (@minus{}524288 @dots{} 524287)\n+\n+@item b\n+A constant for a bitfield width (1 @dots{} 16)\n+\n+@item KA\n+A 10-bit signed constant (@minus{}512 @dots{} 511)\n+\n+@end table\n+\n @item Hewlett-Packard PA-RISC---@file{config/pa/pa.h}\n @table @code\n @item a"}, {"sha": "d6242211adabac853f1030fda6be00895b5c7b3e", "filename": "libgcc/config.host", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef939d6a96bde0f924152e6b9e22701c28f8880/libgcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef939d6a96bde0f924152e6b9e22701c28f8880/libgcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig.host?ref=fef939d6a96bde0f924152e6b9e22701c28f8880", "patch": "@@ -113,6 +113,8 @@ fido-*-*)\n \t;;\n frv*)\tcpu_type=frv\n \t;;\n+ft32*)\tcpu_type=ft32\n+\t;;\n moxie*)\tcpu_type=moxie\n \t;;\n i[34567]86-*-*)\n@@ -478,6 +480,10 @@ frv-*-*linux*)\n \ttmake_file=\"$tmake_file frv/t-frv frv/t-linux t-fdpbit\"\n \ttm_file=\"$tm_file frv/elf-lib.h frv/frv-abi.h\"\n \t;;\n+ft32-*-elf)\n+\ttmake_file=\"ft32/t-ft32 t-softfp-sfdf t-softfp-excl t-softfp\"\n+\textra_parts=\"$extra_parts crti.o crti-hw.o crtn.o\"\n+\t;;\n h8300-*-rtems*)\n \ttmake_file=\"$tmake_file h8300/t-h8300 t-fpbit\"\n \ttm_file=\"$tm_file h8300/h8300-lib.h\""}, {"sha": "1322dd6c3d013e2537834cef3873eda86193695e", "filename": "libgcc/config/ft32/crti-hw.S", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef939d6a96bde0f924152e6b9e22701c28f8880/libgcc%2Fconfig%2Fft32%2Fcrti-hw.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef939d6a96bde0f924152e6b9e22701c28f8880/libgcc%2Fconfig%2Fft32%2Fcrti-hw.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fft32%2Fcrti-hw.S?ref=fef939d6a96bde0f924152e6b9e22701c28f8880", "patch": "@@ -0,0 +1,193 @@\n+.equ SYS_REGMSC0CFG_B3  , 0x1001b\n+.equ SYS_REGIRQCTL_B3   , 0x100e3\n+\n+.global _start\n+_start:\n+# START Interrupt Vector Table [[\n+        jmp     0x3fffc         # RESET Vector\n+        jmp     _watchdog_isr   # WATCHDOG Vector # TODO: Change me to reset the chip proper\n+        jmp     interrupt_0\n+        jmp     interrupt_1\n+        jmp     interrupt_2\n+        jmp     interrupt_3\n+        jmp     interrupt_4\n+        jmp     interrupt_5\n+        jmp     interrupt_6\n+        jmp     interrupt_7\n+        jmp     interrupt_8\n+        jmp     interrupt_9\n+        jmp     interrupt_10\n+        jmp     interrupt_11\n+        jmp     interrupt_12\n+        jmp     interrupt_13\n+        jmp     interrupt_14\n+        jmp     interrupt_15\n+        jmp     interrupt_16\n+        jmp     interrupt_17\n+        jmp     interrupt_18\n+        jmp     interrupt_19\n+        jmp     interrupt_20\n+        jmp     interrupt_21\n+        jmp     interrupt_22\n+        jmp     interrupt_23\n+        jmp     interrupt_24\n+        jmp     interrupt_25\n+        jmp     interrupt_26\n+        jmp     interrupt_27\n+        jmp     interrupt_28\n+        jmp     interrupt_29\n+        jmp     interrupt_30\n+        jmp     interrupt_31\n+        jmp     0x3fff8\n+# ]] END Interrupt Vector Table\n+\n+codestart:\n+        jmp    init\n+\n+        \n+.global _exithook\n+_exithook:               # Debugger uses '_exithook' at 0x90 to catch program exit\n+        return\n+        \n+init:\n+        # Disable all interrupts\n+        ldk     $r0,0x80\n+        sta.b   0x100e3,$r0\n+        \n+        # Reset all peripherals\n+        # lda.l   $r0, 0x10018\n+        # bins.l  $r0, $r0, 0x23F  # Set bit 31\n+        # sta.l   0x10018, $r0\n+        \n+        # Initialize DATA by copying from program memory\n+        ldk.l   $r0,__data_load_start\n+        ldk.l   $r1,__data_load_end\n+        ldk.l   $r2,0   # Will use __data after binutils patch\n+\n+        jmp     .dscopy\n+.dsloop:\n+        # Copy PM[$r0] to RAM $r2\n+        lpmi.l  $r3,$r0,0\n+        sti.l   $r2,0,$r3\n+        add.l   $r0,$r0,4\n+        add.l   $r2,$r2,4\n+.dscopy:\n+        cmp.l   $r0,$r1\n+        jmpc    lt,.dsloop\n+\n+        # Zero BSS\n+        ldk.l   $r0,_bss_start\n+        ldk.l   $r2,_end\n+        sub.l   $r2,$r2,$r0\n+        ldk.l   $r1,0\n+        memset.l  $r0,$r1,$r2\n+\n+        sub.l   $sp,$sp,24  # Space for the caller argument frame\n+        call    main\n+\n+.equ EXITEXIT    , 0x1fffc\n+\n+.global _exit\n+_exit:\n+        sta.l   EXITEXIT,$r0    # simulator end of test\n+        jmp     _exithook\n+\n+_watchdog_isr:\n+        ldk.l   $sp, 0x80FFFF   # Reset the stack pointer so it doesn't grow to a huge size\n+        jmp     0\n+\n+# Macro to construct the interrupt stub code.\n+# it just saves r0, loads r0 with the int vector\n+# and branches to interrupt_common.\n+\n+.macro  inth i=0\n+interrupt_\\i:\n+        push    $r0     # {\n+        lda     $r0,(vector_table + 4 * \\i)\n+        jmp     interrupt_common\n+.endm\n+\n+        inth    0\n+        inth    1\n+        inth    2\n+        inth    3\n+        inth    4\n+        inth    5\n+        inth    6\n+        inth    7\n+        inth    8\n+        inth    9\n+        inth    10\n+        inth    11\n+        inth    12\n+        inth    13\n+        inth    14\n+        inth    15\n+        inth    16\n+        inth    17\n+        inth    18\n+        inth    19\n+        inth    20\n+        inth    21\n+        inth    22\n+        inth    23\n+        inth    24\n+        inth    25\n+        inth    26\n+        inth    27\n+        inth    28\n+        inth    29\n+        inth    30\n+        inth    31\n+        inth    32\n+\n+        # On entry: r0, already saved, holds the handler function\n+interrupt_common:\n+        push    $r1     # {\n+        push    $r2     # {\n+        push    $r3     # {\n+        push    $r4     # {\n+        push    $r5     # {\n+        push    $r6     # {\n+        push    $r7     # {\n+        push    $r8     # {\n+        push    $r9     # {\n+        push    $r10    # {\n+        push    $r11    # {\n+        push    $r12    # {\n+        push    $cc     # {\n+\n+        calli   $r0\n+\n+        pop     $cc     # }\n+        pop     $r12    # }\n+        pop     $r11    # }\n+        pop     $r10    # }\n+        pop     $r9     # }\n+        pop     $r8     # }\n+        pop     $r7     # }\n+        pop     $r6     # }\n+        pop     $r5     # }\n+        pop     $r4     # }\n+        pop     $r3     # }\n+        pop     $r2     # }\n+        pop     $r1     # }\n+        pop     $r0     # } matching push in interrupt_0-31 above\n+        reti\n+\n+        # Null function for unassigned interrupt to point at\n+.global     nullvector\n+nullvector:\n+        return\n+\n+.section .data\n+.global vector_table\n+vector_table:\n+        .rept 33\n+                .long   nullvector\n+        .endr\n+\n+\n+.section .text\n+.global __gxx_personality_sj0\n+__gxx_personality_sj0:"}, {"sha": "8fd8e39b63237d2917e9398de62a8454cbd9ea31", "filename": "libgcc/config/ft32/crti.S", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef939d6a96bde0f924152e6b9e22701c28f8880/libgcc%2Fconfig%2Fft32%2Fcrti.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef939d6a96bde0f924152e6b9e22701c28f8880/libgcc%2Fconfig%2Fft32%2Fcrti.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fft32%2Fcrti.S?ref=fef939d6a96bde0f924152e6b9e22701c28f8880", "patch": "@@ -0,0 +1,40 @@\n+# crti.S for FT32\n+#\n+#   Copyright (C) 2009-2013 Free Software Foundation, Inc.\n+#\n+# This file is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published by the\n+# Free Software Foundation; either version 3, or (at your option) any\n+# later version.\n+#\n+# This file is distributed in the hope that it will be useful, but\n+# WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+# General Public License for more details.\n+#\n+# Under Section 7 of GPL version 3, you are granted additional\n+# permissions described in the GCC Runtime Library Exception, version\n+# 3.1, as published by the Free Software Foundation.\n+#\n+# You should have received a copy of the GNU General Public License and\n+# a copy of the GCC Runtime Library Exception along with this program;\n+# see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+# <http://www.gnu.org/licenses/>.\n+\n+# This file just make a stack frame for the contents of the .fini and\n+# .init sections.  Users may put any desired instructions in those\n+# sections.\n+\n+\t.file\t\t\"crti.S\"\n+\n+\t.section\t\".init\"\n+\t.global\t_init\n+\t.type\t_init, @function\t\n+\t.p2align\t2\n+_init:\n+\n+\t.section\t\".fini\"\n+\t.global\t_fini\n+\t.type\t_fini,@function\n+\t.p2align\t2\n+_fini:"}, {"sha": "322a0c927ca6053ff961092847a57fdc4dbd114e", "filename": "libgcc/config/ft32/crtn.S", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef939d6a96bde0f924152e6b9e22701c28f8880/libgcc%2Fconfig%2Fft32%2Fcrtn.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef939d6a96bde0f924152e6b9e22701c28f8880/libgcc%2Fconfig%2Fft32%2Fcrtn.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fft32%2Fcrtn.S?ref=fef939d6a96bde0f924152e6b9e22701c28f8880", "patch": "@@ -0,0 +1,34 @@\n+# crtn.S for FT32\n+#\n+#   Copyright (C) 2009-2013 Free Software Foundation, Inc.\n+#\n+# This file is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published by the\n+# Free Software Foundation; either version 3, or (at your option) any\n+# later version.\n+#\n+# This file is distributed in the hope that it will be useful, but\n+# WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+# General Public License for more details.\n+#\n+# Under Section 7 of GPL version 3, you are granted additional\n+# permissions described in the GCC Runtime Library Exception, version\n+# 3.1, as published by the Free Software Foundation.\n+#\n+# You should have received a copy of the GNU General Public License and\n+# a copy of the GCC Runtime Library Exception along with this program;\n+# see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+# <http://www.gnu.org/licenses/>.\n+\n+# This file just makes sure that the .fini and .init sections do in\n+# fact return.  Users may put any desired instructions in those sections.\n+# This file is the last thing linked into any executable.\n+\n+\t.file\t\t\"crtn.S\"\n+\n+\t.section\t\".init\"\n+\treturn\n+\t\n+\t.section\t\".fini\"\n+\treturn"}, {"sha": "e40b5481675011f9d9b48ce4f1239161b6d32731", "filename": "libgcc/config/ft32/epilog.S", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef939d6a96bde0f924152e6b9e22701c28f8880/libgcc%2Fconfig%2Fft32%2Fepilog.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef939d6a96bde0f924152e6b9e22701c28f8880/libgcc%2Fconfig%2Fft32%2Fepilog.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fft32%2Fepilog.S?ref=fef939d6a96bde0f924152e6b9e22701c28f8880", "patch": "@@ -0,0 +1,52 @@\n+        .macro  e r=0\n+        .global __epilog_$r\\r\n+__epilog_$r\\r:\n+        pop     $r\\r\n+        .endm\n+\n+        e       28\n+        e       27\n+        e       26\n+        e       25\n+        e       24\n+        e       23\n+        e       22\n+        e       21\n+        e       20\n+        e       19\n+        e       18\n+        e       17\n+        e       16\n+        e       15\n+        e       14\n+        e       13\n+        return\n+\n+        .global __epilog24\n+__epilog24:\n+        add     $sp,$sp,24\n+        return\n+\n+        .macro  f r=0\n+        .global __epilog24_$r\\r\n+__epilog24_$r\\r:\n+        add     $sp,$sp,24\n+        jmp     __epilog_$r\\r\n+        .endm\n+\n+        f       13\n+        f       14\n+        f       15\n+        f       16\n+        f       17\n+        f       18\n+        f       19\n+        f       20\n+        f       21\n+        f       22\n+        f       23\n+        f       24\n+        f       25\n+        f       26\n+        f       27\n+        f       28"}, {"sha": "36e4088d603e135b9ec15a2c9a99e7736e831193", "filename": "libgcc/config/ft32/lib1funcs.S", "status": "added", "additions": 919, "deletions": 0, "changes": 919, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef939d6a96bde0f924152e6b9e22701c28f8880/libgcc%2Fconfig%2Fft32%2Flib1funcs.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef939d6a96bde0f924152e6b9e22701c28f8880/libgcc%2Fconfig%2Fft32%2Flib1funcs.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fft32%2Flib1funcs.S?ref=fef939d6a96bde0f924152e6b9e22701c28f8880", "patch": "@@ -0,0 +1,919 @@\n+# ieee754 sf routines for FT32\n+\n+/* Copyright (C) 1995-2014 Free Software Foundation, Inc.\n+\n+This file is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 3, or (at your option) any\n+later version.\n+\n+This file is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+# See http://www.ens-lyon.fr/LIP/Pub/Rapports/PhD/PhD2006/PhD2006-02.pdf\n+# for implementation details of all except division which is detailed below\n+#\n+\n+// .global __cmpsf2_\n+\n+nan:            .long 0x7FFFFFFF    # also abs mask\n+inf:            .long 0x7F800000\n+sign_mask:      .long 0x80000000\n+m_mask:         .long 0x007FFFFF\n+exp_bias:       .long 127\n+edge_case:      .long 0x00FFFFFF\n+smallest_norm:  .long 0x00800000    # implicit bit\n+high_FF:        .long 0xFF000000\n+high_uint:      .long 0xFFFFFFFF\n+\n+# Supply a few 'missing' instructions\n+\n+# not\n+.macro      not rd,r1\n+    xor     \\rd,\\r1,-1\n+.endm\n+\n+# negate\n+.macro      neg x\n+    not     \\x, \\x\n+    add     \\x, \\x, 1\n+.endm\n+\n+# set $cc from the result of \"ashl reg,dist\"\n+.macro  ashlcc reg,dist\n+    .long   0x5de04008 | (\\reg << 15) | (\\dist << 4)\n+.endm\n+\n+\n+# converts an unsigned number x to a signed rep based on the bits in sign\n+# sign should be 0x00000000 or 0xffffffff.\n+.macro      to_signed x, sign\n+    add     \\x,\\x,\\sign    # conditionally decrement x\n+    xor     \\x,\\x,\\sign    # conditionally complement x\n+.endm\n+\n+\n+.macro  ld32    r,v\n+    ldk     \\r,(\\v>>10)\n+    ldl     \\r,\\r,(\\v & 1023)\n+.endm\n+\n+# calculate trailing zero count in x, also uses scr.\n+# Using Seal's algorithm\n+.macro      ntz x, scr\n+    not     \\scr, \\x\n+    add     \\scr, \\scr, 1\n+    and     \\x, \\x, \\scr\n+    ashl    \\scr, \\x, 4\n+    add     \\x, \\scr, \\x\n+    ashl    \\scr, \\x, 6\n+    add     \\x, \\scr, \\x\n+    ashl    \\scr, \\x, 16\n+    sub     \\x, \\scr, \\x\n+    lshr    \\x, \\x, 26\n+    ldk     \\scr, ntz_table\n+    add     \\x, \\x, \\scr\n+    lpmi.b  \\x, \\x, 0\n+.endm\n+\n+ntz_table:\n+    .byte   32,0,1,12,2,6,0,13,3,0,7,0,0,0,0,14\n+    .byte   10,4,0,0,8,0,0,25,0,0,0,0,0,21,27,15\n+    .byte   31,11,5,0,0,0,0,0,9,0,0,24,0,0,20,26\n+    .byte   30,0,0,0,0,23,0,19,29,0,22,18,28,17,16,0\n+\n+# calculate leading zero count\n+.macro      nlz x, scr\n+    flip    \\x, \\x, 31\n+    ntz     \\x, \\scr\n+.endm\n+\n+\n+# Round 26 bit mantissa to nearest\n+# | 23 bits frac | G | R | S |\n+.macro      round m,  s1, s2\n+    ldk     \\s1,0xc8\n+    and     \\s2,\\m,7\n+    lshr    \\s1,\\s1,\\s2\n+    and     \\s1,\\s1,1\n+    lshr    \\m,\\m,2\n+    add     \\m,\\m,\\s1\n+.endm\n+\n+# If NZ, set the LSB of reg\n+.macro      sticky reg\n+    jmpc    z,1f\n+    or      \\reg,\\reg,1             # set the sticky bit to 1\n+1:\n+.endm\n+\n+##########################################################################\n+##########################################################################\n+## addition & subtraction\n+\n+#if defined(L_subsf3) || defined(L_addsub_sf)\n+.global __subsf3\n+__subsf3:\n+    # this is subtraction, so we just change the sign of r1\n+    lpm     $r2,sign_mask\n+    xor     $r1,$r1,$r2\n+    jmp     __addsf3\n+#endif\n+\n+#if defined(L_addsf3) || defined(L_addsub_sf)\n+.global __addsf3\n+__addsf3:\n+    # x in $r0, y in $r1, result z in $r0       --||| 100 instructions +/- |||--\n+    # unpack e, calc d\n+    bextu   $r2,$r0,(8<<5)|23   # ex in r2\n+    bextu   $r3,$r1,(8<<5)|23   # ey in r3\n+    sub     $r5,$r2,$r3         # d = ex - ey\n+\n+    # Special values are 0x00 and 0xff in ex and ey.\n+    # If (ex&ey) != 0 or (xy|ey)=255 then there may be\n+    # a special value.\n+    tst     $r2,$r3\n+    jmpc    nz,1f\n+    jmp     slow\n+1:  or      $r4,$r2,$r3\n+    cmp     $r4,255\n+    jmpc    nz,no_special_vals\n+slow:\n+    # Check for early exit\n+    cmp     $r2,0\n+    jmpc    z,test_if_not_255\n+    cmp     $r3,0\n+    jmpc    nz,no_early_exit\n+test_if_not_255:\n+    cmp     $r2,255\n+    jmpc    z,no_early_exit\n+    cmp     $r3,255\n+    jmpc    z,no_early_exit\n+    or      $r6,$r2,$r3\n+    cmp     $r6,0\n+    jmpc    nz,was_not_zero\n+    and     $r0,$r0,$r1\n+    lpm     $r1,sign_mask\n+    and     $r0,$r0,$r1\n+    return\n+was_not_zero:\n+    cmp     $r2,0\n+    jmpc    nz,ret_x\n+    move    $r0,$r1\n+    return\n+ret_x:\n+    return\n+no_early_exit:\n+    # setup to test for special values\n+    sub     $r6,$r2,1\n+    and     $r6,$r6,0xFE\n+    sub     $r7,$r3,1\n+    and     $r7,$r7,0xFE\n+    # test for special values\n+    cmp     $r6,$r7\n+    jmpc    gte,ex_spec_is_gte\n+    move    $r6,$r7\n+ex_spec_is_gte:\n+    cmp     $r6,0xFE\n+    jmpc    nz,no_special_vals\n+    cmp     $r5,0\n+    jmpc    ns,d_gte_0\n+    cmp     $r3,0xFF\n+    jmpc    z,ret_y\n+    cmp     $r2,0\n+    jmpc    z,ret_y\n+ret_y:\n+    move    $r0,$r1\n+    return\n+d_gte_0:\n+    cmp     $r5,0\n+    jmpc    z,d_is_0\n+    cmp     $r2,0xFF\n+    jmpc    z,ret_x\n+    cmp     $r3,0\n+    jmpc    z,ret_x\n+d_is_0:\n+    cmp     $r2,0xFF\n+    jmpc    nz,no_special_vals\n+    ashl    $r6,$r0,9           # clear all except x frac\n+    ashl    $r7,$r1,9           # clear all except y frac\n+    or      $r6,$r6,$r7\n+    cmp     $r6,0\n+    jmpc    nz,ret_nan\n+    lshr    $r4,$r0,31          # sx in r4\n+    lshr    $r5,$r1,31          # sy in r4\n+    cmp     $r4,$r5\n+    jmpc    nz,ret_nan\n+    return\n+ret_nan:\n+    lpm     $r0,nan\n+    return\n+no_special_vals:\n+    ldk     $r8,(1<<10)|(9<<5)|26   # setup implicit bit and mask for e\n+    #----------------------\n+    ashr    $r4,$r0,31              # sx in r4\n+    ashl    $r0,$r0,3               # shift mx 3 for GRS bits\n+    bins    $r0,$r0,$r8             # clear sx, ex and add implicit bit mx\n+    # change mx to signed mantissa\n+    to_signed $r0,$r4\n+    #----------------------\n+    ashr    $r4,$r1,31              # sy in r4\n+    ashl    $r1,$r1,3               # shift my 3 for GRS bits\n+    bins    $r1,$r1,$r8             # clear sy, ey and add implicit bit my\n+    # change my to signed mantissa\n+    to_signed $r1,$r4\n+    #----------------------\n+    # test if we swap ms based on d sign\n+    cmp     $r5,0\n+    jmpc    gte,noswap\n+    # swap mx & my\n+    xor     $r0,$r0,$r1\n+    xor     $r1,$r0,$r1\n+    xor     $r0,$r0,$r1\n+    # d positive means that ex>=ey, so ez = ex\n+    # d negative means that ey>ex, so ez = ey\n+    move    $r2,$r3\n+    # |d|\n+    neg     $r5\n+noswap:\n+                                    # now $r2 = ez = max(ex,ey)\n+    cmp     $r5,26                  # max necessary alignment shift is 26\n+    jmpc    lt,under_26\n+    ldk     $r5,26\n+under_26:\n+    ldk     $r7,-1\n+    ashl    $r7,$r7,$r5             # create inverse of mask for test of S bit value in discarded my\n+    not     $r7,$r7\n+    tst     $r1,$r7                 # determine value of sticky bit\n+    # shift my >> |d|\n+    ashr    $r1,$r1,$r5\n+    sticky  $r1\n+\n+    # add ms\n+    add     $r0,$r0,$r1\n+\n+    # $r4 = sign(mx), mx = |mx|\n+    ashr    $r4,$r0,31\n+    xor     $r0,$r0,$r4\n+    sub     $r0,$r0,$r4\n+\n+    # realign mantissa using leading zero count\n+    flip    $r7,$r0,31\n+    ntz     $r7,$r8\n+    ashl    $r0,$r0,$r7\n+    btst    $r0,(6<<5)|0            # test low bits for sticky again\n+    lshr    $r0,$r0,6\n+    sticky  $r0\n+\n+    # update exponent\n+    add     $r2,$r2,5\n+    sub     $r2,$r2,$r7\n+\n+    # Round to nearest\n+    round   $r0,$r7,$r6\n+\n+    # detect_exp_update\n+    lshr    $r6,$r0,24\n+    add     $r2,$r2,$r6\n+\n+    # final tests\n+    # mz == 0? if so, we just bail with a +0\n+    cmp     $r0,0\n+    jmpc    nz,msum_not_zero\n+    ldk     $r0,0\n+    return\n+msum_not_zero:\n+    # Combined check that (1 <= ez <= 254)\n+    sub     $r3,$r2,1\n+    cmp     $r3,254\n+    jmpc    b,no_special_ret\n+    # underflow?\n+    cmp     $r2,0\n+    jmpc    gt,no_under\n+    ldk     $r0,0\n+    jmp     pack_sz\n+no_under:\n+    # overflow?\n+    cmp     $r2,255\n+    jmpc    lt,no_special_ret\n+    ldk     $r0,0x7F8\n+    ashl    $r0,$r0,20\n+    jmp     pack_sz\n+no_special_ret:\n+    # Pack ez\n+    ldl     $r2,$r2,(8<<5)|23\n+    bins    $r0,$r0,$r2             # width = 8, pos = 23 pack ez\n+    # Pack sz\n+pack_sz:\n+    ldl     $r4,$r4,(1<<5)|31\n+    bins    $r0,$r0,$r4             # width = 1, pos = 31 set sz to sy\n+    return\n+#endif\n+\n+##########################################################################\n+##########################################################################\n+## multiplication\n+\n+#ifdef  L_mulsf3\n+.global __mulsf3\n+__mulsf3:\n+    # x in $r0, y in $r1, result z in $r0       --||| 61 instructions +/- |||--\n+\n+    # unpack e\n+    bextu   $r2,$r0,(8<<5)|23   # ex in r2\n+    bextu   $r3,$r1,(8<<5)|23   # ey in r3\n+    # calc result sign\n+    xor     $r4,$r0,$r1\n+    lpm     $r5,sign_mask\n+    and     $r4,$r4,$r5         # sz in r4\n+\n+    # unpack m add implicit bit\n+    ldk     $r5,(1<<10)|(9<<5)|23   # setup implicit bit and mask for e\n+    #----------------------\n+    bins    $r0,$r0,$r5             # clear sx, ex and add implicit bit mx\n+\n+    sub     $r6,$r2,1\n+    cmp     $r6,254\n+    jmpc    b,1f\n+    jmp     slow_mul\n+1:  sub     $r6,$r3,1\n+    cmp     $r6,254\n+    jmpc    b,no_special_vals_mul\n+\n+slow_mul:\n+    # Check for early exit\n+    cmp     $r2,0\n+    jmpc    z,op_is_zero\n+    cmp     $r3,0\n+    jmpc    nz,no_early_exit_mul\n+op_is_zero:\n+    cmp     $r2,255\n+    jmpc    z,no_early_exit_mul\n+    cmp     $r3,255\n+    jmpc    z,no_early_exit_mul\n+    move    $r0,$r4\n+    return\n+no_early_exit_mul:\n+    # setup to test for special values\n+    sub     $r6,$r2,1\n+    and     $r6,$r6,0xFE\n+    sub     $r7,$r3,1\n+    and     $r7,$r7,0xFE\n+    # test for special values\n+    cmp     $r6,$r7\n+    jmpc    gte,ex_spec_is_gte_ey_mul\n+    move    $r6,$r7\n+ex_spec_is_gte_ey_mul:\n+    cmp     $r6,0xFE\n+    jmpc    nz,no_special_vals_mul\n+    cmp     $r2,0xFF\n+    jmpc    nz,ex_not_FF_mul\n+    ashl    $r6,$r0,9\n+    cmp     $r6,0\n+    jmpc    nz,ret_nan\n+    cmp     $r3,0\n+    jmpc    z,ret_nan\n+    ashl    $r6,$r1,1\n+    lpm     $r7,high_FF\n+    cmp     $r6,$r7\n+    jmpc    a,ret_nan\n+    cmp     $r6,0\n+    jmpc    z,ret_nan\n+    # infinity\n+    lpm     $r0,inf\n+    or      $r0,$r0,$r4\n+    return\n+ex_not_FF_mul:\n+    cmp     $r2,0\n+    jmpc    nz,no_nan_mul\n+    cmp     $r3,0xFF\n+    jmpc    nz,no_nan_mul\n+    jmp     ret_nan\n+no_nan_mul:\n+    lpm     $r0,nan\n+    and     $r0,$r0,$r1\n+    or      $r0,$r0,$r4\n+    return\n+\n+ret_nan:\n+    lpm     $r0,nan\n+    return\n+\n+no_special_vals_mul:\n+    bins    $r1,$r1,$r5         # clear sy, ey and add implicit bit my\n+    # calc ez\n+    add     $r3,$r2,$r3\n+    sub     $r3,$r3,127         # ez in r3\n+\n+    # (r1,r2) = R0 * R1\n+    mul     $r2,$r0,$r1\n+    muluh   $r1,$r0,$r1\n+\n+    btst    $r1,(1<<5)|15       # XXX use jmpx\n+    jmpc    z,mul_z0\n+\n+    # mz is 1X.XX...X\n+    # 48-bit product is in (r1,r2). The low 22 bits of r2\n+    # are discarded.\n+    lshr    $r0,$r2,22\n+    ashl    $r1,$r1,10\n+    or      $r0,$r0,$r1         # r0 = (r1,r2) >> 22\n+    ashlcc  2,10\n+    sticky  $r0\n+    add     $r3,$r3,1           # bump exponent\n+\n+    # Round to nearest\n+    round   $r0, $r1, $r2\n+    lshr    $r6,$r0,24\n+    add     $r3,$r3,$r6\n+\n+    sub     $r6,$r3,1\n+    cmp     $r6,254\n+    jmpc    b,no_special_ret_mul\n+\n+special_ret_mul:\n+    # When the final exponent <= 0, result is flushed to 0 except\n+    # for the border case 0x00FFFFFF which is promoted to next higher\n+    # FP no., that is, the smallest \"normalized\" number.\n+    cmp     $r3,0\n+    jmpc    gt,exp_normal\n+    # Pack ez\n+    ldl     $r3,$r3,(8<<5)|23\n+    bins    $r0,$r0,$r3 # width = 8, pos = 23 pack ez\n+    lpm     $r2,edge_case\n+    cmp     $r0,$r2\n+    jmpc    nz,no_edge_case\n+    lpm     $r0,smallest_norm\n+    jmp     pack_sz_mul\n+no_edge_case:\n+    ldk     $r0,0\n+    jmp     pack_sz_mul\n+exp_normal:\n+    # overflow?\n+    cmp     $r3,255\n+    jmpc    lt,no_special_ret_mul\n+    ldk     $r0,0x7F8\n+    ashl    $r0,$r0,20\n+    jmp     pack_sz_mul\n+no_special_ret_mul:\n+    # Pack ez\n+    ldl     $r3,$r3,(8<<5)|23\n+    bins    $r0,$r0,$r3 # width = 8, pos = 23 pack ez\n+    # Pack sz\n+pack_sz_mul:\n+    or    $r0,$r0,$r4\n+    return\n+\n+mul_z0:\n+    # mz is 0X.XX...X\n+    # 48-bit product is in (r1,r2). The low 21 bits of r2\n+    # are discarded.\n+    lshr    $r0,$r2,21\n+    ashl    $r1,$r1,11\n+    or      $r0,$r0,$r1         # r0 = (r1,r2) >> 22\n+    ashlcc  2,11\n+    sticky  $r0\n+    # Round to nearest\n+    round   $r0, $r1, $r2\n+    lshr    $r6,$r0,24\n+    add     $r3,$r3,$r6\n+\n+    sub     $r6,$r3,1\n+    cmp     $r6,254\n+    jmpc    b,no_special_ret_mul\n+    jmp     special_ret_mul\n+#endif\n+\n+##########################################################################\n+##########################################################################\n+## division\n+\n+## See http://perso.ens-lyon.fr/gilles.villard/BIBLIOGRAPHIE/PDF/arith19.pdf\n+## for implementation details\n+\n+\n+dc_1: .long             0xffffe7d7\n+dc_2: .long             0xffffffe8\n+dc_3: .long             0xffbad86f\n+dc_4: .long             0xfffbece7\n+dc_5: .long             0xf3672b51\n+dc_6: .long             0xfd9d3a3e\n+dc_7: .long             0x9a3c4390\n+dc_8: .long             0xd4d2ce9b\n+dc_9: .long             0x1bba92b3\n+dc_10: .long            0x525a1a8b\n+dc_11: .long            0x0452b1bf\n+dc_12: .long            0xFFFFFFC0\n+spec_val_test:  .long   0x7F7FFFFF\n+\n+\n+\n+#ifdef  L_divsf3\n+.global __divsf3\n+__divsf3:\n+    push    $r13\n+    # x in $r0, y in $r1, result z in $r0       --||| 73 instructions +/- |||-\n+    bextu   $r10,$r0,(8<<5)|23   # ex in r2\n+    bextu   $r11,$r1,(8<<5)|23   # ey in r3\n+    lpm     $r6, m_mask\n+    and     $r2, $r0, $r6        # mx\n+    and     $r3, $r1, $r6        # my\n+    cmp     $r2,$r3\n+    bextu   $r2,$r30,(1<<5)|4   # c = Tx >= T;\n+    ashl    $r3,$r3,9           # T = X << 9;\n+    lpm     $r13, sign_mask\n+    ashl    $r4,$r0,8           # X8 = X << 8;\n+    or      $r4,$r4,$r13        # Mx = X8 | 0x80000000;\n+    lshr    $r5,$r4,$r2         # S = Mx >> c;\n+    # calc D\n+    sub     $r2, $r11, $r2\n+    add     $r12, $r10, 125\n+    sub     $r2, $r12, $r2      # int D = (Ex + 125) - (Ey - c);\n+    # calc result sign\n+    xor     $r12,$r0,$r1\n+    and     $r12,$r12,$r13      # Sr = ( X \u02c6 Y ) & 0x80000000;\n+    # check early exit\n+    cmp     $r10, 0\n+    jmpc    nz, no_early_ret_dev\n+    cmp     $r11, 0\n+    jmpc    z, no_early_ret_dev\n+    cmp     $r11, 255\n+    jmpc    z, no_early_ret_dev\n+    move    $r0, $r12\n+    pop     $r13\n+    return\n+no_early_ret_dev:\n+ # setup to test for special values\n+    sub     $r8,$r10,1\n+    and     $r8,$r8,0xFE\n+    sub     $r9,$r11,1\n+    and     $r9,$r9,0xFE\n+    # test for special values\n+    cmp     $r8, $r9\n+    jmpc    gte, absXm1_gte_absYm1\n+    move    $r8, $r9\n+absXm1_gte_absYm1:\n+    cmp     $r8, 0xFE\n+    jmpc    nz, no_spec_ret_div\n+    cmp     $r10, 0xFF\n+    jmpc    nz, ex_not_FF_div\n+    lpm     $r6, m_mask\n+    and     $r2, $r0, $r6        # mx\n+    cmp     $r2, 0\n+    jmpc    nz, ret_nan_div\n+    cmp     $r11, 0xFF\n+    jmpc    z, ret_nan_div\n+    jmp     ret_inf_div\n+ex_not_FF_div:\n+    cmp     $r11, 0xFF\n+    jmpc    nz, ey_not_FF_div\n+    ashl    $r13, $r1, 9\n+    cmp     $r13, 0\n+    jmpc    nz, ret_nan_div\n+    move    $r0, $r12\n+    pop     $r13\n+    return\n+ey_not_FF_div:\n+    or      $r10, $r10, $r11\n+    cmp     $r10, 0\n+    jmpc    z, ret_nan_div\n+ret_inf_div:\n+    lpm     $r6, inf\n+    move    $r0, $r6\n+    or      $r0, $r0, $r12\n+    pop     $r13\n+    return\n+ret_nan_div:\n+    lpm     $r0, nan\n+    pop     $r13\n+    return\n+\n+no_spec_ret_div:\n+# check for overflow\n+    ldk     $r6, 0xFE\n+    cmp     $r2, $r6\n+    jmpc    lt, no_overflow_div\n+    lpm     $r6, inf\n+    or      $r0, $r12, $r6\n+    pop     $r13\n+    return\n+no_overflow_div:\n+# check for underflow\n+    cmp     $r2, 0\n+    jmpc    ns, no_underflow_div\n+    xnor    $r6, $r6, $r6       # -1\n+    cmp     $r2, $r6\n+    jmpc    nz, ret_sr_div\n+    ldk     $r7, 0xFF\n+    xor     $r6, $r6, $r7       # 0xFF ^ -1 = 0xFFFFFF00\n+    cmp     $r4, $r6\n+    jmpc    nz, ret_sr_div\n+    lpm     $r6, sign_mask\n+    cmp     $r4, $r6\n+    jmpc    nz, ret_sr_div\n+    lshr    $r0, $r6, 8\n+    or      $r0, $r0, $r12\n+    pop     $r13\n+    return\n+ret_sr_div:\n+    move    $r0, $r12\n+    pop     $r13\n+    return\n+no_underflow_div:\n+    lpm     $r6, dc_1\n+    muluh   $r7, $r3, $r6       # i0 = mul( T , 0xffffe7d7 );\n+    lpm     $r6, dc_2\n+    sub     $r7, $r6, $r7       # i1 = 0xffffffe8 - i0;\n+    muluh   $r7, $r5, $r7       # i2 = mul( S , i1 );\n+    add     $r7, $r7, 0x20      # i3 = 0x00000020 + i2;\n+    muluh   $r8, $r3, $r3       # i4 = mul( T , T );\n+    muluh   $r9, $r5, $r8       # i5 = mul( S , i4 );\n+    lpm     $r6, dc_3\n+    muluh   $r10, $r3, $r6      # i6 = mul( T , 0xffbad86f );\n+    lpm     $r6, dc_4\n+    sub     $r10, $r6, $r10     # i7 = 0xfffbece7 - i6;\n+    muluh   $r10, $r9, $r10     # i8 = mul( i5 , i7 );\n+    add     $r7, $r7, $r10      # i9 = i3 + i8;\n+    muluh   $r9, $r8, $r9       # i10 = mul( i4 , i5 );\n+    lpm     $r6, dc_5\n+    muluh   $r10, $r3, $r6      # i11 = mul( T , 0xf3672b51 );\n+    lpm     $r6, dc_6\n+    sub     $r10, $r6, $r10     # i12 = 0xfd9d3a3e - i11;\n+    lpm     $r6, dc_7\n+    muluh   $r11, $r3, $r6      # i13 = mul( T , 0x9a3c4390 );\n+    lpm     $r6, dc_8\n+    sub     $r11, $r6, $r11     # i14 = 0xd4d2ce9b - i13\n+    muluh   $r11, $r8, $r11     # i15 = mul( i4 , i14 );\n+    add     $r10, $r10, $r11    # i16 = i12 + i15;\n+    muluh   $r10, $r9, $r10     # i17 = mul( i10 , i16 )\n+    add     $r7, $r7, $r10      # i18 = i9 + i17;\n+    muluh   $r10, $r8, $r8      # i19 = mul( i4 , i4 );\n+    lpm     $r6, dc_9\n+    muluh   $r11, $r3, $r6      # i20 = mul( T , 0x1bba92b3 );\n+    lpm     $r6, dc_10\n+    sub     $r11, $r6, $r11     # i21 = 0x525a1a8b - i20;\n+    lpm     $r6, dc_11\n+    muluh   $r8, $r8, $r6       # i22 = mul( i4 , 0x0452b1bf );\n+    add     $r8, $r11, $r8      # i23 = i21 + i22;\n+    muluh   $r8, $r10, $r8      # i24 = mul( i19 , i23 );\n+    muluh   $r8, $r9, $r8       # i25 = mul( i10 , i24 );\n+    add     $r3, $r7, $r8       # V = i18 + i25;\n+# W = V & 0xFFFFFFC0;\n+    lpm     $r6, dc_12\n+    and     $r3, $r3, $r6   # W\n+# round and pack final values\n+    ashl    $r0, $r2, 23        # pack D\n+    or      $r0, $r0, $r12      # pack Sr\n+    ashl    $r12, $r1, 8\n+    or      $r12, $r12, $r13    # My\n+    muluh   $r10, $r3, $r12\n+    lshr    $r11, $r5, 1\n+    cmp     $r10, $r11\n+    jmpc    gte, div_ret_1\n+    add     $r3, $r3, 0x40\n+div_ret_1:\n+    lshr    $r3, $r3, 7\n+    add     $r0, $r0, $r3\n+    pop     $r13\n+    return\n+#endif\n+\n+##########################################################################\n+##########################################################################\n+## Negate\n+\n+#ifdef L_negsf\n+.global __negsf\n+__negsf:\n+    lpm     $r1, sign_mask\n+    xor     $r0, $r0, $r1\n+    return\n+#endif\n+\n+##########################################################################\n+##########################################################################\n+## float to int & unsigned int\n+\n+#ifdef L_fixsfsi\n+.global __fixsfsi\n+__fixsfsi: # 20 instructions\n+    bextu   $r1,$r0,(8<<5)|23   # e in r1\n+    lshr    $r2,$r0,31          # s in r2\n+    lpm     $r3, m_mask\n+    and     $r0,$r0,$r3         # m in r0\n+    # test nan\n+    cmp     $r1,0xFF\n+    jmpc    nz, int_not_nan\n+    cmp     $r0,0\n+    jmpc    z, int_not_nan\n+    ldk     $r0,0\n+    return\n+int_not_nan:\n+    # test edges\n+    cmp     $r1, 127\n+    jmpc    gte, int_not_zero   # lower limit\n+    ldk     $r0,0\n+    return\n+int_not_zero:\n+    cmp     $r1, 158\n+    jmpc    lt, int_not_max    # upper limit\n+    lpm     $r0, nan\n+    cmp     $r2, 0\n+    jmpc    z, int_positive\n+    xnor    $r0, $r0, 0\n+    return\n+int_not_max:\n+    lpm     $r3, smallest_norm\n+    or      $r0, $r0, $r3       # set implicit bit\n+    sub     $r1, $r1, 150\n+    cmp     $r1, 0\n+    jmpc    s, shift_right\n+    ashl    $r0, $r0, $r1\n+    jmp     set_int_sign\n+shift_right:\n+    xnor    $r1, $r1, 0\n+    add     $r1, $r1, 1\n+    lshr    $r0, $r0, $r1\n+set_int_sign:\n+    cmp     $r2, 0\n+    jmpc    z, int_positive\n+    xnor    $r0, $r0, 0\n+    add     $r0, $r0, 1\n+int_positive:\n+    return\n+#endif\n+\n+#ifdef L_fixunssfsi\n+.global __fixunssfsi\n+__fixunssfsi: # 19 instructions\n+    lshr    $r2, $r0, 31          # s in r2\n+    cmp     $r2, 0\n+    jmpc    z, uint_not_neg\n+    ldk     $r0, 0\n+    return\n+uint_not_neg:\n+    bextu   $r1, $r0, (8<<5)|23   # e in r1\n+    sub     $r1, $r1, 127\n+    lpm     $r3, m_mask\n+    and     $r0, $r0, $r3         # m in r0\n+    # test nan\n+    cmp     $r1, 0xFF\n+    jmpc    nz, uint_not_nan\n+    cmp     $r0, 0\n+    jmpc    z, uint_not_nan\n+    ldk     $r0, 0\n+    return\n+uint_not_nan:\n+    # test edges\n+    cmp     $r1, 0\n+    jmpc    ns, uint_not_zero   # lower limit\n+    ldk     $r0, 0\n+    return\n+uint_not_zero:\n+    lpm     $r3, smallest_norm\n+    or      $r0, $r0, $r3       # set implicit bit\n+    cmp     $r1, 23\n+    jmpc    lt, shift_uint_right\n+    sub     $r1, $r1, 23\n+    ashl    $r0, $r0, $r1\n+    return\n+shift_uint_right:\n+    ldk     $r3, 23\n+    sub     $r1, $r3, $r1\n+    lshr    $r0, $r0, $r1\n+    return\n+#endif\n+\n+##########################################################################\n+##########################################################################\n+## int & unsigned int to float\n+\n+\n+.macro  i2f x, s1, s2, s3, lbl\n+    move    \\s1, \\x\n+    nlz     \\s1, \\s2\n+    cmp     \\s1, 8\n+    jmpc    s, float_round\\lbl\n+    sub     \\s2, \\s1, 8\n+    ashl    \\x, \\x, \\s2\n+    jmp     float_no_round\\lbl\n+float_round\\lbl:\n+    cmp     \\s1, 6\n+    jmpc    s, float_shift_right\\lbl\n+    sub     \\s2, \\s1, 6\n+    ashl    \\x, \\x, \\s2\n+    jmp     float_round_and_pack\\lbl\n+float_shift_right\\lbl:\n+    ldk     \\s2, 6\n+    sub     \\s2, \\s2, \\s1\n+    xnor    \\s3, \\s3 ,\\s3           # 0xFFFFFFFF\n+    ashl    \\s3, \\s3 ,\\s2           # create inverse of mask for test of S bit value in discarded my\n+    xnor    \\s3, \\s3 ,0             # NOT\n+    tst     \\x, \\s3                # determine value of sticky bit\n+    lshr    \\x, \\x, \\s2\n+    jmpc    z,float_round_and_pack\\lbl\n+    or      \\x, \\x, 1               # set the sticky bit to 1\n+float_round_and_pack\\lbl:\n+    bextu   \\s2, \\x, (1<<5)|2      # extract low bit of m\n+    or      \\x, \\x, \\s2           # or p into r\n+    add     \\x, \\x, 1\n+    lshr    \\x, \\x, 2\n+    btst    \\x, (1<<5)|24          # test for carry from round\n+    jmpc    z, float_no_round\\lbl\n+    sub     \\s1, \\s1, 1             # inc e for carry (actually dec nlz)\n+    lshr    \\x, \\x, 1\n+float_no_round\\lbl:\n+    ldk     \\s2, 158\n+    sub     \\s1, \\s2, \\s1\n+    # Pack e\n+    ldl     \\s1, \\s1, (8<<5)|23\n+    bins    \\x, \\x, \\s1\n+.endm\n+\n+\n+#ifdef L_floatsisf\n+.global __floatsisf\n+__floatsisf:                       # 32 instructions\n+    cmp     $r0, 0\n+    jmpc    nz, float_not_zero\n+    return\n+float_not_zero:\n+    ashr    $r1, $r0, 31            # s in r1\n+    xor     $r0, $r0, $r1           # cond neg\n+    sub     $r0, $r0, $r1\n+    i2f     $r0, $r2, $r3, $r4, 1\n+    ldl     $r1, $r1, (1<<5)|31\n+    bins    $r0, $r0, $r1\n+    return\n+#endif\n+\n+#ifdef L_floatunsisf\n+.global __floatunsisf\n+__floatunsisf:                        # 26 instructions\n+    cmp     $r0, 0\n+    jmpc    nz, float_not_zero2\n+    return\n+float_not_zero2:\n+    i2f     $r0, $r1, $r2, $r3, 2\n+    return\n+#endif\n+\n+##########################################################################\n+##########################################################################\n+## float compare\n+\n+\n+__cmpsf2_:\n+    # calc abs vals\n+    lpm     $r3, nan                # also abs mask\n+    and     $r2, $r0, $r3\n+    and     $r3, $r1, $r3\n+    # test if either abs is nan\n+    lpm     $r4, inf\n+    cmp     $r2, $r4\n+    jmpc    gt, cmp_is_gt\n+    cmp     $r3, $r4\n+    jmpc    gt, cmp_is_gt\n+    # test if both are 0\n+    or      $r2, $r2, $r3\n+    cmp     $r2, 0\n+    jmpc    z, cmp_is_eq\n+    # test if eq\n+    cmp     $r0, $r1\n+    jmpc    z, cmp_is_eq\n+    # -- if either is pos\n+    and     $r2, $r0, $r1\n+    cmp     $r2, 0\n+    jmpc    s, cmp_both_neg\n+    cmp     $r0, $r1\n+    jmpc    gt, cmp_is_gt\n+    # r0 < r1\n+    lpm     $r0, high_uint\n+    return\n+cmp_both_neg:\n+    cmp     $r0, $r1\n+    jmpc    lt, cmp_is_gt\n+    # r0 < r1\n+    lpm     $r0, high_uint\n+    return\n+cmp_is_gt:\n+    ldk     $r0, 1\n+    return\n+cmp_is_eq:\n+    ldk     $r0, 0\n+    return\n+\n+\n+\n+"}, {"sha": "ca15be995ff720185e90da5e0a1921b5920e4252", "filename": "libgcc/config/ft32/prolog.S", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef939d6a96bde0f924152e6b9e22701c28f8880/libgcc%2Fconfig%2Fft32%2Fprolog.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef939d6a96bde0f924152e6b9e22701c28f8880/libgcc%2Fconfig%2Fft32%2Fprolog.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fft32%2Fprolog.S?ref=fef939d6a96bde0f924152e6b9e22701c28f8880", "patch": "@@ -0,0 +1,199 @@\n+        .global __prolog_$r13\n+__prolog_$r13:\n+        exi     $r13,$sp,0\n+        jmpi    $r13\n+\n+        .global __prolog_$r14\n+__prolog_$r14:\n+        exi     $r13,$sp,0\n+        push    $r14\n+        jmpi    $r13\n+\n+        .global __prolog_$r15\n+__prolog_$r15:\n+        exi     $r13,$sp,0\n+        push    $r14\n+        push    $r15\n+        jmpi    $r13\n+\n+        .global __prolog_$r16\n+__prolog_$r16:\n+        exi     $r13,$sp,0\n+        push    $r14\n+        push    $r15\n+        push    $r16\n+        jmpi    $r13\n+\n+        .global __prolog_$r17\n+__prolog_$r17:\n+        exi     $r13,$sp,0\n+        push    $r14\n+        push    $r15\n+        push    $r16\n+        push    $r17\n+        jmpi    $r13\n+\n+        .global __prolog_$r18\n+__prolog_$r18:\n+        exi     $r13,$sp,0\n+        push    $r14\n+        push    $r15\n+        push    $r16\n+        push    $r17\n+        push    $r18\n+        jmpi    $r13\n+\n+        .global __prolog_$r19\n+__prolog_$r19:\n+        exi     $r13,$sp,0\n+        push    $r14\n+        push    $r15\n+        push    $r16\n+        push    $r17\n+        push    $r18\n+        push    $r19\n+        jmpi    $r13\n+\n+        .global __prolog_$r20\n+__prolog_$r20:\n+        exi     $r13,$sp,0\n+        push    $r14\n+        push    $r15\n+        push    $r16\n+        push    $r17\n+        push    $r18\n+        push    $r19\n+        push    $r20\n+        jmpi    $r13\n+\n+        .global __prolog_$r21\n+__prolog_$r21:\n+        exi     $r13,$sp,0\n+        push    $r14\n+        push    $r15\n+        push    $r16\n+        push    $r17\n+        push    $r18\n+        push    $r19\n+        push    $r20\n+        push    $r21\n+        jmpi    $r13\n+\n+        .global __prolog_$r22\n+__prolog_$r22:\n+        exi     $r13,$sp,0\n+        push    $r14\n+        push    $r15\n+        push    $r16\n+        push    $r17\n+        push    $r18\n+        push    $r19\n+        push    $r20\n+        push    $r21\n+        push    $r22\n+        jmpi    $r13\n+\n+        .global __prolog_$r23\n+__prolog_$r23:\n+        exi     $r13,$sp,0\n+        push    $r14\n+        push    $r15\n+        push    $r16\n+        push    $r17\n+        push    $r18\n+        push    $r19\n+        push    $r20\n+        push    $r21\n+        push    $r22\n+        push    $r23\n+        jmpi    $r13\n+\n+        .global __prolog_$r24\n+__prolog_$r24:\n+        exi     $r13,$sp,0\n+        push    $r14\n+        push    $r15\n+        push    $r16\n+        push    $r17\n+        push    $r18\n+        push    $r19\n+        push    $r20\n+        push    $r21\n+        push    $r22\n+        push    $r23\n+        push    $r24\n+        jmpi    $r13\n+\n+        .global __prolog_$r25\n+__prolog_$r25:\n+        exi     $r13,$sp,0\n+        push    $r14\n+        push    $r15\n+        push    $r16\n+        push    $r17\n+        push    $r18\n+        push    $r19\n+        push    $r20\n+        push    $r21\n+        push    $r22\n+        push    $r23\n+        push    $r24\n+        push    $r25\n+        jmpi    $r13\n+\n+        .global __prolog_$r26\n+__prolog_$r26:\n+        exi     $r13,$sp,0\n+        push    $r14\n+        push    $r15\n+        push    $r16\n+        push    $r17\n+        push    $r18\n+        push    $r19\n+        push    $r20\n+        push    $r21\n+        push    $r22\n+        push    $r23\n+        push    $r24\n+        push    $r25\n+        push    $r26\n+        jmpi    $r13\n+\n+        .global __prolog_$r27\n+__prolog_$r27:\n+        exi     $r13,$sp,0\n+        push    $r14\n+        push    $r15\n+        push    $r16\n+        push    $r17\n+        push    $r18\n+        push    $r19\n+        push    $r20\n+        push    $r21\n+        push    $r22\n+        push    $r23\n+        push    $r24\n+        push    $r25\n+        push    $r26\n+        push    $r27\n+        jmpi    $r13\n+\n+        .global __prolog_$r28\n+__prolog_$r28:\n+        exi     $r13,$sp,0\n+        push    $r14\n+        push    $r15\n+        push    $r16\n+        push    $r17\n+        push    $r18\n+        push    $r19\n+        push    $r20\n+        push    $r21\n+        push    $r22\n+        push    $r23\n+        push    $r24\n+        push    $r25\n+        push    $r26\n+        push    $r27\n+        push    $r28\n+        jmpi    $r13"}, {"sha": "080e3231b716343f030191b14e60486c7106d85b", "filename": "libgcc/config/ft32/sfp-machine.h", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef939d6a96bde0f924152e6b9e22701c28f8880/libgcc%2Fconfig%2Fft32%2Fsfp-machine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef939d6a96bde0f924152e6b9e22701c28f8880/libgcc%2Fconfig%2Fft32%2Fsfp-machine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fft32%2Fsfp-machine.h?ref=fef939d6a96bde0f924152e6b9e22701c28f8880", "patch": "@@ -0,0 +1,61 @@\n+#define _FP_W_TYPE_SIZE\t\t32\n+#define _FP_W_TYPE\t\tunsigned long\n+#define _FP_WS_TYPE\t\tsigned long\n+#define _FP_I_TYPE\t\tlong\n+\n+/* The type of the result of a floating point comparison.  This must\n+   match `__libgcc_cmp_return__' in GCC for the target.  */\n+typedef int __gcc_CMPtype __attribute__ ((mode (__libgcc_cmp_return__)));\n+#define CMPtype __gcc_CMPtype\n+\n+#define _FP_MUL_MEAT_S(R,X,Y)\t\t\t\t\\\n+  _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S,R,X,Y,umul_ppmm)\n+#define _FP_MUL_MEAT_D(R,X,Y)\t\t\t\t\\\n+  _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D,R,X,Y,umul_ppmm)\n+#define _FP_MUL_MEAT_Q(R,X,Y)\t\t\t\t\\\n+  _FP_MUL_MEAT_4_wide(_FP_WFRACBITS_Q,R,X,Y,umul_ppmm)\n+\n+#define _FP_DIV_MEAT_S(R,X,Y)\t_FP_DIV_MEAT_1_loop(S,R,X,Y)\n+#define _FP_DIV_MEAT_D(R,X,Y)\t_FP_DIV_MEAT_2_udiv(D,R,X,Y)\n+#define _FP_DIV_MEAT_Q(R,X,Y)\t_FP_DIV_MEAT_4_udiv(Q,R,X,Y)\n+\n+#define _FP_NANFRAC_S\t\t((_FP_QNANBIT_S << 1) - 1)\n+#define _FP_NANFRAC_D\t\t((_FP_QNANBIT_D << 1) - 1), -1\n+#define _FP_NANFRAC_Q\t\t((_FP_QNANBIT_Q << 1) - 1), -1, -1, -1\n+#define _FP_NANSIGN_S\t\t0\n+#define _FP_NANSIGN_D\t\t0\n+#define _FP_NANSIGN_Q\t\t0\n+\n+#define _FP_KEEPNANFRACP 1\n+#define _FP_QNANNEGATEDP 0\n+\n+/* Someone please check this.  */\n+#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    if ((_FP_FRAC_HIGH_RAW_##fs(X) & _FP_QNANBIT_##fs)\t\t\\\n+\t&& !(_FP_FRAC_HIGH_RAW_##fs(Y) & _FP_QNANBIT_##fs))\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tR##_s = Y##_s;\t\t\t\t\t\t\\\n+\t_FP_FRAC_COPY_##wc(R,Y);\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tR##_s = X##_s;\t\t\t\t\t\t\\\n+\t_FP_FRAC_COPY_##wc(R,X);\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    R##_c = FP_CLS_NAN;\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* Not checked.  */\n+#define _FP_TININESS_AFTER_ROUNDING 0\n+\n+#define\t__LITTLE_ENDIAN\t1234\n+#define\t__BIG_ENDIAN\t4321\n+\n+# define __BYTE_ORDER __LITTLE_ENDIAN\n+\n+/* Define ALIASNAME as a strong alias for NAME.  */\n+# define strong_alias(name, aliasname) _strong_alias(name, aliasname)\n+# define _strong_alias(name, aliasname) \\\n+  extern __typeof (name) aliasname __attribute__ ((alias (#name)));\n+"}, {"sha": "8360bbffcc5fd284c9e23a8786110218cde9296b", "filename": "libgcc/config/ft32/t-ft32", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef939d6a96bde0f924152e6b9e22701c28f8880/libgcc%2Fconfig%2Fft32%2Ft-ft32", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef939d6a96bde0f924152e6b9e22701c28f8880/libgcc%2Fconfig%2Fft32%2Ft-ft32", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fft32%2Ft-ft32?ref=fef939d6a96bde0f924152e6b9e22701c28f8880", "patch": "@@ -0,0 +1,4 @@\n+LIB2ADD = $(srcdir)/config/ft32/epilog.S $(srcdir)/config/ft32/prolog.S\n+\n+crti-hw.o: $(srcdir)/config/ft32/crti-hw.S\n+\t$(crt_compile) -c -x assembler-with-cpp $<"}]}