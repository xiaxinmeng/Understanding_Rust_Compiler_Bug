{"sha": "e9b5e15f608f671b46cc81fc4c1ade09bd3fb9a0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTliNWUxNWY2MDhmNjcxYjQ2Y2M4MWZjNGMxYWRlMDliZDNmYjlhMA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-01-12T00:14:18Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-01-12T00:14:18Z"}, "message": "(fold, truth_andor): Don't apply distributive law when it would change evaluation order.\n\n(fold, truth_andor): Don't apply distributive law when it would change\nevaluation order.\nClean up code a bit to improve flow.\n\nFrom-SVN: r6381", "tree": {"sha": "ca708672a74c0613bf323c16d3d6ac9708dde487", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca708672a74c0613bf323c16d3d6ac9708dde487"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9b5e15f608f671b46cc81fc4c1ade09bd3fb9a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9b5e15f608f671b46cc81fc4c1ade09bd3fb9a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9b5e15f608f671b46cc81fc4c1ade09bd3fb9a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9b5e15f608f671b46cc81fc4c1ade09bd3fb9a0/comments", "author": null, "committer": null, "parents": [{"sha": "212ac20cebe99703f9046cc173839f4a2dcc3f09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/212ac20cebe99703f9046cc173839f4a2dcc3f09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/212ac20cebe99703f9046cc173839f4a2dcc3f09"}], "stats": {"total": 92, "additions": 50, "deletions": 42}, "files": [{"sha": "d370e520fbdf96b7f775048123e5952ad016be43", "filename": "gcc/fold-const.c", "status": "modified", "additions": 50, "deletions": 42, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5e15f608f671b46cc81fc4c1ade09bd3fb9a0/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5e15f608f671b46cc81fc4c1ade09bd3fb9a0/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=e9b5e15f608f671b46cc81fc4c1ade09bd3fb9a0", "patch": "@@ -4121,53 +4121,61 @@ fold (expr)\n \treturn omit_one_operand (type, arg1, arg0);\n \n     truth_andor:\n+      /* We only do these simplifications if we are optimizing.  */\n+      if (!optimize)\n+\treturn t;\n+\n+      /* Check for things like (A || B) && (A || C).  We can convert this\n+\t to A || (B && C).  Note that either operator can be any of the four\n+\t truth and/or operations and the transformation will still be\n+\t valid.   Also note that we only care about order for the\n+\t ANDIF and ORIF operators.  */\n+      if (TREE_CODE (arg0) == TREE_CODE (arg1)\n+\t  && (TREE_CODE (arg0) == TRUTH_ANDIF_EXPR\n+\t      || TREE_CODE (arg0) == TRUTH_ORIF_EXPR\n+\t      || TREE_CODE (arg0) == TRUTH_AND_EXPR\n+\t      || TREE_CODE (arg0) == TRUTH_OR_EXPR))\n+\t{\n+\t  tree a00 = TREE_OPERAND (arg0, 0);\n+\t  tree a01 = TREE_OPERAND (arg0, 1);\n+\t  tree a10 = TREE_OPERAND (arg1, 0);\n+\t  tree a11 = TREE_OPERAND (arg1, 1);\n+\t  int commutative = ((TREE_CODE (arg0) == TRUTH_OR_EXPR\n+\t\t\t      || TREE_CODE (arg0) == TRUTH_AND_EXPR)\n+\t\t\t     && (code == TRUTH_AND_EXPR\n+\t\t\t\t || code == TRUTH_OR_EXPR));\n+\n+\t  if (operand_equal_p (a00, a10, 0))\n+\t    return fold (build (TREE_CODE (arg0), type, a00,\n+\t\t\t\tfold (build (code, type, a01, a11))));\n+\t  else if (commutative && operand_equal_p (a00, a11, 0))\n+\t    return fold (build (TREE_CODE (arg0), type, a00,\n+\t\t\t\tfold (build (code, type, a01, a10))));\n+\t  else if (commutative && operand_equal_p (a01, a10, 0))\n+\t    return fold (build (TREE_CODE (arg0), type, a01,\n+\t\t\t\tfold (build (code, type, a00, a11))));\n+\n+\t  /* This case if tricky because we must either have commutative\n+\t     operators or else A10 must not have side-effects.  */\n+\n+\t  else if ((commutative || ! TREE_SIDE_EFFECTS (a10))\n+\t\t   && operand_equal_p (a01, a11, 0))\n+\t    return fold (build (TREE_CODE (arg0), type,\n+\t\t\t\tfold (build (code, type, a00, a10)),\n+\t\t\t\ta01));\n+\t}\n+\n       /* Check for the possibility of merging component references.  If our\n \t lhs is another similar operation, try to merge its rhs with our\n \t rhs.  Then try to merge our lhs and rhs.  */\n-      if (optimize)\n-\t{\n-\t  if (TREE_CODE (arg0) == code)\n-\t    {\n-\t      tem = fold_truthop (code, type,\n-\t\t\t\t  TREE_OPERAND (arg0, 1), arg1);\n-\t      if (tem)\n-\t\treturn fold (build (code, type, TREE_OPERAND (arg0, 0), tem));\n-\t    }\n+      if (TREE_CODE (arg0) == code\n+\t  && 0 != (tem = fold_truthop (code, type,\n+\t\t\t\t       TREE_OPERAND (arg0, 1), arg1)))\n+\treturn fold (build (code, type, TREE_OPERAND (arg0, 0), tem));\n \n-\t  /* Check for things like (A || B) && (A || C).  We can convert\n-\t     this to A || (B && C).  Note that either operator can be any of\n-\t     the four truth and/or operations and the transformation will\n-\t     still be valid.  */\n-\t  if (TREE_CODE (arg0) == TREE_CODE (arg1)\n-\t      && (TREE_CODE (arg0) == TRUTH_ANDIF_EXPR\n-\t\t  || TREE_CODE (arg0) == TRUTH_ORIF_EXPR\n-\t\t  || TREE_CODE (arg0) == TRUTH_AND_EXPR\n-\t\t  || TREE_CODE (arg0) == TRUTH_OR_EXPR))\n-\t    {\n-\t      tree a00 = TREE_OPERAND (arg0, 0);\n-\t      tree a01 = TREE_OPERAND (arg0, 1);\n-\t      tree a10 = TREE_OPERAND (arg1, 0);\n-\t      tree a11 = TREE_OPERAND (arg1, 1);\n-\t      tree common = 0, op0, op1;\n-\n-\t      if (operand_equal_p (a00, a10, 0))\n-\t\tcommon = a00, op0 = a01, op1 = a11;\n-\t      else if (operand_equal_p (a00, a11, 0))\n-\t\tcommon = a00, op0 = a01, op1 = a10;\n-\t      else if (operand_equal_p (a01, a10, 0))\n-\t\tcommon = a01, op0 = a00, op1 = a11;\n-\t      else if (operand_equal_p (a01, a11, 0))\n-\t\tcommon = a01, op0 = a00, op1 = a10;\n-\n-\t      if (common)\n-\t\treturn fold (build (TREE_CODE (arg0), type, common,\n-\t\t\t\t    fold (build (code, type, op0, op1))));\n-\t    }\n+      if ((tem = fold_truthop (code, type, arg0, arg1)) != 0)\n+\treturn tem;\n \n-\t  tem = fold_truthop (code, type, arg0, arg1);\n-\t  if (tem)\n-\t    return tem;\n-\t}\n       return t;\n \n     case TRUTH_ORIF_EXPR:"}]}