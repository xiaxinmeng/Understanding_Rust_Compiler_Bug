{"sha": "e1834b5a6fed17915ed3edadf2302157f2d19053", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTE4MzRiNWE2ZmVkMTc5MTVlZDNlZGFkZjIzMDIxNTdmMmQxOTA1Mw==", "commit": {"author": {"name": "Robert Lipe", "email": "robertl@dgii.com", "date": "1998-03-10T22:07:48Z"}, "committer": {"name": "Robert Lipe", "email": "robertl@gcc.gnu.org", "date": "1998-03-10T22:07:48Z"}, "message": "980310-1.f, [...]: New tests from egcs-bugs archives.\n\n\t* g77.f-torture/compile/980310-1.f, g77.f-torture/compile/980310-2.f\n\tg77.f-torture/compile/980310-3.f, g77.f-torture/compile/980310-4.f\n\tg77.f-torture/compile/980310-6.f, g77.f-torture/compile/980310-7.f\n\tg77.f-torture/compile/980310-8.f: New tests from egcs-bugs archives.\n\t* g77.f-torture/execute/980310-5.f: New test from egcs-bugs archives.\n\nFrom-SVN: r18466", "tree": {"sha": "f10ba59c0e52e51511aa65ec24b1f5d822ac5e55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f10ba59c0e52e51511aa65ec24b1f5d822ac5e55"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e1834b5a6fed17915ed3edadf2302157f2d19053", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1834b5a6fed17915ed3edadf2302157f2d19053", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1834b5a6fed17915ed3edadf2302157f2d19053", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1834b5a6fed17915ed3edadf2302157f2d19053/comments", "author": null, "committer": null, "parents": [{"sha": "af9c2d8a254bb4859ea64382d97935a96248b37f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af9c2d8a254bb4859ea64382d97935a96248b37f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af9c2d8a254bb4859ea64382d97935a96248b37f"}], "stats": {"total": 853, "additions": 853, "deletions": 0}, "files": [{"sha": "ae099dc9d64985455602579071fa88d30e901e11", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1834b5a6fed17915ed3edadf2302157f2d19053/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1834b5a6fed17915ed3edadf2302157f2d19053/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e1834b5a6fed17915ed3edadf2302157f2d19053", "patch": "@@ -1,3 +1,10 @@\n+Wed Mar 11 00:03:49 1998  Robert Lipe  <robertl@dgii.com>\n+\n+\t* g77.f-torture/compile/980310-1.f, g77.f-torture/compile/980310-2.f\n+\tg77.f-torture/compile/980310-3.f, g77.f-torture/compile/980310-4.f\n+\tg77.f-torture/compile/980310-6.f, g77.f-torture/compile/980310-7.f\n+\tg77.f-torture/compile/980310-8.f: New tests from egcs-bugs archives.\n+\t* g77.f-torture/execute/980310-5.f: New test from egcs-bugs archives.\n \n Tue Mar 10 00:31:51 1998  Alexandre Oliva   <oliva@dcc.unicamp.br>\n "}, {"sha": "32d77cad6cc45af506eca7bf976579a0ebd5df1d", "filename": "gcc/testsuite/g77.f-torture/compile/980310-1.f", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1834b5a6fed17915ed3edadf2302157f2d19053/gcc%2Ftestsuite%2Fg77.f-torture%2Fcompile%2F980310-1.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1834b5a6fed17915ed3edadf2302157f2d19053/gcc%2Ftestsuite%2Fg77.f-torture%2Fcompile%2F980310-1.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg77.f-torture%2Fcompile%2F980310-1.f?ref=e1834b5a6fed17915ed3edadf2302157f2d19053", "patch": "@@ -0,0 +1,24 @@\n+C Causes internal compiler error on egcs 1.0.1 on i586-pc-sco3.2v5.0.4\n+C To: egcs-bugs@cygnus.com\n+C Subject: backend case range problem/fix\n+C From: Dave Love <d.love@dl.ac.uk>\n+C Date: 02 Dec 1997 18:11:35 +0000\n+C Message-ID: <rzqpvnfboo8.fsf@djlvig.dl.ac.uk>\n+C \n+C The following Fortran test case aborts the compiler because\n+C tree_int_cst_lt dereferences a null tree; this is a regression from\n+C gcc 2.7.\n+C \n+C The patch is against egcs sources.  I don't know if it's still\n+C relevant to mainline gcc, which I no longer follow.\n+\n+      INTEGER N\n+      READ(*,*) N\n+      SELECT CASE (N)\n+        CASE (1:)\n+           WRITE(*,*) 'case 1'\n+        CASE (0)\n+           WRITE(*,*) 'case 0'\n+      END SELECT\n+      END\n+"}, {"sha": "5077c552da8875a084fbcfac960a7e86204196be", "filename": "gcc/testsuite/g77.f-torture/compile/980310-2.f", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1834b5a6fed17915ed3edadf2302157f2d19053/gcc%2Ftestsuite%2Fg77.f-torture%2Fcompile%2F980310-2.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1834b5a6fed17915ed3edadf2302157f2d19053/gcc%2Ftestsuite%2Fg77.f-torture%2Fcompile%2F980310-2.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg77.f-torture%2Fcompile%2F980310-2.f?ref=e1834b5a6fed17915ed3edadf2302157f2d19053", "patch": "@@ -0,0 +1,43 @@\n+C unable to confirm this bug on egcs 1.0.1 for i586-pc-sco3.2v5.0.4 robertl\n+C\n+C Date: Sat, 23 Aug 1997 00:47:53 -0400 (EDT)\n+C From: David Bristow <dbristow@lynx.dac.neu.edu>\n+C To: egcs-bugs@cygnus.com\n+C Subject: g77 crashes compiling Dungeon\n+C Message-ID: <Pine.OSF.3.91.970823003521.11281A-100000@lynx.dac.neu.edu>\n+C\n+C The following small segment of Dungeon (the adventure that became the \n+C commercial hit Zork) causes an internal error in f771.  The platform is \n+C i586-pc-linux-gnulibc1, the compiler is egcs-ss-970821 (g77-GNU Fortran \n+C 0.5.21-19970811)\n+C \n+C --cut here--cut here--cut here--cut here--cut here--cut here--\n+C g77 --verbose -fugly -fvxt -c subr_.f\n+C g77 version 0.5.21-19970811\n+C  gcc --verbose -fugly -fvxt -xf77 subr_.f -xnone -lf2c -lm\n+C Reading specs from /usr/lib/gcc-lib/i586-pc-linux-gnulibc1/egcs-2.90.01/specs\n+C gcc version egcs-2.90.01 970821 (gcc2-970802 experimental)\n+C  /usr/lib/gcc-lib/i586-pc-linux-gnulibc1/egcs-2.90.01/f771 subr_.f -fset-g77-defaults -quiet -dumpbase subr_.f -version -fversion -fugly -fvxt -o /tmp/cca23974.s\n+C f771: warning: -fugly is overloaded with meanings and likely to be removed;\n+C f771: warning: use only the specific -fugly-* options you need\n+C GNU F77 version egcs-2.90.01 970821 (gcc2-970802 experimental) (i586-pc-linux-gnulibc1) compiled by GNU C version egcs-2.90.01 970821 (gcc2-970802 experimental).\n+C GNU Fortran Front End version 0.5.21-19970811\n+C f/com.c:941: failed assertion `TYPE_PRECISION (type) <= TYPE_PRECISION (TREE_TYPE (e))'\n+C gcc: Internal compiler error: program f771 got fatal signal 6\n+C --cut here--cut here--cut here--cut here--cut here--cut here--\n+C \n+C Here's the FORTRAN code, it's basically a single subroutine from subr.f \n+C in the Dungeon source, slightly altered (the original calls RAN(), which \n+C doesn't exist in the g77 runtime)\n+C \n+C RND - Return a random integer mod n\n+C\n+\tINTEGER FUNCTION RND (N)\n+\tIMPLICIT INTEGER (A-Z)\n+\tREAL RAND\n+\tCOMMON /SEED/ RNSEED\n+\n+\tRND = RAND(RNSEED)*FLOAT(N)\n+\tRETURN\n+\n+\tEND"}, {"sha": "ddfb4c4bb9fb4690a5d1c013ed0be1e6ffc1e8b5", "filename": "gcc/testsuite/g77.f-torture/compile/980310-3.f", "status": "added", "additions": 259, "deletions": 0, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1834b5a6fed17915ed3edadf2302157f2d19053/gcc%2Ftestsuite%2Fg77.f-torture%2Fcompile%2F980310-3.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1834b5a6fed17915ed3edadf2302157f2d19053/gcc%2Ftestsuite%2Fg77.f-torture%2Fcompile%2F980310-3.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg77.f-torture%2Fcompile%2F980310-3.f?ref=e1834b5a6fed17915ed3edadf2302157f2d19053", "patch": "@@ -0,0 +1,259 @@\n+c\n+c\tThis demonstrates a problem with g77 and pic on x86 where \n+c \tegcs 1.0.1 and earlier will generate bogus assembler output.\n+c\tunfortunately, gas accepts the bogus acssembler output and \n+c\tgenerates code that almost works.\n+c\n+\n+\n+C Date: Wed, 17 Dec 1997 23:20:29 +0000\n+C From: Joao Cardoso <jcardoso@inescn.pt>\n+C To: egcs-bugs@cygnus.com\n+C Subject: egcs-1.0 f77 bug on OSR5\n+C When trying to compile the Fortran file that I enclose bellow,\n+C I got an assembler error:\n+C \n+C ./g77 -B./ -fpic -O -c scaleg.f\n+C /usr/tmp/cca002D8.s:123:syntax error at (\n+C \n+C ./g77 -B./ -fpic -O0 -c scaleg.f \n+C /usr/tmp/cca002EW.s:246:invalid operand combination: leal\n+C \n+C Compiling without the -fpic flag runs OK.\n+\n+      subroutine scaleg (n,ma,a,mb,b,low,igh,cscale,cperm,wk)\n+c\n+c     *****parameters:\n+      integer igh,low,ma,mb,n\n+      double precision a(ma,n),b(mb,n),cperm(n),cscale(n),wk(n,6)\n+c\n+c     *****local variables:\n+      integer i,ir,it,j,jc,kount,nr,nrp2\n+      double precision alpha,basl,beta,cmax,coef,coef2,coef5,cor,\n+     *                 ew,ewc,fi,fj,gamma,pgamma,sum,t,ta,tb,tc\n+c\n+c     *****fortran functions:\n+      double precision dabs, dlog10, dsign\n+c     float\n+c\n+c     *****subroutines called:\n+c     none\n+c\n+c     ---------------------------------------------------------------\n+c\n+c     *****purpose:\n+c     scales the matrices a and b in the generalized eigenvalue\n+c     problem a*x = (lambda)*b*x such that the magnitudes of the\n+c     elements of the submatrices of a and b (as specified by low\n+c     and igh) are close to unity in the least squares sense.\n+c     ref.:  ward, r. c., balancing the generalized eigenvalue\n+c     problem, siam j. sci. stat. comput., vol. 2, no. 2, june 1981,\n+c     141-152.\n+c\n+c     *****parameter description:\n+c\n+c     on input:\n+c\n+c       ma,mb   integer\n+c               row dimensions of the arrays containing matrices\n+c               a and b respectively, as declared in the main calling\n+c               program dimension statement;\n+c\n+c       n       integer\n+c               order of the matrices a and b;\n+c\n+c       a       real(ma,n)\n+c               contains the a matrix of the generalized eigenproblem\n+c               defined above;\n+c\n+c       b       real(mb,n)\n+c               contains the b matrix of the generalized eigenproblem\n+c               defined above;\n+c\n+c       low     integer\n+c               specifies the beginning -1 for the rows and\n+c               columns of a and b to be scaled;\n+c\n+c       igh     integer\n+c               specifies the ending -1 for the rows and columns\n+c               of a and b to be scaled;\n+c\n+c       cperm   real(n)\n+c               work array.  only locations low through igh are\n+c               referenced and altered by this subroutine;\n+c\n+c       wk      real(n,6)\n+c               work array that must contain at least 6*n locations.\n+c               only locations low through igh, n+low through n+igh,\n+c               ..., 5*n+low through 5*n+igh are referenced and\n+c               altered by this subroutine.\n+c\n+c     on output:\n+c\n+c       a,b     contain the scaled a and b matrices;\n+c\n+c       cscale  real(n)\n+c               contains in its low through igh locations the integer\n+c               exponents of 2 used for the column scaling factors.\n+c               the other locations are not referenced;\n+c\n+c       wk      contains in its low through igh locations the integer\n+c               exponents of 2 used for the row scaling factors.\n+c\n+c     *****algorithm notes:\n+c     none.\n+c\n+c     *****history:\n+c     written by r. c. ward.......\n+c     modified 8/86 by bobby bodenheimer so that if\n+c       sum = 0 (corresponding to the case where the matrix\n+c       doesn't need to be scaled) the routine returns.\n+c\n+c     ---------------------------------------------------------------\n+c\n+      if (low .eq. igh) go to 410\n+      do 210 i = low,igh\n+         wk(i,1) = 0.0d0\n+         wk(i,2) = 0.0d0\n+         wk(i,3) = 0.0d0\n+         wk(i,4) = 0.0d0\n+         wk(i,5) = 0.0d0\n+         wk(i,6) = 0.0d0\n+         cscale(i) = 0.0d0\n+         cperm(i) = 0.0d0\n+  210 continue\n+c\n+c     compute right side vector in resulting linear equations\n+c\n+      basl = dlog10(2.0d0)\n+      do 240 i = low,igh\n+         do 240 j = low,igh\n+            tb = b(i,j)\n+            ta = a(i,j)\n+            if (ta .eq. 0.0d0) go to 220\n+            ta = dlog10(dabs(ta)) / basl\n+  220       continue\n+            if (tb .eq. 0.0d0) go to 230\n+            tb = dlog10(dabs(tb)) / basl\n+  230       continue\n+            wk(i,5) = wk(i,5) - ta - tb\n+            wk(j,6) = wk(j,6) - ta - tb\n+  240 continue\n+      nr = igh-low+1\n+      coef = 1.0d0/float(2*nr)\n+      coef2 = coef*coef\n+      coef5 = 0.5d0*coef2\n+      nrp2 = nr+2\n+      beta = 0.0d0\n+      it = 1\n+c\n+c     start generalized conjugate gradient iteration\n+c\n+  250 continue\n+      ew = 0.0d0\n+      ewc = 0.0d0\n+      gamma = 0.0d0\n+      do 260 i = low,igh\n+         gamma = gamma + wk(i,5)*wk(i,5) + wk(i,6)*wk(i,6)\n+         ew = ew + wk(i,5)\n+         ewc = ewc + wk(i,6)\n+  260 continue\n+      gamma = coef*gamma - coef2*(ew**2 + ewc**2)\n+     +        - coef5*(ew - ewc)**2\n+      if (it .ne. 1) beta = gamma / pgamma\n+      t = coef5*(ewc - 3.0d0*ew)\n+      tc = coef5*(ew - 3.0d0*ewc)\n+      do 270 i = low,igh\n+         wk(i,2) = beta*wk(i,2) + coef*wk(i,5) + t\n+         cperm(i) = beta*cperm(i) + coef*wk(i,6) + tc\n+  270 continue\n+c\n+c     apply matrix to vector\n+c\n+      do 300 i = low,igh\n+         kount = 0\n+         sum = 0.0d0\n+         do 290 j = low,igh\n+            if (a(i,j) .eq. 0.0d0) go to 280\n+            kount = kount+1\n+            sum = sum + cperm(j)\n+  280       continue\n+            if (b(i,j) .eq. 0.0d0) go to 290\n+            kount = kount+1\n+            sum = sum + cperm(j)\n+  290    continue\n+         wk(i,3) = float(kount)*wk(i,2) + sum\n+  300 continue\n+      do 330 j = low,igh\n+         kount = 0\n+         sum = 0.0d0\n+         do 320 i = low,igh\n+            if (a(i,j) .eq. 0.0d0) go to 310\n+            kount = kount+1\n+            sum = sum + wk(i,2)\n+  310       continue\n+            if (b(i,j) .eq. 0.0d0) go to 320\n+            kount = kount+1\n+            sum = sum + wk(i,2)\n+  320    continue\n+         wk(j,4) = float(kount)*cperm(j) + sum\n+  330 continue\n+      sum = 0.0d0\n+      do 340 i = low,igh\n+         sum = sum + wk(i,2)*wk(i,3) + cperm(i)*wk(i,4)\n+  340 continue\n+      if(sum.eq.0.0d0) return\n+      alpha = gamma / sum\n+c\n+c     determine correction to current iterate\n+c\n+      cmax = 0.0d0\n+      do 350 i = low,igh\n+         cor = alpha * wk(i,2)\n+         if (dabs(cor) .gt. cmax) cmax = dabs(cor)\n+         wk(i,1) = wk(i,1) + cor\n+         cor = alpha * cperm(i)\n+         if (dabs(cor) .gt. cmax) cmax = dabs(cor)\n+         cscale(i) = cscale(i) + cor\n+  350 continue\n+      if (cmax .lt. 0.5d0) go to 370\n+      do 360 i = low,igh\n+         wk(i,5) = wk(i,5) - alpha*wk(i,3)\n+         wk(i,6) = wk(i,6) - alpha*wk(i,4)\n+  360 continue\n+      pgamma = gamma\n+      it = it+1\n+      if (it .le. nrp2) go to 250\n+c\n+c     end generalized conjugate gradient iteration\n+c\n+  370 continue\n+      do 380 i = low,igh\n+         ir = wk(i,1) + dsign(0.5d0,wk(i,1))\n+         wk(i,1) = ir\n+         jc = cscale(i) + dsign(0.5d0,cscale(i))\n+         cscale(i) = jc\n+  380 continue\n+c\n+c     scale a and b\n+c\n+      do 400 i = 1,igh\n+         ir = wk(i,1)\n+         fi = 2.0d0**ir\n+         if (i .lt. low) fi = 1.0d0\n+         do 400 j =low,n\n+            jc = cscale(j)\n+            fj = 2.0d0**jc\n+            if (j .le. igh) go to 390\n+            if (i .lt. low) go to 400\n+            fj = 1.0d0\n+  390       continue\n+            a(i,j) = a(i,j)*fi*fj\n+            b(i,j) = b(i,j)*fi*fj\n+  400 continue\n+  410 continue\n+      return\n+c\n+c     last line of scaleg\n+c\n+      end"}, {"sha": "b169845e63472f3ba8abb79679bb59d7a6a956fd", "filename": "gcc/testsuite/g77.f-torture/compile/980310-4.f", "status": "added", "additions": 348, "deletions": 0, "changes": 348, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1834b5a6fed17915ed3edadf2302157f2d19053/gcc%2Ftestsuite%2Fg77.f-torture%2Fcompile%2F980310-4.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1834b5a6fed17915ed3edadf2302157f2d19053/gcc%2Ftestsuite%2Fg77.f-torture%2Fcompile%2F980310-4.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg77.f-torture%2Fcompile%2F980310-4.f?ref=e1834b5a6fed17915ed3edadf2302157f2d19053", "patch": "@@ -0,0 +1,348 @@\n+\n+C To: egcs-bugs@cygnus.com\n+C Subject: -fPIC problem showing up with fortran on x86\n+C From: Dave Love <d.love@dl.ac.uk>\n+C Date: 19 Dec 1997 19:31:41 +0000\n+C \n+C \n+C This illustrates a long-standing problem noted at the end of the g77\n+C `Actual Bugs' info node and thought to be in the back end.  Although\n+C the report is against gcc 2.7 I can reproduce it (specifically on\n+C redhat 4.2) with the 971216 egcs snapshot.\n+C \n+C g77 version 0.5.21\n+C  gcc -v -fnull-version -o /tmp/gfa00415 -xf77-cpp-input /tmp/gfa00415.f -xnone\n+C -lf2c -lm\n+C\n+\n+C ------------\n+      subroutine dqage(f,a,b,epsabs,epsrel,limit,result,abserr,\n+     *   neval,ier,alist,blist,rlist,elist,iord,last)\n+C     --------------------------------------------------\n+C\n+C     Modified Feb 1989 by Barry W. Brown to eliminate key\n+C     as argument (use key=1) and to eliminate all Fortran\n+C     output.\n+C\n+C     Purpose: to make this routine usable from within S.\n+C\n+C     --------------------------------------------------\n+c***begin prologue  dqage\n+c***date written   800101   (yymmdd)\n+c***revision date  830518   (yymmdd)\n+c***category no.  h2a1a1\n+c***keywords  automatic integrator, general-purpose,\n+c             integrand examinator, globally adaptive,\n+c             gauss-kronrod\n+c***author  piessens,robert,appl. math. & progr. div. - k.u.leuven\n+c           de doncker,elise,appl. math. & progr. div. - k.u.leuven\n+c***purpose  the routine calculates an approximation result to a given\n+c            definite integral   i = integral of f over (a,b),\n+c            hopefully satisfying following claim for accuracy\n+c            abs(i-reslt).le.max(epsabs,epsrel*abs(i)).\n+c***description\n+c\n+c        computation of a definite integral\n+c        standard fortran subroutine\n+c        double precision version\n+c\n+c        parameters\n+c         on entry\n+c            f      - double precision\n+c                     function subprogram defining the integrand\n+c                     function f(x). the actual name for f needs to be\n+c                     declared e x t e r n a l in the driver program.\n+c\n+c            a      - double precision\n+c                     lower limit of integration\n+c\n+c            b      - double precision\n+c                     upper limit of integration\n+c\n+c            epsabs - double precision\n+c                     absolute accuracy requested\n+c            epsrel - double precision\n+c                     relative accuracy requested\n+c                     if  epsabs.le.0\n+c                     and epsrel.lt.max(50*rel.mach.acc.,0.5d-28),\n+c                     the routine will end with ier = 6.\n+c\n+c            key    - integer\n+c                     key for choice of local integration rule\n+c                     a gauss-kronrod pair is used with\n+c                          7 - 15 points if key.lt.2,\n+c                         10 - 21 points if key = 2,\n+c                         15 - 31 points if key = 3,\n+c                         20 - 41 points if key = 4,\n+c                         25 - 51 points if key = 5,\n+c                         30 - 61 points if key.gt.5.\n+c\n+c            limit  - integer\n+c                     gives an upperbound on the number of subintervals\n+c                     in the partition of (a,b), limit.ge.1.\n+c\n+c         on return\n+c            result - double precision\n+c                     approximation to the integral\n+c\n+c            abserr - double precision\n+c                     estimate of the modulus of the absolute error,\n+c                     which should equal or exceed abs(i-result)\n+c\n+c            neval  - integer\n+c                     number of integrand evaluations\n+c\n+c            ier    - integer\n+c                     ier = 0 normal and reliable termination of the\n+c                             routine. it is assumed that the requested\n+c                             accuracy has been achieved.\n+c                     ier.gt.0 abnormal termination of the routine\n+c                             the estimates for result and error are\n+c                             less reliable. it is assumed that the\n+c                             requested accuracy has not been achieved.\n+c            error messages\n+c                     ier = 1 maximum number of subdivisions allowed\n+c                             has been achieved. one can allow more\n+c                             subdivisions by increasing the value\n+c                             of limit.\n+c                             however, if this yields no improvement it\n+c                             is rather advised to analyze the integrand\n+c                             in order to determine the integration\n+c                             difficulties. if the position of a local\n+c                             difficulty can be determined(e.g.\n+c                             singularity, discontinuity within the\n+c                             interval) one will probably gain from\n+c                             splitting up the interval at this point\n+c                             and calling the integrator on the\n+c                             subranges. if possible, an appropriate\n+c                             special-purpose integrator should be used\n+c                             which is designed for handling the type of\n+c                             difficulty involved.\n+c                         = 2 the occurrence of roundoff error is\n+c                             detected, which prevents the requested\n+c                             tolerance from being achieved.\n+c                         = 3 extremely bad integrand behaviour occurs\n+c                             at some points of the integration\n+c                             interval.\n+c                         = 6 the input is invalid, because\n+c                             (epsabs.le.0 and\n+c                              epsrel.lt.max(50*rel.mach.acc.,0.5d-28),\n+c                             result, abserr, neval, last, rlist(1) ,\n+c                             elist(1) and iord(1) are set to zero.\n+c                             alist(1) and blist(1) are set to a and b\n+c                             respectively.\n+c\n+c            alist   - double precision\n+c                      vector of dimension at least limit, the first\n+c                       last  elements of which are the left\n+c                      end points of the subintervals in the partition\n+c                      of the given integration range (a,b)\n+c\n+c            blist   - double precision\n+c                      vector of dimension at least limit, the first\n+c                       last  elements of which are the right\n+c                      end points of the subintervals in the partition\n+c                      of the given integration range (a,b)\n+c\n+c            rlist   - double precision\n+c                      vector of dimension at least limit, the first\n+c                       last  elements of which are the\n+c                      integral approximations on the subintervals\n+c\n+c            elist   - double precision\n+c                      vector of dimension at least limit, the first\n+c                       last  elements of which are the moduli of the\n+c                      absolute error estimates on the subintervals\n+c\n+c            iord    - integer\n+c                      vector of dimension at least limit, the first k\n+c                      elements of which are pointers to the\n+c                      error estimates over the subintervals,\n+c                      such that elist(iord(1)), ...,\n+c                      elist(iord(k)) form a decreasing sequence,\n+c                      with k = last if last.le.(limit/2+2), and\n+c                      k = limit+1-last otherwise\n+c\n+c            last    - integer\n+c                      number of subintervals actually produced in the\n+c                      subdivision process\n+c\n+c***references  (none)\n+c***routines called  d1mach,dqk15,dqk21,dqk31,\n+c                    dqk41,dqk51,dqk61,dqpsrt\n+c***end prologue  dqage\n+c\n+      double precision a,abserr,alist,area,area1,area12,area2,a1,a2,b,\n+     *  blist,b1,b2,dabs,defabs,defab1,defab2,dmax1,d1mach,elist,epmach,\n+     *  epsabs,epsrel,errbnd,errmax,error1,error2,erro12,errsum,f,\n+     *  resabs,result,rlist,uflow\n+      integer ier,iord,iroff1,iroff2,k,last,limit,maxerr,neval,\n+     *  nrmax\n+c\n+      dimension alist(limit),blist(limit),elist(limit),iord(limit),\n+     *  rlist(limit)\n+c\n+      external f\n+c\n+c            list of major variables\n+c            -----------------------\n+c\n+c           alist     - list of left end points of all subintervals\n+c                       considered up to now\n+c           blist     - list of right end points of all subintervals\n+c                       considered up to now\n+c           rlist(i)  - approximation to the integral over\n+c                      (alist(i),blist(i))\n+c           elist(i)  - error estimate applying to rlist(i)\n+c           maxerr    - pointer to the interval with largest\n+c                       error estimate\n+c           errmax    - elist(maxerr)\n+c           area      - sum of the integrals over the subintervals\n+c           errsum    - sum of the errors over the subintervals\n+c           errbnd    - requested accuracy max(epsabs,epsrel*\n+c                       abs(result))\n+c           *****1    - variable for the left subinterval\n+c           *****2    - variable for the right subinterval\n+c           last      - index for subdivision\n+c\n+c\n+c           machine dependent constants\n+c           ---------------------------\n+c\n+c           epmach  is the largest relative spacing.\n+c           uflow  is the smallest positive magnitude.\n+c\n+c***first executable statement  dqage\n+      epmach = d1mach(4)\n+      uflow = d1mach(1)\n+c\n+c           test on validity of parameters\n+c           ------------------------------\n+c\n+      ier = 0\n+      neval = 0\n+      last = 0\n+      result = 0.0d+00\n+      abserr = 0.0d+00\n+      alist(1) = a\n+      blist(1) = b\n+      rlist(1) = 0.0d+00\n+      elist(1) = 0.0d+00\n+      iord(1) = 0\n+      if(epsabs.le.0.0d+00.and.\n+     *  epsrel.lt.dmax1(0.5d+02*epmach,0.5d-28)) ier = 6\n+      if(ier.eq.6) go to 999\n+c\n+c           first approximation to the integral\n+c           -----------------------------------\n+c\n+      neval = 0\n+      call dqk15(f,a,b,result,abserr,defabs,resabs)\n+      last = 1\n+      rlist(1) = result\n+      elist(1) = abserr\n+      iord(1) = 1\n+c\n+c           test on accuracy.\n+c\n+      errbnd = dmax1(epsabs,epsrel*dabs(result))\n+      if(abserr.le.0.5d+02*epmach*defabs.and.abserr.gt.errbnd) ier = 2\n+      if(limit.eq.1) ier = 1\n+      if(ier.ne.0.or.(abserr.le.errbnd.and.abserr.ne.resabs)\n+     *  .or.abserr.eq.0.0d+00) go to 60\n+c\n+c           initialization\n+c           --------------\n+c\n+c\n+      errmax = abserr\n+      maxerr = 1\n+      area = result\n+      errsum = abserr\n+      nrmax = 1\n+      iroff1 = 0\n+      iroff2 = 0\n+c\n+c           main do-loop\n+c           ------------\n+c\n+      do 30 last = 2,limit\n+c\n+c           bisect the subinterval with the largest error estimate.\n+c\n+        a1 = alist(maxerr)\n+        b1 = 0.5d+00*(alist(maxerr)+blist(maxerr))\n+        a2 = b1\n+        b2 = blist(maxerr)\n+        call dqk15(f,a1,b1,area1,error1,resabs,defab1)\n+        call dqk15(f,a2,b2,area2,error2,resabs,defab2)\n+c\n+c           improve previous approximations to integral\n+c           and error and test for accuracy.\n+c\n+        neval = neval+1\n+        area12 = area1+area2\n+        erro12 = error1+error2\n+        errsum = errsum+erro12-errmax\n+        area = area+area12-rlist(maxerr)\n+        if(defab1.eq.error1.or.defab2.eq.error2) go to 5\n+        if(dabs(rlist(maxerr)-area12).le.0.1d-04*dabs(area12)\n+     *  .and.erro12.ge.0.99d+00*errmax) iroff1 = iroff1+1\n+        if(last.gt.10.and.erro12.gt.errmax) iroff2 = iroff2+1\n+    5   rlist(maxerr) = area1\n+        rlist(last) = area2\n+        errbnd = dmax1(epsabs,epsrel*dabs(area))\n+        if(errsum.le.errbnd) go to 8\n+c\n+c           test for roundoff error and eventually set error flag.\n+c\n+        if(iroff1.ge.6.or.iroff2.ge.20) ier = 2\n+c\n+c           set error flag in the case that the number of subintervals\n+c           equals limit.\n+c\n+        if(last.eq.limit) ier = 1\n+c\n+c           set error flag in the case of bad integrand behaviour\n+c           at a point of the integration range.\n+c\n+        if(dmax1(dabs(a1),dabs(b2)).le.(0.1d+01+0.1d+03*\n+     *  epmach)*(dabs(a2)+0.1d+04*uflow)) ier = 3\n+c\n+c           append the newly-created intervals to the list.\n+c\n+    8   if(error2.gt.error1) go to 10\n+        alist(last) = a2\n+        blist(maxerr) = b1\n+        blist(last) = b2\n+        elist(maxerr) = error1\n+        elist(last) = error2\n+        go to 20\n+   10   alist(maxerr) = a2\n+        alist(last) = a1\n+        blist(last) = b1\n+        rlist(maxerr) = area2\n+        rlist(last) = area1\n+        elist(maxerr) = error2\n+        elist(last) = error1\n+c\n+c           call subroutine dqpsrt to maintain the descending ordering\n+c           in the list of error estimates and select the subinterval\n+c           with the largest error estimate (to be bisected next).\n+c\n+   20   call dqpsrt(limit,last,maxerr,errmax,elist,iord,nrmax)\n+c ***jump out of do-loop\n+        if(ier.ne.0.or.errsum.le.errbnd) go to 40\n+   30 continue\n+c\n+c           compute final result.\n+c           ---------------------\n+c\n+   40 result = 0.0d+00\n+      do 50 k=1,last\n+        result = result+rlist(k)\n+   50 continue\n+      abserr = errsum\n+   60 neval = 30*neval+15\n+  999 return\n+      end"}, {"sha": "fd91500eea8d671f0548de406e2461bae3bf0be0", "filename": "gcc/testsuite/g77.f-torture/compile/980310-6.f", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1834b5a6fed17915ed3edadf2302157f2d19053/gcc%2Ftestsuite%2Fg77.f-torture%2Fcompile%2F980310-6.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1834b5a6fed17915ed3edadf2302157f2d19053/gcc%2Ftestsuite%2Fg77.f-torture%2Fcompile%2F980310-6.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg77.f-torture%2Fcompile%2F980310-6.f?ref=e1834b5a6fed17915ed3edadf2302157f2d19053", "patch": "@@ -0,0 +1,21 @@\n+C From: Norbert Conrad <Norbert.Conrad@hrz.uni-giessen.de>\n+C Message-Id: <199711131008.LAA12272@marvin.hrz.uni-giessen.de>\n+C Subject: 971105  g77 bug\n+C To: egcs-bugs@cygnus.com\n+C Date: Thu, 13 Nov 1997 11:08:19 +0100 (CET)\n+\n+C I found a bug in g77 in snapshot 971105\n+\n+      subroutine ai (a)\n+      dimension a(-1:*)\n+      return\n+      end\n+C ai.f: In subroutine `ai':\n+C ai.f:1: \n+C          subroutine ai (a)\n+C                         ^\n+C Array `a' at (^) is too large to handle\n+C \n+C This happens whenever the lower index boundary is negative and the upper index\n+C boundary is '*'. \n+"}, {"sha": "9cfbaed692a9897c875f4c27731705d1643e7a81", "filename": "gcc/testsuite/g77.f-torture/compile/980310-7.f", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1834b5a6fed17915ed3edadf2302157f2d19053/gcc%2Ftestsuite%2Fg77.f-torture%2Fcompile%2F980310-7.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1834b5a6fed17915ed3edadf2302157f2d19053/gcc%2Ftestsuite%2Fg77.f-torture%2Fcompile%2F980310-7.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg77.f-torture%2Fcompile%2F980310-7.f?ref=e1834b5a6fed17915ed3edadf2302157f2d19053", "patch": "@@ -0,0 +1,50 @@\n+C From: \"David C. Doherty\" <doherty@networkcs.com>\n+C Message-Id: <199711171846.MAA27947@uh.msc.edu>\n+C Subject: g77: auto arrays + goto = no go\n+C To: egcs-bugs@cygnus.com\n+C Date: Mon, 17 Nov 1997 12:46:27 -0600 (CST)\n+\n+C I sent the following to fortran@gnu.ai.mit.edu, and Dave Love\n+C replied that he was able to reproduce it on rs6000-aix; not on\n+C others. He suggested that I send it to egcs-bugs. \n+\n+C Hi - I've observed the following behavior regarding \n+C automatic arrays and gotos.  Seems similar to what I found\n+C in the docs about computed gotos (but not exactly the same).\n+C \n+C I suspect from the nature of the error msg that it's in the GBE.\n+C \n+C I'm using egcs-971105, under linux-ppc.\n+C \n+C I also observed the same in g77-0.5.19 (and gcc 2.7.2?).\n+C \n+C I'd appreciate any advice on this.  thanks for the great work.\n+C --\n+C >cat testg77.f\n+      subroutine testg77(n, a)\n+c\n+      implicit none\n+c\n+      integer n\n+      real a(n)\n+      real b(n)\n+      integer i\n+c\n+      do i = 1, 10\n+        if (i .gt. 4) goto 100\n+        write(0, '(i2)')i\n+      enddo\n+c\n+      goto 200\n+100   continue\n+200   continue\n+c\n+      return\n+      end\n+C >g77 -c testg77.f\n+C testg77.f: In subroutine `testg77':\n+C testg77.f:19: label `200' used before containing binding contour\n+C testg77.f:18: label `100' used before containing binding contour\n+C --\n+C If I comment out the b(n) line or replace it with, e.g., b(10),\n+C it compiles fine."}, {"sha": "9501012f60abc27cfe6fee6341783790d112d054", "filename": "gcc/testsuite/g77.f-torture/compile/980310-8.f", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1834b5a6fed17915ed3edadf2302157f2d19053/gcc%2Ftestsuite%2Fg77.f-torture%2Fcompile%2F980310-8.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1834b5a6fed17915ed3edadf2302157f2d19053/gcc%2Ftestsuite%2Fg77.f-torture%2Fcompile%2F980310-8.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg77.f-torture%2Fcompile%2F980310-8.f?ref=e1834b5a6fed17915ed3edadf2302157f2d19053", "patch": "@@ -0,0 +1,39 @@\n+C To: egcs-bugs@cygnus.com\n+C Subject: egcs-g77 and array indexing\n+C Reply-To: etseidl@jutland.ca.sandia.gov\n+C Date: Wed, 26 Nov 1997 10:38:27 -0800\n+C From: Edward Seidl <etseidl@jutland.ca.sandia.gov>\n+C\t\n+C\tI have some horrible spaghetti code I'm trying compile with egcs-g77,\n+C\tbut it's puking on code like the example below.  I have no idea if it's\n+C\tlegal fortran or not, and I'm in no position to change it.  All I do know\n+C\tis it compiles with a number of other compilers, including f2c and\n+C\tg77-0.5.19.1/gcc-2.7.2.1.  When I try to compile with egcs-2.90.18 971122\n+C\tI get the following (on both i686-pc-linux-gnu and alphaev56-unknown-linux-gnu):\n+C\t\n+C\tfoo.f: In subroutine `foobar':\n+C\tfoo.f:11: \n+C\t         subroutine foobar(norb,nnorb)\n+C\t                           ^\n+C\tArray `norb' at (^) is too large to handle\n+\n+      program foo\n+      implicit integer(A-Z)\n+      dimension norb(6)\n+      nnorb=6\n+\n+      call foobar(norb,nnorb)\n+\n+      stop\n+      end\n+\n+      subroutine foobar(norb,nnorb)\n+      implicit integer(A-Z)\n+      dimension norb(-1:*)\n+\n+      do 10 i=-1,nnorb-2\n+        norb(i) = i+999\n+  10  continue\n+\n+      return\n+      end"}, {"sha": "a496cf7c321960325241ef734827703483873b89", "filename": "gcc/testsuite/g77.f-torture/execute/980310-5.f", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1834b5a6fed17915ed3edadf2302157f2d19053/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2F980310-5.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1834b5a6fed17915ed3edadf2302157f2d19053/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2F980310-5.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2F980310-5.f?ref=e1834b5a6fed17915ed3edadf2302157f2d19053", "patch": "@@ -0,0 +1,62 @@\n+C Confirmed on EGCS 1.0.1 on i586-pc-sco3.2v5.0.4\n+C To: egcs-bugs@cygnus.com\n+C Subject: [Vladimir Eltsov <ve@boojum.hut.fi>] bug with -fcaller-saves\n+C From: Dave Love <d.love@dl.ac.uk>\n+C Date: 29 Jan 1998 18:20:47 +0000\n+C Message-ID: <rzq67n3cfb4.fsf@djlvig.dl.ac.uk>\n+\n+C This appears to be a (non-critical?) backend problem reported as a g77\n+C bug.  I can reproduce it, but (only) with -O[2].  Any ideas other than\n+C `don't do that, then'? :-)\n+C \n+C ------- Start of forwarded message -------\n+C Date: Tue, 27 Jan 1998 19:25:19 +0200 (EET)\n+C From: Vladimir Eltsov <ve@boojum.hut.fi>\n+C To: fortran@gnu.org\n+C Subject: bug with -fcaller-saves\n+C Message-ID: <Pine.LNX.3.96.980127190257.1606A-100000@slon.hut.fi>\n+C MIME-Version: 1.0\n+C Content-Type: TEXT/PLAIN; charset=US-ASCII\n+C \n+C Hello!\n+C \n+C Following program would hang after printing 6 lines when compiled with \n+C 'g77 -O2 test.f' on x86 architecture, but would work OK when compiled with \n+C 'g77 -O2 -fno-caller-saves test.f' both for gnu and egcs variants of the\n+C compiler.\n+C \n+C Details follow:\n+C -------  test.f -------\n+      program test\n+      implicit double precision (a-h,o-z)\n+\n+      t = 0\n+C \tWas: tend=1.  Changed to shorten runtime. robertl\n+      tend = .0320d-3\n+      dt = 6d-7\n+      h = 0.314d-7\n+      k = 1\n+      ti = dt\n+\n+      do while (t.lt.tend)\n+         do while(t.lt.ti)\n+            if (t+h.gt.ti) then\n+               h = ti-t\n+            end if\n+            call fun(t,h)\n+         end do\n+         print *,k,t,t/5d-7\n+         k = k+1\n+         ti = k*dt\n+      end do\n+\n+      end\n+\n+      subroutine fun(t,h)\n+      implicit double precision (a-h,o-z)\n+\n+      t = t+h\n+      h = 0.314d-7\n+\n+      return\n+      end"}]}