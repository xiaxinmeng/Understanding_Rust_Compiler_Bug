{"sha": "3ce5f966ad256483220ae2d3ecbe9b0e1383fabd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2NlNWY5NjZhZDI1NjQ4MzIyMGFlMmQzZWNiZTliMGUxMzgzZmFiZA==", "commit": {"author": {"name": "Olivier Hainque", "email": "hainque@adacore.com", "date": "2007-04-06T09:40:22Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-04-06T09:40:22Z"}, "message": "trans.c (call_to_gnu): Return an expression with a COMPOUND_EXPR including the call instead of...\n\n2007-04-06  Olivier Hainque  <hainque@adacore.com>\n\t    Eric Botcazou <botcazou@adacore.com>\n\n\t* trans.c (call_to_gnu) <TYPE_RETURNS_BY_TARGET_PTR_P>: Return an\n\texpression with a COMPOUND_EXPR including the call instead of emitting\n\tthe call directly here.\n\t(gnat_to_gnu) <N_Slice>: Do not return a non-constant low bound if the\n\thigh bound is constant and the slice is empty.  Tidy.\n\t(tree_transform, case N_Op_Not): Handle properly the case where the\n\toperation applies to a private type whose full view is a modular type.\n\t(Case_Statement_To_gnu): If an alternative is an E_Constant with an\n\tAddress_Clause, use the associated Expression as the GNAT tree\n\trepresenting the choice value to ensure the corresponding GCC tree is\n\tof the proper kind.\n\t(maybe_stabilize_reference): Stabilize COMPOUND_EXPRs as a whole\n\tinstead of just the operands, as the base GCC stabilize_reference does.\n\t<CALL_EXPR>: New case. Directly stabilize the call if an lvalue is not\n\trequested; otherwise fail.\n\t(addressable_p) <COMPONENT_REF>: Do not test DECL_NONADDRESSABLE_P.\n\nFrom-SVN: r123608", "tree": {"sha": "9a7593fad819d9c81019f18c3864f35ac37f0c64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a7593fad819d9c81019f18c3864f35ac37f0c64"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ce5f966ad256483220ae2d3ecbe9b0e1383fabd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ce5f966ad256483220ae2d3ecbe9b0e1383fabd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ce5f966ad256483220ae2d3ecbe9b0e1383fabd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ce5f966ad256483220ae2d3ecbe9b0e1383fabd/comments", "author": {"login": "hainque", "id": 18735142, "node_id": "MDQ6VXNlcjE4NzM1MTQy", "avatar_url": "https://avatars.githubusercontent.com/u/18735142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hainque", "html_url": "https://github.com/hainque", "followers_url": "https://api.github.com/users/hainque/followers", "following_url": "https://api.github.com/users/hainque/following{/other_user}", "gists_url": "https://api.github.com/users/hainque/gists{/gist_id}", "starred_url": "https://api.github.com/users/hainque/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hainque/subscriptions", "organizations_url": "https://api.github.com/users/hainque/orgs", "repos_url": "https://api.github.com/users/hainque/repos", "events_url": "https://api.github.com/users/hainque/events{/privacy}", "received_events_url": "https://api.github.com/users/hainque/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4b437c6bb91baf785bd3f2c9db288eeb4aa38a49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b437c6bb91baf785bd3f2c9db288eeb4aa38a49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b437c6bb91baf785bd3f2c9db288eeb4aa38a49"}], "stats": {"total": 219, "additions": 143, "deletions": 76}, "files": [{"sha": "5f75aa6db14696ce896edc6a86db9d3f175f7a1f", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 143, "deletions": 76, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce5f966ad256483220ae2d3ecbe9b0e1383fabd/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce5f966ad256483220ae2d3ecbe9b0e1383fabd/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=3ce5f966ad256483220ae2d3ecbe9b0e1383fabd", "patch": "@@ -288,7 +288,7 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name,\n /* Perform initializations for this module.  */\n \n void\n-gnat_init_stmt_group ()\n+gnat_init_stmt_group (void)\n {\n   /* Initialize ourselves.  */\n   init_code_table ();\n@@ -1172,8 +1172,7 @@ Case_Statement_to_gnu (Node_Id gnat_node)\n \t    case N_Identifier:\n \t    case N_Expanded_Name:\n \t      /* This represents either a subtype range or a static value of\n-\t\t some kind; Ekind says which.  If a static value, fall through\n-\t\t to the next case.  */\n+\t\t some kind; Ekind says which.  */\n \t      if (IN (Ekind (Entity (gnat_choice)), Type_Kind))\n \t\t{\n \t\t  tree gnu_type = get_unpadded_type (Entity (gnat_choice));\n@@ -1182,6 +1181,29 @@ Case_Statement_to_gnu (Node_Id gnat_node)\n \t\t  gnu_high = fold (TYPE_MAX_VALUE (gnu_type));\n \t\t  break;\n \t\t}\n+\t      /* Static values are handled by the next case to which we'll\n+\t\t fallthrough.  If this is a constant with an address clause\n+\t\t attached, we need to get to the initialization expression\n+\t\t first, as the GCC tree for the entity might happen to be an\n+\t\t INDIRECT_REF otherwise.  */\n+\t      else if (Ekind (Entity (gnat_choice)) == E_Constant\n+\t\t       && Present (Address_Clause (Entity (gnat_choice))))\n+\t\t{\n+\t\t  /* We might have a deferred constant with an address clause\n+\t\t     on either the incomplete or the full view.  While the\n+\t\t     Address_Clause is always attached to the visible entity,\n+\t\t     as tested above, the static value is the Expression\n+\t\t     attached to the the declaration of the entity or of its\n+\t\t     full view if any.  */\n+\n+\t\t  Entity_Id gnat_constant = Entity (gnat_choice);\n+\n+\t\t  if (Present (Full_View (gnat_constant)))\n+\t\t    gnat_constant = Full_View (gnat_constant);\n+\n+\t\t  gnat_choice\n+\t\t    = Expression (Declaration_Node (gnat_constant));\n+\t\t}\n \n \t      /* ... fall through ... */\n \n@@ -1996,14 +2018,43 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t\t\t\t      gnu_subprog_addr,\n \t\t\t\t      nreverse (gnu_actual_list));\n \n-  /* If we return by passing a target, we emit the call and return the target\n-     as our result.  */\n+  /* If we return by passing a target, the result is the target after the\n+     call.  We must not emit the call directly here because this might be\n+     evaluated as part of an expression with conditions to control whether\n+     the call should be emitted or not.  */\n   if (TYPE_RETURNS_BY_TARGET_PTR_P (gnu_subprog_type))\n     {\n-      add_stmt_with_node (gnu_subprog_call, gnat_node);\n-      *gnu_result_type_p\n+      /* Conceptually, what we need is a COMPOUND_EXPR with the call followed\n+\t by the target object converted to the proper type.  Doing so would\n+\t potentially be very inefficient, however, as this expresssion might\n+\t end up wrapped into an outer SAVE_EXPR later on, which would incur a\n+\t pointless temporary copy of the whole object.\n+\n+\t What we do instead is build a COMPOUND_EXPR returning the address of\n+\t the target, and then dereference.  Wrapping the COMPOUND_EXPR into a\n+\t SAVE_EXPR later on then only incurs a pointer copy.  */\n+\n+      tree gnu_result_type\n \t= TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (gnu_subprog_type)));\n-      return unchecked_convert (*gnu_result_type_p, gnu_target, false);\n+\n+      /* Build and return\n+\t (result_type) *[gnu_subprog_call (&gnu_target, ...), &gnu_target]  */\n+\n+      tree gnu_target_address\n+\t= build_unary_op (ADDR_EXPR, NULL_TREE, gnu_target);\n+\n+      gnu_result\n+\t= build2 (COMPOUND_EXPR, TREE_TYPE (gnu_target_address),\n+\t\t  gnu_subprog_call, gnu_target_address);\n+\n+      gnu_result\n+\t= unchecked_convert (gnu_result_type,\n+\t\t\t     build_unary_op (INDIRECT_REF, NULL_TREE,\n+\t\t\t\t\t     gnu_result),\n+\t\t\t     false);\n+\n+      *gnu_result_type_p = gnu_result_type;\n+      return gnu_result;\n     }\n \n   /* If it is a function call, the result is the call expression unless\n@@ -3032,65 +3083,73 @@ gnat_to_gnu (Node_Id gnat_node)\n \n     case N_Slice:\n       {\n-        tree gnu_type;\n-        Node_Id gnat_range_node = Discrete_Range (gnat_node);\n+\ttree gnu_type;\n+\tNode_Id gnat_range_node = Discrete_Range (gnat_node);\n \n-        gnu_result = gnat_to_gnu (Prefix (gnat_node));\n-        gnu_result_type = get_unpadded_type (Etype (gnat_node));\n+\tgnu_result = gnat_to_gnu (Prefix (gnat_node));\n+\tgnu_result_type = get_unpadded_type (Etype (gnat_node));\n \n \t/* Do any implicit dereferences of the prefix and do any needed\n \t   range check.  */\n-        gnu_result = maybe_implicit_deref (gnu_result);\n-        gnu_result = maybe_unconstrained_array (gnu_result);\n-        gnu_type = TREE_TYPE (gnu_result);\n-        if (Do_Range_Check (gnat_range_node))\n-          {\n-            /* Get the bounds of the slice. */\n+\tgnu_result = maybe_implicit_deref (gnu_result);\n+\tgnu_result = maybe_unconstrained_array (gnu_result);\n+\tgnu_type = TREE_TYPE (gnu_result);\n+\tif (Do_Range_Check (gnat_range_node))\n+\t  {\n+\t    /* Get the bounds of the slice.  */\n \t    tree gnu_index_type\n \t      = TYPE_INDEX_TYPE (TYPE_DOMAIN (gnu_result_type));\n-            tree gnu_min_expr = TYPE_MIN_VALUE (gnu_index_type);\n-            tree gnu_max_expr = TYPE_MAX_VALUE (gnu_index_type);\n-            tree gnu_expr_l, gnu_expr_h, gnu_expr_type;\n-\n-            /* Check to see that the minimum slice value is in range */\n-            gnu_expr_l\n-\t      = emit_index_check\n-\t\t(gnu_result, gnu_min_expr,\n-\t\t TYPE_MIN_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (gnu_type))),\n-\t\t TYPE_MAX_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (gnu_type))));\n-\n-            /* Check to see that the maximum slice value is in range */\n-            gnu_expr_h\n-\t      = emit_index_check\n-\t\t(gnu_result, gnu_max_expr,\n-\t\t TYPE_MIN_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (gnu_type))),\n-\t\t TYPE_MAX_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (gnu_type))));\n-\n-            /* Derive a good type to convert everything too */\n-            gnu_expr_type = get_base_type (TREE_TYPE (gnu_expr_l));\n-\n-            /* Build a compound expression that does the range checks */\n-            gnu_expr\n-              = build_binary_op (COMPOUND_EXPR, gnu_expr_type,\n-                                 convert (gnu_expr_type, gnu_expr_h),\n-                                 convert (gnu_expr_type, gnu_expr_l));\n-\n-            /* Build a conditional expression that returns the range checks\n-               expression if the slice range is not null (max >= min) or\n-               returns the min if the slice range is null */\n-            gnu_expr\n-              = fold_build3 (COND_EXPR, gnu_expr_type,\n-\t\t\t     build_binary_op (GE_EXPR, gnu_expr_type,\n-\t\t\t\t\t      convert (gnu_expr_type,\n-\t\t\t\t\t\t       gnu_max_expr),\n-\t\t\t\t\t      convert (gnu_expr_type,\n-\t\t\t\t\t\t       gnu_min_expr)),\n-\t\t\t     gnu_expr, gnu_min_expr);\n-          }\n-        else\n-          gnu_expr = TYPE_MIN_VALUE (TYPE_DOMAIN (gnu_result_type));\n+\t    tree gnu_min_expr = TYPE_MIN_VALUE (gnu_index_type);\n+\t    tree gnu_max_expr = TYPE_MAX_VALUE (gnu_index_type);\n+\t    /* Get the permitted bounds.  */\n+\t    tree gnu_base_index_type\n+\t      = TYPE_INDEX_TYPE (TYPE_DOMAIN (gnu_type));\n+\t    tree gnu_base_min_expr = TYPE_MIN_VALUE (gnu_base_index_type);\n+\t    tree gnu_base_max_expr = TYPE_MAX_VALUE (gnu_base_index_type);\n+\t    tree gnu_expr_l, gnu_expr_h, gnu_expr_type;\n+\n+\t    /* Check to see that the minimum slice value is in range.  */\n+\t    gnu_expr_l = emit_index_check (gnu_result,\n+\t\t\t\t\t   gnu_min_expr,\n+\t\t\t\t\t   gnu_base_min_expr,\n+\t\t\t\t\t   gnu_base_max_expr);\n+\n+\t    /* Check to see that the maximum slice value is in range.  */\n+\t    gnu_expr_h = emit_index_check (gnu_result,\n+\t\t\t\t\t   gnu_max_expr,\n+\t\t\t\t\t   gnu_base_min_expr,\n+\t\t\t\t\t   gnu_base_max_expr);\n+\n+\t    /* Derive a good type to convert everything to.  */\n+\t    gnu_expr_type = get_base_type (TREE_TYPE (gnu_expr_l));\n+\n+\t    /* Build a compound expression that does the range checks and\n+\t       returns the low bound.  */\n+\t    gnu_expr = build_binary_op (COMPOUND_EXPR, gnu_expr_type,\n+\t\t\t\t\tconvert (gnu_expr_type, gnu_expr_h),\n+\t\t\t\t\tconvert (gnu_expr_type, gnu_expr_l));\n+\n+\t   /* Build a conditional expression that does the range check and\n+\t      returns the low bound if the slice is not empty (max >= min),\n+\t      and returns the naked low bound otherwise (max < min), unless\n+\t      it is non-constant and the high bound is; this prevents VRP\n+\t      from inferring bogus ranges on the unlikely path.  */\n+\t    gnu_expr = fold_build3 (COND_EXPR, gnu_expr_type,\n+\t\t\t\t    build_binary_op (GE_EXPR, gnu_expr_type,\n+\t\t\t\t\t\t     convert (gnu_expr_type,\n+\t\t\t\t\t\t\t      gnu_max_expr),\n+\t\t\t\t\t\t     convert (gnu_expr_type,\n+\t\t\t\t\t\t\t      gnu_min_expr)),\n+\t\t\t\t    gnu_expr,\n+\t\t\t\t    TREE_CODE (gnu_min_expr) != INTEGER_CST\n+\t\t\t\t    && TREE_CODE (gnu_max_expr) == INTEGER_CST\n+\t\t\t\t    ? gnu_max_expr : gnu_min_expr);\n+\t  }\n+\telse\n+\t  /* Simply return the naked low bound.  */\n+\t  gnu_expr = TYPE_MIN_VALUE (TYPE_DOMAIN (gnu_result_type));\n \n-        gnu_result = build_binary_op (ARRAY_RANGE_REF, gnu_result_type,\n+\tgnu_result = build_binary_op (ARRAY_RANGE_REF, gnu_result_type,\n \t\t\t\t      gnu_result, gnu_expr);\n       }\n       break;\n@@ -3487,7 +3546,9 @@ gnat_to_gnu (Node_Id gnat_node)\n       /* This case can apply to a boolean or a modular type.\n \t Fall through for a boolean operand since GNU_CODES is set\n \t up to handle this.  */\n-      if (IN (Ekind (Etype (gnat_node)), Modular_Integer_Kind))\n+      if (Is_Modular_Integer_Type (Etype (gnat_node))\n+\t  || (Ekind (Etype (gnat_node)) == E_Private_Type\n+\t      && Is_Modular_Integer_Type (Full_View (Etype (gnat_node)))))\n \t{\n \t  gnu_expr = gnat_to_gnu (Right_Opnd (gnat_node));\n \t  gnu_result_type = get_unpadded_type (Etype (gnat_node));\n@@ -4473,7 +4534,7 @@ insert_code_for (Node_Id gnat_node)\n /* Start a new statement group chained to the previous group.  */\n \n static void\n-start_stmt_group ()\n+start_stmt_group (void)\n {\n   struct stmt_group *group = stmt_group_free_list;\n \n@@ -4633,7 +4694,7 @@ set_block_for_group (tree gnu_block)\n    BLOCK or cleanups were set.  */\n \n static tree\n-end_stmt_group ()\n+end_stmt_group (void)\n {\n   struct stmt_group *group = current_stmt_group;\n   tree gnu_retval = group->stmt_list;\n@@ -5633,12 +5694,12 @@ addressable_p (tree gnu_expr)\n     case COMPONENT_REF:\n       return (!DECL_BIT_FIELD (TREE_OPERAND (gnu_expr, 1))\n \t      && (!STRICT_ALIGNMENT\n-\t          /* If the field was marked as \"semantically\" addressable\n-\t\t     in create_field_decl, we are guaranteed that it can\n-\t\t     be directly addressed.  */\n-\t\t  || !DECL_NONADDRESSABLE_P (TREE_OPERAND (gnu_expr, 1))\n-\t\t  /* Otherwise it can nevertheless be directly addressed\n-\t\t     if it has been sufficiently aligned in the record.  */\n+\t\t  /* Even with DECL_BIT_FIELD cleared, we have to ensure that\n+\t\t     the field is sufficiently aligned, in case it is subject\n+\t\t     to a pragma Component_Alignment.  But we don't need to\n+\t\t     check the alignment of the containing record, as it is\n+\t\t     guaranteed to be not smaller than that of its most\n+\t\t     aligned field that is not a bit-field.  */\n \t\t  || DECL_ALIGN (TREE_OPERAND (gnu_expr, 1))\n \t\t       >= TYPE_ALIGN (TREE_TYPE (gnu_expr)))\n \t      && addressable_p (TREE_OPERAND (gnu_expr, 0)));\n@@ -6004,8 +6065,8 @@ maybe_stabilize_reference (tree ref, bool force, bool lvalues_only,\n \n     case ADDR_EXPR:\n       /*  A standalone ADDR_EXPR is never an lvalue, and this one can't\n-\t  be nested inside an outer INDIRECT_REF, since INDIREC_REF goes\n-\t  straight to stabilize_1.  */\n+\t  be nested inside an outer INDIRECT_REF, since INDIRECT_REF goes\n+\t  straight to gnat_stabilize_reference_1.  */\n       if (lvalues_only)\n \tgoto failure;\n \n@@ -6057,11 +6118,17 @@ maybe_stabilize_reference (tree ref, bool force, bool lvalues_only,\n       break;\n \n     case COMPOUND_EXPR:\n-      result = build2 (COMPOUND_EXPR, type,\n-\t\t       gnat_stabilize_reference_1 (TREE_OPERAND (ref, 0),\n-\t\t\t\t\t\t   force),\n-\t\t       maybe_stabilize_reference (TREE_OPERAND (ref, 1), force,\n-\t\t\t\t\t\t  lvalues_only, success));\n+      result = gnat_stabilize_reference_1 (ref, force);\n+      break;\n+\n+    case CALL_EXPR:\n+      if (lvalues_only)\n+\tgoto failure;\n+\n+      /* This generates better code than the scheme in protect_multiple_eval\n+\t because large objects will be returned via invisible reference in\n+\t most ABIs so the temporary will directly be filled by the callee.  */\n+      result = gnat_stabilize_reference_1 (ref, force);\n       break;\n \n     case ERROR_MARK:"}]}