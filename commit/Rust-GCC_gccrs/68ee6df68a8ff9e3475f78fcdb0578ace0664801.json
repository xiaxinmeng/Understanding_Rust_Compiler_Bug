{"sha": "68ee6df68a8ff9e3475f78fcdb0578ace0664801", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjhlZTZkZjY4YThmZjllMzQ3NWY3OGZjZGIwNTc4YWNlMDY2NDgwMQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2003-01-04T17:46:24Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-01-04T17:46:24Z"}, "message": "h8300-protos.h: Add prototypes for the new functions defined below.\n\n\t* config/h8300/h8300-protos.h: Add prototypes for\n\tthe new functions defined below.\n\t* config/h8300/h8300.c (TARGET_ASM_FUNCTION_PROLOGUE): Do not\n\tdefine.\n\t(dosize): Emit RTL instead of assembly code.\n\t(push): Likewise.\n\t(pop): Likewise.\n\t(h8300_output_function_prologue): Remove.\n\t(h8300_expand_prologue): New.\n\t(h8300_expand_epilogue): New.\n\t(h8300_output_function_epilogue): Do only the reset of\n\tpragma_saveall.\n\t* config/h8300/h8300.md (push_h8300): New.\n\t(push_h8300hs): Likewise.\n\t(pop_h8300): Likewise.\n\t(pop_h8300hs): Likewise.\n\t(*stm_h8300s_2): Change the name to stm_h8300s_2.\n\t(*stm_h8300s_3): Change the name to stm_h8300s_3.\n\t(*stm_h8300s_4): Change the name to stm_h8300s_4.\n\t(*ldm_h8300s_2): New.\n\t(*ldm_h8300s_3): Likewise.\n\t(*ldm_h8300s_4): Likewise.\n\t(return): Likewise.\n\t(*return_1): Likewise.\n\t(prologue): Likewise.\n\t(epilogue): Likewise.\n\t(monitor_prologue): Likewise.\n\nFrom-SVN: r60882", "tree": {"sha": "8addb3090daaeadf6d7d87788a17da2eafcb8855", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8addb3090daaeadf6d7d87788a17da2eafcb8855"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68ee6df68a8ff9e3475f78fcdb0578ace0664801", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68ee6df68a8ff9e3475f78fcdb0578ace0664801", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68ee6df68a8ff9e3475f78fcdb0578ace0664801", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68ee6df68a8ff9e3475f78fcdb0578ace0664801/comments", "author": null, "committer": null, "parents": [{"sha": "2094e97d2ff9617c9d91958953f88b9b355fa302", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2094e97d2ff9617c9d91958953f88b9b355fa302", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2094e97d2ff9617c9d91958953f88b9b355fa302"}], "stats": {"total": 421, "additions": 262, "deletions": 159}, "files": [{"sha": "f5ee6e68c990ebb83e881817b4079e5c37bd8104", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68ee6df68a8ff9e3475f78fcdb0578ace0664801/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68ee6df68a8ff9e3475f78fcdb0578ace0664801/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=68ee6df68a8ff9e3475f78fcdb0578ace0664801", "patch": "@@ -1,3 +1,33 @@\n+2003-01-04  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config/h8300/h8300-protos.h: Add prototypes for\n+\tthe new functions defined below.\n+\t* config/h8300/h8300.c (TARGET_ASM_FUNCTION_PROLOGUE): Do not\n+\tdefine.\n+\t(dosize): Emit RTL instead of assembly code.\n+\t(push): Likewise.\n+\t(pop): Likewise.\n+\t(h8300_output_function_prologue): Remove.\n+\t(h8300_expand_prologue): New.\n+\t(h8300_expand_epilogue): New.\n+\t(h8300_output_function_epilogue): Do only the reset of\n+\tpragma_saveall.\n+\t* config/h8300/h8300.md (push_h8300): New.\n+\t(push_h8300hs): Likewise.\n+\t(pop_h8300): Likewise.\n+\t(pop_h8300hs): Likewise.\n+\t(*stm_h8300s_2): Change the name to stm_h8300s_2.\n+\t(*stm_h8300s_3): Change the name to stm_h8300s_3.\n+\t(*stm_h8300s_4): Change the name to stm_h8300s_4.\n+\t(*ldm_h8300s_2): New.\n+\t(*ldm_h8300s_3): Likewise.\n+\t(*ldm_h8300s_4): Likewise.\n+\t(return): Likewise.\n+\t(*return_1): Likewise.\n+\t(prologue): Likewise.\n+\t(epilogue): Likewise.\n+\t(monitor_prologue): Likewise.\n+\n 2003-01-03  Dale Johannesen  <dalej@apple.com>\n \n \t* config/darwin.h:  (EXTRA_SECTIONS):  Add machopic_symbol_stub1,"}, {"sha": "f5a59d4b1202f7f843aa43159ff58fd2d289a01a", "filename": "gcc/config/h8300/h8300-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68ee6df68a8ff9e3475f78fcdb0578ace0664801/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68ee6df68a8ff9e3475f78fcdb0578ace0664801/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h?ref=68ee6df68a8ff9e3475f78fcdb0578ace0664801", "patch": "@@ -90,6 +90,9 @@ extern int h8300_tiny_data_p PARAMS ((tree));\n #endif /* TREE_CODE */\n \n extern void h8300_init_once PARAMS ((void));\n+extern int h8300_can_use_return_insn_p PARAMS ((void));\n+extern void h8300_expand_prologue PARAMS ((void));\n+extern void h8300_expand_epilogue PARAMS ((void));\n extern int h8300_current_function_interrupt_function_p PARAMS ((void));\n extern void asm_file_start PARAMS ((FILE *));\n extern void asm_file_end PARAMS ((FILE *));"}, {"sha": "f8ec6822c3bb25159d2b958a48e569ccfdd7f889", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 98, "deletions": 155, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68ee6df68a8ff9e3475f78fcdb0578ace0664801/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68ee6df68a8ff9e3475f78fcdb0578ace0664801/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=68ee6df68a8ff9e3475f78fcdb0578ace0664801", "patch": "@@ -50,18 +50,17 @@ static const char *byte_reg PARAMS ((rtx, int));\n static int h8300_interrupt_function_p PARAMS ((tree));\n static int h8300_monitor_function_p PARAMS ((tree));\n static int h8300_os_task_function_p PARAMS ((tree));\n-static void dosize PARAMS ((FILE *, int, unsigned int));\n+static void dosize PARAMS ((int, unsigned int));\n static int round_frame_size PARAMS ((int));\n static unsigned int compute_saved_regs PARAMS ((void));\n-static void push PARAMS ((FILE *, int));\n-static void pop PARAMS ((FILE *, int));\n+static void push PARAMS ((int));\n+static void pop PARAMS ((int));\n static const char *cond_string PARAMS ((enum rtx_code));\n static unsigned int h8300_asm_insn_count PARAMS ((const char *));\n const struct attribute_spec h8300_attribute_table[];\n static tree h8300_handle_fndecl_attribute PARAMS ((tree *, tree, tree, int, bool *));\n static tree h8300_handle_eightbit_data_attribute PARAMS ((tree *, tree, tree, int, bool *));\n static tree h8300_handle_tiny_data_attribute PARAMS ((tree *, tree, tree, int, bool *));\n-static void h8300_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n static void h8300_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n static void h8300_insert_attributes PARAMS ((tree, tree *));\n #ifndef OBJECT_FORMAT_ELF\n@@ -104,8 +103,6 @@ const char *h8_push_op, *h8_pop_op, *h8_mov_op;\n #undef TARGET_ASM_ALIGNED_HI_OP\n #define TARGET_ASM_ALIGNED_HI_OP \"\\t.word\\t\"\n \n-#undef TARGET_ASM_FUNCTION_PROLOGUE\n-#define TARGET_ASM_FUNCTION_PROLOGUE h8300_output_function_prologue\n #undef TARGET_ASM_FUNCTION_EPILOGUE\n #define TARGET_ASM_FUNCTION_EPILOGUE h8300_output_function_epilogue\n #undef TARGET_ENCODE_SECTION_INFO\n@@ -386,50 +383,32 @@ byte_reg (x, b)\n    SIZE to adjust the stack pointer.  */\n \n static void\n-dosize (file, sign, size)\n-     FILE *file;\n+dosize (sign, size)\n      int sign;\n      unsigned int size;\n {\n-  /* On the H8/300H and H8S, for sizes <= 8 bytes, it is as good or\n-     better to use adds/subs insns rather than add.l/sub.l with an\n-     immediate value.\n-\n-     Also, on the H8/300, if we don't have a temporary to hold the\n-     size of the frame in the prologue, we simply emit a sequence of\n-     subs since this shouldn't happen often.  */\n-  if ((TARGET_H8300 && size <= 4)\n-      || ((TARGET_H8300H || TARGET_H8300S) && size <= 8)\n-      || (TARGET_H8300 && h8300_current_function_interrupt_function_p ())\n-      || (TARGET_H8300 && current_function_needs_context\n-\t  && sign < 0))\n+  /* H8/300 cannot add/subtract a large constant with a single\n+     instruction.  If a temporary register is available, load the\n+     constant to it and then do the addition.  */\n+  if (TARGET_H8300\n+      && size > 4\n+      && !h8300_current_function_interrupt_function_p ()\n+      && !(current_function_needs_context && sign < 0))\n     {\n-      const char *op = (sign > 0) ? \"add\" : \"sub\";\n-      unsigned int amount;\n-\n-      /* Try different amounts in descending order.  */\n-      for (amount = (TARGET_H8300H || TARGET_H8300S) ? 4 : 2;\n-\t   amount > 0;\n-\t   amount /= 2)\n-\t{\n-\t  char insn[100];\n-\n-\t  sprintf (insn, \"\\t%ss\\t#%d,%s\\n\", op, amount,\n-\t\t   TARGET_H8300 ? \"r7\" : \"er7\");\n-\t  for (; size >= amount; size -= amount)\n-\t    fputs (insn, file);\n-\t}\n+      rtx new_sp;\n+      rtx r3 = gen_rtx_REG (Pmode, 3);\n+      emit_insn (gen_rtx_SET (Pmode, r3, GEN_INT (sign * size)));\n+      new_sp = gen_rtx_PLUS (Pmode, stack_pointer_rtx, r3);\n+      emit_insn (gen_rtx_SET (Pmode, stack_pointer_rtx, new_sp));\n     }\n   else\n     {\n-      if (TARGET_H8300)\n-\t{\n-\t  fprintf (file, \"\\tmov.w\\t#%d,r3\\n\\tadd.w\\tr3,r7\\n\", sign * size);\n-\t}\n-      else\n-\t{\n-\t  fprintf (file, \"\\tadd.l\\t#%d,er7\\n\", sign * size);\n-\t}\n+      /* The stack adjustment made here is further optimized by the\n+\t splitter.  In case of H8/300, the splitter always splits the\n+\t addition emitted here to make the adjustment\n+\t interrupt-safe.  */\n+      rtx new_sp = plus_constant (stack_pointer_rtx, sign * size);\n+      emit_insn (gen_rtx_SET (Pmode, stack_pointer_rtx, new_sp));\n     }\n }\n \n@@ -466,30 +445,38 @@ compute_saved_regs ()\n   return saved_regs;\n }\n \n-/* Output assembly language code to push register RN.  */\n+/* Emit an insn to push register RN.  */\n \n static void\n-push (file, rn)\n-     FILE *file;\n+push (rn)\n      int rn;\n {\n+  rtx reg = gen_rtx_REG (word_mode, rn);\n+  rtx x;\n+\n   if (TARGET_H8300)\n-    fprintf (file, \"\\t%s\\t%s,@-r7\\n\", h8_mov_op, h8_reg_names[rn]);\n+    x = gen_push_h8300 (reg);\n   else\n-    fprintf (file, \"\\t%s\\t%s,@-er7\\n\", h8_mov_op, h8_reg_names[rn]);\n+    x = gen_push_h8300hs (reg);\n+  x = emit_insn (x);\n+  REG_NOTES (x) = gen_rtx_EXPR_LIST (REG_INC, stack_pointer_rtx, 0);\n }\n \n-/* Output assembly language code to pop register RN.  */\n+/* Emit an insn to pop register RN.  */\n \n static void\n-pop (file, rn)\n-     FILE *file;\n+pop (rn)\n      int rn;\n {\n+  rtx reg = gen_rtx_REG (word_mode, rn);\n+  rtx x;\n+\n   if (TARGET_H8300)\n-    fprintf (file, \"\\t%s\\t@r7+,%s\\n\", h8_mov_op, h8_reg_names[rn]);\n+    x = gen_pop_h8300 (reg);\n   else\n-    fprintf (file, \"\\t%s\\t@er7+,%s\\n\", h8_mov_op, h8_reg_names[rn]);\n+    x = gen_pop_h8300hs (reg);\n+  x = emit_insn (x);\n+  REG_NOTES (x) = gen_rtx_EXPR_LIST (REG_INC, stack_pointer_rtx, 0);\n }\n \n /* This is what the stack looks like after the prolog of\n@@ -510,73 +497,36 @@ pop (file, rn)\n    <saved registers>\t<- sp\n */\n \n-/* Output assembly language code for the function prologue.  */\n+/* Generate RTL code for the function prologue.  */\n \n-static void\n-h8300_output_function_prologue (file, size)\n-     FILE *file;\n-     HOST_WIDE_INT size;\n+void\n+h8300_expand_prologue ()\n {\n-  int fsize = round_frame_size (size);\n+  int fsize = round_frame_size (get_frame_size ());\n   int regno;\n   int saved_regs;\n   int n_regs;\n \n   /* If the current function has the OS_Task attribute set, then\n      we have a naked prologue.  */\n   if (h8300_os_task_function_p (current_function_decl))\n-    {\n-      fprintf (file, \";OS_Task prologue\\n\");\n-      return;\n-    }\n+    return;\n \n   if (h8300_monitor_function_p (current_function_decl))\n-    {\n-      /* My understanding of monitor functions is they act just\n-\t like interrupt functions, except the prologue must\n-\t mask interrupts.  */\n-      fprintf (file, \";monitor prologue\\n\");\n-      if (TARGET_H8300)\n-\t{\n-\t  fprintf (file, \"\\tsubs\\t#2,sp\\n\");\n-\t  push (file, 0);\n-\t  fprintf (file, \"\\tstc\\tccr,r0l\\n\");\n-\t  fprintf (file, \"\\tmov.b\\tr0l,@(2,sp)\\n\");\n-\t  pop (file, 0);\n-\t  fprintf (file, \"\\torc\\t#128,ccr\\n\");\n-\t}\n-      else if (TARGET_H8300H)\n-\t{\n-\t  push (file, 0);\n-\t  fprintf (file, \"\\tstc\\tccr,r0l\\n\");\n-\t  fprintf (file, \"\\tmov.b\\tr0l,@(4,sp)\\n\");\n-\t  pop (file, 0);\n-\t  fprintf (file, \"\\torc\\t#128,ccr\\n\");\n-\t}\n-      else if (TARGET_H8300S)\n-\t{\n-\t  fprintf (file, \"\\tstc\\texr,@-sp\\n\");\n-\t  push (file, 0);\n-\t  fprintf (file, \"\\tstc\\tccr,r0l\\n\");\n-\t  fprintf (file, \"\\tmov.b\\tr0l,@(6,sp)\\n\");\n-\t  pop (file, 0);\n-\t  fprintf (file, \"\\torc\\t#128,ccr\\n\");\n-\t}\n-      else\n-\tabort ();\n-    }\n+    /* My understanding of monitor functions is they act just like\n+       interrupt functions, except the prologue must mask\n+       interrupts.  */\n+    emit_insn (gen_monitor_prologue ());\n \n   if (frame_pointer_needed)\n     {\n       /* Push fp.  */\n-      push (file, FRAME_POINTER_REGNUM);\n-      fprintf (file, \"\\t%s\\t%s,%s\\n\", h8_mov_op,\n-\t       h8_reg_names[STACK_POINTER_REGNUM],\n-\t       h8_reg_names[FRAME_POINTER_REGNUM]);\n+      push (FRAME_POINTER_REGNUM);\n+      emit_insn (gen_rtx_SET (Pmode, frame_pointer_rtx, stack_pointer_rtx));\n     }\n \n   /* Leave room for locals.  */\n-  dosize (file, -1, fsize);\n+  dosize (-1, fsize);\n \n   /* Push the rest of the registers in ascending order.  */\n   saved_regs = compute_saved_regs ();\n@@ -604,22 +554,22 @@ h8300_output_function_prologue (file, size)\n \t  switch (n_regs)\n \t    {\n \t    case 1:\n-\t      push (file, regno);\n+\t      push (regno);\n \t      break;\n \t    case 2:\n-\t      fprintf (file, \"\\tstm.l\\t%s-%s,@-er7\\n\",\n-\t\t       h8_reg_names[regno],\n-\t\t       h8_reg_names[regno + 1]);\n+\t      emit_insn (gen_stm_h8300s_2 (gen_rtx_REG (SImode, regno),\n+\t\t\t\t\t   gen_rtx_REG (SImode, regno + 1)));\n \t      break;\n \t    case 3:\n-\t      fprintf (file, \"\\tstm.l\\t%s-%s,@-er7\\n\",\n-\t\t       h8_reg_names[regno],\n-\t\t       h8_reg_names[regno + 2]);\n+\t      emit_insn (gen_stm_h8300s_3 (gen_rtx_REG (SImode, regno),\n+\t\t\t\t\t   gen_rtx_REG (SImode, regno + 1),\n+\t\t\t\t\t   gen_rtx_REG (SImode, regno + 2)));\n \t      break;\n \t    case 4:\n-\t      fprintf (file, \"\\tstm.l\\t%s-%s,@-er7\\n\",\n-\t\t       h8_reg_names[regno],\n-\t\t       h8_reg_names[regno + 3]);\n+\t      emit_insn (gen_stm_h8300s_4 (gen_rtx_REG (SImode, regno),\n+\t\t\t\t\t   gen_rtx_REG (SImode, regno + 1),\n+\t\t\t\t\t   gen_rtx_REG (SImode, regno + 2),\n+\t\t\t\t\t   gen_rtx_REG (SImode, regno + 3)));\n \t      break;\n \t    default:\n \t      abort ();\n@@ -628,38 +578,29 @@ h8300_output_function_prologue (file, size)\n     }\n }\n \n-/* Output assembly language code for the function epilogue.  */\n+int\n+h8300_can_use_return_insn_p ()\n+{\n+  return (reload_completed\n+\t  && !frame_pointer_needed\n+\t  && get_frame_size () == 0\n+\t  && compute_saved_regs () == 0);\n+}\n \n-static void\n-h8300_output_function_epilogue (file, size)\n-     FILE *file;\n-     HOST_WIDE_INT size;\n+/* Generate RTL code for the function epilogue.  */\n+\n+void\n+h8300_expand_epilogue ()\n {\n-  int fsize = round_frame_size (size);\n+  int fsize = round_frame_size (get_frame_size ());\n   int regno;\n-  rtx insn = get_last_insn ();\n   int saved_regs;\n   int n_regs;\n \n   if (h8300_os_task_function_p (current_function_decl))\n-    {\n-      /* OS_Task epilogues are nearly naked -- they just have an\n-\t rts instruction.  */\n-      fprintf (file, \";OS_task epilogue\\n\");\n-      fprintf (file, \"\\trts\\n\");\n-      goto out;\n-    }\n-\n-  /* Monitor epilogues are the same as interrupt function epilogues.\n-     Just make a note that we're in a monitor epilogue.  */\n-  if (h8300_monitor_function_p (current_function_decl))\n-    fprintf (file, \";monitor epilogue\\n\");\n-\n-  /* If the last insn was a BARRIER, we don't have to write any code.  */\n-  if (GET_CODE (insn) == NOTE)\n-    insn = prev_nonnote_insn (insn);\n-  if (insn && GET_CODE (insn) == BARRIER)\n-    goto out;\n+    /* OS_Task epilogues are nearly naked -- they just have an\n+       rts instruction.  */\n+    return;\n \n   /* Pop the saved registers in descending order.  */\n   saved_regs = compute_saved_regs ();\n@@ -687,22 +628,22 @@ h8300_output_function_epilogue (file, size)\n \t  switch (n_regs)\n \t    {\n \t    case 1:\n-\t      pop (file, regno);\n+\t      pop (regno);\n \t      break;\n \t    case 2:\n-\t      fprintf (file, \"\\tldm.l\\t@er7+,%s-%s\\n\",\n-\t\t       h8_reg_names[regno - 1],\n-\t\t       h8_reg_names[regno]);\n+\t      emit_insn (gen_ldm_h8300s_2 (gen_rtx_REG (SImode, regno - 1),\n+\t\t\t\t\t   gen_rtx_REG (SImode, regno)));\n \t      break;\n \t    case 3:\n-\t      fprintf (file, \"\\tldm.l\\t@er7+,%s-%s\\n\",\n-\t\t       h8_reg_names[regno - 2],\n-\t\t       h8_reg_names[regno]);\n+\t      emit_insn (gen_ldm_h8300s_3 (gen_rtx_REG (SImode, regno - 2),\n+\t\t\t\t\t   gen_rtx_REG (SImode, regno - 1),\n+\t\t\t\t\t   gen_rtx_REG (SImode, regno)));\n \t      break;\n \t    case 4:\n-\t      fprintf (file, \"\\tldm.l\\t@er7+,%s-%s\\n\",\n-\t\t       h8_reg_names[regno - 3],\n-\t\t       h8_reg_names[regno]);\n+\t      emit_insn (gen_ldm_h8300s_4 (gen_rtx_REG (SImode, regno - 3),\n+\t\t\t\t\t   gen_rtx_REG (SImode, regno - 2),\n+\t\t\t\t\t   gen_rtx_REG (SImode, regno - 1),\n+\t\t\t\t\t   gen_rtx_REG (SImode, regno)));\n \t      break;\n \t    default:\n \t      abort ();\n@@ -711,21 +652,23 @@ h8300_output_function_epilogue (file, size)\n     }\n \n   /* Deallocate locals.  */\n-  dosize (file, 1, fsize);\n+  dosize (1, fsize);\n \n   /* Pop frame pointer if we had one.  */\n   if (frame_pointer_needed)\n-    pop (file, FRAME_POINTER_REGNUM);\n+    pop (FRAME_POINTER_REGNUM);\n+}\n \n-  if (h8300_current_function_interrupt_function_p ())\n-    fprintf (file, \"\\trte\\n\");\n-  else\n-    fprintf (file, \"\\trts\\n\");\n+/* Output assembly language code for the function epilogue.  */\n \n- out:\n+static void\n+h8300_output_function_epilogue (file, size)\n+     FILE *file ATTRIBUTE_UNUSED;\n+     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n+{\n   pragma_saveall = 0;\n }\n-\n+  \n /* Return nonzero if the current function is an interrupt\n    function.  */\n "}, {"sha": "6a9245ee8ae4ccf0e57354b20a67f0e8fea2bb16", "filename": "gcc/config/h8300/h8300.md", "status": "modified", "additions": 131, "deletions": 4, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68ee6df68a8ff9e3475f78fcdb0578ace0664801/gcc%2Fconfig%2Fh8300%2Fh8300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68ee6df68a8ff9e3475f78fcdb0578ace0664801/gcc%2Fconfig%2Fh8300%2Fh8300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.md?ref=68ee6df68a8ff9e3475f78fcdb0578ace0664801", "patch": "@@ -51,7 +51,8 @@\n ;; ----------------------------------------------------------------------\n \n (define_constants\n-  [(UNSPEC_INCDEC\t0)])\n+  [(UNSPEC_INCDEC\t0)\n+   (UNSPEC_MONITOR\t1)])\n \n (define_constants\n   [(SC_REG\t 3)\n@@ -1783,7 +1784,32 @@\n ;; PROLOGUE/EPILOGUE-RELATED INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n-(define_insn \"*stm_h8300s_2\"\n+(define_expand \"push_h8300\"\n+  [(set (mem:HI (pre_dec:HI (reg:HI SP_REG)))\n+        (match_operand:HI 0 \"register_operand\" \"=r\"))]\n+\t\n+  \"TARGET_H8300\"\n+  \"\")\n+\n+(define_expand \"push_h8300hs\"\n+  [(set (mem:SI (pre_dec:SI (reg:SI SP_REG)))\n+        (match_operand:SI 0 \"register_operand\" \"=r\"))]\n+  \"TARGET_H8300H && TARGET_H8300S\"\n+  \"\")\n+\n+(define_expand \"pop_h8300\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(mem:HI (post_inc:HI (reg:HI SP_REG))))]\n+  \"TARGET_H8300\"\n+  \"\")\n+\n+(define_expand \"pop_h8300hs\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(mem:SI (post_inc:SI (reg:SI SP_REG))))]\n+  \"TARGET_H8300H && TARGET_H8300S\"\n+  \"\")\n+\n+(define_insn \"stm_h8300s_2\"\n   [(parallel\n      [(set (reg:SI SP_REG)\n \t   (plus:SI (reg:SI SP_REG) (const_int -8)))\n@@ -1799,7 +1825,7 @@\n   [(set_attr \"cc\" \"none\")\n    (set_attr \"length\" \"4\")])\n \n-(define_insn \"*stm_h8300s_3\"\n+(define_insn \"stm_h8300s_3\"\n   [(parallel\n      [(set (reg:SI SP_REG)\n \t   (plus:SI (reg:SI SP_REG) (const_int -12)))\n@@ -1820,7 +1846,7 @@\n   [(set_attr \"cc\" \"none\")\n    (set_attr \"length\" \"4\")])\n \n-(define_insn \"*stm_h8300s_4\"\n+(define_insn \"stm_h8300s_4\"\n   [(parallel\n      [(set (reg:SI SP_REG)\n \t   (plus:SI (reg:SI SP_REG) (const_int -16)))\n@@ -1840,6 +1866,107 @@\n   \"stm.l\\\\t%S0-%S3,@-er7\"\n   [(set_attr \"cc\" \"none\")\n    (set_attr \"length\" \"4\")])\n+\n+(define_insn \"ldm_h8300s_2\"\n+  [(parallel\n+     [(set (reg:SI SP_REG)\n+\t   (plus:SI (reg:SI SP_REG) (const_int 8)))\n+      (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int 4)))\n+\t   (match_operand:SI 0 \"register_operand\" \"\"))\n+      (set (mem:SI (reg:SI SP_REG))\n+\t   (match_operand:SI 1 \"register_operand\" \"\"))])]\n+  \"TARGET_H8300S\n+   && ((REGNO (operands[0]) == 0 && REGNO (operands[1]) == 1)\n+       || (REGNO (operands[0]) == 2 && REGNO (operands[1]) == 3)\n+       || (REGNO (operands[0]) == 4 && REGNO (operands[1]) == 5))\"\n+  \"ldm.l\\\\t@er7+,%S0-%S1\"\n+  [(set_attr \"cc\" \"none\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"ldm_h8300s_3\"\n+  [(parallel\n+     [(set (reg:SI SP_REG)\n+\t   (plus:SI (reg:SI SP_REG) (const_int 12)))\n+      (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int 8)))\n+\t   (match_operand:SI 0 \"register_operand\" \"\"))\n+      (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int 4)))\n+\t   (match_operand:SI 1 \"register_operand\" \"\"))\n+      (set (mem:SI (reg:SI SP_REG))\n+\t   (match_operand:SI 2 \"register_operand\" \"\"))])]\n+  \"TARGET_H8300S\n+   && ((REGNO (operands[0]) == 0\n+\t&& REGNO (operands[1]) == 1\n+\t&& REGNO (operands[2]) == 2)\n+       || (REGNO (operands[0]) == 4\n+\t   && REGNO (operands[1]) == 5\n+\t   && REGNO (operands[2]) == 6))\"\n+  \"ldm.l\\\\t@er7+,%S0-%S2\"\n+  [(set_attr \"cc\" \"none\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"ldm_h8300s_4\"\n+  [(parallel\n+     [(set (reg:SI SP_REG)\n+\t   (plus:SI (reg:SI SP_REG) (const_int 16)))\n+      (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int 12)))\n+\t   (match_operand:SI 0 \"register_operand\" \"\"))\n+      (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int 8)))\n+\t   (match_operand:SI 1 \"register_operand\" \"\"))\n+      (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int 4)))\n+\t   (match_operand:SI 2 \"register_operand\" \"\"))\n+      (set (mem:SI (reg:SI SP_REG))\n+\t   (match_operand:SI 3 \"register_operand\" \"\"))])]\n+  \"TARGET_H8300S\n+   && REGNO (operands[0]) == 0\n+   && REGNO (operands[1]) == 1\n+   && REGNO (operands[2]) == 2\n+   && REGNO (operands[3]) == 3\"\n+  \"ldm.l\\\\t@er7+,%S0-%S3\"\n+  [(set_attr \"cc\" \"none\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_expand \"return\"\n+  [(return)]\n+  \"h8300_can_use_return_insn_p ()\"\n+  \"\")\n+\n+(define_insn \"*return_1\"\n+  [(return)]\n+  \"reload_completed\"\n+  \"*\n+{\n+  if (h8300_current_function_interrupt_function_p ())\n+    return \\\"rte\\\";\n+  else\n+    return \\\"rts\\\";\n+}\"\n+  [(set_attr \"cc\" \"none\")\n+   (set_attr \"length\" \"2\")])\n+\n+(define_expand \"prologue\"\n+  [(const_int 0)]\n+  \"\"\n+  \"h8300_expand_prologue (); DONE;\")\n+\n+(define_expand \"epilogue\"\n+  [(return)]\n+  \"\"\n+  \"h8300_expand_epilogue ();\")\n+\n+(define_insn \"monitor_prologue\"\n+  [(unspec_volatile [(const_int 0)] UNSPEC_MONITOR)]\n+  \"\"\n+  \"*\n+{\n+  if (TARGET_H8300)\n+    return \\\"subs\\\\t#2,r7\\;mov.w\\\\tr0,@-r7\\;stc\\\\tccr,r0l\\;mov.b\\tr0l,@(2,r7)\\;mov.w\\\\t@r7+,r0\\;orc\\t#128,ccr\\\";\n+  else if (TARGET_H8300H)\n+    return \\\"mov.l\\\\ter0,@-er7\\;stc\\\\tccr,r0l\\;mov.b\\\\tr0l,@(4,er7)\\;mov.l\\\\t@er7+,er0\\;orc\\\\t#128,ccr\\\";\n+  else if (TARGET_H8300S)\n+    return \\\"stc\\texr,@-er7\\;mov.l\\\\ter0,@-er7\\;stc\\tccr,r0l\\;mov.b\\tr0l,@(6,er7)\\;mov.l\\\\t@er7+,er0\\;orc\\t#128,ccr\\\";\n+}\"\n+  [(set_attr \"length\" \"20\")\n+   (set_attr \"cc\" \"clobber\")])\n \f\n ;; ----------------------------------------------------------------------\n ;; EXTEND INSTRUCTIONS"}]}