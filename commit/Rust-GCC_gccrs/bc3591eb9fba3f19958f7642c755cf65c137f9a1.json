{"sha": "bc3591eb9fba3f19958f7642c755cf65c137f9a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmMzNTkxZWI5ZmJhM2YxOTk1OGY3NjQyYzc1NWNmNjVjMTM3ZjlhMQ==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2012-10-29T00:42:25Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2012-10-29T00:42:25Z"}, "message": "re PR rtl-optimization/55106 (ice: Maximum number of LRA constraint passes is achieved (15))\n\n2012-10-28  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR rtl-optimization/55106\n\t* lra-constraints.c (skip_usage_debug_insns): New function.\n\t(check_secondary_memory_needed_p): Ditto.\n\t(inherit_reload_reg): Use the new functions.  Improve debug\n\toutput.\n\nFrom-SVN: r192904", "tree": {"sha": "c6b2a86fbc84697b54efacbfc605b86e954cc7b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6b2a86fbc84697b54efacbfc605b86e954cc7b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc3591eb9fba3f19958f7642c755cf65c137f9a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc3591eb9fba3f19958f7642c755cf65c137f9a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc3591eb9fba3f19958f7642c755cf65c137f9a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc3591eb9fba3f19958f7642c755cf65c137f9a1/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4c358abe604e175a8f9897f3ae44a9fd72725089", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c358abe604e175a8f9897f3ae44a9fd72725089", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c358abe604e175a8f9897f3ae44a9fd72725089"}], "stats": {"total": 85, "additions": 80, "deletions": 5}, "files": [{"sha": "107d6f6f651a50e870b0aeb1c8ce6e9cc0804ee9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc3591eb9fba3f19958f7642c755cf65c137f9a1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc3591eb9fba3f19958f7642c755cf65c137f9a1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bc3591eb9fba3f19958f7642c755cf65c137f9a1", "patch": "@@ -1,3 +1,11 @@\n+2012-10-28  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR rtl-optimization/55106\n+\t* lra-constraints.c (skip_usage_debug_insns): New function.\n+\t(check_secondary_memory_needed_p): Ditto.\n+\t(inherit_reload_reg): Use the new functions.  Improve debug\n+\toutput.\n+\n 2012-10-29  Jonathan Wakely  <jwakely.gcc@gmail.com>\n \n \t* doc/cpp.texi (Search Path): Fix outdated C++ path."}, {"sha": "c9a8cd48330a4c3a517cfbd0008394adb10548b5", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 72, "deletions": 5, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc3591eb9fba3f19958f7642c755cf65c137f9a1/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc3591eb9fba3f19958f7642c755cf65c137f9a1/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=bc3591eb9fba3f19958f7642c755cf65c137f9a1", "patch": "@@ -3573,6 +3573,48 @@ substitute_pseudo (rtx *loc, int old_regno, rtx new_reg)\n   return result;\n }\n \n+/* Return first non-debug insn in list USAGE_INSNS.  */\n+static rtx\n+skip_usage_debug_insns (rtx usage_insns)\n+{\n+  rtx insn;\n+\n+  /* Skip debug insns.  */\n+  for (insn = usage_insns;\n+       insn != NULL_RTX && GET_CODE (insn) == INSN_LIST;\n+       insn = XEXP (insn, 1))\n+    ;\n+  return insn;\n+}\n+\n+/* Return true if we need secondary memory moves for insn in\n+   USAGE_INSNS after inserting inherited pseudo of class INHER_CL\n+   into the insn.  */\n+static bool\n+check_secondary_memory_needed_p (enum reg_class inher_cl, rtx usage_insns)\n+{\n+#ifndef SECONDARY_MEMORY_NEEDED\n+  return false;\n+#else\n+  rtx insn, set, dest;\n+  enum reg_class cl;\n+\n+  if (inher_cl == ALL_REGS\n+      || (insn = skip_usage_debug_insns (usage_insns)) == NULL_RTX)\n+    return false;\n+  lra_assert (INSN_P (insn));\n+  if ((set = single_set (insn)) == NULL_RTX || ! REG_P (SET_DEST (set)))\n+    return false;\n+  dest = SET_DEST (set);\n+  if (! REG_P (dest))\n+    return false;\n+  lra_assert (inher_cl != NO_REGS);\n+  cl = get_reg_class (REGNO (dest));\n+  return (cl != NO_REGS && cl != ALL_REGS\n+\t  && SECONDARY_MEMORY_NEEDED (inher_cl, cl, GET_MODE (dest)));\n+#endif\n+}\n+\n /* Registers involved in inheritance/split in the current EBB\n    (inheritance/split pseudos and original registers).\t*/\n static bitmap_head check_only_regs;\n@@ -3610,18 +3652,18 @@ inherit_reload_reg (bool def_p, int original_regno,\n   lra_assert (! usage_insns[original_regno].after_p);\n   if (lra_dump_file != NULL)\n     fprintf (lra_dump_file,\n-\t     \"\t  <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\\n\");\n+\t     \"    <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\\n\");\n   if (! ira_reg_classes_intersect_p[cl][rclass])\n     {\n       if (lra_dump_file != NULL)\n \t{\n \t  fprintf (lra_dump_file,\n-\t\t   \"\tRejecting inheritance for %d \"\n+\t\t   \"    Rejecting inheritance for %d \"\n \t\t   \"because of disjoint classes %s and %s\\n\",\n \t\t   original_regno, reg_class_names[cl],\n \t\t   reg_class_names[rclass]);\n \t  fprintf (lra_dump_file,\n-\t\t   \"\t>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\\n\");\n+\t\t   \"    >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\\n\");\n \t}\n       return false;\n     }\n@@ -3638,6 +3680,31 @@ inherit_reload_reg (bool def_p, int original_regno,\n       \n       rclass = cl;\n     }\n+  if (check_secondary_memory_needed_p (cl, next_usage_insns))\n+    {\n+      /* Reject inheritance resulting in secondary memory moves.\n+\t Otherwise, there is a danger in LRA cycling.  Also such\n+\t transformation will be unprofitable.  */\n+      if (lra_dump_file != NULL)\n+\t{\n+\t  rtx insn = skip_usage_debug_insns (next_usage_insns);\n+\t  rtx set = single_set (insn);\n+\n+\t  lra_assert (set != NULL_RTX);\n+\n+\t  rtx dest = SET_DEST (set);\n+\n+\t  lra_assert (REG_P (dest));\n+\t  fprintf (lra_dump_file,\n+\t\t   \"    Rejecting inheritance for insn %d(%s)<-%d(%s) \"\n+\t\t   \"as secondary mem is needed\\n\",\n+\t\t   REGNO (dest), reg_class_names[get_reg_class (REGNO (dest))],\n+\t\t   original_regno, reg_class_names[cl]);\n+\t  fprintf (lra_dump_file,\n+\t\t   \"    >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\\n\");\n+\t}\n+      return false;\n+    }\n   new_reg = lra_create_new_reg (GET_MODE (original_reg), original_reg,\n \t\t\t\trclass, \"inheritance\");\n   start_sequence ();\n@@ -3652,7 +3719,7 @@ inherit_reload_reg (bool def_p, int original_regno,\n       if (lra_dump_file != NULL)\n \t{\n \t  fprintf (lra_dump_file,\n-\t\t   \"\tRejecting inheritance %d->%d \"\n+\t\t   \"    Rejecting inheritance %d->%d \"\n \t\t   \"as it results in 2 or more insns:\\n\",\n \t\t   original_regno, REGNO (new_reg));\n \t  debug_rtl_slim (lra_dump_file, new_insns, NULL_RTX, -1, 0);\n@@ -3667,7 +3734,7 @@ inherit_reload_reg (bool def_p, int original_regno,\n     /* We now have a new usage insn for original regno.  */\n     setup_next_usage_insn (original_regno, new_insns, reloads_num, false);\n   if (lra_dump_file != NULL)\n-    fprintf (lra_dump_file, \"\t Original reg change %d->%d (bb%d):\\n\",\n+    fprintf (lra_dump_file, \"    Original reg change %d->%d (bb%d):\\n\",\n \t     original_regno, REGNO (new_reg), BLOCK_FOR_INSN (insn)->index);\n   lra_reg_info[REGNO (new_reg)].restore_regno = original_regno;\n   bitmap_set_bit (&check_only_regs, REGNO (new_reg));"}]}