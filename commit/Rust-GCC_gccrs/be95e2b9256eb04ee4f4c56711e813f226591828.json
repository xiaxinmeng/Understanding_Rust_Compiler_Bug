{"sha": "be95e2b9256eb04ee4f4c56711e813f226591828", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmU5NWUyYjkyNTZlYjA0ZWU0ZjRjNTY3MTFlODEzZjIyNjU5MTgyOA==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2008-09-18T17:57:05Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2008-09-18T17:57:05Z"}, "message": "ipa-cp.c (ipcp_estimate_growth): Return 0 instead of false.\n\n2008-09-18  Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-cp.c (ipcp_estimate_growth): Return 0 instead of false.\n\n\t* ipa-prop.c: Correct comments.\n\t* ipa-prop.h: Likewise.\n\nFrom-SVN: r140464", "tree": {"sha": "41c7d310db75d5c5b7633625f143367537d2f51d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41c7d310db75d5c5b7633625f143367537d2f51d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be95e2b9256eb04ee4f4c56711e813f226591828", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be95e2b9256eb04ee4f4c56711e813f226591828", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be95e2b9256eb04ee4f4c56711e813f226591828", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be95e2b9256eb04ee4f4c56711e813f226591828/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e2c9111c0eac78bd9249d98ecdaebc9a4e327ffb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2c9111c0eac78bd9249d98ecdaebc9a4e327ffb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2c9111c0eac78bd9249d98ecdaebc9a4e327ffb"}], "stats": {"total": 137, "additions": 101, "deletions": 36}, "files": [{"sha": "26a712f41b266c2db0a975ac49f4237fcd7222e2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be95e2b9256eb04ee4f4c56711e813f226591828/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be95e2b9256eb04ee4f4c56711e813f226591828/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=be95e2b9256eb04ee4f4c56711e813f226591828", "patch": "@@ -1,3 +1,10 @@\n+2008-09-18  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* ipa-cp.c (ipcp_estimate_growth): Return 0 instead of false.\n+\n+\t* ipa-prop.c: Correct comments.\n+\t* ipa-prop.h: Likewise.\n+\n 2008-09-18  Jan Hubicka  <jh@suse.cz>\n \n \tPR middle-end/37448"}, {"sha": "455ba91ec3514990087d9b7b8cf95eb4ccfa1923", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be95e2b9256eb04ee4f4c56711e813f226591828/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be95e2b9256eb04ee4f4c56711e813f226591828/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=be95e2b9256eb04ee4f4c56711e813f226591828", "patch": "@@ -1058,7 +1058,7 @@ ipcp_estimate_growth (struct cgraph_node *node)\n   /* If we will be able to fully replace orignal node, we never increase\n      program size.  */\n   if (!need_original)\n-    return false;\n+    return 0;\n \n   info = IPA_NODE_REF (node);\n   count = ipa_get_param_count (info);"}, {"sha": "e741feb833ee2d9c650b97f2dcff9f2f5f0577f4", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 68, "deletions": 23, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be95e2b9256eb04ee4f4c56711e813f226591828/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be95e2b9256eb04ee4f4c56711e813f226591828/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=be95e2b9256eb04ee4f4c56711e813f226591828", "patch": "@@ -46,6 +46,7 @@ static struct cgraph_2edge_hook_list *edge_duplication_hook_holder;\n static struct cgraph_2node_hook_list *node_duplication_hook_holder;\n \n /* Initialize worklist to contain all functions.  */\n+\n struct ipa_func_list *\n ipa_init_func_list (void)\n {\n@@ -67,6 +68,7 @@ ipa_init_func_list (void)\n \n /* Add cgraph node MT to the worklist. Set worklist element WL\n    to point to MT.  */\n+\n void\n ipa_push_func_to_list (struct ipa_func_list **wl, struct cgraph_node *mt)\n {\n@@ -80,6 +82,7 @@ ipa_push_func_to_list (struct ipa_func_list **wl, struct cgraph_node *mt)\n \n /* Remove a function from the worklist. WL points to the first\n    element in the list, which is removed.  */\n+\n struct cgraph_node *\n ipa_pop_func_from_list (struct ipa_func_list ** wl)\n {\n@@ -93,8 +96,9 @@ ipa_pop_func_from_list (struct ipa_func_list ** wl)\n   return return_func;\n }\n \n-/* Return index of the formal whose tree is ptree in function which corresponds\n-   to info.  */\n+/* Return index of the formal whose tree is PTREE in function which corresponds\n+   to INFO.  */\n+\n static int\n ipa_get_param_decl_index (struct ipa_node_params *info, tree ptree)\n {\n@@ -110,6 +114,7 @@ ipa_get_param_decl_index (struct ipa_node_params *info, tree ptree)\n \n /* Populate the param_decl field in parameter descriptors of INFO that\n    corresponds to NODE.  */\n+\n static void\n ipa_populate_param_decls (struct cgraph_node *node,\n \t\t\t  struct ipa_node_params *info)\n@@ -131,6 +136,7 @@ ipa_populate_param_decls (struct cgraph_node *node,\n \n /* Count number of formal parameters in NOTE. Store the result to the\n    appropriate field of INFO.  */\n+\n static void\n ipa_count_formal_params (struct cgraph_node *node,\n \t\t\t struct ipa_node_params *info)\n@@ -151,6 +157,7 @@ ipa_count_formal_params (struct cgraph_node *node,\n /* Initialize the ipa_node_params structure associated with NODE by counting\n    the function parameters, creating the descriptors and populating their\n    param_decls.  */\n+\n void\n ipa_initialize_node_params (struct cgraph_node *node)\n {\n@@ -170,6 +177,7 @@ ipa_initialize_node_params (struct cgraph_node *node)\n    Directly means that this function does not check for modifications through\n    pointers or escaping addresses because all TREE_ADDRESSABLE parameters are\n    considered modified anyway.  */\n+\n static void\n ipa_check_stmt_modifications (struct ipa_node_params *info, gimple stmt)\n {\n@@ -206,6 +214,7 @@ ipa_check_stmt_modifications (struct ipa_node_params *info, gimple stmt)\n    modified.  Parameters may be modified in NODE if they are TREE_ADDRESSABLE,\n    if they appear on the left hand side of an assignment or if there is an\n    ASM_EXPR in the function.  */\n+\n void\n ipa_detect_param_modifications (struct cgraph_node *node)\n {\n@@ -238,8 +247,9 @@ ipa_detect_param_modifications (struct cgraph_node *node)\n   info->modification_analysis_done = 1;\n }\n \n-/* Count number of arguments callsite CS has and store it in \n+/* Count number of arguments callsite CS has and store it in\n    ipa_edge_args structure corresponding to this callsite.  */\n+\n void\n ipa_count_arguments (struct cgraph_edge *cs)\n {\n@@ -256,8 +266,9 @@ ipa_count_arguments (struct cgraph_edge *cs)\n   ipa_set_cs_argument_count (IPA_EDGE_REF (cs), arg_num);\n }\n \n-/* The following function prints the jump functions of all arguments on all\n-   call graph edges going from NODE to file F.  */\n+/* Print the jump functions of all arguments on all call graph edges going from\n+   NODE to file F.  */\n+\n void\n ipa_print_node_jump_functions (FILE *f, struct cgraph_node *node)\n {\n@@ -309,6 +320,7 @@ ipa_print_node_jump_functions (FILE *f, struct cgraph_node *node)\n }\n \n /* Print ipa_jump_func data structures of all nodes in the call graph to F.  */\n+\n void\n ipa_print_all_jump_functions (FILE *f)\n {\n@@ -321,11 +333,12 @@ ipa_print_all_jump_functions (FILE *f)\n     }\n }\n \n-/* The following function determines the jump functions of scalar arguments.\n-   Scalar means SSA names and constants of a number of selected types.  INFO is\n-   the ipa_node_params structure associated with the caller, FUNCTIONS is a\n-   pointer to an array of jump function structures associated with CALL which\n-   is the call statement being examined.*/\n+/* Determine the jump functions of scalar arguments.  Scalar means SSA names\n+   and constants of a number of selected types.  INFO is the ipa_node_params\n+   structure associated with the caller, FUNCTIONS is a pointer to an array of\n+   jump function structures associated with CALL which is the call statement\n+   being examined.*/\n+\n static void\n compute_scalar_jump_functions (struct ipa_node_params *info,\n \t\t\t       struct ipa_jump_func *functions,\n@@ -356,10 +369,11 @@ compute_scalar_jump_functions (struct ipa_node_params *info,\n     }\n }\n \n-/* This function inspects the given TYPE and returns true iff it has the same\n-   structure (the same number of fields of the same types) as a C++ member\n-   pointer.  If METHOD_PTR and DELTA are non-NULL, the trees representing the\n-   corresponding fields are stored there.  */\n+/* Inspect the given TYPE and return true iff it has the same structure (the\n+   same number of fields of the same types) as a C++ member pointer.  If\n+   METHOD_PTR and DELTA are non-NULL, store the trees representing the\n+   corresponding fields there.  */\n+\n static bool\n type_like_member_ptr_p (tree type, tree *method_ptr, tree *delta)\n {\n@@ -388,11 +402,12 @@ type_like_member_ptr_p (tree type, tree *method_ptr, tree *delta)\n   return true;\n }\n \n-/* This function goes through arguments of the CALL and for every one that\n-   looks like a member pointer, it checks whether it can be safely declared\n-   pass-through and if so, marks that to the corresponding item of jum\n-   FUNCTIONS .  It returns true iff there were non-pass-through member pointers\n-   within the arguments.  INFO describes formal parameters of the caller.  */\n+/* Go through arguments of the CALL and for every one that looks like a member\n+   pointer, check whether it can be safely declared pass-through and if so,\n+   mark that to the corresponding item of jump FUNCTIONS.  Return true iff\n+   there are non-pass-through member pointers within the arguments.  INFO\n+   describes formal parameters of the caller.  */\n+\n static bool\n compute_pass_through_member_ptrs (struct ipa_node_params *info,\n \t\t\t\t  struct ipa_jump_func *functions,\n@@ -431,6 +446,7 @@ compute_pass_through_member_ptrs (struct ipa_node_params *info,\n \n /* Simple function filling in a member pointer constant jump function (with PFN\n    and DELTA as the constant value) into JFUNC.  */\n+\n static void\n fill_member_ptr_cst_jump_function (struct ipa_jump_func *jfunc,\n \t\t\t\t   tree pfn, tree delta)\n@@ -449,6 +465,7 @@ fill_member_ptr_cst_jump_function (struct ipa_jump_func *jfunc,\n      D.2515.__pfn ={v} printStuff;\n      D.2515.__delta ={v} 0;\n      i_1 = doprinting (D.2515);  */\n+\n static void\n determine_cst_member_ptr (gimple call, tree arg, tree method_field,\n \t\t\t  tree delta_field, struct ipa_jump_func *jfunc)\n@@ -516,6 +533,7 @@ determine_cst_member_ptr (gimple call, tree arg, tree method_field,\n    tries determine whether it is a constant.  If it is, create a corresponding\n    constant jump function in FUNCTIONS which is an array of jump functions\n    associated with the call.  */\n+\n static void\n compute_cst_member_ptr_arguments (struct ipa_jump_func *functions,\n \t\t\t\t  gimple call)\n@@ -538,6 +556,7 @@ compute_cst_member_ptr_arguments (struct ipa_jump_func *functions,\n /* Compute jump function for all arguments of callsite CS and insert the\n    information in the jump_functions array in the ipa_edge_args corresponding\n    to this callsite.  */\n+\n void\n ipa_compute_jump_functions (struct cgraph_edge *cs)\n {\n@@ -561,13 +580,14 @@ ipa_compute_jump_functions (struct cgraph_edge *cs)\n   if (!compute_pass_through_member_ptrs (info, arguments->jump_functions, call))\n     return;\n \n-  /* Finally, let's check whether we actually pass a new constant membeer\n+  /* Finally, let's check whether we actually pass a new constant member\n      pointer here...  */\n   compute_cst_member_ptr_arguments (arguments->jump_functions, call);\n }\n \n /* If RHS looks like a rhs of a statement loading pfn from a member pointer\n    formal parameter, return the parameter, otherwise return NULL.  */\n+\n static tree\n ipa_get_member_ptr_load_param (tree rhs)\n {\n@@ -590,7 +610,8 @@ ipa_get_member_ptr_load_param (tree rhs)\n }\n \n /* If STMT looks like a statement loading a value from a member pointer formal\n-   parameter, this function retuns that parameter.  */\n+   parameter, this function returns that parameter.  */\n+\n static tree\n ipa_get_stmt_member_ptr_load_param (gimple stmt)\n {\n@@ -604,6 +625,7 @@ ipa_get_stmt_member_ptr_load_param (gimple stmt)\n }\n \n /* Returns true iff T is an SSA_NAME defined by a statement.  */\n+\n static bool\n ipa_is_ssa_with_stmt_def (tree t)\n {\n@@ -617,6 +639,7 @@ ipa_is_ssa_with_stmt_def (tree t)\n /* Creates a new note describing a call to a parameter number FORMAL_ID and\n    attaches it to the linked list of INFO.  It also sets the called flag of the\n    parameter.  STMT is the corresponding call statement.  */\n+\n static void\n ipa_note_param_call (struct ipa_node_params *info, int formal_id,\n \t\t     gimple stmt)\n@@ -808,6 +831,7 @@ ipa_analyze_call_uses (struct ipa_node_params *info, gimple call)\n /* Analyze the statement STMT with respect to formal parameters (described in\n    INFO) and their uses.  Currently it only checks whether formal parameters\n    are called.  */\n+\n static void\n ipa_analyze_stmt_uses (struct ipa_node_params *info, gimple stmt)\n {\n@@ -818,6 +842,7 @@ ipa_analyze_stmt_uses (struct ipa_node_params *info, gimple stmt)\n /* Scan the function body of NODE and inspect the uses of formal parameters.\n    Store the findings in various structures of the associated ipa_node_params\n    structure, such as parameter flags, notes etc.  */\n+\n void\n ipa_analyze_params_uses (struct cgraph_node *node)\n {\n@@ -843,9 +868,10 @@ ipa_analyze_params_uses (struct cgraph_node *node)\n   info->uses_analysis_done = 1;\n }\n \n-/* Update the jump functions assocated with call graph edge E when the call\n+/* Update the jump functions associated with call graph edge E when the call\n    graph edge CS is being inlined, assuming that E->caller is already (possibly\n    indirectly) inlined into CS->callee and that E has not been inlined.  */\n+\n static void\n update_jump_functions_after_inlining (struct cgraph_edge *cs,\n \t\t\t\t      struct cgraph_edge *e)\n@@ -875,8 +901,9 @@ update_jump_functions_after_inlining (struct cgraph_edge *cs,\n }\n \n /* Print out a debug message to file F that we have discovered that an indirect\n-   call descibed by NT is in fact a call of a known constant function descibed\n+   call described by NT is in fact a call of a known constant function described\n    by JFUNC.  NODE is the node where the call is.  */\n+\n static void\n print_edge_addition_message (FILE *f, struct ipa_param_call_note *nt,\n \t\t\t     struct ipa_jump_func *jfunc,\n@@ -900,6 +927,7 @@ print_edge_addition_message (FILE *f, struct ipa_param_call_note *nt,\n    Moreover, if the callee is discovered to be constant, create a new cgraph\n    edge for it.  Newly discovered indirect edges will be added to *NEW_EDGES,\n    unless NEW_EDGES is NULL.  Return true iff a new edge(s) were created.  */\n+\n static bool\n update_call_notes_after_inlining (struct cgraph_edge *cs,\n \t\t\t\t  struct cgraph_node *node,\n@@ -973,6 +1001,7 @@ update_call_notes_after_inlining (struct cgraph_edge *cs,\n    of this subtree.  Newly discovered indirect edges will be added to\n    *NEW_EDGES, unless NEW_EDGES is NULL.  Return true iff a new edge(s) were\n    created.  */\n+\n static bool\n propagate_info_to_inlined_callees (struct cgraph_edge *cs,\n \t\t\t\t   struct cgraph_node *node,\n@@ -997,6 +1026,7 @@ propagate_info_to_inlined_callees (struct cgraph_edge *cs,\n    cgraph_clone_inline_nodes.  Newly discovered indirect edges will be added to\n    *NEW_EDGES, unless NEW_EDGES is NULL.  Return true iff a new edge(s) were +\n    created.  */\n+\n bool\n ipa_propagate_indirect_call_infos (struct cgraph_edge *cs,\n \t\t\t\t   VEC (cgraph_edge_p, heap) **new_edges)\n@@ -1012,6 +1042,7 @@ ipa_propagate_indirect_call_infos (struct cgraph_edge *cs,\n \n /* Frees all dynamically allocated structures that the argument info points\n    to.  */\n+\n void\n ipa_free_edge_args_substructures (struct ipa_edge_args *args)\n {\n@@ -1022,6 +1053,7 @@ ipa_free_edge_args_substructures (struct ipa_edge_args *args)\n }\n \n /* Free all ipa_edge structures.  */\n+\n void\n ipa_free_all_edge_args (void)\n {\n@@ -1039,6 +1071,7 @@ ipa_free_all_edge_args (void)\n \n /* Frees all dynamically allocated structures that the param info points\n    to.  */\n+\n void\n ipa_free_node_params_substructures (struct ipa_node_params *info)\n {\n@@ -1056,6 +1089,7 @@ ipa_free_node_params_substructures (struct ipa_node_params *info)\n }\n \n /* Free all ipa_node_params structures.  */\n+\n void\n ipa_free_all_node_params (void)\n {\n@@ -1072,6 +1106,7 @@ ipa_free_all_node_params (void)\n }\n \n /* Hook that is called by cgraph.c when an edge is removed.  */\n+\n static void\n ipa_edge_removal_hook (struct cgraph_edge *cs,\n \t\t       void *data __attribute__ ((unused)))\n@@ -1084,6 +1119,7 @@ ipa_edge_removal_hook (struct cgraph_edge *cs,\n }\n \n /* Hook that is called by cgraph.c when a node is removed.  */\n+\n static void\n ipa_node_removal_hook (struct cgraph_node *node,\n \t\t       void *data __attribute__ ((unused)))\n@@ -1093,6 +1129,7 @@ ipa_node_removal_hook (struct cgraph_node *node,\n \n /* Helper function to duplicate an array of size N that is at SRC and store a\n    pointer to it to DST.  Nothing is done if SRC is NULL.  */\n+\n static void *\n duplicate_array (void *src, size_t n)\n {\n@@ -1107,6 +1144,7 @@ duplicate_array (void *src, size_t n)\n }\n \n /* Hook that is called by cgraph.c when a node is duplicated.  */\n+\n static void\n ipa_edge_duplication_hook (struct cgraph_edge *src, struct cgraph_edge *dst,\n \t\t\t   __attribute__((unused)) void *data)\n@@ -1127,6 +1165,7 @@ ipa_edge_duplication_hook (struct cgraph_edge *src, struct cgraph_edge *dst,\n }\n \n /* Hook that is called by cgraph.c when a node is duplicated.  */\n+\n static void\n ipa_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n \t\t\t   __attribute__((unused)) void *data)\n@@ -1160,6 +1199,7 @@ ipa_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n }\n \n /* Register our cgraph hooks if they are not already there.  */\n+\n void\n ipa_register_cgraph_hooks (void)\n {\n@@ -1178,6 +1218,7 @@ ipa_register_cgraph_hooks (void)\n }\n \n /* Unregister our cgraph hooks if they are not already there.  */\n+\n static void\n ipa_unregister_cgraph_hooks (void)\n {\n@@ -1193,6 +1234,7 @@ ipa_unregister_cgraph_hooks (void)\n \n /* Free all ipa_node_params and all ipa_edge_args structures if they are no\n    longer needed after ipa-cp.  */\n+\n void\n free_all_ipa_structures_after_ipa_cp (void)\n {\n@@ -1206,6 +1248,7 @@ free_all_ipa_structures_after_ipa_cp (void)\n \n /* Free all ipa_node_params and all ipa_edge_args structures if they are no\n    longer needed after indirect inlining.  */\n+\n void\n free_all_ipa_structures_after_iinln (void)\n {\n@@ -1216,6 +1259,7 @@ free_all_ipa_structures_after_iinln (void)\n \n /* Print ipa_tree_map data structures of all functions in the\n    callgraph to F.  */\n+\n void\n ipa_print_node_params (FILE * f, struct cgraph_node *node)\n {\n@@ -1244,6 +1288,7 @@ ipa_print_node_params (FILE * f, struct cgraph_node *node)\n \n /* Print ipa_tree_map data structures of all functions in the\n    callgraph to F.  */\n+\n void\n ipa_print_all_params (FILE * f)\n {"}, {"sha": "aca7bf8ef25373cdf7d34a5c03315a074d649827", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 25, "deletions": 12, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be95e2b9256eb04ee4f4c56711e813f226591828/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be95e2b9256eb04ee4f4c56711e813f226591828/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=be95e2b9256eb04ee4f4c56711e813f226591828", "patch": "@@ -27,7 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n /* The following definitions and interfaces are used by\n    interprocedural analyses.  */\n \n-/* A jump function for a callsite represents the values passed as actual \n+/* A jump function for a callsite represents the values passed as actual\n    arguments of the callsite. There are three main types of values :\n    Formal - the caller's formal parameter is passed as an actual argument.\n    Constant - a constant is passed as an actual argument.\n@@ -78,16 +78,16 @@ union jump_func_value\n   struct ipa_member_ptr_cst member_cst;\n };\n \n-/* A jump function for a callsite represents the values passed as actual \n-   arguments of the callsite. See enum jump_func_type for the various \n+/* A jump function for a callsite represents the values passed as actual\n+   arguments of the callsite. See enum jump_func_type for the various\n    types of jump functions supported.  */\n struct ipa_jump_func\n {\n   enum jump_func_type type;\n   union jump_func_value value;\n };\n \n-/* All formal parameters in the program have a cval computed by \n+/* All formal parameters in the program have a cval computed by\n    the interprocedural stage of IPCP. See enum ipa_lattice_type for\n    the various types of lattices supported */\n struct ipcp_lattice\n@@ -102,7 +102,7 @@ struct ipa_replace_map\n {\n   /* The tree that will be replaced.  */\n   tree old_tree;\n-  /* The new (replacing) tree.  */ \n+  /* The new (replacing) tree.  */\n   tree new_tree;\n   /* True when a substitution should be done, false otherwise.  */\n   bool replace_p;\n@@ -165,8 +165,8 @@ struct ipa_node_params\n      it points to the node that IPA cp cloned from.  */\n   struct cgraph_node *ipcp_orig_node;\n   /* Meaningful only for original functions.  Expresses the\n-     ratio between the direct calls and sum of all invocations of \n-     this function (given by profiling info).  It is used to calculate \n+     ratio between the direct calls and sum of all invocations of\n+     this function (given by profiling info).  It is used to calculate\n      the profiling information of the original function and the versioned\n      one.  */\n   gcov_type count_scale;\n@@ -184,13 +184,15 @@ struct ipa_node_params\n    are or will be shared among various passes.  */\n \n /* Set the number of formal parameters. */\n+\n static inline void\n ipa_set_param_count (struct ipa_node_params *info, int count)\n {\n   info->param_count = count;\n }\n \n /* Return the number of formal parameters. */\n+\n static inline int\n ipa_get_param_count (struct ipa_node_params *info)\n {\n@@ -200,6 +202,7 @@ ipa_get_param_count (struct ipa_node_params *info)\n /* Return the declaration of Ith formal parameter of the function corresponding\n    to INFO.  Note there is no setter function as this array is built just once\n    using ipa_initialize_node_params. */\n+\n static inline tree\n ipa_get_param (struct ipa_node_params *info, int i)\n {\n@@ -210,6 +213,7 @@ ipa_get_param (struct ipa_node_params *info, int i)\n    the function associated with INFO.  Note that there is no setter method as\n    the goal is to set all flags when building the array in\n    ipa_detect_param_modifications.  */\n+\n static inline bool\n ipa_is_param_modified (struct ipa_node_params *info, int i)\n {\n@@ -220,20 +224,23 @@ ipa_is_param_modified (struct ipa_node_params *info, int i)\n    function associated with INFO.  Note that there is no setter method as the\n    goal is to set all flags when building the array in\n    ipa_detect_called_params.  */\n+\n static inline bool\n ipa_is_param_called (struct ipa_node_params *info, int i)\n {\n   return info->params[i].called;\n }\n \n /* Flag this node as having callers with variable number of arguments.  */\n+\n static inline void\n ipa_set_called_with_variable_arg (struct ipa_node_params *info)\n {\n   info->called_with_var_arguments = 1;\n }\n \n /* Have we detected this node was called with variable number of arguments? */\n+\n static inline bool\n ipa_is_called_with_var_arguments (struct ipa_node_params *info)\n {\n@@ -259,13 +266,15 @@ struct ipa_edge_args\n    are or will be shared among various passes.  */\n \n /* Set the number of actual arguments. */\n+\n static inline void\n ipa_set_cs_argument_count (struct ipa_edge_args *args, int count)\n {\n   args->argument_count = count;\n }\n \n /* Return the number of actual arguments. */\n+\n static inline int\n ipa_get_cs_argument_count (struct ipa_edge_args *args)\n {\n@@ -275,6 +284,7 @@ ipa_get_cs_argument_count (struct ipa_edge_args *args)\n /* Returns a pointer to the jump function for the ith argument.  Please note\n    there is no setter function as jump functions are all set up in\n    ipa_compute_jump_functions. */\n+\n static inline struct ipa_jump_func *\n ipa_get_ith_jump_func (struct ipa_edge_args *args, int i)\n {\n@@ -285,7 +295,7 @@ ipa_get_ith_jump_func (struct ipa_edge_args *args, int i)\n typedef struct ipa_node_params ipa_node_params_t;\n typedef struct ipa_edge_args ipa_edge_args_t;\n \n-/* Types of vectors hodling the infos.  */\n+/* Types of vectors holding the infos.  */\n DEF_VEC_O (ipa_node_params_t);\n DEF_VEC_ALLOC_O (ipa_node_params_t, heap);\n DEF_VEC_O (ipa_edge_args_t);\n@@ -318,7 +328,8 @@ void free_all_ipa_structures_after_iinln (void);\n void ipa_register_cgraph_hooks (void);\n \n /* This function ensures the array of node param infos is big enough to\n-   accomdate a structure for all nodes and realloacates it if not.  */\n+   accommodate a structure for all nodes and reallocates it if not.  */\n+\n static inline void\n ipa_check_create_node_params (void)\n {\n@@ -332,8 +343,9 @@ ipa_check_create_node_params (void)\n \t\t\t   ipa_node_params_vector, cgraph_max_uid + 1);\n }\n \n-/* This function ensures the array of adge arguments infos is big enough to\n-   accomdate a structure for all edges and realloacates it if not.  */\n+/* This function ensures the array of edge arguments infos is big enough to\n+   accommodate a structure for all edges and reallocates it if not.  */\n+\n static inline void\n ipa_check_create_edge_args (void)\n {\n@@ -347,9 +359,10 @@ ipa_check_create_edge_args (void)\n \t\t\t   cgraph_edge_max_uid + 1);\n }\n \n-/* Returns true if the array of edge infos is large enough to accomodate an\n+/* Returns true if the array of edge infos is large enough to accommodate an\n    info for EDGE.  The main purpose of this function is that debug dumping\n    function can check info availability without causing reallocations.  */\n+\n static inline bool\n ipa_edge_args_info_available_for_edge_p (struct cgraph_edge *edge)\n {"}]}