{"sha": "a60749f509279b1dff2918c50649bfb53b86617d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTYwNzQ5ZjUwOTI3OWIxZGZmMjkxOGM1MDY0OWJmYjUzYjg2NjE3ZA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2004-09-04T12:35:41Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2004-09-04T12:35:41Z"}, "message": "fold-const.c (operand_equal_p): Remove code to allow null ARG0/1.\n\n\t* fold-const.c (operand_equal_p): Remove code to allow null ARG0/1.\n\tDefine locals macros OP_SAME and OP_SAME_WITH_NULL and use throughout.\n\nFrom-SVN: r87082", "tree": {"sha": "c797cd63f4d77ce7cbd6a28c6ce217cf2026d081", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c797cd63f4d77ce7cbd6a28c6ce217cf2026d081"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a60749f509279b1dff2918c50649bfb53b86617d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a60749f509279b1dff2918c50649bfb53b86617d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a60749f509279b1dff2918c50649bfb53b86617d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a60749f509279b1dff2918c50649bfb53b86617d/comments", "author": null, "committer": null, "parents": [{"sha": "8d168c2457d819a6c89c0b198fb2c0e093754504", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d168c2457d819a6c89c0b198fb2c0e093754504", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d168c2457d819a6c89c0b198fb2c0e093754504"}], "stats": {"total": 95, "additions": 41, "deletions": 54}, "files": [{"sha": "e231cb53dcf17c29927bdfb226469e2f6158afa2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a60749f509279b1dff2918c50649bfb53b86617d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a60749f509279b1dff2918c50649bfb53b86617d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a60749f509279b1dff2918c50649bfb53b86617d", "patch": "@@ -1,3 +1,8 @@\n+2004-09-04  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* fold-const.c (operand_equal_p): Remove code to allow null ARG0/1.\n+\tDefine locals macros OP_SAME and OP_SAME_WITH_NULL and use throughout.\n+\n 2004-09-04  Jan Hubicka  <jh@suse.cz>\n \n \t* passes.c (rest_of_clean_state):  Fix merge conflict made during"}, {"sha": "538dd76d93623b8cc8edfef9dc1cb24c63335f9a", "filename": "gcc/fold-const.c", "status": "modified", "additions": 36, "deletions": 54, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a60749f509279b1dff2918c50649bfb53b86617d/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a60749f509279b1dff2918c50649bfb53b86617d/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=a60749f509279b1dff2918c50649bfb53b86617d", "patch": "@@ -2285,17 +2285,8 @@ truth_value_p (enum tree_code code)\n int\n operand_equal_p (tree arg0, tree arg1, unsigned int flags)\n {\n-  /* If one is specified and the other isn't, they aren't equal and if\n-     neither is specified, they are.\n-\n-     ??? This is temporary and is meant only to handle the cases of the\n-     optional operands for COMPONENT_REF and ARRAY_REF.  */\n-  if ((arg0 && !arg1) || (!arg0 && arg1))\n-    return 0;\n-  else if (!arg0 && !arg1)\n-    return 1;\n   /* If either is ERROR_MARK, they aren't equal.  */\n-  else if (TREE_CODE (arg0) == ERROR_MARK || TREE_CODE (arg1) == ERROR_MARK)\n+  if (TREE_CODE (arg0) == ERROR_MARK || TREE_CODE (arg1) == ERROR_MARK)\n     return 0;\n \n   /* If both types don't have the same signedness, then we can't consider\n@@ -2387,6 +2378,17 @@ operand_equal_p (tree arg0, tree arg1, unsigned int flags)\n   if (flags & OEP_ONLY_CONST)\n     return 0;\n \n+/* Define macros to test an operan from arg0 and arg1 for equality and a\n+   variant that allows null and views null as being different from any\n+   non-null value.  In the latter case, if either is null, the both\n+   must be; otherwise, do the normal comparison.  */\n+#define OP_SAME(N) operand_equal_p (TREE_OPERAND (arg0, N),\t\\\n+\t\t\t\t    TREE_OPERAND (arg1, N), flags)\n+\n+#define OP_SAME_WITH_NULL(N)\t\t\t\t\\\n+  ((!TREE_OPERAND (arg0, N) || !TREE_OPERAND (arg1, N))\t\\\n+   ? TREE_OPERAND (arg0, N) == TREE_OPERAND (arg1, N) : OP_SAME (N))\n+\n   switch (TREE_CODE_CLASS (TREE_CODE (arg0)))\n     {\n     case '1':\n@@ -2407,15 +2409,11 @@ operand_equal_p (tree arg0, tree arg1, unsigned int flags)\n \t  break;\n \t}\n \n-      return operand_equal_p (TREE_OPERAND (arg0, 0),\n-\t\t\t      TREE_OPERAND (arg1, 0), flags);\n+      return OP_SAME (0);\n \n     case '<':\n     case '2':\n-      if (operand_equal_p (TREE_OPERAND (arg0, 0),\n-\t\t\t   TREE_OPERAND (arg1, 0), flags)\n-\t  && operand_equal_p (TREE_OPERAND (arg0, 1),\n-\t\t\t      TREE_OPERAND (arg1, 1), flags))\n+      if (OP_SAME (0) && OP_SAME (1))\n \treturn 1;\n \n       /* For commutative ops, allow the other order.  */\n@@ -2437,37 +2435,23 @@ operand_equal_p (tree arg0, tree arg1, unsigned int flags)\n \tcase INDIRECT_REF:\n \tcase REALPART_EXPR:\n \tcase IMAGPART_EXPR:\n-\t  return operand_equal_p (TREE_OPERAND (arg0, 0),\n-\t\t\t\t  TREE_OPERAND (arg1, 0), flags);\n+\t  return OP_SAME (0);\n \n \tcase ARRAY_REF:\n \tcase ARRAY_RANGE_REF:\n-\t  return (operand_equal_p (TREE_OPERAND (arg0, 0),\n-\t\t\t\t   TREE_OPERAND (arg1, 0), flags)\n-\t\t  && operand_equal_p (TREE_OPERAND (arg0, 1),\n-\t\t\t\t      TREE_OPERAND (arg1, 1), flags)\n-\t\t  && operand_equal_p (TREE_OPERAND (arg0, 2),\n-\t\t\t\t      TREE_OPERAND (arg1, 2), flags)\n-\t\t  && operand_equal_p (TREE_OPERAND (arg0, 3),\n-\t\t\t\t      TREE_OPERAND (arg1, 3), flags));\n-\n+\t  /* Operands 2 and 3 may be null.  */\n+\t  return (OP_SAME (0)\n+\t\t  && OP_SAME (1)\n+\t\t  && OP_SAME_WITH_NULL (2)\n+\t\t  && OP_SAME_WITH_NULL (3));\n \n \tcase COMPONENT_REF:\n-\t  return (operand_equal_p (TREE_OPERAND (arg0, 0),\n-\t\t\t\t   TREE_OPERAND (arg1, 0), flags)\n-\t\t  && operand_equal_p (TREE_OPERAND (arg0, 1),\n-\t\t\t\t      TREE_OPERAND (arg1, 1), flags)\n-\t\t  && operand_equal_p (TREE_OPERAND (arg0, 2),\n-\t\t\t\t      TREE_OPERAND (arg1, 2), flags));\n-\n+\t  /* Handle operand 2 the same as for ARRAY_REF.  */\n+\t  return OP_SAME (0) && OP_SAME (1) && OP_SAME_WITH_NULL (2);\n \n \tcase BIT_FIELD_REF:\n-\t  return (operand_equal_p (TREE_OPERAND (arg0, 0),\n-\t\t\t\t   TREE_OPERAND (arg1, 0), flags)\n-\t\t  && operand_equal_p (TREE_OPERAND (arg0, 1),\n-\t\t\t\t      TREE_OPERAND (arg1, 1), flags)\n-\t\t  && operand_equal_p (TREE_OPERAND (arg0, 2),\n-\t\t\t\t      TREE_OPERAND (arg1, 2), flags));\n+\t  return OP_SAME (0) && OP_SAME (1) && OP_SAME (2);\n+\n \tdefault:\n \t  return 0;\n \t}\n@@ -2477,33 +2461,28 @@ operand_equal_p (tree arg0, tree arg1, unsigned int flags)\n \t{\n \tcase ADDR_EXPR:\n \tcase TRUTH_NOT_EXPR:\n-\t  return operand_equal_p (TREE_OPERAND (arg0, 0),\n-\t\t\t\t  TREE_OPERAND (arg1, 0), flags);\n+\t  return OP_SAME (0);\n \n \tcase TRUTH_ANDIF_EXPR:\n \tcase TRUTH_ORIF_EXPR:\n-\t  return operand_equal_p (TREE_OPERAND (arg0, 0),\n-\t\t\t\t  TREE_OPERAND (arg1, 0), flags)\n-\t\t && operand_equal_p (TREE_OPERAND (arg0, 1),\n-\t\t\t\t     TREE_OPERAND (arg1, 1), flags);\n+\t  return OP_SAME (0) && OP_SAME (1);\n \n \tcase TRUTH_AND_EXPR:\n \tcase TRUTH_OR_EXPR:\n \tcase TRUTH_XOR_EXPR:\n+\t  if (OP_SAME (0) && OP_SAME (1))\n+\t    return 1;\n+\n+\t  /* Otherwise take into account this is a commutative operation.  */\n \t  return (operand_equal_p (TREE_OPERAND (arg0, 0),\n-\t\t\t\t   TREE_OPERAND (arg1, 0), flags)\n+\t\t\t\t   TREE_OPERAND (arg1, 1), flags)\n \t\t  && operand_equal_p (TREE_OPERAND (arg0, 1),\n-\t\t\t\t      TREE_OPERAND (arg1, 1), flags))\n-\t\t || (operand_equal_p (TREE_OPERAND (arg0, 0),\n-\t\t\t\t      TREE_OPERAND (arg1, 1), flags)\n-\t\t     && operand_equal_p (TREE_OPERAND (arg0, 1),\n-\t\t\t\t\t TREE_OPERAND (arg1, 0), flags));\n+\t\t\t\t      TREE_OPERAND (arg1, 0), flags));\n \n \tcase CALL_EXPR:\n \t  /* If the CALL_EXPRs call different functions, then they\n \t     clearly can not be equal.  */\n-\t  if (! operand_equal_p (TREE_OPERAND (arg0, 0),\n-\t\t\t\t TREE_OPERAND (arg1, 0), flags))\n+\t  if (!OP_SAME (0))\n \t    return 0;\n \n \t  {\n@@ -2549,6 +2528,9 @@ operand_equal_p (tree arg0, tree arg1, unsigned int flags)\n     default:\n       return 0;\n     }\n+\n+#undef OP_SAME\n+#undef OP_SAME_WITH_NULL\n }\n \f\n /* Similar to operand_equal_p, but see if ARG0 might have been made by"}]}