{"sha": "be3c16c474629e69c6c4cd6465ffa4b572cc6460", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmUzYzE2YzQ3NDYyOWU2OWM2YzRjZDY0NjVmZmE0YjU3MmNjNjQ2MA==", "commit": {"author": {"name": "Dehao Chen", "email": "dehao@google.com", "date": "2014-10-21T17:59:30Z"}, "committer": {"name": "Dehao Chen", "email": "dehao@gcc.gnu.org", "date": "2014-10-21T17:59:30Z"}, "message": "Add AutoFDO.\n\ngcc/ChangeLog:\n\n2014-10-21  Dehao Chen  <dehao@google.com>\n\n\t* auto-profile.c: New file.\n\t* auto-profile.h: New file.\n\t* basic-block.h (maybe_hot_count_p): New export func.\n\t(add_working_set): New export func.\n\t* gcov-io.h (GCOV_TAG_AFDO_FILE_NAMES): New tag.\n\t(GCOV_TAG_AFDO_FUNCTION): Likewise.\n\t(GCOV_TAG_AFDO_WORKING_SET): Likewise.\n\t* opts.c (enable_fdo_optimizations): New func.\n\t(common_handle_option): Handle -fauto-profile flag.\n\t* ipa-inline.c (want_early_inline_function_p): Iterative-einline.\n\t(class pass_early_inline): Export early_inliner.\n\t(early_inliner): Likewise.\n\t(pass_early_inline::execute): Likewise.\n\t* ipa-inline.h (early_inliner): Likewise.\n\t* predict.c (maybe_hot_count_p): New export func.\n\t(counts_to_freqs): AutoFDO logic.\n\t(rebuild_frequencies): Likewise.\n\t* tree-profile.c (pass_ipa_tree_profile::gate): Likewise.\n\t* profile.c (add_working_set): New func.\n\t* Makefile.in (auto-profile.o): New object file.\n\t* passes.def (pass_ipa_auto_profile): New pass.\n\t* tree-ssa-live.c (remove_unused_scope_block_p): AutoFDO logic.\n\t* tree-pass.h (make_pass_ipa_auto_profile): New pass.\n\t* toplev.c (compile_file): AutoFDO logic.\n\t* doc/invoke.texi (-fauto-profile): New doc.\n\t* coverage.c (coverage_init): AutoFDO logic.\n\t* common.opt (-fauto-profile): New flag.\n\t* timevar.def (TV_IPA_AUTOFDO): New tag.\n\t* value-prof.c (gimple_alloc_histogram_value): New export func.\n\t(check_ic_target): Likewise.\n\t* value-prof.h (gimple_alloc_histogram_value): Likewise.\n\t(check_ic_target): Likewise.\n\nFrom-SVN: r216523", "tree": {"sha": "2dca135cb3eadb5a684bff2c9f64afbafd4ba80e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2dca135cb3eadb5a684bff2c9f64afbafd4ba80e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be3c16c474629e69c6c4cd6465ffa4b572cc6460", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be3c16c474629e69c6c4cd6465ffa4b572cc6460", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be3c16c474629e69c6c4cd6465ffa4b572cc6460", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be3c16c474629e69c6c4cd6465ffa4b572cc6460/comments", "author": {"login": "danielcdh", "id": 694263, "node_id": "MDQ6VXNlcjY5NDI2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/694263?v=4", "gravatar_id": "", "url": "https://api.github.com/users/danielcdh", "html_url": "https://github.com/danielcdh", "followers_url": "https://api.github.com/users/danielcdh/followers", "following_url": "https://api.github.com/users/danielcdh/following{/other_user}", "gists_url": "https://api.github.com/users/danielcdh/gists{/gist_id}", "starred_url": "https://api.github.com/users/danielcdh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/danielcdh/subscriptions", "organizations_url": "https://api.github.com/users/danielcdh/orgs", "repos_url": "https://api.github.com/users/danielcdh/repos", "events_url": "https://api.github.com/users/danielcdh/events{/privacy}", "received_events_url": "https://api.github.com/users/danielcdh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3edf64aa919b9bf725672bd0ad91bfd30c6a31df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3edf64aa919b9bf725672bd0ad91bfd30c6a31df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3edf64aa919b9bf725672bd0ad91bfd30c6a31df"}], "stats": {"total": 2030, "additions": 1950, "deletions": 80}, "files": [{"sha": "931ec2e5253dc3211a62e7ef3f88bf7ec3043b94", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be3c16c474629e69c6c4cd6465ffa4b572cc6460/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be3c16c474629e69c6c4cd6465ffa4b572cc6460/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=be3c16c474629e69c6c4cd6465ffa4b572cc6460", "patch": "@@ -1,3 +1,38 @@\n+2014-10-21  Dehao Chen  <dehao@google.com>\n+\n+\t* auto-profile.c: New file.\n+\t* auto-profile.h: New file.\n+\t* basic-block.h (maybe_hot_count_p): New export func.\n+\t(add_working_set): New export func.\n+\t* gcov-io.h (GCOV_TAG_AFDO_FILE_NAMES): New tag.\n+\t(GCOV_TAG_AFDO_FUNCTION): Likewise.\n+\t(GCOV_TAG_AFDO_WORKING_SET): Likewise.\n+\t* opts.c (enable_fdo_optimizations): New func.\n+\t(common_handle_option): Handle -fauto-profile flag.\n+\t* ipa-inline.c (want_early_inline_function_p): Iterative-einline.\n+\t(class pass_early_inline): Export early_inliner.\n+\t(early_inliner): Likewise.\n+\t(pass_early_inline::execute): Likewise.\n+\t* ipa-inline.h (early_inliner): Likewise.\n+\t* predict.c (maybe_hot_count_p): New export func.\n+\t(counts_to_freqs): AutoFDO logic.\n+\t(rebuild_frequencies): Likewise.\n+\t* tree-profile.c (pass_ipa_tree_profile::gate): Likewise.\n+\t* profile.c (add_working_set): New func.\n+\t* Makefile.in (auto-profile.o): New object file.\n+\t* passes.def (pass_ipa_auto_profile): New pass.\n+\t* tree-ssa-live.c (remove_unused_scope_block_p): AutoFDO logic.\n+\t* tree-pass.h (make_pass_ipa_auto_profile): New pass.\n+\t* toplev.c (compile_file): AutoFDO logic.\n+\t* doc/invoke.texi (-fauto-profile): New doc.\n+\t* coverage.c (coverage_init): AutoFDO logic.\n+\t* common.opt (-fauto-profile): New flag.\n+\t* timevar.def (TV_IPA_AUTOFDO): New tag.\n+\t* value-prof.c (gimple_alloc_histogram_value): New export func.\n+\t(check_ic_target): Likewise.\n+\t* value-prof.h (gimple_alloc_histogram_value): Likewise.\n+\t(check_ic_target): Likewise.\n+\n 2014-10-21  David Malcolm  <dmalcolm@redhat.com>\n \n \t* cgraph.c (cgraph_c_finalize): New function."}, {"sha": "1fd7915814cd4c8ab07ab30311830309cacbd45f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be3c16c474629e69c6c4cd6465ffa4b572cc6460/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be3c16c474629e69c6c4cd6465ffa4b572cc6460/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=be3c16c474629e69c6c4cd6465ffa4b572cc6460", "patch": "@@ -1153,6 +1153,7 @@ OBJS = \\\n \talias.o \\\n \talloc-pool.o \\\n \tauto-inc-dec.o \\\n+\tauto-profile.o \\\n \tbb-reorder.o \\\n \tbitmap.o \\\n \tbt-load.o \\"}, {"sha": "24d7126a07a7d63c2e978d5c4c29a005277397d2", "filename": "gcc/auto-profile.c", "status": "added", "additions": 1687, "deletions": 0, "changes": 1687, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be3c16c474629e69c6c4cd6465ffa4b572cc6460/gcc%2Fauto-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be3c16c474629e69c6c4cd6465ffa4b572cc6460/gcc%2Fauto-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-profile.c?ref=be3c16c474629e69c6c4cd6465ffa4b572cc6460", "patch": "@@ -0,0 +1,1687 @@\n+/* Read and annotate call graph profile from the auto profile data file.\n+   Copyright (C) 2014. Free Software Foundation, Inc.\n+   Contributed by Dehao Chen (dehao@google.com)\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include <string.h>\n+#include <map>\n+#include <set>\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"tree-pass.h\"\n+#include \"flags.h\"\n+#include \"basic-block.h\"\n+#include \"diagnostic-core.h\"\n+#include \"gcov-io.h\"\n+#include \"input.h\"\n+#include \"profile.h\"\n+#include \"langhooks.h\"\n+#include \"opts.h\"\n+#include \"tree-pass.h\"\n+#include \"cfgloop.h\"\n+#include \"tree-ssa-alias.h\"\n+#include \"tree-cfg.h\"\n+#include \"tree-cfgcleanup.h\"\n+#include \"tree-ssa-operands.h\"\n+#include \"tree-into-ssa.h\"\n+#include \"internal-fn.h\"\n+#include \"is-a.h\"\n+#include \"gimple-expr.h\"\n+#include \"gimple.h\"\n+#include \"gimple-iterator.h\"\n+#include \"gimple-ssa.h\"\n+#include \"cgraph.h\"\n+#include \"value-prof.h\"\n+#include \"coverage.h\"\n+#include \"params.h\"\n+#include \"ipa-inline.h\"\n+#include \"tree-inline.h\"\n+#include \"stringpool.h\"\n+#include \"auto-profile.h\"\n+#include \"vec.h\"\n+\n+/* The following routines implements AutoFDO optimization.\n+\n+   This optimization uses sampling profiles to annotate basic block counts\n+   and uses heuristics to estimate branch probabilities.\n+\n+   There are three phases in AutoFDO:\n+\n+   Phase 1: Read profile from the profile data file.\n+     The following info is read from the profile datafile:\n+        * string_table: a map between function name and its index.\n+        * autofdo_source_profile: a map from function_instance name to\n+          function_instance. This is represented as a forest of\n+          function_instances.\n+        * WorkingSet: a histogram of how many instructions are covered for a\n+          given percentage of total cycles. This is describing the binary\n+          level information (not source level). This info is used to help\n+          decide if we want aggressive optimizations that could increase\n+          code footprint (e.g. loop unroll etc.)\n+     A function instance is an instance of function that could either be a\n+     standalone symbol, or a clone of a function that is inlined into another\n+     function.\n+\n+   Phase 2: Early inline + valur profile transformation.\n+     Early inline uses autofdo_source_profile to find if a callsite is:\n+        * inlined in the profiled binary.\n+        * callee body is hot in the profiling run.\n+     If both condition satisfies, early inline will inline the callsite\n+     regardless of the code growth.\n+     Phase 2 is an iterative process. During each iteration, we also check\n+     if an indirect callsite is promoted and inlined in the profiling run.\n+     If yes, vpt will happen to force promote it and in the next iteration,\n+     einline will inline the promoted callsite in the next iteration.\n+\n+   Phase 3: Annotate control flow graph.\n+     AutoFDO uses a separate pass to:\n+        * Annotate basic block count\n+        * Estimate branch probability\n+\n+   After the above 3 phases, all profile is readily annotated on the GCC IR.\n+   AutoFDO tries to reuse all FDO infrastructure as much as possible to make\n+   use of the profile. E.g. it uses existing mechanism to calculate the basic\n+   block/edge frequency, as well as the cgraph node/edge count.\n+*/\n+\n+#define DEFAULT_AUTO_PROFILE_FILE \"fbdata.afdo\"\n+#define AUTO_PROFILE_VERSION 1\n+\n+namespace autofdo\n+{\n+\n+/* Represent a source location: (function_decl, lineno).  */\n+typedef std::pair<tree, unsigned> decl_lineno;\n+\n+/* Represent an inline stack. vector[0] is the leaf node.  */\n+typedef auto_vec<decl_lineno> inline_stack;\n+\n+/* String array that stores function names.  */\n+typedef auto_vec<char *> string_vector;\n+\n+/* Map from function name's index in string_table to target's\n+   execution count.  */\n+typedef std::map<unsigned, gcov_type> icall_target_map;\n+\n+/* Set of gimple stmts. Used to track if the stmt has already been promoted\n+   to direct call.  */\n+typedef std::set<gimple> stmt_set;\n+\n+/* Represent count info of an inline stack.  */\n+struct count_info\n+{\n+  /* Sampled count of the inline stack.  */\n+  gcov_type count;\n+\n+  /* Map from indirect call target to its sample count.  */\n+  icall_target_map targets;\n+\n+  /* Whether this inline stack is already used in annotation.\n+\n+     Each inline stack should only be used to annotate IR once.\n+     This will be enforced when instruction-level discriminator\n+     is supported.  */\n+  bool annotated;\n+};\n+\n+/* operator< for \"const char *\".  */\n+struct string_compare\n+{\n+  bool operator()(const char *a, const char *b) const\n+  {\n+    return strcmp (a, b) < 0;\n+  }\n+};\n+\n+/* Store a string array, indexed by string position in the array.  */\n+class string_table\n+{\n+public:\n+  string_table ()\n+  {}\n+\n+  ~string_table ();\n+\n+  /* For a given string, returns its index.  */\n+  int get_index (const char *name) const;\n+\n+  /* For a given decl, returns the index of the decl name.  */\n+  int get_index_by_decl (tree decl) const;\n+\n+  /* For a given index, returns the string.  */\n+  const char *get_name (int index) const;\n+\n+  /* Read profile, return TRUE on success.  */\n+  bool read ();\n+\n+private:\n+  typedef std::map<const char *, unsigned, string_compare> string_index_map;\n+  string_vector vector_;\n+  string_index_map map_;\n+};\n+\n+/* Profile of a function instance:\n+     1. total_count of the function.\n+     2. head_count (entry basic block count) of the function (only valid when\n+        function is a top-level function_instance, i.e. it is the original copy\n+        instead of the inlined copy).\n+     3. map from source location (decl_lineno) to profile (count_info).\n+     4. map from callsite to callee function_instance.  */\n+class function_instance\n+{\n+public:\n+  typedef auto_vec<function_instance *> function_instance_stack;\n+\n+  /* Read the profile and return a function_instance with head count as\n+     HEAD_COUNT. Recursively read callsites to create nested function_instances\n+     too. STACK is used to track the recursive creation process.  */\n+  static function_instance *\n+  read_function_instance (function_instance_stack *stack,\n+                          gcov_type head_count);\n+\n+  /* Recursively deallocate all callsites (nested function_instances).  */\n+  ~function_instance ();\n+\n+  /* Accessors.  */\n+  int\n+  name () const\n+  {\n+    return name_;\n+  }\n+  gcov_type\n+  total_count () const\n+  {\n+    return total_count_;\n+  }\n+  gcov_type\n+  head_count () const\n+  {\n+    return head_count_;\n+  }\n+\n+  /* Traverse callsites of the current function_instance to find one at the\n+     location of LINENO and callee name represented in DECL.  */\n+  function_instance *get_function_instance_by_decl (unsigned lineno,\n+                                                    tree decl) const;\n+\n+  /* Store the profile info for LOC in INFO. Return TRUE if profile info\n+     is found.  */\n+  bool get_count_info (location_t loc, count_info *info) const;\n+\n+  /* Read the inlined indirect call target profile for STMT and store it in\n+     MAP, return the total count for all inlined indirect calls.  */\n+  gcov_type find_icall_target_map (gimple stmt, icall_target_map *map) const;\n+\n+  /* Sum of counts that is used during annotation.  */\n+  gcov_type total_annotated_count () const;\n+\n+  /* Mark LOC as annotated.  */\n+  void mark_annotated (location_t loc);\n+\n+private:\n+  /* Callsite, represented as (decl_lineno, callee_function_name_index).  */\n+  typedef std::pair<unsigned, unsigned> callsite;\n+\n+  /* Map from callsite to callee function_instance.  */\n+  typedef std::map<callsite, function_instance *> callsite_map;\n+\n+  function_instance (unsigned name, gcov_type head_count)\n+      : name_ (name), total_count_ (0), head_count_ (head_count)\n+  {\n+  }\n+\n+  /* Map from source location (decl_lineno) to profile (count_info).  */\n+  typedef std::map<unsigned, count_info> position_count_map;\n+\n+  /* function_instance name index in the string_table.  */\n+  unsigned name_;\n+\n+  /* Total sample count.  */\n+  gcov_type total_count_;\n+\n+  /* Entry BB's sample count.  */\n+  gcov_type head_count_;\n+\n+  /* Map from callsite location to callee function_instance.  */\n+  callsite_map callsites;\n+\n+  /* Map from source location to count_info.  */\n+  position_count_map pos_counts;\n+};\n+\n+/* Profile for all functions.  */\n+class autofdo_source_profile\n+{\n+public:\n+  static autofdo_source_profile *\n+  create ()\n+  {\n+    autofdo_source_profile *map = new autofdo_source_profile ();\n+\n+    if (map->read ())\n+      return map;\n+    delete map;\n+    return NULL;\n+  }\n+\n+  ~autofdo_source_profile ();\n+\n+  /* For a given DECL, returns the top-level function_instance.  */\n+  function_instance *get_function_instance_by_decl (tree decl) const;\n+\n+  /* Find count_info for a given gimple STMT. If found, store the count_info\n+     in INFO and return true; otherwise return false.  */\n+  bool get_count_info (gimple stmt, count_info *info) const;\n+\n+  /* Find total count of the callee of EDGE.  */\n+  gcov_type get_callsite_total_count (struct cgraph_edge *edge) const;\n+\n+  /* Update value profile INFO for STMT from the inlined indirect callsite.\n+     Return true if INFO is updated.  */\n+  bool update_inlined_ind_target (gimple stmt, count_info *info);\n+\n+  /* Mark LOC as annotated.  */\n+  void mark_annotated (location_t loc);\n+\n+private:\n+  /* Map from function_instance name index (in string_table) to\n+     function_instance.  */\n+  typedef std::map<unsigned, function_instance *> name_function_instance_map;\n+\n+  autofdo_source_profile () {}\n+\n+  /* Read AutoFDO profile and returns TRUE on success.  */\n+  bool read ();\n+\n+  /* Return the function_instance in the profile that correspond to the\n+     inline STACK.  */\n+  function_instance *\n+  get_function_instance_by_inline_stack (const inline_stack &stack) const;\n+\n+  name_function_instance_map map_;\n+};\n+\n+/* Store the strings read from the profile data file.  */\n+static string_table *afdo_string_table;\n+\n+/* Store the AutoFDO source profile.  */\n+static autofdo_source_profile *afdo_source_profile;\n+\n+/* gcov_ctr_summary structure to store the profile_info.  */\n+static struct gcov_ctr_summary *afdo_profile_info;\n+\n+/* Helper functions.  */\n+\n+/* Return the original name of NAME: strip the suffix that starts\n+   with '.' Caller is responsible for freeing RET.  */\n+\n+static char *\n+get_original_name (const char *name)\n+{\n+  char *ret = xstrdup (name);\n+  char *find = strchr (ret, '.');\n+  if (find != NULL)\n+    *find = 0;\n+  return ret;\n+}\n+\n+/* Return the combined location, which is a 32bit integer in which\n+   higher 16 bits stores the line offset of LOC to the start lineno\n+   of DECL, The lower 16 bits stores the discrimnator.  */\n+\n+static unsigned\n+get_combined_location (location_t loc, tree decl)\n+{\n+  /* TODO: allow more bits for line and less bits for discriminator.  */\n+  if (LOCATION_LINE (loc) - DECL_SOURCE_LINE (decl) >= (1<<16))\n+    warning_at (loc, OPT_Woverflow, \"Offset exceeds 16 bytes.\");\n+  return ((LOCATION_LINE (loc) - DECL_SOURCE_LINE (decl)) << 16);\n+}\n+\n+/* Return the function decl of a given lexical BLOCK.  */\n+\n+static tree\n+get_function_decl_from_block (tree block)\n+{\n+  tree decl;\n+\n+  if (LOCATION_LOCUS (BLOCK_SOURCE_LOCATION (block) == UNKNOWN_LOCATION))\n+    return NULL_TREE;\n+\n+  for (decl = BLOCK_ABSTRACT_ORIGIN (block);\n+       decl && (TREE_CODE (decl) == BLOCK);\n+       decl = BLOCK_ABSTRACT_ORIGIN (decl))\n+    if (TREE_CODE (decl) == FUNCTION_DECL)\n+      break;\n+  return decl;\n+}\n+\n+/* Store inline stack for STMT in STACK.  */\n+\n+static void\n+get_inline_stack (location_t locus, inline_stack *stack)\n+{\n+  if (LOCATION_LOCUS (locus) == UNKNOWN_LOCATION)\n+    return;\n+\n+  tree block = LOCATION_BLOCK (locus);\n+  if (block && TREE_CODE (block) == BLOCK)\n+    {\n+      int level = 0;\n+      for (block = BLOCK_SUPERCONTEXT (block);\n+           block && (TREE_CODE (block) == BLOCK);\n+           block = BLOCK_SUPERCONTEXT (block))\n+        {\n+          location_t tmp_locus = BLOCK_SOURCE_LOCATION (block);\n+          if (LOCATION_LOCUS (tmp_locus) == UNKNOWN_LOCATION)\n+            continue;\n+\n+          tree decl = get_function_decl_from_block (block);\n+          stack->safe_push (\n+              std::make_pair (decl, get_combined_location (locus, decl)));\n+          locus = tmp_locus;\n+          level++;\n+        }\n+    }\n+  stack->safe_push (\n+      std::make_pair (current_function_decl,\n+                      get_combined_location (locus, current_function_decl)));\n+}\n+\n+/* Return STMT's combined location, which is a 32bit integer in which\n+   higher 16 bits stores the line offset of LOC to the start lineno\n+   of DECL, The lower 16 bits stores the discrimnator.  */\n+\n+static unsigned\n+get_relative_location_for_stmt (gimple stmt)\n+{\n+  location_t locus = gimple_location (stmt);\n+  if (LOCATION_LOCUS (locus) == UNKNOWN_LOCATION)\n+    return UNKNOWN_LOCATION;\n+\n+  for (tree block = gimple_block (stmt); block && (TREE_CODE (block) == BLOCK);\n+       block = BLOCK_SUPERCONTEXT (block))\n+    if (LOCATION_LOCUS (BLOCK_SOURCE_LOCATION (block)) != UNKNOWN_LOCATION)\n+      return get_combined_location (locus,\n+                                    get_function_decl_from_block (block));\n+  return get_combined_location (locus, current_function_decl);\n+}\n+\n+/* Return true if BB contains indirect call.  */\n+\n+static bool\n+has_indirect_call (basic_block bb)\n+{\n+  gimple_stmt_iterator gsi;\n+\n+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gimple stmt = gsi_stmt (gsi);\n+      if (gimple_code (stmt) == GIMPLE_CALL && !gimple_call_internal_p (stmt)\n+          && (gimple_call_fn (stmt) == NULL\n+              || TREE_CODE (gimple_call_fn (stmt)) != FUNCTION_DECL))\n+        return true;\n+    }\n+  return false;\n+}\n+\n+/* Member functions for string_table.  */\n+\n+/* Deconstructor.  */\n+\n+string_table::~string_table ()\n+{\n+  for (unsigned i = 0; i < vector_.length (); i++)\n+    free (vector_[i]);\n+}\n+\n+\n+/* Return the index of a given function NAME. Return -1 if NAME is not\n+   found in string table.  */\n+\n+int\n+string_table::get_index (const char *name) const\n+{\n+  if (name == NULL)\n+    return -1;\n+  string_index_map::const_iterator iter = map_.find (name);\n+  if (iter == map_.end ())\n+    return -1;\n+  else\n+    return iter->second;\n+}\n+\n+/* Return the index of a given function DECL. Return -1 if DECL is not \n+   found in string table.  */\n+\n+int\n+string_table::get_index_by_decl (tree decl) const\n+{\n+  char *name\n+      = get_original_name (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)));\n+  int ret = get_index (name);\n+  free (name);\n+  if (ret != -1)\n+    return ret;\n+  ret = get_index (lang_hooks.dwarf_name (decl, 0));\n+  if (ret != -1)\n+    return ret;\n+  if (DECL_ABSTRACT_ORIGIN (decl))\n+    return get_index_by_decl (DECL_ABSTRACT_ORIGIN (decl));\n+  else\n+    return -1;\n+}\n+\n+/* Return the function name of a given INDEX.  */\n+\n+const char *\n+string_table::get_name (int index) const\n+{\n+  gcc_assert (index > 0 && index < (int)vector_.length ());\n+  return vector_[index];\n+}\n+\n+/* Read the string table. Return TRUE if reading is successful.  */\n+\n+bool\n+string_table::read ()\n+{\n+  if (gcov_read_unsigned () != GCOV_TAG_AFDO_FILE_NAMES)\n+    return false;\n+  /* Skip the length of the section.  */\n+  gcov_read_unsigned ();\n+  /* Read in the file name table.  */\n+  unsigned string_num = gcov_read_unsigned ();\n+  for (unsigned i = 0; i < string_num; i++)\n+    {\n+      vector_.safe_push (get_original_name (gcov_read_string ()));\n+      map_[vector_.last ()] = i;\n+    }\n+  return true;\n+}\n+\n+/* Member functions for function_instance.  */\n+\n+function_instance::~function_instance ()\n+{\n+  for (callsite_map::iterator iter = callsites.begin ();\n+       iter != callsites.end (); ++iter)\n+    delete iter->second;\n+}\n+\n+/* Traverse callsites of the current function_instance to find one at the\n+   location of LINENO and callee name represented in DECL.  */\n+\n+function_instance *\n+function_instance::get_function_instance_by_decl (unsigned lineno,\n+                                                  tree decl) const\n+{\n+  int func_name_idx = afdo_string_table->get_index_by_decl (decl);\n+  if (func_name_idx != -1)\n+    {\n+      callsite_map::const_iterator ret\n+          = callsites.find (std::make_pair (lineno, func_name_idx));\n+      if (ret != callsites.end ())\n+        return ret->second;\n+    }\n+  func_name_idx\n+      = afdo_string_table->get_index (lang_hooks.dwarf_name (decl, 0));\n+  if (func_name_idx != -1)\n+    {\n+      callsite_map::const_iterator ret\n+          = callsites.find (std::make_pair (lineno, func_name_idx));\n+      if (ret != callsites.end ())\n+        return ret->second;\n+    }\n+  if (DECL_ABSTRACT_ORIGIN (decl))\n+    return get_function_instance_by_decl (lineno, DECL_ABSTRACT_ORIGIN (decl));\n+  else\n+    return NULL;\n+}\n+\n+/* Store the profile info for LOC in INFO. Return TRUE if profile info\n+   is found.  */\n+\n+bool\n+function_instance::get_count_info (location_t loc, count_info *info) const\n+{\n+  position_count_map::const_iterator iter = pos_counts.find (loc);\n+  if (iter == pos_counts.end ())\n+    return false;\n+  *info = iter->second;\n+  return true;\n+}\n+\n+/* Mark LOC as annotated.  */\n+\n+void\n+function_instance::mark_annotated (location_t loc)\n+{\n+  position_count_map::iterator iter = pos_counts.find (loc);\n+  if (iter == pos_counts.end ())\n+    return;\n+  iter->second.annotated = true;\n+}\n+\n+/* Read the inlinied indirect call target profile for STMT and store it in\n+   MAP, return the total count for all inlined indirect calls.  */\n+\n+gcov_type\n+function_instance::find_icall_target_map (gimple stmt,\n+                                          icall_target_map *map) const\n+{\n+  gcov_type ret = 0;\n+  unsigned stmt_offset = get_relative_location_for_stmt (stmt);\n+\n+  for (callsite_map::const_iterator iter = callsites.begin ();\n+       iter != callsites.end (); ++iter)\n+    {\n+      unsigned callee = iter->second->name ();\n+      /* Check if callsite location match the stmt.  */\n+      if (iter->first.first != stmt_offset)\n+        continue;\n+      struct cgraph_node *node = cgraph_node::get_for_asmname (\n+          get_identifier (afdo_string_table->get_name (callee)));\n+      if (node == NULL)\n+        continue;\n+      if (!check_ic_target (stmt, node))\n+        continue;\n+      (*map)[callee] = iter->second->total_count ();\n+      ret += iter->second->total_count ();\n+    }\n+  return ret;\n+}\n+\n+/* Read the profile and create a function_instance with head count as\n+   HEAD_COUNT. Recursively read callsites to create nested function_instances\n+   too. STACK is used to track the recursive creation process.  */\n+\n+/* function instance profile format:\n+\n+   ENTRY_COUNT: 8 bytes\n+   NAME_INDEX: 4 bytes\n+   NUM_POS_COUNTS: 4 bytes\n+   NUM_CALLSITES: 4 byte\n+   POS_COUNT_1:\n+     POS_1_OFFSET: 4 bytes\n+     NUM_TARGETS: 4 bytes\n+     COUNT: 8 bytes\n+     TARGET_1:\n+       VALUE_PROFILE_TYPE: 4 bytes\n+       TARGET_IDX: 8 bytes\n+       COUNT: 8 bytes\n+     TARGET_2\n+     ...\n+     TARGET_n\n+   POS_COUNT_2\n+   ...\n+   POS_COUNT_N\n+   CALLSITE_1:\n+     CALLSITE_1_OFFSET: 4 bytes\n+     FUNCTION_INSTANCE_PROFILE (nested)\n+   CALLSITE_2\n+   ...\n+   CALLSITE_n.  */\n+\n+function_instance *\n+function_instance::read_function_instance (function_instance_stack *stack,\n+                                           gcov_type head_count)\n+{\n+  unsigned name = gcov_read_unsigned ();\n+  unsigned num_pos_counts = gcov_read_unsigned ();\n+  unsigned num_callsites = gcov_read_unsigned ();\n+  function_instance *s = new function_instance (name, head_count);\n+  stack->safe_push (s);\n+\n+  for (unsigned i = 0; i < num_pos_counts; i++)\n+    {\n+      unsigned offset = gcov_read_unsigned () & 0xffff0000;\n+      unsigned num_targets = gcov_read_unsigned ();\n+      gcov_type count = gcov_read_counter ();\n+      s->pos_counts[offset].count = count;\n+      for (unsigned j = 0; j < stack->length (); j++)\n+        (*stack)[j]->total_count_ += count;\n+      for (unsigned j = 0; j < num_targets; j++)\n+        {\n+          /* Only indirect call target histogram is supported now.  */\n+          gcov_read_unsigned ();\n+          gcov_type target_idx = gcov_read_counter ();\n+          s->pos_counts[offset].targets[target_idx] = gcov_read_counter ();\n+        }\n+    }\n+  for (unsigned i = 0; i < num_callsites; i++)\n+    {\n+      unsigned offset = gcov_read_unsigned ();\n+      function_instance *callee_function_instance\n+          = read_function_instance (stack, 0);\n+      s->callsites[std::make_pair (offset, callee_function_instance->name ())]\n+          = callee_function_instance;\n+    }\n+  stack->pop ();\n+  return s;\n+}\n+\n+/* Sum of counts that is used during annotation.  */\n+\n+gcov_type\n+function_instance::total_annotated_count () const\n+{\n+  gcov_type ret = 0;\n+  for (callsite_map::const_iterator iter = callsites.begin ();\n+       iter != callsites.end (); ++iter)\n+    ret += iter->second->total_annotated_count ();\n+  for (position_count_map::const_iterator iter = pos_counts.begin ();\n+       iter != pos_counts.end (); ++iter)\n+    if (iter->second.annotated)\n+      ret += iter->second.count;\n+  return ret;\n+}\n+\n+/* Member functions for autofdo_source_profile.  */\n+\n+autofdo_source_profile::~autofdo_source_profile ()\n+{\n+  for (name_function_instance_map::const_iterator iter = map_.begin ();\n+       iter != map_.end (); ++iter)\n+    delete iter->second;\n+}\n+\n+/* For a given DECL, returns the top-level function_instance.  */\n+\n+function_instance *\n+autofdo_source_profile::get_function_instance_by_decl (tree decl) const\n+{\n+  int index = afdo_string_table->get_index_by_decl (decl);\n+  if (index == -1)\n+    return NULL;\n+  name_function_instance_map::const_iterator ret = map_.find (index);\n+  return ret == map_.end () ? NULL : ret->second;\n+}\n+\n+/* Find count_info for a given gimple STMT. If found, store the count_info\n+   in INFO and return true; otherwise return false.  */\n+\n+bool\n+autofdo_source_profile::get_count_info (gimple stmt, count_info *info) const\n+{\n+  if (LOCATION_LOCUS (gimple_location (stmt)) == cfun->function_end_locus)\n+    return false;\n+\n+  inline_stack stack;\n+  get_inline_stack (gimple_location (stmt), &stack);\n+  if (stack.length () == 0)\n+    return false;\n+  function_instance *s = get_function_instance_by_inline_stack (stack);\n+  if (s == NULL)\n+    return false;\n+  return s->get_count_info (stack[0].second, info);\n+}\n+\n+/* Mark LOC as annotated.  */\n+\n+void\n+autofdo_source_profile::mark_annotated (location_t loc)\n+{\n+  inline_stack stack;\n+  get_inline_stack (loc, &stack);\n+  if (stack.length () == 0)\n+    return;\n+  function_instance *s = get_function_instance_by_inline_stack (stack);\n+  if (s == NULL)\n+    return;\n+  s->mark_annotated (stack[0].second);\n+}\n+\n+/* Update value profile INFO for STMT from the inlined indirect callsite.\n+   Return true if INFO is updated.  */\n+\n+bool\n+autofdo_source_profile::update_inlined_ind_target (gimple stmt,\n+                                                   count_info *info)\n+{\n+  if (LOCATION_LOCUS (gimple_location (stmt)) == cfun->function_end_locus)\n+    return false;\n+\n+  count_info old_info;\n+  get_count_info (stmt, &old_info);\n+  gcov_type total = 0;\n+  for (icall_target_map::const_iterator iter = old_info.targets.begin ();\n+       iter != old_info.targets.end (); ++iter)\n+    total += iter->second;\n+\n+  /* Program behavior changed, original promoted (and inlined) target is not\n+     hot any more. Will avoid promote the original target.\n+\n+     To check if original promoted target is still hot, we check the total\n+     count of the unpromoted targets (stored in old_info). If it is no less\n+     than half of the callsite count (stored in INFO), the original promoted\n+     target is considered not hot any more.  */\n+  if (total >= info->count / 2)\n+    return false;\n+\n+  inline_stack stack;\n+  get_inline_stack (gimple_location (stmt), &stack);\n+  if (stack.length () == 0)\n+    return false;\n+  function_instance *s = get_function_instance_by_inline_stack (stack);\n+  if (s == NULL)\n+    return false;\n+  icall_target_map map;\n+  if (s->find_icall_target_map (stmt, &map) == 0)\n+    return false;\n+  for (icall_target_map::const_iterator iter = map.begin ();\n+       iter != map.end (); ++iter)\n+    info->targets[iter->first] = iter->second;\n+  return true;\n+}\n+\n+/* Find total count of the callee of EDGE.  */\n+\n+gcov_type\n+autofdo_source_profile::get_callsite_total_count (\n+    struct cgraph_edge *edge) const\n+{\n+  inline_stack stack;\n+  stack.safe_push (std::make_pair (edge->callee->decl, 0));\n+  get_inline_stack (gimple_location (edge->call_stmt), &stack);\n+\n+  function_instance *s = get_function_instance_by_inline_stack (stack);\n+  if (s == NULL\n+      || afdo_string_table->get_index (IDENTIFIER_POINTER (\n+             DECL_ASSEMBLER_NAME (edge->callee->decl))) != s->name ())\n+    return 0;\n+  else\n+    return s->total_count ();\n+}\n+\n+/* Read AutoFDO profile and returns TRUE on success.  */\n+\n+/* source profile format:\n+\n+   GCOV_TAG_AFDO_FUNCTION: 4 bytes\n+   LENGTH: 4 bytes\n+   NUM_FUNCTIONS: 4 bytes\n+   FUNCTION_INSTANCE_1\n+   FUNCTION_INSTANCE_2\n+   ...\n+   FUNCTION_INSTANCE_N.  */\n+\n+bool\n+autofdo_source_profile::read ()\n+{\n+  if (gcov_read_unsigned () != GCOV_TAG_AFDO_FUNCTION)\n+    {\n+      inform (0, \"Not expected TAG.\");\n+      return false;\n+    }\n+\n+  /* Skip the length of the section.  */\n+  gcov_read_unsigned ();\n+\n+  /* Read in the function/callsite profile, and store it in local\n+     data structure.  */\n+  unsigned function_num = gcov_read_unsigned ();\n+  for (unsigned i = 0; i < function_num; i++)\n+    {\n+      function_instance::function_instance_stack stack;\n+      function_instance *s = function_instance::read_function_instance (\n+          &stack, gcov_read_counter ());\n+      afdo_profile_info->sum_all += s->total_count ();\n+      map_[s->name ()] = s;\n+    }\n+  return true;\n+}\n+\n+/* Return the function_instance in the profile that correspond to the\n+   inline STACK.  */\n+\n+function_instance *\n+autofdo_source_profile::get_function_instance_by_inline_stack (\n+    const inline_stack &stack) const\n+{\n+  name_function_instance_map::const_iterator iter = map_.find (\n+      afdo_string_table->get_index_by_decl (stack[stack.length () - 1].first));\n+  if (iter == map_.end())\n+    return NULL;\n+  function_instance *s = iter->second;\n+  for (unsigned i = stack.length() - 1; i > 0; i--)\n+    {\n+      s = s->get_function_instance_by_decl (\n+          stack[i].second, stack[i - 1].first);\n+      if (s == NULL)\n+        return NULL;\n+    }\n+  return s;\n+}\n+\n+/* Module profile is only used by LIPO. Here we simply ignore it.  */\n+\n+static void\n+fake_read_autofdo_module_profile ()\n+{\n+  /* Read in the module info.  */\n+  gcov_read_unsigned ();\n+\n+  /* Skip the length of the section.  */\n+  gcov_read_unsigned ();\n+\n+  /* Read in the file name table.  */\n+  unsigned total_module_num = gcov_read_unsigned ();\n+  gcc_assert (total_module_num == 0);\n+}\n+\n+/* Read data from profile data file.  */\n+\n+static void\n+read_profile (void)\n+{\n+  if (gcov_open (auto_profile_file, 1) == 0)\n+    error (\"Cannot open profile file %s.\", auto_profile_file);\n+\n+  if (gcov_read_unsigned () != GCOV_DATA_MAGIC)\n+    error (\"AutoFDO profile magic number does not mathch.\");\n+\n+  /* Skip the version number.  */\n+  unsigned version = gcov_read_unsigned ();\n+  if (version != AUTO_PROFILE_VERSION)\n+    error (\"AutoFDO profile version %u does match %u.\",\n+           version, AUTO_PROFILE_VERSION);\n+\n+  /* Skip the empty integer.  */\n+  gcov_read_unsigned ();\n+\n+  /* string_table.  */\n+  afdo_string_table = new string_table ();\n+  if (!afdo_string_table->read())\n+    error (\"Cannot read string table from %s.\", auto_profile_file);\n+\n+  /* autofdo_source_profile.  */\n+  afdo_source_profile = autofdo_source_profile::create ();\n+  if (afdo_source_profile == NULL)\n+    error (\"Cannot read function profile from %s.\", auto_profile_file);\n+\n+  /* autofdo_module_profile.  */\n+  fake_read_autofdo_module_profile ();\n+\n+  /* Read in the working set.  */\n+  if (gcov_read_unsigned () != GCOV_TAG_AFDO_WORKING_SET)\n+    error (\"Cannot read working set from %s.\", auto_profile_file);\n+\n+  /* Skip the length of the section.  */\n+  gcov_read_unsigned ();\n+  gcov_working_set_t set[128];\n+  for (unsigned i = 0; i < 128; i++)\n+    {\n+      set[i].num_counters = gcov_read_unsigned ();\n+      set[i].min_counter = gcov_read_counter ();\n+    }\n+  add_working_set (set);\n+}\n+\n+/* From AutoFDO profiles, find values inside STMT for that we want to measure\n+   histograms for indirect-call optimization.\n+\n+   This function is actually served for 2 purposes:\n+ \u00a0 \u00a0 * before annotation, we need to mark histogram, promote and inline\n+ \u00a0 \u00a0 * after annotation, we just need to mark, and let follow-up logic to\n+ \u00a0 \u00a0 \u00a0 decide if it needs to promote and inline.  */\n+\n+static void\n+afdo_indirect_call (gimple_stmt_iterator *gsi, const icall_target_map &map,\n+                    bool transform)\n+{\n+  gimple stmt = gsi_stmt (*gsi);\n+  tree callee;\n+\n+  if (map.size () == 0 || gimple_code (stmt) != GIMPLE_CALL\n+      || gimple_call_fndecl (stmt) != NULL_TREE)\n+    return;\n+\n+  callee = gimple_call_fn (stmt);\n+\n+  histogram_value hist = gimple_alloc_histogram_value (\n+      cfun, HIST_TYPE_INDIR_CALL, stmt, callee);\n+  hist->n_counters = 3;\n+  hist->hvalue.counters = XNEWVEC (gcov_type, hist->n_counters);\n+  gimple_add_histogram_value (cfun, stmt, hist);\n+\n+  gcov_type total = 0;\n+  icall_target_map::const_iterator max_iter = map.end ();\n+\n+  for (icall_target_map::const_iterator iter = map.begin ();\n+       iter != map.end (); ++iter)\n+    {\n+      total += iter->second;\n+      if (max_iter == map.end () || max_iter->second < iter->second)\n+        max_iter = iter;\n+    }\n+\n+  hist->hvalue.counters[0]\n+      = (unsigned long long)afdo_string_table->get_name (max_iter->first);\n+  hist->hvalue.counters[1] = max_iter->second;\n+  hist->hvalue.counters[2] = total;\n+\n+  if (!transform)\n+    return;\n+\n+  struct cgraph_edge *indirect_edge\n+      = cgraph_node::get (current_function_decl)->get_edge (stmt);\n+  struct cgraph_node *direct_call = cgraph_node::get_for_asmname (\n+      get_identifier ((const char *) hist->hvalue.counters[0]));\n+\n+  if (direct_call == NULL || !check_ic_target (stmt, direct_call))\n+    return;\n+  if (DECL_STRUCT_FUNCTION (direct_call->decl) == NULL)\n+    return;\n+  struct cgraph_edge *new_edge\n+      = indirect_edge->make_speculative (direct_call, 0, 0);\n+  new_edge->redirect_call_stmt_to_callee ();\n+  gimple_remove_histogram_value (cfun, stmt, hist);\n+  inline_call (new_edge, true, NULL, NULL, false);\n+}\n+\n+/* From AutoFDO profiles, find values inside STMT for that we want to measure\n+   histograms and adds them to list VALUES.  */\n+\n+static void\n+afdo_vpt (gimple_stmt_iterator *gsi, const icall_target_map &map,\n+          bool transform)\n+{\n+  afdo_indirect_call (gsi, map, transform);\n+}\n+\n+typedef std::set<basic_block> bb_set;\n+typedef std::set<edge> edge_set;\n+\n+static bool\n+is_bb_annotated (const basic_block bb, const bb_set &annotated)\n+{\n+  return annotated.find (bb) != annotated.end ();\n+}\n+\n+static void\n+set_bb_annotated (basic_block bb, bb_set *annotated)\n+{\n+  annotated->insert (bb);\n+}\n+\n+static bool\n+is_edge_annotated (const edge e, const edge_set &annotated)\n+{\n+  return annotated.find (e) != annotated.end ();\n+}\n+\n+static void\n+set_edge_annotated (edge e, edge_set *annotated)\n+{\n+  annotated->insert (e);\n+}\n+\n+/* For a given BB, set its execution count. Attach value profile if a stmt\n+   is not in PROMOTED, because we only want to promot an indirect call once.\n+   Return TRUE if BB is annotated.  */\n+\n+static bool\n+afdo_set_bb_count (basic_block bb, const stmt_set &promoted)\n+{\n+  gimple_stmt_iterator gsi;\n+  edge e;\n+  edge_iterator ei;\n+  gcov_type max_count = 0;\n+  bool has_annotated = false;\n+\n+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      count_info info;\n+      gimple stmt = gsi_stmt (gsi);\n+      if (gimple_clobber_p (stmt) || is_gimple_debug (stmt))\n+        continue;\n+      if (afdo_source_profile->get_count_info (stmt, &info))\n+        {\n+          if (info.count > max_count)\n+            max_count = info.count;\n+          has_annotated = true;\n+          if (info.targets.size () > 0\n+              && promoted.find (stmt) == promoted.end ())\n+            afdo_vpt (&gsi, info.targets, false);\n+        }\n+    }\n+\n+  if (!has_annotated)\n+    return false;\n+\n+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    afdo_source_profile->mark_annotated (gimple_location (gsi_stmt (gsi)));\n+  for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gimple phi = gsi_stmt (gsi);\n+      size_t i;\n+      for (i = 0; i < gimple_phi_num_args (phi); i++)\n+        afdo_source_profile->mark_annotated (gimple_phi_arg_location (phi, i));\n+    }\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+  afdo_source_profile->mark_annotated (e->goto_locus);\n+\n+  bb->count = max_count;\n+  return true;\n+}\n+\n+/* BB1 and BB2 are in an equivalent class iff:\n+   1. BB1 dominates BB2.\n+   2. BB2 post-dominates BB1.\n+   3. BB1 and BB2 are in the same loop nest.\n+   This function finds the equivalent class for each basic block, and\n+   stores a pointer to the first BB in its equivalent class. Meanwhile,\n+   set bb counts for the same equivalent class to be idenical. Update\n+   ANNOTATED_BB for the first BB in its equivalent class.  */\n+\n+static void\n+afdo_find_equiv_class (bb_set *annotated_bb)\n+{\n+  basic_block bb;\n+\n+  FOR_ALL_BB_FN (bb, cfun)\n+  bb->aux = NULL;\n+\n+  FOR_ALL_BB_FN (bb, cfun)\n+  {\n+    vec<basic_block> dom_bbs;\n+    basic_block bb1;\n+    int i;\n+\n+    if (bb->aux != NULL)\n+      continue;\n+    bb->aux = bb;\n+    dom_bbs = get_dominated_by (CDI_DOMINATORS, bb);\n+    FOR_EACH_VEC_ELT (dom_bbs, i, bb1)\n+    if (bb1->aux == NULL && dominated_by_p (CDI_POST_DOMINATORS, bb, bb1)\n+        && bb1->loop_father == bb->loop_father)\n+      {\n+        bb1->aux = bb;\n+        if (bb1->count > bb->count && is_bb_annotated (bb1, *annotated_bb))\n+          {\n+            bb->count = MAX (bb->count, bb1->count);\n+            set_bb_annotated (bb, annotated_bb);\n+          }\n+      }\n+    dom_bbs = get_dominated_by (CDI_POST_DOMINATORS, bb);\n+    FOR_EACH_VEC_ELT (dom_bbs, i, bb1)\n+    if (bb1->aux == NULL && dominated_by_p (CDI_DOMINATORS, bb, bb1)\n+        && bb1->loop_father == bb->loop_father)\n+      {\n+        bb1->aux = bb;\n+        if (bb1->count > bb->count && is_bb_annotated (bb1, *annotated_bb))\n+          {\n+            bb->count = MAX (bb->count, bb1->count);\n+            set_bb_annotated (bb, annotated_bb);\n+          }\n+      }\n+  }\n+}\n+\n+/* If a basic block's count is known, and only one of its in/out edges' count\n+   is unknown, its count can be calculated. Meanwhile, if all of the in/out\n+   edges' counts are known, then the basic block's unknown count can also be\n+   calculated.\n+   IS_SUCC is true if out edges of a basic blocks are examined.\n+   Update ANNOTATED_BB and ANNOTATED_EDGE accordingly.\n+   Return TRUE if any basic block/edge count is changed.  */\n+\n+static bool\n+afdo_propagate_edge (bool is_succ, bb_set *annotated_bb,\n+                     edge_set *annotated_edge)\n+{\n+  basic_block bb;\n+  bool changed = false;\n+\n+  FOR_EACH_BB_FN (bb, cfun)\n+  {\n+    edge e, unknown_edge = NULL;\n+    edge_iterator ei;\n+    int num_unknown_edge = 0;\n+    gcov_type total_known_count = 0;\n+\n+    FOR_EACH_EDGE (e, ei, is_succ ? bb->succs : bb->preds)\n+    if (!is_edge_annotated (e, *annotated_edge))\n+      num_unknown_edge++, unknown_edge = e;\n+    else\n+      total_known_count += e->count;\n+\n+    if (num_unknown_edge == 0)\n+      {\n+        if (total_known_count > bb->count)\n+          {\n+            bb->count = total_known_count;\n+            changed = true;\n+          }\n+        if (!is_bb_annotated (bb, *annotated_bb))\n+          {\n+            set_bb_annotated (bb, annotated_bb);\n+            changed = true;\n+          }\n+      }\n+    else if (num_unknown_edge == 1 && is_bb_annotated (bb, *annotated_bb))\n+      {\n+        if (bb->count >= total_known_count)\n+          unknown_edge->count = bb->count - total_known_count;\n+        else\n+          unknown_edge->count = 0;\n+        set_edge_annotated (unknown_edge, annotated_edge);\n+        changed = true;\n+      }\n+  }\n+  return changed;\n+}\n+\n+/* Special propagation for circuit expressions. Because GCC translates\n+   control flow into data flow for circuit expressions. E.g.\n+   BB1:\n+   if (a && b)\n+     BB2\n+   else\n+     BB3\n+\n+   will be translated into:\n+\n+   BB1:\n+     if (a)\n+       goto BB.t1\n+     else\n+       goto BB.t3\n+   BB.t1:\n+     if (b)\n+       goto BB.t2\n+     else\n+       goto BB.t3\n+   BB.t2:\n+     goto BB.t3\n+   BB.t3:\n+     tmp = PHI (0 (BB1), 0 (BB.t1), 1 (BB.t2)\n+     if (tmp)\n+       goto BB2\n+     else\n+       goto BB3\n+\n+   In this case, we need to propagate through PHI to determine the edge\n+   count of BB1->BB.t1, BB.t1->BB.t2.\n+   Update ANNOTATED_EDGE accordingly.  */\n+\n+static void\n+afdo_propagate_circuit (const bb_set &annotated_bb, edge_set *annotated_edge)\n+{\n+  basic_block bb;\n+  FOR_ALL_BB_FN (bb, cfun)\n+  {\n+    gimple phi_stmt;\n+    tree cmp_rhs, cmp_lhs;\n+    gimple cmp_stmt = last_stmt (bb);\n+    edge e;\n+    edge_iterator ei;\n+\n+    if (!cmp_stmt || gimple_code (cmp_stmt) != GIMPLE_COND)\n+      continue;\n+    cmp_rhs = gimple_cond_rhs (cmp_stmt);\n+    cmp_lhs = gimple_cond_lhs (cmp_stmt);\n+    if (!TREE_CONSTANT (cmp_rhs)\n+        || !(integer_zerop (cmp_rhs) || integer_onep (cmp_rhs)))\n+      continue;\n+    if (TREE_CODE (cmp_lhs) != SSA_NAME)\n+      continue;\n+    if (!is_bb_annotated (bb, annotated_bb))\n+      continue;\n+    phi_stmt = SSA_NAME_DEF_STMT (cmp_lhs);\n+    while (phi_stmt && gimple_code (phi_stmt) == GIMPLE_ASSIGN\n+           && gimple_assign_single_p (phi_stmt)\n+           && TREE_CODE (gimple_assign_rhs1 (phi_stmt)) == SSA_NAME)\n+      phi_stmt = SSA_NAME_DEF_STMT (gimple_assign_rhs1 (phi_stmt));\n+    if (!phi_stmt || gimple_code (phi_stmt) != GIMPLE_PHI)\n+      continue;\n+    FOR_EACH_EDGE (e, ei, bb->succs)\n+    {\n+      unsigned i, total = 0;\n+      edge only_one;\n+      bool check_value_one = (((integer_onep (cmp_rhs))\n+                               ^ (gimple_cond_code (cmp_stmt) == EQ_EXPR))\n+                              ^ ((e->flags & EDGE_TRUE_VALUE) != 0));\n+      if (!is_edge_annotated (e, *annotated_edge))\n+        continue;\n+      for (i = 0; i < gimple_phi_num_args (phi_stmt); i++)\n+        {\n+          tree val = gimple_phi_arg_def (phi_stmt, i);\n+          edge ep = gimple_phi_arg_edge (phi_stmt, i);\n+\n+          if (!TREE_CONSTANT (val)\n+              || !(integer_zerop (val) || integer_onep (val)))\n+            continue;\n+          if (check_value_one ^ integer_onep (val))\n+            continue;\n+          total++;\n+          only_one = ep;\n+          if (e->probability == 0 && !is_edge_annotated (ep, *annotated_edge))\n+            {\n+              ep->probability = 0;\n+              ep->count = 0;\n+              set_edge_annotated (ep, annotated_edge);\n+            }\n+        }\n+      if (total == 1 && !is_edge_annotated (only_one, *annotated_edge))\n+        {\n+          only_one->probability = e->probability;\n+          only_one->count = e->count;\n+          set_edge_annotated (only_one, annotated_edge);\n+        }\n+    }\n+  }\n+}\n+\n+/* Propagate the basic block count and edge count on the control flow\n+   graph. We do the propagation iteratively until stablize.  */\n+\n+static void\n+afdo_propagate (bb_set *annotated_bb, edge_set *annotated_edge)\n+{\n+  basic_block bb;\n+  bool changed = true;\n+  int i = 0;\n+\n+  FOR_ALL_BB_FN (bb, cfun)\n+  {\n+    bb->count = ((basic_block)bb->aux)->count;\n+    if (is_bb_annotated ((const basic_block)bb->aux, *annotated_bb))\n+      set_bb_annotated (bb, annotated_bb);\n+  }\n+\n+  while (changed && i++ < 10)\n+    {\n+      changed = false;\n+\n+      if (afdo_propagate_edge (true, annotated_bb, annotated_edge))\n+        changed = true;\n+      if (afdo_propagate_edge (false, annotated_bb, annotated_edge))\n+        changed = true;\n+      afdo_propagate_circuit (*annotated_bb, annotated_edge);\n+    }\n+}\n+\n+/* Propagate counts on control flow graph and calculate branch\n+   probabilities.  */\n+\n+static void\n+afdo_calculate_branch_prob (bb_set *annotated_bb, edge_set *annotated_edge)\n+{\n+  basic_block bb;\n+  bool has_sample = false;\n+\n+  FOR_EACH_BB_FN (bb, cfun)\n+  if (bb->count > 0)\n+    has_sample = true;\n+\n+  if (!has_sample)\n+    return;\n+\n+  calculate_dominance_info (CDI_POST_DOMINATORS);\n+  calculate_dominance_info (CDI_DOMINATORS);\n+  loop_optimizer_init (0);\n+\n+  afdo_find_equiv_class (annotated_bb);\n+  afdo_propagate (annotated_bb, annotated_edge);\n+\n+  FOR_EACH_BB_FN (bb, cfun)\n+  {\n+    edge e;\n+    edge_iterator ei;\n+    int num_unknown_succ = 0;\n+    gcov_type total_count = 0;\n+\n+    FOR_EACH_EDGE (e, ei, bb->succs)\n+    {\n+      if (!is_edge_annotated (e, *annotated_edge))\n+        num_unknown_succ++;\n+      else\n+        total_count += e->count;\n+    }\n+    if (num_unknown_succ == 0 && total_count > 0)\n+      {\n+        FOR_EACH_EDGE (e, ei, bb->succs)\n+        e->probability = (double)e->count * REG_BR_PROB_BASE / total_count;\n+      }\n+  }\n+  FOR_ALL_BB_FN (bb, cfun)\n+  {\n+    edge e;\n+    edge_iterator ei;\n+\n+    FOR_EACH_EDGE (e, ei, bb->succs)\n+    e->count = (double)bb->count * e->probability / REG_BR_PROB_BASE;\n+    bb->aux = NULL;\n+  }\n+\n+  loop_optimizer_finalize ();\n+  free_dominance_info (CDI_DOMINATORS);\n+  free_dominance_info (CDI_POST_DOMINATORS);\n+}\n+\n+/* Perform value profile transformation using AutoFDO profile. Add the\n+   promoted stmts to PROMOTED_STMTS. Return TRUE if there is any\n+   indirect call promoted.  */\n+\n+static bool\n+afdo_vpt_for_early_inline (stmt_set *promoted_stmts)\n+{\n+  basic_block bb;\n+  if (afdo_source_profile->get_function_instance_by_decl (\n+          current_function_decl) == NULL)\n+    return false;\n+\n+  compute_inline_parameters (cgraph_node::get (current_function_decl), true);\n+\n+  bool has_vpt = false;\n+  FOR_EACH_BB_FN (bb, cfun)\n+  {\n+    if (!has_indirect_call (bb))\n+      continue;\n+    gimple_stmt_iterator gsi;\n+\n+    gcov_type bb_count = 0;\n+    for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+      {\n+        count_info info;\n+        gimple stmt = gsi_stmt (gsi);\n+        if (afdo_source_profile->get_count_info (stmt, &info))\n+          bb_count = MAX (bb_count, info.count);\n+      }\n+\n+    for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+      {\n+        gimple stmt = gsi_stmt (gsi);\n+        /* IC_promotion and early_inline_2 is done in multiple iterations.\n+           No need to promoted the stmt if its in promoted_stmts (means\n+           it is already been promoted in the previous iterations).  */\n+        if (gimple_code (stmt) != GIMPLE_CALL || gimple_call_fn (stmt) == NULL\n+            || TREE_CODE (gimple_call_fn (stmt)) == FUNCTION_DECL\n+            || promoted_stmts->find (stmt) != promoted_stmts->end ())\n+          continue;\n+\n+        count_info info;\n+        afdo_source_profile->get_count_info (stmt, &info);\n+        info.count = bb_count;\n+        if (afdo_source_profile->update_inlined_ind_target (stmt, &info))\n+          {\n+            /* Promote the indirect call and update the promoted_stmts.  */\n+            promoted_stmts->insert (stmt);\n+            afdo_vpt (&gsi, info.targets, true);\n+            has_vpt = true;\n+          }\n+      }\n+  }\n+  if (has_vpt)\n+    {\n+      optimize_inline_calls (current_function_decl);\n+      return true;\n+    }\n+  else\n+    return false;\n+}\n+\n+/* Annotate auto profile to the control flow graph. Do not annotate value\n+   profile for stmts in PROMOTED_STMTS.  */\n+\n+static void\n+afdo_annotate_cfg (const stmt_set &promoted_stmts)\n+{\n+  basic_block bb;\n+  bb_set annotated_bb;\n+  edge_set annotated_edge;\n+  const function_instance *s\n+      = afdo_source_profile->get_function_instance_by_decl (\n+          current_function_decl);\n+\n+  if (s == NULL)\n+    return;\n+  cgraph_node::get (current_function_decl)->count = s->head_count ();\n+  ENTRY_BLOCK_PTR_FOR_FN (cfun)->count = s->head_count ();\n+  gcov_type max_count = ENTRY_BLOCK_PTR_FOR_FN (cfun)->count;\n+\n+  FOR_EACH_BB_FN (bb, cfun)\n+  {\n+    edge e;\n+    edge_iterator ei;\n+\n+    bb->count = 0;\n+    FOR_EACH_EDGE (e, ei, bb->succs)\n+    e->count = 0;\n+\n+    if (afdo_set_bb_count (bb, promoted_stmts))\n+      set_bb_annotated (bb, &annotated_bb);\n+    if (bb->count > max_count)\n+      max_count = bb->count;\n+  }\n+  if (ENTRY_BLOCK_PTR_FOR_FN (cfun)->count\n+      > ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb->count)\n+    {\n+      ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb->count\n+          = ENTRY_BLOCK_PTR_FOR_FN (cfun)->count;\n+      set_bb_annotated (ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb, &annotated_bb);\n+    }\n+  if (ENTRY_BLOCK_PTR_FOR_FN (cfun)->count\n+      > EXIT_BLOCK_PTR_FOR_FN (cfun)->prev_bb->count)\n+    {\n+      EXIT_BLOCK_PTR_FOR_FN (cfun)->prev_bb->count\n+          = ENTRY_BLOCK_PTR_FOR_FN (cfun)->count;\n+      set_bb_annotated (EXIT_BLOCK_PTR_FOR_FN (cfun)->prev_bb, &annotated_bb);\n+    }\n+  afdo_source_profile->mark_annotated (\n+      DECL_SOURCE_LOCATION (current_function_decl));\n+  afdo_source_profile->mark_annotated (cfun->function_start_locus);\n+  afdo_source_profile->mark_annotated (cfun->function_end_locus);\n+  if (max_count > 0)\n+    {\n+      afdo_calculate_branch_prob (&annotated_bb, &annotated_edge);\n+      counts_to_freqs ();\n+      profile_status_for_fn (cfun) = PROFILE_READ;\n+    }\n+  if (flag_value_profile_transformations)\n+    gimple_value_profile_transformations ();\n+}\n+\n+/* Wrapper function to invoke early inliner.  */\n+\n+static void\n+early_inline ()\n+{\n+  compute_inline_parameters (cgraph_node::get (current_function_decl), true);\n+  unsigned todo = early_inliner (cfun);\n+  if (todo & TODO_update_ssa_any)\n+    update_ssa (TODO_update_ssa);\n+}\n+\n+/* Use AutoFDO profile to annoate the control flow graph.\n+   Return the todo flag.  */\n+\n+static unsigned int\n+auto_profile (void)\n+{\n+  struct cgraph_node *node;\n+\n+  if (symtab->state == FINISHED)\n+    return 0;\n+\n+  init_node_map (true);\n+  profile_info = autofdo::afdo_profile_info;\n+\n+  FOR_EACH_FUNCTION (node)\n+  {\n+    if (!gimple_has_body_p (node->decl))\n+      continue;\n+\n+    /* Don't profile functions produced for builtin stuff.  */\n+    if (DECL_SOURCE_LOCATION (node->decl) == BUILTINS_LOCATION)\n+      continue;\n+\n+    push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n+\n+    /* First do indirect call promotion and early inline to make the\n+       IR match the profiled binary before actual annotation.\n+\n+       This is needed because an indirect call might have been promoted\n+       and inlined in the profiled binary. If we do not promote and\n+       inline these indirect calls before annotation, the profile for\n+       these promoted functions will be lost.\n+\n+       e.g. foo() --indirect_call--> bar()\n+       In profiled binary, the callsite is promoted and inlined, making\n+       the profile look like:\n+\n+       foo: {\n+         loc_foo_1: count_1\n+         bar@loc_foo_2: {\n+           loc_bar_1: count_2\n+           loc_bar_2: count_3\n+         }\n+       }\n+\n+       Before AutoFDO pass, loc_foo_2 is not promoted thus not inlined.\n+       If we perform annotation on it, the profile inside bar@loc_foo2\n+       will be wasted.\n+\n+       To avoid this, we promote loc_foo_2 and inline the promoted bar\n+       function before annotation, so the profile inside bar@loc_foo2\n+       will be useful.  */\n+    autofdo::stmt_set promoted_stmts;\n+    for (int i = 0; i < PARAM_VALUE (PARAM_EARLY_INLINER_MAX_ITERATIONS); i++)\n+      {\n+        if (!flag_value_profile_transformations\n+            || !autofdo::afdo_vpt_for_early_inline (&promoted_stmts))\n+          break;\n+        early_inline ();\n+      }\n+\n+    early_inline ();\n+    autofdo::afdo_annotate_cfg (promoted_stmts);\n+    compute_function_frequency ();\n+    update_ssa (TODO_update_ssa);\n+\n+    /* Local pure-const may imply need to fixup the cfg.  */\n+    if (execute_fixup_cfg () & TODO_cleanup_cfg)\n+      cleanup_tree_cfg ();\n+\n+    free_dominance_info (CDI_DOMINATORS);\n+    free_dominance_info (CDI_POST_DOMINATORS);\n+    cgraph_edge::rebuild_edges ();\n+    pop_cfun ();\n+  }\n+\n+  return TODO_rebuild_cgraph_edges;\n+}\n+} /* namespace autofdo.  */\n+\n+/* Read the profile from the profile data file.  */\n+\n+void\n+read_autofdo_file (void)\n+{\n+  if (auto_profile_file == NULL)\n+    auto_profile_file = DEFAULT_AUTO_PROFILE_FILE;\n+\n+  autofdo::afdo_profile_info = (struct gcov_ctr_summary *)xcalloc (\n+      1, sizeof (struct gcov_ctr_summary));\n+  autofdo::afdo_profile_info->runs = 1;\n+  autofdo::afdo_profile_info->sum_max = 0;\n+  autofdo::afdo_profile_info->sum_all = 0;\n+\n+  /* Read the profile from the profile file.  */\n+  autofdo::read_profile ();\n+}\n+\n+/* Free the resources.  */\n+\n+void\n+end_auto_profile (void)\n+{\n+  delete autofdo::afdo_source_profile;\n+  delete autofdo::afdo_string_table;\n+  profile_info = NULL;\n+}\n+\n+/* Returns TRUE if EDGE is hot enough to be inlined early.  */\n+\n+bool\n+afdo_callsite_hot_enough_for_early_inline (struct cgraph_edge *edge)\n+{\n+  gcov_type count\n+      = autofdo::afdo_source_profile->get_callsite_total_count (edge);\n+  if (count > 0)\n+    {\n+      bool is_hot;\n+      const struct gcov_ctr_summary *saved_profile_info = profile_info;\n+      /* At earling inline stage, profile_info is not set yet. We need to\n+         temporarily set it to afdo_profile_info to calculate hotness.  */\n+      profile_info = autofdo::afdo_profile_info;\n+      is_hot = maybe_hot_count_p (NULL, count);\n+      profile_info = saved_profile_info;\n+      return is_hot;\n+    }\n+  else\n+    return false;\n+}\n+\n+namespace\n+{\n+\n+const pass_data pass_data_ipa_auto_profile = {\n+  SIMPLE_IPA_PASS, \"afdo\", /* name */\n+  OPTGROUP_NONE,           /* optinfo_flags */\n+  TV_IPA_AUTOFDO,          /* tv_id */\n+  0,                       /* properties_required */\n+  0,                       /* properties_provided */\n+  0,                       /* properties_destroyed */\n+  0,                       /* todo_flags_start */\n+  0,                       /* todo_flags_finish */\n+};\n+\n+class pass_ipa_auto_profile : public simple_ipa_opt_pass\n+{\n+public:\n+  pass_ipa_auto_profile (gcc::context *ctxt)\n+      : simple_ipa_opt_pass (pass_data_ipa_auto_profile, ctxt)\n+  {\n+  }\n+\n+  /* opt_pass methods: */\n+  virtual bool\n+  gate (function *)\n+  {\n+    return flag_auto_profile;\n+  }\n+  virtual unsigned int\n+  execute (function *)\n+  {\n+    return autofdo::auto_profile ();\n+  }\n+}; // class pass_ipa_auto_profile\n+\n+} // anon namespace\n+\n+simple_ipa_opt_pass *\n+make_pass_ipa_auto_profile (gcc::context *ctxt)\n+{\n+  return new pass_ipa_auto_profile (ctxt);\n+}"}, {"sha": "7b4f2449cb7b7ea7aed826d5051b0b8aa56b620d", "filename": "gcc/auto-profile.h", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be3c16c474629e69c6c4cd6465ffa4b572cc6460/gcc%2Fauto-profile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be3c16c474629e69c6c4cd6465ffa4b572cc6460/gcc%2Fauto-profile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-profile.h?ref=be3c16c474629e69c6c4cd6465ffa4b572cc6460", "patch": "@@ -0,0 +1,31 @@\n+/* auto-profile.h - Defines data exported from auto-profile.c\n+   Copyright (C) 2014. Free Software Foundation, Inc.\n+   Contributed by Dehao Chen (dehao@google.com)\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef AUTO_PROFILE_H\n+#define AUTO_PROFILE_H\n+\n+/* Read, process, finalize AutoFDO data structures.  */\n+extern void read_autofdo_file (void);\n+extern void end_auto_profile (void);\n+\n+/* Returns TRUE if EDGE is hot enough to be inlined early.  */\n+extern bool afdo_callsite_hot_enough_for_early_inline (struct cgraph_edge *);\n+\n+#endif /* AUTO_PROFILE_H */"}, {"sha": "a82db077619ee4120245ab97426f1e5498d5cec3", "filename": "gcc/basic-block.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be3c16c474629e69c6c4cd6465ffa4b572cc6460/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be3c16c474629e69c6c4cd6465ffa4b572cc6460/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=be3c16c474629e69c6c4cd6465ffa4b572cc6460", "patch": "@@ -652,6 +652,7 @@ ei_cond (edge_iterator ei, edge *p)\n extern void dump_flow_info (FILE *, int);\n \n /* In predict.c */\n+extern bool maybe_hot_count_p (struct function *, gcov_type);\n extern bool maybe_hot_bb_p (struct function *, const_basic_block);\n extern bool maybe_hot_edge_p (edge);\n extern bool probably_never_executed_bb_p (struct function *, const_basic_block);\n@@ -805,6 +806,7 @@ extern void default_rtl_profile (void);\n /* In profile.c.  */\n typedef struct gcov_working_set_info gcov_working_set_t;\n extern gcov_working_set_t *find_working_set (unsigned pct_times_10);\n+extern void add_working_set (gcov_working_set_t *);\n \n /* Check tha probability is sane.  */\n "}, {"sha": "817ac87bf12f86dedb5abadf4eed4f1bf20251f7", "filename": "gcc/common.opt", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be3c16c474629e69c6c4cd6465ffa4b572cc6460/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be3c16c474629e69c6c4cd6465ffa4b572cc6460/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=be3c16c474629e69c6c4cd6465ffa4b572cc6460", "patch": "@@ -895,6 +895,16 @@ fauto-inc-dec\n Common Report Var(flag_auto_inc_dec) Init(1)\n Generate auto-inc/dec instructions\n \n+fauto-profile\n+Common Report Var(flag_auto_profile) Optimization\n+Use sample profile information for call graph node weights. The default\n+profile file is fbdata.afdo in 'pwd'.\n+\n+fauto-profile=\n+Common Joined RejectNegative Var(auto_profile_file)\n+Use sample profile information for call graph node weights. The profile\n+file is specified in the argument.\n+\n ; -fcheck-bounds causes gcc to generate array bounds checks.\n ; For C, C++ and ObjC: defaults off.\n ; For Java: defaults to on."}, {"sha": "c02b18c11443c8632e24c1c1c5f5e4f2cdb584e1", "filename": "gcc/coverage.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be3c16c474629e69c6c4cd6465ffa4b572cc6460/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be3c16c474629e69c6c4cd6465ffa4b572cc6460/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=be3c16c474629e69c6c4cd6465ffa4b572cc6460", "patch": "@@ -61,6 +61,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"filenames.h\"\n #include \"target.h\"\n #include \"params.h\"\n+#include \"auto-profile.h\"\n \n #include \"gcov-io.h\"\n #include \"gcov-io.c\"\n@@ -1214,7 +1215,9 @@ coverage_init (const char *filename)\n \n   bbg_file_stamp = local_tick;\n   \n-  if (flag_branch_probabilities)\n+  if (flag_auto_profile)\n+    read_autofdo_file ();\n+  else if (flag_branch_probabilities)\n     read_counts_file ();\n \n   /* Name of bbg file.  */"}, {"sha": "0b26976c52009d33c7c1989120beeced9c1f583a", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be3c16c474629e69c6c4cd6465ffa4b572cc6460/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be3c16c474629e69c6c4cd6465ffa4b572cc6460/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=be3c16c474629e69c6c4cd6465ffa4b572cc6460", "patch": "@@ -365,7 +365,8 @@ Objective-C and Objective-C++ Dialects}.\n @gccoptlist{-faggressive-loop-optimizations -falign-functions[=@var{n}] @gol\n -falign-jumps[=@var{n}] @gol\n -falign-labels[=@var{n}] -falign-loops[=@var{n}] @gol\n--fassociative-math -fauto-inc-dec -fbranch-probabilities @gol\n+-fassociative-math -fauto-profile -fauto-profile[=@var{path}] @gol\n+-fauto-inc-dec -fbranch-probabilities @gol\n -fbranch-target-load-optimize -fbranch-target-load-optimize2 @gol\n -fbtr-bb-exclusive -fcaller-saves @gol\n -fcheck-data-deps -fcombine-stack-adjustments -fconserve-stack @gol\n@@ -9205,6 +9206,41 @@ code.\n \n If @var{path} is specified, GCC looks at the @var{path} to find\n the profile feedback data files. See @option{-fprofile-dir}.\n+\n+@item -fauto-profile\n+@itemx -fauto-profile=@var{path}\n+@opindex fauto-profile\n+Enable sampling based feedback directed optimizations, and optimizations\n+generally profitable only with profile feedback available.\n+\n+The following options are enabled: @code{-fbranch-probabilities}, @code{-fvpt},\n+@code{-funroll-loops}, @code{-fpeel-loops}, @code{-ftracer}, @code{-ftree-vectorize},\n+@code{-finline-functions}, @code{-fipa-cp}, @code{-fipa-cp-clone},\n+@code{-fpredictive-commoning}, @code{-funswitch-loops},\n+@code{-fgcse-after-reload}, @code{-ftree-loop-distribute-patterns},\n+\n+If @var{path} is specified, GCC looks at the @var{path} to find\n+the profile feedback data files.\n+\n+In order to collect AutoFDO profile, you need to have:\n+\n+1. A linux system with linux perf support\n+2. (optional) An Intel processor with last branch record (LBR) support. This is\n+   to guarantee accurate instruction level profile, which is important for\n+   AutoFDO performance.\n+\n+To collect the profile, first use linux perf to collect raw profile\n+(see @uref{https://perf.wiki.kernel.org/}).\n+\n+E.g.\n+@code{perf record -e br_inst_retired:near_taken -b -o perf.data -- your_program}\n+\n+Then use create_gcov tool, which takes raw profile and unstripped binary to\n+generate AutoFDO profile that can be used by GCC.\n+(see @uref{https://github.com/google/autofdo}).\n+\n+E.g.\n+@code{create_gcov --binary=your_program.unstripped --profile=perf.data --gcov=profile.afdo}\n @end table\n \n The following options control compiler behavior regarding floating-point "}, {"sha": "3c2543705d5fbb8963ad80a1221f44f05a588958", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be3c16c474629e69c6c4cd6465ffa4b572cc6460/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be3c16c474629e69c6c4cd6465ffa4b572cc6460/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=be3c16c474629e69c6c4cd6465ffa4b572cc6460", "patch": "@@ -244,6 +244,9 @@ typedef uint64_t gcov_type_unsigned;\n #define GCOV_TAG_PROGRAM_SUMMARY ((gcov_unsigned_t)0xa3000000)\n #define GCOV_TAG_SUMMARY_LENGTH(NUM)  \\\n         (1 + GCOV_COUNTERS_SUMMABLE * (10 + 3 * 2) + (NUM) * 5)\n+#define GCOV_TAG_AFDO_FILE_NAMES ((gcov_unsigned_t)0xaa000000)\n+#define GCOV_TAG_AFDO_FUNCTION ((gcov_unsigned_t)0xac000000)\n+#define GCOV_TAG_AFDO_WORKING_SET ((gcov_unsigned_t)0xaf000000)\n \n \n /* Counters that are collected.  */"}, {"sha": "f0177dfc60d1b953f0c9973478349ae7a486df9e", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 47, "deletions": 32, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be3c16c474629e69c6c4cd6465ffa4b572cc6460/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be3c16c474629e69c6c4cd6465ffa4b572cc6460/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=be3c16c474629e69c6c4cd6465ffa4b572cc6460", "patch": "@@ -122,6 +122,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-inline.h\"\n #include \"ipa-utils.h\"\n #include \"sreal.h\"\n+#include \"auto-profile.h\"\n #include \"cilk.h\"\n #include \"builtins.h\"\n \n@@ -443,6 +444,14 @@ want_early_inline_function_p (struct cgraph_edge *e)\n \n   if (DECL_DISREGARD_INLINE_LIMITS (callee->decl))\n     ;\n+  /* For AutoFDO, we need to make sure that before profile annotation, all\n+     hot paths' IR look exactly the same as profiled binary. As a result,\n+     in einliner, we will disregard size limit and inline those callsites\n+     that are:\n+       * inlined in the profiled binary, and\n+       * the cloned callee has enough samples to be considered \"hot\".  */\n+  else if (flag_auto_profile && afdo_callsite_hot_enough_for_early_inline (e))\n+    ;\n   else if (!DECL_DECLARED_INLINE_P (callee->decl)\n \t   && !flag_inline_small_functions)\n     {\n@@ -2360,39 +2369,8 @@ early_inline_small_functions (struct cgraph_node *node)\n   return inlined;\n }\n \n-/* Do inlining of small functions.  Doing so early helps profiling and other\n-   passes to be somewhat more effective and avoids some code duplication in\n-   later real inlining pass for testcases with very many function calls.  */\n-\n-namespace {\n-\n-const pass_data pass_data_early_inline =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"einline\", /* name */\n-  OPTGROUP_INLINE, /* optinfo_flags */\n-  TV_EARLY_INLINING, /* tv_id */\n-  PROP_ssa, /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  0, /* todo_flags_finish */\n-};\n-\n-class pass_early_inline : public gimple_opt_pass\n-{\n-public:\n-  pass_early_inline (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_early_inline, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  virtual unsigned int execute (function *);\n-\n-}; // class pass_early_inline\n-\n unsigned int\n-pass_early_inline::execute (function *fun)\n+early_inliner (function *fun)\n {\n   struct cgraph_node *node = cgraph_node::get (current_function_decl);\n   struct cgraph_edge *edge;\n@@ -2493,6 +2471,43 @@ pass_early_inline::execute (function *fun)\n   return todo;\n }\n \n+/* Do inlining of small functions.  Doing so early helps profiling and other\n+   passes to be somewhat more effective and avoids some code duplication in\n+   later real inlining pass for testcases with very many function calls.  */\n+\n+namespace {\n+\n+const pass_data pass_data_early_inline =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"einline\", /* name */\n+  OPTGROUP_INLINE, /* optinfo_flags */\n+  TV_EARLY_INLINING, /* tv_id */\n+  PROP_ssa, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_early_inline : public gimple_opt_pass\n+{\n+public:\n+  pass_early_inline (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_early_inline, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_early_inline\n+\n+unsigned int\n+pass_early_inline::execute (function *fun)\n+{\n+  return early_inliner (fun);\n+}\n+\n } // anon namespace\n \n gimple_opt_pass *"}, {"sha": "8edf49621adaeddcbe8574a0f068bb564bd5da8b", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be3c16c474629e69c6c4cd6465ffa4b572cc6460/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be3c16c474629e69c6c4cd6465ffa4b572cc6460/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=be3c16c474629e69c6c4cd6465ffa4b572cc6460", "patch": "@@ -238,6 +238,7 @@ void initialize_growth_caches (void);\n void free_growth_caches (void);\n void compute_inline_parameters (struct cgraph_node *, bool);\n bool speculation_useful_p (struct cgraph_edge *e, bool anticipate_inlining);\n+unsigned int early_inliner (function *fun);\n \n /* In ipa-inline-transform.c  */\n bool inline_call (struct cgraph_edge *, bool, vec<cgraph_edge *> *, int *, bool,"}, {"sha": "de066bcce0727f72181c48b8519b7a5a77938539", "filename": "gcc/opts.c", "status": "modified", "additions": 62, "deletions": 38, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be3c16c474629e69c6c4cd6465ffa4b572cc6460/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be3c16c474629e69c6c4cd6465ffa4b572cc6460/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=be3c16c474629e69c6c4cd6465ffa4b572cc6460", "patch": "@@ -1280,6 +1280,50 @@ print_specific_help (unsigned int include_flags,\n \t\t       opts->x_help_columns, opts, lang_mask);\n }\n \n+/* Enable FDO-related flags.  */\n+\n+static void\n+enable_fdo_optimizations (struct gcc_options *opts,\n+\t\t\t  struct gcc_options *opts_set,\n+\t\t\t  int value)\n+{\n+  if (!opts_set->x_flag_branch_probabilities)\n+    opts->x_flag_branch_probabilities = value;\n+  if (!opts_set->x_flag_profile_values)\n+    opts->x_flag_profile_values = value;\n+  if (!opts_set->x_flag_unroll_loops)\n+    opts->x_flag_unroll_loops = value;\n+  if (!opts_set->x_flag_peel_loops)\n+    opts->x_flag_peel_loops = value;\n+  if (!opts_set->x_flag_tracer)\n+    opts->x_flag_tracer = value;\n+  if (!opts_set->x_flag_value_profile_transformations)\n+    opts->x_flag_value_profile_transformations = value;\n+  if (!opts_set->x_flag_inline_functions)\n+    opts->x_flag_inline_functions = value;\n+  if (!opts_set->x_flag_ipa_cp)\n+    opts->x_flag_ipa_cp = value;\n+  if (!opts_set->x_flag_ipa_cp_clone\n+      && value && opts->x_flag_ipa_cp)\n+    opts->x_flag_ipa_cp_clone = value;\n+  if (!opts_set->x_flag_predictive_commoning)\n+    opts->x_flag_predictive_commoning = value;\n+  if (!opts_set->x_flag_unswitch_loops)\n+    opts->x_flag_unswitch_loops = value;\n+  if (!opts_set->x_flag_gcse_after_reload)\n+    opts->x_flag_gcse_after_reload = value;\n+  if (!opts_set->x_flag_tree_loop_vectorize\n+      && !opts_set->x_flag_tree_vectorize)\n+    opts->x_flag_tree_loop_vectorize = value;\n+  if (!opts_set->x_flag_tree_slp_vectorize\n+      && !opts_set->x_flag_tree_vectorize)\n+    opts->x_flag_tree_slp_vectorize = value;\n+  if (!opts_set->x_flag_vect_cost_model)\n+    opts->x_flag_vect_cost_model = VECT_COST_MODEL_DYNAMIC;\n+  if (!opts_set->x_flag_tree_loop_distribute_patterns)\n+    opts->x_flag_tree_loop_distribute_patterns = value;\n+}\n+\n /* Handle target- and language-independent options.  Return zero to\n    generate an \"unknown option\" message.  Only options that need\n    extra handling need to be listed here; if you simply want\n@@ -1749,50 +1793,30 @@ common_handle_option (struct gcc_options *opts,\n       value = true;\n       /* No break here - do -fprofile-use processing. */\n     case OPT_fprofile_use:\n-      if (!opts_set->x_flag_branch_probabilities)\n-\topts->x_flag_branch_probabilities = value;\n-      if (!opts_set->x_flag_profile_values)\n-\topts->x_flag_profile_values = value;\n-      if (!opts_set->x_flag_unroll_loops)\n-\topts->x_flag_unroll_loops = value;\n-      if (!opts_set->x_flag_peel_loops)\n-\topts->x_flag_peel_loops = value;\n-      if (!opts_set->x_flag_tracer)\n-\topts->x_flag_tracer = value;\n-      if (!opts_set->x_flag_value_profile_transformations)\n-\topts->x_flag_value_profile_transformations = value;\n-      if (!opts_set->x_flag_inline_functions)\n-\topts->x_flag_inline_functions = value;\n-      if (!opts_set->x_flag_ipa_cp)\n-\topts->x_flag_ipa_cp = value;\n-      if (!opts_set->x_flag_ipa_cp_clone\n-\t  && value && opts->x_flag_ipa_cp)\n-\topts->x_flag_ipa_cp_clone = value;\n-      if (!opts_set->x_flag_predictive_commoning)\n-\topts->x_flag_predictive_commoning = value;\n-      if (!opts_set->x_flag_unswitch_loops)\n-\topts->x_flag_unswitch_loops = value;\n-      if (!opts_set->x_flag_gcse_after_reload)\n-\topts->x_flag_gcse_after_reload = value;\n-      if (!opts_set->x_flag_tree_loop_vectorize\n-          && !opts_set->x_flag_tree_vectorize)\n-\topts->x_flag_tree_loop_vectorize = value;\n-      if (!opts_set->x_flag_tree_slp_vectorize\n-          && !opts_set->x_flag_tree_vectorize)\n-\topts->x_flag_tree_slp_vectorize = value;\n-      if (!opts_set->x_flag_vect_cost_model)\n-\topts->x_flag_vect_cost_model = VECT_COST_MODEL_DYNAMIC;\n-      if (!opts_set->x_flag_tree_loop_distribute_patterns)\n-\topts->x_flag_tree_loop_distribute_patterns = value;\n+      enable_fdo_optimizations (opts, opts_set, value);\n       if (!opts_set->x_flag_profile_reorder_functions)\n-\topts->x_flag_profile_reorder_functions = value;\n-      /* Indirect call profiling should do all useful transformations\n- \t speculative devirtualization does.  */\n+\t  opts->x_flag_profile_reorder_functions = value;\n+\t/* Indirect call profiling should do all useful transformations\n+\t   speculative devirtualization does.  */\n       if (!opts_set->x_flag_devirtualize_speculatively\n \t  && opts->x_flag_value_profile_transformations)\n \topts->x_flag_devirtualize_speculatively = false;\n       break;\n \n+    case OPT_fauto_profile_:\n+      opts->x_auto_profile_file = xstrdup (arg);\n+      opts->x_flag_auto_profile = true;\n+      value = true;\n+      /* No break here - do -fauto-profile processing. */\n+    case OPT_fauto_profile:\n+      enable_fdo_optimizations (opts, opts_set, value);\n+      if (!opts_set->x_flag_profile_correction)\n+\topts->x_flag_profile_correction = value;\n+      maybe_set_param_value (\n+\tPARAM_EARLY_INLINER_MAX_ITERATIONS, 10,\n+\topts->x_param_values, opts_set->x_param_values);\n+      break;\n+\n     case OPT_fprofile_generate_:\n       opts->x_profile_data_prefix = xstrdup (arg);\n       value = true;"}, {"sha": "9c2542d5352201ad795b38a4c28173c31f37bb99", "filename": "gcc/passes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be3c16c474629e69c6c4cd6465ffa4b572cc6460/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be3c16c474629e69c6c4cd6465ffa4b572cc6460/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=be3c16c474629e69c6c4cd6465ffa4b572cc6460", "patch": "@@ -90,6 +90,7 @@ along with GCC; see the file COPYING3.  If not see\n       NEXT_PASS (pass_rebuild_cgraph_edges);\n       NEXT_PASS (pass_inline_parameters);\n   POP_INSERT_PASSES ()\n+  NEXT_PASS (pass_ipa_auto_profile);\n   NEXT_PASS (pass_ipa_free_inline_summary);\n   NEXT_PASS (pass_ipa_tree_profile);\n   PUSH_INSERT_PASSES_WITHIN (pass_ipa_tree_profile)"}, {"sha": "96c7661aebe4e3140ccd8fb510c0389ef31f98a7", "filename": "gcc/predict.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be3c16c474629e69c6c4cd6465ffa4b572cc6460/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be3c16c474629e69c6c4cd6465ffa4b572cc6460/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=be3c16c474629e69c6c4cd6465ffa4b572cc6460", "patch": "@@ -167,7 +167,7 @@ set_hot_bb_threshold (gcov_type min)\n \n /* Return TRUE if frequency FREQ is considered to be hot.  */\n \n-static inline bool\n+bool\n maybe_hot_count_p (struct function *fun, gcov_type count)\n {\n   if (fun && profile_status_for_fn (fun) != PROFILE_READ)\n@@ -2859,7 +2859,7 @@ counts_to_freqs (void)\n   /* Don't overwrite the estimated frequencies when the profile for\n      the function is missing.  We may drop this function PROFILE_GUESSED\n      later in drop_profile ().  */\n-  if (!ENTRY_BLOCK_PTR_FOR_FN (cfun)->count)\n+  if (!flag_auto_profile && !ENTRY_BLOCK_PTR_FOR_FN (cfun)->count)\n     return 0;\n \n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun), NULL, next_bb)\n@@ -3230,7 +3230,8 @@ rebuild_frequencies (void)\n     count_max = MAX (bb->count, count_max);\n \n   if (profile_status_for_fn (cfun) == PROFILE_GUESSED\n-      || (profile_status_for_fn (cfun) == PROFILE_READ && count_max < REG_BR_PROB_BASE/10))\n+      || (!flag_auto_profile && profile_status_for_fn (cfun) == PROFILE_READ\n+\t  && count_max < REG_BR_PROB_BASE/10))\n     {\n       loop_optimizer_init (0);\n       add_noreturn_fake_exit_edges ();"}, {"sha": "71b8cbdc97fe928267724b680ccc837e8488d157", "filename": "gcc/profile.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be3c16c474629e69c6c4cd6465ffa4b572cc6460/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be3c16c474629e69c6c4cd6465ffa4b572cc6460/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=be3c16c474629e69c6c4cd6465ffa4b572cc6460", "patch": "@@ -112,6 +112,14 @@ static int total_num_times_called;\n static int total_hist_br_prob[20];\n static int total_num_branches;\n \n+/* Helper function to update gcov_working_sets.  */\n+\n+void add_working_set (gcov_working_set_t *set) {\n+  int i = 0;\n+  for (; i < NUM_GCOV_WORKING_SETS; i++)\n+    gcov_working_sets[i] = set[i];\n+}\n+\n /* Forward declarations.  */\n static void find_spanning_tree (struct edge_list *);\n "}, {"sha": "96b606951d6b852e74a762beaf882119c310f28b", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be3c16c474629e69c6c4cd6465ffa4b572cc6460/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be3c16c474629e69c6c4cd6465ffa4b572cc6460/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=be3c16c474629e69c6c4cd6465ffa4b572cc6460", "patch": "@@ -89,6 +89,7 @@ DEFTIMEVAR (TV_WHOPR_PARTITIONING    , \"whopr partitioning\")\n DEFTIMEVAR (TV_WHOPR_LTRANS          , \"whopr ltrans\")\n DEFTIMEVAR (TV_IPA_REFERENCE         , \"ipa reference\")\n DEFTIMEVAR (TV_IPA_PROFILE           , \"ipa profile\")\n+DEFTIMEVAR (TV_IPA_AUTOFDO           , \"auto profile\")\n DEFTIMEVAR (TV_IPA_PURE_CONST        , \"ipa pure const\")\n DEFTIMEVAR (TV_IPA_ICF\t\t     , \"ipa icf\")\n DEFTIMEVAR (TV_IPA_PTA               , \"ipa points-to\")"}, {"sha": "adfae0bf93b34e738add14753c855eb9516d62b7", "filename": "gcc/toplev.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be3c16c474629e69c6c4cd6465ffa4b572cc6460/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be3c16c474629e69c6c4cd6465ffa4b572cc6460/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=be3c16c474629e69c6c4cd6465ffa4b572cc6460", "patch": "@@ -83,6 +83,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-color.h\"\n #include \"context.h\"\n #include \"pass_manager.h\"\n+#include \"auto-profile.h\"\n #include \"dwarf2out.h\"\n #include \"ipa-reference.h\"\n #include \"ipa-prop.h\"\n@@ -671,6 +672,10 @@ compile_file (void)\n       targetm.asm_out.output_ident (ident_str);\n     }\n \n+  /* Auto profile finalization. */\n+  if (flag_auto_profile)\n+    end_auto_profile ();\n+\n   /* Invoke registered plugin callbacks.  */\n   invoke_plugin_callbacks (PLUGIN_FINISH_UNIT, NULL);\n "}, {"sha": "3db1a08b0ddc852c66f120dbb70bcf6c45b91b01", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be3c16c474629e69c6c4cd6465ffa4b572cc6460/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be3c16c474629e69c6c4cd6465ffa4b572cc6460/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=be3c16c474629e69c6c4cd6465ffa4b572cc6460", "patch": "@@ -449,6 +449,7 @@ extern simple_ipa_opt_pass *make_pass_ipa_lower_emutls (gcc::context *ctxt);\n extern simple_ipa_opt_pass\n \t\t\t\t\t\t\t      *make_pass_ipa_function_and_variable_visibility (gcc::context *ctxt);\n extern simple_ipa_opt_pass *make_pass_ipa_tree_profile (gcc::context *ctxt);\n+extern simple_ipa_opt_pass *make_pass_ipa_auto_profile (gcc::context *ctxt);\n \n extern simple_ipa_opt_pass *make_pass_early_local_passes (gcc::context *ctxt);\n "}, {"sha": "ceb616968ef3af66ee1ea396e5a3714682486377", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be3c16c474629e69c6c4cd6465ffa4b572cc6460/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be3c16c474629e69c6c4cd6465ffa4b572cc6460/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=be3c16c474629e69c6c4cd6465ffa4b572cc6460", "patch": "@@ -719,8 +719,10 @@ class pass_ipa_tree_profile : public simple_ipa_opt_pass\n bool\n pass_ipa_tree_profile::gate (function *)\n {\n-  /* When profile instrumentation, use or test coverage shall be performed.  */\n-  return (!in_lto_p\n+  /* When profile instrumentation, use or test coverage shall be performed.\n+     But for AutoFDO, this there is no instrumentation, thus this pass is\n+     diabled.  */\n+  return (!in_lto_p && !flag_auto_profile\n \t  && (flag_branch_probabilities || flag_test_coverage\n \t      || profile_arc_flag));\n }"}, {"sha": "87f5bf84c59b7c8c268b1ea90178efef39cb360a", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be3c16c474629e69c6c4cd6465ffa4b572cc6460/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be3c16c474629e69c6c4cd6465ffa4b572cc6460/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=be3c16c474629e69c6c4cd6465ffa4b572cc6460", "patch": "@@ -605,7 +605,7 @@ remove_unused_scope_block_p (tree scope)\n      ;\n    /* When not generating debug info we can eliminate info on unused\n       variables.  */\n-   else if (debug_info_level == DINFO_LEVEL_NONE)\n+   else if (!flag_auto_profile && debug_info_level == DINFO_LEVEL_NONE)\n      {\n        /* Even for -g0 don't prune outer scopes from artificial\n \t  functions, otherwise diagnostics using tree_nonartificial_location"}, {"sha": "8ed6433ce7fdabed5aab2d311d9ea83ff960484c", "filename": "gcc/value-prof.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be3c16c474629e69c6c4cd6465ffa4b572cc6460/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be3c16c474629e69c6c4cd6465ffa4b572cc6460/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=be3c16c474629e69c6c4cd6465ffa4b572cc6460", "patch": "@@ -139,7 +139,7 @@ static bool gimple_ic_transform (gimple_stmt_iterator *);\n \n /* Allocate histogram value.  */\n \n-static histogram_value\n+histogram_value\n gimple_alloc_histogram_value (struct function *fun ATTRIBUTE_UNUSED,\n \t\t\t      enum hist_type type, gimple stmt, tree value)\n {\n@@ -1342,7 +1342,7 @@ find_func_by_profile_id (int profile_id)\n    may ICE. Here we only do very minimal sanity check just to make compiler happy.\n    Returns true if TARGET is considered ok for call CALL_STMT.  */\n \n-static bool\n+bool\n check_ic_target (gimple call_stmt, struct cgraph_node *target)\n {\n    location_t locus;"}, {"sha": "f4db3d4bb661dc2a796836341802ecc8fadc1792", "filename": "gcc/value-prof.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be3c16c474629e69c6c4cd6465ffa4b572cc6460/gcc%2Fvalue-prof.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be3c16c474629e69c6c4cd6465ffa4b572cc6460/gcc%2Fvalue-prof.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.h?ref=be3c16c474629e69c6c4cd6465ffa4b572cc6460", "patch": "@@ -77,6 +77,8 @@ typedef vec<histogram_value> histogram_values;\n extern void gimple_find_values_to_profile (histogram_values *);\n extern bool gimple_value_profile_transformations (void);\n \n+histogram_value gimple_alloc_histogram_value (struct function *, enum hist_type,\n+\t\t\t\t\t      gimple stmt, tree);\n histogram_value gimple_histogram_value (struct function *, gimple);\n histogram_value gimple_histogram_value_of_type (struct function *, gimple,\n \t\t\t\t\t\tenum hist_type);\n@@ -91,6 +93,7 @@ void verify_histograms (void);\n void free_histograms (void);\n void stringop_block_profile (gimple, unsigned int *, HOST_WIDE_INT *);\n gimple gimple_ic (gimple, struct cgraph_node *, int, gcov_type, gcov_type);\n+bool check_ic_target (gimple, struct cgraph_node *);\n \n \n /* In tree-profile.c.  */"}]}