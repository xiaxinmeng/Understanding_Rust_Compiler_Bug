{"sha": "14e33ee85629ee9bfb7185eadb27a9066bb02687", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTRlMzNlZTg1NjI5ZWU5YmZiNzE4NWVhZGIyN2E5MDY2YmIwMjY4Nw==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-07-19T23:32:55Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-07-19T23:32:55Z"}, "message": "* c-decl.c (named_labels, shadowed_labels, label_level_chain)\n\t(push_label_level, pop_label_level): Kill.\n\t(struct binding_level): Rename level_chain to outer.\n\tAdd outer_function field.  Change parm_flag, function_body,\n\tkeep, keep_if_subblocks to 1-bit bitfields of type bool.\n\t(current_function_level): New variable.\n\t(keep_next_level_flag, keep_next_if_subblocks): Change type to bool.\n\t(keep_next_level, declare_parm_level, warn_if_shadowing):\n\tUpdate to match.\n\t(struct language_function): Kill named_labels, shadowed_labels fields.\n\t(c_init_decl_processing, start_function, c_push__function_context)\n\t(c_pop_function_context): No need to muck with named_labels nor\n\tshadowed_labels.\n\n\t(make_binding_level): No need to clear the structure here.\n\t(pop_binding_level): Always operate on current_binding_level.\n\tUpdate current_function_level if necessary.\n\t(pushlevel): Don't clear named_labels.  Update current_function_level\n\tif necessary.  Use \"true\" and \"false\" where appropriate.\n\t(poplevel): Diagnose labels defined but not used, or vice\n\tversa, and clear out label-meanings leaving scope, while\n\twalking down the decls list, for all binding levels.\n\tHandle LABEL_DECLs appearing in the shadowed list.\n\tpop_binding_level takes no arguments.\n\t(pushdecl_function_level): Use current_function_level.\n\n\t(make_label, bind_label): New static functions.\n\t(declare_label): New exported function.\n\t(lookup_label, define_label): Rewritten for new data structure.\n\t(shadow_label): Kill.\n\n\t* c-tree.h: Prototype declare_label; don't prototype\n\tpush_label_level, pop_label_level, nor shadow_label.\n\t* c-parse.in: Remove all calls to push_label_level and\n\tpop_label_level.  Use declare_label for __label__ decls.\n\n\t* doc/extend.texi: Clarify that __label__ can be used to\n\tdeclare labels with local scope in any nested block, not\n\tjust statement expressions.  Cross-reference nested functions\n\tsection from local labels section.\n\ntestsuite:\n\t* gcc.dg/noncompile/label-1.c: New comprehensive test case for\n\tdiagnostics of ill-formed constructs involving labels.\n\t* gcc.dg/noncompile/label-lineno-1.c: Add error regexp for\n\tthe new 'previously defined here' message.\n\nFrom-SVN: r69597", "tree": {"sha": "39921ed41b276ac3aff0d0ef4a2b474488855a70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39921ed41b276ac3aff0d0ef4a2b474488855a70"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/14e33ee85629ee9bfb7185eadb27a9066bb02687", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14e33ee85629ee9bfb7185eadb27a9066bb02687", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14e33ee85629ee9bfb7185eadb27a9066bb02687", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14e33ee85629ee9bfb7185eadb27a9066bb02687/comments", "author": null, "committer": null, "parents": [{"sha": "1b339d862abe1a3858536ba5f204218daed6a49a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b339d862abe1a3858536ba5f204218daed6a49a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b339d862abe1a3858536ba5f204218daed6a49a"}], "stats": {"total": 774, "additions": 475, "deletions": 299}, "files": [{"sha": "0905e540d5f29f07354a4aa07d820938648a7d88", "filename": "gcc/ChangeLog", "status": "modified", "additions": 50, "deletions": 7, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14e33ee85629ee9bfb7185eadb27a9066bb02687/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14e33ee85629ee9bfb7185eadb27a9066bb02687/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=14e33ee85629ee9bfb7185eadb27a9066bb02687", "patch": "@@ -1,3 +1,46 @@\n+2003-07-19  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* c-decl.c (named_labels, shadowed_labels, label_level_chain)\n+\t(push_label_level, pop_label_level): Kill.\n+\t(struct binding_level): Rename level_chain to outer.\n+\tAdd outer_function field.  Change parm_flag, function_body,\n+\tkeep, keep_if_subblocks to 1-bit bitfields of type bool.\n+\t(current_function_level): New variable.\n+\t(keep_next_level_flag, keep_next_if_subblocks): Change type to bool.\n+\t(keep_next_level, declare_parm_level, warn_if_shadowing):\n+\tUpdate to match.\n+\t(struct language_function): Kill named_labels, shadowed_labels fields.\n+\t(c_init_decl_processing, start_function, c_push__function_context)\n+\t(c_pop_function_context): No need to muck with named_labels nor\n+\tshadowed_labels.\n+\n+\t(make_binding_level): No need to clear the structure here.\n+\t(pop_binding_level): Always operate on current_binding_level.\n+\tUpdate current_function_level if necessary.\n+\t(pushlevel): Don't clear named_labels.  Update current_function_level\n+\tif necessary.  Use \"true\" and \"false\" where appropriate.\n+\t(poplevel): Diagnose labels defined but not used, or vice\n+\tversa, and clear out label-meanings leaving scope, while\n+\twalking down the decls list, for all binding levels.\n+\tHandle LABEL_DECLs appearing in the shadowed list.\n+\tpop_binding_level takes no arguments.\n+\t(pushdecl_function_level): Use current_function_level.\n+\n+\t(make_label, bind_label): New static functions.\n+\t(declare_label): New exported function.\n+\t(lookup_label, define_label): Rewritten for new data structure.\n+\t(shadow_label): Kill.\n+\n+\t* c-tree.h: Prototype declare_label; don't prototype\n+\tpush_label_level, pop_label_level, nor shadow_label.\n+\t* c-parse.in: Remove all calls to push_label_level and\n+\tpop_label_level.  Use declare_label for __label__ decls.\n+\n+\t* doc/extend.texi: Clarify that __label__ can be used to\n+\tdeclare labels with local scope in any nested block, not\n+\tjust statement expressions.  Cross-reference nested functions\n+\tsection from local labels section.\n+\n 2003-07-19  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n \n \t* sched-rgn.c (find_rgns): Initialize current_edge correctly.\n@@ -13,15 +56,15 @@\n \n 2003-07-19  Ulrich Weigand  <uweigand@de.ibm.com>\n \n-\t* config/s390/s390.c (legitimize_pic_address): Access local symbols \n+\t* config/s390/s390.c (legitimize_pic_address): Access local symbols\n \trelative to the GOT instead of relative to the literal pool base.\n \t(s390_output_symbolic_const): Handle new GOT-relative accesses.\n \t* config/s390/s390.md (\"call\"): Access local functions and PLT stubs\n \trelative to the GOT instead of relative to the literal pool base.\n \t(\"call_value\"): Likewise.\n \t(\"call_value_tls\"): Likewise.\n \n-\t* config/s390/s390.c (s390_chunkify_start): Remove pool anchor \n+\t* config/s390/s390.c (s390_chunkify_start): Remove pool anchor\n \treloading.  Support LTREL_BASE / LTREL_OFFSET construct.\n \t(s390_chunkify_finish): Likewise.\n \t(s390_chunkify_cancel): Likewise.\n@@ -40,12 +83,12 @@\n \t* config/s390/s390.c (s390_split_branches): Use LTREL_BASE/OFFSET.\n \t(s390_load_got): New function.  Use LTREL_BASE/OFFSET.\n \t(s390_emit_prologue): Use it.\n-\t* config/s390/s390.md (\"builtin_longjmp\", \"builtin_setjmp_setup\", \n-\t\"builtin_setjmp_receiver\"): Cleanup.  Use s390_load_got.  Do not \n+\t* config/s390/s390.md (\"builtin_longjmp\", \"builtin_setjmp_setup\",\n+\t\"builtin_setjmp_receiver\"): Cleanup.  Use s390_load_got.  Do not\n \thard-code register 14.\n \t* config/s390/s390-protos.h (s390_load_got): Declare.\n \n-\t* config/s390/s390.c (NR_C_MODES, constant_modes, gen_consttable): \n+\t* config/s390/s390.c (NR_C_MODES, constant_modes, gen_consttable):\n \tSupport TImode constants.\n \t* config/s390/s390.md (\"consttable_ti\"): New.\n \t(\"consttable_si\", \"consttable_di\"): Handle TLS symbols correctly.\n@@ -61,7 +104,7 @@\n \t\"pool_start_64\", \"pool_end_64\", \"reload_base_31\", \"reload_base_64\",\n \t\"pool\", \"literal_pool_31\", \"literal_pool_64\"): Cleanup.  Use\n \tsymbolic UNSPEC values.\n-\t* config/s390/s390.c (larl_operand, s390_short_displacement, \n+\t* config/s390/s390.c (larl_operand, s390_short_displacement,\n \tbras_sym_operand, s390_cannot_force_const_mem,\n \ts390_delegitimize_address, s390_decompose_address,\n \tlegitimize_pic_address, s390_output_symbolic_const,\n@@ -163,7 +206,7 @@\n \n 2003-07-18  Kazu Hirata  <kazu@cs.umass.edu>\n \n-\t* combine.c (simplify_comparison): Don't share rtx when converting \n+\t* combine.c (simplify_comparison): Don't share rtx when converting\n \t(ne (and (not X) 1) 0) to (eq (and X 1) 0).\n \n 2003-07-18  David Edelsohn  <edelsohn@gnu.org>"}, {"sha": "990b4efbf389ec6c68dafe78c0f2b578b154ee56", "filename": "gcc/c-decl.c", "status": "modified", "additions": 202, "deletions": 265, "changes": 467, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14e33ee85629ee9bfb7185eadb27a9066bb02687/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14e33ee85629ee9bfb7185eadb27a9066bb02687/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=14e33ee85629ee9bfb7185eadb27a9066bb02687", "patch": "@@ -115,16 +115,6 @@ static GTY(()) struct stmt_tree_s c_stmt_tree;\n \n static GTY(()) tree c_scope_stmt_stack;\n \n-/* A list (chain of TREE_LIST nodes) of all LABEL_DECLs in the function\n-   that have names.  Here so we can clear out their names' definitions\n-   at the end of the function.  */\n-\n-static GTY(()) tree named_labels;\n-\n-/* A list of LABEL_DECLs from outer contexts that are currently shadowed.  */\n-\n-static GTY(()) tree shadowed_labels;\n-\n /* A list of external DECLs that appeared at block scope when there was\n    some other global meaning for that identifier.  */\n static GTY(()) tree truly_local_externals;\n@@ -206,23 +196,26 @@ struct binding_level GTY(())\n        that were entered and exited one level down.  */\n     tree blocks;\n \n-    /* The binding level which this one is contained in (inherits from).  */\n-    struct binding_level *level_chain;\n+    /* The scope containing this one.  */\n+    struct binding_level *outer;\n \n-    /* Nonzero if we are currently filling this level with parameter\n+    /* The next outermost function scope.  */\n+    struct binding_level *outer_function;\n+\n+    /* True if we are currently filling this level with parameter\n        declarations.  */\n-    char parm_flag;\n+    bool parm_flag : 1;\n \n-    /* Nonzero if this is the outermost block scope of a function body.\n+    /* True if this is the outermost block scope of a function body.\n        This scope contains both the parameters and the local variables\n        declared in the outermost block.  */\n-    char function_body;\n+    bool function_body : 1;\n \n-    /* Nonzero means make a BLOCK for this level regardless of all else.  */\n-    char keep;\n+    /* True means make a BLOCK for this level regardless of all else.  */\n+    bool keep : 1;\n \n-    /* Nonzero means make a BLOCK if this level has any subblocks.  */\n-    char keep_if_subblocks;\n+    /* True means make a BLOCK if this level has any subblocks.  */\n+    bool keep_if_subblocks : 1;\n \n     /* List of decls in `names' that have incomplete structure or\n        union types.  */\n@@ -244,28 +237,24 @@ static GTY(()) struct binding_level *current_binding_level;\n \n static GTY((deletable (\"\"))) struct binding_level *free_binding_level;\n \n+/* The innermost function scope.  Ordinary (not explicitly declared)\n+   labels, bindings to error_mark_node, and the lazily-created\n+   bindings of __func__ and its friends get this scope.  */\n+static GTY(()) struct binding_level *current_function_level;\n+\n /* The outermost binding level, for names of file scope.\n    This is created when the compiler is started and exists\n    through the entire run.  */\n \n static GTY(()) struct binding_level *global_binding_level;\n \n-/* Nonzero means unconditionally make a BLOCK for the next level pushed.  */\n-\n-static int keep_next_level_flag;\n-\n-/* Nonzero means make a BLOCK for the next level pushed\n-   if it has subblocks.  */\n+/* True means unconditionally make a BLOCK for the next level pushed.  */\n \n-static int keep_next_if_subblocks;\n+static bool keep_next_level_flag;\n \n-/* The chain of outer levels of label scopes.\n-   This uses the same data structure used for binding levels,\n-   but it works differently: each link in the chain records\n-   saved values of named_labels and shadowed_labels for\n-   a label binding level outside the current one.  */\n+/* True means make a BLOCK for the next level pushed if it has subblocks.  */\n \n-static GTY(()) struct binding_level *label_level_chain;\n+static bool keep_next_if_subblocks;\n \n /* Functions called automatically at the beginning and end of execution.  */\n \n@@ -274,9 +263,11 @@ tree static_ctors, static_dtors;\n /* Forward declarations.  */\n \n static struct binding_level *make_binding_level (void);\n-static void pop_binding_level (struct binding_level **);\n+static void pop_binding_level (void);\n static int duplicate_decls (tree, tree, int, int);\n static int redeclaration_error_message (tree, tree);\n+static tree make_label (tree, location_t);\n+static void bind_label (tree, tree, struct binding_level *);\n static void implicit_decl_warning (tree);\n static void storedecls (tree);\n static void storetags (tree);\n@@ -356,26 +347,29 @@ make_binding_level (void)\n   if (free_binding_level)\n     {\n       result = free_binding_level;\n-      free_binding_level = result->level_chain;\n-      memset (result, 0, sizeof(struct binding_level));\n+      free_binding_level = result->outer;\n     }\n   else\n     result = ggc_alloc_cleared (sizeof (struct binding_level));\n \n   return result;\n }\n \n-/* Remove a binding level from a list and add it to the level chain.  */\n+/* Remove the topmost binding level from the stack and add it to the\n+   free list, updating current_function_level if necessary.  */\n \n static void\n-pop_binding_level (struct binding_level **lp)\n+pop_binding_level (void)\n {\n-  struct binding_level *l = *lp;\n-  *lp = l->level_chain;\n+  struct binding_level *scope = current_binding_level;\n+\n+  current_binding_level = scope->outer;\n+  if (scope->function_body)\n+    current_function_level = scope->outer_function;\n \n-  memset (l, 0, sizeof (struct binding_level));\n-  l->level_chain = free_binding_level;\n-  free_binding_level = l;\n+  memset (scope, 0, sizeof (struct binding_level));\n+  scope->outer = free_binding_level;\n+  free_binding_level = scope;\n }\n \n /* Nonzero if we are currently in the global binding level.  */\n@@ -389,15 +383,15 @@ global_bindings_p (void)\n void\n keep_next_level (void)\n {\n-  keep_next_level_flag = 1;\n+  keep_next_level_flag = true;\n }\n \n /* Identify this binding level as a level of parameters.  */\n \n void\n declare_parm_level (void)\n {\n-  current_binding_level->parm_flag = 1;\n+  current_binding_level->parm_flag = true;\n }\n \n /* Nonzero if currently making parm declarations.  */\n@@ -413,12 +407,6 @@ in_parm_level_p (void)\n void\n pushlevel (int dummy ATTRIBUTE_UNUSED)\n {\n-  /* If this is the top level of a function, make sure that\n-     NAMED_LABELS is 0.  */\n-\n-  if (current_binding_level == global_binding_level)\n-    named_labels = 0;\n-\n   if (keep_next_if_subblocks)\n     {\n       /* This is the transition from the parameters to the top level\n@@ -429,22 +417,24 @@ pushlevel (int dummy ATTRIBUTE_UNUSED)\n \t store_parm_decls, which in turn is called when and only\n \t when we are about to encounter the opening curly brace for\n \t the function body.  */\n-      current_binding_level->parm_flag = 0;\n-      current_binding_level->function_body = 1;\n-      current_binding_level->keep |= keep_next_level_flag;\n-      current_binding_level->keep_if_subblocks = 1;\n-\n-      keep_next_level_flag = 0;\n-      keep_next_if_subblocks = 0;\n+      current_binding_level->parm_flag         = false;\n+      current_binding_level->function_body     = true;\n+      current_binding_level->keep             |= keep_next_level_flag;\n+      current_binding_level->keep_if_subblocks = true;\n+      current_binding_level->outer_function    = current_function_level;\n+      current_function_level                   = current_binding_level;\n+\n+      keep_next_level_flag = false;\n+      keep_next_if_subblocks = false;\n     }\n   else\n     {\n       struct binding_level *newlevel = make_binding_level ();\n \n-      newlevel->keep              = keep_next_level_flag;\n-      newlevel->level_chain       = current_binding_level;\n+      newlevel->keep        = keep_next_level_flag;\n+      newlevel->outer       = current_binding_level;\n       current_binding_level = newlevel;\n-      keep_next_level_flag = 0;\n+      keep_next_level_flag  = false;\n     }\n }\n \n@@ -496,7 +486,27 @@ poplevel (int keep, int reverse, int functionbody)\n      containing functions.  */\n   for (link = decls; link; link = TREE_CHAIN (link))\n     {\n-      if (DECL_NAME (link) != 0)\n+      if (TREE_CODE (link) == LABEL_DECL)\n+\t{\n+\t  if (TREE_USED (link) && DECL_INITIAL (link) == 0)\n+\t    {\n+\t      error (\"%Hlabel `%D' used but not defined\",\n+\t\t     &DECL_SOURCE_LOCATION (link), link);\n+\t      /* Avoid crashing later.  */\n+\t      DECL_INITIAL (link) = error_mark_node;\n+\t    }\n+\t  else if (!TREE_USED (link) && warn_unused_label)\n+\t    {\n+\t      if (DECL_INITIAL (link) != 0)\n+\t\twarning (\"%Hlabel `%D' defined but not used\",\n+\t\t\t &DECL_SOURCE_LOCATION (link), link);\n+\t      else\n+\t\twarning (\"%Hlabel `%D' declared but not defined\",\n+\t\t\t &DECL_SOURCE_LOCATION (link), link);\n+\t    }\n+\t  IDENTIFIER_LABEL_VALUE (DECL_NAME (link)) = 0;\n+\t}\n+      else if (DECL_NAME (link) != 0)\n \t{\n \t  if (DECL_EXTERNAL (link) \n \t      && current_binding_level != global_binding_level)\n@@ -521,11 +531,14 @@ poplevel (int keep, int reverse, int functionbody)\n     if (TREE_PURPOSE (link))\n       IDENTIFIER_TAG_VALUE (TREE_PURPOSE (link)) = 0;\n \n-  /* Restore all name-meanings of the outer levels\n+  /* Restore all name- and label-meanings of the outer levels\n      that were shadowed by this level.  */\n \n   for (link = current_binding_level->shadowed; link; link = TREE_CHAIN (link))\n-    IDENTIFIER_SYMBOL_VALUE (TREE_PURPOSE (link)) = TREE_VALUE (link);\n+    if (TREE_VALUE (link) && TREE_CODE (TREE_VALUE (link)) == LABEL_DECL)\n+      IDENTIFIER_LABEL_VALUE (TREE_PURPOSE (link)) = TREE_VALUE (link);\n+    else\n+      IDENTIFIER_SYMBOL_VALUE (TREE_PURPOSE (link)) = TREE_VALUE (link);\n \n   /* Restore all tag-meanings of the outer levels\n      that were shadowed by this level.  */\n@@ -599,38 +612,8 @@ poplevel (int keep, int reverse, int functionbody)\n     for (link = tags; link; link = TREE_CHAIN (link))\n       TYPE_CONTEXT (TREE_VALUE (link)) = decl;\n \n-  /* If the level being exited is the top level of a function, check\n-     over all the labels, and clear out the current (function local)\n-     meanings of their names. Then add them to BLOCK_VARS.  */\n-\n-  if (functionbody)\n-    {\n-      for (link = named_labels; link; link = TREE_CHAIN (link))\n-\t{\n-\t  tree label = TREE_VALUE (link);\n-\n-\t  if (DECL_INITIAL (label) == 0)\n-\t    {\n-\t      error (\"%Hlabel '%D' used but not defined\",\n-                     &DECL_SOURCE_LOCATION (label), label);\n-\t      /* Avoid crashing later.  */\n-\t      define_label (input_location, DECL_NAME (label));\n-\t    }\n-\t  else if (warn_unused_label && !TREE_USED (label))\n-\t    warning (\"%Hlabel '%D' defined but not used\",\n-                     &DECL_SOURCE_LOCATION (label), label);\n-\t  IDENTIFIER_LABEL_VALUE (DECL_NAME (label)) = 0;\n-\n-\t  /* Put the labels into the \"variables\" of the\n-\t     top-level block, so debugger can see them.  */\n-\t  TREE_CHAIN (label) = BLOCK_VARS (block);\n-\t  BLOCK_VARS (block) = label;\n-\t}\n-    }\n-\n   /* Pop the current level, and free the structure for reuse.  */\n-\n-  pop_binding_level (&current_binding_level);\n+  pop_binding_level ();\n \n   /* Dispose of the block that we just made inside some higher level.  */\n   if (functionbody)\n@@ -671,77 +654,6 @@ set_block (tree block ATTRIBUTE_UNUSED)\n {\n }\n \f\n-void\n-push_label_level (void)\n-{\n-  struct binding_level *newlevel;\n-\n-  newlevel = make_binding_level ();\n-\n-  /* Add this level to the front of the chain (stack) of label levels.  */\n-\n-  newlevel->level_chain = label_level_chain;\n-  label_level_chain = newlevel;\n-\n-  newlevel->names = named_labels;\n-  newlevel->shadowed = shadowed_labels;\n-  named_labels = 0;\n-  shadowed_labels = 0;\n-}\n-\n-void\n-pop_label_level (void)\n-{\n-  struct binding_level *level = label_level_chain;\n-  tree link, prev;\n-\n-  /* Clear out the definitions of the declared labels in this level.\n-     Leave in the list any ordinary, non-declared labels.  */\n-  for (link = named_labels, prev = 0; link;)\n-    {\n-      if (C_DECLARED_LABEL_FLAG (TREE_VALUE (link)))\n-\t{\n-\t  if (DECL_SOURCE_LINE (TREE_VALUE (link)) == 0)\n-\t    {\n-\t      error (\"%Hlabel '%D' used but not defined\",\n-                     &DECL_SOURCE_LOCATION (TREE_VALUE (link)),\n-                     TREE_VALUE (link));\n-\t      /* Avoid crashing later.  */\n-\t      define_label (input_location, DECL_NAME (TREE_VALUE (link)));\n-\t    }\n-\t  else if (warn_unused_label && !TREE_USED (TREE_VALUE (link)))\n-\t    warning (\"%Hlabel '%D' defined but not used\",\n-                     &DECL_SOURCE_LOCATION (TREE_VALUE (link)),\n-                     TREE_VALUE (link));\n-\t  IDENTIFIER_LABEL_VALUE (DECL_NAME (TREE_VALUE (link))) = 0;\n-\n-\t  /* Delete this element from the list.  */\n-\t  link = TREE_CHAIN (link);\n-\t  if (prev)\n-\t    TREE_CHAIN (prev) = link;\n-\t  else\n-\t    named_labels = link;\n-\t}\n-      else\n-\t{\n-\t  prev = link;\n-\t  link = TREE_CHAIN (link);\n-\t}\n-    }\n-\n-  /* Bring back all the labels that were shadowed.  */\n-  for (link = shadowed_labels; link; link = TREE_CHAIN (link))\n-    if (DECL_NAME (TREE_VALUE (link)) != 0)\n-      IDENTIFIER_LABEL_VALUE (DECL_NAME (TREE_VALUE (link)))\n-\t= TREE_VALUE (link);\n-\n-  named_labels = chainon (named_labels, level->names);\n-  shadowed_labels = level->shadowed;\n-\n-  /* Pop the current level, and free the structure for reuse.  */\n-  pop_binding_level (&label_level_chain);\n-}\n-\f\n /* Push a definition or a declaration of struct, union or enum tag \"name\".\n    \"type\" should be the type node.\n    We assume that the tag \"name\" is not already defined.\n@@ -1631,7 +1543,7 @@ warn_if_shadowing (tree x, tree old)\n \t declarator in a declaration, as opposed to a definition,\n \t but there is no way to tell it's not a definition.  */\n       || (TREE_CODE (x) == PARM_DECL\n-\t  && current_binding_level->level_chain->parm_flag))\n+\t  && current_binding_level->outer->parm_flag))\n     return;\n \n   name = IDENTIFIER_POINTER (DECL_NAME (x));\n@@ -1864,13 +1776,7 @@ pushdecl_top_level (tree x)\n static void\n pushdecl_function_level (tree x, tree name)\n {\n-  struct binding_level *scope;\n-\n-  scope = current_binding_level;\n-  while (scope->function_body == 0)\n-    scope = scope->level_chain;\n-  if (!scope)\n-    abort ();\n+  struct binding_level *scope = current_function_level;\n \n   if (x == error_mark_node)\n     scope->shadowed = tree_cons (name, IDENTIFIER_SYMBOL_VALUE (name),\n@@ -2051,84 +1957,110 @@ undeclared_variable (tree id)\n     }\n }\n \f\n-/* Get the LABEL_DECL corresponding to identifier ID as a label.\n+/* Subroutine of lookup_label, declare_label, define_label: construct a\n+   LABEL_DECL with all the proper frills.  */\n+\n+static tree\n+make_label (tree name, location_t location)\n+{\n+  tree label = build_decl (LABEL_DECL, name, void_type_node);\n+\n+  DECL_CONTEXT (label) = current_function_decl;\n+  DECL_MODE (label) = VOIDmode;\n+  DECL_SOURCE_LOCATION (label) = location;\n+\n+  return label;\n+}\n+\n+/* Another subroutine of lookup_label, declare_label, define_label:\n+   set up the binding of name to LABEL_DECL in the given SCOPE.  */\n+\n+static void\n+bind_label (tree name, tree label, struct binding_level *scope)\n+{\n+  if (IDENTIFIER_LABEL_VALUE (name))\n+    scope->shadowed = tree_cons (name, IDENTIFIER_LABEL_VALUE (name),\n+\t\t\t\t scope->shadowed);\n+  IDENTIFIER_LABEL_VALUE (name) = label;\n+\n+  TREE_CHAIN (label) = scope->names;\n+  scope->names = label;\n+}\n+\n+/* Get the LABEL_DECL corresponding to identifier NAME as a label.\n    Create one if none exists so far for the current function.\n-   This function is called for both label definitions and label references.  */\n+   This is called when a label is used in a goto expression or\n+   has its address taken.  */\n \n tree\n-lookup_label (tree id)\n+lookup_label (tree name)\n {\n-  tree decl = IDENTIFIER_LABEL_VALUE (id);\n+  tree label;\n \n   if (current_function_decl == 0)\n     {\n       error (\"label %s referenced outside of any function\",\n-\t     IDENTIFIER_POINTER (id));\n+\t     IDENTIFIER_POINTER (name));\n       return 0;\n     }\n \n-  /* Use a label already defined or ref'd with this name.  */\n-  if (decl != 0)\n-    {\n-      /* But not if it is inherited and wasn't declared to be inheritable.  */\n-      if (DECL_CONTEXT (decl) != current_function_decl\n-\t  && ! C_DECLARED_LABEL_FLAG (decl))\n-\treturn shadow_label (id);\n-      return decl;\n+  /* Use a label already defined or ref'd with this name, but not if\n+     it is inherited from a containing function and wasn't declared\n+     using __label__.  */\n+  label = IDENTIFIER_LABEL_VALUE (name);\n+  if (label && (DECL_CONTEXT (label) == current_function_decl\n+\t\t|| C_DECLARED_LABEL_FLAG (label)))\n+    {\n+      /* If the label has only been declared, update its apparent\n+\t location to point here, for better diagnostics if it\n+\t turns out not to have been defined.  */\n+      if (!TREE_USED (label))\n+\tDECL_SOURCE_LOCATION (label) = input_location;\n+      return label;\n     }\n \n-  decl = build_decl (LABEL_DECL, id, void_type_node);\n-\n-  /* A label not explicitly declared must be local to where it's ref'd.  */\n-  DECL_CONTEXT (decl) = current_function_decl;\n-\n-  DECL_MODE (decl) = VOIDmode;\n+  /* No label binding for that identifier; make one.  */\n+  label = make_label (name, input_location);\n \n-  /* Say where one reference is to the label,\n-     for the sake of the error if it is not defined.  */\n-  DECL_SOURCE_LOCATION (decl) = input_location;\n-\n-  IDENTIFIER_LABEL_VALUE (id) = decl;\n-\n-  named_labels = tree_cons (NULL_TREE, decl, named_labels);\n-\n-  return decl;\n+  /* Ordinary labels go in the current function scope, which is\n+     not necessarily the current label scope.  */\n+  bind_label (name, label, current_function_level);\n+  return label;\n }\n \n-/* Make a label named NAME in the current function,\n-   shadowing silently any that may be inherited from containing functions\n-   or containing scopes.\n+/* Make a label named NAME in the current function, shadowing silently\n+   any that may be inherited from containing functions or containing\n+   scopes.  This is called for __label__ declarations.  */\n \n-   Note that valid use, if the label being shadowed\n-   comes from another scope in the same function,\n-   requires calling declare_nonlocal_label right away.  */\n+/* Note that valid use, if the label being shadowed comes from another\n+   scope in the same function, requires calling declare_nonlocal_label\n+   right away.  (Is this still true?  -zw 2003-07-17)  */\n \n tree\n-shadow_label (tree name)\n+declare_label (tree name)\n {\n-  tree decl = IDENTIFIER_LABEL_VALUE (name);\n+  tree label = IDENTIFIER_LABEL_VALUE (name);\n+  tree dup;\n \n-  if (decl != 0)\n-    {\n-      tree dup;\n+  /* Check to make sure that the label hasn't already been declared\n+     at this scope */\n+  for (dup = current_binding_level->names; dup; dup = TREE_CHAIN (dup))\n+    if (dup == label)\n+      {\n+\terror (\"duplicate label declaration `%s'\", IDENTIFIER_POINTER (name));\n+\terror (\"%Hthis is a previous declaration\",\n+\t       &DECL_SOURCE_LOCATION (dup));\n \n-      /* Check to make sure that the label hasn't already been declared\n-\t at this label scope */\n-      for (dup = named_labels; dup; dup = TREE_CHAIN (dup))\n-\tif (TREE_VALUE (dup) == decl)\n-\t  {\n-\t    error (\"duplicate label declaration '%E'\", name);\n-\t    error (\"%Hthis is a previous declaration\",\n-                   &DECL_SOURCE_LOCATION (TREE_VALUE (dup)));\n-\t    /* Just use the previous declaration.  */\n-\t    return lookup_label (name);\n-\t  }\n+\t/* Just use the previous declaration.  */\n+\treturn dup;\n+      }\n \n-      shadowed_labels = tree_cons (NULL_TREE, decl, shadowed_labels);\n-      IDENTIFIER_LABEL_VALUE (name) = decl = 0;\n-    }\n+  label = make_label (name, input_location);\n+  C_DECLARED_LABEL_FLAG (label) = 1;\n \n-  return lookup_label (name);\n+  /* Declared labels go in the current scope.  */\n+  bind_label (name, label, current_binding_level);\n+  return label;\n }\n \n /* Define a label, specifying the location in the source file.\n@@ -2138,33 +2070,54 @@ shadow_label (tree name)\n tree\n define_label (location_t location, tree name)\n {\n-  tree decl = lookup_label (name);\n-\n-  /* If label with this name is known from an outer context, shadow it.  */\n-  if (decl != 0 && DECL_CONTEXT (decl) != current_function_decl)\n-    {\n-      shadowed_labels = tree_cons (NULL_TREE, decl, shadowed_labels);\n-      IDENTIFIER_LABEL_VALUE (name) = 0;\n-      decl = lookup_label (name);\n+  tree label;\n+\n+  /* Find any preexisting label with this name.  It is an error\n+     if that label has already been defined in this function, or\n+     if there is a containing function with a declared label with\n+     the same name.  */\n+  label = IDENTIFIER_LABEL_VALUE (name);\n+\n+  if (label\n+      && ((DECL_CONTEXT (label) == current_function_decl\n+\t   && DECL_INITIAL (label) != 0)\n+\t  || (DECL_CONTEXT (label) != current_function_decl\n+\t      && C_DECLARED_LABEL_FLAG (label))))\n+    {\n+      error (\"%Hduplicate label `%D'\", &location, label);\n+      if (DECL_INITIAL (label))\n+\terror (\"%H`%D' previously defined here\",\n+\t       &DECL_SOURCE_LOCATION (label), label);\n+      else\n+\terror (\"%H`%D' previously declared here\",\n+\t       &DECL_SOURCE_LOCATION (label), label);\n+      return 0;\n     }\n-\n-  if (warn_traditional && !in_system_header && lookup_name (name))\n-    warning (\"%Htraditional C lacks a separate namespace for labels, \"\n-             \"identifier `%s' conflicts\", &location, IDENTIFIER_POINTER (name));\n-\n-  if (DECL_INITIAL (decl) != 0)\n+  else if (label && DECL_CONTEXT (label) == current_function_decl)\n     {\n-      error (\"%Hduplicate label `%s'\", &location, IDENTIFIER_POINTER (name));\n-      return 0;\n+      /* The label has been used or declared already in this function,\n+\t but not defined.  Update its location to point to this\n+\t definition.  */\n+      DECL_SOURCE_LOCATION (label) = location;\n     }\n   else\n     {\n-      /* Mark label as having been defined.  */\n-      DECL_INITIAL (decl) = error_mark_node;\n-      /* Say where in the source.  */\n-      DECL_SOURCE_LOCATION (decl) = location;\n-      return decl;\n+      /* No label binding for that identifier; make one.  */\n+      label = make_label (name, location);\n+\n+      /* Ordinary labels go in the current function scope, which is\n+\t not necessarily the current label scope.  */\n+      bind_label (name, label, current_function_level);\n     }\n+\n+  if (warn_traditional && !in_system_header && lookup_name (name))\n+    warning (\"%Htraditional C lacks a separate namespace for labels, \"\n+             \"identifier `%s' conflicts\", &location,\n+\t     IDENTIFIER_POINTER (name));\n+\n+  /* Mark label as having been defined.  */\n+  DECL_INITIAL (label) = error_mark_node;\n+  return label;\n }\n \f\n /* Return the list of declarations of the current level.\n@@ -2316,7 +2269,6 @@ c_init_decl_processing (void)\n   c_parse_init ();\n \n   current_function_decl = NULL;\n-  named_labels = NULL;\n   current_binding_level = NULL_BINDING_LEVEL;\n   free_binding_level = NULL_BINDING_LEVEL;\n \n@@ -5571,8 +5523,6 @@ start_function (tree declspecs, tree declarator, tree attributes)\n   current_function_returns_abnormally = 0;\n   warn_about_return_type = 0;\n   current_extern_inline = 0;\n-  named_labels = 0;\n-  shadowed_labels = 0;\n \n   /* Don't expand any sizes in the return type of the function.  */\n   immediate_size_expand = 0;\n@@ -6611,8 +6561,6 @@ check_for_loop_decls (void)\n struct language_function GTY(())\n {\n   struct c_language_function base;\n-  tree named_labels;\n-  tree shadowed_labels;\n   int returns_value;\n   int returns_null;\n   int returns_abnormally;\n@@ -6633,8 +6581,6 @@ c_push_function_context (struct function *f)\n \n   p->base.x_stmt_tree = c_stmt_tree;\n   p->base.x_scope_stmt_stack = c_scope_stmt_stack;\n-  p->named_labels = named_labels;\n-  p->shadowed_labels = shadowed_labels;\n   p->returns_value = current_function_returns_value;\n   p->returns_null = current_function_returns_null;\n   p->returns_abnormally = current_function_returns_abnormally;\n@@ -6649,13 +6595,6 @@ void\n c_pop_function_context (struct function *f)\n {\n   struct language_function *p = f->language;\n-  tree link;\n-\n-  /* Bring back all the labels that were shadowed.  */\n-  for (link = shadowed_labels; link; link = TREE_CHAIN (link))\n-    if (DECL_NAME (TREE_VALUE (link)) != 0)\n-      IDENTIFIER_LABEL_VALUE (DECL_NAME (TREE_VALUE (link)))\n-\t= TREE_VALUE (link);\n \n   if (DECL_SAVED_INSNS (current_function_decl) == 0\n       && DECL_SAVED_TREE (current_function_decl) == NULL_TREE)\n@@ -6669,8 +6608,6 @@ c_pop_function_context (struct function *f)\n \n   c_stmt_tree = p->base.x_stmt_tree;\n   c_scope_stmt_stack = p->base.x_scope_stmt_stack;\n-  named_labels = p->named_labels;\n-  shadowed_labels = p->shadowed_labels;\n   current_function_returns_value = p->returns_value;\n   current_function_returns_null = p->returns_null;\n   current_function_returns_abnormally = p->returns_abnormally;"}, {"sha": "a798ec3dc01b3d8e626aab3f6d75b50b02980635", "filename": "gcc/c-parse.in", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14e33ee85629ee9bfb7185eadb27a9066bb02687/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14e33ee85629ee9bfb7185eadb27a9066bb02687/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=14e33ee85629ee9bfb7185eadb27a9066bb02687", "patch": "@@ -664,8 +664,6 @@ primary:\n \n \t\t   if (pedantic)\n \t\t     pedwarn (\"ISO C forbids braced-groups within expressions\");\n-\t\t  pop_label_level ();\n-\n \t\t  saved_last_tree = COMPOUND_BODY ($1);\n \t\t  RECHAIN_STMTS ($1, COMPOUND_BODY ($1));\n \t\t  last_tree = saved_last_tree;\n@@ -677,7 +675,6 @@ primary:\n \t\t}\n \t| compstmt_primary_start error ')'\n \t\t{\n-\t\t  pop_label_level ();\n \t\t  last_tree = COMPOUND_BODY ($1);\n \t\t  TREE_CHAIN (last_tree) = NULL_TREE;\n \t\t  $$ = error_mark_node;\n@@ -2113,7 +2110,7 @@ label_decl:\n \t\t{ tree link;\n \t\t  for (link = $2; link; link = TREE_CHAIN (link))\n \t\t    {\n-\t\t      tree label = shadow_label (TREE_VALUE (link));\n+\t\t      tree label = declare_label (TREE_VALUE (link));\n \t\t      C_DECLARED_LABEL_FLAG (label) = 1;\n \t\t      add_decl_stmt (label);\n \t\t    }\n@@ -2158,7 +2155,6 @@ compstmt_primary_start:\n \t\t     there is a way to turn off the entire subtree of blocks\n \t\t     that are contained in it.  */\n \t\t  keep_next_level ();\n-\t\t  push_label_level ();\n \t\t  compstmt_count++;\n \t\t  $$ = add_stmt (build_stmt (COMPOUND_STMT, last_tree));\n \t\t}"}, {"sha": "fb12e7a8d00cd9aa04dab9e822e7b031e7b1fc34", "filename": "gcc/c-tree.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14e33ee85629ee9bfb7185eadb27a9066bb02687/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14e33ee85629ee9bfb7185eadb27a9066bb02687/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=14e33ee85629ee9bfb7185eadb27a9066bb02687", "patch": "@@ -197,6 +197,7 @@ extern void clear_parm_order (void);\n extern int  complete_array_type (tree, tree, int);\n extern void declare_parm_level (void);\n extern void undeclared_variable (tree);\n+extern tree declare_label (tree);\n extern tree define_label (location_t, tree);\n extern void finish_decl (tree, tree, tree);\n extern tree finish_enum (tree, tree, tree);\n@@ -214,13 +215,10 @@ extern void parmlist_tags_warning (void);\n extern void pending_xref_error (void);\n extern void c_push_function_context (struct function *);\n extern void c_pop_function_context (struct function *);\n-extern void pop_label_level (void);\n-extern void push_label_level (void);\n extern void push_parm_decl (tree);\n extern tree pushdecl_top_level (tree);\n extern void pushtag (tree, tree);\n extern tree set_array_declarator_type (tree, tree, int);\n-extern tree shadow_label (tree);\n extern void shadow_tag (tree);\n extern void shadow_tag_warned (tree, int);\n extern tree start_enum (tree);"}, {"sha": "6170978b1efce0d6dbb74db9e1c8c50e25b48425", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 35, "deletions": 15, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14e33ee85629ee9bfb7185eadb27a9066bb02687/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14e33ee85629ee9bfb7185eadb27a9066bb02687/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=14e33ee85629ee9bfb7185eadb27a9066bb02687", "patch": "@@ -424,7 +424,7 @@ extensions, accepted by GCC in C89 mode and in C++.\n \n @menu\n * Statement Exprs::     Putting statements and declarations inside expressions.\n-* Local Labels::        Labels local to a statement-expression.\n+* Local Labels::        Labels local to a block.\n * Labels as Values::    Getting pointers to labels, and computed gotos.\n * Nested Functions::    As in Algol and Pascal, lexical scoping of functions.\n * Constructing Calls::\tDispatching a call to another function.\n@@ -577,10 +577,10 @@ bug.)\n @cindex local labels\n @cindex macros, local labels\n \n-Each statement expression is a scope in which @dfn{local labels} can be\n-declared.  A local label is simply an identifier; you can jump to it\n-with an ordinary @code{goto} statement, but only from within the\n-statement expression it belongs to.\n+GCC allows you to declare @dfn{local labels} in any nested block\n+scope. A local label is just like an ordinary label, but you can\n+only reference it (with a @code{goto} statement, or by taking its\n+address) within the block in which it was declared.  \n \n A local label declaration looks like this:\n \n@@ -595,21 +595,38 @@ or\n __label__ @var{label1}, @var{label2}, /* @r{@dots{}} */;\n @end example\n \n-Local label declarations must come at the beginning of the statement\n-expression, right after the @samp{(@{}, before any ordinary\n-declarations.\n+Local label declarations must come at the beginning of the block,\n+before any ordinary declarations or statements.\n \n The label declaration defines the label @emph{name}, but does not define\n the label itself.  You must do this in the usual way, with\n @code{@var{label}:}, within the statements of the statement expression.\n \n-The local label feature is useful because statement expressions are\n-often used in macros.  If the macro contains nested loops, a @code{goto}\n-can be useful for breaking out of them.  However, an ordinary label\n-whose scope is the whole function cannot be used: if the macro can be\n-expanded several times in one function, the label will be multiply\n-defined in that function.  A local label avoids this problem.  For\n-example:\n+The local label feature is useful for complex macros.  If a macro\n+contains nested loops, a @code{goto} can be useful for breaking out of\n+them.  However, an ordinary label whose scope is the whole function\n+cannot be used: if the macro can be expanded several times in one\n+function, the label will be multiply defined in that function.  A\n+local label avoids this problem.  For example:\n+\n+@example\n+#define SEARCH(value, array, target)              \\\n+do @{                                              \\\n+  __label__ found;                                \\\n+  typeof (target) _SEARCH_target = (target);      \\\n+  typeof (*(array)) *_SEARCH_array = (array);     \\\n+  int i, j;                                       \\\n+  int value;                                      \\\n+  for (i = 0; i < max; i++)                       \\\n+    for (j = 0; j < max; j++)                     \\\n+      if (_SEARCH_array[i][j] == _SEARCH_target)  \\\n+        @{ (value) = i; goto found; @}              \\\n+  (value) = -1;                                   \\\n+ found:;                                          \\\n+@} while (0)\n+@end example\n+\n+This could also be written using a statement-expression:\n \n @example\n #define SEARCH(array, target)                     \\\n@@ -629,6 +646,9 @@ example:\n @})\n @end example\n \n+Local label declarations also make the labels they declare visible to\n+nested functions, if there are any.  @xref{Nested Functions}, for details.\n+\n @node Labels as Values\n @section Labels as Values\n @cindex labels as values"}, {"sha": "8407b0d9bf24cac45be119bd1a231fd6ba14e070", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14e33ee85629ee9bfb7185eadb27a9066bb02687/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14e33ee85629ee9bfb7185eadb27a9066bb02687/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=14e33ee85629ee9bfb7185eadb27a9066bb02687", "patch": "@@ -1,10 +1,17 @@\n+2003-07-19  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* gcc.dg/noncompile/label-1.c: New comprehensive test case for\n+\tdiagnostics of ill-formed constructs involving labels.\n+\t* gcc.dg/noncompile/label-lineno-1.c: Add error regexp for\n+\tthe new 'previously defined here' message.\n+\n 2003-07-18  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* g++.dg/parse/non-dependent2.C: New test.\n \n 2003-07-18  Andrew Pinski  <pinskia@physics.uc.edu>\n \n-\t* g++.dg/init/init-ref4.C: xfail on targets without \n+\t* g++.dg/init/init-ref4.C: xfail on targets without\n \tweak symbols.\n \n 2003-07-17  Jakub Jelinek  <jakub@redhat.com>\n@@ -278,15 +285,15 @@\n \t* g++.dg/opt/emptyunion.C: New testcase.\n \n 2003-07-07  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n-            Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\t    Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \t* g++.dg/opt/stack1.C: New test.\n \n 2003-07-05  Mark Mitchell  <mark@codesourcery.com>\n \n \t* g++.old-deja/g++.jason/typeid1.C: Make it a compile test, not a\n \trun test.\n-\t\n+\n \tPR c++/11431\n \t* g++.dg/expr/static_cast3.C: New test.\n "}, {"sha": "c646b48fb8d4f2d0b9fef6db0ce665aad9eb0797", "filename": "gcc/testsuite/gcc.dg/noncompile/label-1.c", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14e33ee85629ee9bfb7185eadb27a9066bb02687/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2Flabel-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14e33ee85629ee9bfb7185eadb27a9066bb02687/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2Flabel-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2Flabel-1.c?ref=14e33ee85629ee9bfb7185eadb27a9066bb02687", "patch": "@@ -0,0 +1,175 @@\n+/* Test various diagnostics of ill-formed constructs involving labels.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wunused\" } */\n+\n+extern void dummy(void);\n+\n+/* labels must be defined */\n+void a(void)\n+{\n+  goto l;   /* { dg-error \"used but not defined\" \"no label\" } */\n+}\n+\n+/* warnings for labels defined but not used, or declared but not defined */\n+void b(void)\n+{\n+  __label__ l;\n+ l:  /* { dg-warning \"defined but not used\"  \"no goto 1\" } */\n+ m:  /* { dg-warning \"defined but not used\"  \"no goto 2\" } */\n+  dummy();\n+}\n+\n+void c(void)\n+{\n+  __label__ l;  /* { dg-warning \"declared but not defined\" \"only __label__\" } */\n+  dummy();\n+}\n+\n+/* can't have two labels with the same name in the same function */\n+void d(void)\n+{\n+ l: dummy();  /* { dg-error \"previously defined\" \"prev def same scope\" } */\n+ l: dummy();  /* { dg-error \"duplicate label\" \"dup label same scope\" } */\n+ goto l;\n+}\n+\n+/* even at different scopes */\n+void e(void)\n+{\n+ l: dummy();\t/* { dg-error \"previously defined\"  \"prev def diff scope\" } */\n+  {\n+  l: dummy();\t/* { dg-error \"duplicate label\" \"dup label diff scope\" } */\n+  }\n+  goto l;\n+}\n+\n+/* but, with __label__, you can */\n+void f(void)\n+{\n+ l: dummy();\n+  {\n+    __label__ l;\n+    l: dummy();\t  /* { dg-warning \"defined but not used\" \"unused shadow 1\" } */\n+  };\n+  goto l;  /* this reaches the outer l */\n+}\n+\n+/* a __label__ is not visible outside its scope */\n+void g(void)\n+{\n+  dummy();\n+  {\n+    __label__ l;\n+    l: dummy();\n+    goto l;\n+  }\n+  goto l;  /* { dg-error \"used but not defined\" \"label ref out of scope\" } */\n+}\n+\n+/* __label__ can appear at top level of a function, too...\n+   ... but doesn't provide a definition of the label */\n+void h(void)\n+{\n+  __label__ l;\n+  dummy ();\n+\n+  goto l;  /* { dg-error \"used but not defined\" \"used, only __label__\" } */\n+}\n+\n+/* A nested function may not goto a label outside itself  */\n+void i(void)\n+{\n+  auto void nest(void);\n+\n+ l: nest();\n+  \n+  void nest(void)\n+    {\n+      goto l;  /* { dg-error \"used but not defined\" \"nest use outer label\" } */\n+    }\n+\n+  goto l; /* reaches the outer l */\n+}\n+\n+/* which means that a nested function may have its own label with the\n+   same name as the outer function */\n+void j(void)\n+{\n+  auto void nest(void);\n+\n+ l: nest();\n+  \n+  void nest(void)\n+    {\n+    l: dummy(); /* { dg-warning \"defined but not used\" \"nest label same name\" } */\n+    }\n+\n+  goto l; /* reaches the outer l */\n+}\n+\n+/* and, turnabout, an outer function may not goto a label in a nested\n+   function */\n+void k(void)\n+{\n+  void nest(void)\n+  {\n+  l: dummy();  /* { dg-warning \"defined but not used\" \"outer use nest label\" } */\n+  }\n+\n+  goto l; /* { dg-error \"used but not defined\" \"outer use nest label\" } */\n+  nest();\n+}\n+\n+/* not even with __label__ */\n+void l(void)\n+{\n+  void nest(void)\n+  {\n+    __label__ l;\n+  l: dummy(); /* { dg-warning \"defined but not used\" \"outer use nest __label__\" } */\n+  }\n+\n+  goto l; /* { dg-error \"used but not defined\" \"outer use nest __label__\" } */\n+  nest();\n+}\n+\n+\n+/* but if the outer label is declared with __label__, then a nested\n+   function can goto that label (accomplishing a longjmp) */\n+void m(void)\n+{\n+  __label__ l;\n+  void nest(void) { goto l; }\n+  nest();\n+  dummy();\n+ l:;\n+}\n+\n+/* and that means the nested function cannot have its own label with\n+   the same name as an outer label declared with __label__ */\n+\n+void n(void)\n+{\n+  __label__ l; /* { dg-error \"previously declared\" \"outer label decl\" } */\n+  void nest(void)\n+    {\n+    l: goto l;  /* { dg-error \"duplicate label\" \"inner label defn\" } */\n+    }\n+\n+ l:\n+  nest();\n+}\n+\n+/* unless the nested function uses __label__ too!  */\n+void o(void)\n+{\n+  __label__ l;\n+  void nest(void)\n+    {\n+      __label__ l;\n+    l: goto l;\n+    }\n+\n+ l: goto l;\n+ nest();\n+}"}, {"sha": "0c5599434f8bd51cfb7e6aada26aa69fd940431d", "filename": "gcc/testsuite/gcc.dg/noncompile/label-lineno-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14e33ee85629ee9bfb7185eadb27a9066bb02687/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2Flabel-lineno-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14e33ee85629ee9bfb7185eadb27a9066bb02687/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2Flabel-lineno-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2Flabel-lineno-1.c?ref=14e33ee85629ee9bfb7185eadb27a9066bb02687", "patch": "@@ -4,7 +4,7 @@\n void\n foo(int i)\n {\n- my_label:\n+ my_label: /* { dg-error \"previously defined\" \"prev label\" } */\n \n   i++;\n "}]}