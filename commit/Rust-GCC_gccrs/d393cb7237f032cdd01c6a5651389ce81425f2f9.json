{"sha": "d393cb7237f032cdd01c6a5651389ce81425f2f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDM5M2NiNzIzN2YwMzJjZGQwMWM2YTU2NTEzODljZTgxNDI1ZjJmOQ==", "commit": {"author": {"name": "Andrew Haley", "email": "aph@redhat.com", "date": "2005-04-19T09:52:21Z"}, "committer": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "2005-04-19T09:52:21Z"}, "message": "java-except.h (struct eh_range.handler): Remove unused field.\n\n2005-04-18  Andrew Haley  <aph@redhat.com>\n\n        * java-except.h (struct eh_range.handler): Remove unused field.\n        (handle_nested_ranges): Remove function declaration.\n        (sanity_check_exception_range): Add function declaration.\n        * verify.c (verify_jvm_instructions): Remove call to\n        handle_nested_ranges.\n        * verify-glue.c (verify_jvm_instructions_new): Call\n        sanity_check_exception_range.\n        * except.c (link_handler, eh_range_freelist, link_handler,\n        handle_nested_ranges): Remove.\n        (add_handler): Rewrite.\n        (sanity_check_exception_range): New function.\n        (print_ranges): New function.\n\nFrom-SVN: r98395", "tree": {"sha": "836b88c9526b99768601100742ece64545d0bd34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/836b88c9526b99768601100742ece64545d0bd34"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d393cb7237f032cdd01c6a5651389ce81425f2f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d393cb7237f032cdd01c6a5651389ce81425f2f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d393cb7237f032cdd01c6a5651389ce81425f2f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d393cb7237f032cdd01c6a5651389ce81425f2f9/comments", "author": {"login": "theRealAph", "id": 254637, "node_id": "MDQ6VXNlcjI1NDYzNw==", "avatar_url": "https://avatars.githubusercontent.com/u/254637?v=4", "gravatar_id": "", "url": "https://api.github.com/users/theRealAph", "html_url": "https://github.com/theRealAph", "followers_url": "https://api.github.com/users/theRealAph/followers", "following_url": "https://api.github.com/users/theRealAph/following{/other_user}", "gists_url": "https://api.github.com/users/theRealAph/gists{/gist_id}", "starred_url": "https://api.github.com/users/theRealAph/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/theRealAph/subscriptions", "organizations_url": "https://api.github.com/users/theRealAph/orgs", "repos_url": "https://api.github.com/users/theRealAph/repos", "events_url": "https://api.github.com/users/theRealAph/events{/privacy}", "received_events_url": "https://api.github.com/users/theRealAph/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8a5691f87d716bf662a68dc290925f1d52ab3435", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a5691f87d716bf662a68dc290925f1d52ab3435", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a5691f87d716bf662a68dc290925f1d52ab3435"}], "stats": {"total": 354, "additions": 207, "deletions": 147}, "files": [{"sha": "ae97ad0b20407580231547838b146acfeacbcb11", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393cb7237f032cdd01c6a5651389ce81425f2f9/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393cb7237f032cdd01c6a5651389ce81425f2f9/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=d393cb7237f032cdd01c6a5651389ce81425f2f9", "patch": "@@ -1,3 +1,18 @@\n+2005-04-18  Andrew Haley  <aph@redhat.com>\n+\n+\t* java-except.h (struct eh_range.handler): Remove unused field.\n+\t(handle_nested_ranges): Remove function declaration.\n+\t(sanity_check_exception_range): Add function declaration.\t\n+\t* verify.c (verify_jvm_instructions): Remove call to\n+\thandle_nested_ranges.\n+\t* verify-glue.c (verify_jvm_instructions_new): Call\n+\tsanity_check_exception_range.\n+\t* except.c (link_handler, eh_range_freelist, link_handler,\n+\thandle_nested_ranges): Remove.\n+\t(add_handler): Rewrite.\n+\t(sanity_check_exception_range): New function.\n+\t(print_ranges): New function.\n+\n 2005-04-13  Julian Brown  <julian@codesourcery.com>\n \n \t* decl.c (finish_method): Give methods once-only linkage."}, {"sha": "d181517ca064de2a16de774099dff0da24d6aae5", "filename": "gcc/java/except.c", "status": "modified", "additions": 190, "deletions": 142, "changes": 332, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393cb7237f032cdd01c6a5651389ce81425f2f9/gcc%2Fjava%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393cb7237f032cdd01c6a5651389ce81425f2f9/gcc%2Fjava%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexcept.c?ref=d393cb7237f032cdd01c6a5651389ce81425f2f9", "patch": "@@ -1,5 +1,5 @@\n /* Handle exceptions for GNU compiler for the Java(TM) language.\n-   Copyright (C) 1997, 1998, 1999, 2000, 2002, 2003, 2004\n+   Copyright (C) 1997, 1998, 1999, 2000, 2002, 2003, 2004, 2005\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -42,16 +42,13 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n static void expand_start_java_handler (struct eh_range *);\n static struct eh_range *find_handler_in_range (int, struct eh_range *,\n \t\t\t\t\t       struct eh_range *);\n-static void link_handler (struct eh_range *, struct eh_range *);\n static void check_start_handlers (struct eh_range *, int);\n static void free_eh_ranges (struct eh_range *range);\n \n struct eh_range *current_method_handlers;\n \n struct eh_range *current_try_block = NULL;\n \n-struct eh_range *eh_range_freelist = NULL;\n-\n /* These variables are used to speed up find_handler. */\n \n static int cache_range_start, cache_range_end;\n@@ -62,12 +59,60 @@ static struct eh_range *cache_next_child;\n \n struct eh_range whole_range;\n \n+/* Check the invariants of the structure we're using to contain\n+   exception regions.  Either returns true or fails an assertion\n+   check.  */\n+\n+bool\n+sanity_check_exception_range (struct eh_range *range)\n+{\n+  struct eh_range *ptr = range->first_child;\n+  for (; ptr; ptr = ptr->next_sibling)\n+    {\n+      gcc_assert (ptr->outer == range\n+\t\t  && ptr->end_pc > ptr->start_pc);\n+      if (ptr->next_sibling)\n+\tgcc_assert (ptr->next_sibling->start_pc >= ptr->end_pc);\n+      gcc_assert (ptr->start_pc >= ptr->outer->start_pc\n+\t\t  && ptr->end_pc <=  ptr->outer->end_pc);\n+      (void) sanity_check_exception_range (ptr);\n+    }\n+  return true;\n+}\n+\n #if defined(DEBUG_JAVA_BINDING_LEVELS)\n-extern int binding_depth;\n extern int is_class_level;\n extern int current_pc;\n-extern void indent ();\n+extern int binding_depth;\n+extern void indent (void);\n+static void\n+print_ranges (struct eh_range *range)\n+{\n+  if (! range)\n+    return;\n \n+  struct eh_range *child = range->first_child;\n+  \n+  indent ();\n+  fprintf (stderr, \"handler pc %d --> %d \", range->start_pc, range->end_pc);\n+  \n+  tree handler = range->handlers;\n+  for ( ; handler != NULL_TREE; handler = TREE_CHAIN (handler))\n+    {\n+      tree type = TREE_PURPOSE (handler);\n+      if (type == NULL)\n+\ttype = throwable_type_node;\n+      fprintf (stderr, \" type=%s \", IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type))));\n+    }\n+  fprintf (stderr, \"\\n\");\n+\n+  int saved = binding_depth;\n+  binding_depth++;\n+  print_ranges (child);\n+  binding_depth = saved;\n+\n+  print_ranges (range->next_sibling);\n+}\n #endif\n \n /* Search for the most specific eh_range containing PC.\n@@ -117,114 +162,6 @@ find_handler (int pc)\n   return find_handler_in_range (pc, h, cache_next_child);\n }\n \n-/* Recursive helper routine for check_nested_ranges. */\n-\n-static void\n-link_handler (struct eh_range *range, struct eh_range *outer)\n-{\n-  struct eh_range **ptr;\n-\n-  if (range->start_pc == outer->start_pc && range->end_pc == outer->end_pc)\n-    {\n-      outer->handlers = chainon (outer->handlers, range->handlers);\n-      return;\n-    }\n-\n-  /* If the new range completely encloses the `outer' range, then insert it\n-     between the outer range and its parent.  */\n-  if (range->start_pc <= outer->start_pc && range->end_pc >= outer->end_pc)\n-    {\n-      range->outer = outer->outer;\n-      range->next_sibling = NULL;\n-      range->first_child = outer;\n-      {\n-\tstruct eh_range *p = outer;\n-\tstruct eh_range **pr = &(outer->outer->first_child);\n-\twhile (*pr != outer)\n-\t  pr = &(*pr)->next_sibling;\n-\t*pr = range;\n-\n-\twhile (p)\n-\t  {\n-\t    p->outer = range;\n-\t    p = p->next_sibling;\n-\t  }\n-      }\n-      return;\n-    }\n-\n-  /* Handle overlapping ranges by splitting the new range.  */\n-  if (range->start_pc < outer->start_pc || range->end_pc > outer->end_pc)\n-    {\n-      struct eh_range *h = xmalloc (sizeof (struct eh_range));\n-      if (range->start_pc < outer->start_pc)\n-\t{\n-\t  h->start_pc = range->start_pc;\n-\t  h->end_pc = outer->start_pc;\n-\t  range->start_pc = outer->start_pc;\n-\t}\n-      else\n-\t{\n-\t  h->start_pc = outer->end_pc;\n-\t  h->end_pc = range->end_pc;\n-\t  range->end_pc = outer->end_pc;\n-\t}\n-      h->first_child = NULL;\n-      h->outer = NULL;\n-      h->handlers = build_tree_list (TREE_PURPOSE (range->handlers),\n-\t\t\t\t     TREE_VALUE (range->handlers));\n-      h->next_sibling = NULL;\n-      h->expanded = 0;\n-      h->stmt = NULL;\n-      /* Restart both from the top to avoid having to make this\n-\t function smart about reentrancy.  */\n-      link_handler (h, &whole_range);\n-      link_handler (range, &whole_range);\n-      return;\n-    }\n-\n-  ptr = &outer->first_child;\n-  for (;; ptr = &(*ptr)->next_sibling)\n-    {\n-      if (*ptr == NULL || range->end_pc <= (*ptr)->start_pc)\n-\t{\n-\t  range->next_sibling = *ptr;\n-\t  range->first_child = NULL;\n-\t  range->outer = outer;\n-\t  *ptr = range;\n-\t  return;\n-\t}\n-      else if (range->start_pc < (*ptr)->end_pc)\n-\t{\n-\t  link_handler (range, *ptr);\n-\t  return;\n-\t}\n-      /* end_pc > (*ptr)->start_pc && start_pc >= (*ptr)->end_pc. */\n-    }\n-}\n-\n-/* The first pass of exception range processing (calling add_handler)\n-   constructs a linked list of exception ranges.  We turn this into\n-   the data structure expected by the rest of the code, and also\n-   ensure that exception ranges are properly nested.  */\n-\n-void\n-handle_nested_ranges (void)\n-{\n-  struct eh_range *ptr, *next;\n-\n-  ptr = whole_range.first_child;\n-  whole_range.first_child = NULL;\n-  for (; ptr; ptr = next)\n-    {\n-      next = ptr->next_sibling;\n-      ptr->next_sibling = NULL;\n-      link_handler (ptr, &whole_range);\n-    }\n-}\n-\n-/* Free RANGE as well as its children and siblings.  */\n-\n static void\n free_eh_ranges (struct eh_range *range)\n {\n@@ -252,55 +189,166 @@ method_init_exceptions (void)\n   cache_range_start = 0xFFFFFF;\n }\n \n-/* Add an exception range.  If we already have an exception range\n-   which has the same handler and label, and the new range overlaps\n-   that one, then we simply extend the existing range.  Some bytecode\n-   obfuscators generate seemingly nonoverlapping exception ranges\n-   which, when coalesced, do in fact nest correctly.\n-   \n-   This constructs an ordinary linked list which check_nested_ranges()\n-   later turns into the data structure we actually want.\n+/* Split an exception range into two at PC.  The sub-ranges that\n+   belong to the range are split and distributed between the two new\n+   ranges.  */\n+\n+static void\n+split_range (struct eh_range *range, int pc)\n+{\n+  struct eh_range *ptr;\n+  struct eh_range **first_child, **second_child;\n+  struct eh_range *h;\n+\n+  /* First, split all the sub-ranges.  */\n+  for (ptr = range->first_child; ptr; ptr = ptr->next_sibling)\n+    {\n+      if (pc > ptr->start_pc\n+\t  && pc < ptr->end_pc)\n+\t{\n+\t  split_range (ptr, pc);\n+\t}\n+    }\n+\n+  /* Create a new range.  */\n+  h = xmalloc (sizeof (struct eh_range));\n+\n+  h->start_pc = pc;\n+  h->end_pc = range->end_pc;\n+  h->next_sibling = range->next_sibling;\n+  range->next_sibling = h;\n+  range->end_pc = pc;\n+  h->handlers = build_tree_list (TREE_PURPOSE (range->handlers),\n+\t\t\t\t TREE_VALUE (range->handlers));\n+  h->next_sibling = NULL;\n+  h->expanded = 0;\n+  h->stmt = NULL;\n+  h->outer = range->outer;\n+  h->first_child = NULL;\n+\n+  ptr = range->first_child;\n+  first_child = &range->first_child;\n+  second_child = &h->first_child;\n+\n+  /* Distribute the sub-ranges bewteen the two new ranges.  */\n+  for (ptr = range->first_child; ptr; ptr = ptr->next_sibling)\n+    {\n+      if (ptr->start_pc < pc)\n+\t{\n+\t  *first_child = ptr;\n+\t  ptr->outer = range;\n+\t  first_child = &ptr->next_sibling;\n+\t}\n+      else\n+\t{\n+\t  *second_child = ptr;\n+\t  ptr->outer = h;\n+\t  second_child = &ptr->next_sibling;\n+\t}\n+    }\n+  *first_child = NULL;\n+  *second_child = NULL;\n+}  \n+\n+\n+/* Add an exception range. \n+\n+   There are some missed optimization opportunities here.  For\n+   example, some bytecode obfuscators generate seemingly\n+   nonoverlapping exception ranges which, when coalesced, do in fact\n+   nest correctly.  We could merge these, but we'd have to fix up all\n+   the enclosed regions first and perhaps create a new range anyway if\n+   it overlapped existing ranges.\n    \n-   We expect the input to come in order of increasing START_PC.  This\n-   function doesn't attempt to detect the case where two previously\n-   added disjoint ranges could be coalesced by a new range; that is\n-   what the sorting counteracts.  */\n+   Also, we don't attempt to detect the case where two previously\n+   added disjoint ranges could be coalesced by a new range.  */\n \n-void\n+void \n add_handler (int start_pc, int end_pc, tree handler, tree type)\n {\n-  struct eh_range *ptr, *prev = NULL, *h;\n+  struct eh_range *ptr, *h;\n+  struct eh_range **first_child, **prev;\n \n+  /* First, split all the existing ranges that we need to enclose.  */\n   for (ptr = whole_range.first_child; ptr; ptr = ptr->next_sibling)\n     {\n-      if (start_pc >= ptr->start_pc\n-\t  && start_pc <= ptr->end_pc\n-\t  && TREE_PURPOSE (ptr->handlers) == type\n-\t  && TREE_VALUE (ptr->handlers) == handler)\n+      if (start_pc > ptr->start_pc\n+\t  && start_pc < ptr->end_pc)\n+\t{\n+\t  split_range (ptr, start_pc);\n+\t}\n+\n+      if (end_pc > ptr->start_pc\n+\t  && end_pc < ptr->end_pc)\n \t{\n-\t  /* Already found an overlapping range, so coalesce.  */\n-\t  ptr->end_pc = MAX (ptr->end_pc, end_pc);\n-\t  return;\n+\t  split_range (ptr, end_pc);\n \t}\n-      prev = ptr;\n+\n+      if (ptr->start_pc >= end_pc)\n+\tbreak;\n     }\n \n+  /* Create the new range.  */\n   h = xmalloc (sizeof (struct eh_range));\n+  first_child = &h->first_child;\n+\n   h->start_pc = start_pc;\n   h->end_pc = end_pc;\n   h->first_child = NULL;\n-  h->outer = NULL;\n+  h->outer = NULL_EH_RANGE;\n   h->handlers = build_tree_list (type, handler);\n   h->next_sibling = NULL;\n   h->expanded = 0;\n   h->stmt = NULL;\n \n-  if (prev == NULL)\n-    whole_range.first_child = h;\n-  else\n-    prev->next_sibling = h;\n-}\n+  /* Find every range at the top level that will be a sub-range of the\n+     range we're inserting and make it so.  */\n+  {\n+    struct eh_range **prev = &whole_range.first_child;\n+    for (ptr = *prev; ptr;)\n+      {\n+\tstruct eh_range *next = ptr->next_sibling;\n+\n+\tif (ptr->start_pc >= end_pc)\n+\t  break;\n \n+\tif (ptr->start_pc < start_pc)\n+\t  {\n+\t    prev = &ptr->next_sibling;\n+\t  }\n+\telse if (ptr->start_pc >= start_pc\n+\t\t && ptr->start_pc < end_pc)\n+\t  {\n+\t    *prev = next;\n+\t    *first_child = ptr;\n+\t    first_child = &ptr->next_sibling;\n+\t    ptr->outer = h;\n+\t    ptr->next_sibling = NULL;\t  \n+\t  }\n+\n+\tptr = next;\n+      }\n+  }\n+\n+  /* Find the right place to insert the new range.  */\n+  prev = &whole_range.first_child;\n+  for (ptr = *prev; ptr; prev = &ptr->next_sibling, ptr = ptr->next_sibling)\n+    {\n+      gcc_assert (ptr->outer == NULL_EH_RANGE);\n+      if (ptr->start_pc >= start_pc)\n+\tbreak;\n+    }\n+\n+  /* And insert it there.  */\n+  *prev = h;\n+  if (ptr)\n+    {\n+      h->next_sibling = ptr;\n+      h->outer = ptr->outer;\n+    }\n+}\n+      \n+  \n /* if there are any handlers for this range, issue start of region */\n static void\n expand_start_java_handler (struct eh_range *range)"}, {"sha": "7c26cab440763fc3da06fa0274e1c45afd9ae87b", "filename": "gcc/java/java-except.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393cb7237f032cdd01c6a5651389ce81425f2f9/gcc%2Fjava%2Fjava-except.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393cb7237f032cdd01c6a5651389ce81425f2f9/gcc%2Fjava%2Fjava-except.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-except.h?ref=d393cb7237f032cdd01c6a5651389ce81425f2f9", "patch": "@@ -54,8 +54,6 @@ struct eh_range\n \n     /* The TRY_CATCH_EXPR for this EH range.  */\n     tree stmt;\n-\n-    tree handler;\n   };\n \n /* A dummy range that represents the entire method. */\n@@ -67,5 +65,5 @@ extern struct eh_range * find_handler (int);\n extern void method_init_exceptions (void);\n extern void maybe_start_try (int, int);\n extern void add_handler (int, int, tree, tree);\n-extern void handle_nested_ranges (void);\n extern void expand_end_java_handler (struct eh_range *);\n+extern bool sanity_check_exception_range (struct eh_range *);"}, {"sha": "b8eed71736e0abcd85f2a5e1bf88bc013d969751", "filename": "gcc/java/verify-glue.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393cb7237f032cdd01c6a5651389ce81425f2f9/gcc%2Fjava%2Fverify-glue.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393cb7237f032cdd01c6a5651389ce81425f2f9/gcc%2Fjava%2Fverify-glue.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fverify-glue.c?ref=d393cb7237f032cdd01c6a5651389ce81425f2f9", "patch": "@@ -487,7 +487,7 @@ verify_jvm_instructions_new (JCF *jcf, const unsigned char *byte_ops,\n       instruction_bits[handler_pc] |= BCODE_EXCEPTION_TARGET;\n     }\n \n-  handle_nested_ranges ();\n+  gcc_assert (sanity_check_exception_range (&whole_range));\n \n   method.method = current_function_decl;\n   method.signature = build_java_signature (TREE_TYPE (current_function_decl));"}, {"sha": "6f947834189cc0d91a58475345a9456b4bf39b5a", "filename": "gcc/java/verify.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393cb7237f032cdd01c6a5651389ce81425f2f9/gcc%2Fjava%2Fverify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393cb7237f032cdd01c6a5651389ce81425f2f9/gcc%2Fjava%2Fverify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fverify.c?ref=d393cb7237f032cdd01c6a5651389ce81425f2f9", "patch": "@@ -491,7 +491,6 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n     }\n \n   free (starts);\n-  handle_nested_ranges ();\n \n   for (PC = 0;;)\n     {"}]}