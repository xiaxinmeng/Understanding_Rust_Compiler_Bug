{"sha": "75ac95f6647367783c4d65f6f686867ca425cb61", "node_id": "C_kwDOANBUbNoAKDc1YWM5NWY2NjQ3MzY3NzgzYzRkNjVmNmY2ODY4NjdjYTQyNWNiNjE", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-11-18T17:42:35Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-11-18T17:42:35Z"}, "message": "Turn -fsemantic-interposition to optimization flag\n\nTurn flag_semantic_interposition to optimization option so it can be enabled\nwith per-function granuality.  This is done by adding the flag among visibility\nflags into the symbol table.\n\ngcc/ChangeLog:\n\n2021-11-18  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* cgraph.c (cgraph_node::get_availability): Update call of\n\tdecl_replaceable_p.\n\t(cgraph_node::verify_node): Verify that semantic_interposition flag\n\tis set correclty.\n\t* cgraph.h: (symtab_node): Add semantic_interposition flag.\n\t* cgraphclones.c (set_new_clone_decl_and_node_flags): Clear\n\tsemantic_interposition flag.\n\t* cgraphunit.c (cgraph_node::finalize_function): Set\n\tsemantic_interposition flag.\n\t(cgraph_node::add_new_function): Likewise.\n\t(varpool_node::finalize_decl): Likewise.\n\t(cgraph_node::create_wrapper): Likewise.\n\t* common.opt (fsemantic-interposition): Turn to optimization node.\n\t* lto-cgraph.c (lto_output_node): Stream semantic_interposition.\n\t(lto_output_varpool_node): Likewise.\n\t(input_overwrite_node): Likewise.\n\t(input_varpool_node): Likewise.\n\t* symtab.c (symtab_node::dump_base): Dump new flag.\n\t* varasm.c (decl_replaceable_p): Add semantic_interposition_p\n\tparameter.\n\t* varasm.h (decl_replaceable_p): Update declaration.\n\t* varpool.c (varpool_node::ctor_useable_for_folding_p):\n\tUse semantic_interposition flag.\n\t(varpool_node::get_availability): Likewise.\n\t(varpool_node::create_alias): Copy semantic_interposition flag.\n\ngcc/cp/ChangeLog:\n\n2021-11-18  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* decl.c (finish_function): Update use of decl_replaceable_p.\n\ngcc/lto/ChangeLog:\n\n2021-11-18  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* lto-partition.c (promote_symbol): Clear semantic_interposition flag.\n\ngcc/testsuite/ChangeLog:\n\n2021-11-18  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* gcc.dg/lto/semantic-interposition-1_0.c: New test.\n\t* gcc.dg/lto/semantic-interposition-1_1.c: New test.", "tree": {"sha": "36c8c6e5f54c9e2fff395cf1a072416ac33b9fcc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36c8c6e5f54c9e2fff395cf1a072416ac33b9fcc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75ac95f6647367783c4d65f6f686867ca425cb61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75ac95f6647367783c4d65f6f686867ca425cb61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75ac95f6647367783c4d65f6f686867ca425cb61", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75ac95f6647367783c4d65f6f686867ca425cb61/comments", "author": null, "committer": null, "parents": [{"sha": "c331a75d49b6043399f5ccce72a02ccf3b0ddc56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c331a75d49b6043399f5ccce72a02ccf3b0ddc56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c331a75d49b6043399f5ccce72a02ccf3b0ddc56"}], "stats": {"total": 67, "additions": 58, "deletions": 9}, "files": [{"sha": "8e7c12642ad7b8323775c9725ac300c449ace7a4", "filename": "gcc/cgraph.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75ac95f6647367783c4d65f6f686867ca425cb61/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75ac95f6647367783c4d65f6f686867ca425cb61/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=75ac95f6647367783c4d65f6f686867ca425cb61", "patch": "@@ -2390,7 +2390,8 @@ cgraph_node::get_availability (symtab_node *ref)\n      to code cp_cannot_inline_tree_fn and probably shall be shared and\n      the inlinability hooks completely eliminated).  */\n \n-  else if (decl_replaceable_p (decl) && !DECL_EXTERNAL (decl))\n+  else if (decl_replaceable_p (decl, semantic_interposition)\n+\t   && !DECL_EXTERNAL (decl))\n     avail = AVAIL_INTERPOSABLE;\n   else avail = AVAIL_AVAILABLE;\n \n@@ -3486,6 +3487,13 @@ cgraph_node::verify_node (void)\n \t     \"returns a pointer\");\n       error_found = true;\n     }\n+  if (definition && externally_visible\n+      && semantic_interposition\n+\t != opt_for_fn (decl, flag_semantic_interposition))\n+    {\n+      error (\"semantic interposition mismatch\");\n+      error_found = true;\n+    }\n   for (e = indirect_calls; e; e = e->next_callee)\n     {\n       if (e->aux)"}, {"sha": "dafdfd289a001175c14f66e83a72cc71bf54810a", "filename": "gcc/cgraph.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75ac95f6647367783c4d65f6f686867ca425cb61/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75ac95f6647367783c4d65f6f686867ca425cb61/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=75ac95f6647367783c4d65f6f686867ca425cb61", "patch": "@@ -117,6 +117,7 @@ struct GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n       refuse_visibility_changes (false), externally_visible (false),\n       no_reorder (false), force_output (false), forced_by_abi (false),\n       unique_name (false), implicit_section (false), body_removed (false),\n+      semantic_interposition (flag_semantic_interposition),\n       used_from_other_partition (false), in_other_partition (false),\n       address_taken (false), in_init_priority_hash (false),\n       need_lto_streaming (false), offloadable (false), ifunc_resolver (false),\n@@ -557,6 +558,8 @@ struct GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n   /* True when body and other characteristics have been removed by\n      symtab_remove_unreachable_nodes. */\n   unsigned body_removed : 1;\n+  /* True when symbol should comply to -fsemantic-interposition flag.  */\n+  unsigned semantic_interposition : 1;\n \n   /*** WHOPR Partitioning flags.\n        These flags are used at ltrans stage when only part of the callgraph is"}, {"sha": "c997b82f3e1b54505e04c48c39f7f7bad5509dcd", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75ac95f6647367783c4d65f6f686867ca425cb61/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75ac95f6647367783c4d65f6f686867ca425cb61/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=75ac95f6647367783c4d65f6f686867ca425cb61", "patch": "@@ -172,6 +172,7 @@ set_new_clone_decl_and_node_flags (cgraph_node *new_node)\n   new_node->externally_visible = 0;\n   new_node->local = 1;\n   new_node->lowered = true;\n+  new_node->semantic_interposition = 0;\n }\n \n /* Duplicate thunk THUNK if necessary but make it to refer to NODE."}, {"sha": "1e58ffd65e8fe8d8fcfe60749b6e6259314a8d83", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75ac95f6647367783c4d65f6f686867ca425cb61/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75ac95f6647367783c4d65f6f686867ca425cb61/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=75ac95f6647367783c4d65f6f686867ca425cb61", "patch": "@@ -452,6 +452,7 @@ cgraph_node::finalize_function (tree decl, bool no_collect)\n   node->definition = true;\n   notice_global_symbol (decl);\n   node->lowered = DECL_STRUCT_FUNCTION (decl)->cfg != NULL;\n+  node->semantic_interposition = opt_for_fn (decl, flag_semantic_interposition);\n   if (!flag_toplevel_reorder)\n     node->no_reorder = true;\n \n@@ -554,6 +555,8 @@ cgraph_node::add_new_function (tree fndecl, bool lowered)\n \tnode = cgraph_node::get_create (fndecl);\n \tnode->local = false;\n \tnode->definition = true;\n+\tnode->semantic_interposition = opt_for_fn (fndecl,\n+\t\t\t\t\t\t   flag_semantic_interposition);\n \tnode->force_output = true;\n \tif (TREE_PUBLIC (fndecl))\n \t  node->externally_visible = true;\n@@ -581,6 +584,8 @@ cgraph_node::add_new_function (tree fndecl, bool lowered)\n \tif (lowered)\n \t  node->lowered = true;\n \tnode->definition = true;\n+\tnode->semantic_interposition = opt_for_fn (fndecl,\n+\t\t\t\t\t\t   flag_semantic_interposition);\n \tnode->analyze ();\n \tpush_cfun (DECL_STRUCT_FUNCTION (fndecl));\n \tgimple_register_cfg_hooks ();\n@@ -954,6 +959,7 @@ varpool_node::finalize_decl (tree decl)\n   /* Set definition first before calling notice_global_symbol so that\n      it is available to notice_global_symbol.  */\n   node->definition = true;\n+  node->semantic_interposition = flag_semantic_interposition;\n   notice_global_symbol (decl);\n   if (!flag_toplevel_reorder)\n     node->no_reorder = true;\n@@ -2576,6 +2582,7 @@ cgraph_node::create_wrapper (cgraph_node *target)\n \n   /* Turn alias into thunk and expand it into GIMPLE representation.  */\n   definition = true;\n+  semantic_interposition = opt_for_fn (decl, flag_semantic_interposition);\n \n   /* Create empty thunk, but be sure we did not keep former thunk around.\n      In that case we would need to preserve the info.  */"}, {"sha": "db6010e4e2025494f05d5ff4679f793644cd8a9b", "filename": "gcc/common.opt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75ac95f6647367783c4d65f6f686867ca425cb61/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75ac95f6647367783c4d65f6f686867ca425cb61/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=75ac95f6647367783c4d65f6f686867ca425cb61", "patch": "@@ -2539,7 +2539,7 @@ Common Var(flag_sel_sched_reschedule_pipelined) Init(0) Optimization\n Reschedule pipelined regions without pipelining.\n \n fsemantic-interposition\n-Common Var(flag_semantic_interposition) Init(1)\n+Common Var(flag_semantic_interposition) Init(1) Optimization\n Allow interposing function (or variables) by ones with different semantics (or initializer) respectively by dynamic linker.\n \n ; sched_stalled_insns means that insns can be moved prematurely from the queue"}, {"sha": "9f68d1a5590d43d967d04a15323b7ae4435d4b10", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75ac95f6647367783c4d65f6f686867ca425cb61/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75ac95f6647367783c4d65f6f686867ca425cb61/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=75ac95f6647367783c4d65f6f686867ca425cb61", "patch": "@@ -17609,7 +17609,8 @@ finish_function (bool inline_p)\n   if (!processing_template_decl\n       && !cp_function_chain->can_throw\n       && !flag_non_call_exceptions\n-      && !decl_replaceable_p (fndecl))\n+      && !decl_replaceable_p (fndecl,\n+\t\t\t      opt_for_fn (fndecl, flag_semantic_interposition)))\n     TREE_NOTHROW (fndecl) = 1;\n \n   /* This must come after expand_function_end because cleanups might"}, {"sha": "ef3c371c98fd9d18de3dbd3ad1a370a49c56f806", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75ac95f6647367783c4d65f6f686867ca425cb61/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75ac95f6647367783c4d65f6f686867ca425cb61/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=75ac95f6647367783c4d65f6f686867ca425cb61", "patch": "@@ -516,6 +516,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   bp_pack_value (&bp, node->forced_by_abi, 1);\n   bp_pack_value (&bp, node->unique_name, 1);\n   bp_pack_value (&bp, node->body_removed, 1);\n+  bp_pack_value (&bp, node->semantic_interposition, 1);\n   bp_pack_value (&bp, node->implicit_section, 1);\n   bp_pack_value (&bp, node->address_taken, 1);\n   bp_pack_value (&bp, tag == LTO_symtab_analyzed_node\n@@ -604,6 +605,7 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, varpool_node *node,\n \t\t node->body_removed\n \t\t || (!encode_initializer_p && !node->alias && node->definition),\n \t\t 1);\n+  bp_pack_value (&bp, node->semantic_interposition, 1);\n   bp_pack_value (&bp, node->implicit_section, 1);\n   bp_pack_value (&bp, node->writeonly, 1);\n   bp_pack_value (&bp, node->definition && (encode_initializer_p || node->alias),\n@@ -1167,6 +1169,7 @@ input_overwrite_node (struct lto_file_decl_data *file_data,\n   node->forced_by_abi = bp_unpack_value (bp, 1);\n   node->unique_name = bp_unpack_value (bp, 1);\n   node->body_removed = bp_unpack_value (bp, 1);\n+  node->semantic_interposition = bp_unpack_value (bp, 1);\n   node->implicit_section = bp_unpack_value (bp, 1);\n   node->address_taken = bp_unpack_value (bp, 1);\n   node->used_from_other_partition = bp_unpack_value (bp, 1);\n@@ -1373,6 +1376,7 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n   node->forced_by_abi = bp_unpack_value (&bp, 1);\n   node->unique_name = bp_unpack_value (&bp, 1);\n   node->body_removed = bp_unpack_value (&bp, 1);\n+  node->semantic_interposition = bp_unpack_value (&bp, 1);\n   node->implicit_section = bp_unpack_value (&bp, 1);\n   node->writeonly = bp_unpack_value (&bp, 1);\n   node->definition = bp_unpack_value (&bp, 1);"}, {"sha": "6d20555073e6662275af8ce161e6f98a700a050e", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75ac95f6647367783c4d65f6f686867ca425cb61/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75ac95f6647367783c4d65f6f686867ca425cb61/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=75ac95f6647367783c4d65f6f686867ca425cb61", "patch": "@@ -1001,6 +1001,7 @@ promote_symbol (symtab_node *node)\n      so it is prevailing.  This is important to keep binds_to_current_def_p\n      to work across partitions.  */\n   node->resolution = LDPR_PREVAILING_DEF_IRONLY;\n+  node->semantic_interposition = false;\n   DECL_VISIBILITY (node->decl) = VISIBILITY_HIDDEN;\n   DECL_VISIBILITY_SPECIFIED (node->decl) = true;\n   if (dump_file)"}, {"sha": "94b4e47f7497adafe39af86fa7209bfdab8170c5", "filename": "gcc/symtab.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75ac95f6647367783c4d65f6f686867ca425cb61/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75ac95f6647367783c4d65f6f686867ca425cb61/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=75ac95f6647367783c4d65f6f686867ca425cb61", "patch": "@@ -929,6 +929,8 @@ symtab_node::dump_base (FILE *f)\n     fprintf (f, \" forced_by_abi\");\n   if (externally_visible)\n     fprintf (f, \" externally_visible\");\n+  if (semantic_interposition)\n+    fprintf (f, \" semantic_interposition\");\n   if (no_reorder)\n     fprintf (f, \" no_reorder\");\n   if (resolution != LDPR_UNKNOWN)"}, {"sha": "db8427490084a1d44957b5eb46ce1f7bc6e3ebc1", "filename": "gcc/testsuite/gcc.dg/lto/semantic-interposition-1_0.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75ac95f6647367783c4d65f6f686867ca425cb61/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fsemantic-interposition-1_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75ac95f6647367783c4d65f6f686867ca425cb61/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fsemantic-interposition-1_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fsemantic-interposition-1_0.c?ref=75ac95f6647367783c4d65f6f686867ca425cb61", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-lto-do link }  */\n+/* { dg-require-effective-target shared } */\n+/* { dg-extra-ld-options { -shared } } */\n+/* { dg-lto-options {{-O2 -flto -fpic -fdump-ipa-inline-details --shared}} }  */ \n+extern int ret1();\n+\n+int\n+test()\n+{\n+  return ret1();\n+}\n+/* { dg-final { scan-wpa-ipa-dump \"Inlined 1 calls\"  \"inline\"  } } */\n+"}, {"sha": "9a741773002658e4305cb4afacebc305550696fc", "filename": "gcc/testsuite/gcc.dg/lto/semantic-interposition-1_1.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75ac95f6647367783c4d65f6f686867ca425cb61/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fsemantic-interposition-1_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75ac95f6647367783c4d65f6f686867ca425cb61/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fsemantic-interposition-1_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fsemantic-interposition-1_1.c?ref=75ac95f6647367783c4d65f6f686867ca425cb61", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-options \"-O2 -flto -fpic -fno-semantic-interposition\" }  */ \n+int ret1()\n+{\n+  return 1;\n+}"}, {"sha": "8c7aba2db61c45a60e0b6c9b88d1b1e8811b1ac3", "filename": "gcc/varasm.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75ac95f6647367783c4d65f6f686867ca425cb61/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75ac95f6647367783c4d65f6f686867ca425cb61/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=75ac95f6647367783c4d65f6f686867ca425cb61", "patch": "@@ -7625,19 +7625,21 @@ decl_binds_to_current_def_p (const_tree decl)\n    at link-time with an entirely different definition, provided that the\n    replacement has the same type.  For example, functions declared\n    with __attribute__((weak)) on most systems are replaceable.\n+   If SEMANTIC_INTERPOSITION_P is false allow interposition only on\n+   symbols explicitly declared weak.\n \n    COMDAT functions are not replaceable, since all definitions of the\n    function must be equivalent.  It is important that COMDAT functions\n    not be treated as replaceable so that use of C++ template\n    instantiations is not penalized.  */\n \n bool\n-decl_replaceable_p (tree decl)\n+decl_replaceable_p (tree decl, bool semantic_interposition_p)\n {\n   gcc_assert (DECL_P (decl));\n   if (!TREE_PUBLIC (decl) || DECL_COMDAT (decl))\n     return false;\n-  if (!flag_semantic_interposition\n+  if (!semantic_interposition_p\n       && !DECL_WEAK (decl))\n     return false;\n   return !decl_binds_to_current_def_p (decl);"}, {"sha": "4ab9dc51838b3717b8a897d0b856597b869550c2", "filename": "gcc/varasm.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75ac95f6647367783c4d65f6f686867ca425cb61/gcc%2Fvarasm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75ac95f6647367783c4d65f6f686867ca425cb61/gcc%2Fvarasm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.h?ref=75ac95f6647367783c4d65f6f686867ca425cb61", "patch": "@@ -38,7 +38,7 @@ extern void mark_decl_referenced (tree);\n extern void notice_global_symbol (tree);\n extern void set_user_assembler_name (tree, const char *);\n extern void process_pending_assemble_externals (void);\n-extern bool decl_replaceable_p (tree);\n+extern bool decl_replaceable_p (tree, bool);\n extern bool decl_binds_to_current_def_p (const_tree);\n extern enum tls_model decl_default_tls_model (const_tree);\n "}, {"sha": "fd0d53b9eb64790ffe0d228c46229f2438fdcbeb", "filename": "gcc/varpool.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75ac95f6647367783c4d65f6f686867ca425cb61/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75ac95f6647367783c4d65f6f686867ca425cb61/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=75ac95f6647367783c4d65f6f686867ca425cb61", "patch": "@@ -372,7 +372,8 @@ varpool_node::ctor_useable_for_folding_p (void)\n    */\n   if ((!DECL_INITIAL (real_node->decl)\n        || (DECL_WEAK (decl) && !DECL_COMDAT (decl)))\n-      && (DECL_EXTERNAL (decl) || decl_replaceable_p (decl)))\n+      && ((DECL_EXTERNAL (decl) && !in_other_partition)\n+\t  || decl_replaceable_p (decl, semantic_interposition)))\n     return false;\n \n   /* Variables declared `const' with an initializer are considered\n@@ -511,8 +512,8 @@ varpool_node::get_availability (symtab_node *ref)\n   /* If the variable can be overwritten, return OVERWRITABLE.  Takes\n      care of at least one notable extension - the COMDAT variables\n      used to share template instantiations in C++.  */\n-  if (decl_replaceable_p (decl)\n-      || DECL_EXTERNAL (decl))\n+  if (decl_replaceable_p (decl, semantic_interposition)\n+      || (DECL_EXTERNAL (decl) && !in_other_partition))\n     return AVAIL_INTERPOSABLE;\n   return AVAIL_AVAILABLE;\n }\n@@ -779,6 +780,7 @@ varpool_node::create_alias (tree alias, tree decl)\n   alias_node = varpool_node::get_create (alias);\n   alias_node->alias = true;\n   alias_node->definition = true;\n+  alias_node->semantic_interposition = flag_semantic_interposition;\n   alias_node->alias_target = decl;\n   if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (alias)) != NULL)\n     alias_node->weakref = alias_node->transparent_alias = true;"}]}