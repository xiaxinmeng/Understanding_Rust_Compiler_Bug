{"sha": "0340f2ba6e7a3dd55135da0254c72eb3b47de802", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDM0MGYyYmE2ZTdhM2RkNTUxMzVkYTAyNTRjNzJlYjNiNDdkZTgwMg==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2009-03-29T17:20:25Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2009-03-29T17:20:25Z"}, "message": "regmove.c (perhaps_ends_bb_p): Remove.\n\n\t* regmove.c (perhaps_ends_bb_p): Remove.\n\t(optimize_reg_copy_1): Don't call perhaps_ends_bb_p.  Get basic block\n\tfrom INSN and check that the main loop stays within that basic block.\n\t(optimize_reg_copy_1, optimize_reg_copy_3, fixup_match_2): Likewise.\n\t(regmove_forward_pass): Split out from regmove_optimize.  Use\n\tFOR_EACH_BB and FOR_BB_INSNS instead of traversing the insns stream.\n\t(regmove_backward_pass): Split out from regmove_optimize.  Use\n\tFOR_EACH_BB_REVERSE and FOR_BB_INSNS_REVERS_SAFE.\n\t(regmove_optimize): Simplify.\n\nFrom-SVN: r145247", "tree": {"sha": "3c14d17feea850f9c156e1b4b216ea6e7f8f9513", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c14d17feea850f9c156e1b4b216ea6e7f8f9513"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0340f2ba6e7a3dd55135da0254c72eb3b47de802", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0340f2ba6e7a3dd55135da0254c72eb3b47de802", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0340f2ba6e7a3dd55135da0254c72eb3b47de802", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0340f2ba6e7a3dd55135da0254c72eb3b47de802/comments", "author": null, "committer": null, "parents": [{"sha": "d80c695ff0da09ebbb0d7b4370396e36d4e58180", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d80c695ff0da09ebbb0d7b4370396e36d4e58180", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d80c695ff0da09ebbb0d7b4370396e36d4e58180"}], "stats": {"total": 175, "additions": 88, "deletions": 87}, "files": [{"sha": "5f9b9c14a4048dbf92dae68e65b7d6def212ebc9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0340f2ba6e7a3dd55135da0254c72eb3b47de802/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0340f2ba6e7a3dd55135da0254c72eb3b47de802/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0340f2ba6e7a3dd55135da0254c72eb3b47de802", "patch": "@@ -1,3 +1,15 @@\n+2009-03-29  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* regmove.c (perhaps_ends_bb_p): Remove.\n+\t(optimize_reg_copy_1): Don't call perhaps_ends_bb_p.  Get basic block\n+\tfrom INSN and check that the main loop stays within that basic block.\n+\t(optimize_reg_copy_1, optimize_reg_copy_3, fixup_match_2): Likewise.\n+\t(regmove_forward_pass): Split out from regmove_optimize.  Use\n+\tFOR_EACH_BB and FOR_BB_INSNS instead of traversing the insns stream.\n+\t(regmove_backward_pass): Split out from regmove_optimize.  Use\n+\tFOR_EACH_BB_REVERSE and FOR_BB_INSNS_REVERS_SAFE.\n+\t(regmove_optimize): Simplify.\n+\n 2009-03-29  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/39545"}, {"sha": "bdbd74722fd9e2927e43a6bd708dda7a7ed47ecf", "filename": "gcc/regmove.c", "status": "modified", "additions": 76, "deletions": 87, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0340f2ba6e7a3dd55135da0254c72eb3b47de802/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0340f2ba6e7a3dd55135da0254c72eb3b47de802/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=0340f2ba6e7a3dd55135da0254c72eb3b47de802", "patch": "@@ -45,7 +45,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"df.h\"\n \n-static int perhaps_ends_bb_p (rtx);\n static int optimize_reg_copy_1 (rtx, rtx, rtx);\n static void optimize_reg_copy_2 (rtx, rtx, rtx);\n static void optimize_reg_copy_3 (rtx, rtx, rtx);\n@@ -208,30 +207,6 @@ try_auto_increment (rtx insn, rtx inc_insn, rtx inc_insn_set, rtx reg,\n \f\n static int *regno_src_regno;\n \n-\f\n-/* Return 1 if INSN might end a basic block.  */\n-\n-static int perhaps_ends_bb_p (rtx insn)\n-{\n-  switch (GET_CODE (insn))\n-    {\n-    case CODE_LABEL:\n-    case JUMP_INSN:\n-      /* These always end a basic block.  */\n-      return 1;\n-\n-    case CALL_INSN:\n-      /* A CALL_INSN might be the last insn of a basic block, if it is inside\n-\t an EH region or if there are nonlocal gotos.  Note that this test is\n-\t very conservative.  */\n-      if (nonlocal_goto_handler_labels)\n-\treturn 1;\n-      /* Fall through.  */\n-    default:\n-      return can_throw_internal (insn);\n-    }\n-}\n-\f\n /* INSN is a copy from SRC to DEST, both registers, and SRC does not die\n    in INSN.\n \n@@ -251,6 +226,7 @@ optimize_reg_copy_1 (rtx insn, rtx dest, rtx src)\n   rtx dest_death = 0;\n   int sregno = REGNO (src);\n   int dregno = REGNO (dest);\n+  basic_block bb = BLOCK_FOR_INSN (insn);\n \n   /* We don't want to mess with hard regs if register classes are small.  */\n   if (sregno == dregno\n@@ -264,12 +240,10 @@ optimize_reg_copy_1 (rtx insn, rtx dest, rtx src)\n \n   for (p = NEXT_INSN (insn); p; p = NEXT_INSN (p))\n     {\n-      /* ??? We can't scan past the end of a basic block without updating\n-\t the register lifetime info (REG_DEAD/basic_block_live_at_start).  */\n-      if (perhaps_ends_bb_p (p))\n-\tbreak;\n-      else if (! INSN_P (p))\n+      if (! INSN_P (p))\n \tcontinue;\n+      if (BLOCK_FOR_INSN (p) != bb)\n+\tbreak;\n \n       if (reg_set_p (src, p) || reg_set_p (dest, p)\n \t  /* If SRC is an asm-declared register, it must not be replaced\n@@ -457,15 +431,14 @@ optimize_reg_copy_2 (rtx insn, rtx dest, rtx src)\n   rtx set;\n   int sregno = REGNO (src);\n   int dregno = REGNO (dest);\n+  basic_block bb = BLOCK_FOR_INSN (insn);\n \n   for (p = NEXT_INSN (insn); p; p = NEXT_INSN (p))\n     {\n-      /* ??? We can't scan past the end of a basic block without updating\n-\t the register lifetime info (REG_DEAD/basic_block_live_at_start).  */\n-      if (perhaps_ends_bb_p (p))\n-\tbreak;\n-      else if (! INSN_P (p))\n+      if (! INSN_P (p))\n \tcontinue;\n+      if (BLOCK_FOR_INSN (p) != bb)\n+\tbreak;\n \n       set = single_set (p);\n       if (set && SET_SRC (set) == dest && SET_DEST (set) == src\n@@ -530,20 +503,20 @@ optimize_reg_copy_3 (rtx insn, rtx dest, rtx src)\n   int dst_no = REGNO (dest);\n   rtx p, set;\n   enum machine_mode old_mode;\n+  basic_block bb = BLOCK_FOR_INSN (insn);\n \n   if (src_no < FIRST_PSEUDO_REGISTER\n       || dst_no < FIRST_PSEUDO_REGISTER\n       || ! find_reg_note (insn, REG_DEAD, src_reg)\n       || REG_N_DEATHS (src_no) != 1\n       || REG_N_SETS (src_no) != 1)\n     return;\n+\n   for (p = PREV_INSN (insn); p && ! reg_set_p (src_reg, p); p = PREV_INSN (p))\n-    /* ??? We can't scan past the end of a basic block without updating\n-       the register lifetime info (REG_DEAD/basic_block_live_at_start).  */\n-    if (perhaps_ends_bb_p (p))\n+    if (INSN_P (p) && BLOCK_FOR_INSN (p) != bb)\n       break;\n-\n-  if (! p)\n+  \n+  if (! p || BLOCK_FOR_INSN (p) != bb)\n     return;\n \n   if (! (set = single_set (p))\n@@ -767,6 +740,7 @@ fixup_match_2 (rtx insn, rtx dst, rtx src, rtx offset)\n {\n   rtx p, dst_death = 0;\n   int length, num_calls = 0, freq_calls = 0;\n+  basic_block bb = BLOCK_FOR_INSN (insn);\n \n   /* If SRC dies in INSN, we'd have to move the death note.  This is\n      considered to be very unlikely, so we just skip the optimization\n@@ -780,12 +754,10 @@ fixup_match_2 (rtx insn, rtx dst, rtx src, rtx offset)\n     {\n       rtx pset;\n \n-      /* ??? We can't scan past the end of a basic block without updating\n-\t the register lifetime info (REG_DEAD/basic_block_live_at_start).  */\n-      if (perhaps_ends_bb_p (p))\n-\tbreak;\n-      else if (! INSN_P (p))\n+      if (! INSN_P (p))\n \tcontinue;\n+      if (BLOCK_FOR_INSN (p) != bb)\n+\tbreak;\n \n       if (find_regno_note (p, REG_DEAD, REGNO (dst)))\n \tdst_death = p;\n@@ -821,11 +793,10 @@ fixup_match_2 (rtx insn, rtx dst, rtx src, rtx offset)\n #ifdef AUTO_INC_DEC\n \t      for (p = PREV_INSN (insn); p; p = PREV_INSN (p))\n \t\t{\n-\t\t  if (LABEL_P (p)\n-\t\t      || JUMP_P (p))\n-\t\t    break;\n \t\t  if (! INSN_P (p))\n \t\t    continue;\n+\t\t  if (BLOCK_FOR_INSN (p) != bb)\n+\t\t    break;\n \t\t  if (reg_overlap_mentioned_p (dst, PATTERN (p)))\n \t\t    {\n \t\t      if (try_auto_increment (p, insn, 0, dst, newconst, 0))\n@@ -835,11 +806,10 @@ fixup_match_2 (rtx insn, rtx dst, rtx src, rtx offset)\n \t\t}\n \t      for (p = NEXT_INSN (insn); p; p = NEXT_INSN (p))\n \t\t{\n-\t\t  if (LABEL_P (p)\n-\t\t      || JUMP_P (p))\n-\t\t    break;\n \t\t  if (! INSN_P (p))\n \t\t    continue;\n+\t\t  if (BLOCK_FOR_INSN (p) != bb)\n+\t\t    break;\n \t\t  if (reg_overlap_mentioned_p (dst, PATTERN (p)))\n \t\t    {\n \t\t      try_auto_increment (p, insn, 0, dst, newconst, 1);\n@@ -882,40 +852,23 @@ fixup_match_2 (rtx insn, rtx dst, rtx src, rtx offset)\n   return 0;\n }\n \n-/* Main entry for the register move optimization.  */\n+/* A forward pass.  Replace output operands with input operands.  */\n \n-static unsigned int\n-regmove_optimize (void)\n+static void\n+regmove_forward_pass (void)\n {\n+  basic_block bb;\n   rtx insn;\n-  struct match match;\n-  int i;\n-  rtx copy_src, copy_dst;\n-  int nregs = max_reg_num ();\n \n-  /* ??? Hack.  Regmove doesn't examine the CFG, and gets mightily\n-     confused by non-call exceptions ending blocks.  */\n-  if (flag_non_call_exceptions)\n-    return 0;\n-\n-  df_note_add_problem ();\n-  df_analyze ();\n-\n-  regstat_init_n_sets_and_refs ();\n-  regstat_compute_ri ();\n-\n-  regno_src_regno = XNEWVEC (int, nregs);\n-  for (i = nregs; --i >= 0; )\n-    regno_src_regno[i] = -1;\n+  if (! flag_expensive_optimizations)\n+    return;\n \n-  /* A forward pass.  Replace output operands with input operands.  */\n+  if (dump_file)\n+    fprintf (dump_file, \"Starting forward pass...\\n\");\n \n-  if (flag_expensive_optimizations)\n+  FOR_EACH_BB (bb)\n     {\n-      if (dump_file)\n-\tfprintf (dump_file, \"Starting forward pass...\\n\");\n-\n-      for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+      FOR_BB_INSNS (bb, insn)\n \t{\n \t  rtx set = single_set (insn);\n \t  if (! set)\n@@ -952,19 +905,33 @@ regmove_optimize (void)\n \t    }\n \t}\n     }\n+}\n \n-  /* A backward pass.  Replace input operands with output operands.  */\n+/* A backward pass.  Replace input operands with output operands.  */\n+\n+static void\n+regmove_backward_pass (void)\n+{\n+  basic_block bb;\n+  rtx insn, prev;\n \n   if (dump_file)\n     fprintf (dump_file, \"Starting backward pass...\\n\");\n \n-  for (insn = get_last_insn (); insn; insn = PREV_INSN (insn))\n+  FOR_EACH_BB_REVERSE (bb)\n     {\n-      if (INSN_P (insn))\n+      /* ??? Use the safe iterator because fixup_match_2 can remove\n+\t     insns via try_auto_increment.  */ \n+      FOR_BB_INSNS_REVERSE_SAFE (bb, insn, prev)\n \t{\n+\t  struct match match;\n+\t  rtx copy_src, copy_dst;\n \t  int op_no, match_no;\n \t  int success = 0;\n \n+\t  if (! INSN_P (insn))\n+\t    continue;\n+\n \t  if (! find_matches (insn, &match))\n \t    continue;\n \n@@ -1117,13 +1084,10 @@ regmove_optimize (void)\n \t\t{\n \t\t  rtx pset;\n \n-\t\t  /* ??? We can't scan past the end of a basic block without\n-\t\t     updating the register lifetime info\n-\t\t     (REG_DEAD/basic_block_live_at_start).  */\n-\t\t  if (perhaps_ends_bb_p (p))\n-\t\t    break;\n-\t\t  else if (! INSN_P (p))\n+\t\t  if (! INSN_P (p))\n \t\t    continue;\n+\t\t  if (BLOCK_FOR_INSN (p) != bb)\n+\t\t    break;\n \n \t\t  length++;\n \n@@ -1231,6 +1195,31 @@ regmove_optimize (void)\n \t    copy_src_to_dest (insn, copy_src, copy_dst);\n \t}\n     }\n+}\n+\n+/* Main entry for the register move optimization.  */\n+\n+static unsigned int\n+regmove_optimize (void)\n+{\n+  int i;\n+  int nregs = max_reg_num ();\n+\n+  df_note_add_problem ();\n+  df_analyze ();\n+\n+  regstat_init_n_sets_and_refs ();\n+  regstat_compute_ri ();\n+\n+  regno_src_regno = XNEWVEC (int, nregs);\n+  for (i = nregs; --i >= 0; )\n+    regno_src_regno[i] = -1;\n+\n+  /* A forward pass.  Replace output operands with input operands.  */\n+  regmove_forward_pass ();\n+\n+  /* A backward pass.  Replace input operands with output operands.  */\n+  regmove_backward_pass ();\n \n   /* Clean up.  */\n   free (regno_src_regno);"}]}