{"sha": "6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmU0Yjc0ZmI3N2M0NWE2MDg4ZTBjY2EyMmVjMDVjMjhjN2YwYjZkYw==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2020-12-14T15:40:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-12-14T15:40:17Z"}, "message": "Merge pull request #62 from SimplyTheOther/master\n\nExpansion code for cfg attributes, bug fixes and minor enhancements in parser", "tree": {"sha": "46eb33355b3d0351d4743d19d1d5c46ae9d5677c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46eb33355b3d0351d4743d19d1d5c46ae9d5677c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJf14dhCRBK7hj4Ov3rIwAAdHIIAGVMv/wKmwXfM70hsMCpKXG+\nVqxHxHJfRVllBKsqoAysqjKh3o2pNrwCZQPw9zQCKlLgDPdiPHiF80QSxQXd+PZ1\nWMlHjoeNAtJ24Jii04upMfndu9yQwyhAyOHnz69wQXuvEs5S6a/CiPfBDTaSUkk7\nQd61rj21b73UOBiFnF/uUHbXCPqjRI4EzYUuoqp1Ovl7Y9Tt+Od3Q5LjVhnS7kyy\n20d43o5ADI6wtuE4NaPnU7fgDYkGPLOidrae0uAnEGJIk3tu7eZnQ0gcamrzk3fa\njNfen5Zsa/wH40KWnqcMQH89yBREQ13DeDsIAFpB7btOOgrqfU2aBoT/4lK9XSs=\n=GArB\n-----END PGP SIGNATURE-----\n", "payload": "tree 46eb33355b3d0351d4743d19d1d5c46ae9d5677c\nparent cef34bd730d80b4664d8633e2cc27a64c5cae246\nparent 52cc571b308d3d0103dd498fd277859e2116791a\nauthor Philip Herron <philip.herron@embecosm.com> 1607960417 +0000\ncommitter GitHub <noreply@github.com> 1607960417 +0000\n\nMerge pull request #62 from SimplyTheOther/master\n\nExpansion code for cfg attributes, bug fixes and minor enhancements in parser"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cef34bd730d80b4664d8633e2cc27a64c5cae246", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cef34bd730d80b4664d8633e2cc27a64c5cae246", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cef34bd730d80b4664d8633e2cc27a64c5cae246"}, {"sha": "52cc571b308d3d0103dd498fd277859e2116791a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52cc571b308d3d0103dd498fd277859e2116791a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52cc571b308d3d0103dd498fd277859e2116791a"}], "stats": {"total": 9644, "additions": 7681, "deletions": 1963}, "files": [{"sha": "31c89e499f791da1cafdf41c4e447c21097561ba", "filename": "gcc/rust/analysis/rust-scan.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc/gcc%2Frust%2Fanalysis%2Frust-scan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc/gcc%2Frust%2Fanalysis%2Frust-scan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-scan.cc?ref=6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc", "patch": "@@ -353,7 +353,7 @@ TopLevelScan::visit (AST::UseDeclaration &use_decl)\n void\n TopLevelScan::visit (AST::Function &function)\n {\n-  functions[function.function_name] = &function;\n+  functions[function.get_function_name ()] = &function;\n }\n \n void"}, {"sha": "f1edec822b7258dafee2a34a2a7203e5b44ca783", "filename": "gcc/rust/analysis/rust-type-resolution.cc", "status": "modified", "additions": 69, "deletions": 69, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc/gcc%2Frust%2Fanalysis%2Frust-type-resolution.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc/gcc%2Frust%2Fanalysis%2Frust-type-resolution.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-type-resolution.cc?ref=6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc", "patch": "@@ -165,10 +165,10 @@ void\n TypeResolution::visit (AST::IdentifierExpr &ident_expr)\n {\n   AST::Type *type = NULL;\n-  bool ok = scope.LookupType (ident_expr.ident, &type);\n+  bool ok = scope.LookupType (ident_expr.get_ident (), &type);\n   if (!ok)\n     {\n-      rust_error_at (ident_expr.locus, \"unknown identifier\");\n+      rust_error_at (ident_expr.get_locus (), \"unknown identifier\");\n       return;\n     }\n \n@@ -242,7 +242,7 @@ void\n TypeResolution::visit (AST::LiteralExpr &expr)\n {\n   std::string type;\n-  switch (expr.literal.get_lit_type ())\n+  switch (expr.get_lit_type ())\n     {\n     case AST::Literal::CHAR:\n       type = \"char\";\n@@ -279,8 +279,8 @@ TypeResolution::visit (AST::LiteralExpr &expr)\n \n   if (type.empty ())\n     {\n-      rust_error_at (expr.locus, \"unknown literal: %s\",\n-\t\t     expr.literal.as_string ().c_str ());\n+      rust_error_at (expr.get_locus (), \"unknown literal: %s\",\n+\t\t     expr.get_literal ().as_string ().c_str ());\n       return;\n     }\n \n@@ -289,7 +289,7 @@ TypeResolution::visit (AST::LiteralExpr &expr)\n   if (ok)\n     typeBuffer.push_back (val);\n   else\n-    rust_error_at (expr.locus, \"unknown literal type: %s\", type.c_str ());\n+    rust_error_at (expr.get_locus (), \"unknown literal type: %s\", type.c_str ());\n }\n \n void\n@@ -325,7 +325,7 @@ TypeResolution::visit (AST::ArithmeticOrLogicalExpr &expr)\n   expr.visit_lhs (*this);\n   if (typeBuffer.size () <= before)\n     {\n-      rust_error_at (expr.locus, \"unable to determine lhs type\");\n+      rust_error_at (expr.get_locus (), \"unable to determine lhs type\");\n       return;\n     }\n \n@@ -336,7 +336,7 @@ TypeResolution::visit (AST::ArithmeticOrLogicalExpr &expr)\n   expr.visit_rhs (*this);\n   if (typeBuffer.size () <= before)\n     {\n-      rust_error_at (expr.locus, \"unable to determine rhs type\");\n+      rust_error_at (expr.get_locus (), \"unable to determine rhs type\");\n       return;\n     }\n \n@@ -345,7 +345,7 @@ TypeResolution::visit (AST::ArithmeticOrLogicalExpr &expr)\n   // scope will require knowledge of the type\n \n   // do the lhsType and the rhsType match\n-  typesAreCompatible (lhsType, rhsType, expr.right_expr->get_locus_slow ());\n+  typesAreCompatible (lhsType, rhsType, expr.get_right_expr ()->get_locus_slow ());\n }\n \n void\n@@ -368,7 +368,7 @@ TypeResolution::visit (AST::AssignmentExpr &expr)\n   expr.visit_lhs (*this);\n   if (typeBuffer.size () <= before)\n     {\n-      rust_error_at (expr.locus, \"unable to determine lhs type\");\n+      rust_error_at (expr.get_locus (), \"unable to determine lhs type\");\n       return;\n     }\n \n@@ -379,7 +379,7 @@ TypeResolution::visit (AST::AssignmentExpr &expr)\n   expr.visit_rhs (*this);\n   if (typeBuffer.size () <= before)\n     {\n-      rust_error_at (expr.locus, \"unable to determine rhs type\");\n+      rust_error_at (expr.get_locus (), \"unable to determine rhs type\");\n       return;\n     }\n \n@@ -389,7 +389,7 @@ TypeResolution::visit (AST::AssignmentExpr &expr)\n \n   // do the lhsType and the rhsType match\n   if (!typesAreCompatible (lhsType, rhsType,\n-\t\t\t   expr.right_expr->get_locus_slow ()))\n+\t\t\t   expr.get_right_expr ()->get_locus_slow ()))\n     return;\n \n   // is the lhs mutable?\n@@ -465,7 +465,7 @@ TypeResolution::visit (AST::ArrayElemsCopied &elems)\n void\n TypeResolution::visit (AST::ArrayExpr &expr)\n {\n-  auto elements = expr.get_internal_elements ();\n+  auto& elements = expr.get_array_elems ();\n \n   auto before = typeBuffer.size ();\n   elements->accept_vis (*this);\n@@ -526,7 +526,7 @@ TypeResolution::visit (AST::ArrayIndexExpr &expr)\n       return;\n     }\n \n-  typeBuffer.push_back (resolved->get_element_type ());\n+  typeBuffer.push_back (resolved->get_elem_type ().get ());\n }\n \n void\n@@ -548,15 +548,15 @@ TypeResolution::visit (AST::StructExprFieldIdentifier &field)\n void\n TypeResolution::visit (AST::StructExprFieldIdentifierValue &field)\n {\n-  identifierBuffer = &field.field_name;\n-  field.value->accept_vis (*this);\n+  identifierBuffer = std::unique_ptr<std::string> (new std::string (field.get_field_name ()));\n+  field.get_value ()->accept_vis (*this);\n }\n \n void\n TypeResolution::visit (AST::StructExprFieldIndexValue &field)\n {\n-  tupleIndexBuffer = &field.index;\n-  field.value->accept_vis (*this);\n+  tupleIndexBuffer = std::unique_ptr<int> (new int (field.get_index ()));\n+  field.get_value ()->accept_vis (*this);\n }\n \n void\n@@ -569,7 +569,7 @@ TypeResolution::visit (AST::StructExprStructFields &expr)\n       return;\n     }\n \n-  for (auto &field : expr.fields)\n+  for (auto &field : expr.get_fields ())\n     {\n       identifierBuffer = NULL;\n       tupleIndexBuffer = NULL;\n@@ -590,9 +590,9 @@ TypeResolution::visit (AST::StructExprStructFields &expr)\n       if (identifierBuffer != NULL)\n \t{\n \t  AST::StructField *declField = NULL;\n-\t  for (auto &df : decl->fields)\n+\t  for (auto &df : decl->get_fields ())\n \t    {\n-\t      if (identifierBuffer->compare (df.field_name) == 0)\n+\t      if (identifierBuffer->compare (df.get_field_name ()) == 0)\n \t\t{\n \t\t  declField = &df;\n \t\t  break;\n@@ -606,17 +606,17 @@ TypeResolution::visit (AST::StructExprStructFields &expr)\n \t      return;\n \t    }\n \n-\t  if (!typesAreCompatible (declField->field_type.get (), inferedType,\n+\t  if (!typesAreCompatible (declField->get_field_type ().get (), inferedType,\n \t\t\t\t   expr.get_locus_slow ()))\n \t    return;\n \t}\n       // do we have an index for this\n       else if (tupleIndexBuffer != NULL)\n \t{\n \t  AST::StructField *declField = NULL;\n-\t  if (*tupleIndexBuffer < decl->fields.size ())\n+\t  if (*tupleIndexBuffer < decl->get_fields ().size ())\n \t    {\n-\t      declField = &decl->fields[*tupleIndexBuffer];\n+\t      declField = &decl->get_fields ()[*tupleIndexBuffer];\n \t    }\n \t  tupleIndexBuffer = NULL;\n \n@@ -626,7 +626,7 @@ TypeResolution::visit (AST::StructExprStructFields &expr)\n \t      return;\n \t    }\n \n-\t  if (!typesAreCompatible (declField->field_type.get (), inferedType,\n+\t  if (!typesAreCompatible (declField->get_field_type ().get (), inferedType,\n \t\t\t\t   expr.get_locus_slow ()))\n \t    return;\n \t}\n@@ -686,41 +686,41 @@ void\n TypeResolution::visit (AST::CallExpr &expr)\n {\n   // this look up should probably be moved to name resolution\n-  auto fndecl = lookupFndecl (expr.function.get ());\n+  auto fndecl = lookupFndecl (expr.get_function_expr ().get ());\n   if (fndecl == NULL)\n     return;\n \n   // check num args match\n-  if (fndecl->function_params.size () != expr.params.size ())\n+  if (fndecl->get_function_params ().size () != expr.get_params ().size ())\n     {\n       rust_error_at (expr.get_locus_slow (),\n \t\t     \"differing number of arguments vs parameters to function\");\n       return;\n     }\n \n-  typeBuffer.push_back (fndecl->return_type.get ());\n+  typeBuffer.push_back (fndecl->get_return_type ().get ());\n   expr.fndeclRef = fndecl;\n \n   auto before = typeBuffer.size ();\n-  for (auto &item : expr.params)\n+  for (auto &item : expr.get_params ())\n     item->accept_vis (*this);\n \n   auto numInferedParams = typeBuffer.size () - before;\n-  if (numInferedParams != expr.params.size ())\n+  if (numInferedParams != expr.get_params ().size ())\n     {\n-      rust_error_at (expr.locus, \"Failed to infer all parameters\");\n+      rust_error_at (expr.get_locus (), \"Failed to infer all parameters\");\n       return;\n     }\n \n   auto offs = numInferedParams - 1;\n-  for (auto it = fndecl->function_params.rbegin ();\n-       it != fndecl->function_params.rend (); ++it)\n+  for (auto it = fndecl->get_function_params ().rbegin ();\n+       it != fndecl->get_function_params ().rend (); ++it)\n     {\n       AST::Type *argument = typeBuffer.back ();\n       typeBuffer.pop_back ();\n \n-      if (!typesAreCompatible (it->type.get (), argument,\n-\t\t\t       expr.params[offs]->get_locus_slow ()))\n+      if (!typesAreCompatible (it->get_type ().get (), argument,\n+\t\t\t       expr.get_params ()[offs]->get_locus_slow ()))\n \treturn;\n       offs--;\n     }\n@@ -740,7 +740,7 @@ void\n TypeResolution::visit (AST::BlockExpr &expr)\n {\n   scope.Push ();\n-  for (auto &stmt : expr.statements)\n+  for (auto &stmt : expr.get_statements ())\n     {\n       stmt->accept_vis (*this);\n     }\n@@ -780,11 +780,11 @@ TypeResolution::visit (AST::ReturnExpr &expr)\n {\n   // Ensure the type of this matches the function\n   auto before = typeBuffer.size ();\n-  expr.get_expr ()->accept_vis (*this);\n+  expr.get_returned_expr ()->accept_vis (*this);\n \n   if (typeBuffer.size () <= before)\n     {\n-      rust_error_at (expr.get_expr ()->get_locus_slow (),\n+      rust_error_at (expr.get_returned_expr ()->get_locus_slow (),\n \t\t     \"unable to determine type for return expr\");\n       return;\n     }\n@@ -796,14 +796,14 @@ TypeResolution::visit (AST::ReturnExpr &expr)\n   // this will again have issues with structs before we move to HIR\n \n   auto function = scope.CurrentFunction ();\n-  if (!function->has_function_return_type ())\n+  if (!function->has_return_type ())\n     {\n       rust_error_at (expr.get_locus (), \"return for void function %s\",\n \t\t     function->as_string ().c_str ());\n       return;\n     }\n \n-  if (!typesAreCompatible (function->return_type.get (), inferedType,\n+  if (!typesAreCompatible (function->get_return_type ().get (), inferedType,\n \t\t\t   expr.get_locus_slow ()))\n     {\n       return;\n@@ -920,25 +920,25 @@ TypeResolution::visit (AST::Function &function)\n {\n   // always emit the function with return type in the event of nil return type\n   // its  a marker for a void function\n-  scope.InsertType (function.function_name, function.return_type.get ());\n-  scope.InsertFunction (function.function_name, &function);\n+  scope.InsertType (function.get_function_name (), function.get_return_type ().get ());\n+  scope.InsertFunction (function.get_function_name (), &function);\n   scope.PushFunction (&function);\n   scope.Push ();\n \n-  for (auto &param : function.function_params)\n+  for (auto &param : function.get_function_params ())\n     {\n-      if (!isTypeInScope (param.type.get (), param.locus))\n+      if (!isTypeInScope (param.get_type ().get (), param.get_locus ()))\n \t{\n \t  scope.Pop ();\n \t  scope.PopFunction ();\n \t  return;\n \t}\n \n       auto before = letPatternBuffer.size ();\n-      param.param_name->accept_vis (*this);\n+      param.get_pattern ()->accept_vis (*this);\n       if (letPatternBuffer.size () <= before)\n \t{\n-\t  rust_error_at (param.locus, \"failed to analyse parameter name\");\n+\t  rust_error_at (param.get_locus (), \"failed to analyse parameter name\");\n \n \t  scope.Pop ();\n \t  scope.PopFunction ();\n@@ -947,13 +947,13 @@ TypeResolution::visit (AST::Function &function)\n \n       auto paramName = letPatternBuffer.back ();\n       letPatternBuffer.pop_back ();\n-      scope.InsertType (paramName.variable_ident, param.type.get ());\n+      scope.InsertType (paramName.get_ident (), param.get_type ().get ());\n     }\n \n   // ensure the return type is resolved\n-  if (function.has_function_return_type ())\n+  if (function.has_return_type ())\n     {\n-      if (!isTypeInScope (function.return_type.get (), function.locus))\n+      if (!isTypeInScope (function.get_return_type ().get (), function.get_locus ()))\n \t{\n \t  scope.Pop ();\n \t  scope.PopFunction ();\n@@ -962,7 +962,7 @@ TypeResolution::visit (AST::Function &function)\n     }\n \n   // walk the expression body\n-  for (auto &stmt : function.function_body->statements)\n+  for (auto &stmt : function.get_definition ()->get_statements ())\n     {\n       stmt->accept_vis (*this);\n     }\n@@ -982,9 +982,9 @@ TypeResolution::visit (AST::TypeAlias &type_alias)\n void\n TypeResolution::visit (AST::StructStruct &struct_item)\n {\n-  for (auto &field : struct_item.fields)\n+  for (auto &field : struct_item.get_fields ())\n     {\n-      if (!isTypeInScope (field.field_type.get (),\n+      if (!isTypeInScope (field.get_field_type ().get (),\n \t\t\t  Linemap::unknown_location ()))\n \t{\n \t  rust_fatal_error (Linemap::unknown_location (),\n@@ -993,7 +993,7 @@ TypeResolution::visit (AST::StructStruct &struct_item)\n \t}\n     }\n \n-  scope.InsertStruct (struct_item.struct_name, &struct_item);\n+  scope.InsertStruct (struct_item.get_struct_name (), &struct_item);\n }\n \n void\n@@ -1177,7 +1177,7 @@ TypeResolution::visit (AST::LetStmt &stmt)\n   scope.InsertLocal (stmt.as_string (), &stmt);\n   if (!stmt.has_init_expr () && !stmt.has_type ())\n     {\n-      rust_error_at (stmt.locus,\n+      rust_error_at (stmt.get_locus (),\n \t\t     \"E0282: type annotations or init expression needed\");\n       return;\n     }\n@@ -1186,12 +1186,12 @@ TypeResolution::visit (AST::LetStmt &stmt)\n   if (stmt.has_init_expr ())\n     {\n       auto before = typeBuffer.size ();\n-      stmt.init_expr->accept_vis (*this);\n+      stmt.get_init_expr ()->accept_vis (*this);\n \n       if (typeBuffer.size () <= before)\n \t{\n \t  rust_error_at (\n-\t    stmt.init_expr->get_locus_slow (),\n+\t    stmt.get_init_expr ()->get_locus_slow (),\n \t    \"unable to determine type for declaration from init expr\");\n \t  return;\n \t}\n@@ -1201,27 +1201,27 @@ TypeResolution::visit (AST::LetStmt &stmt)\n \n       if (inferedType == NULL)\n \t{\n-\t  rust_error_at (stmt.init_expr->get_locus_slow (),\n+\t  rust_error_at (stmt.get_init_expr ()->get_locus_slow (),\n \t\t\t \"void type found for statement initialisation\");\n \t  return;\n \t}\n     }\n \n   if (stmt.has_type () && stmt.has_init_expr ())\n     {\n-      if (!typesAreCompatible (stmt.type.get (), inferedType,\n-\t\t\t       stmt.init_expr->get_locus_slow ()))\n+      if (!typesAreCompatible (stmt.get_type ().get (), inferedType,\n+\t\t\t       stmt.get_init_expr ()->get_locus_slow ()))\n \t{\n \t  return;\n \t}\n     }\n   else if (stmt.has_type ())\n     {\n       auto before = typeComparisonBuffer.size ();\n-      stmt.type->accept_vis (*this);\n+      stmt.get_type ()->accept_vis (*this);\n       if (typeComparisonBuffer.size () <= before)\n \t{\n-\t  rust_error_at (stmt.locus, \"failed to understand type for lhs\");\n+\t  rust_error_at (stmt.get_locus (), \"failed to understand type for lhs\");\n \t  return;\n \t}\n       auto typeString = typeComparisonBuffer.back ();\n@@ -1241,7 +1241,7 @@ TypeResolution::visit (AST::LetStmt &stmt)\n       inferedType->accept_vis (*this);\n       if (typeComparisonBuffer.size () <= before)\n \t{\n-\t  rust_error_at (stmt.locus, \"failed to understand type for lhs\");\n+\t  rust_error_at (stmt.get_locus (), \"failed to understand type for lhs\");\n \t  return;\n \t}\n       auto typeString = typeComparisonBuffer.back ();\n@@ -1250,14 +1250,14 @@ TypeResolution::visit (AST::LetStmt &stmt)\n       // AST::Type *val = NULL;\n       // if (!scope.LookupType (typeString, &val))\n       //   {\n-      //     rust_error_at (stmt.locus, \"Inferred unknown type: %s\",\n+      //     rust_error_at (stmt.get_locus (), \"Inferred unknown type: %s\",\n       //   \t\t inferedType->as_string ().c_str ());\n       //     return;\n       //   }\n     }\n   else\n     {\n-      rust_fatal_error (stmt.locus, \"Failed to determine any type for LetStmt\");\n+      rust_fatal_error (stmt.get_locus (), \"Failed to determine any type for LetStmt\");\n       return;\n     }\n \n@@ -1268,24 +1268,24 @@ TypeResolution::visit (AST::LetStmt &stmt)\n     }\n \n   // get all the names part of this declaration and add the types to the scope\n-  stmt.variables_pattern->accept_vis (*this);\n+  stmt.get_pattern ()->accept_vis (*this);\n   for (auto &pattern : letPatternBuffer)\n-    scope.InsertType (pattern.variable_ident, inferedType);\n+    scope.InsertType (pattern.get_ident (), inferedType);\n \n   letPatternBuffer.clear ();\n }\n \n void\n TypeResolution::visit (AST::ExprStmtWithoutBlock &stmt)\n {\n-  stmt.expr->accept_vis (*this);\n+  stmt.get_expr ()->accept_vis (*this);\n }\n \n void\n TypeResolution::visit (AST::ExprStmtWithBlock &stmt)\n {\n   scope.Push ();\n-  stmt.expr->accept_vis (*this);\n+  stmt.get_expr ()->accept_vis (*this);\n   auto localMap = scope.PeekLocals ();\n   for (auto &[_, value] : localMap)\n     {\n@@ -1331,7 +1331,7 @@ TypeResolution::visit (AST::ReferenceType &type)\n void\n TypeResolution::visit (AST::ArrayType &type)\n {\n-  typeComparisonBuffer.push_back (type.get_element_type ()->as_string ());\n+  typeComparisonBuffer.push_back (type.get_elem_type ()->as_string ());\n }\n \n void"}, {"sha": "2f61a39418110b7136431c7cb153c0cdd9db3cbf", "filename": "gcc/rust/analysis/rust-type-resolution.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc/gcc%2Frust%2Fanalysis%2Frust-type-resolution.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc/gcc%2Frust%2Fanalysis%2Frust-type-resolution.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-type-resolution.h?ref=6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc", "patch": "@@ -326,8 +326,8 @@ class TypeResolution : public Resolution\n   bool isTypeInScope (AST::Type *type, Location locus);\n \n   TypeScoping scope;\n-  std::string *identifierBuffer;\n-  int *tupleIndexBuffer;\n+  std::unique_ptr<std::string> identifierBuffer;\n+  std::unique_ptr<int> tupleIndexBuffer;\n };\n \n } // namespace Analysis"}, {"sha": "030b0b3707e41ddb9225423dd81d3ce22a91f64e", "filename": "gcc/rust/ast/rust-ast-full-test.cc", "status": "modified", "additions": 285, "deletions": 219, "changes": 504, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-test.cc?ref=6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc", "patch": "@@ -171,13 +171,33 @@ Attribute::as_string () const\n {\n   std::string path_str = path.as_string ();\n   if (attr_input == nullptr)\n-    {\n-      return path_str;\n-    }\n+    return path_str;\n   else\n-    {\n-      return path_str + attr_input->as_string ();\n-    }\n+    return path_str + attr_input->as_string ();\n+}\n+\n+// Copy constructor must deep copy attr_input as unique pointer\n+Attribute::Attribute (Attribute const &other)\n+  : path (other.path), locus (other.locus)\n+{\n+  // guard to protect from null pointer dereference\n+  if (other.attr_input != nullptr)\n+    attr_input = other.attr_input->clone_attr_input ();\n+}\n+\n+// overload assignment operator to use custom clone method\n+Attribute &\n+Attribute::operator= (Attribute const &other)\n+{\n+  path = other.path;\n+  locus = other.locus;\n+  // guard to protect from null pointer dereference\n+  if (other.attr_input != nullptr)\n+    attr_input = other.attr_input->clone_attr_input ();\n+  else\n+    attr_input = nullptr;\n+\n+  return *this;\n }\n \n std::string\n@@ -307,7 +327,13 @@ std::string\n VisItem::as_string () const\n {\n   // FIXME: can't do formatting on string to make identation occur.\n-  std::string str = Item::as_string ();\n+  std::string str;\n+\n+  if (!outer_attrs.empty ())\n+    {\n+      for (const auto &attr : outer_attrs)\n+\tstr += attr.as_string () + \"\\n\";\n+    }\n \n   if (has_visibility ())\n     {\n@@ -318,7 +344,7 @@ VisItem::as_string () const\n }\n \n // Creates a string that reflects the outer attributes stored.\n-std::string\n+/*std::string\n Item::as_string () const\n {\n   std::string str;\n@@ -332,7 +358,7 @@ Item::as_string () const\n     }\n \n   return str;\n-}\n+}*/\n \n std::string\n Module::as_string () const\n@@ -654,33 +680,23 @@ Method::as_string () const\n   else\n     {\n       for (const auto &param : function_params)\n-\t{\n-\t  str += \"\\n  \" + param.as_string ();\n-\t}\n+\tstr += \"\\n  \" + param.as_string ();\n     }\n \n   str += \"\\n Return type: \";\n   if (has_return_type ())\n-    {\n-      str += return_type->as_string ();\n-    }\n+    str += return_type->as_string ();\n   else\n-    {\n-      str += \"none (void)\";\n-    }\n+    str += \"none (void)\";\n \n   str += \"\\n Where clause: \";\n   if (has_where_clause ())\n-    {\n-      str += where_clause.as_string ();\n-    }\n+    str += where_clause.as_string ();\n   else\n-    {\n-      str += \"none\";\n-    }\n+    str += \"none\";\n \n   str += \"\\n Block expr (body): \\n  \";\n-  str += expr->as_string ();\n+  str += function_body->as_string ();\n \n   return str;\n }\n@@ -1089,7 +1105,7 @@ Function::as_string () const\n   if (\"\" != qstr)\n     str += qstr + \" \";\n \n-  if (has_function_return_type ())\n+  if (has_return_type ())\n     {\n       // DEBUG: null pointer check\n       if (return_type == nullptr)\n@@ -1154,9 +1170,7 @@ Function::as_string () const\n     }\n \n   if (has_where_clause ())\n-    {\n-      str += \" where \" + where_clause.as_string ();\n-    }\n+    str += \" where \" + where_clause.as_string ();\n \n   str += \"\\n\";\n \n@@ -1187,9 +1201,7 @@ WhereClause::as_string () const\n   else\n     {\n       for (const auto &item : where_clause_items)\n-\t{\n-\t  str += \"\\n  \" + item->as_string ();\n-\t}\n+\tstr += \"\\n  \" + item->as_string ();\n     }\n \n   return str;\n@@ -1214,9 +1226,7 @@ BlockExpr::as_string () const\n       /* note that this does not print them with \"inner attribute\" syntax -\n        * just the body */\n       for (const auto &attr : inner_attrs)\n-\t{\n-\t  str += \"\\n\" + indent_spaces (stay) + attr.as_string ();\n-\t}\n+\tstr += \"\\n\" + indent_spaces (stay) + attr.as_string ();\n     }\n \n   // statements\n@@ -1246,13 +1256,9 @@ BlockExpr::as_string () const\n   // final expression\n   str += \"\\n\" + indent_spaces (stay) + \"final expression: \";\n   if (expr == nullptr)\n-    {\n-      str += \"none\";\n-    }\n+    str += \"none\";\n   else\n-    {\n-      str += \"\\n\" + expr->as_string ();\n-    }\n+    str += \"\\n\" + expr->as_string ();\n \n   str += \"\\n\" + indent_spaces (out) + \"}\";\n   return str;\n@@ -1264,9 +1270,7 @@ TraitImpl::as_string () const\n   std::string str = VisItem::as_string ();\n \n   if (has_unsafe)\n-    {\n-      str += \"unsafe \";\n-    }\n+    str += \"unsafe \";\n \n   str += \"impl \";\n \n@@ -1279,34 +1283,24 @@ TraitImpl::as_string () const\n   else\n     {\n       for (const auto &param : generic_params)\n-\t{\n-\t  str += \"\\n  \" + param->as_string ();\n-\t}\n+\tstr += \"\\n  \" + param->as_string ();\n     }\n \n   str += \"\\n Has exclam: \";\n   if (has_exclam)\n-    {\n-      str += \"true\";\n-    }\n+    str += \"true\";\n   else\n-    {\n-      str += \"false\";\n-    }\n+    str += \"false\";\n \n   str += \"\\n TypePath (to trait): \" + trait_path.as_string ();\n \n   str += \"\\n Type (struct to impl on): \" + trait_type->as_string ();\n \n   str += \"\\n Where clause: \";\n   if (!has_where_clause ())\n-    {\n-      str += \"none\";\n-    }\n+    str += \"none\";\n   else\n-    {\n-      str += where_clause.as_string ();\n-    }\n+    str += where_clause.as_string ();\n \n   // inner attributes\n   str += \"\\n inner attributes: \";\n@@ -1319,9 +1313,7 @@ TraitImpl::as_string () const\n       /* note that this does not print them with \"inner attribute\" syntax -\n        * just the body */\n       for (const auto &attr : inner_attrs)\n-\t{\n-\t  str += \"\\n  \" + attr.as_string ();\n-\t}\n+\tstr += \"\\n  \" + attr.as_string ();\n     }\n \n   str += \"\\n trait impl items: \";\n@@ -1332,9 +1324,7 @@ TraitImpl::as_string () const\n   else\n     {\n       for (const auto &item : impl_items)\n-\t{\n-\t  str += \"\\n  \" + item->as_string ();\n-\t}\n+\tstr += \"\\n  \" + item->as_string ();\n     }\n \n   return str;\n@@ -1384,8 +1374,14 @@ TypeAlias::as_string () const\n std::string\n MacroInvocationSemi::as_string () const\n {\n+  std::string str;\n+\n   // get outer attrs\n-  std::string str = MacroItem::as_string ();\n+  if (!outer_attrs.empty ())\n+    {\n+      for (const auto &attr : outer_attrs)\n+\tstr += attr.as_string () + \"\\n\";\n+    }\n \n   str += \"\\n\" + path.as_string () + \"!\";\n \n@@ -1444,9 +1440,7 @@ ExternBlock::as_string () const\n       /* note that this does not print them with \"inner attribute\" syntax -\n        * just the body */\n       for (const auto &attr : inner_attrs)\n-\t{\n-\t  str += \"\\n  \" + attr.as_string ();\n-\t}\n+\tstr += \"\\n  \" + attr.as_string ();\n     }\n \n   str += \"\\n external items: \";\n@@ -1457,9 +1451,7 @@ ExternBlock::as_string () const\n   else\n     {\n       for (const auto &item : extern_items)\n-\t{\n-\t  str += \"\\n  \" + item->as_string ();\n-\t}\n+\tstr += \"\\n  \" + item->as_string ();\n     }\n \n   return str;\n@@ -1482,7 +1474,16 @@ MacroRule::as_string () const\n std::string\n MacroRulesDefinition::as_string () const\n {\n-  std::string str (\"macro_rules!\");\n+  std::string str;\n+\n+  // get outer attrs\n+  if (!outer_attrs.empty ())\n+    {\n+      for (const auto &attr : outer_attrs)\n+\tstr += attr.as_string () + \"\\n\";\n+    }\n+\n+  str += \"macro_rules!\";\n \n   str += rule_name;\n \n@@ -1494,9 +1495,7 @@ MacroRulesDefinition::as_string () const\n   else\n     {\n       for (const auto &rule : rules)\n-\t{\n-\t  str += \"\\n  \" + rule.as_string ();\n-\t}\n+\tstr += \"\\n  \" + rule.as_string ();\n     }\n \n   str += \"\\n Delim type: \";\n@@ -1531,9 +1530,7 @@ PathInExpression::as_string () const\n   std::string str;\n \n   if (has_opening_scope_resolution)\n-    {\n-      str = \"::\";\n-    }\n+    str = \"::\";\n \n   return str + PathPattern::as_string ();\n }\n@@ -1564,9 +1561,7 @@ ClosureParam::as_string () const\n   std::string str (pattern->as_string ());\n \n   if (has_type_given ())\n-    {\n-      str += \" : \" + type->as_string ();\n-    }\n+    str += \" : \" + type->as_string ();\n \n   return str;\n }\n@@ -1576,13 +1571,9 @@ ClosureExpr::as_string () const\n {\n   std::string str (\"ClosureExpr:\\n Has move: \");\n   if (has_move)\n-    {\n-      str += \"true\";\n-    }\n+    str += \"true\";\n   else\n-    {\n-      str += \"false\";\n-    }\n+    str += \"false\";\n \n   str += \"\\n Params: \";\n   if (params.empty ())\n@@ -1592,9 +1583,7 @@ ClosureExpr::as_string () const\n   else\n     {\n       for (const auto &param : params)\n-\t{\n-\t  str += \"\\n  \" + param.as_string ();\n-\t}\n+\tstr += \"\\n  \" + param.as_string ();\n     }\n \n   return str;\n@@ -1618,9 +1607,7 @@ PathPattern::as_string () const\n   std::string str;\n \n   for (const auto &segment : segments)\n-    {\n-      str += segment.as_string () + \"::\";\n-    }\n+    str += segment.as_string () + \"::\";\n \n   // basically a hack - remove last two characters of string (remove final ::)\n   str.erase (str.length () - 2);\n@@ -1635,9 +1622,7 @@ QualifiedPathType::as_string () const\n   str += type_to_invoke_on->as_string ();\n \n   if (has_as_clause ())\n-    {\n-      str += \" as \" + trait_path.as_string ();\n-    }\n+    str += \" as \" + trait_path.as_string ();\n \n   return str + \">\";\n }\n@@ -1654,14 +1639,10 @@ BorrowExpr::as_string () const\n   std::string str (\"&\");\n \n   if (double_borrow)\n-    {\n-      str += \"&\";\n-    }\n+    str += \"&\";\n \n   if (is_mut)\n-    {\n-      str += \"mut \";\n-    }\n+    str += \"mut \";\n \n   str += main_or_left_expr->as_string ();\n \n@@ -1673,10 +1654,8 @@ ReturnExpr::as_string () const\n {\n   std::string str (\"return \");\n \n-  if (has_return_expr ())\n-    {\n-      str += return_expr->as_string ();\n-    }\n+  if (has_returned_expr ())\n+    str += return_expr->as_string ();\n \n   return str;\n }\n@@ -1697,9 +1676,7 @@ GroupedExpr::as_string () const\n       /* note that this does not print them with \"inner attribute\" syntax -\n        * just the body */\n       for (const auto &attr : inner_attrs)\n-\t{\n-\t  str += \"\\n  \" + attr.as_string ();\n-\t}\n+\tstr += \"\\n  \" + attr.as_string ();\n     }\n \n   str += \"\\n Expr in parens: \" + expr_in_parens->as_string ();\n@@ -1719,9 +1696,7 @@ ContinueExpr::as_string () const\n   std::string str (\"continue \");\n \n   if (has_label ())\n-    {\n-      str += label.as_string ();\n-    }\n+    str += label.as_string ();\n \n   return str;\n }\n@@ -1856,9 +1831,7 @@ MethodCallExpr::as_string () const\n       for (const auto &param : params)\n \t{\n \t  if (param == nullptr)\n-\t    {\n-\t      return \"ERROR_MARK_STRING - method call expr param is null\";\n-\t    }\n+\t    return \"ERROR_MARK_STRING - method call expr param is null\";\n \n \t  str += \"\\n  \" + param->as_string ();\n \t}\n@@ -1997,9 +1970,7 @@ IfLetExpr::as_string () const\n   else\n     {\n       for (const auto &pattern : match_arm_patterns)\n-\t{\n-\t  str += \"\\n  \" + pattern->as_string ();\n-\t}\n+\tstr += \"\\n  \" + pattern->as_string ();\n     }\n \n   str += \"\\n Scrutinee expr: \" + value->as_string ();\n@@ -2188,9 +2159,7 @@ CallExpr::as_string () const\n       for (const auto &param : params)\n \t{\n \t  if (param == nullptr)\n-\t    {\n-\t      return \"ERROR_MARK_STRING - call expr param is null\";\n-\t    }\n+\t    return \"ERROR_MARK_STRING - call expr param is null\";\n \n \t  str += \"\\n  \" + param->as_string ();\n \t}\n@@ -2206,13 +2175,9 @@ WhileLoopExpr::as_string () const\n \n   str += \"\\n Label: \";\n   if (!has_loop_label ())\n-    {\n-      str += \"none\";\n-    }\n+    str += \"none\";\n   else\n-    {\n-      str += loop_label.as_string ();\n-    }\n+    str += loop_label.as_string ();\n \n   str += \"\\n Conditional expr: \" + condition->as_string ();\n \n@@ -2228,13 +2193,9 @@ WhileLetLoopExpr::as_string () const\n \n   str += \"\\n Label: \";\n   if (!has_loop_label ())\n-    {\n-      str += \"none\";\n-    }\n+    str += \"none\";\n   else\n-    {\n-      str += loop_label.as_string ();\n-    }\n+    str += loop_label.as_string ();\n \n   str += \"\\n Match arm patterns: \";\n   if (match_arm_patterns.empty ())\n@@ -2244,12 +2205,10 @@ WhileLetLoopExpr::as_string () const\n   else\n     {\n       for (const auto &pattern : match_arm_patterns)\n-\t{\n-\t  str += \"\\n  \" + pattern->as_string ();\n-\t}\n+\tstr += \"\\n  \" + pattern->as_string ();\n     }\n \n-  str += \"\\n Scrutinee expr: \" + condition->as_string ();\n+  str += \"\\n Scrutinee expr: \" + scrutinee->as_string ();\n \n   str += \"\\n Loop block: \" + loop_block->as_string ();\n \n@@ -2263,13 +2222,9 @@ LoopExpr::as_string () const\n \n   str += \"\\n Label: \";\n   if (!has_loop_label ())\n-    {\n-      str += \"none\";\n-    }\n+    str += \"none\";\n   else\n-    {\n-      str += loop_label.as_string ();\n-    }\n+    str += loop_label.as_string ();\n \n   str += \"\\n Loop block: \" + loop_block->as_string ();\n \n@@ -2292,20 +2247,14 @@ ArrayExpr::as_string () const\n       /* note that this does not print them with \"inner attribute\" syntax -\n        * just the body */\n       for (const auto &attr : inner_attrs)\n-\t{\n-\t  str += \"\\n  \" + attr.as_string ();\n-\t}\n+\tstr += \"\\n  \" + attr.as_string ();\n     }\n \n   str += \"\\n Array elems: \";\n   if (!has_array_elems ())\n-    {\n-      str += \"none\";\n-    }\n+    str += \"none\";\n   else\n-    {\n-      str += internal_elements->as_string ();\n-    }\n+    str += internal_elements->as_string ();\n \n   return str;\n }\n@@ -2322,14 +2271,10 @@ BreakExpr::as_string () const\n   std::string str (\"break \");\n \n   if (has_label ())\n-    {\n-      str += label.as_string () + \" \";\n-    }\n+    str += label.as_string () + \" \";\n \n   if (has_break_expr ())\n-    {\n-      str += break_expr->as_string ();\n-    }\n+    str += break_expr->as_string ();\n \n   return str;\n }\n@@ -2354,9 +2299,7 @@ MatchArm::as_string () const\n       /* note that this does not print them with \"outer attribute\" syntax -\n        * just the body */\n       for (const auto &attr : outer_attrs)\n-\t{\n-\t  str += \"\\n \" + attr.as_string ();\n-\t}\n+\tstr += \"\\n \" + attr.as_string ();\n     }\n \n   str += \"\\nPatterns: \";\n@@ -2367,20 +2310,14 @@ MatchArm::as_string () const\n   else\n     {\n       for (const auto &pattern : match_arm_patterns)\n-\t{\n-\t  str += \"\\n \" + pattern->as_string ();\n-\t}\n+\tstr += \"\\n \" + pattern->as_string ();\n     }\n \n   str += \"\\nGuard expr: \";\n   if (!has_match_arm_guard ())\n-    {\n-      str += \"none\";\n-    }\n+    str += \"none\";\n   else\n-    {\n-      str += guard_expr->as_string ();\n-    }\n+    str += guard_expr->as_string ();\n \n   return str;\n }\n@@ -3694,9 +3631,7 @@ StructExprTuple::as_string () const\n       /* note that this does not print them with \"inner attribute\" syntax -\n        * just the body */\n       for (const auto &attr : inner_attrs)\n-\t{\n-\t  str += \"\\n\" + indent_spaces (stay) + attr.as_string ();\n-\t}\n+\tstr += \"\\n\" + indent_spaces (stay) + attr.as_string ();\n     }\n   indent_spaces (out);\n   indent_spaces (out);\n@@ -3722,9 +3657,7 @@ StructExprStruct::as_string () const\n       /* note that this does not print them with \"inner attribute\" syntax -\n        * just the body */\n       for (const auto &attr : inner_attrs)\n-\t{\n-\t  str += \"\\n  \" + attr.as_string ();\n-\t}\n+\tstr += \"\\n  \" + attr.as_string ();\n     }\n \n   return str;\n@@ -3734,13 +3667,9 @@ std::string\n StructBase::as_string () const\n {\n   if (base_struct != nullptr)\n-    {\n-      return base_struct->as_string ();\n-    }\n+    return base_struct->as_string ();\n   else\n-    {\n-      return \"ERROR_MARK_STRING - invalid struct base had as string applied\";\n-    }\n+    return \"ERROR_MARK_STRING - invalid struct base had as string applied\";\n }\n \n std::string\n@@ -3775,24 +3704,58 @@ StructExprStructFields::as_string () const\n   else\n     {\n       for (const auto &field : fields)\n-\t{\n-\t  str += \"\\n  \" + field->as_string ();\n-\t}\n+\tstr += \"\\n  \" + field->as_string ();\n     }\n \n   str += \"\\n Struct base: \";\n   if (!has_struct_base ())\n+    str += \"none\";\n+  else\n+    str += struct_base.as_string ();\n+\n+  return str;\n+}\n+\n+std::string\n+EnumExprStruct::as_string () const\n+{\n+  std::string str (\"StructExprStruct (or subclass): \");\n+\n+  str += \"\\n Path: \" + get_enum_variant_path ().as_string ();\n+\n+  str += \"\\n Fields: \";\n+  if (fields.empty ())\n     {\n       str += \"none\";\n     }\n   else\n     {\n-      str += struct_base.as_string ();\n+      for (const auto &field : fields)\n+\tstr += \"\\n  \" + field->as_string ();\n     }\n \n   return str;\n }\n \n+std::string\n+EnumExprFieldWithVal::as_string () const\n+{\n+  // used to get value string\n+  return value->as_string ();\n+}\n+\n+std::string\n+EnumExprFieldIdentifierValue::as_string () const\n+{\n+  return field_name + \" : \" + EnumExprFieldWithVal::as_string ();\n+}\n+\n+std::string\n+EnumExprFieldIndexValue::as_string () const\n+{\n+  return std::to_string (index) + \" : \" + EnumExprFieldWithVal::as_string ();\n+}\n+\n std::string\n EnumItem::as_string () const\n {\n@@ -3807,9 +3770,7 @@ EnumItem::as_string () const\n       /* note that this does not print them with \"outer attribute\" syntax -\n        * just the body */\n       for (const auto &attr : outer_attrs)\n-\t{\n-\t  str += \"\\n  \" + attr.as_string ();\n-\t}\n+\tstr += \"\\n  \" + attr.as_string ();\n     }\n \n   str += \"\\n\" + variant_name;\n@@ -3942,6 +3903,7 @@ EnumItemDiscriminant::as_string () const\n   return str;\n }\n \n+#if 0\n std::string\n ExternalItem::as_string () const\n {\n@@ -3956,31 +3918,43 @@ ExternalItem::as_string () const\n       /* note that this does not print them with \"outer attribute\" syntax -\n        * just the body */\n       for (const auto &attr : outer_attrs)\n-\t{\n \t  str += \"\\n  \" + attr.as_string ();\n-\t}\n     }\n \n   // start visibility on new line and with a space\n   str += \"\\n\" + visibility.as_string () + \" \";\n \n   return str;\n }\n+#endif\n \n std::string\n ExternalStaticItem::as_string () const\n {\n-  std::string str = ExternalItem::as_string ();\n+  // outer attributes\n+  std::string str = \"outer attributes: \";\n+  if (outer_attrs.empty ())\n+    {\n+      str += \"none\";\n+    }\n+  else\n+    {\n+      /* note that this does not print them with \"outer attribute\" syntax -\n+       * just the body */\n+      for (const auto &attr : outer_attrs)\n+\tstr += \"\\n  \" + attr.as_string ();\n+    }\n+\n+  // start visibility on new line and with a space\n+  str += \"\\n\" + visibility.as_string () + \" \";\n \n   str += \"static \";\n \n   if (has_mut)\n-    {\n-      str += \"mut \";\n-    }\n+    str += \"mut \";\n \n   // add name\n-  str += get_item_name ();\n+  str += item_name;\n \n   // add type on new line\n   str += \"\\n Type: \" + item_type->as_string ();\n@@ -3991,12 +3965,27 @@ ExternalStaticItem::as_string () const\n std::string\n ExternalFunctionItem::as_string () const\n {\n-  std::string str = ExternalItem::as_string ();\n+  // outer attributes\n+  std::string str = \"outer attributes: \";\n+  if (outer_attrs.empty ())\n+    {\n+      str += \"none\";\n+    }\n+  else\n+    {\n+      /* note that this does not print them with \"outer attribute\" syntax -\n+       * just the body */\n+      for (const auto &attr : outer_attrs)\n+\tstr += \"\\n  \" + attr.as_string ();\n+    }\n+\n+  // start visibility on new line and with a space\n+  str += \"\\n\" + visibility.as_string () + \" \";\n \n   str += \"fn \";\n \n   // add name\n-  str += get_item_name ();\n+  str += item_name;\n \n   // generic params\n   str += \"\\n Generic params: \";\n@@ -4024,19 +4013,28 @@ ExternalFunctionItem::as_string () const\n \n   // function params\n   str += \"\\n Function params: \";\n-  if (function_params.empty ())\n+  if (function_params.empty () && !has_variadics)\n     {\n       str += \"none\";\n     }\n   else\n     {\n       for (const auto &param : function_params)\n-\t{\n-\t  str += \"\\n  \" + param.as_string ();\n-\t}\n+\tstr += \"\\n  \" + param.as_string ();\n+\n       if (has_variadics)\n \t{\n-\t  str += \"\\n  .. (variadic)\";\n+\t  str += \"\\n  variadic outer attrs: \";\n+\t  if (has_variadic_outer_attrs ())\n+\t    {\n+\t      for (const auto &attr : variadic_outer_attrs)\n+\t\tstr += \"\\n   \" + attr.as_string ();\n+\t    }\n+\t  else\n+\t    {\n+\t      str += \"none\";\n+\t    }\n+\t  str += \"\\n  ... (variadic)\";\n \t}\n     }\n \n@@ -4046,21 +4044,29 @@ ExternalFunctionItem::as_string () const\n   // where clause\n   str += \"\\n Where clause: \";\n   if (has_where_clause ())\n-    {\n-      str += where_clause.as_string ();\n-    }\n+    str += where_clause.as_string ();\n   else\n-    {\n-      str += \"none\";\n-    }\n+    str += \"none\";\n \n   return str;\n }\n \n std::string\n NamedFunctionParam::as_string () const\n {\n-  std::string str = name;\n+  std::string str = \"outer attributes: \";\n+\n+  if (!has_outer_attrs ())\n+    {\n+      str += \"none\";\n+    }\n+  else\n+    {\n+      for (const auto &attr : outer_attrs)\n+\tstr += \"\\n \" + attr.as_string ();\n+    }\n+\n+  str += \"\\n\" + name;\n \n   str += \"\\n Type: \" + param_type->as_string ();\n \n@@ -4730,7 +4736,8 @@ MacroParser::parse_meta_item_inner ()\n   std::vector<MetaNameValueStr> meta_name_value_str_items;\n   for (const auto &item : meta_items)\n     {\n-      std::unique_ptr<MetaNameValueStr> converted_item = item->to_meta_name_value_str ();\n+      std::unique_ptr<MetaNameValueStr> converted_item\n+\t= item->to_meta_name_value_str ();\n       if (converted_item == nullptr)\n \t{\n \t  meta_name_value_str_items.clear ();\n@@ -5048,18 +5055,21 @@ MacroParser::parse_meta_item_lit ()\n bool\n AttrInputMetaItemContainer::check_cfg_predicate (const Session &session) const\n {\n-  /* cfg value of container is purely based on cfg of each inner item - all\n-   * must be true */\n-  for (const auto &inner_item : items)\n+  /* NOTE: assuming that only first item must be true - cfg should only have one\n+   * item, and cfg_attr only has first item as predicate. TODO ensure that this\n+   * is correct. */\n+  if (items.empty ())\n+    return false;\n+\n+  return items[0]->check_cfg_predicate (session);\n+\n+  /*for (const auto &inner_item : items)\n     {\n       if (!inner_item->check_cfg_predicate (session))\n \treturn false;\n     }\n \n-  /* TODO: as far as I can tell, there should only be a single element to\n-   * check here, so ensure there is only a single element in items too? */\n-\n-  return true;\n+  return true;*/\n }\n \n bool\n@@ -5346,6 +5356,62 @@ MetaItemPathLit::to_attribute () const\n \t\t\t    new AttrInputLiteral (lit)));\n }\n \n+std::vector<Attribute>\n+AttrInputMetaItemContainer::separate_cfg_attrs () const\n+{\n+  rust_assert (!items.empty ());\n+\n+  if (items.size () == 1)\n+    return {};\n+\n+  std::vector<Attribute> attrs;\n+  attrs.reserve (items.size () - 1);\n+\n+  for (auto it = items.begin () + 1; it != items.end (); ++it)\n+    {\n+      Attribute attr = (*it)->to_attribute ();\n+      if (attr.is_empty ())\n+\t{\n+\t  // TODO should this be an error that causes us to chuck out\n+\t  // everything?\n+\t  continue;\n+\t}\n+      attrs.push_back (std::move (attr));\n+    }\n+\n+  attrs.shrink_to_fit ();\n+  return attrs;\n+}\n+\n+bool\n+Attribute::check_cfg_predicate (const Session &session)\n+{\n+  /* assume that cfg predicate actually can exist, i.e. attribute has cfg or\n+   * cfg_attr path */\n+  if (!has_attr_input ()\n+      || (path.as_string () != \"cfg\" && path.as_string () != \"cfg_attr\"))\n+    return false;\n+\n+  // TODO: maybe replace with storing a \"has been parsed\" variable?\n+  parse_attr_to_meta_item ();\n+  // can't be const because of this anyway\n+\n+  return attr_input->check_cfg_predicate (session);\n+}\n+\n+std::vector<Attribute>\n+Attribute::separate_cfg_attrs ()\n+{\n+  if (!has_attr_input () || path.as_string () != \"cfg_attr\")\n+    return {};\n+\n+  // TODO: maybe replace with storing a \"has been parsed\" variable?\n+  parse_attr_to_meta_item ();\n+  // can't be const because of this anyway\n+\n+  return attr_input->separate_cfg_attrs ();\n+}\n+\n /* Visitor implementations - these are short but inlining can't happen anyway\n  * due to virtual functions and I didn't want to make the ast header includes\n  * any longer than they already are. */"}, {"sha": "bdc1f1268df4402900fc1fc38026617bd3524faf", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 269, "deletions": 216, "changes": 485, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc", "patch": "@@ -62,32 +62,6 @@ Location?\n };*/\n // decided to not have node as a \"node\" would never need to be stored\n \n-// Attribute body - abstract base class\n-class AttrInput\n-{\n-public:\n-  virtual ~AttrInput () {}\n-\n-  // Unique pointer custom clone function\n-  std::unique_ptr<AttrInput> clone_attr_input () const\n-  {\n-    return std::unique_ptr<AttrInput> (clone_attr_input_impl ());\n-  }\n-\n-  virtual std::string as_string () const = 0;\n-\n-  virtual void accept_vis (ASTVisitor &vis) = 0;\n-\n-  virtual bool check_cfg_predicate (const Session &session) const = 0;\n-\n-  // Parse attribute input to meta item, if possible\n-  virtual AttrInput *parse_to_meta_item () const { return nullptr; }\n-\n-protected:\n-  // pure virtual clone implementation\n-  virtual AttrInput *clone_attr_input_impl () const = 0;\n-};\n-\n // forward decl for use in token tree method\n class Token;\n \n@@ -109,7 +83,7 @@ class TokenTree\n \n   /* Converts token tree to a flat token stream. Tokens must be pointer to avoid\n    * mutual dependency with Token. */\n-  virtual std::vector<std::unique_ptr<Token>> to_token_stream () const = 0;\n+  virtual std::vector<std::unique_ptr<Token> > to_token_stream () const = 0;\n \n protected:\n   // pure virtual clone implementation\n@@ -219,7 +193,7 @@ class Token : public TokenTree, public MacroMatch\n   void accept_vis (ASTVisitor &vis) override;\n \n   // Return copy of itself but in token stream form.\n-  std::vector<std::unique_ptr<Token>> to_token_stream () const override;\n+  std::vector<std::unique_ptr<Token> > to_token_stream () const override;\n \n   TokenId get_id () const { return token_id; }\n \n@@ -279,95 +253,6 @@ struct Literal\n   bool is_error () const { return value_as_string == \"\"; }\n };\n \n-// A token tree with delimiters\n-class DelimTokenTree : public TokenTree, public AttrInput\n-{\n-  DelimType delim_type;\n-  std::vector<std::unique_ptr<TokenTree>> token_trees;\n-  Location locus;\n-\n-protected:\n-  DelimTokenTree *clone_delim_tok_tree_impl () const\n-  {\n-    return new DelimTokenTree (*this);\n-  }\n-\n-  /* Use covariance to implement clone function as returning a DelimTokenTree\n-   * object */\n-  DelimTokenTree *clone_attr_input_impl () const override\n-  {\n-    return clone_delim_tok_tree_impl ();\n-  }\n-\n-  /* Use covariance to implement clone function as returning a DelimTokenTree\n-   * object */\n-  DelimTokenTree *clone_token_tree_impl () const override\n-  {\n-    return clone_delim_tok_tree_impl ();\n-  }\n-\n-public:\n-  DelimTokenTree (DelimType delim_type,\n-\t\t  std::vector<std::unique_ptr<TokenTree>> token_trees\n-\t\t  = std::vector<std::unique_ptr<TokenTree>> (),\n-\t\t  Location locus = Location ())\n-    : delim_type (delim_type), token_trees (std::move (token_trees)),\n-      locus (locus)\n-  {}\n-\n-  // Copy constructor with vector clone\n-  DelimTokenTree (DelimTokenTree const &other)\n-    : delim_type (other.delim_type), locus (other.locus)\n-  {\n-    token_trees.reserve (other.token_trees.size ());\n-    for (const auto &e : other.token_trees)\n-      token_trees.push_back (e->clone_token_tree ());\n-  }\n-\n-  // overloaded assignment operator with vector clone\n-  DelimTokenTree &operator= (DelimTokenTree const &other)\n-  {\n-    delim_type = other.delim_type;\n-    locus = other.locus;\n-\n-    token_trees.reserve (other.token_trees.size ());\n-    for (const auto &e : other.token_trees)\n-      token_trees.push_back (e->clone_token_tree ());\n-\n-    return *this;\n-  }\n-\n-  // move constructors\n-  DelimTokenTree (DelimTokenTree &&other) = default;\n-  DelimTokenTree &operator= (DelimTokenTree &&other) = default;\n-\n-  static DelimTokenTree create_empty () { return DelimTokenTree (PARENS); }\n-\n-  std::string as_string () const override;\n-\n-  void accept_vis (ASTVisitor &vis) override;\n-\n-  bool\n-  check_cfg_predicate (const Session &session ATTRIBUTE_UNUSED) const override\n-  {\n-    // this should never be called - should be converted first\n-    return false;\n-  }\n-\n-  AttrInput *parse_to_meta_item () const override;\n-\n-  std::vector<std::unique_ptr<Token>> to_token_stream () const override;\n-\n-  std::unique_ptr<DelimTokenTree> clone_delim_token_tree () const\n-  {\n-    return std::unique_ptr<DelimTokenTree> (clone_delim_tok_tree_impl ());\n-  }\n-};\n-\n-/* Forward decl - definition moved to rust-expr.h as it requires LiteralExpr to\n- * be defined */\n-class AttrInputLiteral;\n-\n /* TODO: move applicable stuff into here or just don't include it because\n  * nothing uses it A segment of a path (maybe) */\n class PathSegment\n@@ -442,7 +327,7 @@ class SimplePath\n   // does this need visitor if not polymorphic? probably not\n \n   // path-to-string comparison operator\n-  bool operator== (const std::string &rhs)\n+  bool operator== (const std::string &rhs) const\n   {\n     return !has_opening_scope_resolution && segments.size () == 1\n \t   && segments[0].as_string () == rhs;\n@@ -460,6 +345,9 @@ class SimplePath\n   }\n };\n \n+// forward decl for Attribute\n+class AttrInput;\n+\n // aka Attr\n // Attribute AST representation\n struct Attribute\n@@ -488,15 +376,17 @@ struct Attribute\n   ~Attribute () = default;\n \n   // Copy constructor must deep copy attr_input as unique pointer\n-  Attribute (Attribute const &other) : path (other.path), locus (other.locus)\n+  /*Attribute (Attribute const &other) : path (other.path), locus (other.locus)\n   {\n     // guard to protect from null pointer dereference\n     if (other.attr_input != nullptr)\n       attr_input = other.attr_input->clone_attr_input ();\n-  }\n+  }*/\n+  // no point in being defined inline as requires virtual call anyway\n+  Attribute (const Attribute &other);\n \n   // overload assignment operator to use custom clone method\n-  Attribute &operator= (Attribute const &other)\n+  /*Attribute &operator= (Attribute const &other)\n   {\n     path = other.path;\n     locus = other.locus;\n@@ -505,7 +395,9 @@ struct Attribute\n       attr_input = other.attr_input->clone_attr_input ();\n \n     return *this;\n-  }\n+  }*/\n+  // no point in being defined inline as requires virtual call anyway\n+  Attribute &operator= (const Attribute &other);\n \n   // default move semantics\n   Attribute (Attribute &&other) = default;\n@@ -581,29 +473,18 @@ struct Attribute\n   std::string as_string () const;\n \n   // TODO: does this require visitor pattern as not polymorphic?\n-\n-  // Maybe change to const-reference in future\n-  SimplePath get_path () const { return path; }\n+  \n+  const SimplePath &get_path () const { return path; }\n+  SimplePath &get_path () { return path; }\n \n   // Call to parse attribute body to meta item syntax.\n   void parse_attr_to_meta_item ();\n \n   /* Determines whether cfg predicate is true and item with attribute should not\n    * be stripped. */\n-  bool check_cfg_predicate (const Session &session)\n-  {\n-    /* assume that cfg predicate actually can exist, i.e. attribute has cfg or\n-     * cfg_attr path */\n-\n-    if (!has_attr_input ())\n-      return false;\n+  bool check_cfg_predicate (const Session &session);\n \n-    // TODO: maybe replace with storing a \"has been parsed\" variable?\n-    parse_attr_to_meta_item ();\n-    // can't be const because of this anyway\n-\n-    return attr_input->check_cfg_predicate (session);\n-  }\n+  std::vector<Attribute> separate_cfg_attrs ();\n \n protected:\n   // not virtual as currently no subclasses of Attribute, but could be in future\n@@ -613,6 +494,122 @@ struct Attribute\n   }\n };\n \n+// Attribute body - abstract base class\n+class AttrInput\n+{\n+public:\n+  virtual ~AttrInput () {}\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<AttrInput> clone_attr_input () const\n+  {\n+    return std::unique_ptr<AttrInput> (clone_attr_input_impl ());\n+  }\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (ASTVisitor &vis) = 0;\n+\n+  virtual bool check_cfg_predicate (const Session &session) const = 0;\n+\n+  // Parse attribute input to meta item, if possible\n+  virtual AttrInput *parse_to_meta_item () const { return nullptr; }\n+\n+  virtual std::vector<Attribute> separate_cfg_attrs () const { return {}; }\n+\n+protected:\n+  // pure virtual clone implementation\n+  virtual AttrInput *clone_attr_input_impl () const = 0;\n+};\n+\n+// A token tree with delimiters\n+class DelimTokenTree : public TokenTree, public AttrInput\n+{\n+  DelimType delim_type;\n+  std::vector<std::unique_ptr<TokenTree> > token_trees;\n+  Location locus;\n+\n+protected:\n+  DelimTokenTree *clone_delim_tok_tree_impl () const\n+  {\n+    return new DelimTokenTree (*this);\n+  }\n+\n+  /* Use covariance to implement clone function as returning a DelimTokenTree\n+   * object */\n+  DelimTokenTree *clone_attr_input_impl () const override\n+  {\n+    return clone_delim_tok_tree_impl ();\n+  }\n+\n+  /* Use covariance to implement clone function as returning a DelimTokenTree\n+   * object */\n+  DelimTokenTree *clone_token_tree_impl () const override\n+  {\n+    return clone_delim_tok_tree_impl ();\n+  }\n+\n+public:\n+  DelimTokenTree (DelimType delim_type,\n+\t\t  std::vector<std::unique_ptr<TokenTree> > token_trees\n+\t\t  = std::vector<std::unique_ptr<TokenTree> > (),\n+\t\t  Location locus = Location ())\n+    : delim_type (delim_type), token_trees (std::move (token_trees)),\n+      locus (locus)\n+  {}\n+\n+  // Copy constructor with vector clone\n+  DelimTokenTree (DelimTokenTree const &other)\n+    : delim_type (other.delim_type), locus (other.locus)\n+  {\n+    token_trees.reserve (other.token_trees.size ());\n+    for (const auto &e : other.token_trees)\n+      token_trees.push_back (e->clone_token_tree ());\n+  }\n+\n+  // overloaded assignment operator with vector clone\n+  DelimTokenTree &operator= (DelimTokenTree const &other)\n+  {\n+    delim_type = other.delim_type;\n+    locus = other.locus;\n+\n+    token_trees.reserve (other.token_trees.size ());\n+    for (const auto &e : other.token_trees)\n+      token_trees.push_back (e->clone_token_tree ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  DelimTokenTree (DelimTokenTree &&other) = default;\n+  DelimTokenTree &operator= (DelimTokenTree &&other) = default;\n+\n+  static DelimTokenTree create_empty () { return DelimTokenTree (PARENS); }\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  bool check_cfg_predicate (const Session &) const override\n+  {\n+    // this should never be called - should be converted first\n+    return false;\n+  }\n+\n+  AttrInput *parse_to_meta_item () const override;\n+\n+  std::vector<std::unique_ptr<Token> > to_token_stream () const override;\n+\n+  std::unique_ptr<DelimTokenTree> clone_delim_token_tree () const\n+  {\n+    return std::unique_ptr<DelimTokenTree> (clone_delim_tok_tree_impl ());\n+  }\n+};\n+\n+/* Forward decl - definition moved to rust-expr.h as it requires LiteralExpr to\n+ * be defined */\n+class AttrInputLiteral;\n+\n // Forward decl - defined in rust-macro.h\n class MetaNameValueStr;\n \n@@ -638,27 +635,30 @@ class MetaItemInner\n \n   /* HACK: used to simplify parsing - creates a copy of that type, or returns\n    * null */\n-  virtual std::unique_ptr<MetaNameValueStr> to_meta_name_value_str () const { return nullptr; }\n+  virtual std::unique_ptr<MetaNameValueStr> to_meta_name_value_str () const\n+  {\n+    return nullptr;\n+  }\n \n   // HACK: used to simplify parsing - same thing\n   virtual SimplePath to_path_item () const\n   {\n     return SimplePath::create_empty ();\n   }\n \n-  virtual Attribute to_attribute() const { return Attribute::create_empty (); }\n+  virtual Attribute to_attribute () const { return Attribute::create_empty (); }\n \n   virtual bool check_cfg_predicate (const Session &session) const = 0;\n };\n \n // Container used to store MetaItems as AttrInput (bridge-ish kinda thing)\n class AttrInputMetaItemContainer : public AttrInput\n {\n-  std::vector<std::unique_ptr<MetaItemInner>> items;\n+  std::vector<std::unique_ptr<MetaItemInner> > items;\n \n public:\n   AttrInputMetaItemContainer (\n-    std::vector<std::unique_ptr<MetaItemInner>> items)\n+    std::vector<std::unique_ptr<MetaItemInner> > items)\n     : items (std::move (items))\n   {}\n \n@@ -683,6 +683,8 @@ class AttrInputMetaItemContainer : public AttrInput\n       clone_attr_input_meta_item_container_impl ());\n   }\n \n+  std::vector<Attribute> separate_cfg_attrs () const override;\n+\n protected:\n   // Use covariance to implement clone function as returning this type\n   AttrInputMetaItemContainer *clone_attr_input_impl () const override\n@@ -764,6 +766,9 @@ class Stmt\n    * methods. */\n   virtual Location get_locus_slow () const { return Location (); }\n \n+  virtual void mark_for_strip () = 0;\n+  virtual bool is_marked_for_strip () const = 0;\n+\n protected:\n   // Clone function implementation as pure virtual method\n   virtual Stmt *clone_stmt_impl () const = 0;\n@@ -772,40 +777,29 @@ class Stmt\n // Rust \"item\" AST node (declaration of top-level/module-level allowed stuff)\n class Item : public Stmt\n {\n-  std::vector<Attribute> outer_attrs;\n-\n-  // TODO: should outer attrs be defined here or in each derived class?\n-\n public:\n   // Unique pointer custom clone function\n   std::unique_ptr<Item> clone_item () const\n   {\n     return std::unique_ptr<Item> (clone_item_impl ());\n   }\n \n-  std::string as_string () const;\n+  std::string as_string () const = 0;\n \n   /* Adds crate names to the vector passed by reference, if it can\n-   * (polymorphism). */\n+   * (polymorphism). TODO: remove, unused. */\n   virtual void\n   add_crate_name (std::vector<std::string> &names ATTRIBUTE_UNUSED) const\n   {}\n \n-  virtual void accept_vis (ASTVisitor &vis ATTRIBUTE_UNUSED) {}\n-\n protected:\n-  // Constructor\n-  Item (std::vector<Attribute> outer_attribs = std::vector<Attribute> ())\n-    : outer_attrs (std::move (outer_attribs))\n-  {}\n-\n   // Clone function implementation as pure virtual method\n   virtual Item *clone_item_impl () const = 0;\n \n   /* Save having to specify two clone methods in derived classes by making\n    * statement clone return item clone. Hopefully won't affect performance too\n    * much. */\n-  Item *clone_stmt_impl () const override { return clone_item_impl (); }\n+  Item *clone_stmt_impl () const final override { return clone_item_impl (); }\n };\n \n // forward decl of ExprWithoutBlock\n@@ -818,7 +812,9 @@ class Expr\n   std::vector<Attribute> outer_attrs;\n \n public:\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n \n   // Unique pointer custom clone function\n   std::unique_ptr<Expr> clone_expr () const\n@@ -849,6 +845,9 @@ class Expr\n \n   virtual void accept_vis (ASTVisitor &vis) = 0;\n \n+  virtual void mark_for_strip () = 0;\n+  virtual bool is_marked_for_strip () const = 0;\n+\n protected:\n   // Constructor\n   Expr (std::vector<Attribute> outer_attribs = std::vector<Attribute> ())\n@@ -882,7 +881,7 @@ class ExprWithoutBlock : public Expr\n   /* Save having to specify two clone methods in derived classes by making expr\n    * clone return exprwithoutblock clone. Hopefully won't affect performance too\n    * much. */\n-  ExprWithoutBlock *clone_expr_impl () const override\n+  ExprWithoutBlock *clone_expr_impl () const final override\n   {\n     return clone_expr_without_block_impl ();\n   }\n@@ -910,11 +909,10 @@ class ExprWithoutBlock : public Expr\n  */\n class IdentifierExpr : public ExprWithoutBlock\n {\n-public:\n   Identifier ident;\n-\n   Location locus;\n \n+public:\n   IdentifierExpr (Identifier ident, Location locus = Location (),\n \t\t  std::vector<Attribute> outer_attrs\n \t\t  = std::vector<Attribute> ())\n@@ -927,6 +925,8 @@ class IdentifierExpr : public ExprWithoutBlock\n   Location get_locus () const { return locus; }\n   Location get_locus_slow () const override { return get_locus (); }\n \n+  Identifier get_ident () const { return ident; }\n+\n   void accept_vis (ASTVisitor &vis) override;\n \n   // Clones this object.\n@@ -935,6 +935,10 @@ class IdentifierExpr : public ExprWithoutBlock\n     return std::unique_ptr<IdentifierExpr> (clone_identifier_expr_impl ());\n   }\n \n+  // \"Error state\" if ident is empty, so base stripping on this.\n+  void mark_for_strip () override { ident = {}; }\n+  bool is_marked_for_strip () const override { return ident.empty (); }\n+\n protected:\n   // Clone method implementation\n   IdentifierExpr *clone_expr_without_block_impl () const override\n@@ -946,9 +950,6 @@ class IdentifierExpr : public ExprWithoutBlock\n   {\n     return new IdentifierExpr (*this);\n   }\n-\n-  IdentifierExpr (IdentifierExpr const &other) = default;\n-  IdentifierExpr &operator= (IdentifierExpr const &other) = default;\n };\n \n // Pattern base AST node\n@@ -969,6 +970,14 @@ class Pattern\n \n   virtual void accept_vis (ASTVisitor &vis) = 0;\n \n+  // as only one kind of pattern can be stripped, have default of nothing\n+  virtual void mark_for_strip () {}\n+  virtual bool is_marked_for_strip () const { return false; }\n+\n+  /* HACK: slow way of getting location from base expression through virtual\n+   * methods. */\n+  virtual Location get_locus_slow () const = 0;\n+\n protected:\n   // Clone pattern implementation as pure virtual method\n   virtual Pattern *clone_pattern_impl () const = 0;\n@@ -994,15 +1003,18 @@ class Type\n \n   /* HACK: convert to trait bound. Virtual method overriden by classes that\n    * enable this. */\n-  virtual TraitBound *to_trait_bound (bool in_parens ATTRIBUTE_UNUSED) const\n-  {\n-    return nullptr;\n-  }\n+  virtual TraitBound *to_trait_bound (bool) const { return nullptr; }\n   /* as pointer, shouldn't require definition beforehand, only forward\n    * declaration. */\n \n   virtual void accept_vis (ASTVisitor &vis) = 0;\n \n+  // as only two kinds of types can be stripped, have default of nothing\n+  virtual void mark_for_strip () {}\n+  virtual bool is_marked_for_strip () const { return false; }\n+\n+  virtual Location get_locus_slow () const = 0;\n+\n protected:\n   // Clone function implementation as pure virtual method\n   virtual Type *clone_type_impl () const = 0;\n@@ -1025,7 +1037,7 @@ class TypeNoBounds : public Type\n   /* Save having to specify two clone methods in derived classes by making type\n    * clone return typenobounds clone. Hopefully won't affect performance too\n    * much. */\n-  TypeNoBounds *clone_type_impl () const override\n+  TypeNoBounds *clone_type_impl () const final override\n   {\n     return clone_type_no_bounds_impl ();\n   }\n@@ -1082,7 +1094,7 @@ class Lifetime : public TypeParamBound\n   {}\n \n   // Creates an \"error\" lifetime.\n-  static Lifetime error () { return Lifetime (NAMED, std::string (\"\")); }\n+  static Lifetime error () { return Lifetime (NAMED, \"\"); }\n \n   // Returns true if the lifetime is in an error state.\n   bool is_error () const\n@@ -1207,10 +1219,12 @@ class MacroItem : public Item\n {\n   /*public:\n   std::string as_string() const;*/\n+  // std::vector<Attribute> outer_attrs;\n+\n protected:\n-  MacroItem (std::vector<Attribute> outer_attribs)\n-    : Item (std::move (outer_attribs))\n-  {}\n+  /*MacroItem (std::vector<Attribute> outer_attribs)\n+    : outer_attrs (std::move (outer_attribs))\n+  {}*/\n };\n \n // Item used in trait declarations - abstract base class\n@@ -1223,21 +1237,12 @@ class TraitItem\n   // NOTE: all children should have outer attributes\n \n protected:\n-  // Constructor\n-  /*TraitItem(std::vector<Attribute> outer_attrs = std::vector<Attribute>())\n-    : outer_attrs(std::move(outer_attrs)) {}*/\n-\n   // Clone function implementation as pure virtual method\n   virtual TraitItem *clone_trait_item_impl () const = 0;\n \n public:\n   virtual ~TraitItem () {}\n \n-  // Returns whether TraitItem has outer attributes.\n-  /*bool has_outer_attrs() const {\n-      return !outer_attrs.empty();\n-  }*/\n-\n   // Unique pointer custom clone function\n   std::unique_ptr<TraitItem> clone_trait_item () const\n   {\n@@ -1247,6 +1252,9 @@ class TraitItem\n   virtual std::string as_string () const = 0;\n \n   virtual void accept_vis (ASTVisitor &vis) = 0;\n+\n+  virtual void mark_for_strip () = 0;\n+  virtual bool is_marked_for_strip () const = 0;\n };\n \n /* Abstract base class for items used within an inherent impl block (the impl\n@@ -1269,6 +1277,9 @@ class InherentImplItem\n   virtual std::string as_string () const = 0;\n \n   virtual void accept_vis (ASTVisitor &vis) = 0;\n+\n+  virtual void mark_for_strip () = 0;\n+  virtual bool is_marked_for_strip () const = 0;\n };\n \n // Abstract base class for items used in a trait impl\n@@ -1289,58 +1300,66 @@ class TraitImplItem\n   virtual std::string as_string () const = 0;\n \n   virtual void accept_vis (ASTVisitor &vis) = 0;\n+\n+  virtual void mark_for_strip () = 0;\n+  virtual bool is_marked_for_strip () const = 0;\n+};\n+\n+// Abstract base class for an item used inside an extern block\n+class ExternalItem\n+{\n+public:\n+  virtual ~ExternalItem () {}\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<ExternalItem> clone_external_item () const\n+  {\n+    return std::unique_ptr<ExternalItem> (clone_external_item_impl ());\n+  }\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (ASTVisitor &vis) = 0;\n+\n+  virtual void mark_for_strip () = 0;\n+  virtual bool is_marked_for_strip () const = 0;\n+\n+protected:\n+  // Clone function implementation as pure virtual method\n+  virtual ExternalItem *clone_external_item_impl () const = 0;\n };\n \n /* A macro invocation item (or statement) AST node (i.e. semi-coloned macro\n  * invocation) */\n class MacroInvocationSemi : public MacroItem,\n \t\t\t    public TraitItem,\n \t\t\t    public InherentImplItem,\n-\t\t\t    public TraitImplItem\n+\t\t\t    public TraitImplItem,\n+\t\t\t    public ExternalItem\n {\n+  std::vector<Attribute> outer_attrs;\n   SimplePath path;\n   // all delim types except curly must have invocation end with a semicolon\n   DelimType delim_type;\n-  std::vector<std::unique_ptr<TokenTree>> token_trees;\n+  std::vector<std::unique_ptr<TokenTree> > token_trees;\n   Location locus;\n \n public:\n   std::string as_string () const override;\n \n   MacroInvocationSemi (SimplePath macro_path, DelimType delim_type,\n-\t\t       std::vector<std::unique_ptr<TokenTree>> token_trees,\n+\t\t       std::vector<std::unique_ptr<TokenTree> > token_trees,\n \t\t       std::vector<Attribute> outer_attribs, Location locus)\n-    : MacroItem (std::move (outer_attribs)), path (std::move (macro_path)),\n+    : outer_attrs (std::move (outer_attribs)), path (std::move (macro_path)),\n       delim_type (delim_type), token_trees (std::move (token_trees)),\n       locus (locus)\n   {}\n-  /* TODO: possible issue with Item and TraitItem hierarchies both having outer\n-   * attributes\n-   * - storage inefficiency at least.\n-   * Best current idea is to make Item preferred and have TraitItem get virtual\n-   * functions for attributes or something. Or just redo the \"composition\"\n-   * approach, but then this prevents polymorphism and would entail redoing\n-   * quite a bit of the parser. */\n-\n-  // Move constructors\n-  MacroInvocationSemi (MacroInvocationSemi &&other) = default;\n-  MacroInvocationSemi &operator= (MacroInvocationSemi &&other) = default;\n-\n-  void accept_vis (ASTVisitor &vis) override;\n-\n-  // Clones this macro invocation semi.\n-  std::unique_ptr<MacroInvocationSemi> clone_macro_invocation_semi () const\n-  {\n-    return std::unique_ptr<MacroInvocationSemi> (\n-      clone_macro_invocation_semi_impl ());\n-  }\n \n-protected:\n   // Copy constructor with vector clone\n   MacroInvocationSemi (MacroInvocationSemi const &other)\n     : MacroItem (other), TraitItem (other), InherentImplItem (other),\n-      TraitImplItem (other), path (other.path), delim_type (other.delim_type),\n-      locus (other.locus)\n+      TraitImplItem (other), outer_attrs (other.outer_attrs), path (other.path),\n+      delim_type (other.delim_type), locus (other.locus)\n   {\n     token_trees.reserve (other.token_trees.size ());\n     for (const auto &e : other.token_trees)\n@@ -1354,6 +1373,7 @@ class MacroInvocationSemi : public MacroItem,\n     TraitItem::operator= (other);\n     InherentImplItem::operator= (other);\n     TraitImplItem::operator= (other);\n+    outer_attrs = other.outer_attrs;\n     path = other.path;\n     delim_type = other.delim_type;\n     locus = other.locus;\n@@ -1365,6 +1385,28 @@ class MacroInvocationSemi : public MacroItem,\n     return *this;\n   }\n \n+  // Move constructors\n+  MacroInvocationSemi (MacroInvocationSemi &&other) = default;\n+  MacroInvocationSemi &operator= (MacroInvocationSemi &&other) = default;\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // Clones this macro invocation semi.\n+  std::unique_ptr<MacroInvocationSemi> clone_macro_invocation_semi () const\n+  {\n+    return std::unique_ptr<MacroInvocationSemi> (\n+      clone_macro_invocation_semi_impl ());\n+  }\n+\n+  // Invalid if path is empty, so base stripping on that.\n+  void mark_for_strip () override { path = SimplePath::create_empty (); }\n+  bool is_marked_for_strip () const override { return path.is_empty (); }\n+\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+protected:\n   MacroInvocationSemi *clone_macro_invocation_semi_impl () const\n   {\n     return new MacroInvocationSemi (*this);\n@@ -1391,19 +1433,19 @@ class MacroInvocationSemi : public MacroItem,\n     return clone_macro_invocation_semi_impl ();\n   }\n \n-  // FIXME: remove if item impl virtual override works properly\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  /*MacroInvocationSemi* clone_statement_impl() const override {\n-      return clone_macro_invocation_semi_impl ();\n-  }*/\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   MacroInvocationSemi *clone_trait_item_impl () const override\n   {\n     return clone_macro_invocation_semi_impl ();\n   }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroInvocationSemi *clone_external_item_impl () const override\n+  {\n+    return clone_macro_invocation_semi_impl ();\n+  }\n };\n \n // A crate AST object - holds all the data for a single compilation unit\n@@ -1416,11 +1458,11 @@ struct Crate\n   // dodgy spacing required here\n   /* TODO: is it better to have a vector of items here or a module (implicit\n    * top-level one)? */\n-  std::vector<std::unique_ptr<Item>> items;\n+  std::vector<std::unique_ptr<Item> > items;\n \n public:\n   // Constructor\n-  Crate (std::vector<std::unique_ptr<Item>> items,\n+  Crate (std::vector<std::unique_ptr<Item> > items,\n \t std::vector<Attribute> inner_attrs, bool has_utf8bom = false,\n \t bool has_shebang = false)\n     : has_utf8bom (has_utf8bom), has_shebang (has_shebang),\n@@ -1459,6 +1501,17 @@ struct Crate\n \n   // Get crate representation as string (e.g. for debugging).\n   std::string as_string () const;\n+\n+  // Delete all crate information, e.g. if fails cfg.\n+  void strip_crate ()\n+  {\n+    inner_attrs.clear ();\n+    inner_attrs.shrink_to_fit ();\n+\n+    items.clear ();\n+    items.shrink_to_fit ();\n+    // TODO: is this the best way to do this?\n+  }\n };\n \n // Base path expression AST node - abstract"}, {"sha": "f86aa54e2575687c6ce473ffdde91631ccb7353f", "filename": "gcc/rust/ast/rust-expr.h", "status": "modified", "additions": 1177, "deletions": 551, "changes": 1728, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc/gcc%2Frust%2Fast%2Frust-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc/gcc%2Frust%2Fast%2Frust-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-expr.h?ref=6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc"}, {"sha": "f18124dca2c135c82429ee14b8195a63894080fe", "filename": "gcc/rust/ast/rust-item.h", "status": "modified", "additions": 1244, "deletions": 288, "changes": 1532, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc/gcc%2Frust%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc/gcc%2Frust%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-item.h?ref=6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc", "patch": "@@ -57,7 +57,7 @@ class TypeParam : public GenericParam\n \n   // bool has_type_param_bounds;\n   // TypeParamBounds type_param_bounds;\n-  std::vector<std::unique_ptr<TypeParamBound>>\n+  std::vector<std::unique_ptr<TypeParamBound> >\n     type_param_bounds; // inlined form\n \n   // bool has_type;\n@@ -76,8 +76,8 @@ class TypeParam : public GenericParam\n   bool has_outer_attribute () const { return !outer_attr.is_empty (); }\n \n   TypeParam (Identifier type_representation, Location locus = Location (),\n-\t     std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds\n-\t     = std::vector<std::unique_ptr<TypeParamBound>> (),\n+\t     std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds\n+\t     = std::vector<std::unique_ptr<TypeParamBound> > (),\n \t     std::unique_ptr<Type> type = nullptr,\n \t     Attribute outer_attr = Attribute::create_empty ())\n     : outer_attr (std::move (outer_attr)),\n@@ -89,9 +89,12 @@ class TypeParam : public GenericParam\n   // Copy constructor uses clone\n   TypeParam (TypeParam const &other)\n     : outer_attr (other.outer_attr),\n-      type_representation (other.type_representation),\n-      type (other.type->clone_type ()), locus (other.locus)\n+      type_representation (other.type_representation), locus (other.locus)\n   {\n+    // guard to prevent null pointer dereference\n+    if (other.type != nullptr)\n+      type = other.type->clone_type ();\n+\n     type_param_bounds.reserve (other.type_param_bounds.size ());\n     for (const auto &e : other.type_param_bounds)\n       type_param_bounds.push_back (e->clone_type_param_bound ());\n@@ -101,11 +104,15 @@ class TypeParam : public GenericParam\n   TypeParam &operator= (TypeParam const &other)\n   {\n     type_representation = other.type_representation;\n-    // type_param_bounds = other.type_param_bounds;\n-    type = other.type->clone_type ();\n     outer_attr = other.outer_attr;\n     locus = other.locus;\n \n+    // guard to prevent null pointer dereference\n+    if (other.type != nullptr)\n+      type = other.type->clone_type ();\n+    else\n+      type = nullptr;\n+\n     type_param_bounds.reserve (other.type_param_bounds.size ());\n     for (const auto &e : other.type_param_bounds)\n       type_param_bounds.push_back (e->clone_type_param_bound ());\n@@ -123,6 +130,24 @@ class TypeParam : public GenericParam\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Type> &get_type ()\n+  {\n+    rust_assert (type != nullptr);\n+    return type;\n+  }\n+\n+  // TODO: mutable getter seems kinda dodgy\n+  std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds ()\n+  {\n+    return type_param_bounds;\n+  }\n+  const std::vector<std::unique_ptr<TypeParamBound> > &\n+  get_type_param_bounds () const\n+  {\n+    return type_param_bounds;\n+  }\n+\n protected:\n   // Clone function implementation as (not pure) virtual method\n   TypeParam *clone_generic_param_impl () const override\n@@ -193,7 +218,7 @@ class TypeBoundWhereClauseItem : public WhereClauseItem\n \n   // bool has_type_param_bounds;\n   // TypeParamBounds type_param_bounds;\n-  std::vector<std::unique_ptr<TypeParamBound>>\n+  std::vector<std::unique_ptr<TypeParamBound> >\n     type_param_bounds; // inlined form\n \n   // should this store location info?\n@@ -207,7 +232,7 @@ class TypeBoundWhereClauseItem : public WhereClauseItem\n \n   TypeBoundWhereClauseItem (\n     std::vector<LifetimeParam> for_lifetimes, std::unique_ptr<Type> bound_type,\n-    std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds)\n+    std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds)\n     : for_lifetimes (std::move (for_lifetimes)),\n       bound_type (std::move (bound_type)),\n       type_param_bounds (std::move (type_param_bounds))\n@@ -245,6 +270,24 @@ class TypeBoundWhereClauseItem : public WhereClauseItem\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Type> &get_type ()\n+  {\n+    rust_assert (bound_type != nullptr);\n+    return bound_type;\n+  }\n+\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds ()\n+  {\n+    return type_param_bounds;\n+  }\n+  const std::vector<std::unique_ptr<TypeParamBound> > &\n+  get_type_param_bounds () const\n+  {\n+    return type_param_bounds;\n+  }\n+\n protected:\n   // Clone function implementation as (not pure) virtual method\n   TypeBoundWhereClauseItem *clone_where_clause_item_impl () const override\n@@ -257,13 +300,13 @@ class TypeBoundWhereClauseItem : public WhereClauseItem\n struct WhereClause\n {\n private:\n-  std::vector<std::unique_ptr<WhereClauseItem>> where_clause_items;\n+  std::vector<std::unique_ptr<WhereClauseItem> > where_clause_items;\n \n   // should this store location info?\n \n public:\n   WhereClause (\n-    std::vector<std::unique_ptr<WhereClauseItem>> where_clause_items)\n+    std::vector<std::unique_ptr<WhereClauseItem> > where_clause_items)\n     : where_clause_items (std::move (where_clause_items))\n   {}\n \n@@ -292,13 +335,23 @@ struct WhereClause\n   // Creates a WhereClause with no items.\n   static WhereClause create_empty ()\n   {\n-    return WhereClause (std::vector<std::unique_ptr<WhereClauseItem>> ());\n+    return WhereClause (std::vector<std::unique_ptr<WhereClauseItem> > ());\n   }\n \n   // Returns whether the WhereClause has no items.\n   bool is_empty () const { return where_clause_items.empty (); }\n \n   std::string as_string () const;\n+\n+  // TODO: this mutable getter seems kinda dodgy\n+  std::vector<std::unique_ptr<WhereClauseItem> > &get_items ()\n+  {\n+    return where_clause_items;\n+  }\n+  const std::vector<std::unique_ptr<WhereClauseItem> > &get_items () const\n+  {\n+    return where_clause_items;\n+  }\n };\n \n // A self parameter in a method\n@@ -322,6 +375,8 @@ struct SelfParam\n   {}\n   // this is ok as no outside classes can ever call this\n \n+  // TODO: self param can have outer attributes\n+\n public:\n   // Returns whether the self-param has a type field.\n   bool has_type () const { return type != nullptr; }\n@@ -332,21 +387,15 @@ struct SelfParam\n   // Returns whether the self-param is in an error state.\n   bool is_error () const\n   {\n-    return has_type () && has_lifetime ();\n+    return (has_type () && has_lifetime ()) || (has_lifetime () && !has_ref);\n     // not having either is not an error\n   }\n \n   // Creates an error state self-param.\n   static SelfParam create_error ()\n   {\n-    /* HACK: creates a dummy type. Since it's a unique pointer, it should\n-     * clean it up, but it still allocates memory, which is not ideal. */\n-    return SelfParam (Lifetime (Lifetime::STATIC), false, false,\n-\t\t      new QualifiedPathInType (\n-\t\t\tQualifiedPathInType::create_error ()));\n-    /* FIXME: is there a reason why I didn't just create a null pointer? Is it\n-     * due to error being having both a type and a lifetime? If it is, wouldn't\n-     * something like \"not has_ref and has lifetime\" for error be better? */\n+    // cannot have no ref but have a lifetime at the same time\n+    return SelfParam (Lifetime (Lifetime::STATIC), false, false, nullptr);\n   }\n \n   // Type-based self parameter (not ref, no lifetime)\n@@ -373,13 +422,16 @@ struct SelfParam\n   // Overload assignment operator to use clone\n   SelfParam &operator= (SelfParam const &other)\n   {\n-    if (other.type != nullptr)\n-      type = other.type->clone_type ();\n     is_mut = other.is_mut;\n     has_ref = other.has_ref;\n     lifetime = other.lifetime;\n     locus = other.locus;\n \n+    if (other.type != nullptr)\n+      type = other.type->clone_type ();\n+    else\n+      type = nullptr;\n+\n     return *this;\n   }\n \n@@ -390,6 +442,13 @@ struct SelfParam\n   std::string as_string () const;\n \n   Location get_locus () const { return locus; }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Type> &get_type ()\n+  {\n+    rust_assert (has_type ());\n+    return type;\n+  }\n };\n \n // Qualifiers for function, i.e. const, unsafe, extern etc.\n@@ -424,7 +483,7 @@ struct FunctionQualifiers\n     if (!this->extern_abi.empty ())\n       {\n \t// having extern is required; not having it is an implementation error\n-\tgcc_assert (has_extern);\n+\trust_assert (has_extern);\n       }\n   }\n \n@@ -434,31 +493,45 @@ struct FunctionQualifiers\n // A function parameter\n struct FunctionParam\n {\n-public:\n+private:\n+  std::vector<Attribute> outer_attrs;\n+  Location locus;\n   std::unique_ptr<Pattern> param_name;\n   std::unique_ptr<Type> type;\n \n-  Location locus;\n-\n+public:\n   FunctionParam (std::unique_ptr<Pattern> param_name,\n-\t\t std::unique_ptr<Type> param_type, Location locus)\n-    : param_name (std::move (param_name)), type (std::move (param_type)),\n-      locus (locus)\n+\t\t std::unique_ptr<Type> param_type,\n+\t\t std::vector<Attribute> outer_attrs, Location locus)\n+    : outer_attrs (std::move (outer_attrs)), locus (locus),\n+      param_name (std::move (param_name)), type (std::move (param_type))\n   {}\n \n   // Copy constructor uses clone\n-  FunctionParam (FunctionParam const &other)\n-    : param_name (other.param_name->clone_pattern ()),\n-      type (other.type->clone_type ()), locus (other.locus)\n-  {}\n+  FunctionParam (FunctionParam const &other) : locus (other.locus)\n+  {\n+    // guard to prevent nullptr dereference\n+    if (other.param_name != nullptr)\n+      param_name = other.param_name->clone_pattern ();\n+    if (other.type != nullptr)\n+      type = other.type->clone_type ();\n+  }\n \n   // Overload assignment operator to use clone\n   FunctionParam &operator= (FunctionParam const &other)\n   {\n-    param_name = other.param_name->clone_pattern ();\n-    type = other.type->clone_type ();\n     locus = other.locus;\n \n+    // guard to prevent nullptr dereference\n+    if (other.param_name != nullptr)\n+      param_name = other.param_name->clone_pattern ();\n+    else\n+      param_name = nullptr;\n+    if (other.type != nullptr)\n+      type = other.type->clone_type ();\n+    else\n+      type = nullptr;\n+\n     return *this;\n   }\n \n@@ -472,12 +545,30 @@ struct FunctionParam\n   // Creates an error FunctionParam.\n   static FunctionParam create_error ()\n   {\n-    return FunctionParam (nullptr, nullptr, Location ());\n+    return FunctionParam (nullptr, nullptr, {}, Location ());\n   }\n \n   std::string as_string () const;\n \n   Location get_locus () const { return locus; }\n+\n+  // TODO: seems kinda dodgy. Think of better way.\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Pattern> &get_pattern ()\n+  {\n+    rust_assert (param_name != nullptr);\n+    return param_name;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Type> &get_type ()\n+  {\n+    rust_assert (type != nullptr);\n+    return type;\n+  }\n };\n \n // Visibility of item - if the item has it, then it is some form of public\n@@ -581,7 +672,7 @@ class Method : public InherentImplItem, public TraitImplItem\n \n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n \n   SelfParam self_param;\n \n@@ -596,25 +687,26 @@ class Method : public InherentImplItem, public TraitImplItem\n   // bool has_where_clause;\n   WhereClause where_clause;\n \n-  std::unique_ptr<BlockExpr> expr;\n+  std::unique_ptr<BlockExpr> function_body;\n \n   Location locus;\n \n public:\n   // Returns whether the method is in an error state.\n   bool is_error () const\n   {\n-    return expr == nullptr || method_name.empty () || self_param.is_error ();\n+    return function_body == nullptr || method_name.empty ()\n+\t   || self_param.is_error ();\n   }\n \n   // Creates an error state method.\n   static Method create_error ()\n   {\n     return Method (\"\", FunctionQualifiers (FunctionQualifiers::NONE, true),\n-\t\t   std::vector<std::unique_ptr<GenericParam>> (),\n+\t\t   std::vector<std::unique_ptr<GenericParam> > (),\n \t\t   SelfParam::create_error (), std::vector<FunctionParam> (),\n \t\t   nullptr, WhereClause::create_empty (), nullptr,\n-\t\t   Visibility::create_error (), std::vector<Attribute> ());\n+\t\t   Visibility::create_error (), std::vector<Attribute> (), {});\n   }\n \n   // Returns whether the method has generic parameters.\n@@ -634,20 +726,20 @@ class Method : public InherentImplItem, public TraitImplItem\n \n   // Mega-constructor with all possible fields\n   Method (Identifier method_name, FunctionQualifiers qualifiers,\n-\t  std::vector<std::unique_ptr<GenericParam>> generic_params,\n+\t  std::vector<std::unique_ptr<GenericParam> > generic_params,\n \t  SelfParam self_param, std::vector<FunctionParam> function_params,\n \t  std::unique_ptr<Type> return_type, WhereClause where_clause,\n \t  std::unique_ptr<BlockExpr> function_body, Visibility vis,\n-\t  std::vector<Attribute> outer_attrs, Location locus = Location ())\n+\t  std::vector<Attribute> outer_attrs, Location locus)\n     : outer_attrs (std::move (outer_attrs)), vis (std::move (vis)),\n       qualifiers (std::move (qualifiers)),\n       method_name (std::move (method_name)),\n       generic_params (std::move (generic_params)),\n       self_param (std::move (self_param)),\n       function_params (std::move (function_params)),\n       return_type (std::move (return_type)),\n-      where_clause (std::move (where_clause)), expr (std::move (function_body)),\n-      locus (locus)\n+      where_clause (std::move (where_clause)),\n+      function_body (std::move (function_body)), locus (locus)\n   {}\n \n   // TODO: add constructor with less fields\n@@ -657,10 +749,16 @@ class Method : public InherentImplItem, public TraitImplItem\n     : outer_attrs (other.outer_attrs), vis (other.vis),\n       qualifiers (other.qualifiers), method_name (other.method_name),\n       self_param (other.self_param), function_params (other.function_params),\n-      return_type (other.return_type->clone_type ()),\n-      where_clause (other.where_clause), expr (other.expr->clone_block_expr ()),\n-      locus (other.locus)\n+      where_clause (other.where_clause), locus (other.locus)\n   {\n+    // guard to prevent null dereference (always required)\n+    if (other.return_type != nullptr)\n+      return_type = other.return_type->clone_type ();\n+\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.function_body != nullptr)\n+      function_body = other.function_body->clone_block_expr ();\n+\n     generic_params.reserve (other.generic_params.size ());\n     for (const auto &e : other.generic_params)\n       generic_params.push_back (e->clone_generic_param ());\n@@ -675,11 +773,21 @@ class Method : public InherentImplItem, public TraitImplItem\n     qualifiers = other.qualifiers;\n     self_param = other.self_param;\n     function_params = other.function_params;\n-    return_type = other.return_type->clone_type ();\n     where_clause = other.where_clause;\n-    expr = other.expr->clone_block_expr ();\n     locus = other.locus;\n \n+    // guard to prevent null dereference (always required)\n+    if (other.return_type != nullptr)\n+      return_type = other.return_type->clone_type ();\n+    else\n+      return_type = nullptr;\n+\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.function_body != nullptr)\n+      function_body = other.function_body->clone_block_expr ();\n+    else\n+      function_body = nullptr;\n+\n     generic_params.reserve (other.generic_params.size ());\n     for (const auto &e : other.generic_params)\n       generic_params.push_back (e->clone_generic_param ());\n@@ -695,6 +803,56 @@ class Method : public InherentImplItem, public TraitImplItem\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Invalid if block is null, so base stripping on that.\n+  void mark_for_strip () override { function_body = nullptr; }\n+  bool is_marked_for_strip () const override\n+  {\n+    return function_body == nullptr;\n+  }\n+\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+\n+  std::vector<FunctionParam> &get_function_params () { return function_params; }\n+  const std::vector<FunctionParam> &get_function_params () const\n+  {\n+    return function_params;\n+  }\n+\n+  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  {\n+    return generic_params;\n+  }\n+  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  {\n+    return generic_params;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<BlockExpr> &get_definition ()\n+  {\n+    rust_assert (function_body != nullptr);\n+    return function_body;\n+  }\n+\n+  SelfParam &get_self_param () { return self_param; }\n+  const SelfParam &get_self_param () const { return self_param; }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Type> &get_return_type ()\n+  {\n+    rust_assert (has_return_type ());\n+    return return_type;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  WhereClause &get_where_clause ()\n+  {\n+    rust_assert (has_where_clause ());\n+    return where_clause;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -715,24 +873,25 @@ class Method : public InherentImplItem, public TraitImplItem\n class VisItem : public Item\n {\n   Visibility visibility;\n+  std::vector<Attribute> outer_attrs;\n \n protected:\n   // Visibility constructor\n   VisItem (Visibility visibility,\n \t   std::vector<Attribute> outer_attrs = std::vector<Attribute> ())\n-    : Item (std::move (outer_attrs)), visibility (std::move (visibility))\n+    : visibility (std::move (visibility)), outer_attrs (std::move (outer_attrs))\n   {}\n \n   // Visibility copy constructor\n-  VisItem (VisItem const &other) : Item (other), visibility (other.visibility)\n+  VisItem (VisItem const &other)\n+    : visibility (other.visibility), outer_attrs (other.outer_attrs)\n   {}\n \n   // Overload assignment operator to clone\n   VisItem &operator= (VisItem const &other)\n   {\n-    Item::operator= (other);\n     visibility = other.visibility;\n-    // outer_attrs = other.outer_attrs;\n+    outer_attrs = other.outer_attrs;\n \n     return *this;\n   }\n@@ -747,6 +906,13 @@ class VisItem : public Item\n   bool has_visibility () const { return !visibility.is_error (); }\n \n   std::string as_string () const override;\n+\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  Visibility &get_vis () { return visibility; }\n+  const Visibility &get_vis () const { return visibility; }\n+\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n };\n \n // Rust module item - abstract base class\n@@ -767,6 +933,10 @@ class Module : public VisItem\n   std::string as_string () const override;\n \n   Location get_locus () const { return locus; }\n+\n+  // Invalid if name is empty, so base stripping on that.\n+  void mark_for_strip () override { module_name = \"\"; }\n+  bool is_marked_for_strip () const override { return module_name.empty (); }\n };\n \n // Module with a body, defined in file\n@@ -775,7 +945,7 @@ class ModuleBodied : public Module\n   // bool has_inner_attrs;\n   std::vector<Attribute> inner_attrs;\n   // bool has_items;\n-  std::vector<std::unique_ptr<Item>> items;\n+  std::vector<std::unique_ptr<Item> > items;\n \n public:\n   std::string as_string () const override;\n@@ -788,8 +958,8 @@ class ModuleBodied : public Module\n \n   // Full constructor\n   ModuleBodied (Identifier name, Location locus,\n-\t\tstd::vector<std::unique_ptr<Item>> items\n-\t\t= std::vector<std::unique_ptr<Item>> (),\n+\t\tstd::vector<std::unique_ptr<Item> > items\n+\t\t= std::vector<std::unique_ptr<Item> > (),\n \t\tVisibility visibility = Visibility::create_error (),\n \t\tstd::vector<Attribute> inner_attrs = std::vector<Attribute> (),\n \t\tstd::vector<Attribute> outer_attrs = std::vector<Attribute> ())\n@@ -830,24 +1000,33 @@ class ModuleBodied : public Module\n    * the module. */\n   void add_crate_name (std::vector<std::string> &names) const override;\n \n+  // TODO: think of better way to do this - mutable getter seems dodgy\n+  const std::vector<Attribute> &get_inner_attrs () const { return inner_attrs; }\n+  std::vector<Attribute> &get_inner_attrs () { return inner_attrs; }\n+\n+  const std::vector<std::unique_ptr<Item> > &get_items () const\n+  {\n+    return items;\n+  }\n+  std::vector<std::unique_ptr<Item> > &get_items () { return items; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n   ModuleBodied *clone_item_impl () const override\n   {\n     return new ModuleBodied (*this);\n   }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  /*virtual ModuleBodied* clone_statement_impl() const override {\n-      return new ModuleBodied(*this);\n-  }*/\n };\n \n // Module without a body, loaded from external file\n class ModuleNoBody : public Module\n {\n+  /* TODO: are modules loaded from file unique? As in, can you load the same\n+   * file into two different other files? Because this may make the difference\n+   * between simply replacing this with the module\n+   * \"definition\" (as loaded from another file) vs this having to \"reference\" a\n+   * module with body. */\n public:\n   std::string as_string () const override;\n \n@@ -867,12 +1046,6 @@ class ModuleNoBody : public Module\n   {\n     return new ModuleNoBody (*this);\n   }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  /*virtual ModuleNoBody* clone_statement_impl() const override {\n-      return new ModuleNoBody(*this);\n-  }*/\n };\n \n // Rust extern crate declaration AST node\n@@ -920,19 +1093,20 @@ class ExternCrate : public VisItem\n     names.push_back (referenced_crate);\n   }\n \n+  // Invalid if crate name is empty, so base stripping on that.\n+  void mark_for_strip () override { referenced_crate = \"\"; }\n+  bool is_marked_for_strip () const override\n+  {\n+    return referenced_crate.empty ();\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n   ExternCrate *clone_item_impl () const override\n   {\n     return new ExternCrate (*this);\n   }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  /*virtual ExternCrate* clone_statement_impl() const override {\n-      return new ExternCrate(*this);\n-  }*/\n };\n \n // The path-ish thing referred to in a use declaration - abstract base class\n@@ -985,7 +1159,7 @@ class UseTreeGlob : public UseTree\n       {\n \t// compiler implementation error if there is a path with a\n \t// non-path-prefixed use tree glob\n-\tgcc_assert (!has_path ());\n+\trust_assert (!has_path ());\n       }\n     // TODO: do path-prefixed paths also have to have a path? If so, have an\n     // assert for that too.\n@@ -1025,19 +1199,19 @@ class UseTreeList : public UseTree\n   PathType path_type;\n   SimplePath path;\n \n-  std::vector<std::unique_ptr<UseTree>> trees;\n+  std::vector<std::unique_ptr<UseTree> > trees;\n \n public:\n   UseTreeList (PathType path_type, SimplePath path,\n-\t       std::vector<std::unique_ptr<UseTree>> trees, Location locus)\n+\t       std::vector<std::unique_ptr<UseTree> > trees, Location locus)\n     : UseTree (locus), path_type (path_type), path (std::move (path)),\n       trees (std::move (trees))\n   {\n     if (this->path_type != PATH_PREFIXED)\n       {\n \t// compiler implementation error if there is a path with a\n \t// non-path-prefixed use tree glob\n-\tgcc_assert (!has_path ());\n+\trust_assert (!has_path ());\n       }\n     // TODO: do path-prefixed paths also have to have a path? If so, have an\n     // assert for that too.\n@@ -1153,19 +1327,27 @@ class UseDeclaration : public VisItem\n \n   // Copy constructor with clone\n   UseDeclaration (UseDeclaration const &other)\n-    : VisItem (other), use_tree (other.use_tree->clone_use_tree ()),\n-      locus (other.locus)\n-  {}\n+    : VisItem (other), locus (other.locus)\n+  {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.use_tree != nullptr)\n+      use_tree = other.use_tree->clone_use_tree ();\n+  }\n \n   // Overloaded assignment operator to clone\n   UseDeclaration &operator= (UseDeclaration const &other)\n   {\n     VisItem::operator= (other);\n-    use_tree = other.use_tree->clone_use_tree ();\n     // visibility = other.visibility->clone_visibility();\n     // outer_attrs = other.outer_attrs;\n     locus = other.locus;\n \n+    // guard to prevent null dereference (only required if error state)\n+    if (other.use_tree != nullptr)\n+      use_tree = other.use_tree->clone_use_tree ();\n+    else\n+      use_tree = nullptr;\n+\n     return *this;\n   }\n \n@@ -1177,19 +1359,17 @@ class UseDeclaration : public VisItem\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Invalid if use tree is null, so base stripping on that.\n+  void mark_for_strip () override { use_tree = nullptr; }\n+  bool is_marked_for_strip () const override { return use_tree == nullptr; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n   UseDeclaration *clone_item_impl () const override\n   {\n     return new UseDeclaration (*this);\n   }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  /*virtual UseDeclaration* clone_statement_impl() const override {\n-      return new UseDeclaration(*this);\n-  }*/\n };\n \n // Parameters used in a function - TODO inline?\n@@ -1202,13 +1382,12 @@ class LetStmt;\n // Rust function declaration AST node\n class Function : public VisItem, public InherentImplItem, public TraitImplItem\n {\n-public:\n   FunctionQualifiers qualifiers;\n   Identifier function_name;\n \n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n \n   // bool has_function_params;\n   // FunctionParams function_params;\n@@ -1224,6 +1403,7 @@ class Function : public VisItem, public InherentImplItem, public TraitImplItem\n \n   Location locus;\n \n+public:\n   std::vector<LetStmt *> locals;\n \n   std::string as_string () const override;\n@@ -1235,14 +1415,14 @@ class Function : public VisItem, public InherentImplItem, public TraitImplItem\n   bool has_function_params () const { return !function_params.empty (); }\n \n   // Returns whether function has return type - if not, it is void.\n-  bool has_function_return_type () const { return return_type != nullptr; }\n+  bool has_return_type () const { return return_type != nullptr; }\n \n   // Returns whether function has a where clause.\n   bool has_where_clause () const { return !where_clause.is_empty (); }\n \n   // Mega-constructor with all possible fields\n   Function (Identifier function_name, FunctionQualifiers qualifiers,\n-\t    std::vector<std::unique_ptr<GenericParam>> generic_params,\n+\t    std::vector<std::unique_ptr<GenericParam> > generic_params,\n \t    std::vector<FunctionParam> function_params,\n \t    std::unique_ptr<Type> return_type, WhereClause where_clause,\n \t    std::unique_ptr<BlockExpr> function_body, Visibility vis,\n@@ -1264,11 +1444,16 @@ class Function : public VisItem, public InherentImplItem, public TraitImplItem\n     : VisItem (other), qualifiers (other.qualifiers),\n       function_name (other.function_name),\n       function_params (other.function_params),\n-      return_type (other.return_type->clone_type ()),\n-      where_clause (other.where_clause),\n-      function_body (other.function_body->clone_block_expr ()),\n-      locus (other.locus)\n+      where_clause (other.where_clause), locus (other.locus)\n   {\n+    // guard to prevent null dereference (always required)\n+    if (other.return_type != nullptr)\n+      return_type = other.return_type->clone_type ();\n+\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.function_body != nullptr)\n+      function_body = other.function_body->clone_block_expr ();\n+\n     generic_params.reserve (other.generic_params.size ());\n     for (const auto &e : other.generic_params)\n       generic_params.push_back (e->clone_generic_param ());\n@@ -1280,15 +1465,24 @@ class Function : public VisItem, public InherentImplItem, public TraitImplItem\n     VisItem::operator= (other);\n     function_name = other.function_name;\n     qualifiers = other.qualifiers;\n-    // generic_params = other.generic_params;\n     function_params = other.function_params;\n-    return_type = other.return_type->clone_type ();\n     where_clause = other.where_clause;\n-    function_body = other.function_body->clone_block_expr ();\n     // visibility = other.visibility->clone_visibility();\n     // outer_attrs = other.outer_attrs;\n     locus = other.locus;\n \n+    // guard to prevent null dereference (always required)\n+    if (other.return_type != nullptr)\n+      return_type = other.return_type->clone_type ();\n+    else\n+      return_type = nullptr;\n+\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.function_body != nullptr)\n+      function_body = other.function_body->clone_block_expr ();\n+    else\n+      function_body = nullptr;\n+\n     generic_params.reserve (other.generic_params.size ());\n     for (const auto &e : other.generic_params)\n       generic_params.push_back (e->clone_generic_param ());\n@@ -1304,6 +1498,54 @@ class Function : public VisItem, public InherentImplItem, public TraitImplItem\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Invalid if block is null, so base stripping on that.\n+  void mark_for_strip () override { function_body = nullptr; }\n+  bool is_marked_for_strip () const override\n+  {\n+    return function_body == nullptr;\n+  }\n+\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<FunctionParam> &get_function_params () { return function_params; }\n+  const std::vector<FunctionParam> &get_function_params () const\n+  {\n+    return function_params;\n+  }\n+\n+  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  {\n+    return generic_params;\n+  }\n+  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  {\n+    return generic_params;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<BlockExpr> &get_definition ()\n+  {\n+    rust_assert (function_body != nullptr);\n+    return function_body;\n+  }\n+\n+  FunctionQualifiers get_qualifiers () const { return qualifiers; }\n+\n+  Identifier get_function_name () const { return function_name; }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  WhereClause &get_where_clause ()\n+  {\n+    rust_assert (has_where_clause ());\n+    return where_clause;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Type> &get_return_type ()\n+  {\n+    rust_assert (has_return_type ());\n+    return return_type;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -1322,12 +1564,6 @@ class Function : public VisItem, public InherentImplItem, public TraitImplItem\n   {\n     return new Function (*this);\n   }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  /*virtual Function* clone_statement_impl() const override {\n-      return new Function(*this);\n-  }*/\n };\n \n // Rust type alias (i.e. typedef) AST node\n@@ -1337,7 +1573,7 @@ class TypeAlias : public VisItem, public TraitImplItem\n \n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n \n   // bool has_where_clause;\n   WhereClause where_clause;\n@@ -1357,7 +1593,7 @@ class TypeAlias : public VisItem, public TraitImplItem\n \n   // Mega-constructor with all possible fields\n   TypeAlias (Identifier new_type_name,\n-\t     std::vector<std::unique_ptr<GenericParam>> generic_params,\n+\t     std::vector<std::unique_ptr<GenericParam> > generic_params,\n \t     WhereClause where_clause, std::unique_ptr<Type> existing_type,\n \t     Visibility vis, std::vector<Attribute> outer_attrs, Location locus)\n     : VisItem (std::move (vis), std::move (outer_attrs)),\n@@ -1370,9 +1606,12 @@ class TypeAlias : public VisItem, public TraitImplItem\n   // Copy constructor\n   TypeAlias (TypeAlias const &other)\n     : VisItem (other), new_type_name (other.new_type_name),\n-      where_clause (other.where_clause),\n-      existing_type (other.existing_type->clone_type ()), locus (other.locus)\n+      where_clause (other.where_clause), locus (other.locus)\n   {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.existing_type != nullptr)\n+      existing_type = other.existing_type->clone_type ();\n+\n     generic_params.reserve (other.generic_params.size ());\n     for (const auto &e : other.generic_params)\n       generic_params.push_back (e->clone_generic_param ());\n@@ -1383,13 +1622,17 @@ class TypeAlias : public VisItem, public TraitImplItem\n   {\n     VisItem::operator= (other);\n     new_type_name = other.new_type_name;\n-    // generic_params = other.generic_params;\n     where_clause = other.where_clause;\n-    existing_type = other.existing_type->clone_type ();\n     // visibility = other.visibility->clone_visibility();\n     // outer_attrs = other.outer_attrs;\n     locus = other.locus;\n \n+    // guard to prevent null dereference (only required if error state)\n+    if (other.existing_type != nullptr)\n+      existing_type = other.existing_type->clone_type ();\n+    else\n+      existing_type = nullptr;\n+\n     generic_params.reserve (other.generic_params.size ());\n     for (const auto &e : other.generic_params)\n       generic_params.push_back (e->clone_generic_param ());\n@@ -1405,6 +1648,36 @@ class TypeAlias : public VisItem, public TraitImplItem\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Invalid if existing type is null, so base stripping on that.\n+  void mark_for_strip () override { existing_type = nullptr; }\n+  bool is_marked_for_strip () const override\n+  {\n+    return existing_type == nullptr;\n+  }\n+\n+  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  {\n+    return generic_params;\n+  }\n+  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  {\n+    return generic_params;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  WhereClause &get_where_clause ()\n+  {\n+    rust_assert (has_where_clause ());\n+    return where_clause;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Type> &get_type_aliased ()\n+  {\n+    rust_assert (existing_type != nullptr);\n+    return existing_type;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -1416,30 +1689,26 @@ class TypeAlias : public VisItem, public TraitImplItem\n   {\n     return new TypeAlias (*this);\n   }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  /*virtual TypeAlias* clone_statement_impl() const override {\n-      return new TypeAlias(*this);\n-  }*/\n };\n \n // Rust base struct declaration AST node - abstract base class\n class Struct : public VisItem\n {\n-public:\n+protected:\n   // protected to enable access by derived classes - allows better as_string\n   Identifier struct_name;\n \n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n \n   // bool has_where_clause;\n   WhereClause where_clause;\n \n+private:\n   Location locus;\n \n+public:\n   // Returns whether struct has generic parameters.\n   bool has_generics () const { return !generic_params.empty (); }\n \n@@ -1448,9 +1717,31 @@ class Struct : public VisItem\n \n   Location get_locus () const { return locus; }\n \n+  // Invalid if name is empty, so base stripping on that.\n+  void mark_for_strip () override { struct_name = \"\"; }\n+  bool is_marked_for_strip () const override { return struct_name.empty (); }\n+\n+  Identifier get_struct_name () const { return struct_name; }\n+\n+  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  {\n+    return generic_params;\n+  }\n+  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  {\n+    return generic_params;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  WhereClause &get_where_clause ()\n+  {\n+    rust_assert (has_where_clause ());\n+    return where_clause;\n+  }\n+\n protected:\n   Struct (Identifier struct_name,\n-\t  std::vector<std::unique_ptr<GenericParam>> generic_params,\n+\t  std::vector<std::unique_ptr<GenericParam> > generic_params,\n \t  WhereClause where_clause, Visibility vis, Location locus,\n \t  std::vector<Attribute> outer_attrs = std::vector<Attribute> ())\n     : VisItem (std::move (vis), std::move (outer_attrs)),\n@@ -1492,7 +1783,7 @@ class Struct : public VisItem\n // A single field in a struct\n struct StructField\n {\n-public:\n+private:\n   // bool has_outer_attributes;\n   std::vector<Attribute> outer_attrs;\n \n@@ -1504,6 +1795,7 @@ struct StructField\n \n   // should this store location info?\n \n+public:\n   // Returns whether struct field has any outer attributes.\n   bool has_outer_attributes () const { return !outer_attrs.empty (); }\n \n@@ -1520,20 +1812,28 @@ struct StructField\n   // Copy constructor\n   StructField (StructField const &other)\n     : outer_attrs (other.outer_attrs), visibility (other.visibility),\n-      field_name (other.field_name),\n-      field_type (other.field_type->clone_type ())\n-  {}\n+      field_name (other.field_name)\n+  {\n+    // guard to prevent null dereference\n+    if (other.field_type != nullptr)\n+      field_type = other.field_type->clone_type ();\n+  }\n \n   ~StructField () = default;\n \n   // Overloaded assignment operator to clone\n   StructField &operator= (StructField const &other)\n   {\n     field_name = other.field_name;\n-    field_type = other.field_type->clone_type ();\n     visibility = other.visibility;\n     outer_attrs = other.outer_attrs;\n \n+    // guard to prevent null dereference\n+    if (other.field_type != nullptr)\n+      field_type = other.field_type->clone_type ();\n+    else\n+      field_type = nullptr;\n+\n     return *this;\n   }\n \n@@ -1555,20 +1855,35 @@ struct StructField\n   }\n \n   std::string as_string () const;\n+\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+\n+  Identifier get_field_name () const { return field_name; }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Type> &get_field_type ()\n+  {\n+    rust_assert (field_type != nullptr);\n+    return field_type;\n+  }\n+\n+  Visibility get_visibility () const { return visibility; }\n };\n \n // Rust struct declaration with true struct type AST node\n class StructStruct : public Struct\n {\n-public:\n   std::vector<StructField> fields;\n   bool is_unit;\n \n+public:\n   std::string as_string () const override;\n \n   // Mega-constructor with all possible fields\n   StructStruct (std::vector<StructField> fields, Identifier struct_name,\n-\t\tstd::vector<std::unique_ptr<GenericParam>> generic_params,\n+\t\tstd::vector<std::unique_ptr<GenericParam> > generic_params,\n \t\tWhereClause where_clause, bool is_unit, Visibility vis,\n \t\tstd::vector<Attribute> outer_attrs, Location locus)\n     : Struct (std::move (struct_name), std::move (generic_params),\n@@ -1579,7 +1894,7 @@ class StructStruct : public Struct\n \n   // Unit struct constructor\n   StructStruct (Identifier struct_name,\n-\t\tstd::vector<std::unique_ptr<GenericParam>> generic_params,\n+\t\tstd::vector<std::unique_ptr<GenericParam> > generic_params,\n \t\tWhereClause where_clause, Visibility vis,\n \t\tstd::vector<Attribute> outer_attrs, Location locus)\n     : Struct (std::move (struct_name), std::move (generic_params),\n@@ -1596,19 +1911,17 @@ class StructStruct : public Struct\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<StructField> &get_fields () { return fields; }\n+  const std::vector<StructField> &get_fields () const { return fields; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n   StructStruct *clone_item_impl () const override\n   {\n     return new StructStruct (*this);\n   }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  /*virtual StructStruct* clone_statement_impl() const override {\n-      return new StructStruct(*this);\n-  }*/\n };\n \n // A single field in a tuple\n@@ -1642,19 +1955,27 @@ struct TupleField\n \n   // Copy constructor with clone\n   TupleField (TupleField const &other)\n-    : outer_attrs (other.outer_attrs), visibility (other.visibility),\n-      field_type (other.field_type->clone_type ())\n-  {}\n+    : outer_attrs (other.outer_attrs), visibility (other.visibility)\n+  {\n+    // guard to prevent null dereference (only required if error)\n+    if (other.field_type != nullptr)\n+      field_type = other.field_type->clone_type ();\n+  }\n \n   ~TupleField () = default;\n \n   // Overloaded assignment operator to clone\n   TupleField &operator= (TupleField const &other)\n   {\n-    field_type = other.field_type->clone_type ();\n     visibility = other.visibility;\n     outer_attrs = other.outer_attrs;\n \n+    // guard to prevent null dereference (only required if error)\n+    if (other.field_type != nullptr)\n+      field_type = other.field_type->clone_type ();\n+    else\n+      field_type = nullptr;\n+\n     return *this;\n   }\n \n@@ -1672,6 +1993,17 @@ struct TupleField\n   }\n \n   std::string as_string () const;\n+\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Type> &get_field_type ()\n+  {\n+    rust_assert (field_type != nullptr);\n+    return field_type;\n+  }\n };\n \n // Rust tuple declared using struct keyword AST node\n@@ -1684,7 +2016,7 @@ class TupleStruct : public Struct\n \n   // Mega-constructor with all possible fields\n   TupleStruct (std::vector<TupleField> fields, Identifier struct_name,\n-\t       std::vector<std::unique_ptr<GenericParam>> generic_params,\n+\t       std::vector<std::unique_ptr<GenericParam> > generic_params,\n \t       WhereClause where_clause, Visibility vis,\n \t       std::vector<Attribute> outer_attrs, Location locus)\n     : Struct (std::move (struct_name), std::move (generic_params),\n@@ -1695,19 +2027,17 @@ class TupleStruct : public Struct\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<TupleField> &get_fields () { return fields; }\n+  const std::vector<TupleField> &get_fields () const { return fields; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n   TupleStruct *clone_item_impl () const override\n   {\n     return new TupleStruct (*this);\n   }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  /*virtual TupleStruct* clone_statement_impl() const override {\n-      return new TupleStruct(*this);\n-  }*/\n };\n \n /* An item used in an \"enum\" tagged union - not abstract: base represents a\n@@ -1744,6 +2074,14 @@ class EnumItem\n   // not pure virtual as not abstract\n   virtual void accept_vis (ASTVisitor &vis);\n \n+  // Based on idea that name is never empty.\n+  void mark_for_strip () { variant_name = \"\"; }\n+  bool is_marked_for_strip () const { return variant_name.empty (); }\n+\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+\n protected:\n   // Clone function implementation as (not pure) virtual method\n   virtual EnumItem *clone_enum_item_impl () const\n@@ -1772,6 +2110,13 @@ class EnumItemTuple : public EnumItem\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<TupleField> &get_tuple_fields () { return tuple_fields; }\n+  const std::vector<TupleField> &get_tuple_fields () const\n+  {\n+    return tuple_fields;\n+  }\n+\n protected:\n   // Clone function implementation as (not pure) virtual method\n   EnumItemTuple *clone_enum_item_impl () const override\n@@ -1801,6 +2146,13 @@ class EnumItemStruct : public EnumItem\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<StructField> &get_struct_fields () { return struct_fields; }\n+  const std::vector<StructField> &get_struct_fields () const\n+  {\n+    return struct_fields;\n+  }\n+\n protected:\n   // Clone function implementation as (not pure) virtual method\n   EnumItemStruct *clone_enum_item_impl () const override\n@@ -1845,6 +2197,13 @@ class EnumItemDiscriminant : public EnumItem\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_expr ()\n+  {\n+    rust_assert (expression != nullptr);\n+    return expression;\n+  }\n+\n protected:\n   // Clone function implementation as (not pure) virtual method\n   EnumItemDiscriminant *clone_enum_item_impl () const override\n@@ -1860,12 +2219,12 @@ class Enum : public VisItem\n \n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n \n   // bool has_where_clause;\n   WhereClause where_clause;\n \n-  std::vector<std::unique_ptr<EnumItem>> items;\n+  std::vector<std::unique_ptr<EnumItem> > items;\n \n   Location locus;\n \n@@ -1884,8 +2243,8 @@ class Enum : public VisItem\n \n   // Mega-constructor\n   Enum (Identifier enum_name, Visibility vis,\n-\tstd::vector<std::unique_ptr<GenericParam>> generic_params,\n-\tWhereClause where_clause, std::vector<std::unique_ptr<EnumItem>> items,\n+\tstd::vector<std::unique_ptr<GenericParam> > generic_params,\n+\tWhereClause where_clause, std::vector<std::unique_ptr<EnumItem> > items,\n \tstd::vector<Attribute> outer_attrs, Location locus)\n     : VisItem (std::move (vis), std::move (outer_attrs)),\n       enum_name (std::move (enum_name)),\n@@ -1937,16 +2296,37 @@ class Enum : public VisItem\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Invalid if name is empty, so base stripping on that.\n+  void mark_for_strip () override { enum_name = \"\"; }\n+  bool is_marked_for_strip () const override { return enum_name.empty (); }\n+\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<std::unique_ptr<EnumItem> > &get_variants () { return items; }\n+  const std::vector<std::unique_ptr<EnumItem> > &get_variants () const\n+  {\n+    return items;\n+  }\n+\n+  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  {\n+    return generic_params;\n+  }\n+  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  {\n+    return generic_params;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  WhereClause &get_where_clause ()\n+  {\n+    rust_assert (has_where_clause ());\n+    return where_clause;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n   Enum *clone_item_impl () const override { return new Enum (*this); }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  /*virtual Enum* clone_statement_impl() const override {\n-      return new Enum(*this);\n-  }*/\n };\n \n // Rust untagged union used for C compat AST node\n@@ -1956,7 +2336,7 @@ class Union : public VisItem\n \n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n \n   // bool has_where_clause;\n   WhereClause where_clause;\n@@ -1975,7 +2355,7 @@ class Union : public VisItem\n   bool has_where_clause () const { return !where_clause.is_empty (); }\n \n   Union (Identifier union_name, Visibility vis,\n-\t std::vector<std::unique_ptr<GenericParam>> generic_params,\n+\t std::vector<std::unique_ptr<GenericParam> > generic_params,\n \t WhereClause where_clause, std::vector<StructField> variants,\n \t std::vector<Attribute> outer_attrs, Location locus)\n     : VisItem (std::move (vis), std::move (outer_attrs)),\n@@ -2020,16 +2400,34 @@ class Union : public VisItem\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Invalid if name is empty, so base stripping on that.\n+  void mark_for_strip () override { union_name = \"\"; }\n+  bool is_marked_for_strip () const override { return union_name.empty (); }\n+\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<StructField> &get_variants () { return variants; }\n+  const std::vector<StructField> &get_variants () const { return variants; }\n+\n+  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  {\n+    return generic_params;\n+  }\n+  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  {\n+    return generic_params;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  WhereClause &get_where_clause ()\n+  {\n+    rust_assert (has_where_clause ());\n+    return where_clause;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n   Union *clone_item_impl () const override { return new Union (*this); }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  /*virtual Union* clone_statement_impl() const override {\n-      return new Union(*this);\n-  }*/\n };\n \n /* \"Constant item\" AST node - used for constant, compile-time expressions\n@@ -2041,7 +2439,7 @@ class ConstantItem : public VisItem,\n   // either has an identifier or \"_\" - maybe handle in identifier?\n   // bool identifier_is_underscore;\n   // if no identifier declared, identifier will be \"_\"\n-  Identifier identifier;\n+  std::string identifier;\n \n   std::unique_ptr<Type> type;\n   std::unique_ptr<Expr> const_expr;\n@@ -2051,7 +2449,7 @@ class ConstantItem : public VisItem,\n public:\n   std::string as_string () const override;\n \n-  ConstantItem (Identifier ident, Visibility vis, std::unique_ptr<Type> type,\n+  ConstantItem (std::string ident, Visibility vis, std::unique_ptr<Type> type,\n \t\tstd::unique_ptr<Expr> const_expr,\n \t\tstd::vector<Attribute> outer_attrs, Location locus)\n     : VisItem (std::move (vis), std::move (outer_attrs)),\n@@ -2060,20 +2458,32 @@ class ConstantItem : public VisItem,\n   {}\n \n   ConstantItem (ConstantItem const &other)\n-    : VisItem (other), identifier (other.identifier),\n-      type (other.type->clone_type ()),\n-      const_expr (other.const_expr->clone_expr ()), locus (other.locus)\n-  {}\n+    : VisItem (other), identifier (other.identifier), locus (other.locus)\n+  {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.type != nullptr)\n+      type = other.type->clone_type ();\n+    if (other.const_expr != nullptr)\n+      const_expr = other.const_expr->clone_expr ();\n+  }\n \n   // Overload assignment operator to clone\n   ConstantItem &operator= (ConstantItem const &other)\n   {\n     VisItem::operator= (other);\n     identifier = other.identifier;\n-    type = other.type->clone_type ();\n-    const_expr = other.const_expr->clone_expr ();\n     locus = other.locus;\n \n+    // guard to prevent null dereference (only required if error state)\n+    if (other.type != nullptr)\n+      type = other.type->clone_type ();\n+    else\n+      type = nullptr;\n+    if (other.const_expr != nullptr)\n+      const_expr = other.const_expr->clone_expr ();\n+    else\n+      const_expr = nullptr;\n+\n     return *this;\n   }\n \n@@ -2083,12 +2493,37 @@ class ConstantItem : public VisItem,\n \n   /* Returns whether constant item is an \"unnamed\" (wildcard underscore used\n    * as identifier) constant. */\n-  bool is_unnamed () const { return identifier == std::string (\"_\"); }\n+  bool is_unnamed () const { return identifier == \"_\"; }\n \n   Location get_locus () const { return locus; }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Invalid if type or expression are null, so base stripping on that.\n+  void mark_for_strip () override\n+  {\n+    type = nullptr;\n+    const_expr = nullptr;\n+  }\n+  bool is_marked_for_strip () const override\n+  {\n+    return type == nullptr && const_expr == nullptr;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_expr ()\n+  {\n+    rust_assert (const_expr != nullptr);\n+    return const_expr;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Type> &get_type ()\n+  {\n+    rust_assert (type != nullptr);\n+    return type;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -2110,12 +2545,6 @@ class ConstantItem : public VisItem,\n   {\n     return new ConstantItem (*this);\n   }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  /*virtual ConstantItem* clone_statement_impl() const override {\n-      return new ConstantItem(*this);\n-  }*/\n };\n \n /* Static item AST node - items within module scope with fixed storage\n@@ -2142,20 +2571,33 @@ class StaticItem : public VisItem\n   // Copy constructor with clone\n   StaticItem (StaticItem const &other)\n     : VisItem (other), has_mut (other.has_mut), name (other.name),\n-      type (other.type->clone_type ()), expr (other.expr->clone_expr ()),\n       locus (other.locus)\n-  {}\n+  {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.type != nullptr)\n+      type = other.type->clone_type ();\n+    if (other.expr != nullptr)\n+      expr = other.expr->clone_expr ();\n+  }\n \n   // Overloaded assignment operator to clone\n   StaticItem &operator= (StaticItem const &other)\n   {\n     VisItem::operator= (other);\n     name = other.name;\n     has_mut = other.has_mut;\n-    type = other.type->clone_type ();\n-    expr = other.expr->clone_expr ();\n     locus = other.locus;\n \n+    // guard to prevent null dereference (only required if error state)\n+    if (other.type != nullptr)\n+      type = other.type->clone_type ();\n+    else\n+      type = nullptr;\n+    if (other.expr != nullptr)\n+      expr = other.expr->clone_expr ();\n+    else\n+      expr = nullptr;\n+\n     return *this;\n   }\n \n@@ -2167,19 +2609,38 @@ class StaticItem : public VisItem\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Invalid if type or expression are null, so base stripping on that.\n+  void mark_for_strip () override\n+  {\n+    type = nullptr;\n+    expr = nullptr;\n+  }\n+  bool is_marked_for_strip () const override\n+  {\n+    return type == nullptr && expr == nullptr;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_expr ()\n+  {\n+    rust_assert (expr != nullptr);\n+    return expr;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Type> &get_type ()\n+  {\n+    rust_assert (type != nullptr);\n+    return type;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n   StaticItem *clone_item_impl () const override\n   {\n     return new StaticItem (*this);\n   }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  /*virtual StaticItem* clone_statement_impl() const override {\n-      return new StaticItem(*this);\n-  }*/\n };\n \n // Function declaration in traits\n@@ -2192,7 +2653,7 @@ struct TraitFunctionDecl\n \n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n \n   // bool has_params;\n   // FunctionParams function_params;\n@@ -2221,7 +2682,7 @@ struct TraitFunctionDecl\n \n   // Mega-constructor\n   TraitFunctionDecl (Identifier function_name, FunctionQualifiers qualifiers,\n-\t\t     std::vector<std::unique_ptr<GenericParam>> generic_params,\n+\t\t     std::vector<std::unique_ptr<GenericParam> > generic_params,\n \t\t     std::vector<FunctionParam> function_params,\n \t\t     std::unique_ptr<Type> return_type,\n \t\t     WhereClause where_clause)\n@@ -2236,10 +2697,12 @@ struct TraitFunctionDecl\n   // Copy constructor with clone\n   TraitFunctionDecl (TraitFunctionDecl const &other)\n     : qualifiers (other.qualifiers), function_name (other.function_name),\n-      function_params (other.function_params),\n-      return_type (other.return_type->clone_type ()),\n-      where_clause (other.where_clause)\n+      function_params (other.function_params), where_clause (other.where_clause)\n   {\n+    // guard to prevent nullptr dereference\n+    if (other.return_type != nullptr)\n+      return_type = other.return_type->clone_type ();\n+\n     generic_params.reserve (other.generic_params.size ());\n     for (const auto &e : other.generic_params)\n       generic_params.push_back (e->clone_generic_param ());\n@@ -2253,9 +2716,14 @@ struct TraitFunctionDecl\n     function_name = other.function_name;\n     qualifiers = other.qualifiers;\n     function_params = other.function_params;\n-    return_type = other.return_type->clone_type ();\n     where_clause = other.where_clause;\n \n+    // guard to prevent nullptr dereference\n+    if (other.return_type != nullptr)\n+      return_type = other.return_type->clone_type ();\n+    else\n+      return_type = nullptr;\n+\n     generic_params.reserve (other.generic_params.size ());\n     for (const auto &e : other.generic_params)\n       generic_params.push_back (e->clone_generic_param ());\n@@ -2268,6 +2736,40 @@ struct TraitFunctionDecl\n   TraitFunctionDecl &operator= (TraitFunctionDecl &&other) = default;\n \n   std::string as_string () const;\n+\n+  // Invalid if function name is empty, so base stripping on that.\n+  void mark_for_strip () { function_name = \"\"; }\n+  bool is_marked_for_strip () const { return function_name.empty (); }\n+\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<FunctionParam> &get_function_params () { return function_params; }\n+  const std::vector<FunctionParam> &get_function_params () const\n+  {\n+    return function_params;\n+  }\n+\n+  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  {\n+    return generic_params;\n+  }\n+  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  {\n+    return generic_params;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Type> &get_return_type ()\n+  {\n+    rust_assert (has_return_type ());\n+    return return_type;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  WhereClause &get_where_clause ()\n+  {\n+    rust_assert (has_where_clause ());\n+    return where_clause;\n+  }\n };\n \n // Actual trait item function declaration within traits\n@@ -2292,6 +2794,7 @@ class TraitItemFunc : public TraitItem\n   TraitItemFunc (TraitItemFunc const &other)\n     : outer_attrs (other.outer_attrs), decl (other.decl), locus (other.locus)\n   {\n+    // guard to prevent null dereference\n     if (other.block_expr != nullptr)\n       block_expr = other.block_expr->clone_block_expr ();\n   }\n@@ -2303,8 +2806,12 @@ class TraitItemFunc : public TraitItem\n     outer_attrs = other.outer_attrs;\n     decl = other.decl;\n     locus = other.locus;\n+\n+    // guard to prevent null dereference\n     if (other.block_expr != nullptr)\n       block_expr = other.block_expr->clone_block_expr ();\n+    else\n+      block_expr = nullptr;\n \n     return *this;\n   }\n@@ -2319,6 +2826,31 @@ class TraitItemFunc : public TraitItem\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Invalid if trait decl is empty, so base stripping on that.\n+  void mark_for_strip () override { decl.mark_for_strip (); }\n+  bool is_marked_for_strip () const override\n+  {\n+    return decl.is_marked_for_strip ();\n+  }\n+\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<BlockExpr> &get_definition ()\n+  {\n+    rust_assert (has_definition ());\n+    return block_expr;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  TraitFunctionDecl &get_trait_function_decl ()\n+  {\n+    // TODO: maybe only allow access if not marked for strip?\n+    return decl;\n+  }\n+\n protected:\n   // Clone function implementation as (not pure) virtual method\n   TraitItemFunc *clone_trait_item_impl () const override\n@@ -2337,7 +2869,7 @@ struct TraitMethodDecl\n \n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n \n   SelfParam self_param;\n \n@@ -2368,7 +2900,7 @@ struct TraitMethodDecl\n \n   // Mega-constructor\n   TraitMethodDecl (Identifier function_name, FunctionQualifiers qualifiers,\n-\t\t   std::vector<std::unique_ptr<GenericParam>> generic_params,\n+\t\t   std::vector<std::unique_ptr<GenericParam> > generic_params,\n \t\t   SelfParam self_param,\n \t\t   std::vector<FunctionParam> function_params,\n \t\t   std::unique_ptr<Type> return_type, WhereClause where_clause)\n@@ -2385,9 +2917,12 @@ struct TraitMethodDecl\n   TraitMethodDecl (TraitMethodDecl const &other)\n     : qualifiers (other.qualifiers), function_name (other.function_name),\n       self_param (other.self_param), function_params (other.function_params),\n-      return_type (other.return_type->clone_type ()),\n       where_clause (other.where_clause)\n   {\n+    // guard to prevent nullptr dereference\n+    if (other.return_type != nullptr)\n+      return_type = other.return_type->clone_type ();\n+\n     generic_params.reserve (other.generic_params.size ());\n     for (const auto &e : other.generic_params)\n       generic_params.push_back (e->clone_generic_param ());\n@@ -2402,9 +2937,14 @@ struct TraitMethodDecl\n     qualifiers = other.qualifiers;\n     self_param = other.self_param;\n     function_params = other.function_params;\n-    return_type = other.return_type->clone_type ();\n     where_clause = other.where_clause;\n \n+    // guard to prevent nullptr dereference\n+    if (other.return_type != nullptr)\n+      return_type = other.return_type->clone_type ();\n+    else\n+      return_type = nullptr;\n+\n     generic_params.reserve (other.generic_params.size ());\n     for (const auto &e : other.generic_params)\n       generic_params.push_back (e->clone_generic_param ());\n@@ -2417,6 +2957,43 @@ struct TraitMethodDecl\n   TraitMethodDecl &operator= (TraitMethodDecl &&other) = default;\n \n   std::string as_string () const;\n+\n+  // Invalid if method name is empty, so base stripping on that.\n+  void mark_for_strip () { function_name = \"\"; }\n+  bool is_marked_for_strip () const { return function_name.empty (); }\n+\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<FunctionParam> &get_function_params () { return function_params; }\n+  const std::vector<FunctionParam> &get_function_params () const\n+  {\n+    return function_params;\n+  }\n+\n+  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  {\n+    return generic_params;\n+  }\n+  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  {\n+    return generic_params;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Type> &get_return_type ()\n+  {\n+    rust_assert (has_return_type ());\n+    return return_type;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  WhereClause &get_where_clause ()\n+  {\n+    rust_assert (has_where_clause ());\n+    return where_clause;\n+  }\n+\n+  SelfParam &get_self_param () { return self_param; }\n+  const SelfParam &get_self_param () const { return self_param; }\n };\n \n // Actual trait item method declaration within traits\n@@ -2439,19 +3016,27 @@ class TraitItemMethod : public TraitItem\n \n   // Copy constructor with clone\n   TraitItemMethod (TraitItemMethod const &other)\n-    : outer_attrs (other.outer_attrs), decl (other.decl),\n-      block_expr (other.block_expr->clone_block_expr ()), locus (other.locus)\n-  {}\n+    : outer_attrs (other.outer_attrs), decl (other.decl), locus (other.locus)\n+  {\n+    // guard to prevent null dereference\n+    if (other.block_expr != nullptr)\n+      block_expr = other.block_expr->clone_block_expr ();\n+  }\n \n   // Overloaded assignment operator to clone\n   TraitItemMethod &operator= (TraitItemMethod const &other)\n   {\n     TraitItem::operator= (other);\n     outer_attrs = other.outer_attrs;\n     decl = other.decl;\n-    block_expr = other.block_expr->clone_block_expr ();\n     locus = other.locus;\n \n+    // guard to prevent null dereference\n+    if (other.block_expr != nullptr)\n+      block_expr = other.block_expr->clone_block_expr ();\n+    else\n+      block_expr = nullptr;\n+\n     return *this;\n   }\n \n@@ -2465,6 +3050,31 @@ class TraitItemMethod : public TraitItem\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Invalid if trait decl is empty, so base stripping on that.\n+  void mark_for_strip () override { decl.mark_for_strip (); }\n+  bool is_marked_for_strip () const override\n+  {\n+    return decl.is_marked_for_strip ();\n+  }\n+\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  TraitMethodDecl &get_trait_method_decl ()\n+  {\n+    // TODO: maybe only allow access if not marked for strip?\n+    return decl;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<BlockExpr> &get_definition ()\n+  {\n+    rust_assert (has_definition ());\n+    return block_expr;\n+  }\n+\n protected:\n   // Clone function implementation as (not pure) virtual method\n   TraitItemMethod *clone_trait_item_impl () const override\n@@ -2498,21 +3108,37 @@ class TraitItemConst : public TraitItem\n \n   // Copy constructor with clones\n   TraitItemConst (TraitItemConst const &other)\n-    : outer_attrs (other.outer_attrs), name (other.name),\n-      type (other.type->clone_type ()), expr (other.expr->clone_expr ()),\n-      locus (other.locus)\n-  {}\n+    : outer_attrs (other.outer_attrs), name (other.name), locus (other.locus)\n+  {\n+    // guard to prevent null dereference\n+    if (other.expr != nullptr)\n+      expr = other.expr->clone_expr ();\n+\n+    // guard to prevent null dereference (only for error state)\n+    if (other.type != nullptr)\n+      type = other.type->clone_type ();\n+  }\n \n   // Overloaded assignment operator to clone\n   TraitItemConst &operator= (TraitItemConst const &other)\n   {\n     TraitItem::operator= (other);\n     outer_attrs = other.outer_attrs;\n     name = other.name;\n-    type = other.type->clone_type ();\n-    expr = other.expr->clone_expr ();\n     locus = other.locus;\n \n+    // guard to prevent null dereference\n+    if (other.expr != nullptr)\n+      expr = other.expr->clone_expr ();\n+    else\n+      expr = nullptr;\n+\n+    // guard to prevent null dereference (only for error state)\n+    if (other.type != nullptr)\n+      type = other.type->clone_type ();\n+    else\n+      type = nullptr;\n+\n     return *this;\n   }\n \n@@ -2526,6 +3152,28 @@ class TraitItemConst : public TraitItem\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Invalid if type is null, so base stripping on that.\n+  void mark_for_strip () override { type = nullptr; }\n+  bool is_marked_for_strip () const override { return type == nullptr; }\n+\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_expr ()\n+  {\n+    rust_assert (expr != nullptr);\n+    return expr;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Type> &get_type ()\n+  {\n+    rust_assert (type != nullptr);\n+    return type;\n+  }\n+\n protected:\n   // Clone function implementation as (not pure) virtual method\n   TraitItemConst *clone_trait_item_impl () const override\n@@ -2543,7 +3191,7 @@ class TraitItemType : public TraitItem\n \n   // bool has_type_param_bounds;\n   // TypeParamBounds type_param_bounds;\n-  std::vector<std::unique_ptr<TypeParamBound>>\n+  std::vector<std::unique_ptr<TypeParamBound> >\n     type_param_bounds; // inlined form\n \n   Location locus;\n@@ -2554,7 +3202,7 @@ class TraitItemType : public TraitItem\n \n   TraitItemType (\n     Identifier name,\n-    std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds,\n+    std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds,\n     std::vector<Attribute> outer_attrs, Location locus)\n     : outer_attrs (std::move (outer_attrs)), name (std::move (name)),\n       type_param_bounds (std::move (type_param_bounds)), locus (locus)\n@@ -2594,6 +3242,25 @@ class TraitItemType : public TraitItem\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Invalid if name is empty, so base stripping on that.\n+  void mark_for_strip () override { name = \"\"; }\n+  bool is_marked_for_strip () const override { return name.empty (); }\n+\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+\n+  // TODO: mutable getter seems kinda dodgy\n+  std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds ()\n+  {\n+    return type_param_bounds;\n+  }\n+  const std::vector<std::unique_ptr<TypeParamBound> > &\n+  get_type_param_bounds () const\n+  {\n+    return type_param_bounds;\n+  }\n+\n protected:\n   // Clone function implementation as (not pure) virtual method\n   TraitItemType *clone_trait_item_impl () const override\n@@ -2606,23 +3273,24 @@ class TraitItemType : public TraitItem\n class Trait : public VisItem\n {\n   bool has_unsafe;\n-\n   Identifier name;\n \n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n \n   // bool has_type_param_bounds;\n   // TypeParamBounds type_param_bounds;\n-  std::vector<std::unique_ptr<TypeParamBound>>\n+  std::vector<std::unique_ptr<TypeParamBound> >\n     type_param_bounds; // inlined form\n \n   // bool has_where_clause;\n   WhereClause where_clause;\n \n+  std::vector<Attribute> inner_attrs;\n+\n   // bool has_trait_items;\n-  std::vector<std::unique_ptr<TraitItem>> trait_items;\n+  std::vector<std::unique_ptr<TraitItem> > trait_items;\n \n   Location locus;\n \n@@ -2641,25 +3309,31 @@ class Trait : public VisItem\n   // Returns whether trait has trait items.\n   bool has_trait_items () const { return !trait_items.empty (); }\n \n+  // Returns whether trait has inner attributes.\n+  bool has_inner_attrs () const { return !inner_attrs.empty (); }\n+\n   // Mega-constructor\n   Trait (Identifier name, bool is_unsafe,\n-\t std::vector<std::unique_ptr<GenericParam>> generic_params,\n-\t std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds,\n+\t std::vector<std::unique_ptr<GenericParam> > generic_params,\n+\t std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds,\n \t WhereClause where_clause,\n-\t std::vector<std::unique_ptr<TraitItem>> trait_items, Visibility vis,\n-\t std::vector<Attribute> outer_attrs, Location locus)\n+\t std::vector<std::unique_ptr<TraitItem> > trait_items, Visibility vis,\n+\t std::vector<Attribute> outer_attrs, std::vector<Attribute> inner_attrs,\n+\t Location locus)\n     : VisItem (std::move (vis), std::move (outer_attrs)),\n       has_unsafe (is_unsafe), name (std::move (name)),\n       generic_params (std::move (generic_params)),\n       type_param_bounds (std::move (type_param_bounds)),\n       where_clause (std::move (where_clause)),\n+      inner_attrs (std::move (inner_attrs)),\n       trait_items (std::move (trait_items)), locus (locus)\n   {}\n \n   // Copy constructor with vector clone\n   Trait (Trait const &other)\n     : VisItem (other), has_unsafe (other.has_unsafe), name (other.name),\n-      where_clause (other.where_clause), locus (other.locus)\n+      where_clause (other.where_clause), inner_attrs (other.inner_attrs),\n+      locus (other.locus)\n   {\n     generic_params.reserve (other.generic_params.size ());\n     for (const auto &e : other.generic_params)\n@@ -2681,6 +3355,7 @@ class Trait : public VisItem\n     name = other.name;\n     has_unsafe = other.has_unsafe;\n     where_clause = other.where_clause;\n+    inner_attrs = other.inner_attrs;\n     locus = other.locus;\n \n     generic_params.reserve (other.generic_params.size ());\n@@ -2706,16 +3381,53 @@ class Trait : public VisItem\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Invalid if trait name is empty, so base stripping on that.\n+  void mark_for_strip () override { name = \"\"; }\n+  bool is_marked_for_strip () const override { return name.empty (); }\n+\n+  // TODO: think of better way to do this\n+  const std::vector<Attribute> &get_inner_attrs () const { return inner_attrs; }\n+  std::vector<Attribute> &get_inner_attrs () { return inner_attrs; }\n+\n+  const std::vector<std::unique_ptr<TraitItem> > &get_trait_items () const\n+  {\n+    return trait_items;\n+  }\n+  std::vector<std::unique_ptr<TraitItem> > &get_trait_items ()\n+  {\n+    return trait_items;\n+  }\n+\n+  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  {\n+    return generic_params;\n+  }\n+  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  {\n+    return generic_params;\n+  }\n+\n+  std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds ()\n+  {\n+    return type_param_bounds;\n+  }\n+  const std::vector<std::unique_ptr<TypeParamBound> > &\n+  get_type_param_bounds () const\n+  {\n+    return type_param_bounds;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  WhereClause &get_where_clause ()\n+  {\n+    rust_assert (has_where_clause ());\n+    return where_clause;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n   Trait *clone_item_impl () const override { return new Trait (*this); }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  /*virtual Trait* clone_statement_impl() const override {\n-      return new Trait(*this);\n-  }*/\n };\n \n // Implementation item declaration AST node - abstract base class\n@@ -2725,7 +3437,7 @@ class Impl : public VisItem\n protected:\n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n \n   std::unique_ptr<Type> trait_type;\n \n@@ -2751,9 +3463,40 @@ class Impl : public VisItem\n \n   Location get_locus () const { return locus; }\n \n+  // Invalid if trait type is null, so base stripping on that.\n+  void mark_for_strip () override { trait_type = nullptr; }\n+  bool is_marked_for_strip () const override { return trait_type == nullptr; }\n+\n+  // TODO: think of better way to do this\n+  const std::vector<Attribute> &get_inner_attrs () const { return inner_attrs; }\n+  std::vector<Attribute> &get_inner_attrs () { return inner_attrs; }\n+\n+  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  {\n+    return generic_params;\n+  }\n+  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  {\n+    return generic_params;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  WhereClause &get_where_clause ()\n+  {\n+    rust_assert (has_where_clause ());\n+    return where_clause;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Type> &get_type ()\n+  {\n+    rust_assert (trait_type != nullptr);\n+    return trait_type;\n+  }\n+\n protected:\n   // Mega-constructor\n-  Impl (std::vector<std::unique_ptr<GenericParam>> generic_params,\n+  Impl (std::vector<std::unique_ptr<GenericParam> > generic_params,\n \tstd::unique_ptr<Type> trait_type, WhereClause where_clause,\n \tVisibility vis, std::vector<Attribute> inner_attrs,\n \tstd::vector<Attribute> outer_attrs, Location locus)\n@@ -2766,10 +3509,13 @@ class Impl : public VisItem\n \n   // Copy constructor\n   Impl (Impl const &other)\n-    : VisItem (other), trait_type (other.trait_type->clone_type ()),\n-      where_clause (other.where_clause), inner_attrs (other.inner_attrs),\n-      locus (other.locus)\n+    : VisItem (other), where_clause (other.where_clause),\n+      inner_attrs (other.inner_attrs), locus (other.locus)\n   {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.trait_type != nullptr)\n+      trait_type = other.trait_type->clone_type ();\n+\n     generic_params.reserve (other.generic_params.size ());\n     for (const auto &e : other.generic_params)\n       generic_params.push_back (e->clone_generic_param ());\n@@ -2779,11 +3525,16 @@ class Impl : public VisItem\n   Impl &operator= (Impl const &other)\n   {\n     VisItem::operator= (other);\n-    trait_type = other.trait_type->clone_type ();\n     where_clause = other.where_clause;\n     inner_attrs = other.inner_attrs;\n     locus = other.locus;\n \n+    // guard to prevent null dereference (only required if error state)\n+    if (other.trait_type != nullptr)\n+      trait_type = other.trait_type->clone_type ();\n+    else\n+      trait_type = nullptr;\n+\n     generic_params.reserve (other.generic_params.size ());\n     for (const auto &e : other.generic_params)\n       generic_params.push_back (e->clone_generic_param ());\n@@ -2800,7 +3551,7 @@ class Impl : public VisItem\n class InherentImpl : public Impl\n {\n   // bool has_impl_items;\n-  std::vector<std::unique_ptr<InherentImplItem>> impl_items;\n+  std::vector<std::unique_ptr<InherentImplItem> > impl_items;\n \n public:\n   std::string as_string () const override;\n@@ -2809,8 +3560,8 @@ class InherentImpl : public Impl\n   bool has_impl_items () const { return !impl_items.empty (); }\n \n   // Mega-constructor\n-  InherentImpl (std::vector<std::unique_ptr<InherentImplItem>> impl_items,\n-\t\tstd::vector<std::unique_ptr<GenericParam>> generic_params,\n+  InherentImpl (std::vector<std::unique_ptr<InherentImplItem> > impl_items,\n+\t\tstd::vector<std::unique_ptr<GenericParam> > generic_params,\n \t\tstd::unique_ptr<Type> trait_type, WhereClause where_clause,\n \t\tVisibility vis, std::vector<Attribute> inner_attrs,\n \t\tstd::vector<Attribute> outer_attrs, Location locus)\n@@ -2846,19 +3597,23 @@ class InherentImpl : public Impl\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: think of better way to do this\n+  const std::vector<std::unique_ptr<InherentImplItem> > &get_impl_items () const\n+  {\n+    return impl_items;\n+  }\n+  std::vector<std::unique_ptr<InherentImplItem> > &get_impl_items ()\n+  {\n+    return impl_items;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n   InherentImpl *clone_item_impl () const override\n   {\n     return new InherentImpl (*this);\n   }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  /*virtual InherentImpl* clone_statement_impl() const override {\n-      return new InherentImpl(*this);\n-  }*/\n };\n \n // The \"impl footrait for foo\" impl block declaration AST node\n@@ -2869,7 +3624,7 @@ class TraitImpl : public Impl\n   TypePath trait_path;\n \n   // bool has_impl_items;\n-  std::vector<std::unique_ptr<TraitImplItem>> impl_items;\n+  std::vector<std::unique_ptr<TraitImplItem> > impl_items;\n \n public:\n   std::string as_string () const override;\n@@ -2879,8 +3634,8 @@ class TraitImpl : public Impl\n \n   // Mega-constructor\n   TraitImpl (TypePath trait_path, bool is_unsafe, bool has_exclam,\n-\t     std::vector<std::unique_ptr<TraitImplItem>> impl_items,\n-\t     std::vector<std::unique_ptr<GenericParam>> generic_params,\n+\t     std::vector<std::unique_ptr<TraitImplItem> > impl_items,\n+\t     std::vector<std::unique_ptr<GenericParam> > generic_params,\n \t     std::unique_ptr<Type> trait_type, WhereClause where_clause,\n \t     Visibility vis, std::vector<Attribute> inner_attrs,\n \t     std::vector<Attribute> outer_attrs, Location locus)\n@@ -2924,18 +3679,30 @@ class TraitImpl : public Impl\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: think of better way to do this\n+  const std::vector<std::unique_ptr<TraitImplItem> > &get_impl_items () const\n+  {\n+    return impl_items;\n+  }\n+  std::vector<std::unique_ptr<TraitImplItem> > &get_impl_items ()\n+  {\n+    return impl_items;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  TypePath &get_trait_path ()\n+  {\n+    // TODO: assert that trait path is not empty?\n+    return trait_path;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n   TraitImpl *clone_item_impl () const override { return new TraitImpl (*this); }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  /*virtual TraitImpl* clone_statement_impl() const override {\n-      return new TraitImpl(*this);\n-  }*/\n };\n \n+#if 0\n // Abstract base class for an item used inside an extern block\n class ExternalItem\n {\n@@ -2951,6 +3718,10 @@ class ExternalItem\n public:\n   virtual ~ExternalItem () {}\n \n+  /* TODO: spec syntax rules state that \"MacroInvocationSemi\" can be used as \n+   * ExternalItem, but text body isn't so clear. Adding MacroInvocationSemi \n+   * support would require a lot of refactoring. */\n+\n   // Returns whether item has outer attributes.\n   bool has_outer_attrs () const { return !outer_attrs.empty (); }\n \n@@ -2969,6 +3740,11 @@ class ExternalItem\n \n   virtual void accept_vis (ASTVisitor &vis) = 0;\n \n+  // TODO: make virtual? Would be more flexible.\n+  // Based on idea that name should never be empty.\n+  void mark_for_strip () { item_name = \"\"; };\n+  bool is_marked_for_strip () const { return item_name.empty (); };\n+\n protected:\n   ExternalItem (Identifier item_name, Visibility vis,\n \t\tstd::vector<Attribute> outer_attrs, Location locus)\n@@ -3003,35 +3779,57 @@ class ExternalItem\n   // possibly make this public if required\n   std::string get_item_name () const { return item_name; }\n };\n+#endif\n \n // A static item used in an extern block\n class ExternalStaticItem : public ExternalItem\n {\n+  // bool has_outer_attrs;\n+  std::vector<Attribute> outer_attrs;\n+\n+  // bool has_visibility;\n+  Visibility visibility;\n+\n+  Identifier item_name;\n+  Location locus;\n+\n   bool has_mut;\n   std::unique_ptr<Type> item_type;\n \n public:\n   ExternalStaticItem (Identifier item_name, std::unique_ptr<Type> item_type,\n \t\t      bool is_mut, Visibility vis,\n \t\t      std::vector<Attribute> outer_attrs, Location locus)\n-    : ExternalItem (std::move (item_name), std::move (vis),\n-\t\t    std::move (outer_attrs), locus),\n-      has_mut (is_mut), item_type (std::move (item_type))\n+    : outer_attrs (std::move (outer_attrs)), visibility (std::move (vis)),\n+      item_name (std::move (item_name)), locus (locus), has_mut (is_mut),\n+      item_type (std::move (item_type))\n   {}\n \n   // Copy constructor\n   ExternalStaticItem (ExternalStaticItem const &other)\n-    : ExternalItem (other), has_mut (other.has_mut),\n-      item_type (other.item_type->clone_type ())\n-  {}\n+    : outer_attrs (other.outer_attrs), visibility (other.visibility),\n+      item_name (other.item_name), locus (other.locus), has_mut (other.has_mut)\n+  {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.item_type != nullptr)\n+      item_type = other.item_type->clone_type ();\n+  }\n \n   // Overloaded assignment operator to clone\n   ExternalStaticItem &operator= (ExternalStaticItem const &other)\n   {\n-    ExternalItem::operator= (other);\n-    item_type = other.item_type->clone_type ();\n+    outer_attrs = other.outer_attrs;\n+    visibility = other.visibility;\n+    item_name = other.item_name;\n+    locus = other.locus;\n     has_mut = other.has_mut;\n \n+    // guard to prevent null dereference (only required if error state)\n+    if (other.item_type != nullptr)\n+      item_type = other.item_type->clone_type ();\n+    else\n+      item_type = nullptr;\n+\n     return *this;\n   }\n \n@@ -3043,6 +3841,29 @@ class ExternalStaticItem : public ExternalItem\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Returns whether item has outer attributes.\n+  bool has_outer_attrs () const { return !outer_attrs.empty (); }\n+\n+  // Returns whether item has non-default visibility.\n+  bool has_visibility () const { return !visibility.is_error (); }\n+\n+  Location get_locus () const { return locus; }\n+\n+  // Based on idea that type should never be null.\n+  void mark_for_strip () override { item_type = nullptr; };\n+  bool is_marked_for_strip () const override { return item_type == nullptr; };\n+\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Type> &get_type ()\n+  {\n+    rust_assert (item_type != nullptr);\n+    return item_type;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -3057,17 +3878,22 @@ struct NamedFunctionParam\n {\n private:\n   // bool has_name;   // otherwise is _\n-  Identifier name; // TODO: handle wildcard in identifier?\n+  std::string name;\n \n   std::unique_ptr<Type> param_type;\n \n   // TODO: should this store location data?\n \n+  // seemingly new since writing this node\n+  std::vector<Attribute> outer_attrs;\n+\n public:\n-  // Returns whether the named function parameter has a name (i.e. name is not\n-  // '_').\n+  /* Returns whether the named function parameter has a name (i.e. name is not\n+   * '_'). */\n   bool has_name () const { return name != \"_\"; }\n \n+  bool has_outer_attrs () const { return !outer_attrs.empty (); }\n+\n   // Returns whether the named function parameter is in an error state.\n   bool is_error () const\n   {\n@@ -3078,26 +3904,38 @@ struct NamedFunctionParam\n   // Creates an error state named function parameter.\n   static NamedFunctionParam create_error ()\n   {\n-    return NamedFunctionParam (\"\", nullptr);\n+    return NamedFunctionParam (\"\", nullptr, {});\n   }\n \n-  NamedFunctionParam (Identifier name, std::unique_ptr<Type> param_type)\n-    : name (std::move (name)), param_type (std::move (param_type))\n+  NamedFunctionParam (std::string name, std::unique_ptr<Type> param_type,\n+\t\t      std::vector<Attribute> outer_attrs)\n+    : name (std::move (name)), param_type (std::move (param_type)),\n+      outer_attrs (std::move (outer_attrs))\n   {}\n \n   // Copy constructor\n   NamedFunctionParam (NamedFunctionParam const &other)\n-    : name (other.name), param_type (other.param_type->clone_type ())\n-  {}\n+    : name (other.name), outer_attrs (other.outer_attrs)\n+  {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.param_type != nullptr)\n+      param_type = other.param_type->clone_type ();\n+  }\n \n   ~NamedFunctionParam () = default;\n \n   // Overloaded assignment operator to clone\n   NamedFunctionParam &operator= (NamedFunctionParam const &other)\n   {\n     name = other.name;\n-    param_type = other.param_type->clone_type ();\n     // has_name = other.has_name;\n+    outer_attrs = other.outer_attrs;\n+\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.param_type != nullptr)\n+      param_type = other.param_type->clone_type ();\n+    else\n+      param_type = nullptr;\n \n     return *this;\n   }\n@@ -3107,14 +3945,38 @@ struct NamedFunctionParam\n   NamedFunctionParam &operator= (NamedFunctionParam &&other) = default;\n \n   std::string as_string () const;\n+\n+  // Based on idea that nane should never be empty.\n+  void mark_for_strip () { param_type = nullptr; };\n+  bool is_marked_for_strip () const { return is_error (); };\n+\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Type> &get_type ()\n+  {\n+    rust_assert (param_type != nullptr);\n+    return param_type;\n+  }\n };\n \n // A function item used in an extern block\n class ExternalFunctionItem : public ExternalItem\n {\n+  // bool has_outer_attrs;\n+  std::vector<Attribute> outer_attrs;\n+\n+  // bool has_visibility;\n+  Visibility visibility;\n+\n+  Identifier item_name;\n+  Location locus;\n+\n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n \n   // bool has_return_type;\n   // FunctionReturnType return_type;\n@@ -3125,6 +3987,7 @@ class ExternalFunctionItem : public ExternalItem\n \n   std::vector<NamedFunctionParam> function_params;\n   bool has_variadics;\n+  std::vector<Attribute> variadic_outer_attrs;\n \n public:\n   // Returns whether item has generic parameters.\n@@ -3136,28 +3999,56 @@ class ExternalFunctionItem : public ExternalItem\n   // Returns whether item has a where clause.\n   bool has_where_clause () const { return !where_clause.is_empty (); }\n \n+  // Returns whether item has outer attributes.\n+  bool has_outer_attrs () const { return !outer_attrs.empty (); }\n+\n+  // Returns whether item has non-default visibility.\n+  bool has_visibility () const { return !visibility.is_error (); }\n+\n+  // Returns whether item has variadic parameters.\n+  bool is_variadic () const { return has_variadics; }\n+\n+  // Returns whether item has outer attributes on its variadic parameters.\n+  bool has_variadic_outer_attrs () const\n+  {\n+    return !variadic_outer_attrs.empty ();\n+  }\n+\n+  Location get_locus () const { return locus; }\n+\n   ExternalFunctionItem (\n     Identifier item_name,\n-    std::vector<std::unique_ptr<GenericParam>> generic_params,\n+    std::vector<std::unique_ptr<GenericParam> > generic_params,\n     std::unique_ptr<Type> return_type, WhereClause where_clause,\n     std::vector<NamedFunctionParam> function_params, bool has_variadics,\n-    Visibility vis, std::vector<Attribute> outer_attrs, Location locus)\n-    : ExternalItem (std::move (item_name), std::move (vis),\n-\t\t    std::move (outer_attrs), locus),\n+    std::vector<Attribute> variadic_outer_attrs, Visibility vis,\n+    std::vector<Attribute> outer_attrs, Location locus)\n+    : outer_attrs (std::move (outer_attrs)), visibility (std::move (vis)),\n+      item_name (std::move (item_name)), locus (locus),\n       generic_params (std::move (generic_params)),\n       return_type (std::move (return_type)),\n       where_clause (std::move (where_clause)),\n       function_params (std::move (function_params)),\n-      has_variadics (has_variadics)\n-  {}\n+      has_variadics (has_variadics),\n+      variadic_outer_attrs (std::move (variadic_outer_attrs))\n+  {\n+    // TODO: assert that if has variadic outer attrs, then has_variadics is\n+    // true?\n+  }\n \n   // Copy constructor with clone\n   ExternalFunctionItem (ExternalFunctionItem const &other)\n-    : ExternalItem (other), return_type (other.return_type->clone_type ()),\n+    : outer_attrs (other.outer_attrs), visibility (other.visibility),\n+      item_name (other.item_name), locus (other.locus),\n       where_clause (other.where_clause),\n       function_params (other.function_params),\n-      has_variadics (other.has_variadics)\n+      has_variadics (other.has_variadics),\n+      variadic_outer_attrs (other.variadic_outer_attrs)\n   {\n+    // guard to prevent null pointer dereference\n+    if (other.return_type != nullptr)\n+      return_type = other.return_type->clone_type ();\n+\n     generic_params.reserve (other.generic_params.size ());\n     for (const auto &e : other.generic_params)\n       generic_params.push_back (e->clone_generic_param ());\n@@ -3166,11 +4057,20 @@ class ExternalFunctionItem : public ExternalItem\n   // Overloaded assignment operator with clone\n   ExternalFunctionItem &operator= (ExternalFunctionItem const &other)\n   {\n-    ExternalItem::operator= (other);\n-    return_type = other.return_type->clone_type ();\n+    outer_attrs = other.outer_attrs;\n+    visibility = other.visibility;\n+    item_name = other.item_name;\n+    locus = other.locus;\n     where_clause = other.where_clause;\n     function_params = other.function_params;\n     has_variadics = other.has_variadics;\n+    variadic_outer_attrs = other.variadic_outer_attrs;\n+\n+    // guard to prevent null pointer dereference\n+    if (other.return_type != nullptr)\n+      return_type = other.return_type->clone_type ();\n+    else\n+      return_type = nullptr;\n \n     generic_params.reserve (other.generic_params.size ());\n     for (const auto &e : other.generic_params)\n@@ -3187,6 +4087,46 @@ class ExternalFunctionItem : public ExternalItem\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Based on idea that nane should never be empty.\n+  void mark_for_strip () override { item_name = \"\"; };\n+  bool is_marked_for_strip () const override { return item_name.empty (); };\n+\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+\n+  std::vector<NamedFunctionParam> &get_function_params ()\n+  {\n+    return function_params;\n+  }\n+  const std::vector<NamedFunctionParam> &get_function_params () const\n+  {\n+    return function_params;\n+  }\n+\n+  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  {\n+    return generic_params;\n+  }\n+  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  {\n+    return generic_params;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  WhereClause &get_where_clause ()\n+  {\n+    rust_assert (has_where_clause ());\n+    return where_clause;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Type> &get_return_type ()\n+  {\n+    rust_assert (has_return_type ());\n+    return return_type;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -3206,10 +4146,13 @@ class ExternBlock : public VisItem\n   std::vector<Attribute> inner_attrs;\n \n   // bool has_extern_items;\n-  std::vector<std::unique_ptr<ExternalItem>> extern_items;\n+  std::vector<std::unique_ptr<ExternalItem> > extern_items;\n \n   Location locus;\n \n+  // TODO: find another way to store this to save memory?\n+  bool marked_for_strip = false;\n+\n public:\n   std::string as_string () const override;\n \n@@ -3223,7 +4166,7 @@ class ExternBlock : public VisItem\n   bool has_abi () const { return !abi.empty (); }\n \n   ExternBlock (std::string abi,\n-\t       std::vector<std::unique_ptr<ExternalItem>> extern_items,\n+\t       std::vector<std::unique_ptr<ExternalItem> > extern_items,\n \t       Visibility vis, std::vector<Attribute> inner_attrs,\n \t       std::vector<Attribute> outer_attrs, Location locus)\n     : VisItem (std::move (vis), std::move (outer_attrs)), abi (std::move (abi)),\n@@ -3234,7 +4177,7 @@ class ExternBlock : public VisItem\n   // Copy constructor with vector clone\n   ExternBlock (ExternBlock const &other)\n     : VisItem (other), abi (other.abi), inner_attrs (other.inner_attrs),\n-      locus (other.locus)\n+      locus (other.locus), marked_for_strip (other.marked_for_strip)\n   {\n     extern_items.reserve (other.extern_items.size ());\n     for (const auto &e : other.extern_items)\n@@ -3248,6 +4191,7 @@ class ExternBlock : public VisItem\n     abi = other.abi;\n     inner_attrs = other.inner_attrs;\n     locus = other.locus;\n+    marked_for_strip = other.marked_for_strip;\n \n     extern_items.reserve (other.extern_items.size ());\n     for (const auto &e : other.extern_items)\n@@ -3264,19 +4208,31 @@ class ExternBlock : public VisItem\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Can't think of any invalid invariants, so store boolean.\n+  void mark_for_strip () override { marked_for_strip = true; }\n+  bool is_marked_for_strip () const override { return marked_for_strip; }\n+\n+  // TODO: think of better way to do this\n+  const std::vector<std::unique_ptr<ExternalItem> > &get_extern_items () const\n+  {\n+    return extern_items;\n+  }\n+  std::vector<std::unique_ptr<ExternalItem> > &get_extern_items ()\n+  {\n+    return extern_items;\n+  }\n+\n+  // TODO: think of better way to do this\n+  const std::vector<Attribute> &get_inner_attrs () const { return inner_attrs; }\n+  std::vector<Attribute> &get_inner_attrs () { return inner_attrs; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n   ExternBlock *clone_item_impl () const override\n   {\n     return new ExternBlock (*this);\n   }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  /*virtual ExternBlock* clone_statement_impl() const override {\n-      return new ExternBlock(*this);\n-  }*/\n };\n \n // Replaced with forward decls - defined in \"rust-macro.h\""}, {"sha": "2cae0f9fbf57761b0082c1067b6b25c7a3da0185", "filename": "gcc/rust/ast/rust-macro.h", "status": "modified", "additions": 35, "deletions": 20, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc/gcc%2Frust%2Fast%2Frust-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc/gcc%2Frust%2Fast%2Frust-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-macro.h?ref=6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc", "patch": "@@ -124,17 +124,20 @@ class MacroMatchRepetition : public MacroMatch\n \n public:\n   // Returns whether macro match repetition has separator token.\n-  bool has_sep () const { return sep != NULL; }\n+  bool has_sep () const { return sep != nullptr; }\n \n   MacroMatchRepetition (std::vector<std::unique_ptr<MacroMatch> > matches,\n \t\t\tMacroRepOp op, std::unique_ptr<MacroRepSep> sep)\n     : matches (std::move (matches)), op (op), sep (std::move (sep))\n   {}\n \n   // Copy constructor with clone\n-  MacroMatchRepetition (MacroMatchRepetition const &other)\n-    : op (other.op), sep (other.sep->clone_token ())\n+  MacroMatchRepetition (MacroMatchRepetition const &other) : op (other.op)\n   {\n+    // guard to protect from null pointer dereference\n+    if (other.sep != nullptr)\n+      sep = other.sep->clone_token ();\n+\n     matches.reserve (other.matches.size ());\n     for (const auto &e : other.matches)\n       matches.push_back (e->clone_macro_match ());\n@@ -144,7 +147,12 @@ class MacroMatchRepetition : public MacroMatch\n   MacroMatchRepetition &operator= (MacroMatchRepetition const &other)\n   {\n     op = other.op;\n-    sep = other.sep->clone_token ();\n+\n+    // guard to protect from null pointer dereference\n+    if (other.sep != nullptr)\n+      sep = other.sep->clone_token ();\n+    else\n+      sep = nullptr;\n \n     matches.reserve (other.matches.size ());\n     for (const auto &e : other.matches)\n@@ -280,8 +288,9 @@ struct MacroRule\n // A macro rules definition item AST node\n class MacroRulesDefinition : public MacroItem\n {\n+  std::vector<Attribute> outer_attrs;\n   Identifier rule_name;\n-  // MacroRulesDef rules_def; // TODO: inline\n+  // MacroRulesDef rules_def;\n   // only curly without required semicolon at end\n   DelimType delim_type;\n   // MacroRules rules;\n@@ -295,12 +304,23 @@ class MacroRulesDefinition : public MacroItem\n   MacroRulesDefinition (Identifier rule_name, DelimType delim_type,\n \t\t\tstd::vector<MacroRule> rules,\n \t\t\tstd::vector<Attribute> outer_attrs, Location locus)\n-    : MacroItem (std::move (outer_attrs)), rule_name (std::move (rule_name)),\n+    : outer_attrs (std::move (outer_attrs)), rule_name (std::move (rule_name)),\n       delim_type (delim_type), rules (std::move (rules)), locus (locus)\n   {}\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Invalid if rule name is empty, so base stripping on that.\n+  void mark_for_strip () override { rule_name = \"\"; }\n+  bool is_marked_for_strip () const override { return rule_name.empty (); }\n+\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+\n+  std::vector<MacroRule> &get_macro_rules () { return rules; }\n+  const std::vector<MacroRule> &get_macro_rules () const { return rules; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -334,6 +354,13 @@ class MacroInvocation : public TypeNoBounds,\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Invalid if path is empty, so base stripping on that.\n+  void mark_for_strip () override { path = SimplePath::create_empty (); }\n+  bool is_marked_for_strip () const override { return path.is_empty (); }\n+\n+  const SimplePath &get_path () const { return path; }\n+  SimplePath &get_path () { return path; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -342,27 +369,13 @@ class MacroInvocation : public TypeNoBounds,\n     return new MacroInvocation (*this);\n   }\n \n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  MacroInvocation *clone_expr_impl () const override\n-  {\n-    return new MacroInvocation (*this);\n-  }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   MacroInvocation *clone_expr_without_block_impl () const override\n   {\n     return new MacroInvocation (*this);\n   }\n \n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  MacroInvocation *clone_type_impl () const override\n-  {\n-    return new MacroInvocation (*this);\n-  }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   MacroInvocation *clone_type_no_bounds_impl () const override\n@@ -572,6 +585,8 @@ class MetaListNameValueStr : public MetaItem\n };\n \n // Object that parses macros from a token stream.\n+/* TODO: would \"AttributeParser\" be a better name? MetaItems are only for\n+ * attributes, I believe */\n struct MacroParser\n {\n private:"}, {"sha": "392fc18fc6423f52ee9f1ae986c90a3658726308", "filename": "gcc/rust/ast/rust-path.h", "status": "modified", "additions": 173, "deletions": 46, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc/gcc%2Frust%2Fast%2Frust-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc/gcc%2Frust%2Fast%2Frust-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-path.h?ref=6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc", "patch": "@@ -45,7 +45,6 @@ struct GenericArgsBinding\n private:\n   Identifier identifier;\n   std::unique_ptr<Type> type;\n-\n   Location locus;\n \n public:\n@@ -70,9 +69,12 @@ struct GenericArgsBinding\n \n   // Copy constructor has to deep copy the type as it is a unique pointer\n   GenericArgsBinding (GenericArgsBinding const &other)\n-    : identifier (other.identifier), type (other.type->clone_type ()),\n-      locus (other.locus)\n-  {}\n+    : identifier (other.identifier), locus (other.locus)\n+  {\n+    // guard to protect from null pointer dereference\n+    if (other.type != nullptr)\n+      type = other.type->clone_type ();\n+  }\n \n   // default destructor\n   ~GenericArgsBinding () = default;\n@@ -81,8 +83,14 @@ struct GenericArgsBinding\n   GenericArgsBinding &operator= (GenericArgsBinding const &other)\n   {\n     identifier = other.identifier;\n-    type = other.type->clone_type ();\n     locus = other.locus;\n+\n+    // guard to protect from null pointer dereference\n+    if (other.type != nullptr)\n+      type = other.type->clone_type ();\n+    else\n+      type = nullptr;\n+\n     return *this;\n   }\n \n@@ -91,13 +99,20 @@ struct GenericArgsBinding\n   GenericArgsBinding &operator= (GenericArgsBinding &&other) = default;\n \n   std::string as_string () const;\n+\n+  // TODO: is this better? Or is a \"vis_pattern\" better?\n+  std::unique_ptr<Type> &get_type ()\n+  {\n+    rust_assert (type != nullptr);\n+    return type;\n+  }\n };\n \n // Generic arguments allowed in each path expression segment - inline?\n struct GenericArgs\n {\n   std::vector<Lifetime> lifetime_args;\n-  std::vector<std::unique_ptr<Type>> type_args;\n+  std::vector<std::unique_ptr<Type> > type_args;\n   std::vector<GenericArgsBinding> binding_args;\n   Location locus;\n \n@@ -110,7 +125,7 @@ struct GenericArgs\n   }\n \n   GenericArgs (std::vector<Lifetime> lifetime_args,\n-\t       std::vector<std::unique_ptr<Type>> type_args,\n+\t       std::vector<std::unique_ptr<Type> > type_args,\n \t       std::vector<GenericArgsBinding> binding_args,\n \t       Location locus = Location ())\n     : lifetime_args (std::move (lifetime_args)),\n@@ -152,11 +167,17 @@ struct GenericArgs\n   static GenericArgs create_empty ()\n   {\n     return GenericArgs (std::vector<Lifetime> (),\n-\t\t\tstd::vector<std::unique_ptr<Type>> (),\n+\t\t\tstd::vector<std::unique_ptr<Type> > (),\n \t\t\tstd::vector<GenericArgsBinding> ());\n   }\n \n   std::string as_string () const;\n+\n+  // TODO: is this better? Or is a \"vis_pattern\" better?\n+  std::vector<std::unique_ptr<Type> > &get_type_args () { return type_args; }\n+\n+  // TODO: is this better? Or is a \"vis_pattern\" better?\n+  std::vector<GenericArgsBinding> &get_binding_args () { return binding_args; }\n };\n \n /* A segment of a path in expression, including an identifier aspect and maybe\n@@ -189,8 +210,8 @@ class PathExprSegment\n   PathExprSegment (std::string segment_name, Location locus,\n \t\t   std::vector<Lifetime> lifetime_args\n \t\t   = std::vector<Lifetime> (),\n-\t\t   std::vector<std::unique_ptr<Type>> type_args\n-\t\t   = std::vector<std::unique_ptr<Type>> (),\n+\t\t   std::vector<std::unique_ptr<Type> > type_args\n+\t\t   = std::vector<std::unique_ptr<Type> > (),\n \t\t   std::vector<GenericArgsBinding> binding_args\n \t\t   = std::vector<GenericArgsBinding> ())\n     : segment_name (PathIdentSegment (std::move (segment_name))),\n@@ -212,6 +233,13 @@ class PathExprSegment\n   std::string as_string () const;\n \n   Location get_locus () const { return locus; }\n+\n+  // TODO: is this better? Or is a \"vis_pattern\" better?\n+  GenericArgs &get_generic_args ()\n+  {\n+    rust_assert (has_generic_args ());\n+    return generic_args;\n+  }\n };\n \n // AST node representing a pattern that involves a \"path\" - abstract base class\n@@ -231,12 +259,23 @@ class PathPattern : public Pattern\n    * and creates a SimplePath from them. */\n   SimplePath convert_to_simple_path (bool with_opening_scope_resolution) const;\n \n+  // Removes all segments of the path.\n+  void remove_all_segments ()\n+  {\n+    segments.clear ();\n+    segments.shrink_to_fit ();\n+  }\n+\n public:\n   /* Returns whether the path is a single segment (excluding qualified path\n    * initial as segment). */\n   bool is_single_segment () const { return segments.size () == 1; }\n \n   std::string as_string () const override;\n+\n+  // TODO: this seems kinda dodgy\n+  std::vector<PathExprSegment> &get_segments () { return segments; }\n+  const std::vector<PathExprSegment> &get_segments () const { return segments; }\n };\n \n /* AST node representing a path-in-expression pattern (path that allows generic\n@@ -286,6 +325,10 @@ class PathInExpression : public PathPattern, public PathExpr\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Invalid if path is empty (error state), so base stripping on that.\n+  void mark_for_strip () override { remove_all_segments (); }\n+  bool is_marked_for_strip () const override { return is_error (); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -312,7 +355,6 @@ class TypePathSegment\n    * GenericArgs are, so could disallow that in constructor, which won't give\n    * that much size overhead. */\n   PathIdentSegment ident_segment;\n-\n   Location locus;\n \n protected:\n@@ -387,7 +429,7 @@ class TypePathSegmentGeneric : public TypePathSegment\n   TypePathSegmentGeneric (std::string segment_name,\n \t\t\t  bool has_separating_scope_resolution,\n \t\t\t  std::vector<Lifetime> lifetime_args,\n-\t\t\t  std::vector<std::unique_ptr<Type>> type_args,\n+\t\t\t  std::vector<std::unique_ptr<Type> > type_args,\n \t\t\t  std::vector<GenericArgsBinding> binding_args,\n \t\t\t  Location locus)\n     : TypePathSegment (std::move (segment_name),\n@@ -401,6 +443,13 @@ class TypePathSegmentGeneric : public TypePathSegment\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: is this better? Or is a \"vis_pattern\" better?\n+  GenericArgs &get_generic_args ()\n+  {\n+    rust_assert (has_generic_args ());\n+    return generic_args;\n+  }\n+\n protected:\n   // Use covariance to override base class method\n   TypePathSegmentGeneric *clone_type_path_segment_impl () const override\n@@ -417,7 +466,7 @@ struct TypePathFunction\n   /*bool has_inputs;\n   TypePathFnInputs inputs;*/\n   // inlined from TypePathFnInputs\n-  std::vector<std::unique_ptr<Type>> inputs;\n+  std::vector<std::unique_ptr<Type> > inputs;\n \n   // bool has_type;\n   std::unique_ptr<Type> return_type;\n@@ -445,24 +494,20 @@ struct TypePathFunction\n   static TypePathFunction create_error () { return TypePathFunction (true); }\n \n   // Constructor\n-  TypePathFunction (std::vector<std::unique_ptr<Type>> inputs,\n-\t\t    Type *type = nullptr)\n-    : inputs (std::move (inputs)), return_type (type), is_invalid (false)\n-  {}\n-  // FIXME: deprecated\n-\n-  // Constructor\n-  TypePathFunction (std::vector<std::unique_ptr<Type>> inputs,\n+  TypePathFunction (std::vector<std::unique_ptr<Type> > inputs,\n \t\t    std::unique_ptr<Type> type = nullptr)\n     : inputs (std::move (inputs)), return_type (std::move (type)),\n       is_invalid (false)\n   {}\n \n   // Copy constructor with clone\n   TypePathFunction (TypePathFunction const &other)\n-    : return_type (other.return_type->clone_type ()),\n-      is_invalid (other.is_invalid)\n+    : is_invalid (other.is_invalid)\n   {\n+    // guard to protect from null pointer dereference\n+    if (other.return_type != nullptr)\n+      return_type = other.return_type->clone_type ();\n+\n     inputs.reserve (other.inputs.size ());\n     for (const auto &e : other.inputs)\n       inputs.push_back (e->clone_type ());\n@@ -473,9 +518,14 @@ struct TypePathFunction\n   // Overloaded assignment operator to clone type\n   TypePathFunction &operator= (TypePathFunction const &other)\n   {\n-    return_type = other.return_type->clone_type ();\n     is_invalid = other.is_invalid;\n \n+    // guard to protect from null pointer dereference\n+    if (other.return_type != nullptr)\n+      return_type = other.return_type->clone_type ();\n+    else\n+      return_type = nullptr;\n+\n     inputs.reserve (other.inputs.size ());\n     for (const auto &e : other.inputs)\n       inputs.push_back (e->clone_type ());\n@@ -488,6 +538,20 @@ struct TypePathFunction\n   TypePathFunction &operator= (TypePathFunction &&other) = default;\n \n   std::string as_string () const;\n+\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  const std::vector<std::unique_ptr<Type> > &get_params () const\n+  {\n+    return inputs;\n+  }\n+  std::vector<std::unique_ptr<Type> > &get_params () { return inputs; }\n+\n+  // TODO: is this better? Or is a \"vis_pattern\" better?\n+  std::unique_ptr<Type> &get_return_type ()\n+  {\n+    rust_assert (has_return_type ());\n+    return return_type;\n+  }\n };\n \n // Segment used in type path with a function argument\n@@ -520,6 +584,13 @@ class TypePathSegmentFunction : public TypePathSegment\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: is this better? Or is a \"vis_pattern\" better?\n+  TypePathFunction &get_type_path_function ()\n+  {\n+    rust_assert (!function_path.is_error ());\n+    return function_path;\n+  }\n+\n protected:\n   // Use covariance to override base class method\n   TypePathSegmentFunction *clone_type_path_segment_impl () const override\n@@ -531,16 +602,11 @@ class TypePathSegmentFunction : public TypePathSegment\n // Path used inside types\n class TypePath : public TypeNoBounds\n {\n-public:\n   bool has_opening_scope_resolution;\n-  std::vector<std::unique_ptr<TypePathSegment>> segments;\n+  std::vector<std::unique_ptr<TypePathSegment> > segments;\n   Location locus;\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  TypePath *clone_type_impl () const override { return new TypePath (*this); }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   TypePath *clone_type_no_bounds_impl () const override\n@@ -562,12 +628,12 @@ class TypePath : public TypeNoBounds\n   // Creates an error state TypePath.\n   static TypePath create_error ()\n   {\n-    return TypePath (std::vector<std::unique_ptr<TypePathSegment>> (),\n+    return TypePath (std::vector<std::unique_ptr<TypePathSegment> > (),\n \t\t     Location ());\n   }\n \n   // Constructor\n-  TypePath (std::vector<std::unique_ptr<TypePathSegment>> segments,\n+  TypePath (std::vector<std::unique_ptr<TypePathSegment> > segments,\n \t    Location locus, bool has_opening_scope_resolution = false)\n     : has_opening_scope_resolution (has_opening_scope_resolution),\n       segments (std::move (segments)), locus (locus)\n@@ -610,8 +676,19 @@ class TypePath : public TypeNoBounds\n   TraitBound *to_trait_bound (bool in_parens) const override;\n \n   Location get_locus () const { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n+\n+  // TODO: this seems kinda dodgy\n+  std::vector<std::unique_ptr<TypePathSegment> > &get_segments ()\n+  {\n+    return segments;\n+  }\n+  const std::vector<std::unique_ptr<TypePathSegment> > &get_segments () const\n+  {\n+    return segments;\n+  }\n };\n \n struct QualifiedPathType\n@@ -635,19 +712,28 @@ struct QualifiedPathType\n \n   // Copy constructor uses custom deep copy for Type to preserve polymorphism\n   QualifiedPathType (QualifiedPathType const &other)\n-    : type_to_invoke_on (other.type_to_invoke_on->clone_type ()),\n-      trait_path (other.trait_path), locus (other.locus)\n-  {}\n+    : trait_path (other.trait_path), locus (other.locus)\n+  {\n+    // guard to prevent null dereference\n+    if (other.type_to_invoke_on != nullptr)\n+      type_to_invoke_on = other.type_to_invoke_on->clone_type ();\n+  }\n \n   // default destructor\n   ~QualifiedPathType () = default;\n \n   // overload assignment operator to use custom clone method\n   QualifiedPathType &operator= (QualifiedPathType const &other)\n   {\n-    type_to_invoke_on = other.type_to_invoke_on->clone_type ();\n     trait_path = other.trait_path;\n     locus = other.locus;\n+\n+    // guard to prevent null dereference\n+    if (other.type_to_invoke_on != nullptr)\n+      type_to_invoke_on = other.type_to_invoke_on->clone_type ();\n+    else\n+      type_to_invoke_on = nullptr;\n+\n     return *this;\n   }\n \n@@ -670,6 +756,20 @@ struct QualifiedPathType\n   std::string as_string () const;\n \n   Location get_locus () const { return locus; }\n+\n+  // TODO: is this better? Or is a \"vis_pattern\" better?\n+  std::unique_ptr<Type> &get_type ()\n+  {\n+    rust_assert (type_to_invoke_on != nullptr);\n+    return type_to_invoke_on;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_pattern\" better?\n+  TypePath &get_as_type_path ()\n+  {\n+    rust_assert (has_as_clause ());\n+    return trait_path;\n+  }\n };\n \n /* AST node representing a qualified path-in-expression pattern (path that\n@@ -710,6 +810,20 @@ class QualifiedPathInExpression : public PathPattern, public PathExpr\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Invalid if path_type is error, so base stripping on that.\n+  void mark_for_strip () override\n+  {\n+    path_type = QualifiedPathType::create_error ();\n+  }\n+  bool is_marked_for_strip () const override { return is_error (); }\n+\n+  // TODO: is this better? Or is a \"vis_pattern\" better?\n+  QualifiedPathType &get_qualified_path_type ()\n+  {\n+    rust_assert (!path_type.is_error ());\n+    return path_type;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -731,17 +845,10 @@ class QualifiedPathInExpression : public PathPattern, public PathExpr\n class QualifiedPathInType : public TypeNoBounds\n {\n   QualifiedPathType path_type;\n-  std::vector<std::unique_ptr<TypePathSegment>> segments;\n+  std::vector<std::unique_ptr<TypePathSegment> > segments;\n   Location locus;\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  QualifiedPathInType *clone_type_impl () const override\n-  {\n-    return new QualifiedPathInType (*this);\n-  }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   QualifiedPathInType *clone_type_no_bounds_impl () const override\n@@ -752,7 +859,7 @@ class QualifiedPathInType : public TypeNoBounds\n public:\n   QualifiedPathInType (\n     QualifiedPathType qual_path_type,\n-    std::vector<std::unique_ptr<TypePathSegment>> path_segments,\n+    std::vector<std::unique_ptr<TypePathSegment> > path_segments,\n     Location locus = Location ())\n     : path_type (std::move (qual_path_type)),\n       segments (std::move (path_segments)), locus (locus)\n@@ -795,12 +902,32 @@ class QualifiedPathInType : public TypeNoBounds\n   {\n     return QualifiedPathInType (\n       QualifiedPathType::create_error (),\n-      std::vector<std::unique_ptr<TypePathSegment>> ());\n+      std::vector<std::unique_ptr<TypePathSegment> > ());\n   }\n \n   std::string as_string () const override;\n \n   void accept_vis (ASTVisitor &vis) override;\n+\n+  // TODO: is this better? Or is a \"vis_pattern\" better?\n+  QualifiedPathType &get_qualified_path_type ()\n+  {\n+    rust_assert (!path_type.is_error ());\n+    return path_type;\n+  }\n+\n+  // TODO: this seems kinda dodgy\n+  std::vector<std::unique_ptr<TypePathSegment> > &get_segments ()\n+  {\n+    return segments;\n+  }\n+  const std::vector<std::unique_ptr<TypePathSegment> > &get_segments () const\n+  {\n+    return segments;\n+  }\n+\n+  Location get_locus () const { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n };\n } // namespace AST\n } // namespace Rust"}, {"sha": "3a87a835906ce757be827b8dfd0583b19610939e", "filename": "gcc/rust/ast/rust-pattern.h", "status": "modified", "additions": 297, "deletions": 44, "changes": 341, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc/gcc%2Frust%2Fast%2Frust-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc/gcc%2Frust%2Fast%2Frust-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-pattern.h?ref=6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc", "patch": "@@ -34,6 +34,7 @@ class LiteralPattern : public Pattern\n   {}\n \n   Location get_locus () const { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n@@ -49,7 +50,6 @@ class LiteralPattern : public Pattern\n // Identifier pattern AST node (bind value matched to a variable)\n class IdentifierPattern : public Pattern\n {\n-public:\n   Identifier variable_ident;\n   bool is_ref;\n   bool is_mut;\n@@ -59,6 +59,7 @@ class IdentifierPattern : public Pattern\n \n   Location locus;\n \n+public:\n   std::string as_string () const;\n \n   // Returns whether the IdentifierPattern has a pattern to bind.\n@@ -77,7 +78,7 @@ class IdentifierPattern : public Pattern\n     : variable_ident (other.variable_ident), is_ref (other.is_ref),\n       is_mut (other.is_mut), locus (other.locus)\n   {\n-    // fix to get prevent null pointer dereference\n+    // fix to prevent null pointer dereference\n     if (other.to_bind != nullptr)\n       to_bind = other.to_bind->clone_pattern ();\n   }\n@@ -90,9 +91,11 @@ class IdentifierPattern : public Pattern\n     is_mut = other.is_mut;\n     locus = other.locus;\n \n-    // fix to get prevent null pointer dereference\n+    // fix to prevent null pointer dereference\n     if (other.to_bind != nullptr)\n       to_bind = other.to_bind->clone_pattern ();\n+    else\n+      to_bind = nullptr;\n \n     return *this;\n   }\n@@ -102,9 +105,19 @@ class IdentifierPattern : public Pattern\n   IdentifierPattern &operator= (IdentifierPattern &&other) = default;\n \n   Location get_locus () const { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: is this better? Or is a \"vis_pattern\" better?\n+  std::unique_ptr<Pattern> &get_pattern_to_bind ()\n+  {\n+    rust_assert (has_pattern_to_bind ());\n+    return to_bind;\n+  }\n+\n+  Identifier get_ident () const { return variable_ident; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -125,6 +138,7 @@ class WildcardPattern : public Pattern\n   WildcardPattern (Location locus) : locus (locus) {}\n \n   Location get_locus () const { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n@@ -210,6 +224,10 @@ class RangePatternBoundPath : public RangePatternBound\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: this mutable getter seems kinda dodgy\n+  PathInExpression &get_path () { return path; }\n+  const PathInExpression &get_path () const { return path; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -238,6 +256,10 @@ class RangePatternBoundQualPath : public RangePatternBound\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: this mutable getter seems kinda dodgy\n+  QualifiedPathInExpression &get_qualified_path () { return path; }\n+  const QualifiedPathInExpression &get_qualified_path () const { return path; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -293,9 +315,23 @@ class RangePattern : public Pattern\n   RangePattern &operator= (RangePattern &&other) = default;\n \n   Location get_locus () const { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: is this better? or is a \"vis_bound\" better?\n+  std::unique_ptr<RangePatternBound> &get_lower_bound ()\n+  {\n+    rust_assert (lower != nullptr);\n+    return lower;\n+  }\n+\n+  std::unique_ptr<RangePatternBound> &get_upper_bound ()\n+  {\n+    rust_assert (upper != nullptr);\n+    return upper;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -343,8 +379,18 @@ class ReferencePattern : public Pattern\n   ReferencePattern (ReferencePattern &&other) = default;\n   ReferencePattern &operator= (ReferencePattern &&other) = default;\n \n+  Location get_locus () const { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n+\n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: is this better? Or is a \"vis_pattern\" better?\n+  std::unique_ptr<Pattern> &get_referenced_pattern ()\n+  {\n+    rust_assert (pattern != nullptr);\n+    return pattern;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -354,6 +400,7 @@ class ReferencePattern : public Pattern\n   }\n };\n \n+#if 0\n // aka StructPatternEtCetera; potential element in struct pattern\n struct StructPatternEtc\n {\n@@ -373,6 +420,7 @@ struct StructPatternEtc\n     return StructPatternEtc (std::vector<Attribute> ());\n   }\n };\n+#endif\n \n // Base class for a single field in a struct pattern - abstract\n class StructPatternField\n@@ -396,6 +444,13 @@ class StructPatternField\n \n   virtual void accept_vis (ASTVisitor &vis) = 0;\n \n+  virtual void mark_for_strip () = 0;\n+  virtual bool is_marked_for_strip () const = 0;\n+\n+  // TODO: seems kinda dodgy. Think of better way.\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+\n protected:\n   StructPatternField (std::vector<Attribute> outer_attribs, Location locus)\n     : outer_attrs (std::move (outer_attribs)), locus (locus)\n@@ -422,19 +477,27 @@ class StructPatternFieldTuplePat : public StructPatternField\n \n   // Copy constructor requires clone\n   StructPatternFieldTuplePat (StructPatternFieldTuplePat const &other)\n-    : StructPatternField (other), index (other.index),\n-      tuple_pattern (other.tuple_pattern->clone_pattern ())\n-  {}\n+    : StructPatternField (other), index (other.index)\n+  {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.tuple_pattern != nullptr)\n+      tuple_pattern = other.tuple_pattern->clone_pattern ();\n+  }\n \n   // Overload assignment operator to perform clone\n   StructPatternFieldTuplePat &\n   operator= (StructPatternFieldTuplePat const &other)\n   {\n     StructPatternField::operator= (other);\n-    tuple_pattern = other.tuple_pattern->clone_pattern ();\n     index = other.index;\n     // outer_attrs = other.outer_attrs;\n \n+    // guard to prevent null dereference (only required if error state)\n+    if (other.tuple_pattern != nullptr)\n+      tuple_pattern = other.tuple_pattern->clone_pattern ();\n+    else\n+      tuple_pattern = nullptr;\n+\n     return *this;\n   }\n \n@@ -447,6 +510,20 @@ class StructPatternFieldTuplePat : public StructPatternField\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // based on idea of tuple pattern no longer existing\n+  void mark_for_strip () override { tuple_pattern = nullptr; }\n+  bool is_marked_for_strip () const override\n+  {\n+    return tuple_pattern == nullptr;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_pattern\" better?\n+  std::unique_ptr<Pattern> &get_index_pattern ()\n+  {\n+    rust_assert (tuple_pattern != nullptr);\n+    return tuple_pattern;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -473,19 +550,27 @@ class StructPatternFieldIdentPat : public StructPatternField\n \n   // Copy constructor requires clone\n   StructPatternFieldIdentPat (StructPatternFieldIdentPat const &other)\n-    : StructPatternField (other), ident (other.ident),\n-      ident_pattern (other.ident_pattern->clone_pattern ())\n-  {}\n+    : StructPatternField (other), ident (other.ident)\n+  {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.ident_pattern != nullptr)\n+      ident_pattern = other.ident_pattern->clone_pattern ();\n+  }\n \n   // Overload assignment operator to clone\n   StructPatternFieldIdentPat &\n   operator= (StructPatternFieldIdentPat const &other)\n   {\n     StructPatternField::operator= (other);\n     ident = other.ident;\n-    ident_pattern = other.ident_pattern->clone_pattern ();\n     // outer_attrs = other.outer_attrs;\n \n+    // guard to prevent null dereference (only required if error state)\n+    if (other.ident_pattern != nullptr)\n+      ident_pattern = other.ident_pattern->clone_pattern ();\n+    else\n+      ident_pattern = nullptr;\n+\n     return *this;\n   }\n \n@@ -498,6 +583,20 @@ class StructPatternFieldIdentPat : public StructPatternField\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // based on idea of identifier pattern no longer existing\n+  void mark_for_strip () override { ident_pattern = nullptr; }\n+  bool is_marked_for_strip () const override\n+  {\n+    return ident_pattern == nullptr;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_pattern\" better?\n+  std::unique_ptr<Pattern> &get_ident_pattern ()\n+  {\n+    rust_assert (ident_pattern != nullptr);\n+    return ident_pattern;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -525,6 +624,10 @@ class StructPatternFieldIdent : public StructPatternField\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // based on idea of identifier no longer existing\n+  void mark_for_strip () override { ident = {}; }\n+  bool is_marked_for_strip () const override { return ident.empty (); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -539,10 +642,11 @@ struct StructPatternElements\n {\n private:\n   // bool has_struct_pattern_fields;\n-  std::vector<std::unique_ptr<StructPatternField>> fields;\n+  std::vector<std::unique_ptr<StructPatternField> > fields;\n \n   bool has_struct_pattern_etc;\n-  StructPatternEtc etc;\n+  std::vector<Attribute> struct_pattern_etc_attrs;\n+  // StructPatternEtc etc;\n \n   // must have at least one of the two and maybe both\n \n@@ -559,24 +663,27 @@ struct StructPatternElements\n     return !has_struct_pattern_fields () && !has_struct_pattern_etc;\n   }\n \n+  bool has_etc () const { return has_struct_pattern_etc; }\n+\n   // Constructor for StructPatternElements with both (potentially)\n   StructPatternElements (\n-    std::vector<std::unique_ptr<StructPatternField>> fields,\n-    StructPatternEtc etc)\n+    std::vector<std::unique_ptr<StructPatternField> > fields,\n+    std::vector<Attribute> etc_attrs)\n     : fields (std::move (fields)), has_struct_pattern_etc (true),\n-      etc (std::move (etc))\n+      struct_pattern_etc_attrs (std::move (etc_attrs))\n   {}\n \n   // Constructor for StructPatternElements with no StructPatternEtc\n   StructPatternElements (\n-    std::vector<std::unique_ptr<StructPatternField>> fields)\n+    std::vector<std::unique_ptr<StructPatternField> > fields)\n     : fields (std::move (fields)), has_struct_pattern_etc (false),\n-      etc (StructPatternEtc::create_empty ())\n+      struct_pattern_etc_attrs ()\n   {}\n \n   // Copy constructor with vector clone\n   StructPatternElements (StructPatternElements const &other)\n-    : has_struct_pattern_etc (other.has_struct_pattern_etc), etc (other.etc)\n+    : has_struct_pattern_etc (other.has_struct_pattern_etc),\n+      struct_pattern_etc_attrs (other.struct_pattern_etc_attrs)\n   {\n     fields.reserve (other.fields.size ());\n     for (const auto &e : other.fields)\n@@ -586,7 +693,7 @@ struct StructPatternElements\n   // Overloaded assignment operator with vector clone\n   StructPatternElements &operator= (StructPatternElements const &other)\n   {\n-    etc = other.etc;\n+    struct_pattern_etc_attrs = other.struct_pattern_etc_attrs;\n     has_struct_pattern_etc = other.has_struct_pattern_etc;\n \n     fields.reserve (other.fields.size ());\n@@ -604,10 +711,38 @@ struct StructPatternElements\n   static StructPatternElements create_empty ()\n   {\n     return StructPatternElements (\n-      std::vector<std::unique_ptr<StructPatternField>> ());\n+      std::vector<std::unique_ptr<StructPatternField> > ());\n   }\n \n   std::string as_string () const;\n+\n+  // TODO: seems kinda dodgy. Think of better way.\n+  std::vector<std::unique_ptr<StructPatternField> > &\n+  get_struct_pattern_fields ()\n+  {\n+    return fields;\n+  }\n+  const std::vector<std::unique_ptr<StructPatternField> > &\n+  get_struct_pattern_fields () const\n+  {\n+    return fields;\n+  }\n+\n+  std::vector<Attribute> &get_etc_outer_attrs ()\n+  {\n+    return struct_pattern_etc_attrs;\n+  }\n+  const std::vector<Attribute> &get_etc_outer_attrs () const\n+  {\n+    return struct_pattern_etc_attrs;\n+  }\n+\n+  void strip_etc ()\n+  {\n+    has_struct_pattern_etc = false;\n+    struct_pattern_etc_attrs.clear ();\n+    struct_pattern_etc_attrs.shrink_to_fit ();\n+  }\n };\n \n // Struct pattern AST node representation\n@@ -638,9 +773,20 @@ class StructPattern : public Pattern\n   bool has_struct_pattern_elems () const { return !elems.is_empty (); }\n \n   Location get_locus () const { return path.get_locus (); }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: seems kinda dodgy. Think of better way.\n+  StructPatternElements &get_struct_pattern_elems () { return elems; }\n+  const StructPatternElements &get_struct_pattern_elems () const\n+  {\n+    return elems;\n+  }\n+\n+  PathInExpression &get_path () { return path; }\n+  const PathInExpression &get_path () const { return path; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -676,10 +822,10 @@ class TupleStructItems\n // Class for non-ranged tuple struct pattern patterns\n class TupleStructItemsNoRange : public TupleStructItems\n {\n-  std::vector<std::unique_ptr<Pattern>> patterns;\n+  std::vector<std::unique_ptr<Pattern> > patterns;\n \n public:\n-  TupleStructItemsNoRange (std::vector<std::unique_ptr<Pattern>> patterns)\n+  TupleStructItemsNoRange (std::vector<std::unique_ptr<Pattern> > patterns)\n     : patterns (std::move (patterns))\n   {}\n \n@@ -710,6 +856,13 @@ class TupleStructItemsNoRange : public TupleStructItems\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: seems kinda dodgy. Think of better way.\n+  std::vector<std::unique_ptr<Pattern> > &get_patterns () { return patterns; }\n+  const std::vector<std::unique_ptr<Pattern> > &get_patterns () const\n+  {\n+    return patterns;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -722,12 +875,12 @@ class TupleStructItemsNoRange : public TupleStructItems\n // Class for ranged tuple struct pattern patterns\n class TupleStructItemsRange : public TupleStructItems\n {\n-  std::vector<std::unique_ptr<Pattern>> lower_patterns;\n-  std::vector<std::unique_ptr<Pattern>> upper_patterns;\n+  std::vector<std::unique_ptr<Pattern> > lower_patterns;\n+  std::vector<std::unique_ptr<Pattern> > upper_patterns;\n \n public:\n-  TupleStructItemsRange (std::vector<std::unique_ptr<Pattern>> lower_patterns,\n-\t\t\t std::vector<std::unique_ptr<Pattern>> upper_patterns)\n+  TupleStructItemsRange (std::vector<std::unique_ptr<Pattern> > lower_patterns,\n+\t\t\t std::vector<std::unique_ptr<Pattern> > upper_patterns)\n     : lower_patterns (std::move (lower_patterns)),\n       upper_patterns (std::move (upper_patterns))\n   {}\n@@ -766,6 +919,26 @@ class TupleStructItemsRange : public TupleStructItems\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: seems kinda dodgy. Think of better way.\n+  std::vector<std::unique_ptr<Pattern> > &get_lower_patterns ()\n+  {\n+    return lower_patterns;\n+  }\n+  const std::vector<std::unique_ptr<Pattern> > &get_lower_patterns () const\n+  {\n+    return lower_patterns;\n+  }\n+\n+  // TODO: seems kinda dodgy. Think of better way.\n+  std::vector<std::unique_ptr<Pattern> > &get_upper_patterns ()\n+  {\n+    return upper_patterns;\n+  }\n+  const std::vector<std::unique_ptr<Pattern> > &get_upper_patterns () const\n+  {\n+    return upper_patterns;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -787,21 +960,32 @@ class TupleStructPattern : public Pattern\n public:\n   std::string as_string () const override;\n \n+  // Returns whether the pattern has tuple struct items.\n+  bool has_items () const { return items != nullptr; }\n+\n   TupleStructPattern (PathInExpression tuple_struct_path,\n \t\t      std::unique_ptr<TupleStructItems> items)\n     : path (std::move (tuple_struct_path)), items (std::move (items))\n   {}\n \n   // Copy constructor required to clone\n-  TupleStructPattern (TupleStructPattern const &other)\n-    : path (other.path), items (other.items->clone_tuple_struct_items ())\n-  {}\n+  TupleStructPattern (TupleStructPattern const &other) : path (other.path)\n+  {\n+    // guard to protect from null dereference\n+    if (other.items != nullptr)\n+      items = other.items->clone_tuple_struct_items ();\n+  }\n \n   // Operator overload assignment operator to clone\n   TupleStructPattern &operator= (TupleStructPattern const &other)\n   {\n     path = other.path;\n-    items = other.items->clone_tuple_struct_items ();\n+\n+    // guard to protect from null dereference\n+    if (other.items != nullptr)\n+      items = other.items->clone_tuple_struct_items ();\n+    else\n+      items = nullptr;\n \n     return *this;\n   }\n@@ -811,9 +995,20 @@ class TupleStructPattern : public Pattern\n   TupleStructPattern &operator= (TupleStructPattern &&other) = default;\n \n   Location get_locus () const { return path.get_locus (); }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: seems kinda dodgy. Think of better way.\n+  std::unique_ptr<TupleStructItems> &get_items ()\n+  {\n+    rust_assert (has_items ());\n+    return items;\n+  }\n+\n+  PathInExpression &get_path () { return path; }\n+  const PathInExpression &get_path () const { return path; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -885,10 +1080,10 @@ TuplePatternItemsSingle(*this);\n // Class representing TuplePattern patterns where there are multiple patterns\n class TuplePatternItemsMultiple : public TuplePatternItems\n {\n-  std::vector<std::unique_ptr<Pattern>> patterns;\n+  std::vector<std::unique_ptr<Pattern> > patterns;\n \n public:\n-  TuplePatternItemsMultiple (std::vector<std::unique_ptr<Pattern>> patterns)\n+  TuplePatternItemsMultiple (std::vector<std::unique_ptr<Pattern> > patterns)\n     : patterns (std::move (patterns))\n   {}\n \n@@ -919,6 +1114,13 @@ class TuplePatternItemsMultiple : public TuplePatternItems\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: seems kinda dodgy. Think of better way.\n+  std::vector<std::unique_ptr<Pattern> > &get_patterns () { return patterns; }\n+  const std::vector<std::unique_ptr<Pattern> > &get_patterns () const\n+  {\n+    return patterns;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -931,13 +1133,13 @@ class TuplePatternItemsMultiple : public TuplePatternItems\n // Class representing TuplePattern patterns where there are a range of patterns\n class TuplePatternItemsRanged : public TuplePatternItems\n {\n-  std::vector<std::unique_ptr<Pattern>> lower_patterns;\n-  std::vector<std::unique_ptr<Pattern>> upper_patterns;\n+  std::vector<std::unique_ptr<Pattern> > lower_patterns;\n+  std::vector<std::unique_ptr<Pattern> > upper_patterns;\n \n public:\n   TuplePatternItemsRanged (\n-    std::vector<std::unique_ptr<Pattern>> lower_patterns,\n-    std::vector<std::unique_ptr<Pattern>> upper_patterns)\n+    std::vector<std::unique_ptr<Pattern> > lower_patterns,\n+    std::vector<std::unique_ptr<Pattern> > upper_patterns)\n     : lower_patterns (std::move (lower_patterns)),\n       upper_patterns (std::move (upper_patterns))\n   {}\n@@ -977,6 +1179,26 @@ class TuplePatternItemsRanged : public TuplePatternItems\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: seems kinda dodgy. Think of better way.\n+  std::vector<std::unique_ptr<Pattern> > &get_lower_patterns ()\n+  {\n+    return lower_patterns;\n+  }\n+  const std::vector<std::unique_ptr<Pattern> > &get_lower_patterns () const\n+  {\n+    return lower_patterns;\n+  }\n+\n+  // TODO: seems kinda dodgy. Think of better way.\n+  std::vector<std::unique_ptr<Pattern> > &get_upper_patterns ()\n+  {\n+    return upper_patterns;\n+  }\n+  const std::vector<std::unique_ptr<Pattern> > &get_upper_patterns () const\n+  {\n+    return upper_patterns;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -991,7 +1213,6 @@ class TuplePattern : public Pattern\n {\n   // bool has_tuple_pattern_items;\n   std::unique_ptr<TuplePatternItems> items;\n-\n   Location locus;\n \n public:\n@@ -1005,23 +1226,39 @@ class TuplePattern : public Pattern\n   {}\n \n   // Copy constructor requires clone\n-  TuplePattern (TuplePattern const &other)\n-    : items (other.items->clone_tuple_pattern_items ()), locus (other.locus)\n-  {}\n+  TuplePattern (TuplePattern const &other) : locus (other.locus)\n+  {\n+    // guard to prevent null dereference\n+    if (other.items != nullptr)\n+      items = other.items->clone_tuple_pattern_items ();\n+  }\n \n   // Overload assignment operator to clone\n   TuplePattern &operator= (TuplePattern const &other)\n   {\n-    items = other.items->clone_tuple_pattern_items ();\n     locus = other.locus;\n \n+    // guard to prevent null dereference\n+    if (other.items != nullptr)\n+      items = other.items->clone_tuple_pattern_items ();\n+    else\n+      items = nullptr;\n+\n     return *this;\n   }\n \n   Location get_locus () const { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: seems kinda dodgy. Think of better way.\n+  std::unique_ptr<TuplePatternItems> &get_items ()\n+  {\n+    rust_assert (has_tuple_pattern_items ());\n+    return items;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1067,9 +1304,17 @@ class GroupedPattern : public Pattern\n   GroupedPattern &operator= (GroupedPattern &&other) = default;\n \n   Location get_locus () const { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: seems kinda dodgy. Think of better way.\n+  std::unique_ptr<Pattern> &get_pattern_in_parens ()\n+  {\n+    rust_assert (pattern_in_parens != nullptr);\n+    return pattern_in_parens;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1082,13 +1327,13 @@ class GroupedPattern : public Pattern\n // AST node representing patterns that can match slices and arrays\n class SlicePattern : public Pattern\n {\n-  std::vector<std::unique_ptr<Pattern>> items;\n+  std::vector<std::unique_ptr<Pattern> > items;\n   Location locus;\n \n public:\n   std::string as_string () const override;\n \n-  SlicePattern (std::vector<std::unique_ptr<Pattern>> items, Location locus)\n+  SlicePattern (std::vector<std::unique_ptr<Pattern> > items, Location locus)\n     : items (std::move (items)), locus (locus)\n   {}\n \n@@ -1117,9 +1362,17 @@ class SlicePattern : public Pattern\n   SlicePattern &operator= (SlicePattern &&other) = default;\n \n   Location get_locus () const { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: seems kinda dodgy. Think of better way.\n+  std::vector<std::unique_ptr<Pattern> > &get_items () { return items; }\n+  const std::vector<std::unique_ptr<Pattern> > &get_items () const\n+  {\n+    return items;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "faea905d0552b610644fe79df5ede73a3fdab6d2", "filename": "gcc/rust/ast/rust-stmt.h", "status": "modified", "additions": 115, "deletions": 20, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc/gcc%2Frust%2Fast%2Frust-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc/gcc%2Frust%2Fast%2Frust-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-stmt.h?ref=6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc", "patch": "@@ -12,6 +12,9 @@ class EmptyStmt : public Stmt\n {\n   Location locus;\n \n+  // TODO: find another way to store this to save memory?\n+  bool marked_for_strip = false;\n+\n public:\n   std::string as_string () const override { return std::string (1, ';'); }\n \n@@ -21,6 +24,10 @@ class EmptyStmt : public Stmt\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Can't think of any invalid invariants, so store boolean.\n+  void mark_for_strip () override { marked_for_strip = true; }\n+  bool is_marked_for_strip () const override { return marked_for_strip; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -31,7 +38,6 @@ class EmptyStmt : public Stmt\n  * introduces new name into scope */\n class LetStmt : public Stmt\n {\n-public:\n   // bool has_outer_attrs;\n   std::vector<Attribute> outer_attrs;\n \n@@ -45,6 +51,7 @@ class LetStmt : public Stmt\n \n   Location locus;\n \n+public:\n   Type *inferedType;\n \n   // Returns whether let statement has outer attributes.\n@@ -68,21 +75,41 @@ class LetStmt : public Stmt\n \n   // Copy constructor with clone\n   LetStmt (LetStmt const &other)\n-    : outer_attrs (other.outer_attrs),\n-      variables_pattern (other.variables_pattern->clone_pattern ()),\n-      type (other.type->clone_type ()),\n-      init_expr (other.init_expr->clone_expr ()), locus (other.locus)\n-  {}\n+    : outer_attrs (other.outer_attrs), locus (other.locus)\n+  {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.variables_pattern != nullptr)\n+      variables_pattern = other.variables_pattern->clone_pattern ();\n+\n+    // guard to prevent null dereference (always required)\n+    if (other.init_expr != nullptr)\n+      init_expr = other.init_expr->clone_expr ();\n+    if (other.type != nullptr)\n+      type = other.type->clone_type ();\n+  }\n \n   // Overloaded assignment operator to clone\n   LetStmt &operator= (LetStmt const &other)\n   {\n-    variables_pattern = other.variables_pattern->clone_pattern ();\n-    init_expr = other.init_expr->clone_expr ();\n-    type = other.type->clone_type ();\n     outer_attrs = other.outer_attrs;\n     locus = other.locus;\n \n+    // guard to prevent null dereference (only required if error state)\n+    if (other.variables_pattern != nullptr)\n+      variables_pattern = other.variables_pattern->clone_pattern ();\n+    else\n+      variables_pattern = nullptr;\n+\n+    // guard to prevent null dereference (always required)\n+    if (other.init_expr != nullptr)\n+      init_expr = other.init_expr->clone_expr ();\n+    else\n+      init_expr = nullptr;\n+    if (other.type != nullptr)\n+      type = other.type->clone_type ();\n+    else\n+      type = nullptr;\n+\n     return *this;\n   }\n \n@@ -94,6 +121,36 @@ class LetStmt : public Stmt\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Invalid if pattern is null, so base stripping on that.\n+  void mark_for_strip () override { variables_pattern = nullptr; }\n+  bool is_marked_for_strip () const override\n+  {\n+    return variables_pattern == nullptr;\n+  }\n+\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_init_expr ()\n+  {\n+    rust_assert (has_init_expr ());\n+    return init_expr;\n+  }\n+\n+  std::unique_ptr<Pattern> &get_pattern ()\n+  {\n+    rust_assert (variables_pattern != nullptr);\n+    return variables_pattern;\n+  }\n+\n+  std::unique_ptr<Type> &get_type ()\n+  {\n+    rust_assert (has_type ());\n+    return type;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -119,14 +176,14 @@ class ExprStmt : public Stmt\n  * difficulties, can only be guaranteed to hold an expression). */\n class ExprStmtWithoutBlock : public ExprStmt\n {\n-public:\n   // TODO: ensure that this works\n   std::unique_ptr<ExprWithoutBlock> expr;\n   /* HACK: cannot ensure type safety of ExprWithoutBlock due to Pratt parsing,\n    * so have to store more general type of Expr. FIXME: fix this issue somehow\n    * or redesign AST. */\n   // std::unique_ptr<Expr> expr;\n \n+public:\n   std::string as_string () const override;\n \n   ExprStmtWithoutBlock (std::unique_ptr<ExprWithoutBlock> expr, Location locus)\n@@ -137,9 +194,12 @@ class ExprStmtWithoutBlock : public ExprStmt\n   {}*/\n \n   // Copy constructor with clone\n-  ExprStmtWithoutBlock (ExprStmtWithoutBlock const &other)\n-    : ExprStmt (other), expr (other.expr->clone_expr_without_block ())\n-  {}\n+  ExprStmtWithoutBlock (ExprStmtWithoutBlock const &other) : ExprStmt (other)\n+  {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.expr != nullptr)\n+      expr = other.expr->clone_expr_without_block ();\n+  }\n   /*ExprStmtWithoutBlock (ExprStmtWithoutBlock const &other)\n     : ExprStmt (other), expr (other.expr->clone_expr ())\n   {}*/\n@@ -148,8 +208,13 @@ class ExprStmtWithoutBlock : public ExprStmt\n   ExprStmtWithoutBlock &operator= (ExprStmtWithoutBlock const &other)\n   {\n     ExprStmt::operator= (other);\n-    expr = other.expr->clone_expr_without_block ();\n-    //expr = other.expr->clone_expr ();\n+    // expr = other.expr->clone_expr ();\n+\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.expr != nullptr)\n+      expr = other.expr->clone_expr_without_block ();\n+    else\n+      expr = nullptr;\n \n     return *this;\n   }\n@@ -160,6 +225,17 @@ class ExprStmtWithoutBlock : public ExprStmt\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Invalid if expr is null, so base stripping on that.\n+  void mark_for_strip () override { expr = nullptr; }\n+  bool is_marked_for_strip () const override { return expr == nullptr; }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<ExprWithoutBlock> &get_expr ()\n+  {\n+    rust_assert (expr != nullptr);\n+    return expr;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -172,9 +248,9 @@ class ExprStmtWithoutBlock : public ExprStmt\n // Statement containing an expression with a block\n class ExprStmtWithBlock : public ExprStmt\n {\n-public:\n   std::unique_ptr<ExprWithBlock> expr;\n \n+public:\n   std::string as_string () const override;\n \n   std::vector<LetStmt *> locals;\n@@ -184,15 +260,23 @@ class ExprStmtWithBlock : public ExprStmt\n   {}\n \n   // Copy constructor with clone\n-  ExprStmtWithBlock (ExprStmtWithBlock const &other)\n-    : ExprStmt (other), expr (other.expr->clone_expr_with_block ())\n-  {}\n+  ExprStmtWithBlock (ExprStmtWithBlock const &other) : ExprStmt (other)\n+  {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.expr != nullptr)\n+      expr = other.expr->clone_expr_with_block ();\n+  }\n \n   // Overloaded assignment operator to clone\n   ExprStmtWithBlock &operator= (ExprStmtWithBlock const &other)\n   {\n     ExprStmt::operator= (other);\n-    expr = other.expr->clone_expr_with_block ();\n+\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.expr != nullptr)\n+      expr = other.expr->clone_expr_with_block ();\n+    else\n+      expr = nullptr;\n \n     return *this;\n   }\n@@ -203,6 +287,17 @@ class ExprStmtWithBlock : public ExprStmt\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Invalid if expr is null, so base stripping on that.\n+  void mark_for_strip () override { expr = nullptr; }\n+  bool is_marked_for_strip () const override { return expr == nullptr; }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<ExprWithBlock> &get_expr ()\n+  {\n+    rust_assert (expr != nullptr);\n+    return expr;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "8c175d340434c6deb8fe92f1f07a0b885497641b", "filename": "gcc/rust/ast/rust-type.h", "status": "modified", "additions": 163, "deletions": 80, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc/gcc%2Frust%2Fast%2Frust-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc/gcc%2Frust%2Fast%2Frust-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-type.h?ref=6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc", "patch": "@@ -43,6 +43,10 @@ class TraitBound : public TypeParamBound\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: this mutable getter seems kinda dodgy\n+  TypePath &get_type_path () { return type_path; }\n+  const TypePath &get_type_path () const { return type_path; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -106,8 +110,20 @@ class ImplTraitType : public Type\n   std::string as_string () const override;\n \n   Location get_locus () const { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n+\n+  // TODO: mutable getter seems kinda dodgy\n+  std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds ()\n+  {\n+    return type_param_bounds;\n+  }\n+  const std::vector<std::unique_ptr<TypeParamBound> > &\n+  get_type_param_bounds () const\n+  {\n+    return type_param_bounds;\n+  }\n };\n \n // An opaque value of another type that implements a set of traits\n@@ -164,8 +180,20 @@ class TraitObjectType : public Type\n   std::string as_string () const override;\n \n   Location get_locus () const { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n+\n+  // TODO: mutable getter seems kinda dodgy\n+  std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds ()\n+  {\n+    return type_param_bounds;\n+  }\n+  const std::vector<std::unique_ptr<TypeParamBound> > &\n+  get_type_param_bounds () const\n+  {\n+    return type_param_bounds;\n+  }\n };\n \n // A type with parentheses around it, used to avoid ambiguity.\n@@ -175,13 +203,6 @@ class ParenthesisedType : public TypeNoBounds\n   Location locus;\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  ParenthesisedType *clone_type_impl () const override\n-  {\n-    return new ParenthesisedType (*this);\n-  }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   ParenthesisedType *clone_type_no_bounds_impl () const override\n@@ -219,7 +240,7 @@ class ParenthesisedType : public TypeNoBounds\n   }\n \n   // Creates a trait bound (clone of this one's trait bound) - HACK\n-  TraitBound *to_trait_bound (bool in_parens ATTRIBUTE_UNUSED) const override\n+  TraitBound *to_trait_bound (bool) const override\n   {\n     /* NOTE: obviously it is unknown whether the internal type is a trait bound\n      * due to polymorphism, so just let the internal type handle it. As\n@@ -228,25 +249,25 @@ class ParenthesisedType : public TypeNoBounds\n   }\n \n   Location get_locus () const { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n+\n+  // TODO: would a \"vis_type\" be better?\n+  std::unique_ptr<Type> &get_type_in_parens ()\n+  {\n+    rust_assert (type_in_parens != nullptr);\n+    return type_in_parens;\n+  }\n };\n \n // Impl trait with a single bound? Poor reference material here.\n class ImplTraitTypeOneBound : public TypeNoBounds\n {\n   TraitBound trait_bound;\n-\n   Location locus;\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  ImplTraitTypeOneBound *clone_type_impl () const override\n-  {\n-    return new ImplTraitTypeOneBound (*this);\n-  }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   ImplTraitTypeOneBound *clone_type_no_bounds_impl () const override\n@@ -262,8 +283,16 @@ class ImplTraitTypeOneBound : public TypeNoBounds\n   std::string as_string () const override;\n \n   Location get_locus () const { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n+\n+  // TODO: would a \"vis_type\" be better?\n+  TraitBound &get_trait_bound ()\n+  {\n+    // TODO: check to ensure invariants are met?\n+    return trait_bound;\n+  }\n };\n \n /* A trait object with a single trait bound. The \"trait bound\" is really just\n@@ -272,17 +301,9 @@ class TraitObjectTypeOneBound : public TypeNoBounds\n {\n   bool has_dyn;\n   TraitBound trait_bound;\n-\n   Location locus;\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  TraitObjectTypeOneBound *clone_type_impl () const override\n-  {\n-    return new TraitObjectTypeOneBound (*this);\n-  }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   TraitObjectTypeOneBound *clone_type_no_bounds_impl () const override\n@@ -300,16 +321,24 @@ class TraitObjectTypeOneBound : public TypeNoBounds\n   std::string as_string () const override;\n \n   // Creates a trait bound (clone of this one's trait bound) - HACK\n-  TraitBound *to_trait_bound (bool in_parens ATTRIBUTE_UNUSED) const override\n+  TraitBound *to_trait_bound (bool) const override\n   {\n     /* NOTE: this assumes there is no dynamic dispatch specified- if there was,\n      * this cloning would not be required as parsing is unambiguous. */\n-    return new AST::TraitBound (trait_bound);\n+    return new TraitBound (trait_bound);\n   }\n \n   Location get_locus () const { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n+\n+  // TODO: would a \"vis_type\" be better?\n+  TraitBound &get_trait_bound ()\n+  {\n+    // TODO: check to ensure invariants are met?\n+    return trait_bound;\n+  }\n };\n \n class TypePath; // definition moved to \"rust-path.h\"\n@@ -356,14 +385,18 @@ class TupleType : public TypeNoBounds\n   std::string as_string () const override;\n \n   Location get_locus () const { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  TupleType *clone_type_impl () const override { return new TupleType (*this); }\n+  // TODO: mutable getter seems kinda dodgy\n+  std::vector<std::unique_ptr<Type> > &get_elems () { return elems; }\n+  const std::vector<std::unique_ptr<Type> > &get_elems () const\n+  {\n+    return elems;\n+  }\n \n+protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   TupleType *clone_type_no_bounds_impl () const override\n@@ -380,10 +413,6 @@ class NeverType : public TypeNoBounds\n   Location locus;\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  NeverType *clone_type_impl () const override { return new NeverType (*this); }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   NeverType *clone_type_no_bounds_impl () const override\n@@ -397,6 +426,7 @@ class NeverType : public TypeNoBounds\n   std::string as_string () const override { return \"! (never type)\"; }\n \n   Location get_locus () const { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n };\n@@ -449,17 +479,18 @@ class RawPointerType : public TypeNoBounds\n   std::string as_string () const override;\n \n   Location get_locus () const { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  RawPointerType *clone_type_impl () const override\n+  // TODO: would a \"vis_type\" be better?\n+  std::unique_ptr<TypeNoBounds> &get_type_pointed_to ()\n   {\n-    return new RawPointerType (*this);\n+    rust_assert (type != nullptr);\n+    return type;\n   }\n \n+protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   RawPointerType *clone_type_no_bounds_impl () const override\n@@ -516,17 +547,18 @@ class ReferenceType : public TypeNoBounds\n   std::string as_string () const override;\n \n   Location get_locus () const { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  ReferenceType *clone_type_impl () const override\n+  // TODO: would a \"vis_type\" be better?\n+  std::unique_ptr<TypeNoBounds> &get_type_referenced ()\n   {\n-    return new ReferenceType (*this);\n+    rust_assert (type != nullptr);\n+    return type;\n   }\n \n+protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   ReferenceType *clone_type_no_bounds_impl () const override\n@@ -571,20 +603,25 @@ class ArrayType : public TypeNoBounds\n   std::string as_string () const override;\n \n   Location get_locus () const { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-  Type *get_element_type () { return elem_type.get (); }\n-\n-  Expr *get_size_expr () { return size.get (); }\n+  // TODO: would a \"vis_type\" be better?\n+  std::unique_ptr<Type> &get_elem_type ()\n+  {\n+    rust_assert (elem_type != nullptr);\n+    return elem_type;\n+  }\n \n-  Location &get_locus () { return locus; }\n+  // TODO: would a \"vis_expr\" be better?\n+  std::unique_ptr<Expr> &get_size_expr ()\n+  {\n+    rust_assert (size != nullptr);\n+    return size;\n+  }\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  ArrayType *clone_type_impl () const override { return new ArrayType (*this); }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   ArrayType *clone_type_no_bounds_impl () const override\n@@ -627,14 +664,18 @@ class SliceType : public TypeNoBounds\n   std::string as_string () const override;\n \n   Location get_locus () const { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  SliceType *clone_type_impl () const override { return new SliceType (*this); }\n+  // TODO: would a \"vis_type\" be better?\n+  std::unique_ptr<Type> &get_elem_type ()\n+  {\n+    rust_assert (elem_type != nullptr);\n+    return elem_type;\n+  }\n \n+protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   SliceType *clone_type_no_bounds_impl () const override\n@@ -651,13 +692,6 @@ class InferredType : public TypeNoBounds\n \n   // e.g. Vec<_> = whatever\n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  InferredType *clone_type_impl () const override\n-  {\n-    return new InferredType (*this);\n-  }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   InferredType *clone_type_no_bounds_impl () const override\n@@ -671,6 +705,7 @@ class InferredType : public TypeNoBounds\n   std::string as_string () const override;\n \n   Location get_locus () const { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n };\n@@ -689,6 +724,8 @@ struct MaybeNamedParam\n   };\n \n private:\n+  std::vector<Attribute> outer_attrs;\n+\n   std::unique_ptr<Type> param_type;\n \n   ParamKind param_kind;\n@@ -698,27 +735,39 @@ struct MaybeNamedParam\n \n public:\n   MaybeNamedParam (Identifier name, ParamKind param_kind,\n-\t\t   std::unique_ptr<Type> param_type, Location locus)\n-    : param_type (std::move (param_type)), param_kind (param_kind),\n+\t\t   std::unique_ptr<Type> param_type,\n+\t\t   std::vector<Attribute> outer_attrs, Location locus)\n+    : outer_attrs (std::move (outer_attrs)),\n+      param_type (std::move (param_type)), param_kind (param_kind),\n       name (std::move (name)), locus (locus)\n   {}\n \n   // Copy constructor with clone\n   MaybeNamedParam (MaybeNamedParam const &other)\n-    : param_type (other.param_type->clone_type ()),\n-      param_kind (other.param_kind), name (other.name), locus (other.locus)\n-  {}\n+    : outer_attrs (other.outer_attrs), param_kind (other.param_kind),\n+      name (other.name), locus (other.locus)\n+  {\n+    // guard to prevent null dereference\n+    if (other.param_type != nullptr)\n+      param_type = other.param_type->clone_type ();\n+  }\n \n   ~MaybeNamedParam () = default;\n \n   // Overloaded assignment operator with clone\n   MaybeNamedParam &operator= (MaybeNamedParam const &other)\n   {\n+    outer_attrs = other.outer_attrs;\n     name = other.name;\n     param_kind = other.param_kind;\n-    param_type = other.param_type->clone_type ();\n     locus = other.locus;\n \n+    // guard to prevent null dereference\n+    if (other.param_type != nullptr)\n+      param_type = other.param_type->clone_type ();\n+    else\n+      param_type = nullptr;\n+\n     return *this;\n   }\n \n@@ -734,10 +783,21 @@ struct MaybeNamedParam\n   // Creates an error state param.\n   static MaybeNamedParam create_error ()\n   {\n-    return MaybeNamedParam (\"\", UNNAMED, nullptr, Location ());\n+    return MaybeNamedParam (\"\", UNNAMED, nullptr, {}, Location ());\n   }\n \n   Location get_locus () const { return locus; }\n+\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+\n+  // TODO: would a \"vis_type\" be better?\n+  std::unique_ptr<Type> &get_type ()\n+  {\n+    rust_assert (param_type != nullptr);\n+    return param_type;\n+  }\n };\n \n /* A function pointer type - can be created via coercion from function items and\n@@ -751,6 +811,7 @@ class BareFunctionType : public TypeNoBounds\n   FunctionQualifiers function_qualifiers;\n   std::vector<MaybeNamedParam> params;\n   bool is_variadic;\n+  std::vector<Attribute> variadic_attrs;\n \n   // bool has_return_type;\n   // BareFunctionReturnType return_type;\n@@ -768,21 +829,29 @@ class BareFunctionType : public TypeNoBounds\n   BareFunctionType (std::vector<LifetimeParam> lifetime_params,\n \t\t    FunctionQualifiers qualifiers,\n \t\t    std::vector<MaybeNamedParam> named_params, bool is_variadic,\n+\t\t    std::vector<Attribute> variadic_attrs,\n \t\t    std::unique_ptr<TypeNoBounds> type, Location locus)\n     : for_lifetimes (std::move (lifetime_params)),\n       function_qualifiers (std::move (qualifiers)),\n       params (std::move (named_params)), is_variadic (is_variadic),\n+      variadic_attrs (std::move (variadic_attrs)),\n       return_type (std::move (type)), locus (locus)\n-  {}\n+  {\n+    if (!variadic_attrs.empty ())\n+      is_variadic = true;\n+  }\n \n   // Copy constructor with clone\n   BareFunctionType (BareFunctionType const &other)\n     : for_lifetimes (other.for_lifetimes),\n       function_qualifiers (other.function_qualifiers), params (other.params),\n-      is_variadic (other.is_variadic),\n-      return_type (other.return_type->clone_type_no_bounds ()),\n+      is_variadic (other.is_variadic), variadic_attrs (other.variadic_attrs),\n       locus (other.locus)\n-  {}\n+  {\n+    // guard to prevent null dereference\n+    if (other.return_type != nullptr)\n+      return_type = other.return_type->clone_type_no_bounds ();\n+  }\n \n   // Overload assignment operator to deep copy\n   BareFunctionType &operator= (BareFunctionType const &other)\n@@ -791,9 +860,15 @@ class BareFunctionType : public TypeNoBounds\n     function_qualifiers = other.function_qualifiers;\n     params = other.params;\n     is_variadic = other.is_variadic;\n-    return_type = other.return_type->clone_type_no_bounds ();\n+    variadic_attrs = other.variadic_attrs;\n     locus = other.locus;\n \n+    // guard to prevent null dereference\n+    if (other.return_type != nullptr)\n+      return_type = other.return_type->clone_type_no_bounds ();\n+    else\n+      return_type = nullptr;\n+\n     return *this;\n   }\n \n@@ -804,17 +879,25 @@ class BareFunctionType : public TypeNoBounds\n   std::string as_string () const override;\n \n   Location get_locus () const { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  BareFunctionType *clone_type_impl () const override\n+  // TODO: this mutable getter seems kinda dodgy\n+  std::vector<MaybeNamedParam> &get_function_params () { return params; }\n+  const std::vector<MaybeNamedParam> &get_function_params () const\n   {\n-    return new BareFunctionType (*this);\n+    return params;\n+  }\n+\n+  // TODO: would a \"vis_type\" be better?\n+  std::unique_ptr<TypeNoBounds> &get_return_type ()\n+  {\n+    rust_assert (has_return_type ());\n+    return return_type;\n   }\n \n+protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   BareFunctionType *clone_type_no_bounds_impl () const override"}, {"sha": "300240f9b6f817b427fd7c86e1bab833633212ab", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 120, "deletions": 120, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc", "patch": "@@ -88,23 +88,23 @@ bool\n Compilation::compileVarDecl (Bfunction *fndecl, AST::LetStmt *stmt,\n \t\t\t     std::vector<Bvariable *> &vars)\n {\n-  AST::Type *type = stmt->has_type () ? stmt->type.get () : stmt->inferedType;\n+  AST::Type *type = stmt->has_type () ? stmt->get_type ().get () : stmt->inferedType;\n   translatedType = NULL;\n   type->accept_vis (*this);\n   if (translatedType == NULL)\n     {\n-      rust_error_at (stmt->locus, \"failed to compile type for var decl\");\n+      rust_error_at (stmt->get_locus (), \"failed to compile type for var decl\");\n       return false;\n     }\n \n-  stmt->variables_pattern->accept_vis (*this);\n+  stmt->get_pattern ()->accept_vis (*this);\n   for (auto &pattern : patternBuffer)\n     {\n-      auto var = backend->local_variable (fndecl, pattern.variable_ident,\n+      auto var = backend->local_variable (fndecl, pattern.get_ident (),\n \t\t\t\t\t  translatedType, NULL /*decl_var*/,\n-\t\t\t\t\t  false /*address_taken*/, stmt->locus);\n+\t\t\t\t\t  false /*address_taken*/, stmt->get_locus ());\n       vars.push_back (var);\n-      scope.InsertVar (pattern.variable_ident, var);\n+      scope.InsertVar (pattern.get_ident (), var);\n     }\n   patternBuffer.clear ();\n   return true;\n@@ -173,10 +173,10 @@ Compilation::visit (AST::IdentifierExpr &ident_expr)\n   Bvariable *var = NULL;\n   if (!scope.LookupVar (ident_expr.as_string (), &var))\n     {\n-      rust_fatal_error (ident_expr.locus, \"unknown var\");\n+      rust_fatal_error (ident_expr.get_locus (), \"unknown var\");\n       return;\n     }\n-  exprs.push_back (backend->var_expression (var, ident_expr.locus));\n+  exprs.push_back (backend->var_expression (var, ident_expr.get_locus ()));\n }\n \n void\n@@ -199,7 +199,7 @@ Compilation::visit (AST::PathInExpression &path)\n   if (scope.LookupFunction (path.as_string (), &fn))\n     {\n       auto expr\n-\t= backend->function_code_expression (fn, path.get_locus_slow ());\n+\t= backend->function_code_expression (fn, path.get_locus ());\n       exprs.push_back (expr);\n       translatedType = scope.GetFnRetType (fn);\n       return;\n@@ -219,16 +219,16 @@ Compilation::visit (AST::TypePathSegmentFunction &segment)\n void\n Compilation::visit (AST::TypePath &path)\n {\n-  if (path.segments.size () > 1)\n+  if (path.get_segments ().size () > 1)\n     {\n-      rust_error_at (path.locus, \"unable to compile multi segment types yet\");\n+      rust_error_at (path.get_locus (), \"unable to compile multi segment types yet\");\n       return;\n     }\n \n   Btype *type = NULL;\n   if (!scope.LookupType (path.as_string (), &type))\n     {\n-      rust_error_at (path.locus, \"unknown type\");\n+      rust_error_at (path.get_locus (), \"unknown type\");\n       return;\n     }\n   translatedType = type;\n@@ -246,24 +246,24 @@ void\n Compilation::visit (AST::LiteralExpr &expr)\n {\n   Bexpression *compiled;\n-  switch (expr.literal.get_lit_type ())\n+  switch (expr.get_lit_type ())\n     {\n     case AST::Literal::BOOL:\n       compiled = compileBooleanLiteral (expr.as_string ());\n       break;\n \n     case AST::Literal::FLOAT:\n       compiled\n-\t= compileFloatLiteral (expr.as_string (), expr.get_locus_slow ());\n+\t= compileFloatLiteral (expr.as_string (), expr.get_locus ());\n       break;\n \n     case AST::Literal::INT:\n       compiled\n-\t= compileIntegerLiteral (expr.as_string (), expr.get_locus_slow ());\n+\t= compileIntegerLiteral (expr.as_string (), expr.get_locus ());\n       break;\n \n     default:\n-      rust_fatal_error (expr.get_locus_slow (), \"unknown literal\");\n+      rust_fatal_error (expr.get_locus (), \"unknown literal\");\n       return;\n     }\n \n@@ -293,16 +293,16 @@ void\n Compilation::visit (AST::NegationExpr &expr)\n {\n   Bexpression *root = NULL;\n-  VISIT_POP (expr.get_expr ()->get_locus_slow (), expr.get_expr (), root,\n+  VISIT_POP (expr.get_negated_expr ()->get_locus_slow (), expr.get_negated_expr ().get (), root,\n \t     exprs);\n   if (root == NULL)\n     {\n-      rust_error_at (expr.get_expr ()->get_locus_slow (), \"failed to compile\");\n+      rust_error_at (expr.get_negated_expr ()->get_locus_slow (), \"failed to compile\");\n       return;\n     }\n \n   Operator op;\n-  switch (expr.negation_type)\n+  switch (expr.get_negation_type ())\n     {\n     case AST::NegationExpr::NEGATE:\n       op = OPERATOR_MINUS;\n@@ -311,35 +311,35 @@ Compilation::visit (AST::NegationExpr &expr)\n       op = OPERATOR_NOT;\n       break;\n     default:\n-      rust_fatal_error (expr.get_locus_slow (), \"failed to compile operator\");\n+      rust_fatal_error (expr.get_locus (), \"failed to compile operator\");\n       return;\n     }\n \n-  auto unary = backend->unary_expression (op, root, expr.get_locus_slow ());\n+  auto unary = backend->unary_expression (op, root, expr.get_locus ());\n   exprs.push_back (unary);\n }\n \n void\n Compilation::visit (AST::ArithmeticOrLogicalExpr &expr)\n {\n   Bexpression *lhs = NULL;\n-  VISIT_POP (expr.get_lhs ()->get_locus_slow (), expr.get_lhs (), lhs, exprs);\n+  VISIT_POP (expr.get_left_expr ()->get_locus_slow (), expr.get_left_expr ().get (), lhs, exprs);\n   if (lhs == NULL)\n     {\n-      rust_error_at (expr.get_lhs ()->get_locus_slow (), \"failed to compile\");\n+      rust_error_at (expr.get_left_expr ()->get_locus_slow (), \"failed to compile\");\n       return;\n     }\n \n   Bexpression *rhs = NULL;\n-  VISIT_POP (expr.right_expr->get_locus_slow (), expr.right_expr, rhs, exprs);\n+  VISIT_POP (expr.get_right_expr ()->get_locus_slow (), expr.get_right_expr ().get (), rhs, exprs);\n   if (rhs == NULL)\n     {\n-      rust_error_at (expr.right_expr->get_locus_slow (), \"failed to compile\");\n+      rust_error_at (expr.get_right_expr ()->get_locus_slow (), \"failed to compile\");\n       return;\n     }\n \n   Operator op;\n-  switch (expr.expr_type)\n+  switch (expr.get_expr_type ())\n     {\n     case AST::ArithmeticOrLogicalExpr::ADD:\n       op = OPERATOR_PLUS;\n@@ -372,36 +372,36 @@ Compilation::visit (AST::ArithmeticOrLogicalExpr &expr)\n       op = OPERATOR_RSHIFT;\n       break;\n     default:\n-      rust_fatal_error (expr.get_locus_slow (), \"failed to compile operator\");\n+      rust_fatal_error (expr.get_locus (), \"failed to compile operator\");\n       return;\n     }\n \n   auto binExpr\n-    = backend->binary_expression (op, lhs, rhs, expr.get_locus_slow ());\n+    = backend->binary_expression (op, lhs, rhs, expr.get_locus ());\n   exprs.push_back (binExpr);\n }\n \n void\n Compilation::visit (AST::ComparisonExpr &expr)\n {\n   Bexpression *lhs = NULL;\n-  VISIT_POP (expr.get_lhs ()->get_locus_slow (), expr.get_lhs (), lhs, exprs);\n+  VISIT_POP (expr.get_left_expr ()->get_locus_slow (), expr.get_left_expr ().get (), lhs, exprs);\n   if (lhs == NULL)\n     {\n-      rust_error_at (expr.get_lhs ()->get_locus_slow (), \"failed to compile\");\n+      rust_error_at (expr.get_left_expr ()->get_locus_slow (), \"failed to compile\");\n       return;\n     }\n \n   Bexpression *rhs = NULL;\n-  VISIT_POP (expr.right_expr->get_locus_slow (), expr.right_expr, rhs, exprs);\n+  VISIT_POP (expr.get_right_expr ()->get_locus_slow (), expr.get_right_expr ().get (), rhs, exprs);\n   if (rhs == NULL)\n     {\n-      rust_error_at (expr.right_expr->get_locus_slow (), \"failed to compile\");\n+      rust_error_at (expr.get_right_expr ()->get_locus_slow (), \"failed to compile\");\n       return;\n     }\n \n   Operator op;\n-  switch (expr.expr_type)\n+  switch (expr.get_expr_type ())\n     {\n     case AST::ComparisonExpr::EQUAL:\n       op = OPERATOR_EQEQ;\n@@ -422,36 +422,36 @@ Compilation::visit (AST::ComparisonExpr &expr)\n       op = OPERATOR_LE;\n       break;\n     default:\n-      rust_fatal_error (expr.get_locus_slow (), \"failed to compile operator\");\n+      rust_fatal_error (expr.get_locus (), \"failed to compile operator\");\n       return;\n     }\n \n   auto compExpr\n-    = backend->binary_expression (op, lhs, rhs, expr.get_locus_slow ());\n+    = backend->binary_expression (op, lhs, rhs, expr.get_locus ());\n   exprs.push_back (compExpr);\n }\n \n void\n Compilation::visit (AST::LazyBooleanExpr &expr)\n {\n   Bexpression *lhs = NULL;\n-  VISIT_POP (expr.get_lhs ()->get_locus_slow (), expr.get_lhs (), lhs, exprs);\n+  VISIT_POP (expr.get_left_expr ()->get_locus_slow (), expr.get_left_expr ().get (), lhs, exprs);\n   if (lhs == NULL)\n     {\n-      rust_error_at (expr.get_lhs ()->get_locus_slow (), \"failed to compile\");\n+      rust_error_at (expr.get_left_expr ()->get_locus_slow (), \"failed to compile\");\n       return;\n     }\n \n   Bexpression *rhs = NULL;\n-  VISIT_POP (expr.right_expr->get_locus_slow (), expr.right_expr, rhs, exprs);\n+  VISIT_POP (expr.get_right_expr ()->get_locus_slow (), expr.get_right_expr ().get (), rhs, exprs);\n   if (rhs == NULL)\n     {\n-      rust_error_at (expr.right_expr->get_locus_slow (), \"failed to compile\");\n+      rust_error_at (expr.get_right_expr ()->get_locus_slow (), \"failed to compile\");\n       return;\n     }\n \n   Operator op;\n-  switch (expr.expr_type)\n+  switch (expr.get_expr_type ())\n     {\n     case AST::LazyBooleanExpr::LOGICAL_OR:\n       op = OPERATOR_OROR;\n@@ -460,12 +460,12 @@ Compilation::visit (AST::LazyBooleanExpr &expr)\n       op = OPERATOR_ANDAND;\n       break;\n     default:\n-      rust_fatal_error (expr.get_locus_slow (), \"failed to compile operator\");\n+      rust_fatal_error (expr.get_locus (), \"failed to compile operator\");\n       return;\n     }\n \n   auto compExpr\n-    = backend->binary_expression (op, lhs, rhs, expr.get_locus_slow ());\n+    = backend->binary_expression (op, lhs, rhs, expr.get_locus ());\n   exprs.push_back (compExpr);\n }\n \n@@ -477,23 +477,23 @@ void\n Compilation::visit (AST::AssignmentExpr &expr)\n {\n   Bexpression *lhs = NULL;\n-  VISIT_POP (expr.get_lhs ()->get_locus_slow (), expr.get_lhs (), lhs, exprs);\n+  VISIT_POP (expr.get_left_expr ()->get_locus_slow (), expr.get_left_expr ().get (), lhs, exprs);\n   if (lhs == NULL)\n     {\n-      rust_error_at (expr.get_lhs ()->get_locus_slow (), \"failed to compile\");\n+      rust_error_at (expr.get_left_expr ()->get_locus_slow (), \"failed to compile\");\n       return;\n     }\n \n   Bexpression *rhs = NULL;\n-  VISIT_POP (expr.right_expr->get_locus_slow (), expr.right_expr, rhs, exprs);\n+  VISIT_POP (expr.get_right_expr ()->get_locus_slow (), expr.get_right_expr ().get (), rhs, exprs);\n   if (rhs == NULL)\n     {\n-      rust_error_at (expr.right_expr->get_locus_slow (), \"failed to compile\");\n+      rust_error_at (expr.get_right_expr ()->get_locus_slow (), \"failed to compile\");\n       return;\n     }\n \n   auto s = backend->assignment_statement (scope.GetCurrentFndecl (), lhs, rhs,\n-\t\t\t\t\t  expr.get_locus_slow ());\n+\t\t\t\t\t  expr.get_locus ());\n   scope.AddStatement (s);\n }\n \n@@ -550,7 +550,7 @@ Compilation::visit (AST::ArrayExpr &expr)\n   translatedType = nullptr;\n \n   auto before = arrayConsStack.size ();\n-  expr.get_internal_elements ()->accept_vis (*this);\n+  expr.get_array_elems ()->accept_vis (*this);\n   if (arrayConsStack.size () <= before)\n     {\n       rust_error_at (expr.get_locus_slow (),\n@@ -617,10 +617,10 @@ void\n Compilation::visit (AST::StructExprFieldIdentifierValue &field)\n {\n   Bexpression *value = NULL;\n-  VISIT_POP (field.value->get_locus_slow (), field.value.get (), value, exprs);\n+  VISIT_POP (field.get_value ()->get_locus_slow (), field.get_value ().get (), value, exprs);\n   if (value == NULL)\n     {\n-      rust_fatal_error (field.value->get_locus_slow (),\n+      rust_fatal_error (field.get_value ()->get_locus_slow (),\n \t\t\t\"failed to compile value to struct\");\n       return;\n     }\n@@ -631,10 +631,10 @@ void\n Compilation::visit (AST::StructExprFieldIndexValue &field)\n {\n   Bexpression *value = NULL;\n-  VISIT_POP (field.value->get_locus_slow (), field.value.get (), value, exprs);\n+  VISIT_POP (field.get_value ()->get_locus_slow (), field.get_value ().get (), value, exprs);\n   if (value == NULL)\n     {\n-      rust_fatal_error (field.value->get_locus_slow (),\n+      rust_fatal_error (field.get_value ()->get_locus_slow (),\n \t\t\t\"failed to compile value to struct\");\n       return;\n     }\n@@ -647,14 +647,14 @@ Compilation::visit (AST::StructExprStructFields &expr)\n   AST::StructStruct *decl = NULL;\n   if (!scope.LookupStructDecl (expr.get_struct_name ().as_string (), &decl))\n     {\n-      rust_error_at (expr.get_locus_slow (), \"unknown type\");\n+      rust_error_at (expr.get_locus (), \"unknown type\");\n       return;\n     }\n \n   Btype *structType = NULL;\n   if (!scope.LookupType (expr.get_struct_name ().as_string (), &structType))\n     {\n-      rust_fatal_error (expr.get_locus_slow (), \"unknown type\");\n+      rust_fatal_error (expr.get_locus (), \"unknown type\");\n       return;\n     }\n \n@@ -663,13 +663,13 @@ Compilation::visit (AST::StructExprStructFields &expr)\n \n   // FIXME type resolution pass should ensures these are in correct order\n   // and have defaults if required\n-  for (auto &field : expr.fields)\n+  for (auto &field : expr.get_fields ())\n     {\n       Bexpression *value = NULL;\n-      VISIT_POP (expr.get_locus_slow (), field, value, exprs);\n+      VISIT_POP (expr.get_locus (), field, value, exprs);\n       if (value == NULL)\n \t{\n-\t  rust_fatal_error (expr.get_locus_slow (),\n+\t  rust_fatal_error (expr.get_locus (),\n \t\t\t    \"failed to compile value to struct\");\n \t  return;\n \t}\n@@ -679,7 +679,7 @@ Compilation::visit (AST::StructExprStructFields &expr)\n \n   structBuffer.pop_back ();\n   auto cons = backend->constructor_expression (structType, constructor,\n-\t\t\t\t\t       expr.get_locus_slow ());\n+\t\t\t\t\t       expr.get_locus ());\n   exprs.push_back (cons);\n }\n \n@@ -716,15 +716,15 @@ void\n Compilation::visit (AST::CallExpr &expr)\n {\n   Bexpression *fn = NULL;\n-  VISIT_POP (expr.function->get_locus_slow (), expr.function, fn, exprs);\n+  VISIT_POP (expr.get_function_expr ()->get_locus_slow (), expr.get_function_expr (), fn, exprs);\n   if (fn == NULL)\n     {\n-      rust_error_at (expr.function->get_locus_slow (), \"failed to resolve\");\n+      rust_error_at (expr.get_function_expr ()->get_locus_slow (), \"failed to resolve\");\n       return;\n     }\n \n   std::vector<Bexpression *> args;\n-  for (auto &param : expr.params)\n+  for (auto &param : expr.get_params ())\n     {\n       Bexpression *arg = NULL;\n       VISIT_POP (param->get_locus_slow (), param, arg, exprs);\n@@ -739,7 +739,7 @@ Compilation::visit (AST::CallExpr &expr)\n     }\n \n   auto call = backend->call_expression (scope.GetCurrentFndecl (), fn, args,\n-\t\t\t\t\tNULL, expr.locus);\n+\t\t\t\t\tNULL, expr.get_locus ());\n   exprs.push_back (call);\n }\n \n@@ -766,7 +766,7 @@ Compilation::visit (AST::BlockExpr &expr)\n \t\t      start_location, end_location);\n \n   scope.PushBlock (code_block);\n-  for (auto &stmt : expr.statements)\n+  for (auto &stmt : expr.get_statements ())\n     {\n       stmt->accept_vis (*this);\n     }\n@@ -805,10 +805,10 @@ void\n Compilation::visit (AST::ReturnExpr &expr)\n {\n   Bexpression *ret = NULL;\n-  VISIT_POP (expr.get_expr ()->get_locus_slow (), expr.get_expr (), ret, exprs);\n+  VISIT_POP (expr.get_returned_expr ()->get_locus_slow (), expr.get_returned_expr ().get (), ret, exprs);\n   if (ret == NULL)\n     {\n-      rust_fatal_error (expr.get_expr ()->get_locus_slow (),\n+      rust_fatal_error (expr.get_returned_expr ()->get_locus_slow (),\n \t\t\t\"failed to compile\");\n       return;\n     }\n@@ -843,11 +843,11 @@ void\n Compilation::visit (AST::IfExpr &expr)\n {\n   Bexpression *cond = NULL;\n-  VISIT_POP (expr.get_if_condition ()->get_locus_slow (),\n-\t     expr.get_if_condition (), cond, exprs);\n+  VISIT_POP (expr.get_condition_expr ()->get_locus_slow (),\n+\t     expr.get_condition_expr ().get (), cond, exprs);\n   if (cond == NULL)\n     {\n-      rust_error_at (expr.get_if_condition ()->get_locus_slow (),\n+      rust_error_at (expr.get_condition_expr ()->get_locus_slow (),\n \t\t     \"failed to compile\");\n       return;\n     }\n@@ -856,19 +856,19 @@ Compilation::visit (AST::IfExpr &expr)\n   Bblock *then_block = scope.PopBlock ();\n \n   auto stmt = backend->if_statement (scope.GetCurrentFndecl (), cond,\n-\t\t\t\t     then_block, NULL, expr.get_locus_slow ());\n+\t\t\t\t     then_block, NULL, expr.get_locus ());\n   stmts.push_back (stmt);\n }\n \n void\n Compilation::visit (AST::IfExprConseqElse &expr)\n {\n   Bexpression *cond = NULL;\n-  VISIT_POP (expr.get_if_condition ()->get_locus_slow (),\n-\t     expr.get_if_condition (), cond, exprs);\n+  VISIT_POP (expr.get_condition_expr ()->get_locus_slow (),\n+\t     expr.get_condition_expr ().get (), cond, exprs);\n   if (cond == NULL)\n     {\n-      rust_error_at (expr.get_if_condition ()->get_locus_slow (),\n+      rust_error_at (expr.get_condition_expr ()->get_locus_slow (),\n \t\t     \"failed to compile\");\n       return;\n     }\n@@ -881,19 +881,19 @@ Compilation::visit (AST::IfExprConseqElse &expr)\n \n   auto stmt\n     = backend->if_statement (scope.GetCurrentFndecl (), cond, then_block,\n-\t\t\t     else_block, expr.get_locus_slow ());\n+\t\t\t     else_block, expr.get_locus ());\n   stmts.push_back (stmt);\n }\n \n void\n Compilation::visit (AST::IfExprConseqIf &expr)\n {\n   Bexpression *cond = NULL;\n-  VISIT_POP (expr.get_if_condition ()->get_locus_slow (),\n-\t     expr.get_if_condition (), cond, exprs);\n+  VISIT_POP (expr.get_condition_expr ()->get_locus_slow (),\n+\t     expr.get_condition_expr ().get (), cond, exprs);\n   if (cond == NULL)\n     {\n-      rust_error_at (expr.get_if_condition ()->get_locus_slow (),\n+      rust_error_at (expr.get_condition_expr ()->get_locus_slow (),\n \t\t     \"failed to compile\");\n       return;\n     }\n@@ -921,7 +921,7 @@ Compilation::visit (AST::IfExprConseqIf &expr)\n \n   auto stmt\n     = backend->if_statement (scope.GetCurrentFndecl (), cond, then_block,\n-\t\t\t     else_block, expr.get_locus_slow ());\n+\t\t\t     else_block, expr.get_locus ());\n   stmts.push_back (stmt);\n }\n \n@@ -1014,22 +1014,22 @@ Compilation::visit (AST::Function &function)\n   std::vector<Backend::Btyped_identifier> parameters;\n   std::vector<Backend::Btyped_identifier> results;\n \n-  for (auto &param : function.function_params)\n+  for (auto &param : function.get_function_params ())\n     {\n       // translate the type\n       translatedType = NULL;\n-      param.type->accept_vis (*this);\n+      param.get_type ()->accept_vis (*this);\n       if (translatedType == NULL)\n \t{\n-\t  rust_error_at (param.locus, \"failed to generate type for parameter\");\n+\t  rust_error_at (param.get_locus (), \"failed to generate type for parameter\");\n \t  return;\n \t}\n \n       auto before = patternBuffer.size ();\n-      param.param_name->accept_vis (*this);\n+      param.get_pattern ()->accept_vis (*this);\n       if (patternBuffer.size () <= before)\n \t{\n-\t  rust_error_at (param.locus, \"failed to analyse parameter name\");\n+\t  rust_error_at (param.get_locus (), \"failed to analyse parameter name\");\n \t  return;\n \t}\n \n@@ -1039,19 +1039,19 @@ Compilation::visit (AST::Function &function)\n \t  auto paramName = patternBuffer.back ();\n \t  patternBuffer.pop_back ();\n \t  parameters.push_back (\n-\t    Backend::Btyped_identifier (paramName.variable_ident,\n-\t\t\t\t\ttranslatedType, param.locus));\n+\t    Backend::Btyped_identifier (paramName.get_ident (),\n+\t\t\t\t\ttranslatedType, param.get_locus ()));\n \t}\n     }\n \n   Btype *returnType = NULL;\n-  if (function.has_function_return_type ())\n+  if (function.has_return_type ())\n     {\n       translatedType = NULL;\n-      function.return_type->accept_vis (*this);\n+      function.get_return_type ()->accept_vis (*this);\n       if (translatedType == NULL)\n \t{\n-\t  rust_fatal_error (function.locus,\n+\t  rust_fatal_error (function.get_locus (),\n \t\t\t    \"failed to generate type for function\");\n \t  return;\n \t}\n@@ -1063,12 +1063,12 @@ Compilation::visit (AST::Function &function)\n     }\n \n   Btype *fntype = backend->function_type (receiver, parameters, results, NULL,\n-\t\t\t\t\t  function.locus);\n+\t\t\t\t\t  function.get_locus ());\n   Bfunction *fndecl\n-    = backend->function (fntype, function.function_name, \"\" /* asm_name */,\n-\t\t\t 0 /* flags */, function.locus);\n+    = backend->function (fntype, function.get_function_name (), \"\" /* asm_name */,\n+\t\t\t 0 /* flags */, function.get_locus ());\n \n-  scope.InsertFunction (function.function_name, fndecl, returnType);\n+  scope.InsertFunction (function.get_function_name (), fndecl, returnType);\n   scope.Push ();\n \n   // setup the params\n@@ -1085,7 +1085,7 @@ Compilation::visit (AST::Function &function)\n \n   if (!backend->function_set_parameters (fndecl, param_vars))\n     {\n-      rust_error_at (function.locus, \"failed to setup parameter variables\");\n+      rust_error_at (function.get_locus (), \"failed to setup parameter variables\");\n       return;\n     }\n \n@@ -1094,20 +1094,20 @@ Compilation::visit (AST::Function &function)\n     {\n       if (!compileVarDecl (fndecl, decl, vars))\n \t{\n-\t  rust_error_at (decl->locus, \"failed to compile var decl\");\n+\t  rust_error_at (decl->get_locus (), \"failed to compile var decl\");\n \t  return;\n \t}\n     }\n \n   // is null for top level functions - nested functions will have an enclosing\n   // scope\n   Bblock *enclosingScope = NULL;\n-  Location start_location = function.locus;\n+  Location start_location = function.get_locus ();\n   Location end_location;\n-  if (function.function_body->statements.size () > 0)\n+  if (function.get_definition ()->get_statements ().size () > 0)\n     {\n       end_location\n-\t= function.function_body->statements.back ()->get_locus_slow ();\n+\t= function.get_definition ()->get_statements ().back ()->get_locus_slow ();\n     }\n \n   auto code_block = backend->block (fndecl, enclosingScope, vars,\n@@ -1116,27 +1116,27 @@ Compilation::visit (AST::Function &function)\n   scope.PushBlock (code_block);\n \n   Bvariable *retDecl = NULL;\n-  if (function.has_function_return_type ())\n+  if (function.has_return_type ())\n     {\n       bool address_is_taken = false;\n       Bstatement *ret_var_stmt = NULL;\n       retDecl = backend->temporary_variable (fndecl, code_block, returnType,\n \t\t\t\t\t     NULL, address_is_taken,\n-\t\t\t\t\t     function.locus, &ret_var_stmt);\n+\t\t\t\t\t     function.get_locus (), &ret_var_stmt);\n       scope.AddStatement (ret_var_stmt);\n     }\n-  scope.PushCurrentFunction (function.function_name, fndecl, returnType,\n+  scope.PushCurrentFunction (function.get_function_name (), fndecl, returnType,\n \t\t\t     retDecl);\n \n-  for (auto &stmt : function.function_body->statements)\n+  for (auto &stmt : function.get_definition ()->get_statements ())\n     stmt->accept_vis (*this);\n \n   scope.PopBlock ();\n \n   auto body = backend->block_statement (code_block);\n   if (!backend->function_set_body (fndecl, body))\n     {\n-      rust_error_at (function.locus, \"failed to set body to function\");\n+      rust_error_at (function.get_locus (), \"failed to set body to function\");\n       return;\n     }\n \n@@ -1154,36 +1154,36 @@ void\n Compilation::visit (AST::StructStruct &struct_item)\n {\n   std::vector<Backend::Btyped_identifier> fields;\n-  for (auto &field : struct_item.fields)\n+  for (auto &field : struct_item.get_fields ())\n     {\n       translatedType = NULL;\n-      field.field_type->accept_vis (*this);\n+      field.get_field_type ()->accept_vis (*this);\n       if (translatedType == NULL)\n \t{\n \t  rust_fatal_error (\n-\t    struct_item.locus /* StructField is mi sing locus */,\n+\t    struct_item.get_locus () /* StructField is mi sing locus */,\n \t    \"failed to compile struct field\");\n \t  return;\n \t}\n \n       fields.push_back (Backend::Btyped_identifier (\n-\tfield.field_name, translatedType,\n-\tstruct_item.locus /* StructField is mi sing locus */));\n+\tfield.get_field_name (), translatedType,\n+\tstruct_item.get_locus () /* StructField is mi sing locus */));\n     }\n \n   auto compiledStruct\n-    = backend->placeholder_struct_type (struct_item.struct_name,\n-\t\t\t\t\tstruct_item.locus);\n+    = backend->placeholder_struct_type (struct_item.get_struct_name (),\n+\t\t\t\t\tstruct_item.get_locus ());\n   bool ok = backend->set_placeholder_struct_type (compiledStruct, fields);\n   if (!ok)\n     {\n-      rust_fatal_error (struct_item.locus, \"failed to compile struct\");\n+      rust_fatal_error (struct_item.get_locus (), \"failed to compile struct\");\n       return;\n     }\n \n   type_decls.push_back (compiledStruct);\n-  scope.InsertType (struct_item.struct_name, compiledStruct);\n-  scope.InsertStructDecl (struct_item.struct_name, &struct_item);\n+  scope.InsertType (struct_item.get_struct_name (), compiledStruct);\n+  scope.InsertStructDecl (struct_item.get_struct_name (), &struct_item);\n }\n \n void\n@@ -1363,25 +1363,25 @@ Compilation::visit (AST::LetStmt &stmt)\n   if (!stmt.has_init_expr ())\n     return;\n \n-  stmt.variables_pattern->accept_vis (*this);\n+  stmt.get_pattern ()->accept_vis (*this);\n   for (auto &pattern : patternBuffer)\n     {\n       Bvariable *var = NULL;\n-      if (!scope.LookupVar (pattern.variable_ident, &var))\n+      if (!scope.LookupVar (pattern.get_ident (), &var))\n \t{\n-\t  rust_error_at (stmt.locus, \"failed to find var decl for %s\",\n-\t\t\t pattern.variable_ident.c_str ());\n+\t  rust_error_at (stmt.get_locus (), \"failed to find var decl for %s\",\n+\t\t\t pattern.get_ident ().c_str ());\n \t  return;\n \t}\n \n       varBuffer.push_back (var);\n \n       Bexpression *init = NULL;\n-      VISIT_POP (stmt.init_expr->get_locus_slow (), stmt.init_expr, init,\n+      VISIT_POP (stmt.get_init_expr ()->get_locus_slow (), stmt.get_init_expr (), init,\n \t\t exprs);\n       if (init == NULL)\n \t{\n-\t  rust_error_at (stmt.init_expr->get_locus_slow (),\n+\t  rust_error_at (stmt.get_init_expr ()->get_locus_slow (),\n \t\t\t \"failed to compile init statement\");\n \t  return;\n \t}\n@@ -1397,7 +1397,7 @@ Compilation::visit (AST::LetStmt &stmt)\n void\n Compilation::visit (AST::ExprStmtWithoutBlock &stmt)\n {\n-  stmt.expr->accept_vis (*this);\n+  stmt.get_expr ()->accept_vis (*this);\n }\n \n void\n@@ -1413,7 +1413,7 @@ Compilation::visit (AST::ExprStmtWithBlock &stmt)\n \t\t      start_location, end_location);\n \n   scope.PushBlock (code_block);\n-  stmt.expr->accept_vis (*this);\n+  stmt.get_expr ()->accept_vis (*this);\n \n   // get trailing if required\n   for (auto &s : stmts)\n@@ -1465,7 +1465,7 @@ Compilation::visit (AST::ArrayType &type)\n {\n   Btype *elementType;\n   translatedType = nullptr;\n-  type.get_element_type ()->accept_vis (*this);\n+  type.get_elem_type ()->accept_vis (*this);\n   if (translatedType == nullptr)\n     {\n       rust_error_at (type.get_locus (),"}, {"sha": "79e74ace40c9be0600cc15792f13c86be6f40211", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 3395, "deletions": 54, "changes": 3449, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc"}, {"sha": "a0c1a07656b9580790f22c0c4ff1f9c1151b6253", "filename": "gcc/rust/expand/rust-macro-expand.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.h?ref=6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc", "patch": "@@ -15,7 +15,7 @@ class MacroInvocation;\n struct ExpansionCfg\n {\n   // features?\n-  unsigned int recursion_limit; // TODO: determine default recursion limit\n+  unsigned int recursion_limit = 50; // TODO: determine default recursion limit\n \t\t\t\t// trace macros?\n \t\t\t\t// should test?\n \t\t\t\t// more default stuff?\n@@ -27,7 +27,8 @@ struct MacroExpander\n   ExpansionCfg cfg;\n   unsigned int expansion_depth = 0;\n \n-  MacroExpander (AST::Crate &crate, ExpansionCfg cfg) : cfg (cfg), crate (crate)\n+  MacroExpander (AST::Crate &crate, ExpansionCfg cfg, Session &session)\n+    : cfg (cfg), crate (crate), session (session)\n   {}\n \n   ~MacroExpander () = default;\n@@ -40,11 +41,15 @@ struct MacroExpander\n   // should this be public or private?\n   void expand_invoc (std::unique_ptr<AST::MacroInvocation> &invoc);\n \n+  void expand_cfg_attrs (std::vector<AST::Attribute> &attrs);\n+  bool fails_cfg (std::vector<AST::Attribute> &attr);\n+\n   /* TODO: make it extend ASTVisitor so that individual items can be accessed\n    * properly? */\n \n private:\n   AST::Crate &crate;\n+  Session &session;\n };\n } // namespace Rust\n "}, {"sha": "187f8215d4c4b14b023f4bcec23009062172fbbf", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 312, "deletions": 216, "changes": 528, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc", "patch": "@@ -464,6 +464,7 @@ Parser<ManagedTokenSource>::parse_inner_attributes ()\n \t}\n     }\n \n+  inner_attributes.shrink_to_fit ();\n   return inner_attributes;\n }\n \n@@ -522,14 +523,39 @@ Parser<ManagedTokenSource>::parse_attribute_body ()\n   return AST::Attribute (std::move (attr_path), std::move (attr_input), locus);\n }\n \n-// Parses a SimplePath AST node\n+/* Determines whether token is a valid simple path segment. This does not\n+ * include scope resolution operators. */\n+inline bool\n+is_simple_path_segment (TokenId id)\n+{\n+  switch (id)\n+    {\n+    case IDENTIFIER:\n+    case SUPER:\n+    case SELF:\n+    case CRATE:\n+      return true;\n+    case DOLLAR_SIGN:\n+      // assume that dollar sign leads to $crate\n+      return true;\n+    default:\n+      return false;\n+    }\n+}\n+\n+// Parses a SimplePath AST node, if it exists. Does nothing otherwise.\n template <typename ManagedTokenSource>\n AST::SimplePath\n Parser<ManagedTokenSource>::parse_simple_path ()\n {\n   bool has_opening_scope_resolution = false;\n   Location locus = Linemap::unknown_location ();\n \n+  // don't parse anything if not a path upfront\n+  if (!is_simple_path_segment (lexer.peek_token ()->get_id ())\n+      && !is_simple_path_segment (lexer.peek_token (1)->get_id ()))\n+    return AST::SimplePath::create_empty ();\n+\n   /* Checks for opening scope resolution (i.e. global scope fully-qualified\n    * path) */\n   if (lexer.peek_token ()->get_id () == SCOPE_RESOLUTION)\n@@ -585,6 +611,8 @@ Parser<ManagedTokenSource>::parse_simple_path ()\n \n   return AST::SimplePath (std::move (segments), has_opening_scope_resolution,\n \t\t\t  locus);\n+  /* TODO: now that is_simple_path_segment exists, could probably start\n+   * actually making errors upon parse failure of segments and whatever */\n }\n \n /* Parses a single SimplePathSegment (does not handle the scope resolution\n@@ -603,22 +631,21 @@ Parser<ManagedTokenSource>::parse_simple_path_segment ()\n     case SUPER:\n       lexer.skip_token ();\n \n-      return AST::SimplePathSegment (std::string (\"super\"), t->get_locus ());\n+      return AST::SimplePathSegment (\"super\", t->get_locus ());\n     case SELF:\n       lexer.skip_token ();\n \n-      return AST::SimplePathSegment (std::string (\"self\"), t->get_locus ());\n+      return AST::SimplePathSegment (\"self\", t->get_locus ());\n     case CRATE:\n       lexer.skip_token ();\n \n-      return AST::SimplePathSegment (std::string (\"crate\"), t->get_locus ());\n+      return AST::SimplePathSegment (\"crate\", t->get_locus ());\n     case DOLLAR_SIGN:\n       if (lexer.peek_token (1)->get_id () == CRATE)\n \t{\n \t  lexer.skip_token (1);\n \n-\t  return AST::SimplePathSegment (std::string (\"$crate\"),\n-\t\t\t\t\t t->get_locus ());\n+\t  return AST::SimplePathSegment (\"$crate\", t->get_locus ());\n \t}\n       gcc_fallthrough ();\n     default:\n@@ -652,25 +679,25 @@ Parser<ManagedTokenSource>::parse_path_ident_segment ()\n     case SUPER:\n       lexer.skip_token ();\n \n-      return AST::PathIdentSegment (std::string (\"super\"));\n+      return AST::PathIdentSegment (\"super\");\n     case SELF:\n       lexer.skip_token ();\n \n-      return AST::PathIdentSegment (std::string (\"self\"));\n+      return AST::PathIdentSegment (\"self\");\n     case SELF_ALIAS:\n       lexer.skip_token ();\n \n-      return AST::PathIdentSegment (std::string (\"Self\"));\n+      return AST::PathIdentSegment (\"Self\");\n     case CRATE:\n       lexer.skip_token ();\n \n-      return AST::PathIdentSegment (std::string (\"crate\"));\n+      return AST::PathIdentSegment (\"crate\");\n     case DOLLAR_SIGN:\n       if (lexer.peek_token (1)->get_id () == CRATE)\n \t{\n \t  lexer.skip_token (1);\n \n-\t  return AST::PathIdentSegment (std::string (\"$crate\"));\n+\t  return AST::PathIdentSegment (\"$crate\");\n \t}\n       gcc_fallthrough ();\n     default:\n@@ -962,6 +989,7 @@ Parser<ManagedTokenSource>::parse_items ()\n \t}\n     }\n \n+  items.shrink_to_fit ();\n   return items;\n }\n \n@@ -1073,6 +1101,7 @@ Parser<ManagedTokenSource>::parse_outer_attributes ()\n \t}\n     }\n \n+  outer_attributes.shrink_to_fit ();\n   return outer_attributes;\n \n   /* TODO: this shares basically all code with parse_inner_attributes except\n@@ -1262,8 +1291,7 @@ Parser<ManagedTokenSource>::parse_macro_item (\n   /* dodgy way of detecting macro due to weird context-dependence thing.\n    * probably can be improved */\n   // TODO: ensure that string compare works properly\n-  if (t->get_id () == IDENTIFIER\n-      && t->get_str () == std::string (\"macro_rules\"))\n+  if (t->get_id () == IDENTIFIER && t->get_str () == \"macro_rules\")\n     {\n       return parse_macro_rules_def (std::move (outer_attrs));\n     }\n@@ -2078,7 +2106,7 @@ Parser<ManagedTokenSource>::parse_extern_crate (\n       lexer.skip_token ();\n       break;\n     case SELF:\n-      crate_name = std::string (\"self\");\n+      crate_name = \"self\";\n       lexer.skip_token ();\n       break;\n     default:\n@@ -2117,7 +2145,7 @@ Parser<ManagedTokenSource>::parse_extern_crate (\n       lexer.skip_token ();\n       break;\n     case UNDERSCORE:\n-      as_name = std::string (\"_\");\n+      as_name = \"_\";\n       lexer.skip_token ();\n       break;\n     default:\n@@ -2213,17 +2241,14 @@ Parser<ManagedTokenSource>::parse_use_tree ()\n     {\n       // has no path, so must be glob or nested tree UseTree type\n \n-      /* due to implementation issues, parsing simple path removes any trailing\n-       * scope resolutions (or any, actually, if the use tree has no path\n-       * given), so we'll just assume that there's one there. */\n-      // Check anyway, but optional.\n+      bool is_global = false;\n+\n+      // check for global scope resolution operator\n       if (lexer.peek_token ()->get_id () == SCOPE_RESOLUTION)\n \t{\n \t  lexer.skip_token ();\n+\t  is_global = true;\n \t}\n-      /* Note that this implementation issue also makes it impossible to\n-       * determine at the moment whether the tree has GLOBAL or NO_PATH path\n-       * type. */\n \n       const_TokenPtr t = lexer.peek_token ();\n       switch (t->get_id ())\n@@ -2232,11 +2257,14 @@ Parser<ManagedTokenSource>::parse_use_tree ()\n \t  // glob UseTree type\n \t  lexer.skip_token ();\n \n-\t  // TODO: find way to determine whether GLOBAL or NO_PATH path type -\n-\t  // placeholder\n-\t  return std::unique_ptr<AST::UseTreeGlob> (\n-\t    new AST::UseTreeGlob (AST::UseTreeGlob::NO_PATH,\n-\t\t\t\t  AST::SimplePath::create_empty (), locus));\n+\t  if (is_global)\n+\t    return std::unique_ptr<AST::UseTreeGlob> (\n+\t      new AST::UseTreeGlob (AST::UseTreeGlob::GLOBAL,\n+\t\t\t\t    AST::SimplePath::create_empty (), locus));\n+\t  else\n+\t    return std::unique_ptr<AST::UseTreeGlob> (\n+\t      new AST::UseTreeGlob (AST::UseTreeGlob::NO_PATH,\n+\t\t\t\t    AST::SimplePath::create_empty (), locus));\n \t  case LEFT_CURLY: {\n \t    // nested tree UseTree type\n \t    lexer.skip_token ();\n@@ -2255,11 +2283,9 @@ Parser<ManagedTokenSource>::parse_use_tree ()\n \t\tuse_trees.push_back (std::move (use_tree));\n \n \t\tif (lexer.peek_token ()->get_id () != COMMA)\n-\t\t  {\n-\t\t    break;\n-\t\t  }\n-\t\tlexer.skip_token ();\n+\t\t  break;\n \n+\t\tlexer.skip_token ();\n \t\tt = lexer.peek_token ();\n \t      }\n \n@@ -2270,24 +2296,30 @@ Parser<ManagedTokenSource>::parse_use_tree ()\n \t\treturn nullptr;\n \t      }\n \n-\t    /* TODO: find way to determine whether GLOBAL or NO_PATH path type -\n-\t     * placeholder */\n-\t    return std::unique_ptr<AST::UseTreeList> (\n-\t      new AST::UseTreeList (AST::UseTreeList::NO_PATH,\n-\t\t\t\t    AST::SimplePath::create_empty (),\n-\t\t\t\t    std::move (use_trees), locus));\n+\t    if (is_global)\n+\t      return std::unique_ptr<AST::UseTreeList> (\n+\t\tnew AST::UseTreeList (AST::UseTreeList::GLOBAL,\n+\t\t\t\t      AST::SimplePath::create_empty (),\n+\t\t\t\t      std::move (use_trees), locus));\n+\t    else\n+\t      return std::unique_ptr<AST::UseTreeList> (\n+\t\tnew AST::UseTreeList (AST::UseTreeList::NO_PATH,\n+\t\t\t\t      AST::SimplePath::create_empty (),\n+\t\t\t\t      std::move (use_trees), locus));\n \t  }\n \tcase AS:\n \t  // this is not allowed\n-\t  rust_error_at (t->get_locus (),\n-\t\t\t \"use declaration with rebind %<as%> requires a valid \"\n-\t\t\t \"simple path - none found\");\n+\t  rust_error_at (\n+\t    t->get_locus (),\n+\t    \"use declaration with rebind %<as%> requires a valid simple path - \"\n+\t    \"none found\");\n \t  skip_after_semicolon ();\n \t  return nullptr;\n \tdefault:\n \t  rust_error_at (t->get_locus (),\n \t\t\t \"unexpected token %qs in use tree with no valid \"\n-\t\t\t \"simple path (i.e. list or glob use tree)\",\n+\t\t\t \"simple path (i.e. list\"\n+\t\t\t \" or glob use tree)\",\n \t\t\t t->get_token_description ());\n \t  skip_after_semicolon ();\n \t  return nullptr;\n@@ -2296,7 +2328,8 @@ Parser<ManagedTokenSource>::parse_use_tree ()\n   else\n     {\n       /* Due to aforementioned implementation issues, the trailing :: token is\n-       * consumed by the path, so it can not be used as a disambiguator. */\n+       * consumed by the path, so it can not be used as a disambiguator.\n+       * NOPE, not true anymore - TODO what are the consequences of this? */\n \n       const_TokenPtr t = lexer.peek_token ();\n       switch (t->get_id ())\n@@ -2327,11 +2360,9 @@ Parser<ManagedTokenSource>::parse_use_tree ()\n \t\tuse_trees.push_back (std::move (use_tree));\n \n \t\tif (lexer.peek_token ()->get_id () != COMMA)\n-\t\t  {\n-\t\t    break;\n-\t\t  }\n-\t\tlexer.skip_token ();\n+\t\t  break;\n \n+\t\tlexer.skip_token ();\n \t\tt = lexer.peek_token ();\n \t      }\n \n@@ -2368,14 +2399,13 @@ Parser<ManagedTokenSource>::parse_use_tree ()\n \n \t\treturn std::unique_ptr<AST::UseTreeRebind> (\n \t\t  new AST::UseTreeRebind (AST::UseTreeRebind::WILDCARD,\n-\t\t\t\t\t  std::move (path), locus,\n-\t\t\t\t\t  std::string (\"_\")));\n+\t\t\t\t\t  std::move (path), locus, \"_\"));\n \t      default:\n-\t\trust_error_at (t->get_locus (),\n-\t\t\t       \"unexpected token %qs in use tree with as \"\n-\t\t\t       \"clause - expected \"\n-\t\t\t       \"identifier or %<_%>\",\n-\t\t\t       t->get_token_description ());\n+\t\trust_error_at (\n+\t\t  t->get_locus (),\n+\t\t  \"unexpected token %qs in use tree with as clause - expected \"\n+\t\t  \"identifier or %<_%>\",\n+\t\t  t->get_token_description ());\n \t\tskip_after_semicolon ();\n \t\treturn nullptr;\n \t      }\n@@ -2442,9 +2472,8 @@ Parser<ManagedTokenSource>::parse_function (\n   // parse function parameters (only if next token isn't right paren)\n   std::vector<AST::FunctionParam> function_params;\n   if (lexer.peek_token ()->get_id () != RIGHT_PAREN)\n-    {\n-      function_params = parse_function_params ();\n-    }\n+    function_params\n+      = parse_function_params ([] (TokenId id) { return id == RIGHT_PAREN; });\n \n   if (!skip_token (RIGHT_PAREN))\n     {\n@@ -2745,6 +2774,7 @@ Parser<ManagedTokenSource>::parse_generic_params ()\n \tstd::make_move_iterator(type_params.end()));\n   }*/\n \n+  generic_params.shrink_to_fit ();\n   return generic_params;\n }\n \n@@ -2902,6 +2932,7 @@ Parser<ManagedTokenSource>::parse_generic_params (EndTokenPred is_end_token)\n \tstd::make_move_iterator(type_params.end()));\n   }*/\n \n+  generic_params.shrink_to_fit ();\n   return generic_params;\n }\n \n@@ -3149,6 +3180,7 @@ Parser<ManagedTokenSource>::parse_type_params ()\n       lexer.skip_token ();\n     }\n \n+  type_params.shrink_to_fit ();\n   return type_params;\n }\n \n@@ -3180,6 +3212,7 @@ Parser<ManagedTokenSource>::parse_type_params (EndTokenPred is_end_token)\n       lexer.skip_token ();\n     }\n \n+  type_params.shrink_to_fit ();\n   return type_params;\n   /* TODO: this shares most code with parse_lifetime_params - good place to use\n    * template (i.e. parse_non_ptr_sequence if doable) */\n@@ -3236,24 +3269,24 @@ Parser<ManagedTokenSource>::parse_type_param ()\n \t\t\tstd::move (outer_attr)));\n }\n \n-// Parses regular (i.e. non-generic) parameters in functions or methods.\n+/* Parses regular (i.e. non-generic) parameters in functions or methods. Also\n+ * has end token handling. */\n template <typename ManagedTokenSource>\n+template <typename EndTokenPred>\n std::vector<AST::FunctionParam>\n-Parser<ManagedTokenSource>::parse_function_params ()\n+Parser<ManagedTokenSource>::parse_function_params (EndTokenPred is_end_token)\n {\n   std::vector<AST::FunctionParam> params;\n \n-  // HACK: return early if RIGHT_PAREN is found\n-  if (lexer.peek_token ()->get_id () == RIGHT_PAREN)\n-    {\n-      return params;\n-    }\n+  if (is_end_token (lexer.peek_token ()->get_id ()))\n+    return params;\n \n   AST::FunctionParam initial_param = parse_function_param ();\n \n   // Return empty parameter list if no parameter there\n   if (initial_param.is_error ())\n     {\n+      // TODO: is this an error?\n       return params;\n     }\n \n@@ -3268,13 +3301,9 @@ Parser<ManagedTokenSource>::parse_function_params ()\n       // skip comma if applies\n       lexer.skip_token ();\n \n-      /* HACK: break if next token is a right (closing) paren - this is not\n-       * strictly true via grammar rule but seems to be true in practice (i.e.\n-       * with trailing comma). */\n-      if (lexer.peek_token ()->get_id () == RIGHT_PAREN)\n-\t{\n-\t  break;\n-\t}\n+      // TODO: strictly speaking, shouldn't there be no trailing comma?\n+      if (is_end_token (lexer.peek_token ()->get_id ()))\n+\tbreak;\n \n       // now, as right paren would break, function param is required\n       AST::FunctionParam param = parse_function_param ();\n@@ -3291,6 +3320,7 @@ Parser<ManagedTokenSource>::parse_function_params ()\n       t = lexer.peek_token ();\n     }\n \n+  params.shrink_to_fit ();\n   return params;\n }\n \n@@ -3300,6 +3330,10 @@ template <typename ManagedTokenSource>\n AST::FunctionParam\n Parser<ManagedTokenSource>::parse_function_param ()\n {\n+  // parse outer attributes if they exist\n+  std::vector<AST::Attribute> outer_attrs = parse_outer_attributes ();\n+\n+  // TODO: should saved location be at start of outer attributes or pattern?\n   Location locus = lexer.peek_token ()->get_locus ();\n   std::unique_ptr<AST::Pattern> param_pattern = parse_pattern ();\n \n@@ -3324,7 +3358,7 @@ Parser<ManagedTokenSource>::parse_function_param ()\n     }\n \n   return AST::FunctionParam (std::move (param_pattern), std::move (param_type),\n-\t\t\t     locus);\n+\t\t\t     std::move (outer_attrs), locus);\n }\n \n /* Parses a function or method return type syntactical construction. Also\n@@ -3334,9 +3368,8 @@ std::unique_ptr<AST::Type>\n Parser<ManagedTokenSource>::parse_function_return_type ()\n {\n   if (lexer.peek_token ()->get_id () != RETURN_TYPE)\n-    {\n-      return nullptr;\n-    }\n+    return nullptr;\n+\n   // skip return type, as it now obviously exists\n   lexer.skip_token ();\n \n@@ -3391,6 +3424,7 @@ Parser<ManagedTokenSource>::parse_where_clause ()\n       t = lexer.peek_token ();\n     }\n \n+  where_clause_items.shrink_to_fit ();\n   return AST::WhereClause (std::move (where_clause_items));\n }\n \n@@ -3542,8 +3576,8 @@ Parser<ManagedTokenSource>::parse_type_param_bounds ()\n   return type_param_bounds;\n }\n \n-// Parses type parameter bounds in where clause or generic arguments, with end\n-// token handling.\n+/* Parses type parameter bounds in where clause or generic arguments, with end\n+ * token handling. */\n template <typename ManagedTokenSource>\n template <typename EndTokenPred>\n std::vector<std::unique_ptr<AST::TypeParamBound> >\n@@ -4092,6 +4126,7 @@ Parser<ManagedTokenSource>::parse_tuple_fields ()\n       t = lexer.peek_token ();\n     }\n \n+  fields.shrink_to_fit ();\n   return fields;\n \n   // TODO: this shares basically all code with function params and struct fields\n@@ -4196,6 +4231,7 @@ Parser<ManagedTokenSource>::parse_enum_items ()\n       items.push_back (std::move (item));\n     }\n \n+  items.shrink_to_fit ();\n   return items;\n \n   /* TODO: use template if doable (parse_non_ptr_sequence) */\n@@ -4237,6 +4273,7 @@ Parser<ManagedTokenSource>::parse_enum_items (EndTokenPred is_end_tok)\n       items.push_back (std::move (item));\n     }\n \n+  items.shrink_to_fit ();\n   return items;\n \n   /* TODO: use template if doable (parse_non_ptr_sequence) */\n@@ -4530,6 +4567,9 @@ Parser<ManagedTokenSource>::parse_trait (\n       return nullptr;\n     }\n \n+  // parse inner attrs (if they exist)\n+  std::vector<AST::Attribute> inner_attrs = parse_inner_attributes ();\n+\n   // parse trait items\n   std::vector<std::unique_ptr<AST::TraitItem> > trait_items;\n \n@@ -4555,11 +4595,12 @@ Parser<ManagedTokenSource>::parse_trait (\n       return nullptr;\n     }\n \n+  trait_items.shrink_to_fit ();\n   return std::unique_ptr<AST::Trait> (\n     new AST::Trait (std::move (ident), is_unsafe, std::move (generic_params),\n \t\t    std::move (type_param_bounds), std::move (where_clause),\n \t\t    std::move (trait_items), std::move (vis),\n-\t\t    std::move (outer_attrs), locus));\n+\t\t    std::move (outer_attrs), std::move (inner_attrs), locus));\n }\n \n // Parses a trait item used inside traits (not trait, the Item).\n@@ -4613,27 +4654,26 @@ Parser<ManagedTokenSource>::parse_trait_item ()\n \t    return nullptr;\n \t  }\n \n-\t// now for function vs method disambiguation - method has opening \"self\"\n-\t// param\n+\t/* now for function vs method disambiguation - method has opening \"self\"\n+\t * param */\n \tAST::SelfParam self_param = parse_self_param ();\n-\t// FIXME: ensure that self param doesn't accidently consume tokens for a\n-\t// function\n+\t/* FIXME: ensure that self param doesn't accidently consume tokens for a\n+\t * function */\n \tbool is_method = false;\n \tif (!self_param.is_error ())\n \t  {\n \t    is_method = true;\n \n-\t    // skip comma so function and method regular params can be parsed in\n-\t    // same way\n+\t    /* skip comma so function and method regular params can be parsed in\n+\t     * same way */\n \t    if (lexer.peek_token ()->get_id () == COMMA)\n-\t      {\n-\t\tlexer.skip_token ();\n-\t      }\n+\t      lexer.skip_token ();\n \t  }\n \n \t// parse trait function params\n \tstd::vector<AST::FunctionParam> function_params\n-\t  = parse_function_params ();\n+\t  = parse_function_params (\n+\t    [] (TokenId id) { return id == RIGHT_PAREN; });\n \n \tif (!skip_token (RIGHT_PAREN))\n \t  {\n@@ -4914,6 +4954,8 @@ Parser<ManagedTokenSource>::parse_impl (AST::Visibility vis,\n       // DEBUG\n       fprintf (stderr, \"successfully parsed inherent impl\\n\");\n \n+      impl_items.shrink_to_fit ();\n+\n       return std::unique_ptr<AST::InherentImpl> (new AST::InherentImpl (\n \tstd::move (impl_items), std::move (generic_params), std::move (type),\n \tstd::move (where_clause), std::move (vis), std::move (inner_attrs),\n@@ -4987,6 +5029,8 @@ Parser<ManagedTokenSource>::parse_impl (AST::Visibility vis,\n       // DEBUG\n       fprintf (stderr, \"successfully parsed trait impl\\n\");\n \n+      impl_items.shrink_to_fit ();\n+\n       return std::unique_ptr<AST::TraitImpl> (\n \tnew AST::TraitImpl (std::move (type_path), is_unsafe, has_exclam,\n \t\t\t    std::move (impl_items), std::move (generic_params),\n@@ -5138,24 +5182,23 @@ Parser<ManagedTokenSource>::parse_inherent_impl_function_or_method (\n \n   // now for function vs method disambiguation - method has opening \"self\" param\n   AST::SelfParam self_param = parse_self_param ();\n-  // FIXME: ensure that self param doesn't accidently consume tokens for a\n-  // function one idea is to lookahead up to 4 tokens to see whether self is one\n-  // of them\n+  /* FIXME: ensure that self param doesn't accidently consume tokens for a\n+   * function one idea is to lookahead up to 4 tokens to see whether self is one\n+   * of them */\n   bool is_method = false;\n   if (!self_param.is_error ())\n     {\n       is_method = true;\n \n-      // skip comma so function and method regular params can be parsed in same\n-      // way\n+      /* skip comma so function and method regular params can be parsed in same\n+       * way */\n       if (lexer.peek_token ()->get_id () == COMMA)\n-\t{\n-\t  lexer.skip_token ();\n-\t}\n+\tlexer.skip_token ();\n     }\n \n   // parse trait function params\n-  std::vector<AST::FunctionParam> function_params = parse_function_params ();\n+  std::vector<AST::FunctionParam> function_params\n+    = parse_function_params ([] (TokenId id) { return id == RIGHT_PAREN; });\n \n   if (!skip_token (RIGHT_PAREN))\n     {\n@@ -5400,7 +5443,8 @@ Parser<ManagedTokenSource>::parse_trait_impl_function_or_method (\n   std::vector<AST::FunctionParam> function_params;\n   if (lexer.peek_token ()->get_id () != RIGHT_PAREN)\n     {\n-      function_params = parse_function_params ();\n+      function_params\n+\t= parse_function_params ([] (TokenId id) { return id == RIGHT_PAREN; });\n \n       if (function_params.empty ())\n \t{\n@@ -5535,6 +5579,8 @@ Parser<ManagedTokenSource>::parse_extern_block (\n       return nullptr;\n     }\n \n+  extern_items.shrink_to_fit ();\n+\n   return std::unique_ptr<AST::ExternBlock> (\n     new AST::ExternBlock (std::move (abi), std::move (extern_items),\n \t\t\t  std::move (vis), std::move (inner_attrs),\n@@ -5632,55 +5678,53 @@ Parser<ManagedTokenSource>::parse_external_item ()\n \t// parse parameters\n \tstd::vector<AST::NamedFunctionParam> function_params;\n \tbool is_variadic = false;\n+\tstd::vector<AST::Attribute> variadic_attrs;\n \n \tconst_TokenPtr t = lexer.peek_token ();\n \twhile (t->get_id () != RIGHT_PAREN)\n \t  {\n-\t    AST::NamedFunctionParam param = parse_named_function_param ();\n+\t    std::vector<AST::Attribute> maybe_variadic_attrs\n+\t      = parse_outer_attributes ();\n+\t    if (lexer.peek_token ()->get_id () == ELLIPSIS)\n+\t      {\n+\t\t// variadic - use attrs for this\n+\t\tlexer.skip_token ();\n+\t\tis_variadic = true;\n+\t\tvariadic_attrs = std::move (maybe_variadic_attrs);\n+\t\tt = lexer.peek_token ();\n+\n+\t\tif (t->get_id () != RIGHT_PAREN)\n+\t\t  {\n+\t\t    rust_error_at (t->get_locus (),\n+\t\t\t\t   \"expected right parentheses after variadic \"\n+\t\t\t\t   \"in named function \"\n+\t\t\t\t   \"parameters, found %qs\",\n+\t\t\t\t   t->get_token_description ());\n+\t\t    skip_after_semicolon ();\n+\t\t    return nullptr;\n+\t\t  }\n \n+\t\tbreak;\n+\t      }\n+\n+\t    AST::NamedFunctionParam param\n+\t      = parse_named_function_param (std::move (maybe_variadic_attrs));\n \t    if (param.is_error ())\n \t      {\n-\t\t// is this an error? probably\n \t\trust_error_at (t->get_locus (),\n \t\t\t       \"could not parse named function parameter in \"\n \t\t\t       \"external function\");\n \t\tskip_after_semicolon ();\n \t\treturn nullptr;\n \t      }\n-\n \t    function_params.push_back (std::move (param));\n \n-\t    t = lexer.peek_token ();\n-\t    if (t->get_id () != COMMA)\n-\t      {\n-\t\tif (t->get_id () != RIGHT_PAREN)\n-\t\t  {\n-\t\t    rust_error_at (t->get_locus (),\n-\t\t\t\t   \"expected comma or right parentheses in \"\n-\t\t\t\t   \"named function parameters, found %qs\",\n-\t\t\t\t   t->get_token_description ());\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    // end of loop\n-\t\t    break;\n-\t\t  }\n-\t      }\n+\t    if (lexer.peek_token ()->get_id () != COMMA)\n+\t      break;\n+\n \t    // skip comma\n \t    lexer.skip_token ();\n-\n \t    t = lexer.peek_token ();\n-\n-\t    // parse variadic ... if it exists\n-\t    if (t->get_id () == ELLIPSIS\n-\t\t&& lexer.peek_token (1)->get_id () == RIGHT_PAREN)\n-\t      {\n-\t\tlexer.skip_token ();\n-\n-\t\tis_variadic = true;\n-\n-\t\tt = lexer.peek_token ();\n-\t      }\n \t  }\n \n \tif (!skip_token (RIGHT_PAREN))\n@@ -5701,11 +5745,14 @@ Parser<ManagedTokenSource>::parse_external_item ()\n \t    return nullptr;\n \t  }\n \n+\tfunction_params.shrink_to_fit ();\n+\n \treturn std::unique_ptr<AST::ExternalFunctionItem> (\n \t  new AST::ExternalFunctionItem (\n \t    std::move (ident), std::move (generic_params),\n \t    std::move (return_type), std::move (where_clause),\n-\t    std::move (function_params), is_variadic, std::move (vis),\n+\t    std::move (function_params), is_variadic,\n+\t    std::move (variadic_attrs), std::move (vis),\n \t    std::move (outer_attrs), locus));\n       }\n     default:\n@@ -5722,10 +5769,11 @@ Parser<ManagedTokenSource>::parse_external_item ()\n  * identifier). */\n template <typename ManagedTokenSource>\n AST::NamedFunctionParam\n-Parser<ManagedTokenSource>::parse_named_function_param ()\n+Parser<ManagedTokenSource>::parse_named_function_param (\n+  std::vector<AST::Attribute> outer_attrs)\n {\n   // parse identifier/_\n-  Identifier name;\n+  std::string name;\n \n   const_TokenPtr t = lexer.peek_token ();\n   switch (t->get_id ())\n@@ -5760,7 +5808,8 @@ Parser<ManagedTokenSource>::parse_named_function_param ()\n       return AST::NamedFunctionParam::create_error ();\n     }\n \n-  return AST::NamedFunctionParam (std::move (name), std::move (param_type));\n+  return AST::NamedFunctionParam (std::move (name), std::move (param_type),\n+\t\t\t\t  std::move (outer_attrs));\n }\n \n // Parses a statement (will further disambiguate any statement).\n@@ -6231,6 +6280,7 @@ Parser<ManagedTokenSource>::parse_type_path_function ()\n   // parse optional return type\n   std::unique_ptr<AST::Type> return_type = parse_function_return_type ();\n \n+  inputs.shrink_to_fit ();\n   return AST::TypePathFunction (std::move (inputs), std::move (return_type));\n }\n \n@@ -6403,6 +6453,8 @@ Parser<ManagedTokenSource>::parse_qualified_path_in_expression (\n       t = lexer.peek_token ();\n     }\n \n+  segments.shrink_to_fit ();\n+\n   // FIXME: outer attr parsing\n   return AST::QualifiedPathInExpression (std::move (qual_path_type),\n \t\t\t\t\t std::move (segments), locus,\n@@ -6678,7 +6730,8 @@ Parser<ManagedTokenSource>::parse_method ()\n     lexer.skip_token ();\n \n   // parse function parameters\n-  std::vector<AST::FunctionParam> function_params = parse_function_params ();\n+  std::vector<AST::FunctionParam> function_params\n+    = parse_function_params ([] (TokenId id) { return id == RIGHT_PAREN; });\n \n   if (!skip_token (RIGHT_PAREN))\n     {\n@@ -7077,6 +7130,8 @@ Parser<ManagedTokenSource>::parse_block_expr (\n \n   // grammar allows for empty block expressions\n \n+  stmts.shrink_to_fit ();\n+\n   return std::unique_ptr<AST::BlockExpr> (\n     new AST::BlockExpr (std::move (stmts), std::move (expr),\n \t\t\tstd::move (inner_attrs), std::move (outer_attrs),\n@@ -7165,6 +7220,7 @@ Parser<ManagedTokenSource>::parse_closure_expr (\n \n \t  t = lexer.peek_token ();\n \t}\n+      params.shrink_to_fit ();\n       break;\n     default:\n       rust_error_at (t->get_locus (),\n@@ -7282,12 +7338,12 @@ Parser<ManagedTokenSource>::parse_literal_expr (\n     // use true and false keywords rather than \"bool literal\" Rust terminology\n     case TRUE_LITERAL:\n       type = AST::Literal::BOOL;\n-      literal_value = std::string (\"true\");\n+      literal_value = \"true\";\n       lexer.skip_token ();\n       break;\n     case FALSE_LITERAL:\n       type = AST::Literal::BOOL;\n-      literal_value = std::string (\"false\");\n+      literal_value = \"false\";\n       lexer.skip_token ();\n       break;\n     default:\n@@ -8419,6 +8475,8 @@ Parser<ManagedTokenSource>::parse_array_expr (\n \t      return nullptr;\n \t    }\n \n+\t  skip_token (RIGHT_SQUARE);\n+\n \t  std::unique_ptr<AST::ArrayElemsCopied> copied_array_elems (\n \t    new AST::ArrayElemsCopied (std::move (initial_expr),\n \t\t\t\t       std::move (copy_amount)));\n@@ -8435,6 +8493,8 @@ Parser<ManagedTokenSource>::parse_array_expr (\n \t  exprs.push_back (std::move (initial_expr));\n \t  exprs.shrink_to_fit ();\n \n+\t  skip_token (RIGHT_SQUARE);\n+\n \t  std::unique_ptr<AST::ArrayElemsValues> array_elems (\n \t    new AST::ArrayElemsValues (std::move (exprs)));\n \t  return std::unique_ptr<AST::ArrayExpr> (\n@@ -8500,6 +8560,8 @@ template <typename ManagedTokenSource>\n AST::ClosureParam\n Parser<ManagedTokenSource>::parse_closure_param ()\n {\n+  std::vector<AST::Attribute> outer_attrs = parse_outer_attributes ();\n+\n   // parse pattern (which is required)\n   std::unique_ptr<AST::Pattern> pattern = parse_pattern ();\n   if (pattern == nullptr)\n@@ -8525,7 +8587,8 @@ Parser<ManagedTokenSource>::parse_closure_param ()\n \t}\n     }\n \n-  return AST::ClosureParam (std::move (pattern), std::move (type));\n+  return AST::ClosureParam (std::move (pattern), std::move (type),\n+\t\t\t    std::move (outer_attrs));\n }\n \n // Parses a grouped or tuple expression (disambiguates).\n@@ -9191,7 +9254,8 @@ Parser<ManagedTokenSource>::parse_for_prefixed_type ()\n // Parses a maybe named param used in bare function types.\n template <typename ManagedTokenSource>\n AST::MaybeNamedParam\n-Parser<ManagedTokenSource>::parse_maybe_named_param ()\n+Parser<ManagedTokenSource>::parse_maybe_named_param (\n+  std::vector<AST::Attribute> outer_attrs)\n {\n   /* Basically guess that param is named if first token is identifier or\n    * underscore and second token is semicolon. This should probably have no\n@@ -9228,7 +9292,7 @@ Parser<ManagedTokenSource>::parse_maybe_named_param ()\n     }\n \n   return AST::MaybeNamedParam (std::move (name), kind, std::move (type),\n-\t\t\t       current->get_locus ());\n+\t\t\t       std::move (outer_attrs), current->get_locus ());\n }\n \n /* Parses a bare function type (with the given for lifetimes for convenience -\n@@ -9244,63 +9308,62 @@ Parser<ManagedTokenSource>::parse_bare_function_type (\n   AST::FunctionQualifiers qualifiers = parse_function_qualifiers ();\n \n   if (!skip_token (FN_TOK))\n-    {\n-      return nullptr;\n-    }\n+    return nullptr;\n \n   if (!skip_token (LEFT_PAREN))\n-    {\n-      return nullptr;\n-    }\n+    return nullptr;\n \n   // parse function params, if they exist\n   std::vector<AST::MaybeNamedParam> params;\n   bool is_variadic = false;\n+  std::vector<AST::Attribute> variadic_attrs;\n+\n   const_TokenPtr t = lexer.peek_token ();\n   while (t->get_id () != RIGHT_PAREN)\n     {\n-      // handle ellipsis (only if next character is right paren)\n-      if (t->get_id () == ELLIPSIS)\n+      std::vector<AST::Attribute> temp_attrs = parse_outer_attributes ();\n+\n+      if (lexer.peek_token ()->get_id () == ELLIPSIS)\n \t{\n-\t  if (lexer.peek_token (1)->get_id () == RIGHT_PAREN)\n-\t    {\n-\t      lexer.skip_token ();\n-\t      is_variadic = true;\n-\t      break;\n-\t    }\n-\t  else\n+\t  lexer.skip_token ();\n+\t  is_variadic = true;\n+\t  variadic_attrs = std::move (temp_attrs);\n+\n+\t  t = lexer.peek_token ();\n+\n+\t  if (t->get_id () != RIGHT_PAREN)\n \t    {\n \t      rust_error_at (t->get_locus (),\n-\t\t\t     \"ellipsis (for variadic) can only go at end of \"\n-\t\t\t     \"bare function type\");\n+\t\t\t     \"expected right parentheses after variadic in \"\n+\t\t\t     \"maybe named function \"\n+\t\t\t     \"parameters, found %qs\",\n+\t\t\t     t->get_token_description ());\n \t      return nullptr;\n \t    }\n+\n+\t  break;\n \t}\n \n-      // parse required param\n-      AST::MaybeNamedParam param = parse_maybe_named_param ();\n+      AST::MaybeNamedParam param\n+\t= parse_maybe_named_param (std::move (temp_attrs));\n       if (param.is_error ())\n \t{\n \t  rust_error_at (\n-\t    t->get_locus (),\n+\t    lexer.peek_token ()->get_locus (),\n \t    \"failed to parse maybe named param in bare function type\");\n \t  return nullptr;\n \t}\n       params.push_back (std::move (param));\n \n       if (lexer.peek_token ()->get_id () != COMMA)\n-\t{\n-\t  break;\n-\t}\n-      lexer.skip_token ();\n+\tbreak;\n \n+      lexer.skip_token ();\n       t = lexer.peek_token ();\n     }\n \n   if (!skip_token (RIGHT_PAREN))\n-    {\n-      return nullptr;\n-    }\n+    return nullptr;\n \n   // bare function return type, if exists\n   std::unique_ptr<AST::TypeNoBounds> return_type = nullptr;\n@@ -9319,9 +9382,11 @@ Parser<ManagedTokenSource>::parse_bare_function_type (\n \t}\n     }\n \n-  return std::unique_ptr<AST::BareFunctionType> (new AST::BareFunctionType (\n-    std::move (for_lifetimes), std::move (qualifiers), std::move (params),\n-    is_variadic, std::move (return_type), best_try_locus));\n+  return std::unique_ptr<AST::BareFunctionType> (\n+    new AST::BareFunctionType (std::move (for_lifetimes),\n+\t\t\t       std::move (qualifiers), std::move (params),\n+\t\t\t       is_variadic, std::move (variadic_attrs),\n+\t\t\t       std::move (return_type), best_try_locus));\n }\n \n // Parses a reference type (mutable or immutable, with given lifetime).\n@@ -10136,6 +10201,14 @@ Parser<ManagedTokenSource>::parse_pattern ()\n \t      // tuple struct\n \t      lexer.skip_token ();\n \n+\t      // check if empty tuple\n+\t      if (lexer.peek_token ()->get_id () == RIGHT_PAREN)\n+\t\t{\n+\t\t  lexer.skip_token ();\n+\t\t  return std::unique_ptr<AST::TupleStructPattern> (\n+\t\t    new AST::TupleStructPattern (std::move (path), nullptr));\n+\t\t}\n+\n \t      // parse items\n \t      std::unique_ptr<AST::TupleStructItems> items\n \t\t= parse_tuple_struct_items ();\n@@ -10560,6 +10633,14 @@ Parser<ManagedTokenSource>::parse_ident_leading_pattern ()\n \t// DEBUG\n \tfprintf (stderr, \"parsing tuple struct pattern\\n\");\n \n+\t// check if empty tuple\n+\tif (lexer.peek_token ()->get_id () == RIGHT_PAREN)\n+\t  {\n+\t    lexer.skip_token ();\n+\t    return std::unique_ptr<AST::TupleStructPattern> (\n+\t      new AST::TupleStructPattern (std::move (path), nullptr));\n+\t  }\n+\n \t// parse items\n \tstd::unique_ptr<AST::TupleStructItems> items\n \t  = parse_tuple_struct_items ();\n@@ -10802,53 +10883,48 @@ Parser<ManagedTokenSource>::parse_struct_pattern_elems ()\n {\n   std::vector<std::unique_ptr<AST::StructPatternField> > fields;\n \n+  std::vector<AST::Attribute> etc_attrs;\n+  bool has_etc = false;\n+\n   // try parsing struct pattern fields\n   const_TokenPtr t = lexer.peek_token ();\n-  while (t->get_id () != RIGHT_CURLY && t->get_id () != DOT_DOT)\n+  while (t->get_id () != RIGHT_CURLY)\n     {\n-      std::unique_ptr<AST::StructPatternField> field\n-\t= parse_struct_pattern_field ();\n-      if (field == nullptr)\n-\t{\n-\t  // TODO: should this be an error?\n-\t  // assuming that this means that it is a struct pattern etc instead\n-\n-\t  // DEBUG\n-\t  fprintf (\n-\t    stderr,\n-\t    \"failed to parse struct pattern field - breaking from loop\\n\");\n+      std::vector<AST::Attribute> outer_attrs = parse_outer_attributes ();\n \n+      // parse etc (must be last in struct pattern, so breaks)\n+      if (lexer.peek_token ()->get_id () == DOT_DOT)\n+\t{\n+\t  lexer.skip_token ();\n+\t  etc_attrs = std::move (outer_attrs);\n+\t  has_etc = true;\n \t  break;\n \t}\n \n-      fields.push_back (std::move (field));\n-\n-      // DEBUG\n-      fprintf (stderr, \"successfully pushed back a struct pattern field\\n\");\n-\n-      if (lexer.peek_token ()->get_id () != COMMA)\n+      std::unique_ptr<AST::StructPatternField> field\n+\t= parse_struct_pattern_field_partial (std::move (outer_attrs));\n+      if (field == nullptr)\n \t{\n-\t  break;\n+\t  rust_error_at (lexer.peek_token ()->get_locus (),\n+\t\t\t \"failed to parse struct pattern field\");\n+\t  // skip after somewhere?\n+\t  return AST::StructPatternElements::create_empty ();\n \t}\n-      lexer.skip_token ();\n+      fields.push_back (std::move (field));\n \n-      t = lexer.peek_token ();\n-    }\n+      if (lexer.peek_token ()->get_id () != COMMA)\n+\tbreak;\n \n-  /* FIXME: this method of parsing prevents parsing any outer attributes on the\n-   * .. - also there seems to be no distinction between having etc and not\n-   * having etc. */\n-  if (lexer.peek_token ()->get_id () == DOT_DOT)\n-    {\n+      // skip comma\n       lexer.skip_token ();\n-\n-      // as no outer attributes\n-      AST::StructPatternEtc etc = AST::StructPatternEtc::create_empty ();\n-\n-      return AST::StructPatternElements (std::move (fields), std::move (etc));\n+      t = lexer.peek_token ();\n     }\n \n-  return AST::StructPatternElements (std::move (fields));\n+  if (has_etc)\n+    return AST::StructPatternElements (std::move (fields),\n+\t\t\t\t       std::move (etc_attrs));\n+  else\n+    return AST::StructPatternElements (std::move (fields));\n }\n \n /* Parses a struct pattern field (tuple index/pattern, identifier/pattern, or\n@@ -10860,6 +10936,16 @@ Parser<ManagedTokenSource>::parse_struct_pattern_field ()\n   // parse outer attributes (if they exist)\n   std::vector<AST::Attribute> outer_attrs = parse_outer_attributes ();\n \n+  return parse_struct_pattern_field_partial (std::move (outer_attrs));\n+}\n+\n+/* Parses a struct pattern field (tuple index/pattern, identifier/pattern, or\n+ * identifier), with outer attributes passed in. */\n+template <typename ManagedTokenSource>\n+std::unique_ptr<AST::StructPatternField>\n+Parser<ManagedTokenSource>::parse_struct_pattern_field_partial (\n+  std::vector<AST::Attribute> outer_attrs)\n+{\n   // branch based on next token\n   const_TokenPtr t = lexer.peek_token ();\n   switch (t->get_id ())\n@@ -11478,7 +11564,8 @@ Parser<ManagedTokenSource>::parse_struct_expr_field ()\n \n \t  return std::unique_ptr<AST::StructExprFieldIdentifierValue> (\n \t    new AST::StructExprFieldIdentifierValue (std::move (ident),\n-\t\t\t\t\t\t     std::move (expr)));\n+\t\t\t\t\t\t     std::move (expr),\n+\t\t\t\t\t\t     t->get_locus ()));\n \t}\n       else\n \t{\n@@ -11487,7 +11574,8 @@ Parser<ManagedTokenSource>::parse_struct_expr_field ()\n \t  lexer.skip_token ();\n \n \t  return std::unique_ptr<AST::StructExprFieldIdentifier> (\n-\t    new AST::StructExprFieldIdentifier (std::move (ident)));\n+\t    new AST::StructExprFieldIdentifier (std::move (ident),\n+\t\t\t\t\t\tt->get_locus ()));\n \t}\n       case INT_LITERAL: {\n \t// parse tuple index field\n@@ -11511,18 +11599,20 @@ Parser<ManagedTokenSource>::parse_struct_expr_field ()\n \t  }\n \n \treturn std::unique_ptr<AST::StructExprFieldIndexValue> (\n-\t  new AST::StructExprFieldIndexValue (index, std::move (expr)));\n+\t  new AST::StructExprFieldIndexValue (index, std::move (expr),\n+\t\t\t\t\t      t->get_locus ()));\n       }\n     case DOT_DOT:\n       /* this is a struct base and can't be parsed here, so just return nothing\n        * without erroring */\n \n       return nullptr;\n     default:\n-      rust_error_at (t->get_locus (),\n-\t\t     \"unrecognised token %qs as first token of struct expr \"\n-\t\t     \"field - expected identifier or int literal\",\n-\t\t     t->get_token_description ());\n+      rust_error_at (\n+\tt->get_locus (),\n+\t\"unrecognised token %qs as first token of struct expr field - \"\n+\t\"expected identifier or int literal\",\n+\tt->get_token_description ());\n       return nullptr;\n     }\n }\n@@ -13650,12 +13740,15 @@ Parser<ManagedTokenSource>::parse_tuple_index_expr (\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::ArrayIndexExpr>\n Parser<ManagedTokenSource>::parse_index_expr (\n-  const_TokenPtr tok ATTRIBUTE_UNUSED, std::unique_ptr<AST::Expr> array_expr,\n-  std::vector<AST::Attribute> outer_attrs, ParseRestrictions restrictions)\n+  const_TokenPtr, std::unique_ptr<AST::Expr> array_expr,\n+  std::vector<AST::Attribute> outer_attrs, ParseRestrictions)\n {\n   // parse RHS (as tok has already been consumed in parse_expression)\n-  std::unique_ptr<AST::Expr> index_expr\n-    = parse_expr (LBP_ARRAY_REF, std::vector<AST::Attribute> (), restrictions);\n+  /*std::unique_ptr<AST::Expr> index_expr\n+    = parse_expr (LBP_ARRAY_REF, std::vector<AST::Attribute> (),\n+    restrictions);*/\n+  // TODO: conceptually, should treat [] as brackets, so just parse all expr\n+  std::unique_ptr<AST::Expr> index_expr = parse_expr ();\n   if (index_expr == nullptr)\n     return nullptr;\n \n@@ -13682,8 +13775,8 @@ Parser<ManagedTokenSource>::parse_field_access_expr (\n   std::vector<AST::Attribute> outer_attrs,\n   ParseRestrictions restrictions ATTRIBUTE_UNUSED)\n {\n-  // get field name identifier (assume that this is a field access expr and not\n-  // say await)\n+  /* get field name identifier (assume that this is a field access expr and not\n+   * await, for instance) */\n   const_TokenPtr ident_tok = expect_token (IDENTIFIER);\n   Identifier ident = ident_tok->get_str ();\n \n@@ -13967,7 +14060,10 @@ Parser<ManagedTokenSource>::parse_struct_expr_struct_partial (\n }\n \n /* Parses a struct expr tuple with a path in expression already parsed (but not\n- * '(' token). */\n+ * '(' token).\n+ * FIXME: this currently outputs a call expr, as they cannot be disambiguated.\n+ * A better solution would be to just get this to call that function directly.\n+ * */\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::CallExpr>\n Parser<ManagedTokenSource>::parse_struct_expr_tuple_partial (\n@@ -14261,7 +14357,7 @@ Parser<ManagedTokenSource>::parse_tuple_index_expr_float (\n {\n   // only works on float literals\n   if (tok->get_id () != FLOAT_LITERAL)\n-      return nullptr;\n+    return nullptr;\n \n   // DEBUG:\n   fprintf (stderr, \"exact string form of float: '%s'\\n\","}, {"sha": "7218ebc4a2aa66e4e288f8b4c856e020cd05aec4", "filename": "gcc/rust/parse/rust-parse.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc/gcc%2Frust%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc/gcc%2Frust%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.h?ref=6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc", "patch": "@@ -164,7 +164,8 @@ template <typename ManagedTokenSource> class Parser\n   template <typename EndTokenPred>\n   std::vector<std::unique_ptr<AST::TypeParam> > parse_type_params (EndTokenPred is_end_token);\n   std::unique_ptr<AST::TypeParam> parse_type_param ();\n-  std::vector<AST::FunctionParam> parse_function_params ();\n+  template <typename EndTokenPred>\n+  std::vector<AST::FunctionParam> parse_function_params (EndTokenPred is_end_token);\n   AST::FunctionParam parse_function_param ();\n   std::unique_ptr<AST::Type> parse_function_return_type ();\n   AST::WhereClause parse_where_clause ();\n@@ -230,7 +231,8 @@ template <typename ManagedTokenSource> class Parser\n   parse_extern_block (AST::Visibility vis,\n \t\t      std::vector<AST::Attribute> outer_attrs);\n   std::unique_ptr<AST::ExternalItem> parse_external_item ();\n-  AST::NamedFunctionParam parse_named_function_param ();\n+  AST::NamedFunctionParam parse_named_function_param (\n+    std::vector<AST::Attribute> outer_attrs = std::vector<AST::Attribute> ());\n   AST::Method parse_method ();\n \n   // Expression-related (Pratt parsed)\n@@ -543,7 +545,7 @@ template <typename ManagedTokenSource> class Parser\n   std::unique_ptr<AST::Type> parse_paren_prefixed_type ();\n   std::unique_ptr<AST::TypeNoBounds> parse_paren_prefixed_type_no_bounds ();\n   std::unique_ptr<AST::Type> parse_for_prefixed_type ();\n-  AST::MaybeNamedParam parse_maybe_named_param ();\n+  AST::MaybeNamedParam parse_maybe_named_param (std::vector<AST::Attribute> outer_attrs);\n \n   // Statement-related\n   std::unique_ptr<AST::Stmt> parse_stmt ();\n@@ -573,6 +575,7 @@ template <typename ManagedTokenSource> class Parser\n   std::unique_ptr<AST::TupleStructItems> parse_tuple_struct_items ();\n   AST::StructPatternElements parse_struct_pattern_elems ();\n   std::unique_ptr<AST::StructPatternField> parse_struct_pattern_field ();\n+  std::unique_ptr<AST::StructPatternField> parse_struct_pattern_field_partial (std::vector<AST::Attribute> outer_attrs);\n \n   int left_binding_power (const_TokenPtr token);\n "}, {"sha": "da5094877ac707cc6dad1aa9de841a6bfdd586ad", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=6e4b74fb77c45a6088e0cca22ec05c28c7f0b6dc", "patch": "@@ -344,8 +344,8 @@ Session::enable_dump (std::string arg)\n   if (arg == \"all\")\n     {\n       rust_error_at (Location (),\n-\t\t     \"dumping all is not supported as of now. choose %<lex%>, \"\n-\t\t     \"%<parse%>, or %<target_options%>\");\n+\t\t     \"dumping all is not supported as of now. choose %<lex%>, %<parse%>, \"\n+         \"or %<target_options%>\");\n       return false;\n     }\n   else if (arg == \"lex\")\n@@ -390,8 +390,8 @@ Session::enable_dump (std::string arg)\n   else\n     {\n       rust_error_at (Location (),\n-\t\t     \"dump option %qs was unrecognised. choose %<lex%>, \"\n-\t\t     \"%<parse%>, or %<target_options%>\",\n+\t\t     \"dump option %qs was unrecognised. choose %<lex%>, %<parse%>, or \"\n+         \"%<target_options%>\",\n \t\t     arg.c_str ());\n       return false;\n     }\n@@ -472,7 +472,6 @@ Session::parse_file (const char *filename)\n   if (options.dump_option == CompileOptions::REGISTER_PLUGINS_DUMP)\n     {\n       // TODO: what do I dump here?\n-      return;\n     }\n \n   // injection pipeline stage\n@@ -482,7 +481,6 @@ Session::parse_file (const char *filename)\n   if (options.dump_option == CompileOptions::INJECTION_DUMP)\n     {\n       // TODO: what do I dump here? injected crate names?\n-      return;\n     }\n \n   // expansion pipeline stage\n@@ -491,8 +489,10 @@ Session::parse_file (const char *filename)\n \n   if (options.dump_option == CompileOptions::EXPANSION_DUMP)\n     {\n-      // TODO: what do I dump here? expanded macros? AST with expanded macros?\n-      return;\n+      // dump AST with expanded stuff\n+      fprintf (stderr, \"BEGIN POST-EXPANSION AST DUMP\\n\");\n+      parser.debug_dump_ast_output (parsed_crate);\n+      fprintf (stderr, \"END POST-EXPANSION AST DUMP\\n\");\n     }\n \n   // resolution pipeline stage\n@@ -502,7 +502,6 @@ Session::parse_file (const char *filename)\n   if (options.dump_option == CompileOptions::RESOLUTION_DUMP)\n     {\n       // TODO: what do I dump here? resolved names? AST with resolved names?\n-      return;\n     }\n \n   if (saw_errors ())\n@@ -630,8 +629,8 @@ Session::injection (AST::Crate &crate)\n    * rustc also has a \"quote\" macro that is defined differently and is\n    * supposedly not stable so eh. */\n   /* TODO: actually implement injection of these macros. In particular, derive\n-   * macros, cfg, and\n-   * test should be prioritised since they seem to be used the most. */\n+   * macros, cfg, and test should be prioritised since they seem to be used the\n+   * most. */\n \n   // crate injection\n   std::vector<std::string> names;\n@@ -719,7 +718,7 @@ Session::expansion (AST::Crate &crate)\n   // create extctxt? from parse session, cfg, and resolver?\n   /* expand by calling cxtctxt object's monotonic_expander's expand_crate\n    * method. */\n-  MacroExpander expander (crate, cfg);\n+  MacroExpander expander (crate, cfg, *this);\n   expander.expand_crate ();\n \n   // error reporting - check unused macros, get missing fragment specifiers"}]}