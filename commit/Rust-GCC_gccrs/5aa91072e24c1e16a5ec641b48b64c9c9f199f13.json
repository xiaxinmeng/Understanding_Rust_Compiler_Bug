{"sha": "5aa91072e24c1e16a5ec641b48b64c9c9f199f13", "node_id": "C_kwDOANBUbNoAKDVhYTkxMDcyZTI0YzFlMTZhNWVjNjQxYjQ4YjY0YzljOWYxOTlmMTM", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-11-13T21:25:23Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-11-13T21:25:23Z"}, "message": "Implement DSE of dead functions calls storing memory.\n\ngcc/ChangeLog:\n\n2021-11-13  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* ipa-modref.c (modref_summary::modref_summary): Clear new flags.\n\t(modref_summary::dump): Dump try_dse.\n\t(modref_summary::finalize): Add FUN attribute; compute try-dse.\n\t(analyze_function): Update.\n\t(read_section): Update.\n\t(update_signature): Update.\n\t(pass_ipa_modref::execute): Update.\n\t* ipa-modref.h (struct modref_summary):\n\t* tree-ssa-alias.c (ao_ref_init_from_ptr_and_range): Export.\n\t* tree-ssa-alias.h (ao_ref_init_from_ptr_and_range): Declare.\n\t* tree-ssa-dse.c (dse_optimize_call): New function.\n\t(dse_optimize_stmt): Use it.\n\ngcc/testsuite/ChangeLog:\n\n2021-11-13  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* g++.dg/cpp1z/inh-ctor23.C: Fix template\n\t* g++.dg/ipa/ipa-icf-4.C: Fix template\n\t* gcc.dg/tree-ssa/modref-dse-1.c: New test.\n\t* gcc.dg/tree-ssa/modref-dse-2.c: New test.", "tree": {"sha": "087583429b1e19e850beb66efc26633cafdf5f82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/087583429b1e19e850beb66efc26633cafdf5f82"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5aa91072e24c1e16a5ec641b48b64c9c9f199f13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5aa91072e24c1e16a5ec641b48b64c9c9f199f13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5aa91072e24c1e16a5ec641b48b64c9c9f199f13", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5aa91072e24c1e16a5ec641b48b64c9c9f199f13/comments", "author": null, "committer": null, "parents": [{"sha": "af47f22fd5784a363ea78c419898b5d703761fb7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af47f22fd5784a363ea78c419898b5d703761fb7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af47f22fd5784a363ea78c419898b5d703761fb7"}], "stats": {"total": 239, "additions": 227, "deletions": 12}, "files": [{"sha": "3b94dc0c91d673195b73b7d8ee49d8f0a89b2976", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 53, "deletions": 7, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aa91072e24c1e16a5ec641b48b64c9c9f199f13/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aa91072e24c1e16a5ec641b48b64c9c9f199f13/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=5aa91072e24c1e16a5ec641b48b64c9c9f199f13", "patch": "@@ -277,7 +277,7 @@ static GTY(()) fast_function_summary <modref_summary_lto *, va_gc>\n modref_summary::modref_summary ()\n   : loads (NULL), stores (NULL), retslot_flags (0), static_chain_flags (0),\n     writes_errno (false), side_effects (false), global_memory_read (false),\n-    global_memory_written (false)\n+    global_memory_written (false), try_dse (false)\n {\n }\n \n@@ -606,6 +606,8 @@ modref_summary::dump (FILE *out)\n     fprintf (out, \"  Global memory read\\n\");\n   if (global_memory_written)\n     fprintf (out, \"  Global memory written\\n\");\n+  if (try_dse)\n+    fprintf (out, \"  Try dse\\n\");\n   if (arg_flags.length ())\n     {\n       for (unsigned int i = 0; i < arg_flags.length (); i++)\n@@ -662,12 +664,56 @@ modref_summary_lto::dump (FILE *out)\n }\n \n /* Called after summary is produced and before it is used by local analysis.\n-   Can be called multiple times in case summary needs to update signature.  */\n+   Can be called multiple times in case summary needs to update signature.\n+   FUN is decl of function summary is attached to.  */\n void\n-modref_summary::finalize ()\n+modref_summary::finalize (tree fun)\n {\n   global_memory_read = !loads || loads->global_access_p ();\n   global_memory_written = !stores || stores->global_access_p ();\n+\n+  /* We can do DSE if we know function has no side effects and\n+     we can analyse all stores.  Disable dse if there are too many\n+     stores to try.  */\n+  if (side_effects || global_memory_written || writes_errno)\n+    try_dse = false;\n+  else\n+    {\n+      try_dse = true;\n+      size_t i, j, k;\n+      int num_tests = 0, max_tests\n+       \t= opt_for_fn (fun, param_modref_max_tests);\n+      modref_base_node <alias_set_type> *base_node;\n+      modref_ref_node <alias_set_type> *ref_node;\n+      modref_access_node *access_node;\n+      FOR_EACH_VEC_SAFE_ELT (stores->bases, i, base_node)\n+\t{\n+\t  if (base_node->every_ref)\n+\t    {\n+\t      try_dse = false;\n+\t      break;\n+\t    }\n+\t  FOR_EACH_VEC_SAFE_ELT (base_node->refs, j, ref_node)\n+\t    {\n+\t      if (base_node->every_ref)\n+\t\t{\n+\t\t  try_dse = false;\n+\t\t  break;\n+\t\t}\n+\t      FOR_EACH_VEC_SAFE_ELT (ref_node->accesses, k, access_node)\n+\t\tif (num_tests++ > max_tests\n+\t\t    || !access_node->parm_offset_known)\n+\t\t  {\n+\t\t    try_dse = false;\n+\t\t    break;\n+\t\t  }\n+\t      if (!try_dse)\n+\t\tbreak;\n+\t    }\n+\t  if (!try_dse)\n+\t    break;\n+\t}\n+    }\n }\n \n /* Get function summary for FUNC if it exists, return NULL otherwise.  */\n@@ -2832,7 +2878,7 @@ analyze_function (function *f, bool ipa)\n       summary = NULL;\n     }\n   if (summary)\n-    summary->finalize ();\n+    summary->finalize (current_function_decl);\n   if (summary_lto && !summary_lto->useful_p (ecf_flags))\n     {\n       summaries_lto->remove (fnode);\n@@ -3553,7 +3599,7 @@ read_section (struct lto_file_decl_data *file_data, const char *data,\n \t    }\n \t}\n       if (flag_ltrans)\n-\tmodref_sum->finalize ();\n+\tmodref_sum->finalize (node->decl);\n       if (dump_file)\n \t{\n \t  fprintf (dump_file, \"Read modref for %s\\n\",\n@@ -3711,7 +3757,7 @@ update_signature (struct cgraph_node *node)\n \tr_lto->dump (dump_file);\n     }\n   if (r)\n-    r->finalize ();\n+    r->finalize (node->decl);\n   return;\n }\n \n@@ -4917,7 +4963,7 @@ pass_ipa_modref::execute (function *)\n \tfor (struct cgraph_node *cur = component_node; cur;\n \t     cur = ((struct ipa_dfs_info *) cur->aux)->next_cycle)\n \t  if (modref_summary *sum = optimization_summaries->get (cur))\n-\t    sum->finalize ();\n+\t    sum->finalize (cur->decl);\n       if (dump_file)\n \tmodref_propagate_dump_scc (component_node);\n     }"}, {"sha": "118dc5f2abf250585e1a1842b2da2a2748bd38d2", "filename": "gcc/ipa-modref.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aa91072e24c1e16a5ec641b48b64c9c9f199f13/gcc%2Fipa-modref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aa91072e24c1e16a5ec641b48b64c9c9f199f13/gcc%2Fipa-modref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.h?ref=5aa91072e24c1e16a5ec641b48b64c9c9f199f13", "patch": "@@ -38,13 +38,14 @@ struct GTY(()) modref_summary\n   /* Flags coputed by finalize method.  */\n   unsigned global_memory_read : 1;\n   unsigned global_memory_written : 1;\n+  unsigned try_dse : 1;\n \n \n   modref_summary ();\n   ~modref_summary ();\n   void dump (FILE *);\n   bool useful_p (int ecf_flags, bool check_flags = true);\n-  void finalize ();\n+  void finalize (tree);\n };\n \n modref_summary *get_modref_function_summary (cgraph_node *func);"}, {"sha": "c806b0e6afe6628a6b8141cfa01981c047d68e72", "filename": "gcc/testsuite/g++.dg/cpp1z/inh-ctor23.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aa91072e24c1e16a5ec641b48b64c9c9f199f13/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor23.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aa91072e24c1e16a5ec641b48b64c9c9f199f13/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor23.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor23.C?ref=5aa91072e24c1e16a5ec641b48b64c9c9f199f13", "patch": "@@ -1,6 +1,6 @@\n // Testcase from P0136\n // { dg-do compile { target c++11 } }\n-// { dg-options \"-fnew-inheriting-ctors -fdump-tree-gimple -O2 -fno-inline\" }\n+// { dg-options \"-fnew-inheriting-ctors -fdump-tree-gimple -O2 -fno-inline -fno-ipa-modref\" }\n \n struct W { W(int); };\n struct V: W { using W::W; };"}, {"sha": "b4e1958284c26143ea986dae0df2ae276fdf24a8", "filename": "gcc/testsuite/g++.dg/ipa/ipa-icf-4.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aa91072e24c1e16a5ec641b48b64c9c9f199f13/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fipa-icf-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aa91072e24c1e16a5ec641b48b64c9c9f199f13/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fipa-icf-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fipa-icf-4.C?ref=5aa91072e24c1e16a5ec641b48b64c9c9f199f13", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-ipa-icf-optimized-missed -fno-inline\" } */\n+/* { dg-options \"-O2 -fdump-ipa-icf-optimized-missed -fno-inline -fno-ipa-modref\" } */\n \n namespace {\n struct A"}, {"sha": "1f80cc57c57c364642306e01c34bcd20c1a03261", "filename": "gcc/testsuite/gcc.dg/tree-ssa/modref-dse-1.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aa91072e24c1e16a5ec641b48b64c9c9f199f13/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-dse-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aa91072e24c1e16a5ec641b48b64c9c9f199f13/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-dse-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-dse-1.c?ref=5aa91072e24c1e16a5ec641b48b64c9c9f199f13", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-dse1-details\"  } */\n+volatile int *ptr;\n+struct a {\n+\tint a,b,c;\n+} a;\n+__attribute__((noinline))\n+static int init (struct a*a)\n+{\n+\ta->a=0;\n+\ta->b=1;\n+}\n+__attribute__((noinline))\n+static int use (struct a*a)\n+{\n+\tif (a->c != 3)\n+\t\t*ptr=5;\n+}\n+\n+void\n+main(void)\n+{\n+\tstruct a a;\n+\tinit (&a);\n+\ta.c=3;\n+\tuse (&a);\n+}\n+/* { dg-final { scan-tree-dump \"Deleted dead store: init\" \"dse1\" } } */"}, {"sha": "e41d065a5e3b65522d73e990702b15e39fcabe83", "filename": "gcc/testsuite/gcc.dg/tree-ssa/modref-dse-2.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aa91072e24c1e16a5ec641b48b64c9c9f199f13/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-dse-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aa91072e24c1e16a5ec641b48b64c9c9f199f13/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-dse-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-dse-2.c?ref=5aa91072e24c1e16a5ec641b48b64c9c9f199f13", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-dse2-details\"  } */\n+volatile int *ptr;\n+struct a {\n+\tint a,b,c;\n+} a;\n+__attribute__((noinline))\n+static int init (struct a*a)\n+{\n+\ta->a=0;\n+\ta->b=1;\n+\ta->c=1;\n+}\n+__attribute__((noinline))\n+static int use (struct a*a)\n+{\n+\tif (a->c != 3)\n+\t\t*ptr=5;\n+}\n+\n+void\n+main(void)\n+{\n+\tstruct a a;\n+\tinit (&a);\n+\ta.c=3;\n+\tuse (&a);\n+}\n+/* Only DSE2 is tracking live bytes needed to figure out that store to c is\n+   also dead above.  */\n+/* { dg-final { scan-tree-dump \"Deleted dead store: init\" \"dse2\" } } */"}, {"sha": "2965902912fc6092085225ed59534c861d23b093", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aa91072e24c1e16a5ec641b48b64c9c9f199f13/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aa91072e24c1e16a5ec641b48b64c9c9f199f13/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=5aa91072e24c1e16a5ec641b48b64c9c9f199f13", "patch": "@@ -782,7 +782,7 @@ ao_ref_alias_ptr_type (ao_ref *ref)\n    The access is assumed to be only to or after of the pointer target adjusted\n    by the offset, not before it (even in the case RANGE_KNOWN is false).  */\n \n-static void\n+void\n ao_ref_init_from_ptr_and_range (ao_ref *ref, tree ptr,\n \t\t\t\tbool range_known,\n \t\t\t\tpoly_int64 offset,"}, {"sha": "64d4865f58db4667fb44d323c92d71aac1f820e6", "filename": "gcc/tree-ssa-alias.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aa91072e24c1e16a5ec641b48b64c9c9f199f13/gcc%2Ftree-ssa-alias.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aa91072e24c1e16a5ec641b48b64c9c9f199f13/gcc%2Ftree-ssa-alias.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.h?ref=5aa91072e24c1e16a5ec641b48b64c9c9f199f13", "patch": "@@ -111,6 +111,9 @@ ao_ref::max_size_known_p () const\n /* In tree-ssa-alias.c  */\n extern void ao_ref_init (ao_ref *, tree);\n extern void ao_ref_init_from_ptr_and_size (ao_ref *, tree, tree);\n+extern void ao_ref_init_from_ptr_and_range (ao_ref *, tree, bool,\n+\t\t\t\t\t    poly_int64, poly_int64,\n+\t\t\t\t\t    poly_int64);\n extern tree ao_ref_base (ao_ref *);\n extern alias_set_type ao_ref_alias_set (ao_ref *);\n extern alias_set_type ao_ref_base_alias_set (ao_ref *);"}, {"sha": "0e8c4ed1435d14add617bb1795c3771e4cf3ff69", "filename": "gcc/tree-ssa-dse.c", "status": "modified", "additions": 107, "deletions": 1, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aa91072e24c1e16a5ec641b48b64c9c9f199f13/gcc%2Ftree-ssa-dse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aa91072e24c1e16a5ec641b48b64c9c9f199f13/gcc%2Ftree-ssa-dse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dse.c?ref=5aa91072e24c1e16a5ec641b48b64c9c9f199f13", "patch": "@@ -40,6 +40,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimplify.h\"\n #include \"tree-eh.h\"\n #include \"cfganal.h\"\n+#include \"cgraph.h\"\n+#include \"ipa-modref-tree.h\"\n+#include \"ipa-modref.h\"\n \n /* This file implements dead store elimination.\n \n@@ -1027,6 +1030,101 @@ delete_dead_or_redundant_assignment (gimple_stmt_iterator *gsi, const char *type\n   release_defs (stmt);\n }\n \n+/* Try to prove, using modref summary, that all memory written to by a call is\n+   dead and remove it.  Assume that if return value is written to memory\n+   it is already proved to be dead.  */\n+\n+static bool\n+dse_optimize_call (gimple_stmt_iterator *gsi, sbitmap live_bytes)\n+{\n+  gcall *stmt = dyn_cast <gcall *> (gsi_stmt (*gsi));\n+\n+  if (!stmt)\n+    return false;\n+\n+  tree callee = gimple_call_fndecl (stmt);\n+\n+  if (!callee)\n+    return false;\n+\n+  /* Pure/const functions are optimized by normal DCE\n+     or handled as store above.  */\n+  int flags = gimple_call_flags (stmt);\n+  if ((flags & (ECF_PURE|ECF_CONST|ECF_NOVOPS))\n+      && !(flags & (ECF_LOOPING_CONST_OR_PURE)))\n+    return false;\n+\n+  cgraph_node *node = cgraph_node::get (callee);\n+  if (!node)\n+    return false;\n+\n+  if (stmt_could_throw_p (cfun, stmt)\n+      && !cfun->can_delete_dead_exceptions)\n+    return false;\n+\n+  /* If return value is used the call is not dead.  */\n+  tree lhs = gimple_call_lhs (stmt);\n+  if (lhs && TREE_CODE (lhs) == SSA_NAME)\n+    {\n+      imm_use_iterator ui;\n+      gimple *use_stmt;\n+      FOR_EACH_IMM_USE_STMT (use_stmt, ui, lhs)\n+\tif (!is_gimple_debug (use_stmt))\n+\t  return false;\n+    }\n+\n+  /* Verify that there are no side-effects except for return value\n+     and memory writes tracked by modref.  */\n+  modref_summary *summary = get_modref_function_summary (node);\n+  if (!summary || !summary->try_dse)\n+    return false;\n+\n+  modref_base_node <alias_set_type> *base_node;\n+  modref_ref_node <alias_set_type> *ref_node;\n+  modref_access_node *access_node;\n+  size_t i, j, k;\n+  bool by_clobber_p = false;\n+\n+  /* Walk all memory writes and verify that they are dead.  */\n+  FOR_EACH_VEC_SAFE_ELT (summary->stores->bases, i, base_node)\n+    FOR_EACH_VEC_SAFE_ELT (base_node->refs, j, ref_node)\n+      FOR_EACH_VEC_SAFE_ELT (ref_node->accesses, k, access_node)\n+\t{\n+\t  gcc_checking_assert (access_node->parm_offset_known);\n+\n+\t  tree arg;\n+\t  if (access_node->parm_index == MODREF_STATIC_CHAIN_PARM)\n+\t    arg = gimple_call_chain (stmt);\n+\t  else\n+\t    arg = gimple_call_arg (stmt, access_node->parm_index);\n+\n+\t  ao_ref ref;\n+\t  poly_offset_int off = (poly_offset_int)access_node->offset\n+\t\t+ ((poly_offset_int)access_node->parm_offset\n+\t\t   << LOG2_BITS_PER_UNIT);\n+\t  poly_int64 off2;\n+\t  if (!off.to_shwi (&off2))\n+\t    return false;\n+\t  ao_ref_init_from_ptr_and_range\n+\t\t (&ref, arg, true, off2, access_node->size,\n+\t\t  access_node->max_size);\n+\t  ref.ref_alias_set = ref_node->ref;\n+\t  ref.base_alias_set = base_node->base;\n+\n+\t  bool byte_tracking_enabled\n+\t      = setup_live_bytes_from_ref (&ref, live_bytes);\n+\t  enum dse_store_status store_status;\n+\n+\t  store_status = dse_classify_store (&ref, stmt,\n+\t\t\t\t\t     byte_tracking_enabled,\n+\t\t\t\t\t     live_bytes, &by_clobber_p);\n+\t  if (store_status != DSE_STORE_DEAD)\n+\t    return false;\n+\t}\n+  delete_dead_or_redundant_assignment (gsi, \"dead\", need_eh_cleanup);\n+  return true;\n+}\n+\n /* Attempt to eliminate dead stores in the statement referenced by BSI.\n \n    A dead store is a store into a memory location which will later be\n@@ -1050,8 +1148,13 @@ dse_optimize_stmt (function *fun, gimple_stmt_iterator *gsi, sbitmap live_bytes)\n     return;\n \n   ao_ref ref;\n+  /* If this is not a store we can still remove dead call using\n+     modref summary.  */\n   if (!initialize_ao_ref_for_dse (stmt, &ref))\n-    return;\n+    {\n+      dse_optimize_call (gsi, live_bytes);\n+      return;\n+    }\n \n   /* We know we have virtual definitions.  We can handle assignments and\n      some builtin calls.  */\n@@ -1162,6 +1265,9 @@ dse_optimize_stmt (function *fun, gimple_stmt_iterator *gsi, sbitmap live_bytes)\n \t  || (stmt_could_throw_p (fun, stmt)\n \t      && !fun->can_delete_dead_exceptions)))\n     {\n+      /* See if we can remove complete call.  */\n+      if (dse_optimize_call (gsi, live_bytes))\n+\treturn;\n       /* Make sure we do not remove a return slot we cannot reconstruct\n \t later.  */\n       if (gimple_call_return_slot_opt_p (as_a <gcall *>(stmt))"}]}