{"sha": "fd660b1bee7af09cd69d1125cf35e6aa5826234c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmQ2NjBiMWJlZTdhZjA5Y2Q2OWQxMTI1Y2YzNWU2YWE1ODI2MjM0Yw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2004-06-16T05:09:41Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2004-06-16T05:09:41Z"}, "message": "fold-const.c (swap_tree_comparison): No longer static.\n\n        * fold-const.c (swap_tree_comparison): No longer static.\n        (tree_swap_operands_p): Similarly.  Return true if both operands\n        are SSA_NAMEs and the first operand has a higher version number than\n        the second operand.\n        * tree.h (swap_tree_comparison): Prototype.\n        (tree_swap_operands_p): Prototype.\n        * tree-ssa-operands.c (get_expr_operands): For commutative\n        operators and relational comparisons, canonicalize the\n        order of the operands.\n\n        * gcc.dg/tree-ssa/20040615-1.c: New test.\n        * gcc.dg/tree-ssa/20030824-1.c: Update expected output to\n        be less sensitive to operand ordering.\n        * gcc.dg/tree-ssa/20030824-2.c: Likewise.\n\nFrom-SVN: r83224", "tree": {"sha": "2d5c137139fce6357a14c09e7a739e3529131431", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2d5c137139fce6357a14c09e7a739e3529131431"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd660b1bee7af09cd69d1125cf35e6aa5826234c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd660b1bee7af09cd69d1125cf35e6aa5826234c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd660b1bee7af09cd69d1125cf35e6aa5826234c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd660b1bee7af09cd69d1125cf35e6aa5826234c/comments", "author": null, "committer": null, "parents": [{"sha": "3e97fe67e31070b78a333dba397ab4ddde2e7311", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e97fe67e31070b78a333dba397ab4ddde2e7311", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e97fe67e31070b78a333dba397ab4ddde2e7311"}], "stats": {"total": 99, "additions": 92, "deletions": 7}, "files": [{"sha": "027ff23c601ad4d669a0083d27d44cbb9683ea95", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd660b1bee7af09cd69d1125cf35e6aa5826234c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd660b1bee7af09cd69d1125cf35e6aa5826234c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fd660b1bee7af09cd69d1125cf35e6aa5826234c", "patch": "@@ -1,3 +1,15 @@\n+2004-06-15  Jeff Law  <law@redhat.com>\n+\n+\t* fold-const.c (swap_tree_comparison): No longer static.\n+\t(tree_swap_operands_p): Similarly.  Return true if both operands\n+\tare SSA_NAMEs and the first operand has a higher version number than\n+\tthe second operand.\n+\t* tree.h (swap_tree_comparison): Prototype.\n+\t(tree_swap_operands_p): Prototype.\n+\t* tree-ssa-operands.c (get_expr_operands): For commutative\n+\toperators and relational comparisons, canonicalize the\n+\torder of the operands.\n+\n 2004-06-15  Richard Henderson  <rth@redhat.com>\n \n \t* c-common.c (lang_gimplify_stmt): Remove next_p argument."}, {"sha": "91f40543cd0704b65ec478b861554f41c71a9663", "filename": "gcc/fold-const.c", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd660b1bee7af09cd69d1125cf35e6aa5826234c/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd660b1bee7af09cd69d1125cf35e6aa5826234c/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=fd660b1bee7af09cd69d1125cf35e6aa5826234c", "patch": "@@ -92,7 +92,6 @@ static hashval_t size_htab_hash (const void *);\n static int size_htab_eq (const void *, const void *);\n static tree fold_convert_const (enum tree_code, tree, tree);\n static enum tree_code invert_tree_comparison (enum tree_code, bool);\n-static enum tree_code swap_tree_comparison (enum tree_code);\n static enum comparison_code comparison_to_compcode (enum tree_code);\n static enum tree_code compcode_to_comparison (enum comparison_code);\n static tree combine_comparisons (enum tree_code, enum tree_code,\n@@ -132,8 +131,6 @@ static tree fold_mathfn_compare (enum built_in_function, enum tree_code,\n static tree fold_inf_compare (enum tree_code, tree, tree, tree);\n static tree fold_div_compare (enum tree_code, tree, tree, tree);\n static bool reorder_operands_p (tree, tree);\n-static bool tree_swap_operands_p (tree, tree, bool);\n-\n static tree fold_negate_const (tree, tree);\n static tree fold_not_const (tree, tree);\n static tree fold_relational_const (enum tree_code, tree, tree, tree);\n@@ -2119,7 +2116,7 @@ invert_tree_comparison (enum tree_code code, bool honor_nans)\n /* Similar, but return the comparison that results if the operands are\n    swapped.  This is safe for floating-point.  */\n \n-static enum tree_code\n+enum tree_code\n swap_tree_comparison (enum tree_code code)\n {\n   switch (code)\n@@ -5527,7 +5524,7 @@ reorder_operands_p (tree arg0, tree arg1)\n    isn't.  If REORDER is true, only recommend swapping if we can\n    evaluate the operands in reverse order.  */\n \n-static bool\n+bool\n tree_swap_operands_p (tree arg0, tree arg1, bool reorder)\n {\n   STRIP_SIGN_NOPS (arg0);\n@@ -5574,6 +5571,15 @@ tree_swap_operands_p (tree arg0, tree arg1, bool reorder)\n   if (DECL_P (arg0))\n     return 1;\n \n+  /* It is preferable to swap two SSA_NAME to ensure a canonical form\n+     for commutative and comparison operators.  Ensuring a canonical\n+     form allows the optimizers to find additional redundancies without\n+     having to explicitly check for both orderings.  */\n+  if (TREE_CODE (arg0) == SSA_NAME\n+      && TREE_CODE (arg1) == SSA_NAME\n+      && SSA_NAME_VERSION (arg0) > SSA_NAME_VERSION (arg1))\n+    return 1;\n+\n   return 0;\n }\n "}, {"sha": "7cb9953ad95c9831632fffdc012242162282fea8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd660b1bee7af09cd69d1125cf35e6aa5826234c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd660b1bee7af09cd69d1125cf35e6aa5826234c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fd660b1bee7af09cd69d1125cf35e6aa5826234c", "patch": "@@ -1,3 +1,10 @@\n+2004-06-15  Jeff Law  <law@redhat.com>\n+\n+\t* gcc.dg/tree-ssa/20040615-1.c: New test.\n+\t* gcc.dg/tree-ssa/20030824-1.c: Update expected output to\n+\tbe less sensitive to operand ordering.\n+\t* gcc.dg/tree-ssa/20030824-2.c: Likewise.\n+\n 2004-06-16  Danny Smith  <dannysmith@users.sourceforge.net>\n \n \t* g++.dg/abi/bitfield3.C: Add comment.."}, {"sha": "5490537900dd11955d68ac088de7821820b13fb2", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20030824-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd660b1bee7af09cd69d1125cf35e6aa5826234c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030824-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd660b1bee7af09cd69d1125cf35e6aa5826234c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030824-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030824-1.c?ref=fd660b1bee7af09cd69d1125cf35e6aa5826234c", "patch": "@@ -19,4 +19,4 @@ int foo (int x, int y)\n }\n \n /* The addition should be optimized into 'y+x'.  */\n-/* { dg-final { scan-tree-dump-times \"y \\\\+ x\" 1 \"optimized\"} } */\n+/* { dg-final { scan-tree-dump-times \"\\[xy\\] \\\\+ \\[xy]\" 1 \"optimized\"} } */"}, {"sha": "6e59dd816ca31debbfedbcb35b8fffb4eb79d6d4", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20030824-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd660b1bee7af09cd69d1125cf35e6aa5826234c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030824-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd660b1bee7af09cd69d1125cf35e6aa5826234c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030824-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030824-2.c?ref=fd660b1bee7af09cd69d1125cf35e6aa5826234c", "patch": "@@ -19,4 +19,4 @@ int foo (int x, int y)\n }\n \n /* This function should be optimized into 'return y+x'.  */\n-/* { dg-final { scan-tree-dump-times \"return y \\\\+ x\" 1 \"optimized\"} } */\n+/* { dg-final { scan-tree-dump-times \"return \\[xy\\] \\\\+ \\[xy\\]\" 1 \"optimized\"} } */"}, {"sha": "40d6676d63996a01d254e5fac6965d5ec4834c20", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20040615-1.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd660b1bee7af09cd69d1125cf35e6aa5826234c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20040615-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd660b1bee7af09cd69d1125cf35e6aa5826234c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20040615-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20040615-1.c?ref=fd660b1bee7af09cd69d1125cf35e6aa5826234c", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fdump-tree-dom1 -fdump-tree-dom2\" } */\n+  \n+void bar1 (void);\n+void bar2 (void);\n+\n+void\n+foo (unsigned int a, unsigned int b)\n+{\n+  if (a >= b)\n+    bar1 ();\n+  else if (b <= a)\n+    bar2 ();\n+}\n+\n+\n+/* We do not canonicalize the second conditional immediately after going\n+   into SSA form, thus the first dominator pass is unable to remove\n+   the useless conditional.   Thus the xfailed test. \n+\n+   However, the second conditional is canonicalized before the second\n+   dominator optimizer pass and we do want to verify the call to \n+   bar2 was eliminated.  */\n+/* { dg-final { scan-tree-dump-times \"bar2\" 0 \"dom1\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"bar2\" 0 \"dom2\" } } */\n+"}, {"sha": "f1edfa18e185c39f6df0bef3a590d036a9854998", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd660b1bee7af09cd69d1125cf35e6aa5826234c/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd660b1bee7af09cd69d1125cf35e6aa5826234c/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=fd660b1bee7af09cd69d1125cf35e6aa5826234c", "patch": "@@ -1235,6 +1235,37 @@ get_expr_operands (tree stmt, tree *expr_p, int flags, voperands_t prev_vops)\n       || code == TRUTH_XOR_EXPR\n       || code == COMPOUND_EXPR)\n     {\n+      tree op0 = TREE_OPERAND (expr, 0);\n+      tree op1 = TREE_OPERAND (expr, 1);\n+\n+      /* If it would be profitable to swap the operands, then do so to\n+\t canonicalize the statement, enabling better optimization.\n+\n+\t By placing canonicalization of such expressions here we\n+\t transparently keep statements in canonical form, even\n+\t when the statement is modified.  */\n+      if (tree_swap_operands_p (op0, op1, false))\n+\t{\n+\t  /* For relationals we need to swap the operands and change\n+\t     the code.  */\n+\t  if (code == LT_EXPR\n+\t      || code == GT_EXPR\n+\t      || code == LE_EXPR\n+\t      || code == GE_EXPR)\n+\t    {\n+\t      TREE_SET_CODE (expr, swap_tree_comparison (code));\n+\t      TREE_OPERAND (expr, 0) = op1;\n+\t      TREE_OPERAND (expr, 1) = op0;\n+\t    }\n+\t  \n+\t  /* For a commutative operator we can just swap the operands.  */\n+\t  if (commutative_tree_code (code))\n+\t    {\n+\t      TREE_OPERAND (expr, 0) = op1;\n+\t      TREE_OPERAND (expr, 1) = op0;\n+\t    }\n+\t}\n+\n       get_expr_operands (stmt, &TREE_OPERAND (expr, 0), flags, prev_vops);\n       get_expr_operands (stmt, &TREE_OPERAND (expr, 1), flags, prev_vops);\n       return;"}, {"sha": "a1db1f049d2b2bfd04126a048605f75759705c71", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd660b1bee7af09cd69d1125cf35e6aa5826234c/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd660b1bee7af09cd69d1125cf35e6aa5826234c/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=fd660b1bee7af09cd69d1125cf35e6aa5826234c", "patch": "@@ -3332,6 +3332,9 @@ extern tree build_fold_addr_expr (tree);\n extern tree build_fold_addr_expr_with_type (tree, tree);\n extern tree build_fold_indirect_ref (tree);\n \n+extern bool tree_swap_operands_p (tree, tree, bool);\n+extern enum tree_code swap_tree_comparison (enum tree_code);\n+\n /* In builtins.c */\n extern tree fold_builtin (tree);\n extern enum built_in_function builtin_mathfn_code (tree);"}]}