{"sha": "ae5f0df1d5446a1839427f627e9e7f1bb764de2f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWU1ZjBkZjFkNTQ0NmExODM5NDI3ZjYyN2U5ZTdmMWJiNzY0ZGUyZg==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2016-05-06T10:20:13Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2016-05-06T10:20:13Z"}, "message": "re PR target/58219 ([SH] mov.l insn length is wrong on SH2A)\n\ngcc/\n\tPR target/58219\n\t* config/sh/predicates.md (long_displacement_mem_operand): New.\n\t* config/sh/sh.md (movsi_i): Allow for SH2A, disallow for any FPU.\n\tAdd movi20, movi20s alternatives.  Adjust length attribute for\n\talternatives.\n\t(movsi_ie): Allow for any FPU.  Adjust length attribute for\n\talternatives.\n\t(movsi_i_lowpart): Add movi20, movi20s alternatives.  Adjust length\n\tattribute for alternatives.\n\t(*mov<mode>): Use long_displacement_mem_operand for length attribute.\n\t(*movdi_i, movdf_k, movdf_i4, movsf_i, movsf_ie, movsf_ie_ra): Adjust\n\tlength attribute for alternatives.\n\ngcc/testsuite/\n\tPR target/58219\n\t*gcc.target/sh/pr58219.c: New tests.\n\nFrom-SVN: r235954", "tree": {"sha": "d8cade67627b6cb3a648493275b69f2364c05c9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8cade67627b6cb3a648493275b69f2364c05c9d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ae5f0df1d5446a1839427f627e9e7f1bb764de2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae5f0df1d5446a1839427f627e9e7f1bb764de2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae5f0df1d5446a1839427f627e9e7f1bb764de2f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae5f0df1d5446a1839427f627e9e7f1bb764de2f/comments", "author": null, "committer": null, "parents": [{"sha": "078f7e37ba6e00cc64b6c5ffb5f7e0c596d9c0a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/078f7e37ba6e00cc64b6c5ffb5f7e0c596d9c0a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/078f7e37ba6e00cc64b6c5ffb5f7e0c596d9c0a9"}], "stats": {"total": 319, "additions": 239, "deletions": 80}, "files": [{"sha": "84bf0c095cfca7c952a8c0f0d731540c3dad3dfc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae5f0df1d5446a1839427f627e9e7f1bb764de2f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae5f0df1d5446a1839427f627e9e7f1bb764de2f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ae5f0df1d5446a1839427f627e9e7f1bb764de2f", "patch": "@@ -1,3 +1,18 @@\n+2016-05-06  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/58219\n+\t* config/sh/predicates.md (long_displacement_mem_operand): New.\n+\t* config/sh/sh.md (movsi_i): Allow for SH2A, disallow for any FPU.\n+\tAdd movi20, movi20s alternatives.  Adjust length attribute for\n+\talternatives.\n+\t(movsi_ie): Allow for any FPU.  Adjust length attribute for\n+\talternatives.\n+\t(movsi_i_lowpart): Add movi20, movi20s alternatives.  Adjust length\n+\tattribute for alternatives.\n+\t(*mov<mode>): Use long_displacement_mem_operand for length attribute.\n+\t(*movdi_i, movdf_k, movdf_i4, movsf_i, movsf_ie, movsf_ie_ra): Adjust\n+\tlength attribute for alternatives.\n+\n 2016-05-06  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/70960"}, {"sha": "4de90af9abbf3daaf857a9db66252175a2353937", "filename": "gcc/config/sh/predicates.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae5f0df1d5446a1839427f627e9e7f1bb764de2f/gcc%2Fconfig%2Fsh%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae5f0df1d5446a1839427f627e9e7f1bb764de2f/gcc%2Fconfig%2Fsh%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fpredicates.md?ref=ae5f0df1d5446a1839427f627e9e7f1bb764de2f", "patch": "@@ -230,6 +230,12 @@\n        (match_test \"sh_disp_addr_displacement (op)\n \t\t    <= sh_max_mov_insn_displacement (GET_MODE (op), false)\")))\n \n+;; Returns true if OP is a displacement address that does not fit into\n+;; a 16 bit (non-SH2A) memory load / store insn.\n+(define_predicate \"long_displacement_mem_operand\"\n+  (and (match_operand 0 \"displacement_mem_operand\")\n+       (not (match_operand 0 \"short_displacement_mem_operand\"))))\n+\n ;; Returns true if OP is a post-increment addressing mode memory reference.\n (define_predicate \"post_inc_mem\"\n   (and (match_code \"mem\")"}, {"sha": "7b0e746a05147b97d7d7e310e30ec0e9aa0bc605", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 153, "deletions": 80, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae5f0df1d5446a1839427f627e9e7f1bb764de2f/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae5f0df1d5446a1839427f627e9e7f1bb764de2f/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=ae5f0df1d5446a1839427f627e9e7f1bb764de2f", "patch": "@@ -5181,20 +5181,23 @@\n ;; t/r must come after r/r, lest reload will try to reload stuff like\n ;; (set (subreg:SI (mem:QI (plus:SI (reg:SI SP_REG) (const_int 12)) 0) 0)\n ;; (made from (set (subreg:SI (reg:QI ###) 0) ) into T.\n+;; Notice that although this pattern allows movi20 and movi20s on non-SH2A,\n+;; those alternatives will not be taken, as they will be converted into\n+;; PC-relative loads.\n (define_insn \"movsi_i\"\n   [(set (match_operand:SI 0 \"general_movdst_operand\"\n-\t    \"=r,r,r,r,r,r,m,<,<,x,l,x,l,r\")\n+\t\t\t    \"=r,r,  r,  r,  r, r,r,r,m,<,<,x,l,x,l,r\")\n \t(match_operand:SI 1 \"general_movsrc_operand\"\n-\t \"Q,r,I08,mr,x,l,r,x,l,r,r,>,>,i\"))]\n-  \"TARGET_SH1\n-   && ! TARGET_SH2E\n-   && ! TARGET_SH2A\n+\t\t\t    \" Q,r,I08,I20,I28,mr,x,l,r,x,l,r,r,>,>,i\"))]\n+  \"TARGET_SH1 && !TARGET_FPU_ANY\n    && (register_operand (operands[0], SImode)\n        || register_operand (operands[1], SImode))\"\n   \"@\n \tmov.l\t%1,%0\n \tmov\t%1,%0\n \tmov\t%1,%0\n+\tmovi20\t%1,%0\n+\tmovi20s\t%1,%0\n \tmov.l\t%1,%0\n \tsts\t%1,%0\n \tsts\t%1,%0\n@@ -5206,22 +5209,43 @@\n \tlds.l\t%1,%0\n \tlds.l\t%1,%0\n \tfake\t%1,%0\"\n-  [(set_attr \"type\" \"pcload_si,move,movi8,load_si,mac_gp,prget,store,mac_mem,\n-\t\t     pstore,gp_mac,prset,mem_mac,pload,pcload_si\")\n-   (set_attr \"length\" \"*,*,*,*,*,*,*,*,*,*,*,*,*,*\")])\n+  [(set_attr \"type\" \"pcload_si,move,movi8,move,move,load_si,mac_gp,prget,store,\n+\t\t     mac_mem,pstore,gp_mac,prset,mem_mac,pload,pcload_si\")\n+   (set_attr_alternative \"length\"\n+     [(const_int 2)\n+      (const_int 2)\n+      (const_int 2)\n+      (const_int 4)\n+      (const_int 4)\n+      (if_then_else (match_operand 1 \"long_displacement_mem_operand\")\n+\t\t    (const_int 4) (const_int 2))\n+      (const_int 2)\n+      (const_int 2)\n+      (if_then_else (match_operand 0 \"long_displacement_mem_operand\")\n+\t\t    (const_int 4) (const_int 2))\n+      (const_int 2)\n+      (const_int 2)\n+      (const_int 2)\n+      (const_int 2)\n+      (const_int 2)\n+      (const_int 2)\n+      (const_int 2)])])\n \n ;; t/r must come after r/r, lest reload will try to reload stuff like\n ;; (subreg:SI (reg:SF FR14_REG) 0) into T (compiling stdlib/strtod.c -m3e -O2)\n ;; ??? This allows moves from macl to fpul to be recognized, but these moves\n ;; will require a reload.\n ;; ??? We can't include f/f because we need the proper FPSCR setting when\n ;; TARGET_FMOVD is in effect, and mode switching is done before reload.\n+;; Notice that although this pattern allows movi20 and movi20s on non-SH2A,\n+;; those alternatives will not be taken, as they will be converted into\n+;; PC-relative loads.\n (define_insn \"movsi_ie\"\n   [(set (match_operand:SI 0 \"general_movdst_operand\"\n-\t    \"=r,r,r,r,r,r,r,r,mr,<,<,x,l,x,l,y,<,r,y,r,*f,y,*f,y\")\n+\t    \"=r,r,  r,  r,  r, r,r,r,mr,<,<,x,l,x,l,y,<,r,y,r,*f, y,*f,y\")\n \t(match_operand:SI 1 \"general_movsrc_operand\"\n-\t \"Q,r,I08,I20,I28,mr,x,l,r,x,l,r,r,>,>,>,y,i,r,y,y,*f,*f,y\"))]\n-  \"(TARGET_SH2E || TARGET_SH2A)\n+\t    \" Q,r,I08,I20,I28,mr,x,l, r,x,l,r,r,>,>,>,y,i,r,y, y,*f,*f,y\"))]\n+  \"TARGET_SH1 && TARGET_FPU_ANY\n    && ((register_operand (operands[0], SImode)\n \t&& !fpscr_operand (operands[0], SImode))\n        || (register_operand (operands[1], SImode)\n@@ -5261,14 +5285,12 @@\n       (const_int 2)\n       (const_int 4)\n       (const_int 4)\n-      (if_then_else\n-\t(match_test \"TARGET_SH2A\")\n-\t(const_int 4) (const_int 2))\n+      (if_then_else (match_operand 1 \"long_displacement_mem_operand\")\n+\t\t    (const_int 4) (const_int 2))\n       (const_int 2)\n       (const_int 2)\n-      (if_then_else\n-\t(match_test \"TARGET_SH2A\")\n-\t(const_int 4) (const_int 2))\n+      (if_then_else (match_operand 0 \"long_displacement_mem_operand\")\n+\t\t    (const_int 4) (const_int 2))\n       (const_int 2)\n       (const_int 2)\n       (const_int 2)\n@@ -5285,23 +5307,44 @@\n       (const_int 2)\n       (const_int 0)])])\n \n+;; Notice that although this pattern allows movi20 and movi20s on non-SH2A,\n+;; those alternatives will not be taken, as they will be converted into\n+;; PC-relative loads.\n (define_insn \"movsi_i_lowpart\"\n   [(set (strict_low_part\n-\t  (match_operand:SI 0 \"general_movdst_operand\" \"+r,r,r,r,r,r,m,r\"))\n-\t(match_operand:SI 1 \"general_movsrc_operand\" \"Q,r,I08,mr,x,l,r,i\"))]\n-   \"TARGET_SH1\n-    && (register_operand (operands[0], SImode)\n-        || register_operand (operands[1], SImode))\"\n+\t  (match_operand:SI 0 \"general_movdst_operand\"\n+\t\t\t      \"+r,r,  r,  r,  r, r,r,r,m,r\"))\n+\t(match_operand:SI 1 \"general_movsrc_operand\"\n+\t\t\t      \" Q,r,I08,I20,I28,mr,x,l,r,i\"))]\n+  \"TARGET_SH1\n+   && (register_operand (operands[0], SImode)\n+       || register_operand (operands[1], SImode))\"\n   \"@\n \tmov.l\t%1,%0\n \tmov\t%1,%0\n \tmov\t%1,%0\n+\tmovi20\t%1,%0\n+\tmovi20s\t%1,%0\n \tmov.l\t%1,%0\n \tsts\t%1,%0\n \tsts\t%1,%0\n \tmov.l\t%1,%0\n \tfake\t%1,%0\"\n-  [(set_attr \"type\" \"pcload,move,arith,load,mac_gp,prget,store,pcload\")])\n+  [(set_attr \"type\" \"pcload,move,movi8,move,move,load,mac_gp,prget,store,\n+\t\t     pcload\")\n+   (set_attr_alternative \"length\"\n+     [(const_int 2)\n+      (const_int 2)\n+      (const_int 2)\n+      (const_int 4)\n+      (const_int 4)\n+      (if_then_else (match_operand 1 \"long_displacement_mem_operand\")\n+\t\t    (const_int 4) (const_int 2))\n+      (const_int 2)\n+      (const_int 2)\n+      (if_then_else (match_operand 0 \"long_displacement_mem_operand\")\n+\t\t    (const_int 4) (const_int 2))\n+      (const_int 2)])])\n \n (define_insn_and_split \"load_ra\"\n   [(set (match_operand:SI 0 \"general_movdst_operand\" \"\")\n@@ -5478,27 +5521,26 @@\n \tlds\t%1,%0\"\n   [(set_attr \"type\" \"pcload,move,movi8,store,load,store,load,store,load,prget,prset\")\n    (set (attr \"length\")\n-\t(cond [(and (match_operand 0 \"displacement_mem_operand\")\n-\t\t    (not (match_operand 0 \"short_displacement_mem_operand\")))\n-\t       (const_int 4)\n-\t       (and (match_operand 1 \"displacement_mem_operand\")\n-\t\t    (not (match_operand 1 \"short_displacement_mem_operand\")))\n-\t       (const_int 4)]\n+\t(cond [(match_operand 0 \"long_displacement_mem_operand\") (const_int 4)\n+\t       (match_operand 1 \"long_displacement_mem_operand\") (const_int 4)]\n \t      (const_int 2)))])\n \n ;; x/r can be created by inlining/cse, e.g. for execute/961213-1.c\n ;; compiled with -m2 -ml -O3 -funroll-loops\n (define_insn \"*movdi_i\"\n-  [(set (match_operand:DI 0 \"general_movdst_operand\" \"=r,r,r,m,r,r,r,*!x\")\n-\t(match_operand:DI 1 \"general_movsrc_operand\" \"Q,r,m,r,I08,i,x,r\"))]\n+  [(set (match_operand:DI 0 \"general_movdst_operand\" \"=r,r,r,m,  r,r,r,*!x\")\n+\t(match_operand:DI 1 \"general_movsrc_operand\" \" Q,r,m,r,I08,i,x,  r\"))]\n   \"TARGET_SH1\n    && (arith_reg_operand (operands[0], DImode)\n        || arith_reg_operand (operands[1], DImode))\"\n {\n   return output_movedouble (insn, operands, DImode);\n }\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"pcload,move,load,store,move,pcload,move,move\")])\n+  [(set_attr \"type\" \"pcload,move,load,store,move,pcload,move,move\")\n+   (set (attr \"length\")\n+\t(cond [(match_operand 0 \"long_displacement_mem_operand\") (const_int 8)\n+\t       (match_operand 1 \"long_displacement_mem_operand\") (const_int 8)]\n+\t      (const_int 4)))])\n \n ;; If the output is a register and the input is memory or a register, we have\n ;; to be careful and see which word needs to be loaded first.\n@@ -5576,8 +5618,8 @@\n \n ;; FIXME: This should be a define_insn_and_split.\n (define_insn \"movdf_k\"\n-  [(set (match_operand:DF 0 \"general_movdst_operand\" \"=r,r,r,m\")\n-\t(match_operand:DF 1 \"general_movsrc_operand\" \"r,FQ,m,r\"))]\n+  [(set (match_operand:DF 0 \"general_movdst_operand\" \"=r, r,r,m\")\n+\t(match_operand:DF 1 \"general_movsrc_operand\" \" r,FQ,m,r\"))]\n   \"TARGET_SH1\n    && (!TARGET_FPU_DOUBLE || reload_completed\n        /* ??? We provide some insn so that direct_{load,store}[DFmode] get set */\n@@ -5588,20 +5630,31 @@\n {\n   return output_movedouble (insn, operands, DFmode);\n }\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"move,pcload,load,store\")])\n+  [(set_attr \"type\" \"move,pcload,load,store\")\n+   (set (attr \"length\")\n+\t(cond [(match_operand 0 \"long_displacement_mem_operand\") (const_int 8)\n+\t       (match_operand 1 \"long_displacement_mem_operand\") (const_int 8)]\n+\t      (const_int 4)))])\n \n ;; All alternatives of movdf_i4 are split for ! TARGET_FMOVD.\n ;; However, the d/F/c/z alternative cannot be split directly; it is converted\n ;; with special code in machine_dependent_reorg into a load of the R0_REG and\n ;; the d/m/c/X alternative, which is split later into single-precision\n ;; instructions.  And when not optimizing, no splits are done before fixing\n ;; up pcloads, so we need usable length information for that.\n+;; A DF constant load results in the following worst-case 8 byte sequence:\n+;;\tmova\t...,r0\n+;;\tfmov.s\t@r0+,..\n+;;\tfmov.s\t@r0,...\n+;;\tadd\t#-4,r0\n (define_insn \"movdf_i4\"\n-  [(set (match_operand:DF 0 \"general_movdst_operand\" \"=d,r,d,d,m,r,r,m,!??r,!???d\")\n-\t(match_operand:DF 1 \"general_movsrc_operand\"  \"d,r,F,m,d,FQ,m,r,d,r\"))\n+  [(set (match_operand:DF 0 \"general_movdst_operand\"\n+\t\t\t\t\"=d,r, d,d,m, r,r,m,!??r,!???d\")\n+\t(match_operand:DF 1 \"general_movsrc_operand\"\n+\t\t\t\t\" d,r, F,m,d,FQ,m,r,   d,    r\"))\n    (use (reg:SI FPSCR_MODES_REG))\n-   (clobber (match_scratch:SI 2                      \"=X,X,&z,X,X,X,X,X,X,X\"))]\n+   (clobber (match_scratch:SI 2\n+\t\t\t\t\"=X,X,&z,X,X, X,X,X,   X,    X\"))]\n   \"TARGET_FPU_DOUBLE\n    && (arith_reg_operand (operands[0], DFmode)\n        || arith_reg_operand (operands[1], DFmode))\"\n@@ -5625,16 +5678,28 @@\n     }\n   }\n   [(set_attr_alternative \"length\"\n-     [(if_then_else (eq_attr \"fmovd\" \"yes\") (const_int 4) (const_int 8))\n+     [(if_then_else (eq_attr \"fmovd\" \"yes\") (const_int 2) (const_int 4))\n       (const_int 4)\n-      (if_then_else (eq_attr \"fmovd\" \"yes\") (const_int 4) (const_int 6))\n-      (if_then_else (eq_attr \"fmovd\" \"yes\") (const_int 4) (const_int 6))\n-      (if_then_else (eq_attr \"fmovd\" \"yes\") (const_int 4) (const_int 6))\n+      (if_then_else (eq_attr \"fmovd\" \"yes\") (const_int 4) (const_int 8))\n+      (if_then_else (match_operand 1 \"displacement_mem_operand\")\n+\t\t    (if_then_else (eq_attr \"fmovd\" \"yes\")\n+\t\t\t\t  (const_int 4) (const_int 8))\n+\t\t    (if_then_else (eq_attr \"fmovd\" \"yes\")\n+\t\t\t\t  (const_int 2) (const_int 4)))\n+      (if_then_else (match_operand 0 \"displacement_mem_operand\")\n+\t\t    (if_then_else (eq_attr \"fmovd\" \"yes\")\n+\t\t\t\t  (const_int 4) (const_int 8))\n+\t\t    (if_then_else (eq_attr \"fmovd\" \"yes\")\n+\t\t\t\t  (const_int 2) (const_int 4)))\n       (const_int 4)\n-      (const_int 8) (const_int 8) ;; these need only 8 bytes for @(r0,rn)\n+      (if_then_else (match_operand 1 \"long_displacement_mem_operand\")\n+\t\t    (const_int 8) (const_int 4))\n+      (if_then_else (match_operand 0 \"long_displacement_mem_operand\")\n+\t\t    (const_int 8) (const_int 4))\n       (const_int 8)\n       (const_int 8)])\n-   (set_attr \"type\" \"fmove,move,pcfload,fload,fstore,pcload,load,store,load,fload\")\n+   (set_attr \"type\" \"fmove,move,pcfload,fload,fstore,pcload,load,store,load,\n+\t\t    fload\")\n    (set_attr \"late_fp_use\" \"*,*,*,*,yes,*,*,*,*,*\")\n    (set (attr \"fp_mode\") (if_then_else (eq_attr \"fmovd\" \"yes\")\n \t\t\t\t\t   (const_string \"double\")\n@@ -6028,8 +6093,11 @@\n     }\n })\n \n+;; FIXME Although the movsf_i pattern is not used when there's an FPU,\n+;; it somehow influences some RA choices also on FPU targets.\n+;; For non-FPU targets it's actually not needed.\n (define_insn \"movsf_i\"\n-  [(set (match_operand:SF 0 \"general_movdst_operand\" \"=r,r,r,r,m,l,r\")\n+  [(set (match_operand:SF 0 \"general_movdst_operand\" \"=r,r, r, r,m,l,r\")\n \t(match_operand:SF 1 \"general_movsrc_operand\"  \"r,G,FQ,mr,r,r,l\"))]\n   \"TARGET_SH1\n    && (! TARGET_SH2E\n@@ -6046,21 +6114,34 @@\n \tmov.l\t%1,%0\n \tlds\t%1,%0\n \tsts\t%1,%0\"\n-  [(set_attr \"type\" \"move,move,pcload,load,store,move,move\")])\n+  [(set_attr \"type\" \"move,move,pcload,load,store,move,move\")\n+   (set_attr_alternative \"length\"\n+     [(const_int 2)\n+      (const_int 2)\n+      (if_then_else (match_operand 1 \"long_displacement_mem_operand\")\n+\t\t    (const_int 4) (const_int 2))\n+      (if_then_else (match_operand 1 \"long_displacement_mem_operand\")\n+\t\t    (const_int 4) (const_int 2))\n+      (if_then_else (match_operand 0 \"long_displacement_mem_operand\")\n+\t\t    (const_int 4) (const_int 2))\n+      (const_int 2)\n+      (const_int 2)])])\n \n ;; We may not split the ry/yr/XX alternatives to movsi_ie, since\n ;; update_flow_info would not know where to put REG_EQUAL notes\n ;; when the destination changes mode.\n (define_insn \"movsf_ie\"\n   [(set (match_operand:SF 0 \"general_movdst_operand\"\n-\t \"=f,r,f,f,fy,f,m,r,r,m,f,y,y,rf,r,y,<,y,y\")\n+\t\t\t        \"=f,r,f,f,fy, f,m, r, r,m,f,y,y,rf,r,y,<,y,y\")\n \t(match_operand:SF 1 \"general_movsrc_operand\"\n-\t  \"f,r,G,H,FQ,mf,f,FQ,mr,r,y,f,>,fr,y,r,y,>,y\"))\n+\t\t\t        \" f,r,G,H,FQ,mf,f,FQ,mr,r,y,f,>,fr,y,r,y,>,y\"))\n    (use (reg:SI FPSCR_MODES_REG))\n-   (clobber (match_scratch:SI 2 \"=X,X,X,X,&z,X,X,X,X,X,X,X,X,y,X,X,X,X,X\"))]\n+   (clobber (match_scratch:SI 2 \"=X,X,X,X,&z, X,X, X, X,X,X,X,X, y,X,X,X,X,X\"))]\n   \"TARGET_SH2E\n-   && (arith_reg_operand (operands[0], SFmode) || fpul_operand (operands[0], SFmode)\n-       || arith_reg_operand (operands[1], SFmode) || fpul_operand (operands[1], SFmode)\n+   && (arith_reg_operand (operands[0], SFmode)\n+       || fpul_operand (operands[0], SFmode)\n+       || arith_reg_operand (operands[1], SFmode)\n+       || fpul_operand (operands[1], SFmode)\n        || arith_reg_operand (operands[2], SImode))\"\n   \"@\n \tfmov\t%1,%0\n@@ -6091,19 +6172,15 @@\n       (const_int 2)\n       (const_int 2)\n       (const_int 4)\n-      (if_then_else\n-\t(match_test \"TARGET_SH2A\")\n-\t(const_int 4) (const_int 2))\n-      (if_then_else\n-\t(match_test \"TARGET_SH2A\")\n-\t(const_int 4) (const_int 2))\n+      (if_then_else (match_operand 1 \"displacement_mem_operand\")\n+\t\t    (const_int 4) (const_int 2))\n+      (if_then_else (match_operand 0 \"displacement_mem_operand\")\n+\t\t    (const_int 4) (const_int 2))\n       (const_int 2)\n-      (if_then_else\n-\t(match_test \"TARGET_SH2A\")\n-\t(const_int 4) (const_int 2))\n-      (if_then_else\n-\t(match_test \"TARGET_SH2A\")\n-\t(const_int 4) (const_int 2))\n+      (if_then_else (match_operand 1 \"long_displacement_mem_operand\")\n+\t\t    (const_int 4) (const_int 2))\n+      (if_then_else (match_operand 0 \"long_displacement_mem_operand\")\n+\t\t    (const_int 4) (const_int 2))\n       (const_int 2)\n       (const_int 2)\n       (const_int 2)\n@@ -6139,11 +6216,11 @@\n \n (define_insn_and_split \"movsf_ie_ra\"\n   [(set (match_operand:SF 0 \"general_movdst_operand\"\n-\t \"=f,r,f,f,fy,f,m,r,r,m,f,y,y,rf,r,y,<,y,y\")\n+\t \t\t\t\"=f,r,f,f,fy,f,m, r,r,m,f,y,y,rf,r,y,<,y,y\")\n \t(match_operand:SF 1 \"general_movsrc_operand\"\n-\t  \"f,r,G,H,FQ,m,f,FQ,m,r,y,f,>,fr,y,r,y,>,y\"))\n+\t\t\t\t\" f,r,G,H,FQ,m,f,FQ,m,r,y,f,>,fr,y,r,y,>,y\"))\n    (use (reg:SI FPSCR_MODES_REG))\n-   (clobber (match_scratch:SF 2 \"=r,r,X,X,&z,r,r,X,r,r,r,r,r,y,r,r,r,r,r\"))\n+   (clobber (match_scratch:SF 2 \"=r,r,X,X,&z,r,r, X,r,r,r,r,r, y,r,r,r,r,r\"))\n    (const_int 0)]\n   \"TARGET_SH2E\n    && (arith_reg_operand (operands[0], SFmode)\n@@ -6189,19 +6266,15 @@\n       (const_int 2)\n       (const_int 2)\n       (const_int 4)\n-      (if_then_else\n-\t(match_test \"TARGET_SH2A\")\n-\t(const_int 4) (const_int 2))\n-      (if_then_else\n-\t(match_test \"TARGET_SH2A\")\n-\t(const_int 4) (const_int 2))\n+      (if_then_else (match_operand 1 \"displacement_mem_operand\")\n+\t\t    (const_int 4) (const_int 2))\n+      (if_then_else (match_operand 0 \"displacement_mem_operand\")\n+\t\t    (const_int 4) (const_int 2))\n       (const_int 2)\n-      (if_then_else\n-\t(match_test \"TARGET_SH2A\")\n-\t(const_int 4) (const_int 2))\n-      (if_then_else\n-\t(match_test \"TARGET_SH2A\")\n-\t(const_int 4) (const_int 2))\n+      (if_then_else (match_operand 1 \"long_displacement_mem_operand\")\n+\t\t    (const_int 4) (const_int 2))\n+      (if_then_else (match_operand 0 \"long_displacement_mem_operand\")\n+\t\t    (const_int 4) (const_int 2))\n       (const_int 2)\n       (const_int 2)\n       (const_int 2)"}, {"sha": "f645fe5235048bce8b624fe95670c0d695366afd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae5f0df1d5446a1839427f627e9e7f1bb764de2f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae5f0df1d5446a1839427f627e9e7f1bb764de2f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ae5f0df1d5446a1839427f627e9e7f1bb764de2f", "patch": "@@ -1,3 +1,8 @@\n+2016-05-06  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/58219\n+\t*gcc.target/sh/pr58219.c: New tests.\n+\n 2016-05-06  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/70960"}, {"sha": "d900f72eae8b8e2b762eb898e20e735a28063ef1", "filename": "gcc/testsuite/gcc.target/sh/pr58219.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae5f0df1d5446a1839427f627e9e7f1bb764de2f/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr58219.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae5f0df1d5446a1839427f627e9e7f1bb764de2f/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr58219.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr58219.c?ref=ae5f0df1d5446a1839427f627e9e7f1bb764de2f", "patch": "@@ -0,0 +1,60 @@\n+/* Check that move instructions have the correct length on SH2A.  */\n+/* { dg-do compile }  */\n+/* { dg-options \"-O1 -dp\" }  */\n+\n+/* { dg-final { scan-assembler-times \"length = 4\" 10 { target { \"sh2a\" && any_fpu } } } }  */\n+/* { dg-final { scan-assembler-times \"length = 4\" 8 { target { \"sh2a\" && no_fpu } } } }  */\n+\n+int\n+test_00 (int* x)\n+{\n+  return x[0];\n+}\n+\n+int\n+test_01 (int* x)\n+{\n+  return x[1];\n+}\n+\n+int\n+test_02 (int* x)\n+{\n+  return x[100];\n+}\n+\n+int\n+test_03 (int* x, unsigned int y)\n+{\n+  return *(int*)((unsigned int)x + y);\n+}\n+\n+float\n+test_04 (float* x)\n+{\n+  return x[0];\n+}\n+\n+float\n+test_05 (float* x)\n+{\n+  return x[5];\n+}\n+\n+float\n+test_06 (float* x)\n+{\n+  return x[100];\n+}\n+\n+int\n+test_07 (void)\n+{\n+  return 1230;\n+}\n+\n+int\n+test_08 (void)\n+{\n+  return 0xFF0000;\n+}"}]}