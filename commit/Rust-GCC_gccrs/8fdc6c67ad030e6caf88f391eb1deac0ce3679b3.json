{"sha": "8fdc6c67ad030e6caf88f391eb1deac0ce3679b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGZkYzZjNjdhZDAzMGU2Y2FmODhmMzkxZWIxZGVhYzBjZTM2NzliMw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-07-14T07:25:55Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-07-14T07:25:55Z"}, "message": "genmatch.c (struct operand): Add OP_IF and OP_WITH op_types.\n\n2015-07-14  Richard Biener  <rguenther@suse.de>\n\n\t* genmatch.c (struct operand): Add OP_IF and OP_WITH op_types.\n\t(struct if_expr): New.\n\t(struct with_expr): Likewise.\n\t(is_a_helper): Add helpers for if_expr and with_expr.\n\t(struct simplify): Add simplify_kind enum and member.  Remove\n\tifexpr_vec member.\n\t(simplify::simplify): Adjust.\n\t(lower_commutative): Adjust.\n\t(lower_opt_convert): Likewise.\n\t(lower_cond): Likewise.\n\t(replace_id): Handle with_expr and if_expr.\n\t(lower_for): Adjust.\n\t(dt_simplify::gen_1): New recursive worker, split out from ...\n\t(dt_simplify::gen): ... here.  Deal with if and with expansion\n\trecursively.\n\t(capture_info::capture_info): Take context argument\n\t(capture_info::walk_result): Only analyze specific result.\n\t(parser::parse_result): New function.\n\t(parser::parse_simplify): Adjust to parse ifs with then end\n\telse case.\n\t(parser::parse_if): Simplify.\n\t(parser::parse_pattern): Pass down simplify kind.\n\t* match.pd: Convert if structure to new syntax.\n\nFrom-SVN: r225760", "tree": {"sha": "ccc608c672b2695baf0c2f4456fb027e99928f9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ccc608c672b2695baf0c2f4456fb027e99928f9e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8fdc6c67ad030e6caf88f391eb1deac0ce3679b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fdc6c67ad030e6caf88f391eb1deac0ce3679b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8fdc6c67ad030e6caf88f391eb1deac0ce3679b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fdc6c67ad030e6caf88f391eb1deac0ce3679b3/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "67a546ab451541e24dae5c8ecbaf692c8cd89f08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67a546ab451541e24dae5c8ecbaf692c8cd89f08", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67a546ab451541e24dae5c8ecbaf692c8cd89f08"}], "stats": {"total": 794, "additions": 445, "deletions": 349}, "files": [{"sha": "de40c6084f23484c97a718c4d893871754b75643", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdc6c67ad030e6caf88f391eb1deac0ce3679b3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdc6c67ad030e6caf88f391eb1deac0ce3679b3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8fdc6c67ad030e6caf88f391eb1deac0ce3679b3", "patch": "@@ -1,3 +1,29 @@\n+2015-07-14  Richard Biener  <rguenther@suse.de>\n+\n+\t* genmatch.c (struct operand): Add OP_IF and OP_WITH op_types.\n+\t(struct if_expr): New.\n+\t(struct with_expr): Likewise.\n+\t(is_a_helper): Add helpers for if_expr and with_expr.\n+\t(struct simplify): Add simplify_kind enum and member.  Remove\n+\tifexpr_vec member.\n+\t(simplify::simplify): Adjust.\n+\t(lower_commutative): Adjust.\n+\t(lower_opt_convert): Likewise.\n+\t(lower_cond): Likewise.\n+\t(replace_id): Handle with_expr and if_expr.\n+\t(lower_for): Adjust.\n+\t(dt_simplify::gen_1): New recursive worker, split out from ...\n+\t(dt_simplify::gen): ... here.  Deal with if and with expansion\n+\trecursively.\n+\t(capture_info::capture_info): Take context argument\n+\t(capture_info::walk_result): Only analyze specific result.\n+\t(parser::parse_result): New function.\n+\t(parser::parse_simplify): Adjust to parse ifs with then end\n+\telse case.\n+\t(parser::parse_if): Simplify.\n+\t(parser::parse_pattern): Pass down simplify kind.\n+\t* match.pd: Convert if structure to new syntax.\n+\n 2015-07-13  Marek Polacek  <polacek@redhat.com>\n \n \t* rtl.c (rtx_equal_p_cb): Fix typo."}, {"sha": "12f04b05a81f013848abeb084972f54b352dd0dc", "filename": "gcc/genmatch.c", "status": "modified", "additions": 293, "deletions": 217, "changes": 510, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdc6c67ad030e6caf88f391eb1deac0ce3679b3/gcc%2Fgenmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdc6c67ad030e6caf88f391eb1deac0ce3679b3/gcc%2Fgenmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmatch.c?ref=8fdc6c67ad030e6caf88f391eb1deac0ce3679b3", "patch": "@@ -482,7 +482,7 @@ struct capture_info;\n /* The base class for operands.  */\n \n struct operand {\n-  enum op_type { OP_PREDICATE, OP_EXPR, OP_CAPTURE, OP_C_EXPR };\n+  enum op_type { OP_PREDICATE, OP_EXPR, OP_CAPTURE, OP_C_EXPR, OP_IF, OP_WITH };\n   operand (enum op_type type_) : type (type_) {}\n   enum op_type type;\n   virtual void gen_transform (FILE *, int, const char *, bool, int,\n@@ -578,6 +578,26 @@ struct capture : public operand\n \t\t\t      dt_operand ** = 0, bool = true);\n };\n \n+/* if expression.  */\n+\n+struct if_expr : public operand\n+{\n+  if_expr () : operand (OP_IF), cond (NULL), trueexpr (NULL),\n+    falseexpr (NULL) {}\n+  c_expr *cond;\n+  operand *trueexpr;\n+  operand *falseexpr;\n+};\n+\n+/* with expression.  */\n+\n+struct with_expr : public operand\n+{\n+  with_expr () : operand (OP_WITH), with (NULL), subexpr (NULL) {}\n+  c_expr *with;\n+  operand *subexpr;\n+};\n+\n template<>\n template<>\n inline bool\n@@ -610,16 +630,21 @@ is_a_helper <expr *>::test (operand *op)\n   return op->type == operand::OP_EXPR;\n }\n \n-/* Helper to distinguish 'if' from 'with' expressions.  */\n+template<>\n+template<>\n+inline bool\n+is_a_helper <if_expr *>::test (operand *op)\n+{\n+  return op->type == operand::OP_IF;\n+}\n \n-struct if_or_with\n+template<>\n+template<>\n+inline bool\n+is_a_helper <with_expr *>::test (operand *op)\n {\n-  if_or_with (operand *cexpr_, source_location location_, bool is_with_)\n-      : location (location_), cexpr (cexpr_), is_with (is_with_) {}\n-  source_location location;\n-  operand *cexpr;\n-  bool is_with;\n-};\n+  return op->type == operand::OP_WITH;\n+}\n \n /* The main class of a pattern and its transform.  This is used to\n    represent both (simplify ...) and (match ...) kinds.  The AST\n@@ -628,26 +653,27 @@ struct if_or_with\n \n struct simplify\n {\n-  simplify (operand *match_, source_location match_location_,\n+  enum simplify_kind { SIMPLIFY, MATCH };\n+\n+  simplify (simplify_kind kind_,\n+\t    operand *match_, source_location match_location_,\n \t    struct operand *result_, source_location result_location_,\n-\t    vec<if_or_with> ifexpr_vec_, vec<vec<user_id *> > for_vec_,\n-\t    cid_map_t *capture_ids_)\n-      : match (match_), match_location (match_location_),\n+\t    vec<vec<user_id *> > for_vec_, cid_map_t *capture_ids_)\n+      : kind (kind_), match (match_), match_location (match_location_),\n       result (result_), result_location (result_location_),\n-      ifexpr_vec (ifexpr_vec_), for_vec (for_vec_),\n+      for_vec (for_vec_),\n       capture_ids (capture_ids_), capture_max (capture_ids_->elements () - 1) {}\n \n+  simplify_kind kind;\n   /* The expression that is matched against the GENERIC or GIMPLE IL.  */\n   operand *match;\n   source_location match_location;\n-  /* For a (simplify ...) the expression produced when the pattern applies.\n-     For a (match ...) either NULL if it is a simple predicate or the\n-     single expression specifying the matched operands.  */\n+  /* For a (simplify ...) an expression with ifs and withs with the expression\n+     produced when the pattern applies in the leafs.\n+     For a (match ...) the leafs are either empty if it is a simple predicate\n+     or the single expression specifying the matched operands.  */\n   struct operand *result;\n   source_location result_location;\n-  /* Collected 'if' expressions that need to evaluate to true to make\n-     the pattern apply.  */\n-  vec<if_or_with> ifexpr_vec;\n   /* Collected 'for' expression operators that have to be replaced\n      in the lowering phase.  */\n   vec<vec<user_id *> > for_vec;\n@@ -803,8 +829,8 @@ lower_commutative (simplify *s, vec<simplify *>& simplifiers)\n   vec<operand *> matchers = commutate (s->match);\n   for (unsigned i = 0; i < matchers.length (); ++i)\n     {\n-      simplify *ns = new simplify (matchers[i], s->match_location,\n-\t\t\t\t   s->result, s->result_location, s->ifexpr_vec,\n+      simplify *ns = new simplify (s->kind, matchers[i], s->match_location,\n+\t\t\t\t   s->result, s->result_location,\n \t\t\t\t   s->for_vec, s->capture_ids);\n       simplifiers.safe_push (ns);\n     }\n@@ -932,8 +958,8 @@ lower_opt_convert (simplify *s, vec<simplify *>& simplifiers)\n   vec<operand *> matchers = lower_opt_convert (s->match);\n   for (unsigned i = 0; i < matchers.length (); ++i)\n     {\n-      simplify *ns = new simplify (matchers[i], s->match_location,\n-\t\t\t\t   s->result, s->result_location, s->ifexpr_vec,\n+      simplify *ns = new simplify (s->kind, matchers[i], s->match_location,\n+\t\t\t\t   s->result, s->result_location,\n \t\t\t\t   s->for_vec, s->capture_ids);\n       simplifiers.safe_push (ns);\n     }\n@@ -1032,8 +1058,8 @@ lower_cond (simplify *s, vec<simplify *>& simplifiers)\n   vec<operand *> matchers = lower_cond (s->match);\n   for (unsigned i = 0; i < matchers.length (); ++i)\n     {\n-      simplify *ns = new simplify (matchers[i], s->match_location,\n-\t\t\t\t   s->result, s->result_location, s->ifexpr_vec,\n+      simplify *ns = new simplify (s->kind, matchers[i], s->match_location,\n+\t\t\t\t   s->result, s->result_location,\n \t\t\t\t   s->for_vec, s->capture_ids);\n       simplifiers.safe_push (ns);\n     }\n@@ -1061,6 +1087,22 @@ replace_id (operand *o, user_id *id, id_base *with)\n \tne->append_op (replace_id (e->ops[i], id, with));\n       return ne;\n     }\n+  else if (with_expr *w = dyn_cast <with_expr *> (o))\n+    {\n+      with_expr *nw = new with_expr ();\n+      nw->with = as_a <c_expr *> (replace_id (w->with, id, with));\n+      nw->subexpr = replace_id (w->subexpr, id, with);\n+      return nw;\n+    }\n+  else if (if_expr *ife = dyn_cast <if_expr *> (o))\n+    {\n+      if_expr *nife = new if_expr ();\n+      nife->cond = as_a <c_expr *> (replace_id (ife->cond, id, with));\n+      nife->trueexpr = replace_id (ife->trueexpr, id, with);\n+      if (ife->falseexpr)\n+\tnife->falseexpr = replace_id (ife->falseexpr, id, with);\n+      return nife;\n+    }\n \n   /* For c_expr we simply record a string replacement table which is\n      applied at code-generation time.  */\n@@ -1105,22 +1147,17 @@ lower_for (simplify *sin, vec<simplify *>& simplifiers)\n \t    {\n \t      operand *match_op = s->match;\n \t      operand *result_op = s->result;\n-\t      vec<if_or_with> ifexpr_vec = s->ifexpr_vec.copy ();\n-\n \t      for (unsigned i = 0; i < n_ids; ++i)\n \t\t{\n \t\t  user_id *id = ids[i];\n \t\t  id_base *oper = id->substitutes[j % id->substitutes.length ()];\n \t\t  match_op = replace_id (match_op, id, oper);\n \t\t  if (result_op)\n \t\t    result_op = replace_id (result_op, id, oper);\n-\t\t  for (unsigned k = 0; k < s->ifexpr_vec.length (); ++k)\n-\t\t    ifexpr_vec[k].cexpr = replace_id (ifexpr_vec[k].cexpr,\n-\t\t\t\t\t\t      id, oper);\n \t\t}\n-\t      simplify *ns = new simplify (match_op, s->match_location,\n+\t      simplify *ns = new simplify (s->kind, match_op, s->match_location,\n \t\t\t\t\t   result_op, s->result_location,\n-\t\t\t\t\t   ifexpr_vec, vNULL, s->capture_ids);\n+\t\t\t\t\t   vNULL, s->capture_ids);\n \t      worklist.safe_push (ns);\n \t    }\n \t}\n@@ -1228,6 +1265,7 @@ struct dt_simplify : public dt_node\n \t: dt_node (DT_SIMPLIFY), s (s_), pattern_no (pattern_no_),\n \t  indexes (indexes_)  {}\n \n+  void gen_1 (FILE *, int, bool, operand *);\n   void gen (FILE *f, int, bool);\n };\n \n@@ -1530,9 +1568,9 @@ decision_tree::print (FILE *f)\n \n struct capture_info\n {\n-  capture_info (simplify *s);\n+  capture_info (simplify *s, operand *);\n   void walk_match (operand *o, unsigned toplevel_arg, bool, bool);\n-  void walk_result (operand *o, bool);\n+  bool walk_result (operand *o, bool, operand *);\n   void walk_c_expr (c_expr *);\n \n   struct cinfo\n@@ -1552,12 +1590,10 @@ struct capture_info\n \n /* Analyze captures in S.  */\n \n-capture_info::capture_info (simplify *s)\n+capture_info::capture_info (simplify *s, operand *result)\n {\n   expr *e;\n-  if (!s->result\n-      || ((e = dyn_cast <expr *> (s->result))\n-\t  && is_a <predicate_id *> (e->operation)))\n+  if (s->kind == simplify::MATCH)\n     {\n       force_no_side_effects = -1;\n       return;\n@@ -1575,11 +1611,7 @@ capture_info::capture_info (simplify *s)\n \t\t&& (*e->operation == COND_EXPR\n \t\t    || *e->operation == VEC_COND_EXPR));\n \n-  walk_result (s->result, false);\n-\n-  for (unsigned i = 0; i < s->ifexpr_vec.length (); ++i)\n-    if (s->ifexpr_vec[i].is_with)\n-      walk_c_expr (as_a <c_expr *>(s->ifexpr_vec[i].cexpr));\n+  walk_result (s->result, false, result);\n }\n \n /* Analyze captures in the match expression piece O.  */\n@@ -1630,10 +1662,12 @@ capture_info::walk_match (operand *o, unsigned toplevel_arg,\n     gcc_unreachable ();\n }\n \n-/* Analyze captures in the result expression piece O.  */\n+/* Analyze captures in the result expression piece O.  Return true\n+   if RESULT was visited in one of the children.  Only visit\n+   non-if/with children if they are rooted on RESULT.  */\n \n-void\n-capture_info::walk_result (operand *o, bool conditional_p)\n+bool\n+capture_info::walk_result (operand *o, bool conditional_p, operand *result)\n {\n   if (capture *c = dyn_cast <capture *> (o))\n     {\n@@ -1650,7 +1684,7 @@ capture_info::walk_result (operand *o, bool conditional_p)\n \t  && is_a <expr *> (c->what))\n \t{\n \t  info[c->where].cse_p = true;\n-\t  walk_result (c->what, true);\n+\t  walk_result (c->what, true, result);\n \t}\n     }\n   else if (expr *e = dyn_cast <expr *> (o))\n@@ -1663,13 +1697,49 @@ capture_info::walk_result (operand *o, bool conditional_p)\n \t  else if (*e->operation == TRUTH_ANDIF_EXPR\n \t\t   || *e->operation == TRUTH_ORIF_EXPR)\n \t    cond_p = true;\n-\t  walk_result (e->ops[i], cond_p);\n+\t  walk_result (e->ops[i], cond_p, result);\n+\t}\n+    }\n+  else if (if_expr *e = dyn_cast <if_expr *> (o))\n+    {\n+      /* 'if' conditions should be all fine.  */\n+      if (e->trueexpr == result)\n+\t{\n+\t  walk_result (e->trueexpr, false, result);\n+\t  return true;\n+\t}\n+      if (e->falseexpr == result)\n+\t{\n+\t  walk_result (e->falseexpr, false, result);\n+\t  return true;\n \t}\n+      bool res = false;\n+      if (is_a <if_expr *> (e->trueexpr)\n+\t  || is_a <with_expr *> (e->trueexpr))\n+\tres |= walk_result (e->trueexpr, false, result);\n+      if (e->falseexpr\n+\t  && (is_a <if_expr *> (e->falseexpr)\n+\t      || is_a <with_expr *> (e->falseexpr)))\n+\tres |= walk_result (e->falseexpr, false, result);\n+      return res;\n+    }\n+  else if (with_expr *e = dyn_cast <with_expr *> (o))\n+    {\n+      bool res = (e->subexpr == result);\n+      if (res\n+\t  || is_a <if_expr *> (e->subexpr)\n+\t  || is_a <with_expr *> (e->subexpr))\n+\tres |= walk_result (e->subexpr, false, result);\n+      if (res)\n+\twalk_c_expr (e->with);\n+      return res;\n     }\n   else if (c_expr *e = dyn_cast <c_expr *> (o))\n     walk_c_expr (e);\n   else\n     gcc_unreachable ();\n+\n+  return false;\n }\n \n /* Look for captures in the C expr E.  */\n@@ -2487,87 +2557,55 @@ dt_operand::gen (FILE *f, int indent, bool gimple)\n }\n \n \n-\n /* Generate code for the '(if ...)', '(with ..)' and actual transform\n    step of a '(simplify ...)' or '(match ...)'.  This handles everything\n-   that is not part of the decision tree (simplify->match).  */\n+   that is not part of the decision tree (simplify->match).\n+   Main recursive worker.  */\n \n void\n-dt_simplify::gen (FILE *f, int indent, bool gimple)\n+dt_simplify::gen_1 (FILE *f, int indent, bool gimple, operand *result)\n {\n-  fprintf_indent (f, indent, \"{\\n\");\n-  indent += 2;\n-  output_line_directive (f, s->result_location);\n-  if (s->capture_max >= 0)\n-    fprintf_indent (f, indent, \"tree captures[%u] ATTRIBUTE_UNUSED = {};\\n\",\n-\t\t    s->capture_max + 1);\n-\n-  for (int i = 0; i <= s->capture_max; ++i)\n-    if (indexes[i])\n-      {\n-\tchar opname[20];\n-\tfprintf_indent (f, indent, \"captures[%u] = %s;\\n\",\n-\t\t\ti, indexes[i]->get_name (opname));\n-      }\n-\n-  unsigned n_braces = 0;\n-  if (s->ifexpr_vec != vNULL)\n+  if (result)\n     {\n-      for (unsigned i = 0; i < s->ifexpr_vec.length (); ++i)\n+      if (with_expr *w = dyn_cast <with_expr *> (result))\n \t{\n-\t  if_or_with &w = s->ifexpr_vec[i];\n-\t  if (w.is_with)\n+\t  fprintf_indent (f, indent, \"{\\n\");\n+\t  indent += 4;\n+\t  output_line_directive (f, w->with->code[0].src_loc);\n+\t  w->with->gen_transform (f, indent, NULL, true, 1, \"type\", NULL);\n+\t  gen_1 (f, indent, gimple, w->subexpr);\n+\t  indent -= 4;\n+\t  fprintf_indent (f, indent, \"}\\n\");\n+\t  return;\n+\t}\n+      else if (if_expr *ife = dyn_cast <if_expr *> (result))\n+\t{\n+\t  output_line_directive (f, ife->cond->code[0].src_loc);\n+\t  fprintf_indent (f, indent, \"if (\");\n+\t  ife->cond->gen_transform (f, indent, NULL, true, 1, \"type\", NULL);\n+\t  fprintf (f, \")\\n\");\n+\t  fprintf_indent (f, indent + 2, \"{\\n\");\n+\t  indent += 4;\n+\t  gen_1 (f, indent, gimple, ife->trueexpr);\n+\t  indent -= 4;\n+\t  fprintf_indent (f, indent + 2, \"}\\n\");\n+\t  if (ife->falseexpr)\n \t    {\n-\t      fprintf_indent (f, indent, \"{\\n\");\n+\t      fprintf_indent (f, indent, \"else\\n\");\n+\t      fprintf_indent (f, indent + 2, \"{\\n\");\n \t      indent += 4;\n-\t      output_line_directive (f, w.location);\n-\t      w.cexpr->gen_transform (f, indent, NULL, true, 1, \"type\", NULL);\n-\t      n_braces++;\n-\t    }\n-\t  else\n-\t    {\n-\t      output_line_directive (f, w.location);\n-\t      fprintf_indent (f, indent, \"if (\");\n-\t      if (i == s->ifexpr_vec.length () - 1\n-\t\t  || s->ifexpr_vec[i+1].is_with)\n-\t\tw.cexpr->gen_transform (f, indent, NULL, true, 1, \"type\", NULL);\n-\t      else\n-\t\t{\n-\t\t  unsigned j = i;\n-\t\t  do\n-\t\t    {\n-\t\t      if (j != i)\n-\t\t\t{\n-\t\t\t  fprintf (f, \"\\n\");\n-\t\t\t  output_line_directive (f, s->ifexpr_vec[j].location);\n-\t\t\t  fprintf_indent (f, indent + 4, \"&& \");\n-\t\t\t}\n-\t\t      fprintf (f, \"(\");\n-\t\t      s->ifexpr_vec[j].cexpr->gen_transform (f, 0, NULL,\n-\t\t\t\t\t\t\t     true, 1, \"type\",\n-\t\t\t\t\t\t\t     NULL);\n-\t\t      fprintf (f, \")\");\n-\t\t      ++j;\n-\t\t    }\n-\t\t  while (j < s->ifexpr_vec.length ()\n-\t\t\t && !s->ifexpr_vec[j].is_with);\n-\t\t  i = j - 1;\n-\t\t}\n-\t      fprintf (f, \")\\n\");\n+\t      gen_1 (f, indent, gimple, ife->falseexpr);\n+\t      indent -= 4;\n+\t      fprintf_indent (f, indent + 2, \"}\\n\");\n \t    }\n+\t  return;\n \t}\n-      fprintf_indent (f, indent + 2, \"{\\n\");\n-      indent += 4;\n-      n_braces++;\n     }\n \n   /* Analyze captures and perform early-outs on the incoming arguments\n      that cover cases we cannot handle.  */\n-  capture_info cinfo (s);\n-  expr *e;\n-  if (s->result\n-      && !((e = dyn_cast <expr *> (s->result))\n-\t   && is_a <predicate_id *> (e->operation)))\n+  capture_info cinfo (s, result);\n+  if (s->kind == simplify::SIMPLIFY)\n     {\n       if (!gimple)\n \t{\n@@ -2626,7 +2664,6 @@ dt_simplify::gen (FILE *f, int indent, bool gimple)\n   output_line_directive (f, s->result_location, true);\n   fprintf (f, \", %%s:%%d\\\\n\\\", __FILE__, __LINE__);\\n\");\n \n-  operand *result = s->result;\n   if (!result)\n     {\n       /* If there is no result then this is a predicate implementation.  */\n@@ -2782,7 +2819,7 @@ dt_simplify::gen (FILE *f, int indent, bool gimple)\n \n \t{\n \t  fprintf_indent (f, indent, \"tree res;\\n\");\n-\t  s->result->gen_transform (f, indent, \"res\", false, 1, \"type\",\n+\t  result->gen_transform (f, indent, \"res\", false, 1, \"type\",\n \t\t\t\t    &cinfo, indexes);\n \t}\n       else\n@@ -2809,12 +2846,31 @@ dt_simplify::gen (FILE *f, int indent, bool gimple)\n \t  fprintf_indent (f, indent, \"return res;\\n\");\n \t}\n     }\n+}\n \n-  for (unsigned i = 0; i < n_braces; ++i)\n-    {\n-      fprintf_indent (f, indent - 2, \"}\\n\");\n-      indent -= 4;\n-    }\n+/* Generate code for the '(if ...)', '(with ..)' and actual transform\n+   step of a '(simplify ...)' or '(match ...)'.  This handles everything\n+   that is not part of the decision tree (simplify->match).  */\n+\n+void\n+dt_simplify::gen (FILE *f, int indent, bool gimple)\n+{\n+  fprintf_indent (f, indent, \"{\\n\");\n+  indent += 2;\n+  output_line_directive (f, s->result_location);\n+  if (s->capture_max >= 0)\n+    fprintf_indent (f, indent, \"tree captures[%u] ATTRIBUTE_UNUSED = {};\\n\",\n+\t\t    s->capture_max + 1);\n+\n+  for (int i = 0; i <= s->capture_max; ++i)\n+    if (indexes[i])\n+      {\n+\tchar opname[20];\n+\tfprintf_indent (f, indent, \"captures[%u] = %s;\\n\",\n+\t\t\ti, indexes[i]->get_name (opname));\n+      }\n+\n+  gen_1 (f, indent, gimple, s->result);\n \n   indent -= 2;\n   fprintf_indent (f, indent, \"}\\n\");\n@@ -2976,17 +3032,20 @@ class parser\n   void record_operlist (source_location, user_id *);\n \n   void parse_pattern ();\n-  void push_simplify (vec<simplify *>&, operand *, source_location,\n+  operand *parse_result (operand *, predicate_id *);\n+  void push_simplify (simplify::simplify_kind,\n+\t\t      vec<simplify *>&, operand *, source_location,\n \t\t      operand *, source_location);\n-  void parse_simplify (source_location, vec<simplify *>&, predicate_id *,\n-\t\t       expr *);\n+  void parse_simplify (simplify::simplify_kind,\n+\t\t       source_location, vec<simplify *>&, predicate_id *,\n+\t\t       operand *);\n   void parse_for (source_location);\n   void parse_if (source_location);\n   void parse_predicates (source_location);\n   void parse_operator_list (source_location);\n \n   cpp_reader *r;\n-  vec<if_or_with> active_ifs;\n+  vec<c_expr *> active_ifs;\n   vec<vec<user_id *> > active_fors;\n   hash_set<user_id *> *oper_lists_set;\n   vec<user_id *> oper_lists;\n@@ -3425,7 +3484,8 @@ parser::parse_op ()\n    MATCH_LOC, RESULT and RESULT_LOC and push it to SIMPLIFIERS.  */\n \n void\n-parser::push_simplify (vec<simplify *>& simplifiers,\n+parser::push_simplify (simplify::simplify_kind kind,\n+\t\t       vec<simplify *>& simplifiers,\n \t\t       operand *match, source_location match_loc,\n \t\t       operand *result, source_location result_loc)\n {\n@@ -3434,27 +3494,90 @@ parser::push_simplify (vec<simplify *>& simplifiers,\n     active_fors.safe_push (oper_lists);\n \n   simplifiers.safe_push\n-    (new simplify (match, match_loc, result, result_loc,\n-\t\t   active_ifs.copy (), active_fors.copy (), capture_ids));\n+    (new simplify (kind, match, match_loc, result, result_loc,\n+\t\t   active_fors.copy (), capture_ids));\n \n   if (!oper_lists.is_empty ())\n     active_fors.pop ();\n }\n \n /* Parse\n-     simplify = 'simplify' <expr> <result-op>\n-   or\n-     match = 'match' <ident> <expr> [<result-op>]\n-   with\n      <result-op> = <op> | <if> | <with>\n      <if> = '(' 'if' '(' <c-expr> ')' <result-op> ')'\n      <with> = '(' 'with' '{' <c-expr> '}' <result-op> ')'\n+   and return it.  */\n+\n+operand *\n+parser::parse_result (operand *result, predicate_id *matcher)\n+{\n+  const cpp_token *token = peek ();\n+  if (token->type != CPP_OPEN_PAREN)\n+    return parse_op ();\n+\n+  eat_token (CPP_OPEN_PAREN);\n+  if (peek_ident (\"if\"))\n+    {\n+      eat_ident (\"if\");\n+      if_expr *ife = new if_expr ();\n+      ife->cond = parse_c_expr (CPP_OPEN_PAREN);\n+      if (peek ()->type == CPP_OPEN_PAREN)\n+\t{\n+\t  ife->trueexpr = parse_result (result, matcher);\n+\t  if (peek ()->type == CPP_OPEN_PAREN)\n+\t    ife->falseexpr = parse_result (result, matcher);\n+\t  else if (peek ()->type != CPP_CLOSE_PAREN)\n+\t    ife->falseexpr = parse_op ();\n+\t}\n+      else if (peek ()->type != CPP_CLOSE_PAREN)\n+\t{\n+\t  ife->trueexpr = parse_op ();\n+\t  if (peek ()->type == CPP_OPEN_PAREN)\n+\t    ife->falseexpr = parse_result (result, matcher);\n+\t  else if (peek ()->type != CPP_CLOSE_PAREN)\n+\t    ife->falseexpr = parse_op ();\n+\t}\n+      /* If this if is immediately closed then it contains a\n+\t manual matcher or is part of a predicate definition.  */\n+      else /* if (peek ()->type == CPP_CLOSE_PAREN) */\n+\t{\n+\t  if (!matcher)\n+\t    fatal_at (peek (), \"manual transform not implemented\");\n+\t}\n+      eat_token (CPP_CLOSE_PAREN);\n+      return ife;\n+    }\n+  else if (peek_ident (\"with\"))\n+    {\n+      eat_ident (\"with\");\n+      with_expr *withe = new with_expr ();\n+      /* Parse (with c-expr expr) as (if-with (true) expr).  */\n+      withe->with = parse_c_expr (CPP_OPEN_BRACE);\n+      withe->with->nr_stmts = 0;\n+      withe->subexpr = parse_result (result, matcher);\n+      eat_token (CPP_CLOSE_PAREN);\n+      return withe;\n+    }\n+  else\n+    {\n+      operand *op = result;\n+      if (!matcher)\n+\top = parse_expr ();\n+      eat_token (CPP_CLOSE_PAREN);\n+      return op;\n+    }\n+}\n+\n+/* Parse\n+     simplify = 'simplify' <expr> <result-op>\n+   or\n+     match = 'match' <ident> <expr> [<result-op>]\n    and fill SIMPLIFIERS with the results.  */\n \n void\n-parser::parse_simplify (source_location match_location,\n+parser::parse_simplify (simplify::simplify_kind kind,\n+\t\t\tsource_location match_location,\n \t\t\tvec<simplify *>& simplifiers, predicate_id *matcher,\n-\t\t\texpr *result)\n+\t\t\toperand *result)\n {\n   /* Reset the capture map.  */\n   if (!capture_ids)\n@@ -3474,6 +3597,20 @@ parser::parse_simplify (source_location match_location,\n       && is_a <predicate_id *> (as_a <expr *> (match)->operation))\n     fatal_at (loc, \"outermost expression cannot be a predicate\");\n \n+  /* Splice active_ifs onto result and continue parsing the\n+     \"then\" expr.  */\n+  if_expr *active_if = NULL;\n+  for (int i = active_ifs.length (); i > 0; --i)\n+    {\n+      if_expr *ifc = new if_expr ();\n+      ifc->cond = active_ifs[i-1];\n+      ifc->trueexpr = active_if;\n+      active_if = ifc;\n+    }\n+  if_expr *outermost_if = active_if;\n+  while (active_if && active_if->trueexpr)\n+    active_if = as_a <if_expr *> (active_if->trueexpr);\n+\n   const cpp_token *token = peek ();\n \n   /* If this if is immediately closed then it is part of a predicate\n@@ -3482,89 +3619,27 @@ parser::parse_simplify (source_location match_location,\n     {\n       if (!matcher)\n \tfatal_at (token, \"expected transform expression\");\n-      push_simplify (simplifiers, match, match_location,\n+      if (active_if)\n+\t{\n+\t  active_if->trueexpr = result;\n+\t  result = outermost_if;\n+\t}\n+      push_simplify (kind, simplifiers, match, match_location,\n \t\t     result, token->src_loc);\n       return;\n     }\n \n-  unsigned active_ifs_len = active_ifs.length ();\n-  while (1)\n+  operand *tem = parse_result (result, matcher);\n+  if (active_if)\n     {\n-      if (token->type == CPP_OPEN_PAREN)\n-\t{\n-\t  source_location paren_loc = token->src_loc;\n-\t  eat_token (CPP_OPEN_PAREN);\n-\t  if (peek_ident (\"if\"))\n-\t    {\n-\t      eat_ident (\"if\");\n-\t      active_ifs.safe_push (if_or_with (parse_c_expr (CPP_OPEN_PAREN),\n-\t\t\t\t\t\ttoken->src_loc, false));\n-\t      /* If this if is immediately closed then it contains a\n-\t         manual matcher or is part of a predicate definition.\n-\t\t Push it.  */\n-\t      if (peek ()->type == CPP_CLOSE_PAREN)\n-\t\t{\n-\t\t  if (!matcher)\n-\t\t    fatal_at (token, \"manual transform not implemented\");\n-\t\t  push_simplify (simplifiers, match, match_location,\n-\t\t\t\t result, paren_loc);\n-\t\t}\n-\t    }\n-\t  else if (peek_ident (\"with\"))\n-\t    {\n-\t      eat_ident (\"with\");\n-\t      /* Parse (with c-expr expr) as (if-with (true) expr).  */\n-\t      c_expr *e = parse_c_expr (CPP_OPEN_BRACE);\n-\t      e->nr_stmts = 0;\n-\t      active_ifs.safe_push (if_or_with (e, token->src_loc, true));\n-\t    }\n-\t  else\n-\t    {\n-\t      operand *op = result;\n-\t      if (!matcher)\n-\t\top = parse_expr ();\n-\t      push_simplify (simplifiers, match, match_location,\n-\t\t\t     op, token->src_loc);\n-\t      eat_token (CPP_CLOSE_PAREN);\n-\t      /* A \"default\" result closes the enclosing scope.  */\n-\t      if (active_ifs.length () > active_ifs_len)\n-\t\t{\n-\t\t  eat_token (CPP_CLOSE_PAREN);\n-\t\t  active_ifs.pop ();\n-\t\t}\n-\t      else\n-\t\treturn;\n-\t    }\n-\t}\n-      else if (token->type == CPP_CLOSE_PAREN)\n-\t{\n-\t  /* Close a scope if requested.  */\n-\t  if (active_ifs.length () > active_ifs_len)\n-\t    {\n-\t      eat_token (CPP_CLOSE_PAREN);\n-\t      active_ifs.pop ();\n-\t      token = peek ();\n-\t    }\n-\t  else\n-\t    return;\n-\t}\n-      else\n-\t{\n-\t  if (matcher)\n-\t    fatal_at (token, \"expected match operand expression\");\n-\t  push_simplify (simplifiers, match, match_location,\n-\t\t\t matcher ? result : parse_op (), token->src_loc);\n-\t  /* A \"default\" result closes the enclosing scope.  */\n-\t  if (active_ifs.length () > active_ifs_len)\n-\t    {\n-\t      eat_token (CPP_CLOSE_PAREN);\n-\t      active_ifs.pop ();\n-\t    }\n-\t  else\n-\t    return;\n-\t}\n-      token = peek ();\n+      active_if->trueexpr = tem;\n+      result = outermost_if;\n     }\n+  else\n+    result = tem;\n+\n+  push_simplify (kind, simplifiers, match, match_location,\n+\t\t result, token->src_loc);\n }\n \n /* Parsing of the outer control structures.  */\n@@ -3740,15 +3815,15 @@ parser::parse_operator_list (source_location)\n      if = '(' 'if' '(' <c-expr> ')' <pattern> ')'  */\n \n void\n-parser::parse_if (source_location loc)\n+parser::parse_if (source_location)\n {\n-  operand *ifexpr = parse_c_expr (CPP_OPEN_PAREN);\n+  c_expr *ifexpr = parse_c_expr (CPP_OPEN_PAREN);\n \n   const cpp_token *token = peek ();\n   if (token->type == CPP_CLOSE_PAREN)\n     fatal_at (token, \"no pattern defined in if\");\n \n-  active_ifs.safe_push (if_or_with (ifexpr, loc, false));\n+  active_ifs.safe_push (ifexpr);\n   while (1)\n     {\n       const cpp_token *token = peek ();\n@@ -3789,7 +3864,8 @@ parser::parse_pattern ()\n   const char *id = get_ident ();\n   if (strcmp (id, \"simplify\") == 0)\n     {\n-      parse_simplify (token->src_loc, simplifiers, NULL, NULL);\n+      parse_simplify (simplify::SIMPLIFY,\n+\t\t      token->src_loc, simplifiers, NULL, NULL);\n       capture_ids = NULL;\n     }\n   else if (strcmp (id, \"match\") == 0)\n@@ -3827,7 +3903,7 @@ parser::parse_pattern ()\n \t      || (!e && p->nargs != 0)))\n \tfatal_at (token, \"non-matching number of match operands\");\n       p->nargs = e ? e->ops.length () : 0;\n-      parse_simplify (token->src_loc, p->matchers, p, e);\n+      parse_simplify (simplify::MATCH, token->src_loc, p->matchers, p, e);\n       capture_ids = NULL;\n     }\n   else if (strcmp (id, \"for\") == 0)"}, {"sha": "8694854faa102b1f46662ebaf74653840a515ad4", "filename": "gcc/match.pd", "status": "modified", "additions": 126, "deletions": 132, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdc6c67ad030e6caf88f391eb1deac0ce3679b3/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdc6c67ad030e6caf88f391eb1deac0ce3679b3/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=8fdc6c67ad030e6caf88f391eb1deac0ce3679b3", "patch": "@@ -153,11 +153,10 @@ along with GCC; see the file COPYING3.  If not see\n     wide_int mul = wi::mul (@1, @2, TYPE_SIGN (type), &overflow_p);\n    }\n    (if (!overflow_p)\n-    (div @0 { wide_int_to_tree (type, mul); }))\n-   (if (overflow_p\n-        && (TYPE_UNSIGNED (type)\n-\t    || mul != wi::min_value (TYPE_PRECISION (type), SIGNED)))\n-    { build_zero_cst (type); }))))\n+    (div @0 { wide_int_to_tree (type, mul); })\n+    (if (TYPE_UNSIGNED (type)\n+\t || mul != wi::min_value (TYPE_PRECISION (type), SIGNED))\n+     { build_zero_cst (type); })))))\n \n /* Optimize A / A to 1.0 if we don't care about\n    NaNs or Infinities.  */\n@@ -203,11 +202,11 @@ along with GCC; see the file COPYING3.  If not see\n     (with\n      { tree tem = const_binop (RDIV_EXPR, type, build_one_cst (type), @1); }\n      (if (tem)\n-      (mult @0 { tem; } ))))\n-   (if (cst != COMPLEX_CST)\n-    (with { tree inverse = exact_inverse (type, @1); }\n-     (if (inverse)\n-      (mult @0 { inverse; } )))))))\n+      (mult @0 { tem; } )))\n+    (if (cst != COMPLEX_CST)\n+     (with { tree inverse = exact_inverse (type, @1); }\n+      (if (inverse)\n+       (mult @0 { inverse; } ))))))))\n \n /* Same applies to modulo operations, but fold is inconsistent here\n    and simplifies 0 % x to 0, only preserving literal 0 % 0.  */\n@@ -908,11 +907,11 @@ along with GCC; see the file COPYING3.  If not see\n         being well defined.  */\n      (if (low >= prec)\n       (if (op == LROTATE_EXPR || op == RROTATE_EXPR)\n-       (op @0 { build_int_cst (TREE_TYPE (@1), low % prec); }))\n-      (if (TYPE_UNSIGNED (type) || code == LSHIFT_EXPR)\n-       { build_zero_cst (type); })\n-      (op @0 { build_int_cst (TREE_TYPE (@1), prec - 1); }))\n-     (op @0 { build_int_cst (TREE_TYPE (@1), low); }))))))\n+       (op @0 { build_int_cst (TREE_TYPE (@1), low % prec); })\n+       (if (TYPE_UNSIGNED (type) || code == LSHIFT_EXPR)\n+        { build_zero_cst (type); }\n+        (op @0 { build_int_cst (TREE_TYPE (@1), prec - 1); })))\n+      (op @0 { build_int_cst (TREE_TYPE (@1), low); })))))))\n \n \n /* ((1 << A) & 1) != 0 -> A == 0\n@@ -933,10 +932,10 @@ along with GCC; see the file COPYING3.  If not see\n    (if (cand < 0\n \t|| (!integer_zerop (@2)\n \t    && wi::ne_p (wi::lshift (@0, cand), @2)))\n-    { constant_boolean_node (cmp == NE_EXPR, type); })\n-   (if (!integer_zerop (@2)\n-\t&& wi::eq_p (wi::lshift (@0, cand), @2))\n-    (cmp @1 { build_int_cst (TREE_TYPE (@1), cand); })))))\n+    { constant_boolean_node (cmp == NE_EXPR, type); }\n+    (if (!integer_zerop (@2)\n+\t && wi::eq_p (wi::lshift (@0, cand), @2))\n+     (cmp @1 { build_int_cst (TREE_TYPE (@1), cand); }))))))\n \n /* Fold (X << C1) & C2 into (X << C1) & (C2 | ((1 << C1) - 1))\n         (X >> C1) & C2 into (X >> C1) & (C2 | ~((type) -1 >> C1))\n@@ -1007,27 +1006,26 @@ along with GCC; see the file COPYING3.  If not see\n      }\n      /* ((X << 16) & 0xff00) is (X, 0).  */\n      (if ((mask & zerobits) == mask)\n-      { build_int_cst (type, 0); })\n-     (with { newmask = mask | zerobits; }\n-      (if (newmask != mask && (newmask & (newmask + 1)) == 0)\n-       (with\n-\t{\n-\t  /* Only do the transformation if NEWMASK is some integer\n-\t     mode's mask.  */\n-\t  for (prec = BITS_PER_UNIT;\n-\t       prec < HOST_BITS_PER_WIDE_INT; prec <<= 1)\n-\t    if (newmask == (((unsigned HOST_WIDE_INT) 1) << prec) - 1)\n-\t      break;\n-\t}\n-\t(if (prec < HOST_BITS_PER_WIDE_INT\n-\t     || newmask == ~(unsigned HOST_WIDE_INT) 0)\n-\t (with\n-\t  { tree newmaskt = build_int_cst_type (TREE_TYPE (@2), newmask); }\n-\t  (if (!tree_int_cst_equal (newmaskt, @2))\n-\t   (if (shift_type != TREE_TYPE (@3))\n-\t    (bit_and (convert (shift:shift_type (convert @3) @1)) { newmaskt; }))\n-\t   (if (shift_type == TREE_TYPE (@3))\n-\t    (bit_and @4 { newmaskt; }))))))))))))\n+      { build_int_cst (type, 0); }\n+      (with { newmask = mask | zerobits; }\n+       (if (newmask != mask && (newmask & (newmask + 1)) == 0)\n+        (with\n+\t {\n+\t   /* Only do the transformation if NEWMASK is some integer\n+\t      mode's mask.  */\n+\t   for (prec = BITS_PER_UNIT;\n+\t        prec < HOST_BITS_PER_WIDE_INT; prec <<= 1)\n+\t     if (newmask == (((unsigned HOST_WIDE_INT) 1) << prec) - 1)\n+\t       break;\n+\t }\n+\t (if (prec < HOST_BITS_PER_WIDE_INT\n+\t      || newmask == ~(unsigned HOST_WIDE_INT) 0)\n+\t  (with\n+\t   { tree newmaskt = build_int_cst_type (TREE_TYPE (@2), newmask); }\n+\t   (if (!tree_int_cst_equal (newmaskt, @2))\n+\t    (if (shift_type != TREE_TYPE (@3))\n+\t     (bit_and (convert (shift:shift_type (convert @3) @1)) { newmaskt; })\n+\t     (bit_and @4 { newmaskt; })))))))))))))\n \n /* Fold (X & C2) << C1 into (X << C1) & (C2 << C1)\n    (X & C2) >> C1 into (X >> C1) & (C2 >> C1).  */\n@@ -1119,7 +1117,7 @@ along with GCC; see the file COPYING3.  If not see\n \t&& (((inter_int || inter_ptr) && final_int)\n \t    || (inter_float && final_float))\n \t&& inter_prec >= final_prec)\n-    (ocvt @0))\n+    (ocvt @0)\n \n    /* Likewise, if the intermediate and initial types are either both\n       float or both integer, we don't need the middle conversion if the\n@@ -1133,7 +1131,7 @@ along with GCC; see the file COPYING3.  If not see\n \t&& (inter_float || inter_unsignedp == inside_unsignedp)\n \t&& ! (final_prec != GET_MODE_PRECISION (TYPE_MODE (type))\n \t      && TYPE_MODE (type) == TYPE_MODE (inter_type)))\n-    (ocvt @0))\n+    (ocvt @0)\n \n    /* If we have a sign-extension of a zero-extended value, we can\n       replace that by a single zero-extension.  Likewise if the\n@@ -1143,7 +1141,7 @@ along with GCC; see the file COPYING3.  If not see\n \t&& ((inside_prec < inter_prec && inter_prec < final_prec\n \t     && inside_unsignedp && !inter_unsignedp)\n \t    || final_prec == inter_prec))\n-    (ocvt @0))\n+    (ocvt @0)\n \n    /* Two conversions in a row are not needed unless:\n \t- some conversion is floating-point (overstrict for now), or\n@@ -1168,7 +1166,7 @@ along with GCC; see the file COPYING3.  If not see\n \t&& ! (final_ptr && inside_prec != inter_prec)\n \t&& ! (final_prec != GET_MODE_PRECISION (TYPE_MODE (type))\n \t      && TYPE_MODE (type) == TYPE_MODE (inter_type)))\n-    (ocvt @0))\n+    (ocvt @0)\n \n    /* A truncation to an unsigned type (a zero-extension) should be\n       canonicalized as bitwise and of a mask.  */\n@@ -1179,7 +1177,7 @@ along with GCC; see the file COPYING3.  If not see\n     (convert (bit_and @0 { wide_int_to_tree\n \t                     (inside_type,\n \t\t\t      wi::mask (inter_prec, false,\n-\t\t\t\t\tTYPE_PRECISION (inside_type))); })))\n+\t\t\t\t\tTYPE_PRECISION (inside_type))); }))\n \n    /* If we are converting an integer to a floating-point that can\n       represent it exactly and back to an integer, we can skip the\n@@ -1188,7 +1186,7 @@ along with GCC; see the file COPYING3.  If not see\n \t&& inside_int && inter_float && final_int &&\n \t(unsigned) significand_size (TYPE_MODE (inter_type))\n \t>= inside_prec - !inside_unsignedp)\n-    (convert @0))))))\n+    (convert @0)))))))))))\n \n /* If we have a narrowing conversion to an integral type that is fed by a\n    BIT_AND_EXPR, we might be able to remove the BIT_AND_EXPR if it merely\n@@ -1281,20 +1279,17 @@ along with GCC; see the file COPYING3.  If not see\n    genmatch cannot handle.  */\n (simplify\n  (cond INTEGER_CST@0 @1 @2)\n- (if (integer_zerop (@0)\n-      && (!VOID_TYPE_P (TREE_TYPE (@2))\n-\t  || VOID_TYPE_P (type)))\n-  @2)\n- (if (!integer_zerop (@0)\n-      && (!VOID_TYPE_P (TREE_TYPE (@1))\n-\t  || VOID_TYPE_P (type)))\n-  @1))\n+ (if (integer_zerop (@0))\n+  (if (!VOID_TYPE_P (TREE_TYPE (@2)) || VOID_TYPE_P (type))\n+   @2)\n+  (if (!VOID_TYPE_P (TREE_TYPE (@1)) || VOID_TYPE_P (type))\n+   @1)))\n (simplify\n  (vec_cond VECTOR_CST@0 @1 @2)\n  (if (integer_all_onesp (@0))\n-  @1)\n- (if (integer_zerop (@0))\n-  @2))\n+  @1\n+  (if (integer_zerop (@0))\n+   @2)))\n \n (for cnd (cond vec_cond)\n  /* A ? B : (A ? X : C) -> A ? B : C.  */\n@@ -1362,17 +1357,17 @@ along with GCC; see the file COPYING3.  If not see\n    (with { enum tree_code ic = invert_tree_comparison\n              (cmp, HONOR_NANS (@0)); }\n     (if (ic == icmp)\n-     (icmp @0 @1))\n-    (if (ic == ncmp)\n-     (ncmp @0 @1)))))\n+     (icmp @0 @1)\n+     (if (ic == ncmp)\n+      (ncmp @0 @1))))))\n  (simplify\n   (bit_xor (cmp @0 @1) integer_truep)\n   (with { enum tree_code ic = invert_tree_comparison\n             (cmp, HONOR_NANS (@0)); }\n    (if (ic == icmp)\n-    (icmp @0 @1))\n-   (if (ic == ncmp)\n-    (ncmp @0 @1)))))\n+    (icmp @0 @1)\n+    (if (ic == ncmp)\n+     (ncmp @0 @1))))))\n \n /* Transform comparisons of the form X - Y CMP 0 to X CMP Y.\n    ??? The transformation is valid for the other operators if overflow\n@@ -1395,13 +1390,13 @@ along with GCC; see the file COPYING3.  If not see\n   (cmp (mult @0 INTEGER_CST@1) integer_zerop@2)\n   /* Handle unfolded multiplication by zero.  */\n   (if (integer_zerop (@1))\n-   (cmp @1 @2))\n-  (if (ANY_INTEGRAL_TYPE_P (TREE_TYPE (@0))\n-       && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (@0)))\n-   /* If @1 is negative we swap the sense of the comparison.  */\n-   (if (tree_int_cst_sgn (@1) < 0)\n-    (scmp @0 @2))\n-   (cmp @0 @2))))\n+   (cmp @1 @2)\n+   (if (ANY_INTEGRAL_TYPE_P (TREE_TYPE (@0))\n+\t&& TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (@0)))\n+    /* If @1 is negative we swap the sense of the comparison.  */\n+    (if (tree_int_cst_sgn (@1) < 0)\n+     (scmp @0 @2)\n+     (cmp @0 @2))))))\n  \n /* Simplify comparison of something with itself.  For IEEE\n    floating-point, we can only do some of these simplifications.  */\n@@ -1470,11 +1465,11 @@ along with GCC; see the file COPYING3.  If not see\n   /* IEEE doesn't distinguish +0 and -0 in comparisons.  */\n   /* a CMP (-0) -> a CMP 0  */\n   (if (REAL_VALUE_MINUS_ZERO (TREE_REAL_CST (@1)))\n-   (cmp @0 { build_real (TREE_TYPE (@1), dconst0); }))\n+   (cmp @0 { build_real (TREE_TYPE (@1), dconst0); })\n   /* x != NaN is always true, other ops are always false.  */\n   (if (REAL_VALUE_ISNAN (TREE_REAL_CST (@1))\n        && ! HONOR_SNANS (@1))\n-   { constant_boolean_node (cmp == NE_EXPR, type); })\n+   { constant_boolean_node (cmp == NE_EXPR, type); }\n   /* Fold comparisons against infinity.  */\n   (if (REAL_VALUE_ISINF (TREE_REAL_CST (@1))\n        && MODE_HAS_INFINITIES (TYPE_MODE (TREE_TYPE (@1))))\n@@ -1489,37 +1484,37 @@ along with GCC; see the file COPYING3.  If not see\n     /* x > +Inf is always false, if with ignore sNANs.  */\n     (if (code == GT_EXPR\n     \t && ! HONOR_SNANS (@0))\n-     { constant_boolean_node (false, type); })\n+     { constant_boolean_node (false, type); }\n     (if (code == LE_EXPR)\n      /* x <= +Inf is always true, if we don't case about NaNs.  */\n      (if (! HONOR_NANS (@0))\n-      { constant_boolean_node (true, type); })\n-     /* x <= +Inf is the same as x == x, i.e. isfinite(x).  */\n-     (eq @0 @0))\n+      { constant_boolean_node (true, type); }\n+      /* x <= +Inf is the same as x == x, i.e. isfinite(x).  */\n+      (eq @0 @0))\n     /* x == +Inf and x >= +Inf are always equal to x > DBL_MAX.  */\n     (if (code == EQ_EXPR || code == GE_EXPR)\n      (with { real_maxval (&max, neg, TYPE_MODE (TREE_TYPE (@0))); }\n       (if (neg)\n-       (lt @0 { build_real (TREE_TYPE (@0), max); }))\n-      (gt @0 { build_real (TREE_TYPE (@0), max); })))\n+       (lt @0 { build_real (TREE_TYPE (@0), max); })\n+       (gt @0 { build_real (TREE_TYPE (@0), max); })))\n     /* x < +Inf is always equal to x <= DBL_MAX.  */\n     (if (code == LT_EXPR)\n      (with { real_maxval (&max, neg, TYPE_MODE (TREE_TYPE (@0))); }\n       (if (neg)\n-       (ge @0 { build_real (TREE_TYPE (@0), max); }))\n-      (le @0 { build_real (TREE_TYPE (@0), max); })))\n+       (ge @0 { build_real (TREE_TYPE (@0), max); })\n+       (le @0 { build_real (TREE_TYPE (@0), max); })))\n     /* x != +Inf is always equal to !(x > DBL_MAX).  */\n     (if (code == NE_EXPR)\n      (with { real_maxval (&max, neg, TYPE_MODE (TREE_TYPE (@0))); }\n       (if (! HONOR_NANS (@0))\n        (if (neg)\n-        (ge @0 { build_real (TREE_TYPE (@0), max); }))\n-       (le @0 { build_real (TREE_TYPE (@0), max); }))\n-      (if (neg)\n-       (bit_xor (lt @0 { build_real (TREE_TYPE (@0), max); })\n-\t        { build_one_cst (type); }))\n-      (bit_xor (gt @0 { build_real (TREE_TYPE (@0), max); })\n-       { build_one_cst (type); }))))))\n+        (ge @0 { build_real (TREE_TYPE (@0), max); })\n+\t(le @0 { build_real (TREE_TYPE (@0), max); }))\n+       (if (neg)\n+\t(bit_xor (lt @0 { build_real (TREE_TYPE (@0), max); })\n+\t\t\t{ build_one_cst (type); })\n+\t(bit_xor (gt @0 { build_real (TREE_TYPE (@0), max); })\n+\t\t\t{ build_one_cst (type); }))))))))))))))\n \n  /* If this is a comparison of a real constant with a PLUS_EXPR\n     or a MINUS_EXPR of a real constant, we can convert it into a\n@@ -1557,13 +1552,13 @@ along with GCC; see the file COPYING3.  If not see\n     (if (REAL_VALUE_NEGATIVE (TREE_REAL_CST (@1)))\n      /* sqrt(x) < y is always false, if y is negative.  */\n      (if (cmp == EQ_EXPR || cmp == LT_EXPR || cmp == LE_EXPR)\n-      { constant_boolean_node (false, type); })\n+      { constant_boolean_node (false, type); }\n      /* sqrt(x) > y is always true, if y is negative and we\n \tdon't care about NaNs, i.e. negative values of x.  */\n      (if (cmp == NE_EXPR || !HONOR_NANS (@0))\n-      { constant_boolean_node (true, type); })\n+      { constant_boolean_node (true, type); }\n      /* sqrt(x) > y is the same as x >= 0, if y is negative.  */\n-     (ge @0 { build_real (TREE_TYPE (@0), dconst0); }))\n+     (ge @0 { build_real (TREE_TYPE (@0), dconst0); })))\n     (if (cmp == GT_EXPR || cmp == GE_EXPR)\n      (with\n       {\n@@ -1574,10 +1569,10 @@ along with GCC; see the file COPYING3.  If not see\n       (if (REAL_VALUE_ISINF (c2))\n        /* sqrt(x) > y is x == +Inf, when y is very large.  */\n        (if (HONOR_INFINITIES (@0))\n-        (eq @0 { build_real (TREE_TYPE (@0), c2); }))\n-       { constant_boolean_node (false, type); })\n-      /* sqrt(x) > c is the same as x > c*c.  */\n-      (cmp @0 { build_real (TREE_TYPE (@0), c2); })))\n+        (eq @0 { build_real (TREE_TYPE (@0), c2); })\n+\t{ constant_boolean_node (false, type); })\n+       /* sqrt(x) > c is the same as x > c*c.  */\n+       (cmp @0 { build_real (TREE_TYPE (@0), c2); })))\n     (if (cmp == LT_EXPR || cmp == LE_EXPR)\n      (with\n       {\n@@ -1589,30 +1584,30 @@ along with GCC; see the file COPYING3.  If not see\n        /* sqrt(x) < y is always true, when y is a very large\n \t  value and we don't care about NaNs or Infinities.  */\n        (if (! HONOR_NANS (@0) && ! HONOR_INFINITIES (@0))\n-        { constant_boolean_node (true, type); })\n+        { constant_boolean_node (true, type); }\n        /* sqrt(x) < y is x != +Inf when y is very large and we\n \t  don't care about NaNs.  */\n        (if (! HONOR_NANS (@0))\n-        (ne @0 { build_real (TREE_TYPE (@0), c2); }))\n+        (ne @0 { build_real (TREE_TYPE (@0), c2); })\n        /* sqrt(x) < y is x >= 0 when y is very large and we\n \t  don't care about Infinities.  */\n        (if (! HONOR_INFINITIES (@0))\n-        (ge @0 { build_real (TREE_TYPE (@0), dconst0); }))\n+        (ge @0 { build_real (TREE_TYPE (@0), dconst0); })\n        /* sqrt(x) < y is x >= 0 && x != +Inf, when y is large.  */\n        (if (GENERIC)\n         (truth_andif\n \t (ge @0 { build_real (TREE_TYPE (@0), dconst0); })\n-\t (ne @0 { build_real (TREE_TYPE (@0), c2); }))))\n+\t (ne @0 { build_real (TREE_TYPE (@0), c2); }))))))\n       /* sqrt(x) < c is the same as x < c*c, if we ignore NaNs.  */\n       (if (! REAL_VALUE_ISINF (c2)\n            && ! HONOR_NANS (@0))\n-       (cmp @0 { build_real (TREE_TYPE (@0), c2); }))\n+       (cmp @0 { build_real (TREE_TYPE (@0), c2); })\n       /* sqrt(x) < c is the same as x >= 0 && x < c*c.  */\n       (if (! REAL_VALUE_ISINF (c2)\n            && GENERIC)\n        (truth_andif\n         (ge @0 { build_real (TREE_TYPE (@0), dconst0); })\n-\t(cmp @0 { build_real (TREE_TYPE (@0), c2); })))))))))\n+\t(cmp @0 { build_real (TREE_TYPE (@0), c2); })))))))))))))\n \n /* Unordered tests if either argument is a NaN.  */\n (simplify\n@@ -1782,42 +1777,41 @@ along with GCC; see the file COPYING3.  If not see\n \t && types_match (@0, @1)\n \t && types_match (@0, type))\n       (if (TYPE_OVERFLOW_WRAPS (TREE_TYPE (@0)))\n-\t(convert (op @0 @1)))\n-      (with { tree utype = unsigned_type_for (TREE_TYPE (@0)); }\n-\t(convert (op (convert:utype @0) (convert:utype @1)))))))\n+\t(convert (op @0 @1))\n+\t(with { tree utype = unsigned_type_for (TREE_TYPE (@0)); }\n+\t (convert (op (convert:utype @0) (convert:utype @1))))))))\n \n /* This is another case of narrowing, specifically when there's an outer\n    BIT_AND_EXPR which masks off bits outside the type of the innermost\n    operands.   Like the previous case we have to convert the operands\n    to unsigned types to avoid introducing undefined behaviour for the\n    arithmetic operation.  */\n (for op (minus plus)\n-  (simplify\n-    (bit_and (op:s (convert@2 @0) (convert@3 @1)) INTEGER_CST@4)\n-    (if (INTEGRAL_TYPE_P (type)\n-\t /* We check for type compatibility between @0 and @1 below,\n-\t    so there's no need to check that @1/@3 are integral types.  */\n-\t && INTEGRAL_TYPE_P (TREE_TYPE (@0))\n-\t && INTEGRAL_TYPE_P (TREE_TYPE (@2))\n-\t /* The precision of the type of each operand must match the\n-\t    precision of the mode of each operand, similarly for the\n-\t    result.  */\n-\t && (TYPE_PRECISION (TREE_TYPE (@0))\n-\t     == GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (@0))))\n-\t && (TYPE_PRECISION (TREE_TYPE (@1))\n-\t     == GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (@1))))\n-\t && TYPE_PRECISION (type) == GET_MODE_PRECISION (TYPE_MODE (type))\n-\t /* The inner conversion must be a widening conversion.  */\n-\t && TYPE_PRECISION (TREE_TYPE (@2)) > TYPE_PRECISION (TREE_TYPE (@0))\n-\t && types_match (@0, @1)\n-\t && (tree_int_cst_min_precision (@4, TYPE_SIGN (TREE_TYPE (@0)))\n-\t     <= TYPE_PRECISION (TREE_TYPE (@0)))\n-\t && (TYPE_OVERFLOW_WRAPS (TREE_TYPE (@0))\n-\t     || tree_int_cst_sgn (@4) >= 0))\n-      (if (TYPE_OVERFLOW_WRAPS (TREE_TYPE (@0)))\n-\t(with { tree ntype = TREE_TYPE (@0); }\n-\t  (convert (bit_and (op @0 @1) (convert:ntype @4)))))\n-      (with { tree utype = unsigned_type_for (TREE_TYPE (@0)); }\n-\t(convert (bit_and (op (convert:utype @0) (convert:utype @1))\n-\t\t\t  (convert:utype @4)))))))\n-\n+ (simplify\n+  (bit_and (op:s (convert@2 @0) (convert@3 @1)) INTEGER_CST@4)\n+  (if (INTEGRAL_TYPE_P (type)\n+       /* We check for type compatibility between @0 and @1 below,\n+\t  so there's no need to check that @1/@3 are integral types.  */\n+       && INTEGRAL_TYPE_P (TREE_TYPE (@0))\n+       && INTEGRAL_TYPE_P (TREE_TYPE (@2))\n+       /* The precision of the type of each operand must match the\n+\t  precision of the mode of each operand, similarly for the\n+\t  result.  */\n+       && (TYPE_PRECISION (TREE_TYPE (@0))\n+\t   == GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (@0))))\n+       && (TYPE_PRECISION (TREE_TYPE (@1))\n+\t   == GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (@1))))\n+       && TYPE_PRECISION (type) == GET_MODE_PRECISION (TYPE_MODE (type))\n+       /* The inner conversion must be a widening conversion.  */\n+       && TYPE_PRECISION (TREE_TYPE (@2)) > TYPE_PRECISION (TREE_TYPE (@0))\n+       && types_match (@0, @1)\n+       && (tree_int_cst_min_precision (@4, TYPE_SIGN (TREE_TYPE (@0)))\n+\t   <= TYPE_PRECISION (TREE_TYPE (@0)))\n+       && (TYPE_OVERFLOW_WRAPS (TREE_TYPE (@0))\n+\t   || tree_int_cst_sgn (@4) >= 0))\n+   (if (TYPE_OVERFLOW_WRAPS (TREE_TYPE (@0)))\n+    (with { tree ntype = TREE_TYPE (@0); }\n+     (convert (bit_and (op @0 @1) (convert:ntype @4))))\n+    (with { tree utype = unsigned_type_for (TREE_TYPE (@0)); }\n+     (convert (bit_and (op (convert:utype @0) (convert:utype @1))\n+\t       (convert:utype @4))))))))"}]}