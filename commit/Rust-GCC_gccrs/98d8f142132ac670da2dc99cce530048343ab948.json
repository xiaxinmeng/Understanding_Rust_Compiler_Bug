{"sha": "98d8f142132ac670da2dc99cce530048343ab948", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OThkOGYxNDIxMzJhYzY3MGRhMmRjOTljY2U1MzAwNDgzNDNhYjk0OA==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@linux.alibaba.com", "date": "2019-05-08T11:24:38Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2019-05-08T11:24:38Z"}, "message": "re PR tree-optimization/90240 (ICE in try_improve_iv_set, at tree-ssa-loop-ivopts.c:6694)\n\n\tPR tree-optimization/90240\n\t* tree-ssa-loop-ivopts.c (get_scaled_computation_cost_at): Scale cost\n\twith respect to scaling factor pre-computed for each basic block.\n\t(try_improve_iv_set): Return bool if best_cost equals to iv_ca cost.\n\t(find_optimal_iv_set_1): Free iv_ca set if it has infinite_cost.\n\t(COST_SCALING_FACTOR_BOUND, determine_scaling_factor): New.\n\t(tree_ssa_iv_optimize_loop): Call determine_scaling_factor.  Extend\n\tlive range for array of loop's basic blocks.  Cleanup aux field of\n\tloop's basic blocks.\n\n\tgcc/testsuite\n\t* gfortran.dg/graphite/pr90240.f: New test.\n\nFrom-SVN: r271007", "tree": {"sha": "7ad68fb3e9d0d74aec04865d8da07767f3225581", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ad68fb3e9d0d74aec04865d8da07767f3225581"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98d8f142132ac670da2dc99cce530048343ab948", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98d8f142132ac670da2dc99cce530048343ab948", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98d8f142132ac670da2dc99cce530048343ab948", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98d8f142132ac670da2dc99cce530048343ab948/comments", "author": null, "committer": null, "parents": [{"sha": "4f0e90fae97a894247ec93336c8826cf4afb3d0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f0e90fae97a894247ec93336c8826cf4afb3d0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f0e90fae97a894247ec93336c8826cf4afb3d0d"}], "stats": {"total": 128, "additions": 111, "deletions": 17}, "files": [{"sha": "be91d031277a5340e8249d1ee9e8c4291aba80aa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98d8f142132ac670da2dc99cce530048343ab948/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98d8f142132ac670da2dc99cce530048343ab948/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=98d8f142132ac670da2dc99cce530048343ab948", "patch": "@@ -1,3 +1,15 @@\n+2019-05-08  Bin Cheng  <bin.cheng@linux.alibaba.com>\n+\n+\tPR tree-optimization/90240\n+\t* tree-ssa-loop-ivopts.c (get_scaled_computation_cost_at): Scale cost\n+\twith respect to scaling factor pre-computed for each basic block.\n+\t(try_improve_iv_set): Return bool if best_cost equals to iv_ca cost.\n+\t(find_optimal_iv_set_1): Free iv_ca set if it has infinite_cost.\n+\t(COST_SCALING_FACTOR_BOUND, determine_scaling_factor): New.\n+\t(tree_ssa_iv_optimize_loop): Call determine_scaling_factor.  Extend\n+\tlive range for array of loop's basic blocks.  Cleanup aux field of\n+\tloop's basic blocks.\n+\n 2019-05-08  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/90356"}, {"sha": "897a46a2cb3a9927565a13f00ca3f59af3595b0d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98d8f142132ac670da2dc99cce530048343ab948/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98d8f142132ac670da2dc99cce530048343ab948/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=98d8f142132ac670da2dc99cce530048343ab948", "patch": "@@ -1,3 +1,8 @@\n+2018-05-08  Bin Cheng  <bin.cheng@linux.alibaba.com>\n+\n+\tPR tree-optimization/90240\n+\t* gfortran.dg/graphite/pr90240.f: New test.\n+\n 2019-05-08  Li Jia He  <helijia@linux.ibm.com>\n \n \tPR other/90381"}, {"sha": "0873f2124c2423a105a59e2b0beca22902076aa4", "filename": "gcc/testsuite/gfortran.dg/graphite/pr90240.f", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98d8f142132ac670da2dc99cce530048343ab948/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr90240.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98d8f142132ac670da2dc99cce530048343ab948/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr90240.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr90240.f?ref=98d8f142132ac670da2dc99cce530048343ab948", "patch": "@@ -0,0 +1,18 @@\n+! { dg-do compile }\n+! { dg-options \"-O1 -floop-nest-optimize\" }\n+\n+      PARAMETER (n=1335, N2=1335)\n+      COMMON  a(n,N2), b(n,N2), c(n,N2),\n+     *        d(n,N2),\n+     2        e(n,N2), f(n,N2),\n+     *        g(n,N2), h(n,N2)               \n+      DO 200 j=1,i\n+      DO 300 k=1,l\n+      a(k,j) = c(k,j)*g(k,j)*f(k+1,m)+f(k,m)+f(k,j)\n+     2       +f(k+1,j)*h(k+1,j)\n+      b(k,j+1) = d(k,j+1)*g(k,m)+g(k,j+1)\n+     1       *e(k,m)+e(k,j+1)+e(k,j)+e(k+1,j)\n+     2       *h(k,j+1)-h(k,j)\n+  300 ENDDO\n+  200 ENDDO\n+      END"}, {"sha": "534e14638077a582b63b03696e0be3828626b1dd", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 76, "deletions": 17, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98d8f142132ac670da2dc99cce530048343ab948/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98d8f142132ac670da2dc99cce530048343ab948/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=98d8f142132ac670da2dc99cce530048343ab948", "patch": "@@ -4557,22 +4557,25 @@ get_address_cost (struct ivopts_data *data, struct iv_use *use,\n static comp_cost\n get_scaled_computation_cost_at (ivopts_data *data, gimple *at, comp_cost cost)\n {\n-   int loop_freq = data->current_loop->header->count.to_frequency (cfun);\n-   int bb_freq = gimple_bb (at)->count.to_frequency (cfun);\n-   if (loop_freq != 0)\n-     {\n-       gcc_assert (cost.scratch <= cost.cost);\n-       int scaled_cost\n-\t = cost.scratch + (cost.cost - cost.scratch) * bb_freq / loop_freq;\n+  if (data->speed\n+      && data->current_loop->header->count.to_frequency (cfun) > 0)\n+    {\n+      basic_block bb = gimple_bb (at);\n+      gcc_assert (cost.scratch <= cost.cost);\n+      int scale_factor = (int)(intptr_t) bb->aux;\n+      if (scale_factor == 1)\n+\treturn cost;\n \n-       if (dump_file && (dump_flags & TDF_DETAILS))\n-\t fprintf (dump_file, \"Scaling cost based on bb prob \"\n-\t\t  \"by %2.2f: %d (scratch: %d) -> %d (%d/%d)\\n\",\n-\t\t  1.0f * bb_freq / loop_freq, cost.cost,\n-\t\t  cost.scratch, scaled_cost, bb_freq, loop_freq);\n+      int scaled_cost\n+\t= cost.scratch + (cost.cost - cost.scratch) * scale_factor;\n \n-       cost.cost = scaled_cost;\n-     }\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"Scaling cost based on bb prob \"\n+\t\t \"by %2.2f: %d (scratch: %d) -> %d\\n\",\n+\t\t 1.0f * scale_factor, cost.cost, cost.scratch, scaled_cost);\n+\n+      cost.cost = scaled_cost;\n+    }\n \n   return cost;\n }\n@@ -6678,9 +6681,8 @@ try_improve_iv_set (struct ivopts_data *data,\n     }\n \n   iv_ca_delta_commit (data, ivs, best_delta, true);\n-  gcc_assert (best_cost == iv_ca_cost (ivs));\n   iv_ca_delta_free (&best_delta);\n-  return true;\n+  return best_cost == iv_ca_cost (ivs);\n }\n \n /* Attempts to find the optimal set of induction variables.  We do simple\n@@ -6717,6 +6719,14 @@ find_optimal_iv_set_1 (struct ivopts_data *data, bool originalp)\n \t}\n     }\n \n+  /* If the set has infinite_cost, it can't be optimal.  */\n+  if (iv_ca_cost (set).infinite_cost_p ())\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"Overflow to infinite cost in try_improve_iv_set.\\n\");\n+      iv_ca_free (&set);\n+    }\n   return set;\n }\n \n@@ -7522,6 +7532,49 @@ loop_body_includes_call (basic_block *body, unsigned num_nodes)\n   return false;\n }\n \n+/* Determine cost scaling factor for basic blocks in loop.  */\n+#define COST_SCALING_FACTOR_BOUND (20)\n+\n+static void\n+determine_scaling_factor (struct ivopts_data *data, basic_block *body)\n+{\n+  int lfreq = data->current_loop->header->count.to_frequency (cfun);\n+  if (!data->speed || lfreq <= 0)\n+    return;\n+\n+  int max_freq = lfreq;\n+  for (unsigned i = 0; i < data->current_loop->num_nodes; i++)\n+    {\n+      body[i]->aux = (void *)(intptr_t) 1;\n+      if (max_freq < body[i]->count.to_frequency (cfun))\n+\tmax_freq = body[i]->count.to_frequency (cfun);\n+    }\n+  if (max_freq > lfreq)\n+    {\n+      int divisor, factor;\n+      /* Check if scaling factor itself needs to be scaled by the bound.  This\n+\t is to avoid overflow when scaling cost according to profile info.  */\n+      if (max_freq / lfreq > COST_SCALING_FACTOR_BOUND)\n+\t{\n+\t  divisor = max_freq;\n+\t  factor = COST_SCALING_FACTOR_BOUND;\n+\t}\n+      else\n+\t{\n+\t  divisor = lfreq;\n+\t  factor = 1;\n+\t}\n+      for (unsigned i = 0; i < data->current_loop->num_nodes; i++)\n+\t{\n+\t  int bfreq = body[i]->count.to_frequency (cfun);\n+\t  if (bfreq <= lfreq)\n+\t    continue;\n+\n+\t  body[i]->aux = (void*)(intptr_t) (factor * bfreq / divisor);\n+\t}\n+    }\n+}\n+\n /* Optimizes the LOOP.  Returns true if anything changed.  */\n \n static bool\n@@ -7560,7 +7613,6 @@ tree_ssa_iv_optimize_loop (struct ivopts_data *data, struct loop *loop,\n   body = get_loop_body (loop);\n   data->body_includes_call = loop_body_includes_call (body, loop->num_nodes);\n   renumber_gimple_stmt_uids_in_blocks (body, loop->num_nodes);\n-  free (body);\n \n   data->loop_single_exit_p = exit != NULL && loop_only_exit_p (loop, exit);\n \n@@ -7574,6 +7626,9 @@ tree_ssa_iv_optimize_loop (struct ivopts_data *data, struct loop *loop,\n   if (data->vgroups.length () > MAX_CONSIDERED_GROUPS)\n     goto finish;\n \n+  /* Determine cost scaling factor for basic blocks in loop.  */\n+  determine_scaling_factor (data, body);\n+\n   /* Finds candidates for the induction variables (item 2).  */\n   find_iv_candidates (data);\n \n@@ -7584,6 +7639,9 @@ tree_ssa_iv_optimize_loop (struct ivopts_data *data, struct loop *loop,\n \n   /* Find the optimal set of induction variables (item 3, part 2).  */\n   iv_ca = find_optimal_iv_set (data);\n+  /* Cleanup basic block aux field.  */\n+  for (unsigned i = 0; i < data->current_loop->num_nodes; i++)\n+    body[i]->aux = NULL;\n   if (!iv_ca)\n     goto finish;\n   changed = true;\n@@ -7599,6 +7657,7 @@ tree_ssa_iv_optimize_loop (struct ivopts_data *data, struct loop *loop,\n   remove_unused_ivs (data, toremove);\n \n finish:\n+  free (body);\n   free_loop_data (data);\n \n   return changed;"}]}