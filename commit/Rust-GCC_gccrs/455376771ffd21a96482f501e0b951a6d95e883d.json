{"sha": "455376771ffd21a96482f501e0b951a6d95e883d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDU1Mzc2NzcxZmZkMjFhOTY0ODJmNTAxZTBiOTUxYTZkOTVlODgzZA==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-01-22T19:49:02Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-01-22T19:49:02Z"}, "message": "79th Cygnus<->FSF merge\n\nFrom-SVN: r11082", "tree": {"sha": "72df105a5167566b5f363fefcb9ecf25a496676f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/72df105a5167566b5f363fefcb9ecf25a496676f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/455376771ffd21a96482f501e0b951a6d95e883d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/455376771ffd21a96482f501e0b951a6d95e883d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/455376771ffd21a96482f501e0b951a6d95e883d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/455376771ffd21a96482f501e0b951a6d95e883d/comments", "author": null, "committer": null, "parents": [{"sha": "f589b741f98dc838c4ea9296e052b74be7b9e983", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f589b741f98dc838c4ea9296e052b74be7b9e983", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f589b741f98dc838c4ea9296e052b74be7b9e983"}], "stats": {"total": 351, "additions": 236, "deletions": 115}, "files": [{"sha": "a7fe9fed674ce71d30dacff2a0fc9812b57dd609", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 57, "deletions": 3, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455376771ffd21a96482f501e0b951a6d95e883d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455376771ffd21a96482f501e0b951a6d95e883d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=455376771ffd21a96482f501e0b951a6d95e883d", "patch": "@@ -1,3 +1,60 @@\n+Fri Jan 19 18:03:14 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* typeck.c (build_component_ref): Handle getting vbase pointers\n+\tout of complex multiple inheritance better.\n+\n+Fri Jan 19 16:27:40 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* typeck.c (build_object_ref): Make sure we use the real type, not\n+\tany reference type.\n+\n+Fri Jan 19 16:01:47 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* tree.c (build_exception_variant): Don't create new types if we\n+\tdon't have to, also build new types on the right obstack.\n+\n+Fri Jan 19 14:09:44 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl.c (store_bindings): Split out from push_to_top_level.\n+  \t(push_to_top_level): Call it for b->type_shadowed on class binding\n+ \tlevels.\n+\n+Fri Jan 19 13:53:14 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* search.c (expand_upcast_fixups): Fix so that offsets stored in\n+\tvbase_offsets are always right.  Fixes a problem where virtual base\n+\tupcasting and downcasting could be wrong during conversions on this\n+\tduring virtual function dispatch at ctor/dtor time when dynamic\n+\tvtable fixups for deltas are needed.  This only sounds easier than\n+\tit is.  :-)\n+\t(fixup_virtual_upcast_offsets): Change to reflect new calling\n+\tconvention for expand_upcast_fixups.\n+\n+Fri Jan 19 12:23:08 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* decl2.c (grokbitfield): Strip the NOPs from WIDTH before we\n+\tcheck that it's usable as the bitfield width.\n+\n+Wed Jan 17 21:22:40 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* decl2.c (grokfield): Call cplus_decl_attributes with the attrlist.\n+\tPass a null tree to grokdeclarator for its ATTRLIST arg, since it's\n+\tonly ever used for functions in it.\n+\n+Wed Jan 17 12:10:38 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* parse.y (qualified_type_name): Use the TYPE_DECL, not the type.\n+\t(nested_type): Ditto.\n+\t(nested_name_specifier): Use lastiddecl.\n+\n+\t* decl.c (grokdeclarator): Adjust accordingly.\n+\t* init.c (expand_member_init): Ditto.\n+\t* parse.y (base_class): Ditto.\n+\t* typeck2.c (build_functional_cast): Ditto.\n+\n+\t* typeck2.c (build_functional_cast): Fill in name after we've\n+\tchecked for non-aggr type.\n+\n Wed Jan 17 10:18:01 1996  Mike Stump  <mrs@cygnus.com>\n \n \t* decl2.c (warn_pointer_arith): Default to on.\n@@ -53,9 +110,6 @@ Mon Jan 15 16:19:32 1996  Jason Merrill  <jason@yorick.cygnus.com>\n \t* init.c (sort_base_init): Ditto.\n \t(expand_member_init): Ditto.\n \t* init.c (is_aggr_type): New function, like is_aggr_typedef.\n-\t* class.c (pushclass): If !modify and\n- \tCLASSTYPE_LOCAL_TYPEDECLS (type)), do set up IDENTIFIER_TYPE_VALUE\n-\tfor inherited types.\n \n Mon Jan 15 08:45:01 1996  Jeffrey A Law  (law@cygnus.com)\n "}, {"sha": "87dc9c066dd1118ad75d278adbfa15d2ebb0b546", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455376771ffd21a96482f501e0b951a6d95e883d/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455376771ffd21a96482f501e0b951a6d95e883d/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=455376771ffd21a96482f501e0b951a6d95e883d", "patch": "@@ -4416,7 +4416,7 @@ pushclass (type, modify)\n       else if (type != previous_class_type || current_class_depth > 1)\n \t{\n \t  build_mi_matrix (type);\n-\t  push_class_decls (type, !modify);\n+\t  push_class_decls (type);\n \t  free_mi_matrix ();\n \t  if (current_class_depth == 1)\n \t    previous_class_type = type;\n@@ -4453,12 +4453,6 @@ pushclass (type, modify)\n \n       current_function_decl = this_fndecl;\n     }\n-  else if (CLASSTYPE_LOCAL_TYPEDECLS (type))\n-    {\n-      build_mi_matrix (type);\n-      push_class_decls (type, !modify);\n-      free_mi_matrix ();\n-    }\n \n   if (flag_cadillac)\n     cadillac_push_class (type);"}, {"sha": "b4b55b83f704ff3de61e80b345594d9d39c3c2ea", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455376771ffd21a96482f501e0b951a6d95e883d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455376771ffd21a96482f501e0b951a6d95e883d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=455376771ffd21a96482f501e0b951a6d95e883d", "patch": "@@ -2332,7 +2332,7 @@ extern void build_mi_virtuals\t\t\tPROTO((int, int));\n extern void add_mi_virtuals\t\t\tPROTO((int, tree));\n extern void report_ambiguous_mi_virtuals\tPROTO((int, tree));\n extern void note_debug_info_needed\t\tPROTO((tree));\n-extern void push_class_decls\t\t\tPROTO((tree, int));\n+extern void push_class_decls\t\t\tPROTO((tree));\n extern void pop_class_decls\t\t\tPROTO((tree));\n extern void unuse_fields\t\t\tPROTO((tree));\n extern void unmark_finished_struct\t\tPROTO((tree));"}, {"sha": "de18522e2c2e3fcfa22bdd0f8d0189df8cb33c1c", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 82, "deletions": 46, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455376771ffd21a96482f501e0b951a6d95e883d/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455376771ffd21a96482f501e0b951a6d95e883d/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=455376771ffd21a96482f501e0b951a6d95e883d", "patch": "@@ -1832,6 +1832,48 @@ struct saved_scope {\n static struct saved_scope *current_saved_scope;\n extern tree prev_class_type;\n \n+tree\n+store_bindings (names, old_bindings)\n+     tree names, old_bindings;\n+{\n+  tree t;\n+  for (t = names; t; t = TREE_CHAIN (t))\n+    {\n+      tree binding, t1, id;\n+\n+      if (TREE_CODE (t) == TREE_LIST)\n+\tid = TREE_PURPOSE (t);\n+      else\n+\tid = DECL_NAME (t);\n+\n+      if (!id\n+\t  || (!IDENTIFIER_LOCAL_VALUE (id)\n+\t      && !IDENTIFIER_CLASS_VALUE (id)))\n+\tcontinue;\n+\n+      for (t1 = old_bindings; t1; t1 = TREE_CHAIN (t1))\n+\tif (TREE_VEC_ELT (t1, 0) == id)\n+\t  goto skip_it;\n+\t    \n+      binding = make_tree_vec (4);\n+      if (id)\n+\t{\n+\t  my_friendly_assert (TREE_CODE (id) == IDENTIFIER_NODE, 135);\n+\t  TREE_VEC_ELT (binding, 0) = id;\n+\t  TREE_VEC_ELT (binding, 1) = IDENTIFIER_TYPE_VALUE (id);\n+\t  TREE_VEC_ELT (binding, 2) = IDENTIFIER_LOCAL_VALUE (id);\n+\t  TREE_VEC_ELT (binding, 3) = IDENTIFIER_CLASS_VALUE (id);\n+\t  IDENTIFIER_LOCAL_VALUE (id) = NULL_TREE;\n+\t  IDENTIFIER_CLASS_VALUE (id) = NULL_TREE;\n+\t}\n+      TREE_CHAIN (binding) = old_bindings;\n+      old_bindings = binding;\n+    skip_it:\n+      ;\n+    }\n+  return old_bindings;\n+}\n+\n void\n push_to_top_level ()\n {\n@@ -1849,37 +1891,13 @@ push_to_top_level ()\n \n       if (b == global_binding_level)\n \tcontinue;\n-      \n-      for (t = b->names; t; t = TREE_CHAIN (t))\n-\t{\n-\t  tree binding, t1, t2 = t;\n-\t  tree id = DECL_ASSEMBLER_NAME (t2);\n \n-\t  if (!id\n-\t      || (!IDENTIFIER_LOCAL_VALUE (id)\n-\t\t  && !IDENTIFIER_CLASS_VALUE (id)))\n-\t    continue;\n+      old_bindings = store_bindings (b->names, old_bindings);\n+      /* We also need to check type_shadowed to save class-level type\n+\t bindings, since pushclass doesn't fill in b->names.  */\n+      if (b->parm_flag == 2)\n+\told_bindings = store_bindings (b->type_shadowed, old_bindings);\n \n-\t  for (t1 = old_bindings; t1; t1 = TREE_CHAIN (t1))\n-\t    if (TREE_VEC_ELT (t1, 0) == id)\n-\t      goto skip_it;\n-\t    \n-\t  binding = make_tree_vec (4);\n-\t  if (id)\n-\t    {\n-\t      my_friendly_assert (TREE_CODE (id) == IDENTIFIER_NODE, 135);\n-\t      TREE_VEC_ELT (binding, 0) = id;\n-\t      TREE_VEC_ELT (binding, 1) = IDENTIFIER_TYPE_VALUE (id);\n-\t      TREE_VEC_ELT (binding, 2) = IDENTIFIER_LOCAL_VALUE (id);\n-\t      TREE_VEC_ELT (binding, 3) = IDENTIFIER_CLASS_VALUE (id);\n-\t      IDENTIFIER_LOCAL_VALUE (id) = NULL_TREE;\n-\t      IDENTIFIER_CLASS_VALUE (id) = NULL_TREE;\n-\t    }\n-\t  TREE_CHAIN (binding) = old_bindings;\n-\t  old_bindings = binding;\n-\tskip_it:\n-\t  ;\n-\t}\n       /* Unwind type-value slots back to top level.  */\n       for (t = b->type_shadowed; t; t = TREE_CHAIN (t))\n \tSET_IDENTIFIER_TYPE_VALUE (TREE_PURPOSE (t), TREE_VALUE (t));\n@@ -7783,7 +7801,12 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises, attrli\n \t    innermost_code = TREE_CODE (decl);\n \t    if (decl_context == FIELD && ctype == NULL_TREE)\n \t      ctype = current_class_type;\n-\t    if (ctype && TREE_OPERAND (decl, 0) == ctype)\n+\t    if (ctype\n+\t\t&& (TREE_CODE (TREE_OPERAND (decl, 0)) == TYPE_DECL\n+\t\t    && ((DECL_NAME (TREE_OPERAND (decl, 0))\n+\t\t\t == constructor_name_full (ctype))\n+\t\t\t|| (DECL_NAME (TREE_OPERAND (decl, 0))\n+\t\t\t    == constructor_name (ctype)))))\n \t      TREE_OPERAND (decl, 0) = constructor_name (ctype);\n \t    next = &TREE_OPERAND (decl, 0);\n \t    decl = *next;\n@@ -7886,23 +7909,26 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises, attrli\n \t    next = 0;\n \t    break;\n \n+\t  case TYPE_DECL:\n+\t    /* Parse error puts this typespec where\n+\t       a declarator should go.  */\n+\t    cp_error (\"`%T' specified as declarator-id\", DECL_NAME (decl));\n+\t    if (TREE_TYPE (decl) == current_class_type)\n+\t      cp_error (\"  perhaps you want `%T' for a constructor\",\n+\t\t\tcurrent_class_name);\n+\t    dname = DECL_NAME (decl);\n+\t    name = IDENTIFIER_POINTER (dname);\n+\n+\t    /* Avoid giving two errors for this. */\n+\t    IDENTIFIER_CLASS_VALUE (dname) = NULL_TREE;\n+\n+\t    declspecs = temp_tree_cons (NULL_TREE, integer_type_node,\n+\t\t\t\t\tdeclspecs);\n+\t    *next = dname;\n+\t    next = 0;\n+\t    break;\n+\n \t  default:\n-\t    if (TREE_CODE_CLASS (TREE_CODE (decl)) == 't')\n-\t      {\n-\t\t/* Parse error puts this typespec where\n-\t\t   a declarator should go.  */\n-\t\terror (\"typename specified as declarator-id\");\n-\t\tif (current_class_type)\n-\t\t  cp_error (\"  perhaps you want `%T' for a constructor\",\n-\t\t\t    current_class_name);\n-\t\tdname = TYPE_IDENTIFIER (decl);\n-\t\tname = dname ? IDENTIFIER_POINTER (dname) : \"<nameless>\";\n-\t\tdeclspecs = temp_tree_cons (NULL_TREE, integer_type_node,\n-\t\t\t\t\t    declspecs);\n-\t\t*next = dname;\n-\t\tnext = 0;\n-\t\tbreak;\n-\t      }\n \t    cp_compiler_error (\"`%D' as declarator\", decl);\n \t    return 0; /* We used to do a 155 abort here.  */\n \t  }\n@@ -8031,6 +8057,16 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises, attrli\n \t\t}\n \t    }\n \t}\n+      /* C++ aggregate types. */\n+      else if (TREE_CODE (id) == TYPE_DECL)\n+\t{\n+\t  if (type)\n+\t    cp_error (\"multiple declarations `%T' and `%T'\", type,\n+\t\t      TREE_TYPE (id));\n+\t  else\n+\t    type = TREE_TYPE (id);\n+\t  goto found;\n+\t}\n       if (type)\n \terror (\"two or more data types in declaration of `%s'\", name);\n       else if (TREE_CODE (id) == IDENTIFIER_NODE)"}, {"sha": "27f83b0c671f581e48db5a6bfcfc834dffd0dc89", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455376771ffd21a96482f501e0b951a6d95e883d/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455376771ffd21a96482f501e0b951a6d95e883d/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=455376771ffd21a96482f501e0b951a6d95e883d", "patch": "@@ -1362,7 +1362,7 @@ grokfield (declarator, declspecs, raises, init, asmspec_tree, attrlist)\n \tinit = NULL_TREE;\n \n   value = grokdeclarator (declarator, declspecs, FIELD, init != 0,\n-\t\t\t  raises, attrlist);\n+\t\t\t  raises, NULL_TREE);\n   if (! value)\n     return value; /* friend or constructor went bad.  */\n \n@@ -1476,6 +1476,10 @@ grokfield (declarator, declspecs, raises, init, asmspec_tree, attrlist)\n   /* The corresponding pop_obstacks is in cp_finish_decl.  */\n   push_obstacks_nochange ();\n \n+  if (attrlist)\n+    cplus_decl_attributes (value, TREE_PURPOSE (attrlist),\n+\t\t\t   TREE_VALUE (attrlist));\n+\n   if (TREE_CODE (value) == VAR_DECL)\n     {\n       /* We cannot call pushdecl here, because that would\n@@ -1616,6 +1620,9 @@ grokbitfield (declarator, declspecs, width)\n \n   if (width != error_mark_node)\n     {\n+      /* Avoid the non_lvalue wrapper added by fold for PLUS_EXPRs.  */\n+      STRIP_NOPS (width);\n+\n       /* detect invalid field size.  */\n       if (TREE_CODE (width) == CONST_DECL)\n \twidth = DECL_INITIAL (width);"}, {"sha": "d10fb162be31c00dcc0072d644f39cefb253cd6a", "filename": "gcc/cp/init.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455376771ffd21a96482f501e0b951a6d95e883d/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455376771ffd21a96482f501e0b951a6d95e883d/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=455376771ffd21a96482f501e0b951a6d95e883d", "patch": "@@ -930,10 +930,10 @@ expand_member_init (exp, name, init)\n \n   type = TYPE_MAIN_VARIANT (TREE_TYPE (exp));\n \n-  if (TREE_CODE_CLASS (TREE_CODE (name)) == 't')\n+  if (TREE_CODE (name) == TYPE_DECL)\n     {\n-      basetype = name;\n-      name = TYPE_IDENTIFIER (name);\n+      basetype = TREE_TYPE (name);\n+      name = DECL_NAME (name);\n     }\n \n   if (name == NULL_TREE && IS_AGGR_TYPE (type))"}, {"sha": "b3c8edcd985911cb6f53f3d2a453a44657d2006b", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455376771ffd21a96482f501e0b951a6d95e883d/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455376771ffd21a96482f501e0b951a6d95e883d/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=455376771ffd21a96482f501e0b951a6d95e883d", "patch": "@@ -2349,7 +2349,7 @@ base_class_list:\n base_class:\n \t  base_class.1\n \t\t{\n-\t\t  tree type = $1;\n+\t\t  tree type = TREE_TYPE ($1);\n \t\t  if (! is_aggr_type (type, 1))\n \t\t    $$ = NULL_TREE;\n \t\t  else if (current_aggr == signature_type_node\n@@ -2362,19 +2362,19 @@ base_class:\n \t\t    {\n \t\t      sorry (\"signature inheritance, base type `%s' ignored\",\n \t\t\t     IDENTIFIER_POINTER ($$));\n-\t\t      $$ = build_tree_list (access_public_node, $$);\n+\t\t      $$ = build_tree_list (access_public_node, type);\n \t\t    }\n \t\t  else if (type && IS_SIGNATURE (type))\n \t\t    {\n \t\t      error (\"signature name not allowed as base class\");\n \t\t      $$ = NULL_TREE;\n \t\t    }\n \t\t  else\n-\t\t    $$ = build_tree_list (access_default_node, $$);\n+\t\t    $$ = build_tree_list (access_default_node, type);\n \t\t}\n \t| base_class_access_list see_typename base_class.1\n \t\t{\n-\t\t  tree type = $3;\n+\t\t  tree type = TREE_TYPE ($3);\n \t\t  if (current_aggr == signature_type_node)\n \t\t    error (\"access and source specifiers not allowed in signature\");\n \t\t  if (! IS_AGGR_TYPE (type))\n@@ -2389,15 +2389,15 @@ base_class:\n \t\t    {\n \t\t      sorry (\"signature inheritance, base type `%s' ignored\",\n \t\t\t     IDENTIFIER_POINTER ($$));\n-\t\t      $$ = build_tree_list (access_public_node, $3);\n+\t\t      $$ = build_tree_list (access_public_node, type);\n \t\t    }\n \t\t  else if (type && IS_SIGNATURE (type))\n \t\t    {\n \t\t      error (\"signature name not allowed as base class\");\n \t\t      $$ = NULL_TREE;\n \t\t    }\n \t\t  else\n-\t\t    $$ = build_tree_list ($$, $3);\n+\t\t    $$ = build_tree_list ($$, type);\n \t\t}\n \t;\n \n@@ -2857,20 +2857,25 @@ after_type_declarator:\n qualified_type_name:\n \t  type_name %prec EMPTY\n \t\t{\n-\t\t  $$ = TREE_TYPE ($1);\n+\t\t  $$ = identifier_typedecl_value ($1);\n \t\t  /* Remember that this name has been used in the class\n \t\t     definition, as per [class.scope0] */\n \t\t  if (current_class_type\n \t\t      && TYPE_BEING_DEFINED (current_class_type)\n+\t\t      && ! IDENTIFIER_TEMPLATE ($1)\n \t\t      && ! IDENTIFIER_CLASS_VALUE ($1))\n-\t\t    pushdecl_class_level (lookup_name ($1, -2));\n+\t\t    {\n+\t\t      /* Be sure to get an inherited typedef.  */\n+\t\t      $$ = lookup_name ($1, 1);\n+\t\t      pushdecl_class_level ($$);\n+\t\t    }\n \t\t}\n \t| nested_type\n \t;\n \n nested_type:\n \tnested_name_specifier type_name %prec EMPTY\n-\t\t{ $$ = TREE_TYPE ($2); }\n+\t\t{ $$ = identifier_typedecl_value ($2); }\n \t;\n \n direct_after_type_declarator:\n@@ -2984,7 +2989,17 @@ nested_name_specifier:\n    inline here?!?  (jason) */\n nested_name_specifier_1:\n \t  TYPENAME SCOPE\n-\t\t{ got_scope = $$ = TREE_TYPE ($1); }\n+\t\t{\n+\t\t  $$ = lastiddecl;\n+\t\t  /* Remember that this name has been used in the class\n+\t\t     definition, as per [class.scope0] */\n+\t\t  if (current_class_type\n+\t\t      && TYPE_BEING_DEFINED (current_class_type)\n+\t\t      && ! TREE_MANGLED ($1)\n+\t\t      && ! IDENTIFIER_CLASS_VALUE ($1))\n+\t\t    pushdecl_class_level ($$);\n+\t\t  got_scope = $$ = TREE_TYPE ($$);\n+\t\t}\n \t| NSNAME SCOPE\n \t\t{ got_scope = $$ = $1; }\n \t| template_type SCOPE"}, {"sha": "208cc0a2adb146b30866df85bda58e050d04dac4", "filename": "gcc/cp/search.c", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455376771ffd21a96482f501e0b951a6d95e883d/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455376771ffd21a96482f501e0b951a6d95e883d/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=455376771ffd21a96482f501e0b951a6d95e883d", "patch": "@@ -2663,18 +2663,25 @@ virtual_context (fndecl, t, vbase)\n    they may upcast into a direct base, or\n    they may upcast into a different vbase.\n \n-   We only need to do fixups in case 2 and 3.\n+   We only need to do fixups in case 2 and 3.  In case 2, we add in\n+   the virtual base offset to effect an upcast, in case 3, we add in\n+   the virtual base offset to effect an upcast, then subtract out the\n+   offset for the other virtual base, to effect a downcast into it.\n \n    This routine mirrors fixup_vtable_deltas in functionality, though\n    this one is runtime based, and the other is compile time based.\n    Conceivably that routine could be removed entirely, and all fixups\n    done at runtime.\n \n    VBASE_OFFSETS is an association list of virtual bases that contains\n-   offset information, so the offsets are only calculated once.  */\n+   offset information for the virtual bases, so the offsets are only\n+   calculated once.  The offsets are computed by where we think the\n+   vbase should be (as noted by the CLASSTYPE_SEARCH_SLOT) minus where\n+   the vbase really is. */\n static void\n-expand_upcast_fixups (binfo, addr, orig_addr, vbase, t, vbase_offsets)\n-     tree binfo, addr, orig_addr, vbase, t, *vbase_offsets;\n+expand_upcast_fixups (binfo, addr, orig_addr, vbase, vbase_addr, t,\n+\t\t      vbase_offsets)\n+     tree binfo, addr, orig_addr, vbase, vbase_addr, t, *vbase_offsets;\n {\n   tree virtuals = BINFO_VIRTUALS (binfo);\n   tree vc;\n@@ -2685,7 +2692,7 @@ expand_upcast_fixups (binfo, addr, orig_addr, vbase, t, vbase_offsets)\n   if (! delta)\n     {\n       delta = (tree)CLASSTYPE_SEARCH_SLOT (BINFO_TYPE (vbase));\n-      delta = build (MINUS_EXPR, ptrdiff_type_node, delta, addr);\n+      delta = build (MINUS_EXPR, ptrdiff_type_node, delta, vbase_addr);\n       delta = save_expr (delta);\n       delta = tree_cons (vbase, delta, *vbase_offsets);\n       *vbase_offsets = delta;\n@@ -2739,26 +2746,32 @@ expand_upcast_fixups (binfo, addr, orig_addr, vbase, t, vbase_offsets)\n \t  naref = build_array_ref (nvtbl, idx);\n \t  old_delta = build_component_ref (aref, delta_identifier, 0, 0);\n \t  new_delta = build_component_ref (naref, delta_identifier, 0, 0);\n+\n+\t  /* This is a upcast, so we have to add the offset for the\n+\t     virtual base.  */\n \t  old_delta = build_binary_op (PLUS_EXPR, old_delta,\n \t\t\t\t       TREE_VALUE (delta), 0);\n \t  if (vc)\n \t    {\n-\t      /* If this is set, we need to add in delta adjustments for\n-\t\t the other virtual base.  */\n+\t      /* If this is set, we need to subtract out the delta\n+\t\t adjustments for the other virtual base that we\n+\t\t downcast into.  */\n \t      tree vc_delta = purpose_member (vc, *vbase_offsets);\n \t      if (! vc_delta)\n \t\t{\n \t\t  tree vc_addr = convert_pointer_to_real (vc, orig_addr);\n \t\t  vc_delta = (tree)CLASSTYPE_SEARCH_SLOT (BINFO_TYPE (vc));\n \t\t  vc_delta = build (MINUS_EXPR, ptrdiff_type_node,\n-\t\t\t\t    vc_addr, vc_delta);\n+\t\t\t\t    vc_delta, vc_addr);\n \t\t  vc_delta = save_expr (vc_delta);\n \t\t  *vbase_offsets = tree_cons (vc, vc_delta, *vbase_offsets);\n \t\t}\n \t      else\n \t\tvc_delta = TREE_VALUE (vc_delta);\n    \n-\t      old_delta = build_binary_op (PLUS_EXPR, old_delta, vc_delta, 0);\n+\t      /* This is a downcast, so we have to subtract the offset\n+\t\t for the virtual base.  */\n+\t      old_delta = build_binary_op (MINUS_EXPR, old_delta, vc_delta, 0);\n \t    }\n \n \t  TREE_READONLY (new_delta) = 0;\n@@ -2800,8 +2813,9 @@ fixup_virtual_upcast_offsets (real_binfo, binfo, init_self, can_elide, addr, ori\n   /* Should we use something besides CLASSTYPE_VFIELDS? */\n   if (init_self && CLASSTYPE_VFIELDS (BINFO_TYPE (real_binfo)))\n     {\n-      addr = convert_pointer_to_real (binfo, addr);\n-      expand_upcast_fixups (real_binfo, addr, orig_addr, vbase, type, vbase_offsets);\n+      tree new_addr = convert_pointer_to_real (binfo, addr);\n+      expand_upcast_fixups (real_binfo, new_addr, orig_addr, vbase, addr,\n+\t\t\t    type, vbase_offsets);\n     }\n }\n \n@@ -3334,14 +3348,10 @@ dfs_compress_decls (binfo)\n    lattice.  Where ambiguities result, we mark them\n    with `error_mark_node' so that if they are encountered\n    without explicit qualification, we can emit an error\n-   message.\n-\n-   ONLY_TYPES is set when defining TYPE so that inherited types are visible\n-   in the derived class.  */\n+   message.  */\n void\n-push_class_decls (type, only_types)\n+push_class_decls (type)\n      tree type;\n-     int only_types;\n {\n   tree id;\n   struct obstack *ambient_obstack = current_obstack;\n@@ -3396,12 +3406,7 @@ push_class_decls (type, only_types)\n       /* Install the original class value in order to make\n \t pushdecl_class_level work correctly.  */\n       IDENTIFIER_CLASS_VALUE (id) = TREE_VALUE (closed_envelopes);\n-      if (only_types)\n-\t{\n-\t  if (TREE_CODE (new) == TYPE_DECL)\n-\t    set_identifier_type_value (id, TREE_TYPE (new));\n-\t} \n-      else if (TREE_CODE (new) == TREE_LIST)\n+      if (TREE_CODE (new) == TREE_LIST)\n \tpush_class_level_binding (id, new);\n       else\n \tpushdecl_class_level (new);"}, {"sha": "d0f27f953485da9455ae0649d51765cf354178df", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455376771ffd21a96482f501e0b951a6d95e883d/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455376771ffd21a96482f501e0b951a6d95e883d/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=455376771ffd21a96482f501e0b951a6d95e883d", "patch": "@@ -1579,7 +1579,7 @@ build_exception_variant (type, raises)\n   int constp = TYPE_READONLY (type);\n   int volatilep = TYPE_VOLATILE (type);\n \n-  for (v = TYPE_NEXT_VARIANT (v); v; v = TYPE_NEXT_VARIANT (v))\n+  for (; v; v = TYPE_NEXT_VARIANT (v))\n     {\n       if (TYPE_READONLY (v) != constp\n \t  || TYPE_VOLATILE (v) != volatilep)\n@@ -1595,9 +1595,8 @@ build_exception_variant (type, raises)\n     }\n \n   /* Need to build a new variant.  */\n-  v = copy_node (type);\n-  TYPE_NEXT_VARIANT (v) = TYPE_NEXT_VARIANT (type);\n-  TYPE_NEXT_VARIANT (type) = v;\n+  v = build_type_copy (type);\n+\n   if (raises && ! TREE_PERMANENT (raises))\n     {\n       push_obstacks_nochange ();"}, {"sha": "9e5f4e657a59c73adbfbdaef7ed3f81ec071a137", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455376771ffd21a96482f501e0b951a6d95e883d/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455376771ffd21a96482f501e0b951a6d95e883d/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=455376771ffd21a96482f501e0b951a6d95e883d", "patch": "@@ -1539,7 +1539,7 @@ build_object_ref (datum, basetype, field)\n     }\n   else if (is_aggr_type (basetype, 1))\n     {\n-      tree binfo = binfo_or_else (basetype, TREE_TYPE (datum));\n+      tree binfo = binfo_or_else (basetype, dtype);\n       if (binfo)\n \treturn build_component_ref (build_scoped_ref (datum, basetype),\n \t\t\t\t    field, binfo, 1);\n@@ -1825,7 +1825,16 @@ build_component_ref (datum, component, basetype_path, protect)\n \t  error (\"invalid reference to NULL ptr, use ptr-to-member instead\");\n \t  return error_mark_node;\n \t}\n-      addr = convert_pointer_to (DECL_FIELD_CONTEXT (field), addr);\n+      if (VBASE_NAME_P (DECL_NAME (field)))\n+\t  {\n+\t    /* It doesn't matter which vbase pointer we grab, just\n+\t       find one of them.  */\n+\t    tree binfo = get_binfo (DECL_FIELD_CONTEXT (field),\n+\t\t\t\t    TREE_TYPE (TREE_TYPE (addr)), 0);\n+\t    addr = convert_pointer_to_real (binfo, addr);\n+\t  }\n+\telse\n+\t  addr = convert_pointer_to (DECL_FIELD_CONTEXT (field), addr);\n       datum = build_indirect_ref (addr, NULL_PTR);\n       my_friendly_assert (datum != error_mark_node, 311);\n     }\n@@ -5831,7 +5840,7 @@ build_modify_expr (lhs, modifycode, rhs)\n       if (build_default_binary_type_conversion (modifycode, &lhs_tmp, &rhs_tmp))\n \t{\n \t  lhs = stabilize_reference (lhs_tmp);\n-\t  /* Forget is was ever anything else.  */\n+\t  /* Forget it was ever anything else.  */\n \t  olhstype = lhstype = TREE_TYPE (lhs);\n \t  newrhs = build_binary_op (modifycode, lhs, rhs_tmp, 1);\n \t}"}, {"sha": "69d003d916c080fc89f6c338a71e3d7bf3d72c2b", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455376771ffd21a96482f501e0b951a6d95e883d/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455376771ffd21a96482f501e0b951a6d95e883d/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=455376771ffd21a96482f501e0b951a6d95e883d", "patch": "@@ -1440,6 +1440,8 @@ build_functional_cast (exp, parms)\n \t  type = TREE_TYPE (type);\n \t}\n     }\n+  else if (TREE_CODE (exp) == TYPE_DECL)\n+    type = TREE_TYPE (exp);\n   else\n     type = exp;\n \n@@ -1449,20 +1451,6 @@ build_functional_cast (exp, parms)\n       return error_mark_node;\n     }\n \n-  /* Prepare to evaluate as a call to a constructor.  If this expression\n-     is actually used, for example,\n-\t \n-     return X (arg1, arg2, ...);\n-\t \n-     then the slot being initialized will be filled in.  */\n-\n-  if (name == NULL_TREE)\n-    {\n-      name = TYPE_NAME (type);\n-      if (TREE_CODE (name) == TYPE_DECL)\n-\tname = DECL_NESTED_TYPENAME (name);\n-    }\n-\n   if (! IS_AGGR_TYPE (type))\n     {\n       /* this must build a C cast */\n@@ -1478,6 +1466,20 @@ build_functional_cast (exp, parms)\n       return build_c_cast (type, parms, 1);\n     }\n \n+  /* Prepare to evaluate as a call to a constructor.  If this expression\n+     is actually used, for example,\n+\t \n+     return X (arg1, arg2, ...);\n+\t \n+     then the slot being initialized will be filled in.  */\n+\n+  if (name == NULL_TREE)\n+    {\n+      name = TYPE_NAME (type);\n+      if (TREE_CODE (name) == TYPE_DECL)\n+\tname = DECL_NESTED_TYPENAME (name);\n+    }\n+\n   if (TYPE_SIZE (type) == NULL_TREE)\n     {\n       cp_error (\"type `%T' is not yet defined\", type);"}]}