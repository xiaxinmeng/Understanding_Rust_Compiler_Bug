{"sha": "aaa0a838e6a944b0b9ff4a13e08c93a98fb94e97", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWFhMGE4MzhlNmE5NDRiMGI5ZmY0YTEzZTA4YzkzYTk4ZmI5NGU5Nw==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2017-04-27T10:20:36Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-27T10:20:36Z"}, "message": "sem_util.adb, [...] (Build_Class_Wide_Clone_Body): Build body of subprogram that has a class-wide condition that contains calls to...\n\n2017-04-27  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_util.adb, sem_util.ads (Build_Class_Wide_Clone_Body):\n\tBuild body of subprogram that has a class-wide condition that\n\tcontains calls to other primitives.\n\t(Build_Class_Wide_Clone_Call); Build a call to the common\n\tclass-wide clone of a subprogram with classwide conditions. The\n\tbody of the subprogram becomes a wrapper for a call to the\n\tclone. The inherited operation becomes a similar wrapper to which\n\tmodified conditions apply, and the call to the clone includes\n\tthe proper conversion in a call the parent operation.\n\t(Build_Class_Wide_Clone_Decl (Spec_Id : Entity_Id): For a\n\tsubprogram that has a classwide condition that contains calls to\n\tother primitives, build an internal subprogram that is invoked\n\tthrough a type-specific wrapper for all inherited subprograms\n\tthat may have a modified condition.\n\t* sem_prag.adb (Check_References): If subprogram has a classwide\n\tcondition, create entity for corresponding clone, to be invoked\n\tthrough wrapper subprograns.\n\t(Analyze_Pre_Post_Condition_In_Decl_Part): Do not emit error\n\tmessage about placement if pragma isi internally generated.\n\t* sem_ch6.adb (Analyze_Subprogram_Body_Helper): If subprogram has\n\ta classwide clone, build body of clone as copy of original body,\n\tand rewrite original body as a wrapper as a wrapper for a call to\n\tthe clone, so that it incorporates the original pre/postconditions\n\tof the subprogram.\n\t* freeze.adb (Check_Inherited_Conditions): For an inherited\n\tsubprogram that inherits a classwide condition, build spec and\n\tbody of corresponding wrapper so that call to inherited operation\n\tgets the modified conditions.\n\t* contracts.adb (Analyze_Contracts): If analysis of classwide\n\tcondition has created a clone for a primitive operation, analyze\n\tdeclaration of clone.\n\nFrom-SVN: r247313", "tree": {"sha": "8586ee43f539f9cd48e608d19d63392b3a2d09d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8586ee43f539f9cd48e608d19d63392b3a2d09d6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aaa0a838e6a944b0b9ff4a13e08c93a98fb94e97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aaa0a838e6a944b0b9ff4a13e08c93a98fb94e97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aaa0a838e6a944b0b9ff4a13e08c93a98fb94e97", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aaa0a838e6a944b0b9ff4a13e08c93a98fb94e97/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c1025b4e6ff78e8c6358f542661e1ba0dbd03e6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1025b4e6ff78e8c6358f542661e1ba0dbd03e6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1025b4e6ff78e8c6358f542661e1ba0dbd03e6b"}], "stats": {"total": 393, "additions": 324, "deletions": 69}, "files": [{"sha": "354b51a78466d7bf08a2fc54b045910e73a4f0f5", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaa0a838e6a944b0b9ff4a13e08c93a98fb94e97/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaa0a838e6a944b0b9ff4a13e08c93a98fb94e97/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=aaa0a838e6a944b0b9ff4a13e08c93a98fb94e97", "patch": "@@ -1,3 +1,37 @@\n+2017-04-27  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_util.adb, sem_util.ads (Build_Class_Wide_Clone_Body):\n+\tBuild body of subprogram that has a class-wide condition that\n+\tcontains calls to other primitives.\n+\t(Build_Class_Wide_Clone_Call); Build a call to the common\n+\tclass-wide clone of a subprogram with classwide conditions. The\n+\tbody of the subprogram becomes a wrapper for a call to the\n+\tclone. The inherited operation becomes a similar wrapper to which\n+\tmodified conditions apply, and the call to the clone includes\n+\tthe proper conversion in a call the parent operation.\n+\t(Build_Class_Wide_Clone_Decl (Spec_Id : Entity_Id): For a\n+\tsubprogram that has a classwide condition that contains calls to\n+\tother primitives, build an internal subprogram that is invoked\n+\tthrough a type-specific wrapper for all inherited subprograms\n+\tthat may have a modified condition.\n+\t* sem_prag.adb (Check_References): If subprogram has a classwide\n+\tcondition, create entity for corresponding clone, to be invoked\n+\tthrough wrapper subprograns.\n+\t(Analyze_Pre_Post_Condition_In_Decl_Part): Do not emit error\n+\tmessage about placement if pragma isi internally generated.\n+\t* sem_ch6.adb (Analyze_Subprogram_Body_Helper): If subprogram has\n+\ta classwide clone, build body of clone as copy of original body,\n+\tand rewrite original body as a wrapper as a wrapper for a call to\n+\tthe clone, so that it incorporates the original pre/postconditions\n+\tof the subprogram.\n+\t* freeze.adb (Check_Inherited_Conditions): For an inherited\n+\tsubprogram that inherits a classwide condition, build spec and\n+\tbody of corresponding wrapper so that call to inherited operation\n+\tgets the modified conditions.\n+\t* contracts.adb (Analyze_Contracts): If analysis of classwide\n+\tcondition has created a clone for a primitive operation, analyze\n+\tdeclaration of clone.\n+\n 2017-04-27  Steve Baird  <baird@adacore.com>\n \n \t* exp_util.adb (Build_Allocate_Deallocate_Proc):"}, {"sha": "ce61fdc14c0e7b802c4fec2a1818ad174bdd0bee", "filename": "gcc/ada/contracts.adb", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaa0a838e6a944b0b9ff4a13e08c93a98fb94e97/gcc%2Fada%2Fcontracts.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaa0a838e6a944b0b9ff4a13e08c93a98fb94e97/gcc%2Fada%2Fcontracts.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcontracts.adb?ref=aaa0a838e6a944b0b9ff4a13e08c93a98fb94e97", "patch": "@@ -384,9 +384,23 @@ package body Contracts is\n                             N_Generic_Subprogram_Declaration,\n                             N_Subprogram_Declaration)\n          then\n-            Analyze_Entry_Or_Subprogram_Contract\n-              (Subp_Id   => Defining_Entity (Decl),\n-               Freeze_Id => Freeze_Id);\n+            declare\n+               Subp_Id : constant Entity_Id := Defining_Entity (Decl);\n+\n+            begin\n+               Analyze_Entry_Or_Subprogram_Contract (Subp_Id, Freeze_Id);\n+\n+               --  If analysis of a classwide pre/postcondition indicates\n+               --  that a class-wide clone is needed, analyze its declaration\n+               --  now.  Its body is created when the body of the original\n+               --  operation is analyzed (and rewritten).\n+\n+               if Is_Subprogram (Subp_Id)\n+                 and then Present (Class_Wide_Clone (Subp_Id))\n+               then\n+                  Analyze (Unit_Declaration_Node (Class_Wide_Clone (Subp_Id)));\n+               end if;\n+            end;\n \n          --  Entry or subprogram bodies\n "}, {"sha": "1c8f9e6fc48a9e25417c71a3194f3ab4c5710811", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 31, "deletions": 61, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaa0a838e6a944b0b9ff4a13e08c93a98fb94e97/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaa0a838e6a944b0b9ff4a13e08c93a98fb94e97/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=aaa0a838e6a944b0b9ff4a13e08c93a98fb94e97", "patch": "@@ -55,7 +55,6 @@ with Sem_Ch6;   use Sem_Ch6;\n with Sem_Ch7;   use Sem_Ch7;\n with Sem_Ch8;   use Sem_Ch8;\n with Sem_Ch13;  use Sem_Ch13;\n-with Sem_Disp;  use Sem_Disp;\n with Sem_Eval;  use Sem_Eval;\n with Sem_Mech;  use Sem_Mech;\n with Sem_Prag;  use Sem_Prag;\n@@ -1408,7 +1407,6 @@ package body Freeze is\n       New_Prag      : Node_Id;\n       Op_Node       : Elmt_Id;\n       Par_Prim      : Entity_Id;\n-      Par_Type      : Entity_Id;\n       Prim          : Entity_Id;\n \n    begin\n@@ -1459,7 +1457,6 @@ package body Freeze is\n \n          if not Comes_From_Source (Prim) and then Present (Alias (Prim)) then\n             Par_Prim := Alias (Prim);\n-            Par_Type := Find_Dispatching_Type (Par_Prim);\n \n             --  Analyze the contract items of the parent operation, before\n             --  they are rewritten when inherited.\n@@ -1505,80 +1502,53 @@ package body Freeze is\n             --  one, and whose inherited expression has been updated above.\n             --  These expressions are the arguments of pragmas that are part\n             --  of the declarations of the wrapper. The wrapper holds a single\n-            --  statement that is a call to the parent primitive, where the\n+            --  statement that is a call to the class-wide clone, where the\n             --  controlling actuals are conversions to the corresponding type\n             --  in the parent primitive:\n \n-            --    procedure New_Prim (F1 : T1.; ...) is\n-            --       pragma Check (Precondition,  Expr);\n+            --    procedure New_Prim (F1 : T1; ...);\n+            --    procedure New_Prim (F1 : T1; ...) is\n+            --       pragma Check (Precondition, Expr);\n             --    begin\n-            --       Par_Prim (Par_Type (F1) ..);\n+            --       Par_Prim_Clone (Par_Type (F1), ...);\n             --    end;\n \n-            --  If the primitive is a function the statement is a call\n+            --  If the primitive is a function the statement is a return\n+            --  statement with a call.\n \n             declare\n-               Loc        : constant Source_Ptr := Sloc (R);\n-               Actuals    : List_Id;\n-               Call       : Node_Id;\n-               Formal     : Entity_Id;\n-               New_F_Spec : Node_Id;\n-               New_Formal : Entity_Id;\n-               New_Proc   : Node_Id;\n-               New_Spec   : Node_Id;\n+               Loc      : constant Source_Ptr := Sloc (R);\n+               Par_R    : constant Node_Id    := Parent (R);\n+               New_Body : Node_Id;\n+               New_Decl : Node_Id;\n+               New_Spec : Node_Id;\n \n             begin\n-               Actuals    := Empty_List;\n-               New_Spec   := Build_Overriding_Spec (Par_Prim, R);\n-               Formal     := First_Formal (Par_Prim);\n-               New_F_Spec := First (Parameter_Specifications (New_Spec));\n+               New_Spec := Build_Overriding_Spec (Par_Prim, R);\n+               New_Decl :=\n+                 Make_Subprogram_Declaration (Loc,\n+                   Specification => New_Spec);\n \n-               while Present (Formal) loop\n-                  New_Formal := Defining_Identifier (New_F_Spec);\n+               --  Insert the declaration and the body of the wrapper after\n+               --  type declaration that generates inherited operation. For\n+               --  a null procedure, the declaration implies a null body.\n \n-                  --  If controlling argument, add conversion\n-\n-                  if Etype (Formal) = Par_Type then\n-                     Append_To (Actuals,\n-                       Make_Type_Conversion (Loc,\n-                         New_Occurrence_Of (Par_Type, Loc),\n-                         New_Occurrence_Of (New_Formal, Loc)));\n-\n-                  else\n-                     Append_To (Actuals, New_Occurrence_Of (New_Formal, Loc));\n-                  end if;\n-\n-                  Next_Formal (Formal);\n-                  Next (New_F_Spec);\n-               end loop;\n+               if Nkind (New_Spec) = N_Procedure_Specification\n+                 and then Null_Present (New_Spec)\n+               then\n+                  Insert_After_And_Analyze (Par_R, New_Decl);\n \n-               if Ekind (Par_Prim) = E_Procedure then\n-                  Call :=\n-                    Make_Procedure_Call_Statement (Loc,\n-                      Name                   =>\n-                        New_Occurrence_Of (Par_Prim, Loc),\n-                      Parameter_Associations => Actuals);\n                else\n-                  Call :=\n-                    Make_Simple_Return_Statement (Loc,\n-                     Expression =>\n-                       Make_Function_Call (Loc,\n-                         Name                   =>\n-                           New_Occurrence_Of (Par_Prim, Loc),\n-                         Parameter_Associations => Actuals));\n-               end if;\n+                  --  Build body as wrapper to a call to the already built\n+                  --  class-wide clone.\n \n-               New_Proc :=\n-                 Make_Subprogram_Body (Loc,\n-                   Specification              => New_Spec,\n-                   Declarations               => Decls,\n-                   Handled_Statement_Sequence =>\n-                     Make_Handled_Sequence_Of_Statements (Loc,\n-                       Statements => New_List (Call),\n-                       End_Label  => Make_Identifier (Loc, Chars (Prim))));\n+                  New_Body :=\n+                    Build_Class_Wide_Clone_Call\n+                      (Loc, Decls, Par_Prim, New_Spec);\n \n-               Insert_After (Parent (R), New_Proc);\n-               Analyze (New_Proc);\n+                  Insert_List_After_And_Analyze\n+                    (Par_R, New_List (New_Decl, New_Body));\n+               end if;\n             end;\n \n             Needs_Wrapper := False;"}, {"sha": "32384d9e6199dedcd5b185db070e1406805bc514", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaa0a838e6a944b0b9ff4a13e08c93a98fb94e97/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaa0a838e6a944b0b9ff4a13e08c93a98fb94e97/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=aaa0a838e6a944b0b9ff4a13e08c93a98fb94e97", "patch": "@@ -415,7 +415,7 @@ package body Sem_Ch6 is\n          Orig_N := Original_Node (N);\n          Remove_Aspects (Orig_N);\n \n-         --  Propagate any pragmas that apply to the expression function to the\n+         --  Propagate any pragmas that apply to expression function to the\n          --  proper body when the expression function acts as a completion.\n          --  Aspects are automatically transfered because of node rewriting.\n \n@@ -3624,6 +3624,25 @@ package body Sem_Ch6 is\n          end if;\n       end if;\n \n+      --  If the subprogram has a class-wide clone, build its body as a copy\n+      --  of the original body, and rewrite body of original subprogram as a\n+      --  wrapper that calls the clone.\n+\n+      if Present (Spec_Id)\n+        and then Present (Class_Wide_Clone (Spec_Id))\n+        and then (Comes_From_Source (N) or else Was_Expression_Function (N))\n+      then\n+         Build_Class_Wide_Clone_Body (Spec_Id, N);\n+\n+         --  This is the new body for the existing primitive operation\n+\n+         Rewrite (N, Build_Class_Wide_Clone_Call\n+           (Sloc (N), New_List, Spec_Id, Parent (Spec_Id)));\n+         Set_Has_Completion (Spec_Id, False);\n+         Analyze (N);\n+         return;\n+      end if;\n+\n       --  Place subprogram on scope stack, and make formals visible. If there\n       --  is a spec, the visible entity remains that of the spec.\n "}, {"sha": "f9e710db778bfb7ecfb35b7b12538767e7dfd36d", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaa0a838e6a944b0b9ff4a13e08c93a98fb94e97/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaa0a838e6a944b0b9ff4a13e08c93a98fb94e97/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=aaa0a838e6a944b0b9ff4a13e08c93a98fb94e97", "patch": "@@ -4424,6 +4424,14 @@ package body Sem_Prag is\n                end if;\n             end;\n \n+         --  A renaming declaration may inherit a generated pragma, its\n+         --  placement comes from expansion, not from source.\n+\n+         elsif Nkind (Subp_Decl) = N_Subprogram_Renaming_Declaration\n+           and then not Comes_From_Source (N)\n+         then\n+            null;\n+\n          --  Otherwise the placement is illegal\n \n          else\n@@ -23949,6 +23957,9 @@ package body Sem_Prag is\n      (N         : Node_Id;\n       Freeze_Id : Entity_Id := Empty)\n    is\n+      Subp_Decl : constant Node_Id   := Find_Related_Declaration_Or_Body (N);\n+      Spec_Id   : constant Entity_Id := Unique_Defining_Entity (Subp_Decl);\n+\n       Disp_Typ : Entity_Id;\n       --  The dispatching type of the subprogram subject to the pre- or\n       --  postcondition.\n@@ -23995,6 +24006,18 @@ package body Sem_Prag is\n                        (\"operation in class-wide condition must be primitive \"\n                         & \"of &\", Nod, Disp_Typ);\n                   end if;\n+\n+               --  Otherwise we have a call to an overridden primitive, and\n+               --  we will create a common class-wide clone for the body of\n+               --  original operation and its eventual inherited versions.\n+               --  If the original operation dispatches on result it is\n+               --  never inherited and there is no need for a clone.\n+\n+               elsif not Is_Abstract_Subprogram (Spec_Id)\n+                 and then No (Class_Wide_Clone (Spec_Id))\n+                 and then not Has_Controlling_Result (Spec_Id)\n+               then\n+                  Build_Class_Wide_Clone_Decl (Spec_Id);\n                end if;\n             end;\n \n@@ -24027,10 +24050,7 @@ package body Sem_Prag is\n \n       --  Local variables\n \n-      Subp_Decl : constant Node_Id   := Find_Related_Declaration_Or_Body (N);\n-      Spec_Id   : constant Entity_Id := Unique_Defining_Entity (Subp_Decl);\n-      Expr      : constant Node_Id   := Expression (Get_Argument (N, Spec_Id));\n-\n+      Expr     : constant Node_Id := Expression (Get_Argument (N, Spec_Id));\n       Saved_GM : constant Ghost_Mode_Type := Ghost_Mode;\n       --  Save the Ghost mode to restore on exit\n \n@@ -24116,6 +24136,15 @@ package body Sem_Prag is\n          End_Scope;\n       end if;\n \n+      --  If analysis of the condition indicates that a class-wide clone\n+      --  has been created, build and analyze its declaration.\n+\n+      if Is_Subprogram (Spec_Id)\n+        and then Present (Class_Wide_Clone (Spec_Id))\n+      then\n+         Analyze (Unit_Declaration_Node (Class_Wide_Clone (Spec_Id)));\n+      end if;\n+\n       --  Currently it is not possible to inline pre/postconditions on a\n       --  subprogram subject to pragma Inline_Always.\n "}, {"sha": "e158905b0f2d476e5aa358e9fd86ebb02a3baedd", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaa0a838e6a944b0b9ff4a13e08c93a98fb94e97/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaa0a838e6a944b0b9ff4a13e08c93a98fb94e97/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=aaa0a838e6a944b0b9ff4a13e08c93a98fb94e97", "patch": "@@ -1164,6 +1164,141 @@ package body Sem_Util is\n       return Empty;\n    end Build_Actual_Subtype_Of_Component;\n \n+   ---------------------------------\n+   -- Build_Class_Wide_Clone_Body --\n+   ---------------------------------\n+\n+   procedure Build_Class_Wide_Clone_Body\n+     (Spec_Id : Entity_Id;\n+      Bod     : Node_Id)\n+   is\n+      Loc        : constant Source_Ptr := Sloc (Bod);\n+      Clone_Id   : constant Entity_Id  := Class_Wide_Clone (Spec_Id);\n+      Clone_Body : Node_Id;\n+\n+   begin\n+      --  The declaration of the class-wide clone was created when the\n+      --  corresponding class-wide condition was analyzed.\n+\n+      Clone_Body :=\n+        Make_Subprogram_Body (Loc,\n+          Specification              =>\n+            Copy_Subprogram_Spec (Parent (Clone_Id)),\n+          Declarations               => Declarations (Bod),\n+          Handled_Statement_Sequence => Handled_Statement_Sequence (Bod));\n+\n+      --  The new operation is internal and overriding indicators do not apply\n+      --  (the original primitive may have carried one).\n+\n+      Set_Must_Override (Specification (Clone_Body), False);\n+      Insert_Before (Bod, Clone_Body);\n+      Analyze (Clone_Body);\n+   end Build_Class_Wide_Clone_Body;\n+\n+   ---------------------------------\n+   -- Build_Class_Wide_Clone_Call --\n+   ---------------------------------\n+\n+   function Build_Class_Wide_Clone_Call\n+     (Loc     : Source_Ptr;\n+      Decls   : List_Id;\n+      Spec_Id : Entity_Id;\n+      Spec    : Node_Id) return Node_Id\n+   is\n+      Clone_Id : constant Entity_Id := Class_Wide_Clone (Spec_Id);\n+      Par_Type : constant Entity_Id := Find_Dispatching_Type (Spec_Id);\n+\n+      Actuals    : List_Id;\n+      Call       : Node_Id;\n+      Formal     : Entity_Id;\n+      New_Body   : Node_Id;\n+      New_F_Spec : Entity_Id;\n+      New_Formal : Entity_Id;\n+\n+   begin\n+      Actuals    := Empty_List;\n+      Formal     := First_Formal (Spec_Id);\n+      New_F_Spec := First (Parameter_Specifications (Spec));\n+\n+      --  Build parameter association for call to class-wide clone.\n+\n+      while Present (Formal) loop\n+         New_Formal := Defining_Identifier (New_F_Spec);\n+\n+         --  If controlling argument and operation is inherited, add conversion\n+         --  to parent type for the call.\n+\n+         if Etype (Formal) = Par_Type\n+           and then not Is_Empty_List (Decls)\n+         then\n+            Append_To (Actuals,\n+              Make_Type_Conversion (Loc,\n+                New_Occurrence_Of (Par_Type, Loc),\n+                New_Occurrence_Of (New_Formal, Loc)));\n+\n+         else\n+            Append_To (Actuals, New_Occurrence_Of (New_Formal, Loc));\n+         end if;\n+\n+         Next_Formal (Formal);\n+         Next (New_F_Spec);\n+      end loop;\n+\n+      if Ekind (Spec_Id) = E_Procedure then\n+         Call :=\n+           Make_Procedure_Call_Statement (Loc,\n+             Name                   => New_Occurrence_Of (Clone_Id, Loc),\n+             Parameter_Associations => Actuals);\n+      else\n+         Call :=\n+           Make_Simple_Return_Statement (Loc,\n+            Expression =>\n+              Make_Function_Call (Loc,\n+                Name                   => New_Occurrence_Of (Clone_Id, Loc),\n+                Parameter_Associations => Actuals));\n+      end if;\n+\n+      New_Body :=\n+        Make_Subprogram_Body (Loc,\n+          Specification              =>\n+            Copy_Subprogram_Spec (Spec),\n+          Declarations               => Decls,\n+          Handled_Statement_Sequence =>\n+            Make_Handled_Sequence_Of_Statements (Loc,\n+              Statements => New_List (Call),\n+              End_Label  => Make_Identifier (Loc, Chars (Spec_Id))));\n+\n+      return New_Body;\n+   end Build_Class_Wide_Clone_Call;\n+\n+   ---------------------------------\n+   -- Build_Class_Wide_Clone_Decl --\n+   ---------------------------------\n+\n+   procedure Build_Class_Wide_Clone_Decl (Spec_Id : Entity_Id) is\n+      Loc      : constant Source_Ptr := Sloc (Spec_Id);\n+      Clone_Id : constant Entity_Id  :=\n+                   Make_Defining_Identifier (Loc,\n+                     New_External_Name (Chars (Spec_Id), Suffix => \"CL\"));\n+\n+      Decl : Node_Id;\n+      Spec : Node_Id;\n+\n+   begin\n+      Spec := Copy_Subprogram_Spec (Parent (Spec_Id));\n+      Set_Must_Override      (Spec, False);\n+      Set_Must_Not_Override  (Spec, False);\n+      Set_Defining_Unit_Name (Spec, Clone_Id);\n+\n+      Decl := Make_Subprogram_Declaration (Loc, Spec);\n+      Append (Decl, List_Containing (Unit_Declaration_Node (Spec_Id)));\n+\n+      --  Link clone to original subprogram, for use when building body and\n+      --  wrapper call to inherited operation.\n+\n+      Set_Class_Wide_Clone (Spec_Id, Clone_Id);\n+   end Build_Class_Wide_Clone_Decl;\n+\n    -----------------------------\n    -- Build_Component_Subtype --\n    -----------------------------\n@@ -5245,6 +5380,14 @@ package body Sem_Util is\n \n       Result := New_Copy_Tree (Spec);\n \n+      --  However, the spec of a null procedure carries the corresponding null\n+      --  statement of the body (created by the parser), and this cannot be\n+      --  shared with the new subprogram spec.\n+\n+      if Nkind (Result) = N_Procedure_Specification then\n+         Set_Null_Statement (Result, Empty);\n+      end if;\n+\n       --  Create a new entity for the defining unit name\n \n       Def_Id := Defining_Unit_Name (Result);"}, {"sha": "7463ceace83936f29f35083ab788a2120a626b65", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaa0a838e6a944b0b9ff4a13e08c93a98fb94e97/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaa0a838e6a944b0b9ff4a13e08c93a98fb94e97/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=aaa0a838e6a944b0b9ff4a13e08c93a98fb94e97", "patch": "@@ -209,6 +209,52 @@ package Sem_Util is\n    --  Determine whether a selected component has a type that depends on\n    --  discriminants, and build actual subtype for it if so.\n \n+   --  Handling of inherited primitives whose ancestor have class-wide\n+   --  pre/post conditions.\n+\n+   --  If a primitive operation of a parent type has a class-wide pre/post\n+   --  condition that includes calls to other primitives, and that operation\n+   --  is inherited by a descendant type that also overrides some of these\n+   --  other primitives, the condition that applies to the inherited\n+   --  operation has a modified condition in which the overridden primitives\n+   --  have been replaced by the primitives of the descendent type. A call\n+   --  to the inherited operation cannot be simply a call to the parent\n+   --  operation (with an appropriate conversion) as is the case for other\n+   --  inherited operations, but must appear with a wrapper subprogram to which\n+   --  the modified conditions apply. Furthermore the call to the parent\n+   --  operation must not be subject to the original class-wide condition,\n+   --  given that modified conditions apply. To implement these semantics\n+   --  economically we create a subprogram body (a \"class-wide clone\") to\n+   --  which no pre/postconditions apply, and we create bodies for the\n+   --  original and the inherited operation that have their respective\n+   --  pre/post conditions and simply call the clone. The following operations\n+   --  take care of constructing declaration and body of the clone, and\n+   --  building the calls to it within the appropriate wrappers.\n+\n+   procedure Build_Class_Wide_Clone_Body\n+     (Spec_Id  : Entity_Id;\n+      Bod      : Node_Id);\n+   --  Build body of subprogram that has a class-wide condition that contains\n+   --  calls to other primitives. Spec_Id is the Id of the subprogram, and B\n+   --  is its source body, which becomes the body of the clone.\n+\n+   function Build_Class_Wide_Clone_Call\n+    (Loc      : Source_Ptr;\n+     Decls    : List_Id;\n+     Spec_Id  : Entity_Id;\n+     Spec     : Node_Id) return Node_Id;\n+   --  Build a call to the common class-wide clone of a subprogram with\n+   --  class-wide conditions. The body of the subprogram becomes a wrapper\n+   --  for a call to the clone. The inherited operation becomes a similar\n+   --  wrapper to which modified conditions apply, and the call to the\n+   --  clone includes the proper conversion in a call the parent operation.\n+\n+   procedure Build_Class_Wide_Clone_Decl (Spec_Id : Entity_Id);\n+   --  For a subprogram that has a clas-wide condition that contains calls\n+   --  to other primitives, build an internal subprogram that is invoked\n+   --  through a type-specific wrapper for all inherited subprograms that\n+   --  may have a modified condition.\n+\n    function Build_Default_Subtype\n      (T : Entity_Id;\n       N : Node_Id) return Entity_Id;"}]}