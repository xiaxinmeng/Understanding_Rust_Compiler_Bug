{"sha": "91ea6df357db9c986090683aa22cfa1ea2547213", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTFlYTZkZjM1N2RiOWM5ODYwOTA2ODNhYTIyY2ZhMWVhMjU0NzIxMw==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@cs.tamu.edu", "date": "2010-10-27T19:31:33Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2010-10-27T19:31:33Z"}, "message": "parser.c (cp_parser_ctor_initializer_opt_and_function_body): Make sure a constexpr ctor has an empty body.\n\n\t* parser.c (cp_parser_ctor_initializer_opt_and_function_body):\n\tMake sure a constexpr ctor has an empty body.\n\t* class.c (type_has_constexpr_default_constructor): New.\n\t* cp-tree.h: Declare it.\n\t* init.c (perform_member_init): Complain about uninitialized\n\tmember in constexpr ctor.\n\t(emit_mem_initializers): And uninitialized base.\n\t* decl.c (check_tag_decl): Fix typo.\n\n\t* semantics.c (valid_type_in_constexpr_fundecl_p): New fn.\n\t(is_valid_constexpr_fn): New fn.\n\t(validate_constexpr_fundecl): Use it.\n\t* decl.c (validate_constexpr_redeclaration): New.\n\t(duplicate_decls): Use it.\n\t(cp_finish_decl): Call validate_constexpr_fundecl and\n\tensure_literal_type_for_constexpr_object here.\n\t(start_decl): Not here.  Don't ICE on constexpr reference.\n\t(check_for_uninitialized_const_var): Don't handle constexpr specially.\n\t(grokfndecl): Set DECL_DECLARED_CONSTEXPR_P.\n\t(check_static_variable_definition): Give friendly message about\n\tmissing constexpr.\n\t(grokdeclarator): Complain about typedef and volatile with constexpr.\n\tReorganize.  Give sorry about non-static data members in C++0x mode.\n\t(start_preparsed_function): Check validate_constexpr_fundecl here.\n\t(check_function_type): Not here.\n\t* decl2.c (finish_static_data_member_decl): Don't complain about\n\tin-class init.\n\t* parser.c (CP_PARSER_FLAGS_ONLY_TYPE_OR_CONSTEXPR): New.\n\t(cp_parser_condition): Pass it to cp_parser_decl_specifier_seq.\n\t(cp_parser_decl_specifier_seq): Handle it.\n\t(cp_parser_explicit_instantiation): Diagnose inline and constexpr.\n\nCo-Authored-By: Jason Merrill <jason@redhat.com>\n\nFrom-SVN: r166013", "tree": {"sha": "935f90ff364485ab5facda1e86039d079df9a040", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/935f90ff364485ab5facda1e86039d079df9a040"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91ea6df357db9c986090683aa22cfa1ea2547213", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91ea6df357db9c986090683aa22cfa1ea2547213", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91ea6df357db9c986090683aa22cfa1ea2547213", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91ea6df357db9c986090683aa22cfa1ea2547213/comments", "author": null, "committer": null, "parents": [{"sha": "3b49d762b5d6845f6c09926a0a6b2d5e0471a755", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b49d762b5d6845f6c09926a0a6b2d5e0471a755", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b49d762b5d6845f6c09926a0a6b2d5e0471a755"}], "stats": {"total": 502, "additions": 334, "deletions": 168}, "files": [{"sha": "5fe0f17592c735f12a647e1721c4fe77e371b6b6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ea6df357db9c986090683aa22cfa1ea2547213/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ea6df357db9c986090683aa22cfa1ea2547213/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=91ea6df357db9c986090683aa22cfa1ea2547213", "patch": "@@ -1,6 +1,38 @@\n 2010-10-27  Gabriel Dos Reis  <gdr@cse.tamu.edu>\n \t    Jason Merrill  <jason@redhat.com>\n \n+\t* parser.c (cp_parser_ctor_initializer_opt_and_function_body):\n+\tMake sure a constexpr ctor has an empty body.\n+\t* class.c (type_has_constexpr_default_constructor): New.\n+\t* cp-tree.h: Declare it.\n+\t* init.c (perform_member_init): Complain about uninitialized\n+\tmember in constexpr ctor.\n+\t(emit_mem_initializers): And uninitialized base.\n+\t* decl.c (check_tag_decl): Fix typo.\n+\n+\t* semantics.c (valid_type_in_constexpr_fundecl_p): New fn.\n+\t(is_valid_constexpr_fn): New fn.\n+\t(validate_constexpr_fundecl): Use it.\n+\t* decl.c (validate_constexpr_redeclaration): New.\n+\t(duplicate_decls): Use it.\n+\t(cp_finish_decl): Call validate_constexpr_fundecl and\n+\tensure_literal_type_for_constexpr_object here.\n+\t(start_decl): Not here.  Don't ICE on constexpr reference.\n+\t(check_for_uninitialized_const_var): Don't handle constexpr specially.\n+\t(grokfndecl): Set DECL_DECLARED_CONSTEXPR_P.\n+\t(check_static_variable_definition): Give friendly message about\n+\tmissing constexpr.\n+\t(grokdeclarator): Complain about typedef and volatile with constexpr.\n+\tReorganize.  Give sorry about non-static data members in C++0x mode.\n+\t(start_preparsed_function): Check validate_constexpr_fundecl here.\n+\t(check_function_type): Not here.\n+\t* decl2.c (finish_static_data_member_decl): Don't complain about\n+\tin-class init.\n+\t* parser.c (CP_PARSER_FLAGS_ONLY_TYPE_OR_CONSTEXPR): New.\n+\t(cp_parser_condition): Pass it to cp_parser_decl_specifier_seq.\n+\t(cp_parser_decl_specifier_seq): Handle it.\n+\t(cp_parser_explicit_instantiation): Diagnose inline and constexpr.\n+\n \t* class.c (check_bases): Propagate non-literality.\n \t(check_field_decls): Likewise.\n \t(finalize_literal_type_property): New."}, {"sha": "c3e3c53afe689554442f9c47a745d98b85563494", "filename": "gcc/cp/class.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ea6df357db9c986090683aa22cfa1ea2547213/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ea6df357db9c986090683aa22cfa1ea2547213/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=91ea6df357db9c986090683aa22cfa1ea2547213", "patch": "@@ -4325,6 +4325,19 @@ type_has_user_provided_default_constructor (tree t)\n   return false;\n }\n \n+/* Returns true iff class T has a constexpr default constructor.  */\n+\n+bool\n+type_has_constexpr_default_constructor (tree t)\n+{\n+  tree fns;\n+\n+  if (!CLASS_TYPE_P (t))\n+    return false;\n+  fns = get_default_ctor (t);\n+  return (fns && DECL_DECLARED_CONSTEXPR_P (fns));\n+}\n+\n /* Returns true iff class TYPE has a virtual destructor.  */\n \n bool"}, {"sha": "1cd776a3cbf947a3bbe6350cb99f020a18fce853", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ea6df357db9c986090683aa22cfa1ea2547213/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ea6df357db9c986090683aa22cfa1ea2547213/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=91ea6df357db9c986090683aa22cfa1ea2547213", "patch": "@@ -4721,6 +4721,7 @@ extern tree in_class_defaulted_default_constructor (tree);\n extern bool user_provided_p\t\t\t(tree);\n extern bool type_has_user_provided_constructor  (tree);\n extern bool type_has_user_provided_default_constructor (tree);\n+extern bool type_has_constexpr_default_constructor (tree);\n extern bool type_has_virtual_destructor\t\t(tree);\n extern bool type_has_move_constructor\t\t(tree);\n extern bool type_has_move_assign\t\t(tree);"}, {"sha": "8b2af9cde6b065141e4b0c5888600f58bd587afc", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 120, "deletions": 106, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ea6df357db9c986090683aa22cfa1ea2547213/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ea6df357db9c986090683aa22cfa1ea2547213/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=91ea6df357db9c986090683aa22cfa1ea2547213", "patch": "@@ -1128,6 +1128,32 @@ check_redeclaration_exception_specification (tree new_decl,\n     }\n }\n \n+/* Return true if OLD_DECL and NEW_DECL agree on constexprness.\n+   Otherwise issue diagnostics.  */\n+\n+static bool\n+validate_constexpr_redeclaration (tree old_decl, tree new_decl)\n+{\n+  old_decl = STRIP_TEMPLATE (old_decl);\n+  new_decl = STRIP_TEMPLATE (new_decl);\n+  if (!VAR_OR_FUNCTION_DECL_P (old_decl)\n+      || !VAR_OR_FUNCTION_DECL_P (new_decl))\n+    return true;\n+  if (DECL_DECLARED_CONSTEXPR_P (old_decl)\n+      == DECL_DECLARED_CONSTEXPR_P (new_decl))\n+    return true;\n+  if (TREE_CODE (old_decl) == FUNCTION_DECL && DECL_BUILT_IN (old_decl))\n+    {\n+      /* Hide a built-in declaration.  */\n+      DECL_DECLARED_CONSTEXPR_P (old_decl)\n+\t= DECL_DECLARED_CONSTEXPR_P (new_decl);\n+      return true;\n+    }\n+  error (\"redeclaration %qD differs in %<constexpr%>\", new_decl);\n+  error (\"from previous declaration %q+D\", old_decl);\n+  return false;\n+}\n+\n #define GNU_INLINE_P(fn) (DECL_DECLARED_INLINE_P (fn)\t\t\t\\\n \t\t\t  && lookup_attribute (\"gnu_inline\",\t\t\\\n \t\t\t\t\t       DECL_ATTRIBUTES (fn)))\n@@ -1607,6 +1633,9 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n      warn about it.  */\n   warn_extern_redeclared_static (newdecl, olddecl);\n \n+  if (!validate_constexpr_redeclaration (olddecl, newdecl))\n+    return error_mark_node;\n+\n   /* We have committed to returning 1 at this point.  */\n   if (TREE_CODE (newdecl) == FUNCTION_DECL)\n     {\n@@ -4029,7 +4058,7 @@ check_tag_decl (cp_decl_specifier_seq *declspecs)\n       else if (saw_typedef)\n \twarning (0, \"%<typedef%> was ignored in this declaration\");\n       else if (declspecs->specs[(int) ds_constexpr])\n-        error (\"%<constexpr> cannot be used for type declarations\");\n+        error (\"%<constexpr%> cannot be used for type declarations\");\n     }\n \n   return declared_type;\n@@ -4310,9 +4339,6 @@ start_decl (const cp_declarator *declarator,\n \t  && !alias)\n \tpermerror (input_location, \"declaration of %q#D outside of class is not definition\",\n \t\t   decl);\n-\n-      if (!ensure_literal_type_for_constexpr_object (decl))\n-        return error_mark_node;\n     }\n \n   was_public = TREE_PUBLIC (decl);\n@@ -4344,7 +4370,7 @@ start_decl (const cp_declarator *declarator,\n       /* This is a const variable with implicit 'static'.  Set\n \t DECL_THIS_STATIC so we can tell it from variables that are\n \t !TREE_PUBLIC because of the anonymous namespace.  */\n-      gcc_assert (CP_TYPE_CONST_P (TREE_TYPE (decl)));\n+      gcc_assert (CP_TYPE_CONST_P (TREE_TYPE (decl)) || errorcount);\n       DECL_THIS_STATIC (decl) = 1;\n     }\n \n@@ -4753,14 +4779,10 @@ check_for_uninitialized_const_var (tree decl)\n {\n   tree type = strip_array_types (TREE_TYPE (decl));\n \n-  if (TREE_CODE (decl) == VAR_DECL && DECL_DECLARED_CONSTEXPR_P (decl)\n-      && DECL_INITIAL (decl) == NULL)\n-    error (\"missing initializer for constexpr %qD\", decl);\n-\n   /* ``Unless explicitly declared extern, a const object does not have\n      external linkage and must be initialized. ($8.4; $12.1)'' ARM\n      7.1.6 */\n-  else if (TREE_CODE (decl) == VAR_DECL\n+  if (TREE_CODE (decl) == VAR_DECL\n       && TREE_CODE (type) != REFERENCE_TYPE\n       && CP_TYPE_CONST_P (type)\n       && (!TYPE_NEEDS_CONSTRUCTING (type)\n@@ -5691,6 +5713,12 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \t}\n     }\n \n+  if (TREE_CODE (decl) == FUNCTION_DECL)\n+    validate_constexpr_fundecl (decl);\n+\n+  else if (!ensure_literal_type_for_constexpr_object (decl))\n+    DECL_DECLARED_CONSTEXPR_P (decl) = 0;\n+\n   if (init && TREE_CODE (decl) == FUNCTION_DECL)\n     {\n       tree clone;\n@@ -6959,6 +6987,8 @@ grokfndecl (tree ctype,\n   /* If the declaration was declared inline, mark it as such.  */\n   if (inlinep)\n     DECL_DECLARED_INLINE_P (decl) = 1;\n+  if (inlinep & 2)\n+    DECL_DECLARED_CONSTEXPR_P (decl) = true;\n \n   DECL_EXTERNAL (decl) = 1;\n   if (quals && TREE_CODE (type) == FUNCTION_TYPE)\n@@ -7341,6 +7371,21 @@ build_ptrmem_type (tree class_type, tree member_type)\n int\n check_static_variable_definition (tree decl, tree type)\n {\n+  /* If DECL is declared constexpr, we'll do the appropriate checks\n+     in check_initializer.  */\n+  if (DECL_P (decl) && DECL_DECLARED_CONSTEXPR_P (decl))\n+    return 0;\n+  else if (cxx_dialect >= cxx0x && !INTEGRAL_OR_ENUMERATION_TYPE_P (type))\n+    {\n+      if (literal_type_p (type))\n+\terror (\"%<constexpr%> needed for in-class initialization of static \"\n+\t       \"data member %q#D of non-integral type\", decl);\n+      else\n+\terror (\"in-class initialization of static data member %q#D of \"\n+\t       \"non-literal type\", decl);\n+      return 1;\n+    }\n+\n   /* Motion 10 at San Diego: If a static const integral data member is\n      initialized with an integral constant expression, the initializer\n      may appear either in the declaration (within the class), or in\n@@ -7352,10 +7397,6 @@ check_static_variable_definition (tree decl, tree type)\n       error (\"invalid in-class initialization of static data member \"\n \t     \"of non-integral type %qT\",\n \t     type);\n-      /* If we just return the declaration, crashes will sometimes\n-\t occur.  We therefore return void_type_node, as if this were a\n-\t friend declaration, to cause callers to completely ignore\n-\t this declaration.  */\n       return 1;\n     }\n   else if (!CP_TYPE_CONST_P (type))\n@@ -8046,6 +8087,12 @@ grokdeclarator (const cp_declarator *declarator,\n   if (name == NULL)\n     name = decl_context == PARM ? \"parameter\" : \"type name\";\n \n+  if (constexpr_p && declspecs->specs[(int)ds_typedef])\n+    {\n+      error (\"%<constexpr%> cannot appear in a typedef declaration\");\n+      return error_mark_node;\n+    }\n+\n   /* If there were multiple types specified in the decl-specifier-seq,\n      issue an error message.  */\n   if (declspecs->multiple_types_p)\n@@ -8299,17 +8346,6 @@ grokdeclarator (const cp_declarator *declarator,\n   type_quals = TYPE_UNQUALIFIED;\n   if (declspecs->specs[(int)ds_const])\n     type_quals |= TYPE_QUAL_CONST;\n-  /* A `constexpr' specifier used in an object declaration declares\n-     the object as `const'.  */\n-  if (constexpr_p)\n-    {\n-      if (innermost_code == cdk_function)\n-        ;\n-      else if (declspecs->specs[(int)ds_const] != 0)\n-        error (\"both %<const%> and %<constexpr%> cannot be used here\");\n-      else\n-        type_quals |= TYPE_QUAL_CONST;\n-    }\n   if (declspecs->specs[(int)ds_volatile])\n     type_quals |= TYPE_QUAL_VOLATILE;\n   if (declspecs->specs[(int)ds_restrict])\n@@ -8686,21 +8722,6 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t  }\n \t      }\n \n-            /* It is not allowed to use `constexpr' in a function\n-               declaration that is not a definition.\n-               That is too strict, though.  */\n-            if (constexpr_p && !funcdef_flag)\n-              {\n-                error (\"the %<constexpr%> specifier cannot be used in \"\n-                       \"a function declaration that is not a definition\");\n-                constexpr_p = false;\n-              }\n-\n-            /* A constexpr non-static member function is implicitly const.  */\n-            if (constexpr_p && decl_context == FIELD && staticp == 0\n-                && sfk != sfk_constructor && sfk != sfk_destructor)\n-              memfn_quals |= TYPE_QUAL_CONST;\n-\n \t    arg_types = grokparms (declarator->u.function.parameters,\n \t\t\t\t   &parms);\n \n@@ -8878,6 +8899,18 @@ grokdeclarator (const cp_declarator *declarator,\n \t}\n     }\n \n+  /* A `constexpr' specifier used in an object declaration declares\n+     the object as `const'.  */\n+  if (constexpr_p && innermost_code != cdk_function)\n+    {\n+      if (type_quals & TYPE_QUAL_CONST)\n+        error (\"both %<const%> and %<constexpr%> cannot be used here\");\n+      if (type_quals & TYPE_QUAL_VOLATILE)\n+        error (\"both %<volatile%> and %<constexpr%> cannot be used here\");\n+      type_quals |= TYPE_QUAL_CONST;\n+      type = cp_build_qualified_type (type, type_quals);\n+    }\n+\n   if (unqualified_id && TREE_CODE (unqualified_id) == TEMPLATE_ID_EXPR\n       && TREE_CODE (type) != FUNCTION_TYPE\n       && TREE_CODE (type) != METHOD_TYPE)\n@@ -8964,8 +8997,6 @@ grokdeclarator (const cp_declarator *declarator,\n \treturn error_mark_node;\n       else if (TREE_CODE (type) == FUNCTION_TYPE)\n \t{\n-\t  tree sname = declarator->u.id.unqualified_name;\n-\n \t  if (current_class_type\n \t      && (!friendp || funcdef_flag))\n \t    {\n@@ -8975,20 +9006,6 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t     ctype, name, current_class_type);\n \t      return error_mark_node;\n \t    }\n-\n-          /* It is not permitted to define a member function outside ist\n-             membership class as `constexpr'.  */\n-          if (constexpr_p)\n-            error (\"a constexpr function cannot be defined \"\n-                   \"outside of its class\");\n-\n-\t  if (TREE_CODE (sname) == IDENTIFIER_NODE\n-\t      && NEW_DELETE_OPNAME_P (sname))\n-\t    /* Overloaded operator new and operator delete\n-\t       are always static functions.  */\n-\t    ;\n-\t  else\n-\t    type = build_memfn_type (type, ctype, memfn_quals);\n \t}\n       else if (declspecs->specs[(int)ds_typedef]\n \t       && current_class_type)\n@@ -8999,6 +9016,15 @@ grokdeclarator (const cp_declarator *declarator,\n \t}\n     }\n \n+  if (ctype == NULL_TREE && decl_context == FIELD && friendp == 0)\n+    ctype = current_class_type;\n+\n+  /* A constexpr non-static member function is implicitly const.  */\n+  if (constexpr_p && ctype && staticp == 0\n+      && TREE_CODE (type) == FUNCTION_TYPE\n+      && sfk != sfk_constructor && sfk != sfk_destructor)\n+    memfn_quals |= TYPE_QUAL_CONST;\n+\n   /* Now TYPE has the actual type.  */\n \n   if (returned_attrs)\n@@ -9362,6 +9388,10 @@ grokdeclarator (const cp_declarator *declarator,\n \ttype = build_pointer_type (type);\n     }\n \n+  if (ctype && TREE_CODE (type) == FUNCTION_TYPE && staticp < 2\n+      && !NEW_DELETE_OPNAME_P (unqualified_id))\n+    type = build_memfn_type (type, ctype, memfn_quals);\n+\n   {\n     tree decl;\n \n@@ -9395,22 +9425,15 @@ grokdeclarator (const cp_declarator *declarator,\n \t    error (\"invalid use of %<::%>\");\n \t    return error_mark_node;\n \t  }\n-\telse if (TREE_CODE (type) == FUNCTION_TYPE)\n+\telse if (TREE_CODE (type) == FUNCTION_TYPE\n+\t\t || TREE_CODE (type) == METHOD_TYPE)\n \t  {\n \t    int publicp = 0;\n \t    tree function_context;\n \n \t    if (friendp == 0)\n \t      {\n-\t\tif (ctype == NULL_TREE)\n-\t\t  ctype = current_class_type;\n-\n-\t\tif (ctype == NULL_TREE)\n-\t\t  {\n-\t\t    error (\"can't make %qD into a method -- not in a class\",\n-\t\t\t   unqualified_id);\n-\t\t    return error_mark_node;\n-\t\t  }\n+\t\tgcc_assert (ctype);\n \n \t\t/* ``A union may [ ... ] not [ have ] virtual functions.''\n \t\t   ARM 9.5 */\n@@ -9431,8 +9454,6 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t\tvirtualp = 0;\n \t\t      }\n \t\t  }\n-\t\telse if (staticp < 2)\n-\t\t  type = build_memfn_type (type, ctype, memfn_quals);\n \t      }\n \n \t    /* Check that the name used for a destructor makes sense.  */\n@@ -9455,9 +9476,12 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t    return error_mark_node;\n \t\t  }\n                 if (constexpr_p)\n-                  error (\"a destructor cannot be %<constexpr%>\");\n+                  {\n+                    error (\"a destructor cannot be %<constexpr%>\");\n+                    return error_mark_node;\n+                  }\n \t      }\n-\t    else if (sfk == sfk_constructor && friendp)\n+\t    else if (sfk == sfk_constructor && friendp && !ctype)\n \t      {\n \t\terror (\"expected qualified name in friend declaration \"\n \t\t       \"for constructor %qD\",\n@@ -9477,7 +9501,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t\t       unqualified_id,\n \t\t\t       virtualp, flags, memfn_quals, raises,\n \t\t\t       friendp ? -1 : 0, friendp, publicp,\n-                               inlinep || constexpr_p,\n+                               inlinep | (2 * constexpr_p),\n \t\t\t       sfk,\n \t\t\t       funcdef_flag, template_count, in_namespace,\n \t\t\t       attrlist, declarator->id_loc);\n@@ -9499,25 +9523,6 @@ grokdeclarator (const cp_declarator *declarator,\n \t    if (explicitp == 2)\n \t      DECL_NONCONVERTING_P (decl) = 1;\n \t  }\n-\telse if (TREE_CODE (type) == METHOD_TYPE)\n-\t  {\n-\t    /* We only get here for friend declarations of\n-\t       members of other classes.  */\n-\t    /* All method decls are public, so tell grokfndecl to set\n-\t       TREE_PUBLIC, also.  */\n-\t    decl = grokfndecl (ctype, type,\n-\t\t\t       TREE_CODE (unqualified_id) != TEMPLATE_ID_EXPR\n-\t\t\t       ? unqualified_id : dname,\n-\t\t\t       parms,\n-\t\t\t       unqualified_id,\n-\t\t\t       virtualp, flags, memfn_quals, raises,\n-\t\t\t       friendp ? -1 : 0, friendp, 1, 0, sfk,\n-\t\t\t       funcdef_flag, template_count, in_namespace,\n-\t\t\t       attrlist,\n-\t\t\t       declarator->id_loc);\n-\t    if (decl == NULL_TREE)\n-\t      return error_mark_node;\n-\t  }\n \telse if (!staticp && !dependent_type_p (type)\n \t\t && !COMPLETE_TYPE_P (complete_type (type))\n \t\t && (TREE_CODE (type) != ARRAY_TYPE || initialized == 0))\n@@ -9596,15 +9601,25 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t       the rest of the compiler does not correctly\n \t\t       handle the initialization unless the member is\n \t\t       static so we make it static below.  */\n-\t\t    permerror (input_location, \"ISO C++ forbids initialization of member %qD\",\n-\t\t\t       unqualified_id);\n-\t\t    permerror (input_location, \"making %qD static\", unqualified_id);\n-\t\t    staticp = 1;\n+\t\t    if (cxx_dialect >= cxx0x)\n+\t\t      {\n+\t\t\tsorry (\"non-static data member initializers\");\n+\t\t      }\n+\t\t    else\n+\t\t      {\n+\t\t\tpermerror (input_location, \"ISO C++ forbids initialization of member %qD\",\n+\t\t\t\t   unqualified_id);\n+\t\t\tpermerror (input_location, \"making %qD static\", unqualified_id);\n+\t\t\tstaticp = 1;\n+\t\t      }\n \t\t  }\n \n \t\tif (uses_template_parms (type))\n \t\t  /* We'll check at instantiation time.  */\n \t\t  ;\n+\t\telse if (constexpr_p)\n+\t\t  /* constexpr has the same requirements.  */\n+\t\t  ;\n \t\telse if (check_static_variable_definition (unqualified_id,\n \t\t\t\t\t\t\t   type))\n \t\t  /* If we just return the declaration, crashes\n@@ -9714,11 +9729,6 @@ grokdeclarator (const cp_declarator *declarator,\n \t\tsfk = sfk_none;\n \t      }\n \t  }\n-\telse if (TREE_CODE (type) == FUNCTION_TYPE && staticp < 2\n-\t\t && !NEW_DELETE_OPNAME_P (original_name))\n-\t  type = build_method_type_directly (ctype,\n-\t\t\t\t\t     TREE_TYPE (type),\n-\t\t\t\t\t     TYPE_ARG_TYPES (type));\n \n \t/* Record presence of `static'.  */\n \tpublicp = (ctype != NULL_TREE\n@@ -9728,7 +9738,8 @@ grokdeclarator (const cp_declarator *declarator,\n \tdecl = grokfndecl (ctype, type, original_name, parms, unqualified_id,\n \t\t\t   virtualp, flags, memfn_quals, raises,\n \t\t\t   1, friendp,\n-\t\t\t   publicp, inlinep || constexpr_p, sfk, funcdef_flag,\n+\t\t\t   publicp, inlinep | (2 * constexpr_p), sfk,\n+                           funcdef_flag,\n \t\t\t   template_count, in_namespace, attrlist,\n \t\t\t   declarator->id_loc);\n \tif (decl == NULL_TREE)\n@@ -9797,6 +9808,9 @@ grokdeclarator (const cp_declarator *declarator,\n \t\tstorage_class = sc_none;\n \t      }\n \t  }\n+\telse if (constexpr_p && DECL_EXTERNAL (decl))\n+\t  error (\"declaration of constexpr variable %qD is not a definition\",\n+\t\t decl);\n       }\n \n     if (storage_class == sc_extern && initialized && !funcdef_flag)\n@@ -9826,8 +9840,8 @@ grokdeclarator (const cp_declarator *declarator,\n       DECL_THIS_STATIC (decl) = 1;\n \n     /* Don't forget constexprness.  */\n-    if (VAR_OR_FUNCTION_DECL_P (decl))\n-      DECL_DECLARED_CONSTEXPR_P (decl) = constexpr_p;\n+    if (constexpr_p)\n+      DECL_DECLARED_CONSTEXPR_P (decl) = true;\n \n     /* Record constancy and volatility on the DECL itself .  There's\n        no need to do this when processing a template; we'll do this\n@@ -11863,10 +11877,6 @@ check_function_type (tree decl, tree current_function_parms)\n   /* In a function definition, arg types must be complete.  */\n   require_complete_types_for_parms (current_function_parms);\n \n-  /* constexpr functions must have literal argument types and\n-     literal return type.  */\n-  validate_constexpr_fundecl (decl);\n-\n   if (dependent_type_p (return_type))\n     return;\n   if (!COMPLETE_OR_VOID_TYPE_P (return_type)\n@@ -12126,6 +12136,10 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n \tmaybe_apply_pragma_weak (decl1);\n     }\n \n+  /* constexpr functions must have literal argument types and\n+     literal return type.  */\n+  validate_constexpr_fundecl (decl1);\n+\n   /* Reset this in case the call to pushdecl changed it.  */\n   current_function_decl = decl1;\n "}, {"sha": "13fa5f698903d98c09136d94be0538a4d10d4fb2", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ea6df357db9c986090683aa22cfa1ea2547213/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ea6df357db9c986090683aa22cfa1ea2547213/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=91ea6df357db9c986090683aa22cfa1ea2547213", "patch": "@@ -771,21 +771,6 @@ finish_static_data_member_decl (tree decl,\n     permerror (input_location, \"local class %q#T shall not have static data member %q#D\",\n \t       current_class_type, decl);\n \n-  /* Static consts need not be initialized in the class definition.  */\n-  if (init != NULL_TREE && TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (decl)))\n-    {\n-      static int explained = 0;\n-\n-      error (\"initializer invalid for static member with constructor\");\n-      if (!explained)\n-\t{\n-\t  error (\"(an out of class initialization is required)\");\n-\t  explained = 1;\n-\t}\n-      init = NULL_TREE;\n-    }\n-\n-  DECL_INITIAL (decl) = init;\n   DECL_IN_AGGR_P (decl) = 1;\n \n   if (TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE"}, {"sha": "3a6e2e7f4ebd2e55953623cf4ab519b09ce537c8", "filename": "gcc/cp/init.c", "status": "modified", "additions": 33, "deletions": 11, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ea6df357db9c986090683aa22cfa1ea2547213/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ea6df357db9c986090683aa22cfa1ea2547213/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=91ea6df357db9c986090683aa22cfa1ea2547213", "patch": "@@ -533,6 +533,15 @@ perform_member_init (tree member, tree init)\n \t\t       \"uninitialized member %qD with %<const%> type %qT\",\n \t\t       member, type);\n \n+\t  if (DECL_DECLARED_CONSTEXPR_P (current_function_decl)\n+\t      && !type_has_constexpr_default_constructor (type))\n+\t    {\n+\t      if (!DECL_TEMPLATE_INSTANTIATION (current_function_decl))\n+\t\terror (\"uninitialized member %qD in %<constexpr%> constructor\",\n+\t\t       member);\n+\t      DECL_DECLARED_CONSTEXPR_P (current_function_decl) = false;\n+\t    }\n+\n \t  core_type = strip_array_types (type);\n \t  if (CLASS_TYPE_P (core_type)\n \t      && (CLASSTYPE_READONLY_FIELDS_NEED_INIT (core_type)\n@@ -864,17 +873,30 @@ emit_mem_initializers (tree mem_inits)\n       tree subobject = TREE_PURPOSE (mem_inits);\n       tree arguments = TREE_VALUE (mem_inits);\n \n-      /* If these initializations are taking place in a copy constructor,\n-\t the base class should probably be explicitly initialized if there\n-\t is a user-defined constructor in the base class (other than the\n-\t default constructor, which will be called anyway).  */\n-      if (extra_warnings && !arguments\n-\t  && DECL_COPY_CONSTRUCTOR_P (current_function_decl)\n-\t  && type_has_user_nondefault_constructor (BINFO_TYPE (subobject)))\n-\twarning_at (DECL_SOURCE_LOCATION (current_function_decl), OPT_Wextra,\n-\t\t    \"base class %q#T should be explicitly initialized in the \"\n-\t\t    \"copy constructor\",\n-\t\t    BINFO_TYPE (subobject));\n+      if (arguments == NULL_TREE)\n+\t{\n+\t  /* If these initializations are taking place in a copy constructor,\n+\t     the base class should probably be explicitly initialized if there\n+\t     is a user-defined constructor in the base class (other than the\n+\t     default constructor, which will be called anyway).  */\n+\t  if (extra_warnings\n+\t      && DECL_COPY_CONSTRUCTOR_P (current_function_decl)\n+\t      && type_has_user_nondefault_constructor (BINFO_TYPE (subobject)))\n+\t    warning_at (DECL_SOURCE_LOCATION (current_function_decl),\n+\t\t\tOPT_Wextra, \"base class %q#T should be explicitly \"\n+\t\t\t\"initialized in the copy constructor\",\n+\t\t\tBINFO_TYPE (subobject));\n+\n+\t  if (DECL_DECLARED_CONSTEXPR_P (current_function_decl)\n+\t      && !(type_has_constexpr_default_constructor\n+\t\t   (BINFO_TYPE (subobject))))\n+\t    {\n+\t      if (!DECL_TEMPLATE_INSTANTIATION (current_function_decl))\n+\t\terror (\"uninitialized base %qT in %<constexpr%> constructor\",\n+\t\t       BINFO_TYPE (subobject));\n+\t      DECL_DECLARED_CONSTEXPR_P (current_function_decl) = false;\n+\t    }\n+\t}\n \n       /* Initialize the base.  */\n       if (BINFO_VIRTUAL_P (subobject))"}, {"sha": "0d28345034cc98aa885ffffe886b8ad6bb54bc2a", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 50, "deletions": 5, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ea6df357db9c986090683aa22cfa1ea2547213/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ea6df357db9c986090683aa22cfa1ea2547213/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=91ea6df357db9c986090683aa22cfa1ea2547213", "patch": "@@ -1334,7 +1334,10 @@ enum\n   CP_PARSER_FLAGS_NO_USER_DEFINED_TYPES = 0x2,\n   /* When parsing a type-specifier, do not try to parse a class-specifier\n      or enum-specifier.  */\n-  CP_PARSER_FLAGS_NO_TYPE_DEFINITIONS = 0x4\n+  CP_PARSER_FLAGS_NO_TYPE_DEFINITIONS = 0x4,\n+  /* When parsing a decl-specifier-seq, only allow type-specifier or\n+     constexpr.  */\n+  CP_PARSER_FLAGS_ONLY_TYPE_OR_CONSTEXPR = 0x8\n };\n \n /* This type is used for parameters and variables which hold\n@@ -8509,6 +8512,7 @@ cp_parser_condition (cp_parser* parser)\n {\n   cp_decl_specifier_seq type_specifiers;\n   const char *saved_message;\n+  int declares_class_or_enum;\n \n   /* Try the declaration first.  */\n   cp_parser_parse_tentatively (parser);\n@@ -8518,9 +8522,10 @@ cp_parser_condition (cp_parser* parser)\n   parser->type_definition_forbidden_message\n     = G_(\"types may not be defined in conditions\");\n   /* Parse the type-specifier-seq.  */\n-  cp_parser_type_specifier_seq (parser, /*is_declaration==*/true,\n-\t\t\t\t/*is_trailing_return=*/false,\n-\t\t\t\t&type_specifiers);\n+  cp_parser_decl_specifier_seq (parser,\n+\t\t\t\tCP_PARSER_FLAGS_ONLY_TYPE_OR_CONSTEXPR,\n+\t\t\t\t&type_specifiers,\n+\t\t\t\t&declares_class_or_enum);\n   /* Restore the saved message.  */\n   parser->type_definition_forbidden_message = saved_message;\n   /* If all is well, we might be looking at a declaration.  */\n@@ -9851,6 +9856,11 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n \t  break;\n \t}\n \n+      if (found_decl_spec\n+\t  && (flags & CP_PARSER_FLAGS_ONLY_TYPE_OR_CONSTEXPR)\n+\t  && token->keyword != RID_CONSTEXPR)\n+\terror (\"decl-specifier invalid in condition\");\n+\n       /* Constructors are a special case.  The `S' in `S()' is not a\n \t decl-specifier; it is the beginning of the declarator.  */\n       constructor_p\n@@ -12231,6 +12241,13 @@ cp_parser_explicit_instantiation (cp_parser* parser)\n \t\t\t\t\t\t       decl_specifiers.type_location);\n       if (declarator != cp_error_declarator)\n \t{\n+\t  if (decl_specifiers.specs[(int)ds_inline])\n+\t    permerror (input_location, \"explicit instantiation shall not use\"\n+\t\t       \" %<inline%> specifier\");\n+\t  if (decl_specifiers.specs[(int)ds_constexpr])\n+\t    permerror (input_location, \"explicit instantiation shall not use\"\n+\t\t       \" %<constexpr%> specifier\");\n+\n \t  decl = grokdeclarator (declarator, &decl_specifiers,\n \t\t\t\t NORMAL, 0, &decl_specifiers.attributes);\n \t  /* Turn access control back on for names used during\n@@ -16245,15 +16262,43 @@ cp_parser_function_body (cp_parser *parser)\n static bool\n cp_parser_ctor_initializer_opt_and_function_body (cp_parser *parser)\n {\n-  tree body;\n+  tree body, list;\n   bool ctor_initializer_p;\n+  const bool check_body_p =\n+     DECL_CONSTRUCTOR_P (current_function_decl)\n+     && DECL_DECLARED_CONSTEXPR_P (current_function_decl);\n+  tree last = NULL;\n \n   /* Begin the function body.  */\n   body = begin_function_body ();\n   /* Parse the optional ctor-initializer.  */\n   ctor_initializer_p = cp_parser_ctor_initializer_opt (parser);\n+\n+  /* If we're parsing a constexpr constructor definition, we need\n+     to check that the constructor body is indeed empty.  However,\n+     before we get to cp_parser_function_body lot of junk has been\n+     generated, so we can't just check that we have an empty block.\n+     Rather we take a snapshot of the outermost block, and check whether\n+     cp_parser_function_body changed its state.  */\n+  if (check_body_p)\n+    {\n+      list = body;\n+      if (TREE_CODE (list) == BIND_EXPR)\n+\tlist = BIND_EXPR_BODY (list);\n+      if (TREE_CODE (list) == STATEMENT_LIST\n+\t  && STATEMENT_LIST_TAIL (list) != NULL)\n+\tlast = STATEMENT_LIST_TAIL (list)->stmt;\n+    }\n   /* Parse the function-body.  */\n   cp_parser_function_body (parser);\n+  if (check_body_p\n+      && (TREE_CODE (list) != STATEMENT_LIST\n+\t  || (last == NULL && STATEMENT_LIST_TAIL (list) != NULL)\n+\t  || (last != NULL && last != STATEMENT_LIST_TAIL (list)->stmt)))\n+    {\n+      error (\"constexpr constructor does not have empty body\");\n+      DECL_DECLARED_CONSTEXPR_P (current_function_decl) = false;\n+    }\n   /* Finish the function body.  */\n   finish_function_body (body);\n "}, {"sha": "0ca8c339088517a22ce1ac3dcaf929a8b6200d60", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 59, "deletions": 31, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ea6df357db9c986090683aa22cfa1ea2547213/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ea6df357db9c986090683aa22cfa1ea2547213/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=91ea6df357db9c986090683aa22cfa1ea2547213", "patch": "@@ -5277,6 +5277,59 @@ ensure_literal_type_for_constexpr_object (tree decl)\n   return decl;\n }\n \n+/* Return true if type expression T is a valid parameter type, or\n+   a valid return type, of a constexpr function.  */\n+\n+static bool\n+valid_type_in_constexpr_fundecl_p (tree t)\n+{\n+  return (literal_type_p (t)\n+\t  /* FIXME we allow ref to non-literal; should change standard to\n+\t     match, or change back if not.  */\n+\t  || TREE_CODE (t) == REFERENCE_TYPE);\n+}\n+\n+/* Check whether the parameter and return types of FUN are valid for a\n+   constexpr function, and complain if COMPLAIN.  */\n+\n+static bool\n+is_valid_constexpr_fn (tree fun, bool complain)\n+{\n+  tree parm = FUNCTION_FIRST_USER_PARM (fun);\n+  bool ret = true;\n+  for (; parm != NULL; parm = TREE_CHAIN (parm))\n+    if (!valid_type_in_constexpr_fundecl_p (TREE_TYPE (parm)))\n+      {\n+\tret = false;\n+\tif (complain)\n+\t  error (\"invalid type for parameter %q#D of constexpr function\",\n+\t\t parm);\n+      }\n+\n+  if (!DECL_CONSTRUCTOR_P (fun))\n+    {\n+      tree rettype = TREE_TYPE (TREE_TYPE (fun));\n+      if (!valid_type_in_constexpr_fundecl_p (rettype))\n+\t{\n+\t  ret = false;\n+\t  if (complain)\n+\t    error (\"invalid return type %qT of constexpr function %qD\",\n+\t\t   rettype, fun);\n+\t}\n+\n+      if (DECL_NONSTATIC_MEMBER_FUNCTION_P (fun)\n+\t  && COMPLETE_TYPE_P (DECL_CONTEXT (fun))\n+\t  && !valid_type_in_constexpr_fundecl_p (DECL_CONTEXT (fun)))\n+\t{\n+\t  ret = false;\n+\t  if (complain)\n+\t    error (\"enclosing class of %q#D is not a literal type\", fun);\n+\t}\n+    }\n+\n+  return ret;\n+}\n+\n /* Return non-null if FUN certainly designates a valid constexpr function\n    declaration.  Otherwise return NULL.  Issue appropriate diagnostics\n    if necessary.  Note that we only check the declaration, not the body\n@@ -5285,43 +5338,18 @@ ensure_literal_type_for_constexpr_object (tree decl)\n tree\n validate_constexpr_fundecl (tree fun)\n {\n-  tree rettype = NULL;\n-  tree parm = NULL;\n-\n-  /* Don't bother if FUN is not marked constexpr.  */\n-  if (!DECL_DECLARED_CONSTEXPR_P (fun))\n-    return NULL;\n-\n-  /* For a function template, we have absolutely no guarantee that all\n-     instantiations will be constexpr.  */\n-  if (TREE_CODE (fun) == TEMPLATE_DECL)\n+  if (processing_template_decl || !DECL_DECLARED_CONSTEXPR_P (fun))\n     return NULL;\n-  \n-  parm = FUNCTION_FIRST_USER_PARM (fun);\n-  for (; parm != NULL; parm = TREE_CHAIN (parm))\n-    {\n-      tree type = TREE_TYPE (parm);\n-      if (dependent_type_p (type))\n-        return NULL;\n-      if (!literal_type_p (type))\n-        {\n-           error (\"parameter %q#D is not of literal type\", parm);\n-          return NULL;\n-        }\n-    }\n-\n-  if (DECL_CONSTRUCTOR_P (fun))\n+  else if (DECL_CLONED_FUNCTION_P (fun))\n+    /* We already checked the original function.  */\n     return fun;\n \n-  rettype = TREE_TYPE (TREE_TYPE (fun));\n-  if (dependent_type_p (rettype))\n-    return NULL;\n-  if (!literal_type_p (rettype))\n+  if (!is_valid_constexpr_fn (fun, !DECL_TEMPLATE_INSTANTIATION (fun)))\n     {\n-      error (\"return type %qT of function %qD is not a literal type\",\n-             TREE_TYPE (TREE_TYPE (fun)), fun);\n+      DECL_DECLARED_CONSTEXPR_P (fun) = false;\n       return NULL;\n     }\n+\n   return fun;\n }\n "}, {"sha": "ddf0da0b9b4bc96aed8d0ff90af50eb40e336acf", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-auto.C", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ea6df357db9c986090683aa22cfa1ea2547213/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-auto.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ea6df357db9c986090683aa22cfa1ea2547213/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-auto.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-auto.C?ref=91ea6df357db9c986090683aa22cfa1ea2547213", "patch": "@@ -0,0 +1,2 @@\n+// { dg-options -std=c++0x }\n+constexpr auto value = 0;"}, {"sha": "e2328fcc578ada8d901c52b97a73fa74dc01c23d", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-condition.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ea6df357db9c986090683aa22cfa1ea2547213/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-condition.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ea6df357db9c986090683aa22cfa1ea2547213/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-condition.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-condition.C?ref=91ea6df357db9c986090683aa22cfa1ea2547213", "patch": "@@ -0,0 +1,9 @@\n+// { dg-options -std=c++0x }\n+// Core DR 948\n+\n+constexpr int something() { return 3; }\n+\n+int main() {\n+  if (constexpr long v = something()) {}\n+  if (static long v = something()) { } // { dg-error \"decl-specifier invalid\" }\n+}"}, {"sha": "91c489db230d4316a79d0e87e912ccecc96bd114", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-ctor.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ea6df357db9c986090683aa22cfa1ea2547213/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ctor.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ea6df357db9c986090683aa22cfa1ea2547213/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ctor.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ctor.C?ref=91ea6df357db9c986090683aa22cfa1ea2547213", "patch": "@@ -0,0 +1,7 @@\n+// { dg-options -std=c++0x }\n+\n+struct A\n+{\n+  int i;\n+  constexpr A() { }\t\t// { dg-error \"uninitialized member .A::i\" }\n+};"}, {"sha": "20898736983286144540fea5944b76c904feb1b8", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-expinst.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ea6df357db9c986090683aa22cfa1ea2547213/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-expinst.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ea6df357db9c986090683aa22cfa1ea2547213/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-expinst.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-expinst.C?ref=91ea6df357db9c986090683aa22cfa1ea2547213", "patch": "@@ -0,0 +1,5 @@\n+// { dg-options -std=c++0x }\n+// Error: Explicit instantiation of a function template shall not use the\n+// inline or constexpr specifiers\n+template<class T> constexpr inline T bar(T x) { return x; }\n+template constexpr inline float bar(float x); // { dg-error \"specifier\" }"}, {"sha": "35643b990c101bb4e10dc3c706150657e6783cb3", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-ice2.C", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ea6df357db9c986090683aa22cfa1ea2547213/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ice2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ea6df357db9c986090683aa22cfa1ea2547213/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ice2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ice2.C?ref=91ea6df357db9c986090683aa22cfa1ea2547213", "patch": "@@ -0,0 +1,3 @@\n+// { dg-options -std=c++0x }\n+int x;\n+constexpr int& rx = x; // { dg-error \"int&\" }"}]}