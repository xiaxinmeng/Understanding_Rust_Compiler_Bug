{"sha": "e2e95f45a8324f5aeacdc191217359f747fc2c26", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTJlOTVmNDVhODMyNGY1YWVhY2RjMTkxMjE3MzU5Zjc0N2ZjMmMyNg==", "commit": {"author": {"name": "Revital Eres", "email": "eres@il.ibm.com", "date": "2007-10-31T17:04:42Z"}, "committer": {"name": "Revital Eres", "email": "revitale@gcc.gnu.org", "date": "2007-10-31T17:04:42Z"}, "message": "Enable auto-vectorization for PowerPC 750CL paired-single instructions\n\nFrom-SVN: r129803", "tree": {"sha": "ffcd2f0cd6e20a0379266c1ddc17953d9734dcc9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ffcd2f0cd6e20a0379266c1ddc17953d9734dcc9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e2e95f45a8324f5aeacdc191217359f747fc2c26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2e95f45a8324f5aeacdc191217359f747fc2c26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2e95f45a8324f5aeacdc191217359f747fc2c26", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2e95f45a8324f5aeacdc191217359f747fc2c26/comments", "author": {"login": "revit13", "id": 16211463, "node_id": "MDQ6VXNlcjE2MjExNDYz", "avatar_url": "https://avatars.githubusercontent.com/u/16211463?v=4", "gravatar_id": "", "url": "https://api.github.com/users/revit13", "html_url": "https://github.com/revit13", "followers_url": "https://api.github.com/users/revit13/followers", "following_url": "https://api.github.com/users/revit13/following{/other_user}", "gists_url": "https://api.github.com/users/revit13/gists{/gist_id}", "starred_url": "https://api.github.com/users/revit13/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/revit13/subscriptions", "organizations_url": "https://api.github.com/users/revit13/orgs", "repos_url": "https://api.github.com/users/revit13/repos", "events_url": "https://api.github.com/users/revit13/events{/privacy}", "received_events_url": "https://api.github.com/users/revit13/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1e4c40729a2606b0b3cd7993d9f6faac7ca1506b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e4c40729a2606b0b3cd7993d9f6faac7ca1506b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e4c40729a2606b0b3cd7993d9f6faac7ca1506b"}], "stats": {"total": 626, "additions": 614, "deletions": 12}, "files": [{"sha": "75cc8da6d0fb7d26f9a8fa37520d4df52c21c2ea", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2e95f45a8324f5aeacdc191217359f747fc2c26/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2e95f45a8324f5aeacdc191217359f747fc2c26/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e2e95f45a8324f5aeacdc191217359f747fc2c26", "patch": "@@ -1,3 +1,19 @@\n+2007-10-31  Revital Eres  <eres@il.ibm.com>\n+\n+\t* config/rs6000/paired.md (sminv2sf3, smaxv2sf3, reduc_smax_v2sf,\n+\treduc_smin_v2sf vec_interleave_highv2sf, vec_interleave_lowv2sf,\n+\tvec_extract_evenv2sf, vec_extract_oddv2sf, reduc_splus_v2sf,\n+\tmovmisalignv2sf, vcondv2sf): New.\n+\t(UNSPEC_INTERHI_V2SF, UNSPEC_INTERLO_V2SF, UNSPEC_EXTEVEN_V2SF,\n+\tUNSPEC_EXTODD_V2SF): Define new constants.\n+\t* config/rs6000/rs6000-protos.h (paired_expand_vector_move,\n+\tpaired_emit_vector_cond_expr): New.\n+\t* config/rs6000/rs6000-c.c (__PAIRED__): Add new builtin_define.\n+\t* config/rs6000/rs6000.c (paired_expand_vector_move,\n+\tpaired_emit_vector_cond_expr, paired_emit_vector_compare):\n+\tNew functions.\n+\t* config/rs6000/750cl.h (ASM_CPU_SPEC): Pass down -m750cl option.\n+\n 2007-10-31  Sebastian Pop  <sebastian.pop@amd.com>\n \n \tPR tree-optimization/32377"}, {"sha": "b88a1942685f6340feb8804dfcaf457642f5e163", "filename": "gcc/config/rs6000/750cl.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2e95f45a8324f5aeacdc191217359f747fc2c26/gcc%2Fconfig%2Frs6000%2F750cl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2e95f45a8324f5aeacdc191217359f747fc2c26/gcc%2Fconfig%2Frs6000%2F750cl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2F750cl.h?ref=e2e95f45a8324f5aeacdc191217359f747fc2c26", "patch": "@@ -21,3 +21,6 @@\n #undef TARGET_PAIRED_FLOAT\n #define TARGET_PAIRED_FLOAT rs6000_paired_float\n \n+#undef ASM_CPU_SPEC \n+#define ASM_CPU_SPEC \"-m750cl\"\n+"}, {"sha": "4e41359d014001de0b7407ea8925576ea05d8ef7", "filename": "gcc/config/rs6000/paired.md", "status": "modified", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2e95f45a8324f5aeacdc191217359f747fc2c26/gcc%2Fconfig%2Frs6000%2Fpaired.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2e95f45a8324f5aeacdc191217359f747fc2c26/gcc%2Fconfig%2Frs6000%2Fpaired.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpaired.md?ref=e2e95f45a8324f5aeacdc191217359f747fc2c26", "patch": "@@ -21,6 +21,12 @@\n ;; Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n ;; MA 02110-1301, USA.\n \n+(define_constants\n+[(UNSPEC_INTERHI_V2SF     330)\n+ (UNSPEC_INTERLO_V2SF     331)\n+ (UNSPEC_EXTEVEN_V2SF     332)\n+ (UNSPEC_EXTODD_V2SF      333)\n+])\n \n (define_insn \"negv2sf2\"\n   [(set (match_operand:V2SF 0 \"gpc_reg_operand\" \"=f\")\n@@ -370,3 +376,145 @@\n   \"ps_merge00 %0, %1, %2\"\n   [(set_attr \"type\" \"fp\")])\n \n+(define_expand \"sminv2sf3\"\n+  [(set (match_operand:V2SF 0 \"gpc_reg_operand\" \"=f\")\n+        (smin:V2SF (match_operand:V2SF 1 \"gpc_reg_operand\" \"f\")\n+                   (match_operand:V2SF 2 \"gpc_reg_operand\" \"f\")))]\n+  \"TARGET_PAIRED_FLOAT\"\n+{\n+  rtx tmp = gen_reg_rtx (V2SFmode);\n+\n+  emit_insn (gen_subv2sf3 (tmp, operands[1], operands[2]));\n+  emit_insn (gen_selv2sf4 (operands[0], tmp, operands[2], operands[1], CONST0_RTX (SFmode)));\n+  DONE;\n+})\n+\n+(define_expand \"smaxv2sf3\"\n+  [(set (match_operand:V2SF 0 \"gpc_reg_operand\" \"=f\")\n+        (smax:V2SF (match_operand:V2SF 1 \"gpc_reg_operand\" \"f\")\n+                   (match_operand:V2SF 2 \"gpc_reg_operand\" \"f\")))]\n+  \"TARGET_PAIRED_FLOAT\"\n+{\n+  rtx tmp = gen_reg_rtx (V2SFmode);\n+\n+  emit_insn (gen_subv2sf3 (tmp, operands[1], operands[2]));\n+  emit_insn (gen_selv2sf4 (operands[0], tmp, operands[1], operands[2], CONST0_RTX (SFmode)));\n+  DONE;\n+})\n+\n+(define_expand \"reduc_smax_v2sf\"\n+  [(match_operand:V2SF 0 \"gpc_reg_operand\" \"=f\")\n+   (match_operand:V2SF 1 \"gpc_reg_operand\" \"f\")]\n+  \"TARGET_PAIRED_FLOAT\"\n+{\n+  rtx tmp_swap = gen_reg_rtx (V2SFmode);\n+  rtx tmp = gen_reg_rtx (V2SFmode);\n+\n+  emit_insn (gen_paired_merge10 (tmp_swap, operands[1], operands[1]));\n+  emit_insn (gen_subv2sf3 (tmp, operands[1], tmp_swap));\n+  emit_insn (gen_selv2sf4 (operands[0], tmp, operands[1], tmp_swap, CONST0_RTX (SFmode)));\n+\n+  DONE;\n+})\n+\n+(define_expand \"reduc_smin_v2sf\"\n+  [(match_operand:V2SF 0 \"gpc_reg_operand\" \"=f\")\n+   (match_operand:V2SF 1 \"gpc_reg_operand\" \"f\")]\n+  \"TARGET_PAIRED_FLOAT\"\n+{\n+  rtx tmp_swap = gen_reg_rtx (V2SFmode);\n+  rtx tmp = gen_reg_rtx (V2SFmode);\n+\n+  emit_insn (gen_paired_merge10 (tmp_swap, operands[1], operands[1]));\n+  emit_insn (gen_subv2sf3 (tmp, operands[1], tmp_swap));\n+  emit_insn (gen_selv2sf4 (operands[0], tmp, tmp_swap, operands[1], CONST0_RTX (SFmode)));\n+\n+  DONE;\n+})\n+\n+(define_expand \"vec_interleave_highv2sf\"\n+ [(set (match_operand:V2SF 0 \"gpc_reg_operand\" \"=f\")\n+        (unspec:V2SF [(match_operand:V2SF 1 \"gpc_reg_operand\" \"f\")\n+                      (match_operand:V2SF 2 \"gpc_reg_operand\" \"f\")]\n+                      UNSPEC_INTERHI_V2SF))]\n+  \"TARGET_PAIRED_FLOAT\"\n+  \"\n+{\n+  emit_insn (gen_paired_merge00 (operands[0], operands[1], operands[2]));\n+  DONE;\n+}\")\n+\n+(define_expand \"vec_interleave_lowv2sf\"\n+ [(set (match_operand:V2SF 0 \"gpc_reg_operand\" \"=f\")\n+        (unspec:V2SF [(match_operand:V2SF 1 \"gpc_reg_operand\" \"f\")\n+                      (match_operand:V2SF 2 \"gpc_reg_operand\" \"f\")]\n+                      UNSPEC_INTERLO_V2SF))]\n+  \"TARGET_PAIRED_FLOAT\"\n+  \"\n+{\n+  emit_insn (gen_paired_merge11 (operands[0], operands[1], operands[2]));\n+  DONE;\n+}\")\n+\n+(define_expand \"vec_extract_evenv2sf\"\n+ [(set (match_operand:V2SF 0 \"gpc_reg_operand\" \"=f\")\n+        (unspec:V2SF [(match_operand:V2SF 1 \"gpc_reg_operand\" \"f\")\n+                      (match_operand:V2SF 2 \"gpc_reg_operand\" \"f\")]\n+                      UNSPEC_EXTEVEN_V2SF))]\n+  \"TARGET_PAIRED_FLOAT\"\n+  \"\n+{\n+  emit_insn (gen_paired_merge00 (operands[0], operands[1], operands[2]));\n+  DONE;\n+}\")\n+\n+(define_expand \"vec_extract_oddv2sf\"\n+ [(set (match_operand:V2SF 0 \"gpc_reg_operand\" \"=f\")\n+        (unspec:V2SF [(match_operand:V2SF 1 \"gpc_reg_operand\" \"f\")\n+                      (match_operand:V2SF 2 \"gpc_reg_operand\" \"f\")]\n+                      UNSPEC_EXTODD_V2SF))]\n+  \"TARGET_PAIRED_FLOAT\"\n+  \"\n+{\n+  emit_insn (gen_paired_merge11 (operands[0], operands[1], operands[2]));\n+  DONE;\n+}\")\n+\n+\n+(define_expand \"reduc_splus_v2sf\"\n+  [(set (match_operand:V2SF 0 \"gpc_reg_operand\" \"=f\")\n+        (match_operand:V2SF 1 \"gpc_reg_operand\" \"f\"))]\n+  \"TARGET_PAIRED_FLOAT\"\n+  \"\n+{\n+  emit_insn (gen_paired_sum1 (operands[0], operands[1], operands[1], operands[1]));\n+  DONE;\n+}\")\n+\n+(define_expand \"movmisalignv2sf\"\n+  [(set (match_operand:V2SF 0 \"gpc_reg_operand\" \"=f\")\n+        (match_operand:V2SF 1 \"gpc_reg_operand\" \"f\"))]\n+  \"TARGET_PAIRED_FLOAT\"\n+{\n+  paired_expand_vector_move (operands);\n+  DONE;\n+})\n+\n+(define_expand \"vcondv2sf\"\n+  [(set (match_operand:V2SF 0 \"gpc_reg_operand\" \"=f\")\n+        (if_then_else:V2SF\n+         (match_operator 3 \"gpc_reg_operand\"\n+                         [(match_operand:V2SF 4 \"gpc_reg_operand\" \"f\")\n+                          (match_operand:V2SF 5 \"gpc_reg_operand\" \"f\")])\n+         (match_operand:V2SF 1 \"gpc_reg_operand\" \"f\")\n+         (match_operand:V2SF 2 \"gpc_reg_operand\" \"f\")))]\n+  \"TARGET_PAIRED_FLOAT && flag_unsafe_math_optimizations\"\n+  \"\n+{\n+        if (paired_emit_vector_cond_expr (operands[0], operands[1], operands[2],\n+                                          operands[3], operands[4], operands[5]))\n+        DONE;\n+        else\n+        FAIL;\n+}\")\n+"}, {"sha": "336eceef7b2ea0bcc60cdff82baf320657a8d9d0", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2e95f45a8324f5aeacdc191217359f747fc2c26/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2e95f45a8324f5aeacdc191217359f747fc2c26/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=e2e95f45a8324f5aeacdc191217359f747fc2c26", "patch": "@@ -123,6 +123,8 @@ rs6000_cpu_cpp_builtins (cpp_reader *pfile)\n     }\n   if (TARGET_SPE)\n     builtin_define (\"__SPE__\");\n+  if (TARGET_PAIRED_FLOAT)\n+    builtin_define (\"__PAIRED__\");\n   if (TARGET_SOFT_FLOAT)\n     builtin_define (\"_SOFT_FLOAT\");\n   if (!(TARGET_HARD_FLOAT && (TARGET_FPRS || TARGET_E500_DOUBLE)))"}, {"sha": "56bb376a77d4bb3459b86cc22b10e1ca40791b0f", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2e95f45a8324f5aeacdc191217359f747fc2c26/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2e95f45a8324f5aeacdc191217359f747fc2c26/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=e2e95f45a8324f5aeacdc191217359f747fc2c26", "patch": "@@ -65,6 +65,12 @@ extern int mems_ok_for_quad_peep (rtx, rtx);\n extern bool gpr_or_gpr_p (rtx, rtx);\n extern enum reg_class rs6000_secondary_reload_class (enum reg_class,\n \t\t\t\t\t\t     enum machine_mode, rtx);\n+\n+extern int paired_emit_vector_cond_expr (rtx, rtx, rtx,\n+                                         rtx, rtx, rtx);\n+extern void paired_expand_vector_move (rtx operands[]);\n+\n+\n extern int ccr_bit (rtx, int);\n extern int extract_MB (rtx);\n extern int extract_ME (rtx);"}, {"sha": "3dc6c15ad569bf88d47ccf91cfe97316b3a91b26", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2e95f45a8324f5aeacdc191217359f747fc2c26/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2e95f45a8324f5aeacdc191217359f747fc2c26/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=e2e95f45a8324f5aeacdc191217359f747fc2c26", "patch": "@@ -2773,6 +2773,103 @@ paired_expand_vector_init (rtx target, rtx vals)\n   emit_move_insn (target, new);\n }\n \n+void\n+paired_expand_vector_move (rtx operands[])\n+{\n+  rtx op0 = operands[0], op1 = operands[1];\n+\n+  emit_move_insn (op0, op1);\n+}\n+\n+/* Emit vector compare for code RCODE.  DEST is destination, OP1 and\n+   OP2 are two VEC_COND_EXPR operands, CC_OP0 and CC_OP1 are the two\n+   operands for the relation operation COND.  This is a recursive\n+   function.  */\n+\n+static void\n+paired_emit_vector_compare (enum rtx_code rcode,\n+                            rtx dest, rtx op0, rtx op1,\n+                            rtx cc_op0, rtx cc_op1)\n+{\n+  rtx tmp = gen_reg_rtx (V2SFmode);\n+  rtx tmp1, max, min, equal_zero;\n+\n+  gcc_assert (TARGET_PAIRED_FLOAT);\n+  gcc_assert (GET_MODE (op0) == GET_MODE (op1));\n+\n+  switch (rcode)\n+    {\n+    case LT:\n+    case LTU:\n+      paired_emit_vector_compare (GE, dest, op1, op0, cc_op0, cc_op1);\n+      return;\n+    case GE:\n+    case GEU:\n+      emit_insn (gen_subv2sf3 (tmp, cc_op0, cc_op1));\n+      emit_insn (gen_selv2sf4 (dest, tmp, op0, op1, CONST0_RTX (SFmode)));\n+      return;\n+    case LE:\n+    case LEU:\n+      paired_emit_vector_compare (GE, dest, op0, op1, cc_op1, cc_op0);\n+      return;\n+    case GT:\n+      paired_emit_vector_compare (LE, dest, op1, op0, cc_op0, cc_op1);\n+      return;\n+    case EQ:\n+      tmp1 = gen_reg_rtx (V2SFmode);\n+      max = gen_reg_rtx (V2SFmode);\n+      min = gen_reg_rtx (V2SFmode);\n+      equal_zero = gen_reg_rtx (V2SFmode);\n+\n+      emit_insn (gen_subv2sf3 (tmp, cc_op0, cc_op1));\n+      emit_insn (gen_selv2sf4\n+                 (max, tmp, cc_op0, cc_op1, CONST0_RTX (SFmode)));\n+      emit_insn (gen_subv2sf3 (tmp, cc_op1, cc_op0));\n+      emit_insn (gen_selv2sf4\n+                 (min, tmp, cc_op0, cc_op1, CONST0_RTX (SFmode)));\n+      emit_insn (gen_subv2sf3 (tmp1, min, max));\n+      emit_insn (gen_selv2sf4 (dest, tmp1, op0, op1, CONST0_RTX (SFmode)));\n+      return;\n+    case NE:\n+      paired_emit_vector_compare (EQ, dest, op1, op0, cc_op0, cc_op1);\n+      return;\n+    case UNLE:\n+      paired_emit_vector_compare (LE, dest, op1, op0, cc_op0, cc_op1);\n+      return;\n+    case UNLT:\n+      paired_emit_vector_compare (LT, dest, op1, op0, cc_op0, cc_op1);\n+      return;\n+    case UNGE:\n+      paired_emit_vector_compare (GE, dest, op1, op0, cc_op0, cc_op1);\n+      return;\n+    case UNGT:\n+      paired_emit_vector_compare (GT, dest, op1, op0, cc_op0, cc_op1);\n+      return;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  return;\n+}\n+\n+/* Emit vector conditional expression.\n+   DEST is destination. OP1 and OP2 are two VEC_COND_EXPR operands.\n+   CC_OP0 and CC_OP1 are the two operands for the relation operation COND.  */\n+\n+int\n+paired_emit_vector_cond_expr (rtx dest, rtx op1, rtx op2,\n+\t\t\t      rtx cond, rtx cc_op0, rtx cc_op1)\n+{\n+  enum rtx_code rcode = GET_CODE (cond);\n+\n+  if (!TARGET_PAIRED_FLOAT)\n+    return 0;\n+\n+  paired_emit_vector_compare (rcode, dest, op1, op2, cc_op0, cc_op1);\n+\n+  return 1;\n+}\n+\n /* Initialize vector TARGET to VALS.  */\n \n void"}, {"sha": "d8f691af424900f9f650b455181f89e13fffceea", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2e95f45a8324f5aeacdc191217359f747fc2c26/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2e95f45a8324f5aeacdc191217359f747fc2c26/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e2e95f45a8324f5aeacdc191217359f747fc2c26", "patch": "@@ -1,3 +1,30 @@\n+2007-10-31  Revital Eres  <eres@il.ibm.com>\n+\n+\t* gcc.dg/vect/vect.exp: Add support for powerpc-*paired\n+\ttarget.\n+\t* gcc.dg/vect/tree-vect.h (check_vect): Add\n+\tpowerpc-*paired test.\n+\t* lib/target-supports.exp (check_750cl_hw_available):\n+\tNew.\n+\t(check_effective_target_vect_int,\n+\tcheck_effective_target_vect_intfloat_cvt,\n+\tcheck_effective_target_powerpc_altivec_ok,\n+\tcheck_effective_target_vect_long,\n+\tcheck_effective_target_vect_sdot_hi,\n+\tcheck_effective_target_vect_udot_hi,\n+\tcheck_effective_target_vect_pack_trunc,\n+\tcheck_effective_target_vect_unpack,\n+\tcheck_effective_target_vect_shift,\n+\tcheck_effective_target_vect_int_mult): Disable for powerpc-*paired\n+\ttarget.\n+\t* gcc.dg/vect/vect-ifcvt-11.c: New.\n+\t* gcc.dg/vect/vect-ifcvt-12.c: Likewise.\n+\t* gcc.dg/vect/vect-ifcvt-13.c: Likewise.\n+\t* gcc.dg/vect/vect-ifcvt-14.c: Likewise.\n+\t* gcc.dg/vect/vect-ifcvt-15.c: Likewise.\n+\t* gcc.dg/vect/vect-ifcvt-16.c: Likewise.\n+\t* gcc.dg/vect/vect-ifcvt-17.c: Likewise.\n+\n 2007-10-31  Dominique d'Humieres  <dominiq@lps.ens.fr>\n \t    Tobias Burnus  <burnus@net-b.de>\n "}, {"sha": "e080a6d35a43bd2cdd775909fc864f54a8a37a30", "filename": "gcc/testsuite/gcc.dg/vect/tree-vect.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2e95f45a8324f5aeacdc191217359f747fc2c26/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ftree-vect.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2e95f45a8324f5aeacdc191217359f747fc2c26/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ftree-vect.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ftree-vect.h?ref=e2e95f45a8324f5aeacdc191217359f747fc2c26", "patch": "@@ -13,7 +13,10 @@ sig_ill_handler (int sig)\n void check_vect (void)\n {\n   signal(SIGILL, sig_ill_handler);\n-#if defined(__ppc__) || defined(__ppc64__) || defined(__powerpc__) || defined(powerpc)\n+#if defined(__PAIRED__)\n+  /* 750CL paired-single instruction, 'ps_mul %v0,%v0,%v0'.  */\n+ asm volatile (\".long 0x10000032\");\n+#elif defined(__ppc__) || defined(__ppc64__) || defined(__powerpc__) || defined(powerpc)\n   /* Altivec instruction, 'vor %v0,%v0,%v0'.  */\n   asm volatile (\".long 0x10000484\");\n #elif defined(__i386__) || defined(__x86_64__)"}, {"sha": "560b5bc73df5f4f093f99d435c165b088d304925", "filename": "gcc/testsuite/gcc.dg/vect/vect-ifcvt-11.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2e95f45a8324f5aeacdc191217359f747fc2c26/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2e95f45a8324f5aeacdc191217359f747fc2c26/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-11.c?ref=e2e95f45a8324f5aeacdc191217359f747fc2c26", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-require-effective-target vect_condition } */\n+/* { dg-require-effective-target vect_float } */\n+\n+#include <stdarg.h>\n+#include <signal.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+#define MAX 42\n+\n+extern void abort(void); \n+\n+int main ()\n+{  \n+  float A[N] = {36,39,42,45,43,32,21,12,23,34,45,56,67,78,89,11};\n+  float B[N] = {0,0,42,42,42,0,0,0,0,0,42,42,42,42,42,0};\n+  int i, j;\n+\n+  check_vect ();\n+\n+  for (i = 0; i < 16; i++)\n+    A[i] = ( A[i] >= MAX ? MAX : 0); \n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    if (A[i] != B[i])\n+      abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "5f132b8ba81ac175353305ebb9837d163ec5a27c", "filename": "gcc/testsuite/gcc.dg/vect/vect-ifcvt-12.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2e95f45a8324f5aeacdc191217359f747fc2c26/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2e95f45a8324f5aeacdc191217359f747fc2c26/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-12.c?ref=e2e95f45a8324f5aeacdc191217359f747fc2c26", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-require-effective-target vect_condition } */\n+/* { dg-require-effective-target vect_float } */\n+\n+#include <stdarg.h>\n+#include <signal.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+#define MAX 42\n+\n+extern void abort(void); \n+\n+int main ()\n+{  \n+  float A[N] = {36,39,42,45,43,32,21,12,23,34,45,56,67,78,89,11};\n+  float B[N] = {0,0,0,42,42,0,0,0,0,0,42,42,42,42,42,0};\n+  int i, j;\n+\n+  check_vect ();\n+  for (i = 0; i < 16; i++)\n+    A[i] = ( A[i] > MAX ? MAX : 0); \n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    if (A[i] != B[i])\n+      abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "a5a59366bdce0376e768138179648603f1b7c1b1", "filename": "gcc/testsuite/gcc.dg/vect/vect-ifcvt-13.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2e95f45a8324f5aeacdc191217359f747fc2c26/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2e95f45a8324f5aeacdc191217359f747fc2c26/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-13.c?ref=e2e95f45a8324f5aeacdc191217359f747fc2c26", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-require-effective-target vect_condition } */\n+/* { dg-require-effective-target vect_float } */\n+\n+#include <stdarg.h>\n+#include <signal.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+#define MAX 42\n+\n+extern void abort(void); \n+\n+int main ()\n+{  \n+  float A[N] = {36,39,42,45,43,32,21,12,23,34,45,56,67,78,89,11};\n+  float B[N] = {42,42,42,0,0,42,42,42,42,42,0,0,0,0,0,42};\n+  int i, j;\n+\n+  check_vect ();\n+\n+  for (i = 0; i < 16; i++)\n+    A[i] = ( A[i] <= MAX ? MAX : 0); \n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    if (A[i] != B[i])\n+      abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "a5a59366bdce0376e768138179648603f1b7c1b1", "filename": "gcc/testsuite/gcc.dg/vect/vect-ifcvt-14.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2e95f45a8324f5aeacdc191217359f747fc2c26/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2e95f45a8324f5aeacdc191217359f747fc2c26/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-14.c?ref=e2e95f45a8324f5aeacdc191217359f747fc2c26", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-require-effective-target vect_condition } */\n+/* { dg-require-effective-target vect_float } */\n+\n+#include <stdarg.h>\n+#include <signal.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+#define MAX 42\n+\n+extern void abort(void); \n+\n+int main ()\n+{  \n+  float A[N] = {36,39,42,45,43,32,21,12,23,34,45,56,67,78,89,11};\n+  float B[N] = {42,42,42,0,0,42,42,42,42,42,0,0,0,0,0,42};\n+  int i, j;\n+\n+  check_vect ();\n+\n+  for (i = 0; i < 16; i++)\n+    A[i] = ( A[i] <= MAX ? MAX : 0); \n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    if (A[i] != B[i])\n+      abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "67d7ebe60c68d2f883e1bc0aee0010504b534d55", "filename": "gcc/testsuite/gcc.dg/vect/vect-ifcvt-15.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2e95f45a8324f5aeacdc191217359f747fc2c26/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2e95f45a8324f5aeacdc191217359f747fc2c26/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-15.c?ref=e2e95f45a8324f5aeacdc191217359f747fc2c26", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-require-effective-target vect_condition } */\n+/* { dg-require-effective-target vect_float } */\n+\n+#include <stdarg.h>\n+#include <signal.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+#define MAX 42\n+\n+extern void abort(void); \n+\n+int main ()\n+{  \n+  float A[N] = {36,39,42,45,43,32,21,12,23,34,45,56,67,78,89,11};\n+  float B[N] = {42,42,0,0,0,42,42,42,42,42,0,0,0,0,0,42};\n+  int i, j;\n+\n+  check_vect ();\n+\n+  for (i = 0; i < 16; i++)\n+    A[i] = ( A[i] < MAX ? MAX : 0); \n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    if (A[i] != B[i])\n+      abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "de7da97efa3dce4445de8fa96f7cdb1270481339", "filename": "gcc/testsuite/gcc.dg/vect/vect-ifcvt-16.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2e95f45a8324f5aeacdc191217359f747fc2c26/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2e95f45a8324f5aeacdc191217359f747fc2c26/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-16.c?ref=e2e95f45a8324f5aeacdc191217359f747fc2c26", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-require-effective-target vect_condition } */\n+/* { dg-require-effective-target vect_float } */\n+\n+#include <stdarg.h>\n+#include <signal.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+#define MAX 42\n+\n+extern void abort(void); \n+\n+int main ()\n+{  \n+  float A[N] = {36,39,42,45,43,32,21,42,23,34,45,56,67,42,89,11};\n+  float B[N] = {42,42,0,42,42,42,42,0,42,42,42,42,42,0,42,42};\n+  int i, j;\n+\n+  check_vect ();\n+\n+  for (i = 0; i < 16; i++)\n+    A[i] = ( A[i] != MAX ? MAX : 0); \n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    if (A[i] != B[i])\n+      abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "0a497b524bd6a064a85ad2d1a128b3ffe0c145ae", "filename": "gcc/testsuite/gcc.dg/vect/vect-ifcvt-17.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2e95f45a8324f5aeacdc191217359f747fc2c26/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2e95f45a8324f5aeacdc191217359f747fc2c26/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-17.c?ref=e2e95f45a8324f5aeacdc191217359f747fc2c26", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-require-effective-target vect_condition } */\n+/* { dg-require-effective-target vect_float } */\n+\n+#include <stdarg.h>\n+#include <signal.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+#define MAX 42\n+\n+extern void abort(void);\n+\n+int main ()\n+{\n+  float A[N] = {36,39,42,45,43,32,21,12,23,34,45,56,42,78,89,11};\n+  float B[N] = {42,42,0,42,42,42,42,42,42,42,42,42,0,42,42,42};\n+  int i, j;\n+\n+  check_vect ();\n+\n+  for (i = 0; i < 16; i++)\n+    A[i] = ( A[i] == MAX ? 0 : MAX);\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    if (A[i] != B[i])\n+      abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "40cb29f5a6f72364195b48cb4b26651a9fe99fe5", "filename": "gcc/testsuite/gcc.dg/vect/vect.exp", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2e95f45a8324f5aeacdc191217359f747fc2c26/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2e95f45a8324f5aeacdc191217359f747fc2c26/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp?ref=e2e95f45a8324f5aeacdc191217359f747fc2c26", "patch": "@@ -36,7 +36,14 @@ set save-dg-do-what-default ${dg-do-what-default}\n # Skip these tests for targets that do not support generating vector\n # code.  Set additional target-dependent vector flags, which can be\n # overridden by using dg-options in individual tests.\n-if [istarget \"powerpc*-*-*\"] {\n+if  [istarget \"powerpc-*paired*\"]  {\n+   lappend DEFAULT_VECTCFLAGS \"-mpaired\"\n+    if [check_750cl_hw_available] {\n+        set dg-do-what-default run \n+    } else {\n+        set dg-do-what-default compile\n+    }\n+} elseif [istarget \"powerpc*-*-*\"] {\n     # Skip targets not supporting -maltivec.\n     if ![is-effective-target powerpc_altivec_ok] {\n \treturn"}, {"sha": "f4c3e6aea30eddfdbfd4ce6a6a09b19fc97a4f36", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 73, "deletions": 10, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2e95f45a8324f5aeacdc191217359f747fc2c26/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2e95f45a8324f5aeacdc191217359f747fc2c26/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=e2e95f45a8324f5aeacdc191217359f747fc2c26", "patch": "@@ -906,6 +906,63 @@ proc check_effective_target_static_libgfortran { } {\n     return $et_static_libgfortran_saved\n }\n \n+# Return 1 if the target supports executing 750CL paired-single instructions, 0\n+# otherwise.  Cache the result.\n+\n+proc check_750cl_hw_available { } {\n+    global 750cl_hw_available_saved\n+    global tool\n+\n+    if [info exists 750cl_hw_available_saved] {\n+        verbose \"check_hw_available  returning saved $750cl_hw_available_saved\" 2\n+    } else {\n+        set 750cl_hw_available_saved 0\n+\n+        # If this is not the right target then we can quit.\n+        if { ![istarget powerpc-*paired*] } {\n+            verbose \"check_hw_available  returning 0\" 2\n+            return $750cl_hw_available_saved\n+        }\n+\n+        # Set up, compile, and execute a test program containing paired-single\n+        # instructions.  Include the current process ID in the file\n+        # names to prevent conflicts with invocations for multiple\n+        # testsuites.\n+        set src 750cl[pid].c\n+        set exe 750cl[pid].x\n+\n+        set f [open $src \"w\"]\n+        puts $f \"int main() {\"\n+        puts $f \"#ifdef __MACH__\"\n+        puts $f \"  asm volatile (\\\"ps_mul v0,v0,v0\\\");\"\n+        puts $f \"#else\"\n+        puts $f \"  asm volatile (\\\"ps_mul 0,0,0\\\");\"\n+        puts $f \"#endif\"\n+        puts $f \"  return 0; }\"\n+        close $f\n+\n+        verbose \"check_750cl_hw_available  compiling testfile $src\" 2\n+        set lines [${tool}_target_compile $src $exe executable \"-mpaired\"]\n+        file delete $src\n+\n+        if [string match \"\" $lines] then {\n+            # No error message, compilation succeeded.\n+            set result [${tool}_load \"./$exe\" \"\" \"\"]\n+            set status [lindex $result 0]\n+            remote_file build delete $exe\n+            verbose \"check_750cl_hw_available testfile status is <$status>\" 2\n+\n+            if { $status == \"pass\" } then {\n+                set 750_hw_available_saved 1\n+            }\n+        } else {\n+            verbose \"check_750_hw_availalble testfile compilation failed\" 2\n+        }\n+    }\n+    return $750cl_hw_available_saved\n+}\n+\n+\n # Return 1 if the target supports executing AltiVec instructions, 0\n # otherwise.  Cache the result.\n \n@@ -1451,7 +1508,8 @@ proc check_effective_target_vect_int { } {\n     } else {\n \tset et_vect_int_saved 0\n \tif { [istarget i?86-*-*]\n-\t      || [istarget powerpc*-*-*]\n+             || ([istarget powerpc*-*-*]\n+                  && ![istarget powerpc-*-linux*paired*])\n \t      || [istarget spu-*-*]\n \t      || [istarget x86_64-*-*]\n \t      || [istarget sparc*-*-*]\n@@ -1476,7 +1534,8 @@ proc check_effective_target_vect_intfloat_cvt { } {\n     } else {\n         set et_vect_intfloat_cvt_saved 0\n         if { [istarget i?86-*-*]\n-              || [istarget powerpc*-*-*]\n+              || ([istarget powerpc*-*-*]\n+                   && ![istarget powerpc-*-linux*paired*])\n               || [istarget x86_64-*-*] } {\n            set et_vect_intfloat_cvt_saved 1\n         }\n@@ -1618,7 +1677,8 @@ proc check_effective_target_powerpc_fprs { } {\n # Return 1 if this is a PowerPC target supporting -maltivec.\n \n proc check_effective_target_powerpc_altivec_ok { } {\n-    if { [istarget powerpc*-*-*]\n+    if { ([istarget powerpc*-*-*]\n+         && ![istarget powerpc-*-linux*paired*])\n \t || [istarget rs6000-*-*] } {\n \t# AltiVec is not supported on AIX before 5.3.\n \tif { [istarget powerpc*-*-aix4*]\n@@ -1720,7 +1780,8 @@ proc check_effective_target_vect_shift { } {\n \tverbose \"check_effective_target_vect_shift: using cached result\" 2\n     } else {\n \tset et_vect_shift_saved 0\n-\tif { [istarget powerpc*-*-*]\n+\tif { ([istarget powerpc*-*-*]\n+             && ![istarget powerpc-*-linux*paired*])\n \t     || [istarget ia64-*-*]\n \t     || [istarget i?86-*-*]\n \t     || [istarget x86_64-*-*] } {\n@@ -1738,7 +1799,9 @@ proc check_effective_target_vect_shift { } {\n \n proc check_effective_target_vect_long { } {\n     if { [istarget i?86-*-*]\n-\t || ([istarget powerpc*-*-*] && [check_effective_target_ilp32])\n+\t || (([istarget powerpc*-*-*] \n+              && ![istarget powerpc-*-linux*paired*]) \n+              && [check_effective_target_ilp32])\n \t || [istarget x86_64-*-*]\n \t || ([istarget sparc*-*-*] && [check_effective_target_ilp32]) } {\n \tset answer 1\n@@ -2033,7 +2096,7 @@ proc check_effective_target_vect_sdot_hi { } {\n         verbose \"check_effective_target_vect_sdot_hi: using cached result\" 2\n     } else {\n         set et_vect_sdot_hi_saved 0\n-        if { [istarget powerpc*-*-*] \n+        if { ([istarget powerpc*-*-*] && ![istarget powerpc-*-linux*paired*])\n \t     || [istarget i?86-*-*]\n              || [istarget x86_64-*-*] } {\n             set et_vect_sdot_hi_saved 1\n@@ -2055,7 +2118,7 @@ proc check_effective_target_vect_udot_hi { } {\n         verbose \"check_effective_target_vect_udot_hi: using cached result\" 2\n     } else {\n         set et_vect_udot_hi_saved 0\n-        if { [istarget powerpc*-*-*] } {\n+        if { ([istarget powerpc*-*-*] && ![istarget powerpc-*-linux*paired*]) } {\n             set et_vect_udot_hi_saved 1\n         }\n     }\n@@ -2077,7 +2140,7 @@ proc check_effective_target_vect_pack_trunc { } {\n         verbose \"check_effective_target_vect_pack_trunc: using cached result\" 2\n     } else {\n         set et_vect_pack_trunc_saved 0\n-        if { [istarget powerpc*-*-*]\n+        if { ([istarget powerpc*-*-*] && ![istarget powerpc-*-linux*paired*])\n              || [istarget i?86-*-*]\n              || [istarget x86_64-*-*] } {\n             set et_vect_pack_trunc_saved 1\n@@ -2099,7 +2162,7 @@ proc check_effective_target_vect_unpack { } {\n         verbose \"check_effective_target_vect_unpack: using cached result\" 2\n     } else {\n         set et_vect_unpack_saved 0\n-        if { [istarget powerpc*-*-*]\n+        if { ([istarget powerpc*-*-*] && ![istarget powerpc-*paired*])\n              || [istarget i?86-*-*]\n              || [istarget x86_64-*-*] } {\n             set et_vect_unpack_saved 1\n@@ -2329,7 +2392,7 @@ proc check_effective_target_vect_int_mult { } {\n \tverbose \"check_effective_target_vect_int_mult: using cached result\" 2\n     } else {\n \tset et_vect_int_mult_saved 0\n-\tif { [istarget powerpc*-*-*]\n+\tif { ([istarget powerpc*-*-*] && ![istarget powerpc-*-linux*paired*])\n \t     || [istarget spu-*-*]\n \t     || [istarget i?86-*-*]\n \t     || [istarget x86_64-*-*] } {"}]}