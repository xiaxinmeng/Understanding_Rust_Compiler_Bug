{"sha": "933f507d1fda886c1471c200f79b02e1c6d3fb2c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTMzZjUwN2QxZmRhODg2YzE0NzFjMjAwZjc5YjAyZTFjNmQzZmIyYw==", "commit": {"author": {"name": "Easwaran Raman", "email": "eraman@gcc.gnu.org", "date": "2013-05-18T01:35:04Z"}, "committer": {"name": "Easwaran Raman", "email": "eraman@gcc.gnu.org", "date": "2013-05-18T01:35:04Z"}, "message": "tree-ssa-reassoc.c (find_insert_point): New function.\n\n2013-05-17   Easwaran Raman  <eraman@google.com>\n\n        * tree-ssa-reassoc.c (find_insert_point): New function.\n        (insert_stmt_after): Likewise.\n        (get_def_stmt): Likewise.\n        (ensure_ops_are_available): Likewise.\n        (not_dominated_by): Likewise.\n        (rewrite_expr_tree): Do not move statements beyond what is\n        necessary. Remove call to swap_ops_for_binary_stmt...\n        (reassociate_bb): ... and move it here.\n        (build_and_add_sum): Assign UIDs for new statements.\n        (linearize_expr): Likewise.\n        (do_reassoc): Renumber gimple statement UIDs.\n\ntestsuite/ChangeLog:\n\n2013-05-17   Easwaran Raman  <eraman@google.com>\n\n        * gcc.dg/tree-ssa/reassoc-28.c: New testcase.\n\nFrom-SVN: r199048", "tree": {"sha": "0ab6c75725936898fe585bb03325c1060de6e24e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ab6c75725936898fe585bb03325c1060de6e24e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/933f507d1fda886c1471c200f79b02e1c6d3fb2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/933f507d1fda886c1471c200f79b02e1c6d3fb2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/933f507d1fda886c1471c200f79b02e1c6d3fb2c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/933f507d1fda886c1471c200f79b02e1c6d3fb2c/comments", "author": null, "committer": null, "parents": [{"sha": "1f2f6dc2bca7e7eea7cadfc347995ea99e78ed99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f2f6dc2bca7e7eea7cadfc347995ea99e78ed99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f2f6dc2bca7e7eea7cadfc347995ea99e78ed99"}], "stats": {"total": 223, "additions": 203, "deletions": 20}, "files": [{"sha": "4536e6279a138265e65e80cc5b5467b1c75272d0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/933f507d1fda886c1471c200f79b02e1c6d3fb2c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/933f507d1fda886c1471c200f79b02e1c6d3fb2c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=933f507d1fda886c1471c200f79b02e1c6d3fb2c", "patch": "@@ -1,3 +1,17 @@\n+2013-05-17   Easwaran Raman  <eraman@google.com>\n+\n+\t* tree-ssa-reassoc.c (find_insert_point): New function.\n+\t(insert_stmt_after): Likewise.\n+\t(get_def_stmt): Likewise.\n+\t(ensure_ops_are_available): Likewise.\n+\t(not_dominated_by): Likewise.\n+\t(rewrite_expr_tree): Do not move statements beyond what is\n+\tnecessary. Remove call to swap_ops_for_binary_stmt...\n+\t(reassociate_bb): ... and move it here.\n+\t(build_and_add_sum): Assign UIDs for new statements.\n+\t(linearize_expr): Likewise.\n+\t(do_reassoc): Renumber gimple statement UIDs.\n+\n 2013-05-17  Jan Hubicka  <jh@suse.cz>\n \n \t* lto-symtab.c (lto_symtab_merge_cgraph_nodes): Resolve cross module\n@@ -156,6 +170,7 @@\n \n \t* Makefile.in (tree-switch-conversion.o): Depend on $(OPTABS_H).\n \n+>>>>>>> .r199043\n 2013-05-16  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/driver-i386.c (host_detect_local_cpu): Determine"}, {"sha": "6fd1b2ed3a680fd282371d4263fb270ce9a8ac8e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/933f507d1fda886c1471c200f79b02e1c6d3fb2c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/933f507d1fda886c1471c200f79b02e1c6d3fb2c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=933f507d1fda886c1471c200f79b02e1c6d3fb2c", "patch": "@@ -1,3 +1,7 @@\n+2013-05-17   Easwaran Raman  <eraman@google.com>\n+\n+\t* gcc.dg/tree-ssa/reassoc-28.c: New testcase.\n+\n 2013-05-17  Marc Glisse  <marc.glisse@inria.fr>\n \n \tPR testsuite/57313"}, {"sha": "3d10b49ccaff78d5f36f0a3cd893ed76057a573b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-28.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/933f507d1fda886c1471c200f79b02e1c6d3fb2c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-28.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/933f507d1fda886c1471c200f79b02e1c6d3fb2c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-28.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-28.c?ref=933f507d1fda886c1471c200f79b02e1c6d3fb2c", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do run} */\n+/* { dg-options \"-O2 -fdump-tree-reassoc1-details\" } */\n+\n+#define LENGTH 4\n+void abort (void);\n+unsigned\n+__attribute__ ((noinline))  foo (unsigned char *buf, int n)\n+{\n+ unsigned sum = 0, i = 0;\n+ do {\n+   sum +=(buf)[n-1];\n+   /* Split the BB to test statements are correctly moved to\n+      satisfy dependences.  */\n+   if (n > LENGTH)\n+     i++;\n+   sum += buf[n-2];\n+   sum += buf[n-3];\n+   sum += buf[n-4];\n+   n = n-4;\n+ } while (n > 0);\n+\n+ return sum + i;\n+}\n+\n+unsigned char a[] = {1, 1, 1, 1};\n+\n+int main() {\n+  int sum = foo (a, LENGTH);\n+  if (sum != 4)\n+    abort ();\n+  return 0;\n+}\n+\n+/* Verify one stmt has been moved to another BB to ensure correct dependences.  */\n+/* { dg-final { scan-tree-dump-times \"to a different BB\" 1 \"reassoc1\"} }*/\n+/* { dg-final { scan-tree-dump-times \"within same BB\" 2 \"reassoc1\"} }*/\n+/* { dg-final { cleanup-tree-dump \"reassoc1\" } } */"}, {"sha": "29c9dff2868b68732820e431ecfa248159b836e6", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 147, "deletions": 20, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/933f507d1fda886c1471c200f79b02e1c6d3fb2c/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/933f507d1fda886c1471c200f79b02e1c6d3fb2c/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=933f507d1fda886c1471c200f79b02e1c6d3fb2c", "patch": "@@ -1166,6 +1166,7 @@ build_and_add_sum (tree type, tree op1, tree op2, enum tree_code opcode)\n       && (!op2def || gimple_nop_p (op2def)))\n     {\n       gsi = gsi_after_labels (single_succ (ENTRY_BLOCK_PTR));\n+      gimple_set_uid (sum, gimple_uid (gsi_stmt (gsi)));\n       gsi_insert_before (&gsi, sum, GSI_NEW_STMT);\n     }\n   else if ((!op1def || gimple_nop_p (op1def))\n@@ -1175,13 +1176,15 @@ build_and_add_sum (tree type, tree op1, tree op2, enum tree_code opcode)\n       if (gimple_code (op2def) == GIMPLE_PHI)\n \t{\n \t  gsi = gsi_after_labels (gimple_bb (op2def));\n+          gimple_set_uid (sum, gimple_uid (gsi_stmt (gsi)));\n \t  gsi_insert_before (&gsi, sum, GSI_NEW_STMT);\n \t}\n       else\n \t{\n \t  if (!stmt_ends_bb_p (op2def))\n \t    {\n \t      gsi = gsi_for_stmt (op2def);\n+              gimple_set_uid (sum, gimple_uid (op2def));\n \t      gsi_insert_after (&gsi, sum, GSI_NEW_STMT);\n \t    }\n \t  else\n@@ -1200,13 +1203,15 @@ build_and_add_sum (tree type, tree op1, tree op2, enum tree_code opcode)\n       if (gimple_code (op1def) == GIMPLE_PHI)\n \t{\n \t  gsi = gsi_after_labels (gimple_bb (op1def));\n+          gimple_set_uid (sum, gimple_uid (op1def));\n \t  gsi_insert_before (&gsi, sum, GSI_NEW_STMT);\n \t}\n       else\n \t{\n \t  if (!stmt_ends_bb_p (op1def))\n \t    {\n \t      gsi = gsi_for_stmt (op1def);\n+              gimple_set_uid (sum, gimple_uid (op1def));\n \t      gsi_insert_after (&gsi, sum, GSI_NEW_STMT);\n \t    }\n \t  else\n@@ -2841,6 +2846,135 @@ swap_ops_for_binary_stmt (vec<operand_entry_t> ops,\n     }\n }\n \n+/* Determine if stmt A is not dominated by stmt B. If A and B are in\n+   same basic block, then A's UID has to be less than B. If they are\n+   in different BB's, then A's BB must not be dominated by B's BB.  */\n+\n+static inline bool\n+not_dominated_by (gimple a, gimple b)\n+{\n+  basic_block bb_a, bb_b;\n+  bb_a = gimple_bb (a);\n+  bb_b = gimple_bb (b);\n+  return ((bb_a == bb_b && gimple_uid (a)  < gimple_uid (b))\n+          || (bb_a != bb_b\n+              && !dominated_by_p (CDI_DOMINATORS, bb_a, bb_b)));\n+\n+}\n+\n+/* Find the statement after which STMT must be moved so that the\n+   dependency from DEP_STMT to STMT is maintained.  */\n+\n+static gimple\n+find_insert_point (gimple stmt, gimple dep_stmt)\n+{\n+  gimple insert_stmt = stmt;\n+  if (dep_stmt == NULL)\n+    return stmt;\n+  if (not_dominated_by (insert_stmt, dep_stmt))\n+    insert_stmt = dep_stmt;\n+  return insert_stmt;\n+}\n+\n+/* Insert STMT after INSERT_POINT.  */\n+\n+static void\n+insert_stmt_after (gimple stmt, gimple insert_point)\n+{\n+  imm_use_iterator iter;\n+  tree lhs;\n+  gimple use_stmt;\n+  gimple_stmt_iterator gsistmt = gsi_for_stmt (stmt), gsi_insert;\n+  basic_block insert_bb = gimple_bb (insert_point);\n+  bool insert_bb_different = (insert_bb != gimple_bb (stmt));\n+  lhs = gimple_assign_lhs (stmt);\n+  /* If there are any debug uses of LHS, reset them.  */\n+  FOR_EACH_IMM_USE_STMT (use_stmt, iter, lhs)\n+    {\n+      if (is_gimple_debug (use_stmt)\n+          && not_dominated_by (use_stmt, insert_point))\n+        {\n+          gimple_debug_bind_reset_value (use_stmt);\n+          update_stmt (use_stmt);\n+        }\n+    }\n+  /* If INSERT_STMT is a phi node, then do not insert just after that statement.\n+     Instead, find the first non-label gimple statement in BB and insert before\n+     that.  */\n+  if (gimple_code (insert_point) == GIMPLE_PHI)\n+    {\n+      gsi_insert = gsi_after_labels (insert_bb);\n+      gsi_move_before (&gsistmt, &gsi_insert);\n+    }\n+  /* Statements marked for throw can not be in the middle of a basic block. So\n+     we can not insert a statement (not marked for throw) immediately after.  */\n+  else if (stmt_ends_bb_p (insert_point))\n+    {\n+      edge succ_edge = find_fallthru_edge (insert_bb->succs);\n+      insert_bb = succ_edge->dest;\n+      insert_bb_different = (insert_bb != gimple_bb (stmt));\n+      /* Insert STMT at the beginning of the successor basic block.  */\n+      gsi_insert = gsi_after_labels (insert_bb);\n+      gsi_move_before (&gsistmt, &gsi_insert);\n+    }\n+  else\n+    {\n+      gsi_insert = gsi_for_stmt (insert_point);\n+      gsi_move_after (&gsistmt, &gsi_insert);\n+    }\n+  /* Set the UID of STMT to that of INSERT_POINT so that subsequent comparisons\n+     of UIDs to determine dominance within a basic block works.  */\n+  gimple_set_uid (stmt, gimple_uid (insert_point));\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Moved stmt \");\n+      print_gimple_stmt (dump_file, stmt, 0, 0);\n+      fprintf (dump_file, \" %s to satisfy dependences\\n\",\n+               insert_bb_different ? \"to a different BB\" : \"within same BB\");\n+    }\n+\n+}\n+\n+/* If OP is a SSA variable and is not the default definition, return the\n+   gimple statement that defines OP. Else return NULL.  */\n+\n+static inline gimple\n+get_def_stmt (tree op)\n+{\n+  if (TREE_CODE (op) == SSA_NAME\n+      && !SSA_NAME_IS_DEFAULT_DEF (op))\n+    return SSA_NAME_DEF_STMT (op);\n+  else\n+    return NULL;\n+}\n+\n+/* Ensure that operands in the OPS vector are available for STMT and all\n+   gimple statements on which STMT depends.  */\n+\n+static void\n+ensure_ops_are_available (gimple stmt, vec<operand_entry_t> ops, int opindex)\n+{\n+  unsigned int len = ops.length ();\n+  gimple insert_stmt = stmt;\n+  gimple dep_stmts[2];\n+  dep_stmts[0] = get_def_stmt (ops[opindex]->op);\n+  if (len - opindex == 2)\n+    {\n+      dep_stmts[1] = get_def_stmt (ops[opindex + 1]->op);\n+    }\n+  else\n+    {\n+      gimple stmt1 = SSA_NAME_DEF_STMT (gimple_assign_rhs1 (stmt));\n+      ensure_ops_are_available (stmt1, ops, opindex + 1);\n+      dep_stmts[1] = stmt1;\n+    }\n+  for (int i = 0; i < 2; i++)\n+    insert_stmt = find_insert_point (insert_stmt, dep_stmts[i]);\n+\n+  if (insert_stmt != stmt)\n+    insert_stmt_after (stmt, insert_stmt);\n+}\n+\n /* Recursively rewrite our linearized statements so that the operators\n    match those in OPS[OPINDEX], putting the computation in rank\n    order.  */\n@@ -2853,11 +2987,6 @@ rewrite_expr_tree (gimple stmt, unsigned int opindex,\n   tree rhs2 = gimple_assign_rhs2 (stmt);\n   operand_entry_t oe;\n \n-  /* If we have three operands left, then we want to make sure the ones\n-     that get the double binary op are chosen wisely.  */\n-  if (opindex + 3 == ops.length ())\n-    swap_ops_for_binary_stmt (ops, opindex, stmt);\n-\n   /* The final recursion case for this function is that you have\n      exactly two operations left.\n      If we had one exactly one op in the entire list to start with, we\n@@ -2903,20 +3032,7 @@ rewrite_expr_tree (gimple stmt, unsigned int opindex,\n     {\n       if (!moved)\n \t{\n-\t  gimple_stmt_iterator gsinow, gsirhs1;\n-\t  gimple stmt1 = stmt, stmt2;\n-\t  unsigned int count;\n-\n-\t  gsinow = gsi_for_stmt (stmt);\n-\t  count = ops.length () - opindex - 2;\n-\t  while (count-- != 0)\n-\t    {\n-\t      stmt2 = SSA_NAME_DEF_STMT (gimple_assign_rhs1 (stmt1));\n-\t      gsirhs1 = gsi_for_stmt (stmt2);\n-\t      gsi_move_before (&gsirhs1, &gsinow);\n-\t      gsi_prev (&gsinow);\n-\t      stmt1 = stmt2;\n-\t    }\n+          ensure_ops_are_available (stmt, ops, opindex);\n \t  moved = true;\n \t}\n \n@@ -3128,6 +3244,7 @@ linearize_expr (gimple stmt)\n   gsinow = gsi_for_stmt (stmt);\n   gsirhs = gsi_for_stmt (binrhs);\n   gsi_move_before (&gsirhs, &gsinow);\n+  gimple_set_uid (binrhs, gimple_uid (stmt));\n \n   gimple_assign_set_rhs2 (stmt, gimple_assign_rhs1 (binrhs));\n   gimple_assign_set_rhs1 (binrhs, gimple_assign_lhs (binlhs));\n@@ -4134,7 +4251,16 @@ reassociate_bb (basic_block bb)\n \t\t      && ops.length () > 3)\n \t\t    rewrite_expr_tree_parallel (stmt, width, ops);\n \t\t  else\n-\t\t    rewrite_expr_tree (stmt, 0, ops, false);\n+                    {\n+                      /* When there are three operands left, we want\n+                         to make sure the ones that get the double\n+                         binary op are chosen wisely.  */\n+                      int len = ops.length ();\n+                      if (len >= 3)\n+                        swap_ops_for_binary_stmt (ops, len - 3, stmt);\n+\n+\t\t      rewrite_expr_tree (stmt, 0, ops, false);\n+                    }\n \n \t\t  /* If we combined some repeated factors into a \n \t\t     __builtin_powi call, multiply that result by the\n@@ -4195,6 +4321,7 @@ static void\n do_reassoc (void)\n {\n   break_up_subtract_bb (ENTRY_BLOCK_PTR);\n+  renumber_gimple_stmt_uids ();\n   reassociate_bb (EXIT_BLOCK_PTR);\n }\n "}]}