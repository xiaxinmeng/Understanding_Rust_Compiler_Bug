{"sha": "ea0a374b2c55421c111b401ba73bd45230599c07", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWEwYTM3NGIyYzU1NDIxYzExMWI0MDFiYTczYmQ0NTIzMDU5OWMwNw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2009-04-06T20:13:39Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2009-04-06T20:13:39Z"}, "message": "re PR fortran/38863 (WHERE with multiple elemental defined assignments gives wrong answer)\n\n2009-04-06  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/38863\n\t* dependency.c (ref_same_as_full_array): New function.\n\t(gfc_dep_resolver): Call it.\n\n2009-04-06  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/38863\n\t* gfortran.dg/dependency_23.f90: New test.\n\nFrom-SVN: r145621", "tree": {"sha": "96395e2ffcf5e4972e9e21177942e430516a4991", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/96395e2ffcf5e4972e9e21177942e430516a4991"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea0a374b2c55421c111b401ba73bd45230599c07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea0a374b2c55421c111b401ba73bd45230599c07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea0a374b2c55421c111b401ba73bd45230599c07", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea0a374b2c55421c111b401ba73bd45230599c07/comments", "author": null, "committer": null, "parents": [{"sha": "53e350d382574a7e38ba23dad13a1f8399782fc1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53e350d382574a7e38ba23dad13a1f8399782fc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53e350d382574a7e38ba23dad13a1f8399782fc1"}], "stats": {"total": 139, "additions": 139, "deletions": 0}, "files": [{"sha": "bba5fe5151b248deb30aa3192332900741a69589", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea0a374b2c55421c111b401ba73bd45230599c07/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea0a374b2c55421c111b401ba73bd45230599c07/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=ea0a374b2c55421c111b401ba73bd45230599c07", "patch": "@@ -1,3 +1,9 @@\n+2009-04-06  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/38863\n+\t* dependency.c (ref_same_as_full_array): New function.\n+\t(gfc_dep_resolver): Call it.\n+\n 2009-04-06  Janus Weil  <janus@gcc.gnu.org>\n \n        PR fortran/39414"}, {"sha": "5f74c34ac5ca4dc7774ad376164be9f454f32b89", "filename": "gcc/fortran/dependency.c", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea0a374b2c55421c111b401ba73bd45230599c07/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea0a374b2c55421c111b401ba73bd45230599c07/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=ea0a374b2c55421c111b401ba73bd45230599c07", "patch": "@@ -1244,6 +1244,71 @@ gfc_full_array_ref_p (gfc_ref *ref)\n }\n \n \n+/* Determine if a full array is the same as an array section with one\n+   variable limit.  For this to be so, the strides must both be unity\n+   and one of either start == lower or end == upper must be true.  */\n+\n+static bool\n+ref_same_as_full_array (gfc_ref *full_ref, gfc_ref *ref)\n+{\n+  int i;\n+  bool upper_or_lower;\n+\n+  if (full_ref->type != REF_ARRAY)\n+    return false;\n+  if (full_ref->u.ar.type != AR_FULL)\n+    return false;\n+  if (ref->type != REF_ARRAY)\n+    return false;\n+  if (ref->u.ar.type != AR_SECTION)\n+    return false;\n+\n+  for (i = 0; i < ref->u.ar.dimen; i++)\n+    {\n+      /* If we have a single element in the reference, we need to check\n+\t that the array has a single element and that we actually reference\n+\t the correct element.  */\n+      if (ref->u.ar.dimen_type[i] == DIMEN_ELEMENT)\n+\t{\n+\t  if (!full_ref->u.ar.as\n+\t      || !full_ref->u.ar.as->lower[i]\n+\t      || !full_ref->u.ar.as->upper[i]\n+\t      || gfc_dep_compare_expr (full_ref->u.ar.as->lower[i],\n+\t\t\t\t       full_ref->u.ar.as->upper[i])\n+\t      || !ref->u.ar.start[i]\n+\t      || gfc_dep_compare_expr (ref->u.ar.start[i],\n+\t\t\t\t       full_ref->u.ar.as->lower[i]))\n+\t    return false;\n+\t}\n+\n+      /* Check the strides.  */\n+      if (full_ref->u.ar.stride[i] && !gfc_expr_is_one (full_ref->u.ar.stride[i], 0))\n+\treturn false;\n+      if (ref->u.ar.stride[i] && !gfc_expr_is_one (ref->u.ar.stride[i], 0))\n+\treturn false;\n+\n+      upper_or_lower = false;\n+      /* Check the lower bound.  */\n+      if (ref->u.ar.start[i]\n+\t  && (ref->u.ar.as\n+\t        && full_ref->u.ar.as->lower[i]\n+\t        && gfc_dep_compare_expr (ref->u.ar.start[i],\n+\t\t\t\t         full_ref->u.ar.as->lower[i]) == 0))\n+\tupper_or_lower =  true;\n+      /* Check the upper bound.  */\n+      if (ref->u.ar.end[i]\n+\t  && (ref->u.ar.as\n+\t        && full_ref->u.ar.as->upper[i]\n+\t        && gfc_dep_compare_expr (ref->u.ar.end[i],\n+\t\t\t\t         full_ref->u.ar.as->upper[i]) == 0))\n+\tupper_or_lower =  true;\n+      if (!upper_or_lower)\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+\n /* Finds if two array references are overlapping or not.\n    Return value\n    \t1 : array references are overlapping.\n@@ -1281,6 +1346,13 @@ gfc_dep_resolver (gfc_ref *lref, gfc_ref *rref)\n \t  return (fin_dep == GFC_DEP_OVERLAP) ? 1 : 0;\n \t\n \tcase REF_ARRAY:\n+\n+\t  if (ref_same_as_full_array (lref, rref))\n+\t    return 0;\n+\n+\t  if (ref_same_as_full_array (rref, lref))\n+\t    return 0;\n+\n \t  if (lref->u.ar.dimen != rref->u.ar.dimen)\n \t    {\n \t      if (lref->u.ar.type == AR_FULL)"}, {"sha": "489ca5b795c44ec8f4699e4fece4a2ce7fe8919c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea0a374b2c55421c111b401ba73bd45230599c07/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea0a374b2c55421c111b401ba73bd45230599c07/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ea0a374b2c55421c111b401ba73bd45230599c07", "patch": "@@ -1,3 +1,8 @@\n+2009-04-06  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/38863\n+\t* gfortran.dg/dependency_23.f90: New test.\n+\n 2009-04-06  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/28868"}, {"sha": "bdb17115a11d42466581f91677286e1ae8e40c23", "filename": "gcc/testsuite/gfortran.dg/dependency_23.f90", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea0a374b2c55421c111b401ba73bd45230599c07/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_23.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea0a374b2c55421c111b401ba73bd45230599c07/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_23.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_23.f90?ref=ea0a374b2c55421c111b401ba73bd45230599c07", "patch": "@@ -0,0 +1,56 @@\n+! { dg-do run }\n+! Test the fix for PR38863, in which an unnecessary temporary\n+! generated results that are not consistent with other compilers.\n+!\n+! Contributed by Dick Hendrickson  <dick.hendrickson@gmail.com>\n+!\n+module rg0045_stuff\n+  type unseq\n+    integer :: i\n+    logical :: l\n+  end type unseq\n+  interface assignment(=)\n+    module procedure l_to_t, i_to_t\n+  end interface\n+contains\n+  elemental subroutine l_to_t (arg1, arg2)\n+    type(unseq), intent(inout) :: arg1\n+    logical, intent(in) :: arg2\n+    arg1%l = arg2\n+  end subroutine l_to_t\n+  elemental subroutine i_to_t (arg1, arg2)\n+    type(unseq), intent(inout) :: arg1\n+    integer, intent(in) :: arg2\n+    arg1%i = arg2\n+  end subroutine i_to_t\n+  subroutine rg0045(nf1, nf2, nf3)\n+    type(unseq) :: tla2l(nf3, nf2)\n+    type(unseq) :: tda2l(3,2)\n+    logical :: lda(nf3,nf2)\n+    tda2l%l = reshape ([.true.,.false.,.true.,.false.,.true.,.false.],[3,2])\n+    tda2l%i = reshape ([1, -1, 3, -1, 5, -1],[3,2])\n+    lda = tda2l%l\n+    tla2l%l = lda\n+    tla2l%i = reshape ([1, 2, 3, 4, 5, 6], [3,2])\n+!\n+! The problem occurred here: gfortran was producing a temporary for these\n+! assignments because the dependency checking was too restrictive.  Since\n+! a temporary was used, the integer component was reset in the first assignment\n+! rather than being carried over.\n+!\n+    where(lda)\n+      tla2l = tla2l(1:3, 1:2)%l\n+      tla2l = tla2l(1:3, 1:2)%i\n+    elsewhere\n+      tla2l = -1\n+    endwhere\n+    if (any (tla2l%i .ne. tda2l%i)) call abort\n+    if (any (tla2l%l .neqv. tda2l%l)) call abort\n+  end subroutine\n+end module rg0045_stuff\n+\n+  use rg0045_stuff\n+  call rg0045(1, 2, 3)\n+end\n+\n+"}]}