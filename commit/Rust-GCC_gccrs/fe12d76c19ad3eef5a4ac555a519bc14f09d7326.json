{"sha": "fe12d76c19ad3eef5a4ac555a519bc14f09d7326", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmUxMmQ3NmMxOWFkM2VlZjVhNGFjNTU1YTUxOWJjMTRmMDlkNzMyNg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2016-11-21T05:29:36Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2016-11-21T05:29:36Z"}, "message": "re PR target/48551 (Following source code crashes the c++ compiler on coldfire platform.)\n\n2016-11-20  Jeff Law  <law@redhat.com>\n\n\tPR target/48551\n\t* reload.h (struct target_reload): Make x_double_reg_address_ok\n\tbe per-mode rather.\n\t* reload.c (find_reloads_address): Check if double_reg_address_ok\n\tis true for the mode of the memory reference.\n\t* reload1.c (init_reload): Initialize double_reg_address_ok for\n\teach mode.\n\n\tPR target/48551\n\t* gcc.target/m68k/pr48551.c: New test.\n\nFrom-SVN: r242648", "tree": {"sha": "0b5b40035eedaf847288f81a5c5be3bd4847c5e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b5b40035eedaf847288f81a5c5be3bd4847c5e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe12d76c19ad3eef5a4ac555a519bc14f09d7326", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe12d76c19ad3eef5a4ac555a519bc14f09d7326", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe12d76c19ad3eef5a4ac555a519bc14f09d7326", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe12d76c19ad3eef5a4ac555a519bc14f09d7326/comments", "author": null, "committer": null, "parents": [{"sha": "29c90a3c28a7917023477648f0c88aa273e7510e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29c90a3c28a7917023477648f0c88aa273e7510e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29c90a3c28a7917023477648f0c88aa273e7510e"}], "stats": {"total": 77, "additions": 68, "deletions": 9}, "files": [{"sha": "40d6f8a5cbbf7175acdb3228af14768a3b89034f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe12d76c19ad3eef5a4ac555a519bc14f09d7326/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe12d76c19ad3eef5a4ac555a519bc14f09d7326/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fe12d76c19ad3eef5a4ac555a519bc14f09d7326", "patch": "@@ -1,3 +1,13 @@\n+2016-11-20  Jeff Law  <law@redhat.com>\n+\n+\tPR target/48551\n+\t* reload.h (struct target_reload): Make x_double_reg_address_ok\n+\tbe per-mode rather.\n+\t* reload.c (find_reloads_address): Check if double_reg_address_ok\n+\tis true for the mode of the memory reference.\n+\t* reload1.c (init_reload): Initialize double_reg_address_ok for\n+\teach mode.\n+\n 2016-11-20  Aldy Hernandez  <aldyh@redhat.com>\n \n \tPR middle-end/61409"}, {"sha": "4cba220945134a8c8cb4c3c49ea1cae95f20dfcf", "filename": "gcc/reload.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe12d76c19ad3eef5a4ac555a519bc14f09d7326/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe12d76c19ad3eef5a4ac555a519bc14f09d7326/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=fe12d76c19ad3eef5a4ac555a519bc14f09d7326", "patch": "@@ -5090,7 +5090,7 @@ find_reloads_address (machine_mode mode, rtx *memrefloc, rtx ad,\n \t    loc = &XEXP (*loc, 0);\n \t}\n \n-      if (double_reg_address_ok\n+      if (double_reg_address_ok[mode]\n \t  && regno_ok_for_base_p (REGNO (XEXP (ad, 0)), mode, as,\n \t\t\t\t  PLUS, CONST_INT))\n \t{"}, {"sha": "1fc8ecb6cac6cf0b078d9adb873eec86fa97eee4", "filename": "gcc/reload.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe12d76c19ad3eef5a4ac555a519bc14f09d7326/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe12d76c19ad3eef5a4ac555a519bc14f09d7326/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=fe12d76c19ad3eef5a4ac555a519bc14f09d7326", "patch": "@@ -159,9 +159,6 @@ struct target_reload {\n      which these are valid is the same as spill_indirect_levels, above.  */\n   bool x_indirect_symref_ok;\n \n-  /* Nonzero if an address (plus (reg frame_pointer) (reg ...)) is valid.  */\n-  bool x_double_reg_address_ok;\n-\n   /* Nonzero if indirect addressing is supported on the machine; this means\n      that spilling (REG n) does not require reloading it into a register in\n      order to do (MEM (REG n)) or (MEM (PLUS (REG n) (CONST_INT c))).  The\n@@ -181,6 +178,10 @@ struct target_reload {\n \t\t     [FIRST_PSEUDO_REGISTER]\n \t\t     [MAX_MOVE_MAX / MIN_UNITS_PER_WORD + 1]);\n \n+  /* Nonzero if an address (plus (reg frame_pointer) (reg ...)) is valid\n+     in the given mode.  */\n+  bool x_double_reg_address_ok[MAX_MACHINE_MODE];\n+\n   /* We will only make a register eligible for caller-save if it can be\n      saved in its widest mode with a simple SET insn as long as the memory\n      address is valid.  We record the INSN_CODE is those insns here since"}, {"sha": "b855268c025102cc77521119b3311831c73a1b08", "filename": "gcc/reload1.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe12d76c19ad3eef5a4ac555a519bc14f09d7326/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe12d76c19ad3eef5a4ac555a519bc14f09d7326/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=fe12d76c19ad3eef5a4ac555a519bc14f09d7326", "patch": "@@ -448,11 +448,10 @@ init_reload (void)\n       /* This way, we make sure that reg+reg is an offsettable address.  */\n       tem = plus_constant (Pmode, tem, 4);\n \n-      if (memory_address_p (QImode, tem))\n-\t{\n-\t  double_reg_address_ok = 1;\n-\t  break;\n-\t}\n+      for (int mode = 0; mode < MAX_MACHINE_MODE; mode++)\n+\tif (!double_reg_address_ok[mode]\n+\t    && memory_address_p ((enum machine_mode)mode, tem))\n+\t  double_reg_address_ok[mode] = 1;\n     }\n \n   /* Initialize obstack for our rtl allocation.  */"}, {"sha": "37e840321a506df48f324cf1e3df8e39cb016a10", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe12d76c19ad3eef5a4ac555a519bc14f09d7326/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe12d76c19ad3eef5a4ac555a519bc14f09d7326/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fe12d76c19ad3eef5a4ac555a519bc14f09d7326", "patch": "@@ -1,3 +1,8 @@\n+2016-11-20  Jeff Law  <law@redhat.com>\n+\n+\tPR target/48551\n+\t* gcc.target/m68k/pr48551.c: New test.\n+\n 2016-11-20  Harald Anlauf  <anlauf@gmx.de>\n  \n \tPR fortran/69741"}, {"sha": "48ea4b4940f5b7d1d14c4ac4b7be97fb25ddd93b", "filename": "gcc/testsuite/gcc.target/m68k/pr48551.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe12d76c19ad3eef5a4ac555a519bc14f09d7326/gcc%2Ftestsuite%2Fgcc.target%2Fm68k%2Fpr48551.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe12d76c19ad3eef5a4ac555a519bc14f09d7326/gcc%2Ftestsuite%2Fgcc.target%2Fm68k%2Fpr48551.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fm68k%2Fpr48551.c?ref=fe12d76c19ad3eef5a4ac555a519bc14f09d7326", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mcpu=5475\" } */\n+\n+/* This tickles a problem with reload on the m68k.  There's a reasonable\n+   chance it will get stale over time.  */\n+\n+int frob;\n+typedef double SplashCoord;\n+void transform (SplashCoord xi, SplashCoord yi);\n+void\n+arf (SplashCoord x0, SplashCoord y0, SplashCoord x1, SplashCoord y1,\n+     SplashCoord x2, SplashCoord y2, SplashCoord x3, SplashCoord y3,\n+     SplashCoord * matrix, SplashCoord flatness2)\n+{\n+  SplashCoord cx[(1 << 10) + 1][3];\n+  SplashCoord cy[(1 << 10) + 1][3];\n+  SplashCoord xl0, xl1, xl2, xr0, xr1, xr2, xr3, xx1, xx2, xh;\n+  SplashCoord yl0, yl1, yl2, yr0, yr1, yr2, yr3, yy1, yy2, yh;\n+  int p1, p2, p3;\n+  while (p1  < (1 << 10))\n+    {\n+      xl0 = cx[p1][0];\n+      xx2 = cx[p1][2];\n+      yy2 = cy[p1][2];\n+      transform (xx2, yy2);\n+      if (frob)\n+\t{\n+\t  xl1 = (xl0 + xx1);\n+\t  xh = (xx1 + xx2);\n+\t  yl2 = (yl1 + yh);\n+\t  xr2 = (xx2 + xr3);\n+\t  yr2 = (yy2 + yr3) * 0.5;\n+\t  xr1 = (xh + xr2);\n+\t  yr1 = (yh + yr2);\n+\t  xr0 = (xl2 + xr1);\n+\t  yr0 = (yl2 + yr1);\n+\t  cx[p1][1] = xl1;\n+\t  cy[p1][1] = yl1;\n+\t  cx[p1][2] = xl2;\n+\t  cx[p3][0] = xr0;\n+\t  cy[p3][0] = yr0;\n+\t}\n+    }\n+}"}]}