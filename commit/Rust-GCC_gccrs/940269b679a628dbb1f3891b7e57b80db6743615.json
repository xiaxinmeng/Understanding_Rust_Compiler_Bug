{"sha": "940269b679a628dbb1f3891b7e57b80db6743615", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQwMjY5YjY3OWE2MjhkYmIxZjM4OTFiN2U1N2I4MGRiNjc0MzYxNQ==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2017-12-08T10:55:01Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2017-12-08T10:55:01Z"}, "message": "[arm] Generate a -mfpu= option for passing to the assembler\n\nWhen gcc runs with the new -mfpu=auto option (either explicitly or\nwhen that's the default behaviour) then this option is not passed\nthrough to the assembler as we cannot rely on the assembler\nunderstanding it (currently it doesn't understand it at all, but in\nfuture that might change).  That means that the assembler falls back\nto its builtin default, which may not correspond to what the user\nexpected based on the command-line options they passed.\n\nNormally that wouldn't matter because assembler files generated by the\ncompiler will contain explicit directives that set the FPU type\ndirectly and override any internal defaults; but when the compiler\ndriver is used to invoke the assembler directly (because the source\nfile ends in .s or .S) then this might cause a problem if that assumes\nthe FPU matches the compiler.\n\nTo address this, this patch makes the driver construct a -mfpu= option\nfor the assembler in the same way as the compiler generates an\ninternal .fpu directive.  As mentioned, this makes no difference if\nthe assembler file explicitly overrides the command line options, but\nhelps in the case where this is implicit.\n\n\n\t* config/arm/arm.h (arm_asm_auto_mfpu): Declare.\n\t(ASM_CPU_SPEC_FUNCTIONS): Add new rule asm_auto_mfpu.\n\t(ASM_CPU_SPEC): Use it if -mfpu is set to auto.\n\t* common/config/arm/arm-common.c (arm_asm_auto_mfpu): New function.\n-- This line, and those below, will be ignored--\n\nM    gcc/ChangeLog\nM    gcc/common/config/arm/arm-common.c\nM    gcc/config/arm/arm.h\n\nFrom-SVN: r255502", "tree": {"sha": "f8c721ce19f8a0a5fe66c2dba6f051b5a4b28054", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f8c721ce19f8a0a5fe66c2dba6f051b5a4b28054"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/940269b679a628dbb1f3891b7e57b80db6743615", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/940269b679a628dbb1f3891b7e57b80db6743615", "html_url": "https://github.com/Rust-GCC/gccrs/commit/940269b679a628dbb1f3891b7e57b80db6743615", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/940269b679a628dbb1f3891b7e57b80db6743615/comments", "author": null, "committer": null, "parents": [{"sha": "4a53066d0e9be7ef045dabbe497eeeca0ce2c7fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a53066d0e9be7ef045dabbe497eeeca0ce2c7fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a53066d0e9be7ef045dabbe497eeeca0ce2c7fc"}], "stats": {"total": 94, "additions": 92, "deletions": 2}, "files": [{"sha": "435a230fdbdd3ac85aa3112ff23b263087e7c361", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/940269b679a628dbb1f3891b7e57b80db6743615/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/940269b679a628dbb1f3891b7e57b80db6743615/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=940269b679a628dbb1f3891b7e57b80db6743615", "patch": "@@ -1,3 +1,10 @@\n+2017-06-08  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* config/arm/arm.h (arm_asm_auto_mfpu): Declare.\n+\t(ASM_CPU_SPEC_FUNCTIONS): Add new rule asm_auto_mfpu.\n+\t(ASM_CPU_SPEC): Use it if -mfpu is set to auto.\n+\t* common/config/arm/arm-common.c (arm_asm_auto_mfpu): New function.\n+\n 2017-06-08  Tristan Gingold  <gindold@adacore.com>\n \n \tPR ada/81470"}, {"sha": "90b04f1618e39441c2e7395bbea2487f49a3170c", "filename": "gcc/common/config/arm/arm-common.c", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/940269b679a628dbb1f3891b7e57b80db6743615/gcc%2Fcommon%2Fconfig%2Farm%2Farm-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/940269b679a628dbb1f3891b7e57b80db6743615/gcc%2Fcommon%2Fconfig%2Farm%2Farm-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Farm%2Farm-common.c?ref=940269b679a628dbb1f3891b7e57b80db6743615", "patch": "@@ -823,6 +823,86 @@ arm_be8_option (int argc, const char **argv)\n   return \"\";\n }\n \n+/* Generate a -mfpu= option for passing to the assembler.  This is\n+   only called when -mfpu was set (possibly defaulted) to auto and is\n+   needed to ensure that the assembler knows the correct FPU to use.\n+   It wouldn't really be needed except that the compiler can be used\n+   to invoke the assembler directly on hand-written files that lack\n+   the necessary internal .fpu directives.  We assume that the architecture\n+   canonicalization calls have already been made so that we have a final\n+   -march= option to derive the fpu from.  */\n+const char*\n+arm_asm_auto_mfpu (int argc, const char **argv)\n+{\n+  static char *auto_fpu = NULL;\n+  const char *arch = NULL;\n+  static const enum isa_feature fpu_bitlist[]\n+    = { ISA_ALL_FPU_INTERNAL, isa_nobit };\n+  const arch_option *selected_arch;\n+  static const char* fpuname = \"softvfp\";\n+\n+  /* Handle multiple calls to this routine.  */\n+  if (auto_fpu)\n+    {\n+      free (auto_fpu);\n+      auto_fpu = NULL;\n+    }\n+\n+  while (argc)\n+    {\n+      if (strcmp (argv[0], \"arch\") == 0)\n+\tarch = argv[1];\n+      else\n+\tfatal_error (input_location,\n+\t\t     \"unrecognized operand to %%:asm_auto_mfpu\");\n+      argc -= 2;\n+      argv += 2;\n+    }\n+\n+  auto_sbitmap target_isa (isa_num_bits);\n+  auto_sbitmap fpubits (isa_num_bits);\n+\n+  gcc_assert (arch != NULL);\n+  selected_arch = arm_parse_arch_option_name (all_architectures,\n+\t\t\t\t\t      \"-march\", arch);\n+  if (selected_arch == NULL)\n+    return \"\";\n+\n+  arm_initialize_isa (target_isa, selected_arch->common.isa_bits);\n+  arm_parse_option_features (target_isa, &selected_arch->common,\n+\t\t\t     strchr (arch, '+'));\n+  arm_initialize_isa (fpubits, fpu_bitlist);\n+\n+  bitmap_and (fpubits, fpubits, target_isa);\n+\n+  /* The logic below is essentially identical to that in\n+     arm.c:arm_identify_fpu_from_isa(), but that only works in the main\n+     part of the compiler.  */\n+\n+  /* If there are no FPU capability bits, we just pass -mfpu=softvfp.  */\n+  if (!bitmap_empty_p (fpubits))\n+    {\n+      unsigned int i;\n+      auto_sbitmap cand_fpubits (isa_num_bits);\n+      for (i = 0; i < TARGET_FPU_auto; i++)\n+\t{\n+\t  arm_initialize_isa (cand_fpubits, all_fpus[i].isa_bits);\n+\t  if (bitmap_equal_p (fpubits, cand_fpubits))\n+\t    {\n+\t      fpuname = all_fpus[i].name;\n+\t      break;\n+\t    }\n+\t}\n+\n+      gcc_assert (i != TARGET_FPU_auto);\n+    }\n+\n+  auto_fpu = (char *) xmalloc (strlen (fpuname) + sizeof (\"-mfpu=\"));\n+  strcpy (auto_fpu, \"-mfpu=\");\n+  strcat (auto_fpu, fpuname);\n+  return auto_fpu;\n+}\n+\n #undef ARM_CPU_NAME_LENGTH\n \n "}, {"sha": "ac51412fe453bf28a09b3754c3d0b2d4db603412", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/940269b679a628dbb1f3891b7e57b80db6743615/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/940269b679a628dbb1f3891b7e57b80db6743615/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=940269b679a628dbb1f3891b7e57b80db6743615", "patch": "@@ -2166,13 +2166,16 @@ extern int making_const_table;\n \n extern const char *arm_rewrite_mcpu (int argc, const char **argv);\n extern const char *arm_rewrite_march (int argc, const char **argv);\n+extern const char *arm_asm_auto_mfpu (int argc, const char **argv);\n #define ASM_CPU_SPEC_FUNCTIONS\t\t\t\\\n   { \"rewrite_mcpu\", arm_rewrite_mcpu },\t\\\n-  { \"rewrite_march\", arm_rewrite_march },\n+  { \"rewrite_march\", arm_rewrite_march },\t\\\n+  { \"asm_auto_mfpu\", arm_asm_auto_mfpu },\n \n #define ASM_CPU_SPEC\t\t\t\t\t\t\t\\\n+  \" %{mfpu=auto:%<mfpu=auto %:asm_auto_mfpu(%{march=*: arch %*})}\"\t\\\n   \" %{mcpu=generic-*:-march=%:rewrite_march(%{mcpu=generic-*:%*});\"\t\\\n-  \"   march=*:-march=%:rewrite_march(%{march=*:%*});\"\t\t\\\n+  \"   march=*:-march=%:rewrite_march(%{march=*:%*});\"\t\t\t\\\n   \"   mcpu=*:-mcpu=%:rewrite_mcpu(%{mcpu=*:%*})\"\t\t\t\\\n   \" }\"\n "}]}