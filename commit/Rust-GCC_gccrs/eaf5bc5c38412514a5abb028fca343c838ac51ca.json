{"sha": "eaf5bc5c38412514a5abb028fca343c838ac51ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWFmNWJjNWMzODQxMjUxNGE1YWJiMDI4ZmNhMzQzYzgzOGFjNTFjYQ==", "commit": {"author": {"name": "Mark Wielaard", "email": "mark@klomp.org", "date": "2021-09-05T22:48:11Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-09-06T10:07:35Z"}, "message": "Add EnumItem HIR lowering\n\nMake HIT EnumItem class an Item, not VisItem like in the AST. At the\nHIR level EnumItems shouldn't have visibility anymore.\n\nMove struct_field_name_exists to rust-ast-lower.cc with the\ndeclaration in rust-ast-lower.h to make it reusable in the different\nvisitors.\n\nAdd a new ASTLoweringEnumItem that can be used from ASTLoweringItem\nand ASTLoweringStmt. It checks the EnumItems don't have visibility and\nthat EnumItemStruct fields are not duplicated.\n\nAdd a new testcase 'bad_pub_enumitems.rs' to check the no-visibility and\nno-duplicates properties hold.", "tree": {"sha": "e31ad30bd83f58c5944d9b66b7666190f0b338f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e31ad30bd83f58c5944d9b66b7666190f0b338f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eaf5bc5c38412514a5abb028fca343c838ac51ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaf5bc5c38412514a5abb028fca343c838ac51ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eaf5bc5c38412514a5abb028fca343c838ac51ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaf5bc5c38412514a5abb028fca343c838ac51ca/comments", "author": null, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3ac8573495919f1c8f6d6cca6578edd5e3ab01e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3ac8573495919f1c8f6d6cca6578edd5e3ab01e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3ac8573495919f1c8f6d6cca6578edd5e3ab01e"}], "stats": {"total": 518, "additions": 406, "deletions": 112}, "files": [{"sha": "333cb7ba3fbf6066cab4ecd067d4ec40585ebaaa", "filename": "gcc/rust/hir/rust-ast-lower-enumitem.h", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaf5bc5c38412514a5abb028fca343c838ac51ca/gcc%2Frust%2Fhir%2Frust-ast-lower-enumitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaf5bc5c38412514a5abb028fca343c838ac51ca/gcc%2Frust%2Fhir%2Frust-ast-lower-enumitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-enumitem.h?ref=eaf5bc5c38412514a5abb028fca343c838ac51ca", "patch": "@@ -0,0 +1,192 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_LOWER_ENUMITEM\n+#define RUST_AST_LOWER_ENUMITEM\n+\n+#include \"rust-diagnostics.h\"\n+\n+#include \"rust-ast-lower-base.h\"\n+#include \"rust-ast-lower-type.h\"\n+#include \"rust-ast-lower-expr.h\"\n+#include \"rust-hir-full-decls.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+class ASTLoweringEnumItem : public ASTLoweringBase\n+{\n+  using Rust::HIR::ASTLoweringBase::visit;\n+\n+public:\n+  static HIR::EnumItem *translate (AST::EnumItem *item)\n+  {\n+    ASTLoweringEnumItem resolver;\n+    item->accept_vis (resolver);\n+    return resolver.translated;\n+  }\n+\n+  void visit (AST::EnumItem &item) override\n+  {\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, item.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    if (item.has_visibility ())\n+      rust_error_at (item.get_locus (),\n+\t\t     \"visibility qualifier %qs not allowed on enum item\",\n+\t\t     item.get_vis ().as_string ().c_str ());\n+\n+    translated = new HIR::EnumItem (mapping, item.get_identifier (),\n+\t\t\t\t    item.get_outer_attrs (), item.get_locus ());\n+\n+    mappings->insert_defid_mapping (mapping.get_defid (), translated);\n+    mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t       translated);\n+    mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t       item.get_locus ());\n+  }\n+\n+  void visit (AST::EnumItemTuple &item) override\n+  {\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, item.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    if (item.has_visibility ())\n+      rust_error_at (item.get_locus (),\n+\t\t     \"visibility qualifier %qs not allowed on enum item\",\n+\t\t     item.get_vis ().as_string ().c_str ());\n+\n+    std::vector<HIR::TupleField> fields;\n+    for (auto &field : item.get_tuple_fields ())\n+      {\n+\tHIR::Visibility vis = HIR::Visibility::create_public ();\n+\tHIR::Type *type\n+\t  = ASTLoweringType::translate (field.get_field_type ().get ());\n+\n+\tauto crate_num = mappings->get_current_crate ();\n+\tAnalysis::NodeMapping field_mapping (\n+\t  crate_num, field.get_node_id (),\n+\t  mappings->get_next_hir_id (crate_num),\n+\t  mappings->get_next_localdef_id (crate_num));\n+\n+\tHIR::TupleField translated_field (field_mapping,\n+\t\t\t\t\t  std::unique_ptr<HIR::Type> (type),\n+\t\t\t\t\t  vis, field.get_locus (),\n+\t\t\t\t\t  field.get_outer_attrs ());\n+\tfields.push_back (std::move (translated_field));\n+      }\n+\n+    translated\n+      = new HIR::EnumItemTuple (mapping, item.get_identifier (),\n+\t\t\t\tstd::move (fields), item.get_outer_attrs (),\n+\t\t\t\titem.get_locus ());\n+\n+    mappings->insert_defid_mapping (mapping.get_defid (), translated);\n+    mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t       translated);\n+    mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t       item.get_locus ());\n+  }\n+\n+  void visit (AST::EnumItemStruct &item) override\n+  {\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, item.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    if (item.has_visibility ())\n+      rust_error_at (item.get_locus (),\n+\t\t     \"visibility qualifier %qs not allowed on enum item\",\n+\t\t     item.get_vis ().as_string ().c_str ());\n+\n+    std::vector<HIR::StructField> fields;\n+    for (auto &field : item.get_struct_fields ())\n+      {\n+\tHIR::Visibility vis = HIR::Visibility::create_public ();\n+\tHIR::Type *type\n+\t  = ASTLoweringType::translate (field.get_field_type ().get ());\n+\n+\tauto crate_num = mappings->get_current_crate ();\n+\tAnalysis::NodeMapping field_mapping (\n+\t  crate_num, field.get_node_id (),\n+\t  mappings->get_next_hir_id (crate_num),\n+\t  mappings->get_next_localdef_id (crate_num));\n+\n+\tHIR::StructField translated_field (field_mapping,\n+\t\t\t\t\t   field.get_field_name (),\n+\t\t\t\t\t   std::unique_ptr<HIR::Type> (type),\n+\t\t\t\t\t   vis, field.get_locus (),\n+\t\t\t\t\t   field.get_outer_attrs ());\n+\n+\tif (struct_field_name_exists (fields, translated_field))\n+\t  break;\n+\n+\tfields.push_back (std::move (translated_field));\n+      }\n+\n+    translated\n+      = new HIR::EnumItemStruct (mapping, item.get_identifier (),\n+\t\t\t\t std::move (fields), item.get_outer_attrs (),\n+\t\t\t\t item.get_locus ());\n+\n+    mappings->insert_defid_mapping (mapping.get_defid (), translated);\n+    mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t       translated);\n+    mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t       item.get_locus ());\n+  }\n+  void visit (AST::EnumItemDiscriminant &item) override\n+  {\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, item.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    if (item.has_visibility ())\n+      rust_error_at (item.get_locus (),\n+\t\t     \"visibility qualifier %qs not allowed on enum item\",\n+\t\t     item.get_vis ().as_string ().c_str ());\n+\n+    HIR::Expr *expr = ASTLoweringExpr::translate (item.get_expr ().get ());\n+    translated\n+      = new HIR::EnumItemDiscriminant (mapping, item.get_identifier (),\n+\t\t\t\t       std::unique_ptr<HIR::Expr> (expr),\n+\t\t\t\t       item.get_outer_attrs (),\n+\t\t\t\t       item.get_locus ());\n+\n+    mappings->insert_defid_mapping (mapping.get_defid (), translated);\n+    mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t       translated);\n+    mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t       item.get_locus ());\n+  }\n+\n+private:\n+  ASTLoweringEnumItem () : translated (nullptr) {}\n+  HIR::EnumItem *translated;\n+};\n+\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif // RUST_AST_LOWER_ENUMITEM"}, {"sha": "dfc2612608becd1bece922f5cbc6244fc3e6655f", "filename": "gcc/rust/hir/rust-ast-lower-item.h", "status": "modified", "additions": 62, "deletions": 41, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaf5bc5c38412514a5abb028fca343c838ac51ca/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaf5bc5c38412514a5abb028fca343c838ac51ca/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h?ref=eaf5bc5c38412514a5abb028fca343c838ac51ca", "patch": "@@ -22,6 +22,7 @@\n #include \"rust-diagnostics.h\"\n \n #include \"rust-ast-lower-base.h\"\n+#include \"rust-ast-lower-enumitem.h\"\n #include \"rust-ast-lower-type.h\"\n #include \"rust-ast-lower-implitem.h\"\n #include \"rust-ast-lower-stmt.h\"\n@@ -65,7 +66,7 @@ class ASTLoweringItem : public ASTLoweringBase\n     // should be lowered from module.get_vis()\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n \n-    auto items = std::vector<std::unique_ptr<Item> > ();\n+    auto items = std::vector<std::unique_ptr<Item>> ();\n \n     for (auto &item : module.get_items ())\n       {\n@@ -93,11 +94,11 @@ class ASTLoweringItem : public ASTLoweringBase\n \n   void visit (AST::TypeAlias &alias) override\n   {\n-    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n     HIR::WhereClause where_clause (std::move (where_clause_items));\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n \n-    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n     if (alias.has_generics ())\n       generic_params = lower_generic_params (alias.get_generic_params ());\n \n@@ -125,14 +126,14 @@ class ASTLoweringItem : public ASTLoweringBase\n \n   void visit (AST::TupleStruct &struct_decl) override\n   {\n-    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n     if (struct_decl.has_generics ())\n       {\n \tgeneric_params\n \t  = lower_generic_params (struct_decl.get_generic_params ());\n       }\n \n-    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n     HIR::WhereClause where_clause (std::move (where_clause_items));\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n \n@@ -175,35 +176,16 @@ class ASTLoweringItem : public ASTLoweringBase\n \t\t\t       struct_decl.get_locus ());\n   }\n \n-  /* Checks whether the name of a field already exists.  Returns true\n-     and produces an error if so.  */\n-  static bool struct_field_name_exists (std::vector<HIR::StructField> &fields,\n-\t\t\t\t\tHIR::StructField &new_field)\n-  {\n-    for (auto &field : fields)\n-      {\n-\tif (field.get_field_name ().compare (new_field.get_field_name ()) == 0)\n-\t  {\n-\t    RichLocation r (new_field.get_locus ());\n-\t    r.add_range (field.get_locus ());\n-\t    rust_error_at (r, \"duplicate field name %qs\",\n-\t\t\t   field.get_field_name ().c_str ());\n-\t    return true;\n-\t  }\n-      }\n-    return false;\n-  }\n-\n   void visit (AST::StructStruct &struct_decl) override\n   {\n-    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n     if (struct_decl.has_generics ())\n       {\n \tgeneric_params\n \t  = lower_generic_params (struct_decl.get_generic_params ());\n       }\n \n-    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n     HIR::WhereClause where_clause (std::move (where_clause_items));\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n \n@@ -251,16 +233,55 @@ class ASTLoweringItem : public ASTLoweringBase\n \t\t\t       struct_decl.get_locus ());\n   }\n \n+  void visit (AST::Enum &enum_decl) override\n+  {\n+    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n+    if (enum_decl.has_generics ())\n+      {\n+\tgeneric_params = lower_generic_params (enum_decl.get_generic_params ());\n+      }\n+\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n+    HIR::WhereClause where_clause (std::move (where_clause_items));\n+    HIR::Visibility vis = HIR::Visibility::create_public ();\n+\n+    // bool is_unit = enum_decl.is_zero_variant ();\n+    std::vector<std::unique_ptr<HIR::EnumItem>> items;\n+    for (auto &variant : enum_decl.get_variants ())\n+      {\n+\tHIR::EnumItem *hir_item\n+\t  = ASTLoweringEnumItem::translate (variant.get ());\n+\titems.push_back (std::unique_ptr<HIR::EnumItem> (hir_item));\n+      }\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, enum_decl.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    translated = new HIR::Enum (mapping, enum_decl.get_identifier (), vis,\n+\t\t\t\tstd::move (generic_params),\n+\t\t\t\tstd::move (where_clause), /* is_unit, */\n+\t\t\t\tstd::move (items), enum_decl.get_outer_attrs (),\n+\t\t\t\tenum_decl.get_locus ());\n+\n+    mappings->insert_defid_mapping (mapping.get_defid (), translated);\n+    mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t       translated);\n+    mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t       enum_decl.get_locus ());\n+  }\n+\n   void visit (AST::Union &union_decl) override\n   {\n-    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n     if (union_decl.has_generics ())\n       {\n \tgeneric_params\n \t  = lower_generic_params (union_decl.get_generic_params ());\n       }\n \n-    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n     HIR::WhereClause where_clause (std::move (where_clause_items));\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n \n@@ -359,14 +380,14 @@ class ASTLoweringItem : public ASTLoweringBase\n   void visit (AST::Function &function) override\n   {\n     // ignore for now and leave empty\n-    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n     HIR::WhereClause where_clause (std::move (where_clause_items));\n     HIR::FunctionQualifiers qualifiers (\n       HIR::FunctionQualifiers::AsyncConstStatus::NONE, false);\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n \n     // need\n-    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n     if (function.has_generics ())\n       {\n \tgeneric_params = lower_generic_params (function.get_generic_params ());\n@@ -443,12 +464,12 @@ class ASTLoweringItem : public ASTLoweringBase\n \n   void visit (AST::InherentImpl &impl_block) override\n   {\n-    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n \n     HIR::WhereClause where_clause (std::move (where_clause_items));\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n \n-    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n     if (impl_block.has_generics ())\n       {\n \tgeneric_params\n@@ -486,7 +507,7 @@ class ASTLoweringItem : public ASTLoweringBase\n \t\t\t\t   mappings->get_next_hir_id (crate_num),\n \t\t\t\t   mappings->get_next_localdef_id (crate_num));\n \n-    std::vector<std::unique_ptr<HIR::ImplItem> > impl_items;\n+    std::vector<std::unique_ptr<HIR::ImplItem>> impl_items;\n     std::vector<HirId> impl_item_ids;\n     for (auto &impl_item : impl_block.get_impl_items ())\n       {\n@@ -523,12 +544,12 @@ class ASTLoweringItem : public ASTLoweringBase\n \n   void visit (AST::Trait &trait) override\n   {\n-    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n \n     HIR::WhereClause where_clause (std::move (where_clause_items));\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n \n-    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n     if (trait.has_generics ())\n       {\n \tgeneric_params = lower_generic_params (trait.get_generic_params ());\n@@ -557,9 +578,9 @@ class ASTLoweringItem : public ASTLoweringBase\n \t  }\n       }\n \n-    std::vector<std::unique_ptr<HIR::TypeParamBound> > type_param_bounds;\n+    std::vector<std::unique_ptr<HIR::TypeParamBound>> type_param_bounds;\n \n-    std::vector<std::unique_ptr<HIR::TraitItem> > trait_items;\n+    std::vector<std::unique_ptr<HIR::TraitItem>> trait_items;\n     std::vector<HirId> trait_item_ids;\n     for (auto &item : trait.get_trait_items ())\n       {\n@@ -595,12 +616,12 @@ class ASTLoweringItem : public ASTLoweringBase\n \n   void visit (AST::TraitImpl &impl_block) override\n   {\n-    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n \n     HIR::WhereClause where_clause (std::move (where_clause_items));\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n \n-    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n     if (impl_block.has_generics ())\n       {\n \tgeneric_params\n@@ -640,7 +661,7 @@ class ASTLoweringItem : public ASTLoweringBase\n \t\t\t\t   mappings->get_next_hir_id (crate_num),\n \t\t\t\t   mappings->get_next_localdef_id (crate_num));\n \n-    std::vector<std::unique_ptr<HIR::ImplItem> > impl_items;\n+    std::vector<std::unique_ptr<HIR::ImplItem>> impl_items;\n     std::vector<HirId> impl_item_ids;\n     for (auto &impl_item : impl_block.get_impl_items ())\n       {\n@@ -680,7 +701,7 @@ class ASTLoweringItem : public ASTLoweringBase\n   {\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n \n-    std::vector<std::unique_ptr<HIR::ExternalItem> > extern_items;\n+    std::vector<std::unique_ptr<HIR::ExternalItem>> extern_items;\n     for (auto &item : extern_block.get_extern_items ())\n       {\n \tHIR::ExternalItem *lowered"}, {"sha": "ee9b675b76b58b288f8df80d7e6a533f9cef68f5", "filename": "gcc/rust/hir/rust-ast-lower-stmt.h", "status": "modified", "additions": 47, "deletions": 27, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaf5bc5c38412514a5abb028fca343c838ac51ca/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaf5bc5c38412514a5abb028fca343c838ac51ca/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h?ref=eaf5bc5c38412514a5abb028fca343c838ac51ca", "patch": "@@ -22,6 +22,7 @@\n #include \"rust-diagnostics.h\"\n \n #include \"rust-ast-lower-base.h\"\n+#include \"rust-ast-lower-enumitem.h\"\n #include \"rust-ast-lower-type.h\"\n #include \"rust-ast-lower-block.h\"\n #include \"rust-ast-lower-expr.h\"\n@@ -110,14 +111,14 @@ class ASTLoweringStmt : public ASTLoweringBase\n \n   void visit (AST::TupleStruct &struct_decl) override\n   {\n-    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n     if (struct_decl.has_generics ())\n       {\n \tgeneric_params\n \t  = lower_generic_params (struct_decl.get_generic_params ());\n       }\n \n-    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n     HIR::WhereClause where_clause (std::move (where_clause_items));\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n \n@@ -159,35 +160,16 @@ class ASTLoweringStmt : public ASTLoweringBase\n \t\t\t       struct_decl.get_locus ());\n   }\n \n-  /* Checks whether the name of a field already exists.  Returns true\n-     and produces an error if so.  */\n-  static bool struct_field_name_exists (std::vector<HIR::StructField> &fields,\n-\t\t\t\t\tHIR::StructField &new_field)\n-  {\n-    for (auto &field : fields)\n-      {\n-\tif (field.get_field_name ().compare (new_field.get_field_name ()) == 0)\n-\t  {\n-\t    RichLocation r (new_field.get_locus ());\n-\t    r.add_range (field.get_locus ());\n-\t    rust_error_at (r, \"duplicate field name %qs\",\n-\t\t\t   field.get_field_name ().c_str ());\n-\t    return true;\n-\t  }\n-      }\n-    return false;\n-  }\n-\n   void visit (AST::StructStruct &struct_decl) override\n   {\n-    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n     if (struct_decl.has_generics ())\n       {\n \tgeneric_params\n \t  = lower_generic_params (struct_decl.get_generic_params ());\n       }\n \n-    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n     HIR::WhereClause where_clause (std::move (where_clause_items));\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n \n@@ -236,14 +218,14 @@ class ASTLoweringStmt : public ASTLoweringBase\n \n   void visit (AST::Union &union_decl) override\n   {\n-    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n     if (union_decl.has_generics ())\n       {\n \tgeneric_params\n \t  = lower_generic_params (union_decl.get_generic_params ());\n       }\n \n-    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n     HIR::WhereClause where_clause (std::move (where_clause_items));\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n \n@@ -288,6 +270,44 @@ class ASTLoweringStmt : public ASTLoweringBase\n \t\t\t       union_decl.get_locus ());\n   }\n \n+  void visit (AST::Enum &enum_decl) override\n+  {\n+    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n+    if (enum_decl.has_generics ())\n+      {\n+\tgeneric_params = lower_generic_params (enum_decl.get_generic_params ());\n+      }\n+\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n+    HIR::WhereClause where_clause (std::move (where_clause_items));\n+    HIR::Visibility vis = HIR::Visibility::create_public ();\n+\n+    // bool is_unit = enum_decl.is_zero_variant ();\n+    std::vector<std::unique_ptr<HIR::EnumItem>> items;\n+    for (auto &variant : enum_decl.get_variants ())\n+      {\n+\tHIR::EnumItem *hir_item\n+\t  = ASTLoweringEnumItem::translate (variant.get ());\n+\titems.push_back (std::unique_ptr<HIR::EnumItem> (hir_item));\n+      }\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, enum_decl.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    translated = new HIR::Enum (mapping, enum_decl.get_identifier (), vis,\n+\t\t\t\tstd::move (generic_params),\n+\t\t\t\tstd::move (where_clause), /* is_unit, */\n+\t\t\t\tstd::move (items), enum_decl.get_outer_attrs (),\n+\t\t\t\tenum_decl.get_locus ());\n+\n+    mappings->insert_hir_stmt (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t       translated);\n+    mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t       enum_decl.get_locus ());\n+  }\n+\n   void visit (AST::EmptyStmt &empty) override\n   {\n     auto crate_num = mappings->get_current_crate ();\n@@ -306,14 +326,14 @@ class ASTLoweringStmt : public ASTLoweringBase\n   void visit (AST::Function &function) override\n   {\n     // ignore for now and leave empty\n-    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n     HIR::WhereClause where_clause (std::move (where_clause_items));\n     HIR::FunctionQualifiers qualifiers (\n       HIR::FunctionQualifiers::AsyncConstStatus::NONE, false);\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n \n     // need\n-    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n     if (function.has_generics ())\n       {\n \tgeneric_params = lower_generic_params (function.get_generic_params ());"}, {"sha": "b64e1a05438c91dfefd2e364ca01a78d45ad281a", "filename": "gcc/rust/hir/rust-ast-lower.cc", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaf5bc5c38412514a5abb028fca343c838ac51ca/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaf5bc5c38412514a5abb028fca343c838ac51ca/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower.cc?ref=eaf5bc5c38412514a5abb028fca343c838ac51ca", "patch": "@@ -520,5 +520,25 @@ ASTLoweringBase::lower_bound (AST::TypeParamBound *bound)\n   return ASTLoweringTypeBounds::translate (bound);\n }\n \n+/* Checks whether the name of a field already exists.  Returns true\n+   and produces an error if so.  */\n+bool\n+struct_field_name_exists (std::vector<HIR::StructField> &fields,\n+\t\t\t  HIR::StructField &new_field)\n+{\n+  for (auto &field : fields)\n+    {\n+      if (field.get_field_name ().compare (new_field.get_field_name ()) == 0)\n+\t{\n+\t  RichLocation r (new_field.get_locus ());\n+\t  r.add_range (field.get_locus ());\n+\t  rust_error_at (r, \"duplicate field name %qs\",\n+\t\t\t field.get_field_name ().c_str ());\n+\t  return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n } // namespace HIR\n } // namespace Rust"}, {"sha": "254f68649dbd3d45c3199c035eab3fd398f12764", "filename": "gcc/rust/hir/rust-ast-lower.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaf5bc5c38412514a5abb028fca343c838ac51ca/gcc%2Frust%2Fhir%2Frust-ast-lower.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaf5bc5c38412514a5abb028fca343c838ac51ca/gcc%2Frust%2Fhir%2Frust-ast-lower.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower.h?ref=eaf5bc5c38412514a5abb028fca343c838ac51ca", "patch": "@@ -27,6 +27,11 @@\n namespace Rust {\n namespace HIR {\n \n+/* Checks whether the name of a field already exists.  Returns true\n+   and produces an error if so.  */\n+bool\n+struct_field_name_exists (std::vector<HIR::StructField> &fields,\n+\t\t\t  HIR::StructField &new_field);\n class ASTLowering\n {\n public:"}, {"sha": "b0e418c166b0819127cd070b36519a261a876e9f", "filename": "gcc/rust/hir/tree/rust-hir-full-test.cc", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaf5bc5c38412514a5abb028fca343c838ac51ca/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaf5bc5c38412514a5abb028fca343c838ac51ca/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc?ref=eaf5bc5c38412514a5abb028fca343c838ac51ca", "patch": "@@ -3086,23 +3086,8 @@ StructExprStructFields::as_string () const\n std::string\n EnumItem::as_string () const\n {\n-  // outer attributes\n-  std::string str = \"outer attributes: \";\n-  if (outer_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"outer attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : outer_attrs)\n-\t{\n-\t  str += \"\\n  \" + attr.as_string ();\n-\t}\n-    }\n-\n-  str += \"\\n\" + variant_name;\n+  std::string str = Item::as_string ();\n+  str += variant_name;\n \n   return str;\n }"}, {"sha": "35b1c64e6d2aea3e6cf7e9102c5303bdde38af9a", "filename": "gcc/rust/hir/tree/rust-hir-item.h", "status": "modified", "additions": 31, "deletions": 27, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaf5bc5c38412514a5abb028fca343c838ac51ca/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaf5bc5c38412514a5abb028fca343c838ac51ca/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h?ref=eaf5bc5c38412514a5abb028fca343c838ac51ca", "patch": "@@ -1636,44 +1636,41 @@ class TupleStruct : public Struct\n };\n \n /* An item used in an \"enum\" tagged union - not abstract: base represents a\n- * name-only enum */\n-class EnumItem\n+   name-only enum. Syntactically EnumItem's can have a Visibility. But not\n+   Semantically. So check there is no Visibility when lowering and make this\n+   an Item, not an VisItem.  */\n+class EnumItem : public Item\n {\n-  // bool has_attrs;\n-  AST::AttrVec outer_attrs;\n-\n   Identifier variant_name;\n \n   Location locus;\n \n public:\n   virtual ~EnumItem () {}\n \n-  // Returns whether enum item has outer attributes.\n-  bool has_outer_attrs () const { return !outer_attrs.empty (); }\n-\n-  EnumItem (Identifier variant_name, AST::AttrVec outer_attrs, Location locus)\n-    : outer_attrs (std::move (outer_attrs)),\n+  EnumItem (Analysis::NodeMapping mappings, Identifier variant_name,\n+\t    AST::AttrVec outer_attrs, Location locus)\n+    : Item (std::move (mappings), std::move (outer_attrs)),\n       variant_name (std::move (variant_name)), locus (locus)\n   {}\n \n   // Unique pointer custom clone function\n   std::unique_ptr<EnumItem> clone_enum_item () const\n   {\n-    return std::unique_ptr<EnumItem> (clone_enum_item_impl ());\n+    return std::unique_ptr<EnumItem> (clone_item_impl ());\n   }\n \n   virtual std::string as_string () const;\n \n   // not pure virtual as not abstract\n   virtual void accept_vis (HIRVisitor &vis);\n \n+  Location get_locus () const { return locus; }\n+\n+  Identifier get_identifier () const { return variant_name; }\n+\n protected:\n-  // Clone function implementation as (not pure) virtual method\n-  virtual EnumItem *clone_enum_item_impl () const\n-  {\n-    return new EnumItem (*this);\n-  }\n+  EnumItem *clone_item_impl () const override { return new EnumItem (*this); }\n };\n \n // A tuple item used in an \"enum\" tagged union\n@@ -1686,9 +1683,11 @@ class EnumItemTuple : public EnumItem\n   // Returns whether tuple enum item has tuple fields.\n   bool has_tuple_fields () const { return !tuple_fields.empty (); }\n \n-  EnumItemTuple (Identifier variant_name, std::vector<TupleField> tuple_fields,\n-\t\t AST::AttrVec outer_attrs, Location locus)\n-    : EnumItem (std::move (variant_name), std::move (outer_attrs), locus),\n+  EnumItemTuple (Analysis::NodeMapping mappings, Identifier variant_name,\n+\t\t std::vector<TupleField> tuple_fields, AST::AttrVec outer_attrs,\n+\t\t Location locus)\n+    : EnumItem (std::move (mappings), std::move (variant_name),\n+\t\tstd::move (outer_attrs), locus),\n       tuple_fields (std::move (tuple_fields))\n   {}\n \n@@ -1698,7 +1697,7 @@ class EnumItemTuple : public EnumItem\n \n protected:\n   // Clone function implementation as (not pure) virtual method\n-  EnumItemTuple *clone_enum_item_impl () const override\n+  EnumItemTuple *clone_item_impl () const override\n   {\n     return new EnumItemTuple (*this);\n   }\n@@ -1714,10 +1713,11 @@ class EnumItemStruct : public EnumItem\n   // Returns whether struct enum item has struct fields.\n   bool has_struct_fields () const { return !struct_fields.empty (); }\n \n-  EnumItemStruct (Identifier variant_name,\n+  EnumItemStruct (Analysis::NodeMapping mappings, Identifier variant_name,\n \t\t  std::vector<StructField> struct_fields,\n \t\t  AST::AttrVec outer_attrs, Location locus)\n-    : EnumItem (std::move (variant_name), std::move (outer_attrs), locus),\n+    : EnumItem (std::move (mappings), std::move (variant_name),\n+\t\tstd::move (outer_attrs), locus),\n       struct_fields (std::move (struct_fields))\n   {}\n \n@@ -1727,7 +1727,7 @@ class EnumItemStruct : public EnumItem\n \n protected:\n   // Clone function implementation as (not pure) virtual method\n-  EnumItemStruct *clone_enum_item_impl () const override\n+  EnumItemStruct *clone_item_impl () const override\n   {\n     return new EnumItemStruct (*this);\n   }\n@@ -1739,9 +1739,11 @@ class EnumItemDiscriminant : public EnumItem\n   std::unique_ptr<Expr> expression;\n \n public:\n-  EnumItemDiscriminant (Identifier variant_name, std::unique_ptr<Expr> expr,\n-\t\t\tAST::AttrVec outer_attrs, Location locus)\n-    : EnumItem (std::move (variant_name), std::move (outer_attrs), locus),\n+  EnumItemDiscriminant (Analysis::NodeMapping mappings, Identifier variant_name,\n+\t\t\tstd::unique_ptr<Expr> expr, AST::AttrVec outer_attrs,\n+\t\t\tLocation locus)\n+    : EnumItem (std::move (mappings), std::move (variant_name),\n+\t\tstd::move (outer_attrs), locus),\n       expression (std::move (expr))\n   {}\n \n@@ -1771,7 +1773,7 @@ class EnumItemDiscriminant : public EnumItem\n \n protected:\n   // Clone function implementation as (not pure) virtual method\n-  EnumItemDiscriminant *clone_enum_item_impl () const override\n+  EnumItemDiscriminant *clone_item_impl () const override\n   {\n     return new EnumItemDiscriminant (*this);\n   }\n@@ -1861,6 +1863,8 @@ class Enum : public VisItem\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  Identifier get_identifier () const { return enum_name; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */"}, {"sha": "e7fd5edb9811c2acca873b4e7d3eb9f9083b4d6e", "filename": "gcc/testsuite/rust/compile/bad_pub_enumitems.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaf5bc5c38412514a5abb028fca343c838ac51ca/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbad_pub_enumitems.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaf5bc5c38412514a5abb028fca343c838ac51ca/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbad_pub_enumitems.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbad_pub_enumitems.rs?ref=eaf5bc5c38412514a5abb028fca343c838ac51ca", "patch": "@@ -0,0 +1,47 @@\n+pub enum E\n+{\n+  pub A { a: i32 }, // { dg-error \"visibility qualifier\" }\n+  B (u8),\n+  pub C, // { dg-error \"visibility qualifier\" }\n+  D\n+}\n+\n+enum E1\n+{\n+  A,\n+  pub B = 42, // { dg-error \"visibility qualifier\" }\n+  C = 3,\n+  D,\n+  pub E // { dg-error \"visibility qualifier\" }\n+}\n+\n+enum E2\n+{\n+  pub A (u8, i32, u64), // { dg-error \"visibility qualifier\" }\n+  B { a: u8, a: u8 }  // { dg-error \"duplicate field\" }}\n+}\n+\n+fn main ()\n+{\n+  enum EE\n+    {\n+      Alpha { alpha: i32 },\n+      pub Beta (u8), // { dg-error \"visibility qualifier\" }\n+      pub Gamma, // { dg-error \"visibility qualifier\" }\n+      Delta { delta: u32 }\n+    }\n+\n+  enum EE1\n+    {\n+      pub Alpha, // { dg-error \"visibility qualifier\" }\n+      Beta = 41,\n+      pub Gamma = 3, // { dg-error \"visibility qualifier\" }\n+      Delta,\n+    }\n+\n+  enum E2\n+    {\n+      Alpha { a: u8, a: u8 },  // { dg-error \"duplicate field\" }}\n+      pub Beta (u8, i32, u64) // { dg-error \"visibility qualifier\" }\n+    }\n+}"}]}