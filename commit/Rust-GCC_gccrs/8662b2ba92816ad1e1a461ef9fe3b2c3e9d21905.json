{"sha": "8662b2ba92816ad1e1a461ef9fe3b2c3e9d21905", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODY2MmIyYmE5MjgxNmFkMWUxYTQ2MWVmOWZlM2IyYzNlOWQyMTkwNQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-07-09T15:41:31Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-07-09T15:41:31Z"}, "message": "pdp11.md (define_c_enum \"unspecv\"): New.\n\n\t* config/pdp11/pdp11.md (define_c_enum \"unspecv\"): New.\n\t(prologue, epilogue): New.\n\t(return, *rts): New.\n\t(blockage, setd, seti): New.\n\t* config/pdp11/pdp11.c (TARGET_ASM_FUNCTION_PROLOGUE): Remove.\n\t(TARGET_ASM_FUNCTION_EPILOGUE): Remove.\n\t(pdp11_saved_regno): New.\n\t(pdp11_expand_prologue): Rename from pdp11_output_function_prologue;\n\tgenerate rtl instead of text.\n\t(pdp11_expand_epilogue): Similarly from pdp11_output_function_epilogue.\n\t(pdp11_sp_frame_offset): Export.  Use pdp11_saved_regno.\n\t* config/pdp11/pdp11-protos.h: Update.\n\nFrom-SVN: r176082", "tree": {"sha": "3315e7a8955f0c9e0124919e79de774a9cf458c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3315e7a8955f0c9e0124919e79de774a9cf458c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8662b2ba92816ad1e1a461ef9fe3b2c3e9d21905", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8662b2ba92816ad1e1a461ef9fe3b2c3e9d21905", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8662b2ba92816ad1e1a461ef9fe3b2c3e9d21905", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8662b2ba92816ad1e1a461ef9fe3b2c3e9d21905/comments", "author": null, "committer": null, "parents": [{"sha": "28b21ebbdb7bc48a1f3de36bf4f98a58a00c54ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28b21ebbdb7bc48a1f3de36bf4f98a58a00c54ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28b21ebbdb7bc48a1f3de36bf4f98a58a00c54ec"}], "stats": {"total": 433, "additions": 255, "deletions": 178}, "files": [{"sha": "cbc027fb93305a1d60c13b3b8c3f0916055b882c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8662b2ba92816ad1e1a461ef9fe3b2c3e9d21905/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8662b2ba92816ad1e1a461ef9fe3b2c3e9d21905/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8662b2ba92816ad1e1a461ef9fe3b2c3e9d21905", "patch": "@@ -1,3 +1,18 @@\n+2011-07-09  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/pdp11/pdp11.md (define_c_enum \"unspecv\"): New.\n+\t(prologue, epilogue): New.\n+\t(return, *rts): New.\n+\t(blockage, setd, seti): New.\n+\t* config/pdp11/pdp11.c (TARGET_ASM_FUNCTION_PROLOGUE): Remove.\n+\t(TARGET_ASM_FUNCTION_EPILOGUE): Remove.\n+\t(pdp11_saved_regno): New.\n+\t(pdp11_expand_prologue): Rename from pdp11_output_function_prologue;\n+\tgenerate rtl instead of text.\n+\t(pdp11_expand_epilogue): Similarly from pdp11_output_function_epilogue.\n+\t(pdp11_sp_frame_offset): Export.  Use pdp11_saved_regno.\n+\t* config/pdp11/pdp11-protos.h: Update.\n+\n 2011-07-09  Richard Henderson  <rth@redhat.com>\n \n \t* config/rs6000/rs6000.c (rs6000_output_function_prologue): Don't"}, {"sha": "bb13309f34bb38dd646d58a0c98397023fba033c", "filename": "gcc/config/pdp11/pdp11-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8662b2ba92816ad1e1a461ef9fe3b2c3e9d21905/gcc%2Fconfig%2Fpdp11%2Fpdp11-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8662b2ba92816ad1e1a461ef9fe3b2c3e9d21905/gcc%2Fconfig%2Fpdp11%2Fpdp11-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11-protos.h?ref=8662b2ba92816ad1e1a461ef9fe3b2c3e9d21905", "patch": "@@ -38,10 +38,13 @@ typedef enum { no_action, dec_before, inc_after } pdp11_action;\n typedef enum { little, either, big } pdp11_partorder;\n extern bool pdp11_expand_operands (rtx *, rtx [][2], int, \n \t\t\t\t   pdp11_action *, pdp11_partorder);\n+extern int pdp11_sp_frame_offset (void);\n extern int pdp11_initial_elimination_offset (int, int);\n extern enum reg_class pdp11_regno_reg_class (int);\n \n #endif /* RTX_CODE */\n \n extern void output_ascii (FILE *, const char *, int);\n extern void pdp11_asm_output_var (FILE *, const char *, int, int, bool);\n+extern void pdp11_expand_prologue (void);\n+extern void pdp11_expand_epilogue (void);"}, {"sha": "63e99865dd663a84cfdba060d2f65637d18b2b7b", "filename": "gcc/config/pdp11/pdp11.c", "status": "modified", "additions": 186, "deletions": 178, "changes": 364, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8662b2ba92816ad1e1a461ef9fe3b2c3e9d21905/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8662b2ba92816ad1e1a461ef9fe3b2c3e9d21905/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.c?ref=8662b2ba92816ad1e1a461ef9fe3b2c3e9d21905", "patch": "@@ -141,8 +141,6 @@ decode_pdp11_d (const struct real_format *fmt ATTRIBUTE_UNUSED,\n \n static const char *singlemove_string (rtx *);\n static bool pdp11_assemble_integer (rtx, unsigned int, int);\n-static void pdp11_output_function_prologue (FILE *, HOST_WIDE_INT);\n-static void pdp11_output_function_epilogue (FILE *, HOST_WIDE_INT);\n static bool pdp11_rtx_costs (rtx, int, int, int *, bool);\n static bool pdp11_return_in_memory (const_tree, const_tree);\n static rtx pdp11_function_value (const_tree, const_tree, bool);\n@@ -166,11 +164,6 @@ static bool pdp11_legitimate_constant_p (enum machine_mode, rtx);\n #undef TARGET_ASM_INTEGER\n #define TARGET_ASM_INTEGER pdp11_assemble_integer\n \n-#undef TARGET_ASM_FUNCTION_PROLOGUE\n-#define TARGET_ASM_FUNCTION_PROLOGUE pdp11_output_function_prologue\n-#undef TARGET_ASM_FUNCTION_EPILOGUE\n-#define TARGET_ASM_FUNCTION_EPILOGUE pdp11_output_function_epilogue\n-\n #undef TARGET_ASM_OPEN_PAREN\n #define TARGET_ASM_OPEN_PAREN \"[\"\n #undef TARGET_ASM_CLOSE_PAREN\n@@ -227,95 +220,92 @@ static bool pdp11_legitimate_constant_p (enum machine_mode, rtx);\n #undef  TARGET_LEGITIMATE_CONSTANT_P\n #define TARGET_LEGITIMATE_CONSTANT_P pdp11_legitimate_constant_p\n \f\n-/*\n-   stream is a stdio stream to output the code to.\n-   size is an int: how many units of temporary storage to allocate.\n-   Refer to the array `regs_ever_live' to determine which registers\n-   to save; `regs_ever_live[I]' is nonzero if register number I\n-   is ever used in the function.  This macro is responsible for\n-   knowing which registers should not be saved even if used.  \n-*/\n+/* A helper function to determine if REGNO should be saved in the\n+   current function's stack frame.  */\n \n-static void\n-pdp11_output_function_prologue (FILE *stream, HOST_WIDE_INT size)\n-{\t\t\t\t\t\t\t       \n-    HOST_WIDE_INT fsize = ((size) + 1) & ~1;\n-    int regno;\n-    int via_ac = -1;\n+static inline bool\n+pdp11_saved_regno (unsigned regno)\n+{\n+  return !call_used_regs[regno] && df_regs_ever_live_p (regno);\n+}\n \n-    fprintf (stream,\n-\t     \"\\n\\t;\t/* function prologue %s*/\\n\",\n-\t     current_function_name ());\n+/* Expand the function prologue.  */\n \n-    /* if we are outputting code for main, \n-       the switch FPU to right mode if TARGET_FPU */\n-    if (MAIN_NAME_P (DECL_NAME (current_function_decl)) && TARGET_FPU)\n+void\n+pdp11_expand_prologue (void)\n+{\t\t\t\t\t\t\t       \n+  HOST_WIDE_INT fsize = get_frame_size ();\n+  unsigned regno;\n+  rtx x, via_ac = NULL;\n+\n+  /* If we are outputting code for main, the switch FPU to the\n+     right mode if TARGET_FPU.  */\n+  if (MAIN_NAME_P (DECL_NAME (current_function_decl)) && TARGET_FPU)\n     {\n-\tfprintf(stream,\n-\t\t\"\\t;/* switch cpu to double float, single integer */\\n\");\n-\tfprintf(stream, \"\\tsetd\\n\");\n-\tfprintf(stream, \"\\tseti\\n\\n\");\n+      emit_insn (gen_setd ());\n+      emit_insn (gen_seti ());\n     }\n     \n-    if (frame_pointer_needed) \t\t\t\t\t\n-    {\t\t\t\t\t\t\t\t\n-\tfprintf(stream, \"\\tmov r5, -(sp)\\n\");\t\t\t\n-\tfprintf(stream, \"\\tmov sp, r5\\n\");\t\t\t\t\n-    }\t\t\t\t\t\t\t\t\n-    else \t\t\t\t\t\t\t\t\n+  if (frame_pointer_needed) \t\t\t\t\t\n     {\t\t\t\t\t\t\t\t\n-\t/* DON'T SAVE FP */\n+      x = gen_rtx_PRE_DEC (Pmode, stack_pointer_rtx);\n+      x = gen_frame_mem (Pmode, x);\n+      emit_move_insn (x, hard_frame_pointer_rtx);\n+\n+      emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx);\n     }\t\t\t\t\t\t\t\t\n \n-    /* make frame */\n-    if (fsize)\t\t\t\t\t\t\t\n-\tasm_fprintf (stream, \"\\tsub $%#wo, sp\\n\", fsize);\n-\n-    /* save CPU registers  */\n-    for (regno = R0_REGNUM; regno <= PC_REGNUM; regno++)\t\t\t\t\n-      if (df_regs_ever_live_p (regno) && ! call_used_regs[regno])\t\n-\t    if (! ((regno == FRAME_POINTER_REGNUM)\t\t\t\n-\t\t   && frame_pointer_needed))\t\t\t\t\n-\t\tfprintf (stream, \"\\tmov %s, -(sp)\\n\", reg_names[regno]);\t\n-    /* fpu regs saving */\n-    \n-    /* via_ac specifies the ac to use for saving ac4, ac5 */\n-    via_ac = -1;\n-    \n-    for (regno = AC0_REGNUM; regno <= AC5_REGNUM ; regno++) \n+  /* Make frame.  */\n+  if (fsize)\n     {\n-\t/* ac0 - ac3 */\t\t\t\t\t\t\n-\tif (LOAD_FPU_REG_P(regno)\n-\t    && df_regs_ever_live_p (regno) \n-\t    && ! call_used_regs[regno])\n-\t{\n-\t    fprintf (stream, \"\\tstd %s, -(sp)\\n\", reg_names[regno]);\n-\t    via_ac = regno;\n-\t}\n-\t\n-\t/* maybe make ac4, ac5 call used regs?? */\n-\t/* ac4 - ac5 */\n-\tif (NO_LOAD_FPU_REG_P(regno)\n-\t    && df_regs_ever_live_p (regno)\n-\t    && ! call_used_regs[regno])\n-\t{\n-\t  gcc_assert (via_ac != -1);\n-\t  fprintf (stream, \"\\tldd %s, %s\\n\",\n-\t\t   reg_names[regno], reg_names[via_ac]);\n-\t  fprintf (stream, \"\\tstd %s, -(sp)\\n\", reg_names[via_ac]);\n-\t}\n+      emit_insn (gen_addhi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t     GEN_INT (-fsize)));\n+\n+      /* Prevent frame references via the frame pointer from being\n+\t scheduled before the frame is allocated.  */\n+      if (frame_pointer_needed)\n+\temit_insn (gen_blockage ());\n     }\n \n-    fprintf (stream, \"\\t;/* end of prologue */\\n\\n\");\t\t\n+  /* Save CPU registers.  */\n+  for (regno = R0_REGNUM; regno <= PC_REGNUM; regno++)\n+    if (pdp11_saved_regno (regno)\n+\t&& (regno != HARD_FRAME_POINTER_REGNUM || !frame_pointer_needed))\n+      {\n+\tx = gen_rtx_PRE_DEC (Pmode, stack_pointer_rtx);\n+\tx = gen_frame_mem (Pmode, x);\n+\temit_move_insn (x, gen_rtx_REG (Pmode, regno));\n+      }\n+\n+  /* Save FPU registers.  */\n+  for (regno = AC0_REGNUM; regno <= AC3_REGNUM; regno++) \n+    if (pdp11_saved_regno (regno))\n+      {\n+\tx = gen_rtx_PRE_DEC (Pmode, stack_pointer_rtx);\n+\tx = gen_frame_mem (DFmode, x);\n+\tvia_ac = gen_rtx_REG (DFmode, regno);\n+\temit_move_insn (x, via_ac);\n+      }\n+\n+  /* ??? Maybe make ac4, ac5 call used regs?? */\n+  for (regno = AC4_REGNUM; regno <= AC5_REGNUM; regno++)\n+    if (pdp11_saved_regno (regno))\n+      {\n+\tgcc_assert (via_ac != NULL);\n+\temit_move_insn (via_ac, gen_rtx_REG (DFmode, regno));\n+\n+\tx = gen_rtx_PRE_DEC (Pmode, stack_pointer_rtx);\n+\tx = gen_frame_mem (DFmode, x);\n+\temit_move_insn (x, via_ac);\n+      }\n }\n \n-/*\n-   The function epilogue should not depend on the current stack pointer!\n+/* The function epilogue should not depend on the current stack pointer!\n    It should use the frame pointer only.  This is mandatory because\n    of alloca; we also take advantage of it to omit stack adjustments\n    before returning.  */\n \n-/* maybe we can make leaf functions faster by switching to the\n+/* Maybe we can make leaf functions faster by switching to the\n    second register file - this way we don't have to save regs!\n    leaf functions are ~ 50% of all functions (dynamically!) \n \n@@ -328,109 +318,127 @@ pdp11_output_function_prologue (FILE *stream, HOST_WIDE_INT size)\n \n    maybe as option if you want to generate code for kernel mode? */\n \n-static void\n-pdp11_output_function_epilogue (FILE *stream, HOST_WIDE_INT size)\n+void\n+pdp11_expand_epilogue (void)\n {\t\t\t\t\t\t\t\t\n-    HOST_WIDE_INT fsize = ((size) + 1) & ~1;\n-    int i, j, k;\n+  HOST_WIDE_INT fsize = get_frame_size ();\n+  unsigned regno;\n+  rtx x, reg, via_ac = NULL;\n \n-    int via_ac;\n-    \n-    fprintf (stream, \"\\n\\t;\t/*function epilogue */\\n\");\t\t\n+  if (pdp11_saved_regno (AC4_REGNUM) || pdp11_saved_regno (AC5_REGNUM))\n+    {\n+      /* Find a temporary with which to restore AC4/5.  */\n+      for (regno = AC0_REGNUM; regno <= AC3_REGNUM; regno++)\n+\tif (pdp11_saved_regno (regno))\n+\t  {\n+\t    via_ac = gen_rtx_REG (DFmode, regno);\n+\t    break;\n+\t  }\n+    }\n \n-    if (frame_pointer_needed)\t\t\t\t\t\n-    {\t\t\t\t\t\t\t\t\n-\t/* hope this is safe - m68k does it also .... */\t\t\n-        df_set_regs_ever_live (FRAME_POINTER_REGNUM, false);\n-\t\t\t\t\t\t\t\t\n-\tfor (i = PC_REGNUM, j = 0 ; i >= 0 ; i--)\t\t\t\t\n-\t  if (df_regs_ever_live_p (i) && ! call_used_regs[i])\t\t\n-\t\tj++;\n-\t\n-\t/* remember # of pushed bytes for CPU regs */\n-\tk = 2*j;\n-\t\n-\t/* change fp -> r5 due to the compile error on libgcc2.c */\n-\tfor (i = PC_REGNUM ; i >= R0_REGNUM ; i--)\t\t\t\t\t\n-\t  if (df_regs_ever_live_p (i) && ! call_used_regs[i])\t\t\n-\t\tfprintf(stream, \"\\tmov %#\" HOST_WIDE_INT_PRINT \"o(r5), %s\\n\",\n-\t\t\t(-fsize-2*j--)&0xffff, reg_names[i]);\n-\n-\t/* get ACs */\t\t\t\t\t\t\n-\tvia_ac = AC5_REGNUM;\n-\t\n-\tfor (i = AC5_REGNUM; i >= AC0_REGNUM; i--)\n-\t  if (df_regs_ever_live_p (i) && ! call_used_regs[i])\n-\t    {\n-\t\tvia_ac = i;\n-\t\tk += 8;\n-\t    }\n-\t\n-\tfor (i = AC5_REGNUM; i >= AC0_REGNUM; i--)\n-\t{\n-\t    if (LOAD_FPU_REG_P(i)\n-\t\t&& df_regs_ever_live_p (i)\n-\t\t&& ! call_used_regs[i])\n-\t    {\n-\t\tfprintf(stream, \"\\tldd %#\" HOST_WIDE_INT_PRINT \"o(r5), %s\\n\",\n-\t\t\t(-fsize-k)&0xffff, reg_names[i]);\n-\t\tk -= 8;\n-\t    }\n-\t    \n-\t    if (NO_LOAD_FPU_REG_P(i)\n-\t\t&& df_regs_ever_live_p (i)\n-\t\t&& ! call_used_regs[i])\n-\t    {\n-\t        gcc_assert (LOAD_FPU_REG_P(via_ac));\n-\t\t    \n-\t\tfprintf(stream, \"\\tldd %#\" HOST_WIDE_INT_PRINT \"o(r5), %s\\n\",\n-\t\t\t(-fsize-k)&0xffff, reg_names[via_ac]);\n-\t\tfprintf(stream, \"\\tstd %s, %s\\n\", reg_names[via_ac], reg_names[i]);\n-\t\tk -= 8;\n-\t    }\n-\t}\n-\t\n-\tfprintf(stream, \"\\tmov r5, sp\\n\");\t\t\t\t\n-\tfprintf (stream, \"\\tmov (sp)+, r5\\n\");     \t\t\t\n-    }\t\t\t\t\t\t\t\t\n-    else\t\t\t\t\t\t\t\t\n-    {\t\t   \n-      via_ac = AC5_REGNUM;\n-\t\n-\t/* get ACs */\n-\tfor (i = AC5_REGNUM; i >= AC0_REGNUM; i--)\n-\t  if (df_regs_ever_live_p (i) && ! call_used_regs[i])\n-\t\tvia_ac = i;\n-\t\n-\tfor (i = AC5_REGNUM; i >= AC0_REGNUM; i--)\n+  /* If possible, restore registers via pops.  */\n+  if (!frame_pointer_needed || current_function_sp_is_unchanging)\n+    {\n+      /* Restore registers via pops.  */\n+\n+      for (regno = AC5_REGNUM; regno >= AC0_REGNUM; regno--)\n+\tif (pdp11_saved_regno (regno))\n+\t  {\n+\t    x = gen_rtx_POST_INC (Pmode, stack_pointer_rtx);\n+\t    x = gen_frame_mem (DFmode, x);\n+\t    reg = gen_rtx_REG (DFmode, regno);\n+\n+\t    if (LOAD_FPU_REG_P (regno))\n+\t      emit_move_insn (reg, x);\n+\t    else\n+\t      {\n+\t        emit_move_insn (via_ac, x);\n+\t\temit_move_insn (reg, via_ac);\n+\t      }\n+\t  }\n+\n+      for (regno = PC_REGNUM; regno >= R0_REGNUM + 2; regno--)\n+\tif (pdp11_saved_regno (regno)\n+\t    && (regno != HARD_FRAME_POINTER_REGNUM || !frame_pointer_needed))\n+\t  {\n+\t    x = gen_rtx_POST_INC (Pmode, stack_pointer_rtx);\n+\t    x = gen_frame_mem (Pmode, x);\n+\t    emit_move_insn (gen_rtx_REG (Pmode, regno), x);\n+\t  }\n+    }\n+  else\n+    {\n+      /* Restore registers via moves.  */\n+      /* ??? If more than a few registers need to be restored, it's smaller\n+\t to generate a pointer through which we can emit pops.  Consider\n+\t that moves cost 2*NREG words and pops cost NREG+3 words.  This\n+\t means that the crossover is NREG=3.\n+\n+\t Possible registers to use are:\n+\t  (1) The first call-saved general register.  This register will\n+\t\tbe restored with the last pop.\n+\t  (2) R1, if it's not used as a return register.\n+\t  (3) FP itself.  This option may result in +4 words, since we\n+\t\tmay need two add imm,rn instructions instead of just one.\n+\t\tThis also has the downside that we're not representing\n+\t\tthe unwind info in any way, so during the epilogue the\n+\t\tdebugger may get lost.  */\n+\n+      HOST_WIDE_INT ofs = -pdp11_sp_frame_offset ();\n+\n+      for (regno = AC5_REGNUM; regno >= AC0_REGNUM; regno--)\n+\tif (pdp11_saved_regno (regno))\n+\t  {\n+\t    x = plus_constant (hard_frame_pointer_rtx, ofs);\n+\t    x = gen_frame_mem (DFmode, x);\n+\t    reg = gen_rtx_REG (DFmode, regno);\n+\n+\t    if (LOAD_FPU_REG_P (regno))\n+\t      emit_move_insn (reg, x);\n+\t    else\n+\t      {\n+\t        emit_move_insn (via_ac, x);\n+\t\temit_move_insn (reg, via_ac);\n+\t      }\n+\t    ofs += 8;\n+\t  }\n+\n+      for (regno = PC_REGNUM; regno >= R0_REGNUM + 2; regno--)\n+\tif (pdp11_saved_regno (regno)\n+\t    && (regno != HARD_FRAME_POINTER_REGNUM || !frame_pointer_needed))\n+\t  {\n+\t    x = plus_constant (hard_frame_pointer_rtx, ofs);\n+\t    x = gen_frame_mem (Pmode, x);\n+\t    emit_move_insn (gen_rtx_REG (Pmode, regno), x);\n+\t    ofs += 2;\n+\t  }\n+    }\n+\n+  /* Deallocate the stack frame.  */\n+  if (fsize)\n+    {\n+      /* Prevent frame references via any pointer from being\n+\t scheduled after the frame is deallocated.  */\n+      emit_insn (gen_blockage ());\n+\n+      if (frame_pointer_needed)\n \t{\n-\t    if (LOAD_FPU_REG_P(i)\n-\t\t&& df_regs_ever_live_p (i)\n-\t\t&& ! call_used_regs[i])\n-\t      fprintf(stream, \"\\tldd (sp)+, %s\\n\", reg_names[i]);\n-\t    \n-\t    if (NO_LOAD_FPU_REG_P(i)\n-\t\t&& df_regs_ever_live_p (i)\n-\t\t&& ! call_used_regs[i])\n-\t    {\n-\t        gcc_assert (LOAD_FPU_REG_P(via_ac));\n-\t\t    \n-\t\tfprintf(stream, \"\\tldd (sp)+, %s\\n\", reg_names[via_ac]);\n-\t\tfprintf(stream, \"\\tstd %s, %s\\n\", reg_names[via_ac], reg_names[i]);\n-\t    }\n+\t  /* We can deallocate the frame with a single move.  */\n+\t  emit_move_insn (stack_pointer_rtx, hard_frame_pointer_rtx);\n \t}\n+      else\n+\temit_insn (gen_addhi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t       GEN_INT (fsize)));\n+    }\n \n-\tfor (i = PC_REGNUM; i >= 0; i--)\t\t\t\t\t\n-\t  if (df_regs_ever_live_p (i) && !call_used_regs[i])\t\t\n-\t\tfprintf(stream, \"\\tmov (sp)+, %s\\n\", reg_names[i]);\t\n-\t\t\t\t\t\t\t\t\n-\tif (fsize)\t\t\t\t\t\t\n-\t    fprintf((stream), \"\\tadd $%#\" HOST_WIDE_INT_PRINT \"o, sp\\n\",\n-\t\t    (fsize)&0xffff);      \t\t\n-    }\t\t\t\n-\t\t\t\t\t\n-    fprintf (stream, \"\\trts pc\\n\");\t\t\t\t\t\n-    fprintf (stream, \"\\t;/* end of epilogue*/\\n\\n\\n\");\t\t\n+  if (frame_pointer_needed)\n+    {\n+      x = gen_rtx_POST_INC (Pmode, stack_pointer_rtx);\n+      x = gen_frame_mem (Pmode, x);\n+      emit_move_insn (hard_frame_pointer_rtx, x);\n+    }\n+\n+  emit_jump_insn (gen_return ());\n }\n \n /* Return the best assembler insn template\n@@ -1570,16 +1578,16 @@ pdp11_regno_reg_class (int regno)\n }\n \n \n-static int\n+int\n pdp11_sp_frame_offset (void)\n {\n   int offset = 0, regno;\n   offset = get_frame_size();\n   for (regno = 0; regno <= PC_REGNUM; regno++)\n-    if (df_regs_ever_live_p (regno) && ! call_used_regs[regno])\n+    if (pdp11_saved_regno (regno))\n       offset += 2;\n   for (regno = AC0_REGNUM; regno <= AC5_REGNUM; regno++)\n-    if (df_regs_ever_live_p (regno) && ! call_used_regs[regno])\n+    if (pdp11_saved_regno (regno))\n       offset += 8;\n   \n   return offset;"}, {"sha": "23a8665c9744d531f4a3044e2a48b6bd4d40a1a4", "filename": "gcc/config/pdp11/pdp11.md", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8662b2ba92816ad1e1a461ef9fe3b2c3e9d21905/gcc%2Fconfig%2Fpdp11%2Fpdp11.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8662b2ba92816ad1e1a461ef9fe3b2c3e9d21905/gcc%2Fconfig%2Fpdp11%2Fpdp11.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.md?ref=8662b2ba92816ad1e1a461ef9fe3b2c3e9d21905", "patch": "@@ -22,6 +22,13 @@\n (include \"predicates.md\")\n (include \"constraints.md\")\n \n+(define_c_enum \"unspecv\"\n+  [\n+    UNSPECV_BLOCKAGE\n+    UNSPECV_SETD\n+    UNSPECV_SETI\n+  ])\n+\n (define_constants\n   [\n    ;; Register numbers\n@@ -104,6 +111,50 @@\n \n ;; define function units\n \n+;; Prologue and epilogue support.\n+\n+(define_expand \"prologue\"\n+  [(const_int 0)]\n+  \"\"\n+{\n+  pdp11_expand_prologue ();\n+  DONE;\n+})\n+\n+(define_expand \"epilogue\"\n+  [(const_int 0)]\n+  \"\"\n+{\n+  pdp11_expand_epilogue ();\n+  DONE;\n+})\n+\n+(define_expand \"return\"\n+  [(return)]\n+  \"reload_completed && !frame_pointer_needed && pdp11_sp_frame_offset () == 0\"\n+  \"\")\n+\n+(define_insn \"*rts\"\n+  [(return)]\n+  \"\"\n+  \"rts pc\")\n+\n+(define_insn \"blockage\"\n+  [(unspec_volatile [(const_int 0)] UNSPECV_BLOCKAGE)]\n+  \"\"\n+  \"\"\n+  [(set_attr \"length\" \"0\")])\n+\n+(define_insn \"setd\"\n+  [(unspec_volatile [(const_int 0)] UNSPECV_SETD)]\n+  \"\"\n+  \"setd\")\n+\n+(define_insn \"seti\"\n+  [(unspec_volatile [(const_int 0)] UNSPECV_SETI)]\n+  \"\"\n+  \"seti\")\n+\n ;; arithmetic - values here immediately when next insn issued\n ;; or does it mean the number of cycles after this insn was issued?\n ;; how do I say that fpu insns use cpu also? (pre-interaction phase)"}]}