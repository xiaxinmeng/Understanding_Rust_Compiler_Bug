{"sha": "a14feb3c783fba6af8d66b8138214a3a313be5c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTE0ZmViM2M3ODNmYmE2YWY4ZDY2YjgxMzgyMTRhM2EzMTNiZTVjNQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2018-12-19T15:15:42Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2018-12-19T15:15:42Z"}, "message": "C++: improvements to binary operator diagnostics (PR c++/87504)\n\nThe C frontend is able (where expression locations are available) to print\nproblems with binary operators in 3-location form, labelling the types of\nthe expressions:\n\n  arg_0 op arg_1\n  ~~~~~ ^~ ~~~~~\n    |        |\n    |        arg1 type\n    arg0 type\n\nThe C++ frontend currently just shows the combined location:\n\n  arg_0 op arg_1\n  ~~~~~~^~~~~~~~\n\nand fails to highlight where the subexpressions are, or their types.\n\nThis patch introduces a op_location_t struct for handling the above\noperator-location vs combined-location split, and a new\nclass binary_op_rich_location for displaying the above, so that the\nC++ frontend is able to use the more detailed 3-location form for\ntype mismatches in binary operators, and for -Wtautological-compare\n(where types are not displayed).  Both forms can be seen in this\nexample:\n\nbad-binary-ops.C:69:20: error: no match for 'operator&&' (operand types are\n  's' and 't')\n   69 |   return ns_4::foo && ns_4::inner::bar;\n      |          ~~~~~~~~~ ^~ ~~~~~~~~~~~~~~~~\n      |                |                   |\n      |                s                   t\nbad-binary-ops.C:69:20: note: candidate: 'operator&&(bool, bool)' <built-in>\n   69 |   return ns_4::foo && ns_4::inner::bar;\n      |          ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~\n\nThe patch also allows for some uses of macros in\n-Wtautological-compare, where both sides of the comparison have\nbeen spelled the same way, e.g.:\n\nWtautological-compare-ranges.c:23:11: warning: self-comparison always\n   evaluates to true [-Wtautological-compare]\n   23 |   if (FOO == FOO);\n      |           ^~\n\ngcc/c-family/ChangeLog:\n\tPR c++/87504\n\t* c-common.h (warn_tautological_cmp): Convert 1st param from\n\tlocation_t to const op_location_t &.\n\t* c-warn.c (find_array_ref_with_const_idx_r): Call fold_for_warn\n\twhen testing for INTEGER_CST.\n\t(warn_tautological_bitwise_comparison): Convert 1st param from\n\tlocation_t to const op_location_t &; use it to build a\n\tbinary_op_rich_location, and use this.\n\t(spelled_the_same_p): New function.\n\t(warn_tautological_cmp): Convert 1st param from location_t to\n\tconst op_location_t &.  Warn for macro expansions if\n\tspelled_the_same_p.  Use binary_op_rich_location.\n\ngcc/c/ChangeLog:\n\tPR c++/87504\n\t* c-typeck.c (class maybe_range_label_for_tree_type_mismatch):\n\tMove from here to gcc-rich-location.h and gcc-rich-location.c.\n\t(build_binary_op): Use struct op_location_t and\n\tclass binary_op_rich_location.\n\ngcc/cp/ChangeLog:\n\tPR c++/87504\n\t* call.c (op_error): Convert 1st param from location_t to\n\tconst op_location_t &.  Use binary_op_rich_location for binary\n\tops.\n\t(build_conditional_expr_1): Convert 1st param from location_t to\n\tconst op_location_t &.\n\t(build_conditional_expr): Likewise.\n\t(build_new_op_1): Likewise.\n\t(build_new_op): Likewise.\n\t* cp-tree.h (build_conditional_expr): Likewise.\n\t(build_new_op): Likewise.\n\t(build_x_binary_op): Likewise.\n\t(cp_build_binary_op): Likewise.\n\t* parser.c (cp_parser_primary_expression): Build a location\n\tfor id-expression nodes.\n\t(cp_parser_binary_expression): Use an op_location_t when\n\tcalling build_x_binary_op.\n\t(cp_parser_operator): Build a location for user-defined literals.\n\t* typeck.c (build_x_binary_op): Convert 1st param from location_t\n\tto const op_location_t &.\n\t(cp_build_binary_op): Likewise.  Use binary_op_rich_location.\n\ngcc/ChangeLog:\n\tPR c++/87504\n\t* gcc-rich-location.c\n\t(maybe_range_label_for_tree_type_mismatch::get_text): Move here from\n\tc/c-typeck.c.\n\t(binary_op_rich_location::binary_op_rich_location): New ctor.\n\t(binary_op_rich_location::use_operator_loc_p): New function.\n\t* gcc-rich-location.h\n\t(class maybe_range_label_for_tree_type_mismatch)): Move here from\n\tc/c-typeck.c.\n\t(struct op_location_t): New forward decl.\n\t(class binary_op_rich_location): New class.\n\t* tree.h (struct op_location_t): New struct.\n\ngcc/testsuite/ChangeLog:\n\t* c-c++-common/Wtautological-compare-ranges.c: New test.\n\t* g++.dg/cpp0x/pr51420.C: Add -fdiagnostics-show-caret and update\n\texpected output.\n\t* g++.dg/diagnostic/bad-binary-ops.C: Update expected output from\n\t1-location form to 3-location form, with labelling of ranges with\n\ttypes.  Add examples of id-expression nodes with namespaces.\n\t* g++.dg/diagnostic/param-type-mismatch-2.C: Likewise.\n\nFrom-SVN: r267273", "tree": {"sha": "8077a5987ffd2b51526c4fb5914a366842927823", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8077a5987ffd2b51526c4fb5914a366842927823"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a14feb3c783fba6af8d66b8138214a3a313be5c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a14feb3c783fba6af8d66b8138214a3a313be5c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a14feb3c783fba6af8d66b8138214a3a313be5c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a14feb3c783fba6af8d66b8138214a3a313be5c5/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dfd7fdca2ac17d8b823a16700525824ca312ade0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfd7fdca2ac17d8b823a16700525824ca312ade0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfd7fdca2ac17d8b823a16700525824ca312ade0"}], "stats": {"total": 565, "additions": 489, "deletions": 76}, "files": [{"sha": "f2118d8de8d94e7ec2f19547dbfb06fe657a63e8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a14feb3c783fba6af8d66b8138214a3a313be5c5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a14feb3c783fba6af8d66b8138214a3a313be5c5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a14feb3c783fba6af8d66b8138214a3a313be5c5", "patch": "@@ -1,3 +1,18 @@\n+2018-12-19  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR c++/87504\n+\t* gcc-rich-location.c\n+\t(maybe_range_label_for_tree_type_mismatch::get_text): Move here from\n+\tc/c-typeck.c.\n+\t(binary_op_rich_location::binary_op_rich_location): New ctor.\n+\t(binary_op_rich_location::use_operator_loc_p): New function.\n+\t* gcc-rich-location.h\n+\t(class maybe_range_label_for_tree_type_mismatch)): Move here from\n+\tc/c-typeck.c.\n+\t(struct op_location_t): New forward decl.\n+\t(class binary_op_rich_location): New class.\n+\t* tree.h (struct op_location_t): New struct.\n+\n 2018-12-19  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR c++/43064"}, {"sha": "637a288e2ace1986f322a6c15fd1a933eb9cd18f", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a14feb3c783fba6af8d66b8138214a3a313be5c5/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a14feb3c783fba6af8d66b8138214a3a313be5c5/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=a14feb3c783fba6af8d66b8138214a3a313be5c5", "patch": "@@ -1,3 +1,18 @@\n+2018-12-19  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR c++/87504\n+\t* c-common.h (warn_tautological_cmp): Convert 1st param from\n+\tlocation_t to const op_location_t &.\n+\t* c-warn.c (find_array_ref_with_const_idx_r): Call fold_for_warn\n+\twhen testing for INTEGER_CST.\n+\t(warn_tautological_bitwise_comparison): Convert 1st param from\n+\tlocation_t to const op_location_t &; use it to build a\n+\tbinary_op_rich_location, and use this.\n+\t(spelled_the_same_p): New function.\n+\t(warn_tautological_cmp): Convert 1st param from location_t to\n+\tconst op_location_t &.  Warn for macro expansions if\n+\tspelled_the_same_p.  Use binary_op_rich_location.\n+\n 2018-12-19  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR c++/43064"}, {"sha": "0b9ddf68fe00a36aca93ba17bf28fdb76affadf8", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a14feb3c783fba6af8d66b8138214a3a313be5c5/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a14feb3c783fba6af8d66b8138214a3a313be5c5/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=a14feb3c783fba6af8d66b8138214a3a313be5c5", "patch": "@@ -1268,7 +1268,8 @@ extern void constant_expression_error (tree);\n extern void overflow_warning (location_t, tree, tree = NULL_TREE);\n extern void warn_logical_operator (location_t, enum tree_code, tree,\n \t\t\t\t   enum tree_code, tree, enum tree_code, tree);\n-extern void warn_tautological_cmp (location_t, enum tree_code, tree, tree);\n+extern void warn_tautological_cmp (const op_location_t &, enum tree_code,\n+\t\t\t\t   tree, tree);\n extern void warn_logical_not_parentheses (location_t, enum tree_code, tree,\n \t\t\t\t\t  tree);\n extern bool warn_if_unused_value (const_tree, location_t);"}, {"sha": "b0f6da0e52c4049f328c5793b8a5e983c9104101", "filename": "gcc/c-family/c-warn.c", "status": "modified", "additions": 47, "deletions": 10, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a14feb3c783fba6af8d66b8138214a3a313be5c5/gcc%2Fc-family%2Fc-warn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a14feb3c783fba6af8d66b8138214a3a313be5c5/gcc%2Fc-family%2Fc-warn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-warn.c?ref=a14feb3c783fba6af8d66b8138214a3a313be5c5", "patch": "@@ -322,7 +322,8 @@ find_array_ref_with_const_idx_r (tree *expr_p, int *, void *)\n \n   if ((TREE_CODE (expr) == ARRAY_REF\n        || TREE_CODE (expr) == ARRAY_RANGE_REF)\n-      && TREE_CODE (TREE_OPERAND (expr, 1)) == INTEGER_CST)\n+      && (TREE_CODE (fold_for_warn (TREE_OPERAND (expr, 1)))\n+\t  == INTEGER_CST))\n     return integer_type_node;\n \n   return NULL_TREE;\n@@ -334,7 +335,7 @@ find_array_ref_with_const_idx_r (tree *expr_p, int *, void *)\n    of this comparison.  */\n \n static void\n-warn_tautological_bitwise_comparison (location_t loc, tree_code code,\n+warn_tautological_bitwise_comparison (const op_location_t &loc, tree_code code,\n \t\t\t\t      tree lhs, tree rhs)\n {\n   if (code != EQ_EXPR && code != NE_EXPR)\n@@ -389,29 +390,64 @@ warn_tautological_bitwise_comparison (location_t loc, tree_code code,\n   if (res == cstw)\n     return;\n \n+  binary_op_rich_location richloc (loc, lhs, rhs, false);\n   if (code == EQ_EXPR)\n-    warning_at (loc, OPT_Wtautological_compare,\n+    warning_at (&richloc, OPT_Wtautological_compare,\n \t\t\"bitwise comparison always evaluates to false\");\n   else\n-    warning_at (loc, OPT_Wtautological_compare,\n+    warning_at (&richloc, OPT_Wtautological_compare,\n \t\t\"bitwise comparison always evaluates to true\");\n }\n \n+/* Given LOC_A and LOC_B from macro expansions, return true if\n+   they are \"spelled the same\" i.e. if they are both directly from\n+   expansion of the same non-function-like macro.  */\n+\n+static bool\n+spelled_the_same_p (location_t loc_a, location_t loc_b)\n+{\n+  gcc_assert (from_macro_expansion_at (loc_a));\n+  gcc_assert (from_macro_expansion_at (loc_b));\n+\n+  const line_map_macro *map_a\n+    = linemap_check_macro (linemap_lookup (line_table, loc_a));\n+\n+  const line_map_macro *map_b\n+    = linemap_check_macro (linemap_lookup (line_table, loc_b));\n+\n+  if (map_a->macro == map_b->macro)\n+    if (!cpp_fun_like_macro_p (map_a->macro))\n+      return true;\n+\n+  return false;\n+}\n+\n /* Warn if a self-comparison always evaluates to true or false.  LOC\n    is the location of the comparison with code CODE, LHS and RHS are\n    operands of the comparison.  */\n \n void\n-warn_tautological_cmp (location_t loc, enum tree_code code, tree lhs, tree rhs)\n+warn_tautological_cmp (const op_location_t &loc, enum tree_code code,\n+\t\t       tree lhs, tree rhs)\n {\n   if (TREE_CODE_CLASS (code) != tcc_comparison)\n     return;\n \n   /* Don't warn for various macro expansions.  */\n-  if (from_macro_expansion_at (loc)\n-      || from_macro_expansion_at (EXPR_LOCATION (lhs))\n-      || from_macro_expansion_at (EXPR_LOCATION (rhs)))\n+  if (from_macro_expansion_at (loc))\n     return;\n+  bool lhs_in_macro = from_macro_expansion_at (EXPR_LOCATION (lhs));\n+  bool rhs_in_macro = from_macro_expansion_at (EXPR_LOCATION (rhs));\n+  if (lhs_in_macro || rhs_in_macro)\n+    {\n+      /* Don't warn if exactly one is from a macro.  */\n+      if (!(lhs_in_macro && rhs_in_macro))\n+\treturn;\n+\n+      /* If both are in a macro, only warn if they're spelled the same.  */\n+      if (!spelled_the_same_p (EXPR_LOCATION (lhs), EXPR_LOCATION (rhs)))\n+\treturn;\n+    }\n \n   warn_tautological_bitwise_comparison (loc, code, lhs, rhs);\n \n@@ -446,11 +482,12 @@ warn_tautological_cmp (location_t loc, enum tree_code code, tree lhs, tree rhs)\n       const bool always_true = (code == EQ_EXPR || code == LE_EXPR\n \t\t\t\t|| code == GE_EXPR || code == UNLE_EXPR\n \t\t\t\t|| code == UNGE_EXPR || code == UNEQ_EXPR);\n+      binary_op_rich_location richloc (loc, lhs, rhs, false);\n       if (always_true)\n-\twarning_at (loc, OPT_Wtautological_compare,\n+\twarning_at (&richloc, OPT_Wtautological_compare,\n \t\t    \"self-comparison always evaluates to true\");\n       else\n-\twarning_at (loc, OPT_Wtautological_compare,\n+\twarning_at (&richloc, OPT_Wtautological_compare,\n \t\t    \"self-comparison always evaluates to false\");\n     }\n }"}, {"sha": "3232614f4301a30551a7ed4c4b8e302409fd538a", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a14feb3c783fba6af8d66b8138214a3a313be5c5/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a14feb3c783fba6af8d66b8138214a3a313be5c5/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=a14feb3c783fba6af8d66b8138214a3a313be5c5", "patch": "@@ -1,3 +1,11 @@\n+2018-12-19  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR c++/87504\n+\t* c-typeck.c (class maybe_range_label_for_tree_type_mismatch):\n+\tMove from here to gcc-rich-location.h and gcc-rich-location.c.\n+\t(build_binary_op): Use struct op_location_t and\n+\tclass binary_op_rich_location.\n+\n 2018-12-11  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR sanitizer/88426"}, {"sha": "72ecd46cea63b00661628848284eee91c7661ea2", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 3, "deletions": 38, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a14feb3c783fba6af8d66b8138214a3a313be5c5/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a14feb3c783fba6af8d66b8138214a3a313be5c5/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=a14feb3c783fba6af8d66b8138214a3a313be5c5", "patch": "@@ -11313,38 +11313,6 @@ build_vec_cmp (tree_code code, tree type,\n   return build3 (VEC_COND_EXPR, type, cmp, minus_one_vec, zero_vec);\n }\n \n-/* Subclass of range_label for labelling the type of EXPR when reporting\n-   a type mismatch between EXPR and OTHER_EXPR.\n-   Either or both of EXPR and OTHER_EXPR could be NULL.  */\n-\n-class maybe_range_label_for_tree_type_mismatch : public range_label\n-{\n- public:\n-  maybe_range_label_for_tree_type_mismatch (tree expr, tree other_expr)\n-  : m_expr (expr), m_other_expr (other_expr)\n-  {\n-  }\n-\n-  label_text get_text (unsigned range_idx) const FINAL OVERRIDE\n-  {\n-    if (m_expr == NULL_TREE\n-\t|| !EXPR_P (m_expr))\n-      return label_text (NULL, false);\n-    tree expr_type = TREE_TYPE (m_expr);\n-\n-    tree other_type = NULL_TREE;\n-    if (m_other_expr && EXPR_P (m_other_expr))\n-      other_type = TREE_TYPE (m_other_expr);\n-\n-   range_label_for_type_mismatch inner (expr_type, other_type);\n-   return inner.get_text (range_idx);\n-  }\n-\n- private:\n-  tree m_expr;\n-  tree m_other_expr;\n-};\n-\n /* Build a binary-operation expression without default conversions.\n    CODE is the kind of expression to build.\n    LOCATION is the operator's location.\n@@ -12475,12 +12443,9 @@ build_binary_op (location_t location, enum tree_code code,\n \n   if (!result_type)\n     {\n-      gcc_rich_location richloc (location);\n-      maybe_range_label_for_tree_type_mismatch\n-\tlabel_for_op0 (orig_op0, orig_op1),\n-\tlabel_for_op1 (orig_op1, orig_op0);\n-      richloc.maybe_add_expr (orig_op0, &label_for_op0);\n-      richloc.maybe_add_expr (orig_op1, &label_for_op1);\n+      /* Favor showing any expression locations that are available. */\n+      op_location_t oploc (location, UNKNOWN_LOCATION);\n+      binary_op_rich_location richloc (oploc, orig_op0, orig_op1, true);\n       binary_op_error (&richloc, code, TREE_TYPE (op0), TREE_TYPE (op1));\n       return error_mark_node;\n     }"}, {"sha": "beae2659c7442dbd7f02d18d339671f0c3b7da88", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a14feb3c783fba6af8d66b8138214a3a313be5c5/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a14feb3c783fba6af8d66b8138214a3a313be5c5/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a14feb3c783fba6af8d66b8138214a3a313be5c5", "patch": "@@ -1,3 +1,27 @@\n+2018-12-19  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR c++/87504\n+\t* call.c (op_error): Convert 1st param from location_t to\n+\tconst op_location_t &.  Use binary_op_rich_location for binary\n+\tops.\n+\t(build_conditional_expr_1): Convert 1st param from location_t to\n+\tconst op_location_t &.\n+\t(build_conditional_expr): Likewise.\n+\t(build_new_op_1): Likewise.\n+\t(build_new_op): Likewise.\n+\t* cp-tree.h (build_conditional_expr): Likewise.\n+\t(build_new_op): Likewise.\n+\t(build_x_binary_op): Likewise.\n+\t(cp_build_binary_op): Likewise.\n+\t* parser.c (cp_parser_primary_expression): Build a location\n+\tfor id-expression nodes.\n+\t(cp_parser_binary_expression): Use an op_location_t when\n+\tcalling build_x_binary_op.\n+\t(cp_parser_operator): Build a location for user-defined literals.\n+\t* typeck.c (build_x_binary_op): Convert 1st param from location_t\n+\tto const op_location_t &.\n+\t(cp_build_binary_op): Likewise.  Use binary_op_rich_location.\n+\n 2018-12-19  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR c++/43064"}, {"sha": "e2f8fe1063075d2911d6fe393d96a21c6d7bcf5c", "filename": "gcc/cp/call.c", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a14feb3c783fba6af8d66b8138214a3a313be5c5/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a14feb3c783fba6af8d66b8138214a3a313be5c5/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=a14feb3c783fba6af8d66b8138214a3a313be5c5", "patch": "@@ -166,8 +166,8 @@ static tree build_over_call (struct z_candidate *, int, tsubst_flags_t);\n \t\t     /*c_cast_p=*/false, (COMPLAIN))\n static tree convert_like_real (conversion *, tree, tree, int, bool,\n \t\t\t       bool, tsubst_flags_t);\n-static void op_error (location_t, enum tree_code, enum tree_code, tree,\n-\t\t      tree, tree, bool);\n+static void op_error (const op_location_t &, enum tree_code, enum tree_code,\n+\t\t      tree, tree, tree, bool);\n static struct z_candidate *build_user_type_conversion_1 (tree, tree, int,\n \t\t\t\t\t\t\t tsubst_flags_t);\n static void print_z_candidate (location_t, const char *, struct z_candidate *);\n@@ -4713,7 +4713,8 @@ op_error_string (const char *errmsg, int ntypes, bool match)\n }\n \n static void\n-op_error (location_t loc, enum tree_code code, enum tree_code code2,\n+op_error (const op_location_t &loc,\n+\t  enum tree_code code, enum tree_code code2,\n \t  tree arg1, tree arg2, tree arg3, bool match)\n {\n   bool assop = code == MODIFY_EXPR;\n@@ -4767,8 +4768,12 @@ op_error (location_t loc, enum tree_code code, enum tree_code code2,\n     default:\n       if (arg2)\n \tif (flag_diagnostics_show_caret)\n-\t  error_at (loc, op_error_string (G_(\"%<operator%s%>\"), 2, match),\n-\t\t    opname, TREE_TYPE (arg1), TREE_TYPE (arg2));\n+\t  {\n+\t    binary_op_rich_location richloc (loc, arg1, arg2, true);\n+\t    error_at (&richloc,\n+\t\t      op_error_string (G_(\"%<operator%s%>\"), 2, match),\n+\t\t      opname, TREE_TYPE (arg1), TREE_TYPE (arg2));\n+\t  }\n \telse\n \t  error_at (loc, op_error_string (G_(\"%<operator%s%> in %<%E %s %E%>\"),\n \t\t\t\t\t  2, match),\n@@ -4867,7 +4872,8 @@ conditional_conversion (tree e1, tree e2, tsubst_flags_t complain)\n    arguments to the conditional expression.  */\n \n static tree\n-build_conditional_expr_1 (location_t loc, tree arg1, tree arg2, tree arg3,\n+build_conditional_expr_1 (const op_location_t &loc,\n+\t\t\t  tree arg1, tree arg2, tree arg3,\n                           tsubst_flags_t complain)\n {\n   tree arg2_type;\n@@ -5461,7 +5467,8 @@ build_conditional_expr_1 (location_t loc, tree arg1, tree arg2, tree arg3,\n /* Wrapper for above.  */\n \n tree\n-build_conditional_expr (location_t loc, tree arg1, tree arg2, tree arg3,\n+build_conditional_expr (const op_location_t &loc,\n+\t\t\ttree arg1, tree arg2, tree arg3,\n                         tsubst_flags_t complain)\n {\n   tree ret;\n@@ -5650,8 +5657,9 @@ op_is_ordered (tree_code code)\n }\n \n static tree\n-build_new_op_1 (location_t loc, enum tree_code code, int flags, tree arg1,\n-\t\ttree arg2, tree arg3, tree *overload, tsubst_flags_t complain)\n+build_new_op_1 (const op_location_t &loc, enum tree_code code, int flags,\n+\t\ttree arg1, tree arg2, tree arg3, tree *overload,\n+\t\ttsubst_flags_t complain)\n {\n   struct z_candidate *candidates = 0, *cand;\n   vec<tree, va_gc> *arglist;\n@@ -6130,7 +6138,7 @@ build_new_op_1 (location_t loc, enum tree_code code, int flags, tree arg1,\n /* Wrapper for above.  */\n \n tree\n-build_new_op (location_t loc, enum tree_code code, int flags,\n+build_new_op (const op_location_t &loc, enum tree_code code, int flags,\n \t      tree arg1, tree arg2, tree arg3,\n \t      tree *overload, tsubst_flags_t complain)\n {"}, {"sha": "8a9509564dca38e54a6e3cac100237403aa2bc15", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a14feb3c783fba6af8d66b8138214a3a313be5c5/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a14feb3c783fba6af8d66b8138214a3a313be5c5/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=a14feb3c783fba6af8d66b8138214a3a313be5c5", "patch": "@@ -6097,7 +6097,8 @@ extern int raw_dump_id;\n extern bool check_dtor_name\t\t\t(tree, tree);\n int magic_varargs_p\t\t\t\t(tree);\n \n-extern tree build_conditional_expr\t\t(location_t, tree, tree, tree, \n+extern tree build_conditional_expr\t\t(const op_location_t &,\n+\t\t\t\t\t\t tree, tree, tree,\n                                                  tsubst_flags_t);\n extern tree build_addr_func\t\t\t(tree, tsubst_flags_t);\n extern void set_flags_from_callee\t\t(tree);\n@@ -6122,7 +6123,8 @@ extern tree build_new_method_call\t\t(tree, tree,\n extern tree build_special_member_call\t\t(tree, tree,\n \t\t\t\t\t\t vec<tree, va_gc> **,\n \t\t\t\t\t\t tree, int, tsubst_flags_t);\n-extern tree build_new_op\t\t\t(location_t, enum tree_code,\n+extern tree build_new_op\t\t\t(const op_location_t &,\n+\t\t\t\t\t\t enum tree_code,\n \t\t\t\t\t\t int, tree, tree, tree, tree *,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree build_op_call\t\t\t(tree, vec<tree, va_gc> **,\n@@ -7339,7 +7341,7 @@ extern tree cp_build_function_call_nary         (tree, tsubst_flags_t, ...)\n \t\t\t\t\t\tATTRIBUTE_SENTINEL;\n extern tree cp_build_function_call_vec\t\t(tree, vec<tree, va_gc> **,\n \t\t\t\t\t\t tsubst_flags_t);\n-extern tree build_x_binary_op\t\t\t(location_t,\n+extern tree build_x_binary_op\t\t\t(const op_location_t &,\n \t\t\t\t\t\t enum tree_code, tree,\n \t\t\t\t\t\t enum tree_code, tree,\n \t\t\t\t\t\t enum tree_code, tree *,\n@@ -7406,7 +7408,7 @@ extern tree composite_pointer_type\t\t(tree, tree, tree, tree,\n extern tree merge_types\t\t\t\t(tree, tree);\n extern tree strip_array_domain\t\t\t(tree);\n extern tree check_return_expr\t\t\t(tree, bool *);\n-extern tree cp_build_binary_op                  (location_t,\n+extern tree cp_build_binary_op                  (const op_location_t &,\n \t\t\t\t\t\t enum tree_code, tree, tree,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree build_x_vec_perm_expr               (location_t,"}, {"sha": "e5381b45d033b2843a8d60e26adeaf46d7c19795", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a14feb3c783fba6af8d66b8138214a3a313be5c5/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a14feb3c783fba6af8d66b8138214a3a313be5c5/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=a14feb3c783fba6af8d66b8138214a3a313be5c5", "patch": "@@ -5710,8 +5710,21 @@ cp_parser_primary_expression (cp_parser *parser,\n \t\t id_expression.get_location ()));\n \tif (error_msg)\n \t  cp_parser_error (parser, error_msg);\n-\tdecl.set_location (id_expression.get_location ());\n-\tdecl.set_range (id_expr_token->location, id_expression.get_finish ());\n+\t/* Build a location for an id-expression of the form:\n+\t     ::ns::id\n+             ~~~~~~^~\n+\t  or:\n+\t     id\n+\t     ^~\n+\t   i.e. from the start of the first token to the end of the final\n+\t   token, with the caret at the start of the unqualified-id.  */\n+\tlocation_t caret_loc = get_pure_location (id_expression.get_location ());\n+\tlocation_t start_loc = get_start (id_expr_token->location);\n+\tlocation_t finish_loc = get_finish (id_expression.get_location ());\n+\tlocation_t combined_loc\n+\t  = make_location (caret_loc, start_loc, finish_loc);\n+\n+\tdecl.set_location (combined_loc);\n \treturn decl;\n       }\n \n@@ -9556,7 +9569,8 @@ cp_parser_binary_expression (cp_parser* parser, bool cast_p,\n \t}\n       else\n         {\n-          current.lhs = build_x_binary_op (combined_loc, current.tree_type,\n+\t  op_location_t op_loc (current.loc, combined_loc);\n+\t  current.lhs = build_x_binary_op (op_loc, current.tree_type,\n                                            current.lhs, current.lhs_type,\n                                            rhs, rhs_type, &overload,\n                                            complain_flags (decltype_p));\n@@ -15391,8 +15405,16 @@ cp_parser_operator (cp_parser* parser, location_t start_loc)\n \t    const char *name = IDENTIFIER_POINTER (id);\n \t    id = cp_literal_operator_id (name);\n \t  }\n-\tstart_loc = make_location (start_loc, start_loc, get_finish (end_loc));\n-\treturn cp_expr (id, start_loc);\n+\t/* Generate a location of the form:\n+\t     \"\" _suffix_identifier\n+\t     ^~~~~~~~~~~~~~~~~~~~~\n+\t   with caret == start at the start token, finish at the end of the\n+\t   suffix identifier.  */\n+\tlocation_t finish_loc\n+\t  = get_finish (cp_lexer_previous_token (parser->lexer)->location);\n+\tlocation_t combined_loc\n+\t  = make_location (start_loc, start_loc, finish_loc);\n+\treturn cp_expr (id, combined_loc);\n       }\n \n     default:"}, {"sha": "94a33d41dbafefaec6d363e847e9c020649fd846", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a14feb3c783fba6af8d66b8138214a3a313be5c5/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a14feb3c783fba6af8d66b8138214a3a313be5c5/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=a14feb3c783fba6af8d66b8138214a3a313be5c5", "patch": "@@ -4128,7 +4128,7 @@ convert_arguments (tree typelist, vec<tree, va_gc> **values, tree fndecl,\n    ARG2_CODE as ERROR_MARK.  */\n \n tree\n-build_x_binary_op (location_t loc, enum tree_code code, tree arg1,\n+build_x_binary_op (const op_location_t &loc, enum tree_code code, tree arg1,\n \t\t   enum tree_code arg1_code, tree arg2,\n \t\t   enum tree_code arg2_code, tree *overload_p,\n \t\t   tsubst_flags_t complain)\n@@ -4317,7 +4317,7 @@ warn_for_null_address (location_t location, tree op, tsubst_flags_t complain)\n    multiple inheritance, and deal with pointer to member functions.  */\n \n tree\n-cp_build_binary_op (location_t location,\n+cp_build_binary_op (const op_location_t &location,\n \t\t    enum tree_code code, tree orig_op0, tree orig_op1,\n \t\t    tsubst_flags_t complain)\n {\n@@ -5314,9 +5314,13 @@ cp_build_binary_op (location_t location,\n   if (!result_type)\n     {\n       if (complain & tf_error)\n-\terror_at (location,\n-\t\t  \"invalid operands of types %qT and %qT to binary %qO\",\n-\t\t  TREE_TYPE (orig_op0), TREE_TYPE (orig_op1), code);\n+\t{\n+\t  binary_op_rich_location richloc (location,\n+\t\t\t\t\t   orig_op0, orig_op1, true);\n+\t  error_at (&richloc,\n+\t\t    \"invalid operands of types %qT and %qT to binary %qO\",\n+\t\t    TREE_TYPE (orig_op0), TREE_TYPE (orig_op1), code);\n+\t}\n       return error_mark_node;\n     }\n "}, {"sha": "25a604f6bdca9274bfb1d2eab577598f906d6d82", "filename": "gcc/gcc-rich-location.c", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a14feb3c783fba6af8d66b8138214a3a313be5c5/gcc%2Fgcc-rich-location.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a14feb3c783fba6af8d66b8138214a3a313be5c5/gcc%2Fgcc-rich-location.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc-rich-location.c?ref=a14feb3c783fba6af8d66b8138214a3a313be5c5", "patch": "@@ -182,3 +182,92 @@ gcc_rich_location::add_fixit_insert_formatted (const char *content,\n   else\n     add_fixit_insert_before (insertion_point, content);\n }\n+\n+/* Implementation of range_label::get_text for\n+   maybe_range_label_for_tree_type_mismatch.\n+\n+   If both expressions are non-NULL, then generate text describing\n+   the first expression's type (using the other expression's type\n+   for comparison, analogous to %H and %I in the C++ frontend, but\n+   on expressions rather than types).  */\n+\n+label_text\n+maybe_range_label_for_tree_type_mismatch::get_text (unsigned range_idx) const\n+{\n+  if (m_expr == NULL_TREE\n+      || !EXPR_P (m_expr))\n+    return label_text (NULL, false);\n+  tree expr_type = TREE_TYPE (m_expr);\n+\n+  tree other_type = NULL_TREE;\n+  if (m_other_expr && EXPR_P (m_other_expr))\n+    other_type = TREE_TYPE (m_other_expr);\n+\n+  range_label_for_type_mismatch inner (expr_type, other_type);\n+  return inner.get_text (range_idx);\n+}\n+\n+/* binary_op_rich_location's ctor.\n+\n+   If use_operator_loc_p (LOC, ARG0, ARG1), then attempt to make a 3-location\n+   rich_location of the form:\n+\n+     arg_0 op arg_1\n+     ~~~~~ ^~ ~~~~~\n+       |        |\n+       |        arg1 type\n+       arg0 type\n+\n+   labelling the types of the arguments if SHOW_TYPES is true.\n+\n+   Otherwise, make a 1-location rich_location using the compound\n+   location within LOC:\n+\n+     arg_0 op arg_1\n+     ~~~~~~^~~~~~~~\n+\n+   for which we can't label the types.  */\n+\n+binary_op_rich_location::binary_op_rich_location (const op_location_t &loc,\n+\t\t\t\t\t\t  tree arg0, tree arg1,\n+\t\t\t\t\t\t  bool show_types)\n+: gcc_rich_location (loc.m_combined_loc),\n+  m_label_for_arg0 (arg0, arg1),\n+  m_label_for_arg1 (arg1, arg0)\n+{\n+  /* Default (above) to using the combined loc.\n+     Potentially override it here: if we have location information for the\n+     operator and for both arguments, then split them all out.\n+     Alternatively, override it if we don't have the combined location.  */\n+  if (use_operator_loc_p (loc, arg0, arg1))\n+    {\n+      set_range (0, loc.m_operator_loc, SHOW_RANGE_WITH_CARET);\n+      maybe_add_expr (arg0, show_types ? &m_label_for_arg0 : NULL);\n+      maybe_add_expr (arg1, show_types ? &m_label_for_arg1 : NULL);\n+    }\n+}\n+\n+/* Determine if binary_op_rich_location's ctor should attempt to make\n+   a 3-location rich_location (the location of the operator and of\n+   the 2 arguments), or fall back to a 1-location rich_location showing\n+   just the combined location of the operation as a whole.  */\n+\n+bool\n+binary_op_rich_location::use_operator_loc_p (const op_location_t &loc,\n+\t\t\t\t\t     tree arg0, tree arg1)\n+{\n+  /* If we don't have a combined location, then use the operator location,\n+     and try to add ranges for the operators.  */\n+  if (loc.m_combined_loc == UNKNOWN_LOCATION)\n+    return true;\n+\n+  /* If we don't have the operator location, then use the\n+     combined location.  */\n+  if (loc.m_operator_loc == UNKNOWN_LOCATION)\n+    return false;\n+\n+  /* We have both operator location and combined location: only use the\n+     operator location if we have locations for both arguments.  */\n+  return (EXPR_HAS_LOCATION (arg0)\n+\t  && EXPR_HAS_LOCATION (arg1));\n+}"}, {"sha": "202d4f44804d8e168e49ebc7ed20e21ba0aa0f7a", "filename": "gcc/gcc-rich-location.h", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a14feb3c783fba6af8d66b8138214a3a313be5c5/gcc%2Fgcc-rich-location.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a14feb3c783fba6af8d66b8138214a3a313be5c5/gcc%2Fgcc-rich-location.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc-rich-location.h?ref=a14feb3c783fba6af8d66b8138214a3a313be5c5", "patch": "@@ -162,4 +162,61 @@ class range_label_for_type_mismatch : public range_label\n   tree m_other_type;\n };\n \n+/* Subclass of range_label for labelling the type of EXPR when reporting\n+   a type mismatch between EXPR and OTHER_EXPR.\n+   Either or both of EXPR and OTHER_EXPR could be NULL.  */\n+\n+class maybe_range_label_for_tree_type_mismatch : public range_label\n+{\n+ public:\n+  maybe_range_label_for_tree_type_mismatch (tree expr, tree other_expr)\n+  : m_expr (expr), m_other_expr (other_expr)\n+  {\n+  }\n+\n+  label_text get_text (unsigned range_idx) const FINAL OVERRIDE;\n+\n+ private:\n+  tree m_expr;\n+  tree m_other_expr;\n+};\n+\n+struct op_location_t;\n+\n+/* A subclass of rich_location for showing problems with binary operations.\n+\n+   If enough location information is available, the ctor will make a\n+   3-location rich_location of the form:\n+\n+     arg_0 op arg_1\n+     ~~~~~ ^~ ~~~~~\n+       |        |\n+       |        arg1 type\n+       arg0 type\n+\n+   labelling the types of the arguments if SHOW_TYPES is true.\n+\n+   Otherwise, it will fall back to a 1-location rich_location using the\n+   compound location within LOC:\n+\n+     arg_0 op arg_1\n+     ~~~~~~^~~~~~~~\n+\n+   for which we can't label the types.  */\n+\n+class binary_op_rich_location : public gcc_rich_location\n+{\n+ public:\n+  binary_op_rich_location (const op_location_t &loc,\n+\t\t\t   tree arg0, tree arg1,\n+\t\t\t   bool show_types);\n+\n+ private:\n+  static bool use_operator_loc_p (const op_location_t &loc,\n+\t\t\t\t  tree arg0, tree arg1);\n+\n+  maybe_range_label_for_tree_type_mismatch m_label_for_arg0;\n+  maybe_range_label_for_tree_type_mismatch m_label_for_arg1;\n+};\n+\n #endif /* GCC_RICH_LOCATION_H */"}, {"sha": "4a613382a07143d51b68a5eebd9fb5576f33bf7a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a14feb3c783fba6af8d66b8138214a3a313be5c5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a14feb3c783fba6af8d66b8138214a3a313be5c5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a14feb3c783fba6af8d66b8138214a3a313be5c5", "patch": "@@ -1,3 +1,13 @@\n+2018-12-19  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* c-c++-common/Wtautological-compare-ranges.c: New test.\n+\t* g++.dg/cpp0x/pr51420.C: Add -fdiagnostics-show-caret and update\n+\texpected output.\n+\t* g++.dg/diagnostic/bad-binary-ops.C: Update expected output from\n+\t1-location form to 3-location form, with labelling of ranges with\n+\ttypes.  Add examples of id-expression nodes with namespaces.\n+\t* g++.dg/diagnostic/param-type-mismatch-2.C: Likewise.\n+\n 2018-12-19  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR c++/43064"}, {"sha": "2634d276641313dd3007524261a768606bb1ce9f", "filename": "gcc/testsuite/c-c++-common/Wtautological-compare-ranges.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a14feb3c783fba6af8d66b8138214a3a313be5c5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWtautological-compare-ranges.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a14feb3c783fba6af8d66b8138214a3a313be5c5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWtautological-compare-ranges.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWtautological-compare-ranges.c?ref=a14feb3c783fba6af8d66b8138214a3a313be5c5", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wtautological-compare -fdiagnostics-show-caret\" } */\n+\n+#define FOO foo\n+\n+void\n+fn1 (int foo)\n+{\n+  if (foo == foo); /* { dg-warning \"self-comparison always evaluates to true\" } */\n+  /* { dg-begin-multiline-output \"\" }\n+   if (foo == foo);\n+           ^~\n+     { dg-end-multiline-output \"\" { target c } } */\n+  /* { dg-begin-multiline-output \"\" }\n+   if (foo == foo);\n+       ~~~ ^~ ~~~\n+     { dg-end-multiline-output \"\" { target c++ } } */\n+}\n+\n+void\n+fn2 (int foo)\n+{\n+  if (FOO == FOO); /* { dg-warning \"self-comparison always evaluates to true\" } */\n+  /* { dg-begin-multiline-output \"\" }\n+   if (FOO == FOO);\n+           ^~\n+     { dg-end-multiline-output \"\" } */\n+}\n+\n+void\n+fn3 (int foo)\n+{\n+  if ((foo & 16) == 10); /* { dg-warning \"bitwise comparison always evaluates to false\" } */\n+  /* { dg-begin-multiline-output \"\" }\n+   if ((foo & 16) == 10);\n+                  ^~\n+     { dg-end-multiline-output \"\" { target c } } */\n+  /* { dg-begin-multiline-output \"\" }\n+   if ((foo & 16) == 10);\n+       ~~~~~~~~~~ ^~ ~~\n+     { dg-end-multiline-output \"\" { target c++ } } */\n+}"}, {"sha": "1612cef9ee2724ca53107e88e5a1d667dba4fd0f", "filename": "gcc/testsuite/g++.dg/cpp0x/pr51420.C", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a14feb3c783fba6af8d66b8138214a3a313be5c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr51420.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a14feb3c783fba6af8d66b8138214a3a313be5c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr51420.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr51420.C?ref=a14feb3c783fba6af8d66b8138214a3a313be5c5", "patch": "@@ -1,8 +1,18 @@\n // { dg-do compile { target c++11 } }\n+// { dg-options \"-fdiagnostics-show-caret\" }\n \n void\n foo()\n {\n   float x = operator\"\" _F();  //  { dg-error  \"13:'operator\\\"\\\"_F' was not declared in this scope\" }\n+  /* { dg-begin-multiline-output \"\" }\n+   float x = operator\"\" _F();\n+             ^~~~~~~~~~~~~\n+     { dg-end-multiline-output \"\" } */\n+\n   float y = 0_F;  //  { dg-error  \"unable to find numeric literal operator\" }\n+  /* { dg-begin-multiline-output \"\" }\n+   float y = 0_F;\n+             ^~~\n+     { dg-end-multiline-output \"\" } */\n }"}, {"sha": "fab5849dfc7f846fc616878976e9d00792ff934b", "filename": "gcc/testsuite/g++.dg/diagnostic/bad-binary-ops.C", "status": "modified", "additions": 55, "deletions": 2, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a14feb3c783fba6af8d66b8138214a3a313be5c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fbad-binary-ops.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a14feb3c783fba6af8d66b8138214a3a313be5c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fbad-binary-ops.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fbad-binary-ops.C?ref=a14feb3c783fba6af8d66b8138214a3a313be5c5", "patch": "@@ -11,7 +11,10 @@ void test_1 ()\n \n /* { dg-begin-multiline-output \"\" }\n    myvec[1] / ptr;\n-   ~~~~~~~~~^~~~~\n+   ~~~~~~~~ ^ ~~~\n+          |   |\n+          |   const int*\n+          __m128 {aka float}\n    { dg-end-multiline-output \"\" } */\n }\n \n@@ -28,17 +31,67 @@ int test_2 (void)\n /* { dg-begin-multiline-output \"\" }\n    return (some_function ()\n            ~~~~~~~~~~~~~~~~\n+                         |\n+                         s\n     + some_other_function ());\n-    ^~~~~~~~~~~~~~~~~~~~~~~~\n+    ^ ~~~~~~~~~~~~~~~~~~~~~~\n+                          |\n+                          t\n    { dg-end-multiline-output \"\" } */\n }\n \n int test_3 (struct s param_s, struct t param_t)\n {\n   return param_s && param_t; // { dg-error \"no match for .operator\" }\n \n+/* { dg-begin-multiline-output \"\" }\n+   return param_s && param_t;\n+          ~~~~~~~ ^~ ~~~~~~~\n+          |          |\n+          s          t\n+   { dg-end-multiline-output \"\" } */\n /* { dg-begin-multiline-output \"\" }\n    return param_s && param_t;\n           ~~~~~~~~^~~~~~~~~~\n    { dg-end-multiline-output \"\" } */\n }\n+\n+namespace ns_4\n+{\n+  struct s foo;\n+  namespace inner {\n+    struct t bar;\n+  };\n+};\n+\n+int test_4a (void)\n+{\n+  return ns_4::foo && ns_4::inner::bar; // { dg-error \"no match for .operator\" }\n+  /* { dg-begin-multiline-output \"\" }\n+   return ns_4::foo && ns_4::inner::bar;\n+          ~~~~~~~~~ ^~ ~~~~~~~~~~~~~~~~\n+                |                   |\n+                s                   t\n+     { dg-end-multiline-output \"\" } */\n+\n+  /* { dg-begin-multiline-output \"\" }\n+   return ns_4::foo && ns_4::inner::bar;\n+          ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~\n+     { dg-end-multiline-output \"\" } */\n+}\n+\n+int test_4b (void)\n+{\n+  return ::ns_4::foo && ns_4::inner::bar; // { dg-error \"no match for .operator\" }\n+  /* { dg-begin-multiline-output \"\" }\n+   return ::ns_4::foo && ns_4::inner::bar;\n+          ~~~~~~~~~~~ ^~ ~~~~~~~~~~~~~~~~\n+                  |                   |\n+                  s                   t\n+     { dg-end-multiline-output \"\" } */\n+\n+  /* { dg-begin-multiline-output \"\" }\n+   return ::ns_4::foo && ns_4::inner::bar;\n+          ~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~\n+     { dg-end-multiline-output \"\" } */\n+}"}, {"sha": "de7570a6efacaa6996daca55d331b44909fdf7f0", "filename": "gcc/testsuite/g++.dg/diagnostic/param-type-mismatch-2.C", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a14feb3c783fba6af8d66b8138214a3a313be5c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fparam-type-mismatch-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a14feb3c783fba6af8d66b8138214a3a313be5c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fparam-type-mismatch-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fparam-type-mismatch-2.C?ref=a14feb3c783fba6af8d66b8138214a3a313be5c5", "patch": "@@ -204,7 +204,9 @@ int test_10 ()\n   return v10_a - v10_b; // { dg-error \"no match for\" }\n   /* { dg-begin-multiline-output \"\" }\n    return v10_a - v10_b;\n-          ~~~~~~^~~~~~~\n+          ~~~~~ ^ ~~~~~\n+          |       |\n+          s10     s10\n      { dg-end-multiline-output \"\" } */\n   // { dg-message \"candidate\" \"\" { target *-*-* } s10_operator }\n   /* { dg-begin-multiline-output \"\" }"}, {"sha": "ed37e5455743bcc16a09cb6639685cec1b5b571a", "filename": "gcc/tree.h", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a14feb3c783fba6af8d66b8138214a3a313be5c5/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a14feb3c783fba6af8d66b8138214a3a313be5c5/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=a14feb3c783fba6af8d66b8138214a3a313be5c5", "patch": "@@ -5962,4 +5962,53 @@ fndecl_built_in_p (const_tree node, built_in_function name)\n \t  && DECL_FUNCTION_CODE (node) == name);\n }\n \n+/* A struct for encapsulating location information about an operator\n+   and the operation built from it.\n+\n+   m_operator_loc is the location of the operator\n+   m_combined_loc is the location of the compound expression.\n+\n+   For example, given \"a && b\" the, operator location is:\n+      a && b\n+        ^~\n+   and the combined location is:\n+      a && b\n+      ~~^~~~\n+   Capturing this information allows for class binary_op_rich_location\n+   to provide detailed information about e.g. type mismatches in binary\n+   operations where enough location information is available:\n+\n+     arg_0 op arg_1\n+     ~~~~~ ^~ ~~~~~\n+       |        |\n+       |        arg1 type\n+       arg0 type\n+\n+   falling back to just showing the combined location:\n+\n+     arg_0 op arg_1\n+     ~~~~~~^~~~~~~~\n+\n+   where it is not.  */\n+\n+struct op_location_t\n+{\n+  location_t m_operator_loc;\n+  location_t m_combined_loc;\n+\n+  /* 1-argument ctor, for constructing from a combined location.  */\n+  op_location_t (location_t combined_loc)\n+  : m_operator_loc (UNKNOWN_LOCATION), m_combined_loc (combined_loc)\n+  {}\n+\n+  /* 2-argument ctor, for distinguishing between the operator's location\n+     and the combined location.  */\n+  op_location_t (location_t operator_loc, location_t combined_loc)\n+  : m_operator_loc (operator_loc), m_combined_loc (combined_loc)\n+  {}\n+\n+  /* Implicitly convert back to a location_t, using the combined location.  */\n+  operator location_t () const { return m_combined_loc; }\n+};\n+\n #endif  /* GCC_TREE_H  */"}]}