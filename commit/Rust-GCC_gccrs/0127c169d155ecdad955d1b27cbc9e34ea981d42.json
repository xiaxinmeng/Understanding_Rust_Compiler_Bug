{"sha": "0127c169d155ecdad955d1b27cbc9e34ea981d42", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDEyN2MxNjlkMTU1ZWNkYWQ5NTVkMWIyN2NiYzllMzRlYTk4MWQ0Mg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-10-05T05:02:19Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-10-05T05:02:19Z"}, "message": "ipa-polymorphic-call.c (walk_ssa_copies): Recognize NULL pointer checks.\n\n\n\n\t* ipa-polymorphic-call.c (walk_ssa_copies): Recognize\n\tNULL pointer checks.\n\t(ipa_polymorphic_call_context::get_dynamic_type): Return true\n\tif type doesn't change.\n\t* cgraph.h (cgraph_indirect_call_info): New flag.\n\t* cgraph.c (cgraph_node::create_indirect_edge): Initialize it.\n\t(cgraph_node::dump): Dump it.\n\t* ipa-prop.c (ipa_analyze_call_uses):  Ignore return valud\n\tof context.get_dynamic_type.\n\t(ipa_make_edge_direct_to_target): Do not speculate\n\tedge that is already speuclative.\n\t(try_make_edge_direct_virtual_call): Use VPTR_CHANGED; Do not\n\tspeculate to __builtin_unreachable\n\t(ipa_write_indirect_edge_info, ipa_read_indirect_edge_info): Stream\n\tvptr_changed.\n\t* ipa-cp.c (ipa_get_indirect_edge_target_1): Use vptr_changed.\n\t* g++.dg/ipa/devirt-47.C: New testcase.\n\nFrom-SVN: r215898", "tree": {"sha": "d2428ebac5861155cb99905a9e92c774a2f64be7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2428ebac5861155cb99905a9e92c774a2f64be7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0127c169d155ecdad955d1b27cbc9e34ea981d42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0127c169d155ecdad955d1b27cbc9e34ea981d42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0127c169d155ecdad955d1b27cbc9e34ea981d42", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0127c169d155ecdad955d1b27cbc9e34ea981d42/comments", "author": null, "committer": null, "parents": [{"sha": "2add94cd4415d64ea2a075abfa1ce74a9ee39053", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2add94cd4415d64ea2a075abfa1ce74a9ee39053", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2add94cd4415d64ea2a075abfa1ce74a9ee39053"}], "stats": {"total": 186, "additions": 161, "deletions": 25}, "files": [{"sha": "3bf6de1581c8c7b86f55bb45e0bf77d9c4a6a34d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0127c169d155ecdad955d1b27cbc9e34ea981d42/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0127c169d155ecdad955d1b27cbc9e34ea981d42/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0127c169d155ecdad955d1b27cbc9e34ea981d42", "patch": "@@ -1,3 +1,22 @@\n+2014-10-04  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-polymorphic-call.c (walk_ssa_copies): Recognize\n+\tNULL pointer checks.\n+\t(ipa_polymorphic_call_context::get_dynamic_type): Return true\n+\tif type doesn't change.\n+\t* cgraph.h (cgraph_indirect_call_info): New flag.\n+\t* cgraph.c (cgraph_node::create_indirect_edge): Initialize it.\n+\t(cgraph_node::dump): Dump it.\n+\t* ipa-prop.c (ipa_analyze_call_uses):  Ignore return valud\n+\tof context.get_dynamic_type.\n+\t(ipa_make_edge_direct_to_target): Do not speculate\n+\tedge that is already speuclative.\n+\t(try_make_edge_direct_virtual_call): Use VPTR_CHANGED; Do not\n+\tspeculate to __builtin_unreachable\n+\t(ipa_write_indirect_edge_info, ipa_read_indirect_edge_info): Stream\n+\tvptr_changed.\n+\t* ipa-cp.c (ipa_get_indirect_edge_target_1): Use vptr_changed.\n+\n 2014-10-04  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-prop.c (ipa_compute_jump_functions_for_edge): Call"}, {"sha": "38dc7e663fa12b72cb2858f6035dfed1d6092cf4", "filename": "gcc/cgraph.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0127c169d155ecdad955d1b27cbc9e34ea981d42/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0127c169d155ecdad955d1b27cbc9e34ea981d42/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=0127c169d155ecdad955d1b27cbc9e34ea981d42", "patch": "@@ -883,6 +883,7 @@ cgraph_node::create_indirect_edge (gimple call_stmt, int ecf_flags,\n \n   edge->indirect_info = cgraph_allocate_init_indirect_info ();\n   edge->indirect_info->ecf_flags = ecf_flags;\n+  edge->indirect_info->vptr_changed = true;\n \n   /* Record polymorphic call info.  */\n   if (compute_indirect_info\n@@ -1988,6 +1989,8 @@ cgraph_node::dump (FILE *f)\n \t\t    edge->indirect_info->member_ptr ? \"member ptr\" : \"aggregate\",\n \t\t    edge->indirect_info->by_ref ? \"passed by reference\":\"\",\n \t\t    (int)edge->indirect_info->offset);\n+\t  if (edge->indirect_info->vptr_changed)\n+\t    fprintf (f, \" (vptr maybe changed)\");\n \t}\n       fprintf (f, \"\\n\");\n       if (edge->indirect_info->polymorphic)"}, {"sha": "20b5c4e4805cb08d30cd20fbccf1a137c350c3f0", "filename": "gcc/cgraph.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0127c169d155ecdad955d1b27cbc9e34ea981d42/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0127c169d155ecdad955d1b27cbc9e34ea981d42/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=0127c169d155ecdad955d1b27cbc9e34ea981d42", "patch": "@@ -1393,6 +1393,9 @@ struct GTY(()) cgraph_indirect_call_info\n   /* When the previous bit is set, this one determines whether the destination\n      is loaded from a parameter passed by reference. */\n   unsigned by_ref : 1;\n+  /* For polymorphic calls this specify whether the virtual table pointer\n+     may have changed in between function entry and the call.  */\n+  unsigned vptr_changed : 1;\n };\n \n struct GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"))) cgraph_edge {"}, {"sha": "a3be16f8bf45b63fd6bb1f2a51e4bacd20224bbf", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0127c169d155ecdad955d1b27cbc9e34ea981d42/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0127c169d155ecdad955d1b27cbc9e34ea981d42/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=0127c169d155ecdad955d1b27cbc9e34ea981d42", "patch": "@@ -1560,7 +1560,8 @@ ipa_get_indirect_edge_target_1 (struct cgraph_edge *ie,\n   t = NULL;\n \n   /* Try to work out value of virtual table pointer value in replacemnets.  */\n-  if (!t && agg_reps && !ie->indirect_info->by_ref)\n+  if (!t && agg_reps && !ie->indirect_info->by_ref\n+      && !ie->indirect_info->vptr_changed)\n     {\n       while (agg_reps)\n \t{\n@@ -1578,7 +1579,8 @@ ipa_get_indirect_edge_target_1 (struct cgraph_edge *ie,\n   /* Try to work out value of virtual table pointer value in known\n      aggregate values.  */\n   if (!t && known_aggs.length () > (unsigned int) param_index\n-      && !ie->indirect_info->by_ref)\n+      && !ie->indirect_info->by_ref\n+      && !ie->indirect_info->vptr_changed)\n     {\n        struct ipa_agg_jump_function *agg;\n        agg = known_aggs[param_index];"}, {"sha": "74226f21a87132a3859b2a6b3ef080f2de4d768c", "filename": "gcc/ipa-polymorphic-call.c", "status": "modified", "additions": 33, "deletions": 5, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0127c169d155ecdad955d1b27cbc9e34ea981d42/gcc%2Fipa-polymorphic-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0127c169d155ecdad955d1b27cbc9e34ea981d42/gcc%2Fipa-polymorphic-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-polymorphic-call.c?ref=0127c169d155ecdad955d1b27cbc9e34ea981d42", "patch": "@@ -760,11 +760,37 @@ walk_ssa_copies (tree op)\n   while (TREE_CODE (op) == SSA_NAME\n \t && !SSA_NAME_IS_DEFAULT_DEF (op)\n \t && SSA_NAME_DEF_STMT (op)\n-\t && gimple_assign_single_p (SSA_NAME_DEF_STMT (op)))\n+\t && (gimple_assign_single_p (SSA_NAME_DEF_STMT (op))\n+\t     || gimple_code (SSA_NAME_DEF_STMT (op)) == GIMPLE_PHI))\n     {\n-      if (gimple_assign_load_p (SSA_NAME_DEF_STMT (op)))\n-\treturn op;\n-      op = gimple_assign_rhs1 (SSA_NAME_DEF_STMT (op));\n+      /* Special case\n+\t if (ptr == 0)\n+\t   ptr = 0;\n+\t else\n+\t   ptr = ptr.foo;\n+\t This pattern is implicitly produced for casts to non-primary\n+\t bases.  When doing context analysis, we do not really care\n+\t about the case pointer is NULL, becuase the call will be\n+\t undefined anyway.  */\n+      if (gimple_code (SSA_NAME_DEF_STMT (op)) == GIMPLE_PHI)\n+\t{\n+\t  gimple phi = SSA_NAME_DEF_STMT (op);\n+\n+\t  if (gimple_phi_num_args (phi) != 2)\n+\t    return op;\n+\t  if (integer_zerop (gimple_phi_arg_def (phi, 0)))\n+\t    op = gimple_phi_arg_def (phi, 1);\n+\t  else if (integer_zerop (gimple_phi_arg_def (phi, 1)))\n+\t    op = gimple_phi_arg_def (phi, 0);\n+\t  else\n+\t    return op;\n+\t}\n+      else\n+\t{\n+\t  if (gimple_assign_load_p (SSA_NAME_DEF_STMT (op)))\n+\t    return op;\n+\t  op = gimple_assign_rhs1 (SSA_NAME_DEF_STMT (op));\n+\t}\n       STRIP_NOPS (op);\n     }\n   return op;\n@@ -1371,6 +1397,8 @@ check_stmt_for_type_change (ao_ref *ao ATTRIBUTE_UNUSED, tree vdef, void *data)\n    is set), try to walk memory writes and find the actual construction of the\n    instance.\n \n+   Return true if memory is unchanged from function entry.\n+\n    We do not include this analysis in the context analysis itself, because\n    it needs memory SSA to be fully built and the walk may be expensive.\n    So it is not suitable for use withing fold_stmt and similar uses.  */\n@@ -1615,7 +1643,7 @@ ipa_polymorphic_call_context::get_dynamic_type (tree instance,\n \t       function_entry_reached ? \" (multiple types encountered)\" : \"\");\n     }\n \n-  return true;\n+  return false;\n }\n \n /* See if speculation given by SPEC_OUTER_TYPE, SPEC_OFFSET and SPEC_MAYBE_DERIVED_TYPE"}, {"sha": "80acdcc21bb5ab5010bbc62b41a7f927d3285454", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 64, "deletions": 18, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0127c169d155ecdad955d1b27cbc9e34ea981d42/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0127c169d155ecdad955d1b27cbc9e34ea981d42/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=0127c169d155ecdad955d1b27cbc9e34ea981d42", "patch": "@@ -2371,10 +2371,10 @@ ipa_analyze_call_uses (struct func_body_info *fbi, gimple call)\n       gcc_checking_assert (cs->indirect_info->otr_token\n \t\t\t   == tree_to_shwi (OBJ_TYPE_REF_TOKEN (target)));\n \n-      if (context.get_dynamic_type (instance,\n-\t\t\t\t    OBJ_TYPE_REF_OBJECT (target),\n-\t\t\t\t    obj_type_ref_class (target), call))\n-\tcs->indirect_info->context = context;\n+      context.get_dynamic_type (instance,\n+\t\t\t\tOBJ_TYPE_REF_OBJECT (target),\n+\t\t\t\tobj_type_ref_class (target), call);\n+      cs->indirect_info->context = context;\n     }\n \n   if (TREE_CODE (target) == SSA_NAME)\n@@ -2878,6 +2878,38 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target,\n       callee = cgraph_node::get_create (target);\n     }\n \n+  /* If the edge is already speculated.  */\n+  if (speculative && ie->speculative)\n+    {\n+      struct cgraph_edge *e2;\n+      struct ipa_ref *ref;\n+      ie->speculative_call_info (e2, ie, ref);\n+      if (e2->callee->ultimate_alias_target ()\n+\t  != callee->ultimate_alias_target ())\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"ipa-prop: Discovered call to a speculative target \"\n+\t\t     \"(%s/%i -> %s/%i) but the call is already speculated to %s/%i. Giving up.\\n\",\n+\t\t     xstrdup (ie->caller->name ()),\n+\t\t     ie->caller->order,\n+\t\t     xstrdup (callee->name ()),\n+\t\t     callee->order,\n+\t\t     xstrdup (e2->callee->name ()),\n+\t\t     e2->callee->order);\n+\t}\n+      else\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"ipa-prop: Discovered call to a speculative target \"\n+\t\t     \"(%s/%i -> %s/%i) this agree with previous speculation.\\n\",\n+\t\t     xstrdup (ie->caller->name ()),\n+\t\t     ie->caller->order,\n+\t\t     xstrdup (callee->name ()),\n+\t\t     callee->order);\n+\t}\n+      return NULL;\n+    }\n+\n   if (!dbg_cnt (devirt))\n     return NULL;\n \n@@ -3127,17 +3159,17 @@ try_make_edge_direct_virtual_call (struct cgraph_edge *ie,\n \n       ctx.offset_by (ie->indirect_info->offset);\n \n-      /* TODO: We want to record if type change happens.  \n-\t Old code did not do that that seems like a bug.  */\n-      ctx.possible_dynamic_type_change (ie->in_polymorphic_cdtor,\n-\t\t\t\t\tie->indirect_info->otr_type);\n+      if (ie->indirect_info->vptr_changed)\n+\tctx.possible_dynamic_type_change (ie->in_polymorphic_cdtor,\n+\t\t\t\t\t  ie->indirect_info->otr_type);\n \n       updated = ie->indirect_info->context.combine_with\n \t\t  (ctx, ie->indirect_info->otr_type);\n     }\n \n   /* Try to do lookup via known virtual table pointer value.  */\n-  if (!ie->indirect_info->by_ref)\n+  if (!ie->indirect_info->by_ref\n+      && (!ie->indirect_info->vptr_changed || flag_devirtualize_speculatively))\n     {\n       tree vtable;\n       unsigned HOST_WIDE_INT offset;\n@@ -3146,16 +3178,24 @@ try_make_edge_direct_virtual_call (struct cgraph_edge *ie,\n \t\t\t\t\t   true);\n       if (t && vtable_pointer_value_to_vtable (t, &vtable, &offset))\n \t{\n-\t  target = gimple_get_virt_method_for_vtable (ie->indirect_info->otr_token,\n+\t  t = gimple_get_virt_method_for_vtable (ie->indirect_info->otr_token,\n \t\t\t\t\t\t      vtable, offset);\n-\t  if (target)\n+\t  if (t)\n \t    {\n-\t      if ((TREE_CODE (TREE_TYPE (target)) == FUNCTION_TYPE\n-\t\t   && DECL_FUNCTION_CODE (target) == BUILT_IN_UNREACHABLE)\n+\t      if ((TREE_CODE (TREE_TYPE (t)) == FUNCTION_TYPE\n+\t\t   && DECL_FUNCTION_CODE (t) == BUILT_IN_UNREACHABLE)\n \t\t  || !possible_polymorphic_call_target_p\n-\t\t       (ie, cgraph_node::get (target)))\n-\t\ttarget = ipa_impossible_devirt_target (ie, target);\n-\t      return ipa_make_edge_direct_to_target (ie, target);\n+\t\t       (ie, cgraph_node::get (t)))\n+\t\t{\n+\t\t  /* Do not speculate builtin_unreachable, it is stpid!  */\n+\t\t  if (!ie->indirect_info->vptr_changed)\n+\t\t    target = ipa_impossible_devirt_target (ie, target);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  target = t;\n+\t\t  speculative = ie->indirect_info->vptr_changed;\n+\t\t}\n \t    }\n \t}\n     }\n@@ -3188,7 +3228,7 @@ try_make_edge_direct_virtual_call (struct cgraph_edge *ie,\n \t  else\n \t    target = ipa_impossible_devirt_target (ie, NULL_TREE);\n \t}\n-      else if (flag_devirtualize_speculatively\n+      else if (!target && flag_devirtualize_speculatively\n \t       && !ie->speculative && ie->maybe_hot_p ())\n \t{\n \t  cgraph_node *n = try_speculative_devirtualization (ie->indirect_info->otr_type,\n@@ -3222,7 +3262,11 @@ try_make_edge_direct_virtual_call (struct cgraph_edge *ie,\n   if (target)\n     {\n       if (!possible_polymorphic_call_target_p (ie, cgraph_node::get_create (target)))\n-\ttarget = ipa_impossible_devirt_target (ie, target);\n+\t{\n+\t  if (!speculative)\n+\t    return NULL;\n+\t  target = ipa_impossible_devirt_target (ie, target);\n+\t}\n       return ipa_make_edge_direct_to_target (ie, target, speculative);\n     }\n   else\n@@ -4801,6 +4845,7 @@ ipa_write_indirect_edge_info (struct output_block *ob,\n   bp_pack_value (&bp, ii->agg_contents, 1);\n   bp_pack_value (&bp, ii->member_ptr, 1);\n   bp_pack_value (&bp, ii->by_ref, 1);\n+  bp_pack_value (&bp, ii->vptr_changed, 1);\n   streamer_write_bitpack (&bp);\n   if (ii->agg_contents || ii->polymorphic)\n     streamer_write_hwi (ob, ii->offset);\n@@ -4832,6 +4877,7 @@ ipa_read_indirect_edge_info (struct lto_input_block *ib,\n   ii->agg_contents = bp_unpack_value (&bp, 1);\n   ii->member_ptr = bp_unpack_value (&bp, 1);\n   ii->by_ref = bp_unpack_value (&bp, 1);\n+  ii->vptr_changed = bp_unpack_value (&bp, 1);\n   if (ii->agg_contents || ii->polymorphic)\n     ii->offset = (HOST_WIDE_INT) streamer_read_hwi (ib);\n   else"}, {"sha": "ce04eacf5c06ad635b104f5b293c638737be7991", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0127c169d155ecdad955d1b27cbc9e34ea981d42/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0127c169d155ecdad955d1b27cbc9e34ea981d42/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0127c169d155ecdad955d1b27cbc9e34ea981d42", "patch": "@@ -1,3 +1,7 @@\n+2014-10-04  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* g++.dg/ipa/devirt-47.C: New testcase.\n+\n 2014-10-04  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR ipa/61144"}, {"sha": "85f7b634342cf17d3fbb05b1a515dae360f25632", "filename": "gcc/testsuite/g++.dg/ipa/devirt-47.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0127c169d155ecdad955d1b27cbc9e34ea981d42/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-47.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0127c169d155ecdad955d1b27cbc9e34ea981d42/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-47.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-47.C?ref=0127c169d155ecdad955d1b27cbc9e34ea981d42", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fno-ipa-cp -fdump-ipa-inline-details -fno-early-inlining -fdump-tree-optimized\" } */\n+struct A {\n+   virtual int foo(){return 1;}\n+};\n+struct B {\n+   virtual int bar(){return 4;}\n+};\n+struct C:B,A {\n+   virtual int foo(){return 2;}\n+};\n+static void\n+test (struct A *a)\n+{\n+  if (a->foo() != 2)\n+   __builtin_abort ();\n+}\n+int\n+m()\n+{\n+  struct A *a = new C;\n+  test (a);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-ipa-dump-times \"Discovered a virtual call to a speculative target\\[^\\\\n\\]*C::_ZTh\" 1 \"inline\"  } } */\n+/* { dg-final { scan-ipa-dump-not \"OBJ_TYPE_REF\" \"optimized\"  } } */\n+/* FIXME: We ought to inline thunk.  */\n+/* { dg-final { scan-ipa-dump \"C::_ZThn\" \"optimized\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"inline\" } } */\n+/* { dg-final { cleanup-ipa-dump \"optimized\" } } */"}]}