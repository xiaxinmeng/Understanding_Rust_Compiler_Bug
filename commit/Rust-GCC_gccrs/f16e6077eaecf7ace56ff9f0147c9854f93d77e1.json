{"sha": "f16e6077eaecf7ace56ff9f0147c9854f93d77e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjE2ZTYwNzdlYWVjZjdhY2U1NmZmOWYwMTQ3Yzk4NTRmOTNkNzdlMQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2015-10-30T13:45:42Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2015-10-30T13:45:42Z"}, "message": "Allow real_format to be passed to more real.h functions\n\nMost real.h routines used machine modes to specify the format of\nan operation and converted that to a float_format * internally.\nSome also had alternative versions that accepted a float_format *.\n\nIn an upcoming patch it seemed more convenient for the callers\nI was adding to use float_format directly, since the callers need\nto examine the format themselves for other reasons.  This patch\ntherefore replaces the machine_mode arguments with a new class that\nallows both machine modes and float_format pointers to be used.\n\nTested on x86_64-linux-gnu, arm-linux-gnueabi and aarch64-linux-gnu.\n\ngcc/\n\t* real.h (format_helper): New.\n\t(real_convert, exact_real_truncate, real_from_string3, real_to_target)\n\t(real_from_target, real_nan, real_2expN, real_value_truncate)\n\t(significand_size, real_from_string2, exact_real_inverse)\n\t(exact_real_inverse, real_powi, real_trunc, real_floor, real_ceil)\n\t(real_round, real_isinteger, real_from_integer): Replace\n\tmachine_mode arguments with format_helper arguments.\n\t* real.c (exact_real_inverse, real_from_string2, real_from_string3)\n\t(real_from_integer, real_nan, real_2expN, real_convert)\n\t(real_value_truncate, exact_real_truncate, real_to_target)\n\t(real_from_target, significand_size, real_powi, real_trunc)\n\t(real_floor, real_ceil, real_round, real_isinteger): Replace\n\tmachine_mode arguments with format_helper arguments.\n\t(real_to_target_fmt, real_from_target_fmt): Delete.\n\t* dfp.h (decimal_real_convert): Replace mode argument with real_format.\n\t* dfp.c (decimal_to_binary, decimal_real_convert): Replace mode\n\targument with real_format.\n\t* builtins.c (do_real_to_int_conversion): Update type of fn argument.\n\ngcc/java/\n\t* jcf-parse.c (get_constant): Use real_from_target rather than\n\treal_from_target_fmt.\n\nFrom-SVN: r229581", "tree": {"sha": "2563ff48cbf908942137b14e5b91dba9144ee3c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2563ff48cbf908942137b14e5b91dba9144ee3c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f16e6077eaecf7ace56ff9f0147c9854f93d77e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f16e6077eaecf7ace56ff9f0147c9854f93d77e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f16e6077eaecf7ace56ff9f0147c9854f93d77e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f16e6077eaecf7ace56ff9f0147c9854f93d77e1/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4ff7defd046ca231a35c93b4000962b37ccad31c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ff7defd046ca231a35c93b4000962b37ccad31c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ff7defd046ca231a35c93b4000962b37ccad31c"}], "stats": {"total": 277, "additions": 138, "deletions": 139}, "files": [{"sha": "3d8b19c073b12c04a3a4e138bfca94a1838f3a15", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f16e6077eaecf7ace56ff9f0147c9854f93d77e1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f16e6077eaecf7ace56ff9f0147c9854f93d77e1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f16e6077eaecf7ace56ff9f0147c9854f93d77e1", "patch": "@@ -1,3 +1,24 @@\n+2015-10-30  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* real.h (format_helper): New.\n+\t(real_convert, exact_real_truncate, real_from_string3, real_to_target)\n+\t(real_from_target, real_nan, real_2expN, real_value_truncate)\n+\t(significand_size, real_from_string2, exact_real_inverse)\n+\t(exact_real_inverse, real_powi, real_trunc, real_floor, real_ceil)\n+\t(real_round, real_isinteger, real_from_integer): Replace\n+\tmachine_mode arguments with format_helper arguments.\n+\t* real.c (exact_real_inverse, real_from_string2, real_from_string3)\n+\t(real_from_integer, real_nan, real_2expN, real_convert)\n+\t(real_value_truncate, exact_real_truncate, real_to_target)\n+\t(real_from_target, significand_size, real_powi, real_trunc)\n+\t(real_floor, real_ceil, real_round, real_isinteger): Replace\n+\tmachine_mode arguments with format_helper arguments.\n+\t(real_to_target_fmt, real_from_target_fmt): Delete.\n+\t* dfp.h (decimal_real_convert): Replace mode argument with real_format.\n+\t* dfp.c (decimal_to_binary, decimal_real_convert): Replace mode\n+\targument with real_format.\n+\t* builtins.c (do_real_to_int_conversion): Update type of fn argument.\n+\n 2015-10-30  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* fixed-value.c (check_real_for_fixed_mode, fixed_from_string)"}, {"sha": "11c34e6623e43a79d7f353cab359f2dfe9bdc3a6", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f16e6077eaecf7ace56ff9f0147c9854f93d77e1/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f16e6077eaecf7ace56ff9f0147c9854f93d77e1/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=f16e6077eaecf7ace56ff9f0147c9854f93d77e1", "patch": "@@ -7273,7 +7273,7 @@ fold_builtin_strlen (location_t loc, tree type, tree arg)\n \n static tree\n do_real_to_int_conversion (tree itype, tree arg,\n-\t\t\t   void (*fn) (REAL_VALUE_TYPE *, machine_mode,\n+\t\t\t   void (*fn) (REAL_VALUE_TYPE *, format_helper,\n \t\t\t\t       const REAL_VALUE_TYPE *))\n {\n   if (TREE_CODE (arg) != REAL_CST || TREE_OVERFLOW (arg))"}, {"sha": "34386eb85865514cf308d285c4b027044cd51635", "filename": "gcc/dfp.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f16e6077eaecf7ace56ff9f0147c9854f93d77e1/gcc%2Fdfp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f16e6077eaecf7ace56ff9f0147c9854f93d77e1/gcc%2Fdfp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdfp.c?ref=f16e6077eaecf7ace56ff9f0147c9854f93d77e1", "patch": "@@ -343,13 +343,13 @@ decode_decimal128 (const struct real_format *fmt ATTRIBUTE_UNUSED,\n \n static void\n decimal_to_binary (REAL_VALUE_TYPE *to, const REAL_VALUE_TYPE *from,\n-\t\t   machine_mode mode)\n+\t\t   const real_format *fmt)\n {\n   char string[256];\n   const decimal128 *const d128 = (const decimal128 *) from->sig;\n \n   decimal128ToString (d128, string);\n-  real_from_string3 (to, string, mode);\n+  real_from_string3 (to, string, fmt);\n }\n \n \n@@ -459,15 +459,13 @@ decimal_round_for_format (const struct real_format *fmt, REAL_VALUE_TYPE *r)\n    binary and decimal types.  */\n \n void\n-decimal_real_convert (REAL_VALUE_TYPE *r, machine_mode mode,\n+decimal_real_convert (REAL_VALUE_TYPE *r, const real_format *fmt,\n \t\t      const REAL_VALUE_TYPE *a)\n {\n-  const struct real_format *fmt = REAL_MODE_FORMAT (mode);\n-\n   if (a->decimal && fmt->b == 10)\n     return;\n   if (a->decimal)\n-      decimal_to_binary (r, a, mode);\n+      decimal_to_binary (r, a, fmt);\n   else\n       decimal_from_binary (r, a);\n }"}, {"sha": "a3653c9de12c5702c4b55ef8ea5805ac56639cc4", "filename": "gcc/dfp.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f16e6077eaecf7ace56ff9f0147c9854f93d77e1/gcc%2Fdfp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f16e6077eaecf7ace56ff9f0147c9854f93d77e1/gcc%2Fdfp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdfp.h?ref=f16e6077eaecf7ace56ff9f0147c9854f93d77e1", "patch": "@@ -34,7 +34,8 @@ void encode_decimal128 (const struct real_format *fmt, long *, const REAL_VALUE_\n int  decimal_do_compare (const REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *, int);\n void decimal_real_from_string (REAL_VALUE_TYPE *, const char *);\n void decimal_round_for_format (const struct real_format *, REAL_VALUE_TYPE *);\n-void decimal_real_convert (REAL_VALUE_TYPE *, machine_mode, const REAL_VALUE_TYPE *);\n+void decimal_real_convert (REAL_VALUE_TYPE *, const real_format *,\n+\t\t\t   const REAL_VALUE_TYPE *);\n void decimal_real_to_decimal (char *, const REAL_VALUE_TYPE *, size_t, size_t, int);\n void decimal_do_fix_trunc (REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *);\n void decimal_real_maxval (REAL_VALUE_TYPE *, int, machine_mode);"}, {"sha": "15cd23c4ddba783c5f38793f7c679b28d652d7b8", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f16e6077eaecf7ace56ff9f0147c9854f93d77e1/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f16e6077eaecf7ace56ff9f0147c9854f93d77e1/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=f16e6077eaecf7ace56ff9f0147c9854f93d77e1", "patch": "@@ -1,3 +1,8 @@\n+2015-10-30  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* jcf-parse.c (get_constant): Use real_from_target rather than\n+\treal_from_target_fmt.\n+\n 2015-10-29  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* boehm.c: Reorder #include's and remove duplicates."}, {"sha": "792fdbff199b511804d2ef97d09d1d0513e97b40", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f16e6077eaecf7ace56ff9f0147c9854f93d77e1/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f16e6077eaecf7ace56ff9f0147c9854f93d77e1/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=f16e6077eaecf7ace56ff9f0147c9854f93d77e1", "patch": "@@ -1058,7 +1058,7 @@ get_constant (JCF *jcf, int index)\n \tlong buf = num;\n \tREAL_VALUE_TYPE d;\n \n-\treal_from_target_fmt (&d, &buf, &ieee_single_format);\n+\treal_from_target (&d, &buf, &ieee_single_format);\n \tvalue = build_real (float_type_node, d);\n \tbreak;\n       }\n@@ -1076,7 +1076,7 @@ get_constant (JCF *jcf, int index)\n \telse\n \t  buf[0] = lo, buf[1] = hi;\n \n-\treal_from_target_fmt (&d, buf, &ieee_double_format);\n+\treal_from_target (&d, buf, &ieee_double_format);\n \tvalue = build_real (double_type_node, d);\n \tbreak;\n       }"}, {"sha": "0480b14101b5652824636a6c6be280024dfe12d1", "filename": "gcc/real.c", "status": "modified", "additions": 60, "deletions": 103, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f16e6077eaecf7ace56ff9f0147c9854f93d77e1/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f16e6077eaecf7ace56ff9f0147c9854f93d77e1/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=f16e6077eaecf7ace56ff9f0147c9854f93d77e1", "patch": "@@ -1266,11 +1266,11 @@ real_identical (const REAL_VALUE_TYPE *a, const REAL_VALUE_TYPE *b)\n   return true;\n }\n \n-/* Try to change R into its exact multiplicative inverse in machine\n-   mode MODE.  Return true if successful.  */\n+/* Try to change R into its exact multiplicative inverse in format FMT.\n+   Return true if successful.  */\n \n bool\n-exact_real_inverse (machine_mode mode, REAL_VALUE_TYPE *r)\n+exact_real_inverse (format_helper fmt, REAL_VALUE_TYPE *r)\n {\n   const REAL_VALUE_TYPE *one = real_digit (1);\n   REAL_VALUE_TYPE u;\n@@ -1286,9 +1286,9 @@ exact_real_inverse (machine_mode mode, REAL_VALUE_TYPE *r)\n   if (r->sig[SIGSZ-1] != SIG_MSB)\n     return false;\n \n-  /* Find the inverse and truncate to the required mode.  */\n+  /* Find the inverse and truncate to the required format.  */\n   do_divide (&u, one, r);\n-  real_convert (&u, mode, &u);\n+  real_convert (&u, fmt, &u);\n \n   /* The rounding may have overflowed.  */\n   if (u.cl != rvc_normal)\n@@ -2104,35 +2104,36 @@ real_from_string (REAL_VALUE_TYPE *r, const char *str)\n /* Legacy.  Similar, but return the result directly.  */\n \n REAL_VALUE_TYPE\n-real_from_string2 (const char *s, machine_mode mode)\n+real_from_string2 (const char *s, format_helper fmt)\n {\n   REAL_VALUE_TYPE r;\n \n   real_from_string (&r, s);\n-  if (mode != VOIDmode)\n-    real_convert (&r, mode, &r);\n+  if (fmt)\n+    real_convert (&r, fmt, &r);\n \n   return r;\n }\n \n-/* Initialize R from string S and desired MODE. */\n+/* Initialize R from string S and desired format FMT. */\n \n void\n-real_from_string3 (REAL_VALUE_TYPE *r, const char *s, machine_mode mode)\n+real_from_string3 (REAL_VALUE_TYPE *r, const char *s, format_helper fmt)\n {\n-  if (DECIMAL_FLOAT_MODE_P (mode))\n+  if (fmt.decimal_p ())\n     decimal_real_from_string (r, s);\n   else\n     real_from_string (r, s);\n \n-  if (mode != VOIDmode)\n-    real_convert (r, mode, r);\n+  if (fmt)\n+    real_convert (r, fmt, r);\n }\n \n-/* Initialize R from the wide_int VAL_IN.  The MODE is not VOIDmode,*/\n+/* Initialize R from the wide_int VAL_IN.  Round it to format FMT if\n+   FMT is nonnull.  */\n \n void\n-real_from_integer (REAL_VALUE_TYPE *r, machine_mode mode,\n+real_from_integer (REAL_VALUE_TYPE *r, format_helper fmt,\n \t\t   const wide_int_ref &val_in, signop sgn)\n {\n   if (val_in == 0)\n@@ -2216,10 +2217,10 @@ real_from_integer (REAL_VALUE_TYPE *r, machine_mode mode,\n       normalize (r);\n     }\n \n-  if (DECIMAL_FLOAT_MODE_P (mode))\n+  if (fmt.decimal_p ())\n     decimal_from_integer (r);\n-  else if (mode != VOIDmode)\n-    real_convert (r, mode, r);\n+  else if (fmt)\n+    real_convert (r, fmt, r);\n }\n \n /* Render R, an integral value, as a floating point constant with no\n@@ -2448,13 +2449,8 @@ real_inf (REAL_VALUE_TYPE *r)\n \n bool\n real_nan (REAL_VALUE_TYPE *r, const char *str, int quiet,\n-\t  machine_mode mode)\n+\t  format_helper fmt)\n {\n-  const struct real_format *fmt;\n-\n-  fmt = REAL_MODE_FORMAT (mode);\n-  gcc_assert (fmt);\n-\n   if (*str == 0)\n     {\n       if (quiet)\n@@ -2574,7 +2570,7 @@ real_maxval (REAL_VALUE_TYPE *r, int sign, machine_mode mode)\n /* Fills R with 2**N.  */\n \n void\n-real_2expN (REAL_VALUE_TYPE *r, int n, machine_mode fmode)\n+real_2expN (REAL_VALUE_TYPE *r, int n, format_helper fmt)\n {\n   memset (r, 0, sizeof (*r));\n \n@@ -2589,8 +2585,8 @@ real_2expN (REAL_VALUE_TYPE *r, int n, machine_mode fmode)\n       SET_REAL_EXP (r, n);\n       r->sig[SIGSZ-1] = SIG_MSB;\n     }\n-  if (DECIMAL_FLOAT_MODE_P (fmode))\n-    decimal_real_convert (r, fmode, r);\n+  if (fmt.decimal_p ())\n+    decimal_real_convert (r, fmt, r);\n }\n \n \f\n@@ -2612,7 +2608,7 @@ round_for_format (const struct real_format *fmt, REAL_VALUE_TYPE *r)\n \t (e.g. -O0 on '_Decimal32 x = 1.0 + 2.0dd'), but have not\n \t investigated whether this convert needs to be here, or\n \t something else is missing. */\n-      decimal_real_convert (r, DFmode, r);\n+      decimal_real_convert (r, REAL_MODE_FORMAT (DFmode), r);\n     }\n \n   p2 = fmt->p;\n@@ -2718,21 +2714,16 @@ round_for_format (const struct real_format *fmt, REAL_VALUE_TYPE *r)\n   clear_significand_below (r, np2);\n }\n \n-/* Extend or truncate to a new mode.  */\n+/* Extend or truncate to a new format.  */\n \n void\n-real_convert (REAL_VALUE_TYPE *r, machine_mode mode,\n+real_convert (REAL_VALUE_TYPE *r, format_helper fmt,\n \t      const REAL_VALUE_TYPE *a)\n {\n-  const struct real_format *fmt;\n-\n-  fmt = REAL_MODE_FORMAT (mode);\n-  gcc_assert (fmt);\n-\n   *r = *a;\n \n   if (a->decimal || fmt->b == 10)\n-    decimal_real_convert (r, mode, a);\n+    decimal_real_convert (r, fmt, a);\n \n   round_for_format (fmt, r);\n \n@@ -2744,32 +2735,28 @@ real_convert (REAL_VALUE_TYPE *r, machine_mode mode,\n /* Legacy.  Likewise, except return the struct directly.  */\n \n REAL_VALUE_TYPE\n-real_value_truncate (machine_mode mode, REAL_VALUE_TYPE a)\n+real_value_truncate (format_helper fmt, REAL_VALUE_TYPE a)\n {\n   REAL_VALUE_TYPE r;\n-  real_convert (&r, mode, &a);\n+  real_convert (&r, fmt, &a);\n   return r;\n }\n \n-/* Return true if truncating to MODE is exact.  */\n+/* Return true if truncating to FMT is exact.  */\n \n bool\n-exact_real_truncate (machine_mode mode, const REAL_VALUE_TYPE *a)\n+exact_real_truncate (format_helper fmt, const REAL_VALUE_TYPE *a)\n {\n-  const struct real_format *fmt;\n   REAL_VALUE_TYPE t;\n   int emin2m1;\n \n-  fmt = REAL_MODE_FORMAT (mode);\n-  gcc_assert (fmt);\n-\n   /* Don't allow conversion to denormals.  */\n   emin2m1 = fmt->emin - 1;\n   if (REAL_EXP (a) <= emin2m1)\n     return false;\n \n-  /* After conversion to the new mode, the value must be identical.  */\n-  real_convert (&t, mode, a);\n+  /* After conversion to the new format, the value must be identical.  */\n+  real_convert (&t, fmt, a);\n   return real_identical (&t, a);\n }\n \n@@ -2780,8 +2767,8 @@ exact_real_truncate (machine_mode mode, const REAL_VALUE_TYPE *a)\n    Legacy: return word 0 for implementing REAL_VALUE_TO_TARGET_SINGLE.  */\n \n long\n-real_to_target_fmt (long *buf, const REAL_VALUE_TYPE *r_orig,\n-\t\t    const struct real_format *fmt)\n+real_to_target (long *buf, const REAL_VALUE_TYPE *r_orig,\n+\t\tformat_helper fmt)\n {\n   REAL_VALUE_TYPE r;\n   long buf1;\n@@ -2796,62 +2783,32 @@ real_to_target_fmt (long *buf, const REAL_VALUE_TYPE *r_orig,\n   return *buf;\n }\n \n-/* Similar, but look up the format from MODE.  */\n-\n-long\n-real_to_target (long *buf, const REAL_VALUE_TYPE *r, machine_mode mode)\n-{\n-  const struct real_format *fmt;\n-\n-  fmt = REAL_MODE_FORMAT (mode);\n-  gcc_assert (fmt);\n-\n-  return real_to_target_fmt (buf, r, fmt);\n-}\n-\n /* Read R from the given target format.  Read the words of the result\n    in target word order in BUF.  There are always 32 bits in each\n    long, no matter the size of the host long.  */\n \n void\n-real_from_target_fmt (REAL_VALUE_TYPE *r, const long *buf,\n-\t\t      const struct real_format *fmt)\n+real_from_target (REAL_VALUE_TYPE *r, const long *buf, format_helper fmt)\n {\n   (*fmt->decode) (fmt, r, buf);\n }\n \n-/* Similar, but look up the format from MODE.  */\n-\n-void\n-real_from_target (REAL_VALUE_TYPE *r, const long *buf, machine_mode mode)\n-{\n-  const struct real_format *fmt;\n-\n-  fmt = REAL_MODE_FORMAT (mode);\n-  gcc_assert (fmt);\n-\n-  (*fmt->decode) (fmt, r, buf);\n-}\n-\n /* Return the number of bits of the largest binary value that the\n-   significand of MODE will hold.  */\n+   significand of FMT will hold.  */\n /* ??? Legacy.  Should get access to real_format directly.  */\n \n int\n-significand_size (machine_mode mode)\n+significand_size (format_helper fmt)\n {\n-  const struct real_format *fmt;\n-\n-  fmt = REAL_MODE_FORMAT (mode);\n   if (fmt == NULL)\n     return 0;\n \n   if (fmt->b == 10)\n     {\n       /* Return the size in bits of the largest binary value that can be\n-\t held by the decimal coefficient for this mode.  This is one more\n+\t held by the decimal coefficient for this format.  This is one more\n \t than the number of bits required to hold the largest coefficient\n-\t of this mode.  */\n+\t of this format.  */\n       double log2_10 = 3.3219281;\n       return fmt->p * log2_10;\n     }\n@@ -4861,14 +4818,14 @@ const struct real_format real_internal_format =\n     \"real_internal\"\n   };\n \f\n-/* Calculate X raised to the integer exponent N in mode MODE and store\n+/* Calculate X raised to the integer exponent N in format FMT and store\n    the result in R.  Return true if the result may be inexact due to\n    loss of precision.  The algorithm is the classic \"left-to-right binary\n    method\" described in section 4.6.3 of Donald Knuth's \"Seminumerical\n    Algorithms\", \"The Art of Computer Programming\", Volume 2.  */\n \n bool\n-real_powi (REAL_VALUE_TYPE *r, machine_mode mode,\n+real_powi (REAL_VALUE_TYPE *r, format_helper fmt,\n \t   const REAL_VALUE_TYPE *x, HOST_WIDE_INT n)\n {\n   unsigned HOST_WIDE_INT bit;\n@@ -4910,54 +4867,54 @@ real_powi (REAL_VALUE_TYPE *r, machine_mode mode,\n   if (neg)\n     inexact |= do_divide (&t, &dconst1, &t);\n \n-  real_convert (r, mode, &t);\n+  real_convert (r, fmt, &t);\n   return inexact;\n }\n \n /* Round X to the nearest integer not larger in absolute value, i.e.\n-   towards zero, placing the result in R in mode MODE.  */\n+   towards zero, placing the result in R in format FMT.  */\n \n void\n-real_trunc (REAL_VALUE_TYPE *r, machine_mode mode,\n+real_trunc (REAL_VALUE_TYPE *r, format_helper fmt,\n \t    const REAL_VALUE_TYPE *x)\n {\n   do_fix_trunc (r, x);\n-  if (mode != VOIDmode)\n-    real_convert (r, mode, r);\n+  if (fmt)\n+    real_convert (r, fmt, r);\n }\n \n /* Round X to the largest integer not greater in value, i.e. round\n-   down, placing the result in R in mode MODE.  */\n+   down, placing the result in R in format FMT.  */\n \n void\n-real_floor (REAL_VALUE_TYPE *r, machine_mode mode,\n+real_floor (REAL_VALUE_TYPE *r, format_helper fmt,\n \t    const REAL_VALUE_TYPE *x)\n {\n   REAL_VALUE_TYPE t;\n \n   do_fix_trunc (&t, x);\n   if (! real_identical (&t, x) && x->sign)\n     do_add (&t, &t, &dconstm1, 0);\n-  if (mode != VOIDmode)\n-    real_convert (r, mode, &t);\n+  if (fmt)\n+    real_convert (r, fmt, &t);\n   else\n     *r = t;\n }\n \n /* Round X to the smallest integer not less then argument, i.e. round\n-   up, placing the result in R in mode MODE.  */\n+   up, placing the result in R in format FMT.  */\n \n void\n-real_ceil (REAL_VALUE_TYPE *r, machine_mode mode,\n+real_ceil (REAL_VALUE_TYPE *r, format_helper fmt,\n \t   const REAL_VALUE_TYPE *x)\n {\n   REAL_VALUE_TYPE t;\n \n   do_fix_trunc (&t, x);\n   if (! real_identical (&t, x) && ! x->sign)\n     do_add (&t, &t, &dconst1, 0);\n-  if (mode != VOIDmode)\n-    real_convert (r, mode, &t);\n+  if (fmt)\n+    real_convert (r, fmt, &t);\n   else\n     *r = t;\n }\n@@ -4966,13 +4923,13 @@ real_ceil (REAL_VALUE_TYPE *r, machine_mode mode,\n    zero.  */\n \n void\n-real_round (REAL_VALUE_TYPE *r, machine_mode mode,\n+real_round (REAL_VALUE_TYPE *r, format_helper fmt,\n \t    const REAL_VALUE_TYPE *x)\n {\n   do_add (r, x, &dconsthalf, x->sign);\n   do_fix_trunc (r, r);\n-  if (mode != VOIDmode)\n-    real_convert (r, mode, r);\n+  if (fmt)\n+    real_convert (r, fmt, r);\n }\n \n /* Set the sign of R to the sign of X.  */\n@@ -4986,11 +4943,11 @@ real_copysign (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *x)\n /* Check whether the real constant value given is an integer.  */\n \n bool\n-real_isinteger (const REAL_VALUE_TYPE *c, machine_mode mode)\n+real_isinteger (const REAL_VALUE_TYPE *c, format_helper fmt)\n {\n   REAL_VALUE_TYPE cint;\n \n-  real_trunc (&cint, mode, c);\n+  real_trunc (&cint, fmt, c);\n   return real_identical (c, &cint);\n }\n "}, {"sha": "df5ccc95ee5c8eedd58e81d53f637e8b209cff09", "filename": "gcc/real.h", "status": "modified", "additions": 43, "deletions": 26, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f16e6077eaecf7ace56ff9f0147c9854f93d77e1/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f16e6077eaecf7ace56ff9f0147c9854f93d77e1/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=f16e6077eaecf7ace56ff9f0147c9854f93d77e1", "patch": "@@ -193,6 +193,28 @@ extern const struct real_format *\n   (FLOAT_MODE_P (MODE) \\\n    && FLOAT_MODE_FORMAT (MODE)->has_sign_dependent_rounding)\n \n+/* This class allows functions in this file to accept a floating-point\n+   format as either a mode or an explicit real_format pointer.  In the\n+   former case the mode must be VOIDmode (which means \"no particular\n+   format\") or must satisfy SCALAR_FLOAT_MODE_P.  */\n+class format_helper\n+{\n+public:\n+  format_helper (const real_format *format) : m_format (format) {}\n+  format_helper (machine_mode m);\n+  const real_format *operator-> () const { return m_format; }\n+  operator const real_format *() const { return m_format; }\n+\n+  bool decimal_p () const { return m_format && m_format->b == 10; }\n+\n+private:\n+  const real_format *m_format;\n+};\n+\n+inline format_helper::format_helper (machine_mode m)\n+  : m_format (m == VOIDmode ? 0 : REAL_MODE_FORMAT (m))\n+{}\n+\n /* Declare functions in real.c.  */\n \n /* True if the given mode has a NaN representation and the treatment of\n@@ -254,12 +276,12 @@ extern bool real_identical (const REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *);\n extern bool real_equal (const REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *);\n extern bool real_less (const REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *);\n \n-/* Extend or truncate to a new mode.  */\n-extern void real_convert (REAL_VALUE_TYPE *, machine_mode,\n+/* Extend or truncate to a new format.  */\n+extern void real_convert (REAL_VALUE_TYPE *, format_helper,\n \t\t\t  const REAL_VALUE_TYPE *);\n \n /* Return true if truncating to NEW is exact.  */\n-extern bool exact_real_truncate (machine_mode, const REAL_VALUE_TYPE *);\n+extern bool exact_real_truncate (format_helper, const REAL_VALUE_TYPE *);\n \n /* Render R as a decimal floating point constant.  */\n extern void real_to_decimal (char *, const REAL_VALUE_TYPE *, size_t,\n@@ -281,24 +303,20 @@ extern HOST_WIDE_INT real_to_integer (const REAL_VALUE_TYPE *);\n    the value underflows, +1 if overflows, and 0 otherwise.  */\n extern int real_from_string (REAL_VALUE_TYPE *, const char *);\n /* Wrapper to allow different internal representation for decimal floats. */\n-extern void real_from_string3 (REAL_VALUE_TYPE *, const char *, machine_mode);\n+extern void real_from_string3 (REAL_VALUE_TYPE *, const char *, format_helper);\n \n-extern long real_to_target_fmt (long *, const REAL_VALUE_TYPE *,\n-\t\t\t\tconst struct real_format *);\n-extern long real_to_target (long *, const REAL_VALUE_TYPE *, machine_mode);\n+extern long real_to_target (long *, const REAL_VALUE_TYPE *, format_helper);\n \n-extern void real_from_target_fmt (REAL_VALUE_TYPE *, const long *,\n-\t\t\t\t  const struct real_format *);\n extern void real_from_target (REAL_VALUE_TYPE *, const long *,\n-\t\t\t      machine_mode);\n+\t\t\t      format_helper);\n \n extern void real_inf (REAL_VALUE_TYPE *);\n \n-extern bool real_nan (REAL_VALUE_TYPE *, const char *, int, machine_mode);\n+extern bool real_nan (REAL_VALUE_TYPE *, const char *, int, format_helper);\n \n extern void real_maxval (REAL_VALUE_TYPE *, int, machine_mode);\n \n-extern void real_2expN (REAL_VALUE_TYPE *, int, machine_mode);\n+extern void real_2expN (REAL_VALUE_TYPE *, int, format_helper);\n \n extern unsigned int real_hash (const REAL_VALUE_TYPE *);\n \n@@ -370,15 +388,14 @@ extern const struct real_format arm_half_format;\n #define REAL_VALUE_TO_TARGET_DECIMAL32(IN, OUT) \\\n   ((OUT) = real_to_target (NULL, &(IN), mode_for_size (32, MODE_DECIMAL_FLOAT, 0)))\n \n-extern REAL_VALUE_TYPE real_value_truncate (machine_mode,\n-\t\t\t\t\t    REAL_VALUE_TYPE);\n+extern REAL_VALUE_TYPE real_value_truncate (format_helper, REAL_VALUE_TYPE);\n \n extern REAL_VALUE_TYPE real_value_negate (const REAL_VALUE_TYPE *);\n extern REAL_VALUE_TYPE real_value_abs (const REAL_VALUE_TYPE *);\n \n-extern int significand_size (machine_mode);\n+extern int significand_size (format_helper);\n \n-extern REAL_VALUE_TYPE real_from_string2 (const char *, machine_mode);\n+extern REAL_VALUE_TYPE real_from_string2 (const char *, format_helper);\n \n #define REAL_VALUE_ATOF(s, m) \\\n   real_from_string2 (s, m)\n@@ -437,8 +454,8 @@ REAL_VALUE_TYPE real_value_from_int_cst (const_tree, const_tree);\n /* Return a CONST_DOUBLE with value R and mode M.  */\n extern rtx const_double_from_real_value (REAL_VALUE_TYPE, machine_mode);\n \n-/* Replace R by 1/R in the given machine mode, if the result is exact.  */\n-extern bool exact_real_inverse (machine_mode, REAL_VALUE_TYPE *);\n+/* Replace R by 1/R in the given format, if the result is exact.  */\n+extern bool exact_real_inverse (format_helper, REAL_VALUE_TYPE *);\n \n /* Return true if arithmetic on values in IMODE that were promoted\n    from values in TMODE is equivalent to direct arithmetic on values\n@@ -451,25 +468,25 @@ extern tree build_real (tree, REAL_VALUE_TYPE);\n /* Likewise, but first truncate the value to the type.  */\n extern tree build_real_truncate (tree, REAL_VALUE_TYPE);\n \n-/* Calculate R as X raised to the integer exponent N in mode MODE.  */\n-extern bool real_powi (REAL_VALUE_TYPE *, machine_mode,\n+/* Calculate R as X raised to the integer exponent N in format FMT.  */\n+extern bool real_powi (REAL_VALUE_TYPE *, format_helper,\n \t\t       const REAL_VALUE_TYPE *, HOST_WIDE_INT);\n \n /* Standard round to integer value functions.  */\n-extern void real_trunc (REAL_VALUE_TYPE *, machine_mode,\n+extern void real_trunc (REAL_VALUE_TYPE *, format_helper,\n \t\t\tconst REAL_VALUE_TYPE *);\n-extern void real_floor (REAL_VALUE_TYPE *, machine_mode,\n+extern void real_floor (REAL_VALUE_TYPE *, format_helper,\n \t\t\tconst REAL_VALUE_TYPE *);\n-extern void real_ceil (REAL_VALUE_TYPE *, machine_mode,\n+extern void real_ceil (REAL_VALUE_TYPE *, format_helper,\n \t\t       const REAL_VALUE_TYPE *);\n-extern void real_round (REAL_VALUE_TYPE *, machine_mode,\n+extern void real_round (REAL_VALUE_TYPE *, format_helper,\n \t\t\tconst REAL_VALUE_TYPE *);\n \n /* Set the sign of R to the sign of X.  */\n extern void real_copysign (REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *);\n \n /* Check whether the real constant value given is an integer.  */\n-extern bool real_isinteger (const REAL_VALUE_TYPE *, machine_mode);\n+extern bool real_isinteger (const REAL_VALUE_TYPE *, format_helper);\n extern bool real_isinteger (const REAL_VALUE_TYPE *, HOST_WIDE_INT *);\n \n /* Write into BUF the maximum representable finite floating-point\n@@ -480,7 +497,7 @@ extern void get_max_float (const struct real_format *, char *, size_t);\n #ifndef GENERATOR_FILE\n /* real related routines.  */\n extern wide_int real_to_integer (const REAL_VALUE_TYPE *, bool *, int);\n-extern void real_from_integer (REAL_VALUE_TYPE *, machine_mode,\n+extern void real_from_integer (REAL_VALUE_TYPE *, format_helper,\n \t\t\t       const wide_int_ref &, signop);\n #endif\n "}]}