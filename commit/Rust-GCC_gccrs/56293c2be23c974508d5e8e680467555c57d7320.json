{"sha": "56293c2be23c974508d5e8e680467555c57d7320", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTYyOTNjMmJlMjNjOTc0NTA4ZDVlOGU2ODA0Njc1NTVjNTdkNzMyMA==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2000-04-19T02:29:16Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2000-04-19T02:29:16Z"}, "message": "This commit was generated by cvs2svn to compensate for changes in r33244,\n\nwhich included commits to RCS files with non-trunk default branches.\n\nFrom-SVN: r33245", "tree": {"sha": "b994ff1648f56f954388f0f6acfe4414031cbe1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b994ff1648f56f954388f0f6acfe4414031cbe1b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56293c2be23c974508d5e8e680467555c57d7320", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56293c2be23c974508d5e8e680467555c57d7320", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56293c2be23c974508d5e8e680467555c57d7320", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56293c2be23c974508d5e8e680467555c57d7320/comments", "author": null, "committer": null, "parents": [{"sha": "0eebf9e5c729a27fec1c7ee40eefd226eb2df6e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0eebf9e5c729a27fec1c7ee40eefd226eb2df6e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0eebf9e5c729a27fec1c7ee40eefd226eb2df6e3"}], "stats": {"total": 619, "additions": 484, "deletions": 135}, "files": [{"sha": "f5b7c5aa2b948d732f7dfd06d214ef8e2f966980", "filename": "boehm-gc/backptr.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56293c2be23c974508d5e8e680467555c57d7320/boehm-gc%2Fbackptr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56293c2be23c974508d5e8e680467555c57d7320/boehm-gc%2Fbackptr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fbackptr.h?ref=56293c2be23c974508d5e8e680467555c57d7320", "patch": "@@ -29,9 +29,11 @@\n /*   source is heap object ==> *base_p != 0, *offset_p = offset       */\n /*   Returns 1 on success, 0 if source couldn't be determined.        */\n /* Dest can be any address within a heap object.                      */\n-typedef enum {  GC_UNREFERENCED, /* No refence info available.\t\t*/\n+typedef enum {  GC_UNREFERENCED, /* No reference info available.\t*/\n \t\tGC_NO_SPACE,\t/* Dest not allocated with debug alloc  */\n \t\tGC_REFD_FROM_ROOT, /* Referenced directly by root *base_p */\n+\t\tGC_REFD_FROM_REG,  /* Referenced from a register, i.e.\t*/\n+\t\t\t\t   /* a root without an address.\t*/\n \t\tGC_REFD_FROM_HEAP, /* Referenced from another heap obj. */\n \t\tGC_FINALIZER_REFD /* Finalizable and hence accessible.  */\n } GC_ref_kind;\n@@ -53,4 +55,9 @@ void * GC_generate_random_valid_address(void);\n /* source in dbg_mlc.c also serves as a sample client.\t      */\n void GC_generate_random_backtrace(void);\n \n+/* Print a backtrace from a specific address.  Used by the \t*/\n+/* above.  The client should call GC_gcollect() immediately\t*/\n+/* before invocation.\t\t\t\t\t\t*/\n+void GC_print_backtrace(void *);\n+\n "}, {"sha": "8d57f0467fb457c2253e2f7b3a2b1e6a9ab11a6a", "filename": "boehm-gc/cord/cordprnt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56293c2be23c974508d5e8e680467555c57d7320/boehm-gc%2Fcord%2Fcordprnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56293c2be23c974508d5e8e680467555c57d7320/boehm-gc%2Fcord%2Fcordprnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fcordprnt.c?ref=56293c2be23c974508d5e8e680467555c57d7320", "patch": "@@ -233,7 +233,7 @@ int CORD_vsprintf(CORD * out, CORD format, va_list args)\n \t\t\tif (width == NONE && prec == NONE) {\n \t\t\t    register char c;\n \n-\t\t\t    c = va_arg(args, char);\n+\t\t\t    c = va_arg(args, int);\n \t\t\t    CORD_ec_append(result, c);\n \t\t\t    goto done;\n \t\t\t}"}, {"sha": "3ac0d4403dfc9f872d5a6b12b23660fac8ebf25e", "filename": "boehm-gc/cord/gc.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56293c2be23c974508d5e8e680467555c57d7320/boehm-gc%2Fcord%2Fgc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56293c2be23c974508d5e8e680467555c57d7320/boehm-gc%2Fcord%2Fgc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fgc.h?ref=56293c2be23c974508d5e8e680467555c57d7320", "patch": "@@ -1,7 +1,8 @@\n /* \n  * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n  * Copyright (c) 1991-1995 by Xerox Corporation.  All rights reserved.\n- * Copyright 1996 by Silicon Graphics.  All rights reserved.\n+ * Copyright 1996-1999 by Silicon Graphics.  All rights reserved.\n+ * Copyright 1999 by Hewlett-Packard Company.  All rights reserved.\n  *\n  * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n  * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n@@ -352,11 +353,11 @@ GC_API GC_PTR GC_malloc_atomic_ignore_off_page GC_PROTO((size_t lb));\n \n #ifdef GC_ADD_CALLER\n #  define GC_EXTRAS GC_RETURN_ADDR, __FILE__, __LINE__\n-#  define GC_EXTRA_PARAMS GC_word ra, GC_CONST char * descr_string,\n-\t\t          int descr_int\n+#  define GC_EXTRA_PARAMS GC_word ra, GC_CONST char * s,\n+\t\t          int i\n #else\n #  define GC_EXTRAS __FILE__, __LINE__\n-#  define GC_EXTRA_PARAMS GC_CONST char * descr_string, int descr_int\n+#  define GC_EXTRA_PARAMS GC_CONST char * s, int i\n #endif\n \n /* Debugging (annotated) allocation.  GC_gcollect will check \t\t*/"}, {"sha": "f6e74365216d3e81725f0cbfecd642ec6b06fd12", "filename": "boehm-gc/hpux_irix_threads.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56293c2be23c974508d5e8e680467555c57d7320/boehm-gc%2Fhpux_irix_threads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56293c2be23c974508d5e8e680467555c57d7320/boehm-gc%2Fhpux_irix_threads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fhpux_irix_threads.c?ref=56293c2be23c974508d5e8e680467555c57d7320", "patch": "@@ -387,7 +387,8 @@ int GC_is_thread_stack(ptr_t addr)\n }\n # endif\n \n-/* We hold allocation lock.  We assume the world is stopped.\t*/\n+/* We hold allocation lock.  Should do exactly the right thing if the\t*/\n+/* world is stopped.  Should not fail if it isn't.\t\t\t*/\n void GC_push_all_stacks()\n {\n     register int i;"}, {"sha": "f5b7c5aa2b948d732f7dfd06d214ef8e2f966980", "filename": "boehm-gc/include/backptr.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56293c2be23c974508d5e8e680467555c57d7320/boehm-gc%2Finclude%2Fbackptr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56293c2be23c974508d5e8e680467555c57d7320/boehm-gc%2Finclude%2Fbackptr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fbackptr.h?ref=56293c2be23c974508d5e8e680467555c57d7320", "patch": "@@ -29,9 +29,11 @@\n /*   source is heap object ==> *base_p != 0, *offset_p = offset       */\n /*   Returns 1 on success, 0 if source couldn't be determined.        */\n /* Dest can be any address within a heap object.                      */\n-typedef enum {  GC_UNREFERENCED, /* No refence info available.\t\t*/\n+typedef enum {  GC_UNREFERENCED, /* No reference info available.\t*/\n \t\tGC_NO_SPACE,\t/* Dest not allocated with debug alloc  */\n \t\tGC_REFD_FROM_ROOT, /* Referenced directly by root *base_p */\n+\t\tGC_REFD_FROM_REG,  /* Referenced from a register, i.e.\t*/\n+\t\t\t\t   /* a root without an address.\t*/\n \t\tGC_REFD_FROM_HEAP, /* Referenced from another heap obj. */\n \t\tGC_FINALIZER_REFD /* Finalizable and hence accessible.  */\n } GC_ref_kind;\n@@ -53,4 +55,9 @@ void * GC_generate_random_valid_address(void);\n /* source in dbg_mlc.c also serves as a sample client.\t      */\n void GC_generate_random_backtrace(void);\n \n+/* Print a backtrace from a specific address.  Used by the \t*/\n+/* above.  The client should call GC_gcollect() immediately\t*/\n+/* before invocation.\t\t\t\t\t\t*/\n+void GC_print_backtrace(void *);\n+\n "}, {"sha": "926089e86fbb18567aa48981aa68dc152f1e7b76", "filename": "boehm-gc/include/cord.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56293c2be23c974508d5e8e680467555c57d7320/boehm-gc%2Finclude%2Fcord.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56293c2be23c974508d5e8e680467555c57d7320/boehm-gc%2Finclude%2Fcord.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fcord.h?ref=56293c2be23c974508d5e8e680467555c57d7320", "patch": "@@ -41,7 +41,7 @@\n  * This interface is fairly big, largely for performance reasons.\n  * The most basic constants and functions:\n  *\n- * CORD - the type fo a cord;\n+ * CORD - the type of a cord;\n  * CORD_EMPTY - empty cord;\n  * CORD_len(cord) - length of a cord;\n  * CORD_cat(cord1,cord2) - concatenation of two cords;"}, {"sha": "e35f54f7d3f5e3d1d85c65e31c5aa7bca29672f5", "filename": "boehm-gc/include/gc.h", "status": "modified", "additions": 45, "deletions": 6, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56293c2be23c974508d5e8e680467555c57d7320/boehm-gc%2Finclude%2Fgc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56293c2be23c974508d5e8e680467555c57d7320/boehm-gc%2Finclude%2Fgc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc.h?ref=56293c2be23c974508d5e8e680467555c57d7320", "patch": "@@ -1,7 +1,8 @@\n /* \n  * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n  * Copyright (c) 1991-1995 by Xerox Corporation.  All rights reserved.\n- * Copyright 1996 by Silicon Graphics.  All rights reserved.\n+ * Copyright 1996-1999 by Silicon Graphics.  All rights reserved.\n+ * Copyright 1999 by Hewlett-Packard Company.  All rights reserved.\n  *\n  * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n  * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n@@ -35,6 +36,14 @@\n #include \"libgc_globals.h\"\n #endif\n \n+#if defined(__MINGW32__) && defined(WIN32_THREADS)\n+# ifdef GC_BUILD\n+#   define GC_API __declspec(dllexport)\n+# else\n+#   define GC_API __declspec(dllimport)\n+# endif\n+#endif\n+\n #if defined(_MSC_VER) && defined(_DLL)\n # ifdef GC_BUILD\n #   define GC_API __declspec(dllexport)\n@@ -130,6 +139,17 @@ GC_API int GC_dont_expand;\n \t\t\t/* Dont expand heap unless explicitly requested */\n \t\t\t/* or forced to.\t\t\t\t*/\n \n+GC_API int GC_use_entire_heap;\n+\t\t/* Causes the nonincremental collector to use the\t*/\n+\t\t/* entire heap before collecting.  This was the only \t*/\n+\t\t/* option for GC versions < 5.0.  This sometimes\t*/\n+\t\t/* results in more large block fragmentation, since\t*/\n+\t\t/* very larg blocks will tend to get broken up\t\t*/\n+\t\t/* during each GC cycle.  It is likely to result in a\t*/\n+\t\t/* larger working set, but lower collection\t\t*/\n+\t\t/* frequencies, and hence fewer instructions executed\t*/\n+\t\t/* in the collector.\t\t\t\t\t*/\n+\n GC_API int GC_full_freq;    /* Number of partial collections between\t*/\n \t\t\t    /* full collections.  Matters only if\t*/\n \t\t\t    /* GC_incremental is set.\t\t\t*/\n@@ -352,11 +372,11 @@ GC_API GC_PTR GC_malloc_atomic_ignore_off_page GC_PROTO((size_t lb));\n \n #ifdef GC_ADD_CALLER\n #  define GC_EXTRAS GC_RETURN_ADDR, __FILE__, __LINE__\n-#  define GC_EXTRA_PARAMS GC_word ra, GC_CONST char * descr_string,\n-\t\t          int descr_int\n+#  define GC_EXTRA_PARAMS GC_word ra, GC_CONST char * s,\n+\t\t          int i\n #else\n #  define GC_EXTRAS __FILE__, __LINE__\n-#  define GC_EXTRA_PARAMS GC_CONST char * descr_string, int descr_int\n+#  define GC_EXTRA_PARAMS GC_CONST char * s, int i\n #endif\n \n /* Debugging (annotated) allocation.  GC_gcollect will check \t\t*/\n@@ -387,6 +407,8 @@ GC_API void GC_debug_end_stubborn_change GC_PROTO((GC_PTR));\n \tGC_debug_register_finalizer(p, f, d, of, od)\n #   define GC_REGISTER_FINALIZER_IGNORE_SELF(p, f, d, of, od) \\\n \tGC_debug_register_finalizer_ignore_self(p, f, d, of, od)\n+#   define GC_REGISTER_FINALIZER_NO_ORDER(p, f, d, of, od) \\\n+\tGC_debug_register_finalizer_no_order(p, f, d, of, od)\n #   define GC_MALLOC_STUBBORN(sz) GC_debug_malloc_stubborn(sz, GC_EXTRAS);\n #   define GC_CHANGE_STUBBORN(p) GC_debug_change_stubborn(p)\n #   define GC_END_STUBBORN_CHANGE(p) GC_debug_end_stubborn_change(p)\n@@ -403,6 +425,8 @@ GC_API void GC_debug_end_stubborn_change GC_PROTO((GC_PTR));\n \tGC_register_finalizer(p, f, d, of, od)\n #   define GC_REGISTER_FINALIZER_IGNORE_SELF(p, f, d, of, od) \\\n \tGC_register_finalizer_ignore_self(p, f, d, of, od)\n+#   define GC_REGISTER_FINALIZER_NO_ORDER(p, f, d, of, od) \\\n+\tGC_register_finalizer_no_order(p, f, d, of, od)\n #   define GC_MALLOC_STUBBORN(sz) GC_malloc_stubborn(sz)\n #   define GC_CHANGE_STUBBORN(p) GC_change_stubborn(p)\n #   define GC_END_STUBBORN_CHANGE(p) GC_end_stubborn_change(p)\n@@ -481,6 +505,16 @@ GC_API void GC_debug_register_finalizer_ignore_self\n \tGC_PROTO((GC_PTR obj, GC_finalization_proc fn, GC_PTR cd,\n \t\t  GC_finalization_proc *ofn, GC_PTR *ocd));\n \n+/* Another version of the above.  It ignores all cycles.        */\n+/* It should probably only be used by Java implementations.      */\n+GC_API void GC_register_finalizer_no_order\n+\tGC_PROTO((GC_PTR obj, GC_finalization_proc fn, GC_PTR cd,\n+\t\t  GC_finalization_proc *ofn, GC_PTR *ocd));\n+GC_API void GC_debug_register_finalizer_no_order\n+\tGC_PROTO((GC_PTR obj, GC_finalization_proc fn, GC_PTR cd,\n+\t\t  GC_finalization_proc *ofn, GC_PTR *ocd));\n+\n+\n /* The following routine may be used to break cycles between\t*/\n /* finalizable objects, thus causing cyclic finalizable\t\t*/\n /* objects to be finalized in the correct order.  Standard\t*/\n@@ -537,6 +571,9 @@ GC_API int GC_unregister_disappearing_link GC_PROTO((GC_PTR * /* link */));\n GC_API GC_PTR GC_make_closure GC_PROTO((GC_finalization_proc fn, GC_PTR data));\n GC_API void GC_debug_invoke_finalizer GC_PROTO((GC_PTR obj, GC_PTR data));\n \n+/* Returns !=0  if GC_invoke_finalizers has something to do. \t\t*/\n+GC_API int GC_should_invoke_finalizers GC_PROTO((void));\n+\n GC_API int GC_invoke_finalizers GC_PROTO((void));\n \t/* Run finalizers for all objects that are ready to\t*/\n \t/* be finalized.  Return the number of finalizers\t*/\n@@ -700,7 +737,8 @@ GC_API void (*GC_is_visible_print_proc)\n # endif /* SOLARIS_THREADS */\n \n \n-#if defined(IRIX_THREADS) || defined(LINUX_THREADS) || defined(HPUX_THREADS)\n+#if !defined(USE_LD_WRAP) && \\\n+    (defined(IRIX_THREADS) || defined(LINUX_THREADS) || defined(HPUX_THREADS))\n /* We treat these similarly. */\n # include <pthread.h>\n # include <signal.h>\n@@ -714,8 +752,9 @@ GC_API void (*GC_is_visible_print_proc)\n # define pthread_create GC_pthread_create\n # define pthread_sigmask GC_pthread_sigmask\n # define pthread_join GC_pthread_join\n+# define dlopen GC_dlopen\n \n-#endif /* IRIX_THREADS || LINUX_THREADS */\n+#endif /* xxxxx_THREADS */\n \n # if defined(PCR) || defined(SOLARIS_THREADS) || defined(WIN32_THREADS) || \\\n \tdefined(IRIX_THREADS) || defined(LINUX_THREADS) || \\"}, {"sha": "36013e135b9abe0599db5bbcd6802ace67730a0b", "filename": "boehm-gc/include/gc_cpp.h", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56293c2be23c974508d5e8e680467555c57d7320/boehm-gc%2Finclude%2Fgc_cpp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56293c2be23c974508d5e8e680467555c57d7320/boehm-gc%2Finclude%2Fgc_cpp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_cpp.h?ref=56293c2be23c974508d5e8e680467555c57d7320", "patch": "@@ -16,12 +16,11 @@ the code was modified is included with the above copyright notice.\n C++ Interface to the Boehm Collector\n \n     John R. Ellis and Jesse Hull \n-    Last modified on Mon Jul 24 15:43:42 PDT 1995 by ellis\n \n This interface provides access to the Boehm collector.  It provides\n basic facilities similar to those described in \"Safe, Efficient\n Garbage Collection for C++\", by John R. Elis and David L. Detlefs\n-(ftp.parc.xerox.com:/pub/ellis/gc).\n+(ftp://ftp.parc.xerox.com/pub/ellis/gc).\n \n All heap-allocated objects are either \"collectable\" or\n \"uncollectable\".  Programs must explicitly delete uncollectable\n@@ -38,7 +37,7 @@ Objects derived from class \"gc\" are collectable.  For example:\n     A* a = new A;       // a is collectable. \n \n Collectable instances of non-class types can be allocated using the GC\n-placement:\n+(or UseGC) placement:\n \n     typedef int A[ 10 ];\n     A* a = new (GC) A;\n@@ -124,6 +123,12 @@ invoked using the ANSI-conforming syntax t->~T().  If you're using\n cfront 3.0, you'll have to comment out the class gc_cleanup, which\n uses explicit invocation.\n \n+5. GC name conflicts:\n+\n+Many other systems seem to use the identifier \"GC\" as an abbreviation\n+for \"Graphics Context\".  Since version 5.0, GC placement has been replaced\n+by UseGC.  GC is an alias for UseGC, unless GC_NAME_CONFLICT is defined.\n+\n ****************************************************************************/\n \n #include \"gc.h\"\n@@ -138,7 +143,11 @@ uses explicit invocation.\n #   define OPERATOR_NEW_ARRAY\n #endif\n \n-enum GCPlacement {GC, NoGC, PointerFreeGC};\n+enum GCPlacement {UseGC,\n+#ifndef GC_NAME_CONFLICT\n+\t\t  GC=UseGC,\n+#endif\n+                  NoGC, PointerFreeGC};\n \n class gc {public:\n     inline void* operator new( size_t size );\n@@ -211,7 +220,7 @@ inline void* gc::operator new( size_t size ) {\n     return GC_MALLOC( size );}\n     \n inline void* gc::operator new( size_t size, GCPlacement gcp ) {\n-    if (gcp == GC) \n+    if (gcp == UseGC) \n         return GC_MALLOC( size );\n     else if (gcp == PointerFreeGC)\n \treturn GC_MALLOC_ATOMIC( size );\n@@ -261,7 +270,7 @@ inline void* operator new(\n {\n     void* obj;\n \n-    if (gcp == GC) {\n+    if (gcp == UseGC) {\n         obj = GC_MALLOC( size );\n         if (cleanup != 0) \n             GC_REGISTER_FINALIZER_IGNORE_SELF( "}, {"sha": "2e0598f204c71fa11ede4f2322d8de31dbd5b841", "filename": "boehm-gc/include/gc_typed.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56293c2be23c974508d5e8e680467555c57d7320/boehm-gc%2Finclude%2Fgc_typed.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56293c2be23c974508d5e8e680467555c57d7320/boehm-gc%2Finclude%2Fgc_typed.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_typed.h?ref=56293c2be23c974508d5e8e680467555c57d7320", "patch": "@@ -61,6 +61,7 @@ GC_API GC_PTR GC_malloc_explicitly_typed\n \t\t\tGC_PROTO((size_t size_in_bytes, GC_descr d));\n \t\t/* Allocate an object whose layout is described by d.\t*/\n \t\t/* The resulting object MAY NOT BE PASSED TO REALLOC.\t*/\n+\t\t/* The returned object is cleared.\t\t\t*/\n \n GC_API GC_PTR GC_malloc_explicitly_typed_ignore_off_page\n                         GC_PROTO((size_t size_in_bytes, GC_descr d));\n@@ -75,6 +76,7 @@ GC_API GC_PTR GC_calloc_explicitly_typed\n   \t/* alignment required for pointers.  E.g. on a 32-bit\t*/\n   \t/* machine with 16-bit aligned pointers, size_in_bytes\t*/\n   \t/* must be a multiple of 2.\t\t\t\t*/\n+\t/* Returned object is cleared.\t\t\t\t*/\n \n #ifdef GC_DEBUG\n #   define GC_MALLOC_EXPLICTLY_TYPED(bytes, d) GC_MALLOC(bytes)"}, {"sha": "eabb85f0c206df2ac5ed9ccc19bb6f1f58c7c37e", "filename": "boehm-gc/include/private/gc_priv.h", "status": "modified", "additions": 123, "deletions": 59, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56293c2be23c974508d5e8e680467555c57d7320/boehm-gc%2Finclude%2Fprivate%2Fgc_priv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56293c2be23c974508d5e8e680467555c57d7320/boehm-gc%2Finclude%2Fprivate%2Fgc_priv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgc_priv.h?ref=56293c2be23c974508d5e8e680467555c57d7320", "patch": "@@ -44,7 +44,7 @@\n typedef GC_word word;\n typedef GC_signed_word signed_word;\n \n-# ifndef CONFIG_H\n+# ifndef GCCONFIG_H\n #   include \"gcconfig.h\"\n # endif\n \n@@ -82,6 +82,7 @@ typedef char * ptr_t;\t/* A generic pointer to which we can add\t*/\n #   define GC_FAR\n #endif\n \n+\n /*********************************/\n /*                               */\n /* Definitions for conservative  */\n@@ -173,15 +174,6 @@ typedef char * ptr_t;\t/* A generic pointer to which we can add\t*/\n \t\t    /* May save significant amounts of space for obj_map  */\n \t\t    /* entries.\t\t\t\t\t\t  */\n \n-#ifndef OLD_BLOCK_ALLOC\n-   /* Macros controlling large block allocation strategy.\t*/\n-#  define EXACT_FIRST  \t/* Make a complete pass through the large object */\n-\t\t\t/* free list before splitting a block\t\t */\n-#  define PRESERVE_LAST /* Do not divide last allocated heap segment\t */\n-\t\t\t/* unless we would otherwise need to expand the\t */\n-\t\t\t/* heap.\t\t\t\t\t */\n-#endif\n-\n /* ALIGN_DOUBLE requires MERGE_SIZES at present. */\n # if defined(ALIGN_DOUBLE) && !defined(MERGE_SIZES)\n #   define MERGE_SIZES\n@@ -281,6 +273,13 @@ void GC_print_callers (/* struct callinfo info[NFRAMES] */);\n #   define MS_TIME_DIFF(a,b) ((double) (a.tv_sec - b.tv_sec) * 1000.0 \\\n                                + (double) (a.tv_usec - b.tv_usec) / 1000.0)\n #else /* !BSD_TIME */\n+# ifdef MSWIN32\n+#   include <windows.h>\n+#   include <winbase.h>\n+#   define CLOCK_TYPE DWORD\n+#   define GET_TIME(x) x = GetTickCount()\n+#   define MS_TIME_DIFF(a,b) ((long)((a)-(b)))\n+# else /* !MSWIN32, !BSD_TIME */\n #   include <time.h>\n #   if !defined(__STDC__) && defined(SPARC) && defined(SUNOS4)\n       clock_t clock();\t/* Not in time.h, where it belongs\t*/\n@@ -306,6 +305,7 @@ void GC_print_callers (/* struct callinfo info[NFRAMES] */);\n #   define GET_TIME(x) x = clock()\n #   define MS_TIME_DIFF(a,b) ((unsigned long) \\\n \t\t(1000.0*(double)((a)-(b))/(double)CLOCKS_PER_SEC))\n+# endif /* !MSWIN32 */\n #endif /* !BSD_TIME */\n \n /* We use bzero and bcopy internally.  They may not be available.\t*/\n@@ -437,8 +437,11 @@ void GC_print_callers (/* struct callinfo info[NFRAMES] */);\n #    define LOCK() mutex_lock(&GC_allocate_ml);\n #    define UNLOCK() mutex_unlock(&GC_allocate_ml);\n #  endif\n-#  ifdef LINUX_THREADS\n+#  if defined(LINUX_THREADS) \n+#   if defined(I386)|| defined(POWERPC) || defined(ALPHA) || defined(IA64) \\\n+    || defined(M68K)\n #    include <pthread.h>\n+#    define USE_SPIN_LOCK\n #    if defined(I386)\n        inline static int GC_test_and_set(volatile unsigned int *addr) {\n \t  int oldval;\n@@ -448,9 +451,38 @@ void GC_print_callers (/* struct callinfo info[NFRAMES] */);\n \t\t: \"0\"(1), \"m\"(*(addr)));\n \t  return oldval;\n        }\n-#    else\n-#     if defined(POWERPC)\n+#    endif\n+#    if defined(IA64)\n        inline static int GC_test_and_set(volatile unsigned int *addr) {\n+\t  int oldval;\n+\t  __asm__ __volatile__(\"xchg4 %0=%1,%2\"\n+\t\t: \"=r\"(oldval), \"=m\"(*addr)\n+\t\t: \"r\"(1), \"1\"(*addr));\n+\t  return oldval;\n+       }\n+       inline static void GC_clear(volatile unsigned int *addr) {\n+\t __asm__ __volatile__(\"st4.rel %0=r0\" : \"=m\" (*addr));\n+       }\n+#      define GC_CLEAR_DEFINED\n+#    endif\n+#    ifdef M68K\n+       /* Contributed by Tony Mantler.  I'm not sure how well it was\t*/\n+       /* tested.\t\t\t\t\t\t\t*/\n+       inline static int GC_test_and_set(volatile unsigned int *addr) {\n+          char oldval; /* this must be no longer than 8 bits */\n+\n+          /* The return value is semi-phony. */\n+          /* 'tas' sets bit 7 while the return */\n+          /* value pretends bit 0 was set */\n+          __asm__ __volatile__(\n+                 \"tas %1@; sne %0; negb %0\"\n+                 : \"=d\" (oldval)\n+                 : \"a\" (addr));\n+          return oldval;\n+       }\n+#    endif\n+#    if defined(POWERPC)\n+      inline static int GC_test_and_set(volatile unsigned int *addr) {\n         int oldval;\n         int temp = 1; // locked value\n \n@@ -465,46 +497,61 @@ void GC_print_callers (/* struct callinfo info[NFRAMES] */);\n               : \"r\"(temp), \"1\"(addr)\n               : \"memory\");\n         return (int)oldval;\n-       }\n-#     else\n-#      ifdef ALPHA\n-         inline static int GC_test_and_set(volatile unsigned int *\n-addr)\n-         {\n-           unsigned long oldvalue;\n-           unsigned long temp;\n-\n-           __asm__ __volatile__(\n-                                \"1:     ldl_l %0,%1\\n\"\n-                                \"       and %0,%3,%2\\n\"\n-                                \"       bne %2,2f\\n\"\n-                                \"       xor %0,%3,%0\\n\"\n-                                \"       stl_c %0,%1\\n\"\n-                                \"       beq %0,3f\\n\"\n-                                \"       mb\\n\"\n-                                \"2:\\n\"\n-                                \".section .text2,\\\"ax\\\"\\n\"\n-                                \"3:     br 1b\\n\"\n-                                \".previous\"\n-                                :\"=&r\" (temp), \"=m\" (*addr), \"=&r\"\n-(oldvalue)\n-                                :\"Ir\" (1), \"m\" (*addr));\n-\n-           return oldvalue;\n-         }\n-#      else\n-         -- > Need implementation of GC_test_and_set()\n-#      endif\n-#     endif\n+      }\n+      inline static void GC_clear(volatile unsigned int *addr) {\n+\t __asm__ __volatile__(\"eieio\");\n+         *(addr) = 0;\n+      }\n+#     define GC_CLEAR_DEFINED\n #    endif\n-     inline static void GC_clear(volatile unsigned int *addr) {\n+#    ifdef ALPHA\n+      inline static int GC_test_and_set(volatile unsigned int * addr)\n+      {\n+        unsigned long oldvalue;\n+        unsigned long temp;\n+\n+        __asm__ __volatile__(\n+                             \"1:     ldl_l %0,%1\\n\"\n+                             \"       and %0,%3,%2\\n\"\n+                             \"       bne %2,2f\\n\"\n+                             \"       xor %0,%3,%0\\n\"\n+                             \"       stl_c %0,%1\\n\"\n+                             \"       beq %0,3f\\n\"\n+                             \"       mb\\n\"\n+                             \"2:\\n\"\n+                             \".section .text2,\\\"ax\\\"\\n\"\n+                             \"3:     br 1b\\n\"\n+                             \".previous\"\n+                             :\"=&r\" (temp), \"=m\" (*addr), \"=&r\" (oldvalue)\n+                             :\"Ir\" (1), \"m\" (*addr));\n+\n+        return oldvalue;\n+      }\n+      /* Should probably also define GC_clear, since it needs\t*/\n+      /* a memory barrier ??\t\t\t\t\t*/\n+#    endif /* ALPHA */\n+#    ifdef ARM32\n+      inline static int GC_test_and_set(volatile unsigned int *addr) {\n+        int oldval;\n+        /* SWP on ARM is very similar to XCHG on x86.  Doesn't lock the\n+         * bus because there are no SMP ARM machines.  If/when there are,\n+         * this code will likely need to be updated. */\n+        /* See linuxthreads/sysdeps/arm/pt-machine.h in glibc-2.1 */\n+        __asm__ __volatile__(\"swp %0, %1, [%2]\"\n+      \t\t\t     : \"=r\"(oldval)\n+      \t\t\t     : \"r\"(1), \"r\"(addr));\n+        return oldval;\n+      }\n+#    endif\n+#    ifndef GC_CLEAR_DEFINED\n+       inline static void GC_clear(volatile unsigned int *addr) {\n+\t  /* Try to discourage gcc from moving anything past this. */\n+\t  __asm__ __volatile__(\" \");\n           *(addr) = 0;\n-     }\n+       }\n+#    endif\n \n      extern volatile unsigned int GC_allocate_lock;\n-\t/* This is not a mutex because mutexes that obey the (optional)     */\n-\t/* POSIX scheduling rules are subject to convoys in high contention */\n-\t/* applications.  This is basically a spin lock.\t\t    */\n      extern pthread_t GC_lock_holder;\n      extern void GC_lock(void);\n \t/* Allocation lock holder.  Only set if acquired by client through */\n@@ -517,12 +564,19 @@ addr)\n \t\t{ if (GC_test_and_set(&GC_allocate_lock)) GC_lock(); }\n #    define UNLOCK() \\\n \t\tGC_clear(&GC_allocate_lock)\n-     extern GC_bool GC_collecting;\n+     extern VOLATILE GC_bool GC_collecting;\n #    define ENTER_GC() \\\n \t\t{ \\\n \t\t    GC_collecting = 1; \\\n \t\t}\n #    define EXIT_GC() GC_collecting = 0;\n+#   else /* LINUX_THREADS on hardware for which we don't know how\t*/\n+\t /* to do test and set.\t\t\t\t\t\t*/\n+#    include <pthread.h>\n+     extern pthread_mutex_t GC_allocate_ml;\n+#    define LOCK() pthread_mutex_lock(&GC_allocate_ml)\n+#    define UNLOCK() pthread_mutex_unlock(&GC_allocate_ml)\n+#   endif\n #  endif /* LINUX_THREADS */\n #  if defined(HPUX_THREADS)\n #    include <pthread.h>\n@@ -581,7 +635,7 @@ addr)\n \t\t\t*(volatile unsigned long *)(&GC_allocate_lock) = 0; }\n #      endif\n #    endif\n-     extern GC_bool GC_collecting;\n+     extern VOLATILE GC_bool GC_collecting;\n #    define ENTER_GC() \\\n \t\t{ \\\n \t\t    GC_collecting = 1; \\\n@@ -957,8 +1011,10 @@ struct hblk {\n /* The type of mark procedures.  This really belongs in gc_mark.h.\t*/\n /* But we put it here, so that we can avoid scanning the mark proc\t*/\n /* table.\t\t\t\t\t\t\t\t*/\n-typedef struct ms_entry * (*mark_proc)(/* word * addr, mark_stack_ptr,\n-\t\t\t\t\t  mark_stack_limit, env */);\n+typedef struct ms_entry * (*mark_proc)(/* word * addr,\n+\t\t\t\t\t  struct ms_entry *mark_stack_ptr,\n+\t\t\t\t\t  struct ms_entry *mark_stack_limit,\n+\t\t\t\t\t  word env */);\n # define LOG_MAX_MARK_PROCS 6\n # define MAX_MARK_PROCS (1 << LOG_MAX_MARK_PROCS)\n \n@@ -1035,6 +1091,7 @@ struct roots {\n struct _GC_arrays {\n   word _heapsize;\n   word _max_heapsize;\n+  word _requested_heapsize;\t/* Heap size due to explicit expansion */\n   ptr_t _last_heap_addr;\n   ptr_t _prev_heap_addr;\n   word _large_free_bytes;\n@@ -1059,6 +1116,10 @@ struct _GC_arrays {\n   word _mem_freed;\n   \t/* Number of explicitly deallocated words of memory\t*/\n   \t/* since last collection.\t\t\t\t*/\n+  ptr_t _scratch_end_ptr;\n+  ptr_t _scratch_last_end_ptr;\n+\t/* Used by headers.c, and can easily appear to point to\t*/\n+\t/* heap.\t\t\t\t\t\t*/\n   mark_proc _mark_procs[MAX_MARK_PROCS];\n   \t/* Table of user-defined mark procedures.  There is\t*/\n \t/* a small number of these, which can be referenced\t*/\n@@ -1223,9 +1284,12 @@ GC_API GC_FAR struct _GC_arrays GC_arrays;\n # define GC_words_finalized GC_arrays._words_finalized\n # define GC_non_gc_bytes_at_gc GC_arrays._non_gc_bytes_at_gc\n # define GC_mem_freed GC_arrays._mem_freed\n+# define GC_scratch_end_ptr GC_arrays._scratch_end_ptr\n+# define GC_scratch_last_end_ptr GC_arrays._scratch_last_end_ptr\n # define GC_mark_procs GC_arrays._mark_procs\n # define GC_heapsize GC_arrays._heapsize\n # define GC_max_heapsize GC_arrays._max_heapsize\n+# define GC_requested_heapsize GC_arrays._requested_heapsize\n # define GC_words_allocd_before_gc GC_arrays._words_allocd_before_gc\n # define GC_heap_sects GC_arrays._heap_sects\n # define GC_last_stack GC_arrays._last_stack\n@@ -1260,6 +1324,8 @@ GC_API GC_FAR struct _GC_arrays GC_arrays;\n # define beginGC_arrays ((ptr_t)(&GC_arrays))\n # define endGC_arrays (((ptr_t)(&GC_arrays)) + (sizeof GC_arrays))\n \n+#define USED_HEAP_SIZE (GC_heapsize - GC_large_free_bytes)\n+\n /* Object kinds: */\n # define MAXOBJKINDS 16\n \n@@ -1392,10 +1458,7 @@ extern ptr_t GC_greatest_plausible_heap_addr;\n ptr_t GC_approx_sp();\n \n GC_bool GC_should_collect();\n-#ifdef PRESERVE_LAST\n-    GC_bool GC_in_last_heap_sect(/* ptr_t */);\n-\t/* In last added heap section?  If so, avoid breaking up.\t*/\n-#endif\n+\n void GC_apply_to_all_blocks(/*fn, client_data*/);\n \t\t\t/* Invoke fn(hbp, client_data) for each \t*/\n \t\t\t/* allocated heap block.\t\t\t*/\n@@ -1672,9 +1735,10 @@ ptr_t GC_allocobj(/* sz_inn_words, kind */);\n \t\t\t\t/* head.\t\t\t\t*/\n \n void GC_init_headers();\n-GC_bool GC_install_header(/*h*/);\n+struct hblkhdr * GC_install_header(/*h*/);\n \t\t\t\t/* Install a header for block h.\t*/\n-\t\t\t\t/* Return FALSE on failure.\t\t*/\n+\t\t\t\t/* Return 0 on failure, or the header\t*/\n+\t\t\t\t/* otherwise.\t\t\t\t*/\n GC_bool GC_install_counts(/*h, sz*/);\n \t\t\t\t/* Set up forwarding counts for block\t*/\n \t\t\t\t/* h of size sz.\t\t\t*/"}, {"sha": "4c4bca31222f30d07ccd670bae54fbd53a16c2bd", "filename": "boehm-gc/include/private/gcconfig.h", "status": "modified", "additions": 274, "deletions": 55, "changes": 329, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56293c2be23c974508d5e8e680467555c57d7320/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56293c2be23c974508d5e8e680467555c57d7320/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h?ref=56293c2be23c974508d5e8e680467555c57d7320", "patch": "@@ -13,9 +13,9 @@\n  * modified is included with the above copyright notice.\n  */\n  \n-#ifndef CONFIG_H\n+#ifndef GCCONFIG_H\n \n-# define CONFIG_H\n+# define GCCONFIG_H\n \n /* Machine dependent parameters.  Some tuning parameters can be found\t*/\n /* near the top of gc_private.h.\t\t\t\t\t*/\n@@ -53,6 +53,11 @@\n #    define NETBSD\n #    define mach_type_known\n # endif\n+# if defined(__NetBSD__) && defined(arm32)\n+#    define ARM32\n+#    define NETBSD\n+#    define mach_type_known\n+# endif\n # if defined(vax)\n #    define VAX\n #    ifdef ultrix\n@@ -64,15 +69,18 @@\n # endif\n # if defined(mips) || defined(__mips)\n #    define MIPS\n-#    if defined(ultrix) || defined(__ultrix) || defined(__NetBSD__)\n-#\tdefine ULTRIX\n-#    else\n-#\tif defined(_SYSTYPE_SVR4) || defined(SYSTYPE_SVR4) || defined(__SYSTYPE_SVR4__)\n-#\t  define IRIX5   /* or IRIX 6.X */\n-#\telse\n-#\t  define RISCOS  /* or IRIX 4.X */\n-#\tendif\n-#    endif\n+#    if !defined(LINUX)\n+#      if defined(ultrix) || defined(__ultrix) || defined(__NetBSD__)\n+#\t define ULTRIX\n+#      else\n+#\t if defined(_SYSTYPE_SVR4) || defined(SYSTYPE_SVR4) \\\n+\t    || defined(__SYSTYPE_SVR4__)\n+#\t   define IRIX5   /* or IRIX 6.X */\n+#\t else\n+#\t   define RISCOS  /* or IRIX 4.X */\n+#\t endif\n+#      endif\n+#    endif /* !LINUX */\n #    define mach_type_known\n # endif\n # if defined(sequent) && defined(i386)\n@@ -130,15 +138,22 @@\n #   define SYSV\n #   define mach_type_known\n # endif\n-# if defined(_PA_RISC1_0) || defined(_PA_RISC1_1) \\\n+# if defined(_PA_RISC1_0) || defined(_PA_RISC1_1) || defined(_PA_RISC2_0) \\\n      || defined(hppa) || defined(__hppa__)\n #   define HP_PA\n+#   ifndef LINUX\n+#     define HPUX\n+#   endif\n #   define mach_type_known\n # endif\n # if defined(LINUX) && (defined(i386) || defined(__i386__))\n #    define I386\n #    define mach_type_known\n # endif\n+# if defined(LINUX) && (defined(__ia64__) || defined(__ia64))\n+#    define IA64\n+#    define mach_type_known\n+# endif\n # if defined(LINUX) && defined(powerpc)\n #    define POWERPC\n #    define mach_type_known\n@@ -147,10 +162,14 @@\n #    define M68K\n #    define mach_type_known\n # endif\n-# if defined(LINUX) && defined(sparc)\n+# if defined(LINUX) && (defined(sparc) || defined(__sparc__))\n #    define SPARC\n #    define mach_type_known\n # endif\n+# if defined(LINUX) && defined(arm)\n+#    define ARM32\n+#    define mach_type_known\n+# endif\n # if defined(__alpha) || defined(__alpha__)\n #   define ALPHA\n #   if !defined(LINUX)\n@@ -243,6 +262,11 @@\n #   define CYGWIN32\n #   define mach_type_known\n # endif\n+# if defined(__MINGW32__)\n+#   define I386\n+#   define MSWIN32\n+#   define mach_type_known\n+# endif\n # if defined(__BORLANDC__)\n #   define I386\n #   define MSWIN32\n@@ -253,6 +277,10 @@\n #   define UTS4\n #   define mach_type_known\n # endif\n+# if defined(__pj__)\n+#   define PJ\n+#   define mach_type_known\n+# endif\n /* Ivan Demakov */\n # if defined(__WATCOMC__) && defined(__386__)\n #   define I386\n@@ -307,6 +335,9 @@\n \t\t    /* \t\t        (CX_UX and DGUX)\t\t*/\n \t\t    /* \t\t   S370\t      ==> 370-like machine\t*/\n \t\t    /* \t\t\trunning Amdahl UTS4\t\t*/\n+\t\t    /* \t\t   ARM32      ==> Intel StrongARM\t*/\n+\t\t    /* \t\t   IA64\t      ==> Intel IA64\t\t*/\n+\t\t    /*\t\t\t\t  (e.g. Itanium)\t*/\n \n \n /*\n@@ -392,6 +423,15 @@\n  *\n  * An architecture may define DYNAMIC_LOADING if dynamic_load.c\n  * defined GC_register_dynamic_libraries() for the architecture.\n+ *\n+ * An architecture may define PREFETCH(x) to preload the cache with *x.\n+ * This defaults to a no-op.\n+ *\n+ * PREFETCH_FOR_WRITE(x) is used if *x is about to be written.\n+ *\n+ * An architecture may also define CLEAR_DOUBLE(x) to be a fast way to\n+ * clear the two words at GC_malloc-aligned address x.  By default,\n+ * word stores of 0 are used instead.\n  */\n \n \n@@ -516,7 +556,7 @@\n #     undef STACK_GRAN\n #     define STACK_GRAN 0x10000000\n \t/* Stack usually starts at 0x80000000 */\n-#     define DATASTART GC_data_start\n+#     define LINUX_DATA_START\n       extern int _end;\n #     define DATAEND (&_end)\n #   endif\n@@ -615,8 +655,8 @@\n #   ifdef LINUX\n #     define OS_TYPE \"LINUX\"\n #     ifdef __ELF__\n-#         define DATASTART GC_data_start\n-#         define DYNAMIC_LOADING\n+#       define LINUX_DATA_START\n+#       define DYNAMIC_LOADING\n #     else\n           Linux Sparc non elf ?\n #     endif\n@@ -684,13 +724,16 @@\n #   endif\n #   ifdef LINUX\n #\tdefine OS_TYPE \"LINUX\"\n-#       define HEURISTIC1\n-#       undef STACK_GRAN\n-#       define STACK_GRAN 0x10000000\n-\t/* STACKBOTTOM is usually 0xc0000000, but this changes with\t*/\n-\t/* different kernel configurations.  In particular, systems\t*/\n-\t/* with 2GB physical memory will usually move the user\t\t*/\n-\t/* address space limit, and hence initial SP to 0x80000000.\t*/\n+#       define LINUX_STACKBOTTOM\n+#\tif 0\n+#\t  define HEURISTIC1\n+#         undef STACK_GRAN\n+#         define STACK_GRAN 0x10000000\n+\t  /* STACKBOTTOM is usually 0xc0000000, but this changes with\t*/\n+\t  /* different kernel configurations.  In particular, systems\t*/\n+\t  /* with 2GB physical memory will usually move the user\t*/\n+\t  /* address space limit, and hence initial SP to 0x80000000.\t*/\n+#       endif\n #       if !defined(LINUX_THREADS) || !defined(REDIRECT_MALLOC)\n #\t    define MPROTECT_VDB\n #\telse\n@@ -706,8 +749,7 @@\n #\t     endif\n #\t     include <features.h>\n #\t     if defined(__GLIBC__) && __GLIBC__ >= 2\n-\t\t extern int __data_start;\n-#\t\t define DATASTART ((ptr_t)(&__data_start))\n+#\t\t define LINUX_DATA_START\n #\t     else\n      \t         extern char **__environ;\n #                define DATASTART ((ptr_t)(&__environ))\n@@ -726,6 +768,26 @@\n \t     extern int etext;\n #            define DATASTART ((ptr_t)((((word) (&etext)) + 0xfff) & ~0xfff))\n #       endif\n+#\tifdef USE_I686_PREFETCH\n+#\t  define PREFETCH(x) \\\n+\t    __asm__ __volatile__ (\"\tprefetchnta\t%0\": : \"m\"(*(char *)(x)))\n+\t    /* Empirically prefetcht0 is much more effective at reducing\t*/\n+\t    /* cache miss stalls for the targetted load instructions.  But it\t*/\n+\t    /* seems to interfere enough with other cache traffic that the net\t*/\n+\t    /* result is worse than prefetchnta.\t\t\t\t*/\n+#         if 0 \n+\t    /* Using prefetches for write seems to have a slight negative\t*/\n+\t    /* impact on performance, at least for a PIII/500.\t\t\t*/\n+#\t    define PREFETCH_FOR_WRITE(x) \\\n+\t      __asm__ __volatile__ (\"\tprefetcht0\t%0\": : \"m\"(*(char *)(x)))\n+#\t  endif\n+#\tendif\n+#\tifdef USE_3DNOW_PREFETCH\n+#\t  define PREFETCH(x) \\\n+\t    __asm__ __volatile__ (\"\tprefetch\t%0\": : \"m\"(*(char *)(x)))\n+#\t  define PREFETCH_FOR_WRITE(x) \n+\t    __asm__ __volatile__ (\"\tprefetchw\t%0\": : \"m\"(*(char *)(x)))\n+#\tendif\n #   endif\n #   ifdef CYGWIN32\n #       define OS_TYPE \"CYGWIN32\"\n@@ -836,35 +898,48 @@\n \n # ifdef MIPS\n #   define MACH_TYPE \"MIPS\"\n-#   ifndef IRIX5\n-#     define DATASTART (ptr_t)0x10000000\n-\t\t\t      /* Could probably be slightly higher since */\n-\t\t\t      /* startup code allocates lots of stuff.   */\n-#   else\n-      extern int _fdata;\n-#     define DATASTART ((ptr_t)(&_fdata))\n-#     ifdef USE_MMAP\n-#         define HEAP_START (ptr_t)0x30000000\n-#     else\n-#\t  define HEAP_START DATASTART\n-#     endif\n-\t\t\t      /* Lowest plausible heap address.\t\t*/\n-\t\t\t      /* In the MMAP case, we map there.\t*/\n-\t\t\t      /* In either case it is used to identify\t*/\n-\t\t\t      /* heap sections so they're not \t\t*/\n-\t\t\t      /* considered as roots.\t\t\t*/\n-#   endif /* IRIX5 */\n-#   define HEURISTIC2\n /* #   define STACKBOTTOM ((ptr_t)0x7fff8000)  sometimes also works.  */\n+#   ifdef LINUX\n+      /* This was developed for a linuxce style platform.  Probably\t*/\n+      /* needs to be tweaked for workstation class machines.\t\t*/\n+#     define OS_TYPE \"LINUX\"\n+      extern int __data_start;\n+#     define DATASTART ((ptr_t)(&__data_start))\n+#     define ALIGNMENT 4\n+#     define USE_GENERIC_PUSH_REGS 1\n+#     define STACKBOTTOM 0x80000000\n+\t/* In many cases, this should probably use LINUX_STACKBOTTOM \t*/\n+\t/* instead. But some kernel versions seem to give the wrong\t*/\n+\t/* value from /proc.\t\t\t\t\t\t*/\n+#   endif /* Linux */\n #   ifdef ULTRIX\n+#\tdefine HEURISTIC2\n+#       define DATASTART (ptr_t)0x10000000\n+\t\t\t      /* Could probably be slightly higher since */\n+\t\t\t      /* startup code allocates lots of stuff.   */\n #\tdefine OS_TYPE \"ULTRIX\"\n #       define ALIGNMENT 4\n #   endif\n #   ifdef RISCOS\n+#\tdefine HEURISTIC2\n+#       define DATASTART (ptr_t)0x10000000\n #\tdefine OS_TYPE \"RISCOS\"\n #   \tdefine ALIGNMENT 4  /* Required by hardware */\n #   endif\n #   ifdef IRIX5\n+#\tdefine HEURISTIC2\n+        extern int _fdata;\n+#       define DATASTART ((ptr_t)(&_fdata))\n+#       ifdef USE_MMAP\n+#         define HEAP_START (ptr_t)0x30000000\n+#       else\n+#\t  define HEAP_START DATASTART\n+#       endif\n+\t\t\t      /* Lowest plausible heap address.\t\t*/\n+\t\t\t      /* In the MMAP case, we map there.\t*/\n+\t\t\t      /* In either case it is used to identify\t*/\n+\t\t\t      /* heap sections so they're not \t\t*/\n+\t\t\t      /* considered as roots.\t\t\t*/\n #\tdefine OS_TYPE \"IRIX5\"\n #       define MPROTECT_VDB\n #       ifdef _MIPS_SZPTR\n@@ -892,9 +967,17 @@\n # endif\n \n # ifdef HP_PA\n+    /* OS is assumed to be HP/UX\t*/\n #   define MACH_TYPE \"HP_PA\"\n-#   define ALIGNMENT 4\n-#   define ALIGN_DOUBLE\n+#   define OS_TYPE \"HPUX\"\n+#   ifdef __LP64__\n+#     define CPP_WORDSZ 64\n+#     define ALIGNMENT 8\n+#   else\n+#     define CPP_WORDSZ 32\n+#     define ALIGNMENT 4\n+#     define ALIGN_DOUBLE\n+#   endif\n     extern int __data_start;\n #   define DATASTART ((ptr_t)(&__data_start))\n #   if 0\n@@ -911,14 +994,21 @@\n #   endif\n #   define STACK_GROWS_UP\n #   define DYNAMIC_LOADING\n+#   ifndef HPUX_THREADS\n+#     define MPROTECT_VDB\n+#   endif\n #   include <unistd.h>\n #   define GETPAGESIZE() sysconf(_SC_PAGE_SIZE)\n-\t/* They misspelled the Posix macro?\t*/\n # endif\n \n # ifdef ALPHA\n #   define MACH_TYPE \"ALPHA\"\n #   define ALIGNMENT 8\n+#   define USE_GENERIC_PUSH_REGS\n+\t/* Gcc and probably the DEC/Compaq compiler spill pointers to preserved\t*/\n+\t/* fp registers in some cases when the target is a 21264.  The assembly\t*/\n+\t/* code doesn't handle that yet, and version dependencies make that a\t*/\n+\t/* bit tricky.  Do the easy thing for now.\t\t\t\t*/\n #   ifdef OSF1\n #\tdefine OS_TYPE \"OSF1\"\n #   \tdefine DATASTART ((ptr_t) 0x140000000)\n@@ -939,13 +1029,9 @@\n #       define CPP_WORDSZ 64\n #       define STACKBOTTOM ((ptr_t) 0x120000000)\n #       ifdef __ELF__\n-#   \t  if 0\n-\t    /* __data_start apparently disappeared in some recent releases. */\n-            extern int __data_start;\n-#           define DATASTART &__data_start\n-#\t  endif\n-#         define DATASTART GC_data_start\n+#\t  define LINUX_DATA_START\n #         define DYNAMIC_LOADING\n+\t  /* This doesn't work if the collector is in a dynamic library. */\n #       else\n #           define DATASTART ((ptr_t) 0x140000000)\n #       endif\n@@ -957,6 +1043,49 @@\n #   endif\n # endif\n \n+# ifdef IA64\n+#   define MACH_TYPE \"IA64\"\n+#   define ALIGN_DOUBLE\n+\t/* Requires 16 byte alignment for malloc */\n+#   define ALIGNMENT 8\n+#   define USE_GENERIC_PUSH_REGS\n+\t/* We need to get preserved registers in addition to register windows.\t*/\n+\t/* That's easiest to do with setjmp.\t\t\t\t\t*/\n+#   ifdef HPUX\n+\t--> needs work\n+#   endif\n+#   ifdef LINUX\n+#       define OS_TYPE \"LINUX\"\n+#       define CPP_WORDSZ 64\n+\t/* This should really be done through /proc, but that\t*/\n+\t/* requires we run on an IA64 kernel.\t\t\t*/\n+#       define STACKBOTTOM ((ptr_t) 0xa000000000000000l)\n+\t/* We also need the base address of the register stack\t*/\n+\t/* backing store.  There is probably a better way to\t*/\n+\t/* get that, too ...\t\t\t\t\t*/\n+#\tdefine BACKING_STORE_BASE ((ptr_t) 0x9fffffff80000000l)\n+#\tif 1\n+#\t    define SEARCH_FOR_DATA_START\n+#\t    define DATASTART GC_data_start\n+#\telse\n+\t    extern int data_start;\n+#\t    define DATASTART ((ptr_t)(&data_start))\n+#\tendif\n+#       define DYNAMIC_LOADING\n+#\tdefine MPROTECT_VDB\n+\t\t/* Requires Linux 2.3.47 or later.\t*/\n+\textern int _end;\n+#\tdefine DATAEND (&_end)\n+\t/* PREFETCH appears to have a large performance impact.\t*/\n+#\tdefine PREFETCH(x) \\\n+\t  __asm__ (\"\tlfetch\t[%0]\": : \"r\"((void *)(x)))\n+#\tdefine PREFETCH_FOR_WRITE(x) \\\n+\t  __asm__ (\"\tlfetch.excl\t[%0]\": : \"r\"((void *)(x)))\n+#\tdefine CLEAR_DOUBLE(x) \\\n+\t  __asm__ (\"\tstf.spill\t[%0]=f0\": : \"r\"((void *)(x)))\n+#   endif\n+# endif\n+\n # ifdef M88K\n #   define MACH_TYPE \"M88K\"\n #   define ALIGNMENT 4\n@@ -987,6 +1116,69 @@\n #\tdefine HEURISTIC2\n # endif\n \n+# if defined(PJ)\n+#   define ALIGNMENT 4\n+    extern int _etext;\n+#   define DATASTART ((ptr_t)(&_etext))\n+#   define HEURISTIC1\n+# endif\n+\n+# ifdef ARM32\n+#   define CPP_WORDSZ 32\n+#   define MACH_TYPE \"ARM32\"\n+#   define ALIGNMENT 4\n+#   ifdef NETBSD\n+#       define OS_TYPE \"NETBSD\"\n+#       define HEURISTIC2\n+        extern char etext;\n+#       define DATASTART ((ptr_t)(&etext))\n+#       define USE_GENERIC_PUSH_REGS\n+#   endif\n+#   ifdef LINUX\n+#       define OS_TYPE \"LINUX\"\n+#       define HEURISTIC1\n+#       undef STACK_GRAN\n+#       define STACK_GRAN 0x10000000\n+#       define USE_GENERIC_PUSH_REGS\n+#       ifdef __ELF__\n+#            define DYNAMIC_LOADING\n+#\t     include <features.h>\n+#\t     if defined(__GLIBC__) && __GLIBC__ >= 2\n+#\t\t define LINUX_DATA_START\n+#\t     else\n+     \t         extern char **__environ;\n+#                define DATASTART ((ptr_t)(&__environ))\n+\t\t\t      /* hideous kludge: __environ is the first */\n+\t\t\t      /* word in crt0.o, and delimits the start */\n+\t\t\t      /* of the data segment, no matter which   */\n+\t\t\t      /* ld options were passed through.        */\n+\t\t\t      /* We could use _etext instead, but that  */\n+\t\t\t      /* would include .rodata, which may       */\n+\t\t\t      /* contain large read-only data tables    */\n+\t\t\t      /* that we'd rather not scan.\t\t*/\n+#\t     endif\n+\t     extern int _end;\n+#\t     define DATAEND (&_end)\n+#\telse\n+\t     extern int etext;\n+#            define DATASTART ((ptr_t)((((word) (&etext)) + 0xfff) & ~0xfff))\n+#       endif\n+#   endif\n+#endif\n+\n+#ifdef LINUX_DATA_START\n+    /* Some Linux distributions arrange to define __data_start.  Some\t*/\n+    /* define data_start as a weak symbol.  The latter is technically\t*/\n+    /* broken, since the user program may define data_start, in which\t*/\n+    /* case we lose.  Nonetheless, we try both, prefering __data_start.\t*/\n+    /* We assume gcc.\t*/\n+#   pragma weak __data_start\n+    extern int __data_start;\n+#   pragma weak data_start\n+    extern int data_start;\n+#   define DATASTART ((ptr_t)(&__data_start != 0? &__data_start : &data_start))\n+#endif\n+\n # ifndef STACK_GROWS_UP\n #   define STACK_GROWS_DOWN\n # endif\n@@ -1029,6 +1221,10 @@\n #   define SUNOS5SIGS\n # endif\n \n+# if defined(HPUX)\n+#   define SUNOS5SIGS\n+# endif\n+\n # if CPP_WORDSZ != 32 && CPP_WORDSZ != 64\n    -> bad word size\n # endif\n@@ -1063,6 +1259,26 @@\n #   define DEFAULT_VDB\n # endif\n \n+# ifndef PREFETCH\n+#   define PREFETCH(x)\n+#   define NO_PREFETCH\n+# endif\n+\n+# ifndef PREFETCH_FOR_WRITE\n+#   define PREFETCH_FOR_WRITE(x)\n+#   define NO_PREFETCH_FOR_WRITE\n+# endif\n+\n+# ifndef CACHE_LINE_SIZE\n+#   define CACHE_LINE_SIZE 32\t/* Wild guess\t*/\n+# endif\n+\n+# ifndef CLEAR_DOUBLE\n+#   define CLEAR_DOUBLE(x) \\\n+\t((word*)x)[0] = 0; \\\n+\t((word*)x)[1] = 0;\n+# endif /* CLEAR_DOUBLE */\n+\n # if defined(_SOLARIS_PTHREADS) && !defined(SOLARIS_THREADS)\n #   define SOLARIS_THREADS\n # endif\n@@ -1078,10 +1294,13 @@\n # if defined(SOLARIS_THREADS) && !defined(SUNOS5)\n --> inconsistent configuration\n # endif\n+# if defined(HPUX_THREADS) && !defined(HPUX)\n+--> inconsistent configuration\n+# endif\n # if defined(PCR) || defined(SRC_M3) || \\\n \tdefined(SOLARIS_THREADS) || defined(WIN32_THREADS) || \\\n \tdefined(IRIX_THREADS) || defined(LINUX_THREADS) || \\\n-\tdefined(IRIX_JDK_THREADS)\n+\tdefined(IRIX_JDK_THREADS) || defined(HPUX_THREADS)\n #   define THREADS\n # endif\n \n@@ -1096,4 +1315,4 @@\n \t\t\t\t/* include assembly code to do it well.\t*/\n # endif\n \n-# endif\n+# endif /* GCCONFIG_H */"}]}