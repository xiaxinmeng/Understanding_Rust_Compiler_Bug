{"sha": "e90d15686466770a26d9ea512bef52897511807f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTkwZDE1Njg2NDY2NzcwYTI2ZDllYTUxMmJlZjUyODk3NTExODA3Zg==", "commit": {"author": {"name": "Hans-Peter Nilsson", "email": "hp@bitrange.com", "date": "2013-07-03T14:37:29Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@gcc.gnu.org", "date": "2013-07-03T14:37:29Z"}, "message": "re PR middle-end/55030 (gcc.c-torture/execute/builtins/memcpy-chk.c execution,  -Os (et al))\n\n\tPR middle-end/55030\n\t* stmt.c (expand_nl_goto_receiver): Remove almost-copy of\n\texpand_builtin_setjmp_receiver.\n\t(expand_label): Adjust, call expand_builtin_setjmp_receiver\n\twith NULL for the label parameter.\n\t* builtins.c (expand_builtin_setjmp_receiver): Don't clobber\n\tthe frame-pointer.  Adjust comments.\n\t[HAVE_builtin_setjmp_receiver]: Emit builtin_setjmp_receiver\n\tonly if LABEL is non-NULL.\n\nFrom-SVN: r200643", "tree": {"sha": "42ce7f021dc99ae613b299643535ca40828f2a6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42ce7f021dc99ae613b299643535ca40828f2a6e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e90d15686466770a26d9ea512bef52897511807f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e90d15686466770a26d9ea512bef52897511807f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e90d15686466770a26d9ea512bef52897511807f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e90d15686466770a26d9ea512bef52897511807f/comments", "author": null, "committer": null, "parents": [{"sha": "cbd7413b3c21c29efeccf753f76ad77bb0b94bed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbd7413b3c21c29efeccf753f76ad77bb0b94bed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbd7413b3c21c29efeccf753f76ad77bb0b94bed"}], "stats": {"total": 116, "additions": 34, "deletions": 82}, "files": [{"sha": "0addb65022dfb8337e48b4c39990d98397b4c1dc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e90d15686466770a26d9ea512bef52897511807f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e90d15686466770a26d9ea512bef52897511807f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e90d15686466770a26d9ea512bef52897511807f", "patch": "@@ -1,3 +1,15 @@\n+2013-07-03  Hans-Peter Nilsson  <hp@bitrange.com>\n+\n+\tPR middle-end/55030\n+\t* stmt.c (expand_nl_goto_receiver): Remove almost-copy of\n+\texpand_builtin_setjmp_receiver.\n+\t(expand_label): Adjust, call expand_builtin_setjmp_receiver\n+\twith NULL for the label parameter.\n+\t* builtins.c (expand_builtin_setjmp_receiver): Don't clobber\n+\tthe frame-pointer.  Adjust comments.\n+\t[HAVE_builtin_setjmp_receiver]: Emit builtin_setjmp_receiver\n+\tonly if LABEL is non-NULL.\n+\n 2013-07-03  Yufeng Zhang  <yufeng.zhang@arm.com>\n \n \t* config/aarch64/aarch64.h (enum arm_abi_type): Remove."}, {"sha": "6bd045c1e7e3f4ab4df653629c26e897a1b6f1b9", "filename": "gcc/builtins.c", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e90d15686466770a26d9ea512bef52897511807f/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e90d15686466770a26d9ea512bef52897511807f/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=e90d15686466770a26d9ea512bef52897511807f", "patch": "@@ -886,14 +886,15 @@ expand_builtin_setjmp_setup (rtx buf_addr, rtx receiver_label)\n }\n \n /* Construct the trailing part of a __builtin_setjmp call.  This is\n-   also called directly by the SJLJ exception handling code.  */\n+   also called directly by the SJLJ exception handling code.\n+   If RECEIVER_LABEL is NULL, instead contruct a nonlocal goto handler.  */\n \n void\n expand_builtin_setjmp_receiver (rtx receiver_label ATTRIBUTE_UNUSED)\n {\n   rtx chain;\n \n-  /* Clobber the FP when we get here, so we have to make sure it's\n+  /* Mark the FP as used when we get here, so we have to make sure it's\n      marked as used by this function.  */\n   emit_use (hard_frame_pointer_rtx);\n \n@@ -908,17 +909,28 @@ expand_builtin_setjmp_receiver (rtx receiver_label ATTRIBUTE_UNUSED)\n #ifdef HAVE_nonlocal_goto\n   if (! HAVE_nonlocal_goto)\n #endif\n-    {\n-      emit_move_insn (virtual_stack_vars_rtx, hard_frame_pointer_rtx);\n-      /* This might change the hard frame pointer in ways that aren't\n-\t apparent to early optimization passes, so force a clobber.  */\n-      emit_clobber (hard_frame_pointer_rtx);\n-    }\n+    /* First adjust our frame pointer to its actual value.  It was\n+       previously set to the start of the virtual area corresponding to\n+       the stacked variables when we branched here and now needs to be\n+       adjusted to the actual hardware fp value.\n+\n+       Assignments to virtual registers are converted by\n+       instantiate_virtual_regs into the corresponding assignment\n+       to the underlying register (fp in this case) that makes\n+       the original assignment true.\n+       So the following insn will actually be decrementing fp by\n+       STARTING_FRAME_OFFSET.  */\n+    emit_move_insn (virtual_stack_vars_rtx, hard_frame_pointer_rtx);\n \n #if !HARD_FRAME_POINTER_IS_ARG_POINTER\n   if (fixed_regs[ARG_POINTER_REGNUM])\n     {\n #ifdef ELIMINABLE_REGS\n+      /* If the argument pointer can be eliminated in favor of the\n+\t frame pointer, we don't need to restore it.  We assume here\n+\t that if such an elimination is present, it can always be used.\n+\t This is the case on all known machines; if we don't make this\n+\t assumption, we do unnecessary saving on many machines.  */\n       size_t i;\n       static const struct elims {const int from, to;} elim_regs[] = ELIMINABLE_REGS;\n \n@@ -939,7 +951,7 @@ expand_builtin_setjmp_receiver (rtx receiver_label ATTRIBUTE_UNUSED)\n #endif\n \n #ifdef HAVE_builtin_setjmp_receiver\n-  if (HAVE_builtin_setjmp_receiver)\n+  if (receiver_label != NULL && HAVE_builtin_setjmp_receiver)\n     emit_insn (gen_builtin_setjmp_receiver (receiver_label));\n   else\n #endif"}, {"sha": "1dc447a5c858cb3c5fba4c7735a01a48d08510c1", "filename": "gcc/stmt.c", "status": "modified", "additions": 1, "deletions": 73, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e90d15686466770a26d9ea512bef52897511807f/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e90d15686466770a26d9ea512bef52897511807f/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=e90d15686466770a26d9ea512bef52897511807f", "patch": "@@ -104,7 +104,6 @@ extern basic_block label_to_block_fn (struct function *, tree);\n \f\n static int n_occurrences (int, const char *);\n static bool tree_conflicts_with_clobbers_p (tree, HARD_REG_SET *);\n-static void expand_nl_goto_receiver (void);\n static bool check_operand_nalternatives (tree, tree);\n static bool check_unique_operand_names (tree, tree, tree);\n static char *resolve_operand_name_1 (char *, tree, tree, tree);\n@@ -198,7 +197,7 @@ expand_label (tree label)\n \n   if (DECL_NONLOCAL (label))\n     {\n-      expand_nl_goto_receiver ();\n+      expand_builtin_setjmp_receiver (NULL);\n       nonlocal_goto_handler_labels\n \t= gen_rtx_EXPR_LIST (VOIDmode, label_r,\n \t\t\t     nonlocal_goto_handler_labels);\n@@ -1554,77 +1553,6 @@ expand_return (tree retval)\n     }\n }\n \f\n-/* Emit code to restore vital registers at the beginning of a nonlocal goto\n-   handler.  */\n-static void\n-expand_nl_goto_receiver (void)\n-{\n-  rtx chain;\n-\n-  /* Clobber the FP when we get here, so we have to make sure it's\n-     marked as used by this function.  */\n-  emit_use (hard_frame_pointer_rtx);\n-\n-  /* Mark the static chain as clobbered here so life information\n-     doesn't get messed up for it.  */\n-  chain = targetm.calls.static_chain (current_function_decl, true);\n-  if (chain && REG_P (chain))\n-    emit_clobber (chain);\n-\n-#ifdef HAVE_nonlocal_goto\n-  if (! HAVE_nonlocal_goto)\n-#endif\n-    /* First adjust our frame pointer to its actual value.  It was\n-       previously set to the start of the virtual area corresponding to\n-       the stacked variables when we branched here and now needs to be\n-       adjusted to the actual hardware fp value.\n-\n-       Assignments are to virtual registers are converted by\n-       instantiate_virtual_regs into the corresponding assignment\n-       to the underlying register (fp in this case) that makes\n-       the original assignment true.\n-       So the following insn will actually be\n-       decrementing fp by STARTING_FRAME_OFFSET.  */\n-    emit_move_insn (virtual_stack_vars_rtx, hard_frame_pointer_rtx);\n-\n-#if !HARD_FRAME_POINTER_IS_ARG_POINTER\n-  if (fixed_regs[ARG_POINTER_REGNUM])\n-    {\n-#ifdef ELIMINABLE_REGS\n-      /* If the argument pointer can be eliminated in favor of the\n-\t frame pointer, we don't need to restore it.  We assume here\n-\t that if such an elimination is present, it can always be used.\n-\t This is the case on all known machines; if we don't make this\n-\t assumption, we do unnecessary saving on many machines.  */\n-      static const struct elims {const int from, to;} elim_regs[] = ELIMINABLE_REGS;\n-      size_t i;\n-\n-      for (i = 0; i < ARRAY_SIZE (elim_regs); i++)\n-\tif (elim_regs[i].from == ARG_POINTER_REGNUM\n-\t    && elim_regs[i].to == HARD_FRAME_POINTER_REGNUM)\n-\t  break;\n-\n-      if (i == ARRAY_SIZE (elim_regs))\n-#endif\n-\t{\n-\t  /* Now restore our arg pointer from the address at which it\n-\t     was saved in our stack frame.  */\n-\t  emit_move_insn (crtl->args.internal_arg_pointer,\n-\t\t\t  copy_to_reg (get_arg_pointer_save_area ()));\n-\t}\n-    }\n-#endif\n-\n-#ifdef HAVE_nonlocal_goto_receiver\n-  if (HAVE_nonlocal_goto_receiver)\n-    emit_insn (gen_nonlocal_goto_receiver ());\n-#endif\n-\n-  /* We must not allow the code we just generated to be reordered by\n-     scheduling.  Specifically, the update of the frame pointer must\n-     happen immediately, not later.  */\n-  emit_insn (gen_blockage ());\n-}\n \f\n /* Emit code to save the current value of stack.  */\n rtx"}]}