{"sha": "dcb7c3cea69923adba7e664b9f45429a6fd3349a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGNiN2MzY2VhNjk5MjNhZGJhN2U2NjRiOWY0NTQyOWE2ZmQzMzQ5YQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-07-20T10:11:25Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-07-20T10:11:25Z"}, "message": "(expand_expr...\n\n(expand_expr, case PLACEHOLDER_EXPR): Pick outermost object in\nplaceholder_list of right type without a PLACEHOLDER_EXPR.\n\nFrom-SVN: r14498", "tree": {"sha": "d599ec18dbb7d640c55e35cda06fcd5c192d2eb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d599ec18dbb7d640c55e35cda06fcd5c192d2eb0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dcb7c3cea69923adba7e664b9f45429a6fd3349a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcb7c3cea69923adba7e664b9f45429a6fd3349a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dcb7c3cea69923adba7e664b9f45429a6fd3349a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcb7c3cea69923adba7e664b9f45429a6fd3349a/comments", "author": null, "committer": null, "parents": [{"sha": "3910a7cb5ea4b50d79c6aa36b28369716e130111", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3910a7cb5ea4b50d79c6aa36b28369716e130111", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3910a7cb5ea4b50d79c6aa36b28369716e130111"}], "stats": {"total": 44, "additions": 27, "deletions": 17}, "files": [{"sha": "1cfb4538a2e1cdde452d47a30b31165b997307f5", "filename": "gcc/expr.c", "status": "modified", "additions": 27, "deletions": 17, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcb7c3cea69923adba7e664b9f45429a6fd3349a/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcb7c3cea69923adba7e664b9f45429a6fd3349a/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=dcb7c3cea69923adba7e664b9f45429a6fd3349a", "patch": "@@ -5048,26 +5048,36 @@ expand_expr (exp, target, tmode, modifier)\n \t  tree old_list = placeholder_list;\n \t  tree elt;\n \n-\t  /* See if the object is the type that we want.  Then see if\n-\t     the operand of any reference is the type we want.  */\n+\t  /* See if the object is the type that we want and does not contain\n+\t     this PLACEHOLDER_EXPR itself.  Then see if the operand of any\n+\t     reference is the type we want.  */\n \t  if ((TYPE_MAIN_VARIANT (TREE_TYPE (TREE_PURPOSE (placeholder_list)))\n-\t       == need_type))\n+\t       == need_type)\n+\t      && (! contains_this_placeholder_p\n+\t\t  (TREE_PURPOSE (placeholder_list), exp)))\n \t    object = TREE_PURPOSE (placeholder_list);\n \n-\t  /* Find the innermost reference that is of the type we want.    */\n-\t  for (elt = TREE_PURPOSE (placeholder_list);\n-\t       elt != 0\n-\t       && (TREE_CODE_CLASS (TREE_CODE (elt)) == 'r'\n-\t\t   || TREE_CODE_CLASS (TREE_CODE (elt)) == '1'\n-\t\t   || TREE_CODE_CLASS (TREE_CODE (elt)) == '2'\n-\t\t   || TREE_CODE_CLASS (TREE_CODE (elt)) == 'e');\n-\t       elt = ((TREE_CODE (elt) == COMPOUND_EXPR\n-\t\t       || TREE_CODE (elt) == COND_EXPR)\n-\t\t      ? TREE_OPERAND (elt, 1) : TREE_OPERAND (elt, 0)))\n-\t    if (TREE_CODE_CLASS (TREE_CODE (elt)) == 'r'\n-\t\t&& (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_OPERAND (elt, 0)))\n-\t\t    == need_type))\n-\t      object = TREE_OPERAND (elt, 0);\n+\t  else\n+\t    /* Find the outermost reference that is of the type we want and\n+\t       that does not itself contain this PLACEHOLDER_EXPR.  */\n+\t    for (elt = TREE_PURPOSE (placeholder_list);\n+\t\t elt != 0\n+\t\t && (TREE_CODE_CLASS (TREE_CODE (elt)) == 'r'\n+\t\t     || TREE_CODE_CLASS (TREE_CODE (elt)) == '1'\n+\t\t     || TREE_CODE_CLASS (TREE_CODE (elt)) == '2'\n+\t\t     || TREE_CODE_CLASS (TREE_CODE (elt)) == 'e');\n+\t\t elt = ((TREE_CODE (elt) == COMPOUND_EXPR\n+\t\t\t || TREE_CODE (elt) == COND_EXPR)\n+\t\t\t? TREE_OPERAND (elt, 1) : TREE_OPERAND (elt, 0)))\n+\t      if (TREE_CODE_CLASS (TREE_CODE (elt)) == 'r'\n+\t\t  && (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_OPERAND (elt, 0)))\n+\t\t      == need_type)\n+\t\t  && ! contains_this_placeholder_p (TREE_OPERAND (elt, 0),\n+\t\t\t\t\t\t    exp))\n+\t\t{\n+\t\t  object = TREE_OPERAND (elt, 0);\n+\t\t  break;\n+\t\t}\n \n \t  if (object != 0)\n \t    {"}]}