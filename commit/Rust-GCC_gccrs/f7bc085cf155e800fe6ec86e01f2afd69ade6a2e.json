{"sha": "f7bc085cf155e800fe6ec86e01f2afd69ade6a2e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjdiYzA4NWNmMTU1ZTgwMGZlNmVjODZlMDFmMmFmZDY5YWRlNmEyZQ==", "commit": {"author": {"name": "H.J. Lu", "email": "hongjiu.lu@intel.com", "date": "2008-08-18T19:16:30Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2008-08-18T19:16:30Z"}, "message": "mcf.c: Really add it.\n\n2008-08-18  H.J. Lu  <hongjiu.lu@intel.com>\n\n\t* mcf.c: Really add it.\n\nFrom-SVN: r139209", "tree": {"sha": "6a20c1f399b08cf2e4183459090cff06a7c1df5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a20c1f399b08cf2e4183459090cff06a7c1df5a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f7bc085cf155e800fe6ec86e01f2afd69ade6a2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7bc085cf155e800fe6ec86e01f2afd69ade6a2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7bc085cf155e800fe6ec86e01f2afd69ade6a2e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7bc085cf155e800fe6ec86e01f2afd69ade6a2e/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "52c76998c7109adca55106b881b9945fea860015", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52c76998c7109adca55106b881b9945fea860015", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52c76998c7109adca55106b881b9945fea860015"}], "stats": {"total": 1405, "additions": 1405, "deletions": 0}, "files": [{"sha": "128edeadae2eaf4ba2bff129609a7abdc55160cf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7bc085cf155e800fe6ec86e01f2afd69ade6a2e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7bc085cf155e800fe6ec86e01f2afd69ade6a2e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f7bc085cf155e800fe6ec86e01f2afd69ade6a2e", "patch": "@@ -1,3 +1,7 @@\n+2008-08-18  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* mcf.c: Really add it.\n+\n 2008-08-18  Paul Yuan  <yingbo.com@gmail.com>\n \t    Vinodha Ramasamy  <vinodha@google.com>\n "}, {"sha": "d7bc5f30e72168d19f9c4d072ee07e277446257a", "filename": "gcc/mcf.c", "status": "added", "additions": 1401, "deletions": 0, "changes": 1401, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7bc085cf155e800fe6ec86e01f2afd69ade6a2e/gcc%2Fmcf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7bc085cf155e800fe6ec86e01f2afd69ade6a2e/gcc%2Fmcf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmcf.c?ref=f7bc085cf155e800fe6ec86e01f2afd69ade6a2e", "patch": "@@ -0,0 +1,1401 @@\n+/* Routines to implement minimum-cost maximal flow algorithm used to smooth\n+   basic block and edge frequency counts.\n+   Copyright (C) 2008\n+   Free Software Foundation, Inc.\n+   Contributed by Paul Yuan (yingbo.com@gmail.com) and\n+                  Vinodha Ramasamy (vinodha@google.com).\n+\n+This file is part of GCC.\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* References:\n+   [1] \"Feedback-directed Optimizations in GCC with Estimated Edge Profiles\n+        from Hardware Event Sampling\", Vinodha Ramasamy, Paul Yuan, Dehao Chen,\n+        and Robert Hundt; GCC Summit 2008.\n+   [2] \"Complementing Missing and Inaccurate Profiling Using a Minimum Cost\n+        Circulation Algorithm\", Roy Levin, Ilan Newman and Gadi Haber;\n+        HiPEAC '08.\n+\n+   Algorithm to smooth basic block and edge counts:\n+   1. create_fixup_graph: Create fixup graph by translating function CFG into\n+      a graph that satisfies MCF algorithm requirements.\n+   2. find_max_flow: Find maximal flow.\n+   3. compute_residual_flow: Form residual network.\n+   4. Repeat:\n+      cancel_negative_cycle: While G contains a negative cost cycle C, reverse\n+      the flow on the found cycle by the minimum residual capacity in that\n+      cycle.\n+   5. Form the minimal cost flow\n+      f(u,v) = rf(v, u).\n+   6. adjust_cfg_counts: Update initial edge weights with corrected weights.\n+      delta(u.v) = f(u,v) -f(v,u).\n+      w*(u,v) = w(u,v) + delta(u,v).  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"basic-block.h\"\n+#include \"output.h\"\n+#include \"langhooks.h\"\n+#include \"tree.h\"\n+#include \"gcov-io.h\"\n+\n+#include \"profile.h\"\n+\n+/* CAP_INFINITY: Constant to represent infinite capacity.  */\n+#define CAP_INFINITY __LONG_LONG_MAX__\n+\n+/* COST FUNCTION.  */\n+#define K_POS(b)        ((b))\n+#define K_NEG(b)        (50 * (b))\n+#define COST(k, w)      ((k) / mcf_ln ((w) + 2))\n+/* Limit the number of iterations for cancel_negative_cycles() to ensure\n+   reasonable compile time.  */\n+#define MAX_ITER(n, e)  10 + (1000000 / ((n) * (e)))\n+typedef enum\n+{\n+  INVALID_EDGE,\n+  VERTEX_SPLIT_EDGE,\t    /* Edge to represent vertex with w(e) = w(v).  */\n+  REDIRECT_EDGE,\t    /* Edge after vertex transformation.  */\n+  REVERSE_EDGE,\n+  SOURCE_CONNECT_EDGE,\t    /* Single edge connecting to single source.  */\n+  SINK_CONNECT_EDGE,\t    /* Single edge connecting to single sink.  */\n+  BALANCE_EDGE,\t\t    /* Edge connecting with source/sink: cp(e) = 0.  */\n+  REDIRECT_NORMALIZED_EDGE, /* Normalized edge for a redirect edge.  */\n+  REVERSE_NORMALIZED_EDGE   /* Normalized edge for a reverse edge.  */\n+} edge_type;\n+\n+/* Structure to represent an edge in the fixup graph.  */\n+typedef struct fixup_edge_d\n+{\n+  int src;\n+  int dest;\n+  /* Flag denoting type of edge and attributes for the flow field.  */\n+  edge_type type;\n+  bool is_rflow_valid;\n+  /* Index to the normalization vertex added for this edge.  */\n+  int norm_vertex_index;\n+  /* Flow for this edge.  */\n+  gcov_type flow;\n+  /* Residual flow for this edge - used during negative cycle canceling.  */\n+  gcov_type rflow;\n+  gcov_type weight;\n+  gcov_type cost;\n+  gcov_type max_capacity;\n+} fixup_edge_type;\n+\n+typedef fixup_edge_type *fixup_edge_p;\n+\n+DEF_VEC_P (fixup_edge_p);\n+DEF_VEC_ALLOC_P (fixup_edge_p, heap);\n+\n+/* Structure to represent a vertex in the fixup graph.  */\n+typedef struct fixup_vertex_d\n+{\n+  VEC (fixup_edge_p, heap) *succ_edges;\n+} fixup_vertex_type;\n+\n+typedef fixup_vertex_type *fixup_vertex_p;\n+\n+/* Fixup graph used in the MCF algorithm.  */\n+typedef struct fixup_graph_d\n+{\n+  /* Current number of vertices for the graph.  */\n+  int num_vertices;\n+  /* Current number of edges for the graph.  */\n+  int num_edges;\n+  /* Index of new entry vertex.  */\n+  int new_entry_index;\n+  /* Index of new exit vertex.  */\n+  int new_exit_index;\n+  /* Fixup vertex list. Adjacency list for fixup graph.  */\n+  fixup_vertex_p vertex_list;\n+  /* Fixup edge list.  */\n+  fixup_edge_p edge_list;\n+} fixup_graph_type;\n+\n+typedef struct queue_d\n+{\n+  int *queue;\n+  int head;\n+  int tail;\n+  int size;\n+} queue_type;\n+\n+/* Structure used in the maximal flow routines to find augmenting path.  */\n+typedef struct augmenting_path_d\n+{\n+  /* Queue used to hold vertex indices.  */\n+  queue_type queue_list;\n+  /* Vector to hold chain of pred vertex indices in augmenting path.  */\n+  int *bb_pred;\n+  /* Vector that indicates if basic block i has been visited.  */\n+  int *is_visited;\n+} augmenting_path_type;\n+\n+\n+/* Function definitions.  */\n+\n+/* Dump routines to aid debugging.  */\n+\n+/* Print basic block with index N for FIXUP_GRAPH in n' and n'' format.  */\n+\n+static void\n+print_basic_block (FILE *file, fixup_graph_type *fixup_graph, int n)\n+{\n+  if (n == ENTRY_BLOCK)\n+    fputs (\"ENTRY\", file);\n+  else if (n == ENTRY_BLOCK + 1)\n+    fputs (\"ENTRY''\", file);\n+  else if (n == 2 * EXIT_BLOCK)\n+    fputs (\"EXIT\", file);\n+  else if (n == 2 * EXIT_BLOCK + 1)\n+    fputs (\"EXIT''\", file);\n+  else if (n == fixup_graph->new_exit_index)\n+    fputs (\"NEW_EXIT\", file);\n+  else if (n == fixup_graph->new_entry_index)\n+    fputs (\"NEW_ENTRY\", file);\n+  else\n+    {\n+      fprintf (file, \"%d\", n / 2);\n+      if (n % 2)\n+\tfputs (\"''\", file);\n+      else\n+\tfputs (\"'\", file);\n+    }\n+}\n+\n+\n+/* Print edge S->D for given fixup_graph with n' and n'' format.\n+   PARAMETERS:\n+   S is the index of the source vertex of the edge (input) and\n+   D is the index of the destination vertex of the edge (input) for the given\n+   fixup_graph (input).  */\n+\n+static void\n+print_edge (FILE *file, fixup_graph_type *fixup_graph, int s, int d)\n+{\n+  print_basic_block (file, fixup_graph, s);\n+  fputs (\"->\", file);\n+  print_basic_block (file, fixup_graph, d);\n+}\n+\n+\n+/* Dump out the attributes of a given edge FEDGE in the fixup_graph to a\n+   file.  */\n+static void\n+dump_fixup_edge (FILE *file, fixup_graph_type *fixup_graph, fixup_edge_p fedge)\n+{\n+  if (!fedge)\n+    {\n+      fputs (\"NULL fixup graph edge.\\n\", file);\n+      return;\n+    }\n+\n+  print_edge (file, fixup_graph, fedge->src, fedge->dest);\n+  fputs (\": \", file);\n+\n+  if (fedge->type)\n+    {\n+      fprintf (file, \"flow/capacity=\" HOST_WIDEST_INT_PRINT_DEC \"/\",\n+\t       fedge->flow);\n+      if (fedge->max_capacity == CAP_INFINITY)\n+\tfputs (\"+oo,\", file);\n+      else\n+\tfprintf (file, \"\" HOST_WIDEST_INT_PRINT_DEC \",\", fedge->max_capacity);\n+    }\n+\n+  if (fedge->is_rflow_valid)\n+    {\n+      if (fedge->rflow == CAP_INFINITY)\n+\tfputs (\" rflow=+oo.\", file);\n+      else\n+\tfprintf (file, \" rflow=\" HOST_WIDEST_INT_PRINT_DEC \",\", fedge->rflow);\n+    }\n+\n+  fprintf (file, \" cost=\" HOST_WIDEST_INT_PRINT_DEC \".\", fedge->cost);\n+\n+  fprintf (file, \"\\t(%d->%d)\", fedge->src, fedge->dest);\n+\n+  if (fedge->type)\n+    {\n+      switch (fedge->type)\n+\t{\n+\tcase VERTEX_SPLIT_EDGE:\n+\t  fputs (\" @VERTEX_SPLIT_EDGE\", file);\n+\t  break;\n+\n+\tcase REDIRECT_EDGE:\n+\t  fputs (\" @REDIRECT_EDGE\", file);\n+\t  break;\n+\n+\tcase SOURCE_CONNECT_EDGE:\n+\t  fputs (\" @SOURCE_CONNECT_EDGE\", file);\n+\t  break;\n+\n+\tcase SINK_CONNECT_EDGE:\n+\t  fputs (\" @SINK_CONNECT_EDGE\", file);\n+\t  break;\n+\n+\tcase REVERSE_EDGE:\n+\t  fputs (\" @REVERSE_EDGE\", file);\n+\t  break;\n+\n+\tcase BALANCE_EDGE:\n+\t  fputs (\" @BALANCE_EDGE\", file);\n+\t  break;\n+\n+\tcase REDIRECT_NORMALIZED_EDGE:\n+\tcase REVERSE_NORMALIZED_EDGE:\n+\t  fputs (\"  @NORMALIZED_EDGE\", file);\n+\t  break;\n+\n+\tdefault:\n+\t  fputs (\" @INVALID_EDGE\", file);\n+\t  break;\n+\t}\n+    }\n+  fputs (\"\\n\", file);\n+}\n+\n+\n+/* Print out the edges and vertices of the given FIXUP_GRAPH, into the dump\n+   file. The input string MSG is printed out as a heading.  */\n+\n+static void\n+dump_fixup_graph (FILE *file, fixup_graph_type *fixup_graph, const char *msg)\n+{\n+  int i, j;\n+  int fnum_vertices, fnum_edges;\n+\n+  fixup_vertex_p fvertex_list, pfvertex;\n+  fixup_edge_p pfedge;\n+\n+  gcc_assert (fixup_graph);\n+  fvertex_list = fixup_graph->vertex_list;\n+  fnum_vertices = fixup_graph->num_vertices;\n+  fnum_edges = fixup_graph->num_edges;\n+\n+  fprintf (file, \"\\nDump fixup graph for %s(): %s.\\n\",\n+\t   lang_hooks.decl_printable_name (current_function_decl, 2), msg);\n+  fprintf (file,\n+\t   \"There are %d vertices and %d edges. new_exit_index is %d.\\n\\n\",\n+\t   fnum_vertices, fnum_edges, fixup_graph->new_exit_index);\n+\n+  for (i = 0; i < fnum_vertices; i++)\n+    {\n+      pfvertex = fvertex_list + i;\n+      fprintf (file, \"vertex_list[%d]: %d succ fixup edges.\\n\",\n+\t       i, VEC_length (fixup_edge_p, pfvertex->succ_edges));\n+\n+      for (j = 0; VEC_iterate (fixup_edge_p, pfvertex->succ_edges, j, pfedge);\n+\t   j++)\n+\t{\n+\t  /* Distinguish forward edges and backward edges in the residual flow\n+             network.  */\n+\t  if (pfedge->type)\n+\t    fputs (\"(f) \", file);\n+\t  else if (pfedge->is_rflow_valid)\n+\t    fputs (\"(b) \", file);\n+\t  dump_fixup_edge (file, fixup_graph, pfedge);\n+\t}\n+    }\n+\n+  fputs (\"\\n\", file);\n+}\n+\n+\n+/* Utility routines.  */\n+/* ln() implementation: approximate calculation. Returns ln of X.  */\n+\n+static double\n+mcf_ln (double x)\n+{\n+#define E       2.71828\n+  int l = 1;\n+  double m = E;\n+\n+  gcc_assert (x >= 0);\n+\n+  while (m < x)\n+    {\n+      m *= E;\n+      l++;\n+    }\n+\n+  return l;\n+}\n+\n+\n+/* sqrt() implementation: based on open source QUAKE3 code (magic sqrt\n+   implementation) by John Carmack.  Returns sqrt of X.  */\n+\n+static double\n+mcf_sqrt (double x)\n+{\n+#define MAGIC_CONST1    0x1fbcf800\n+#define MAGIC_CONST2    0x5f3759df\n+  union {\n+    int intPart;\n+    float floatPart;\n+  } convertor, convertor2;\n+\n+  gcc_assert (x >= 0);\n+\n+  convertor.floatPart = x;\n+  convertor2.floatPart = x;\n+  convertor.intPart = MAGIC_CONST1 + (convertor.intPart >> 1);\n+  convertor2.intPart = MAGIC_CONST2 - (convertor2.intPart >> 1);\n+\n+  return 0.5f * (convertor.floatPart + (x * convertor2.floatPart));\n+}\n+\n+\n+/* Common code shared between add_fixup_edge and add_rfixup_edge. Adds an edge\n+   (SRC->DEST) to the edge_list maintained in FIXUP_GRAPH with cost of the edge\n+   added set to COST.  */\n+\n+static fixup_edge_p\n+add_edge (fixup_graph_type *fixup_graph, int src, int dest, gcov_type cost)\n+{\n+  fixup_vertex_p curr_vertex = fixup_graph->vertex_list + src;\n+  fixup_edge_p curr_edge = fixup_graph->edge_list + fixup_graph->num_edges;\n+  curr_edge->src = src;\n+  curr_edge->dest = dest;\n+  curr_edge->cost = cost;\n+  fixup_graph->num_edges++;\n+  if (dump_file)\n+    dump_fixup_edge (dump_file, fixup_graph, curr_edge);\n+  VEC_safe_push (fixup_edge_p, heap, curr_vertex->succ_edges, curr_edge);\n+  return curr_edge;\n+}\n+\n+\n+/* Add a fixup edge (src->dest) with attributes TYPE, WEIGHT, COST and\n+   MAX_CAPACITY to the edge_list in the fixup graph.  */\n+\n+static void\n+add_fixup_edge (fixup_graph_type *fixup_graph, int src, int dest, int type,\n+\t\tgcov_type weight, gcov_type cost, gcov_type max_capacity)\n+{\n+  fixup_edge_p curr_edge = add_edge(fixup_graph, src, dest, cost);\n+  curr_edge->type = type;\n+  curr_edge->weight = weight;\n+  curr_edge->max_capacity = max_capacity;\n+}\n+\n+\n+/* Add a residual edge (SRC->DEST) with attributes RFLOW and COST\n+   to the fixup graph.  */\n+\n+static void\n+add_rfixup_edge (fixup_graph_type *fixup_graph, int src, int dest,\n+\t\t gcov_type rflow, gcov_type cost)\n+{\n+  fixup_edge_p curr_edge = add_edge (fixup_graph, src, dest, cost);\n+  curr_edge->rflow = rflow;\n+  curr_edge->is_rflow_valid = true;\n+  /* This edge is not a valid edge - merely used to hold residual flow.  */\n+  curr_edge->type = INVALID_EDGE;\n+}\n+\n+\n+/* Return the pointer to fixup edge SRC->DEST or NULL if edge does not\n+   exist in the FIXUP_GRAPH.  */\n+\n+static fixup_edge_p\n+find_fixup_edge (fixup_graph_type *fixup_graph, int src, int dest)\n+{\n+  int j;\n+  fixup_edge_p pfedge;\n+  fixup_vertex_p pfvertex;\n+\n+  gcc_assert (src < fixup_graph->num_vertices);\n+\n+  pfvertex = fixup_graph->vertex_list + src;\n+\n+  for (j = 0; VEC_iterate (fixup_edge_p, pfvertex->succ_edges, j, pfedge);\n+       j++)\n+    if (pfedge->dest == dest)\n+      return pfedge;\n+\n+  return NULL;\n+}\n+\n+\n+/* Cleanup routine to free structures in FIXUP_GRAPH.  */\n+\n+static void\n+delete_fixup_graph (fixup_graph_type *fixup_graph)\n+{\n+  int i;\n+  int fnum_vertices = fixup_graph->num_vertices;\n+  fixup_vertex_p pfvertex = fixup_graph->vertex_list;\n+\n+  for (i = 0; i < fnum_vertices; i++, pfvertex++)\n+    VEC_free (fixup_edge_p, heap, pfvertex->succ_edges);\n+\n+  free (fixup_graph->vertex_list);\n+  free (fixup_graph->edge_list);\n+}\n+\n+\n+/* Creates a fixup graph FIXUP_GRAPH from the function CFG.  */\n+\n+static void\n+create_fixup_graph (fixup_graph_type *fixup_graph)\n+{\n+  double sqrt_avg_vertex_weight = 0;\n+  double total_vertex_weight = 0;\n+  double k_pos = 0;\n+  double k_neg = 0;\n+  /* Vector to hold D(v) = sum_out_edges(v) - sum_in_edges(v).  */\n+  gcov_type *diff_out_in = NULL;\n+  gcov_type supply_value = 1, demand_value = 0;\n+  gcov_type fcost = 0;\n+  int new_entry_index = 0, new_exit_index = 0;\n+  int i = 0, j = 0;\n+  int new_index = 0;\n+  basic_block bb;\n+  edge e;\n+  edge_iterator ei;\n+  fixup_edge_p pfedge, r_pfedge;\n+  fixup_edge_p fedge_list;\n+  int fnum_edges;\n+\n+  /* Each basic_block will be split into 2 during vertex transformation.  */\n+  int fnum_vertices_after_transform =  2 * n_basic_blocks;\n+  int fnum_edges_after_transform = n_edges + n_basic_blocks;\n+\n+  /* Count the new SOURCE and EXIT vertices to be added.  */\n+  int fmax_num_vertices =\n+    fnum_vertices_after_transform + n_edges + n_basic_blocks + 2;\n+\n+  /* In create_fixup_graph: Each basic block and edge can be split into 3\n+     edges. Number of balance edges = n_basic_blocks. So after\n+     create_fixup_graph:\n+     max_edges = 4 * n_basic_blocks + 3 * n_edges\n+     Accounting for residual flow edges\n+     max_edges = 2 * (4 * n_basic_blocks + 3 * n_edges)\n+     = 8 * n_basic_blocks + 6 * n_edges\n+     < 8 * n_basic_blocks + 8 * n_edges.  */\n+  int fmax_num_edges = 8 * (n_basic_blocks + n_edges);\n+\n+  /* Initial num of vertices in the fixup graph.  */\n+  fixup_graph->num_vertices = n_basic_blocks;\n+\n+  /* Fixup graph vertex list.  */\n+  fixup_graph->vertex_list =\n+    (fixup_vertex_p) xcalloc (fmax_num_vertices, sizeof (fixup_vertex_type));\n+\n+  /* Fixup graph edge list.  */\n+  fixup_graph->edge_list =\n+    (fixup_edge_p) xcalloc (fmax_num_edges, sizeof (fixup_edge_type));\n+\n+  diff_out_in =\n+    (gcov_type *) xcalloc (1 + fnum_vertices_after_transform,\n+\t\t\t   sizeof (gcov_type));\n+\n+  /* Compute constants b, k_pos, k_neg used in the cost function calculation.\n+     b = sqrt(avg_vertex_weight(cfg)); k_pos = b; k_neg = 50b.  */\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n+    total_vertex_weight += bb->count;\n+\n+  sqrt_avg_vertex_weight = mcf_sqrt (total_vertex_weight / n_basic_blocks);\n+\n+  k_pos = K_POS (sqrt_avg_vertex_weight);\n+  k_neg = K_NEG (sqrt_avg_vertex_weight);\n+\n+  /* 1. Vertex Transformation: Split each vertex v into two vertices v' and v'',\n+     connected by an edge e from v' to v''. w(e) = w(v).  */\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"\\nVertex transformation:\\n\");\n+\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n+  {\n+    /* v'->v'': index1->(index1+1).  */\n+    i = 2 * bb->index;\n+    fcost = (gcov_type) COST (k_pos, bb->count);\n+    add_fixup_edge (fixup_graph, i, i + 1, VERTEX_SPLIT_EDGE, bb->count,\n+                    fcost, CAP_INFINITY);\n+    fixup_graph->num_vertices++;\n+\n+    FOR_EACH_EDGE (e, ei, bb->succs)\n+    {\n+      /* Edges with ignore attribute set should be treated like they don't\n+         exist.  */\n+      if (EDGE_INFO (e) && EDGE_INFO (e)->ignore)\n+        continue;\n+      j = 2 * e->dest->index;\n+      fcost = (gcov_type) COST (k_pos, e->count);\n+      add_fixup_edge (fixup_graph, i + 1, j, REDIRECT_EDGE, e->count, fcost,\n+                      CAP_INFINITY);\n+    }\n+  }\n+\n+  /* After vertex transformation.  */\n+  gcc_assert (fixup_graph->num_vertices == fnum_vertices_after_transform);\n+  /* Redirect edges are not added for edges with ignore attribute.  */\n+  gcc_assert (fixup_graph->num_edges <= fnum_edges_after_transform);\n+\n+  fnum_edges_after_transform = fixup_graph->num_edges;\n+\n+  /* 2. Initialize D(v).  */\n+  for (i = 0; i < fnum_edges_after_transform; i++)\n+    {\n+      pfedge = fixup_graph->edge_list + i;\n+      diff_out_in[pfedge->src] += pfedge->weight;\n+      diff_out_in[pfedge->dest] -= pfedge->weight;\n+    }\n+\n+  /* Entry block - vertex indices 0, 1; EXIT block - vertex indices 2, 3.  */\n+  for (i = 0; i <= 3; i++)\n+    diff_out_in[i] = 0;\n+\n+  /* 3. Add reverse edges: needed to decrease counts during smoothing.  */\n+  if (dump_file)\n+    fprintf (dump_file, \"\\nReverse edges:\\n\");\n+  for (i = 0; i < fnum_edges_after_transform; i++)\n+    {\n+      pfedge = fixup_graph->edge_list + i;\n+      if ((pfedge->src == 0) || (pfedge->src == 2))\n+        continue;\n+      r_pfedge = find_fixup_edge (fixup_graph, pfedge->dest, pfedge->src);\n+      if (!r_pfedge && pfedge->weight)\n+\t{\n+\t  /* Skip adding reverse edges for edges with w(e) = 0, as its maximum\n+\t     capacity is 0.  */\n+\t  fcost = (gcov_type) COST (k_neg, pfedge->weight);\n+\t  add_fixup_edge (fixup_graph, pfedge->dest, pfedge->src,\n+\t\t\t  REVERSE_EDGE, 0, fcost, pfedge->weight);\n+\t}\n+    }\n+\n+  /* 4. Create single source and sink. Connect new source vertex s' to function\n+     entry block. Connect sink vertex t' to function exit.  */\n+  if (dump_file)\n+    fprintf (dump_file, \"\\ns'->S, T->t':\\n\");\n+\n+  new_entry_index = fixup_graph->new_entry_index = fixup_graph->num_vertices;\n+  fixup_graph->num_vertices++;\n+  /* Set supply_value to 1 to avoid zero count function ENTRY.  */\n+  add_fixup_edge (fixup_graph, new_entry_index, ENTRY_BLOCK, SOURCE_CONNECT_EDGE,\n+\t\t  1 /* supply_value */, 0, 1 /* supply_value */);\n+\n+  /* Create new exit with EXIT_BLOCK as single pred.  */\n+  new_exit_index = fixup_graph->new_exit_index = fixup_graph->num_vertices;\n+  fixup_graph->num_vertices++;\n+  add_fixup_edge (fixup_graph, 2 * EXIT_BLOCK + 1, new_exit_index,\n+                  SINK_CONNECT_EDGE,\n+                  0 /* demand_value */, 0, 0 /* demand_value */);\n+\n+  /* Connect vertices with unbalanced D(v) to source/sink.  */\n+  if (dump_file)\n+    fprintf (dump_file, \"\\nD(v) balance:\\n\");\n+  /* Skip vertices for ENTRY (0, 1) and EXIT (2,3) blocks, so start with i = 4.\n+     diff_out_in[v''] will be 0, so skip v'' vertices, hence i += 2.  */\n+  for (i = 4; i < new_entry_index; i += 2)\n+    {\n+      if (diff_out_in[i] > 0)\n+\t{\n+\t  add_fixup_edge (fixup_graph, i, new_exit_index, BALANCE_EDGE, 0, 0,\n+\t\t\t  diff_out_in[i]);\n+\t  demand_value += diff_out_in[i];\n+\t}\n+      else if (diff_out_in[i] < 0)\n+\t{\n+\t  add_fixup_edge (fixup_graph, new_entry_index, i, BALANCE_EDGE, 0, 0,\n+\t\t\t  -diff_out_in[i]);\n+\t  supply_value -= diff_out_in[i];\n+\t}\n+    }\n+\n+  /* Set supply = demand.  */\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\nAdjust supply and demand:\\n\");\n+      fprintf (dump_file, \"supply_value=\" HOST_WIDEST_INT_PRINT_DEC \"\\n\",\n+\t       supply_value);\n+      fprintf (dump_file, \"demand_value=\" HOST_WIDEST_INT_PRINT_DEC \"\\n\",\n+\t       demand_value);\n+    }\n+\n+  if (demand_value > supply_value)\n+    {\n+      pfedge = find_fixup_edge (fixup_graph, new_entry_index, ENTRY_BLOCK);\n+      pfedge->max_capacity += (demand_value - supply_value);\n+    }\n+  else\n+    {\n+      pfedge = find_fixup_edge (fixup_graph, 2 * EXIT_BLOCK + 1, new_exit_index);\n+      pfedge->max_capacity += (supply_value - demand_value);\n+    }\n+\n+  /* 6. Normalize edges: remove anti-parallel edges. Anti-parallel edges are\n+     created by the vertex transformation step from self-edges in the original\n+     CFG and by the reverse edges added earlier.  */\n+  if (dump_file)\n+    fprintf (dump_file, \"\\nNormalize edges:\\n\");\n+\n+  fnum_edges = fixup_graph->num_edges;\n+  fedge_list = fixup_graph->edge_list;\n+\n+  for (i = 0; i < fnum_edges; i++)\n+    {\n+      pfedge = fedge_list + i;\n+      r_pfedge = find_fixup_edge (fixup_graph, pfedge->dest, pfedge->src);\n+      if (((pfedge->type == VERTEX_SPLIT_EDGE)\n+\t   || (pfedge->type == REDIRECT_EDGE)) && r_pfedge)\n+\t{\n+\t  new_index = fixup_graph->num_vertices;\n+\t  fixup_graph->num_vertices++;\n+\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \"\\nAnti-parallel edge:\\n\");\n+\t      dump_fixup_edge (dump_file, fixup_graph, pfedge);\n+\t      dump_fixup_edge (dump_file, fixup_graph, r_pfedge);\n+\t      fprintf (dump_file, \"New vertex is %d.\\n\", new_index);\n+\t      fprintf (dump_file, \"------------------\\n\");\n+\t    }\n+\n+\t  pfedge->cost /= 2;\n+\t  pfedge->norm_vertex_index = new_index;\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \"After normalization:\\n\");\n+\t      dump_fixup_edge (dump_file, fixup_graph, pfedge);\n+\t    }\n+\n+\t  /* Add a new fixup edge: new_index->src.  */\n+\t  add_fixup_edge (fixup_graph, new_index, pfedge->src,\n+\t\t\t  REVERSE_NORMALIZED_EDGE, 0, r_pfedge->cost,\n+\t\t\t  r_pfedge->max_capacity);\n+\t  gcc_assert (fixup_graph->num_vertices <= fmax_num_vertices);\n+\n+\t  /* Edge: r_pfedge->src -> r_pfedge->dest\n+             ==> r_pfedge->src -> new_index.  */\n+\t  r_pfedge->dest = new_index;\n+\t  r_pfedge->type = REVERSE_NORMALIZED_EDGE;\n+\t  r_pfedge->cost = pfedge->cost;\n+\t  r_pfedge->max_capacity = pfedge->max_capacity;\n+\t  if (dump_file)\n+\t    dump_fixup_edge (dump_file, fixup_graph, r_pfedge);\n+\t}\n+    }\n+\n+  if (dump_file)\n+    dump_fixup_graph (dump_file, fixup_graph, \"After create_fixup_graph()\");\n+\n+  /* Cleanup.  */\n+  free (diff_out_in);\n+}\n+\n+\n+/* Allocates space for the structures in AUGMENTING_PATH.  The space needed is\n+   proportional to the number of nodes in the graph, which is given by\n+   GRAPH_SIZE.  */\n+\n+static void\n+init_augmenting_path (augmenting_path_type *augmenting_path, int graph_size)\n+{\n+  augmenting_path->queue_list.queue = (int *)\n+    xcalloc (graph_size + 2, sizeof (int));\n+  augmenting_path->queue_list.size = graph_size + 2;\n+  augmenting_path->bb_pred = (int *) xcalloc (graph_size, sizeof (int));\n+  augmenting_path->is_visited = (int *) xcalloc (graph_size, sizeof (int));\n+}\n+\n+/* Free the structures in AUGMENTING_PATH.  */\n+static void\n+free_augmenting_path (augmenting_path_type *augmenting_path)\n+{\n+  free (augmenting_path->queue_list.queue);\n+  free (augmenting_path->bb_pred);\n+  free (augmenting_path->is_visited);\n+}\n+\n+\n+/* Queue routines. Assumes queue will never overflow.  */\n+\n+static void\n+init_queue (queue_type *queue_list)\n+{\n+  gcc_assert (queue_list);\n+  queue_list->head = 0;\n+  queue_list->tail = 0;\n+}\n+\n+/* Return true if QUEUE_LIST is empty.  */\n+static bool\n+is_empty (queue_type *queue_list)\n+{\n+  return (queue_list->head == queue_list->tail);\n+}\n+\n+/* Insert element X into QUEUE_LIST.  */\n+static void\n+enqueue (queue_type *queue_list, int x)\n+{\n+  gcc_assert (queue_list->tail < queue_list->size);\n+  queue_list->queue[queue_list->tail] = x;\n+  (queue_list->tail)++;\n+}\n+\n+/* Return the first element in QUEUE_LIST.  */\n+static int\n+dequeue (queue_type *queue_list)\n+{\n+  int x;\n+  gcc_assert (queue_list->head >= 0);\n+  x = queue_list->queue[queue_list->head];\n+  (queue_list->head)++;\n+  return x;\n+}\n+\n+\n+/* Finds a negative cycle in the residual network using\n+   the Bellman-Ford algorithm. The flow on the found cycle is reversed by the\n+   minimum residual capacity of that cycle. ENTRY and EXIT vertices are not\n+   considered.\n+\n+Parameters:\n+   FIXUP_GRAPH - Residual graph  (input/output)\n+   The following are allocated/freed by the caller:\n+   PI - Vector to hold predecessors in path  (pi = pred index)\n+   D - D[I] holds minimum cost of path from i to sink\n+   CYCLE - Vector to hold the minimum cost cycle\n+\n+Return:\n+   true if a negative cycle was found, false otherwise.  */\n+\n+static bool\n+cancel_negative_cycle (fixup_graph_type *fixup_graph,\n+\t\t       int *pi, gcov_type *d, int *cycle)\n+{\n+  int i, j, k;\n+  int fnum_vertices, fnum_edges;\n+  fixup_edge_p fedge_list, pfedge, r_pfedge;\n+  bool found_cycle = false;\n+  int cycle_start = 0, cycle_end = 0;\n+  gcov_type sum_cost = 0, cycle_flow = 0;\n+  int new_entry_index;\n+  bool propagated = false;\n+\n+  gcc_assert (fixup_graph);\n+  fnum_vertices = fixup_graph->num_vertices;\n+  fnum_edges = fixup_graph->num_edges;\n+  fedge_list = fixup_graph->edge_list;\n+  new_entry_index = fixup_graph->new_entry_index;\n+\n+  /* Initialize.  */\n+  /* Skip ENTRY.  */\n+  for (i = 1; i < fnum_vertices; i++)\n+    {\n+      d[i] = CAP_INFINITY;\n+      pi[i] = -1;\n+      cycle[i] = -1;\n+    }\n+  d[ENTRY_BLOCK] = 0;\n+\n+  /* Relax.  */\n+  for (k = 1; k < fnum_vertices; k++)\n+  {\n+    propagated = false;\n+    for (i = 0; i < fnum_edges; i++)\n+      {\n+\tpfedge = fedge_list + i;\n+\tif (pfedge->src == new_entry_index)\n+\t  continue;\n+\tif (pfedge->is_rflow_valid && pfedge->rflow\n+            && d[pfedge->src] != CAP_INFINITY\n+\t    && (d[pfedge->dest] > d[pfedge->src] + pfedge->cost))\n+\t  {\n+\t    d[pfedge->dest] = d[pfedge->src] + pfedge->cost;\n+\t    pi[pfedge->dest] = pfedge->src;\n+            propagated = true;\n+\t  }\n+      }\n+    if (!propagated)\n+      break;\n+  }\n+\n+  if (!propagated)\n+  /* No negative cycles exist.  */\n+    return 0;\n+\n+  /* Detect.  */\n+  for (i = 0; i < fnum_edges; i++)\n+    {\n+      pfedge = fedge_list + i;\n+      if (pfedge->src == new_entry_index)\n+\tcontinue;\n+      if (pfedge->is_rflow_valid && pfedge->rflow\n+          && d[pfedge->src] != CAP_INFINITY\n+\t  && (d[pfedge->dest] > d[pfedge->src] + pfedge->cost))\n+\t{\n+\t  found_cycle = true;\n+\t  break;\n+\t}\n+    }\n+\n+  if (!found_cycle)\n+    return 0;\n+\n+  /* Augment the cycle with the cycle's minimum residual capacity.  */\n+  found_cycle = false;\n+  cycle[0] = pfedge->dest;\n+  j = pfedge->dest;\n+\n+  for (i = 1; i < fnum_vertices; i++)\n+    {\n+      j = pi[j];\n+      cycle[i] = j;\n+      for (k = 0; k < i; k++)\n+\t{\n+\t  if (cycle[k] == j)\n+\t    {\n+\t      /* cycle[k] -> ... -> cycle[i].  */\n+\t      cycle_start = k;\n+\t      cycle_end = i;\n+\t      found_cycle = true;\n+\t      break;\n+\t    }\n+\t}\n+      if (found_cycle)\n+\tbreak;\n+    }\n+\n+  gcc_assert (cycle[cycle_start] == cycle[cycle_end]);\n+  if (dump_file)\n+    fprintf (dump_file, \"\\nNegative cycle length is %d:\\n\",\n+\t     cycle_end - cycle_start);\n+\n+  sum_cost = 0;\n+  cycle_flow = CAP_INFINITY;\n+  for (k = cycle_start; k < cycle_end; k++)\n+    {\n+      pfedge = find_fixup_edge (fixup_graph, cycle[k + 1], cycle[k]);\n+      cycle_flow = MIN (cycle_flow, pfedge->rflow);\n+      sum_cost += pfedge->cost;\n+      if (dump_file)\n+\tfprintf (dump_file, \"%d \", cycle[k]);\n+    }\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"%d\", cycle[k]);\n+      fprintf (dump_file,\n+\t       \": (\" HOST_WIDEST_INT_PRINT_DEC \", \" HOST_WIDEST_INT_PRINT_DEC\n+\t       \")\\n\", sum_cost, cycle_flow);\n+      fprintf (dump_file,\n+\t       \"Augment cycle with \" HOST_WIDEST_INT_PRINT_DEC \"\\n\",\n+\t       cycle_flow);\n+    }\n+\n+  for (k = cycle_start; k < cycle_end; k++)\n+    {\n+      pfedge = find_fixup_edge (fixup_graph, cycle[k + 1], cycle[k]);\n+      r_pfedge = find_fixup_edge (fixup_graph, cycle[k], cycle[k + 1]);\n+      pfedge->rflow -= cycle_flow;\n+      if (pfedge->type)\n+\tpfedge->flow += cycle_flow;\n+      r_pfedge->rflow += cycle_flow;\n+      if (r_pfedge->type)\n+\tr_pfedge->flow -= cycle_flow;\n+    }\n+\n+  return true;\n+}\n+\n+\n+/* Computes the residual flow for FIXUP_GRAPH by setting the rflow field of\n+   the edges. ENTRY and EXIT vertices should not be considered.  */\n+\n+static void\n+compute_residual_flow (fixup_graph_type *fixup_graph)\n+{\n+  int i;\n+  int fnum_edges;\n+  fixup_edge_p fedge_list, pfedge;\n+\n+  gcc_assert (fixup_graph);\n+\n+  if (dump_file)\n+    fputs (\"\\ncompute_residual_flow():\\n\", dump_file);\n+\n+  fnum_edges = fixup_graph->num_edges;\n+  fedge_list = fixup_graph->edge_list;\n+\n+  for (i = 0; i < fnum_edges; i++)\n+    {\n+      pfedge = fedge_list + i;\n+      pfedge->rflow = pfedge->max_capacity - pfedge->flow;\n+      pfedge->is_rflow_valid = true;\n+      add_rfixup_edge (fixup_graph, pfedge->dest, pfedge->src, pfedge->flow,\n+\t\t       -pfedge->cost);\n+    }\n+}\n+\n+\n+/* Uses Edmonds-Karp algorithm - BFS to find augmenting path from SOURCE to\n+   SINK. The fields in the edge vector in the FIXUP_GRAPH are not modified by\n+   this routine. The vector bb_pred in the AUGMENTING_PATH structure is updated\n+   to reflect the path found.\n+   Returns: 0 if no augmenting path is found, 1 otherwise.  */\n+\n+static int\n+find_augmenting_path (fixup_graph_type *fixup_graph,\n+\t\t      augmenting_path_type *augmenting_path, int source,\n+\t\t      int sink)\n+{\n+  int u = 0;\n+  int i;\n+  fixup_vertex_p fvertex_list, pfvertex;\n+  fixup_edge_p pfedge;\n+  int *bb_pred, *is_visited;\n+  queue_type *queue_list;\n+\n+  gcc_assert (augmenting_path);\n+  bb_pred = augmenting_path->bb_pred;\n+  gcc_assert (bb_pred);\n+  is_visited = augmenting_path->is_visited;\n+  gcc_assert (is_visited);\n+  queue_list = &(augmenting_path->queue_list);\n+\n+  gcc_assert (fixup_graph);\n+\n+  fvertex_list = fixup_graph->vertex_list;\n+\n+  for (u = 0; u < fixup_graph->num_vertices; u++)\n+    is_visited[u] = 0;\n+\n+  init_queue (queue_list);\n+  enqueue (queue_list, source);\n+  bb_pred[source] = -1;\n+\n+  while (!is_empty (queue_list))\n+    {\n+      u = dequeue (queue_list);\n+      is_visited[u] = 1;\n+      pfvertex = fvertex_list + u;\n+      for (i = 0; VEC_iterate (fixup_edge_p, pfvertex->succ_edges, i, pfedge);\n+\t   i++)\n+\t{\n+\t  int dest = pfedge->dest;\n+\t  if ((pfedge->rflow > 0) && (is_visited[dest] == 0))\n+\t    {\n+\t      enqueue (queue_list, dest);\n+\t      bb_pred[dest] = u;\n+\t      is_visited[dest] = 1;\n+\t      if (dest == sink)\n+\t\treturn 1;\n+\t    }\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n+\n+/* Routine to find the maximal flow:\n+   Algorithm:\n+   1. Initialize flow to 0\n+   2. Find an augmenting path form source to sink.\n+   3. Send flow equal to the path's residual capacity along the edges of this path.\n+   4. Repeat steps 2 and 3 until no new augmenting path is found.\n+   \n+Parameters:\n+SOURCE: index of source vertex (input)\n+SINK: index of sink vertex    (input)\n+FIXUP_GRAPH: adjacency matrix representing the graph. The flow of the edges will be\n+             set to have a valid maximal flow by this routine. (input)\n+Return: Maximum flow possible.  */\n+\n+static gcov_type\n+find_max_flow (fixup_graph_type *fixup_graph, int source, int sink)\n+{\n+  int fnum_edges;\n+  augmenting_path_type augmenting_path;\n+  int *bb_pred;\n+  gcov_type max_flow = 0;\n+  int i, u;\n+  fixup_edge_p fedge_list, pfedge, r_pfedge;\n+\n+  gcc_assert (fixup_graph);\n+\n+  fnum_edges = fixup_graph->num_edges;\n+  fedge_list = fixup_graph->edge_list;\n+\n+  /* Initialize flow to 0.  */\n+  for (i = 0; i < fnum_edges; i++)\n+    {\n+      pfedge = fedge_list + i;\n+      pfedge->flow = 0;\n+    }\n+\n+  compute_residual_flow (fixup_graph);\n+\n+  init_augmenting_path (&augmenting_path, fixup_graph->num_vertices);\n+\n+  bb_pred = augmenting_path.bb_pred;\n+  while (find_augmenting_path (fixup_graph, &augmenting_path, source, sink))\n+    {\n+      /* Determine the amount by which we can increment the flow.  */\n+      gcov_type increment = CAP_INFINITY;\n+      for (u = sink; u != source; u = bb_pred[u])\n+\t{\n+\t  pfedge = find_fixup_edge (fixup_graph, bb_pred[u], u);\n+\t  increment = MIN (increment, pfedge->rflow);\n+\t}\n+      max_flow += increment;\n+\n+      /* Now increment the flow. EXIT vertex index is 1.  */\n+      for (u = sink; u != source; u = bb_pred[u])\n+\t{\n+\t  pfedge = find_fixup_edge (fixup_graph, bb_pred[u], u);\n+\t  r_pfedge = find_fixup_edge (fixup_graph, u, bb_pred[u]);\n+\t  if (pfedge->type)\n+\t    {\n+\t      /* forward edge.  */\n+\t      pfedge->flow += increment;\n+\t      pfedge->rflow -= increment;\n+\t      r_pfedge->rflow += increment;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* backward edge.  */\n+\t      gcc_assert (r_pfedge->type);\n+\t      r_pfedge->rflow += increment;\n+\t      r_pfedge->flow -= increment;\n+\t      pfedge->rflow -= increment;\n+\t    }\n+\t}\n+\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"\\nDump augmenting path:\\n\");\n+\t  for (u = sink; u != source; u = bb_pred[u])\n+\t    {\n+\t      print_basic_block (dump_file, fixup_graph, u);\n+\t      fprintf (dump_file, \"<-\");\n+\t    }\n+\t  fprintf (dump_file,\n+\t\t   \"ENTRY  (path_capacity=\" HOST_WIDEST_INT_PRINT_DEC \")\\n\",\n+\t\t   increment);\n+\t  fprintf (dump_file,\n+\t\t   \"Network flow is \" HOST_WIDEST_INT_PRINT_DEC \".\\n\",\n+\t\t   max_flow);\n+\t}\n+    }\n+\n+  free_augmenting_path (&augmenting_path);\n+  if (dump_file)\n+    dump_fixup_graph (dump_file, fixup_graph, \"After find_max_flow()\");\n+  return max_flow;\n+}\n+\n+\n+/* Computes the corrected edge and basic block weights using FIXUP_GRAPH\n+   after applying the find_minimum_cost_flow() routine.  */\n+\n+static void\n+adjust_cfg_counts (fixup_graph_type *fixup_graph)\n+{\n+  basic_block bb;\n+  edge e;\n+  edge_iterator ei;\n+  int i, j;\n+  fixup_edge_p pfedge, pfedge_n;\n+\n+  gcc_assert (fixup_graph);\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"\\nadjust_cfg_counts():\\n\");\n+\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n+    {\n+      i = 2 * bb->index;\n+\n+      /* Fixup BB.  */\n+      if (dump_file)\n+        fprintf (dump_file,\n+                 \"BB%d: \" HOST_WIDEST_INT_PRINT_DEC \"\", bb->index, bb->count);\n+\n+      pfedge = find_fixup_edge (fixup_graph, i, i + 1);\n+      if (pfedge->flow)\n+        {\n+          bb->count += pfedge->flow;\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \" + \" HOST_WIDEST_INT_PRINT_DEC \"(\",\n+\t               pfedge->flow);\n+\t      print_edge (dump_file, fixup_graph, i, i + 1);\n+\t      fprintf (dump_file, \")\");\n+\t    }\n+        }\n+\n+      pfedge_n =\n+        find_fixup_edge (fixup_graph, i + 1, pfedge->norm_vertex_index);\n+      /* Deduct flow from normalized reverse edge.  */\n+      if (pfedge->norm_vertex_index && pfedge_n->flow)\n+        {\n+          bb->count -= pfedge_n->flow;\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \" - \" HOST_WIDEST_INT_PRINT_DEC \"(\",\n+\t\t       pfedge_n->flow);\n+\t      print_edge (dump_file, fixup_graph, i + 1,\n+\t\t\t  pfedge->norm_vertex_index);\n+\t      fprintf (dump_file, \")\");\n+\t    }\n+        }\n+      if (dump_file)\n+        fprintf (dump_file, \" = \" HOST_WIDEST_INT_PRINT_DEC \"\\n\", bb->count);\n+\n+      /* Fixup edge.  */\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+        {\n+          /* Treat edges with ignore attribute set as if they don't exist.  */\n+          if (EDGE_INFO (e) && EDGE_INFO (e)->ignore)\n+\t    continue;\n+\n+          j = 2 * e->dest->index;\n+          if (dump_file)\n+\t    fprintf (dump_file, \"%d->%d: \" HOST_WIDEST_INT_PRINT_DEC \"\",\n+\t\t     bb->index, e->dest->index, e->count);\n+\n+          pfedge = find_fixup_edge (fixup_graph, i + 1, j);\n+\n+          if (bb->index != e->dest->index)\n+\t    {\n+\t      /* Non-self edge.  */\n+\t      if (pfedge->flow)\n+\t        {\n+\t          e->count += pfedge->flow;\n+\t          if (dump_file)\n+\t\t    {\n+\t\t      fprintf (dump_file, \" + \" HOST_WIDEST_INT_PRINT_DEC \"(\",\n+\t\t\t       pfedge->flow);\n+\t\t      print_edge (dump_file, fixup_graph, i + 1, j);\n+\t\t      fprintf (dump_file, \")\");\n+\t\t    }\n+\t        }\n+\n+\t      pfedge_n =\n+\t        find_fixup_edge (fixup_graph, j, pfedge->norm_vertex_index);\n+\t      /* Deduct flow from normalized reverse edge.  */\n+\t      if (pfedge->norm_vertex_index && pfedge_n->flow)\n+\t        {\n+\t          e->count -= pfedge_n->flow;\n+\t          if (dump_file)\n+\t\t    {\n+\t\t      fprintf (dump_file, \" - \" HOST_WIDEST_INT_PRINT_DEC \"(\",\n+\t\t\t       pfedge_n->flow);\n+\t\t      print_edge (dump_file, fixup_graph, j,\n+\t\t\t          pfedge->norm_vertex_index);\n+\t\t      fprintf (dump_file, \")\");\n+\t\t    }\n+\t        }\n+\t    }\n+          else\n+\t    {\n+\t      /* Handle self edges. Self edge is split with a normalization\n+                 vertex. Here i=j.  */\n+\t      pfedge = find_fixup_edge (fixup_graph, j, i + 1);\n+\t      pfedge_n =\n+\t        find_fixup_edge (fixup_graph, i + 1, pfedge->norm_vertex_index);\n+\t      e->count += pfedge_n->flow;\n+\t      bb->count += pfedge_n->flow;\n+\t      if (dump_file)\n+\t        {\n+\t          fprintf (dump_file, \"(self edge)\");\n+\t          fprintf (dump_file, \" + \" HOST_WIDEST_INT_PRINT_DEC \"(\",\n+\t\t           pfedge_n->flow);\n+\t          print_edge (dump_file, fixup_graph, i + 1,\n+\t\t\t      pfedge->norm_vertex_index);\n+\t          fprintf (dump_file, \")\");\n+\t        }\n+\t    }\n+\n+          if (bb->count)\n+\t    e->probability = REG_BR_PROB_BASE * e->count / bb->count;\n+          if (dump_file)\n+\t    fprintf (dump_file, \" = \" HOST_WIDEST_INT_PRINT_DEC \"\\t(%.1f%%)\\n\",\n+\t\t     e->count, e->probability * 100.0 / REG_BR_PROB_BASE);\n+        }\n+    } \n+\n+  ENTRY_BLOCK_PTR->count = sum_edge_counts (ENTRY_BLOCK_PTR->succs); \n+  EXIT_BLOCK_PTR->count = sum_edge_counts (EXIT_BLOCK_PTR->preds);\n+\n+  /* Compute edge probabilities.  */\n+  FOR_ALL_BB (bb)\n+    {\n+      if (bb->count)\n+        {\n+          FOR_EACH_EDGE (e, ei, bb->succs)\n+            e->probability = REG_BR_PROB_BASE * e->count / bb->count;\n+        }\n+      else\n+        {\n+          int total = 0;\n+          FOR_EACH_EDGE (e, ei, bb->succs)\n+            if (!(e->flags & (EDGE_COMPLEX | EDGE_FAKE)))\n+              total++;\n+          if (total)\n+            {\n+              FOR_EACH_EDGE (e, ei, bb->succs)\n+                {\n+                  if (!(e->flags & (EDGE_COMPLEX | EDGE_FAKE)))\n+                    e->probability = REG_BR_PROB_BASE / total;\n+                  else\n+                    e->probability = 0;\n+                }\n+            }\n+          else\n+            {\n+              total += EDGE_COUNT (bb->succs);\n+              FOR_EACH_EDGE (e, ei, bb->succs)\n+                  e->probability = REG_BR_PROB_BASE / total;\n+            }\n+        }\n+    }\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\nCheck %s() CFG flow conservation:\\n\",\n+           lang_hooks.decl_printable_name (current_function_decl, 2));\n+      FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR->next_bb, EXIT_BLOCK_PTR, next_bb)\n+        {\n+          if ((bb->count != sum_edge_counts (bb->preds))\n+               || (bb->count != sum_edge_counts (bb->succs)))\n+            {\n+              fprintf (dump_file,\n+                       \"BB%d(\" HOST_WIDEST_INT_PRINT_DEC \")  **INVALID**: \",\n+                       bb->index, bb->count);\n+              fprintf (stderr,\n+                       \"******** BB%d(\" HOST_WIDEST_INT_PRINT_DEC\n+                       \")  **INVALID**: \\n\", bb->index, bb->count);\n+              fprintf (dump_file, \"in_edges=\" HOST_WIDEST_INT_PRINT_DEC \" \",\n+                       sum_edge_counts (bb->preds));\n+              fprintf (dump_file, \"out_edges=\" HOST_WIDEST_INT_PRINT_DEC \"\\n\",\n+                       sum_edge_counts (bb->succs));\n+            }\n+         }\n+    }\n+}\n+\n+\n+/* Implements the negative cycle canceling algorithm to compute a minimum cost\n+   flow.\n+Algorithm:\n+1. Find maximal flow.\n+2. Form residual network\n+3. Repeat:\n+  While G contains a negative cost cycle C, reverse the flow on the found cycle\n+  by the minimum residual capacity in that cycle.\n+4. Form the minimal cost flow\n+  f(u,v) = rf(v, u)\n+Input:\n+  FIXUP_GRAPH - Initial fixup graph.\n+  The flow field is modified to represent the minimum cost flow.  */\n+\n+static void\n+find_minimum_cost_flow (fixup_graph_type *fixup_graph)\n+{\n+  /* Holds the index of predecessor in path.  */\n+  int *pred;\n+  /* Used to hold the minimum cost cycle.  */\n+  int *cycle;\n+  /* Used to record the number of iterations of cancel_negative_cycle.  */\n+  int iteration;\n+  /* Vector d[i] holds the minimum cost of path from i to sink.  */\n+  gcov_type *d;\n+  int fnum_vertices;\n+  int new_exit_index;\n+  int new_entry_index;\n+\n+  gcc_assert (fixup_graph);\n+  fnum_vertices = fixup_graph->num_vertices;\n+  new_exit_index = fixup_graph->new_exit_index;\n+  new_entry_index = fixup_graph->new_entry_index;\n+\n+  find_max_flow (fixup_graph, new_entry_index, new_exit_index);\n+\n+  /* Initialize the structures for find_negative_cycle().  */\n+  pred = (int *) xcalloc (fnum_vertices, sizeof (int));\n+  d = (gcov_type *) xcalloc (fnum_vertices, sizeof (gcov_type));\n+  cycle = (int *) xcalloc (fnum_vertices, sizeof (int));\n+\n+  /* Repeatedly find and cancel negative cost cycles, until\n+     no more negative cycles exist. This also updates the flow field\n+     to represent the minimum cost flow so far.  */\n+  iteration = 0;\n+  while (cancel_negative_cycle (fixup_graph, pred, d, cycle))\n+    {\n+      iteration++;\n+      if (iteration > MAX_ITER (fixup_graph->num_vertices,\n+                                fixup_graph->num_edges))\n+        break;\n+    }\n+\n+  if (dump_file)\n+    dump_fixup_graph (dump_file, fixup_graph,\n+\t\t      \"After find_minimum_cost_flow()\");\n+\n+  /* Cleanup structures.  */\n+  free (pred);\n+  free (d);\n+  free (cycle);\n+}\n+\n+\n+/* Compute the sum of the edge counts in TO_EDGES.  */\n+\n+gcov_type\n+sum_edge_counts (VEC (edge, gc) *to_edges)\n+{\n+  gcov_type sum = 0;\n+  edge e;\n+  edge_iterator ei;\n+\n+  FOR_EACH_EDGE (e, ei, to_edges)\n+    {\n+      if (EDGE_INFO (e) && EDGE_INFO (e)->ignore)\n+        continue;\n+      sum += e->count;\n+    }\n+  return sum;\n+}\n+\n+\n+/* Main routine. Smoothes the intial assigned basic block and edge counts using\n+   a minimum cost flow algorithm, to ensure that the flow consistency rule is\n+   obeyed: sum of outgoing edges = sum of incoming edges for each basic\n+   block.  */\n+\n+void\n+mcf_smooth_cfg (void)\n+{\n+  fixup_graph_type fixup_graph;\n+  memset (&fixup_graph, 0, sizeof (fixup_graph));\n+  create_fixup_graph (&fixup_graph);\n+  find_minimum_cost_flow (&fixup_graph);\n+  adjust_cfg_counts (&fixup_graph);\n+  delete_fixup_graph (&fixup_graph);\n+}"}]}