{"sha": "3ea109a3479cdbbe8a47bf60b2d2d69072a1d51b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2VhMTA5YTM0NzljZGJiZThhNDdiZjYwYjJkMmQ2OTA3MmExZDUxYg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-02T18:25:45Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-02T18:25:45Z"}, "message": "The vec_perm code falls back to doing byte-level permutes if element-level permutes aren't supported.\n\nqimode_for_vec_perm\n\nThe vec_perm code falls back to doing byte-level permutes if\nelement-level permutes aren't supported.  There were two copies\nof the code to calculate the mode, and later patches add another,\nso this patch splits it out into a helper function.\n\n2018-01-02  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* optabs-query.h (qimode_for_vec_perm): Declare.\n\t* optabs-query.c (can_vec_perm_p): Split out qimode search to...\n\t(qimode_for_vec_perm): ...this new function.\n\t* optabs.c (expand_vec_perm): Use qimode_for_vec_perm.\n\nFrom-SVN: r256089", "tree": {"sha": "97ee41fba95472080036586c5de1b5d4ed707397", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/97ee41fba95472080036586c5de1b5d4ed707397"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ea109a3479cdbbe8a47bf60b2d2d69072a1d51b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ea109a3479cdbbe8a47bf60b2d2d69072a1d51b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ea109a3479cdbbe8a47bf60b2d2d69072a1d51b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ea109a3479cdbbe8a47bf60b2d2d69072a1d51b/comments", "author": null, "committer": null, "parents": [{"sha": "a1d6c05238093d4de85dc18f825ba4f5e3a5746c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1d6c05238093d4de85dc18f825ba4f5e3a5746c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1d6c05238093d4de85dc18f825ba4f5e3a5746c"}], "stats": {"total": 32, "additions": 26, "deletions": 6}, "files": [{"sha": "60bbfbf42535c6f223a703b650aa0d7fea376a8a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ea109a3479cdbbe8a47bf60b2d2d69072a1d51b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ea109a3479cdbbe8a47bf60b2d2d69072a1d51b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3ea109a3479cdbbe8a47bf60b2d2d69072a1d51b", "patch": "@@ -1,3 +1,10 @@\n+2018-01-02  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* optabs-query.h (qimode_for_vec_perm): Declare.\n+\t* optabs-query.c (can_vec_perm_p): Split out qimode search to...\n+\t(qimode_for_vec_perm): ...this new function.\n+\t* optabs.c (expand_vec_perm): Use qimode_for_vec_perm.\n+\n 2018-01-02  Aaron Sawdey  <acsawdey@linux.vnet.ibm.com>\n \n \t* rtlanal.c (canonicalize_condition): Return 0 if final rtx"}, {"sha": "02a583fa8a56d7fa703f20d619cff723c8e47c4b", "filename": "gcc/optabs-query.c", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ea109a3479cdbbe8a47bf60b2d2d69072a1d51b/gcc%2Foptabs-query.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ea109a3479cdbbe8a47bf60b2d2d69072a1d51b/gcc%2Foptabs-query.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.c?ref=3ea109a3479cdbbe8a47bf60b2d2d69072a1d51b", "patch": "@@ -345,6 +345,22 @@ can_conditionally_move_p (machine_mode mode)\n   return direct_optab_handler (movcc_optab, mode) != CODE_FOR_nothing;\n }\n \n+/* If a target doesn't implement a permute on a vector with multibyte\n+   elements, we can try to do the same permute on byte elements.\n+   If this makes sense for vector mode MODE then return the appropriate\n+   byte vector mode.  */\n+\n+opt_machine_mode\n+qimode_for_vec_perm (machine_mode mode)\n+{\n+  machine_mode qimode;\n+  if (GET_MODE_INNER (mode) != QImode\n+      && mode_for_vector (QImode, GET_MODE_SIZE (mode)).exists (&qimode)\n+      && VECTOR_MODE_P (qimode))\n+    return qimode;\n+  return opt_machine_mode ();\n+}\n+\n /* Return true if VEC_PERM_EXPR of arbitrary input vectors can be\n    expanded using SIMD extensions of the CPU.  SEL may be NULL, which\n    stands for an unknown constant.  Note that additional permutations\n@@ -375,9 +391,7 @@ can_vec_perm_p (machine_mode mode, bool variable, vec_perm_indices *sel)\n     return true;\n \n   /* We allow fallback to a QI vector mode, and adjust the mask.  */\n-  if (GET_MODE_INNER (mode) == QImode\n-      || !mode_for_vector (QImode, GET_MODE_SIZE (mode)).exists (&qimode)\n-      || !VECTOR_MODE_P (qimode))\n+  if (!qimode_for_vec_perm (mode).exists (&qimode))\n     return false;\n \n   /* ??? For completeness, we ought to check the QImode version of"}, {"sha": "ce0c401a9d50c095cb8e925d2789a431027d02a6", "filename": "gcc/optabs-query.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ea109a3479cdbbe8a47bf60b2d2d69072a1d51b/gcc%2Foptabs-query.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ea109a3479cdbbe8a47bf60b2d2d69072a1d51b/gcc%2Foptabs-query.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.h?ref=3ea109a3479cdbbe8a47bf60b2d2d69072a1d51b", "patch": "@@ -174,6 +174,7 @@ enum insn_code can_extend_p (machine_mode, machine_mode, int);\n enum insn_code can_float_p (machine_mode, machine_mode, int);\n enum insn_code can_fix_p (machine_mode, machine_mode, int, bool *);\n bool can_conditionally_move_p (machine_mode mode);\n+opt_machine_mode qimode_for_vec_perm (machine_mode);\n bool can_vec_perm_p (machine_mode, bool, vec_perm_indices *);\n /* Find a widening optab even if it doesn't widen as much as we want.  */\n #define find_widening_optab_handler(A, B, C) \\"}, {"sha": "a2213ddd72e9c23a34227dac1d1230598ac938b7", "filename": "gcc/optabs.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ea109a3479cdbbe8a47bf60b2d2d69072a1d51b/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ea109a3479cdbbe8a47bf60b2d2d69072a1d51b/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=3ea109a3479cdbbe8a47bf60b2d2d69072a1d51b", "patch": "@@ -5472,9 +5472,7 @@ expand_vec_perm (machine_mode mode, rtx v0, rtx v1, rtx sel, rtx target)\n \n   /* Set QIMODE to a different vector mode with byte elements.\n      If no such mode, or if MODE already has byte elements, use VOIDmode.  */\n-  if (GET_MODE_INNER (mode) == QImode\n-      || !mode_for_vector (QImode, w).exists (&qimode)\n-      || !VECTOR_MODE_P (qimode))\n+  if (!qimode_for_vec_perm (mode).exists (&qimode))\n     qimode = VOIDmode;\n \n   /* If the input is a constant, expand it specially.  */"}]}