{"sha": "ce2b6ba521252796f61a25ada77f3e55ea97b36d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2UyYjZiYTUyMTI1Mjc5NmY2MWEyNWFkYTc3ZjNlNTVlYTk3YjM2ZA==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2008-05-26T13:43:18Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-05-26T13:43:18Z"}, "message": "einfo.ads (Abstract_Interface_Alias): Renamed as Interface_Alias.\n\n2008-05-26  Javier Miranda  <miranda@adacore.com>\n\n\t* einfo.ads (Abstract_Interface_Alias): Renamed as Interface_Alias.\n\t(Set_Abstract_Interface_Alias): Renamed as Set_Interface_Alias.\n\t(Is_Internal): Adding documentation on internal entities that have\n \tattribute Interface_Alias (old attribute Abstract_Interface_Alias)\n\n\t* einfo.adb (Abstract_Interface_Alias): Renamed as Interface_Alias.\n\t(Set_Abstract_Interface_Alias): Renamed as Set_Interface_Alias.\n \tAdded assertion to force entities with this attribute to have\n \tattribute Is_Internal set to True.\n\t(Next_Tag_Component): Simplify assertion using attribute Is_Tag.\n\n\t* sem_ch3.adb (Derive_Interface_Subprograms): This subprogram has been\n \trenamed as Derive_Progenitor_Subprograms. In addition, its code is\n \ta new implementation.\n\t(Add_Interface_Tag_Components): Remove special management of\n\tsynchronized interfaces.\n\t(Analyze_Interface_Declaration): Minor reformating\n\t(Build_Derived_Record_Type): Minor reformating\n\t(Check_Abstract_Overriding): Avoid reporting error in case of abstract\n \tpredefined primitive inherited from interface type because the body of\n \tinternally generated predefined primitives of tagged types are generated\n \tlater by Freeze_Type\n\t(Derive_Subprogram): Avoid generating an internal name if the parent\n \tsubprogram overrides an interface primitive.\n\t(Derive_Subprograms): New implementation that keeps separate the\n \tmanagement of tagged types not implementing interfaces, from tagged\n \ttypes that implement interfaces.\n\t(Is_Progenitor): New implementation.\n\t(Process_Full_View): Add documentation\n\t(Record_Type_Declaration): Replace call to Derive_Interface_Subprograms\n \tby call to Derive_Progenitor_Subprograms.\n\n\t* sem_ch6.ads (Is_Interface_Conformant): New subprogram.\n\t(Check_Subtype_Conformant, Subtype_Conformant): Adding new argument\n \tSkip_Controlling_Formals.\n\n\t* sem_ch6.adb (Is_Interface_Conformant): New subprogram.\n\t(Check_Conventions): New implementation. Remove local subprogram\n \tSkip_Check. Remove formal Search_From of routine Check_Convention.\n\t(Check_Subtype_Conformant, Subtype_Conformant): Adding new argument\n \tSkip_Controlling_Formals.\n\t(New_Overloaded_Entity): Enable addition of predefined dispatching\n \toperations.\n\n\t* sem_disp.ads\n\t(Find_Primitive_Covering_Interface): New subprogram.\n\n\t* sem_disp.adb (Check_Dispatching_Operation): Disable registering\n \tthe task body procedure as a primitive of the corresponding tagged\n \ttype.\n\t(Check_Operation_From_Private_Type): Avoid adding twice an entity\n \tto the list of primitives.\n\t(Find_Primitive_Covering_Interface): New subprogram.\n\t(Override_Dispatching_Operation): Add documentation.\n\n\t* sem_type.adb (Covers): Minor reformatings\n\n\t* sem_util.ads (Collect_Abstract_Interfaces): Renamed as\n\tCollect_Interfaces.\n \tRename formal.\n\t(Has_Abstract_Interfaces): Renamed as Has_Interfaces.\n\t(Implements_Interface): New subprogram.\n\t(Is_Parent): Removed.\n\t(Primitive_Names_Match): New subprogram.\n\t(Remove_Homonym): Moved here from Derive_Interface_Subprograms.\n\t(Ultimate_Alias): New subprogram.\n\n\t* sem_util.adb (Collect_Abstract_Interfaces): Renamed as\n\tCollect_Interfaces.\n \tRemove special management for synchronized types. Rename formal. Remove\n \tinternal subprograms Interface_Present_In_Parent and Add_Interface.\n\t(Has_Abstract_Interfaces): Renamed as Has_Interfaces. Replace assertion\n \ton non-record types by code to return false in such case.\n\t(Implements_Interface): New subprogram.\n\t(Is_Parent): Removed. No special management is now required for\n \tsynchronized types covering interfaces.\n\t(Primitive_Names_Match): New subprogram.\n\t(Remove_Homonym): Moved here from Derive_Interface_Subprograms.\n\t(Ultimate_Alias): New subprogram.\n\n\t* exp_ch3.adb (Add_Internal_Interface_Entities): New subprogram.\n \tAdd internal entities associated with secondary dispatch tables to\n \tthe list of tagged type primitives that are not interfaces.\n\t(Freeze_Record_Type): Add new call to Add_Internal_Interface_Entities\n\t(Make_Predefined_Primitive_Specs): Code reorganization to improve\n \tthe management of predefined equality operator. In addition, if\n \tthe type has an equality function corresponding with a primitive\n \tdefined in an interface type, the inherited equality is abstract\n \tas well, and no body can be created for it.\n\n\t* exp_disp.ads (Is_Predefined_Dispatching_Operation): Moved from\n \texp_util to exp_disp.\n\t(Is_Predefined_Interface_Primitive): New subprogram. Returns True if\n \tan entity corresponds with one of the predefined primitives required\n \tto implement interfaces.\n\tUpdate copyright notice.\n\n\t* exp_disp.adb (Set_All_DT_Position): Add assertion. Exclude from the\n \tfinal check on abstract subprograms all the primitives associated with\n \tinterface primitives because they must be visible in the public and\n \tprivate part.\n\t(Write_DT): Use Find_Dispatching_Type to locate the name of the\n\tinterface type. This allows the use of this routine, for debugging\n\tpurposes, when the tagged type is not fully decorated.\n\t(Is_Predefined_Dispatching_Operation): Moved from exp_util to exp_disp.\n \tFactorize code calling new subprogram Is_Predefined_Interface_Primitive.\n\t(Is_Predefined_Interface_Primitive): New subprogram. Returns True if an\n \tentity corresponds with one of the predefined primitives required to\n \timplement interfaces.\n\n\t* exp_util.adb (Find_Interface_ADT): New implementation\n\t(Find_Interface): Removed.\n\n\t* sprint.adb (Sprint_Node_Actual): Generate missing output for the\n \tlist of interfaces associated with nodes\n\tN_Formal_Derived_Type_Definition and N_Private_Extension_Declaration.\n\nFrom-SVN: r135923", "tree": {"sha": "79adfbe7ee2b0d0ba21e43d27188487c0ef9a3bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/79adfbe7ee2b0d0ba21e43d27188487c0ef9a3bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce2b6ba521252796f61a25ada77f3e55ea97b36d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce2b6ba521252796f61a25ada77f3e55ea97b36d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce2b6ba521252796f61a25ada77f3e55ea97b36d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce2b6ba521252796f61a25ada77f3e55ea97b36d/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e5f005e18cf7763078e93e3da1747cb3c964b0b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5f005e18cf7763078e93e3da1747cb3c964b0b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5f005e18cf7763078e93e3da1747cb3c964b0b3"}], "stats": {"total": 3295, "additions": 1762, "deletions": 1533}, "files": [{"sha": "fa212a76bed5d392e5d97c3f96cb3e22b829fdfa", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 33, "deletions": 34, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=ce2b6ba521252796f61a25ada77f3e55ea97b36d", "patch": "@@ -208,8 +208,8 @@ package body Einfo is\n \n    --    Spec_PPC_List                   Node24\n \n-   --    Abstract_Interface_Alias        Node25\n-   --    Abstract_Interfaces             Elist25\n+   --    Interface_Alias                 Node25\n+   --    Interfaces                      Elist25\n    --    Debug_Renaming_Link             Node25\n    --    DT_Offset_To_Top_Func           Node25\n    --    Task_Body_Procedure             Node25\n@@ -544,18 +544,6 @@ package body Einfo is\n    -- Attribute Access Functions --\n    --------------------------------\n \n-   function Abstract_Interfaces (Id : E) return L is\n-   begin\n-      pragma Assert (Is_Record_Type (Id));\n-      return Elist25 (Id);\n-   end Abstract_Interfaces;\n-\n-   function Abstract_Interface_Alias (Id : E) return E is\n-   begin\n-      pragma Assert (Is_Subprogram (Id));\n-      return Node25 (Id);\n-   end Abstract_Interface_Alias;\n-\n    function Accept_Address (Id : E) return L is\n    begin\n       return Elist21 (Id);\n@@ -1538,6 +1526,18 @@ package body Einfo is\n       return Flag232 (Id);\n    end Implemented_By_Entry;\n \n+   function Interfaces (Id : E) return L is\n+   begin\n+      pragma Assert (Is_Record_Type (Id));\n+      return Elist25 (Id);\n+   end Interfaces;\n+\n+   function Interface_Alias (Id : E) return E is\n+   begin\n+      pragma Assert (Is_Subprogram (Id));\n+      return Node25 (Id);\n+   end Interface_Alias;\n+\n    function In_Package_Body (Id : E) return B is\n    begin\n       return Flag48 (Id);\n@@ -2941,21 +2941,6 @@ package body Einfo is\n    -- Attribute Set Procedures --\n    ------------------------------\n \n-   procedure Set_Abstract_Interfaces (Id : E; V : L) is\n-   begin\n-      pragma Assert (Is_Record_Type (Id));\n-      Set_Elist25 (Id, V);\n-   end Set_Abstract_Interfaces;\n-\n-   procedure Set_Abstract_Interface_Alias (Id : E; V : E) is\n-   begin\n-      pragma Assert\n-        (Is_Hidden (Id)\n-          and then\n-           (Ekind (Id) = E_Procedure or else Ekind (Id) = E_Function));\n-      Set_Node25 (Id, V);\n-   end Set_Abstract_Interface_Alias;\n-\n    procedure Set_Accept_Address (Id : E; V : L) is\n    begin\n       Set_Elist21 (Id, V);\n@@ -3961,6 +3946,22 @@ package body Einfo is\n       Set_Flag232 (Id, V);\n    end Set_Implemented_By_Entry;\n \n+   procedure Set_Interfaces (Id : E; V : L) is\n+   begin\n+      pragma Assert (Is_Record_Type (Id));\n+      Set_Elist25 (Id, V);\n+   end Set_Interfaces;\n+\n+   procedure Set_Interface_Alias (Id : E; V : E) is\n+   begin\n+      pragma Assert\n+        (Is_Internal (Id)\n+          and then Is_Hidden (Id)\n+          and then (Ekind (Id) = E_Procedure\n+                      or else Ekind (Id) = E_Function));\n+      Set_Node25 (Id, V);\n+   end Set_Interface_Alias;\n+\n    procedure Set_In_Package_Body (Id : E; V : B := True) is\n    begin\n       Set_Flag48 (Id, V);\n@@ -7296,11 +7297,9 @@ package body Einfo is\n \n    function Next_Tag_Component (Id : E) return E is\n       Comp : Entity_Id;\n-      Typ  : constant Entity_Id := Scope (Id);\n \n    begin\n-      pragma Assert (Ekind (Id) = E_Component\n-                       and then Is_Tagged_Type (Typ));\n+      pragma Assert (Is_Tag (Id));\n \n       Comp := Next_Entity (Id);\n       while Present (Comp) loop\n@@ -8600,13 +8599,13 @@ package body Einfo is\n \n          when E_Procedure                                  |\n               E_Function                                   =>\n-            Write_Str (\"Abstract_Interface_Alias\");\n+            Write_Str (\"Interface_Alias\");\n \n          when E_Record_Type                                |\n               E_Record_Subtype                             |\n               E_Record_Type_With_Private                   |\n               E_Record_Subtype_With_Private                =>\n-            Write_Str (\"Abstract_Interfaces\");\n+            Write_Str (\"Interfaces\");\n \n          when Task_Kind                                    =>\n             Write_Str (\"Task_Body_Procedure\");"}, {"sha": "c0377a5430d2d572e97559020a3adabfe177cb0b", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 34, "deletions": 30, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=ce2b6ba521252796f61a25ada77f3e55ea97b36d", "patch": "@@ -293,18 +293,6 @@ package Einfo is\n --  type, and if assertions are enabled, an attempt to set the attribute on a\n --  subtype will raise an assert error.\n \n---    Abstract_Interfaces (Elist25)\n---       Present in record types and subtypes. List of abstract interfaces\n---       implemented by a tagged type that are not already implemented by the\n---       ancestors (Ada 2005: AI-251).\n-\n---    Abstract_Interface_Alias (Node25)\n---       Present in subprograms that cover a primitive operation of an abstract\n---       interface type. Can be set only if the Is_Hidden flag is also set,\n---       since such entities are always hidden. Points to its associated\n---       interface subprogram. It is used to register the subprogram in\n---       secondary dispatch table of the interface (Ada 2005: AI-251).\n-\n --    Accept_Address (Elist21)\n --       Present in entries. If an accept has a statement sequence, then an\n --       address variable is created, which is used to hold the address of the\n@@ -364,12 +352,12 @@ package Einfo is\n --    Alias (Node18)\n --       Present in overloaded entities (literals, subprograms, entries) and\n --       subprograms that cover a primitive operation of an abstract interface\n---       (that is, subprograms with the Abstract_Interface_Alias attribute).\n---       In case of overloaded entities it points to the parent subprogram of\n---       a derived subprogram. In case of abstract interface subprograms it\n---       points to the subprogram that covers the abstract interface primitive.\n---       Also used for a subprogram renaming, where it points to the renamed\n---       subprogram. Always empty for entries.\n+--       (that is, subprograms with the Interface_Alias attribute). In case of\n+--       overloaded entities it points to the parent subprogram of a derived\n+--       subprogram. In case of abstract interface subprograms it points to the\n+--       subprogram that covers the abstract interface primitive. Also used for\n+--       a subprogram renaming, where it points to the renamed subprogram.\n+--       Always empty for entries.\n \n --    Alignment (Uint14)\n --       Present in entities for types and also in constants, variables\n@@ -1837,6 +1825,18 @@ package Einfo is\n --       Applies to functions and procedures. Set if pragma Implemented_By_\n --       Entry is applied on the subprogram entity.\n \n+--    Interfaces (Elist25)\n+--       Present in record types and subtypes. List of abstract interfaces\n+--       implemented by a tagged type that are not already implemented by the\n+--       ancestors (Ada 2005: AI-251).\n+\n+--    Interface_Alias (Node25)\n+--       Present in subprograms that cover a primitive operation of an abstract\n+--       interface type. Can be set only if the Is_Hidden flag is also set,\n+--       since such entities are always hidden. Points to its associated\n+--       interface subprogram. It is used to register the subprogram in\n+--       secondary dispatch table of the interface (Ada 2005: AI-251).\n+\n --    In_Package_Body (Flag48)\n --       Present in package entities. Set on the entity that denotes the\n --       package (the defining occurrence of the package declaration) while\n@@ -2259,6 +2259,10 @@ package Einfo is\n --         3) Object declarations generated by the expander that are implicitly\n --         imported or exported so that they can be marked in Sprint output.\n --\n+--         4) Internal entities in the list of primitives of tagged types that\n+--         are used to handle secondary dispatch tables. These entities have\n+--         also the attribute Interface_Alias.\n+--\n --    Is_Interrupt_Handler (Flag89)\n --       Present in procedures. Set if a pragma Interrupt_Handler applies\n --       to the procedure. The procedure must be parameterless, and on all\n@@ -5018,7 +5022,7 @@ package Einfo is\n    --    Generic_Renamings                   (Elist23)  (for an instance)\n    --    Inner_Instances                     (Elist23)  (generic function only)\n    --    Protection_Object                   (Node23)   (for concurrent kind)\n-   --    Abstract_Interface_Alias            (Node25)\n+   --    Interface_Alias                     (Node25)\n    --    Overridden_Operation                (Node26)\n    --    Extra_Formals                       (Node28)\n    --    Body_Needed_For_SAL                 (Flag40)\n@@ -5279,7 +5283,7 @@ package Einfo is\n    --    Inner_Instances                     (Elist23)  (for generic proc)\n    --    Protection_Object                   (Node23)   (for concurrent kind)\n    --    Spec_PPC_List                       (Node24)   (non-generic case only)\n-   --    Abstract_Interface_Alias            (Node25)\n+   --    Interface_Alias                     (Node25)\n    --    Static_Initialization               (Node26)   (init_proc only)\n    --    Overridden_Operation                (Node26)\n    --    Wrapped_Entity                      (Node27)   (non-generic case only)\n@@ -5363,7 +5367,7 @@ package Einfo is\n    --    Discriminant_Constraint             (Elist21)\n    --    Corresponding_Remote_Type           (Node22)\n    --    Stored_Constraint                   (Elist23)\n-   --    Abstract_Interfaces                 (Elist25)\n+   --    Interfaces                          (Elist25)\n    --    Component_Alignment                 (special)  (base type only)\n    --    C_Pass_By_Copy                      (Flag125)  (base type only)\n    --    Has_Dispatch_Table                  (Flag220)  (base tagged type only)\n@@ -5397,7 +5401,7 @@ package Einfo is\n    --    Discriminant_Constraint             (Elist21)\n    --    Private_View                        (Node22)\n    --    Stored_Constraint                   (Elist23)\n-   --    Abstract_Interfaces                 (Elist25)\n+   --    Interfaces                          (Elist25)\n    --    Has_Completion                      (Flag26)\n    --    Has_Record_Rep_Clause               (Flag65)   (base type only)\n    --    Has_External_Tag_Rep_Clause         (Flag110)\n@@ -5746,13 +5750,11 @@ package Einfo is\n    --  section contains the functions used to obtain attribute values which\n    --  correspond to values in fields or flags in the entity itself.\n \n-   function Abstract_Interfaces                 (Id : E) return L;\n    function Accept_Address                      (Id : E) return L;\n    function Access_Disp_Table                   (Id : E) return L;\n    function Actual_Subtype                      (Id : E) return E;\n    function Address_Taken                       (Id : E) return B;\n    function Alias                               (Id : E) return E;\n-   function Abstract_Interface_Alias            (Id : E) return E;\n    function Alignment                           (Id : E) return U;\n    function Associated_Final_Chain              (Id : E) return E;\n    function Associated_Formal_Package           (Id : E) return E;\n@@ -5920,6 +5922,8 @@ package Einfo is\n    function In_Private_Part                     (Id : E) return B;\n    function In_Use                              (Id : E) return B;\n    function Inner_Instances                     (Id : E) return L;\n+   function Interfaces                          (Id : E) return L;\n+   function Interface_Alias                     (Id : E) return E;\n    function Interface_Name                      (Id : E) return N;\n    function Is_AST_Entry                        (Id : E) return B;\n    function Is_Abstract_Subprogram              (Id : E) return B;\n@@ -6305,14 +6309,12 @@ package Einfo is\n    -- Attribute Set Procedures --\n    ------------------------------\n \n-   procedure Set_Abstract_Interfaces             (Id : E; V : L);\n    procedure Set_Accept_Address                  (Id : E; V : L);\n    procedure Set_Access_Disp_Table               (Id : E; V : L);\n    procedure Set_Dispatch_Table_Wrapper          (Id : E; V : E);\n    procedure Set_Actual_Subtype                  (Id : E; V : E);\n    procedure Set_Address_Taken                   (Id : E; V : B := True);\n    procedure Set_Alias                           (Id : E; V : E);\n-   procedure Set_Abstract_Interface_Alias        (Id : E; V : E);\n    procedure Set_Alignment                       (Id : E; V : U);\n    procedure Set_Associated_Final_Chain          (Id : E; V : E);\n    procedure Set_Associated_Formal_Package       (Id : E; V : E);\n@@ -6474,10 +6476,12 @@ package Einfo is\n    procedure Set_Hiding_Loop_Variable            (Id : E; V : E);\n    procedure Set_Homonym                         (Id : E; V : E);\n    procedure Set_Implemented_By_Entry            (Id : E; V : B := True);\n+   procedure Set_Interfaces                      (Id : E; V : L);\n    procedure Set_In_Package_Body                 (Id : E; V : B := True);\n    procedure Set_In_Private_Part                 (Id : E; V : B := True);\n    procedure Set_In_Use                          (Id : E; V : B := True);\n    procedure Set_Inner_Instances                 (Id : E; V : L);\n+   procedure Set_Interface_Alias                 (Id : E; V : E);\n    procedure Set_Interface_Name                  (Id : E; V : N);\n    procedure Set_Is_AST_Entry                    (Id : E; V : B := True);\n    procedure Set_Is_Abstract_Subprogram          (Id : E; V : B := True);\n@@ -6954,12 +6958,10 @@ package Einfo is\n    --  subprograms meeting the requirements documented in the section on\n    --  XEINFO may be referenced in this section.\n \n-   pragma Inline (Abstract_Interfaces);\n    pragma Inline (Accept_Address);\n    pragma Inline (Access_Disp_Table);\n    pragma Inline (Actual_Subtype);\n    pragma Inline (Address_Taken);\n-   pragma Inline (Abstract_Interface_Alias);\n    pragma Inline (Alias);\n    pragma Inline (Alignment);\n    pragma Inline (Associated_Final_Chain);\n@@ -7122,10 +7124,12 @@ package Einfo is\n    pragma Inline (Hiding_Loop_Variable);\n    pragma Inline (Homonym);\n    pragma Inline (Implemented_By_Entry);\n+   pragma Inline (Interfaces);\n    pragma Inline (In_Package_Body);\n    pragma Inline (In_Private_Part);\n    pragma Inline (In_Use);\n    pragma Inline (Inner_Instances);\n+   pragma Inline (Interface_Alias);\n    pragma Inline (Interface_Name);\n    pragma Inline (Is_AST_Entry);\n    pragma Inline (Is_Abstract_Subprogram);\n@@ -7380,12 +7384,10 @@ package Einfo is\n    pragma Inline (Init_Esize);\n    pragma Inline (Init_RM_Size);\n \n-   pragma Inline (Set_Abstract_Interfaces);\n    pragma Inline (Set_Accept_Address);\n    pragma Inline (Set_Access_Disp_Table);\n    pragma Inline (Set_Actual_Subtype);\n    pragma Inline (Set_Address_Taken);\n-   pragma Inline (Set_Abstract_Interface_Alias);\n    pragma Inline (Set_Alias);\n    pragma Inline (Set_Alignment);\n    pragma Inline (Set_Associated_Final_Chain);\n@@ -7547,10 +7549,12 @@ package Einfo is\n    pragma Inline (Set_Hiding_Loop_Variable);\n    pragma Inline (Set_Homonym);\n    pragma Inline (Set_Implemented_By_Entry);\n+   pragma Inline (Set_Interfaces);\n    pragma Inline (Set_In_Package_Body);\n    pragma Inline (Set_In_Private_Part);\n    pragma Inline (Set_In_Use);\n    pragma Inline (Set_Inner_Instances);\n+   pragma Inline (Set_Interface_Alias);\n    pragma Inline (Set_Interface_Name);\n    pragma Inline (Set_Is_AST_Entry);\n    pragma Inline (Set_Is_Abstract_Subprogram);"}, {"sha": "34b5644d6d243452378cebf67ea0ae90064daac5", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=ce2b6ba521252796f61a25ada77f3e55ea97b36d", "patch": "@@ -2573,7 +2573,7 @@ package body Exp_Aggr is\n                   --  Ada 2005 (AI-251): If tagged type has progenitors we must\n                   --  also initialize tags of the secondary dispatch tables.\n \n-                  if Has_Abstract_Interfaces (Base_Type (Typ)) then\n+                  if Has_Interfaces (Base_Type (Typ)) then\n                      Init_Secondary_Tags\n                        (Typ        => Base_Type (Typ),\n                         Target     => Target,\n@@ -3080,7 +3080,7 @@ package body Exp_Aggr is\n          --  abstract interfaces we must also initialize the tags of the\n          --  secondary dispatch tables.\n \n-         if Has_Abstract_Interfaces (Base_Type (Typ)) then\n+         if Has_Interfaces (Base_Type (Typ)) then\n             Init_Secondary_Tags\n               (Typ        => Base_Type (Typ),\n                Target     => Target,\n@@ -5369,7 +5369,7 @@ package body Exp_Aggr is\n       --  If the tagged types covers interface types we need to initialize all\n       --  hidden components containing pointers to secondary dispatch tables.\n \n-      elsif Is_Tagged_Type (Typ) and then Has_Abstract_Interfaces (Typ) then\n+      elsif Is_Tagged_Type (Typ) and then Has_Interfaces (Typ) then\n          Convert_To_Assignments (N, Typ);\n \n       --  If some components are mutable, the size of the aggregate component"}, {"sha": "4d2967bbf0fc9737bc037bf2b892b6914fbc2cc3", "filename": "gcc/ada/exp_ch13.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fexp_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fexp_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch13.adb?ref=ce2b6ba521252796f61a25ada77f3e55ea97b36d", "patch": "@@ -299,7 +299,7 @@ package body Exp_Ch13 is\n          --  its secondary dispatch table and therefore the code generator\n          --  has nothing else to do with this freezing node.\n \n-         Delete := Present (Abstract_Interface_Alias (E));\n+         Delete := Present (Interface_Alias (E));\n       end if;\n \n       --  Analyze actions generated by freezing. The init_proc contains source"}, {"sha": "c1195518c97fe51462d67b751add346da545028a", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 152, "deletions": 25, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=ce2b6ba521252796f61a25ada77f3e55ea97b36d", "patch": "@@ -57,6 +57,7 @@ with Sem_Disp; use Sem_Disp;\n with Sem_Eval; use Sem_Eval;\n with Sem_Mech; use Sem_Mech;\n with Sem_Res;  use Sem_Res;\n+with Sem_Type; use Sem_Type;\n with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n with Stand;    use Stand;\n@@ -2166,7 +2167,7 @@ package body Exp_Ch3 is\n             --  If the interface is a parent of Rec_Type it shares the primary\n             --  dispatch table and hence there is no need to build the function\n \n-            if not Is_Parent (Node (Iface_Elmt), Rec_Type) then\n+            if not Is_Ancestor (Node (Iface_Elmt), Rec_Type) then\n                Build_Offset_To_Top_Function (Iface_Comp => Node (Comp_Elmt));\n             end if;\n \n@@ -2304,7 +2305,7 @@ package body Exp_Ch3 is\n \n             if Ada_Version >= Ada_05\n               and then not Is_Interface (Rec_Type)\n-              and then Has_Abstract_Interfaces (Rec_Type)\n+              and then Has_Interfaces (Rec_Type)\n             then\n                Init_Secondary_Tags\n                  (Typ            => Rec_Type,\n@@ -2398,8 +2399,7 @@ package body Exp_Ch3 is\n \n                         if not Is_Imported (Prim)\n                           and then Convention (Prim) = Convention_CPP\n-                          and then not Present (Abstract_Interface_Alias\n-                                                 (Prim))\n+                          and then not Present (Interface_Alias (Prim))\n                         then\n                            Register_Primitive (Loc,\n                              Prim    => Prim,\n@@ -2421,7 +2421,7 @@ package body Exp_Ch3 is\n \n             if Ada_Version >= Ada_05\n               and then not Is_Interface (Rec_Type)\n-              and then Has_Abstract_Interfaces (Rec_Type)\n+              and then Has_Interfaces (Rec_Type)\n               and then Has_Discriminants (Etype (Rec_Type))\n               and then Is_Variable_Size_Record (Etype (Rec_Type))\n             then\n@@ -4421,7 +4421,7 @@ package body Exp_Ch3 is\n               and then\n                 (Is_Class_Wide_Type (Etype (Expr))\n                    or else\n-                     not Is_Parent (Root_Type (Typ), Etype (Expr)))\n+                     not Is_Ancestor (Root_Type (Typ), Etype (Expr)))\n               and then Comes_From_Source (Def_Id)\n               and then VM_Target = No_VM\n             then\n@@ -5321,6 +5321,105 @@ package body Exp_Ch3 is\n    ------------------------\n \n    procedure Freeze_Record_Type (N : Node_Id) is\n+\n+      procedure Add_Internal_Interface_Entities (Tagged_Type : Entity_Id);\n+      --  Add to the list of primitives of Tagged_Types the internal entities\n+      --  associated with interface primitives that are located in secondary\n+      --  dispatch tables.\n+\n+      -------------------------------------\n+      -- Add_Internal_Interface_Entities --\n+      -------------------------------------\n+\n+      procedure Add_Internal_Interface_Entities (Tagged_Type : Entity_Id) is\n+         Elmt        : Elmt_Id;\n+         Iface       : Entity_Id;\n+         Iface_Elmt  : Elmt_Id;\n+         Iface_Prim  : Entity_Id;\n+         Ifaces_List : Elist_Id;\n+         New_Subp    : Entity_Id := Empty;\n+         Prim        : Entity_Id;\n+\n+      begin\n+         pragma Assert (Ada_Version >= Ada_05\n+           and then Is_Record_Type (Tagged_Type)\n+           and then Is_Tagged_Type (Tagged_Type)\n+           and then Has_Interfaces (Tagged_Type)\n+           and then not Is_Interface (Tagged_Type));\n+\n+         Collect_Interfaces (Tagged_Type, Ifaces_List);\n+\n+         Iface_Elmt := First_Elmt (Ifaces_List);\n+         while Present (Iface_Elmt) loop\n+            Iface := Node (Iface_Elmt);\n+\n+            --  Exclude from this processing interfaces that are parents\n+            --  of Tagged_Type because their primitives are located in the\n+            --  primary dispatch table (and hence no auxiliary internal\n+            --  entities are required to handle secondary dispatch tables\n+            --  in such case).\n+\n+            if not Is_Ancestor (Iface, Tagged_Type) then\n+               Elmt := First_Elmt (Primitive_Operations (Iface));\n+               while Present (Elmt) loop\n+                  Iface_Prim := Node (Elmt);\n+\n+                  if not Is_Predefined_Dispatching_Operation (Iface_Prim) then\n+                     Prim :=\n+                       Find_Primitive_Covering_Interface\n+                         (Tagged_Type => Tagged_Type,\n+                          Iface_Prim  => Iface_Prim);\n+\n+                     pragma Assert (Present (Prim));\n+\n+                     Derive_Subprogram\n+                       (New_Subp     => New_Subp,\n+                        Parent_Subp  => Iface_Prim,\n+                        Derived_Type => Tagged_Type,\n+                        Parent_Type  => Iface);\n+\n+                     --  Ada 2005 (AI-251): Decorate internal entity Iface_Subp\n+                     --  associated with interface types. These entities are\n+                     --  only registered in the list of primitives of its\n+                     --  corresponding tagged type because they are only used\n+                     --  to fill the contents of the secondary dispatch tables.\n+                     --  Therefore they are removed from the homonym chains.\n+\n+                     Set_Is_Hidden (New_Subp);\n+                     Set_Is_Internal (New_Subp);\n+                     Set_Alias (New_Subp, Prim);\n+                     Set_Is_Abstract_Subprogram (New_Subp,\n+                       Is_Abstract_Subprogram (Prim));\n+                     Set_Interface_Alias (New_Subp, Iface_Prim);\n+\n+                     --  Internal entities associated with interface types are\n+                     --  only registered in the list of primitives of the\n+                     --  tagged type. They are only used to fill the contents\n+                     --  of the secondary dispatch tables. Therefore they are\n+                     --  not needed in the homonym chains.\n+\n+                     Remove_Homonym (New_Subp);\n+\n+                     --  Hidden entities associated with interfaces must have\n+                     --  set the Has_Delay_Freeze attribute to ensure that, in\n+                     --  case of locally defined tagged types (or compiling\n+                     --  with static dispatch tables generation disabled) the\n+                     --  corresponding entry of the secondary dispatch table is\n+                     --  filled when such entity is frozen.\n+\n+                     Set_Has_Delayed_Freeze (New_Subp);\n+                  end if;\n+\n+                  Next_Elmt (Elmt);\n+               end loop;\n+            end if;\n+\n+            Next_Elmt (Iface_Elmt);\n+         end loop;\n+      end Add_Internal_Interface_Entities;\n+\n+      --  Local variables\n+\n       Def_Id        : constant Node_Id := Entity (N);\n       Type_Decl     : constant Node_Id := Parent (Def_Id);\n       Comp          : Entity_Id;\n@@ -5343,6 +5442,8 @@ package body Exp_Ch3 is\n       Wrapper_Body_List   : List_Id := No_List;\n       Null_Proc_Decl_List : List_Id := No_List;\n \n+   --  Start of processing for Freeze_Record_Type\n+\n    begin\n       --  Build discriminant checking functions if not a derived type (for\n       --  derived types that are not tagged types, always use the discriminant\n@@ -5545,6 +5646,17 @@ package body Exp_Ch3 is\n                Insert_Actions (N, Null_Proc_Decl_List);\n             end if;\n \n+            --  Ada 2005 (AI-251): Add internal entities associated with\n+            --  secondary dispatch tables to the list of primitives of tagged\n+            --  types that are not interfaces\n+\n+            if Ada_Version >= Ada_05\n+              and then not Is_Interface (Def_Id)\n+              and then Has_Interfaces (Def_Id)\n+            then\n+               Add_Internal_Interface_Entities (Def_Id);\n+            end if;\n+\n             Set_Is_Frozen (Def_Id);\n             Set_All_DT_Position (Def_Id);\n \n@@ -6678,7 +6790,7 @@ package body Exp_Ch3 is\n          --  Initialize the pointer to the secondary DT associated with the\n          --  interface.\n \n-         if not Is_Parent (Iface, Typ) then\n+         if not Is_Ancestor (Iface, Typ) then\n             Append_To (Stmts_List,\n               Make_Assignment_Statement (Loc,\n                 Name =>\n@@ -6776,7 +6888,7 @@ package body Exp_Ch3 is\n             --  Don't need to set any value if this interface shares\n             --  the primary dispatch table.\n \n-            if not Is_Parent (Iface, Typ) then\n+            if not Is_Ancestor (Iface, Typ) then\n                Append_To (Stmts_List,\n                  Build_Set_Static_Offset_To_Top (Loc,\n                    Iface_Tag    => New_Reference_To (Iface_Tag, Loc),\n@@ -7499,27 +7611,42 @@ package body Exp_Ch3 is\n             --  User-defined equality\n \n             elsif Chars (Node (Prim)) = Name_Op_Eq\n-              and then (No (Alias (Node (Prim)))\n-                         or else Nkind (Unit_Declaration_Node (Node (Prim))) =\n-                                            N_Subprogram_Renaming_Declaration)\n               and then Etype (First_Formal (Node (Prim))) =\n                          Etype (Next_Formal (First_Formal (Node (Prim))))\n               and then Base_Type (Etype (Node (Prim))) = Standard_Boolean\n             then\n-               Eq_Needed := False;\n-               exit;\n+               if No (Alias (Node (Prim)))\n+                 or else Nkind (Unit_Declaration_Node (Node (Prim))) =\n+                           N_Subprogram_Renaming_Declaration\n+               then\n+                  Eq_Needed := False;\n+                  exit;\n \n-            --  If the parent is not an interface type and has an abstract\n-            --  equality function, the inherited equality is abstract as well,\n-            --  and no body can be created for it.\n+               --  If the parent is not an interface type and has an abstract\n+               --  equality function, the inherited equality is abstract as\n+               --  well, and no body can be created for it.\n \n-            elsif Chars (Node (Prim)) = Name_Op_Eq\n-              and then not Is_Interface (Etype (Tag_Typ))\n-              and then Present (Alias (Node (Prim)))\n-              and then Is_Abstract_Subprogram (Alias (Node (Prim)))\n-            then\n-               Eq_Needed := False;\n-               exit;\n+               elsif not Is_Interface (Etype (Tag_Typ))\n+                 and then Present (Alias (Node (Prim)))\n+                 and then Is_Abstract_Subprogram (Alias (Node (Prim)))\n+               then\n+                  Eq_Needed := False;\n+                  exit;\n+\n+               --  If the type has an equality function corresponding with\n+               --  a primitive defined in an interface type, the inherited\n+               --  equality is abstract as well, and no body can be created\n+               --  for it.\n+\n+               elsif Present (Alias (Node (Prim)))\n+                 and then Comes_From_Source (Ultimate_Alias (Node (Prim)))\n+                 and then\n+                   Is_Interface\n+                     (Find_Dispatching_Type (Ultimate_Alias (Node (Prim))))\n+               then\n+                  Eq_Needed := False;\n+                  exit;\n+               end if;\n             end if;\n \n             Next_Elmt (Prim);\n@@ -7663,7 +7790,7 @@ package body Exp_Ch3 is\n                   and then Is_Limited_Record (Etype (Tag_Typ)))\n              or else\n                (Is_Concurrent_Record_Type (Tag_Typ)\n-                  and then Has_Abstract_Interfaces (Tag_Typ))\n+                  and then Has_Interfaces (Tag_Typ))\n          then\n             Append_To (Res,\n               Make_Subprogram_Declaration (Loc,\n@@ -8116,7 +8243,7 @@ package body Exp_Ch3 is\n           ((Is_Interface (Etype (Tag_Typ))\n               and then Is_Limited_Record (Etype (Tag_Typ)))\n            or else (Is_Concurrent_Record_Type (Tag_Typ)\n-                     and then Has_Abstract_Interfaces (Tag_Typ)))\n+                     and then Has_Interfaces (Tag_Typ)))\n         and then RTE_Available (RE_Select_Specific_Data)\n       then\n          Append_To (Res, Make_Disp_Asynchronous_Select_Body (Tag_Typ));"}, {"sha": "2d275a9bc8033814d517675dc9b1a42e37e1da5e", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=ce2b6ba521252796f61a25ada77f3e55ea97b36d", "patch": "@@ -9210,7 +9210,7 @@ package body Exp_Ch4 is\n          --    Obj1 in Iface'Class;  --  Compile time error\n \n          if not Is_Class_Wide_Type (Left_Type)\n-           and then (Is_Parent (Etype (Right_Type), Left_Type)\n+           and then (Is_Ancestor (Etype (Right_Type), Left_Type)\n                        or else (Is_Interface (Etype (Right_Type))\n                                  and then Interface_Present_In_Ancestor\n                                            (Typ   => Left_Type,"}, {"sha": "9b4718535524abd1b8ee4b00b3ae3a8fd274847f", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=ce2b6ba521252796f61a25ada77f3e55ea97b36d", "patch": "@@ -4728,7 +4728,7 @@ package body Exp_Ch6 is\n          Tagged_Typ := Find_Dispatching_Type (Prim);\n \n          if No (Access_Disp_Table (Tagged_Typ))\n-           or else not Has_Abstract_Interfaces (Tagged_Typ)\n+           or else not Has_Interfaces (Tagged_Typ)\n            or else not RTE_Available (RE_Interface_Tag)\n            or else Restriction_Active (No_Dispatching_Calls)\n          then\n@@ -4856,7 +4856,7 @@ package body Exp_Ch6 is\n                --  table slot.\n \n                if not Is_Interface (Typ)\n-                 or else Present (Abstract_Interface_Alias (Subp))\n+                 or else Present (Interface_Alias (Subp))\n                then\n                   if Is_Predefined_Dispatching_Operation (Subp) then\n                      Register_Predefined_DT_Entry (Subp);"}, {"sha": "572dae04ea082093cb8e41a79659bc80720bd9d2", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=ce2b6ba521252796f61a25ada77f3e55ea97b36d", "patch": "@@ -32,6 +32,7 @@ with Exp_Ch3;  use Exp_Ch3;\n with Exp_Ch11; use Exp_Ch11;\n with Exp_Ch6;  use Exp_Ch6;\n with Exp_Dbug; use Exp_Dbug;\n+with Exp_Disp; use Exp_Disp;\n with Exp_Sel;  use Exp_Sel;\n with Exp_Smem; use Exp_Smem;\n with Exp_Tss;  use Exp_Tss;\n@@ -1880,11 +1881,11 @@ package body Exp_Ch9 is\n          Iface := Etype (Iface);\n       end loop Examine_Parents;\n \n-      if Present (Abstract_Interfaces\n+      if Present (Interfaces\n                    (Corresponding_Record_Type (Scope (Proc_Nam))))\n       then\n          Iface_Elmt := First_Elmt\n-                         (Abstract_Interfaces\n+                         (Interfaces\n                            (Corresponding_Record_Type (Scope (Proc_Nam))));\n          Examine_Interfaces : while Present (Iface_Elmt) loop\n             Iface := Node (Iface_Elmt);\n@@ -7091,7 +7092,7 @@ package body Exp_Ch9 is\n                         --  an interface.\n \n                         if Ada_Version >= Ada_05\n-                          and then Present (Abstract_Interfaces (\n+                          and then Present (Interfaces (\n                                      Corresponding_Record_Type (Pid)))\n                         then\n                            Disp_Op_Body :=\n@@ -7178,8 +7179,7 @@ package body Exp_Ch9 is\n \n       if Ada_Version >= Ada_05\n         and then Present (Protected_Definition (Parent (Pid)))\n-        and then Present (Abstract_Interfaces\n-                           (Corresponding_Record_Type (Pid)))\n+        and then Present (Interfaces (Corresponding_Record_Type (Pid)))\n       then\n          declare\n             Vis_Decl  : Node_Id :=\n@@ -7630,10 +7630,10 @@ package body Exp_Ch9 is\n       if Ada_Version >= Ada_05\n         and then Present (Visible_Declarations (Pdef))\n         and then Present (Corresponding_Record_Type\n-                          (Defining_Identifier (Parent (Pdef))))\n-        and then Present (Abstract_Interfaces\n-                          (Corresponding_Record_Type\n-                           (Defining_Identifier (Parent (Pdef)))))\n+                           (Defining_Identifier (Parent (Pdef))))\n+        and then Present (Interfaces\n+                           (Corresponding_Record_Type\n+                             (Defining_Identifier (Parent (Pdef)))))\n       then\n          declare\n             Current_Node : Node_Id := Rec_Decl;\n@@ -7750,8 +7750,7 @@ package body Exp_Ch9 is\n \n             if Ada_Version >= Ada_05\n               and then\n-                Present (Abstract_Interfaces\n-                          (Corresponding_Record_Type (Prot_Typ)))\n+                Present (Interfaces (Corresponding_Record_Type (Prot_Typ)))\n             then\n                Sub :=\n                  Make_Subprogram_Declaration (Loc,\n@@ -9535,8 +9534,7 @@ package body Exp_Ch9 is\n \n       if Ada_Version >= Ada_05\n         and then Present (Task_Definition (Parent (Ttyp)))\n-        and then Present (Abstract_Interfaces\n-                          (Corresponding_Record_Type (Ttyp)))\n+        and then Present (Interfaces (Corresponding_Record_Type (Ttyp)))\n       then\n          declare\n             Current_Node : Node_Id;\n@@ -10030,10 +10028,10 @@ package body Exp_Ch9 is\n       if Ada_Version >= Ada_05\n         and then Present (Taskdef)\n         and then Present (Corresponding_Record_Type\n-                          (Defining_Identifier (Parent (Taskdef))))\n-        and then Present (Abstract_Interfaces\n-                          (Corresponding_Record_Type\n-                           (Defining_Identifier (Parent (Taskdef)))))\n+                           (Defining_Identifier (Parent (Taskdef))))\n+        and then Present (Interfaces\n+                           (Corresponding_Record_Type\n+                             (Defining_Identifier (Parent (Taskdef)))))\n       then\n          declare\n             Current_Node : Node_Id := Rec_Decl;\n@@ -10087,7 +10085,6 @@ package body Exp_Ch9 is\n \n          declare\n             L : constant List_Id := Freeze_Entity (Rec_Ent, Loc);\n-\n          begin\n             if Is_Non_Empty_List (L) then\n                Insert_List_After (Body_Decl, L);\n@@ -11576,7 +11573,7 @@ package body Exp_Ch9 is\n       if Has_Entry\n         or else Has_Interrupt_Handler (Ptyp)\n         or else Has_Attach_Handler (Ptyp)\n-        or else Has_Abstract_Interfaces (Protect_Rec)\n+        or else Has_Interfaces (Protect_Rec)\n       then\n          declare\n             Pkg_Id      : constant RTU_Id  :="}, {"sha": "860fd17352cc90d5683cb588d6591debfdc7469b", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 117, "deletions": 63, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=ce2b6ba521252796f61a25ada77f3e55ea97b36d", "patch": "@@ -1080,7 +1080,7 @@ package body Exp_Disp is\n             --  a parent of the type of the actual because in this case the\n             --  interface primitives are located in the primary dispatch table.\n \n-            elsif Is_Parent (Formal_Typ, Actual_Typ) then\n+            elsif Is_Ancestor (Formal_Typ, Actual_Typ) then\n                null;\n \n             --  Implicit conversion to the class-wide formal type to force\n@@ -1126,7 +1126,7 @@ package body Exp_Disp is\n             --  a parent of the type of the actual because in this case the\n             --  interface primitives are located in the primary dispatch table.\n \n-            elsif Is_Parent (Formal_DDT, Actual_DDT) then\n+            elsif Is_Ancestor (Formal_DDT, Actual_DDT) then\n                null;\n \n             else\n@@ -1450,6 +1450,50 @@ package body Exp_Disp is\n                and then not Restriction_Active (No_Dispatching_Calls);\n    end Has_DT;\n \n+   -----------------------------------------\n+   -- Is_Predefined_Dispatching_Operation --\n+   -----------------------------------------\n+\n+   function Is_Predefined_Dispatching_Operation\n+     (E : Entity_Id) return Boolean\n+   is\n+      TSS_Name : TSS_Name_Type;\n+\n+   begin\n+      if not Is_Dispatching_Operation (E) then\n+         return False;\n+      end if;\n+\n+      Get_Name_String (Chars (E));\n+\n+      --  Most predefined primitives have internally generated names. Equality\n+      --  must be treated differently; the predefined operation is recognized\n+      --  as a homogeneous binary operator that returns Boolean.\n+\n+      if Name_Len > TSS_Name_Type'Last then\n+         TSS_Name := TSS_Name_Type (Name_Buffer (Name_Len - TSS_Name'Length + 1\n+                                     .. Name_Len));\n+         if        Chars (E) = Name_uSize\n+           or else Chars (E) = Name_uAlignment\n+           or else TSS_Name  = TSS_Stream_Read\n+           or else TSS_Name  = TSS_Stream_Write\n+           or else TSS_Name  = TSS_Stream_Input\n+           or else TSS_Name  = TSS_Stream_Output\n+           or else\n+             (Chars (E) = Name_Op_Eq\n+                and then Etype (First_Entity (E)) = Etype (Last_Entity (E)))\n+           or else Chars (E) = Name_uAssign\n+           or else TSS_Name  = TSS_Deep_Adjust\n+           or else TSS_Name  = TSS_Deep_Finalize\n+           or else Is_Predefined_Interface_Primitive (E)\n+         then\n+            return True;\n+         end if;\n+      end if;\n+\n+      return False;\n+   end Is_Predefined_Dispatching_Operation;\n+\n    -------------------------------------\n    -- Is_Predefined_Dispatching_Alias --\n    -------------------------------------\n@@ -1475,6 +1519,21 @@ package body Exp_Disp is\n       return False;\n    end Is_Predefined_Dispatching_Alias;\n \n+   ---------------------------------------\n+   -- Is_Predefined_Interface_Primitive --\n+   ---------------------------------------\n+\n+   function Is_Predefined_Interface_Primitive (E : Entity_Id) return Boolean is\n+   begin\n+      return Ada_Version >= Ada_05\n+        and then (Chars (E) = Name_uDisp_Asynchronous_Select or else\n+                  Chars (E) = Name_uDisp_Conditional_Select  or else\n+                  Chars (E) = Name_uDisp_Get_Prim_Op_Kind    or else\n+                  Chars (E) = Name_uDisp_Get_Task_Id         or else\n+                  Chars (E) = Name_uDisp_Requeue             or else\n+                  Chars (E) = Name_uDisp_Timed_Select);\n+   end Is_Predefined_Interface_Primitive;\n+\n    ----------------------------------------\n    -- Make_Disp_Asynchronous_Select_Body --\n    ----------------------------------------\n@@ -3401,7 +3460,7 @@ package body Exp_Disp is\n            or else Is_Controlled (Typ)\n            or else Restriction_Active (No_Dispatching_Calls)\n            or else not Is_Limited_Type (Typ)\n-           or else not Has_Abstract_Interfaces (Typ)\n+           or else not Has_Interfaces (Typ)\n            or else not Build_Thunks\n          then\n             --  No OSD table required\n@@ -3429,11 +3488,11 @@ package body Exp_Disp is\n                while Present (Prim_Elmt) loop\n                   Prim := Node (Prim_Elmt);\n \n-                  if Present (Abstract_Interface_Alias (Prim))\n+                  if Present (Interface_Alias (Prim))\n                     and then Find_Dispatching_Type\n-                               (Abstract_Interface_Alias (Prim)) = Iface\n+                               (Interface_Alias (Prim)) = Iface\n                   then\n-                     Prim_Alias := Abstract_Interface_Alias (Prim);\n+                     Prim_Alias := Interface_Alias (Prim);\n \n                      E := Prim;\n                      while Present (Alias (E)) loop\n@@ -3544,31 +3603,29 @@ package body Exp_Disp is\n                   Prim := Node (Prim_Elmt);\n \n                   if not Is_Predefined_Dispatching_Operation (Prim)\n-                    and then Present (Abstract_Interface_Alias (Prim))\n+                    and then Present (Interface_Alias (Prim))\n                     and then not Is_Abstract_Subprogram (Alias (Prim))\n                     and then not Is_Imported (Alias (Prim))\n                     and then Find_Dispatching_Type\n-                               (Abstract_Interface_Alias (Prim)) = Iface\n+                               (Interface_Alias (Prim)) = Iface\n \n                      --  Generate the code of the thunk only if the abstract\n                      --  interface type is not an immediate ancestor of\n                      --  Tagged_Type; otherwise the DT associated with the\n                      --  interface is the primary DT.\n \n-                    and then not Is_Parent (Iface, Typ)\n+                    and then not Is_Ancestor (Iface, Typ)\n                   then\n                      if not Build_Thunks then\n                         Pos :=\n-                          UI_To_Int\n-                            (DT_Position (Abstract_Interface_Alias (Prim)));\n+                          UI_To_Int (DT_Position (Interface_Alias (Prim)));\n                         Prim_Table (Pos) := Alias (Prim);\n                      else\n                         Expand_Interface_Thunk (Prim, Thunk_Id, Thunk_Code);\n \n                         if Present (Thunk_Id) then\n                            Pos :=\n-                             UI_To_Int\n-                               (DT_Position (Abstract_Interface_Alias (Prim)));\n+                             UI_To_Int (DT_Position (Interface_Alias (Prim)));\n \n                            Prim_Table (Pos) := Thunk_Id;\n                            Append_To (Result, Thunk_Code);\n@@ -3843,7 +3900,7 @@ package body Exp_Disp is\n \n       --  Ada 2005 (AI-251): Build the secondary dispatch tables\n \n-      if Has_Abstract_Interfaces (Typ) then\n+      if Has_Interfaces (Typ) then\n          Collect_Interface_Components (Typ, Typ_Comps);\n \n          Suffix_Index := 0;\n@@ -4438,7 +4495,7 @@ package body Exp_Disp is\n \n          --  Count the number of interface types implemented by Typ\n \n-         Collect_Abstract_Interfaces (Typ, Typ_Ifaces);\n+         Collect_Interfaces (Typ, Typ_Ifaces);\n \n          AI := First_Elmt (Typ_Ifaces);\n          while Present (AI) loop\n@@ -4460,7 +4517,7 @@ package body Exp_Disp is\n             begin\n                AI := First_Elmt (Typ_Ifaces);\n                while Present (AI) loop\n-                  if Is_Parent (Node (AI), Typ) then\n+                  if Is_Ancestor (Node (AI), Typ) then\n                      Sec_DT_Tag :=\n                        New_Reference_To (DT_Ptr, Loc);\n                   else\n@@ -4471,7 +4528,7 @@ package body Exp_Disp is\n \n                      while Ekind (Node (Elmt)) = E_Constant\n                         and then not\n-                          Is_Parent (Node (AI), Related_Type (Node (Elmt)))\n+                          Is_Ancestor (Node (AI), Related_Type (Node (Elmt)))\n                      loop\n                         pragma Assert (Has_Thunks (Node (Elmt)));\n                         Next_Elmt (Elmt);\n@@ -4582,7 +4639,7 @@ package body Exp_Disp is\n          if Ada_Version >= Ada_05\n            and then Has_DT (Typ)\n            and then Is_Concurrent_Record_Type (Typ)\n-           and then Has_Abstract_Interfaces (Typ)\n+           and then Has_Interfaces (Typ)\n            and then Nb_Prim > 0\n            and then not Is_Abstract_Type (Typ)\n            and then not Is_Controlled (Typ)\n@@ -4999,7 +5056,7 @@ package body Exp_Disp is\n                   Prim := Node (Prim_Elmt);\n \n                   if Is_Imported (Prim)\n-                    or else Present (Abstract_Interface_Alias (Prim))\n+                    or else Present (Interface_Alias (Prim))\n                     or else Is_Predefined_Dispatching_Operation (Prim)\n                   then\n                      null;\n@@ -5015,7 +5072,7 @@ package body Exp_Disp is\n \n                      if not Is_Predefined_Dispatching_Operation (E)\n                        and then not Is_Abstract_Subprogram (E)\n-                       and then not Present (Abstract_Interface_Alias (E))\n+                       and then not Present (Interface_Alias (E))\n                      then\n                         pragma Assert\n                           (UI_To_Int (DT_Position (Prim)) <= Nb_Prim);\n@@ -5225,11 +5282,10 @@ package body Exp_Disp is\n                         Copy_Secondary_DTs (Etype (Typ));\n                      end if;\n \n-                     if Present (Abstract_Interfaces (Typ))\n-                       and then not Is_Empty_Elmt_List\n-                                      (Abstract_Interfaces (Typ))\n+                     if Present (Interfaces (Typ))\n+                       and then not Is_Empty_Elmt_List (Interfaces (Typ))\n                      then\n-                        Iface := First_Elmt (Abstract_Interfaces (Typ));\n+                        Iface := First_Elmt (Interfaces (Typ));\n                         E     := First_Entity (Typ);\n                         while Present (E)\n                           and then Present (Node (Sec_DT_Ancestor))\n@@ -5392,7 +5448,7 @@ package body Exp_Disp is\n \n       if Ada_Version >= Ada_05\n         and then Is_Concurrent_Record_Type (Typ)\n-        and then Has_Abstract_Interfaces (Typ)\n+        and then Has_Interfaces (Typ)\n       then\n          Append_List_To (Result,\n            Make_Select_Specific_Data_Table (Typ));\n@@ -5547,7 +5603,7 @@ package body Exp_Disp is\n \n             --  Look for primitive overriding an abstract interface subprogram\n \n-            if Present (Abstract_Interface_Alias (Prim))\n+            if Present (Interface_Alias (Prim))\n               and then not Examined (UI_To_Int (DT_Position (Alias (Prim))))\n             then\n                Prim_Pos := DT_Position (Alias (Prim));\n@@ -5626,7 +5682,7 @@ package body Exp_Disp is\n \n       --  Collect the components associated with secondary dispatch tables\n \n-      if Has_Abstract_Interfaces (Typ) then\n+      if Has_Interfaces (Typ) then\n          Collect_Interface_Components (Typ, Typ_Comps);\n       end if;\n \n@@ -5777,7 +5833,7 @@ package body Exp_Disp is\n \n       --  2) Generate the secondary tag entities\n \n-      if Has_Abstract_Interfaces (Typ) then\n+      if Has_Interfaces (Typ) then\n          Suffix_Index := 0;\n \n          --  For each interface type we build an unique external name\n@@ -6071,7 +6127,7 @@ package body Exp_Disp is\n          return;\n       end if;\n \n-      if not Present (Abstract_Interface_Alias (Prim)) then\n+      if not Present (Interface_Alias (Prim)) then\n          Tag_Typ := Scope (DTC_Entity (Prim));\n          Pos := DT_Position (Prim);\n          Tag := First_Tag_Component (Tag_Typ);\n@@ -6128,13 +6184,13 @@ package body Exp_Disp is\n \n       else\n          Tag_Typ   := Find_Dispatching_Type (Alias (Prim));\n-         Iface_Typ := Find_Dispatching_Type (Abstract_Interface_Alias (Prim));\n+         Iface_Typ := Find_Dispatching_Type (Interface_Alias (Prim));\n \n          pragma Assert (Is_Interface (Iface_Typ));\n \n          Expand_Interface_Thunk (Prim, Thunk_Id, Thunk_Code);\n \n-         if not Is_Parent (Iface_Typ, Tag_Typ)\n+         if not Is_Ancestor (Iface_Typ, Tag_Typ)\n            and then Present (Thunk_Code)\n          then\n             --  Comment needed on why checks are suppressed. This is not just\n@@ -6151,7 +6207,7 @@ package body Exp_Disp is\n             Iface_DT_Ptr  := Node (Iface_DT_Elmt);\n             pragma Assert (Has_Thunks (Iface_DT_Ptr));\n \n-            Iface_Prim := Abstract_Interface_Alias (Prim);\n+            Iface_Prim := Interface_Alias (Prim);\n             Pos        := DT_Position (Iface_Prim);\n             Tag        := First_Tag_Component (Iface_Typ);\n             L          := New_List;\n@@ -6263,7 +6319,7 @@ package body Exp_Disp is\n             --  Primitive operations covering abstract interfaces are\n             --  allocated later\n \n-            elsif Present (Abstract_Interface_Alias (Op)) then\n+            elsif Present (Interface_Alias (Op)) then\n                null;\n \n             --  Predefined dispatching operations are completely safe. They\n@@ -6343,6 +6399,8 @@ package body Exp_Disp is\n    --  Start of processing for Set_All_DT_Position\n \n    begin\n+      pragma Assert (Present (First_Tag_Component (Typ)));\n+\n       --  Set the DT_Position for each primitive operation. Perform some\n       --  sanity checks to avoid to build completely inconsistent dispatch\n       --  tables.\n@@ -6498,17 +6556,14 @@ package body Exp_Disp is\n \n             --  Overriding primitives of ancestor abstract interfaces\n \n-            elsif Present (Abstract_Interface_Alias (Prim))\n-              and then Is_Parent\n-                         (Find_Dispatching_Type\n-                           (Abstract_Interface_Alias (Prim)),\n-                          Typ)\n+            elsif Present (Interface_Alias (Prim))\n+              and then Is_Ancestor\n+                         (Find_Dispatching_Type (Interface_Alias (Prim)), Typ)\n             then\n                pragma Assert (DT_Position (Prim) = No_Uint\n-                 and then Present (DTC_Entity\n-                                    (Abstract_Interface_Alias (Prim))));\n+                 and then Present (DTC_Entity (Interface_Alias (Prim))));\n \n-               E := Abstract_Interface_Alias (Prim);\n+               E := Interface_Alias (Prim);\n                Set_DT_Position (Prim, DT_Position (E));\n \n                pragma Assert\n@@ -6520,11 +6575,11 @@ package body Exp_Disp is\n             --  Overriding primitives must use the same entry as the\n             --  overridden primitive.\n \n-            elsif not Present (Abstract_Interface_Alias (Prim))\n+            elsif not Present (Interface_Alias (Prim))\n               and then Present (Alias (Prim))\n               and then Chars (Prim) = Chars (Alias (Prim))\n               and then Find_Dispatching_Type (Alias (Prim)) /= Typ\n-              and then Is_Parent\n+              and then Is_Ancestor\n                          (Find_Dispatching_Type (Alias (Prim)), Typ)\n               and then Present (DTC_Entity (Alias (Prim)))\n             then\n@@ -6554,7 +6609,7 @@ package body Exp_Disp is\n \n             --  Primitives covering interface primitives are handled later\n \n-            elsif Present (Abstract_Interface_Alias (Prim)) then\n+            elsif Present (Interface_Alias (Prim)) then\n                null;\n \n             else\n@@ -6583,16 +6638,15 @@ package body Exp_Disp is\n          Prim := Node (Prim_Elmt);\n \n          if DT_Position (Prim) = No_Uint\n-           and then Present (Abstract_Interface_Alias (Prim))\n+           and then Present (Interface_Alias (Prim))\n          then\n             pragma Assert (Present (Alias (Prim))\n               and then Find_Dispatching_Type (Alias (Prim)) = Typ);\n \n             --  Check if this entry will be placed in the primary DT\n \n-            if Is_Parent (Find_Dispatching_Type\n-                           (Abstract_Interface_Alias (Prim)),\n-                          Typ)\n+            if Is_Ancestor\n+                (Find_Dispatching_Type (Interface_Alias (Prim)), Typ)\n             then\n                pragma Assert (DT_Position (Alias (Prim)) /= No_Uint);\n                Set_DT_Position (Prim, DT_Position (Alias (Prim)));\n@@ -6601,9 +6655,9 @@ package body Exp_Disp is\n \n             else\n                pragma Assert\n-                 (DT_Position (Abstract_Interface_Alias (Prim)) /= No_Uint);\n+                 (DT_Position (Interface_Alias (Prim)) /= No_Uint);\n                Set_DT_Position (Prim,\n-                 DT_Position (Abstract_Interface_Alias (Prim)));\n+                 DT_Position (Interface_Alias (Prim)));\n             end if;\n          end if;\n \n@@ -6666,14 +6720,16 @@ package body Exp_Disp is\n          --  point of declaration, but for inherited operations it must\n          --  be done when building the dispatch table.\n \n-         --  Ada 2005 (AI-251): Hidden entities associated with abstract\n-         --  interface primitives are not taken into account because the\n-         --  check is done with the aliased primitive.\n+         --  Ada 2005 (AI-251): Primitives associated with interfaces are\n+         --  excluded from this check because interfaces must be visible in\n+         --  the public and private part (RM 7.3 (7.3/2))\n \n          if Is_Abstract_Type (Typ)\n            and then Is_Abstract_Subprogram (Prim)\n            and then Present (Alias (Prim))\n-           and then not Present (Abstract_Interface_Alias (Prim))\n+           and then not Is_Interface\n+                          (Find_Dispatching_Type (Ultimate_Alias (Prim)))\n+           and then not Present (Interface_Alias (Prim))\n            and then Is_Derived_Type (Typ)\n            and then In_Private_Part (Current_Scope)\n            and then\n@@ -6789,16 +6845,14 @@ package body Exp_Disp is\n       Prim        : Entity_Id)\n    is\n    begin\n-      if Present (Abstract_Interface_Alias (Prim))\n+      if Present (Interface_Alias (Prim))\n         and then Is_Interface\n-                   (Find_Dispatching_Type\n-                     (Abstract_Interface_Alias (Prim)))\n+                   (Find_Dispatching_Type (Interface_Alias (Prim)))\n       then\n          Set_DTC_Entity (Prim,\n            Find_Interface_Tag\n              (T     => Tagged_Type,\n-              Iface => Find_Dispatching_Type\n-                        (Abstract_Interface_Alias (Prim))));\n+              Iface => Find_Dispatching_Type (Interface_Alias (Prim))));\n       else\n          Set_DTC_Entity (Prim,\n            First_Tag_Component (Tagged_Type));\n@@ -6927,12 +6981,12 @@ package body Exp_Disp is\n                Write_Name (Chars (Scope (DTC_Entity (Alias (Prim)))));\n             end if;\n \n-            if Present (Abstract_Interface_Alias (Prim)) then\n+            if Present (Interface_Alias (Prim)) then\n                Write_Str  (\", AI_Alias of \");\n-               Write_Name (Chars (Scope (DTC_Entity\n-                                          (Abstract_Interface_Alias (Prim)))));\n+               Write_Name\n+                 (Chars (Find_Dispatching_Type (Interface_Alias (Prim))));\n                Write_Char (':');\n-               Write_Int  (Int (Abstract_Interface_Alias (Prim)));\n+               Write_Int  (Int (Interface_Alias (Prim)));\n             end if;\n \n             Write_Str (\")\");"}, {"sha": "abdc949855e459a5503e444aba7e631ce5a7e998", "filename": "gcc/ada/exp_disp.ads", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fexp_disp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fexp_disp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.ads?ref=ce2b6ba521252796f61a25ada77f3e55ea97b36d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -212,6 +212,13 @@ package Exp_Disp is\n    --  Otherwise they are set to the defining identifier and the subprogram\n    --  body of the generated thunk.\n \n+   function Is_Predefined_Dispatching_Operation (E : Entity_Id) return Boolean;\n+   --  Ada 2005 (AI-251): Determines if E is a predefined primitive operation\n+\n+   function Is_Predefined_Interface_Primitive (E : Entity_Id) return Boolean;\n+   --  Ada 2005 (AI-345): Returns True if E is one of the predefined primitives\n+   --  required to implement interfaces.\n+\n    function Make_DT (Typ : Entity_Id; N : Node_Id := Empty) return List_Id;\n    --  Expand the declarations for the Dispatch Table. The node N is the\n    --  declaration that forces the generation of the table. It is used to place"}, {"sha": "a33bf0472a2e36d058eef66b71c8c9aeaa2b8dd3", "filename": "gcc/ada/exp_intr.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fexp_intr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fexp_intr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_intr.adb?ref=ce2b6ba521252796f61a25ada77f3e55ea97b36d", "patch": "@@ -45,6 +45,7 @@ with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n+with Sem_Type; use Sem_Type;\n with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n with Sinput;   use Sinput;\n@@ -165,7 +166,7 @@ package body Exp_Intr is\n          --  If the result type is not parent of Tag_Arg then we need to\n          --  locate the tag of the secondary dispatch table.\n \n-         if not Is_Parent (Etype (Result_Typ), Etype (Tag_Arg)) then\n+         if not Is_Ancestor (Etype (Result_Typ), Etype (Tag_Arg)) then\n             pragma Assert (not Is_Interface (Etype (Tag_Arg)));\n \n             Iface_Tag :="}, {"sha": "058c549525ec06223aedc3cb7e20eafe3dfdc44b", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 31, "deletions": 300, "changes": 331, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=ce2b6ba521252796f61a25ada77f3e55ea97b36d", "patch": "@@ -1386,73 +1386,8 @@ package body Exp_Util is\n      (T     : Entity_Id;\n       Iface : Entity_Id) return Elmt_Id\n    is\n-      ADT   : Elmt_Id;\n-      Found : Boolean   := False;\n-      Typ   : Entity_Id := T;\n-\n-      procedure Find_Secondary_Table (Typ : Entity_Id);\n-      --  Internal subprogram used to recursively climb to the ancestors\n-\n-      --------------------------\n-      -- Find_Secondary_Table --\n-      --------------------------\n-\n-      procedure Find_Secondary_Table (Typ : Entity_Id) is\n-         AI_Elmt : Elmt_Id;\n-         AI      : Node_Id;\n-\n-      begin\n-         pragma Assert (Typ /= Iface);\n-\n-         --  Climb to the ancestor (if any) handling synchronized interface\n-         --  derivations and private types\n-\n-         if Is_Concurrent_Record_Type (Typ) then\n-            declare\n-               Iface_List : constant List_Id := Abstract_Interface_List (Typ);\n-\n-            begin\n-               if Is_Non_Empty_List (Iface_List) then\n-                  Find_Secondary_Table (Etype (First (Iface_List)));\n-               end if;\n-            end;\n-\n-         elsif Present (Full_View (Etype (Typ))) then\n-            if Full_View (Etype (Typ)) /= Typ then\n-               Find_Secondary_Table (Full_View (Etype (Typ)));\n-            end if;\n-\n-         elsif Etype (Typ) /= Typ then\n-            Find_Secondary_Table (Etype (Typ));\n-         end if;\n-\n-         --  Traverse the list of interfaces implemented by the type\n-\n-         if not Found\n-           and then Present (Abstract_Interfaces (Typ))\n-           and then not Is_Empty_Elmt_List (Abstract_Interfaces (Typ))\n-         then\n-            AI_Elmt := First_Elmt (Abstract_Interfaces (Typ));\n-            while Present (AI_Elmt) loop\n-               AI := Node (AI_Elmt);\n-\n-               if AI = Iface or else Is_Ancestor (Iface, AI) then\n-                  Found := True;\n-                  return;\n-               end if;\n-\n-               --  Document what is going on here, why four Next's???\n-\n-               Next_Elmt (ADT);\n-               Next_Elmt (ADT);\n-               Next_Elmt (ADT);\n-               Next_Elmt (ADT);\n-               Next_Elmt (AI_Elmt);\n-            end loop;\n-         end if;\n-      end Find_Secondary_Table;\n-\n-   --  Start of processing for Find_Interface_ADT\n+      ADT : Elmt_Id;\n+      Typ : Entity_Id := T;\n \n    begin\n       pragma Assert (Is_Interface (Iface));\n@@ -1481,11 +1416,23 @@ package body Exp_Util is\n         (not Is_Class_Wide_Type (Typ)\n           and then Ekind (Typ) /= E_Incomplete_Type);\n \n-      ADT := Next_Elmt (Next_Elmt (First_Elmt (Access_Disp_Table (Typ))));\n-      pragma Assert (Present (Node (ADT)));\n-      Find_Secondary_Table (Typ);\n-      pragma Assert (Found);\n-      return ADT;\n+      if Is_Ancestor (Iface, Typ) then\n+         return First_Elmt (Access_Disp_Table (Typ));\n+\n+      else\n+         ADT :=\n+           Next_Elmt (Next_Elmt (First_Elmt (Access_Disp_Table (Typ))));\n+         while Present (ADT)\n+           and then Present (Related_Type (Node (ADT)))\n+           and then Related_Type (Node (ADT)) /= Iface\n+           and then not Is_Ancestor (Iface, Related_Type (Node (ADT)))\n+         loop\n+            Next_Elmt (ADT);\n+         end loop;\n+\n+         pragma Assert (Present (Related_Type (Node (ADT))));\n+         return ADT;\n+      end if;\n    end Find_Interface_ADT;\n \n    ------------------------\n@@ -1500,14 +1447,6 @@ package body Exp_Util is\n       Found  : Boolean   := False;\n       Typ    : Entity_Id := T;\n \n-      Is_Primary_Tag : Boolean := False;\n-\n-      Is_Sync_Typ : Boolean := False;\n-      --  In case of non concurrent-record-types each parent-type has the\n-      --  tags associated with the interface types that are not implemented\n-      --  by the ancestors; concurrent-record-types have their whole list of\n-      --  interface tags (and this case requires some special management).\n-\n       procedure Find_Tag (Typ : Entity_Id);\n       --  Internal subprogram used to recursively climb to the ancestors\n \n@@ -1524,32 +1463,15 @@ package body Exp_Util is\n          --  therefore shares the main tag.\n \n          if Typ = Iface then\n-            if Is_Sync_Typ then\n-               Is_Primary_Tag := True;\n-            else\n-               pragma Assert\n-                 (Etype (First_Tag_Component (Typ)) = RTE (RE_Tag));\n-               AI_Tag := First_Tag_Component (Typ);\n-            end if;\n-\n+            pragma Assert (Etype (First_Tag_Component (Typ)) = RTE (RE_Tag));\n+            AI_Tag := First_Tag_Component (Typ);\n             Found  := True;\n             return;\n          end if;\n \n-         --  Handle synchronized interface derivations\n-\n-         if Is_Concurrent_Record_Type (Typ) then\n-            declare\n-               Iface_List : constant List_Id := Abstract_Interface_List (Typ);\n-            begin\n-               if Is_Non_Empty_List (Iface_List) then\n-                  Find_Tag (Etype (First (Iface_List)));\n-               end if;\n-            end;\n-\n          --  Climb to the root type handling private types\n \n-         elsif Present (Full_View (Etype (Typ))) then\n+         if Present (Full_View (Etype (Typ))) then\n             if Full_View (Etype (Typ)) /= Typ then\n                Find_Tag (Full_View (Etype (Typ)));\n             end if;\n@@ -1561,19 +1483,16 @@ package body Exp_Util is\n          --  Traverse the list of interfaces implemented by the type\n \n          if not Found\n-           and then Present (Abstract_Interfaces (Typ))\n-           and then not (Is_Empty_Elmt_List (Abstract_Interfaces (Typ)))\n+           and then Present (Interfaces (Typ))\n+           and then not (Is_Empty_Elmt_List (Interfaces (Typ)))\n          then\n             --  Skip the tag associated with the primary table\n \n-            if not Is_Sync_Typ then\n-               pragma Assert\n-                 (Etype (First_Tag_Component (Typ)) = RTE (RE_Tag));\n-               AI_Tag := Next_Tag_Component (First_Tag_Component (Typ));\n-               pragma Assert (Present (AI_Tag));\n-            end if;\n+            pragma Assert (Etype (First_Tag_Component (Typ)) = RTE (RE_Tag));\n+            AI_Tag := Next_Tag_Component (First_Tag_Component (Typ));\n+            pragma Assert (Present (AI_Tag));\n \n-            AI_Elmt := First_Elmt (Abstract_Interfaces (Typ));\n+            AI_Elmt := First_Elmt (Interfaces (Typ));\n             while Present (AI_Elmt) loop\n                AI := Node (AI_Elmt);\n \n@@ -1624,149 +1543,10 @@ package body Exp_Util is\n          Typ := Non_Limited_View (Typ);\n       end if;\n \n-      if not Is_Concurrent_Record_Type (Typ) then\n-         Find_Tag (Typ);\n-         pragma Assert (Found);\n-         return AI_Tag;\n-\n-      --  Concurrent record types\n-\n-      else\n-         Is_Sync_Typ := True;\n-         AI_Tag      := Next_Tag_Component (First_Tag_Component (Typ));\n-         Find_Tag (Typ);\n-         pragma Assert (Found);\n-\n-         if Is_Primary_Tag then\n-            return First_Tag_Component (Typ);\n-         else\n-            return AI_Tag;\n-         end if;\n-      end if;\n-   end Find_Interface_Tag;\n-\n-   --------------------\n-   -- Find_Interface --\n-   --------------------\n-\n-   function Find_Interface\n-     (T      : Entity_Id;\n-      Comp   : Entity_Id) return Entity_Id\n-   is\n-      AI_Tag : Entity_Id;\n-      Found  : Boolean := False;\n-      Iface  : Entity_Id;\n-      Typ    : Entity_Id := T;\n-\n-      Is_Sync_Typ : Boolean := False;\n-      --  In case of non concurrent-record-types each parent-type has the\n-      --  tags associated with the interface types that are not implemented\n-      --  by the ancestors; concurrent-record-types have their whole list of\n-      --  interface tags (and this case requires some special management).\n-\n-      procedure Find_Iface (Typ : Entity_Id);\n-      --  Internal subprogram used to recursively climb to the ancestors\n-\n-      ----------------\n-      -- Find_Iface --\n-      ----------------\n-\n-      procedure Find_Iface (Typ : Entity_Id) is\n-         AI_Elmt : Elmt_Id;\n-\n-      begin\n-         --  Climb to the root type\n-\n-         --  Handle synchronized interface derivations\n-\n-         if Is_Concurrent_Record_Type (Typ) then\n-            declare\n-               Iface_List : constant List_Id := Abstract_Interface_List (Typ);\n-            begin\n-               if Is_Non_Empty_List (Iface_List) then\n-                  Find_Iface (Etype (First (Iface_List)));\n-               end if;\n-            end;\n-\n-         --  Handle the common case\n-\n-         elsif Etype (Typ) /= Typ then\n-            pragma Assert (not Present (Full_View (Etype (Typ))));\n-            Find_Iface (Etype (Typ));\n-         end if;\n-\n-         --  Traverse the list of interfaces implemented by the type\n-\n-         if not Found\n-           and then Present (Abstract_Interfaces (Typ))\n-           and then not (Is_Empty_Elmt_List (Abstract_Interfaces (Typ)))\n-         then\n-            --  Skip the tag associated with the primary table\n-\n-            if not Is_Sync_Typ then\n-               pragma Assert\n-                 (Etype (First_Tag_Component (Typ)) = RTE (RE_Tag));\n-               AI_Tag := Next_Tag_Component (First_Tag_Component (Typ));\n-               pragma Assert (Present (AI_Tag));\n-            end if;\n-\n-            AI_Elmt := First_Elmt (Abstract_Interfaces (Typ));\n-            while Present (AI_Elmt) loop\n-               if AI_Tag = Comp then\n-                  Iface := Node (AI_Elmt);\n-                  Found := True;\n-                  return;\n-               end if;\n-\n-               AI_Tag := Next_Tag_Component (AI_Tag);\n-               Next_Elmt (AI_Elmt);\n-            end loop;\n-         end if;\n-      end Find_Iface;\n-\n-   --  Start of processing for Find_Interface\n-\n-   begin\n-      --  Handle private types\n-\n-      if Has_Private_Declaration (Typ)\n-        and then Present (Full_View (Typ))\n-      then\n-         Typ := Full_View (Typ);\n-      end if;\n-\n-      --  Handle access types\n-\n-      if Is_Access_Type (Typ) then\n-         Typ := Directly_Designated_Type (Typ);\n-      end if;\n-\n-      --  Handle task and protected types implementing interfaces\n-\n-      if Is_Concurrent_Type (Typ) then\n-         Typ := Corresponding_Record_Type (Typ);\n-      end if;\n-\n-      if Is_Class_Wide_Type (Typ) then\n-         Typ := Etype (Typ);\n-      end if;\n-\n-      --  Handle entities from the limited view\n-\n-      if Ekind (Typ) = E_Incomplete_Type then\n-         pragma Assert (Present (Non_Limited_View (Typ)));\n-         Typ := Non_Limited_View (Typ);\n-      end if;\n-\n-      if Is_Concurrent_Record_Type (Typ) then\n-         Is_Sync_Typ := True;\n-         AI_Tag      := Next_Tag_Component (First_Tag_Component (Typ));\n-      end if;\n-\n-      Find_Iface (Typ);\n+      Find_Tag (Typ);\n       pragma Assert (Found);\n-      return Iface;\n-   end Find_Interface;\n+      return AI_Tag;\n+   end Find_Interface_Tag;\n \n    ------------------\n    -- Find_Prim_Op --\n@@ -3062,55 +2842,6 @@ package body Exp_Util is\n         and then Is_Library_Level_Entity (Typ);\n    end Is_Library_Level_Tagged_Type;\n \n-   -----------------------------------------\n-   -- Is_Predefined_Dispatching_Operation --\n-   -----------------------------------------\n-\n-   function Is_Predefined_Dispatching_Operation (E : Entity_Id) return Boolean\n-   is\n-      TSS_Name : TSS_Name_Type;\n-\n-   begin\n-      if not Is_Dispatching_Operation (E) then\n-         return False;\n-      end if;\n-\n-      Get_Name_String (Chars (E));\n-\n-      --  Most predefined primitives have internally generated names. Equality\n-      --  must be treated differently; the predefined operation is recognized\n-      --  as a homogeneous binary operator that returns Boolean.\n-\n-      if Name_Len > TSS_Name_Type'Last then\n-         TSS_Name := TSS_Name_Type (Name_Buffer (Name_Len - TSS_Name'Length + 1\n-                                     .. Name_Len));\n-         if Chars (E)        = Name_uSize\n-           or else Chars (E) = Name_uAlignment\n-           or else TSS_Name  = TSS_Stream_Read\n-           or else TSS_Name  = TSS_Stream_Write\n-           or else TSS_Name  = TSS_Stream_Input\n-           or else TSS_Name  = TSS_Stream_Output\n-           or else\n-             (Chars (E) = Name_Op_Eq\n-                and then Etype (First_Entity (E)) = Etype (Last_Entity (E)))\n-           or else Chars (E) = Name_uAssign\n-           or else TSS_Name  = TSS_Deep_Adjust\n-           or else TSS_Name  = TSS_Deep_Finalize\n-           or else (Ada_Version >= Ada_05\n-                      and then (Chars (E) = Name_uDisp_Asynchronous_Select\n-                        or else Chars (E) = Name_uDisp_Conditional_Select\n-                        or else Chars (E) = Name_uDisp_Get_Prim_Op_Kind\n-                        or else Chars (E) = Name_uDisp_Get_Task_Id\n-                        or else Chars (E) = Name_uDisp_Requeue\n-                        or else Chars (E) = Name_uDisp_Timed_Select))\n-         then\n-            return True;\n-         end if;\n-      end if;\n-\n-      return False;\n-   end Is_Predefined_Dispatching_Operation;\n-\n    ----------------------------------\n    -- Is_Possibly_Unaligned_Object --\n    ----------------------------------"}, {"sha": "5f35d4eff1d9129cced891a498fdf3635922b938", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=ce2b6ba521252796f61a25ada77f3e55ea97b36d", "patch": "@@ -342,13 +342,6 @@ package Exp_Util is\n    --  declarations and/or allocations when the type is indefinite (including\n    --  class-wide).\n \n-   function Find_Interface\n-     (T    : Entity_Id;\n-      Comp : Entity_Id) return Entity_Id;\n-   --  Ada 2005 (AI-251): Given a tagged type and one of its components\n-   --  associated with the secondary dispatch table of an abstract interface\n-   --  type, return the associated abstract interface type.\n-\n    function Find_Interface_ADT\n      (T     : Entity_Id;\n       Iface : Entity_Id) return Elmt_Id;\n@@ -462,9 +455,6 @@ package Exp_Util is\n    --  Return True if Typ is a library level tagged type. Currently we use\n    --  this information to build statically allocated dispatch tables.\n \n-   function Is_Predefined_Dispatching_Operation (E : Entity_Id) return Boolean;\n-   --  Ada 2005 (AI-251): Determines if E is a predefined primitive operation\n-\n    function Is_Ref_To_Bit_Packed_Array (N : Node_Id) return Boolean;\n    --  Determine whether the node P is a reference to a bit packed array, i.e.\n    --  whether the designated object is a component of a bit packed array, or a"}, {"sha": "bf4f94677e8ed84d24405d992072902f1a485ab8", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=ce2b6ba521252796f61a25ada77f3e55ea97b36d", "patch": "@@ -30,6 +30,7 @@ with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Errout;   use Errout;\n with Exp_Ch7;  use Exp_Ch7;\n+with Exp_Disp; use Exp_Disp;\n with Exp_Pakd; use Exp_Pakd;\n with Exp_Util; use Exp_Util;\n with Exp_Tss;  use Exp_Tss;"}, {"sha": "8af553fef5993afd2943c690e8cc0215fc39c10c", "filename": "gcc/ada/lib-xref.adb", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Flib-xref.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Flib-xref.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.adb?ref=ce2b6ba521252796f61a25ada77f3e55ea97b36d", "patch": "@@ -1150,16 +1150,14 @@ package body Lib.Xref is\n                New_Entry (Tref);\n \n                if Is_Record_Type (Ent)\n-                 and then Present (Abstract_Interfaces (Ent))\n+                 and then Present (Interfaces (Ent))\n                then\n                   --  Add an entry for each one of the given interfaces\n                   --  implemented by type Ent.\n \n                   declare\n-                     Elmt : Elmt_Id;\n-\n+                     Elmt : Elmt_Id := First_Elmt (Interfaces (Ent));\n                   begin\n-                     Elmt := First_Elmt (Abstract_Interfaces (Ent));\n                      while Present (Elmt) loop\n                         New_Entry (Node (Elmt));\n                         Next_Elmt (Elmt);\n@@ -2032,13 +2030,11 @@ package body Lib.Xref is\n                      --  Additional information for types with progenitors\n \n                      if Is_Record_Type (XE.Ent)\n-                       and then Present (Abstract_Interfaces (XE.Ent))\n+                       and then Present (Interfaces (XE.Ent))\n                      then\n                         declare\n-                           Elmt : Elmt_Id;\n-\n+                           Elmt : Elmt_Id := First_Elmt (Interfaces (XE.Ent));\n                         begin\n-                           Elmt := First_Elmt (Abstract_Interfaces (XE.Ent));\n                            while Present (Elmt) loop\n                               Check_Type_Reference (Node (Elmt), True);\n                               Next_Elmt (Elmt);"}, {"sha": "3e4a036fb8dd5bdd9d20ced7a555a48b2aaf8a5d", "filename": "gcc/ada/sem_cat.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fsem_cat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fsem_cat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_cat.adb?ref=ce2b6ba521252796f61a25ada77f3e55ea97b36d", "patch": "@@ -28,7 +28,7 @@ with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Errout;   use Errout;\n-with Exp_Util; use Exp_Util;\n+with Exp_Disp; use Exp_Disp;\n with Fname;    use Fname;\n with Lib;      use Lib;\n with Namet;    use Namet;"}, {"sha": "4a7c91f1c95bde47041c2fe03e8f00f374b88b76", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=ce2b6ba521252796f61a25ada77f3e55ea97b36d", "patch": "@@ -9268,7 +9268,7 @@ package body Sem_Ch12 is\n          --  Now verify that the actual includes all other ancestors of\n          --  the formal.\n \n-         Elmt := First_Elmt (Abstract_Interfaces (A_Gen_T));\n+         Elmt := First_Elmt (Interfaces (A_Gen_T));\n          while Present (Elmt) loop\n             if not Interface_Present_In_Ancestor\n                      (Act_T, Get_Instance_Of (Node (Elmt)))\n@@ -9575,7 +9575,6 @@ package body Sem_Ch12 is\n \n                function Is_Tagged_Ancestor (T1, T2 : Entity_Id) return Boolean\n                is\n-                  Interfaces : Elist_Id;\n                   Intfc_Elmt : Elmt_Id;\n \n                begin\n@@ -9599,9 +9598,7 @@ package body Sem_Ch12 is\n                   --  progenitors.\n \n                   else\n-                     Interfaces := Abstract_Interfaces (T2);\n-\n-                     Intfc_Elmt := First_Elmt (Interfaces);\n+                     Intfc_Elmt := First_Elmt (Interfaces (T2));\n                      while Present (Intfc_Elmt) loop\n                         if Is_Ancestor (T1, Node (Intfc_Elmt)) then\n                            return True;"}, {"sha": "a3f036ade2527235992c906c3b2a689b86fe6e28", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 750, "deletions": 665, "changes": 1415, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=ce2b6ba521252796f61a25ada77f3e55ea97b36d", "patch": "@@ -31,6 +31,7 @@ with Einfo;    use Einfo;\n with Errout;   use Errout;\n with Eval_Fat; use Eval_Fat;\n with Exp_Ch3;  use Exp_Ch3;\n+with Exp_Disp; use Exp_Disp;\n with Exp_Dist; use Exp_Dist;\n with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n@@ -253,9 +254,6 @@ package body Sem_Ch3 is\n    --  view cannot itself have a full view (it would get clobbered during\n    --  view exchanges).\n \n-   procedure Check_Abstract_Interfaces (N : Node_Id; Def : Node_Id);\n-   --  Check ARM rules 3.9.4 (15/2), 9.1 (9.d/2) and 9.4 (11.d/2)\n-\n    procedure Check_Access_Discriminant_Requires_Limited\n      (D   : Node_Id;\n       Loc : Node_Id);\n@@ -289,6 +287,9 @@ package body Sem_Ch3 is\n    --  Validate the initialization of an object declaration. T is the required\n    --  type, and Exp is the initialization expression.\n \n+   procedure Check_Interfaces (N : Node_Id; Def : Node_Id);\n+   --  Check ARM rules 3.9.4 (15/2), 9.1 (9.d/2) and 9.4 (11.d/2)\n+\n    procedure Check_Or_Process_Discriminants\n      (N    : Node_Id;\n       T    : Entity_Id;\n@@ -486,14 +487,16 @@ package body Sem_Ch3 is\n    --  appropriate semantic fields. If the full view of the parent is a record\n    --  type, build constrained components of subtype.\n \n-   procedure Derive_Interface_Subprograms\n+   procedure Derive_Progenitor_Subprograms\n      (Parent_Type : Entity_Id;\n-      Tagged_Type : Entity_Id;\n-      Ifaces_List : Elist_Id);\n-   --  Ada 2005 (AI-251): Derive primitives of abstract interface types that\n-   --  are not immediate ancestors of Tagged type and associate them their\n-   --  aliased primitive. Ifaces_List contains the abstract interface\n-   --  primitives that have been derived from Parent_Type.\n+      Tagged_Type : Entity_Id);\n+   --  Ada 2005 (AI-251): To complete type derivation, collect the primitive\n+   --  operations of progenitors of Tagged_Type, and replace the subsidiary\n+   --  subtypes with Tagged_Type, to build the specs of the inherited interface\n+   --  primitives. The derived primitives are aliased to those of the\n+   --  interface. This routine takes care also of transferring to the full-view\n+   --  subprograms associated with the partial-view of Tagged_Type that cover\n+   --  interface primitives.\n \n    procedure Derived_Standard_Character\n      (N             : Node_Id;\n@@ -1273,36 +1276,12 @@ package body Sem_Ch3 is\n \n    procedure Add_Interface_Tag_Components (N : Node_Id; Typ : Entity_Id) is\n       Loc      : constant Source_Ptr := Sloc (N);\n-      Elmt     : Elmt_Id;\n-      Ext      : Node_Id;\n       L        : List_Id;\n       Last_Tag : Node_Id;\n-      Comp     : Node_Id;\n-\n-      procedure Add_Sync_Iface_Tags (T : Entity_Id);\n-      --  Local subprogram used to recursively climb through the parents\n-      --  of T to add the tags of all the progenitor interfaces.\n \n       procedure Add_Tag (Iface : Entity_Id);\n       --  Add tag for one of the progenitor interfaces\n \n-      -------------------------\n-      -- Add_Sync_Iface_Tags --\n-      -------------------------\n-\n-      procedure Add_Sync_Iface_Tags (T : Entity_Id) is\n-      begin\n-         if Etype (T) /= T then\n-            Add_Sync_Iface_Tags (Etype (T));\n-         end if;\n-\n-         Elmt := First_Elmt (Abstract_Interfaces (T));\n-         while Present (Elmt) loop\n-            Add_Tag (Node (Elmt));\n-            Next_Elmt (Elmt);\n-         end loop;\n-      end Add_Sync_Iface_Tags;\n-\n       -------------\n       -- Add_Tag --\n       -------------\n@@ -1387,7 +1366,9 @@ package body Sem_Ch3 is\n \n       --  Local variables\n \n-      Iface_List : List_Id;\n+      Elmt : Elmt_Id;\n+      Ext  : Node_Id;\n+      Comp : Node_Id;\n \n    --  Start of processing for Add_Interface_Tag_Components\n \n@@ -1403,8 +1384,8 @@ package body Sem_Ch3 is\n         or else (Is_Concurrent_Record_Type (Typ)\n                   and then Is_Empty_List (Abstract_Interface_List (Typ)))\n         or else (not Is_Concurrent_Record_Type (Typ)\n-                  and then No (Abstract_Interfaces (Typ))\n-                  and then Is_Empty_Elmt_List (Abstract_Interfaces (Typ)))\n+                  and then No (Interfaces (Typ))\n+                  and then Is_Empty_Elmt_List (Interfaces (Typ)))\n       then\n          return;\n       end if;\n@@ -1458,16 +1439,8 @@ package body Sem_Ch3 is\n       --  corresponding with all the interfaces that are not implemented\n       --  by the parent.\n \n-      if Is_Concurrent_Record_Type (Typ) then\n-         Iface_List := Abstract_Interface_List (Typ);\n-\n-         if Is_Non_Empty_List (Iface_List) then\n-            Add_Sync_Iface_Tags (Etype (First (Iface_List)));\n-         end if;\n-      end if;\n-\n-      if Present (Abstract_Interfaces (Typ)) then\n-         Elmt := First_Elmt (Abstract_Interfaces (Typ));\n+      if Present (Interfaces (Typ)) then\n+         Elmt := First_Elmt (Interfaces (Typ));\n          while Present (Elmt) loop\n             Add_Tag (Node (Elmt));\n             Next_Elmt (Elmt);\n@@ -1993,18 +1966,18 @@ package body Sem_Ch3 is\n       CW : constant Entity_Id := Class_Wide_Type (T);\n \n    begin\n-      Set_Is_Tagged_Type      (T);\n+      Set_Is_Tagged_Type (T);\n \n-      Set_Is_Limited_Record   (T, Limited_Present (Def)\n-                                   or else Task_Present (Def)\n-                                   or else Protected_Present (Def)\n-                                   or else Synchronized_Present (Def));\n+      Set_Is_Limited_Record (T, Limited_Present (Def)\n+                                  or else Task_Present (Def)\n+                                  or else Protected_Present (Def)\n+                                  or else Synchronized_Present (Def));\n \n       --  Type is abstract if full declaration carries keyword, or if previous\n       --  partial view did.\n \n       Set_Is_Abstract_Type (T);\n-      Set_Is_Interface     (T);\n+      Set_Is_Interface (T);\n \n       --  Type is a limited interface if it includes the keyword limited, task,\n       --  protected, or synchronized.\n@@ -2015,8 +1988,8 @@ package body Sem_Ch3 is\n               or else Synchronized_Present (Def)\n               or else Task_Present (Def));\n \n-      Set_Is_Protected_Interface    (T, Protected_Present (Def));\n-      Set_Is_Task_Interface         (T, Task_Present (Def));\n+      Set_Is_Protected_Interface (T, Protected_Present (Def));\n+      Set_Is_Task_Interface (T, Task_Present (Def));\n \n       --  Type is a synchronized interface if it includes the keyword task,\n       --  protected, or synchronized.\n@@ -2026,8 +1999,8 @@ package body Sem_Ch3 is\n               or else Protected_Present (Def)\n               or else Task_Present (Def));\n \n-      Set_Abstract_Interfaces       (T, New_Elmt_List);\n-      Set_Primitive_Operations      (T, New_Elmt_List);\n+      Set_Interfaces (T, New_Elmt_List);\n+      Set_Primitive_Operations (T, New_Elmt_List);\n \n       --  Complete the decoration of the class-wide entity if it was already\n       --  built (i.e. during the creation of the limited view)\n@@ -3236,13 +3209,13 @@ package body Sem_Ch3 is\n             --  The progenitors (if any) must be limited or synchronized\n             --  interfaces.\n \n-            if Present (Abstract_Interfaces (T)) then\n+            if Present (Interfaces (T)) then\n                declare\n                   Iface      : Entity_Id;\n                   Iface_Elmt : Elmt_Id;\n \n                begin\n-                  Iface_Elmt := First_Elmt (Abstract_Interfaces (T));\n+                  Iface_Elmt := First_Elmt (Interfaces (T));\n                   while Present (Iface_Elmt) loop\n                      Iface := Node (Iface_Elmt);\n \n@@ -6770,7 +6743,7 @@ package body Sem_Ch3 is\n             Analyze_Interface_Declaration (Derived_Type, Type_Def);\n          end if;\n \n-         Set_Abstract_Interfaces (Derived_Type, No_Elist);\n+         Set_Interfaces (Derived_Type, No_Elist);\n       end if;\n \n       --  Fields inherited from the Parent_Type\n@@ -6804,9 +6777,9 @@ package body Sem_Ch3 is\n \n       if Is_Record_Type (Derived_Type) then\n          Set_OK_To_Reorder_Components\n-           (Derived_Type, OK_To_Reorder_Components   (Parent_Base));\n+           (Derived_Type, OK_To_Reorder_Components (Parent_Base));\n          Set_Reverse_Bit_Order\n-           (Derived_Type, Reverse_Bit_Order          (Parent_Base));\n+           (Derived_Type, Reverse_Bit_Order (Parent_Base));\n       end if;\n \n       --  Direct controlled types do not inherit Finalize_Storage_Only flag\n@@ -6896,16 +6869,17 @@ package body Sem_Ch3 is\n \n                --  Check ARM rules 3.9.4 (15/2), 9.1 (9.d/2) and 9.4 (11.d/2)\n \n-               Check_Abstract_Interfaces (N, Type_Def);\n+               Check_Interfaces (N, Type_Def);\n \n                --  Ada 2005 (AI-251): Collect the list of progenitors that are\n                --  not already in the parents.\n \n-               Collect_Abstract_Interfaces\n-                 (T                         => Derived_Type,\n-                  Ifaces_List               => Ifaces_List,\n-                  Exclude_Parent_Interfaces => True);\n-               Set_Abstract_Interfaces (Derived_Type, Ifaces_List);\n+               Collect_Interfaces\n+                 (T               => Derived_Type,\n+                  Ifaces_List     => Ifaces_List,\n+                  Exclude_Parents => True);\n+\n+               Set_Interfaces (Derived_Type, Ifaces_List);\n             end;\n          end if;\n \n@@ -7003,7 +6977,7 @@ package body Sem_Ch3 is\n          --  implemented interfaces if we are in expansion mode\n \n          if Expander_Active\n-           and then Has_Abstract_Interfaces (Derived_Type)\n+           and then Has_Interfaces (Derived_Type)\n          then\n             Add_Interface_Tag_Components (N, Derived_Type);\n          end if;\n@@ -7887,236 +7861,6 @@ package body Sem_Ch3 is\n       Set_Underlying_Full_View (Typ, Full_View (Subt));\n    end Build_Underlying_Full_View;\n \n-   -------------------------------\n-   -- Check_Abstract_Interfaces --\n-   -------------------------------\n-\n-   procedure Check_Abstract_Interfaces (N : Node_Id; Def : Node_Id) is\n-      Parent_Type : constant Entity_Id := Etype (Defining_Identifier (N));\n-\n-      Iface       : Node_Id;\n-      Iface_Def   : Node_Id;\n-      Iface_Typ   : Entity_Id;\n-      Parent_Node : Node_Id;\n-\n-      Is_Task : Boolean := False;\n-      --  Set True if parent type or any progenitor is a task interface\n-\n-      Is_Protected : Boolean := False;\n-      --  Set True if parent type or any progenitor is a protected interface\n-\n-      procedure Check_Ifaces (Iface_Def : Node_Id; Error_Node : Node_Id);\n-      --  Check that a progenitor is compatible with declaration.\n-      --  Error is posted on Error_Node.\n-\n-      ------------------\n-      -- Check_Ifaces --\n-      ------------------\n-\n-      procedure Check_Ifaces (Iface_Def : Node_Id; Error_Node : Node_Id) is\n-         Iface_Id : constant Entity_Id :=\n-                      Defining_Identifier (Parent (Iface_Def));\n-         Type_Def : Node_Id;\n-\n-      begin\n-         if Nkind (N) = N_Private_Extension_Declaration then\n-            Type_Def := N;\n-         else\n-            Type_Def := Type_Definition (N);\n-         end if;\n-\n-         if Is_Task_Interface (Iface_Id) then\n-            Is_Task := True;\n-\n-         elsif Is_Protected_Interface (Iface_Id) then\n-            Is_Protected := True;\n-         end if;\n-\n-         --  Check that the characteristics of the progenitor are compatible\n-         --  with the explicit qualifier in the declaration.\n-         --  The check only applies to qualifiers that come from source.\n-         --  Limited_Present also appears in the declaration of corresponding\n-         --  records, and the check does not apply to them.\n-\n-         if Limited_Present (Type_Def)\n-           and then not\n-             Is_Concurrent_Record_Type (Defining_Identifier (N))\n-         then\n-            if Is_Limited_Interface (Parent_Type)\n-              and then not Is_Limited_Interface (Iface_Id)\n-            then\n-               Error_Msg_NE\n-                 (\"progenitor& must be limited interface\",\n-                   Error_Node, Iface_Id);\n-\n-            elsif\n-              (Task_Present (Iface_Def)\n-                or else Protected_Present (Iface_Def)\n-                or else Synchronized_Present (Iface_Def))\n-              and then Nkind (N) /= N_Private_Extension_Declaration\n-            then\n-               Error_Msg_NE\n-                 (\"progenitor& must be limited interface\",\n-                   Error_Node, Iface_Id);\n-            end if;\n-\n-         --  Protected interfaces can only inherit from limited, synchronized\n-         --  or protected interfaces.\n-\n-         elsif Nkind (N) = N_Full_Type_Declaration\n-           and then  Protected_Present (Type_Def)\n-         then\n-            if Limited_Present (Iface_Def)\n-              or else Synchronized_Present (Iface_Def)\n-              or else Protected_Present (Iface_Def)\n-            then\n-               null;\n-\n-            elsif Task_Present (Iface_Def) then\n-               Error_Msg_N (\"(Ada 2005) protected interface cannot inherit\"\n-                            & \" from task interface\", Error_Node);\n-\n-            else\n-               Error_Msg_N (\"(Ada 2005) protected interface cannot inherit\"\n-                            & \" from non-limited interface\", Error_Node);\n-            end if;\n-\n-         --  Ada 2005 (AI-345): Synchronized interfaces can only inherit from\n-         --  limited and synchronized.\n-\n-         elsif Synchronized_Present (Type_Def) then\n-            if Limited_Present (Iface_Def)\n-              or else Synchronized_Present (Iface_Def)\n-            then\n-               null;\n-\n-            elsif Protected_Present (Iface_Def)\n-              and then Nkind (N) /= N_Private_Extension_Declaration\n-            then\n-               Error_Msg_N (\"(Ada 2005) synchronized interface cannot inherit\"\n-                            & \" from protected interface\", Error_Node);\n-\n-            elsif Task_Present (Iface_Def)\n-              and then Nkind (N) /= N_Private_Extension_Declaration\n-            then\n-               Error_Msg_N (\"(Ada 2005) synchronized interface cannot inherit\"\n-                            & \" from task interface\", Error_Node);\n-\n-            elsif not Is_Limited_Interface (Iface_Id) then\n-               Error_Msg_N (\"(Ada 2005) synchronized interface cannot inherit\"\n-                            & \" from non-limited interface\", Error_Node);\n-            end if;\n-\n-         --  Ada 2005 (AI-345): Task interfaces can only inherit from limited,\n-         --  synchronized or task interfaces.\n-\n-         elsif Nkind (N) = N_Full_Type_Declaration\n-           and then Task_Present (Type_Def)\n-         then\n-            if Limited_Present (Iface_Def)\n-              or else Synchronized_Present (Iface_Def)\n-              or else Task_Present (Iface_Def)\n-            then\n-               null;\n-\n-            elsif Protected_Present (Iface_Def) then\n-               Error_Msg_N (\"(Ada 2005) task interface cannot inherit from\"\n-                            & \" protected interface\", Error_Node);\n-\n-            else\n-               Error_Msg_N (\"(Ada 2005) task interface cannot inherit from\"\n-                            & \" non-limited interface\", Error_Node);\n-            end if;\n-         end if;\n-      end Check_Ifaces;\n-\n-   --  Start of processing for Check_Abstract_Interfaces\n-\n-   begin\n-      if Is_Interface (Parent_Type) then\n-         if Is_Task_Interface (Parent_Type) then\n-            Is_Task := True;\n-\n-         elsif Is_Protected_Interface (Parent_Type) then\n-            Is_Protected := True;\n-         end if;\n-      end if;\n-\n-      if Nkind (N) = N_Private_Extension_Declaration then\n-\n-         --  Check that progenitors are compatible with declaration\n-\n-         Iface := First (Interface_List (Def));\n-         while Present (Iface) loop\n-            Iface_Typ := Find_Type_Of_Subtype_Indic (Iface);\n-\n-            Parent_Node := Parent (Base_Type (Iface_Typ));\n-            Iface_Def   := Type_Definition (Parent_Node);\n-\n-            if not Is_Interface (Iface_Typ) then\n-               Error_Msg_NE (\"(Ada 2005) & must be an interface\",\n-                          Iface, Iface_Typ);\n-\n-            else\n-               Check_Ifaces (Iface_Def, Iface);\n-            end if;\n-\n-            Next (Iface);\n-         end loop;\n-\n-         if Is_Task and Is_Protected then\n-            Error_Msg_N\n-              (\"type cannot derive from task and protected interface\", N);\n-         end if;\n-\n-         return;\n-      end if;\n-\n-      --  Full type declaration of derived type.\n-      --  Check compatibility with parent if it is interface type\n-\n-      if Nkind (Type_Definition (N)) = N_Derived_Type_Definition\n-        and then Is_Interface (Parent_Type)\n-      then\n-         Parent_Node := Parent (Parent_Type);\n-\n-         --  More detailed checks for interface varieties\n-\n-         Check_Ifaces\n-           (Iface_Def  => Type_Definition (Parent_Node),\n-            Error_Node => Subtype_Indication (Type_Definition (N)));\n-      end if;\n-\n-      Iface := First (Interface_List (Def));\n-\n-      while Present (Iface) loop\n-         Iface_Typ := Find_Type_Of_Subtype_Indic (Iface);\n-\n-         Parent_Node := Parent (Base_Type (Iface_Typ));\n-         Iface_Def   := Type_Definition (Parent_Node);\n-\n-         if not Is_Interface (Iface_Typ) then\n-            Error_Msg_NE (\"(Ada 2005) & must be an interface\",\n-                          Iface, Iface_Typ);\n-\n-         else\n-            --  \"The declaration of a specific descendant of an interface\n-            --   type freezes the interface type\" RM 13.14\n-\n-            Freeze_Before (N, Iface_Typ);\n-            Check_Ifaces (Iface_Def, Error_Node => Iface);\n-         end if;\n-\n-         Next (Iface);\n-      end loop;\n-\n-      if Is_Task and Is_Protected then\n-         Error_Msg_N\n-           (\"type cannot derive from task and protected interface\", N);\n-      end if;\n-\n-   end Check_Abstract_Interfaces;\n-\n    -------------------------------\n    -- Check_Abstract_Overriding --\n    -------------------------------\n@@ -8162,13 +7906,20 @@ package body Sem_Ch3 is\n          if Is_Null_Extension (T)\n            and then Has_Controlling_Result (Subp)\n            and then Ada_Version >= Ada_05\n-           and then Present (Alias (Subp))\n+           and then Present (Alias_Subp)\n            and then not Comes_From_Source (Subp)\n-           and then not Is_Abstract_Subprogram (Alias (Subp))\n+           and then not Is_Abstract_Subprogram (Alias_Subp)\n            and then not Is_Access_Type (Etype (Subp))\n          then\n             null;\n \n+         --  Ada 2005 (AI-251): Internal entities of interfaces need no\n+         --  processing because this check is done with the aliased\n+         --  entity\n+\n+         elsif Present (Interface_Alias (Subp)) then\n+            null;\n+\n          elsif (Is_Abstract_Subprogram (Subp)\n                  or else Requires_Overriding (Subp)\n                  or else\n@@ -8180,18 +7931,14 @@ package body Sem_Ch3 is\n            and then not Is_TSS (Subp, TSS_Stream_Output)\n            and then not Is_Abstract_Type (T)\n            and then Convention (T) /= Convention_CIL\n-           and then Chars (Subp) /= Name_uDisp_Asynchronous_Select\n-           and then Chars (Subp) /= Name_uDisp_Conditional_Select\n-           and then Chars (Subp) /= Name_uDisp_Get_Prim_Op_Kind\n-           and then Chars (Subp) /= Name_uDisp_Requeue\n-           and then Chars (Subp) /= Name_uDisp_Timed_Select\n+           and then not Is_Predefined_Interface_Primitive (Subp)\n \n             --  Ada 2005 (AI-251): Do not consider hidden entities associated\n             --  with abstract interface types because the check will be done\n             --  with the aliased entity (otherwise we generate a duplicated\n             --  error message).\n \n-           and then not Present (Abstract_Interface_Alias (Subp))\n+           and then not Present (Interface_Alias (Subp))\n          then\n             if Present (Alias_Subp) then\n \n@@ -8222,13 +7969,15 @@ package body Sem_Ch3 is\n                       or else Requires_Overriding (Subp)\n                       or else Is_Access_Type (Etype (Subp)))\n                then\n-                  --  The body of predefined primitives of tagged types derived\n-                  --  from interface types are generated later by Freeze_Type.\n-\n-                  if Is_Predefined_Dispatching_Operation (Subp)\n-                    and then Is_Abstract_Subprogram (Alias_Subp)\n-                    and then Is_Interface\n-                               (Root_Type (Find_Dispatching_Type (Subp)))\n+                  --  Avoid reporting error in case of abstract predefined\n+                  --  primitive inherited from interface type because the\n+                  --  body of internally generated predefined primitives\n+                  --  of tagged types are generated later by Freeze_Type\n+\n+                  if Is_Interface (Root_Type (T))\n+                    and then Is_Abstract_Subprogram (Subp)\n+                    and then Is_Predefined_Dispatching_Operation (Subp)\n+                    and then not Comes_From_Source (Ultimate_Alias (Subp))\n                   then\n                      null;\n \n@@ -8268,7 +8017,7 @@ package body Sem_Ch3 is\n                --  abstract interfaces.\n \n                elsif Is_Concurrent_Record_Type (T)\n-                 and then Present (Abstract_Interfaces (T))\n+                 and then Present (Interfaces (T))\n                then\n                   --  The controlling formal of Subp must be of mode \"out\",\n                   --  \"in out\" or an access-to-variable to be overridden.\n@@ -8277,12 +8026,14 @@ package body Sem_Ch3 is\n                   --  in -gnatj mode) ???\n \n                   if Ekind (First_Formal (Subp)) = E_In_Parameter then\n-                     Error_Msg_NE\n-                       (\"first formal of & must be of mode `OUT`, `IN OUT` \" &\n-                        \"or access-to-variable\", T, Subp);\n-                     Error_Msg_N\n-                       (\"\\to be overridden by protected procedure or \" &\n-                        \"entry (RM 9.4(11.9/2))\", T);\n+                     if not Is_Predefined_Dispatching_Operation (Subp) then\n+                        Error_Msg_NE\n+                          (\"first formal of & must be of mode `OUT`, \" &\n+                           \"`IN OUT` or access-to-variable\", T, Subp);\n+                        Error_Msg_N\n+                          (\"\\to be overridden by protected procedure or \" &\n+                           \"entry (RM 9.4(11.9/2))\", T);\n+                     end if;\n \n                   --  Some other kind of overriding failure\n \n@@ -8315,8 +8066,8 @@ package body Sem_Ch3 is\n \n          if Ada_Version >= Ada_05\n            and then Is_Hidden (Subp)\n-           and then Present (Abstract_Interface_Alias (Subp))\n-           and then Implemented_By_Entry (Abstract_Interface_Alias (Subp))\n+           and then Present (Interface_Alias (Subp))\n+           and then Implemented_By_Entry (Interface_Alias (Subp))\n            and then Present (Alias_Subp)\n            and then\n              (not Is_Primitive_Wrapper (Alias_Subp)\n@@ -8330,7 +8081,7 @@ package body Sem_Ch3 is\n                   Error_Ent := Corresponding_Concurrent_Type (Error_Ent);\n                end if;\n \n-               Error_Msg_Node_2 := Abstract_Interface_Alias (Subp);\n+               Error_Msg_Node_2 := Interface_Alias (Subp);\n                Error_Msg_NE\n                  (\"type & must implement abstract subprogram & with an entry\",\n                   Error_Ent, Error_Ent);\n@@ -8742,6 +8493,234 @@ package body Sem_Ch3 is\n       end if;\n    end Check_Initialization;\n \n+   ----------------------\n+   -- Check_Interfaces --\n+   ----------------------\n+\n+   procedure Check_Interfaces (N : Node_Id; Def : Node_Id) is\n+      Parent_Type : constant Entity_Id := Etype (Defining_Identifier (N));\n+\n+      Iface       : Node_Id;\n+      Iface_Def   : Node_Id;\n+      Iface_Typ   : Entity_Id;\n+      Parent_Node : Node_Id;\n+\n+      Is_Task : Boolean := False;\n+      --  Set True if parent type or any progenitor is a task interface\n+\n+      Is_Protected : Boolean := False;\n+      --  Set True if parent type or any progenitor is a protected interface\n+\n+      procedure Check_Ifaces (Iface_Def : Node_Id; Error_Node : Node_Id);\n+      --  Check that a progenitor is compatible with declaration.\n+      --  Error is posted on Error_Node.\n+\n+      ------------------\n+      -- Check_Ifaces --\n+      ------------------\n+\n+      procedure Check_Ifaces (Iface_Def : Node_Id; Error_Node : Node_Id) is\n+         Iface_Id : constant Entity_Id :=\n+                      Defining_Identifier (Parent (Iface_Def));\n+         Type_Def : Node_Id;\n+\n+      begin\n+         if Nkind (N) = N_Private_Extension_Declaration then\n+            Type_Def := N;\n+         else\n+            Type_Def := Type_Definition (N);\n+         end if;\n+\n+         if Is_Task_Interface (Iface_Id) then\n+            Is_Task := True;\n+\n+         elsif Is_Protected_Interface (Iface_Id) then\n+            Is_Protected := True;\n+         end if;\n+\n+         --  Check that the characteristics of the progenitor are compatible\n+         --  with the explicit qualifier in the declaration.\n+         --  The check only applies to qualifiers that come from source.\n+         --  Limited_Present also appears in the declaration of corresponding\n+         --  records, and the check does not apply to them.\n+\n+         if Limited_Present (Type_Def)\n+           and then not\n+             Is_Concurrent_Record_Type (Defining_Identifier (N))\n+         then\n+            if Is_Limited_Interface (Parent_Type)\n+              and then not Is_Limited_Interface (Iface_Id)\n+            then\n+               Error_Msg_NE\n+                 (\"progenitor& must be limited interface\",\n+                   Error_Node, Iface_Id);\n+\n+            elsif\n+              (Task_Present (Iface_Def)\n+                or else Protected_Present (Iface_Def)\n+                or else Synchronized_Present (Iface_Def))\n+              and then Nkind (N) /= N_Private_Extension_Declaration\n+            then\n+               Error_Msg_NE\n+                 (\"progenitor& must be limited interface\",\n+                   Error_Node, Iface_Id);\n+            end if;\n+\n+         --  Protected interfaces can only inherit from limited, synchronized\n+         --  or protected interfaces.\n+\n+         elsif Nkind (N) = N_Full_Type_Declaration\n+           and then  Protected_Present (Type_Def)\n+         then\n+            if Limited_Present (Iface_Def)\n+              or else Synchronized_Present (Iface_Def)\n+              or else Protected_Present (Iface_Def)\n+            then\n+               null;\n+\n+            elsif Task_Present (Iface_Def) then\n+               Error_Msg_N (\"(Ada 2005) protected interface cannot inherit\"\n+                            & \" from task interface\", Error_Node);\n+\n+            else\n+               Error_Msg_N (\"(Ada 2005) protected interface cannot inherit\"\n+                            & \" from non-limited interface\", Error_Node);\n+            end if;\n+\n+         --  Ada 2005 (AI-345): Synchronized interfaces can only inherit from\n+         --  limited and synchronized.\n+\n+         elsif Synchronized_Present (Type_Def) then\n+            if Limited_Present (Iface_Def)\n+              or else Synchronized_Present (Iface_Def)\n+            then\n+               null;\n+\n+            elsif Protected_Present (Iface_Def)\n+              and then Nkind (N) /= N_Private_Extension_Declaration\n+            then\n+               Error_Msg_N (\"(Ada 2005) synchronized interface cannot inherit\"\n+                            & \" from protected interface\", Error_Node);\n+\n+            elsif Task_Present (Iface_Def)\n+              and then Nkind (N) /= N_Private_Extension_Declaration\n+            then\n+               Error_Msg_N (\"(Ada 2005) synchronized interface cannot inherit\"\n+                            & \" from task interface\", Error_Node);\n+\n+            elsif not Is_Limited_Interface (Iface_Id) then\n+               Error_Msg_N (\"(Ada 2005) synchronized interface cannot inherit\"\n+                            & \" from non-limited interface\", Error_Node);\n+            end if;\n+\n+         --  Ada 2005 (AI-345): Task interfaces can only inherit from limited,\n+         --  synchronized or task interfaces.\n+\n+         elsif Nkind (N) = N_Full_Type_Declaration\n+           and then Task_Present (Type_Def)\n+         then\n+            if Limited_Present (Iface_Def)\n+              or else Synchronized_Present (Iface_Def)\n+              or else Task_Present (Iface_Def)\n+            then\n+               null;\n+\n+            elsif Protected_Present (Iface_Def) then\n+               Error_Msg_N (\"(Ada 2005) task interface cannot inherit from\"\n+                            & \" protected interface\", Error_Node);\n+\n+            else\n+               Error_Msg_N (\"(Ada 2005) task interface cannot inherit from\"\n+                            & \" non-limited interface\", Error_Node);\n+            end if;\n+         end if;\n+      end Check_Ifaces;\n+\n+   --  Start of processing for Check_Interfaces\n+\n+   begin\n+      if Is_Interface (Parent_Type) then\n+         if Is_Task_Interface (Parent_Type) then\n+            Is_Task := True;\n+\n+         elsif Is_Protected_Interface (Parent_Type) then\n+            Is_Protected := True;\n+         end if;\n+      end if;\n+\n+      if Nkind (N) = N_Private_Extension_Declaration then\n+\n+         --  Check that progenitors are compatible with declaration\n+\n+         Iface := First (Interface_List (Def));\n+         while Present (Iface) loop\n+            Iface_Typ := Find_Type_Of_Subtype_Indic (Iface);\n+\n+            Parent_Node := Parent (Base_Type (Iface_Typ));\n+            Iface_Def   := Type_Definition (Parent_Node);\n+\n+            if not Is_Interface (Iface_Typ) then\n+               Error_Msg_NE (\"(Ada 2005) & must be an interface\",\n+                          Iface, Iface_Typ);\n+\n+            else\n+               Check_Ifaces (Iface_Def, Iface);\n+            end if;\n+\n+            Next (Iface);\n+         end loop;\n+\n+         if Is_Task and Is_Protected then\n+            Error_Msg_N\n+              (\"type cannot derive from task and protected interface\", N);\n+         end if;\n+\n+         return;\n+      end if;\n+\n+      --  Full type declaration of derived type.\n+      --  Check compatibility with parent if it is interface type\n+\n+      if Nkind (Type_Definition (N)) = N_Derived_Type_Definition\n+        and then Is_Interface (Parent_Type)\n+      then\n+         Parent_Node := Parent (Parent_Type);\n+\n+         --  More detailed checks for interface varieties\n+\n+         Check_Ifaces\n+           (Iface_Def  => Type_Definition (Parent_Node),\n+            Error_Node => Subtype_Indication (Type_Definition (N)));\n+      end if;\n+\n+      Iface := First (Interface_List (Def));\n+      while Present (Iface) loop\n+         Iface_Typ := Find_Type_Of_Subtype_Indic (Iface);\n+\n+         Parent_Node := Parent (Base_Type (Iface_Typ));\n+         Iface_Def   := Type_Definition (Parent_Node);\n+\n+         if not Is_Interface (Iface_Typ) then\n+            Error_Msg_NE (\"(Ada 2005) & must be an interface\",\n+                          Iface, Iface_Typ);\n+\n+         else\n+            --  \"The declaration of a specific descendant of an interface\n+            --   type freezes the interface type\" RM 13.14\n+\n+            Freeze_Before (N, Iface_Typ);\n+            Check_Ifaces (Iface_Def, Error_Node => Iface);\n+         end if;\n+\n+         Next (Iface);\n+      end loop;\n+\n+      if Is_Task and Is_Protected then\n+         Error_Msg_N\n+           (\"type cannot derive from task and protected interface\", N);\n+      end if;\n+   end Check_Interfaces;\n+\n    ------------------------------------\n    -- Check_Or_Process_Discriminants --\n    ------------------------------------\n@@ -11188,8 +11167,6 @@ package body Sem_Ch3 is\n       Scale_Val     : Uint;\n       Bound_Val     : Ureal;\n \n-   --  Start of processing for Decimal_Fixed_Point_Type_Declaration\n-\n    begin\n       Check_Restriction (No_Fixed_Point, Def);\n \n@@ -11331,222 +11308,123 @@ package body Sem_Ch3 is\n       Set_Is_Constrained (T);\n    end Decimal_Fixed_Point_Type_Declaration;\n \n-   ----------------------------------\n-   -- Derive_Interface_Subprograms --\n-   ----------------------------------\n+   -----------------------------------\n+   -- Derive_Progenitor_Subprograms --\n+   -----------------------------------\n \n-   procedure Derive_Interface_Subprograms\n+   procedure Derive_Progenitor_Subprograms\n      (Parent_Type : Entity_Id;\n-      Tagged_Type : Entity_Id;\n-      Ifaces_List : Elist_Id)\n+      Tagged_Type : Entity_Id)\n    is\n-      function Collect_Interface_Primitives\n-        (Tagged_Type : Entity_Id) return Elist_Id;\n-      --  Ada 2005 (AI-251): Collect the primitives of all the implemented\n-      --  interfaces.\n-\n-      function In_List (L : Elist_Id; Subp : Entity_Id) return Boolean;\n-      --  Determine if Subp already in the list L\n+      E          : Entity_Id;\n+      Elmt       : Elmt_Id;\n+      Iface      : Entity_Id;\n+      Iface_Elmt : Elmt_Id;\n+      Iface_Subp : Entity_Id;\n+      New_Subp   : Entity_Id := Empty;\n+      Prim_Elmt  : Elmt_Id;\n+      Subp       : Entity_Id;\n+      Typ        : Entity_Id;\n \n-      procedure Remove_Homonym (E : Entity_Id);\n-      --  Removes E from the homonym chain\n+   begin\n+      pragma Assert (Ada_Version >= Ada_05\n+        and then Is_Record_Type (Tagged_Type)\n+        and then Is_Tagged_Type (Tagged_Type)\n+        and then Has_Interfaces (Tagged_Type));\n+\n+      --  Step 1: Transfer to the full-view primitives asociated with the\n+      --  partial-view that cover interface primitives. Conceptually this\n+      --  work should be done later by Process_Full_View; done here to\n+      --  simplify its implementation at later stages. It can be safely\n+      --  done here because interfaces must be visible in the partial and\n+      --  private view (RM 7.3(7.3/2)).\n+\n+      --  Small optimization: This work is only required if the parent is\n+      --  abstract. If the tagged type is not abstract, it cannot have\n+      --  abstract primitives (the only entities in the list of primitives of\n+      --  non-abstract tagged types that can reference abstract primitives\n+      --  through its Alias attribute are the internal entities that have\n+      --  attribute Interface_Alias, and these entities are generated later\n+      --  by Freeze_Record_Type).\n \n-      ----------------------------------\n-      -- Collect_Interface_Primitives --\n-      ----------------------------------\n+      if In_Private_Part (Current_Scope)\n+        and then Is_Abstract_Type (Parent_Type)\n+      then\n+         Elmt := First_Elmt (Primitive_Operations (Tagged_Type));\n+         while Present (Elmt) loop\n+            Subp := Node (Elmt);\n \n-      function Collect_Interface_Primitives\n-         (Tagged_Type : Entity_Id) return Elist_Id\n-      is\n-         Op_List     : constant Elist_Id := New_Elmt_List;\n-         Elmt        : Elmt_Id;\n-         Ifaces_List : Elist_Id;\n-         Iface_Elmt  : Elmt_Id;\n-         Prim        : Entity_Id;\n+            --  At this stage it is not possible to have entities in the list\n+            --  of primitives that have attribute Interface_Alias\n \n-      begin\n-         pragma Assert (Is_Tagged_Type (Tagged_Type)\n-           and then Has_Abstract_Interfaces (Tagged_Type));\n+            pragma Assert (No (Interface_Alias (Subp)));\n \n-         Collect_Abstract_Interfaces (Tagged_Type, Ifaces_List);\n+            Typ := Find_Dispatching_Type (Ultimate_Alias (Subp));\n \n-         Iface_Elmt := First_Elmt (Ifaces_List);\n-         while Present (Iface_Elmt) loop\n-            Elmt := First_Elmt (Primitive_Operations (Node (Iface_Elmt)));\n-            while Present (Elmt) loop\n-               Prim := Node (Elmt);\n+            if Is_Interface (Typ) then\n+               E := Find_Primitive_Covering_Interface\n+                      (Tagged_Type => Tagged_Type,\n+                       Iface_Prim  => Subp);\n \n-               if not Is_Predefined_Dispatching_Operation (Prim) then\n-                  Append_Elmt (Prim, Op_List);\n+               if Present (E)\n+                 and then Find_Dispatching_Type (Ultimate_Alias (E)) /= Typ\n+               then\n+                  Replace_Elmt (Elmt, E);\n+                  Remove_Homonym (Subp);\n                end if;\n-\n-               Next_Elmt (Elmt);\n-            end loop;\n-\n-            Next_Elmt (Iface_Elmt);\n-         end loop;\n-\n-         return Op_List;\n-      end Collect_Interface_Primitives;\n-\n-      -------------\n-      -- In_List --\n-      -------------\n-\n-      function In_List (L : Elist_Id; Subp : Entity_Id) return Boolean is\n-         Elmt : Elmt_Id;\n-\n-      begin\n-         Elmt := First_Elmt (L);\n-         while Present (Elmt) loop\n-            if Node (Elmt) = Subp then\n-               return True;\n             end if;\n \n             Next_Elmt (Elmt);\n          end loop;\n-\n-         return False;\n-      end In_List;\n-\n-      --------------------\n-      -- Remove_Homonym --\n-      --------------------\n-\n-      procedure Remove_Homonym (E : Entity_Id) is\n-         Prev  : Entity_Id := Empty;\n-         H     : Entity_Id;\n-\n-      begin\n-         if E = Current_Entity (E) then\n-            Set_Current_Entity (Homonym (E));\n-         else\n-            H := Current_Entity (E);\n-            while Present (H) and then H /= E loop\n-               Prev := H;\n-               H    := Homonym (H);\n-            end loop;\n-\n-            Set_Homonym (Prev, Homonym (E));\n-         end if;\n-      end Remove_Homonym;\n-\n-      --  Local Variables\n-\n-      E           : Entity_Id;\n-      Elmt        : Elmt_Id;\n-      Iface       : Entity_Id;\n-      Iface_Subp  : Entity_Id;\n-      New_Subp    : Entity_Id := Empty;\n-      Op_List     : Elist_Id;\n-      Parent_Base : Entity_Id;\n-      Subp        : Entity_Id;\n-\n-   --  Start of processing for Derive_Interface_Subprograms\n-\n-   begin\n-      if Ada_Version < Ada_05\n-        or else not Is_Record_Type (Tagged_Type)\n-        or else not Is_Tagged_Type (Tagged_Type)\n-        or else not Has_Abstract_Interfaces (Tagged_Type)\n-      then\n-         return;\n       end if;\n \n-      --  Add to the list of interface subprograms all the primitives inherited\n-      --  from abstract interfaces that are not immediate ancestors and also\n-      --  add their derivation to the list of interface primitives.\n-\n-      Op_List := Collect_Interface_Primitives (Tagged_Type);\n+      --  Step 2: Add primitives of progenitors that are not implemented by\n+      --  parents of Tagged_Type\n \n-      Elmt := First_Elmt (Op_List);\n-      while Present (Elmt) loop\n-         Subp  := Node (Elmt);\n-         Iface := Find_Dispatching_Type (Subp);\n+      if Present (Interfaces (Tagged_Type)) then\n+         Iface_Elmt := First_Elmt (Interfaces (Tagged_Type));\n+         while Present (Iface_Elmt) loop\n+            Iface := Node (Iface_Elmt);\n \n-         if Is_Concurrent_Record_Type (Tagged_Type) then\n-            if not Present (Abstract_Interface_Alias (Subp)) then\n-               Derive_Subprogram (New_Subp, Subp, Tagged_Type, Iface);\n-               Append_Elmt (New_Subp, Ifaces_List);\n-            end if;\n+            Prim_Elmt := First_Elmt (Primitive_Operations (Iface));\n+            while Present (Prim_Elmt) loop\n+               Iface_Subp := Node (Prim_Elmt);\n \n-         elsif not Is_Parent (Iface, Tagged_Type) then\n-            Derive_Subprogram (New_Subp, Subp, Tagged_Type, Iface);\n-            Append_Elmt (New_Subp, Ifaces_List);\n-         end if;\n+               if not Is_Predefined_Dispatching_Operation (Iface_Subp) then\n+                  E := Find_Primitive_Covering_Interface\n+                         (Tagged_Type => Tagged_Type,\n+                          Iface_Prim  => Iface_Subp);\n \n-         Next_Elmt (Elmt);\n-      end loop;\n+                  --  If not found we derive a new primitive leaving its alias\n+                  --  attribute referencing the interface primitive\n \n-      --  Complete the derivation of the interface subprograms. Assign to each\n-      --  entity associated with abstract interfaces their aliased entity and\n-      --  complete their decoration as hidden interface entities that will be\n-      --  used later to build the secondary dispatch tables.\n+                  if No (E) then\n+                     Derive_Subprogram\n+                       (New_Subp, Iface_Subp, Tagged_Type, Iface);\n \n-      if not Is_Empty_Elmt_List (Ifaces_List) then\n-         if Ekind (Parent_Type) = E_Record_Type_With_Private\n-           and then Has_Discriminants (Parent_Type)\n-           and then Present (Full_View (Parent_Type))\n-         then\n-            Parent_Base := Full_View (Parent_Type);\n-         else\n-            Parent_Base := Parent_Type;\n-         end if;\n+                  --  Propagate to the full view interface entities associated\n+                  --  with the partial view\n \n-         Elmt := First_Elmt (Ifaces_List);\n-         while Present (Elmt) loop\n-            Iface_Subp := Node (Elmt);\n-\n-            --  Look for the first overriding entity in the homonym chain.\n-            --  In this way if we are in the private part of a package spec\n-            --  we get the last overriding subprogram.\n-\n-            E  := Current_Entity_In_Scope (Iface_Subp);\n-            while Present (E) loop\n-               if Is_Dispatching_Operation (E)\n-                 and then Scope (E) = Scope (Iface_Subp)\n-                 and then Type_Conformant (E, Iface_Subp)\n-                 and then not In_List (Ifaces_List, E)\n-               then\n-                  exit;\n+                  elsif In_Private_Part (Current_Scope)\n+                    and then Present (Alias (E))\n+                    and then Alias (E) = Iface_Subp\n+                    and then\n+                      List_Containing (Parent (E)) /=\n+                        Private_Declarations\n+                          (Specification\n+                            (Unit_Declaration_Node (Current_Scope)))\n+                  then\n+                     Append_Elmt (E, Primitive_Operations (Tagged_Type));\n+                  end if;\n                end if;\n \n-               E := Homonym (E);\n+               Next_Elmt (Prim_Elmt);\n             end loop;\n \n-            --  Create an overriding entity if not found in the homonym chain\n-\n-            if not Present (E) then\n-               Derive_Subprogram\n-                 (E, Alias (Iface_Subp), Tagged_Type, Parent_Base);\n-\n-            elsif not In_List (Primitive_Operations (Tagged_Type), E) then\n-\n-               --  Inherit the operation from the private view\n-\n-               Append_Elmt (E, Primitive_Operations (Tagged_Type));\n-            end if;\n-\n-            --  Complete the decoration of the hidden interface entity\n-\n-            Set_Is_Hidden                (Iface_Subp);\n-            Set_Abstract_Interface_Alias (Iface_Subp, Alias (Iface_Subp));\n-            Set_Alias                    (Iface_Subp, E);\n-            Set_Is_Abstract_Subprogram   (Iface_Subp,\n-                                          Is_Abstract_Subprogram (E));\n-            Remove_Homonym               (Iface_Subp);\n-\n-            --  Hidden entities associated with interfaces must have set the\n-            --  Has_Delay_Freeze attribute to ensure that the corresponding\n-            --  entry of the secondary dispatch table is filled when such\n-            --  entity is frozen.\n-\n-            Set_Has_Delayed_Freeze (Iface_Subp);\n-\n-            Next_Elmt (Elmt);\n+            Next_Elmt (Iface_Elmt);\n          end loop;\n       end if;\n-   end Derive_Interface_Subprograms;\n+   end Derive_Progenitor_Subprograms;\n \n    -----------------------\n    -- Derive_Subprogram --\n@@ -11764,13 +11642,34 @@ package body Sem_Ch3 is\n          end if;\n       end Set_Derived_Name;\n \n+      --  Local variables\n+\n+      Parent_Overrides_Interface_Primitive : Boolean := False;\n+\n    --  Start of processing for Derive_Subprogram\n \n    begin\n       New_Subp :=\n          New_Entity (Nkind (Parent_Subp), Sloc (Derived_Type));\n       Set_Ekind (New_Subp, Ekind (Parent_Subp));\n \n+      --  Check whether the parent overrides an interface primitive\n+\n+      if Is_Overriding_Operation (Parent_Subp) then\n+         declare\n+            E : Entity_Id := Parent_Subp;\n+         begin\n+            while Present (Overridden_Operation (E)) loop\n+               E := Ultimate_Alias (Overridden_Operation (E));\n+            end loop;\n+\n+            Parent_Overrides_Interface_Primitive :=\n+              Is_Dispatching_Operation (E)\n+                and then Present (Find_Dispatching_Type (E))\n+                and then Is_Interface (Find_Dispatching_Type (E));\n+         end;\n+      end if;\n+\n       --  Check whether the inherited subprogram is a private operation that\n       --  should be inherited but not yet made visible. Such subprograms can\n       --  become visible at a later point (e.g., the private part of a public\n@@ -11816,10 +11715,11 @@ package body Sem_Ch3 is\n       then\n          Set_Derived_Name;\n \n-      --  Ada 2005 (AI-251): Hidden entity associated with abstract interface\n-      --  primitive\n+      --  Ada 2005 (AI-251): Regular derivation if the parent subprogram\n+      --  overrides an interface primitive because interface primitives\n+      --  must be visible in the partial view of the parent (RM 7.3 (7.3/2))\n \n-      elsif Present (Abstract_Interface_Alias (Parent_Subp)) then\n+      elsif Parent_Overrides_Interface_Primitive then\n          Set_Derived_Name;\n \n       --  The type is inheriting a private operation, so enter\n@@ -12035,17 +11935,102 @@ package body Sem_Ch3 is\n       Derived_Type   : Entity_Id;\n       Generic_Actual : Entity_Id := Empty)\n    is\n-      Op_List      : constant Elist_Id :=\n-                       Collect_Primitive_Operations (Parent_Type);\n-      Ifaces_List  : constant Elist_Id := New_Elmt_List;\n-      Predef_Prims : constant Elist_Id := New_Elmt_List;\n+      Op_List : constant Elist_Id :=\n+                  Collect_Primitive_Operations (Parent_Type);\n+\n+      function Check_Derived_Type return Boolean;\n+      --  Check that all primitive inherited from Parent_Type are found in\n+      --  the list of primitives of Derived_Type exactly in the same order.\n+\n+      function Check_Derived_Type return Boolean is\n+         E        : Entity_Id;\n+         Elmt     : Elmt_Id;\n+         List     : Elist_Id;\n+         New_Subp : Entity_Id;\n+         Op_Elmt  : Elmt_Id;\n+         Subp     : Entity_Id;\n+\n+      begin\n+         --  Traverse list of entities in the current scope searching for\n+         --  an incomplete type whose full-view is derived type\n+\n+         E := First_Entity (Scope (Derived_Type));\n+         while Present (E)\n+           and then E /= Derived_Type\n+         loop\n+            if Ekind (E) = E_Incomplete_Type\n+              and then Present (Full_View (E))\n+              and then Full_View (E) = Derived_Type\n+            then\n+               --  Disable this test if Derived_Type completes an incomplete\n+               --  type because in such case more primitives can be added\n+               --  later to the list of primitives of Derived_Type by routine\n+               --  Process_Incomplete_Dependents\n+\n+               return True;\n+            end if;\n+\n+            E := Next_Entity (E);\n+         end loop;\n+\n+         List := Collect_Primitive_Operations (Derived_Type);\n+         Elmt := First_Elmt (List);\n+\n+         Op_Elmt := First_Elmt (Op_List);\n+         while Present (Op_Elmt) loop\n+            Subp     := Node (Op_Elmt);\n+            New_Subp := Node (Elmt);\n+\n+            --  At this early stage Derived_Type has no entities with attribute\n+            --  Interface_Alias. In addition, such primitives are always\n+            --  located at the end of the list of primitives of Parent_Type.\n+            --  Therefore, if found we can safely stop processing pending\n+            --  entities.\n+\n+            exit when Present (Interface_Alias (Subp));\n+\n+            --  Handle hidden entities\n+\n+            if not Is_Predefined_Dispatching_Operation (Subp)\n+              and then Is_Hidden (Subp)\n+            then\n+               if Present (New_Subp)\n+                 and then Primitive_Names_Match (Subp, New_Subp)\n+               then\n+                  Next_Elmt (Elmt);\n+               end if;\n+\n+            else\n+               if not Present (New_Subp)\n+                 or else Ekind (Subp) /= Ekind (New_Subp)\n+                 or else not Primitive_Names_Match (Subp, New_Subp)\n+               then\n+                  return False;\n+               end if;\n+\n+               Next_Elmt (Elmt);\n+            end if;\n+\n+            Next_Elmt (Op_Elmt);\n+         end loop;\n+\n+         return True;\n+      end Check_Derived_Type;\n+\n+      --  Local variables\n+\n+      Alias_Subp   : Entity_Id;\n       Act_List     : Elist_Id;\n-      Act_Elmt     : Elmt_Id;\n+      Act_Elmt     : Elmt_Id   := No_Elmt;\n+      Act_Subp     : Entity_Id := Empty;\n       Elmt         : Elmt_Id;\n+      Need_Search  : Boolean   := False;\n       New_Subp     : Entity_Id := Empty;\n       Parent_Base  : Entity_Id;\n       Subp         : Entity_Id;\n \n+   --  Start of processing for Derive_Subprograms\n+\n    begin\n       if Ekind (Parent_Type) = E_Record_Type_With_Private\n         and then Has_Discriminants (Parent_Type)\n@@ -12056,126 +12041,266 @@ package body Sem_Ch3 is\n          Parent_Base := Parent_Type;\n       end if;\n \n-      --  Derive primitives inherited from the parent. Note that if the generic\n-      --  actual is present, this is not really a type derivation, it is a\n-      --  completion within an instance.\n-\n       if Present (Generic_Actual) then\n          Act_List := Collect_Primitive_Operations (Generic_Actual);\n          Act_Elmt := First_Elmt (Act_List);\n-      else\n-         Act_Elmt := No_Elmt;\n       end if;\n \n-      --  Literals are derived earlier in the process of building the derived\n-      --  type, and are skipped here.\n+      --  Derive primitives inherited from the parent. Note that if the generic\n+      --  actual is present, this is not really a type derivation, it is a\n+      --  completion within an instance.\n \n-      Elmt := First_Elmt (Op_List);\n-      while Present (Elmt) loop\n-         Subp := Node (Elmt);\n+      --  Case 1: Derived_Type does not implement interfaces\n+\n+      if not Is_Tagged_Type (Derived_Type)\n+        or else (not Has_Interfaces (Derived_Type)\n+                  and then not (Present (Generic_Actual)\n+                                  and then\n+                                Has_Interfaces (Generic_Actual)))\n+      then\n+         Elmt := First_Elmt (Op_List);\n+         while Present (Elmt) loop\n+            Subp := Node (Elmt);\n \n-         if Ekind (Subp) /= E_Enumeration_Literal then\n+            --  Literals are derived earlier in the process of building the\n+            --  derived type, and are skipped here.\n \n-            if Ada_Version >= Ada_05\n-              and then Present (Abstract_Interface_Alias (Subp))\n-            then\n+            if Ekind (Subp) = E_Enumeration_Literal then\n                null;\n \n-            --  We derive predefined primitives in a later round to ensure that\n-            --  they are always added to the list of primitives after user\n-            --  defined primitives (because predefined primitives have to be\n-            --  skipped when matching the operations of a parent interface to\n-            --  those of a concrete type). However it is unclear why those\n-            --  primitives would be needed in an instantiation???\n+            --  The actual is a direct descendant and the common primitive\n+            --  operations appear in the same order.\n \n-            elsif Is_Predefined_Dispatching_Operation (Subp) then\n-               Append_Elmt (Subp, Predef_Prims);\n+            --  If the generic parent type is present, the derived type is an\n+            --  instance of a formal derived type, and within the instance its\n+            --  operations are those of the actual. We derive from the formal\n+            --  type but make the inherited operations aliases of the\n+            --  corresponding operations of the actual.\n \n-            elsif No (Generic_Actual) then\n-               Derive_Subprogram (New_Subp, Subp, Derived_Type, Parent_Base);\n+            else\n+               Derive_Subprogram\n+                 (New_Subp, Subp, Derived_Type, Parent_Base, Node (Act_Elmt));\n \n-               --  Ada 2005 (AI-251): Add derivation of an abstract interface\n-               --  primitive to the list of entities to which we have to\n-               --  associate an aliased entity.\n+               if Present (Act_Elmt) then\n+                  Next_Elmt (Act_Elmt);\n+               end if;\n+            end if;\n \n-               if Ada_Version >= Ada_05\n-                 and then Is_Dispatching_Operation (Subp)\n-                 and then Present (Find_Dispatching_Type (Subp))\n-                 and then Is_Interface (Find_Dispatching_Type (Subp))\n-               then\n-                  Append_Elmt (New_Subp, Ifaces_List);\n+            Next_Elmt (Elmt);\n+         end loop;\n+\n+      --  Case 2: Derived_Type implements interfaces\n+\n+      else\n+         --  If the parent type has no predefined primitives we remove\n+         --  predefined primitives from the list of primitives of generic\n+         --  actual to simplify the complexity of this algorithm.\n+\n+         if Present (Generic_Actual) then\n+            declare\n+               Has_Predefined_Primitives : Boolean := False;\n+\n+            begin\n+               --  Check if the parent type has predefined primitives\n+\n+               Elmt := First_Elmt (Op_List);\n+               while Present (Elmt) loop\n+                  Subp := Node (Elmt);\n+\n+                  if Is_Predefined_Dispatching_Operation (Subp)\n+                    and then not Comes_From_Source (Ultimate_Alias (Subp))\n+                  then\n+                     Has_Predefined_Primitives := True;\n+                     exit;\n+                  end if;\n+\n+                  Next_Elmt (Elmt);\n+               end loop;\n+\n+               --  Remove predefined primitives of Generic_Actual. We must use\n+               --  an auxiliary list because in case of tagged types the value\n+               --  returned by Collect_Primitive_Operations is the value stored\n+               --  in its Primitive_Operations attribute (and we don't want to\n+               --  modify its current contents).\n+\n+               if not Has_Predefined_Primitives then\n+                  declare\n+                     Aux_List : constant Elist_Id := New_Elmt_List;\n+\n+                  begin\n+                     Elmt := First_Elmt (Act_List);\n+                     while Present (Elmt) loop\n+                        Subp := Node (Elmt);\n+\n+                        if not Is_Predefined_Dispatching_Operation (Subp)\n+                          or else Comes_From_Source (Subp)\n+                        then\n+                           Append_Elmt (Subp, Aux_List);\n+                        end if;\n+\n+                        Next_Elmt (Elmt);\n+                     end loop;\n+\n+                     Act_List := Aux_List;\n+                  end;\n                end if;\n \n-            else\n-               --  If the generic parent type is present, the derived type\n-               --  is an instance of a formal derived type, and within the\n-               --  instance its operations are those of the actual. We derive\n-               --  from the formal type but make the inherited operations\n-               --  aliases of the corresponding operations of the actual.\n-\n-               if Is_Interface (Parent_Type)\n-                 and then Root_Type (Derived_Type) /= Parent_Type\n+               Act_Elmt := First_Elmt (Act_List);\n+               Act_Subp := Node (Act_Elmt);\n+            end;\n+         end if;\n+\n+         --  Stage 1: If the generic actual is not present we derive the\n+         --  primitives inherited from the parent type. If the generic parent\n+         --  type is present, the derived type is an instance of a formal\n+         --  derived type, and within the instance its operations are those of\n+         --  the actual. We derive from the formal type but make the inherited\n+         --  operations aliases of the corresponding operations of the actual.\n+\n+         Elmt := First_Elmt (Op_List);\n+         while Present (Elmt) loop\n+            Subp       := Node (Elmt);\n+            Alias_Subp := Ultimate_Alias (Subp);\n+\n+            --  At this early stage Derived_Type has no entities with attribute\n+            --  Interface_Alias. In addition, such primitives are always\n+            --  located at the end of the list of primitives of Parent_Type.\n+            --  Therefore, if found we can safely stop processing pending\n+            --  entities.\n+\n+            exit when Present (Interface_Alias (Subp));\n+\n+            --  If the generic actual is present find the corresponding\n+            --  operation in the generic actual. If the parent type is a\n+            --  direct ancestor of the derived type then, even if it is an\n+            --  interface, the operations are inherited from the primary\n+            --  dispatch table and are in the proper order. If we detect here\n+            --  that primitives are not in the same order we traverse the list\n+            --  of primitive operations of the actual to find the one that\n+            --  implements the interface primitive.\n+\n+            if Need_Search\n+              or else\n+                (Present (Generic_Actual)\n+                   and then Present (Act_Subp)\n+                   and then not Primitive_Names_Match (Subp, Act_Subp))\n+            then\n+               pragma Assert (not Is_Ancestor (Parent_Base, Generic_Actual));\n+               pragma Assert (Is_Interface (Parent_Base));\n+\n+               --  Remember that we need searching for all the pending\n+               --  primitives\n+\n+               Need_Search := True;\n+\n+               --  Handle entities associated with interface primitives\n+\n+               if Present (Alias (Subp))\n+                 and then Is_Interface (Find_Dispatching_Type (Alias (Subp)))\n+                 and then not Is_Predefined_Dispatching_Operation (Subp)\n                then\n-                  --  Find the corresponding operation in the generic actual.\n-                  --  Given that the actual is not a direct descendant of the\n-                  --  parent, as in Ada 95, the primitives are not necessarily\n-                  --  in the same order, so we have to traverse the list of\n-                  --  primitive operations of the actual to find the one that\n-                  --  implements the interface operation.\n-\n-                  --  Note that if the parent type is the direct ancestor of\n-                  --  the derived type, then even if it is an interface the\n-                  --  operations are inherited from the primary dispatch table\n-                  --  and are in the proper order.\n+                  Act_Subp :=\n+                    Find_Primitive_Covering_Interface\n+                      (Tagged_Type => Generic_Actual,\n+                       Iface_Prim  => Subp);\n \n+               --  Handle predefined primitives plus the rest of user-defined\n+               --  primitives\n+\n+               else\n                   Act_Elmt := First_Elmt (Act_List);\n                   while Present (Act_Elmt) loop\n-                     exit when\n-                       Abstract_Interface_Alias (Node (Act_Elmt)) = Subp;\n+                     Act_Subp := Node (Act_Elmt);\n+\n+                     exit when Primitive_Names_Match (Subp, Act_Subp)\n+                       and then Type_Conformant (Subp, Act_Subp,\n+                                  Skip_Controlling_Formals => True)\n+                       and then No (Interface_Alias (Act_Subp));\n+\n                      Next_Elmt (Act_Elmt);\n                   end loop;\n                end if;\n+            end if;\n \n-               --  If the formal is not an interface, the actual is a direct\n-               --  descendant and the common  primitive operations appear in\n-               --  the same order.\n+            --   Case 1: If the parent is a limited interface then it has the\n+            --   predefined primitives of synchronized interfaces. However, the\n+            --   actual type may be a non-limited type and hence it does not\n+            --   have such primitives.\n \n-               Derive_Subprogram\n-                 (New_Subp, Subp, Derived_Type, Parent_Base, Node (Act_Elmt));\n+            if Present (Generic_Actual)\n+              and then not Present (Act_Subp)\n+              and then Is_Limited_Interface (Parent_Base)\n+              and then Is_Predefined_Interface_Primitive (Subp)\n+            then\n+               null;\n \n-               if Present (Act_Elmt) then\n-                  Next_Elmt (Act_Elmt);\n+            --  Case 2: Inherit entities associated with interfaces that\n+            --  were not covered by the parent type. We exclude here null\n+            --  interface primitives because they do not need special\n+            --  management.\n+\n+            elsif Present (Alias (Subp))\n+              and then Is_Interface (Find_Dispatching_Type (Alias_Subp))\n+              and then not\n+                (Nkind (Parent (Alias_Subp)) = N_Procedure_Specification\n+                   and then Null_Present (Parent (Alias_Subp)))\n+            then\n+               Derive_Subprogram\n+                 (New_Subp     => New_Subp,\n+                  Parent_Subp  => Alias_Subp,\n+                  Derived_Type => Derived_Type,\n+                  Parent_Type  => Find_Dispatching_Type (Alias_Subp),\n+                  Actual_Subp  => Act_Subp);\n+\n+               if No (Generic_Actual) then\n+                  Set_Alias (New_Subp, Subp);\n                end if;\n-            end if;\n-         end if;\n \n-         Next_Elmt (Elmt);\n-      end loop;\n+            --  Case 3: Common derivation\n \n-      --  Inherit additional operations from progenitor interfaces. However,\n-      --  if the derived type is a generic actual, there are not new primitive\n-      --  operations for the type, because it has those of the actual, so\n-      --  nothing needs to be done. The renamings generated above are not\n-      --  primitive operations, and their purpose is simply to make the proper\n-      --  operations visible within an instantiation.\n+            else\n+               Derive_Subprogram\n+                 (New_Subp     => New_Subp,\n+                  Parent_Subp  => Subp,\n+                  Derived_Type => Derived_Type,\n+                  Parent_Type  => Parent_Base,\n+                  Actual_Subp  => Act_Subp);\n+            end if;\n \n-      if Ada_Version >= Ada_05\n-        and then Is_Tagged_Type (Derived_Type)\n-        and then No (Generic_Actual)\n-      then\n-         Derive_Interface_Subprograms (Parent_Type, Derived_Type, Ifaces_List);\n-      end if;\n+            --  No need to update Act_Elm if we must search for the\n+            --  corresponding operation in the generic actual\n \n-      --  Derive predefined primitives\n+            if not Need_Search\n+              and then Present (Act_Elmt)\n+            then\n+               Next_Elmt (Act_Elmt);\n+               Act_Subp := Node (Act_Elmt);\n+            end if;\n \n-      if not Is_Empty_Elmt_List (Predef_Prims) then\n-         Elmt := First_Elmt (Predef_Prims);\n-         while Present (Elmt) loop\n-            Derive_Subprogram\n-              (New_Subp, Node (Elmt), Derived_Type, Parent_Base);\n             Next_Elmt (Elmt);\n          end loop;\n+\n+         --  Inherit additional operations from progenitors. If the derived\n+         --  type is a generic actual, there are not new primitive operations\n+         --  for the type because it has those of the actual, and therefore\n+         --  nothing needs to be done. The renamings generated above are not\n+         --  primitive operations, and their purpose is simply to make the\n+         --  proper operations visible within an instantiation.\n+\n+         if No (Generic_Actual) then\n+            Derive_Progenitor_Subprograms (Parent_Base, Derived_Type);\n+         end if;\n       end if;\n+\n+      --  Final check: Direct descendants must have their primitives in the\n+      --  same order. We exclude from this test non-tagged types and instances\n+      --  of formal derived types. We skip this test if we have already\n+      --  reported serious errors in the sources.\n+\n+      pragma Assert (not Is_Tagged_Type (Derived_Type)\n+        or else Present (Generic_Actual)\n+        or else Serious_Errors_Detected > 0\n+        or else Check_Derived_Type);\n    end Derive_Subprograms;\n \n    --------------------------------\n@@ -14046,48 +14171,9 @@ package body Sem_Ch3 is\n      (Iface : Entity_Id;\n       Typ   : Entity_Id) return Boolean\n    is\n-      Iface_Elmt  : Elmt_Id;\n-      I_Name      : Entity_Id;\n-\n    begin\n-      if No (Abstract_Interfaces (Typ)) then\n-         return False;\n-\n-      else\n-         Iface_Elmt := First_Elmt (Abstract_Interfaces (Typ));\n-         while Present (Iface_Elmt) loop\n-            I_Name := Node (Iface_Elmt);\n-            if Base_Type (I_Name) = Base_Type (Iface) then\n-               return True;\n-\n-            elsif Is_Derived_Type (I_Name)\n-              and then Is_Ancestor (Iface, I_Name)\n-            then\n-               return True;\n-\n-            else\n-               Next_Elmt (Iface_Elmt);\n-            end if;\n-         end loop;\n-\n-         --  For concurrent record types, they have the interfaces of the\n-         --  parent synchronized type. However these have no ancestors that\n-         --  implement anything, so assume it is a progenitor.\n-         --  Should be cleaned up in Collect_Abstract_Interfaces???\n-\n-         if Is_Concurrent_Record_Type (Typ) then\n-            return Present (Abstract_Interfaces (Typ));\n-         end if;\n-\n-         --  If type is a derived type, check recursively its ancestors\n-\n-         if Is_Derived_Type (Typ) then\n-            return Etype (Typ) = Iface\n-              or else  Is_Progenitor (Iface, Etype (Typ));\n-         else\n-            return False;\n-         end if;\n-      end if;\n+      return Implements_Interface (Typ, Iface,\n+               Exclude_Parents => True);\n    end Is_Progenitor;\n \n    ------------------------------\n@@ -15366,8 +15452,8 @@ package body Sem_Ch3 is\n \n          --  Handle entities in the list of abstract interfaces\n \n-         if Present (Abstract_Interfaces (Typ)) then\n-            Iface_Elmt := First_Elmt (Abstract_Interfaces (Typ));\n+         if Present (Interfaces (Typ)) then\n+            Iface_Elmt := First_Elmt (Interfaces (Typ));\n             while Present (Iface_Elmt) loop\n                Iface := Node (Iface_Elmt);\n \n@@ -15697,6 +15783,9 @@ package body Sem_Ch3 is\n       --  If the private view was tagged, copy the new primitive operations\n       --  from the private view to the full view.\n \n+      --  Note: Subprograms covering interface primitives were previously\n+      --  propagated to the full view by Derive_Progenitor_Primitives\n+\n       if Is_Tagged_Type (Full_T)\n         and then not Is_Concurrent_Type (Full_T)\n       then\n@@ -16902,11 +16991,11 @@ package body Sem_Ch3 is\n       --  These flags must be initialized before calling Process_Discriminants\n       --  because this routine makes use of them.\n \n-      Set_Ekind               (T, E_Record_Type);\n-      Set_Etype               (T, T);\n-      Init_Size_Align         (T);\n-      Set_Abstract_Interfaces (T, No_Elist);\n-      Set_Stored_Constraint   (T, No_Elist);\n+      Set_Ekind             (T, E_Record_Type);\n+      Set_Etype             (T, T);\n+      Init_Size_Align       (T);\n+      Set_Interfaces        (T, No_Elist);\n+      Set_Stored_Constraint (T, No_Elist);\n \n       --  Normal case\n \n@@ -16952,7 +17041,7 @@ package body Sem_Ch3 is\n       if Ada_Version >= Ada_05\n         and then Present (Interface_List (Def))\n       then\n-         Check_Abstract_Interfaces (N, Def);\n+         Check_Interfaces (N, Def);\n \n          declare\n             Ifaces_List : Elist_Id;\n@@ -16961,12 +17050,12 @@ package body Sem_Ch3 is\n             --  Ada 2005 (AI-251): Collect the list of progenitors that are not\n             --  already in the parents.\n \n-            Collect_Abstract_Interfaces\n-              (T                         => T,\n-               Ifaces_List               => Ifaces_List,\n-               Exclude_Parent_Interfaces => True);\n+            Collect_Interfaces\n+              (T               => T,\n+               Ifaces_List     => Ifaces_List,\n+               Exclude_Parents => True);\n \n-            Set_Abstract_Interfaces (T, Ifaces_List);\n+            Set_Interfaces (T, Ifaces_List);\n          end;\n       end if;\n \n@@ -17013,7 +17102,7 @@ package body Sem_Ch3 is\n             --  Ada 2005 (AI-251): Addition of the Tag corresponding to all the\n             --  implemented interfaces.\n \n-            if Has_Abstract_Interfaces (T) then\n+            if Has_Interfaces (T) then\n                Add_Interface_Tag_Components (N, T);\n             end if;\n          end if;\n@@ -17050,11 +17139,7 @@ package body Sem_Ch3 is\n       if Is_Tagged\n         and then not Is_Empty_List (Interface_List (Def))\n       then\n-         declare\n-            Ifaces_List : constant Elist_Id := New_Elmt_List;\n-         begin\n-            Derive_Interface_Subprograms (T, T, Ifaces_List);\n-         end;\n+         Derive_Progenitor_Subprograms (T, T);\n       end if;\n    end Record_Type_Declaration;\n "}, {"sha": "a341069bf75f29c97e2c2f52bdcb9e805c71d023", "filename": "gcc/ada/sem_ch3.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fsem_ch3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fsem_ch3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.ads?ref=ce2b6ba521252796f61a25ada77f3e55ea97b36d", "patch": "@@ -26,7 +26,7 @@\n with Nlists; use Nlists;\n with Types;  use Types;\n \n-package Sem_Ch3  is\n+package Sem_Ch3 is\n    procedure Analyze_Component_Declaration         (N : Node_Id);\n    procedure Analyze_Incomplete_Type_Decl          (N : Node_Id);\n    procedure Analyze_Itype_Reference               (N : Node_Id);"}, {"sha": "b59cd4b5186160bdc68fb9db5046854c8dfbdafc", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=ce2b6ba521252796f61a25ada77f3e55ea97b36d", "patch": "@@ -3525,7 +3525,6 @@ package body Sem_Ch4 is\n             Error_Msg_NE (\"no selector& for}\", N, Sel);\n \n             Check_Misspelled_Selector (Type_To_Use, Sel);\n-\n          end if;\n \n          Set_Entity (Sel, Any_Id);\n@@ -6443,14 +6442,14 @@ package body Sem_Ch4 is\n                --  primitive is also in this list of primitive operations and\n                --  will be used instead.\n \n-               if (Present (Abstract_Interface_Alias (Prim_Op))\n-                     and then Is_Ancestor (Find_Dispatching_Type\n-                                             (Alias (Prim_Op)), Corr_Type))\n+               if (Present (Interface_Alias (Prim_Op))\n+                    and then Is_Ancestor (Find_Dispatching_Type\n+                                            (Alias (Prim_Op)), Corr_Type))\n                  or else\n \n-               --  Do not consider hidden primitives unless the type is in an\n-               --  open scope or we are within an instance, where visibility\n-               --  is known to be correct.\n+                  --  Do not consider hidden primitives unless the type is\n+                  --  in an open scope or we are within an instance, where\n+                  --  visibility is known to be correct.\n \n                   (Is_Hidden (Prim_Op)\n                      and then not Is_Immediately_Visible (Obj_Type)"}, {"sha": "037ccf980da134b564e9fee6f49d6164955b9724", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 141, "deletions": 97, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=ce2b6ba521252796f61a25ada77f3e55ea97b36d", "patch": "@@ -33,6 +33,7 @@ with Expander; use Expander;\n with Exp_Ch6;  use Exp_Ch6;\n with Exp_Ch7;  use Exp_Ch7;\n with Exp_Ch9;  use Exp_Ch9;\n+with Exp_Disp; use Exp_Disp;\n with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n with Fname;    use Fname;\n@@ -1827,7 +1828,7 @@ package body Sem_Ch6 is\n               and then Ekind (Etype (First_Entity (Spec_Id))) = E_Record_Type\n               and then Is_Tagged_Type (Etype (First_Entity (Spec_Id)))\n               and then\n-                Present (Abstract_Interfaces (Etype (First_Entity (Spec_Id))))\n+                Present (Interfaces (Etype (First_Entity (Spec_Id))))\n               and then\n                 Present\n                   (Corresponding_Concurrent_Type\n@@ -2471,8 +2472,8 @@ package body Sem_Ch6 is\n                if (Ekind (Formal_Typ) = E_Protected_Type\n                      or else Ekind (Formal_Typ) = E_Task_Type)\n                  and then Present (Corresponding_Record_Type (Formal_Typ))\n-                 and then Present (Abstract_Interfaces\n-                                  (Corresponding_Record_Type (Formal_Typ)))\n+                 and then Present (Interfaces\n+                                    (Corresponding_Record_Type (Formal_Typ)))\n                then\n                   Set_Etype (Formal,\n                     Corresponding_Record_Type (Formal_Typ));\n@@ -3506,18 +3507,9 @@ package body Sem_Ch6 is\n    -----------------------\n \n    procedure Check_Conventions (Typ : Entity_Id) is\n+      Ifaces_List : Elist_Id;\n \n-      function Skip_Check (Op : Entity_Id) return Boolean;\n-      pragma Inline (Skip_Check);\n-      --  A small optimization: skip the predefined dispatching operations,\n-      --  since they always have the same convention. Also do not consider\n-      --  abstract primitives since those are left by an erroneous overriding.\n-      --  This function returns True for any operation that is thus exempted\n-      --  exempted from checking.\n-\n-      procedure Check_Convention\n-        (Op          : Entity_Id;\n-         Search_From : Elmt_Id);\n+      procedure Check_Convention (Op : Entity_Id);\n       --  Verify that the convention of inherited dispatching operation Op is\n       --  consistent among all subprograms it overrides. In order to minimize\n       --  the search, Search_From is utilized to designate a specific point in\n@@ -3527,89 +3519,62 @@ package body Sem_Ch6 is\n       -- Check_Convention --\n       ----------------------\n \n-      procedure Check_Convention\n-        (Op          : Entity_Id;\n-         Search_From : Elmt_Id)\n-      is\n-         procedure Error_Msg_Operation (Op : Entity_Id);\n-         --  Emit a continuation to an error message depicting the kind, name,\n-         --  convention and source location of subprogram Op.\n-\n-         -------------------------\n-         -- Error_Msg_Operation --\n-         -------------------------\n+      procedure Check_Convention (Op : Entity_Id) is\n+         Iface_Elmt      : Elmt_Id;\n+         Iface_Prim_Elmt : Elmt_Id;\n+         Iface_Prim      : Entity_Id;\n \n-         procedure Error_Msg_Operation (Op : Entity_Id) is\n-         begin\n-            Error_Msg_Name_1 := Chars (Op);\n+      begin\n+         Iface_Elmt := First_Elmt (Ifaces_List);\n+         while Present (Iface_Elmt) loop\n+            Iface_Prim_Elmt :=\n+               First_Elmt (Primitive_Operations (Node (Iface_Elmt)));\n+            while Present (Iface_Prim_Elmt) loop\n+               Iface_Prim := Node (Iface_Prim_Elmt);\n+\n+               if Is_Interface_Conformant (Typ, Iface_Prim, Op)\n+                 and then Convention (Iface_Prim) /= Convention (Op)\n+               then\n+                  Error_Msg_N\n+                    (\"inconsistent conventions in primitive operations\", Typ);\n \n-            --  Error messages of primitive subprograms do not contain a\n-            --  convention attribute since the convention may have been first\n-            --  inherited from a parent subprogram, then changed by a pragma.\n+                  Error_Msg_Name_1 := Chars (Op);\n+                  Error_Msg_Name_2 := Get_Convention_Name (Convention (Op));\n+                  Error_Msg_Sloc   := Sloc (Op);\n \n-            if Comes_From_Source (Op) then\n-               Error_Msg_Sloc := Sloc (Op);\n-               Error_Msg_N\n-                (\"\\ primitive % defined #\", Typ);\n+                  if Comes_From_Source (Op) then\n+                     if not Is_Overriding_Operation (Op) then\n+                        Error_Msg_N (\"\\\\primitive % defined #\", Typ);\n+                     else\n+                        Error_Msg_N (\"\\\\overridding operation % with \" &\n+                                     \"convention % defined #\", Typ);\n+                     end if;\n \n-            else\n-               Error_Msg_Name_2 := Get_Convention_Name (Convention (Op));\n+                  else pragma Assert (Present (Alias (Op)));\n+                     Error_Msg_Sloc := Sloc (Alias (Op));\n+                     Error_Msg_N (\"\\\\inherited operation % with \" &\n+                                  \"convention % defined #\", Typ);\n+                  end if;\n \n-               if Present (Abstract_Interface_Alias (Op)) then\n-                  Error_Msg_Sloc := Sloc (Abstract_Interface_Alias (Op));\n+                  Error_Msg_Name_1 := Chars (Op);\n+                  Error_Msg_Name_2 :=\n+                    Get_Convention_Name (Convention (Iface_Prim));\n+                  Error_Msg_Sloc := Sloc (Iface_Prim);\n                   Error_Msg_N (\"\\\\overridden operation % with \" &\n                                \"convention % defined #\", Typ);\n \n-               else pragma Assert (Present (Alias (Op)));\n-                  Error_Msg_Sloc := Sloc (Alias (Op));\n-                  Error_Msg_N (\"\\\\inherited operation % with \" &\n-                               \"convention % defined #\", Typ);\n-               end if;\n-            end if;\n-         end Error_Msg_Operation;\n-\n-         --  Local variables\n-\n-         Second_Prim_Op      : Entity_Id;\n-         Second_Prim_Op_Elmt : Elmt_Id;\n-\n-      --  Start of processing for Check_Convention\n-\n-      begin\n-         Second_Prim_Op_Elmt := Next_Elmt (Search_From);\n-         while Present (Second_Prim_Op_Elmt) loop\n-            Second_Prim_Op := Node (Second_Prim_Op_Elmt);\n-\n-            if not Skip_Check (Second_Prim_Op)\n-              and then Chars (Second_Prim_Op) = Chars (Op)\n-              and then Type_Conformant (Second_Prim_Op, Op)\n-              and then Convention (Second_Prim_Op) /= Convention (Op)\n-            then\n-               Error_Msg_N\n-                 (\"inconsistent conventions in primitive operations\", Typ);\n+                  --  Avoid cascading errors\n \n-               Error_Msg_Operation (Op);\n-               Error_Msg_Operation (Second_Prim_Op);\n-\n-               --  Avoid cascading errors\n+                  return;\n+               end if;\n \n-               return;\n-            end if;\n+               Next_Elmt (Iface_Prim_Elmt);\n+            end loop;\n \n-            Next_Elmt (Second_Prim_Op_Elmt);\n+            Next_Elmt (Iface_Elmt);\n          end loop;\n       end Check_Convention;\n \n-      ----------------\n-      -- Skip_Check --\n-      ----------------\n-\n-      function Skip_Check (Op : Entity_Id) return Boolean is\n-      begin\n-         return Is_Predefined_Dispatching_Operation (Op)\n-           or else Is_Abstract_Subprogram (Op);\n-      end Skip_Check;\n-\n       --  Local variables\n \n       Prim_Op      : Entity_Id;\n@@ -3618,6 +3583,12 @@ package body Sem_Ch6 is\n    --  Start of processing for Check_Conventions\n \n    begin\n+      if not Has_Interfaces (Typ) then\n+         return;\n+      end if;\n+\n+      Collect_Interfaces (Typ, Ifaces_List);\n+\n       --  The algorithm checks every overriding dispatching operation against\n       --  all the corresponding overridden dispatching operations, detecting\n       --  differences in conventions.\n@@ -3627,13 +3598,10 @@ package body Sem_Ch6 is\n          Prim_Op := Node (Prim_Op_Elmt);\n \n          --  A small optimization: skip the predefined dispatching operations\n-         --  since they always have the same convention. Also avoid processing\n-         --  of abstract primitives left from an erroneous overriding.\n+         --  since they always have the same convention.\n \n-         if not Skip_Check (Prim_Op) then\n-            Check_Convention\n-              (Op          => Prim_Op,\n-               Search_From => Prim_Op_Elmt);\n+         if not Is_Predefined_Dispatching_Operation (Prim_Op) then\n+            Check_Convention (Prim_Op);\n          end if;\n \n          Next_Elmt (Prim_Op_Elmt);\n@@ -4497,15 +4465,17 @@ package body Sem_Ch6 is\n    ------------------------------\n \n    procedure Check_Subtype_Conformant\n-     (New_Id  : Entity_Id;\n-      Old_Id  : Entity_Id;\n-      Err_Loc : Node_Id := Empty)\n+     (New_Id                   : Entity_Id;\n+      Old_Id                   : Entity_Id;\n+      Err_Loc                  : Node_Id := Empty;\n+      Skip_Controlling_Formals : Boolean := False)\n    is\n       Result : Boolean;\n       pragma Warnings (Off, Result);\n    begin\n       Check_Conformance\n-        (New_Id, Old_Id, Subtype_Conformant, True, Result, Err_Loc);\n+        (New_Id, Old_Id, Subtype_Conformant, True, Result, Err_Loc,\n+         Skip_Controlling_Formals => Skip_Controlling_Formals);\n    end Check_Subtype_Conformant;\n \n    ---------------------------\n@@ -5795,6 +5765,76 @@ package body Sem_Ch6 is\n       end loop;\n    end Install_Formals;\n \n+   -----------------------------\n+   -- Is_Interface_Conformant --\n+   -----------------------------\n+\n+   function Is_Interface_Conformant\n+     (Tagged_Type : Entity_Id;\n+      Iface_Prim  : Entity_Id;\n+      Prim        : Entity_Id) return Boolean\n+   is\n+   begin\n+      pragma Assert (Is_Subprogram (Iface_Prim)\n+        and then Is_Subprogram (Prim)\n+        and then Is_Dispatching_Operation (Iface_Prim)\n+        and then Is_Dispatching_Operation (Prim));\n+\n+      pragma Assert (Is_Interface (Find_Dispatching_Type (Iface_Prim))\n+        or else (Present (Alias (Iface_Prim))\n+                   and then\n+                     Is_Interface\n+                       (Find_Dispatching_Type (Ultimate_Alias (Iface_Prim)))));\n+\n+      if Prim = Iface_Prim\n+        or else not Is_Subprogram (Prim)\n+        or else Ekind (Prim) /= Ekind (Iface_Prim)\n+        or else not Is_Dispatching_Operation (Prim)\n+        or else Scope (Prim) /= Scope (Tagged_Type)\n+        or else No (Find_Dispatching_Type (Prim))\n+        or else Base_Type (Find_Dispatching_Type (Prim)) /= Tagged_Type\n+        or else not Primitive_Names_Match (Iface_Prim, Prim)\n+      then\n+         return False;\n+\n+      --  Case of a procedure, or a function not returning an interface\n+\n+      elsif Ekind (Iface_Prim) = E_Procedure\n+        or else Etype (Prim) = Etype (Iface_Prim)\n+        or else not Is_Interface (Etype (Iface_Prim))\n+      then\n+         return Type_Conformant (Prim, Iface_Prim,\n+                  Skip_Controlling_Formals => True);\n+\n+      --  Case of a function returning an interface\n+\n+      elsif Implements_Interface (Etype (Prim), Etype (Iface_Prim)) then\n+         declare\n+            Ret_Typ       : constant Entity_Id := Etype (Prim);\n+            Is_Conformant : Boolean;\n+\n+         begin\n+            --  Temporarly set both entities returning exactly the same type to\n+            --  be able to call Type_Conformant (because that routine has no\n+            --  machinery to handle interfaces).\n+\n+            Set_Etype (Prim, Etype (Iface_Prim));\n+\n+            Is_Conformant :=\n+              Type_Conformant (Prim, Iface_Prim,\n+                Skip_Controlling_Formals => True);\n+\n+            --  Restore proper decoration of returned type\n+\n+            Set_Etype (Prim, Ret_Typ);\n+\n+            return Is_Conformant;\n+         end;\n+      end if;\n+\n+      return False;\n+   end Is_Interface_Conformant;\n+\n    ---------------------------------\n    -- Is_Non_Overriding_Operation --\n    ---------------------------------\n@@ -6422,7 +6462,7 @@ package body Sem_Ch6 is\n                                             N_Task_Type_Declaration,\n                                             N_Protected_Type_Declaration)\n          then\n-            Collect_Abstract_Interfaces (Typ, Ifaces_List);\n+            Collect_Interfaces (Typ, Ifaces_List);\n \n             if not Is_Empty_Elmt_List (Ifaces_List) then\n                Overridden_Subp :=\n@@ -6555,7 +6595,6 @@ package body Sem_Ch6 is\n            and then Is_Dispatching_Operation (Alias (S))\n            and then Present (Find_Dispatching_Type (Alias (S)))\n            and then Is_Interface (Find_Dispatching_Type (Alias (S)))\n-           and then not Is_Predefined_Dispatching_Operation (Alias (S))\n          then\n             goto Add_New_Entity;\n          end if;\n@@ -7669,10 +7708,15 @@ package body Sem_Ch6 is\n    -- Subtype_Conformant --\n    ------------------------\n \n-   function Subtype_Conformant (New_Id, Old_Id : Entity_Id) return Boolean is\n+   function Subtype_Conformant\n+     (New_Id                   : Entity_Id;\n+      Old_Id                   : Entity_Id;\n+      Skip_Controlling_Formals : Boolean := False) return Boolean\n+   is\n       Result : Boolean;\n    begin\n-      Check_Conformance (New_Id, Old_Id, Subtype_Conformant, False, Result);\n+      Check_Conformance (New_Id, Old_Id, Subtype_Conformant, False, Result,\n+        Skip_Controlling_Formals => Skip_Controlling_Formals);\n       return Result;\n    end Subtype_Conformant;\n "}, {"sha": "689ac8b690ac9d535a0fe5b1a741db86fd8a1d6a", "filename": "gcc/ada/sem_ch6.ads", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fsem_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fsem_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.ads?ref=ce2b6ba521252796f61a25ada77f3e55ea97b36d", "patch": "@@ -111,9 +111,10 @@ package Sem_Ch6 is\n    --  Is_Primitive indicates whether the subprogram is primitive.\n \n    procedure Check_Subtype_Conformant\n-     (New_Id  : Entity_Id;\n-      Old_Id  : Entity_Id;\n-      Err_Loc : Node_Id := Empty);\n+     (New_Id                   : Entity_Id;\n+      Old_Id                   : Entity_Id;\n+      Err_Loc                  : Node_Id := Empty;\n+      Skip_Controlling_Formals : Boolean := False);\n    --  Check that two callable entities (subprograms, entries, literals)\n    --  are subtype conformant, post error message if not (RM 6.3.1(16))\n    --  the flag being placed on the Err_Loc node if it is specified, and\n@@ -173,6 +174,14 @@ package Sem_Ch6 is\n    --  procedure is also used to get visibility to the formals when analyzing\n    --  preconditions and postconditions appearing in the spec.\n \n+   function Is_Interface_Conformant\n+     (Tagged_Type : Entity_Id;\n+      Iface_Prim  : Entity_Id;\n+      Prim        : Entity_Id) return Boolean;\n+   --  Returns true if both primitives have a matching name and they are also\n+   --  type conformant. Special management is done for functions returning\n+   --  interfaces.\n+\n    function Mode_Conformant (New_Id, Old_Id : Entity_Id) return Boolean;\n    --  Determine whether two callable entities (subprograms, entries,\n    --  literals) are mode conformant (RM 6.3.1(15))\n@@ -212,7 +221,10 @@ package Sem_Ch6 is\n    procedure Set_Formal_Mode (Formal_Id : Entity_Id);\n    --  Set proper Ekind to reflect formal mode (in, out, in out)\n \n-   function Subtype_Conformant (New_Id, Old_Id : Entity_Id) return Boolean;\n+   function Subtype_Conformant\n+     (New_Id                   : Entity_Id;\n+      Old_Id                   : Entity_Id;\n+      Skip_Controlling_Formals : Boolean := False) return Boolean;\n    --  Determine whether two callable entities (subprograms, entries,\n    --  literals) are subtype conformant (RM6.3.1(16)).\n "}, {"sha": "8a85b11e6ee2b83136c816f6ab04afb34ebde3ca", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=ce2b6ba521252796f61a25ada77f3e55ea97b36d", "patch": "@@ -2417,16 +2417,16 @@ package body Sem_Ch9 is\n \n             if Present (Interface_List (N))\n               or else (Is_Tagged_Type (Priv_T)\n-                         and then Has_Abstract_Interfaces\n-                                    (Priv_T, Use_Full_View => False))\n+                         and then Has_Interfaces\n+                                   (Priv_T, Use_Full_View => False))\n             then\n                if Is_Tagged_Type (Priv_T) then\n-                  Collect_Abstract_Interfaces\n+                  Collect_Interfaces\n                     (Priv_T, Priv_T_Ifaces, Use_Full_View => False);\n                end if;\n \n                if Is_Tagged_Type (T) then\n-                  Collect_Abstract_Interfaces (T, Full_T_Ifaces);\n+                  Collect_Interfaces (T, Full_T_Ifaces);\n                end if;\n \n                Iface := Find_Hidden_Interface (Priv_T_Ifaces, Full_T_Ifaces);"}, {"sha": "a8eb3df52e3eb6e3688b7f9e5280a8bc125d19c7", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 135, "deletions": 6, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=ce2b6ba521252796f61a25ada77f3e55ea97b36d", "patch": "@@ -618,6 +618,19 @@ package body Sem_Disp is\n          Tagged_Type := Corresponding_Record_Type (Tagged_Type);\n       end if;\n \n+      --  (AI-345): The task body procedure is not a primitive of the tagged\n+      --  type\n+\n+      if Present (Tagged_Type)\n+        and then Is_Concurrent_Record_Type (Tagged_Type)\n+        and then Present (Corresponding_Concurrent_Type (Tagged_Type))\n+        and then Is_Task_Type (Corresponding_Concurrent_Type (Tagged_Type))\n+        and then Subp = Get_Task_Body_Procedure\n+                          (Corresponding_Concurrent_Type (Tagged_Type))\n+      then\n+         return;\n+      end if;\n+\n       --  If Subp is derived from a dispatching operation then it should\n       --  always be treated as dispatching. In this case various checks\n       --  below will be bypassed. Makes sure that late declarations for\n@@ -870,6 +883,10 @@ package body Sem_Disp is\n       --  Now it should be a correct primitive operation, put it in the list\n \n       if Present (Old_Subp) then\n+\n+         --  If the type has interfaces we complete this check after we\n+         --  set attribute Is_Dispatching_Operation\n+\n          Check_Subtype_Conformant (Subp, Old_Subp);\n \n          if (Chars (Subp) = Name_Initialize\n@@ -902,7 +919,7 @@ package body Sem_Disp is\n                      Prim := Node (Elmt);\n \n                      if Present (Alias (Prim))\n-                       and then Present (Abstract_Interface_Alias (Prim))\n+                       and then Present (Interface_Alias (Prim))\n                        and then Alias (Prim) = Subp\n                      then\n                         Register_Primitive (Sloc (Prim),\n@@ -933,6 +950,78 @@ package body Sem_Disp is\n \n       Set_Is_Dispatching_Operation (Subp, True);\n \n+      --  Ada 2005 (AI-251): If the type implements interfaces we must check\n+      --  subtype conformance against all the interfaces covered by this\n+      --  primitive.\n+\n+      if Present (Old_Subp)\n+        and then Has_Interfaces (Tagged_Type)\n+      then\n+         declare\n+            Ifaces_List     : Elist_Id;\n+            Iface_Elmt      : Elmt_Id;\n+            Iface_Prim_Elmt : Elmt_Id;\n+            Iface_Prim      : Entity_Id;\n+            Ret_Typ         : Entity_Id;\n+\n+         begin\n+            Collect_Interfaces (Tagged_Type, Ifaces_List);\n+\n+            Iface_Elmt := First_Elmt (Ifaces_List);\n+            while Present (Iface_Elmt) loop\n+               if not Is_Ancestor (Node (Iface_Elmt), Tagged_Type) then\n+                  Iface_Prim_Elmt :=\n+                    First_Elmt (Primitive_Operations (Node (Iface_Elmt)));\n+                  while Present (Iface_Prim_Elmt) loop\n+                     Iface_Prim := Node (Iface_Prim_Elmt);\n+\n+                     if Is_Interface_Conformant\n+                          (Tagged_Type, Iface_Prim, Subp)\n+                     then\n+                        --  Handle procedures, functions whose return type\n+                        --  matches, or functions not returning interfaces\n+\n+                        if Ekind (Subp) = E_Procedure\n+                          or else Etype (Iface_Prim) = Etype (Subp)\n+                          or else not Is_Interface (Etype (Iface_Prim))\n+                        then\n+                           Check_Subtype_Conformant\n+                             (New_Id  => Subp,\n+                              Old_Id  => Iface_Prim,\n+                              Err_Loc => Subp,\n+                              Skip_Controlling_Formals => True);\n+\n+                        --  Handle functions returning interfaces\n+\n+                        elsif Implements_Interface\n+                                (Etype (Subp), Etype (Iface_Prim))\n+                        then\n+                           --  Temporarily force both entities to return the\n+                           --  same type. Required because Subtype_Conformant\n+                           --  does not handle this case.\n+\n+                           Ret_Typ := Etype (Iface_Prim);\n+                           Set_Etype (Iface_Prim, Etype (Subp));\n+\n+                           Check_Subtype_Conformant\n+                             (New_Id  => Subp,\n+                              Old_Id  => Iface_Prim,\n+                              Err_Loc => Subp,\n+                              Skip_Controlling_Formals => True);\n+\n+                           Set_Etype (Iface_Prim, Ret_Typ);\n+                        end if;\n+                     end if;\n+\n+                     Next_Elmt (Iface_Prim_Elmt);\n+                  end loop;\n+               end if;\n+\n+               Next_Elmt (Iface_Elmt);\n+            end loop;\n+         end;\n+      end if;\n+\n       if not Body_Is_Last_Primitive then\n          Set_DT_Position (Subp, No_Uint);\n \n@@ -1083,7 +1172,13 @@ package body Sem_Disp is\n          if Derives_From (Node (Op1)) then\n \n             if No (Prev) then\n-               Prepend_Elmt (Subp, New_Prim);\n+\n+               --  Avoid adding it to the list of primitives if already there!\n+\n+               if Node (Op2) /= Subp then\n+                  Prepend_Elmt (Subp, New_Prim);\n+               end if;\n+\n             else\n                Insert_Elmt_After (Subp, Prev);\n             end if;\n@@ -1302,6 +1397,38 @@ package body Sem_Disp is\n       return Empty;\n    end Find_Dispatching_Type;\n \n+   ---------------------------------------\n+   -- Find_Primitive_Covering_Interface --\n+   ---------------------------------------\n+\n+   function Find_Primitive_Covering_Interface\n+     (Tagged_Type : Entity_Id;\n+      Iface_Prim  : Entity_Id) return Entity_Id\n+   is\n+      E : Entity_Id;\n+\n+   begin\n+      pragma Assert (Is_Interface (Find_Dispatching_Type (Iface_Prim))\n+        or else (Present (Alias (Iface_Prim))\n+                   and then\n+                     Is_Interface\n+                       (Find_Dispatching_Type (Ultimate_Alias (Iface_Prim)))));\n+\n+      E := Current_Entity (Iface_Prim);\n+      while Present (E) loop\n+         if Is_Subprogram (E)\n+           and then Is_Dispatching_Operation (E)\n+           and then Is_Interface_Conformant (Tagged_Type, Iface_Prim, E)\n+         then\n+            return E;\n+         end if;\n+\n+         E := Homonym (E);\n+      end loop;\n+\n+      return Empty;\n+   end Find_Primitive_Covering_Interface;\n+\n    ---------------------------\n    -- Is_Dynamically_Tagged --\n    ---------------------------\n@@ -1425,7 +1552,7 @@ package body Sem_Disp is\n       Replace_Elmt (Elmt, New_Op);\n \n       if Ada_Version >= Ada_05\n-        and then Has_Abstract_Interfaces (Tagged_Type)\n+        and then Has_Interfaces (Tagged_Type)\n       then\n          --  Ada 2005 (AI-251): Update the attribute alias of all the aliased\n          --  entities of the overridden primitive to reference New_Op, and also\n@@ -1434,6 +1561,8 @@ package body Sem_Disp is\n          --  operations that it implements (for operations inherited from the\n          --  parent itself, this check is made when building the derived type).\n \n+         --  Note: This code is only executed in case of late overriding\n+\n          Elmt := First_Elmt (Primitive_Operations (Tagged_Type));\n          while Present (Elmt) loop\n             Prim := Node (Elmt);\n@@ -1445,14 +1574,14 @@ package body Sem_Disp is\n             --  reading attributes in entities that are not yet fully decorated\n \n             elsif Is_Subprogram (Prim)\n-              and then Present (Abstract_Interface_Alias (Prim))\n+              and then Present (Interface_Alias (Prim))\n               and then Alias (Prim) = Prev_Op\n               and then Present (Etype (New_Op))\n             then\n                Set_Alias (Prim, New_Op);\n                Check_Subtype_Conformant (New_Op, Prim);\n-               Set_Is_Abstract_Subprogram\n-                 (Prim, Is_Abstract_Subprogram (New_Op));\n+               Set_Is_Abstract_Subprogram (Prim,\n+                 Is_Abstract_Subprogram (New_Op));\n \n                --  Ensure that this entity will be expanded to fill the\n                --  corresponding entry in its dispatch table."}, {"sha": "c0195ecd4fd720a7078f6532e73c13bb67250185", "filename": "gcc/ada/sem_disp.ads", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fsem_disp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fsem_disp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.ads?ref=ce2b6ba521252796f61a25ada77f3e55ea97b36d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -69,6 +69,14 @@ package Sem_Disp is\n    --  Check whether a subprogram is dispatching, and find the tagged\n    --  type of the controlling argument or arguments.\n \n+   function Find_Primitive_Covering_Interface\n+     (Tagged_Type : Entity_Id;\n+      Iface_Prim  : Entity_Id) return Entity_Id;\n+   --  Search in the homonym chain for the primitive of Tagged_Type that\n+   --  covers Iface_Prim. The homonym chain traversal is required to catch\n+   --  primitives associated with the partial view of private types when\n+   --  processing the corresponding full view.\n+\n    function Is_Dynamically_Tagged (N : Node_Id) return Boolean;\n    --  Used to determine whether a call is dispatching, i.e. if is an\n    --  an expression of a class_Wide type, or a call to a function with"}, {"sha": "4a170d82ce3da94175ba143072d539d58ee165a6", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=ce2b6ba521252796f61a25ada77f3e55ea97b36d", "patch": "@@ -421,7 +421,7 @@ package body Sem_Type is\n \n       elsif Is_Hidden (E)\n         and then Is_Subprogram (E)\n-        and then Present (Abstract_Interface_Alias (E))\n+        and then Present (Interface_Alias (E))\n       then\n          --  Ada 2005 (AI-251): If this primitive operation corresponds with\n          --  an immediate ancestor interface there is no need to add it to the\n@@ -431,10 +431,10 @@ package body Sem_Type is\n          --  subprograms which are in fact the same.\n \n          if not Is_Ancestor\n-                  (Find_Dispatching_Type (Abstract_Interface_Alias (E)),\n+                  (Find_Dispatching_Type (Interface_Alias (E)),\n                    Find_Dispatching_Type (E))\n          then\n-            Add_One_Interp (N, Abstract_Interface_Alias (E), T);\n+            Add_One_Interp (N, Interface_Alias (E), T);\n          end if;\n \n          return;\n@@ -783,7 +783,7 @@ package body Sem_Type is\n \n       --  Literals are compatible with types in  a given \"class\"\n \n-      elsif (T2 = Universal_Integer and then Is_Integer_Type (T1))\n+      elsif     (T2 = Universal_Integer and then Is_Integer_Type (T1))\n         or else (T2 = Universal_Real    and then Is_Real_Type (T1))\n         or else (T2 = Universal_Fixed   and then Is_Fixed_Point_Type (T1))\n         or else (T2 = Any_Fixed         and then Is_Fixed_Point_Type (T1))\n@@ -849,9 +849,9 @@ package body Sem_Type is\n             --  Note: test for presence of E is defense against previous error.\n \n             if Present (E)\n-              and then Present (Abstract_Interfaces (E))\n+              and then Present (Interfaces (E))\n             then\n-               Elmt := First_Elmt (Abstract_Interfaces (E));\n+               Elmt := First_Elmt (Interfaces (E));\n                while Present (Elmt) loop\n                   if Is_Ancestor (Etype (T1), Node (Elmt)) then\n                      return True;\n@@ -1032,7 +1032,7 @@ package body Sem_Type is\n          return True;\n \n       elsif Is_Type (T1)\n-        and then  Is_Generic_Actual_Type (T1)\n+        and then Is_Generic_Actual_Type (T1)\n         and then Full_View_Covers (T2, T1)\n       then\n          return True;\n@@ -2251,11 +2251,11 @@ package body Sem_Type is\n          end if;\n \n          loop\n-            if Present (Abstract_Interfaces (E))\n-              and then Present (Abstract_Interfaces (E))\n-              and then not Is_Empty_Elmt_List (Abstract_Interfaces (E))\n+            if Present (Interfaces (E))\n+              and then Present (Interfaces (E))\n+              and then not Is_Empty_Elmt_List (Interfaces (E))\n             then\n-               Elmt := First_Elmt (Abstract_Interfaces (E));\n+               Elmt := First_Elmt (Interfaces (E));\n                while Present (Elmt) loop\n                   AI := Node (Elmt);\n \n@@ -2334,7 +2334,7 @@ package body Sem_Type is\n                   if Etype (AI) = Iface_Typ then\n                      return True;\n \n-                  elsif Present (Abstract_Interfaces (Etype (AI)))\n+                  elsif Present (Interfaces (Etype (AI)))\n                      and then Iface_Present_In_Ancestor (Etype (AI))\n                   then\n                      return True;"}, {"sha": "895491e302b1a4075fd4ea53b907b90f2595c179", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 234, "deletions": 210, "changes": 444, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=ce2b6ba521252796f61a25ada77f3e55ea97b36d", "patch": "@@ -29,6 +29,7 @@ with Checks;   use Checks;\n with Debug;    use Debug;\n with Errout;   use Errout;\n with Elists;   use Elists;\n+with Exp_Disp; use Exp_Disp;\n with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n with Fname;    use Fname;\n@@ -1235,56 +1236,27 @@ package body Sem_Util is\n       end if;\n    end Check_VMS;\n \n-   ---------------------------------\n-   -- Collect_Abstract_Interfaces --\n-   ---------------------------------\n+   ------------------------\n+   -- Collect_Interfaces --\n+   ------------------------\n \n-   procedure Collect_Abstract_Interfaces\n-     (T                         : Entity_Id;\n-      Ifaces_List               : out Elist_Id;\n-      Exclude_Parent_Interfaces : Boolean := False;\n-      Use_Full_View             : Boolean := True)\n+   procedure Collect_Interfaces\n+     (T               : Entity_Id;\n+      Ifaces_List     : out Elist_Id;\n+      Exclude_Parents : Boolean := False;\n+      Use_Full_View   : Boolean := True)\n    is\n-      procedure Add_Interface (Iface : Entity_Id);\n-      --  Add the interface it if is not already in the list\n-\n       procedure Collect (Typ : Entity_Id);\n       --  Subsidiary subprogram used to traverse the whole list\n       --  of directly and indirectly implemented interfaces\n \n-      function Interface_Present_In_Parent\n-         (Typ   : Entity_Id;\n-          Iface : Entity_Id) return Boolean;\n-      --  Typ must be a tagged record type/subtype and Iface must be an\n-      --  abstract interface type. This function is used to check if Typ\n-      --  or some parent of Typ implements Iface.\n-\n-      -------------------\n-      -- Add_Interface --\n-      -------------------\n-\n-      procedure Add_Interface (Iface : Entity_Id) is\n-         Elmt : Elmt_Id;\n-\n-      begin\n-         Elmt := First_Elmt (Ifaces_List);\n-         while Present (Elmt) and then Node (Elmt) /= Iface loop\n-            Next_Elmt (Elmt);\n-         end loop;\n-\n-         if No (Elmt) then\n-            Append_Elmt (Iface, Ifaces_List);\n-         end if;\n-      end Add_Interface;\n-\n       -------------\n       -- Collect --\n       -------------\n \n       procedure Collect (Typ : Entity_Id) is\n          Ancestor   : Entity_Id;\n          Full_T     : Entity_Id;\n-         Iface_List : List_Id;\n          Id         : Node_Id;\n          Iface      : Entity_Id;\n \n@@ -1300,27 +1272,10 @@ package body Sem_Util is\n             Full_T := Full_View (Typ);\n          end if;\n \n-         Iface_List := Abstract_Interface_List (Full_T);\n-\n          --  Include the ancestor if we are generating the whole list of\n          --  abstract interfaces.\n \n-         --  In concurrent types the ancestor interface (if any) is the\n-         --  first element of the list of interface types.\n-\n-         if Is_Concurrent_Type (Full_T)\n-           or else Is_Concurrent_Record_Type (Full_T)\n-         then\n-            if Is_Non_Empty_List (Iface_List) then\n-               Ancestor := Etype (First (Iface_List));\n-               Collect (Ancestor);\n-\n-               if not Exclude_Parent_Interfaces then\n-                  Add_Interface (Ancestor);\n-               end if;\n-            end if;\n-\n-         elsif Etype (Full_T) /= Typ\n+         if Etype (Full_T) /= Typ\n \n             --  Protect the frontend against wrong sources. For example:\n \n@@ -1339,27 +1294,16 @@ package body Sem_Util is\n             Collect (Ancestor);\n \n             if Is_Interface (Ancestor)\n-              and then not Exclude_Parent_Interfaces\n+              and then not Exclude_Parents\n             then\n-               Add_Interface (Ancestor);\n+               Append_Unique_Elmt (Ancestor, Ifaces_List);\n             end if;\n          end if;\n \n          --  Traverse the graph of ancestor interfaces\n \n-         if Is_Non_Empty_List (Iface_List) then\n-            Id := First (Iface_List);\n-\n-            --  In concurrent types the ancestor interface (if any) is the\n-            --  first element of the list of interface types and we have\n-            --  already processed them while climbing to the root type.\n-\n-            if Is_Concurrent_Type (Full_T)\n-              or else Is_Concurrent_Record_Type (Full_T)\n-            then\n-               Next (Id);\n-            end if;\n-\n+         if Is_Non_Empty_List (Abstract_Interface_List (Full_T)) then\n+            Id := First (Abstract_Interface_List (Full_T));\n             while Present (Id) loop\n                Iface := Etype (Id);\n \n@@ -1369,13 +1313,14 @@ package body Sem_Util is\n                --    type Wrong is new I and O with null record; -- ERROR\n \n                if Is_Interface (Iface) then\n-                  if Exclude_Parent_Interfaces\n-                    and then Interface_Present_In_Parent (T, Iface)\n+                  if Exclude_Parents\n+                    and then Etype (T) /= T\n+                    and then Interface_Present_In_Ancestor (Etype (T), Iface)\n                   then\n                      null;\n                   else\n-                     Collect       (Iface);\n-                     Add_Interface (Iface);\n+                     Collect (Iface);\n+                     Append_Unique_Elmt (Iface, Ifaces_List);\n                   end if;\n                end if;\n \n@@ -1384,40 +1329,13 @@ package body Sem_Util is\n          end if;\n       end Collect;\n \n-      ---------------------------------\n-      -- Interface_Present_In_Parent --\n-      ---------------------------------\n-\n-      function Interface_Present_In_Parent\n-         (Typ   : Entity_Id;\n-          Iface : Entity_Id) return Boolean\n-      is\n-         Aux        : Entity_Id := Typ;\n-         Iface_List : List_Id;\n-\n-      begin\n-         if Is_Concurrent_Type (Typ)\n-           or else Is_Concurrent_Record_Type (Typ)\n-         then\n-            Iface_List := Abstract_Interface_List (Typ);\n-\n-            if Is_Non_Empty_List (Iface_List) then\n-               Aux := Etype (First (Iface_List));\n-            else\n-               return False;\n-            end if;\n-         end if;\n-\n-         return Interface_Present_In_Ancestor (Aux, Iface);\n-      end Interface_Present_In_Parent;\n-\n-   --  Start of processing for Collect_Abstract_Interfaces\n+   --  Start of processing for Collect_Interfaces\n \n    begin\n       pragma Assert (Is_Tagged_Type (T) or else Is_Concurrent_Type (T));\n       Ifaces_List := New_Elmt_List;\n       Collect (T);\n-   end Collect_Abstract_Interfaces;\n+   end Collect_Interfaces;\n \n    ----------------------------------\n    -- Collect_Interface_Components --\n@@ -1526,7 +1444,7 @@ package body Sem_Util is\n    --  Start of processing for Collect_Interfaces_Info\n \n    begin\n-      Collect_Abstract_Interfaces  (T, Ifaces_List);\n+      Collect_Interfaces  (T, Ifaces_List);\n       Collect_Interface_Components (T, Comps_List);\n \n       --  Search for the record component and tag associated with each\n@@ -1542,7 +1460,7 @@ package body Sem_Util is\n          --  Associate the primary tag component and the primary dispatch table\n          --  with all the interfaces that are parents of T\n \n-         if Is_Parent (Iface, T) then\n+         if Is_Ancestor (Iface, T) then\n             Append_Elmt (First_Tag_Component (T), Components_List);\n             Append_Elmt (Node (First_Elmt (Access_Disp_Table (T))), Tags_List);\n \n@@ -1555,7 +1473,7 @@ package body Sem_Util is\n                Comp_Iface := Related_Type (Node (Comp_Elmt));\n \n                if Comp_Iface = Iface\n-                 or else Is_Parent (Iface, Comp_Iface)\n+                 or else Is_Ancestor (Iface, Comp_Iface)\n                then\n                   Append_Elmt (Node (Comp_Elmt), Components_List);\n                   Append_Elmt (Search_Tag (Comp_Iface), Tags_List);\n@@ -4085,83 +4003,6 @@ package body Sem_Util is\n       return Task_Body_Procedure (Underlying_Type (Root_Type (E)));\n    end Get_Task_Body_Procedure;\n \n-   -----------------------------\n-   -- Has_Abstract_Interfaces --\n-   -----------------------------\n-\n-   function Has_Abstract_Interfaces\n-     (T             : Entity_Id;\n-      Use_Full_View : Boolean := True) return Boolean\n-   is\n-      Typ : Entity_Id;\n-\n-   begin\n-      --  Handle concurrent types\n-\n-      if Is_Concurrent_Type (T) then\n-         Typ := Corresponding_Record_Type (T);\n-      else\n-         Typ := T;\n-      end if;\n-\n-      if not Present (Typ)\n-        or else not Is_Tagged_Type (Typ)\n-      then\n-         return False;\n-      end if;\n-\n-      pragma Assert (Is_Record_Type (Typ));\n-\n-      --  Handle private types\n-\n-      if Use_Full_View\n-        and then Present (Full_View (Typ))\n-      then\n-         Typ := Full_View (Typ);\n-      end if;\n-\n-      --  Handle concurrent record types\n-\n-      if Is_Concurrent_Record_Type (Typ)\n-        and then Is_Non_Empty_List (Abstract_Interface_List (Typ))\n-      then\n-         return True;\n-      end if;\n-\n-      loop\n-         if Is_Interface (Typ)\n-           or else\n-             (Is_Record_Type (Typ)\n-               and then Present (Abstract_Interfaces (Typ))\n-               and then not Is_Empty_Elmt_List (Abstract_Interfaces (Typ)))\n-         then\n-            return True;\n-         end if;\n-\n-         exit when Etype (Typ) = Typ\n-\n-            --  Handle private types\n-\n-            or else (Present (Full_View (Etype (Typ)))\n-                       and then Full_View (Etype (Typ)) = Typ)\n-\n-            --  Protect the frontend against wrong source with cyclic\n-            --  derivations\n-\n-            or else Etype (Typ) = T;\n-\n-         --  Climb to the ancestor type handling private types\n-\n-         if Present (Full_View (Etype (Typ))) then\n-            Typ := Full_View (Etype (Typ));\n-         else\n-            Typ := Etype (Typ);\n-         end if;\n-      end loop;\n-\n-      return False;\n-   end Has_Abstract_Interfaces;\n-\n    -----------------------\n    -- Has_Access_Values --\n    -----------------------\n@@ -4616,6 +4457,82 @@ package body Sem_Util is\n           and then Includes_Infinities (Scalar_Range (E));\n    end Has_Infinities;\n \n+   --------------------\n+   -- Has_Interfaces --\n+   --------------------\n+\n+   function Has_Interfaces\n+     (T             : Entity_Id;\n+      Use_Full_View : Boolean := True) return Boolean\n+   is\n+      Typ : Entity_Id;\n+\n+   begin\n+      --  Handle concurrent types\n+\n+      if Is_Concurrent_Type (T) then\n+         Typ := Corresponding_Record_Type (T);\n+      else\n+         Typ := T;\n+      end if;\n+\n+      if not Present (Typ)\n+        or else not Is_Record_Type (Typ)\n+        or else not Is_Tagged_Type (Typ)\n+      then\n+         return False;\n+      end if;\n+\n+      --  Handle private types\n+\n+      if Use_Full_View\n+        and then Present (Full_View (Typ))\n+      then\n+         Typ := Full_View (Typ);\n+      end if;\n+\n+      --  Handle concurrent record types\n+\n+      if Is_Concurrent_Record_Type (Typ)\n+        and then Is_Non_Empty_List (Abstract_Interface_List (Typ))\n+      then\n+         return True;\n+      end if;\n+\n+      loop\n+         if Is_Interface (Typ)\n+           or else\n+             (Is_Record_Type (Typ)\n+               and then Present (Interfaces (Typ))\n+               and then not Is_Empty_Elmt_List (Interfaces (Typ)))\n+         then\n+            return True;\n+         end if;\n+\n+         exit when Etype (Typ) = Typ\n+\n+            --  Handle private types\n+\n+            or else (Present (Full_View (Etype (Typ)))\n+                       and then Full_View (Etype (Typ)) = Typ)\n+\n+            --  Protect the frontend against wrong source with cyclic\n+            --  derivations\n+\n+            or else Etype (Typ) = T;\n+\n+         --  Climb to the ancestor type handling private types\n+\n+         if Present (Full_View (Etype (Typ))) then\n+            Typ := Full_View (Etype (Typ));\n+         else\n+            Typ := Etype (Typ);\n+         end if;\n+      end loop;\n+\n+      return False;\n+   end Has_Interfaces;\n+\n    ------------------------\n    -- Has_Null_Exclusion --\n    ------------------------\n@@ -5219,6 +5136,56 @@ package body Sem_Util is\n       end if;\n    end Has_Tagged_Component;\n \n+   --------------------------\n+   -- Implements_Interface --\n+   --------------------------\n+\n+   function Implements_Interface\n+     (Typ_Ent         : Entity_Id;\n+      Iface_Ent       : Entity_Id;\n+      Exclude_Parents : Boolean := False) return Boolean\n+   is\n+      Ifaces_List : Elist_Id;\n+      Elmt        : Elmt_Id;\n+      Iface       : Entity_Id;\n+      Typ         : Entity_Id;\n+\n+   begin\n+      if Is_Class_Wide_Type (Typ_Ent) then\n+         Typ := Etype (Typ_Ent);\n+      else\n+         Typ := Typ_Ent;\n+      end if;\n+\n+      if Is_Class_Wide_Type (Iface_Ent) then\n+         Iface := Etype (Iface_Ent);\n+      else\n+         Iface := Iface_Ent;\n+      end if;\n+\n+      if not Has_Interfaces (Typ) then\n+         return False;\n+      end if;\n+\n+      Collect_Interfaces (Typ, Ifaces_List);\n+\n+      Elmt := First_Elmt (Ifaces_List);\n+      while Present (Elmt) loop\n+         if Is_Ancestor (Node (Elmt), Typ)\n+           and then Exclude_Parents\n+         then\n+            null;\n+\n+         elsif Node (Elmt) = Iface then\n+            return True;\n+         end if;\n+\n+         Next_Elmt (Elmt);\n+      end loop;\n+\n+      return False;\n+   end Implements_Interface;\n+\n    -----------------\n    -- In_Instance --\n    -----------------\n@@ -6524,33 +6491,6 @@ package body Sem_Util is\n       end if;\n    end Is_OK_Variable_For_Out_Formal;\n \n-   ---------------\n-   -- Is_Parent --\n-   ---------------\n-\n-   function Is_Parent\n-     (E1 : Entity_Id;\n-      E2 : Entity_Id) return Boolean\n-   is\n-      Iface_List : List_Id;\n-      T          : Entity_Id := E2;\n-\n-   begin\n-      if Is_Concurrent_Type (T)\n-        or else Is_Concurrent_Record_Type (T)\n-      then\n-         Iface_List := Abstract_Interface_List (E2);\n-\n-         if Is_Empty_List (Iface_List) then\n-            return False;\n-         end if;\n-\n-         T := Etype (First (Iface_List));\n-      end if;\n-\n-      return Is_Ancestor (E1, T);\n-   end Is_Parent;\n-\n    -----------------------------------\n    -- Is_Partially_Initialized_Type --\n    -----------------------------------\n@@ -8494,6 +8434,48 @@ package body Sem_Util is\n       return Trace_Components (Type_Id, False);\n    end Private_Component;\n \n+   ---------------------------\n+   -- Primitive_Names_Match --\n+   ---------------------------\n+\n+   function Primitive_Names_Match (E1, E2 : Entity_Id) return Boolean is\n+\n+      function Non_Internal_Name (E : Entity_Id) return Name_Id;\n+      --  Given an internal name, returns the corresponding non-internal name\n+\n+      ------------------------\n+      --  Non_Internal_Name --\n+      ------------------------\n+\n+      function Non_Internal_Name (E : Entity_Id) return Name_Id is\n+      begin\n+         Get_Name_String (Chars (E));\n+         Name_Len := Name_Len - 1;\n+         return Name_Find;\n+      end Non_Internal_Name;\n+\n+   --  Start of processing for Primitive_Names_Match\n+\n+   begin\n+      pragma Assert (Present (E1) and then Present (E2));\n+\n+      return Chars (E1) = Chars (E2)\n+        or else\n+           (not Is_Internal_Name (Chars (E1))\n+              and then Is_Internal_Name (Chars (E2))\n+              and then Non_Internal_Name (E2) = Chars (E1))\n+        or else\n+           (not Is_Internal_Name (Chars (E2))\n+              and then Is_Internal_Name (Chars (E1))\n+              and then Non_Internal_Name (E1) = Chars (E2))\n+        or else\n+           (Is_Predefined_Dispatching_Operation (E1)\n+              and then Is_Predefined_Dispatching_Operation (E2)\n+              and then Same_TSS (E1, E2))\n+        or else\n+           (Is_Init_Proc (E1) and then Is_Init_Proc (E2));\n+   end Primitive_Names_Match;\n+\n    -----------------------\n    -- Process_End_Label --\n    -----------------------\n@@ -8703,6 +8685,32 @@ package body Sem_Util is\n       return Token_Node;\n    end Real_Convert;\n \n+   --------------------\n+   -- Remove_Homonym --\n+   --------------------\n+\n+   procedure Remove_Homonym (E : Entity_Id) is\n+      Prev  : Entity_Id := Empty;\n+      H     : Entity_Id;\n+\n+   begin\n+      if E = Current_Entity (E) then\n+         if Present (Homonym (E)) then\n+            Set_Current_Entity (Homonym (E));\n+         else\n+            Set_Name_Entity_Id (Chars (E), Empty);\n+         end if;\n+      else\n+         H := Current_Entity (E);\n+         while Present (H) and then H /= E loop\n+            Prev := H;\n+            H    := Homonym (H);\n+         end loop;\n+\n+         Set_Homonym (Prev, Homonym (E));\n+      end if;\n+   end Remove_Homonym;\n+\n    ---------------------\n    -- Rep_To_Pos_Flag --\n    ---------------------\n@@ -9745,6 +9753,22 @@ package body Sem_Util is\n       return Scope_Depth (Enclosing_Dynamic_Scope (Btyp));\n    end Type_Access_Level;\n \n+   --------------------\n+   -- Ultimate_Alias --\n+   --------------------\n+   --  To do: add occurrences calling this new subprogram\n+\n+   function Ultimate_Alias (Prim : Entity_Id) return Entity_Id is\n+      E : Entity_Id := Prim;\n+\n+   begin\n+      while Present (Alias (E)) loop\n+         E := Alias (E);\n+      end loop;\n+\n+      return E;\n+   end Ultimate_Alias;\n+\n    --------------------------\n    -- Unit_Declaration_Node --\n    --------------------------"}, {"sha": "aeedc7d0a811bab0def3ac4cc417f2ea96d37fb0", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 35, "deletions": 22, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=ce2b6ba521252796f61a25ada77f3e55ea97b36d", "patch": "@@ -152,14 +152,14 @@ package Sem_Util is\n    --  with OpenVMS ports. The argument is the construct in question\n    --  and is used to post the error message.\n \n-   procedure Collect_Abstract_Interfaces\n-     (T                         : Entity_Id;\n-      Ifaces_List               : out Elist_Id;\n-      Exclude_Parent_Interfaces : Boolean := False;\n-      Use_Full_View             : Boolean := True);\n+   procedure Collect_Interfaces\n+     (T               : Entity_Id;\n+      Ifaces_List     : out Elist_Id;\n+      Exclude_Parents : Boolean := False;\n+      Use_Full_View   : Boolean := True);\n    --  Ada 2005 (AI-251): Collect whole list of abstract interfaces that are\n-   --  directly or indirectly implemented by T. Exclude_Parent_Interfaces is\n-   --  used to avoid addition of inherited interfaces to the generated list.\n+   --  directly or indirectly implemented by T. Exclude_Parents is used to\n+   --  avoid the addition of inherited interfaces to the generated list.\n    --  Use_Full_View is used to collect the interfaces using the full-view\n    --  (if available).\n \n@@ -498,14 +498,6 @@ package Sem_Util is\n    --  as an access type internally, this function tests only for access types\n    --  known to the programmer. See also Has_Tagged_Component.\n \n-   function Has_Abstract_Interfaces\n-     (T             : Entity_Id;\n-      Use_Full_View : Boolean := True) return Boolean;\n-   --  Where T is a concurrent type or a record type, returns true if T covers\n-   --  any abstract interface types. In case of private types the argument\n-   --  Use_Full_View controls if the check is done using its full view (if\n-   --  available).\n-\n    type Alignment_Result is (Known_Compatible, Unknown, Known_Incompatible);\n    --  Result of Has_Compatible_Alignment test, description found below. Note\n    --  that the values are arranged in increasing order of problematicness.\n@@ -542,6 +534,14 @@ package Sem_Util is\n    --  Determines if the range of the floating-point type E includes\n    --  infinities. Returns False if E is not a floating-point type.\n \n+   function Has_Interfaces\n+     (T             : Entity_Id;\n+      Use_Full_View : Boolean := True) return Boolean;\n+   --  Where T is a concurrent type or a record type, returns true if T covers\n+   --  any abstract interface types. In case of private types the argument\n+   --  Use_Full_View controls if the check is done using its full view (if\n+   --  available).\n+\n    function Has_Null_Exclusion (N : Node_Id) return Boolean;\n    --  Determine whether node N has a null exclusion\n \n@@ -572,6 +572,12 @@ package Sem_Util is\n    --  component is present. This function is used to check if '=' has to be\n    --  expanded into a bunch component comparisons.\n \n+   function Implements_Interface\n+     (Typ_Ent         : Entity_Id;\n+      Iface_Ent       : Entity_Id;\n+      Exclude_Parents : Boolean := False) return Boolean;\n+   --  Returns true if the Typ implements interface Iface\n+\n    function In_Instance return Boolean;\n    --  Returns True if the current scope is within a generic instance\n \n@@ -716,13 +722,6 @@ package Sem_Util is\n    --  is a variable (in the Is_Variable sense) with a non-tagged type\n    --  target are considered view conversions and hence variables.\n \n-   function Is_Parent\n-     (E1 : Entity_Id;\n-      E2 : Entity_Id) return Boolean;\n-   --  Determine whether E1 is a parent of E2. For a concurrent type, the\n-   --  parent is the first element of its list of interface types; for other\n-   --  types, this function provides the same result as Is_Ancestor.\n-\n    function Is_Partially_Initialized_Type (Typ : Entity_Id) return Boolean;\n    --  Typ is a type entity. This function returns true if this type is\n    --  partly initialized, meaning that an object of the type is at least\n@@ -951,6 +950,13 @@ package Sem_Util is\n    --  For convenience, qualified expressions applied to object names\n    --  are also allowed as actuals for this function.\n \n+   function Primitive_Names_Match (E1, E2 : Entity_Id) return Boolean;\n+   --  Returns True if the names of both entities correspond with matching\n+   --  primitives. This routine includes support for the case in which one\n+   --  or both entities correspond with entities built by Derive_Subprogram\n+   --  with a special name to avoid being overriden (ie. return true in case\n+   --  of entities with names \"nameP\" and \"name\" or viceversa).\n+\n    function Private_Component (Type_Id : Entity_Id) return Entity_Id;\n    --  Returns some private component (if any) of the given Type_Id.\n    --  Used to enforce the rules on visibility of operations on composite\n@@ -974,6 +980,9 @@ package Sem_Util is\n    --  S is a possibly signed syntactically valid real literal. The result\n    --  returned is an N_Real_Literal node representing the literal value.\n \n+   procedure Remove_Homonym (E : Entity_Id);\n+   --  Removes E from the homonym chain\n+\n    function Rep_To_Pos_Flag (E : Entity_Id; Loc : Source_Ptr) return Node_Id;\n    --  This is used to construct the second argument in a call to Rep_To_Pos\n    --  which is Standard_True if range checks are enabled (E is an entity to\n@@ -1147,6 +1156,10 @@ package Sem_Util is\n    function Type_Access_Level (Typ : Entity_Id) return Uint;\n    --  Return the accessibility level of Typ\n \n+   function Ultimate_Alias (Prim : Entity_Id) return Entity_Id;\n+   --  Return the last entity in the chain of aliased entities of Prim.\n+   --  If Prim has no alias return Prim.\n+\n    function Unit_Declaration_Node (Unit_Id : Entity_Id) return Node_Id;\n    --  Unit_Id is the simple name of a program unit, this function returns the\n    --  corresponding xxx_Declaration node for the entity. Also applies to the"}, {"sha": "4306ce41450a38b6c369949cf215cd3efd03f82c", "filename": "gcc/ada/sprint.adb", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fsprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2b6ba521252796f61a25ada77f3e55ea97b36d/gcc%2Fada%2Fsprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.adb?ref=ce2b6ba521252796f61a25ada77f3e55ea97b36d", "patch": "@@ -1577,6 +1577,11 @@ package body Sprint is\n             Write_Str_With_Col_Check_Sloc (\"new \");\n             Sprint_Node (Subtype_Mark (Node));\n \n+            if Present (Interface_List (Node)) then\n+               Write_Str_With_Col_Check (\" and \");\n+               Sprint_And_List (Interface_List (Node));\n+            end if;\n+\n             if Private_Present (Node) then\n                Write_Str_With_Col_Check (\" with private\");\n             end if;\n@@ -2442,6 +2447,12 @@ package body Sprint is\n \n             Write_Str_With_Col_Check (\" is new \");\n             Sprint_Node (Subtype_Indication (Node));\n+\n+            if Present (Interface_List (Node)) then\n+               Write_Str_With_Col_Check (\" and \");\n+               Sprint_And_List (Interface_List (Node));\n+            end if;\n+\n             Write_Str_With_Col_Check (\" with private;\");\n \n          when N_Procedure_Call_Statement =>"}]}