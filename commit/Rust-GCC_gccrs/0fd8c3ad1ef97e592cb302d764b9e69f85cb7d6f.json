{"sha": "0fd8c3ad1ef97e592cb302d764b9e69f85cb7d6f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGZkOGMzYWQxZWY5N2U1OTJjYjMwMmQ3NjRiOWU2OWY4NWNiN2Q2Zg==", "commit": {"author": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2009-06-18T12:24:10Z"}, "committer": {"name": "Sandra Loosemore", "email": "sandra@gcc.gnu.org", "date": "2009-06-18T12:24:10Z"}, "message": "extend.texi (Half-Precision): New section.\n\n2009-06-18  Sandra Loosemore  <sandra@codesourcery.com>\n\n\tgcc/\n\t* doc/extend.texi (Half-Precision): New section.\n\t* doc/invoke.texi (Option Summary): List -mfp16-format.\n\t(ARM Options): List neon-fp16 as -mfpu value.  Document -mfp16-format.\n\t* config/arm/arm.opt (mfp16-format=): New.\n\t* config/arm/arm.c: Include intl.h.\n\t(TARGET_INVALID_PARAMETER_TYPE): Redefine.\n\t(TARGET_INVALID_RETURN_TYPE): Redefine.\n\t(TARGET_PROMOTED_TYPE): Redefine.\n\t(TARGET_CONVERT_TO_TYPE): Redefine.\n\t(arm_fp16_format): Define.\n\t(all_fpus): Add entry for neon-fp16.\n\t(fp_model_for_fpu): Likewise.\n\t(struct fp16_format): Declare.\n\t(all_fp16_formats): Define.\n\t(arm_init_libfuncs): Add entries for HFmode conversions and arithmetic\n\tfunctions.\n\t(arm_override_options): Set arm_fp16_format. Call sorry for fp16\n\tand no ldrh.\n\t(arm_legitimate_index_p): Treat HFmode like HImode.\n\t(thumb1_legitimate_address_p): Make it recognize HFmode constants.\n\t(coproc_secondary_reload_class): Special-case HFmode.\n\t(arm_print_operand): Add 'z' specifier for vld1.16/vst1.16.\n\t(arm_hard_regno_mode_ok): Allow HFmode values in VFP registers.\n\t(arm_init_fp16_builtins): New.\n\t(arm_init_builtins): Call it.\n\t(arm_invalid_parameter_type): New.\n\t(arm_invalid_return_type): New.\n\t(arm_promoted_type): New.\n\t(arm_convert_to_type).\n\t(arm_file_start): Deal with neon-fp16 as fpu_name.  Emit tag for fp16\n\tformat.\n\t(arm_emit_fp16_const): New function.\n\t(arm_mangle_type): Mangle __fp16 as \"Dh\".\n\t* config/arm/arm.h (TARGET_VFPD32): Make it know about\n\tFPUTYPE_NEON_FP16.\n\t(TARGET_NEON_FP16): New.\n\t(TARGET_NEON): Make it know about FPUTYPE_NEON_FP16.\n\t(enum fputype): Add FPUTYPE_NEON_FP16.\n\t(enum arm_fp16_format_type): Declare.\n\t(arm_fp16_format): Declare.\n\t(LARGEST_EXPONENT_IS_NORMAL): Define.\n\t* config/arm/arm-protos.h (arm_emit_fp16_const): Declare.\n\t* config/arm/arm-modes.def (HFmode): Define.\n\t* config/arm/vfp.md: (*movhf_vfp): New.\n\t(extendhfsf2): New.\n\t(truncsfhf2): New.\n\t* config/arm/arm.md: (fpu): Add neon_fp16.\n\t(floatsihf2, floatdihf2): New.\n\t(fix_trunchfsi2, fix_trunchfdi2): New.\n\t(truncdfhf2): New.\n\t(extendhfdf2): New.\n\t(movhf): New.\n\t(*arm32_movhf): New.\n\t(*thumb1_movhf): New.\n\t(consttable_2): Add check for HFmode constants.\n\t(consttable_4): Handle HFmode constants.\n\nFrom-SVN: r148654", "tree": {"sha": "c59b4303d74346dd274c9504a6302946ba670574", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c59b4303d74346dd274c9504a6302946ba670574"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0fd8c3ad1ef97e592cb302d764b9e69f85cb7d6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fd8c3ad1ef97e592cb302d764b9e69f85cb7d6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fd8c3ad1ef97e592cb302d764b9e69f85cb7d6f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fd8c3ad1ef97e592cb302d764b9e69f85cb7d6f/comments", "author": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2c2f70e1f266b6582398248096feccaceb2dd70c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c2f70e1f266b6582398248096feccaceb2dd70c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c2f70e1f266b6582398248096feccaceb2dd70c"}], "stats": {"total": 696, "additions": 668, "deletions": 28}, "files": [{"sha": "83df7adb529d3e548ae6318c96f920a1feb6bec9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fd8c3ad1ef97e592cb302d764b9e69f85cb7d6f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fd8c3ad1ef97e592cb302d764b9e69f85cb7d6f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0fd8c3ad1ef97e592cb302d764b9e69f85cb7d6f", "patch": "@@ -1,3 +1,62 @@\n+2009-06-18  Sandra Loosemore  <sandra@codesourcery.com>\n+\n+\t* doc/extend.texi (Half-Precision): New section.\n+\t* doc/invoke.texi (Option Summary): List -mfp16-format.\n+\t(ARM Options): List neon-fp16 as -mfpu value.  Document -mfp16-format.\n+\t* config/arm/arm.opt (mfp16-format=): New.\n+\t* config/arm/arm.c: Include intl.h.\n+\t(TARGET_INVALID_PARAMETER_TYPE): Redefine.\n+\t(TARGET_INVALID_RETURN_TYPE): Redefine.\n+\t(TARGET_PROMOTED_TYPE): Redefine.\n+\t(TARGET_CONVERT_TO_TYPE): Redefine.\n+\t(arm_fp16_format): Define.\n+\t(all_fpus): Add entry for neon-fp16.\n+\t(fp_model_for_fpu): Likewise.\n+\t(struct fp16_format): Declare.\n+\t(all_fp16_formats): Define.\n+\t(arm_init_libfuncs): Add entries for HFmode conversions and arithmetic\n+\tfunctions.\n+\t(arm_override_options): Set arm_fp16_format. Call sorry for fp16\n+\tand no ldrh.\n+\t(arm_legitimate_index_p): Treat HFmode like HImode.\n+\t(thumb1_legitimate_address_p): Make it recognize HFmode constants.\n+\t(coproc_secondary_reload_class): Special-case HFmode.\n+\t(arm_print_operand): Add 'z' specifier for vld1.16/vst1.16.\n+\t(arm_hard_regno_mode_ok): Allow HFmode values in VFP registers.\n+\t(arm_init_fp16_builtins): New.\n+\t(arm_init_builtins): Call it.\n+\t(arm_invalid_parameter_type): New.\n+\t(arm_invalid_return_type): New.\n+\t(arm_promoted_type): New.\n+\t(arm_convert_to_type).\n+\t(arm_file_start): Deal with neon-fp16 as fpu_name.  Emit tag for fp16\n+\tformat.\n+\t(arm_emit_fp16_const): New function.\n+\t(arm_mangle_type): Mangle __fp16 as \"Dh\".\n+\t* config/arm/arm.h (TARGET_VFPD32): Make it know about\n+\tFPUTYPE_NEON_FP16.\n+\t(TARGET_NEON_FP16): New.\n+\t(TARGET_NEON): Make it know about FPUTYPE_NEON_FP16.\n+\t(enum fputype): Add FPUTYPE_NEON_FP16.\n+\t(enum arm_fp16_format_type): Declare.\n+\t(arm_fp16_format): Declare.\n+\t(LARGEST_EXPONENT_IS_NORMAL): Define.\n+\t* config/arm/arm-protos.h (arm_emit_fp16_const): Declare.\n+\t* config/arm/arm-modes.def (HFmode): Define.\n+\t* config/arm/vfp.md: (*movhf_vfp): New.\n+\t(extendhfsf2): New.\n+\t(truncsfhf2): New.\n+\t* config/arm/arm.md: (fpu): Add neon_fp16.\n+\t(floatsihf2, floatdihf2): New.\n+\t(fix_trunchfsi2, fix_trunchfdi2): New.\n+\t(truncdfhf2): New.\n+\t(extendhfdf2): New.\n+\t(movhf): New.\n+\t(*arm32_movhf): New.\n+\t(*thumb1_movhf): New.\n+\t(consttable_2): Add check for HFmode constants.\n+\t(consttable_4): Handle HFmode constants.\n+\n 2009-06-18  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* convert.c (convert_to_integer): Convert (int)logb() into ilogb()."}, {"sha": "813ce8ec14287c8310e78eebd8694e17476c5585", "filename": "gcc/config/arm/arm-modes.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fd8c3ad1ef97e592cb302d764b9e69f85cb7d6f/gcc%2Fconfig%2Farm%2Farm-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fd8c3ad1ef97e592cb302d764b9e69f85cb7d6f/gcc%2Fconfig%2Farm%2Farm-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-modes.def?ref=0fd8c3ad1ef97e592cb302d764b9e69f85cb7d6f", "patch": "@@ -25,6 +25,11 @@\n    FIXME What format is this?  */\n FLOAT_MODE (XF, 12, 0);\n \n+/* Half-precision floating point */\n+FLOAT_MODE (HF, 2, 0);\n+ADJUST_FLOAT_FORMAT (HF, ((arm_fp16_format == ARM_FP16_FORMAT_ALTERNATIVE)\n+\t\t\t  ? &arm_half_format : &ieee_half_format));\n+\n /* CCFPEmode should be used with floating inequalities,\n    CCFPmode should be used with floating equalities.\n    CC_NOOVmode should be used with SImode integer equalities."}, {"sha": "b911a970d82011d28a68059af275cf750c2e4c14", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fd8c3ad1ef97e592cb302d764b9e69f85cb7d6f/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fd8c3ad1ef97e592cb302d764b9e69f85cb7d6f/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=0fd8c3ad1ef97e592cb302d764b9e69f85cb7d6f", "patch": "@@ -140,6 +140,7 @@ extern void arm_final_prescan_insn (rtx);\n extern int arm_debugger_arg_offset (int, rtx);\n extern bool arm_is_long_call_p (tree);\n extern int    arm_emit_vector_const (FILE *, rtx);\n+extern void arm_emit_fp16_const (rtx c);\n extern const char * arm_output_load_gr (rtx *);\n extern const char *vfp_output_fstmd (rtx *);\n extern void arm_set_return_address (rtx, rtx);"}, {"sha": "e6b2edb39adb77b0541d6f30dc62cfdc637d8cb1", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 242, "deletions": 13, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fd8c3ad1ef97e592cb302d764b9e69f85cb7d6f/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fd8c3ad1ef97e592cb302d764b9e69f85cb7d6f/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=0fd8c3ad1ef97e592cb302d764b9e69f85cb7d6f", "patch": "@@ -53,6 +53,7 @@\n #include \"debug.h\"\n #include \"langhooks.h\"\n #include \"df.h\"\n+#include \"intl.h\"\n \n /* Forward definitions of types.  */\n typedef struct minipool_node    Mnode;\n@@ -200,6 +201,10 @@ static bool arm_tls_symbol_p (rtx x);\n static int arm_issue_rate (void);\n static void arm_output_dwarf_dtprel (FILE *, int, rtx) ATTRIBUTE_UNUSED;\n static bool arm_allocate_stack_slots_for_args (void);\n+static const char *arm_invalid_parameter_type (const_tree t);\n+static const char *arm_invalid_return_type (const_tree t);\n+static tree arm_promoted_type (const_tree t);\n+static tree arm_convert_to_type (tree type, tree expr);\n \n \f\n /* Initialize the GCC target structure.  */\n@@ -407,6 +412,18 @@ static bool arm_allocate_stack_slots_for_args (void);\n #undef TARGET_LEGITIMATE_ADDRESS_P\n #define TARGET_LEGITIMATE_ADDRESS_P\tarm_legitimate_address_p\n \n+#undef TARGET_INVALID_PARAMETER_TYPE\n+#define TARGET_INVALID_PARAMETER_TYPE arm_invalid_parameter_type\n+\n+#undef TARGET_INVALID_RETURN_TYPE\n+#define TARGET_INVALID_RETURN_TYPE arm_invalid_return_type\n+\n+#undef TARGET_PROMOTED_TYPE\n+#define TARGET_PROMOTED_TYPE arm_promoted_type\n+\n+#undef TARGET_CONVERT_TO_TYPE\n+#define TARGET_CONVERT_TO_TYPE arm_convert_to_type\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Obstack for minipool constant handling.  */\n@@ -440,6 +457,9 @@ enum fputype arm_fpu_tune;\n /* Whether to use floating point hardware.  */\n enum float_abi_type arm_float_abi;\n \n+/* Which __fp16 format to use.  */\n+enum arm_fp16_format_type arm_fp16_format;\n+\n /* Which ABI to use.  */\n enum arm_abi_type arm_abi;\n \n@@ -719,15 +739,16 @@ struct fpu_desc\n \n static const struct fpu_desc all_fpus[] =\n {\n-  {\"fpa\",\tFPUTYPE_FPA},\n-  {\"fpe2\",\tFPUTYPE_FPA_EMU2},\n-  {\"fpe3\",\tFPUTYPE_FPA_EMU2},\n-  {\"maverick\",\tFPUTYPE_MAVERICK},\n-  {\"vfp\",\tFPUTYPE_VFP},\n-  {\"vfp3\",\tFPUTYPE_VFP3},\n-  {\"vfpv3\",\tFPUTYPE_VFP3},\n-  {\"vfpv3-d16\",\tFPUTYPE_VFP3D16},\n-  {\"neon\",\tFPUTYPE_NEON}\n+  {\"fpa\",\t\tFPUTYPE_FPA},\n+  {\"fpe2\",\t\tFPUTYPE_FPA_EMU2},\n+  {\"fpe3\",\t\tFPUTYPE_FPA_EMU2},\n+  {\"maverick\",\t\tFPUTYPE_MAVERICK},\n+  {\"vfp\",\t\tFPUTYPE_VFP},\n+  {\"vfp3\",\t\tFPUTYPE_VFP3},\n+  {\"vfpv3\",\t\tFPUTYPE_VFP3},\n+  {\"vfpv3-d16\",\t\tFPUTYPE_VFP3D16},\n+  {\"neon\",\t\tFPUTYPE_NEON},\n+  {\"neon-fp16\",\t\tFPUTYPE_NEON_FP16}\n };\n \n \n@@ -745,7 +766,8 @@ static const enum arm_fp_model fp_model_for_fpu[] =\n   ARM_FP_MODEL_VFP,\t\t/* FPUTYPE_VFP  */\n   ARM_FP_MODEL_VFP,\t\t/* FPUTYPE_VFP3D16  */\n   ARM_FP_MODEL_VFP,\t\t/* FPUTYPE_VFP3  */\n-  ARM_FP_MODEL_VFP\t\t/* FPUTYPE_NEON  */\n+  ARM_FP_MODEL_VFP,\t\t/* FPUTYPE_NEON  */\n+  ARM_FP_MODEL_VFP\t\t/* FPUTYPE_NEON_FP16  */\n };\n \n \n@@ -766,6 +788,23 @@ static const struct float_abi all_float_abis[] =\n };\n \n \n+struct fp16_format\n+{\n+  const char *name;\n+  enum arm_fp16_format_type fp16_format_type;\n+};\n+\n+\n+/* Available values for -mfp16-format=.  */\n+\n+static const struct fp16_format all_fp16_formats[] =\n+{\n+  {\"none\",\t\tARM_FP16_FORMAT_NONE},\n+  {\"ieee\",\t\tARM_FP16_FORMAT_IEEE},\n+  {\"alternative\",\tARM_FP16_FORMAT_ALTERNATIVE}\n+};\n+\n+\n struct abi_name\n {\n   const char *name;\n@@ -923,6 +962,44 @@ arm_init_libfuncs (void)\n   set_optab_libfunc (umod_optab, DImode, NULL);\n   set_optab_libfunc (smod_optab, SImode, NULL);\n   set_optab_libfunc (umod_optab, SImode, NULL);\n+\n+  /* Half-precision float operations.  The compiler handles all operations\n+     with NULL libfuncs by converting the SFmode.  */\n+  switch (arm_fp16_format)\n+    {\n+    case ARM_FP16_FORMAT_IEEE:\n+    case ARM_FP16_FORMAT_ALTERNATIVE:\n+\n+      /* Conversions.  */\n+      set_conv_libfunc (trunc_optab, HFmode, SFmode,\n+\t\t\t(arm_fp16_format == ARM_FP16_FORMAT_IEEE\n+\t\t\t ? \"__gnu_f2h_ieee\"\n+\t\t\t : \"__gnu_f2h_alternative\"));\n+      set_conv_libfunc (sext_optab, SFmode, HFmode, \n+\t\t\t(arm_fp16_format == ARM_FP16_FORMAT_IEEE\n+\t\t\t ? \"__gnu_h2f_ieee\"\n+\t\t\t : \"__gnu_h2f_alternative\"));\n+      \n+      /* Arithmetic.  */\n+      set_optab_libfunc (add_optab, HFmode, NULL);\n+      set_optab_libfunc (sdiv_optab, HFmode, NULL);\n+      set_optab_libfunc (smul_optab, HFmode, NULL);\n+      set_optab_libfunc (neg_optab, HFmode, NULL);\n+      set_optab_libfunc (sub_optab, HFmode, NULL);\n+\n+      /* Comparisons.  */\n+      set_optab_libfunc (eq_optab, HFmode, NULL);\n+      set_optab_libfunc (ne_optab, HFmode, NULL);\n+      set_optab_libfunc (lt_optab, HFmode, NULL);\n+      set_optab_libfunc (le_optab, HFmode, NULL);\n+      set_optab_libfunc (ge_optab, HFmode, NULL);\n+      set_optab_libfunc (gt_optab, HFmode, NULL);\n+      set_optab_libfunc (unord_optab, HFmode, NULL);\n+      break;\n+\n+    default:\n+      break;\n+    }\n }\n \n /* On AAPCS systems, this is the \"struct __va_list\".  */\n@@ -1294,6 +1371,23 @@ arm_override_options (void)\n \n   tune_flags = all_cores[(int)arm_tune].flags;\n \n+  if (target_fp16_format_name)\n+    {\n+      for (i = 0; i < ARRAY_SIZE (all_fp16_formats); i++)\n+\t{\n+\t  if (streq (all_fp16_formats[i].name, target_fp16_format_name))\n+\t    {\n+\t      arm_fp16_format = all_fp16_formats[i].fp16_format_type;\n+\t      break;\n+\t    }\n+\t}\n+      if (i == ARRAY_SIZE (all_fp16_formats))\n+\terror (\"invalid __fp16 format option: -mfp16-format=%s\",\n+\t       target_fp16_format_name);\n+    }\n+  else\n+    arm_fp16_format = ARM_FP16_FORMAT_NONE;\n+\n   if (target_abi_name)\n     {\n       for (i = 0; i < ARRAY_SIZE (arm_all_abis); i++)\n@@ -1525,6 +1619,10 @@ arm_override_options (void)\n   if (TARGET_THUMB2 && TARGET_IWMMXT)\n     sorry (\"Thumb-2 iWMMXt\");\n \n+  /* __fp16 support currently assumes the core has ldrh.  */\n+  if (!arm_arch4 && arm_fp16_format != ARM_FP16_FORMAT_NONE)\n+    sorry (\"__fp16 and no ldrh\");\n+\n   /* If soft-float is specified then don't use FPU.  */\n   if (TARGET_SOFT_FLOAT)\n     arm_fpu_arch = FPUTYPE_NONE;\n@@ -4173,6 +4271,7 @@ arm_legitimate_index_p (enum machine_mode mode, rtx index, RTX_CODE outer,\n   if (GET_MODE_SIZE (mode) <= 4\n       && ! (arm_arch4\n \t    && (mode == HImode\n+\t\t|| mode == HFmode\n \t\t|| (mode == QImode && outer == SIGN_EXTEND))))\n     {\n       if (code == MULT)\n@@ -4201,13 +4300,15 @@ arm_legitimate_index_p (enum machine_mode mode, rtx index, RTX_CODE outer,\n      load.  */\n   if (arm_arch4)\n     {\n-      if (mode == HImode || (outer == SIGN_EXTEND && mode == QImode))\n+      if (mode == HImode\n+\t  || mode == HFmode\n+\t  || (outer == SIGN_EXTEND && mode == QImode))\n \trange = 256;\n       else\n \trange = 4096;\n     }\n   else\n-    range = (mode == HImode) ? 4095 : 4096;\n+    range = (mode == HImode || mode == HFmode) ? 4095 : 4096;\n \n   return (code == CONST_INT\n \t  && INTVAL (index) < range\n@@ -4380,7 +4481,8 @@ thumb1_legitimate_address_p (enum machine_mode mode, rtx x, int strict_p)\n     return 1;\n \n   /* This is PC relative data after arm_reorg runs.  */\n-  else if (GET_MODE_SIZE (mode) >= 4 && reload_completed\n+  else if ((GET_MODE_SIZE (mode) >= 4 || mode == HFmode)\n+\t   && reload_completed\n \t   && (GET_CODE (x) == LABEL_REF\n \t       || (GET_CODE (x) == CONST\n \t\t   && GET_CODE (XEXP (x, 0)) == PLUS\n@@ -7121,6 +7223,13 @@ arm_eliminable_register (rtx x)\n enum reg_class\n coproc_secondary_reload_class (enum machine_mode mode, rtx x, bool wb)\n {\n+  if (mode == HFmode)\n+    {\n+      if (s_register_operand (x, mode) || neon_vector_mem_operand (x, 2))\n+\treturn NO_REGS;\n+      return GENERAL_REGS;\n+    }\n+\n   if (TARGET_NEON\n       && (GET_MODE_CLASS (mode) == MODE_VECTOR_INT\n           || GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT)\n@@ -13926,6 +14035,31 @@ arm_print_operand (FILE *stream, rtx x, int code)\n       }\n       return;\n \n+    /* Register specifier for vld1.16/vst1.16.  Translate the S register\n+       number into a D register number and element index.  */\n+    case 'z':\n+      {\n+        int mode = GET_MODE (x);\n+        int regno;\n+\n+        if (GET_MODE_SIZE (mode) != 2 || GET_CODE (x) != REG)\n+          {\n+\t    output_operand_lossage (\"invalid operand for code '%c'\", code);\n+\t    return;\n+          }\n+\n+        regno = REGNO (x);\n+        if (!VFP_REGNO_OK_FOR_SINGLE (regno))\n+          {\n+\t    output_operand_lossage (\"invalid operand for code '%c'\", code);\n+\t    return;\n+          }\n+\n+\tregno = regno - FIRST_VFP_REGNUM;\n+\tfprintf (stream, \"d%d[%d]\", regno/2, ((regno % 2) ? 2 : 0));\n+      }\n+      return;\n+      \n     default:\n       if (x == 0)\n \t{\n@@ -14723,6 +14857,12 @@ arm_hard_regno_mode_ok (unsigned int regno, enum machine_mode mode)\n       if (mode == DFmode)\n \treturn VFP_REGNO_OK_FOR_DOUBLE (regno);\n \n+      /* VFP registers can hold HFmode values, but there is no point in\n+\t putting them there unless we have the NEON extensions for\n+\t loading/storing them, too.  */\n+      if (mode == HFmode)\n+\treturn TARGET_NEON_FP16 && VFP_REGNO_OK_FOR_SINGLE (regno);\n+\n       if (TARGET_NEON)\n         return (VALID_NEON_DREG_MODE (mode) && VFP_REGNO_OK_FOR_DOUBLE (regno))\n                || (VALID_NEON_QREG_MODE (mode)\n@@ -16208,6 +16348,15 @@ arm_init_neon_builtins (void)\n     }\n }\n \n+static void\n+arm_init_fp16_builtins (void)\n+{\n+  tree fp16_type = make_node (REAL_TYPE);\n+  TYPE_PRECISION (fp16_type) = 16;\n+  layout_type (fp16_type);\n+  (*lang_hooks.types.register_builtin_type) (fp16_type, \"__fp16\");\n+}\n+\n static void\n arm_init_builtins (void)\n {\n@@ -16218,6 +16367,56 @@ arm_init_builtins (void)\n \n   if (TARGET_NEON)\n     arm_init_neon_builtins ();\n+\n+  if (arm_fp16_format)\n+    arm_init_fp16_builtins ();\n+}\n+\n+/* Implement TARGET_INVALID_PARAMETER_TYPE.  */\n+\n+static const char *\n+arm_invalid_parameter_type (const_tree t)\n+{\n+  if (SCALAR_FLOAT_TYPE_P (t) && TYPE_PRECISION (t) == 16)\n+    return N_(\"function parameters cannot have __fp16 type\");\n+  return NULL;\n+}\n+\n+/* Implement TARGET_INVALID_PARAMETER_TYPE.  */\n+\n+static const char *\n+arm_invalid_return_type (const_tree t)\n+{\n+  if (SCALAR_FLOAT_TYPE_P (t) && TYPE_PRECISION (t) == 16)\n+    return N_(\"functions cannot return __fp16 type\");\n+  return NULL;\n+}\n+\n+/* Implement TARGET_PROMOTED_TYPE.  */\n+\n+static tree\n+arm_promoted_type (const_tree t)\n+{\n+  if (SCALAR_FLOAT_TYPE_P (t) && TYPE_PRECISION (t) == 16)\n+    return float_type_node;\n+  return NULL_TREE;\n+}\n+\n+/* Implement TARGET_CONVERT_TO_TYPE.\n+   Specifically, this hook implements the peculiarity of the ARM\n+   half-precision floating-point C semantics that requires conversions between\n+   __fp16 to or from double to do an intermediate conversion to float.  */\n+\n+static tree\n+arm_convert_to_type (tree type, tree expr)\n+{\n+  tree fromtype = TREE_TYPE (expr);\n+  if (!SCALAR_FLOAT_TYPE_P (fromtype) || !SCALAR_FLOAT_TYPE_P (type))\n+    return NULL_TREE;\n+  if ((TYPE_PRECISION (fromtype) == 16 && TYPE_PRECISION (type) > 32)\n+      || (TYPE_PRECISION (type) == 16 && TYPE_PRECISION (fromtype) > 32))\n+    return convert (type, convert (float_type_node, expr));\n+  return NULL_TREE;\n }\n \n /* Errors in the source file can cause expand_expr to return const0_rtx\n@@ -18413,6 +18612,10 @@ arm_file_start (void)\n \t      fpu_name = \"neon\";\n \t      set_float_abi_attributes = 1;\n \t      break;\n+\t    case FPUTYPE_NEON_FP16:\n+\t      fpu_name = \"neon-fp16\";\n+\t      set_float_abi_attributes = 1;\n+\t      break;\n \t    default:\n \t      abort();\n \t    }\n@@ -18466,6 +18669,11 @@ arm_file_start (void)\n \tval = 6;\n       asm_fprintf (asm_out_file, \"\\t.eabi_attribute 30, %d\\n\", val);\n \n+      /* Tag_ABI_FP_16bit_format.  */\n+      if (arm_fp16_format)\n+\tasm_fprintf (asm_out_file, \"\\t.eabi_attribute 38, %d\\n\",\n+\t\t     (int)arm_fp16_format);\n+\n       if (arm_lang_output_object_attributes_hook)\n \tarm_lang_output_object_attributes_hook();\n     }\n@@ -18695,6 +18903,23 @@ arm_emit_vector_const (FILE *file, rtx x)\n   return 1;\n }\n \n+/* Emit a fp16 constant appropriately padded to occupy a 4-byte word.\n+   HFmode constant pool entries are actually loaded with ldr.  */\n+void\n+arm_emit_fp16_const (rtx c)\n+{\n+  REAL_VALUE_TYPE r;\n+  long bits;\n+\n+  REAL_VALUE_FROM_CONST_DOUBLE (r, c);\n+  bits = real_to_target (NULL, &r, HFmode);\n+  if (WORDS_BIG_ENDIAN)\n+    assemble_zeros (2);\n+  assemble_integer (GEN_INT (bits), 2, BITS_PER_WORD, 1);\n+  if (!WORDS_BIG_ENDIAN)\n+    assemble_zeros (2);\n+}\n+\n const char *\n arm_output_load_gr (rtx *operands)\n {\n@@ -19724,6 +19949,10 @@ arm_mangle_type (const_tree type)\n       return \"St9__va_list\";\n     }\n \n+  /* Half-precision float.  */\n+  if (TREE_CODE (type) == REAL_TYPE && TYPE_PRECISION (type) == 16)\n+    return \"Dh\";\n+\n   if (TREE_CODE (type) != VECTOR_TYPE)\n     return NULL;\n "}, {"sha": "2632a194fe791c15696824ece820f705605b1465", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fd8c3ad1ef97e592cb302d764b9e69f85cb7d6f/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fd8c3ad1ef97e592cb302d764b9e69f85cb7d6f/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=0fd8c3ad1ef97e592cb302d764b9e69f85cb7d6f", "patch": "@@ -215,20 +215,25 @@ extern void (*arm_lang_output_object_attributes_hook)(void);\n /* FPU is has the full VFPv3/NEON register file of 32 D registers.  */\n #define TARGET_VFPD32 (arm_fp_model == ARM_FP_MODEL_VFP \\\n \t\t       && (arm_fpu_arch == FPUTYPE_VFP3 \\\n-\t\t\t   || arm_fpu_arch == FPUTYPE_NEON))\n+\t\t\t   || arm_fpu_arch == FPUTYPE_NEON \\\n+\t\t\t   || arm_fpu_arch == FPUTYPE_NEON_FP16))\n \n /* FPU supports VFPv3 instructions.  */\n #define TARGET_VFP3 (arm_fp_model == ARM_FP_MODEL_VFP \\\n \t\t     && (arm_fpu_arch == FPUTYPE_VFP3D16 \\\n \t\t\t || TARGET_VFPD32))\n \n+/* FPU supports NEON/VFP half-precision floating-point.  */\n+#define TARGET_NEON_FP16 (arm_fpu_arch == FPUTYPE_NEON_FP16)\n+\n /* FPU supports Neon instructions.  The setting of this macro gets\n    revealed via __ARM_NEON__ so we add extra guards upon TARGET_32BIT\n    and TARGET_HARD_FLOAT to ensure that NEON instructions are\n    available.  */\n #define TARGET_NEON (TARGET_32BIT && TARGET_HARD_FLOAT \\\n \t\t     && arm_fp_model == ARM_FP_MODEL_VFP \\\n-\t\t     && arm_fpu_arch == FPUTYPE_NEON)\n+\t\t     && (arm_fpu_arch == FPUTYPE_NEON \\\n+\t\t\t || arm_fpu_arch == FPUTYPE_NEON_FP16))\n \n /* \"DSP\" multiply instructions, eg. SMULxy.  */\n #define TARGET_DSP_MULTIPLY \\\n@@ -308,7 +313,9 @@ enum fputype\n   /* VFPv3.  */\n   FPUTYPE_VFP3,\n   /* Neon.  */\n-  FPUTYPE_NEON\n+  FPUTYPE_NEON,\n+  /* Neon with half-precision float extensions.  */\n+  FPUTYPE_NEON_FP16\n };\n \n /* Recast the floating point class to be the floating point attribute.  */\n@@ -333,6 +340,21 @@ extern enum float_abi_type arm_float_abi;\n #define TARGET_DEFAULT_FLOAT_ABI ARM_FLOAT_ABI_SOFT\n #endif\n \n+/* Which __fp16 format to use.\n+   The enumeration values correspond to the numbering for the\n+   Tag_ABI_FP_16bit_format attribute.\n+ */\n+enum arm_fp16_format_type\n+{\n+  ARM_FP16_FORMAT_NONE = 0,\n+  ARM_FP16_FORMAT_IEEE = 1,\n+  ARM_FP16_FORMAT_ALTERNATIVE = 2\n+};\n+\n+extern enum arm_fp16_format_type arm_fp16_format;\n+#define LARGEST_EXPONENT_IS_NORMAL(bits) \\\n+    ((bits) == 16 && arm_fp16_format == ARM_FP16_FORMAT_ALTERNATIVE)\n+\n /* Which ABI to use.  */\n enum arm_abi_type\n {"}, {"sha": "fc2ce3c9c984ae1fc0eac6ad8170bd380a429b1d", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 199, "deletions": 10, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fd8c3ad1ef97e592cb302d764b9e69f85cb7d6f/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fd8c3ad1ef97e592cb302d764b9e69f85cb7d6f/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=0fd8c3ad1ef97e592cb302d764b9e69f85cb7d6f", "patch": "@@ -158,7 +158,7 @@\n ; Floating Point Unit.  If we only have floating point emulation, then there\n ; is no point in scheduling the floating point insns.  (Well, for best\n ; performance we should try and group them together).\n-(define_attr \"fpu\" \"none,fpa,fpe2,fpe3,maverick,vfp,vfpv3d16,vfpv3,neon\"\n+(define_attr \"fpu\" \"none,fpa,fpe2,fpe3,maverick,vfp,vfpv3d16,vfpv3,neon,neon_fp16\"\n   (const (symbol_ref \"arm_fpu_attr\")))\n \n ; LENGTH of an instruction (in bytes)\n@@ -3734,6 +3734,34 @@\n \f\n ;; Fixed <--> Floating conversion insns\n \n+(define_expand \"floatsihf2\"\n+  [(set (match_operand:HF           0 \"general_operand\" \"\")\n+\t(float:HF (match_operand:SI 1 \"general_operand\" \"\")))]\n+  \"TARGET_EITHER\"\n+  \"\n+  {\n+    rtx op1 = gen_reg_rtx (SFmode);\n+    expand_float (op1, operands[1], 0);\n+    op1 = convert_to_mode (HFmode, op1, 0);\n+    emit_move_insn (operands[0], op1);\n+    DONE;\n+  }\"\n+)\n+\n+(define_expand \"floatdihf2\"\n+  [(set (match_operand:HF           0 \"general_operand\" \"\")\n+\t(float:HF (match_operand:DI 1 \"general_operand\" \"\")))]\n+  \"TARGET_EITHER\"\n+  \"\n+  {\n+    rtx op1 = gen_reg_rtx (SFmode);\n+    expand_float (op1, operands[1], 0);\n+    op1 = convert_to_mode (HFmode, op1, 0);\n+    emit_move_insn (operands[0], op1);\n+    DONE;\n+  }\"\n+)\n+\n (define_expand \"floatsisf2\"\n   [(set (match_operand:SF           0 \"s_register_operand\" \"\")\n \t(float:SF (match_operand:SI 1 \"s_register_operand\" \"\")))]\n@@ -3758,6 +3786,30 @@\n     }\n \")\n \n+(define_expand \"fix_trunchfsi2\"\n+  [(set (match_operand:SI         0 \"general_operand\" \"\")\n+\t(fix:SI (fix:HF (match_operand:HF 1 \"general_operand\"  \"\"))))]\n+  \"TARGET_EITHER\"\n+  \"\n+  {\n+    rtx op1 = convert_to_mode (SFmode, operands[1], 0);\n+    expand_fix (operands[0], op1, 0);\n+    DONE;\n+  }\"\n+)\n+\n+(define_expand \"fix_trunchfdi2\"\n+  [(set (match_operand:DI         0 \"general_operand\" \"\")\n+\t(fix:DI (fix:HF (match_operand:HF 1 \"general_operand\"  \"\"))))]\n+  \"TARGET_EITHER\"\n+  \"\n+  {\n+    rtx op1 = convert_to_mode (SFmode, operands[1], 0);\n+    expand_fix (operands[0], op1, 0);\n+    DONE;\n+  }\"\n+)\n+\n (define_expand \"fix_truncsfsi2\"\n   [(set (match_operand:SI         0 \"s_register_operand\" \"\")\n \t(fix:SI (fix:SF (match_operand:SF 1 \"s_register_operand\"  \"\"))))]\n@@ -3797,6 +3849,22 @@\n   \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n   \"\"\n )\n+\n+/* DFmode -> HFmode conversions have to go through SFmode.  */\n+(define_expand \"truncdfhf2\"\n+  [(set (match_operand:HF  0 \"general_operand\" \"\")\n+\t(float_truncate:HF\n+ \t (match_operand:DF 1 \"general_operand\" \"\")))]\n+  \"TARGET_EITHER\"\n+  \"\n+  {\n+    rtx op1;\n+    op1 = convert_to_mode (SFmode, operands[1], 0);\n+    op1 = convert_to_mode (HFmode, op1, 0);\n+    emit_move_insn (operands[0], op1);\n+    DONE;\n+  }\"\n+)\n \f\n ;; Zero and sign extension instructions.\n \n@@ -4660,6 +4728,21 @@\n   \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n   \"\"\n )\n+\n+/* HFmode -> DFmode conversions have to go through SFmode.  */\n+(define_expand \"extendhfdf2\"\n+  [(set (match_operand:DF                  0 \"general_operand\" \"\")\n+\t(float_extend:DF (match_operand:HF 1 \"general_operand\"  \"\")))]\n+  \"TARGET_EITHER\"\n+  \"\n+  {\n+    rtx op1;\n+    op1 = convert_to_mode (SFmode, operands[1], 0);\n+    op1 = convert_to_mode (DFmode, op1, 0);\n+    emit_insn (gen_movdf (operands[0], op1));\n+    DONE;\n+  }\"\n+)\n \f\n ;; Move insns (including loads and stores)\n \n@@ -5808,6 +5891,107 @@\n    (set_attr \"pool_range\" \"*,32,*,*,*,*\")]\n )\n \n+;; HFmode moves\n+(define_expand \"movhf\"\n+  [(set (match_operand:HF 0 \"general_operand\" \"\")\n+\t(match_operand:HF 1 \"general_operand\" \"\"))]\n+  \"TARGET_EITHER\"\n+  \"\n+  if (TARGET_32BIT)\n+    {\n+      if (GET_CODE (operands[0]) == MEM)\n+        operands[1] = force_reg (HFmode, operands[1]);\n+    }\n+  else /* TARGET_THUMB1 */\n+    {\n+      if (can_create_pseudo_p ())\n+        {\n+           if (GET_CODE (operands[0]) != REG)\n+\t     operands[1] = force_reg (HFmode, operands[1]);\n+        }\n+    }\n+  \"\n+)\n+\n+(define_insn \"*arm32_movhf\"\n+  [(set (match_operand:HF 0 \"nonimmediate_operand\" \"=r,m,r,r\")\n+\t(match_operand:HF 1 \"general_operand\"\t   \" m,r,r,F\"))]\n+  \"TARGET_32BIT && !(TARGET_HARD_FLOAT && TARGET_NEON_FP16)\n+   && (\t  s_register_operand (operands[0], HFmode)\n+       || s_register_operand (operands[1], HFmode))\"\n+  \"*\n+  switch (which_alternative)\n+    {\n+    case 0:\t/* ARM register from memory */\n+      return \\\"ldr%(h%)\\\\t%0, %1\\\\t%@ __fp16\\\";\n+    case 1:\t/* memory from ARM register */\n+      return \\\"str%(h%)\\\\t%1, %0\\\\t%@ __fp16\\\";\n+    case 2:\t/* ARM register from ARM register */\n+      return \\\"mov%?\\\\t%0, %1\\\\t%@ __fp16\\\";\n+    case 3:\t/* ARM register from constant */\n+      {\n+\tREAL_VALUE_TYPE r;\n+\tlong bits;\n+\trtx ops[4];\n+\n+\tREAL_VALUE_FROM_CONST_DOUBLE (r, operands[1]);\n+\tbits = real_to_target (NULL, &r, HFmode);\n+\tops[0] = operands[0];\n+\tops[1] = GEN_INT (bits);\n+\tops[2] = GEN_INT (bits & 0xff00);\n+\tops[3] = GEN_INT (bits & 0x00ff);\n+\n+\tif (arm_arch_thumb2)\n+\t  output_asm_insn (\\\"movw%?\\\\t%0, %1\\\", ops);\n+\telse\n+\t  output_asm_insn (\\\"mov%?\\\\t%0, %2\\;orr%?\\\\t%0, %0, %3\\\", ops);\n+\treturn \\\"\\\";\n+       }\n+    default:\n+      gcc_unreachable ();\n+    }\n+  \"\n+  [(set_attr \"conds\" \"unconditional\")\n+   (set_attr \"type\" \"load1,store1,*,*\")\n+   (set_attr \"length\" \"4,4,4,8\")\n+   (set_attr \"predicable\" \"yes\")\n+   ]\n+)\n+\n+(define_insn \"*thumb1_movhf\"\n+  [(set (match_operand:HF     0 \"nonimmediate_operand\" \"=l,l,m,*r,*h\")\n+\t(match_operand:HF     1 \"general_operand\"      \"l,mF,l,*h,*r\"))]\n+  \"TARGET_THUMB1\n+   && (\t  s_register_operand (operands[0], HFmode) \n+       || s_register_operand (operands[1], HFmode))\"\n+  \"*\n+  switch (which_alternative)\n+    {\n+    case 1:\n+      {\n+\trtx addr;\n+\tgcc_assert (GET_CODE(operands[1]) == MEM);\n+\taddr = XEXP (operands[1], 0);\n+\tif (GET_CODE (addr) == LABEL_REF\n+\t    || (GET_CODE (addr) == CONST\n+\t\t&& GET_CODE (XEXP (addr, 0)) == PLUS\n+\t\t&& GET_CODE (XEXP (XEXP (addr, 0), 0)) == LABEL_REF\n+\t\t&& GET_CODE (XEXP (XEXP (addr, 0), 1)) == CONST_INT))\n+\t  {\n+\t    /* Constant pool entry.  */\n+\t    return \\\"ldr\\\\t%0, %1\\\";\n+\t  }\n+\treturn \\\"ldrh\\\\t%0, %1\\\";\n+      }\n+    case 2: return \\\"strh\\\\t%1, %0\\\";\n+    default: return \\\"mov\\\\t%0, %1\\\";\n+    }\n+  \"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"type\" \"*,load1,store1,*,*\")\n+   (set_attr \"pool_range\" \"*,1020,*,*,*\")]\n+)\n+\n (define_expand \"movsf\"\n   [(set (match_operand:SF 0 \"general_operand\" \"\")\n \t(match_operand:SF 1 \"general_operand\" \"\"))]\n@@ -10674,6 +10858,7 @@\n   \"TARGET_THUMB1\"\n   \"*\n   making_const_table = TRUE;\n+  gcc_assert (GET_MODE_CLASS (GET_MODE (operands[0])) != MODE_FLOAT);\n   assemble_integer (operands[0], 2, BITS_PER_WORD, 1);\n   assemble_zeros (2);\n   return \\\"\\\";\n@@ -10686,19 +10871,23 @@\n   \"TARGET_EITHER\"\n   \"*\n   {\n+    rtx x = operands[0];\n     making_const_table = TRUE;\n-    switch (GET_MODE_CLASS (GET_MODE (operands[0])))\n+    switch (GET_MODE_CLASS (GET_MODE (x)))\n       {\n       case MODE_FLOAT:\n-      {\n-        REAL_VALUE_TYPE r;\n-        REAL_VALUE_FROM_CONST_DOUBLE (r, operands[0]);\n-        assemble_real (r, GET_MODE (operands[0]), BITS_PER_WORD);\n-        break;\n-      }\n+ \tif (GET_MODE (x) == HFmode)\n+ \t  arm_emit_fp16_const (x);\n+ \telse\n+ \t  {\n+ \t    REAL_VALUE_TYPE r;\n+ \t    REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n+ \t    assemble_real (r, GET_MODE (x), BITS_PER_WORD);\n+ \t  }\n+ \tbreak;\n       default:\n-        assemble_integer (operands[0], 4, BITS_PER_WORD, 1);\n-\tmark_symbol_refs_as_used (operands[0]);\n+        assemble_integer (x, 4, BITS_PER_WORD, 1);\n+\tmark_symbol_refs_as_used (x);\n         break;\n       }\n     return \\\"\\\";"}, {"sha": "a39bb3a8d5c7133351aa24bccada113602ec4eb6", "filename": "gcc/config/arm/arm.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fd8c3ad1ef97e592cb302d764b9e69f85cb7d6f/gcc%2Fconfig%2Farm%2Farm.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fd8c3ad1ef97e592cb302d764b9e69f85cb7d6f/gcc%2Fconfig%2Farm%2Farm.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.opt?ref=0fd8c3ad1ef97e592cb302d764b9e69f85cb7d6f", "patch": "@@ -78,6 +78,10 @@ Specify if floating point hardware should be used\n mfp=\n Target RejectNegative Joined Undocumented Var(target_fpe_name)\n \n+mfp16-format=\n+Target RejectNegative Joined Var(target_fp16_format_name)\n+Specify the __fp16 floating-point format\n+\n ;; Now ignored.\n mfpe\n Target RejectNegative Mask(FPE) Undocumented"}, {"sha": "eb18864ecbf66a3a814b0ff0ba670f9042b1f9c4", "filename": "gcc/config/arm/vfp.md", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fd8c3ad1ef97e592cb302d764b9e69f85cb7d6f/gcc%2Fconfig%2Farm%2Fvfp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fd8c3ad1ef97e592cb302d764b9e69f85cb7d6f/gcc%2Fconfig%2Farm%2Fvfp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvfp.md?ref=0fd8c3ad1ef97e592cb302d764b9e69f85cb7d6f", "patch": "@@ -185,6 +185,61 @@\n    (set_attr \"neg_pool_range\" \"*,   0,*,*,*,*,1008,*\")]\n )\n \n+;; HFmode moves\n+(define_insn \"*movhf_vfp\"\n+  [(set (match_operand:HF 0 \"nonimmediate_operand\" \"= t,Um,r,m,t,r,t,r,r\")\n+\t(match_operand:HF 1 \"general_operand\"\t   \" Um, t,m,r,t,r,r,t,F\"))]\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_NEON_FP16\n+   && (   s_register_operand (operands[0], HFmode)\n+       || s_register_operand (operands[1], HFmode))\"\n+  \"*\n+  switch (which_alternative)\n+    {\n+    case 0:     /* S register from memory */\n+      return \\\"vld1.16\\\\t{%z0}, %A1\\\";\n+    case 1:     /* memory from S register */\n+      return \\\"vst1.16\\\\t{%z1}, %A0\\\";\n+    case 2:     /* ARM register from memory */\n+      return \\\"ldrh\\\\t%0, %1\\\\t%@ __fp16\\\";\n+    case 3:     /* memory from ARM register */\n+      return \\\"strh\\\\t%1, %0\\\\t%@ __fp16\\\";\n+    case 4:\t/* S register from S register */\n+      return \\\"fcpys\\\\t%0, %1\\\";\n+    case 5:\t/* ARM register from ARM register */\n+      return \\\"mov\\\\t%0, %1\\\\t%@ __fp16\\\";\n+    case 6:\t/* S register from ARM register */\n+      return \\\"fmsr\\\\t%0, %1\\\";\n+    case 7:\t/* ARM register from S register */\n+      return \\\"fmrs\\\\t%0, %1\\\";\n+    case 8:\t/* ARM register from constant */\n+      {\n+        REAL_VALUE_TYPE r;\n+\tlong bits;\n+\trtx ops[4];\n+\n+        REAL_VALUE_FROM_CONST_DOUBLE (r, operands[1]);\n+\tbits = real_to_target (NULL, &r, HFmode);\n+\tops[0] = operands[0];\n+\tops[1] = GEN_INT (bits);\n+\tops[2] = GEN_INT (bits & 0xff00);\n+\tops[3] = GEN_INT (bits & 0x00ff);\n+\n+\tif (arm_arch_thumb2)\n+\t  output_asm_insn (\\\"movw\\\\t%0, %1\\\", ops);\n+\telse\n+\t  output_asm_insn (\\\"mov\\\\t%0, %2\\;orr\\\\t%0, %0, %3\\\", ops);\n+\treturn \\\"\\\";\n+       }\n+    default:\n+      gcc_unreachable ();\n+    }\n+  \"\n+  [(set_attr \"conds\" \"unconditional\")\n+   (set_attr \"type\" \"*,*,load1,store1,fcpys,*,r_2_f,f_2_r,*\")\n+   (set_attr \"neon_type\" \"neon_vld1_1_2_regs,neon_vst1_1_2_regs_vst2_2_regs,*,*,*,*,*,*,*\")\n+   (set_attr \"length\" \"4,4,4,4,4,4,4,4,8\")]\n+)\n+\n \n ;; SFmode moves\n ;; Disparage the w<->r cases because reloading an invalid address is\n@@ -736,6 +791,24 @@\n    (set_attr \"type\" \"f_cvt\")]\n )\n \n+(define_insn \"extendhfsf2\"\n+  [(set (match_operand:SF\t\t   0 \"s_register_operand\" \"=t\")\n+\t(float_extend:SF (match_operand:HF 1 \"s_register_operand\" \"t\")))]\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_NEON_FP16\"\n+  \"vcvtb%?.f32.f16\\\\t%0, %1\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"f_cvt\")]\n+)\n+\n+(define_insn \"truncsfhf2\"\n+  [(set (match_operand:HF\t\t   0 \"s_register_operand\" \"=t\")\n+\t(float_truncate:HF (match_operand:SF 1 \"s_register_operand\" \"t\")))]\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_NEON_FP16\"\n+  \"vcvtb%?.f16.f32\\\\t%0, %1\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"f_cvt\")]\n+)\n+\n (define_insn \"*truncsisf2_vfp\"\n   [(set (match_operand:SI\t\t  0 \"s_register_operand\" \"=t\")\n \t(fix:SI (fix:SF (match_operand:SF 1 \"s_register_operand\" \"t\"))))]"}, {"sha": "1cf6e760b4cc0ba84310291d0cebbc273679c91a", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fd8c3ad1ef97e592cb302d764b9e69f85cb7d6f/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fd8c3ad1ef97e592cb302d764b9e69f85cb7d6f/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=0fd8c3ad1ef97e592cb302d764b9e69f85cb7d6f", "patch": "@@ -35,6 +35,7 @@ extensions, accepted by GCC in C89 mode and in C++.\n * Long Long::           Double-word integers---@code{long long int}.\n * Complex::             Data types for complex numbers.\n * Floating Types::      Additional Floating Types.\n+* Half-Precision::      Half-Precision Floating Point.\n * Decimal Float::       Decimal Floating Types. \n * Hex Floats::          Hexadecimal floating-point constants.\n * Fixed-Point::         Fixed-Point Types.\n@@ -921,6 +922,55 @@ Not all targets support additional floating point types.  @code{__float80}\n is supported on i386, x86_64 and ia64 targets and target @code{__float128}\n is supported on x86_64 and ia64 targets.\n \n+@node Half-Precision\n+@section Half-Precision Floating Point\n+@cindex half-precision floating point\n+@cindex @code{__fp16} data type\n+\n+On ARM targets, GCC supports half-precision (16-bit) floating point via\n+the @code{__fp16} type.  You must enable this type explicitly \n+with the @option{-mfp16-format} command-line option in order to use it.\n+\n+ARM supports two incompatible representations for half-precision\n+floating-point values.  You must choose one of the representations and\n+use it consistently in your program.\n+\n+Specifying @option{-mfp16-format=ieee} selects the IEEE 754-2008 format.\n+This format can represent normalized values in the range of @math{2^{-14}} to 65504.\n+There are 11 bits of significand precision, approximately 3\n+decimal digits.\n+\n+Specifying @option{-mfp16-format=alternative} selects the ARM\n+alternative format.  This representation is similar to the IEEE\n+format, but does not support infinities or NaNs.  Instead, the range\n+of exponents is extended, so that this format can represent normalized\n+values in the range of @math{2^{-14}} to 131008.\n+\n+The @code{__fp16} type is a storage format only.  For purposes\n+of arithmetic and other operations, @code{__fp16} values in C or C++\n+expressions are automatically promoted to @code{float}.  In addition,\n+you cannot declare a function with a return value or parameters \n+of type @code{__fp16}.\n+\n+Note that conversions from @code{double} to @code{__fp16}\n+involve an intermediate conversion to @code{float}.  Because\n+of rounding, this can sometimes produce a different result than a\n+direct conversion.\n+\n+ARM provides hardware support for conversions between \n+@code{__fp16} and @code{float} values\n+as an extension to VFP and NEON (Advanced SIMD).  GCC generates\n+code using the instructions provided by this extension if you compile\n+with the options @option{-mfpu=neon-fp16 -mfloat-abi=softfp},\n+in addition to the @option{-mfp16-format} option to select\n+a half-precision format.  \n+\n+Language-level support for the @code{__fp16} data type is\n+independent of whether GCC generates code using hardware floating-point\n+instructions.  In cases where hardware support is not specified, GCC\n+implements conversions between @code{__fp16} and @code{float} values\n+as library calls.\n+\n @node Decimal Float\n @section Decimal Floating Types\n @cindex decimal floating types"}, {"sha": "2324960492fcc1ac29b8edb0f442e4f15dc16d47", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fd8c3ad1ef97e592cb302d764b9e69f85cb7d6f/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fd8c3ad1ef97e592cb302d764b9e69f85cb7d6f/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=0fd8c3ad1ef97e592cb302d764b9e69f85cb7d6f", "patch": "@@ -443,6 +443,7 @@ Objective-C and Objective-C++ Dialects}.\n -msched-prolog  -mno-sched-prolog @gol\n -mlittle-endian  -mbig-endian  -mwords-little-endian @gol\n -mfloat-abi=@var{name}  -msoft-float  -mhard-float  -mfpe @gol\n+-mfp16-format=@var{name}\n -mthumb-interwork  -mno-thumb-interwork @gol\n -mcpu=@var{name}  -march=@var{name}  -mfpu=@var{name}  @gol\n -mstructure-size-boundary=@var{n} @gol\n@@ -9301,14 +9302,21 @@ of the @option{-mcpu=} option.  Permissible names are: @samp{armv2},\n @opindex mfp\n This specifies what floating point hardware (or hardware emulation) is\n available on the target.  Permissible names are: @samp{fpa}, @samp{fpe2},\n-@samp{fpe3}, @samp{maverick}, @samp{vfp}, @samp{vfpv3}, @samp{vfpv3-d16} and\n-@samp{neon}.  @option{-mfp} and @option{-mfpe}\n+@samp{fpe3}, @samp{maverick}, @samp{vfp}, @samp{vfpv3}, @samp{vfpv3-d16},\n+@samp{neon}, and @samp{neon-fp16}.  @option{-mfp} and @option{-mfpe}\n are synonyms for @option{-mfpu}=@samp{fpe}@var{number}, for compatibility\n with older versions of GCC@.\n \n If @option{-msoft-float} is specified this specifies the format of\n floating point values.\n \n+@item -mfp16-format=@var{name}\n+@opindex mfp16-format\n+Specify the format of the @code{__fp16} half-precision floating-point type.\n+Permissible names are @samp{none}, @samp{ieee}, and @samp{alternative}; \n+the default is @samp{none}, in which case the @code{__fp16} type is not \n+defined.  @xref{Half-Precision}, for more information.\n+\n @item -mstructure-size-boundary=@var{n}\n @opindex mstructure-size-boundary\n The size of all structures and unions will be rounded up to a multiple"}]}