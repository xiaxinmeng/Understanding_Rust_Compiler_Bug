{"sha": "a16ad7794695d54a794e023556cebd61e20bd4c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTE2YWQ3Nzk0Njk1ZDU0YTc5NGUwMjM1NTZjZWJkNjFlMjBiZDRjMg==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2001-05-25T04:24:12Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2001-05-25T04:24:12Z"}, "message": "inserters_extractors.cc (test09): New test.\n\n\n2001-05-24  Benjamin Kosnik  <bkoz@redhat.com>\n\n\tlibstdc++/2830\n\t* testsuite/21_strings/inserters_extractors.cc (test09): New test.\n\t* include/bits/ostream.tcc: Format to match istream.tcc.\n\t(operator<<(basic_ostream __out, const basic_string __s)): Fix.\n\nFrom-SVN: r42557", "tree": {"sha": "1908c41ea69bafbe088403f9d2a4a7c6f7341e92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1908c41ea69bafbe088403f9d2a4a7c6f7341e92"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a16ad7794695d54a794e023556cebd61e20bd4c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a16ad7794695d54a794e023556cebd61e20bd4c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a16ad7794695d54a794e023556cebd61e20bd4c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a16ad7794695d54a794e023556cebd61e20bd4c2/comments", "author": null, "committer": null, "parents": [{"sha": "1044b043c229a4fbc17be667a16900f32c12710d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1044b043c229a4fbc17be667a16900f32c12710d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1044b043c229a4fbc17be667a16900f32c12710d"}], "stats": {"total": 551, "additions": 315, "deletions": 236}, "files": [{"sha": "44999eb6b4241c80629470f85cb9318632f0bada", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a16ad7794695d54a794e023556cebd61e20bd4c2/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a16ad7794695d54a794e023556cebd61e20bd4c2/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=a16ad7794695d54a794e023556cebd61e20bd4c2", "patch": "@@ -1,3 +1,10 @@\n+2001-05-24  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\tlibstdc++/2830\n+\t* testsuite/21_strings/inserters_extractors.cc (test09): New test.\n+\t* include/bits/ostream.tcc: Format to match istream.tcc.\n+\t(operator<<(basic_ostream __out, const basic_string __s)): Fix.\n+\t\n 2001-05-24  Phil Edwards  <pme@sources.redhat.com>\n \n \t* libsupc++/eh_alloc.cc (__cxa_allocate_exception):  Qualify"}, {"sha": "1c4c521d06008f77ee9e94174248195fea5a6933", "filename": "libstdc++-v3/include/bits/ostream.tcc", "status": "modified", "additions": 286, "deletions": 236, "changes": 522, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a16ad7794695d54a794e023556cebd61e20bd4c2/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fostream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a16ad7794695d54a794e023556cebd61e20bd4c2/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fostream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fostream.tcc?ref=a16ad7794695d54a794e023556cebd61e20bd4c2", "patch": "@@ -31,8 +31,8 @@\n \n #include <bits/std_locale.h>\n \n-namespace std {\n-\n+namespace std \n+{\n   template<typename _CharT, typename _Traits>\n     basic_ostream<_CharT, _Traits>::sentry::\n     sentry(basic_ostream<_CharT,_Traits>& __os)\n@@ -51,16 +51,16 @@ namespace std {\n       sentry __cerb(*this);\n       if (__cerb)\n \t{ \n-\t  try {\n-\t      __pf(*this);\n-\t  }\n-\t  catch(exception& __fail){\n-\t    // 27.6.2.5.1 Common requirements.\n-\t    // Turn this on without causing an ios::failure to be thrown.\n-\t    this->setstate(ios_base::badbit);\n-\t    if ((this->exceptions() & ios_base::badbit) != 0)\n-\t      __throw_exception_again;\n-\t  }\n+\t  try \n+\t    { __pf(*this); }\n+\t  catch(exception& __fail)\n+\t    {\n+\t      // 27.6.2.5.1 Common requirements.\n+\t      // Turn this on without causing an ios::failure to be thrown.\n+\t      this->setstate(ios_base::badbit);\n+\t      if ((this->exceptions() & ios_base::badbit) != 0)\n+\t\t__throw_exception_again;\n+\t    }\n \t}\n       return *this;\n     }\n@@ -73,16 +73,16 @@ namespace std {\n       sentry __cerb(*this);\n       if (__cerb)\n \t{ \n-\t  try {\n-\t      __pf(*this);\n-\t  }\n-\t  catch(exception& __fail){\n-\t    // 27.6.2.5.1 Common requirements.\n-\t    // Turn this on without causing an ios::failure to be thrown.\n-\t    this->setstate(ios_base::badbit);\n-\t    if ((this->exceptions() & ios_base::badbit) != 0)\n-\t      __throw_exception_again;\n-\t  }\n+\t  try \n+\t    { __pf(*this); }\n+\t  catch(exception& __fail)\n+\t    {\n+\t      // 27.6.2.5.1 Common requirements.\n+\t      // Turn this on without causing an ios::failure to be thrown.\n+\t      this->setstate(ios_base::badbit);\n+\t      if ((this->exceptions() & ios_base::badbit) != 0)\n+\t\t__throw_exception_again;\n+\t    }\n \t}\n       return *this;\n     }\n@@ -95,16 +95,16 @@ namespace std {\n       sentry __cerb(*this);\n       if (__cerb)\n \t{ \n-\t  try {\n-\t      __pf(*this);\n-\t  }\n-\t  catch(exception& __fail){\n-\t    // 27.6.2.5.1 Common requirements.\n-\t    // Turn this on without causing an ios::failure to be thrown.\n-\t    this->setstate(ios_base::badbit);\n-\t    if ((this->exceptions() & ios_base::badbit) != 0)\n-\t      __throw_exception_again;\n-\t  }\n+\t  try \n+\t    { __pf(*this); }\n+\t  catch(exception& __fail)\n+\t    {\n+\t      // 27.6.2.5.1 Common requirements.\n+\t      // Turn this on without causing an ios::failure to be thrown.\n+\t      this->setstate(ios_base::badbit);\n+\t      if ((this->exceptions() & ios_base::badbit) != 0)\n+\t\t__throw_exception_again;\n+\t    }\n \t}\n       return *this;\n     }\n@@ -116,17 +116,19 @@ namespace std {\n       sentry __cerb(*this);\n       if (__cerb) \n \t{\n-\t  try {\n-\t    if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())\n+\t  try \n+\t    {\n+\t      if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())\n+\t\tthis->setstate(ios_base::badbit);\n+\t    }\n+\t  catch(exception& __fail)\n+\t    {\n+\t      // 27.6.1.2.1 Common requirements.\n+\t      // Turn this on without causing an ios::failure to be thrown.\n \t      this->setstate(ios_base::badbit);\n-\t  }\n-\t  catch(exception& __fail){\n-\t    // 27.6.1.2.1 Common requirements.\n-\t    // Turn this on without causing an ios::failure to be thrown.\n-\t    this->setstate(ios_base::badbit);\n-\t    if ((this->exceptions() & ios_base::badbit) != 0)\n-\t      __throw_exception_again;\n-\t  }\n+\t      if ((this->exceptions() & ios_base::badbit) != 0)\n+\t\t__throw_exception_again;\n+\t    }\n \t}\n       return *this;\n     }\n@@ -138,25 +140,27 @@ namespace std {\n       sentry __cerb(*this);\n       if (__cerb) \n \t{\n-\t  try {\n-\t    bool __f;\n-\t    ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;\n-\t    if (__fmt & ios_base::oct || __fmt & ios_base::hex)\n-\t      __f = _M_fnumput->put(*this, *this, this->fill(), \n-\t\t\t\t    static_cast<unsigned long>(__n)).failed();\n-\t    else\n-\t      __f = _M_fnumput->put(*this, *this, this->fill(), __n).failed();\n-\n-\t    if (__f)  \n+\t  try \n+\t    {\n+\t      bool __f;\n+\t      ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;\n+\t      if (__fmt & ios_base::oct || __fmt & ios_base::hex)\n+\t\t__f = _M_fnumput->put(*this, *this, this->fill(), \n+\t\t\t\t     static_cast<unsigned long>(__n)).failed();\n+\t      else\n+\t\t__f = _M_fnumput->put(*this, *this, this->fill(), __n).failed();\n+\n+\t      if (__f)  \n+\t\tthis->setstate(ios_base::badbit);\n+\t    }\n+\t  catch(exception& __fail)\n+\t    {\n+\t      // 27.6.1.2.1 Common requirements.\n+\t      // Turn this on without causing an ios::failure to be thrown.\n \t      this->setstate(ios_base::badbit);\n-\t  }\n-\t  catch(exception& __fail){\n-\t    // 27.6.1.2.1 Common requirements.\n-\t    // Turn this on without causing an ios::failure to be thrown.\n-\t    this->setstate(ios_base::badbit);\n-\t    if ((this->exceptions() & ios_base::badbit) != 0)\n-\t      __throw_exception_again;\n-\t  }\n+\t      if ((this->exceptions() & ios_base::badbit) != 0)\n+\t\t__throw_exception_again;\n+\t    }\n \t}\n       return *this;\n     }\n@@ -168,17 +172,19 @@ namespace std {\n       sentry __cerb(*this);\n       if (__cerb) \n \t{\n-\t  try {\n-\t    if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())\n+\t  try \n+\t    {\n+\t      if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())\n+\t\tthis->setstate(ios_base::badbit);\n+\t    }\n+\t  catch(exception& __fail)\n+\t    {\n+\t      // 27.6.1.2.1 Common requirements.\n+\t      // Turn this on without causing an ios::failure to be thrown.\n \t      this->setstate(ios_base::badbit);\n-\t  }\n-\t  catch(exception& __fail){\n-\t    // 27.6.1.2.1 Common requirements.\n-\t    // Turn this on without causing an ios::failure to be thrown.\n-\t    this->setstate(ios_base::badbit);\n-\t    if ((this->exceptions() & ios_base::badbit) != 0)\n-\t      __throw_exception_again;\n-\t  }\n+\t      if ((this->exceptions() & ios_base::badbit) != 0)\n+\t\t__throw_exception_again;\n+\t    }\n \t}\n       return *this;\n     }\n@@ -191,23 +197,26 @@ namespace std {\n       sentry __cerb(*this);\n       if (__cerb) \n \t{\n-\t  try {\n-\t    bool __f;\n-\t    ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;\n-\t    if (__fmt & ios_base::oct || __fmt & ios_base::hex)\n-\t      __f = _M_fnumput->put(*this, *this, this->fill(), \n-\t\t\t       static_cast<unsigned long long>(__n)).failed();\n-\t    else\n-\t      __f = _M_fnumput->put(*this, *this, this->fill(), __n).failed();\n-\n-\t  }\n-\t  catch(exception& __fail){\n-\t    // 27.6.1.2.1 Common requirements.\n-\t    // Turn this on without causing an ios::failure to be thrown.\n-\t    this->setstate(ios_base::badbit);\n-\t    if ((this->exceptions() & ios_base::badbit) != 0)\n-\t      __throw_exception_again;\n-\t  }\n+\t  try \n+\t    {\n+\t      bool __f;\n+\t      ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;\n+\t      if (__fmt & ios_base::oct || __fmt & ios_base::hex)\n+\t\t__f = _M_fnumput->put(*this, *this, this->fill(), \n+\t\t\t\tstatic_cast<unsigned long long>(__n)).failed();\n+\t      else\n+\t\t__f = _M_fnumput->put(*this, *this, this->fill(), __n).failed();\n+\t      if (__f)  \n+\t\tthis->setstate(ios_base::badbit);\n+\t    }\n+\t  catch(exception& __fail)\n+\t    {\n+\t      // 27.6.1.2.1 Common requirements.\n+\t      // Turn this on without causing an ios::failure to be thrown.\n+\t      this->setstate(ios_base::badbit);\n+\t      if ((this->exceptions() & ios_base::badbit) != 0)\n+\t\t__throw_exception_again;\n+\t    }\n \t}\n       return *this;\n     }\n@@ -219,62 +228,68 @@ namespace std {\n       sentry __cerb(*this);\n       if (__cerb) \n \t{\n-\t  try {\n-\t    if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())\n+\t  try \n+\t    {\n+\t      if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())\n+\t\tthis->setstate(ios_base::badbit);\n+\t    }\n+\t  catch(exception& __fail)\n+\t    {\n+\t      // 27.6.1.2.1 Common requirements.\n+\t      // Turn this on without causing an ios::failure to be thrown.\n \t      this->setstate(ios_base::badbit);\n-\t  }\n-\t  catch(exception& __fail){\n-\t    // 27.6.1.2.1 Common requirements.\n-\t    // Turn this on without causing an ios::failure to be thrown.\n-\t    this->setstate(ios_base::badbit);\n-\t    if ((this->exceptions() & ios_base::badbit) != 0)\n-\t      __throw_exception_again;\n-\t  }\n+\t      if ((this->exceptions() & ios_base::badbit) != 0)\n+\t\t__throw_exception_again;\n+\t    }\n \t}\n       return *this;\n     }\n #endif\n-\n+  \n   template<typename _CharT, typename _Traits>\n     basic_ostream<_CharT, _Traits>& \n     basic_ostream<_CharT, _Traits>::operator<<(double __n)\n     {\n       sentry __cerb(*this);\n       if (__cerb) \n \t{\n-\t  try {\n-\t    if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())\n+\t  try \n+\t    {\n+\t      if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())\n+\t\tthis->setstate(ios_base::badbit);\n+\t    }\n+\t  catch(exception& __fail)\n+\t    {\n+\t      // 27.6.1.2.1 Common requirements.\n+\t      // Turn this on without causing an ios::failure to be thrown.\n \t      this->setstate(ios_base::badbit);\n-\t  }\n-\t  catch(exception& __fail){\n-\t    // 27.6.1.2.1 Common requirements.\n-\t    // Turn this on without causing an ios::failure to be thrown.\n-\t    this->setstate(ios_base::badbit);\n-\t    if ((this->exceptions() & ios_base::badbit) != 0)\n-\t      __throw_exception_again;\n-\t  }\n+\t      if ((this->exceptions() & ios_base::badbit) != 0)\n+\t\t__throw_exception_again;\n+\t    }\n \t}\n       return *this;\n     }\n-\n+  \n   template<typename _CharT, typename _Traits>\n     basic_ostream<_CharT, _Traits>& \n     basic_ostream<_CharT, _Traits>::operator<<(long double __n)\n     {\n       sentry __cerb(*this);\n       if (__cerb) \n \t{\n-\t  try {\n-\t    if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())\n+\t  try \n+\t    {\n+\t      if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())\n+\t\tthis->setstate(ios_base::badbit);\n+\t    }\n+\t  catch(exception& __fail)\n+\t    {\n+\t      // 27.6.1.2.1 Common requirements.\n+\t      // Turn this on without causing an ios::failure to be thrown.\n \t      this->setstate(ios_base::badbit);\n-\t  }\n-\t  catch(exception& __fail){\n-\t    // 27.6.1.2.1 Common requirements.\n-\t    // Turn this on without causing an ios::failure to be thrown.\n-\t    this->setstate(ios_base::badbit);\n-\t    if ((this->exceptions() & ios_base::badbit) != 0)\n-\t      __throw_exception_again;\n-\t  }\n+\t      if ((this->exceptions() & ios_base::badbit) != 0)\n+\t\t__throw_exception_again;\n+\t    }\n \t}\n       return *this;\n     }\n@@ -286,17 +301,19 @@ namespace std {\n       sentry __cerb(*this);\n       if (__cerb) \n \t{\n-\t  try {\n-\t    if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())\n+\t  try \n+\t    {\n+\t      if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())\n+\t\tthis->setstate(ios_base::badbit);\n+\t    }\n+\t  catch(exception& __fail)\n+\t    {\n+\t      // 27.6.1.2.1 Common requirements.\n+\t      // Turn this on without causing an ios::failure to be thrown.\n \t      this->setstate(ios_base::badbit);\n-\t  }\n-\t  catch(exception& __fail){\n-\t    // 27.6.1.2.1 Common requirements.\n-\t    // Turn this on without causing an ios::failure to be thrown.\n-\t    this->setstate(ios_base::badbit);\n-\t    if ((this->exceptions() & ios_base::badbit) != 0)\n-\t      __throw_exception_again;\n-\t  }\n+\t      if ((this->exceptions() & ios_base::badbit) != 0)\n+\t\t__throw_exception_again;\n+\t    }\n \t}\n       return *this;\n     }\n@@ -393,7 +410,7 @@ namespace std {\n       if (__testok)\n #ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n // 136.  seekp, seekg setting wrong streams?\n-\trdbuf()->pubseekoff(__off, __d, ios_base::out);\n+\tthis->rdbuf()->pubseekoff(__off, __d, ios_base::out);\n #endif\n       return *this;\n     }\n@@ -494,30 +511,32 @@ namespace std {\n       typename __ostream_type::sentry __cerb(__out);\n       if (__cerb)\n \t{\n-\t  try {\n-\t    streamsize __w = __out.width();\n-\t    _CharT* __pads = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __w));\n-\t    __pads[0] = __c;\n-\t    streamsize __len = 1;\n-\t    if (__w > __len)\n-\t      {\n-\t\t__pad_char(__out, __pads, &__c, __w, __len);\n-\t\t__len = __w;\n-\t      }\n-\t    __out.write(__pads, __len);\n-\t    __out.width(0);\n-\t  }\n-\t  catch(exception& __fail){\n-\t    // 27.6.1.2.1 Common requirements.\n-\t    // Turn this on without causing an ios::failure to be thrown.\n-\t    __out.setstate(ios_base::badbit);\n-\t    if ((__out.exceptions() & ios_base::badbit) != 0)\n-\t      __throw_exception_again;\n-\t  }\n+\t  try \n+\t    {\n+\t      streamsize __w = __out.width();\n+\t      _CharT* __pads = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __w));\n+\t      __pads[0] = __c;\n+\t      streamsize __len = 1;\n+\t      if (__w > __len)\n+\t\t{\n+\t\t  __pad_char(__out, __pads, &__c, __w, __len);\n+\t\t  __len = __w;\n+\t\t}\n+\t      __out.write(__pads, __len);\n+\t      __out.width(0);\n+\t    }\n+\t  catch(exception& __fail)\n+\t    {\n+\t      // 27.6.1.2.1 Common requirements.\n+\t      // Turn this on without causing an ios::failure to be thrown.\n+\t      __out.setstate(ios_base::badbit);\n+\t      if ((__out.exceptions() & ios_base::badbit) != 0)\n+\t\t__throw_exception_again;\n+\t    }\n \t}\n       return __out;\n     }\n-\n+  \n   // Specialization\n   template <class _Traits> \n     basic_ostream<char, _Traits>&\n@@ -527,26 +546,28 @@ namespace std {\n       typename __ostream_type::sentry __cerb(__out);\n       if (__cerb)\n \t{\n-\t  try {\n-\t    streamsize __w = __out.width();\n-\t    char* __pads = static_cast<char*>(__builtin_alloca(__w + 1));\n-\t    __pads[0] = __c;\n-\t    streamsize __len = 1;\n-\t    if (__w > __len)\n-\t      {\n-\t\t__pad_char(__out, __pads, &__c, __w, __len);\n-\t\t__len = __w;\n-\t      }\n-\t    __out.write(__pads, __len);\n-\t    __out.width(0);\n-\t  }\n-\t  catch(exception& __fail){\n-\t    // 27.6.1.2.1 Common requirements.\n-\t    // Turn this on without causing an ios::failure to be thrown.\n-\t    __out.setstate(ios_base::badbit);\n-\t    if ((__out.exceptions() & ios_base::badbit) != 0)\n-\t      __throw_exception_again;\n-\t  }\n+\t  try \n+\t    {\n+\t      streamsize __w = __out.width();\n+\t      char* __pads = static_cast<char*>(__builtin_alloca(__w + 1));\n+\t      __pads[0] = __c;\n+\t      streamsize __len = 1;\n+\t      if (__w > __len)\n+\t\t{\n+\t\t  __pad_char(__out, __pads, &__c, __w, __len);\n+\t\t  __len = __w;\n+\t\t}\n+\t      __out.write(__pads, __len);\n+\t      __out.width(0);\n+\t    }\n+\t  catch(exception& __fail)\n+\t    {\n+\t      // 27.6.1.2.1 Common requirements.\n+\t      // Turn this on without causing an ios::failure to be thrown.\n+\t      __out.setstate(ios_base::badbit);\n+\t      if ((__out.exceptions() & ios_base::badbit) != 0)\n+\t\t__throw_exception_again;\n+\t    }\n \t}\n       return __out;\n      }\n@@ -559,26 +580,28 @@ namespace std {\n       typename __ostream_type::sentry __cerb(__out);\n       if (__cerb)\n \t{\n-\t  try {\n-\t    streamsize __w = __out.width();\n-\t    _CharT* __pads = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __w));\n-\t    streamsize __len = static_cast<streamsize>(_Traits::length(__s));\n-\t    if (__w > __len)\n-\t      {\n-\t\t__pad_char(__out, __pads, __s, __w, __len);\n-\t\t__s = __pads;\n-\t\t__len = __w;\n-\t      }\n-\t    __out.write(__s, __len);\n-\t    __out.width(0);\n-\t  }\n-\t  catch(exception& __fail){\n-\t    // 27.6.1.2.1 Common requirements.\n-\t    // Turn this on without causing an ios::failure to be thrown.\n-\t    __out.setstate(ios_base::badbit);\n-\t    if ((__out.exceptions() & ios_base::badbit) != 0)\n-\t      __throw_exception_again;\n-\t  }\n+\t  try \n+\t    {\n+\t      streamsize __w = __out.width();\n+\t      _CharT* __pads = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __w));\n+\t      streamsize __len = static_cast<streamsize>(_Traits::length(__s));\n+\t      if (__w > __len)\n+\t\t{\n+\t\t  __pad_char(__out, __pads, __s, __w, __len);\n+\t\t  __s = __pads;\n+\t\t  __len = __w;\n+\t\t}\n+\t      __out.write(__s, __len);\n+\t      __out.width(0);\n+\t    }\n+\t  catch(exception& __fail)\n+\t    {\n+\t      // 27.6.1.2.1 Common requirements.\n+\t      // Turn this on without causing an ios::failure to be thrown.\n+\t      __out.setstate(ios_base::badbit);\n+\t      if ((__out.exceptions() & ios_base::badbit) != 0)\n+\t\t__throw_exception_again;\n+\t    }\n \t}\n       return __out;\n     }\n@@ -601,27 +624,29 @@ namespace std {\n \t    __ws[__i] = __out.widen(__s[__i]);\n \t  _CharT* __str = __ws;\n \t  \n-\t  try {\n-\t    streamsize __len = static_cast<streamsize>(__clen);\n-\t    streamsize __w = __out.width();\n-\t    _CharT* __pads = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __w));\n-\n-\t    if (__w > __len)\n-\t      {\n-\t\t__pad_char(__out, __pads, __ws, __w, __len);\n-\t\t__str = __pads;\n-\t\t__len = __w;\n-\t      }\n-\t    __out.write(__str, __len);\n-\t    __out.width(0);\n-\t  }\n-\t  catch(exception& __fail){\n-\t    // 27.6.1.2.1 Common requirements.\n-\t    // Turn this on without causing an ios::failure to be thrown.\n-\t    __out.setstate(ios_base::badbit);\n-\t    if ((__out.exceptions() & ios_base::badbit) != 0)\n-\t      __throw_exception_again;\n-\t  }\n+\t  try \n+\t    {\n+\t      streamsize __len = static_cast<streamsize>(__clen);\n+\t      streamsize __w = __out.width();\n+\t      _CharT* __pads = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __w));\n+\t      \n+\t      if (__w > __len)\n+\t\t{\n+\t\t  __pad_char(__out, __pads, __ws, __w, __len);\n+\t\t  __str = __pads;\n+\t\t  __len = __w;\n+\t\t}\n+\t      __out.write(__str, __len);\n+\t      __out.width(0);\n+\t    }\n+\t  catch(exception& __fail)\n+\t    {\n+\t      // 27.6.1.2.1 Common requirements.\n+\t      // Turn this on without causing an ios::failure to be thrown.\n+\t      __out.setstate(ios_base::badbit);\n+\t      if ((__out.exceptions() & ios_base::badbit) != 0)\n+\t\t__throw_exception_again;\n+\t    }\n \t}\n       return __out;\n     }\n@@ -635,37 +660,62 @@ namespace std {\n       typename __ostream_type::sentry __cerb(__out);\n       if (__cerb)\n \t{\n-\t  try {\n-\t    streamsize __w = __out.width();\n-\t    char* __pads = static_cast<char*>(__builtin_alloca(__w));\n-\t    streamsize __len = static_cast<streamsize>(_Traits::length(__s));\n-\t    if (__w > __len)\n-\t      {\n-\t\t__pad_char(__out, __pads, __s, __w, __len);\n-\t\t__s = __pads;\n-\t\t__len = __w;\n-\t      }\n-\t    __out.write(__s, __len);\n-\t    __out.width(0);\n-\t  }\n-\t  catch(exception& __fail){\n-\t    // 27.6.1.2.1 Common requirements.\n-\t    // Turn this on without causing an ios::failure to be thrown.\n-\t    __out.setstate(ios_base::badbit);\n-\t    if ((__out.exceptions() & ios_base::badbit) != 0)\n-\t      __throw_exception_again;\n-\t  }\n+\t  try \n+\t    {\n+\t      streamsize __w = __out.width();\n+\t      char* __pads = static_cast<char*>(__builtin_alloca(__w));\n+\t      streamsize __len = static_cast<streamsize>(_Traits::length(__s));\n+\t      if (__w > __len)\n+\t\t{\n+\t\t  __pad_char(__out, __pads, __s, __w, __len);\n+\t\t  __s = __pads;\n+\t\t  __len = __w;\n+\t\t}\n+\t      __out.write(__s, __len);\n+\t      __out.width(0);\n+\t    }\n+\t  catch(exception& __fail)\n+\t    {\n+\t      // 27.6.1.2.1 Common requirements.\n+\t      // Turn this on without causing an ios::failure to be thrown.\n+\t      __out.setstate(ios_base::badbit);\n+\t      if ((__out.exceptions() & ios_base::badbit) != 0)\n+\t\t__throw_exception_again;\n+\t    }\n \t}\n       return __out;\n     }\n \n-  // 21.3.7.8 basic_string::operator<<\n+  // 21.3.7.9 basic_string::operator<<\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     basic_ostream<_CharT, _Traits>&\n     operator<<(basic_ostream<_CharT, _Traits>& __out,\n-\t       const basic_string<_CharT, _Traits, _Alloc>& __s)\n-    { return (__out << __s.c_str()); }\n-\n+\t       const basic_string<_CharT, _Traits, _Alloc>& __str)\n+    { \n+      typedef basic_ostream<_CharT, _Traits> __ostream_type;\n+      typename __ostream_type::sentry __cerb(__out);\n+      if (__cerb)\n+\t{\n+\t  const _CharT* __s = __str.data();\n+\t  streamsize __w = __out.width();\n+\t  _CharT* __pads = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __w));\n+\t  streamsize __len = static_cast<streamsize>(__str.size());\n+#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n+\t  // 25. String operator<< uses width() value wrong\n+#endif\n+\t  if (__w > __len)\n+\t    {\n+\t      __pad_char(__out, __pads, __s, __w, __len);\n+\t      __s = __pads;\n+\t      __len = __w;\n+\t    }\n+\t  streamsize __res = __out.rdbuf()->sputn(__s, __len);\n+\t  __out.width(0);\n+\t  if (__res != __len)\n+\t    __out.setstate(ios_base::failbit);\n+\t}\n+      return __out;\n+    }\n } // namespace std\n  \n // Local Variables:"}, {"sha": "967571a75f30fa91fd650daebe3132c9183e945a", "filename": "libstdc++-v3/testsuite/21_strings/inserters_extractors.cc", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a16ad7794695d54a794e023556cebd61e20bd4c2/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Finserters_extractors.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a16ad7794695d54a794e023556cebd61e20bd4c2/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Finserters_extractors.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Finserters_extractors.cc?ref=a16ad7794695d54a794e023556cebd61e20bd4c2", "patch": "@@ -304,6 +304,26 @@ void test08()\n   VERIFY( year == 2001 );\n }\n \n+// libstdc++/2830\n+void test09()\n+{\n+  bool test = true;\n+  std::string blanks( 3, '\\0');\n+  std::string foo = \"peace\";\n+  foo += blanks;\n+  foo += \"& love\";\n+  \n+  std::ostringstream oss1;\n+  oss1 << foo;\n+  VERIFY( oss1.str() == foo );\n+  \n+  std::ostringstream oss2;\n+  oss2.width(20);\n+  oss2 << foo;\n+  VERIFY( oss2.str() != foo );\n+  VERIFY( oss2.str().size() == 20 );\n+}\n+\n int main()\n { \n   test01();\n@@ -320,5 +340,7 @@ int main()\n   test07();\n \n   test08();\n+  \n+  test09();\n   return 0;\n }"}]}