{"sha": "2b4bd1bc301c22fc47d685f658a100c04597d041", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmI0YmQxYmMzMDFjMjJmYzQ3ZDY4NWY2NThhMTAwYzA0NTk3ZDA0MQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-05-20T00:20:55Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-05-20T00:20:55Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1023", "tree": {"sha": "7056ecd0c9682455c4fd62f6d395a8e1830888b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7056ecd0c9682455c4fd62f6d395a8e1830888b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b4bd1bc301c22fc47d685f658a100c04597d041", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b4bd1bc301c22fc47d685f658a100c04597d041", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b4bd1bc301c22fc47d685f658a100c04597d041", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b4bd1bc301c22fc47d685f658a100c04597d041/comments", "author": null, "committer": null, "parents": [{"sha": "4d449554949422320218bc1d565848cdc5478c80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d449554949422320218bc1d565848cdc5478c80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d449554949422320218bc1d565848cdc5478c80"}], "stats": {"total": 32, "additions": 19, "deletions": 13}, "files": [{"sha": "af6f67d553d9e92d79050d677bc237ffdf0697a8", "filename": "gcc/combine.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b4bd1bc301c22fc47d685f658a100c04597d041/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b4bd1bc301c22fc47d685f658a100c04597d041/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=2b4bd1bc301c22fc47d685f658a100c04597d041", "patch": "@@ -4686,9 +4686,10 @@ apply_distributive_law (x)\n     case SUBREG:\n       /* Non-paradoxical SUBREGs distributes over all operations, provided\n \t the inner modes and word numbers are the same, this is an extraction\n-\t of a low-order part, and we would not be converting a single-word\n+\t of a low-order part, we don't convert an fp operation to int or\n+\t vice versa, and we would not be converting a single-word\n \t operation into a multi-word operation.  The latter test is not\n-\t required, but we prevents generating unneeded multi-word operations.\n+\t required, but it prevents generating unneeded multi-word operations.\n \t Some of the previous tests are redundant given the latter test, but\n \t are retained because they are required for correctness.\n \n@@ -4697,6 +4698,8 @@ apply_distributive_law (x)\n       if (GET_MODE (SUBREG_REG (lhs)) != GET_MODE (SUBREG_REG (rhs))\n \t  || SUBREG_WORD (lhs) != SUBREG_WORD (rhs)\n \t  || ! subreg_lowpart_p (lhs)\n+\t  || (GET_MODE_CLASS (GET_MODE (lhs))\n+\t      != GET_MODE_CLASS (GET_MODE (SUBREG_REG (lhs))))\n \t  || (GET_MODE_SIZE (GET_MODE (lhs))\n \t      < GET_MODE_SIZE (GET_MODE (SUBREG_REG (lhs))))\n \t  || GET_MODE_SIZE (GET_MODE (SUBREG_REG (lhs))) > UNITS_PER_WORD)"}, {"sha": "d5873342141d941fecf45c53f568d3077ec9aa92", "filename": "gcc/config/i960/i960.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b4bd1bc301c22fc47d685f658a100c04597d041/gcc%2Fconfig%2Fi960%2Fi960.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b4bd1bc301c22fc47d685f658a100c04597d041/gcc%2Fconfig%2Fi960%2Fi960.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.md?ref=2b4bd1bc301c22fc47d685f658a100c04597d041", "patch": "@@ -1221,6 +1221,11 @@\n   \"ldos\t%1,%0\"\n   [(set_attr \"type\" \"load\")])\n \n+;; Using shifts here generates much better code than doing an `and 255'.\n+;; This is mainly because the `and' requires loading the constant separately,\n+;; the constant is likely to get optimized, and then the compiler can't\n+;; optimize the `and' because it doesn't know that one operand is a constant.\n+\n (define_expand \"zero_extendqisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"\")))]"}, {"sha": "0502eb8341a96fb461861b8bc10311810cba5533", "filename": "gcc/unroll.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b4bd1bc301c22fc47d685f658a100c04597d041/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b4bd1bc301c22fc47d685f658a100c04597d041/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=2b4bd1bc301c22fc47d685f658a100c04597d041", "patch": "@@ -1461,10 +1461,15 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t      for (tv = bl->giv; tv; tv = tv->next_iv)\n \t\tif (tv->giv_type == DEST_ADDR && tv->same == v)\n \t\t  {\n-\t\t    /* Increment the giv by the amount that was calculated in\n-\t\t       find_splittable_givs, and saved in add_val.  */\n-\t\t    tv->dest_reg = plus_constant (tv->dest_reg,\n-\t\t\t\t\t\t  INTVAL (tv->add_val));\n+\t\t    int this_giv_inc = INTVAL (giv_inc);\n+\n+\t\t    /* Scale this_giv_inc if the multiplicative factors of\n+\t\t       the two givs are different.  */\n+\t\t    if (tv->mult_val != v->mult_val)\n+\t\t      this_giv_inc = (this_giv_inc / INTVAL (v->mult_val)\n+\t\t\t\t      * INTVAL (tv->mult_val));\n+\t\t       \n+\t\t    tv->dest_reg = plus_constant (tv->dest_reg, this_giv_inc);\n \t\t    *tv->location = tv->dest_reg;\n \t\t    \n \t\t    if (last_iteration && unroll_type != UNROLL_COMPLETELY)\n@@ -2598,13 +2603,6 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \t\t    }\n \t\t}\n \n-\t      /* Overwrite the old add_val, which is no longer needed, and\n-\t\t substitute the amount that the giv is incremented on each\n-\t\t iteration.  We need to save this somewhere, so we know how\n-\t\t much to increment split DEST_ADDR giv's in copy_loop_body.  */\n-\n-\t      v->add_val = giv_inc;\n-\n \t      if (loop_dump_stream)\n \t\tfprintf (loop_dump_stream, \"DEST_ADDR giv being split.\\n\");\n \t    }"}]}