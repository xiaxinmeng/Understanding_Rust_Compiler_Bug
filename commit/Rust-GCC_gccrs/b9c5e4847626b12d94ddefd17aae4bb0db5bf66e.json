{"sha": "b9c5e4847626b12d94ddefd17aae4bb0db5bf66e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjljNWU0ODQ3NjI2YjEyZDk0ZGRlZmQxN2FhZTRiYjBkYjViZjY2ZQ==", "commit": {"author": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2006-07-04T21:23:03Z"}, "committer": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2006-07-04T21:23:03Z"}, "message": "Fix whitespace.\n\nFrom-SVN: r115190", "tree": {"sha": "ee3dc4aefbc94a8b63f11b15f7fe9da39a62ff92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ee3dc4aefbc94a8b63f11b15f7fe9da39a62ff92"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b9c5e4847626b12d94ddefd17aae4bb0db5bf66e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9c5e4847626b12d94ddefd17aae4bb0db5bf66e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9c5e4847626b12d94ddefd17aae4bb0db5bf66e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9c5e4847626b12d94ddefd17aae4bb0db5bf66e/comments", "author": null, "committer": null, "parents": [{"sha": "a25bf5b38105918b859f161e201916ae52ff86e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a25bf5b38105918b859f161e201916ae52ff86e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a25bf5b38105918b859f161e201916ae52ff86e9"}], "stats": {"total": 343, "additions": 171, "deletions": 172}, "files": [{"sha": "4c0f2f419aa76d447363ceec28a896eca47b3161", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 171, "deletions": 172, "changes": 343, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9c5e4847626b12d94ddefd17aae4bb0db5bf66e/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9c5e4847626b12d94ddefd17aae4bb0db5bf66e/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=b9c5e4847626b12d94ddefd17aae4bb0db5bf66e", "patch": "@@ -1,7 +1,7 @@\n /* SSA-PRE for trees.\n    Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n    Contributed by Daniel Berlin <dan@dberlin.org> and Steven Bosscher\n-   <stevenb@suse.de> \n+   <stevenb@suse.de>\n \n This file is part of GCC.\n \n@@ -45,7 +45,7 @@ Boston, MA 02110-1301, USA.  */\n #include \"cfgloop.h\"\n \n /* TODO:\n-   \n+\n    1. Avail sets can be shared by making an avail_find_leader that\n       walks up the dominator tree and looks in those avail sets.\n       This might affect code optimality, it's unclear right now.\n@@ -58,15 +58,15 @@ Boston, MA 02110-1301, USA.  */\n       any store in a block, instead of loads that occur before\n       stores that affect them.  This is relatively more expensive, and\n       it's not clear how much more it will buy us.\n-*/   \n+*/\n \n /* For ease of terminology, \"expression node\" in the below refers to\n    every expression node but MODIFY_EXPR, because MODIFY_EXPR's represent\n    the actual statement containing the expressions we care about, and\n    we cache the value number by putting it in the expression.  */\n \n /* Basic algorithm\n-   \n+\n    First we walk the statements to generate the AVAIL sets, the\n    EXP_GEN sets, and the tmp_gen sets.  EXP_GEN sets represent the\n    generation of values/expressions by a given block.  We use them\n@@ -77,7 +77,7 @@ Boston, MA 02110-1301, USA.  */\n    fixpoint iteration, in order to calculate the AVAIL sets.  In\n    traditional parlance, AVAIL sets tell us the downsafety of the\n    expressions/values.\n-   \n+\n    Next, we generate the ANTIC sets.  These sets represent the\n    anticipatable expressions.  ANTIC is a backwards dataflow\n    problem.An expression is anticipatable in a given block if it could\n@@ -124,28 +124,28 @@ Boston, MA 02110-1301, USA.  */\n    unique number for each value number in use.  This allows\n    expressions with SSA_NAMES replaced by value handles to still be\n    pretty printed in a sane way.  They simply print as \"value.3 *\n-   value.5\", etc.  \n+   value.5\", etc.\n \n    Expression nodes have value handles associated with them as a\n    cache.  Otherwise, we'd have to look them up again in the hash\n    table This makes significant difference (factor of two or more) on\n    some test cases.  They can be thrown away after the pass is\n    finished.  */\n \n-/* Representation of expressions on value numbers: \n+/* Representation of expressions on value numbers:\n \n    In some portions of this code, you will notice we allocate \"fake\"\n    analogues to the expression we are value numbering, and replace the\n    operands with the values of the expression.  Since we work on\n    values, and not just names, we canonicalize expressions to value\n-   expressions for use in the ANTIC sets, the EXP_GEN set, etc.  \n+   expressions for use in the ANTIC sets, the EXP_GEN set, etc.\n \n    This is theoretically unnecessary, it just saves a bunch of\n    repeated get_value_handle and find_leader calls in the remainder of\n    the code, trading off temporary memory usage for speed.  The tree\n    nodes aren't actually creating more garbage, since they are\n    allocated in a special pools which are thrown away at the end of\n-   this pass.  \n+   this pass.\n \n    All of this also means that if you print the EXP_GEN or ANTIC sets,\n    you will see \"value.5 + value.7\" in the set, instead of \"a_55 +\n@@ -163,7 +163,7 @@ Boston, MA 02110-1301, USA.  */\n    and thus, are simply represented as two bitmaps, one that keeps\n    track of values present in the set, and one that keeps track of\n    expressions present in the set.\n-   \n+\n    The other sets are represented as doubly linked lists kept in topological\n    order, with an optional supporting bitmap of values present in the\n    set.  The sets represent values, and the elements can be values or\n@@ -205,19 +205,19 @@ typedef struct value_set\n      necessary to keep the set in topologically sorted order because\n      of how the set is built.  */\n   value_set_node_t tail;\n-  \n+\n   /* The length of the list.  */\n   size_t length;\n-  \n+\n   /* True if the set is indexed, which means it contains a backing\n      bitmap for quick determination of whether certain values exist in the\n      set.  */\n   bool indexed;\n-  \n+\n   /* The bitmap of values that exist in the set.  May be NULL in an\n      empty or non-indexed set.  */\n   bitmap values;\n-  \n+\n } *value_set_t;\n \n \n@@ -294,10 +294,10 @@ static struct\n \n   /* The number of new PHI nodes added by PRE.  */\n   int phis;\n-  \n+\n   /* The number of values found constant.  */\n   int constified;\n-  \n+\n } pre_stats;\n \n \n@@ -393,22 +393,22 @@ expr_pred_trans_eq (const void *p1, const void *p2)\n   basic_block b2 = ve2->pred;\n   int i;\n   tree vuse1;\n-  \n+\n   /* If they are not translations for the same basic block, they can't\n      be equal.  */\n   if (b1 != b2)\n     return false;\n \n \n   /* If they are for the same basic block, determine if the\n-     expressions are equal.  */  \n+     expressions are equal.  */\n   if (!expressions_equal_p (ve1->e, ve2->e))\n     return false;\n \n   /* Make sure the vuses are equivalent.  */\n   if (ve1->vuses == ve2->vuses)\n     return true;\n-  \n+\n   if (VEC_length (tree, ve1->vuses) != VEC_length (tree, ve2->vuses))\n     return false;\n \n@@ -524,7 +524,7 @@ value_insert_into_set_bitmap (value_set_t set, tree v)\n \n /* Create a new bitmap set and return it.  */\n \n-static bitmap_set_t \n+static bitmap_set_t\n bitmap_set_new (void)\n {\n   bitmap_set_t ret = (bitmap_set_t) pool_alloc (bitmap_set_pool);\n@@ -556,7 +556,7 @@ bitmap_insert_into_set (bitmap_set_t set, tree expr)\n   /* XXX: For now, we only let SSA_NAMES into the bitmap sets.  */\n   gcc_assert (TREE_CODE (expr) == SSA_NAME);\n   val = get_value_handle (expr);\n-  \n+\n   gcc_assert (val);\n   if (!is_gimple_min_invariant (val))\n   {\n@@ -573,7 +573,7 @@ insert_into_set (value_set_t set, tree expr)\n   value_set_node_t newnode = (value_set_node_t) pool_alloc (value_set_node_pool);\n   tree val = get_value_handle (expr);\n   gcc_assert (val);\n-  \n+\n   if (is_gimple_min_invariant (val))\n     return;\n \n@@ -661,7 +661,7 @@ static void\n set_copy (value_set_t dest, value_set_t orig)\n {\n   value_set_node_t node;\n- \n+\n   if (!orig || !orig->head)\n     return;\n \n@@ -681,12 +681,12 @@ set_remove (value_set_t set, tree expr)\n   value_set_node_t node, prev;\n \n   /* Remove the value of EXPR from the bitmap, decrement the set\n-     length, and remove it from the actual double linked list.  */ \n+     length, and remove it from the actual double linked list.  */\n   value_remove_from_set_bitmap (set, get_value_handle (expr));\n   set->length--;\n   prev = NULL;\n-  for (node = set->head; \n-       node != NULL; \n+  for (node = set->head;\n+       node != NULL;\n        prev = node, node = node->next)\n     {\n       if (node->expr == expr)\n@@ -695,7 +695,7 @@ set_remove (value_set_t set, tree expr)\n \t    set->head = node->next;\n \t  else\n \t    prev->next= node->next;\n- \n+\n \t  if (node == set->tail)\n \t    set->tail = prev;\n \t  pool_free (value_set_node_pool, node);\n@@ -712,10 +712,10 @@ set_contains_value (value_set_t set, tree val)\n   /* All constants are in every set.  */\n   if (is_gimple_min_invariant (val))\n     return true;\n-  \n+\n   if (!set || set->length == 0)\n     return false;\n-  \n+\n   return value_exists_in_set_bitmap (set, val);\n }\n \n@@ -733,7 +733,7 @@ bitmap_set_contains (bitmap_set_t set, tree expr)\n   return bitmap_bit_p (set->expressions, SSA_NAME_VERSION (expr));\n }\n \n-  \n+\n /* Return true if bitmapped set SET contains the value VAL.  */\n \n static bool\n@@ -840,7 +840,7 @@ bitmap_value_insert_into_set (bitmap_set_t set, tree expr)\n \n   if (is_gimple_min_invariant (val))\n     return;\n-  \n+\n   if (!bitmap_set_contains_value (set, val))\n     bitmap_insert_into_set (set, expr);\n }\n@@ -881,7 +881,7 @@ bitmap_print_value_set (FILE *outfile, bitmap_set_t set,\n \t    fprintf (outfile, \", \");\n \t  first = false;\n \t  print_generic_expr (outfile, ssa_name (i), 0);\n-\t\n+\n \t  fprintf (outfile, \" (\");\n \t  print_generic_expr (outfile, get_value_handle (ssa_name (i)), 0);\n \t  fprintf (outfile, \") \");\n@@ -904,11 +904,11 @@ print_value_set (FILE *outfile, value_set_t set,\n \t   node = node->next)\n \t{\n \t  print_generic_expr (outfile, node->expr, 0);\n-\t  \n+\n \t  fprintf (outfile, \" (\");\n \t  print_generic_expr (outfile, get_value_handle (node->expr), 0);\n \t  fprintf (outfile, \") \");\n-\t\t     \n+\n \t  if (node->next)\n \t    fprintf (outfile, \", \");\n \t}\n@@ -937,7 +937,7 @@ debug_value_expressions (tree val)\n   print_value_expressions (stderr, val);\n }\n \n-  \n+\n void debug_value_set (value_set_t, const char *, int);\n \n void\n@@ -947,11 +947,11 @@ debug_value_set (value_set_t set, const char *setname, int blockindex)\n }\n \n /* Return the folded version of T if T, when folded, is a gimple\n-   min_invariant.  Otherwise, return T.  */ \n+   min_invariant.  Otherwise, return T.  */\n \n static tree\n fully_constant_expression (tree t)\n-{  \n+{\n   tree folded;\n   folded = fold (t);\n   if (folded && is_gimple_min_invariant (folded))\n@@ -960,7 +960,7 @@ fully_constant_expression (tree t)\n }\n \n /* Return a copy of a chain of nodes, chained through the TREE_CHAIN field.\n-   For example, this can copy a list made of TREE_LIST nodes.  \n+   For example, this can copy a list made of TREE_LIST nodes.\n    Allocates the nodes in list_node_pool*/\n \n static tree\n@@ -972,10 +972,10 @@ pool_copy_list (tree list)\n   if (list == 0)\n     return 0;\n   head = (tree) pool_alloc (list_node_pool);\n-  \n+\n   memcpy (head, list, tree_size (list));\n   prev = head;\n-  \n+\n   next = TREE_CHAIN (list);\n   while (next)\n     {\n@@ -1055,7 +1055,7 @@ phi_translate (tree expr, value_set_t set, basic_block pred,\n \n   if (phitrans)\n     return phitrans;\n-  \n+\n   switch (TREE_CODE_CLASS (TREE_CODE (expr)))\n     {\n     case tcc_expression:\n@@ -1083,8 +1083,8 @@ phi_translate (tree expr, value_set_t set, basic_block pred,\n \t       as one value number, because that doesn't make much\n \t       sense, and just breaks the support functions we call,\n \t       which expect TREE_OPERAND (call_expr, 2) to be a\n-\t       TREE_LIST. */\t      \n-\t    \n+\t       TREE_LIST. */\n+\n \t    newop0 = phi_translate (find_leader (set, oldop0),\n \t\t\t\t    set, pred, phiblock);\n \t    if (newop0 == NULL)\n@@ -1098,18 +1098,18 @@ phi_translate (tree expr, value_set_t set, basic_block pred,\n \t      }\n \n \t    /* phi translate the argument list piece by piece.\n-\t       \n+\n \t      We could actually build the list piece by piece here,\n \t      but it's likely to not be worth the memory we will save,\n \t      unless you have millions of call arguments.  */\n \n \t    newarglist = pool_copy_list (oldarglist);\n \t    for (oldwalker = oldarglist, newwalker = newarglist;\n \t\t oldwalker && newwalker;\n-\t\t oldwalker = TREE_CHAIN (oldwalker), \n+\t\t oldwalker = TREE_CHAIN (oldwalker),\n \t\t   newwalker = TREE_CHAIN (newwalker))\n \t      {\n-\t\t\n+\n \t\ttree oldval = TREE_VALUE (oldwalker);\n \t\ttree newval;\n \t\tif (oldval)\n@@ -1139,7 +1139,7 @@ phi_translate (tree expr, value_set_t set, basic_block pred,\n \t      }\n \t    if (listchanged)\n \t      vn_lookup_or_add (newarglist, NULL);\n-\t    \n+\n \t    tvuses = translate_vuses_through_block (vuses, pred);\n \n \t    if (listchanged || (newop0 != oldop0) || (oldop2 != newop2)\n@@ -1150,7 +1150,7 @@ phi_translate (tree expr, value_set_t set, basic_block pred,\n \t\tTREE_OPERAND (newexpr, 0) = newop0 == oldop0 ? oldop0 : get_value_handle (newop0);\n \t\tTREE_OPERAND (newexpr, 1) = listchanged ? newarglist : oldarglist;\n \t\tTREE_OPERAND (newexpr, 2) = newop2 == oldop2 ? oldop2 : get_value_handle (newop2);\n-\t\tcreate_tree_ann (newexpr);\t \n+\t\tcreate_tree_ann (newexpr);\n \t\tvn_lookup_or_add_with_vuses (newexpr, tvuses);\n \t\texpr = newexpr;\n \t\tphi_trans_add (oldexpr, newexpr, pred, tvuses);\n@@ -1198,21 +1198,21 @@ phi_translate (tree expr, value_set_t set, basic_block pred,\n \t\t\t\tset, pred, phiblock);\n \tif (newop0 == NULL)\n \t  return NULL;\n-\t\n+\n \tif (TREE_CODE (expr) == ARRAY_REF)\n \t  {\n \t    oldop1 = TREE_OPERAND (expr, 1);\n \t    newop1 = phi_translate (find_leader (set, oldop1),\n \t\t\t\t    set, pred, phiblock);\n-\t\n+\n \t    if (newop1 == NULL)\n \t      return NULL;\n \t    oldop2 = TREE_OPERAND (expr, 2);\n \t    if (oldop2)\n \t      {\n \t\tnewop2 = phi_translate (find_leader (set, oldop2),\n \t\t\t\t\tset, pred, phiblock);\n-\t    \n+\n \t\tif (newop2 == NULL)\n \t\t  return NULL;\n \t      }\n@@ -1221,7 +1221,7 @@ phi_translate (tree expr, value_set_t set, basic_block pred,\n \t      {\n \t\tnewop3 = phi_translate (find_leader (set, oldop3),\n \t\t\t\t\tset, pred, phiblock);\n-\t\t\n+\n \t\tif (newop3 == NULL)\n \t\t  return NULL;\n \t      }\n@@ -1230,10 +1230,10 @@ phi_translate (tree expr, value_set_t set, basic_block pred,\n \toldvuses = VALUE_HANDLE_VUSES (get_value_handle (expr));\n \tif (oldvuses)\n \t  newvuses = translate_vuses_through_block (oldvuses, pred);\n-\t\n+\n \tif (newop0 != oldop0 || newvuses != oldvuses\n-\t    || newop1 != oldop1 \n-\t    || newop2 != oldop2 \n+\t    || newop1 != oldop1\n+\t    || newop2 != oldop2\n \t    || newop3 != oldop3)\n \t  {\n \t    tree t;\n@@ -1277,7 +1277,7 @@ phi_translate (tree expr, value_set_t set, basic_block pred,\n \ttree newop1;\n \ttree newop2;\n \ttree newexpr;\n-\t\n+\n \tnewop1 = phi_translate (find_leader (set, oldop1),\n \t\t\t\tset, pred, phiblock);\n \tif (newop1 == NULL)\n@@ -1301,7 +1301,7 @@ phi_translate (tree expr, value_set_t set, basic_block pred,\n \t      }\n \t    else\n \t      {\n-\t\tcreate_tree_ann (newexpr);\t \n+\t\tcreate_tree_ann (newexpr);\n \t\tvn_lookup_or_add (newexpr, NULL);\n \t      }\n \t    expr = newexpr;\n@@ -1334,7 +1334,7 @@ phi_translate (tree expr, value_set_t set, basic_block pred,\n \t      }\n \t    else\n \t      {\n-\t\tcreate_tree_ann (newexpr);\t \n+\t\tcreate_tree_ann (newexpr);\n \t\tvn_lookup_or_add (newexpr, NULL);\n \t      }\n \t    expr = newexpr;\n@@ -1352,7 +1352,7 @@ phi_translate (tree expr, value_set_t set, basic_block pred,\n \t  phi = SSA_NAME_DEF_STMT (expr);\n \telse\n \t  return expr;\n-\t\n+\n \te = find_edge (pred, bb_for_stmt (phi));\n \tif (e)\n \t  {\n@@ -1383,7 +1383,7 @@ phi_translate_set (value_set_t dest, value_set_t set, basic_block pred,\n        node = node->next)\n     {\n       tree translated;\n-      \n+\n       translated = phi_translate (node->expr, set, pred, phiblock);\n \n       /* Don't add constants or empty translations to the cache, since\n@@ -1392,7 +1392,7 @@ phi_translate_set (value_set_t dest, value_set_t set, basic_block pred,\n \t{\n \t  tree vh = get_value_handle (translated);\n \t  VEC (tree, gc) *vuses;\n-\t  \n+\n \t  /* The value handle itself may also be an invariant, in\n \t     which case, it has no vuses.  */\n \t  vuses = !is_gimple_min_invariant (vh)\n@@ -1402,7 +1402,7 @@ phi_translate_set (value_set_t dest, value_set_t set, basic_block pred,\n \n       if (translated != NULL)\n \tvalue_insert_into_set (dest, translated);\n-    } \n+    }\n }\n \n /* Find the leader for a value (i.e., the name representing that\n@@ -1414,7 +1414,7 @@ bitmap_find_leader (bitmap_set_t set, tree val)\n {\n   if (val == NULL)\n     return NULL;\n-  \n+\n   if (is_gimple_min_invariant (val))\n     return val;\n   if (bitmap_set_contains_value (set, val))\n@@ -1429,15 +1429,15 @@ bitmap_find_leader (bitmap_set_t set, tree val)\n \t large testcases, doing it this way is roughly 5-10x faster\n \t than walking the bitmap.\n \t If this is somehow a significant lose for some cases, we can\n-\t choose which set to walk based on which set is smaller.  */\t \n+\t choose which set to walk based on which set is smaller.  */\n       value_set_t exprset;\n       value_set_node_t node;\n       exprset = VALUE_HANDLE_EXPR_SET (val);\n       for (node = exprset->head; node; node = node->next)\n \t{\n \t  if (TREE_CODE (node->expr) == SSA_NAME)\n \t    {\n-\t      if (bitmap_bit_p (set->expressions, \n+\t      if (bitmap_bit_p (set->expressions,\n \t\t\t\tSSA_NAME_VERSION (node->expr)))\n \t\treturn node->expr;\n \t    }\n@@ -1446,7 +1446,7 @@ bitmap_find_leader (bitmap_set_t set, tree val)\n   return NULL;\n }\n \n-\t\n+\n /* Find the leader for a value (i.e., the name representing that\n    value) in a given set, and return it.  Return NULL if no leader is\n    found.  */\n@@ -1465,7 +1465,7 @@ find_leader (value_set_t set, tree val)\n \n   if (set->length == 0)\n     return NULL;\n-  \n+\n   if (value_exists_in_set_bitmap (set, val))\n     {\n       for (node = set->head;\n@@ -1517,7 +1517,7 @@ vuses_dies_in_block_x (VEC (tree, gc) *vuses, basic_block block)\n \n /* Determine if the expression EXPR is valid in SET.  This means that\n    we have a leader for each part of the expression (if it consists of\n-   values), or the expression is an SSA_NAME.  \n+   values), or the expression is an SSA_NAME.\n \n    NB: We never should run into a case where we have SSA_NAME +\n    SSA_NAME or SSA_NAME + value.  The sets valid_in_set is called on,\n@@ -1543,7 +1543,7 @@ valid_in_set (value_set_t set, tree expr, basic_block block)\n \ttree op1 = TREE_OPERAND (expr, 0);\n \treturn set_contains_value (set, op1);\n       }\n-      \n+\n     case tcc_expression:\n       {\n \tif (TREE_CODE (expr) == CALL_EXPR)\n@@ -1567,10 +1567,10 @@ valid_in_set (value_set_t set, tree expr, basic_block block)\n \t  }\n \treturn false;\n       }\n-      \n+\n     case tcc_reference:\n       {\n-\tif (TREE_CODE (expr) == INDIRECT_REF \n+\tif (TREE_CODE (expr) == INDIRECT_REF\n \t    || TREE_CODE (expr) == COMPONENT_REF\n             || TREE_CODE (expr) == ARRAY_REF)\n \t  {\n@@ -1616,7 +1616,7 @@ valid_in_set (value_set_t set, tree expr, basic_block block)\n \n     default:\n       /* No other cases should be encountered.  */\n-      gcc_unreachable (); \n+      gcc_unreachable ();\n    }\n }\n \n@@ -1633,7 +1633,7 @@ clean (value_set_t set, basic_block block)\n   while (node)\n     {\n       next = node->next;\n-      if (!valid_in_set (set, node->expr, block))\t\n+      if (!valid_in_set (set, node->expr, block))\n \tset_remove (set, node->expr);\n       node = next;\n     }\n@@ -1721,7 +1721,7 @@ compute_antic_aux (basic_block block, bool block_has_abnormal_pred_edge)\n   S = bitmap_set_subtract_from_value_set (ANTIC_OUT, TMP_GEN (block), false);\n \n   /* Start ANTIC_IN with EXP_GEN - TMP_GEN */\n-  ANTIC_IN (block) = bitmap_set_subtract_from_value_set (EXP_GEN (block), \n+  ANTIC_IN (block) = bitmap_set_subtract_from_value_set (EXP_GEN (block),\n \t\t\t\t\t\t\t TMP_GEN (block),\n \t\t\t\t\t\t\t true);\n \n@@ -1741,7 +1741,7 @@ compute_antic_aux (basic_block block, bool block_has_abnormal_pred_edge)\n \tprint_value_set (dump_file, ANTIC_OUT, \"ANTIC_OUT\", block->index);\n \n       if (ANTIC_SAFE_LOADS (block))\n-\tprint_value_set (dump_file, ANTIC_SAFE_LOADS (block), \n+\tprint_value_set (dump_file, ANTIC_SAFE_LOADS (block),\n \t\t\t \"ANTIC_SAFE_LOADS\", block->index);\n       print_value_set (dump_file, ANTIC_IN (block), \"ANTIC_IN\", block->index);\n \n@@ -1904,19 +1904,19 @@ compute_vuse_representatives (void)\n    uses, and virtual uses *do* actually die, this ends up being faster\n    in most cases than continually walking the virtual use/def chains\n    to determine whether we are inside a block where a given virtual is\n-   still available to be used.  \n+   still available to be used.\n \n    ANTIC_SAFE_LOADS are those loads that actually occur before any kill to\n    their vuses in the block,and thus, are safe at the top of the\n-   block.  \n+   block.\n \n    An example:\n \n    <block begin>\n    b = *a\n    *a = 9\n    <block end>\n-   \n+\n    b = *a is an antic safe load because it still safe to consider it\n    ANTIC at the top of the block.\n \n@@ -1939,7 +1939,7 @@ compute_rvuse_and_antic_safe (void)\n   unsigned int *first_store_uid;\n \n   first_store_uid = xcalloc (n_basic_blocks, sizeof (unsigned int));\n-  \n+\n   compute_vuse_representatives ();\n \n   FOR_ALL_BB (bb)\n@@ -1976,14 +1976,14 @@ compute_rvuse_and_antic_safe (void)\n       for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n \t{\n \t  tree stmt = bsi_stmt (bsi);\n-\t  \n-\t  if (first_store_uid[bb->index] == 0 \n-\t      && !ZERO_SSA_OPERANDS (stmt, SSA_OP_VMAYUSE | SSA_OP_VMAYDEF \n+\n+\t  if (first_store_uid[bb->index] == 0\n+\t      && !ZERO_SSA_OPERANDS (stmt, SSA_OP_VMAYUSE | SSA_OP_VMAYDEF\n \t\t\t\t     | SSA_OP_VMUSTDEF | SSA_OP_VMUSTKILL))\n \t    {\n \t      first_store_uid[bb->index] = stmt_ann (stmt)->uid;\n \t    }\n-\t  \n+\n \n \t  FOR_EACH_SSA_USE_OPERAND (usep, stmt, iter, SSA_OP_VIRTUAL_KILLS\n \t\t\t\t    | SSA_OP_VMAYUSE)\n@@ -2079,31 +2079,31 @@ compute_rvuse_and_antic_safe (void)\n     }\n \n   FOR_EACH_BB (bb)\n-    {      \n+    {\n       value_set_node_t node;\n       if (bitmap_empty_p (RVUSE_KILL (bb)))\n \tcontinue;\n-      \n+\n       for (node = EXP_GEN (bb)->head; node; node = node->next)\n \t{\n \t  if (REFERENCE_CLASS_P (node->expr))\n \t    {\n \t      tree vh = get_value_handle (node->expr);\n \t      tree maybe = bitmap_find_leader (AVAIL_OUT (bb), vh);\n-\t      \n+\n \t      if (maybe)\n \t\t{\n \t\t  tree def = SSA_NAME_DEF_STMT (maybe);\n \n \t\t  if (bb_for_stmt (def) != bb)\n \t\t    continue;\n-\t\t  \n+\n \t\t  if (TREE_CODE (def) == PHI_NODE\n \t\t      || stmt_ann (def)->uid < first_store_uid[bb->index])\n \t\t    {\n \t\t      if (ANTIC_SAFE_LOADS (bb) == NULL)\n \t\t\tANTIC_SAFE_LOADS (bb) = set_new (true);\n-\t\t      value_insert_into_set (ANTIC_SAFE_LOADS (bb), \n+\t\t      value_insert_into_set (ANTIC_SAFE_LOADS (bb),\n \t\t\t\t\t     node->expr);\n \t\t    }\n \t\t}\n@@ -2176,7 +2176,7 @@ static VEC(tree, heap) *need_creation;\n    Thus, this routine doesn't create temporaries, it just builds a\n    single access expression for the array, calling\n    find_or_generate_expression to build the innermost pieces.\n-   \n+\n    This function is a subroutine of create_expression_by_pieces, and\n    should not be called on it's own unless you really know what you\n    are doing.\n@@ -2193,7 +2193,7 @@ create_component_ref_by_pieces (basic_block block, tree expr, tree stmts)\n       if (found)\n \treturn found;\n     }\n-  \n+\n   if (TREE_CODE (genop) == VALUE_HANDLE)\n     genop = VALUE_HANDLE_EXPR_SET (expr)->head->expr;\n \n@@ -2203,7 +2203,7 @@ create_component_ref_by_pieces (basic_block block, tree expr, tree stmts)\n       {\n \ttree op0;\n \ttree op1, op2, op3;\n-\top0 = create_component_ref_by_pieces (block, \n+\top0 = create_component_ref_by_pieces (block,\n \t\t\t\t\t      TREE_OPERAND (genop, 0),\n \t\t\t\t\t      stmts);\n \top1 = TREE_OPERAND (genop, 1);\n@@ -2215,19 +2215,19 @@ create_component_ref_by_pieces (basic_block block, tree expr, tree stmts)\n \top3 = TREE_OPERAND (genop, 3);\n \tif (op3 && TREE_CODE (op3) == VALUE_HANDLE)\n \t  op3 = find_or_generate_expression (block, op3, stmts);\n-\tfolded = build4 (ARRAY_REF, TREE_TYPE (genop), op0, op1, \n+\tfolded = build4 (ARRAY_REF, TREE_TYPE (genop), op0, op1,\n \t\t\t      op2, op3);\n \treturn folded;\n       }\n     case COMPONENT_REF:\n       {\n \ttree op0;\n \ttree op1;\n-\top0 = create_component_ref_by_pieces (block, \n+\top0 = create_component_ref_by_pieces (block,\n \t\t\t\t\t      TREE_OPERAND (genop, 0),\n \t\t\t\t\t      stmts);\n \top1 = VALUE_HANDLE_EXPR_SET (TREE_OPERAND (genop, 1))->head->expr;\n-\tfolded = fold_build3 (COMPONENT_REF, TREE_TYPE (genop), op0, op1, \n+\tfolded = fold_build3 (COMPONENT_REF, TREE_TYPE (genop), op0, op1,\n \t\t\t      NULL_TREE);\n \treturn folded;\n       }\n@@ -2236,7 +2236,7 @@ create_component_ref_by_pieces (basic_block block, tree expr, tree stmts)\n       {\n \ttree op1 = TREE_OPERAND (genop, 0);\n \ttree genop1 = find_or_generate_expression (block, op1, stmts);\n-\t\n+\n \tfolded = fold_build1 (TREE_CODE (genop), TREE_TYPE (genop),\n \t\t\t      genop1);\n \treturn folded;\n@@ -2249,17 +2249,17 @@ create_component_ref_by_pieces (basic_block block, tree expr, tree stmts)\n     case STRING_CST:\n       return genop;\n     default:\n-      gcc_unreachable ();      \n+      gcc_unreachable ();\n     }\n \n   return NULL_TREE;\n }\n \n /* Find a leader for an expression, or generate one using\n    create_expression_by_pieces if it's ANTIC but\n-   complex.  \n+   complex.\n    BLOCK is the basic_block we are looking for leaders in.\n-   EXPR is the expression to find a leader or generate for. \n+   EXPR is the expression to find a leader or generate for.\n    STMTS is the statement list to put the inserted expressions on.\n    Returns the SSA_NAME of the LHS of the generated expression or the\n    leader.  */\n@@ -2281,9 +2281,9 @@ find_or_generate_expression (basic_block block, tree expr, tree stmts)\n   return genop;\n }\n \n-#define NECESSARY(stmt)\t\tstmt->common.asm_written_flag  \n+#define NECESSARY(stmt)\t\tstmt->common.asm_written_flag\n /* Create an expression in pieces, so that we can handle very complex\n-   expressions that may be ANTIC, but not necessary GIMPLE.  \n+   expressions that may be ANTIC, but not necessary GIMPLE.\n    BLOCK is the basic block the expression will be inserted into,\n    EXPR is the expression to insert (in value form)\n    STMTS is a statement list to append the necessary insertions into.\n@@ -2313,14 +2313,14 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n \ttree genop0, genop2;\n \ttree genarglist;\n \ttree walker, genwalker;\n-\t\n+\n \tgcc_assert (TREE_CODE (expr) == CALL_EXPR);\n \tgenop2 = NULL;\n-\t\n+\n \top0 = TREE_OPERAND (expr, 0);\n \targlist = TREE_OPERAND (expr, 1);\n \top2 = TREE_OPERAND (expr, 2);\n-\t\n+\n \tgenop0 = find_or_generate_expression (block, op0, stmts);\n \tgenarglist = copy_list (arglist);\n \tfor (walker = arglist, genwalker = genarglist;\n@@ -2332,13 +2332,13 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n \t\t\t\t\t     stmts);\n \t  }\n \n-\tif (op2)\t  \n+\tif (op2)\n \t  genop2 = find_or_generate_expression (block, op2, stmts);\n \tfolded = fold_build3 (TREE_CODE (expr), TREE_TYPE (expr),\n \t\t\t      genop0, genarglist, genop2);\n \tbreak;\n-\t\n-\t\n+\n+\n       }\n       break;\n     case tcc_reference:\n@@ -2352,21 +2352,21 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n \t  {\n \t    tree op1 = TREE_OPERAND (expr, 0);\n \t    tree genop1 = find_or_generate_expression (block, op1, stmts);\n-\t    \n+\n \t    folded = fold_build1 (TREE_CODE (expr), TREE_TYPE (expr),\n \t\t\t\t  genop1);\n \t  }\n \tbreak;\n       }\n-      \n+\n     case tcc_binary:\n     case tcc_comparison:\n       {\n \ttree op1 = TREE_OPERAND (expr, 0);\n \ttree op2 = TREE_OPERAND (expr, 1);\n \ttree genop1 = find_or_generate_expression (block, op1, stmts);\n \ttree genop2 = find_or_generate_expression (block, op2, stmts);\n-\tfolded = fold_build2 (TREE_CODE (expr), TREE_TYPE (expr), \n+\tfolded = fold_build2 (TREE_CODE (expr), TREE_TYPE (expr),\n \t\t\t      genop1, genop2);\n \tbreak;\n       }\n@@ -2375,7 +2375,7 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n       {\n \ttree op1 = TREE_OPERAND (expr, 0);\n \ttree genop1 = find_or_generate_expression (block, op1, stmts);\n-\tfolded = fold_build1 (TREE_CODE (expr), TREE_TYPE (expr), \n+\tfolded = fold_build1 (TREE_CODE (expr), TREE_TYPE (expr),\n \t\t\t      genop1);\n \tbreak;\n       }\n@@ -2388,7 +2388,7 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n      statements.\n      We have to call unshare_expr because force_gimple_operand may\n      modify the tree we pass to it.  */\n-  newexpr = force_gimple_operand (unshare_expr (folded), &forced_stmts, \n+  newexpr = force_gimple_operand (unshare_expr (folded), &forced_stmts,\n                                   false, NULL);\n \n   /* If we have any intermediate expressions to the value sets, add them\n@@ -2402,7 +2402,7 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n \t  tree forcedname = TREE_OPERAND (stmt, 0);\n \t  tree forcedexpr = TREE_OPERAND (stmt, 1);\n \t  tree val = vn_lookup_or_add (forcedexpr, NULL);\n-\t  \n+\n \t  VEC_safe_push (tree, heap, inserted_exprs, stmt);\n \t  vn_add (forcedname, val);\n \t  bitmap_value_replace_in_set (NEW_SETS (block), forcedname);\n@@ -2444,12 +2444,12 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n      here.  */\n   v = get_value_handle (expr);\n   vn_add (name, v);\n-  bitmap_value_replace_in_set (NEW_SETS (block), name); \n+  bitmap_value_replace_in_set (NEW_SETS (block), name);\n   bitmap_value_replace_in_set (AVAIL_OUT (block), name);\n \n   pre_stats.insertions++;\n   if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\t\t\t\t    \n+    {\n       fprintf (dump_file, \"Inserted \");\n       print_generic_expr (dump_file, newexpr, 0);\n       fprintf (dump_file, \" in predecessor %d\\n\", block->index);\n@@ -2476,7 +2476,7 @@ insert_into_preds_of_block (basic_block block, value_set_node_t node,\n   edge_iterator ei;\n   tree type = TREE_TYPE (avail[EDGE_PRED (block, 0)->src->index]);\n   tree temp;\n-  \n+\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"Found partial redundancy for expression \");\n@@ -2493,7 +2493,7 @@ insert_into_preds_of_block (basic_block block, value_set_node_t node,\n     {\n       bool firstinsideloop = false;\n       bool secondinsideloop = false;\n-      firstinsideloop = flow_bb_inside_loop_p (block->loop_father, \n+      firstinsideloop = flow_bb_inside_loop_p (block->loop_father,\n \t\t\t\t\t       EDGE_PRED (block, 0)->src);\n       secondinsideloop = flow_bb_inside_loop_p (block->loop_father,\n \t\t\t\t\t\tEDGE_PRED (block, 1)->src);\n@@ -2505,7 +2505,7 @@ insert_into_preds_of_block (basic_block block, value_set_node_t node,\n \t  nophi = true;\n \t}\n     }\n-\t  \n+\n \n   /* Make the necessary insertions.  */\n   FOR_EACH_EDGE (pred, ei, block->preds)\n@@ -2521,7 +2521,7 @@ insert_into_preds_of_block (basic_block block, value_set_node_t node,\n \t  tree vh;\n \n \t  /* eprime may be an invariant.  */\n-\t  vh = TREE_CODE (eprime) == VALUE_HANDLE \n+\t  vh = TREE_CODE (eprime) == VALUE_HANDLE\n \t    ? eprime\n \t    : get_value_handle (eprime);\n \n@@ -2546,7 +2546,7 @@ insert_into_preds_of_block (basic_block block, value_set_node_t node,\n \t  bsi_insert_on_edge (pred, stmts);\n \t  avail[bprime->index] = builtexpr;\n \t  insertions = true;\n-\t}\t\t\t      \n+\t}\n     }\n   /* If we didn't want a phi node, and we made insertions, we still have\n      inserted new stuff, and thus return true.  If we didn't want a phi node,\n@@ -2571,34 +2571,34 @@ insert_into_preds_of_block (basic_block block, value_set_node_t node,\n     DECL_COMPLEX_GIMPLE_REG_P (temp) = 1;\n   temp = create_phi_node (temp, block);\n \n-  NECESSARY (temp) = 0; \n+  NECESSARY (temp) = 0;\n   VEC_safe_push (tree, heap, inserted_exprs, temp);\n   FOR_EACH_EDGE (pred, ei, block->preds)\n     add_phi_arg (temp, avail[pred->src->index], pred);\n-  \n+\n   vn_add (PHI_RESULT (temp), val);\n-  \n+\n   /* The value should *not* exist in PHI_GEN, or else we wouldn't be doing\n      this insertion, since we test for the existence of this value in PHI_GEN\n      before proceeding with the partial redundancy checks in insert_aux.\n-     \n+\n      The value may exist in AVAIL_OUT, in particular, it could be represented\n      by the expression we are trying to eliminate, in which case we want the\n      replacement to occur.  If it's not existing in AVAIL_OUT, we want it\n      inserted there.\n-     \n+\n      Similarly, to the PHI_GEN case, the value should not exist in NEW_SETS of\n      this block, because if it did, it would have existed in our dominator's\n      AVAIL_OUT, and would have been skipped due to the full redundancy check.\n   */\n \n   bitmap_insert_into_set (PHI_GEN (block),\n \t\t\t  PHI_RESULT (temp));\n-  bitmap_value_replace_in_set (AVAIL_OUT (block), \n+  bitmap_value_replace_in_set (AVAIL_OUT (block),\n \t\t\t       PHI_RESULT (temp));\n   bitmap_insert_into_set (NEW_SETS (block),\n \t\t\t  PHI_RESULT (temp));\n-  \n+\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"Created phi \");\n@@ -2610,18 +2610,18 @@ insert_into_preds_of_block (basic_block block, value_set_node_t node,\n }\n \n \n-      \n+\n /* Perform insertion of partially redundant values.\n    For BLOCK, do the following:\n    1.  Propagate the NEW_SETS of the dominator into the current block.\n-   If the block has multiple predecessors, \n+   If the block has multiple predecessors,\n        2a. Iterate over the ANTIC expressions for the block to see if\n            any of them are partially redundant.\n        2b. If so, insert them into the necessary predecessors to make\n            the expression fully redundant.\n        2c. Insert a new PHI merging the values of the predecessors.\n        2d. Insert the new PHI, and the new expressions, into the\n-           NEW_SETS set.  \n+           NEW_SETS set.\n    3. Recursively call ourselves on the dominator children of BLOCK.\n \n */\n@@ -2676,14 +2676,14 @@ insert_aux (basic_block block)\n \n \t\t      val = get_value_handle (node->expr);\n \t\t      if (bitmap_set_contains_value (PHI_GEN (block), val))\n-\t\t\tcontinue; \n+\t\t\tcontinue;\n \t\t      if (bitmap_set_contains_value (AVAIL_OUT (dom), val))\n \t\t\t{\n \t\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t\t    fprintf (dump_file, \"Found fully redundant value\\n\");\n \t\t\t  continue;\n \t\t\t}\n-\t\t\t\t\t      \n+\n \t\t      avail = XCNEWVEC (tree, last_basic_block);\n \t\t      FOR_EACH_EDGE (pred, ei, block->preds)\n \t\t\t{\n@@ -2731,7 +2731,7 @@ insert_aux (basic_block block)\n \t\t\t  else\n \t\t\t    {\n \t\t\t      avail[bprime->index] = edoubleprime;\n-\t\t\t      by_some = true; \n+\t\t\t      by_some = true;\n \t\t\t      if (first_s == NULL)\n \t\t\t\tfirst_s = edoubleprime;\n \t\t\t      else if (!operand_equal_p (first_s, edoubleprime,\n@@ -2751,7 +2751,7 @@ insert_aux (basic_block block)\n \t\t      /* If all edges produce the same value and that value is\n \t\t\t an invariant, then the PHI has the same value on all\n \t\t\t edges.  Note this.  */\n-\t\t      else if (!cant_insert && all_same && eprime \n+\t\t      else if (!cant_insert && all_same && eprime\n \t\t\t       && is_gimple_min_invariant (eprime)\n \t\t\t       && !is_gimple_min_invariant (val))\n \t\t\t{\n@@ -2761,7 +2761,7 @@ insert_aux (basic_block block)\n \t\t\t  for (node = exprset->head; node; node = node->next)\n  \t\t\t    {\n \t\t\t      if (TREE_CODE (node->expr) == SSA_NAME)\n-\t\t\t\t{\t\t\t\t  \n+\t\t\t\t{\n \t\t\t\t  vn_add (node->expr, eprime);\n \t\t\t\t  pre_stats.constified++;\n \t\t\t\t}\n@@ -2791,10 +2791,10 @@ insert (void)\n   bool new_stuff = true;\n   basic_block bb;\n   int num_iterations = 0;\n-  \n+\n   FOR_ALL_BB (bb)\n     NEW_SETS (bb) = bitmap_set_new ();\n-  \n+\n   while (new_stuff)\n     {\n       num_iterations++;\n@@ -2882,15 +2882,15 @@ create_value_expr_from (tree expr, basic_block block, tree stmt)\n       gcc_assert (code == TREE_LIST);\n       pool = list_node_pool;\n     }\n-  else \n+  else\n     {\n       gcc_assert (code == CALL_EXPR);\n       pool = expression_node_pool;\n     }\n \n   vexpr = (tree) pool_alloc (pool);\n   memcpy (vexpr, expr, tree_size (expr));\n-  \n+\n   /* This case is only for TREE_LIST's that appear as part of\n      CALL_EXPR's.  Anything else is a bug, but we can't easily verify\n      this, hence this comment.  TREE_LIST is not handled by the\n@@ -2903,9 +2903,9 @@ create_value_expr_from (tree expr, basic_block block, tree stmt)\n       tree op = NULL_TREE;\n       tree temp = NULL_TREE;\n       if (TREE_CHAIN (vexpr))\n-\ttemp = create_value_expr_from (TREE_CHAIN (vexpr), block, stmt);      \n+\ttemp = create_value_expr_from (TREE_CHAIN (vexpr), block, stmt);\n       TREE_CHAIN (vexpr) = temp ? temp : TREE_CHAIN (vexpr);\n-      \n+\n \n       /* Recursively value-numberize reference ops.  */\n       if (REFERENCE_CLASS_P (TREE_VALUE (vexpr)))\n@@ -2914,7 +2914,7 @@ create_value_expr_from (tree expr, basic_block block, tree stmt)\n \t  op = TREE_VALUE (vexpr);\n \t  tempop = create_value_expr_from (op, block, stmt);\n \t  op = tempop ? tempop : op;\n-\t  \n+\n \t  TREE_VALUE (vexpr)  = vn_lookup_or_add (op, stmt);\n \t}\n       else\n@@ -2933,7 +2933,7 @@ create_value_expr_from (tree expr, basic_block block, tree stmt)\n   for (i = 0; i < TREE_CODE_LENGTH (code); i++)\n     {\n       tree val, op;\n-      \n+\n       op = TREE_OPERAND (expr, i);\n       if (op == NULL_TREE)\n \tcontinue;\n@@ -2948,18 +2948,18 @@ create_value_expr_from (tree expr, basic_block block, tree stmt)\n       else if (TREE_CODE (op) == TREE_LIST)\n \t{\n \t  tree tempop;\n-\t  \n+\n \t  gcc_assert (TREE_CODE (expr) == CALL_EXPR);\n \t  tempop = create_value_expr_from (op, block, stmt);\n-\t  \n+\n \t  op = tempop ? tempop : op;\n \t  vn_lookup_or_add (op, NULL);\n \t  /* Unlike everywhere else, we do *not* want to replace the\n \t     TREE_LIST itself with a value number, because support\n \t     functions we call will blow up.  */\n \t  val = op;\n \t}\n-      else       \n+      else\n \t/* Create a value handle for OP and add it to VEXPR.  */\n \tval = vn_lookup_or_add (op, NULL);\n \n@@ -2984,7 +2984,7 @@ create_value_expr_from (tree expr, basic_block block, tree stmt)\n static void\n insert_extra_phis (basic_block block, basic_block dom)\n {\n-  \n+\n   if (!single_pred_p (block))\n     {\n       edge e;\n@@ -3032,7 +3032,7 @@ insert_extra_phis (basic_block block, basic_block dom)\n \t\t  get_var_ann (mergephitemp);\n \t\t}\n \t      temp = mergephitemp;\n-\t\t  \n+\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t{\n \t\t  fprintf (dump_file, \"Creating phi \");\n@@ -3042,13 +3042,13 @@ insert_extra_phis (basic_block block, basic_block dom)\n \n \t      add_referenced_var (temp);\n \t      temp = create_phi_node (temp, block);\n-\t      NECESSARY (temp) = 0; \n+\t      NECESSARY (temp) = 0;\n \t      VEC_safe_push (tree, heap, inserted_exprs, temp);\n \n \t      FOR_EACH_EDGE (e, ei, block->preds)\n \t\t{\n \t\t  tree leader = bitmap_find_leader (AVAIL_OUT (e->src), val);\n-\t\t  \n+\n \t\t  gcc_assert (leader);\n \t\t  add_phi_arg (temp, leader, e);\n \n@@ -3060,7 +3060,7 @@ insert_extra_phis (basic_block block, basic_block dom)\n \t\t}\n \n \t      vn_add (PHI_RESULT (temp), val);\n-\t      \n+\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\tfprintf (dump_file, \"\\n\");\n \t    }\n@@ -3125,7 +3125,7 @@ try_look_through_load (tree lhs, tree mem_ref, tree stmt, basic_block block)\n       || TREE_CODE (rhs) == ADDR_EXPR\n       || TREE_INVARIANT (rhs))\n     {\n-      \n+\n       /* Yay!  Compute a value number for the RHS of the statement and\n  \t add its value to the AVAIL_OUT set for the block.  Add the LHS\n \t to TMP_GEN.  */\n@@ -3290,7 +3290,7 @@ realify_fake_stores (void)\n \t  /* Mark the temp variable as referenced */\n \t  add_referenced_var (SSA_NAME_VAR (TREE_OPERAND (stmt, 0)));\n \n-\t  /* Put the new statement in GC memory, fix up the \n+\t  /* Put the new statement in GC memory, fix up the\n \t     SSA_NAME_DEF_STMT on it, and then put it in place of\n \t     the old statement before the store in the IR stream\n \t     as a plain ssa name copy.  */\n@@ -3357,7 +3357,7 @@ try_combine_conversion (tree *expr_p)\n    block.  The AVAIL sets are built from information we glean while doing\n    this value numbering, since the AVAIL sets contain only one entry per\n    value.\n-   \n+\n    AVAIL_IN[BLOCK] = AVAIL_OUT[dom(BLOCK)].\n    AVAIL_OUT[BLOCK] = AVAIL_IN[BLOCK] U PHI_GEN[BLOCK] U TMP_GEN[BLOCK].  */\n \n@@ -3444,7 +3444,7 @@ compute_avail (void)\n \n \t  stmt = bsi_stmt (bsi);\n \t  ann = stmt_ann (stmt);\n-\t  \n+\n \t  ann->uid = stmt_uid++;\n \n \t  /* For regular value numbering, we are only interested in\n@@ -3500,14 +3500,14 @@ compute_avail (void)\n \t\t  /* Compute a value number for the RHS of the statement\n \t\t     and add its value to the AVAIL_OUT set for the block.\n \t\t     Add the LHS to TMP_GEN.  */\n-\t\t  add_to_sets (lhs, rhs, stmt, TMP_GEN (block), \n+\t\t  add_to_sets (lhs, rhs, stmt, TMP_GEN (block),\n \t\t\t       AVAIL_OUT (block));\n-\t\t  \n+\n \t\t  if (TREE_CODE (rhs) == SSA_NAME\n \t\t      && !is_undefined_value (rhs))\n \t\t    value_insert_into_set (EXP_GEN (block), rhs);\n \t\t  continue;\n-\t\t}\t   \n+\t\t}\n \t    }\n \n \t  /* For any other statement that we don't recognize, simply\n@@ -3542,7 +3542,7 @@ eliminate (void)\n   FOR_EACH_BB (b)\n     {\n       block_stmt_iterator i;\n-      \n+\n       for (i = bsi_start (b); !bsi_end_p (i); bsi_next (&i))\n         {\n           tree stmt = bsi_stmt (i);\n@@ -3562,7 +3562,7 @@ eliminate (void)\n \n \t      sprime = bitmap_find_leader (AVAIL_OUT (b),\n \t\t\t\t\t   vn_lookup (lhs, NULL));\n-\t      if (sprime \n+\t      if (sprime\n \t\t  && sprime != lhs\n \t\t  && (TREE_CODE (*rhs_p) != SSA_NAME\n \t\t      || may_propagate_copy (*rhs_p, sprime)))\n@@ -3578,8 +3578,8 @@ eliminate (void)\n \t\t      fprintf (dump_file, \" in \");\n \t\t      print_generic_stmt (dump_file, stmt, 0);\n \t\t    }\n-\t\t  \n-\t\t  if (TREE_CODE (sprime) == SSA_NAME) \n+\n+\t\t  if (TREE_CODE (sprime) == SSA_NAME)\n \t\t    NECESSARY (SSA_NAME_DEF_STMT (sprime)) = 1;\n \t\t  /* We need to make sure the new and old types actually match,\n \t\t     which may require adding a simple cast, which fold_convert\n@@ -3588,7 +3588,7 @@ eliminate (void)\n \t\t      && !tree_ssa_useless_type_conversion_1 (TREE_TYPE (*rhs_p),\n \t\t\t\t\t\t\t      TREE_TYPE (sprime)))\n \t\t    sprime = fold_convert (TREE_TYPE (*rhs_p), sprime);\n-\t\t  \n+\n \t\t  pre_stats.eliminations++;\n \t\t  propagate_tree_value (rhs_p, sprime);\n \t\t  update_stmt (stmt);\n@@ -3614,7 +3614,7 @@ eliminate (void)\n \n /* If OP's defining statement has not already been determined to be necessary,\n    mark that statement necessary. Return the stmt, if it is newly\n-   necessary.  */ \n+   necessary.  */\n \n static inline tree\n mark_operand_necessary (tree op)\n@@ -3681,14 +3681,14 @@ remove_dead_inserted_code (void)\n       else\n \t{\n \t  /* Propagate through the operands.  Examine all the USE, VUSE and\n-\t     V_MAY_DEF operands in this statement.  Mark all the statements \n+\t     V_MAY_DEF operands in this statement.  Mark all the statements\n \t     which feed this statement's uses as necessary.  */\n \t  ssa_op_iter iter;\n \t  tree use;\n \n \t  /* The operands of V_MAY_DEF expressions are also needed as they\n \t     represent potential definitions that may reach this\n-\t     statement (V_MAY_DEF operands allow us to follow def-def \n+\t     statement (V_MAY_DEF operands allow us to follow def-def\n \t     links).  */\n \n \t  FOR_EACH_SSA_TREE_OPERAND (use, t, iter, SSA_OP_ALL_USES)\n@@ -3733,7 +3733,7 @@ static void\n init_pre (bool do_fre)\n {\n   basic_block bb;\n-  \n+\n   in_fre = do_fre;\n \n   inserted_exprs = NULL;\n@@ -3784,7 +3784,7 @@ init_pre (bool do_fre)\n   expression_node_pool = create_alloc_pool (\"Expression tree nodes\",\n \t\t\t\t\t    tree_code_size (CALL_EXPR), 30);\n   list_node_pool = create_alloc_pool (\"List tree nodes\",\n-\t\t\t\t      tree_code_size (TREE_LIST), 30);  \n+\t\t\t\t      tree_code_size (TREE_LIST), 30);\n   comparison_node_pool = create_alloc_pool (\"Comparison tree nodes\",\n       \t\t\t\t\t    tree_code_size (EQ_EXPR), 30);\n   modify_expr_node_pool = create_alloc_pool (\"MODIFY_EXPR nodes\",\n@@ -3886,9 +3886,9 @@ execute_pre (bool do_fre)\n       FOR_ALL_BB (bb)\n \t{\n \t  print_value_set (dump_file, EXP_GEN (bb), \"exp_gen\", bb->index);\n-\t  bitmap_print_value_set (dump_file, TMP_GEN (bb), \"tmp_gen\", \n+\t  bitmap_print_value_set (dump_file, TMP_GEN (bb), \"tmp_gen\",\n \t\t\t\t  bb->index);\n-\t  bitmap_print_value_set (dump_file, AVAIL_OUT (bb), \"avail_out\", \n+\t  bitmap_print_value_set (dump_file, AVAIL_OUT (bb), \"avail_out\",\n \t\t\t\t  bb->index);\n \t}\n     }\n@@ -3918,7 +3918,7 @@ execute_pre (bool do_fre)\n       fprintf (dump_file, \"Eliminated: %d\\n\", pre_stats.eliminations);\n       fprintf (dump_file, \"Constified: %d\\n\", pre_stats.constified);\n     }\n-  \n+\n   bsi_commit_edge_inserts ();\n \n   if (!do_fre)\n@@ -3960,7 +3960,7 @@ struct tree_opt_pass pass_pre =\n   0,\t\t\t\t\t/* properties_provided */\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_update_ssa_only_virtuals | TODO_dump_func | TODO_ggc_collect \n+  TODO_update_ssa_only_virtuals | TODO_dump_func | TODO_ggc_collect\n   | TODO_verify_ssa, /* todo_flags_finish */\n   0\t\t\t\t\t/* letter */\n };\n@@ -3997,4 +3997,3 @@ struct tree_opt_pass pass_fre =\n   TODO_dump_func | TODO_ggc_collect | TODO_verify_ssa, /* todo_flags_finish */\n   0\t\t\t\t\t/* letter */\n };\n-"}]}