{"sha": "b2932ae5b8737d612d2368882be71d91d8bacf59", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjI5MzJhZTViODczN2Q2MTJkMjM2ODg4MmJlNzFkOTFkOGJhY2Y1OQ==", "commit": {"author": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1996-12-10T02:18:38Z"}, "committer": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1996-12-10T02:18:38Z"}, "message": "x\n\nFrom-SVN: r13259", "tree": {"sha": "9296ca858c847fe69d5ac58772e4415f67d9ffe4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9296ca858c847fe69d5ac58772e4415f67d9ffe4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b2932ae5b8737d612d2368882be71d91d8bacf59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2932ae5b8737d612d2368882be71d91d8bacf59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2932ae5b8737d612d2368882be71d91d8bacf59", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2932ae5b8737d612d2368882be71d91d8bacf59/comments", "author": null, "committer": null, "parents": [{"sha": "a94dbf2c2628c83773a1eb6c9ced1a49a3a5f45e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a94dbf2c2628c83773a1eb6c9ced1a49a3a5f45e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a94dbf2c2628c83773a1eb6c9ced1a49a3a5f45e"}], "stats": {"total": 116, "additions": 59, "deletions": 57}, "files": [{"sha": "dd8276ce379fda04e06f30257e908fbce65241cc", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 59, "deletions": 57, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2932ae5b8737d612d2368882be71d91d8bacf59/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2932ae5b8737d612d2368882be71d91d8bacf59/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=b2932ae5b8737d612d2368882be71d91d8bacf59", "patch": "@@ -3151,6 +3151,7 @@ static void\n output_uleb128 (value)\n      register unsigned long value;\n {\n+  unsigned long save_value = value;\n   fprintf (asm_out_file, \"\\t%s\\t\", ASM_BYTE_OP);\n   do\n     {\n@@ -3168,6 +3169,8 @@ output_uleb128 (value)\n \t}\n     }\n   while (value != 0);\n+  if (flag_verbose_asm)\n+    fprintf (asm_out_file, \"\\t%s ULEB128 0x%x\", ASM_COMMENT_START, save_value);\n }\n \n /* Output an signed LEB128 quantity.  */\n@@ -3177,6 +3180,7 @@ output_sleb128 (value)\n {\n   register int more;\n   register unsigned byte;\n+  long save_value = value;\n   fprintf (asm_out_file, \"\\t%s\\t\", ASM_BYTE_OP);\n   do\n     {\n@@ -3196,6 +3200,8 @@ output_sleb128 (value)\n \t}\n     }\n   while (more);\n+  if (flag_verbose_asm)\n+    fprintf (asm_out_file, \"\\t%s SLEB128 %d\", ASM_COMMENT_START, save_value);\n }\n \n /* Select the encoding of an attribute value.  */\n@@ -3258,10 +3264,7 @@ output_value_format (v)\n   enum dwarf_form form = value_format (v);\n   output_uleb128 (form);\n   if (flag_verbose_asm)\n-    {\n-      fprintf (asm_out_file, \"\\t%s %s\",\n-\t       ASM_COMMENT_START, dwarf_form_name (form));\n-    }\n+    fprintf (asm_out_file, \" (%s)\", dwarf_form_name (form));\n   fputc ('\\n', asm_out_file);\n }\n \n@@ -3277,17 +3280,12 @@ output_abbrev_section ()\n       register dw_die_ref abbrev = abbrev_die_table[abbrev_id];\n       output_uleb128 (abbrev_id);\n       if (flag_verbose_asm)\n-\t{\n-\t  fprintf (asm_out_file, \"\\t%s abbrev code = %u\",\n-\t\t   ASM_COMMENT_START, abbrev_id);\n-\t}\n+\tfprintf (asm_out_file, \" (abbrev code)\");\n       fputc ('\\n', asm_out_file);\n       output_uleb128 (abbrev->die_tag);\n       if (flag_verbose_asm)\n-\t{\n-\t  fprintf (asm_out_file, \"\\t%s TAG: %s\",\n-\t\t   ASM_COMMENT_START, dwarf_tag_name (abbrev->die_tag));\n-\t}\n+\tfprintf (asm_out_file, \" (TAG: %s)\",\n+\t\t dwarf_tag_name (abbrev->die_tag));\n       fputc ('\\n', asm_out_file);\n       fprintf (asm_out_file, \"\\t%s\\t0x%x\", ASM_BYTE_OP,\n \t       (abbrev->die_child != NULL)\n@@ -3305,11 +3303,8 @@ output_abbrev_section ()\n \t{\n \t  output_uleb128 (a_attr->dw_attr);\n \t  if (flag_verbose_asm)\n-\t    {\n-\t      fprintf (asm_out_file, \"\\t%s %s\",\n-\t\t       ASM_COMMENT_START,\n-\t\t       dwarf_attr_name (a_attr->dw_attr));\n-\t    }\n+\t    fprintf (asm_out_file, \" (%s)\",\n+\t\t     dwarf_attr_name (a_attr->dw_attr));\n \t  fputc ('\\n', asm_out_file);\n \t  output_value_format (&a_attr->dw_attr_val);\n \t}\n@@ -3357,7 +3352,7 @@ output_loc_operands (loc)\n       fputc ('\\n', asm_out_file);\n       break;\n     case DW_OP_consts:\n-      output_sleb128 (val1->v.val_unsigned);\n+      output_sleb128 (val1->v.val_int);\n       fputc ('\\n', asm_out_file);\n       break;\n     case DW_OP_pick:\n@@ -3413,13 +3408,13 @@ output_loc_operands (loc)\n       fputc ('\\n', asm_out_file);\n       break;\n     case DW_OP_fbreg:\n-      output_sleb128 (val1->v.val_unsigned);\n+      output_sleb128 (val1->v.val_int);\n       fputc ('\\n', asm_out_file);\n       break;\n     case DW_OP_bregx:\n       output_uleb128 (val1->v.val_unsigned);\n       fputc ('\\n', asm_out_file);\n-      output_sleb128 (val2->v.val_unsigned);\n+      output_sleb128 (val2->v.val_int);\n       fputc ('\\n', asm_out_file);\n       break;\n     case DW_OP_piece:\n@@ -3466,12 +3461,8 @@ output_die (die)\n   register dw_loc_descr_ref loc;\n   output_uleb128 (die->die_abbrev);\n   if (flag_verbose_asm)\n-    {\n-      fprintf (asm_out_file, \"\\t%s DIE (0x%x) %s\",\n-\t       ASM_COMMENT_START,\n-\t       die->die_offset,\n-\t       dwarf_tag_name (die->die_tag));\n-    }\n+    fprintf (asm_out_file, \" (DIE (0x%x) %s)\",\n+\t     die->die_offset, dwarf_tag_name (die->die_tag));\n   fputc ('\\n', asm_out_file);\n   for (a = die->die_attr; a != NULL; a = a->dw_attr_next)\n     {\n@@ -3598,6 +3589,9 @@ output_die (die)\n     {\n       /* Add null byte to terminate sibling list. */\n       ASM_OUTPUT_DWARF_DATA1 (asm_out_file, 0);\n+      if (flag_verbose_asm)\n+\tfprintf (asm_out_file, \"\\t%s end of children of DIE 0x%x\",\n+\t\t ASM_COMMENT_START, die->die_offset);\n       fputc ('\\n', asm_out_file);\n     }\n }\n@@ -4073,9 +4067,19 @@ output_call_frame_info ()\n   register dw_cfi_ref cfi;\n   unsigned long fde_pad;\n \n+  /* Only output the info if it will be interesting.  */\n+  for (i = 0; i < fde_table_in_use; ++i)\n+    if (fde_table[i].dw_fde_cfi != NULL)\n+      break;\n+  if (i == fde_table_in_use)\n+    return;\n+\n   /* (re-)initialize the beginning FDE offset.  */\n   next_fde_offset = DWARF_ROUND (cie_size, PTR_SIZE);\n \n+  fputc ('\\n', asm_out_file);\n+  ASM_OUTPUT_SECTION (asm_out_file, FRAME_SECTION);\n+\n   /* Output the CIE. */\n   ASM_OUTPUT_DWARF_DATA (asm_out_file, next_fde_offset - DWARF_OFFSET_SIZE);\n   if (flag_verbose_asm)\n@@ -4112,17 +4116,11 @@ output_call_frame_info ()\n   fputc ('\\n', asm_out_file);\n   output_uleb128 (1);\n   if (flag_verbose_asm)\n-    {\n-      fprintf (asm_out_file, \"\\t%s CIE Code Alignment Factor\",\n-\t       ASM_COMMENT_START);\n-    }\n+    fprintf (asm_out_file, \" (CIE Code Alignment Factor)\");\n   fputc ('\\n', asm_out_file);\n   output_sleb128 (DWARF_CIE_DATA_ALIGNMENT);\n   if (flag_verbose_asm)\n-    {\n-      fprintf (asm_out_file, \"\\t%s CIE Data Alignment Factor\",\n-\t       ASM_COMMENT_START);\n-    }\n+    fprintf (asm_out_file, \" (CIE Data Alignment Factor)\");\n   fputc ('\\n', asm_out_file);\n   ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DWARF_FRAME_RETURN_COLUMN);\n   if (flag_verbose_asm)\n@@ -4152,6 +4150,8 @@ output_call_frame_info ()\n   for (i = 0; i < fde_table_in_use; ++i)\n     {\n       fde = &fde_table[i];\n+      if (fde->dw_fde_cfi == NULL)\n+\tcontinue;\n       fde_size = size_of_fde (fde, &fde_pad);\n       ASM_OUTPUT_DWARF_DATA (asm_out_file, fde_size - DWARF_OFFSET_SIZE);\n       if (flag_verbose_asm)\n@@ -4576,10 +4576,7 @@ output_line_info ()\n \t  fputc ('\\n', asm_out_file);\n \t  output_uleb128 (current_file);\n \t  if (flag_verbose_asm)\n-\t    {\n-\t      fprintf (asm_out_file, \"\\t%s \\\"%s\\\"\",\n-\t\t       ASM_COMMENT_START, file_table[current_file]);\n-\t    }\n+\t    fprintf (asm_out_file, \" (\\\"%s\\\")\", file_table[current_file]);\n \t  fputc ('\\n', asm_out_file);\n \t}\n       line_offset = line_info->dw_line_num - current_line;\n@@ -4683,10 +4680,7 @@ output_line_info ()\n \t  fputc ('\\n', asm_out_file);\n \t  output_uleb128 (current_file);\n \t  if (flag_verbose_asm)\n-\t    {\n-\t      fprintf (asm_out_file, \"\\t%s \\\"%s\\\"\",\n-\t\t       ASM_COMMENT_START, file_table[current_file]);\n-\t    }\n+\t    fprintf (asm_out_file, \" (\\\"%s\\\")\", file_table[current_file]);\n \t  fputc ('\\n', asm_out_file);\n \t}\n       if (line_info->dw_line_num != current_line)\n@@ -5921,13 +5915,13 @@ add_byte_size_attribute (die, tree_node)\n    \"containing object\" for the bit-field to the highest order bit of the\n    bit-field itself.\n \n-   For any given bit-field, the \"containing object\" is a hypothetical object (of\n-   some integral or enum type) within which the given bit-field lives.  The\n-   type of this hypothetical \"containing object\" is always the same as the\n-   declared type of the individual bit-field itself.\n-   The determination of the exact location of the \"containing object\" for a\n-   bit-field is rather complicated.  It's handled by the `field_byte_offset'\n-   function (above).\n+   For any given bit-field, the \"containing object\" is a hypothetical\n+   object (of some integral or enum type) within which the given bit-field\n+   lives.  The type of this hypothetical \"containing object\" is always the\n+   same as the declared type of the individual bit-field itself.  The\n+   determination of the exact location of the \"containing object\" for a\n+   bit-field is rather complicated.  It's handled by the\n+   `field_byte_offset' function (above).\n \n    Note that it is the size (in bytes) of the hypothetical \"containing object\"\n    which will be given in the DW_AT_byte_size attribute for this bit-field.\n@@ -6047,6 +6041,17 @@ add_pure_or_virtual_attribute (die, func_decl)\n \f\n /********************* utility routines for DIEs *************************/\n \n+/* Add source coordinate attributes for the given decl.  */\n+static void\n+add_src_coords_attributes (die, decl)\n+     register dw_die_ref die;\n+     register tree decl;\n+{\n+  register unsigned file_index = lookup_filename (DECL_SOURCE_FILE (decl));\n+  add_AT_unsigned (die, DW_AT_decl_file, file_index);\n+  add_AT_unsigned (die, DW_AT_decl_line, DECL_SOURCE_LINE (decl));\n+}\n+\n /* Add an DW_AT_name attribute and source coordinate attribute for the\n    given decl, but only if it actually has a name.  */\n static void\n@@ -6055,7 +6060,6 @@ add_name_and_src_coords_attributes (die, decl)\n      register tree decl;\n {\n   register tree decl_name;\n-  register unsigned file_index;\n   if (TREE_CODE (decl) == FUNCTION_DECL || TREE_CODE (decl) == VAR_DECL)\n     decl_name = DECL_ASSEMBLER_NAME (decl);\n   else\n@@ -6064,9 +6068,7 @@ add_name_and_src_coords_attributes (die, decl)\n   if (decl_name && IDENTIFIER_POINTER (decl_name))\n     {\n       add_name_attribute (die, IDENTIFIER_POINTER (decl_name));\n-      file_index = lookup_filename (DECL_SOURCE_FILE (decl));\n-      add_AT_unsigned (die, DW_AT_decl_file, file_index);\n-      add_AT_unsigned (die, DW_AT_decl_line, DECL_SOURCE_LINE (decl));\n+      add_src_coords_attributes (die, decl);\n     }\n }\n \n@@ -6448,6 +6450,8 @@ gen_enumeration_type_die (type, context_die)\n       register tree link;\n       TREE_ASM_WRITTEN (type) = 1;\n       add_byte_size_attribute (type_die, type);\n+      if (type_tag (type))\n+\tadd_src_coords_attributes (type_die, TYPE_STUB_DECL (type));\n       for (link = TYPE_FIELDS (type);\n \t   link != NULL; link = TREE_CHAIN (link))\n \t{\n@@ -7263,6 +7267,8 @@ gen_struct_or_union_type_die (type, context_die)\n          this type is expressed in terms of this type itself.  */\n       TREE_ASM_WRITTEN (type) = 1;\n       add_byte_size_attribute (type_die, type);\n+      if (type_tag (type))\n+\tadd_src_coords_attributes (type_die, TYPE_STUB_DECL (type));\n       push_decl_scope (type);\n       gen_member_die (type, type_die);\n       pop_decl_scope ();\n@@ -8411,12 +8417,8 @@ dwarf2out_finish ()\n \n   if (fde_table_in_use)\n     {\n-#ifdef MIPS_DEBUGGING_INFO /* Not currently useful otherwise.  */\n       /* Output call frame information.  */\n-      fputc ('\\n', asm_out_file);\n-      ASM_OUTPUT_SECTION (asm_out_file, FRAME_SECTION);\n       output_call_frame_info ();\n-#endif\n \n       /* Output the address range information.  */\n       fputc ('\\n', asm_out_file);"}]}