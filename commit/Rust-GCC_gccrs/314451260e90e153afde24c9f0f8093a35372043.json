{"sha": "314451260e90e153afde24c9f0f8093a35372043", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzE0NDUxMjYwZTkwZTE1M2FmZGUyNGM5ZjBmODA5M2EzNTM3MjA0Mw==", "commit": {"author": {"name": "Michael Hayes", "email": "m.hayes@elec.canterbury.ac.nz", "date": "1999-06-09T03:47:24Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "1999-06-09T03:47:24Z"}, "message": "c4x.h (TARGET_EXPOSE_LDP, [...]): Define new macros.\n\n\t* config/c4x/c4x.h (TARGET_EXPOSE_LDP, LEGITIMIZE_RELOAD_ADDRESS):\n\tDefine new macros.\n\t* config/c4x/c4x.c (c4x_emit_move_sequence, src_operand): Use\n\tTARGET_EXPOSE_LDP.\n\t(c4x_legitimize_reload_address): New function.\n\t* config/c4x/c4x.md: Update docs.\n\nFrom-SVN: r27443", "tree": {"sha": "6354e1745cf712a04af20632a0b77a905306c106", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6354e1745cf712a04af20632a0b77a905306c106"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/314451260e90e153afde24c9f0f8093a35372043", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/314451260e90e153afde24c9f0f8093a35372043", "html_url": "https://github.com/Rust-GCC/gccrs/commit/314451260e90e153afde24c9f0f8093a35372043", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/314451260e90e153afde24c9f0f8093a35372043/comments", "author": null, "committer": null, "parents": [{"sha": "babb4c65be476a56f6755d76b52d5c471ccd7343", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/babb4c65be476a56f6755d76b52d5c471ccd7343", "html_url": "https://github.com/Rust-GCC/gccrs/commit/babb4c65be476a56f6755d76b52d5c471ccd7343"}], "stats": {"total": 97, "additions": 81, "deletions": 16}, "files": [{"sha": "dc83be10b04f1002328893da25dcb6cf99e49294", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/314451260e90e153afde24c9f0f8093a35372043/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/314451260e90e153afde24c9f0f8093a35372043/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=314451260e90e153afde24c9f0f8093a35372043", "patch": "@@ -1,3 +1,12 @@\n+Wed Jun  9 22:34:38 1999  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n+\n+\t* config/c4x/c4x.h (TARGET_EXPOSE_LDP, LEGITIMIZE_RELOAD_ADDRESS):\n+\tDefine new macros. \n+\t* config/c4x/c4x.c (c4x_emit_move_sequence, src_operand): Use\n+\tTARGET_EXPOSE_LDP.\n+\t(c4x_legitimize_reload_address): New function.\n+\t* config/c4x/c4x.md: Update docs.\n+\n Wed Jun  9 04:14:48 1999  Jeffrey A Law  (law@cygnus.com)\n \n \t* fixincludes: Avoid removing '.'."}, {"sha": "23f8bfa093f57e2afa5d1f025eb59f0e9fd1ef7a", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 43, "deletions": 9, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/314451260e90e153afde24c9f0f8093a35372043/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/314451260e90e153afde24c9f0f8093a35372043/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=314451260e90e153afde24c9f0f8093a35372043", "patch": "@@ -1077,7 +1077,8 @@ c4x_emit_move_sequence (operands, mode)\n      and emit associated (HIGH (SYMREF)) if large memory model.  \n      c4x_legitimize_address could be used to do this,\n      perhaps by calling validize_address.  */\n-  if (! (reload_in_progress || reload_completed)\n+  if (TARGET_EXPOSE_LDP\n+      && ! (reload_in_progress || reload_completed)\n       && GET_CODE (op1) == MEM\n       && symbolic_address_operand (XEXP (op1, 0), Pmode))\n     {\n@@ -1088,7 +1089,8 @@ c4x_emit_move_sequence (operands, mode)\n \t\t\t    gen_rtx_LO_SUM (Pmode, dp_reg, XEXP (op1, 0)));\n     }\n \n-  if (! (reload_in_progress || reload_completed)\n+  if (TARGET_EXPOSE_LDP\n+      && ! (reload_in_progress || reload_completed)\n       && GET_CODE (op0) == MEM \n       && symbolic_address_operand (XEXP (op0, 0), Pmode))\n     {\n@@ -1409,12 +1411,14 @@ c4x_check_legit_addr (mode, addr, strict)\n       /* Direct addressing.  */\n     case LABEL_REF:\n     case SYMBOL_REF:\n+      if (! TARGET_EXPOSE_LDP && ! strict && mode != HFmode && mode != HImode)\n+\treturn 1;\n       /* These need to be converted to a LO_SUM (...). \n-\t c4x_legitimize_address will fix them up.  */\n+\t LEGITIMIZE_RELOAD_ADDRESS will do this during reload.  */\n       return 0;\n \n       /* Do not allow direct memory access to absolute addresses.\n-         This is more pain than its worth, especially for the\n+         This is more pain than it's worth, especially for the\n          small memory model where we can't guarantee that\n          this address is within the data page---we don't want\n          to modify the DP register in the small memory model,\n@@ -1515,6 +1519,32 @@ c4x_legitimize_address (orig, mode)\n }\n \n \n+rtx\n+c4x_legitimize_reload_address (orig, mode, insn)\n+     rtx orig ATTRIBUTE_UNUSED;\n+     enum machine_mode mode;\n+     rtx insn;\n+{                                                                    \t\n+  if (mode != HImode \n+      && mode != HFmode\n+      && GET_MODE (orig) != HImode\n+      && GET_MODE (orig) != HFmode\n+      && (GET_CODE (orig) == CONST\t\t\t\t\t\n+          || GET_CODE (orig) == SYMBOL_REF\t\t\t\t\n+          || GET_CODE (orig) == LABEL_REF))\n+    {                                                                   \n+      rtx dp_reg = gen_rtx_REG (Pmode, DP_REGNO);\t\t\t\n+      if (! TARGET_SMALL)\t\t\t\t\t\t\n+        emit_insn_before (gen_rtx_SET (VOIDmode, dp_reg, \t\t\n+\t\t\t\t       gen_rtx_HIGH (Pmode, orig)),\t\n+\t\t\t  insn);\n+      return gen_rtx_LO_SUM (Pmode, dp_reg, orig);\n+    }\n+\n+  return NULL_RTX;\n+}\n+\n+\n /* Provide the costs of an addressing mode that contains ADDR.\n    If ADDR is not a valid address, its cost is irrelevant.  \n    This is used in cse and loop optimisation to determine\n@@ -3002,20 +3032,24 @@ src_operand (op, mode)\n   if (GET_CODE (op) == CONST_DOUBLE)\n     return c4x_H_constant (op);\n \n-  /* Disallow symbolic addresses.  */\n+  /* Disallow symbolic addresses.  Only the predicate\n+     symbolic_address_operand will match these.  */\n   if (GET_CODE (op) == SYMBOL_REF\n       || GET_CODE (op) == LABEL_REF\n       || GET_CODE (op) == CONST)\n     return 0;\n \n-  /* Disallow direct memory access symbolic addresses. \n-     These are usually caught by the movqi expander and\n-     converted to a LO_SUM.  */\n+  /* If TARGET_EXPOSE_LDP is zero, allow direct memory access to\n+     symbolic addresses.  These will be rejected by\n+     GO_IF_LEGITIMATE_ADDRESS and fixed up by\n+     LEGITIMIZE_RELOAD_ADDRESS.  If TARGET_EXPOSE_LDP is nonzero,\n+     disallow direct memory access to symbolic addresses.  These\n+     should be converted to a HIGH/LO_SUM pair by the movqi expander.  */\n   if (GET_CODE (op) == MEM\n       && ((GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n \t   || GET_CODE (XEXP (op, 0)) == LABEL_REF\n \t   || GET_CODE (XEXP (op, 0)) == CONST)))\n-    return 0;\n+    return ! TARGET_EXPOSE_LDP;\n \n   return general_operand (op, mode);\n }"}, {"sha": "7ef0738f00841d2e856fb75197e94cd1d45a959d", "filename": "gcc/config/c4x/c4x.h", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/314451260e90e153afde24c9f0f8093a35372043/gcc%2Fconfig%2Fc4x%2Fc4x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/314451260e90e153afde24c9f0f8093a35372043/gcc%2Fconfig%2Fc4x%2Fc4x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.h?ref=314451260e90e153afde24c9f0f8093a35372043", "patch": "@@ -303,7 +303,9 @@ extern int target_flags;\n #define TARGET_C40\t\t(target_flags & C40_FLAG)\n #define TARGET_C44\t\t(target_flags & C44_FLAG)\n \n+/* Define some options to control code generation.  */\n #define TARGET_LOAD_ADDRESS\t(1 || (! TARGET_C3X && ! TARGET_SMALL))\n+#define TARGET_EXPOSE_LDP\t0\n \n /* -mrpts            allows the use of the RPTS instruction irregardless.\n    -mrpts=max-cycles will use RPTS if the number of cycles is constant\n@@ -1664,6 +1666,20 @@ extern struct rtx_def *c4x_legitimize_address ();\n   }\t\t\t\t\t\t\t\t\t\\\n }\n \n+extern struct rtx_def *c4x_legitimize_reload_address ();\n+#define LEGITIMIZE_RELOAD_ADDRESS(X,MODE,OPNUM,TYPE,IND_LEVELS,WIN)     \\\n+{\t\t\t\t\t\t\t\t\t\\\n+  rtx new;\t\t\t\t\t\t\t\t\\\n+  new = c4x_legitimize_reload_address (X, MODE, insn);\t\t\t\\\n+  if (new != NULL_RTX)\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    (X) = new;\t\t\t\t\t\t\t\t\\\n+   /* We do not have to call push_reload because we do not require      \\\n+      any more reloads.  */\t\t\t\t\t\t\\\n+    goto WIN;\t\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n \n /* No mode-dependent addresses on the C4x are autoincrements.  */\n \n@@ -1684,7 +1700,9 @@ extern struct rtx_def *c4x_legitimize_address ();\n    restricted subset of CONST_INT and CONST_DOUBLE.  Disallow\n    LABEL_REF and SYMBOL_REF (except on the C40 with the big memory\n    model) so that the symbols will be forced into the constant pool.\n-   On second thoughts, lets do this with the move expanders.\n+   On second thoughts, let's do this with the move expanders since\n+   the alias analysis has trouble if we force constant addresses\n+   into memory.\n */\n \n #define LEGITIMATE_CONSTANT_P(X)\t\t\t\t\\\n@@ -2078,7 +2096,7 @@ dtors_section ()\t\t\t\t\t\t\t\\\n     fprintf (FILE, \"\\n\");\t\t\t\t\t\\\n }\n \n-#define ASM_FILE_END(FILE)   fprintf (FILE, \"\\t.end\\n\")\n+#define ASM_FILE_END(FILE) fprintf (FILE, \"\\t.end\\n\")\n \n /* We need to have a data section we can identify so that we can set\n    the DP register back to a data pointer in the small memory model.\n@@ -2089,7 +2107,7 @@ dtors_section ()\t\t\t\t\t\t\t\\\n     if (! TARGET_TI) fputs (\"gcc2_compiled.:\\n\", FILE);\t\\\n       fputs (\"\\t.data\\ndata_sec:\\n\", FILE);\n \n-#define ASM_COMMENT_START\t\";\"\n+#define ASM_COMMENT_START \";\"\n \n #define ASM_APP_ON \"\"\n #define ASM_APP_OFF \"\"\n@@ -2248,16 +2266,19 @@ asm_fprintf (FILE, \"%s%d:\\n\", PREFIX, NUM)\n \n #define CPP_PREDEFINES \"\"\n \n-/* This says how to output an assembler line\n-   to define a local common symbol.  */\n+/* Output of Uninitialized Variables  */\n+\n+/* This says how to output an assembler line to define a local\n+   uninitialized variable.  */\n \n #undef ASM_OUTPUT_LOCAL\n #define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n ( fputs (\"\\t.bss\\t\", FILE),\t\t\t\\\n   assemble_name (FILE, (NAME)),\t\t\\\n   fprintf (FILE, \",%u\\n\", (ROUNDED)))\n \n-/* Output of Uninitialized Variables  */\n+/* This says how to output an assembler line to define a global\n+   uninitialized variable.  */\n \n #undef ASM_OUTPUT_COMMON\n #define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\"}, {"sha": "7f1b0f309abd7b75a60a4f5602ec347b87a0866a", "filename": "gcc/config/c4x/c4x.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/314451260e90e153afde24c9f0f8093a35372043/gcc%2Fconfig%2Fc4x%2Fc4x.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/314451260e90e153afde24c9f0f8093a35372043/gcc%2Fconfig%2Fc4x%2Fc4x.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.md?ref=314451260e90e153afde24c9f0f8093a35372043", "patch": "@@ -68,6 +68,8 @@\n ; src_operand           general operand                            [rfHmI]\n ; par_ind_operand       indirect S mode (ARx + 0, 1, IRx)          [S<>]\n ; parallel_operand      par_ind_operand or ext_low_reg_operand\n+; symbolic_address_operand\n+; call_address_operand\n \n ; ADDI src2, src1, dst  three operand op\n ; ADDI src, dst         two operand op\n@@ -1141,7 +1143,6 @@\n    operands[3] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[1]) & 0xffff);\n }\")\n \n-; This pattern is required to handle the case where a register that clobbers\n ; CC has been selected to load a symbolic address.  We force the address\n ; into memory and then generate LDP and LDIU insns.\n ; This is also required for the C30 if we pretend that we can "}]}