{"sha": "80ad92e9852a26508113712cfd98b242fc105f92", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODBhZDkyZTk4NTJhMjY1MDgxMTM3MTJjZmQ5OGIyNDJmYzEwNWY5Mg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-04-03T00:38:00Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-04-03T00:38:00Z"}, "message": "iq2000.c (uns_arith_operand, [...]): Move to predicates.md.\n\n\t* config/iq2000/iq2000.c (uns_arith_operand, arith_operand,\n\tsmall_int, large_int, reg_or_0_operand, simple_memory_operand,\n\tequality_op, cmp_op, pc_or_label_operand, call_insn_operand,\n\tmove_operand, power_of_2_operand): Move to predicates.md.\n\t* config/iq2000/iq2000.h (SPECIAL_MODE_PREDICATES,\n\tPREDICATE_CODE): Remove.\n\t* config/iq2000/iq2000.md: Include predicates.md.\n\t* config/iq2000/predicates.md: New.\n\nFrom-SVN: r97472", "tree": {"sha": "56956a494a485994e83505db4338da698e567b72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/56956a494a485994e83505db4338da698e567b72"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/80ad92e9852a26508113712cfd98b242fc105f92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80ad92e9852a26508113712cfd98b242fc105f92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80ad92e9852a26508113712cfd98b242fc105f92", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80ad92e9852a26508113712cfd98b242fc105f92/comments", "author": null, "committer": null, "parents": [{"sha": "fc9c289a8013cf74068e8c2f9d99d7972a6adc8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc9c289a8013cf74068e8c2f9d99d7972a6adc8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc9c289a8013cf74068e8c2f9d99d7972a6adc8a"}], "stats": {"total": 482, "additions": 246, "deletions": 236}, "files": [{"sha": "9ffac61a605ea392aa067c6d4608ea41ad590af4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ad92e9852a26508113712cfd98b242fc105f92/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ad92e9852a26508113712cfd98b242fc105f92/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=80ad92e9852a26508113712cfd98b242fc105f92", "patch": "@@ -1,3 +1,14 @@\n+2005-04-02  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config/iq2000/iq2000.c (uns_arith_operand, arith_operand,\n+\tsmall_int, large_int, reg_or_0_operand, simple_memory_operand,\n+\tequality_op, cmp_op, pc_or_label_operand, call_insn_operand,\n+\tmove_operand, power_of_2_operand): Move to predicates.md.\n+\t* config/iq2000/iq2000.h (SPECIAL_MODE_PREDICATES,\n+\tPREDICATE_CODE): Remove.\n+\t* config/iq2000/iq2000.md: Include predicates.md.\n+\t* config/iq2000/predicates.md: New.\n+\n 2005-04-02  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/m68hc11/m68hc11.h (target_flags, MASK_SHORT)"}, {"sha": "ff3fc0d654524a3646da946a4c5ff6a095bf3d12", "filename": "gcc/config/iq2000/iq2000.c", "status": "modified", "additions": 0, "deletions": 211, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ad92e9852a26508113712cfd98b242fc105f92/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ad92e9852a26508113712cfd98b242fc105f92/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=80ad92e9852a26508113712cfd98b242fc105f92", "patch": "@@ -208,217 +208,6 @@ static int  iq2000_arg_partial_bytes  (CUMULATIVE_ARGS *, enum machine_mode,\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n-/* Return 1 if OP can be used as an operand where a register or 16 bit unsigned\n-   integer is needed.  */\n-\n-int\n-uns_arith_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) == CONST_INT && SMALL_INT_UNSIGNED (op))\n-    return 1;\n-\n-  return register_operand (op, mode);\n-}\n-\n-/* Return 1 if OP can be used as an operand where a 16 bit integer is needed.  */\n-\n-int\n-arith_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) == CONST_INT && SMALL_INT (op))\n-    return 1;\n-\n-  return register_operand (op, mode);\n-}\n-\n-/* Return 1 if OP is a integer which fits in 16 bits.  */\n-\n-int\n-small_int (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (op) == CONST_INT && SMALL_INT (op));\n-}\n-\n-/* Return 1 if OP is a 32 bit integer which is too big to be loaded with one\n-   instruction.  */\n-\n-int\n-large_int (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  HOST_WIDE_INT value;\n-\n-  if (GET_CODE (op) != CONST_INT)\n-    return 0;\n-\n-  value = INTVAL (op);\n-\n-  /* IOR reg,$r0,value.  */\n-  if ((value & ~ ((HOST_WIDE_INT) 0x0000ffff)) == 0)\n-    return 0;\n-\n-  /* SUBU reg,$r0,value.  */\n-  if (((unsigned HOST_WIDE_INT) (value + 32768)) <= 32767)\n-    return 0;\n-\n-  /* LUI reg,value >> 16.  */\n-  if ((value & 0x0000ffff) == 0)\n-    return 0;\n-\n-  return 1;\n-}\n-\n-/* Return 1 if OP is a register or the constant 0.  */\n-\n-int\n-reg_or_0_operand (rtx op, enum machine_mode mode)\n-{\n-  switch (GET_CODE (op))\n-    {\n-    case CONST_INT:\n-      return INTVAL (op) == 0;\n-\n-    case CONST_DOUBLE:\n-      return op == CONST0_RTX (mode);\n-\n-    case REG:\n-    case SUBREG:\n-      return register_operand (op, mode);\n-\n-    default:\n-      break;\n-    }\n-\n-  return 0;\n-}\n-\n-/* Return 1 if OP is a memory operand that fits in a single instruction\n-   (i.e., register + small offset).  */\n-\n-int\n-simple_memory_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  rtx addr, plus0, plus1;\n-\n-  /* Eliminate non-memory operations.  */\n-  if (GET_CODE (op) != MEM)\n-    return 0;\n-\n-  /* Dword operations really put out 2 instructions, so eliminate them.  */\n-  if (GET_MODE_SIZE (GET_MODE (op)) > (unsigned) UNITS_PER_WORD)\n-    return 0;\n-\n-  /* Decode the address now.  */\n-  addr = XEXP (op, 0);\n-  switch (GET_CODE (addr))\n-    {\n-    case REG:\n-    case LO_SUM:\n-      return 1;\n-\n-    case CONST_INT:\n-      return SMALL_INT (addr);\n-\n-    case PLUS:\n-      plus0 = XEXP (addr, 0);\n-      plus1 = XEXP (addr, 1);\n-      if (GET_CODE (plus0) == REG\n-\t  && GET_CODE (plus1) == CONST_INT && SMALL_INT (plus1)\n-\t  && SMALL_INT_UNSIGNED (plus1) /* No negative offsets.  */)\n-\treturn 1;\n-\n-      else if (GET_CODE (plus1) == REG\n-\t       && GET_CODE (plus0) == CONST_INT && SMALL_INT (plus0)\n-\t       && SMALL_INT_UNSIGNED (plus1) /* No negative offsets.  */)\n-\treturn 1;\n-\n-      else\n-\treturn 0;\n-\n-    case SYMBOL_REF:\n-      return 0;\n-\n-    default:\n-      break;\n-    }\n-\n-  return 0;\n-}\n-\n-/* Return nonzero if the code of this rtx pattern is EQ or NE.  */\n-\n-int\n-equality_op (rtx op, enum machine_mode mode)\n-{\n-  if (mode != GET_MODE (op))\n-    return 0;\n-\n-  return GET_CODE (op) == EQ || GET_CODE (op) == NE;\n-}\n-\n-/* Return nonzero if the code is a relational operations (EQ, LE, etc).  */\n-\n-int\n-cmp_op (rtx op, enum machine_mode mode)\n-{\n-  if (mode != GET_MODE (op))\n-    return 0;\n-\n-  return COMPARISON_P (op);\n-}\n-\n-/* Return nonzero if the operand is either the PC or a label_ref.  */\n-\n-int\n-pc_or_label_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (op == pc_rtx)\n-    return 1;\n-\n-  if (GET_CODE (op) == LABEL_REF)\n-    return 1;\n-\n-  return 0;\n-}\n-\n-/* Return nonzero if OP is a valid operand for a call instruction.  */\n-\n-int\n-call_insn_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (CONSTANT_ADDRESS_P (op)\n-\t  || (GET_CODE (op) == REG && op != arg_pointer_rtx\n-\t      && ! (REGNO (op) >= FIRST_PSEUDO_REGISTER\n-\t\t    && REGNO (op) <= LAST_VIRTUAL_REGISTER)));\n-}\n-\n-/* Return nonzero if OP is valid as a source operand for a move instruction.  */\n-\n-int\n-move_operand (rtx op, enum machine_mode mode)\n-{\n-  /* Accept any general operand after reload has started; doing so\n-     avoids losing if reload does an in-place replacement of a register\n-     with a SYMBOL_REF or CONST.  */\n-  return (general_operand (op, mode)\n-\t  && (! (iq2000_check_split (op, mode))\n-\t      || reload_in_progress || reload_completed));\n-}\n-\n-/* Return nonzero if OP is a constant power of 2.  */\n-\n-int\n-power_of_2_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  int intval;\n-\n-  if (GET_CODE (op) != CONST_INT)\n-    return 0;\n-  else\n-    intval = INTVAL (op);\n-\n-  return ((intval & ((unsigned)(intval) - 1)) == 0);\n-}\n-\n /* Return nonzero if we split the address into high and low parts.  */\n \n int"}, {"sha": "a352eea2e1ed92450bd44b7f3f9af6a82842eef9", "filename": "gcc/config/iq2000/iq2000.h", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ad92e9852a26508113712cfd98b242fc105f92/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ad92e9852a26508113712cfd98b242fc105f92/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.h?ref=80ad92e9852a26508113712cfd98b242fc105f92", "patch": "@@ -779,23 +779,6 @@ while (0)\n \f\n /* Miscellaneous Parameters.  */\n \n-#define PREDICATE_CODES\t\t\t\t\t\t\t\\\n-  {\"uns_arith_operand\",\t\t{ REG, CONST_INT, SUBREG }},\t\t\\\n-  {\"arith_operand\",\t\t{ REG, CONST_INT, SUBREG }},\t\t\\\n-  {\"small_int\",\t\t\t{ CONST_INT }},\t\t\t\t\\\n-  {\"large_int\",\t\t\t{ CONST_INT }},\t\t\t\t\\\n-  {\"reg_or_0_operand\",\t\t{ REG, CONST_INT, CONST_DOUBLE, SUBREG }}, \\\n-  {\"simple_memory_operand\",\t{ MEM, SUBREG }},\t\t\t\\\n-  {\"equality_op\",\t\t{ EQ, NE }},\t\t\t\t\\\n-  {\"cmp_op\",\t\t\t{ EQ, NE, GT, GE, GTU, GEU, LT, LE,\t\\\n-\t\t\t\t  LTU, LEU }},\t\t\t\t\\\n-  {\"pc_or_label_operand\",\t{ PC, LABEL_REF }},\t\t\t\\\n-  {\"call_insn_operand\",\t\t{ CONST_INT, CONST, SYMBOL_REF, REG}},\t\\\n-  {\"move_operand\", \t\t{ CONST_INT, CONST_DOUBLE, CONST,\t\\\n-\t\t\t\t  SYMBOL_REF, LABEL_REF, SUBREG,\t\\\n-\t\t\t\t  REG, MEM}},\t\t\t\t\\\n-  {\"power_of_2_operand\",\t{ CONST_INT }},\n-\n #define CASE_VECTOR_MODE SImode\n \n #define WORD_REGISTER_OPERATIONS\n@@ -1062,13 +1045,6 @@ extern void\t\tsbss_section  (void);\n   ((LENGTH) = iq2000_adjust_insn_length ((INSN), (LENGTH)))\n \n \f\n-/* A list of predicates that do special things with modes, and so\n-   should not elicit warnings for VOIDmode match_operand.  */\n-\n-#define SPECIAL_MODE_PREDICATES \\\n-  \"pc_or_label_operand\",\n-\n-\f\n \n \n /* How to tell the debugger about changes of source files.  */"}, {"sha": "208b82c2b9de2bc24e6fa226d615006c5563449e", "filename": "gcc/config/iq2000/iq2000.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ad92e9852a26508113712cfd98b242fc105f92/gcc%2Fconfig%2Fiq2000%2Fiq2000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ad92e9852a26508113712cfd98b242fc105f92/gcc%2Fconfig%2Fiq2000%2Fiq2000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.md?ref=80ad92e9852a26508113712cfd98b242fc105f92", "patch": "@@ -1,5 +1,5 @@\n ;;  iq2000.md\t     Machine Description for Vitesse IQ2000 processors\n-;;  Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n+;;  Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.\n \n ;; This file is part of GCC.\n \n@@ -194,6 +194,7 @@\n    (nil)\n    (nil)])\n \n+(include \"predicates.md\")\n \f\n \n ;; ........................."}, {"sha": "a8ce5819d7401fec2e9fc2a456f23d744b4e8d5d", "filename": "gcc/config/iq2000/predicates.md", "status": "added", "additions": 233, "deletions": 0, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ad92e9852a26508113712cfd98b242fc105f92/gcc%2Fconfig%2Fiq2000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ad92e9852a26508113712cfd98b242fc105f92/gcc%2Fconfig%2Fiq2000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fpredicates.md?ref=80ad92e9852a26508113712cfd98b242fc105f92", "patch": "@@ -0,0 +1,233 @@\n+;; Predicate definitions for Vitesse IQ2000.\n+;; Copyright (C) 2005 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+;; Return 1 if OP can be used as an operand where a register or 16 bit\n+;; unsigned integer is needed.\n+\n+(define_predicate \"uns_arith_operand\"\n+  (match_code \"reg,const_int,subreg\")\n+{\n+  if (GET_CODE (op) == CONST_INT && SMALL_INT_UNSIGNED (op))\n+    return 1;\n+\n+  return register_operand (op, mode);\n+})\n+\n+;; Return 1 if OP can be used as an operand where a 16 bit integer is\n+;; needed.\n+\n+(define_predicate \"arith_operand\"\n+  (match_code \"reg,const_int,subreg\")\n+{\n+  if (GET_CODE (op) == CONST_INT && SMALL_INT (op))\n+    return 1;\n+\n+  return register_operand (op, mode);\n+})\n+\n+;; Return 1 if OP is a integer which fits in 16 bits.\n+\n+(define_predicate \"small_int\"\n+  (match_code \"const_int\")\n+{\n+  return (GET_CODE (op) == CONST_INT && SMALL_INT (op));\n+})\n+\n+;; Return 1 if OP is a 32 bit integer which is too big to be loaded\n+;; with one instruction.\n+\n+(define_predicate \"large_int\"\n+  (match_code \"const_int\")\n+{\n+  HOST_WIDE_INT value;\n+\n+  if (GET_CODE (op) != CONST_INT)\n+    return 0;\n+\n+  value = INTVAL (op);\n+\n+  /* IOR reg,$r0,value.  */\n+  if ((value & ~ ((HOST_WIDE_INT) 0x0000ffff)) == 0)\n+    return 0;\n+\n+  /* SUBU reg,$r0,value.  */\n+  if (((unsigned HOST_WIDE_INT) (value + 32768)) <= 32767)\n+    return 0;\n+\n+  /* LUI reg,value >> 16.  */\n+  if ((value & 0x0000ffff) == 0)\n+    return 0;\n+\n+  return 1;\n+})\n+\n+;; Return 1 if OP is a register or the constant 0.\n+\n+(define_predicate \"reg_or_0_operand\"\n+  (match_code \"reg,const_int,const_double,subreg\")\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case CONST_INT:\n+      return INTVAL (op) == 0;\n+\n+    case CONST_DOUBLE:\n+      return op == CONST0_RTX (mode);\n+\n+    case REG:\n+    case SUBREG:\n+      return register_operand (op, mode);\n+\n+    default:\n+      break;\n+    }\n+\n+  return 0;\n+})\n+\n+;; Return 1 if OP is a memory operand that fits in a single\n+;; instruction (i.e., register + small offset).\n+\n+(define_predicate \"simple_memory_operand\"\n+  (match_code \"mem,subreg\")\n+{\n+  rtx addr, plus0, plus1;\n+\n+  /* Eliminate non-memory operations.  */\n+  if (GET_CODE (op) != MEM)\n+    return 0;\n+\n+  /* Dword operations really put out 2 instructions, so eliminate them.  */\n+  if (GET_MODE_SIZE (GET_MODE (op)) > (unsigned) UNITS_PER_WORD)\n+    return 0;\n+\n+  /* Decode the address now.  */\n+  addr = XEXP (op, 0);\n+  switch (GET_CODE (addr))\n+    {\n+    case REG:\n+    case LO_SUM:\n+      return 1;\n+\n+    case CONST_INT:\n+      return SMALL_INT (addr);\n+\n+    case PLUS:\n+      plus0 = XEXP (addr, 0);\n+      plus1 = XEXP (addr, 1);\n+      if (GET_CODE (plus0) == REG\n+\t  && GET_CODE (plus1) == CONST_INT && SMALL_INT (plus1)\n+\t  && SMALL_INT_UNSIGNED (plus1) /* No negative offsets.  */)\n+\treturn 1;\n+\n+      else if (GET_CODE (plus1) == REG\n+\t       && GET_CODE (plus0) == CONST_INT && SMALL_INT (plus0)\n+\t       && SMALL_INT_UNSIGNED (plus1) /* No negative offsets.  */)\n+\treturn 1;\n+\n+      else\n+\treturn 0;\n+\n+    case SYMBOL_REF:\n+      return 0;\n+\n+    default:\n+      break;\n+    }\n+\n+  return 0;\n+})\n+\n+;; Return nonzero if the code of this rtx pattern is EQ or NE.\n+\n+(define_predicate \"equality_op\"\n+  (match_code \"eq,ne\")\n+{\n+  if (mode != GET_MODE (op))\n+    return 0;\n+\n+  return GET_CODE (op) == EQ || GET_CODE (op) == NE;\n+})\n+\n+;; Return nonzero if the code is a relational operations (EQ, LE,\n+;; etc).\n+\n+(define_predicate \"cmp_op\"\n+  (match_code \"eq,ne,gt,ge,gtu,geu,lt,le,ltu,leu\")\n+{\n+  if (mode != GET_MODE (op))\n+    return 0;\n+\n+  return COMPARISON_P (op);\n+})\n+\n+;; Return nonzero if the operand is either the PC or a label_ref.\n+\n+(define_special_predicate \"pc_or_label_operand\"\n+  (match_code \"pc,label_ref\")\n+{\n+  if (op == pc_rtx)\n+    return 1;\n+\n+  if (GET_CODE (op) == LABEL_REF)\n+    return 1;\n+\n+  return 0;\n+})\n+\n+;; Return nonzero if OP is a valid operand for a call instruction.\n+\n+(define_predicate \"call_insn_operand\"\n+  (match_code \"const_int,const,symbol_ref,reg\")\n+{\n+  return (CONSTANT_ADDRESS_P (op)\n+\t  || (GET_CODE (op) == REG && op != arg_pointer_rtx\n+\t      && ! (REGNO (op) >= FIRST_PSEUDO_REGISTER\n+\t\t    && REGNO (op) <= LAST_VIRTUAL_REGISTER)));\n+})\n+\n+;; Return nonzero if OP is valid as a source operand for a move\n+;; instruction.\n+\n+(define_predicate \"move_operand\"\n+  (match_code \"const_int,const_double,const,symbol_ref,label_ref,subreg,reg,mem\")\n+{\n+  /* Accept any general operand after reload has started; doing so\n+     avoids losing if reload does an in-place replacement of a register\n+     with a SYMBOL_REF or CONST.  */\n+  return (general_operand (op, mode)\n+\t  && (! (iq2000_check_split (op, mode))\n+\t      || reload_in_progress || reload_completed));\n+})\n+\n+;; Return nonzero if OP is a constant power of 2.\n+\n+(define_predicate \"power_of_2_operand\"\n+  (match_code \"const_int\")\n+{\n+  int intval;\n+\n+  if (GET_CODE (op) != CONST_INT)\n+    return 0;\n+  else\n+    intval = INTVAL (op);\n+\n+  return ((intval & ((unsigned)(intval) - 1)) == 0);\n+})"}]}