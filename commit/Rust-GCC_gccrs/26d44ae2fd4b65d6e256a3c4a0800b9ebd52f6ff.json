{"sha": "26d44ae2fd4b65d6e256a3c4a0800b9ebd52f6ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjZkNDRhZTJmZDRiNjVkNmUyNTZhM2M0YTA4MDBiOWViZDUyZjZmZg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-06-30T00:38:18Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-06-30T00:38:18Z"}, "message": "gimplify.c (gimplify_modify_expr_rhs): Move immediately before gimplify_modify_expr.\n\n        * gimplify.c (gimplify_modify_expr_rhs): Move immediately before\n        gimplify_modify_expr.\n        (gimplify_init_constructor): Likewise.  Gimplify the null\n        CONSTRUCTOR assignment.\n        (gimplify_modify_expr_to_memcpy): New.\n        (gimplify_modify_expr_to_memset): New.\n        (gimplify_modify_expr): Use them.\n\nFrom-SVN: r83888", "tree": {"sha": "8a3a133fe40360717067538e331693b767460568", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a3a133fe40360717067538e331693b767460568"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/26d44ae2fd4b65d6e256a3c4a0800b9ebd52f6ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26d44ae2fd4b65d6e256a3c4a0800b9ebd52f6ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26d44ae2fd4b65d6e256a3c4a0800b9ebd52f6ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26d44ae2fd4b65d6e256a3c4a0800b9ebd52f6ff/comments", "author": null, "committer": null, "parents": [{"sha": "9d75385f5c9131090d3f4fd55b241bade2035469", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d75385f5c9131090d3f4fd55b241bade2035469", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d75385f5c9131090d3f4fd55b241bade2035469"}], "stats": {"total": 1173, "additions": 620, "deletions": 553}, "files": [{"sha": "441759fc88fe33e45b93c29b2948dfc4d2598b28", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26d44ae2fd4b65d6e256a3c4a0800b9ebd52f6ff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26d44ae2fd4b65d6e256a3c4a0800b9ebd52f6ff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=26d44ae2fd4b65d6e256a3c4a0800b9ebd52f6ff", "patch": "@@ -1,3 +1,13 @@\n+2004-06-29  Richard Henderson  <rth@redhat.com>\n+\n+\t* gimplify.c (gimplify_modify_expr_rhs): Move immediately before\n+\tgimplify_modify_expr.\n+\t(gimplify_init_constructor): Likewise.  Gimplify the null\n+\tCONSTRUCTOR assignment.\n+\t(gimplify_modify_expr_to_memcpy): New.\n+\t(gimplify_modify_expr_to_memset): New.\n+\t(gimplify_modify_expr): Use them.\n+\n 2004-06-29  Roman Zippel <zippel@linux-m68k.org>\n \n \t* web.c (union_defs): use all defs of an instruction to create a"}, {"sha": "c596ad90428b83d6c9e31e02432e547d4aaf3518", "filename": "gcc/gimplify.c", "status": "modified", "additions": 610, "deletions": 553, "changes": 1163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26d44ae2fd4b65d6e256a3c4a0800b9ebd52f6ff/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26d44ae2fd4b65d6e256a3c4a0800b9ebd52f6ff/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=26d44ae2fd4b65d6e256a3c4a0800b9ebd52f6ff", "patch": "@@ -1323,414 +1323,137 @@ force_labels_r (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n   return NULL_TREE;\n }\n \n-/* Break out elements of a constructor used as an initializer into separate\n-   MODIFY_EXPRs.\n+/* *EXPR_P is a COMPONENT_REF being used as an rvalue.  If its type is\n+   different from its canonical type, wrap the whole thing inside a\n+   NOP_EXPR and force the type of the COMPONENT_REF to be the canonical\n+   type.\n \n-   Note that we still need to clear any elements that don't have explicit\n-   initializers, so if not all elements are initialized we keep the\n-   original MODIFY_EXPR, we just remove all of the constructor elements.  */\n+   The canonical type of a COMPONENT_REF is the type of the field being\n+   referenced--unless the field is a bit-field which can be read directly\n+   in a smaller mode, in which case the canonical type is the\n+   sign-appropriate type corresponding to that mode.  */\n \n-static enum gimplify_status\n-gimplify_init_constructor (tree *expr_p, tree *pre_p,\n-\t\t\t   tree *post_p, bool want_value)\n+static void\n+canonicalize_component_ref (tree *expr_p)\n {\n-  tree object = TREE_OPERAND (*expr_p, 0);\n-  tree ctor = TREE_OPERAND (*expr_p, 1);\n-  tree type = TREE_TYPE (ctor);\n-  enum gimplify_status ret;\n-  tree elt_list;\n+  tree expr = *expr_p;\n+  tree type;\n \n-  if (TREE_CODE (ctor) != CONSTRUCTOR)\n-    return GS_UNHANDLED;\n+  if (TREE_CODE (expr) != COMPONENT_REF)\n+    abort ();\n \n-  elt_list = CONSTRUCTOR_ELTS (ctor);\n+  if (INTEGRAL_TYPE_P (TREE_TYPE (expr)))\n+    type = TREE_TYPE (get_unwidened (expr, NULL_TREE));\n+  else\n+    type = TREE_TYPE (TREE_OPERAND (expr, 1));\n \n-  ret = GS_ALL_DONE;\n-  switch (TREE_CODE (type))\n+  if (TREE_TYPE (expr) != type)\n     {\n-    case RECORD_TYPE:\n-    case UNION_TYPE:\n-    case QUAL_UNION_TYPE:\n-    case ARRAY_TYPE:\n-      {\n-\tHOST_WIDE_INT i, num_elements, num_nonzero_elements;\n-\tHOST_WIDE_INT num_nonconstant_elements;\n-\tbool cleared;\n+      tree old_type = TREE_TYPE (expr);\n \n-\t/* Aggregate types must lower constructors to initialization of\n-\t   individual elements.  The exception is that a CONSTRUCTOR node\n-\t   with no elements indicates zero-initialization of the whole.  */\n-\tif (elt_list == NULL)\n-\t  {\n-\t    if (want_value)\n-\t      {\n-\t\t*expr_p = object;\n-\t\treturn GS_OK;\n-\t      }\n-\t    else\n-\t      return GS_UNHANDLED;\n-\t  }\n+      /* Set the type of the COMPONENT_REF to the underlying type.  */\n+      TREE_TYPE (expr) = type;\n \n-\tcategorize_ctor_elements (ctor, &num_nonzero_elements,\n-\t\t\t\t  &num_nonconstant_elements);\n-\tnum_elements = count_type_elements (TREE_TYPE (ctor));\n+      /* And wrap the whole thing inside a NOP_EXPR.  */\n+      expr = build1 (NOP_EXPR, old_type, expr);\n \n-\t/* If a const aggregate variable is being initialized, then it\n-\t   should never be a lose to promote the variable to be static.  */\n-\tif (num_nonconstant_elements == 0\n-\t    && TREE_READONLY (object)\n-\t    && TREE_CODE (object) == VAR_DECL)\n-\t  {\n-\t    DECL_INITIAL (object) = ctor;\n-\t    TREE_STATIC (object) = 1;\n-\t    if (!DECL_NAME (object))\n-\t      DECL_NAME (object) = create_tmp_var_name (\"C\");\n-\t    walk_tree (&DECL_INITIAL (object), force_labels_r, NULL, NULL);\n+      *expr_p = expr;\n+    }\n+}\n \n-\t    /* ??? C++ doesn't automatically append a .<number> to the\n-\t       assembler name, and even when it does, it looks a FE private\n-\t       data structures to figure out what that number should be,\n-\t       which are not set for this variable.  I suppose this is\n-\t       important for local statics for inline functions, which aren't\n-\t       \"local\" in the object file sense.  So in order to get a unique\n-\t       TU-local symbol, we must invoke the lhd version now.  */\n-\t    lhd_set_decl_assembler_name (object);\n+/* If a NOP conversion is changing a pointer to array of foo to a pointer\n+   to foo, embed that change in the ADDR_EXPR by converting \n+      T array[U];\n+      (T *)&array\n+   ==>\n+      &array[L]\n+   where L is the lower bound.  For simplicity, only do this for constant\n+   lower bound.  */\n \n-\t    *expr_p = NULL_TREE;\n-\t    break;\n-\t  }\n+static void\n+canonicalize_addr_expr (tree *expr_p)\n+{\n+  tree expr = *expr_p;\n+  tree ctype = TREE_TYPE (expr);\n+  tree addr_expr = TREE_OPERAND (expr, 0);\n+  tree atype = TREE_TYPE (addr_expr);\n+  tree dctype, datype, ddatype, otype, obj_expr;\n \n-\t/* If there are \"lots\" of initialized elements, and all of them\n-\t   are valid address constants, then the entire initializer can\n-\t   be dropped to memory, and then memcpy'd out.  */\n-\tif (num_nonconstant_elements == 0)\n-\t  {\n-\t    HOST_WIDE_INT size = int_size_in_bytes (type);\n-\t    unsigned int align;\n+  /* Both cast and addr_expr types should be pointers.  */\n+  if (!POINTER_TYPE_P (ctype) || !POINTER_TYPE_P (atype))\n+    return;\n \n-\t    /* ??? We can still get unbounded array types, at least\n-\t       from the C++ front end.  This seems wrong, but attempt\n-\t       to work around it for now.  */\n-\t    if (size < 0)\n-\t      {\n-\t\tsize = int_size_in_bytes (TREE_TYPE (object));\n-\t\tif (size >= 0)\n-\t\t  TREE_TYPE (ctor) = type = TREE_TYPE (object);\n-\t      }\n+  /* The addr_expr type should be a pointer to an array.  */\n+  datype = TREE_TYPE (atype);\n+  if (TREE_CODE (datype) != ARRAY_TYPE)\n+    return;\n \n-\t    /* Find the maximum alignment we can assume for the object.  */\n-\t    /* ??? Make use of DECL_OFFSET_ALIGN.  */\n-\t    if (DECL_P (object))\n-\t      align = DECL_ALIGN (object);\n-\t    else\n-\t      align = TYPE_ALIGN (type);\n+  /* Both cast and addr_expr types should address the same object type.  */\n+  dctype = TREE_TYPE (ctype);\n+  ddatype = TREE_TYPE (datype);\n+  if (!lang_hooks.types_compatible_p (ddatype, dctype))\n+    return;\n \n-\t    if (size > 0 && !can_move_by_pieces (size, align))\n-\t      {\n-\t\ttree new = create_tmp_var_raw (type, \"C\");\n-\t\tgimple_add_tmp_var (new);\n-\t\tTREE_STATIC (new) = 1;\n-\t\tTREE_READONLY (new) = 1;\n-\t\tDECL_INITIAL (new) = ctor;\n-\t\tif (align > DECL_ALIGN (new))\n-\t\t  {\n-\t\t    DECL_ALIGN (new) = align;\n-\t\t    DECL_USER_ALIGN (new) = 1;\n-\t\t  }\n-\t        walk_tree (&DECL_INITIAL (new), force_labels_r, NULL, NULL);\n+  /* The addr_expr and the object type should match.  */\n+  obj_expr = TREE_OPERAND (addr_expr, 0);\n+  otype = TREE_TYPE (obj_expr);\n+  if (!lang_hooks.types_compatible_p (otype, datype))\n+    return;\n \n-\t\tTREE_OPERAND (*expr_p, 1) = new;\n-\t\tbreak;\n-\t      }\n-\t  }\n+  /* The lower bound and element sizes must be constant.  */\n+  if (TREE_CODE (TYPE_SIZE_UNIT (dctype)) != INTEGER_CST\n+      || !TYPE_DOMAIN (datype) || !TYPE_MIN_VALUE (TYPE_DOMAIN (datype))\n+      || TREE_CODE (TYPE_MIN_VALUE (TYPE_DOMAIN (datype))) != INTEGER_CST)\n+    return;\n \n-\t/* If there are \"lots\" of initialized elements, even discounting\n-\t   those that are not address constants (and thus *must* be \n-\t   computed at runtime), then partition the constructor into\n-\t   constant and non-constant parts.  Block copy the constant\n-\t   parts in, then generate code for the non-constant parts.  */\n-\t/* TODO.  There's code in cp/typeck.c to do this.  */\n+  /* All checks succeeded.  Build a new node to merge the cast.  */\n+  *expr_p = build4 (ARRAY_REF, dctype, obj_expr,\n+\t\t    TYPE_MIN_VALUE (TYPE_DOMAIN (datype)),\n+\t\t    TYPE_MIN_VALUE (TYPE_DOMAIN (datype)),\n+\t\t    size_binop (EXACT_DIV_EXPR, TYPE_SIZE_UNIT (dctype),\n+\t\t\t\tsize_int (TYPE_ALIGN (dctype)\n+\t\t\t\t\t  / BITS_PER_UNIT)));\n+  *expr_p = build1 (ADDR_EXPR, ctype, *expr_p);\n+}\n \n-\t/* If there are \"lots\" of zeros, then block clear the object first.  */\n-\tcleared = false;\n-\tif (num_elements - num_nonzero_elements > CLEAR_RATIO\n-\t    && num_nonzero_elements < num_elements/4)\n-\t  cleared = true;\n+/* *EXPR_P is a NOP_EXPR or CONVERT_EXPR.  Remove it and/or other conversions\n+   underneath as appropriate.  */\n \n-\t/* ??? This bit ought not be needed.  For any element not present\n-\t   in the initializer, we should simply set them to zero.  Except\n-\t   we'd need to *find* the elements that are not present, and that\n-\t   requires trickery to avoid quadratic compile-time behavior in\n-\t   large cases or excessive memory use in small cases.  */\n-\telse\n-\t  {\n-\t    HOST_WIDE_INT len = list_length (elt_list);\n-\t    if (TREE_CODE (type) == ARRAY_TYPE)\n-\t      {\n-\t\ttree nelts = array_type_nelts (type);\n-\t\tif (!host_integerp (nelts, 1)\n-\t\t    || tree_low_cst (nelts, 1) != len)\n-\t\t  cleared = 1;;\n-\t      }\n-\t    else if (len != fields_length (type))\n-\t      cleared = 1;\n-\t  }\n+static enum gimplify_status\n+gimplify_conversion (tree *expr_p)\n+{  \n+  /* Strip away as many useless type conversions as possible\n+     at the toplevel.  */\n+  STRIP_USELESS_TYPE_CONVERSION (*expr_p);\n \n-\tif (cleared)\n-\t  {\n-\t    CONSTRUCTOR_ELTS (ctor) = NULL_TREE;\n-\t    append_to_statement_list (*expr_p, pre_p);\n-\t  }\n+  /* If we still have a conversion at the toplevel, then strip\n+     away all but the outermost conversion.  */\n+  if (TREE_CODE (*expr_p) == NOP_EXPR || TREE_CODE (*expr_p) == CONVERT_EXPR)\n+    {\n+      STRIP_SIGN_NOPS (TREE_OPERAND (*expr_p, 0));\n \n-\tfor (i = 0; elt_list; i++, elt_list = TREE_CHAIN (elt_list))\n-\t  {\n-\t    tree purpose, value, cref, init;\n+      /* And remove the outermost conversion if it's useless.  */\n+      if (tree_ssa_useless_type_conversion (*expr_p))\n+\t*expr_p = TREE_OPERAND (*expr_p, 0);\n+    }\n \n-\t    purpose = TREE_PURPOSE (elt_list);\n-\t    value = TREE_VALUE (elt_list);\n+  /* If we still have a conversion at the toplevel,\n+     then canonicalize some constructs.  */\n+  if (TREE_CODE (*expr_p) == NOP_EXPR || TREE_CODE (*expr_p) == CONVERT_EXPR)\n+    {\n+      tree sub = TREE_OPERAND (*expr_p, 0);\n \n-\t    if (cleared && initializer_zerop (value))\n-\t      continue;\n+      /* If a NOP conversion is changing the type of a COMPONENT_REF\n+\t expression, then canonicalize its type now in order to expose more\n+\t redundant conversions.  */\n+      if (TREE_CODE (sub) == COMPONENT_REF)\n+\tcanonicalize_component_ref (&TREE_OPERAND (*expr_p, 0));\n \n-\t    if (TREE_CODE (type) == ARRAY_TYPE)\n-\t      {\n-\t\ttree t = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (object)));\n-\n-\t\t/* ??? Here's to hoping the front end fills in all of the\n-\t\t   indicies, so we don't have to figure out what's missing\n-\t\t   ourselves.  */\n-\t\tif (!purpose)\n-\t\t  abort ();\n-\t\t/* ??? Need to handle this.  */\n-\t\tif (TREE_CODE (purpose) == RANGE_EXPR)\n-\t\t  abort ();\n-\n-\t\tcref = build (ARRAY_REF, t, object, purpose, NULL_TREE, NULL_TREE);\n-\t      }\n-\t    else\n-\t      cref = build (COMPONENT_REF, TREE_TYPE (purpose), object,\n-\t\t\t    purpose, NULL_TREE);\n-\n-\t    init = build (MODIFY_EXPR, TREE_TYPE (purpose), cref, value);\n-\n-\t    /* Each member initialization is a full-expression.  */\n-\t    gimplify_and_add (init, pre_p);\n-\t  }\n-\n-\t*expr_p = NULL_TREE;\n-      }\n-      break;\n-\n-    case COMPLEX_TYPE:\n-      {\n-\ttree r, i;\n-\n-\t/* Extract the real and imaginary parts out of the ctor.  */\n-\tr = i = NULL_TREE;\n-\tif (elt_list)\n-\t  {\n-\t    r = TREE_VALUE (elt_list);\n-\t    elt_list = TREE_CHAIN (elt_list);\n-\t    if (elt_list)\n-\t      {\n-\t\ti = TREE_VALUE (elt_list);\n-\t\tif (TREE_CHAIN (elt_list))\n-\t\t  abort ();\n-\t      }\n-\t  }\n-\tif (r == NULL || i == NULL)\n-\t  {\n-\t    tree zero = convert (TREE_TYPE (type), integer_zero_node);\n-\t    if (r == NULL)\n-\t      r = zero;\n-\t    if (i == NULL)\n-\t      i = zero;\n-\t  }\n-\n-\t/* Complex types have either COMPLEX_CST or COMPLEX_EXPR to\n-\t   represent creation of a complex value.  */\n-\tif (TREE_CONSTANT (r) && TREE_CONSTANT (i))\n-\t  {\n-\t    ctor = build_complex (type, r, i);\n-\t    TREE_OPERAND (*expr_p, 1) = ctor;\n-\t  }\n-\telse\n-\t  {\n-\t    ctor = build (COMPLEX_EXPR, type, r, i);\n-\t    TREE_OPERAND (*expr_p, 1) = ctor;\n-\t    ret = gimplify_expr (&TREE_OPERAND (*expr_p, 1), pre_p, post_p,\n-\t\t\t\t is_gimple_rhs, fb_rvalue);\n-\t  }\n-      }\n-      break;\n-\n-    case VECTOR_TYPE:\n-      /* Go ahead and simplify constant constructors to VECTOR_CST.  */\n-      if (TREE_CONSTANT (ctor))\n-\tTREE_OPERAND (*expr_p, 1) = build_vector (type, elt_list);\n-      else\n-\t{\n-\t  /* Vector types use CONSTRUCTOR all the way through gimple\n-\t     compilation as a general initializer.  */\n-\t  for (; elt_list; elt_list = TREE_CHAIN (elt_list))\n-\t    {\n-\t      enum gimplify_status tret;\n-\t      tret = gimplify_expr (&TREE_VALUE (elt_list), pre_p, post_p,\n-\t\t\t\t    is_gimple_constructor_elt, fb_rvalue);\n-\t      if (tret == GS_ERROR)\n-\t\tret = GS_ERROR;\n-\t    }\n-\t}\n-      break;\n-\n-    default:\n-      /* So how did we get a CONSTRUCTOR for a scalar type?  */\n-      abort ();\n-    }\n-\n-  if (ret == GS_ERROR)\n-    return GS_ERROR;\n-  else if (want_value)\n-    {\n-      append_to_statement_list (*expr_p, pre_p);\n-      *expr_p = object;\n-      return GS_OK;\n-    }\n-  else\n-    return GS_ALL_DONE;\n-}\n-\n-/* *EXPR_P is a COMPONENT_REF being used as an rvalue.  If its type is\n-   different from its canonical type, wrap the whole thing inside a\n-   NOP_EXPR and force the type of the COMPONENT_REF to be the canonical\n-   type.\n-\n-   The canonical type of a COMPONENT_REF is the type of the field being\n-   referenced--unless the field is a bit-field which can be read directly\n-   in a smaller mode, in which case the canonical type is the\n-   sign-appropriate type corresponding to that mode.  */\n-\n-static void\n-canonicalize_component_ref (tree *expr_p)\n-{\n-  tree expr = *expr_p;\n-  tree type;\n-\n-  if (TREE_CODE (expr) != COMPONENT_REF)\n-    abort ();\n-\n-  if (INTEGRAL_TYPE_P (TREE_TYPE (expr)))\n-    type = TREE_TYPE (get_unwidened (expr, NULL_TREE));\n-  else\n-    type = TREE_TYPE (TREE_OPERAND (expr, 1));\n-\n-  if (TREE_TYPE (expr) != type)\n-    {\n-      tree old_type = TREE_TYPE (expr);\n-\n-      /* Set the type of the COMPONENT_REF to the underlying type.  */\n-      TREE_TYPE (expr) = type;\n-\n-      /* And wrap the whole thing inside a NOP_EXPR.  */\n-      expr = build1 (NOP_EXPR, old_type, expr);\n-\n-      *expr_p = expr;\n-    }\n-}\n-\n-/* If a NOP conversion is changing a pointer to array of foo to a pointer\n-   to foo, embed that change in the ADDR_EXPR by converting \n-      T array[U];\n-      (T *)&array\n-   ==>\n-      &array[L]\n-   where L is the lower bound.  For simplicity, only do this for constant\n-   lower bound.  */\n-\n-static void\n-canonicalize_addr_expr (tree *expr_p)\n-{\n-  tree expr = *expr_p;\n-  tree ctype = TREE_TYPE (expr);\n-  tree addr_expr = TREE_OPERAND (expr, 0);\n-  tree atype = TREE_TYPE (addr_expr);\n-  tree dctype, datype, ddatype, otype, obj_expr;\n-\n-  /* Both cast and addr_expr types should be pointers.  */\n-  if (!POINTER_TYPE_P (ctype) || !POINTER_TYPE_P (atype))\n-    return;\n-\n-  /* The addr_expr type should be a pointer to an array.  */\n-  datype = TREE_TYPE (atype);\n-  if (TREE_CODE (datype) != ARRAY_TYPE)\n-    return;\n-\n-  /* Both cast and addr_expr types should address the same object type.  */\n-  dctype = TREE_TYPE (ctype);\n-  ddatype = TREE_TYPE (datype);\n-  if (!lang_hooks.types_compatible_p (ddatype, dctype))\n-    return;\n-\n-  /* The addr_expr and the object type should match.  */\n-  obj_expr = TREE_OPERAND (addr_expr, 0);\n-  otype = TREE_TYPE (obj_expr);\n-  if (!lang_hooks.types_compatible_p (otype, datype))\n-    return;\n-\n-  /* The lower bound and element sizes must be constant.  */\n-  if (TREE_CODE (TYPE_SIZE_UNIT (dctype)) != INTEGER_CST\n-      || !TYPE_DOMAIN (datype) || !TYPE_MIN_VALUE (TYPE_DOMAIN (datype))\n-      || TREE_CODE (TYPE_MIN_VALUE (TYPE_DOMAIN (datype))) != INTEGER_CST)\n-    return;\n-\n-  /* All checks succeeded.  Build a new node to merge the cast.  */\n-  *expr_p = build4 (ARRAY_REF, dctype, obj_expr,\n-\t\t    TYPE_MIN_VALUE (TYPE_DOMAIN (datype)),\n-\t\t    TYPE_MIN_VALUE (TYPE_DOMAIN (datype)),\n-\t\t    size_binop (EXACT_DIV_EXPR, TYPE_SIZE_UNIT (dctype),\n-\t\t\t\tsize_int (TYPE_ALIGN (dctype)\n-\t\t\t\t\t  / BITS_PER_UNIT)));\n-  *expr_p = build1 (ADDR_EXPR, ctype, *expr_p);\n-}\n-\n-/* *EXPR_P is a NOP_EXPR or CONVERT_EXPR.  Remove it and/or other conversions\n-   underneath as appropriate.  */\n-\n-static enum gimplify_status\n-gimplify_conversion (tree *expr_p)\n-{  \n-  /* Strip away as many useless type conversions as possible\n-     at the toplevel.  */\n-  STRIP_USELESS_TYPE_CONVERSION (*expr_p);\n-\n-  /* If we still have a conversion at the toplevel, then strip\n-     away all but the outermost conversion.  */\n-  if (TREE_CODE (*expr_p) == NOP_EXPR || TREE_CODE (*expr_p) == CONVERT_EXPR)\n-    {\n-      STRIP_SIGN_NOPS (TREE_OPERAND (*expr_p, 0));\n-\n-      /* And remove the outermost conversion if it's useless.  */\n-      if (tree_ssa_useless_type_conversion (*expr_p))\n-\t*expr_p = TREE_OPERAND (*expr_p, 0);\n-    }\n-\n-  /* If we still have a conversion at the toplevel,\n-     then canonicalize some constructs.  */\n-  if (TREE_CODE (*expr_p) == NOP_EXPR || TREE_CODE (*expr_p) == CONVERT_EXPR)\n-    {\n-      tree sub = TREE_OPERAND (*expr_p, 0);\n-\n-      /* If a NOP conversion is changing the type of a COMPONENT_REF\n-\t expression, then canonicalize its type now in order to expose more\n-\t redundant conversions.  */\n-      if (TREE_CODE (sub) == COMPONENT_REF)\n-\tcanonicalize_component_ref (&TREE_OPERAND (*expr_p, 0));\n-\n-      /* If a NOP conversion is changing a pointer to array of foo\n-\t to a pointer to foo, embed that change in the ADDR_EXPR.  */\n-      else if (TREE_CODE (sub) == ADDR_EXPR)\n-\tcanonicalize_addr_expr (expr_p);\n-    }\n+      /* If a NOP conversion is changing a pointer to array of foo\n+\t to a pointer to foo, embed that change in the ADDR_EXPR.  */\n+      else if (TREE_CODE (sub) == ADDR_EXPR)\n+\tcanonicalize_addr_expr (expr_p);\n+    }\n \n   return GS_OK;\n }\n@@ -2490,107 +2213,526 @@ gimplify_cond_expr (tree *expr_p, tree *pre_p, tree target)\n   tree tmp, type;\n   enum gimplify_status ret;\n \n-  type = TREE_TYPE (expr);\n-  if (!type)\n-    TREE_TYPE (expr) = void_type_node;\n+  type = TREE_TYPE (expr);\n+  if (!type)\n+    TREE_TYPE (expr) = void_type_node;\n+\n+  /* If this COND_EXPR has a value, copy the values into a temporary within\n+     the arms.  */\n+  else if (! VOID_TYPE_P (type))\n+    {\n+      if (target)\n+\t{\n+\t  tmp = target;\n+\t  ret = GS_OK;\n+\t}\n+      else\n+\t{\n+\t  tmp = create_tmp_var (TREE_TYPE (expr), \"iftmp\");\n+\t  ret = GS_ALL_DONE;\n+\t}\n+\n+      /* Build the then clause, 't1 = a;'.  But don't build an assignment\n+\t if this branch is void; in C++ it can be, if it's a throw.  */\n+      if (TREE_TYPE (TREE_OPERAND (expr, 1)) != void_type_node)\n+\tTREE_OPERAND (expr, 1)\n+\t  = build (MODIFY_EXPR, void_type_node, tmp, TREE_OPERAND (expr, 1));\n+\n+      /* Build the else clause, 't1 = b;'.  */\n+      if (TREE_TYPE (TREE_OPERAND (expr, 2)) != void_type_node)\n+\tTREE_OPERAND (expr, 2)\n+\t  = build (MODIFY_EXPR, void_type_node, tmp, TREE_OPERAND (expr, 2));\n+\n+      TREE_TYPE (expr) = void_type_node;\n+      recalculate_side_effects (expr);\n+\n+      /* Move the COND_EXPR to the prequeue and use the temp in its place.  */\n+      gimplify_and_add (expr, pre_p);\n+      *expr_p = tmp;\n+\n+      return ret;\n+    }\n+\n+  /* Make sure the condition has BOOLEAN_TYPE.  */\n+  TREE_OPERAND (expr, 0) = gimple_boolify (TREE_OPERAND (expr, 0));\n+\n+  /* Break apart && and || conditions.  */\n+  if (TREE_CODE (TREE_OPERAND (expr, 0)) == TRUTH_ANDIF_EXPR\n+      || TREE_CODE (TREE_OPERAND (expr, 0)) == TRUTH_ORIF_EXPR)\n+    {\n+      expr = shortcut_cond_expr (expr);\n+\n+      if (expr != *expr_p)\n+\t{\n+\t  *expr_p = expr;\n+\n+\t  /* We can't rely on gimplify_expr to re-gimplify the expanded\n+\t     form properly, as cleanups might cause the target labels to be\n+\t     wrapped in a TRY_FINALLY_EXPR.  To prevent that, we need to\n+\t     set up a conditional context.  */\n+\t  gimple_push_condition ();\n+\t  gimplify_stmt (expr_p);\n+\t  gimple_pop_condition (pre_p);\n+\n+\t  return GS_ALL_DONE;\n+\t}\n+    }\n+\n+  /* Now do the normal gimplification.  */\n+  ret = gimplify_expr (&TREE_OPERAND (expr, 0), pre_p, NULL,\n+\t\t       is_gimple_condexpr, fb_rvalue);\n+\n+  gimple_push_condition ();\n+\n+  gimplify_to_stmt_list (&TREE_OPERAND (expr, 1));\n+  gimplify_to_stmt_list (&TREE_OPERAND (expr, 2));\n+  recalculate_side_effects (expr);\n+\n+  gimple_pop_condition (pre_p);\n+\n+  if (ret == GS_ERROR)\n+    ;\n+  else if (TREE_SIDE_EFFECTS (TREE_OPERAND (expr, 1)))\n+    ret = GS_ALL_DONE;\n+  else if (TREE_SIDE_EFFECTS (TREE_OPERAND (expr, 2)))\n+    /* Rewrite \"if (a); else b\" to \"if (!a) b\"  */\n+    {\n+      TREE_OPERAND (expr, 0) = invert_truthvalue (TREE_OPERAND (expr, 0));\n+      ret = gimplify_expr (&TREE_OPERAND (expr, 0), pre_p, NULL,\n+\t\t\t   is_gimple_condexpr, fb_rvalue);\n+\n+      tmp = TREE_OPERAND (expr, 1);\n+      TREE_OPERAND (expr, 1) = TREE_OPERAND (expr, 2);\n+      TREE_OPERAND (expr, 2) = tmp;\n+    }\n+  else\n+    /* Both arms are empty; replace the COND_EXPR with its predicate.  */\n+    expr = TREE_OPERAND (expr, 0);\n+\n+  *expr_p = expr;\n+  return ret;\n+}\n+\n+/* A subroutine of gimplify_modify_expr.  Replace a MODIFY_EXPR with\n+   a call to __builtin_memcpy.  */\n+\n+static enum gimplify_status\n+gimplify_modify_expr_to_memcpy (tree *expr_p, bool want_value)\n+{\n+  tree args, t, to, to_ptr, from;\n+\n+  to = TREE_OPERAND (*expr_p, 0);\n+  from = TREE_OPERAND (*expr_p, 1);\n+\n+  t = TYPE_SIZE_UNIT (TREE_TYPE (to));\n+  t = SUBSTITUTE_PLACEHOLDER_IN_EXPR (t, to);\n+  t = SUBSTITUTE_PLACEHOLDER_IN_EXPR (t, from);\n+  t = unshare_expr (t);\n+  args = tree_cons (NULL, t, NULL);\n+\n+  t = build_fold_addr_expr (from);\n+  args = tree_cons (NULL, t, args);\n+\n+  to_ptr = build_fold_addr_expr (to);\n+  args = tree_cons (NULL, to, args);\n+  t = implicit_built_in_decls[BUILT_IN_MEMCPY];\n+  t = build_function_call_expr (t, args);\n+\n+  if (want_value)\n+    {\n+      t = build1 (NOP_EXPR, TREE_TYPE (to_ptr), t);\n+      t = build1 (INDIRECT_REF, TREE_TYPE (to), t);\n+    }\n+\n+  *expr_p = t;\n+  return GS_OK;\n+}\n+\n+/* A subroutine of gimplify_modify_expr.  Replace a MODIFY_EXPR with\n+   a call to __builtin_memset.  In this case we know that the RHS is\n+   a CONSTRUCTOR with an empty element list.  */\n+\n+static enum gimplify_status\n+gimplify_modify_expr_to_memset (tree *expr_p, bool want_value)\n+{\n+  tree args, t, to, to_ptr;\n+\n+  to = TREE_OPERAND (*expr_p, 0);\n+\n+  t = TYPE_SIZE_UNIT (TREE_TYPE (to));\n+  t = SUBSTITUTE_PLACEHOLDER_IN_EXPR (t, to);\n+  t = unshare_expr (t);\n+  args = tree_cons (NULL, t, NULL);\n+\n+  args = tree_cons (NULL, integer_zero_node, args);\n+\n+  to_ptr = build_fold_addr_expr (to);\n+  args = tree_cons (NULL, to, args);\n+  t = implicit_built_in_decls[BUILT_IN_MEMSET];\n+  t = build_function_call_expr (t, args);\n+\n+  if (want_value)\n+    {\n+      t = build1 (NOP_EXPR, TREE_TYPE (to_ptr), t);\n+      t = build1 (INDIRECT_REF, TREE_TYPE (to), t);\n+    }\n+\n+  *expr_p = t;\n+  return GS_OK;\n+}\n+\n+/* A subroutine of gimplify_modify_expr.  Break out elements of a\n+   CONSTRUCTOR used as an initializer into separate MODIFY_EXPRs.\n+\n+   Note that we still need to clear any elements that don't have explicit\n+   initializers, so if not all elements are initialized we keep the\n+   original MODIFY_EXPR, we just remove all of the constructor elements.  */\n+\n+static enum gimplify_status\n+gimplify_init_constructor (tree *expr_p, tree *pre_p,\n+\t\t\t   tree *post_p, bool want_value)\n+{\n+  tree object = TREE_OPERAND (*expr_p, 0);\n+  tree ctor = TREE_OPERAND (*expr_p, 1);\n+  tree type = TREE_TYPE (ctor);\n+  enum gimplify_status ret;\n+  tree elt_list;\n+\n+  if (TREE_CODE (ctor) != CONSTRUCTOR)\n+    return GS_UNHANDLED;\n+\n+  elt_list = CONSTRUCTOR_ELTS (ctor);\n+\n+  ret = GS_ALL_DONE;\n+  switch (TREE_CODE (type))\n+    {\n+    case RECORD_TYPE:\n+    case UNION_TYPE:\n+    case QUAL_UNION_TYPE:\n+    case ARRAY_TYPE:\n+      {\n+\tHOST_WIDE_INT i, num_elements, num_nonzero_elements;\n+\tHOST_WIDE_INT num_nonconstant_elements;\n+\tbool cleared;\n+\n+\t/* Aggregate types must lower constructors to initialization of\n+\t   individual elements.  The exception is that a CONSTRUCTOR node\n+\t   with no elements indicates zero-initialization of the whole.  */\n+\tif (elt_list == NULL)\n+\t  {\n+\t    if (want_value)\n+\t      {\n+\t\t*expr_p = object;\n+\t\treturn GS_OK;\n+\t      }\n+\t    else\n+\t      return GS_UNHANDLED;\n+\t  }\n+\n+\tcategorize_ctor_elements (ctor, &num_nonzero_elements,\n+\t\t\t\t  &num_nonconstant_elements);\n+\tnum_elements = count_type_elements (TREE_TYPE (ctor));\n+\n+\t/* If a const aggregate variable is being initialized, then it\n+\t   should never be a lose to promote the variable to be static.  */\n+\tif (num_nonconstant_elements == 0\n+\t    && TREE_READONLY (object)\n+\t    && TREE_CODE (object) == VAR_DECL)\n+\t  {\n+\t    DECL_INITIAL (object) = ctor;\n+\t    TREE_STATIC (object) = 1;\n+\t    if (!DECL_NAME (object))\n+\t      DECL_NAME (object) = create_tmp_var_name (\"C\");\n+\t    walk_tree (&DECL_INITIAL (object), force_labels_r, NULL, NULL);\n+\n+\t    /* ??? C++ doesn't automatically append a .<number> to the\n+\t       assembler name, and even when it does, it looks a FE private\n+\t       data structures to figure out what that number should be,\n+\t       which are not set for this variable.  I suppose this is\n+\t       important for local statics for inline functions, which aren't\n+\t       \"local\" in the object file sense.  So in order to get a unique\n+\t       TU-local symbol, we must invoke the lhd version now.  */\n+\t    lhd_set_decl_assembler_name (object);\n+\n+\t    *expr_p = NULL_TREE;\n+\t    break;\n+\t  }\n+\n+\t/* If there are \"lots\" of initialized elements, and all of them\n+\t   are valid address constants, then the entire initializer can\n+\t   be dropped to memory, and then memcpy'd out.  */\n+\tif (num_nonconstant_elements == 0)\n+\t  {\n+\t    HOST_WIDE_INT size = int_size_in_bytes (type);\n+\t    unsigned int align;\n+\n+\t    /* ??? We can still get unbounded array types, at least\n+\t       from the C++ front end.  This seems wrong, but attempt\n+\t       to work around it for now.  */\n+\t    if (size < 0)\n+\t      {\n+\t\tsize = int_size_in_bytes (TREE_TYPE (object));\n+\t\tif (size >= 0)\n+\t\t  TREE_TYPE (ctor) = type = TREE_TYPE (object);\n+\t      }\n+\n+\t    /* Find the maximum alignment we can assume for the object.  */\n+\t    /* ??? Make use of DECL_OFFSET_ALIGN.  */\n+\t    if (DECL_P (object))\n+\t      align = DECL_ALIGN (object);\n+\t    else\n+\t      align = TYPE_ALIGN (type);\n+\n+\t    if (size > 0 && !can_move_by_pieces (size, align))\n+\t      {\n+\t\ttree new = create_tmp_var_raw (type, \"C\");\n+\t\tgimple_add_tmp_var (new);\n+\t\tTREE_STATIC (new) = 1;\n+\t\tTREE_READONLY (new) = 1;\n+\t\tDECL_INITIAL (new) = ctor;\n+\t\tif (align > DECL_ALIGN (new))\n+\t\t  {\n+\t\t    DECL_ALIGN (new) = align;\n+\t\t    DECL_USER_ALIGN (new) = 1;\n+\t\t  }\n+\t        walk_tree (&DECL_INITIAL (new), force_labels_r, NULL, NULL);\n+\n+\t\tTREE_OPERAND (*expr_p, 1) = new;\n+\t\tbreak;\n+\t      }\n+\t  }\n+\n+\t/* If there are \"lots\" of initialized elements, even discounting\n+\t   those that are not address constants (and thus *must* be \n+\t   computed at runtime), then partition the constructor into\n+\t   constant and non-constant parts.  Block copy the constant\n+\t   parts in, then generate code for the non-constant parts.  */\n+\t/* TODO.  There's code in cp/typeck.c to do this.  */\n+\n+\t/* If there are \"lots\" of zeros, then block clear the object first.  */\n+\tcleared = false;\n+\tif (num_elements - num_nonzero_elements > CLEAR_RATIO\n+\t    && num_nonzero_elements < num_elements/4)\n+\t  cleared = true;\n+\n+\t/* ??? This bit ought not be needed.  For any element not present\n+\t   in the initializer, we should simply set them to zero.  Except\n+\t   we'd need to *find* the elements that are not present, and that\n+\t   requires trickery to avoid quadratic compile-time behavior in\n+\t   large cases or excessive memory use in small cases.  */\n+\telse\n+\t  {\n+\t    HOST_WIDE_INT len = list_length (elt_list);\n+\t    if (TREE_CODE (type) == ARRAY_TYPE)\n+\t      {\n+\t\ttree nelts = array_type_nelts (type);\n+\t\tif (!host_integerp (nelts, 1)\n+\t\t    || tree_low_cst (nelts, 1) != len)\n+\t\t  cleared = 1;;\n+\t      }\n+\t    else if (len != fields_length (type))\n+\t      cleared = 1;\n+\t  }\n+\n+\tif (cleared)\n+\t  {\n+\t    /* Zap the CONSTRUCTOR element list, which simplifies this case.\n+\t       Note that we still have to gimplify, in order to handle the\n+\t       case of variable sized types.  */\n+\t    CONSTRUCTOR_ELTS (ctor) = NULL_TREE;\n+\t    gimplify_stmt (expr_p);\n+\t    append_to_statement_list (*expr_p, pre_p);\n+\t  }\n+\n+\tfor (i = 0; elt_list; i++, elt_list = TREE_CHAIN (elt_list))\n+\t  {\n+\t    tree purpose, value, cref, init;\n+\n+\t    purpose = TREE_PURPOSE (elt_list);\n+\t    value = TREE_VALUE (elt_list);\n+\n+\t    if (cleared && initializer_zerop (value))\n+\t      continue;\n+\n+\t    if (TREE_CODE (type) == ARRAY_TYPE)\n+\t      {\n+\t\ttree t = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (object)));\n+\n+\t\t/* ??? Here's to hoping the front end fills in all of the\n+\t\t   indicies, so we don't have to figure out what's missing\n+\t\t   ourselves.  */\n+\t\tif (!purpose)\n+\t\t  abort ();\n+\t\t/* ??? Need to handle this.  */\n+\t\tif (TREE_CODE (purpose) == RANGE_EXPR)\n+\t\t  abort ();\n+\n+\t\tcref = build (ARRAY_REF, t, object, purpose,\n+\t\t\t      NULL_TREE, NULL_TREE);\n+\t      }\n+\t    else\n+\t      cref = build (COMPONENT_REF, TREE_TYPE (purpose), object,\n+\t\t\t    purpose, NULL_TREE);\n+\n+\t    init = build (MODIFY_EXPR, TREE_TYPE (purpose), cref, value);\n+\n+\t    /* Each member initialization is a full-expression.  */\n+\t    gimplify_and_add (init, pre_p);\n+\t  }\n+\n+\t*expr_p = NULL_TREE;\n+      }\n+      break;\n+\n+    case COMPLEX_TYPE:\n+      {\n+\ttree r, i;\n+\n+\t/* Extract the real and imaginary parts out of the ctor.  */\n+\tr = i = NULL_TREE;\n+\tif (elt_list)\n+\t  {\n+\t    r = TREE_VALUE (elt_list);\n+\t    elt_list = TREE_CHAIN (elt_list);\n+\t    if (elt_list)\n+\t      {\n+\t\ti = TREE_VALUE (elt_list);\n+\t\tif (TREE_CHAIN (elt_list))\n+\t\t  abort ();\n+\t      }\n+\t  }\n+\tif (r == NULL || i == NULL)\n+\t  {\n+\t    tree zero = convert (TREE_TYPE (type), integer_zero_node);\n+\t    if (r == NULL)\n+\t      r = zero;\n+\t    if (i == NULL)\n+\t      i = zero;\n+\t  }\n+\n+\t/* Complex types have either COMPLEX_CST or COMPLEX_EXPR to\n+\t   represent creation of a complex value.  */\n+\tif (TREE_CONSTANT (r) && TREE_CONSTANT (i))\n+\t  {\n+\t    ctor = build_complex (type, r, i);\n+\t    TREE_OPERAND (*expr_p, 1) = ctor;\n+\t  }\n+\telse\n+\t  {\n+\t    ctor = build (COMPLEX_EXPR, type, r, i);\n+\t    TREE_OPERAND (*expr_p, 1) = ctor;\n+\t    ret = gimplify_expr (&TREE_OPERAND (*expr_p, 1), pre_p, post_p,\n+\t\t\t\t is_gimple_rhs, fb_rvalue);\n+\t  }\n+      }\n+      break;\n \n-  /* If this COND_EXPR has a value, copy the values into a temporary within\n-     the arms.  */\n-  else if (! VOID_TYPE_P (type))\n-    {\n-      if (target)\n-\t{\n-\t  tmp = target;\n-\t  ret = GS_OK;\n-\t}\n+    case VECTOR_TYPE:\n+      /* Go ahead and simplify constant constructors to VECTOR_CST.  */\n+      if (TREE_CONSTANT (ctor))\n+\tTREE_OPERAND (*expr_p, 1) = build_vector (type, elt_list);\n       else\n \t{\n-\t  tmp = create_tmp_var (TREE_TYPE (expr), \"iftmp\");\n-\t  ret = GS_ALL_DONE;\n+\t  /* Vector types use CONSTRUCTOR all the way through gimple\n+\t     compilation as a general initializer.  */\n+\t  for (; elt_list; elt_list = TREE_CHAIN (elt_list))\n+\t    {\n+\t      enum gimplify_status tret;\n+\t      tret = gimplify_expr (&TREE_VALUE (elt_list), pre_p, post_p,\n+\t\t\t\t    is_gimple_constructor_elt, fb_rvalue);\n+\t      if (tret == GS_ERROR)\n+\t\tret = GS_ERROR;\n+\t    }\n \t}\n+      break;\n \n-      /* Build the then clause, 't1 = a;'.  But don't build an assignment\n-\t if this branch is void; in C++ it can be, if it's a throw.  */\n-      if (TREE_TYPE (TREE_OPERAND (expr, 1)) != void_type_node)\n-\tTREE_OPERAND (expr, 1)\n-\t  = build (MODIFY_EXPR, void_type_node, tmp, TREE_OPERAND (expr, 1));\n-\n-      /* Build the else clause, 't1 = b;'.  */\n-      if (TREE_TYPE (TREE_OPERAND (expr, 2)) != void_type_node)\n-\tTREE_OPERAND (expr, 2)\n-\t  = build (MODIFY_EXPR, void_type_node, tmp, TREE_OPERAND (expr, 2));\n-\n-      TREE_TYPE (expr) = void_type_node;\n-      recalculate_side_effects (expr);\n-\n-      /* Move the COND_EXPR to the prequeue and use the temp in its place.  */\n-      gimplify_and_add (expr, pre_p);\n-      *expr_p = tmp;\n+    default:\n+      /* So how did we get a CONSTRUCTOR for a scalar type?  */\n+      abort ();\n+    }\n \n-      return ret;\n+  if (ret == GS_ERROR)\n+    return GS_ERROR;\n+  else if (want_value)\n+    {\n+      append_to_statement_list (*expr_p, pre_p);\n+      *expr_p = object;\n+      return GS_OK;\n     }\n+  else\n+    return GS_ALL_DONE;\n+}\n \n-  /* Make sure the condition has BOOLEAN_TYPE.  */\n-  TREE_OPERAND (expr, 0) = gimple_boolify (TREE_OPERAND (expr, 0));\n+/* Subroutine of gimplify_modify_expr to do simplifications of MODIFY_EXPRs\n+   based on the code of the RHS.  We loop for as long as something changes.  */\n \n-  /* Break apart && and || conditions.  */\n-  if (TREE_CODE (TREE_OPERAND (expr, 0)) == TRUTH_ANDIF_EXPR\n-      || TREE_CODE (TREE_OPERAND (expr, 0)) == TRUTH_ORIF_EXPR)\n-    {\n-      expr = shortcut_cond_expr (expr);\n+static enum gimplify_status\n+gimplify_modify_expr_rhs (tree *expr_p, tree *from_p, tree *to_p, tree *pre_p,\n+\t\t\t  tree *post_p, bool want_value)\n+{\n+  enum gimplify_status ret = GS_OK;\n \n-      if (expr != *expr_p)\n+  while (ret != GS_UNHANDLED)\n+    switch (TREE_CODE (*from_p))\n+      {\n+      case TARGET_EXPR:\n \t{\n-\t  *expr_p = expr;\n+\t  /* If we are initializing something from a TARGET_EXPR, strip the\n+\t     TARGET_EXPR and initialize it directly, if possible.  This can't\n+\t     be done if the initializer is void, since that implies that the\n+\t     temporary is set in some non-trivial way.\n \n-\t  /* We can't rely on gimplify_expr to re-gimplify the expanded\n-\t     form properly, as cleanups might cause the target labels to be\n-\t     wrapped in a TRY_FINALLY_EXPR.  To prevent that, we need to\n-\t     set up a conditional context.  */\n-\t  gimple_push_condition ();\n-\t  gimplify_stmt (expr_p);\n-\t  gimple_pop_condition (pre_p);\n+\t     ??? What about code that pulls out the temp and uses it\n+\t     elsewhere? I think that such code never uses the TARGET_EXPR as\n+\t     an initializer.  If I'm wrong, we'll abort because the temp won't\n+\t     have any RTL.  In that case, I guess we'll need to replace\n+\t     references somehow.  */\n+\t  tree init = TARGET_EXPR_INITIAL (*from_p);\n \n-\t  return GS_ALL_DONE;\n+\t  if (!VOID_TYPE_P (TREE_TYPE (init)))\n+\t    {\n+\t      *from_p = init;\n+\t      ret = GS_OK;\n+\t    }\n+\t  else\n+\t    ret = GS_UNHANDLED;\n \t}\n-    }\n-\n-  /* Now do the normal gimplification.  */\n-  ret = gimplify_expr (&TREE_OPERAND (expr, 0), pre_p, NULL,\n-\t\t       is_gimple_condexpr, fb_rvalue);\n-\n-  gimple_push_condition ();\n+\tbreak;\n \n-  gimplify_to_stmt_list (&TREE_OPERAND (expr, 1));\n-  gimplify_to_stmt_list (&TREE_OPERAND (expr, 2));\n-  recalculate_side_effects (expr);\n+      case COMPOUND_EXPR:\n+\t/* Remove any COMPOUND_EXPR in the RHS so the following cases will be\n+\t   caught.  */\n+\tgimplify_compound_expr (from_p, pre_p, true);\n+\tret = GS_OK;\n+\tbreak;\n \n-  gimple_pop_condition (pre_p);\n+      case CONSTRUCTOR:\n+\t/* If we're initializing from a CONSTRUCTOR, break this into\n+\t   individual MODIFY_EXPRs.  */\n+\treturn gimplify_init_constructor (expr_p, pre_p, post_p, want_value);\n \n-  if (ret == GS_ERROR)\n-    ;\n-  else if (TREE_SIDE_EFFECTS (TREE_OPERAND (expr, 1)))\n-    ret = GS_ALL_DONE;\n-  else if (TREE_SIDE_EFFECTS (TREE_OPERAND (expr, 2)))\n-    /* Rewrite \"if (a); else b\" to \"if (!a) b\"  */\n-    {\n-      TREE_OPERAND (expr, 0) = invert_truthvalue (TREE_OPERAND (expr, 0));\n-      ret = gimplify_expr (&TREE_OPERAND (expr, 0), pre_p, NULL,\n-\t\t\t   is_gimple_condexpr, fb_rvalue);\n+      case COND_EXPR:\n+\t/* If we're assigning from a ?: expression with ADDRESSABLE type, push\n+\t   the assignment down into the branches, since we can't generate a\n+\t   temporary of such a type.  */\n+\tif (TREE_ADDRESSABLE (TREE_TYPE (*from_p)))\n+\t  {\n+\t    *expr_p = *from_p;\n+\t    return gimplify_cond_expr (expr_p, pre_p, *to_p);\n+\t  }\n+\telse\n+\t  ret = GS_UNHANDLED;\n+\tbreak;\n \n-      tmp = TREE_OPERAND (expr, 1);\n-      TREE_OPERAND (expr, 1) = TREE_OPERAND (expr, 2);\n-      TREE_OPERAND (expr, 2) = tmp;\n-    }\n-  else\n-    /* Both arms are empty; replace the COND_EXPR with its predicate.  */\n-    expr = TREE_OPERAND (expr, 0);\n+      default:\n+\tret = GS_UNHANDLED;\n+\tbreak;\n+      }\n \n-  *expr_p = expr;\n   return ret;\n }\n \n-/*  Gimplify the MODIFY_EXPR node pointed by EXPR_P.\n+/* Gimplify the MODIFY_EXPR node pointed by EXPR_P.\n \n       modify_expr\n \t      : varname '=' rhs\n@@ -2628,31 +2770,15 @@ gimplify_modify_expr (tree *expr_p, tree *pre_p, tree *post_p, bool want_value)\n     return ret;\n \n   /* If the value being copied is of variable width, expose the length\n-     if the copy by converting the whole thing to a memcpy.  Note that\n-     we need to do this before gimplifying any of the operands\n+     if the copy by converting the whole thing to a memcpy/memset.\n+     Note that we need to do this before gimplifying any of the operands\n      so that we can resolve any PLACEHOLDER_EXPRs in the size.  */\n   if (TREE_CODE (TYPE_SIZE_UNIT (TREE_TYPE (*to_p))) != INTEGER_CST)\n     {\n-      tree args, t, dest;\n-\n-      t = TYPE_SIZE_UNIT (TREE_TYPE (*to_p));\n-      t = SUBSTITUTE_PLACEHOLDER_IN_EXPR (t, *to_p);\n-      t = SUBSTITUTE_PLACEHOLDER_IN_EXPR (t, *from_p);\n-      t = unshare_expr (t);\n-      args = tree_cons (NULL, t, NULL);\n-      t = build_fold_addr_expr (*from_p);\n-      args = tree_cons (NULL, t, args);\n-      dest = build_fold_addr_expr (*to_p);\n-      args = tree_cons (NULL, dest, args);\n-      t = implicit_built_in_decls[BUILT_IN_MEMCPY];\n-      t = build_function_call_expr (t, args);\n-      if (want_value)\n-\t{\n-\t  t = build1 (NOP_EXPR, TREE_TYPE (dest), t);\n-\t  t = build1 (INDIRECT_REF, TREE_TYPE (*to_p), t);\n-\t}\n-      *expr_p = t;\n-      return GS_OK;\n+      if (TREE_CODE (*from_p) == CONSTRUCTOR)\n+\treturn gimplify_modify_expr_to_memset (expr_p, want_value);\n+      else\n+\treturn gimplify_modify_expr_to_memcpy (expr_p, want_value);\n     }\n \n   ret = gimplify_expr (to_p, pre_p, post_p, is_gimple_lvalue, fb_lvalue);\n@@ -2707,75 +2833,6 @@ gimplify_modify_expr (tree *expr_p, tree *pre_p, tree *post_p, bool want_value)\n   return ret;\n }\n \n-/*  Subroutine of above to do simplifications of MODIFY_EXPRs based on\n-    the code of the RHS.  We loop for as long as we can do something.  */\n-\n-static enum gimplify_status\n-gimplify_modify_expr_rhs (tree *expr_p, tree *from_p, tree *to_p, tree *pre_p,\n-\t\t\t  tree *post_p, bool want_value)\n-{\n-  enum gimplify_status ret = GS_OK;\n-\n-  while (ret != GS_UNHANDLED)\n-    switch (TREE_CODE (*from_p))\n-      {\n-      case TARGET_EXPR:\n-\t{\n-\t  /* If we are initializing something from a TARGET_EXPR, strip the\n-\t     TARGET_EXPR and initialize it directly, if possible.  This can't\n-\t     be done if the initializer is void, since that implies that the\n-\t     temporary is set in some non-trivial way.\n-\n-\t     ??? What about code that pulls out the temp and uses it\n-\t     elsewhere? I think that such code never uses the TARGET_EXPR as\n-\t     an initializer.  If I'm wrong, we'll abort because the temp won't\n-\t     have any RTL.  In that case, I guess we'll need to replace\n-\t     references somehow.  */\n-\t  tree init = TARGET_EXPR_INITIAL (*from_p);\n-\n-\t  if (!VOID_TYPE_P (TREE_TYPE (init)))\n-\t    {\n-\t      *from_p = init;\n-\t      ret = GS_OK;\n-\t    }\n-\t  else\n-\t    ret = GS_UNHANDLED;\n-\t}\n-\tbreak;\n-\n-      case COMPOUND_EXPR:\n-\t/* Remove any COMPOUND_EXPR in the RHS so the following cases will be\n-\t   caught.  */\n-\tgimplify_compound_expr (from_p, pre_p, true);\n-\tret = GS_OK;\n-\tbreak;\n-\n-      case CONSTRUCTOR:\n-\t/* If we're initializing from a CONSTRUCTOR, break this into\n-\t   individual MODIFY_EXPRs.  */\n-\treturn gimplify_init_constructor (expr_p, pre_p, post_p, want_value);\n-\n-      case COND_EXPR:\n-\t/* If we're assigning from a ?: expression with ADDRESSABLE type, push\n-\t   the assignment down into the branches, since we can't generate a\n-\t   temporary of such a type.  */\n-\tif (TREE_ADDRESSABLE (TREE_TYPE (*from_p)))\n-\t  {\n-\t    *expr_p = *from_p;\n-\t    return gimplify_cond_expr (expr_p, pre_p, *to_p);\n-\t  }\n-\telse\n-\t  ret = GS_UNHANDLED;\n-\tbreak;\n-\n-      default:\n-\tret = GS_UNHANDLED;\n-\tbreak;\n-      }\n-\n-  return ret;\n-}\n-\n /*  Gimplify a comparison between two variable-sized objects.  Do this\n     with a call to BUILT_IN_MEMCMP.  */\n "}]}