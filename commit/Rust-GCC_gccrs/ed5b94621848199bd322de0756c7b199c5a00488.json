{"sha": "ed5b94621848199bd322de0756c7b199c5a00488", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQ1Yjk0NjIxODQ4MTk5YmQzMjJkZTA3NTZjN2IxOTljNWEwMDQ4OA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-19T22:07:22Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-19T22:07:22Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r529", "tree": {"sha": "120bc653764a48a350a2dcfe16cb4454eae3a103", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/120bc653764a48a350a2dcfe16cb4454eae3a103"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed5b94621848199bd322de0756c7b199c5a00488", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed5b94621848199bd322de0756c7b199c5a00488", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed5b94621848199bd322de0756c7b199c5a00488", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed5b94621848199bd322de0756c7b199c5a00488/comments", "author": null, "committer": null, "parents": [{"sha": "fd9c4f832dd093fb716b130f217406c23984bed3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd9c4f832dd093fb716b130f217406c23984bed3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd9c4f832dd093fb716b130f217406c23984bed3"}], "stats": {"total": 612, "additions": 417, "deletions": 195}, "files": [{"sha": "320ac7d47df909cadd8979c908b959d787ad7fcc", "filename": "gcc/collect2.c", "status": "modified", "additions": 417, "deletions": 195, "changes": 612, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed5b94621848199bd322de0756c7b199c5a00488/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed5b94621848199bd322de0756c7b199c5a00488/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=ed5b94621848199bd322de0756c7b199c5a00488", "patch": "@@ -29,31 +29,90 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include <sys/types.h>\n #include <stdio.h>\n #include <string.h>\n-#include <stdlib.h>\n #include <ctype.h>\n-#include \"gstddef.h\"\n #include <errno.h>\n #include <signal.h>\n #include <sys/file.h>\n #include <sys/stat.h>\n #include <sys/wait.h>\n \n+#ifndef errno\n+extern int errno;\n+#endif\n+\n #define COLLECT\n \n #include \"config.h\"\n \n #ifndef __STDC__\n #include \"gvarargs.h\"\n #define generic char\n-#define PROTO(x) ()\n #define const\n \n #else\n-#include \"stdarg.h\"\n+#include \"gstdarg.h\"\n #define generic void\n-#define PROTO(x) x\n #endif\n \n+#ifdef USG\n+#define vfork fork\n+#endif\n+\n+#ifndef R_OK\n+#define R_OK 4\n+#define W_OK 2\n+#define X_OK 1\n+#endif\n+\n+/* On MSDOS, write temp files in current dir\n+   because there's no place else we can expect to use.  */\n+#if __MSDOS__\n+#ifndef P_tmpdir\n+#define P_tmpdir \"./\"\n+#endif\n+#endif\n+\f\n+/* On certain systems, we have code that works by scanning the object file\n+   directly.  But this code uses system-specific header files and library\n+   functions, so turn it off in a cross-compiler.  */\n+\n+#ifdef CROSS_COMPILE\n+#undef OBJECT_FORMAT_COFF\n+#undef OBJECT_FORMAT_ROSE\n+#endif\n+\n+/* If we can't use a special method, use the ordinary one:\n+   run nm to find what symbols are present.\n+   In a cross-compiler, this means you need a cross nm,\n+   but that isn't quite as unpleasant as special headers.  */\n+\n+#if !defined (OBJECT_FORMAT_COFF) && !defined (OBJECT_FORMAT_ROSE)\n+#define OBJECT_FORMAT_NONE\n+#endif\n+\n+#ifdef OBJECT_FORMAT_COFF\n+\n+#include <a.out.h>\n+#include <ar.h>\n+\n+#ifdef UMAX\n+#include <sgs.h>\n+#endif\n+\n+#ifdef _AIX\n+#define ISCOFF(magic) \\\n+  ((magic) == U802WRMAGIC || (magic) == U802ROMAGIC || (magic) == U802TOCMAGIC)\n+#endif\n+\n+#if defined (_AIX) || defined (USG)\n+#undef FREAD\n+#undef FWRITE\n+#endif\n+\n+#include <ldfcn.h>\n+\n+#endif /* OBJECT_FORMAT_COFF */\n+\n #ifdef OBJECT_FORMAT_ROSE\n \n #ifdef _OSF_SOURCE\n@@ -69,25 +128,17 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include <mach_o_header.h>\n #include <mach_o_vals.h>\n #include <mach_o_types.h>\n+\n #endif /* OBJECT_FORMAT_ROSE */\n \n+#ifdef OBJECT_FORMAT_NONE\n+\n /* Default flags to pass to nm.  */\n #ifndef NM_FLAGS\n #define NM_FLAGS \"-p\"\n #endif\n \n-#ifdef USG\n-#define vfork fork\n-#endif\n-\n-/* On MSDOS, write temp files in current dir\n-   because there's no place else we can expect to use.  */\n-#if __MSDOS__\n-#ifndef P_tmpdir\n-#define P_tmpdir \"./\"\n-#endif\n-#endif\n-\n+#endif /* OBJECT_FORMAT_NONE */\n \f\n /* Linked lists of constructor and destructor names. */\n \n@@ -112,7 +163,9 @@ enum pass {\n   PASS_SECOND\t\t\t\t/* with constructors linked in */\n };\n \n+#ifndef NO_SYS_SIGLIST\n extern char *sys_siglist[];\n+#endif\n extern char *version_string;\n \n static int vflag;\t\t\t/* true if -v */\n@@ -129,27 +182,27 @@ static char *nm_file_name;\t\t/* pathname of nm */\n static struct head constructors;\t/* list of constructors found */\n static struct head destructors;\t\t/* list of destructors found */\n \n-extern char *getenv\t\tPROTO((\tconst char * ));\n-extern char *mktemp\t\tPROTO((\tchar * ));\n-extern int   vfork\t\tPROTO(( void ));\n-static void  add_to_list\tPROTO((\tstruct head *headp, char *name ));\n-static void  scan_prog_file\tPROTO((\tchar *, enum pass ));\n-static void  fork_execute\tPROTO((\tchar *, char **argv ));\n-static void  do_wait\t\tPROTO((\tchar * ));\n-static void  write_c_file\tPROTO((\tFILE *, char * ));\n-static void  my_exit\t\tPROTO(( int ));\n-static void  handler\t\tPROTO(( int ));\n-static void  maybe_unlink\tPROTO(( char * ));\n-static void  choose_temp_base\tPROTO(( void ));\n-\n-generic\t\t*xcalloc\tPROTO((\tsize_t, size_t ));\n-generic\t\t*xmalloc\tPROTO((\tsize_t ));\n-\n+extern char *getenv ();\n+extern char *mktemp ();\n+extern int   vfork ();\n+static void  add_to_list ();\n+static void  scan_prog_file ();\n+static void  fork_execute ();\n+static void  do_wait ();\n+static void  write_c_file ();\n+static void  my_exit ();\n+static void  handler ();\n+static void  maybe_unlink ();\n+static void  choose_temp_base ();\n+\n+generic *xcalloc ();\n+generic *xmalloc ();\n \f\n \n #if !defined(HAVE_STRERROR) && !defined(_OSF_SOURCE)\n \n-char *strerror (e)\n+char *\n+strerror (e)\n      int e;\n {\n   extern char *sys_errlist[];\n@@ -175,10 +228,10 @@ static void\n my_exit (status)\n      int status;\n {\n-  if (c_file[0])\n+  if (c_file != 0 && c_file[0])\n     maybe_unlink (c_file);\n \n-  if (o_file[0])\n+  if (o_file != 0 && o_file[0])\n     maybe_unlink (o_file);\n \n   exit (status);\n@@ -309,17 +362,15 @@ handler (signo)\n     maybe_unlink (o_file);\n \n   signal (signo, SIG_DFL);\n-\n-  fatal (\"Caught signal %d [%s]\", signo, sys_siglist[signo]);\n   kill (getpid (), signo);\n }\n \n \f\n generic *\n xcalloc (size1, size2)\n-     size_t size1, size2;\n+     int size1, size2;\n {\n-  generic *ptr = calloc (size1, size2);\n+  generic *ptr = (generic *) calloc (size1, size2);\n   if (ptr)\n     return ptr;\n \n@@ -329,22 +380,78 @@ xcalloc (size1, size2)\n \n generic *\n xmalloc (size)\n-     size_t size;\n+     int size;\n {\n-  generic *ptr = malloc (size);\n+  generic *ptr = (generic *) malloc (size);\n   if (ptr)\n     return ptr;\n \n   fatal (\"Out of memory.\");\n   return (generic *)0;\n }\n \n+/* Make a copy of a string INPUT with size SIZE.  */\n+\n+char *\n+savestring (input, size)\n+     char *input;\n+     int size;\n+{\n+  char *output = (char *) xmalloc (size + 1);\n+  strcpy (output, input);\n+  return output;\n+}\n+\f\n+/* Decide whether the given symbol is:\n+   a constructor (1), a destructor (2), or neither (0).  */\n+\n+static int\n+is_ctor_dtor (s)\n+     char *s;\n+{\n+  struct names { char *name; int len; int ret; int two_underscores; };\n+\n+  register struct names *p;\n+  register int ch;\n+  register char *orig_s = s;\n+\n+  static struct names special[] = {\n+#ifdef NO_DOLLAR_IN_LABEL\n+    { \"GLOBAL_.I.\", sizeof (\"GLOBAL_.I.\")-1, 1, 0 },\n+    { \"GLOBAL_.D.\", sizeof (\"GLOBAL_.D.\")-1, 2, 0 },\n+#else\n+    { \"GLOBAL_$I$\", sizeof (\"GLOBAL_$I$\")-1, 1, 0 },\n+    { \"GLOBAL_$D$\", sizeof (\"GLOBAL_$I$\")-1, 2, 0 },\n+#endif\n+    { \"sti__\", sizeof (\"sti__\")-1, 1, 1 },\n+    { \"std__\", sizeof (\"std__\")-1, 2, 1 },\n+    { NULL, 0, 0, 0 }\n+  };\n+\n+  while ((ch = *s) == '_')\n+    ++s;\n+\n+  if (s == orig_s)\n+    return 0;\n+\n+  for (p = &special[0]; p->len > 0; p++)\n+    {\n+      if (ch == p->name[0]\n+\t  && (!p->two_underscores || ((s - orig_s) >= 2))\n+\t  && strncmp(s, p->name, p->len) == 0)\n+\t{\n+\t  return p->ret;\n+\t}\n+    }\n+  return 0;\n+}\n+\n \f\n /* Compute a string to use as the base of all temporary file names.\n    It is substituted for %g.  */\n \n static void\n-choose_temp_base PROTO((void))\n+choose_temp_base ()\n {\n   char *base = getenv (\"TMPDIR\");\n   int len;\n@@ -388,16 +495,16 @@ main (argc, argv)\n   FILE *outf;\n   char *ld_file_name;\n   char *c_file_name;\n-  char *B_option;\n   char *p;\n   char *prefix;\n-  char **c_argv\t\t= (char **) xcalloc (sizeof (char *), argc+7);\n-  char **c_ptr\t\t= c_argv;\n+  char **c_argv;\n+  char **c_ptr;\n   char **ld1_argv\t= (char **) xcalloc (sizeof (char *), argc+2);\n   char **ld1\t\t= ld1_argv;\n   char **ld2_argv\t= (char **) xcalloc (sizeof (char *), argc+5);\n   char **ld2\t\t= ld2_argv;\n   int first_file;\n+  int num_c_args\t= argc+7;\n   int len;\n   int clen;\n \n@@ -406,6 +513,21 @@ main (argc, argv)\n   vflag = 1;\n #endif\n \n+  p = (char *) getenv (\"COLLECT_GCC_OPTIONS\");\n+  if (p)\n+    while (*p)\n+      {\n+\tchar *q = p;\n+\twhile (*q && *q != ' ') q++;\n+\tif (*p == '-' && (p[1] == 'm' || p[1] == 'f'))\n+\t  num_c_args++;\n+\n+\tif (*q) q++;\n+\tp = q;\n+      }\n+\n+  c_ptr = c_argv = (char **) xcalloc (sizeof (char *), num_c_args);\n+\n   if (argc < 2)\n     fatal (\"no arguments\");\n \n@@ -466,9 +588,7 @@ main (argc, argv)\n #endif\n \n   ld_file_name = xcalloc (len + sizeof (\"real-ld\"), 1);\n-  c_file_name  = xcalloc (clen + sizeof (\"gcc\"), 1);\n   nm_file_name = xcalloc (len + sizeof (\"gnm\"), 1);\n-  B_option     = xcalloc (len + sizeof (\"-B\"), 1);\n \n   memcpy (ld_file_name, prefix, len);\n   strcpy (ld_file_name + len, \"real-ld\");\n@@ -486,23 +606,28 @@ main (argc, argv)\n \t}\n     }\n \n-  memcpy (c_file_name, prefix, len);\n-  strcpy (c_file_name + len, \"gcc\");\n-  if (access (c_file_name, X_OK) < 0)\n+  c_file_name = getenv (\"COLLECT_GCC\");\n+  if (c_file_name == 0 || c_file_name[0] != '/')\n     {\n-#ifdef STANDARD_BIN_PREFIX\n-      strcpy (c_file_name, STANDARD_BIN_PREFIX);\n-      strcat (c_file_name, \"gcc\");\n+      c_file_name = xcalloc (clen + sizeof (\"gcc\"), 1);\n+      memcpy (c_file_name, prefix, len);\n+      strcpy (c_file_name + len, \"gcc\");\n       if (access (c_file_name, X_OK) < 0)\n-#endif\n \t{\n-#ifdef STANDARD_EXEC_PREFIX\n-\t  strcpy (c_file_name, STANDARD_EXEC_PREFIX);\n+#ifdef STANDARD_BIN_PREFIX\n+\t  strcpy (c_file_name, STANDARD_BIN_PREFIX);\n \t  strcat (c_file_name, \"gcc\");\n \t  if (access (c_file_name, X_OK) < 0)\n #endif\n \t    {\n-\t      strcpy (c_file_name, \"gcc\");\n+#ifdef STANDARD_EXEC_PREFIX\n+\t      strcpy (c_file_name, STANDARD_EXEC_PREFIX);\n+\t      strcat (c_file_name, \"gcc\");\n+\t      if (access (c_file_name, X_OK) < 0)\n+#endif\n+\t\t{\n+\t\t  strcpy (c_file_name, \"gcc\");\n+\t\t}\n \t    }\n \t}\n     }\n@@ -523,9 +648,6 @@ main (argc, argv)\n \t}\n     }\n \n-  strcpy (B_option, \"-B\");\n-  strcpy (B_option + sizeof (\"-B\") - 1, prefix);\n-\n   *ld1++ = *ld2++ = \"ld\";\n \n   /* Make temp file names. */\n@@ -534,13 +656,21 @@ main (argc, argv)\n   o_file = xcalloc (temp_filename_length + sizeof (\".o\"), 1);\n   sprintf (c_file, \"%s.c\", temp_filename);\n   sprintf (o_file, \"%s.o\", temp_filename);\n-  *c_ptr++ = \"gcc\";\n+  *c_ptr++ = c_file_name;\n   *c_ptr++ = \"-c\";\n   *c_ptr++ = \"-o\";\n   *c_ptr++ = o_file;\n \n+  /* !!! When GCC calls collect2,\n+     it does not know whether it is calling collect2 or ld.\n+     So collect2 cannot meaningfully understand any options\n+     except those ld understands.\n+     If you propose to make GCC pass some other option,\n+     just imagine what will happen if ld is really ld!!!  */\n+\n   /* Parse arguments.  Remember output file spec, pass the rest to ld. */\n-  /* After the first file, put in the c++ rt0 */\n+  /* After the first file, put in the c++ rt0.  */\n+\n   first_file = 1;\n   while ((arg = *++argv) != (char *)0)\n     {\n@@ -559,22 +689,6 @@ main (argc, argv)\n \t\t}\n \t      break;\n \n-\t      /* pass -f<xxx>, -B<xxx>, -b<xxx>, -V<xxx>, and -m<xxx>\n-\t\t options to gcc.  This allows options to be passed\n-\t\t that affect search rules, and the size of pointers. */\n-\t    case 'b':\n-\t    case 'B':\n-\t    case 'f':\n-\t    case 'm':\n-\t    case 'V':\n-\t      if (arg[1] != '\\0')\n-\t\t{\n-\t\t  ld1--;\n-\t\t  ld2--;\n-\t\t  *c_ptr++ = arg;\n-\t\t}\n-\t      break;\n-\n \t    case 'o':\n \t      outfile = (arg[2] == '\\0') ? argv[1] : &arg[2];\n \t      break;\n@@ -599,13 +713,26 @@ main (argc, argv)\n \t}\n     }\n \n-  *c_ptr++ = B_option;\n+  /* Get any options that the upper GCC wants to pass to the sub-GCC.  */\n+  p = (char *) getenv (\"COLLECT_GCC_OPTIONS\");\n+  if (p)\n+    while (*p)\n+      {\n+\tchar *q = p;\n+\twhile (*q && *q != ' ') q++;\n+\tif (*p == '-' && (p[1] == 'm' || p[1] == 'f'))\n+\t  *c_ptr++ = savestring (p, q - p);\n+\n+\tif (*q) q++;\n+\tp = q;\n+      }\n+\n   *c_ptr++ = c_file;\n   *c_ptr = *ld1 = *ld2 = (char *)0;\n \n   if (vflag)\n     {\n-      fprintf (stderr, \"GNU COLLECT2 version %s\", version_string);\n+      fprintf (stderr, \"collect2 version %s\", version_string);\n #ifdef TARGET_VERSION\n       TARGET_VERSION;\n #endif\n@@ -614,13 +741,31 @@ main (argc, argv)\n \n   if (debug)\n     {\n-      fprintf (stderr, \"prefix       = %s\\n\", prefix);\n-      fprintf (stderr, \"ld_file_name = %s\\n\", ld_file_name);\n-      fprintf (stderr, \"c_file_name  = %s\\n\", c_file_name);\n-      fprintf (stderr, \"nm_file_name = %s\\n\", nm_file_name);\n-      fprintf (stderr, \"B_option     = %s\\n\", B_option);\n-      fprintf (stderr, \"c_file       = %s\\n\", c_file);\n-      fprintf (stderr, \"o_file       = %s\\n\", o_file);\n+      char *ptr;\n+      fprintf (stderr, \"prefix              = %s\\n\", prefix);\n+      fprintf (stderr, \"ld_file_name        = %s\\n\", ld_file_name);\n+      fprintf (stderr, \"c_file_name         = %s\\n\", c_file_name);\n+      fprintf (stderr, \"nm_file_name        = %s\\n\", nm_file_name);\n+      fprintf (stderr, \"c_file              = %s\\n\", c_file);\n+      fprintf (stderr, \"o_file              = %s\\n\", o_file);\n+\n+      ptr = getenv (\"COLLECT_GCC_OPTIONS\");\n+      if (ptr)\n+\tfprintf (stderr, \"COLLECT_GCC_OPTIONS = %s\\n\", ptr);\n+\n+      ptr = getenv (\"COLLECT_GCC\");\n+      if (ptr)\n+\tfprintf (stderr, \"COLLECT_GCC         = %s\\n\", ptr);\n+\n+      ptr = getenv (\"COMPILER_PATH\");\n+      if (ptr)\n+\tfprintf (stderr, \"COMPILER_PATH       = %s\\n\", ptr);\n+\n+      ptr = getenv (\"LIBRARY_PATH\");\n+      if (ptr)\n+\tfprintf (stderr, \"LIBRARY_PATH        = %s\\n\", ptr);\n+\n+      fprintf (stderr, \"\\n\");\n     }\n \n   /* Load the program, searching all libraries.\n@@ -688,21 +833,28 @@ do_wait (prog)\n   wait (&status);\n   if (status)\n     {\n-      int sig = WTERMSIG (status);\n+      int sig = status & 0x7F;\n       int ret;\n \n       if (sig != -1 && sig != 0)\n \t{\n+#ifdef NO_SYS_SIGLIST\n+\t  error (\"%s terminated with signal %d %s\",\n+\t\t prog,\n+\t\t sig,\n+\t\t (status & 0200) ? \", core dumped\" : \"\");\n+#else\n \t  error (\"%s terminated with signal %d [%s]%s\",\n \t\t prog,\n \t\t sig,\n \t\t sys_siglist[sig],\n \t\t (status & 0200) ? \", core dumped\" : \"\");\n+#endif\n \n \t  my_exit (127);\n \t}\n \n-      ret = WEXITSTATUS (status);\n+      ret = ((status & 0xFF00) >> 8);\n       if (ret != -1 && ret != 0)\n \t{\n \t  error (\"%s returned %d exit status\", prog, ret);\n@@ -720,8 +872,8 @@ fork_execute (prog, argv)\n      char **argv;\n {\n   int pid;\n-  void (*int_handler) PROTO((int));\n-  void (*quit_handler) PROTO((int));\n+  void (*int_handler) ();\n+  void (*quit_handler) ();\n \n   if (vflag || debug)\n     {\n@@ -748,8 +900,8 @@ fork_execute (prog, argv)\n       fatal_perror (\"Execute %s\", prog);\n     }\n \n-  int_handler  = (void (*)PROTO((int)))signal (SIGINT,  SIG_IGN);\n-  quit_handler = (void (*)PROTO((int)))signal (SIGQUIT, SIG_IGN);\n+  int_handler  = (void (*) ())signal (SIGINT,  SIG_IGN);\n+  quit_handler = (void (*) ())signal (SIGQUIT, SIG_IGN);\n \n   do_wait (prog);\n \n@@ -832,30 +984,29 @@ write_c_file (stream, name)\n \n   fprintf (stream, \"typedef void entry_pt();\\n\\n\");\n     \n-  write_list_with_asm (stream, \"entry_pt \", constructors);\n+  write_list_with_asm (stream, \"entry_pt \", constructors.first);\n     \n   fprintf (stream, \"\\nentry_pt * __CTOR_LIST__[] = {\\n\");\n   fprintf (stream, \"\\t(entry_pt *) %d,\\n\", constructors.number);\n-  write_list (stream, \"\\t\", constructors);\n+  write_list (stream, \"\\t\", constructors.first);\n   fprintf (stream, \"\\t0\\n};\\n\\n\");\n \n-  write_list_with_asm (stream, \"entry_pt \", destructors);\n+  write_list_with_asm (stream, \"entry_pt \", destructors.first);\n \n   fprintf (stream, \"\\nentry_pt * __DTOR_LIST__[] = {\\n\");\n   fprintf (stream, \"\\t(entry_pt *) %d,\\n\", destructors.number);\n-  write_list (stream, \"\\t\", destructors);\n+  write_list (stream, \"\\t\", destructors.first);\n   fprintf (stream, \"\\t0\\n};\\n\\n\");\n \n   fprintf (stream, \"extern entry_pt __main;\\n\");\n   fprintf (stream, \"entry_pt *__main_reference = __main;\\n\\n\");\n }\n \n \f\n-#ifndef OBJECT_FORMAT_ROSE\n+#ifdef OBJECT_FORMAT_NONE\n \n-/* OSF/rose specific version to scan the name list of the loaded\n-   program for the symbols g++ uses for static constructors and\n-   destructors.\n+/* Generic version to scan the name list of the loaded program for\n+   the symbols g++ uses for static constructors and destructors.\n \n    The constructor table begins at __CTOR_LIST__ and contains a count\n    of the number of pointers (or -1 if the constructors are built in a\n@@ -868,8 +1019,8 @@ scan_prog_file (prog_name, which_pass)\n      char *prog_name;\n      enum pass which_pass;\n {\n-  void (*int_handler) PROTO((int));\n-  void (*quit_handler) PROTO((int));\n+  void (*int_handler) ();\n+  void (*quit_handler) ();\n   char *nm_argv[4];\n   int pid;\n   int argc = 0;\n@@ -880,12 +1031,12 @@ scan_prog_file (prog_name, which_pass)\n   if (which_pass != PASS_FIRST)\n     return;\n \n-  nm_argv[ argc++ ] = \"nm\";\n+  nm_argv[argc++] = \"nm\";\n   if (NM_FLAGS[0] != '\\0')\n-    nm_argv[ argc++ ] = NM_FLAGS;\n+    nm_argv[argc++] = NM_FLAGS;\n \n-  nm_argv[ argc++ ] = prog_name;\n-  nm_argv[ argc++ ] = (char *)0;\n+  nm_argv[argc++] = prog_name;\n+  nm_argv[argc++] = (char *)0;\n \n   if (pipe (pipe_fd) < 0)\n     fatal_perror (\"pipe\");\n@@ -932,8 +1083,8 @@ scan_prog_file (prog_name, which_pass)\n     }\n \n   /* Parent context from here on.  */\n-  int_handler  = (void (*)PROTO((int)))signal (SIGINT,  SIG_IGN);\n-  quit_handler = (void (*)PROTO((int)))signal (SIGQUIT, SIG_IGN);\n+  int_handler  = (void (*) ())signal (SIGINT,  SIG_IGN);\n+  quit_handler = (void (*) ())signal (SIGQUIT, SIG_IGN);\n \n   if (close (pipe_fd[1]) < 0)\n     fatal_perror (\"Close (%d)\", pipe_fd[1]);\n@@ -945,8 +1096,7 @@ scan_prog_file (prog_name, which_pass)\n   while (fgets (buf, sizeof buf, inf) != (char *)0)\n     {\n       int ch, ch2;\n-      char *start;\n-      char *end;\n+      char *name, *end;\n \n       /* If it contains a constructor or destructor name, add the name\n \t to the appropriate list. */\n@@ -956,42 +1106,29 @@ scan_prog_file (prog_name, which_pass)\n \n       if (ch == '\\0' || ch == '\\n')\n \tcontinue;\n-\n-      start = p;\n-      while ((ch = *p) == '_')\t/* skip any extra '_' inserted */\n-\tp++;\n-\n-      for (end = p; (ch2 = *end) != '\\0' && !isspace (ch2); end++)\n-\t;\n+  \n+      name = p;\n+      /* Find the end of the symbol name.\n+\t Don't include `|', because Encore nm can tack that on the end.  */\n+      for (end = p; (ch2 = *end) != '\\0' && !isspace (ch2) && ch2 != '|';\n+\t   end++)\n+\tcontinue;\n \n       *end = '\\0';\n-      if (ch == 'G')\n+      switch (is_ctor_dtor (name))\n \t{\n-\t  if (! strncmp (p, \"GLOBAL_$I$\", 10))\n-\t    add_to_list (&constructors, p-1);\n+\tcase 1:\n+\t  add_to_list (&constructors, name);\n+\t  break;\n \n-\t  else if (! strncmp (p, \"GLOBAL_$D$\", 10))\n-\t    add_to_list (&destructors, p-1);\n+\tcase 2:\n+\t  add_to_list (&destructors, name);\n+\t  break;\n \n-\t  else\t\t\t\t/* not a constructor or destructor */\n-\t    continue;\n+\tdefault:\t\t/* not a constructor or destructor */\n+\t  continue;\n \t}\n \n-      else if (ch == 's' && (p - start) >= 2)\n-\t{\n-\t  if (! strncmp (p, \"sti__\", 5))\n-\t    add_to_list (&constructors, p-2);\n-\n-\t  else if (! strncmp (p, \"std__\", 5))\n-\t    add_to_list (&destructors, p-2);\n-\n-\t  else\t\t\t\t/* not a constructor or destructor */\n-\t    continue;\n-\t}\n-\n-      else\n-\tcontinue;\n-\n       if (debug)\n \tfprintf (stderr, \"\\t%s\\n\", buf);\n     }\n@@ -1008,7 +1145,115 @@ scan_prog_file (prog_name, which_pass)\n   signal (SIGQUIT, quit_handler);\n }\n \n-#endif /* !OBJECT_FORMAT_ROSE */\n+#endif /* OBJECT_FORMAT_NONE */\n+\n+\f\n+/*\n+ * COFF specific stuff.\n+ */\n+\n+#ifdef OBJECT_FORMAT_COFF\n+\n+#if defined(EXTENDED_COFF)\n+#   define GCC_SYMBOLS(X) (SYMHEADER(X).isymMax+SYMHEADER(X).iextMax)\n+#   define GCC_SYMENT SYMR\n+#   define GCC_OK_SYMBOL(X) ((X).st == stProc && (X).sc == scText)\n+#   define GCC_SYMINC(X) (1)\n+#   define GCC_SYMZERO(X) (SYMHEADER(X).isymMax)\n+#else\n+#   define GCC_SYMBOLS(X) (HEADER(ldptr).f_nsyms)\n+#   define GCC_SYMENT SYMENT\n+#   define GCC_OK_SYMBOL(X) \\\n+     (((X).n_sclass == C_EXT) && \\\n+        (((X).n_type & N_TMASK) == (DT_NON << N_BTSHFT) || \\\n+         ((X).n_type & N_TMASK) == (DT_FCN << N_BTSHFT)))\n+#   define GCC_SYMINC(X) ((X).n_numaux+1)\n+#   define GCC_SYMZERO(X) 0\n+#endif\n+\n+extern char *ldgetname ();\n+\n+/* COFF version to scan the name list of the loaded program for\n+   the symbols g++ uses for static constructors and destructors.\n+\n+   The constructor table begins at __CTOR_LIST__ and contains a count\n+   of the number of pointers (or -1 if the constructors are built in a\n+   separate section by the linker), followed by the pointers to the\n+   constructor functions, terminated with a null pointer.  The\n+   destructor table has the same format, and begins at __DTOR_LIST__.  */\n+\n+static void\n+scan_prog_file (prog_name, which_pass)\n+     char *prog_name;\n+     enum pass which_pass;\n+{\n+  LDFILE *ldptr;\n+  int sym_index, sym_count;\n+\n+  if (which_pass != PASS_FIRST)\n+    return;\n+\n+  if ((ldptr = ldopen (prog_name, ldptr)) == NULL)\n+    fatal (\"%s: can't open as COFF file\", prog_name);\n+      \n+  if (!ISCOFF (HEADER(ldptr).f_magic))\n+    fatal (\"%s: not a COFF file\", prog_name);\n+\n+  sym_count = GCC_SYMBOLS (ldptr);\n+  sym_index = GCC_SYMZERO (ldptr);\n+  while (sym_index < sym_count)\n+    {\n+      GCC_SYMENT symbol;\n+\n+      if (ldtbread (ldptr, sym_index, &symbol) <= 0)\n+\tbreak;\n+      sym_index += GCC_SYMINC (symbol);\n+\n+      if (GCC_OK_SYMBOL (symbol))\n+\t{\n+\t  char *name;\n+\n+\t  if ((name = ldgetname (ldptr, &symbol)) == NULL)\n+\t    continue;\t\t/* should never happen */\n+\n+#ifdef _AIX\n+\t  /* All AIX function names begin with a dot. */\n+\t  if (*name++ != '.')\n+\t    continue;\n+#endif\n+\n+\t  switch (is_ctor_dtor (name))\n+\t    {\n+\t    case 1:\n+\t      add_to_list (&constructors, name);\n+\t      break;\n+\n+\t    case 2:\n+\t      add_to_list (&destructors, name);\n+\t      break;\n+\n+\t    default:\t\t/* not a constructor or destructor */\n+\t      continue;\n+\t    }\n+\n+#if !defined(EXTENDED_COFF)\n+\t  if (debug)\n+\t    fprintf (stderr, \"\\tsec=%d class=%d type=%s%o %s\\n\",\n+\t\t     symbol.n_scnum, symbol.n_sclass,\n+\t\t     (symbol.n_type ? \"0\" : \"\"), symbol.n_type,\n+\t\t     name);\n+#else\n+\t  if (debug)\n+\t    fprintf (stderr, \"\\tiss = %5d, value = %5d, index = %5d, name = %s\\n\",\n+\t\t     symbol.iss, symbol.value, symbol.index, name);\n+#endif\n+\t}\n+    }\n+\n+  (void) ldclose(ldptr);\n+}\n+\n+#endif /* OBJECT_FORMAT_COFF */\n \n \f\n /*\n@@ -1023,7 +1268,7 @@ typedef union load_union\n {\n   ldc_header_t\t\t\thdr;\t/* common header */\n   load_cmd_map_command_t\tmap;\t/* map indexing other load cmds */\n-  interpreter_command_t\t\tiprtr;\t/* interpereter pathname */\n+  interpreter_command_t\t\tiprtr;\t/* interpreter pathname */\n   strings_command_t\t\tstr;\t/* load commands strings section */\n   region_command_t\t\tregion;\t/* region load command */\n   reloc_command_t\t\treloc;\t/* relocation section */\n@@ -1055,31 +1300,21 @@ struct file_info\n   int\tuse_mmap;\t\t\t/* != 0 if mmap'ed */\n };\n \n-extern int decode_mach_o_hdr\t\tPROTO((\tvoid *in_bufp,\n-\t\t\t\t\t\tsize_t in_bufsize,\n-\t\t\t\t\t\tunsigned long hdr_version,\n-\t\t\t\t\t\tmo_header_t *headerp ));\n+extern int decode_mach_o_hdr ();\n \n-extern int encode_mach_o_hdr\t\tPROTO((\tmo_header_t *headerp,\n-\t\t\t\t\t\tvoid *out_bufp,\n-\t\t\t\t\t\tsize_t out_bufsize ));\n+extern int encode_mach_o_hdr ();\n \n-static void bad_header\t\t\tPROTO(( int status ));\n+static void bad_header ();\n \n-static void print_header\t\tPROTO(( mo_header_t *hdr_ptr ));\n+static void print_header ();\n \n-static void print_load_command\t\tPROTO(( load_union_t *load_hdr,\n-\t\t\t\t\t        size_t offset,\n-\t\t\t\t\t        int number ));\n+static void print_load_command ();\n \n-static void add_func_table\t\tPROTO(( mo_header_t *hdr_p,\n-\t\t\t\t\t        load_all_t *load_array,\n-\t\t\t\t\t        symbol_info_t *sym,\n-\t\t\t\t\t        int type ));\n+static void add_func_table ();\n \n-static struct file_info\t*read_file\tPROTO((\tchar *, int, int ));\n+static struct file_info\t*read_file ();\n \n-static void end_file\t\t\tPROTO((\tstruct file_info * ));\n+static void end_file ();\n \n \f\n /* OSF/rose specific version to scan the name list of the loaded\n@@ -1203,7 +1438,7 @@ scan_prog_file (prog_name, which_pass)\n \n \t  if (debug)\n \t    {\n-\t      char *kind = \"uknown\";\n+\t      char *kind = \"unknown\";\n \n \t      switch (load_hdr->sym.symc_kind)\n \t\t{\n@@ -1219,7 +1454,7 @@ scan_prog_file (prog_name, which_pass)\n \t  if (load_hdr->sym.symc_kind != SYMC_DEFINED_SYMBOLS)\n \t    continue;\n \n-\t  str_sect = load_array[ load_hdr->sym.symc_strings_section ].section;\n+\t  str_sect = load_array[load_hdr->sym.symc_strings_section].section;\n \t  if (str_sect == (char *)0)\n \t    fatal (\"string section missing\");\n \n@@ -1231,50 +1466,37 @@ scan_prog_file (prog_name, which_pass)\n \t    {\n \t      symbol_info_t *sym = ((symbol_info_t *) load_cmd->section) + i;\n \t      char *name = sym->si_name.symbol_name + str_sect;\n-\t      char *name_start = name;\n \n \t      if (name[0] != '_')\n \t\tcontinue;\n \n-\t      while (*++name == '_')\t/* skip any extra '_' inserted */\n-\t\t;\n-\n \t      if (rw)\n \t\t{\n-\t\t  if (*name != 'm' || (name - name_start) < 2\n-\t\t      || strcmp (name, \"main\"))\n+\t\t  char *n = name;\n+\t\t  while (*n == '_')\n+\t\t    ++n;\n+\t\t  if (*n != 'm' || (n - name) < 2 || strcmp (n, \"main\"))\n \t\t    continue;\n \n \t\t  main_sym = sym;\n \t\t}\n-\n-\t      else if (*name == 'G')\n-\t\t{\n-\t\t  if (! strncmp (name, \"GLOBAL_$I$\", 10))\n-\t\t    add_to_list (&constructors, name_start);\n-\n-\t\t  else if (! strncmp (name, \"GLOBAL_$D$\", 10))\n-\t\t    add_to_list (&destructors, name_start);\n-\n-\t\t  else\t\t/* not a constructor or destructor */\n-\t\t    continue;\n-\t\t}\n-\n-\t      else if (*name == 's' && (name - name_start) > 2)\n+\t      else\n \t\t{\n-\t\t  if (! strncmp (name, \"sti__\", 5))\n-\t\t    add_to_list (&constructors, name_start);\n-\n-\t\t  else if (! strncmp (name, \"std__\", 5))\n-\t\t    add_to_list (&destructors, name_start);\n-\n-\t\t  else\t\t/* not a constructor or destructor */\n-\t\t    continue;\n+\t\t  switch (is_ctor_dtor (name))\n+\t\t    {\n+\t\t    case 1:\n+\t\t      add_to_list (&constructors, name);\n+\t\t      break;\n+\n+\t\t    case 2:\n+\t\t      add_to_list (&destructors, name);\n+\t\t      break;\n+\n+\t\t    default:\t/* not a constructor or destructor */\n+\t\t      continue;\n+\t\t    }\n \t\t}\n \n-\t      else\n-\t\tcontinue;\n-\n \t      if (debug)\n \t\tfprintf (stderr, \"\\ttype = 0x%.4x, sc = 0x%.2x, flags = 0x%.8x, name = %.30s\\n\",\n \t\t\t sym->si_type, sym->si_sc_type, sym->si_flags, name);\n@@ -1369,7 +1591,7 @@ scan_prog_file (prog_name, which_pass)\n \n \f\n /* Add a function table to the load commands to call a function\n-   on initition or termination of the process.  */\n+   on initiation or termination of the process.  */\n \n static void\n add_func_table (hdr_p, load_array, sym, type)"}]}