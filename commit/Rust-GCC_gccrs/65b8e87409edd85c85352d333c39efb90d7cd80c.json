{"sha": "65b8e87409edd85c85352d333c39efb90d7cd80c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjViOGU4NzQwOWVkZDg1Yzg1MzUyZDMzM2MzOWVmYjkwZDdjZDgwYw==", "commit": {"author": {"name": "Ranjit Mathew", "email": "rmathew@hotmail.com", "date": "2003-01-28T22:23:36Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2003-01-28T22:23:36Z"}, "message": "re PR java/9254 (java::lang::Object::wait(), threads-win32.cc returns wrong return codes)\n\n2003-01-28  Ranjit Mathew  <rmathew@hotmail.com>\n\n\tFixes PR java/9254:\n\t* include/win32-threads.h (_Jv_Mutex_t): Convert to a struct\n\tadditionally containing id of the owner thread as well as\n\tthe number of nested times the thread has acquired the mutex.\n\t(_Jv_MutexInit): Initialise owner thread id and refcount to 0.\n\t(_Jv_MutexDestroy): Reset owner thread id and refcount to 0.\n\t(_Jv_MutexUnlock): Check if really the owner thread, reset\n\towner thread id to 0 before leaving, if leaving for the last\n\ttime.\n\t(_Jv_MutexLock): Set owner thread id in the mutex and increment\n\trefcount.\n\t(_Jv_ThreadYield): Yield using a call to Sleep(0).\n\t* win32-threads.cc (_Jv_CondWait): Check if really owner of\n\tthe passed mutex.\n\tPass handle of the broadcast event, instead of a pointer to it\n\tin Win32 ResetEvent( ) call.\n\tRemove incorrect return values.\n\t(_Jv_CondDestroy): Close both event handles and delete\n\tcritical section.\n\t(_Jv_CondNotify): Check if really the owner thread.\n\t(_Jv_CondNotifyAll): Check if really the owner thread.\n\t(_Jv_InitThreads): Change daemon_cond to a manual-reset event.\n\t(really_start): Use SetEvent( ) to signal daemon_cond.\n\t(_Jv_ThreadWait): Remove SignalObjectAndWait( ) and use\n\tWaitForSingleObject( ) instead to wait for daemon_cond to be\n\tsignalled.\n\nFrom-SVN: r62033", "tree": {"sha": "574bb63340f70c9fa5bf9c43614d3646628d128e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/574bb63340f70c9fa5bf9c43614d3646628d128e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/65b8e87409edd85c85352d333c39efb90d7cd80c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65b8e87409edd85c85352d333c39efb90d7cd80c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65b8e87409edd85c85352d333c39efb90d7cd80c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65b8e87409edd85c85352d333c39efb90d7cd80c/comments", "author": null, "committer": null, "parents": [{"sha": "c1c1d12306906a61f3c0f9f5956723a1d0f407dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1c1d12306906a61f3c0f9f5956723a1d0f407dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1c1d12306906a61f3c0f9f5956723a1d0f407dd"}], "stats": {"total": 188, "additions": 136, "deletions": 52}, "files": [{"sha": "dbcd959957cfda5c544416ef559b8a795248f34a", "filename": "libjava/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65b8e87409edd85c85352d333c39efb90d7cd80c/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65b8e87409edd85c85352d333c39efb90d7cd80c/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=65b8e87409edd85c85352d333c39efb90d7cd80c", "patch": "@@ -1,3 +1,32 @@\n+2003-01-28  Ranjit Mathew  <rmathew@hotmail.com>\n+\n+\tFixes PR java/9254:\n+\t* include/win32-threads.h (_Jv_Mutex_t): Convert to a struct\n+\tadditionally containing id of the owner thread as well as\n+\tthe number of nested times the thread has acquired the mutex.\n+\t(_Jv_MutexInit): Initialise owner thread id and refcount to 0.\n+\t(_Jv_MutexDestroy): Reset owner thread id and refcount to 0.\n+\t(_Jv_MutexUnlock): Check if really the owner thread, reset\n+\towner thread id to 0 before leaving, if leaving for the last\n+\ttime.\n+\t(_Jv_MutexLock): Set owner thread id in the mutex and increment\n+\trefcount.\n+\t(_Jv_ThreadYield): Yield using a call to Sleep(0).\n+\t* win32-threads.cc (_Jv_CondWait): Check if really owner of\n+\tthe passed mutex.\n+\tPass handle of the broadcast event, instead of a pointer to it\n+\tin Win32 ResetEvent( ) call.\n+\tRemove incorrect return values.\n+\t(_Jv_CondDestroy): Close both event handles and delete\n+\tcritical section.\n+\t(_Jv_CondNotify): Check if really the owner thread.\n+\t(_Jv_CondNotifyAll): Check if really the owner thread.\n+\t(_Jv_InitThreads): Change daemon_cond to a manual-reset event.\n+\t(really_start): Use SetEvent( ) to signal daemon_cond.\n+\t(_Jv_ThreadWait): Remove SignalObjectAndWait( ) and use\n+\tWaitForSingleObject( ) instead to wait for daemon_cond to be\n+\tsignalled.\n+\n 2003-01-27  Ranjit Mathew  <rmathew@hotmail.com>\n \n \t* configure.in: Specifically define HAVE_BACKTRACE if building"}, {"sha": "5e40ae24b87b4c252cddecfb68bced95173853f7", "filename": "libjava/include/win32-threads.h", "status": "modified", "additions": 45, "deletions": 13, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65b8e87409edd85c85352d333c39efb90d7cd80c/libjava%2Finclude%2Fwin32-threads.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65b8e87409edd85c85352d333c39efb90d7cd80c/libjava%2Finclude%2Fwin32-threads.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fwin32-threads.h?ref=65b8e87409edd85c85352d333c39efb90d7cd80c", "patch": "@@ -1,7 +1,8 @@\n // -*- c++ -*-\n // win32-threads.h - Defines for using Win32 threads.\n \n-/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003 Free Software\n+   Foundation\n \n    This file is part of libgcj.\n \n@@ -18,13 +19,32 @@ details.  */\n // Typedefs.\n //\n \n-typedef struct _Jv_ConditionVariable_t {\n+typedef struct\n+{\n+  // ev[0] (signal) is a Win32 auto-reset event for _Jv_CondNotify\n+  // ev[1] (broadcast) is a Win32 manual-reset event for _Jv_CondNotifyAll\n   HANDLE ev[2];\n-  CRITICAL_SECTION count_mutex;\n+\n+  // Number of threads waiting on this condition variable\n   int blocked_count;\n-};\n \n-typedef CRITICAL_SECTION _Jv_Mutex_t;\n+  // Protects access to the blocked_count variable\n+  CRITICAL_SECTION count_mutex;\n+\n+} _Jv_ConditionVariable_t;\n+\n+typedef struct\n+{\n+  // The thread-id of the owner thread if any, 0 otherwise\n+  DWORD owner;\n+\n+  // Track nested mutex acquisitions by the same thread\n+  int refcount;\n+\n+  // The actual Windows construct used to implement this mutex\n+  CRITICAL_SECTION cs;\n+\n+} _Jv_Mutex_t;\n \n typedef struct\n {\n@@ -60,25 +80,39 @@ int _Jv_CondNotifyAll (_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *);\n \n inline void _Jv_MutexInit (_Jv_Mutex_t *mu)\n {\n-  InitializeCriticalSection(mu);\n+  mu->owner = 0UL;\n+  mu->refcount = 0;\n+  InitializeCriticalSection (&(mu->cs));\n }\n \n #define _Jv_HaveMutexDestroy\n inline void _Jv_MutexDestroy (_Jv_Mutex_t *mu)\n {\n-  DeleteCriticalSection(mu);\n+  mu->owner = 0UL;\n+  mu->refcount = 0;\n+  DeleteCriticalSection (&(mu->cs));\n   mu = NULL;\n }\n \n inline int _Jv_MutexUnlock (_Jv_Mutex_t *mu)\n {\n-  LeaveCriticalSection(mu);\n-  return 0;\n+  if (mu->owner == GetCurrentThreadId ( ))\n+    {\n+      mu->refcount--;\n+      if (mu->refcount == 0)\n+        mu->owner = 0UL;\n+      LeaveCriticalSection (&(mu->cs));\n+      return 0;\n+    }\n+  else\n+    return 1;\n }\n \n inline int _Jv_MutexLock (_Jv_Mutex_t *mu)\n {\n-  EnterCriticalSection(mu);\n+  EnterCriticalSection (&(mu->cs));\n+  mu->owner = GetCurrentThreadId ( );\n+  mu->refcount++;\n   return 0;\n }\n \n@@ -104,9 +138,7 @@ inline _Jv_Thread_t *_Jv_ThreadCurrentData(void)\n \n inline void _Jv_ThreadYield (void)\n {\n-  // FIXME: win98 freezes hard (OS hang) when we use this --\n-  //        for now, we simply don't yield\n-  // Sleep (0);\n+  Sleep (0);\n }\n \n void _Jv_ThreadRegister (_Jv_Thread_t *data);"}, {"sha": "3a3999a8f2d394811e35186b10237ca9484c7237", "filename": "libjava/win32-threads.cc", "status": "modified", "additions": 62, "deletions": 39, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65b8e87409edd85c85352d333c39efb90d7cd80c/libjava%2Fwin32-threads.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65b8e87409edd85c85352d333c39efb90d7cd80c/libjava%2Fwin32-threads.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fwin32-threads.cc?ref=65b8e87409edd85c85352d333c39efb90d7cd80c", "patch": "@@ -1,6 +1,7 @@\n // win32-threads.cc - interface between libjava and Win32 threads.\n \n-/* Copyright (C) 1998, 1999  Free Software Foundation, Inc.\n+/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003 Free Software\n+   Foundation, Inc.\n \n    This file is part of libgcj.\n \n@@ -70,12 +71,14 @@ DWORD _Jv_ThreadDataKey;\n inline void\n ensure_condvar_initialized(_Jv_ConditionVariable_t *cv)\n {\n-  if (cv->ev[0] == 0) {\n-    cv->ev[0] = CreateEvent (NULL, 0, 0, NULL);\n-    if (cv->ev[0] == 0) JvFail(\"CreateEvent() failed\");\n-    cv->ev[1] = CreateEvent (NULL, 1, 0, NULL);\n-    if (cv->ev[1] == 0) JvFail(\"CreateEvent() failed\");\n-  }\n+  if (cv->ev[0] == 0)\n+    {\n+      cv->ev[0] = CreateEvent (NULL, 0, 0, NULL);\n+      if (cv->ev[0] == 0) JvFail(\"CreateEvent() failed\");\n+\n+      cv->ev[1] = CreateEvent (NULL, 1, 0, NULL);\n+      if (cv->ev[1] == 0) JvFail(\"CreateEvent() failed\");\n+    }\n }\n \n // Reimplementation of the general algorithm described at\n@@ -85,11 +88,13 @@ ensure_condvar_initialized(_Jv_ConditionVariable_t *cv)\n int\n _Jv_CondWait(_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *mu, jlong millis, jint nanos)\n {\n+  if (mu->owner != GetCurrentThreadId ( ))\n+    return _JV_NOT_OWNER;\n \n-  EnterCriticalSection(&cv->count_mutex);\n-  ensure_condvar_initialized(cv);\n+  EnterCriticalSection (&cv->count_mutex);\n+  ensure_condvar_initialized (cv);\n   cv->blocked_count++;\n-  LeaveCriticalSection(&cv->count_mutex);\n+  LeaveCriticalSection (&cv->count_mutex);\n \n   DWORD time;\n   if ((millis == 0) && (nanos > 0)) time = 1;\n@@ -102,58 +107,74 @@ _Jv_CondWait(_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *mu, jlong millis, jint na\n \n   EnterCriticalSection(&cv->count_mutex);\n   cv->blocked_count--;\n-  // If we were unblocked by the second event (the broadcast one) and nobody is\n-  // left, then reset the signal.\n-  int last_waiter = rval == WAIT_OBJECT_0 + 1 && cv->blocked_count == 0;\n+  // If we were unblocked by the second event (the broadcast one)\n+  // and nobody is left, then reset the event.\n+  int last_waiter = (rval == (WAIT_OBJECT_0 + 1)) && (cv->blocked_count == 0);\n   LeaveCriticalSection(&cv->count_mutex);\n \n-  if (last_waiter) ResetEvent(&cv->ev[1]);\n+  if (last_waiter)\n+    ResetEvent (cv->ev[1]);\n \n   _Jv_MutexLock (mu);\n \n-  if (rval == WAIT_FAILED) return GetLastError();\n-  else if (rval == WAIT_TIMEOUT) return ETIMEDOUT;\n-  else return 0;\n+  return 0;\n }\n \n void\n _Jv_CondInit (_Jv_ConditionVariable_t *cv)\n {\n   // we do lazy creation of Events since CreateEvent() is insanely expensive\n   cv->ev[0] = 0;\n-  InitializeCriticalSection(&cv->count_mutex);\n+  InitializeCriticalSection (&cv->count_mutex);\n   cv->blocked_count = 0;\n }\n \n void\n _Jv_CondDestroy (_Jv_ConditionVariable_t *cv)\n {\n-  if (cv->ev[0] != 0) CloseHandle(cv->ev[0]);\n-  cv = NULL;\n+  if (cv->ev[0] != 0)\n+    {\n+      CloseHandle (cv->ev[0]);\n+      CloseHandle (cv->ev[1]);\n+\n+      cv->ev[0] = 0;\n+    }\n+\n+  DeleteCriticalSection (&cv->count_mutex);\n }\n \n int\n-_Jv_CondNotify (_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *)\n+_Jv_CondNotify (_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *mu)\n {\n-  EnterCriticalSection(&cv->count_mutex);\n-  ensure_condvar_initialized(cv);\n+  if (mu->owner != GetCurrentThreadId ( ))\n+    return _JV_NOT_OWNER;\n+\n+  EnterCriticalSection (&cv->count_mutex);\n+  ensure_condvar_initialized (cv);\n   int somebody_is_blocked = cv->blocked_count > 0;\n-  LeaveCriticalSection(&cv->count_mutex);\n+  LeaveCriticalSection (&cv->count_mutex);\n+\n+  if (somebody_is_blocked)\n+    SetEvent (cv->ev[0]);\n \n-  if (somebody_is_blocked) return SetEvent (cv->ev[0]) ? 0 : GetLastError();\n-  else return 0;\n+  return 0;\n }\n \n int\n-_Jv_CondNotifyAll (_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *)\n+_Jv_CondNotifyAll (_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *mu)\n {\n-  EnterCriticalSection(&cv->count_mutex);\n-  ensure_condvar_initialized(cv);\n+  if (mu->owner != GetCurrentThreadId ( ))\n+    return _JV_NOT_OWNER;\n+\n+  EnterCriticalSection (&cv->count_mutex);\n+  ensure_condvar_initialized (cv);\n   int somebody_is_blocked = cv->blocked_count > 0;\n-  LeaveCriticalSection(&cv->count_mutex);\n+  LeaveCriticalSection (&cv->count_mutex);\n \n-  if (somebody_is_blocked) return SetEvent (cv->ev[1]) ? 0 : GetLastError();\n-  else return 0;\n+  if (somebody_is_blocked)\n+    SetEvent (cv->ev[1]);\n+\n+  return 0;\n }\n \n //\n@@ -165,8 +186,8 @@ _Jv_InitThreads (void)\n {\n   _Jv_ThreadKey = TlsAlloc();\n   _Jv_ThreadDataKey = TlsAlloc();\n-  daemon_mutex = CreateMutex(NULL, 0, NULL);\n-  daemon_cond = CreateEvent(NULL, 0, 0, NULL);\n+  daemon_mutex = CreateMutex (NULL, 0, NULL);\n+  daemon_cond = CreateEvent (NULL, 1, 0, NULL);\n   non_daemon_count = 0;\n }\n \n@@ -255,7 +276,7 @@ really_start (void* x)\n       WaitForSingleObject (daemon_mutex, INFINITE);\n       non_daemon_count--;\n       if (! non_daemon_count)\n-          PulseEvent (daemon_cond);\n+        SetEvent (daemon_cond);\n       ReleaseMutex (daemon_mutex);\n     }\n \n@@ -297,10 +318,12 @@ _Jv_ThreadStart (java::lang::Thread *thread, _Jv_Thread_t *data, _Jv_ThreadStart\n void\n _Jv_ThreadWait (void)\n {\n-  WaitForSingleObject(daemon_mutex, INFINITE);\n-  if(non_daemon_count)\n-      SignalObjectAndWait(daemon_mutex, daemon_cond, INFINITE, 0);\n-  ReleaseMutex(daemon_mutex);\n+  WaitForSingleObject (daemon_mutex, INFINITE);\n+  if (non_daemon_count)\n+    {\n+      ReleaseMutex (daemon_mutex);\n+      WaitForSingleObject (daemon_cond, INFINITE);\n+    }\n }\n \n void"}]}