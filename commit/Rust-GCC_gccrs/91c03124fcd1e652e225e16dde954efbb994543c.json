{"sha": "91c03124fcd1e652e225e16dde954efbb994543c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTFjMDMxMjRmY2QxZTY1MmUyMjVlMTZkZGU5NTRlZmJiOTk0NTQzYw==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2018-11-06T05:33:40Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2018-11-06T05:33:40Z"}, "message": "gOlogy: fix debug binds in auto-inc-dec\n\nAs auto_inc_dec pass combines incs and mems from different insns, it\noften causes regs to temporarily hold a value different from the one\nit would before the transformation.  Debug insns within that range\nwould therefore end up binding to the wrong expression after the\ntransformation.\n\nThis patch adjusts debug binds in the affected range.\n\nfor  gcc/ChangeLog\n\n\t* auto-inc-dec.c: Include valtrack.h.  Improve comments.\n\t(reg_next_debug_use): New.\n\t(attempt_change): Propagate adjusted expression into affected\n\tdebug insns.\n\t(merge_in_block): Track uses in debug insns.\n\t(pass_inc_dec::execute): Allocate and release\n\treg_next_debug_use.\n\nFrom-SVN: r265828", "tree": {"sha": "4933a94e1769bcaf6f900d46f2aadc5c98d0f3a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4933a94e1769bcaf6f900d46f2aadc5c98d0f3a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91c03124fcd1e652e225e16dde954efbb994543c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91c03124fcd1e652e225e16dde954efbb994543c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91c03124fcd1e652e225e16dde954efbb994543c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91c03124fcd1e652e225e16dde954efbb994543c/comments", "author": null, "committer": null, "parents": [{"sha": "ce2ad8cc8f080890966b594453ff01e875605e66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce2ad8cc8f080890966b594453ff01e875605e66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce2ad8cc8f080890966b594453ff01e875605e66"}], "stats": {"total": 138, "additions": 135, "deletions": 3}, "files": [{"sha": "2c5abd39a4ba92daacd6dde9be2a23f9eeba3e08", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91c03124fcd1e652e225e16dde954efbb994543c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91c03124fcd1e652e225e16dde954efbb994543c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=91c03124fcd1e652e225e16dde954efbb994543c", "patch": "@@ -1,3 +1,13 @@\n+2018-11-06  Alexandre Oliva <aoliva@redhat.com>\n+\n+\t* auto-inc-dec.c: Include valtrack.h.  Improve comments.\n+\t(reg_next_debug_use): New.\n+\t(attempt_change): Propagate adjusted expression into affected\n+\tdebug insns.\n+\t(merge_in_block): Track uses in debug insns.\n+\t(pass_inc_dec::execute): Allocate and release\n+\treg_next_debug_use.\n+\n 2018-11-06 Wei Xiao <wei3.xiao@intel.com>\n \n \t* config/i386/avx512fintrin.h: Update VFIXUPIMM* intrinsics."}, {"sha": "064b8afd4ff9c5619513301b0c5da6e162d85c4d", "filename": "gcc/auto-inc-dec.c", "status": "modified", "additions": 125, "deletions": 3, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91c03124fcd1e652e225e16dde954efbb994543c/gcc%2Fauto-inc-dec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91c03124fcd1e652e225e16dde954efbb994543c/gcc%2Fauto-inc-dec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-inc-dec.c?ref=91c03124fcd1e652e225e16dde954efbb994543c", "patch": "@@ -36,6 +36,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"dbgcnt.h\"\n #include \"print-rtl.h\"\n+#include \"valtrack.h\"\n \n /* This pass was originally removed from flow.c. However there is\n    almost nothing that remains of that code.\n@@ -53,6 +54,21 @@ along with GCC; see the file COPYING3.  If not see\n            ...\n            *(a += c) pre\n \n+        or, alternately,\n+\n+           a <- b + c\n+           ...\n+           *b\n+\n+        becomes\n+\n+           a <- b\n+           ...\n+           *(a += c) post\n+\n+        This uses a post-add, but it's handled as FORM_PRE_ADD because\n+        the \"increment\" insn appears before the memory access.\n+\n \n       (2) FORM_PRE_INC\n            a += c\n@@ -61,6 +77,7 @@ along with GCC; see the file COPYING3.  If not see\n \n         becomes\n \n+           ...\n            *(a += c) pre\n \n \n@@ -75,8 +92,8 @@ along with GCC; see the file COPYING3.  If not see\n         becomes\n \n            b <- a\n-           ...\n            *(b += c) post\n+           ...\n \n \n       (4) FORM_POST_INC\n@@ -87,6 +104,8 @@ along with GCC; see the file COPYING3.  If not see\n         becomes\n \n            *(a += c) post\n+           ...\n+\n \n   There are three types of values of c.\n \n@@ -393,6 +412,7 @@ dump_mem_insn (FILE *file)\n    must be compared with the current block.\n */\n \n+static rtx_insn **reg_next_debug_use = NULL;\n static rtx_insn **reg_next_use = NULL;\n static rtx_insn **reg_next_inc_use = NULL;\n static rtx_insn **reg_next_def = NULL;\n@@ -509,27 +529,83 @@ attempt_change (rtx new_addr, rtx inc_reg)\n       gcc_assert (mov_insn);\n       emit_insn_before (mov_insn, inc_insn.insn);\n       regno = REGNO (inc_insn.reg0);\n+      /* ??? Could REGNO possibly be used in MEM_INSN other than in\n+\t the MEM address, and still die there, so that move_dead_notes\n+\t would incorrectly move the note?  */\n       if (reg_next_use[regno] == mem_insn.insn)\n \tmove_dead_notes (mov_insn, mem_insn.insn, inc_insn.reg0);\n       else\n \tmove_dead_notes (mov_insn, inc_insn.insn, inc_insn.reg0);\n \n       regno = REGNO (inc_insn.reg_res);\n+      if (reg_next_debug_use && reg_next_debug_use[regno]\n+\t  && BLOCK_FOR_INSN (reg_next_debug_use[regno]) == bb)\n+\t{\n+\t  rtx adjres = gen_rtx_PLUS (GET_MODE (inc_insn.reg_res),\n+\t\t\t\t     inc_insn.reg_res, inc_insn.reg1);\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"adjusting debug insns\\n\");\n+\t  propagate_for_debug (PREV_INSN (reg_next_debug_use[regno]),\n+\t\t\t       mem_insn.insn,\n+\t\t\t       inc_insn.reg_res, adjres, bb);\n+\t  reg_next_debug_use[regno] = NULL;\n+\t}\n       reg_next_def[regno] = mov_insn;\n       reg_next_use[regno] = NULL;\n+\n       regno = REGNO (inc_insn.reg0);\n+      if (reg_next_debug_use && reg_next_debug_use[regno]\n+\t  && BLOCK_FOR_INSN (reg_next_debug_use[regno]) == bb\n+\t  && find_reg_note (mov_insn, REG_DEAD, inc_insn.reg0))\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"remapping debug insns\\n\");\n+\t  propagate_for_debug (PREV_INSN (reg_next_debug_use[regno]),\n+\t\t\t       mem_insn.insn,\n+\t\t\t       inc_insn.reg0, inc_insn.reg_res, bb);\n+\t  reg_next_debug_use[regno] = NULL;\n+\t}\n       reg_next_use[regno] = mov_insn;\n       df_recompute_luids (bb);\n       break;\n \n     case FORM_POST_INC:\n       regno = REGNO (inc_insn.reg_res);\n+      if (reg_next_debug_use && reg_next_debug_use[regno]\n+\t  && BLOCK_FOR_INSN (reg_next_debug_use[regno]) == bb)\n+\t{\n+\t  rtx adjres = gen_rtx_MINUS (GET_MODE (inc_insn.reg_res),\n+\t\t\t\t      inc_insn.reg_res, inc_insn.reg1);\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"adjusting debug insns\\n\");\n+\t  propagate_for_debug (PREV_INSN (reg_next_debug_use[regno]),\n+\t\t\t       inc_insn.insn,\n+\t\t\t       inc_insn.reg_res, adjres, bb);\n+\t  reg_next_debug_use[regno] = NULL;\n+\t}\n       if (reg_next_use[regno] == reg_next_inc_use[regno])\n \treg_next_inc_use[regno] = NULL;\n \n       /* Fallthru.  */\n     case FORM_PRE_INC:\n       regno = REGNO (inc_insn.reg_res);\n+      /* Despite the fall-through, we won't run this twice: we'll have\n+\t already cleared reg_next_debug_use[regno] before falling\n+\t through.  */\n+      if (reg_next_debug_use && reg_next_debug_use[regno]\n+\t  && BLOCK_FOR_INSN (reg_next_debug_use[regno]) == bb)\n+\t{\n+\t  rtx adjres = gen_rtx_PLUS (GET_MODE (inc_insn.reg_res),\n+\t\t\t\t     inc_insn.reg_res, inc_insn.reg1);\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"adjusting debug insns\\n\");\n+\t  propagate_for_debug (PREV_INSN (reg_next_debug_use[regno]),\n+\t\t\t       mem_insn.insn,\n+\t\t\t       inc_insn.reg_res, adjres, bb);\n+\t  if (DF_INSN_LUID (mem_insn.insn)\n+\t      < DF_INSN_LUID (reg_next_debug_use[regno]))\n+\t    reg_next_debug_use[regno] = NULL;\n+\t}\n       reg_next_def[regno] = mem_insn.insn;\n       reg_next_use[regno] = NULL;\n \n@@ -544,10 +620,26 @@ attempt_change (rtx new_addr, rtx inc_reg)\n \t pointer for the main iteration has not yet hit that.  It is\n \t still pointing to the mem insn. */\n       regno = REGNO (inc_insn.reg_res);\n+      /* The pseudo is now set earlier, so it must have been dead in\n+\t that range, and dead registers cannot be referenced in debug\n+\t insns.  */\n+      gcc_assert (!(reg_next_debug_use && reg_next_debug_use[regno]\n+\t\t    && BLOCK_FOR_INSN (reg_next_debug_use[regno]) == bb));\n       reg_next_def[regno] = mem_insn.insn;\n       reg_next_use[regno] = NULL;\n \n       regno = REGNO (inc_insn.reg0);\n+      if (reg_next_debug_use && reg_next_debug_use[regno]\n+\t  && BLOCK_FOR_INSN (reg_next_debug_use[regno]) == bb\n+\t  && find_reg_note (mov_insn, REG_DEAD, inc_insn.reg0))\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"remapping debug insns\\n\");\n+\t  propagate_for_debug (PREV_INSN (reg_next_debug_use[regno]),\n+\t\t\t       inc_insn.insn,\n+\t\t\t       inc_insn.reg0, inc_insn.reg_res, bb);\n+\t  reg_next_debug_use[regno] = NULL;\n+\t}\n       reg_next_use[regno] = mem_insn.insn;\n       if ((reg_next_use[regno] == reg_next_inc_use[regno])\n \t  || (reg_next_inc_use[regno] == inc_insn.insn))\n@@ -1332,7 +1424,20 @@ merge_in_block (int max_reg, basic_block bb)\n       bool insn_is_add_or_inc = true;\n \n       if (!NONDEBUG_INSN_P (insn))\n-\tcontinue;\n+\t{\n+\t  if (DEBUG_BIND_INSN_P (insn))\n+\t    {\n+\t      df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n+\t      df_ref use;\n+\n+\t      if (dump_file)\n+\t\tdump_insn_slim (dump_file, insn);\n+\n+\t      FOR_EACH_INSN_INFO_USE (use, insn_info)\n+\t\treg_next_debug_use[DF_REF_REGNO (use)] = insn;\n+\t    }\n+\t  continue;\n+\t}\n \n       /* This continue is deliberate.  We do not want the uses of the\n \t jump put into reg_next_use because it is not considered safe to\n@@ -1410,7 +1515,7 @@ merge_in_block (int max_reg, basic_block bb)\n \n \t\t     where reg1 is a constant (*).\n \n-\t\t     The next use of reg_res was not idenfied by\n+\t\t     The next use of reg_res was not identified by\n \t\t     find_address as a mem_insn that we could turn\n \t\t     into auto-inc, so see if we find a suitable\n \t\t     MEM in the next use of reg0, as long as it's\n@@ -1510,13 +1615,22 @@ merge_in_block (int max_reg, basic_block bb)\n \t  /* Need to update next use.  */\n \t  FOR_EACH_INSN_INFO_DEF (def, insn_info)\n \t    {\n+\t      if (reg_next_debug_use)\n+\t\treg_next_debug_use[DF_REF_REGNO (def)] = NULL;\n \t      reg_next_use[DF_REF_REGNO (def)] = NULL;\n \t      reg_next_inc_use[DF_REF_REGNO (def)] = NULL;\n \t      reg_next_def[DF_REF_REGNO (def)] = insn;\n \t    }\n \n \t  FOR_EACH_INSN_INFO_USE (use, insn_info)\n \t    {\n+\t      if (reg_next_debug_use)\n+\t\t/* This may seem surprising, but we know we may only\n+\t\t   modify the value of a REG between an insn and the\n+\t\t   next nondebug use thereof.  Any debug uses after\n+\t\t   the next nondebug use can be left alone, the REG\n+\t\t   will hold the expected value there.  */\n+\t\treg_next_debug_use[DF_REF_REGNO (use)] = NULL;\n \t      reg_next_use[DF_REF_REGNO (use)] = insn;\n \t      if (insn_is_add_or_inc)\n \t\treg_next_inc_use[DF_REF_REGNO (use)] = insn;\n@@ -1536,6 +1650,8 @@ merge_in_block (int max_reg, basic_block bb)\n     {\n       /* In this case, we must clear these vectors since the trick of\n \t testing if the stale insn in the block will not work.  */\n+      if (reg_next_debug_use)\n+\tmemset (reg_next_debug_use, 0, max_reg * sizeof (rtx));\n       memset (reg_next_use, 0, max_reg * sizeof (rtx));\n       memset (reg_next_inc_use, 0, max_reg * sizeof (rtx));\n       memset (reg_next_def, 0, max_reg * sizeof (rtx));\n@@ -1599,12 +1715,18 @@ pass_inc_dec::execute (function *fun ATTRIBUTE_UNUSED)\n   df_note_add_problem ();\n   df_analyze ();\n \n+  if (MAY_HAVE_DEBUG_BIND_INSNS)\n+    reg_next_debug_use = XCNEWVEC (rtx_insn *, max_reg);\n+  else\n+    /* An earlier function may have had debug binds.  */\n+    reg_next_debug_use = NULL;\n   reg_next_use = XCNEWVEC (rtx_insn *, max_reg);\n   reg_next_inc_use = XCNEWVEC (rtx_insn *, max_reg);\n   reg_next_def = XCNEWVEC (rtx_insn *, max_reg);\n   FOR_EACH_BB_FN (bb, fun)\n     merge_in_block (max_reg, bb);\n \n+  free (reg_next_debug_use);\n   free (reg_next_use);\n   free (reg_next_inc_use);\n   free (reg_next_def);"}]}