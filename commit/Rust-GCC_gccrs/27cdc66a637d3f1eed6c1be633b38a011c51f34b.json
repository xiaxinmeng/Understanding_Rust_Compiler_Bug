{"sha": "27cdc66a637d3f1eed6c1be633b38a011c51f34b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjdjZGM2NmE2MzdkM2YxZWVkNmMxYmU2MzNiMzhhMDExYzUxZjM0Yg==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2009-10-27T14:02:58Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-10-27T14:02:58Z"}, "message": "sem_warn.adb, [...]: Minor reformatting.\n\n2009-10-27  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_warn.adb, sem_util.adb, sem_util.ads: Minor reformatting. Add\n\tcomments.\n\nFrom-SVN: r153595", "tree": {"sha": "ab70272708e0c64206bb0568eac9e46ca5845635", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab70272708e0c64206bb0568eac9e46ca5845635"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/27cdc66a637d3f1eed6c1be633b38a011c51f34b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27cdc66a637d3f1eed6c1be633b38a011c51f34b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27cdc66a637d3f1eed6c1be633b38a011c51f34b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27cdc66a637d3f1eed6c1be633b38a011c51f34b/comments", "author": null, "committer": null, "parents": [{"sha": "76b84bf03f7a5c8d516690d043b69bc4d8288c04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76b84bf03f7a5c8d516690d043b69bc4d8288c04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76b84bf03f7a5c8d516690d043b69bc4d8288c04"}], "stats": {"total": 70, "additions": 52, "deletions": 18}, "files": [{"sha": "794901f4ae63ff73db87f7057f784a52d6557209", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27cdc66a637d3f1eed6c1be633b38a011c51f34b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27cdc66a637d3f1eed6c1be633b38a011c51f34b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=27cdc66a637d3f1eed6c1be633b38a011c51f34b", "patch": "@@ -1,3 +1,8 @@\n+2009-10-27  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_warn.adb, sem_util.adb, sem_util.ads: Minor reformatting. Add\n+\tcomments.\n+\n 2009-10-27  Robert Dewar  <dewar@adacore.com>\n \n \t* s-os_lib.ads, s-os_lib.adb, prj-err.adb, makeutl.adb: Minor"}, {"sha": "9c8de0473d4403788e555855be1301be00086cd3", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27cdc66a637d3f1eed6c1be633b38a011c51f34b/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27cdc66a637d3f1eed6c1be633b38a011c51f34b/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=27cdc66a637d3f1eed6c1be633b38a011c51f34b", "patch": "@@ -2142,26 +2142,35 @@ package body Sem_Util is\n    -------------------------\n \n    function Denotes_Same_Object (A1, A2 : Node_Id) return Boolean is\n-\n    begin\n+      --  If we have entity names, then must be same entity\n+\n       if Is_Entity_Name (A1) then\n          if Is_Entity_Name (A2)then\n-            return  Entity (A1) = Entity (A2);\n+            return Entity (A1) = Entity (A2);\n          else\n             return False;\n          end if;\n \n+      --  No match if not same node kind\n+\n       elsif Nkind (A1) /= Nkind (A2) then\n          return False;\n \n+      --  For selected components, must have same prefix and selector\n+\n       elsif Nkind (A1) = N_Selected_Component then\n          return Denotes_Same_Object (Prefix (A1), Prefix (A2))\n            and then\n          Entity (Selector_Name (A1)) = Entity (Selector_Name (A2));\n \n+      --  For explicit dereferences, prefixes must be same\n+\n       elsif Nkind (A1) = N_Explicit_Dereference then\n          return Denotes_Same_Object (Prefix (A1), Prefix (A2));\n \n+      --  For indexed components, prefixes and all subscripts must be the same\n+\n       elsif Nkind (A1) = N_Indexed_Component then\n          if Denotes_Same_Object (Prefix (A1), Prefix (A2)) then\n             declare\n@@ -2172,6 +2181,9 @@ package body Sem_Util is\n                Indx1 := First (Expressions (A1));\n                Indx2 := First (Expressions (A2));\n                while Present (Indx1) loop\n+\n+                  --  Shouldn't we be checking that values are the same???\n+\n                   if not Denotes_Same_Object (Indx1, Indx2) then\n                      return False;\n                   end if;\n@@ -2186,6 +2198,8 @@ package body Sem_Util is\n             return False;\n          end if;\n \n+      --  For slices, prefixes must match and bounds must match\n+\n       elsif Nkind (A1) = N_Slice\n         and then Denotes_Same_Object (Prefix (A1), Prefix (A2))\n       then\n@@ -2196,14 +2210,17 @@ package body Sem_Util is\n             Get_Index_Bounds (Etype (A1), Lo1, Hi1);\n             Get_Index_Bounds (Etype (A2), Lo2, Hi2);\n \n-            --  Check whether bounds are statically identical\n-            --  No attempt to detect partial overlap of slices.\n+            --  Check whether bounds are statically identical. There is no\n+            --  attempt to detect partial overlap of slices.\n+\n+            --  What about an array and a slice of an array???\n \n             return Denotes_Same_Object (Lo1, Lo2)\n               and then Denotes_Same_Object (Hi1, Hi2);\n          end;\n \n-         --  Literals will appear as indices.\n+         --  Literals will appear as indices. Isn't this where we should check\n+         --  Known_At_Compile_Time at least if we are generating warnings ???\n \n       elsif Nkind (A1) = N_Integer_Literal then\n          return Intval (A1) = Intval (A2);"}, {"sha": "623a72b2782f8ca0d57c927c713c4802f46fa5a1", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27cdc66a637d3f1eed6c1be633b38a011c51f34b/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27cdc66a637d3f1eed6c1be633b38a011c51f34b/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=27cdc66a637d3f1eed6c1be633b38a011c51f34b", "patch": "@@ -254,8 +254,11 @@ package Sem_Util is\n    function Denotes_Same_Object (A1, A2 : Node_Id) return Boolean;\n    function Denotes_Same_Prefix (A1, A2 : Node_Id) return Boolean;\n    --  Functions to detect suspicious overlapping between actuals in a call,\n-   --  when one of them is writable. The predicates are those  proposed in\n+   --  when one of them is writable. The predicates are those proposed in\n    --  AI05-0144, to detect dangerous order dependence in complex calls.\n+   --  I would add a parameter Warn which enables more extensive testing of\n+   --  cases as we find appropriate when we are only warning ??? Or perhaps\n+   --  return an indication of (Error, Warn, OK) ???\n \n    function Denotes_Variable (N : Node_Id) return Boolean;\n    --  Returns True if node N denotes a single variable without parentheses"}, {"sha": "f8124f219c0685d24a2fa2c039a8d516451a4c9b", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27cdc66a637d3f1eed6c1be633b38a011c51f34b/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27cdc66a637d3f1eed6c1be633b38a011c51f34b/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=27cdc66a637d3f1eed6c1be633b38a011c51f34b", "patch": "@@ -3544,8 +3544,9 @@ package body Sem_Warn is\n       Form1, Form2 : Entity_Id;\n \n    begin\n-\n-      --  For now, treat this warning as an extension.\n+      --  For now, treat this warning as an extension\n+      --  Why not just define a new warning switch, you really don't want to\n+      --  force this warning when using conditional expressions for example???\n \n       if not Extensions_Allowed then\n          return;\n@@ -3554,7 +3555,7 @@ package body Sem_Warn is\n       --  Exclude calls rewritten as enumeration literals\n \n       if not Nkind_In\n-        (N, N_Function_Call, N_Procedure_Call_Statement)\n+               (N, N_Function_Call, N_Procedure_Call_Statement)\n       then\n          return;\n       end if;\n@@ -3570,22 +3571,23 @@ package body Sem_Warn is\n \n       Form1 := First_Formal (Subp);\n       Act1  := First_Actual (N);\n-\n       while Present (Form1) and then Present (Act1) loop\n          if Ekind (Form1) = E_In_Out_Parameter then\n             Form2 := First_Formal (Subp);\n             Act2  := First_Actual (N);\n-\n             while Present (Form2) and then Present (Act2) loop\n                if Form1 /= Form2\n                  and then Ekind (Form2) /= E_Out_Parameter\n                  and then\n                    (Denotes_Same_Object (Act1, Act2)\n-                    or else Denotes_Same_Prefix (Act1, Act2))\n+                      or else\n+                    Denotes_Same_Prefix (Act1, Act2))\n                then\n-\n                   --  Exclude generic types and guard against previous errors.\n-                  --  If either type is elementary the aliasing is harmless\n+                  --  If either type is elementary the aliasing is harmless.\n+\n+                  --  I can't relate the comment about elementary to the\n+                  --  actual code below, which seems to be testing generic???\n \n                   if Error_Posted (N)\n                     or else No (Etype (Act1))\n@@ -3605,15 +3607,19 @@ package body Sem_Warn is\n                      null;\n \n                   elsif Is_Elementary_Type (Underlying_Type (Etype (Form1)))\n-                    or else\n-                      Is_Elementary_Type (Underlying_Type (Etype (Form2)))\n+                          or else\n+                        Is_Elementary_Type (Underlying_Type (Etype (Form2)))\n                   then\n                      null;\n+\n                   else\n                      declare\n                         Act  : Node_Id;\n                         Form : Entity_Id;\n+\n                      begin\n+                        --  Find matching actual\n+\n                         Act  := First_Actual (N);\n                         Form := First_Formal (Subp);\n                         while Act /= Act2 loop\n@@ -3624,6 +3630,8 @@ package body Sem_Warn is\n                         --  If the call was written in prefix notation, count\n                         --  only the visible actuals in the call.\n \n+                        --  Why original_node calls below ???\n+\n                         if Is_Entity_Name (First_Actual (N))\n                           and then Nkind (Original_Node (N)) = Nkind (N)\n                           and then\n@@ -3641,8 +3649,8 @@ package body Sem_Warn is\n                                  Act1, Form);\n                            else\n                               Error_Msg_FE\n-                             (\"writable actual overlaps with actual for&?\",\n-                              Act1, Form);\n+                                (\"writable actual overlaps with actual for&?\",\n+                                 Act1, Form);\n                            end if;\n \n                         else\n@@ -3652,6 +3660,7 @@ package body Sem_Warn is\n                         end if;\n                      end;\n                   end if;\n+\n                   return;\n                end if;\n "}]}