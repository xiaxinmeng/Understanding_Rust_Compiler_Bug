{"sha": "aa36c0813a2f8c213bb5b041ce67e7032b078c5a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWEzNmMwODEzYTJmOGMyMTNiYjViMDQxY2U2N2U3MDMyYjA3OGM1YQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-12-03T19:46:56Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-12-03T19:46:56Z"}, "message": "tree.c (is_overloaded_fn): Handle getting a fn template.\n\n\t* tree.c (is_overloaded_fn): Handle getting a fn template.\n\t(really_overloaded_fn): Likewise.\n\t* error.c (dump_decl): Handle TEMPLATE_ID_EXPRs better.\n\t* pt.c (check_explicit_specialization): Tweak.\n\t(determine_explicit_specialization): Tweak.\n\n\t* tree.c, cp-tree.h (get_target_expr): New fn.\n\n1997-12-02  Mark Mitchell  <mmitchell@usa.net>\n\n\t* pt.c (determine_explicit_specialization): Avoid an internal\n\terror for bad specializations.\n\n\t* method.c (build_overload_value): Handle SCOPE_REF.\n\nFrom-SVN: r16928", "tree": {"sha": "cbef61e4c68e290653ba52cca7d8b28493864ced", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cbef61e4c68e290653ba52cca7d8b28493864ced"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa36c0813a2f8c213bb5b041ce67e7032b078c5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa36c0813a2f8c213bb5b041ce67e7032b078c5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa36c0813a2f8c213bb5b041ce67e7032b078c5a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa36c0813a2f8c213bb5b041ce67e7032b078c5a/comments", "author": null, "committer": null, "parents": [{"sha": "868e82ab1fa87c6801acb82b0fb4e079e4e25356", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/868e82ab1fa87c6801acb82b0fb4e079e4e25356", "html_url": "https://github.com/Rust-GCC/gccrs/commit/868e82ab1fa87c6801acb82b0fb4e079e4e25356"}], "stats": {"total": 92, "additions": 71, "deletions": 21}, "files": [{"sha": "7def192d6fad2ee208bb4794f4fb836e9d58f95b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa36c0813a2f8c213bb5b041ce67e7032b078c5a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa36c0813a2f8c213bb5b041ce67e7032b078c5a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=aa36c0813a2f8c213bb5b041ce67e7032b078c5a", "patch": "@@ -1,3 +1,20 @@\n+Wed Dec  3 11:44:52 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* tree.c (is_overloaded_fn): Handle getting a fn template.\n+\t(really_overloaded_fn): Likewise.\n+\t* error.c (dump_decl): Handle TEMPLATE_ID_EXPRs better.\n+\t* pt.c (check_explicit_specialization): Tweak.\n+\t(determine_explicit_specialization): Tweak.\n+\n+\t* tree.c, cp-tree.h (get_target_expr): New fn.\n+\n+1997-12-02  Mark Mitchell  <mmitchell@usa.net>\n+\n+\t* pt.c (determine_explicit_specialization): Avoid an internal\n+\terror for bad specializations.\n+\n+\t* method.c (build_overload_value): Handle SCOPE_REF.\n+\n Tue Dec  2 19:18:50 1997  Mike Stump  <mrs@wrs.com>\n \n \t* class.c (prepare_fresh_vtable): Enable even more complex MI"}, {"sha": "e1653020194cccea7170650eb318b4a5ac3365c9", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa36c0813a2f8c213bb5b041ce67e7032b078c5a/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa36c0813a2f8c213bb5b041ce67e7032b078c5a/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=aa36c0813a2f8c213bb5b041ce67e7032b078c5a", "patch": "@@ -2425,6 +2425,7 @@ extern tree min_tree_cons\t\t\tPROTO((tree, tree, tree));\n extern int lvalue_p\t\t\t\tPROTO((tree));\n extern int lvalue_or_else\t\t\tPROTO((tree, char *));\n extern tree build_cplus_new\t\t\tPROTO((tree, tree));\n+extern tree get_target_expr\t\t\tPROTO((tree));\n extern tree break_out_cleanups\t\t\tPROTO((tree));\n extern tree break_out_calls\t\t\tPROTO((tree));\n extern tree build_cplus_method_type\t\tPROTO((tree, tree, tree));"}, {"sha": "206474130cd4efd7506860e30942ac330b5ec6ac", "filename": "gcc/cp/error.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa36c0813a2f8c213bb5b041ce67e7032b078c5a/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa36c0813a2f8c213bb5b041ce67e7032b078c5a/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=aa36c0813a2f8c213bb5b041ce67e7032b078c5a", "patch": "@@ -779,7 +779,10 @@ dump_decl (t, v)\n     case TEMPLATE_ID_EXPR:\n       {\n \ttree args;\n-\tdump_type (TREE_OPERAND (t, 0), v);\n+\ttree name = TREE_OPERAND (t, 0);\n+\tif (is_overloaded_fn (name))\n+\t  name = DECL_NAME (get_first_fn (name));\n+\tdump_decl (name, v);\n \tOB_PUTC ('<');\n \tfor (args = TREE_OPERAND (t, 1); args; args = TREE_CHAIN (args))\n \t  {"}, {"sha": "0ab0e236dd5c093f9fbca8b68da28027f69a5fe6", "filename": "gcc/cp/method.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa36c0813a2f8c213bb5b041ce67e7032b078c5a/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa36c0813a2f8c213bb5b041ce67e7032b078c5a/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=aa36c0813a2f8c213bb5b041ce67e7032b078c5a", "patch": "@@ -641,6 +641,14 @@ build_overload_value (type, value, in_template)\n \t  build_overload_identifier (DECL_ASSEMBLER_NAME (value));\n \t  return;\n \t}\n+      else if (TREE_CODE (value) == SCOPE_REF)\n+\t{\n+\t  OB_PUTC2 ('Q', '1');\n+\t  numeric_output_need_bar = 0;\n+\t  build_overload_name (TREE_OPERAND (value, 0), 0, 0);\n+\t  build_overload_identifier (TREE_OPERAND (value, 1));\n+\t  return;\n+\t}\n       else\n \tmy_friendly_abort (71);\n       break; /* not really needed */"}, {"sha": "58ecc3ce456d14a5ee98023c88695b1aadfffcab", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa36c0813a2f8c213bb5b041ce67e7032b078c5a/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa36c0813a2f8c213bb5b041ce67e7032b078c5a/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=aa36c0813a2f8c213bb5b041ce67e7032b078c5a", "patch": "@@ -352,27 +352,27 @@ determine_explicit_specialization (template_id, type, targs_out,\n   int overloaded;\n   tree fns;\n   tree matching_fns = NULL_TREE;\n-  tree name = NULL_TREE;\n   tree result;\n   tree fn;\n \n-  my_friendly_assert (TREE_CODE (template_id) == TEMPLATE_ID_EXPR,\n-\t\t      0); \n+  my_friendly_assert (TREE_CODE (template_id) == TEMPLATE_ID_EXPR\n+\t\t      && TREE_OPERAND (template_id, 0), 0); \n \t\t      \n   fns = TREE_OPERAND (template_id, 0);\n \n-  overloaded = fns != NULL_TREE && really_overloaded_fn (fns);\n+  if (is_overloaded_fn (fns))\n+    fn = get_first_fn (fns);\n+  else\n+    fn = NULL_TREE;\n+\n+  overloaded = really_overloaded_fn (fns);\n \n-  for (fn = (fns != NULL_TREE) ? get_first_fn (fns) : NULL_TREE; \n-       fn != NULL_TREE; \n+  for (; fn != NULL_TREE; \n        fn = overloaded ? DECL_CHAIN (fn) : NULL_TREE)\n     {\n       int dummy = 0;\n       tree targs;\n \n-      if (name == NULL_TREE)\n-\tname = DECL_NAME (fn);\n-\n       if (TREE_CODE (fn) != TEMPLATE_DECL\n \t  || (need_member_template && !is_member_template (fn)))\n \tcontinue;\n@@ -424,8 +424,9 @@ determine_explicit_specialization (template_id, type, targs_out,\n   if (matching_fns == NULL_TREE)\n     {\n       if (complain)\n-\tcp_error (\"Specialization of `%s' does not match any template declaration.\",\n-\t\t  IDENTIFIER_POINTER (name));\n+\tcp_error (\"`%D' does not match any template declaration.\",\n+\t\t  template_id);\n+\n       *targs_out = NULL_TREE;\n       return NULL_TREE;\n     }\n@@ -496,8 +497,8 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \t  && !processing_explicit_specialization (template_count)\n \t  && !is_friend)\n \t{\n-\t  if (!have_def && ! template_header_count)\n-\t    /* This is not an explicit specialization.  It must be\n+\t  if (! have_def && ! template_header_count && ! ctype)\n+\t    /* This is not an explict specialization.  It must be\n \t       an explicit instantiation.  */\n \t    return 2;\n \t  else if (template_header_count > template_count\n@@ -507,7 +508,7 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \t\t\tdeclarator);\n \t      return 0;\n \t    }\n-\t  else if (pedantic)\n+\t  else if (pedantic || uses_template_parms (decl))\n \t    pedwarn (\"explicit specialization not preceeded by `template <>'\");\n \t}\n "}, {"sha": "2d048abff4278dc4d613707309617d2ba357c9e5", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa36c0813a2f8c213bb5b041ce67e7032b078c5a/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa36c0813a2f8c213bb5b041ce67e7032b078c5a/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=aa36c0813a2f8c213bb5b041ce67e7032b078c5a", "patch": "@@ -248,6 +248,7 @@ build_cplus_new (type, init)\n     return init;\n \n   slot = build (VAR_DECL, type);\n+  DECL_ARTIFICIAL (slot) = 1;\n   layout_decl (slot, 0);\n   rval = build (NEW_EXPR, type,\n \t\tTREE_OPERAND (init, 0), TREE_OPERAND (init, 1), slot);\n@@ -258,6 +259,25 @@ build_cplus_new (type, init)\n   return rval;\n }\n \n+/* Encapsulate the expression INIT in a TARGET_EXPR.  */\n+\n+tree\n+get_target_expr (init)\n+     tree init;\n+{\n+  tree slot;\n+  tree rval;\n+\n+  slot = build (VAR_DECL, TREE_TYPE (init));\n+  DECL_ARTIFICIAL (slot) = 1;\n+  layout_decl (slot, 0);\n+  rval = build (TARGET_EXPR, TREE_TYPE (init), slot, init,\n+\t\tNULL_TREE, NULL_TREE);\n+  TREE_SIDE_EFFECTS (rval) = 1;\n+\n+  return rval;\n+}\n+\n /* Recursively search EXP for CALL_EXPRs that need cleanups and replace\n    these CALL_EXPRs with tree nodes that will perform the cleanups.  */\n \n@@ -1273,15 +1293,14 @@ int\n is_overloaded_fn (x)\n      tree x;\n {\n-  if (TREE_CODE (x) == FUNCTION_DECL)\n-    return 1;\n-\n-  if (TREE_CODE (x) == TEMPLATE_ID_EXPR)\n+  if (TREE_CODE (x) == FUNCTION_DECL\n+      || TREE_CODE (x) == TEMPLATE_ID_EXPR\n+      || DECL_FUNCTION_TEMPLATE_P (x))\n     return 1;\n \n   if (TREE_CODE (x) == TREE_LIST\n       && (TREE_CODE (TREE_VALUE (x)) == FUNCTION_DECL\n-\t  || TREE_CODE (TREE_VALUE (x)) == TEMPLATE_DECL))\n+\t  || DECL_FUNCTION_TEMPLATE_P (TREE_VALUE (x))))\n     return 1;\n \n   return 0;\n@@ -1291,7 +1310,8 @@ int\n really_overloaded_fn (x)\n      tree x;\n {     \n-  if (TREE_CODE (x) == TEMPLATE_ID_EXPR)\n+  if (TREE_CODE (x) == TEMPLATE_ID_EXPR\n+      || DECL_FUNCTION_TEMPLATE_P (x))\n     return 1;\n \n   if (TREE_CODE (x) == TREE_LIST"}]}