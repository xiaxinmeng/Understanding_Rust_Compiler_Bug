{"sha": "91507076503d57982218c726a712c48adc7a4e1d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTE1MDcwNzY1MDNkNTc5ODIyMThjNzI2YTcxMmM0OGFkYzdhNGUxZA==", "commit": {"author": {"name": "CohenArthur", "email": "arthur.cohen@epita.fr", "date": "2021-08-11T21:30:11Z"}, "committer": {"name": "CohenArthur", "email": "arthur.cohen@epita.fr", "date": "2021-09-05T15:21:40Z"}, "message": "name_mangling: Add Mangler class with multiple versions", "tree": {"sha": "2a84bd1e2ea1df140aa3ac31b1c3fd5dbf0cea33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a84bd1e2ea1df140aa3ac31b1c3fd5dbf0cea33"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91507076503d57982218c726a712c48adc7a4e1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91507076503d57982218c726a712c48adc7a4e1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91507076503d57982218c726a712c48adc7a4e1d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91507076503d57982218c726a712c48adc7a4e1d/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50623899998de5a8ffe47227a351c2b3dd29aa0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50623899998de5a8ffe47227a351c2b3dd29aa0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50623899998de5a8ffe47227a351c2b3dd29aa0a"}], "stats": {"total": 318, "additions": 211, "deletions": 107}, "files": [{"sha": "14294f3fc3e1d63b9ff53b7cccb289c76bb675de", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91507076503d57982218c726a712c48adc7a4e1d/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91507076503d57982218c726a712c48adc7a4e1d/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=91507076503d57982218c726a712c48adc7a4e1d", "patch": "@@ -70,6 +70,7 @@ GRS_OBJS = \\\n     rust/rust-ast-full-test.o \\\n     rust/rust-session-manager.o \\\n     rust/rust-compile.o \\\n+    rust/rust-mangle.o \\\n     rust/rust-compile-resolve-path.o \\\n     rust/rust-macro-expand.o \\\n     rust/rust-hir-full-test.o \\"}, {"sha": "126d0588fd2899be915532959acd852e802077b8", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91507076503d57982218c726a712c48adc7a4e1d/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91507076503d57982218c726a712c48adc7a4e1d/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=91507076503d57982218c726a712c48adc7a4e1d", "patch": "@@ -28,6 +28,7 @@\n #include \"rust-ast-full.h\"\n #include \"rust-hir-full.h\"\n #include \"rust-hir-const-fold-ctx.h\"\n+#include \"rust-mangle.h\"\n \n namespace Rust {\n namespace Compile {\n@@ -45,7 +46,7 @@ class Context\n     : backend (backend), resolver (Resolver::Resolver::get ()),\n       tyctx (Resolver::TypeCheckContext::get ()),\n       mappings (Analysis::Mappings::get ()),\n-      const_ctx (ConstFold::Context::get ())\n+      const_ctx (ConstFold::Context::get ()), mangler (Mangler (Mangler::MangleVersion::LEGACY))\n   {\n     // insert the builtins\n     auto builtins = resolver->get_builtin_types ();\n@@ -285,13 +286,19 @@ class Context\n     return pop;\n   }\n \n-  // this needs to support Legacy and V0 see github #429 or #305\n   std::string mangle_item (const TyTy::BaseType *ty,\n-\t\t\t   const Resolver::CanonicalPath &path) const;\n+\t\t\t   const Resolver::CanonicalPath &path) const\n+  {\n+    return mangler.mangle_item (ty, path, mappings->get_current_crate_name ());\n+  }\n \n   std::string mangle_impl_item (const TyTy::BaseType *self,\n \t\t\t\tconst TyTy::BaseType *ty,\n-\t\t\t\tconst std::string &name) const;\n+\t\t\t\tconst std::string &name) const\n+  {\n+    return mangler.mangle_impl_item (self, ty, name,\n+\t\t\t\t     mappings->get_current_crate_name ());\n+  }\n \n private:\n   ::Backend *backend;\n@@ -300,6 +307,7 @@ class Context\n   Analysis::Mappings *mappings;\n   ConstFold::Context *const_ctx;\n   std::set<HirId> builtin_range;\n+  Mangler mangler;\n \n   // state\n   std::vector<fncontext> fn_stack;"}, {"sha": "ef2c16a1ed5a97785261b2fe7cd81e1f371c17fa", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 0, "deletions": 103, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91507076503d57982218c726a712c48adc7a4e1d/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91507076503d57982218c726a712c48adc7a4e1d/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=91507076503d57982218c726a712c48adc7a4e1d", "patch": "@@ -22,7 +22,6 @@\n #include \"rust-compile-struct-field-expr.h\"\n #include \"rust-hir-trait-resolve.h\"\n #include \"rust-hir-path-probe.h\"\n-#include \"fnv-hash.h\"\n \n namespace Rust {\n namespace Compile {\n@@ -538,107 +537,5 @@ HIRCompileBase::compile_locals_for_block (Resolver::Rib &rib, Bfunction *fndecl,\n \n   return true;\n }\n-\n-// Mr Mangle time\n-\n-static const std::string kMangledSymbolPrefix = \"_ZN\";\n-static const std::string kMangledSymbolDelim = \"E\";\n-static const std::string kMangledGenericDelim = \"$C$\";\n-static const std::string kMangledSubstBegin = \"$LT$\";\n-static const std::string kMangledSubstEnd = \"$GT$\";\n-\n-static std::string\n-mangle_name (const std::string &name)\n-{\n-  return std::to_string (name.size ()) + name;\n-}\n-\n-static std::string\n-mangle_canonical_path (const Resolver::CanonicalPath &path)\n-{\n-  std::string buffer;\n-  path.iterate_segs ([&] (const Resolver::CanonicalPath &p) -> bool {\n-    buffer += mangle_name (p.get ());\n-    return true;\n-  });\n-  return buffer;\n-}\n-\n-// rustc uses a sip128 hash for legacy mangling, but an fnv 128 was quicker to\n-// implement for now\n-static std::string\n-legacy_hash (const std::string &fingerprint)\n-{\n-  Hash::FNV128 hasher;\n-  hasher.write ((const unsigned char *) fingerprint.c_str (),\n-\t\tfingerprint.size ());\n-\n-  uint64_t hi, lo;\n-  hasher.sum (&hi, &lo);\n-\n-  char hex[16 + 1];\n-  memset (hex, 0, sizeof hex);\n-  snprintf (hex, sizeof hex, \"%08\" PRIx64 \"%08\" PRIx64, lo, hi);\n-\n-  return \"h\" + std::string (hex, sizeof (hex) - 1);\n-}\n-\n-static std::string\n-mangle_self (const TyTy::BaseType *self)\n-{\n-  if (self->get_kind () != TyTy::TypeKind::ADT)\n-    return mangle_name (self->get_name ());\n-\n-  const TyTy::ADTType *s = static_cast<const TyTy::ADTType *> (self);\n-  std::string buf = s->get_identifier ();\n-\n-  if (s->has_subsititions_defined ())\n-    {\n-      buf += kMangledSubstBegin;\n-\n-      const std::vector<TyTy::SubstitutionParamMapping> &params\n-\t= s->get_substs ();\n-      for (size_t i = 0; i < params.size (); i++)\n-\t{\n-\t  const TyTy::SubstitutionParamMapping &sub = params.at (i);\n-\t  buf += sub.as_string ();\n-\n-\t  if ((i + 1) < params.size ())\n-\t    buf += kMangledGenericDelim;\n-\t}\n-\n-      buf += kMangledSubstEnd;\n-    }\n-\n-  return mangle_name (buf);\n-}\n-\n-std::string\n-Context::mangle_item (const TyTy::BaseType *ty,\n-\t\t      const Resolver::CanonicalPath &path) const\n-{\n-  const std::string &crate_name = mappings->get_current_crate_name ();\n-\n-  const std::string hash = legacy_hash (ty->as_string ());\n-  const std::string hash_sig = mangle_name (hash);\n-\n-  return kMangledSymbolPrefix + mangle_name (crate_name)\n-\t + mangle_canonical_path (path) + hash_sig + kMangledSymbolDelim;\n-}\n-\n-// FIXME this is a wee bit broken\n-std::string\n-Context::mangle_impl_item (const TyTy::BaseType *self, const TyTy::BaseType *ty,\n-\t\t\t   const std::string &name) const\n-{\n-  const std::string &crate_name = mappings->get_current_crate_name ();\n-\n-  const std::string hash = legacy_hash (ty->as_string ());\n-  const std::string hash_sig = mangle_name (hash);\n-\n-  return kMangledSymbolPrefix + mangle_name (crate_name) + mangle_self (self)\n-\t + mangle_name (name) + hash_sig + kMangledSymbolDelim;\n-}\n-\n } // namespace Compile\n } // namespace Rust"}, {"sha": "f2e6e156bbc61bd49f0bf225c97bc58d76ac795b", "filename": "gcc/rust/backend/rust-mangle.cc", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91507076503d57982218c726a712c48adc7a4e1d/gcc%2Frust%2Fbackend%2Frust-mangle.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91507076503d57982218c726a712c48adc7a4e1d/gcc%2Frust%2Fbackend%2Frust-mangle.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-mangle.cc?ref=91507076503d57982218c726a712c48adc7a4e1d", "patch": "@@ -0,0 +1,149 @@\n+#include \"rust-mangle.h\"\n+#include \"fnv-hash.h\"\n+\n+// FIXME: Rename those to legacy_*\n+static const std::string kMangledSymbolPrefix = \"_ZN\";\n+static const std::string kMangledSymbolDelim = \"E\";\n+static const std::string kMangledGenericDelim = \"$C$\";\n+static const std::string kMangledSubstBegin = \"$LT$\";\n+static const std::string kMangledSubstEnd = \"$GT$\";\n+\n+namespace Rust {\n+namespace Compile {\n+\n+static std::string\n+legacy_mangle_name (const std::string &name)\n+{\n+  return std::to_string (name.size ()) + name;\n+}\n+\n+static std::string\n+legacy_mangle_canonical_path (const Resolver::CanonicalPath &path)\n+{\n+  std::string buffer;\n+  path.iterate_segs ([&] (const Resolver::CanonicalPath &p) -> bool {\n+    buffer += legacy_mangle_name (p.get ());\n+    return true;\n+  });\n+  return buffer;\n+}\n+\n+// rustc uses a sip128 hash for legacy mangling, but an fnv 128 was quicker to\n+// implement for now\n+static std::string\n+legacy_hash (const std::string &fingerprint)\n+{\n+  Hash::FNV128 hasher;\n+  hasher.write ((const unsigned char *) fingerprint.c_str (),\n+\t\tfingerprint.size ());\n+\n+  uint64_t hi, lo;\n+  hasher.sum (&hi, &lo);\n+\n+  char hex[16 + 1];\n+  memset (hex, 0, sizeof hex);\n+  snprintf (hex, sizeof hex, \"%08\" PRIx64 \"%08\" PRIx64, lo, hi);\n+\n+  return \"h\" + std::string (hex, sizeof (hex) - 1);\n+}\n+\n+static std::string\n+legacy_mangle_self (const TyTy::BaseType *self)\n+{\n+  if (self->get_kind () != TyTy::TypeKind::ADT)\n+    return legacy_mangle_name (self->get_name ());\n+\n+  const TyTy::ADTType *s = static_cast<const TyTy::ADTType *> (self);\n+  std::string buf = s->get_identifier ();\n+\n+  if (s->has_subsititions_defined ())\n+    {\n+      buf += kMangledSubstBegin;\n+\n+      const std::vector<TyTy::SubstitutionParamMapping> &params\n+\t= s->get_substs ();\n+      for (size_t i = 0; i < params.size (); i++)\n+\t{\n+\t  const TyTy::SubstitutionParamMapping &sub = params.at (i);\n+\t  buf += sub.as_string ();\n+\n+\t  if ((i + 1) < params.size ())\n+\t    buf += kMangledGenericDelim;\n+\t}\n+\n+      buf += kMangledSubstEnd;\n+    }\n+\n+  return legacy_mangle_name (buf);\n+}\n+\n+static std::string\n+legacy_mangle_item (const TyTy::BaseType *ty, const Resolver::CanonicalPath &path,\n+\t\t\t     const std::string &crate_name)\n+{\n+  const std::string hash = legacy_hash (ty->as_string ());\n+  const std::string hash_sig = legacy_mangle_name (hash);\n+\n+  return kMangledSymbolPrefix + legacy_mangle_name (crate_name)\n+\t + legacy_mangle_canonical_path (path) + hash_sig + kMangledSymbolDelim;\n+}\n+\n+// FIXME this is a wee bit broken\n+static std::string\n+legacy_mangle_impl_item (const TyTy::BaseType *self,\n+\t\t\t\t  const TyTy::BaseType *ty,\n+\t\t\t\t  const std::string &name,\n+\t\t\t\t  const std::string &crate_name)\n+{\n+  const std::string hash = legacy_hash (ty->as_string ());\n+  const std::string hash_sig = legacy_mangle_name (hash);\n+\n+  return kMangledSymbolPrefix + legacy_mangle_name (crate_name)\n+\t + legacy_mangle_self (self) + legacy_mangle_name (name) + hash_sig\n+\t + kMangledSymbolDelim;\n+}\n+\n+// FIXME: Uncomment once v0 mangling is implemented\n+// static std::string\n+// Mangler::v0_mangle_item (const TyTy::BaseType *ty,\n+// \t\t\t const std::string &name)\n+// {}\n+//\n+// static std::string\n+// Mangler::v0_mangle_impl_item (const TyTy::BaseType *self,\n+// \t\t\t      const TyTy::BaseType *ty,\n+// \t\t\t      const std::string &name)\n+// {}\n+\n+std::string\n+Mangler::mangle_item (const TyTy::BaseType *ty, const Resolver::CanonicalPath &path,\n+\t\t      const std::string &crate_name) const\n+{\n+  switch (version)\n+    {\n+    case Mangler::MangleVersion::LEGACY:\n+      return legacy_mangle_item (ty, path, crate_name);\n+    case Mangler::MangleVersion::V0:\n+      gcc_unreachable ();\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+std::string\n+Mangler::mangle_impl_item (const TyTy::BaseType *self, const TyTy::BaseType *ty,\n+\t\t\t   const std::string &name,\n+\t\t\t   const std::string &crate_name) const\n+{\n+  switch (version)\n+    {\n+    case Mangler::MangleVersion::LEGACY:\n+      return legacy_mangle_impl_item (self, ty, name, crate_name);\n+    case Mangler::MangleVersion::V0:\n+      gcc_unreachable ();\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+} // namespace Compile\n+} // namespace Rust"}, {"sha": "8ed5ab6fa804a0794ddb620167ca1dd3316ffa72", "filename": "gcc/rust/backend/rust-mangle.h", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91507076503d57982218c726a712c48adc7a4e1d/gcc%2Frust%2Fbackend%2Frust-mangle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91507076503d57982218c726a712c48adc7a4e1d/gcc%2Frust%2Fbackend%2Frust-mangle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-mangle.h?ref=91507076503d57982218c726a712c48adc7a4e1d", "patch": "@@ -0,0 +1,49 @@\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_MANGLE_H\n+#define RUST_MANGLE_H\n+\n+#include \"rust-compile-tyty.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+class Mangler\n+{\n+public:\n+  enum MangleVersion\n+  {\n+    LEGACY,\n+    V0,\n+  };\n+\n+  Mangler (MangleVersion version) : version (version) {}\n+\n+  // this needs to support Legacy and V0 see github #429 or #305\n+  std::string mangle_item (const TyTy::BaseType *ty, const Resolver::CanonicalPath &path,\n+\t\t\t   const std::string &crate_name) const;\n+\n+  std::string mangle_impl_item (const TyTy::BaseType *self,\n+\t\t\t\tconst TyTy::BaseType *ty,\n+\t\t\t\tconst std::string &name,\n+\t\t\t   const std::string &crate_name) const;\n+\n+private:\n+  enum MangleVersion version;\n+};\n+} // namespace Compile\n+} // namespace Rust\n+#endif // RUST_MANGLE_H"}]}