{"sha": "57d6c446c787d1dacd89c5cd504747d6857ad494", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTdkNmM0NDZjNzg3ZDFkYWNkODljNWNkNTA0NzQ3ZDY4NTdhZDQ5NA==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2013-11-24T19:15:36Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2013-11-24T19:15:36Z"}, "message": "jump.c (reset_insn_reg_label_operand_notes): New function, split out from ...\n\n\n\t* jump.c (reset_insn_reg_label_operand_notes): New function,\n\tsplit out from ...\n\t(init_label_info): ... here.  Reset LABEL_NUSES in cfglayout mode.\n\t* cfgcleanup.c (delete_dead_jump_tables_between): New function,\n\tsplit out from ...\n\t(delete_dead_jumptables): ... here.  Handle cfglayout mode.\n\t(cleanup_cfg): Delete dead jump tables in cfglayout mode if an\n\texpensive CFG cleanup is called for.\n\t* cfgrtl.c (fixup_reorder_chain): Remove BARRIERs from fallthru paths.\n\t(cfg_layout_finalize): Delete dead jump tables before re-building\n\tthe insns chain.\n\t* ira.c (ira): Rebuild jump labels *after* deleting unreachable\n\tbasic blocks, not before.\n\t* loop-init.c (rtl_loop_done): Call for an expensive CFG cleanup.\n\n\t* modulo-sched.c (sms_schedule): Do not look for BARRIERs in the\n\tinsns chain of a scheduling extended basic block, they cannot appear\n\tthere in cfglayout mode.\n\nFrom-SVN: r205337", "tree": {"sha": "f5db0208687505d3114934ff0a9f353f86b4947f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5db0208687505d3114934ff0a9f353f86b4947f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/57d6c446c787d1dacd89c5cd504747d6857ad494", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57d6c446c787d1dacd89c5cd504747d6857ad494", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57d6c446c787d1dacd89c5cd504747d6857ad494", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57d6c446c787d1dacd89c5cd504747d6857ad494/comments", "author": null, "committer": null, "parents": [{"sha": "58b07297511c491cdd3feab39fcb0d84713f736e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58b07297511c491cdd3feab39fcb0d84713f736e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58b07297511c491cdd3feab39fcb0d84713f736e"}], "stats": {"total": 230, "additions": 159, "deletions": 71}, "files": [{"sha": "29ac53cb0fd402868821de0f7f74660720716f7b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57d6c446c787d1dacd89c5cd504747d6857ad494/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57d6c446c787d1dacd89c5cd504747d6857ad494/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=57d6c446c787d1dacd89c5cd504747d6857ad494", "patch": "@@ -1,3 +1,24 @@\n+2013-11-24  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* jump.c (reset_insn_reg_label_operand_notes): New function,\n+\tsplit out from ...\n+\t(init_label_info): ... here.  Reset LABEL_NUSES in cfglayout mode.\n+\t* cfgcleanup.c (delete_dead_jump_tables_between): New function,\n+\tsplit out from ...\n+\t(delete_dead_jumptables): ... here.  Handle cfglayout mode.\n+\t(cleanup_cfg): Delete dead jump tables in cfglayout mode if an\n+\texpensive CFG cleanup is called for.\n+\t* cfgrtl.c (fixup_reorder_chain): Remove BARRIERs from fallthru paths.\n+\t(cfg_layout_finalize): Delete dead jump tables before re-building\n+\tthe insns chain.\n+\t* ira.c (ira): Rebuild jump labels *after* deleting unreachable\n+\tbasic blocks, not before.\n+\t* loop-init.c (rtl_loop_done): Call for an expensive CFG cleanup.\n+\n+\t* modulo-sched.c (sms_schedule): Do not look for BARRIERs in the\n+\tinsns chain of a scheduling extended basic block, they cannot appear\n+\tthere in cfglayout mode.\n+\n 2013-11-24  Tobias Burnus  <burnus@net-b.de>\n \n \t* doc/invoke.texi (-fsanitize=leak): Add link to the wiki page."}, {"sha": "e909b03253dc0061d8dd889a3c20c133d74738ee", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 57, "deletions": 32, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57d6c446c787d1dacd89c5cd504747d6857ad494/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57d6c446c787d1dacd89c5cd504747d6857ad494/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=57d6c446c787d1dacd89c5cd504747d6857ad494", "patch": "@@ -2944,40 +2944,65 @@ delete_unreachable_blocks (void)\n   return changed;\n }\n \n+\f\n+/* Look for, and delete, any dead jumptables between START and END.  */\n+\n+static void\n+delete_dead_jump_tables_between (rtx start, rtx end)\n+{\n+  rtx insn, next;\n+\n+  for (insn = start; insn != end; insn = next)\n+    {\n+      next = NEXT_INSN (insn);\n+      if (next != NULL_RTX\n+\t  && LABEL_P (insn)\n+\t  && LABEL_NUSES (insn) == LABEL_PRESERVE_P (insn)\n+\t  && JUMP_TABLE_DATA_P (next))\n+\t{\n+\t  rtx label = insn, jump = next;\n+\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Dead jumptable %i removed\\n\",\n+\t\t     INSN_UID (insn));\n+\n+\t  next = NEXT_INSN (next);\n+\t  delete_insn (jump);\n+\t  delete_insn (label);\n+\t}\n+    }\n+}\n+\n+\n /* Delete any jump tables never referenced.  We can't delete them at the\n-   time of removing tablejump insn as they are referenced by the preceding\n-   insns computing the destination, so we delay deleting and garbagecollect\n-   them once life information is computed.  */\n+   time of removing tablejump insn as the label preceding the jump table\n+   data may be referenced by the preceding insns computing the destination.\n+   So we delay deleting and garbage-collect them from time to time, after\n+   a CFG cleanup.  */\n+\n void\n delete_dead_jumptables (void)\n {\n   basic_block bb;\n \n-  /* A dead jump table does not belong to any basic block.  Scan insns\n-     between two adjacent basic blocks.  */\n+  /* Label reference count must up-to-date to detect dead jump tables.  */\n+  rebuild_jump_labels (get_insns ());\n+\n   FOR_EACH_BB (bb)\n     {\n-      rtx insn, next;\n-\n-      for (insn = NEXT_INSN (BB_END (bb));\n-\t   insn && !NOTE_INSN_BASIC_BLOCK_P (insn);\n-\t   insn = next)\n+      if (current_ir_type () == IR_RTL_CFGLAYOUT)\n \t{\n-\t  next = NEXT_INSN (insn);\n-\t  if (LABEL_P (insn)\n-\t      && LABEL_NUSES (insn) == LABEL_PRESERVE_P (insn)\n-\t      && JUMP_TABLE_DATA_P (next))\n-\t    {\n-\t      rtx label = insn, jump = next;\n-\n-\t      if (dump_file)\n-\t\tfprintf (dump_file, \"Dead jumptable %i removed\\n\",\n-\t\t\t INSN_UID (insn));\n-\n-\t      next = NEXT_INSN (next);\n-\t      delete_insn (jump);\n-\t      delete_insn (label);\n-\t    }\n+\t  /* Jump tables only appear in the header or footer of BB.  */\n+\t  delete_dead_jump_tables_between (BB_HEADER (bb), NULL_RTX);\n+\t  delete_dead_jump_tables_between (BB_FOOTER (bb), NULL_RTX);\n+\t}\n+      else\n+\t{\n+\t  /* Jump tables are in the insns chain between basic blocks.  */\n+\t  rtx start = NEXT_INSN (BB_END (bb));\n+\t  rtx end = (bb->next_bb == EXIT_BLOCK_PTR_FOR_FN (cfun))\n+\t    ? NULL_RTX : BB_HEAD (bb->next_bb);\n+\t  delete_dead_jump_tables_between (start, end);\n \t}\n     }\n }\n@@ -3049,13 +3074,13 @@ cleanup_cfg (int mode)\n   if (mode & CLEANUP_CROSSJUMP)\n     remove_fake_exit_edges ();\n \n-  /* Don't call delete_dead_jumptables in cfglayout mode, because\n-     that function assumes that jump tables are in the insns stream.\n-     But we also don't _have_ to delete dead jumptables in cfglayout\n-     mode because we shouldn't even be looking at things that are\n-     not in a basic block.  Dead jumptables are cleaned up when\n-     going out of cfglayout mode.  */\n-  if (!(mode & CLEANUP_CFGLAYOUT))\n+  /* Don't always call delete_dead_jumptables in cfglayout mode, because\n+     jump tables can only appear in the headers and footers of basic blocks\n+     and we usually are not interested in anything hiding there.\n+     But if an expensive cleanup is called for, garbage-collect the dead\n+     jump tables to get label reference counts right.  This sometimes\n+     allows some labels to be removed and more basic blocks to be merged.  */\n+  if (!(mode & CLEANUP_CFGLAYOUT) || (mode & CLEANUP_EXPENSIVE))\n     delete_dead_jumptables ();\n \n   /* ???  We probably do this way too often.  */"}, {"sha": "4ce7273834c4e3b49aec62b52a2da66c0a6261de", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57d6c446c787d1dacd89c5cd504747d6857ad494/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57d6c446c787d1dacd89c5cd504747d6857ad494/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=57d6c446c787d1dacd89c5cd504747d6857ad494", "patch": "@@ -3696,10 +3696,10 @@ fixup_reorder_chain (void)\n #endif\n \n   /* Now add jumps and labels as needed to match the blocks new\n-     outgoing edges.  */\n+     outgoing edges.  Fixup missing or redundant BARRIERs.  */\n \n-  for (bb = ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb; bb ; bb = (basic_block)\n-       bb->aux)\n+  for (bb = ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb; bb ;\n+       bb = (basic_block) bb->aux)\n     {\n       edge e_fall, e_taken, e;\n       rtx bb_end_insn;\n@@ -3853,13 +3853,26 @@ fixup_reorder_chain (void)\n \n   relink_block_chain (/*stay_in_cfglayout_mode=*/false);\n \n-  /* Annoying special case - jump around dead jumptables left in the code.  */\n+  /* Annoying special case - stray barriers left in the code.  This happens\n+     if a tablejump is transformed to a simpe or confitional jump, or if a\n+     basic block ending in a tablejump is removed but the jump table itself\n+     is not.  */\n   FOR_EACH_BB (bb)\n     {\n       edge e = find_fallthru_edge (bb->succs);\n \n-      if (e && !can_fallthru (e->src, e->dest))\n-\tforce_nonfallthru (e);\n+      if (e && e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun))\n+\t{\n+\t  rtx insn, next;\n+\t  for (insn = NEXT_INSN (BB_END (e->src));\n+\t       insn != BB_HEAD (e->dest);\n+\t       insn = next)\n+\t    {\n+\t      next = NEXT_INSN (insn);\n+\t      if (BARRIER_P (insn))\n+\t\tremove_insn (insn);\n+\t    }\n+\t}\n     }\n \n   /* Ensure goto_locus from edges has some instructions with that locus\n@@ -4273,14 +4286,15 @@ break_superblocks (void)\n }\n \n /* Finalize the changes: reorder insn list according to the sequence specified\n-   by aux pointers, enter compensation code, rebuild scope forest.  */\n+   by aux pointers, enter compensation code.  */\n \n void\n cfg_layout_finalize (void)\n {\n #ifdef ENABLE_CHECKING\n   verify_flow_info ();\n #endif\n+  delete_dead_jumptables ();\n   force_one_exit_fallthru ();\n   rtl_register_cfg_hooks ();\n   if (reload_completed\n@@ -4291,9 +4305,6 @@ cfg_layout_finalize (void)\n     fixup_fallthru_exit_predecessor ();\n   fixup_reorder_chain ();\n \n-  rebuild_jump_labels (get_insns ());\n-  delete_dead_jumptables ();\n-\n #ifdef ENABLE_CHECKING\n   verify_insn_chain ();\n   verify_flow_info ();"}, {"sha": "43f98d4d69a6d7620ed80a24c825c7c0b71d004f", "filename": "gcc/ira.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57d6c446c787d1dacd89c5cd504747d6857ad494/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57d6c446c787d1dacd89c5cd504747d6857ad494/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=57d6c446c787d1dacd89c5cd504747d6857ad494", "patch": "@@ -5273,9 +5273,9 @@ ira (FILE *f)\n   if (optimize && rebuild_p)\n     {\n       timevar_push (TV_JUMP);\n-      rebuild_jump_labels (get_insns ());\n       if (purge_all_dead_edges ())\n \tdelete_unreachable_blocks ();\n+      rebuild_jump_labels (get_insns ());\n       timevar_pop (TV_JUMP);\n     }\n "}, {"sha": "87f9619d7510b3097921a24e7a2432d32b7af608", "filename": "gcc/jump.c", "status": "modified", "additions": 57, "deletions": 23, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57d6c446c787d1dacd89c5cd504747d6857ad494/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57d6c446c787d1dacd89c5cd504747d6857ad494/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=57d6c446c787d1dacd89c5cd504747d6857ad494", "patch": "@@ -177,6 +177,34 @@ make_pass_cleanup_barriers (gcc::context *ctxt)\n }\n \n \f\n+/* Remove all REG_LABEL_OPERAND notes from INSN.\n+\n+   REG_LABEL_TARGET notes (including the JUMP_LABEL field) are sticky and\n+   not reset here; that way we won't lose association with a label when\n+   e.g. the source for a target register disappears out of reach for targets\n+   that may use jump-target registers.  Jump transformations are supposed to\n+   transform any REG_LABEL_TARGET notes.  The target label reference in a\n+   branch may disappear from the branch (and from the instruction before it)\n+   for other reasons, like register allocation.  */\n+\n+static void\n+reset_insn_reg_label_operand_notes (rtx insn)\n+{\n+  if (INSN_P (insn))\n+    {\n+      rtx note, next;\n+\n+      for (note = REG_NOTES (insn); note; note = next)\n+\t{\n+\t  next = XEXP (note, 1);\n+\t  if (REG_NOTE_KIND (note) == REG_LABEL_OPERAND\n+\t      && ! reg_mentioned_p (XEXP (note, 0), PATTERN (insn)))\n+\t    remove_note (insn, note);\n+\t}\n+    }\n+}\n+\n+\n /* Initialize LABEL_NUSES and JUMP_LABEL fields, add REG_LABEL_TARGET\n    for remaining targets for JUMP_P.  Delete any REG_LABEL_OPERAND\n    notes whose labels don't occur in the insn any more.  */\n@@ -186,32 +214,38 @@ init_label_info (rtx f)\n {\n   rtx insn;\n \n-  for (insn = f; insn; insn = NEXT_INSN (insn))\n+  if (current_ir_type () == IR_RTL_CFGLAYOUT)\n     {\n-      if (LABEL_P (insn))\n-\tLABEL_NUSES (insn) = (LABEL_PRESERVE_P (insn) != 0);\n-\n-      /* REG_LABEL_TARGET notes (including the JUMP_LABEL field) are\n-\t sticky and not reset here; that way we won't lose association\n-\t with a label when e.g. the source for a target register\n-\t disappears out of reach for targets that may use jump-target\n-\t registers.  Jump transformations are supposed to transform\n-\t any REG_LABEL_TARGET notes.  The target label reference in a\n-\t branch may disappear from the branch (and from the\n-\t instruction before it) for other reasons, like register\n-\t allocation.  */\n-\n-      if (INSN_P (insn))\n+      basic_block bb;\n+\n+      FOR_EACH_BB (bb)\n \t{\n-\t  rtx note, next;\n+\t  /* Labels only appear between BB_HEAD and the basic block note,\n+\t     and in the basic block header and footer.  */\n+\t  for (insn = BB_HEAD (bb);\n+\t       insn && LABEL_P (insn);\n+\t       insn = NEXT_INSN (insn))\n+\t    LABEL_NUSES (insn) = (LABEL_PRESERVE_P (insn) != 0);\n+\t  for (insn = BB_HEADER (bb); insn; insn = NEXT_INSN (insn))\n+\t    if (LABEL_P (insn))\n+\t      LABEL_NUSES (insn) = (LABEL_PRESERVE_P (insn) != 0);\n+\t  for (insn = BB_FOOTER (bb); insn; insn = NEXT_INSN (insn))\n+\t    if (LABEL_P (insn))\n+\t      LABEL_NUSES (insn) = (LABEL_PRESERVE_P (insn) != 0);\n \n-\t  for (note = REG_NOTES (insn); note; note = next)\n-\t    {\n-\t      next = XEXP (note, 1);\n-\t      if (REG_NOTE_KIND (note) == REG_LABEL_OPERAND\n-\t\t  && ! reg_mentioned_p (XEXP (note, 0), PATTERN (insn)))\n-\t\tremove_note (insn, note);\n-\t    }\n+\t  FOR_BB_INSNS (bb, insn)\n+\t    if (INSN_P (insn))\n+\t      reset_insn_reg_label_operand_notes (insn);\n+\t}\n+    }\n+  else\n+    {\n+      for (insn = f; insn; insn = NEXT_INSN (insn))\n+\t{\n+\t  if (LABEL_P (insn))\n+\t    LABEL_NUSES (insn) = (LABEL_PRESERVE_P (insn) != 0);\n+\t  if (INSN_P (insn))\n+\t    reset_insn_reg_label_operand_notes (insn);\n \t}\n     }\n }"}, {"sha": "0d8e43837445d6693daa8cb61094f5599581da73", "filename": "gcc/loop-init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57d6c446c787d1dacd89c5cd504747d6857ad494/gcc%2Floop-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57d6c446c787d1dacd89c5cd504747d6857ad494/gcc%2Floop-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-init.c?ref=57d6c446c787d1dacd89c5cd504747d6857ad494", "patch": "@@ -415,7 +415,7 @@ rtl_loop_done (void)\n   loop_optimizer_finalize ();\n   free_dominance_info (CDI_DOMINATORS);\n \n-  cleanup_cfg (0);\n+  cleanup_cfg (CLEANUP_EXPENSIVE);\n   if (dump_file)\n     {\n       dump_reg_info (dump_file);"}, {"sha": "444ffda34e9b624390dd26f7fb969daf3ec75d0f", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57d6c446c787d1dacd89c5cd504747d6857ad494/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57d6c446c787d1dacd89c5cd504747d6857ad494/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=57d6c446c787d1dacd89c5cd504747d6857ad494", "patch": "@@ -1471,7 +1471,7 @@ sms_schedule (void)\n \tcontinue;\n       }\n \n-      /* Don't handle BBs with calls or barriers\n+      /* Don't handle BBs with calls\n \t or !single_set with the exception of instructions that include\n \t count_reg---these instructions are part of the control part\n \t that do-loop recognizes.\n@@ -1481,7 +1481,6 @@ sms_schedule (void)\n          rtx set;\n \n         if (CALL_P (insn)\n-            || BARRIER_P (insn)\n             || (NONDEBUG_INSN_P (insn) && !JUMP_P (insn)\n                 && !single_set (insn) && GET_CODE (PATTERN (insn)) != USE\n                 && !reg_mentioned_p (count_reg, insn))\n@@ -1496,8 +1495,6 @@ sms_schedule (void)\n \t    {\n \t      if (CALL_P (insn))\n \t\tfprintf (dump_file, \"SMS loop-with-call\\n\");\n-\t      else if (BARRIER_P (insn))\n-\t\tfprintf (dump_file, \"SMS loop-with-barrier\\n\");\n               else if ((NONDEBUG_INSN_P (insn) && !JUMP_P (insn)\n                 && !single_set (insn) && GET_CODE (PATTERN (insn)) != USE))\n                 fprintf (dump_file, \"SMS loop-with-not-single-set\\n\");"}]}