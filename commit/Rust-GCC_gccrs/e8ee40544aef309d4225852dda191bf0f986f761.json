{"sha": "e8ee40544aef309d4225852dda191bf0f986f761", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZThlZTQwNTQ0YWVmMzA5ZDQyMjU4NTJkZGExOTFiZjBmOTg2Zjc2MQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2014-09-23T17:11:07Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2014-09-23T17:11:07Z"}, "message": "rs6000.md (f32_vsx): New mode attributes to refine the constraints used on 32/64-bit floating point...\n\n2014-09-23  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/rs6000.md (f32_vsx): New mode attributes to\n\trefine the constraints used on 32/64-bit floating point moves.\n\t(f32_av): Likewise.\n\t(f64_vsx): Likewise.\n\t(f64_dm): Likewise.\n\t(f64_av): Likewise.\n\t(BOOL_REGS_OUTPUT): Use wt constraint for TImode instead of wa.\n\t(BOOL_REGS_OP1): Likewise.\n\t(BOOL_REGS_OP2): Likewise.\n\t(BOOL_REGS_UNARY): Likewise.\n\t(mov<mode>_hardfloat, SFmode/SDmode): Tighten down constraints for\n\t32/64-bit floating point moves.  Do not use wa, instead use ww/ws\n\tfor moves involving VSX registers.  Do not use constraints that\n\ttarget VSX registers for decimal types.\n\t(mov<mode>_hardfloat32, DFmode/DDmode): Likewise.\n\t(mov<mode>_hardfloat64, DFmode/DDmode): Likewise.\n\nFrom-SVN: r215521", "tree": {"sha": "ccabde2df6de7d1184bd037e76d38e61d0cadd9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ccabde2df6de7d1184bd037e76d38e61d0cadd9f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e8ee40544aef309d4225852dda191bf0f986f761", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8ee40544aef309d4225852dda191bf0f986f761", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8ee40544aef309d4225852dda191bf0f986f761", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8ee40544aef309d4225852dda191bf0f986f761/comments", "author": null, "committer": null, "parents": [{"sha": "10b8fa2ed23366f5a9224a050db24b5f9d1236ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10b8fa2ed23366f5a9224a050db24b5f9d1236ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10b8fa2ed23366f5a9224a050db24b5f9d1236ab"}], "stats": {"total": 56, "additions": 46, "deletions": 10}, "files": [{"sha": "62369c7500b84bc5dbc813d7848be83f9186618d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ee40544aef309d4225852dda191bf0f986f761/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ee40544aef309d4225852dda191bf0f986f761/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e8ee40544aef309d4225852dda191bf0f986f761", "patch": "@@ -1,3 +1,22 @@\n+2014-09-23  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000.md (f32_vsx): New mode attributes to\n+\trefine the constraints used on 32/64-bit floating point moves.\n+\t(f32_av): Likewise.\n+\t(f64_vsx): Likewise.\n+\t(f64_dm): Likewise.\n+\t(f64_av): Likewise.\n+\t(BOOL_REGS_OUTPUT): Use wt constraint for TImode instead of wa.\n+\t(BOOL_REGS_OP1): Likewise.\n+\t(BOOL_REGS_OP2): Likewise.\n+\t(BOOL_REGS_UNARY): Likewise.\n+\t(mov<mode>_hardfloat, SFmode/SDmode): Tighten down constraints for\n+\t32/64-bit floating point moves.  Do not use wa, instead use ww/ws\n+\tfor moves involving VSX registers.  Do not use constraints that\n+\ttarget VSX registers for decimal types.\n+\t(mov<mode>_hardfloat32, DFmode/DDmode): Likewise.\n+\t(mov<mode>_hardfloat64, DFmode/DDmode): Likewise.\n+\n 2014-09-23  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* tree.h (int_bit_position): Turn into inline function;"}, {"sha": "8ce53a5069cc616ad91f0134b46619c58e5c21fa", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 27, "deletions": 10, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ee40544aef309d4225852dda191bf0f986f761/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ee40544aef309d4225852dda191bf0f986f761/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=e8ee40544aef309d4225852dda191bf0f986f761", "patch": "@@ -401,8 +401,25 @@\n (define_mode_attr f32_sv [(SF \"stxsspx %x1,%y0\")  (SD \"stxsiwzx %x1,%y0\")])\n \n ; Definitions for 32-bit fpr direct move\n+; At present, the decimal modes are not allowed in the traditional altivec\n+; registers, so restrict the constraints to just the traditional FPRs.\n (define_mode_attr f32_dm [(SF \"wn\") (SD \"wh\")])\n \n+; Definitions for 32-bit VSX\n+(define_mode_attr f32_vsx [(SF \"ww\") (SD \"wn\")])\n+\n+; Definitions for 32-bit use of altivec registers\n+(define_mode_attr f32_av  [(SF \"wu\") (SD \"wn\")])\n+\n+; Definitions for 64-bit VSX\n+(define_mode_attr f64_vsx [(DF \"ws\") (DD \"wn\")])\n+\n+; Definitions for 64-bit direct move\n+(define_mode_attr f64_dm  [(DF \"wk\") (DD \"wh\")])\n+\n+; Definitions for 64-bit use of altivec registers\n+(define_mode_attr f64_av  [(DF \"wv\") (DD \"wn\")])\n+\n ; These modes do not fit in integer registers in 32-bit mode.\n ; but on e500v2, the gpr are 64 bit registers\n (define_mode_iterator DIFD [DI (DF \"!TARGET_E500_DOUBLE\") DD])\n@@ -528,7 +545,7 @@\n ;; either.\n \n ;; Mode attribute for boolean operation register constraints for output\n-(define_mode_attr BOOL_REGS_OUTPUT\t[(TI\t\"&r,r,r,wa,v\")\n+(define_mode_attr BOOL_REGS_OUTPUT\t[(TI\t\"&r,r,r,wt,v\")\n \t\t\t\t\t (PTI\t\"&r,r,r\")\n \t\t\t\t\t (V16QI\t\"wa,v,&?r,?r,?r\")\n \t\t\t\t\t (V8HI\t\"wa,v,&?r,?r,?r\")\n@@ -539,7 +556,7 @@\n \t\t\t\t\t (V1TI\t\"wa,v,&?r,?r,?r\")])\n \n ;; Mode attribute for boolean operation register constraints for operand1\n-(define_mode_attr BOOL_REGS_OP1\t\t[(TI\t\"r,0,r,wa,v\")\n+(define_mode_attr BOOL_REGS_OP1\t\t[(TI\t\"r,0,r,wt,v\")\n \t\t\t\t\t (PTI\t\"r,0,r\")\n \t\t\t\t\t (V16QI\t\"wa,v,r,0,r\")\n \t\t\t\t\t (V8HI\t\"wa,v,r,0,r\")\n@@ -550,7 +567,7 @@\n \t\t\t\t\t (V1TI\t\"wa,v,r,0,r\")])\n \n ;; Mode attribute for boolean operation register constraints for operand2\n-(define_mode_attr BOOL_REGS_OP2\t\t[(TI\t\"r,r,0,wa,v\")\n+(define_mode_attr BOOL_REGS_OP2\t\t[(TI\t\"r,r,0,wt,v\")\n \t\t\t\t\t (PTI\t\"r,r,0\")\n \t\t\t\t\t (V16QI\t\"wa,v,r,r,0\")\n \t\t\t\t\t (V8HI\t\"wa,v,r,r,0\")\n@@ -563,7 +580,7 @@\n ;; Mode attribute for boolean operation register constraints for operand1\n ;; for one_cmpl.  To simplify things, we repeat the constraint where 0\n ;; is used for operand1 or operand2\n-(define_mode_attr BOOL_REGS_UNARY\t[(TI\t\"r,0,0,wa,v\")\n+(define_mode_attr BOOL_REGS_UNARY\t[(TI\t\"r,0,0,wt,v\")\n \t\t\t\t\t (PTI\t\"r,0,0\")\n \t\t\t\t\t (V16QI\t\"wa,v,r,0,0\")\n \t\t\t\t\t (V8HI\t\"wa,v,r,0,0\")\n@@ -7805,8 +7822,8 @@\n }\")\n \n (define_insn \"mov<mode>_hardfloat\"\n-  [(set (match_operand:FMOVE32 0 \"nonimmediate_operand\" \"=!r,!r,m,f,wa,wa,<f32_lr>,<f32_sm>,wu,Z,?<f32_dm>,?r,*c*l,!r,*h,!r,!r\")\n-\t(match_operand:FMOVE32 1 \"input_operand\" \"r,m,r,f,wa,j,<f32_lm>,<f32_sr>,Z,wu,r,<f32_dm>,r,h,0,G,Fn\"))]\n+  [(set (match_operand:FMOVE32 0 \"nonimmediate_operand\" \"=!r,!r,m,f,<f32_vsx>,<f32_vsx>,<f32_lr>,<f32_sm>,<f32_av>,Z,?<f32_dm>,?r,*c*l,!r,*h,!r,!r\")\n+\t(match_operand:FMOVE32 1 \"input_operand\" \"r,m,r,f,<f32_vsx>,j,<f32_lm>,<f32_sr>,Z,<f32_av>,r,<f32_dm>,r, h, 0, G,Fn\"))]\n   \"(gpc_reg_operand (operands[0], <MODE>mode)\n    || gpc_reg_operand (operands[1], <MODE>mode))\n    && (TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT)\"\n@@ -7944,8 +7961,8 @@\n ;; reloading.\n \n (define_insn \"*mov<mode>_hardfloat32\"\n-  [(set (match_operand:FMOVE64 0 \"nonimmediate_operand\" \"=m,d,d,wv,Z,wa,wa,Y,r,!r,!r,!r,!r\")\n-\t(match_operand:FMOVE64 1 \"input_operand\" \"d,m,d,Z,wv,wa,j,r,Y,r,G,H,F\"))]\n+  [(set (match_operand:FMOVE64 0 \"nonimmediate_operand\" \"=m,d,d,<f64_av>,Z,<f64_vsx>,<f64_vsx>,Y,r,!r,!r,!r,!r\")\n+\t(match_operand:FMOVE64 1 \"input_operand\" \"d,m,d,Z,<f64_av>,<f64_vsx>,j,r,Y,r,G,H,F\"))]\n   \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT \n    && (gpc_reg_operand (operands[0], <MODE>mode)\n        || gpc_reg_operand (operands[1], <MODE>mode))\"\n@@ -7982,8 +7999,8 @@\n ; ld/std require word-aligned displacements -> 'Y' constraint.\n ; List Y->r and r->Y before r->r for reload.\n (define_insn \"*mov<mode>_hardfloat64\"\n-  [(set (match_operand:FMOVE64 0 \"nonimmediate_operand\" \"=m,d,d,wv,Z,wa,wa,Y,r,!r,*c*l,!r,*h,!r,!r,!r,r,wg,r,wk\")\n-\t(match_operand:FMOVE64 1 \"input_operand\" \"d,m,d,Z,wv,wa,j,r,Y,r,r,h,0,G,H,F,wg,r,wk,r\"))]\n+  [(set (match_operand:FMOVE64 0 \"nonimmediate_operand\" \"=m,d,d,<f64_av>,Z,<f64_vsx>,<f64_vsx>,Y,r,!r,*c*l,!r,*h,!r,!r,!r,r,wg,r,<f64_dm>\")\n+\t(match_operand:FMOVE64 1 \"input_operand\" \"d,m,d,Z,<f64_av>,<f64_vsx>,j,r,Y,r,r,h,0,G,H,F,wg,r,<f64_dm>,r\"))]\n   \"TARGET_POWERPC64 && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n    && (gpc_reg_operand (operands[0], <MODE>mode)\n        || gpc_reg_operand (operands[1], <MODE>mode))\""}]}