{"sha": "aa18f65ad4bfdd9a566d7ebc3fd66075b29e35af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWExOGY2NWFkNGJmZGQ5YTU2NmQ3ZWJjM2ZkNjYwNzViMjllMzVhZg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2016-06-11T12:07:54Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2016-06-11T12:07:54Z"}, "message": "trans.c (build_binary_op_trapv): If no operand is a constant, use the generic implementation of the middle-end...\n\n\t* gcc-interface/trans.c (build_binary_op_trapv): If no operand is a\n\tconstant, use the generic implementation of the middle-end; otherwise\n\tturn the dynamic conditions into static conditions and simplify.\n\nFrom-SVN: r237328", "tree": {"sha": "fc84956b83b2d88bfb609430cc42dc8cdaf1f443", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc84956b83b2d88bfb609430cc42dc8cdaf1f443"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa18f65ad4bfdd9a566d7ebc3fd66075b29e35af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa18f65ad4bfdd9a566d7ebc3fd66075b29e35af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa18f65ad4bfdd9a566d7ebc3fd66075b29e35af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa18f65ad4bfdd9a566d7ebc3fd66075b29e35af/comments", "author": null, "committer": null, "parents": [{"sha": "a31d78c6a0b25dbc9076e357925a9b07a5d96f73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a31d78c6a0b25dbc9076e357925a9b07a5d96f73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a31d78c6a0b25dbc9076e357925a9b07a5d96f73"}], "stats": {"total": 255, "additions": 128, "deletions": 127}, "files": [{"sha": "6f2fda6004bfa58be5f45f6d32dff24d0198f927", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa18f65ad4bfdd9a566d7ebc3fd66075b29e35af/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa18f65ad4bfdd9a566d7ebc3fd66075b29e35af/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=aa18f65ad4bfdd9a566d7ebc3fd66075b29e35af", "patch": "@@ -1,3 +1,9 @@\n+2016-06-11  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/trans.c (build_binary_op_trapv): If no operand is a\n+\tconstant, use the generic implementation of the middle-end; otherwise\n+\tturn the dynamic conditions into static conditions and simplify.\n+\n 2016-06-11  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/trans.c (Case_Statement_to_gnu): Deal with characters."}, {"sha": "2f47e9aa63e13b457a9daa6647895161242e8859", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 122, "deletions": 127, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa18f65ad4bfdd9a566d7ebc3fd66075b29e35af/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa18f65ad4bfdd9a566d7ebc3fd66075b29e35af/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=aa18f65ad4bfdd9a566d7ebc3fd66075b29e35af", "patch": "@@ -8875,19 +8875,16 @@ build_binary_op_trapv (enum tree_code code, tree gnu_type, tree left,\n   tree rhs = gnat_protect_expr (right);\n   tree type_max = TYPE_MAX_VALUE (gnu_type);\n   tree type_min = TYPE_MIN_VALUE (gnu_type);\n-  tree zero = build_int_cst (gnu_type, 0);\n-  tree gnu_expr, rhs_lt_zero, tmp1, tmp2;\n-  tree check_pos, check_neg, check;\n+  tree gnu_expr, check;\n+  int sgn;\n \n   /* Assert that the precision is a power of 2.  */\n   gcc_assert ((precision & (precision - 1)) == 0);\n \n-  /* Prefer a constant or known-positive rhs to simplify checks.  */\n-  if (!TREE_CONSTANT (rhs)\n-      && commutative_tree_code (code)\n-      && (TREE_CONSTANT (lhs)\n-\t  || (!tree_expr_nonnegative_p (rhs)\n-\t      && tree_expr_nonnegative_p (lhs))))\n+  /* Prefer a constant on the RHS to simplify checks.  */\n+  if (TREE_CODE (rhs) != INTEGER_CST\n+      && TREE_CODE (lhs) == INTEGER_CST\n+      && (code == PLUS_EXPR || code == MULT_EXPR))\n     {\n       tree tmp = lhs;\n       lhs = rhs;\n@@ -8898,151 +8895,149 @@ build_binary_op_trapv (enum tree_code code, tree gnu_type, tree left,\n \n   /* If we can fold the expression to a constant, just return it.\n      The caller will deal with overflow, no need to generate a check.  */\n-  if (TREE_CONSTANT (gnu_expr))\n+  if (TREE_CODE (gnu_expr) == INTEGER_CST)\n     return gnu_expr;\n \n-  rhs_lt_zero = tree_expr_nonnegative_p (rhs)\n-\t\t? boolean_false_node\n-\t\t: build_binary_op (LT_EXPR, boolean_type_node, rhs, zero);\n-\n-  /* ??? Should use more efficient check for operand_equal_p (lhs, rhs, 0) */\n-\n-  /* Try a few strategies that may be cheaper than the general\n-     code at the end of the function, if the rhs is not known.\n-     The strategies are:\n-       - Call library function for 64-bit multiplication (complex)\n-       - Widen, if input arguments are sufficiently small\n-       - Determine overflow using wrapped result for addition/subtraction.  */\n-\n-  if (!TREE_CONSTANT (rhs))\n+  /* If no operand is a constant, we use the generic implementation.  */\n+  if (TREE_CODE (lhs) != INTEGER_CST && TREE_CODE (rhs) != INTEGER_CST)\n     {\n-      /* Even for add/subtract double size to get another base type.  */\n-      const unsigned int needed_precision = precision * 2;\n-\n-      if (code == MULT_EXPR && precision == 64)\n+      /* Never inline a 64-bit mult for a 32-bit target, it's way too long.  */\n+      if (code == MULT_EXPR && precision == 64 && BITS_PER_WORD < 64)\n \t{\n-\t  tree int_64 = gnat_type_for_size (64, 0);\n-\n+\t  tree int64 = gnat_type_for_size (64, 0);\n \t  return convert (gnu_type, build_call_n_expr (mulv64_decl, 2,\n-\t\t\t\t\t\t       convert (int_64, lhs),\n-\t\t\t\t\t\t       convert (int_64, rhs)));\n+\t\t\t\t\t\t       convert (int64, lhs),\n+\t\t\t\t\t\t       convert (int64, rhs)));\n \t}\n \n-      if (needed_precision <= BITS_PER_WORD\n-\t  || (code == MULT_EXPR && needed_precision <= LONG_LONG_TYPE_SIZE))\n-\t{\n-\t  tree wide_type = gnat_type_for_size (needed_precision, 0);\n-\t  tree wide_result = build_binary_op (code, wide_type,\n-\t\t\t\t\t      convert (wide_type, lhs),\n-\t\t\t\t\t      convert (wide_type, rhs));\n-\n-\t  check = build_binary_op\n-\t    (TRUTH_ORIF_EXPR, boolean_type_node,\n-\t     build_binary_op (LT_EXPR, boolean_type_node, wide_result,\n-\t\t\t      convert (wide_type, type_min)),\n-\t     build_binary_op (GT_EXPR, boolean_type_node, wide_result,\n-\t\t\t      convert (wide_type, type_max)));\n+      enum internal_fn icode;\n \n-\t  return\n-\t    emit_check (check, gnu_expr, CE_Overflow_Check_Failed, gnat_node);\n-\t}\n-\n-      if (code == PLUS_EXPR || code == MINUS_EXPR)\n+      switch (code)\n \t{\n-\t  tree unsigned_type = gnat_type_for_size (precision, 1);\n-\t  tree wrapped_expr\n-\t    = convert (gnu_type,\n-\t\t       build_binary_op (code, unsigned_type,\n-\t\t\t\t\tconvert (unsigned_type, lhs),\n-\t\t\t\t\tconvert (unsigned_type, rhs)));\n-\n-\t  /* Overflow when (rhs < 0) ^ (wrapped_expr < lhs)), for addition\n-\t     or when (rhs < 0) ^ (wrapped_expr > lhs) for subtraction.  */\n-\t  check\n-\t    = build_binary_op (TRUTH_XOR_EXPR, boolean_type_node, rhs_lt_zero,\n-\t\t\t       build_binary_op (code == PLUS_EXPR\n-\t\t\t\t\t\t? LT_EXPR : GT_EXPR,\n-\t\t\t\t\t        boolean_type_node,\n-\t\t\t\t\t\twrapped_expr, lhs));\n-\n-\t  return\n-\t    emit_check (check, gnu_expr, CE_Overflow_Check_Failed, gnat_node);\n+\tcase PLUS_EXPR:\n+\t  icode = IFN_ADD_OVERFLOW;\n+\t  break;\n+\tcase MINUS_EXPR:\n+\t  icode = IFN_SUB_OVERFLOW;\n+\t  break;\n+\tcase MULT_EXPR:\n+\t  icode = IFN_MUL_OVERFLOW;\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n+\n+      tree gnu_ctype = build_complex_type (gnu_type);\n+      tree call\n+\t= build_call_expr_internal_loc (UNKNOWN_LOCATION, icode, gnu_ctype, 2,\n+\t\t\t\t\tlhs, rhs);\n+      tree tgt = save_expr (call);\n+      gnu_expr = build1 (REALPART_EXPR, gnu_type, tgt);\n+      check\n+\t= convert (boolean_type_node, build1 (IMAGPART_EXPR, gnu_type, tgt));\n+      return\n+\temit_check (check, gnu_expr, CE_Overflow_Check_Failed, gnat_node);\n    }\n \n+  /* If one operand is a constant, we expose the overflow condition to enable\n+     a subsequent simplication or even elimination.  */\n   switch (code)\n     {\n     case PLUS_EXPR:\n-      /* When rhs >= 0, overflow when lhs > type_max - rhs.  */\n-      check_pos = build_binary_op (GT_EXPR, boolean_type_node, lhs,\n-\t\t\t\t   build_binary_op (MINUS_EXPR, gnu_type,\n-\t\t\t\t\t\t    type_max, rhs)),\n-\n-      /* When rhs < 0, overflow when lhs < type_min - rhs.  */\n-      check_neg = build_binary_op (LT_EXPR, boolean_type_node, lhs,\n-\t\t\t\t   build_binary_op (MINUS_EXPR, gnu_type,\n-\t\t\t\t\t\t    type_min, rhs));\n+      sgn = tree_int_cst_sgn (rhs);\n+      if (sgn > 0)\n+\t/* When rhs > 0, overflow when lhs > type_max - rhs.  */\n+\tcheck = build_binary_op (GT_EXPR, boolean_type_node, lhs,\n+\t\t\t\t build_binary_op (MINUS_EXPR, gnu_type,\n+\t\t\t\t\t\t  type_max, rhs));\n+      else if (sgn < 0)\n+\t/* When rhs < 0, overflow when lhs < type_min - rhs.  */\n+\tcheck = build_binary_op (LT_EXPR, boolean_type_node, lhs,\n+\t\t\t\t build_binary_op (MINUS_EXPR, gnu_type,\n+\t\t\t\t\t\t  type_min, rhs));\n+      else\n+\treturn gnu_expr;\n       break;\n \n     case MINUS_EXPR:\n-      /* When rhs >= 0, overflow when lhs < type_min + rhs.  */\n-      check_pos = build_binary_op (LT_EXPR, boolean_type_node, lhs,\n-\t\t\t\t   build_binary_op (PLUS_EXPR, gnu_type,\n-\t\t\t\t\t\t    type_min, rhs)),\n-\n-      /* When rhs < 0, overflow when lhs > type_max + rhs.  */\n-      check_neg = build_binary_op (GT_EXPR, boolean_type_node, lhs,\n-\t\t\t\t   build_binary_op (PLUS_EXPR, gnu_type,\n-\t\t\t\t\t\t    type_max, rhs));\n+      if (TREE_CODE (lhs) == INTEGER_CST)\n+\t{\n+\t  sgn = tree_int_cst_sgn (lhs);\n+\t  if (sgn > 0)\n+\t    /* When lhs > 0, overflow when rhs < lhs - type_max.  */\n+\t    check = build_binary_op (LT_EXPR, boolean_type_node, rhs,\n+\t\t\t\t     build_binary_op (MINUS_EXPR, gnu_type,\n+\t\t\t\t\t\t      lhs, type_max));\n+\t  else if (sgn < 0)\n+\t    /* When lhs < 0, overflow when rhs > lhs - type_min.  */\n+\t    check = build_binary_op (GT_EXPR, boolean_type_node, rhs,\n+\t\t\t\t     build_binary_op (MINUS_EXPR, gnu_type,\n+\t\t\t\t\t\t      lhs, type_min));\n+\t  else\n+\t    return gnu_expr;\n+\t}\n+      else\n+\t{\n+\t  sgn = tree_int_cst_sgn (rhs);\n+\t  if (sgn > 0)\n+\t    /* When rhs > 0, overflow when lhs < type_min + rhs.  */\n+\t    check = build_binary_op (LT_EXPR, boolean_type_node, lhs,\n+\t\t\t\t     build_binary_op (PLUS_EXPR, gnu_type,\n+\t\t\t\t\t\t      type_min, rhs));\n+\t  else if (sgn < 0)\n+\t    /* When rhs < 0, overflow when lhs > type_max + rhs.  */\n+\t    check = build_binary_op (GT_EXPR, boolean_type_node, lhs,\n+\t\t\t\t     build_binary_op (PLUS_EXPR, gnu_type,\n+\t\t\t\t\t\t      type_max, rhs));\n+\t  else\n+\t    return gnu_expr;\n+\t}\n       break;\n \n     case MULT_EXPR:\n-      /* The check here is designed to be efficient if the rhs is constant,\n-\t but it will work for any rhs by using integer division.\n-\t Four different check expressions determine whether X * C overflows,\n-\t depending on C.\n-\t   C ==  0  =>  false\n-\t   C  >  0  =>  X > type_max / C || X < type_min / C\n-\t   C == -1  =>  X == type_min\n-\t   C  < -1  =>  X > type_min / C || X < type_max / C */\n-\n-      tmp1 = build_binary_op (TRUNC_DIV_EXPR, gnu_type, type_max, rhs);\n-      tmp2 = build_binary_op (TRUNC_DIV_EXPR, gnu_type, type_min, rhs);\n-\n-      check_pos\n-\t= build_binary_op (TRUTH_ANDIF_EXPR, boolean_type_node,\n-\t\t\t   build_binary_op (NE_EXPR, boolean_type_node, zero,\n-\t\t\t\t\t    rhs),\n-\t\t\t   build_binary_op (TRUTH_ORIF_EXPR, boolean_type_node,\n-\t\t\t\t\t    build_binary_op (GT_EXPR,\n-\t\t\t\t\t\t\t     boolean_type_node,\n-\t\t\t\t\t\t\t     lhs, tmp1),\n-\t\t\t\t\t    build_binary_op (LT_EXPR,\n-\t\t\t\t\t\t\t     boolean_type_node,\n-\t\t\t\t\t\t\t     lhs, tmp2)));\n-\n-      check_neg\n-\t= fold_build3 (COND_EXPR, boolean_type_node,\n-\t\t       build_binary_op (EQ_EXPR, boolean_type_node, rhs,\n-\t\t\t\t\tbuild_int_cst (gnu_type, -1)),\n-\t\t       build_binary_op (EQ_EXPR, boolean_type_node, lhs,\n-\t\t\t\t\ttype_min),\n-\t\t       build_binary_op (TRUTH_ORIF_EXPR, boolean_type_node,\n-\t\t\t\t\tbuild_binary_op (GT_EXPR,\n-\t\t\t\t\t\t\t boolean_type_node,\n-\t\t\t\t\t\t\t lhs, tmp2),\n-\t\t\t\t\tbuild_binary_op (LT_EXPR,\n-\t\t\t\t\t\t\t boolean_type_node,\n-\t\t\t\t\t\t\t lhs, tmp1)));\n+      sgn = tree_int_cst_sgn (rhs);\n+      if (sgn > 0)\n+\t{\n+\t  if (integer_onep (rhs))\n+\t    return gnu_expr;\n+\n+\t  tree lb = build_binary_op (TRUNC_DIV_EXPR, gnu_type, type_min, rhs);\n+\t  tree ub = build_binary_op (TRUNC_DIV_EXPR, gnu_type, type_max, rhs);\n+\n+\t  /* When rhs > 1, overflow outside [type_min/rhs; type_max/rhs].  */\n+\t  check\n+\t    = build_binary_op (TRUTH_ORIF_EXPR, boolean_type_node,\n+\t\t\t       build_binary_op (LT_EXPR, boolean_type_node,\n+\t\t\t\t\t\tlhs, lb),\n+\t\t\t       build_binary_op (GT_EXPR, boolean_type_node,\n+\t\t\t\t\t\tlhs, ub));\n+\t}\n+      else if (sgn < 0)\n+\t{\n+\t  tree lb = build_binary_op (TRUNC_DIV_EXPR, gnu_type, type_max, rhs);\n+\t  tree ub = build_binary_op (TRUNC_DIV_EXPR, gnu_type, type_min, rhs);\n+\n+\t  if (integer_minus_onep (rhs))\n+\t    /* When rhs == -1, overflow if lhs == type_min.  */\n+\t    check\n+\t      = build_binary_op (EQ_EXPR, boolean_type_node, lhs, type_min);\n+\t  else\n+\t    /* When rhs < -1, overflow outside [type_max/rhs; type_min/rhs].  */\n+\t    check\n+\t      = build_binary_op (TRUTH_ORIF_EXPR, boolean_type_node,\n+\t\t\t\t build_binary_op (LT_EXPR, boolean_type_node,\n+\t\t\t\t\t\t  lhs, lb),\n+\t\t\t\t build_binary_op (GT_EXPR, boolean_type_node,\n+\t\t\t\t\t\t  lhs, ub));\n+\t}\n+      else\n+\treturn gnu_expr;\n       break;\n \n     default:\n       gcc_unreachable ();\n     }\n \n-  check = fold_build3 (COND_EXPR, boolean_type_node, rhs_lt_zero, check_neg,\n-\t\t       check_pos);\n-\n   return emit_check (check, gnu_expr, CE_Overflow_Check_Failed, gnat_node);\n }\n "}]}