{"sha": "37478789dc446a28ffc642ee121e8c3959e5fe47", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzc0Nzg3ODlkYzQ0NmEyOGZmYzY0MmVlMTIxZThjMzk1OWU1ZmU0Nw==", "commit": {"author": {"name": "Kewen Lin", "email": "linkw@gcc.gnu.org", "date": "2020-06-04T05:57:19Z"}, "committer": {"name": "Kewen Lin", "email": "linkw@linux.ibm.com", "date": "2020-06-11T08:35:30Z"}, "message": "vect: Rename things related to rgroup_masks\n\nPower supports vector memory access with length (in bytes) instructions.\nLike existing fully masking for SVE, it is another approach to vectorize\nthe loop using partially-populated vectors.\n\nAs Richard Sandiford pointed out, we can rename the rgroup struct\nrgroup_masks to rgroup_controls, rename its members mask_type to type,\nmasks to controls to be more generic.\n\nBesides, this patch also renames some functions like vect_set_loop_mask\nto vect_set_loop_control, release_vec_loop_masks to\nrelease_vec_loop_controls, vect_set_loop_masks_directly to\nvect_set_loop_controls_directly.\n\nBootstrapped/regtested on aarch64-linux-gnu.\n\ngcc/ChangeLog:\n\n\t* tree-vect-loop-manip.c (vect_set_loop_mask): Renamed to ...\n\t(vect_set_loop_control): ... this.\n\t(vect_maybe_permute_loop_masks): Rename rgroup_masks related things.\n\t(vect_set_loop_masks_directly): Renamed to ...\n\t(vect_set_loop_controls_directly): ... this.  Also rename some\n\tvariables with ctrl instead of mask.  Rename vect_set_loop_mask to\n\tvect_set_loop_control.\n\t(vect_set_loop_condition_masked): Rename rgroup_masks related things.\n\tAlso rename some variables with ctrl instead of mask.\n\t* tree-vect-loop.c (release_vec_loop_masks): Renamed to ...\n\t(release_vec_loop_controls): ... this.  Rename rgroup_masks related\n\tthings.\n\t(_loop_vec_info::~_loop_vec_info): Rename release_vec_loop_masks to\n\trelease_vec_loop_controls.\n\t(can_produce_all_loop_masks_p): Rename rgroup_masks related things.\n\t(vect_get_max_nscalars_per_iter): Likewise.\n\t(vect_estimate_min_profitable_iters): Likewise.\n\t(vect_record_loop_mask): Likewise.\n\t(vect_get_loop_mask): Likewise.\n\t* tree-vectorizer.h (struct rgroup_masks): Renamed to ...\n\t(struct rgroup_controls): ... this.  Also rename mask_type\n\tto type and rename masks to controls.", "tree": {"sha": "2a9d870f00773515e70060943943eb72f9bb18c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a9d870f00773515e70060943943eb72f9bb18c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/37478789dc446a28ffc642ee121e8c3959e5fe47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37478789dc446a28ffc642ee121e8c3959e5fe47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37478789dc446a28ffc642ee121e8c3959e5fe47", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37478789dc446a28ffc642ee121e8c3959e5fe47/comments", "author": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3372425ecf3e225d7a2b3c73e061e11498b6f74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3372425ecf3e225d7a2b3c73e061e11498b6f74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3372425ecf3e225d7a2b3c73e061e11498b6f74"}], "stats": {"total": 263, "additions": 133, "deletions": 130}, "files": [{"sha": "806db84cb6135bd50dd4a1c388abcf7af5712f2d", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 86, "deletions": 85, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37478789dc446a28ffc642ee121e8c3959e5fe47/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37478789dc446a28ffc642ee121e8c3959e5fe47/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=37478789dc446a28ffc642ee121e8c3959e5fe47", "patch": "@@ -256,17 +256,17 @@ adjust_phi_and_debug_stmts (gimple *update_phi, edge e, tree new_def)\n \t\t\tgimple_bb (update_phi));\n }\n \n-/* Define one loop mask MASK from loop LOOP.  INIT_MASK is the value that\n-   the mask should have during the first iteration and NEXT_MASK is the\n+/* Define one loop rgroup control CTRL from loop LOOP.  INIT_CTRL is the value\n+   that the control should have during the first iteration and NEXT_CTRL is the\n    value that it should have on subsequent iterations.  */\n \n static void\n-vect_set_loop_mask (class loop *loop, tree mask, tree init_mask,\n-\t\t    tree next_mask)\n+vect_set_loop_control (class loop *loop, tree ctrl, tree init_ctrl,\n+\t\t       tree next_ctrl)\n {\n-  gphi *phi = create_phi_node (mask, loop->header);\n-  add_phi_arg (phi, init_mask, loop_preheader_edge (loop), UNKNOWN_LOCATION);\n-  add_phi_arg (phi, next_mask, loop_latch_edge (loop), UNKNOWN_LOCATION);\n+  gphi *phi = create_phi_node (ctrl, loop->header);\n+  add_phi_arg (phi, init_ctrl, loop_preheader_edge (loop), UNKNOWN_LOCATION);\n+  add_phi_arg (phi, next_ctrl, loop_latch_edge (loop), UNKNOWN_LOCATION);\n }\n \n /* Add SEQ to the end of LOOP's preheader block.  */\n@@ -320,11 +320,11 @@ interleave_supported_p (vec_perm_indices *indices, tree vectype,\n    latter.  Return true on success, adding any new statements to SEQ.  */\n \n static bool\n-vect_maybe_permute_loop_masks (gimple_seq *seq, rgroup_masks *dest_rgm,\n-\t\t\t       rgroup_masks *src_rgm)\n+vect_maybe_permute_loop_masks (gimple_seq *seq, rgroup_controls *dest_rgm,\n+\t\t\t       rgroup_controls *src_rgm)\n {\n-  tree src_masktype = src_rgm->mask_type;\n-  tree dest_masktype = dest_rgm->mask_type;\n+  tree src_masktype = src_rgm->type;\n+  tree dest_masktype = dest_rgm->type;\n   machine_mode src_mode = TYPE_MODE (src_masktype);\n   insn_code icode1, icode2;\n   if (dest_rgm->max_nscalars_per_iter <= src_rgm->max_nscalars_per_iter\n@@ -338,10 +338,10 @@ vect_maybe_permute_loop_masks (gimple_seq *seq, rgroup_masks *dest_rgm,\n       machine_mode dest_mode = insn_data[icode1].operand[0].mode;\n       gcc_assert (dest_mode == insn_data[icode2].operand[0].mode);\n       tree unpack_masktype = vect_halve_mask_nunits (src_masktype, dest_mode);\n-      for (unsigned int i = 0; i < dest_rgm->masks.length (); ++i)\n+      for (unsigned int i = 0; i < dest_rgm->controls.length (); ++i)\n \t{\n-\t  tree src = src_rgm->masks[i / 2];\n-\t  tree dest = dest_rgm->masks[i];\n+\t  tree src = src_rgm->controls[i / 2];\n+\t  tree dest = dest_rgm->controls[i];\n \t  tree_code code = ((i & 1) == (BYTES_BIG_ENDIAN ? 0 : 1)\n \t\t\t    ? VEC_UNPACK_HI_EXPR\n \t\t\t    : VEC_UNPACK_LO_EXPR);\n@@ -371,10 +371,10 @@ vect_maybe_permute_loop_masks (gimple_seq *seq, rgroup_masks *dest_rgm,\n       tree masks[2];\n       for (unsigned int i = 0; i < 2; ++i)\n \tmasks[i] = vect_gen_perm_mask_checked (src_masktype, indices[i]);\n-      for (unsigned int i = 0; i < dest_rgm->masks.length (); ++i)\n+      for (unsigned int i = 0; i < dest_rgm->controls.length (); ++i)\n \t{\n-\t  tree src = src_rgm->masks[i / 2];\n-\t  tree dest = dest_rgm->masks[i];\n+\t  tree src = src_rgm->controls[i / 2];\n+\t  tree dest = dest_rgm->controls[i];\n \t  gimple *stmt = gimple_build_assign (dest, VEC_PERM_EXPR,\n \t\t\t\t\t      src, src, masks[i & 1]);\n \t  gimple_seq_add_stmt (seq, stmt);\n@@ -384,12 +384,12 @@ vect_maybe_permute_loop_masks (gimple_seq *seq, rgroup_masks *dest_rgm,\n   return false;\n }\n \n-/* Helper for vect_set_loop_condition_masked.  Generate definitions for\n-   all the masks in RGM and return a mask that is nonzero when the loop\n-   needs to iterate.  Add any new preheader statements to PREHEADER_SEQ.\n-   Use LOOP_COND_GSI to insert code before the exit gcond.\n+/* Helper for vect_set_loop_condition_partial_vectors.  Generate definitions\n+   for all the rgroup controls in RGC and return a control that is nonzero\n+   when the loop needs to iterate.  Add any new preheader statements to\n+   PREHEADER_SEQ.  Use LOOP_COND_GSI to insert code before the exit gcond.\n \n-   RGM belongs to loop LOOP.  The loop originally iterated NITERS\n+   RGC belongs to loop LOOP.  The loop originally iterated NITERS\n    times and has been vectorized according to LOOP_VINFO.\n \n    If NITERS_SKIP is nonnull, the first iteration of the vectorized loop\n@@ -399,32 +399,32 @@ vect_maybe_permute_loop_masks (gimple_seq *seq, rgroup_masks *dest_rgm,\n \n    It is known that:\n \n-     NITERS * RGM->max_nscalars_per_iter\n+     NITERS * RGC->max_nscalars_per_iter\n \n    does not overflow.  However, MIGHT_WRAP_P says whether an induction\n    variable that starts at 0 and has step:\n \n-     VF * RGM->max_nscalars_per_iter\n+     VF * RGC->max_nscalars_per_iter\n \n    might overflow before hitting a value above:\n \n-     (NITERS + NITERS_SKIP) * RGM->max_nscalars_per_iter\n+     (NITERS + NITERS_SKIP) * RGC->max_nscalars_per_iter\n \n    This means that we cannot guarantee that such an induction variable\n-   would ever hit a value that produces a set of all-false masks for RGM.  */\n+   would ever hit a value that produces a set of all-false masks for RGC.  */\n \n static tree\n-vect_set_loop_masks_directly (class loop *loop, loop_vec_info loop_vinfo,\n-\t\t\t      gimple_seq *preheader_seq,\n-\t\t\t      gimple_stmt_iterator loop_cond_gsi,\n-\t\t\t      rgroup_masks *rgm, tree niters, tree niters_skip,\n-\t\t\t      bool might_wrap_p)\n+vect_set_loop_controls_directly (class loop *loop, loop_vec_info loop_vinfo,\n+\t\t\t\t gimple_seq *preheader_seq,\n+\t\t\t\t gimple_stmt_iterator loop_cond_gsi,\n+\t\t\t\t rgroup_controls *rgc, tree niters,\n+\t\t\t\t tree niters_skip, bool might_wrap_p)\n {\n   tree compare_type = LOOP_VINFO_MASK_COMPARE_TYPE (loop_vinfo);\n   tree iv_type = LOOP_VINFO_MASK_IV_TYPE (loop_vinfo);\n-  tree mask_type = rgm->mask_type;\n-  unsigned int nscalars_per_iter = rgm->max_nscalars_per_iter;\n-  poly_uint64 nscalars_per_mask = TYPE_VECTOR_SUBPARTS (mask_type);\n+  tree ctrl_type = rgc->type;\n+  unsigned int nscalars_per_iter = rgc->max_nscalars_per_iter;\n+  poly_uint64 nscalars_per_ctrl = TYPE_VECTOR_SUBPARTS (ctrl_type);\n   poly_uint64 vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n \n   /* Calculate the maximum number of scalar values that the rgroup\n@@ -436,8 +436,8 @@ vect_set_loop_masks_directly (class loop *loop, loop_vec_info loop_vinfo,\n   tree nscalars_skip = niters_skip;\n   if (nscalars_per_iter != 1)\n     {\n-      /* We checked before choosing to use a fully-masked loop that these\n-\t multiplications don't overflow.  */\n+      /* We checked before setting LOOP_VINFO_USING_PARTIAL_VECTORS_P that\n+\t these multiplications don't overflow.  */\n       tree compare_factor = build_int_cst (compare_type, nscalars_per_iter);\n       tree iv_factor = build_int_cst (iv_type, nscalars_per_iter);\n       nscalars_total = gimple_build (preheader_seq, MULT_EXPR, compare_type,\n@@ -541,27 +541,27 @@ vect_set_loop_masks_directly (class loop *loop, loop_vec_info loop_vinfo,\n   test_index = gimple_convert (&test_seq, compare_type, test_index);\n   gsi_insert_seq_before (test_gsi, test_seq, GSI_SAME_STMT);\n \n-  /* Provide a definition of each mask in the group.  */\n-  tree next_mask = NULL_TREE;\n-  tree mask;\n+  /* Provide a definition of each control in the group.  */\n+  tree next_ctrl = NULL_TREE;\n+  tree ctrl;\n   unsigned int i;\n-  FOR_EACH_VEC_ELT_REVERSE (rgm->masks, i, mask)\n+  FOR_EACH_VEC_ELT_REVERSE (rgc->controls, i, ctrl)\n     {\n-      /* Previous masks will cover BIAS scalars.  This mask covers the\n+      /* Previous controls will cover BIAS scalars.  This control covers the\n \t next batch.  */\n-      poly_uint64 bias = nscalars_per_mask * i;\n+      poly_uint64 bias = nscalars_per_ctrl * i;\n       tree bias_tree = build_int_cst (compare_type, bias);\n       gimple *tmp_stmt;\n \n       /* See whether the first iteration of the vector loop is known\n-\t to have a full mask.  */\n+\t to have a full control.  */\n       poly_uint64 const_limit;\n       bool first_iteration_full\n \t= (poly_int_tree_p (first_limit, &const_limit)\n-\t   && known_ge (const_limit, (i + 1) * nscalars_per_mask));\n+\t   && known_ge (const_limit, (i + 1) * nscalars_per_ctrl));\n \n       /* Rather than have a new IV that starts at BIAS and goes up to\n-\t TEST_LIMIT, prefer to use the same 0-based IV for each mask\n+\t TEST_LIMIT, prefer to use the same 0-based IV for each control\n \t and adjust the bound down by BIAS.  */\n       tree this_test_limit = test_limit;\n       if (i != 0)\n@@ -574,9 +574,9 @@ vect_set_loop_masks_directly (class loop *loop, loop_vec_info loop_vinfo,\n \t\t\t\t\t  bias_tree);\n \t}\n \n-      /* Create the initial mask.  First include all scalars that\n+      /* Create the initial control.  First include all scalars that\n \t are within the loop limit.  */\n-      tree init_mask = NULL_TREE;\n+      tree init_ctrl = NULL_TREE;\n       if (!first_iteration_full)\n \t{\n \t  tree start, end;\n@@ -593,13 +593,13 @@ vect_set_loop_masks_directly (class loop *loop, loop_vec_info loop_vinfo,\n \t    {\n \t      /* FIRST_LIMIT is the maximum number of scalars handled by the\n \t\t first iteration of the vector loop.  Test the portion\n-\t\t associated with this mask.  */\n+\t\t associated with this control.  */\n \t      start = bias_tree;\n \t      end = first_limit;\n \t    }\n \n-\t  init_mask = make_temp_ssa_name (mask_type, NULL, \"max_mask\");\n-\t  tmp_stmt = vect_gen_while (init_mask, start, end);\n+\t  init_ctrl = make_temp_ssa_name (ctrl_type, NULL, \"max_mask\");\n+\t  tmp_stmt = vect_gen_while (init_ctrl, start, end);\n \t  gimple_seq_add_stmt (preheader_seq, tmp_stmt);\n \t}\n \n@@ -610,34 +610,35 @@ vect_set_loop_masks_directly (class loop *loop, loop_vec_info loop_vinfo,\n \t  && !(poly_int_tree_p (nscalars_skip, &const_skip)\n \t       && known_le (const_skip, bias)))\n \t{\n-\t  tree unskipped_mask = vect_gen_while_not (preheader_seq, mask_type,\n+\t  tree unskipped_mask = vect_gen_while_not (preheader_seq, ctrl_type,\n \t\t\t\t\t\t    bias_tree, nscalars_skip);\n-\t  if (init_mask)\n-\t    init_mask = gimple_build (preheader_seq, BIT_AND_EXPR, mask_type,\n-\t\t\t\t      init_mask, unskipped_mask);\n+\t  if (init_ctrl)\n+\t    init_ctrl = gimple_build (preheader_seq, BIT_AND_EXPR, ctrl_type,\n+\t\t\t\t      init_ctrl, unskipped_mask);\n \t  else\n-\t    init_mask = unskipped_mask;\n+\t    init_ctrl = unskipped_mask;\n \t}\n \n-      if (!init_mask)\n+      if (!init_ctrl)\n \t/* First iteration is full.  */\n-\tinit_mask = build_minus_one_cst (mask_type);\n+\tinit_ctrl = build_minus_one_cst (ctrl_type);\n \n-      /* Get the mask value for the next iteration of the loop.  */\n-      next_mask = make_temp_ssa_name (mask_type, NULL, \"next_mask\");\n-      gcall *call = vect_gen_while (next_mask, test_index, this_test_limit);\n+      /* Get the control value for the next iteration of the loop.  */\n+      next_ctrl = make_temp_ssa_name (ctrl_type, NULL, \"next_mask\");\n+      gcall *call = vect_gen_while (next_ctrl, test_index, this_test_limit);\n       gsi_insert_before (test_gsi, call, GSI_SAME_STMT);\n \n-      vect_set_loop_mask (loop, mask, init_mask, next_mask);\n+      vect_set_loop_control (loop, ctrl, init_ctrl, next_ctrl);\n     }\n-  return next_mask;\n+  return next_ctrl;\n }\n \n-/* Make LOOP iterate NITERS times using masking and WHILE_ULT calls.\n-   LOOP_VINFO describes the vectorization of LOOP.  NITERS is the\n-   number of iterations of the original scalar loop that should be\n-   handled by the vector loop.  NITERS_MAYBE_ZERO and FINAL_IV are\n-   as for vect_set_loop_condition.\n+/* Set up the iteration condition and rgroup controls for LOOP, given\n+   that LOOP_VINFO_USING_PARTIAL_VECTORS_P is true for the vectorized\n+   loop.  LOOP_VINFO describes the vectorization of LOOP.  NITERS is\n+   the number of iterations of the original scalar loop that should be\n+   handled by the vector loop.  NITERS_MAYBE_ZERO and FINAL_IV are as\n+   for vect_set_loop_condition.\n \n    Insert the branch-back condition before LOOP_COND_GSI and return the\n    final gcond.  */\n@@ -679,42 +680,42 @@ vect_set_loop_condition_masked (class loop *loop, loop_vec_info loop_vinfo,\n \n   widest_int iv_limit = vect_iv_limit_for_full_masking (loop_vinfo);\n \n-  /* Iterate over all the rgroups and fill in their masks.  We could use\n-     the first mask from any rgroup for the loop condition; here we\n+  /* Iterate over all the rgroups and fill in their controls.  We could use\n+     the first control from any rgroup for the loop condition; here we\n      arbitrarily pick the last.  */\n-  tree test_mask = NULL_TREE;\n-  rgroup_masks *rgm;\n+  tree test_ctrl = NULL_TREE;\n+  rgroup_controls *rgc;\n   unsigned int i;\n   vec_loop_masks *masks = &LOOP_VINFO_MASKS (loop_vinfo);\n-  FOR_EACH_VEC_ELT (*masks, i, rgm)\n-    if (!rgm->masks.is_empty ())\n+  FOR_EACH_VEC_ELT (*masks, i, rgc)\n+    if (!rgc->controls.is_empty ())\n       {\n \t/* First try using permutes.  This adds a single vector\n \t   instruction to the loop for each mask, but needs no extra\n \t   loop invariants or IVs.  */\n \tunsigned int nmasks = i + 1;\n \tif ((nmasks & 1) == 0)\n \t  {\n-\t    rgroup_masks *half_rgm = &(*masks)[nmasks / 2 - 1];\n-\t    if (!half_rgm->masks.is_empty ()\n-\t\t&& vect_maybe_permute_loop_masks (&header_seq, rgm, half_rgm))\n+\t    rgroup_controls *half_rgc = &(*masks)[nmasks / 2 - 1];\n+\t    if (!half_rgc->controls.is_empty ()\n+\t\t&& vect_maybe_permute_loop_masks (&header_seq, rgc, half_rgc))\n \t      continue;\n \t  }\n \n \t/* See whether zero-based IV would ever generate all-false masks\n \t   before wrapping around.  */\n \tbool might_wrap_p\n \t  = (iv_limit == -1\n-\t     || (wi::min_precision (iv_limit * rgm->max_nscalars_per_iter,\n+\t     || (wi::min_precision (iv_limit * rgc->max_nscalars_per_iter,\n \t\t\t\t    UNSIGNED)\n \t\t > compare_precision));\n \n-\t/* Set up all masks for this group.  */\n-\ttest_mask = vect_set_loop_masks_directly (loop, loop_vinfo,\n-\t\t\t\t\t\t  &preheader_seq,\n-\t\t\t\t\t\t  loop_cond_gsi, rgm,\n-\t\t\t\t\t\t  niters, niters_skip,\n-\t\t\t\t\t\t  might_wrap_p);\n+\t/* Set up all controls for this group.  */\n+\ttest_ctrl = vect_set_loop_controls_directly (loop, loop_vinfo,\n+\t\t\t\t\t\t     &preheader_seq,\n+\t\t\t\t\t\t     loop_cond_gsi, rgc,\n+\t\t\t\t\t\t     niters, niters_skip,\n+\t\t\t\t\t\t     might_wrap_p);\n       }\n \n   /* Emit all accumulated statements.  */\n@@ -724,8 +725,8 @@ vect_set_loop_condition_masked (class loop *loop, loop_vec_info loop_vinfo,\n   /* Get a boolean result that tells us whether to iterate.  */\n   edge exit_edge = single_exit (loop);\n   tree_code code = (exit_edge->flags & EDGE_TRUE_VALUE) ? EQ_EXPR : NE_EXPR;\n-  tree zero_mask = build_zero_cst (TREE_TYPE (test_mask));\n-  gcond *cond_stmt = gimple_build_cond (code, test_mask, zero_mask,\n+  tree zero_ctrl = build_zero_cst (TREE_TYPE (test_ctrl));\n+  gcond *cond_stmt = gimple_build_cond (code, test_ctrl, zero_ctrl,\n \t\t\t\t\tNULL_TREE, NULL_TREE);\n   gsi_insert_before (&loop_cond_gsi, cond_stmt, GSI_SAME_STMT);\n "}, {"sha": "f4d47e05bd4f9618a5a55816c01c9f2d7906b761", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37478789dc446a28ffc642ee121e8c3959e5fe47/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37478789dc446a28ffc642ee121e8c3959e5fe47/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=37478789dc446a28ffc642ee121e8c3959e5fe47", "patch": "@@ -878,16 +878,16 @@ _loop_vec_info::_loop_vec_info (class loop *loop_in, vec_info_shared *shared)\n   epilogue_vinfos.create (6);\n }\n \n-/* Free all levels of MASKS.  */\n+/* Free all levels of rgroup CONTROLS.  */\n \n void\n-release_vec_loop_masks (vec_loop_masks *masks)\n+release_vec_loop_controls (vec<rgroup_controls> *controls)\n {\n-  rgroup_masks *rgm;\n+  rgroup_controls *rgc;\n   unsigned int i;\n-  FOR_EACH_VEC_ELT (*masks, i, rgm)\n-    rgm->masks.release ();\n-  masks->release ();\n+  FOR_EACH_VEC_ELT (*controls, i, rgc)\n+    rgc->controls.release ();\n+  controls->release ();\n }\n \n /* Free all memory used by the _loop_vec_info, as well as all the\n@@ -897,7 +897,7 @@ _loop_vec_info::~_loop_vec_info ()\n {\n   free (bbs);\n \n-  release_vec_loop_masks (&masks);\n+  release_vec_loop_controls (&masks);\n   delete ivexpr_map;\n   delete scan_map;\n   epilogue_vinfos.release ();\n@@ -938,12 +938,12 @@ cse_and_gimplify_to_preheader (loop_vec_info loop_vinfo, tree expr)\n static bool\n can_produce_all_loop_masks_p (loop_vec_info loop_vinfo, tree cmp_type)\n {\n-  rgroup_masks *rgm;\n+  rgroup_controls *rgm;\n   unsigned int i;\n   FOR_EACH_VEC_ELT (LOOP_VINFO_MASKS (loop_vinfo), i, rgm)\n-    if (rgm->mask_type != NULL_TREE\n+    if (rgm->type != NULL_TREE\n \t&& !direct_internal_fn_supported_p (IFN_WHILE_ULT,\n-\t\t\t\t\t    cmp_type, rgm->mask_type,\n+\t\t\t\t\t    cmp_type, rgm->type,\n \t\t\t\t\t    OPTIMIZE_FOR_SPEED))\n       return false;\n   return true;\n@@ -957,7 +957,7 @@ vect_get_max_nscalars_per_iter (loop_vec_info loop_vinfo)\n {\n   unsigned int res = 1;\n   unsigned int i;\n-  rgroup_masks *rgm;\n+  rgroup_controls *rgm;\n   FOR_EACH_VEC_ELT (LOOP_VINFO_MASKS (loop_vinfo), i, rgm)\n     res = MAX (res, rgm->max_nscalars_per_iter);\n   return res;\n@@ -2379,7 +2379,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n   LOOP_VINFO_TARGET_COST_DATA (loop_vinfo)\n     = init_cost (LOOP_VINFO_LOOP (loop_vinfo));\n   /* Reset accumulated rgroup information.  */\n-  release_vec_loop_masks (&LOOP_VINFO_MASKS (loop_vinfo));\n+  release_vec_loop_controls (&LOOP_VINFO_MASKS (loop_vinfo));\n   /* Reset assorted flags.  */\n   LOOP_VINFO_PEELING_FOR_NITER (loop_vinfo) = false;\n   LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo) = false;\n@@ -3512,10 +3512,10 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n \n       /* Calculate how many masks we need to generate.  */\n       unsigned int num_masks = 0;\n-      rgroup_masks *rgm;\n+      rgroup_controls *rgm;\n       unsigned int num_vectors_m1;\n       FOR_EACH_VEC_ELT (LOOP_VINFO_MASKS (loop_vinfo), num_vectors_m1, rgm)\n-\tif (rgm->mask_type)\n+\tif (rgm->type)\n \t  num_masks += num_vectors_m1 + 1;\n       gcc_assert (num_masks > 0);\n \n@@ -8153,7 +8153,7 @@ vect_record_loop_mask (loop_vec_info loop_vinfo, vec_loop_masks *masks,\n   gcc_assert (nvectors != 0);\n   if (masks->length () < nvectors)\n     masks->safe_grow_cleared (nvectors);\n-  rgroup_masks *rgm = &(*masks)[nvectors - 1];\n+  rgroup_controls *rgm = &(*masks)[nvectors - 1];\n   /* The number of scalars per iteration and the number of vectors are\n      both compile-time constants.  */\n   unsigned int nscalars_per_iter\n@@ -8169,7 +8169,7 @@ vect_record_loop_mask (loop_vec_info loop_vinfo, vec_loop_masks *masks,\n   if (rgm->max_nscalars_per_iter < nscalars_per_iter)\n     {\n       rgm->max_nscalars_per_iter = nscalars_per_iter;\n-      rgm->mask_type = truth_type_for (vectype);\n+      rgm->type = truth_type_for (vectype);\n     }\n }\n \n@@ -8184,24 +8184,24 @@ tree\n vect_get_loop_mask (gimple_stmt_iterator *gsi, vec_loop_masks *masks,\n \t\t    unsigned int nvectors, tree vectype, unsigned int index)\n {\n-  rgroup_masks *rgm = &(*masks)[nvectors - 1];\n-  tree mask_type = rgm->mask_type;\n+  rgroup_controls *rgm = &(*masks)[nvectors - 1];\n+  tree mask_type = rgm->type;\n \n   /* Populate the rgroup's mask array, if this is the first time we've\n      used it.  */\n-  if (rgm->masks.is_empty ())\n+  if (rgm->controls.is_empty ())\n     {\n-      rgm->masks.safe_grow_cleared (nvectors);\n+      rgm->controls.safe_grow_cleared (nvectors);\n       for (unsigned int i = 0; i < nvectors; ++i)\n \t{\n \t  tree mask = make_temp_ssa_name (mask_type, NULL, \"loop_mask\");\n \t  /* Provide a dummy definition until the real one is available.  */\n \t  SSA_NAME_DEF_STMT (mask) = gimple_build_nop ();\n-\t  rgm->masks[i] = mask;\n+\t  rgm->controls[i] = mask;\n \t}\n     }\n \n-  tree mask = rgm->masks[index];\n+  tree mask = rgm->controls[index];\n   if (maybe_ne (TYPE_VECTOR_SUBPARTS (mask_type),\n \t\tTYPE_VECTOR_SUBPARTS (vectype)))\n     {"}, {"sha": "828a54104a6ba13f8b7092bea599c26f11269aec", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37478789dc446a28ffc642ee121e8c3959e5fe47/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37478789dc446a28ffc642ee121e8c3959e5fe47/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=37478789dc446a28ffc642ee121e8c3959e5fe47", "patch": "@@ -390,7 +390,6 @@ is_a_helper <_bb_vec_info *>::test (vec_info *i)\n   return i->kind == vec_info::bb;\n }\n \n-\n /* In general, we can divide the vector statements in a vectorized loop\n    into related groups (\"rgroups\") and say that for each rgroup there is\n    some nS such that the rgroup operates on nS values from one scalar\n@@ -420,19 +419,21 @@ is_a_helper <_bb_vec_info *>::test (vec_info *i)\n \n    In classical vectorization, each iteration of the vector loop would\n    handle exactly VF iterations of the original scalar loop.  However,\n-   in a fully-masked loop, a particular iteration of the vector loop\n-   might handle fewer than VF iterations of the scalar loop.  The vector\n-   lanes that correspond to iterations of the scalar loop are said to be\n-   \"active\" and the other lanes are said to be \"inactive\".\n-\n-   In a fully-masked loop, many rgroups need to be masked to ensure that\n-   they have no effect for the inactive lanes.  Each such rgroup needs a\n-   sequence of booleans in the same order as above, but with each (i,j)\n-   replaced by a boolean that indicates whether iteration i is active.\n-   This sequence occupies nV vector masks that again have nL lanes each.\n-   Thus the mask sequence as a whole consists of VF independent booleans\n-   that are each repeated nS times.\n-\n+   in vector loops that are able to operate on partial vectors, a\n+   particular iteration of the vector loop might handle fewer than VF\n+   iterations of the scalar loop.  The vector lanes that correspond to\n+   iterations of the scalar loop are said to be \"active\" and the other\n+   lanes are said to be \"inactive\".\n+\n+   In such vector loops, many rgroups need to be controlled to ensure\n+   that they have no effect for the inactive lanes.  Conceptually, each\n+   such rgroup needs a sequence of booleans in the same order as above,\n+   but with each (i,j) replaced by a boolean that indicates whether\n+   iteration i is active.  This sequence occupies nV vector controls\n+   that again have nL lanes each.  Thus the control sequence as a whole\n+   consists of VF independent booleans that are each repeated nS times.\n+\n+   Taking mask-based approach as a partially-populated vectors example.\n    We make the simplifying assumption that if a sequence of nV masks is\n    suitable for one (nS,nL) pair, we can reuse it for (nS/2,nL/2) by\n    VIEW_CONVERTing it.  This holds for all current targets that support\n@@ -472,20 +473,21 @@ is_a_helper <_bb_vec_info *>::test (vec_info *i)\n    first level being indexed by nV - 1 (since nV == 0 doesn't exist) and\n    the second being indexed by the mask index 0 <= i < nV.  */\n \n-/* The masks needed by rgroups with nV vectors, according to the\n-   description above.  */\n-struct rgroup_masks {\n-  /* The largest nS for all rgroups that use these masks.  */\n+/* The controls (like masks) needed by rgroups with nV vectors,\n+   according to the description above.  */\n+struct rgroup_controls {\n+  /* The largest nS for all rgroups that use these controls.  */\n   unsigned int max_nscalars_per_iter;\n \n-  /* The type of mask to use, based on the highest nS recorded above.  */\n-  tree mask_type;\n+  /* The type of control to use, based on the highest nS recorded above.\n+     For mask-based approach, it's used for mask_type.  */\n+  tree type;\n \n-  /* A vector of nV masks, in iteration order.  */\n-  vec<tree> masks;\n+  /* A vector of nV controls, in iteration order.  */\n+  vec<tree> controls;\n };\n \n-typedef auto_vec<rgroup_masks> vec_loop_masks;\n+typedef auto_vec<rgroup_controls> vec_loop_masks;\n \n typedef auto_vec<std::pair<data_reference*, tree> > drs_init_vec;\n "}]}