{"sha": "8b11a64cd99d948ac278cc508d1866c6d28df85e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGIxMWE2NGNkOTlkOTQ4YWMyNzhjYzUwOGQxODY2YzZkMjhkZjg1ZQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2004-09-05T09:25:37Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2004-09-05T09:25:37Z"}, "message": "tree-ssa-loop-ivopts.c: New file.\n\n\t* tree-ssa-loop-ivopts.c: New file.\n\t* Makefile.in (tree-ssa-loop-ivopts.c): Add.\n\t* cfgloop.h (target_avail_regs, target_res_regs, target_small_cost,\n\ttarget_pres_cost, target_spill_cost): Declare.\n\t* cfgloopanal.c (avail_regs, res_regs, small_cost, pres_cost,\n\tspill_cost): Renamed to ...\n\t(target_avail_regs, target_res_regs, target_small_cost,\n\ttarget_pres_cost, target_spill_cost): ... and exported.\n\t(init_set_costs, global_cost_for_size): Work with renamed variables.\n\t* common.opt (flag_ivopts): New flag.\n\t* expr.c (expand_expr_real_1): Handle SSA_NAME case.  Handle\n\tREF_ORIGINAL.\n\t* gimplify.c (struct gimplify_ctx): Add into_ssa field.\n\t(internal_get_tmp_var, gimplify_modify_expr, gimplify_expr): Support\n\tgenerating SSA form.\n\t(force_gimple_operand): New function.\n\t* timevar.def (TV_TREE_LOOP_IVOPTS): New timevar.\n\t* tree-cfg.c (stmt_bsi): New function.\n\t* params.def (PARAM_IV_CONSIDER_ALL_CANDIDATES_BOUND,\n\tPARAM_IV_MAX_CONSIDERED_USES): New.\n\t* tree-flow.h (stmt_bsi, tree_ssa_iv_optimize, split_loop_exit_edge,\n\tbsi_insert_on_edge_immediate_loop. standard_iv_increment_position,\n\tip_end_pos, ip_normal_pos, force_gimple_operand): Declare.\n\t* tree-gimple.c (is_gimple_formal_tmp_var): Accept ssa names.\n\t* tree-nested.c (build_addr): Export.\n\t* tree-optimize.c (init_tree_optimization_passes): Add\n\tpass_iv_optimize.\n\t* tree-pass.h (pass_iv_optimize): Declare.\n\t* tree-ssa-loop-im.c (for_each_index): Handle REALPART_EXPR and\n\tIMAGPART_EXPR.\n\t* tree-ssa-loop-manip.c (create_iv): Force the base to be acceptable\n\tas a phi node argument.\n\t(split_loop_exit_edge, bsi_insert_on_edge_immediate_loop,\n\tip_end_pos, ip_normal_pos, standard_iv_increment_position): New\n\tfunctions.\n\t* tree-ssa-loop-niter.c (zero_p, unsigned_type_for): Export.\n\t* tree-ssa-loop.c (tree_ssa_loop_ivopts, gate_tree_ssa_loop_ivopts,\n\tpass_iv_optimize): New pass.\n\t* tree-ssa-operands.c (get_indirect_ref_operands): Handle REF_ORIGINAL.\n\t* tree-ssanames.c (release_ssa_name): Allow calling with var = NULL.\n\t* tree.c (build_int_cst_type, cst_and_fits_in_hwi): New functions.\n\t* tree.h (REF_ORIGINAL): New macro.\n\t(build_int_cst_type, unsigned_type_for, zero_p,\n\tcst_and_fits_in_hwi, build_addr): Declare.\n\t* doc/invoke.texi (-fivopts): Document.\n\t(PARAM_IV_CONSIDER_ALL_CANDIDATES_BOUND,\n\tPARAM_IV_MAX_CONSIDERED_USES): Document.\n\t* doc/passes.texi: Document induction variable optimizations pass.\n\n\t* gcc.dg/tree-ssa/loop-2.c: New test.\n\t* gcc.dg/tree-ssa/loop-3.c: New test.\n\t* gcc.dg/tree-ssa/loop-4.c: New test.\n\t* gcc.dg/tree-ssa/loop-5.c: New test.\n\nFrom-SVN: r87100", "tree": {"sha": "5fe97f05e5fc6b7356f52252207207aa904b781f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5fe97f05e5fc6b7356f52252207207aa904b781f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b11a64cd99d948ac278cc508d1866c6d28df85e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b11a64cd99d948ac278cc508d1866c6d28df85e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b11a64cd99d948ac278cc508d1866c6d28df85e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b11a64cd99d948ac278cc508d1866c6d28df85e/comments", "author": null, "committer": null, "parents": [{"sha": "56fa138bafabce659967883250b202d23d697c00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56fa138bafabce659967883250b202d23d697c00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56fa138bafabce659967883250b202d23d697c00"}], "stats": {"total": 5027, "additions": 5000, "deletions": 27}, "files": [{"sha": "83979db9881b612229131c3d8a155704664b8ce7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8b11a64cd99d948ac278cc508d1866c6d28df85e", "patch": "@@ -1,3 +1,54 @@\n+2004-09-05  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* tree-ssa-loop-ivopts.c: New file.\n+\t* Makefile.in (tree-ssa-loop-ivopts.c): Add.\n+\t* cfgloop.h (target_avail_regs, target_res_regs, target_small_cost,\n+\ttarget_pres_cost, target_spill_cost): Declare.\n+\t* cfgloopanal.c (avail_regs, res_regs, small_cost, pres_cost,\n+\tspill_cost): Renamed to ...\n+\t(target_avail_regs, target_res_regs, target_small_cost,\n+\ttarget_pres_cost, target_spill_cost): ... and exported.\n+\t(init_set_costs, global_cost_for_size): Work with renamed variables.\n+\t* common.opt (flag_ivopts): New flag.\n+\t* expr.c (expand_expr_real_1): Handle SSA_NAME case.  Handle\n+\tREF_ORIGINAL.\n+\t* gimplify.c (struct gimplify_ctx): Add into_ssa field.\n+\t(internal_get_tmp_var, gimplify_modify_expr, gimplify_expr): Support\n+\tgenerating SSA form.\n+\t(force_gimple_operand): New function.\n+\t* timevar.def (TV_TREE_LOOP_IVOPTS): New timevar.\n+\t* tree-cfg.c (stmt_bsi): New function.\n+\t* params.def (PARAM_IV_CONSIDER_ALL_CANDIDATES_BOUND,\n+\tPARAM_IV_MAX_CONSIDERED_USES): New.\n+\t* tree-flow.h (stmt_bsi, tree_ssa_iv_optimize, split_loop_exit_edge,\n+\tbsi_insert_on_edge_immediate_loop. standard_iv_increment_position,\n+\tip_end_pos, ip_normal_pos, force_gimple_operand): Declare.\n+\t* tree-gimple.c (is_gimple_formal_tmp_var): Accept ssa names.\n+\t* tree-nested.c (build_addr): Export.\n+\t* tree-optimize.c (init_tree_optimization_passes): Add\n+\tpass_iv_optimize.\n+\t* tree-pass.h (pass_iv_optimize): Declare.\n+\t* tree-ssa-loop-im.c (for_each_index): Handle REALPART_EXPR and\n+\tIMAGPART_EXPR.\n+\t* tree-ssa-loop-manip.c (create_iv): Force the base to be acceptable\n+\tas a phi node argument.\n+\t(split_loop_exit_edge, bsi_insert_on_edge_immediate_loop,\n+\tip_end_pos, ip_normal_pos, standard_iv_increment_position): New\n+\tfunctions.\n+\t* tree-ssa-loop-niter.c (zero_p, unsigned_type_for): Export.\n+\t* tree-ssa-loop.c (tree_ssa_loop_ivopts, gate_tree_ssa_loop_ivopts,\n+\tpass_iv_optimize): New pass.\n+\t* tree-ssa-operands.c (get_indirect_ref_operands): Handle REF_ORIGINAL.\n+\t* tree-ssanames.c (release_ssa_name): Allow calling with var = NULL.\n+\t* tree.c (build_int_cst_type, cst_and_fits_in_hwi): New functions.\n+\t* tree.h (REF_ORIGINAL): New macro.\n+\t(build_int_cst_type, unsigned_type_for, zero_p,\n+\tcst_and_fits_in_hwi, build_addr): Declare.\n+\t* doc/invoke.texi (-fivopts): Document.\n+\t(PARAM_IV_CONSIDER_ALL_CANDIDATES_BOUND,\n+\tPARAM_IV_MAX_CONSIDERED_USES): Document.\n+\t* doc/passes.texi: Document induction variable optimizations pass.\n+\n 2004-09-04  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* builtin-attrs.def (ATTR_NOTHROW_SENTINEL_1): New."}, {"sha": "71c11ebc43a9751f3053bf122d04f51f2c8c4776", "filename": "gcc/Makefile.in", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=8b11a64cd99d948ac278cc508d1866c6d28df85e", "patch": "@@ -899,7 +899,7 @@ OBJS-common = \\\n  tree-phinodes.o tree-ssanames.o tree-sra.o tree-complex.o tree-ssa-loop.o \\\n  tree-ssa-loop-niter.o tree-ssa-loop-manip.o tree-ssa-threadupdate.o\t   \\\n  tree-vectorizer.o tree-ssa-loop-ivcanon.o tree-ssa-propagate.o\t \t   \\\n- tree-if-conv.o\t \t                                                   \\\n+ tree-ssa-loop-ivopts.o tree-if-conv.o\t \t                           \\\n  alias.o bb-reorder.o bitmap.o builtins.o caller-save.o calls.o\t  \t   \\\n  cfg.o cfganal.o cfgbuild.o cfgcleanup.o cfglayout.o cfgloop.o\t\t   \\\n  cfgloopanal.o cfgloopmanip.o loop-init.o loop-unswitch.o loop-unroll.o\t   \\\n@@ -1721,6 +1721,11 @@ tree-ssa-loop-ch.o : tree-ssa-loop-ch.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) tree-inline.h \\\n    output.h diagnostic.h $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n    tree-pass.h flags.h\n+tree-ssa-loop-ivopts.o : tree-ssa-loop-ivopts.c $(TREE_FLOW_H) $(CONFIG_H) \\\n+   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) varray.h $(EXPR_H) \\\n+   output.h diagnostic.h $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n+   tree-pass.h $(GGC_H) $(RECOG_H) insn-config.h $(HASHTAB_H) $(SCEV_H) \\\n+   cfgloop.h $(PARAMS_H)\n tree-ssa-loop-manip.o : tree-ssa-loop-manip.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) \\\n    output.h diagnostic.h $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\"}, {"sha": "762c1ff29347dc0b9d59d0d407b789472d1bc98d", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=8b11a64cd99d948ac278cc508d1866c6d28df85e", "patch": "@@ -424,6 +424,17 @@ simple_loop_desc (struct loop *loop)\n   return loop->aux;\n }\n \n+/* The properties of the target.  */\n+\n+extern unsigned target_avail_regs;\t/* Number of available registers.  */\n+extern unsigned target_res_regs;\t/* Number of reserved registers.  */\n+extern unsigned target_small_cost;\t/* The cost for register when there\n+\t\t\t\t\t   is a free one.  */\n+extern unsigned target_pres_cost;\t/* The cost for register when there are\n+\t\t\t\t\t   not too many free ones.  */\n+extern unsigned target_spill_cost;\t/* The cost for register when we need\n+\t\t\t\t\t   to spill.  */\n+\n /* Register pressure estimation for induction variable optimizations & loop\n    invariant motion.  */\n extern unsigned global_cost_for_size (unsigned, unsigned, unsigned);"}, {"sha": "0a5179ea97623997cb47201223cfe20e97ba5a59", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=8b11a64cd99d948ac278cc508d1866c6d28df85e", "patch": "@@ -497,12 +497,12 @@ seq_cost (rtx seq)\n \n /* The properties of the target.  */\n \n-static unsigned avail_regs;\t/* Number of available registers.  */\n-static unsigned res_regs;\t/* Number of reserved registers.  */\n-static unsigned small_cost;\t/* The cost for register when there is a free one.  */\n-static unsigned pres_cost;\t/* The cost for register when there are not too many\n+unsigned target_avail_regs;\t/* Number of available registers.  */\n+unsigned target_res_regs;\t/* Number of reserved registers.  */\n+unsigned target_small_cost;\t/* The cost for register when there is a free one.  */\n+unsigned target_pres_cost;\t/* The cost for register when there are not too many\n \t\t\t\t   free ones.  */\n-static unsigned spill_cost;\t/* The cost for register when we need to spill.  */\n+unsigned target_spill_cost;\t/* The cost for register when we need to spill.  */\n \n /* Initialize the constants for computing set costs.  */\n \n@@ -519,25 +519,25 @@ init_set_costs (void)\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     if (TEST_HARD_REG_BIT (reg_class_contents[GENERAL_REGS], i)\n \t&& !fixed_regs[i])\n-      avail_regs++;\n+      target_avail_regs++;\n \n-  res_regs = 3;\n+  target_res_regs = 3;\n \n   /* These are really just heuristic values.  */\n   \n   start_sequence ();\n   emit_move_insn (reg1, reg2);\n   seq = get_insns ();\n   end_sequence ();\n-  small_cost = seq_cost (seq);\n-  pres_cost = 2 * small_cost;\n+  target_small_cost = seq_cost (seq);\n+  target_pres_cost = 2 * target_small_cost;\n \n   start_sequence ();\n   emit_move_insn (mem, reg1);\n   emit_move_insn (reg2, mem);\n   seq = get_insns ();\n   end_sequence ();\n-  spill_cost = seq_cost (seq);\n+  target_spill_cost = seq_cost (seq);\n }\n \n /* Calculates cost for having SIZE new loop global variables.  REGS_USED is the\n@@ -550,14 +550,14 @@ global_cost_for_size (unsigned size, unsigned regs_used, unsigned n_uses)\n   unsigned regs_needed = regs_used + size;\n   unsigned cost = 0;\n \n-  if (regs_needed + res_regs <= avail_regs)\n-    cost += small_cost * size;\n-  else if (regs_needed <= avail_regs)\n-    cost += pres_cost * size;\n+  if (regs_needed + target_res_regs <= target_avail_regs)\n+    cost += target_small_cost * size;\n+  else if (regs_needed <= target_avail_regs)\n+    cost += target_pres_cost * size;\n   else\n     {\n-      cost += pres_cost * size;\n-      cost += spill_cost * n_uses * (regs_needed - avail_regs) / regs_needed;\n+      cost += target_pres_cost * size;\n+      cost += target_spill_cost * n_uses * (regs_needed - target_avail_regs) / regs_needed;\n     }\n \n   return cost;"}, {"sha": "00c0ca300071dacbf4ea89cc9f985da9aab6de7c", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=8b11a64cd99d948ac278cc508d1866c6d28df85e", "patch": "@@ -472,6 +472,10 @@ finstrument-functions\n Common Report Var(flag_instrument_function_entry_exit)\n Instrument function entry and exit with profiling calls\n \n+fivopts\n+Common Report Var(flag_ivopts) Init(1)\n+Optimize induction variables on trees\n+\n fkeep-inline-functions\n Common Report Var(flag_keep_inline_functions)\n Generate code for functions even if they are fully inlined"}, {"sha": "ade9d2c27bcdda832ccc8acd4f43de10fd15d006", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=8b11a64cd99d948ac278cc508d1866c6d28df85e", "patch": "@@ -316,7 +316,7 @@ Objective-C and Objective-C++ Dialects}.\n -funroll-all-loops  -funroll-loops  -fpeel-loops @gol\n -funswitch-loops  -fold-unroll-loops  -fold-unroll-all-loops @gol\n -ftree-pre  -ftree-ccp  -ftree-dce -ftree-loop-optimize @gol\n--ftree-loop-im -ftree-loop-ivcanon @gol\n+-ftree-loop-im -ftree-loop-ivcanon -fivopts @gol\n -ftree-dominator-opts -ftree-dse -ftree-copyrename @gol\n -ftree-ch -ftree-sra -ftree-ter -ftree-lrs -ftree-fre -ftree-vectorize @gol\n --param @var{name}=@var{value}\n@@ -4503,6 +4503,10 @@ determining number of iterations requires complicated analysis.  Later\n optimizations then may determine the number easily.  Useful especially\n in connection with unrolling.\n \n+@item -fivopts\n+Perform induction variable optimizations (strength reduction, induction\n+variable merging and induction variable elimination) on trees.\n+\n @item -ftree-sra\n Perform scalar replacement of aggregates.  This pass replaces structure\n references with scalars to prevent committing structures to memory too\n@@ -5308,6 +5312,16 @@ The maximum number of branches unswitched in a single loop.\n @item lim-expensive\n The minimum cost of an expensive expression in the loop invariant motion.\n \n+@item iv-consider-all-candidates-bound\n+Bound on number of candidates for induction variables below that\n+all candidates are considered for each use in induction variable\n+optimizations.  Only the most relevant candidates are considered\n+if there are more candidates, to avoid quadratic time complexity.\n+\n+@item iv-max-considered-uses\n+The induction variable optimizations give up on loops that contain more\n+induction variable uses.\n+\n @item max-iterations-to-track\n \n The maximum number of iterations of a loop the brute force algorithm"}, {"sha": "4937d721224ebf593beafbb2b82f38b591f90662", "filename": "gcc/doc/passes.texi", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Fdoc%2Fpasses.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Fdoc%2Fpasses.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fpasses.texi?ref=8b11a64cd99d948ac278cc508d1866c6d28df85e", "patch": "@@ -381,6 +381,11 @@ loop using it, in case when a complicated analysis is necessary to determine\n the number of iterations.  Later optimizations then may determine the number\n easily.  The pass is implemented in @file{tree-ssa-loop-ivcanon.c}.\n \n+Induction variable optimizations.  This pass performs standard induction\n+variable optimizations, including strength reduction, induction variable\n+merging and induction variable elimination.  The pass is implemented in\n+@file{tree-ssa-loop-ivopts.c}.\n+\n The optimizations also use various utility functions contained in\n @file{tree-ssa-loop-manip.c}, @file{cfgloop.c}, @file{cfgloopanal.c} and\n @file{cfgloopmanip.c}."}, {"sha": "7d8c1f7f5689fc2bcc1229dd7e3f6f289c964352", "filename": "gcc/expr.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=8b11a64cd99d948ac278cc508d1866c6d28df85e", "patch": "@@ -6462,6 +6462,10 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \treturn temp;\n       }\n \n+    case SSA_NAME:\n+      return expand_expr_real_1 (SSA_NAME_VAR (exp), target, tmode, modifier,\n+\t\t\t\t NULL);\n+\n     case PARM_DECL:\n     case VAR_DECL:\n       /* If a static var's type was incomplete when the decl was written,\n@@ -6743,6 +6747,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n     case INDIRECT_REF:\n       {\n \ttree exp1 = TREE_OPERAND (exp, 0);\n+\ttree orig;\n \n \tif (modifier != EXPAND_WRITE)\n \t  {\n@@ -6756,7 +6761,11 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \top0 = expand_expr (exp1, NULL_RTX, VOIDmode, EXPAND_SUM);\n \top0 = memory_address (mode, op0);\n \ttemp = gen_rtx_MEM (mode, op0);\n-\tset_mem_attributes (temp, exp, 0);\n+\n+\torig = REF_ORIGINAL (exp);\n+\tif (!orig)\n+\t  orig = exp;\n+\tset_mem_attributes (temp, orig, 0);\n \n \treturn temp;\n       }"}, {"sha": "2358d3525f9fbbb65e8b2db9976cbc14bf902478", "filename": "gcc/gimplify.c", "status": "modified", "additions": 60, "deletions": 3, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=8b11a64cd99d948ac278cc508d1866c6d28df85e", "patch": "@@ -50,15 +50,16 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n static struct gimplify_ctx\n {\n   tree current_bind_expr;\n-  bool save_stack;\n   tree temps;\n   tree conditional_cleanups;\n-  int conditions;\n   tree exit_label;\n   tree return_temp;\n   varray_type case_labels;\n   /* The formal temporary table.  Should this be persistent?  */\n   htab_t temp_htab;\n+  int conditions;\n+  bool save_stack;\n+  bool into_ssa;\n } *gimplify_ctxp;\n \n \n@@ -477,6 +478,12 @@ internal_get_tmp_var (tree val, tree *pre_p, tree *post_p, bool is_formal)\n \n   /* gimplify_modify_expr might want to reduce this further.  */\n   gimplify_and_add (mod, pre_p);\n+\n+  /* If we're gimplifying into ssa, gimplify_modify_expr will have\n+     given our temporary an ssa name.  Find and return it.  */\n+  if (gimplify_ctxp->into_ssa)\n+    t = TREE_OPERAND (mod, 0);\n+\n   return t;\n }\n \n@@ -2875,6 +2882,15 @@ gimplify_modify_expr (tree *expr_p, tree *pre_p, tree *post_p, bool want_value)\n \t}\n     }\n \n+  if (gimplify_ctxp->into_ssa && is_gimple_reg (*to_p))\n+    {\n+      /* If we've somehow already got an SSA_NAME on the LHS, then\n+\t we're probably modifying it twice.  Not good.  */\n+      if (TREE_CODE (*to_p) == SSA_NAME)\n+\tabort ();\n+      *to_p = make_ssa_name (*to_p, *expr_p);\n+    }\n+\n   if (want_value)\n     {\n       append_to_statement_list (*expr_p, pre_p);\n@@ -4048,7 +4064,9 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t*expr_p = get_initialized_tmp_var (*expr_p, pre_p, post_p);\n       else\n \t*expr_p = get_formal_tmp_var (*expr_p, pre_p);\n-      DECL_GIMPLE_FORMAL_TEMP_P (*expr_p) = 1;\n+\n+      if (TREE_CODE (*expr_p) != SSA_NAME)\n+\tDECL_GIMPLE_FORMAL_TEMP_P (*expr_p) = 1;\n     }\n   else if (fallback & fb_mayfail)\n     {\n@@ -4327,4 +4345,43 @@ gimplify_function_tree (tree fndecl)\n   current_function_decl = oldfn;\n }\n \n+\f\n+/* Expands EXPR to list of gimple statements STMTS.  If SIMPLE is true,\n+   force the result to be either ssa_name or an invariant, otherwise\n+   just force it to be a rhs expression.  If VAR is not NULL, make the\n+   base variable of the final destination be VAR if suitable.  */\n+\n+tree\n+force_gimple_operand (tree expr, tree *stmts, bool simple, tree var)\n+{\n+  tree t;\n+  enum gimplify_status ret;\n+  gimple_predicate gimple_test_f;\n+\n+  *stmts = NULL_TREE;\n+\n+  if (is_gimple_val (expr))\n+    return expr;\n+\n+  gimple_test_f = simple ? is_gimple_val : is_gimple_reg_rhs;\n+\n+  push_gimplify_context ();\n+  gimplify_ctxp->into_ssa = true;\n+\n+  if (var)\n+    expr = build (MODIFY_EXPR, TREE_TYPE (var), var, expr);\n+\n+  ret = gimplify_expr (&expr, stmts, NULL,\n+\t\t       gimple_test_f, fb_rvalue);\n+  if (ret == GS_ERROR)\n+    abort ();\n+\n+  for (t = gimplify_ctxp->temps; t ; t = TREE_CHAIN (t))\n+    add_referenced_tmp_var (t);\n+\n+  pop_gimplify_context (NULL);\n+\n+  return expr;\n+}\n+\n #include \"gt-gimplify.h\""}, {"sha": "845b8d2c51bfe2722234aed16a862a6344e98794", "filename": "gcc/params.def", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=8b11a64cd99d948ac278cc508d1866c6d28df85e", "patch": "@@ -325,6 +325,23 @@ DEFPARAM(PARAM_LIM_EXPENSIVE,\n \t \"The minimum cost of an expensive expression in the loop invariant motion\",\n \t 20)\n \n+/* Bound on number of candidates for induction variables below that\n+   all candidates are considered for each use in induction variable\n+   optimizations.  */\n+\n+DEFPARAM(PARAM_IV_CONSIDER_ALL_CANDIDATES_BOUND,\n+\t \"iv-consider-all-candidates-bound\",\n+\t \"Bound on number of candidates below that all candidates are considered in iv optimizations\",\n+\t 30)\n+\n+/* The induction variable optimizations give up on loops that contain more\n+   induction variable uses.  */\n+\n+DEFPARAM(PARAM_IV_MAX_CONSIDERED_USES,\n+\t \"iv-max-considered-uses\",\n+\t \"Bound on number of iv uses in loop optimized in iv optimizations\",\n+\t 250)\n+\n /* The product of the next two is used to decide whether or not to\n    use .GLOBAL_VAR.  See tree-dfa.c.  */\n DEFPARAM(PARAM_GLOBAL_VAR_THRESHOLD,"}, {"sha": "a96882522a8479bb4c479c191ad71e3c3baf4713", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8b11a64cd99d948ac278cc508d1866c6d28df85e", "patch": "@@ -1,3 +1,10 @@\n+2004-09-05  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* gcc.dg/tree-ssa/loop-2.c: New test.\n+\t* gcc.dg/tree-ssa/loop-3.c: New test.\n+\t* gcc.dg/tree-ssa/loop-4.c: New test.\n+\t* gcc.dg/tree-ssa/loop-5.c: New test.\n+\n 2004-09-04  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* gcc.dg/format/sentinel-1.c: Update for parameter option."}, {"sha": "41f42215b857d2e33d816f399d873d0da08e1546", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-2.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-2.c?ref=8b11a64cd99d948ac278cc508d1866c6d28df85e", "patch": "@@ -0,0 +1,37 @@\n+/* A test for strength reduction and induction variable elimination.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fdump-tree-vars\" } */\n+\n+/* Size of this structure should be sufficiently weird so that no memory\n+   addressing mode applies.  */\n+\n+struct bla\n+{\n+  char x[187];\n+  int y;\n+  char z[253];\n+} arr_base[100];\n+\n+void xxx(void)\n+{\n+  int iter;\n+\n+  for (iter = 0; iter < 100; iter++)\n+    arr_base[iter].y = 17 * iter;\n+}\n+\n+/* Access to arr_base[iter].y should be strength reduced.  */\n+\n+/* { dg-final { scan-tree-dump-times \"arr_base.*=\" 0 \"vars\" } } */\n+\n+/* 17 * iter should be strength reduced.  */\n+\n+/* { dg-final { scan-tree-dump-times \" \\\\* 17\" 0 \"vars\" } } */\n+/* { dg-final { scan-tree-dump-times \" \\\\+ 17\" 1 \"vars\" } } */\n+\n+/* The induction variable comparison with 99 should be eliminated\n+   and replaced by comparison of the variable for 17 * iter with 1700.  */\n+\n+/* { dg-final { scan-tree-dump-times \"1700\" 1 \"vars\" } } */\n+/* { dg-final { scan-tree-dump-times \"iter\" 0 \"vars\" } } */"}, {"sha": "67846f40b113cbb53445c23e386b04614cf047dd", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-3.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-3.c?ref=8b11a64cd99d948ac278cc508d1866c6d28df85e", "patch": "@@ -0,0 +1,27 @@\n+/* A test for strength reduction and induction variable elimination.\n+   Target is restricted to x86 type architectures, so that we may\n+   assume something about memory addressing modes.  */\n+\n+/* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O1 -fdump-tree-vars\" } */\n+\n+int arr_base[100];\n+\n+int foo(int);\n+\n+void xxx(void)\n+{\n+  int iter;\n+\n+  for (iter = 0; iter < 100; iter++)\n+    arr_base[iter] = foo (iter);\n+}\n+\n+/* Access to arr_base[iter].y should not be strength reduced, since\n+   we have a memory mode including multiplication by 4.  */\n+\n+/* { dg-final { scan-tree-dump-times \"arr_base.*=\" 1 \"vars\" } } */\n+\n+/* And original induction variable should be preserved.  */\n+\n+/* { dg-final { scan-tree-dump-times \"int iter\" 1 \"vars\" } } */"}, {"sha": "2d3ca62422ee9c0133057e3dc2affa865684a069", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-4.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-4.c?ref=8b11a64cd99d948ac278cc508d1866c6d28df85e", "patch": "@@ -0,0 +1,32 @@\n+/* A test for strength reduction and induction variable elimination.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fdump-tree-vars\" } */\n+\n+/* Size of this structure should be sufficiently weird so that no memory\n+   addressing mode applies.  */\n+\n+struct bla\n+{\n+  char x[187];\n+  int y;\n+  char z[253];\n+} arr_base[100];\n+\n+int foo(void);\n+\n+void xxx(void)\n+{\n+  int iter;\n+\n+  for (iter = 0; iter < 100; iter++)\n+    arr_base[iter].y = foo ();\n+}\n+\n+/* Access to arr_base[iter].y should be strength reduced.  */\n+\n+/* { dg-final { scan-tree-dump-times \"arr_base.*=\" 0 \"vars\" } } */\n+\n+/* And the original induction variable should be eliminated.  */\n+\n+/* { dg-final { scan-tree-dump-times \"iter\" 0 \"vars\" } } */"}, {"sha": "4ec6fd04bcd92203671020afe7a0e4af7d47b781", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-5.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-5.c?ref=8b11a64cd99d948ac278cc508d1866c6d28df85e", "patch": "@@ -0,0 +1,26 @@\n+/* A test for induction variable merging.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fdump-tree-vars\" } */\n+\n+void foo(int);\n+\n+void xxx(void)\n+{\n+  int iter, jter;\n+\n+  for (iter = 0, jter = 2; iter < 100; iter++, jter++)\n+    {\n+      foo (iter);\n+      foo (jter);\n+    }\n+}\n+\n+/* Only iter variable should remain.  */\n+\n+/* { dg-final { scan-tree-dump-times \"int iter\" 1 \"vars\" } } */\n+/* { dg-final { scan-tree-dump-times \"jter\" 0 \"vars\" } } */\n+\n+/* And the use of jter should be replaced by iter + 2 */\n+\n+/* { dg-final { scan-tree-dump-times \" \\\\+ 2\" 1 \"vars\" } } */"}, {"sha": "4dbaa6af62c3d934e3b278d227ddd9eb8b8e0e41", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=8b11a64cd99d948ac278cc508d1866c6d28df85e", "patch": "@@ -86,6 +86,7 @@ DEFTIMEVAR (TV_LIM                   , \"loop invariant motion\")\n DEFTIMEVAR (TV_TREE_LOOP_IVCANON     , \"tree canonical iv creation\")\n DEFTIMEVAR (TV_COMPLETE_UNROLL       , \"complete unrolling\")\n DEFTIMEVAR (TV_TREE_VECTORIZATION    , \"tree loop vectorization\")\n+DEFTIMEVAR (TV_TREE_LOOP_IVOPTS\t     , \"tree iv optimization\")\n DEFTIMEVAR (TV_TREE_CH\t\t     , \"tree copy headers\")\n DEFTIMEVAR (TV_TREE_SSA_TO_NORMAL    , \"tree SSA to normal\")\n DEFTIMEVAR (TV_TREE_NRV\t\t     , \"tree NRV optimization\")"}, {"sha": "b08efe8f6d649d1b3e42fd4b7f606d630a39f5ea", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=8b11a64cd99d948ac278cc508d1866c6d28df85e", "patch": "@@ -2731,6 +2731,19 @@ set_bb_for_stmt (tree t, basic_block bb)\n     }\n }\n \n+/* Finds iterator for STMT.  */\n+\n+extern block_stmt_iterator\n+stmt_for_bsi (tree stmt)\n+{\n+  block_stmt_iterator bsi;\n+\n+  for (bsi = bsi_start (bb_for_stmt (stmt)); !bsi_end_p (bsi); bsi_next (&bsi))\n+    if (bsi_stmt (bsi) == stmt)\n+      return bsi;\n+\n+  abort ();\n+}\n \n /* Insert statement (or statement list) T before the statement\n    pointed-to by iterator I.  M specifies how to update iterator I"}, {"sha": "5edfae50bbb83123b14822be8d56ace9c4617370", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=8b11a64cd99d948ac278cc508d1866c6d28df85e", "patch": "@@ -414,6 +414,7 @@ typedef struct {\n static inline block_stmt_iterator bsi_start (basic_block);\n static inline block_stmt_iterator bsi_last (basic_block);\n static inline block_stmt_iterator bsi_after_labels (basic_block);\n+block_stmt_iterator stmt_for_bsi (tree);\n static inline bool bsi_end_p (block_stmt_iterator);\n static inline void bsi_next (block_stmt_iterator *);\n static inline void bsi_prev (block_stmt_iterator *);\n@@ -637,6 +638,7 @@ bool empty_block_p (basic_block);\n void tree_ssa_lim (struct loops *);\n void canonicalize_induction_variables (struct loops *);\n void tree_unroll_loops_completely (struct loops *);\n+void tree_ssa_iv_optimize (struct loops *);\n \n void number_of_iterations_cond (tree, tree, tree, enum tree_code, tree, tree,\n \t\t\t\tstruct tree_niter_desc *);\n@@ -653,6 +655,12 @@ void loop_commit_inserts (void);\n bool for_each_index (tree *, bool (*) (tree, tree *, void *), void *);\n void create_iv (tree, tree, tree, struct loop *, block_stmt_iterator *, bool,\n \t\ttree *, tree *);\n+void split_loop_exit_edge (edge);\n+basic_block bsi_insert_on_edge_immediate_loop (edge, tree);\n+void standard_iv_increment_position (struct loop *, block_stmt_iterator *,\n+\t\t\t\t     bool *);\n+basic_block ip_end_pos (struct loop *);\n+basic_block ip_normal_pos (struct loop *);\n \n /* In tree-ssa-loop-im.c  */\n /* The possibilities of statement movement.  */\n@@ -711,6 +719,10 @@ void insert_edge_copies (tree stmt, basic_block bb);\n extern void build_ssa_operands (tree, stmt_ann_t, stmt_operands_p, \n \t\t\t\tstmt_operands_p);\n \n+/* In gimplify.c  */\n+\n+tree force_gimple_operand (tree, tree *, bool, tree);\n+\n #include \"tree-flow-inline.h\"\n \n #endif /* _TREE_FLOW_H  */"}, {"sha": "9211a65f164956707c285ae2614529d2dd99381a", "filename": "gcc/tree-gimple.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Ftree-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Ftree-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.c?ref=8b11a64cd99d948ac278cc508d1866c6d28df85e", "patch": "@@ -448,6 +448,9 @@ is_gimple_reg (tree t)\n bool\n is_gimple_formal_tmp_var (tree t)\n {\n+  if (TREE_CODE (t) == SSA_NAME)\n+    return true;\n+\n   return TREE_CODE (t) == VAR_DECL && DECL_GIMPLE_FORMAL_TEMP_P (t);\n }\n "}, {"sha": "8d5017b225185657cb4247bc69721131834bdea6", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=8b11a64cd99d948ac278cc508d1866c6d28df85e", "patch": "@@ -153,7 +153,7 @@ create_tmp_var_for (struct nesting_info *info, tree type, const char *prefix)\n \n /* Take the address of EXP.  Mark it for addressability as necessary.  */\n \n-static tree\n+tree\n build_addr (tree exp)\n {\n   tree base = exp;"}, {"sha": "310d46f864cf436109cf87a9f6e770e7f6172909", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=8b11a64cd99d948ac278cc508d1866c6d28df85e", "patch": "@@ -371,6 +371,7 @@ init_tree_optimization_passes (void)\n   NEXT_PASS (pass_if_conversion);\n   NEXT_PASS (pass_vectorize);\n   NEXT_PASS (pass_complete_unroll);\n+  NEXT_PASS (pass_iv_optimize);\n   NEXT_PASS (pass_loop_done);\n   *p = NULL;\n "}, {"sha": "2f340a9c7c4aaf94b53b5c1b46363507350ea8e3", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=8b11a64cd99d948ac278cc508d1866c6d28df85e", "patch": "@@ -113,6 +113,7 @@ extern struct tree_opt_pass pass_iv_canon;\n extern struct tree_opt_pass pass_if_conversion;\n extern struct tree_opt_pass pass_vectorize;\n extern struct tree_opt_pass pass_complete_unroll;\n+extern struct tree_opt_pass pass_iv_optimize;\n extern struct tree_opt_pass pass_loop_done;\n extern struct tree_opt_pass pass_ch;\n extern struct tree_opt_pass pass_ccp;"}, {"sha": "e80d8eeededef571df14c1b1cd59b70bf4f50a1b", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=8b11a64cd99d948ac278cc508d1866c6d28df85e", "patch": "@@ -132,6 +132,8 @@ for_each_index (tree *addr_p, bool (*cbck) (tree, tree *, void *), void *data)\n \tcase COMPONENT_REF:\n \tcase VIEW_CONVERT_EXPR:\n \tcase ARRAY_RANGE_REF:\n+\tcase REALPART_EXPR:\n+\tcase IMAGPART_EXPR:\n \t  nxt = &TREE_OPERAND (*addr_p, 0);\n \t  break;\n "}, {"sha": "aee09fe545e698d28b4491305bc6870e04b3fd00", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "added", "additions": 4413, "deletions": 0, "changes": 4413, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=8b11a64cd99d948ac278cc508d1866c6d28df85e"}, {"sha": "51e29fd844bb503063b9abc6f67c335bcf613d6f", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 119, "deletions": 2, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=8b11a64cd99d948ac278cc508d1866c6d28df85e", "patch": "@@ -50,7 +50,7 @@ create_iv (tree base, tree step, tree var, struct loop *loop,\n \t   block_stmt_iterator *incr_pos, bool after,\n \t   tree *var_before, tree *var_after)\n {\n-  tree stmt, initial, step1;\n+  tree stmt, initial, step1, stmts;\n   tree vb, va;\n   enum tree_code incr_op = PLUS_EXPR;\n \n@@ -100,7 +100,13 @@ create_iv (tree base, tree step, tree var, struct loop *loop,\n   else\n     bsi_insert_before (incr_pos, stmt, BSI_NEW_STMT);\n \n-  initial = base;\n+  initial = force_gimple_operand (base, &stmts, true, var);\n+  if (stmts)\n+    {\n+      edge pe = loop_preheader_edge (loop);\n+\n+      bsi_insert_on_edge_immediate_loop (pe, stmts);\n+    }\n \n   stmt = create_phi_node (vb, loop->header);\n   SSA_NAME_DEF_STMT (vb) = stmt;\n@@ -382,3 +388,114 @@ verify_loop_closed_ssa (void)\n \tcheck_loop_closed_ssa_stmt (bb, bsi_stmt (bsi));\n     }\n }\n+\n+/* Split loop exit edge EXIT.  The things are a bit complicated by a need to\n+   preserve the loop closed ssa form.  */\n+\n+void\n+split_loop_exit_edge (edge exit)\n+{\n+  basic_block dest = exit->dest;\n+  basic_block bb = loop_split_edge_with (exit, NULL);\n+  tree phi, new_phi, new_name;\n+  use_operand_p op_p;\n+\n+  for (phi = phi_nodes (dest); phi; phi = TREE_CHAIN (phi))\n+    {\n+      op_p = PHI_ARG_DEF_PTR_FROM_EDGE (phi, bb->succ);\n+\n+      new_name = duplicate_ssa_name (USE_FROM_PTR (op_p), NULL);\n+      new_phi = create_phi_node (new_name, bb);\n+      SSA_NAME_DEF_STMT (new_name) = new_phi;\n+      add_phi_arg (&new_phi, USE_FROM_PTR (op_p), exit);\n+      SET_USE (op_p, new_name);\n+    }\n+}\n+\n+/* Insert statement STMT to the edge E and update the loop structures.\n+   Returns the newly created block (if any).  */\n+\n+basic_block\n+bsi_insert_on_edge_immediate_loop (edge e, tree stmt)\n+{\n+  basic_block src, dest, new_bb;\n+  struct loop *loop_c;\n+\n+  src = e->src;\n+  dest = e->dest;\n+\n+  loop_c = find_common_loop (src->loop_father, dest->loop_father);\n+\n+  new_bb = bsi_insert_on_edge_immediate (e, stmt);\n+\n+  if (!new_bb)\n+    return NULL;\n+\n+  add_bb_to_loop (new_bb, loop_c);\n+  if (dest->loop_father->latch == src)\n+    dest->loop_father->latch = new_bb;\n+\n+  return new_bb;\n+}\n+\n+/* Returns the basic block in that statements should be emitted for induction\n+   variables incremented at the end of the LOOP.  */\n+\n+basic_block\n+ip_end_pos (struct loop *loop)\n+{\n+  return loop->latch;\n+}\n+\n+/* Returns the basic block in that statements should be emitted for induction\n+   variables incremented just before exit condition of a LOOP.  */\n+\n+basic_block\n+ip_normal_pos (struct loop *loop)\n+{\n+  tree last;\n+  basic_block bb;\n+  edge exit;\n+\n+  if (loop->latch->pred->pred_next)\n+    return NULL;\n+\n+  bb = loop->latch->pred->src;\n+  last = last_stmt (bb);\n+  if (TREE_CODE (last) != COND_EXPR)\n+    return NULL;\n+\n+  exit = bb->succ;\n+  if (exit->dest == loop->latch)\n+    exit = exit->succ_next;\n+\n+  if (flow_bb_inside_loop_p (loop, exit->dest))\n+    return NULL;\n+\n+  return bb;\n+}\n+\n+/* Stores the standard position for induction variable increment in LOOP\n+   (just before the exit condition if it is available and latch block is empty,\n+   end of the latch block otherwise) to BSI.  INSERT_AFTER is set to true if\n+   the increment should be inserted after *BSI.  */\n+\n+void\n+standard_iv_increment_position (struct loop *loop, block_stmt_iterator *bsi,\n+\t\t\t\tbool *insert_after)\n+{\n+  basic_block bb = ip_normal_pos (loop), latch = ip_end_pos (loop);\n+  tree last = last_stmt (latch);\n+\n+  if (!bb\n+      || (last && TREE_CODE (last) != LABEL_EXPR))\n+    {\n+      *bsi = bsi_last (latch);\n+      *insert_after = true;\n+    }\n+  else\n+    {\n+      *bsi = bsi_last (bb);\n+      *insert_after = false;\n+    }\n+}"}, {"sha": "7135ceee226a7f94931e591b24cb5f7365eefedd", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=8b11a64cd99d948ac278cc508d1866c6d28df85e", "patch": "@@ -54,7 +54,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n /* Returns true if ARG is either NULL_TREE or constant zero.  */\n \n-static bool\n+bool\n zero_p (tree arg)\n {\n   if (!arg)\n@@ -86,7 +86,7 @@ inverse (tree x, tree mask)\n \n /* Returns unsigned variant of TYPE.  */\n \n-static tree\n+tree\n unsigned_type_for (tree type)\n {\n   return make_unsigned_type (TYPE_PRECISION (type));"}, {"sha": "55cce5548e6e1a4baf236618ef71eb3c994813a0", "filename": "gcc/tree-ssa-loop.c", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Ftree-ssa-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Ftree-ssa-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.c?ref=8b11a64cd99d948ac278cc508d1866c6d28df85e", "patch": "@@ -256,6 +256,39 @@ struct tree_opt_pass pass_complete_unroll =\n   TODO_dump_func                \t/* todo_flags_finish */\n };\n \n+/* Induction variable optimizations.  */\n+\n+static void\n+tree_ssa_loop_ivopts (void)\n+{\n+  if (!current_loops)\n+    return;\n+\n+  tree_ssa_iv_optimize (current_loops);\n+}\n+\n+static bool\n+gate_tree_ssa_loop_ivopts (void)\n+{\n+  return flag_ivopts != 0;\n+}\n+\n+struct tree_opt_pass pass_iv_optimize =\n+{\n+  \"ivopts\",\t\t\t\t/* name */\n+  gate_tree_ssa_loop_ivopts,\t\t/* gate */\n+  tree_ssa_loop_ivopts,\t\t       \t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_TREE_LOOP_IVOPTS,\t  \t\t/* tv_id */\n+  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_dump_func                \t/* todo_flags_finish */\n+};\n+\n /* Loop optimizer finalization.  */\n \n static void"}, {"sha": "85b777fd9dcb5cd1d75d84235ae30731dd94f87e", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=8b11a64cd99d948ac278cc508d1866c6d28df85e", "patch": "@@ -1295,6 +1295,18 @@ get_indirect_ref_operands (tree stmt, tree expr, int flags)\n   /* Stores into INDIRECT_REF operands are never killing definitions.  */\n   flags &= ~opf_kill_def;\n \n+  if (REF_ORIGINAL (expr))\n+    {\n+      enum tree_code ocode = TREE_CODE (REF_ORIGINAL (expr));\n+\n+      /* If we originally accessed part of a structure, we do it still.  */\n+      if (ocode == ARRAY_REF\n+\t  || ocode == COMPONENT_REF\n+\t  || ocode == REALPART_EXPR\n+\t  || ocode == IMAGPART_EXPR)\n+\tflags &= ~opf_kill_def;\n+    }\n+\n   if (SSA_VAR_P (ptr))\n     {\n       struct ptr_info_def *pi = NULL;"}, {"sha": "12664bbf09cb5b0e2ba3bcd73fa5c2536cd75bb9", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=8b11a64cd99d948ac278cc508d1866c6d28df85e", "patch": "@@ -241,6 +241,9 @@ make_ssa_name (tree var, tree stmt)\n void\n release_ssa_name (tree var)\n {\n+  if (!var)\n+    return;\n+\n   /* Never release the default definition for a symbol.  It's a\n      special SSA name that should always exist once it's created.  */\n   if (var == var_ann (SSA_NAME_VAR (var))->default_def)"}, {"sha": "157d7f2d15a004f35fdfb8472caa92dab4150ddb", "filename": "gcc/tree.c", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=8b11a64cd99d948ac278cc508d1866c6d28df85e", "patch": "@@ -444,6 +444,41 @@ build_int_cstu (tree type, unsigned HOST_WIDE_INT low)\n   return build_int_cst_wide (type, low, 0);\n }\n \n+/* Create an INT_CST node with a LOW value zero or sign extended depending\n+   on the type.  */\n+\n+tree\n+build_int_cst_type (tree type, HOST_WIDE_INT low)\n+{\n+  unsigned HOST_WIDE_INT val = (unsigned HOST_WIDE_INT) low;\n+  unsigned bits;\n+  bool signed_p;\n+  bool negative;\n+  tree ret;\n+\n+  if (!type)\n+    type = integer_type_node;\n+\n+  bits = TYPE_PRECISION (type);\n+  signed_p = !TYPE_UNSIGNED (type);\n+  negative = ((val >> (bits - 1)) & 1) != 0;\n+\n+  if (signed_p && negative)\n+    {\n+      if (bits < HOST_BITS_PER_WIDE_INT)\n+\tval = val | ((~(unsigned HOST_WIDE_INT) 0) << bits);\n+      ret = build_int_cst_wide (type, val, ~(unsigned HOST_WIDE_INT) 0);\n+    }\n+  else\n+    {\n+      if (bits < HOST_BITS_PER_WIDE_INT)\n+\tval = val & ~((~(unsigned HOST_WIDE_INT) 0) << bits);\n+      ret = build_int_cst_wide (type, val, 0);\n+    }\n+\n+  return ret;\n+}\n+\n /* Create an INT_CST node of TYPE and value HI:LOW.  If TYPE is NULL,\n    integer_type_node is used.  */\n \n@@ -532,6 +567,22 @@ build_int_cst_wide (tree type, unsigned HOST_WIDE_INT low, HOST_WIDE_INT hi)\n   return t;\n }\n \n+/* Checks that X is integer constant that can be expressed in (unsigned)\n+   HOST_WIDE_INT without loss of precision.  */\n+\n+bool\n+cst_and_fits_in_hwi (tree x)\n+{\n+  if (TREE_CODE (x) != INTEGER_CST)\n+    return false;\n+\n+  if (TYPE_PRECISION (TREE_TYPE (x)) > HOST_BITS_PER_WIDE_INT)\n+    return false;\n+\n+  return (TREE_INT_CST_HIGH (x) == 0\n+\t  || TREE_INT_CST_HIGH (x) == -1);\n+}\n+\n /* Return a new VECTOR_CST node whose type is TYPE and whose values\n    are in a list pointed by VALS.  */\n "}, {"sha": "4d5830c62dae3f3d4c048192a8ddba18726b30ec", "filename": "gcc/tree.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b11a64cd99d948ac278cc508d1866c6d28df85e/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=8b11a64cd99d948ac278cc508d1866c6d28df85e", "patch": "@@ -1069,6 +1069,9 @@ struct tree_vec GTY(())\n #define TREE_OPERAND(NODE, I) TREE_OPERAND_CHECK (NODE, I)\n #define TREE_COMPLEXITY(NODE) (EXPR_CHECK (NODE)->exp.complexity)\n \n+/* In INDIRECT_REF.  */\n+#define REF_ORIGINAL(NODE) TREE_CHAIN (TREE_CHECK (NODE, INDIRECT_REF))\n+\n /* In a LABELED_BLOCK_EXPR node.  */\n #define LABELED_BLOCK_LABEL(NODE) \\\n   TREE_OPERAND_CHECK_CODE (NODE, LABELED_BLOCK_EXPR, 0)\n@@ -2747,6 +2750,7 @@ extern tree build4_stat (enum tree_code, tree, tree, tree, tree,\n #define build4(c,t1,t2,t3,t4,t5) build4_stat (c,t1,t2,t3,t4,t5 MEM_STAT_INFO)\n \n extern tree build_int_cst (tree, HOST_WIDE_INT);\n+extern tree build_int_cst_type (tree, HOST_WIDE_INT);\n extern tree build_int_cstu (tree, unsigned HOST_WIDE_INT);\n extern tree build_int_cst_wide (tree, unsigned HOST_WIDE_INT, HOST_WIDE_INT);\n extern tree build_vector (tree, tree);\n@@ -2769,6 +2773,7 @@ extern tree build_empty_stmt (void);\n \n extern tree make_signed_type (int);\n extern tree make_unsigned_type (int);\n+extern tree unsigned_type_for (tree);\n extern void initialize_sizetypes (bool);\n extern void set_sizetype (tree);\n extern void fixup_unsigned_type (tree);\n@@ -3174,6 +3179,9 @@ extern int integer_pow2p (tree);\n \n extern int integer_nonzerop (tree);\n \n+extern bool zero_p (tree);\n+extern bool cst_and_fits_in_hwi (tree);\n+\n /* staticp (tree x) is nonzero if X is a reference to data allocated\n    at a fixed address in memory.  Returns the outermost data.  */\n \n@@ -3498,6 +3506,7 @@ extern tree build_nonstandard_integer_type (unsigned HOST_WIDE_INT, int);\n extern tree build_range_type (tree, tree, tree);\n extern HOST_WIDE_INT int_cst_value (tree);\n extern tree tree_fold_gcd (tree, tree);\n+extern tree build_addr (tree);\n \n extern bool fields_compatible_p (tree, tree);\n extern tree find_compatible_field (tree, tree);"}]}