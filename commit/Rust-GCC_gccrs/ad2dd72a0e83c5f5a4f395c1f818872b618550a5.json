{"sha": "ad2dd72a0e83c5f5a4f395c1f818872b618550a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWQyZGQ3MmEwZTgzYzVmNWE0ZjM5NWMxZjgxODg3MmI2MTg1NTBhNQ==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2008-08-12T06:31:57Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2008-08-12T06:31:57Z"}, "message": "tree-vectorizer.c: Depend on langhooks.h.\n\n\t* tree-vectorizer.c: Depend on langhooks.h.\n\t(supportable_widening_operation): Add two arguments. Support double\n\ttype conversions.\n\t(supportable_narrowing_operation): Likewise.\n\t* tree-vectorizer.h (supportable_widening_operation): Add two\n\targuments.\n\t(supportable_narrowing_operation): Likewise.\n\t* tree-vect-patterns.c (vect_recog_widen_mult_pattern) : Call\n\tsupportable_widening_operation with correct arguments.\n\t* tree-vect-transform.c (vectorizable_conversion): Likewise.\n\t(vectorizable_type_demotion): Support double type conversions.\n\t(vectorizable_type_promotion): Likewise.\n\t* Makefile.in (tree-vectorizer.o): Depend on langhooks.h.\n\nFrom-SVN: r138988", "tree": {"sha": "d08aa3cd7532e377a8e591040da5b32f9ae3e84b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d08aa3cd7532e377a8e591040da5b32f9ae3e84b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad2dd72a0e83c5f5a4f395c1f818872b618550a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad2dd72a0e83c5f5a4f395c1f818872b618550a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad2dd72a0e83c5f5a4f395c1f818872b618550a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad2dd72a0e83c5f5a4f395c1f818872b618550a5/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "62641193ee06686bb2cb4d65708cc2d9b0795870", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62641193ee06686bb2cb4d65708cc2d9b0795870", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62641193ee06686bb2cb4d65708cc2d9b0795870"}], "stats": {"total": 564, "additions": 510, "deletions": 54}, "files": [{"sha": "dfa628ef302681027a6536b33b260b02a395c768", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2dd72a0e83c5f5a4f395c1f818872b618550a5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2dd72a0e83c5f5a4f395c1f818872b618550a5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ad2dd72a0e83c5f5a4f395c1f818872b618550a5", "patch": "@@ -1,3 +1,19 @@\n+2008-08-12  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* tree-vectorizer.c: Depend on langhooks.h.\n+\t(supportable_widening_operation): Add two arguments. Support double\n+\ttype conversions.\n+\t(supportable_narrowing_operation): Likewise.\n+\t* tree-vectorizer.h (supportable_widening_operation): Add two \n+\targuments.\n+\t(supportable_narrowing_operation): Likewise.\n+\t* tree-vect-patterns.c (vect_recog_widen_mult_pattern) : Call\n+\tsupportable_widening_operation with correct arguments.\n+\t* tree-vect-transform.c (vectorizable_conversion): Likewise.\n+\t(vectorizable_type_demotion): Support double type conversions.\n+\t(vectorizable_type_promotion): Likewise.\n+\t* Makefile.in (tree-vectorizer.o): Depend on langhooks.h.\n+\n 2008-08-11  Michael Matz  <matz@suse.de>\n \n \t* i386/i386.c (override_options): Move initialisation from"}, {"sha": "8970d1bf6a3d6c36feb8b42de7f79858c52b424e", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2dd72a0e83c5f5a4f395c1f818872b618550a5/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2dd72a0e83c5f5a4f395c1f818872b618550a5/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=ad2dd72a0e83c5f5a4f395c1f818872b618550a5", "patch": "@@ -2344,7 +2344,7 @@ tree-vectorizer.o: tree-vectorizer.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(GGC_H) $(OPTABS_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) \\\n    $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) \\\n    tree-pass.h $(EXPR_H) $(RECOG_H) tree-vectorizer.h $(TREE_DATA_REF_H) $(SCEV_H) \\\n-   $(INPUT_H) $(TARGET_H) $(CFGLAYOUT_H) $(TOPLEV_H) tree-chrec.h\n+   $(INPUT_H) $(TARGET_H) $(CFGLAYOUT_H) $(TOPLEV_H) tree-chrec.h langhooks.h\n tree-loop-linear.o: tree-loop-linear.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(GGC_H) $(OPTABS_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) \\\n    $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) \\"}, {"sha": "55f170602d6ae87921df9d8bf19293b36cd4f31a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2dd72a0e83c5f5a4f395c1f818872b618550a5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2dd72a0e83c5f5a4f395c1f818872b618550a5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ad2dd72a0e83c5f5a4f395c1f818872b618550a5", "patch": "@@ -1,3 +1,25 @@\n+2008-08-12  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* gcc.dg/vect/vect-multitypes-12.c: New.\n+\t* gcc.dg/vect/vect-multitypes-13.c, gcc.dg/vect/vect-multitypes-14.c,\n+\tgcc.dg/vect/vect-multitypes-15.c : Likewise.\n+\t* gcc.dg/vect/vect-reduc-dot-u8a.c: Avoid vectorization of the\n+\tinit loop.\n+\t* gcc.dg/vect/vect-72.c, gcc.dg/vect/vect-strided-store-a-u8-i2.c:\n+\tLikewise.\n+\t* gcc.dg/vect/vect-reduc-dot-u8b.c: Avoid vectorization of the init\n+\tloop.\n+\tShould be vectorizable on targets that support vector unpack.\n+\t* gcc.dg/vect/vect-widen-mult-u8.c,\n+\tgcc.dg/vect/wrapv-vect-reduc-dot-s8b.c,.\n+\tgcc.dg/vect/wrapv-vect-reduc-dot-s8b.c: Likewise.\n+\t* gcc.dg/vect/vect-35.c: Should be vectorizable on targets that\n+\tsupport vector pack. Avoid vectorization of the init loop.\n+\t* gcc.dg/vect/vect-reduc-pattern-1b.c: Should be vectorizable on\n+\ttargets that support vector unpack.\n+\t* gcc.dg/vect/vect-reduc-pattern-2b.c,\n+\tgcc.dg/vect/vect-reduc-dot-s8c.c, gcc.dg/vect/vect-112.c: Likewise.\n+\n 2008-08-11  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR rtl-optimization/36998"}, {"sha": "0bc185b361ef71c99e729a77ecfaa98a667a877b", "filename": "gcc/testsuite/gcc.dg/vect/vect-112.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2dd72a0e83c5f5a4f395c1f818872b618550a5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-112.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2dd72a0e83c5f5a4f395c1f818872b618550a5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-112.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-112.c?ref=ad2dd72a0e83c5f5a4f395c1f818872b618550a5", "patch": "@@ -32,7 +32,7 @@ int main (void)\n   return main1 ();\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_unpack } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */\n \n "}, {"sha": "d75308f22feac60624b383d51f6e642c1412ac10", "filename": "gcc/testsuite/gcc.dg/vect/vect-35.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2dd72a0e83c5f5a4f395c1f818872b618550a5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-35.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2dd72a0e83c5f5a4f395c1f818872b618550a5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-35.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-35.c?ref=ad2dd72a0e83c5f5a4f395c1f818872b618550a5", "patch": "@@ -18,6 +18,8 @@ int main1 ()\n   for (i = 0; i < N; i++)\n     {\n       s.b[i] = 3*i;\n+      if (i%3 == 0)\n+        s.b[i] = 3*i;\n     }\n \n   /* Dependence analysis fails cause s.a and s.b may overlap."}, {"sha": "67a197519521a8314257a921d2bef183e9dd4072", "filename": "gcc/testsuite/gcc.dg/vect/vect-72.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2dd72a0e83c5f5a4f395c1f818872b618550a5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-72.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2dd72a0e83c5f5a4f395c1f818872b618550a5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-72.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-72.c?ref=ad2dd72a0e83c5f5a4f395c1f818872b618550a5", "patch": "@@ -18,6 +18,9 @@ int main1 ()\n   for (i=0; i < N+1; i++)\n     {\n       ib[i] = i;\n+      /* Avoid vectorization.  */\n+      if (i%3 == 0)\n+        ib[i] = 5;\n     }\n \n   for (i = 1; i < N+1; i++)"}, {"sha": "e4d5417547e1db18bf924cd3318d8dbe623ebb67", "filename": "gcc/testsuite/gcc.dg/vect/vect-multitypes-12.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2dd72a0e83c5f5a4f395c1f818872b618550a5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2dd72a0e83c5f5a4f395c1f818872b618550a5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-12.c?ref=ad2dd72a0e83c5f5a4f395c1f818872b618550a5", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64\n+\n+char x[N] __attribute__ ((__aligned__(16)));\n+\n+__attribute__ ((noinline)) int\n+foo (int len, int *z) {\n+  int i;\n+\n+  for (i=0; i<len; i++) {\n+    z[i] = x[i];\n+  }\n+}\n+\n+\n+int main (void)\n+{\n+  char i;\n+  int z[N+4];\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++) {\n+    x[i] = i;\n+  }\n+\n+  foo (N,z+2);\n+\n+  for (i=0; i<N; i++) {\n+    if (z[i+2] != x[i])\n+      abort ();\n+  }\n+  \n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { target vect_unpack } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { ! vect_unpack } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "32b3131ee20505cae3400a72d38f8d24d902bcc1", "filename": "gcc/testsuite/gcc.dg/vect/vect-multitypes-13.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2dd72a0e83c5f5a4f395c1f818872b618550a5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2dd72a0e83c5f5a4f395c1f818872b618550a5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-13.c?ref=ad2dd72a0e83c5f5a4f395c1f818872b618550a5", "patch": "@@ -0,0 +1,63 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64\n+\n+unsigned char uX[N] __attribute__ ((__aligned__(16)));\n+unsigned int uresult[N];\n+signed char X[N] __attribute__ ((__aligned__(16)));\n+int result[N];\n+\n+/* Unsigned type promotion (qi->si) */\n+__attribute__ ((noinline)) int\n+foo1(int len) {\n+  int i;\n+\n+  for (i=0; i<len; i++) {\n+    uresult[i] = (unsigned int)uX[i];\n+  }\n+}\n+\n+/* Signed type promotion (qi->si) */\n+__attribute__ ((noinline)) int\n+foo2(int len) {\n+  int i;\n+\n+  for (i=0; i<len; i++) {\n+    result[i] = (int)X[i];\n+  }\n+}\n+\n+int main (void)\n+{\n+  int i;\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++) {\n+    X[i] = 16-i;\n+    uX[i] = 16-i;\n+  }\n+\n+  foo1 (N);\n+\n+  for (i=0; i<N; i++) {\n+    if (uresult[i] != (unsigned int)uX[i])\n+      abort ();\n+  }\n+  \n+  foo2 (N);\n+  \n+  for (i=0; i<N; i++) {\n+    if (result[i] != (int)X[i])\n+      abort ();\n+  }\n+  \n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { target vect_unpack } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "970535ff660edc4a43a943e5a02e522f6295966f", "filename": "gcc/testsuite/gcc.dg/vect/vect-multitypes-14.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2dd72a0e83c5f5a4f395c1f818872b618550a5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2dd72a0e83c5f5a4f395c1f818872b618550a5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-14.c?ref=ad2dd72a0e83c5f5a4f395c1f818872b618550a5", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64\n+\n+unsigned char uX[N] __attribute__ ((__aligned__(16)));\n+unsigned char uresultX[N];\n+unsigned int uY[N] __attribute__ ((__aligned__(16)));\n+unsigned char uresultY[N];\n+\n+/* Unsigned type demotion (si->qi) */\n+\n+__attribute__ ((noinline)) int\n+foo1(int len) {\n+  int i;\n+\n+  for (i=0; i<len; i++) {\n+    uresultX[i] = uX[i];\n+    uresultY[i] = (unsigned char)uY[i];\n+  }\n+}\n+\n+int main (void)\n+{\n+  int i;\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++) {\n+    uX[i] = 16-i;\n+    uY[i] = 16-i;\n+  }\n+\n+  foo1 (N);\n+\n+  for (i=0; i<N; i++) {\n+    if (uresultX[i] != uX[i])\n+      abort ();\n+    if (uresultY[i] != (unsigned char)uY[i])\n+      abort ();\n+  }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_pack_trunc } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "458705adada8b2c45abeeeb2a9f5dedb838e8f20", "filename": "gcc/testsuite/gcc.dg/vect/vect-multitypes-15.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2dd72a0e83c5f5a4f395c1f818872b618550a5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2dd72a0e83c5f5a4f395c1f818872b618550a5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-15.c?ref=ad2dd72a0e83c5f5a4f395c1f818872b618550a5", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+#include <stdio.h>\n+\n+#define N 64\n+\n+#define DOT1 43680\n+#define DOT2 -20832\n+\n+signed char X[N] __attribute__ ((__aligned__(16)));\n+signed char Y[N] __attribute__ ((__aligned__(16)));\n+unsigned char CX[N] __attribute__ ((__aligned__(16)));\n+\n+__attribute__ ((noinline)) void\n+foo1(int len) {\n+  int i;\n+  int result1 = 0;\n+\n+  for (i=0; i<len; i++) {\n+    result1 += (X[i] * Y[i]);\n+    CX[i] = 5;\n+  }\n+\n+  if (result1 != DOT1)\n+    abort ();\n+}\n+\n+\n+int main (void)\n+{\n+  int i, dot1, dot2;\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++) {\n+    X[i] = i;\n+    Y[i] = 64-i;\n+    CX[i] = i;\n+  }\n+\n+  foo1 (N);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { vect_sdot_hi  || vect_uncpack } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "80377bae9a4621368db008f3c92e99bd3de0e468", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-dot-s8c.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2dd72a0e83c5f5a4f395c1f818872b618550a5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-s8c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2dd72a0e83c5f5a4f395c1f818872b618550a5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-s8c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-s8c.c?ref=ad2dd72a0e83c5f5a4f395c1f818872b618550a5", "patch": "@@ -11,8 +11,7 @@ signed char X[N] __attribute__ ((__aligned__(16)));\n signed char Y[N] __attribute__ ((__aligned__(16)));\n \n /* char->int->int dot product. \n-   Not detected as a dot-product pattern.\n-   Currently fails to be vectorized due to presence of type conversions. */\n+   Not detected as a dot-product pattern.  */\n __attribute__ ((noinline)) int\n foo3(int len) {\n   int i;\n@@ -42,6 +41,5 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */\n-\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_unpack } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "d8aefdad1a62d232888fd7204d36f451d8477b95", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-dot-u8a.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2dd72a0e83c5f5a4f395c1f818872b618550a5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-u8a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2dd72a0e83c5f5a4f395c1f818872b618550a5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-u8a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-u8a.c?ref=ad2dd72a0e83c5f5a4f395c1f818872b618550a5", "patch": "@@ -44,6 +44,8 @@ int main (void)\n   for (i=0; i<N; i++) {\n     X[i] = i;\n     Y[i] = 64-i;\n+    if (i%5 == 0)\n+      X[i] = i;\n   }\n \n   dot = foo (N);"}, {"sha": "5496f6af920811f176c3e0236dc7b87bd03d3acb", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-dot-u8b.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2dd72a0e83c5f5a4f395c1f818872b618550a5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-u8b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2dd72a0e83c5f5a4f395c1f818872b618550a5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-u8b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-u8b.c?ref=ad2dd72a0e83c5f5a4f395c1f818872b618550a5", "patch": "@@ -39,6 +39,9 @@ int main (void)\n   for (i=0; i<N; i++) {\n     X[i] = i;\n     Y[i] = 64-i;\n+    /* Avoid vectorization.  */\n+    if (i%100 == 0)\n+      X[i] = i;\n   }\n \n   dot = foo (N);\n@@ -54,7 +57,7 @@ int main (void)\n    targets that support accumulation into int (powerpc, ia64) we'd have:\n dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_udot_qi || vect_widen_mult_qi_to_hi } }\n */\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" {target vect_widen_mult_qi_to_hi} } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" {target { vect_widen_mult_qi_to_hi || vect_unpack } } } } */\n \n /* { dg-final { cleanup-tree-dump \"vect\" } } */\n "}, {"sha": "6effa87ebb5be054b58b5bd1352f1c958295e520", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-pattern-1b.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2dd72a0e83c5f5a4f395c1f818872b618550a5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-pattern-1b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2dd72a0e83c5f5a4f395c1f818872b618550a5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-pattern-1b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-pattern-1b.c?ref=ad2dd72a0e83c5f5a4f395c1f818872b618550a5", "patch": "@@ -35,6 +35,6 @@ main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"vect_recog_widen_sum_pattern: detected\" 1 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_widen_sum_qi_to_si } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 0 \"vect\" { target { ! vect_widen_sum_qi_to_si } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { vect_widen_sum_qi_to_si || vect_unpack } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 0 \"vect\" { target { { ! vect_widen_sum_qi_to_si } && { ! vect_unpack } } } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "53d5f0d5cceaf41cf5a14ffd67000739dbc6f7ab", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-pattern-2b.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2dd72a0e83c5f5a4f395c1f818872b618550a5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-pattern-2b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2dd72a0e83c5f5a4f395c1f818872b618550a5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-pattern-2b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-pattern-2b.c?ref=ad2dd72a0e83c5f5a4f395c1f818872b618550a5", "patch": "@@ -35,6 +35,6 @@ main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"vect_recog_widen_sum_pattern: detected\" 1 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_widen_sum_qi_to_si } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 0 \"vect\" { target { ! vect_widen_sum_qi_to_si } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { vect_widen_sum_qi_to_si && vect_unpack } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 0 \"vect\" { target { { ! vect_widen_sum_qi_to_si } && { ! vect_unpack } } } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "8548d267ede7bf5ba0012c272a579beb41b0239f", "filename": "gcc/testsuite/gcc.dg/vect/vect-strided-store-a-u8-i2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2dd72a0e83c5f5a4f395c1f818872b618550a5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-store-a-u8-i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2dd72a0e83c5f5a4f395c1f818872b618550a5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-store-a-u8-i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-store-a-u8-i2.c?ref=ad2dd72a0e83c5f5a4f395c1f818872b618550a5", "patch": "@@ -24,8 +24,8 @@ main1 ()\n     {\n       a[i] = i;\n       b[i] = i * 2;\n-      if (a[i] == 178)\n-         abort();\n+      if (i%3 == 0)\n+        a[i] = 10; \n     }\n \n   for (i = 0; i < N; i++)"}, {"sha": "63bd00227d75c9a892f50fb8d203d3d103ce9336", "filename": "gcc/testsuite/gcc.dg/vect/vect-widen-mult-u8.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2dd72a0e83c5f5a4f395c1f818872b618550a5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-u8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2dd72a0e83c5f5a4f395c1f818872b618550a5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-u8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-u8.c?ref=ad2dd72a0e83c5f5a4f395c1f818872b618550a5", "patch": "@@ -28,6 +28,8 @@ int main (void)\n   for (i=0; i<N; i++) {\n     X[i] = i;\n     Y[i] = 64-i;\n+    if (i%4 == 0)\n+      X[i] = 5;\n   }\n \n   foo1 (N);\n@@ -40,6 +42,6 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_widen_mult_qi_to_hi } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { vect_widen_mult_qi_to_hi || vect_unpack } } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */\n "}, {"sha": "31eb3f62054e1e6ff60b02b171dcb28cf294eeaf", "filename": "gcc/testsuite/gcc.dg/vect/wrapv-vect-reduc-dot-s8b.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2dd72a0e83c5f5a4f395c1f818872b618550a5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fwrapv-vect-reduc-dot-s8b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2dd72a0e83c5f5a4f395c1f818872b618550a5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fwrapv-vect-reduc-dot-s8b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fwrapv-vect-reduc-dot-s8b.c?ref=ad2dd72a0e83c5f5a4f395c1f818872b618550a5", "patch": "@@ -40,6 +40,8 @@ int main (void)\n   for (i=0; i<N; i++) {\n     X[i] = i;\n     Y[i] = 64-i;\n+    if (i%5 == 0)\n+      X[i] = i;\n   }\n \n   dot = foo (N);\n@@ -57,6 +59,6 @@ int main (void)\n dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_sdot_qi } }\n */\n /* In the meantime expect: */\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_widen_mult_qi_to_hi } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { vect_widen_mult_qi_to_hi || vect_unpack } } } } */\n \n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "d5bff5a48226bc1cc057156aecd3fb17e197192f", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2dd72a0e83c5f5a4f395c1f818872b618550a5/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2dd72a0e83c5f5a4f395c1f818872b618550a5/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=ad2dd72a0e83c5f5a4f395c1f818872b618550a5", "patch": "@@ -374,6 +374,7 @@ vect_recog_widen_mult_pattern (gimple last_stmt,\n   tree dummy;\n   tree var;\n   enum tree_code dummy_code;\n+  bool dummy_bool;\n \n   if (!is_gimple_assign (last_stmt))\n     return NULL;\n@@ -414,7 +415,7 @@ vect_recog_widen_mult_pattern (gimple last_stmt,\n   if (!vectype\n       || !supportable_widening_operation (WIDEN_MULT_EXPR, last_stmt, vectype,\n \t\t\t\t\t  &dummy, &dummy, &dummy_code,\n-\t\t\t\t\t  &dummy_code))\n+\t\t\t\t\t  &dummy_code, &dummy_bool, &dummy))\n     return NULL;\n \n   *type_in = vectype;"}, {"sha": "a1bc2b1bd081685114dc28ad889e09f8da78f09f", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 146, "deletions": 26, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2dd72a0e83c5f5a4f395c1f818872b618550a5/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2dd72a0e83c5f5a4f395c1f818872b618550a5/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=ad2dd72a0e83c5f5a4f395c1f818872b618550a5", "patch": "@@ -3457,6 +3457,8 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n   VEC(tree,heap) *vec_oprnds0 = NULL;\n   tree vop0;\n   tree integral_type;\n+  tree dummy;\n+  bool dummy_bool;\n \n   /* Is STMT a vectorizable conversion?   */\n \n@@ -3547,10 +3549,11 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n       || (modifier == WIDEN\n \t  && !supportable_widening_operation (code, stmt, vectype_in,\n \t\t\t\t\t      &decl1, &decl2,\n-\t\t\t\t\t      &code1, &code2))\n+\t\t\t\t\t      &code1, &code2,\n+                                              &dummy_bool, &dummy))\n       || (modifier == NARROW\n \t  && !supportable_narrowing_operation (code, stmt, vectype_in,\n-\t\t\t\t\t       &code1)))\n+\t\t\t\t\t       &code1, &dummy_bool, &dummy)))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"conversion not supported by target.\");\n@@ -4268,6 +4271,10 @@ vectorizable_type_demotion (gimple stmt, gimple_stmt_iterator *gsi,\n   int ncopies;\n   int j;\n   tree vectype_in;\n+  tree intermediate_type = NULL_TREE, narrow_type, double_vec_dest;\n+  bool double_op = false;\n+  tree first_vector, second_vector;\n+  tree vec_oprnd2 = NULL_TREE, vec_oprnd3 = NULL_TREE, last_oprnd = NULL_TREE;\n \n   if (!STMT_VINFO_RELEVANT_P (stmt_info))\n     return false;\n@@ -4297,7 +4304,8 @@ vectorizable_type_demotion (gimple stmt, gimple_stmt_iterator *gsi,\n   if (!vectype_out)\n     return false;\n   nunits_out = TYPE_VECTOR_SUBPARTS (vectype_out);\n-  if (nunits_in != nunits_out / 2) /* FORNOW */\n+  if (nunits_in != nunits_out / 2\n+      && nunits_in != nunits_out/4)\n     return false;\n \n   ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_out;\n@@ -4326,7 +4334,8 @@ vectorizable_type_demotion (gimple stmt, gimple_stmt_iterator *gsi,\n     }\n \n   /* Supportable by target?  */\n-  if (!supportable_narrowing_operation (code, stmt, vectype_in, &code1))\n+  if (!supportable_narrowing_operation (code, stmt, vectype_in, &code1,\n+                                        &double_op, &intermediate_type))\n     return false;\n \n   STMT_VINFO_VECTYPE (stmt_info) = vectype_in;\n@@ -4346,8 +4355,15 @@ vectorizable_type_demotion (gimple stmt, gimple_stmt_iterator *gsi,\n \t     ncopies);\n \n   /* Handle def.  */\n-  vec_dest = vect_create_destination_var (scalar_dest, vectype_out);\n-  \n+  /* In case of double demotion, we first generate demotion operation to the\n+     intermediate type, and then from that type to the final one.  */\n+  if (double_op)\n+    narrow_type = intermediate_type;\n+  else\n+    narrow_type = vectype_out;\n+  vec_dest = vect_create_destination_var (scalar_dest, narrow_type);\n+  double_vec_dest = vect_create_destination_var (scalar_dest, vectype_out);\n+\n   /* In case the vectorization factor (VF) is bigger than the number\n      of elements that we can fit in a vectype (nunits), we have to generate\n      more than one vector stmt - i.e - we need to \"unroll\" the\n@@ -4358,22 +4374,59 @@ vectorizable_type_demotion (gimple stmt, gimple_stmt_iterator *gsi,\n       /* Handle uses.  */\n       if (j == 0)\n \t{\n-\t  vec_oprnd0 = vect_get_vec_def_for_operand (op0, stmt, NULL);\n-\t  vec_oprnd1 = vect_get_vec_def_for_stmt_copy (dt[0], vec_oprnd0);\n+          vec_oprnd0 = vect_get_vec_def_for_operand (op0, stmt, NULL);\n+          vec_oprnd1 = vect_get_vec_def_for_stmt_copy (dt[0], vec_oprnd0);\n+          if (double_op)\n+            {\n+              /* For double demotion we need four operands.  */\n+              vec_oprnd2 = vect_get_vec_def_for_stmt_copy (dt[0], vec_oprnd1);\n+              vec_oprnd3 = vect_get_vec_def_for_stmt_copy (dt[0], vec_oprnd2);\n+            }\n \t}\n       else\n \t{\n-\t  vec_oprnd0 = vect_get_vec_def_for_stmt_copy (dt[0], vec_oprnd1);\n-\t  vec_oprnd1 = vect_get_vec_def_for_stmt_copy (dt[0], vec_oprnd0);\n+          vec_oprnd0 = vect_get_vec_def_for_stmt_copy (dt[0], last_oprnd);\n+          vec_oprnd1 = vect_get_vec_def_for_stmt_copy (dt[0], vec_oprnd0);\n+          if (double_op)\n+            {\n+              /* For double demotion we need four operands.  */\n+              vec_oprnd2 = vect_get_vec_def_for_stmt_copy (dt[0], vec_oprnd1);\n+              vec_oprnd3 = vect_get_vec_def_for_stmt_copy (dt[0], vec_oprnd2);\n+            }\n \t}\n \n-      /* Arguments are ready. Create the new vector stmt.  */\n+      /* Arguments are ready. Create the new vector stmts.  */\n       new_stmt = gimple_build_assign_with_ops (code1, vec_dest, vec_oprnd0,\n-\t\t\t\t\t       vec_oprnd1);\n-      new_temp = make_ssa_name (vec_dest, new_stmt);\n-      gimple_assign_set_lhs (new_stmt, new_temp);\n+                                               vec_oprnd1);\n+      first_vector = make_ssa_name (vec_dest, new_stmt);\n+      gimple_assign_set_lhs (new_stmt, first_vector);\n       vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \n+      /* In the next iteration we will get copy for this operand.  */\n+      last_oprnd = vec_oprnd1;\n+\n+      if (double_op)\n+        {\n+          /* For double demotion operation we first generate two demotion\n+             operations from the source type to the intermediate type, and\n+             then combine the results in one demotion to the destination\n+             type.  */\n+          new_stmt = gimple_build_assign_with_ops (code1, vec_dest, vec_oprnd2,\n+                                                   vec_oprnd3);\n+          second_vector = make_ssa_name (vec_dest, new_stmt);\n+          gimple_assign_set_lhs (new_stmt, second_vector);\n+          vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\n+          new_stmt = gimple_build_assign_with_ops (code1, double_vec_dest, \n+                                                  first_vector, second_vector);\n+          new_temp = make_ssa_name (double_vec_dest, new_stmt);\n+          gimple_assign_set_lhs (new_stmt, new_temp);\n+          vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+         \n+          /* In the next iteration we will get copy for this operand.  */\n+          last_oprnd = vec_oprnd3;\n+        }\n+\n       if (j == 0)\n \tSTMT_VINFO_VEC_STMT (stmt_info) = new_stmt;\n       else\n@@ -4420,6 +4473,9 @@ vectorizable_type_promotion (gimple stmt, gimple_stmt_iterator *gsi,\n   int ncopies;\n   int j;\n   tree vectype_in;\n+  tree intermediate_type = NULL_TREE, first_vector, second_vector;\n+  bool double_op;\n+  tree wide_type, double_vec_dest;\n   \n   if (!STMT_VINFO_RELEVANT_P (stmt_info))\n     return false;\n@@ -4450,7 +4506,7 @@ vectorizable_type_promotion (gimple stmt, gimple_stmt_iterator *gsi,\n   if (!vectype_out)\n     return false;\n   nunits_out = TYPE_VECTOR_SUBPARTS (vectype_out);\n-  if (nunits_out != nunits_in / 2) /* FORNOW */\n+  if (nunits_out != nunits_in / 2 && nunits_out != nunits_in/4)\n     return false;\n \n   ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_in;\n@@ -4492,9 +4548,14 @@ vectorizable_type_promotion (gimple stmt, gimple_stmt_iterator *gsi,\n \n   /* Supportable by target?  */\n   if (!supportable_widening_operation (code, stmt, vectype_in,\n-\t\t\t\t       &decl1, &decl2, &code1, &code2))\n+\t\t\t\t       &decl1, &decl2, &code1, &code2,\n+                                       &double_op, &intermediate_type))\n     return false;\n \n+  /* Binary widening operation can only be supported directly by the\n+     architecture.  */\n+  gcc_assert (!(double_op && op_type == binary_op));\n+\n   STMT_VINFO_VECTYPE (stmt_info) = vectype_in;\n \n   if (!vec_stmt) /* transformation not required.  */\n@@ -4513,7 +4574,13 @@ vectorizable_type_promotion (gimple stmt, gimple_stmt_iterator *gsi,\n                         ncopies);\n \n   /* Handle def.  */\n-  vec_dest = vect_create_destination_var (scalar_dest, vectype_out);\n+  if (double_op)\n+    wide_type = intermediate_type;\n+  else\n+    wide_type = vectype_out;\n+\n+  vec_dest = vect_create_destination_var (scalar_dest, wide_type);\n+  double_vec_dest = vect_create_destination_var (scalar_dest, vectype_out);\n \n   /* In case the vectorization factor (VF) is bigger than the number\n      of elements that we can fit in a vectype (nunits), we have to generate\n@@ -4540,22 +4607,75 @@ vectorizable_type_promotion (gimple stmt, gimple_stmt_iterator *gsi,\n       /* Arguments are ready. Create the new vector stmt.  We are creating \n          two vector defs because the widened result does not fit in one vector.\n          The vectorized stmt can be expressed as a call to a target builtin,\n-         or a using a tree-code.  */\n+         or a using a tree-code. In case of double promotion (from char to int,\n+         for example), the promotion is performed in two phases: first we\n+         generate a promotion operation from the source type to the intermediate\n+         type (short in case of char->int promotion), and then for each of the\n+         created vectors we generate a promotion statement from the intermediate\n+         type to the destination type.  */\n       /* Generate first half of the widened result:  */\n-      new_stmt = vect_gen_widened_results_half (code1, vectype_out, decl1, \n+      new_stmt = vect_gen_widened_results_half (code1, wide_type, decl1, \n \t\t\tvec_oprnd0, vec_oprnd1, op_type, vec_dest, gsi, stmt);\n-      if (j == 0)\n-        STMT_VINFO_VEC_STMT (stmt_info) = new_stmt;\n+      if (is_gimple_call (new_stmt))\n+        first_vector = gimple_call_lhs (new_stmt);\n       else\n-        STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n-      prev_stmt_info = vinfo_for_stmt (new_stmt);\n+        first_vector =  gimple_assign_lhs (new_stmt);\n+\n+      if (!double_op)\n+        {\n+          if (j == 0)\n+            STMT_VINFO_VEC_STMT (stmt_info) = new_stmt;\n+          else\n+            STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n+          prev_stmt_info = vinfo_for_stmt (new_stmt);\n+        }\n \n       /* Generate second half of the widened result:  */\n-      new_stmt = vect_gen_widened_results_half (code2, vectype_out, decl2,\n+      new_stmt = vect_gen_widened_results_half (code2, wide_type, decl2,\n \t\t\tvec_oprnd0, vec_oprnd1, op_type, vec_dest, gsi, stmt);\n-      STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n-      prev_stmt_info = vinfo_for_stmt (new_stmt);\n+      if (is_gimple_call (new_stmt))\n+        second_vector = gimple_call_lhs (new_stmt);\n+      else\n+        second_vector =  gimple_assign_lhs (new_stmt);\n \n+      if (!double_op)\n+        {\n+          STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n+          prev_stmt_info = vinfo_for_stmt (new_stmt);\n+        }\n+      else\n+        {\n+          /* FIRST_VECTOR and SECOND_VECTOR are the results of source type\n+             to intermediate type promotion. Now we generate promotions\n+             for both of them to the destination type (i.e., four\n+             statements).  */\n+          new_stmt = vect_gen_widened_results_half (code1, vectype_out,\n+                                   decl1, first_vector, NULL_TREE, op_type,\n+                                   double_vec_dest, gsi, stmt);\n+          if (j == 0)\n+            STMT_VINFO_VEC_STMT (stmt_info) = new_stmt;\n+          else\n+            STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n+          prev_stmt_info = vinfo_for_stmt (new_stmt);\n+\n+          new_stmt = vect_gen_widened_results_half (code2, vectype_out,\n+                                   decl2, first_vector, NULL_TREE, op_type,\n+                                   double_vec_dest, gsi, stmt);\n+          STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n+          prev_stmt_info = vinfo_for_stmt (new_stmt);\n+\n+          new_stmt = vect_gen_widened_results_half (code1, vectype_out,\n+                                  decl1, second_vector, NULL_TREE, op_type,\n+                                  double_vec_dest, gsi, stmt);\n+          STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n+          prev_stmt_info = vinfo_for_stmt (new_stmt);\n+\n+          new_stmt = vect_gen_widened_results_half (code2, vectype_out,\n+                                  decl2, second_vector, NULL_TREE, op_type,\n+                                  double_vec_dest, gsi, stmt);\n+          STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n+          prev_stmt_info = vinfo_for_stmt (new_stmt);\n+        }\n     }\n \n   *vec_stmt = STMT_VINFO_VEC_STMT (stmt_info);"}, {"sha": "78f82624c236c9c1638b71dda2957cbf14b1db20", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 88, "deletions": 10, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2dd72a0e83c5f5a4f395c1f818872b618550a5/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2dd72a0e83c5f5a4f395c1f818872b618550a5/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=ad2dd72a0e83c5f5a4f395c1f818872b618550a5", "patch": "@@ -147,6 +147,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"hashtab.h\"\n #include \"tree-vectorizer.h\"\n #include \"tree-pass.h\"\n+#include \"langhooks.h\"\n \n /*************************************************************************\n   General Vectorization Utilities\n@@ -2136,12 +2137,17 @@ vect_is_simple_use (tree operand, loop_vec_info loop_vinfo, gimple *def_stmt,\n    vectorizing the operation, if available. \n    - DECL1 and DECL2 are decls of target builtin functions to be used\n    when vectorizing the operation, if available. In this case,\n-   CODE1 and CODE2 are CALL_EXPR.  */\n+   CODE1 and CODE2 are CALL_EXPR.  \n+   - DOUBLE_OP determines if the operation is a double cast, like\n+   char->short->int\n+   - INTERM_TYPE is the intermediate type required to perform the \n+   widening operation (short in the above example)  */\n \n bool\n supportable_widening_operation (enum tree_code code, gimple stmt, tree vectype,\n                                 tree *decl1, tree *decl2,\n-                                enum tree_code *code1, enum tree_code *code2)\n+                                enum tree_code *code1, enum tree_code *code2,\n+                                bool *double_op, tree *interm_type)\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_info = STMT_VINFO_LOOP_VINFO (stmt_info);\n@@ -2154,6 +2160,8 @@ supportable_widening_operation (enum tree_code code, gimple stmt, tree vectype,\n   tree wide_vectype = get_vectype_for_scalar_type (type);\n   enum tree_code c1, c2;\n \n+  *double_op = false;\n+\n   /* The result of a vectorized widening operation usually requires two vectors\n      (because the widened results do not fit int one vector). The generated \n      vector results would normally be expected to be generated in the same \n@@ -2264,12 +2272,57 @@ supportable_widening_operation (enum tree_code code, gimple stmt, tree vectype,\n \n   vec_mode = TYPE_MODE (vectype);\n   if ((icode1 = optab_handler (optab1, vec_mode)->insn_code) == CODE_FOR_nothing\n-      || insn_data[icode1].operand[0].mode != TYPE_MODE (wide_vectype)\n       || (icode2 = optab_handler (optab2, vec_mode)->insn_code)\n-                                                        == CODE_FOR_nothing\n-      || insn_data[icode2].operand[0].mode != TYPE_MODE (wide_vectype))\n+                                                        == CODE_FOR_nothing)\n     return false;\n \n+  /* Check if it's a double cast, like char->int. In such case the intermediate\n+     type is short, and we check that char->short->int operaion is supported by\n+     the target.  */\n+  if (insn_data[icode1].operand[0].mode != TYPE_MODE (wide_vectype)\n+      || insn_data[icode2].operand[0].mode != TYPE_MODE (wide_vectype))\n+    {\n+      if (code == NOP_EXPR)\n+        {\n+          enum machine_mode intermediate_mode =\n+                                             insn_data[icode1].operand[0].mode;\n+          tree intermediate_type =\n+                      lang_hooks.types.type_for_mode (intermediate_mode,\n+                                                      TYPE_UNSIGNED (vectype));\n+          optab optab3 = optab_for_tree_code (c1, intermediate_type,\n+                                              optab_default);\n+          optab optab4 = optab_for_tree_code (c2, intermediate_type,\n+                                              optab_default);\n+\n+          if (!optab3 || !optab4)\n+            return false;\n+\n+          if ((icode1 = optab1->handlers[(int) vec_mode].insn_code)\n+                                                        == CODE_FOR_nothing\n+              || insn_data[icode1].operand[0].mode != intermediate_mode\n+              || (icode2 = optab2->handlers[(int) vec_mode].insn_code)\n+                                                        == CODE_FOR_nothing\n+              || insn_data[icode2].operand[0].mode != intermediate_mode\n+              || (icode1 = optab3->handlers[(int) intermediate_mode].insn_code)\n+                                                        == CODE_FOR_nothing\n+              || insn_data[icode1].operand[0].mode != TYPE_MODE (wide_vectype)\n+              || (icode2 = optab4->handlers[(int) intermediate_mode].insn_code)\n+                                                        == CODE_FOR_nothing\n+              || insn_data[icode2].operand[0].mode != TYPE_MODE (wide_vectype))\n+            return false;\n+          else\n+            {\n+              *double_op = true;\n+              *interm_type = intermediate_type;\n+              *code1 = c1;\n+              *code2 = c2;\n+              return true;\n+            }\n+        }\n+\n+       return false;\n+    }\n+\n   *code1 = c1;\n   *code2 = c2;\n   return true;\n@@ -2288,16 +2341,21 @@ supportable_widening_operation (enum tree_code code, gimple stmt, tree vectype,\n \n    Output:\n    - CODE1 is the code of a vector operation to be used when \n-   vectorizing the operation, if available.  */\n+   vectorizing the operation, if available. \n+   - DOUBLE_OP determines if the operation is a double cast, like\n+   int->short->char\n+   - INTERMIDIATE_TYPE is the intermediate type required to perform the\n+   widening operation (short in the above example) */\n \n bool\n supportable_narrowing_operation (enum tree_code code,\n \t\t\t\t const_gimple stmt, const_tree vectype,\n-\t\t\t\t enum tree_code *code1)\n+\t\t\t\t enum tree_code *code1, bool *double_op,\n+                                 tree *intermediate_type)\n {\n   enum machine_mode vec_mode;\n   enum insn_code icode1;\n-  optab optab1;\n+  optab optab1, interm_optab;\n   tree type = gimple_expr_type (stmt);\n   tree narrow_vectype = get_vectype_for_scalar_type (type);\n   enum tree_code c1;\n@@ -2331,10 +2389,30 @@ supportable_narrowing_operation (enum tree_code code,\n     return false;\n \n   vec_mode = TYPE_MODE (vectype);\n-  if ((icode1 = optab_handler (optab1, vec_mode)->insn_code) == CODE_FOR_nothing\n-      || insn_data[icode1].operand[0].mode != TYPE_MODE (narrow_vectype))\n+  if ((icode1 = optab_handler (optab1, vec_mode)->insn_code) \n+       == CODE_FOR_nothing)\n     return false;\n \n+  /* In case of NUNITS_IN == NUNITS_OUT/4 check that the it is possible to\n+     perform the operation using an intermediate type of NUNITS_OUT/2.  */\n+  if (insn_data[icode1].operand[0].mode != TYPE_MODE (narrow_vectype))\n+    {\n+      enum machine_mode intermediate_mode = insn_data[icode1].operand[0].mode;\n+      *intermediate_type = lang_hooks.types.type_for_mode (intermediate_mode,\n+                                                 TYPE_UNSIGNED (vectype));\n+      interm_optab = optab_for_tree_code (VEC_PACK_TRUNC_EXPR,\n+                                          *intermediate_type, optab_default);\n+      if (!interm_optab)\n+        return false;\n+\n+      if ((icode1 = interm_optab->handlers[(int) intermediate_mode].insn_code)\n+           == CODE_FOR_nothing\n+          || insn_data[icode1].operand[0].mode != TYPE_MODE (narrow_vectype))\n+        return false;\n+\n+      *double_op = true;\n+    }\n+\n   *code1 = c1;\n   return true;\n }"}, {"sha": "cf7c5b123e9e5935869ea81f9344f6114a295b6f", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2dd72a0e83c5f5a4f395c1f818872b618550a5/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2dd72a0e83c5f5a4f395c1f818872b618550a5/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=ad2dd72a0e83c5f5a4f395c1f818872b618550a5", "patch": "@@ -671,9 +671,9 @@ extern enum dr_alignment_support vect_supportable_dr_alignment\n   (struct data_reference *);\n extern bool reduction_code_for_scalar_code (enum tree_code, enum tree_code *);\n extern bool supportable_widening_operation (enum tree_code, gimple, tree,\n-  tree *, tree *, enum tree_code *, enum tree_code *);\n+  tree *, tree *, enum tree_code *, enum tree_code *, bool *, tree *);\n extern bool supportable_narrowing_operation (enum tree_code, const_gimple,\n-\t\t\t\t\t     const_tree, enum tree_code *);\n+\t\t\t     const_tree, enum tree_code *, bool *, tree *);\n \n /* Creation and deletion of loop and stmt info structs.  */\n extern loop_vec_info new_loop_vec_info (struct loop *loop);"}]}