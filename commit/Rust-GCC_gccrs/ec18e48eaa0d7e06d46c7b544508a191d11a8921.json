{"sha": "ec18e48eaa0d7e06d46c7b544508a191d11a8921", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWMxOGU0OGVhYTBkN2UwNmQ0NmM3YjU0NDUwOGExOTFkMTFhODkyMQ==", "commit": {"author": {"name": "Vlad Lazar", "email": "vlad.lazar@arm.com", "date": "2018-08-16T16:33:43Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2018-08-16T16:33:43Z"}, "message": "expmed.h (canonicalize_comparison): New declaration.\n\n\t* expmed.h (canonicalize_comparison): New declaration.\n\t* expmed.c (canonicalize_comparison, equivalent_cmp_code): New function.\n\t* expmed.c (emit_store_flag_1): Add call to canonicalize_comparison.\n\t* optabs.c (prepare_cmp_insn): Likewise.\n\t* rtl.h (unsigned_condition_p): New function which checks if a\n\tcomparison operator is unsigned.\n\n\t* gcc.target/aarch64/imm_choice_comparison.c: New test.\n\nFrom-SVN: r263591", "tree": {"sha": "ab7980e4a0ea136a6da132a6eaa6bd5bad54c76d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab7980e4a0ea136a6da132a6eaa6bd5bad54c76d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec18e48eaa0d7e06d46c7b544508a191d11a8921", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec18e48eaa0d7e06d46c7b544508a191d11a8921", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec18e48eaa0d7e06d46c7b544508a191d11a8921", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec18e48eaa0d7e06d46c7b544508a191d11a8921/comments", "author": null, "committer": null, "parents": [{"sha": "891b1d6872ecf18ccf605d036f8f01dec32d66a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/891b1d6872ecf18ccf605d036f8f01dec32d66a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/891b1d6872ecf18ccf605d036f8f01dec32d66a4"}], "stats": {"total": 174, "additions": 174, "deletions": 0}, "files": [{"sha": "0e1125595f14aa83eaa1507c50859b485f6fb095", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec18e48eaa0d7e06d46c7b544508a191d11a8921/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec18e48eaa0d7e06d46c7b544508a191d11a8921/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ec18e48eaa0d7e06d46c7b544508a191d11a8921", "patch": "@@ -1,3 +1,12 @@\n+2018-08-16  Vlad Lazar  <vlad.lazar@arm.com>\n+\n+\t* expmed.h (canonicalize_comparison): New declaration.\n+\t* expmed.c (canonicalize_comparison, equivalent_cmp_code): New function.\n+\t* expmed.c (emit_store_flag_1): Add call to canonicalize_comparison.\n+\t* optabs.c (prepare_cmp_insn): Likewise.\n+\t* rtl.h (unsigned_condition_p): New function which checks if a\n+\tcomparison operator is unsigned.\n+\n 2018-08-16  Nathan Sidwell  <nathan@acm.org>\n \n \t* config/rs6000/rs6000-c.c (rs6000_macro_to_expend): Use cpp_macro_p."}, {"sha": "be9f0ec901169c28f261e6de5e63bb4cdd9f7c62", "filename": "gcc/expmed.c", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec18e48eaa0d7e06d46c7b544508a191d11a8921/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec18e48eaa0d7e06d46c7b544508a191d11a8921/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=ec18e48eaa0d7e06d46c7b544508a191d11a8921", "patch": "@@ -5541,6 +5541,9 @@ emit_store_flag_1 (rtx target, enum rtx_code code, rtx op0, rtx op1,\n   if (mode == VOIDmode)\n     mode = GET_MODE (op0);\n \n+  if (CONST_SCALAR_INT_P (op1))\n+    canonicalize_comparison (mode, &code, &op1);\n+\n   /* For some comparisons with 1 and -1, we can convert this to\n      comparisons with zero.  This will often produce more opportunities for\n      store-flag insns.  */\n@@ -6161,6 +6164,96 @@ emit_store_flag_force (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \n   return target;\n }\n+\n+/* Helper function for canonicalize_cmp_for_target.  Swap between inclusive\n+   and exclusive ranges in order to create an equivalent comparison.  See\n+   canonicalize_cmp_for_target for the possible cases.  */\n+\n+static enum rtx_code\n+equivalent_cmp_code (enum rtx_code code)\n+{\n+  switch (code)\n+    {\n+    case GT:\n+      return GE;\n+    case GE:\n+      return GT;\n+    case LT:\n+      return LE;\n+    case LE:\n+      return LT;\n+    case GTU:\n+      return GEU;\n+    case GEU:\n+      return GTU;\n+    case LTU:\n+      return LEU;\n+    case LEU:\n+      return LTU;\n+\n+    default:\n+      return code;\n+    }\n+}\n+\n+/* Choose the more appropiate immediate in scalar integer comparisons.  The\n+   purpose of this is to end up with an immediate which can be loaded into a\n+   register in fewer moves, if possible.\n+\n+   For each integer comparison there exists an equivalent choice:\n+     i)   a >  b or a >= b + 1\n+     ii)  a <= b or a <  b + 1\n+     iii) a >= b or a >  b - 1\n+     iv)  a <  b or a <= b - 1\n+\n+   MODE is the mode of the first operand.\n+   CODE points to the comparison code.\n+   IMM points to the rtx containing the immediate.  *IMM must satisfy\n+   CONST_SCALAR_INT_P on entry and continues to satisfy CONST_SCALAR_INT_P\n+   on exit.  */\n+\n+void\n+canonicalize_comparison (machine_mode mode, enum rtx_code *code, rtx *imm)\n+{\n+  if (!SCALAR_INT_MODE_P (mode))\n+    return;\n+\n+  int to_add = 0;\n+  enum signop sgn = unsigned_condition_p (*code) ? UNSIGNED : SIGNED;\n+\n+  /* Extract the immediate value from the rtx.  */\n+  wide_int imm_val = rtx_mode_t (*imm, mode);\n+\n+  if (*code == GT || *code == GTU || *code == LE || *code == LEU)\n+    to_add = 1;\n+  else if (*code == GE || *code == GEU || *code == LT || *code == LTU)\n+    to_add = -1;\n+  else\n+    return;\n+\n+  /* Check for overflow/underflow in the case of signed values and\n+     wrapping around in the case of unsigned values.  If any occur\n+     cancel the optimization.  */\n+  wi::overflow_type overflow = wi::OVF_NONE;\n+  wide_int imm_modif = wi::add (imm_val, to_add, sgn, &overflow);\n+  if (overflow)\n+    return;\n+\n+  rtx reg = gen_rtx_REG (mode, LAST_VIRTUAL_REGISTER + 1);\n+  rtx new_imm = immed_wide_int_const (imm_modif, mode);\n+\n+  rtx_insn *old_rtx = gen_move_insn (reg, *imm);\n+  rtx_insn *new_rtx = gen_move_insn (reg, new_imm);\n+\n+  /* Update the immediate and the code.  */\n+  if (insn_cost (old_rtx, true) > insn_cost (new_rtx, true))\n+    {\n+      *code = equivalent_cmp_code (*code);\n+      *imm = new_imm;\n+    }\n+}\n+\n+\n \f\n /* Perform possibly multi-word comparison and conditional jump to LABEL\n    if ARG1 OP ARG2 true where ARG1 and ARG2 are of mode MODE.  This is"}, {"sha": "cc247c4379e3e4927f837421eb386dee2db98255", "filename": "gcc/expmed.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec18e48eaa0d7e06d46c7b544508a191d11a8921/gcc%2Fexpmed.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec18e48eaa0d7e06d46c7b544508a191d11a8921/gcc%2Fexpmed.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.h?ref=ec18e48eaa0d7e06d46c7b544508a191d11a8921", "patch": "@@ -702,6 +702,8 @@ extern rtx emit_store_flag (rtx, enum rtx_code, rtx, rtx, machine_mode,\n extern rtx emit_store_flag_force (rtx, enum rtx_code, rtx, rtx,\n \t\t\t\t  machine_mode, int, int);\n \n+extern void canonicalize_comparison (machine_mode, enum rtx_code *, rtx *);\n+\n /* Choose a minimal N + 1 bit approximation to 1/D that can be used to\n    replace division by D, and put the least significant N bits of the result\n    in *MULTIPLIER_PTR and return the most significant bit.  */"}, {"sha": "6052222c90ce559ae3b11a40fbd2ebbf4a6bc8dc", "filename": "gcc/optabs.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec18e48eaa0d7e06d46c7b544508a191d11a8921/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec18e48eaa0d7e06d46c7b544508a191d11a8921/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=ec18e48eaa0d7e06d46c7b544508a191d11a8921", "patch": "@@ -3812,6 +3812,9 @@ prepare_cmp_insn (rtx x, rtx y, enum rtx_code comparison, rtx size,\n   gcc_assert (methods == OPTAB_DIRECT || methods == OPTAB_WIDEN\n \t      || methods == OPTAB_LIB_WIDEN);\n \n+  if (CONST_SCALAR_INT_P (y))\n+    canonicalize_comparison (mode, &comparison, &y);\n+\n   /* If we are optimizing, force expensive constants into a register.  */\n   if (CONSTANT_P (x) && optimize\n       && (rtx_cost (x, mode, COMPARE, 0, optimize_insn_for_speed_p ())"}, {"sha": "68d3ceab29fc392b59e1a9deb33ff653b59fe1fc", "filename": "gcc/rtl.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec18e48eaa0d7e06d46c7b544508a191d11a8921/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec18e48eaa0d7e06d46c7b544508a191d11a8921/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=ec18e48eaa0d7e06d46c7b544508a191d11a8921", "patch": "@@ -3310,6 +3310,15 @@ extern enum rtx_code unsigned_condition (enum rtx_code);\n extern enum rtx_code signed_condition (enum rtx_code);\n extern void mark_jump_label (rtx, rtx_insn *, int);\n \n+/* Return true if integer comparison operator CODE interprets its operands\n+   as unsigned.  */\n+\n+inline bool\n+unsigned_condition_p (enum rtx_code code)\n+{\n+  return unsigned_condition (code) == code;\n+}\n+\n /* In jump.c */\n extern rtx_insn *delete_related_insns (rtx);\n "}, {"sha": "e0f48aba8cf4354e85b7f547d7dcd12ec7df456a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec18e48eaa0d7e06d46c7b544508a191d11a8921/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec18e48eaa0d7e06d46c7b544508a191d11a8921/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ec18e48eaa0d7e06d46c7b544508a191d11a8921", "patch": "@@ -1,3 +1,7 @@\n+2018-08-16  Vlad Lazar  <vlad.lazar@arm.com>\n+\n+\t* gcc.target/aarch64/imm_choice_comparison.c: New test.\n+\n 2018-08-16  Iain Sandoe <iain@sandoe.co.uk>\n \n \t* gcc.dg/memcmp-1.c (lib_memcmp): Apply __USER_LABEL_PREFIX__."}, {"sha": "ebc44d6dbc7287d907603d77d7b54496de177c4b", "filename": "gcc/testsuite/gcc.target/aarch64/imm_choice_comparison.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec18e48eaa0d7e06d46c7b544508a191d11a8921/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fimm_choice_comparison.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec18e48eaa0d7e06d46c7b544508a191d11a8921/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fimm_choice_comparison.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fimm_choice_comparison.c?ref=ec18e48eaa0d7e06d46c7b544508a191d11a8921", "patch": "@@ -0,0 +1,54 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+/* Go from four moves to two.  */\n+\n+int\n+foo (long long x)\n+{\n+  return x <= 0x1999999999999998;\n+}\n+\n+int\n+GT (unsigned int x)\n+{\n+  return x > 0xfefffffe;\n+}\n+\n+int\n+LE (unsigned int x)\n+{\n+  return x <= 0xfefffffe;\n+}\n+\n+int\n+GE (long long x)\n+{\n+  return x >= 0xff000000;\n+}\n+\n+int\n+LT (int x)\n+{\n+  return x < 0xff000000;\n+}\n+\n+/* Optimize the immediate in conditionals.  */\n+\n+int\n+check (int x, int y)\n+{\n+  if (x > y && GT (x))\n+    return 100;\n+\n+  return x;\n+}\n+\n+int\n+tern (int x)\n+{\n+  return x >= 0xff000000 ? 5 : -3;\n+}\n+\n+/* baz produces one movk instruction.  */\n+/* { dg-final { scan-assembler-times \"movk\" 1 } } */"}]}