{"sha": "14976818e723aedf177bdd090fdd3ecb246e908d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTQ5NzY4MThlNzIzYWVkZjE3N2JkZDA5MGZkZDNlY2IyNDZlOTA4ZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard@codesourcery.com", "date": "2007-04-12T17:10:56Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2007-04-12T17:10:56Z"}, "message": "mips.h (TARGET_SPLIT_CALLS): Check TARGET_CALL_CLOBBERED_GP.\n\ngcc/\n\t* config/mips/mips.h (TARGET_SPLIT_CALLS): Check\n\tTARGET_CALL_CLOBBERED_GP.\n\t(TARGET_SIBCALLS): Check TARGET_USE_GOT instead of TARGET_ABICALLS.\n\t(TARGET_USE_GOT, TARGET_CALL_CLOBBERED_GP): New macros.\n\t(TARGET_CALL_SAVED_GP, TARGET_USE_PIC_FN_ADDR_REG): Likewise.\n\t(STARTING_FRAME_OFFSET): Check TARGET_CALL_CLOBBERED_GP instead\n\tof TARGET_ABICALLS && !TARGET_NEWABI.\n\t(MIPS_CALL): Check TARGET_USE_GOT instead of TARGET_ABICALLS.\n\t* config/mips/mips.c (mips_load_call_address): Check\n\tTARGET_CALL_SAVED_GP instead of TARGET_NEWABI.\n\t(mips_global_pointer): Check TARGET_USE_GOT instead of TARGET_ABICALLS.\n\tCheck TARGET_CALL_SAVED_GP instead of TARGET_NEWABI.\n\t(mips_save_reg_p): Check TARGET_CALL_SAVED_GP instead of\n\tTARGET_ABICALLS && TARGET_NEWABI.\n\t(mips_current_loadgp_style): Check TARGET_USE_GOT instead of\n\tTARGET_ABICALLS.\n\t(mips_expand_prologue): Check TARGET_OLDABI instead of !TARGET_NEWABI.\n\t(mips_expand_epilogue): Check TARGET_CALL_SAVED_GP instead of\n\tTARGET_ABICALLS && TARGET_NEWABI.\n\t(mips_output_mi_thunk): Check TARGET_USE_GOT instead of\n\tTARGET_ABICALLS.  Check TARGET_CALL_SAVED_GP instead of\n\tTARGET_NEWABI.  Use TARGET_USE_PIC_FN_ADDR_REG to decide\n\twhether indirect calls must use $25.\n\t(mips_extra_live_on_entry): Check TARGET_GOT instead of\n\tTARGET_ABICALLS.\n\t* config/mips/mips.md (jal_macro): Check flag_pic and\n\tTARGET_CALL_CLOBBERED_GP instead of TARGET_ABICALLS and TARGET_NEWABI.\n\t(builtin_setjmp_setup, builtin_longjmp): Check TARGET_USE_GOT\n\tinstead of TARGET_ABICALLS.\n\t(exception_receiver): Check TARGET_CALL_CLOBBERED_GP instead of\n\tTARGET_ABICALLS && TARGET_OLDABI.\n\t(load_call<mode>): Check TARGET_USE_GOT instead of TARGET_ABICALLS.\n\t(sibcall): In the comment above the define_insn, mention\n\tTARGET_USE_PIC_FN_ADDR_REG instead of TARGET_ABICALLS.\n\t* config/mips/constraints.md (c): Check TARGET_USE_PIC_FN_ADDR_REG\n\tinstead of TARGET_ABICALLS.\n\nFrom-SVN: r123751", "tree": {"sha": "7c0f32335921253409500cfc13d9689ae349e3b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c0f32335921253409500cfc13d9689ae349e3b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/14976818e723aedf177bdd090fdd3ecb246e908d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14976818e723aedf177bdd090fdd3ecb246e908d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14976818e723aedf177bdd090fdd3ecb246e908d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14976818e723aedf177bdd090fdd3ecb246e908d/comments", "author": null, "committer": null, "parents": [{"sha": "2f11881446ab72f0e85eedb8391ae47cd89d3244", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f11881446ab72f0e85eedb8391ae47cd89d3244", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f11881446ab72f0e85eedb8391ae47cd89d3244"}], "stats": {"total": 162, "additions": 107, "deletions": 55}, "files": [{"sha": "d28edd580148823eadcd9ddbc82699b4cf64ced5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14976818e723aedf177bdd090fdd3ecb246e908d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14976818e723aedf177bdd090fdd3ecb246e908d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=14976818e723aedf177bdd090fdd3ecb246e908d", "patch": "@@ -1,3 +1,42 @@\n+2007-04-12  Richard Sandiford  <richard@codesourcery.com>\n+\n+\t* config/mips/mips.h (TARGET_SPLIT_CALLS): Check\n+\tTARGET_CALL_CLOBBERED_GP.\n+\t(TARGET_SIBCALLS): Check TARGET_USE_GOT instead of TARGET_ABICALLS.\n+\t(TARGET_USE_GOT, TARGET_CALL_CLOBBERED_GP): New macros.\n+\t(TARGET_CALL_SAVED_GP, TARGET_USE_PIC_FN_ADDR_REG): Likewise.\n+\t(STARTING_FRAME_OFFSET): Check TARGET_CALL_CLOBBERED_GP instead\n+\tof TARGET_ABICALLS && !TARGET_NEWABI.\n+\t(MIPS_CALL): Check TARGET_USE_GOT instead of TARGET_ABICALLS.\n+\t* config/mips/mips.c (mips_load_call_address): Check\n+\tTARGET_CALL_SAVED_GP instead of TARGET_NEWABI.\n+\t(mips_global_pointer): Check TARGET_USE_GOT instead of TARGET_ABICALLS.\n+\tCheck TARGET_CALL_SAVED_GP instead of TARGET_NEWABI.\n+\t(mips_save_reg_p): Check TARGET_CALL_SAVED_GP instead of\n+\tTARGET_ABICALLS && TARGET_NEWABI.\n+\t(mips_current_loadgp_style): Check TARGET_USE_GOT instead of\n+\tTARGET_ABICALLS.\n+\t(mips_expand_prologue): Check TARGET_OLDABI instead of !TARGET_NEWABI.\n+\t(mips_expand_epilogue): Check TARGET_CALL_SAVED_GP instead of\n+\tTARGET_ABICALLS && TARGET_NEWABI.\n+\t(mips_output_mi_thunk): Check TARGET_USE_GOT instead of\n+\tTARGET_ABICALLS.  Check TARGET_CALL_SAVED_GP instead of\n+\tTARGET_NEWABI.  Use TARGET_USE_PIC_FN_ADDR_REG to decide\n+\twhether indirect calls must use $25.\n+\t(mips_extra_live_on_entry): Check TARGET_GOT instead of\n+\tTARGET_ABICALLS.\n+\t* config/mips/mips.md (jal_macro): Check flag_pic and\n+\tTARGET_CALL_CLOBBERED_GP instead of TARGET_ABICALLS and TARGET_NEWABI.\n+\t(builtin_setjmp_setup, builtin_longjmp): Check TARGET_USE_GOT\n+\tinstead of TARGET_ABICALLS.\n+\t(exception_receiver): Check TARGET_CALL_CLOBBERED_GP instead of\n+\tTARGET_ABICALLS && TARGET_OLDABI.\n+\t(load_call<mode>): Check TARGET_USE_GOT instead of TARGET_ABICALLS.\n+\t(sibcall): In the comment above the define_insn, mention\n+\tTARGET_USE_PIC_FN_ADDR_REG instead of TARGET_ABICALLS.\n+\t* config/mips/constraints.md (c): Check TARGET_USE_PIC_FN_ADDR_REG\n+\tinstead of TARGET_ABICALLS.\n+\n 2007-04-12  Bernd Schmidt  <bernd.schmidt@analog.com>\n \n \t* doc/md.texi (Blackfin family constraints): Document PA and PB."}, {"sha": "a01777dc926c01b9db8cd62e5feec55751c5a53b", "filename": "gcc/config/mips/constraints.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14976818e723aedf177bdd090fdd3ecb246e908d/gcc%2Fconfig%2Fmips%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14976818e723aedf177bdd090fdd3ecb246e908d/gcc%2Fconfig%2Fmips%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fconstraints.md?ref=14976818e723aedf177bdd090fdd3ecb246e908d", "patch": "@@ -42,7 +42,7 @@\n (define_register_constraint \"b\" \"ALL_REGS\"\n   \"@internal\")\n \n-(define_register_constraint \"c\" \"TARGET_ABICALLS ? PIC_FN_ADDR_REG\n+(define_register_constraint \"c\" \"TARGET_USE_PIC_FN_ADDR_REG ? PIC_FN_ADDR_REG\n \t\t\t\t : TARGET_MIPS16 ? M16_NA_REGS\n \t\t\t\t : GR_REGS\"\n   \"A register suitable for use in an indirect jump.  This will always be"}, {"sha": "86155109404313284878338bdb9fe0a0aaa49952", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 31, "deletions": 28, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14976818e723aedf177bdd090fdd3ecb246e908d/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14976818e723aedf177bdd090fdd3ecb246e908d/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=14976818e723aedf177bdd090fdd3ecb246e908d", "patch": "@@ -3354,10 +3354,10 @@ mips_load_call_address (rtx dest, rtx addr, int sibcall_p)\n {\n   /* If we're generating PIC, and this call is to a global function,\n      try to allow its address to be resolved lazily.  This isn't\n-     possible for NewABI sibcalls since the value of $gp on entry\n+     possible if TARGET_CALL_SAVED_GP since the value of $gp on entry\n      to the stub would be our caller's gp, not ours.  */\n   if (TARGET_EXPLICIT_RELOCS\n-      && !(sibcall_p && TARGET_NEWABI)\n+      && !(sibcall_p && TARGET_CALL_SAVED_GP)\n       && global_got_operand (addr, VOIDmode))\n     {\n       rtx high, lo_sum_symbol;\n@@ -6144,8 +6144,8 @@ mips_global_pointer (void)\n {\n   unsigned int regno;\n \n-  /* $gp is always available in non-abicalls code.  */\n-  if (!TARGET_ABICALLS)\n+  /* $gp is always available unless we're using a GOT.  */\n+  if (!TARGET_USE_GOT)\n     return GLOBAL_POINTER_REGNUM;\n \n   /* We must always provide $gp when it is used implicitly.  */\n@@ -6182,7 +6182,7 @@ mips_global_pointer (void)\n \n   /* We need a global pointer, but perhaps we can use a call-clobbered\n      register instead of $gp.  */\n-  if (TARGET_NEWABI && current_function_is_leaf)\n+  if (TARGET_CALL_SAVED_GP && current_function_is_leaf)\n     for (regno = GP_REG_FIRST; regno <= GP_REG_LAST; regno++)\n       if (!regs_ever_live[regno]\n \t  && call_used_regs[regno]\n@@ -6199,10 +6199,10 @@ mips_global_pointer (void)\n static bool\n mips_save_reg_p (unsigned int regno)\n {\n-  /* We only need to save $gp for NewABI PIC.  */\n+  /* We only need to save $gp if TARGET_CALL_SAVED_GP and only then\n+     if we have not chosen a call-clobbered substitute.  */\n   if (regno == GLOBAL_POINTER_REGNUM)\n-    return (TARGET_ABICALLS && TARGET_NEWABI\n-\t    && cfun->machine->global_pointer == regno);\n+    return TARGET_CALL_SAVED_GP && cfun->machine->global_pointer == regno;\n \n   /* Check call-saved registers.  */\n   if (regs_ever_live[regno] && !call_used_regs[regno])\n@@ -6546,7 +6546,7 @@ mips_output_cplocal (void)\n enum mips_loadgp_style\n mips_current_loadgp_style (void)\n {\n-  if (!TARGET_ABICALLS || cfun->machine->global_pointer == 0)\n+  if (!TARGET_USE_GOT || cfun->machine->global_pointer == 0)\n     return LOADGP_NONE;\n \n   if (TARGET_ABSOLUTE_ABICALLS)\n@@ -6858,7 +6858,7 @@ mips_expand_prologue (void)\n   mips_emit_loadgp ();\n \n   /* If generating o32/o64 abicalls, save $gp on the stack.  */\n-  if (TARGET_ABICALLS && !TARGET_NEWABI && !current_function_is_leaf)\n+  if (TARGET_ABICALLS && TARGET_OLDABI && !current_function_is_leaf)\n     emit_insn (gen_cprestore (GEN_INT (current_function_outgoing_args_size)));\n \n   /* If we are profiling, make sure no instructions are scheduled before\n@@ -6992,10 +6992,10 @@ mips_expand_epilogue (int sibcall_p)\n   if (target != stack_pointer_rtx)\n     emit_move_insn (stack_pointer_rtx, target);\n \n-  /* If we're using addressing macros for n32/n64 abicalls, $gp is\n-     implicitly used by all SYMBOL_REFs.  We must emit a blockage\n-     insn before restoring it.  */\n-  if (TARGET_ABICALLS && TARGET_NEWABI && !TARGET_EXPLICIT_RELOCS)\n+  /* If we're using addressing macros, $gp is implicitly used by all\n+     SYMBOL_REFs.  We must emit a blockage insn before restoring $gp\n+     from the stack.  */\n+  if (TARGET_CALL_SAVED_GP && !TARGET_EXPLICIT_RELOCS)\n     emit_insn (gen_blockage ());\n \n   /* Restore the registers.  */\n@@ -7086,12 +7086,12 @@ mips_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n   reload_completed = 1;\n   reset_block_changes ();\n \n-  /* Pick a global pointer for -mabicalls.  Use $15 rather than $28\n-     for TARGET_NEWABI since the latter is a call-saved register.  */\n-  if (TARGET_ABICALLS)\n+  /* Pick a global pointer.  Use a call-clobbered register if\n+     TARGET_CALL_SAVED_GP, so that we can use a sibcall.  */\n+  if (TARGET_USE_GOT)\n     cfun->machine->global_pointer\n       = REGNO (pic_offset_table_rtx)\n-      = TARGET_NEWABI ? 15 : GLOBAL_POINTER_REGNUM;\n+      = TARGET_CALL_SAVED_GP ? 15 : GLOBAL_POINTER_REGNUM;\n \n   /* Set up the global pointer for n32 or n64 abicalls.  */\n   mips_emit_loadgp ();\n@@ -7137,24 +7137,27 @@ mips_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n   /* Jump to the target function.  Use a sibcall if direct jumps are\n      allowed, otherwise load the address into a register first.  */\n   fnaddr = XEXP (DECL_RTL (function), 0);\n-  if (TARGET_MIPS16 || TARGET_ABICALLS || TARGET_LONG_CALLS)\n+  if (TARGET_MIPS16 || TARGET_USE_GOT || TARGET_LONG_CALLS)\n     {\n       /* This is messy.  gas treats \"la $25,foo\" as part of a call\n \t sequence and may allow a global \"foo\" to be lazily bound.\n \t The general move patterns therefore reject this combination.\n \n-\t In this context, lazy binding would actually be OK for o32 and o64,\n-\t but it's still wrong for n32 and n64; see mips_load_call_address.\n-\t We must therefore load the address via a temporary register if\n-\t mips_dangerous_for_la25_p.\n+\t In this context, lazy binding would actually be OK\n+\t for TARGET_CALL_CLOBBERED_GP, but it's still wrong for\n+\t TARGET_CALL_SAVED_GP; see mips_load_call_address.\n+\t We must therefore load the address via a temporary\n+\t register if mips_dangerous_for_la25_p.\n \n \t If we jump to the temporary register rather than $25, the assembler\n \t can use the move insn to fill the jump's delay slot.  */\n-      if (TARGET_ABICALLS && !mips_dangerous_for_la25_p (fnaddr))\n+      if (TARGET_USE_PIC_FN_ADDR_REG\n+\t  && !mips_dangerous_for_la25_p (fnaddr))\n \ttemp1 = gen_rtx_REG (Pmode, PIC_FUNCTION_ADDR_REGNUM);\n       mips_load_call_address (temp1, fnaddr, true);\n \n-      if (TARGET_ABICALLS && REGNO (temp1) != PIC_FUNCTION_ADDR_REGNUM)\n+      if (TARGET_USE_PIC_FN_ADDR_REG\n+\t  && REGNO (temp1) != PIC_FUNCTION_ADDR_REGNUM)\n \temit_move_insn (gen_rtx_REG (Pmode, PIC_FUNCTION_ADDR_REGNUM), temp1);\n       emit_jump_insn (gen_indirect_jump (temp1));\n     }\n@@ -10878,13 +10881,13 @@ mips_encode_section_info (tree decl, rtx rtl, int first)\n     }\n }\n \n-/* Implement TARGET_EXTRA_LIVE_ON_ENTRY.  PIC_FUNCTION_ADDR_REGNUM is live\n-   on entry to a function when generating -mshared abicalls code.  */\n+/* Implement TARGET_EXTRA_LIVE_ON_ENTRY.  Some code models use the incoming\n+   value of PIC_FUNCTION_ADDR_REGNUM to set up the global pointer.  */\n \n static void\n mips_extra_live_on_entry (bitmap regs)\n {\n-  if (TARGET_ABICALLS && !TARGET_ABSOLUTE_ABICALLS)\n+  if (TARGET_USE_GOT && !TARGET_ABSOLUTE_ABICALLS)\n     bitmap_set_bit (regs, PIC_FUNCTION_ADDR_REGNUM);\n }\n "}, {"sha": "af8a7f4ba2a2c359a50f9979ff874bb55b04d353", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14976818e723aedf177bdd090fdd3ecb246e908d/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14976818e723aedf177bdd090fdd3ecb246e908d/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=14976818e723aedf177bdd090fdd3ecb246e908d", "patch": "@@ -144,12 +144,11 @@ extern const struct mips_rtx_cost_data *mips_cost;\n /* Run-time compilation parameters selecting different hardware subsets.  */\n \n /* True if the call patterns should be split into a jalr followed by\n-   an instruction to restore $gp.  This is only ever true for SVR4 PIC,\n-   in which $gp is call-clobbered.  It is only safe to split the load\n+   an instruction to restore $gp.  It is only safe to split the load\n    from the call when every use of $gp is explicit.  */\n \n #define TARGET_SPLIT_CALLS \\\n-  (TARGET_EXPLICIT_RELOCS && TARGET_ABICALLS && !TARGET_NEWABI)\n+  (TARGET_EXPLICIT_RELOCS && TARGET_CALL_CLOBBERED_GP)\n \n /* True if we're generating a form of -mabicalls in which we can use\n    operators like %hi and %lo to refer to locally-binding symbols.\n@@ -173,12 +172,22 @@ extern const struct mips_rtx_cost_data *mips_cost;\n \tusing sibling calls in this case anyway; they would usually\n \tbe longer than normal calls.\n \n-      - TARGET_ABICALLS && !TARGET_EXPLICIT_RELOCS.  call_insn_operand\n-\taccepts global constants, but \"jr $25\" is the only allowed\n-\tsibcall.  */\n-\n+      - TARGET_USE_GOT && !TARGET_EXPLICIT_RELOCS.  call_insn_operand\n+\taccepts global constants, but all sibcalls must be indirect.  */\n #define TARGET_SIBCALLS \\\n-  (!TARGET_MIPS16 && (!TARGET_ABICALLS || TARGET_EXPLICIT_RELOCS))\n+  (!TARGET_MIPS16 && (!TARGET_USE_GOT || TARGET_EXPLICIT_RELOCS))\n+\n+/* True if we need to use a global offset table to access some symbols.  */\n+#define TARGET_USE_GOT TARGET_ABICALLS\n+\n+/* True if TARGET_USE_GOT and if $gp is a call-clobbered register.  */\n+#define TARGET_CALL_CLOBBERED_GP (TARGET_ABICALLS && TARGET_OLDABI)\n+\n+/* True if TARGET_USE_GOT and if $gp is a call-saved register.  */\n+#define TARGET_CALL_SAVED_GP (TARGET_USE_GOT && !TARGET_CALL_CLOBBERED_GP)\n+\n+/* True if indirect calls must use register class PIC_FN_ADDR_REG.  */\n+#define TARGET_USE_PIC_FN_ADDR_REG TARGET_ABICALLS\n \n /* True if .gpword or .gpdword should be used for switch tables.\n \n@@ -1746,8 +1755,7 @@ extern const enum reg_class mips_regno_to_class[];\n   ((flag_profile_values && ! TARGET_64BIT\t\t\t\t\\\n     ? MAX (REG_PARM_STACK_SPACE(NULL), current_function_outgoing_args_size) \\\n     : current_function_outgoing_args_size)\t\t\t\t\\\n-   + (TARGET_ABICALLS && !TARGET_NEWABI\t\t\t\t\t\\\n-      ? MIPS_STACK_ALIGN (UNITS_PER_WORD) : 0))\n+   + (TARGET_CALL_CLOBBERED_GP ? MIPS_STACK_ALIGN (UNITS_PER_WORD) : 0))\n \n #define RETURN_ADDR_RTX mips_return_addr\n \n@@ -2301,13 +2309,13 @@ typedef struct mips_args {\n    (\"j\" or \"jal\"), OPERANDS are its operands, and OPNO is the operand number\n    of the target.\n \n-   When generating -mabicalls without explicit relocation operators,\n+   When generating GOT code without explicit relocation operators,\n    all calls should use assembly macros.  Otherwise, all indirect\n    calls should use \"jr\" or \"jalr\"; we will arrange to restore $gp\n    afterwards if necessary.  Finally, we can only generate direct\n    calls for -mabicalls by temporarily switching to non-PIC mode.  */\n #define MIPS_CALL(INSN, OPERANDS, OPNO)\t\t\t\t\\\n-  (TARGET_ABICALLS && !TARGET_EXPLICIT_RELOCS\t\t\t\\\n+  (TARGET_USE_GOT && !TARGET_EXPLICIT_RELOCS\t\t\t\\\n    ? \"%*\" INSN \"\\t%\" #OPNO \"%/\"\t\t\t\t\t\\\n    : REG_P (OPERANDS[OPNO])\t\t\t\t\t\\\n    ? \"%*\" INSN \"r\\t%\" #OPNO \"%/\"\t\t\t\t\\"}, {"sha": "7aa3dae4927729930c90d45447b536ea6e5b150a", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14976818e723aedf177bdd090fdd3ecb246e908d/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14976818e723aedf177bdd090fdd3ecb246e908d/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=14976818e723aedf177bdd090fdd3ecb246e908d", "patch": "@@ -221,15 +221,16 @@\n ;; This attribute is YES if the instruction is a jal macro (not a\n ;; real jal instruction).\n ;;\n-;; jal is always a macro for o32 and o64 abicalls because it includes an\n-;; instruction to restore $gp.  Direct jals are also macros for -mshared\n-;; abicalls because they first load the target address into $25.\n+;; jal is always a macro for TARGET_CALL_CLOBBERED_GP because it includes\n+;; an instruction to restore $gp.  Direct jals are also macros for\n+;; flag_pic && !TARGET_ABSOLUTE_ABICALLS because they first load\n+;; the target address into a register.\n (define_attr \"jal_macro\" \"no,yes\"\n   (cond [(eq_attr \"jal\" \"direct\")\n-\t (symbol_ref \"TARGET_ABICALLS\n-\t\t      && (TARGET_OLDABI || !TARGET_ABSOLUTE_ABICALLS)\")\n+\t (symbol_ref \"TARGET_CALL_CLOBBERED_GP\n+\t\t      || (flag_pic && !TARGET_ABSOLUTE_ABICALLS)\")\n \t (eq_attr \"jal\" \"indirect\")\n-\t (symbol_ref \"TARGET_ABICALLS && TARGET_OLDABI\")]\n+\t (symbol_ref \"TARGET_CALL_CLOBBERED_GP\")]\n \t(const_string \"no\")))\n \n ;; Classification of each insn.\n@@ -4947,14 +4948,14 @@\n   [(set_attr \"type\" \"jump\")\n    (set_attr \"mode\" \"none\")])\n \n-;; For TARGET_ABICALLS, we save the gp in the jmp_buf as well.\n+;; For TARGET_USE_GOT, we save the gp in the jmp_buf as well.\n ;; While it is possible to either pull it off the stack (in the\n ;; o32 case) or recalculate it given t9 and our target label,\n ;; it takes 3 or 4 insns to do so.\n \n (define_expand \"builtin_setjmp_setup\"\n   [(use (match_operand 0 \"register_operand\"))]\n-  \"TARGET_ABICALLS\"\n+  \"TARGET_USE_GOT\"\n {\n   rtx addr;\n \n@@ -4969,7 +4970,7 @@\n \n (define_expand \"builtin_longjmp\"\n   [(use (match_operand 0 \"register_operand\"))]\n-  \"TARGET_ABICALLS\"\n+  \"TARGET_USE_GOT\"\n {\n   /* The elements of the buffer are, in order:  */\n   int W = GET_MODE_SIZE (Pmode);\n@@ -5105,7 +5106,7 @@\n (define_insn_and_split \"exception_receiver\"\n   [(set (reg:SI 28)\n \t(unspec_volatile:SI [(const_int 0)] UNSPEC_EH_RECEIVER))]\n-  \"TARGET_ABICALLS && TARGET_OLDABI\"\n+  \"TARGET_CALL_CLOBBERED_GP\"\n   \"#\"\n   \"&& reload_completed\"\n   [(const_int 0)]\n@@ -5143,7 +5144,7 @@\n \t\t   (match_operand:P 2 \"immediate_operand\" \"\")\n \t\t   (reg:P FAKE_CALL_REGNO)]\n \t\t  UNSPEC_LOAD_CALL))]\n-  \"TARGET_ABICALLS\"\n+  \"TARGET_USE_GOT\"\n   \"<load>\\t%0,%R2(%1)\"\n   [(set_attr \"type\" \"load\")\n    (set_attr \"mode\" \"<MODE>\")\n@@ -5157,9 +5158,10 @@\n ;; constraints.\n \n ;; When we use an indirect jump, we need a register that will be\n-;; preserved by the epilogue.  Since TARGET_ABICALLS forces us to\n-;; use $25 for this purpose -- and $25 is never clobbered by the\n-;; epilogue -- we might as well use it for !TARGET_ABICALLS as well.\n+;; preserved by the epilogue.  Since TARGET_USE_PIC_FN_ADDR_REG forces\n+;; us to use $25 for this purpose -- and $25 is never clobbered by the\n+;; epilogue -- we might as well use it for !TARGET_USE_PIC_FN_ADDR_REG\n+;; as well.\n \n (define_expand \"sibcall\"\n   [(parallel [(call (match_operand 0 \"\")"}]}