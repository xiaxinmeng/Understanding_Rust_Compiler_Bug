{"sha": "420672bc92e560bcebf12bdd1f3423362c93bf2e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDIwNjcyYmM5MmU1NjBiY2ViZjEyYmRkMWYzNDIzMzYyYzkzYmYyZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2018-10-26T07:20:01Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2018-10-26T07:20:01Z"}, "message": "ipa-devirt.c (warn_odr): Make static.\n\n\n\t* ipa-devirt.c (warn_odr): Make static.\n\t(types_same_for_odr): Drop strict variant.\n\t(types_odr_comparable): Likewise.\n\t(odr_or_derived_type_p): Look for main variants.\n\t(odr_name_hasher::equal): Cleanup comment.\n\t(odr_subtypes_equivalent): Add warn and warned arguments; check main\n\tvariants.\n\t(type_variants_equivalent_p): break out from ...\n\t(odr_types_equivalent): ... here; go for main variants where needed.\n\t(warn_odr): ... here; turn static.\n\t(warn_types_mismatch): Compare mangled names of main variants.\n\t* ipa-utils.h (types_odr_comparable): Drop strict parameter.\n\t(type_with_linkage_p): Sanity check that we look at main variant.\n\t* lto.c (lto_read_decls): Only consider main variant to be ODR type.\n\t* tree.h (types_same_for_odr): Drop strict argument.\n\nFrom-SVN: r265519", "tree": {"sha": "e87d7b82e66cbef3db48d8aa3b1869ae4fe53d64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e87d7b82e66cbef3db48d8aa3b1869ae4fe53d64"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/420672bc92e560bcebf12bdd1f3423362c93bf2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/420672bc92e560bcebf12bdd1f3423362c93bf2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/420672bc92e560bcebf12bdd1f3423362c93bf2e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/420672bc92e560bcebf12bdd1f3423362c93bf2e/comments", "author": null, "committer": null, "parents": [{"sha": "99976e2700062d03a06412a92b345741f735deff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99976e2700062d03a06412a92b345741f735deff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99976e2700062d03a06412a92b345741f735deff"}], "stats": {"total": 230, "additions": 138, "deletions": 92}, "files": [{"sha": "87e79471af8e6c33b02d3fb62d749c53a6f72cf0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/420672bc92e560bcebf12bdd1f3423362c93bf2e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/420672bc92e560bcebf12bdd1f3423362c93bf2e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=420672bc92e560bcebf12bdd1f3423362c93bf2e", "patch": "@@ -1,3 +1,21 @@\n+2018-10-26  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-devirt.c (warn_odr): Make static.\n+\t(types_same_for_odr): Drop strict variant.\n+\t(types_odr_comparable): Likewise.\n+\t(odr_or_derived_type_p): Look for main variants.\n+\t(odr_name_hasher::equal): Cleanup comment.\n+\t(odr_subtypes_equivalent): Add warn and warned arguments; check main\n+\tvariants.\n+\t(type_variants_equivalent_p): break out from ...\n+\t(odr_types_equivalent): ... here; go for main variants where needed.\n+\t(warn_odr): ... here; turn static.\n+\t(warn_types_mismatch): Compare mangled names of main variants.\n+\t* ipa-utils.h (types_odr_comparable): Drop strict parameter.\n+\t(type_with_linkage_p): Sanity check that we look at main variant.\n+\t* lto.c (lto_read_decls): Only consider main variant to be ODR type.\n+\t* tree.h (types_same_for_odr): Drop strict argument.\n+\n 2018-10-26  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/87746"}, {"sha": "df880fe4145cced2c98e6c92ed752b1c182ab277", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 116, "deletions": 88, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/420672bc92e560bcebf12bdd1f3423362c93bf2e/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/420672bc92e560bcebf12bdd1f3423362c93bf2e/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=420672bc92e560bcebf12bdd1f3423362c93bf2e", "patch": "@@ -175,6 +175,8 @@ struct default_hash_traits <type_pair>\n static bool odr_types_equivalent_p (tree, tree, bool, bool *,\n \t\t\t\t    hash_set<type_pair> *,\n \t\t\t\t    location_t, location_t);\n+static void warn_odr (tree t1, tree t2, tree st1, tree st2,\n+\t\t      bool warn, bool *warned, const char *reason);\n \n static bool odr_violation_reported = false;\n \n@@ -381,22 +383,15 @@ odr_vtable_hasher::hash (const odr_type_d *odr_type)\n \n    Until we start streaming mangled type names, this function works\n    only for polymorphic types.\n-\n-   When STRICT is true, we compare types by their names for purposes of\n-   ODR violation warnings.  When strict is false, we consider variants\n-   equivalent, because it is all that matters for devirtualization machinery.\n */\n \n bool\n-types_same_for_odr (const_tree type1, const_tree type2, bool strict)\n+types_same_for_odr (const_tree type1, const_tree type2)\n {\n   gcc_checking_assert (TYPE_P (type1) && TYPE_P (type2));\n \n-  if (!strict)\n-    {\n-      type1 = TYPE_MAIN_VARIANT (type1);\n-      type2 = TYPE_MAIN_VARIANT (type2);\n-    }\n+  type1 = TYPE_MAIN_VARIANT (type1);\n+  type2 = TYPE_MAIN_VARIANT (type2);\n \n   if (type1 == type2)\n     return true;\n@@ -470,17 +465,15 @@ types_same_for_odr (const_tree type1, const_tree type2, bool strict)\n /* Return true if we can decide on ODR equivalency.\n \n    In non-LTO it is always decide, in LTO however it depends in the type has\n-   ODR info attached.\n-\n-   When STRICT is false, compare main variants.  */\n+   ODR info attached. */\n \n bool\n-types_odr_comparable (tree t1, tree t2, bool strict)\n+types_odr_comparable (tree t1, tree t2)\n {\n   return (!in_lto_p\n-\t  || t1 == t2\n-\t  || (!strict && TYPE_MAIN_VARIANT (t1) == TYPE_MAIN_VARIANT (t2))\n-\t  || (odr_type_p (t1) && odr_type_p (t2))\n+\t  || TYPE_MAIN_VARIANT (t1) == TYPE_MAIN_VARIANT (t2)\n+\t  || (odr_type_p (TYPE_MAIN_VARIANT (t1))\n+\t      && odr_type_p (TYPE_MAIN_VARIANT (t2)))\n \t  || (TREE_CODE (t1) == RECORD_TYPE && TREE_CODE (t2) == RECORD_TYPE\n \t      && TYPE_BINFO (t1) && TYPE_BINFO (t2)\n \t      && polymorphic_type_binfo_p (TYPE_BINFO (t1))\n@@ -525,7 +518,7 @@ odr_or_derived_type_p (const_tree t)\n {\n   do\n     {\n-      if (odr_type_p (t))\n+      if (odr_type_p (TYPE_MAIN_VARIANT (t)))\n \treturn true;\n       /* Function type is a tricky one. Basically we can consider it\n \t ODR derived if return type or any of the parameters is.\n@@ -540,7 +533,7 @@ odr_or_derived_type_p (const_tree t)\n \t     if (TREE_TYPE (t) && odr_or_derived_type_p (TREE_TYPE (t)))\n \t       return true;\n \t     for (t = TYPE_ARG_TYPES (t); t; t = TREE_CHAIN (t))\n-\t       if (odr_or_derived_type_p (TREE_VALUE (t)))\n+\t       if (odr_or_derived_type_p (TYPE_MAIN_VARIANT (TREE_VALUE (t))))\n \t\t return true;\n \t     return false;\n \t   }\n@@ -566,8 +559,7 @@ odr_name_hasher::equal (const odr_type_d *o1, const tree_node *t2)\n     return true;\n   if (!in_lto_p)\n     return false;\n-  /* Check for anonymous namespaces. Those have !TREE_PUBLIC\n-     on the corresponding TYPE_STUB_DECL.  */\n+  /* Check for anonymous namespaces.  */\n   if ((type_with_linkage_p (t1) && type_in_anonymous_namespace_p (t1))\n       || (type_with_linkage_p (t2) && type_in_anonymous_namespace_p (t2)))\n     return false;\n@@ -639,10 +631,45 @@ set_type_binfo (tree type, tree binfo)\n       gcc_assert (!TYPE_BINFO (type));\n }\n \n+/* Return true if type variants match.\n+   This assumes that we already verified that T1 and T2 are variants of the\n+   same type.  */\n+\n+static bool\n+type_variants_equivalent_p (tree t1, tree t2, bool warn, bool *warned)\n+{\n+  if (TYPE_QUALS (t1) != TYPE_QUALS (t2))\n+    {\n+      warn_odr (t1, t2, NULL, NULL, warn, warned,\n+\t        G_(\"a type with different qualifiers is defined in another \"\n+\t\t   \"translation unit\"));\n+      return false;\n+    }\n+\n+  if (comp_type_attributes (t1, t2) != 1)\n+    {\n+      warn_odr (t1, t2, NULL, NULL, warn, warned,\n+\t        G_(\"a type with different attributes \"\n+\t\t   \"is defined in another translation unit\"));\n+      return false;\n+    }\n+\n+  if (COMPLETE_TYPE_P (t1) && COMPLETE_TYPE_P (t2)\n+      && TYPE_ALIGN (t1) != TYPE_ALIGN (t2))\n+    {\n+      warn_odr (t1, t2, NULL, NULL, warn, warned,\n+\t\tG_(\"a type with different alignment \"\n+\t\t   \"is defined in another translation unit\"));\n+      return false;\n+    }\n+\n+  return true;\n+}\n+\n /* Compare T1 and T2 based on name or structure.  */\n \n static bool\n-odr_subtypes_equivalent_p (tree t1, tree t2,\n+odr_subtypes_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n \t\t\t   hash_set<type_pair> *visited,\n \t\t\t   location_t loc1, location_t loc2)\n {\n@@ -654,20 +681,25 @@ odr_subtypes_equivalent_p (tree t1, tree t2,\n     return true;\n \n   /* Anonymous namespace types must match exactly.  */\n-  if ((type_with_linkage_p (t1) && type_in_anonymous_namespace_p (t1))\n-      || (type_with_linkage_p (t2) && type_in_anonymous_namespace_p (t2)))\n+  if ((type_with_linkage_p (TYPE_MAIN_VARIANT (t1))\n+       && type_in_anonymous_namespace_p (TYPE_MAIN_VARIANT (t1)))\n+      || (type_with_linkage_p (TYPE_MAIN_VARIANT (t2))\n+\t  && type_in_anonymous_namespace_p (TYPE_MAIN_VARIANT (t2))))\n     return false;\n \n   /* For ODR types be sure to compare their names.\n      To support -Wno-odr-type-merging we allow one type to be non-ODR\n      and other ODR even though it is a violation.  */\n-  if (types_odr_comparable (t1, t2, true))\n+  if (types_odr_comparable (t1, t2))\n     {\n-      if (!types_same_for_odr (t1, t2, true))\n+      if (!types_same_for_odr (t1, t2))\n         return false;\n+      if (!type_variants_equivalent_p (t1, t2, warn, warned))\n+\treturn false;\n       /* Limit recursion: If subtypes are ODR types and we know\n \t that they are same, be happy.  */\n-      if (!odr_type_p (t1) || !get_odr_type (t1, true)->odr_violated)\n+      if (!odr_type_p (TYPE_MAIN_VARIANT (t1))\n+\t  || !get_odr_type (TYPE_MAIN_VARIANT (t1), true)->odr_violated)\n         return true;\n     }\n \n@@ -679,15 +711,19 @@ odr_subtypes_equivalent_p (tree t1, tree t2,\n       && (TYPE_NAME (t1) == NULL_TREE) != (TYPE_NAME (t2) == NULL_TREE))\n     return false;\n \n-  type_pair pair={t1,t2};\n-  if (TYPE_UID (t1) > TYPE_UID (t2))\n+  type_pair pair={TYPE_MAIN_VARIANT (t1), TYPE_MAIN_VARIANT (t2)};\n+  if (TYPE_UID (TYPE_MAIN_VARIANT (t1)) > TYPE_UID (TYPE_MAIN_VARIANT (t2)))\n     {\n-      pair.first = t2;\n-      pair.second = t1;\n+      pair.first = TYPE_MAIN_VARIANT (t2);\n+      pair.second = TYPE_MAIN_VARIANT (t1);\n     }\n   if (visited->add (pair))\n     return true;\n-  return odr_types_equivalent_p (t1, t2, false, NULL, visited, loc1, loc2);\n+  if (odr_types_equivalent_p (TYPE_MAIN_VARIANT (t1), TYPE_MAIN_VARIANT (t2),\n+\t\t\t      false, NULL, visited, loc1, loc2)\n+      && !type_variants_equivalent_p (t1, t2, warn, warned))\n+    return false;\n+  return true;\n }\n \n /* Return true if DECL1 and DECL2 are identical methods.  Consider\n@@ -959,7 +995,7 @@ compare_virtual_tables (varpool_node *prevailing, varpool_node *vtable)\n    If WARN is false, do nothing. Set WARNED if warning was indeed\n    output.  */\n \n-void\n+static void\n warn_odr (tree t1, tree t2, tree st1, tree st2,\n \t  bool warn, bool *warned, const char *reason)\n {\n@@ -1083,21 +1119,29 @@ warn_types_mismatch (tree t1, tree t2, location_t loc1, location_t loc2)\n \n   /* It is a quite common bug to reference anonymous namespace type in\n      non-anonymous namespace class.  */\n-  if ((type_with_linkage_p (t1) && type_in_anonymous_namespace_p (t1))\n-      || (type_with_linkage_p (t2) && type_in_anonymous_namespace_p (t2)))\n+  if ((type_with_linkage_p (TYPE_MAIN_VARIANT (t1))\n+       && type_in_anonymous_namespace_p (TYPE_MAIN_VARIANT (t1)))\n+      || (type_with_linkage_p (TYPE_MAIN_VARIANT (t2))\n+\t  && type_in_anonymous_namespace_p (TYPE_MAIN_VARIANT (t2))))\n     {\n-      if (type_with_linkage_p (t1) && !type_in_anonymous_namespace_p (t1))\n+      if (type_with_linkage_p (TYPE_MAIN_VARIANT (t1))\n+\t  && !type_in_anonymous_namespace_p (TYPE_MAIN_VARIANT (t1)))\n \t{\n \t  std::swap (t1, t2);\n \t  std::swap (loc_t1, loc_t2);\n \t}\n       gcc_assert (TYPE_NAME (t1) && TYPE_NAME (t2)\n \t\t  && TREE_CODE (TYPE_NAME (t1)) == TYPE_DECL\n \t\t  && TREE_CODE (TYPE_NAME (t2)) == TYPE_DECL);\n+      tree n1 = TYPE_NAME (t1);\n+      tree n2 = TYPE_NAME (t2);\n+      if (TREE_CODE (n1) == TYPE_DECL)\n+\tn1 = DECL_NAME (n1);\n+      if (TREE_CODE (n2) == TYPE_DECL)\n+\tn1 = DECL_NAME (n2);\n       /* Most of the time, the type names will match, do not be unnecesarily\n          verbose.  */\n-      if (IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (t1)))\n-\t  != IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (t2))))\n+      if (IDENTIFIER_POINTER (n1) != IDENTIFIER_POINTER (n2))\n         inform (loc_t1,\n \t        \"type %qT defined in anonymous namespace can not match \"\n \t        \"type %qT across the translation unit boundary\",\n@@ -1112,22 +1156,24 @@ warn_types_mismatch (tree t1, tree t2, location_t loc1, location_t loc2)\n \t        \"the incompatible type defined in another translation unit\");\n       return;\n     }\n+  tree mt1 = TYPE_MAIN_VARIANT (t1);\n+  tree mt2 = TYPE_MAIN_VARIANT (t2);\n   /* If types have mangled ODR names and they are different, it is most\n      informative to output those.\n      This also covers types defined in different namespaces.  */\n-  if (TYPE_NAME (t1) && TYPE_NAME (t2)\n-      && TREE_CODE (TYPE_NAME (t1)) == TYPE_DECL\n-      && TREE_CODE (TYPE_NAME (t2)) == TYPE_DECL\n-      && DECL_ASSEMBLER_NAME_SET_P (TYPE_NAME (t1))\n-      && DECL_ASSEMBLER_NAME_SET_P (TYPE_NAME (t2))\n-      && DECL_ASSEMBLER_NAME (TYPE_NAME (t1))\n-\t != DECL_ASSEMBLER_NAME (TYPE_NAME (t2)))\n+  if (TYPE_NAME (mt1) && TYPE_NAME (mt2)\n+      && TREE_CODE (TYPE_NAME (mt1)) == TYPE_DECL\n+      && TREE_CODE (TYPE_NAME (mt2)) == TYPE_DECL\n+      && DECL_ASSEMBLER_NAME_SET_P (TYPE_NAME (mt1))\n+      && DECL_ASSEMBLER_NAME_SET_P (TYPE_NAME (mt2))\n+      && DECL_ASSEMBLER_NAME (TYPE_NAME (mt1))\n+\t != DECL_ASSEMBLER_NAME (TYPE_NAME (mt2)))\n     {\n       char *name1 = xstrdup (cplus_demangle\n-\t (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (TYPE_NAME (t1))),\n+\t (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (TYPE_NAME (mt1))),\n \t  DMGL_PARAMS | DMGL_ANSI | DMGL_TYPES));\n       char *name2 = cplus_demangle\n-\t (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (TYPE_NAME (t2))),\n+\t (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (TYPE_NAME (mt2))),\n \t  DMGL_PARAMS | DMGL_ANSI | DMGL_TYPES);\n       if (name1 && name2 && strcmp (name1, name2))\n \t{\n@@ -1216,8 +1262,8 @@ warn_types_mismatch (tree t1, tree t2, location_t loc1, location_t loc2)\n       return;\n     }\n \n-  if (types_odr_comparable (t1, t2, true)\n-      && types_same_for_odr (t1, t2, true))\n+  if (types_odr_comparable (t1, t2)\n+      && types_same_for_odr (t1, t2))\n     inform (loc_t1,\n \t    \"type %qT itself violates the C++ One Definition Rule\", t1);\n   /* Prevent pointless warnings like \"struct aa\" should match \"struct aa\".  */\n@@ -1246,8 +1292,10 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n   /* Check first for the obvious case of pointer identity.  */\n   if (t1 == t2)\n     return true;\n-  gcc_assert (!type_with_linkage_p (t1) || !type_in_anonymous_namespace_p (t1));\n-  gcc_assert (!type_with_linkage_p (t2) || !type_in_anonymous_namespace_p (t2));\n+  gcc_assert (!type_with_linkage_p (TYPE_MAIN_VARIANT (t1))\n+\t      || !type_in_anonymous_namespace_p (TYPE_MAIN_VARIANT (t1)));\n+  gcc_assert (!type_with_linkage_p (TYPE_MAIN_VARIANT (t2))\n+\t      || !type_in_anonymous_namespace_p (TYPE_MAIN_VARIANT (t2)));\n \n   /* Can't be the same type if the types don't have the same code.  */\n   if (TREE_CODE (t1) != TREE_CODE (t2))\n@@ -1257,16 +1305,10 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n       return false;\n     }\n \n-  if (TYPE_QUALS (t1) != TYPE_QUALS (t2))\n-    {\n-      warn_odr (t1, t2, NULL, NULL, warn, warned,\n-\t        G_(\"a type with different qualifiers is defined in another \"\n-\t\t   \"translation unit\"));\n-      return false;\n-    }\n-\n-  if ((type_with_linkage_p (t1) && type_in_anonymous_namespace_p (t1))\n-      || (type_with_linkage_p (t2) && type_in_anonymous_namespace_p (t2)))\n+  if ((type_with_linkage_p (TYPE_MAIN_VARIANT (t1))\n+       && type_in_anonymous_namespace_p (TYPE_MAIN_VARIANT (t1)))\n+      || (type_with_linkage_p (TYPE_MAIN_VARIANT (t2))\n+\t  && type_in_anonymous_namespace_p (TYPE_MAIN_VARIANT (t2))))\n     {\n       /* We can not trip this when comparing ODR types, only when trying to\n \t match different ODR derivations from different declarations.\n@@ -1275,14 +1317,6 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n       return false;\n     }\n \n-  if (comp_type_attributes (t1, t2) != 1)\n-    {\n-      warn_odr (t1, t2, NULL, NULL, warn, warned,\n-\t        G_(\"a type with different attributes \"\n-\t\t   \"is defined in another translation unit\"));\n-      return false;\n-    }\n-\n   if (TREE_CODE (t1) == ENUMERAL_TYPE\n       && TYPE_VALUES (t1) && TYPE_VALUES (t2))\n     {\n@@ -1366,7 +1400,7 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n \t    }\n \n \t  if (!odr_subtypes_equivalent_p (TREE_TYPE (t1), TREE_TYPE (t2),\n-\t\t\t\t\t  visited, loc1, loc2))\n+\t\t\t\t\t  warn, warned, visited, loc1, loc2))\n \t    {\n \t      warn_odr (t1, t2, NULL, NULL, warn, warned,\n \t\t\tG_(\"it is defined as a pointer to different type \"\n@@ -1380,6 +1414,7 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n \n       if ((TREE_CODE (t1) == VECTOR_TYPE || TREE_CODE (t1) == COMPLEX_TYPE)\n \t  && !odr_subtypes_equivalent_p (TREE_TYPE (t1), TREE_TYPE (t2),\n+\t\t\t\t\t warn, warned,\n \t\t\t\t\t visited, loc1, loc2))\n \t{\n \t  /* Probably specific enough.  */\n@@ -1399,7 +1434,7 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n \t/* Array types are the same if the element types are the same and\n \t   the number of elements are the same.  */\n \tif (!odr_subtypes_equivalent_p (TREE_TYPE (t1), TREE_TYPE (t2),\n-\t\t\t\t\tvisited, loc1, loc2))\n+\t\t\t\t\twarn, warned, visited, loc1, loc2))\n \t  {\n \t    warn_odr (t1, t2, NULL, NULL, warn, warned,\n \t\t      G_(\"a different type is defined in another \"\n@@ -1417,7 +1452,7 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n \t/* For an incomplete external array, the type domain can be\n \t   NULL_TREE.  Check this condition also.  */\n \tif (i1 == NULL_TREE || i2 == NULL_TREE)\n-\t  return true;\n+          return type_variants_equivalent_p (t1, t2, warn, warned);\n \n \ttree min1 = TYPE_MIN_VALUE (i1);\n \ttree min2 = TYPE_MIN_VALUE (i2);\n@@ -1441,7 +1476,7 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n       /* Function types are the same if the return type and arguments types\n \t are the same.  */\n       if (!odr_subtypes_equivalent_p (TREE_TYPE (t1), TREE_TYPE (t2),\n-\t\t\t\t      visited, loc1, loc2))\n+\t\t\t\t      warn, warned, visited, loc1, loc2))\n \t{\n \t  warn_odr (t1, t2, NULL, NULL, warn, warned,\n \t\t    G_(\"has different return value \"\n@@ -1453,7 +1488,7 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n \n       if (TYPE_ARG_TYPES (t1) == TYPE_ARG_TYPES (t2)\n \t  || !prototype_p (t1) || !prototype_p (t2))\n-\treturn true;\n+        return type_variants_equivalent_p (t1, t2, warn, warned);\n       else\n \t{\n \t  tree parms1, parms2;\n@@ -1463,8 +1498,8 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n \t       parms1 = TREE_CHAIN (parms1), parms2 = TREE_CHAIN (parms2))\n \t    {\n \t      if (!odr_subtypes_equivalent_p\n-\t\t     (TREE_VALUE (parms1), TREE_VALUE (parms2), visited,\n-\t\t      loc1, loc2))\n+\t\t     (TREE_VALUE (parms1), TREE_VALUE (parms2), warn, warned,\n+\t\t      visited, loc1, loc2))\n \t\t{\n \t\t  warn_odr (t1, t2, NULL, NULL, warn, warned,\n \t\t\t    G_(\"has different parameters in another \"\n@@ -1484,7 +1519,7 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n \t      return false;\n \t    }\n \n-\t  return true;\n+          return type_variants_equivalent_p (t1, t2, warn, warned);\n \t}\n \n     case RECORD_TYPE:\n@@ -1544,8 +1579,8 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n \t\t    return false;\n \t\t  }\n \t\tif (!odr_subtypes_equivalent_p (TREE_TYPE (f1),\n-\t\t\t\t\t\tTREE_TYPE (f2), visited,\n-\t\t\t\t\t\tloc1, loc2))\n+\t\t\t\t\t\tTREE_TYPE (f2), warn, warned,\n+\t\t\t\t\t\tvisited, loc1, loc2))\n \t\t  {\n \t\t    /* Do not warn about artificial fields and just go into\n  \t\t       generic field mismatch warning.  */\n@@ -1622,18 +1657,11 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n \t\t   \"is defined in another translation unit\"));\n       return false;\n     }\n-  if (COMPLETE_TYPE_P (t1) && COMPLETE_TYPE_P (t2)\n-      && TYPE_ALIGN (t1) != TYPE_ALIGN (t2))\n-    {\n-      warn_odr (t1, t2, NULL, NULL, warn, warned,\n-\t\tG_(\"a type with different alignment \"\n-\t\t   \"is defined in another translation unit\"));\n-      return false;\n-    }\n+\n   gcc_assert (!TYPE_SIZE_UNIT (t1) || !TYPE_SIZE_UNIT (t2)\n \t      || operand_equal_p (TYPE_SIZE_UNIT (t1),\n \t\t\t\t  TYPE_SIZE_UNIT (t2), 0));\n-  return true;\n+  return type_variants_equivalent_p (t1, t2, warn, warned);\n }\n \n /* Return true if TYPE1 and TYPE2 are equivalent for One Definition Rule.  */"}, {"sha": "371b2fbdb98b71a59f02b61fcd8cae1f9017ce83", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/420672bc92e560bcebf12bdd1f3423362c93bf2e/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/420672bc92e560bcebf12bdd1f3423362c93bf2e/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=420672bc92e560bcebf12bdd1f3423362c93bf2e", "patch": "@@ -83,7 +83,7 @@ bool type_known_to_have_no_derivations_p (tree);\n bool contains_polymorphic_type_p (const_tree);\n void register_odr_type (tree);\n bool types_must_be_same_for_odr (tree, tree);\n-bool types_odr_comparable (tree, tree, bool strict = false);\n+bool types_odr_comparable (tree, tree);\n cgraph_node *try_speculative_devirtualization (tree, HOST_WIDE_INT,\n \t\t\t\t\t       ipa_polymorphic_call_context);\n void warn_types_mismatch (tree t1, tree t2, location_t loc1 = UNKNOWN_LOCATION,\n@@ -179,6 +179,7 @@ polymorphic_type_binfo_p (const_tree binfo)\n inline bool\n type_with_linkage_p (const_tree t)\n {\n+  gcc_checking_assert (TYPE_MAIN_VARIANT (t) == t);\n   if (!TYPE_NAME (t) || TREE_CODE (TYPE_NAME (t)) != TYPE_DECL)\n     return false;\n "}, {"sha": "2d52d4a8f4e34affef63c5221ba449906b355ad7", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/420672bc92e560bcebf12bdd1f3423362c93bf2e/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/420672bc92e560bcebf12bdd1f3423362c93bf2e/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=420672bc92e560bcebf12bdd1f3423362c93bf2e", "patch": "@@ -1827,7 +1827,7 @@ lto_read_decls (struct lto_file_decl_data *decl_data, const void *data,\n \t\t     type canonical of a derived type in the same SCC.  */\n \t\t  if (!TYPE_CANONICAL (t))\n \t\t    gimple_register_canonical_type (t);\n-\t\t  if (odr_type_p (t))\n+\t\t  if (TYPE_MAIN_VARIANT (t) == t && odr_type_p (t))\n \t\t    odr_types.safe_push (t);\n \t\t}\n \t      /* Link shared INTEGER_CSTs into TYPE_CACHED_VALUEs of its"}, {"sha": "0ef96ba561285406e4e3e7aceb5fd1ab58ca9d56", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/420672bc92e560bcebf12bdd1f3423362c93bf2e/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/420672bc92e560bcebf12bdd1f3423362c93bf2e/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=420672bc92e560bcebf12bdd1f3423362c93bf2e", "patch": "@@ -4958,8 +4958,7 @@ extern tree block_ultimate_origin (const_tree);\n extern tree get_binfo_at_offset (tree, poly_int64, tree);\n extern bool virtual_method_call_p (const_tree);\n extern tree obj_type_ref_class (const_tree ref);\n-extern bool types_same_for_odr (const_tree type1, const_tree type2,\n-\t\t\t\tbool strict=false);\n+extern bool types_same_for_odr (const_tree type1, const_tree type2);\n extern bool contains_bitfld_component_ref_p (const_tree);\n extern bool block_may_fallthru (const_tree);\n extern void using_eh_for_cleanups (void);"}]}