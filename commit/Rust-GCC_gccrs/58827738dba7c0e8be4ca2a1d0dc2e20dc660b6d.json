{"sha": "58827738dba7c0e8be4ca2a1d0dc2e20dc660b6d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTg4Mjc3MzhkYmE3YzBlOGJlNGNhMmExZDBkYzJlMjBkYzY2MGI2ZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-20T15:51:54Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-20T15:51:54Z"}, "message": "[multiple changes]\n\n2014-01-20  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_prag.adb (Analyze_Pragma): Ensure that\n\tthe sole argument of pragmas Abstract_State, Contract_Cases,\n\tDepends, Global and Initializes in in aggregate form.\n\t(Analyze_Refined_Pragma): Ensure that the sole argument of\n\tpragmas Refined_Depends, Refined_Global and Refined_State is in\n\taggregate form.\n\t(Ensure_Aggregate_Form): New routine.\n\n2014-01-20  Doug Rupp  <rupp@adacore.com>\n\n\t* sem_attr.adb (Analyze_Attribute): case\n\tAttribute_Constrained => treat all prefixes as legal for Declib\n\tcompatibility.\n\nFrom-SVN: r206836", "tree": {"sha": "2d58983b6c54ed0d1bc1a4d0f1f4dd0b6a8ba554", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2d58983b6c54ed0d1bc1a4d0f1f4dd0b6a8ba554"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/58827738dba7c0e8be4ca2a1d0dc2e20dc660b6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58827738dba7c0e8be4ca2a1d0dc2e20dc660b6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58827738dba7c0e8be4ca2a1d0dc2e20dc660b6d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58827738dba7c0e8be4ca2a1d0dc2e20dc660b6d/comments", "author": null, "committer": null, "parents": [{"sha": "9559eccf365a3bc6741ad2bad2916973fb41fbe6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9559eccf365a3bc6741ad2bad2916973fb41fbe6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9559eccf365a3bc6741ad2bad2916973fb41fbe6"}], "stats": {"total": 230, "additions": 165, "deletions": 65}, "files": [{"sha": "cd17e43350d49bb28e57bd621650861022d2c6e2", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58827738dba7c0e8be4ca2a1d0dc2e20dc660b6d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58827738dba7c0e8be4ca2a1d0dc2e20dc660b6d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=58827738dba7c0e8be4ca2a1d0dc2e20dc660b6d", "patch": "@@ -1,3 +1,19 @@\n+2014-01-20  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Pragma): Ensure that\n+\tthe sole argument of pragmas Abstract_State, Contract_Cases,\n+\tDepends, Global and Initializes in in aggregate form.\n+\t(Analyze_Refined_Pragma): Ensure that the sole argument of\n+\tpragmas Refined_Depends, Refined_Global and Refined_State is in\n+\taggregate form.\n+\t(Ensure_Aggregate_Form): New routine.\n+\n+2014-01-20  Doug Rupp  <rupp@adacore.com>\n+\n+\t* sem_attr.adb (Analyze_Attribute): case\n+\tAttribute_Constrained => treat all prefixes as legal for Declib\n+\tcompatibility.\n+\n 2014-01-20  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* sem_prag.adb (Check_Mode): Reimplement the routine."}, {"sha": "1750cc39680c1c50435678889088947c154b5dd8", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58827738dba7c0e8be4ca2a1d0dc2e20dc660b6d/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58827738dba7c0e8be4ca2a1d0dc2e20dc660b6d/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=58827738dba7c0e8be4ca2a1d0dc2e20dc660b6d", "patch": "@@ -3037,6 +3037,15 @@ package body Sem_Attr is\n               and then Extensions_Allowed\n             then\n                return;\n+\n+            --  For compatibility with Declib code, treat all prefixes as\n+            --  legal, including non-discriminated types.\n+\n+            --  ??? this non-conforming language extension needs documenting\n+            --  ??? anyway it should not depend on Extend_System!\n+\n+            elsif Present (System_Extend_Unit) then\n+               return;\n             end if;\n          end if;\n "}, {"sha": "097fb13fc0f9c3321eb0ff5a144ff171f0abebaf", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 140, "deletions": 65, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58827738dba7c0e8be4ca2a1d0dc2e20dc660b6d/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58827738dba7c0e8be4ca2a1d0dc2e20dc660b6d/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=58827738dba7c0e8be4ca2a1d0dc2e20dc660b6d", "patch": "@@ -1,4 +1,4 @@\n------------------------------------------------------------------------------\n+------------------------------------------------------------------------------\n --                                                                          --\n --                         GNAT COMPILER COMPONENTS                         --\n --                                                                          --\n@@ -449,39 +449,38 @@ package body Sem_Prag is\n       Subp_Id   := Defining_Entity (Subp_Decl);\n       All_Cases := Get_Pragma_Arg (First (Pragma_Argument_Associations (N)));\n \n-      --  Multiple contract cases appear in aggregate form\n-\n-      if Nkind (All_Cases) = N_Aggregate then\n-         if No (Component_Associations (All_Cases)) then\n-            Error_Msg_N (\"wrong syntax for aspect Contract_Cases\", N);\n+      --  Single and multiple contract cases must appear in aggregate form. If\n+      --  this is not the case, then either the parser of the analysis of the\n+      --  pragma failed to produce an aggregate.\n \n-         --  Individual contract cases appear as component associations\n+      pragma Assert (Nkind (All_Cases) = N_Aggregate);\n \n-         else\n-            --  Ensure that the formal parameters are visible when analyzing\n-            --  all clauses. This falls out of the general rule of aspects\n-            --  pertaining to subprogram declarations. Skip the installation\n-            --  for subprogram bodies because the formals are already visible.\n+      if No (Component_Associations (All_Cases)) then\n+         Error_Msg_N (\"wrong syntax for aspect Contract_Cases\", N);\n \n-            if not In_Open_Scopes (Subp_Id) then\n-               Restore_Scope := True;\n-               Push_Scope (Subp_Id);\n-               Install_Formals (Subp_Id);\n-            end if;\n+      --  Individual contract cases appear as component associations\n \n-            CCase := First (Component_Associations (All_Cases));\n-            while Present (CCase) loop\n-               Analyze_Contract_Case (CCase);\n-               Next (CCase);\n-            end loop;\n+      else\n+         --  Ensure that the formal parameters are visible when analyzing all\n+         --  clauses. This falls out of the general rule of aspects pertaining\n+         --  to subprogram declarations. Skip the installation for subprogram\n+         --  bodies because the formals are already visible.\n \n-            if Restore_Scope then\n-               End_Scope;\n-            end if;\n+         if not In_Open_Scopes (Subp_Id) then\n+            Restore_Scope := True;\n+            Push_Scope (Subp_Id);\n+            Install_Formals (Subp_Id);\n          end if;\n \n-      else\n-         Error_Msg_N (\"wrong syntax for aspect Contract_Cases\", N);\n+         CCase := First (Component_Associations (All_Cases));\n+         while Present (CCase) loop\n+            Analyze_Contract_Case (CCase);\n+            Next (CCase);\n+         end loop;\n+\n+         if Restore_Scope then\n+            End_Scope;\n+         end if;\n       end if;\n    end Analyze_Contract_Cases_In_Decl_Part;\n \n@@ -2577,32 +2576,26 @@ package body Sem_Prag is\n \n       Collect_States_And_Variables;\n \n-      --  Multiple initialization clauses appear as an aggregate\n+      --  Single and multiple initialization clauses must appear as an\n+      --  aggregate. If this is not the case, then either the parser of\n+      --  the analysis of the pragma failed to produce an aggregate.\n \n-      if Nkind (Inits) = N_Aggregate then\n-         if Present (Expressions (Inits)) then\n-            Init := First (Expressions (Inits));\n-            while Present (Init) loop\n-               Analyze_Initialization_Item (Init);\n-\n-               Next (Init);\n-            end loop;\n-         end if;\n+      pragma Assert (Nkind (Inits) = N_Aggregate);\n \n-         if Present (Component_Associations (Inits)) then\n-            Init := First (Component_Associations (Inits));\n-            while Present (Init) loop\n-               Analyze_Initialization_Item_With_Inputs (Init);\n-\n-               Next (Init);\n-            end loop;\n-         end if;\n-\n-      --  Various forms of a single initialization clause. Note that these may\n-      --  include malformed initializations.\n+      if Present (Expressions (Inits)) then\n+         Init := First (Expressions (Inits));\n+         while Present (Init) loop\n+            Analyze_Initialization_Item (Init);\n+            Next (Init);\n+         end loop;\n+      end if;\n \n-      else\n-         Analyze_Initialization_Item (Inits);\n+      if Present (Component_Associations (Inits)) then\n+         Init := First (Component_Associations (Inits));\n+         while Present (Init) loop\n+            Analyze_Initialization_Item_With_Inputs (Init);\n+            Next (Init);\n+         end loop;\n       end if;\n    end Analyze_Initializes_In_Decl_Part;\n \n@@ -2620,8 +2613,8 @@ package body Sem_Prag is\n       --  name may be different from the pragma name.\n \n       Pragma_Exit : exception;\n-      --  This exception is used to exit pragma processing completely. It is\n-      --  used when an error is detected, and no further processing is\n+      --  This exception is used to exit pragma processing completely. It\n+      --  is used when an error is detected, and no further processing is\n       --  required. It is also used if an earlier error has left the tree in\n       --  a state where the pragma should not be processed.\n \n@@ -2656,8 +2649,8 @@ package body Sem_Prag is\n       --  Subsidiary routine to the analysis of body pragmas Refined_Depends,\n       --  Refined_Global and Refined_Post. Check the placement and related\n       --  context of the pragma. Spec_Id is the entity of the related\n-      --  subprogram. Body_Id is the entity of the subprogram body. Flag Legal\n-      --  is set when the pragma is properly placed.\n+      --  subprogram. Body_Id is the entity of the subprogram body. Flag\n+      --  Legal is set when the pragma is properly placed.\n \n       procedure Check_Ada_83_Warning;\n       --  Issues a warning message for the current pragma if operating in Ada\n@@ -2910,6 +2903,12 @@ package body Sem_Prag is\n       --  presence of at least one component. UU_Typ is the related Unchecked_\n       --  Union type.\n \n+      procedure Ensure_Aggregate_Form (Arg : Node_Id);\n+      --  Subsidiary routine to the processing of pragmas Abstract_State,\n+      --  Contract_Cases, Depends, Global, Initializes, Refined_Depends,\n+      --  Refined_Global and Refined_State. Transform argument Arg into an\n+      --  aggregate if not one already. N_Null is never transformed.\n+\n       procedure Error_Pragma (Msg : String);\n       pragma No_Return (Error_Pragma);\n       --  Outputs error message for current pragma. The message contains a %\n@@ -2936,15 +2935,15 @@ package body Sem_Prag is\n \n       procedure Error_Pragma_Arg_Ident (Msg : String; Arg : Node_Id);\n       pragma No_Return (Error_Pragma_Arg_Ident);\n-      --  Outputs error message for current pragma. The message may contain\n-      --  a % that will be replaced with the pragma name. The parameter Arg\n-      --  must be a pragma argument association with a non-empty identifier\n-      --  (i.e. its Chars field must be set), and the error message is placed\n-      --  on the identifier. The message is placed using Error_Msg_N so\n-      --  the message may also contain an & insertion character which will\n-      --  reference the identifier. After placing the message, Pragma_Exit\n-      --  is raised. Note: this routine calls Fix_Error (see spec of that\n-      --  procedure for details).\n+      --  Outputs error message for current pragma. The message may contain a %\n+      --  that will be replaced with the pragma name. The parameter Arg must be\n+      --  a pragma argument association with a non-empty identifier (i.e. its\n+      --  Chars field must be set), and the error message is placed on the\n+      --  identifier. The message is placed using Error_Msg_N so the message\n+      --  may also contain an & insertion character which will reference\n+      --  the identifier. After placing the message, Pragma_Exit is raised.\n+      --  Note: this routine calls Fix_Error (see spec of that procedure for\n+      --  details).\n \n       procedure Error_Pragma_Ref (Msg : String; Ref : Entity_Id);\n       pragma No_Return (Error_Pragma_Ref);\n@@ -3221,6 +3220,13 @@ package body Sem_Prag is\n          Check_Arg_Count (1);\n          Check_No_Identifiers;\n \n+         if Nam_In (Pname, Name_Refined_Depends,\n+                           Name_Refined_Global,\n+                           Name_Refined_State)\n+         then\n+            Ensure_Aggregate_Form (Arg1);\n+         end if;\n+\n          --  Verify the placement of the pragma and check for duplicates. The\n          --  pragma must apply to a subprogram body [stub].\n \n@@ -5110,6 +5116,70 @@ package body Sem_Prag is\n          end loop;\n       end Check_Variant;\n \n+      ---------------------------\n+      -- Ensure_Aggregate_Form --\n+      ---------------------------\n+\n+      procedure Ensure_Aggregate_Form (Arg : Node_Id) is\n+         Expr  : constant Node_Id    := Get_Pragma_Arg (Arg);\n+         Loc   : constant Source_Ptr := Sloc (Arg);\n+         Nam   : constant Name_Id    := Chars (Arg);\n+         Comps : List_Id := No_List;\n+         Exprs : List_Id := No_List;\n+\n+      begin\n+         --  The argument is already in aggregate form, but the presence of a\n+         --  name causes this to be interpreted as a named association which in\n+         --  turn must be converted into an aggregate.\n+\n+         --    pragma Global (In_Out => (A, B, C))\n+         --                   ^         ^\n+         --                   name      aggregate\n+\n+         --    pragma Global ((In_Out => (A, B, C)))\n+         --                   ^          ^\n+         --                   aggregate  aggregate\n+\n+         if Nkind (Expr) = N_Aggregate then\n+            if Nam = No_Name then\n+               return;\n+            end if;\n+\n+         --  Do not transform a null argument into an aggregate as N_Null has\n+         --  special meaning in formal verification pragmas.\n+\n+         elsif Nkind (Expr) = N_Null then\n+            return;\n+         end if;\n+\n+         --  Positional argument is transformed into an aggregate with an\n+         --  Expressions list.\n+\n+         if Nam = No_Name then\n+            Exprs := New_List (Relocate_Node (Expr));\n+\n+         --  An associative argument is transformed into an aggregate with\n+         --  Component_Associations.\n+\n+         else\n+            Comps := New_List (\n+              Make_Component_Association (Loc,\n+                Choices    => New_List (Make_Identifier (Loc, Chars (Arg))),\n+                Expression => Relocate_Node (Expr)));\n+\n+         end if;\n+\n+         --  Remove the pragma argument name as this information has been\n+         --  captured in the aggregate.\n+\n+         Set_Chars (Arg, No_Name);\n+\n+         Set_Expression (Arg,\n+           Make_Aggregate (Loc,\n+             Component_Associations => Comps,\n+             Expressions            => Exprs));\n+      end Ensure_Aggregate_Form;\n+\n       ------------------\n       -- Error_Pragma --\n       ------------------\n@@ -9654,6 +9724,7 @@ package body Sem_Prag is\n             GNAT_Pragma;\n             S14_Pragma;\n             Check_Arg_Count (1);\n+            Ensure_Aggregate_Form (Arg1);\n \n             --  Ensure the proper placement of the pragma. Abstract states must\n             --  be associated with a package declaration.\n@@ -9677,7 +9748,7 @@ package body Sem_Prag is\n \n             State := Expression (Arg1);\n \n-            --  Multiple abstract states appear as an aggregate\n+            --  Multiple non-null abstract states appear as an aggregate\n \n             if Nkind (State) = N_Aggregate then\n                State := First (Expressions (State));\n@@ -11305,6 +11376,7 @@ package body Sem_Prag is\n          begin\n             GNAT_Pragma;\n             Check_Arg_Count (1);\n+            Ensure_Aggregate_Form (Arg1);\n \n             --  The pragma is analyzed at the end of the declarative part which\n             --  contains the related subprogram. Reset the analyzed flag.\n@@ -11824,6 +11896,7 @@ package body Sem_Prag is\n             GNAT_Pragma;\n             S14_Pragma;\n             Check_Arg_Count (1);\n+            Ensure_Aggregate_Form (Arg1);\n \n             --  Ensure the proper placement of the pragma. Depends must be\n             --  associated with a subprogram declaration or a body that acts\n@@ -13094,6 +13167,7 @@ package body Sem_Prag is\n             GNAT_Pragma;\n             S14_Pragma;\n             Check_Arg_Count (1);\n+            Ensure_Aggregate_Form (Arg1);\n \n             --  Ensure the proper placement of the pragma. Global must be\n             --  associated with a subprogram declaration or a body that acts\n@@ -13937,6 +14011,7 @@ package body Sem_Prag is\n             GNAT_Pragma;\n             S14_Pragma;\n             Check_Arg_Count (1);\n+            Ensure_Aggregate_Form (Arg1);\n \n             --  Ensure the proper placement of the pragma. Initializes must be\n             --  associated with a package declaration.\n@@ -22116,7 +22191,7 @@ package body Sem_Prag is\n       Abstr_States := New_Copy_Elist (Abstract_States (Spec_Id));\n       Collect_Hidden_States;\n \n-      --  Multiple state refinements appear as an aggregate\n+      --  Multiple non-null state refinements appear as an aggregate\n \n       if Nkind (Clauses) = N_Aggregate then\n          if Present (Expressions (Clauses)) then"}]}