{"sha": "474ffc723e5888c328b33f3cefe972fbeda4548c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDc0ZmZjNzIzZTU4ODhjMzI4YjMzZjNjZWZlOTcyZmJlZGE0NTQ4Yw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-04-18T18:19:43Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-04-18T18:19:43Z"}, "message": "cgraph.h (verify_symtab, [...]): Declare.\n\n\t* cgraph.h (verify_symtab, verify_symtab_node, verify_symtab_base):\n\tDeclare.\n\t* cgraphunit.c (verify_cgraph_node): Verify symtab base; do not verify \n\tcgraph hash and same comdat groups.\n\t(cgraph_optimize); Verify symbol table.\n\t* ipa.c (cgraph_remove_unreachable_nodes): Verify symbol table.\n\t(dissolve_same_comdat_group_list): Work on symtab nodes.\n\t(function_and_variable_visibility): Dissolve variable same comdat group\n\tlists, too.\n\t* symtab.c: Include timevar.h\n\t(verify_symtab_base, verify_symtab_node, verify_symtab): New functions.\n\nFrom-SVN: r186578", "tree": {"sha": "de940ffb13e3d6461c2a64bbad989c58632316f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de940ffb13e3d6461c2a64bbad989c58632316f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/474ffc723e5888c328b33f3cefe972fbeda4548c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/474ffc723e5888c328b33f3cefe972fbeda4548c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/474ffc723e5888c328b33f3cefe972fbeda4548c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/474ffc723e5888c328b33f3cefe972fbeda4548c/comments", "author": null, "committer": null, "parents": [{"sha": "fade902a4b4e5af0441f0059116df27241c18574", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fade902a4b4e5af0441f0059116df27241c18574", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fade902a4b4e5af0441f0059116df27241c18574"}], "stats": {"total": 200, "additions": 157, "deletions": 43}, "files": [{"sha": "ebee8ab22cef406abfcc4546eb48c8e7e1fd0232", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/474ffc723e5888c328b33f3cefe972fbeda4548c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/474ffc723e5888c328b33f3cefe972fbeda4548c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=474ffc723e5888c328b33f3cefe972fbeda4548c", "patch": "@@ -1,3 +1,17 @@\n+2012-04-18  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.h (verify_symtab, verify_symtab_node, verify_symtab_base):\n+\tDeclare.\n+\t* cgraphunit.c (verify_cgraph_node): Verify symtab base; do not verify \n+\tcgraph hash and same comdat groups.\n+\t(cgraph_optimize); Verify symbol table.\n+\t* ipa.c (cgraph_remove_unreachable_nodes): Verify symbol table.\n+\t(dissolve_same_comdat_group_list): Work on symtab nodes.\n+\t(function_and_variable_visibility): Dissolve variable same comdat group\n+\tlists, too.\n+\t* symtab.c: Include timevar.h\n+\t(verify_symtab_base, verify_symtab_node, verify_symtab): New functions.\n+\n 2012-04-18  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* tree-switch-conversion.c (info): Remove global pass info."}, {"sha": "1fd42f165811d0dbc54724ae2a7eb8a93f4226c5", "filename": "gcc/cgraph.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/474ffc723e5888c328b33f3cefe972fbeda4548c/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/474ffc723e5888c328b33f3cefe972fbeda4548c/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=474ffc723e5888c328b33f3cefe972fbeda4548c", "patch": "@@ -512,6 +512,9 @@ void debug_symtab (void);\n void dump_symtab_node (FILE *, symtab_node);\n void debug_symtab_node (symtab_node);\n void dump_symtab_base (FILE *, symtab_node);\n+void verify_symtab (void);\n+void verify_symtab_node (symtab_node);\n+bool verify_symtab_base (symtab_node);\n \n /* In cgraph.c  */\n void dump_cgraph (FILE *);"}, {"sha": "9de423396c163f6397eb43b3ac383c3a99b8e308", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 5, "deletions": 36, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/474ffc723e5888c328b33f3cefe972fbeda4548c/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/474ffc723e5888c328b33f3cefe972fbeda4548c/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=474ffc723e5888c328b33f3cefe972fbeda4548c", "patch": "@@ -577,6 +577,7 @@ verify_cgraph_node (struct cgraph_node *node)\n     return;\n \n   timevar_push (TV_CGRAPH_VERIFY);\n+  error_found |= verify_symtab_base ((symtab_node) node);\n   for (e = node->callees; e; e = e->next_callee)\n     if (e->aux)\n       {\n@@ -663,12 +664,6 @@ verify_cgraph_node (struct cgraph_node *node)\n       error_found = true;\n     }\n \n-  if (!cgraph_get_node (node->symbol.decl))\n-    {\n-      error (\"node not found in cgraph_hash\");\n-      error_found = true;\n-    }\n-\n   if (node->clone_of)\n     {\n       struct cgraph_node *n;\n@@ -708,32 +703,6 @@ verify_cgraph_node (struct cgraph_node *node)\n       error (\"double linked list of clones corrupted\");\n       error_found = true;\n     }\n-  if (node->symbol.same_comdat_group)\n-    {\n-      symtab_node n = node->symbol.same_comdat_group;\n-\n-      if (!DECL_ONE_ONLY (n->symbol.decl))\n-\t{\n-\t  error (\"non-DECL_ONE_ONLY node in a same_comdat_group list\");\n-\t  error_found = true;\n-\t}\n-      if (n == (symtab_node)node)\n-\t{\n-\t  error (\"node is alone in a comdat group\");\n-\t  error_found = true;\n-\t}\n-      do\n-\t{\n-\t  if (!n->symbol.same_comdat_group)\n-\t    {\n-\t      error (\"same_comdat_group is not a circular list\");\n-\t      error_found = true;\n-\t      break;\n-\t    }\n-\t  n = n->symbol.same_comdat_group;\n-\t}\n-      while (n != (symtab_node)node);\n-    }\n \n   if (node->analyzed && node->alias)\n     {\n@@ -2654,7 +2623,7 @@ cgraph_optimize (void)\n     return;\n \n #ifdef ENABLE_CHECKING\n-  verify_cgraph ();\n+  verify_symtab ();\n #endif\n \n   /* Frontend may output common variables after the unit has been finalized.\n@@ -2704,15 +2673,15 @@ cgraph_optimize (void)\n   if (!quiet_flag)\n     fprintf (stderr, \"Assembling functions:\\n\");\n #ifdef ENABLE_CHECKING\n-  verify_cgraph ();\n+  verify_symtab ();\n #endif\n \n   cgraph_materialize_all_clones ();\n   bitmap_obstack_initialize (NULL);\n   execute_ipa_pass_list (all_late_ipa_passes);\n   cgraph_remove_unreachable_nodes (true, dump_file);\n #ifdef ENABLE_CHECKING\n-  verify_cgraph ();\n+  verify_symtab ();\n #endif\n   bitmap_obstack_release (NULL);\n   cgraph_mark_functions_to_output ();\n@@ -2740,7 +2709,7 @@ cgraph_optimize (void)\n       dump_symtab (cgraph_dump_file);\n     }\n #ifdef ENABLE_CHECKING\n-  verify_cgraph ();\n+  verify_symtab ();\n   /* Double check that all inline clones are gone and that all\n      function bodies have been released from memory.  */\n   if (!seen_error ())"}, {"sha": "964b2b980d5909d1a3a04ab62489b13dd695b017", "filename": "gcc/ipa.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/474ffc723e5888c328b33f3cefe972fbeda4548c/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/474ffc723e5888c328b33f3cefe972fbeda4548c/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=474ffc723e5888c328b33f3cefe972fbeda4548c", "patch": "@@ -176,7 +176,7 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n   bool changed = false;\n \n #ifdef ENABLE_CHECKING\n-  verify_cgraph ();\n+  verify_symtab ();\n #endif\n   if (file)\n     fprintf (file, \"\\nReclaiming functions:\");\n@@ -467,7 +467,7 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n     return changed;\n \n #ifdef ENABLE_CHECKING\n-  verify_cgraph ();\n+  verify_symtab ();\n #endif\n \n   /* Reclaim alias pairs for functions that have disappeared from the\n@@ -730,12 +730,12 @@ varpool_externally_visible_p (struct varpool_node *vnode, bool aliased)\n /* Dissolve the same_comdat_group list in which NODE resides.  */\n \n static void\n-dissolve_same_comdat_group_list (struct cgraph_node *node)\n+dissolve_same_comdat_group_list (symtab_node node)\n {\n-  struct cgraph_node *n = node, *next;\n+  symtab_node n = node, next;\n   do\n     {\n-      next = cgraph (n->symbol.same_comdat_group);\n+      next = n->symbol.same_comdat_group;\n       n->symbol.same_comdat_group = NULL;\n       n = next;\n     }\n@@ -838,7 +838,7 @@ function_and_variable_visibility (bool whole_program)\n \t\t all of them have to be, otherwise it is a front-end bug.  */\n \t      gcc_assert (DECL_EXTERNAL (n->symbol.decl));\n #endif\n-\t  dissolve_same_comdat_group_list (node);\n+\t  dissolve_same_comdat_group_list ((symtab_node) node);\n \t}\n       gcc_assert ((!DECL_WEAK (node->symbol.decl)\n \t\t  && !DECL_COMDAT (node->symbol.decl))\n@@ -865,7 +865,7 @@ function_and_variable_visibility (bool whole_program)\n \t       in the group and they will all be made local.  We need to\n \t       dissolve the group at once so that the predicate does not\n \t       segfault though. */\n-\t    dissolve_same_comdat_group_list (node);\n+\t    dissolve_same_comdat_group_list ((symtab_node) node);\n \t}\n \n       if (node->thunk.thunk_p\n@@ -936,6 +936,8 @@ function_and_variable_visibility (bool whole_program)\n \t{\n \t  gcc_assert (in_lto_p || whole_program || !TREE_PUBLIC (vnode->symbol.decl));\n \t  cgraph_make_decl_local (vnode->symbol.decl);\n+\t  if (vnode->symbol.same_comdat_group)\n+\t    dissolve_same_comdat_group_list ((symtab_node) vnode);\n \t  vnode->symbol.resolution = LDPR_PREVAILING_DEF_IRONLY;\n \t}\n      gcc_assert (TREE_STATIC (vnode->symbol.decl));"}, {"sha": "d264e8c99dc255f24c971fbb975a94dffb8a4692", "filename": "gcc/symtab.c", "status": "modified", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/474ffc723e5888c328b33f3cefe972fbeda4548c/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/474ffc723e5888c328b33f3cefe972fbeda4548c/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=474ffc723e5888c328b33f3cefe972fbeda4548c", "patch": "@@ -29,6 +29,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ggc.h\"\n #include \"cgraph.h\"\n #include \"diagnostic.h\"\n+#include \"timevar.h\"\n \n /* Hash table used to convert declarations into nodes.  */\n static GTY((param_is (union symtab_node_def))) htab_t symtab_hash;\n@@ -471,4 +472,129 @@ debug_symtab (void)\n   dump_symtab (stderr);\n }\n \n+/* Verify common part of symtab nodes.  */\n+\n+DEBUG_FUNCTION bool\n+verify_symtab_base (symtab_node node)\n+{\n+  bool error_found = false;\n+  symtab_node hashed_node;\n+\n+  if (symtab_function_p (node))\n+    {\n+      if (TREE_CODE (node->symbol.decl) != FUNCTION_DECL)\n+\t{\n+          error (\"function symbol is not function\");\n+          error_found = true;\n+\t}\n+    }\n+  else if (symtab_variable_p (node))\n+    {\n+      if (TREE_CODE (node->symbol.decl) != VAR_DECL)\n+\t{\n+          error (\"variable symbol is not variable\");\n+          error_found = true;\n+\t}\n+    }\n+  else\n+    {\n+      error (\"node has unknown type\");\n+      error_found = true;\n+    }\n+   \n+  hashed_node = symtab_get_node (node->symbol.decl);\n+  if (!hashed_node)\n+    {\n+      error (\"node not found in symtab decl hashtable\");\n+      error_found = true;\n+    }\n+  if (assembler_name_hash)\n+    {\n+      hashed_node = symtab_node_for_asm (DECL_ASSEMBLER_NAME (node->symbol.decl));\n+      if (hashed_node && hashed_node->symbol.previous_sharing_asm_name)\n+\t{\n+          error (\"assembler name hash list corrupted\");\n+          error_found = true;\n+\t}\n+      while (hashed_node)\n+\t{\n+\t  if (hashed_node == node)\n+\t    break;\n+\t  hashed_node = hashed_node->symbol.next_sharing_asm_name;\n+\t}\n+      if (!hashed_node)\n+\t{\n+          error (\"node not found in symtab assembler name hash\");\n+          error_found = true;\n+\t}\n+    }\n+  if (node->symbol.previous_sharing_asm_name\n+      && node->symbol.previous_sharing_asm_name->symbol.next_sharing_asm_name != node)\n+    {\n+      error (\"double linked list of assembler names corrupted\");\n+    }\n+  if (node->symbol.same_comdat_group)\n+    {\n+      symtab_node n = node->symbol.same_comdat_group;\n+\n+      if (!DECL_ONE_ONLY (n->symbol.decl))\n+\t{\n+\t  error (\"non-DECL_ONE_ONLY node in a same_comdat_group list\");\n+\t  error_found = true;\n+\t}\n+      if (n->symbol.type != node->symbol.type)\n+\t{\n+\t  error (\"mixing different types of symbol in same comdat groups is not supported\");\n+\t  error_found = true;\n+\t}\n+      if (n == node)\n+\t{\n+\t  error (\"node is alone in a comdat group\");\n+\t  error_found = true;\n+\t}\n+      do\n+\t{\n+\t  if (!n->symbol.same_comdat_group)\n+\t    {\n+\t      error (\"same_comdat_group is not a circular list\");\n+\t      error_found = true;\n+\t      break;\n+\t    }\n+\t  n = n->symbol.same_comdat_group;\n+\t}\n+      while (n != node);\n+    }\n+  return error_found;\n+}\n+\n+/* Verify consistency of NODE.  */\n+\n+DEBUG_FUNCTION void\n+verify_symtab_node (symtab_node node)\n+{\n+  if (seen_error ())\n+    return;\n+\n+  timevar_push (TV_CGRAPH_VERIFY);\n+  if (symtab_function_p (node))\n+    verify_cgraph_node (cgraph (node));\n+  else\n+    if (verify_symtab_base (node))\n+      {\n+        dump_symtab_node (stderr, node);\n+        internal_error (\"verify_symtab_node failed\");\n+      }\n+  timevar_pop (TV_CGRAPH_VERIFY);\n+}\n+\n+/* Verify symbol table for internal consistency.  */\n+\n+DEBUG_FUNCTION void\n+verify_symtab (void)\n+{\n+  symtab_node node;\n+  FOR_EACH_SYMBOL (node)\n+   verify_symtab_node (node);\n+}\n+\n #include \"gt-symtab.h\""}]}