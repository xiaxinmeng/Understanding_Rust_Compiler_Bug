{"sha": "06d9f09f53cd3d0c1164986a9c5ff3a37e59dec4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDZkOWYwOWY1M2NkM2QwYzExNjQ5ODZhOWM1ZmYzYTM3ZTU5ZGVjNA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2001-04-20T15:29:09Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2001-04-20T15:29:09Z"}, "message": "class.c (dfs_unshared_virtual_bases): Add ATTRIBUTE_UNUSED.\n\ncp:\n\t* class.c (dfs_unshared_virtual_bases): Add ATTRIBUTE_UNUSED.\n\t(layout_empty_base): Return at end flag.\n\t(build_base_field): Likewise.\n\t(build_base_fields): Likewise.\n\t(layout_virtual_bases): Don't add 1 to eoc value.\n\t(end_of_class): Use full size for empty bases.\n\t(layout_class_type): Clear CLASSNEARLY_EMPTY_P if we appended\n\tempty bases. Don't add 1 to eoc value. Only add trailing padding\n\tif we're an empty class with no empty bases.\n\t(dump_class_hierarchy): Dump size and alignment.\ntestsuite:\n\t* g++.old-deja/g++.abi/empty2.C: New test.\n\t* g++.old-deja/g++.abi/empty3.C: New test.\n\nFrom-SVN: r41460", "tree": {"sha": "0450a1d1b73690e0e654642706589b65a48cb971", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0450a1d1b73690e0e654642706589b65a48cb971"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06d9f09f53cd3d0c1164986a9c5ff3a37e59dec4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06d9f09f53cd3d0c1164986a9c5ff3a37e59dec4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06d9f09f53cd3d0c1164986a9c5ff3a37e59dec4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06d9f09f53cd3d0c1164986a9c5ff3a37e59dec4/comments", "author": null, "committer": null, "parents": [{"sha": "a0a7b566f791a05642de174586fb7e4748ff1dc3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0a7b566f791a05642de174586fb7e4748ff1dc3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0a7b566f791a05642de174586fb7e4748ff1dc3"}], "stats": {"total": 243, "additions": 222, "deletions": 21}, "files": [{"sha": "eaee2bb24a37f612f22da3c1f70a7f6b20c77227", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d9f09f53cd3d0c1164986a9c5ff3a37e59dec4/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d9f09f53cd3d0c1164986a9c5ff3a37e59dec4/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=06d9f09f53cd3d0c1164986a9c5ff3a37e59dec4", "patch": "@@ -1,3 +1,16 @@\n+2001-04-20  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* class.c (dfs_unshared_virtual_bases): Add ATTRIBUTE_UNUSED.\n+\t(layout_empty_base): Return at end flag.\n+\t(build_base_field): Likewise.\n+\t(build_base_fields): Likewise.\n+\t(layout_virtual_bases): Don't add 1 to eoc value.\n+\t(end_of_class): Use full size for empty bases.\n+\t(layout_class_type): Clear CLASSNEARLY_EMPTY_P if we appended\n+\tempty bases. Don't add 1 to eoc value. Only add trailing padding\n+\tif we're an empty class with no empty bases.\n+\t(dump_class_hierarchy): Dump size and alignment.\n+\n 2001-04-20  Jakub Jelinek  <jakub@redhat.com>\n \n \t* call.c (maybe_handle_ref_bind): Copy ICS_USER_FLAG and"}, {"sha": "9c713c0c047ea830c8e4c8dc5b8cbee9b07d13f3", "filename": "gcc/cp/class.c", "status": "modified", "additions": 44, "deletions": 21, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d9f09f53cd3d0c1164986a9c5ff3a37e59dec4/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d9f09f53cd3d0c1164986a9c5ff3a37e59dec4/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=06d9f09f53cd3d0c1164986a9c5ff3a37e59dec4", "patch": "@@ -144,10 +144,10 @@ static void check_bitfield_decl PARAMS ((tree));\n static void check_field_decl PARAMS ((tree, tree, int *, int *, int *, int *));\n static void check_field_decls PARAMS ((tree, tree *, int *, int *, int *, \n \t\t\t\t     int *));\n-static void build_base_field PARAMS ((record_layout_info, tree, int *,\n+static bool build_base_field PARAMS ((record_layout_info, tree, int *,\n+\t\t\t\t     splay_tree));\n+static bool build_base_fields PARAMS ((record_layout_info, int *,\n \t\t\t\t      splay_tree));\n-static void build_base_fields PARAMS ((record_layout_info, int *,\n-\t\t\t\t       splay_tree));\n static tree build_vbase_pointer_fields PARAMS ((record_layout_info, int *));\n static tree build_vtbl_or_vbase_field PARAMS ((tree, tree, tree, tree, tree,\n \t\t\t\t\t       int *));\n@@ -180,7 +180,7 @@ static void layout_nonempty_base_or_field PARAMS ((record_layout_info,\n \t\t\t\t\t\t   tree, tree,\n \t\t\t\t\t\t   splay_tree));\n static unsigned HOST_WIDE_INT end_of_class PARAMS ((tree, int));\n-static void layout_empty_base PARAMS ((tree, tree, splay_tree));\n+static bool layout_empty_base PARAMS ((tree, tree, splay_tree));\n static void accumulate_vtbl_inits PARAMS ((tree, tree, tree, tree, tree));\n static tree dfs_accumulate_vtbl_inits PARAMS ((tree, tree, tree, tree,\n \t\t\t\t\t       tree));\n@@ -1825,7 +1825,7 @@ mark_primary_virtual_base (binfo, base_binfo, type)\n \n static tree dfs_unshared_virtual_bases (binfo, data)\n      tree binfo;\n-     void *data;\n+     void *data ATTRIBUTE_UNUSED;\n {\n   if (TREE_VIA_VIRTUAL (binfo) && !BINFO_MARKED (binfo)\n       && CLASSTYPE_HAS_PRIMARY_BASE_P (BINFO_TYPE (binfo)))\n@@ -4015,16 +4015,18 @@ layout_nonempty_base_or_field (rli, decl, binfo, offsets)\n /* Layout the empty base BINFO.  EOC indicates the byte currently just\n    past the end of the class, and should be correctly aligned for a\n    class of the type indicated by BINFO; OFFSETS gives the offsets of\n-   the empty bases allocated so far.  */\n+   the empty bases allocated so far. Return non-zero iff we added it\n+   at the end. */\n \n-static void\n+static bool\n layout_empty_base (binfo, eoc, offsets)\n      tree binfo;\n      tree eoc;\n      splay_tree offsets;\n {\n   tree alignment;\n   tree basetype = BINFO_TYPE (binfo);\n+  bool atend = false;\n   \n   /* This routine should only be used for empty classes.  */\n   my_friendly_assert (is_empty_class (basetype), 20000321);\n@@ -4039,6 +4041,7 @@ layout_empty_base (binfo, eoc, offsets)\n     {\n       /* That didn't work.  Now, we move forward from the next\n \t available spot in the class.  */\n+      atend = true;\n       propagate_binfo_offsets (binfo, convert (ssizetype, eoc));\n       while (1) \n \t{\n@@ -4053,14 +4056,16 @@ layout_empty_base (binfo, eoc, offsets)\n \t  propagate_binfo_offsets (binfo, alignment);\n \t}\n     }\n+  return atend;\n }\n \n /* Build a FIELD_DECL for the base given by BINFO in the class\n    indicated by RLI.  If the new object is non-empty, clear *EMPTY_P.\n    *BASE_ALIGN is a running maximum of the alignments of any base\n-   class.  OFFSETS gives the location of empty base subobjects.  */\n+   class.  OFFSETS gives the location of empty base subobjects. Return\n+   non-zero if the new object cannot be nearly-empty. */\n \n-static void\n+static bool\n build_base_field (rli, binfo, empty_p, offsets)\n      record_layout_info rli;\n      tree binfo;\n@@ -4069,11 +4074,12 @@ build_base_field (rli, binfo, empty_p, offsets)\n {\n   tree basetype = BINFO_TYPE (binfo);\n   tree decl;\n+  bool atend = false;\n \n   if (!COMPLETE_TYPE_P (basetype))\n     /* This error is now reported in xref_tag, thus giving better\n        location information.  */\n-    return;\n+    return atend;\n   \n   decl = build_decl (FIELD_DECL, NULL_TREE, basetype);\n   DECL_ARTIFICIAL (decl) = 1;\n@@ -4102,20 +4108,22 @@ build_base_field (rli, binfo, empty_p, offsets)\n \t byte-aligned.  */\n       eoc = tree_low_cst (rli_size_unit_so_far (rli), 0);\n       eoc = CEIL (eoc, DECL_ALIGN_UNIT (decl)) * DECL_ALIGN_UNIT (decl);\n-      layout_empty_base (binfo, size_int (eoc), offsets);\n+      atend |= layout_empty_base (binfo, size_int (eoc), offsets);\n     }\n \n   /* Record the offsets of BINFO and its base subobjects.  */\n   record_subobject_offsets (BINFO_TYPE (binfo), \n \t\t\t    BINFO_OFFSET (binfo),\n \t\t\t    offsets, \n \t\t\t    /*vbases_p=*/0);\n+  return atend;\n }\n \n /* Layout all of the non-virtual base classes.  Record empty\n-   subobjects in OFFSETS.  */\n+   subobjects in OFFSETS. Return non-zero if the type cannot be nearly\n+   empty.  */\n \n-static void\n+static bool\n build_base_fields (rli, empty_p, offsets)\n      record_layout_info rli;\n      int *empty_p;\n@@ -4126,6 +4134,7 @@ build_base_fields (rli, empty_p, offsets)\n   tree rec = rli->t;\n   int n_baseclasses = CLASSTYPE_N_BASECLASSES (rec);\n   int i;\n+  bool atend = 0;\n \n   /* Under the new ABI, the primary base class is always allocated\n      first.  */\n@@ -4152,8 +4161,9 @@ build_base_fields (rli, empty_p, offsets)\n \t  && !BINFO_PRIMARY_P (base_binfo))\n \tcontinue;\n \n-      build_base_field (rli, base_binfo, empty_p, offsets);\n+      atend |= build_base_field (rli, base_binfo, empty_p, offsets);\n     }\n+  return atend;\n }\n \n /* Go through the TYPE_METHODS of T issuing any appropriate\n@@ -4828,7 +4838,7 @@ layout_virtual_bases (t, offsets)\n      multiple such bases at the same location.  */\n   eoc = end_of_class (t, /*include_virtuals_p=*/1);\n   if (eoc * BITS_PER_UNIT > dsize)\n-    dsize = (eoc + 1) * BITS_PER_UNIT;\n+    dsize = eoc * BITS_PER_UNIT;\n \n   /* Now, make sure that the total size of the type is a multiple of\n      its alignment.  */\n@@ -4867,6 +4877,7 @@ end_of_class (t, include_virtuals_p)\n     {\n       tree base_binfo;\n       tree offset;\n+      tree size;\n       unsigned HOST_WIDE_INT end_of_base;\n \n       base_binfo = BINFO_BASETYPE (TYPE_BINFO (t), i);\n@@ -4876,9 +4887,16 @@ end_of_class (t, include_virtuals_p)\n \t  && !BINFO_PRIMARY_P (base_binfo))\n \tcontinue;\n \n+      if (is_empty_class (BINFO_TYPE (base_binfo)))\n+\t/* An empty class has zero CLASSTYPE_SIZE_UNIT, but we need to\n+\t   allocate some space for it. It cannot have virtual bases,\n+\t   so TYPE_SIZE_UNIT is fine.  */\n+\tsize = TYPE_SIZE_UNIT (BINFO_TYPE (base_binfo));\n+      else\n+\tsize = CLASSTYPE_SIZE_UNIT (BINFO_TYPE (base_binfo));\n       offset = size_binop (PLUS_EXPR, \n \t\t\t   BINFO_OFFSET (base_binfo),\n-\t\t\t   CLASSTYPE_SIZE_UNIT (BINFO_TYPE (base_binfo)));\n+\t\t\t   size);\n       end_of_base = tree_low_cst (offset, /*pos=*/1);\n       if (end_of_base > result)\n \tresult = end_of_base;\n@@ -4970,7 +4988,9 @@ layout_class_type (t, empty_p, vfuns_p,\n   /* Build FIELD_DECLs for all of the non-virtual base-types.  */\n   empty_base_offsets = splay_tree_new (splay_tree_compare_integer_csts, \n \t\t\t\t       NULL, NULL);\n-  build_base_fields (rli, empty_p, empty_base_offsets);\n+  if (build_base_fields (rli, empty_p, empty_base_offsets))\n+    CLASSTYPE_NEARLY_EMPTY_P (t) = 0;\n+  \n   /* Add pointers to all of our virtual base-classes.  */\n   TYPE_FIELDS (t) = chainon (build_vbase_pointer_fields (rli, empty_p),\n \t\t\t     TYPE_FIELDS (t));\n@@ -5060,7 +5080,7 @@ layout_class_type (t, empty_p, vfuns_p,\n   if (TREE_CODE (rli_size_unit_so_far (rli)) == INTEGER_CST\n       && compare_tree_int (rli_size_unit_so_far (rli), eoc) < 0)\n     {\n-      rli->offset = size_binop (MAX_EXPR, rli->offset, size_int (eoc + 1));\n+      rli->offset = size_binop (MAX_EXPR, rli->offset, size_int (eoc));\n       rli->bitpos = bitsize_zero_node;\n     }\n \n@@ -5069,7 +5089,7 @@ layout_class_type (t, empty_p, vfuns_p,\n      if it has basetypes.  Therefore, we add the fake field after all\n      the other fields; if there are already FIELD_DECLs on the list,\n      their offsets will not be disturbed.  */\n-  if (*empty_p)\n+  if (!eoc && *empty_p)\n     {\n       tree padding;\n \n@@ -6758,8 +6778,11 @@ dump_class_hierarchy (name, t)\n         error (\"could not open dump file `%s'\", name);\n       return;\n     }\n-  fprintf (stream, \"%s\\n\",\n-           type_as_string (t, TFF_PLAIN_IDENTIFIER));\n+  fprintf (stream, \"%s size=\", type_as_string (t, TFF_PLAIN_IDENTIFIER));\n+  fprintf (stream, HOST_WIDE_INT_PRINT_DEC,\n+\t   tree_low_cst (TYPE_SIZE (t), 0) / BITS_PER_UNIT);\n+  fprintf (stream, \" align=%lu\\n\",\n+\t   (unsigned long)(TYPE_ALIGN (t) / BITS_PER_UNIT));\n   dump_class_hierarchy_r (stream, t, TYPE_BINFO (t), 0);\n   fprintf (stream, \"\\n\");\n   if (name)"}, {"sha": "157bbed491c5b3e83f8bd6385fcaf07da107e0fb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d9f09f53cd3d0c1164986a9c5ff3a37e59dec4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d9f09f53cd3d0c1164986a9c5ff3a37e59dec4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=06d9f09f53cd3d0c1164986a9c5ff3a37e59dec4", "patch": "@@ -1,3 +1,8 @@\n+2001-04-20  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* g++.old-deja/g++.abi/empty2.C: New test.\n+\t* g++.old-deja/g++.abi/empty3.C: New test.\n+\n 2001-04-20  Jakub Jelinek  <jakub@redhat.com>\n \n \t* g++.old-deja/g++.other/comdat2.C: New test."}, {"sha": "411651701e3126e20e3ebd412ea8f64903c912bd", "filename": "gcc/testsuite/g++.old-deja/g++.abi/empty2.C", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d9f09f53cd3d0c1164986a9c5ff3a37e59dec4/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fempty2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d9f09f53cd3d0c1164986a9c5ff3a37e59dec4/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fempty2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fempty2.C?ref=06d9f09f53cd3d0c1164986a9c5ff3a37e59dec4", "patch": "@@ -0,0 +1,136 @@\n+// Build don't link:\n+\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 12 Apr 2001 <nathan@codesourcery.com>\n+\n+// Check we deal with trailing empty base classes properly\n+\n+struct A {};\n+struct B1 : A {};\n+struct B2 : A {};\n+struct B3 : A {};\n+struct B4 : A {};\n+struct B5 : A {};\n+struct B6 : A {};\n+struct B7 : A {};\n+struct B8 : A {};\n+\n+struct C1 : B1\n+{\n+  virtual void Foo () {};\n+};\n+struct C2 : B1, B2\n+{\n+  virtual void Foo () {};\n+};\n+struct C3 : B1, B2, B3\n+{\n+  virtual void Foo () {};\n+};\n+struct C4 : B1, B2, B3, B4\n+{\n+  virtual void Foo () {};\n+};\n+struct C5 : B1, B2, B3, B4, B5\n+{\n+  virtual void Foo () {};\n+};\n+struct C6 : B1, B2, B3, B4, B5, B6\n+{\n+  virtual void Foo () {};\n+};\n+struct C7 : B1, B2, B3, B4, B5, B6, B7\n+{\n+  virtual void Foo () {};\n+};\n+struct C8 : B1, B2, B3, B4, B5, B6, B7, B8\n+{\n+  virtual void Foo () {};\n+};\n+\n+struct D1 : virtual C1 {};\n+struct D2 : virtual C2 {};\n+struct D3 : virtual C3 {};\n+struct D4 : virtual C4 {};\n+struct D5 : virtual C5 {};\n+struct D6 : virtual C6 {};\n+struct D7 : virtual C7 {};\n+struct D8 : virtual C8 {};\n+\n+unsigned const nearly_empty_size = sizeof (D1);\n+\n+template <typename Cn, typename Dn> int Check (Dn const &ref)\n+{\n+  if ((sizeof (Cn) <= nearly_empty_size)\n+      != (static_cast <void const *> (&ref)\n+\t  == static_cast <Cn const *> (&ref)))\n+    return 1;\n+  return 0;\n+}\n+\n+template <typename Bn, typename Cn> int Check ()\n+{\n+  Cn c[2];\n+\n+  if (static_cast <A *> (static_cast <B1 *> (&c[1]))\n+      == static_cast <A *> (static_cast <Bn *> (&c[0])))\n+    return 1;\n+  return 0;\n+}\n+\n+  \n+int main ()\n+{\n+#if defined (__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100\n+  if (Check<B1, C1> ())\n+    return 1;\n+  if (Check<B2, C2> ())\n+    return 2;\n+  if (Check<B3, C3> ())\n+    return 3;\n+  if (Check<B4, C4> ())\n+    return 4;\n+  if (Check<B5, C5> ())\n+    return 5;\n+  if (Check<B6, C6> ())\n+    return 6;\n+  if (Check<B7, C7> ())\n+    return 7;\n+  if (Check<B8, C8> ())\n+    return 8;\n+  \n+  if (Check<C1> (D1 ()))\n+    return 11;\n+  if (Check<C2> (D2 ()))\n+    return 12;\n+  if (Check<C3> (D3 ()))\n+    return 13;\n+  if (Check<C4> (D4 ()))\n+    return 14;\n+  if (Check<C5> (D5 ()))\n+    return 15;\n+  if (Check<C6> (D6 ()))\n+    return 16;\n+  if (Check<C7> (D7 ()))\n+    return 17;\n+  if (Check<C8> (D8 ()))\n+    return 18;\n+  \n+  if (sizeof (C2) == nearly_empty_size)\n+    return 22;\n+  if (sizeof (C3) == nearly_empty_size)\n+    return 23;\n+  if (sizeof (C4) == nearly_empty_size)\n+    return 24;\n+  if (sizeof (C5) == nearly_empty_size)\n+    return 25;\n+  if (sizeof (C6) == nearly_empty_size)\n+    return 26;\n+  if (sizeof (C7) == nearly_empty_size)\n+    return 27;\n+  if (sizeof (C8) == nearly_empty_size)\n+    return 28;\n+#endif\n+  return 0;\n+  \n+}"}, {"sha": "93e9d9ffdf92182d8479c2ebac8811db4ab27803", "filename": "gcc/testsuite/g++.old-deja/g++.abi/empty3.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d9f09f53cd3d0c1164986a9c5ff3a37e59dec4/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fempty3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d9f09f53cd3d0c1164986a9c5ff3a37e59dec4/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fempty3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fempty3.C?ref=06d9f09f53cd3d0c1164986a9c5ff3a37e59dec4", "patch": "@@ -0,0 +1,24 @@\n+// Build don't link:\n+\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 12 Apr 2001 <nathan@codesourcery.com>\n+\n+// Check we deal with aligning virtual bases after a trailing empty\n+// base class properly\n+\n+struct A {};\n+struct B1 : A {};\n+struct B2 : A {};\n+struct B3 : A {};\n+\n+struct C : B1, B2, virtual B3 {};\n+\n+int main ()\n+{\n+#if defined (__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100\n+  C c;\n+  if (((char *)static_cast <B3 *> (&c) - (char *)&c) % __alignof__ (C))\n+    return 1;\n+#endif\n+  return 0;\n+}"}]}