{"sha": "1bad9c1806ac51abc2bf1bdf18b96924b1104ebb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWJhZDljMTgwNmFjNTFhYmMyYmYxYmRmMThiOTY5MjRiMTEwNGViYg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2017-11-10T20:14:52Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2017-11-10T20:14:52Z"}, "message": "auto-profile.c (afdo_indirect_call): Drop frequency.\n\n\n\t* auto-profile.c (afdo_indirect_call): Drop frequency.\n\t* cgraph.c (symbol_table::create_edge): Drop frequency argument.\n\t(cgraph_node::create_edge): Drop frequency argument.\n\t(cgraph_node::create_indirect_edge): Drop frequency argument.\n\t(cgraph_edge::make_speculative): Drop frequency arguments.\n\t(cgraph_edge::resolve_speculation): Do not update frequencies\n\t(cgraph_edge::dump_edge_flags): Do not dump frequency.\n\t(cgraph_node::dump): Check consistency in IPA mode.\n\t(cgraph_edge::maybe_hot_p): Use IPA counter.\n\t(cgraph_edge::verify_count_and_frequency): Rename to ...\n\t(cgraph_edge::verify_count): ... this one; drop frequency checking.\n\t(cgraph_node::verify_node): Update.\n\t* cgraph.h (struct cgraph_edge): Drop frequency.\n\t(cgraph_edge::frequency): New function.\n\t* cgraphbuild.c (pass_build_cgraph_edges::execute): Donot pass\n\tfrequencies.\n\t(cgraph_edge::rebuild_edges): Likewise.\n\t* cgraphclones.c (cgraph_edge::clone): Scale only counts.\n\t(duplicate_thunk_for_node): Do not pass frequency.\n\t(cgraph_node::create_clone): Scale only counts.\n\t(cgraph_node::create_virtual_clone): Do not pass frequency.\n\t(cgraph_node::create_edge_including_clones): Do not pass frequency.\n\t(cgraph_node::create_version_clone): Do not pass frequency.\n\t* cgraphunit.c (cgraph_node::analyze): Do not pass frequency.\n\t(cgraph_node::expand_thunk): Do not pass frequency.\n\t(cgraph_node::create_wrapper): Do not pass frequency.\n\t* gimple-iterator.c (update_call_edge_frequencies): Do not pass\n\tfrequency.\n\t* gimple-streamer-in.c (input_bb): Scale only IPA counts.\n\t* ipa-chkp.c (chkp_produce_thunks): Do not pass frequency.\n\t* ipa-cp.c (ipcp_lattice::print): Use frequency function.\n\t(gather_caller_stats): Use frequency function.\n\t(ipcp_cloning_candidate_p): Use frequency function.\n\t(ipcp_propagate_stage): Use frequency function.\n\t(get_info_about_necessary_edges): Use frequency function.\n\t(update_profiling_info): Update only IPA profile.\n\t(update_specialized_profile): Use frequency functoin.\n\t(perhaps_add_new_callers): Update only IPA profile.\n\t* ipa-devirt.c (ipa_devirt): Use IPA profile.\n\t* ipa-fnsummary.c (redirect_to_unreachable): Do not set frequrency.\n\t(dump_ipa_call_summary): Use frequency function.\n\t(estimate_edge_size_and_time): Use frequency function.\n\t(ipa_merge_fn_summary_after_inlining): Use frequency function.\n\t* ipa-inline-analysis.c (do_estimate_edge_time): Use IPA profile.\n\t* ipa-inline-transform.c (update_noncloned_frequencies): Rename to ..\n\t(update_noncloned_counts): ... ths one; scale counts only.\n\t(clone_inlined_nodes): Do not scale frequency.\n\t(inline_call): Do not pass frequency.\n\t* ipa-inline.c (compute_uninlined_call_time): Use IPA profile.\n\t(compute_inlined_call_time): Use IPA profile.\n\t(want_inline_small_function_p): Use IPA profile.\n\t(want_inline_self_recursive_call_p): Use IPA profile.\n\t(edge_badness): Use IPA profile.\n\t(lookup_recursive_calls): Use IPA profile.\n\t(recursive_inlining): Do not pass frequency.\n\t(resolve_noninline_speculation): Do not update frequency.\n\t(inline_small_functions): Collect max of IPA profile.\n\t(dump_overall_stats): Dump IPA porfile.\n\t(dump_inline_stats): Dump IPA porfile.\n\t(ipa_inline): Collect IPA stats.\n\t* ipa-inline.h (clone_inlined_nodes): Update prototype.\n\t* ipa-profile.c (ipa_propagate_frequency_1): Use frequency function.\n\t(ipa_propagate_frequency): Use frequency function.\n\t(ipa_profile): Cleanup.\n\t* ipa-prop.c (ipa_make_edge_direct_to_target): Do not pass frequency\n\t* ipa-utils.c (ipa_merge_profiles): Merge all profiles.\n\t* lto-cgraph.c (lto_output_edge): Do not stream frequency.\n\t(input_node): Do not stream frequency.\n\t(input_edge): Do not stream frequency.\n\t(merge_profile_summaries): Scale only IPA profiles.\n\t* omp-simd-clone.c (simd_clone_adjust): Do not pass frequency.\n\t* predict.c (drop_profile): Do not recompute frequency.\n\t* trans-mem.c (ipa_tm_insert_irr_call): Do not pass frequency.\n\t(ipa_tm_insert_gettmclone_call): Do not pass frequency.\n\t* tree-cfg.c (execute_fixup_cfg): Drop profile to global0 if needed.\n\t* tree-chkp.c (chkp_copy_bounds_for_assign): Do not pass frequency.\n\t* tree-emutls.c (gen_emutls_addr): Do not pass frequency.\n\t* tree-inline.c (copy_bb): Do not scale frequency.\n\t(expand_call_inline): Do not scale frequency.\n\t(tree_function_versioning): Do not scale frequency.\n\t* ubsan.c (ubsan_create_edge): Do not pass frequency.\n\nlto/ChangeLog:\n\n2017-11-10  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* lto-partition.c (lto_balanced_map): Use frequency accessor.\n\nFrom-SVN: r254636", "tree": {"sha": "fb0b29c9c3b3f1661c40c33d122103cfc6a499c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb0b29c9c3b3f1661c40c33d122103cfc6a499c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/comments", "author": null, "committer": null, "parents": [{"sha": "a0e6ac44380249e8dfa4e6e4c533edfc6ad46d5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0e6ac44380249e8dfa4e6e4c533edfc6ad46d5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0e6ac44380249e8dfa4e6e4c533edfc6ad46d5b"}], "stats": {"total": 892, "additions": 428, "deletions": 464}, "files": [{"sha": "ba6d46b0d7990b47078a8dae30a05dce1b096ce8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1bad9c1806ac51abc2bf1bdf18b96924b1104ebb", "patch": "@@ -1,3 +1,87 @@\n+2017-11-10  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* auto-profile.c (afdo_indirect_call): Drop frequency.\n+\t* cgraph.c (symbol_table::create_edge): Drop frequency argument.\n+\t(cgraph_node::create_edge): Drop frequency argument.\n+\t(cgraph_node::create_indirect_edge): Drop frequency argument.\n+\t(cgraph_edge::make_speculative): Drop frequency arguments.\n+\t(cgraph_edge::resolve_speculation): Do not update frequencies\n+\t(cgraph_edge::dump_edge_flags): Do not dump frequency.\n+\t(cgraph_node::dump): Check consistency in IPA mode.\n+\t(cgraph_edge::maybe_hot_p): Use IPA counter.\n+\t(cgraph_edge::verify_count_and_frequency): Rename to ...\n+\t(cgraph_edge::verify_count): ... this one; drop frequency checking.\n+\t(cgraph_node::verify_node): Update.\n+\t* cgraph.h (struct cgraph_edge): Drop frequency.\n+\t(cgraph_edge::frequency): New function.\n+\t* cgraphbuild.c (pass_build_cgraph_edges::execute): Donot pass\n+\tfrequencies.\n+\t(cgraph_edge::rebuild_edges): Likewise.\n+\t* cgraphclones.c (cgraph_edge::clone): Scale only counts.\n+\t(duplicate_thunk_for_node): Do not pass frequency.\n+\t(cgraph_node::create_clone): Scale only counts.\n+\t(cgraph_node::create_virtual_clone): Do not pass frequency.\n+\t(cgraph_node::create_edge_including_clones): Do not pass frequency.\n+\t(cgraph_node::create_version_clone): Do not pass frequency.\n+\t* cgraphunit.c (cgraph_node::analyze): Do not pass frequency.\n+\t(cgraph_node::expand_thunk): Do not pass frequency.\n+\t(cgraph_node::create_wrapper): Do not pass frequency.\n+\t* gimple-iterator.c (update_call_edge_frequencies): Do not pass\n+\tfrequency.\n+\t* gimple-streamer-in.c (input_bb): Scale only IPA counts.\n+\t* ipa-chkp.c (chkp_produce_thunks): Do not pass frequency.\n+\t* ipa-cp.c (ipcp_lattice::print): Use frequency function.\n+\t(gather_caller_stats): Use frequency function.\n+\t(ipcp_cloning_candidate_p): Use frequency function.\n+\t(ipcp_propagate_stage): Use frequency function.\n+\t(get_info_about_necessary_edges): Use frequency function.\n+\t(update_profiling_info): Update only IPA profile.\n+\t(update_specialized_profile): Use frequency functoin.\n+\t(perhaps_add_new_callers): Update only IPA profile.\n+\t* ipa-devirt.c (ipa_devirt): Use IPA profile.\n+\t* ipa-fnsummary.c (redirect_to_unreachable): Do not set frequrency.\n+\t(dump_ipa_call_summary): Use frequency function.\n+\t(estimate_edge_size_and_time): Use frequency function.\n+\t(ipa_merge_fn_summary_after_inlining): Use frequency function.\n+\t* ipa-inline-analysis.c (do_estimate_edge_time): Use IPA profile.\n+\t* ipa-inline-transform.c (update_noncloned_frequencies): Rename to ..\n+\t(update_noncloned_counts): ... ths one; scale counts only.\n+\t(clone_inlined_nodes): Do not scale frequency.\n+\t(inline_call): Do not pass frequency.\n+\t* ipa-inline.c (compute_uninlined_call_time): Use IPA profile.\n+\t(compute_inlined_call_time): Use IPA profile.\n+\t(want_inline_small_function_p): Use IPA profile.\n+\t(want_inline_self_recursive_call_p): Use IPA profile.\n+\t(edge_badness): Use IPA profile.\n+\t(lookup_recursive_calls): Use IPA profile.\n+\t(recursive_inlining): Do not pass frequency.\n+\t(resolve_noninline_speculation): Do not update frequency.\n+\t(inline_small_functions): Collect max of IPA profile.\n+\t(dump_overall_stats): Dump IPA porfile.\n+\t(dump_inline_stats): Dump IPA porfile.\n+\t(ipa_inline): Collect IPA stats.\n+\t* ipa-inline.h (clone_inlined_nodes): Update prototype.\n+\t* ipa-profile.c (ipa_propagate_frequency_1): Use frequency function.\n+\t(ipa_propagate_frequency): Use frequency function.\n+\t(ipa_profile): Cleanup.\n+\t* ipa-prop.c (ipa_make_edge_direct_to_target): Do not pass frequency\n+\t* ipa-utils.c (ipa_merge_profiles): Merge all profiles.\n+\t* lto-cgraph.c (lto_output_edge): Do not stream frequency.\n+\t(input_node): Do not stream frequency.\n+\t(input_edge): Do not stream frequency.\n+\t(merge_profile_summaries): Scale only IPA profiles.\n+\t* omp-simd-clone.c (simd_clone_adjust): Do not pass frequency.\n+\t* predict.c (drop_profile): Do not recompute frequency.\n+\t* trans-mem.c (ipa_tm_insert_irr_call): Do not pass frequency.\n+\t(ipa_tm_insert_gettmclone_call): Do not pass frequency.\n+\t* tree-cfg.c (execute_fixup_cfg): Drop profile to global0 if needed.\n+\t* tree-chkp.c (chkp_copy_bounds_for_assign): Do not pass frequency.\n+\t* tree-emutls.c (gen_emutls_addr): Do not pass frequency.\n+\t* tree-inline.c (copy_bb): Do not scale frequency.\n+\t(expand_call_inline): Do not scale frequency.\n+\t(tree_function_versioning): Do not scale frequency.\n+\t* ubsan.c (ubsan_create_edge): Do not pass frequency.\n+\n 2017-11-10  Julia Koval  <julia.koval@intel.com>\n \n \t * config/i386/gfniintrin.h (_mm_gf2p8affine_epi64_epi8,"}, {"sha": "f8c8871cf5ecfc20a5b68ffa0a87d1fd1a371fc7", "filename": "gcc/auto-profile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Fauto-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Fauto-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-profile.c?ref=1bad9c1806ac51abc2bf1bdf18b96924b1104ebb", "patch": "@@ -1061,7 +1061,7 @@ afdo_indirect_call (gimple_stmt_iterator *gsi, const icall_target_map &map,\n   /* FIXME: Count should be initialized.  */\n   struct cgraph_edge *new_edge\n       = indirect_edge->make_speculative (direct_call,\n-\t\t\t\t\t profile_count::uninitialized (), 0);\n+\t\t\t\t\t profile_count::uninitialized ());\n   new_edge->redirect_call_stmt_to_callee ();\n   gimple_remove_histogram_value (cfun, stmt, hist);\n   inline_call (new_edge, true, NULL, NULL, false);"}, {"sha": "83e496b42398d85830784a79b2d0635095a06a7d", "filename": "gcc/cgraph.c", "status": "modified", "additions": 49, "deletions": 100, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=1bad9c1806ac51abc2bf1bdf18b96924b1104ebb", "patch": "@@ -822,7 +822,7 @@ cgraph_edge::set_call_stmt (gcall *new_stmt, bool update_speculative)\n \n cgraph_edge *\n symbol_table::create_edge (cgraph_node *caller, cgraph_node *callee,\n-\t\t\t   gcall *call_stmt, profile_count count, int freq,\n+\t\t\t   gcall *call_stmt, profile_count count,\n \t\t\t   bool indir_unknown_callee)\n {\n   cgraph_edge *edge;\n@@ -862,10 +862,7 @@ symbol_table::create_edge (cgraph_node *caller, cgraph_node *callee,\n   edge->next_callee = NULL;\n   edge->lto_stmt_uid = 0;\n \n-  edge->count = count.ipa ();\n-  edge->frequency = freq;\n-  gcc_checking_assert (freq >= 0);\n-  gcc_checking_assert (freq <= CGRAPH_FREQ_MAX);\n+  edge->count = count;\n \n   edge->call_stmt = call_stmt;\n   push_cfun (DECL_STRUCT_FUNCTION (caller->decl));\n@@ -907,10 +904,10 @@ symbol_table::create_edge (cgraph_node *caller, cgraph_node *callee,\n \n cgraph_edge *\n cgraph_node::create_edge (cgraph_node *callee,\n-\t\t\t  gcall *call_stmt, profile_count count, int freq)\n+\t\t\t  gcall *call_stmt, profile_count count)\n {\n   cgraph_edge *edge = symtab->create_edge (this, callee, call_stmt, count,\n-\t\t\t\t\t   freq, false);\n+\t\t\t\t\t   false);\n \n   initialize_inline_failed (edge);\n \n@@ -944,11 +941,11 @@ cgraph_allocate_init_indirect_info (void)\n \n cgraph_edge *\n cgraph_node::create_indirect_edge (gcall *call_stmt, int ecf_flags,\n-\t\t\t\t   profile_count count, int freq,\n+\t\t\t\t   profile_count count,\n \t\t\t\t   bool compute_indirect_info)\n {\n   cgraph_edge *edge = symtab->create_edge (this, NULL, call_stmt,\n-\t\t\t\t\t\t\t    count, freq, true);\n+\t\t\t\t\t\t\t    count, true);\n   tree target;\n \n   initialize_inline_failed (edge);\n@@ -1060,8 +1057,7 @@ cgraph_edge::remove (void)\n    Return direct edge created.  */\n \n cgraph_edge *\n-cgraph_edge::make_speculative (cgraph_node *n2, profile_count direct_count,\n-\t\t\t       int direct_frequency)\n+cgraph_edge::make_speculative (cgraph_node *n2, profile_count direct_count)\n {\n   cgraph_node *n = caller;\n   ipa_ref *ref = NULL;\n@@ -1071,7 +1067,7 @@ cgraph_edge::make_speculative (cgraph_node *n2, profile_count direct_count,\n     fprintf (dump_file, \"Indirect call -> speculative call %s => %s\\n\",\n \t     n->dump_name (), n2->dump_name ());\n   speculative = true;\n-  e2 = n->create_edge (n2, call_stmt, direct_count, direct_frequency);\n+  e2 = n->create_edge (n2, call_stmt, direct_count);\n   initialize_inline_failed (e2);\n   e2->speculative = true;\n   if (TREE_NOTHROW (n2->decl))\n@@ -1081,7 +1077,6 @@ cgraph_edge::make_speculative (cgraph_node *n2, profile_count direct_count,\n   e2->lto_stmt_uid = lto_stmt_uid;\n   e2->in_polymorphic_cdtor = in_polymorphic_cdtor;\n   count -= e2->count;\n-  frequency -= e2->frequency;\n   symtab->call_edge_duplication_hooks (this, e2);\n   ref = n->create_reference (n2, IPA_REF_ADDR, call_stmt);\n   ref->lto_stmt_uid = lto_stmt_uid;\n@@ -1198,9 +1193,6 @@ cgraph_edge::resolve_speculation (tree callee_decl)\n          in the functions inlined through it.  */\n     }\n   edge->count += e2->count;\n-  edge->frequency += e2->frequency;\n-  if (edge->frequency > CGRAPH_FREQ_MAX)\n-    edge->frequency = CGRAPH_FREQ_MAX;\n   edge->speculative = false;\n   e2->speculative = false;\n   ref->remove_reference ();\n@@ -1308,9 +1300,7 @@ cgraph_edge::redirect_call_stmt_to_callee (void)\n \t  /* We are producing the final function body and will throw away the\n \t     callgraph edges really soon.  Reset the counts/frequencies to\n \t     keep verifier happy in the case of roundoff errors.  */\n-\t  e->count = gimple_bb (e->call_stmt)->count.ipa ();\n-\t  e->frequency = compute_call_stmt_bb_frequency\n-\t\t\t  (e->caller->decl, gimple_bb (e->call_stmt));\n+\t  e->count = gimple_bb (e->call_stmt)->count;\n \t}\n       /* Expand speculation into GIMPLE code.  */\n       else\n@@ -1329,12 +1319,7 @@ cgraph_edge::redirect_call_stmt_to_callee (void)\n \n \t  profile_probability prob = e->count.probability_in (e->count\n \t\t\t\t\t\t\t      + e2->count);\n-\t  if (prob.initialized_p ())\n-\t    ;\n-\t  else if (e->frequency || e2->frequency)\n-\t    prob = profile_probability::probability_in_gcov_type\n-\t\t     (e->frequency, e->frequency + e2->frequency).guessed ();\n-\t  else \n+\t  if (!prob.initialized_p ())\n \t    prob = profile_probability::even ();\n \t  new_stmt = gimple_ic (e->call_stmt,\n \t\t\t\tdyn_cast<cgraph_node *> (ref->referred),\n@@ -1355,24 +1340,11 @@ cgraph_edge::redirect_call_stmt_to_callee (void)\n \t      gcall *ibndret = chkp_retbnd_call_by_val (iresult);\n \t      struct cgraph_edge *iedge\n \t\t= e2->caller->cgraph_node::get_edge (ibndret);\n-\t      struct cgraph_edge *dedge;\n \n \t      if (dbndret)\n-\t\t{\n-\t\t  dedge = iedge->caller->create_edge (iedge->callee,\n-\t\t\t\t\t\t      dbndret, e->count,\n-\t\t\t\t\t\t      e->frequency);\n-\t\t  dedge->frequency = compute_call_stmt_bb_frequency\n-\t\t    (dedge->caller->decl, gimple_bb (dedge->call_stmt));\n-\t\t}\n-\t      iedge->frequency = compute_call_stmt_bb_frequency\n-\t\t(iedge->caller->decl, gimple_bb (iedge->call_stmt));\n+\t\tiedge->caller->create_edge (iedge->callee, dbndret, e->count);\n \t    }\n \n-\t  e->frequency = compute_call_stmt_bb_frequency\n-\t\t\t   (e->caller->decl, gimple_bb (e->call_stmt));\n-\t  e2->frequency = compute_call_stmt_bb_frequency\n-\t\t\t   (e2->caller->decl, gimple_bb (e2->call_stmt));\n \t  e2->speculative = false;\n \t  ref->speculative = false;\n \t  ref->stmt = NULL;\n@@ -1610,7 +1582,6 @@ cgraph_update_edges_for_call_stmt_node (cgraph_node *node,\n       cgraph_edge *e = node->get_edge (old_stmt);\n       cgraph_edge *ne = NULL;\n       profile_count count;\n-      int frequency;\n \n       if (e)\n \t{\n@@ -1644,8 +1615,7 @@ cgraph_update_edges_for_call_stmt_node (cgraph_node *node,\n \t  /* Otherwise remove edge and create new one; we can't simply redirect\n \t     since function has changed, so inline plan and other information\n \t     attached to edge is invalid.  */\n-\t  count = e->count.ipa ();\n-\t  frequency = e->frequency;\n+\t  count = e->count;\n  \t  if (e->indirect_unknown_callee || e->inline_failed)\n \t    e->remove ();\n \t  else\n@@ -1655,16 +1625,13 @@ cgraph_update_edges_for_call_stmt_node (cgraph_node *node,\n \t{\n \t  /* We are seeing new direct call; compute profile info based on BB.  */\n \t  basic_block bb = gimple_bb (new_stmt);\n-\t  count = bb->count.ipa ();\n-\t  frequency = compute_call_stmt_bb_frequency (current_function_decl,\n-\t\t\t\t\t\t      bb);\n+\t  count = bb->count;\n \t}\n \n       if (new_call)\n \t{\n \t  ne = node->create_edge (cgraph_node::get_create (new_call),\n-\t\t\t\t  as_a <gcall *> (new_stmt), count,\n-\t\t\t\t  frequency);\n+\t\t\t\t  as_a <gcall *> (new_stmt), count);\n \t  gcc_assert (ne->inline_failed);\n \t}\n     }\n@@ -2056,10 +2023,9 @@ cgraph_edge::dump_edge_flags (FILE *f)\n     {\n       fprintf (f, \"(\");\n       count.dump (f);\n-      fprintf (f, \")\");\n+      fprintf (f, \",\");\n+      fprintf (f, \"%.2f per call) \", frequency () / (double)CGRAPH_FREQ_BASE);\n     }\n-  if (frequency)\n-    fprintf (f, \"(%.2f per call) \", frequency / (double)CGRAPH_FREQ_BASE);\n   if (can_throw_external)\n     fprintf (f, \"(can throw external) \");\n }\n@@ -2205,22 +2171,22 @@ cgraph_node::dump (FILE *f)\n     }\n   fprintf (f, \"\\n\");\n \n-  if (count.initialized_p ())\n+  if (count.ipa ().initialized_p ())\n     {\n       bool ok = true;\n       bool min = false;\n       ipa_ref *ref;\n \n       FOR_EACH_ALIAS (this, ref)\n \tif (dyn_cast <cgraph_node *> (ref->referring)->count.initialized_p ())\n-\t  sum += dyn_cast <cgraph_node *> (ref->referring)->count;\n+\t  sum += dyn_cast <cgraph_node *> (ref->referring)->count.ipa ();\n   \n       if (global.inlined_to\n \t  || (symtab->state < EXPANSION\n \t      && ultimate_alias_target () == this && only_called_directly_p ()))\n \tok = !count.differs_from_p (sum);\n-      else if (count > profile_count::from_gcov_type (100)\n-\t       && count < sum.apply_scale (99, 100))\n+      else if (count.ipa () > profile_count::from_gcov_type (100)\n+\t       && count.ipa () < sum.apply_scale (99, 100))\n \tok = false, min = true;\n       if (!ok)\n \t{\n@@ -2826,7 +2792,7 @@ cgraph_edge::cannot_lead_to_return_p (void)\n bool\n cgraph_edge::maybe_hot_p (void)\n {\n-  if (!maybe_hot_count_p (NULL, count))\n+  if (!maybe_hot_count_p (NULL, count.ipa ()))\n     return false;\n   if (caller->frequency == NODE_FREQUENCY_UNLIKELY_EXECUTED\n       || (callee\n@@ -2845,12 +2811,12 @@ cgraph_edge::maybe_hot_p (void)\n   if (symtab->state < IPA_SSA)\n     return true;\n   if (caller->frequency == NODE_FREQUENCY_EXECUTED_ONCE\n-      && frequency < CGRAPH_FREQ_BASE * 3 / 2)\n+      && frequency () < CGRAPH_FREQ_BASE * 3 / 2)\n     return false;\n   if (opt_for_fn (caller->decl, flag_guess_branch_prob))\n     {\n       if (PARAM_VALUE (HOT_BB_FREQUENCY_FRACTION) == 0\n-\t  || frequency <= (CGRAPH_FREQ_BASE\n+\t  || frequency () <= (CGRAPH_FREQ_BASE\n \t\t\t   / PARAM_VALUE (HOT_BB_FREQUENCY_FRACTION)))\n         return false;\n     }\n@@ -3079,29 +3045,14 @@ clone_of_p (cgraph_node *node, cgraph_node *node2)\n /* Verify edge count and frequency.  */\n \n bool\n-cgraph_edge::verify_count_and_frequency ()\n+cgraph_edge::verify_count ()\n {\n   bool error_found = false;\n   if (!count.verify ())\n     {\n       error (\"caller edge count invalid\");\n       error_found = true;\n     }\n-  if (count.initialized_p () && !(count.ipa () == count))\n-    {\n-      error (\"caller edge count is local\");\n-      error_found = true;\n-    }\n-  if (frequency < 0)\n-    {\n-      error (\"caller edge frequency is negative\");\n-      error_found = true;\n-    }\n-  if (frequency > CGRAPH_FREQ_MAX)\n-    {\n-      error (\"caller edge frequency is too large\");\n-      error_found = true;\n-    }\n   return error_found;\n }\n \n@@ -3193,11 +3144,6 @@ cgraph_node::verify_node (void)\n       error (\"cgraph count invalid\");\n       error_found = true;\n     }\n-  if (count.initialized_p () && !(count.ipa () == count))\n-    {\n-      error (\"cgraph count is local\");\n-      error_found = true;\n-    }\n   if (global.inlined_to && same_comdat_group)\n     {\n       error (\"inline clone in same comdat group list\");\n@@ -3244,7 +3190,7 @@ cgraph_node::verify_node (void)\n   bool check_comdat = comdat_local_p ();\n   for (e = callers; e; e = e->next_caller)\n     {\n-      if (e->verify_count_and_frequency ())\n+      if (e->verify_count ())\n \terror_found = true;\n       if (check_comdat\n \t  && !in_same_comdat_group_p (e->caller))\n@@ -3277,46 +3223,49 @@ cgraph_node::verify_node (void)\n     }\n   for (e = callees; e; e = e->next_callee)\n     {\n-      if (e->verify_count_and_frequency ())\n+      if (e->verify_count ())\n \terror_found = true;\n-      /* FIXME: re-enable once cgraph is converted to counts.  */\n       if (gimple_has_body_p (e->caller->decl)\n-\t  && 0\n \t  && !e->caller->global.inlined_to\n \t  && !e->speculative\n \t  /* Optimized out calls are redirected to __builtin_unreachable.  */\n-\t  && (e->frequency\n+\t  && (e->count.nonzero_p ()\n \t      || ! e->callee->decl\n \t      || DECL_BUILT_IN_CLASS (e->callee->decl) != BUILT_IN_NORMAL\n \t      || DECL_FUNCTION_CODE (e->callee->decl) != BUILT_IN_UNREACHABLE)\n-\t  && (e->frequency\n-\t      != compute_call_stmt_bb_frequency (e->caller->decl,\n-\t\t\t\t\t\t gimple_bb (e->call_stmt))))\n+\t  && count\n+\t      == ENTRY_BLOCK_PTR_FOR_FN (DECL_STRUCT_FUNCTION (decl))->count\n+\t  && (!e->count.ipa_p ()\n+\t      && e->count.differs_from_p (gimple_bb (e->call_stmt)->count)))\n \t{\n-\t  error (\"caller edge frequency %i does not match BB frequency %i\",\n-\t\t e->frequency,\n-\t\t compute_call_stmt_bb_frequency (e->caller->decl,\n-\t\t\t\t\t\t gimple_bb (e->call_stmt)));\n+\t  error (\"caller edge count does not match BB count\");\n+\t  fprintf (stderr, \"edge count: \");\n+\t  e->count.dump (stderr);\n+\t  fprintf (stderr, \"\\n bb count: \");\n+\t  gimple_bb (e->call_stmt)->count.dump (stderr);\n+\t  fprintf (stderr, \"\\n\");\n \t  error_found = true;\n \t}\n     }\n   for (e = indirect_calls; e; e = e->next_callee)\n     {\n-      if (e->verify_count_and_frequency ())\n+      if (e->verify_count ())\n \terror_found = true;\n-      /* FIXME: re-enable once cgraph is converted to counts.  */\n       if (gimple_has_body_p (e->caller->decl)\n \t  && !e->caller->global.inlined_to\n \t  && !e->speculative\n-\t  && 0\n-\t  && (e->frequency\n-\t      != compute_call_stmt_bb_frequency (e->caller->decl,\n-\t\t\t\t\t\t gimple_bb (e->call_stmt))))\n+\t  && e->count.ipa_p ()\n+\t  && count\n+\t      == ENTRY_BLOCK_PTR_FOR_FN (DECL_STRUCT_FUNCTION (decl))->count\n+\t  && (!e->count.ipa_p ()\n+\t      && e->count.differs_from_p (gimple_bb (e->call_stmt)->count)))\n \t{\n-\t  error (\"indirect call frequency %i does not match BB frequency %i\",\n-\t\t e->frequency,\n-\t\t compute_call_stmt_bb_frequency (e->caller->decl,\n-\t\t\t\t\t\t gimple_bb (e->call_stmt)));\n+\t  error (\"indirect call count does not match BB count\");\n+\t  fprintf (stderr, \"edge count: \");\n+\t  e->count.dump (stderr);\n+\t  fprintf (stderr, \"\\n bb count: \");\n+\t  gimple_bb (e->call_stmt)->count.dump (stderr);\n+\t  fprintf (stderr, \"\\n\");\n \t  error_found = true;\n \t}\n     }"}, {"sha": "8da8f605b6f2a37fde28791bb56422e212b46b1d", "filename": "gcc/cgraph.h", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=1bad9c1806ac51abc2bf1bdf18b96924b1104ebb", "patch": "@@ -942,7 +942,7 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n      All hooks will see this in node's global.inlined_to, when invoked.\n      Can be NULL if the node is not inlined.  SUFFIX is string that is appended\n      to the original name.  */\n-  cgraph_node *create_clone (tree decl, profile_count count, int freq,\n+  cgraph_node *create_clone (tree decl, profile_count count,\n \t\t\t     bool update_original,\n \t\t\t     vec<cgraph_edge *> redirect_callers,\n \t\t\t     bool call_duplication_hook,\n@@ -1110,14 +1110,13 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n \n   /* Create edge from a given function to CALLEE in the cgraph.  */\n   cgraph_edge *create_edge (cgraph_node *callee,\n-\t\t\t    gcall *call_stmt, profile_count count,\n-\t\t\t    int freq);\n+\t\t\t    gcall *call_stmt, profile_count count);\n \n   /* Create an indirect edge with a yet-undetermined callee where the call\n      statement destination is a formal parameter of the caller with index\n      PARAM_INDEX. */\n   cgraph_edge *create_indirect_edge (gcall *call_stmt, int ecf_flags,\n-\t\t\t\t     profile_count count, int freq,\n+\t\t\t\t     profile_count count,\n \t\t\t\t     bool compute_indirect_info = true);\n \n   /* Like cgraph_create_edge walk the clone tree and update all clones sharing\n@@ -1126,7 +1125,6 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n   void create_edge_including_clones (cgraph_node *callee,\n \t\t\t\t     gimple *old_stmt, gcall *stmt,\n \t\t\t\t     profile_count count,\n-\t\t\t\t     int freq,\n \t\t\t\t     cgraph_inline_failed_t reason);\n \n   /* Return the callgraph edge representing the GIMPLE_CALL statement\n@@ -1665,8 +1663,7 @@ struct GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"),\n   /* Turn edge into speculative call calling N2. Update\n      the profile so the direct call is taken COUNT times\n      with FREQUENCY.  */\n-  cgraph_edge *make_speculative (cgraph_node *n2, profile_count direct_count,\n-\t\t\t\t int direct_frequency);\n+  cgraph_edge *make_speculative (cgraph_node *n2, profile_count direct_count);\n \n    /* Given speculative call edge, return all three components.  */\n   void speculative_call_info (cgraph_edge *&direct, cgraph_edge *&indirect,\n@@ -1684,11 +1681,11 @@ struct GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"),\n   /* Create clone of edge in the node N represented\n      by CALL_EXPR the callgraph.  */\n   cgraph_edge * clone (cgraph_node *n, gcall *call_stmt, unsigned stmt_uid,\n-\t\t       profile_count num, profile_count den, int freq_scale,\n+\t\t       profile_count num, profile_count den,\n \t\t       bool update_original);\n \n   /* Verify edge count and frequency.  */\n-  bool verify_count_and_frequency ();\n+  bool verify_count ();\n \n   /* Return true when call of edge can not lead to return from caller\n      and thus it is safe to ignore its side effects for IPA analysis\n@@ -1728,10 +1725,6 @@ struct GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"),\n   /* The stmt_uid of call_stmt.  This is used by LTO to recover the call_stmt\n      when the function is serialized in.  */\n   unsigned int lto_stmt_uid;\n-  /* Expected frequency of executions within the function.\n-     When set to CGRAPH_FREQ_BASE, the edge is expected to be called once\n-     per function call.  The range is 0 to CGRAPH_FREQ_MAX.  */\n-  int frequency;\n   /* Unique id of the edge.  */\n   int uid;\n   /* Whether this edge was made direct by indirect inlining.  */\n@@ -1769,6 +1762,10 @@ struct GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"),\n   /* Return true if call must bind to current definition.  */\n   bool binds_to_current_def_p ();\n \n+  /* Expected frequency of executions within the function.\n+     When set to CGRAPH_FREQ_BASE, the edge is expected to be called once\n+     per function call.  The range is 0 to CGRAPH_FREQ_MAX.  */\n+  int frequency ();\n private:\n   /* Remove the edge from the list of the callers of the callee.  */\n   void remove_caller (void);\n@@ -2287,7 +2284,7 @@ class GTY((tag (\"SYMTAB\"))) symbol_table\n      parameters of which only CALLEE can be NULL (when creating an indirect call\n      edge).  */\n   cgraph_edge *create_edge (cgraph_node *caller, cgraph_node *callee,\n-\t\t\t    gcall *call_stmt, profile_count count, int freq,\n+\t\t\t    gcall *call_stmt, profile_count count,\n \t\t\t    bool indir_unknown_callee);\n \n   /* Put the edge onto the free list.  */\n@@ -3111,6 +3108,18 @@ cgraph_edge::binds_to_current_def_p ()\n     return false;\n }\n \n+/* Expected frequency of executions within the function.\n+   When set to CGRAPH_FREQ_BASE, the edge is expected to be called once\n+   per function call.  The range is 0 to CGRAPH_FREQ_MAX.  */\n+\n+inline int\n+cgraph_edge::frequency ()\n+{\n+  return count.to_cgraph_frequency (caller->global.inlined_to\n+\t\t\t\t    ? caller->global.inlined_to->count\n+\t\t\t\t    : caller->count);\n+}\n+\n /* Return true if the TM_CLONE bit is set for a given FNDECL.  */\n static inline bool\n decl_is_tm_clone (const_tree fndecl)"}, {"sha": "efb333cbae0dd0566919297925dc05f30632769b", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=1bad9c1806ac51abc2bf1bdf18b96924b1104ebb", "patch": "@@ -317,17 +317,15 @@ pass_build_cgraph_edges::execute (function *fun)\n \n \t  if (gcall *call_stmt = dyn_cast <gcall *> (stmt))\n \t    {\n-\t      int freq = compute_call_stmt_bb_frequency (current_function_decl,\n-\t\t\t\t\t\t\t bb);\n \t      decl = gimple_call_fndecl (call_stmt);\n \t      if (decl)\n-\t\tnode->create_edge (cgraph_node::get_create (decl), call_stmt, bb->count, freq);\n+\t\tnode->create_edge (cgraph_node::get_create (decl), call_stmt, bb->count);\n \t      else if (gimple_call_internal_p (call_stmt))\n \t\t;\n \t      else\n \t\tnode->create_indirect_edge (call_stmt,\n \t\t\t\t\t    gimple_call_flags (call_stmt),\n-\t\t\t\t\t    bb->count, freq);\n+\t\t\t\t\t    bb->count);\n \t    }\n \t  node->record_stmt_references (stmt);\n \t  if (gomp_parallel *omp_par_stmt = dyn_cast <gomp_parallel *> (stmt))\n@@ -402,7 +400,7 @@ cgraph_edge::rebuild_edges (void)\n   node->remove_callees ();\n   node->remove_all_references ();\n \n-  node->count = ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.ipa ();\n+  node->count = ENTRY_BLOCK_PTR_FOR_FN (cfun)->count;\n \n   FOR_EACH_BB_FN (bb, cfun)\n     {\n@@ -413,18 +411,16 @@ cgraph_edge::rebuild_edges (void)\n \n \t  if (gcall *call_stmt = dyn_cast <gcall *> (stmt))\n \t    {\n-\t      int freq = compute_call_stmt_bb_frequency (current_function_decl,\n-\t\t\t\t\t\t\t bb);\n \t      decl = gimple_call_fndecl (call_stmt);\n \t      if (decl)\n \t\tnode->create_edge (cgraph_node::get_create (decl), call_stmt,\n-\t\t\t\t   bb->count, freq);\n+\t\t\t\t   bb->count);\n \t      else if (gimple_call_internal_p (call_stmt))\n \t\t;\n \t      else\n \t\tnode->create_indirect_edge (call_stmt,\n \t\t\t\t\t    gimple_call_flags (call_stmt),\n-\t\t\t\t\t    bb->count, freq);\n+\t\t\t\t\t    bb->count);\n \t    }\n \t  node->record_stmt_references (stmt);\n \t}"}, {"sha": "a575a34b0c66d00311c56ded4dd02c6f1a0840c3", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 38, "deletions": 34, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=1bad9c1806ac51abc2bf1bdf18b96924b1104ebb", "patch": "@@ -87,20 +87,11 @@ along with GCC; see the file COPYING3.  If not see\n cgraph_edge *\n cgraph_edge::clone (cgraph_node *n, gcall *call_stmt, unsigned stmt_uid,\n \t\t    profile_count num, profile_count den,\n-\t\t    int freq_scale, bool update_original)\n+\t\t    bool update_original)\n {\n   cgraph_edge *new_edge;\n-  profile_count gcov_count\n-\t = (num == profile_count::zero () || den > 0)\n-\t   ? count.apply_scale (num, den) : count;\n-  gcov_type freq;\n-\n-  /* We do not want to ignore loop nest after frequency drops to 0.  */\n-  if (!freq_scale)\n-    freq_scale = 1;\n-  freq = frequency * (gcov_type) freq_scale / CGRAPH_FREQ_BASE;\n-  if (freq > CGRAPH_FREQ_MAX)\n-    freq = CGRAPH_FREQ_MAX;\n+  profile_count::adjust_for_ipa_scaling (&num, &den);\n+  profile_count gcov_count = count.apply_scale (num, den);\n \n   if (indirect_unknown_callee)\n     {\n@@ -113,19 +104,19 @@ cgraph_edge::clone (cgraph_node *n, gcall *call_stmt, unsigned stmt_uid,\n \t{\n \t  cgraph_node *callee = cgraph_node::get (decl);\n \t  gcc_checking_assert (callee);\n-\t  new_edge = n->create_edge (callee, call_stmt, gcov_count, freq);\n+\t  new_edge = n->create_edge (callee, call_stmt, gcov_count);\n \t}\n       else\n \t{\n \t  new_edge = n->create_indirect_edge (call_stmt,\n \t\t\t\t\t      indirect_info->ecf_flags,\n-\t\t\t\t\t      gcov_count, freq, false);\n+\t\t\t\t\t      gcov_count, false);\n \t  *new_edge->indirect_info = *indirect_info;\n \t}\n     }\n   else\n     {\n-      new_edge = n->create_edge (callee, call_stmt, gcov_count, freq);\n+      new_edge = n->create_edge (callee, call_stmt, gcov_count);\n       if (indirect_info)\n \t{\n \t  new_edge->indirect_info\n@@ -142,10 +133,14 @@ cgraph_edge::clone (cgraph_node *n, gcall *call_stmt, unsigned stmt_uid,\n   new_edge->call_stmt_cannot_inline_p = call_stmt_cannot_inline_p;\n   new_edge->speculative = speculative;\n   new_edge->in_polymorphic_cdtor = in_polymorphic_cdtor;\n-  if (update_original)\n-    {\n-      count -= new_edge->count;\n-    }\n+\n+  /* Update IPA profile.  Local profiles need no updating in original.  */\n+  if (update_original\n+      && count.ipa () == count && new_edge->count.ipa () == new_edge->count)\n+    count -= new_edge->count;\n+  else if (caller->count.global0 () == caller->count\n+\t   && !(count == profile_count::zero ()))\n+    count = count.global0 ();\n   symtab->call_edge_duplication_hooks (this, new_edge);\n   return new_edge;\n }\n@@ -337,8 +332,7 @@ duplicate_thunk_for_node (cgraph_node *thunk, cgraph_node *node)\n   new_thunk->clone.args_to_skip = node->clone.args_to_skip;\n   new_thunk->clone.combined_args_to_skip = node->clone.combined_args_to_skip;\n \n-  cgraph_edge *e = new_thunk->create_edge (node, NULL, new_thunk->count,\n-\t\t\t\t\t\t  CGRAPH_FREQ_BASE);\n+  cgraph_edge *e = new_thunk->create_edge (node, NULL, new_thunk->count);\n   symtab->call_edge_duplication_hooks (thunk->callees, e);\n   symtab->call_cgraph_duplication_hooks (thunk, new_thunk);\n   return new_thunk;\n@@ -422,7 +416,7 @@ dump_callgraph_transformation (const cgraph_node *original,\n    node is not inlined.  */\n \n cgraph_node *\n-cgraph_node::create_clone (tree new_decl, profile_count prof_count, int freq,\n+cgraph_node::create_clone (tree new_decl, profile_count prof_count,\n \t\t\t   bool update_original,\n \t\t\t   vec<cgraph_edge *> redirect_callers,\n \t\t\t   bool call_duplication_hook,\n@@ -432,11 +426,27 @@ cgraph_node::create_clone (tree new_decl, profile_count prof_count, int freq,\n   cgraph_node *new_node = symtab->create_empty ();\n   cgraph_edge *e;\n   unsigned i;\n+  profile_count old_count = count;\n \n   if (new_inlined_to)\n     dump_callgraph_transformation (this, new_inlined_to, \"inlining to\");\n \n+  if (prof_count == profile_count::zero ()\n+      && !(count == profile_count::zero ()))\n+    prof_count = count.global0 ();\n+\n   new_node->count = prof_count;\n+\n+  /* Update IPA profile.  Local profiles need no updating in original.  */\n+  if (update_original && !(count == profile_count::zero ())\n+      && count.ipa () == count && prof_count.ipa () == prof_count)\n+    {\n+      if (count.nonzero_p ()\n+\t  && !(count - prof_count).nonzero_p ())\n+\tcount = count.global0 ();\n+      else\n+        count -= prof_count;\n+    }\n   new_node->decl = new_decl;\n   new_node->register_symbol ();\n   new_node->origin = origin;\n@@ -489,12 +499,12 @@ cgraph_node::create_clone (tree new_decl, profile_count prof_count, int freq,\n   new_node->expand_all_artificial_thunks ();\n \n   for (e = callees;e; e=e->next_callee)\n-    e->clone (new_node, e->call_stmt, e->lto_stmt_uid, new_node->count, count,\n-\t      freq, update_original);\n+    e->clone (new_node, e->call_stmt, e->lto_stmt_uid, new_node->count, old_count,\n+\t      update_original);\n \n   for (e = indirect_calls; e; e = e->next_callee)\n     e->clone (new_node, e->call_stmt, e->lto_stmt_uid,\n-\t      new_node->count, count, freq, update_original);\n+\t      new_node->count, old_count, update_original);\n   new_node->clone_references (this);\n \n   new_node->next_sibling_clone = clones;\n@@ -503,9 +513,6 @@ cgraph_node::create_clone (tree new_decl, profile_count prof_count, int freq,\n   clones = new_node;\n   new_node->clone_of = this;\n \n-  if (update_original)\n-    count -= prof_count;\n-\n   if (call_duplication_hook)\n     symtab->call_cgraph_duplication_hooks (this, new_node);\n \n@@ -591,7 +598,7 @@ cgraph_node::create_virtual_clone (vec<cgraph_edge *> redirect_callers,\n   SET_DECL_ASSEMBLER_NAME (new_decl, clone_function_name (old_decl, suffix));\n   SET_DECL_RTL (new_decl, NULL);\n \n-  new_node = create_clone (new_decl, count, CGRAPH_FREQ_BASE, false,\n+  new_node = create_clone (new_decl, count, false,\n \t\t\t   redirect_callers, false, NULL, args_to_skip, suffix);\n \n   /* Update the properties.\n@@ -773,15 +780,14 @@ void\n cgraph_node::create_edge_including_clones (cgraph_node *callee,\n \t\t\t\t\t   gimple *old_stmt, gcall *stmt,\n \t\t\t\t\t   profile_count count,\n-\t\t\t\t\t   int freq,\n \t\t\t\t\t   cgraph_inline_failed_t reason)\n {\n   cgraph_node *node;\n   cgraph_edge *edge;\n \n   if (!get_edge (stmt))\n     {\n-      edge = create_edge (callee, stmt, count, freq);\n+      edge = create_edge (callee, stmt, count);\n       edge->inline_failed = reason;\n     }\n \n@@ -801,7 +807,7 @@ cgraph_node::create_edge_including_clones (cgraph_node *callee,\n \t    edge->set_call_stmt (stmt);\n \t  else if (! node->get_edge (stmt))\n \t    {\n-\t      edge = node->create_edge (callee, stmt, count, freq);\n+\t      edge = node->create_edge (callee, stmt, count);\n \t      edge->inline_failed = reason;\n \t    }\n \n@@ -904,14 +910,12 @@ cgraph_node::create_version_clone (tree new_decl,\n \t || bitmap_bit_p (bbs_to_copy, gimple_bb (e->call_stmt)->index))\n        e->clone (new_version, e->call_stmt,\n \t\t e->lto_stmt_uid, count, count,\n-\t\t CGRAPH_FREQ_BASE,\n \t\t true);\n    for (e = indirect_calls; e; e=e->next_callee)\n      if (!bbs_to_copy\n \t || bitmap_bit_p (bbs_to_copy, gimple_bb (e->call_stmt)->index))\n        e->clone (new_version, e->call_stmt,\n \t\t e->lto_stmt_uid, count, count,\n-\t\t CGRAPH_FREQ_BASE,\n \t\t true);\n    FOR_EACH_VEC_ELT (redirect_callers, i, e)\n      {"}, {"sha": "3b68d646ffa12f5113e79ad80936ec41a58b8789", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=1bad9c1806ac51abc2bf1bdf18b96924b1104ebb", "patch": "@@ -620,7 +620,7 @@ cgraph_node::analyze (void)\n     {\n       cgraph_node *t = cgraph_node::get (thunk.alias);\n \n-      create_edge (t, NULL, t->count, CGRAPH_FREQ_BASE);\n+      create_edge (t, NULL, t->count);\n       callees->can_throw_external = !TREE_NOTHROW (t->decl);\n       /* Target code in expand_thunk may need the thunk's target\n \t to be analyzed, so recurse here.  */\n@@ -1950,7 +1950,7 @@ cgraph_node::expand_thunk (bool output_asm_thunks, bool force_gimple_thunk)\n \t      resbnd = chkp_insert_retbnd_call (NULL, restmp, &bsi);\n \t      create_edge (get_create (gimple_call_fndecl (gsi_stmt (bsi))),\n \t\t\t   as_a <gcall *> (gsi_stmt (bsi)),\n-\t\t\t   callees->count, callees->frequency);\n+\t\t\t   callees->count);\n \t    }\n \n \t  if (restmp && !this_adjusting\n@@ -2759,7 +2759,7 @@ cgraph_node::create_wrapper (cgraph_node *target)\n \n   memset (&thunk, 0, sizeof (cgraph_thunk_info));\n   thunk.thunk_p = true;\n-  create_edge (target, NULL, count, CGRAPH_FREQ_BASE);\n+  create_edge (target, NULL, count);\n   callees->can_throw_external = !TREE_NOTHROW (target->decl);\n \n   tree arguments = DECL_ARGUMENTS (decl);"}, {"sha": "d9d02d305efa41df7a7d605d8d38bb45adc3bea6", "filename": "gcc/gimple-iterator.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Fgimple-iterator.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Fgimple-iterator.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-iterator.c?ref=1bad9c1806ac51abc2bf1bdf18b96924b1104ebb", "patch": "@@ -83,7 +83,6 @@ static void\n update_call_edge_frequencies (gimple_seq_node first, basic_block bb)\n {\n   struct cgraph_node *cfun_node = NULL;\n-  int bb_freq = 0;\n   gimple_seq_node n;\n \n   for (n = first; n ; n = n->next)\n@@ -94,15 +93,11 @@ update_call_edge_frequencies (gimple_seq_node first, basic_block bb)\n \t/* These function calls are expensive enough that we want\n \t   to avoid calling them if we never see any calls.  */\n \tif (cfun_node == NULL)\n-\t  {\n-\t    cfun_node = cgraph_node::get (current_function_decl);\n-\t    bb_freq = (compute_call_stmt_bb_frequency\n-\t\t       (current_function_decl, bb));\n-\t  }\n+\t  cfun_node = cgraph_node::get (current_function_decl);\n \n \te = cfun_node->get_edge (n);\n \tif (e != NULL)\n-\t  e->frequency = bb_freq;\n+\t  e->count = bb->count;\n       }\n }\n "}, {"sha": "56f748a23ae38c9058ef964da53215a0f44ae15e", "filename": "gcc/gimple-streamer-in.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Fgimple-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Fgimple-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-streamer-in.c?ref=1bad9c1806ac51abc2bf1bdf18b96924b1104ebb", "patch": "@@ -264,8 +264,11 @@ input_bb (struct lto_input_block *ib, enum LTO_tags tag,\n   index = streamer_read_uhwi (ib);\n   bb = BASIC_BLOCK_FOR_FN (fn, index);\n \n-  bb->count = profile_count::stream_in (ib).apply_scale\n-\t\t (count_materialization_scale, REG_BR_PROB_BASE);\n+  bb->count = profile_count::stream_in (ib);\n+  if (count_materialization_scale != REG_BR_PROB_BASE\n+      && bb->count.ipa ().nonzero_p ())\n+    bb->count\n+      = bb->count.apply_scale (count_materialization_scale, REG_BR_PROB_BASE);\n   bb->flags = streamer_read_hwi (ib);\n \n   /* LTO_bb1 has statements.  LTO_bb0 does not.  */"}, {"sha": "30684baa3f8aab12a2fa4a9b412808a81ece9b86", "filename": "gcc/ipa-chkp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Fipa-chkp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Fipa-chkp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-chkp.c?ref=1bad9c1806ac51abc2bf1bdf18b96924b1104ebb", "patch": "@@ -717,7 +717,7 @@ chkp_produce_thunks (bool early)\n \t  node->thunk.thunk_p = true;\n \t  node->thunk.add_pointer_bounds_args = true;\n \t  node->create_edge (node->instrumented_version, NULL,\n-\t\t\t     node->count, CGRAPH_FREQ_BASE);\n+\t\t\t     node->count);\n \t  node->create_reference (node->instrumented_version,\n \t\t\t       IPA_REF_CHKP, NULL);\n \t  /* Thunk shouldn't be a cdtor.  */"}, {"sha": "bc1e3ae799d873af6eb4ee5f5a11da7fc5cf339c", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=1bad9c1806ac51abc2bf1bdf18b96924b1104ebb", "patch": "@@ -498,7 +498,7 @@ ipcp_lattice<valtype>::print (FILE * f, bool dump_sources, bool dump_benefits)\n \t  fprintf (f, \" [from:\");\n \t  for (s = val->sources; s; s = s->next)\n \t    fprintf (f, \" %i(%i)\", s->cs->caller->order,\n-\t\t     s->cs->frequency);\n+\t\t     s->cs->frequency ());\n \t  fprintf (f, \"]\");\n \t}\n \n@@ -677,9 +677,9 @@ gather_caller_stats (struct cgraph_node *node, void *data)\n   for (cs = node->callers; cs; cs = cs->next_caller)\n     if (!cs->caller->thunk.thunk_p)\n       {\n-        if (cs->count.initialized_p ())\n-\t  stats->count_sum += cs->count;\n-\tstats->freq_sum += cs->frequency;\n+        if (cs->count.ipa ().initialized_p ())\n+\t  stats->count_sum += cs->count.ipa ();\n+\tstats->freq_sum += cs->frequency ();\n \tstats->n_calls++;\n \tif (cs->maybe_hot_p ())\n \t  stats->n_hot_calls ++;\n@@ -731,7 +731,7 @@ ipcp_cloning_candidate_p (struct cgraph_node *node)\n      significantly.  */\n   if (max_count > profile_count::zero ())\n     {\n-      if (stats.count_sum > node->count.apply_scale (90, 100))\n+      if (stats.count_sum > node->count.ipa ().apply_scale (90, 100))\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file, \"Considering %s for cloning; \"\n@@ -3272,7 +3272,7 @@ ipcp_propagate_stage (struct ipa_topo_info *topo)\n       }\n     if (node->definition && !node->alias)\n       overall_size += ipa_fn_summaries->get (node)->self_size;\n-    max_count = max_count.max (node->count);\n+    max_count = max_count.max (node->count.ipa ());\n   }\n \n   max_new_size = overall_size;\n@@ -3550,9 +3550,9 @@ get_info_about_necessary_edges (ipcp_value<valtype> *val, cgraph_node *dest,\n \t  if (cgraph_edge_brings_value_p (cs, src, dest))\n \t    {\n \t      count++;\n-\t      freq += cs->frequency;\n-\t      if (cs->count.initialized_p ())\n-\t        cnt += cs->count;\n+\t      freq += cs->frequency ();\n+\t      if (cs->count.ipa ().initialized_p ())\n+\t        cnt += cs->count.ipa ();\n \t      hot |= cs->maybe_hot_p ();\n \t    }\n \t  cs = get_next_cgraph_edge_clone (cs);\n@@ -3662,7 +3662,7 @@ update_profiling_info (struct cgraph_node *orig_node,\n   profile_count new_sum, orig_sum;\n   profile_count remainder, orig_node_count = orig_node->count;\n \n-  if (!(orig_node_count > profile_count::zero ()))\n+  if (!(orig_node_count.ipa () > profile_count::zero ()))\n     return;\n \n   init_caller_stats (&stats);\n@@ -3701,7 +3701,7 @@ update_profiling_info (struct cgraph_node *orig_node,\n \n   for (cs = new_node->callees; cs; cs = cs->next_callee)\n     /* FIXME: why we care about non-zero frequency here?  */\n-    if (cs->frequency)\n+    if (cs->frequency ())\n       cs->count = cs->count.apply_scale (new_sum, orig_node_count);\n     else\n       cs->count = profile_count::zero ();\n@@ -3741,7 +3741,7 @@ update_specialized_profile (struct cgraph_node *new_node,\n   orig_node->count -= redirected_sum;\n \n   for (cs = new_node->callees; cs; cs = cs->next_callee)\n-    if (cs->frequency)\n+    if (cs->frequency ())\n       cs->count += cs->count.apply_scale (redirected_sum, new_node_count);\n     else\n       cs->count = profile_count::zero ();\n@@ -4463,8 +4463,8 @@ perhaps_add_new_callers (cgraph_node *node, ipcp_value<valtype> *val)\n \n \t      cs->redirect_callee_duplicating_thunks (val->spec_node);\n \t      val->spec_node->expand_all_artificial_thunks ();\n-\t      if (cs->count.initialized_p ())\n-\t        redirected_sum = redirected_sum + cs->count;\n+\t      if (cs->count.ipa ().initialized_p ())\n+\t        redirected_sum = redirected_sum + cs->count.ipa ();\n \t    }\n \t  cs = get_next_cgraph_edge_clone (cs);\n \t}"}, {"sha": "540f038a2d5f84b4f6c06791914b3c258fa90138", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=1bad9c1806ac51abc2bf1bdf18b96924b1104ebb", "patch": "@@ -3566,7 +3566,7 @@ ipa_devirt (void)\n \t    bool final;\n \n \t    if (final_warning_records)\n-\t      final_warning_records->dyn_count = e->count;\n+\t      final_warning_records->dyn_count = e->count.ipa ();\n \n \t    vec <cgraph_node *>targets\n \t       = possible_polymorphic_call_targets\n@@ -3727,8 +3727,7 @@ ipa_devirt (void)\n \t\tnconverted++;\n \t\tupdate = true;\n \t\te->make_speculative\n-\t\t  (likely_target, e->count.apply_scale (8, 10),\n-\t\t   e->frequency * 8 / 10);\n+\t\t  (likely_target, e->count.apply_scale (8, 10));\n \t      }\n \t  }\n       if (update)"}, {"sha": "6c0e4370066221dc0986d71667e1d44bd0a8710d", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=1bad9c1806ac51abc2bf1bdf18b96924b1104ebb", "patch": "@@ -244,7 +244,6 @@ redirect_to_unreachable (struct cgraph_edge *e)\n     e->redirect_callee (target);\n   struct ipa_call_summary *es = ipa_call_summaries->get (e);\n   e->inline_failed = CIF_UNREACHABLE;\n-  e->frequency = 0;\n   e->count = profile_count::zero ();\n   es->call_stmt_size = 0;\n   es->call_stmt_time = 0;\n@@ -823,7 +822,7 @@ dump_ipa_call_summary (FILE *f, int indent, struct cgraph_node *node,\n \t       indent, \"\", callee->name (), callee->order,\n \t       !edge->inline_failed\n \t       ? \"inlined\" : cgraph_inline_failed_string (edge-> inline_failed),\n-\t       indent, \"\", es->loop_depth, edge->frequency,\n+\t       indent, \"\", es->loop_depth, edge->frequency (),\n \t       es->call_stmt_size, es->call_stmt_time,\n \t       (int) ipa_fn_summaries->get (callee)->size / ipa_fn_summary::size_scale,\n \t       (int) ipa_fn_summaries->get (callee)->estimated_stack_size);\n@@ -865,7 +864,7 @@ dump_ipa_call_summary (FILE *f, int indent, struct cgraph_node *node,\n \t       \" time: %2i\",\n \t       indent, \"\",\n \t       es->loop_depth,\n-\t       edge->frequency, es->call_stmt_size, es->call_stmt_time);\n+\t       edge->frequency (), es->call_stmt_size, es->call_stmt_time);\n       if (es->predicate)\n \t{\n \t  fprintf (f, \"predicate: \");\n@@ -2579,9 +2578,9 @@ estimate_edge_size_and_time (struct cgraph_edge *e, int *size, int *min_size,\n   if (min_size)\n     *min_size += cur_size;\n   if (prob == REG_BR_PROB_BASE)\n-    *time += ((sreal)(call_time * e->frequency)) / CGRAPH_FREQ_BASE;\n+    *time += ((sreal)(call_time * e->frequency ())) / CGRAPH_FREQ_BASE;\n   else\n-    *time += ((sreal)call_time) * (prob * e->frequency)\n+    *time += ((sreal)call_time) * (prob * e->frequency ())\n \t      / (CGRAPH_FREQ_BASE * REG_BR_PROB_BASE);\n }\n \n@@ -3059,7 +3058,7 @@ ipa_merge_fn_summary_after_inlining (struct cgraph_edge *edge)\n \t\t\t\t      toplev_predicate);\n       if (p != false && nonconstp != false)\n \t{\n-\t  sreal add_time = ((sreal)e->time * edge->frequency) / CGRAPH_FREQ_BASE;\n+\t  sreal add_time = ((sreal)e->time * edge->frequency ()) / CGRAPH_FREQ_BASE;\n \t  int prob = e->nonconst_predicate.probability (callee_info->conds,\n \t\t\t\t\t\t\tclause, es->param);\n \t  add_time = add_time * prob / REG_BR_PROB_BASE;"}, {"sha": "54a441f142dbc60c1e78e600c06e5cfe1b5d55c7", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=1bad9c1806ac51abc2bf1bdf18b96924b1104ebb", "patch": "@@ -175,11 +175,11 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n      edges and for those we disable size limits.  Don't do that when\n      probability that caller will call the callee is low however, since it\n      may hurt optimization of the caller's hot path.  */\n-  if (edge->count.initialized_p () && edge->maybe_hot_p ()\n-      && (edge->count.apply_scale (2, 1)\n+  if (edge->count.ipa ().initialized_p () && edge->maybe_hot_p ()\n+      && (edge->count.ipa ().apply_scale (2, 1)\n           > (edge->caller->global.inlined_to\n-\t     ? edge->caller->global.inlined_to->count\n-\t     : edge->caller->count)))\n+\t     ? edge->caller->global.inlined_to->count.ipa ()\n+\t     : edge->caller->count.ipa ())))\n     hints |= INLINE_HINT_known_hot;\n \n   known_vals.release ();"}, {"sha": "8e66483016a604ad1815b7064f91c0863813c3d1", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 11, "deletions": 28, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=1bad9c1806ac51abc2bf1bdf18b96924b1104ebb", "patch": "@@ -51,36 +51,24 @@ along with GCC; see the file COPYING3.  If not see\n int ncalls_inlined;\n int nfunctions_inlined;\n \n-/* Scale frequency of NODE edges by FREQ_SCALE.  */\n+/* Scale counts of NODE edges by NUM/DEN.  */\n \n static void\n-update_noncloned_frequencies (struct cgraph_node *node, \n-\t\t\t      int freq_scale, profile_count num,\n-\t\t\t      profile_count den)\n+update_noncloned_counts (struct cgraph_node *node, \n+\t\t\t profile_count num, profile_count den)\n {\n   struct cgraph_edge *e;\n \n   profile_count::adjust_for_ipa_scaling (&num, &den);\n \n-  /* We do not want to ignore high loop nest after freq drops to 0.  */\n-  if (!freq_scale)\n-    freq_scale = 1;\n   for (e = node->callees; e; e = e->next_callee)\n     {\n-      e->frequency = e->frequency * (gcov_type) freq_scale / CGRAPH_FREQ_BASE;\n-      if (e->frequency > CGRAPH_FREQ_MAX)\n-        e->frequency = CGRAPH_FREQ_MAX;\n       if (!e->inline_failed)\n-        update_noncloned_frequencies (e->callee, freq_scale, num, den);\n+        update_noncloned_counts (e->callee, num, den);\n       e->count = e->count.apply_scale (num, den);\n     }\n   for (e = node->indirect_calls; e; e = e->next_callee)\n-    {\n-      e->frequency = e->frequency * (gcov_type) freq_scale / CGRAPH_FREQ_BASE;\n-      if (e->frequency > CGRAPH_FREQ_MAX)\n-        e->frequency = CGRAPH_FREQ_MAX;\n-      e->count = e->count.apply_scale (num, den);\n-    }\n+    e->count = e->count.apply_scale (num, den);\n   node->count = node->count.apply_scale (num, den);\n }\n \n@@ -169,12 +157,11 @@ master_clone_with_noninline_clones_p (struct cgraph_node *node)\n    By default the offline copy is removed, when it appears dead after inlining.\n    UPDATE_ORIGINAL prevents this transformation.\n    If OVERALL_SIZE is non-NULL, the size is updated to reflect the\n-   transformation.\n-   FREQ_SCALE specify the scaling of frequencies of call sites.  */\n+   transformation.  */\n \n void\n clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n-\t\t     bool update_original, int *overall_size, int freq_scale)\n+\t\t     bool update_original, int *overall_size)\n {\n   struct cgraph_node *inlining_into;\n   struct cgraph_edge *next;\n@@ -218,8 +205,7 @@ clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n \t    }\n \t  duplicate = false;\n \t  e->callee->externally_visible = false;\n-          update_noncloned_frequencies (e->callee, e->frequency,\n-\t\t\t\t\te->count, e->callee->count);\n+          update_noncloned_counts (e->callee, e->count, e->callee->count);\n \n \t  dump_callgraph_transformation (e->callee, inlining_into,\n \t\t\t\t\t \"inlining to\");\n@@ -228,11 +214,8 @@ clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n \t{\n \t  struct cgraph_node *n;\n \n-\t  if (freq_scale == -1)\n-\t    freq_scale = e->frequency;\n \t  n = e->callee->create_clone (e->callee->decl,\n-\t\t\t\t       MIN (e->count, e->callee->count),\n-\t\t\t\t       freq_scale,\n+\t\t\t\t       e->count,\n \t\t\t\t       update_original, vNULL, true,\n \t\t\t\t       inlining_into,\n \t\t\t\t       NULL);\n@@ -250,7 +233,7 @@ clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n     {\n       next = e->next_callee;\n       if (!e->inline_failed)\n-        clone_inlined_nodes (e, duplicate, update_original, overall_size, freq_scale);\n+        clone_inlined_nodes (e, duplicate, update_original, overall_size);\n     }\n }\n \n@@ -457,7 +440,7 @@ inline_call (struct cgraph_edge *e, bool update_original,\n \t}\n     }\n \n-  clone_inlined_nodes (e, true, update_original, overall_size, e->frequency);\n+  clone_inlined_nodes (e, true, update_original, overall_size);\n \n   gcc_assert (curr->callee->global.inlined_to == to);\n "}, {"sha": "3128f320bddc5d9f508b51a13e5bd2ffe16d2b7a", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 106, "deletions": 99, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=1bad9c1806ac51abc2bf1bdf18b96924b1104ebb", "patch": "@@ -640,12 +640,12 @@ compute_uninlined_call_time (struct cgraph_edge *edge,\n \t\t\t ? edge->caller->global.inlined_to\n \t\t\t : edge->caller);\n \n-  if (edge->count.nonzero_p ()\n-      && caller->count.nonzero_p ())\n-    uninlined_call_time *= (sreal)edge->count.to_gcov_type ()\n-\t\t\t   / caller->count.to_gcov_type ();\n-  if (edge->frequency)\n-    uninlined_call_time *= cgraph_freq_base_rec * edge->frequency;\n+  if (edge->count.ipa ().nonzero_p ()\n+      && caller->count.ipa ().nonzero_p ())\n+    uninlined_call_time *= (sreal)edge->count.ipa ().to_gcov_type ()\n+\t\t\t   / caller->count.ipa ().to_gcov_type ();\n+  if (edge->frequency ())\n+    uninlined_call_time *= cgraph_freq_base_rec * edge->frequency ();\n   else\n     uninlined_call_time = uninlined_call_time >> 11;\n \n@@ -665,17 +665,17 @@ compute_inlined_call_time (struct cgraph_edge *edge,\n \t\t\t : edge->caller);\n   sreal caller_time = ipa_fn_summaries->get (caller)->time;\n \n-  if (edge->count.nonzero_p ()\n-      && caller->count.nonzero_p ())\n+  if (edge->count.ipa ().nonzero_p ()\n+      && caller->count.ipa ().nonzero_p ())\n     time *= (sreal)edge->count.to_gcov_type () / caller->count.to_gcov_type ();\n-  if (edge->frequency)\n-    time *= cgraph_freq_base_rec * edge->frequency;\n+  if (edge->frequency ())\n+    time *= cgraph_freq_base_rec * edge->frequency ();\n   else\n     time = time >> 11;\n \n   /* This calculation should match one in ipa-inline-analysis.c\n      (estimate_edge_size_and_time).  */\n-  time -= (sreal) edge->frequency\n+  time -= (sreal) edge->frequency ()\n \t   * ipa_call_summaries->get (edge)->call_stmt_time / CGRAPH_FREQ_BASE;\n   time += caller_time;\n   if (time <= 0)\n@@ -724,7 +724,7 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n      promote non-inline functions to inline and we increase\n      MAX_INLINE_INSNS_SINGLE 16-fold for inline functions.  */\n   else if ((!DECL_DECLARED_INLINE_P (callee->decl)\n-\t   && (!e->count.initialized_p () || !e->maybe_hot_p ()))\n+\t   && (!e->count.ipa ().initialized_p () || !e->maybe_hot_p ()))\n \t   && ipa_fn_summaries->get (callee)->min_size\n \t\t- ipa_call_summaries->get (e)->call_stmt_size\n \t      > MAX (MAX_INLINE_INSNS_SINGLE, MAX_INLINE_INSNS_AUTO))\n@@ -733,7 +733,7 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n       want_inline = false;\n     }\n   else if ((DECL_DECLARED_INLINE_P (callee->decl)\n-\t    || e->count.nonzero_p ())\n+\t    || e->count.ipa ().nonzero_p ())\n \t   && ipa_fn_summaries->get (callee)->min_size\n \t\t- ipa_call_summaries->get (e)->call_stmt_size\n \t      > 16 * MAX_INLINE_INSNS_SINGLE)\n@@ -843,7 +843,7 @@ want_inline_self_recursive_call_p (struct cgraph_edge *edge,\n       reason = \"recursive call is cold\";\n       want_inline = false;\n     }\n-  else if (!outer_node->count.nonzero_p ())\n+  else if (!outer_node->count.ipa ().nonzero_p ())\n     {\n       reason = \"not executed in profile\";\n       want_inline = false;\n@@ -855,7 +855,7 @@ want_inline_self_recursive_call_p (struct cgraph_edge *edge,\n     }\n \n   if (outer_node->global.inlined_to)\n-    caller_freq = outer_node->callers->frequency;\n+    caller_freq = outer_node->callers->frequency ();\n \n   if (!caller_freq)\n     {\n@@ -881,16 +881,16 @@ want_inline_self_recursive_call_p (struct cgraph_edge *edge,\n       int i;\n       for (i = 1; i < depth; i++)\n \tmax_prob = max_prob * max_prob / CGRAPH_FREQ_BASE;\n-      if (max_count.nonzero_p () && edge->count.nonzero_p () \n-\t  && (edge->count.to_gcov_type () * CGRAPH_FREQ_BASE\n-\t      / outer_node->count.to_gcov_type ()\n+      if (max_count.nonzero_p () && edge->count.ipa ().nonzero_p () \n+\t  && (edge->count.ipa ().to_gcov_type () * CGRAPH_FREQ_BASE\n+\t      / outer_node->count.ipa ().to_gcov_type ()\n \t      >= max_prob))\n \t{\n \t  reason = \"profile of recursive call is too large\";\n \t  want_inline = false;\n \t}\n       if (!max_count.nonzero_p ()\n-\t  && (edge->frequency * CGRAPH_FREQ_BASE / caller_freq\n+\t  && (edge->frequency () * CGRAPH_FREQ_BASE / caller_freq\n \t      >= max_prob))\n \t{\n \t  reason = \"frequency of recursive call is too large\";\n@@ -915,17 +915,17 @@ want_inline_self_recursive_call_p (struct cgraph_edge *edge,\n      methods.  */\n   else\n     {\n-      if (max_count.nonzero_p () && edge->count.initialized_p ()\n-\t  && (edge->count.to_gcov_type () * 100\n-\t      / outer_node->count.to_gcov_type ()\n+      if (max_count.nonzero_p () && edge->count.ipa ().initialized_p ()\n+\t  && (edge->count.ipa ().to_gcov_type () * 100\n+\t      / outer_node->count.ipa ().to_gcov_type ()\n \t      <= PARAM_VALUE (PARAM_MIN_INLINE_RECURSIVE_PROBABILITY)))\n \t{\n \t  reason = \"profile of recursive call is too small\";\n \t  want_inline = false;\n \t}\n       else if ((!max_count.nonzero_p ()\n-\t        || !edge->count.initialized_p ())\n-\t       && (edge->frequency * 100 / caller_freq\n+\t        || !edge->count.ipa ().initialized_p ())\n+\t       && (edge->frequency () * 100 / caller_freq\n \t           <= PARAM_VALUE (PARAM_MIN_INLINE_RECURSIVE_PROBABILITY)))\n \t{\n \t  reason = \"frequency of recursive call is too small\";\n@@ -1023,8 +1023,11 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n   edge_time = estimate_edge_time (edge, &unspec_edge_time);\n   hints = estimate_edge_hints (edge);\n   gcc_checking_assert (edge_time >= 0);\n-  /* Check that inlined time is better, but tolerate some roundoff issues.  */\n-  gcc_checking_assert ((edge_time - callee_info->time).to_int () <= 0);\n+  /* Check that inlined time is better, but tolerate some roundoff issues.\n+     FIXME: When callee profile drops to 0 we account calls more.  This\n+     should be fixed by never doing that.  */\n+  gcc_checking_assert ((edge_time - callee_info->time).to_int () <= 0\n+\t\t\t|| callee->count.ipa ().initialized_p ());\n   gcc_checking_assert (growth <= callee_info->size);\n \n   if (dump)\n@@ -1070,7 +1073,7 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n      then calls without.\n   */\n   else if (opt_for_fn (caller->decl, flag_guess_branch_prob)\n-\t   || caller->count.nonzero_p ())\n+\t   || caller->count.ipa ().nonzero_p ())\n     {\n       sreal numerator, denominator;\n       int overall_growth;\n@@ -1080,9 +1083,9 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \t\t   - inlined_time);\n       if (numerator == 0)\n \tnumerator = ((sreal) 1 >> 8);\n-      if (caller->count.nonzero_p ())\n-\tnumerator *= caller->count.to_gcov_type ();\n-      else if (caller->count.initialized_p ())\n+      if (caller->count.ipa ().nonzero_p ())\n+\tnumerator *= caller->count.ipa ().to_gcov_type ();\n+      else if (caller->count.ipa ().initialized_p ())\n \tnumerator = numerator >> 11;\n       denominator = growth;\n \n@@ -1108,14 +1111,14 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \t  && callee_info->single_caller\n \t  && !edge->caller->global.inlined_to\n \t  /* ... and edges executed only conditionally ... */\n-\t  && edge->frequency < CGRAPH_FREQ_BASE\n+\t  && edge->frequency () < CGRAPH_FREQ_BASE\n \t  /* ... consider case where callee is not inline but caller is ... */\n \t  && ((!DECL_DECLARED_INLINE_P (edge->callee->decl)\n \t       && DECL_DECLARED_INLINE_P (caller->decl))\n \t      /* ... or when early optimizers decided to split and edge\n \t\t frequency still indicates splitting is a win ... */\n \t      || (callee->split_part && !caller->split_part\n-\t\t  && edge->frequency\n+\t\t  && edge->frequency ()\n \t\t     < CGRAPH_FREQ_BASE\n \t\t       * PARAM_VALUE\n \t\t\t  (PARAM_PARTIAL_INLINING_ENTRY_PROBABILITY) / 100\n@@ -1166,9 +1169,9 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \t\t   \" overall growth %i (current) %i (original)\"\n \t\t   \" %i (compensated)\\n\",\n \t\t   badness.to_double (),\n-\t\t  (double)edge->frequency / CGRAPH_FREQ_BASE,\n-\t\t   edge->count.initialized_p () ? edge->count.to_gcov_type () : -1,\n-\t\t   caller->count.initialized_p () ? caller->count.to_gcov_type () : -1,\n+\t\t  (double)edge->frequency () / CGRAPH_FREQ_BASE,\n+\t\t   edge->count.ipa ().initialized_p () ? edge->count.ipa ().to_gcov_type () : -1,\n+\t\t   caller->count.ipa ().initialized_p () ? caller->count.ipa ().to_gcov_type () : -1,\n \t\t   compute_uninlined_call_time (edge,\n \t\t\t\t\t\tunspec_edge_time).to_double (),\n \t\t   compute_inlined_call_time (edge, edge_time).to_double (),\n@@ -1430,8 +1433,8 @@ lookup_recursive_calls (struct cgraph_node *node, struct cgraph_node *where,\n       {\n \t/* When profile feedback is available, prioritize by expected number\n \t   of calls.  */\n-        heap->insert (!(max_count > 0) || !e->count.initialized_p () ? -e->frequency\n-\t\t      : -(e->count.to_gcov_type ()\n+        heap->insert (!(max_count > 0) || !e->count.ipa ().initialized_p () ? -e->frequency ()\n+\t\t      : -(e->count.ipa ().to_gcov_type ()\n \t\t\t/ ((max_count.to_gcov_type () + (1<<24) - 1)\n \t\t\t   / (1<<24))),\n \t\t      e);\n@@ -1533,11 +1536,10 @@ recursive_inlining (struct cgraph_edge *edge,\n \t{\n \t  /* We need original clone to copy around.  */\n \t  master_clone = node->create_clone (node->decl, node->count,\n-\t    CGRAPH_FREQ_BASE, false, vNULL,\n-\t    true, NULL, NULL);\n+\t    false, vNULL, true, NULL, NULL);\n \t  for (e = master_clone->callees; e; e = e->next_callee)\n \t    if (!e->inline_failed)\n-\t      clone_inlined_nodes (e, true, false, NULL, CGRAPH_FREQ_BASE);\n+\t      clone_inlined_nodes (e, true, false, NULL);\n \t  curr->redirect_callee (master_clone);\n           reset_edge_growth_cache (curr);\n \t}\n@@ -1684,8 +1686,8 @@ resolve_noninline_speculation (edge_heap_t *edge_heap, struct cgraph_edge *edge)\n \t\t\t\t  ? node->global.inlined_to : node;\n       auto_bitmap updated_nodes;\n \n-      if (edge->count.initialized_p ())\n-        spec_rem += edge->count;\n+      if (edge->count.ipa ().initialized_p ())\n+        spec_rem += edge->count.ipa ();\n       edge->resolve_speculation ();\n       reset_edge_caches (where);\n       ipa_update_overall_fn_summary (where);\n@@ -1790,7 +1792,7 @@ inline_small_functions (void)\n \t  }\n \n \tfor (edge = node->callers; edge; edge = edge->next_caller)\n-\t  max_count = max_count.max (edge->count);\n+\t  max_count = max_count.max (edge->count.ipa ());\n       }\n   ipa_free_postorder_info ();\n   initialize_growth_caches ();\n@@ -1874,35 +1876,40 @@ inline_small_functions (void)\n \tcontinue;\n \n #if CHECKING_P\n-      /* Be sure that caches are maintained consistent.  */\n-      sreal cached_badness = edge_badness (edge, false);\n- \n-      int old_size_est = estimate_edge_size (edge);\n-      sreal old_time_est = estimate_edge_time (edge);\n-      int old_hints_est = estimate_edge_hints (edge);\n-\n-      reset_edge_growth_cache (edge);\n-      gcc_assert (old_size_est == estimate_edge_size (edge));\n-      gcc_assert (old_time_est == estimate_edge_time (edge));\n-      /* FIXME:\n-\n-         gcc_assert (old_hints_est == estimate_edge_hints (edge));\n-\n-\t fails with profile feedback because some hints depends on\n-\t maybe_hot_edge_p predicate and because callee gets inlined to other\n-\t calls, the edge may become cold.\n-\t This ought to be fixed by computing relative probabilities\n-\t for given invocation but that will be better done once whole\n-\t code is converted to sreals.  Disable for now and revert to \"wrong\"\n-\t value so enable/disable checking paths agree.  */\n-      edge_growth_cache[edge->uid].hints = old_hints_est + 1;\n-\n-      /* When updating the edge costs, we only decrease badness in the keys.\n-\t Increases of badness are handled lazilly; when we see key with out\n-\t of date value on it, we re-insert it now.  */\n-      current_badness = edge_badness (edge, false);\n-      gcc_assert (cached_badness == current_badness);\n-      gcc_assert (current_badness >= badness);\n+      /* Be sure that caches are maintained consistent.\n+\t This check is affected by scaling roundoff errors when compiling for\n+\t IPA this we skip it in that case.  */\n+      if (!edge->callee->count.ipa_p ())\n+\t{\n+\t  sreal cached_badness = edge_badness (edge, false);\n+     \n+\t  int old_size_est = estimate_edge_size (edge);\n+\t  sreal old_time_est = estimate_edge_time (edge);\n+\t  int old_hints_est = estimate_edge_hints (edge);\n+\n+\t  reset_edge_growth_cache (edge);\n+\t  gcc_assert (old_size_est == estimate_edge_size (edge));\n+\t  gcc_assert (old_time_est == estimate_edge_time (edge));\n+\t  /* FIXME:\n+\n+\t     gcc_assert (old_hints_est == estimate_edge_hints (edge));\n+\n+\t     fails with profile feedback because some hints depends on\n+\t     maybe_hot_edge_p predicate and because callee gets inlined to other\n+\t     calls, the edge may become cold.\n+\t     This ought to be fixed by computing relative probabilities\n+\t     for given invocation but that will be better done once whole\n+\t     code is converted to sreals.  Disable for now and revert to \"wrong\"\n+\t     value so enable/disable checking paths agree.  */\n+\t  edge_growth_cache[edge->uid].hints = old_hints_est + 1;\n+\n+\t  /* When updating the edge costs, we only decrease badness in the keys.\n+\t     Increases of badness are handled lazilly; when we see key with out\n+\t     of date value on it, we re-insert it now.  */\n+\t  current_badness = edge_badness (edge, false);\n+\t  gcc_assert (cached_badness == current_badness);\n+\t  gcc_assert (current_badness >= badness);\n+\t}\n #else\n       current_badness = edge_badness (edge, false);\n #endif\n@@ -1945,11 +1952,11 @@ inline_small_functions (void)\n \t\t   ? gimple_lineno ((const gimple *) edge->call_stmt)\n \t\t   : -1,\n \t\t   badness.to_double (),\n-\t\t   edge->frequency / (double)CGRAPH_FREQ_BASE);\n-\t  if (edge->count.initialized_p ())\n+\t\t   edge->frequency () / (double)CGRAPH_FREQ_BASE);\n+\t  if (edge->count.ipa ().initialized_p ())\n \t    {\n \t      fprintf (dump_file, \" Called \");\n-\t      edge->count.dump (dump_file);\n+\t      edge->count.ipa ().dump (dump_file);\n \t      fprintf (dump_file, \"times\\n\");\n             }\n \t  if (dump_flags & TDF_DETAILS)\n@@ -2255,8 +2262,8 @@ dump_overall_stats (void)\n       {\n \tsreal time = ipa_fn_summaries->get (node)->time;\n \tsum += time;\n-\tif (node->count.initialized_p ())\n-\t  sum_weighted += time * node->count.to_gcov_type ();\n+\tif (node->count.ipa ().initialized_p ())\n+\t  sum_weighted += time * node->count.ipa ().to_gcov_type ();\n       }\n   fprintf (dump_file, \"Overall time estimate: \"\n \t   \"%f weighted by profile: \"\n@@ -2286,57 +2293,57 @@ dump_inline_stats (void)\n       {\n \tif (e->inline_failed)\n \t  {\n-\t    if (e->count.initialized_p ())\n-\t      reason[(int) e->inline_failed][0] += e->count.to_gcov_type ();\n-\t    reason[(int) e->inline_failed][1] += e->frequency;\n+\t    if (e->count.ipa ().initialized_p ())\n+\t      reason[(int) e->inline_failed][0] += e->count.ipa ().to_gcov_type ();\n+\t    reason[(int) e->inline_failed][1] += e->frequency ();\n \t    reason[(int) e->inline_failed][2] ++;\n \t    if (DECL_VIRTUAL_P (e->callee->decl)\n-\t\t&& e->count.initialized_p ())\n+\t\t&& e->count.ipa ().initialized_p ())\n \t      {\n \t\tif (e->indirect_inlining_edge)\n-\t\t  noninlined_virt_indir_cnt += e->count.to_gcov_type ();\n+\t\t  noninlined_virt_indir_cnt += e->count.ipa ().to_gcov_type ();\n \t\telse\n-\t\t  noninlined_virt_cnt += e->count.to_gcov_type ();\n+\t\t  noninlined_virt_cnt += e->count.ipa ().to_gcov_type ();\n \t      }\n-\t    else if (e->count.initialized_p ())\n+\t    else if (e->count.ipa ().initialized_p ())\n \t      {\n \t\tif (e->indirect_inlining_edge)\n-\t\t  noninlined_indir_cnt += e->count.to_gcov_type ();\n+\t\t  noninlined_indir_cnt += e->count.ipa ().to_gcov_type ();\n \t\telse\n-\t\t  noninlined_cnt += e->count.to_gcov_type ();\n+\t\t  noninlined_cnt += e->count.ipa ().to_gcov_type ();\n \t      }\n \t  }\n-\telse if (e->count.initialized_p ())\n+\telse if (e->count.ipa ().initialized_p ())\n \t  {\n \t    if (e->speculative)\n \t      {\n \t\tif (DECL_VIRTUAL_P (e->callee->decl))\n-\t\t  inlined_speculative_ply += e->count.to_gcov_type ();\n+\t\t  inlined_speculative_ply += e->count.ipa ().to_gcov_type ();\n \t\telse\n-\t\t  inlined_speculative += e->count.to_gcov_type ();\n+\t\t  inlined_speculative += e->count.ipa ().to_gcov_type ();\n \t      }\n \t    else if (DECL_VIRTUAL_P (e->callee->decl))\n \t      {\n \t\tif (e->indirect_inlining_edge)\n-\t\t  inlined_virt_indir_cnt += e->count.to_gcov_type ();\n+\t\t  inlined_virt_indir_cnt += e->count.ipa ().to_gcov_type ();\n \t\telse\n-\t\t  inlined_virt_cnt += e->count.to_gcov_type ();\n+\t\t  inlined_virt_cnt += e->count.ipa ().to_gcov_type ();\n \t      }\n \t    else\n \t      {\n \t\tif (e->indirect_inlining_edge)\n-\t\t  inlined_indir_cnt += e->count.to_gcov_type ();\n+\t\t  inlined_indir_cnt += e->count.ipa ().to_gcov_type ();\n \t\telse\n-\t\t  inlined_cnt += e->count.to_gcov_type ();\n+\t\t  inlined_cnt += e->count.ipa ().to_gcov_type ();\n \t      }\n \t  }\n       }\n     for (e = node->indirect_calls; e; e = e->next_callee)\n       if (e->indirect_info->polymorphic\n-\t  & e->count.initialized_p ())\n-\tindirect_poly_cnt += e->count.to_gcov_type ();\n-      else if (e->count.initialized_p ())\n-\tindirect_cnt += e->count.to_gcov_type ();\n+\t  & e->count.ipa ().initialized_p ())\n+\tindirect_poly_cnt += e->count.ipa ().to_gcov_type ();\n+      else if (e->count.ipa ().initialized_p ())\n+\tindirect_cnt += e->count.ipa ().to_gcov_type ();\n   }\n   if (max_count.initialized_p ())\n     {\n@@ -2488,8 +2495,8 @@ ipa_inline (void)\n \t      next = edge->next_callee;\n \t      if (edge->speculative && !speculation_useful_p (edge, false))\n \t\t{\n-\t\t  if (edge->count.initialized_p ())\n-\t\t    spec_rem += edge->count;\n+\t\t  if (edge->count.ipa ().initialized_p ())\n+\t\t    spec_rem += edge->count.ipa ();\n \t\t  edge->resolve_speculation ();\n \t\t  update = true;\n \t\t  remove_functions = true;"}, {"sha": "ebf5d9718fbdb452f30c6eb02daa8c08e62a4c2a", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=1bad9c1806ac51abc2bf1bdf18b96924b1104ebb", "patch": "@@ -59,8 +59,7 @@ bool inline_account_function_p (struct cgraph_node *node);\n bool inline_call (struct cgraph_edge *, bool, vec<cgraph_edge *> *, int *, bool,\n \t\t  bool *callee_removed = NULL);\n unsigned int inline_transform (struct cgraph_node *);\n-void clone_inlined_nodes (struct cgraph_edge *e, bool, bool, int *,\n-\t\t\t  int freq_scale);\n+void clone_inlined_nodes (struct cgraph_edge *e, bool, bool, int *);\n \n extern int ncalls_inlined;\n extern int nfunctions_inlined;"}, {"sha": "cdcd0505f030e2c23c45cc7fa1d0670229d6500e", "filename": "gcc/ipa-profile.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Fipa-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Fipa-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-profile.c?ref=1bad9c1806ac51abc2bf1bdf18b96924b1104ebb", "patch": "@@ -340,7 +340,7 @@ ipa_propagate_frequency_1 (struct cgraph_node *node, void *data)\n \t\t  && edge->caller->global.inlined_to->frequency\n \t\t     != NODE_FREQUENCY_UNLIKELY_EXECUTED)))\n \t  d->maybe_unlikely_executed = false;\n-      if (!edge->frequency)\n+      if (!edge->frequency ())\n \tcontinue;\n       switch (edge->caller->frequency)\n         {\n@@ -431,11 +431,11 @@ ipa_propagate_frequency (struct cgraph_node *node)\n     }\n \n   /* With profile we can decide on hot/normal based on count.  */\n-  if (node->count.initialized_p ())\n+  if (node->count. ipa().initialized_p ())\n     {\n       bool hot = false;\n-      if (!(node->count == profile_count::zero ())\n-\t  && node->count >= get_hot_bb_threshold ())\n+      if (!(node->count. ipa() == profile_count::zero ())\n+\t  && node->count. ipa() >= get_hot_bb_threshold ())\n \thot = true;\n       if (!hot)\n \thot |= contains_hot_call_p (node);\n@@ -667,9 +667,7 @@ ipa_profile (void)\n \t\t      e->make_speculative\n \t\t\t(n2,\n \t\t\t e->count.apply_probability\n-\t\t\t\t     (e->indirect_info->common_target_probability),\n-\t\t\t apply_scale (e->frequency,\n-\t\t\t\t      e->indirect_info->common_target_probability));\n+\t\t\t\t     (e->indirect_info->common_target_probability));\n \t\t      update = true;\n \t\t    }\n \t\t}"}, {"sha": "4b3c23614185d68f47f8fab4dc21ec8ac669b9a4", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=1bad9c1806ac51abc2bf1bdf18b96924b1104ebb", "patch": "@@ -2982,7 +2982,7 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target,\n \t}\n       /* make_speculative will update ie's cost to direct call cost. */\n       ie = ie->make_speculative\n-\t     (callee, ie->count.apply_scale (8, 10), ie->frequency * 8 / 10);\n+\t     (callee, ie->count.apply_scale (8, 10));\n     }\n \n   return ie;"}, {"sha": "808db436b6ac82d568f5a19aebc793499266e6be", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 10, "deletions": 28, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=1bad9c1806ac51abc2bf1bdf18b96924b1104ebb", "patch": "@@ -404,17 +404,18 @@ ipa_merge_profiles (struct cgraph_node *dst,\n \n   /* FIXME when we merge in unknown profile, we ought to set counts as\n      unsafe.  */\n-  if (!src->count.initialized_p ())\n+  if (!src->count.initialized_p ()\n+      || !(src->count.ipa () == src->count))\n     return;\n   if (symtab->dump_file)\n     {\n       fprintf (symtab->dump_file, \"Merging profiles of %s to %s\\n\",\n \t       src->dump_name (), dst->dump_name ());\n     }\n-  if (dst->count.initialized_p ())\n-    dst->count += src->count;\n-  else\n-    dst->count = src->count;\n+  if (dst->count.initialized_p () && dst->count.ipa () == dst->count)\n+    dst->count += src->count.ipa ();\n+  else \n+    dst->count = src->count.ipa ();\n \n   /* This is ugly.  We need to get both function bodies into memory.\n      If declaration is merged, we need to duplicate it to be able\n@@ -564,18 +565,12 @@ ipa_merge_profiles (struct cgraph_node *dst,\n \t{\n \t  if (e->speculative)\n \t    continue;\n-\t  e->count = gimple_bb (e->call_stmt)->count.ipa ();\n-\t  e->frequency = compute_call_stmt_bb_frequency\n-\t\t\t     (dst->decl,\n-\t\t\t      gimple_bb (e->call_stmt));\n+\t  e->count = gimple_bb (e->call_stmt)->count;\n \t}\n       for (e = dst->indirect_calls, e2 = src->indirect_calls; e;\n \t   e2 = (e2 ? e2->next_callee : NULL), e = e->next_callee)\n \t{\n \t  profile_count count = gimple_bb (e->call_stmt)->count;\n-\t  int freq = compute_call_stmt_bb_frequency\n-\t\t\t(dst->decl,\n-\t\t\t gimple_bb (e->call_stmt));\n \t  /* When call is speculative, we need to re-distribute probabilities\n \t     the same way as they was.  This is not really correct because\n \t     in the other copy the speculation may differ; but probably it\n@@ -624,12 +619,6 @@ ipa_merge_profiles (struct cgraph_node *dst,\n \t\t\t   indirect->count += indirect2->count;\n \t\t\t}\n \t\t    }\n-\t\t  int  prob = direct->count.probability_in (direct->count\n-\t\t\t\t\t\t\t    + indirect->count).\n-\t\t\t      to_reg_br_prob_base ();\n-\t\t  direct->frequency = RDIV (freq * prob, REG_BR_PROB_BASE);\n-\t\t  indirect->frequency = RDIV (freq * (REG_BR_PROB_BASE - prob),\n-\t\t\t\t\t      REG_BR_PROB_BASE);\n \t\t}\n \t      else\n \t\t/* At the moment we should have only profile feedback based\n@@ -642,18 +631,11 @@ ipa_merge_profiles (struct cgraph_node *dst,\n \t      ipa_ref *ref;\n \n \t      e2->speculative_call_info (direct, indirect, ref);\n-\t      e->count = count.ipa ();\n-\t      e->frequency = freq;\n-\t      int prob = direct->count.probability_in (e->count)\n-\t\t\t .to_reg_br_prob_base ();\n-\t      e->make_speculative (direct->callee, direct->count,\n-\t\t\t\t   RDIV (freq * prob, REG_BR_PROB_BASE));\n+\t      e->count = count;\n+\t      e->make_speculative (direct->callee, direct->count);\n \t    }\n \t  else\n-\t    {\n-\t      e->count = count.ipa ();\n-\t      e->frequency = freq;\n-\t    }\n+\t    e->count = count;\n \t}\n       if (!preserve_body)\n         src->release_body ();"}, {"sha": "a19f8a13dfb892cc8c06ed9b2b9ae4ee90788777", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=1bad9c1806ac51abc2bf1bdf18b96924b1104ebb", "patch": "@@ -266,7 +266,6 @@ lto_output_edge (struct lto_simple_output_block *ob, struct cgraph_edge *edge,\n   bp_pack_enum (&bp, cgraph_inline_failed_t,\n \t        CIF_N_REASONS, edge->inline_failed);\n   bp_pack_var_len_unsigned (&bp, uid);\n-  bp_pack_var_len_unsigned (&bp, edge->frequency);\n   bp_pack_value (&bp, edge->indirect_inlining_edge, 1);\n   bp_pack_value (&bp, edge->speculative, 1);\n   bp_pack_value (&bp, edge->call_stmt_cannot_inline_p, 1);\n@@ -1248,7 +1247,7 @@ input_node (struct lto_file_decl_data *file_data,\n   if (clone_ref != LCC_NOT_FOUND)\n     {\n       node = dyn_cast<cgraph_node *> (nodes[clone_ref])->create_clone (fn_decl,\n-\tprofile_count::uninitialized (), CGRAPH_FREQ_BASE, false,\n+\tprofile_count::uninitialized (), false,\n \tvNULL, false, NULL, NULL);\n     }\n   else\n@@ -1464,7 +1463,6 @@ input_edge (struct lto_input_block *ib, vec<symtab_node *> nodes,\n   struct cgraph_edge *edge;\n   unsigned int stmt_id;\n   profile_count count;\n-  int freq;\n   cgraph_inline_failed_t inline_failed;\n   struct bitpack_d bp;\n   int ecf_flags = 0;\n@@ -1487,12 +1485,11 @@ input_edge (struct lto_input_block *ib, vec<symtab_node *> nodes,\n   bp = streamer_read_bitpack (ib);\n   inline_failed = bp_unpack_enum (&bp, cgraph_inline_failed_t, CIF_N_REASONS);\n   stmt_id = bp_unpack_var_len_unsigned (&bp);\n-  freq = (int) bp_unpack_var_len_unsigned (&bp);\n \n   if (indirect)\n-    edge = caller->create_indirect_edge (NULL, 0, count, freq);\n+    edge = caller->create_indirect_edge (NULL, 0, count);\n   else\n-    edge = caller->create_edge (callee, NULL, count, freq);\n+    edge = caller->create_edge (callee, NULL, count);\n \n   edge->indirect_inlining_edge = bp_unpack_value (&bp, 1);\n   edge->speculative = bp_unpack_value (&bp, 1);\n@@ -1823,8 +1820,13 @@ merge_profile_summaries (struct lto_file_decl_data **file_data_vec)\n \tif (scale == REG_BR_PROB_BASE)\n \t  continue;\n \tfor (edge = node->callees; edge; edge = edge->next_callee)\n-\t  edge->count = edge->count.apply_scale (scale, REG_BR_PROB_BASE);\n-\tnode->count = node->count.apply_scale (scale, REG_BR_PROB_BASE);\n+\t  if (edge->count.ipa ().nonzero_p ())\n+\t    edge->count = edge->count.apply_scale (scale, REG_BR_PROB_BASE);\n+\tfor (edge = node->indirect_calls; edge; edge = edge->next_callee)\n+\t  if (edge->count.ipa ().nonzero_p ())\n+\t    edge->count = edge->count.apply_scale (scale, REG_BR_PROB_BASE);\n+\tif (node->count.ipa ().nonzero_p ())\n+\t  node->count = node->count.apply_scale (scale, REG_BR_PROB_BASE);\n       }\n }\n "}, {"sha": "4edb153ed76ba7bc0fc739aef5ea18ef9a8d2e22", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=1bad9c1806ac51abc2bf1bdf18b96924b1104ebb", "patch": "@@ -1,3 +1,7 @@\n+2017-11-10  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* lto-partition.c (lto_balanced_map): Use frequency accessor.\n+\n 2017-10-13  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* lto-lang.c (lto_post_options): Clean shlib flag when not doing PIC."}, {"sha": "2d0663eb93c761fb35d392f6a581cfc2e4a5db22", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=1bad9c1806ac51abc2bf1bdf18b96924b1104ebb", "patch": "@@ -587,7 +587,7 @@ lto_balanced_map (int n_lto_partitions, int max_partition_size)\n \t      for (edge = node->callees; edge; edge = edge->next_callee)\n \t\tif (edge->callee->definition)\n \t\t  {\n-\t\t    int edge_cost = edge->frequency;\n+\t\t    int edge_cost = edge->frequency ();\n \t\t    int index;\n \n \t\t    if (!edge_cost)\n@@ -603,7 +603,7 @@ lto_balanced_map (int n_lto_partitions, int max_partition_size)\n \t\t  }\n \t      for (edge = node->callers; edge; edge = edge->next_caller)\n \t\t{\n-\t\t  int edge_cost = edge->frequency;\n+\t\t  int edge_cost = edge->frequency ();\n \t\t  int index;\n \n \t\t  gcc_assert (edge->caller->definition);"}, {"sha": "5cd85642546291f57e6185f1ab4c5c34f3cbf125", "filename": "gcc/omp-simd-clone.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Fomp-simd-clone.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Fomp-simd-clone.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-simd-clone.c?ref=1bad9c1806ac51abc2bf1bdf18b96924b1104ebb", "patch": "@@ -1389,10 +1389,8 @@ simd_clone_adjust (struct cgraph_node *node)\n \t      (single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun)), seq);\n \n \t    entry_bb = single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n-\t    int freq = compute_call_stmt_bb_frequency (current_function_decl,\n-\t\t\t\t\t\t       entry_bb);\n \t    node->create_edge (cgraph_node::get_create (fn),\n-\t\t\t       call, entry_bb->count, freq);\n+\t\t\t       call, entry_bb->count);\n \n \t    imm_use_iterator iter;\n \t    use_operand_p use_p;"}, {"sha": "07b4bf7c3989521df58802f7023b64f2afc288c9", "filename": "gcc/predict.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=1bad9c1806ac51abc2bf1bdf18b96924b1104ebb", "patch": "@@ -3222,11 +3222,10 @@ drop_profile (struct cgraph_node *node, profile_count call_count)\n   pop_cfun ();\n \n   struct cgraph_edge *e;\n-  for (e = node->callees; e; e = e->next_caller)\n-    {\n-      e->frequency = compute_call_stmt_bb_frequency (e->caller->decl,\n-\t\t\t\t\t\t     gimple_bb (e->call_stmt));\n-    }\n+  for (e = node->callees; e; e = e->next_callee)\n+    e->count = gimple_bb (e->call_stmt)->count;\n+  for (e = node->indirect_calls; e; e = e->next_callee)\n+    e->count = gimple_bb (e->call_stmt)->count;\n   \n   profile_status_for_fn (fn)\n       = (flag_guess_branch_prob ? PROFILE_GUESSED : PROFILE_ABSENT);"}, {"sha": "63cac31829e7f3ecddda88a5084ec425a6e7b0c9", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=1bad9c1806ac51abc2bf1bdf18b96924b1104ebb", "patch": "@@ -5065,9 +5065,7 @@ ipa_tm_insert_irr_call (struct cgraph_node *node, struct tm_region *region,\n \n   node->create_edge (cgraph_node::get_create\n \t\t       (builtin_decl_explicit (BUILT_IN_TM_IRREVOCABLE)),\n-\t\t     g, gimple_bb (g)->count,\n-\t\t     compute_call_stmt_bb_frequency (node->decl,\n-\t\t\t\t\t\t     gimple_bb (g)));\n+\t\t     g, gimple_bb (g)->count);\n }\n \n /* Construct a call to TM_GETTMCLONE and insert it before GSI.  */\n@@ -5116,9 +5114,7 @@ ipa_tm_insert_gettmclone_call (struct cgraph_node *node,\n \n   gsi_insert_before (gsi, g, GSI_SAME_STMT);\n \n-  node->create_edge (cgraph_node::get_create (gettm_fn), g, gimple_bb (g)->count,\n-\t\t     compute_call_stmt_bb_frequency (node->decl,\n-\t\t\t\t\t\t     gimple_bb (g)));\n+  node->create_edge (cgraph_node::get_create (gettm_fn), g, gimple_bb (g)->count);\n \n   /* Cast return value from tm_gettmclone* into appropriate function\n      pointer.  */"}, {"sha": "9a2fa1d98cac8d03be25c36003fe4e6d39eacc5f", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=1bad9c1806ac51abc2bf1bdf18b96924b1104ebb", "patch": "@@ -9225,7 +9225,7 @@ execute_fixup_cfg (void)\n   gimple_stmt_iterator gsi;\n   int todo = 0;\n   cgraph_node *node = cgraph_node::get (current_function_decl);\n-  profile_count num = node->count;\n+  profile_count num = node->count.ipa ();\n   profile_count den = ENTRY_BLOCK_PTR_FOR_FN (cfun)->count;\n   bool scale = num.initialized_p () && den.ipa_p ()\n \t       && (den.nonzero_p () || num == profile_count::zero ())\n@@ -9241,7 +9241,15 @@ execute_fixup_cfg (void)\n   FOR_EACH_BB_FN (bb, cfun)\n     {\n       if (scale)\n-        bb->count = bb->count.apply_scale (num, den);\n+\t{\n+\t  if (num == profile_count::zero ())\n+\t    {\n+\t      if (!(bb->count == profile_count::zero ()))\n+\t        bb->count = bb->count.global0 ();\n+\t    }\n+\t  else\n+            bb->count = bb->count.apply_scale (num, den);\n+\t}\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi);)\n \t{\n \t  gimple *stmt = gsi_stmt (gsi);\n@@ -9331,11 +9339,8 @@ execute_fixup_cfg (void)\n \t      if (!cfun->after_inlining)\n \t\t{\n \t\t  gcall *call_stmt = dyn_cast <gcall *> (stmt);\n-\t\t  int freq\n-\t\t    = compute_call_stmt_bb_frequency (current_function_decl,\n-\t\t\t\t\t\t      bb);\n \t\t  node->create_edge (cgraph_node::get_create (fndecl),\n-\t\t\t\t     call_stmt, bb->count, freq);\n+\t\t\t\t     call_stmt, bb->count);\n \t\t}\n \t    }\n \t}"}, {"sha": "6d24355aba6f2afe4acb96075bc465ea260f3468", "filename": "gcc/tree-chkp.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Ftree-chkp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Ftree-chkp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chkp.c?ref=1bad9c1806ac51abc2bf1bdf18b96924b1104ebb", "patch": "@@ -4231,18 +4231,12 @@ chkp_copy_bounds_for_assign (gimple *assign, struct cgraph_edge *edge)\n \t{\n \t  tree fndecl = gimple_call_fndecl (stmt);\n \t  struct cgraph_node *callee = cgraph_node::get_create (fndecl);\n-\t  struct cgraph_edge *new_edge;\n \n \t  gcc_assert (chkp_gimple_call_builtin_p (stmt, BUILT_IN_CHKP_BNDSTX)\n \t\t      || chkp_gimple_call_builtin_p (stmt, BUILT_IN_CHKP_BNDLDX)\n \t\t      || chkp_gimple_call_builtin_p (stmt, BUILT_IN_CHKP_BNDRET));\n \n-\t  new_edge = edge->caller->create_edge (callee,\n-\t\t\t\t\t\tas_a <gcall *> (stmt),\n-\t\t\t\t\t\tedge->count,\n-\t\t\t\t\t\tedge->frequency);\n-\t  new_edge->frequency = compute_call_stmt_bb_frequency\n-\t    (edge->caller->decl, gimple_bb (stmt));\n+\t  edge->caller->create_edge (callee, as_a <gcall *> (stmt), edge->count);\n \t}\n       gsi_prev (&iter);\n     }"}, {"sha": "9136a0b28566e933498b142b8f442d39c5593eb7", "filename": "gcc/tree-emutls.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Ftree-emutls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Ftree-emutls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-emutls.c?ref=1bad9c1806ac51abc2bf1bdf18b96924b1104ebb", "patch": "@@ -417,7 +417,7 @@ gen_emutls_addr (tree decl, struct lower_emutls_data *d)\n \n       gimple_seq_add_stmt (&d->seq, x);\n \n-      d->cfun_node->create_edge (d->builtin_node, x, d->bb->count, d->bb_freq);\n+      d->cfun_node->create_edge (d->builtin_node, x, d->bb->count);\n \n       /* We may be adding a new reference to a new variable to the function.\n          This means we have to play with the ipa-reference web.  */"}, {"sha": "5c49214663f7000b0430fecc36ddadc69b801648", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 21, "deletions": 60, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=1bad9c1806ac51abc2bf1bdf18b96924b1104ebb", "patch": "@@ -2001,66 +2001,39 @@ copy_bb (copy_body_data *id, basic_block bb,\n \t\t  edge = id->src_node->get_edge (orig_stmt);\n \t\t  if (edge)\n \t\t    {\n-\t\t      int edge_freq = edge->frequency;\n-\t\t      int new_freq;\n \t\t      struct cgraph_edge *old_edge = edge;\n+\t\t      profile_count old_cnt = edge->count;\n \t\t      edge = edge->clone (id->dst_node, call_stmt,\n \t\t\t\t\t  gimple_uid (stmt),\n-\t\t\t\t\t  profile_count::one (),\n-\t\t\t\t\t  profile_count::one (),\n-\t\t\t\t\t  CGRAPH_FREQ_BASE,\n+\t\t\t\t\t  num, den,\n \t\t\t\t\t  true);\n-\t\t      /* We could also just rescale the frequency, but\n-\t\t         doing so would introduce roundoff errors and make\n-\t\t\t verifier unhappy.  */\n-\t\t      new_freq  = compute_call_stmt_bb_frequency (id->dst_node->decl,\n-\t\t\t\t\t\t\t\t  copy_basic_block);\n-\n-\t\t      /* Speculative calls consist of two edges - direct and indirect.\n-\t\t\t Duplicate the whole thing and distribute frequencies accordingly.  */\n+\n+\t\t      /* Speculative calls consist of two edges - direct and\n+\t\t\t indirect.  Duplicate the whole thing and distribute\n+\t\t\t frequencies accordingly.  */\n \t\t      if (edge->speculative)\n \t\t\t{\n \t\t\t  struct cgraph_edge *direct, *indirect;\n \t\t\t  struct ipa_ref *ref;\n \n \t\t\t  gcc_assert (!edge->indirect_unknown_callee);\n \t\t\t  old_edge->speculative_call_info (direct, indirect, ref);\n+\n+\t\t\t  profile_count indir_cnt = indirect->count;\n \t\t\t  indirect = indirect->clone (id->dst_node, call_stmt,\n \t\t\t\t\t\t      gimple_uid (stmt),\n-\t\t\t\t\t\t      profile_count::one (),\n-\t\t\t\t\t\t      profile_count::one (),\n-\t\t\t\t\t\t      CGRAPH_FREQ_BASE,\n+\t\t\t\t\t\t      num, den,\n \t\t\t\t\t\t      true);\n-\t\t\t  if (old_edge->frequency + indirect->frequency)\n-\t\t\t    {\n-\t\t\t      edge->frequency = MIN (RDIV ((gcov_type)new_freq * old_edge->frequency,\n-\t\t\t\t\t\t           (old_edge->frequency + indirect->frequency)),\n-\t\t\t\t\t\t     CGRAPH_FREQ_MAX);\n-\t\t\t      indirect->frequency = MIN (RDIV ((gcov_type)new_freq * indirect->frequency,\n-\t\t\t\t\t\t\t       (old_edge->frequency + indirect->frequency)),\n-\t\t\t\t\t\t\t CGRAPH_FREQ_MAX);\n-\t\t\t    }\n+\n+\t\t\t  profile_probability prob\n+\t\t\t     = indir_cnt.probability_in (old_cnt + indir_cnt);\n+\t\t\t  indirect->count\n+\t\t\t     = copy_basic_block->count.apply_probability (prob);\n+\t\t\t  edge->count = copy_basic_block->count - indirect->count;\n \t\t\t  id->dst_node->clone_reference (ref, stmt);\n \t\t\t}\n \t\t      else\n-\t\t\t{\n-\t\t\t  edge->frequency = new_freq;\n-\t\t\t  if (dump_file\n-\t\t\t      && profile_status_for_fn (cfun) != PROFILE_ABSENT\n-\t\t\t      && (edge_freq > edge->frequency + 10\n-\t\t\t\t  || edge_freq < edge->frequency - 10))\n-\t\t\t    {\n-\t\t\t      fprintf (dump_file, \"Edge frequency estimated by \"\n-\t\t\t\t       \"cgraph %i diverge from inliner's estimate %i\\n\",\n-\t\t\t\t       edge_freq,\n-\t\t\t\t       edge->frequency);\n-\t\t\t      fprintf (dump_file,\n-\t\t\t\t       \"Orig bb: %i, orig bb freq %i, new bb freq %i\\n\",\n-\t\t\t\t       bb->index,\n-\t\t\t\t       bb->count.to_frequency (cfun),\n-\t\t\t\t       copy_basic_block->count.to_frequency (cfun));\n-\t\t\t    }\n-\t\t\t}\n+\t\t\tedge->count = copy_basic_block->count;\n \t\t    }\n \t\t  break;\n \n@@ -2103,15 +2076,10 @@ copy_bb (copy_body_data *id, basic_block bb,\n \t\t  if (id->transform_call_graph_edges == CB_CGE_MOVE_CLONES)\n \t\t    id->dst_node->create_edge_including_clones\n \t\t      (dest, orig_stmt, call_stmt, bb->count,\n-\t\t       compute_call_stmt_bb_frequency (id->dst_node->decl,\n-\t\t       \t\t\t\t       copy_basic_block),\n \t\t       CIF_ORIGINALLY_INDIRECT_CALL);\n \t\t  else\n \t\t    id->dst_node->create_edge (dest, call_stmt,\n-\t\t\t\t\tbb->count,\n-\t\t\t\t\tcompute_call_stmt_bb_frequency\n-\t\t\t\t\t  (id->dst_node->decl,\n-\t\t\t\t\t   copy_basic_block))->inline_failed\n+\t\t\t\t\tbb->count)->inline_failed\n \t\t      = CIF_ORIGINALLY_INDIRECT_CALL;\n \t\t  if (dump_file)\n \t\t    {\n@@ -4475,7 +4443,6 @@ expand_call_inline (basic_block bb, gimple *stmt, copy_body_data *id)\n     {\n       cgraph_edge *edge;\n       tree virtual_offset = NULL;\n-      int freq = cg_edge->frequency;\n       profile_count count = cg_edge->count;\n       tree op;\n       gimple_stmt_iterator iter = gsi_for_stmt (stmt);\n@@ -4485,9 +4452,7 @@ expand_call_inline (basic_block bb, gimple *stmt, copy_body_data *id)\n \t\t   \t\t           gimple_uid (stmt),\n \t\t\t\t   \t   profile_count::one (),\n \t\t\t\t\t   profile_count::one (),\n-\t\t\t\t\t   CGRAPH_FREQ_BASE,\n \t\t\t\t           true);\n-      edge->frequency = freq;\n       edge->count = count;\n       if (id->src_node->thunk.virtual_offset_p)\n         virtual_offset = size_int (id->src_node->thunk.virtual_value);\n@@ -4709,7 +4674,7 @@ expand_call_inline (basic_block bb, gimple *stmt, copy_body_data *id)\n       print_generic_expr (dump_file, id->src_fn);\n       fprintf (dump_file, \" to \");\n       print_generic_expr (dump_file, id->dst_fn);\n-      fprintf (dump_file, \" with frequency %i\\n\", cg_edge->frequency);\n+      fprintf (dump_file, \" with frequency %i\\n\", cg_edge->frequency ());\n     }\n \n   /* This is it.  Duplicate the callee body.  Assume callee is\n@@ -6089,20 +6054,16 @@ tree_function_versioning (tree old_decl, tree new_decl,\n       struct cgraph_edge *e;\n       rebuild_frequencies ();\n \n-      new_version_node->count = ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.ipa ();\n+      new_version_node->count = ENTRY_BLOCK_PTR_FOR_FN (cfun)->count;\n       for (e = new_version_node->callees; e; e = e->next_callee)\n \t{\n \t  basic_block bb = gimple_bb (e->call_stmt);\n-\t  e->frequency = compute_call_stmt_bb_frequency (current_function_decl,\n-\t\t\t\t\t\t\t bb);\n-\t  e->count = bb->count.ipa ();\n+\t  e->count = bb->count;\n \t}\n       for (e = new_version_node->indirect_calls; e; e = e->next_callee)\n \t{\n \t  basic_block bb = gimple_bb (e->call_stmt);\n-\t  e->frequency = compute_call_stmt_bb_frequency (current_function_decl,\n-\t\t\t\t\t\t\t bb);\n-\t  e->count = bb->count.ipa ();\n+\t  e->count = bb->count;\n \t}\n     }\n "}, {"sha": "560d4654850b77aada55df9dbc7b2dab24938302", "filename": "gcc/ubsan.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Fubsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bad9c1806ac51abc2bf1bdf18b96924b1104ebb/gcc%2Fubsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fubsan.c?ref=1bad9c1806ac51abc2bf1bdf18b96924b1104ebb", "patch": "@@ -675,12 +675,10 @@ ubsan_create_edge (gimple *stmt)\n {\n   gcall *call_stmt = dyn_cast <gcall *> (stmt);\n   basic_block bb = gimple_bb (stmt);\n-  int freq = compute_call_stmt_bb_frequency (current_function_decl, bb);\n   cgraph_node *node = cgraph_node::get (current_function_decl);\n   tree decl = gimple_call_fndecl (call_stmt);\n   if (decl)\n-    node->create_edge (cgraph_node::get_create (decl), call_stmt, bb->count,\n-\t\t       freq);\n+    node->create_edge (cgraph_node::get_create (decl), call_stmt, bb->count);\n }\n \n /* Expand the UBSAN_BOUNDS special builtin function.  */"}]}