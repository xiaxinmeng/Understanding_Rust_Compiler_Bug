{"sha": "fabaf7d6caf919ceaa05f2db4260fa897864d517", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmFiYWY3ZDZjYWY5MTljZWFhMDVmMmRiNDI2MGZhODk3ODY0ZDUxNw==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-09-17T17:05:01Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-09-17T21:29:02Z"}, "message": "Initial Dynamic dispatch support\n\nThis is the first pass at implementing dynamic dispatch, it creates a\nvtable object and trait object to store the vtable and reciever. The\nmethod resolution during type checking acts the same as if it was a\ngeneric type bound method call. This detects this case during code\ngeneration to access the dynamic object appropriately to get the fnptr\nand call it with the stored reciever.\n\nFixes: #197", "tree": {"sha": "d50a81ea97725eee5abe8d4b881e265c04fd80c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d50a81ea97725eee5abe8d4b881e265c04fd80c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fabaf7d6caf919ceaa05f2db4260fa897864d517", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fabaf7d6caf919ceaa05f2db4260fa897864d517", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fabaf7d6caf919ceaa05f2db4260fa897864d517", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fabaf7d6caf919ceaa05f2db4260fa897864d517/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6e15ff5f052801180b3e56c4579ea555f2f0c50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6e15ff5f052801180b3e56c4579ea555f2f0c50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6e15ff5f052801180b3e56c4579ea555f2f0c50"}], "stats": {"total": 456, "additions": 427, "deletions": 29}, "files": [{"sha": "4a810616977cbfac5812fa64f6e83d9fc20c5c40", "filename": "gcc/rust/backend/rust-compile-base.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabaf7d6caf919ceaa05f2db4260fa897864d517/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabaf7d6caf919ceaa05f2db4260fa897864d517/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.h?ref=fabaf7d6caf919ceaa05f2db4260fa897864d517", "patch": "@@ -200,6 +200,19 @@ class HIRCompileBase : public HIR::HIRVisitor\n \n   bool compile_locals_for_block (Resolver::Rib &rib, Bfunction *fndecl,\n \t\t\t\t std::vector<Bvariable *> &locals);\n+\n+  Bexpression *coercion_site (Bexpression *compiled_ref, TyTy::BaseType *actual,\n+\t\t\t      TyTy::BaseType *expected, Location locus);\n+\n+  Bexpression *coerce_to_dyn_object (Bexpression *compiled_ref,\n+\t\t\t\t     TyTy::BaseType *actual,\n+\t\t\t\t     TyTy::BaseType *expected,\n+\t\t\t\t     TyTy::DynamicObjectType *ty,\n+\t\t\t\t     Location locus);\n+\n+  Bexpression *\n+  compute_address_for_trait_item (const Resolver::TraitItemReference *ref,\n+\t\t\t\t  TyTy::BaseType *receiver);\n };\n \n } // namespace Compile"}, {"sha": "7a4344ec493a1bb1526230fa8a8355e164d62c5e", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 61, "deletions": 9, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabaf7d6caf919ceaa05f2db4260fa897864d517/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabaf7d6caf919ceaa05f2db4260fa897864d517/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=fabaf7d6caf919ceaa05f2db4260fa897864d517", "patch": "@@ -343,9 +343,10 @@ class Context\n class TyTyResolveCompile : public TyTy::TyVisitor\n {\n public:\n-  static ::Btype *compile (Context *ctx, TyTy::BaseType *ty)\n+  static ::Btype *compile (Context *ctx, TyTy::BaseType *ty,\n+\t\t\t   bool trait_object_mode = false)\n   {\n-    TyTyResolveCompile compiler (ctx);\n+    TyTyResolveCompile compiler (ctx, trait_object_mode);\n     ty->accept_vis (compiler);\n     return compiler.translated;\n   }\n@@ -378,7 +379,8 @@ class TyTyResolveCompile : public TyTy::TyVisitor\n     if (!type.get_return_type ()->is_unit ())\n       {\n \tauto hir_type = type.get_return_type ();\n-\tauto ret = TyTyResolveCompile::compile (ctx, hir_type);\n+\tauto ret\n+\t  = TyTyResolveCompile::compile (ctx, hir_type, trait_object_mode);\n \tresults.push_back (Backend::Btyped_identifier (\n \t  \"_\", ret,\n \t  ctx->get_mappings ()->lookup_location (hir_type->get_ref ())));\n@@ -388,7 +390,7 @@ class TyTyResolveCompile : public TyTy::TyVisitor\n       {\n \tauto param_tyty = param_pair.second;\n \tauto compiled_param_type\n-\t  = TyTyResolveCompile::compile (ctx, param_tyty);\n+\t  = TyTyResolveCompile::compile (ctx, param_tyty, trait_object_mode);\n \n \tauto compiled_param = Backend::Btyped_identifier (\n \t  param_pair.first->as_string (), compiled_param_type,\n@@ -429,7 +431,6 @@ class TyTyResolveCompile : public TyTy::TyVisitor\n     if (ctx->lookup_compiled_types (type.get_ty_ref (), &translated, &type))\n       return;\n \n-    // create implicit struct\n     std::vector<Backend::Btyped_identifier> fields;\n     for (size_t i = 0; i < type.num_fields (); i++)\n       {\n@@ -570,7 +571,7 @@ class TyTyResolveCompile : public TyTy::TyVisitor\n   void visit (TyTy::ReferenceType &type) override\n   {\n     Btype *base_compiled_type\n-      = TyTyResolveCompile::compile (ctx, type.get_base ());\n+      = TyTyResolveCompile::compile (ctx, type.get_base (), trait_object_mode);\n     if (type.is_mutable ())\n       {\n \ttranslated = ctx->get_backend ()->reference_type (base_compiled_type);\n@@ -585,7 +586,7 @@ class TyTyResolveCompile : public TyTy::TyVisitor\n   void visit (TyTy::PointerType &type) override\n   {\n     Btype *base_compiled_type\n-      = TyTyResolveCompile::compile (ctx, type.get_base ());\n+      = TyTyResolveCompile::compile (ctx, type.get_base (), trait_object_mode);\n     if (type.is_mutable ())\n       {\n \ttranslated = ctx->get_backend ()->pointer_type (base_compiled_type);\n@@ -610,12 +611,63 @@ class TyTyResolveCompile : public TyTy::TyVisitor\n     translated = ctx->get_backend ()->unit_type ();\n   }\n \n-  void visit (TyTy::DynamicObjectType &) override { gcc_unreachable (); }\n+  void visit (TyTy::DynamicObjectType &type) override\n+  {\n+    if (trait_object_mode)\n+      {\n+\ttranslated = ctx->get_backend ()->integer_type (\n+\t  true, ctx->get_backend ()->get_pointer_size ());\n+\treturn;\n+      }\n+\n+    if (ctx->lookup_compiled_types (type.get_ty_ref (), &translated, &type))\n+      return;\n+\n+    // create implicit struct\n+    auto items = type.get_object_items ();\n+    std::vector<Backend::Btyped_identifier> fields;\n+\n+    Btype *uint = ctx->get_backend ()->integer_type (\n+      true, ctx->get_backend ()->get_pointer_size ());\n+    Btype *uintptr_ty = ctx->get_backend ()->pointer_type (uint);\n+\n+    Backend::Btyped_identifier f (\"__receiver_trait_obj_ptr\", uintptr_ty,\n+\t\t\t\t  ctx->get_mappings ()->lookup_location (\n+\t\t\t\t    type.get_ty_ref ()));\n+    fields.push_back (std::move (f));\n+\n+    for (size_t i = 0; i < items.size (); i++)\n+      {\n+\t// mrustc seems to make a vtable consisting of uintptr's\n+\tBtype *uint = ctx->get_backend ()->integer_type (\n+\t  true, ctx->get_backend ()->get_pointer_size ());\n+\tBtype *uintptr_ty = ctx->get_backend ()->pointer_type (uint);\n+\n+\tBackend::Btyped_identifier f (\"__\" + std::to_string (i), uintptr_ty,\n+\t\t\t\t      ctx->get_mappings ()->lookup_location (\n+\t\t\t\t\ttype.get_ty_ref ()));\n+\tfields.push_back (std::move (f));\n+      }\n+\n+    Btype *type_record = ctx->get_backend ()->struct_type (fields);\n+    Btype *named_struct\n+      = ctx->get_backend ()->named_type (type.get_name (), type_record,\n+\t\t\t\t\t ctx->get_mappings ()->lookup_location (\n+\t\t\t\t\t   type.get_ty_ref ()));\n+\n+    ctx->push_type (named_struct);\n+    translated = named_struct;\n+\n+    ctx->insert_compiled_type (type.get_ty_ref (), named_struct, &type);\n+  }\n \n private:\n-  TyTyResolveCompile (Context *ctx) : ctx (ctx), translated (nullptr) {}\n+  TyTyResolveCompile (Context *ctx, bool trait_object_mode)\n+    : ctx (ctx), trait_object_mode (trait_object_mode), translated (nullptr)\n+  {}\n \n   Context *ctx;\n+  bool trait_object_mode;\n   ::Btype *translated;\n };\n "}, {"sha": "e3fa697cca957865a9545c050c5e10cb8e8af314", "filename": "gcc/rust/backend/rust-compile-stmt.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabaf7d6caf919ceaa05f2db4260fa897864d517/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabaf7d6caf919ceaa05f2db4260fa897864d517/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h?ref=fabaf7d6caf919ceaa05f2db4260fa897864d517", "patch": "@@ -58,6 +58,7 @@ class CompileStmt : public HIRCompileBase\n     if (!ctx->get_tyctx ()->lookup_type (stmt.get_mappings ().get_hirid (),\n \t\t\t\t\t &ty))\n       {\n+\t// FIXME this should be an assertion instead\n \trust_fatal_error (stmt.get_locus (),\n \t\t\t  \"failed to lookup variable declaration type\");\n \treturn;\n@@ -66,15 +67,26 @@ class CompileStmt : public HIRCompileBase\n     Bvariable *var = nullptr;\n     if (!ctx->lookup_var_decl (stmt.get_mappings ().get_hirid (), &var))\n       {\n+\t// FIXME this should be an assertion instead and use error mark node\n \trust_fatal_error (stmt.get_locus (),\n \t\t\t  \"failed to lookup compiled variable declaration\");\n \treturn;\n       }\n \n     Bexpression *init = CompileExpr::Compile (stmt.get_init_expr (), ctx);\n+    // FIXME use error_mark_node, check that CompileExpr returns error_mark_node\n+    // on failure and make this an assertion\n     if (init == nullptr)\n       return;\n \n+    TyTy::BaseType *actual = nullptr;\n+    bool ok = ctx->get_tyctx ()->lookup_type (\n+      stmt.get_init_expr ()->get_mappings ().get_hirid (), &actual);\n+    rust_assert (ok);\n+\n+    TyTy::BaseType *expected = ty;\n+    init = coercion_site (init, actual, expected, stmt.get_locus ());\n+\n     auto fnctx = ctx->peek_fn ();\n     if (ty->is_unit ())\n       {"}, {"sha": "58c679f74ff207f1cadced4de684df0a45d128d3", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 240, "deletions": 15, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabaf7d6caf919ceaa05f2db4260fa897864d517/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabaf7d6caf919ceaa05f2db4260fa897864d517/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=fabaf7d6caf919ceaa05f2db4260fa897864d517", "patch": "@@ -108,6 +108,9 @@ CompileExpr::visit (HIR::CallExpr &expr)\n void\n CompileExpr::visit (HIR::MethodCallExpr &expr)\n {\n+  // method receiver\n+  Bexpression *self = CompileExpr::Compile (expr.get_receiver ().get (), ctx);\n+\n   // lookup the resolved name\n   NodeId resolved_node_id = UNKNOWN_NODEID;\n   if (!ctx->get_resolver ()->lookup_resolved_name (\n@@ -134,6 +137,110 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n   rust_assert (lookup_fntype->get_kind () == TyTy::TypeKind::FNDEF);\n   TyTy::FnType *fntype = static_cast<TyTy::FnType *> (lookup_fntype);\n \n+  TyTy::BaseType *receiver = nullptr;\n+  ok = ctx->get_tyctx ()->lookup_receiver (expr.get_mappings ().get_hirid (),\n+\t\t\t\t\t   &receiver);\n+  rust_assert (ok);\n+\n+  bool is_dyn_dispatch\n+    = receiver->get_root ()->get_kind () == TyTy::TypeKind::DYNAMIC;\n+  bool is_generic_receiver = receiver->get_kind () == TyTy::TypeKind::PARAM;\n+  if (is_generic_receiver)\n+    {\n+      TyTy::ParamType *p = static_cast<TyTy::ParamType *> (receiver);\n+      receiver = p->resolve ();\n+    }\n+\n+  if (is_dyn_dispatch)\n+    {\n+      TyTy::DynamicObjectType *dyn\n+\t= static_cast<TyTy::DynamicObjectType *> (receiver->get_root ());\n+\n+      size_t offs = 0;\n+      const Resolver::TraitItemReference *ref = nullptr;\n+      for (auto &item : dyn->get_object_items ())\n+\t{\n+\t  auto t = item->get_tyty ();\n+\t  rust_assert (t->get_kind () == TyTy::TypeKind::FNDEF);\n+\t  auto ft = static_cast<TyTy::FnType *> (t);\n+\n+\t  if (ft->get_id () == fntype->get_id ())\n+\t    {\n+\t      ref = item;\n+\t      break;\n+\t    }\n+\t  offs++;\n+\t}\n+\n+      if (ref == nullptr)\n+\t{\n+\t  translated = ctx->get_backend ()->error_expression ();\n+\t  return;\n+\t}\n+\n+      // get any indirection sorted out\n+      auto receiver_ref = self;\n+      if (receiver->get_kind () == TyTy::TypeKind::REF)\n+\t{\n+\t  TyTy::ReferenceType *r\n+\t    = static_cast<TyTy::ReferenceType *> (receiver);\n+\t  auto indirect_ty = r->get_base ();\n+\t  Btype *indrect_compiled_tyty\n+\t    = TyTyResolveCompile::compile (ctx, indirect_ty);\n+\n+\t  Bexpression *indirect\n+\t    = ctx->get_backend ()->indirect_expression (indrect_compiled_tyty,\n+\t\t\t\t\t\t\treceiver_ref, true,\n+\t\t\t\t\t\t\texpr.get_locus ());\n+\t  receiver_ref = indirect;\n+\t}\n+\n+      // access the offs + 1 for the fnptr and offs=0 for the reciever obj\n+      Bexpression *self_argument\n+\t= ctx->get_backend ()->struct_field_expression (receiver_ref, 0,\n+\t\t\t\t\t\t\texpr.get_locus ());\n+\n+      // access the vtable for the fn\n+      Bexpression *fn_vtable_access\n+\t= ctx->get_backend ()->struct_field_expression (receiver_ref, offs + 1,\n+\t\t\t\t\t\t\texpr.get_locus ());\n+\n+      // cast it to the correct fntype\n+      Btype *expected_fntype = TyTyResolveCompile::compile (ctx, fntype, true);\n+      Bexpression *fn_convert_expr\n+\t= ctx->get_backend ()->convert_expression (expected_fntype,\n+\t\t\t\t\t\t   fn_vtable_access,\n+\t\t\t\t\t\t   expr.get_locus ());\n+\n+      fncontext fnctx = ctx->peek_fn ();\n+      Bblock *enclosing_scope = ctx->peek_enclosing_scope ();\n+      bool is_address_taken = false;\n+      Bstatement *ret_var_stmt = nullptr;\n+\n+      Bvariable *fn_convert_expr_tmp = ctx->get_backend ()->temporary_variable (\n+\tfnctx.fndecl, enclosing_scope, expected_fntype, fn_convert_expr,\n+\tis_address_taken, expr.get_locus (), &ret_var_stmt);\n+      ctx->add_statement (ret_var_stmt);\n+\n+      std::vector<Bexpression *> args;\n+      args.push_back (self_argument);\n+      expr.iterate_params ([&] (HIR::Expr *p) mutable -> bool {\n+\tBexpression *compiled_expr = CompileExpr::Compile (p, ctx);\n+\trust_assert (compiled_expr != nullptr);\n+\targs.push_back (compiled_expr);\n+\treturn true;\n+      });\n+\n+      Bexpression *fn_expr\n+\t= ctx->get_backend ()->var_expression (fn_convert_expr_tmp,\n+\t\t\t\t\t       expr.get_locus ());\n+\n+      translated\n+\t= ctx->get_backend ()->call_expression (fnctx.fndecl, fn_expr, args,\n+\t\t\t\t\t\tnullptr, expr.get_locus ());\n+      return;\n+    }\n+\n   // lookup compiled functions\n   Bfunction *fn = nullptr;\n   if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n@@ -157,17 +264,6 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n \t    trait->get_mappings ().get_defid (), &trait_ref);\n \t  rust_assert (ok);\n \n-\t  TyTy::BaseType *receiver = nullptr;\n-\t  ok = ctx->get_tyctx ()->lookup_receiver (\n-\t    expr.get_mappings ().get_hirid (), &receiver);\n-\t  rust_assert (ok);\n-\n-\t  if (receiver->get_kind () == TyTy::TypeKind::PARAM)\n-\t    {\n-\t      TyTy::ParamType *p = static_cast<TyTy::ParamType *> (receiver);\n-\t      receiver = p->resolve ();\n-\t    }\n-\n \t  // the type resolver can only resolve type bounds to their trait\n \t  // item so its up to us to figure out if this path should resolve\n \t  // to an trait-impl-block-item or if it can be defaulted to the\n@@ -290,10 +386,6 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n \n   std::vector<Bexpression *> args;\n \n-  // method receiver\n-  Bexpression *self = CompileExpr::Compile (expr.get_receiver ().get (), ctx);\n-  rust_assert (self != nullptr);\n-\n   // lookup the autoderef mappings\n   std::vector<Resolver::Adjustment> *adjustments = nullptr;\n   ok = ctx->get_tyctx ()->lookup_autoderef_mappings (\n@@ -579,5 +671,138 @@ HIRCompileBase::compile_locals_for_block (Resolver::Rib &rib, Bfunction *fndecl,\n \n   return true;\n }\n+\n+Bexpression *\n+HIRCompileBase::coercion_site (Bexpression *compiled_ref,\n+\t\t\t       TyTy::BaseType *actual, TyTy::BaseType *expected,\n+\t\t\t       Location locus)\n+{\n+  auto root_actual_kind = actual->get_root ()->get_kind ();\n+  auto root_expected_kind = expected->get_root ()->get_kind ();\n+\n+  if (root_expected_kind == TyTy::TypeKind::DYNAMIC\n+      && root_actual_kind != TyTy::TypeKind::DYNAMIC)\n+    {\n+      TyTy::DynamicObjectType *dyn\n+\t= static_cast<TyTy::DynamicObjectType *> (expected->get_root ());\n+      return coerce_to_dyn_object (compiled_ref, actual, expected, dyn, locus);\n+    }\n+\n+  return compiled_ref;\n+}\n+\n+Bexpression *\n+HIRCompileBase::coerce_to_dyn_object (Bexpression *compiled_ref,\n+\t\t\t\t      TyTy::BaseType *actual,\n+\t\t\t\t      TyTy::BaseType *expected,\n+\t\t\t\t      TyTy::DynamicObjectType *ty,\n+\t\t\t\t      Location locus)\n+{\n+  Btype *dynamic_object = TyTyResolveCompile::compile (ctx, ty);\n+\n+  //' this assumes ordering and current the structure is\n+  // __trait_object_ptr\n+  // [list of function ptrs]\n+\n+  std::vector<Bexpression *> vals;\n+  vals.push_back (compiled_ref);\n+  for (auto &item : ty->get_object_items ())\n+    {\n+      // compute the address of each method item\n+      auto address = compute_address_for_trait_item (item, actual->get_root ());\n+      vals.push_back (address);\n+    }\n+\n+  Bexpression *constructed_trait_object\n+    = ctx->get_backend ()->constructor_expression (dynamic_object, vals, -1,\n+\n+\t\t\t\t\t\t   locus);\n+\n+  fncontext fnctx = ctx->peek_fn ();\n+  Bblock *enclosing_scope = ctx->peek_enclosing_scope ();\n+  bool is_address_taken = false;\n+  Bstatement *ret_var_stmt = nullptr;\n+\n+  Bvariable *dyn_tmp = ctx->get_backend ()->temporary_variable (\n+    fnctx.fndecl, enclosing_scope, dynamic_object, constructed_trait_object,\n+    is_address_taken, locus, &ret_var_stmt);\n+  ctx->add_statement (ret_var_stmt);\n+\n+  // FIXME this needs to be more generic to apply any covariance\n+\n+  auto e = expected;\n+  std::vector<Resolver::Adjustment> adjustments;\n+  while (e->get_kind () == TyTy::TypeKind::REF)\n+    {\n+      auto r = static_cast<TyTy::ReferenceType *> (e);\n+      e = r->get_base ();\n+\n+      if (r->is_mutable ())\n+\tadjustments.push_back (\n+\t  Resolver::Adjustment (Resolver::Adjustment::AdjustmentType::MUT_REF,\n+\t\t\t\te));\n+      else\n+\tadjustments.push_back (\n+\t  Resolver::Adjustment (Resolver::Adjustment::AdjustmentType::IMM_REF,\n+\t\t\t\te));\n+    }\n+\n+  auto resulting_dyn_object_ref\n+    = ctx->get_backend ()->var_expression (dyn_tmp, locus);\n+  for (auto it = adjustments.rbegin (); it != adjustments.rend (); it++)\n+    {\n+      bool ok\n+\t= it->get_type () == Resolver::Adjustment::AdjustmentType::IMM_REF\n+\t  || it->get_type () == Resolver::Adjustment::AdjustmentType::MUT_REF;\n+      rust_assert (ok);\n+\n+      resulting_dyn_object_ref\n+\t= ctx->get_backend ()->address_expression (resulting_dyn_object_ref,\n+\t\t\t\t\t\t   locus);\n+    }\n+  return resulting_dyn_object_ref;\n+}\n+\n+Bexpression *\n+HIRCompileBase::compute_address_for_trait_item (\n+  const Resolver::TraitItemReference *trait_item_ref, TyTy::BaseType *receiver)\n+{\n+  TyTy::BaseType *item_type = trait_item_ref->get_tyty ();\n+  rust_assert (item_type->get_kind () == TyTy::TypeKind::FNDEF);\n+  TyTy::FnType *fntype = static_cast<TyTy::FnType *> (item_type);\n+\n+  auto root = receiver->get_root ();\n+  HIR::PathIdentSegment segment_name (trait_item_ref->get_identifier ());\n+  std::vector<Resolver::PathProbeCandidate> candidates\n+    = Resolver::PathProbeType::Probe (root, segment_name, true, false, true);\n+\n+  // FIXME for default trait item resolution\n+  //\n+  // if (candidates.size () == 0)\n+  //   {\n+  //     rust_assert (trait_item_ref->is_optional ()); // has definition\n+  //\n+  //     CompileTraitItem::Compile (self_type,\n+  //       \t\t\t trait_item_ref->get_hir_trait_item (), ctx,\n+  //       \t\t\t fntype);\n+  //     if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n+  //       {\n+  //         return ctx->get_backend ()->error_expression ();\n+  //       }\n+  //   }\n+\n+  rust_assert (!candidates.empty ());\n+  rust_assert (candidates.size () == 1);\n+\n+  Resolver::PathProbeCandidate *candidate = &candidates.at (0);\n+  rust_assert (candidate->is_impl_candidate ());\n+\n+  HIR::ImplItem *impl_item = candidate->item.impl.impl_item;\n+\n+  return CompileInherentImplItem::Compile (receiver->get_root (), impl_item,\n+\t\t\t\t\t   ctx, true, fntype, true,\n+\t\t\t\t\t   Location () /* FIXME */);\n+}\n+\n } // namespace Compile\n } // namespace Rust"}, {"sha": "0b64a3680192cdfc5f96b4ba49b8b1f11655cf01", "filename": "gcc/rust/typecheck/rust-hir-trait-ref.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabaf7d6caf919ceaa05f2db4260fa897864d517/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabaf7d6caf919ceaa05f2db4260fa897864d517/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h?ref=fabaf7d6caf919ceaa05f2db4260fa897864d517", "patch": "@@ -177,6 +177,7 @@ class TraitItemReference\n };\n \n // this wraps up the HIR::Trait so we can do analysis on it\n+\n class TraitReference\n {\n public:"}, {"sha": "5f69deb52d3a2d0df403e8fc4f6e51bf83e95c6c", "filename": "gcc/rust/typecheck/rust-tyty-bounds.cc", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabaf7d6caf919ceaa05f2db4260fa897864d517/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabaf7d6caf919ceaa05f2db4260fa897864d517/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc?ref=fabaf7d6caf919ceaa05f2db4260fa897864d517", "patch": "@@ -88,7 +88,16 @@ TypeBoundPredicate::get () const\n std::string\n TypeBoundPredicate::get_name () const\n {\n-  return get ()->get_name ();\n+  auto mappings = Analysis::Mappings::get ();\n+  auto trait = get ();\n+  auto nodeid = trait->get_mappings ().get_nodeid ();\n+\n+  const Resolver::CanonicalPath *p = nullptr;\n+  if (mappings->lookup_canonical_path (mappings->get_current_crate (), nodeid,\n+\t\t\t\t       &p))\n+    return p->get ();\n+\n+  return trait->get_name ();\n }\n \n bool"}, {"sha": "f4ce501c48c393cedfaa336179e824199c14894b", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabaf7d6caf919ceaa05f2db4260fa897864d517/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabaf7d6caf919ceaa05f2db4260fa897864d517/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=fabaf7d6caf919ceaa05f2db4260fa897864d517", "patch": "@@ -2312,6 +2312,13 @@ DynamicObjectType::clone () const\n \t\t\t\tget_combined_refs ());\n }\n \n+std::string\n+DynamicObjectType::get_name () const\n+{\n+  std::string bounds = \"[\" + raw_bounds_as_string () + \"]\";\n+  return \"dyn \" + bounds;\n+}\n+\n bool\n DynamicObjectType::is_equal (const BaseType &other) const\n {\n@@ -2324,6 +2331,35 @@ DynamicObjectType::is_equal (const BaseType &other) const\n   return bounds_compatible (other, Location (), false);\n }\n \n+const std::vector<const Resolver::TraitItemReference *>\n+DynamicObjectType::get_object_items () const\n+{\n+  std::vector<const Resolver::TraitItemReference *> items;\n+  for (auto &bound : get_specified_bounds ())\n+    {\n+      const Resolver::TraitReference *trait = bound.get ();\n+      for (auto &item : trait->get_trait_items ())\n+\t{\n+\t  if (item.get_trait_item_type ()\n+\t\t== Resolver::TraitItemReference::TraitItemType::FN\n+\t      && item.is_object_safe ())\n+\t    items.push_back (&item);\n+\t}\n+\n+      for (auto &super_trait : trait->get_super_traits ())\n+\t{\n+\t  for (auto &item : super_trait->get_trait_items ())\n+\t    {\n+\t      if (item.get_trait_item_type ()\n+\t\t    == Resolver::TraitItemReference::TraitItemType::FN\n+\t\t  && item.is_object_safe ())\n+\t\titems.push_back (&item);\n+\t    }\n+\t}\n+    }\n+  return items;\n+}\n+\n // rust-tyty-call.h\n \n void"}, {"sha": "7ab2b2ce830615edbb4605acf8952981b6edc889", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabaf7d6caf919ceaa05f2db4260fa897864d517/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabaf7d6caf919ceaa05f2db4260fa897864d517/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=fabaf7d6caf919ceaa05f2db4260fa897864d517", "patch": "@@ -26,8 +26,10 @@\n #include \"rust-abi.h\"\n \n namespace Rust {\n+\n namespace Resolver {\n class TraitReference;\n+class TraitItemReference;\n class AssociatedImplTrait;\n } // namespace Resolver\n \n@@ -186,9 +188,12 @@ class TypeBoundsMappings\n   std::string raw_bounds_as_string () const\n   {\n     std::string buf;\n-    for (auto &b : specified_bounds)\n-      buf += b.as_string () + \" + \";\n-\n+    for (size_t i = 0; i < specified_bounds.size (); i++)\n+      {\n+\tconst TypeBoundPredicate &b = specified_bounds.at (i);\n+\tbool has_next = (i + 1) < specified_bounds.size ();\n+\tbuf += b.get_name () + (has_next ? \" + \" : \"\");\n+      }\n     return buf;\n   }\n \n@@ -1857,7 +1862,11 @@ class DynamicObjectType : public BaseType\n \n   BaseType *clone () const final override;\n \n-  std::string get_name () const override final { return as_string (); }\n+  std::string get_name () const override final;\n+\n+  // this returns a flat list of items including super trait bounds\n+  const std::vector<const Resolver::TraitItemReference *>\n+  get_object_items () const;\n };\n \n } // namespace TyTy"}, {"sha": "f25784a1ebb9b2b48befa93523a833388d385e0b", "filename": "gcc/testsuite/rust/execute/torture/trait5.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabaf7d6caf919ceaa05f2db4260fa897864d517/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait5.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabaf7d6caf919ceaa05f2db4260fa897864d517/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait5.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait5.rs?ref=fabaf7d6caf919ceaa05f2db4260fa897864d517", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-output \"123\\n123\\n\" } */\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+struct Foo(i32);\n+trait Bar {\n+    fn baz(&self);\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+}\n+\n+impl Bar for Foo {\n+    fn baz(&self) {\n+        // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+        unsafe {\n+            let a = \"%i\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c, self.0);\n+        }\n+    }\n+}\n+\n+fn static_dispatch<T: Bar>(t: &T) {\n+    t.baz();\n+}\n+\n+fn dynamic_dispatch(t: &dyn Bar) {\n+    t.baz();\n+}\n+\n+fn main() -> i32 {\n+    let a = &Foo(123);\n+    static_dispatch(a);\n+\n+    let b: &dyn Bar = a;\n+    dynamic_dispatch(b);\n+\n+    0\n+}"}]}