{"sha": "a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTk2MjVhOTFkMmNkMmVmMmNjNmQ4MmY2YWNlOWJlNTE5OTc0NWZkZg==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2010-11-06T13:14:55Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2010-11-06T13:14:55Z"}, "message": "In gcc/objc/: 2010-11-05 Nicola Pero <nicola.pero@meta-innovation.com>\n\nIn gcc/objc/:\n2010-11-05  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        Fixed using the Objective-C 2.0 syntax with self and super.\n        * objc-act.c (OBJC_LOOKUP_NO_INSTANCE_METHODS_OF_ROOT_CLASS): New.\n        (maybe_make_artificial_property_decl): Added 'implementation'\n        argument.  Use OBJC_LOOKUP_NO_INSTANCE_METHODS_OF_ROOT_CLASS when\n        looking up getters or setters for a class.  If an implementation\n        is specified, search it as well for a getter or setter.\n        (objc_maybe_build_component_ref): Updated calls to\n        maybe_make_artificial_property_decl; added code to deal with\n        'self' and 'super' and with methods declared locally in the\n        implementation.  Store the getter call expression in the\n        PROPERTY_REF instead of throwing it away.\n        (objc_build_class_component_ref): Updated calls to\n        maybe_make_artificial_property_decl, and store the getter call\n        expression in PROPERTY_REF instead of throwing it away.\n        (lookup_method_static): Implemented\n        OBJC_LOOKUP_NO_INSTANCE_METHODS_OF_ROOT_CLASS option.\n        (objc_gimplify_property_ref): Do not build the getter method call\n        here; instead use the one stored in the PROPERTY_REF.  If it's not\n        there, produce helpful error messages.\n        * objc-tree.def (PROPERTY_REF): Increased the number of operands\n        from 2 to 3.  Updated comments.\n        * objc-act.h (PROPERTY_REF_GETTER_CALL): New.\n\nIn gcc/testsuite/:\n2010-11-05  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        Fixed using the Objective-C 2.0 dot-syntax with self and super.\n        * objc.dg/property/dotsyntax-5.m: New.\n        * objc.dg/property/dotsyntax-6.m: New.\n        * objc.dg/property/dotsyntax-7.m: New.\n        * objc.dg/property/dotsyntax-8.m: New.\n        * objc.dg/property/dotsyntax-9.m: New.\n        * objc.dg/property/dotsyntax-10.m: New.\n        * objc.dg/property/dotsyntax-11.m: New.\n        * obj-c++.dg/property/dotsyntax-5.mm: New.\n        * obj-c++.dg/property/dotsyntax-6.mm: New.\n        * obj-c++.dg/property/dotsyntax-7.mm: New.\n        * obj-c++.dg/property/dotsyntax-8.mm: New.\n        * obj-c++.dg/property/dotsyntax-9.mm: New.\n        * obj-c++.dg/property/dotsyntax-10.mm: New.\n        * obj-c++.dg/property/dotsyntax-11.mm: New.\n\nFrom-SVN: r166402", "tree": {"sha": "ae27652f67777ee67c50f37fbe2dd448c1a7dafa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae27652f67777ee67c50f37fbe2dd448c1a7dafa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cd746c2704ed7cc2204ac3e76d6369c710d05176", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd746c2704ed7cc2204ac3e76d6369c710d05176", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd746c2704ed7cc2204ac3e76d6369c710d05176"}], "stats": {"total": 1448, "additions": 1355, "deletions": 93}, "files": [{"sha": "9bde682663a02f8083a21952e72b5cae7ca805f9", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf", "patch": "@@ -1,3 +1,28 @@\n+2010-11-06  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\tFixed using the Objective-C 2.0 syntax with self and super.\n+\t* objc-act.c (OBJC_LOOKUP_NO_INSTANCE_METHODS_OF_ROOT_CLASS): New.\n+\t(maybe_make_artificial_property_decl): Added 'implementation'\n+\targument.  Use OBJC_LOOKUP_NO_INSTANCE_METHODS_OF_ROOT_CLASS when\n+\tlooking up getters or setters for a class.  If an implementation\n+\tis specified, search it as well for a getter or setter.\n+\t(objc_maybe_build_component_ref): Updated calls to\n+\tmaybe_make_artificial_property_decl; added code to deal with\n+\t'self' and 'super' and with methods declared locally in the\n+\timplementation.  Store the getter call expression in the\n+\tPROPERTY_REF instead of throwing it away.\n+\t(objc_build_class_component_ref): Updated calls to\n+\tmaybe_make_artificial_property_decl, and store the getter call\n+\texpression in PROPERTY_REF instead of throwing it away.\n+\t(lookup_method_static): Implemented\n+\tOBJC_LOOKUP_NO_INSTANCE_METHODS_OF_ROOT_CLASS option.\n+\t(objc_gimplify_property_ref): Do not build the getter method call\n+\there; instead use the one stored in the PROPERTY_REF.  If it's not\n+\tthere, produce helpful error messages.\n+\t* objc-tree.def (PROPERTY_REF): Increased the number of operands\n+\tfrom 2 to 3.  Updated comments.\n+\t* objc-act.h (PROPERTY_REF_GETTER_CALL): New.\n+\t\n 2010-11-06  Iain Sandoe  <iains@gcc.gnu.org>\n \n \tPR target/44981"}, {"sha": "fd5244e389a5fa21eb27c0be52f7935bb6761a4f", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 256, "deletions": 88, "changes": 344, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf", "patch": "@@ -377,8 +377,14 @@ static const char *default_constant_string_class_name;\n #define TAG_GNUINIT\t\t\t\"__objc_gnu_init\"\n \n /* Flags for lookup_method_static().  */\n-#define OBJC_LOOKUP_CLASS\t1\t/* Look for class methods.  */\n-#define OBJC_LOOKUP_NO_SUPER\t2\t/* Do not examine superclasses.  */\n+\n+/* Look for class methods.  */\n+#define OBJC_LOOKUP_CLASS\t1\n+/* Do not examine superclasses.  */\n+#define OBJC_LOOKUP_NO_SUPER\t2\n+/* Disable returning an instance method of a root class when a class\n+   method can't be found.  */\n+#define OBJC_LOOKUP_NO_INSTANCE_METHODS_OF_ROOT_CLASS 4 \n \n /* The OCTI_... enumeration itself is in objc/objc-act.h.  */\n tree objc_global_trees[OCTI_MAX];\n@@ -1085,32 +1091,58 @@ lookup_property (tree interface_type, tree property)\n }\n \n /* This is a subroutine of objc_maybe_build_component_ref.  Search the\n-   list of methods in the interface (and, failing that, protocol list)\n+   list of methods in the interface (and, failing that, the local list\n+   in the implementation, and failing that, the protocol list)\n    provided for a 'setter' or 'getter' for 'component' with default\n    names (ie, if 'component' is \"name\", then search for \"name\" and\n    \"setName:\").  If any is found, then create an artificial property\n    that uses them.  Return NULL_TREE if 'getter' or 'setter' could not\n    be found.  */\n static tree\n-maybe_make_artificial_property_decl (tree interface, tree protocol_list, tree component, bool is_class)\n+maybe_make_artificial_property_decl (tree interface, tree implementation, \n+\t\t\t\t     tree protocol_list, tree component, bool is_class)\n {\n   tree getter_name = component;\n   tree setter_name = get_identifier (objc_build_property_setter_name (component));\n   tree getter = NULL_TREE;\n   tree setter = NULL_TREE;\n \n+  /* First, check the @interface and all superclasses.  */\n   if (interface)\n     {\n       int flags = 0;\n \n+      /* Using instance methods of the root class as accessors is most\n+\t likely unwanted and can be extremely confusing (and, most\n+\t importantly, other Objective-C 2.0 compilers do not do it).\n+\t Turn it off.  */\n       if (is_class)\n-\tflags = OBJC_LOOKUP_CLASS;\n+\tflags = OBJC_LOOKUP_CLASS | OBJC_LOOKUP_NO_INSTANCE_METHODS_OF_ROOT_CLASS;\n       \n       getter = lookup_method_static (interface, getter_name, flags);\n       setter = lookup_method_static (interface, setter_name, flags);\n     }\n \n-  /* Try the protocol_list if we didn't find anything in the interface.  */\n+  /* Second, check the local @implementation context.  */\n+  if (!getter && !setter)\n+    {\n+      if (implementation)\n+\t{\n+\t  if (is_class)\n+\t    {\n+\t      getter = lookup_method (CLASS_CLS_METHODS (implementation), getter_name);\n+\t      setter = lookup_method (CLASS_CLS_METHODS (implementation), setter_name);\n+\t    }\n+\t  else\n+\t    {\n+\t      getter = lookup_method (CLASS_NST_METHODS (implementation), getter_name);\n+\t      setter = lookup_method (CLASS_NST_METHODS (implementation), setter_name);\t      \n+\t    }\n+\t}\n+    }\n+\n+  /* Try the protocol_list if we didn't find anything in the\n+     @interface and in the @implementation.  */\n   if (!getter && !setter)\n     {\n       getter = lookup_method_in_protocol_list (protocol_list, getter_name, is_class);\n@@ -1186,13 +1218,13 @@ objc_maybe_build_component_ref (tree object, tree property_ident)\n   tree x = NULL_TREE;\n   tree rtype;\n \n-  /* If we are in Objective-C 1.0 mode, properties are not\n-     available.  */\n+  /* If we are in Objective-C 1.0 mode, dot-syntax and properties are\n+     not available.  */\n   if (flag_objc1_only)\n     return NULL_TREE;\n \n-  /* Try to determine quickly if 'object' is an Objective-C object or\n-     not.  If not, return.  */\n+  /* Try to determine if 'object' is an Objective-C object or not.  If\n+     not, return.  */\n   if (object == NULL_TREE || object == error_mark_node \n       || (rtype = TREE_TYPE (object)) == NULL_TREE)\n     return NULL_TREE;\n@@ -1201,37 +1233,118 @@ objc_maybe_build_component_ref (tree object, tree property_ident)\n       || TREE_CODE (property_ident) != IDENTIFIER_NODE)\n     return NULL_TREE;\n \n-  /* TODO: Implement super.property.  */\n-  \n-  /* TODO: Carefully review the following code.  */\n+  /* The following analysis of 'object' is similar to the one used for\n+     the 'receiver' of a method invocation.  We need to determine what\n+     'object' is and find the appropriate property (either declared,\n+     or artificial) for it (in the same way as we need to find the\n+     appropriate method prototype for a method invocation).  There are\n+     some simplifications here though: \"object.property\" is invalid if\n+     \"object\" has a type of \"id\" or \"Class\"; it must at least have a\n+     protocol attached to it, and \"object\" is never a class name as\n+     that is done by objc_build_class_component_ref.  Finally, we\n+     don't know if this really is a dot-syntax expression, so we want\n+     to make a quick exit if it is not; for this reason, we try to\n+     postpone checks after determining that 'object' looks like an\n+     Objective-C object.  */\n+\n   if (objc_is_id (rtype))\n     {\n-      tree rprotos = (TYPE_HAS_OBJC_INFO (TREE_TYPE (rtype))\n-\t\t      ? TYPE_OBJC_PROTOCOL_LIST (TREE_TYPE (rtype))\n-\t\t      : NULL_TREE);\n-      if (rprotos)\n-\tx = lookup_property_in_protocol_list (rprotos, property_ident);\n+      /* This is the case that the 'object' is of type 'id' or\n+\t 'Class'.  */\n \n-      if (x == NULL_TREE)\n+      /* Check if at least it is of type 'id <Protocol>' or 'Class\n+\t <Protocol>'; if so, look the property up in the\n+\t protocols.  */\n+      if (TYPE_HAS_OBJC_INFO (TREE_TYPE (rtype)))\n \t{\n-\t  /* Ok, no property.  Maybe it was an object.component\n-\t     dot-syntax without a declared property.  Look for\n-\t     getter/setter methods and internally declare an artifical\n-\t     property based on them if found.  */\n-\t  x = maybe_make_artificial_property_decl (NULL_TREE, rprotos, \n-\t\t\t\t\t\t   property_ident,\n-\t\t\t\t\t\t   false);\n+\t  tree rprotos = TYPE_OBJC_PROTOCOL_LIST (TREE_TYPE (rtype));\n+\t  \n+\t  if (rprotos)\n+\t    {\n+\t      /* No point looking up declared @properties if we are\n+\t\t dealing with a class.  Classes have no declared\n+\t\t properties.  */\n+\t      if (!IS_CLASS (rtype))\n+\t\tx = lookup_property_in_protocol_list (rprotos, property_ident);\n+\t      \n+\t      if (x == NULL_TREE)\n+\t\t{\n+\t\t  /* Ok, no property.  Maybe it was an\n+\t\t     object.component dot-syntax without a declared\n+\t\t     property (this is valid for classes too).  Look\n+\t\t     for getter/setter methods and internally declare\n+\t\t     an artifical property based on them if found.  */\n+\t\t  x = maybe_make_artificial_property_decl (NULL_TREE,\n+\t\t\t\t\t\t\t   NULL_TREE,\n+\t\t\t\t\t\t\t   rprotos, \n+\t\t\t\t\t\t\t   property_ident,\n+\t\t\t\t\t\t\t   IS_CLASS (rtype));\n+\t\t}\n+\t    }\n+\t}\n+      else if (objc_method_context)\n+\t{\n+\t  /* Else, if we are inside a method it could be the case of\n+\t     'super' or 'self'.  */\n+\t  tree interface_type = NULL_TREE;\n+\t  tree t = object;\n+\t  while (TREE_CODE (t) == COMPOUND_EXPR\n+\t\t || TREE_CODE (t) == MODIFY_EXPR\n+\t\t || CONVERT_EXPR_P (t)\n+\t\t || TREE_CODE (t) == COMPONENT_REF)\n+\t    t = TREE_OPERAND (t, 0);\n+\t  \n+\t  if (t == UOBJC_SUPER_decl)\n+\t    interface_type = lookup_interface (CLASS_SUPER_NAME (implementation_template));\n+\t  else if (t == self_decl)\n+\t    interface_type = lookup_interface (CLASS_NAME (implementation_template));\n+\n+\t  /* TODO: Protocols.  */\n+\n+\t  if (interface_type)\n+\t    {\n+\t      if (TREE_CODE (objc_method_context) != CLASS_METHOD_DECL)\n+\t\t{\n+\t\t  x = lookup_property (interface_type, property_ident);\n+\t\t  /* TODO: Protocols.  */\n+\t\t}\n+\t\n+\t      if (x == NULL_TREE)\n+\t\t{\n+\t\t  /* Try the dot-syntax without a declared property.\n+\t\t     If this is an access to 'self', it is possible\n+\t\t     that they may refer to a setter/getter that is\n+\t\t     not declared in the interface, but exists locally\n+\t\t     in the implementation.  In that case, get the\n+\t\t     implementation context and use it.  */\n+\t\t  tree implementation = NULL_TREE;\n+\n+\t\t  if (t == self_decl)\n+\t\t    implementation = objc_implementation_context;\n+\t\t  \n+\t\t  /* TODO: Protocols.  */\n+\n+\t\t  x = maybe_make_artificial_property_decl \n+\t\t    (interface_type, implementation, NULL_TREE,\n+\t\t     property_ident,\n+\t\t     (TREE_CODE (objc_method_context) == CLASS_METHOD_DECL));\n+\t\t}\n+\t    }\n \t}\n     }\n   else\n     {\n+      /* This is the case where we have more information on 'rtype'.  */\n       tree basetype = TYPE_MAIN_VARIANT (rtype);\n \n+      /* Skip the pointer - if none, it's not an Objective-C object or\n+\t class.  */\n       if (basetype != NULL_TREE && TREE_CODE (basetype) == POINTER_TYPE)\n \tbasetype = TREE_TYPE (basetype);\n       else\n \treturn NULL_TREE;\n \n+      /* Traverse typedefs.  */\n       while (basetype != NULL_TREE\n \t     && TREE_CODE (basetype) == RECORD_TYPE \n \t     && OBJC_TYPE_NAME (basetype)\n@@ -1243,58 +1356,91 @@ objc_maybe_build_component_ref (tree object, tree property_ident)\n \t{\n \t  tree interface_type = TYPE_OBJC_INTERFACE (basetype);\n \t  tree protocol_list = TYPE_OBJC_PROTOCOL_LIST (basetype);\n-\t  \n-\t  x = lookup_property (interface_type, property_ident);\n-\n-\t  if (x == NULL_TREE)\n-\t    x = lookup_property_in_protocol_list (protocol_list, property_ident);\n \n-\t  if (x == NULL_TREE)\n+\t  if (interface_type \n+\t      && (TREE_CODE (interface_type) == CLASS_INTERFACE_TYPE\n+\t\t  || TREE_CODE (interface_type) == CATEGORY_INTERFACE_TYPE\n+\t\t  || TREE_CODE (interface_type) == PROTOCOL_INTERFACE_TYPE))\n \t    {\n-\t      /* Ok, no property.  Try the dot-syntax without a\n-\t\t declared property.  */\n-\t      x = maybe_make_artificial_property_decl (interface_type, protocol_list, \n-\t\t\t\t\t\t       property_ident, false);\n+\t      /* Not sure 'rtype' could ever be a class here!  Just\n+\t\t for safety we keep the checks.  */\n+\t      if (!IS_CLASS (rtype))\n+\t\t{\n+\t\t  x = lookup_property (interface_type, property_ident);\n+\t\t  \n+\t\t  if (x == NULL_TREE)\n+\t\t    x = lookup_property_in_protocol_list (protocol_list, \n+\t\t\t\t\t\t\t  property_ident);\n+\t\t}\n+\t      \n+\t      if (x == NULL_TREE)\n+\t\t{\n+\t\t  /* Try the dot-syntax without a declared property.\n+\t\t     If we are inside a method implementation, it is\n+\t\t     possible that they may refer to a setter/getter\n+\t\t     that is not declared in the interface, but exists\n+\t\t     locally in the implementation.  In that case, get\n+\t\t     the implementation context and use it.  */\n+\t\t  tree implementation = NULL_TREE;\n+\n+\t\t  if (objc_implementation_context\n+\t\t      && CLASS_NAME (objc_implementation_context) \n+\t\t      == OBJC_TYPE_NAME (interface_type))\n+\t\t    implementation = objc_implementation_context;\n+\t\t  \n+\t\t  x = maybe_make_artificial_property_decl (interface_type,\n+\t\t\t\t\t\t\t   implementation,\n+\t\t\t\t\t\t\t   protocol_list, \n+\t\t\t\t\t\t\t   property_ident,\n+\t\t\t\t\t\t\t   IS_CLASS (rtype));\n+\t\t}\n \t    }\n \t}\n     }\n \n+  /* TODO: Fix compiling super.accessor.  */\n+\n   if (x)\n     {\n       tree expression;\n-\n-      if (TREE_DEPRECATED (x))\n-\twarn_deprecated_use (x, NULL_TREE);\n-\n-      expression = build2 (PROPERTY_REF, TREE_TYPE(x), object, x);\n-      SET_EXPR_LOCATION (expression, input_location);\n-      TREE_SIDE_EFFECTS (expression) = 1;\n+      tree getter_call;\n \n       /* We have an additional nasty problem here; if this\n \t PROPERTY_REF needs to become a 'getter', then the conversion\n \t from PROPERTY_REF into a getter call happens in gimplify,\n-\t after the selector table has already been generated and it is\n-\t too late to add another selector to it.  To work around the\n-\t problem, we always put the selector in the table at this\n-\t stage, as if we were building the method call here.  And the\n-\t easiest way to do this is precisely to build the method call,\n-\t then discard it.  Note that if the PROPERTY_REF becomes a\n-\t 'setter' instead of a 'getter', then we have added a selector\n-\t too many to the selector table.  This is a little\n-\t inefficient.\n-\n-\t TODO: This can be made more efficient; in particular we don't\n-\t need to build the whole message call, we could just work on\n-\t the selector.\n+\t after the selector table has already been generated and when\n+\t it is too late to add another selector to it.  To work around\n+\t the problem, we always create the getter call at this stage,\n+\t which puts the selector in the table.  Note that if the\n+\t PROPERTY_REF becomes a 'setter' instead of a 'getter', then\n+\t we have added a selector too many to the selector table.\n+\t This is a little inefficient.\n+\n+\t Also note that method calls to 'self' and 'super' require the\n+\t context (self_decl, UOBJS_SUPER_decl,\n+\t objc_implementation_context etc) to be built correctly; this\n+\t is yet another reason why building the call at the gimplify\n+\t stage (when this context has been lost) is not very\n+\t practical.  If we build it at this stage, we know it will\n+\t always be built correctly.\n \n \t If the PROPERTY_HAS_NO_GETTER() (ie, it is an artificial\n \t property decl created to deal with a dotsyntax not really\n \t referring to an existing property) then do not try to build a\n \t call to the getter as there is no getter.  */\n-      if (!PROPERTY_HAS_NO_GETTER (x))\n-\tobjc_finish_message_expr (object,\n-\t\t\t\t  PROPERTY_GETTER_NAME (x),\n-\t\t\t\t  NULL_TREE);\n+      if (PROPERTY_HAS_NO_GETTER (x))\n+\tgetter_call = NULL_TREE;\n+      else\n+\tgetter_call = objc_finish_message_expr (object,\n+\t\t\t\t\t\tPROPERTY_GETTER_NAME (x),\n+\t\t\t\t\t\tNULL_TREE);\n+\n+      if (TREE_DEPRECATED (x))\n+\twarn_deprecated_use (x, NULL_TREE);\n+\n+      expression = build3 (PROPERTY_REF, TREE_TYPE(x), object, x, getter_call);\n+      SET_EXPR_LOCATION (expression, input_location);\n+      TREE_SIDE_EFFECTS (expression) = 1;\n       \n       return expression;\n     }\n@@ -1341,26 +1487,28 @@ objc_build_class_component_ref (tree class_name, tree property_ident)\n       return error_mark_node;\n     }\n \n-  x = maybe_make_artificial_property_decl (rtype, NULL_TREE,\n+  x = maybe_make_artificial_property_decl (rtype, NULL_TREE, NULL_TREE,\n \t\t\t\t\t   property_ident,\n \t\t\t\t\t   true);\n   \n   if (x)\n     {\n       tree expression;\n+      tree getter_call;\n \n+      if (PROPERTY_HAS_NO_GETTER (x))\n+\tgetter_call = NULL_TREE;\n+      else\n+\tgetter_call = objc_finish_message_expr (object,\n+\t\t\t\t\t\tPROPERTY_GETTER_NAME (x),\n+\t\t\t\t\t\tNULL_TREE);\n       if (TREE_DEPRECATED (x))\n \twarn_deprecated_use (x, NULL_TREE);\n \n-      expression = build2 (PROPERTY_REF, TREE_TYPE(x), object, x);\n+      expression = build3 (PROPERTY_REF, TREE_TYPE(x), object, x, getter_call);\n       SET_EXPR_LOCATION (expression, input_location);\n       TREE_SIDE_EFFECTS (expression) = 1;\n-      /* See above for why we do this.  */\n-      if (!PROPERTY_HAS_NO_GETTER (x))\n-\tobjc_finish_message_expr (object,\n-\t\t\t\t  PROPERTY_GETTER_NAME (x),\n-\t\t\t\t  NULL_TREE);\n-      \n+\n       return expression;\n     }\n   else\n@@ -7957,13 +8105,16 @@ lookup_method (tree mchain, tree method)\n   return NULL_TREE;\n }\n \n-/* Look up a class (if OBJC_LOOKUP_CLASS is set in FLAGS) or instance method\n-   in INTERFACE, along with any categories and protocols attached thereto.\n-   If method is not found, and the OBJC_LOOKUP_NO_SUPER is _not_ set in FLAGS,\n-   recursively examine the INTERFACE's superclass.  If OBJC_LOOKUP_CLASS is\n-   set, OBJC_LOOKUP_NO_SUPER is cleared, and no suitable class method could\n-   be found in INTERFACE or any of its superclasses, look for an _instance_\n-   method of the same name in the root class as a last resort.\n+/* Look up a class (if OBJC_LOOKUP_CLASS is set in FLAGS) or instance\n+   method in INTERFACE, along with any categories and protocols\n+   attached thereto.  If method is not found, and the\n+   OBJC_LOOKUP_NO_SUPER is _not_ set in FLAGS, recursively examine the\n+   INTERFACE's superclass.  If OBJC_LOOKUP_CLASS is set,\n+   OBJC_LOOKUP_NO_SUPER is clear, and no suitable class method could\n+   be found in INTERFACE or any of its superclasses, look for an\n+   _instance_ method of the same name in the root class as a last\n+   resort.  This behaviour can be turned off by using\n+   OBJC_LOOKUP_NO_INSTANCE_METHODS_OF_ROOT_CLASS.\n \n    If a suitable method cannot be found, return NULL_TREE.  */\n \n@@ -7974,6 +8125,7 @@ lookup_method_static (tree interface, tree ident, int flags)\n   tree inter = interface;\n   int is_class = (flags & OBJC_LOOKUP_CLASS);\n   int no_superclasses = (flags & OBJC_LOOKUP_NO_SUPER);\n+  int no_instance_methods_of_root_class = (flags & OBJC_LOOKUP_NO_INSTANCE_METHODS_OF_ROOT_CLASS);\n \n   while (inter)\n     {\n@@ -8020,11 +8172,18 @@ lookup_method_static (tree interface, tree ident, int flags)\n     }\n   while (inter);\n \n-  /* If no class (factory) method was found, check if an _instance_\n-     method of the same name exists in the root class.  This is what\n-     the Objective-C runtime will do.  If an instance method was not\n-     found, return 0.  */\n-  return is_class ? lookup_method_static (root_inter, ident, 0): NULL_TREE;\n+  if (is_class && !no_instance_methods_of_root_class)\n+    {\n+      /* If no class (factory) method was found, check if an _instance_\n+\t method of the same name exists in the root class.  This is what\n+\t the Objective-C runtime will do.  */\n+      return lookup_method_static (root_inter, ident, 0);\n+    }\n+  else\n+    {\n+      /* If an instance method was not found, return 0.  */      \n+      return NULL_TREE;\n+    }\n }\n \n /* Add the method to the hash list if it doesn't contain an identical\n@@ -12038,15 +12197,24 @@ objc_rewrite_function_call (tree function, tree first_param)\n static void\n objc_gimplify_property_ref (tree *expr_p)\n {\n-  tree object_expression = PROPERTY_REF_OBJECT (*expr_p);\n-  tree property_decl = PROPERTY_REF_PROPERTY_DECL (*expr_p);\n-  tree call_exp, getter;\n-\n-  /* TODO: Implement super.property.  */\n+  tree getter = PROPERTY_REF_GETTER_CALL (*expr_p);\n+  tree call_exp;\n+\n+  if (getter == NULL_TREE)\n+    {\n+      tree property_decl = PROPERTY_REF_PROPERTY_DECL (*expr_p);\n+      /* This can happen if DECL_ARTIFICIAL (*expr_p), but\n+\t should be impossible for real properties, which always\n+\t have a getter.  */\n+      error_at (EXPR_LOCATION (*expr_p), \"no %qs getter found\",\n+\t\tIDENTIFIER_POINTER (PROPERTY_NAME (property_decl)));\n+      /* Try to recover from the error to prevent an ICE.  We take\n+\t zero and cast it to the type of the property.  */\n+      *expr_p = convert (TREE_TYPE (property_decl),\n+\t\t\t integer_zero_node);\n+      return;\n+    }\n \n-  getter = objc_finish_message_expr (object_expression, \n-\t\t\t\t     PROPERTY_GETTER_NAME (property_decl),\n-\t\t\t\t     NULL_TREE);\n   call_exp = getter;\n #ifdef OBJCPLUS\n   /* In C++, a getter which returns an aggregate value results in a"}, {"sha": "9a9cacd668ff924f681599a4a3f400fe56c1a837", "filename": "gcc/objc/objc-act.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf/gcc%2Fobjc%2Fobjc-act.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf/gcc%2Fobjc%2Fobjc-act.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.h?ref=a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf", "patch": "@@ -131,6 +131,15 @@ typedef enum objc_property_assign_semantics {\n    declared property.  */\n #define PROPERTY_REF_PROPERTY_DECL(NODE) TREE_OPERAND (PROPERTY_REF_CHECK (NODE), 1)\n \n+/* PROPERTY_REF_GETTER_CALL is the getter call expression, ready to\n+   use at gimplify time if needed.  Generating the getter call\n+   requires modifying the selector table, and, in the case of\n+   self/super, requires the context to be generated correctly.  The\n+   gimplify stage is too late to do these things, so we generate the\n+   getter call earlier instead, and keep it here in case we need to\n+   use it.  */\n+#define PROPERTY_REF_GETTER_CALL(NODE) TREE_OPERAND (PROPERTY_REF_CHECK (NODE), 2)\n+\n \n /* CLASS_INTERFACE_TYPE, CLASS_IMPLEMENTATION_TYPE,\n    CATEGORY_INTERFACE_TYPE, CATEGORY_IMPLEMENTATION_TYPE,"}, {"sha": "e33fc78db2974679e88d68e441c3da281379f450", "filename": "gcc/objc/objc-tree.def", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf/gcc%2Fobjc%2Fobjc-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf/gcc%2Fobjc%2Fobjc-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-tree.def?ref=a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf", "patch": "@@ -44,23 +44,27 @@ DEFTREECODE (CLASS_REFERENCE_EXPR, \"class_reference_expr\", tcc_expression, 1)\n    where 'object' is an Objective-C object and 'property' is an\n    Objective-C property.  Operand 0 is the object (the tree\n    representing the expression), and Operand 1 is the property (the\n-   PROPERTY_DECL).  A PROPERTY_REF tree needs to be transformed into\n-   'setter' and 'getter' calls at some point; at the moment this\n-   happens in two places:\n+   PROPERTY_DECL).  Operand 2 is the 'getter' call, ready to be used;\n+   we pregenerate it because it is hard to generate it properly later\n+   on.  A PROPERTY_REF tree needs to be transformed into 'setter' and\n+   'getter' calls at some point; at the moment this happens in two\n+   places:\n \n      * if we detect that a modify expression is being applied to a\n        PROPERTY_REF, then we transform that into a 'getter' call (this\n        happens in build_modify_expr() or cp_build_modify_expr()).\n \n     * else, it will remain as a PROPERTY_REF until we get to\n       gimplification; at that point, we convert each PROPERTY_REF into\n-      a 'getter' call during ObjC/ObjC++ gimplify.\n+      a 'getter' call during ObjC/ObjC++ gimplify.  At that point, it\n+      is quite hard to build a 'getter' call, but we have already built\n+      it and we just need to swap Operand 2 in.\n \n   Please note that when the Objective-C 2.0 \"dot-syntax\" 'object.component' \n   is encountered, where 'component' is not a property but there are valid\n   setter/getter methods for it, an artificial PROPERTY_DECL is generated\n   and used in the PROPERTY_REF.  */\n-DEFTREECODE (PROPERTY_REF, \"property_ref\", tcc_expression, 2)\n+DEFTREECODE (PROPERTY_REF, \"property_ref\", tcc_expression, 3)\n \n /*\n Local variables:"}, {"sha": "fc8fc748d02faf50262962214246b37214b7ec6a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf", "patch": "@@ -1,3 +1,21 @@\n+2010-11-06  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\tFixed using the Objective-C 2.0 dot-syntax with self and super.\n+\t* objc.dg/property/dotsyntax-5.m: New.\n+\t* objc.dg/property/dotsyntax-6.m: New.\n+\t* objc.dg/property/dotsyntax-7.m: New.\n+\t* objc.dg/property/dotsyntax-8.m: New.\n+\t* objc.dg/property/dotsyntax-9.m: New.\n+\t* objc.dg/property/dotsyntax-10.m: New.\n+\t* objc.dg/property/dotsyntax-11.m: New.\n+\t* obj-c++.dg/property/dotsyntax-5.mm: New.\n+\t* obj-c++.dg/property/dotsyntax-6.mm: New.\n+\t* obj-c++.dg/property/dotsyntax-7.mm: New.\n+\t* obj-c++.dg/property/dotsyntax-8.mm: New.\n+\t* obj-c++.dg/property/dotsyntax-9.mm: New.\n+\t* obj-c++.dg/property/dotsyntax-10.mm: New.\n+\t* obj-c++.dg/property/dotsyntax-11.mm: New.\n+\n 2010-11-06  Iain Sandoe  <iains@gcc.gnu.org>\n \n \t* obj-c++.dg/encode-3.mm: Provide a different string check for the"}, {"sha": "433595f3daa1902ea0c6213911d71d82bf586231", "filename": "gcc/testsuite/obj-c++.dg/property/dotsyntax-10.mm", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-10.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-10.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-10.mm?ref=a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf", "patch": "@@ -0,0 +1,86 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do run } */\n+/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* Test dot-syntax with 'super'.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+static int c;\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  int a;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+- (int) count;\n+- (void) setCount: (int)count;\n++ (int) classCount;\n++ (void) setClassCount: (int)count;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+- (int) count\n+{\n+  return a;\n+}\n+- (void) setCount: (int)count\n+{\n+  a = count;\n+}\n++ (int) classCount\n+{\n+  return c;\n+}\n++ (void) setClassCount: (int)count\n+{\n+  c = count;\n+}\n+@end\n+\n+@interface MySubClass : MyRootClass\n++ (int) testMe;\n+- (int) testMe;\n+@end\n+\n+@implementation MySubClass\n+- (int) testMe\n+{\n+  super.count = 400;\n+  if (super.count != 400)\n+    abort ();\n+\n+  return super.count;\n+}\n++ (int) testMe\n+{\n+  super.classCount = 4000;\n+  if (super.classCount != 4000)\n+    abort ();\n+\n+  return super.classCount;\n+}\n+@end\n+\n+int main (void)\n+{\n+  MySubClass *object = [[MySubClass alloc] init];\n+\n+  if ([object testMe] != 400)\n+    abort ();\n+\n+  if ([MySubClass testMe] != 4000)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+"}, {"sha": "6c9d924ca82ae32a05539bd9376ff9794324add1", "filename": "gcc/testsuite/obj-c++.dg/property/dotsyntax-11.mm", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-11.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-11.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-11.mm?ref=a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf", "patch": "@@ -0,0 +1,61 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do compile } */\n+\n+/* Test the error reporting for the dot-syntax in the scenario where\n+   we have a setter, but not a getter, yet a getter is requested.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+static int c;\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  int a;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+- (void) setCount: (int)count;\n++ (void) setClassCount: (int)count;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+- (void) setCount: (int)count\n+{\n+  a = count;\n+}\n++ (void) setClassCount: (int)count\n+{\n+  c = count;\n+}\n+@end\n+\n+@interface MySubClass : MyRootClass\n++ (int) testMe;\n+- (int) testMe;\n+@end\n+\n+@implementation MySubClass\n+- (int) testMe\n+{\n+  super.count = 400;\n+  if (super.count != 400) /* { dg-error \"no .count. getter found\" } */\n+    abort ();             \n+\n+  return super.count;     /* { dg-error \"no .count. getter found\" } */\n+}\n++ (int) testMe\n+{\n+  super.classCount = 4000;\n+  if (super.classCount != 4000) /* { dg-error \"no .classCount. getter found\" } */\n+    abort ();\n+\n+  return super.classCount;      /* { dg-error \"no .classCount. getter found\" } */\n+}\n+@end"}, {"sha": "06e11303219a67ac6f0fbc6657b8f18ff542e280", "filename": "gcc/testsuite/obj-c++.dg/property/dotsyntax-5.mm", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-5.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-5.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-5.mm?ref=a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf", "patch": "@@ -0,0 +1,78 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do run } */\n+/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* Test the 'dot syntax' with self, both in instance and class methods.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+static int c;\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  int a;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+- (int) count;\n+- (void) setCount: (int)count;\n++ (int) classCount;\n++ (void) setClassCount: (int)count;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+- (int) count\n+{\n+  return a;\n+}\n+- (void) setCount: (int)count\n+{\n+  a = count;\n+}\n++ (int) classCount\n+{\n+  return c;\n+}\n++ (void) setClassCount: (int)count\n+{\n+  c = count;\n+}\n+- (int) testMe\n+{\n+  self.count = 400;\n+  if (self.count != 400)\n+    abort ();\n+\n+  return self.count;\n+}\n++ (int) testMe\n+{\n+  self.classCount = 4000;\n+  if (self.classCount != 4000)\n+    abort ();\n+\n+  return self.classCount;\n+}\n+@end\n+\n+int main (void)\n+{\n+  MyRootClass *object = [[MyRootClass alloc] init];\n+\n+  if ([object testMe] != 400)\n+    abort ();\n+\n+  if ([MyRootClass testMe] != 4000)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+"}, {"sha": "cc8c567cff984c7c535c4d6b1d054d6e679e9325", "filename": "gcc/testsuite/obj-c++.dg/property/dotsyntax-6.mm", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-6.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-6.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-6.mm?ref=a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf", "patch": "@@ -0,0 +1,107 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do run } */\n+/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* Test nested 'dot syntax' (xxx.yyy.zzz or [xxx yyy].zzz).  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@class MyRootClass;\n+\n+static int c;\n+static MyRootClass *shared_root = nil;\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  int a;\n+  int b;\n+  MyRootClass *next;\n+}\n+@property int b;\n+@property (assign) MyRootClass *next;\n++ (id) initialize;\n++ (MyRootClass *)sharedInstance;\n++ (id) alloc;\n+- (id) init;\n+- (MyRootClass *)same;\n+- (int) count;\n+- (void) setCount: (int)count;\n+@end\n+\n+@implementation MyRootClass\n+@synthesize b;\n+@synthesize next;\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n++ (MyRootClass *)sharedInstance\n+{\n+  if (!shared_root)\n+    shared_root = [[self alloc] init];\n+\n+  return shared_root;\n+}\n+- (MyRootClass *)same\n+{\n+  return self;\n+}\n+- (int) count\n+{\n+  return a;\n+}\n+- (void) setCount: (int)count\n+{\n+  a = count;\n+}\n+@end\n+\n+int main (void)\n+{\n+  MyRootClass *object = [[MyRootClass alloc] init];\n+\n+  /* Test ClassName.accessor.accessor.  */\n+  MyRootClass.sharedInstance.count = 500;\n+  if (MyRootClass.sharedInstance.count != 500)\n+    abort ();\n+\n+  /* Test object.accessor.accessor.  */\n+  object.same.count = 1000;\n+  if (object.same.count != 1000)\n+    abort ();\n+\n+  /* Test object.accessor.property.  */\n+  object.same.next = object;\n+  if (object.same.next != object)\n+    abort ();\n+\n+  /* Test lots of nesting.  */\n+  if (object.next.next.same.same.next.next.same != object)\n+    abort ();\n+\n+  /* Test more nesting.  */\n+  MyRootClass.sharedInstance.next = object;\n+  MyRootClass.sharedInstance.next.next.next.next.next.count = 2000;\n+  if (MyRootClass.sharedInstance.next.next.next.next.next.count != 2000)\n+    abort ();\n+\n+  /* Test more nesting.  */\n+  MyRootClass.sharedInstance.same.same.same.same.same.count = 3000;\n+  if (MyRootClass.sharedInstance.same.same.same.same.same.count != 3000)\n+    abort ();\n+\n+  /* Test [object method].property.  */\n+  [MyRootClass sharedInstance].count = 5000;\n+  if ([MyRootClass sharedInstance].count != 5000)\n+    abort ();\n+\n+  /* Just a final check.  */\n+  if (shared_root.count != 5000)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+"}, {"sha": "15c1725d833a23720e618d61e51a3d4ce1265e37", "filename": "gcc/testsuite/obj-c++.dg/property/dotsyntax-7.mm", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-7.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-7.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-7.mm?ref=a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf", "patch": "@@ -0,0 +1,48 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do run } */\n+/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* Test dot syntax of a casted expression.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  int a;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+- (int) count;\n+- (void) setCount: (int)count;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+- (int) count\n+{\n+  return a;\n+}\n+- (void) setCount: (int)count\n+{\n+  a = count;\n+}\n+@end\n+\n+int main (void)\n+{\n+  id object = [[MyRootClass alloc] init];\n+\n+  ((MyRootClass *)object).count = 200;\n+  if (((MyRootClass *)object).count != 200)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+"}, {"sha": "35dfda40c9dc4e24208da15929f57d3ed511b987", "filename": "gcc/testsuite/obj-c++.dg/property/dotsyntax-8.mm", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-8.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-8.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-8.mm?ref=a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf", "patch": "@@ -0,0 +1,62 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do run } */\n+/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* Test the 'dot syntax' with typedefs.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+static int c;\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  int a;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+- (int) count;\n+- (void) setCount: (int)count;\n++ (int) classCount;\n++ (void) setClassCount: (int)count;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+- (int) count\n+{\n+  return a;\n+}\n+- (void) setCount: (int)count\n+{\n+  a = count;\n+}\n++ (int) classCount\n+{\n+  return c;\n+}\n++ (void) setClassCount: (int)count\n+{\n+  c = count;\n+}\n+@end\n+\n+typedef MyRootClass MyType;\n+\n+int main (void)\n+{\n+  MyType *object = [[MyRootClass alloc] init];\n+\n+  object.count = 1974;\n+  if (object.count != 1974)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+"}, {"sha": "61a5c0eb8c6d488da72219f369cef0bc1f807bc8", "filename": "gcc/testsuite/obj-c++.dg/property/dotsyntax-9.mm", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-9.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-9.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-9.mm?ref=a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf", "patch": "@@ -0,0 +1,77 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do run } */\n+/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* Test that setter/getters for dot-syntax are properly found even if\n+   not declared in the @interface, but available in the local\n+   @implementation before the current line (ie, [object name] can be\n+   compiled in that case, so object.name should be compiled too).  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+static int c;\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  int a;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+- (int) count\n+{\n+  return a;\n+}\n+- (void) setCount: (int)count\n+{\n+  a = count;\n+}\n++ (int) classCount\n+{\n+  return c;\n+}\n++ (void) setClassCount: (int)count\n+{\n+  c = count;\n+}\n+- (int) testMe\n+{\n+  self.count = 400;\n+  if (self.count != 400)\n+    abort ();\n+\n+  return self.count;\n+}\n++ (int) testMe\n+{\n+  self.classCount = 4000;\n+  if (self.classCount != 4000)\n+    abort ();\n+\n+  return self.classCount;\n+}\n+@end\n+\n+int main (void)\n+{\n+  MyRootClass *object = [[MyRootClass alloc] init];\n+\n+  if ([object testMe] != 400)\n+    abort ();\n+\n+  if ([MyRootClass testMe] != 4000)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+"}, {"sha": "433595f3daa1902ea0c6213911d71d82bf586231", "filename": "gcc/testsuite/objc.dg/property/dotsyntax-10.m", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-10.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-10.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-10.m?ref=a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf", "patch": "@@ -0,0 +1,86 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do run } */\n+/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* Test dot-syntax with 'super'.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+static int c;\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  int a;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+- (int) count;\n+- (void) setCount: (int)count;\n++ (int) classCount;\n++ (void) setClassCount: (int)count;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+- (int) count\n+{\n+  return a;\n+}\n+- (void) setCount: (int)count\n+{\n+  a = count;\n+}\n++ (int) classCount\n+{\n+  return c;\n+}\n++ (void) setClassCount: (int)count\n+{\n+  c = count;\n+}\n+@end\n+\n+@interface MySubClass : MyRootClass\n++ (int) testMe;\n+- (int) testMe;\n+@end\n+\n+@implementation MySubClass\n+- (int) testMe\n+{\n+  super.count = 400;\n+  if (super.count != 400)\n+    abort ();\n+\n+  return super.count;\n+}\n++ (int) testMe\n+{\n+  super.classCount = 4000;\n+  if (super.classCount != 4000)\n+    abort ();\n+\n+  return super.classCount;\n+}\n+@end\n+\n+int main (void)\n+{\n+  MySubClass *object = [[MySubClass alloc] init];\n+\n+  if ([object testMe] != 400)\n+    abort ();\n+\n+  if ([MySubClass testMe] != 4000)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+"}, {"sha": "6c9d924ca82ae32a05539bd9376ff9794324add1", "filename": "gcc/testsuite/objc.dg/property/dotsyntax-11.m", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-11.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-11.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-11.m?ref=a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf", "patch": "@@ -0,0 +1,61 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do compile } */\n+\n+/* Test the error reporting for the dot-syntax in the scenario where\n+   we have a setter, but not a getter, yet a getter is requested.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+static int c;\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  int a;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+- (void) setCount: (int)count;\n++ (void) setClassCount: (int)count;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+- (void) setCount: (int)count\n+{\n+  a = count;\n+}\n++ (void) setClassCount: (int)count\n+{\n+  c = count;\n+}\n+@end\n+\n+@interface MySubClass : MyRootClass\n++ (int) testMe;\n+- (int) testMe;\n+@end\n+\n+@implementation MySubClass\n+- (int) testMe\n+{\n+  super.count = 400;\n+  if (super.count != 400) /* { dg-error \"no .count. getter found\" } */\n+    abort ();             \n+\n+  return super.count;     /* { dg-error \"no .count. getter found\" } */\n+}\n++ (int) testMe\n+{\n+  super.classCount = 4000;\n+  if (super.classCount != 4000) /* { dg-error \"no .classCount. getter found\" } */\n+    abort ();\n+\n+  return super.classCount;      /* { dg-error \"no .classCount. getter found\" } */\n+}\n+@end"}, {"sha": "06e11303219a67ac6f0fbc6657b8f18ff542e280", "filename": "gcc/testsuite/objc.dg/property/dotsyntax-5.m", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-5.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-5.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-5.m?ref=a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf", "patch": "@@ -0,0 +1,78 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do run } */\n+/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* Test the 'dot syntax' with self, both in instance and class methods.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+static int c;\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  int a;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+- (int) count;\n+- (void) setCount: (int)count;\n++ (int) classCount;\n++ (void) setClassCount: (int)count;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+- (int) count\n+{\n+  return a;\n+}\n+- (void) setCount: (int)count\n+{\n+  a = count;\n+}\n++ (int) classCount\n+{\n+  return c;\n+}\n++ (void) setClassCount: (int)count\n+{\n+  c = count;\n+}\n+- (int) testMe\n+{\n+  self.count = 400;\n+  if (self.count != 400)\n+    abort ();\n+\n+  return self.count;\n+}\n++ (int) testMe\n+{\n+  self.classCount = 4000;\n+  if (self.classCount != 4000)\n+    abort ();\n+\n+  return self.classCount;\n+}\n+@end\n+\n+int main (void)\n+{\n+  MyRootClass *object = [[MyRootClass alloc] init];\n+\n+  if ([object testMe] != 400)\n+    abort ();\n+\n+  if ([MyRootClass testMe] != 4000)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+"}, {"sha": "cc8c567cff984c7c535c4d6b1d054d6e679e9325", "filename": "gcc/testsuite/objc.dg/property/dotsyntax-6.m", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-6.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-6.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-6.m?ref=a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf", "patch": "@@ -0,0 +1,107 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do run } */\n+/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* Test nested 'dot syntax' (xxx.yyy.zzz or [xxx yyy].zzz).  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@class MyRootClass;\n+\n+static int c;\n+static MyRootClass *shared_root = nil;\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  int a;\n+  int b;\n+  MyRootClass *next;\n+}\n+@property int b;\n+@property (assign) MyRootClass *next;\n++ (id) initialize;\n++ (MyRootClass *)sharedInstance;\n++ (id) alloc;\n+- (id) init;\n+- (MyRootClass *)same;\n+- (int) count;\n+- (void) setCount: (int)count;\n+@end\n+\n+@implementation MyRootClass\n+@synthesize b;\n+@synthesize next;\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n++ (MyRootClass *)sharedInstance\n+{\n+  if (!shared_root)\n+    shared_root = [[self alloc] init];\n+\n+  return shared_root;\n+}\n+- (MyRootClass *)same\n+{\n+  return self;\n+}\n+- (int) count\n+{\n+  return a;\n+}\n+- (void) setCount: (int)count\n+{\n+  a = count;\n+}\n+@end\n+\n+int main (void)\n+{\n+  MyRootClass *object = [[MyRootClass alloc] init];\n+\n+  /* Test ClassName.accessor.accessor.  */\n+  MyRootClass.sharedInstance.count = 500;\n+  if (MyRootClass.sharedInstance.count != 500)\n+    abort ();\n+\n+  /* Test object.accessor.accessor.  */\n+  object.same.count = 1000;\n+  if (object.same.count != 1000)\n+    abort ();\n+\n+  /* Test object.accessor.property.  */\n+  object.same.next = object;\n+  if (object.same.next != object)\n+    abort ();\n+\n+  /* Test lots of nesting.  */\n+  if (object.next.next.same.same.next.next.same != object)\n+    abort ();\n+\n+  /* Test more nesting.  */\n+  MyRootClass.sharedInstance.next = object;\n+  MyRootClass.sharedInstance.next.next.next.next.next.count = 2000;\n+  if (MyRootClass.sharedInstance.next.next.next.next.next.count != 2000)\n+    abort ();\n+\n+  /* Test more nesting.  */\n+  MyRootClass.sharedInstance.same.same.same.same.same.count = 3000;\n+  if (MyRootClass.sharedInstance.same.same.same.same.same.count != 3000)\n+    abort ();\n+\n+  /* Test [object method].property.  */\n+  [MyRootClass sharedInstance].count = 5000;\n+  if ([MyRootClass sharedInstance].count != 5000)\n+    abort ();\n+\n+  /* Just a final check.  */\n+  if (shared_root.count != 5000)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+"}, {"sha": "15c1725d833a23720e618d61e51a3d4ce1265e37", "filename": "gcc/testsuite/objc.dg/property/dotsyntax-7.m", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-7.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-7.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-7.m?ref=a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf", "patch": "@@ -0,0 +1,48 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do run } */\n+/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* Test dot syntax of a casted expression.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  int a;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+- (int) count;\n+- (void) setCount: (int)count;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+- (int) count\n+{\n+  return a;\n+}\n+- (void) setCount: (int)count\n+{\n+  a = count;\n+}\n+@end\n+\n+int main (void)\n+{\n+  id object = [[MyRootClass alloc] init];\n+\n+  ((MyRootClass *)object).count = 200;\n+  if (((MyRootClass *)object).count != 200)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+"}, {"sha": "35dfda40c9dc4e24208da15929f57d3ed511b987", "filename": "gcc/testsuite/objc.dg/property/dotsyntax-8.m", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-8.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-8.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-8.m?ref=a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf", "patch": "@@ -0,0 +1,62 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do run } */\n+/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* Test the 'dot syntax' with typedefs.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+static int c;\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  int a;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+- (int) count;\n+- (void) setCount: (int)count;\n++ (int) classCount;\n++ (void) setClassCount: (int)count;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+- (int) count\n+{\n+  return a;\n+}\n+- (void) setCount: (int)count\n+{\n+  a = count;\n+}\n++ (int) classCount\n+{\n+  return c;\n+}\n++ (void) setClassCount: (int)count\n+{\n+  c = count;\n+}\n+@end\n+\n+typedef MyRootClass MyType;\n+\n+int main (void)\n+{\n+  MyType *object = [[MyRootClass alloc] init];\n+\n+  object.count = 1974;\n+  if (object.count != 1974)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+"}, {"sha": "61a5c0eb8c6d488da72219f369cef0bc1f807bc8", "filename": "gcc/testsuite/objc.dg/property/dotsyntax-9.m", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-9.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-9.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-9.m?ref=a9625a91d2cd2ef2cc6d82f6ace9be5199745fdf", "patch": "@@ -0,0 +1,77 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do run } */\n+/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* Test that setter/getters for dot-syntax are properly found even if\n+   not declared in the @interface, but available in the local\n+   @implementation before the current line (ie, [object name] can be\n+   compiled in that case, so object.name should be compiled too).  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+static int c;\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  int a;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+- (int) count\n+{\n+  return a;\n+}\n+- (void) setCount: (int)count\n+{\n+  a = count;\n+}\n++ (int) classCount\n+{\n+  return c;\n+}\n++ (void) setClassCount: (int)count\n+{\n+  c = count;\n+}\n+- (int) testMe\n+{\n+  self.count = 400;\n+  if (self.count != 400)\n+    abort ();\n+\n+  return self.count;\n+}\n++ (int) testMe\n+{\n+  self.classCount = 4000;\n+  if (self.classCount != 4000)\n+    abort ();\n+\n+  return self.classCount;\n+}\n+@end\n+\n+int main (void)\n+{\n+  MyRootClass *object = [[MyRootClass alloc] init];\n+\n+  if ([object testMe] != 400)\n+    abort ();\n+\n+  if ([MyRootClass testMe] != 4000)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+"}]}