{"sha": "cd1440b199ae8476f1b6df884e86fa07388e1f80", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2QxNDQwYjE5OWFlODQ3NmYxYjZkZjg4NGU4NmZhMDczODhlMWY4MA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2012-07-24T18:28:15Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2012-07-24T18:28:15Z"}, "message": "Reduce the size of optabs representation\n\nFrom-SVN: r189821", "tree": {"sha": "7a5f81d480a16d01d04ed37f989cde0c027bbf45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a5f81d480a16d01d04ed37f989cde0c027bbf45"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd1440b199ae8476f1b6df884e86fa07388e1f80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd1440b199ae8476f1b6df884e86fa07388e1f80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd1440b199ae8476f1b6df884e86fa07388e1f80", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd1440b199ae8476f1b6df884e86fa07388e1f80/comments", "author": null, "committer": null, "parents": [{"sha": "658e8ebaac1aff81586940d4ca1661e0ab3c5f91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/658e8ebaac1aff81586940d4ca1661e0ab3c5f91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/658e8ebaac1aff81586940d4ca1661e0ab3c5f91"}], "stats": {"total": 3017, "additions": 1108, "deletions": 1909}, "files": [{"sha": "ee809e011570472716677d08dbcd615d602a13bc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd1440b199ae8476f1b6df884e86fa07388e1f80/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd1440b199ae8476f1b6df884e86fa07388e1f80/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cd1440b199ae8476f1b6df884e86fa07388e1f80", "patch": "@@ -1,3 +1,139 @@\n+2012-07-24  Richard Henderson  <rth@redhat.com>\n+\n+\t* optabs.def: New file.\n+\t* Makefile.in (OPTABS_H): Add insn-opinit.h.\n+\t(MOSTLYCLEANFILES): Likewise.\n+\t(insn-opinit.o): Remove reload.h\n+\t(simple_rtl_generated_c): Remove insn-opinit.c.\n+\t(s-opinit): New rule.\n+\t(build/genopinit.o): Add optabs.def.\n+\t* genopinit.c (rtx_upname): New.\n+\t(optabs): Extract to optabs.def\n+\t(enum optab_tag, struct optab_def_d, optabs): New.\n+\t(struct pattern_d, patterns): New.\n+\t(match_pattern): Split out from ...\n+\t(gen_insn): ... here.  Push matches on patterns vec.\n+\t(pattern_cmp, optab_kind_cmp, optab_rcode_cmp): New.\n+\t(header_file_name, source_file_name, handle_arg): New.\n+\t(open_outfile): New.\n+\t(main): Sort and emit new tables.  Generate lookup_handler,\n+\traw_optab_handler, swap_optab_enable.\n+\t* libfuncs.h (libfunc_entry): Change \"size_t optab\" to \"optab op\".\n+\t* optabs.c (code_to_optab_): Remove.\n+\t(hash_libfunc): Update for optab name change.\n+\t(eq_libfunc): Likewise.\n+\t(convert_optab_libfunc): Update computation of optab member;\n+\tuse the new convlib_def table.\n+\t(optab_libfunc): Similarly.\n+\t(set_optab_libfunc, set_conv_libfunc): Likewise.\n+\t(sign_expand_binop): Use swap_optab_enable instead of fake optabs.\n+\t(init_insn_codes, init_optab, init_optabv, init_convert_optab): Remove.\n+\t(init_optabs): Don't call them; export the data to optabs.def.\n+\t(gen_int_libfunc, gen_fp_libfunc): Export non-static.\n+\t(gen_fixed_libfunc, gen_signed_fixed_libfunc): Likewise.\n+\t(gen_unsigned_fixed_libfunc, gen_int_fp_libfunc): Likewise.\n+\t(gen_intv_fp_libfunc, gen_int_fp_fixed_libfunc): Likewise.\n+\t(gen_int_fp_signed_fixed_libfunc, gen_int_fixed_libfunc): Likewise.\n+\t(gen_int_signed_fixed_libfunc): Likewise.\n+\t(gen_int_unsigned_fixed_libfunc): Likewise.\n+\t(gen_interclass_conv_libfunc, gen_int_to_fp_conv_libfunc): Likewise.\n+\t(gen_ufloat_conv_libfunc): Likewise.\n+\t(gen_int_to_fp_nondecimal_conv_libfunc): Likewise.\n+\t(gen_fp_to_int_conv_libfunc, gen_intraclass_conv_libfunc): Likewise.\n+\t(gen_trunc_conv_libfunc, gen_extend_conv_libfunc): Likewise.\n+\t(gen_fract_conv_libfunc, gen_fractuns_conv_libfunc): Likewise.\n+\t(gen_satfract_conv_libfunc, gen_satfractuns_conv_libfunc): Likewise.\n+\t(debug_optab_libfuncs): Update for optab representation change.\n+\t* optabs.h: Include insn-opinit.h.\n+\t(optab, convert_optab, direct_optab): New typedefs.\n+\t(struct optab_handlers, struct widening_optab_handlers): Remove.\n+\t(struct optab_libcall_d): Rename from optab_d; remove code_,\n+\thandlers, widening members.\n+\t(struct convert_optab_libcall_d): Rename from convert_optab_d;\n+\tremove code_ and handlers members.\n+\t(enum optab_index, enum convert_optab_index): Remove.\n+\t(enum direct_optab_index): Remove.\n+\t(code_to_optab_): Fix array range.\n+\t(optab_to_code): Covert to inline function.\n+\t(optab_to_code_, convlib_def, normlib_def): Declare.\n+\t(raw_optab_handler, swap_optab_enable): Declare.\n+\t(unknown_optab): Remove; export to optabs.def\n+\t(ssadd_optab, usadd_optab, sssub_optab, ussub_optab, ssmul_optab,\n+\tusmul_optab, ssdiv_optab, usdiv_optab, ssneg_optab, usneg_optab,\n+\tssashl_optab, usashl_optab, add_optab, sub_optab, smul_optab,\n+\taddv_optab, subv_optab, smul_highpart_optab, umul_highpart_optab,\n+\tsmul_widen_optab, umul_widen_optab, usmul_widen_optab,\n+\tsmadd_widen_optab, umadd_widen_optab, ssmadd_widen_optab,\n+\tusmadd_widen_optab, smsub_widen_optab, umsub_widen_optab,\n+\tssmsub_widen_optab, usmsub_widen_optab, sdiv_optab, smulv_optab,\n+\tsdivv_optab, sdivmod_optab, udiv_optab, udivmod_optab, smod_optab,\n+\tumod_optab, fmod_optab, remainder_optab, ftrunc_optab, and_optab,\n+\tior_optab, xor_optab, ashl_optab, lshr_optab, ashr_optab, rotl_optab,\n+\trotr_optab, vashl_optab, vlshr_optab, vashr_optab, vrotl_optab,\n+\tvrotr_optab, smin_optab, smax_optab, umin_optab, umax_optab, pow_optab,\n+\tatan2_optab, fma_optab, fms_optab, fnma_optab, fnms_optab, mov_optab,\n+\tmovstrict_optab, movmisalign_optab, storent_optab, neg_optab,\n+\tnegv_optab, abs_optab, absv_optab, one_cmpl_optab, bswap_optab,\n+\tffs_optab, clz_optab, ctz_optab, clrsb_optab, popcount_optab,\n+\tparity_optab, sqrt_optab, sincos_optab, sin_optab, asin_optab,\n+\tcos_optab, acos_optab, exp_optab, exp10_optab, exp2_optab, expm1_optab,\n+\tldexp_optab, scalb_optab, significand_optab, logb_optab, ilogb_optab,\n+\tlog_optab, log10_optab, log2_optab, log1p_optab, floor_optab,\n+\tceil_optab, btrunc_optab, round_optab, nearbyint_optab, rint_optab,\n+\ttan_optab, atan_optab, copysign_optab, signbit_optab, isinf_optab,\n+\tcmp_optab, ucmp_optab, eq_optab, ne_optab, gt_optab, ge_optab,\n+\tlt_optab, le_optab, unord_optab, strlen_optab, cbranch_optab,\n+\tcmov_optab, cstore_optab, ctrap_optab, push_optab, addcc_optab,\n+\treduc_smax_optab, reduc_umax_optab, reduc_smin_optab, reduc_umin_optab,\n+\treduc_splus_optab, reduc_uplus_optab, ssum_widen_optab,\n+\tusum_widen_optab, sdot_prod_optab, udot_prod_optab, vec_set_optab,\n+\tvec_extract_optab, vec_init_optab, vec_shl_optab, vec_shr_optab,\n+\tvec_realign_load_optab, vec_widen_umult_hi_optab,\n+\tvec_widen_umult_lo_optab, vec_widen_smult_hi_optab,\n+\tvec_widen_smult_lo_optab, vec_widen_umult_even_optab,\n+\tvec_widen_umult_odd_optab, vec_widen_smult_even_optab,\n+\tvec_widen_smult_odd_optab, vec_widen_ushiftl_hi_optab,\n+\tvec_widen_ushiftl_lo_optab, vec_widen_sshiftl_hi_optab,\n+\tvec_widen_sshiftl_lo_optab, vec_unpacks_hi_optab, vec_unpacks_lo_optab,\n+\tvec_unpacku_hi_optab, vec_unpacku_lo_optab, vec_unpacks_float_hi_optab,\n+\tvec_unpacks_float_lo_optab, vec_unpacku_float_hi_optab,\n+\tvec_unpacku_float_lo_optab, vec_pack_trunc_optab, vec_pack_ssat_optab,\n+\tvec_pack_usat_optab, vec_pack_sfix_trunc_optab,\n+\tvec_pack_ufix_trunc_optab, powi_optab, sync_compare_and_swap_optab,\n+\tsync_lock_test_and_set_optab, sync_old_add_optab, sync_old_sub_optab,\n+\tsync_old_ior_optab, sync_old_and_optab, sync_old_xor_optab,\n+\tsync_old_nand_optab, sync_new_add_optab, sync_new_sub_optab,\n+\tsync_new_ior_optab, sync_new_and_optab, sync_new_xor_optab,\n+\tsync_new_nand_optab, sext_optab, zext_optab, trunc_optab, sfix_optab,\n+\tufix_optab, sfixtrunc_optab, ufixtrunc_optab, sfloat_optab,\n+\tufloat_optab, lrint_optab, lround_optab, lfloor_optab, lceil_optab,\n+\tfract_optab, fractuns_optab, satfract_optab, satfractuns_optab,\n+\tvec_load_lanes_optab, vec_store_lanes_optab, vcond_optab, vcondu_optab,\n+\tmovcc_optab, reload_in_optab, reload_out_optab, movmem_optab,\n+\tsetmem_optab, cmpstr_optab, cmpstrn_optab, cmpmem_optab,\n+\tsync_lock_release_optab, sync_add_optab, sync_sub_optab,\n+\tsync_ior_optab, sync_and_optab, sync_xor_optab, sync_nand_optab,\n+\tatomic_exchange_optab, atomic_compare_and_swap_optab,\n+\tatomic_load_optab, atomic_store_optab, atomic_add_fetch_optab,\n+\tatomic_sub_fetch_optab, atomic_and_fetch_optab,\n+\tatomic_nand_fetch_optab, atomic_xor_fetch_optab, atomic_or_fetch_optab,\n+\tatomic_fetch_add_optab, atomic_fetch_sub_optab, atomic_fetch_and_optab,\n+\tatomic_fetch_nand_optab, atomic_fetch_xor_optab, atomic_fetch_or_optab,\n+\tatomic_add_optab, atomic_sub_optab, atomic_and_optab,\n+\tatomic_nand_optab, atomic_xor_optab, atomic_or_optab,\n+\tatomic_always_lock_free_optab, atomic_is_lock_free_optab,\n+\tatomic_thread_fence_optab, atomic_signal_fence_optab,\n+\tvec_perm_optab, vec_perm_const_optab): Likewise.\n+\t(struct target_optabs): Remove x_optab_table, x_convert_optab_table,\n+\tand x_direct_optab_table members; add pat_enable.\n+\t(optab_table, convert_optab_table, direct_optab_table): Remove.\n+\t(optab_handler): Use raw_optab_handler.\n+\t(widening_optab_handler, convert_optab_handler): Likewise.\n+\t(set_optab_handler, set_widening_optab_handler): Remove.\n+\t(set_convert_optab_handler, set_direct_optab_handler): Remove.\n+\t(direct_optab_handler): Defer to optab_handler.\n+\t* rtl.h (NON_GENERATOR_NUM_RTX_CODE): New.\n+\n 2012-07-24  Jason Merrill  <jason@redhat.com>\n \n \t* bitmap.c (bitmap_descriptor): Adjust order of parameters to"}, {"sha": "40f7c4de561352a82fe7814bcbbe0ac603c8952a", "filename": "gcc/Makefile.in", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd1440b199ae8476f1b6df884e86fa07388e1f80/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd1440b199ae8476f1b6df884e86fa07388e1f80/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=cd1440b199ae8476f1b6df884e86fa07388e1f80", "patch": "@@ -889,7 +889,7 @@ OPTIONS_H = options.h flag-types.h $(OPTIONS_H_EXTRA)\n FUNCTION_H = function.h $(HASHTAB_H) vecprim.h $(TM_H) hard-reg-set.h \\\n \t$(VEC_H) vecir.h $(INPUT_H) $(MACHMODE_H)\n EXPR_H = expr.h insn-config.h $(FUNCTION_H) $(RTL_H) $(FLAGS_H) $(TREE_H) $(MACHMODE_H) $(EMIT_RTL_H)\n-OPTABS_H = optabs.h insn-codes.h\n+OPTABS_H = optabs.h insn-codes.h insn-opinit.h\n REGS_H = regs.h $(MACHMODE_H) hard-reg-set.h\n SCHED_INT_H = sched-int.h $(INSN_ATTR_H) $(BASIC_BLOCK_H) $(RTL_H) $(DF_H) \\\n \tvecprim.h $(REGSET_H)\n@@ -1484,7 +1484,7 @@ BACKEND = libbackend.a main.o @TREEBROWSER@ libcommon-target.a libcommon.a \\\n MOSTLYCLEANFILES = insn-flags.h insn-config.h insn-codes.h \\\n  insn-output.c insn-recog.c insn-emit.c insn-extract.c insn-peep.c \\\n  insn-attr.h insn-attr-common.h insn-attrtab.c insn-dfatab.c \\\n- insn-latencytab.c insn-opinit.c insn-preds.c insn-constants.h \\\n+ insn-latencytab.c insn-opinit.c insn-opinit.h insn-preds.c insn-constants.h \\\n  tm-preds.h tm-constrs.h checksum-options \\\n  tree-check.h min-insn-modes.c insn-modes.c insn-modes.h \\\n  genrtl.h gt-*.h gtype-*.h gtype-desc.c gtyp-input.list \\\n@@ -3430,7 +3430,7 @@ insn-modes.o : insn-modes.c $(CONFIG_H) $(SYSTEM_H) coretypes.h\t$(TM_H) \\\n   $(MACHMODE_H)\n insn-opinit.o : insn-opinit.c $(CONFIG_H) $(SYSTEM_H) coretypes.h\t\\\n   $(TM_H) $(RTL_H) $(TM_P_H) insn-config.h $(FLAGS_H) $(RECOG_H)\t\\\n-  $(EXPR_H) $(OPTABS_H) reload.h\n+  $(EXPR_H) $(OPTABS_H)\n insn-output.o : insn-output.c $(CONFIG_H) $(SYSTEM_H) coretypes.h\t\\\n   $(TM_H) $(RTL_H) $(GGC_H) $(REGS_H) conditions.h\t\t\t\\\n   hard-reg-set.h insn-config.h $(INSN_ATTR_H) $(EXPR_H) output.h\t\\\n@@ -3459,7 +3459,7 @@ simple_rtl_generated_h\t= insn-attr.h insn-attr-common.h insn-codes.h \\\n \t\t\t  insn-config.h insn-flags.h\n \n simple_rtl_generated_c\t= insn-automata.c insn-emit.c \\\n-\t\t\t  insn-extract.c insn-opinit.c insn-output.c \\\n+\t\t\t  insn-extract.c insn-output.c \\\n \t\t\t  insn-peep.c insn-recog.c\n \n simple_generated_h\t= $(simple_rtl_generated_h) insn-constants.h\n@@ -3506,6 +3506,15 @@ s-attrtab : $(MD_DEPS) build/genattrtab$(build_exeext) \\\n \t$(SHELL) $(srcdir)/../move-if-change tmp-latencytab.c insn-latencytab.c\n \t$(STAMP) s-attrtab\n \n+# genopinit produces two files.\n+insn-opinit.c insn-opinit.h: s-opinit ; @true\n+s-opinit: $(MD_DEPS) build/genopinit$(build_exeext) insn-conditions.md\n+\t$(RUN_GEN) build/genopinit$(build_exeext) $(md_file) \\\n+\t  insn-conditions.md -htmp-opinit.h -ctmp-opinit.c\n+\t$(SHELL) $(srcdir)/../move-if-change tmp-opinit.h insn-opinit.h\n+\t$(SHELL) $(srcdir)/../move-if-change tmp-opinit.c insn-opinit.c\n+\t$(STAMP) s-opinit\n+\n # gencondmd doesn't use the standard naming convention.\n build/gencondmd.c: s-conditions; @true\n s-conditions: $(MD_DEPS) build/genconditions$(build_exeext)\n@@ -3859,7 +3868,7 @@ build/genmddeps.o: genmddeps.c $(BCONFIG_H) $(SYSTEM_H) coretypes.h\t\\\n build/genmodes.o : genmodes.c $(BCONFIG_H) $(SYSTEM_H) errors.h\t\t\\\n   $(HASHTAB_H) machmode.def $(extra_modes_file)\n build/genopinit.o : genopinit.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H)\t\\\n-  coretypes.h $(GTM_H) errors.h gensupport.h\n+  coretypes.h $(GTM_H) errors.h gensupport.h optabs.def\n build/genoutput.o : genoutput.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H)\t\\\n   coretypes.h $(GTM_H) errors.h $(READ_MD_H) gensupport.h\n build/genpeep.o : genpeep.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H)\t\\"}, {"sha": "52612794802c53ca92dec3571435b4614bfd90e7", "filename": "gcc/genopinit.c", "status": "modified", "additions": 443, "deletions": 489, "changes": 932, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd1440b199ae8476f1b6df884e86fa07388e1f80/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd1440b199ae8476f1b6df884e86fa07388e1f80/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=cd1440b199ae8476f1b6df884e86fa07388e1f80", "patch": "@@ -1,7 +1,5 @@\n /* Generate code to initialize optabs from machine description.\n-   Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n-   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010, 2011\n-   Free Software Foundation, Inc.\n+   Copyright (C) 1993-2012 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -29,542 +27,498 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gensupport.h\"\n \n \n-/* Many parts of GCC use arrays that are indexed by machine mode and\n-   contain the insn codes for pattern in the MD file that perform a given\n-   operation on operands of that mode.\n+#define DEF_RTL_EXPR(V, N, X, C) #V,\n \n-   These patterns are present in the MD file with names that contain\n-   the mode(s) used and the name of the operation.  This program\n-   writes a function `init_all_optabs' that initializes the optabs with\n-   all the insn codes of the relevant patterns present in the MD file.\n+static const char * const rtx_upname[] = {\n+#include \"rtl.def\"\n+};\n+\n+#undef DEF_RTL_EXPR\n+\n+\n+/* The entries in optabs.def are categorized:\n+     C: A \"conversion\" optab, which uses two modes; has libcall data.\n+     N: A \"normal\" optab, which uses one mode; has libcall data.\n+     D: A \"direct\" optab, which uses one mode; does not have libcall data.\n+     V: An \"oVerflow\" optab.  Like N, but does not record its code in\n+        code_to_optab.\n \n-   This array contains a list of optabs that need to be initialized.  Within\n-   each string, the name of the pattern to be matched against is delimited\n-   with $( and $).  In the string, $a and $b are used to match a short mode\n-   name (the part of the mode name not including `mode' and converted to\n-   lower-case).  When writing out the initializer, the entire string is\n-   used.  $A and $B are replaced with the full name of the mode; $a and $b\n-   are replaced with the short form of the name, as above.\n+     CX, NX, VX: An extra pattern entry for a conversion or normal optab.\n \n-   If $N is present in the pattern, it means the two modes must be in\n-   the same mode class, and $b must be greater than $a (e.g, QImode\n-   and HImode).\n+   These patterns may be present in the MD file with names that contain\n+   the mode(s) used and the name of the operation.  This array contains\n+   a list of optabs that need to be initialized.  Within each name,\n+   $a and $b are used to match a short mode name (the part of the mode\n+   name not including `mode' and converted to lower-case).\n \n    $I means that only full integer modes should be considered for the\n    next mode, and $F means that only float modes should be considered.\n    $P means that both full and partial integer modes should be considered.\n    $Q means that only fixed-point modes should be considered.\n \n-   $V means to emit 'v' if the first mode is a MODE_FLOAT mode.\n-\n-   For some optabs, we store the operation by RTL codes.  These are only\n-   used for comparisons.  In that case, $c and $C are the lower-case and\n-   upper-case forms of the comparison, respectively.  */\n-\n-static const char * const optabs[] =\n-{ \"set_convert_optab_handler (sext_optab, $B, $A, CODE_FOR_$(extend$a$b2$))\",\n-  \"set_convert_optab_handler (zext_optab, $B, $A, CODE_FOR_$(zero_extend$a$b2$))\",\n-  \"set_convert_optab_handler (sfix_optab, $B, $A, CODE_FOR_$(fix$F$a$I$b2$))\",\n-  \"set_convert_optab_handler (ufix_optab, $B, $A, CODE_FOR_$(fixuns$F$a$b2$))\",\n-  \"set_convert_optab_handler (sfixtrunc_optab, $B, $A, CODE_FOR_$(fix_trunc$F$a$I$b2$))\",\n-  \"set_convert_optab_handler (ufixtrunc_optab, $B, $A, CODE_FOR_$(fixuns_trunc$F$a$I$b2$))\",\n-  \"set_convert_optab_handler (sfloat_optab, $B, $A, CODE_FOR_$(float$I$a$F$b2$))\",\n-  \"set_convert_optab_handler (ufloat_optab, $B, $A, CODE_FOR_$(floatuns$I$a$F$b2$))\",\n-  \"set_convert_optab_handler (trunc_optab, $B, $A, CODE_FOR_$(trunc$a$b2$))\",\n-  \"set_convert_optab_handler (fract_optab, $B, $A, CODE_FOR_$(fract$a$b2$))\",\n-  \"set_convert_optab_handler (fractuns_optab, $B, $A, CODE_FOR_$(fractuns$I$a$Q$b2$))\",\n-  \"set_convert_optab_handler (fractuns_optab, $B, $A, CODE_FOR_$(fractuns$Q$a$I$b2$))\",\n-  \"set_convert_optab_handler (satfract_optab, $B, $A, CODE_FOR_$(satfract$a$Q$b2$))\",\n-  \"set_convert_optab_handler (satfractuns_optab, $B, $A, CODE_FOR_$(satfractuns$I$a$Q$b2$))\",\n-  \"set_convert_optab_handler (vec_load_lanes_optab, $A, $B, CODE_FOR_$(vec_load_lanes$a$b$))\",\n-  \"set_convert_optab_handler (vec_store_lanes_optab, $A, $B, CODE_FOR_$(vec_store_lanes$a$b$))\",\n-  \"set_optab_handler (add_optab, $A, CODE_FOR_$(add$P$a3$))\",\n-  \"set_optab_handler (addv_optab, $A, CODE_FOR_$(add$F$a3$)),\\n\\\n-    set_optab_handler (add_optab, $A, CODE_FOR_$(add$F$a3$))\",\n-  \"set_optab_handler (addv_optab, $A, CODE_FOR_$(addv$I$a3$))\",\n-  \"set_optab_handler (add_optab, $A, CODE_FOR_$(add$Q$a3$))\",\n-  \"set_optab_handler (ssadd_optab, $A, CODE_FOR_$(ssadd$Q$a3$))\",\n-  \"set_optab_handler (usadd_optab, $A, CODE_FOR_$(usadd$Q$a3$))\",\n-  \"set_optab_handler (sub_optab, $A, CODE_FOR_$(sub$P$a3$))\",\n-  \"set_optab_handler (subv_optab, $A, CODE_FOR_$(sub$F$a3$)),\\n\\\n-    set_optab_handler (sub_optab, $A, CODE_FOR_$(sub$F$a3$))\",\n-  \"set_optab_handler (subv_optab, $A, CODE_FOR_$(subv$I$a3$))\",\n-  \"set_optab_handler (sub_optab, $A, CODE_FOR_$(sub$Q$a3$))\",\n-  \"set_optab_handler (sssub_optab, $A, CODE_FOR_$(sssub$Q$a3$))\",\n-  \"set_optab_handler (ussub_optab, $A, CODE_FOR_$(ussub$Q$a3$))\",\n-  \"set_optab_handler (smul_optab, $A, CODE_FOR_$(mul$Q$a3$))\",\n-  \"set_optab_handler (ssmul_optab, $A, CODE_FOR_$(ssmul$Q$a3$))\",\n-  \"set_optab_handler (usmul_optab, $A, CODE_FOR_$(usmul$Q$a3$))\",\n-  \"set_optab_handler (smul_optab, $A, CODE_FOR_$(mul$P$a3$))\",\n-  \"set_optab_handler (smulv_optab, $A, CODE_FOR_$(mul$F$a3$)),\\n\\\n-    set_optab_handler (smul_optab, $A, CODE_FOR_$(mul$F$a3$))\",\n-  \"set_optab_handler (smulv_optab, $A, CODE_FOR_$(mulv$I$a3$))\",\n-  \"set_optab_handler (umul_highpart_optab, $A, CODE_FOR_$(umul$a3_highpart$))\",\n-  \"set_optab_handler (smul_highpart_optab, $A, CODE_FOR_$(smul$a3_highpart$))\",\n-  \"set_widening_optab_handler (smul_widen_optab, $B, $A, CODE_FOR_$(mul$a$b3$)$N)\",\n-  \"set_widening_optab_handler (umul_widen_optab, $B, $A, CODE_FOR_$(umul$a$b3$)$N)\",\n-  \"set_widening_optab_handler (usmul_widen_optab, $B, $A, CODE_FOR_$(usmul$a$b3$)$N)\",\n-  \"set_widening_optab_handler (smadd_widen_optab, $B, $A, CODE_FOR_$(madd$a$b4$)$N)\",\n-  \"set_widening_optab_handler (umadd_widen_optab, $B, $A, CODE_FOR_$(umadd$a$b4$)$N)\",\n-  \"set_widening_optab_handler (ssmadd_widen_optab, $B, $A, CODE_FOR_$(ssmadd$a$b4$)$N)\",\n-  \"set_widening_optab_handler (usmadd_widen_optab, $B, $A, CODE_FOR_$(usmadd$a$b4$)$N)\",\n-  \"set_widening_optab_handler (smsub_widen_optab, $B, $A, CODE_FOR_$(msub$a$b4$)$N)\",\n-  \"set_widening_optab_handler (umsub_widen_optab, $B, $A, CODE_FOR_$(umsub$a$b4$)$N)\",\n-  \"set_widening_optab_handler (ssmsub_widen_optab, $B, $A, CODE_FOR_$(ssmsub$a$b4$)$N)\",\n-  \"set_widening_optab_handler (usmsub_widen_optab, $B, $A, CODE_FOR_$(usmsub$a$b4$)$N)\",\n-  \"set_optab_handler (sdiv_optab, $A, CODE_FOR_$(div$a3$))\",\n-  \"set_optab_handler (ssdiv_optab, $A, CODE_FOR_$(ssdiv$Q$a3$))\",\n-  \"set_optab_handler (sdivv_optab, $A, CODE_FOR_$(div$V$I$a3$))\",\n-  \"set_optab_handler (udiv_optab, $A, CODE_FOR_$(udiv$I$a3$))\",\n-  \"set_optab_handler (udiv_optab, $A, CODE_FOR_$(udiv$Q$a3$))\",\n-  \"set_optab_handler (usdiv_optab, $A, CODE_FOR_$(usdiv$Q$a3$))\",\n-  \"set_optab_handler (sdivmod_optab, $A, CODE_FOR_$(divmod$a4$))\",\n-  \"set_optab_handler (udivmod_optab, $A, CODE_FOR_$(udivmod$a4$))\",\n-  \"set_optab_handler (smod_optab, $A, CODE_FOR_$(mod$a3$))\",\n-  \"set_optab_handler (umod_optab, $A, CODE_FOR_$(umod$a3$))\",\n-  \"set_optab_handler (fmod_optab, $A, CODE_FOR_$(fmod$a3$))\",\n-  \"set_optab_handler (remainder_optab, $A, CODE_FOR_$(remainder$a3$))\",\n-  \"set_optab_handler (ftrunc_optab, $A, CODE_FOR_$(ftrunc$F$a2$))\",\n-  \"set_optab_handler (and_optab, $A, CODE_FOR_$(and$a3$))\",\n-  \"set_optab_handler (ior_optab, $A, CODE_FOR_$(ior$a3$))\",\n-  \"set_optab_handler (xor_optab, $A, CODE_FOR_$(xor$a3$))\",\n-  \"set_optab_handler (ashl_optab, $A, CODE_FOR_$(ashl$a3$))\",\n-  \"set_optab_handler (ssashl_optab, $A, CODE_FOR_$(ssashl$Q$a3$))\",\n-  \"set_optab_handler (usashl_optab, $A, CODE_FOR_$(usashl$Q$a3$))\",\n-  \"set_optab_handler (ashr_optab, $A, CODE_FOR_$(ashr$a3$))\",\n-  \"set_optab_handler (lshr_optab, $A, CODE_FOR_$(lshr$a3$))\",\n-  \"set_optab_handler (rotl_optab, $A, CODE_FOR_$(rotl$a3$))\",\n-  \"set_optab_handler (rotr_optab, $A, CODE_FOR_$(rotr$a3$))\",\n-  \"set_optab_handler (vashr_optab, $A, CODE_FOR_$(vashr$a3$))\",\n-  \"set_optab_handler (vlshr_optab, $A, CODE_FOR_$(vlshr$a3$))\",\n-  \"set_optab_handler (vashl_optab, $A, CODE_FOR_$(vashl$a3$))\",\n-  \"set_optab_handler (vrotl_optab, $A, CODE_FOR_$(vrotl$a3$))\",\n-  \"set_optab_handler (vrotr_optab, $A, CODE_FOR_$(vrotr$a3$))\",\n-  \"set_optab_handler (smin_optab, $A, CODE_FOR_$(smin$a3$))\",\n-  \"set_optab_handler (smax_optab, $A, CODE_FOR_$(smax$a3$))\",\n-  \"set_optab_handler (umin_optab, $A, CODE_FOR_$(umin$I$a3$))\",\n-  \"set_optab_handler (umax_optab, $A, CODE_FOR_$(umax$I$a3$))\",\n-  \"set_optab_handler (pow_optab, $A, CODE_FOR_$(pow$a3$))\",\n-  \"set_optab_handler (atan2_optab, $A, CODE_FOR_$(atan2$a3$))\",\n-  \"set_optab_handler (neg_optab, $A, CODE_FOR_$(neg$P$a2$))\",\n-  \"set_optab_handler (negv_optab, $A, CODE_FOR_$(neg$F$a2$)),\\n\\\n-    set_optab_handler (neg_optab, $A, CODE_FOR_$(neg$F$a2$))\",\n-  \"set_optab_handler (negv_optab, $A, CODE_FOR_$(negv$I$a2$))\",\n-  \"set_optab_handler (neg_optab, $A, CODE_FOR_$(neg$Q$a2$))\",\n-  \"set_optab_handler (ssneg_optab, $A, CODE_FOR_$(ssneg$Q$a2$))\",\n-  \"set_optab_handler (usneg_optab, $A, CODE_FOR_$(usneg$Q$a2$))\",\n-  \"set_optab_handler (abs_optab, $A, CODE_FOR_$(abs$P$a2$))\",\n-  \"set_optab_handler (absv_optab, $A, CODE_FOR_$(abs$F$a2$)),\\n\\\n-    set_optab_handler (abs_optab, $A, CODE_FOR_$(abs$F$a2$))\",\n-  \"set_optab_handler (absv_optab, $A, CODE_FOR_$(absv$I$a2$))\",\n-  \"set_optab_handler (copysign_optab, $A, CODE_FOR_$(copysign$F$a3$))\",\n-  \"set_optab_handler (signbit_optab, $A, CODE_FOR_$(signbit$F$a2$))\",\n-  \"set_optab_handler (isinf_optab, $A, CODE_FOR_$(isinf$a2$))\",\n-  \"set_optab_handler (sqrt_optab, $A, CODE_FOR_$(sqrt$a2$))\",\n-  \"set_optab_handler (floor_optab, $A, CODE_FOR_$(floor$a2$))\",\n-  \"set_convert_optab_handler (lfloor_optab, $B, $A, CODE_FOR_$(lfloor$F$a$I$b2$))\",\n-  \"set_optab_handler (fma_optab, $A, CODE_FOR_$(fma$a4$))\",\n-  \"set_optab_handler (fms_optab, $A, CODE_FOR_$(fms$a4$))\",\n-  \"set_optab_handler (fnma_optab, $A, CODE_FOR_$(fnma$a4$))\",\n-  \"set_optab_handler (fnms_optab, $A, CODE_FOR_$(fnms$a4$))\",\n-  \"set_optab_handler (ceil_optab, $A, CODE_FOR_$(ceil$a2$))\",\n-  \"set_convert_optab_handler (lceil_optab, $B, $A, CODE_FOR_$(lceil$F$a$I$b2$))\",\n-  \"set_optab_handler (round_optab, $A, CODE_FOR_$(round$a2$))\",\n-  \"set_optab_handler (btrunc_optab, $A, CODE_FOR_$(btrunc$a2$))\",\n-  \"set_optab_handler (nearbyint_optab, $A, CODE_FOR_$(nearbyint$a2$))\",\n-  \"set_optab_handler (rint_optab, $A, CODE_FOR_$(rint$a2$))\",\n-  \"set_convert_optab_handler (lrint_optab, $B, $A, CODE_FOR_$(lrint$F$a$I$b2$))\",\n-  \"set_convert_optab_handler (lround_optab, $B, $A, CODE_FOR_$(lround$F$a$I$b2$))\",\n-  \"set_optab_handler (sincos_optab, $A, CODE_FOR_$(sincos$a3$))\",\n-  \"set_optab_handler (sin_optab, $A, CODE_FOR_$(sin$a2$))\",\n-  \"set_optab_handler (asin_optab, $A, CODE_FOR_$(asin$a2$))\",\n-  \"set_optab_handler (cos_optab, $A, CODE_FOR_$(cos$a2$))\",\n-  \"set_optab_handler (acos_optab, $A, CODE_FOR_$(acos$a2$))\",\n-  \"set_optab_handler (exp_optab, $A, CODE_FOR_$(exp$a2$))\",\n-  \"set_optab_handler (exp10_optab, $A, CODE_FOR_$(exp10$a2$))\",\n-  \"set_optab_handler (exp2_optab, $A, CODE_FOR_$(exp2$a2$))\",\n-  \"set_optab_handler (expm1_optab, $A, CODE_FOR_$(expm1$a2$))\",\n-  \"set_optab_handler (ldexp_optab, $A, CODE_FOR_$(ldexp$a3$))\",\n-  \"set_optab_handler (scalb_optab, $A, CODE_FOR_$(scalb$a3$))\",\n-  \"set_optab_handler (significand_optab, $A, CODE_FOR_$(significand$a2$))\",\n-  \"set_optab_handler (logb_optab, $A, CODE_FOR_$(logb$a2$))\",\n-  \"set_optab_handler (ilogb_optab, $A, CODE_FOR_$(ilogb$a2$))\",\n-  \"set_optab_handler (log_optab, $A, CODE_FOR_$(log$a2$))\",\n-  \"set_optab_handler (log10_optab, $A, CODE_FOR_$(log10$a2$))\",\n-  \"set_optab_handler (log2_optab, $A, CODE_FOR_$(log2$a2$))\",\n-  \"set_optab_handler (log1p_optab, $A, CODE_FOR_$(log1p$a2$))\",\n-  \"set_optab_handler (tan_optab, $A, CODE_FOR_$(tan$a2$))\",\n-  \"set_optab_handler (atan_optab, $A, CODE_FOR_$(atan$a2$))\",\n-  \"set_optab_handler (strlen_optab, $A, CODE_FOR_$(strlen$a$))\",\n-  \"set_optab_handler (one_cmpl_optab, $A, CODE_FOR_$(one_cmpl$a2$))\",\n-  \"set_optab_handler (bswap_optab, $A, CODE_FOR_$(bswap$a2$))\",\n-  \"set_optab_handler (ffs_optab, $A, CODE_FOR_$(ffs$a2$))\",\n-  \"set_optab_handler (clz_optab, $A, CODE_FOR_$(clz$a2$))\",\n-  \"set_optab_handler (ctz_optab, $A, CODE_FOR_$(ctz$a2$))\",\n-  \"set_optab_handler (clrsb_optab, $A, CODE_FOR_$(clrsb$a2$))\",\n-  \"set_optab_handler (popcount_optab, $A, CODE_FOR_$(popcount$a2$))\",\n-  \"set_optab_handler (parity_optab, $A, CODE_FOR_$(parity$a2$))\",\n-  \"set_optab_handler (mov_optab, $A, CODE_FOR_$(mov$a$))\",\n-  \"set_optab_handler (movstrict_optab, $A, CODE_FOR_$(movstrict$a$))\",\n-  \"set_optab_handler (movmisalign_optab, $A, CODE_FOR_$(movmisalign$a$))\",\n-  \"set_optab_handler (storent_optab, $A, CODE_FOR_$(storent$a$))\",\n-  \"set_optab_handler (addcc_optab, $A, CODE_FOR_$(add$acc$))\",\n-  \"set_direct_optab_handler (movcc_optab, $A, CODE_FOR_$(mov$acc$))\",\n-  \"set_optab_handler (cbranch_optab, $A, CODE_FOR_$(cbranch$a4$))\",\n-  \"set_optab_handler (cmov_optab, $A, CODE_FOR_$(cmov$a6$))\",\n-  \"set_optab_handler (cstore_optab, $A, CODE_FOR_$(cstore$a4$))\",\n-  \"set_optab_handler (ctrap_optab, $A, CODE_FOR_$(ctrap$a4$))\",\n-  \"set_optab_handler (push_optab, $A, CODE_FOR_$(push$a1$))\",\n-  \"set_direct_optab_handler (reload_in_optab, $A, CODE_FOR_$(reload_in$a$))\",\n-  \"set_direct_optab_handler (reload_out_optab, $A, CODE_FOR_$(reload_out$a$))\",\n-  \"set_direct_optab_handler (movmem_optab, $A, CODE_FOR_$(movmem$a$))\",\n-  \"set_direct_optab_handler (cmpstr_optab, $A, CODE_FOR_$(cmpstr$a$))\",\n-  \"set_direct_optab_handler (cmpstrn_optab, $A, CODE_FOR_$(cmpstrn$a$))\",\n-  \"set_direct_optab_handler (cmpmem_optab, $A, CODE_FOR_$(cmpmem$a$))\",\n-  \"set_direct_optab_handler (setmem_optab, $A, CODE_FOR_$(setmem$a$))\",\n-  \"set_direct_optab_handler (sync_add_optab, $A, CODE_FOR_$(sync_add$I$a$))\",\n-  \"set_direct_optab_handler (sync_sub_optab, $A, CODE_FOR_$(sync_sub$I$a$))\",\n-  \"set_direct_optab_handler (sync_ior_optab, $A, CODE_FOR_$(sync_ior$I$a$))\",\n-  \"set_direct_optab_handler (sync_and_optab, $A, CODE_FOR_$(sync_and$I$a$))\",\n-  \"set_direct_optab_handler (sync_xor_optab, $A, CODE_FOR_$(sync_xor$I$a$))\",\n-  \"set_direct_optab_handler (sync_nand_optab, $A, CODE_FOR_$(sync_nand$I$a$))\",\n-  \"set_optab_handler (sync_old_add_optab, $A, CODE_FOR_$(sync_old_add$I$a$))\",\n-  \"set_optab_handler (sync_old_sub_optab, $A, CODE_FOR_$(sync_old_sub$I$a$))\",\n-  \"set_optab_handler (sync_old_ior_optab, $A, CODE_FOR_$(sync_old_ior$I$a$))\",\n-  \"set_optab_handler (sync_old_and_optab, $A, CODE_FOR_$(sync_old_and$I$a$))\",\n-  \"set_optab_handler (sync_old_xor_optab, $A, CODE_FOR_$(sync_old_xor$I$a$))\",\n-  \"set_optab_handler (sync_old_nand_optab, $A, CODE_FOR_$(sync_old_nand$I$a$))\",\n-  \"set_optab_handler (sync_new_add_optab, $A, CODE_FOR_$(sync_new_add$I$a$))\",\n-  \"set_optab_handler (sync_new_sub_optab, $A, CODE_FOR_$(sync_new_sub$I$a$))\",\n-  \"set_optab_handler (sync_new_ior_optab, $A, CODE_FOR_$(sync_new_ior$I$a$))\",\n-  \"set_optab_handler (sync_new_and_optab, $A, CODE_FOR_$(sync_new_and$I$a$))\",\n-  \"set_optab_handler (sync_new_xor_optab, $A, CODE_FOR_$(sync_new_xor$I$a$))\",\n-  \"set_optab_handler (sync_new_nand_optab, $A, CODE_FOR_$(sync_new_nand$I$a$))\",\n-  \"set_optab_handler (sync_compare_and_swap_optab, $A, CODE_FOR_$(sync_compare_and_swap$I$a$))\",\n-  \"set_optab_handler (sync_lock_test_and_set_optab, $A, CODE_FOR_$(sync_lock_test_and_set$I$a$))\",\n-  \"set_direct_optab_handler (sync_lock_release_optab, $A, CODE_FOR_$(sync_lock_release$I$a$))\",\n-  \"set_direct_optab_handler (atomic_exchange_optab, $A, CODE_FOR_$(atomic_exchange$I$a$))\",\n-  \"set_direct_optab_handler (atomic_compare_and_swap_optab, $A, CODE_FOR_$(atomic_compare_and_swap$I$a$))\",\n-  \"set_direct_optab_handler (atomic_load_optab, $A, CODE_FOR_$(atomic_load$I$a$))\",\n-  \"set_direct_optab_handler (atomic_store_optab, $A, CODE_FOR_$(atomic_store$I$a$))\",\n-  \"set_direct_optab_handler (atomic_add_fetch_optab, $A, CODE_FOR_$(atomic_add_fetch$I$a$))\",\n-  \"set_direct_optab_handler (atomic_sub_fetch_optab, $A, CODE_FOR_$(atomic_sub_fetch$I$a$))\",\n-  \"set_direct_optab_handler (atomic_and_fetch_optab, $A, CODE_FOR_$(atomic_and_fetch$I$a$))\",\n-  \"set_direct_optab_handler (atomic_nand_fetch_optab, $A, CODE_FOR_$(atomic_nand_fetch$I$a$))\",\n-  \"set_direct_optab_handler (atomic_xor_fetch_optab, $A, CODE_FOR_$(atomic_xor_fetch$I$a$))\",\n-  \"set_direct_optab_handler (atomic_or_fetch_optab, $A, CODE_FOR_$(atomic_or_fetch$I$a$))\",\n-  \"set_direct_optab_handler (atomic_fetch_add_optab, $A, CODE_FOR_$(atomic_fetch_add$I$a$))\",\n-  \"set_direct_optab_handler (atomic_fetch_sub_optab, $A, CODE_FOR_$(atomic_fetch_sub$I$a$))\",\n-  \"set_direct_optab_handler (atomic_fetch_and_optab, $A, CODE_FOR_$(atomic_fetch_and$I$a$))\",\n-  \"set_direct_optab_handler (atomic_fetch_nand_optab, $A, CODE_FOR_$(atomic_fetch_nand$I$a$))\",\n-  \"set_direct_optab_handler (atomic_fetch_xor_optab, $A, CODE_FOR_$(atomic_fetch_xor$I$a$))\",\n-  \"set_direct_optab_handler (atomic_fetch_or_optab, $A, CODE_FOR_$(atomic_fetch_or$I$a$))\",\n-  \"set_direct_optab_handler (atomic_add_optab, $A, CODE_FOR_$(atomic_add$I$a$))\",\n-  \"set_direct_optab_handler (atomic_sub_optab, $A, CODE_FOR_$(atomic_sub$I$a$))\",\n-  \"set_direct_optab_handler (atomic_and_optab, $A, CODE_FOR_$(atomic_and$I$a$))\",\n-  \"set_direct_optab_handler (atomic_nand_optab, $A, CODE_FOR_$(atomic_nand$I$a$))\",\n-  \"set_direct_optab_handler (atomic_xor_optab, $A, CODE_FOR_$(atomic_xor$I$a$))\",\n-  \"set_direct_optab_handler (atomic_or_optab, $A, CODE_FOR_$(atomic_or$I$a$))\",\n-  \"set_optab_handler (vec_set_optab, $A, CODE_FOR_$(vec_set$a$))\",\n-  \"set_optab_handler (vec_extract_optab, $A, CODE_FOR_$(vec_extract$a$))\",\n-  \"set_optab_handler (vec_init_optab, $A, CODE_FOR_$(vec_init$a$))\",\n-  \"set_optab_handler (vec_shl_optab, $A, CODE_FOR_$(vec_shl_$a$))\",\n-  \"set_optab_handler (vec_shr_optab, $A, CODE_FOR_$(vec_shr_$a$))\",\n-  \"set_optab_handler (vec_realign_load_optab, $A, CODE_FOR_$(vec_realign_load_$a$))\",\n-  \"set_direct_optab_handler (vec_perm_optab, $A, CODE_FOR_$(vec_perm$a$))\",\n-  \"set_direct_optab_handler (vec_perm_const_optab, $A, CODE_FOR_$(vec_perm_const$a$))\",\n-  \"set_convert_optab_handler (vcond_optab, $A, $B, CODE_FOR_$(vcond$a$b$))\",\n-  \"set_convert_optab_handler (vcondu_optab, $A, $B, CODE_FOR_$(vcondu$a$b$))\",\n-  \"set_optab_handler (ssum_widen_optab, $A, CODE_FOR_$(widen_ssum$I$a3$))\",\n-  \"set_optab_handler (usum_widen_optab, $A, CODE_FOR_$(widen_usum$I$a3$))\",\n-  \"set_optab_handler (udot_prod_optab, $A, CODE_FOR_$(udot_prod$I$a$))\",\n-  \"set_optab_handler (sdot_prod_optab, $A, CODE_FOR_$(sdot_prod$I$a$))\",\n-  \"set_optab_handler (reduc_smax_optab, $A, CODE_FOR_$(reduc_smax_$a$))\",\n-  \"set_optab_handler (reduc_umax_optab, $A, CODE_FOR_$(reduc_umax_$a$))\",\n-  \"set_optab_handler (reduc_smin_optab, $A, CODE_FOR_$(reduc_smin_$a$))\",\n-  \"set_optab_handler (reduc_umin_optab, $A, CODE_FOR_$(reduc_umin_$a$))\",\n-  \"set_optab_handler (reduc_splus_optab, $A, CODE_FOR_$(reduc_splus_$a$))\" ,\n-  \"set_optab_handler (reduc_uplus_optab, $A, CODE_FOR_$(reduc_uplus_$a$))\",\n-  \"set_optab_handler (vec_widen_umult_hi_optab, $A, CODE_FOR_$(vec_widen_umult_hi_$a$))\",\n-  \"set_optab_handler (vec_widen_umult_lo_optab, $A, CODE_FOR_$(vec_widen_umult_lo_$a$))\",\n-  \"set_optab_handler (vec_widen_smult_hi_optab, $A, CODE_FOR_$(vec_widen_smult_hi_$a$))\",\n-  \"set_optab_handler (vec_widen_smult_lo_optab, $A, CODE_FOR_$(vec_widen_smult_lo_$a$))\",\n-  \"set_optab_handler (vec_widen_umult_even_optab, $A, CODE_FOR_$(vec_widen_umult_even_$a$))\",\n-  \"set_optab_handler (vec_widen_umult_odd_optab, $A, CODE_FOR_$(vec_widen_umult_odd_$a$))\",\n-  \"set_optab_handler (vec_widen_smult_even_optab, $A, CODE_FOR_$(vec_widen_smult_even_$a$))\",\n-  \"set_optab_handler (vec_widen_smult_odd_optab, $A, CODE_FOR_$(vec_widen_smult_odd_$a$))\",\n-  \"set_optab_handler (vec_widen_ushiftl_hi_optab, $A, CODE_FOR_$(vec_widen_ushiftl_hi_$a$))\",\n-  \"set_optab_handler (vec_widen_ushiftl_lo_optab, $A, CODE_FOR_$(vec_widen_ushiftl_lo_$a$))\",\n-  \"set_optab_handler (vec_widen_sshiftl_hi_optab, $A, CODE_FOR_$(vec_widen_sshiftl_hi_$a$))\",\n-  \"set_optab_handler (vec_widen_sshiftl_lo_optab, $A, CODE_FOR_$(vec_widen_sshiftl_lo_$a$))\",\n-  \"set_optab_handler (vec_unpacks_hi_optab, $A, CODE_FOR_$(vec_unpacks_hi_$a$))\",\n-  \"set_optab_handler (vec_unpacks_lo_optab, $A, CODE_FOR_$(vec_unpacks_lo_$a$))\",\n-  \"set_optab_handler (vec_unpacku_hi_optab, $A, CODE_FOR_$(vec_unpacku_hi_$a$))\",\n-  \"set_optab_handler (vec_unpacku_lo_optab, $A, CODE_FOR_$(vec_unpacku_lo_$a$))\",\n-  \"set_optab_handler (vec_unpacks_float_hi_optab, $A, CODE_FOR_$(vec_unpacks_float_hi_$a$))\",\n-  \"set_optab_handler (vec_unpacks_float_lo_optab, $A, CODE_FOR_$(vec_unpacks_float_lo_$a$))\",\n-  \"set_optab_handler (vec_unpacku_float_hi_optab, $A, CODE_FOR_$(vec_unpacku_float_hi_$a$))\",\n-  \"set_optab_handler (vec_unpacku_float_lo_optab, $A, CODE_FOR_$(vec_unpacku_float_lo_$a$))\",\n-  \"set_optab_handler (vec_pack_trunc_optab, $A, CODE_FOR_$(vec_pack_trunc_$a$))\",\n-  \"set_optab_handler (vec_pack_ssat_optab, $A, CODE_FOR_$(vec_pack_ssat_$a$))\",\n-  \"set_optab_handler (vec_pack_usat_optab, $A, CODE_FOR_$(vec_pack_usat_$a$))\",\n-  \"set_optab_handler (vec_pack_sfix_trunc_optab, $A, CODE_FOR_$(vec_pack_sfix_trunc_$a$))\",\n-  \"set_optab_handler (vec_pack_ufix_trunc_optab, $A, CODE_FOR_$(vec_pack_ufix_trunc_$a$))\"\n+   The pattern may be NULL if the optab exists only for the libcalls\n+   that we plan to attach to it, and there are no named patterns in\n+   the md files.  */\n+\n+#define OPTAB_CL(name, pat, c, b, l)\t\tname,\n+#define OPTAB_CX(name, pat)\n+#define OPTAB_CD(name, pat)\t\t\tname,\n+#define OPTAB_NL(name, pat, c, b, s, l)\t\tname,\n+#define OPTAB_NC(name, pat, c)\t\t\tname,\n+#define OPTAB_NX(name, pat)\n+#define OPTAB_VL(name, pat, c, b, s, l)\t\tname,\n+#define OPTAB_VC(name, pat, c)\t\t\tname,\n+#define OPTAB_VX(name, pat)\n+#define OPTAB_DC(name, pat, c)\t\t\tname,\n+#define OPTAB_D(name, pat)\t\t\tname,\n+\n+typedef enum optab_tag {\n+  unknown_optab,\n+#include \"optabs.def\"\n+  NUM_OPTABS\n+} optab;\n+\n+#undef OPTAB_CL\n+#undef OPTAB_CX\n+#undef OPTAB_CD\n+#undef OPTAB_NL\n+#undef OPTAB_NC\n+#undef OPTAB_NX\n+#undef OPTAB_VL\n+#undef OPTAB_VC\n+#undef OPTAB_VX\n+#undef OPTAB_DC\n+#undef OPTAB_D\n+\n+#define NS \"NULL\"\n+#define ZS \"'\\\\0'\"\n+#define OPTAB_CL(o, p, c, b, l)    { #o, p, #b, ZS, #l, o, c, UNKNOWN, 1 },\n+#define OPTAB_CX(o, p) { #o, p, NULL, NULL, NULL, o, UNKNOWN, UNKNOWN, 1 },\n+#define OPTAB_CD(o, p) { #o, p, NS, ZS, NS, o, UNKNOWN, UNKNOWN, 2 },\n+#define OPTAB_NL(o, p, c, b, s, l) { #o, p, #b, #s, #l, o, c, c, 3 },\n+#define OPTAB_NC(o, p, c)          { #o, p, NS, ZS, NS, o, c, c, 3 },\n+#define OPTAB_NX(o, p) { #o, p, NULL, NULL, NULL, o, UNKNOWN, UNKNOWN, 3 },\n+#define OPTAB_VL(o, p, c, b, s, l) { #o, p, #b, #s, #l, o, c, UNKNOWN, 3 },\n+#define OPTAB_VC(o, p, c)          { #o, p, NS, ZS, NS, o, c, UNKNOWN, 3 },\n+#define OPTAB_VX(o, p) { #o, p, NULL, NULL, NULL, o, UNKNOWN, UNKNOWN, 3 },\n+#define OPTAB_DC(o, p, c)          { #o, p, NS, ZS, NS, o, c, c, 4 },\n+#define OPTAB_D(o, p)  { #o, p, NS, ZS, NS, o, UNKNOWN, UNKNOWN, 4 },\n+\n+typedef struct optab_def_d\n+{\n+  const char *name;\n+  const char *pattern;\n+  const char *base;\n+  const char *suffix;\n+  const char *libcall;\n+  unsigned int op;\n+  enum rtx_code fcode;\n+  enum rtx_code rcode;\n+  unsigned int kind;\n+} optab_def;\n+\n+static optab_def optabs[] = {\n+  { \"unknown_optab\", NULL, NS, ZS, NS, unknown_optab, UNKNOWN, UNKNOWN, 0 },\n+#include \"optabs.def\"\n };\n \n-static void gen_insn (rtx);\n+#undef OPTAB_CL\n+#undef OPTAB_CX\n+#undef OPTAB_CD\n+#undef OPTAB_NL\n+#undef OPTAB_NC\n+#undef OPTAB_NX\n+#undef OPTAB_VL\n+#undef OPTAB_VC\n+#undef OPTAB_VX\n+#undef OPTAB_DC\n+#undef OPTAB_D\n+\n+/* Vector in which to collect insns that match.  */\n+\n+typedef struct pattern_d\n+{\n+  const char *name;\n+  unsigned int op;\n+  unsigned int m1, m2;\n+  unsigned int sort_num;\n+} pattern;\n+\n+DEF_VEC_O(pattern);\n+DEF_VEC_ALLOC_O(pattern, heap);\n+\n+static VEC(pattern, heap) *patterns;\n+\n+static bool\n+match_pattern (pattern *p, const char *name, const char *pat)\n+{\n+  bool force_float = false;\n+  bool force_int = false;\n+  bool force_partial_int = false;\n+  bool force_fixed = false;\n+\n+  if (pat == NULL)\n+    return false;\n+  for (; ; ++pat)\n+    {\n+      if (*pat != '$')\n+\t{\n+\t  if (*pat != *name++)\n+\t    return false;\n+\t  if (*pat == '\\0')\n+\t    return true;\n+\t  continue;\n+\t}\n+      switch (*++pat)\n+\t{\n+\tcase 'I':\n+\t  force_int = 1;\n+\t  break;\n+\tcase 'P':\n+\t  force_partial_int = 1;\n+\t  break;\n+\tcase 'F':\n+\t  force_float = 1;\n+\t  break;\n+\tcase 'Q':\n+\t  force_fixed = 1;\n+\t  break;\n+\n+\tcase 'a':\n+\tcase 'b':\n+\t  {\n+\t    int i;\n+\n+\t    /* This loop will stop at the first prefix match, so\n+\t       look through the modes in reverse order, in case\n+\t       there are extra CC modes and CC is a prefix of the\n+\t       CC modes (as it should be).  */\n+\t    for (i = (MAX_MACHINE_MODE) - 1; i >= 0; i--)\n+\t      {\n+\t\tconst char *p, *q;\n+\t\tfor (p = GET_MODE_NAME(i), q = name; *p; p++, q++)\n+\t\t  if (TOLOWER (*p) != *q)\n+\t\t    break;\n+\t\tif (*p == 0\n+\t\t    && (! force_int || mode_class[i] == MODE_INT\n+\t\t\t|| mode_class[i] == MODE_VECTOR_INT)\n+\t\t    && (! force_partial_int\n+\t\t\t|| mode_class[i] == MODE_INT\n+\t\t\t|| mode_class[i] == MODE_PARTIAL_INT\n+\t\t\t|| mode_class[i] == MODE_VECTOR_INT)\n+\t\t    && (! force_float\n+\t\t\t|| mode_class[i] == MODE_FLOAT\n+\t\t\t|| mode_class[i] == MODE_DECIMAL_FLOAT\n+\t\t\t|| mode_class[i] == MODE_COMPLEX_FLOAT\n+\t\t\t|| mode_class[i] == MODE_VECTOR_FLOAT)\n+\t\t    && (! force_fixed\n+\t\t\t|| mode_class[i] == MODE_FRACT\n+\t\t\t|| mode_class[i] == MODE_UFRACT\n+\t\t\t|| mode_class[i] == MODE_ACCUM\n+\t\t\t|| mode_class[i] == MODE_UACCUM\n+\t\t\t|| mode_class[i] == MODE_VECTOR_FRACT\n+\t\t\t|| mode_class[i] == MODE_VECTOR_UFRACT\n+\t\t\t|| mode_class[i] == MODE_VECTOR_ACCUM\n+\t\t\t|| mode_class[i] == MODE_VECTOR_UACCUM))\n+\t\t  break;\n+\t      }\n+\n+\t    if (i < 0)\n+\t      return false;\n+\t    name += strlen (GET_MODE_NAME (i));\n+\t    if (*pat == 'a')\n+\t      p->m1 = i;\n+\t    else\n+\t      p->m2 = i;\n+\n+\t    force_int = false;\n+\t    force_partial_int = false;\n+\t    force_float = false;\n+\t    force_fixed = false;\n+\t  }\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+}\n \n static void\n gen_insn (rtx insn)\n {\n   const char *name = XSTR (insn, 0);\n-  int m1 = 0, m2 = 0, op = 0;\n-  size_t pindex;\n-  int i;\n-  const char *np, *pp, *p, *q;\n-\n-  /* Don't mention instructions whose names are the null string.\n-     They are in the machine description just to be recognized.  */\n-  if (*name == 0)\n-    return;\n+  pattern p;\n+  unsigned pindex;\n \n-  /* See if NAME matches one of the patterns we have for the optabs we know\n-     about.  */\n+  /* Don't mention \"unnamed\" instructions.  */\n+  if (*name == 0 || *name == '*')\n+    return;\n+  p.name = name;\n \n+  /* See if NAME matches one of the patterns we have for the optabs\n+     we know about.  */\n   for (pindex = 0; pindex < ARRAY_SIZE (optabs); pindex++)\n     {\n-      int force_float = 0, force_int = 0, force_partial_int = 0;\n-      int force_fixed = 0;\n-      int force_wider = 0;\n-      int matches = 1;\n-\n-      for (pp = optabs[pindex]; pp[0] != '$' || pp[1] != '('; pp++)\n-\t;\n-\n-      for (pp += 2, np = name; matches && ! (pp[0] == '$' && pp[1] == ')');\n-\t   pp++)\n+      p.m1 = p.m2 = 0;\n+      if (match_pattern (&p, name, optabs[pindex].pattern))\n \t{\n-\t  if (*pp != '$')\n-\t    {\n-\t      if (*pp != *np++)\n-\t\tbreak;\n-\t    }\n-\t  else\n-\t    switch (*++pp)\n-\t      {\n-\t      case 'N':\n-\t\tforce_wider = 1;\n-\t\tbreak;\n-\t      case 'I':\n-\t\tforce_int = 1;\n-\t\tbreak;\n-\t      case 'P':\n-                force_partial_int = 1;\n-                break;\n-\t      case 'F':\n-\t\tforce_float = 1;\n-\t\tbreak;\n-\t      case 'Q':\n-\t\tforce_fixed = 1;\n-\t\tbreak;\n-\t      case 'V':\n-                break;\n-\t      case 'c':\n-\t\tfor (op = 0; op < NUM_RTX_CODE; op++)\n-\t\t  {\n-\t\t    for (p = GET_RTX_NAME(op), q = np; *p; p++, q++)\n-\t\t      if (*p != *q)\n-\t\t\tbreak;\n-\n-\t\t    /* We have to be concerned about matching \"gt\" and\n-\t\t       missing \"gtu\", e.g., so verify we have reached the\n-\t\t       end of thing we are to match.  */\n-\t\t    if (*p == 0 && *q == 0\n-\t\t\t&& (GET_RTX_CLASS (op) == RTX_COMPARE\n-\t\t\t    || GET_RTX_CLASS (op) == RTX_COMM_COMPARE))\n-\t\t      break;\n-\t\t  }\n-\n-\t\tif (op == NUM_RTX_CODE)\n-\t\t  matches = 0;\n-\t\telse\n-\t\t  np += strlen (GET_RTX_NAME(op));\n-\t\tbreak;\n-\t      case 'a':\n-\t      case 'b':\n-\t\t/* This loop will stop at the first prefix match, so\n-                   look through the modes in reverse order, in case\n-                   there are extra CC modes and CC is a prefix of the\n-                   CC modes (as it should be).  */\n-\t\tfor (i = (MAX_MACHINE_MODE) - 1; i >= 0; i--)\n-\t\t  {\n-\t\t    for (p = GET_MODE_NAME(i), q = np; *p; p++, q++)\n-\t\t      if (TOLOWER (*p) != *q)\n-\t\t\tbreak;\n-\n-\t\t    if (*p == 0\n-\t\t\t&& (! force_int || mode_class[i] == MODE_INT\n-\t\t\t    || mode_class[i] == MODE_VECTOR_INT)\n-\t\t        && (! force_partial_int\n-                            || mode_class[i] == MODE_INT\n-                            || mode_class[i] == MODE_PARTIAL_INT\n-\t\t\t    || mode_class[i] == MODE_VECTOR_INT)\n-\t\t\t&& (! force_float\n-\t\t\t    || mode_class[i] == MODE_FLOAT\n-\t\t\t    || mode_class[i] == MODE_DECIMAL_FLOAT\n-\t\t\t    || mode_class[i] == MODE_COMPLEX_FLOAT\n-\t\t\t    || mode_class[i] == MODE_VECTOR_FLOAT)\n-\t\t\t&& (! force_fixed\n-\t\t\t    || mode_class[i] == MODE_FRACT\n-\t\t\t    || mode_class[i] == MODE_UFRACT\n-\t\t\t    || mode_class[i] == MODE_ACCUM\n-\t\t\t    || mode_class[i] == MODE_UACCUM\n-\t\t\t    || mode_class[i] == MODE_VECTOR_FRACT\n-\t\t\t    || mode_class[i] == MODE_VECTOR_UFRACT\n-\t\t\t    || mode_class[i] == MODE_VECTOR_ACCUM\n-\t\t\t    || mode_class[i] == MODE_VECTOR_UACCUM)\n-\t\t\t&& (! force_wider\n-\t\t\t    || *pp == 'a'\n-\t\t\t    || m1 < i))\n-\t\t      break;\n-\t\t  }\n-\n-\t\tif (i < 0)\n-\t\t  matches = 0;\n-\t\telse if (*pp == 'a')\n-\t\t  m1 = i, np += strlen (GET_MODE_NAME(i));\n-\t\telse\n-\t\t  m2 = i, np += strlen (GET_MODE_NAME(i));\n-\n-\t\tforce_int = force_partial_int = force_float = force_fixed = 0;\n-\t\tbreak;\n-\n-\t      default:\n-\t\tgcc_unreachable ();\n-\t      }\n+\t  p.op = optabs[pindex].op;\n+\t  p.sort_num = (p.op << 16) | (p.m2 << 8) | p.m1;\n+\t  VEC_safe_push (pattern, heap, patterns, &p);\n+\t  return;\n \t}\n-\n-      if (matches && pp[0] == '$' && pp[1] == ')'\n-\t  && *np == 0)\n-\tbreak;\n     }\n+}\n \n-  if (pindex == ARRAY_SIZE (optabs))\n-    return;\n+static int\n+pattern_cmp (const void *va, const void *vb)\n+{\n+  const pattern *a = (const pattern *)va;\n+  const pattern *b = (const pattern *)vb;\n+  return a->sort_num - b->sort_num;\n+}\n \n-  /* We found a match.  If this pattern is only conditionally present,\n-     write out the \"if\" and two extra blanks.  */\n+static int\n+optab_kind_cmp (const void *va, const void *vb)\n+{\n+  const optab_def *a = (const optab_def *)va;\n+  const optab_def *b = (const optab_def *)vb;\n+  int diff = a->kind - b->kind;\n+  if (diff == 0)\n+    diff = a->op - b->op;\n+  return diff;\n+}\n \n-  if (*XSTR (insn, 2) != 0)\n-    printf (\"  if (HAVE_%s)\\n  \", name);\n+static int\n+optab_rcode_cmp (const void *va, const void *vb)\n+{\n+  const optab_def *a = (const optab_def *)va;\n+  const optab_def *b = (const optab_def *)vb;\n+  return a->rcode - b->rcode;\n+}\n \n-  printf (\"  \");\n+static const char *header_file_name = \"init-opinit.h\";\n+static const char *source_file_name = \"init-opinit.c\";\n \n-  /* Now write out the initialization, making all required substitutions.  */\n-  for (pp = optabs[pindex]; *pp; pp++)\n+static bool\n+handle_arg (const char *arg)\n+{\n+  switch (arg[1])\n     {\n-      if (*pp != '$')\n-\tputchar (*pp);\n-      else\n-\tswitch (*++pp)\n-\t  {\n-\t  case '(':  case ')':\n-\t  case 'I':  case 'F':  case 'N':\n-\t    break;\n-\t  case 'V':\n-\t    if (SCALAR_FLOAT_MODE_P (m1))\n-              printf (\"v\");\n-            break;\n-\t  case 'a':\n-\t    for (np = GET_MODE_NAME(m1); *np; np++)\n-\t      putchar (TOLOWER (*np));\n-\t    break;\n-\t  case 'b':\n-\t    for (np = GET_MODE_NAME(m2); *np; np++)\n-\t      putchar (TOLOWER (*np));\n-\t    break;\n-\t  case 'A':\n-\t    printf (\"%smode\", GET_MODE_NAME(m1));\n-\t    break;\n-\t  case 'B':\n-\t    printf (\"%smode\", GET_MODE_NAME(m2));\n-\t    break;\n-\t  case 'c':\n-\t    printf (\"%s\", GET_RTX_NAME(op));\n-\t    break;\n-\t  case 'C':\n-\t    for (np = GET_RTX_NAME(op); *np; np++)\n-\t      putchar (TOUPPER (*np));\n-\t    break;\n-\t  }\n+    case 'h':\n+      header_file_name = &arg[2];\n+      return true;\n+    case 'c':\n+      source_file_name = &arg[2];\n+      return true;\n+    default:\n+      return false;\n     }\n-\n-  printf (\";\\n\");\n }\n \n-extern int main (int, char **);\n+static FILE *\n+open_outfile (const char *file_name)\n+{\n+  FILE *f = fopen (file_name, \"w\");\n+  if (!f)\n+    fatal (\"cannot open file %s: %s\", file_name, xstrerror (errno));\n+  fprintf (f,\n+\t   \"/* Generated automatically by the program `genopinit'\\n\"\n+\t   \"   from the machine description file `md'.  */\\n\\n\");\n+  return f;\n+}\n \n int\n main (int argc, char **argv)\n {\n-  rtx desc;\n+  FILE *h_file, *s_file;\n+  unsigned int i, j, n, last_kind[5];\n+  pattern *p;\n \n   progname = \"genopinit\";\n \n-  if (!init_rtx_reader_args (argc, argv))\n+  if (NUM_OPTABS > 0xffff || MAX_MACHINE_MODE >= 0xff)\n+    fatal (\"genopinit range assumptions invalid\");\n+\n+  if (!init_rtx_reader_args_cb (argc, argv, handle_arg))\n     return (FATAL_EXIT_CODE);\n \n-  printf (\"/* Generated automatically by the program `genopinit'\\n\\\n-from the machine description file `md'.  */\\n\\n\");\n-\n-  printf (\"#include \\\"config.h\\\"\\n\");\n-  printf (\"#include \\\"system.h\\\"\\n\");\n-  printf (\"#include \\\"coretypes.h\\\"\\n\");\n-  printf (\"#include \\\"tm.h\\\"\\n\");\n-  printf (\"#include \\\"rtl.h\\\"\\n\");\n-  printf (\"#include \\\"tm_p.h\\\"\\n\");\n-  printf (\"#include \\\"flags.h\\\"\\n\");\n-  printf (\"#include \\\"insn-config.h\\\"\\n\");\n-  printf (\"#include \\\"recog.h\\\"\\n\");\n-  printf (\"#include \\\"expr.h\\\"\\n\");\n-  printf (\"#include \\\"optabs.h\\\"\\n\");\n-  printf (\"#include \\\"reload.h\\\"\\n\\n\");\n-\n-  printf (\"void\\ninit_all_optabs (void)\\n{\\n\");\n-\n-  puts (\"\\\n-#ifdef FIXUNS_TRUNC_LIKE_FIX_TRUNC\\n\\\n-  int i, j;\\n\\\n-#endif\\n\");\n+  h_file = open_outfile (header_file_name);\n+  s_file = open_outfile (source_file_name);\n \n   /* Read the machine description.  */\n-\n   while (1)\n     {\n       int line_no, insn_code_number = 0;\n-\n-      desc = read_md_rtx (&line_no, &insn_code_number);\n+      rtx desc = read_md_rtx (&line_no, &insn_code_number);\n       if (desc == NULL)\n \tbreak;\n-\n       if (GET_CODE (desc) == DEFINE_INSN || GET_CODE (desc) == DEFINE_EXPAND)\n \tgen_insn (desc);\n     }\n \n-  puts (\"\\\n-\\n\\\n-#ifdef FIXUNS_TRUNC_LIKE_FIX_TRUNC\\n\\\n-  /* This flag says the same insns that convert to a signed fixnum\\n\\\n-     also convert validly to an unsigned one.  */\\n\\\n-  for (i = 0; i < NUM_MACHINE_MODES; i++)\\n\\\n-    for (j = 0; j < NUM_MACHINE_MODES; j++)\\n\\\n-      set_convert_optab_handler\\n\\\n- \t(ufixtrunc_optab, (enum machine_mode) i, (enum machine_mode) j,\\n\\\n-\t convert_optab_handler (sfixtrunc_optab, (enum machine_mode) i,\\n\\\n-\t\t\t\t\t\t (enum machine_mode) j));\\n\\\n-#endif\\n\\\n-}\");\n-\n-  fflush (stdout);\n-  return (ferror (stdout) != 0 ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE);\n+  /* Sort the collected patterns.  */\n+  qsort (VEC_address (pattern, patterns), VEC_length (pattern, patterns),\n+\t sizeof (pattern), pattern_cmp);\n+\n+  /* Now that we've handled the \"extra\" patterns, eliminate them from\n+     the optabs array.  That way they don't get in the way below.  */\n+  n = ARRAY_SIZE (optabs);\n+  for (i = 0; i < n; )\n+    if (optabs[i].base == NULL)\n+      optabs[i] = optabs[--n];\n+    else\n+      ++i;\n+\n+  /* Sort the (real) optabs.  Better than forcing the optabs.def file to\n+     remain sorted by kind.  We also scrogged any real ordering with the\n+     purging of the X patterns above.  */\n+  qsort (optabs, n, sizeof(optab_def), optab_kind_cmp);\n+\n+  /* Emit the optab enumeration for the header file.  */\n+  fprintf (h_file, \"enum optab_tag {\\n\");\n+  for (i = j = 0; i < n; ++i)\n+    {\n+      optabs[i].op = i;\n+      fprintf (h_file, \"  %s,\\n\", optabs[i].name);\n+      if (optabs[i].kind != j)\n+\tlast_kind[j++] = i - 1;\n+    }\n+  fprintf (h_file, \"  FIRST_CONV_OPTAB = %s,\\n\", optabs[last_kind[0]+1].name);\n+  fprintf (h_file, \"  LAST_CONVLIB_OPTAB = %s,\\n\", optabs[last_kind[1]].name);\n+  fprintf (h_file, \"  LAST_CONV_OPTAB = %s,\\n\", optabs[last_kind[2]].name);\n+  fprintf (h_file, \"  FIRST_NORM_OPTAB = %s,\\n\", optabs[last_kind[2]+1].name);\n+  fprintf (h_file, \"  LAST_NORMLIB_OPTAB = %s,\\n\", optabs[last_kind[3]].name);\n+  fprintf (h_file, \"  LAST_NORM_OPTAB = %s\\n\", optabs[i-1].name);\n+  fprintf (h_file, \"};\\n\\n\");\n+\n+  fprintf (h_file, \"#define NUM_OPTABS          %u\\n\", n);\n+  fprintf (h_file, \"#define NUM_CONVLIB_OPTABS  %u\\n\",\n+\t   last_kind[1] - last_kind[0]);\n+  fprintf (h_file, \"#define NUM_NORMLIB_OPTABS  %u\\n\",\n+\t   last_kind[3] - last_kind[2]);\n+  fprintf (h_file, \"#define NUM_OPTAB_PATTERNS  %u\\n\",\n+\t   (unsigned) VEC_length (pattern, patterns));\n+\n+  fprintf (s_file,\n+\t   \"#include \\\"config.h\\\"\\n\"\n+\t   \"#include \\\"system.h\\\"\\n\"\n+\t   \"#include \\\"coretypes.h\\\"\\n\"\n+\t   \"#include \\\"tm.h\\\"\\n\"\n+\t   \"#include \\\"rtl.h\\\"\\n\"\n+\t   \"#include \\\"tm_p.h\\\"\\n\"\n+\t   \"#include \\\"flags.h\\\"\\n\"\n+\t   \"#include \\\"insn-config.h\\\"\\n\"\n+\t   \"#include \\\"expr.h\\\"\\n\"\n+\t   \"#include \\\"optabs.h\\\"\\n\"\n+\t   \"\\n\"\n+\t   \"struct optab_pat {\\n\"\n+\t   \"  unsigned scode;\\n\"\n+\t   \"  enum insn_code icode;\\n\"\n+\t   \"};\\n\\n\");\n+\n+  fprintf (s_file,\n+\t   \"static const struct optab_pat pats[NUM_OPTAB_PATTERNS] = {\\n\");\n+  for (i = 0; VEC_iterate (pattern, patterns, i, p); ++i)\n+    fprintf (s_file, \"  { %#08x, CODE_FOR_%s },\\n\", p->sort_num, p->name);\n+  fprintf (s_file, \"};\\n\\n\");\n+\n+  fprintf (s_file, \"void\\ninit_all_optabs (void)\\n{\\n\");\n+  fprintf (s_file, \"  bool *ena = this_target_optabs->pat_enable;\\n\");\n+  for (i = 0; VEC_iterate (pattern, patterns, i, p); ++i)\n+    fprintf (s_file, \"  ena[%u] = HAVE_%s;\\n\", i, p->name);\n+  fprintf (s_file, \"}\\n\\n\");\n+\n+  /* Perform a binary search on a pre-encoded optab+mode*2.  */\n+  /* ??? Perhaps even better to generate a minimal perfect hash.\n+     Using gperf directly is awkward since it's so geared to working\n+     with strings.  Plus we have no visibility into the ordering of\n+     the hash entries, which complicates the pat_enable array.  */\n+  fprintf (s_file,\n+\t   \"static int\\n\"\n+\t   \"lookup_handler (unsigned scode)\\n\"\n+\t   \"{\\n\"\n+\t   \"  int l = 0, h = ARRAY_SIZE (pats), m;\\n\"\n+\t   \"  while (h > l)\\n\"\n+\t   \"    {\\n\"\n+\t   \"      m = (h + l) / 2;\\n\"\n+\t   \"      if (scode == pats[m].scode)\\n\"\n+\t   \"        return m;\\n\"\n+\t   \"      else if (scode < pats[m].scode)\\n\"\n+\t   \"        h = m;\\n\"\n+\t   \"      else\\n\"\n+\t   \"        l = m + 1;\\n\"\n+\t   \"    }\\n\"\n+\t   \"  return -1;\\n\"\n+\t   \"}\\n\\n\");\n+\n+  fprintf (s_file,\n+\t   \"enum insn_code\\n\"\n+\t   \"raw_optab_handler (unsigned scode)\\n\"\n+\t   \"{\\n\"\n+\t   \"  int i = lookup_handler (scode);\\n\"\n+\t   \"  return (i >= 0 && this_target_optabs->pat_enable[i]\\n\"\n+\t   \"          ? pats[i].icode : CODE_FOR_nothing);\\n\"\n+\t   \"}\\n\\n\");\n+\n+  fprintf (s_file,\n+\t   \"bool\\n\"\n+\t   \"swap_optab_enable (optab op, enum machine_mode m, bool set)\\n\"\n+\t   \"{\\n\"\n+\t   \"  unsigned scode = (op << 16) | m;\\n\"\n+\t   \"  int i = lookup_handler (scode);\\n\"\n+\t   \"  if (i >= 0)\\n\"\n+\t   \"    {\\n\"\n+\t   \"      bool ret = this_target_optabs->pat_enable[i];\\n\"\n+\t   \"      this_target_optabs->pat_enable[i] = set;\\n\"\n+\t   \"      return ret;\\n\"\n+\t   \"    }\\n\"\n+\t   \"  else\\n\"\n+\t   \"    {\\n\"\n+\t   \"      gcc_assert (!set);\\n\"\n+\t   \"      return false;\\n\"\n+\t   \"    }\\n\"\n+\t   \"}\\n\\n\");\n+\n+  /* C++ (even G++) does not support (non-trivial) designated initializers.\n+     To work around that, generate these arrays programatically rather than\n+     by our traditional multiple inclusion of def files.  */\n+\n+  fprintf (s_file,\n+\t   \"const struct convert_optab_libcall_d \"\n+\t   \"convlib_def[NUM_CONVLIB_OPTABS] = {\\n\");\n+  for (i = last_kind[0] + 1; i <= last_kind[1]; ++i)\n+    fprintf (s_file, \"  { %s, %s },\\n\", optabs[i].base, optabs[i].libcall);\n+  fprintf (s_file, \"};\\n\\n\");\n+\n+  fprintf (s_file,\n+\t   \"const struct optab_libcall_d \"\n+\t   \"normlib_def[NUM_NORMLIB_OPTABS] = {\\n\");\n+  for (i = last_kind[2] + 1; i <= last_kind[3]; ++i)\n+    fprintf (s_file, \"  { %s, %s, %s },\\n\",\n+\t     optabs[i].suffix, optabs[i].base, optabs[i].libcall);\n+  fprintf (s_file, \"};\\n\\n\");\n+\n+  fprintf (s_file, \"enum rtx_code const optab_to_code_[NUM_OPTABS] = {\\n\");\n+  for (i = 0; i < n; ++i)\n+    fprintf (s_file, \"  %s,\\n\", rtx_upname[optabs[i].fcode]);\n+  fprintf (s_file, \"};\\n\\n\");\n+\n+  qsort (optabs, n, sizeof (optab_def), optab_rcode_cmp);\n+\n+  fprintf (s_file, \"const optab code_to_optab_[NUM_RTX_CODE] = {\\n\");\n+  for (j = 0; optabs[j].rcode == UNKNOWN; ++j)\n+    continue;\n+  for (i = 0; i < NON_GENERATOR_NUM_RTX_CODE; ++i)\n+    {\n+      if (j < n && optabs[j].rcode == i)\n+\tfprintf (s_file, \"  %s,\\n\", optabs[j++].name);\n+      else\n+\tfprintf (s_file, \"  unknown_optab,\\n\");\n+    }\n+  fprintf (s_file, \"};\\n\\n\");\n+\n+  return (fclose (h_file) == 0 && fclose (s_file) == 0\n+\t  ? SUCCESS_EXIT_CODE : FATAL_EXIT_CODE);\n }"}, {"sha": "75f7a69f53253c6b9442ffc3490ce420fb590c9b", "filename": "gcc/libfuncs.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd1440b199ae8476f1b6df884e86fa07388e1f80/gcc%2Flibfuncs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd1440b199ae8476f1b6df884e86fa07388e1f80/gcc%2Flibfuncs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibfuncs.h?ref=cd1440b199ae8476f1b6df884e86fa07388e1f80", "patch": "@@ -52,7 +52,7 @@ enum libfunc_index\n    for normal optabs and conversion optabs.  In the first case mode2\n    is unused.  */\n struct GTY(()) libfunc_entry {\n-  size_t optab;\n+  optab op;\n   enum machine_mode mode1, mode2;\n   rtx libfunc;\n };"}, {"sha": "022adfa22f83dccd869144c63e5660cebe7cb40c", "filename": "gcc/optabs.c", "status": "modified", "additions": 106, "deletions": 547, "changes": 653, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd1440b199ae8476f1b6df884e86fa07388e1f80/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd1440b199ae8476f1b6df884e86fa07388e1f80/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=cd1440b199ae8476f1b6df884e86fa07388e1f80", "patch": "@@ -54,9 +54,6 @@ struct target_libfuncs *this_target_libfuncs = &default_target_libfuncs;\n #define libfunc_hash \\\n   (this_target_libfuncs->x_libfunc_hash)\n \n-/* Contains the optab used for each rtx code.  */\n-optab code_to_optab_[NUM_RTX_CODE + 1];\n-\n static void prepare_float_lib_cmp (rtx, rtx, enum rtx_code, rtx *,\n \t\t\t\t   enum machine_mode *);\n static rtx expand_unop_direct (enum machine_mode, optab, rtx, rtx, int);\n@@ -78,9 +75,7 @@ static hashval_t\n hash_libfunc (const void *p)\n {\n   const struct libfunc_entry *const e = (const struct libfunc_entry *) p;\n-\n-  return (((int) e->mode1 + (int) e->mode2 * NUM_MACHINE_MODES)\n-\t  ^ e->optab);\n+  return (((int) e->mode1 + (int) e->mode2 * NUM_MACHINE_MODES) ^ e->op);\n }\n \n /* Used for libfunc_hash.  */\n@@ -90,10 +85,7 @@ eq_libfunc (const void *p, const void *q)\n {\n   const struct libfunc_entry *const e1 = (const struct libfunc_entry *) p;\n   const struct libfunc_entry *const e2 = (const struct libfunc_entry *) q;\n-\n-  return (e1->optab == e2->optab\n-\t  && e1->mode1 == e2->mode1\n-\t  && e1->mode2 == e2->mode2);\n+  return e1->op == e2->op && e1->mode1 == e2->mode1 && e1->mode2 == e2->mode2;\n }\n \n /* Return libfunc corresponding operation defined by OPTAB converting\n@@ -106,22 +98,30 @@ convert_optab_libfunc (convert_optab optab, enum machine_mode mode1,\n   struct libfunc_entry e;\n   struct libfunc_entry **slot;\n \n-  e.optab = (size_t) (optab - &convert_optab_table[0]);\n+  /* ??? This ought to be an assert, but not all of the places\n+     that we expand optabs know about the optabs that got moved\n+     to being direct.  */\n+  if (!(optab >= FIRST_CONV_OPTAB && optab <= LAST_CONVLIB_OPTAB))\n+    return NULL_RTX;\n+\n+  e.op = optab;\n   e.mode1 = mode1;\n   e.mode2 = mode2;\n-  slot = (struct libfunc_entry **) htab_find_slot (libfunc_hash, &e, NO_INSERT);\n+  slot = (struct libfunc_entry **)\n+    htab_find_slot (libfunc_hash, &e, NO_INSERT);\n   if (!slot)\n     {\n-      if (optab->libcall_gen)\n-\t{\n-\t  optab->libcall_gen (optab, optab->libcall_basename, mode1, mode2);\n-          slot = (struct libfunc_entry **) htab_find_slot (libfunc_hash, &e, NO_INSERT);\n-\t  if (slot)\n-\t    return (*slot)->libfunc;\n-\t  else\n-\t    return NULL;\n-\t}\n-      return NULL;\n+      const struct convert_optab_libcall_d *d\n+\t= &convlib_def[optab - FIRST_CONV_OPTAB];\n+\n+      if (d->libcall_gen == NULL)\n+\treturn NULL;\n+\n+      d->libcall_gen (optab, d->libcall_basename, mode1, mode2);\n+      slot = (struct libfunc_entry **)\n+\thtab_find_slot (libfunc_hash, &e, NO_INSERT);\n+      if (!slot)\n+\treturn NULL;\n     }\n   return (*slot)->libfunc;\n }\n@@ -135,24 +135,30 @@ optab_libfunc (optab optab, enum machine_mode mode)\n   struct libfunc_entry e;\n   struct libfunc_entry **slot;\n \n-  e.optab = (size_t) (optab - &optab_table[0]);\n+  /* ??? This ought to be an assert, but not all of the places\n+     that we expand optabs know about the optabs that got moved\n+     to being direct.  */\n+  if (!(optab >= FIRST_NORM_OPTAB && optab <= LAST_NORMLIB_OPTAB))\n+    return NULL_RTX;\n+\n+  e.op = optab;\n   e.mode1 = mode;\n   e.mode2 = VOIDmode;\n-  slot = (struct libfunc_entry **) htab_find_slot (libfunc_hash, &e, NO_INSERT);\n+  slot = (struct libfunc_entry **)\n+    htab_find_slot (libfunc_hash, &e, NO_INSERT);\n   if (!slot)\n     {\n-      if (optab->libcall_gen)\n-\t{\n-\t  optab->libcall_gen (optab, optab->libcall_basename,\n-\t\t\t      optab->libcall_suffix, mode);\n-          slot = (struct libfunc_entry **) htab_find_slot (libfunc_hash,\n-\t\t\t\t\t\t\t   &e, NO_INSERT);\n-\t  if (slot)\n-\t    return (*slot)->libfunc;\n-\t  else\n-\t    return NULL;\n-\t}\n-      return NULL;\n+      const struct optab_libcall_d *d\n+\t= &normlib_def[optab - FIRST_NORM_OPTAB];\n+\n+      if (d->libcall_gen == NULL)\n+\treturn NULL;\n+\n+      d->libcall_gen (optab, d->libcall_basename, d->libcall_suffix, mode);\n+      slot = (struct libfunc_entry **)\n+\thtab_find_slot (libfunc_hash, &e, NO_INSERT);\n+      if (!slot)\n+\treturn NULL;\n     }\n   return (*slot)->libfunc;\n }\n@@ -2227,46 +2233,46 @@ sign_expand_binop (enum machine_mode mode, optab uoptab, optab soptab,\n {\n   rtx temp;\n   optab direct_optab = unsignedp ? uoptab : soptab;\n-  struct optab_d wide_soptab;\n+  bool save_enable;\n \n   /* Do it without widening, if possible.  */\n   temp = expand_binop (mode, direct_optab, op0, op1, target,\n \t\t       unsignedp, OPTAB_DIRECT);\n   if (temp || methods == OPTAB_DIRECT)\n     return temp;\n \n-  /* Try widening to a signed int.  Make a fake signed optab that\n-     hides any signed insn for direct use.  */\n-  wide_soptab = *soptab;\n-  set_optab_handler (&wide_soptab, mode, CODE_FOR_nothing);\n-  /* We don't want to generate new hash table entries from this fake\n-     optab.  */\n-  wide_soptab.libcall_gen = NULL;\n+  /* Try widening to a signed int.  Disable any direct use of any\n+     signed insn in the current mode.  */\n+  save_enable = swap_optab_enable (soptab, mode, false);\n \n-  temp = expand_binop (mode, &wide_soptab, op0, op1, target,\n+  temp = expand_binop (mode, soptab, op0, op1, target,\n \t\t       unsignedp, OPTAB_WIDEN);\n \n   /* For unsigned operands, try widening to an unsigned int.  */\n-  if (temp == 0 && unsignedp)\n+  if (!temp && unsignedp)\n     temp = expand_binop (mode, uoptab, op0, op1, target,\n \t\t\t unsignedp, OPTAB_WIDEN);\n   if (temp || methods == OPTAB_WIDEN)\n-    return temp;\n+    goto egress;\n \n   /* Use the right width libcall if that exists.  */\n-  temp = expand_binop (mode, direct_optab, op0, op1, target, unsignedp, OPTAB_LIB);\n+  temp = expand_binop (mode, direct_optab, op0, op1, target,\n+\t\t       unsignedp, OPTAB_LIB);\n   if (temp || methods == OPTAB_LIB)\n-    return temp;\n+    goto egress;\n \n   /* Must widen and use a libcall, use either signed or unsigned.  */\n-  temp = expand_binop (mode, &wide_soptab, op0, op1, target,\n+  temp = expand_binop (mode, soptab, op0, op1, target,\n \t\t       unsignedp, methods);\n-  if (temp != 0)\n-    return temp;\n-  if (unsignedp)\n-    return expand_binop (mode, uoptab, op0, op1, target,\n+  if (!temp && unsignedp)\n+    temp = expand_binop (mode, uoptab, op0, op1, target,\n \t\t\t unsignedp, methods);\n-  return 0;\n+\n+ egress:\n+  /* Undo the fiddling above.  */\n+  if (save_enable)\n+    swap_optab_enable (soptab, mode, true);\n+  return temp;\n }\n \f\n /* Generate code to perform an operation specified by UNOPPTAB\n@@ -5415,39 +5421,6 @@ have_insn_for (enum rtx_code code, enum machine_mode mode)\n \t      != CODE_FOR_nothing));\n }\n \n-/* Set all insn_code fields to CODE_FOR_nothing.  */\n-\n-static void\n-init_insn_codes (void)\n-{\n-  memset (optab_table, 0, sizeof (optab_table));\n-  memset (convert_optab_table, 0, sizeof (convert_optab_table));\n-  memset (direct_optab_table, 0, sizeof (direct_optab_table));\n-}\n-\n-/* Initialize OP's code to CODE, and write it into the code_to_optab table.  */\n-static inline void\n-init_optab (optab op, enum rtx_code code)\n-{\n-  op->code_ = code;\n-  code_to_optab_[(int) code] = op;\n-}\n-\n-/* Same, but fill in its code as CODE, and do _not_ write it into\n-   the code_to_optab table.  */\n-static inline void\n-init_optabv (optab op, enum rtx_code code)\n-{\n-  op->code_ = code;\n-}\n-\n-/* Conversion optabs never go in the code_to_optab table.  */\n-static void\n-init_convert_optab (convert_optab op, enum rtx_code code)\n-{\n-  op->code_ = code;\n-}\n-\n /* Initialize the libfunc fields of an entire group of entries in some\n    optab.  Each entry is set equal to a string consisting of a leading\n    pair of underscores followed by a generic operation name followed by\n@@ -5463,7 +5436,8 @@ init_convert_optab (convert_optab op, enum rtx_code code)\n */\n \n static void\n-gen_libfunc (optab optable, const char *opname, int suffix, enum machine_mode mode)\n+gen_libfunc (optab optable, const char *opname, int suffix,\n+\t     enum machine_mode mode)\n {\n   unsigned opname_len = strlen (opname);\n   const char *mname = GET_MODE_NAME (mode);\n@@ -5497,7 +5471,7 @@ gen_libfunc (optab optable, const char *opname, int suffix, enum machine_mode mo\n \n /* Like gen_libfunc, but verify that integer operation is involved.  */\n \n-static void\n+void\n gen_int_libfunc (optab optable, const char *opname, char suffix,\n \t\t enum machine_mode mode)\n {\n@@ -5515,7 +5489,7 @@ gen_int_libfunc (optab optable, const char *opname, char suffix,\n \n /* Like gen_libfunc, but verify that FP and set decimal prefix if needed.  */\n \n-static void\n+void\n gen_fp_libfunc (optab optable, const char *opname, char suffix,\n \t\tenum machine_mode mode)\n {\n@@ -5536,7 +5510,7 @@ gen_fp_libfunc (optab optable, const char *opname, char suffix,\n \n /* Like gen_libfunc, but verify that fixed-point operation is involved.  */\n \n-static void\n+void\n gen_fixed_libfunc (optab optable, const char *opname, char suffix,\n \t\t   enum machine_mode mode)\n {\n@@ -5548,7 +5522,7 @@ gen_fixed_libfunc (optab optable, const char *opname, char suffix,\n /* Like gen_libfunc, but verify that signed fixed-point operation is\n    involved.  */\n \n-static void\n+void\n gen_signed_fixed_libfunc (optab optable, const char *opname, char suffix,\n \t\t\t  enum machine_mode mode)\n {\n@@ -5560,7 +5534,7 @@ gen_signed_fixed_libfunc (optab optable, const char *opname, char suffix,\n /* Like gen_libfunc, but verify that unsigned fixed-point operation is\n    involved.  */\n \n-static void\n+void\n gen_unsigned_fixed_libfunc (optab optable, const char *opname, char suffix,\n \t\t\t    enum machine_mode mode)\n {\n@@ -5571,7 +5545,7 @@ gen_unsigned_fixed_libfunc (optab optable, const char *opname, char suffix,\n \n /* Like gen_libfunc, but verify that FP or INT operation is involved.  */\n \n-static void\n+void\n gen_int_fp_libfunc (optab optable, const char *name, char suffix,\n \t\t    enum machine_mode mode)\n {\n@@ -5584,7 +5558,7 @@ gen_int_fp_libfunc (optab optable, const char *name, char suffix,\n /* Like gen_libfunc, but verify that FP or INT operation is involved\n    and add 'v' suffix for integer operation.  */\n \n-static void\n+void\n gen_intv_fp_libfunc (optab optable, const char *name, char suffix,\n \t\t     enum machine_mode mode)\n {\n@@ -5604,7 +5578,7 @@ gen_intv_fp_libfunc (optab optable, const char *name, char suffix,\n /* Like gen_libfunc, but verify that FP or INT or FIXED operation is\n    involved.  */\n \n-static void\n+void\n gen_int_fp_fixed_libfunc (optab optable, const char *name, char suffix,\n \t\t\t  enum machine_mode mode)\n {\n@@ -5619,7 +5593,7 @@ gen_int_fp_fixed_libfunc (optab optable, const char *name, char suffix,\n /* Like gen_libfunc, but verify that FP or INT or signed FIXED operation is\n    involved.  */\n \n-static void\n+void\n gen_int_fp_signed_fixed_libfunc (optab optable, const char *name, char suffix,\n \t\t\t\t enum machine_mode mode)\n {\n@@ -5634,7 +5608,7 @@ gen_int_fp_signed_fixed_libfunc (optab optable, const char *name, char suffix,\n /* Like gen_libfunc, but verify that INT or FIXED operation is\n    involved.  */\n \n-static void\n+void\n gen_int_fixed_libfunc (optab optable, const char *name, char suffix,\n \t\t       enum machine_mode mode)\n {\n@@ -5647,7 +5621,7 @@ gen_int_fixed_libfunc (optab optable, const char *name, char suffix,\n /* Like gen_libfunc, but verify that INT or signed FIXED operation is\n    involved.  */\n \n-static void\n+void\n gen_int_signed_fixed_libfunc (optab optable, const char *name, char suffix,\n \t\t\t      enum machine_mode mode)\n {\n@@ -5660,7 +5634,7 @@ gen_int_signed_fixed_libfunc (optab optable, const char *name, char suffix,\n /* Like gen_libfunc, but verify that INT or unsigned FIXED operation is\n    involved.  */\n \n-static void\n+void\n gen_int_unsigned_fixed_libfunc (optab optable, const char *name, char suffix,\n \t\t\t\tenum machine_mode mode)\n {\n@@ -5676,7 +5650,7 @@ gen_int_unsigned_fixed_libfunc (optab optable, const char *name, char suffix,\n    a mode name and an operand count these functions have two mode names\n    and no operand count.  */\n \n-static void\n+void\n gen_interclass_conv_libfunc (convert_optab tab,\n \t\t\t     const char *opname,\n \t\t\t     enum machine_mode tmode,\n@@ -5748,7 +5722,7 @@ gen_interclass_conv_libfunc (convert_optab tab,\n /* Same as gen_interclass_conv_libfunc but verify that we are producing\n    int->fp conversion.  */\n \n-static void\n+void\n gen_int_to_fp_conv_libfunc (convert_optab tab,\n \t\t\t    const char *opname,\n \t\t\t    enum machine_mode tmode,\n@@ -5764,7 +5738,7 @@ gen_int_to_fp_conv_libfunc (convert_optab tab,\n /* ufloat_optab is special by using floatun for FP and floatuns decimal fp\n    naming scheme.  */\n \n-static void\n+void\n gen_ufloat_conv_libfunc (convert_optab tab,\n \t\t\t const char *opname ATTRIBUTE_UNUSED,\n \t\t\t enum machine_mode tmode,\n@@ -5779,7 +5753,7 @@ gen_ufloat_conv_libfunc (convert_optab tab,\n /* Same as gen_interclass_conv_libfunc but verify that we are producing\n    fp->int conversion.  */\n \n-static void\n+void\n gen_int_to_fp_nondecimal_conv_libfunc (convert_optab tab,\n \t\t\t               const char *opname,\n \t\t\t               enum machine_mode tmode,\n@@ -5795,7 +5769,7 @@ gen_int_to_fp_nondecimal_conv_libfunc (convert_optab tab,\n /* Same as gen_interclass_conv_libfunc but verify that we are producing\n    fp->int conversion with no decimal floating point involved.  */\n \n-static void\n+void\n gen_fp_to_int_conv_libfunc (convert_optab tab,\n \t\t\t    const char *opname,\n \t\t\t    enum machine_mode tmode,\n@@ -5812,7 +5786,7 @@ gen_fp_to_int_conv_libfunc (convert_optab tab,\n    The string formation rules are\n    similar to the ones for init_libfunc, above.  */\n \n-static void\n+void\n gen_intraclass_conv_libfunc (convert_optab tab, const char *opname,\n \t\t\t     enum machine_mode tmode, enum machine_mode fmode)\n {\n@@ -5882,7 +5856,7 @@ gen_intraclass_conv_libfunc (convert_optab tab, const char *opname,\n /* Pick proper libcall for trunc_optab.  We need to chose if we do\n    truncation or extension and interclass or intraclass.  */\n \n-static void\n+void\n gen_trunc_conv_libfunc (convert_optab tab,\n \t\t\t const char *opname,\n \t\t\t enum machine_mode tmode,\n@@ -5911,7 +5885,7 @@ gen_trunc_conv_libfunc (convert_optab tab,\n /* Pick proper libcall for extend_optab.  We need to chose if we do\n    truncation or extension and interclass or intraclass.  */\n \n-static void\n+void\n gen_extend_conv_libfunc (convert_optab tab,\n \t\t\t const char *opname ATTRIBUTE_UNUSED,\n \t\t\t enum machine_mode tmode,\n@@ -5940,7 +5914,7 @@ gen_extend_conv_libfunc (convert_optab tab,\n /* Pick proper libcall for fract_optab.  We need to chose if we do\n    interclass or intraclass.  */\n \n-static void\n+void\n gen_fract_conv_libfunc (convert_optab tab,\n \t\t\tconst char *opname,\n \t\t\tenum machine_mode tmode,\n@@ -5959,7 +5933,7 @@ gen_fract_conv_libfunc (convert_optab tab,\n \n /* Pick proper libcall for fractuns_optab.  */\n \n-static void\n+void\n gen_fractuns_conv_libfunc (convert_optab tab,\n \t\t\t   const char *opname,\n \t\t\t   enum machine_mode tmode,\n@@ -5980,7 +5954,7 @@ gen_fractuns_conv_libfunc (convert_optab tab,\n /* Pick proper libcall for satfract_optab.  We need to chose if we do\n    interclass or intraclass.  */\n \n-static void\n+void\n gen_satfract_conv_libfunc (convert_optab tab,\n \t\t\t   const char *opname,\n \t\t\t   enum machine_mode tmode,\n@@ -6000,7 +5974,7 @@ gen_satfract_conv_libfunc (convert_optab tab,\n \n /* Pick proper libcall for satfractuns_optab.  */\n \n-static void\n+void\n gen_satfractuns_conv_libfunc (convert_optab tab,\n \t\t\t      const char *opname,\n \t\t\t      enum machine_mode tmode,\n@@ -6101,12 +6075,13 @@ set_user_assembler_libfunc (const char *name, const char *asmspec)\n /* Call this to reset the function entry for one optab (OPTABLE) in mode\n    MODE to NAME, which should be either 0 or a string constant.  */\n void\n-set_optab_libfunc (optab optable, enum machine_mode mode, const char *name)\n+set_optab_libfunc (optab op, enum machine_mode mode, const char *name)\n {\n   rtx val;\n   struct libfunc_entry e;\n   struct libfunc_entry **slot;\n-  e.optab = (size_t) (optable - &optab_table[0]);\n+\n+  e.op = op;\n   e.mode1 = mode;\n   e.mode2 = VOIDmode;\n \n@@ -6117,7 +6092,7 @@ set_optab_libfunc (optab optable, enum machine_mode mode, const char *name)\n   slot = (struct libfunc_entry **) htab_find_slot (libfunc_hash, &e, INSERT);\n   if (*slot == NULL)\n     *slot = ggc_alloc_libfunc_entry ();\n-  (*slot)->optab = (size_t) (optable - &optab_table[0]);\n+  (*slot)->op = op;\n   (*slot)->mode1 = mode;\n   (*slot)->mode2 = VOIDmode;\n   (*slot)->libfunc = val;\n@@ -6127,13 +6102,14 @@ set_optab_libfunc (optab optable, enum machine_mode mode, const char *name)\n    (OPTABLE) from mode FMODE to mode TMODE to NAME, which should be\n    either 0 or a string constant.  */\n void\n-set_conv_libfunc (convert_optab optable, enum machine_mode tmode,\n+set_conv_libfunc (convert_optab optab, enum machine_mode tmode,\n \t\t  enum machine_mode fmode, const char *name)\n {\n   rtx val;\n   struct libfunc_entry e;\n   struct libfunc_entry **slot;\n-  e.optab = (size_t) (optable - &convert_optab_table[0]);\n+\n+  e.op = optab;\n   e.mode1 = tmode;\n   e.mode2 = fmode;\n \n@@ -6144,7 +6120,7 @@ set_conv_libfunc (convert_optab optable, enum machine_mode tmode,\n   slot = (struct libfunc_entry **) htab_find_slot (libfunc_hash, &e, INSERT);\n   if (*slot == NULL)\n     *slot = ggc_alloc_libfunc_entry ();\n-  (*slot)->optab = (size_t) (optable - &convert_optab_table[0]);\n+  (*slot)->op = optab;\n   (*slot)->mode1 = tmode;\n   (*slot)->mode2 = fmode;\n   (*slot)->libfunc = val;\n@@ -6157,421 +6133,13 @@ void\n init_optabs (void)\n {\n   if (libfunc_hash)\n-    {\n-      htab_empty (libfunc_hash);\n-      /* We statically initialize the insn_codes with the equivalent of\n-\t CODE_FOR_nothing.  Repeat the process if reinitialising.  */\n-      init_insn_codes ();\n-    }\n+    htab_empty (libfunc_hash);\n   else\n     libfunc_hash = htab_create_ggc (10, hash_libfunc, eq_libfunc, NULL);\n \n-  init_optab (add_optab, PLUS);\n-  init_optabv (addv_optab, PLUS);\n-  init_optab (sub_optab, MINUS);\n-  init_optabv (subv_optab, MINUS);\n-  init_optab (ssadd_optab, SS_PLUS);\n-  init_optab (usadd_optab, US_PLUS);\n-  init_optab (sssub_optab, SS_MINUS);\n-  init_optab (ussub_optab, US_MINUS);\n-  init_optab (smul_optab, MULT);\n-  init_optab (ssmul_optab, SS_MULT);\n-  init_optab (usmul_optab, US_MULT);\n-  init_optabv (smulv_optab, MULT);\n-  init_optab (smul_highpart_optab, UNKNOWN);\n-  init_optab (umul_highpart_optab, UNKNOWN);\n-  init_optab (smul_widen_optab, UNKNOWN);\n-  init_optab (umul_widen_optab, UNKNOWN);\n-  init_optab (usmul_widen_optab, UNKNOWN);\n-  init_optab (smadd_widen_optab, UNKNOWN);\n-  init_optab (umadd_widen_optab, UNKNOWN);\n-  init_optab (ssmadd_widen_optab, UNKNOWN);\n-  init_optab (usmadd_widen_optab, UNKNOWN);\n-  init_optab (smsub_widen_optab, UNKNOWN);\n-  init_optab (umsub_widen_optab, UNKNOWN);\n-  init_optab (ssmsub_widen_optab, UNKNOWN);\n-  init_optab (usmsub_widen_optab, UNKNOWN);\n-  init_optab (sdiv_optab, DIV);\n-  init_optab (ssdiv_optab, SS_DIV);\n-  init_optab (usdiv_optab, US_DIV);\n-  init_optabv (sdivv_optab, DIV);\n-  init_optab (sdivmod_optab, UNKNOWN);\n-  init_optab (udiv_optab, UDIV);\n-  init_optab (udivmod_optab, UNKNOWN);\n-  init_optab (smod_optab, MOD);\n-  init_optab (umod_optab, UMOD);\n-  init_optab (fmod_optab, UNKNOWN);\n-  init_optab (remainder_optab, UNKNOWN);\n-  init_optab (ftrunc_optab, UNKNOWN);\n-  init_optab (and_optab, AND);\n-  init_optab (ior_optab, IOR);\n-  init_optab (xor_optab, XOR);\n-  init_optab (ashl_optab, ASHIFT);\n-  init_optab (ssashl_optab, SS_ASHIFT);\n-  init_optab (usashl_optab, US_ASHIFT);\n-  init_optab (ashr_optab, ASHIFTRT);\n-  init_optab (lshr_optab, LSHIFTRT);\n-  init_optabv (vashl_optab, ASHIFT);\n-  init_optabv (vashr_optab, ASHIFTRT);\n-  init_optabv (vlshr_optab, LSHIFTRT);\n-  init_optab (rotl_optab, ROTATE);\n-  init_optab (rotr_optab, ROTATERT);\n-  init_optab (smin_optab, SMIN);\n-  init_optab (smax_optab, SMAX);\n-  init_optab (umin_optab, UMIN);\n-  init_optab (umax_optab, UMAX);\n-  init_optab (pow_optab, UNKNOWN);\n-  init_optab (atan2_optab, UNKNOWN);\n-  init_optab (fma_optab, FMA);\n-  init_optab (fms_optab, UNKNOWN);\n-  init_optab (fnma_optab, UNKNOWN);\n-  init_optab (fnms_optab, UNKNOWN);\n-\n-  /* These three have codes assigned exclusively for the sake of\n-     have_insn_for.  */\n-  init_optab (mov_optab, SET);\n-  init_optab (movstrict_optab, STRICT_LOW_PART);\n-  init_optab (cbranch_optab, COMPARE);\n-\n-  init_optab (cmov_optab, UNKNOWN);\n-  init_optab (cstore_optab, UNKNOWN);\n-  init_optab (ctrap_optab, UNKNOWN);\n-\n-  init_optab (storent_optab, UNKNOWN);\n-\n-  init_optab (cmp_optab, UNKNOWN);\n-  init_optab (ucmp_optab, UNKNOWN);\n-\n-  init_optab (eq_optab, EQ);\n-  init_optab (ne_optab, NE);\n-  init_optab (gt_optab, GT);\n-  init_optab (ge_optab, GE);\n-  init_optab (lt_optab, LT);\n-  init_optab (le_optab, LE);\n-  init_optab (unord_optab, UNORDERED);\n-\n-  init_optab (neg_optab, NEG);\n-  init_optab (ssneg_optab, SS_NEG);\n-  init_optab (usneg_optab, US_NEG);\n-  init_optabv (negv_optab, NEG);\n-  init_optab (abs_optab, ABS);\n-  init_optabv (absv_optab, ABS);\n-  init_optab (addcc_optab, UNKNOWN);\n-  init_optab (one_cmpl_optab, NOT);\n-  init_optab (bswap_optab, BSWAP);\n-  init_optab (ffs_optab, FFS);\n-  init_optab (clz_optab, CLZ);\n-  init_optab (ctz_optab, CTZ);\n-  init_optab (clrsb_optab, CLRSB);\n-  init_optab (popcount_optab, POPCOUNT);\n-  init_optab (parity_optab, PARITY);\n-  init_optab (sqrt_optab, SQRT);\n-  init_optab (floor_optab, UNKNOWN);\n-  init_optab (ceil_optab, UNKNOWN);\n-  init_optab (round_optab, UNKNOWN);\n-  init_optab (btrunc_optab, UNKNOWN);\n-  init_optab (nearbyint_optab, UNKNOWN);\n-  init_optab (rint_optab, UNKNOWN);\n-  init_optab (sincos_optab, UNKNOWN);\n-  init_optab (sin_optab, UNKNOWN);\n-  init_optab (asin_optab, UNKNOWN);\n-  init_optab (cos_optab, UNKNOWN);\n-  init_optab (acos_optab, UNKNOWN);\n-  init_optab (exp_optab, UNKNOWN);\n-  init_optab (exp10_optab, UNKNOWN);\n-  init_optab (exp2_optab, UNKNOWN);\n-  init_optab (expm1_optab, UNKNOWN);\n-  init_optab (ldexp_optab, UNKNOWN);\n-  init_optab (scalb_optab, UNKNOWN);\n-  init_optab (significand_optab, UNKNOWN);\n-  init_optab (logb_optab, UNKNOWN);\n-  init_optab (ilogb_optab, UNKNOWN);\n-  init_optab (log_optab, UNKNOWN);\n-  init_optab (log10_optab, UNKNOWN);\n-  init_optab (log2_optab, UNKNOWN);\n-  init_optab (log1p_optab, UNKNOWN);\n-  init_optab (tan_optab, UNKNOWN);\n-  init_optab (atan_optab, UNKNOWN);\n-  init_optab (copysign_optab, UNKNOWN);\n-  init_optab (signbit_optab, UNKNOWN);\n-\n-  init_optab (isinf_optab, UNKNOWN);\n-\n-  init_optab (strlen_optab, UNKNOWN);\n-  init_optab (push_optab, UNKNOWN);\n-\n-  init_optab (reduc_smax_optab, UNKNOWN);\n-  init_optab (reduc_umax_optab, UNKNOWN);\n-  init_optab (reduc_smin_optab, UNKNOWN);\n-  init_optab (reduc_umin_optab, UNKNOWN);\n-  init_optab (reduc_splus_optab, UNKNOWN);\n-  init_optab (reduc_uplus_optab, UNKNOWN);\n-\n-  init_optab (ssum_widen_optab, UNKNOWN);\n-  init_optab (usum_widen_optab, UNKNOWN);\n-  init_optab (sdot_prod_optab, UNKNOWN);\n-  init_optab (udot_prod_optab, UNKNOWN);\n-\n-  init_optab (vec_extract_optab, UNKNOWN);\n-  init_optab (vec_set_optab, UNKNOWN);\n-  init_optab (vec_init_optab, UNKNOWN);\n-  init_optab (vec_shl_optab, UNKNOWN);\n-  init_optab (vec_shr_optab, UNKNOWN);\n-  init_optab (vec_realign_load_optab, UNKNOWN);\n-  init_optab (movmisalign_optab, UNKNOWN);\n-  init_optab (vec_widen_umult_hi_optab, UNKNOWN);\n-  init_optab (vec_widen_umult_lo_optab, UNKNOWN);\n-  init_optab (vec_widen_smult_hi_optab, UNKNOWN);\n-  init_optab (vec_widen_smult_lo_optab, UNKNOWN);\n-  init_optab (vec_widen_ushiftl_hi_optab, UNKNOWN);\n-  init_optab (vec_widen_ushiftl_lo_optab, UNKNOWN);\n-  init_optab (vec_widen_sshiftl_hi_optab, UNKNOWN);\n-  init_optab (vec_widen_sshiftl_lo_optab, UNKNOWN);\n-  init_optab (vec_unpacks_hi_optab, UNKNOWN);\n-  init_optab (vec_unpacks_lo_optab, UNKNOWN);\n-  init_optab (vec_unpacku_hi_optab, UNKNOWN);\n-  init_optab (vec_unpacku_lo_optab, UNKNOWN);\n-  init_optab (vec_unpacks_float_hi_optab, UNKNOWN);\n-  init_optab (vec_unpacks_float_lo_optab, UNKNOWN);\n-  init_optab (vec_unpacku_float_hi_optab, UNKNOWN);\n-  init_optab (vec_unpacku_float_lo_optab, UNKNOWN);\n-  init_optab (vec_pack_trunc_optab, UNKNOWN);\n-  init_optab (vec_pack_usat_optab, UNKNOWN);\n-  init_optab (vec_pack_ssat_optab, UNKNOWN);\n-  init_optab (vec_pack_ufix_trunc_optab, UNKNOWN);\n-  init_optab (vec_pack_sfix_trunc_optab, UNKNOWN);\n-\n-  init_optab (powi_optab, UNKNOWN);\n-\n-  /* Conversions.  */\n-  init_convert_optab (sext_optab, SIGN_EXTEND);\n-  init_convert_optab (zext_optab, ZERO_EXTEND);\n-  init_convert_optab (trunc_optab, TRUNCATE);\n-  init_convert_optab (sfix_optab, FIX);\n-  init_convert_optab (ufix_optab, UNSIGNED_FIX);\n-  init_convert_optab (sfixtrunc_optab, UNKNOWN);\n-  init_convert_optab (ufixtrunc_optab, UNKNOWN);\n-  init_convert_optab (sfloat_optab, FLOAT);\n-  init_convert_optab (ufloat_optab, UNSIGNED_FLOAT);\n-  init_convert_optab (lrint_optab, UNKNOWN);\n-  init_convert_optab (lround_optab, UNKNOWN);\n-  init_convert_optab (lfloor_optab, UNKNOWN);\n-  init_convert_optab (lceil_optab, UNKNOWN);\n-\n-  init_convert_optab (fract_optab, FRACT_CONVERT);\n-  init_convert_optab (fractuns_optab, UNSIGNED_FRACT_CONVERT);\n-  init_convert_optab (satfract_optab, SAT_FRACT);\n-  init_convert_optab (satfractuns_optab, UNSIGNED_SAT_FRACT);\n-\n   /* Fill in the optabs with the insns we support.  */\n   init_all_optabs ();\n \n-  /* Initialize the optabs with the names of the library functions.  */\n-  add_optab->libcall_basename = \"add\";\n-  add_optab->libcall_suffix = '3';\n-  add_optab->libcall_gen = gen_int_fp_fixed_libfunc;\n-  addv_optab->libcall_basename = \"add\";\n-  addv_optab->libcall_suffix = '3';\n-  addv_optab->libcall_gen = gen_intv_fp_libfunc;\n-  ssadd_optab->libcall_basename = \"ssadd\";\n-  ssadd_optab->libcall_suffix = '3';\n-  ssadd_optab->libcall_gen = gen_signed_fixed_libfunc;\n-  usadd_optab->libcall_basename = \"usadd\";\n-  usadd_optab->libcall_suffix = '3';\n-  usadd_optab->libcall_gen = gen_unsigned_fixed_libfunc;\n-  sub_optab->libcall_basename = \"sub\";\n-  sub_optab->libcall_suffix = '3';\n-  sub_optab->libcall_gen = gen_int_fp_fixed_libfunc;\n-  subv_optab->libcall_basename = \"sub\";\n-  subv_optab->libcall_suffix = '3';\n-  subv_optab->libcall_gen = gen_intv_fp_libfunc;\n-  sssub_optab->libcall_basename = \"sssub\";\n-  sssub_optab->libcall_suffix = '3';\n-  sssub_optab->libcall_gen = gen_signed_fixed_libfunc;\n-  ussub_optab->libcall_basename = \"ussub\";\n-  ussub_optab->libcall_suffix = '3';\n-  ussub_optab->libcall_gen = gen_unsigned_fixed_libfunc;\n-  smul_optab->libcall_basename = \"mul\";\n-  smul_optab->libcall_suffix = '3';\n-  smul_optab->libcall_gen = gen_int_fp_fixed_libfunc;\n-  smulv_optab->libcall_basename = \"mul\";\n-  smulv_optab->libcall_suffix = '3';\n-  smulv_optab->libcall_gen = gen_intv_fp_libfunc;\n-  ssmul_optab->libcall_basename = \"ssmul\";\n-  ssmul_optab->libcall_suffix = '3';\n-  ssmul_optab->libcall_gen = gen_signed_fixed_libfunc;\n-  usmul_optab->libcall_basename = \"usmul\";\n-  usmul_optab->libcall_suffix = '3';\n-  usmul_optab->libcall_gen = gen_unsigned_fixed_libfunc;\n-  sdiv_optab->libcall_basename = \"div\";\n-  sdiv_optab->libcall_suffix = '3';\n-  sdiv_optab->libcall_gen = gen_int_fp_signed_fixed_libfunc;\n-  sdivv_optab->libcall_basename = \"divv\";\n-  sdivv_optab->libcall_suffix = '3';\n-  sdivv_optab->libcall_gen = gen_int_libfunc;\n-  ssdiv_optab->libcall_basename = \"ssdiv\";\n-  ssdiv_optab->libcall_suffix = '3';\n-  ssdiv_optab->libcall_gen = gen_signed_fixed_libfunc;\n-  udiv_optab->libcall_basename = \"udiv\";\n-  udiv_optab->libcall_suffix = '3';\n-  udiv_optab->libcall_gen = gen_int_unsigned_fixed_libfunc;\n-  usdiv_optab->libcall_basename = \"usdiv\";\n-  usdiv_optab->libcall_suffix = '3';\n-  usdiv_optab->libcall_gen = gen_unsigned_fixed_libfunc;\n-  sdivmod_optab->libcall_basename = \"divmod\";\n-  sdivmod_optab->libcall_suffix = '4';\n-  sdivmod_optab->libcall_gen = gen_int_libfunc;\n-  udivmod_optab->libcall_basename = \"udivmod\";\n-  udivmod_optab->libcall_suffix = '4';\n-  udivmod_optab->libcall_gen = gen_int_libfunc;\n-  smod_optab->libcall_basename = \"mod\";\n-  smod_optab->libcall_suffix = '3';\n-  smod_optab->libcall_gen = gen_int_libfunc;\n-  umod_optab->libcall_basename = \"umod\";\n-  umod_optab->libcall_suffix = '3';\n-  umod_optab->libcall_gen = gen_int_libfunc;\n-  ftrunc_optab->libcall_basename = \"ftrunc\";\n-  ftrunc_optab->libcall_suffix = '2';\n-  ftrunc_optab->libcall_gen = gen_fp_libfunc;\n-  and_optab->libcall_basename = \"and\";\n-  and_optab->libcall_suffix = '3';\n-  and_optab->libcall_gen = gen_int_libfunc;\n-  ior_optab->libcall_basename = \"ior\";\n-  ior_optab->libcall_suffix = '3';\n-  ior_optab->libcall_gen = gen_int_libfunc;\n-  xor_optab->libcall_basename = \"xor\";\n-  xor_optab->libcall_suffix = '3';\n-  xor_optab->libcall_gen = gen_int_libfunc;\n-  ashl_optab->libcall_basename = \"ashl\";\n-  ashl_optab->libcall_suffix = '3';\n-  ashl_optab->libcall_gen = gen_int_fixed_libfunc;\n-  ssashl_optab->libcall_basename = \"ssashl\";\n-  ssashl_optab->libcall_suffix = '3';\n-  ssashl_optab->libcall_gen = gen_signed_fixed_libfunc;\n-  usashl_optab->libcall_basename = \"usashl\";\n-  usashl_optab->libcall_suffix = '3';\n-  usashl_optab->libcall_gen = gen_unsigned_fixed_libfunc;\n-  ashr_optab->libcall_basename = \"ashr\";\n-  ashr_optab->libcall_suffix = '3';\n-  ashr_optab->libcall_gen = gen_int_signed_fixed_libfunc;\n-  lshr_optab->libcall_basename = \"lshr\";\n-  lshr_optab->libcall_suffix = '3';\n-  lshr_optab->libcall_gen = gen_int_unsigned_fixed_libfunc;\n-  smin_optab->libcall_basename = \"min\";\n-  smin_optab->libcall_suffix = '3';\n-  smin_optab->libcall_gen = gen_int_fp_libfunc;\n-  smax_optab->libcall_basename = \"max\";\n-  smax_optab->libcall_suffix = '3';\n-  smax_optab->libcall_gen = gen_int_fp_libfunc;\n-  umin_optab->libcall_basename = \"umin\";\n-  umin_optab->libcall_suffix = '3';\n-  umin_optab->libcall_gen = gen_int_libfunc;\n-  umax_optab->libcall_basename = \"umax\";\n-  umax_optab->libcall_suffix = '3';\n-  umax_optab->libcall_gen = gen_int_libfunc;\n-  neg_optab->libcall_basename = \"neg\";\n-  neg_optab->libcall_suffix = '2';\n-  neg_optab->libcall_gen = gen_int_fp_fixed_libfunc;\n-  ssneg_optab->libcall_basename = \"ssneg\";\n-  ssneg_optab->libcall_suffix = '2';\n-  ssneg_optab->libcall_gen = gen_signed_fixed_libfunc;\n-  usneg_optab->libcall_basename = \"usneg\";\n-  usneg_optab->libcall_suffix = '2';\n-  usneg_optab->libcall_gen = gen_unsigned_fixed_libfunc;\n-  negv_optab->libcall_basename = \"neg\";\n-  negv_optab->libcall_suffix = '2';\n-  negv_optab->libcall_gen = gen_intv_fp_libfunc;\n-  one_cmpl_optab->libcall_basename = \"one_cmpl\";\n-  one_cmpl_optab->libcall_suffix = '2';\n-  one_cmpl_optab->libcall_gen = gen_int_libfunc;\n-  ffs_optab->libcall_basename = \"ffs\";\n-  ffs_optab->libcall_suffix = '2';\n-  ffs_optab->libcall_gen = gen_int_libfunc;\n-  clz_optab->libcall_basename = \"clz\";\n-  clz_optab->libcall_suffix = '2';\n-  clz_optab->libcall_gen = gen_int_libfunc;\n-  ctz_optab->libcall_basename = \"ctz\";\n-  ctz_optab->libcall_suffix = '2';\n-  ctz_optab->libcall_gen = gen_int_libfunc;\n-  clrsb_optab->libcall_basename = \"clrsb\";\n-  clrsb_optab->libcall_suffix = '2';\n-  clrsb_optab->libcall_gen = gen_int_libfunc;\n-  popcount_optab->libcall_basename = \"popcount\";\n-  popcount_optab->libcall_suffix = '2';\n-  popcount_optab->libcall_gen = gen_int_libfunc;\n-  parity_optab->libcall_basename = \"parity\";\n-  parity_optab->libcall_suffix = '2';\n-  parity_optab->libcall_gen = gen_int_libfunc;\n-\n-  /* Comparison libcalls for integers MUST come in pairs,\n-     signed/unsigned.  */\n-  cmp_optab->libcall_basename = \"cmp\";\n-  cmp_optab->libcall_suffix = '2';\n-  cmp_optab->libcall_gen = gen_int_fp_fixed_libfunc;\n-  ucmp_optab->libcall_basename = \"ucmp\";\n-  ucmp_optab->libcall_suffix = '2';\n-  ucmp_optab->libcall_gen = gen_int_libfunc;\n-\n-  /* EQ etc are floating point only.  */\n-  eq_optab->libcall_basename = \"eq\";\n-  eq_optab->libcall_suffix = '2';\n-  eq_optab->libcall_gen = gen_fp_libfunc;\n-  ne_optab->libcall_basename = \"ne\";\n-  ne_optab->libcall_suffix = '2';\n-  ne_optab->libcall_gen = gen_fp_libfunc;\n-  gt_optab->libcall_basename = \"gt\";\n-  gt_optab->libcall_suffix = '2';\n-  gt_optab->libcall_gen = gen_fp_libfunc;\n-  ge_optab->libcall_basename = \"ge\";\n-  ge_optab->libcall_suffix = '2';\n-  ge_optab->libcall_gen = gen_fp_libfunc;\n-  lt_optab->libcall_basename = \"lt\";\n-  lt_optab->libcall_suffix = '2';\n-  lt_optab->libcall_gen = gen_fp_libfunc;\n-  le_optab->libcall_basename = \"le\";\n-  le_optab->libcall_suffix = '2';\n-  le_optab->libcall_gen = gen_fp_libfunc;\n-  unord_optab->libcall_basename = \"unord\";\n-  unord_optab->libcall_suffix = '2';\n-  unord_optab->libcall_gen = gen_fp_libfunc;\n-\n-  powi_optab->libcall_basename = \"powi\";\n-  powi_optab->libcall_suffix = '2';\n-  powi_optab->libcall_gen = gen_fp_libfunc;\n-\n-  /* Conversions.  */\n-  sfloat_optab->libcall_basename = \"float\";\n-  sfloat_optab->libcall_gen = gen_int_to_fp_conv_libfunc;\n-  ufloat_optab->libcall_gen = gen_ufloat_conv_libfunc;\n-  sfix_optab->libcall_basename = \"fix\";\n-  sfix_optab->libcall_gen = gen_fp_to_int_conv_libfunc;\n-  ufix_optab->libcall_basename = \"fixuns\";\n-  ufix_optab->libcall_gen = gen_fp_to_int_conv_libfunc;\n-  lrint_optab->libcall_basename = \"lrint\";\n-  lrint_optab->libcall_gen = gen_int_to_fp_nondecimal_conv_libfunc;\n-  lround_optab->libcall_basename = \"lround\";\n-  lround_optab->libcall_gen = gen_int_to_fp_nondecimal_conv_libfunc;\n-  lfloor_optab->libcall_basename = \"lfloor\";\n-  lfloor_optab->libcall_gen = gen_int_to_fp_nondecimal_conv_libfunc;\n-  lceil_optab->libcall_basename = \"lceil\";\n-  lceil_optab->libcall_gen = gen_int_to_fp_nondecimal_conv_libfunc;\n-\n-  /* trunc_optab is also used for FLOAT_EXTEND.  */\n-  sext_optab->libcall_basename = \"extend\";\n-  sext_optab->libcall_gen = gen_extend_conv_libfunc;\n-  trunc_optab->libcall_basename = \"trunc\";\n-  trunc_optab->libcall_gen = gen_trunc_conv_libfunc;\n-\n-  /* Conversions for fixed-point modes and other modes.  */\n-  fract_optab->libcall_basename = \"fract\";\n-  fract_optab->libcall_gen = gen_fract_conv_libfunc;\n-  satfract_optab->libcall_basename = \"satfract\";\n-  satfract_optab->libcall_gen = gen_satfract_conv_libfunc;\n-  fractuns_optab->libcall_basename = \"fractuns\";\n-  fractuns_optab->libcall_gen = gen_fractuns_conv_libfunc;\n-  satfractuns_optab->libcall_basename = \"satfractuns\";\n-  satfractuns_optab->libcall_gen = gen_satfractuns_conv_libfunc;\n-\n   /* The ffs function operates on `int'.  Fall back on it if we do not\n      have a libgcc2 function for that width.  */\n   if (INT_TYPE_SIZE < BITS_PER_WORD)\n@@ -6594,7 +6162,8 @@ init_optabs (void)\n   /* Use cabs for double complex abs, since systems generally have cabs.\n      Don't define any libcall for float complex, so that cabs will be used.  */\n   if (complex_double_type_node)\n-    set_optab_libfunc (abs_optab, TYPE_MODE (complex_double_type_node), \"cabs\");\n+    set_optab_libfunc (abs_optab, TYPE_MODE (complex_double_type_node),\n+\t\t       \"cabs\");\n \n   abort_libfunc = init_one_libfunc (\"abort\");\n   memcpy_libfunc = init_one_libfunc (\"memcpy\");\n@@ -6686,45 +6255,35 @@ init_sync_libfuncs (int max)\n DEBUG_FUNCTION void\n debug_optab_libfuncs (void)\n {\n-  int i;\n-  int j;\n-  int k;\n+  int i, j, k;\n \n   /* Dump the arithmetic optabs.  */\n-  for (i = 0; i != (int) OTI_MAX; i++)\n+  for (i = FIRST_NORM_OPTAB; i <= LAST_NORMLIB_OPTAB; ++i)\n     for (j = 0; j < NUM_MACHINE_MODES; ++j)\n       {\n-\toptab o;\n-\trtx l;\n-\n-\to = &optab_table[i];\n-\tl = optab_libfunc (o, (enum machine_mode) j);\n+\trtx l = optab_libfunc ((optab) i, (enum machine_mode) j);\n \tif (l)\n \t  {\n \t    gcc_assert (GET_CODE (l) == SYMBOL_REF);\n \t    fprintf (stderr, \"%s\\t%s:\\t%s\\n\",\n-\t\t     GET_RTX_NAME (optab_to_code (o)),\n+\t\t     GET_RTX_NAME (optab_to_code ((optab) i)),\n \t\t     GET_MODE_NAME (j),\n \t\t     XSTR (l, 0));\n \t  }\n       }\n \n   /* Dump the conversion optabs.  */\n-  for (i = 0; i < (int) COI_MAX; ++i)\n+  for (i = FIRST_CONV_OPTAB; i <= LAST_CONVLIB_OPTAB; ++i)\n     for (j = 0; j < NUM_MACHINE_MODES; ++j)\n       for (k = 0; k < NUM_MACHINE_MODES; ++k)\n \t{\n-\t  convert_optab o;\n-\t  rtx l;\n-\n-\t  o = &convert_optab_table[i];\n-\t  l = convert_optab_libfunc (o, (enum machine_mode) j,\n-\t\t\t\t     (enum machine_mode) k);\n+\t  rtx l = convert_optab_libfunc ((optab) i, (enum machine_mode) j,\n+\t\t\t\t\t (enum machine_mode) k);\n \t  if (l)\n \t    {\n \t      gcc_assert (GET_CODE (l) == SYMBOL_REF);\n \t      fprintf (stderr, \"%s\\t%s\\t%s:\\t%s\\n\",\n-\t\t       GET_RTX_NAME (optab_to_code (o)),\n+\t\t       GET_RTX_NAME (optab_to_code ((optab) i)),\n \t\t       GET_MODE_NAME (j),\n \t\t       GET_MODE_NAME (k),\n \t\t       XSTR (l, 0));"}, {"sha": "9f6b29cd3e52b970149b9bae8beb703fcf7af6b8", "filename": "gcc/optabs.def", "status": "added", "additions": 308, "deletions": 0, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd1440b199ae8476f1b6df884e86fa07388e1f80/gcc%2Foptabs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd1440b199ae8476f1b6df884e86fa07388e1f80/gcc%2Foptabs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.def?ref=cd1440b199ae8476f1b6df884e86fa07388e1f80", "patch": "@@ -0,0 +1,308 @@\n+/* Definitions for operation tables, or \"optabs\".\n+   Copyright (C) 1987-2012 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* Entries here are categorized C, D, N, V.  See genopinit.c for details\n+   on the meaning of the categories and for the pattern dollar codes.  */\n+\n+/* The extension libcalls are used for float extension.  */\n+OPTAB_CL(sext_optab, \"extend$b$a2\", SIGN_EXTEND, \"extend\", gen_extend_conv_libfunc)\n+OPTAB_CL(trunc_optab, \"trunc$b$a2\", TRUNCATE, \"trunc\", gen_trunc_conv_libfunc)\n+OPTAB_CL(zext_optab, \"zero_extend$b$a2\", ZERO_EXTEND, NULL, NULL)\n+\n+OPTAB_CL(sfix_optab, \"fix$F$b$I$a2\", FIX, \"fix\", gen_fp_to_int_conv_libfunc)\n+OPTAB_CL(ufix_optab, \"fixuns$F$b$a2\", UNSIGNED_FIX, \"fixuns\", gen_fp_to_int_conv_libfunc)\n+OPTAB_CL(sfloat_optab, \"float$I$b$F$a2\", FLOAT, \"float\", gen_int_to_fp_conv_libfunc)\n+OPTAB_CL(ufloat_optab, \"floatuns$I$b$F$a2\", UNSIGNED_FLOAT, NULL, gen_ufloat_conv_libfunc)\n+\n+OPTAB_CL(lrint_optab, \"lrint$F$b$I$a2\", UNKNOWN, \"lrint\", gen_int_to_fp_nondecimal_conv_libfunc)\n+OPTAB_CL(lround_optab, \"lround$F$b$I$a2\", UNKNOWN, \"lround\", gen_int_to_fp_nondecimal_conv_libfunc)\n+OPTAB_CL(lfloor_optab, \"lfloor$F$b$I$a2\", UNKNOWN, \"lfloor\", gen_int_to_fp_nondecimal_conv_libfunc)\n+OPTAB_CL(lceil_optab, \"lceil$F$b$I$a2\", UNKNOWN, \"lceil\", gen_int_to_fp_nondecimal_conv_libfunc)\n+\n+/* Conversions for fixed-point modes and other modes.  */\n+OPTAB_CL(fract_optab, \"fract$b$a2\", FRACT_CONVERT, \"fract\", gen_fract_conv_libfunc)\n+OPTAB_CL(fractuns_optab, \"fractuns$I$b$Q$a2\", UNSIGNED_FRACT_CONVERT, \"fractuns\", gen_fractuns_conv_libfunc)\n+OPTAB_CX(fractuns_optab, \"fractuns$Q$b$I$a2\")\n+OPTAB_CL(satfract_optab, \"satfract$b$Q$a2\", SAT_FRACT, \"satfract\", gen_satfract_conv_libfunc)\n+OPTAB_CL(satfractuns_optab, \"satfractuns$I$b$Q$a2\", UNSIGNED_SAT_FRACT, \"satfractuns\", gen_satfractuns_conv_libfunc)\n+\n+OPTAB_CD(sfixtrunc_optab, \"fix_trunc$F$b$I$a2\")\n+OPTAB_CD(ufixtrunc_optab, \"fixuns_trunc$F$b$I$a2\")\n+\n+/* Misc optabs that use two modes; model them as \"conversions\".  */\n+OPTAB_CD(smul_widen_optab, \"mul$b$a3\")\n+OPTAB_CD(umul_widen_optab, \"umul$b$a3\")\n+OPTAB_CD(usmul_widen_optab, \"usmul$b$a3\")\n+OPTAB_CD(smadd_widen_optab, \"madd$b$a4\")\n+OPTAB_CD(umadd_widen_optab, \"umadd$b$a4\")\n+OPTAB_CD(ssmadd_widen_optab, \"ssmadd$b$a4\")\n+OPTAB_CD(usmadd_widen_optab, \"usmadd$b$a4\")\n+OPTAB_CD(smsub_widen_optab, \"msub$b$a4\")\n+OPTAB_CD(umsub_widen_optab, \"umsub$b$a4\")\n+OPTAB_CD(ssmsub_widen_optab, \"ssmsub$b$a4\")\n+OPTAB_CD(usmsub_widen_optab, \"usmsub$a$b4\")\n+OPTAB_CD(vec_load_lanes_optab, \"vec_load_lanes$a$b\")\n+OPTAB_CD(vec_store_lanes_optab, \"vec_store_lanes$a$b\")\n+OPTAB_CD(vcond_optab, \"vcond$a$b\")\n+OPTAB_CD(vcondu_optab, \"vcondu$a$b\")\n+\n+OPTAB_NL(add_optab, \"add$P$a3\", PLUS, \"add\", '3', gen_int_fp_fixed_libfunc)\n+OPTAB_NX(add_optab, \"add$F$a3\")\n+OPTAB_NX(add_optab, \"add$Q$a3\")\n+OPTAB_VL(addv_optab, \"addv$I$a3\", PLUS, \"add\", '3', gen_intv_fp_libfunc)\n+OPTAB_VX(addv_optab, \"add$F$a3\")\n+OPTAB_NL(ssadd_optab, \"ssadd$Q$a3\", SS_PLUS, \"ssadd\", '3', gen_signed_fixed_libfunc)\n+OPTAB_NL(usadd_optab, \"usadd$Q$a3\", US_PLUS, \"usadd\", '3', gen_unsigned_fixed_libfunc)\n+OPTAB_NL(sub_optab, \"sub$P$a3\", MINUS, \"sub\", '3', gen_int_fp_fixed_libfunc)\n+OPTAB_NX(sub_optab, \"sub$F$a3\")\n+OPTAB_NX(sub_optab, \"sub$Q$a3\")\n+OPTAB_VL(subv_optab, \"subv$I$a3\", MINUS, \"sub\", '3', gen_intv_fp_libfunc)\n+OPTAB_VX(subv_optab, \"sub$F$a3\")\n+OPTAB_NL(sssub_optab, \"sssub$Q$a3\", SS_MINUS, \"sssub\", '3', gen_signed_fixed_libfunc)\n+OPTAB_NL(ussub_optab, \"ussub$Q$a3\", US_MINUS, \"ussub\", '3', gen_unsigned_fixed_libfunc)\n+OPTAB_NL(smul_optab, \"mul$Q$a3\", MULT, \"mul\", '3', gen_int_fp_fixed_libfunc)\n+OPTAB_NX(smul_optab, \"mul$P$a3\")\n+OPTAB_NX(smul_optab, \"mul$F$a3\")\n+OPTAB_VL(smulv_optab, \"mulv$I$a3\", MULT, \"mul\", '3', gen_intv_fp_libfunc)\n+OPTAB_VX(smulv_optab, \"mul$F$a3\")\n+OPTAB_NL(ssmul_optab, \"ssmul$Q$a3\", SS_MULT, \"ssmul\", '3', gen_signed_fixed_libfunc)\n+OPTAB_NL(usmul_optab, \"usmul$Q$a3\", US_MULT, \"usmul\", '3', gen_unsigned_fixed_libfunc)\n+OPTAB_NL(sdiv_optab, \"div$a3\", DIV, \"div\", '3', gen_int_fp_signed_fixed_libfunc)\n+OPTAB_VL(sdivv_optab, \"divv$I$a3\", DIV, \"divv\", '3', gen_int_libfunc)\n+OPTAB_VX(sdivv_optab, \"div$F$a3\")\n+OPTAB_NL(ssdiv_optab, \"ssdiv$Q$a3\", SS_DIV, \"ssdiv\", '3', gen_signed_fixed_libfunc)\n+OPTAB_NL(udiv_optab, \"udiv$I$a3\", UDIV, \"udiv\", '3', gen_int_unsigned_fixed_libfunc)\n+OPTAB_NX(udiv_optab, \"udiv$Q$a3\")\n+OPTAB_NL(usdiv_optab, \"usdiv$Q$a3\", US_DIV, \"usdiv\", '3', gen_unsigned_fixed_libfunc)\n+OPTAB_NL(sdivmod_optab, \"divmod$a4\", UNKNOWN, \"divmod\", '4', gen_int_libfunc)\n+OPTAB_NL(udivmod_optab, \"udivmod$a4\", UNKNOWN, \"udivmod\", '4', gen_int_libfunc)\n+OPTAB_NL(smod_optab, \"mod$a3\", MOD, \"mod\", '3', gen_int_libfunc)\n+OPTAB_NL(umod_optab, \"umod$a3\", UMOD, \"umod\", '3', gen_int_libfunc)\n+OPTAB_NL(ftrunc_optab, \"ftrunc$F$a2\", UNKNOWN, \"ftrunc\", '2', gen_fp_libfunc)\n+OPTAB_NL(and_optab, \"and$a3\", AND, \"and\", '3', gen_int_libfunc)\n+OPTAB_NL(ior_optab, \"ior$a3\", IOR, \"ior\", '3', gen_int_libfunc)\n+OPTAB_NL(xor_optab, \"xor$a3\", XOR, \"xor\", '3', gen_int_libfunc)\n+OPTAB_NL(ashl_optab, \"ashl$a3\", ASHIFT, \"ashl\", '3', gen_int_fixed_libfunc)\n+OPTAB_NL(ssashl_optab, \"ssashl$Q$a3\", SS_ASHIFT, \"ssashl\", '3', gen_signed_fixed_libfunc)\n+OPTAB_NL(usashl_optab, \"usashl$Q$a3\", US_ASHIFT, \"usashl\", '3', gen_unsigned_fixed_libfunc)\n+OPTAB_NL(ashr_optab, \"ashr$a3\", ASHIFTRT, \"ashr\", '3', gen_int_signed_fixed_libfunc)\n+OPTAB_NL(lshr_optab, \"lshr$a3\", LSHIFTRT, \"lshr\", '3', gen_int_unsigned_fixed_libfunc)\n+OPTAB_NC(rotl_optab, \"rotl$a3\", ROTATE)\n+OPTAB_NC(rotr_optab, \"rotr$a3\", ROTATERT)\n+OPTAB_VC(vashl_optab, \"vashl$a3\", ASHIFT)\n+OPTAB_VC(vashr_optab, \"vashr$a3\", ASHIFTRT)\n+OPTAB_VC(vlshr_optab, \"vlshr$a3\", LSHIFTRT)\n+OPTAB_VC(vrotl_optab, \"vrotl$a3\", ROTATE)\n+OPTAB_VC(vrotr_optab, \"vrotr$a3\", ROTATERT)\n+OPTAB_NL(smin_optab, \"smin$a3\", SMIN, \"min\", '3', gen_int_fp_libfunc)\n+OPTAB_NL(smax_optab, \"smax$a3\", SMAX, \"max\", '3', gen_int_fp_libfunc)\n+OPTAB_NL(umin_optab, \"umin$I$a3\", UMIN, \"umin\", '3', gen_int_libfunc)\n+OPTAB_NL(umax_optab, \"umax$I$a3\", UMAX, \"umax\", '3', gen_int_libfunc)\n+\n+OPTAB_NL(neg_optab, \"neg$P$a2\", NEG, \"neg\", '2', gen_int_fp_fixed_libfunc)\n+OPTAB_NX(neg_optab, \"neg$F$a2\")\n+OPTAB_NX(neg_optab, \"neg$Q$a2\")\n+OPTAB_VL(negv_optab, \"negv$I$a2\", NEG, \"neg\", '2', gen_intv_fp_libfunc)\n+OPTAB_VX(negv_optab, \"neg$F$a2\")\n+OPTAB_NL(ssneg_optab, \"ssneg$Q$a2\", SS_NEG, \"ssneg\", '2', gen_signed_fixed_libfunc)\n+OPTAB_NL(usneg_optab, \"usneg$Q$a2\", US_NEG, \"usneg\", '2', gen_unsigned_fixed_libfunc)\n+OPTAB_NC(abs_optab, \"abs$P$a2\", ABS)\n+OPTAB_NX(abs_optab, \"abs$F$a2\")\n+OPTAB_VC(absv_optab, \"absv$I$a2\", ABS)\n+OPTAB_VX(absv_optab, \"abs$F$a2\")\n+OPTAB_NL(one_cmpl_optab, \"one_cmpl$a2\", NOT, \"one_cmpl\", '2', gen_int_libfunc)\n+OPTAB_NC(bswap_optab, \"bswap$a2\", BSWAP)\n+OPTAB_NL(ffs_optab, \"ffs$a2\", FFS, \"ffs\", '2', gen_int_libfunc)\n+OPTAB_NL(clz_optab, \"clz$a2\", CLZ, \"clz\", '2', gen_int_libfunc)\n+OPTAB_NL(ctz_optab, \"ctz$a2\", CTZ, \"ctz\", '2', gen_int_libfunc)\n+OPTAB_NL(clrsb_optab, \"clrsb$a2\", CLRSB, \"clrsb\", '2', gen_int_libfunc)\n+OPTAB_NL(popcount_optab, \"popcount$a2\", POPCOUNT, \"popcount\", '2', gen_int_libfunc)\n+OPTAB_NL(parity_optab, \"parity$a2\", PARITY, \"parity\", '2', gen_int_libfunc)\n+\n+/* Comparison libcalls for integers MUST come in pairs, signed/unsigned.  */\n+OPTAB_NL(cmp_optab, NULL, UNKNOWN, \"cmp\", '2', gen_int_fp_fixed_libfunc)\n+OPTAB_NL(ucmp_optab, NULL, UNKNOWN, \"ucmp\", '2', gen_int_libfunc)\n+\n+/* EQ etc are floating point comparisons.  */\n+OPTAB_NL(eq_optab, NULL, EQ, \"eq\", '2', gen_fp_libfunc)\n+OPTAB_NL(ne_optab, NULL, NE, \"ne\", '2', gen_fp_libfunc)\n+OPTAB_NL(gt_optab, NULL, GT, \"gt\", '2', gen_fp_libfunc)\n+OPTAB_NL(ge_optab, NULL, GE, \"ge\", '2', gen_fp_libfunc)\n+OPTAB_NL(lt_optab, NULL, LT, \"lt\", '2', gen_fp_libfunc)\n+OPTAB_NL(le_optab, NULL, LE, \"le\", '2', gen_fp_libfunc)\n+OPTAB_NL(unord_optab, NULL, UNORDERED, \"unord\", '2', gen_fp_libfunc)\n+\n+OPTAB_NL(powi_optab, NULL, UNKNOWN, \"powi\", '2', gen_fp_libfunc)\n+\n+/* These are all initialized individually, on a per-host basis.  */\n+OPTAB_NC(sqrt_optab, \"sqrt$a2\", SQRT)\n+OPTAB_NC(sync_old_add_optab, \"sync_old_add$I$a\", UNKNOWN)\n+OPTAB_NC(sync_old_sub_optab, \"sync_old_sub$I$a\", UNKNOWN)\n+OPTAB_NC(sync_old_ior_optab, \"sync_old_ior$I$a\", UNKNOWN)\n+OPTAB_NC(sync_old_and_optab, \"sync_old_and$I$a\", UNKNOWN)\n+OPTAB_NC(sync_old_xor_optab, \"sync_old_xor$I$a\", UNKNOWN)\n+OPTAB_NC(sync_old_nand_optab, \"sync_old_nand$I$a\", UNKNOWN)\n+OPTAB_NC(sync_new_add_optab, \"sync_new_add$I$a\", UNKNOWN)\n+OPTAB_NC(sync_new_sub_optab, \"sync_new_sub$I$a\", UNKNOWN)\n+OPTAB_NC(sync_new_ior_optab, \"sync_new_ior$I$a\", UNKNOWN)\n+OPTAB_NC(sync_new_and_optab, \"sync_new_and$I$a\", UNKNOWN)\n+OPTAB_NC(sync_new_xor_optab, \"sync_new_xor$I$a\", UNKNOWN)\n+OPTAB_NC(sync_new_nand_optab, \"sync_new_nand$I$a\", UNKNOWN)\n+OPTAB_NC(sync_compare_and_swap_optab, \"sync_compare_and_swap$I$a\", UNKNOWN)\n+OPTAB_NC(sync_lock_test_and_set_optab, \"sync_lock_test_and_set$I$a\", UNKNOWN)\n+\n+OPTAB_DC(mov_optab, \"mov$a\", SET)\n+OPTAB_DC(movstrict_optab, \"movstrict$a\", STRICT_LOW_PART)\n+OPTAB_D (movmisalign_optab, \"movmisalign$a\")\n+OPTAB_D (storent_optab, \"storent$a\")\n+OPTAB_D (push_optab, \"push$a1\")\n+OPTAB_D (reload_in_optab, \"reload_in$a\")\n+OPTAB_D (reload_out_optab, \"reload_out$a\")\n+\n+OPTAB_DC(cbranch_optab, \"cbranch$a4\", COMPARE)\n+OPTAB_D (addcc_optab, \"add$acc\")\n+OPTAB_D (movcc_optab, \"mov$acc\")\n+OPTAB_D (cmov_optab, \"cmov$a6\")\n+OPTAB_D (cstore_optab, \"cstore$a4\")\n+OPTAB_D (ctrap_optab, \"ctrap$a4\")\n+\n+OPTAB_D (smul_highpart_optab, \"smul$a3_highpart\")\n+OPTAB_D (umul_highpart_optab, \"umul$a3_highpart\")\n+\n+OPTAB_D (cmpmem_optab, \"cmpmem$a\")\n+OPTAB_D (cmpstr_optab, \"cmpstr$a\")\n+OPTAB_D (cmpstrn_optab, \"cmpstrn$a\")\n+OPTAB_D (movmem_optab, \"movmem$a\")\n+OPTAB_D (setmem_optab, \"setmem$a\")\n+OPTAB_D (strlen_optab, \"strlen$a\")\n+\n+OPTAB_DC(fma_optab, \"fma$a4\", FMA)\n+OPTAB_D (fms_optab, \"fms$a4\")\n+OPTAB_D (fnma_optab, \"fnma$a4\")\n+OPTAB_D (fnms_optab, \"fnms$a4\")\n+\n+OPTAB_D (rint_optab, \"rint$a2\")\n+OPTAB_D (round_optab, \"round$a2\")\n+OPTAB_D (floor_optab, \"floor$a2\")\n+OPTAB_D (ceil_optab, \"ceil$a2\")\n+OPTAB_D (btrunc_optab, \"btrunc$a2\")\n+OPTAB_D (nearbyint_optab, \"nearbyint$a2\")\n+\n+OPTAB_D (acos_optab, \"acos$a2\")\n+OPTAB_D (asin_optab, \"asin$a2\")\n+OPTAB_D (atan2_optab, \"atan2$a3\")\n+OPTAB_D (atan_optab, \"atan$a2\")\n+OPTAB_D (copysign_optab, \"copysign$F$a3\")\n+OPTAB_D (cos_optab, \"cos$a2\")\n+OPTAB_D (exp10_optab, \"exp10$a2\")\n+OPTAB_D (exp2_optab, \"exp2$a2\")\n+OPTAB_D (exp_optab, \"exp$a2\")\n+OPTAB_D (expm1_optab, \"expm1$a2\")\n+OPTAB_D (fmod_optab, \"fmod$a3\")\n+OPTAB_D (ilogb_optab, \"ilogb$a2\")\n+OPTAB_D (isinf_optab, \"isinf$a2\")\n+OPTAB_D (ldexp_optab, \"ldexp$a3\")\n+OPTAB_D (log10_optab, \"log10$a2\")\n+OPTAB_D (log1p_optab, \"log1p$a2\")\n+OPTAB_D (log2_optab, \"log2$a2\")\n+OPTAB_D (log_optab, \"log$a2\")\n+OPTAB_D (logb_optab, \"logb$a2\")\n+OPTAB_D (pow_optab, \"pow$a3\")\n+OPTAB_D (remainder_optab, \"remainder$a3\")\n+OPTAB_D (scalb_optab, \"scalb$a3\")\n+OPTAB_D (signbit_optab, \"signbit$F$a2\")\n+OPTAB_D (significand_optab, \"significand$a2\")\n+OPTAB_D (sin_optab, \"sin$a2\")\n+OPTAB_D (sincos_optab, \"sincos$a3\")\n+OPTAB_D (tan_optab, \"tan$a2\")\n+\n+OPTAB_D (reduc_smax_optab, \"reduc_smax_$a\")\n+OPTAB_D (reduc_smin_optab, \"reduc_smin_$a\")\n+OPTAB_D (reduc_splus_optab, \"reduc_splus_$a\")\n+OPTAB_D (reduc_umax_optab, \"reduc_umax_$a\")\n+OPTAB_D (reduc_umin_optab, \"reduc_umin_$a\")\n+OPTAB_D (reduc_uplus_optab, \"reduc_uplus_$a\")\n+OPTAB_D (sdot_prod_optab, \"sdot_prod$I$a\")\n+OPTAB_D (ssum_widen_optab, \"widen_ssum$I$a3\")\n+OPTAB_D (udot_prod_optab, \"udot_prod$I$a\")\n+OPTAB_D (usum_widen_optab, \"widen_usum$I$a3\")\n+OPTAB_D (vec_extract_optab, \"vec_extract$a\")\n+OPTAB_D (vec_init_optab, \"vec_init$a\")\n+OPTAB_D (vec_pack_sfix_trunc_optab, \"vec_pack_sfix_trunc_$a\")\n+OPTAB_D (vec_pack_ssat_optab, \"vec_pack_ssat_$a\")\n+OPTAB_D (vec_pack_trunc_optab, \"vec_pack_trunc_$a\")\n+OPTAB_D (vec_pack_ufix_trunc_optab, \"vec_pack_ufix_trunc_$a\")\n+OPTAB_D (vec_pack_usat_optab, \"vec_pack_usat_$a\")\n+OPTAB_D (vec_perm_const_optab, \"vec_perm_const$a\")\n+OPTAB_D (vec_perm_optab, \"vec_perm$a\")\n+OPTAB_D (vec_realign_load_optab, \"vec_realign_load_$a\")\n+OPTAB_D (vec_set_optab, \"vec_set$a\")\n+OPTAB_D (vec_shl_optab, \"vec_shl_$a\")\n+OPTAB_D (vec_shr_optab, \"vec_shr_$a\")\n+OPTAB_D (vec_unpacks_float_hi_optab, \"vec_unpacks_float_hi_$a\")\n+OPTAB_D (vec_unpacks_float_lo_optab, \"vec_unpacks_float_lo_$a\")\n+OPTAB_D (vec_unpacks_hi_optab, \"vec_unpacks_hi_$a\")\n+OPTAB_D (vec_unpacks_lo_optab, \"vec_unpacks_lo_$a\")\n+OPTAB_D (vec_unpacku_float_hi_optab, \"vec_unpacku_float_hi_$a\")\n+OPTAB_D (vec_unpacku_float_lo_optab, \"vec_unpacku_float_lo_$a\")\n+OPTAB_D (vec_unpacku_hi_optab, \"vec_unpacku_hi_$a\")\n+OPTAB_D (vec_unpacku_lo_optab, \"vec_unpacku_lo_$a\")\n+OPTAB_D (vec_widen_smult_even_optab, \"vec_widen_smult_even_$a\")\n+OPTAB_D (vec_widen_smult_hi_optab, \"vec_widen_smult_hi_$a\")\n+OPTAB_D (vec_widen_smult_lo_optab, \"vec_widen_smult_lo_$a\")\n+OPTAB_D (vec_widen_smult_odd_optab, \"vec_widen_smult_odd_$a\")\n+OPTAB_D (vec_widen_sshiftl_hi_optab, \"vec_widen_sshiftl_hi_$a\")\n+OPTAB_D (vec_widen_sshiftl_lo_optab, \"vec_widen_sshiftl_lo_$a\")\n+OPTAB_D (vec_widen_umult_even_optab, \"vec_widen_umult_even_$a\")\n+OPTAB_D (vec_widen_umult_hi_optab, \"vec_widen_umult_hi_$a\")\n+OPTAB_D (vec_widen_umult_lo_optab, \"vec_widen_umult_lo_$a\")\n+OPTAB_D (vec_widen_umult_odd_optab, \"vec_widen_umult_odd_$a\")\n+OPTAB_D (vec_widen_ushiftl_hi_optab, \"vec_widen_ushiftl_hi_$a\")\n+OPTAB_D (vec_widen_ushiftl_lo_optab, \"vec_widen_ushiftl_lo_$a\")\n+\n+OPTAB_D (sync_add_optab, \"sync_add$I$a\")\n+OPTAB_D (sync_and_optab, \"sync_and$I$a\")\n+OPTAB_D (sync_ior_optab, \"sync_ior$I$a\")\n+OPTAB_D (sync_lock_release_optab, \"sync_lock_release$I$a\")\n+OPTAB_D (sync_nand_optab, \"sync_nand$I$a\")\n+OPTAB_D (sync_sub_optab, \"sync_sub$I$a\")\n+OPTAB_D (sync_xor_optab, \"sync_xor$I$a\")\n+\n+OPTAB_D (atomic_add_fetch_optab, \"atomic_add_fetch$I$a\")\n+OPTAB_D (atomic_add_optab, \"atomic_add$I$a\")\n+OPTAB_D (atomic_and_fetch_optab, \"atomic_and_fetch$I$a\")\n+OPTAB_D (atomic_and_optab, \"atomic_and$I$a\")\n+OPTAB_D (atomic_compare_and_swap_optab, \"atomic_compare_and_swap$I$a\")\n+OPTAB_D (atomic_exchange_optab,\t \"atomic_exchange$I$a\")\n+OPTAB_D (atomic_fetch_add_optab, \"atomic_fetch_add$I$a\")\n+OPTAB_D (atomic_fetch_and_optab, \"atomic_fetch_and$I$a\")\n+OPTAB_D (atomic_fetch_nand_optab, \"atomic_fetch_nand$I$a\")\n+OPTAB_D (atomic_fetch_or_optab, \"atomic_fetch_or$I$a\")\n+OPTAB_D (atomic_fetch_sub_optab, \"atomic_fetch_sub$I$a\")\n+OPTAB_D (atomic_fetch_xor_optab, \"atomic_fetch_xor$I$a\")\n+OPTAB_D (atomic_load_optab, \"atomic_load$I$a\")\n+OPTAB_D (atomic_nand_fetch_optab, \"atomic_nand_fetch$I$a\")\n+OPTAB_D (atomic_nand_optab, \"atomic_nand$I$a\")\n+OPTAB_D (atomic_or_fetch_optab, \"atomic_or_fetch$I$a\")\n+OPTAB_D (atomic_or_optab, \"atomic_or$I$a\")\n+OPTAB_D (atomic_store_optab, \"atomic_store$I$a\")\n+OPTAB_D (atomic_sub_fetch_optab, \"atomic_sub_fetch$I$a\")\n+OPTAB_D (atomic_sub_optab, \"atomic_sub$I$a\")\n+OPTAB_D (atomic_xor_fetch_optab, \"atomic_xor_fetch$I$a\")\n+OPTAB_D (atomic_xor_optab, \"atomic_xor$I$a\")"}, {"sha": "e0be2bac4fd44ee6775c5b543d47dacb2462c4eb", "filename": "gcc/optabs.h", "status": "modified", "additions": 94, "deletions": 866, "changes": 960, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd1440b199ae8476f1b6df884e86fa07388e1f80/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd1440b199ae8476f1b6df884e86fa07388e1f80/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=cd1440b199ae8476f1b6df884e86fa07388e1f80", "patch": "@@ -22,833 +22,58 @@ along with GCC; see the file COPYING3.  If not see\n #define GCC_OPTABS_H\n \n #include \"insn-codes.h\"\n+#include \"insn-opinit.h\"\n \n-/* Optabs are tables saying how to generate insn bodies\n-   for various machine modes and numbers of operands.\n-   Each optab applies to one operation.\n+typedef enum optab_tag optab;\n+typedef enum optab_tag convert_optab;\n+typedef enum optab_tag direct_optab;\n \n-   For example, add_optab applies to addition.\n-\n-   The insn_code slot is the enum insn_code that says how to\n-   generate an insn for this operation on a particular machine mode.\n-   It is CODE_FOR_nothing if there is no such insn on the target machine.\n-\n-   The `lib_call' slot is the name of the library function that\n-   can be used to perform the operation.\n-\n-   A few optabs, such as move_optab, are used by special code.  */\n-\n-struct optab_handlers\n-{\n-  enum insn_code insn_code;\n-};\n-\n-struct widening_optab_handlers\n-{\n-  struct optab_handlers handlers[NUM_MACHINE_MODES][NUM_MACHINE_MODES];\n-};\n-\n-struct optab_d\n+struct optab_libcall_d\n {\n-  enum rtx_code code_;\n   char libcall_suffix;\n   const char *libcall_basename;\n-  void (*libcall_gen)(struct optab_d *, const char *name, char suffix,\n-\t\t      enum machine_mode);\n-  struct optab_handlers handlers[NUM_MACHINE_MODES];\n-  struct widening_optab_handlers *widening;\n+  void (*libcall_gen) (optab, const char *name,\n+\t\t       char suffix, enum machine_mode);\n };\n-typedef struct optab_d * optab;\n \n-/* A convert_optab is for some sort of conversion operation between\n-   modes.  The first array index is the destination mode, the second\n-   is the source mode.  */\n-struct convert_optab_d\n+struct convert_optab_libcall_d\n {\n-  enum rtx_code code_;\n   const char *libcall_basename;\n-  void (*libcall_gen)(struct convert_optab_d *, const char *name,\n-\t\t      enum machine_mode,\n-\t\t      enum machine_mode);\n-  struct optab_handlers handlers[NUM_MACHINE_MODES][NUM_MACHINE_MODES];\n+  void (*libcall_gen) (convert_optab, const char *name,\n+\t\t       enum machine_mode, enum machine_mode);\n };\n-typedef struct convert_optab_d *convert_optab;\n \n /* Given an enum insn_code, access the function to construct\n    the body of that kind of insn.  */\n #define GEN_FCN(CODE) (insn_data[CODE].genfun)\n \n-/* Enumeration of valid indexes into optab_table.  */\n-enum optab_index\n-{\n-  /* Fixed-point operators with signed/unsigned saturation */\n-  OTI_ssadd,\n-  OTI_usadd,\n-  OTI_sssub,\n-  OTI_ussub,\n-  OTI_ssmul,\n-  OTI_usmul,\n-  OTI_ssdiv,\n-  OTI_usdiv,\n-  OTI_ssneg,\n-  OTI_usneg,\n-  OTI_ssashl,\n-  OTI_usashl,\n-\n-  OTI_add,\n-  OTI_addv,\n-  OTI_sub,\n-  OTI_subv,\n-\n-  /* Signed and fp multiply */\n-  OTI_smul,\n-  OTI_smulv,\n-  /* Signed multiply, return high word */\n-  OTI_smul_highpart,\n-  OTI_umul_highpart,\n-  /* Signed multiply with result one machine mode wider than args */\n-  OTI_smul_widen,\n-  OTI_umul_widen,\n-  /* Widening multiply of one unsigned and one signed operand.  */\n-  OTI_usmul_widen,\n-  /* Signed multiply and add with the result and addend one machine mode\n-     wider than the multiplicand and multiplier.  */\n-  OTI_smadd_widen,\n-  /* Unsigned multiply and add with the result and addend one machine mode\n-     wider than the multiplicand and multiplier.  */\n-  OTI_umadd_widen,\n-  /* Signed multiply and add with the result and addend one machine mode\n-     wider than the multiplicand and multiplier.\n-     All involved operations are saturating.  */\n-  OTI_ssmadd_widen,\n-  /* Unsigned multiply and add with the result and addend one machine mode\n-     wider than the multiplicand and multiplier.\n-     All involved operations are saturating.  */\n-  OTI_usmadd_widen,\n-  /* Signed multiply and subtract the result and minuend one machine mode\n-     wider than the multiplicand and multiplier.  */\n-  OTI_smsub_widen,\n-  /* Unsigned multiply and subtract the result and minuend one machine mode\n-     wider than the multiplicand and multiplier.  */\n-  OTI_umsub_widen,\n-  /* Signed multiply and subtract the result and minuend one machine mode\n-     wider than the multiplicand and multiplier.\n-     All involved operations are saturating.  */\n-  OTI_ssmsub_widen,\n-  /* Unsigned multiply and subtract the result and minuend one machine mode\n-     wider than the multiplicand and multiplier.\n-     All involved operations are saturating.  */\n-  OTI_usmsub_widen,\n-\n-  /* Signed divide */\n-  OTI_sdiv,\n-  OTI_sdivv,\n-  /* Signed divide-and-remainder in one */\n-  OTI_sdivmod,\n-  OTI_udiv,\n-  OTI_udivmod,\n-  /* Signed remainder */\n-  OTI_smod,\n-  OTI_umod,\n-  /* Floating point remainder functions */\n-  OTI_fmod,\n-  OTI_remainder,\n-  /* Convert float to integer in float fmt */\n-  OTI_ftrunc,\n-\n-  /* Logical and */\n-  OTI_and,\n-  /* Logical or */\n-  OTI_ior,\n-  /* Logical xor */\n-  OTI_xor,\n-\n-  /* Arithmetic shift left */\n-  OTI_ashl,\n-  /* Logical shift right */\n-  OTI_lshr,\n-  /* Arithmetic shift right */\n-  OTI_ashr,\n-  /* Rotate left */\n-  OTI_rotl,\n-  /* Rotate right */\n-  OTI_rotr,\n-\n-  /* Arithmetic shift left of vector by vector */\n-  OTI_vashl,\n-  /* Logical shift right of vector by vector */\n-  OTI_vlshr,\n-  /* Arithmetic shift right of vector by vector */\n-  OTI_vashr,\n-  /* Rotate left of vector by vector */\n-  OTI_vrotl,\n-  /* Rotate right of vector by vector */\n-  OTI_vrotr,\n-\n-  /* Signed and floating-point minimum value */\n-  OTI_smin,\n-  /* Signed and floating-point maximum value */\n-  OTI_smax,\n-  /* Unsigned minimum value */\n-  OTI_umin,\n-  /* Unsigned maximum value */\n-  OTI_umax,\n-  /* Power */\n-  OTI_pow,\n-  /* Arc tangent of y/x */\n-  OTI_atan2,\n-  /* Floating multiply/add */\n-  OTI_fma,\n-  OTI_fms,\n-  OTI_fnma,\n-  OTI_fnms,\n-\n-  /* Move instruction.  */\n-  OTI_mov,\n-  /* Move, preserving high part of register.  */\n-  OTI_movstrict,\n-  /* Move, with a misaligned memory.  */\n-  OTI_movmisalign,\n-  /* Nontemporal store.  */\n-  OTI_storent,\n-\n-  /* Unary operations */\n-  /* Negation */\n-  OTI_neg,\n-  OTI_negv,\n-  /* Abs value */\n-  OTI_abs,\n-  OTI_absv,\n-  /* Byteswap */\n-  OTI_bswap,\n-  /* Bitwise not */\n-  OTI_one_cmpl,\n-  /* Bit scanning and counting */\n-  OTI_ffs,\n-  OTI_clz,\n-  OTI_ctz,\n-  OTI_clrsb,\n-  OTI_popcount,\n-  OTI_parity,\n-  /* Square root */\n-  OTI_sqrt,\n-  /* Sine-Cosine */\n-  OTI_sincos,\n-  /* Sine */\n-  OTI_sin,\n-  /* Inverse sine */\n-  OTI_asin,\n-  /* Cosine */\n-  OTI_cos,\n-  /* Inverse cosine */\n-  OTI_acos,\n-  /* Exponential */\n-  OTI_exp,\n-  /* Base-10 Exponential */\n-  OTI_exp10,\n-  /* Base-2 Exponential */\n-  OTI_exp2,\n-  /* Exponential - 1*/\n-  OTI_expm1,\n-  /* Load exponent of a floating point number */\n-  OTI_ldexp,\n-  /* Multiply floating-point number by integral power of radix */\n-  OTI_scalb,\n-  /* Mantissa of a floating-point number */\n-  OTI_significand,\n-  /* Radix-independent exponent */\n-  OTI_logb,\n-  OTI_ilogb,\n-  /* Natural Logarithm */\n-  OTI_log,\n-  /* Base-10 Logarithm */\n-  OTI_log10,\n-  /* Base-2 Logarithm */\n-  OTI_log2,\n-  /* logarithm of 1 plus argument */\n-  OTI_log1p,\n-  /* Rounding functions */\n-  OTI_floor,\n-  OTI_ceil,\n-  OTI_btrunc,\n-  OTI_round,\n-  OTI_nearbyint,\n-  OTI_rint,\n-  /* Tangent */\n-  OTI_tan,\n-  /* Inverse tangent */\n-  OTI_atan,\n-  /* Copy sign */\n-  OTI_copysign,\n-  /* Signbit */\n-  OTI_signbit,\n-  /* Test for infinite value */\n-  OTI_isinf,\n-\n-  /* Compare insn; two operands.  Used only for libcalls.  */\n-  OTI_cmp,\n-  OTI_ucmp,\n-\n-  /* Floating point comparison optabs - used primarily for libfuncs */\n-  OTI_eq,\n-  OTI_ne,\n-  OTI_gt,\n-  OTI_ge,\n-  OTI_lt,\n-  OTI_le,\n-  OTI_unord,\n-\n-  /* String length */\n-  OTI_strlen,\n-\n-  /* Combined compare & jump/move/store flags/trap operations.  */\n-  OTI_cbranch,\n-  OTI_cmov,\n-  OTI_cstore,\n-  OTI_ctrap,\n-\n-  /* Push instruction.  */\n-  OTI_push,\n-\n-  /* Conditional add instruction.  */\n-  OTI_addcc,\n-\n-  /* Reduction operations on a vector operand.  */\n-  OTI_reduc_smax,\n-  OTI_reduc_umax,\n-  OTI_reduc_smin,\n-  OTI_reduc_umin,\n-  OTI_reduc_splus,\n-  OTI_reduc_uplus,\n-\n-  /* Summation, with result machine mode one or more wider than args.  */\n-  OTI_ssum_widen,\n-  OTI_usum_widen,\n-\n-  /* Dot product, with result machine mode one or more wider than args.  */\n-  OTI_sdot_prod,\n-  OTI_udot_prod,\n-\n-  /* Set specified field of vector operand.  */\n-  OTI_vec_set,\n-  /* Extract specified field of vector operand.  */\n-  OTI_vec_extract,\n-  /* Initialize vector operand.  */\n-  OTI_vec_init,\n-  /* Whole vector shift. The shift amount is in bits.  */\n-  OTI_vec_shl,\n-  OTI_vec_shr,\n-  /* Extract specified elements from vectors, for vector load.  */\n-  OTI_vec_realign_load,\n-  /* Widening multiplication.  The high/low/even/odd part of the\n-     resulting vector of products is returned.  */\n-  OTI_vec_widen_umult_hi,\n-  OTI_vec_widen_umult_lo,\n-  OTI_vec_widen_smult_hi,\n-  OTI_vec_widen_smult_lo,\n-  OTI_vec_widen_umult_even,\n-  OTI_vec_widen_umult_odd,\n-  OTI_vec_widen_smult_even,\n-  OTI_vec_widen_smult_odd,\n-  /* Widening shift left.\n-     The high/low part of the resulting vector is returned.  */\n-  OTI_vec_widen_ushiftl_hi,\n-  OTI_vec_widen_ushiftl_lo,\n-  OTI_vec_widen_sshiftl_hi,\n-  OTI_vec_widen_sshiftl_lo,\n-  /* Extract and widen the high/low part of a vector of signed or\n-     floating point elements.  */\n-  OTI_vec_unpacks_hi,\n-  OTI_vec_unpacks_lo,\n-  /* Extract and widen the high/low part of a vector of unsigned\n-     elements.  */\n-  OTI_vec_unpacku_hi,\n-  OTI_vec_unpacku_lo,\n-\n-  /* Extract, convert to floating point and widen the high/low part of\n-     a vector of signed or unsigned integer elements.  */\n-  OTI_vec_unpacks_float_hi,\n-  OTI_vec_unpacks_float_lo,\n-  OTI_vec_unpacku_float_hi,\n-  OTI_vec_unpacku_float_lo,\n-\n-  /* Narrow (demote) and merge the elements of two vectors.  */\n-  OTI_vec_pack_trunc,\n-  OTI_vec_pack_usat,\n-  OTI_vec_pack_ssat,\n-\n-  /* Convert to signed/unsigned integer, narrow and merge elements\n-     of two vectors of floating point elements.  */\n-  OTI_vec_pack_sfix_trunc,\n-  OTI_vec_pack_ufix_trunc,\n-\n-  /* Perform a raise to the power of integer.  */\n-  OTI_powi,\n-\n-  /* Atomic compare and swap.  */\n-  OTI_sync_compare_and_swap,\n-\n-  /* Atomic exchange with acquire semantics.  */\n-  OTI_sync_lock_test_and_set,\n-\n-  /* This second set is atomic operations in which we return the value\n-     that existed in memory before the operation.  */\n-  OTI_sync_old_add,\n-  OTI_sync_old_sub,\n-  OTI_sync_old_ior,\n-  OTI_sync_old_and,\n-  OTI_sync_old_xor,\n-  OTI_sync_old_nand,\n-\n-  /* This third set is atomic operations in which we return the value\n-     that resulted after performing the operation.  */\n-  OTI_sync_new_add,\n-  OTI_sync_new_sub,\n-  OTI_sync_new_ior,\n-  OTI_sync_new_and,\n-  OTI_sync_new_xor,\n-  OTI_sync_new_nand,\n-\n-  OTI_MAX\n-};\n-\n-#define unknown_optab NULL\n-\n-#define ssadd_optab (&optab_table[OTI_ssadd])\n-#define usadd_optab (&optab_table[OTI_usadd])\n-#define sssub_optab (&optab_table[OTI_sssub])\n-#define ussub_optab (&optab_table[OTI_ussub])\n-#define ssmul_optab (&optab_table[OTI_ssmul])\n-#define usmul_optab (&optab_table[OTI_usmul])\n-#define ssdiv_optab (&optab_table[OTI_ssdiv])\n-#define usdiv_optab (&optab_table[OTI_usdiv])\n-#define ssneg_optab (&optab_table[OTI_ssneg])\n-#define usneg_optab (&optab_table[OTI_usneg])\n-#define ssashl_optab (&optab_table[OTI_ssashl])\n-#define usashl_optab (&optab_table[OTI_usashl])\n-\n-#define add_optab (&optab_table[OTI_add])\n-#define sub_optab (&optab_table[OTI_sub])\n-#define smul_optab (&optab_table[OTI_smul])\n-#define addv_optab (&optab_table[OTI_addv])\n-#define subv_optab (&optab_table[OTI_subv])\n-#define smul_highpart_optab (&optab_table[OTI_smul_highpart])\n-#define umul_highpart_optab (&optab_table[OTI_umul_highpart])\n-#define smul_widen_optab (&optab_table[OTI_smul_widen])\n-#define umul_widen_optab (&optab_table[OTI_umul_widen])\n-#define usmul_widen_optab (&optab_table[OTI_usmul_widen])\n-#define smadd_widen_optab (&optab_table[OTI_smadd_widen])\n-#define umadd_widen_optab (&optab_table[OTI_umadd_widen])\n-#define ssmadd_widen_optab (&optab_table[OTI_ssmadd_widen])\n-#define usmadd_widen_optab (&optab_table[OTI_usmadd_widen])\n-#define smsub_widen_optab (&optab_table[OTI_smsub_widen])\n-#define umsub_widen_optab (&optab_table[OTI_umsub_widen])\n-#define ssmsub_widen_optab (&optab_table[OTI_ssmsub_widen])\n-#define usmsub_widen_optab (&optab_table[OTI_usmsub_widen])\n-#define sdiv_optab (&optab_table[OTI_sdiv])\n-#define smulv_optab (&optab_table[OTI_smulv])\n-#define sdivv_optab (&optab_table[OTI_sdivv])\n-#define sdivmod_optab (&optab_table[OTI_sdivmod])\n-#define udiv_optab (&optab_table[OTI_udiv])\n-#define udivmod_optab (&optab_table[OTI_udivmod])\n-#define smod_optab (&optab_table[OTI_smod])\n-#define umod_optab (&optab_table[OTI_umod])\n-#define fmod_optab (&optab_table[OTI_fmod])\n-#define remainder_optab (&optab_table[OTI_remainder])\n-#define ftrunc_optab (&optab_table[OTI_ftrunc])\n-#define and_optab (&optab_table[OTI_and])\n-#define ior_optab (&optab_table[OTI_ior])\n-#define xor_optab (&optab_table[OTI_xor])\n-#define ashl_optab (&optab_table[OTI_ashl])\n-#define lshr_optab (&optab_table[OTI_lshr])\n-#define ashr_optab (&optab_table[OTI_ashr])\n-#define rotl_optab (&optab_table[OTI_rotl])\n-#define rotr_optab (&optab_table[OTI_rotr])\n-#define vashl_optab (&optab_table[OTI_vashl])\n-#define vlshr_optab (&optab_table[OTI_vlshr])\n-#define vashr_optab (&optab_table[OTI_vashr])\n-#define vrotl_optab (&optab_table[OTI_vrotl])\n-#define vrotr_optab (&optab_table[OTI_vrotr])\n-#define smin_optab (&optab_table[OTI_smin])\n-#define smax_optab (&optab_table[OTI_smax])\n-#define umin_optab (&optab_table[OTI_umin])\n-#define umax_optab (&optab_table[OTI_umax])\n-#define pow_optab (&optab_table[OTI_pow])\n-#define atan2_optab (&optab_table[OTI_atan2])\n-#define fma_optab (&optab_table[OTI_fma])\n-#define fms_optab (&optab_table[OTI_fms])\n-#define fnma_optab (&optab_table[OTI_fnma])\n-#define fnms_optab (&optab_table[OTI_fnms])\n-\n-#define mov_optab (&optab_table[OTI_mov])\n-#define movstrict_optab (&optab_table[OTI_movstrict])\n-#define movmisalign_optab (&optab_table[OTI_movmisalign])\n-#define storent_optab (&optab_table[OTI_storent])\n-\n-#define neg_optab (&optab_table[OTI_neg])\n-#define negv_optab (&optab_table[OTI_negv])\n-#define abs_optab (&optab_table[OTI_abs])\n-#define absv_optab (&optab_table[OTI_absv])\n-#define one_cmpl_optab (&optab_table[OTI_one_cmpl])\n-#define bswap_optab (&optab_table[OTI_bswap])\n-#define ffs_optab (&optab_table[OTI_ffs])\n-#define clz_optab (&optab_table[OTI_clz])\n-#define ctz_optab (&optab_table[OTI_ctz])\n-#define clrsb_optab (&optab_table[OTI_clrsb])\n-#define popcount_optab (&optab_table[OTI_popcount])\n-#define parity_optab (&optab_table[OTI_parity])\n-#define sqrt_optab (&optab_table[OTI_sqrt])\n-#define sincos_optab (&optab_table[OTI_sincos])\n-#define sin_optab (&optab_table[OTI_sin])\n-#define asin_optab (&optab_table[OTI_asin])\n-#define cos_optab (&optab_table[OTI_cos])\n-#define acos_optab (&optab_table[OTI_acos])\n-#define exp_optab (&optab_table[OTI_exp])\n-#define exp10_optab (&optab_table[OTI_exp10])\n-#define exp2_optab (&optab_table[OTI_exp2])\n-#define expm1_optab (&optab_table[OTI_expm1])\n-#define ldexp_optab (&optab_table[OTI_ldexp])\n-#define scalb_optab (&optab_table[OTI_scalb])\n-#define significand_optab (&optab_table[OTI_significand])\n-#define logb_optab (&optab_table[OTI_logb])\n-#define ilogb_optab (&optab_table[OTI_ilogb])\n-#define log_optab (&optab_table[OTI_log])\n-#define log10_optab (&optab_table[OTI_log10])\n-#define log2_optab (&optab_table[OTI_log2])\n-#define log1p_optab (&optab_table[OTI_log1p])\n-#define floor_optab (&optab_table[OTI_floor])\n-#define ceil_optab (&optab_table[OTI_ceil])\n-#define btrunc_optab (&optab_table[OTI_btrunc])\n-#define round_optab (&optab_table[OTI_round])\n-#define nearbyint_optab (&optab_table[OTI_nearbyint])\n-#define rint_optab (&optab_table[OTI_rint])\n-#define tan_optab (&optab_table[OTI_tan])\n-#define atan_optab (&optab_table[OTI_atan])\n-#define copysign_optab (&optab_table[OTI_copysign])\n-#define signbit_optab (&optab_table[OTI_signbit])\n-#define isinf_optab (&optab_table[OTI_isinf])\n-\n-#define cmp_optab (&optab_table[OTI_cmp])\n-#define ucmp_optab (&optab_table[OTI_ucmp])\n-\n-#define eq_optab (&optab_table[OTI_eq])\n-#define ne_optab (&optab_table[OTI_ne])\n-#define gt_optab (&optab_table[OTI_gt])\n-#define ge_optab (&optab_table[OTI_ge])\n-#define lt_optab (&optab_table[OTI_lt])\n-#define le_optab (&optab_table[OTI_le])\n-#define unord_optab (&optab_table[OTI_unord])\n-\n-#define strlen_optab (&optab_table[OTI_strlen])\n-\n-#define cbranch_optab (&optab_table[OTI_cbranch])\n-#define cmov_optab (&optab_table[OTI_cmov])\n-#define cstore_optab (&optab_table[OTI_cstore])\n-#define ctrap_optab (&optab_table[OTI_ctrap])\n-\n-#define push_optab (&optab_table[OTI_push])\n-#define addcc_optab (&optab_table[OTI_addcc])\n-\n-#define reduc_smax_optab (&optab_table[OTI_reduc_smax])\n-#define reduc_umax_optab (&optab_table[OTI_reduc_umax])\n-#define reduc_smin_optab (&optab_table[OTI_reduc_smin])\n-#define reduc_umin_optab (&optab_table[OTI_reduc_umin])\n-#define reduc_splus_optab (&optab_table[OTI_reduc_splus])\n-#define reduc_uplus_optab (&optab_table[OTI_reduc_uplus])\n-\n-#define ssum_widen_optab (&optab_table[OTI_ssum_widen])\n-#define usum_widen_optab (&optab_table[OTI_usum_widen])\n-#define sdot_prod_optab (&optab_table[OTI_sdot_prod])\n-#define udot_prod_optab (&optab_table[OTI_udot_prod])\n-\n-#define vec_set_optab (&optab_table[OTI_vec_set])\n-#define vec_extract_optab (&optab_table[OTI_vec_extract])\n-#define vec_init_optab (&optab_table[OTI_vec_init])\n-#define vec_shl_optab (&optab_table[OTI_vec_shl])\n-#define vec_shr_optab (&optab_table[OTI_vec_shr])\n-#define vec_realign_load_optab (&optab_table[OTI_vec_realign_load])\n-#define vec_widen_umult_hi_optab (&optab_table[OTI_vec_widen_umult_hi])\n-#define vec_widen_umult_lo_optab (&optab_table[OTI_vec_widen_umult_lo])\n-#define vec_widen_smult_hi_optab (&optab_table[OTI_vec_widen_smult_hi])\n-#define vec_widen_smult_lo_optab (&optab_table[OTI_vec_widen_smult_lo])\n-#define vec_widen_umult_even_optab (&optab_table[OTI_vec_widen_umult_even])\n-#define vec_widen_umult_odd_optab (&optab_table[OTI_vec_widen_umult_odd])\n-#define vec_widen_smult_even_optab (&optab_table[OTI_vec_widen_smult_even])\n-#define vec_widen_smult_odd_optab (&optab_table[OTI_vec_widen_smult_odd])\n-#define vec_widen_ushiftl_hi_optab (&optab_table[OTI_vec_widen_ushiftl_hi])\n-#define vec_widen_ushiftl_lo_optab (&optab_table[OTI_vec_widen_ushiftl_lo])\n-#define vec_widen_sshiftl_hi_optab (&optab_table[OTI_vec_widen_sshiftl_hi])\n-#define vec_widen_sshiftl_lo_optab (&optab_table[OTI_vec_widen_sshiftl_lo])\n-#define vec_unpacks_hi_optab (&optab_table[OTI_vec_unpacks_hi])\n-#define vec_unpacks_lo_optab (&optab_table[OTI_vec_unpacks_lo])\n-#define vec_unpacku_hi_optab (&optab_table[OTI_vec_unpacku_hi])\n-#define vec_unpacku_lo_optab (&optab_table[OTI_vec_unpacku_lo])\n-#define vec_unpacks_float_hi_optab (&optab_table[OTI_vec_unpacks_float_hi])\n-#define vec_unpacks_float_lo_optab (&optab_table[OTI_vec_unpacks_float_lo])\n-#define vec_unpacku_float_hi_optab (&optab_table[OTI_vec_unpacku_float_hi])\n-#define vec_unpacku_float_lo_optab (&optab_table[OTI_vec_unpacku_float_lo])\n-#define vec_pack_trunc_optab (&optab_table[OTI_vec_pack_trunc])\n-#define vec_pack_ssat_optab (&optab_table[OTI_vec_pack_ssat])\n-#define vec_pack_usat_optab (&optab_table[OTI_vec_pack_usat])\n-#define vec_pack_sfix_trunc_optab (&optab_table[OTI_vec_pack_sfix_trunc])\n-#define vec_pack_ufix_trunc_optab (&optab_table[OTI_vec_pack_ufix_trunc])\n-\n-#define powi_optab (&optab_table[OTI_powi])\n-\n-#define sync_compare_and_swap_optab \\\n-  (&optab_table[(int) OTI_sync_compare_and_swap])\n-#define sync_lock_test_and_set_optab \\\n-  (&optab_table[(int) OTI_sync_lock_test_and_set])\n-#define sync_old_add_optab (&optab_table[(int) OTI_sync_old_add])\n-#define sync_old_sub_optab (&optab_table[(int) OTI_sync_old_sub])\n-#define sync_old_ior_optab (&optab_table[(int) OTI_sync_old_ior])\n-#define sync_old_and_optab (&optab_table[(int) OTI_sync_old_and])\n-#define sync_old_xor_optab (&optab_table[(int) OTI_sync_old_xor])\n-#define sync_old_nand_optab (&optab_table[(int) OTI_sync_old_nand])\n-#define sync_new_add_optab (&optab_table[(int) OTI_sync_new_add])\n-#define sync_new_sub_optab (&optab_table[(int) OTI_sync_new_sub])\n-#define sync_new_ior_optab (&optab_table[(int) OTI_sync_new_ior])\n-#define sync_new_and_optab (&optab_table[(int) OTI_sync_new_and])\n-#define sync_new_xor_optab (&optab_table[(int) OTI_sync_new_xor])\n-#define sync_new_nand_optab (&optab_table[(int) OTI_sync_new_nand])\n-\n-/* Conversion optabs have their own table and indexes.  */\n-enum convert_optab_index\n-{\n-  COI_sext,\n-  COI_zext,\n-  COI_trunc,\n-\n-  COI_sfix,\n-  COI_ufix,\n-\n-  COI_sfixtrunc,\n-  COI_ufixtrunc,\n-\n-  COI_sfloat,\n-  COI_ufloat,\n-\n-  COI_lrint,\n-  COI_lround,\n-  COI_lfloor,\n-  COI_lceil,\n-\n-  COI_fract,\n-  COI_fractuns,\n-  COI_satfract,\n-  COI_satfractuns,\n-\n-  COI_vec_load_lanes,\n-  COI_vec_store_lanes,\n-\n-  /* Vector conditional operations.  */\n-  COI_vcond,\n-  COI_vcondu,\n-\n-  COI_MAX\n-};\n-\n-#define sext_optab (&convert_optab_table[COI_sext])\n-#define zext_optab (&convert_optab_table[COI_zext])\n-#define trunc_optab (&convert_optab_table[COI_trunc])\n-#define sfix_optab (&convert_optab_table[COI_sfix])\n-#define ufix_optab (&convert_optab_table[COI_ufix])\n-#define sfixtrunc_optab (&convert_optab_table[COI_sfixtrunc])\n-#define ufixtrunc_optab (&convert_optab_table[COI_ufixtrunc])\n-#define sfloat_optab (&convert_optab_table[COI_sfloat])\n-#define ufloat_optab (&convert_optab_table[COI_ufloat])\n-#define lrint_optab (&convert_optab_table[COI_lrint])\n-#define lround_optab (&convert_optab_table[COI_lround])\n-#define lfloor_optab (&convert_optab_table[COI_lfloor])\n-#define lceil_optab (&convert_optab_table[COI_lceil])\n-#define fract_optab (&convert_optab_table[COI_fract])\n-#define fractuns_optab (&convert_optab_table[COI_fractuns])\n-#define satfract_optab (&convert_optab_table[COI_satfract])\n-#define satfractuns_optab (&convert_optab_table[COI_satfractuns])\n-#define vec_load_lanes_optab (&convert_optab_table[COI_vec_load_lanes])\n-#define vec_store_lanes_optab (&convert_optab_table[COI_vec_store_lanes])\n-#define vcond_optab (&convert_optab_table[(int) COI_vcond])\n-#define vcondu_optab (&convert_optab_table[(int) COI_vcondu])\n-\n-/* Contains the optab used for each rtx code.  */\n-extern optab code_to_optab_[NUM_RTX_CODE + 1];\n+/* Contains the optab used for each rtx code, and vice-versa.  */\n+extern const optab code_to_optab_[NUM_RTX_CODE];\n+extern const enum rtx_code optab_to_code_[NUM_OPTABS];\n \n static inline optab\n code_to_optab (enum rtx_code code)\n {\n   return code_to_optab_[code];\n }\n \n-#define optab_to_code(op)\t((op)->code_)\n-\n-\f\n-typedef rtx (*rtxfun) (rtx);\n-\n-/* Enumerates operations that have a named .md pattern associated\n-   with them, but which are not implemented as library functions.  */\n-enum direct_optab_index\n+static inline enum rtx_code\n+optab_to_code (optab op)\n {\n-#ifdef HAVE_conditional_move\n-  /* Conditional move operations.  */\n-  DOI_movcc,\n-#endif\n+  return optab_to_code_[op];\n+}\n \n-  /* Operations that use a scratch register to perform input and output\n-     reloads of special objects.  */\n-  DOI_reload_in,\n-  DOI_reload_out,\n-\n-  /* Block move operation.  */\n-  DOI_movmem,\n-\n-  /* Block set operation.  */\n-  DOI_setmem,\n-\n-  /* Various types of block compare operation.  */\n-  DOI_cmpstr,\n-  DOI_cmpstrn,\n-  DOI_cmpmem,\n-\n-  /* Atomic clear with release semantics.  */\n-  DOI_sync_lock_release,\n-\n-  /* Atomic operation with no resulting value.  */\n-  DOI_sync_add,\n-  DOI_sync_sub,\n-  DOI_sync_ior,\n-  DOI_sync_and,\n-  DOI_sync_xor,\n-  DOI_sync_nand,\n-\n-  /* Atomic operations with memory model parameters. */\n-  DOI_atomic_exchange,\n-  DOI_atomic_compare_and_swap,\n-  DOI_atomic_load,\n-  DOI_atomic_store,\n-  DOI_atomic_add_fetch,\n-  DOI_atomic_sub_fetch,\n-  DOI_atomic_and_fetch,\n-  DOI_atomic_nand_fetch,\n-  DOI_atomic_xor_fetch,\n-  DOI_atomic_or_fetch,\n-  DOI_atomic_fetch_add,\n-  DOI_atomic_fetch_sub,\n-  DOI_atomic_fetch_and,\n-  DOI_atomic_fetch_nand,\n-  DOI_atomic_fetch_xor,\n-  DOI_atomic_fetch_or,\n-  DOI_atomic_add,\n-  DOI_atomic_sub,\n-  DOI_atomic_and,\n-  DOI_atomic_nand,\n-  DOI_atomic_xor,\n-  DOI_atomic_or,\n-  DOI_atomic_always_lock_free,\n-  DOI_atomic_is_lock_free,\n-  DOI_atomic_thread_fence,\n-  DOI_atomic_signal_fence,\n-\n-  /* Vector permutation.  */\n-  DOI_vec_perm,\n-  DOI_vec_perm_const,\n-\n-  DOI_MAX\n-};\n+extern const struct convert_optab_libcall_d convlib_def[NUM_CONVLIB_OPTABS];\n+extern const struct optab_libcall_d normlib_def[NUM_NORMLIB_OPTABS];\n \n-/* A structure that says which insn should be used to perform an operation\n-   in a particular mode.  */\n-struct direct_optab_d\n-{\n-  struct optab_handlers handlers[NUM_MACHINE_MODES];\n-};\n-typedef struct direct_optab_d *direct_optab;\n+/* Returns the active icode for the given (encoded) optab.  */\n+extern enum insn_code raw_optab_handler (unsigned);\n+extern bool swap_optab_enable (optab, enum machine_mode, bool);\n \n-#ifdef HAVE_conditional_move\n-#define movcc_optab (&direct_optab_table[(int) DOI_movcc])\n-#endif\n-#define reload_in_optab (&direct_optab_table[(int) DOI_reload_in])\n-#define reload_out_optab (&direct_optab_table[(int) DOI_reload_out])\n-#define movmem_optab (&direct_optab_table[(int) DOI_movmem])\n-#define setmem_optab (&direct_optab_table[(int) DOI_setmem])\n-#define cmpstr_optab (&direct_optab_table[(int) DOI_cmpstr])\n-#define cmpstrn_optab (&direct_optab_table[(int) DOI_cmpstrn])\n-#define cmpmem_optab (&direct_optab_table[(int) DOI_cmpmem])\n-#define sync_lock_release_optab \\\n-  (&direct_optab_table[(int) DOI_sync_lock_release])\n-#define sync_add_optab (&direct_optab_table[(int) DOI_sync_add])\n-#define sync_sub_optab (&direct_optab_table[(int) DOI_sync_sub])\n-#define sync_ior_optab (&direct_optab_table[(int) DOI_sync_ior])\n-#define sync_and_optab (&direct_optab_table[(int) DOI_sync_and])\n-#define sync_xor_optab (&direct_optab_table[(int) DOI_sync_xor])\n-#define sync_nand_optab (&direct_optab_table[(int) DOI_sync_nand])\n-\n-#define atomic_exchange_optab \\\n-  (&direct_optab_table[(int) DOI_atomic_exchange])\n-#define atomic_compare_and_swap_optab \\\n-  (&direct_optab_table[(int) DOI_atomic_compare_and_swap])\n-#define atomic_load_optab \\\n-  (&direct_optab_table[(int) DOI_atomic_load])\n-#define atomic_store_optab \\\n-  (&direct_optab_table[(int) DOI_atomic_store])\n-#define atomic_add_fetch_optab \\\n-  (&direct_optab_table[(int) DOI_atomic_add_fetch])\n-#define atomic_sub_fetch_optab \\\n-  (&direct_optab_table[(int) DOI_atomic_sub_fetch])\n-#define atomic_and_fetch_optab \\\n-  (&direct_optab_table[(int) DOI_atomic_and_fetch])\n-#define atomic_nand_fetch_optab \\\n-  (&direct_optab_table[(int) DOI_atomic_nand_fetch])\n-#define atomic_xor_fetch_optab \\\n-  (&direct_optab_table[(int) DOI_atomic_xor_fetch])\n-#define atomic_or_fetch_optab \\\n-  (&direct_optab_table[(int) DOI_atomic_or_fetch])\n-#define atomic_fetch_add_optab \\\n-  (&direct_optab_table[(int) DOI_atomic_fetch_add])\n-#define atomic_fetch_sub_optab \\\n-  (&direct_optab_table[(int) DOI_atomic_fetch_sub])\n-#define atomic_fetch_and_optab \\\n-  (&direct_optab_table[(int) DOI_atomic_fetch_and])\n-#define atomic_fetch_nand_optab \\\n-  (&direct_optab_table[(int) DOI_atomic_fetch_nand])\n-#define atomic_fetch_xor_optab \\\n-  (&direct_optab_table[(int) DOI_atomic_fetch_xor])\n-#define atomic_fetch_or_optab \\\n-  (&direct_optab_table[(int) DOI_atomic_fetch_or])\n-#define atomic_add_optab \\\n-  (&direct_optab_table[(int) DOI_atomic_add])\n-#define atomic_sub_optab \\\n-  (&direct_optab_table[(int) DOI_atomic_sub])\n-#define atomic_and_optab \\\n-  (&direct_optab_table[(int) DOI_atomic_and])\n-#define atomic_nand_optab \\\n-  (&direct_optab_table[(int) DOI_atomic_nand])\n-#define atomic_xor_optab \\\n-  (&direct_optab_table[(int) DOI_atomic_xor])\n-#define atomic_or_optab \\\n-  (&direct_optab_table[(int) DOI_atomic_or])\n-#define atomic_always_lock_free_optab \\\n-  (&direct_optab_table[(int) DOI_atomic_always_lock_free])\n-#define atomic_is_lock_free_optab \\\n-  (&direct_optab_table[(int) DOI_atomic_is_lock_free])\n-#define atomic_thread_fence_optab \\\n-  (&direct_optab_table[(int) DOI_atomic_thread_fence])\n-#define atomic_signal_fence_optab \\\n-  (&direct_optab_table[(int) DOI_atomic_signal_fence])\n-\n-#define vec_perm_optab (&direct_optab_table[DOI_vec_perm])\n-#define vec_perm_const_optab (&direct_optab_table[(int) DOI_vec_perm_const])\n-\f\n /* Target-dependent globals.  */\n struct target_optabs {\n-  /* Tables of patterns that may have an associated libcall.  */\n-  struct optab_d x_optab_table[(int) OTI_MAX];\n-\n-  /* Tables of patterns for converting one mode to another.  */\n-  struct convert_optab_d x_convert_optab_table[(int) COI_MAX];\n-\n-  /* Tables of patterns for direct optabs (i.e. those which cannot be\n-     implemented using a libcall).  */\n-  struct direct_optab_d x_direct_optab_table[(int) DOI_MAX];\n+  /* Patterns that are used by optabs that are enabled for this target.  */\n+  bool pat_enable[NUM_OPTAB_PATTERNS];\n };\n \n extern struct target_optabs default_target_optabs;\n@@ -857,13 +82,6 @@ extern struct target_optabs *this_target_optabs;\n #else\n #define this_target_optabs (&default_target_optabs)\n #endif\n-\n-#define optab_table \\\n-  (this_target_optabs->x_optab_table)\n-#define convert_optab_table \\\n-  (this_target_optabs->x_convert_optab_table)\n-#define direct_optab_table \\\n-  (this_target_optabs->x_direct_optab_table)\n \f\n /* Define functions given in optabs.c.  */\n \n@@ -1036,49 +254,9 @@ extern rtx expand_mult_highpart (enum machine_mode, rtx, rtx, rtx, bool);\n static inline enum insn_code\n optab_handler (optab op, enum machine_mode mode)\n {\n-  return op->handlers[(int) mode].insn_code;\n-}\n-\n-/* Like optab_handler, but for widening_operations that have a TO_MODE and\n-  a FROM_MODE.  */\n-\n-static inline enum insn_code\n-widening_optab_handler (optab op, enum machine_mode to_mode,\n-\t\t\tenum machine_mode from_mode)\n-{\n-  if (to_mode == from_mode || from_mode == VOIDmode)\n-    return optab_handler (op, to_mode);\n-\n-  if (op->widening)\n-    return op->widening->handlers[(int) to_mode][(int) from_mode].insn_code;\n-\n-  return CODE_FOR_nothing;\n-}\n-\n-/* Record that insn CODE should be used to implement mode MODE of OP.  */\n-\n-static inline void\n-set_optab_handler (optab op, enum machine_mode mode, enum insn_code code)\n-{\n-  op->handlers[(int) mode].insn_code = code;\n-}\n-\n-/* Like set_optab_handler, but for widening operations that have a TO_MODE\n-   and a FROM_MODE.  */\n-\n-static inline void\n-set_widening_optab_handler (optab op, enum machine_mode to_mode,\n-\t\t\t    enum machine_mode from_mode, enum insn_code code)\n-{\n-  if (to_mode == from_mode)\n-    set_optab_handler (op, to_mode, code);\n-  else\n-    {\n-      if (op->widening == NULL)\n-\top->widening = XCNEW (struct widening_optab_handlers);\n-\n-      op->widening->handlers[(int) to_mode][(int) from_mode].insn_code = code;\n-    }\n+  unsigned scode = (op << 16) | mode;\n+  gcc_assert (op > LAST_CONV_OPTAB);\n+  return raw_optab_handler (scode);\n }\n \n /* Return the insn used to perform conversion OP from mode FROM_MODE\n@@ -1089,17 +267,28 @@ static inline enum insn_code\n convert_optab_handler (convert_optab op, enum machine_mode to_mode,\n \t\t       enum machine_mode from_mode)\n {\n-  return op->handlers[(int) to_mode][(int) from_mode].insn_code;\n+  unsigned scode = (op << 16) | (from_mode << 8) | to_mode;\n+  gcc_assert (op > unknown_optab && op <= LAST_CONV_OPTAB);\n+  return raw_optab_handler (scode);\n }\n \n-/* Record that insn CODE should be used to perform conversion OP\n-   from mode FROM_MODE to mode TO_MODE.  */\n+/* Like optab_handler, but for widening_operations that have a\n+   TO_MODE and a FROM_MODE.  */\n \n-static inline void\n-set_convert_optab_handler (convert_optab op, enum machine_mode to_mode,\n-\t\t\t   enum machine_mode from_mode, enum insn_code code)\n+static inline enum insn_code\n+widening_optab_handler (optab op, enum machine_mode to_mode,\n+\t\t\tenum machine_mode from_mode)\n {\n-  op->handlers[(int) to_mode][(int) from_mode].insn_code = code;\n+  unsigned scode = (op << 16) | to_mode;\n+  if (to_mode != from_mode && from_mode != VOIDmode)\n+    {\n+      /* ??? Why does find_widening_optab_handler_and_mode attempt to\n+\t widen things that can't be widened?  E.g. add_optab... */\n+      if (op > LAST_CONV_OPTAB)\n+\treturn CODE_FOR_nothing;\n+      scode |= from_mode << 8;\n+    }\n+  return raw_optab_handler (scode);\n }\n \n /* Return the insn used to implement mode MODE of OP, or CODE_FOR_nothing\n@@ -1108,16 +297,7 @@ set_convert_optab_handler (convert_optab op, enum machine_mode to_mode,\n static inline enum insn_code\n direct_optab_handler (direct_optab op, enum machine_mode mode)\n {\n-  return op->handlers[(int) mode].insn_code;\n-}\n-\n-/* Record that insn CODE should be used to implement mode MODE of OP.  */\n-\n-static inline void\n-set_direct_optab_handler (direct_optab op, enum machine_mode mode,\n-\t\t\t  enum insn_code code)\n-{\n-  op->handlers[(int) mode].insn_code = code;\n+  return optab_handler (op, mode);\n }\n \n /* Return true if UNOPTAB is for a trapping-on-overflow operation.  */\n@@ -1292,4 +472,52 @@ extern void expand_jump_insn (enum insn_code icode, unsigned int nops,\n extern rtx prepare_operand (enum insn_code, rtx, int, enum machine_mode,\n \t\t\t    enum machine_mode, int);\n \n+extern void gen_int_libfunc (optab, const char *, char, enum machine_mode);\n+extern void gen_fp_libfunc (optab, const char *, char, enum machine_mode);\n+extern void gen_fixed_libfunc (optab, const char *, char, enum machine_mode);\n+extern void gen_signed_fixed_libfunc (optab, const char *, char,\n+\t\t\t\t      enum machine_mode);\n+extern void gen_unsigned_fixed_libfunc (optab, const char *, char,\n+\t\t\t\t\tenum machine_mode);\n+extern void gen_int_fp_libfunc (optab, const char *, char, enum machine_mode);\n+extern void gen_intv_fp_libfunc (optab, const char *, char, enum machine_mode);\n+extern void gen_int_fp_fixed_libfunc (optab, const char *, char,\n+\t\t\t\t      enum machine_mode);\n+extern void gen_int_fp_signed_fixed_libfunc (optab, const char *, char,\n+\t\t\t\t\t     enum machine_mode);\n+extern void gen_int_fixed_libfunc (optab, const char *, char,\n+\t\t\t\t   enum machine_mode);\n+extern void gen_int_signed_fixed_libfunc (optab, const char *, char,\n+\t\t\t\t\t  enum machine_mode);\n+extern void gen_int_unsigned_fixed_libfunc (optab, const char *, char,\n+\t\t\t\t\t    enum machine_mode);\n+\n+extern void gen_interclass_conv_libfunc (convert_optab, const char *,\n+\t\t\t\t\t enum machine_mode, enum machine_mode);\n+extern void gen_int_to_fp_conv_libfunc (convert_optab, const char *,\n+\t\t\t\t\tenum machine_mode, enum machine_mode);\n+extern void gen_ufloat_conv_libfunc (convert_optab, const char *,\n+\t\t\t\t     enum machine_mode, enum machine_mode);\n+extern void gen_int_to_fp_nondecimal_conv_libfunc  (convert_optab,\n+\t\t\t\t\t\t    const char *,\n+\t\t\t\t\t\t    enum machine_mode,\n+\t\t\t\t\t\t    enum machine_mode);\n+extern void gen_fp_to_int_conv_libfunc (convert_optab, const char *,\n+\t\t\t\t\tenum machine_mode, enum machine_mode);\n+extern void gen_intraclass_conv_libfunc (convert_optab, const char *,\n+\t\t\t\t\t enum machine_mode, enum machine_mode);\n+extern void gen_trunc_conv_libfunc (convert_optab, const char *,\n+\t\t\t\t    enum machine_mode, enum machine_mode);\n+extern void gen_extend_conv_libfunc (convert_optab, const char *,\n+\t\t\t\t     enum machine_mode, enum machine_mode);\n+extern void gen_fract_conv_libfunc (convert_optab, const char *,\n+\t\t\t\t    enum machine_mode, enum machine_mode);\n+extern void gen_fractuns_conv_libfunc (convert_optab, const char *,\n+\t\t\t\t       enum machine_mode, enum machine_mode);\n+extern void gen_satfract_conv_libfunc (convert_optab, const char *,\n+\t\t\t\t       enum machine_mode, enum machine_mode);\n+extern void gen_satfractuns_conv_libfunc (convert_optab, const char *,\n+\t\t\t\t\t  enum machine_mode,\n+\t\t\t\t\t  enum machine_mode);\n+\n #endif /* GCC_OPTABS_H */"}, {"sha": "f942c5903b7cb3c70fd84d0cce160e2d28d47cd4", "filename": "gcc/rtl.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd1440b199ae8476f1b6df884e86fa07388e1f80/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd1440b199ae8476f1b6df884e86fa07388e1f80/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=cd1440b199ae8476f1b6df884e86fa07388e1f80", "patch": "@@ -55,8 +55,13 @@ enum rtx_code  {\n \t\t\t\t   NUM_RTX_CODE.\n \t\t\t\t   Assumes default enum value assignment.  */\n \n+/* The cast here, saves many elsewhere.  */\n #define NUM_RTX_CODE ((int) LAST_AND_UNUSED_RTX_CODE)\n-\t\t\t\t/* The cast here, saves many elsewhere.  */\n+\n+/* Similar, but since generator files get more entries... */\n+#ifdef GENERATOR_FILE\n+# define NON_GENERATOR_NUM_RTX_CODE ((int) MATCH_OPERAND)\n+#endif\n \n /* Register Transfer Language EXPRESSIONS CODE CLASSES */\n "}]}