{"sha": "642357660ae1f36651519fb41f81a997f5fdae53", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQyMzU3NjYwYWUxZjM2NjUxNTE5ZmI0MWY4MWE5OTdmNWZkYWU1Mw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2015-11-18T21:55:11Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2015-11-18T21:55:11Z"}, "message": "ada-tree.h (DECL_INVARIANT_P): New macro.\n\n\t* gcc-interface/ada-tree.h (DECL_INVARIANT_P): New macro.\n\t* gcc-interface/gigi.h (enum standard_datatypes): Remove\n\tADT_longjmp_decl and add ADT_not_handled_by_others_decl.\n\t(longjmp_decl): Delete.\n\t(not_handled_by_others_decl): New macro.\n\t(build_simple_component_ref): Delete.\n\t(build_component_ref): Adjust prototype.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity): Adjust calls to\n\tbuild_component_ref.\n\t(gnat_to_gnu_field): Set DECL_INVARIANT_P on discriminants\n\twithout default value.\n\t* gcc-interface/trans.c (gigi): Reorder initialization sequence\n\tand add not_handled_by_others_decl.\n\t(Attribute_to_gnu): Adjust calls to build_component_ref.\n\t(Subprogram_Body_to_gnu): Likewise.\n\t(Call_to_gnu): Likewise.\n\t(Exception_Handler_to_gnu_sjlj): Likewise.\n\t(gnat_to_gnu): Likewise.\n\t(range_check_info_d): Add inserted_cond field.\n\t(Loop_Statement_to_gnu): Make two passes on the recorded range checks.\n\t(build_noreturn_cond): New static function.\n\t(Raise_Error_to_gnu): Record range checks in loops at -O1 and above.\n\t(make_invariant): New static function.\n\t(Loop_Statement_to_gnu): Use it to compute invariant expressions for\n\tthe loop bounds if possible, but do not require it if loop unswitching\n\tis enabled.\n\t* gcc-interface/utils.c (convert_to_fat_pointer): Likewise.\n\t(convert): Likewise.\n\t(maybe_unconstrained_array): Likewise.  Call it instead of\n\tbuild_simple_component_ref and add guard for CONSTRUCTORs.\n\t(unchecked_convert): Likewise.\n\t* gcc-interface/utils2.c (compare_fat_pointers): Likewise.\n\t(build_simple_component_ref): Remove COMPONENT parameter, unify\n\tcode dealing with VIEW_CONVERT_EXPR and make it more general,\n\tremove special treatment for CONSTRUCTORs of template types.\n\t(build_component_ref): Remove COMPONENT parameter and adjust call\n\tto build_simple_component_ref.\n\t(maybe_wrap_malloc): Likewise.\n\t(build_allocator): Likewise.\n\t(gnat_invariant_expr): Look through overflow checks, deal with\n\taddition and subtraction of constants and take into account\n\tDECL_INVARIANT_P for the COMPONENT_REF case.\n\nFrom-SVN: r230575", "tree": {"sha": "1b06a2606d86dae56336dcdd2fd3e60bee7c93db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b06a2606d86dae56336dcdd2fd3e60bee7c93db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/642357660ae1f36651519fb41f81a997f5fdae53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/642357660ae1f36651519fb41f81a997f5fdae53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/642357660ae1f36651519fb41f81a997f5fdae53", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/642357660ae1f36651519fb41f81a997f5fdae53/comments", "author": null, "committer": null, "parents": [{"sha": "5d306e55e09af218e1698a8e427638f717af4f3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d306e55e09af218e1698a8e427638f717af4f3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d306e55e09af218e1698a8e427638f717af4f3d"}], "stats": {"total": 835, "additions": 519, "deletions": 316}, "files": [{"sha": "9ae6c801ed0b54e3c330e1bf54600562cb1ab525", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/642357660ae1f36651519fb41f81a997f5fdae53/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/642357660ae1f36651519fb41f81a997f5fdae53/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=642357660ae1f36651519fb41f81a997f5fdae53", "patch": "@@ -1,3 +1,48 @@\n+2015-11-18  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/ada-tree.h (DECL_INVARIANT_P): New macro.\n+\t* gcc-interface/gigi.h (enum standard_datatypes): Remove\n+\tADT_longjmp_decl and add ADT_not_handled_by_others_decl.\n+\t(longjmp_decl): Delete.\n+\t(not_handled_by_others_decl): New macro.\n+\t(build_simple_component_ref): Delete.\n+\t(build_component_ref): Adjust prototype.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity): Adjust calls to\n+\tbuild_component_ref.\n+\t(gnat_to_gnu_field): Set DECL_INVARIANT_P on discriminants\n+\twithout default value.\n+\t* gcc-interface/trans.c (gigi): Reorder initialization sequence\n+\tand add not_handled_by_others_decl.\n+\t(Attribute_to_gnu): Adjust calls to build_component_ref.\n+\t(Subprogram_Body_to_gnu): Likewise.\n+\t(Call_to_gnu): Likewise.\n+\t(Exception_Handler_to_gnu_sjlj): Likewise.\n+\t(gnat_to_gnu): Likewise.\n+\t(range_check_info_d): Add inserted_cond field.\n+\t(Loop_Statement_to_gnu): Make two passes on the recorded range checks.\n+\t(build_noreturn_cond): New static function.\n+\t(Raise_Error_to_gnu): Record range checks in loops at -O1 and above.\n+\t(make_invariant): New static function.\n+\t(Loop_Statement_to_gnu): Use it to compute invariant expressions for\n+\tthe loop bounds if possible, but do not require it if loop unswitching\n+\tis enabled.\n+\t* gcc-interface/utils.c (convert_to_fat_pointer): Likewise.\n+\t(convert): Likewise.\n+\t(maybe_unconstrained_array): Likewise.  Call it instead of\n+\tbuild_simple_component_ref and add guard for CONSTRUCTORs.\n+\t(unchecked_convert): Likewise.\n+\t* gcc-interface/utils2.c (compare_fat_pointers): Likewise.\n+\t(build_simple_component_ref): Remove COMPONENT parameter, unify\n+\tcode dealing with VIEW_CONVERT_EXPR and make it more general,\n+\tremove special treatment for CONSTRUCTORs of template types.\n+\t(build_component_ref): Remove COMPONENT parameter and adjust call\n+\tto build_simple_component_ref.\n+\t(maybe_wrap_malloc): Likewise.\n+\t(build_allocator): Likewise.\n+\t(gnat_invariant_expr): Look through overflow checks, deal with\n+\taddition and subtraction of constants and take into account\n+\tDECL_INVARIANT_P for the COMPONENT_REF case.\n+\n 2015-11-18  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/misc.c: Move global variables to the top of the file."}, {"sha": "4e368f00dad90e49fd4f605558b77a972a34510c", "filename": "gcc/ada/gcc-interface/ada-tree.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/642357660ae1f36651519fb41f81a997f5fdae53/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/642357660ae1f36651519fb41f81a997f5fdae53/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.h?ref=642357660ae1f36651519fb41f81a997f5fdae53", "patch": "@@ -405,10 +405,14 @@ do {\t\t\t\t\t\t   \\\n #define DECL_ELABORATION_PROC_P(NODE) \\\n   DECL_LANG_FLAG_3 (FUNCTION_DECL_CHECK (NODE))\n \n-/* Nonzero in a DECL if it is made for a pointer that points to something which\n-   is readonly.  */\n+/* Nonzero in a CONST_DECL, VAR_DECL or PARM_DECL if it is made for a pointer\n+   that points to something which is readonly.  */\n #define DECL_POINTS_TO_READONLY_P(NODE) DECL_LANG_FLAG_4 (NODE)\n \n+/* Nonzero in a FIELD_DECL if it is invariant once set, for example if it is\n+   a discriminant of a discriminated type without default expression.  */\n+#define DECL_INVARIANT_P(NODE) DECL_LANG_FLAG_4 (FIELD_DECL_CHECK (NODE))\n+\n /* In a FIELD_DECL corresponding to a discriminant, contains the\n    discriminant number.  */\n #define DECL_DISCRIMINANT_NUMBER(NODE) DECL_INITIAL (FIELD_DECL_CHECK (NODE))"}, {"sha": "75e9e33b13ebec22f35a34a392543f5f23ead109", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/642357660ae1f36651519fb41f81a997f5fdae53/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/642357660ae1f36651519fb41f81a997f5fdae53/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=642357660ae1f36651519fb41f81a997f5fdae53", "patch": "@@ -1291,7 +1291,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t    else\n \t\t      gnu_expr\n \t\t\t= build_component_ref\n-\t\t\t    (gnu_expr, NULL_TREE,\n+\t\t\t    (gnu_expr,\n \t\t\t     DECL_CHAIN (TYPE_FIELDS (TREE_TYPE (gnu_expr))),\n \t\t\t     false);\n \t\t  }\n@@ -1335,8 +1335,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      add_stmt_with_node\n \t\t(build_binary_op (INIT_EXPR, NULL_TREE,\n \t\t\t\t  build_component_ref\n-\t\t\t\t  (gnu_new_var, NULL_TREE,\n-\t\t\t\t   TYPE_FIELDS (gnu_new_type), false),\n+\t\t\t\t  (gnu_new_var, TYPE_FIELDS (gnu_new_type),\n+\t\t\t\t   false),\n \t\t\t\t  gnu_expr),\n \t\t gnat_entity);\n \n@@ -1345,8 +1345,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    gnu_expr\n \t      = build_unary_op\n \t\t(ADDR_EXPR, NULL_TREE,\n-\t\t build_component_ref (gnu_new_var, NULL_TREE,\n-\t\t\t\t      TYPE_FIELDS (gnu_new_type), false));\n+\t\t build_component_ref (gnu_new_var, TYPE_FIELDS (gnu_new_type),\n+\t\t\t\t      false));\n \t    TREE_CONSTANT (gnu_expr) = 1;\n \n \t    used_by_ref = true;\n@@ -6778,8 +6778,12 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n   TREE_THIS_VOLATILE (gnu_field) = TREE_SIDE_EFFECTS (gnu_field) = is_volatile;\n \n   if (Ekind (gnat_field) == E_Discriminant)\n-    DECL_DISCRIMINANT_NUMBER (gnu_field)\n-      = UI_To_gnu (Discriminant_Number (gnat_field), sizetype);\n+    {\n+      DECL_INVARIANT_P (gnu_field)\n+\t= No (Discriminant_Default_Value (gnat_field));\n+      DECL_DISCRIMINANT_NUMBER (gnu_field)\n+\t= UI_To_gnu (Discriminant_Number (gnat_field), sizetype);\n+    }\n \n   return gnu_field;\n }"}, {"sha": "46ec42e4fd833db20ac3c55c995e5dce6fce2a6b", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/642357660ae1f36651519fb41f81a997f5fdae53/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/642357660ae1f36651519fb41f81a997f5fdae53/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=642357660ae1f36651519fb41f81a997f5fdae53", "patch": "@@ -408,17 +408,18 @@ enum standard_datatypes\n   /* Identifier for the name of the Exception_Data type.  */\n   ADT_exception_data_name_id,\n \n-  /* Types and decls used by our temporary exception mechanism.  See\n-     init_gigi_decls for details.  */\n+  /* Types and decls used by the SJLJ exception mechanism.  */\n   ADT_jmpbuf_type,\n   ADT_jmpbuf_ptr_type,\n   ADT_get_jmpbuf_decl,\n   ADT_set_jmpbuf_decl,\n   ADT_get_excptr_decl,\n+  ADT_not_handled_by_others_decl,\n   ADT_setjmp_decl,\n-  ADT_longjmp_decl,\n   ADT_update_setjmp_buf_decl,\n   ADT_raise_nodefer_decl,\n+\n+  /* Types and decls used by the ZCX exception mechanism.  */\n   ADT_reraise_zcx_decl,\n   ADT_set_exception_parameter_decl,\n   ADT_begin_handler_decl,\n@@ -427,6 +428,7 @@ enum standard_datatypes\n   ADT_others_decl,\n   ADT_all_others_decl,\n   ADT_unhandled_others_decl,\n+\n   ADT_LAST};\n \n /* Define kind of exception information associated with raise statements.  */\n@@ -475,13 +477,14 @@ extern GTY(()) tree gnat_raise_decls_ext[(int) LAST_REASON_CODE + 1];\n #define get_jmpbuf_decl gnat_std_decls[(int) ADT_get_jmpbuf_decl]\n #define set_jmpbuf_decl gnat_std_decls[(int) ADT_set_jmpbuf_decl]\n #define get_excptr_decl gnat_std_decls[(int) ADT_get_excptr_decl]\n+#define not_handled_by_others_decl \\\n+\t  gnat_std_decls[(int) ADT_not_handled_by_others_decl]\n #define setjmp_decl gnat_std_decls[(int) ADT_setjmp_decl]\n-#define longjmp_decl gnat_std_decls[(int) ADT_longjmp_decl]\n #define update_setjmp_buf_decl gnat_std_decls[(int) ADT_update_setjmp_buf_decl]\n #define raise_nodefer_decl gnat_std_decls[(int) ADT_raise_nodefer_decl]\n #define reraise_zcx_decl gnat_std_decls[(int) ADT_reraise_zcx_decl]\n #define set_exception_parameter_decl \\\n-          gnat_std_decls[(int) ADT_set_exception_parameter_decl]\n+\t  gnat_std_decls[(int) ADT_set_exception_parameter_decl]\n #define begin_handler_decl gnat_std_decls[(int) ADT_begin_handler_decl]\n #define others_decl gnat_std_decls[(int) ADT_others_decl]\n #define all_others_decl gnat_std_decls[(int) ADT_all_others_decl]\n@@ -896,16 +899,10 @@ extern tree build_call_raise_range (int msg, Node_Id gnat_node,\n    same as build_constructor in the language-independent tree.c.  */\n extern tree gnat_build_constructor (tree type, vec<constructor_elt, va_gc> *v);\n \n-/* Return a COMPONENT_REF to access a field that is given by COMPONENT,\n-   an IDENTIFIER_NODE giving the name of the field, FIELD, a FIELD_DECL,\n-   for the field, or both.  Don't fold the result if NO_FOLD_P.  */\n-extern tree build_simple_component_ref (tree record_variable, tree component,\n-\t\t\t\t\ttree field, bool no_fold_p);\n-\n-/* Likewise, but generate a Constraint_Error if the reference could not be\n-   found.  */\n-extern tree build_component_ref (tree record_variable, tree component,\n-                                 tree field, bool no_fold_p);\n+/* Return a COMPONENT_REF to access FIELD in RECORD, or NULL_EXPR and generate\n+   a Constraint_Error if the field is not found in the record.  Don't fold the\n+   result if NO_FOLD is true.  */\n+extern tree build_component_ref (tree record, tree field, bool no_fold);\n \n /* Build a GCC tree to call an allocation or deallocation function.\n    If GNU_OBJ is nonzero, it is an object to deallocate.  Otherwise,"}, {"sha": "5f2c1dcddcc6b6bbec663c2e11f492500efe87f7", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 217, "deletions": 136, "changes": 353, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/642357660ae1f36651519fb41f81a997f5fdae53/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/642357660ae1f36651519fb41f81a997f5fdae53/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=642357660ae1f36651519fb41f81a997f5fdae53", "patch": "@@ -33,6 +33,7 @@\n #include \"gimple-expr.h\"\n #include \"stringpool.h\"\n #include \"cgraph.h\"\n+#include \"predict.h\"\n #include \"diagnostic.h\"\n #include \"alias.h\"\n #include \"fold-const.h\"\n@@ -181,6 +182,7 @@ struct GTY(()) range_check_info_d {\n   tree high_bound;\n   tree type;\n   tree invariant_cond;\n+  tree inserted_cond;\n };\n \n typedef struct range_check_info_d *range_check_info;\n@@ -423,6 +425,8 @@ gigi (Node_Id gnat_root,\n     = get_identifier (\"system__standard_library__exception_data\");\n \n   /* Make the types and functions used for exception processing.  */\n+  except_type_node = gnat_to_gnu_type (Base_Type (standard_exception_type));\n+\n   jmpbuf_type\n     = build_array_type (gnat_type_for_mode (Pmode, 0),\n \t\t\tbuild_index_type (size_int (5)));\n@@ -443,6 +447,22 @@ gigi (Node_Id gnat_root,\n \t\t\t\t\t    NULL_TREE),\n        NULL_TREE, is_disabled, true, true, true, false, NULL, Empty);\n \n+  get_excptr_decl\n+    = create_subprog_decl\n+      (get_identifier (\"system__soft_links__get_gnat_exception\"), NULL_TREE,\n+       build_function_type_list (build_pointer_type (except_type_node),\n+\t\t\t\t NULL_TREE),\n+       NULL_TREE, is_disabled, true, true, true, false, NULL, Empty);\n+\n+  not_handled_by_others_decl = get_identifier (\"not_handled_by_others\");\n+  for (t = TYPE_FIELDS (except_type_node); t; t = DECL_CHAIN (t))\n+    if (DECL_NAME (t) == not_handled_by_others_decl)\n+      {\n+\tnot_handled_by_others_decl = t;\n+\tbreak;\n+      }\n+  gcc_assert (DECL_P (not_handled_by_others_decl));\n+\n   /* setjmp returns an integer and has one operand, which is a pointer to\n      a jmpbuf.  */\n   setjmp_decl\n@@ -464,6 +484,39 @@ gigi (Node_Id gnat_root,\n   DECL_BUILT_IN_CLASS (update_setjmp_buf_decl) = BUILT_IN_NORMAL;\n   DECL_FUNCTION_CODE (update_setjmp_buf_decl) = BUILT_IN_UPDATE_SETJMP_BUF;\n \n+  raise_nodefer_decl\n+    = create_subprog_decl\n+      (get_identifier (\"__gnat_raise_nodefer_with_msg\"), NULL_TREE,\n+       build_function_type_list (void_type_node,\n+\t\t\t\t build_pointer_type (except_type_node),\n+\t\t\t\t NULL_TREE),\n+       NULL_TREE, is_disabled, true, true, true, false, NULL, Empty);\n+\n+  /* Indicate that it never returns.  */\n+  TREE_THIS_VOLATILE (raise_nodefer_decl) = 1;\n+  TREE_SIDE_EFFECTS (raise_nodefer_decl) = 1;\n+  TREE_TYPE (raise_nodefer_decl)\n+    = build_qualified_type (TREE_TYPE (raise_nodefer_decl),\n+\t\t\t    TYPE_QUAL_VOLATILE);\n+\n+  reraise_zcx_decl\n+    = create_subprog_decl (get_identifier (\"__gnat_reraise_zcx\"), NULL_TREE,\n+\t\t\t   ftype, NULL_TREE,\n+\t\t\t   is_disabled, true, true, true, false,\n+\t\t\t   NULL, Empty);\n+  /* Indicate that these never return.  */\n+  TREE_THIS_VOLATILE (reraise_zcx_decl) = 1;\n+  TREE_SIDE_EFFECTS (reraise_zcx_decl) = 1;\n+  TREE_TYPE (reraise_zcx_decl)\n+    = build_qualified_type (TREE_TYPE (reraise_zcx_decl), TYPE_QUAL_VOLATILE);\n+\n+  set_exception_parameter_decl\n+    = create_subprog_decl\n+      (get_identifier (\"__gnat_set_exception_parameter\"), NULL_TREE,\n+       build_function_type_list (void_type_node, ptr_type_node, ptr_type_node,\n+\t\t\t\t NULL_TREE),\n+       NULL_TREE, is_disabled, true, true, true, false, NULL, Empty);\n+\n   /* Hooks to call when entering/leaving an exception handler.  */\n   ftype = build_function_type_list (void_type_node, ptr_type_node, NULL_TREE);\n \n@@ -485,16 +538,29 @@ gigi (Node_Id gnat_root,\n \t\t\t   is_disabled, true, true, true, false,\n \t\t\t   NULL, Empty);\n \n-  reraise_zcx_decl\n-    = create_subprog_decl (get_identifier (\"__gnat_reraise_zcx\"), NULL_TREE,\n-\t\t\t   ftype, NULL_TREE,\n-\t\t\t   is_disabled, true, true, true, false,\n-\t\t\t   NULL, Empty);\n-  /* Indicate that these never return.  */\n-  TREE_THIS_VOLATILE (reraise_zcx_decl) = 1;\n-  TREE_SIDE_EFFECTS (reraise_zcx_decl) = 1;\n-  TREE_TYPE (reraise_zcx_decl)\n-    = build_qualified_type (TREE_TYPE (reraise_zcx_decl), TYPE_QUAL_VOLATILE);\n+  /* Dummy objects to materialize \"others\" and \"all others\" in the exception\n+     tables.  These are exported by a-exexpr-gcc.adb, so see this unit for\n+     the types to use.  */\n+  others_decl\n+    = create_var_decl (get_identifier (\"OTHERS\"),\n+\t\t       get_identifier (\"__gnat_others_value\"),\n+\t\t       unsigned_char_type_node, NULL_TREE,\n+\t\t       true, false, true, false, true, false,\n+\t\t       NULL, Empty);\n+\n+  all_others_decl\n+    = create_var_decl (get_identifier (\"ALL_OTHERS\"),\n+\t\t       get_identifier (\"__gnat_all_others_value\"),\n+\t\t       unsigned_char_type_node, NULL_TREE,\n+\t\t       true, false, true, false, true, false,\n+\t\t       NULL, Empty);\n+\n+  unhandled_others_decl\n+    = create_var_decl (get_identifier (\"UNHANDLED_OTHERS\"),\n+\t\t       get_identifier (\"__gnat_unhandled_others_value\"),\n+\t\t       unsigned_char_type_node, NULL_TREE,\n+\t\t       true, false, true, false, true, false,\n+\t\t       NULL, Empty);\n \n   /* If in no exception handlers mode, all raise statements are redirected to\n      __gnat_last_chance_handler.  No need to redefine raise_nodefer_decl since\n@@ -530,39 +596,6 @@ gigi (Node_Id gnat_root,\n \t\t\t       ? exception_range : exception_column);\n     }\n \n-  /* Set the types that GCC and Gigi use from the front end.  */\n-  except_type_node = gnat_to_gnu_type (Base_Type (standard_exception_type));\n-\n-  /* Make other functions used for exception processing.  */\n-  get_excptr_decl\n-    = create_subprog_decl\n-      (get_identifier (\"system__soft_links__get_gnat_exception\"), NULL_TREE,\n-       build_function_type_list (build_pointer_type (except_type_node),\n-\t\t\t\t NULL_TREE),\n-     NULL_TREE, is_disabled, true, true, true, false, NULL, Empty);\n-\n-  set_exception_parameter_decl\n-    = create_subprog_decl\n-      (get_identifier (\"__gnat_set_exception_parameter\"), NULL_TREE,\n-       build_function_type_list (void_type_node, ptr_type_node, ptr_type_node,\n-\t\t\t\t NULL_TREE),\n-       NULL_TREE, is_disabled, true, true, true, false, NULL, Empty);\n-\n-  raise_nodefer_decl\n-    = create_subprog_decl\n-      (get_identifier (\"__gnat_raise_nodefer_with_msg\"), NULL_TREE,\n-       build_function_type_list (void_type_node,\n-\t\t\t\t build_pointer_type (except_type_node),\n-\t\t\t\t NULL_TREE),\n-       NULL_TREE, is_disabled, true, true, true, false, NULL, Empty);\n-\n-  /* Indicate that it never returns.  */\n-  TREE_THIS_VOLATILE (raise_nodefer_decl) = 1;\n-  TREE_SIDE_EFFECTS (raise_nodefer_decl) = 1;\n-  TREE_TYPE (raise_nodefer_decl)\n-    = build_qualified_type (TREE_TYPE (raise_nodefer_decl),\n-\t\t\t    TYPE_QUAL_VOLATILE);\n-\n   /* Build the special descriptor type and its null node if needed.  */\n   if (TARGET_VTABLE_USES_DESCRIPTORS)\n     {\n@@ -596,30 +629,6 @@ gigi (Node_Id gnat_root,\n   longest_float_type_node\n     = get_unpadded_type (Base_Type (standard_long_long_float));\n \n-  /* Dummy objects to materialize \"others\" and \"all others\" in the exception\n-     tables.  These are exported by a-exexpr-gcc.adb, so see this unit for\n-     the types to use.  */\n-  others_decl\n-    = create_var_decl (get_identifier (\"OTHERS\"),\n-\t\t       get_identifier (\"__gnat_others_value\"),\n-\t\t       unsigned_char_type_node, NULL_TREE,\n-\t\t       true, false, true, false, true, false,\n-\t\t       NULL, Empty);\n-\n-  all_others_decl\n-    = create_var_decl (get_identifier (\"ALL_OTHERS\"),\n-\t\t       get_identifier (\"__gnat_all_others_value\"),\n-\t\t       unsigned_char_type_node, NULL_TREE,\n-\t\t       true, false, true, false, true, false,\n-\t\t       NULL, Empty);\n-\n-  unhandled_others_decl\n-    = create_var_decl (get_identifier (\"UNHANDLED_OTHERS\"),\n-\t\t       get_identifier (\"__gnat_unhandled_others_value\"),\n-\t\t       unsigned_char_type_node, NULL_TREE,\n-\t\t       true, false, true, false, true, false,\n-\t\t       NULL, Empty);\n-\n   main_identifier_node = get_identifier (\"main\");\n \n   /* Install the builtins we might need, either internally or as\n@@ -2450,8 +2459,8 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \n \t  gnu_result\n \t    = build_compound_expr (gnu_result_type, asm_expr,\n-\t\t\t\t   build_component_ref (rec_val, NULL_TREE,\n-\t\t\t\t\t\t\tfield, false));\n+\t\t\t\t   build_component_ref (rec_val, field,\n+\t\t\t\t\t\t\tfalse));\n \t}\n       break;\n \n@@ -2718,6 +2727,24 @@ can_be_lower_p (tree val1, tree val2)\n   return tree_int_cst_lt (val1, val2);\n }\n \n+/* Replace EXPR1 and EXPR2 by invariant expressions if possible.  Return\n+   true if both expressions have been replaced and false otherwise.  */\n+\n+static bool\n+make_invariant (tree *expr1, tree *expr2)\n+{\n+  tree inv_expr1 = gnat_invariant_expr (*expr1);\n+  tree inv_expr2 = gnat_invariant_expr (*expr2);\n+\n+  if (inv_expr1)\n+    *expr1 = inv_expr1;\n+\n+  if (inv_expr2)\n+    *expr2 = inv_expr2;\n+\n+  return inv_expr1 && inv_expr2;\n+}\n+\n /* Helper function for walk_tree, used by independent_iterations_p below.  */\n \n static tree\n@@ -3082,48 +3109,60 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n      the LOOP_STMT to it, finish it and make it the \"loop\".  */\n   if (Present (gnat_iter_scheme) && No (Condition (gnat_iter_scheme)))\n     {\n-      struct range_check_info_d *rci;\n-      unsigned n_checks = vec_safe_length (gnu_loop_info->checks);\n-      unsigned int i;\n-\n-      /* First, if we have computed a small number of invariant conditions for\n-\t range checks applied to the iteration variable, then initialize these\n-\t conditions in front of the loop.  Otherwise, leave them set to true.\n-\n-\t ??? The heuristics need to be improved, by taking into account the\n-\t     following datapoints:\n-\t       - loop unswitching is disabled for big loops.  The cap is the\n-\t\t parameter PARAM_MAX_UNSWITCH_INSNS (50).\n-\t       - loop unswitching can only be applied a small number of times\n-\t\t to a given loop.  The cap is PARAM_MAX_UNSWITCH_LEVEL (3).\n-\t       - the front-end quickly generates useless or redundant checks\n-\t\t that can be entirely optimized away in the end.  */\n-      if (1 <= n_checks && n_checks <= 4)\n-\tFOR_EACH_VEC_ELT (*gnu_loop_info->checks, i, rci)\n-\t  {\n-\t    tree low_ok\n-\t      = rci->low_bound\n-\t        ? build_binary_op (GE_EXPR, boolean_type_node,\n-\t\t\t\t   convert (rci->type, gnu_low),\n-\t\t\t\t   rci->low_bound)\n-\t\t: boolean_true_node;\n-\n-\t    tree high_ok\n-\t      = rci->high_bound\n-\t        ? build_binary_op (LE_EXPR, boolean_type_node,\n-\t\t\t\t   convert (rci->type, gnu_high),\n-\t\t\t\t   rci->high_bound)\n-\t\t: boolean_true_node;\n-\n-\t    tree range_ok\n-\t      = build_binary_op (TRUTH_ANDIF_EXPR, boolean_type_node,\n-\t\t\t\t low_ok, high_ok);\n-\n-\t    TREE_OPERAND (rci->invariant_cond, 0)\n-\t      = build_unary_op (TRUTH_NOT_EXPR, boolean_type_node, range_ok);\n-\n-\t    add_stmt_with_node_force (rci->invariant_cond, gnat_node);\n-\t  }\n+      /* First, if we have computed invariant conditions for range (or index)\n+\t checks applied to the iteration variable, find out whether they can\n+\t be evaluated to false at compile time; otherwise, if there are not\n+\t too many of them, combine them with the original checks.  If loop\n+\t unswitching is enabled, do not require the loop bounds to be also\n+\t invariant, as their evaluation will still be ahead of the loop.  */\n+      if (vec_safe_length (gnu_loop_info->checks) > 0\n+\t && (make_invariant (&gnu_low, &gnu_high) || flag_unswitch_loops))\n+\t{\n+\t  struct range_check_info_d *rci;\n+\t  unsigned int i, n_remaining_checks = 0;\n+\n+\t  FOR_EACH_VEC_ELT (*gnu_loop_info->checks, i, rci)\n+\t    {\n+\t      tree low_ok\n+\t\t= rci->low_bound\n+\t\t  ? build_binary_op (GE_EXPR, boolean_type_node,\n+\t\t\t\t     convert (rci->type, gnu_low),\n+\t\t\t\t     rci->low_bound)\n+\t\t  : boolean_true_node;\n+\n+\t      tree high_ok\n+\t\t= rci->high_bound\n+\t\t  ? build_binary_op (LE_EXPR, boolean_type_node,\n+\t\t\t\t     convert (rci->type, gnu_high),\n+\t\t\t\t     rci->high_bound)\n+\t\t  : boolean_true_node;\n+\n+\t      tree range_ok\n+\t\t= build_binary_op (TRUTH_ANDIF_EXPR, boolean_type_node,\n+\t\t\t\t   low_ok, high_ok);\n+\n+\t      rci->invariant_cond\n+\t\t= build_unary_op (TRUTH_NOT_EXPR, boolean_type_node, range_ok);\n+\n+\t      if (rci->invariant_cond == boolean_false_node)\n+\t\tTREE_OPERAND (rci->inserted_cond, 0) = rci->invariant_cond;\n+\t      else\n+\t\tn_remaining_checks++;\n+\t    }\n+\n+\t  /* Note that loop unswitching can only be applied a small number of\n+\t     times to a given loop (PARAM_MAX_UNSWITCH_LEVEL default to 3).  */\n+\t  if (0 < n_remaining_checks && n_remaining_checks <= 3\n+\t      && optimize > 1 && !optimize_size)\n+\t    FOR_EACH_VEC_ELT (*gnu_loop_info->checks, i, rci)\n+\t      if (rci->invariant_cond != boolean_false_node)\n+\t\t{\n+\t\t  TREE_OPERAND (rci->inserted_cond, 0) = rci->invariant_cond;\n+\n+\t\t  if (flag_unswitch_loops)\n+\t\t    add_stmt_with_node_force (rci->inserted_cond, gnat_node);\n+\t\t}\n+\t}\n \n       /* Second, if loop vectorization is enabled and the iterations of the\n \t loop can easily be proved as independent, mark the loop.  */\n@@ -3865,8 +3904,7 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n \t  for (t = TREE_CHAIN (gnu_cico_list); t; t = TREE_CHAIN (t))\n \t    {\n \t      tree gnu_field_deref\n-\t\t= build_component_ref (gnu_ret_deref, NULL_TREE,\n-\t\t\t\t       TREE_PURPOSE (t), true);\n+\t\t= build_component_ref (gnu_ret_deref, TREE_PURPOSE (t), true);\n \t      gnu_result = build2 (MODIFY_EXPR, void_type_node,\n \t\t\t\t   gnu_field_deref, TREE_VALUE (t));\n \t      add_stmt_with_node (gnu_result, gnat_end_label);\n@@ -4698,8 +4736,8 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t    tree gnu_result\n \t      = length == 1\n \t\t? gnu_call\n-\t\t: build_component_ref (gnu_call, NULL_TREE,\n-\t\t\t\t       TREE_PURPOSE (gnu_cico_list), false);\n+\t\t: build_component_ref (gnu_call, TREE_PURPOSE (gnu_cico_list),\n+\t\t\t\t       false);\n \n \t    /* If the actual is a conversion, get the inner expression, which\n \t       will be the real destination, and convert the result to the\n@@ -4786,8 +4824,8 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n       if (TYPE_CI_CO_LIST (gnu_subprog_type))\n \t{\n \t  tree gnu_elmt = TYPE_CI_CO_LIST (gnu_subprog_type);\n-\t  gnu_call = build_component_ref (gnu_call, NULL_TREE,\n-\t\t\t\t\t  TREE_PURPOSE (gnu_elmt), false);\n+\t  gnu_call\n+\t    = build_component_ref (gnu_call, TREE_PURPOSE (gnu_elmt), false);\n \t  gnu_result_type = TREE_TYPE (gnu_call);\n \t}\n \n@@ -5142,7 +5180,7 @@ Exception_Handler_to_gnu_sjlj (Node_Id gnat_node)\n \t\t  (build_unary_op\n \t\t   (INDIRECT_REF, NULL_TREE,\n \t\t    gnu_except_ptr_stack->last ()),\n-\t\t   get_identifier (\"not_handled_by_others\"), NULL_TREE,\n+\t\t   not_handled_by_others_decl,\n \t\t   false)),\n \t\t integer_zero_node);\n \t}\n@@ -5396,6 +5434,31 @@ Compilation_Unit_to_gnu (Node_Id gnat_node)\n   process_deferred_decl_context (true);\n }\n \f\n+/* Mark COND, a boolean expression, as predicating a call to a noreturn\n+   function, i.e. predict that it is very likely false, and return it.\n+\n+   The compiler will automatically predict the last edge leading to a call\n+   to a noreturn function as very unlikely taken.  This function makes it\n+   possible to expand the prediction to predecessors in case the condition\n+   is made up of several short-circuit operators.  */\n+\n+static tree\n+build_noreturn_cond (tree cond)\n+{\n+  tree fn = builtin_decl_explicit (BUILT_IN_EXPECT);\n+  tree arg_types = TYPE_ARG_TYPES (TREE_TYPE (fn));\n+  tree pred_type = TREE_VALUE (arg_types);\n+  tree expected_type = TREE_VALUE (TREE_CHAIN (arg_types));\n+\n+  tree t = build_call_expr (fn, 3,\n+\t\t\t    fold_convert (pred_type, cond),\n+\t\t\t    build_int_cst (expected_type, 0),\n+\t\t\t    build_int_cst (integer_type_node,\n+\t\t\t\t\t   PRED_NORETURN));\n+\n+  return build1 (NOP_EXPR, boolean_type_node, t);\n+}\n+\n /* Subroutine of gnat_to_gnu to translate gnat_node, an N_Raise_xxx_Error,\n    to a GCC tree, which is returned.  GNU_RESULT_TYPE_P is a pointer to where\n    we should place the result type.  LABEL_P is true if there is a label to\n@@ -5467,18 +5530,29 @@ Raise_Error_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t      = build_call_raise_range (reason, gnat_node, gnu_index,\n \t\t\t\t\tgnu_low_bound, gnu_high_bound);\n \n-\t  /* If loop unswitching is enabled, we try to compute invariant\n-\t     conditions for checks applied to iteration variables, i.e.\n-\t     conditions that are both independent of the variable and\n-\t     necessary in order for the check to fail in the course of\n-\t     some iteration, and prepend them to the original condition\n-\t     of the checks.  This will make it possible later for the\n-\t     loop unswitching pass to replace the loop with two loops,\n-\t     one of which has the checks eliminated and the other has\n-\t     the original checks reinstated, and a run time selection.\n-\t     The former loop will be suitable for vectorization.  */\n+\t  /* If optimization is enabled and we are inside a loop, we try to\n+\t     compute invariant conditions for checks applied to the iteration\n+\t     variable, i.e. conditions that are independent of the variable\n+\t     and necessary in order for the checks to fail in the course of\n+\t     some iteration.  If we succeed, we consider an alternative:\n+\n+\t       1. If loop unswitching is enabled, we prepend these conditions\n+\t\t  to the original conditions of the checks.  This will make it\n+\t\t  possible for the loop unswitching pass to replace the loop\n+\t\t  with two loops, one of which has the checks eliminated and\n+\t\t  the other has the original checks reinstated, and a prologue\n+\t\t  implementing a run-time selection.  The former loop will be\n+\t\t  for example suitable for vectorization.\n+\n+\t       2. Otherwise, we instead append the conditions to the original\n+\t\t  conditions of the checks.  At worse, if the conditions cannot\n+\t\t  be evaluated at compile time, they will be evaluated as true\n+\t\t  at run time only when the checks have already failed, thus\n+\t\t  contributing negatively only to the size of the executable.\n+\t\t  But the hope is that these invariant conditions be evaluated\n+\t\t  at compile time to false, thus taking away the entire checks\n+\t\t  with them.  */\n \t  if (optimize\n-\t      && flag_unswitch_loops\n \t      && inside_loop_p ()\n \t      && (!gnu_low_bound\n \t\t  || (gnu_low_bound = gnat_invariant_expr (gnu_low_bound)))\n@@ -5490,14 +5564,21 @@ Raise_Error_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t      rci->low_bound = gnu_low_bound;\n \t      rci->high_bound = gnu_high_bound;\n \t      rci->type = get_unpadded_type (gnat_type);\n-\t      rci->invariant_cond = build1 (SAVE_EXPR, boolean_type_node,\n-\t\t\t\t\t    boolean_true_node);\n+\t      rci->inserted_cond\n+\t\t= build1 (SAVE_EXPR, boolean_type_node, boolean_true_node);\n \t      vec_safe_push (loop->checks, rci);\n \t      loop->has_checks = true;\n-\t      gnu_cond = build_binary_op (TRUTH_ANDIF_EXPR,\n-\t\t\t\t\t  boolean_type_node,\n-\t\t\t\t\t  rci->invariant_cond,\n-\t\t\t\t\t  gnat_to_gnu (gnat_cond));\n+\t      gnu_cond = build_noreturn_cond (gnat_to_gnu (gnat_cond));\n+\t      if (flag_unswitch_loops)\n+\t\tgnu_cond = build_binary_op (TRUTH_ANDIF_EXPR,\n+\t\t\t\t\t    boolean_type_node,\n+\t\t\t\t\t    rci->inserted_cond,\n+\t\t\t\t\t    gnu_cond);\n+\t      else\n+\t\tgnu_cond = build_binary_op (TRUTH_ANDIF_EXPR,\n+\t\t\t\t\t    boolean_type_node,\n+\t\t\t\t\t    gnu_cond,\n+\t\t\t\t\t    rci->inserted_cond);\n \t    }\n \n \t  /* Or else, if aggressive loop optimizations are enabled, we just\n@@ -6256,7 +6337,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t    gnu_field = gnat_to_gnu_field_decl (gnat_field);\n \n \t    gnu_result\n-\t      = build_component_ref (gnu_prefix, NULL_TREE, gnu_field,\n+\t      = build_component_ref (gnu_prefix, gnu_field,\n \t\t\t\t     (Nkind (Parent (gnat_node))\n \t\t\t\t      == N_Attribute_Reference)\n \t\t\t\t     && lvalue_required_for_attribute_p"}, {"sha": "aa2fdf2405588fae12824ba0b320d328ae76e882", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/642357660ae1f36651519fb41f81a997f5fdae53/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/642357660ae1f36651519fb41f81a997f5fdae53/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=642357660ae1f36651519fb41f81a997f5fdae53", "patch": "@@ -3970,11 +3970,9 @@ convert_to_fat_pointer (tree type, tree expr)\n \t  expr = build_unary_op (INDIRECT_REF, NULL_TREE, expr);\n \t  template_addr\n \t    = build_unary_op (ADDR_EXPR, NULL_TREE,\n-\t\t\t      build_component_ref (expr, NULL_TREE, field,\n-\t\t\t\t\t\t   false));\n+\t\t\t      build_component_ref (expr, field, false));\n \t  expr = build_unary_op (ADDR_EXPR, NULL_TREE,\n-\t\t\t\t build_component_ref (expr, NULL_TREE,\n-\t\t\t\t\t\t      DECL_CHAIN (field),\n+\t\t\t\t build_component_ref (expr, DECL_CHAIN (field),\n \t\t\t\t\t\t      false));\n \t}\n     }\n@@ -4110,8 +4108,7 @@ convert (tree type, tree expr)\n \n       /* Otherwise, build an explicit component reference.  */\n       else\n-\tunpadded\n-\t  = build_component_ref (expr, NULL_TREE, TYPE_FIELDS (etype), false);\n+\tunpadded = build_component_ref (expr, TYPE_FIELDS (etype), false);\n \n       return convert (type, unpadded);\n     }\n@@ -4132,8 +4129,8 @@ convert (tree type, tree expr)\n   if (ecode == RECORD_TYPE && TYPE_JUSTIFIED_MODULAR_P (etype)\n       && code != UNCONSTRAINED_ARRAY_TYPE\n       && TYPE_MAIN_VARIANT (type) != TYPE_MAIN_VARIANT (etype))\n-    return convert (type, build_component_ref (expr, NULL_TREE,\n-\t\t\t\t\t       TYPE_FIELDS (etype), false));\n+    return\n+      convert (type, build_component_ref (expr, TYPE_FIELDS (etype), false));\n \n   /* If converting to a type that contains a template, convert to the data\n      type and then build the template. */\n@@ -4393,7 +4390,7 @@ convert (tree type, tree expr)\n       do {\n \ttree field = TYPE_FIELDS (child_etype);\n \tif (DECL_NAME (field) == parent_name_id && TREE_TYPE (field) == type)\n-\t  return build_component_ref (expr, NULL_TREE, field, false);\n+\t  return build_component_ref (expr, field, false);\n \tchild_etype = TREE_TYPE (field);\n       } while (TREE_CODE (child_etype) == RECORD_TYPE);\n     }\n@@ -4489,8 +4486,7 @@ convert (tree type, tree expr)\n       /* If converting fat pointer to normal or thin pointer, get the pointer\n \t to the array and then convert it.  */\n       if (TYPE_IS_FAT_POINTER_P (etype))\n-\texpr\n-\t  = build_component_ref (expr, NULL_TREE, TYPE_FIELDS (etype), false);\n+\texpr = build_component_ref (expr, TYPE_FIELDS (etype), false);\n \n       return fold (convert_to_pointer (type, expr));\n \n@@ -4715,13 +4711,11 @@ maybe_unconstrained_array (tree exp)\n \t      tree op1\n \t\t= build_unary_op (INDIRECT_REF, NULL_TREE,\n \t\t\t\t  build_component_ref (TREE_OPERAND (exp, 1),\n-\t\t\t\t\t\t       NULL_TREE,\n \t\t\t\t\t\t       TYPE_FIELDS (type),\n \t\t\t\t\t\t       false));\n \t      tree op2\n \t\t= build_unary_op (INDIRECT_REF, NULL_TREE,\n \t\t\t\t  build_component_ref (TREE_OPERAND (exp, 2),\n-\t\t\t\t\t\t       NULL_TREE,\n \t\t\t\t\t\t       TYPE_FIELDS (type),\n \t\t\t\t\t\t       false));\n \n@@ -4732,8 +4726,8 @@ maybe_unconstrained_array (tree exp)\n \t  else\n \t    {\n \t      exp = build_unary_op (INDIRECT_REF, NULL_TREE,\n-\t\t\t\t    build_component_ref (exp, NULL_TREE,\n-\t\t\t\t\t\t         TYPE_FIELDS (type),\n+\t\t\t\t    build_component_ref (exp,\n+\t\t\t\t\t\t\t TYPE_FIELDS (type),\n \t\t\t\t\t\t         false));\n \t      TREE_READONLY (exp) = read_only;\n \t      TREE_THIS_NOTRAP (exp) = no_trap;\n@@ -4754,18 +4748,23 @@ maybe_unconstrained_array (tree exp)\n \t  && TYPE_CONTAINS_TEMPLATE_P (TREE_TYPE (TYPE_FIELDS (type))))\n \t{\n \t  exp = convert (TREE_TYPE (TYPE_FIELDS (type)), exp);\n+\t  code = TREE_CODE (exp);\n \t  type = TREE_TYPE (exp);\n \t}\n \n       if (TYPE_CONTAINS_TEMPLATE_P (type))\n \t{\n-\t  exp = build_simple_component_ref (exp, NULL_TREE,\n-\t\t\t\t\t    DECL_CHAIN (TYPE_FIELDS (type)),\n-\t\t\t\t\t    false);\n+\t  /* If the array initializer is a box, return NULL_TREE.  */\n+\t  if (code == CONSTRUCTOR && CONSTRUCTOR_NELTS (exp) < 2)\n+\t    return NULL_TREE;\n+\n+\t  exp = build_component_ref (exp, DECL_CHAIN (TYPE_FIELDS (type)),\n+\t\t\t\t     false);\n+\t  type = TREE_TYPE (exp);\n \n \t  /* If the array type is padded, convert to the unpadded type.  */\n-\t  if (exp && TYPE_IS_PADDING_P (TREE_TYPE (exp)))\n-\t    exp = convert (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (exp))), exp);\n+\t  if (TYPE_IS_PADDING_P (type))\n+\t    exp = convert (TREE_TYPE (TYPE_FIELDS (type)), exp);\n \t}\n       break;\n \n@@ -4915,7 +4914,7 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n       finish_record_type (rec_type, field, 1, false);\n \n       expr = unchecked_convert (rec_type, expr, notrunc_p);\n-      expr = build_component_ref (expr, NULL_TREE, field, false);\n+      expr = build_component_ref (expr, field, false);\n       expr = fold_build1 (NOP_EXPR, type, expr);\n     }\n \n@@ -4986,8 +4985,7 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n \t  tree rec_type = maybe_pad_type (type, TYPE_SIZE (etype), 0, Empty,\n \t\t\t\t\t  false, false, false, true);\n \t  expr = unchecked_convert (rec_type, expr, notrunc_p);\n-\t  expr = build_component_ref (expr, NULL_TREE, TYPE_FIELDS (rec_type),\n-\t\t\t\t      false);\n+\t  expr = build_component_ref (expr, TYPE_FIELDS (rec_type), false);\n \t}\n     }\n "}, {"sha": "79e9b2f26dae9cfd5c866b9e90fc11221b13a161", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 92, "deletions": 133, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/642357660ae1f36651519fb41f81a997f5fdae53/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/642357660ae1f36651519fb41f81a997f5fdae53/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=642357660ae1f36651519fb41f81a997f5fdae53", "patch": "@@ -467,8 +467,7 @@ compare_fat_pointers (location_t loc, tree result_type, tree p1, tree p2)\n   if (TREE_CODE (p1) == CONSTRUCTOR)\n     p1_array = CONSTRUCTOR_ELT (p1, 0)->value;\n   else\n-    p1_array = build_component_ref (p1, NULL_TREE,\n-\t\t\t\t    TYPE_FIELDS (TREE_TYPE (p1)), true);\n+    p1_array = build_component_ref (p1, TYPE_FIELDS (TREE_TYPE (p1)), true);\n \n   p1_array_is_null\n     = fold_build2_loc (loc, EQ_EXPR, result_type, p1_array,\n@@ -478,8 +477,7 @@ compare_fat_pointers (location_t loc, tree result_type, tree p1, tree p2)\n   if (TREE_CODE (p2) == CONSTRUCTOR)\n     p2_array = CONSTRUCTOR_ELT (p2, 0)->value;\n   else\n-    p2_array = build_component_ref (p2, NULL_TREE,\n-\t\t\t\t    TYPE_FIELDS (TREE_TYPE (p2)), true);\n+    p2_array = build_component_ref (p2, TYPE_FIELDS (TREE_TYPE (p2)), true);\n \n   p2_array_is_null\n     = fold_build2_loc (loc, EQ_EXPR, result_type, p2_array,\n@@ -500,15 +498,15 @@ compare_fat_pointers (location_t loc, tree result_type, tree p1, tree p2)\n     p1_bounds = CONSTRUCTOR_ELT (p1, 1)->value;\n   else\n     p1_bounds\n-      = build_component_ref (p1, NULL_TREE,\n-\t\t\t     DECL_CHAIN (TYPE_FIELDS (TREE_TYPE (p1))), true);\n+      = build_component_ref (p1, DECL_CHAIN (TYPE_FIELDS (TREE_TYPE (p1))),\n+\t\t\t     true);\n \n   if (TREE_CODE (p2) == CONSTRUCTOR)\n     p2_bounds = CONSTRUCTOR_ELT (p2, 1)->value;\n   else\n     p2_bounds\n-      = build_component_ref (p2, NULL_TREE,\n-\t\t\t     DECL_CHAIN (TYPE_FIELDS (TREE_TYPE (p2))), true);\n+      = build_component_ref (p2, DECL_CHAIN (TYPE_FIELDS (TREE_TYPE (p2))),\n+\t\t\t     true);\n \n   same_bounds\n     = fold_build2_loc (loc, EQ_EXPR, result_type, p1_bounds, p2_bounds);\n@@ -1942,80 +1940,65 @@ gnat_build_constructor (tree type, vec<constructor_elt, va_gc> *v)\n   return result;\n }\n \f\n-/* Return a COMPONENT_REF to access a field that is given by COMPONENT,\n-   an IDENTIFIER_NODE giving the name of the field, or FIELD, a FIELD_DECL,\n-   for the field.  Don't fold the result if NO_FOLD_P is true.\n+/* Return a COMPONENT_REF to access FIELD in RECORD, or NULL_TREE if the field\n+   is not found in the record.  Don't fold the result if NO_FOLD is true.  */\n \n-   We also handle the fact that we might have been passed a pointer to the\n-   actual record and know how to look for fields in variant parts.  */\n-\n-tree\n-build_simple_component_ref (tree record_variable, tree component, tree field,\n-\t\t\t    bool no_fold_p)\n+static tree\n+build_simple_component_ref (tree record, tree field, bool no_fold)\n {\n-  tree record_type = TYPE_MAIN_VARIANT (TREE_TYPE (record_variable));\n-  tree base, ref;\n+  tree type = TYPE_MAIN_VARIANT (TREE_TYPE (record));\n+  tree ref;\n \n-  gcc_assert (RECORD_OR_UNION_TYPE_P (record_type)\n-\t      && COMPLETE_TYPE_P (record_type)\n-\t      && (component == NULL_TREE) != (field == NULL_TREE));\n-\n-  /* If no field was specified, look for a field with the specified name in\n-     the current record only.  */\n-  if (!field)\n-    for (field = TYPE_FIELDS (record_type);\n-\t field;\n-\t field = DECL_CHAIN (field))\n-      if (DECL_NAME (field) == component)\n-\tbreak;\n+  gcc_assert (RECORD_OR_UNION_TYPE_P (type) && COMPLETE_TYPE_P (type));\n \n-  if (!field)\n-    return NULL_TREE;\n+  /* Try to fold a conversion from another record or union type unless the type\n+     contains a placeholder as it might be needed for a later substitution.  */\n+  if (TREE_CODE (record) == VIEW_CONVERT_EXPR\n+      && RECORD_OR_UNION_TYPE_P (TREE_TYPE (TREE_OPERAND (record, 0)))\n+      && !type_contains_placeholder_p (type))\n+    {\n+      tree op = TREE_OPERAND (record, 0);\n+\n+      /* If this is an unpadding operation, convert the underlying object to\n+\t the unpadded type directly.  */\n+      if (TYPE_IS_PADDING_P (type) && field == TYPE_FIELDS (type))\n+\treturn convert (TREE_TYPE (field), op);\n+\n+      /* Otherwise try to access FIELD directly in the underlying type, but\n+\t make sure that the form of the reference doesn't change too much;\n+\t this can happen for an unconstrained bit-packed array type whose\n+\t constrained form can be an integer type.  */\n+      ref = build_simple_component_ref (op, field, no_fold);\n+      if (ref && TREE_CODE (TREE_TYPE (ref)) == TREE_CODE (TREE_TYPE (field)))\n+\treturn ref;\n+    }\n \n   /* If this field is not in the specified record, see if we can find a field\n      in the specified record whose original field is the same as this one.  */\n-  if (DECL_CONTEXT (field) != record_type)\n+  if (DECL_CONTEXT (field) != type)\n     {\n       tree new_field;\n \n       /* First loop through normal components.  */\n-      for (new_field = TYPE_FIELDS (record_type);\n+      for (new_field = TYPE_FIELDS (type);\n \t   new_field;\n \t   new_field = DECL_CHAIN (new_field))\n \tif (SAME_FIELD_P (field, new_field))\n \t  break;\n \n-      /* Next, see if we're looking for an inherited component in an extension.\n-\t If so, look through the extension directly, unless the type contains\n-\t a placeholder, as it might be needed for a later substitution.  */\n-      if (!new_field\n-\t  && TREE_CODE (record_variable) == VIEW_CONVERT_EXPR\n-\t  && TYPE_ALIGN_OK (record_type)\n-\t  && !type_contains_placeholder_p (record_type)\n-\t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (record_variable, 0)))\n-\t     == RECORD_TYPE\n-\t  && TYPE_ALIGN_OK (TREE_TYPE (TREE_OPERAND (record_variable, 0))))\n-\t{\n-\t  ref = build_simple_component_ref (TREE_OPERAND (record_variable, 0),\n-\t\t\t\t\t    NULL_TREE, field, no_fold_p);\n-\t  if (ref)\n-\t    return ref;\n-\t}\n-\n       /* Next, loop through DECL_INTERNAL_P components if we haven't found the\n \t component in the first search.  Doing this search in two steps is\n \t required to avoid hidden homonymous fields in the _Parent field.  */\n       if (!new_field)\n-\tfor (new_field = TYPE_FIELDS (record_type);\n+\tfor (new_field = TYPE_FIELDS (type);\n \t     new_field;\n \t     new_field = DECL_CHAIN (new_field))\n-\t  if (DECL_INTERNAL_P (new_field))\n+\t  if (DECL_INTERNAL_P (new_field)\n+\t      && RECORD_OR_UNION_TYPE_P (TREE_TYPE (new_field)))\n \t    {\n \t      tree field_ref\n-\t\t= build_simple_component_ref (record_variable,\n-\t\t\t\t\t      NULL_TREE, new_field, no_fold_p);\n-\t      ref = build_simple_component_ref (field_ref, NULL_TREE, field,\n-\t\t\t\t\t\tno_fold_p);\n+\t\t= build_simple_component_ref (record, new_field, no_fold);\n+\t      ref = build_simple_component_ref (field_ref, field, no_fold);\n \t      if (ref)\n \t\treturn ref;\n \t    }\n@@ -2033,95 +2016,49 @@ build_simple_component_ref (tree record_variable, tree component, tree field,\n       && TREE_OVERFLOW (DECL_FIELD_OFFSET (field)))\n     return NULL_TREE;\n \n-  /* We have found a suitable field.  Before building the COMPONENT_REF, get\n-     the base object of the record variable if possible.  */\n-  base = record_variable;\n-\n-  if (TREE_CODE (record_variable) == VIEW_CONVERT_EXPR)\n-    {\n-      tree inner_variable = TREE_OPERAND (record_variable, 0);\n-      tree inner_type = TYPE_MAIN_VARIANT (TREE_TYPE (inner_variable));\n-\n-      /* Look through a conversion between type variants.  This is transparent\n-\t as far as the field is concerned.  */\n-      if (inner_type == record_type)\n-\tbase = inner_variable;\n-\n-      /* Look through a conversion between original and packable version, but\n-\t the field needs to be adjusted in this case.  */\n-      else if (RECORD_OR_UNION_TYPE_P (inner_type)\n-\t       && TYPE_NAME (inner_type) == TYPE_NAME (record_type))\n-\t{\n-\t  tree new_field;\n-\n-\t  for (new_field = TYPE_FIELDS (inner_type);\n-\t       new_field;\n-\t       new_field = DECL_CHAIN (new_field))\n-\t    if (SAME_FIELD_P (field, new_field))\n-\t      break;\n-\t  if (new_field)\n-\t    {\n-\t      field = new_field;\n-\t      base = inner_variable;\n-\t    }\n-\t}\n-    }\n-\n-  ref = build3 (COMPONENT_REF, TREE_TYPE (field), base, field, NULL_TREE);\n+  ref = build3 (COMPONENT_REF, TREE_TYPE (field), record, field, NULL_TREE);\n \n-  if (TREE_READONLY (record_variable)\n+  if (TREE_READONLY (record)\n       || TREE_READONLY (field)\n-      || TYPE_READONLY (record_type))\n+      || TYPE_READONLY (type))\n     TREE_READONLY (ref) = 1;\n \n-  if (TREE_THIS_VOLATILE (record_variable)\n+  if (TREE_THIS_VOLATILE (record)\n       || TREE_THIS_VOLATILE (field)\n-      || TYPE_VOLATILE (record_type))\n+      || TYPE_VOLATILE (type))\n     TREE_THIS_VOLATILE (ref) = 1;\n \n-  if (no_fold_p)\n+  if (no_fold)\n     return ref;\n \n   /* The generic folder may punt in this case because the inner array type\n      can be self-referential, but folding is in fact not problematic.  */\n-  if (TREE_CODE (base) == CONSTRUCTOR\n-      && TYPE_CONTAINS_TEMPLATE_P (TREE_TYPE (base)))\n+  if (TREE_CODE (record) == CONSTRUCTOR\n+      && TYPE_CONTAINS_TEMPLATE_P (TREE_TYPE (record)))\n     {\n-      unsigned int len = CONSTRUCTOR_NELTS (base);\n-      gcc_assert (len > 0);\n-\n-      if (field == CONSTRUCTOR_ELT (base, 0)->index)\n-\treturn CONSTRUCTOR_ELT (base, 0)->value;\n-\n-      if (len > 1)\n-\t{\n-\t  if (field == CONSTRUCTOR_ELT (base, 1)->index)\n-\t    return CONSTRUCTOR_ELT (base, 1)->value;\n-\t}\n-      else\n-\treturn NULL_TREE;\n-\n+      vec<constructor_elt, va_gc> *elts = CONSTRUCTOR_ELTS (record);\n+      unsigned HOST_WIDE_INT idx;\n+      tree index, value;\n+      FOR_EACH_CONSTRUCTOR_ELT (elts, idx, index, value)\n+       if (index == field)\n+\treturn value;\n       return ref;\n     }\n \n   return fold (ref);\n }\n \n-/* Likewise, but generate a Constraint_Error if the reference could not be\n-   found.  */\n+/* Likewise, but return NULL_EXPR and generate a Constraint_Error if the\n+   field is not found in the record.  */\n \n tree\n-build_component_ref (tree record_variable, tree component, tree field,\n-\t\t     bool no_fold_p)\n+build_component_ref (tree record, tree field, bool no_fold)\n {\n-  tree ref = build_simple_component_ref (record_variable, component, field,\n-\t\t\t\t\t no_fold_p);\n+  tree ref = build_simple_component_ref (record, field, no_fold);\n   if (ref)\n     return ref;\n \n-  /* If FIELD was specified, assume this is an invalid user field so raise\n-     Constraint_Error.  Otherwise, we have no type to return so abort.  */\n-  gcc_assert (field);\n+  /* Assume this is an invalid user field so raise Constraint_Error.  */\n   return build1 (NULL_EXPR, TREE_TYPE (field),\n \t\t build_call_raise (CE_Discriminant_Check_Failed, Empty,\n \t\t\t\t   N_Raise_Constraint_Error));\n@@ -2230,8 +2167,8 @@ maybe_wrap_malloc (tree data_size, tree data_type, Node_Id gnat_node)\n \t= build_unary_op (INDIRECT_REF, NULL_TREE, aligning_record_addr);\n \n       tree aligning_field\n-\t= build_component_ref (aligning_record, NULL_TREE,\n-\t\t\t       TYPE_FIELDS (aligning_type), false);\n+\t= build_component_ref (aligning_record, TYPE_FIELDS (aligning_type),\n+\t\t\t       false);\n \n       tree aligning_field_addr\n         = build_unary_op (ADDR_EXPR, NULL_TREE, aligning_field);\n@@ -2416,7 +2353,7 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n       else\n \tstorage_init\n \t  = build_binary_op (INIT_EXPR, NULL_TREE,\n-\t\t\t     build_component_ref (storage_deref, NULL_TREE,\n+\t\t\t     build_component_ref (storage_deref,\n \t\t\t\t\t\t  TYPE_FIELDS (storage_type),\n \t\t\t\t\t\t  false),\n \t\t\t     build_template (template_type, type, NULL_TREE));\n@@ -2883,10 +2820,11 @@ get_inner_constant_reference (tree exp)\n tree\n gnat_invariant_expr (tree expr)\n {\n-  tree type = TREE_TYPE (expr), t;\n+  const tree type = TREE_TYPE (expr);\n \n   expr = remove_conversions (expr, false);\n \n+  /* Look through temporaries created to capture values.  */\n   while ((TREE_CODE (expr) == CONST_DECL\n \t  || (TREE_CODE (expr) == VAR_DECL && TREE_READONLY (expr)))\n \t && decl_function_context (expr) == current_function_decl\n@@ -2908,7 +2846,27 @@ gnat_invariant_expr (tree expr)\n   if (TREE_CONSTANT (expr))\n     return fold_convert (type, expr);\n \n-  t = expr;\n+  /* Skip overflow checks since they don't change the invariantness.  */\n+  if (TREE_CODE (expr) == COND_EXPR\n+      && TREE_CODE (COND_EXPR_THEN (expr)) == COMPOUND_EXPR\n+      && TREE_CODE (TREE_OPERAND (COND_EXPR_THEN (expr), 0)) == CALL_EXPR\n+      && get_callee_fndecl (TREE_OPERAND (COND_EXPR_THEN (expr), 0))\n+         == gnat_raise_decls[CE_Overflow_Check_Failed])\n+    expr = COND_EXPR_ELSE (expr);\n+\n+  /* Deal with addition or subtraction of constants.  */\n+  if (TREE_CODE (expr) == PLUS_EXPR || TREE_CODE (expr) == MINUS_EXPR)\n+    {\n+      tree op0 = gnat_invariant_expr (TREE_OPERAND (expr, 0));\n+      tree op1 = TREE_OPERAND (expr, 1);\n+      if (op0 && TREE_CONSTANT (op1))\n+\treturn fold_build2 (TREE_CODE (expr), type, op0, op1);\n+      else\n+\treturn NULL_TREE;\n+    }\n+\n+  bool invariant_p = false;\n+  tree t = expr;\n \n   while (true)\n     {\n@@ -2917,6 +2875,7 @@ gnat_invariant_expr (tree expr)\n \tcase COMPONENT_REF:\n \t  if (TREE_OPERAND (t, 2) != NULL_TREE)\n \t    return NULL_TREE;\n+\t  invariant_p |= DECL_INVARIANT_P (TREE_OPERAND (t, 1));\n \t  break;\n \n \tcase ARRAY_REF:\n@@ -2928,16 +2887,16 @@ gnat_invariant_expr (tree expr)\n \t  break;\n \n \tcase BIT_FIELD_REF:\n-\tcase VIEW_CONVERT_EXPR:\n \tcase REALPART_EXPR:\n \tcase IMAGPART_EXPR:\n+\tcase VIEW_CONVERT_EXPR:\n+\tCASE_CONVERT:\n \t  break;\n \n \tcase INDIRECT_REF:\n-\t  if (!TREE_READONLY (t)\n-\t      || TREE_SIDE_EFFECTS (t)\n-\t      || !TREE_THIS_NOTRAP (t))\n+\t  if ((!invariant_p && !TREE_READONLY (t)) || TREE_SIDE_EFFECTS (t))\n \t    return NULL_TREE;\n+\t  invariant_p = false;\n \t  break;\n \n \tdefault:\n@@ -2956,7 +2915,7 @@ gnat_invariant_expr (tree expr)\n \t  || decl_function_context (t) != current_function_decl))\n     return fold_convert (type, expr);\n \n-  if (!TREE_READONLY (t))\n+  if (!invariant_p && !TREE_READONLY (t))\n     return NULL_TREE;\n \n   if (TREE_CODE (t) == PARM_DECL)"}, {"sha": "edd201f209bf4df9b2399a8d94e81dfc012b7f68", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/642357660ae1f36651519fb41f81a997f5fdae53/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/642357660ae1f36651519fb41f81a997f5fdae53/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=642357660ae1f36651519fb41f81a997f5fdae53", "patch": "@@ -1,3 +1,9 @@\n+2015-11-18  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/loop_optimization19.adb: New test.\n+\t* gnat.dg/loop_optimization20.adb: Likewise.\n+\t* gnat.dg/loop_optimization21.ad[sb]: Likewise.\n+\n 2015-11-18  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/opt52.adb: New test."}, {"sha": "434a7b8d3f9f926a51d402e1fc4ad660e8d9efc6", "filename": "gcc/testsuite/gnat.dg/loop_optimization19.adb", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/642357660ae1f36651519fb41f81a997f5fdae53/gcc%2Ftestsuite%2Fgnat.dg%2Floop_optimization19.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/642357660ae1f36651519fb41f81a997f5fdae53/gcc%2Ftestsuite%2Fgnat.dg%2Floop_optimization19.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Floop_optimization19.adb?ref=642357660ae1f36651519fb41f81a997f5fdae53", "patch": "@@ -0,0 +1,45 @@\n+-- { dg-do compile }\n+-- { dg-options \"-O -fdump-tree-optimized\" }\n+\n+procedure Loop_Optimization19 is\n+\n+  type Array_T is array (Positive range <>) of Integer;\n+  type Obj_T (Length : Natural) is\n+    record\n+      Elements : Array_T (1 .. Length);\n+    end record;\n+\n+  type T is access Obj_T;\n+\n+  function Equal (S1, S2 : T) return Boolean;\n+  pragma No_Inline (Equal);\n+\n+  function Equal (S1, S2 : T) return Boolean is\n+  begin\n+    if S1.Length = S2.Length then\n+      for I in 1 .. S1.Length loop\n+        if S1.Elements (I) /= S2.Elements (I) then\n+          return False;\n+        end if;\n+      end loop;\n+     return True;\n+    else\n+      return False;\n+    end if;\n+  end Equal;\n+\n+  A : T := new Obj_T (Length => 10);\n+  B : T := new Obj_T (Length => 20);\n+  C : T := new Obj_T (Length => 30);\n+\n+begin\n+  if Equal (A, B) then\n+    raise Program_Error;\n+  else\n+    if Equal (B, C) then\n+      raise Program_Error;\n+    end if;\n+  end if;\n+end;\n+\n+-- { dg-final { scan-tree-dump-not \"Index_Check\" \"optimized\" } }"}, {"sha": "729799e605a2001dc369b083ede392697221e9ef", "filename": "gcc/testsuite/gnat.dg/loop_optimization20.adb", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/642357660ae1f36651519fb41f81a997f5fdae53/gcc%2Ftestsuite%2Fgnat.dg%2Floop_optimization20.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/642357660ae1f36651519fb41f81a997f5fdae53/gcc%2Ftestsuite%2Fgnat.dg%2Floop_optimization20.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Floop_optimization20.adb?ref=642357660ae1f36651519fb41f81a997f5fdae53", "patch": "@@ -0,0 +1,35 @@\n+-- { dg-do compile }\n+-- { dg-options \"-O -fdump-tree-optimized\" }\n+\n+procedure Loop_Optimization20 is\n+\n+  type Array_T is array (Positive range <>) of Integer;\n+  type Obj_T (Length : Natural) is\n+    record\n+      Elements : Array_T (1 .. Length);\n+    end record;\n+\n+  type T is access Obj_T;\n+\n+  function Is_Null (S1 : Obj_T) return Boolean;\n+  pragma No_Inline (Is_Null);\n+\n+  function Is_Null (S1 : Obj_T) return Boolean is\n+  begin\n+    for I in 1 .. S1.Length loop\n+      if S1.Elements (I) /= 0 then\n+        return False;\n+      end if;\n+    end loop;\n+    return True;\n+  end;\n+\n+  A : T := new Obj_T'(Length => 10, Elements => (others => 0));\n+\n+begin\n+  if not Is_Null (A.all) then\n+    raise Program_Error;\n+  end if;\n+end;\n+\n+-- { dg-final { scan-tree-dump-not \"Index_Check\" \"optimized\" } }"}, {"sha": "957b715ff7de01beec8dcd48dd5936be6a227f6b", "filename": "gcc/testsuite/gnat.dg/loop_optimization21.adb", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/642357660ae1f36651519fb41f81a997f5fdae53/gcc%2Ftestsuite%2Fgnat.dg%2Floop_optimization21.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/642357660ae1f36651519fb41f81a997f5fdae53/gcc%2Ftestsuite%2Fgnat.dg%2Floop_optimization21.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Floop_optimization21.adb?ref=642357660ae1f36651519fb41f81a997f5fdae53", "patch": "@@ -0,0 +1,20 @@\n+-- { dg-do compile }\n+-- { dg-options \"-O -fdump-tree-optimized\" }\n+\n+package body Loop_Optimization21 is\n+\n+  function Min (X : in Item_Vector) return Item is\n+    Tmp_Min : Item;\n+  begin\n+    Tmp_Min := X (X'First);\n+    for I in X'First + 1 .. X'Last loop\n+      if X (I) <= Tmp_Min then\n+        Tmp_Min := X (I);\n+      end if;\n+    end loop;\n+    return Tmp_Min;\n+  end Min;\n+\n+end Loop_Optimization21;\n+\n+-- { dg-final { scan-tree-dump-times \"Index_Check\" 1 \"optimized\" } }"}, {"sha": "4510b0e9c9210936ee7c4492df951bbbcf53c919", "filename": "gcc/testsuite/gnat.dg/loop_optimization21.ads", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/642357660ae1f36651519fb41f81a997f5fdae53/gcc%2Ftestsuite%2Fgnat.dg%2Floop_optimization21.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/642357660ae1f36651519fb41f81a997f5fdae53/gcc%2Ftestsuite%2Fgnat.dg%2Floop_optimization21.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Floop_optimization21.ads?ref=642357660ae1f36651519fb41f81a997f5fdae53", "patch": "@@ -0,0 +1,9 @@\n+package Loop_Optimization21 is\n+\n+  type Item is new Float;\n+\n+  type Item_Vector is array (Positive range <>) of Item;\n+\n+  function Min (X : Item_Vector) return Item;\n+\n+end Loop_Optimization21;"}]}