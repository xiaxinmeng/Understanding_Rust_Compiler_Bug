{"sha": "da792a6816d789da1d267d5e594fdc9c20db52a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGE3OTJhNjgxNmQ3ODlkYTFkMjY3ZDVlNTk0ZmRjOWMyMGRiNTJhNg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-06-13T01:46:09Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-06-13T01:46:09Z"}, "message": "(alpha_cpu, alpha_cpu_string): New variables.\n\n(override_options): Process -mcpu= value.\n(alpha_adjust_cost): Handle adjustments for EV5.\n\nFrom-SVN: r12278", "tree": {"sha": "352f6e16f8cbf354a2f4ae6fb41dd8723a5f6d3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/352f6e16f8cbf354a2f4ae6fb41dd8723a5f6d3c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da792a6816d789da1d267d5e594fdc9c20db52a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da792a6816d789da1d267d5e594fdc9c20db52a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da792a6816d789da1d267d5e594fdc9c20db52a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da792a6816d789da1d267d5e594fdc9c20db52a6/comments", "author": null, "committer": null, "parents": [{"sha": "e5ee0060c6e97e535a58ab86189e36bfa9414b0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5ee0060c6e97e535a58ab86189e36bfa9414b0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5ee0060c6e97e535a58ab86189e36bfa9414b0c"}], "stats": {"total": 42, "additions": 41, "deletions": 1}, "files": [{"sha": "13ae03e89f7bb30bc57f38013dad26ed6d1ee617", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da792a6816d789da1d267d5e594fdc9c20db52a6/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da792a6816d789da1d267d5e594fdc9c20db52a6/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=da792a6816d789da1d267d5e594fdc9c20db52a6", "patch": "@@ -38,6 +38,9 @@ Boston, MA 02111-1307, USA.  */\n #include \"obstack.h\"\n #include \"tree.h\"\n \n+/* Specify which cpu to schedule for. */\n+ enum processor_type alpha_cpu;\n+\n /* Specify how accurate floating-point traps need to be.  */\n \n enum alpha_trap_precision alpha_tp;\n@@ -51,6 +54,7 @@ enum alpha_fp_rounding_mode alpha_fprm;\n enum alpha_fp_trap_mode alpha_fptm;\n \n /* Strings decoded into the above options.  */\n+char *alpha_cpu_string;\t\t/* -mcpu=ev[4|5] */\n char *alpha_tp_string;\t\t/* -mtrap-precision=[p|s|i] */\n char *alpha_fprm_string;\t/* -mfp-rounding-mode=[n|m|c|d] */\n char *alpha_fptm_string;\t/* -mfp-trap-mode=[n|u|su|sui] */\n@@ -93,6 +97,18 @@ static void add_long_const\tPROTO((FILE *, HOST_WIDE_INT, int, int, int));\n void\n override_options ()\n {\n+  alpha_cpu = TARGET_CPU_DEFAULT;\n+  if (alpha_cpu_string)\n+    {\n+      if (alpha_cpu_string[0] == 'e'\n+\t  && alpha_cpu_string[1] == 'v'\n+\t  && (alpha_cpu_string[2] == '4' || alpha_cpu_string[2] == '5'))\n+\talpha_cpu = alpha_cpu_string[2] == '4' ? PROCESSOR_EV4 : PROCESSOR_EV5;\n+      else\n+\terror (\"bad value (%s) for -mcpu switch\",\n+\t       alpha_cpu_string);\n+    }\n+\n   alpha_tp = ALPHA_TP_PROG;\n   alpha_fprm = ALPHA_FPRM_NORM;\n   alpha_fptm = ALPHA_FPTM_N;\n@@ -1047,6 +1063,29 @@ alpha_adjust_cost (insn, link, dep_insn, cost)\n   if (REG_NOTE_KIND (link) != 0)\n     return 0;\n \n+  /* EV5 costs are as given in alpha.md; exceptions are given here. */\n+  if (alpha_cpu == PROCESSOR_EV5)\n+    {\n+      /* And the lord DEC sayeth:  \"A special bypass provides an effective\n+\t latency of 0 cycles for an ICMP or ILOG insn producing the test\n+\t operand of an IBR or CMOV insn.\" */\n+      if (recog_memoized (dep_insn) >= 0\n+\t  && (get_attr_type (dep_insn) == TYPE_ICMP\n+\t      || get_attr_type (dep_insn) == TYPE_ILOG)\n+\t  && recog_memoized (insn) >= 0\n+\t  && (get_attr_type (insn) == TYPE_IBR\n+\t      || (get_attr_type (insn) == TYPE_CMOV\n+\t\t  && !((set = single_set (dep_insn)) != 0\n+\t\t       && GET_CODE (PATTERN (insn)) == SET\n+\t\t       && GET_CODE (SET_SRC (PATTERN (insn))) == IF_THEN_ELSE\n+\t\t       && (rtx_equal_p (SET_DEST (set),\n+\t\t\t\t\tXEXP (SET_SRC (PATTERN (insn)), 1))\n+\t\t\t   || rtx_equal_p (SET_DEST (set),\n+\t\t\t\t\t   XEXP (SET_SRC (PATTERN (insn)), 2)))))))\n+\treturn 1;\n+      return cost;\n+    } \n+\n   /* If INSN is a store insn and DEP_INSN is setting the data being stored,\n      we can sometimes lower the cost.  */\n \n@@ -1076,7 +1115,8 @@ alpha_adjust_cost (insn, link, dep_insn, cost)\n      for the address in loads and stores.  */\n \n   if (recog_memoized (dep_insn) >= 0\n-      && get_attr_type (dep_insn) == TYPE_IADDLOG)\n+      && (get_attr_type (dep_insn) == TYPE_IADD\n+\t  || get_attr_type (dep_insn) == TYPE_ILOG))\n     switch (get_attr_type (insn))\n       {\n       case TYPE_LD:"}]}