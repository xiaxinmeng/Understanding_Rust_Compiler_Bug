{"sha": "ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWU3NmI5MzE0YmEyYWEyZGMxZjU5YzRlZmEzMmFjNDJkZDg0MTQ3ZA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2003-07-08T01:38:44Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-07-08T01:38:44Z"}, "message": "cp-tree.h (build_scoped_method_call): Remove.\n\n\t* cp-tree.h (build_scoped_method_call): Remove.\n\t(lookup_qualified_name): Remove parameter.\n\t(tsubst_copy_and_build): Declare.\n\t(finish_qualified_object_call_expr): Remove.\n\t(check_accessibility_of_qualified_id): New function.\n\t(finish_qualified_id_expr): Likewise.\n\t(non_reference): Likewise.\n\t(build_expr_from-tree): Remove.\n\t* call.c (non_reference): Remove.\n\t(build_scoped_method_call): Likewise.\n\t(build_method_call): Use error_operand_p.  Assert that we are not\n\tprocessing a template.\n\t(standard_conversion): Use non_reference.\n\t* class.c (build_vtbl_entry_ref): Likewise.\n\t(build_vtbl_ref_1): Likewise.\n\t* cvt.c (build_expr_type_conversion): Use non_reference.\n\t* decl.c (lookup_qualified_name): Remove flags parameter.\n\t(grok_op_properties): Use non_reference.\n\t* decl2.c (grok_array_decl): Likewise.\n\t(build_expr_from_tree): Remove.\n\t(build_offset_ref_call_from_tree): Update comment.\n\t* error.c (parm_to_string): Call reinit_global_formatting_buffer.\n\t* except.c (prepare_eh_types): Use non_reference.\n\t(can_convert_eh): Likewise.\n\t* init.c (build_dtor_call): Avoid using build_method_call.\n\t* mangle.c (write_template_param): Remove misleading comment.\n\t* method.c (locate_copy): Use non_reference.\n\t* parser.c (cp_parser_scope_through_which_access_occurs): Remove.\n\t(cp_parser_primary_expression): Do not create SCOPE_REFs is\n\tnon-dependent contexts.\n\t(cp_parser_postfix_expression): Use finish_qualified_id_expr.\n\t(cp_parser_direct_declarator): Use tsubst_copy_and_build, not\n\tbuild_expr_from_tree.\n\t(cp_parser_lookup_name): Adjust call to lookup_qualified_name.\n\tUse check_accessibility_of_qualified_id.\n\t* pt.c (maybe_fold_nontype_arg): Use tsubst_copy_and_build, not\n\tbuild_expr_from_tree.\n\t(tsubst_baselink): New function.\n\t(tsubst_qualified_id): Likewise.\n\t(tsubst_copy): Use them.  Remove support for METHOD_CALL_EXPR.\n\t(tsubst_expr): Adjust call to lookup_qualified_name.\n\t(tsubst_copy_and_build): Handle SCOPE_REFs specially.  Adjust\n\thandling of CALL_EXPRs.\n\t(value_dependent_expression_p): Use INTEGRAL_OR_ENUMERATION_TYPE_P.\n\t* rtti.c (get_tinfo_decl_dynamic): Use non_reference.\n\t* search.c (check_final_overrider): Likewise.\n\t* semantics.c (check_accessibility_of_qualified_id): New function.\n\t(finish_qualified_object_call_expr): Remove.\n\t* typeck.c (target_type): Use non_reference.\n\t(cxx_sizeof_or_alignof_type): Likewise.\n\t(dubious_conversion_warnings): Likewise.\n\t(convert_for_initialization): Likewise.\n\t(non_reference): New function.\n\nFrom-SVN: r69063", "tree": {"sha": "fd553211eb12fd2f9ce0b66abea29db6c18cd0f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd553211eb12fd2f9ce0b66abea29db6c18cd0f0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d/comments", "author": null, "committer": null, "parents": [{"sha": "923c4cf299afcff993b1ae8f510e997d3aca94f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/923c4cf299afcff993b1ae8f510e997d3aca94f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/923c4cf299afcff993b1ae8f510e997d3aca94f5"}], "stats": {"total": 1449, "additions": 522, "deletions": 927}, "files": [{"sha": "888f0310a7ebfb7c1cc9832aae50c56780bfd31b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d", "patch": "@@ -1,3 +1,59 @@\n+2003-07-07  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (build_scoped_method_call): Remove.\n+\t(lookup_qualified_name): Remove parameter.\n+\t(tsubst_copy_and_build): Declare.\n+\t(finish_qualified_object_call_expr): Remove.\n+\t(check_accessibility_of_qualified_id): New function.\n+\t(finish_qualified_id_expr): Likewise.\n+\t(non_reference): Likewise.\n+\t(build_expr_from-tree): Remove.\n+\t* call.c (non_reference): Remove.\n+\t(build_scoped_method_call): Likewise.\n+\t(build_method_call): Use error_operand_p.  Assert that we are not\n+\tprocessing a template.\n+\t(standard_conversion): Use non_reference.\n+\t* class.c (build_vtbl_entry_ref): Likewise.\n+\t(build_vtbl_ref_1): Likewise.\n+\t* cvt.c (build_expr_type_conversion): Use non_reference.\n+\t* decl.c (lookup_qualified_name): Remove flags parameter.\n+\t(grok_op_properties): Use non_reference.\n+\t* decl2.c (grok_array_decl): Likewise.\n+\t(build_expr_from_tree): Remove.\n+\t(build_offset_ref_call_from_tree): Update comment.\n+\t* error.c (parm_to_string): Call reinit_global_formatting_buffer.\n+\t* except.c (prepare_eh_types): Use non_reference.\n+\t(can_convert_eh): Likewise.\n+\t* init.c (build_dtor_call): Avoid using build_method_call.\n+\t* mangle.c (write_template_param): Remove misleading comment.\n+\t* method.c (locate_copy): Use non_reference.\n+\t* parser.c (cp_parser_scope_through_which_access_occurs): Remove.\n+\t(cp_parser_primary_expression): Do not create SCOPE_REFs is\n+\tnon-dependent contexts.\n+\t(cp_parser_postfix_expression): Use finish_qualified_id_expr.\n+\t(cp_parser_direct_declarator): Use tsubst_copy_and_build, not\n+\tbuild_expr_from_tree.\n+\t(cp_parser_lookup_name): Adjust call to lookup_qualified_name.\n+\tUse check_accessibility_of_qualified_id.\n+\t* pt.c (maybe_fold_nontype_arg): Use tsubst_copy_and_build, not\n+\tbuild_expr_from_tree.\n+\t(tsubst_baselink): New function.\n+\t(tsubst_qualified_id): Likewise.\n+\t(tsubst_copy): Use them.  Remove support for METHOD_CALL_EXPR.\n+\t(tsubst_expr): Adjust call to lookup_qualified_name.\n+\t(tsubst_copy_and_build): Handle SCOPE_REFs specially.  Adjust\n+\thandling of CALL_EXPRs.\n+\t(value_dependent_expression_p): Use INTEGRAL_OR_ENUMERATION_TYPE_P.\n+\t* rtti.c (get_tinfo_decl_dynamic): Use non_reference.\n+\t* search.c (check_final_overrider): Likewise.\n+\t* semantics.c (check_accessibility_of_qualified_id): New function.\n+\t(finish_qualified_object_call_expr): Remove.\n+\t* typeck.c (target_type): Use non_reference.\n+\t(cxx_sizeof_or_alignof_type): Likewise.\n+\t(dubious_conversion_warnings): Likewise.\n+\t(convert_for_initialization): Likewise.\n+\t(non_reference): New function.\n+\n 2003-07-07  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* decl.c (print_binding_level, print_other_binding_stack,"}, {"sha": "fbf5c06a32fed257b6216d4190b783b4b5a87c4f", "filename": "gcc/cp/call.c", "status": "modified", "additions": 5, "deletions": 120, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d", "patch": "@@ -87,7 +87,6 @@ static struct z_candidate *add_function_candidate\n static tree implicit_conversion (tree, tree, tree, int);\n static tree standard_conversion (tree, tree, tree);\n static tree reference_binding (tree, tree, tree, int);\n-static tree non_reference (tree);\n static tree build_conv (enum tree_code, tree, tree);\n static bool is_subseq (tree, tree);\n static tree maybe_handle_ref_bind (tree *);\n@@ -205,106 +204,6 @@ check_dtor_name (tree basetype, tree name)\n   return false;\n }\n \n-/* Build a method call of the form `EXP->SCOPES::NAME (PARMS)'.\n-   This is how virtual function calls are avoided.  */\n-\n-tree\n-build_scoped_method_call (tree exp, tree basetype, tree name, tree parms)\n-{\n-  /* Because this syntactic form does not allow\n-     a pointer to a base class to be `stolen',\n-     we need not protect the derived->base conversion\n-     that happens here.\n-     \n-     @@ But we do have to check access privileges later.  */\n-  tree binfo, decl;\n-  tree type = TREE_TYPE (exp);\n-\n-  if (type == error_mark_node\n-      || basetype == error_mark_node)\n-    return error_mark_node;\n-\n-  if (processing_template_decl)\n-    {\n-      name = build_min_nt (SCOPE_REF, basetype, name);\n-      return build_min_nt (METHOD_CALL_EXPR, name, exp, parms, NULL_TREE);\n-    }\n-\n-  if (TREE_CODE (type) == REFERENCE_TYPE)\n-    type = TREE_TYPE (type);\n-\n-  if (TREE_CODE (basetype) == TREE_VEC)\n-    {\n-      binfo = basetype;\n-      basetype = BINFO_TYPE (binfo);\n-    }\n-  else\n-    binfo = NULL_TREE;\n-\n-  /* Check the destructor call syntax.  */\n-  if (TREE_CODE (name) == BIT_NOT_EXPR)\n-    {\n-      /* We can get here if someone writes their destructor call like\n-\t `obj.NS::~T()'; this isn't really a scoped method call, so hand\n-\t it off.  */\n-      if (TREE_CODE (basetype) == NAMESPACE_DECL)\n-\treturn build_method_call (exp, name, parms, NULL_TREE, LOOKUP_NORMAL);\n-\n-      if (! check_dtor_name (basetype, name))\n-\terror (\"qualified type `%T' does not match destructor name `~%T'\",\n-\t\t  basetype, TREE_OPERAND (name, 0));\n-\n-      /* Destructors can be \"called\" for simple types; see 5.2.4 and 12.4 Note\n-\t that explicit ~int is caught in the parser; this deals with typedefs\n-\t and template parms.  */\n-      if (! IS_AGGR_TYPE (basetype))\n-\t{\n-\t  if (TYPE_MAIN_VARIANT (type) != TYPE_MAIN_VARIANT (basetype))\n-\t    error (\"type of `%E' does not match destructor type `%T' (type was `%T')\",\n-\t\t      exp, basetype, type);\n-\n-\t  return convert_to_void (exp, /*implicit=*/NULL);\n-\t}\n-    }\n-\n-  if (TREE_CODE (basetype) == NAMESPACE_DECL)\n-    {\n-      error (\"`%D' is a namespace\", basetype);\n-      return error_mark_node;\n-    }\n-  if (! is_aggr_type (basetype, 1))\n-    return error_mark_node;\n-\n-  if (! IS_AGGR_TYPE (type))\n-    {\n-      error (\"base object `%E' of scoped method call is of non-aggregate type `%T'\",\n-\t\texp, type);\n-      return error_mark_node;\n-    }\n-\n-  decl = build_scoped_ref (exp, basetype, &binfo);\n-\n-  if (binfo)\n-    {\n-      /* Call to a destructor.  */\n-      if (TREE_CODE (name) == BIT_NOT_EXPR)\n-\t{\n-\t  if (! TYPE_HAS_DESTRUCTOR (TREE_TYPE (decl)))\n-\t    return convert_to_void (exp, /*implicit=*/NULL);\n-\t  \n-\t  return build_delete (TREE_TYPE (decl), decl, \n-\t\t\t       sfk_complete_destructor,\n-\t\t\t       LOOKUP_NORMAL|LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR,\n-\t\t\t       0);\n-\t}\n-\n-      /* Call to a method.  */\n-      return build_method_call (decl, name, parms, binfo,\n-\t\t\t\tLOOKUP_NORMAL|LOOKUP_NONVIRTUAL);\n-    }\n-  return error_mark_node;\n-}\n-\n /* We want the address of a function or method.  We avoid creating a\n    pointer-to-member function.  */\n \n@@ -460,14 +359,12 @@ build_method_call (tree instance, tree name, tree parms,\n   n_build_method_call++;\n #endif\n \n-  if (instance == error_mark_node\n+  if (error_operand_p (instance)\n       || name == error_mark_node\n-      || parms == error_mark_node\n-      || (instance && TREE_TYPE (instance) == error_mark_node))\n+      || parms == error_mark_node)\n     return error_mark_node;\n \n-  if (processing_template_decl)\n-    return build_min_nt (METHOD_CALL_EXPR, name, instance, parms, NULL_TREE);\n+  my_friendly_assert (!processing_template_decl, 20030707);\n \n   if (TREE_CODE (TREE_TYPE (instance)) == REFERENCE_TYPE)\n     instance = convert_from_reference (instance);\n@@ -518,7 +415,7 @@ build_method_call (tree instance, tree name, tree parms,\n   else\n     fn = lookup_member (object_type, name, /*protect=*/2, /*want_type=*/false);\n   \n-  if (fn && TREE_CODE (fn) == TREE_LIST && !BASELINK_P (fn))\n+  if (fn && TREE_CODE (fn) == TREE_LIST)\n     {\n       error (\"request for member `%D' is ambiguous\", name);\n       print_candidates (fn);\n@@ -669,17 +566,6 @@ build_conv (enum tree_code code, tree type, tree from)\n   return t;\n }\n \n-/* If T is a REFERENCE_TYPE return the type to which T refers.\n-   Otherwise, return T itself.  */\n-\n-static tree\n-non_reference (tree t)\n-{\n-  if (TREE_CODE (t) == REFERENCE_TYPE)\n-    t = TREE_TYPE (t);\n-  return t;\n-}\n-\n tree\n strip_top_quals (tree t)\n {\n@@ -699,8 +585,7 @@ standard_conversion (tree to, tree from, tree expr)\n   tree conv;\n   bool fromref = false;\n \n-  if (TREE_CODE (to) == REFERENCE_TYPE)\n-    to = TREE_TYPE (to);\n+  to = non_reference (to);\n   if (TREE_CODE (from) == REFERENCE_TYPE)\n     {\n       fromref = true;"}, {"sha": "5c276a4a3d03feadc2678a08798296f9d7588af4", "filename": "gcc/cp/class.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d", "patch": "@@ -401,9 +401,7 @@ build_vtable_entry_ref (tree array_ref, tree instance, tree idx)\n {\n   tree i, i2, vtable, first_fn, basetype;\n \n-  basetype = TREE_TYPE (instance);\n-  if (TREE_CODE (basetype) == REFERENCE_TYPE)\n-    basetype = TREE_TYPE (basetype);\n+  basetype = non_reference (TREE_TYPE (instance));\n \n   vtable = get_vtbl_decl_for_binfo (TYPE_BINFO (basetype));\n   first_fn = TYPE_BINFO_VTABLE (basetype);\n@@ -439,9 +437,7 @@ build_vtbl_ref_1 (tree instance, tree idx)\n   int cdtorp = 0;\n   tree fixed_type = fixed_type_or_null (instance, NULL, &cdtorp);\n \n-  tree basetype = TREE_TYPE (instance);\n-  if (TREE_CODE (basetype) == REFERENCE_TYPE)\n-    basetype = TREE_TYPE (basetype);\n+  tree basetype = non_reference (TREE_TYPE (instance));\n \n   if (fixed_type && !cdtorp)\n     {"}, {"sha": "9d383cf24aef768d21906090d2e914bb658b5b0f", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d", "patch": "@@ -3493,7 +3493,6 @@ extern GTY(()) operator_name_info_t assignment_operator_name_info\n extern bool check_dtor_name (tree, tree);\n \n extern tree build_vfield_ref\t\t\t(tree, tree);\n-extern tree build_scoped_method_call (tree, tree, tree, tree);\n extern tree build_conditional_expr\t\t(tree, tree, tree);\n extern tree build_addr_func (tree);\n extern tree build_call (tree, tree);\n@@ -3660,7 +3659,7 @@ extern tree make_typename_type\t\t\t(tree, tree, tsubst_flags_t);\n extern tree make_unbound_class_template\t\t(tree, tree, tsubst_flags_t);\n extern tree lookup_name_nonclass\t\t(tree);\n extern tree lookup_function_nonclass            (tree, tree);\n-extern tree lookup_qualified_name               (tree, tree, bool, int);\n+extern tree lookup_qualified_name               (tree, tree, bool);\n extern tree lookup_name\t\t\t\t(tree, int);\n extern tree lookup_name_current_level\t\t(tree);\n extern tree lookup_type_current_level\t\t(tree);\n@@ -3775,7 +3774,6 @@ extern void import_export_decl (tree);\n extern void import_export_tinfo\t(tree, tree, bool);\n extern void finish_file\t\t\t\t(void);\n extern tree build_cleanup\t\t\t(tree);\n-extern tree build_expr_from_tree\t\t(tree);\n extern tree build_offset_ref_call_from_tree     (tree, tree);\n extern tree build_call_from_tree                (tree, tree, bool);\n extern void set_decl_namespace (tree, tree, bool);\n@@ -3967,6 +3965,7 @@ extern tree most_specialized_instantiation      (tree);\n extern void print_candidates                    (tree);\n extern int instantiate_pending_templates        (void);\n extern tree tsubst_default_argument             (tree, tree, tree);\n+extern tree tsubst_copy_and_build               (tree, tree, tsubst_flags_t, tree);\n extern tree most_general_template\t\t(tree);\n extern tree get_mostly_instantiated_function_type (tree);\n extern int problematic_instantiation_changed    (void);\n@@ -4114,7 +4113,6 @@ extern tree finish_call_expr                    (tree, tree, bool);\n extern tree finish_increment_expr               (tree, enum tree_code);\n extern tree finish_this_expr                    (void);\n extern tree finish_object_call_expr             (tree, tree, tree);\n-extern tree finish_qualified_object_call_expr   (tree, tree, tree);\n extern tree finish_pseudo_destructor_expr       (tree, tree, tree);\n extern tree finish_unary_op_expr                (enum tree_code, tree);\n extern tree finish_compound_literal             (tree, tree);\n@@ -4149,6 +4147,8 @@ extern tree begin_global_stmt_expr              (void);\n extern tree finish_global_stmt_expr             (tree);\n extern tree check_template_template_default_arg (tree);\n extern void expand_or_defer_fn\t\t\t(tree);\n+extern void check_accessibility_of_qualified_id (tree, tree, tree);\n+extern tree finish_qualified_id_expr            (tree, tree, bool, bool);\n \n /* in tree.c */\n extern void lang_check_failed\t\t\t(const char *, int,\n@@ -4299,6 +4299,7 @@ extern tree check_return_expr                   (tree);\n extern tree build_ptrmemfunc_access_expr       (tree, tree);\n extern tree build_address                       (tree);\n extern tree build_nop                           (tree, tree);\n+extern tree non_reference                       (tree);\n \n /* in typeck2.c */\n extern void require_complete_eh_spec_types\t(tree, tree);"}, {"sha": "bc9b309fa25e1f95bee9a2c54a4324eea9254968", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d", "patch": "@@ -1077,9 +1077,7 @@ build_expr_type_conversion (int desires, tree expr, bool complain)\n       if (winner && winner == cand)\n \tcontinue;\n \n-      candidate = TREE_TYPE (TREE_TYPE (cand));\n-      if (TREE_CODE (candidate) == REFERENCE_TYPE)\n-\tcandidate = TREE_TYPE (candidate);\n+      candidate = non_reference (TREE_TYPE (TREE_TYPE (cand)));\n \n       switch (TREE_CODE (candidate))\n \t{\n@@ -1117,9 +1115,7 @@ build_expr_type_conversion (int desires, tree expr, bool complain)\n \n   if (winner)\n     {\n-      tree type = TREE_TYPE (TREE_TYPE (winner));\n-      if (TREE_CODE (type) == REFERENCE_TYPE)\n-\ttype = TREE_TYPE (type);\n+      tree type = non_reference (TREE_TYPE (TREE_TYPE (winner)));\n       return build_user_type_conversion (type, expr, LOOKUP_NORMAL);\n     }\n "}, {"sha": "f0aef38513f283243aa46336f3a61945434751c0", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d", "patch": "@@ -5770,8 +5770,10 @@ qualify_lookup (tree val, int flags)\n    declaration found.  */\n \n tree\n-lookup_qualified_name (tree scope, tree name, bool is_type_p, int flags)\n+lookup_qualified_name (tree scope, tree name, bool is_type_p)\n {\n+  int flags = 0;\n+\n   if (TREE_CODE (scope) == NAMESPACE_DECL)\n     {\n       cxx_binding binding;\n@@ -5780,12 +5782,15 @@ lookup_qualified_name (tree scope, tree name, bool is_type_p, int flags)\n       flags |= LOOKUP_COMPLAIN;\n       if (is_type_p)\n \tflags |= LOOKUP_PREFER_TYPES;\n-      if (!qualified_lookup_using_namespace (name, scope, &binding, flags))\n+      if (!qualified_lookup_using_namespace (name, scope, &binding, \n+\t\t\t\t\t     flags))\n \treturn NULL_TREE;\n       return select_decl (&binding, flags);\n     }\n-  else\n+  else if (is_aggr_type (scope, /*or_else=*/1))\n     return lookup_member (scope, name, 0, is_type_p);\n+  else\n+    return error_mark_node;\n }\n \n /* Check to see whether or not DECL is a variable that would have been\n@@ -12320,9 +12325,7 @@ grok_op_properties (tree decl, int friendp)\n \t      if (p)\n \t\tfor (; TREE_CODE (TREE_VALUE (p)) != VOID_TYPE ; p = TREE_CHAIN (p))\n \t\t  {\n-\t\t    tree arg = TREE_VALUE (p);\n-\t\t    if (TREE_CODE (arg) == REFERENCE_TYPE)\n-\t\t      arg = TREE_TYPE (arg);\n+\t\t    tree arg = non_reference (TREE_VALUE (p));\n \n \t\t    /* This lets bad template code slip through.  */\n \t\t    if (IS_AGGR_TYPE (arg)"}, {"sha": "7158f1021471f192a64f5bce96457b4d06c1f637", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 3, "deletions": 423, "changes": 426, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d", "patch": "@@ -409,8 +409,7 @@ grok_array_decl (tree array_expr, tree index_exp)\n \n   my_friendly_assert (type, 20030626);\n \n-  if (TREE_CODE (type) == REFERENCE_TYPE)\n-    type = TREE_TYPE (type);\n+  type = non_reference (type);\n \n   /* If they have an `operator[]', use that.  */\n   if (IS_AGGR_TYPE (type) || IS_AGGR_TYPE (TREE_TYPE (index_exp)))\n@@ -2938,415 +2937,6 @@ finish_file ()\n   input_location = locus;\n }\n \n-/* T is the parse tree for an expression.  Return the expression after\n-   performing semantic analysis.  */\n-\n-tree\n-build_expr_from_tree (tree t)\n-{\n-  if (t == NULL_TREE || t == error_mark_node)\n-    return t;\n-\n-  switch (TREE_CODE (t))\n-    {\n-    case IDENTIFIER_NODE:\n-      return do_identifier (t, NULL_TREE);\n-\n-    case LOOKUP_EXPR:\n-      if (LOOKUP_EXPR_GLOBAL (t))\n-\t{\n-\t  tree token = TREE_OPERAND (t, 0);\n-\t  return do_scoped_id (token, IDENTIFIER_GLOBAL_VALUE (token));\n-\t}\n-      else\n-\t{\n-\t  t = do_identifier (TREE_OPERAND (t, 0), NULL_TREE);\n-\t  if (TREE_CODE (t) == ALIAS_DECL)\n-\t    t = DECL_INITIAL (t);\n-\t  return t;\n-\t}\n-\n-    case TEMPLATE_ID_EXPR:\n-      {\n-\ttree template;\n-\ttree args;\n-\ttree object;\n-\n-\ttemplate = build_expr_from_tree (TREE_OPERAND (t, 0));\n-\targs = build_expr_from_tree (TREE_OPERAND (t, 1));\n-\t\n-\tif (TREE_CODE (template) == COMPONENT_REF)\n-\t  {\n-\t    object = TREE_OPERAND (template, 0);\n-\t    template = TREE_OPERAND (template, 1);\n-\t  }\n-\telse\n-\t  object = NULL_TREE;\n-\n-\ttemplate = lookup_template_function (template, args);\n-\tif (object)\n-\t  return build (COMPONENT_REF, TREE_TYPE (template), \n-\t\t\tobject, template);\n-\telse\n-\t  return template;\n-      }\n-\n-    case INDIRECT_REF:\n-      return build_x_indirect_ref\n-\t(build_expr_from_tree (TREE_OPERAND (t, 0)), \"unary *\");\n-\n-    case CAST_EXPR:\n-      return build_functional_cast\n-\t(TREE_TYPE (t), build_expr_from_tree (TREE_OPERAND (t, 0)));\n-\n-    case REINTERPRET_CAST_EXPR:\n-      return build_reinterpret_cast\n-\t(TREE_TYPE (t), build_expr_from_tree (TREE_OPERAND (t, 0)));\n-\n-    case CONST_CAST_EXPR:\n-      return build_const_cast\n-\t(TREE_TYPE (t), build_expr_from_tree (TREE_OPERAND (t, 0)));\n-\n-    case DYNAMIC_CAST_EXPR:\n-      return build_dynamic_cast\n-\t(TREE_TYPE (t), build_expr_from_tree (TREE_OPERAND (t, 0)));\n-\n-    case STATIC_CAST_EXPR:\n-      return build_static_cast\n-\t(TREE_TYPE (t), build_expr_from_tree (TREE_OPERAND (t, 0)));\n-\n-    case PREDECREMENT_EXPR:\n-    case PREINCREMENT_EXPR:\n-    case POSTDECREMENT_EXPR:\n-    case POSTINCREMENT_EXPR:\n-    case NEGATE_EXPR:\n-    case BIT_NOT_EXPR:\n-    case ABS_EXPR:\n-    case TRUTH_NOT_EXPR:\n-    case ADDR_EXPR:\n-    case CONVERT_EXPR:      /* Unary + */\n-    case REALPART_EXPR:\n-    case IMAGPART_EXPR:\n-      if (TREE_TYPE (t))\n-\treturn t;\n-      return build_x_unary_op (TREE_CODE (t),\n-\t\t\t       build_expr_from_tree (TREE_OPERAND (t, 0)));\n-\n-    case PLUS_EXPR:\n-    case MINUS_EXPR:\n-    case MULT_EXPR:\n-    case TRUNC_DIV_EXPR:\n-    case CEIL_DIV_EXPR:\n-    case FLOOR_DIV_EXPR:\n-    case ROUND_DIV_EXPR:\n-    case EXACT_DIV_EXPR:\n-    case BIT_AND_EXPR:\n-    case BIT_ANDTC_EXPR:\n-    case BIT_IOR_EXPR:\n-    case BIT_XOR_EXPR:\n-    case TRUNC_MOD_EXPR:\n-    case FLOOR_MOD_EXPR:\n-    case TRUTH_ANDIF_EXPR:\n-    case TRUTH_ORIF_EXPR:\n-    case TRUTH_AND_EXPR:\n-    case TRUTH_OR_EXPR:\n-    case RSHIFT_EXPR:\n-    case LSHIFT_EXPR:\n-    case RROTATE_EXPR:\n-    case LROTATE_EXPR:\n-    case EQ_EXPR:\n-    case NE_EXPR:\n-    case MAX_EXPR:\n-    case MIN_EXPR:\n-    case LE_EXPR:\n-    case GE_EXPR:\n-    case LT_EXPR:\n-    case GT_EXPR:\n-    case MEMBER_REF:\n-      return build_x_binary_op\n-\t(TREE_CODE (t), \n-\t build_expr_from_tree (TREE_OPERAND (t, 0)),\n-\t build_expr_from_tree (TREE_OPERAND (t, 1)));\n-\n-    case DOTSTAR_EXPR:\n-      return build_m_component_ref\n-\t(build_expr_from_tree (TREE_OPERAND (t, 0)),\n-\t build_expr_from_tree (TREE_OPERAND (t, 1)));\n-\n-    case SCOPE_REF:\n-      return build_offset_ref (TREE_OPERAND (t, 0), TREE_OPERAND (t, 1));\n-\n-    case ARRAY_REF:\n-      if (TREE_OPERAND (t, 0) == NULL_TREE)\n-\t/* new-type-id */\n-\treturn build_nt (ARRAY_REF, NULL_TREE,\n-\t\t\t build_expr_from_tree (TREE_OPERAND (t, 1)));\n-      return grok_array_decl (build_expr_from_tree (TREE_OPERAND (t, 0)),\n-\t\t\t      build_expr_from_tree (TREE_OPERAND (t, 1)));\n-\n-    case SIZEOF_EXPR:\n-    case ALIGNOF_EXPR:\n-      {\n-\ttree r = build_expr_from_tree (TREE_OPERAND (t, 0));\n-\tif (!TYPE_P (r))\n-\t  return TREE_CODE (t) == SIZEOF_EXPR ? expr_sizeof (r) : c_alignof_expr (r);\n-\telse\n-\t  return cxx_sizeof_or_alignof_type (r, TREE_CODE (t), true);\n-      }\n-\n-    case MODOP_EXPR:\n-      return build_x_modify_expr\n-\t(build_expr_from_tree (TREE_OPERAND (t, 0)),\n-\t TREE_CODE (TREE_OPERAND (t, 1)),\n-\t build_expr_from_tree (TREE_OPERAND (t, 2)));\n-\n-    case ARROW_EXPR:\n-      return build_x_arrow\n-\t(build_expr_from_tree (TREE_OPERAND (t, 0)));\n-\n-    case NEW_EXPR:\n-      return build_new\n-\t(build_expr_from_tree (TREE_OPERAND (t, 0)),\n-\t build_expr_from_tree (TREE_OPERAND (t, 1)),\n-\t build_expr_from_tree (TREE_OPERAND (t, 2)),\n-\t NEW_EXPR_USE_GLOBAL (t));\n-\n-    case DELETE_EXPR:\n-      return delete_sanity\n-\t(build_expr_from_tree (TREE_OPERAND (t, 0)),\n-\t build_expr_from_tree (TREE_OPERAND (t, 1)),\n-\t DELETE_EXPR_USE_VEC (t), DELETE_EXPR_USE_GLOBAL (t));\n-\n-    case COMPOUND_EXPR:\n-      if (TREE_OPERAND (t, 1) == NULL_TREE)\n-\treturn build_x_compound_expr\n-\t  (build_expr_from_tree (TREE_OPERAND (t, 0)));\n-      else\n-\tabort ();\n-\n-    case METHOD_CALL_EXPR:\n-      if (TREE_CODE (TREE_OPERAND (t, 0)) == SCOPE_REF)\n-\t{\n-\t  tree ref = TREE_OPERAND (t, 0);\n-\t  tree name = TREE_OPERAND (ref, 1);\n-\t  \n-\t  if (TREE_CODE (name) == TEMPLATE_ID_EXPR)\n-\t    name = build_nt (TEMPLATE_ID_EXPR,\n-\t                     TREE_OPERAND (name, 0),\n-\t                     build_expr_from_tree (TREE_OPERAND (name, 1)));\n-\t    \n-\t  return build_scoped_method_call\n-\t    (build_expr_from_tree (TREE_OPERAND (t, 1)),\n-\t     build_expr_from_tree (TREE_OPERAND (ref, 0)),\n-\t     name,\n-\t     build_expr_from_tree (TREE_OPERAND (t, 2)));\n-\t}\n-      else \n-\t{\n-\t  tree fn = TREE_OPERAND (t, 0);\n-\n-\t  /* We can get a TEMPLATE_ID_EXPR here on code like:\n-\n-\t       x->f<2>();\n-\t      \n-\t     so we must resolve that.  However, we can also get things\n-\t     like a BIT_NOT_EXPR here, when referring to a destructor,\n-\t     and things like that are not correctly resolved by\n-\t     build_expr_from_tree.  So, just use build_expr_from_tree\n-\t     when we really need it.  */\n-\t  if (TREE_CODE (fn) == TEMPLATE_ID_EXPR)\n-\t    fn = lookup_template_function\n-\t      (TREE_OPERAND (fn, 0),\n-\t       build_expr_from_tree (TREE_OPERAND (fn, 1)));\n-\n-\t  return build_method_call\n-\t    (build_expr_from_tree (TREE_OPERAND (t, 1)),\n-\t     fn,\n-\t     build_expr_from_tree (TREE_OPERAND (t, 2)),\n-\t     NULL_TREE, LOOKUP_NORMAL);\n-\t}\n-\n-    case CALL_EXPR:\n-      if (TREE_CODE (TREE_OPERAND (t, 0)) == SCOPE_REF)\n-\t{\n-\t  tree ref = TREE_OPERAND (t, 0);\n-\t  tree name = TREE_OPERAND (ref, 1);\n-\t  tree fn, scope, args;\n-\t  \n-\t  if (TREE_CODE (name) == TEMPLATE_ID_EXPR)\n-\t    name = build_nt (TEMPLATE_ID_EXPR,\n-\t                     TREE_OPERAND (name, 0),\n-\t                     build_expr_from_tree (TREE_OPERAND (name, 1)));\n-\n-\t  scope = build_expr_from_tree (TREE_OPERAND (ref, 0));\n-\t  args = build_expr_from_tree (TREE_OPERAND (t, 1));\n-\t  fn = resolve_scoped_fn_name (scope, name);\n-\t  \n-\t  return build_call_from_tree (fn, args, 1);\n-\t}\n-      else\n-\t{\n-\t  tree name = TREE_OPERAND (t, 0);\n-          tree id;\n-          tree args = build_expr_from_tree (TREE_OPERAND (t, 1));\n-          if (args != NULL_TREE && TREE_CODE (name) == LOOKUP_EXPR\n-              && !LOOKUP_EXPR_GLOBAL (name)\n-              && TREE_CODE ((id = TREE_OPERAND (name, 0))) == IDENTIFIER_NODE\n-              && (!current_class_type\n-                  || !lookup_member (current_class_type, id, 0, false)))\n-            {\n-              /* Do Koenig lookup if there are no class members.  */\n-              name = do_identifier (id, args);\n-            }\n-          else if (TREE_CODE (name) == TEMPLATE_ID_EXPR\n-\t\t   || ! really_overloaded_fn (name))\n-\t    name = build_expr_from_tree (name);\n-\n-\t  if (TREE_CODE (name) == OFFSET_REF)\n-\t    return build_offset_ref_call_from_tree (name, args);\n-\t  if (TREE_CODE (name) == COMPONENT_REF)\n-\t    return finish_object_call_expr (TREE_OPERAND (name, 1),\n-\t\t\t\t\t    TREE_OPERAND (name, 0),\n-\t\t\t\t\t    args);\n-\t  name = convert_from_reference (name);\n-\t  return build_call_from_tree (name, args, \n-\t\t\t\t       /*disallow_virtual=*/false);\n-\t}\n-\n-    case COND_EXPR:\n-      return build_x_conditional_expr\n-\t(build_expr_from_tree (TREE_OPERAND (t, 0)),\n-\t build_expr_from_tree (TREE_OPERAND (t, 1)),\n-\t build_expr_from_tree (TREE_OPERAND (t, 2)));\n-\n-    case PSEUDO_DTOR_EXPR:\n-      return (finish_pseudo_destructor_expr \n-\t      (build_expr_from_tree (TREE_OPERAND (t, 0)),\n-\t       build_expr_from_tree (TREE_OPERAND (t, 1)),\n-\t       build_expr_from_tree (TREE_OPERAND (t, 2))));\n-\n-    case TREE_LIST:\n-      {\n-\ttree purpose, value, chain;\n-\n-\tif (t == void_list_node)\n-\t  return t;\n-\n-\tpurpose = TREE_PURPOSE (t);\n-\tif (purpose)\n-\t  purpose = build_expr_from_tree (purpose);\n-\tvalue = TREE_VALUE (t);\n-\tif (value)\n-\t  value = build_expr_from_tree (value);\n-\tchain = TREE_CHAIN (t);\n-\tif (chain && chain != void_type_node)\n-\t  chain = build_expr_from_tree (chain);\n-\treturn tree_cons (purpose, value, chain);\n-      }\n-\n-    case COMPONENT_REF:\n-      {\n-\ttree object = build_expr_from_tree (TREE_OPERAND (t, 0));\n-\ttree member = TREE_OPERAND (t, 1);\n-\n-\tif (!CLASS_TYPE_P (TREE_TYPE (object)))\n-\t  {\n-\t    if (TREE_CODE (member) == BIT_NOT_EXPR)\n-\t      return finish_pseudo_destructor_expr (object, \n-\t\t\t\t\t\t    NULL_TREE,\n-\t\t\t\t\t\t    TREE_TYPE (object));\n-\t    else if (TREE_CODE (member) == SCOPE_REF\n-\t\t     && (TREE_CODE (TREE_OPERAND (member, 1)) == BIT_NOT_EXPR))\n-\t      return finish_pseudo_destructor_expr (object, \n-\t\t\t\t\t\t    TREE_OPERAND (t, 0),\n-\t\t\t\t\t\t    TREE_TYPE (object));\n-\t  }\n-\telse if (TREE_CODE (member) == SCOPE_REF\n-\t\t && TREE_CODE (TREE_OPERAND (member, 1)) == TEMPLATE_ID_EXPR)\n-\t  {\n-\t    tree tmpl;\n-\t    tree args;\n-\t\n-\t    /* Lookup the template functions now that we know what the\n-\t       scope is.  */\n-\t    tmpl = TREE_OPERAND (TREE_OPERAND (member, 1), 0);\n-\t    args = TREE_OPERAND (TREE_OPERAND (member, 1), 1);\n-\t    member = lookup_qualified_name (TREE_OPERAND (member, 0),\n-\t\t\t\t\t    tmpl, \n-\t\t\t\t\t    /*is_type=*/0,\n-\t\t\t\t\t    /*flags=*/0);\n-\t    if (BASELINK_P (member))\n-\t      BASELINK_FUNCTIONS (member) \n-\t\t= build_nt (TEMPLATE_ID_EXPR, BASELINK_FUNCTIONS (member),\n-\t\t\t    args);\n-\t    else\n-\t      {\n-\t\terror (\"`%D' is not a member of `%T'\",\n-\t\t       tmpl, TREE_TYPE (object));\n-\t\treturn error_mark_node;\n-\t      }\n-\t  }\n-\n-\n-\treturn finish_class_member_access_expr (object, member);\n-      }\n-\n-    case THROW_EXPR:\n-      return build_throw (build_expr_from_tree (TREE_OPERAND (t, 0)));\n-\n-    case CONSTRUCTOR:\n-      {\n-\ttree r;\n-\ttree elts;\n-\ttree type = TREE_TYPE (t);\n-\tbool purpose_p;\n-\n-\t/* digest_init will do the wrong thing if we let it.  */\n-\tif (type && TYPE_PTRMEMFUNC_P (type))\n-\t  return t;\n-\n-\tr = NULL_TREE;\n-\t/* We do not want to process the purpose of aggregate\n-\t   initializers as they are identifier nodes which will be\n-\t   looked up by digest_init.  */\n-\tpurpose_p = !(type && IS_AGGR_TYPE (type));\n-\tfor (elts = CONSTRUCTOR_ELTS (t); elts; elts = TREE_CHAIN (elts))\n-\t  {\n-\t    tree purpose = TREE_PURPOSE (elts);\n-\t    tree value = TREE_VALUE (elts);\n-\t    \n-\t    if (purpose && purpose_p)\n-\t      purpose = build_expr_from_tree (purpose);\n-\t    value = build_expr_from_tree (value);\n-\t    r = tree_cons (purpose, value, r);\n-\t  }\n-\t\n-\tr = build_constructor (NULL_TREE, nreverse (r));\n-\tTREE_HAS_CONSTRUCTOR (r) = TREE_HAS_CONSTRUCTOR (t);\n-\n-\tif (type)\n-\t  return digest_init (type, r, 0);\n-\treturn r;\n-      }\n-\n-    case TYPEID_EXPR:\n-      if (TYPE_P (TREE_OPERAND (t, 0)))\n-\treturn get_typeid (TREE_OPERAND (t, 0));\n-      return build_typeid (build_expr_from_tree (TREE_OPERAND (t, 0)));\n-\n-    case PARM_DECL:\n-    case VAR_DECL:\n-      return convert_from_reference (t);\n-\n-    case VA_ARG_EXPR:\n-      return build_va_arg (build_expr_from_tree (TREE_OPERAND (t, 0)),\n-\t\t\t   TREE_TYPE (t));\n-\n-    default:\n-      return t;\n-    }\n-}\n-\n /* FN is an OFFSET_REF indicating the function to call in parse-tree\n    form; it has not yet been semantically analyzed.  ARGS are the\n    arguments to the function.  They have already been semantically\n@@ -3359,22 +2949,12 @@ build_offset_ref_call_from_tree (tree fn, tree args)\n \n   my_friendly_assert (TREE_CODE (fn) == OFFSET_REF, 20020725);\n \n-  /* A qualified name corresponding to a non-static member\n-     function or a pointer-to-member is represented as an \n-     OFFSET_REF.  \n-\n-     For both of these function calls, FN will be an OFFSET_REF.\n-\n-\tstruct A { void f(); };\n-\tvoid A::f() { (A::f) (); } \n+  /* A qualified name corresponding to a bound pointer-to-member is\n+     represented as an OFFSET_REF:\n \n \tstruct B { void g(); };\n \tvoid (B::*p)();\n \tvoid B::g() { (this->*p)(); }  */\n-\n-  /* This code is not really correct (for example, it does not\n-     handle the case that `A::f' is overloaded), but it is\n-     historically how we have handled this situation.  */\n   if (TREE_CODE (TREE_OPERAND (fn, 1)) == FIELD_DECL)\n     /* This case should now be handled elsewhere.  */\n     abort ();"}, {"sha": "a9f5b15834accd3ee7c1733971213c9af0519f8e", "filename": "gcc/cp/error.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d", "patch": "@@ -2230,6 +2230,8 @@ language_to_string (enum languages c)\n static const char *\n parm_to_string (int p)\n {\n+  reinit_global_formatting_buffer ();\n+\n   if (p < 0)\n     output_add_string (scratch_buffer, \"'this'\");\n   else"}, {"sha": "390f12c45514919198ae30a7088be6ddeb662530", "filename": "gcc/cp/except.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d", "patch": "@@ -107,8 +107,7 @@ prepare_eh_type (tree type)\n     return error_mark_node;\n \n   /* peel back references, so they match.  */\n-  if (TREE_CODE (type) == REFERENCE_TYPE)\n-    type = TREE_TYPE (type);\n+  type = non_reference (type);\n \n   /* Peel off cv qualifiers.  */\n   type = TYPE_MAIN_VARIANT (type);\n@@ -872,10 +871,8 @@ nothrow_libfn_p (tree fn)\n static int\n can_convert_eh (tree to, tree from)\n {\n-  if (TREE_CODE (to) == REFERENCE_TYPE)\n-    to = TREE_TYPE (to);\n-  if (TREE_CODE (from) == REFERENCE_TYPE)\n-    from = TREE_TYPE (from);\n+  to = non_reference (to);\n+  from = non_reference (from);\n \n   if (TREE_CODE (to) == POINTER_TYPE && TREE_CODE (from) == POINTER_TYPE)\n     {"}, {"sha": "f89b4248e65fa37b71c5359532212afda3b462ad", "filename": "gcc/cp/init.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d", "patch": "@@ -2915,7 +2915,7 @@ static tree\n build_dtor_call (tree exp, special_function_kind dtor_kind, int flags)\n {\n   tree name;\n-\n+  tree fn;\n   switch (dtor_kind)\n     {\n     case sfk_complete_destructor:\n@@ -2933,8 +2933,13 @@ build_dtor_call (tree exp, special_function_kind dtor_kind, int flags)\n     default:\n       abort ();\n     }\n-  return build_method_call (exp, name, NULL_TREE, \n-\t\t\t    TYPE_BINFO (TREE_TYPE (exp)), flags);\n+\n+  exp = convert_from_reference (exp);\n+  fn = lookup_fnfields (TREE_TYPE (exp), name, /*protect=*/2);\n+  return build_new_method_call (exp, fn, \n+\t\t\t\t/*args=*/NULL_TREE,\n+\t\t\t\t/*conversion_path=*/NULL_TREE,\n+\t\t\t\tflags);\n }\n \n /* Generate a call to a destructor. TYPE is the type to cast ADDR to."}, {"sha": "63c58baf059e2ed638731804f2e58098cc54886b", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d", "patch": "@@ -2197,14 +2197,7 @@ write_pointer_to_member_type (const tree type)\n    TEMPLATE_TEMPLATE_PARM, BOUND_TEMPLATE_TEMPLATE_PARM or a\n    TEMPLATE_PARM_INDEX.\n \n-     <template-param> ::= T </parameter/ number> _\n-\n-   If we are internally mangling then we distinguish level and, for\n-   non-type parms, type too. The mangling appends\n-   \n-     </level/ number> _ </non-type type/ type> _\n-\n-   This is used by mangle_conv_op_name_for_type.  */\n+     <template-param> ::= T </parameter/ number> _  */\n \n static void\n write_template_param (const tree parm)"}, {"sha": "e1ffaad3769ae53aef72a6d4cc65689e8e4155cd", "filename": "gcc/cp/method.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d", "patch": "@@ -1000,9 +1000,7 @@ locate_copy (tree type, void *client_)\n       parms = TREE_CHAIN (parms);\n       if (!parms)\n         continue;\n-      src_type = TREE_VALUE (parms);\n-      if (TREE_CODE (src_type) == REFERENCE_TYPE)\n-        src_type = TREE_TYPE (src_type);\n+      src_type = non_reference (TREE_VALUE (parms));\n       if (!same_type_ignoring_top_level_qualifiers_p (src_type, type))\n         continue;\n       if (!sufficient_parms_p (TREE_CHAIN (parms)))"}, {"sha": "27e73cb967fa7af638170a79585e72e66920065d", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 37, "deletions": 141, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d", "patch": "@@ -1717,8 +1717,6 @@ static bool cp_parser_is_string_literal\n   (cp_token *);\n static bool cp_parser_is_keyword \n   (cp_token *, enum rid);\n-static tree cp_parser_scope_through_which_access_occurs\n-  (tree, tree, tree);\n \n /* Returns nonzero if we are parsing tentatively.  */\n \n@@ -1744,62 +1742,6 @@ cp_parser_is_keyword (cp_token* token, enum rid keyword)\n   return token->keyword == keyword;\n }\n \n-/* Returns the scope through which DECL is being accessed, or\n-   NULL_TREE if DECL is not a member.  If OBJECT_TYPE is non-NULL, we\n-   have just seen `x->' or `x.' and OBJECT_TYPE is the type of `*x',\n-   or `x', respectively.  If the DECL was named as `A::B' then\n-   NESTED_NAME_SPECIFIER is `A'.  */\n-\n-static tree\n-cp_parser_scope_through_which_access_occurs (tree decl, \n-\t\t\t\t\t     tree object_type,\n-\t\t\t\t\t     tree nested_name_specifier)\n-{\n-  tree scope;\n-  tree qualifying_type = NULL_TREE;\n-  \n-  /* Determine the SCOPE of DECL.  */\n-  scope = context_for_name_lookup (decl);\n-  /* If the SCOPE is not a type, then DECL is not a member.  */\n-  if (!TYPE_P (scope))\n-    return NULL_TREE;\n-  /* Figure out the type through which DECL is being accessed.  */\n-  if (object_type \n-      /* OBJECT_TYPE might not be a class type; consider:\n-\n-\t   class A { typedef int I; };\n-\t   I *p;\n-\t   p->A::I::~I();\n-\n-         In this case, we will have \"A::I\" as the DECL, but \"I\" as the\n-\t OBJECT_TYPE.  */\n-      && CLASS_TYPE_P (object_type)\n-      && DERIVED_FROM_P (scope, object_type))\n-    /* If we are processing a `->' or `.' expression, use the type of the\n-       left-hand side.  */\n-    qualifying_type = object_type;\n-  else if (nested_name_specifier)\n-    {\n-      /* If the reference is to a non-static member of the\n-\t current class, treat it as if it were referenced through\n-\t `this'.  */\n-      if (DECL_NONSTATIC_MEMBER_P (decl)\n-\t  && current_class_ptr\n-\t  && DERIVED_FROM_P (scope, current_class_type))\n-\tqualifying_type = current_class_type;\n-      /* Otherwise, use the type indicated by the\n-\t nested-name-specifier.  */\n-      else\n-\tqualifying_type = nested_name_specifier;\n-    }\n-  else\n-    /* Otherwise, the name must be from the current class or one of\n-       its bases.  */\n-    qualifying_type = currently_open_derived_class (scope);\n-\n-  return qualifying_type;\n-}\n-\n /* Issue the indicated error MESSAGE.  */\n \n static void\n@@ -2600,7 +2542,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \telse\n \t  {\n \t    bool dependent_p;\n-\t    \n+\n \t    /* If the declaration was explicitly qualified indicate\n \t       that.  The semantics of `A::f(3)' are different than\n \t       `f(3)' if `f' is virtual.  */\n@@ -2710,7 +2652,8 @@ cp_parser_primary_expression (cp_parser *parser,\n \t       we will resolve the name at instantiation time.  */\n \t    if (dependent_p)\n \t      {\n-\t\t/* Create a SCOPE_REF for qualified names.  */\n+\t\t/* Create a SCOPE_REF for qualified names, if the\n+\t\t   scope is dependent.  */\n \t\tif (parser->scope)\n \t\t  {\n \t\t    if (TYPE_P (parser->scope))\n@@ -2720,9 +2663,13 @@ cp_parser_primary_expression (cp_parser *parser,\n \t\t       might be constant when things are instantiated.  */\n \t\t    if (parser->constant_expression_p)\n \t\t      parser->non_constant_expression_p = true;\n-\t\t    return build_nt (SCOPE_REF, \n-\t\t\t\t     parser->scope, \n-\t\t\t\t     id_expression);\n+\t\t    if (TYPE_P (parser->scope)\n+\t\t\t&& dependent_type_p (parser->scope))\n+\t\t      return build_nt (SCOPE_REF, \n+\t\t\t\t       parser->scope, \n+\t\t\t\t       id_expression);\n+\t\t    else\n+\t\t      return decl;\n \t\t  }\n \t\t/* A TEMPLATE_ID already contains all the information\n \t\t   we need.  */\n@@ -3523,7 +3470,6 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n      form a pointer-to-member.  In that case, QUALIFYING_CLASS is the\n      class used to qualify the member.  */\n   tree qualifying_class = NULL_TREE;\n-  bool done;\n \n   /* Peek at the next token.  */\n   token = cp_lexer_peek_token (parser->lexer);\n@@ -3752,68 +3698,28 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n       break;\n     }\n \n-  /* Peek at the next token.  */\n-  token = cp_lexer_peek_token (parser->lexer);\n-  done = (token->type != CPP_OPEN_SQUARE\n-\t  && token->type != CPP_OPEN_PAREN\n-\t  && token->type != CPP_DOT\n-\t  && token->type != CPP_DEREF\n-\t  && token->type != CPP_PLUS_PLUS\n-\t  && token->type != CPP_MINUS_MINUS);\n-\n-  /* If the postfix expression is complete, finish up.  */\n-  if (address_p && qualifying_class && done)\n-    {\n-      if (TREE_CODE (postfix_expression) == SCOPE_REF)\n-\tpostfix_expression = TREE_OPERAND (postfix_expression, 1);\n-      postfix_expression \n-\t= build_offset_ref (qualifying_class, postfix_expression);\n-      return postfix_expression;\n-    }\n-\n-  /* Otherwise, if we were avoiding committing until we knew\n-     whether or not we had a pointer-to-member, we now know that\n-     the expression is an ordinary reference to a qualified name.  */\n+  /* If we were avoiding committing to the processing of a\n+     qualified-id until we knew whether or not we had a\n+     pointer-to-member, we now know.  */\n   if (qualifying_class)\n     {\n-      if (TREE_CODE (postfix_expression) == FIELD_DECL)\n-\tpostfix_expression \n-\t  = finish_non_static_data_member (postfix_expression,\n-\t\t\t\t\t   qualifying_class);\n-      else if (BASELINK_P (postfix_expression) \n-\t       && !processing_template_decl)\n-\t{\n-\t  tree fn;\n-\t  tree fns;\n+      bool done;\n \n-\t  /* See if any of the functions are non-static members.  */\n-\t  fns = BASELINK_FUNCTIONS (postfix_expression);\n-\t  if (TREE_CODE (fns) == TEMPLATE_ID_EXPR)\n-\t    fns = TREE_OPERAND (fns, 0);\n-\t  for (fn = fns; fn; fn = OVL_NEXT (fn))\n-\t    if (DECL_NONSTATIC_MEMBER_FUNCTION_P (fn))\n-\t      break;\n-\t  /* If so, the expression may be relative to the current\n-\t     class.  */\n-\t  if (fn && current_class_type \n-\t      && DERIVED_FROM_P (qualifying_class, current_class_type))\n-\t    postfix_expression \n-\t      = (build_class_member_access_expr \n-\t\t (maybe_dummy_object (qualifying_class, NULL),\n-\t\t  postfix_expression,\n-\t\t  BASELINK_ACCESS_BINFO (postfix_expression),\n-\t\t  /*preserve_reference=*/false));\n-\t  else if (done)\n-\t    {\n-\t      /* The expression is a qualified name whose address is not\n-\t\t being taken.  */\n-\t      postfix_expression = build_offset_ref (qualifying_class,\n-\t\t\t\t\t\t     postfix_expression);\n-\t      if (TREE_CODE (postfix_expression) == OFFSET_REF)\n-\t\tpostfix_expression = resolve_offset_ref (postfix_expression);\n-\t      return postfix_expression;\n-\t    }\n-\t}\n+      /* Peek at the next token.  */\n+      token = cp_lexer_peek_token (parser->lexer);\n+      done = (token->type != CPP_OPEN_SQUARE\n+\t      && token->type != CPP_OPEN_PAREN\n+\t      && token->type != CPP_DOT\n+\t      && token->type != CPP_DEREF\n+\t      && token->type != CPP_PLUS_PLUS\n+\t      && token->type != CPP_MINUS_MINUS);\n+\n+      postfix_expression = finish_qualified_id_expr (qualifying_class,\n+\t\t\t\t\t\t     postfix_expression,\n+\t\t\t\t\t\t     done,\n+\t\t\t\t\t\t     address_p);\n+      if (done)\n+\treturn postfix_expression;\n     }\n \n   /* Remember that there was a reference to this entity.  */\n@@ -3915,7 +3821,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t\tif (!arg)\n \t\t  {\n \t\t    postfix_expression \n-\t\t      = lookup_arg_dependent(identifier, functions, args);\n+\t\t      = lookup_arg_dependent (identifier, functions, args);\n \t\t    if (!postfix_expression)\n \t\t      {\n \t\t\t/* The unqualified name could not be resolved.  */\n@@ -4014,8 +3920,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t\t   may have reference type even when the standard says\n \t\t   it does not.  Therefore, we have to manually obtain\n \t\t   the underlying type here.  */\n-\t\tif (TREE_CODE (scope) == REFERENCE_TYPE)\n-\t\t  scope = TREE_TYPE (scope);\n+\t\tscope = non_reference (scope);\n \t\t/* If the SCOPE is an OFFSET_TYPE, then we grab the\n \t\t   type of the field.  We get an OFFSET_TYPE for\n \t\t   something like:\n@@ -10031,7 +9936,10 @@ cp_parser_direct_declarator (cp_parser* parser,\n \n \t\t  saved_processing_template_decl = processing_template_decl;\n \t\t  processing_template_decl = 0;\n-\t\t  bounds = build_expr_from_tree (bounds);\n+\t\t  bounds = tsubst_copy_and_build (bounds, \n+\t\t\t\t\t\t  /*args=*/NULL_TREE,\n+\t\t\t\t\t\t  tf_error,\n+\t\t\t\t\t\t  /*in_decl=*/NULL_TREE);\n \t\t  processing_template_decl = saved_processing_template_decl;\n \t\t}\n \t    }\n@@ -13209,8 +13117,7 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n \t     may be instantiated during name lookup.  In that case,\n \t     errors may be issued.  Even if we rollback the current\n \t     tentative parse, those errors are valid.  */\n-\t  decl = lookup_qualified_name (parser->scope, name, is_type,\n-\t\t\t\t\t/*flags=*/0);\n+\t  decl = lookup_qualified_name (parser->scope, name, is_type);\n \t  if (dependent_p)\n \t    pop_scope (parser->scope);\n \t}\n@@ -13282,18 +13189,7 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n      During an explicit instantiation, access is not checked at all,\n      as per [temp.explicit].  */\n   if (DECL_P (decl))\n-    {\n-      tree qualifying_type;\n-      \n-      /* Figure out the type through which DECL is being\n-\t accessed.  */\n-      qualifying_type \n-\t= cp_parser_scope_through_which_access_occurs (decl,\n-\t\t\t\t\t\t       object_type,\n-\t\t\t\t\t\t       parser->scope);\n-      if (qualifying_type)\n-\tperform_or_defer_access_check (TYPE_BINFO (qualifying_type), decl);\n-    }\n+    check_accessibility_of_qualified_id (decl, object_type, parser->scope);\n \n   return decl;\n }"}, {"sha": "60383ef914ab410881e739db2ed5767f9cb4856a", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 256, "deletions": 173, "changes": 429, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d", "patch": "@@ -171,7 +171,6 @@ static bool dependent_template_id_p (tree, tree);\n static tree tsubst (tree, tree, tsubst_flags_t, tree);\n static tree tsubst_expr\t(tree, tree, tsubst_flags_t, tree);\n static tree tsubst_copy\t(tree, tree, tsubst_flags_t, tree);\n-static tree tsubst_copy_and_build (tree, tree, tsubst_flags_t, tree);\n \n /* Make the current scope suitable for access checking when we are\n    processing T.  T can be FUNCTION_DECL for instantiated function\n@@ -5527,9 +5526,8 @@ maybe_fold_nontype_arg (tree arg)\n \t template constant parameter, like N - 1.  Now that we've\n \t tsubst'd, we might have something like 2 - 1.  This will\n \t confuse lookup_template_class, so we do constant folding\n-\t here.  We have to unset processing_template_decl, to\n-\t fool build_expr_from_tree() into building an actual\n-\t tree.  */\n+\t here.  We have to unset processing_template_decl, to fool\n+\t tsubst_copy_and_build() into building an actual tree.  */\n \n       /* If the TREE_TYPE of ARG is not NULL_TREE, ARG is already\n \t as simple as it's going to get, and trying to reprocess\n@@ -5538,7 +5536,10 @@ maybe_fold_nontype_arg (tree arg)\n \t{\n \t  int saved_processing_template_decl = processing_template_decl; \n \t  processing_template_decl = 0;\n-\t  arg = build_expr_from_tree (arg);\n+\t  arg = tsubst_copy_and_build (arg,\n+\t\t\t\t       /*args=*/NULL_TREE,\n+\t\t\t\t       tf_error,\n+\t\t\t\t       /*in_decl=*/NULL_TREE);\n \t  processing_template_decl = saved_processing_template_decl; \n \t}\n \n@@ -7076,6 +7077,118 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n     }\n }\n \n+/* Like tsubst_expr for a BASELINK.  OBJECT_TYPE, if non-NULL, is the\n+   type of the expression on the left-hand side of the \".\" or \"->\"\n+   operator.  */\n+\n+static tree\n+tsubst_baselink (tree baselink, tree object_type,\n+\t\t tree args, tsubst_flags_t complain, tree in_decl)\n+{\n+    tree name;\n+    tree qualifying_scope;\n+    tree fns;\n+    tree template_args = 0;\n+    bool template_id_p = false;\n+\n+    /* A baselink indicates a function from a base class.  The\n+       BASELINK_ACCESS_BINFO and BASELINK_BINFO are going to have\n+       non-dependent types; otherwise, the lookup could not have\n+       succeeded.  However, they may indicate bases of the template\n+       class, rather than the instantiated class.  \n+\n+       In addition, lookups that were not ambiguous before may be\n+       ambiguous now.  Therefore, we perform the lookup again. */\n+    qualifying_scope = BINFO_TYPE (BASELINK_ACCESS_BINFO (baselink));\n+    fns = BASELINK_FUNCTIONS (baselink);\n+    if (TREE_CODE (fns) == TEMPLATE_ID_EXPR)\n+      {\n+\ttemplate_id_p = true;\n+\ttemplate_args = TREE_OPERAND (fns, 1);\n+\tfns = TREE_OPERAND (fns, 0);\n+\ttemplate_args = tsubst_copy (template_args, args,\n+\t\t\t\t     complain, in_decl);\n+\tmaybe_fold_nontype_args (template_args);\n+      }\n+    name = DECL_NAME (get_first_fn (fns));\n+    baselink = lookup_fnfields (qualifying_scope, name, /*protect=*/1);\n+    if (BASELINK_P (baselink) && template_id_p)\n+      BASELINK_FUNCTIONS (baselink) \n+\t= build_nt (TEMPLATE_ID_EXPR,\n+\t\t    BASELINK_FUNCTIONS (baselink),\n+\t\t    template_args);\n+    if (!object_type)\n+      object_type = current_class_type;\n+    return adjust_result_of_qualified_name_lookup (baselink, \n+\t\t\t\t\t\t   qualifying_scope,\n+\t\t\t\t\t\t   object_type);\n+}\n+\n+/* Like tsubst_expr for a SCOPE_REF, given by QUALIFIED_ID.  DONE is\n+   true if the qualified-id will be a postfix-expression in-and-of\n+   itself; false if more of the postfix-expression follows the\n+   QUALIFIED_ID.  ADDRESS_P is true if the qualified-id is the operand\n+   of \"&\".  */\n+\n+static tree\n+tsubst_qualified_id (tree qualified_id, tree args, \n+\t\t     tsubst_flags_t complain, tree in_decl,\n+\t\t     bool done, bool address_p)\n+{\n+  tree expr;\n+  tree scope;\n+  tree name;\n+  bool is_template;\n+  tree template_args;\n+\n+  my_friendly_assert (TREE_CODE (qualified_id) == SCOPE_REF, 20030706);\n+\n+  /* Look up the qualified name.  */\n+  scope = TREE_OPERAND (qualified_id, 0);\n+  scope = tsubst (scope, args, complain, in_decl);\n+\n+  /* Figure out what name to look up.  */\n+  name = TREE_OPERAND (qualified_id, 1);\n+  if (TREE_CODE (name) == TEMPLATE_ID_EXPR)\n+    {\n+      is_template = true;\n+      template_args = tsubst_copy_and_build (TREE_OPERAND (name, 1), \n+\t\t\t\t\t     args, complain, in_decl);\n+      name = TREE_OPERAND (name, 0);\n+    }\n+  else\n+    {\n+      is_template = false;\n+      template_args = NULL_TREE;\n+    }\n+\n+  expr = tsubst_copy (name, args, complain, in_decl);\n+  if (!BASELINK_P (name))\n+    {\n+      expr = lookup_qualified_name (scope, expr, /*is_type_p=*/0);\n+      if (DECL_P (expr))\n+\tcheck_accessibility_of_qualified_id (expr, \n+\t\t\t\t\t     /*object_type=*/NULL_TREE,\n+\t\t\t\t\t     scope);\n+    }\n+\n+  /* Remember that there was a reference to this entity.  */\n+  if (DECL_P (expr))\n+    mark_used (expr);\n+\n+  if (is_template)\n+    lookup_template_function (expr, template_args);\n+\n+  if (TYPE_P (scope))\n+    {\n+      expr = (adjust_result_of_qualified_name_lookup \n+\t      (expr, scope, current_class_type));\n+      expr = finish_qualified_id_expr (scope, expr, done, address_p);\n+    }\n+\n+  return expr;\n+}\n+\n /* Like tsubst, but deals with expressions.  This function just replaces\n    template parms; to finish processing the resultant expression, use\n    tsubst_expr.  */\n@@ -7157,43 +7270,7 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       return t;\n \n     case BASELINK:\n-      {\n-\ttree name;\n-\ttree qualifying_scope;\n-\ttree fns;\n-\ttree template_args = 0;\n-\tbool template_id_p = false;\n-\n-\t/* A baselink indicates a function from a base class.  The\n-\t   BASELINK_ACCESS_BINFO and BASELINK_BINFO are going to have\n-\t   non-dependent types; otherwise, the lookup could not have\n-\t   succeeded.  However, they may indicate bases of the template\n-\t   class, rather than the instantiated class.  \n-\t   \n-\t   In addition, lookups that were not ambiguous before may be\n-\t   ambiguous now.  Therefore, we perform the lookup again.  */\n-\tqualifying_scope = BINFO_TYPE (BASELINK_ACCESS_BINFO (t));\n-\tfns = BASELINK_FUNCTIONS (t);\n-\tif (TREE_CODE (fns) == TEMPLATE_ID_EXPR)\n-\t  {\n-\t    template_id_p = true;\n-\t    template_args = TREE_OPERAND (fns, 1);\n-\t    fns = TREE_OPERAND (fns, 0);\n-\t    template_args = tsubst_copy (template_args, args,\n-\t\t\t\t\t complain, in_decl);\n-\t    maybe_fold_nontype_args (template_args);\n-\t  }\n-\tname = DECL_NAME (get_first_fn (fns));\n-\tt = lookup_fnfields (qualifying_scope, name, /*protect=*/1);\n-\tif (BASELINK_P (t) && template_id_p)\n-\t  BASELINK_FUNCTIONS (t) \n-\t    = build_nt (TEMPLATE_ID_EXPR,\n-\t\t\tBASELINK_FUNCTIONS (t),\n-\t\t\ttemplate_args);\n-\treturn adjust_result_of_qualified_name_lookup (t, \n-\t\t\t\t\t\t       qualifying_scope,\n-\t\t\t\t\t\t       current_class_type);\n-      }\n+      return tsubst_baselink (t, current_class_type, args, complain, in_decl);\n \n     case TEMPLATE_DECL:\n       if (DECL_TEMPLATE_TEMPLATE_PARM_P (t))\n@@ -7296,8 +7373,13 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t    name = build1 (BIT_NOT_EXPR, NULL_TREE, name);\n \t    name = build_nt (SCOPE_REF, base, name);\n \t  }\n+\telse if (TREE_CODE (name) == BASELINK)\n+\t  name = tsubst_baselink (name, \n+\t\t\t\t  non_reference (TREE_TYPE (object)), \n+\t\t\t\t  args, complain, \n+\t\t\t\t  in_decl);\n \telse\n-\t  name = tsubst_copy (TREE_OPERAND (t, 1), args, complain, in_decl);\n+\t  name = tsubst_copy (name, args, complain, in_decl);\n \treturn build_nt (COMPONENT_REF, object, name);\n       }\n \n@@ -7352,14 +7434,6 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t\t\t\t    in_decl),\n \t\t       NULL_TREE);\n \n-    case METHOD_CALL_EXPR:\n-      return build_nt\n-\t(code, \n-\t tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl),\n-\t tsubst_copy (TREE_OPERAND (t, 1), args, complain, in_decl),\n-\t tsubst_copy (TREE_OPERAND (t, 2), args, complain, in_decl),\n-\t NULL_TREE);\n-\n     case STMT_EXPR:\n       /* This processing should really occur in tsubst_expr.  However,\n \t tsubst_expr does not recurse into expressions, since it\n@@ -7547,8 +7621,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t    scope = tsubst_expr (scope, args, complain, in_decl);\n \t    do_local_using_decl (lookup_qualified_name (scope,\n \t\t\t\t\t\t\tname, \n-\t\t\t\t\t\t\t/*is_type_p=*/0,\n-\t\t\t\t\t\t\t/*flags=*/0));\n+\t\t\t\t\t\t\t/*is_type_p=*/0));\n \t  }\n \telse\n \t  {\n@@ -7814,12 +7887,14 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n /* Like tsubst but deals with expressions and performs semantic\n    analysis.  */\n \n-static tree\n+tree\n tsubst_copy_and_build (tree t, \n                        tree args, \n                        tsubst_flags_t complain, \n                        tree in_decl)\n {\n+  tree op1;\n+\n   if (t == NULL_TREE || t == error_mark_node)\n     return t;\n \n@@ -7859,9 +7934,11 @@ tsubst_copy_and_build (tree t,\n       {\n \ttree object;\n \ttree template\n-\t  = tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl);\n+\t  = tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain, \n+\t\t\t\t   in_decl);\n \ttree targs\n-\t  = tsubst_copy (TREE_OPERAND (t, 1), args, complain, in_decl);\n+\t  = tsubst_copy_and_build (TREE_OPERAND (t, 1), args, complain, \n+\t\t\t\t   in_decl);\n \t\n \tif (TREE_CODE (template) == COMPONENT_REF)\n \t  {\n@@ -7870,7 +7947,6 @@ tsubst_copy_and_build (tree t,\n \t  }\n \telse\n \t  object = NULL_TREE;\n-\tmaybe_fold_nontype_args (targs);\n \ttemplate = lookup_template_function (template, targs);\n \t\n \tif (object)\n@@ -7910,10 +7986,21 @@ tsubst_copy_and_build (tree t,\n \t(tsubst (TREE_TYPE (t), args, complain, in_decl),\n \t tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain, in_decl));\n \n-    case PREDECREMENT_EXPR:\n-    case PREINCREMENT_EXPR:\n     case POSTDECREMENT_EXPR:\n     case POSTINCREMENT_EXPR:\n+      op1 = TREE_OPERAND (t, 0);\n+      if (TREE_CODE (op1) == SCOPE_REF)\n+\top1 = tsubst_qualified_id (TREE_OPERAND (t, 0),\n+\t\t\t\t   args, complain, \n+\t\t\t\t   in_decl,\n+\t\t\t\t   /*done=*/false,\n+\t\t\t\t   /*address_p=*/false);\n+      else\n+\top1 = tsubst_copy_and_build (op1, args, complain, in_decl);\n+      return build_x_unary_op (TREE_CODE (t), op1);\n+\n+    case PREDECREMENT_EXPR:\n+    case PREINCREMENT_EXPR:\n       if (TREE_TYPE (t))\n \treturn tsubst_copy (t, args, complain, in_decl);\n       else\n@@ -7939,8 +8026,16 @@ tsubst_copy_and_build (tree t,\n \t(TREE_CODE (t),\n \t tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain, in_decl));\n \n-    case TRUTH_NOT_EXPR:\n     case ADDR_EXPR:\n+      op1 = TREE_OPERAND (t, 0);\n+      if (TREE_CODE (op1) == SCOPE_REF)\n+\top1 = tsubst_qualified_id (op1, args, complain, in_decl, \n+\t\t\t\t   /*done=*/true, /*address_p=*/true);\n+      else\n+\top1 = tsubst_copy_and_build (op1, args, complain, in_decl);\n+      return build_x_unary_op (ADDR_EXPR, op1);\n+\n+    case TRUTH_NOT_EXPR:\n     case CONVERT_EXPR:  /* Unary + */\n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n@@ -7994,26 +8089,31 @@ tsubst_copy_and_build (tree t,\n \t tsubst_copy_and_build (TREE_OPERAND (t, 1), args, complain, in_decl));\n \n     case SCOPE_REF:\n-      return build_offset_ref\n-\t(tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl),\n-\t tsubst_copy (TREE_OPERAND (t, 1), args, complain, in_decl));\n+      return tsubst_qualified_id (t, args, complain, in_decl, /*done=*/true,\n+\t\t\t\t  /*address_p=*/false);\n \n     case ARRAY_REF:\n-      {\n-\tif (tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl)\n-\t    == NULL_TREE)\n-\t  /* new-type-id */\n-\t  return build_nt\n-\t    (ARRAY_REF, NULL_TREE,\n-\t     tsubst_copy_and_build (TREE_OPERAND (t, 1), args, complain,\n-\t\t\t\t    in_decl));\n-\t\n-\treturn grok_array_decl\n-\t  (tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain,\n-\t\t\t\t  in_decl),\n+      if (tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl)\n+\t  == NULL_TREE)\n+\t/* new-type-id */\n+\treturn build_nt\n+\t  (ARRAY_REF, NULL_TREE,\n \t   tsubst_copy_and_build (TREE_OPERAND (t, 1), args, complain,\n \t\t\t\t  in_decl));\n-      }\n+\n+      op1 = TREE_OPERAND (t, 0);\n+      if (TREE_CODE (op1) == SCOPE_REF)\n+\top1 = tsubst_qualified_id (op1, args, complain, in_decl,\n+\t\t\t\t   /*done=*/false, /*address_p=*/false);\n+      else\n+\top1 = tsubst_copy_and_build (op1, args, complain, in_decl);\n+      /* Remember that there was a reference to this entity.  */\n+      if (DECL_P (op1))\n+\tmark_used (op1);\n+      return grok_array_decl (op1, \n+\t\t\t      tsubst_copy_and_build (TREE_OPERAND (t, 1), \n+\t\t\t\t\t\t     args, complain,\n+\t\t\t\t\t\t     in_decl));\n \n     case SIZEOF_EXPR:\n     case ALIGNOF_EXPR:\n@@ -8034,8 +8134,16 @@ tsubst_copy_and_build (tree t,\n \t tsubst_copy_and_build (TREE_OPERAND (t, 2), args, complain, in_decl));\n \n     case ARROW_EXPR:\n-      return build_x_arrow\n-\t(tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain, in_decl));\n+      op1 = TREE_OPERAND (t, 0);\n+      if (TREE_CODE (op1) == SCOPE_REF)\n+\top1 = tsubst_qualified_id (op1, args, complain, in_decl,\n+\t\t\t\t   /*done=*/false, /*address_p=*/false);\n+      else\n+\top1 = tsubst_copy_and_build (op1, args, complain, in_decl);\n+      /* Remember that there was a reference to this entity.  */\n+      if (DECL_P (op1))\n+\tmark_used (op1);\n+      return build_x_arrow (op1);\n \n     case NEW_EXPR:\n       return build_new\n@@ -8062,104 +8170,62 @@ tsubst_copy_and_build (tree t,\n \t  abort ();\n       }\n \n-    case METHOD_CALL_EXPR:\n+    case CALL_EXPR:\n       {\n-\ttree method\n-\t  = tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl);\n-\t\n-\tif (TREE_CODE (method) == SCOPE_REF)\n+\ttree function;\n+\ttree call_args;\n+\ttree koenig_name;\n+\tbool qualified_p;\n+\n+\tfunction = TREE_OPERAND (t, 0);\n+\tif (TREE_CODE (function) == LOOKUP_EXPR\n+\t    && !LOOKUP_EXPR_GLOBAL (function))\n+\t  koenig_name = TREE_OPERAND (function, 0);\n+\telse\n+\t  koenig_name = NULL_TREE;\n+\tif (TREE_CODE (function) == SCOPE_REF)\n \t  {\n-\t    tree name = TREE_OPERAND (method, 1);\n-\t  \n-\t    if (TREE_CODE (name) == TEMPLATE_ID_EXPR)\n-\t      name = build_nt (TEMPLATE_ID_EXPR,\n-\t\t\t       TREE_OPERAND (name, 0),\n-\t\t\t       TREE_OPERAND (name, 1));\n-\t    \n-\t    return build_scoped_method_call\n-\t      (tsubst_copy_and_build\n-\t       (TREE_OPERAND (t, 1), args, complain, in_decl),\n-\t       TREE_OPERAND (method, 0),\n-\t       name,\n-\t       tsubst_copy_and_build\n-\t       (TREE_OPERAND (t, 2), args, complain, in_decl));\n+\t    qualified_p = true;\n+\t    function = tsubst_qualified_id (function, args, complain, in_decl,\n+\t\t\t\t\t    /*done=*/false, \n+\t\t\t\t\t    /*address_p=*/false);\n \t  }\n-\telse \n+\telse\n \t  {\n-\t    /* We can get a TEMPLATE_ID_EXPR here on code like:\n-\n-\t    x->f<2>();\n-\t      \n-\t    so we must resolve that.  However, we can also get things\n-\t    like a BIT_NOT_EXPR here, when referring to a destructor,\n-\t    and things like that are not correctly resolved by this\n-\t    function so just use it when we really need it.  */\n-\t    if (TREE_CODE (method) == TEMPLATE_ID_EXPR)\n-\t      method = lookup_template_function\n-\t\t(TREE_OPERAND (method, 0),\n-\t\t TREE_OPERAND (method, 1));\n-\n-\t    return build_method_call\n-\t      (tsubst_copy_and_build\n-\t       (TREE_OPERAND (t, 1), args, complain, in_decl),\n-\t       method,\n-\t       tsubst_copy_and_build\n-\t       (TREE_OPERAND (t, 2), args, complain, in_decl),\n-\t       NULL_TREE, LOOKUP_NORMAL);\n+\t    qualified_p = (TREE_CODE (function) == COMPONENT_REF\n+\t\t\t   && (TREE_CODE (TREE_OPERAND (function, 1))\n+\t\t\t       == SCOPE_REF));\n+\t    function = tsubst_copy_and_build (function, args, complain, \n+\t\t\t\t\t      in_decl);\n+\t    function = convert_from_reference (function);\n \t  }\n-      }\n \n-    case CALL_EXPR:\n-      {\n-\ttree function, copy_args;\n+\t/* Remember that there was a reference to this entity.  */\n+\tif (DECL_P (function))\n+\t  mark_used (function);\n \n-\tfunction = tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl);\n-\tcopy_args = tsubst_copy_and_build (TREE_OPERAND (t, 1), args,\n+\tcall_args = tsubst_copy_and_build (TREE_OPERAND (t, 1), args,\n \t\t\t\t\t   complain, in_decl);\n \t  \n \tif (BASELINK_P (function))\n-\t  return build_call_from_tree (function, copy_args, 1);\n-\telse if (TREE_CODE (function) == SCOPE_REF)\n-\t  {\n-\t    tree name = TREE_OPERAND (function, 1);\n-\t    if (TREE_CODE (name) == TEMPLATE_ID_EXPR)\n-\t      name = build_nt (TEMPLATE_ID_EXPR,\n-\t\t\t       TREE_OPERAND (name, 0),\n-\t\t\t       build_expr_from_tree (TREE_OPERAND (name, 1)));\n-\t    \n-\t    function = resolve_scoped_fn_name (TREE_OPERAND (function, 0),\n-\t\t\t\t\t       name);\n-\t    \n-\t    return build_call_from_tree (function, copy_args, 1);\n-\t  }\n+\t  return build_call_from_tree (function, call_args, 1);\n \telse\n \t  {\n-\t    tree name = function;\n-\t    tree id;\n-\t    \n-\t    if (copy_args != NULL_TREE && TREE_CODE (name) == LOOKUP_EXPR\n-\t\t&& !LOOKUP_EXPR_GLOBAL (name)\n-\t\t&& (TREE_CODE ((id = TREE_OPERAND (name, 0)))\n-\t\t    == IDENTIFIER_NODE)\n-\t\t&& (!current_class_type\n-\t\t    || !lookup_member (current_class_type, id, 0, false)))\n-\t      {\n-\t\t/* Do Koenig lookup if there are no class members.  */\n-\t\tname = do_identifier (id, copy_args);\n-\t      }\n-\t    else if (TREE_CODE (name) == TEMPLATE_ID_EXPR\n-\t\t     || ! really_overloaded_fn (name))\n-\t      name = build_expr_from_tree (name);\n-\n-\t    if (TREE_CODE (name) == OFFSET_REF)\n-\t      return build_offset_ref_call_from_tree (name, copy_args);\n-\t    if (TREE_CODE (name) == COMPONENT_REF)\n-\t      return finish_object_call_expr (TREE_OPERAND (name, 1),\n-\t\t\t\t\t      TREE_OPERAND (name, 0),\n-\t\t\t\t\t      copy_args);\n-\t    name = convert_from_reference (name);\n-\t    return build_call_from_tree (name, copy_args, \n-\t\t\t\t\t /*disallow_virtual=*/false);\n+\t    if (call_args != NULL_TREE && koenig_name)\n+\t      function = lookup_arg_dependent (koenig_name,\n+\t\t\t\t\t       function, \n+\t\t\t\t\t       call_args);\n+\n+\t    if (TREE_CODE (function) == OFFSET_REF)\n+\t      return build_offset_ref_call_from_tree (function, call_args);\n+\t    if (TREE_CODE (function) == COMPONENT_REF)\n+\t      return (build_new_method_call \n+\t\t      (TREE_OPERAND (function, 0),\n+\t\t       TREE_OPERAND (function, 1),\n+\t\t       call_args, NULL_TREE, \n+\t\t       qualified_p ? LOOKUP_NONVIRTUAL : LOOKUP_NORMAL));\n+\t    return finish_call_expr (function, call_args, \n+\t\t\t\t     /*disallow_virtual=*/qualified_p);\n \t  }\n       }\n \n@@ -8200,10 +8266,27 @@ tsubst_copy_and_build (tree t,\n \n     case COMPONENT_REF:\n       {\n-\ttree object =\n-\t  tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain, in_decl);\n-\ttree member =\n-\t  tsubst_copy (TREE_OPERAND (t, 1), args, complain, in_decl);\n+\ttree object;\n+\ttree member;\n+\n+\tobject = TREE_OPERAND (t, 0);\n+\tif (TREE_CODE (object) == SCOPE_REF)\n+\t  object = tsubst_qualified_id (object, args, complain, in_decl,\n+\t\t\t\t\t/*done=*/false, /*address_p=*/false);\n+\telse\n+\t  object = tsubst_copy_and_build (object, args, complain, in_decl);\n+\n+\t/* Remember that there was a reference to this entity.  */\n+\tif (DECL_P (object))\n+\t  mark_used (object);\n+\n+\tmember = TREE_OPERAND (t, 1);\n+\tif (BASELINK_P (member))\n+\t  member = tsubst_baselink (member, \n+\t\t\t\t    non_reference (TREE_TYPE (object)),\n+\t\t\t\t    args, complain, in_decl);\n+\telse\n+\t  member = tsubst_copy (member, args, complain, in_decl);\n \n \tif (!CLASS_TYPE_P (TREE_TYPE (object)))\n \t  {\n@@ -8229,8 +8312,7 @@ tsubst_copy_and_build (tree t,\n \t    args = TREE_OPERAND (TREE_OPERAND (member, 1), 1);\n \t    member = lookup_qualified_name (TREE_OPERAND (member, 0),\n \t\t\t\t\t    tmpl, \n-\t\t\t\t\t    /*is_type=*/0,\n-\t\t\t\t\t    /*flags=*/0);\n+\t\t\t\t\t    /*is_type=*/0);\n \t    if (BASELINK_P (member))\n \t      BASELINK_FUNCTIONS (member) \n \t\t= build_nt (TEMPLATE_ID_EXPR, BASELINK_FUNCTIONS (member),\n@@ -8303,7 +8385,9 @@ tsubst_copy_and_build (tree t,\n       return convert_from_reference (tsubst_copy (t, args, complain, in_decl));\n \n     case VAR_DECL:\n-      return convert_from_reference (tsubst_copy (t, args, complain, in_decl));\n+      if (args)\n+\tt = tsubst_copy (t, args, complain, in_decl);\n+      return convert_from_reference (t);\n \n     case VA_ARG_EXPR:\n \treturn build_x_va_arg\n@@ -11405,8 +11489,7 @@ value_dependent_expression_p (tree expression)\n      with an expression that is value-dependent.  */\n   if (TREE_CODE (expression) == VAR_DECL\n       && DECL_INITIAL (expression)\n-      && (CP_INTEGRAL_TYPE_P (TREE_TYPE (expression))\n-\t  || TREE_CODE (TREE_TYPE (expression)) == ENUMERAL_TYPE)\n+      && INTEGRAL_OR_ENUMERATION_TYPE_P (expression)\n       && value_dependent_expression_p (DECL_INITIAL (expression)))\n     return true;\n   /* These expressions are value-dependent if the type to which the"}, {"sha": "b28fea6212a5e35509914a7913c4825c63f6288e", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d", "patch": "@@ -213,11 +213,8 @@ get_tinfo_decl_dynamic (tree exp)\n   if (exp == error_mark_node)\n     return error_mark_node;\n \n-  type = TREE_TYPE (exp);\n-\n   /* peel back references, so they match.  */\n-  if (TREE_CODE (type) == REFERENCE_TYPE)\n-    type = TREE_TYPE (type);\n+  type = non_reference (TREE_TYPE (exp));\n \n   /* Peel off cv qualifiers.  */\n   type = TYPE_MAIN_VARIANT (type);\n@@ -408,8 +405,7 @@ get_typeid (tree type)\n   /* If the type of the type-id is a reference type, the result of the\n      typeid expression refers to a type_info object representing the\n      referenced type.  */\n-  if (TREE_CODE (type) == REFERENCE_TYPE)\n-    type = TREE_TYPE (type);\n+  type = non_reference (type);\n \n   /* The top-level cv-qualifiers of the lvalue expression or the type-id\n      that is the operand of typeid are always ignored.  */"}, {"sha": "64e5707e1f0f484550764995d0d1d9e98f85e2e1", "filename": "gcc/cp/search.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d", "patch": "@@ -1712,9 +1712,7 @@ check_final_overrider (tree overrider, tree basefn)\n \t{\n \t  /* can_convert will permit user defined conversion from a\n \t     (reference to) class type. We must reject them.  */\n-\t  over_return = TREE_TYPE (over_type);\n-\t  if (TREE_CODE (over_return) == REFERENCE_TYPE)\n-\t    over_return = TREE_TYPE (over_return);\n+\t  over_return = non_reference (TREE_TYPE (over_type));\n \t  if (CLASS_TYPE_P (over_return))\n \t    fail = 2;\n \t}"}, {"sha": "cc1e2ea3e9c314285694b29e63856064e94766b7", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 113, "deletions": 10, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d", "patch": "@@ -1276,6 +1276,119 @@ finish_non_static_data_member (tree decl, tree qualifying_scope)\n     }\n }\n \n+/* DECL was the declaration to which a qualified-id resolved.  Issue\n+   an error message if it is not accessible.  If OBJECT_TYPE is\n+   non-NULL, we have just seen `x->' or `x.' and OBJECT_TYPE is the\n+   type of `*x', or `x', respectively.  If the DECL was named as\n+   `A::B' then NESTED_NAME_SPECIFIER is `A'.  */\n+\n+void\n+check_accessibility_of_qualified_id (tree decl, \n+\t\t\t\t     tree object_type, \n+\t\t\t\t     tree nested_name_specifier)\n+{\n+  tree scope;\n+  tree qualifying_type = NULL_TREE;\n+  \n+  /* Determine the SCOPE of DECL.  */\n+  scope = context_for_name_lookup (decl);\n+  /* If the SCOPE is not a type, then DECL is not a member.  */\n+  if (!TYPE_P (scope))\n+    return;\n+  /* Compute the scope through which DECL is being accessed.  */\n+  if (object_type \n+      /* OBJECT_TYPE might not be a class type; consider:\n+\n+\t   class A { typedef int I; };\n+\t   I *p;\n+\t   p->A::I::~I();\n+\n+         In this case, we will have \"A::I\" as the DECL, but \"I\" as the\n+\t OBJECT_TYPE.  */\n+      && CLASS_TYPE_P (object_type)\n+      && DERIVED_FROM_P (scope, object_type))\n+    /* If we are processing a `->' or `.' expression, use the type of the\n+       left-hand side.  */\n+    qualifying_type = object_type;\n+  else if (nested_name_specifier)\n+    {\n+      /* If the reference is to a non-static member of the\n+\t current class, treat it as if it were referenced through\n+\t `this'.  */\n+      if (DECL_NONSTATIC_MEMBER_P (decl)\n+\t  && current_class_ptr\n+\t  && DERIVED_FROM_P (scope, current_class_type))\n+\tqualifying_type = current_class_type;\n+      /* Otherwise, use the type indicated by the\n+\t nested-name-specifier.  */\n+      else\n+\tqualifying_type = nested_name_specifier;\n+    }\n+  else\n+    /* Otherwise, the name must be from the current class or one of\n+       its bases.  */\n+    qualifying_type = currently_open_derived_class (scope);\n+\n+  if (qualifying_type)\n+    perform_or_defer_access_check (TYPE_BINFO (qualifying_type), decl);\n+}\n+\n+/* EXPR is the result of a qualified-id.  The QUALIFYING_CLASS was the\n+   class named to the left of the \"::\" operator.  DONE is true if this\n+   expression is a complete postfix-expression; it is false if this\n+   expression is followed by '->', '[', '(', etc.  ADDRESS_P is true\n+   iff this expression is the operand of '&'.  */\n+\n+tree\n+finish_qualified_id_expr (tree qualifying_class, tree expr, bool done,\n+\t\t\t  bool address_p)\n+{\n+  /* If EXPR occurs as the operand of '&', use special handling that\n+     permits a pointer-to-member.  */\n+  if (address_p && done)\n+    {\n+      if (TREE_CODE (expr) == SCOPE_REF)\n+\texpr = TREE_OPERAND (expr, 1);\n+      expr = build_offset_ref (qualifying_class, expr);\n+      return expr;\n+    }\n+\n+  if (TREE_CODE (expr) == FIELD_DECL)\n+    expr = finish_non_static_data_member (expr, qualifying_class);\n+  else if (BASELINK_P (expr) && !processing_template_decl)\n+    {\n+      tree fn;\n+      tree fns;\n+\n+      /* See if any of the functions are non-static members.  */\n+      fns = BASELINK_FUNCTIONS (expr);\n+      if (TREE_CODE (fns) == TEMPLATE_ID_EXPR)\n+\tfns = TREE_OPERAND (fns, 0);\n+      for (fn = fns; fn; fn = OVL_NEXT (fn))\n+\tif (DECL_NONSTATIC_MEMBER_FUNCTION_P (fn))\n+\t  break;\n+      /* If so, the expression may be relative to the current\n+\t class.  */\n+      if (fn && current_class_type \n+\t  && DERIVED_FROM_P (qualifying_class, current_class_type))\n+\texpr = (build_class_member_access_expr \n+\t\t(maybe_dummy_object (qualifying_class, NULL),\n+\t\t expr,\n+\t\t BASELINK_ACCESS_BINFO (expr),\n+\t\t /*preserve_reference=*/false));\n+      else if (done)\n+\t{\n+\t  /* The expression is a qualified name whose address is not\n+\t     being taken.  */\n+\t  expr = build_offset_ref (qualifying_class, expr);\n+\t  if (TREE_CODE (expr) == OFFSET_REF)\n+\t    expr = resolve_offset_ref (expr);\n+\t}\n+    }\n+\n+  return expr;\n+}\n+\n /* Begin a statement-expression.  The value returned must be passed to\n    finish_stmt_expr.  */\n \n@@ -1548,16 +1661,6 @@ finish_object_call_expr (tree fn, tree object, tree args)\n     return build_new_method_call (object, fn, args, NULL_TREE, LOOKUP_NORMAL);\n }\n \n-/* Finish a qualified member function call using OBJECT and ARGS as\n-   arguments to FN.  Returns an expression for the call.  */\n-\n-tree \n-finish_qualified_object_call_expr (tree fn, tree object, tree args)\n-{\n-  return build_scoped_method_call (object, TREE_OPERAND (fn, 0),\n-\t\t\t\t   TREE_OPERAND (fn, 1), args);\n-}\n-\n /* Finish a pseudo-destructor expression.  If SCOPE is NULL, the\n    expression was of the form `OBJECT.~DESTRUCTOR' where DESTRUCTOR is\n    the TYPE for the type given.  If SCOPE is non-NULL, the expression"}, {"sha": "e6abb3df57f28e2bed9544737956c08a4293212c", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d", "patch": "@@ -72,8 +72,7 @@ static tree lookup_destructor (tree, tree, tree);\n tree\n target_type (tree type)\n {\n-  if (TREE_CODE (type) == REFERENCE_TYPE)\n-    type = TREE_TYPE (type);\n+  type = non_reference (type);\n   while (TREE_CODE (type) == POINTER_TYPE\n \t || TREE_CODE (type) == ARRAY_TYPE\n \t || TREE_CODE (type) == FUNCTION_TYPE\n@@ -1421,9 +1420,8 @@ cxx_sizeof_or_alignof_type (tree type, enum tree_code op, int complain)\n     return build_min_nt (op, type);\n   \n   op_name = operator_name_info[(int) op].name;\n-  \n-  if (TREE_CODE (type) == REFERENCE_TYPE)\n-    type = TREE_TYPE (type);\n+\n+  type = non_reference (type);\n   type_code = TREE_CODE (type);\n \n   if (type_code == METHOD_TYPE)\n@@ -5888,8 +5886,7 @@ tree\n dubious_conversion_warnings (tree type, tree expr,\n \t\t\t     const char *errtype, tree fndecl, int parmnum)\n {\n-  if (TREE_CODE (type) == REFERENCE_TYPE)\n-    type = TREE_TYPE (type);\n+  type = non_reference (type);\n   \n   /* Issue warnings about peculiar, but valid, uses of NULL.  */\n   if (ARITHMETIC_TYPE_P (type) && expr == null_node)\n@@ -6102,8 +6099,7 @@ convert_for_initialization (tree exp, tree type, tree rhs, int flags,\n   if (exp == error_mark_node)\n     return error_mark_node;\n \n-  if (TREE_CODE (rhstype) == REFERENCE_TYPE)\n-    rhstype = TREE_TYPE (rhstype);\n+  rhstype = non_reference (rhstype);\n \n   type = complete_type (type);\n \n@@ -6708,3 +6704,14 @@ strip_all_pointer_quals (tree type)\n   else\n     return TYPE_MAIN_VARIANT (type);\n }\n+\n+/* If T is a REFERENCE_TYPE return the type to which T refers.\n+   Otherwise, return T itself.  */\n+\n+tree\n+non_reference (tree t)\n+{\n+  if (TREE_CODE (t) == REFERENCE_TYPE)\n+    t = TREE_TYPE (t);\n+  return t;\n+}"}]}