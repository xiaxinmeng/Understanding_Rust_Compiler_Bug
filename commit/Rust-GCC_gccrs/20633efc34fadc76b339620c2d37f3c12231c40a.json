{"sha": "20633efc34fadc76b339620c2d37f3c12231c40a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjA2MzNlZmMzNGZhZGM3NmIzMzk2MjBjMmQzN2YzYzEyMjMxYzQwYQ==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2011-09-26T08:14:25Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2011-09-26T08:14:25Z"}, "message": "avr-protos.h (output_reload_inhi): Change prototype.\n\n\t* config/avr/avr-protos.h (output_reload_inhi): Change prototype.\n\t* config/avr/avr.md (adjust_len): Add \"reload_in16\" alternative.\n\t(*reload_inhi): Use it.  Adapt call to output_reload_inhi to new\n\tprototype.\n\t(*movhi): Split constraint alternative \"r,rL\" into \"r,r\" and \"r,L\".\n\t* config/avr/avr.c: Rename output_reload_insisf_1 to\n\toutput_reload_in_const.\n\t(avr_popcount_each_byte): Handle SFmode, too.\n\t(output_reload_in_const): Change so it can handle HI loads, too.\n\tUse avr_popcount_each_byte to work out if scratch register must be\n\tcreated on the fly.\n\t(output_reload_inhi): Rewrite using output_reload_in_const and...\n\t(output_movhi): ...use it to print constants' loads.\n\t(adjust_insn_length): New case ADJUST_LEN_RELOAD_IN16. Cleanup code.\n\nFrom-SVN: r179181", "tree": {"sha": "23c55d512e551d6f39bd0e5e625a4370ea4d9e12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23c55d512e551d6f39bd0e5e625a4370ea4d9e12"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/20633efc34fadc76b339620c2d37f3c12231c40a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20633efc34fadc76b339620c2d37f3c12231c40a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20633efc34fadc76b339620c2d37f3c12231c40a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20633efc34fadc76b339620c2d37f3c12231c40a/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50179d5882b4abaed3c5deaa6a3068e01956fe29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50179d5882b4abaed3c5deaa6a3068e01956fe29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50179d5882b4abaed3c5deaa6a3068e01956fe29"}], "stats": {"total": 296, "additions": 118, "deletions": 178}, "files": [{"sha": "71ab33bbd6246c2dd2b5665d920110302ea5aee1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20633efc34fadc76b339620c2d37f3c12231c40a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20633efc34fadc76b339620c2d37f3c12231c40a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=20633efc34fadc76b339620c2d37f3c12231c40a", "patch": "@@ -1,3 +1,20 @@\n+2011-09-26  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\t* config/avr/avr-protos.h (output_reload_inhi): Change prototype.\n+\t* config/avr/avr.md (adjust_len): Add \"reload_in16\" alternative.\n+\t(*reload_inhi): Use it.  Adapt call to output_reload_inhi to new\n+\tprototype.\n+\t(*movhi): Split constraint alternative \"r,rL\" into \"r,r\" and \"r,L\".\n+\t* config/avr/avr.c: Rename output_reload_insisf_1 to\n+\toutput_reload_in_const.\n+\t(avr_popcount_each_byte): Handle SFmode, too.\n+\t(output_reload_in_const): Change so it can handle HI loads, too.\n+\tUse avr_popcount_each_byte to work out if scratch register must be\n+\tcreated on the fly.\n+\t(output_reload_inhi): Rewrite using output_reload_in_const and...\n+\t(output_movhi): ...use it to print constants' loads.\n+\t(adjust_insn_length): New case ADJUST_LEN_RELOAD_IN16. Cleanup code.\n+\n 2011-09-25  David S. Miller  <davem@davemloft.net>\n \n \t* config/sparc/constraints.md (C, P, Z): New constraints for"}, {"sha": "fe02dc97e4e0e16683c7cddaa7b62f22c869841f", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20633efc34fadc76b339620c2d37f3c12231c40a/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20633efc34fadc76b339620c2d37f3c12231c40a/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=20633efc34fadc76b339620c2d37f3c12231c40a", "patch": "@@ -87,7 +87,7 @@ extern bool avr_popcount_each_byte (rtx, int, int);\n \n extern int extra_constraint_Q (rtx x);\n extern int adjust_insn_length (rtx insn, int len);\n-extern const char *output_reload_inhi (rtx insn, rtx *operands, int *len);\n+extern const char* output_reload_inhi (rtx*, rtx, int*);\n extern const char *output_reload_insisf (rtx insn, rtx *operands, rtx clobber, int *len);\n extern void notice_update_cc (rtx body, rtx insn);\n extern void print_operand (FILE *file, rtx x, int code);"}, {"sha": "8f4ae97ae8bc7cc860d7d0b3164fb4318acc0897", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 91, "deletions": 171, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20633efc34fadc76b339620c2d37f3c12231c40a/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20633efc34fadc76b339620c2d37f3c12231c40a/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=20633efc34fadc76b339620c2d37f3c12231c40a", "patch": "@@ -319,19 +319,24 @@ avr_popcount (unsigned int val)\n }\n \n \n-/* Constraint helper function.  XVAL is an CONST_INT.  Return true if the least\n-   significant N_BYTES bytes of XVAL all have a popcount in POP_MASK and false,\n-   otherwise.  POP_MASK represents a subset of integers which contains an\n-   integer N iff bit N of POP_MASK is set.  */\n+/* Constraint helper function.  XVAL is a CONST_INT or a CONST_DOUBLE.\n+   Return true if the least significant N_BYTES bytes of XVAL all have a\n+   popcount in POP_MASK and false, otherwise.  POP_MASK represents a subset\n+   of integers which contains an integer N iff bit N of POP_MASK is set.  */\n    \n bool\n avr_popcount_each_byte (rtx xval, int n_bytes, int pop_mask)\n {\n   int i;\n \n+  enum machine_mode mode = GET_MODE (xval);\n+\n+  if (VOIDmode == mode)\n+    mode = SImode;\n+\n   for (i = 0; i < n_bytes; i++)\n     {\n-      rtx xval8 = simplify_gen_subreg (QImode, xval, SImode, i);\n+      rtx xval8 = simplify_gen_subreg (QImode, xval, mode, i);\n       unsigned int val8 = UINTVAL (xval8) & GET_MODE_MASK (QImode);\n \n       if (0 == (pop_mask & (1 << avr_popcount (val8))))\n@@ -2077,84 +2082,9 @@ output_movhi (rtx insn, rtx operands[], int *l)\n \t    }\n \t}\n       else if (CONSTANT_P (src))\n-\t{\n-\t  if (test_hard_reg_class (LD_REGS, dest)) /* ldi d,i */\n-\t    {\n-\t      *l = 2;\n-\t      return (AS2 (ldi,%A0,lo8(%1)) CR_TAB\n-\t\t      AS2 (ldi,%B0,hi8(%1)));\n-\t    }\n-\t  \n-\t  if (GET_CODE (src) == CONST_INT)\n-\t    {\n-\t      if (src == const0_rtx) /* mov r,L */\n-\t\t{\n-\t\t  *l = 2;\n-\t\t  return (AS1 (clr,%A0) CR_TAB\n-\t\t\t  AS1 (clr,%B0));\n-\t\t}\n-\t      else if (src == const1_rtx)\n-\t\t{\n-\t\t  *l = 3;\n-\t\t  return (AS1 (clr,%A0) CR_TAB\n-\t\t\t  AS1 (clr,%B0) CR_TAB\n-\t\t\t  AS1 (inc,%A0));\n-\t\t}\n-\t      else if (src == constm1_rtx)\n-\t\t{\n-\t\t  /* Immediate constants -1 to any register */\n-\t\t  *l = 3;\n-\t\t  return (AS1 (clr,%0)  CR_TAB\n-\t\t\t  AS1 (dec,%A0) CR_TAB\n-\t\t\t  AS2 (mov,%B0,%A0));\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  int bit_nr = exact_log2 (INTVAL (src));\n-\n-\t\t  if (bit_nr >= 0)\n-\t\t    {\n-\t\t      *l = 4;\n-\t\t      if (!real_l)\n-\t\t\toutput_asm_insn ((AS1 (clr,%A0) CR_TAB\n-\t\t\t\t\t  AS1 (clr,%B0) CR_TAB\n-\t\t\t\t\t  \"set\"), operands);\n-\t\t      if (!real_l)\n-\t\t\tavr_output_bld (operands, bit_nr);\n-\n-\t\t      return \"\";\n-\t\t    }\n-\t\t}\n-\n-\t      if ((INTVAL (src) & 0xff) == 0)\n-\t\t{\n-\t\t  *l = 5;\n-\t\t  return (AS2 (mov,__tmp_reg__,r31) CR_TAB\n-\t\t\t  AS1 (clr,%A0)             CR_TAB\n-\t\t\t  AS2 (ldi,r31,hi8(%1))     CR_TAB\n-\t\t\t  AS2 (mov,%B0,r31)         CR_TAB\n-\t\t\t  AS2 (mov,r31,__tmp_reg__));\n-\t\t}\n-\t      else if ((INTVAL (src) & 0xff00) == 0)\n-\t\t{\n-\t\t  *l = 5;\n-\t\t  return (AS2 (mov,__tmp_reg__,r31) CR_TAB\n-\t\t\t  AS2 (ldi,r31,lo8(%1))     CR_TAB\n-\t\t\t  AS2 (mov,%A0,r31)         CR_TAB\n-\t\t\t  AS1 (clr,%B0)             CR_TAB\n-\t\t\t  AS2 (mov,r31,__tmp_reg__));\n-\t\t}\n-\t    }\n-\t  \n-\t  /* Last resort, equal to loading from memory.  */\n-\t  *l = 6;\n-\t  return (AS2 (mov,__tmp_reg__,r31) CR_TAB\n-\t\t  AS2 (ldi,r31,lo8(%1))     CR_TAB\n-\t\t  AS2 (mov,%A0,r31)         CR_TAB\n-\t\t  AS2 (ldi,r31,hi8(%1))     CR_TAB\n-\t\t  AS2 (mov,%B0,r31)         CR_TAB\n-\t\t  AS2 (mov,r31,__tmp_reg__));\n-\t}\n+        {\n+          return output_reload_inhi (operands, NULL, real_l);\n+        }\n       else if (GET_CODE (src) == MEM)\n \treturn out_movhi_r_mr (insn, operands, real_l); /* mov r,m */\n     }\n@@ -5125,6 +5055,10 @@ adjust_insn_length (rtx insn, int len)\n       \n       switch (adjust_len)\n         {\n+        case ADJUST_LEN_RELOAD_IN16:\n+          output_reload_inhi (op, op[2], &len);\n+          break;\n+          \n         case ADJUST_LEN_RELOAD_IN32:\n           output_reload_insisf (insn, op, op[2], &len);\n           break;\n@@ -5185,31 +5119,7 @@ adjust_insn_length (rtx insn, int len)\n       op[1] = SET_SRC (set);\n       op[0] = SET_DEST (set);\n \n-      if (GET_CODE (patt) == PARALLEL\n-\t  && general_operand (op[1], VOIDmode)\n-\t  && general_operand (op[0], VOIDmode))\n-\t{\n-\t  if (XVECLEN (patt, 0) == 2)\n-\t    op[2] = XVECEXP (patt, 0, 1);\n-\n-\t  switch (GET_MODE (op[0]))\n-\t    {\n-\t    case QImode:\n-\t      len = 2;\n-\t      break;\n-\t    case HImode:\n-\t      output_reload_inhi (insn, op, &len);\n-\t      break;\n-\t    case SImode:\n-\t    case SFmode:\n-\t      /* Handled by ADJUST_LEN_RELOAD_INSISF above.  */\n-\t      gcc_unreachable();\n-\t      break;\n-\t    default:\n-\t      break;\n-\t    }\n-\t}\n-      else if (GET_CODE (op[1]) == ASHIFT\n+      if (GET_CODE (op[1]) == ASHIFT\n \t  || GET_CODE (op[1]) == ASHIFTRT\n \t  || GET_CODE (op[1]) == LSHIFTRT)\n \t{\n@@ -7153,45 +7063,6 @@ avr_hard_regno_mode_ok (int regno, enum machine_mode mode)\n   return !(regno & 1);\n }\n \n-const char *\n-output_reload_inhi (rtx insn ATTRIBUTE_UNUSED, rtx *operands, int *len)\n-{\n-  int tmp;\n-  if (!len)\n-    len = &tmp;\n-      \n-  if (GET_CODE (operands[1]) == CONST_INT)\n-    {\n-      int val = INTVAL (operands[1]);\n-      if ((val & 0xff) == 0)\n-\t{\n-\t  *len = 3;\n-\t  return (AS2 (mov,%A0,__zero_reg__) CR_TAB\n-\t\t  AS2 (ldi,%2,hi8(%1))       CR_TAB\n-\t\t  AS2 (mov,%B0,%2));\n-\t}\n-      else if ((val & 0xff00) == 0)\n-\t{\n-\t  *len = 3;\n-\t  return (AS2 (ldi,%2,lo8(%1)) CR_TAB\n-\t\t  AS2 (mov,%A0,%2)     CR_TAB\n-\t\t  AS2 (mov,%B0,__zero_reg__));\n-\t}\n-      else if ((val & 0xff) == ((val & 0xff00) >> 8))\n-\t{\n-\t  *len = 3;\n-\t  return (AS2 (ldi,%2,lo8(%1)) CR_TAB\n-\t\t  AS2 (mov,%A0,%2)     CR_TAB\n-\t\t  AS2 (mov,%B0,%2));\n-\t}\n-    }\n-  *len = 4;\n-  return (AS2 (ldi,%2,lo8(%1)) CR_TAB\n-\t  AS2 (mov,%A0,%2)     CR_TAB\n-\t  AS2 (ldi,%2,hi8(%1)) CR_TAB\n-\t  AS2 (mov,%B0,%2));\n-}\n-\n \n /* A helper for `output_reload_insisf'.  */\n /* Set 32-bit register OP[0] to compile-time constant OP[1].\n@@ -7203,7 +7074,7 @@ output_reload_inhi (rtx insn ATTRIBUTE_UNUSED, rtx *operands, int *len)\n    If CLEAR_P is false, nothing is known about OP[0].  */\n \n static void\n-output_reload_insisf_1 (rtx *op, rtx clobber_reg, int *len, bool clear_p)\n+output_reload_in_const (rtx *op, rtx clobber_reg, int *len, bool clear_p)\n {\n   rtx src = op[1];\n   rtx dest = op[0];\n@@ -7223,7 +7094,8 @@ output_reload_insisf_1 (rtx *op, rtx clobber_reg, int *len, bool clear_p)\n   /* (REG:SI 14) is special: It's neither in LD_REGS nor in NO_LD_REGS\n      but has some subregs that are in LD_REGS.  Use the MSB (REG:QI 17).  */\n   \n-  if (14 == REGNO (dest))\n+  if (14 == REGNO (dest)\n+      && 4 == GET_MODE_SIZE (mode))\n     {\n       clobber_reg = gen_rtx_REG (QImode, 17);\n     }\n@@ -7233,25 +7105,16 @@ output_reload_insisf_1 (rtx *op, rtx clobber_reg, int *len, bool clear_p)\n      a byte that is neither 0, -1 or a power of 2.  */\n   \n   if (NULL_RTX == clobber_reg\n-      && !test_hard_reg_class (LD_REGS, dest))\n+      && !test_hard_reg_class (LD_REGS, dest)\n+      && !avr_popcount_each_byte (src, GET_MODE_SIZE (mode),\n+                                  (1 << 0) | (1 << 1) | (1 << 8)))\n     {\n-      for (n = 0; n < GET_MODE_SIZE (mode); n++)\n-        {\n-          xval = simplify_gen_subreg (QImode, src, mode, n);\n-\n-          if (!(const0_rtx == xval\n-                || constm1_rtx == xval\n-                || single_one_operand (xval, QImode)))\n-            {\n-              /* We have no clobber reg but need one.  Cook one up.\n-                 That's cheaper than loading from constant pool.  */\n-              \n-              cooked_clobber_p = true;\n-              clobber_reg = gen_rtx_REG (QImode, REG_Z + 1);\n-              avr_asm_len (\"mov __tmp_reg__,%0\", &clobber_reg, len, 1);\n-              break;\n-            }\n-        }\n+      /* We have no clobber register but need one.  Cook one up.\n+         That's cheaper than loading from constant pool.  */\n+      \n+      cooked_clobber_p = true;\n+      clobber_reg = gen_rtx_REG (QImode, REG_Z + 1);\n+      avr_asm_len (\"mov __tmp_reg__,%0\", &clobber_reg, len, 1);\n     }\n \n   /* Now start filling DEST from LSB to MSB.  */\n@@ -7396,6 +7259,63 @@ output_reload_insisf_1 (rtx *op, rtx clobber_reg, int *len, bool clear_p)\n }\n \n \n+/* Reload the constant OP[1] into the HI register OP[0].\n+   CLOBBER_REG is a QI clobber reg needed to move vast majority of consts\n+   into a NO_LD_REGS register.  If CLOBBER_REG is NULL_RTX we either don't\n+   need a clobber reg or have to cook one up.\n+\n+   PLEN == NULL: Output instructions.\n+   PLEN != NULL: Output nothing.  Set *PLEN to number of words occupied\n+                 by the insns printed.\n+\n+   Return \"\".  */\n+\n+const char*\n+output_reload_inhi (rtx *op, rtx clobber_reg, int *plen)\n+{\n+  if (CONST_INT_P (op[1]))\n+    {\n+      output_reload_in_const (op, clobber_reg, plen, false);\n+    }\n+  else if (test_hard_reg_class (LD_REGS, op[0]))\n+    {\n+      avr_asm_len (\"ldi %A0,lo8(%1)\" CR_TAB\n+                   \"ldi %B0,hi8(%1)\", op, plen, -2);\n+    }\n+  else\n+    {\n+      rtx xop[3];\n+\n+      xop[0] = op[0];\n+      xop[1] = op[1];\n+      xop[2] = clobber_reg;\n+      \n+      if (plen)\n+        *plen = 0;\n+      \n+      if (clobber_reg == NULL_RTX)\n+        {\n+          /* No scratch register provided: cook une up.  */\n+          \n+          xop[2] = gen_rtx_REG (QImode, REG_Z + 1);\n+          avr_asm_len (\"mov __tmp_reg__,%2\", xop, plen, 1);\n+        }\n+      \n+      avr_asm_len (\"ldi %2,lo8(%1)\" CR_TAB\n+                   \"mov %A0,%2\"     CR_TAB\n+                   \"ldi %2,hi8(%1)\" CR_TAB\n+                   \"mov %B0,%2\", xop, plen, 4);\n+\n+      if (clobber_reg == NULL_RTX)\n+        {\n+          avr_asm_len (\"mov %2,__tmp_reg__\", xop, plen, 1);\n+        }\n+    }\n+\n+  return \"\";\n+}\n+\n+\n /* Reload a SI or SF compile time constant OP[1] into the register OP[0].\n    CLOBBER_REG is a QI clobber reg needed to move vast majority of consts\n    into a NO_LD_REGS register.  If CLOBBER_REG is NULL_RTX we either don't\n@@ -7432,8 +7352,8 @@ output_reload_insisf (rtx insn ATTRIBUTE_UNUSED,\n          Instead, we call the print function twice to get the lengths of\n          both methods and use the shortest one.  */\n          \n-      output_reload_insisf_1 (op, clobber_reg, &len_clr, true);\n-      output_reload_insisf_1 (op, clobber_reg, &len_noclr, false);\n+      output_reload_in_const (op, clobber_reg, &len_clr, true);\n+      output_reload_in_const (op, clobber_reg, &len_noclr, false);\n       \n       if (len_noclr - len_clr == 4)\n         {\n@@ -7443,7 +7363,7 @@ output_reload_insisf (rtx insn ATTRIBUTE_UNUSED,\n                        \"clr %B0\" CR_TAB\n                        \"movw %C0,%A0\", &op[0], len, 3);\n           \n-          output_reload_insisf_1 (op, clobber_reg, len, true);\n+          output_reload_in_const (op, clobber_reg, len, true);\n           \n           if (len)\n             *len += 3;\n@@ -7454,7 +7374,7 @@ output_reload_insisf (rtx insn ATTRIBUTE_UNUSED,\n \n   /* Default: destination not pre-cleared.  */\n \n-  output_reload_insisf_1 (op, clobber_reg, len, false);\n+  output_reload_in_const (op, clobber_reg, len, false);\n   return \"\";\n }\n "}, {"sha": "294023076182150afdd5999b472d157cb074f3d3", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20633efc34fadc76b339620c2d37f3c12231c40a/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20633efc34fadc76b339620c2d37f3c12231c40a/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=20633efc34fadc76b339620c2d37f3c12231c40a", "patch": "@@ -136,7 +136,7 @@\n ;; Otherwise do special processing depending on the attribute.\n \n (define_attr \"adjust_len\"\n-  \"yes,no,reload_in32,out_bitop,out_plus,tsthi,tstsi,compare\"\n+  \"yes,no,reload_in16,reload_in32,out_bitop,out_plus,tsthi,tstsi,compare\"\n   (const_string \"yes\"))\n \n ;; Define mode iterators\n@@ -387,18 +387,21 @@\n         (match_operand:HI 1 \"immediate_operand\" \"i\"))\n    (clobber (match_operand:QI 2 \"register_operand\" \"=&d\"))]\n   \"reload_completed\"\n-  \"* return output_reload_inhi (insn, operands, NULL);\"\n+  {\n+    return output_reload_inhi (operands, operands[2], NULL);\n+  }\n   [(set_attr \"length\" \"4\")\n+   (set_attr \"adjust_len\" \"reload_in16\")\n    (set_attr \"cc\" \"none\")])\n \n (define_insn \"*movhi\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r,m,d,*r,q,r\")\n-        (match_operand:HI 1 \"general_operand\"       \"rL,m,rL,i,i,r,q\"))]\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r,r,m,d,*r,q,r\")\n+        (match_operand:HI 1 \"general_operand\"       \"r,L,m,rL,i,i,r,q\"))]\n   \"(register_operand (operands[0],HImode)\n     || register_operand (operands[1],HImode) || const0_rtx == operands[1])\"\n   \"* return output_movhi (insn, operands, NULL);\"\n-  [(set_attr \"length\" \"2,6,7,2,6,5,2\")\n-   (set_attr \"cc\" \"none,clobber,clobber,none,clobber,none,none\")])\n+  [(set_attr \"length\" \"2,2,6,7,2,6,5,2\")\n+   (set_attr \"cc\" \"none,clobber,clobber,clobber,none,clobber,none,none\")])\n \n (define_peephole2 ; movw\n   [(set (match_operand:QI 0 \"even_register_operand\" \"\")"}]}