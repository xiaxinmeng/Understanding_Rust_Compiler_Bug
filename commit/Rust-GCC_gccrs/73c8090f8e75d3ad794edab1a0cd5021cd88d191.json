{"sha": "73c8090f8e75d3ad794edab1a0cd5021cd88d191", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzNjODA5MGY4ZTc1ZDNhZDc5NGVkYWIxYTBjZDUwMjFjZDg4ZDE5MQ==", "commit": {"author": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "1998-06-30T14:45:56Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "1998-06-30T14:45:56Z"}, "message": "tm.texi: document STACK_SAVEAREA_MODE.\n\nmd.texi: update save_stack_* pattern description.\n\nFrom-SVN: r20844", "tree": {"sha": "de7d9ac754f4158ed994cf6063ff0220c93487ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de7d9ac754f4158ed994cf6063ff0220c93487ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73c8090f8e75d3ad794edab1a0cd5021cd88d191", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73c8090f8e75d3ad794edab1a0cd5021cd88d191", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73c8090f8e75d3ad794edab1a0cd5021cd88d191", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73c8090f8e75d3ad794edab1a0cd5021cd88d191/comments", "author": null, "committer": null, "parents": [{"sha": "2067f1f59dd1776dfb63b32bd770d5284cac118f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2067f1f59dd1776dfb63b32bd770d5284cac118f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2067f1f59dd1776dfb63b32bd770d5284cac118f"}], "stats": {"total": 30, "additions": 22, "deletions": 8}, "files": [{"sha": "a3ebe693e438a5250ad2c5164431e77222147254", "filename": "gcc/md.texi", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73c8090f8e75d3ad794edab1a0cd5021cd88d191/gcc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73c8090f8e75d3ad794edab1a0cd5021cd88d191/gcc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmd.texi?ref=73c8090f8e75d3ad794edab1a0cd5021cd88d191", "patch": "@@ -2412,14 +2412,15 @@ such required data.\n @end enumerate\n \n When saving the stack pointer, operand 0 is the save area and operand 1\n-is the stack pointer.  The mode used to allocate the save area is the\n-mode of operand 0.  You must specify an integral mode, or\n-@code{VOIDmode} if no save area is needed for a particular type of save\n-(either because no save is needed or because a machine-specific save\n-area can be used).  Operand 0 is the stack pointer and operand 1 is the\n-save area for restore operations.  If @samp{save_stack_block} is\n-defined, operand 0 must not be @code{VOIDmode} since these saves can be\n-arbitrarily nested.\n+is the stack pointer.  The mode used to allocate the save area defaults\n+to @code{Pmode} but you can override that choice by defining the\n+@code{STACK_SAVEAREA_MODE} macro (@pxref{Storage_Layout}).  You must\n+specify an integral mode, or @code{VOIDmode} if no save area is needed\n+for a particular type of save (either because no save is needed or\n+because a machine-specific save area can be used).  Operand 0 is the\n+stack pointer and operand 1 is the save area for restore operations.  If\n+@samp{save_stack_block} is defined, operand 0 must not be\n+@code{VOIDmode} since these saves can be arbitrarily nested.\n \n A save area is a @code{mem} that is at a constant offset from\n @code{virtual_stack_vars_rtx} when the stack pointer is saved for use by"}, {"sha": "78cc6ce496cf0bfb0654525590f01dc344689a16", "filename": "gcc/tm.texi", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73c8090f8e75d3ad794edab1a0cd5021cd88d191/gcc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73c8090f8e75d3ad794edab1a0cd5021cd88d191/gcc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftm.texi?ref=73c8090f8e75d3ad794edab1a0cd5021cd88d191", "patch": "@@ -979,6 +979,19 @@ this size or smaller can be used for structures and unions with the\n appropriate sizes.  If this macro is undefined, @code{GET_MODE_BITSIZE\n (DImode)} is assumed.\n \n+@findex STACK_SAVEAREA_MODE\n+@item STACK_SAVEAREA_MODE (@var{save_level})\n+If defined, an expression of type @code{enum machine_mode} that\n+specifies the mode of a @code{save_stack_@var{level}} named pattern\n+(@pxref{Standard Names}).  @var{save_level} is one of @code{SAVE_BLOCK},\n+@code{SAVE_FUNCTION}, or @code{SAVE_NONLOCAL} and selects which of the\n+three named patterns is having its mode specified.\n+\n+You need not define this macro if it always returns @code{Pmode}.  You\n+would most commonly define this macro if the\n+@code{save_stack_@var{level}} patterns need to support both a 32- and a\n+64-bit mode.\n+\n @findex CHECK_FLOAT_VALUE\n @item CHECK_FLOAT_VALUE (@var{mode}, @var{value}, @var{overflow})\n A C statement to validate the value @var{value} (of type"}]}