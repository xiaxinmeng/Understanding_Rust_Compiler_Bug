{"sha": "99fc25020d47424e0c0b0da370e2e18540b96b73", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTlmYzI1MDIwZDQ3NDI0ZTBjMGIwZGEzNzBlMmUxODU0MGI5NmI3Mw==", "commit": {"author": {"name": "Chen Liqin", "email": "liqin@sunnorth.com.cn", "date": "2007-01-08T04:47:33Z"}, "committer": {"name": "Chen Liqin", "email": "liqin@gcc.gnu.org", "date": "2007-01-08T04:47:33Z"}, "message": "t-score-elf (MULTILIB_OPTIONS): Change.\n\n\t* config/score/t-score-elf (MULTILIB_OPTIONS): Change.\n\t* config/score/predicates.md (const_uimm5, sr0_operand, const_simm12,\n\tconst_simm15, const_pow2, const_npow2): Added.\n\t* config/score/misc.md (insv, extv, extzv, movmemsi, \n\tmove_lbu_a/b, mov_lhu_a/b etc): Added and fix some bug.\n\t* config/score/score.c (score_address_cost, score_select_cc_mode): \n\tAdded.\n\tChange CONST_OK_FOR_LETTER_P/EXTRA_CONSTRAINT define.\n\tUpdate score_rtx_costs for MACRO TARGET_RTX_COSTS.\n\tUpdate score_print_operand.\n\t* config/score/score.h (DATA_ALIGNMENT, SELECT_CC_MODE): Added.\n\tAdjust register allocate order and update some macro define.\n\t* config/score/score-mdaux.c (mdx_unaligned_load, mdx_unsigned_store,\n\tmdx_block_move_straight, mdx_block_move_loop_head,\n\tmdx_block_move_loop_body, mdx_block_move_loop_foot, mdx_block_move_loop,\n\tmdx_block_move): Added.\n\t(mdx_movsicc, mdp_select_add_imm, mdp_select, mds_zero_extract_andi,\n\tmdp_limm): Updated and fix some bug and typo.\n\t* config/score/score.md (movqi/hi/si, add/sub/zero/ext): Updated.\n\t(movsf, movdf, doloop_end): Added.\n\nFrom-SVN: r120570", "tree": {"sha": "789e5b3c80322464e00e5cabe161cb3c0f47d875", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/789e5b3c80322464e00e5cabe161cb3c0f47d875"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/99fc25020d47424e0c0b0da370e2e18540b96b73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99fc25020d47424e0c0b0da370e2e18540b96b73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99fc25020d47424e0c0b0da370e2e18540b96b73", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99fc25020d47424e0c0b0da370e2e18540b96b73/comments", "author": null, "committer": null, "parents": [{"sha": "0979f01dee2c058122e0f57926e14fe53115e8f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0979f01dee2c058122e0f57926e14fe53115e8f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0979f01dee2c058122e0f57926e14fe53115e8f6"}], "stats": {"total": 1889, "additions": 1493, "deletions": 396}, "files": [{"sha": "8e36d9189b21ce4992c9ca3decbba8c604400e4e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99fc25020d47424e0c0b0da370e2e18540b96b73/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99fc25020d47424e0c0b0da370e2e18540b96b73/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=99fc25020d47424e0c0b0da370e2e18540b96b73", "patch": "@@ -1,3 +1,25 @@\n+2007-01-08  Chen Liqin  <liqin@sunnorth.com.cn>\n+\t* config/score/t-score-elf (MULTILIB_OPTIONS): Change.\n+\t* config/score/predicates.md (const_uimm5, sr0_operand, const_simm12,\n+\tconst_simm15, const_pow2, const_npow2): Added.\n+\t* config/score/misc.md (insv, extv, extzv, movmemsi, \n+\tmove_lbu_a/b, mov_lhu_a/b etc): Added and fix some bug.\n+\t* config/score/score.c (score_address_cost, score_select_cc_mode): \n+\tAdded.\n+\tChange CONST_OK_FOR_LETTER_P/EXTRA_CONSTRAINT define.\n+\tUpdate score_rtx_costs for MACRO TARGET_RTX_COSTS.\n+\tUpdate score_print_operand.\n+\t* config/score/score.h (DATA_ALIGNMENT, SELECT_CC_MODE): Added.\n+\tAdjust register allocate order and update some macro define.\n+\t* config/score/score-mdaux.c (mdx_unaligned_load, mdx_unsigned_store,\n+\tmdx_block_move_straight, mdx_block_move_loop_head,\n+\tmdx_block_move_loop_body, mdx_block_move_loop_foot, mdx_block_move_loop,\n+\tmdx_block_move): Added.\n+\t(mdx_movsicc, mdp_select_add_imm, mdp_select, mds_zero_extract_andi,\n+\tmdp_limm): Updated and fix some bug and typo.\n+\t* config/score/score.md (movqi/hi/si, add/sub/zero/ext): Updated.\n+\t(movsf, movdf, doloop_end): Added.\n+\n 2007-01-08  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* config/arm/arm.c, config/arm/arm.h, config/arm/arm.md,"}, {"sha": "8c6bca0e0cdde9d2fc3603bb9b4280b4ebad8656", "filename": "gcc/config/score/crti.asm", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99fc25020d47424e0c0b0da370e2e18540b96b73/gcc%2Fconfig%2Fscore%2Fcrti.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99fc25020d47424e0c0b0da370e2e18540b96b73/gcc%2Fconfig%2Fscore%2Fcrti.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fcrti.asm?ref=99fc25020d47424e0c0b0da370e2e18540b96b73", "patch": "@@ -43,8 +43,8 @@\n         .mask   0x00000000, 0\n _start:\n         la      r28, _gp\n-        la      r8, __bss_start\n-        la      r9, __bss_end__\n+        la      r8, _bss_start\n+        la      r9, _bss_end__\n         sub!    r9, r8\n         srli!   r9, 2\n         addi    r9, -1\n@@ -91,8 +91,8 @@ _fini:\n         .mask   0x00000000,0\n _start:\n         la      r28, _gp\n-        la      r8, __bss_start\n-        la      r9, __bss_end__\n+        la      r8, _bss_start\n+        la      r9, _bss_end__\n         sub!    r9, r8\n         srli!   r9, 2\n         addi    r9, -1\n@@ -102,15 +102,10 @@ _start:\n         sw      r9, [r8]+, 4\n         bcnz    1b\n         la      r0, _stack\n-#       jl      _init\n-#       la      r4, _end\n-#       jl      _init_argv\n         ldiu!   r4, 0\n         ldiu!   r5, 0\n-#       jl      main\n         la      r29, main\n         brl     r29\n-#       jl      exit\n         la      r29, exit\n         brl     r29\n         .end    _start"}, {"sha": "add988ed5f726f68a764e786c7a7623a81e24343", "filename": "gcc/config/score/crtn.asm", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99fc25020d47424e0c0b0da370e2e18540b96b73/gcc%2Fconfig%2Fscore%2Fcrtn.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99fc25020d47424e0c0b0da370e2e18540b96b73/gcc%2Fconfig%2Fscore%2Fcrtn.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fcrtn.asm?ref=99fc25020d47424e0c0b0da370e2e18540b96b73", "patch": "@@ -59,4 +59,3 @@\n         br      r3\n #endif\n \n-"}, {"sha": "a4f817040f1720497ad4235a234c08edaa8f59a9", "filename": "gcc/config/score/misc.md", "status": "modified", "additions": 312, "deletions": 3, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99fc25020d47424e0c0b0da370e2e18540b96b73/gcc%2Fconfig%2Fscore%2Fmisc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99fc25020d47424e0c0b0da370e2e18540b96b73/gcc%2Fconfig%2Fscore%2Fmisc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fmisc.md?ref=99fc25020d47424e0c0b0da370e2e18540b96b73", "patch": "@@ -84,8 +84,8 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n         (if_then_else:SI (match_operator 1 \"comparison_operator\"\n                           [(reg:CC CC_REGNUM) (const_int 0)])\n-                         (match_operand:SI 2 \"register_operand\" \"d\")\n-                         (match_operand:SI 3 \"register_operand\" \"0\")))]\n+                         (match_operand:SI 2 \"arith_operand\" \"d\")\n+                         (match_operand:SI 3 \"arith_operand\" \"0\")))]\n   \"\"\n   \"mv%C1   %0, %2\"\n   [(set_attr \"type\" \"cndmv\")\n@@ -95,7 +95,7 @@\n   [(set (reg:CC_NZ CC_REGNUM)\n         (compare:CC_NZ (unspec:SI\n                         [(match_operand:SI 0 \"register_operand\" \"*e,d\")\n-                         (match_operand:SI 1 \"const_bi_operand\" \"\")]\n+                         (match_operand:SI 1 \"const_uimm5\" \"\")]\n                         BITTST)\n                        (const_int 0)))]\n   \"\"\n@@ -106,3 +106,312 @@\n    (set_attr \"up_c\" \"yes\")\n    (set_attr \"mode\" \"SI\")])\n \n+(define_expand \"extzv\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+        (zero_extract (match_operand:SI 1 \"memory_operand\" \"\")\n+                      (match_operand:SI 2 \"immediate_operand\" \"\")\n+                      (match_operand:SI 3 \"immediate_operand\" \"\")))]\n+  \"!TARGET_SCORE5U && !TARGET_LITTLE_ENDIAN\"\n+{\n+  if (mdx_unaligned_load (operands))\n+    DONE;\n+  else\n+    FAIL;\n+})\n+\n+(define_expand \"insv\"\n+  [(set (zero_extract (match_operand:SI 0 \"memory_operand\" \"\")\n+                      (match_operand:SI 1 \"immediate_operand\" \"\")\n+                      (match_operand:SI 2 \"immediate_operand\" \"\"))\n+        (match_operand:SI 3 \"register_operand\" \"\"))]\n+  \"!TARGET_SCORE5U && !TARGET_LITTLE_ENDIAN\"\n+{\n+  if (mdx_unaligned_store (operands))\n+    DONE;\n+  else\n+    FAIL;\n+})\n+\n+(define_expand \"extv\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+        (sign_extract (match_operand:SI 1 \"memory_operand\" \"\")\n+                      (match_operand:SI 2 \"immediate_operand\" \"\")\n+                      (match_operand:SI 3 \"immediate_operand\" \"\")))]\n+  \"!TARGET_SCORE5U && !TARGET_LITTLE_ENDIAN\"\n+{\n+  if (mdx_unaligned_load (operands))\n+    DONE;\n+  else\n+    FAIL;\n+})\n+\n+(define_expand \"movmemsi\"\n+  [(parallel [(set (match_operand:BLK 0 \"general_operand\")\n+                   (match_operand:BLK 1 \"general_operand\"))\n+              (use (match_operand:SI 2 \"\"))\n+              (use (match_operand:SI 3 \"const_int_operand\"))])]\n+  \"!TARGET_SCORE5U\"\n+{\n+  if (mdx_block_move (operands))\n+    DONE;\n+  else\n+    FAIL;\n+})\n+\n+(define_insn \"move_lbu_a\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+                 (match_operand:SI 2 \"const_simm12\" \"\")))\n+   (set (match_operand:QI 3 \"register_operand\" \"=d\")\n+        (mem:QI (match_dup 1)))]\n+  \"!TARGET_SCORE5U\"\n+  \"lbu     %3, [%1]+, %2\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"mode\" \"QI\")])\n+\n+(define_insn \"move_lhu_a\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+                 (match_operand:SI 2 \"const_simm12\" \"\")))\n+   (set (match_operand:HI 3 \"register_operand\" \"=d\")\n+        (mem:HI (match_dup 1)))]\n+  \"!TARGET_SCORE5U\"\n+  \"lhu     %3, [%1]+, %2\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"mode\" \"HI\")])\n+\n+(define_insn \"move_lw_a\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+                 (match_operand:SI 2 \"const_simm12\" \"\")))\n+   (set (match_operand:SI 3 \"register_operand\" \"=d\")\n+        (mem:SI (match_dup 1)))]\n+  \"!TARGET_SCORE5U\"\n+  \"lw      %3, [%1]+, %2\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"move_sb_a\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+                 (match_operand:SI 2 \"const_simm12\" \"\")))\n+   (set (mem:QI (match_dup 1))\n+        (match_operand:QI 3 \"register_operand\" \"d\"))]\n+  \"!TARGET_SCORE5U\"\n+  \"sb      %3, [%1]+, %2\"\n+  [(set_attr \"type\" \"store\")\n+   (set_attr \"mode\" \"QI\")])\n+\n+(define_insn \"move_sh_a\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+                 (match_operand:SI 2 \"const_simm12\" \"\")))\n+   (set (mem:HI (match_dup 1))\n+        (match_operand:HI 3 \"register_operand\" \"d\"))]\n+  \"!TARGET_SCORE5U\"\n+  \"sh      %3, [%1]+, %2\"\n+  [(set_attr \"type\" \"store\")\n+   (set_attr \"mode\" \"HI\")])\n+\n+(define_insn \"move_sw_a\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+                 (match_operand:SI 2 \"const_simm12\" \"\")))\n+   (set (mem:SI (match_dup 1))\n+        (match_operand:SI 3 \"register_operand\" \"d\"))]\n+  \"!TARGET_SCORE5U\"\n+  \"sw      %3, [%1]+, %2\"\n+  [(set_attr \"type\" \"store\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"move_lbu_b\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+                 (match_operand:SI 2 \"const_simm12\" \"\")))\n+   (set (match_operand:QI 3 \"register_operand\" \"=d\")\n+        (mem:QI (plus:SI (match_dup 1)\n+                         (match_dup 2))))]\n+  \"!TARGET_SCORE5U\"\n+  \"lbu     %3, [%1, %2]+\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"mode\" \"QI\")])\n+\n+(define_insn \"move_lhu_b\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+                 (match_operand:SI 2 \"const_simm12\" \"\")))\n+   (set (match_operand:HI 3 \"register_operand\" \"=d\")\n+        (mem:HI (plus:SI (match_dup 1)\n+                         (match_dup 2))))]\n+  \"!TARGET_SCORE5U\"\n+  \"lhu     %3, [%1, %2]+\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"mode\" \"HI\")])\n+\n+(define_insn \"move_lw_b\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+                 (match_operand:SI 2 \"const_simm12\" \"\")))\n+   (set (match_operand:SI 3 \"register_operand\" \"=d\")\n+        (mem:SI (plus:SI (match_dup 1)\n+                         (match_dup 2))))]\n+  \"!TARGET_SCORE5U\"\n+  \"lw      %3, [%1, %2]+\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"move_sb_b\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+                 (match_operand:SI 2 \"const_simm12\" \"\")))\n+   (set (mem:QI (plus:SI (match_dup 1)\n+                         (match_dup 2)))\n+        (match_operand:QI 3 \"register_operand\" \"d\"))]\n+  \"!TARGET_SCORE5U\"\n+  \"sb      %3, [%1, %2]+\"\n+  [(set_attr \"type\" \"store\")\n+   (set_attr \"mode\" \"QI\")])\n+\n+(define_insn \"move_sh_b\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+                 (match_operand:SI 2 \"const_simm12\" \"\")))\n+   (set (mem:HI (plus:SI (match_dup 1)\n+                         (match_dup 2)))\n+        (match_operand:HI 3 \"register_operand\" \"d\"))]\n+  \"!TARGET_SCORE5U\"\n+  \"sh      %3, [%1, %2]+\"\n+  [(set_attr \"type\" \"store\")\n+   (set_attr \"mode\" \"HI\")])\n+\n+(define_insn \"move_sw_b\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+                 (match_operand:SI 2 \"const_simm12\" \"\")))\n+   (set (mem:SI (plus:SI (match_dup 1)\n+                         (match_dup 2)))\n+        (match_operand:SI 3 \"register_operand\" \"d\"))]\n+  \"!TARGET_SCORE5U\"\n+  \"sw      %3, [%1, %2]+\"\n+  [(set_attr \"type\" \"store\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"move_lcb\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+                 (const_int 4)))\n+   (set (reg:SI LC_REGNUM)\n+        (unspec:SI [(mem:BLK (match_dup 1))] LCB))]\n+  \"!TARGET_SCORE5U && !TARGET_LITTLE_ENDIAN\"\n+  \"lcb     [%1]+\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"move_lcw\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+                 (const_int 4)))\n+   (set (match_operand:SI 2 \"register_operand\" \"=d\")\n+        (unspec:SI [(mem:BLK (match_dup 1))\n+                    (reg:SI LC_REGNUM)] LCW))\n+   (set (reg:SI LC_REGNUM)\n+        (unspec:SI [(mem:BLK (match_dup 1))] LCB))]\n+  \"!TARGET_SCORE5U && !TARGET_LITTLE_ENDIAN\"\n+  \"lcw     %2, [%1]+\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"move_lce\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+                 (const_int 4)))\n+   (set (match_operand:SI 2 \"register_operand\" \"=d\")\n+        (unspec:SI [(mem:BLK (match_dup 1))\n+                    (reg:SI LC_REGNUM)] LCE))]\n+  \"!TARGET_SCORE5U && !TARGET_LITTLE_ENDIAN\"\n+  \"lce     %2, [%1]+\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"move_scb\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+                 (const_int 4)))\n+   (set (mem:BLK (match_dup 1))\n+        (unspec:BLK [(match_operand:SI 2 \"register_operand\" \"d\")] SCB))\n+   (set (reg:SI SC_REGNUM)\n+        (unspec:SI [(match_dup 2)] SCLC))]\n+  \"!TARGET_SCORE5U && !TARGET_LITTLE_ENDIAN\"\n+  \"scb     %2, [%1]+\"\n+  [(set_attr \"type\" \"store\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"move_scw\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+                 (const_int 4)))\n+   (set (mem:BLK (match_dup 1))\n+        (unspec:BLK [(match_operand:SI 2 \"register_operand\" \"d\")\n+                     (reg:SI SC_REGNUM)] SCW))\n+   (set (reg:SI SC_REGNUM)\n+        (unspec:SI [(match_dup 2)] SCLC))]\n+  \"!TARGET_SCORE5U && !TARGET_LITTLE_ENDIAN\"\n+  \"scw     %2, [%1]+\"\n+  [(set_attr \"type\" \"store\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"move_sce\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+                 (const_int 4)))\n+   (set (mem:BLK (match_dup 1))\n+        (unspec:BLK [(reg:SI SC_REGNUM)] SCE))]\n+  \"!TARGET_SCORE5U && !TARGET_LITTLE_ENDIAN\"\n+  \"sce     [%1]+\"\n+  [(set_attr \"type\" \"store\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"andsi3_extzh\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (and:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+                (const_int 65535)))]\n+  \"\"\n+  \"extzh   %0, %1\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"bitclr_c\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=e,d\")\n+        (and:SI (match_operand:SI 1 \"register_operand\" \"0,d\")\n+                (match_operand:SI 2 \"const_npow2\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"\"\n+  \"@\n+   bitclr!    %0, %F2\n+   bitclr.c   %0, %1, %F2\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"bitset_c\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=e,d\")\n+        (ior:SI (match_operand:SI 1 \"register_operand\" \"0,d\")\n+                (match_operand:SI 2 \"const_pow2\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"\"\n+  \"@\n+   bitset!    %0, %E2\n+   bitset.c   %0, %1, %E2\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"bittgl_c\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=e,d\")\n+        (xor:SI (match_operand:SI 1 \"register_operand\" \"0,d\")\n+                (match_operand:SI 2 \"const_pow2\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"\"\n+  \"@\n+   bittgl!    %0, %E2\n+   bittgl.c   %0, %1, %E2\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"SI\")])"}, {"sha": "138f628d70a57c0d7f1713f7ea8803be8aea9904", "filename": "gcc/config/score/mul-div.S", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99fc25020d47424e0c0b0da370e2e18540b96b73/gcc%2Fconfig%2Fscore%2Fmul-div.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99fc25020d47424e0c0b0da370e2e18540b96b73/gcc%2Fconfig%2Fscore%2Fmul-div.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fmul-div.S?ref=99fc25020d47424e0c0b0da370e2e18540b96b73", "patch": "@@ -242,7 +242,7 @@ _flush_cache:\n         #nop!\n         addi    r8, 16\n         bcnz    2b\n-        .cprestore      12              # pic used\n+        .cprestore r0, 12               # pic used\n         addi    r0, 8                   # pic used\n         br      r3\n #endif\n@@ -278,7 +278,7 @@ __mulsi3_loop2:\n         cmpi.c  a1, 0\n         bne     __mulsi3_loop\n         mv      r4, t1\n-        .cprestore 12                   # pic used\n+        .cprestore r0, 12               # pic used\n         addi    r0, 8                   # pic used\n         br      ra\n         .end    __mulsi3\n@@ -334,7 +334,7 @@ __uds_loop3:\n __uds_exit:\n         mv      a1, a0\n         mv      r4, t4\n-        .cprestore 12                   # pic used\n+        .cprestore r0, 12               # pic used\n         addi    r0, 8                   # pic used\n         br      ra\n         .end    __udivsi3\n@@ -350,7 +350,7 @@ __umodsi3:\n         la      r29, __udivsi3\n         brl     r29\n         mv      r4, a1\n-        .cprestore 12                   # pic used\n+        .cprestore r0, 12               # pic used\n         addi    r0, 8                   # pic used\n         br      t3\n         .end    __umodsi3\n@@ -383,7 +383,7 @@ __divsi3_adjust:\n         bge     __divsi3_exit\n         neg     r4, r4\n __divsi3_exit:\n-        .cprestore 12                   # pic used\n+        .cprestore r0, 12               # pic used\n         addi    r0, 8                   # pic used\n         br      t3\n         .end    __divsi3"}, {"sha": "eefb4971200da31208faac0bc6ad55aeca0238de", "filename": "gcc/config/score/predicates.md", "status": "modified", "additions": 32, "deletions": 7, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99fc25020d47424e0c0b0da370e2e18540b96b73/gcc%2Fconfig%2Fscore%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99fc25020d47424e0c0b0da370e2e18540b96b73/gcc%2Fconfig%2Fscore%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fpredicates.md?ref=99fc25020d47424e0c0b0da370e2e18540b96b73", "patch": "@@ -35,13 +35,11 @@\n   (ior (match_operand 0 \"const_call_insn_operand\")\n        (match_operand 0 \"register_operand\")))\n \n-(define_predicate \"const_bi_operand\"\n-  (and (match_code \"const_int\")\n-       (match_test \"CONST_OK_FOR_LETTER_P (INTVAL (op), 'J')\")))\n-\n-(define_predicate \"pindex_off_operand\"\n-  (and (match_code \"const_int\")\n-       (match_test \"CONST_OK_FOR_LETTER_P (INTVAL (op), 'P')\")))\n+(define_predicate \"const_uimm5\"\n+  (match_code \"const_int\")\n+{\n+  return IMM_IN_RANGE (INTVAL (op), 5, 0);\n+})\n \n (define_predicate \"hireg_operand\"\n   (and (match_code \"reg\")\n@@ -51,6 +49,10 @@\n   (and (match_code \"reg\")\n        (match_test \"REGNO (op) == LO_REGNUM\")))\n \n+(define_predicate \"sr0_operand\"\n+  (and (match_code \"reg\")\n+       (match_test \"REGNO (op) == CN_REGNUM\")))\n+\n (define_predicate \"g32reg_operand\"\n   (and (match_code \"reg\")\n        (match_test \"GP_REG_P (REGNO (op))\")))\n@@ -61,3 +63,26 @@\n (define_predicate \"branch_nz_operator\"\n   (match_code \"eq,ne,lt,ge\"))\n \n+(define_predicate \"const_simm12\"\n+  (match_code \"const_int\")\n+{\n+  return IMM_IN_RANGE (INTVAL (op), 12, 1);\n+})\n+\n+(define_predicate \"const_simm15\"\n+  (match_code \"const_int\")\n+{\n+  return IMM_IN_RANGE (INTVAL (op), 15, 1);\n+})\n+\n+(define_predicate \"const_pow2\"\n+  (match_code \"const_int\")\n+{\n+  return IMM_IS_POW_OF_2 ((unsigned HOST_WIDE_INT) INTVAL (op), 0, 31);\n+})\n+\n+(define_predicate \"const_npow2\"\n+  (match_code \"const_int\")\n+{\n+  return IMM_IS_POW_OF_2 (~(unsigned HOST_WIDE_INT) INTVAL (op), 0, 31);\n+})"}, {"sha": "796255e2533633f0f94ae38e2be03f0692fa24bf", "filename": "gcc/config/score/score-conv.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99fc25020d47424e0c0b0da370e2e18540b96b73/gcc%2Fconfig%2Fscore%2Fscore-conv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99fc25020d47424e0c0b0da370e2e18540b96b73/gcc%2Fconfig%2Fscore%2Fscore-conv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore-conv.h?ref=99fc25020d47424e0c0b0da370e2e18540b96b73", "patch": "@@ -45,7 +45,7 @@ extern int target_flags;\n \n #define CE_REG_P(REGNO)        REG_CONTAIN (REGNO, CE_REG_FIRST, CE_REG_NUM)\n \n-#define UIMM_IN_RANGE(V, W)  ((V) >= 0 && (V) < ((HOST_WIDE_INT)1 << (W)))\n+#define UIMM_IN_RANGE(V, W)  ((V) >= 0 && (V) < ((HOST_WIDE_INT) 1 << (W)))\n \n #define SIMM_IN_RANGE(V, W)                            \\\n   ((V) >= (-1 * ((HOST_WIDE_INT) 1 << ((W) - 1)))      \\\n@@ -54,6 +54,11 @@ extern int target_flags;\n #define IMM_IN_RANGE(V, W, S) \\\n   ((S) ? SIMM_IN_RANGE (V, W) : UIMM_IN_RANGE (V, W))\n \n+#define IMM_IS_POW_OF_2(V, E1, E2)                \\\n+  ((V) >= ((unsigned HOST_WIDE_INT) 1 << (E1))     \\\n+   && (V) <= ((unsigned HOST_WIDE_INT) 1 << (E2))  \\\n+   && ((V) & ((V) - 1)) == 0)\n+\n #define SCORE_STACK_ALIGN(LOC)          (((LOC) + 3) & ~3)\n \n #define SCORE_MAX_FIRST_STACK_STEP      (0x3ff0)"}, {"sha": "e8d1478ed19ba24080e3715da5b521654740aed4", "filename": "gcc/config/score/score-mdaux.c", "status": "modified", "additions": 370, "deletions": 49, "changes": 419, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99fc25020d47424e0c0b0da370e2e18540b96b73/gcc%2Fconfig%2Fscore%2Fscore-mdaux.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99fc25020d47424e0c0b0da370e2e18540b96b73/gcc%2Fconfig%2Fscore%2Fscore-mdaux.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore-mdaux.c?ref=99fc25020d47424e0c0b0da370e2e18540b96b73", "patch": "@@ -108,10 +108,9 @@ score_symbol_type score_classify_symbol (rtx x)\n   if (GET_CODE (x) == LABEL_REF)\n     return SYMBOL_GENERAL;\n \n-  if (GET_CODE (x) != SYMBOL_REF)\n-    gcc_unreachable ();\n+  gcc_assert (GET_CODE (x) == SYMBOL_REF);\n \n-  if (CONSTANT_POOL_ADDRESS_P(x))\n+  if (CONSTANT_POOL_ADDRESS_P (x))\n     {\n       if (GET_MODE_SIZE (get_pool_mode (x)) <= SCORE_SDATA_MAX)\n         return SYMBOL_SMALL_DATA;\n@@ -185,14 +184,14 @@ mda_compute_frame_size (HOST_WIDE_INT size)\n   f->mask = 0;\n   f->var_size = SCORE_STACK_ALIGN (size);\n   f->args_size = current_function_outgoing_args_size;\n-  f->cprestore_size = SCORE_STACK_ALIGN (STARTING_FRAME_OFFSET) - f->args_size;\n+  f->cprestore_size = flag_pic ? UNITS_PER_WORD : 0;\n   if (f->var_size == 0 && current_function_is_leaf)\n     f->args_size = f->cprestore_size = 0;\n \n   if (f->args_size == 0 && current_function_calls_alloca)\n     f->args_size = UNITS_PER_WORD;\n \n-  f->total_size = f->var_size + f->args_size;\n+  f->total_size = f->var_size + f->args_size + f->cprestore_size;\n   for (regno = GP_REG_FIRST; regno <= GP_REG_LAST; regno++)\n     {\n       if (score_save_reg_p (regno))\n@@ -205,7 +204,7 @@ mda_compute_frame_size (HOST_WIDE_INT size)\n   if (current_function_calls_eh_return)\n     {\n       unsigned int i;\n-      for (i = 0; ; ++i)\n+      for (i = 0;; ++i)\n         {\n           regno = EH_RETURN_DATA_REGNO (i);\n           if (regno == INVALID_REGNUM)\n@@ -215,7 +214,7 @@ mda_compute_frame_size (HOST_WIDE_INT size)\n         }\n     }\n \n-  f->total_size += SCORE_STACK_ALIGN (f->gp_reg_size);\n+  f->total_size += f->gp_reg_size;\n   f->num_gp = f->gp_reg_size / UNITS_PER_WORD;\n \n   if (f->mask)\n@@ -226,12 +225,7 @@ mda_compute_frame_size (HOST_WIDE_INT size)\n       f->gp_sp_offset = offset;\n     }\n   else\n-    {\n-      f->gp_sp_offset = 0;\n-    }\n-\n-  if ((f->total_size == f->gp_reg_size) && flag_pic)\n-    f->total_size += 8;\n+    f->gp_sp_offset = 0;\n \n   return f;\n }\n@@ -294,8 +288,13 @@ mdx_prologue (void)\n   if (frame_pointer_needed)\n     EMIT_PL (emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx));\n \n-  if (flag_pic)\n-    emit_insn (gen_cprestore (GEN_INT (size + 4)));\n+  if (flag_pic && f->cprestore_size)\n+    {\n+      if (frame_pointer_needed)\n+        emit_insn (gen_cprestore_use_fp (GEN_INT (size - f->cprestore_size)));\n+      else\n+        emit_insn (gen_cprestore_use_sp (GEN_INT (size - f->cprestore_size)));\n+    }\n \n #undef EMIT_PL\n }\n@@ -392,7 +391,7 @@ mda_classify_address (struct score_address_info *info,\n       info->offset = XEXP (x, 1);\n       return (mda_valid_base_register_p (info->reg, strict)\n               && GET_CODE (info->offset) == CONST_INT\n-              && CONST_OK_FOR_LETTER_P (INTVAL (info->offset), 'O'));\n+              && IMM_IN_RANGE (INTVAL (info->offset), 15, 1));\n     case PRE_DEC:\n     case POST_DEC:\n     case PRE_INC:\n@@ -405,7 +404,7 @@ mda_classify_address (struct score_address_info *info,\n       return mda_valid_base_register_p (info->reg, strict);\n     case CONST_INT:\n       info->type = ADD_CONST_INT;\n-      return CONST_OK_FOR_LETTER_P (INTVAL (x), 'O');\n+      return IMM_IN_RANGE (INTVAL (x), 15, 1);\n     case CONST:\n     case LABEL_REF:\n     case SYMBOL_REF:\n@@ -443,7 +442,7 @@ mda_symbolic_constant_p (rtx x, enum score_symbol_type *symbol_type)\n     return 1;\n \n   /* if offset > 15bit, must reload  */\n-  if (!CONST_OK_FOR_LETTER_P (offset, 'O'))\n+  if (!IMM_IN_RANGE (offset, 15, 1))\n     return 0;\n \n   switch (*symbol_type)\n@@ -459,11 +458,9 @@ mda_symbolic_constant_p (rtx x, enum score_symbol_type *symbol_type)\n void\n mdx_movsicc (rtx *ops)\n {\n-  enum machine_mode mode = CCmode;\n-\n-  if (GET_CODE (ops[1]) == EQ || GET_CODE (ops[1]) == NE)\n-    mode = CC_NZmode;\n+  enum machine_mode mode;\n \n+  mode = score_select_cc_mode (GET_CODE (ops[1]), ops[2], ops[3]);\n   emit_insn (gen_rtx_SET (VOIDmode, gen_rtx_REG (mode, CC_REGNUM),\n                           gen_rtx_COMPARE (mode, cmp_op0, cmp_op1)));\n }\n@@ -533,14 +530,15 @@ mds_movdi (rtx *ops)\n void\n mds_zero_extract_andi (rtx *ops)\n {\n-  if (INTVAL (ops[1]) == 1 && const_bi_operand (ops[2], SImode))\n+  if (INTVAL (ops[1]) == 1 && const_uimm5 (ops[2], SImode))\n     emit_insn (gen_zero_extract_bittst (ops[0], ops[2]));\n   else\n     {\n       unsigned HOST_WIDE_INT mask;\n       mask = (0xffffffffU & ((1U << INTVAL (ops[1])) - 1U));\n       mask = mask << INTVAL (ops[2]);\n-      emit_insn (gen_andsi3_cmp (ops[0], gen_int_mode (mask, SImode)));\n+      emit_insn (gen_andsi3_cmp (ops[3], ops[0],\n+                                 gen_int_mode (mask, SImode)));\n     }\n }\n \n@@ -637,17 +635,20 @@ mdp_sinsn (rtx *ops, enum mda_mem_unit unit)\n const char *\n mdp_limm (rtx *ops)\n {\n+  HOST_WIDE_INT v;\n+\n   gcc_assert (GET_CODE (ops[0]) == REG);\n+  gcc_assert (GET_CODE (ops[1]) == CONST_INT);\n \n-  if (G16_REG_P (REGNO (ops[0]))\n-      && CONST_OK_FOR_LETTER_P (INTVAL (ops[1]), 'I'))\n+  v = INTVAL (ops[1]);\n+  if (G16_REG_P (REGNO (ops[0])) && IMM_IN_RANGE (v, 8, 0))\n     return \"ldiu!   %0, %c1\";\n-  else if (CONST_OK_FOR_LETTER_P (INTVAL (ops[1]), 'L'))\n+  else if (IMM_IN_RANGE (v, 16, 1))\n     return \"ldi     %0, %c1\";\n-  else if (EXTRA_CONSTRAINT (ops[1], 'Q'))\n+  else if ((v & 0xffff) == 0)\n     return \"ldis    %0, %U1\";\n   else\n-    return \"li      %0, %D1\";\n+    return \"li      %0, %c1\";\n }\n \n /* Output asm insn for move.  */\n@@ -670,69 +671,389 @@ mdp_move (rtx *ops)\n     return \"mv      %0, %1\";\n }\n \n-/* Score support add/sub with exponent immediate insn,\n-   use to judge imm condition.  */\n-static unsigned int\n-num_bits1 (unsigned HOST_WIDE_INT v)\n+/* Emit lcb/lce insns.  */\n+bool\n+mdx_unaligned_load (rtx *ops)\n+{\n+  rtx dst = ops[0];\n+  rtx src = ops[1];\n+  rtx len = ops[2];\n+  rtx off = ops[3];\n+  rtx addr_reg;\n+\n+  if (INTVAL (len) != BITS_PER_WORD\n+      || (INTVAL (off) % BITS_PER_UNIT) != 0)\n+    return false;\n+\n+  gcc_assert (GET_MODE_SIZE (GET_MODE (dst)) == GET_MODE_SIZE (SImode));\n+\n+  addr_reg = copy_addr_to_reg (XEXP (src, 0));\n+  emit_insn (gen_move_lcb (addr_reg, addr_reg));\n+  emit_insn (gen_move_lce (addr_reg, addr_reg, dst));\n+\n+  return true;\n+}\n+\n+/* Emit scb/sce insns.  */\n+bool\n+mdx_unaligned_store (rtx *ops)\n {\n-  int i, n = 0;\n+  rtx dst = ops[0];\n+  rtx len = ops[1];\n+  rtx off = ops[2];\n+  rtx src = ops[3];\n+  rtx addr_reg;\n+\n+  if (INTVAL(len) != BITS_PER_WORD\n+      || (INTVAL(off) % BITS_PER_UNIT) != 0)\n+    return false;\n \n-  for (i = 0; i < BITS_PER_WORD; i++)\n-    n += BITSET_P (v, i) ? 1 : 0;\n-  return n;\n+  gcc_assert (GET_MODE_SIZE (GET_MODE (src)) == GET_MODE_SIZE (SImode));\n+\n+  addr_reg = copy_addr_to_reg (XEXP (dst, 0));\n+  emit_insn (gen_move_scb (addr_reg, addr_reg, src));\n+  emit_insn (gen_move_sce (addr_reg, addr_reg));\n+\n+  return true;\n }\n \n-/* Generate add insn, insn will affect condition flag. Optimize used.  */\n+/* If length is short, generate move insns straight.  */\n+static void\n+mdx_block_move_straight (rtx dst, rtx src, HOST_WIDE_INT length)\n+{\n+  HOST_WIDE_INT leftover;\n+  int i, reg_count;\n+  rtx *regs;\n+\n+  leftover = length % UNITS_PER_WORD;\n+  length -= leftover;\n+  reg_count = length / UNITS_PER_WORD;\n+\n+  regs = alloca (sizeof (rtx) * reg_count);\n+  for (i = 0; i < reg_count; i++)\n+    regs[i] = gen_reg_rtx (SImode);\n+\n+  /* Load from src to regs.  */\n+  if (MEM_ALIGN (src) >= BITS_PER_WORD)\n+    {\n+      HOST_WIDE_INT offset = 0;\n+      for (i = 0; i < reg_count; offset += UNITS_PER_WORD, i++)\n+        emit_move_insn (regs[i], adjust_address (src, SImode, offset));\n+    }\n+  else if (reg_count >= 1)\n+    {\n+      rtx src_reg = copy_addr_to_reg (XEXP (src, 0));\n+\n+      emit_insn (gen_move_lcb (src_reg, src_reg));\n+      for (i = 0; i < (reg_count - 1); i++)\n+        emit_insn (gen_move_lcw (src_reg, src_reg, regs[i]));\n+      emit_insn (gen_move_lce (src_reg, src_reg, regs[i]));\n+    }\n+\n+  /* Store regs to dest.  */\n+  if (MEM_ALIGN (dst) >= BITS_PER_WORD)\n+    {\n+      HOST_WIDE_INT offset = 0;\n+      for (i = 0; i < reg_count; offset += UNITS_PER_WORD, i++)\n+        emit_move_insn (adjust_address (dst, SImode, offset), regs[i]);\n+    }\n+  else if (reg_count >= 1)\n+    {\n+      rtx dst_reg = copy_addr_to_reg (XEXP (dst, 0));\n+\n+      emit_insn (gen_move_scb (dst_reg, dst_reg, regs[0]));\n+      for (i = 1; i < reg_count; i++)\n+        emit_insn (gen_move_scw (dst_reg, dst_reg, regs[i]));\n+      emit_insn (gen_move_sce (dst_reg, dst_reg));\n+    }\n+\n+  /* Mop up any left-over bytes.  */\n+  if (leftover > 0)\n+    {\n+      src = adjust_address (src, BLKmode, length);\n+      dst = adjust_address (dst, BLKmode, length);\n+      move_by_pieces (dst, src, leftover,\n+                      MIN (MEM_ALIGN (src), MEM_ALIGN (dst)), 0);\n+    }\n+}\n+\n+/* Generate loop head when dst or src is unaligned.  */\n+static void\n+mdx_block_move_loop_head (rtx dst_reg, HOST_WIDE_INT dst_align,\n+                          rtx src_reg, HOST_WIDE_INT src_align,\n+                          HOST_WIDE_INT length)\n+{\n+  bool src_unaligned = (src_align < BITS_PER_WORD);\n+  bool dst_unaligned = (dst_align < BITS_PER_WORD);\n+\n+  rtx temp = gen_reg_rtx (SImode);\n+\n+  gcc_assert (length == UNITS_PER_WORD);\n+\n+  if (src_unaligned)\n+    {\n+      emit_insn (gen_move_lcb (src_reg, src_reg));\n+      emit_insn (gen_move_lcw (src_reg, src_reg, temp));\n+    }\n+  else\n+    emit_insn (gen_move_lw_a (src_reg,\n+                              src_reg, gen_int_mode (4, SImode), temp));\n+\n+  if (dst_unaligned)\n+    emit_insn (gen_move_scb (dst_reg, dst_reg, temp));\n+  else\n+    emit_insn (gen_move_sw_a (dst_reg,\n+                              dst_reg, gen_int_mode (4, SImode), temp));\n+}\n+\n+/* Generate loop body, copy length bytes per iteration.  */\n+static void\n+mdx_block_move_loop_body (rtx dst_reg, HOST_WIDE_INT dst_align,\n+                          rtx src_reg, HOST_WIDE_INT src_align,\n+                          HOST_WIDE_INT length)\n+{\n+  int reg_count = length / UNITS_PER_WORD;\n+  rtx *regs = alloca (sizeof (rtx) * reg_count);\n+  int i;\n+  bool src_unaligned = (src_align < BITS_PER_WORD);\n+  bool dst_unaligned = (dst_align < BITS_PER_WORD);\n+\n+  for (i = 0; i < reg_count; i++)\n+    regs[i] = gen_reg_rtx (SImode);\n+\n+  if (src_unaligned)\n+    {\n+      for (i = 0; i < reg_count; i++)\n+        emit_insn (gen_move_lcw (src_reg, src_reg, regs[i]));\n+    }\n+  else\n+    {\n+      for (i = 0; i < reg_count; i++)\n+        emit_insn (gen_move_lw_a (src_reg,\n+                                  src_reg, gen_int_mode (4, SImode), regs[i]));\n+    }\n+\n+  if (dst_unaligned)\n+    {\n+      for (i = 0; i < reg_count; i++)\n+        emit_insn (gen_move_scw (dst_reg, dst_reg, regs[i]));\n+    }\n+  else\n+    {\n+      for (i = 0; i < reg_count; i++)\n+        emit_insn (gen_move_sw_a (dst_reg,\n+                                  dst_reg, gen_int_mode (4, SImode), regs[i]));\n+    }\n+}\n+\n+/* Generate loop foot, copy the leftover bytes.  */\n+static void\n+mdx_block_move_loop_foot (rtx dst_reg, HOST_WIDE_INT dst_align,\n+                          rtx src_reg, HOST_WIDE_INT src_align,\n+                          HOST_WIDE_INT length)\n+{\n+  bool src_unaligned = (src_align < BITS_PER_WORD);\n+  bool dst_unaligned = (dst_align < BITS_PER_WORD);\n+\n+  HOST_WIDE_INT leftover;\n+\n+  leftover = length % UNITS_PER_WORD;\n+  length -= leftover;\n+\n+  if (length > 0)\n+    mdx_block_move_loop_body (dst_reg, dst_align,\n+                              src_reg, src_align, length);\n+\n+  if (dst_unaligned)\n+    emit_insn (gen_move_sce (dst_reg, dst_reg));\n+\n+  if (leftover > 0)\n+    {\n+      HOST_WIDE_INT src_adj = src_unaligned ? -4 : 0;\n+      HOST_WIDE_INT dst_adj = dst_unaligned ? -4 : 0;\n+      rtx temp;\n+\n+      gcc_assert (leftover < UNITS_PER_WORD);\n+\n+      if (leftover >= UNITS_PER_WORD / 2\n+          && src_align >= BITS_PER_WORD / 2\n+          && dst_align >= BITS_PER_WORD / 2)\n+        {\n+          temp = gen_reg_rtx (HImode);\n+          emit_insn (gen_move_lhu_b (src_reg, src_reg,\n+                                     gen_int_mode (src_adj, SImode), temp));\n+          emit_insn (gen_move_sh_b (dst_reg, dst_reg,\n+                                    gen_int_mode (dst_adj, SImode), temp));\n+          leftover -= UNITS_PER_WORD / 2;\n+          src_adj = UNITS_PER_WORD / 2;\n+          dst_adj = UNITS_PER_WORD / 2;\n+        }\n+\n+      while (leftover > 0)\n+        {\n+          temp = gen_reg_rtx (QImode);\n+          emit_insn (gen_move_lbu_b (src_reg, src_reg,\n+                                     gen_int_mode (src_adj, SImode), temp));\n+          emit_insn (gen_move_sb_b (dst_reg, dst_reg,\n+                                    gen_int_mode (dst_adj, SImode), temp));\n+          leftover--;\n+          src_adj = 1;\n+          dst_adj = 1;\n+        }\n+    }\n+}\n+\n+#define MIN_MOVE_REGS 3\n+#define MIN_MOVE_BYTES (MIN_MOVE_REGS * UNITS_PER_WORD)\n+#define MAX_MOVE_REGS 4\n+#define MAX_MOVE_BYTES (MAX_MOVE_REGS * UNITS_PER_WORD)\n+\n+/* The length is large, generate a loop if necessary.\n+   The loop is consisted by loop head/body/foot.  */\n+static void\n+mdx_block_move_loop (rtx dst, rtx src, HOST_WIDE_INT length)\n+{\n+  HOST_WIDE_INT src_align = MEM_ALIGN (src);\n+  HOST_WIDE_INT dst_align = MEM_ALIGN (dst);\n+  HOST_WIDE_INT loop_mov_bytes;\n+  HOST_WIDE_INT iteration = 0;\n+  HOST_WIDE_INT head_length = 0, leftover;\n+  rtx label, src_reg, dst_reg, final_dst;\n+\n+  bool gen_loop_head = (src_align < BITS_PER_WORD\n+                        || dst_align < BITS_PER_WORD);\n+\n+  if (gen_loop_head)\n+    head_length += UNITS_PER_WORD;\n+\n+  for (loop_mov_bytes = MAX_MOVE_BYTES;\n+       loop_mov_bytes >= MIN_MOVE_BYTES;\n+       loop_mov_bytes -= UNITS_PER_WORD)\n+    {\n+      iteration = (length - head_length) / loop_mov_bytes;\n+      if (iteration > 1)\n+        break;\n+    }\n+  if (iteration <= 1)\n+    {\n+      mdx_block_move_straight (dst, src, length);\n+      return;\n+    }\n+\n+  leftover = (length - head_length) % loop_mov_bytes;\n+  length -= leftover;\n+\n+  src_reg = copy_addr_to_reg (XEXP (src, 0));\n+  dst_reg = copy_addr_to_reg (XEXP (dst, 0));\n+  final_dst = expand_simple_binop (Pmode, PLUS, dst_reg, GEN_INT (length),\n+                                   0, 0, OPTAB_WIDEN);\n+\n+  if (gen_loop_head)\n+    mdx_block_move_loop_head (dst_reg, dst_align,\n+                              src_reg, src_align, head_length);\n+\n+  label = gen_label_rtx ();\n+  emit_label (label);\n+\n+  mdx_block_move_loop_body (dst_reg, dst_align,\n+                            src_reg, src_align, loop_mov_bytes);\n+\n+  emit_insn (gen_cmpsi (dst_reg, final_dst));\n+  emit_jump_insn (gen_bne (label));\n+\n+  mdx_block_move_loop_foot (dst_reg, dst_align,\n+                            src_reg, src_align, leftover);\n+}\n+\n+/* Generate block move, for misc.md: \"movmemsi\".  */\n+bool\n+mdx_block_move (rtx *ops)\n+{\n+  rtx dst = ops[0];\n+  rtx src = ops[1];\n+  rtx length = ops[2];\n+\n+  if (TARGET_LITTLE_ENDIAN\n+      && (MEM_ALIGN (src) < BITS_PER_WORD || MEM_ALIGN (dst) < BITS_PER_WORD)\n+      && INTVAL (length) >= UNITS_PER_WORD)\n+    return false;\n+\n+  if (GET_CODE (length) == CONST_INT)\n+    {\n+      if (INTVAL (length) <= 2 * MAX_MOVE_BYTES)\n+        {\n+           mdx_block_move_straight (dst, src, INTVAL (length));\n+           return true;\n+        }\n+      else if (optimize &&\n+               !(flag_unroll_loops || flag_unroll_all_loops))\n+        {\n+          mdx_block_move_loop (dst, src, INTVAL (length));\n+          return true;\n+        }\n+    }\n+  return false;\n+}\n+\n+/* Generate add insn.  */\n const char *\n-mdp_add_imm_ucc (rtx *ops)\n+mdp_select_add_imm (rtx *ops, bool set_cc)\n {\n   HOST_WIDE_INT v = INTVAL (ops[2]);\n \n   gcc_assert (GET_CODE (ops[2]) == CONST_INT);\n   gcc_assert (REGNO (ops[0]) == REGNO (ops[1]));\n \n-  if (G16_REG_P (REGNO (ops[0])))\n+  if (set_cc && G16_REG_P (REGNO (ops[0])))\n     {\n-      if (v > 0 && num_bits1 (v) == 1 && IMM_IN_RANGE (ffs (v) - 1, 4, 0))\n+      if (v > 0 && IMM_IS_POW_OF_2 ((unsigned HOST_WIDE_INT) v, 0, 15))\n         {\n           ops[2] = GEN_INT (ffs (v) - 1);\n           return \"addei!  %0, %c2\";\n         }\n \n-      if (v < 0 && num_bits1 (-v) == 1 && IMM_IN_RANGE (ffs (-v) - 1, 4, 0))\n+      if (v < 0 && IMM_IS_POW_OF_2 ((unsigned HOST_WIDE_INT) (-v), 0, 15))\n         {\n           ops[2] = GEN_INT (ffs (-v) - 1);\n           return \"subei!  %0, %c2\";\n         }\n     }\n+\n+  if (set_cc)\n     return \"addi.c  %0, %c2\";\n+  else\n+    return \"addi    %0, %c2\";\n }\n \n-/* Output arith insn, insn will update condition flag.  */\n+/* Output arith insn.  */\n const char *\n-mdp_select (rtx *ops, const char *inst_pre, bool commu, const char *let)\n+mdp_select (rtx *ops, const char *inst_pre,\n+            bool commu, const char *letter, bool set_cc)\n {\n   gcc_assert (GET_CODE (ops[0]) == REG);\n   gcc_assert (GET_CODE (ops[1]) == REG);\n \n-  if (G16_REG_P (REGNO (ops[0]))\n+  if (set_cc && G16_REG_P (REGNO (ops[0]))\n       && (GET_CODE (ops[2]) == REG ? G16_REG_P (REGNO (ops[2])) : 1)\n       && REGNO (ops[0]) == REGNO (ops[1]))\n     {\n-      snprintf (ins, INS_BUF_SZ, \"%s!        %%0, %%%s2\", inst_pre, let);\n+      snprintf (ins, INS_BUF_SZ, \"%s!  %%0, %%%s2\", inst_pre, letter);\n       return ins;\n     }\n \n-  if (commu && G16_REG_P (REGNO (ops[0]))\n+  if (commu && set_cc && G16_REG_P (REGNO (ops[0]))\n       && G16_REG_P (REGNO (ops[1]))\n       && REGNO (ops[0]) == REGNO (ops[2]))\n     {\n       gcc_assert (GET_CODE (ops[2]) == REG);\n-      snprintf (ins, INS_BUF_SZ, \"%s!        %%0, %%%s1\", inst_pre, let);\n+      snprintf (ins, INS_BUF_SZ, \"%s!  %%0, %%%s1\", inst_pre, letter);\n       return ins;\n     }\n \n-  snprintf (ins, INS_BUF_SZ, \"%s.c        %%0, %%1, %%%s2\", inst_pre, let);\n+  if (set_cc)\n+    snprintf (ins, INS_BUF_SZ, \"%s.c  %%0, %%1, %%%s2\", inst_pre, letter);\n+  else\n+    snprintf (ins, INS_BUF_SZ, \"%s    %%0, %%1, %%%s2\", inst_pre, letter);\n   return ins;\n }\n "}, {"sha": "ad6d1be014c10ce192f0e71af04e40e94c9243ed", "filename": "gcc/config/score/score-mdaux.h", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99fc25020d47424e0c0b0da370e2e18540b96b73/gcc%2Fconfig%2Fscore%2Fscore-mdaux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99fc25020d47424e0c0b0da370e2e18540b96b73/gcc%2Fconfig%2Fscore%2Fscore-mdaux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore-mdaux.h?ref=99fc25020d47424e0c0b0da370e2e18540b96b73", "patch": "@@ -69,8 +69,6 @@ void mda_gen_cmp (enum machine_mode mode);\n \n int mda_symbolic_constant_p (rtx x, enum score_symbol_type *symbol_type);\n \n-bool mda_pindex_mem (rtx addr);\n-\n int mda_bp (void);\n \n /* Machine Expand.  */\n@@ -87,8 +85,6 @@ void mdx_call_value (rtx *ops, bool sibcall);\n /* Machine Split.  */\n void mds_movdi (rtx *ops);\n \n-void mds_addsi (rtx *ops);\n-\n void mds_zero_extract_andi (rtx *ops);\n \n /* Machine Print.  */\n@@ -100,14 +96,21 @@ const char * mdp_linsn (rtx *ops, enum mda_mem_unit unit, bool sign);\n \n const char * mdp_sinsn (rtx *ops, enum mda_mem_unit unit);\n \n-const char * mdp_add_imm_ucc (rtx *ops);\n+const char * mdp_select_add_imm (rtx *ops, bool set_cc);\n \n const char * mdp_select (rtx *ops, const char *inst_pre,\n-                        bool comu, const char *let);\n+                        bool commu, const char *letter, bool set_cc);\n \n const char * mdp_limm (rtx *ops);\n \n const char * mdp_move (rtx *ops);\n \n+/* Machine unaligned memory load/store. */\n+bool mdx_unaligned_load (rtx* ops);\n+\n+bool mdx_unaligned_store (rtx* ops);\n+\n+bool mdx_block_move (rtx* ops);\n+\n #endif\n "}, {"sha": "6cc50cf5eaf8ab01708da55548a8b3b556d903eb", "filename": "gcc/config/score/score-modes.def", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99fc25020d47424e0c0b0da370e2e18540b96b73/gcc%2Fconfig%2Fscore%2Fscore-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99fc25020d47424e0c0b0da370e2e18540b96b73/gcc%2Fconfig%2Fscore%2Fscore-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore-modes.def?ref=99fc25020d47424e0c0b0da370e2e18540b96b73", "patch": "@@ -21,6 +21,5 @@\n /* CC_NZmode should be used if the N (sign) and Z (zero) flag is set correctly.\n    CC_Nmode should be used if only the N flag is set correctly.  */\n \n-CC_MODE (CC_NZ);\n CC_MODE (CC_N);\n-\n+CC_MODE (CC_NZ);"}, {"sha": "c261749d072d23b8e15b18e3db3068126ac2be8d", "filename": "gcc/config/score/score-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99fc25020d47424e0c0b0da370e2e18540b96b73/gcc%2Fconfig%2Fscore%2Fscore-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99fc25020d47424e0c0b0da370e2e18540b96b73/gcc%2Fconfig%2Fscore%2Fscore-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore-protos.h?ref=99fc25020d47424e0c0b0da370e2e18540b96b73", "patch": "@@ -36,7 +36,7 @@ enum reg_class score_preferred_reload_class (rtx x, enum reg_class class);\n enum reg_class score_secondary_reload_class (enum reg_class class,\n                                              enum machine_mode mode, rtx x);\n \n-int score_const_ok_for_letter_p (int value, char c);\n+int score_const_ok_for_letter_p (HOST_WIDE_INT value, char c);\n \n int score_extra_constraint (rtx op, char c);\n "}, {"sha": "b5e85f484945b246d63a6052a8004fb1c2782bfc", "filename": "gcc/config/score/score-version.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99fc25020d47424e0c0b0da370e2e18540b96b73/gcc%2Fconfig%2Fscore%2Fscore-version.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99fc25020d47424e0c0b0da370e2e18540b96b73/gcc%2Fconfig%2Fscore%2Fscore-version.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore-version.h?ref=99fc25020d47424e0c0b0da370e2e18540b96b73", "patch": "@@ -18,4 +18,4 @@\n    the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n    Boston, MA 02110-1301, USA.  */\n \n-#define SCORE_GCC_VERSION \"1.1\"\n+#define SCORE_GCC_VERSION \"1.2\""}, {"sha": "34352a67e4d4dcd7b649f77d0cdef3c306b74c89", "filename": "gcc/config/score/score.c", "status": "modified", "additions": 188, "deletions": 60, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99fc25020d47424e0c0b0da370e2e18540b96b73/gcc%2Fconfig%2Fscore%2Fscore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99fc25020d47424e0c0b0da370e2e18540b96b73/gcc%2Fconfig%2Fscore%2Fscore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore.c?ref=99fc25020d47424e0c0b0da370e2e18540b96b73", "patch": "@@ -67,7 +67,9 @@ static int score_symbol_insns (enum score_symbol_type);\n \n static int score_address_insns (rtx, enum machine_mode);\n \n-static bool score_rtx_costs (rtx, int, int, int *);\n+static bool score_rtx_costs (rtx, enum rtx_code, enum rtx_code, int *);\n+\n+static int score_address_cost (rtx);\n \n #undef  TARGET_ASM_FILE_START\n #define TARGET_ASM_FILE_START           th_asm_file_start\n@@ -126,6 +128,9 @@ static bool score_rtx_costs (rtx, int, int, int *);\n #undef TARGET_RTX_COSTS\n #define TARGET_RTX_COSTS                score_rtx_costs\n \n+#undef TARGET_ADDRESS_COST\n+#define TARGET_ADDRESS_COST             score_address_cost\n+\n #undef TARGET_DEFAULT_TARGET_FLAGS\n #define TARGET_DEFAULT_TARGET_FLAGS     TARGET_DEFAULT\n \n@@ -154,7 +159,7 @@ score_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n static rtx\n score_add_offset (rtx temp, rtx reg, HOST_WIDE_INT offset)\n {\n-  if (!CONST_OK_FOR_LETTER_P (offset, 'O'))\n+  if (!IMM_IN_RANGE (offset, 15, 1))\n     {\n       reg = expand_simple_binop (GET_MODE (reg), PLUS,\n                                  gen_int_mode (offset & 0xffffc000,\n@@ -499,12 +504,13 @@ enum reg_class score_char_to_class[256];\n void\n score_override_options (void)\n {\n+  flag_pic = false;\n   if (!flag_pic)\n     sdata_max = g_switch_set ? g_switch_value : DEFAULT_SDATA_MAX;\n   else\n     {\n       sdata_max = 0;\n-      if (g_switch_set)\n+      if (g_switch_set && (g_switch_value != 0))\n         warning (0, \"-fPIC and -G are incompatible\");\n     }\n \n@@ -540,7 +546,7 @@ score_reg_class (int regno)\n       || regno == ARG_POINTER_REGNUM)\n     return ALL_REGS;\n \n-  for (c = 0 ; c < N_REG_CLASSES ; c++)\n+  for (c = 0; c < N_REG_CLASSES; c++)\n     if (TEST_HARD_REG_BIT (reg_class_contents[c], regno))\n       return c;\n \n@@ -551,10 +557,10 @@ score_reg_class (int regno)\n enum reg_class\n score_preferred_reload_class (rtx x ATTRIBUTE_UNUSED, enum reg_class class)\n {\n-  if (reg_class_subset_p (G32_REGS, class))\n-    class = G32_REGS;\n   if (reg_class_subset_p (G16_REGS, class))\n-    class = G16_REGS;\n+    return G16_REGS;\n+  if (reg_class_subset_p (G32_REGS, class))\n+    return G32_REGS;\n   return class;\n }\n \n@@ -576,41 +582,34 @@ score_secondary_reload_class (enum reg_class class,\n \n /* Implement CONST_OK_FOR_LETTER_P macro.  */\n /* imm constraints\n-   I        IMM8        (i15-2-form)\n-   J        IMM5        (i15_1-form)\n-   K        IMM16       (i-form)\n-   L        IMM16s      (i-form)\n-   M        IMM14       (ri-form)\n-   N        IMM14s      (ri-form)\n-   O        IMM15s      (ri-form)\n-   P        IMM12s      (rix-form) / IMM10s(cop-form) << 2  */\n+   I        imm16 << 16\n+   J        uimm5\n+   K        uimm16\n+   L        simm16\n+   M        uimm14\n+   N        simm14  */\n int\n-score_const_ok_for_letter_p (int value, char c)\n+score_const_ok_for_letter_p (HOST_WIDE_INT value, char c)\n {\n   switch (c)\n     {\n-    case 'I': return IMM_IN_RANGE (value, 8, 0);\n+    case 'I': return ((value & 0xffff) == 0);\n     case 'J': return IMM_IN_RANGE (value, 5, 0);\n     case 'K': return IMM_IN_RANGE (value, 16, 0);\n     case 'L': return IMM_IN_RANGE (value, 16, 1);\n     case 'M': return IMM_IN_RANGE (value, 14, 0);\n     case 'N': return IMM_IN_RANGE (value, 14, 1);\n-    case 'O': return IMM_IN_RANGE (value, 15, 1);\n-    case 'P': return IMM_IN_RANGE (value, 12, 1);\n     default : return 0;\n     }\n }\n \n /* Implement EXTRA_CONSTRAINT macro.  */\n-/* Q        const_hi    imm\n-   Z        symbol_ref  */\n+/* Z        symbol_ref  */\n int\n score_extra_constraint (rtx op, char c)\n {\n   switch (c)\n     {\n-    case 'Q':\n-      return (GET_CODE (op) == CONST_INT && (INTVAL (op) & 0xffff) == 0);\n     case 'Z':\n       return GET_CODE (op) == SYMBOL_REF;\n     default:\n@@ -917,10 +916,8 @@ score_address_insns (rtx x, enum machine_mode mode)\n   int factor;\n \n   if (mode == BLKmode)\n-    /* BLKmode is used for single unaligned loads and stores.  */\n     factor = 1;\n   else\n-    /* Each word of a multi-word value will be accessed individually.  */\n     factor = (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n \n   if (mda_classify_address (&addr, mode, x, false))\n@@ -938,24 +935,53 @@ score_address_insns (rtx x, enum machine_mode mode)\n \n /* Implement TARGET_RTX_COSTS macro.  */\n static bool\n-score_rtx_costs (rtx x, int code, int outer_code, int *total)\n+score_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n+                 int *total)\n {\n   enum machine_mode mode = GET_MODE (x);\n \n   switch (code)\n     {\n     case CONST_INT:\n-      /* These can be used anywhere. */\n-      *total = 0;\n+      if (outer_code == SET)\n+        {\n+          if (CONST_OK_FOR_LETTER_P (INTVAL (x), 'I')\n+              || CONST_OK_FOR_LETTER_P (INTVAL (x), 'L'))\n+            *total = COSTS_N_INSNS (1);\n+          else\n+            *total = COSTS_N_INSNS (2);\n+        }\n+      else if (outer_code == PLUS || outer_code == MINUS)\n+        {\n+          if (CONST_OK_FOR_LETTER_P (INTVAL (x), 'N'))\n+            *total = 0;\n+          else if (CONST_OK_FOR_LETTER_P (INTVAL (x), 'I')\n+                   || CONST_OK_FOR_LETTER_P (INTVAL (x), 'L'))\n+            *total = 1;\n+          else\n+            *total = COSTS_N_INSNS (2);\n+        }\n+      else if (outer_code == AND || outer_code == IOR)\n+        {\n+          if (CONST_OK_FOR_LETTER_P (INTVAL (x), 'M'))\n+            *total = 0;\n+          else if (CONST_OK_FOR_LETTER_P (INTVAL (x), 'I')\n+                   || CONST_OK_FOR_LETTER_P (INTVAL (x), 'K'))\n+            *total = 1;\n+          else\n+            *total = COSTS_N_INSNS (2);\n+        }\n+      else\n+        {\n+          *total = 0;\n+        }\n       return true;\n \n-      /* Otherwise fall through to the handling below because\n-         we'll need to construct the constant.  */\n     case CONST:\n     case SYMBOL_REF:\n     case LABEL_REF:\n     case CONST_DOUBLE:\n-      *total = COSTS_N_INSNS (1);\n+      *total = COSTS_N_INSNS (2);\n       return true;\n \n     case MEM:\n@@ -1011,7 +1037,8 @@ score_rtx_costs (rtx x, int code, int outer_code, int *total)\n           *total = COSTS_N_INSNS (4);\n           return true;\n         }\n-      return false;\n+      *total = COSTS_N_INSNS (1);\n+      return true;\n \n     case NEG:\n       if (mode == DImode)\n@@ -1022,29 +1049,52 @@ score_rtx_costs (rtx x, int code, int outer_code, int *total)\n       return false;\n \n     case MULT:\n-      *total = COSTS_N_INSNS (12);\n+      *total = optimize_size ? COSTS_N_INSNS (2) : COSTS_N_INSNS (12);\n       return true;\n \n     case DIV:\n     case MOD:\n     case UDIV:\n     case UMOD:\n-      *total = COSTS_N_INSNS (33);\n+      *total = optimize_size ? COSTS_N_INSNS (2) : COSTS_N_INSNS (33);\n       return true;\n \n     case SIGN_EXTEND:\n-      *total = COSTS_N_INSNS (2);\n-      return true;\n-\n     case ZERO_EXTEND:\n-      *total = COSTS_N_INSNS (1);\n+      switch (GET_MODE (XEXP (x, 0)))\n+        {\n+        case QImode:\n+        case HImode:\n+          if (GET_CODE (XEXP (x, 0)) == MEM)\n+            {\n+              *total = COSTS_N_INSNS (2);\n+\n+              if (!TARGET_LITTLE_ENDIAN &&\n+                  side_effects_p (XEXP (XEXP (x, 0), 0)))\n+                *total = 100;\n+            }\n+          else\n+            *total = COSTS_N_INSNS (1);\n+          break;\n+\n+        default:\n+          *total = COSTS_N_INSNS (1);\n+          break;\n+        }\n       return true;\n \n     default:\n       return false;\n     }\n }\n \n+/* Implement TARGET_ADDRESS_COST macro.  */\n+int\n+score_address_cost (rtx addr)\n+{\n+  return score_address_insns (addr, SImode);\n+}\n+\n /* Implement ASM_OUTPUT_EXTERNAL macro.  */\n int\n score_output_external (FILE *file ATTRIBUTE_UNUSED,\n@@ -1089,18 +1139,16 @@ score_return_addr (int count, rtx frame ATTRIBUTE_UNUSED)\n /* Implement PRINT_OPERAND macro.  */\n /* Score-specific operand codes:\n    '['        print .set nor1 directive\n-   ']'        print .set r1        directive\n-\n+   ']'        print .set r1 directive\n    'U'        print hi part of a CONST_INT rtx\n-   'D'        print first part of const double\n-   'S'        selectively print '!' if operand is 15bit instruction accessible\n-   'V'        print \"v!\" if operand is 15bit instruction accessible, or\n-   \"lfh!\"\n-\n+   'E'        print log2(v)\n+   'F'        print log2(~v)\n+   'D'        print SFmode const double\n+   'S'        selectively print \"!\" if operand is 15bit instruction accessible\n+   'V'        print \"v!\" if operand is 15bit instruction accessible, or \"lfh!\"\n    'L'        low  part of DImode reg operand\n    'H'        high part of DImode reg operand\n-\n-   'C'  print part of opcode for a branch condition.  */\n+   'C'        print part of opcode for a branch condition.  */\n void\n score_print_operand (FILE *file, rtx op, int c)\n {\n@@ -1125,9 +1173,11 @@ score_print_operand (FILE *file, rtx op, int c)\n   else if (c == 'D')\n     {\n       if (GET_CODE (op) == CONST_DOUBLE)\n-        fprintf (file, HOST_WIDE_INT_PRINT_HEX,\n-                 TARGET_LITTLE_ENDIAN\n-                 ? CONST_DOUBLE_LOW (op) : CONST_DOUBLE_HIGH (op));\n+        {\n+          rtx temp = gen_lowpart (SImode, op);\n+          gcc_assert (GET_MODE (op) == SFmode);\n+          fprintf (file, HOST_WIDE_INT_PRINT_HEX, INTVAL (temp));\n+        }\n       else\n         output_addr_const (file, op);\n     }\n@@ -1142,23 +1192,17 @@ score_print_operand (FILE *file, rtx op, int c)\n       gcc_assert (code == REG);\n       fprintf (file, G16_REG_P (REGNO (op)) ? \"v!\" : \"lfh!\");\n     }\n-  else if (code == REG)\n-    {\n-      int regnum = REGNO (op);\n-      if ((c == 'H' && !WORDS_BIG_ENDIAN)\n-          || (c == 'L' && WORDS_BIG_ENDIAN))\n-        regnum ++;\n-      fprintf (file, \"%s\", reg_names[regnum]);\n-    }\n   else if (c == 'C')\n     {\n+      enum machine_mode mode = GET_MODE (XEXP (op, 0));\n+\n       switch (code)\n         {\n         case EQ: fputs (\"eq\", file); break;\n         case NE: fputs (\"ne\", file); break;\n         case GT: fputs (\"gt\", file); break;\n-        case GE: fputs (\"ge\", file); break;\n-        case LT: fputs (\"lt\", file); break;\n+        case GE: fputs (mode != CCmode ? \"pl\" : \"ge\", file); break;\n+        case LT: fputs (mode != CCmode ? \"mi\" : \"lt\", file); break;\n         case LE: fputs (\"le\", file); break;\n         case GTU: fputs (\"gtu\", file); break;\n         case GEU: fputs (\"cs\", file); break;\n@@ -1168,6 +1212,46 @@ score_print_operand (FILE *file, rtx op, int c)\n           output_operand_lossage (\"invalid operand for code: '%c'\", code);\n         }\n     }\n+  else if (c == 'E')\n+    {\n+      unsigned HOST_WIDE_INT i;\n+      unsigned HOST_WIDE_INT pow2mask = 1;\n+      unsigned HOST_WIDE_INT val;\n+\n+      val = INTVAL (op);\n+      for (i = 0; i < 32; i++)\n+        {\n+          if (val == pow2mask)\n+            break;\n+          pow2mask <<= 1;\n+        }\n+      gcc_assert (i < 32);\n+      fprintf (file, HOST_WIDE_INT_PRINT_HEX, i);\n+    }\n+  else if (c == 'F')\n+    {\n+      unsigned HOST_WIDE_INT i;\n+      unsigned HOST_WIDE_INT pow2mask = 1;\n+      unsigned HOST_WIDE_INT val;\n+\n+      val = ~INTVAL (op);\n+      for (i = 0; i < 32; i++)\n+        {\n+          if (val == pow2mask)\n+            break;\n+          pow2mask <<= 1;\n+        }\n+      gcc_assert (i < 32);\n+      fprintf (file, HOST_WIDE_INT_PRINT_HEX, i);\n+    }\n+  else if (code == REG)\n+    {\n+      int regnum = REGNO (op);\n+      if ((c == 'H' && !WORDS_BIG_ENDIAN)\n+          || (c == 'L' && WORDS_BIG_ENDIAN))\n+        regnum ++;\n+      fprintf (file, \"%s\", reg_names[regnum]);\n+    }\n   else\n     {\n       switch (code)\n@@ -1233,4 +1317,48 @@ score_print_operand_address (FILE *file, rtx x)\n   gcc_unreachable ();\n }\n \n+/* Implement SELECT_CC_MODE macro.  */\n+enum machine_mode\n+score_select_cc_mode (enum rtx_code op, rtx x, rtx y)\n+{\n+  if ((op == EQ || op == NE || op == LT || op == GE)\n+      && y == const0_rtx\n+      && GET_MODE (x) == SImode)\n+    {\n+      switch (GET_CODE (x))\n+        {\n+        case PLUS:\n+        case MINUS:\n+        case NEG:\n+        case AND:\n+        case IOR:\n+        case XOR:\n+        case NOT:\n+        case ASHIFT:\n+        case LSHIFTRT:\n+        case ASHIFTRT:\n+          return CC_NZmode;\n+\n+        case SIGN_EXTEND:\n+        case ZERO_EXTEND:\n+        case ROTATE:\n+        case ROTATERT:\n+          return (op == LT || op == GE) ? CC_Nmode : CCmode;\n+\n+        default:\n+          return CCmode;\n+        }\n+    }\n+\n+  if ((op == EQ || op == NE)\n+      && (GET_CODE (y) == NEG)\n+      && register_operand (XEXP (y, 0), SImode)\n+      && register_operand (x, SImode))\n+    {\n+      return CC_NZmode;\n+    }\n+\n+  return CCmode;\n+}\n+\n struct gcc_target targetm = TARGET_INITIALIZER;"}, {"sha": "3ee53cfcb870b17b5337c576ca34419f3945198c", "filename": "gcc/config/score/score.h", "status": "modified", "additions": 79, "deletions": 42, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99fc25020d47424e0c0b0da370e2e18540b96b73/gcc%2Fconfig%2Fscore%2Fscore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99fc25020d47424e0c0b0da370e2e18540b96b73/gcc%2Fconfig%2Fscore%2Fscore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore.h?ref=99fc25020d47424e0c0b0da370e2e18540b96b73", "patch": "@@ -28,19 +28,20 @@ extern GTY(()) rtx cmp_op0;\n extern GTY(()) rtx cmp_op1;\n \n /* Controlling the Compilation Driver.  */\n+#undef SWITCH_TAKES_ARG\n #define SWITCH_TAKES_ARG(CHAR) \\\n   (DEFAULT_SWITCH_TAKES_ARG (CHAR) || (CHAR) == 'G')\n \n /* CC1_SPEC is the set of arguments to pass to the compiler proper.  */\n #undef CC1_SPEC\n-#define CC1_SPEC                 \"%{!mel:-meb}\"\n+#define CC1_SPEC                 \"%{G*} %{!mel:-meb}\"\n \n #undef ASM_SPEC\n #define ASM_SPEC \\\n   \"%{!mel:-EB} %{mel:-EL} %{mscore5u:-SCORE5U} %{mscore7:-SCORE7} %{G*}\"\n \n #undef LINK_SPEC\n-#define LINK_SPEC                 \"%{!mel:-EB} %{mel:-EL} %{G*}\"\n+#define LINK_SPEC                \"%{!mel:-EB} %{mel:-EL} %{G*}\"\n \n /* Run-time Target Specification.  */\n #define TARGET_CPU_CPP_BUILTINS()               \\\n@@ -96,7 +97,7 @@ extern GTY(()) rtx cmp_op1;\n \n /* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n #define PARM_BOUNDARY                  BITS_PER_WORD\n-#define STACK_BOUNDARY                 64\n+#define STACK_BOUNDARY                 BITS_PER_WORD\n \n /* Allocation boundary (in *bits*) for the code of a function.  */\n #define FUNCTION_BOUNDARY              BITS_PER_WORD\n@@ -115,12 +116,41 @@ extern GTY(()) rtx cmp_op1;\n    data to make it all fit in fewer cache lines.  Another is to\n    cause character arrays to be word-aligned so that `strcpy' calls\n    that copy constants to character arrays can be done inline.  */\n-#define DATA_ALIGNMENT(TYPE, ALIGN)                                     \\\n-  ((((ALIGN) < BITS_PER_WORD)                                           \\\n-    && (TREE_CODE (TYPE) == ARRAY_TYPE                                  \\\n-        || TREE_CODE (TYPE) == UNION_TYPE                               \\\n+#define DATA_ALIGNMENT(TYPE, ALIGN)                                      \\\n+  ((((ALIGN) < BITS_PER_WORD)                                            \\\n+    && (TREE_CODE (TYPE) == ARRAY_TYPE                                   \\\n+        || TREE_CODE (TYPE) == UNION_TYPE                                \\\n         || TREE_CODE (TYPE) == RECORD_TYPE)) ? BITS_PER_WORD : (ALIGN))\n \n+/* If defined, a C expression to compute the alignment given to a\n+   constant that is being placed in memory.  EXP is the constant\n+   and ALIGN is the alignment that the object would ordinarily have.\n+   The value of this macro is used instead of that alignment to align\n+   the object.\n+\n+   If this macro is not defined, then ALIGN is used.\n+\n+   The typical use of this macro is to increase alignment for string\n+   constants to be word aligned so that `strcpy' calls that copy\n+   constants can be done inline.  */\n+#define CONSTANT_ALIGNMENT(EXP, ALIGN)                                  \\\n+  ((TREE_CODE (EXP) == STRING_CST  || TREE_CODE (EXP) == CONSTRUCTOR)   \\\n+   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n+\n+/* If defined, a C expression to compute the alignment for a local\n+   variable.  TYPE is the data type, and ALIGN is the alignment that\n+   the object would ordinarily have.  The value of this macro is used\n+   instead of that alignment to align the object.\n+\n+   If this macro is not defined, then ALIGN is used.\n+\n+   One use of this macro is to increase alignment of medium-size\n+   data to make it all fit in fewer cache lines.  */\n+#define LOCAL_ALIGNMENT(TYPE, ALIGN)                                    \\\n+  ((TREE_CODE (TYPE) == ARRAY_TYPE                                      \\\n+    && TYPE_MODE (TREE_TYPE (TYPE)) == QImode                           \\\n+    && (ALIGN) < BITS_PER_WORD) ? BITS_PER_WORD : (ALIGN))\n+\n /* Alignment of field after `int : 0' in a structure.  */\n #define EMPTY_FIELD_BOUNDARY           32\n \n@@ -209,7 +239,7 @@ extern GTY(()) rtx cmp_op1;\n {                                                        \\\n   /* General Purpose Registers  */                       \\\n   1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,        \\\n-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1,        \\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,        \\\n   /* Control Registers  */                               \\\n   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        \\\n   /* CEH/ CEL/ CNT/ LCR/ SCR / ARG_POINTER_REGNUM/ FRAME_POINTER_REGNUM */\\\n@@ -245,8 +275,8 @@ extern GTY(()) rtx cmp_op1;\n }\n \n #define REG_ALLOC_ORDER                                                   \\\n-{   0,  1,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,        \\\n-   18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,  2,  3,        \\\n+{   0,  1,  6,  7,  8,  9, 10, 11,  4,  5, 22, 23, 24, 25, 26, 27,        \\\n+   12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 28, 29, 30, 31,  2,  3,        \\\n    32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,        \\\n    48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,        \\\n    64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,        \\\n@@ -386,18 +416,18 @@ enum reg_class\n   score_preferred_reload_class (X, CLASS)\n \n /* If we need to load shorts byte-at-a-time, then we need a scratch.  */\n-#define SECONDARY_INPUT_RELOAD_CLASS(CLASS, MODE, X)        \\\n+#define SECONDARY_INPUT_RELOAD_CLASS(CLASS, MODE, X) \\\n   score_secondary_reload_class (CLASS, MODE, X)\n \n /* Return the register class of a scratch register needed to copy IN into\n    or out of a register in CLASS in MODE.  If it can be done directly,\n    NO_REGS is returned.  */\n-#define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS, MODE, X)       \\\n+#define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS, MODE, X) \\\n   score_secondary_reload_class (CLASS, MODE, X)\n \n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.  */\n-#define CLASS_MAX_NREGS(CLASS, MODE)    \\\n+#define CLASS_MAX_NREGS(CLASS, MODE) \\\n   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n #define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS)    \\\n@@ -607,8 +637,8 @@ typedef struct score_args\n #define HAVE_PRE_DECREMENT              1\n #define HAVE_POST_INCREMENT             1\n #define HAVE_POST_DECREMENT             1\n-#define HAVE_PRE_MODIFY_DISP            0\n-#define HAVE_POST_MODIFY_DISP           0\n+#define HAVE_PRE_MODIFY_DISP            1\n+#define HAVE_POST_MODIFY_DISP           1\n #define HAVE_PRE_MODIFY_REG             0\n #define HAVE_POST_MODIFY_REG            0\n \n@@ -660,6 +690,13 @@ typedef struct score_args\n \n #define LEGITIMATE_CONSTANT_P(X)        1\n \n+/* Condition Code Status.  */\n+#define SELECT_CC_MODE(OP, X, Y)        score_select_cc_mode (OP, X, Y)\n+\n+/* Return nonzero if SELECT_CC_MODE will never return MODE for a\n+   floating point inequality comparison.  */\n+#define REVERSIBLE_CC_MODE(MODE)        1\n+\n /* Describing Relative Costs of Operations  */\n /* Compute extra cost of moving data between one register class and another.  */\n #define REGISTER_MOVE_COST(MODE, FROM, TO) \\\n@@ -753,32 +790,32 @@ typedef struct score_args\n   sprintf ((LABEL), \"*%s%s%ld\", (LOCAL_LABEL_PREFIX), (PREFIX), (long) (NUM))\n \n /* Output of Assembler Instructions.  */\n-#define REGISTER_NAMES                                                   \\\n-{ \"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\",                        \\\n-  \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\",                  \\\n-  \"r16\", \"r17\", \"r18\", \"r19\", \"r20\", \"r21\", \"r22\", \"r23\",                \\\n-  \"r24\", \"r25\", \"r26\", \"r27\", \"r28\", \"r29\", \"r30\", \"r31\",                \\\n-                                                                         \\\n-  \"cr0\", \"cr1\", \"cr2\", \"cr3\", \"cr4\", \"cr5\", \"cr6\", \"cr7\",                \\\n-  \"cr8\", \"cr9\", \"cr10\", \"cr11\", \"cr12\", \"cr13\", \"cr14\", \"cr15\",          \\\n-                                                                         \\\n-  \"ceh\", \"cel\", \"sr0\", \"sr1\", \"sr2\", \"_arg\", \"_frame\", \"\",               \\\n-  \"cr24\", \"cr25\", \"cr26\", \"cr27\", \"cr28\", \"cr29\", \"cr30\", \"cr31\",        \\\n-                                                                         \\\n-  \"c1r0\", \"c1r1\", \"c1r2\", \"c1r3\", \"c1r4\", \"c1r5\", \"c1r6\", \"c1r7\",        \\\n-  \"c1r8\", \"c1r9\", \"c1r10\", \"c1r11\", \"c1r12\", \"c1r13\", \"c1r14\", \"c1r15\",  \\\n-  \"c1r16\", \"c1r17\", \"c1r18\", \"c1r19\", \"c1r20\", \"c1r21\", \"c1r22\", \"c1r23\",\\\n-  \"c1r24\", \"c1r25\", \"c1r26\", \"c1r27\", \"c1r28\", \"c1r29\", \"c1r30\", \"c1r31\",\\\n-                                                                         \\\n-  \"c2r0\", \"c2r1\", \"c2r2\", \"c2r3\", \"c2r4\", \"c2r5\", \"c2r6\", \"c2r7\",        \\\n-  \"c2r8\", \"c2r9\", \"c2r10\", \"c2r11\", \"c2r12\", \"c2r13\", \"c2r14\", \"c2r15\",  \\\n-  \"c2r16\", \"c2r17\", \"c2r18\", \"c2r19\", \"c2r20\", \"c2r21\", \"c2r22\", \"c2r23\",\\\n-  \"c2r24\", \"c2r25\", \"c2r26\", \"c2r27\", \"c2r28\", \"c2r29\", \"c2r30\", \"c2r31\",\\\n-                                                                         \\\n-  \"c3r0\", \"c3r1\", \"c3r2\", \"c3r3\", \"c3r4\", \"c3r5\", \"c3r6\", \"c3r7\",        \\\n-  \"c3r8\", \"c3r9\", \"c3r10\", \"c3r11\", \"c3r12\", \"c3r13\", \"c3r14\", \"c3r15\",  \\\n-  \"c3r16\", \"c3r17\", \"c3r18\", \"c3r19\", \"c3r20\", \"c3r21\", \"c3r22\", \"c3r23\",\\\n-  \"c3r24\", \"c3r25\", \"c3r26\", \"c3r27\", \"c3r28\", \"c3r29\", \"c3r30\", \"c3r31\",\\\n+#define REGISTER_NAMES                                                    \\\n+{ \"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\",                         \\\n+  \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\",                   \\\n+  \"r16\", \"r17\", \"r18\", \"r19\", \"r20\", \"r21\", \"r22\", \"r23\",                 \\\n+  \"r24\", \"r25\", \"r26\", \"r27\", \"r28\", \"r29\", \"r30\", \"r31\",                 \\\n+                                                                          \\\n+  \"cr0\", \"cr1\", \"cr2\", \"cr3\", \"cr4\", \"cr5\", \"cr6\", \"cr7\",                 \\\n+  \"cr8\", \"cr9\", \"cr10\", \"cr11\", \"cr12\", \"cr13\", \"cr14\", \"cr15\",           \\\n+                                                                          \\\n+  \"ceh\", \"cel\", \"sr0\", \"sr1\", \"sr2\", \"_arg\", \"_frame\", \"\",                \\\n+  \"cr24\", \"cr25\", \"cr26\", \"cr27\", \"cr28\", \"cr29\", \"cr30\", \"cr31\",         \\\n+                                                                          \\\n+  \"c1r0\", \"c1r1\", \"c1r2\", \"c1r3\", \"c1r4\", \"c1r5\", \"c1r6\", \"c1r7\",         \\\n+  \"c1r8\", \"c1r9\", \"c1r10\", \"c1r11\", \"c1r12\", \"c1r13\", \"c1r14\", \"c1r15\",   \\\n+  \"c1r16\", \"c1r17\", \"c1r18\", \"c1r19\", \"c1r20\", \"c1r21\", \"c1r22\", \"c1r23\", \\\n+  \"c1r24\", \"c1r25\", \"c1r26\", \"c1r27\", \"c1r28\", \"c1r29\", \"c1r30\", \"c1r31\", \\\n+                                                                          \\\n+  \"c2r0\", \"c2r1\", \"c2r2\", \"c2r3\", \"c2r4\", \"c2r5\", \"c2r6\", \"c2r7\",         \\\n+  \"c2r8\", \"c2r9\", \"c2r10\", \"c2r11\", \"c2r12\", \"c2r13\", \"c2r14\", \"c2r15\",   \\\n+  \"c2r16\", \"c2r17\", \"c2r18\", \"c2r19\", \"c2r20\", \"c2r21\", \"c2r22\", \"c2r23\", \\\n+  \"c2r24\", \"c2r25\", \"c2r26\", \"c2r27\", \"c2r28\", \"c2r29\", \"c2r30\", \"c2r31\", \\\n+                                                                          \\\n+  \"c3r0\", \"c3r1\", \"c3r2\", \"c3r3\", \"c3r4\", \"c3r5\", \"c3r6\", \"c3r7\",         \\\n+  \"c3r8\", \"c3r9\", \"c3r10\", \"c3r11\", \"c3r12\", \"c3r13\", \"c3r14\", \"c3r15\",   \\\n+  \"c3r16\", \"c3r17\", \"c3r18\", \"c3r19\", \"c3r20\", \"c3r21\", \"c3r22\", \"c3r23\", \\\n+  \"c3r24\", \"c3r25\", \"c3r26\", \"c3r27\", \"c3r28\", \"c3r29\", \"c3r30\", \"c3r31\", \\\n }\n \n /* Print operand X (an rtx) in assembler syntax to file FILE.  */\n@@ -907,4 +944,4 @@ struct extern_list GTY ((chain_next (\"%h.next\")))\n   int size;                             /* size in bytes  */\n };\n \n-extern GTY (()) struct extern_list      *extern_head ;\n+extern GTY (()) struct extern_list      *extern_head;"}, {"sha": "63934692638b1eb4b7d62b5b3cf9a9ce80518af7", "filename": "gcc/config/score/score.md", "status": "modified", "additions": 462, "deletions": 207, "changes": 669, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99fc25020d47424e0c0b0da370e2e18540b96b73/gcc%2Fconfig%2Fscore%2Fscore.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99fc25020d47424e0c0b0da370e2e18540b96b73/gcc%2Fconfig%2Fscore%2Fscore.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore.md?ref=99fc25020d47424e0c0b0da370e2e18540b96b73", "patch": "@@ -59,8 +59,8 @@\n \n (define_constants\n    [(BITTST         0)\n-    (LOAD_ADD       1)\n-    (STORE_ADD      2)\n+    (CPLOAD         1)\n+    (CPRESTORE      2)\n \n     (SCB            3)\n     (SCW            4)\n@@ -88,10 +88,22 @@\n (include \"misc.md\")\n (include \"mac.md\")\n \n-(define_insn \"movqi\"\n+(define_expand \"movqi\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\")\n+        (match_operand:QI 1 \"general_operand\"))]\n+  \"\"\n+{\n+  if (MEM_P (operands[0])\n+      && !register_operand (operands[1], QImode))\n+    {\n+      operands[1] = force_reg (QImode, operands[1]);\n+    }\n+})\n+\n+(define_insn \"*movqi_insns\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d,d,d,m,d,*x,d,*a\")\n         (match_operand:QI 1 \"general_operand\" \"i,d,m,d,*x,d,*a,d\"))]\n-  \"\"\n+  \"!MEM_P (operands[0]) || register_operand (operands[1], QImode)\"\n {\n   switch (which_alternative)\n     {\n@@ -109,10 +121,22 @@\n   [(set_attr \"type\" \"arith,move,load,store,fce,tce,fsr,tsr\")\n    (set_attr \"mode\" \"QI\")])\n \n-(define_insn \"movhi\"\n+(define_expand \"movhi\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\")\n+        (match_operand:HI 1 \"general_operand\"))]\n+  \"\"\n+{\n+  if (MEM_P (operands[0])\n+      && !register_operand (operands[1], HImode))\n+    {\n+      operands[1] = force_reg (HImode, operands[1]);\n+    }\n+})\n+\n+(define_insn \"*movhi_insns\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d,d,d,m,d,*x,d,*a\")\n         (match_operand:HI 1 \"general_operand\" \"i,d,m,d,*x,d,*a,d\"))]\n-  \"\"\n+  \"!MEM_P (operands[0]) || register_operand (operands[1], HImode)\"\n {\n   switch (which_alternative)\n     {\n@@ -130,10 +154,22 @@\n   [(set_attr \"type\" \"arith,move,load,store,fce,tce,fsr,tsr\")\n    (set_attr \"mode\" \"HI\")])\n \n-(define_insn \"movsi\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,d,d,m,d,*x,d,*a,d,c\")\n-        (match_operand:SI 1 \"general_operand\" \"i,d,m,d,*x,d,*a,d,c,d\"))]\n+(define_expand \"movsi\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\")\n+        (match_operand:SI 1 \"general_operand\"))]\n   \"\"\n+{\n+  if (MEM_P (operands[0])\n+      && !register_operand (operands[1], SImode))\n+    {\n+      operands[1] = force_reg (SImode, operands[1]);\n+    }\n+})\n+\n+(define_insn \"*movsi_insns\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,d,d,m,d,*x,d,*a,d,*c\")\n+        (match_operand:SI 1 \"general_operand\" \"i,d,m,d,*x,d,*a,d,*c,d\"))]\n+  \"!MEM_P (operands[0]) || register_operand (operands[1], SImode)\"\n {\n   switch (which_alternative)\n     {\n@@ -169,46 +205,103 @@\n   DONE;\n })\n \n+(define_expand \"movsf\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\")\n+        (match_operand:SF 1 \"general_operand\"))]\n+  \"\"\n+{\n+  if (MEM_P (operands[0])\n+      && !register_operand (operands[1], SFmode))\n+    {\n+      operands[1] = force_reg (SFmode, operands[1]);\n+    }\n+})\n+\n+(define_insn \"*movsf_insns\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=d,d,d,m\")\n+        (match_operand:SF 1 \"general_operand\" \"i,d,m,d\"))]\n+  \"!MEM_P (operands[0]) || register_operand (operands[1], SFmode)\"\n+{\n+  switch (which_alternative)\n+    {\n+    case 0: return \\\"li      %0, %D1\\\";;\n+    case 1: return mdp_move (operands);\n+    case 2: return mdp_linsn (operands, MDA_WORD, false);\n+    case 3: return mdp_sinsn (operands, MDA_WORD);\n+    default: gcc_unreachable ();\n+    }\n+}\n+  [(set_attr \"type\" \"arith,move,load,store\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn_and_split \"movdf\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=d,d,d,m\")\n+        (match_operand:DF 1 \"general_operand\" \"i,d,m,d\"))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(const_int 0)]\n+{\n+  mds_movdi (operands);\n+  DONE;\n+})\n+\n (define_insn \"addsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,d,d\")\n-        (plus:SI (match_operand:SI 1 \"register_operand\" \"0,d,%d\")\n-                 (match_operand:SI 2 \"arith_operand\" \"L,N,d\")))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d,d,d\")\n+        (plus:SI (match_operand:SI 1 \"register_operand\" \"0,0,d,d\")\n+                 (match_operand:SI 2 \"arith_operand\" \"I,L,N,d\")))]\n   \"\"\n-  \"@\n-   addi    %0, %c2\n-   addri   %0, %1, %c2\n-   add     %0, %1, %2\"\n+{\n+  switch (which_alternative)\n+    {\n+    case 0: return \\\"addis %0, %U2\\\";\n+    case 1: return mdp_select_add_imm (operands, false);\n+    case 2: return \\\"addri %0, %1, %c2\\\";\n+    case 3: return mdp_select (operands, \"add\", true, \"\", false);\n+    default: gcc_unreachable ();\n+    }\n+}\n   [(set_attr \"type\" \"arith\")\n    (set_attr \"mode\" \"SI\")])\n \n (define_insn \"*addsi3_cmp\"\n   [(set (reg:CC_NZ CC_REGNUM)\n-        (compare:CC_NZ (plus:SI (match_operand:SI 0 \"register_operand\" \"d,d,d\")\n-                                (match_operand:SI 1 \"arith_operand\" \"N,L,d\"))\n-                       (const_int 0)))]\n+        (compare:CC_NZ (plus:SI\n+                        (match_operand:SI 1 \"register_operand\" \"0,0,d,d\")\n+                        (match_operand:SI 2 \"arith_operand\" \"I,L,N,d\"))\n+                       (const_int 0)))\n+   (clobber (match_scratch:SI 0 \"=d,d,d,d\"))]\n   \"\"\n-  \"@\n-   %[       addri.c r1, %0, %c1       %]\n-   %[       m%V0    r1, %0\\;addi.c  r1, %2        %]\n-   %[       add.c   r1, %0, %1        %]\"\n+{\n+  switch (which_alternative)\n+    {\n+    case 0: return \\\"addis.c %0, %U2\\\";\n+    case 1: return mdp_select_add_imm (operands, true);\n+    case 2: return \\\"addri.c %0, %1, %c2\\\";\n+    case 3: return mdp_select (operands, \"add\", true, \"\", true);\n+    default: gcc_unreachable ();\n+    }\n+}\n   [(set_attr \"type\" \"arith\")\n    (set_attr \"up_c\" \"yes\")\n    (set_attr \"mode\" \"SI\")])\n \n-(define_insn \"addsi3_ucc\"\n+(define_insn \"*addsi3_ucc\"\n   [(set (reg:CC_NZ CC_REGNUM)\n-        (compare:CC_NZ (plus:SI (match_operand:SI 1 \"register_operand\" \"0,d,d\")\n-                                (match_operand:SI 2 \"arith_operand\" \"L,N,d\"))\n+        (compare:CC_NZ (plus:SI\n+                        (match_operand:SI 1 \"register_operand\" \"0,0,d,d\")\n+                        (match_operand:SI 2 \"arith_operand\" \"I,L,N,d\"))\n                        (const_int 0)))\n-   (set (match_operand:SI 0 \"register_operand\" \"=d,d,d\")\n+   (set (match_operand:SI 0 \"register_operand\" \"=d,d,d,d\")\n         (plus:SI (match_dup 1) (match_dup 2)))]\n   \"\"\n {\n   switch (which_alternative)\n     {\n-    case 0: return mdp_add_imm_ucc (operands);\n-    case 1: return \\\"addri.c %0, %1, %c2\\\";\n-    case 2: return mdp_select (operands, \"add\", true, \"\");\n+    case 0: return \\\"addis.c %0, %U2\\\";\n+    case 1: return mdp_select_add_imm (operands, true);\n+    case 2: return \\\"addri.c %0, %1, %c2\\\";\n+    case 3: return mdp_select (operands, \"add\", true, \"\", true);\n     default: gcc_unreachable ();\n     }\n }\n@@ -217,9 +310,9 @@\n    (set_attr \"mode\" \"SI\")])\n \n (define_insn \"adddi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=*e,d\")\n-        (plus:DI (match_operand:DI 1 \"register_operand\" \"*0,d\")\n-                 (match_operand:DI 2 \"register_operand\" \"*e,d\")))\n+  [(set (match_operand:DI 0 \"register_operand\" \"=e,d\")\n+        (plus:DI (match_operand:DI 1 \"register_operand\" \"0,d\")\n+                 (match_operand:DI 2 \"register_operand\" \"e,d\")))\n   (clobber (reg:CC CC_REGNUM))]\n   \"\"\n   \"@\n@@ -233,17 +326,22 @@\n         (minus:SI (match_operand:SI 1 \"register_operand\" \"d\")\n                   (match_operand:SI 2 \"register_operand\" \"d\")))]\n   \"\"\n-  \"sub     %0, %1, %2\"\n+{\n+  return mdp_select (operands, \"sub\", false, \"\", false);\n+}\n   [(set_attr \"type\" \"arith\")\n    (set_attr \"mode\" \"SI\")])\n \n (define_insn \"*subsi3_cmp\"\n   [(set (reg:CC_NZ CC_REGNUM)\n-        (compare:CC_NZ (minus:SI (match_operand:SI 0 \"register_operand\" \"d\")\n-                                 (match_operand:SI 1 \"register_operand\" \"d\"))\n-                       (const_int 0)))]\n+        (compare:CC_NZ (minus:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+                                 (match_operand:SI 2 \"register_operand\" \"d\"))\n+                       (const_int 0)))\n+   (clobber (match_scratch:SI 0 \"=d\"))]\n   \"\"\n-  \"%[        sub.c   r1, %0, %1        %]\"\n+{\n+  return mdp_select (operands, \"sub\", false, \"\", true);\n+}\n   [(set_attr \"type\" \"arith\")\n    (set_attr \"up_c\" \"yes\")\n    (set_attr \"mode\" \"SI\")])\n@@ -255,11 +353,10 @@\n    (set (reg:CC CC_REGNUM)\n         (compare:CC (match_dup 1) (match_dup 2)))]\n   \"\"\n-  [(parallel\n-       [(set (reg:CC CC_REGNUM)\n-             (compare:CC (match_dup 1) (match_dup 2)))\n-        (set (match_dup 0)\n-             (minus:SI (match_dup 1) (match_dup 2)))])])\n+  [(set (reg:CC CC_REGNUM)\n+        (compare:CC (match_dup 1) (match_dup 2)))\n+   (set (match_dup 0)\n+        (minus:SI (match_dup 1) (match_dup 2)))])\n \n (define_insn \"subsi3_ucc_pcmp\"\n   [(parallel\n@@ -270,7 +367,7 @@\n              (minus:SI (match_dup 1) (match_dup 2)))])]\n   \"\"\n {\n-  return mdp_select (operands, \"sub\", false, \"\");\n+  return mdp_select (operands, \"sub\", false, \"\", true);\n }\n   [(set_attr \"type\" \"arith\")\n    (set_attr \"up_c\" \"yes\")\n@@ -285,16 +382,16 @@\n         (minus:SI (match_dup 1) (match_dup 2)))]\n   \"\"\n {\n-  return mdp_select (operands, \"sub\", false, \"\");\n+  return mdp_select (operands, \"sub\", false, \"\", true);\n }\n   [(set_attr \"type\" \"arith\")\n    (set_attr \"up_c\" \"yes\")\n    (set_attr \"mode\" \"SI\")])\n \n (define_insn \"subdi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=*e,d\")\n-        (minus:DI (match_operand:DI 1 \"register_operand\" \"*0,d\")\n-                  (match_operand:DI 2 \"register_operand\" \"*e,d\")))\n+  [(set (match_operand:DI 0 \"register_operand\" \"=e,d\")\n+        (minus:DI (match_operand:DI 1 \"register_operand\" \"0,d\")\n+                  (match_operand:DI 2 \"register_operand\" \"e,d\")))\n    (clobber (reg:CC CC_REGNUM))]\n   \"\"\n   \"@\n@@ -306,47 +403,58 @@\n (define_insn \"andsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d,d,d,d\")\n         (and:SI (match_operand:SI 1 \"register_operand\" \"0,0,d,d\")\n-                (match_operand:SI 2 \"arith_operand\" \"K,Q,M,d\")))]\n+                (match_operand:SI 2 \"arith_operand\" \"I,K,M,d\")))]\n   \"\"\n-  \"@\n-   andi    %0, %c2\n-   andis   %0, %U2\n-   andri   %0, %1, %c2\n-   and     %0, %1, %2\"\n+{\n+  switch (which_alternative)\n+    {\n+    case 0: return \\\"andis %0, %U2\\\";\n+    case 1: return \\\"andi  %0, %c2\";\n+    case 2: return \\\"andri %0, %1, %c2\\\";\n+    case 3: return mdp_select (operands, \"and\", true, \"\", false);\n+    default: gcc_unreachable ();\n+    }\n+}\n   [(set_attr \"type\" \"arith\")\n    (set_attr \"mode\" \"SI\")])\n \n (define_insn \"andsi3_cmp\"\n   [(set (reg:CC_NZ CC_REGNUM)\n-        (compare:CC_NZ (and:SI (match_operand:SI 0 \"register_operand\" \"d,d,d,d\")\n-                               (match_operand:SI 1 \"arith_operand\" \"M,K,Q,d\"))\n-                       (const_int 0)))]\n+        (compare:CC_NZ (and:SI (match_operand:SI 1 \"register_operand\" \"0,0,0,d\")\n+                               (match_operand:SI 2 \"arith_operand\" \"I,K,M,d\"))\n+                       (const_int 0)))\n+   (clobber (match_scratch:SI 0 \"=d,d,d,d\"))]\n   \"\"\n-  \"@\n-   %[        andri.c r1, %0, %c1      %]\n-   %[        m%V0    r1, %0\\;andi.c  r1, %c1        %]\n-   %[        m%V0    r1, %0\\;andis.c r1, %U1        %]\n-   %[        and.c   r1, %0, %1       %]\"\n+{\n+  switch (which_alternative)\n+    {\n+    case 0: return \\\"andis.c %0, %U2\\\";\n+    case 1: return \\\"andi.c  %0, %c2\";\n+    case 2: return \\\"andri.c %0, %1, %c2\\\";\n+    case 3: return mdp_select (operands, \"and\", true, \"\", true);\n+    default: gcc_unreachable ();\n+    }\n+}\n   [(set_attr \"type\" \"arith\")\n    (set_attr \"up_c\" \"yes\")\n    (set_attr \"mode\" \"SI\")])\n \n-(define_insn \"andsi3_ucc\"\n+(define_insn \"*andsi3_ucc\"\n   [(set (reg:CC_NZ CC_REGNUM)\n         (compare:CC_NZ (and:SI\n                         (match_operand:SI 1 \"register_operand\" \"0,0,d,d\")\n-                        (match_operand:SI 2 \"arith_operand\" \"K,Q,M,d\"))\n+                        (match_operand:SI 2 \"arith_operand\" \"I,K,M,d\"))\n                        (const_int 0)))\n    (set (match_operand:SI 0 \"register_operand\" \"=d,d,d,d\")\n         (and:SI (match_dup 1) (match_dup 2)))]\n   \"\"\n {\n   switch (which_alternative)\n     {\n-    case 0:  return \\\"andi.c  %0, %c2\\\";\n-    case 1:  return \\\"andis.c %0, %U2\\\";\n-    case 2:  return \\\"andri.c %0, %1, %c2\\\";\n-    case 3:  return mdp_select (operands, \"and\", true, \"\");\n+    case 0: return \\\"andis.c %0, %U2\\\";\n+    case 1: return \\\"andi.c  %0, %c2\";\n+    case 2: return \\\"andri.c %0, %1, %c2\\\";\n+    case 3: return mdp_select (operands, \"and\", true, \"\", true);\n     default: gcc_unreachable ();\n     }\n }\n@@ -355,12 +463,12 @@\n    (set_attr \"mode\" \"SI\")])\n \n (define_insn_and_split \"*zero_extract_andi\"\n-  [(set (reg:CC_NZ CC_REGNUM)\n-        (compare:CC_NZ (zero_extract:SI\n-                        (match_operand:SI 0 \"register_operand\" \"d\")\n-                        (match_operand:SI 1 \"const_bi_operand\" \"\")\n-                        (match_operand:SI 2 \"const_bi_operand\" \"\"))\n-                       (const_int 0)))]\n+  [(set (reg:CC CC_REGNUM)\n+        (compare:CC (zero_extract:SI\n+                     (match_operand:SI 0 \"register_operand\" \"d\")\n+                     (match_operand:SI 1 \"const_uimm5\" \"\")\n+                     (match_operand:SI 2 \"const_uimm5\" \"\"))\n+                    (const_int 0)))]\n   \"\"\n   \"#\"\n   \"\"\n@@ -373,38 +481,62 @@\n (define_insn \"iorsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d,d,d,d\")\n         (ior:SI (match_operand:SI 1 \"register_operand\" \"0,0,d,d\")\n-                (match_operand:SI 2 \"arith_operand\" \"K,Q,M,d\")))]\n+                (match_operand:SI 2 \"arith_operand\" \"I,K,M,d\")))]\n   \"\"\n-  \"@\n-   ori     %0, %c2\n-   oris    %0, %U2\n-   orri    %0, %1, %c2\n-   or      %0, %1, %2\"\n+{\n+  switch (which_alternative)\n+    {\n+    case 0: return \\\"oris %0, %U2\\\";\n+    case 1: return \\\"ori  %0, %c2\\\";\n+    case 2: return \\\"orri %0, %1, %c2\\\";\n+    case 3: return mdp_select (operands, \"or\", true, \"\", false);\n+    default: gcc_unreachable ();\n+    }\n+}\n   [(set_attr \"type\" \"arith\")\n    (set_attr \"mode\" \"SI\")])\n \n (define_insn \"iorsi3_ucc\"\n   [(set (reg:CC_NZ CC_REGNUM)\n-        (compare:CC_NZ (ior:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-                               (match_operand:SI 2 \"register_operand\" \"d\"))\n+        (compare:CC_NZ (ior:SI\n+                        (match_operand:SI 1 \"register_operand\" \"0,0,d,d\")\n+                        (match_operand:SI 2 \"arith_operand\" \"I,K,M,d\"))\n                        (const_int 0)))\n-   (set (match_operand:SI 0 \"register_operand\" \"=d\")\n+   (set (match_operand:SI 0 \"register_operand\" \"=d,d,d,d\")\n         (ior:SI (match_dup 1) (match_dup 2)))]\n   \"\"\n {\n-  return mdp_select (operands, \"or\", true, \"\");\n+  switch (which_alternative)\n+    {\n+    case 0: return \\\"oris.c %0, %U2\\\";\n+    case 1: return \\\"ori.c  %0, %c2\\\";\n+    case 2: return \\\"orri.c %0, %1, %c2\\\";\n+    case 3: return mdp_select (operands, \"or\", true, \"\", true);\n+    default: gcc_unreachable ();\n+    }\n }\n   [(set_attr \"type\" \"arith\")\n    (set_attr \"up_c\" \"yes\")\n    (set_attr \"mode\" \"SI\")])\n \n (define_insn \"iorsi3_cmp\"\n   [(set (reg:CC_NZ CC_REGNUM)\n-        (compare:CC_NZ (ior:SI (match_operand:SI 0 \"register_operand\" \"d\")\n-                               (match_operand:SI 1 \"register_operand\" \"d\"))\n-                       (const_int 0)))]\n+        (compare:CC_NZ (ior:SI\n+                        (match_operand:SI 1 \"register_operand\" \"0,0,d,d\")\n+                        (match_operand:SI 2 \"arith_operand\" \"I,K,M,d\"))\n+                       (const_int 0)))\n+   (clobber (match_scratch:SI 0 \"=d,d,d,d\"))]\n   \"\"\n-  \"%[        or.c    r1, %0, %1       %]\"\n+{\n+  switch (which_alternative)\n+    {\n+    case 0: return \\\"oris.c %0, %U2\\\";\n+    case 1: return \\\"ori.c  %0, %c2\\\";\n+    case 2: return \\\"orri.c %0, %1, %c2\\\";\n+    case 3: return mdp_select (operands, \"or\", true, \"\", true);\n+    default: gcc_unreachable ();\n+    }\n+}\n   [(set_attr \"type\" \"arith\")\n    (set_attr \"up_c\" \"yes\")\n    (set_attr \"mode\" \"SI\")])\n@@ -414,7 +546,9 @@\n         (xor:SI (match_operand:SI 1 \"register_operand\" \"d\")\n                 (match_operand:SI 2 \"register_operand\" \"d\")))]\n   \"\"\n-  \"xor     %0, %1, %2\"\n+{\n+  return mdp_select (operands, \"xor\", true, \"\", false);\n+}\n   [(set_attr \"type\" \"arith\")\n    (set_attr \"mode\" \"SI\")])\n \n@@ -427,19 +561,22 @@\n         (xor:SI (match_dup 1) (match_dup 2)))]\n   \"\"\n {\n-  return mdp_select (operands, \"xor\", true, \"\");\n+  return mdp_select (operands, \"xor\", true, \"\", true);\n }\n   [(set_attr \"type\" \"arith\")\n    (set_attr \"up_c\" \"yes\")\n    (set_attr \"mode\" \"SI\")])\n \n (define_insn \"xorsi3_cmp\"\n   [(set (reg:CC_NZ CC_REGNUM)\n-        (compare:CC_NZ (xor:SI (match_operand:SI 0 \"register_operand\" \"d\")\n-                               (match_operand:SI 1 \"register_operand\" \"d\"))\n-                       (const_int 0)))]\n+        (compare:CC_NZ (xor:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+                               (match_operand:SI 2 \"register_operand\" \"d\"))\n+                       (const_int 0)))\n+   (clobber (match_scratch:SI 0 \"=d\"))]\n   \"\"\n-  \"%[        xor.c   r1, %0, %1       %]\"\n+{\n+  return mdp_select (operands, \"xor\", true, \"\", true);\n+}\n   [(set_attr \"type\" \"arith\")\n    (set_attr \"up_c\" \"yes\")\n    (set_attr \"mode\" \"SI\")])\n@@ -459,49 +596,35 @@\n   [(set_attr \"type\" \"arith,load\")\n    (set_attr \"mode\" \"SI\")])\n \n-(define_insn \"extendqisi2_cmp\"\n+(define_insn \"*extendqisi2_ucc\"\n   [(set (reg:CC_N CC_REGNUM)\n         (compare:CC_N (ashiftrt:SI\n-                       (ashift:SI (match_operand:SI 0 \"register_operand\" \"d\")\n+                       (ashift:SI (match_operand:SI 1 \"register_operand\" \"d\")\n                                   (const_int 24))\n                        (const_int 24))\n-                      (const_int 0)))]\n+                      (const_int 0)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (sign_extend:SI (match_operand:QI 2 \"register_operand\" \"0\")))]\n   \"\"\n-  \"%[        extsb.c r1, %0       %]\"\n+  \"extsb.c %0, %1\"\n   [(set_attr \"type\" \"arith\")\n    (set_attr \"up_c\" \"yes\")\n    (set_attr \"mode\" \"SI\")])\n \n-(define_insn \"extendqisi2_ucc\"\n+(define_insn \"*extendqisi2_cmp\"\n   [(set (reg:CC_N CC_REGNUM)\n         (compare:CC_N (ashiftrt:SI\n                        (ashift:SI (match_operand:SI 1 \"register_operand\" \"d\")\n                                   (const_int 24))\n                        (const_int 24))\n                       (const_int 0)))\n-   (set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (sign_extend:SI (match_operand:QI 2 \"register_operand\" \"0\")))]\n+   (clobber (match_scratch:SI 0 \"=d\"))]\n   \"\"\n   \"extsb.c %0, %1\"\n   [(set_attr \"type\" \"arith\")\n    (set_attr \"up_c\" \"yes\")\n    (set_attr \"mode\" \"SI\")])\n \n-(define_insn \"zero_extendqisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\"\"=d,d\")\n-        (zero_extend:SI (match_operand:QI 1 \"register_operand\" \"d,m\")))]\n-  \"\"\n-{\n-  switch (which_alternative)\n-    {\n-    case 0: return \\\"extzb   %0, %1\\\";\n-    case 1: return mdp_linsn (operands, MDA_BYTE, false);\n-    default: gcc_unreachable ();\n-    }\n-}\n-  [(set_attr \"type\" \"arith, load\")\n-   (set_attr \"mode\" \"SI\")])\n-\n (define_insn \"extendhisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n         (sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"d,m\")))]\n@@ -517,34 +640,79 @@\n   [(set_attr \"type\" \"arith, load\")\n    (set_attr \"mode\" \"SI\")])\n \n-(define_insn \"extendhisi2_cmp\"\n+(define_insn \"*extendhisi2_ucc\"\n   [(set (reg:CC_N CC_REGNUM)\n         (compare:CC_N (ashiftrt:SI\n-                       (ashift:SI (match_operand:SI 0 \"register_operand\" \"d\")\n+                       (ashift:SI (match_operand:SI 1 \"register_operand\" \"d\")\n                                   (const_int 16))\n                        (const_int 16))\n-                      (const_int 0)))]\n+                      (const_int 0)))\n+  (set (match_operand:SI 0 \"register_operand\" \"=d\")\n+       (sign_extend:SI (match_operand:HI 2 \"register_operand\" \"0\")))]\n   \"\"\n-  \"%[        extsh.c r1, %0       %]\"\n+  \"extsh.c %0, %1\"\n   [(set_attr \"type\" \"arith\")\n    (set_attr \"up_c\" \"yes\")\n    (set_attr \"mode\" \"SI\")])\n \n-(define_insn \"extendhisi2_ucc\"\n+(define_insn \"*extendhisi2_cmp\"\n   [(set (reg:CC_N CC_REGNUM)\n         (compare:CC_N (ashiftrt:SI\n                        (ashift:SI (match_operand:SI 1 \"register_operand\" \"d\")\n                                   (const_int 16))\n                        (const_int 16))\n                       (const_int 0)))\n-  (set (match_operand:SI 0 \"register_operand\" \"=d\")\n-       (sign_extend:SI (match_operand:HI 2 \"register_operand\" \"0\")))]\n+   (clobber (match_scratch:SI 0 \"=d\"))]\n   \"\"\n   \"extsh.c %0, %1\"\n   [(set_attr \"type\" \"arith\")\n    (set_attr \"up_c\" \"yes\")\n    (set_attr \"mode\" \"SI\")])\n \n+(define_insn \"zero_extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+        (zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"d,m\")))]\n+  \"\"\n+{\n+  switch (which_alternative)\n+    {\n+    case 0: return \\\"extzb   %0, %1\\\";\n+    case 1: return mdp_linsn (operands, MDA_BYTE, false);\n+    default: gcc_unreachable ();\n+    }\n+  }\n+  [(set_attr \"type\" \"arith, load\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"*zero_extendqisi2_ucc\"\n+  [(set (reg:CC_N CC_REGNUM)\n+        (compare:CC_N (lshiftrt:SI\n+                       (ashift:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+                                  (const_int 24))\n+                       (const_int 24))\n+                      (const_int 0)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (zero_extend:SI (match_operand:QI 2 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"extzb.c %0, %1\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"up_c\" \"yes\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"*zero_extendqisi2_cmp\"\n+  [(set (reg:CC_N CC_REGNUM)\n+        (compare:CC_N (lshiftrt:SI\n+                       (ashift:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+                                  (const_int 24))\n+                       (const_int 24))\n+                      (const_int 0)))\n+   (clobber (match_scratch:SI 0 \"=d\"))]\n+  \"\"\n+  \"extzb.c %0, %1\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"up_c\" \"yes\")\n+   (set_attr \"mode\" \"SI\")])\n+\n (define_insn \"zero_extendhisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n         (zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"d,m\")))]\n@@ -560,6 +728,35 @@\n   [(set_attr \"type\" \"arith, load\")\n    (set_attr \"mode\" \"SI\")])\n \n+(define_insn \"*zero_extendhisi2_ucc\"\n+  [(set (reg:CC_N CC_REGNUM)\n+        (compare:CC_N (lshiftrt:SI\n+                       (ashift:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+                                  (const_int 16))\n+                       (const_int 16))\n+                      (const_int 0)))\n+  (set (match_operand:SI 0 \"register_operand\" \"=d\")\n+       (zero_extend:SI (match_operand:HI 2 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"extzh.c %0, %1\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"up_c\" \"yes\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"*zero_extendhisi2_cmp\"\n+  [(set (reg:CC_N CC_REGNUM)\n+        (compare:CC_N (lshiftrt:SI\n+                       (ashift:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+                                  (const_int 16))\n+                       (const_int 16))\n+                      (const_int 0)))\n+   (clobber (match_scratch:SI 0 \"=d\"))]\n+  \"\"\n+  \"extzh.c %0, %1\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"up_c\" \"yes\")\n+   (set_attr \"mode\" \"SI\")])\n+\n (define_insn \"mulsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n         (mult:SI (match_operand:SI 1 \"register_operand\" \"d\")\n@@ -572,7 +769,8 @@\n \n (define_insn \"mulsidi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=x\")\n-        (mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n+        (mult:DI (sign_extend:DI\n+                  (match_operand:SI 1 \"register_operand\" \"d\"))\n                  (sign_extend:DI\n                   (match_operand:SI 2 \"register_operand\" \"d\"))))]\n   \"!TARGET_SCORE5U\"\n@@ -582,7 +780,8 @@\n \n (define_insn \"umulsidi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=x\")\n-        (mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n+        (mult:DI (zero_extend:DI\n+                  (match_operand:SI 1 \"register_operand\" \"d\"))\n                  (zero_extend:DI\n                   (match_operand:SI 2 \"register_operand\" \"d\"))))]\n   \"!TARGET_SCORE5U\"\n@@ -635,8 +834,8 @@\n {\n   switch (which_alternative)\n     {\n-    case 0: return mdp_select (operands, \"slli\", false, \"c\");\n-    case 1: return mdp_select (operands, \"sll\", false, \"\");\n+    case 0: return mdp_select (operands, \"slli\", false, \"c\", true);\n+    case 1: return mdp_select (operands, \"sll\", false, \"\", true);\n     default: gcc_unreachable ();\n     }\n }\n@@ -647,13 +846,19 @@\n (define_insn \"ashlsi3_cmp\"\n   [(set (reg:CC_NZ CC_REGNUM)\n         (compare:CC_NZ (ashift:SI\n-                        (match_operand:SI 0 \"register_operand\" \"d,d\")\n-                        (match_operand:SI 1 \"arith_operand\" \"J,d\"))\n-                       (const_int 0)))]\n+                        (match_operand:SI 1 \"register_operand\" \"d,d\")\n+                        (match_operand:SI 2 \"arith_operand\" \"J,d\"))\n+                       (const_int 0)))\n+   (clobber (match_scratch:SI 0 \"=d,d\"))]\n   \"\"\n-  \"@\n-   %[        slli.c  r1, %0, %c1      %]\n-   %[        sll.c   r1, %0, %1       %]\"\n+{\n+  switch (which_alternative)\n+    {\n+    case 0: return mdp_select (operands, \"slli\", false, \"c\", true);\n+    case 1: return mdp_select (operands, \"sll\", false, \"\", true);\n+    default: gcc_unreachable ();\n+    }\n+}\n   [(set_attr \"type\" \"arith\")\n    (set_attr \"up_c\" \"yes\")\n    (set_attr \"mode\" \"SI\")])\n@@ -682,7 +887,7 @@\n   switch (which_alternative)\n     {\n     case 0: return \\\"srai.c  %0, %1, %c2\\\";\n-    case 1: return mdp_select (operands, \"sra\", false, \"\");\n+    case 1: return mdp_select (operands, \"sra\", false, \"\", true);\n     default: gcc_unreachable ();\n     }\n }\n@@ -693,52 +898,23 @@\n (define_insn \"ashrsi3_cmp\"\n   [(set (reg:CC_NZ CC_REGNUM)\n         (compare:CC_NZ (ashiftrt:SI\n-                        (match_operand:SI 0 \"register_operand\" \"d,d\")\n-                        (match_operand:SI 1 \"arith_operand\" \"J,d\"))\n-                       (const_int 0)))]\n-  \"\"\n-  \"@\n-   %[        srai.c  r1, %0, %c1      %]\n-   %[        sra.c   r1, %0, %1       %]\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"up_c\" \"yes\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"ashrsi3_ucc_n\"\n-  [(set (reg:CC_N CC_REGNUM)\n-        (compare:CC_N (ashiftrt:SI\n-                       (match_operand:SI 1 \"register_operand\" \"d,d\")\n-                       (match_operand:SI 2 \"arith_operand\" \"J,d\"))\n-                      (const_int 0)))\n-   (set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n-        (ashiftrt:SI (match_dup 1) (match_dup 2)))]\n+                        (match_operand:SI 1 \"register_operand\" \"d,d\")\n+                        (match_operand:SI 2 \"arith_operand\" \"J,d\"))\n+                       (const_int 0)))\n+   (clobber (match_scratch:SI 0 \"=d,d\"))]\n   \"\"\n {\n   switch (which_alternative)\n     {\n     case 0: return \\\"srai.c  %0, %1, %c2\\\";\n-    case 1: return mdp_select (operands, \"sra\", false, \"\");\n+    case 1: return mdp_select (operands, \"sra\", false, \"\", true);\n     default: gcc_unreachable ();\n     }\n }\n   [(set_attr \"type\" \"arith\")\n    (set_attr \"up_c\" \"yes\")\n    (set_attr \"mode\" \"SI\")])\n \n-(define_insn \"ashrsi3_cmp_n\"\n-  [(set (reg:CC_N CC_REGNUM)\n-        (compare:CC_N (ashiftrt:SI\n-                       (match_operand:SI 0 \"register_operand\" \"d,d\")\n-                       (match_operand:SI 1 \"arith_operand\" \"J,d\"))\n-                      (const_int 0)))]\n-  \"\"\n-  \"@\n-   %[        srai.c  r1, %0, %c1      %]\n-   %[        sra.c   r1, %0, %1       %]\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"up_c\" \"yes\")\n-   (set_attr \"mode\" \"SI\")])\n-\n (define_insn \"lshrsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n         (lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"d,d\")\n@@ -762,8 +938,8 @@\n {\n   switch (which_alternative)\n     {\n-    case 0: return mdp_select (operands, \"srli\", false, \"c\");\n-    case 1: return mdp_select (operands, \"srl\", false, \"\");\n+    case 0: return mdp_select (operands, \"srli\", false, \"c\", true);\n+    case 1: return mdp_select (operands, \"srl\", false, \"\", true);\n     default: gcc_unreachable ();\n     }\n }\n@@ -774,13 +950,19 @@\n (define_insn \"lshrsi3_cmp\"\n   [(set (reg:CC_NZ CC_REGNUM)\n         (compare:CC_NZ (lshiftrt:SI\n-                        (match_operand:SI 0 \"register_operand\" \"d,d\")\n-                        (match_operand:SI 1 \"arith_operand\" \"J,d\"))\n-                       (const_int 0)))]\n+                        (match_operand:SI 1 \"register_operand\" \"d,d\")\n+                        (match_operand:SI 2 \"arith_operand\" \"J,d\"))\n+                       (const_int 0)))\n+   (clobber (match_scratch:SI 0 \"=d,d\"))]\n   \"\"\n-  \"@\n-   %[        srli.c  r1, %0, %c1      %]\n-   %[        srl.c   r1, %0, %1       %]\"\n+{\n+  switch (which_alternative)\n+    {\n+    case 0: return mdp_select (operands, \"srli\", false, \"c\", true);\n+    case 1: return mdp_select (operands, \"srl\", false, \"\", true);\n+    default: gcc_unreachable ();\n+    }\n+}\n   [(set_attr \"type\" \"arith\")\n    (set_attr \"up_c\" \"yes\")\n    (set_attr \"mode\" \"SI\")])\n@@ -793,11 +975,24 @@\n   [(set_attr \"type\" \"arith\")\n    (set_attr \"mode\" \"SI\")])\n \n+(define_insn \"*negsi2_cmp\"\n+  [(set (reg:CC_NZ CC_REGNUM)\n+        (compare:CC_NZ (neg:SI (match_operand:SI 1 \"register_operand\" \"e,d\"))\n+                       (const_int 0)))\n+   (clobber (match_scratch:SI 0 \"=e,d\"))]\n+  \"\"\n+  \"@\n+   neg!    %0, %1\n+   neg.c   %0, %1\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"up_c\" \"yes\")\n+   (set_attr \"mode\" \"SI\")])\n+\n (define_insn \"negsi2_ucc\"\n-  [(set (reg:CC CC_REGNUM)\n-        (compare:CC (neg:SI (match_operand:SI 1 \"register_operand\" \"*e,d\"))\n-                    (const_int 0)))\n-   (set (match_operand:SI 0 \"register_operand\" \"=*e,d\")\n+  [(set (reg:CC_NZ CC_REGNUM)\n+        (compare:CC_NZ (neg:SI (match_operand:SI 1 \"register_operand\" \"e,d\"))\n+                       (const_int 0)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=e,d\")\n         (neg:SI (match_dup 1)))]\n   \"\"\n   \"@\n@@ -817,9 +1012,9 @@\n \n (define_insn \"one_cmplsi2_ucc\"\n   [(set (reg:CC_NZ CC_REGNUM)\n-        (compare:CC_NZ (not:SI (match_operand:SI 1 \"register_operand\" \"*e,d\"))\n+        (compare:CC_NZ (not:SI (match_operand:SI 1 \"register_operand\" \"e,d\"))\n                        (const_int 0)))\n-   (set (match_operand:SI 0 \"register_operand\" \"=*e,d\")\n+   (set (match_operand:SI 0 \"register_operand\" \"=e,d\")\n         (not:SI (match_dup 1)))]\n   \"\"\n   \"@\n@@ -831,12 +1026,13 @@\n \n (define_insn \"one_cmplsi2_cmp\"\n   [(set (reg:CC_NZ CC_REGNUM)\n-        (compare:CC_NZ (not:SI (match_operand:SI 0 \"register_operand\" \"*e,d\"))\n-                       (const_int 0)))]\n+        (compare:CC_NZ (not:SI (match_operand:SI 1 \"register_operand\" \"e,d\"))\n+                       (const_int 0)))\n+   (clobber (match_scratch:SI 0 \"=e,d\"))]\n   \"\"\n   \"@\n-   %[        not!    r1, %0       %]\n-   %[        not.c   r1, %0       %]\"\n+   not!    %0, %1\n+   not.c   %0, %1\"\n   [(set_attr \"type\" \"arith\")\n    (set_attr \"up_c\" \"yes\")\n    (set_attr \"mode\" \"SI\")])\n@@ -877,8 +1073,8 @@\n \n (define_insn \"cmpsi_nz\"\n   [(set (reg:CC_NZ CC_REGNUM)\n-        (compare:CC_NZ (match_operand:SI 0 \"register_operand\" \"d,*e,d\")\n-                       (match_operand:SI 1 \"arith_operand\" \"L,*e,d\")))]\n+        (compare:CC_NZ (match_operand:SI 0 \"register_operand\" \"d,e,d\")\n+                       (match_operand:SI 1 \"arith_operand\" \"L,e,d\")))]\n   \"\"\n   \"@\n    cmpi.c  %0, %c1\n@@ -890,8 +1086,8 @@\n \n (define_insn \"cmpsi_n\"\n   [(set (reg:CC_N CC_REGNUM)\n-        (compare:CC_N (match_operand:SI 0 \"register_operand\" \"d,*e,d\")\n-                      (match_operand:SI 1 \"arith_operand\" \"L,*e,d\")))]\n+        (compare:CC_N (match_operand:SI 0 \"register_operand\" \"d,e,d\")\n+                      (match_operand:SI 1 \"arith_operand\" \"L,e,d\")))]\n   \"\"\n   \"@\n    cmpi.c  %0, %c1\n@@ -901,10 +1097,23 @@\n     (set_attr \"up_c\" \"yes\")\n     (set_attr \"mode\" \"SI\")])\n \n+(define_insn \"*cmpsi_to_addsi\"\n+  [(set (reg:CC_NZ CC_REGNUM)\n+        (compare:CC_NZ (match_operand:SI 1 \"register_operand\" \"0,d\")\n+                       (neg:SI (match_operand:SI 2 \"register_operand\" \"e,d\"))))\n+   (clobber (match_scratch:SI 0 \"=e,d\"))]\n+  \"\"\n+  \"@\n+   add!    %0, %2\n+   add.c   %0, %1, %2\"\n+   [(set_attr \"type\" \"cmp\")\n+    (set_attr \"up_c\" \"yes\")\n+    (set_attr \"mode\" \"SI\")])\n+\n (define_insn \"cmpsi_cc\"\n   [(set (reg:CC CC_REGNUM)\n-        (compare:CC (match_operand:SI 0 \"register_operand\" \"d,*e,d\")\n-                    (match_operand:SI 1 \"arith_operand\" \"L,*e,d\")))]\n+        (compare:CC (match_operand:SI 0 \"register_operand\" \"d,e,d\")\n+                    (match_operand:SI 1 \"arith_operand\" \"L,e,d\")))]\n   \"\"\n   \"@\n    cmpi.c  %0, %c1\n@@ -1078,17 +1287,17 @@\n    (clobber (reg:SI RT_REGNUM))]\n   \"SIBLING_CALL_P (insn)\"\n {\n-  if (!flag_pic) \n-    switch (which_alternative) \n+  if (!flag_pic)\n+    switch (which_alternative)\n       {\n       case 0: return \\\"br%S0   %0\\\";\n       case 1: return \\\"j       %0\\\";\n       default: gcc_unreachable ();\n       }\n   else\n-    switch (which_alternative) \n+    switch (which_alternative)\n       {\n-      case 0: return \\\"mv      r29, %0\\;.cpadd  r29\\;br      r29\\\";\n+      case 0: return \\\"mv      r29, %0\\;br      r29\\\";\n       case 1: return \\\"la      r29, %0\\;br      r29\\\";\n       default: gcc_unreachable ();\n       }\n@@ -1112,17 +1321,17 @@\n    (clobber (reg:SI RT_REGNUM))]\n   \"SIBLING_CALL_P (insn)\"\n {\n-  if (!flag_pic) \n-    switch (which_alternative) \n+  if (!flag_pic)\n+    switch (which_alternative)\n       {\n       case 0: return \\\"br%S1   %1\\\";\n       case 1: return \\\"j       %1\\\";\n       default: gcc_unreachable ();\n       }\n   else\n-    switch (which_alternative) \n+    switch (which_alternative)\n       {\n-      case 0: return \\\"mv      r29, %1\\;.cpadd  r29\\;br      r29\\\";\n+      case 0: return \\\"mv      r29, %1\\;br      r29\\\";\n       case 1: return \\\"la      r29, %1\\;br      r29\\\";\n       default: gcc_unreachable ();\n       }\n@@ -1154,7 +1363,7 @@\n   else\n      switch (which_alternative)\n       {\n-      case 0: return \\\"mv      r29, %0\\;.cpadd  r29\\;brl     r29\\\";\n+      case 0: return \\\"mv      r29, %0\\;brl     r29\\\";\n       case 1: return \\\"la      r29, %0\\;brl     r29\\\";\n       default: gcc_unreachable ();\n       }\n@@ -1163,7 +1372,7 @@\n \n (define_expand \"call_value\"\n   [(parallel [(set (match_operand 0 \"\" \"\")\n-              (call (match_operand 1 \"\" \"\") (match_operand 2 \"\" \"\")))\n+                   (call (match_operand 1 \"\" \"\") (match_operand 2 \"\" \"\")))\n               (use (match_operand 3 \"\" \"\"))])]\n   \"\"\n {\n@@ -1188,7 +1397,7 @@\n   else\n     switch (which_alternative)\n       {\n-      case 0: return \\\"mv      r29, %1\\;.cpadd  r29\\;brl     r29\\\";\n+      case 0: return \\\"mv      r29, %1\\;brl     r29\\\";\n       case 1: return \\\"la      r29, %1\\;brl     r29\\\";\n       default: gcc_unreachable ();\n       }\n@@ -1277,13 +1486,59 @@\n )\n \n (define_insn \"cpload\"\n-  [(unspec:SI [(const_int 1)] 1)]\n+  [(unspec_volatile:SI [(const_int 1)] CPLOAD)]\n   \"flag_pic\"\n   \".cpload r29\"\n )\n \n-(define_insn \"cprestore\"\n-  [(unspec:SI [(match_operand:SI 0 \"\" \"\")] 2)]\n+(define_insn \"cprestore_use_fp\"\n+  [(unspec_volatile:SI [(match_operand:SI 0 \"\" \"\")] CPRESTORE)\n+   (use (reg:SI FP_REGNUM))]\n   \"flag_pic\"\n-  \".cprestore %0\"\n+  \".cprestore r2, %0\"\n )\n+\n+(define_insn \"cprestore_use_sp\"\n+  [(unspec_volatile:SI [(match_operand:SI 0 \"\" \"\")] CPRESTORE)\n+   (use (reg:SI SP_REGNUM))]\n+  \"flag_pic\"\n+  \".cprestore r0, %0\"\n+)\n+\n+(define_expand \"doloop_end\"\n+  [(use (match_operand 0 \"\" \"\"))    ; loop pseudo\n+   (use (match_operand 1 \"\" \"\"))    ; iterations; zero if unknown\n+   (use (match_operand 2 \"\" \"\"))    ; max iterations\n+   (use (match_operand 3 \"\" \"\"))    ; loop level\n+   (use (match_operand 4 \"\" \"\"))]   ; label\n+  \"\"\n+  {\n+    if (INTVAL (operands[3]) > 1)\n+      FAIL;\n+\n+    if (GET_MODE (operands[0]) == SImode)\n+      {\n+        rtx sr0 = gen_rtx_REG (SImode, CN_REGNUM);\n+        emit_jump_insn (gen_doloop_end_si (sr0, operands[4]));\n+      }\n+    else\n+      FAIL;\n+\n+    DONE;\n+  })\n+\n+(define_insn \"doloop_end_si\"\n+  [(set (pc)\n+        (if_then_else\n+         (ne (match_operand:SI 0 \"sr0_operand\" \"\")\n+             (const_int 0))\n+         (label_ref (match_operand 1 \"\" \"\"))\n+         (pc)))\n+   (set (match_dup 0)\n+        (plus:SI (match_dup 0)\n+                 (const_int -1)))\n+   (clobber (reg:CC CC_REGNUM))\n+]\n+  \"\"\n+  \"bcnz %1\"\n+  [(set_attr \"type\" \"branch\")])"}, {"sha": "d8bc89fe95c6f3a527db950212fb8cd2905dd059", "filename": "gcc/config/score/t-score-elf", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99fc25020d47424e0c0b0da370e2e18540b96b73/gcc%2Fconfig%2Fscore%2Ft-score-elf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99fc25020d47424e0c0b0da370e2e18540b96b73/gcc%2Fconfig%2Fscore%2Ft-score-elf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Ft-score-elf?ref=99fc25020d47424e0c0b0da370e2e18540b96b73", "patch": "@@ -35,12 +35,11 @@ dp-bit.c: $(srcdir)/config/fp-bit.c\n # without the $gp register.\n TARGET_LIBGCC2_CFLAGS = -G 0\n \n-MULTILIB_OPTIONS = fPIC mel mscore7\n+MULTILIB_OPTIONS = mmac mel fPIC\n MULTILIB_MATCHES = fPIC=fpic\n \n EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o crti.o crtn.o\n \n LIBGCC = stmp-multilib\n INSTALL_LIBGCC = install-multilib\n \n-"}]}