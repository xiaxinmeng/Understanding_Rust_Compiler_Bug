{"sha": "455786b6c75af58bd20f39f00148c12562d65863", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDU1Nzg2YjZjNzVhZjU4YmQyMGYzOWYwMDE0OGMxMjU2MmQ2NTg2Mw==", "commit": {"author": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2004-09-20T23:10:00Z"}, "committer": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2004-09-20T23:10:00Z"}, "message": "sh.c (sh_expand_prologue): Add a REG_FRAME_RELATED_EXPR note to pretend a direct save from the original...\n\n\t* config/sh/sh.c (sh_expand_prologue): Add a REG_FRAME_RELATED_EXPR\n\tnote to pretend a direct save from the original register when an\n\tintermediate register is used for the save.\n\nFrom-SVN: r87778", "tree": {"sha": "14e37e98582d54b87c80d912cc5641d9faead558", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14e37e98582d54b87c80d912cc5641d9faead558"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/455786b6c75af58bd20f39f00148c12562d65863", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/455786b6c75af58bd20f39f00148c12562d65863", "html_url": "https://github.com/Rust-GCC/gccrs/commit/455786b6c75af58bd20f39f00148c12562d65863", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/455786b6c75af58bd20f39f00148c12562d65863/comments", "author": null, "committer": null, "parents": [{"sha": "3d142be23b9b1ce6a479a9c4ef836a3a79d6a650", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d142be23b9b1ce6a479a9c4ef836a3a79d6a650", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d142be23b9b1ce6a479a9c4ef836a3a79d6a650"}], "stats": {"total": 24, "additions": 24, "deletions": 0}, "files": [{"sha": "135da237ed1b36a9791a8d1ae0d696741c196ea2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455786b6c75af58bd20f39f00148c12562d65863/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455786b6c75af58bd20f39f00148c12562d65863/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=455786b6c75af58bd20f39f00148c12562d65863", "patch": "@@ -1,3 +1,9 @@\n+2004-09-20  Kaz Kojima  <kkojima@gcc.gnu.org>\n+\n+\t* config/sh/sh.c (sh_expand_prologue): Add a REG_FRAME_RELATED_EXPR\n+\tnote to pretend a direct save from the original register when an\n+\tintermediate register is used for the save.\n+\n 2004-09-20  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* tsystem.h (alloca): Provide a default definition."}, {"sha": "0e98ee3ef45ae71a0956e4bbb7555bff8ffa7c20", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455786b6c75af58bd20f39f00148c12562d65863/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455786b6c75af58bd20f39f00148c12562d65863/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=455786b6c75af58bd20f39f00148c12562d65863", "patch": "@@ -5558,6 +5558,7 @@ sh_expand_prologue (void)\n \t  enum machine_mode mode = entry->mode;\n \t  int reg = entry->reg;\n \t  rtx reg_rtx, mem_rtx, pre_dec = NULL_RTX;\n+\t  rtx orig_reg_rtx;\n \n \t  offset = entry->offset;\n \n@@ -5647,6 +5648,7 @@ sh_expand_prologue (void)\n \t    abort ();\n \n \taddr_ok:\n+\t  orig_reg_rtx = reg_rtx;\n \t  if (TARGET_REGISTER_P (reg)\n \t      || ((reg == PR_REG || SPECIAL_REGISTER_P (reg))\n \t\t  && mem_rtx != pre_dec))\n@@ -5674,6 +5676,22 @@ sh_expand_prologue (void)\n \t    /* Mark as interesting for dwarf cfi generator */\n \t    insn = emit_move_insn (mem_rtx, reg_rtx);\n \t    RTX_FRAME_RELATED_P (insn) = 1;\n+\t    /* If we use an intermediate register for the save, we can't\n+\t       describe this exactly in cfi as a copy of the to-be-saved\n+\t       register into the temporary register and then the temporary\n+\t       register on the stack, because the temporary register can\n+\t       have a different natural size than the to-be-saved register.\n+\t       Thus, we gloss over the intermediate copy and pretend we do\n+\t       a direct save from the to-be-saved register.  */\n+\t    if (REGNO (reg_rtx) != reg)\n+\t      {\n+\t\trtx set, note_rtx;\n+\n+\t\tset = gen_rtx_SET (VOIDmode, mem_rtx, orig_reg_rtx);\n+\t\tnote_rtx = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR, set,\n+\t\t\t\t\t      REG_NOTES (insn));\n+\t\tREG_NOTES (insn) = note_rtx;\n+\t      }\n \n \t    if (TARGET_SHCOMPACT && (offset_in_r0 != -1))\n \t      {"}]}