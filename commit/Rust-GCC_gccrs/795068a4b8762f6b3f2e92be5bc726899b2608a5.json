{"sha": "795068a4b8762f6b3f2e92be5bc726899b2608a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzk1MDY4YTRiODc2MmY2YjNmMmU5MmJlNWJjNzI2ODk5YjI2MDhhNQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-05-19T23:57:13Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-05-19T23:57:13Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1021", "tree": {"sha": "80fe2d6c1bdc59aab18f6cb2c8786839ffe0e9e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/80fe2d6c1bdc59aab18f6cb2c8786839ffe0e9e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/795068a4b8762f6b3f2e92be5bc726899b2608a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/795068a4b8762f6b3f2e92be5bc726899b2608a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/795068a4b8762f6b3f2e92be5bc726899b2608a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/795068a4b8762f6b3f2e92be5bc726899b2608a5/comments", "author": null, "committer": null, "parents": [{"sha": "c06de95d2e44fbd569ba2469aea0e2420cbdfcd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c06de95d2e44fbd569ba2469aea0e2420cbdfcd4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c06de95d2e44fbd569ba2469aea0e2420cbdfcd4"}], "stats": {"total": 830, "additions": 682, "deletions": 148}, "files": [{"sha": "a875dba5e3c2a828dcc81d3597802af22d4b6be7", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 423, "deletions": 146, "changes": 569, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/795068a4b8762f6b3f2e92be5bc726899b2608a5/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/795068a4b8762f6b3f2e92be5bc726899b2608a5/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=795068a4b8762f6b3f2e92be5bc726899b2608a5", "patch": "@@ -955,35 +955,137 @@ singlemove_string (operands)\n   return \"mov %1,%0\";\n }\n \f\n+/* Return non-zero if it is OK to assume that the given memory operand is\n+   aligned at least to a 8-byte boundary.  This should only be called\n+   for memory accesses whose size is 8 bytes or larger.  */\n+\n+static int\n+mem_aligned_8 (mem)\n+     register rtx mem;\n+{\n+  register rtx addr;\n+  register rtx base;\n+  register rtx offset;\n+\n+  if (GET_CODE (mem) != MEM)\n+    abort ();\t/* It's gotta be a MEM! */\n+\n+  addr = XEXP (mem, 0);\n+\n+#if 1\n+  /* Now that all misaligned double parms are copied on function entry,\n+     we can assume any 64-bit object is 64-bit aligned.  */\n+\n+  /* See what register we use in the address.  */\n+  base = 0;\n+  if (GET_CODE (addr) == PLUS)\n+    {\n+      if (GET_CODE (XEXP (addr, 0)) == REG\n+\t  && GET_CODE (XEXP (addr, 1)) == CONST_INT)\n+\t{\n+\t  base = XEXP (addr, 0);\n+\t  offset = XEXP (addr, 1);\n+\t}\n+    }\n+  else if (GET_CODE (addr) == REG)\n+    {\n+      base = addr;\n+      offset = const0_rtx;\n+    }\n+\n+  /* If it's the stack or frame pointer, check offset alignment.\n+     We can have improper aligment in the function entry code.  */\n+  if (base\n+      && (REGNO (base) == FRAME_POINTER_REGNUM\n+\t  || REGNO (base) == STACK_POINTER_REGNUM))\n+    {\n+      if ((INTVAL (offset) & 0x7) == 0)\n+\treturn 1;\n+    }\n+  else\n+    /* Anything else, we know is properly aligned.  */\n+    return 1;\n+#else\n+  /* If the operand is known to have been allocated in static storage, then\n+     it must be aligned.  */\n+\n+  if (CONSTANT_P (addr) || GET_CODE (addr) == LO_SUM)\n+    return 1;\n+\n+  base = 0;\n+  if (GET_CODE (addr) == PLUS)\n+    {\n+      if (GET_CODE (XEXP (addr, 0)) == REG\n+          && GET_CODE (XEXP (addr, 1)) == CONST_INT)\n+        {\n+          base = XEXP (addr, 0);\n+          offset = XEXP (addr, 1);\n+        }\n+    }\n+  else if (GET_CODE (addr) == REG)\n+    {\n+      base = addr;\n+      offset = const0_rtx;\n+    }\n+\n+  /* Trust round enough offsets from the stack or frame pointer.\n+     If TARGET_HOPE_ALIGN, trust round enough offset from any register.\n+     If it is obviously unaligned, don't ever return true.  */\n+  if (base\n+      && (REGNO (base) == FRAME_POINTER_REGNUM\n+          || REGNO (base) == STACK_POINTER_REGNUM\n+\t  || TARGET_HOPE_ALIGN))\n+    {\n+      if ((INTVAL (offset) & 0x7) == 0)\n+\treturn 1;\n+    }\n+  /* Otherwise, we can assume that an access is aligned if it is to an\n+     aggregate.  Also, if TARGET_HOPE_ALIGN, then assume everything that isn't\n+     obviously unaligned is aligned.  */\n+  else if (MEM_IN_STRUCT_P (mem) || TARGET_HOPE_ALIGN)\n+    return 1;\n+#endif\n+\n+  /* An obviously unaligned address.  */\n+  return 0;\n+}\n+\n+enum optype { REGOP, OFFSOP, MEMOP, PUSHOP, POPOP, CNSTOP, RNDOP };\n+\n /* Output assembler code to perform a doubleword move insn\n-   with operands OPERANDS.  */\n+   with operands OPERANDS.  This is very similar to the following\n+   output_move_quad function.  */\n \n char *\n output_move_double (operands)\n      rtx *operands;\n {\n-  enum { REGOP, OFFSOP, MEMOP, PUSHOP, POPOP, CNSTOP, RNDOP } optype0, optype1;\n+  register rtx op0 = operands[0];\n+  register rtx op1 = operands[1];\n+  register enum optype optype0;\n+  register enum optype optype1;\n   rtx latehalf[2];\n-  rtx addreg0 = 0, addreg1 = 0;\n+  rtx addreg0 = 0;\n+  rtx addreg1 = 0;\n \n   /* First classify both operands.  */\n \n-  if (REG_P (operands[0]))\n+  if (REG_P (op0))\n     optype0 = REGOP;\n-  else if (offsettable_memref_p (operands[0]))\n+  else if (offsettable_memref_p (op0))\n     optype0 = OFFSOP;\n-  else if (GET_CODE (operands[0]) == MEM)\n+  else if (GET_CODE (op0) == MEM)\n     optype0 = MEMOP;\n   else\n     optype0 = RNDOP;\n \n-  if (REG_P (operands[1]))\n+  if (REG_P (op1))\n     optype1 = REGOP;\n-  else if (CONSTANT_P (operands[1]))\n+  else if (CONSTANT_P (op1))\n     optype1 = CNSTOP;\n-  else if (offsettable_memref_p (operands[1]))\n+  else if (offsettable_memref_p (op1))\n     optype1 = OFFSOP;\n-  else if (GET_CODE (operands[1]) == MEM)\n+  else if (GET_CODE (op1) == MEM)\n     optype1 = MEMOP;\n   else\n     optype1 = RNDOP;\n@@ -992,180 +1094,76 @@ output_move_double (operands)\n      supposed to allow to happen.  Abort if we get one,\n      because generating code for these cases is painful.  */\n \n-  if (optype0 == RNDOP || optype1 == RNDOP)\n+  if (optype0 == RNDOP || optype1 == RNDOP\n+      || (optype0 == MEM && optype1 == MEM))\n     abort ();\n \n   /* If an operand is an unoffsettable memory ref, find a register\n      we can increment temporarily to make it refer to the second word.  */\n \n   if (optype0 == MEMOP)\n-    addreg0 = find_addr_reg (XEXP (operands[0], 0));\n+    addreg0 = find_addr_reg (XEXP (op0, 0));\n \n   if (optype1 == MEMOP)\n-    addreg1 = find_addr_reg (XEXP (operands[1], 0));\n+    addreg1 = find_addr_reg (XEXP (op1, 0));\n \n   /* Ok, we can do one word at a time.\n-     Normally we do the low-numbered word first,\n-     but if either operand is autodecrementing then we\n-     do the high-numbered word first.\n-\n-     In either case, set up in LATEHALF the operands to use for the\n+     Set up in LATEHALF the operands to use for the\n      high-numbered (least significant) word and in some cases alter the\n      operands in OPERANDS to be suitable for the low-numbered word.  */\n \n   if (optype0 == REGOP)\n-    latehalf[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+    latehalf[0] = gen_rtx (REG, SImode, REGNO (op0) + 1);\n   else if (optype0 == OFFSOP)\n-    latehalf[0] = adj_offsettable_operand (operands[0], 4);\n+    latehalf[0] = adj_offsettable_operand (op0, 4);\n   else\n-    latehalf[0] = operands[0];\n+    latehalf[0] = op0;\n \n   if (optype1 == REGOP)\n-    latehalf[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+    latehalf[1] = gen_rtx (REG, SImode, REGNO (op1) + 1);\n   else if (optype1 == OFFSOP)\n-    latehalf[1] = adj_offsettable_operand (operands[1], 4);\n+    latehalf[1] = adj_offsettable_operand (op1, 4);\n   else if (optype1 == CNSTOP)\n-    split_double (operands[1], &operands[1], &latehalf[1]);\n+    split_double (op1, &operands[1], &latehalf[1]);\n   else\n-    latehalf[1] = operands[1];\n-\n-  /* If the first move would clobber the source of the second one,\n-     do them in the other order.\n-\n-     RMS says \"This happens only for registers;\n-     such overlap can't happen in memory unless the user explicitly\n-     sets it up, and that is an undefined circumstance.\"\n+    latehalf[1] = op1;\n \n-     but it happens on the sparc when loading parameter registers,\n-     so I am going to define that circumstance, and make it work\n-     as expected.  */\n-\n-  /* Easy case: try moving both words at once.  */\n-  /* First check for moving between an even/odd register pair\n-     and a memory location.  */\n+  /* Easy case: try moving both words at once.  Check for moving between\n+     an even/odd register pair and a memory location.  */\n   if ((optype0 == REGOP && optype1 != REGOP && optype1 != CNSTOP\n-       && (REGNO (operands[0]) & 1) == 0)\n+       && (REGNO (op0) & 1) == 0)\n       || (optype0 != REGOP && optype0 != CNSTOP && optype1 == REGOP\n-\t  && (REGNO (operands[1]) & 1) == 0))\n+\t  && (REGNO (op1) & 1) == 0))\n     {\n-      /* Now that all misaligned double parms are copied\n-\t on function entry, we can assume any 64-bit object\n-\t is 64-bit aligned.  */\n-#if 1\n-      rtx addr;\n-      rtx base, offset;\n+      register rtx mem;\n \n       if (optype0 == REGOP)\n-\taddr = operands[1];\n+\tmem = op1;\n       else\n-\taddr = operands[0];\n+\tmem = op0;\n \n-      /* See what register we use in the address.  */\n-      base = 0;\n-      if (GET_CODE (XEXP (addr, 0)) == PLUS)\n-\t{\n-\t  rtx temp = XEXP (addr, 0);\n-\t  if (GET_CODE (XEXP (temp, 0)) == REG\n-\t      && GET_CODE (XEXP (temp, 1)) == CONST_INT)\n-\t    base = XEXP (temp, 0), offset = XEXP (temp, 1);\n-\t}\n-      else if (GET_CODE (XEXP (addr, 0)) == REG)\n-\tbase = XEXP (addr, 0), offset = const0_rtx;\n-\n-      /* If it's the  stack or frame pointer, check offset alignment.\n-\t We can have improper aligment in the function entry code.  */\n-      if (base\n-\t  && (REGNO (base) == FRAME_POINTER_REGNUM\n-\t      || REGNO (base) == STACK_POINTER_REGNUM))\n-\t{\n-\t  if ((INTVAL (offset) & 0x7) == 0)\n-\t    return (addr == operands[1] ? \"ldd %1,%0\" : \"std %1,%0\");\n-\t}\n-      else\n-\t/* Anything else, we know is properly aligned.  */\n-\treturn (addr == operands[1] ? \"ldd %1,%0\" : \"std %1,%0\");\n-#else\n-      /* This old code is preserved in case we ever need\n-\t it for Fortran.  It won't be complete right;\n-\t In Fortran, doubles can be just 32-bit aligned\n-\t even in global variables and arrays.  */\n-      rtx addr;\n-      rtx base, offset;\n-\n-      if (optype0 == REGOP)\n-\taddr = operands[1];\n-      else\n-\taddr = operands[0];\n-\n-      /* Now see if we can trust the address to be 8-byte aligned.\n-\t Trust double-precision floats in global variables.  */\n-\n-      if (GET_CODE (XEXP (addr, 0)) == LO_SUM && GET_MODE (addr) == DFmode)\n-\treturn (addr == operands[1] ? \"ldd %1,%0\" : \"std %1,%0\");\n-\n-      base = 0;\n-      if (GET_CODE (XEXP (addr, 0)) == PLUS)\n-\t{\n-\t  rtx temp = XEXP (addr, 0);\n-\t  if (GET_CODE (XEXP (temp, 0)) == REG\n-\t      && GET_CODE (XEXP (temp, 1)) == CONST_INT)\n-\t    base = XEXP (temp, 0), offset = XEXP (temp, 1);\n-\t}\n-      else if (GET_CODE (XEXP (addr, 0)) == REG)\n-\tbase = XEXP (addr, 0), offset = const0_rtx;\n-\n-      /* Trust round enough offsets from the stack or frame pointer.\n-\t If TARGET_HOPE_ALIGN, trust round enough offset from any register\n-\t for DFmode loads.  If it is obviously unaligned, don't ever\n-\t generate ldd or std.  */\n-      if (base\n-\t  && (REGNO (base) == FRAME_POINTER_REGNUM\n-\t      || REGNO (base) == STACK_POINTER_REGNUM\n-\t      || (TARGET_HOPE_ALIGN && GET_MODE (addr) == DFmode)))\n-\t{\n-\t  if ((INTVAL (offset) & 0x7) == 0)\n-\t    return (addr == operands[1] ? \"ldd %1,%0\" : \"std %1,%0\");\n-\t}\n-      /* We know structs not on the stack are properly aligned.  Since a\n-\t double asks for 8-byte alignment, we know it must have got that\n-\t if it is in a struct.  But a DImode need not be 8-byte aligned,\n-\t because it could be a struct containing two ints or pointers.\n-\t Hence, a constant DFmode address will always be 8-byte aligned.\n-\t Any DFmode access inside a struct will always be aligned.\n-\t If TARGET_HOPE_ALIGN, then assume all doubles are aligned even if this\n-\t is not a constant address.  */\n-      else if (GET_MODE (addr) == DFmode\n-\t       && (CONSTANT_P (XEXP (addr, 0))\n-\t\t   || MEM_IN_STRUCT_P (addr)\n-\t\t   || TARGET_HOPE_ALIGN))\n-\treturn (addr == operands[1] ? \"ldd %1,%0\" : \"std %1,%0\");\n-#endif /* 0 */\n+      if (mem_aligned_8 (mem))\n+\treturn (mem == op1 ? \"ldd %1,%0\" : \"std %1,%0\");\n     }\n \n+  /* If the first move would clobber the source of the second one,\n+     do them in the other order.  */\n+\n+  /* Overlapping registers.  */\n   if (optype0 == REGOP && optype1 == REGOP\n-      && REGNO (operands[0]) == REGNO (latehalf[1]))\n+      && REGNO (op0) == REGNO (latehalf[1]))\n     {\n-      /* Make any unoffsettable addresses point at high-numbered word.  */\n-      if (addreg0)\n-\toutput_asm_insn (\"add %0,0x4,%0\", &addreg0);\n-      if (addreg1)\n-\toutput_asm_insn (\"add %0,0x4,%0\", &addreg1);\n-\n       /* Do that word.  */\n       output_asm_insn (singlemove_string (latehalf), latehalf);\n-\n-      /* Undo the adds we just did.  */\n-      if (addreg0)\n-\toutput_asm_insn (\"add %0,-0x4,%0\", &addreg0);\n-      if (addreg1)\n-\toutput_asm_insn (\"add %0,-0x4,%0\", &addreg1);\n-\n       /* Do low-numbered word.  */\n       return singlemove_string (operands);\n     }\n+  /* Loading into a register which overlaps a register used in the address.  */\n   else if (optype0 == REGOP && optype1 != REGOP\n-\t   && reg_overlap_mentioned_p (operands[0], operands[1]))\n+\t   && reg_overlap_mentioned_p (op0, op1))\n     {\n+      /* ??? This fails if the address is a double register address, each\n+\t of which is clobbered by operand 0.  */\n       /* Do the late half first.  */\n       output_asm_insn (singlemove_string (latehalf), latehalf);\n       /* Then clobber.  */\n@@ -1193,8 +1191,217 @@ output_move_double (operands)\n \n   return \"\";\n }\n+\n+/* Output assembler code to perform a quadword move insn\n+   with operands OPERANDS.  This is very similar to the preceeding\n+   output_move_double function.  */\n+\n+char *\n+output_move_quad (operands)\n+     rtx *operands;\n+{\n+  register rtx op0 = operands[0];\n+  register rtx op1 = operands[1];\n+  register enum optype optype0;\n+  register enum optype optype1;\n+  rtx wordpart[4][2];\n+  rtx addreg0 = 0;\n+  rtx addreg1 = 0;\n+\n+  /* First classify both operands.  */\n+\n+  if (REG_P (op0))\n+    optype0 = REGOP;\n+  else if (offsettable_memref_p (op0))\n+    optype0 = OFFSOP;\n+  else if (GET_CODE (op0) == MEM)\n+    optype0 = MEMOP;\n+  else\n+    optype0 = RNDOP;\n+\n+  if (REG_P (op1))\n+    optype1 = REGOP;\n+  else if (CONSTANT_P (op1))\n+    optype1 = CNSTOP;\n+  else if (offsettable_memref_p (op1))\n+    optype1 = OFFSOP;\n+  else if (GET_CODE (op1) == MEM)\n+    optype1 = MEMOP;\n+  else\n+    optype1 = RNDOP;\n+\n+  /* Check for the cases that the operand constraints are not\n+     supposed to allow to happen.  Abort if we get one,\n+     because generating code for these cases is painful.  */\n+\n+  if (optype0 == RNDOP || optype1 == RNDOP\n+      || (optype0 == MEM && optype1 == MEM))\n+    abort ();\n+\n+  /* If an operand is an unoffsettable memory ref, find a register\n+     we can increment temporarily to make it refer to the later words.  */\n+\n+  if (optype0 == MEMOP)\n+    addreg0 = find_addr_reg (XEXP (op0, 0));\n+\n+  if (optype1 == MEMOP)\n+    addreg1 = find_addr_reg (XEXP (op1, 0));\n+\n+  /* Ok, we can do one word at a time.\n+     Set up in wordpart the operands to use for each word of the arguments.  */\n+\n+  if (optype0 == REGOP)\n+    {\n+      wordpart[0][0] = gen_rtx (REG, SImode, REGNO (op0) + 0);\n+      wordpart[1][0] = gen_rtx (REG, SImode, REGNO (op0) + 1);\n+      wordpart[2][0] = gen_rtx (REG, SImode, REGNO (op0) + 2);\n+      wordpart[3][0] = gen_rtx (REG, SImode, REGNO (op0) + 3);\n+    }\n+  else if (optype0 == OFFSOP)\n+    {\n+      wordpart[0][0] = adj_offsettable_operand (op0, 0);\n+      wordpart[1][0] = adj_offsettable_operand (op0, 4);\n+      wordpart[2][0] = adj_offsettable_operand (op0, 8);\n+      wordpart[3][0] = adj_offsettable_operand (op0, 12);\n+    }\n+  else\n+    {\n+      wordpart[0][0] = op0;\n+      wordpart[1][0] = op0;\n+      wordpart[2][0] = op0;\n+      wordpart[3][0] = op0;\n+    }\n+\n+  if (optype1 == REGOP)\n+    {\n+      wordpart[0][1] = gen_rtx (REG, SImode, REGNO (op1) + 0);\n+      wordpart[1][1] = gen_rtx (REG, SImode, REGNO (op1) + 1);\n+      wordpart[2][1] = gen_rtx (REG, SImode, REGNO (op1) + 2);\n+      wordpart[3][1] = gen_rtx (REG, SImode, REGNO (op1) + 3);\n+    }\n+  else if (optype1 == OFFSOP)\n+    {\n+      wordpart[0][1] = adj_offsettable_operand (op1, 0);\n+      wordpart[1][1] = adj_offsettable_operand (op1, 4);\n+      wordpart[2][1] = adj_offsettable_operand (op1, 8);\n+      wordpart[3][1] = adj_offsettable_operand (op1, 12);\n+    }\n+  else if (optype1 == CNSTOP)\n+    {\n+      /* This case isn't implemented yet, because there is no internal\n+\t representation for quad-word constants, and there is no split_quad\n+\t function.  */\n+#if 0\n+      split_quad (op1, &wordpart[0][1], &wordpart[1][1],\n+\t\t  &wordpart[2][1], &wordpart[3][1]);\n+#else\n+      abort ();\n+#endif\n+    }\n+  else\n+    {\n+      wordpart[0][1] = op1;\n+      wordpart[1][1] = op1;\n+      wordpart[2][1] = op1;\n+      wordpart[3][1] = op1;\n+    }\n+\n+  /* Easy case: try moving the quad as two pairs.  Check for moving between\n+     an even/odd register pair and a memory location.  */\n+  /* ??? Should also handle the case of non-offsettable addresses here.\n+     We can at least do the first pair as a ldd/std, and then do the third\n+     and fourth words individually.  */\n+  if ((optype0 == REGOP && optype1 == OFFSOP && (REGNO (op0) & 1) == 0)\n+      || (optype0 == OFFSOP && optype1 == REGOP && (REGNO (op1) & 1) == 0))\n+    {\n+      rtx mem;\n+\n+      if (optype0 == REGOP)\n+\tmem = op1;\n+      else\n+\tmem = op0;\n+\n+      if (mem_aligned_8 (mem))\n+\t{\n+\t  operands[2] = adj_offsettable_operand (mem, 8);\n+\t  if (mem == op1)\n+\t    return \"ldd %1,%0;ldd %2,%S0\";\n+\t  else\n+\t    return \"std %1,%0;std %S1,%2\";\n+\t}\n+    }\n+\n+  /* If the first move would clobber the source of the second one,\n+     do them in the other order.  */\n+\n+  /* Overlapping registers.  */\n+  if (optype0 == REGOP && optype1 == REGOP\n+      && (REGNO (op0) == REGNO (wordpart[1][3])\n+\t  || REGNO (op0) == REGNO (wordpart[1][2])\n+\t  || REGNO (op0) == REGNO (wordpart[1][1])))\n+    {\n+      /* Do fourth word.  */\n+      output_asm_insn (singlemove_string (wordpart[3]), wordpart[3]);\n+      /* Do the third word.  */\n+      output_asm_insn (singlemove_string (wordpart[2]), wordpart[2]);\n+      /* Do the second word.  */\n+      output_asm_insn (singlemove_string (wordpart[1]), wordpart[1]);\n+      /* Do lowest-numbered word.  */\n+      return singlemove_string (wordpart[0]);\n+    }\n+  /* Loading into a register which overlaps a register used in the address.  */\n+  if (optype0 == REGOP && optype1 != REGOP\n+      && reg_overlap_mentioned_p (op0, op1))\n+    {\n+      /* ??? Not implemented yet.  This is a bit complicated, because we\n+\t must load which ever part overlaps the address last.  If the address\n+\t is a double-reg address, then there are two parts which need to\n+\t be done last, which is impossible.  We would need a scratch register\n+\t in that case.  */\n+      abort ();\n+    }\n+\n+  /* Normal case: move the four words in lowest to higest address order.  */\n+\n+  output_asm_insn (singlemove_string (wordpart[0]), wordpart[0]);\n+\n+  /* Make any unoffsettable addresses point at the second word.  */\n+  if (addreg0)\n+    output_asm_insn (\"add %0,0x4,%0\", &addreg0);\n+  if (addreg1)\n+    output_asm_insn (\"add %0,0x4,%0\", &addreg1);\n+\n+  /* Do the second word.  */\n+  output_asm_insn (singlemove_string (wordpart[1]), wordpart[1]);\n+\n+  /* Make any unoffsettable addresses point at the third word.  */\n+  if (addreg0)\n+    output_asm_insn (\"add %0,0x4,%0\", &addreg0);\n+  if (addreg1)\n+    output_asm_insn (\"add %0,0x4,%0\", &addreg1);\n+\n+  /* Do the third word.  */\n+  output_asm_insn (singlemove_string (wordpart[2]), wordpart[2]);\n+\n+  /* Make any unoffsettable addresses point at the fourth word.  */\n+  if (addreg0)\n+    output_asm_insn (\"add %0,0x4,%0\", &addreg0);\n+  if (addreg1)\n+    output_asm_insn (\"add %0,0x4,%0\", &addreg1);\n+\n+  /* Do the fourth word.  */\n+  output_asm_insn (singlemove_string (wordpart[3]), wordpart[3]);\n+\n+  /* Undo the adds we just did.  */\n+  if (addreg0)\n+    output_asm_insn (\"add %0,-0xc,%0\", &addreg0);\n+  if (addreg1)\n+    output_asm_insn (\"add %0,-0xc,%0\", &addreg1);\n+\n+  return \"\";\n+}\n \f\n-/* Output assembler code to perform a doubleword move insn with perands\n+/* Output assembler code to perform a doubleword move insn with operands\n    OPERANDS, one of which must be a floating point register.  */\n \n char *\n@@ -1231,6 +1438,47 @@ output_fp_move_double (operands)\n     }\n   else abort ();\n }\n+\n+/* Output assembler code to perform a quadword move insn with operands\n+   OPERANDS, one of which must be a floating point register.  */\n+\n+char *\n+output_fp_move_quad (operands)\n+     rtx *operands;\n+{\n+  register rtx op0 = operands[0];\n+  register rtx op1 = operands[1];\n+  register rtx addr;\n+\n+  if (FP_REG_P (op0))\n+    {\n+      if (FP_REG_P (op1))\n+\treturn \"fmovs %1,%0\\n\\tfmovs %R1,%R0\\n\\tfmovs %S1,%S0\\n\\tfmovs %T1,%T0\";\n+      if (GET_CODE (op1) == REG)\n+\t{\n+\t  if ((REGNO (op1) & 1) == 0)\n+\t    return \"std %1,[%@-8]\\n\\tldd [%@-8],%0\\n\\tstd %S1,[%@-8]\\n\\tldd [%@-8],%S0\";\n+\t  else\n+\t    return \"st %R1,[%@-4]\\n\\tst %1,[%@-8]\\n\\tldd [%@-8],%0\\n\\tst %T1,[%@-4]\\n\\tst %S1,[%@-8]\\n\\tldd [%@-8],%S0\";\n+\t}\n+      else\n+\treturn output_move_quad (operands);\n+    }\n+  else if (FP_REG_P (op1))\n+    {\n+      if (GET_CODE (op0) == REG)\n+\t{\n+\t  if ((REGNO (op0) & 1) == 0)\n+\t    return \"std %1,[%@-8]\\n\\tldd [%@-8],%0\\n\\tstd %S1,[%@-8]\\n\\tldd [%@-8],%S0\";\n+\t  else\n+\t    return \"std %S1,[%@-8]\\n\\tld [%@-4],%T0\\n\\tld [%@-8],%S0\\n\\tstd %1,[%@-8]\\n\\tld [%@-4],%R0\\n\\tld [%@-8],%0\";\n+\t}\n+      else\n+\treturn output_move_quad (operands);\n+    }\n+  else\n+    abort ();\n+}\n \f\n /* Return a REG that occurs in ADDR with coefficient 1.\n    ADDR can be effectively incremented by incrementing REG.  */\n@@ -2140,6 +2388,8 @@ output_cbranch (op, label, reversed, annul, noop)\n   return string;\n }\n \n+/* Output assembler code to return from a function.  */\n+\n char *\n output_return (operands)\n      rtx *operands;\n@@ -2199,6 +2449,8 @@ output_return (operands)\n     }\n }\n \n+/* Output assembler code for a SImode to SFmode conversion.  */\n+\n char *\n output_floatsisf2 (operands)\n      rtx *operands;\n@@ -2210,6 +2462,8 @@ output_floatsisf2 (operands)\n   return \"st %r1,[%%fp-4]\\n\\tld [%%fp-4],%0\\n\\tfitos %0,%0\";\n }\n \n+/* Output assembler code for a SImode to DFmode conversion.  */\n+\n char *\n output_floatsidf2 (operands)\n      rtx *operands;\n@@ -2220,6 +2474,19 @@ output_floatsidf2 (operands)\n     return \"fitod %1,%0\";\n   return \"st %r1,[%%fp-4]\\n\\tld [%%fp-4],%0\\n\\tfitod %0,%0\";\n }\n+\n+/* Output assembler code for a SImode to TFmode conversion.  */\n+\n+char *\n+output_floatsitf2 (operands)\n+     rtx *operands;\n+{\n+  if (GET_CODE (operands[1]) == MEM)\n+    return \"ld %1,%0\\n\\tfitoq %0,%0\";\n+  else if (FP_REG_P (operands[1]))\n+    return \"fitoq %1,%0\";\n+  return \"st %r1,[%%fp-4]\\n\\tld [%%fp-4],%0\\n\\tfitoq %0,%0\";\n+}\n \f\n /* Leaf functions and non-leaf functions have different needs.  */\n \n@@ -2436,10 +2703,20 @@ print_operand (file, x, code)\n       fputs (frame_base_name, file);\n       return;\n     case 'R':\n-      /* Print out the second register name of a register pair.\n+      /* Print out the second register name of a register pair or quad.\n \t I.e., R (%o0) => %o1.  */\n       fputs (reg_names[REGNO (x)+1], file);\n       return;\n+    case 'S':\n+      /* Print out the third register name of a register quad.\n+\t I.e., S (%o0) => %o2.  */\n+      fputs (reg_names[REGNO (x)+2], file);\n+      return;\n+    case 'T':\n+      /* Print out the fourth register name of a register quad.\n+\t I.e., T (%o0) => %o3.  */\n+      fputs (reg_names[REGNO (x)+3], file);\n+      return;\n     case 'm':\n       /* Print the operand's address only.  */\n       output_address (XEXP (x, 0));"}, {"sha": "00f58583d6b0368131c105e48ae0852ab0afe812", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/795068a4b8762f6b3f2e92be5bc726899b2608a5/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/795068a4b8762f6b3f2e92be5bc726899b2608a5/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=795068a4b8762f6b3f2e92be5bc726899b2608a5", "patch": "@@ -1655,13 +1655,16 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n extern char *singlemove_string ();\n extern char *output_move_double ();\n+extern char *output_move_quad ();\n extern char *output_fp_move_double ();\n+extern char *output_fp_move_quad ();\n extern char *output_block_move ();\n extern char *output_scc_insn ();\n extern char *output_cbranch ();\n extern char *output_return ();\n extern char *output_floatsisf2 ();\n extern char *output_floatsidf2 ();\n+extern char *output_floatsitf2 ();\n \n /* Defined in flags.h, but insn-emit.c does not include flags.h.  */\n "}, {"sha": "4f8dc221383b1dbe2d147da08ca968fffdc20e18", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 256, "deletions": 2, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/795068a4b8762f6b3f2e92be5bc726899b2608a5/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/795068a4b8762f6b3f2e92be5bc726899b2608a5/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=795068a4b8762f6b3f2e92be5bc726899b2608a5", "patch": "@@ -196,6 +196,18 @@\n   DONE;\n }\")\n \n+(define_expand \"cmptf\"\n+  [(set (reg:CCFP 0)\n+\t(compare:CCFP (match_operand:TF 0 \"register_operand\" \"\")\n+\t\t      (match_operand:TF 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  sparc_compare_op0 = operands[0];\n+  sparc_compare_op1 = operands[1];\n+  DONE;\n+}\")\n+\n ;; Next come the scc insns.  For seq, sne, sgeu, and sltu, we can do this\n ;; without jumps using the addx/subx instructions.  For the rest, we do\n ;; branches.  Seq_special and sne_special clobber the CC reg, because they\n@@ -370,6 +382,14 @@\n   \"fcmpes %0,%1\"\n   [(set_attr \"type\" \"fpcmp\")])\n \n+(define_insn \"\"\n+  [(set (reg:CCFP 0)\n+\t(compare:CCFP (match_operand:TF 0 \"register_operand\" \"f\")\n+\t\t      (match_operand:TF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fcmpeq %0,%1\"\n+  [(set_attr \"type\" \"fpcmp\")])\n+\n ;; The SEQ and SNE patterns are special because they can be done\n ;; without any branching and do not involve a COMPARE.\n \n@@ -1003,6 +1023,71 @@\n \f\n ;; Floating point move insns\n \n+;; This pattern forces (set (reg:TF ...) (const_double ...))\n+;; to be reloaded by putting the constant into memory.\n+;; It must come before the more general movtf pattern.\n+(define_insn \"\"\n+  [(set (match_operand:TF 0 \"general_operand\" \"=?r,f,o\")\n+\t(match_operand:TF 1 \"\" \"?E,m,G\"))]\n+  \"GET_CODE (operands[1]) == CONST_DOUBLE\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return output_move_quad (operands);\n+    case 1:\n+      return output_fp_move_quad (operands);\n+    case 2:\n+      operands[1] = adj_offsettable_operand (operands[0], 4);\n+      operands[2] = adj_offsettable_operand (operands[0], 8);\n+      operands[3] = adj_offsettable_operand (operands[0], 12);\n+      return \\\"st %%g0,%0\\;st %%g0,%1\\;st %%g0,%2\\;st %%g0,%3\\\";\n+    }\n+}\"\n+  [(set_attr \"type\" \"load,fpload,store\")\n+   (set_attr \"length\" \"5,5,5\")])\n+\n+(define_expand \"movtf\"\n+  [(set (match_operand:TF 0 \"general_operand\" \"\")\n+\t(match_operand:TF 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (emit_move_sequence (operands, TFmode, 0))\n+    DONE;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:TF 0 \"reg_or_nonsymb_mem_operand\" \"=f,r,Q,Q,f,&r,?f,?r\")\n+\t(match_operand:TF 1 \"reg_or_nonsymb_mem_operand\" \"f,r,f,r,Q,Q,r,f\"))]\n+  \"register_operand (operands[0], TFmode)\n+   || register_operand (operands[1], TFmode)\"\n+  \"*\n+{\n+  if (FP_REG_P (operands[0]) || FP_REG_P (operands[1]))\n+    return output_fp_move_quad (operands);\n+  return output_move_quad (operands);\n+}\"\n+  [(set_attr \"type\" \"fp,move,fpstore,store,fpload,load,multi,multi\")\n+   (set_attr \"length\" \"4,4,5,5,5,5,5,5\")])\n+\n+(define_insn \"\"\n+  [(set (mem:TF (match_operand:SI 0 \"symbolic_operand\" \"i,i\"))\n+\t(match_operand:TF 1 \"reg_or_0_operand\" \"rf,G\"))\n+   (clobber (match_scratch:SI 2 \"=&r,&r\"))]\n+  \"\"\n+  \"*\n+{\n+  output_asm_insn (\\\"sethi %%hi(%a0),%2\\\", operands);\n+  if (which_alternative == 0)\n+    return \\\"std %1,[%2+%%lo(%a0)]\\;std %S1,[%2+%%lo(%a0+8)]\\\";\n+  else\n+    return \\\"st %%g0,[%2+%%lo(%a0)]\\;st %%g0,[%2+%%lo(%a0+4)]\\; st %%g0,[%2+%%lo(%a0+8)]\\;st %%g0,[%2+%%lo(%a0+12)]\\\";\n+}\"\n+  [(set_attr \"type\" \"store\")\n+   (set_attr \"length\" \"5\")])\n+\f\n ;; This pattern forces (set (reg:DF ...) (const_double ...))\n ;; to be reloaded by putting the constant into memory.\n ;; It must come before the more general movdf pattern.\n@@ -1318,7 +1403,7 @@\n   return \\\"andcc %0,%1,%%g0\\\";\n }\")\n \f\n-;; Conversions between float and double.\n+;; Conversions between float, double and long double.\n \n (define_insn \"extendsfdf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n@@ -1328,13 +1413,45 @@\n   \"fstod %1,%0\"\n   [(set_attr \"type\" \"fp\")])\n \n+(define_insn \"extendsftf2\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=f\")\n+\t(float_extend:TF\n+\t (match_operand:SF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fstoq %1,%0\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"extenddftf2\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=f\")\n+\t(float_extend:TF\n+\t (match_operand:DF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fdtoq %1,%0\"\n+  [(set_attr \"type\" \"fp\")])\n+\n (define_insn \"truncdfsf2\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n \t(float_truncate:SF\n \t (match_operand:DF 1 \"register_operand\" \"f\")))]\n   \"\"\n   \"fdtos %1,%0\"\n   [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"trunctfsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(float_truncate:SF\n+\t (match_operand:TF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fqtos %1,%0\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"trunctfdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(float_truncate:DF\n+\t (match_operand:TF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fqtod %1,%0\"\n+  [(set_attr \"type\" \"fp\")])\n \f\n ;; Conversion between fixed point and floating point.\n \n@@ -1354,6 +1471,14 @@\n   [(set_attr \"type\" \"fp\")\n    (set_attr \"length\" \"3\")])\n \n+(define_insn \"floatsitf2\"\n+  [(set (match_operand:TF 0 \"general_operand\" \"=f\")\n+\t(float:TF (match_operand:SI 1 \"nonimmediate_operand\" \"rfm\")))]\n+  \"\"\n+  \"* return output_floatsitf2 (operands);\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"length\" \"3\")])\n+\n ;; Convert a float to an actual integer.\n ;; Truncation is performed as part of the conversion.\n \n@@ -1401,6 +1526,77 @@\n   [(set_attr \"type\" \"fp\")\n    (set_attr \"length\" \"3\")])\n \n+(define_insn \"fix_trunctfsi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n+\t(fix:SI (fix:TF (match_operand:TF 1 \"general_operand\" \"fm\"))))\n+   (clobber (match_scratch:DF 2 \"=&f\"))]\n+  \"\"\n+  \"*\n+{\n+  if (FP_REG_P (operands[1]))\n+    output_asm_insn (\\\"fqtoi %1,%2\\\", operands);\n+  else\n+    {\n+      rtx xoperands[3];\n+      xoperands[0] = operands[2];\n+      xoperands[1] = operands[1];\n+      output_asm_insn (output_fp_move_quad (xoperands), xoperands);\n+      output_asm_insn (\\\"fqtoi %2,%2\\\", operands);\n+    }\n+  if (GET_CODE (operands[0]) == MEM)\n+    return \\\"st %2,%0\\\";\n+  else\n+    return \\\"st %2,[%%fp-4]\\;ld [%%fp-4],%0\\\";\n+}\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"length\" \"3\")])\n+\n+;; Allow combiner to combine a fix_trunctfsi2 with a floatsitf2\n+;; This eliminates 2 useless instructions.\n+;; The first one matches if the fixed result is needed.  The second one\n+;; matches if the fixed result is not needed.\n+\n+(define_insn \"\"\n+  [(set (match_operand:TF 0 \"general_operand\" \"=f\")\n+\t(float:TF (fix:SI (fix:TF (match_operand:TF 1 \"general_operand\" \"fm\")))))\n+   (set (match_operand:SI 2 \"general_operand\" \"=rm\")\n+\t(fix:SI (fix:TF (match_dup 1))))]\n+  \"\"\n+  \"*\n+{\n+  if (FP_REG_P (operands[1]))\n+    output_asm_insn (\\\"fqtoi %1,%0\\\", operands);\n+  else\n+    {\n+      output_asm_insn (output_fp_move_quad (operands), operands);\n+      output_asm_insn (\\\"fqtoi %0,%0\\\", operands);\n+    }\n+  if (GET_CODE (operands[2]) == MEM)\n+    return \\\"st %0,%2\\;fitoq %0,%0\\\";\n+  else\n+    return \\\"st %0,[%%fp-4]\\;fitoq %0,%0\\;ld [%%fp-4],%2\\\";\n+}\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"length\" \"5\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:TF 0 \"general_operand\" \"=f\")\n+\t(float:TF (fix:SI (fix:TF (match_operand:TF 1 \"general_operand\" \"fm\")))))]\n+  \"\"\n+  \"*\n+{\n+  if (FP_REG_P (operands[1]))\n+    output_asm_insn (\\\"fqtoi %1,%0\\\", operands);\n+  else\n+    {\n+      output_asm_insn (output_fp_move_quad (operands), operands);\n+      output_asm_insn (\\\"fqtoi %0,%0\\\", operands);\n+    }\n+  return \\\"fitoq %0,%0\\\";\n+}\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"length\" \"3\")])\n+\n ;; Allow combiner to combine a fix_truncdfsi2 with a floatsidf2\n ;; This eliminates 2 useless instructions.\n ;; The first one matches if the fixed result is needed.  The second one\n@@ -1962,6 +2158,14 @@\n \f\n ;; Floating point arithmetic instructions.\n \n+(define_insn \"addtf3\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=f\")\n+\t(plus:TF (match_operand:TF 1 \"register_operand\" \"f\")\n+\t\t (match_operand:TF 2 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"faddq %1,%2,%0\"\n+  [(set_attr \"type\" \"fp\")])\n+\n (define_insn \"adddf3\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(plus:DF (match_operand:DF 1 \"register_operand\" \"f\")\n@@ -1978,6 +2182,14 @@\n   \"fadds %1,%2,%0\"\n   [(set_attr \"type\" \"fp\")])\n \n+(define_insn \"subtf3\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=f\")\n+\t(minus:TF (match_operand:TF 1 \"register_operand\" \"f\")\n+\t\t  (match_operand:TF 2 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fsubq %1,%2,%0\"\n+  [(set_attr \"type\" \"fp\")])\n+\n (define_insn \"subdf3\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(minus:DF (match_operand:DF 1 \"register_operand\" \"f\")\n@@ -1994,6 +2206,14 @@\n   \"fsubs %1,%2,%0\"\n   [(set_attr \"type\" \"fp\")])\n \n+(define_insn \"multf3\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=f\")\n+\t(mult:TF (match_operand:TF 1 \"register_operand\" \"f\")\n+\t\t (match_operand:TF 2 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fmulq %1,%2,%0\"\n+  [(set_attr \"type\" \"fpmul\")])\n+\n (define_insn \"muldf3\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(mult:DF (match_operand:DF 1 \"register_operand\" \"f\")\n@@ -2010,6 +2230,14 @@\n   \"fmuls %1,%2,%0\"\n   [(set_attr \"type\" \"fpmul\")])\n \n+(define_insn \"divtf3\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=f\")\n+\t(div:TF (match_operand:TF 1 \"register_operand\" \"f\")\n+\t\t(match_operand:TF 2 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fdivq %1,%2,%0\"\n+  [(set_attr \"type\" \"fpdiv\")])\n+\n (define_insn \"divdf3\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(div:DF (match_operand:DF 1 \"register_operand\" \"f\")\n@@ -2026,6 +2254,16 @@\n   \"fdivs %1,%2,%0\"\n   [(set_attr \"type\" \"fpdiv\")])\n \n+(define_insn \"negtf2\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=f,f\")\n+\t(neg:TF (match_operand:TF 1 \"register_operand\" \"0,f\")))]\n+  \"\"\n+  \"@\n+   fnegs %0,%0\n+   fnegs %1,%0\\;fmovs %R1,%R0\\;fmovs %S1,%S0\\;fmovs %T1,%T0\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"length\" \"1,4\")])\n+\n (define_insn \"negdf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f,f\")\n \t(neg:DF (match_operand:DF 1 \"register_operand\" \"0,f\")))]\n@@ -2036,14 +2274,23 @@\n   [(set_attr \"type\" \"fp\")\n    (set_attr \"length\" \"1,2\")])\n \n-\n (define_insn \"negsf2\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n \t(neg:SF (match_operand:SF 1 \"register_operand\" \"f\")))]\n   \"\"\n   \"fnegs %1,%0\"\n   [(set_attr \"type\" \"fp\")])\n \n+(define_insn \"abstf2\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=f,f\")\n+\t(abs:TF (match_operand:TF 1 \"register_operand\" \"0,f\")))]\n+  \"\"\n+  \"@\n+   fabss %0,%0\n+   fabss %1,%0\\;fmovs %R1,%R0\\;fmovs %S1,%S0\\;fmovs %T1,%T0\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"length\" \"1,4\")])\n+\n (define_insn \"absdf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f,f\")\n \t(abs:DF (match_operand:DF 1 \"register_operand\" \"0,f\")))]\n@@ -2061,6 +2308,13 @@\n   \"fabss %1,%0\"\n   [(set_attr \"type\" \"fp\")])\n \n+(define_insn \"sqrttf2\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=f\")\n+\t(sqrt:TF (match_operand:TF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fsqrtq %1,%0\"\n+  [(set_attr \"type\" \"fpsqrt\")])\n+\n (define_insn \"sqrtdf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(sqrt:DF (match_operand:DF 1 \"register_operand\" \"f\")))]"}]}