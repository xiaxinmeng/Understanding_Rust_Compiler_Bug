{"sha": "4cb110fbcb795cd0ad0a45a06f1e2ce9adc1e27f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGNiMTEwZmJjYjc5NWNkMGFkMGE0NWEwNmYxZTJjZTlhZGMxZTI3Zg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-10-27T16:23:25Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-10-27T16:23:25Z"}, "message": "optabs.c (expand_vec_perm): Use the correct mode for scaling the selector.\n\n        * optabs.c (expand_vec_perm): Use the correct mode for scaling the\n        selector.  Save the qimode constant selector for later use by the\n        qimode vec_perm pattern.\n\nFrom-SVN: r180567", "tree": {"sha": "c7bd745f092edc17d54898323cc44b8e39f6063b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7bd745f092edc17d54898323cc44b8e39f6063b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4cb110fbcb795cd0ad0a45a06f1e2ce9adc1e27f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cb110fbcb795cd0ad0a45a06f1e2ce9adc1e27f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cb110fbcb795cd0ad0a45a06f1e2ce9adc1e27f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cb110fbcb795cd0ad0a45a06f1e2ce9adc1e27f/comments", "author": null, "committer": null, "parents": [{"sha": "ed80f8590c13ae01cece8759f2842fcd7410135c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed80f8590c13ae01cece8759f2842fcd7410135c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed80f8590c13ae01cece8759f2842fcd7410135c"}], "stats": {"total": 106, "additions": 59, "deletions": 47}, "files": [{"sha": "b0b77bc10a64a5f67602003d936e1875a2cb9f28", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cb110fbcb795cd0ad0a45a06f1e2ce9adc1e27f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cb110fbcb795cd0ad0a45a06f1e2ce9adc1e27f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4cb110fbcb795cd0ad0a45a06f1e2ce9adc1e27f", "patch": "@@ -1,3 +1,9 @@\n+2011-10-27  Richard Henderson  <rth@redhat.com>\n+\n+\t* optabs.c (expand_vec_perm): Use the correct mode for scaling the\n+\tselector.  Save the qimode constant selector for later use by the\n+\tqimode vec_perm pattern.\n+\n 2011-10-27  Bernd Schmidt  <bernds@codesourcery.com>\n \n \t* config/c6x/c6x.c (unit_req_imbalance, res_mii): Cast the first arg"}, {"sha": "736d8264cf12df0db4f0d08476b355e55f1a4eab", "filename": "gcc/optabs.c", "status": "modified", "additions": 53, "deletions": 47, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cb110fbcb795cd0ad0a45a06f1e2ce9adc1e27f/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cb110fbcb795cd0ad0a45a06f1e2ce9adc1e27f/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=4cb110fbcb795cd0ad0a45a06f1e2ce9adc1e27f", "patch": "@@ -6912,7 +6912,7 @@ expand_vec_perm (enum machine_mode mode, rtx v0, rtx v1, rtx sel, rtx target)\n   enum insn_code icode;\n   enum machine_mode qimode;\n   unsigned int i, w, e, u;\n-  rtx tmp, sel_qi;\n+  rtx tmp, sel_qi = NULL;\n   rtvec vec;\n \n   if (!target || GET_MODE (target) != mode)\n@@ -6946,23 +6946,23 @@ expand_vec_perm (enum machine_mode mode, rtx v0, rtx v1, rtx sel, rtx target)\n       /* Fall back to a constant byte-based permutation.  */\n       if (qimode != VOIDmode)\n \t{\n-\t  icode = direct_optab_handler (vec_perm_const_optab, qimode);\n-\t  if (icode != CODE_FOR_nothing)\n+\t  vec = rtvec_alloc (w);\n+\t  for (i = 0; i < e; ++i)\n \t    {\n-\t      vec = rtvec_alloc (w);\n-\t      for (i = 0; i < e; ++i)\n-\t\t{\n-\t\t  unsigned int j, this_e;\n+\t      unsigned int j, this_e;\n \n-\t\t  this_e = INTVAL (XVECEXP (sel, 0, i));\n-\t\t  this_e &= 2 * e - 1;\n-\t\t  this_e *= u;\n+\t      this_e = INTVAL (XVECEXP (sel, 0, i));\n+\t      this_e &= 2 * e - 1;\n+\t      this_e *= u;\n \n-\t\t  for (j = 0; j < u; ++j)\n-\t\t    RTVEC_ELT (vec, i * u + j) = GEN_INT (this_e + j);\n-\t\t}\n-\t      sel_qi = gen_rtx_CONST_VECTOR (qimode, vec);\n+\t      for (j = 0; j < u; ++j)\n+\t\tRTVEC_ELT (vec, i * u + j) = GEN_INT (this_e + j);\n+\t    }\n+\t  sel_qi = gen_rtx_CONST_VECTOR (qimode, vec);\n \n+\t  icode = direct_optab_handler (vec_perm_const_optab, qimode);\n+\t  if (icode != CODE_FOR_nothing)\n+\t    {\n \t      tmp = expand_vec_perm_1 (icode, gen_lowpart (qimode, target),\n \t\t\t\t       gen_lowpart (qimode, v0),\n \t\t\t\t       gen_lowpart (qimode, v1), sel_qi);\n@@ -6989,47 +6989,53 @@ expand_vec_perm (enum machine_mode mode, rtx v0, rtx v1, rtx sel, rtx target)\n   if (icode == CODE_FOR_nothing)\n     return NULL_RTX;\n \n-  /* Multiply each element by its byte size.  */\n-  if (u == 2)\n-    sel = expand_simple_binop (mode, PLUS, sel, sel, sel, 0, OPTAB_DIRECT);\n-  else\n-    sel = expand_simple_binop (mode, ASHIFT, sel, GEN_INT (exact_log2 (u)),\n-\t\t\t       sel, 0, OPTAB_DIRECT);\n-  gcc_assert (sel != NULL);\n-\n-  /* Broadcast the low byte each element into each of its bytes.  */\n-  vec = rtvec_alloc (w);\n-  for (i = 0; i < w; ++i)\n-    {\n-      int this_e = i / u * u;\n-      if (BYTES_BIG_ENDIAN)\n-\tthis_e += u - 1;\n-      RTVEC_ELT (vec, i) = GEN_INT (this_e);\n-    }\n-  tmp = gen_rtx_CONST_VECTOR (qimode, vec);\n-  sel = gen_lowpart (qimode, sel);\n-  sel = expand_vec_perm (qimode, sel, sel, tmp, NULL);\n-  gcc_assert (sel != NULL);\n-\n-  /* Add the byte offset to each byte element.  */\n-  /* Note that the definition of the indicies here is memory ordering,\n-     so there should be no difference between big and little endian.  */\n-  vec = rtvec_alloc (w);\n-  for (i = 0; i < w; ++i)\n-    RTVEC_ELT (vec, i) = GEN_INT (i % u);\n-  tmp = gen_rtx_CONST_VECTOR (qimode, vec);\n-  sel = expand_simple_binop (qimode, PLUS, sel, tmp, sel, 0, OPTAB_DIRECT);\n-  gcc_assert (sel != NULL);\n+  if (sel_qi == NULL)\n+    {\n+      /* Multiply each element by its byte size.  */\n+      enum machine_mode selmode = GET_MODE (sel);\n+      if (u == 2)\n+\tsel = expand_simple_binop (selmode, PLUS, sel, sel,\n+\t\t\t\t   sel, 0, OPTAB_DIRECT);\n+      else\n+\tsel = expand_simple_binop (selmode, ASHIFT, sel,\n+\t\t\t\t   GEN_INT (exact_log2 (u)),\n+\t\t\t\t   sel, 0, OPTAB_DIRECT);\n+      gcc_assert (sel != NULL);\n+\n+      /* Broadcast the low byte each element into each of its bytes.  */\n+      vec = rtvec_alloc (w);\n+      for (i = 0; i < w; ++i)\n+\t{\n+\t  int this_e = i / u * u;\n+\t  if (BYTES_BIG_ENDIAN)\n+\t    this_e += u - 1;\n+\t  RTVEC_ELT (vec, i) = GEN_INT (this_e);\n+\t}\n+      tmp = gen_rtx_CONST_VECTOR (qimode, vec);\n+      sel = gen_lowpart (qimode, sel);\n+      sel = expand_vec_perm (qimode, sel, sel, tmp, NULL);\n+      gcc_assert (sel != NULL);\n+\n+      /* Add the byte offset to each byte element.  */\n+      /* Note that the definition of the indicies here is memory ordering,\n+\t so there should be no difference between big and little endian.  */\n+      vec = rtvec_alloc (w);\n+      for (i = 0; i < w; ++i)\n+\tRTVEC_ELT (vec, i) = GEN_INT (i % u);\n+      tmp = gen_rtx_CONST_VECTOR (qimode, vec);\n+      sel_qi = expand_simple_binop (qimode, PLUS, sel, tmp,\n+\t\t\t\t    sel, 0, OPTAB_DIRECT);\n+      gcc_assert (sel_qi != NULL);\n+    }\n \n   tmp = expand_vec_perm_1 (icode, gen_lowpart (qimode, target),\n \t\t\t   gen_lowpart (qimode, v0),\n-\t\t\t   gen_lowpart (qimode, v1), sel);\n+\t\t\t   gen_lowpart (qimode, v1), sel_qi);\n   if (tmp)\n     tmp = gen_lowpart (mode, tmp);\n   return tmp;\n }\n \n-\n /* Return insn code for a conditional operator with a comparison in\n    mode CMODE, unsigned if UNS is true, resulting in a value of mode VMODE.  */\n "}]}