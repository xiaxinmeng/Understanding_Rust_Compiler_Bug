{"sha": "118aa5e31ce479bb81a003199b4c6ca0d997c9a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTE4YWE1ZTMxY2U0NzliYjgxYTAwMzE5OWI0YzZjYTBkOTk3YzlhMg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-01-19T12:49:38Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-01-19T12:49:38Z"}, "message": "Fix ICE in speculative_call_info\n\nthis fixes two issues with the new multi-target speculation code which reproduce\non Firefox.  I can now build firefox with FDO locally but on Mozilla build bots\nit still fails with ICE in speculative_call_info.\n\nOne problem is that speuclative code compares call_stmt and lto_stmt_uid in\na way that may get unwanted effect when these gets out of sync.  It does not\nmake sense to have both non-zero so I added code clearing it and sanity check\nthat it is kept this way.\n\nOther problem is cgraph_edge::make_direct not working well with multiple\ntargets.  In this case it removed one speuclative target and the indirect call\nleaving other targets in the tree.\n\nThis is fixed by iterating across all targets and removing all except the good\none (if it exists).\n\n\tPR lto/93318\n\t* cgraph.c (cgraph_edge::resolve_speculation): Fix foramting.\n\t(cgraph_edge::make_direct): Remove all indirect targets.\n\t(cgraph_edge::redirect_call_stmt_to_callee): Use make_direct..\n\t(cgraph_node::verify_node): Verify that only one call_stmt or\n\tlto_stmt_uid is set.\n\t* cgraphclones.c (cgraph_edge::clone): Set only one call_stmt or\n\tlto_stmt_uid.\n\t* lto-cgraph.c (lto_output_edge): Simplify streaming of stmt.\n\t(lto_output_ref): Simplify streaming of stmt.\n\t* lto-streamer-in.c (fixup_call_stmt_edges_1): Clear lto_stmt_uid.", "tree": {"sha": "39628edc50f14d10ca77e933975701a81f550d14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39628edc50f14d10ca77e933975701a81f550d14"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/118aa5e31ce479bb81a003199b4c6ca0d997c9a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/118aa5e31ce479bb81a003199b4c6ca0d997c9a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/118aa5e31ce479bb81a003199b4c6ca0d997c9a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/118aa5e31ce479bb81a003199b4c6ca0d997c9a2/comments", "author": null, "committer": null, "parents": [{"sha": "52354dadb80b60c3fd05fb1b5aa3feb15a98b8af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52354dadb80b60c3fd05fb1b5aa3feb15a98b8af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52354dadb80b60c3fd05fb1b5aa3feb15a98b8af"}], "stats": {"total": 103, "additions": 90, "deletions": 13}, "files": [{"sha": "0e24b4a64721432a0cbd19ce447030096e12e771", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/118aa5e31ce479bb81a003199b4c6ca0d997c9a2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/118aa5e31ce479bb81a003199b4c6ca0d997c9a2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=118aa5e31ce479bb81a003199b4c6ca0d997c9a2", "patch": "@@ -1,3 +1,17 @@\n+2020-01-18  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR lto/93318\n+\t* cgraph.c (cgraph_edge::resolve_speculation): Fix foramting.\n+\t(cgraph_edge::make_direct): Remove all indirect targets.\n+\t(cgraph_edge::redirect_call_stmt_to_callee): Use make_direct..\n+\t(cgraph_node::verify_node): Verify that only one call_stmt or\n+\tlto_stmt_uid is set.\n+\t* cgraphclones.c (cgraph_edge::clone): Set only one call_stmt or\n+\tlto_stmt_uid.\n+\t* lto-cgraph.c (lto_output_edge): Simplify streaming of stmt.\n+\t(lto_output_ref): Simplify streaming of stmt.\n+\t* lto-streamer-in.c (fixup_call_stmt_edges_1): Clear lto_stmt_uid.\n+\n 2020-01-18  Tamar Christina  <tamar.christina@arm.com>\n \n \t* config/aarch64/aarch64-sve-builtins-base.cc (memory_vector_mode):"}, {"sha": "c442f334fe24632022ff854a385c04c22424d5b1", "filename": "gcc/cgraph.c", "status": "modified", "additions": 67, "deletions": 9, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/118aa5e31ce479bb81a003199b4c6ca0d997c9a2/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/118aa5e31ce479bb81a003199b4c6ca0d997c9a2/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=118aa5e31ce479bb81a003199b4c6ca0d997c9a2", "patch": "@@ -1226,8 +1226,8 @@ cgraph_edge::resolve_speculation (cgraph_edge *edge, tree callee_decl)\n         fprintf (dump_file, \"Speculative call turned into direct call.\\n\");\n       edge = e2;\n       e2 = tmp;\n-      /* FIXME:  If EDGE is inlined, we should scale up the frequencies and counts\n-         in the functions inlined through it.  */\n+      /* FIXME:  If EDGE is inlined, we should scale up the frequencies\n+\t and counts in the functions inlined through it.  */\n     }\n   edge->count += e2->count;\n   if (edge->num_speculative_call_targets_p ())\n@@ -1263,11 +1263,52 @@ cgraph_edge::make_direct (cgraph_edge *edge, cgraph_node *callee)\n   /* If we are redirecting speculative call, make it non-speculative.  */\n   if (edge->speculative)\n     {\n-      edge = resolve_speculation (edge, callee->decl);\n+      cgraph_edge *found = NULL;\n+      cgraph_edge *direct, *next;\n+      ipa_ref *ref;\n+\n+      edge->speculative_call_info (direct, edge, ref);\n \n-      /* On successful speculation just return the pre existing direct edge.  */\n-      if (!edge->indirect_unknown_callee)\n-        return edge;\n+      /* Look all speculative targets and remove all but one corresponding\n+\t to callee (if it exists).\n+\t If there is only one target we can save one extra call to\n+\t speculative_call_info.  */\n+      if (edge->num_speculative_call_targets_p () != 1)\n+\tfor (direct = edge->caller->callees; direct; direct = next)\n+\t  {\n+\t    next = direct->next_callee;\n+\t    if (direct->call_stmt == edge->call_stmt\n+\t\t&& direct->lto_stmt_uid == edge->lto_stmt_uid)\n+\t      {\n+\t\tdirect->speculative_call_info (direct, edge, ref);\n+\n+\t\t/* Compare ref not direct->callee.  Direct edge is possibly\n+\t\t   inlined or redirected.  */\n+\t\tif (!ref->referred->semantically_equivalent_p (callee))\n+\t\t  edge = direct->resolve_speculation (direct, NULL);\n+\t\telse\n+\t\t  {\n+\t\t    gcc_checking_assert (!found);\n+\t\t    found = direct;\n+\t\t  }\n+\t      }\n+\t  }\n+\telse if (!ref->referred->semantically_equivalent_p (callee))\n+\t  edge = direct->resolve_speculation (direct, NULL);\n+\telse\n+\t  found = direct;\n+\n+      /* On successful speculation just remove the indirect edge and\n+\t return the pre existing direct edge.\n+\t It is important to not remove it and redirect because the direct\n+\t edge may be inlined or redirected.  */\n+      if (found)\n+\t{\n+\t  resolve_speculation (edge, callee->decl);\n+\t  gcc_checking_assert (!found->speculative);\n+\t  return found;\n+\t}\n+      gcc_checking_assert (!edge->speculative);\n     }\n \n   edge->indirect_unknown_callee = 0;\n@@ -1328,7 +1369,7 @@ cgraph_edge::redirect_call_stmt_to_callee (cgraph_edge *e)\n       /* If there already is an direct call (i.e. as a result of inliner's\n \t substitution), forget about speculating.  */\n       if (decl)\n-\te = resolve_speculation (e, decl);\n+\te = make_direct (e, cgraph_node::get (decl));\n       else\n \t{\n \t  /* Expand speculation into GIMPLE code.  */\n@@ -3116,6 +3157,8 @@ cgraph_node::verify_node (void)\n   basic_block this_block;\n   gimple_stmt_iterator gsi;\n   bool error_found = false;\n+  int i;\n+  ipa_ref *ref = NULL;\n \n   if (seen_error ())\n     return;\n@@ -3201,6 +3244,11 @@ cgraph_node::verify_node (void)\n \t  cgraph_debug_gimple_stmt (this_cfun, e->call_stmt);\n \t  error_found = true;\n \t}\n+      if (e->call_stmt && e->lto_stmt_uid)\n+\t{\n+\t  error (\"edge has both cal_stmt and lto_stmt_uid set\");\n+\t  error_found = true;\n+\t}\n     }\n   bool check_comdat = comdat_local_p ();\n   for (e = callers; e; e = e->next_caller)\n@@ -3267,6 +3315,11 @@ cgraph_node::verify_node (void)\n \t  fprintf (stderr, \"\\n\");\n \t  error_found = true;\n \t}\n+      if (e->call_stmt && e->lto_stmt_uid)\n+\t{\n+\t  error (\"edge has both cal_stmt and lto_stmt_uid set\");\n+\t  error_found = true;\n+\t}\n     }\n   for (e = indirect_calls; e; e = e->next_callee)\n     {\n@@ -3398,8 +3451,6 @@ cgraph_node::verify_node (void)\n       if (this_cfun->cfg)\n \t{\n \t  hash_set<gimple *> stmts;\n-\t  int i;\n-\t  ipa_ref *ref = NULL;\n \n \t  /* Reach the trees by walking over the CFG, and note the\n \t     enclosing basic-blocks in the call edges.  */\n@@ -3468,6 +3519,13 @@ cgraph_node::verify_node (void)\n \t/* No CFG available?!  */\n \tgcc_unreachable ();\n \n+      for (i = 0; iterate_reference (i, ref); i++)\n+\tif (ref->stmt && ref->lto_stmt_uid)\n+\t  {\n+\t    error (\"reference has both cal_stmt and lto_stmt_uid set\");\n+\t    error_found = true;\n+\t  }\n+\n       for (e = callees; e; e = e->next_callee)\n \t{\n \t  if (!e->aux && !e->speculative)"}, {"sha": "417488bca1f8397f8ab0363130d40c262a6c46bd", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/118aa5e31ce479bb81a003199b4c6ca0d997c9a2/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/118aa5e31ce479bb81a003199b4c6ca0d997c9a2/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=118aa5e31ce479bb81a003199b4c6ca0d997c9a2", "patch": "@@ -132,7 +132,8 @@ cgraph_edge::clone (cgraph_node *n, gcall *call_stmt, unsigned stmt_uid,\n \n   new_edge->inline_failed = inline_failed;\n   new_edge->indirect_inlining_edge = indirect_inlining_edge;\n-  new_edge->lto_stmt_uid = stmt_uid;\n+  if (!call_stmt)\n+    new_edge->lto_stmt_uid = stmt_uid;\n   new_edge->speculative_id = speculative_id;\n   /* Clone flags that depend on call_stmt availability manually.  */\n   new_edge->can_throw_external = can_throw_external;"}, {"sha": "b0c7ebf775bd81f7a748da2e918847bd521829e5", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/118aa5e31ce479bb81a003199b4c6ca0d997c9a2/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/118aa5e31ce479bb81a003199b4c6ca0d997c9a2/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=118aa5e31ce479bb81a003199b4c6ca0d997c9a2", "patch": "@@ -257,10 +257,11 @@ lto_output_edge (struct lto_simple_output_block *ob, struct cgraph_edge *edge,\n   edge->count.stream_out (ob->main_stream);\n \n   bp = bitpack_create (ob->main_stream);\n-  uid = (!gimple_has_body_p (edge->caller->decl) || edge->caller->thunk.thunk_p\n-\t ? edge->lto_stmt_uid : gimple_uid (edge->call_stmt) + 1);\n+  uid = !edge->call_stmt ? edge->lto_stmt_uid\n+\t\t\t : gimple_uid (edge->call_stmt) + 1;\n   bp_pack_enum (&bp, cgraph_inline_failed_t,\n \t        CIF_N_REASONS, edge->inline_failed);\n+  gcc_checking_assert (uid || edge->caller->thunk.thunk_p);\n   bp_pack_var_len_unsigned (&bp, uid);\n   bp_pack_value (&bp, edge->speculative_id, 16);\n   bp_pack_value (&bp, edge->indirect_inlining_edge, 1);\n@@ -669,7 +670,7 @@ lto_output_ref (struct lto_simple_output_block *ob, struct ipa_ref *ref,\n {\n   struct bitpack_d bp;\n   int nref;\n-  int uid = ref->lto_stmt_uid;\n+  int uid = !ref->stmt ? ref->lto_stmt_uid : gimple_uid (ref->stmt) + 1;\n   struct cgraph_node *node;\n \n   bp = bitpack_create (ob->main_stream);"}, {"sha": "9566e5ee102f2e09f07bf59a00d600d38d87dedd", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/118aa5e31ce479bb81a003199b4c6ca0d997c9a2/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/118aa5e31ce479bb81a003199b4c6ca0d997c9a2/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=118aa5e31ce479bb81a003199b4c6ca0d997c9a2", "patch": "@@ -892,6 +892,7 @@ fixup_call_stmt_edges_1 (struct cgraph_node *node, gimple **stmts,\n         fatal_error (input_location,\n \t\t     \"Cgraph edge statement index out of range\");\n       cedge->call_stmt = as_a <gcall *> (stmts[cedge->lto_stmt_uid - 1]);\n+      cedge->lto_stmt_uid = 0;\n       if (!cedge->call_stmt)\n         fatal_error (input_location,\n \t\t     \"Cgraph edge statement index not found\");\n@@ -902,6 +903,7 @@ fixup_call_stmt_edges_1 (struct cgraph_node *node, gimple **stmts,\n         fatal_error (input_location,\n \t\t     \"Cgraph edge statement index out of range\");\n       cedge->call_stmt = as_a <gcall *> (stmts[cedge->lto_stmt_uid - 1]);\n+      cedge->lto_stmt_uid = 0;\n       if (!cedge->call_stmt)\n         fatal_error (input_location, \"Cgraph edge statement index not found\");\n     }\n@@ -912,6 +914,7 @@ fixup_call_stmt_edges_1 (struct cgraph_node *node, gimple **stmts,\n \t  fatal_error (input_location,\n \t\t       \"Reference statement index out of range\");\n \tref->stmt = stmts[ref->lto_stmt_uid - 1];\n+\tref->lto_stmt_uid = 0;\n \tif (!ref->stmt)\n \t  fatal_error (input_location, \"Reference statement index not found\");\n       }"}]}