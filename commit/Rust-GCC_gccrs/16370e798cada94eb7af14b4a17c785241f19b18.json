{"sha": "16370e798cada94eb7af14b4a17c785241f19b18", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTYzNzBlNzk4Y2FkYTk0ZWI3YWYxNGI0YTE3Yzc4NTI0MWYxOWIxOA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2016-12-14T16:08:07Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2016-12-14T16:08:07Z"}, "message": "rs6000.c (rs6000_split_vec_extract_var): On ISA 3.0/power9, add support to use the VEXTU{B,H,W}{L,R}X extract instructions.\n\n[gcc]\n2016-12-14  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/rs6000.c (rs6000_split_vec_extract_var): On ISA\n\t3.0/power9, add support to use the VEXTU{B,H,W}{L,R}X extract\n\tinstructions.\n\t* config/rs6000/vsx.md (VSr2): Add IEEE 128-bit floating point\n\ttype constraint registers.\n\t(VSr3): Likewise.\n\t(FL_CONV): New mode iterator for binary floating types that have a\n\tdirect conversion from 64-bit integer to floating point.\n\t(vsx_extract_<mode>_p9): Add support for the ISA 3.0/power9\n\tVEXTU{B,H,W}{L,R}X extract instructions.\n\t(vsx_extract_<mode>_p9 splitter): Add splitter to load up the\n\textract byte position into the GPR if we are using the\n\tVEXTU{B,H,W}{L,R}X extract instructions.\n\t(vsx_extract_<mode>_di_p9): Support extracts to GPRs.\n\t(vsx_extract_<mode>_store_p9): Support extracting to GPRs so that\n\twe can use reg+offset address instructions.\n\t(vsx_extract_<mode>_var): Support extracts to GPRs.\n\t(vsx_extract_<VSX_EXTRACT_I:mode>_<SDI:mode>_var): New combiner\n\tinsn to combine vector extracts with zero_extend.\n\t(vsx_ext_<VSX_EXTRACT_I:VS_scalar>_fl_<FL_CONV:mode>): Optimize\n\textracting a small integer vector element and converting it to a\n\tfloating point type.\n\t(vsx_ext_<VSX_EXTRACT_I:VS_scalar>_ufl_<FL_CONV:mode>): Likewise.\n\t(UNSPEC_XXEXTRACTUW): New unspec.\n\t(UNSPEC_XXINSERTW): Likewise.\n\t(vextract4b): Add support for the vec_vextract4b built-in\n\tfunction.\n\t(vextract4b_internal): Likewise.\n\t(vinsert4b): Add support for the vec_insert4b built-in function.\n\tInclude both a version that inserts element 1 from a V4SI object\n\tand one that inserts a DI object.\n\t(vinsert4b_internal): Likewise.\n\t(vinsert4b_di): Likewise.\n\t(vinsert4b_di_internal): Likewise.\n\t* config/rs6000/predicates.md (const_0_to_11_operand): New\n\tpredicate, match 0..11.\n\t* config/rs6000/rs6000-builtin.def (BU_P9V_VSX_3): Set built-in\n\ttype to ternary, not binary.\n\t(BU_P9V_64BIT_VSX_3): Likewise.\n\t(P9V_BUILTIN_VEXTRACT4B): Add support for vec_vinsert4b and\n\tvec_extract4b non-overloaded built-in functions.\n\t(P9V_BUILTIN_VINSERT4B): Likewise.\n\t(P9V_BUILTIN_VINSERT4B_DI): Likewise.\n\t(P9V_BUILTIN_VEC_VEXTULX): Move to section that adds 2 operand ISA\n\t3.0 built-in functions.\n\t(P9V_BUILTIN_VEC_VEXTURX): Likewise.\n\t(P9V_BUILTIN_VEC_VEXTRACT4B): Add support for overloaded\n\tvec_insert4b and vec_extract4 built-in functions.\n\t(P9V_BUILTIN_VEC_VINSERT4B): Likewise.\n\t* config/rs6000/rs6000-c.c (altivec_overloaded_builtins): Add\n\toverloaded support for vec_vinsert4b and vec_extract4b.\n\t* config/rs6000/rs6000.c (altivec_expand_builtin): Add checks for\n\tthe vec_insert4b and vec_extract4b byte number being a constant in\n\tthe range 0..11.\n\t* config/rs6000/altivec.h (vec_vinsert4b): Support vec_vinsert4b\n\tand vec_extract4b built-in functions.\n\t* doc/extend.doc (PowerPC VSX built-in functions): Document\n\tvec_insert4b and vec_extract4b.\n\n[gcc/testsuite]\n2016-12-14  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* gcc/testsuite/gcc.target/powerpc/vec-extract.h: If DO_TRACE is\n\tdefined, add tracing of the various extracts to stderr.  Add\n\tsupport for tests that convert the result to another type.\n\t* gcc/testsuite/gcc.target/powerpc/vec-extract-v2df.c: Likewise.\n\t* gcc/testsuite/gcc.target/powerpc/vec-extract-v4sf.c: Likewise.\n\t* gcc/testsuite/gcc.target/powerpc/vec-extract-v4si-df.c: Add new\n\ttests that do an extract and then convert the values double.\n\t* gcc/testsuite/gcc.target/powerpc/vec-extract-v4siu-df.c: Likewise.\n\t* gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-df.c: Likewise.\n\t* gcc/testsuite/gcc.target/powerpc/vec-extract-v16qi-df.c: Likewise.\n\t* gcc/testsuite/gcc.target/powerpc/vec-extract-v8hiu-df.c: Likewise.\n\t* gcc/testsuite/gcc.target/powerpc/vec-extract-v8hi-df.c: Likewise.\n\t* gcc.target/powerpc/p9-extract-1.c: Update test to check for\n\tVEXTU{B,H,W}{L,R}X instructions being generated by default instead\n\tof VEXTRACTU{B,H} and XXEXTRACTUW.\n\t* gcc.target/powerpc/p9-extract-3.c: New test for combination of\n\tvec_extract and convert to floating point.\n\t* gcc.target/powerpc/p9-vinsert4b-1.c: New test for vec_vinsert4b\n\tand vec_extract4b.\n\t* gcc.target/powerpc/p9-vinsert4b-2.c: Likewise.\n\nFrom-SVN: r243653", "tree": {"sha": "48dc25cf80111bb752fad4251db1f37d4ad12a96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/48dc25cf80111bb752fad4251db1f37d4ad12a96"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16370e798cada94eb7af14b4a17c785241f19b18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16370e798cada94eb7af14b4a17c785241f19b18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16370e798cada94eb7af14b4a17c785241f19b18", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16370e798cada94eb7af14b4a17c785241f19b18/comments", "author": null, "committer": null, "parents": [{"sha": "d33c00e1ceb82fa46561ee076b9cb40ad44dc0dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d33c00e1ceb82fa46561ee076b9cb40ad44dc0dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d33c00e1ceb82fa46561ee076b9cb40ad44dc0dc"}], "stats": {"total": 1463, "additions": 1144, "deletions": 319}, "files": [{"sha": "bfeb1c3a076304d3b5fbe078814b1991a1ee557e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16370e798cada94eb7af14b4a17c785241f19b18/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16370e798cada94eb7af14b4a17c785241f19b18/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=16370e798cada94eb7af14b4a17c785241f19b18", "patch": "@@ -1,3 +1,64 @@\n+2016-12-14  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000.c (rs6000_split_vec_extract_var): On ISA\n+\t3.0/power9, add support to use the VEXTU{B,H,W}{L,R}X extract\n+\tinstructions.\n+\t* config/rs6000/vsx.md (VSr2): Add IEEE 128-bit floating point\n+\ttype constraint registers.\n+\t(VSr3): Likewise.\n+\t(FL_CONV): New mode iterator for binary floating types that have a\n+\tdirect conversion from 64-bit integer to floating point.\n+\t(vsx_extract_<mode>_p9): Add support for the ISA 3.0/power9\n+\tVEXTU{B,H,W}{L,R}X extract instructions.\n+\t(vsx_extract_<mode>_p9 splitter): Add splitter to load up the\n+\textract byte position into the GPR if we are using the\n+\tVEXTU{B,H,W}{L,R}X extract instructions.\n+\t(vsx_extract_<mode>_di_p9): Support extracts to GPRs.\n+\t(vsx_extract_<mode>_store_p9): Support extracting to GPRs so that\n+\twe can use reg+offset address instructions.\n+\t(vsx_extract_<mode>_var): Support extracts to GPRs.\n+\t(vsx_extract_<VSX_EXTRACT_I:mode>_<SDI:mode>_var): New combiner\n+\tinsn to combine vector extracts with zero_extend.\n+\t(vsx_ext_<VSX_EXTRACT_I:VS_scalar>_fl_<FL_CONV:mode>): Optimize\n+\textracting a small integer vector element and converting it to a\n+\tfloating point type.\n+\t(vsx_ext_<VSX_EXTRACT_I:VS_scalar>_ufl_<FL_CONV:mode>): Likewise.\n+\t(UNSPEC_XXEXTRACTUW): New unspec.\n+\t(UNSPEC_XXINSERTW): Likewise.\n+\t(vextract4b): Add support for the vec_vextract4b built-in\n+\tfunction.\n+\t(vextract4b_internal): Likewise.\n+\t(vinsert4b): Add support for the vec_insert4b built-in function.\n+\tInclude both a version that inserts element 1 from a V4SI object\n+\tand one that inserts a DI object.\n+\t(vinsert4b_internal): Likewise.\n+\t(vinsert4b_di): Likewise.\n+\t(vinsert4b_di_internal): Likewise.\n+\t* config/rs6000/predicates.md (const_0_to_11_operand): New\n+\tpredicate, match 0..11.\n+\t* config/rs6000/rs6000-builtin.def (BU_P9V_VSX_3): Set built-in\n+\ttype to ternary, not binary.\n+\t(BU_P9V_64BIT_VSX_3): Likewise.\n+\t(P9V_BUILTIN_VEXTRACT4B): Add support for vec_vinsert4b and\n+\tvec_extract4b non-overloaded built-in functions.\n+\t(P9V_BUILTIN_VINSERT4B): Likewise.\n+\t(P9V_BUILTIN_VINSERT4B_DI): Likewise.\n+\t(P9V_BUILTIN_VEC_VEXTULX): Move to section that adds 2 operand ISA\n+\t3.0 built-in functions.\n+\t(P9V_BUILTIN_VEC_VEXTURX): Likewise.\n+\t(P9V_BUILTIN_VEC_VEXTRACT4B): Add support for overloaded\n+\tvec_insert4b and vec_extract4 built-in functions.\n+\t(P9V_BUILTIN_VEC_VINSERT4B): Likewise.\n+\t* config/rs6000/rs6000-c.c (altivec_overloaded_builtins): Add\n+\toverloaded support for vec_vinsert4b and vec_extract4b.\n+\t* config/rs6000/rs6000.c (altivec_expand_builtin): Add checks for\n+\tthe vec_insert4b and vec_extract4b byte number being a constant in\n+\tthe range 0..11.\n+\t* config/rs6000/altivec.h (vec_vinsert4b): Support vec_vinsert4b\n+\tand vec_extract4b built-in functions.\n+\t* doc/extend.doc (PowerPC VSX built-in functions): Document\n+\tvec_insert4b and vec_extract4b.\n+\n 2016-12-14  Martin Liska  <mliska@suse.cz>\n \n \t* gimple-pretty-print.c (dump_probability): New function."}, {"sha": "2eeeab18d4839cbb594263833a44f110e263dff0", "filename": "gcc/config/rs6000/altivec.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16370e798cada94eb7af14b4a17c785241f19b18/gcc%2Fconfig%2Frs6000%2Faltivec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16370e798cada94eb7af14b4a17c785241f19b18/gcc%2Fconfig%2Frs6000%2Faltivec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.h?ref=16370e798cada94eb7af14b4a17c785241f19b18", "patch": "@@ -394,6 +394,8 @@\n #define vec_vctzd __builtin_vec_vctzd\n #define vec_vctzh __builtin_vec_vctzh\n #define vec_vctzw __builtin_vec_vctzw\n+#define vec_vextract4b __builtin_vec_vextract4b\n+#define vec_vinsert4b __builtin_vec_vinsert4b\n #define vec_vprtyb __builtin_vec_vprtyb\n #define vec_vprtybd __builtin_vec_vprtybd\n #define vec_vprtybw __builtin_vec_vprtybw"}, {"sha": "30b212392f6506d8bcc7f460386143cbd0cbc891", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16370e798cada94eb7af14b4a17c785241f19b18/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16370e798cada94eb7af14b4a17c785241f19b18/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=16370e798cada94eb7af14b4a17c785241f19b18", "patch": "@@ -210,6 +210,11 @@\n   (and (match_code \"const_int\")\n        (match_test \"IN_RANGE (INTVAL (op), 0, 7)\")))\n \n+;; Match op = 0..11\n+(define_predicate \"const_0_to_11_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (INTVAL (op), 0, 11)\")))\n+\n ;; Match op = 0..15\n (define_predicate \"const_0_to_15_operand\"\n   (and (match_code \"const_int\")"}, {"sha": "702c2d04d15512fb6f5d3a0acfe8c21cb02d7e78", "filename": "gcc/config/rs6000/rs6000-builtin.def", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16370e798cada94eb7af14b4a17c785241f19b18/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16370e798cada94eb7af14b4a17c785241f19b18/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def?ref=16370e798cada94eb7af14b4a17c785241f19b18", "patch": "@@ -877,7 +877,16 @@\n \t\t    \"__builtin_vsx_\" NAME,\t\t/* NAME */\t\\\n \t\t    RS6000_BTM_P9_VECTOR,\t\t/* MASK */\t\\\n \t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n-\t\t     | RS6000_BTC_BINARY),\t\t\t\t\\\n+\t\t     | RS6000_BTC_TERNARY),\t\t\t\t\\\n+\t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n+\n+#define BU_P9V_64BIT_VSX_3(ENUM, NAME, ATTR, ICODE)\t\t\t\\\n+  RS6000_BUILTIN_2 (P9V_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_vsx_\" NAME,\t\t/* NAME */\t\\\n+\t\t    (RS6000_BTM_64BIT\t\t\t\t\t\\\n+\t\t     | RS6000_BTM_P9_VECTOR),\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_TERNARY),\t\t\t\t\\\n \t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n \n /* See the comment on BU_ALTIVEC_P.  */\n@@ -1968,6 +1977,11 @@ BU_P9V_AV_2 (VEXTUHRX, \"vextuhrx\",\t\tCONST,\tvextuhrx)\n BU_P9V_AV_2 (VEXTUWLX, \"vextuwlx\",\t\tCONST,\tvextuwlx)\n BU_P9V_AV_2 (VEXTUWRX, \"vextuwrx\",\t\tCONST,\tvextuwrx)\n \n+/* Insert/extract 4 byte word into a vector.  */\n+BU_P9V_VSX_2 (VEXTRACT4B,   \"vextract4b\",\tCONST,\tvextract4b)\n+BU_P9V_VSX_3 (VINSERT4B,    \"vinsert4b\",\tCONST,\tvinsert4b)\n+BU_P9V_VSX_3 (VINSERT4B_DI, \"vinsert4b_di\",\tCONST,\tvinsert4b_di)\n+\n /* 3 argument vector functions returning void, treated as SPECIAL,\n    added in ISA 3.0 (power9).  */\n BU_P9V_64BIT_AV_X (STXVL,\t\"stxvl\",\tMISC)\n@@ -2009,12 +2023,13 @@ BU_P9V_AV_P (VCMPNEZW_P,\t\"vcmpnezw_p\",\tCONST,\tvector_nez_v4si_p)\n \n /* ISA 3.0 Vector scalar overloaded 2 argument functions */\n BU_P9V_OVERLOAD_2 (LXVL,\t\"lxvl\")\n+BU_P9V_OVERLOAD_2 (VEXTULX,\t\"vextulx\")\n+BU_P9V_OVERLOAD_2 (VEXTURX,\t\"vexturx\")\n+BU_P9V_OVERLOAD_2 (VEXTRACT4B,\t\"vextract4b\")\n \n /* ISA 3.0 Vector scalar overloaded 3 argument functions */\n BU_P9V_OVERLOAD_3 (STXVL,\t\"stxvl\")\n-\n-BU_P9V_OVERLOAD_2 (VEXTULX,\t\"vextulx\")\n-BU_P9V_OVERLOAD_2 (VEXTURX,\t\"vexturx\")\n+BU_P9V_OVERLOAD_3 (VINSERT4B,\t\"vinsert4b\")\n \n /* Overloaded CMPNE support was implemented prior to Power 9,\n    so is not mentioned here.  */"}, {"sha": "6ec9d59a291cab009c2bce067fd3a4c8c44557f8", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16370e798cada94eb7af14b4a17c785241f19b18/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16370e798cada94eb7af14b4a17c785241f19b18/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=16370e798cada94eb7af14b4a17c785241f19b18", "patch": "@@ -4686,6 +4686,11 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {\n   { P9V_BUILTIN_VEC_VCTZLSBB, P9V_BUILTIN_VCTZLSBB,\n     RS6000_BTI_INTSI, RS6000_BTI_unsigned_V16QI, 0, 0 },\n \n+  { P9V_BUILTIN_VEC_VEXTRACT4B, P9V_BUILTIN_VEXTRACT4B,\n+    RS6000_BTI_INTDI, RS6000_BTI_V16QI, RS6000_BTI_UINTSI, 0 },\n+  { P9V_BUILTIN_VEC_VEXTRACT4B, P9V_BUILTIN_VEXTRACT4B,\n+    RS6000_BTI_INTDI, RS6000_BTI_unsigned_V16QI, RS6000_BTI_UINTSI, 0 },\n+\n   { P9V_BUILTIN_VEC_VEXTULX, P9V_BUILTIN_VEXTUBLX,\n     RS6000_BTI_INTQI, RS6000_BTI_UINTSI,\n     RS6000_BTI_V16QI, 0 },\n@@ -4739,6 +4744,28 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {\n   { P8V_BUILTIN_VEC_VGBBD, P8V_BUILTIN_VGBBD,\n     RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, 0, 0 },\n \n+  { P9V_BUILTIN_VEC_VINSERT4B, P9V_BUILTIN_VINSERT4B,\n+    RS6000_BTI_V16QI, RS6000_BTI_V4SI,\n+    RS6000_BTI_V16QI, RS6000_BTI_UINTSI },\n+  { P9V_BUILTIN_VEC_VINSERT4B, P9V_BUILTIN_VINSERT4B,\n+    RS6000_BTI_V16QI, RS6000_BTI_unsigned_V4SI,\n+    RS6000_BTI_V16QI, RS6000_BTI_UINTSI },\n+  { P9V_BUILTIN_VEC_VINSERT4B, P9V_BUILTIN_VINSERT4B,\n+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V4SI,\n+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_UINTSI },\n+  { P9V_BUILTIN_VEC_VINSERT4B, P9V_BUILTIN_VINSERT4B_DI,\n+    RS6000_BTI_V16QI, RS6000_BTI_INTDI,\n+    RS6000_BTI_V16QI, RS6000_BTI_UINTDI },\n+  { P9V_BUILTIN_VEC_VINSERT4B, P9V_BUILTIN_VINSERT4B_DI,\n+    RS6000_BTI_V16QI, RS6000_BTI_UINTDI,\n+    RS6000_BTI_V16QI, RS6000_BTI_UINTDI },\n+  { P9V_BUILTIN_VEC_VINSERT4B, P9V_BUILTIN_VINSERT4B_DI,\n+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTDI,\n+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_UINTDI },\n+  { P9V_BUILTIN_VEC_VINSERT4B, P9V_BUILTIN_VINSERT4B_DI,\n+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_UINTDI,\n+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_UINTDI },\n+\n   { P8V_BUILTIN_VEC_VADDECUQ, P8V_BUILTIN_VADDECUQ,\n     RS6000_BTI_V1TI, RS6000_BTI_V1TI, RS6000_BTI_V1TI, RS6000_BTI_V1TI },\n   { P8V_BUILTIN_VEC_VADDECUQ, P8V_BUILTIN_VADDECUQ,"}, {"sha": "7076ca16a4fdfe12255438275d07cd11910e92e8", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 79, "deletions": 2, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16370e798cada94eb7af14b4a17c785241f19b18/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16370e798cada94eb7af14b4a17c785241f19b18/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=16370e798cada94eb7af14b4a17c785241f19b18", "patch": "@@ -7522,8 +7522,52 @@ rs6000_split_vec_extract_var (rtx dest, rtx src, rtx element, rtx tmp_gpr,\n     {\n       int bit_shift = byte_shift + 3;\n       rtx element2;\n+      int dest_regno = regno_or_subregno (dest);\n+      int src_regno = regno_or_subregno (src);\n+      int element_regno = regno_or_subregno (element);\n+\n+      gcc_assert (REG_P (tmp_gpr));\n+\n+      /* See if we want to generate VEXTU{B,H,W}{L,R}X if the destination is in\n+\t a general purpose register.  */\n+      if (TARGET_P9_VECTOR\n+\t  && (mode == V16QImode || mode == V8HImode || mode == V4SImode)\n+\t  && INT_REGNO_P (dest_regno)\n+\t  && ALTIVEC_REGNO_P (src_regno)\n+\t  && INT_REGNO_P (element_regno))\n+\t{\n+\t  rtx dest_si = gen_rtx_REG (SImode, dest_regno);\n+\t  rtx element_si = gen_rtx_REG (SImode, element_regno);\n+\n+\t  if (mode == V16QImode)\n+\t    emit_insn (VECTOR_ELT_ORDER_BIG\n+\t\t       ? gen_vextublx (dest_si, element_si, src)\n+\t\t       : gen_vextubrx (dest_si, element_si, src));\n+\n+\t  else if (mode == V8HImode)\n+\t    {\n+\t      rtx tmp_gpr_si = gen_rtx_REG (SImode, REGNO (tmp_gpr));\n+\t      emit_insn (gen_ashlsi3 (tmp_gpr_si, element_si, const1_rtx));\n+\t      emit_insn (VECTOR_ELT_ORDER_BIG\n+\t\t\t ? gen_vextuhlx (dest_si, tmp_gpr_si, src)\n+\t\t\t : gen_vextuhrx (dest_si, tmp_gpr_si, src));\n+\t    }\n+\n+\n+\t  else\n+\t    {\n+\t      rtx tmp_gpr_si = gen_rtx_REG (SImode, REGNO (tmp_gpr));\n+\t      emit_insn (gen_ashlsi3 (tmp_gpr_si, element_si, const2_rtx));\n+\t      emit_insn (VECTOR_ELT_ORDER_BIG\n+\t\t\t ? gen_vextuwlx (dest_si, tmp_gpr_si, src)\n+\t\t\t : gen_vextuwrx (dest_si, tmp_gpr_si, src));\n+\t    }\n+\n+\t  return;\n+\t}\n \n-      gcc_assert (REG_P (tmp_gpr) && REG_P (tmp_altivec));\n+\n+      gcc_assert (REG_P (tmp_altivec));\n \n       /* For little endian, adjust element ordering.  For V2DI/V2DF, we can use\n \t an XOR, otherwise we need to subtract.  The shift amount is so VSLO\n@@ -15550,7 +15594,7 @@ altivec_expand_builtin (tree exp, rtx target, bool *expandedp)\n   size_t i;\n   enum insn_code icode;\n   tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n-  tree arg0;\n+  tree arg0, arg1, arg2;\n   rtx op0, pat;\n   machine_mode tmode, mode0;\n   enum rs6000_builtins fcode\n@@ -15770,6 +15814,39 @@ altivec_expand_builtin (tree exp, rtx target, bool *expandedp)\n     case VSX_BUILTIN_VEC_EXT_V1TI:\n       return altivec_expand_vec_ext_builtin (exp, target);\n \n+    case P9V_BUILTIN_VEXTRACT4B:\n+    case P9V_BUILTIN_VEC_VEXTRACT4B:\n+      arg1 = CALL_EXPR_ARG (exp, 1);\n+      STRIP_NOPS (arg1);\n+\n+      /* Generate a normal call if it is invalid.  */\n+      if (arg1 == error_mark_node)\n+\treturn expand_call (exp, target, false);\n+\n+      if (TREE_CODE (arg1) != INTEGER_CST || TREE_INT_CST_LOW (arg1) > 11)\n+\t{\n+\t  error (\"second argument to vec_vextract4b must 0..11\");\n+\t  return expand_call (exp, target, false);\n+\t}\n+      break;\n+\n+    case P9V_BUILTIN_VINSERT4B:\n+    case P9V_BUILTIN_VINSERT4B_DI:\n+    case P9V_BUILTIN_VEC_VINSERT4B:\n+      arg2 = CALL_EXPR_ARG (exp, 2);\n+      STRIP_NOPS (arg2);\n+\n+      /* Generate a normal call if it is invalid.  */\n+      if (arg2 == error_mark_node)\n+\treturn expand_call (exp, target, false);\n+\n+      if (TREE_CODE (arg2) != INTEGER_CST || TREE_INT_CST_LOW (arg2) > 11)\n+\t{\n+\t  error (\"third argument to vec_vinsert4b must 0..11\");\n+\t  return expand_call (exp, target, false);\n+\t}\n+      break;\n+\n     default:\n       break;\n       /* Fall through.  */"}, {"sha": "7aecbe6d64539ac7391eb879ef6017d40bb603e4", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 248, "deletions": 37, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16370e798cada94eb7af14b4a17c785241f19b18/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16370e798cada94eb7af14b4a17c785241f19b18/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=16370e798cada94eb7af14b4a17c785241f19b18", "patch": "@@ -119,13 +119,17 @@\n \t\t\t (V4SF  \"wf\")\n \t\t\t (DF    \"ws\")\n \t\t\t (SF\t\"ww\")\n-\t\t\t (DI\t\"wi\")])\n+\t\t\t (DI\t\"wi\")\n+\t\t\t (KF\t\"wq\")\n+\t\t\t (TF\t\"wp\")])\n \n (define_mode_attr VSr3\t[(V2DF  \"wa\")\n \t\t\t (V4SF  \"wa\")\n \t\t\t (DF    \"ws\")\n \t\t\t (SF\t\"ww\")\n-\t\t\t (DI\t\"wi\")])\n+\t\t\t (DI\t\"wi\")\n+\t\t\t (KF\t\"wq\")\n+\t\t\t (TF\t\"wp\")])\n \n ;; Map the register class for sp<->dp float conversions, destination\n (define_mode_attr VSr4\t[(SF\t\"ws\")\n@@ -298,6 +302,14 @@\n \t\t\t\t\t   || (FLOAT128_IEEE_P (TFmode)\n \t\t\t\t\t       && TARGET_FLOAT128_HW)\")])\n \n+;; Mode iterator for binary floating types that have a direct conversion\n+;; from 64-bit integer to floating point\n+(define_mode_iterator FL_CONV [SF\n+\t\t\t       DF\n+\t\t\t       (KF \"TARGET_FLOAT128_HW\")\n+\t\t\t       (TF \"TARGET_FLOAT128_HW\n+\t\t\t\t    && FLOAT128_IEEE_P (TFmode)\")])\n+\n ;; Iterator for the 2 short vector types to do a splat from an integer\n (define_mode_iterator VSX_SPLAT_I [V16QI V8HI])\n \n@@ -366,6 +378,8 @@\n    UNSPEC_VCMPNEZH\n    UNSPEC_VCMPNEW\n    UNSPEC_VCMPNEZW\n+   UNSPEC_XXEXTRACTUW\n+   UNSPEC_XXINSERTW\n   ])\n \n ;; VSX moves\n@@ -2535,63 +2549,98 @@\n })\n \n (define_insn \"vsx_extract_<mode>_p9\"\n-  [(set (match_operand:<VS_scalar> 0 \"gpc_reg_operand\" \"=<VSX_EX>\")\n+  [(set (match_operand:<VS_scalar> 0 \"gpc_reg_operand\" \"=r,<VSX_EX>\")\n \t(vec_select:<VS_scalar>\n-\t (match_operand:VSX_EXTRACT_I 1 \"gpc_reg_operand\" \"<VSX_EX>\")\n-\t (parallel [(match_operand:QI 2 \"<VSX_EXTRACT_PREDICATE>\" \"n\")])))]\n+\t (match_operand:VSX_EXTRACT_I 1 \"gpc_reg_operand\" \"wK,<VSX_EX>\")\n+\t (parallel [(match_operand:QI 2 \"<VSX_EXTRACT_PREDICATE>\" \"n,n\")])))\n+   (clobber (match_scratch:SI 3 \"=r,X\"))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode) && TARGET_VEXTRACTUB\n    && TARGET_VSX_SMALL_INTEGER\"\n {\n-  HOST_WIDE_INT elt = INTVAL (operands[2]);\n-  HOST_WIDE_INT elt_adj = (!VECTOR_ELT_ORDER_BIG\n-\t\t\t   ? GET_MODE_NUNITS (<MODE>mode) - 1 - elt\n-\t\t\t   : elt);\n-\n-  HOST_WIDE_INT unit_size = GET_MODE_UNIT_SIZE (<MODE>mode);\n-  HOST_WIDE_INT offset = unit_size * elt_adj;\n+  if (which_alternative == 0)\n+    return \"#\";\n \n-  operands[2] = GEN_INT (offset);\n-  if (unit_size == 4)\n-    return \"xxextractuw %x0,%x1,%2\";\n   else\n-    return \"vextractu<wd> %0,%1,%2\";\n+    {\n+      HOST_WIDE_INT elt = INTVAL (operands[2]);\n+      HOST_WIDE_INT elt_adj = (!VECTOR_ELT_ORDER_BIG\n+\t\t\t       ? GET_MODE_NUNITS (<MODE>mode) - 1 - elt\n+\t\t\t       : elt);\n+\n+      HOST_WIDE_INT unit_size = GET_MODE_UNIT_SIZE (<MODE>mode);\n+      HOST_WIDE_INT offset = unit_size * elt_adj;\n+\n+      operands[2] = GEN_INT (offset);\n+      if (unit_size == 4)\n+\treturn \"xxextractuw %x0,%x1,%2\";\n+      else\n+\treturn \"vextractu<wd> %0,%1,%2\";\n+    }\n }\n   [(set_attr \"type\" \"vecsimple\")])\n \n+(define_split\n+  [(set (match_operand:<VS_scalar> 0 \"int_reg_operand\")\n+\t(vec_select:<VS_scalar>\n+\t (match_operand:VSX_EXTRACT_I 1 \"altivec_register_operand\")\n+\t (parallel [(match_operand:QI 2 \"const_int_operand\")])))\n+   (clobber (match_operand:SI 3 \"int_reg_operand\"))]\n+  \"VECTOR_MEM_VSX_P (<MODE>mode) && TARGET_VEXTRACTUB\n+   && TARGET_VSX_SMALL_INTEGER && reload_completed\"\n+  [(const_int 0)]\n+{\n+  rtx op0_si = gen_rtx_REG (SImode, REGNO (operands[0]));\n+  rtx op1 = operands[1];\n+  rtx op2 = operands[2];\n+  rtx op3 = operands[3];\n+  HOST_WIDE_INT offset = INTVAL (op2) * GET_MODE_UNIT_SIZE (<MODE>mode);\n+\n+  emit_move_insn (op3, GEN_INT (offset));\n+  if (VECTOR_ELT_ORDER_BIG)\n+    emit_insn (gen_vextu<wd>lx (op0_si, op3, op1));\n+  else\n+    emit_insn (gen_vextu<wd>rx (op0_si, op3, op1));\n+  DONE;\n+})\n+\n ;; Optimize zero extracts to eliminate the AND after the extract.\n (define_insn_and_split \"*vsx_extract_<mode>_di_p9\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=<VSX_EX>\")\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,<VSX_EX>\")\n \t(zero_extend:DI\n \t (vec_select:<VS_scalar>\n-\t  (match_operand:VSX_EXTRACT_I 1 \"gpc_reg_operand\" \"<VSX_EX>\")\n-\t  (parallel [(match_operand:QI 2 \"const_int_operand\" \"n\")]))))]\n+\t  (match_operand:VSX_EXTRACT_I 1 \"gpc_reg_operand\" \"wK,<VSX_EX>\")\n+\t  (parallel [(match_operand:QI 2 \"const_int_operand\" \"n,n\")]))))\n+   (clobber (match_scratch:SI 3 \"=r,X\"))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode) && TARGET_VEXTRACTUB\n    && TARGET_VSX_SMALL_INTEGER\"\n   \"#\"\n   \"&& reload_completed\"\n-  [(set (match_dup 3)\n-\t(vec_select:<VS_scalar>\n-\t (match_dup 1)\n-\t (parallel [(match_dup 2)])))]\n+  [(parallel [(set (match_dup 4)\n+\t\t   (vec_select:<VS_scalar>\n+\t\t    (match_dup 1)\n+\t\t    (parallel [(match_dup 2)])))\n+\t      (clobber (match_dup 3))])]\n {\n-  operands[3] = gen_rtx_REG (<VS_scalar>mode, REGNO (operands[0]));\n+  operands[4] = gen_rtx_REG (<VS_scalar>mode, REGNO (operands[0]));\n })\n \n ;; Optimize stores to use the ISA 3.0 scalar store instructions\n (define_insn_and_split \"*vsx_extract_<mode>_store_p9\"\n-  [(set (match_operand:<VS_scalar> 0 \"memory_operand\" \"=Z\")\n+  [(set (match_operand:<VS_scalar> 0 \"memory_operand\" \"=Z,m\")\n \t(vec_select:<VS_scalar>\n-\t (match_operand:VSX_EXTRACT_I 1 \"gpc_reg_operand\" \"<VSX_EX>\")\n-\t (parallel [(match_operand:QI 2 \"const_int_operand\" \"n\")])))\n-   (clobber (match_scratch:<VS_scalar> 3 \"=<VSX_EX>\"))]\n+\t (match_operand:VSX_EXTRACT_I 1 \"gpc_reg_operand\" \"<VSX_EX>,<VSX_EX>\")\n+\t (parallel [(match_operand:QI 2 \"const_int_operand\" \"n,n\")])))\n+   (clobber (match_scratch:<VS_scalar> 3 \"=<VSX_EX>,&r\"))\n+   (clobber (match_scratch:SI 4 \"=X,&r\"))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode) && TARGET_VEXTRACTUB\n    && TARGET_VSX_SMALL_INTEGER\"\n   \"#\"\n   \"&& reload_completed\"\n-  [(set (match_dup 3)\n-\t(vec_select:<VS_scalar>\n-\t (match_dup 1)\n-\t (parallel [(match_dup 2)])))\n+  [(parallel [(set (match_dup 3)\n+\t\t   (vec_select:<VS_scalar>\n+\t\t    (match_dup 1)\n+\t\t    (parallel [(match_dup 2)])))\n+\t      (clobber (match_dup 4))])\n    (set (match_dup 0)\n \t(match_dup 3))])\n \n@@ -2721,13 +2770,13 @@\n \n ;; Variable V16QI/V8HI/V4SI extract\n (define_insn_and_split \"vsx_extract_<mode>_var\"\n-  [(set (match_operand:<VS_scalar> 0 \"gpc_reg_operand\" \"=r,r\")\n+  [(set (match_operand:<VS_scalar> 0 \"gpc_reg_operand\" \"=r,r,r\")\n \t(unspec:<VS_scalar>\n-\t [(match_operand:VSX_EXTRACT_I 1 \"input_operand\" \"v,m\")\n-\t  (match_operand:DI 2 \"gpc_reg_operand\" \"r,r\")]\n+\t [(match_operand:VSX_EXTRACT_I 1 \"input_operand\" \"wK,v,m\")\n+\t  (match_operand:DI 2 \"gpc_reg_operand\" \"r,r,r\")]\n \t UNSPEC_VSX_EXTRACT))\n-   (clobber (match_scratch:DI 3 \"=r,&b\"))\n-   (clobber (match_scratch:V2DI 4 \"=&v,X\"))]\n+   (clobber (match_scratch:DI 3 \"=r,r,&b\"))\n+   (clobber (match_scratch:V2DI 4 \"=X,&v,X\"))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode) && TARGET_DIRECT_MOVE_64BIT\"\n   \"#\"\n   \"&& reload_completed\"\n@@ -2738,6 +2787,27 @@\n   DONE;\n })\n \n+(define_insn_and_split \"*vsx_extract_<VSX_EXTRACT_I:mode>_<SDI:mode>_var\"\n+  [(set (match_operand:SDI 0 \"gpc_reg_operand\" \"=r,r,r\")\n+\t(zero_extend:SDI\n+\t (unspec:<VSX_EXTRACT_I:VS_scalar>\n+\t  [(match_operand:VSX_EXTRACT_I 1 \"input_operand\" \"wK,v,m\")\n+\t   (match_operand:DI 2 \"gpc_reg_operand\" \"r,r,r\")]\n+\t  UNSPEC_VSX_EXTRACT)))\n+   (clobber (match_scratch:DI 3 \"=r,r,&b\"))\n+   (clobber (match_scratch:V2DI 4 \"=X,&v,X\"))]\n+  \"VECTOR_MEM_VSX_P (<VSX_EXTRACT_I:MODE>mode) && TARGET_DIRECT_MOVE_64BIT\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+{\n+  machine_mode smode = <VSX_EXTRACT_I:MODE>mode;\n+  rs6000_split_vec_extract_var (gen_rtx_REG (smode, REGNO (operands[0])),\n+\t\t\t\toperands[1], operands[2],\n+\t\t\t\toperands[3], operands[4]);\n+  DONE;\n+})\n+\n ;; VSX_EXTRACT optimizations\n ;; Optimize double d = (double) vec_extract (vi, <n>)\n ;; Get the element into the top position and use XVCVSWDP/XVCVUWDP\n@@ -2839,6 +2909,56 @@\n   DONE;\n })\n \n+;; Optimize <type> f = (<ftype>) vec_extract (<vtype>, <n>)\n+;; Where <ftype> is SFmode, DFmode (and KFmode/TFmode if those types are IEEE\n+;; 128-bit hardware types) and <vtype> is vector char, vector unsigned char,\n+;; vector short or vector unsigned short.\n+(define_insn_and_split \"*vsx_ext_<VSX_EXTRACT_I:VS_scalar>_fl_<FL_CONV:mode>\"\n+  [(set (match_operand:FL_CONV 0 \"gpc_reg_operand\" \"=<FL_CONV:VSr3>\")\n+\t(float:FL_CONV\n+\t (vec_select:<VSX_EXTRACT_I:VS_scalar>\n+\t  (match_operand:VSX_EXTRACT_I 1 \"gpc_reg_operand\" \"v\")\n+\t  (parallel [(match_operand:QI 2 \"const_int_operand\" \"n\")]))))\n+   (clobber (match_scratch:<VSX_EXTRACT_I:VS_scalar> 3 \"=v\"))]\n+  \"VECTOR_MEM_VSX_P (<VSX_EXTRACT_I:MODE>mode) && TARGET_DIRECT_MOVE_64BIT\n+   && TARGET_P9_VECTOR && TARGET_VSX_SMALL_INTEGER\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (match_dup 3)\n+\t\t   (vec_select:<VSX_EXTRACT_I:VS_scalar>\n+\t\t    (match_dup 1)\n+\t\t    (parallel [(match_dup 2)])))\n+\t      (clobber (scratch:SI))])\n+   (set (match_dup 4)\n+\t(sign_extend:DI (match_dup 3)))\n+   (set (match_dup 0)\n+\t(float:<FL_CONV:MODE> (match_dup 4)))]\n+{\n+  operands[4] = gen_rtx_REG (DImode, REGNO (operands[3]));\n+})\n+\n+(define_insn_and_split \"*vsx_ext_<VSX_EXTRACT_I:VS_scalar>_ufl_<FL_CONV:mode>\"\n+  [(set (match_operand:FL_CONV 0 \"gpc_reg_operand\" \"=<FL_CONV:VSr3>\")\n+\t(unsigned_float:FL_CONV\n+\t (vec_select:<VSX_EXTRACT_I:VS_scalar>\n+\t  (match_operand:VSX_EXTRACT_I 1 \"gpc_reg_operand\" \"v\")\n+\t  (parallel [(match_operand:QI 2 \"const_int_operand\" \"n\")]))))\n+   (clobber (match_scratch:<VSX_EXTRACT_I:VS_scalar> 3 \"=v\"))]\n+  \"VECTOR_MEM_VSX_P (<VSX_EXTRACT_I:MODE>mode) && TARGET_DIRECT_MOVE_64BIT\n+   && TARGET_P9_VECTOR && TARGET_VSX_SMALL_INTEGER\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (match_dup 3)\n+\t\t   (vec_select:<VSX_EXTRACT_I:VS_scalar>\n+\t\t    (match_dup 1)\n+\t\t    (parallel [(match_dup 2)])))\n+\t      (clobber (scratch:SI))])\n+   (set (match_dup 0)\n+\t(float:<FL_CONV:MODE> (match_dup 4)))]\n+{\n+  operands[4] = gen_rtx_REG (DImode, REGNO (operands[3]));\n+})\n+\n ;; V4SI/V8HI/V16QI set operation on ISA 3.0\n (define_insn \"vsx_set_<mode>_p9\"\n   [(set (match_operand:VSX_EXTRACT_I 0 \"gpc_reg_operand\" \"=<VSX_EX>\")\n@@ -3686,3 +3806,94 @@\n   \"TARGET_P9_VECTOR\"\n   \"vextuwrx %0,%1,%2\"\n   [(set_attr \"type\" \"vecsimple\")])\n+\n+;; Vector insert/extract word at arbitrary byte values.  Note, the little\n+;; endian version needs to adjust the byte number, and the V4SI element in\n+;; vinsert4b.\n+(define_expand \"vextract4b\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\")\n+\t(unspec:DI [(match_operand:V16QI 1 \"vsx_register_operand\")\n+\t\t    (match_operand:QI 2 \"const_0_to_11_operand\")]\n+\t\t   UNSPEC_XXEXTRACTUW))]\n+  \"TARGET_P9_VECTOR\"\n+{\n+  if (!VECTOR_ELT_ORDER_BIG)\n+    operands[2] = GEN_INT (12 - INTVAL (operands[2]));\n+})\n+\n+(define_insn_and_split \"*vextract4b_internal\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=wj,r\")\n+\t(unspec:DI [(match_operand:V16QI 1 \"vsx_register_operand\" \"wa,v\")\n+\t\t    (match_operand:QI 2 \"const_0_to_11_operand\" \"n,n\")]\n+\t\t   UNSPEC_XXEXTRACTUW))]\n+  \"TARGET_P9_VECTOR\"\n+  \"@\n+   xxextractuw %x0,%x1,%2\n+   #\"\n+  \"&& reload_completed && int_reg_operand (operands[0], DImode)\"\n+  [(const_int 0)]\n+{\n+  rtx op0 = operands[0];\n+  rtx op1 = operands[1];\n+  rtx op2 = operands[2];\n+  rtx op0_si = gen_rtx_REG (SImode, REGNO (op0));\n+  rtx op1_v4si = gen_rtx_REG (V4SImode, REGNO (op1));\n+\n+  emit_move_insn (op0, op2);\n+  if (VECTOR_ELT_ORDER_BIG)\n+    emit_insn (gen_vextuwlx (op0_si, op0_si, op1_v4si));\n+  else\n+    emit_insn (gen_vextuwrx (op0_si, op0_si, op1_v4si));\n+  DONE;\n+}\n+  [(set_attr \"type\" \"vecperm\")])\n+\n+(define_expand \"vinsert4b\"\n+  [(set (match_operand:V16QI 0 \"vsx_register_operand\")\n+\t(unspec:V16QI [(match_operand:V4SI 1 \"vsx_register_operand\")\n+\t\t       (match_operand:V16QI 2 \"vsx_register_operand\")\n+\t\t       (match_operand:QI 3 \"const_0_to_11_operand\")]\n+\t\t   UNSPEC_XXINSERTW))]\n+  \"TARGET_P9_VECTOR\"\n+{\n+  if (!VECTOR_ELT_ORDER_BIG)\n+    {\n+      rtx op1 = operands[1];\n+      rtx v4si_tmp = gen_reg_rtx (V4SImode);\n+      emit_insn (gen_vsx_xxpermdi_v4si (v4si_tmp, op1, op1, const1_rtx));\n+      operands[1] = v4si_tmp;\n+      operands[3] = GEN_INT (12 - INTVAL (operands[3]));\n+    }\n+})\n+\n+(define_insn \"*vinsert4b_internal\"\n+  [(set (match_operand:V16QI 0 \"vsx_register_operand\" \"=wa\")\n+\t(unspec:V16QI [(match_operand:V4SI 1 \"vsx_register_operand\" \"wa\")\n+\t\t       (match_operand:V16QI 2 \"vsx_register_operand\" \"0\")\n+\t\t       (match_operand:QI 3 \"const_0_to_11_operand\" \"n\")]\n+\t\t   UNSPEC_XXINSERTW))]\n+  \"TARGET_P9_VECTOR\"\n+  \"xxinsertw %x0,%x1,%3\"\n+  [(set_attr \"type\" \"vecperm\")])\n+\n+(define_expand \"vinsert4b_di\"\n+  [(set (match_operand:V16QI 0 \"vsx_register_operand\")\n+\t(unspec:V16QI [(match_operand:DI 1 \"vsx_register_operand\")\n+\t\t       (match_operand:V16QI 2 \"vsx_register_operand\")\n+\t\t       (match_operand:QI 3 \"const_0_to_11_operand\")]\n+\t\t   UNSPEC_XXINSERTW))]\n+  \"TARGET_P9_VECTOR\"\n+{\n+  if (!VECTOR_ELT_ORDER_BIG)\n+    operands[3] = GEN_INT (12 - INTVAL (operands[3]));\n+})\n+\n+(define_insn \"*vinsert4b_di_internal\"\n+  [(set (match_operand:V16QI 0 \"vsx_register_operand\" \"=wa\")\n+\t(unspec:V16QI [(match_operand:DI 1 \"vsx_register_operand\" \"wj\")\n+\t\t       (match_operand:V16QI 2 \"vsx_register_operand\" \"0\")\n+\t\t       (match_operand:QI 3 \"const_0_to_11_operand\" \"n\")]\n+\t\t   UNSPEC_XXINSERTW))]\n+  \"TARGET_P9_VECTOR\"\n+  \"xxinsertw %x0,%x1,%3\"\n+  [(set_attr \"type\" \"vecperm\")])"}, {"sha": "23b8898ad5a7c3d25e7a39b0b24a6248fe2f838e", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16370e798cada94eb7af14b4a17c785241f19b18/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16370e798cada94eb7af14b4a17c785241f19b18/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=16370e798cada94eb7af14b4a17c785241f19b18", "patch": "@@ -17995,6 +17995,15 @@ vector unsigned short vec_vctzh (vector unsigned short);\n vector int vec_vctzw (vector int);\n vector unsigned int vec_vctzw (vector int);\n \n+long long vec_vextract4b (const vector signed char, const int);\n+long long vec_vextract4b (const vector unsigned char, const int);\n+\n+vector signed char vec_insert4b (vector int, vector signed char, const int);\n+vector unsigned char vec_insert4b (vector unsigned int, vector unsigned char,\n+                                   const int);\n+vector signed char vec_insert4b (long long, vector signed char, const int);\n+vector unsigned char vec_insert4b (long long, vector unsigned char, const int);\n+\n vector int vec_vprtyb (vector int);\n vector unsigned int vec_vprtyb (vector unsigned int);\n vector long long vec_vprtyb (vector long long);"}, {"sha": "9f7fa7e43c72fe0af193d316fa5c6be53a28b816", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16370e798cada94eb7af14b4a17c785241f19b18/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16370e798cada94eb7af14b4a17c785241f19b18/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=16370e798cada94eb7af14b4a17c785241f19b18", "patch": "@@ -1,3 +1,26 @@\n+2016-12-14  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* gcc/testsuite/gcc.target/powerpc/vec-extract.h: If DO_TRACE is\n+\tdefined, add tracing of the various extracts to stderr.  Add\n+\tsupport for tests that convert the result to another type.\n+\t* gcc/testsuite/gcc.target/powerpc/vec-extract-v2df.c: Likewise.\n+\t* gcc/testsuite/gcc.target/powerpc/vec-extract-v4sf.c: Likewise.\n+\t* gcc/testsuite/gcc.target/powerpc/vec-extract-v4si-df.c: Add new\n+\ttests that do an extract and then convert the values double.\n+\t* gcc/testsuite/gcc.target/powerpc/vec-extract-v4siu-df.c: Likewise.\n+\t* gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-df.c: Likewise.\n+\t* gcc/testsuite/gcc.target/powerpc/vec-extract-v16qi-df.c: Likewise.\n+\t* gcc/testsuite/gcc.target/powerpc/vec-extract-v8hiu-df.c: Likewise.\n+\t* gcc/testsuite/gcc.target/powerpc/vec-extract-v8hi-df.c: Likewise.\n+\t* gcc.target/powerpc/p9-extract-1.c: Update test to check for\n+\tVEXTU{B,H,W}{L,R}X instructions being generated by default instead\n+\tof VEXTRACTU{B,H} and XXEXTRACTUW.\n+\t* gcc.target/powerpc/p9-extract-3.c: New test for combination of\n+\tvec_extract and convert to floating point.\n+\t* gcc.target/powerpc/p9-vinsert4b-1.c: New test for vec_vinsert4b\n+\tand vec_extract4b.\n+\t* gcc.target/powerpc/p9-vinsert4b-2.c: Likewise.\n+\n 2016-12-14  Toma Tabacu  <toma.tabacu@imgtec.com>\n \n \t* gcc.target/mips/mips16-attributes.c: Remove dg-skip-if for"}, {"sha": "ecbe0ed660d5c2111859e2fb1190bf4c34260261", "filename": "gcc/testsuite/gcc.target/powerpc/p9-extract-1.c", "status": "modified", "additions": 102, "deletions": 19, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16370e798cada94eb7af14b4a17c785241f19b18/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-extract-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16370e798cada94eb7af14b4a17c785241f19b18/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-extract-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-extract-1.c?ref=16370e798cada94eb7af14b4a17c785241f19b18", "patch": "@@ -3,24 +3,107 @@\n /* { dg-require-effective-target powerpc_p9vector_ok } */\n /* { dg-options \"-mcpu=power9 -O2\" } */\n \n+/* Test to make sure VEXTU{B,H,W}{L,R}X is generated for various vector extract\n+   operations for ISA 3.0 (-mcpu=power9).  In addition, make sure that neither\n+   of the the the old methods of doing vector extracts are done either by\n+   explict stores to the stack or by using direct move instructions.  */\n+\n #include <altivec.h>\n \n-int extract_int_0 (vector int a) { return vec_extract (a, 0); }\n-int extract_int_3 (vector int a) { return vec_extract (a, 3); }\n-\n-int extract_short_0 (vector short a) { return vec_extract (a, 0); }\n-int extract_short_3 (vector short a) { return vec_extract (a, 7); }\n-\n-int extract_schar_0 (vector signed char a) { return vec_extract (a, 0); }\n-int extract_schar_3 (vector signed char a) { return vec_extract (a, 15); }\n-\n-/* { dg-final { scan-assembler     \"vextractub\"  } } */\n-/* { dg-final { scan-assembler     \"vextractuh\"  } } */\n-/* { dg-final { scan-assembler     \"xxextractuw\" } } */\n-/* { dg-final { scan-assembler     \"mfvsr\"       } } */\n-/* { dg-final { scan-assembler-not \"stxvd2x\"     } } */\n-/* { dg-final { scan-assembler-not \"stxv\"        } } */\n-/* { dg-final { scan-assembler-not \"lwa\"         } } */\n-/* { dg-final { scan-assembler-not \"lwz\"         } } */\n-/* { dg-final { scan-assembler-not \"lha\"         } } */\n-/* { dg-final { scan-assembler-not \"lhz\"         } } */\n+int\n+extract_int_0 (vector int a)\n+{\n+  int b = vec_extract (a, 0);\n+  return b;\n+}\n+\n+int\n+extract_int_3 (vector int a)\n+{\n+  int b = vec_extract (a, 3);\n+  return b;\n+}\n+\n+unsigned int\n+extract_uint_0 (vector unsigned int a)\n+{\n+  unsigned int b = vec_extract (a, 0);\n+  return b;\n+}\n+\n+unsigned int\n+extract_uint_3 (vector unsigned int a)\n+{\n+  unsigned int b = vec_extract (a, 3);\n+  return b;\n+}\n+\n+short\n+extract_short_0 (vector short a)\n+{\n+  short b = vec_extract (a, 0);\n+  return b;\n+}\n+\n+short\n+extract_short_7 (vector short a)\n+{\n+  short b = vec_extract (a, 7);\n+  return b;\n+}\n+\n+unsigned short\n+extract_ushort_0 (vector unsigned short a)\n+{\n+  unsigned short b = vec_extract (a, 0);\n+  return b;\n+}\n+\n+unsigned short\n+extract_ushort_7 (vector unsigned short a)\n+{\n+  unsigned short b = vec_extract (a, 7);\n+  return b;\n+}\n+\n+signed char\n+extract_schar_0 (vector signed char a)\n+{\n+  signed char b = vec_extract (a, 0);\n+  return b;\n+}\n+\n+signed char\n+extract_schar_15 (vector signed char a)\n+{\n+  signed char b = vec_extract (a, 15);\n+  return b;\n+}\n+\n+unsigned char\n+extract_uchar_0 (vector unsigned char a)\n+{\n+  unsigned char b = vec_extract (a, 0);\n+  return b;\n+}\n+\n+unsigned char\n+extract_uchar_15 (vector unsigned char a)\n+{\n+  signed char b = vec_extract (a, 15);\n+  return b;\n+}\n+\n+/* { dg-final { scan-assembler     \"vextub\\[lr\\]x \" } } */\n+/* { dg-final { scan-assembler     \"vextuh\\[lr\\]x \" } } */\n+/* { dg-final { scan-assembler     \"vextuw\\[lr\\]x \" } } */\n+/* { dg-final { scan-assembler     \"extsb \"         } } */\n+/* { dg-final { scan-assembler     \"extsh \"         } } */\n+/* { dg-final { scan-assembler     \"extsw \"         } } */\n+/* { dg-final { scan-assembler-not \"m\\[ft\\]vsr\"     } } */\n+/* { dg-final { scan-assembler-not \"stxvd2x \"       } } */\n+/* { dg-final { scan-assembler-not \"stxv \"          } } */\n+/* { dg-final { scan-assembler-not \"lwa \"           } } */\n+/* { dg-final { scan-assembler-not \"lwz \"           } } */\n+/* { dg-final { scan-assembler-not \"lha \"           } } */\n+/* { dg-final { scan-assembler-not \"lhz \"           } } */"}, {"sha": "90b3eae83a0c5250f547d877a6f99f18add4995d", "filename": "gcc/testsuite/gcc.target/powerpc/p9-extract-3.c", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16370e798cada94eb7af14b4a17c785241f19b18/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-extract-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16370e798cada94eb7af14b4a17c785241f19b18/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-extract-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-extract-3.c?ref=16370e798cada94eb7af14b4a17c785241f19b18", "patch": "@@ -0,0 +1,108 @@\n+/* { dg-do compile { target { powerpc64*-*-* && lp64 } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9 -O2\" } */\n+\n+/* Test that under ISA 3.0 (-mcpu=power9), the compiler optimizes conversion to\n+   double after a vec_extract to use the VEXTRACTU{B,H} or XXEXTRACTUW\n+   instructions (which leaves the result in a vector register), and not the\n+   VEXTU{B,H,W}{L,R}X instructions (which needs a direct move to do the floating\n+   point conversion).  */\n+\n+#include <altivec.h>\n+\n+double\n+fpcvt_int_0 (vector int a)\n+{\n+  int b = vec_extract (a, 0);\n+  return (double)b;\n+}\n+\n+double\n+fpcvt_int_3 (vector int a)\n+{\n+  int b = vec_extract (a, 3);\n+  return (double)b;\n+}\n+\n+double\n+fpcvt_uint_0 (vector unsigned int a)\n+{\n+  unsigned int b = vec_extract (a, 0);\n+  return (double)b;\n+}\n+\n+double\n+fpcvt_uint_3 (vector unsigned int a)\n+{\n+  unsigned int b = vec_extract (a, 3);\n+  return (double)b;\n+}\n+\n+double\n+fpcvt_short_0 (vector short a)\n+{\n+  short b = vec_extract (a, 0);\n+  return (double)b;\n+}\n+\n+double\n+fpcvt_short_7 (vector short a)\n+{\n+  short b = vec_extract (a, 7);\n+  return (double)b;\n+}\n+\n+double\n+fpcvt_ushort_0 (vector unsigned short a)\n+{\n+  unsigned short b = vec_extract (a, 0);\n+  return (double)b;\n+}\n+\n+double\n+fpcvt_ushort_7 (vector unsigned short a)\n+{\n+  unsigned short b = vec_extract (a, 7);\n+  return (double)b;\n+}\n+\n+double\n+fpcvt_schar_0 (vector signed char a)\n+{\n+  signed char b = vec_extract (a, 0);\n+  return (double)b;\n+}\n+\n+double\n+fpcvt_schar_15 (vector signed char a)\n+{\n+  signed char b = vec_extract (a, 15);\n+  return (double)b;\n+}\n+\n+double\n+fpcvt_uchar_0 (vector unsigned char a)\n+{\n+  unsigned char b = vec_extract (a, 0);\n+  return (double)b;\n+}\n+\n+double\n+fpcvt_uchar_15 (vector unsigned char a)\n+{\n+  signed char b = vec_extract (a, 15);\n+  return (double)b;\n+}\n+\n+/* { dg-final { scan-assembler     \"vextractu\\[bh\\] \"    } } */\n+/* { dg-final { scan-assembler     \"vexts\\[bh\\]2d \"      } } */\n+/* { dg-final { scan-assembler     \"vspltw \"             } } */\n+/* { dg-final { scan-assembler     \"xscvsxddp \"          } } */\n+/* { dg-final { scan-assembler     \"xvcvsxwdp \"          } } */\n+/* { dg-final { scan-assembler     \"xvcvuxwdp \"          } } */\n+/* { dg-final { scan-assembler-not \"exts\\[bhw\\] \"        } } */\n+/* { dg-final { scan-assembler-not \"stxv\"                } } */\n+/* { dg-final { scan-assembler-not \"m\\[ft\\]vsrd \"        } } */\n+/* { dg-final { scan-assembler-not \"m\\[ft\\]vsrw\\[az\\] \"  } } */\n+/* { dg-final { scan-assembler-not \"l\\[hw\\]\\[az\\] \"      } } */"}, {"sha": "fa1ba75470567cb3c71d988e7dc56cb7f62c1523", "filename": "gcc/testsuite/gcc.target/powerpc/p9-vinsert4b-1.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16370e798cada94eb7af14b4a17c785241f19b18/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-vinsert4b-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16370e798cada94eb7af14b4a17c785241f19b18/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-vinsert4b-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-vinsert4b-1.c?ref=16370e798cada94eb7af14b4a17c785241f19b18", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do compile { target { powerpc64*-*-* && lp64 } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9 -O2\" } */\n+\n+#include <altivec.h>\n+\n+vector signed char\n+vins_v4si (vector int *vi, vector signed char *vc)\n+{\n+  return vec_vinsert4b (*vi, *vc, 1);\n+}\n+\n+vector unsigned char\n+vins_di (long di, vector unsigned char *vc)\n+{\n+  return vec_vinsert4b (di, *vc, 2);\n+}\n+\n+vector char\n+vins_di2 (long *p_di, vector char *vc)\n+{\n+  return vec_vinsert4b (*p_di, *vc, 3);\n+}\n+\n+vector unsigned char\n+vins_di0 (vector unsigned char *vc)\n+{\n+  return vec_vinsert4b (0, *vc, 4);\n+}\n+\n+long\n+vext (vector signed char *vc)\n+{\n+  return vec_vextract4b (*vc, 5);\n+}\n+\n+/* { dg-final { scan-assembler \"xxextractuw\\|vextuw\\[lr\\]x\" } } */\n+/* { dg-final { scan-assembler \"xxinsertw\" } } */"}, {"sha": "653f6e0c5e59faca2daf6c346fee9d58bf5a8b86", "filename": "gcc/testsuite/gcc.target/powerpc/p9-vinsert4b-2.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16370e798cada94eb7af14b4a17c785241f19b18/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-vinsert4b-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16370e798cada94eb7af14b4a17c785241f19b18/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-vinsert4b-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-vinsert4b-2.c?ref=16370e798cada94eb7af14b4a17c785241f19b18", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do compile { target { powerpc64*-*-* && lp64 } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9 -O2\" } */\n+\n+#include <altivec.h>\n+\n+vector signed char\n+ins_v4si (vector int vi, vector signed char vc)\n+{\n+  return vec_vinsert4b (vi, vc, 12);\t/* { dg-error \"vec_vinsert4b\" } */\n+}\n+\n+vector unsigned char\n+ins_di (long di, vector unsigned char vc, long n)\n+{\n+  return vec_vinsert4b (di, vc, n);\t/* { dg-error \"vec_vinsert4b\" } */\n+}\n+\n+long\n+vext1 (vector signed char vc)\n+{\n+  return vec_vextract4b (vc, 12);\t/* { dg-error \"vec_vextract4b\" } */\n+}\n+\n+long\n+vextn (vector unsigned char vc, long n)\n+{\n+  return vec_vextract4b (vc, n);\t/* { dg-error \"vec_vextract4b\" } */\n+}"}, {"sha": "cfcb8d7753e3b99b6c6918a4e90eaba4146017af", "filename": "gcc/testsuite/gcc.target/powerpc/vec-extract-v16qi-df.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16370e798cada94eb7af14b4a17c785241f19b18/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v16qi-df.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16370e798cada94eb7af14b4a17c785241f19b18/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v16qi-df.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v16qi-df.c?ref=16370e798cada94eb7af14b4a17c785241f19b18", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-O2 -mvsx\" } */\n+\n+#define TYPE signed char\n+#define RTYPE double\n+#define FAIL_FORMAT \"%g\"\n+#define FAIL_CAST(X) ((double)(X))\n+#define ELEMENTS 16\n+#define INITIAL \\\n+  {  10,  -20,  30,  -40, 50, -60, 70, -80, \\\n+     90, -100, 110, -120, 30, -40, 50, -60 }\n+\n+#include \"vec-extract.h\""}, {"sha": "514de253a755b7f991e6b086ec6c1bc1f07ea450", "filename": "gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-df.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16370e798cada94eb7af14b4a17c785241f19b18/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v16qiu-df.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16370e798cada94eb7af14b4a17c785241f19b18/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v16qiu-df.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v16qiu-df.c?ref=16370e798cada94eb7af14b4a17c785241f19b18", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-O2 -mvsx\" } */\n+\n+#define TYPE unsigned char\n+#define RTYPE double\n+#define FAIL_FORMAT \"%g\"\n+#define FAIL_CAST(X) ((double)(X))\n+#define ELEMENTS 16\n+#define INITIAL \\\n+  {  1, 2, 3, 4, 5, 6, 7, 8, 240, 241, 242, 243, 244, 245, 246, 247 }\n+\n+#include \"vec-extract.h\""}, {"sha": "34c9b00b9338e656b0a46d0be201f300d94ea40b", "filename": "gcc/testsuite/gcc.target/powerpc/vec-extract-v2df.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16370e798cada94eb7af14b4a17c785241f19b18/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v2df.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16370e798cada94eb7af14b4a17c785241f19b18/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v2df.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v2df.c?ref=16370e798cada94eb7af14b4a17c785241f19b18", "patch": "@@ -3,6 +3,8 @@\n /* { dg-options \"-O2 -mvsx\" } */\n \n #define TYPE double\n+#define FAIL_FORMAT \"%g\"\n+#define FAIL_CAST(X) ((double)(X))\n #define ELEMENTS 2\n #define INITIAL { 10.0, -20.0 }\n "}, {"sha": "518ff4ab73df7a47235961b1a4b054d08ce2a44a", "filename": "gcc/testsuite/gcc.target/powerpc/vec-extract-v4sf.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16370e798cada94eb7af14b4a17c785241f19b18/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v4sf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16370e798cada94eb7af14b4a17c785241f19b18/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v4sf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v4sf.c?ref=16370e798cada94eb7af14b4a17c785241f19b18", "patch": "@@ -3,6 +3,8 @@\n /* { dg-options \"-O2 -mvsx\" } */\n \n #define TYPE float\n+#define FAIL_FORMAT \"%g\"\n+#define FAIL_CAST(X) ((double)(X))\n #define ELEMENTS 4\n #define INITIAL { 10.0f, -20.0f, 30.0f, -40.0f }\n "}, {"sha": "afcc7de856d32684e3046054202fe3090df04411", "filename": "gcc/testsuite/gcc.target/powerpc/vec-extract-v4si-df.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16370e798cada94eb7af14b4a17c785241f19b18/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v4si-df.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16370e798cada94eb7af14b4a17c785241f19b18/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v4si-df.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v4si-df.c?ref=16370e798cada94eb7af14b4a17c785241f19b18", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-O2 -mvsx\" } */\n+\n+#define TYPE int\n+#define RTYPE double\n+#define FAIL_FORMAT \"%g\"\n+#define FAIL_CAST(X) ((double)(X))\n+#define ELEMENTS 4\n+#define INITIAL { 10, -20, 30, -40 }\n+\n+#include \"vec-extract.h\""}, {"sha": "071e492eb39df4efc6e4b03d9ea901923f1b80ba", "filename": "gcc/testsuite/gcc.target/powerpc/vec-extract-v4siu-df.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16370e798cada94eb7af14b4a17c785241f19b18/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v4siu-df.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16370e798cada94eb7af14b4a17c785241f19b18/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v4siu-df.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v4siu-df.c?ref=16370e798cada94eb7af14b4a17c785241f19b18", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-O2 -mvsx\" } */\n+\n+#define TYPE unsigned int\n+#define RTYPE double\n+#define FAIL_FORMAT \"%g\"\n+#define FAIL_CAST(X) ((double)(X))\n+#define ELEMENTS 4\n+#define INITIAL { 1, 2, 0xff03, 0xff04 }\n+\n+#include \"vec-extract.h\""}, {"sha": "4a15fb6bfd582e0b0a0304870b9f44931c92b028", "filename": "gcc/testsuite/gcc.target/powerpc/vec-extract-v8hi-df.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16370e798cada94eb7af14b4a17c785241f19b18/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v8hi-df.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16370e798cada94eb7af14b4a17c785241f19b18/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v8hi-df.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v8hi-df.c?ref=16370e798cada94eb7af14b4a17c785241f19b18", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-O2 -mvsx\" } */\n+\n+#define TYPE short\n+#define RTYPE double\n+#define FAIL_FORMAT \"%g\"\n+#define FAIL_CAST(X) ((double)(X))\n+#define ELEMENTS 8\n+#define INITIAL { 10, -20, 30, -40, 50, -60, 70, 80 }\n+\n+#include \"vec-extract.h\""}, {"sha": "ff45c172bf09a7604281190aa04c93af718d2320", "filename": "gcc/testsuite/gcc.target/powerpc/vec-extract-v8hiu-df.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16370e798cada94eb7af14b4a17c785241f19b18/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v8hiu-df.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16370e798cada94eb7af14b4a17c785241f19b18/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v8hiu-df.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v8hiu-df.c?ref=16370e798cada94eb7af14b4a17c785241f19b18", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-O2 -mvsx\" } */\n+\n+#define TYPE unsigned short\n+#define RTYPE double\n+#define FAIL_FORMAT \"%g\"\n+#define FAIL_CAST(X) ((double)(X))\n+#define ELEMENTS 8\n+#define INITIAL { 1, 2, 3, 4, 0xf1, 0xf2, 0xf3, 0xf4 }\n+\n+#include \"vec-extract.h\""}, {"sha": "a6f2dc48b3d83bab1c310e2d29a656a92bf0a9b3", "filename": "gcc/testsuite/gcc.target/powerpc/vec-extract.h", "status": "modified", "additions": 313, "deletions": 257, "changes": 570, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16370e798cada94eb7af14b4a17c785241f19b18/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16370e798cada94eb7af14b4a17c785241f19b18/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract.h?ref=16370e798cada94eb7af14b4a17c785241f19b18", "patch": "@@ -2,16 +2,53 @@\n #include <stddef.h>\n #include <altivec.h>\n \n+#ifndef RTYPE\n+#define RTYPE TYPE\n+#endif\n+\n+#ifdef DO_TRACE\n+#include <stdio.h>\n+\n+#define TRACE(STRING, NUM)\t\t\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    fprintf (stderr, \"%s%s: %2d\\n\", (NUM == 0) ? \"\\n\" : \"\",\t\t\\\n+\t     STRING, (int)NUM);\t\t\t\t\t\t\\\n+    fflush (stderr);\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n+#ifndef FAIL_FORMAT\n+#define FAIL_FORMAT \"%ld\"\n+#define FAIL_CAST(X) ((long)(X))\n+#endif\n+\n+#define FAIL(EXP, GOT)\t\t\t\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    fprintf (stderr, \"Expected: \" FAIL_FORMAT \", got \" FAIL_FORMAT \"\\n\", \\\n+\t     FAIL_CAST (EXP), FAIL_CAST (GOT));\t\t\t\t\\\n+    fflush (stderr);\t\t\t\t\t\t\t\\\n+    abort ();\t\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n+#else\n+#define TRACE(STRING, NUM)\n+#define FAIL(EXP, GOT) abort ()\n+#endif\n+\n+static void\t    check\t   (RTYPE, RTYPE)\t__attribute__((__noinline__));\n+static vector TYPE  deoptimize     (vector TYPE)\t__attribute__((__noinline__));\n+static vector TYPE *deoptimize_ptr (vector TYPE *)\t__attribute__((__noinline__));\n+\n static void\n-check (TYPE expected, TYPE got)\n+check (RTYPE expected, RTYPE got)\n {\n   if (expected != got)\n-    abort ();\n+    FAIL (expected, got);\n }\n \n-static vector TYPE  deoptimize     (vector TYPE)\t__attribute__((__noinline__));\n-static vector TYPE *deoptimize_ptr (vector TYPE *)\t__attribute__((__noinline__));\n-\n static vector TYPE\n deoptimize (vector TYPE a)\n {\n@@ -29,116 +66,116 @@ deoptimize_ptr (vector TYPE *p)\n \f\n /* Tests for the normal case of vec_extract where the vector is in a register\n    and returning the result in a register as a return value.  */\n-TYPE\n+RTYPE\n get_auto_n (vector TYPE a, ssize_t n)\n {\n-  return vec_extract (a, n);\n+  return (RTYPE) vec_extract (a, n);\n }\n \n-TYPE\n+RTYPE\n get_auto_0 (vector TYPE a)\n {\n-  return vec_extract (a, 0);\n+  return (RTYPE) vec_extract (a, 0);\n }\n \n-TYPE\n+RTYPE\n get_auto_1 (vector TYPE a)\n {\n-  return vec_extract (a, 1);\n+  return (RTYPE) vec_extract (a, 1);\n }\n \n #if ELEMENTS >= 4\n-TYPE\n+RTYPE\n get_auto_2 (vector TYPE a)\n {\n-  return vec_extract (a, 2);\n+  return (RTYPE) vec_extract (a, 2);\n }\n \n-TYPE\n+RTYPE\n get_auto_3 (vector TYPE a)\n {\n-  return vec_extract (a, 3);\n+  return (RTYPE) vec_extract (a, 3);\n }\n \n #if ELEMENTS >= 8\n-TYPE\n+RTYPE\n get_auto_4 (vector TYPE a)\n {\n-  return vec_extract (a, 4);\n+  return (RTYPE) vec_extract (a, 4);\n }\n \n-TYPE\n+RTYPE\n get_auto_5 (vector TYPE a)\n {\n-  return vec_extract (a, 5);\n+  return (RTYPE) vec_extract (a, 5);\n }\n \n-TYPE\n+RTYPE\n get_auto_6 (vector TYPE a)\n {\n-  return vec_extract (a, 6);\n+  return (RTYPE) vec_extract (a, 6);\n }\n \n-TYPE\n+RTYPE\n get_auto_7 (vector TYPE a)\n {\n-  return vec_extract (a, 7);\n+  return (RTYPE) vec_extract (a, 7);\n }\n \n #if ELEMENTS >= 16\n-TYPE\n+RTYPE\n get_auto_8 (vector TYPE a)\n {\n-  return vec_extract (a, 8);\n+  return (RTYPE) vec_extract (a, 8);\n }\n \n-TYPE\n+RTYPE\n get_auto_9 (vector TYPE a)\n {\n-  return vec_extract (a, 9);\n+  return (RTYPE) vec_extract (a, 9);\n }\n \n-TYPE\n+RTYPE\n get_auto_10 (vector TYPE a)\n {\n-  return vec_extract (a, 10);\n+  return (RTYPE) vec_extract (a, 10);\n }\n \n-TYPE\n+RTYPE\n get_auto_11 (vector TYPE a)\n {\n-  return vec_extract (a, 11);\n+  return (RTYPE) vec_extract (a, 11);\n }\n \n-TYPE\n+RTYPE\n get_auto_12 (vector TYPE a)\n {\n-  return vec_extract (a, 12);\n+  return (RTYPE) vec_extract (a, 12);\n }\n \n-TYPE\n+RTYPE\n get_auto_13 (vector TYPE a)\n {\n-  return vec_extract (a, 13);\n+  return (RTYPE) vec_extract (a, 13);\n }\n \n-TYPE\n+RTYPE\n get_auto_14 (vector TYPE a)\n {\n-  return vec_extract (a, 14);\n+  return (RTYPE) vec_extract (a, 14);\n }\n \n-TYPE\n+RTYPE\n get_auto_15 (vector TYPE a)\n {\n-  return vec_extract (a, 15);\n+  return (RTYPE) vec_extract (a, 15);\n }\n \n #endif\n #endif\n #endif\n \n-typedef TYPE (*auto_func_type) (vector TYPE);\n+typedef RTYPE (*auto_func_type) (vector TYPE);\n \n static auto_func_type get_auto_const[] = {\n   get_auto_0,\n@@ -173,7 +210,10 @@ do_auto (vector TYPE a)\n   size_t i;\n \n   for (i = 0; i < sizeof (get_auto_const) / sizeof (get_auto_const[0]); i++)\n-    check (get_auto_n (a, i),  (get_auto_const[i]) (a));\n+    {\n+      TRACE (\"auto\", i);\n+      check (get_auto_n (a, i), (get_auto_const[i]) (a));\n+    }\n }\n \n \f\n@@ -182,115 +222,115 @@ do_auto (vector TYPE a)\n    in the right position to use a scalar store).  */\n \n void\n-get_store_n (TYPE *p, vector TYPE a, ssize_t n)\n+get_store_n (RTYPE *p, vector TYPE a, ssize_t n)\n {\n-  *p = vec_extract (a, n);\n+  *p = (RTYPE) vec_extract (a, n);\n }\n \n void\n-get_store_0 (TYPE *p, vector TYPE a)\n+get_store_0 (RTYPE *p, vector TYPE a)\n {\n-  *p = vec_extract (a, 0);\n+  *p = (RTYPE) vec_extract (a, 0);\n }\n \n void\n-get_store_1 (TYPE *p, vector TYPE a)\n+get_store_1 (RTYPE *p, vector TYPE a)\n {\n-  *p = vec_extract (a, 1);\n+  *p = (RTYPE) vec_extract (a, 1);\n }\n \n #if ELEMENTS >= 4\n void\n-get_store_2 (TYPE *p, vector TYPE a)\n+get_store_2 (RTYPE *p, vector TYPE a)\n {\n-  *p = vec_extract (a, 2);\n+  *p = (RTYPE) vec_extract (a, 2);\n }\n \n void\n-get_store_3 (TYPE *p, vector TYPE a)\n+get_store_3 (RTYPE *p, vector TYPE a)\n {\n-  *p = vec_extract (a, 3);\n+  *p = (RTYPE) vec_extract (a, 3);\n }\n \n #if ELEMENTS >= 8\n void\n-get_store_4 (TYPE *p, vector TYPE a)\n+get_store_4 (RTYPE *p, vector TYPE a)\n {\n-  *p = vec_extract (a, 4);\n+  *p = (RTYPE) vec_extract (a, 4);\n }\n \n void\n-get_store_5 (TYPE *p, vector TYPE a)\n+get_store_5 (RTYPE *p, vector TYPE a)\n {\n-  *p = vec_extract (a, 5);\n+  *p = (RTYPE) vec_extract (a, 5);\n }\n \n void\n-get_store_6 (TYPE *p, vector TYPE a)\n+get_store_6 (RTYPE *p, vector TYPE a)\n {\n-  *p = vec_extract (a, 6);\n+  *p = (RTYPE) vec_extract (a, 6);\n }\n \n void\n-get_store_7 (TYPE *p, vector TYPE a)\n+get_store_7 (RTYPE *p, vector TYPE a)\n {\n-  *p = vec_extract (a, 7);\n+  *p = (RTYPE) vec_extract (a, 7);\n }\n \n #if ELEMENTS >= 16\n void\n-get_store_8 (TYPE *p, vector TYPE a)\n+get_store_8 (RTYPE *p, vector TYPE a)\n {\n-  *p = vec_extract (a, 8);\n+  *p = (RTYPE) vec_extract (a, 8);\n }\n \n void\n-get_store_9 (TYPE *p, vector TYPE a)\n+get_store_9 (RTYPE *p, vector TYPE a)\n {\n-  *p = vec_extract (a, 9);\n+  *p = (RTYPE) vec_extract (a, 9);\n }\n \n void\n-get_store_10 (TYPE *p, vector TYPE a)\n+get_store_10 (RTYPE *p, vector TYPE a)\n {\n-  *p = vec_extract (a, 10);\n+  *p = (RTYPE) vec_extract (a, 10);\n }\n \n void\n-get_store_11 (TYPE *p, vector TYPE a)\n+get_store_11 (RTYPE *p, vector TYPE a)\n {\n-  *p = vec_extract (a, 11);\n+  *p = (RTYPE) vec_extract (a, 11);\n }\n \n void\n-get_store_12 (TYPE *p, vector TYPE a)\n+get_store_12 (RTYPE *p, vector TYPE a)\n {\n-  *p = vec_extract (a, 12);\n+  *p = (RTYPE) vec_extract (a, 12);\n }\n \n void\n-get_store_13 (TYPE *p, vector TYPE a)\n+get_store_13 (RTYPE *p, vector TYPE a)\n {\n-  *p = vec_extract (a, 13);\n+  *p = (RTYPE) vec_extract (a, 13);\n }\n \n void\n-get_store_14 (TYPE *p, vector TYPE a)\n+get_store_14 (RTYPE *p, vector TYPE a)\n {\n-  *p = vec_extract (a, 14);\n+  *p = (RTYPE) vec_extract (a, 14);\n }\n \n void\n-get_store_15 (TYPE *p, vector TYPE a)\n+get_store_15 (RTYPE *p, vector TYPE a)\n {\n-  *p = vec_extract (a, 15);\n+  *p = (RTYPE) vec_extract (a, 15);\n }\n \n #endif\n #endif\n #endif\n \n-typedef void (*store_func_type) (TYPE *, vector TYPE);\n+typedef void (*store_func_type) (RTYPE *, vector TYPE);\n \n static store_func_type get_store_const[] = {\n   get_store_0,\n@@ -323,10 +363,11 @@ void\n do_store (vector TYPE a)\n {\n   size_t i;\n-  TYPE result_var, result_const;\n+  RTYPE result_var, result_const;\n \n   for (i = 0; i < sizeof (get_store_const) / sizeof (get_store_const[0]); i++)\n     {\n+      TRACE (\"store\", i);\n       get_store_n (&result_var, a, i);\n       (get_store_const[i]) (&result_const, a);\n       check (result_var, result_const);\n@@ -337,116 +378,116 @@ do_store (vector TYPE a)\n /* Tests for vec_extract where the vector comes from memory (the compiler can\n    optimize this by doing a scalar load without having to load the whole\n    vector).  */\n-TYPE\n+RTYPE\n get_pointer_n (vector TYPE *p, ssize_t n)\n {\n-  return vec_extract (*p, n);\n+  return (RTYPE) vec_extract (*p, n);\n }\n \n-TYPE\n+RTYPE\n get_pointer_0 (vector TYPE *p)\n {\n-  return vec_extract (*p, 0);\n+  return (RTYPE) vec_extract (*p, 0);\n }\n \n-TYPE\n+RTYPE\n get_pointer_1 (vector TYPE *p)\n {\n-  return vec_extract (*p, 1);\n+  return (RTYPE) vec_extract (*p, 1);\n }\n \n #if ELEMENTS >= 4\n-TYPE\n+RTYPE\n get_pointer_2 (vector TYPE *p)\n {\n-  return vec_extract (*p, 2);\n+  return (RTYPE) vec_extract (*p, 2);\n }\n \n-TYPE\n+RTYPE\n get_pointer_3 (vector TYPE *p)\n {\n-  return vec_extract (*p, 3);\n+  return (RTYPE) vec_extract (*p, 3);\n }\n \n #if ELEMENTS >= 8\n-TYPE\n+RTYPE\n get_pointer_4 (vector TYPE *p)\n {\n-  return vec_extract (*p, 4);\n+  return (RTYPE) vec_extract (*p, 4);\n }\n \n-static TYPE\n+RTYPE\n get_pointer_5 (vector TYPE *p)\n {\n-  return vec_extract (*p, 5);\n+  return (RTYPE) vec_extract (*p, 5);\n }\n \n-TYPE\n+RTYPE\n get_pointer_6 (vector TYPE *p)\n {\n-  return vec_extract (*p, 6);\n+  return (RTYPE) vec_extract (*p, 6);\n }\n \n-TYPE\n+RTYPE\n get_pointer_7 (vector TYPE *p)\n {\n-  return vec_extract (*p, 7);\n+  return (RTYPE) vec_extract (*p, 7);\n }\n \n #if ELEMENTS >= 16\n-TYPE\n+RTYPE\n get_pointer_8 (vector TYPE *p)\n {\n-  return vec_extract (*p, 8);\n+  return (RTYPE) vec_extract (*p, 8);\n }\n \n-TYPE\n+RTYPE\n get_pointer_9 (vector TYPE *p)\n {\n-  return vec_extract (*p, 9);\n+  return (RTYPE) vec_extract (*p, 9);\n }\n \n-TYPE\n+RTYPE\n get_pointer_10 (vector TYPE *p)\n {\n-  return vec_extract (*p, 10);\n+  return (RTYPE) vec_extract (*p, 10);\n }\n \n-TYPE\n+RTYPE\n get_pointer_11 (vector TYPE *p)\n {\n-  return vec_extract (*p, 11);\n+  return (RTYPE) vec_extract (*p, 11);\n }\n \n-TYPE\n+RTYPE\n get_pointer_12 (vector TYPE *p)\n {\n-  return vec_extract (*p, 12);\n+  return (RTYPE) vec_extract (*p, 12);\n }\n \n-TYPE\n+RTYPE\n get_pointer_13 (vector TYPE *p)\n {\n-  return vec_extract (*p, 13);\n+  return (RTYPE) vec_extract (*p, 13);\n }\n \n-TYPE\n+RTYPE\n get_pointer_14 (vector TYPE *p)\n {\n-  return vec_extract (*p, 14);\n+  return (RTYPE) vec_extract (*p, 14);\n }\n \n-TYPE\n+RTYPE\n get_pointer_15 (vector TYPE *p)\n {\n-  return vec_extract (*p, 15);\n+  return (RTYPE) vec_extract (*p, 15);\n }\n \n #endif\n #endif\n #endif\n \n-typedef TYPE (*pointer_func_type) (vector TYPE *);\n+typedef RTYPE (*pointer_func_type) (vector TYPE *);\n \n static pointer_func_type get_pointer_const[] = {\n   get_pointer_0,\n@@ -481,124 +522,127 @@ do_pointer (vector TYPE *p)\n   size_t i;\n \n   for (i = 0; i < sizeof (get_pointer_const) / sizeof (get_pointer_const[0]); i++)\n-    check (get_pointer_n (p, i),  (get_pointer_const[i]) (p));\n+    {\n+      TRACE (\"pointer\", i);\n+      check (get_pointer_n (p, i),  (get_pointer_const[i]) (p));\n+    }\n }\n \n \f\n /* Test for vec_extract where the vector comes from an indexed memory\n    operation.  This is to make sure that if the compiler optimizes vec_extract\n    from memory to be a scalar load, the address is correctly adjusted.  */\n \n-TYPE\n+RTYPE\n get_indexed_n (vector TYPE *p, size_t x, ssize_t n)\n {\n-  return vec_extract (p[x], n);\n+  return (RTYPE) vec_extract (p[x], n);\n }\n \n-TYPE\n+RTYPE\n get_indexed_0 (vector TYPE *p, size_t x)\n {\n-  return vec_extract (p[x], 0);\n+  return (RTYPE) vec_extract (p[x], 0);\n }\n \n-TYPE\n+RTYPE\n get_indexed_1 (vector TYPE *p, size_t x)\n {\n-  return vec_extract (p[x], 1);\n+  return (RTYPE) vec_extract (p[x], 1);\n }\n \n #if ELEMENTS >= 4\n-TYPE\n+RTYPE\n get_indexed_2 (vector TYPE *p, size_t x)\n {\n-  return vec_extract (p[x], 2);\n+  return (RTYPE) vec_extract (p[x], 2);\n }\n \n-TYPE\n+RTYPE\n get_indexed_3 (vector TYPE *p, size_t x)\n {\n-  return vec_extract (p[x], 3);\n+  return (RTYPE) vec_extract (p[x], 3);\n }\n \n #if ELEMENTS >= 8\n-TYPE\n+RTYPE\n get_indexed_4 (vector TYPE *p, size_t x)\n {\n-  return vec_extract (p[x], 4);\n+  return (RTYPE) vec_extract (p[x], 4);\n }\n \n-static TYPE\n+RTYPE\n get_indexed_5 (vector TYPE *p, size_t x)\n {\n-  return vec_extract (p[x], 5);\n+  return (RTYPE) vec_extract (p[x], 5);\n }\n \n-TYPE\n+RTYPE\n get_indexed_6 (vector TYPE *p, size_t x)\n {\n-  return vec_extract (p[x], 6);\n+  return (RTYPE) vec_extract (p[x], 6);\n }\n \n-TYPE\n+RTYPE\n get_indexed_7 (vector TYPE *p, size_t x)\n {\n-  return vec_extract (p[x], 7);\n+  return (RTYPE) vec_extract (p[x], 7);\n }\n \n #if ELEMENTS >= 16\n-TYPE\n+RTYPE\n get_indexed_8 (vector TYPE *p, size_t x)\n {\n-  return vec_extract (p[x], 8);\n+  return (RTYPE) vec_extract (p[x], 8);\n }\n \n-TYPE\n+RTYPE\n get_indexed_9 (vector TYPE *p, size_t x)\n {\n-  return vec_extract (p[x], 9);\n+  return (RTYPE) vec_extract (p[x], 9);\n }\n \n-TYPE\n+RTYPE\n get_indexed_10 (vector TYPE *p, size_t x)\n {\n-  return vec_extract (p[x], 10);\n+  return (RTYPE) vec_extract (p[x], 10);\n }\n \n-TYPE\n+RTYPE\n get_indexed_11 (vector TYPE *p, size_t x)\n {\n-  return vec_extract (p[x], 11);\n+  return (RTYPE) vec_extract (p[x], 11);\n }\n \n-TYPE\n+RTYPE\n get_indexed_12 (vector TYPE *p, size_t x)\n {\n-  return vec_extract (p[x], 12);\n+  return (RTYPE) vec_extract (p[x], 12);\n }\n \n-TYPE\n+RTYPE\n get_indexed_13 (vector TYPE *p, size_t x)\n {\n-  return vec_extract (p[x], 13);\n+  return (RTYPE) vec_extract (p[x], 13);\n }\n \n-TYPE\n+RTYPE\n get_indexed_14 (vector TYPE *p, size_t x)\n {\n-  return vec_extract (p[x], 14);\n+  return (RTYPE) vec_extract (p[x], 14);\n }\n \n-TYPE\n+RTYPE\n get_indexed_15 (vector TYPE *p, size_t x)\n {\n-  return vec_extract (p[x], 15);\n+  return (RTYPE) vec_extract (p[x], 15);\n }\n \n #endif\n #endif\n #endif\n \n-typedef TYPE (*indexed_func_type) (vector TYPE *, size_t);\n+typedef RTYPE (*indexed_func_type) (vector TYPE *, size_t);\n \n static indexed_func_type get_indexed_const[] = {\n   get_indexed_0,\n@@ -633,124 +677,127 @@ do_indexed (vector TYPE *p, size_t x)\n   size_t i;\n \n   for (i = 0; i < sizeof (get_indexed_const) / sizeof (get_indexed_const[0]); i++)\n-    check (get_indexed_n (p, x, i),  (get_indexed_const[i]) (p, x));\n+    {\n+      TRACE (\"indexed\", i);\n+      check (get_indexed_n (p, x, i),  (get_indexed_const[i]) (p, x));\n+    }\n }\n \n \f\n /* Test for vec_extract where the vector comes from memory using an address\n    with a pointer and a constant offset.  This will occur in ISA 3.0 which\n    added d-form memory addressing for vectors.  */\n \n-TYPE\n+RTYPE\n get_ptr_plus1_n (vector TYPE *p, ssize_t n)\n {\n-  return vec_extract (p[1], n);\n+  return (RTYPE) vec_extract (p[1], n);\n }\n \n-TYPE\n+RTYPE\n get_ptr_plus1_0 (vector TYPE *p)\n {\n-  return vec_extract (p[1], 0);\n+  return (RTYPE) vec_extract (p[1], 0);\n }\n \n-TYPE\n+RTYPE\n get_ptr_plus1_1 (vector TYPE *p)\n {\n-  return vec_extract (p[1], 1);\n+  return (RTYPE) vec_extract (p[1], 1);\n }\n \n #if ELEMENTS >= 4\n-TYPE\n+RTYPE\n get_ptr_plus1_2 (vector TYPE *p)\n {\n-  return vec_extract (p[1], 2);\n+  return (RTYPE) vec_extract (p[1], 2);\n }\n \n-TYPE\n+RTYPE\n get_ptr_plus1_3 (vector TYPE *p)\n {\n-  return vec_extract (p[1], 3);\n+  return (RTYPE) vec_extract (p[1], 3);\n }\n \n #if ELEMENTS >= 8\n-TYPE\n+RTYPE\n get_ptr_plus1_4 (vector TYPE *p)\n {\n-  return vec_extract (p[1], 4);\n+  return (RTYPE) vec_extract (p[1], 4);\n }\n \n-static TYPE\n+RTYPE\n get_ptr_plus1_5 (vector TYPE *p)\n {\n-  return vec_extract (p[1], 5);\n+  return (RTYPE) vec_extract (p[1], 5);\n }\n \n-TYPE\n+RTYPE\n get_ptr_plus1_6 (vector TYPE *p)\n {\n-  return vec_extract (p[1], 6);\n+  return (RTYPE) vec_extract (p[1], 6);\n }\n \n-TYPE\n+RTYPE\n get_ptr_plus1_7 (vector TYPE *p)\n {\n-  return vec_extract (p[1], 7);\n+  return (RTYPE) vec_extract (p[1], 7);\n }\n \n #if ELEMENTS >= 16\n-TYPE\n+RTYPE\n get_ptr_plus1_8 (vector TYPE *p)\n {\n-  return vec_extract (p[1], 8);\n+  return (RTYPE) vec_extract (p[1], 8);\n }\n \n-TYPE\n+RTYPE\n get_ptr_plus1_9 (vector TYPE *p)\n {\n-  return vec_extract (p[1], 9);\n+  return (RTYPE) vec_extract (p[1], 9);\n }\n \n-TYPE\n+RTYPE\n get_ptr_plus1_10 (vector TYPE *p)\n {\n-  return vec_extract (p[1], 10);\n+  return (RTYPE) vec_extract (p[1], 10);\n }\n \n-TYPE\n+RTYPE\n get_ptr_plus1_11 (vector TYPE *p)\n {\n-  return vec_extract (p[1], 11);\n+  return (RTYPE) vec_extract (p[1], 11);\n }\n \n-TYPE\n+RTYPE\n get_ptr_plus1_12 (vector TYPE *p)\n {\n-  return vec_extract (p[1], 12);\n+  return (RTYPE) vec_extract (p[1], 12);\n }\n \n-TYPE\n+RTYPE\n get_ptr_plus1_13 (vector TYPE *p)\n {\n-  return vec_extract (p[1], 13);\n+  return (RTYPE) vec_extract (p[1], 13);\n }\n \n-TYPE\n+RTYPE\n get_ptr_plus1_14 (vector TYPE *p)\n {\n-  return vec_extract (p[1], 14);\n+  return (RTYPE) vec_extract (p[1], 14);\n }\n \n-TYPE\n+RTYPE\n get_ptr_plus1_15 (vector TYPE *p)\n {\n-  return vec_extract (p[1], 15);\n+  return (RTYPE) vec_extract (p[1], 15);\n }\n \n #endif\n #endif\n #endif\n \n-typedef TYPE (*pointer_func_type) (vector TYPE *);\n+typedef RTYPE (*pointer_func_type) (vector TYPE *);\n \n static pointer_func_type get_ptr_plus1_const[] = {\n   get_ptr_plus1_0,\n@@ -785,124 +832,127 @@ do_ptr_plus1 (vector TYPE *p)\n   size_t i;\n \n   for (i = 0; i < sizeof (get_ptr_plus1_const) / sizeof (get_ptr_plus1_const[0]); i++)\n-    check (get_ptr_plus1_n (p, i),  (get_ptr_plus1_const[i]) (p));\n+    {\n+      TRACE (\"ptr_plus1\", i);\n+      check (get_ptr_plus1_n (p, i),  (get_ptr_plus1_const[i]) (p));\n+    }\n }\n \n \f\n /* Test for vec_extract where the vector comes from a static variable.  */\n \n static vector TYPE s;\n \n-TYPE\n+RTYPE\n get_static_n (ssize_t n)\n {\n-  return vec_extract (s, n);\n+  return (RTYPE) vec_extract (s, n);\n }\n \n-TYPE\n+RTYPE\n get_static_0 (void)\n {\n-  return vec_extract (s, 0);\n+  return (RTYPE) vec_extract (s, 0);\n }\n \n-TYPE\n+RTYPE\n get_static_1 (void)\n {\n-  return vec_extract (s, 1);\n+  return (RTYPE) vec_extract (s, 1);\n }\n \n #if ELEMENTS >= 4\n-TYPE\n+RTYPE\n get_static_2 (void)\n {\n-  return vec_extract (s, 2);\n+  return (RTYPE) vec_extract (s, 2);\n }\n \n-TYPE\n+RTYPE\n get_static_3 (void)\n {\n-  return vec_extract (s, 3);\n+  return (RTYPE) vec_extract (s, 3);\n }\n \n #if ELEMENTS >= 8\n-TYPE\n+RTYPE\n get_static_4 (void)\n {\n-  return vec_extract (s, 4);\n+  return (RTYPE) vec_extract (s, 4);\n }\n \n-TYPE\n+RTYPE\n get_static_5 (void)\n {\n-  return vec_extract (s, 5);\n+  return (RTYPE) vec_extract (s, 5);\n }\n \n-TYPE\n+RTYPE\n get_static_6 (void)\n {\n-  return vec_extract (s, 6);\n+  return (RTYPE) vec_extract (s, 6);\n }\n \n-TYPE\n+RTYPE\n get_static_7 (void)\n {\n-  return vec_extract (s, 7);\n+  return (RTYPE) vec_extract (s, 7);\n }\n \n #if ELEMENTS >= 16\n-TYPE\n+RTYPE\n get_static_8 (void)\n {\n-  return vec_extract (s, 8);\n+  return (RTYPE) vec_extract (s, 8);\n }\n \n-TYPE\n+RTYPE\n get_static_9 (void)\n {\n-  return vec_extract (s, 9);\n+  return (RTYPE) vec_extract (s, 9);\n }\n \n-TYPE\n+RTYPE\n get_static_10 (void)\n {\n-  return vec_extract (s, 10);\n+  return (RTYPE) vec_extract (s, 10);\n }\n \n-TYPE\n+RTYPE\n get_static_11 (void)\n {\n-  return vec_extract (s, 11);\n+  return (RTYPE) vec_extract (s, 11);\n }\n \n-TYPE\n+RTYPE\n get_static_12 (void)\n {\n-  return vec_extract (s, 12);\n+  return (RTYPE) vec_extract (s, 12);\n }\n \n-TYPE\n+RTYPE\n get_static_13 (void)\n {\n-  return vec_extract (s, 13);\n+  return (RTYPE) vec_extract (s, 13);\n }\n \n-TYPE\n+RTYPE\n get_static_14 (void)\n {\n-  return vec_extract (s, 14);\n+  return (RTYPE) vec_extract (s, 14);\n }\n \n-TYPE\n+RTYPE\n get_static_15 (void)\n {\n-  return vec_extract (s, 15);\n+  return (RTYPE) vec_extract (s, 15);\n }\n \n #endif\n #endif\n #endif\n \n-typedef TYPE (*static_func_type) (void);\n+typedef RTYPE (*static_func_type) (void);\n \n static static_func_type get_static_const[] = {\n   get_static_0,\n@@ -937,124 +987,127 @@ do_static (void)\n   size_t i;\n \n   for (i = 0; i < sizeof (get_static_const) / sizeof (get_static_const[0]); i++)\n-    check (get_static_n (i),  (get_static_const[i]) ());\n+    {\n+      TRACE (\"static\", i);\n+      check (get_static_n (i),  (get_static_const[i]) ());\n+    }\n }\n \n \f\n /* Test for vec_extract where the vector is in a global variable.  */\n \n vector TYPE g;\n \n-TYPE\n+RTYPE\n get_global_n (ssize_t n)\n {\n-  return vec_extract (g, n);\n+  return (RTYPE) vec_extract (g, n);\n }\n \n-TYPE\n+RTYPE\n get_global_0 (void)\n {\n-  return vec_extract (g, 0);\n+  return (RTYPE) vec_extract (g, 0);\n }\n \n-TYPE\n+RTYPE\n get_global_1 (void)\n {\n-  return vec_extract (g, 1);\n+  return (RTYPE) vec_extract (g, 1);\n }\n \n #if ELEMENTS >= 4\n-TYPE\n+RTYPE\n get_global_2 (void)\n {\n-  return vec_extract (g, 2);\n+  return (RTYPE) vec_extract (g, 2);\n }\n \n-TYPE\n+RTYPE\n get_global_3 (void)\n {\n-  return vec_extract (g, 3);\n+  return (RTYPE) vec_extract (g, 3);\n }\n \n #if ELEMENTS >= 8\n-TYPE\n+RTYPE\n get_global_4 (void)\n {\n-  return vec_extract (g, 4);\n+  return (RTYPE) vec_extract (g, 4);\n }\n \n-TYPE\n+RTYPE\n get_global_5 (void)\n {\n-  return vec_extract (g, 5);\n+  return (RTYPE) vec_extract (g, 5);\n }\n \n-TYPE\n+RTYPE\n get_global_6 (void)\n {\n-  return vec_extract (g, 6);\n+  return (RTYPE) vec_extract (g, 6);\n }\n \n-TYPE\n+RTYPE\n get_global_7 (void)\n {\n-  return vec_extract (g, 7);\n+  return (RTYPE) vec_extract (g, 7);\n }\n \n #if ELEMENTS >= 16\n-TYPE\n+RTYPE\n get_global_8 (void)\n {\n-  return vec_extract (g, 8);\n+  return (RTYPE) vec_extract (g, 8);\n }\n \n-TYPE\n+RTYPE\n get_global_9 (void)\n {\n-  return vec_extract (g, 9);\n+  return (RTYPE) vec_extract (g, 9);\n }\n \n-TYPE\n+RTYPE\n get_global_10 (void)\n {\n-  return vec_extract (g, 10);\n+  return (RTYPE) vec_extract (g, 10);\n }\n \n-TYPE\n+RTYPE\n get_global_11 (void)\n {\n-  return vec_extract (g, 11);\n+  return (RTYPE) vec_extract (g, 11);\n }\n \n-TYPE\n+RTYPE\n get_global_12 (void)\n {\n-  return vec_extract (g, 12);\n+  return (RTYPE) vec_extract (g, 12);\n }\n \n-TYPE\n+RTYPE\n get_global_13 (void)\n {\n-  return vec_extract (g, 13);\n+  return (RTYPE) vec_extract (g, 13);\n }\n \n-TYPE\n+RTYPE\n get_global_14 (void)\n {\n-  return vec_extract (g, 14);\n+  return (RTYPE) vec_extract (g, 14);\n }\n \n-TYPE\n+RTYPE\n get_global_15 (void)\n {\n-  return vec_extract (g, 15);\n+  return (RTYPE) vec_extract (g, 15);\n }\n \n #endif\n #endif\n #endif\n \n-typedef TYPE (*global_func_type) (void);\n+typedef RTYPE (*global_func_type) (void);\n \n static global_func_type get_global_const[] = {\n   get_global_0,\n@@ -1089,7 +1142,10 @@ do_global (void)\n   size_t i;\n \n   for (i = 0; i < sizeof (get_global_const) / sizeof (get_global_const[0]); i++)\n-    check (get_global_n (i),  (get_global_const[i]) ());\n+    {\n+      TRACE (\"global\", i);\n+      check (get_global_n (i),  (get_global_const[i]) ());\n+    }\n }\n \n \f"}]}