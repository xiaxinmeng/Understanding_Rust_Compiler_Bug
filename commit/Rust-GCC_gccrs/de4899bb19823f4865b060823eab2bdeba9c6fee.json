{"sha": "de4899bb19823f4865b060823eab2bdeba9c6fee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGU0ODk5YmIxOTgyM2Y0ODY1YjA2MDgyM2VhYjJiZGViYTljNmZlZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-11-20T15:47:33Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-11-20T15:47:33Z"}, "message": "[multiple changes]\n\n2014-11-20  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch3.adb (Expand_N_Object_Declaration): Handle properly\n\ta type invariant check on an object with default initialization\n\tand an address clause.\n\n2014-11-20  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_elab.adb (Check_A_Call): Handle variable ref case in\n\tSPARK (Check_Elab_Call): ditto (Find_Elab_Reference): ditto\n\t(Get_Referenced_Ent): ditto.\n\t* sem_elab.ads: Comment fixes to account for the fact that we\n\tnow deal with variable references in SPARK mode.\n\t* sem_res.adb (Resolve_Entity_Name): In SPARK_Mode Call\n\tCheck_Elab_Call for variable.\n\n2014-11-20  Yannick Moy  <moy@adacore.com>\n\n\t* a-cofove.ads (Copy): Fix precondition, which should allow\n\tCapacity = 0.\n\t(First_To_Previous, Current_To_Last): Add necessary preconditions.\n\nFrom-SVN: r217878", "tree": {"sha": "167699241ee1036a970b090cf5459b5ed28a8b49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/167699241ee1036a970b090cf5459b5ed28a8b49"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de4899bb19823f4865b060823eab2bdeba9c6fee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de4899bb19823f4865b060823eab2bdeba9c6fee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de4899bb19823f4865b060823eab2bdeba9c6fee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de4899bb19823f4865b060823eab2bdeba9c6fee/comments", "author": null, "committer": null, "parents": [{"sha": "8c691dc68e9c514a6a3359cdb7cac06836ec81a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c691dc68e9c514a6a3359cdb7cac06836ec81a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c691dc68e9c514a6a3359cdb7cac06836ec81a8"}], "stats": {"total": 338, "additions": 233, "deletions": 105}, "files": [{"sha": "e43d191f67a645c13566fc591efd7982e5769f87", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de4899bb19823f4865b060823eab2bdeba9c6fee/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de4899bb19823f4865b060823eab2bdeba9c6fee/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=de4899bb19823f4865b060823eab2bdeba9c6fee", "patch": "@@ -1,3 +1,25 @@\n+2014-11-20  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch3.adb (Expand_N_Object_Declaration): Handle properly\n+\ta type invariant check on an object with default initialization\n+\tand an address clause.\n+\n+2014-11-20  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_elab.adb (Check_A_Call): Handle variable ref case in\n+\tSPARK (Check_Elab_Call): ditto (Find_Elab_Reference): ditto\n+\t(Get_Referenced_Ent): ditto.\n+\t* sem_elab.ads: Comment fixes to account for the fact that we\n+\tnow deal with variable references in SPARK mode.\n+\t* sem_res.adb (Resolve_Entity_Name): In SPARK_Mode Call\n+\tCheck_Elab_Call for variable.\n+\n+2014-11-20  Yannick Moy  <moy@adacore.com>\n+\n+\t* a-cofove.ads (Copy): Fix precondition, which should allow\n+\tCapacity = 0.\n+\t(First_To_Previous, Current_To_Last): Add necessary preconditions.\n+\n 2014-11-20  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* exp_ch3.adb (Build_Initialization_Call): Reimplement the"}, {"sha": "6ddd24b9fcad24343832984aa35e9da16539e684", "filename": "gcc/ada/a-cofove.ads", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de4899bb19823f4865b060823eab2bdeba9c6fee/gcc%2Fada%2Fa-cofove.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de4899bb19823f4865b060823eab2bdeba9c6fee/gcc%2Fada%2Fa-cofove.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofove.ads?ref=de4899bb19823f4865b060823eab2bdeba9c6fee", "patch": "@@ -114,7 +114,7 @@ is\n       Capacity : Capacity_Range := 0) return Vector\n    with\n      Global => null,\n-     Pre    => (if Bounded then Length (Source) <= Capacity);\n+     Pre    => (if Bounded then (Capacity = 0 or Length (Source) <= Capacity));\n \n    function Element\n      (Container : Vector;\n@@ -195,7 +195,9 @@ is\n      Global => null;\n \n    function Has_Element\n-     (Container : Vector; Position : Extended_Index) return Boolean with\n+     (Container : Vector;\n+      Position  : Extended_Index) return Boolean\n+   with\n      Global => null;\n \n    generic\n@@ -212,17 +214,19 @@ is\n \n    function First_To_Previous\n      (Container : Vector;\n-      Current : Index_Type) return Vector\n+      Current   : Index_Type) return Vector\n    with\n      Ghost,\n-     Global => null;\n+     Global => null,\n+     Pre    => Current in First_Index (Container) .. Last_Index (Container);\n \n    function Current_To_Last\n      (Container : Vector;\n-      Current : Index_Type) return Vector\n+      Current   : Index_Type) return Vector\n    with\n      Ghost,\n-     Global => null;\n+     Global => null,\n+     Pre    => Current in First_Index (Container) .. Last_Index (Container);\n    --  First_To_Previous returns a container containing all elements preceding\n    --  Current (excluded) in Container. Current_To_Last returns a container\n    --  containing all elements following Current (included) in Container."}, {"sha": "f2f42d4d9fdbbab207bc5939a09d074000da9637", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de4899bb19823f4865b060823eab2bdeba9c6fee/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de4899bb19823f4865b060823eab2bdeba9c6fee/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=de4899bb19823f4865b060823eab2bdeba9c6fee", "patch": "@@ -23,6 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Aspects;  use Aspects;\n with Atree;    use Atree;\n with Checks;   use Checks;\n with Einfo;    use Einfo;\n@@ -5462,8 +5463,23 @@ package body Exp_Ch3 is\n            and then not Has_Init_Expression (N)\n            and then not No_Initialization (N)\n          then\n-            Insert_After (N,\n-              Make_Invariant_Call (New_Occurrence_Of (Def_Id, Loc)));\n+            --  If entity has an address clause or aspect, make invariant\n+            --  call into a freeze action for the explicit freeze node for\n+            --  object. Otherwise insert invariant check after declaration.\n+\n+            if Present (Following_Address_Clause (N))\n+              or else Has_Aspect (Def_Id, Aspect_Address)\n+            then\n+               Ensure_Freeze_Node (Def_Id);\n+               Set_Has_Delayed_Freeze (Def_Id);\n+               Set_Is_Frozen (Def_Id, False);\n+               Append_Freeze_Action (Def_Id,\n+                 Make_Invariant_Call (New_Occurrence_Of (Def_Id, Loc)));\n+\n+            else\n+               Insert_After (N,\n+                 Make_Invariant_Call (New_Occurrence_Of (Def_Id, Loc)));\n+            end if;\n          end if;\n \n          Default_Initialize_Object (Init_After);"}, {"sha": "c84d04b30c9c3ac450bd663e8b39b4924c3400ef", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 118, "deletions": 54, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de4899bb19823f4865b060823eab2bdeba9c6fee/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de4899bb19823f4865b060823eab2bdeba9c6fee/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=de4899bb19823f4865b060823eab2bdeba9c6fee", "patch": "@@ -184,7 +184,11 @@ package body Sem_Elab is\n    --  E is the entity of the called subprogram, or instantiated generic unit,\n    --  or subprogram referenced by 'Access.\n    --\n-   --  The flag Outer_Scope is the outer level scope for the original call.\n+   --  In SPARK mode, N can also be a variable reference, since in SPARK this\n+   --  also triggers a requirement for Elaborate_All, and in this case E is the\n+   --  entity being referenced.\n+   --\n+   --  Outer_Scope is the outer level scope for the original reference.\n    --  Inter_Unit_Only is set if the call is only to be checked in the\n    --  case where it is to another unit (and skipped if within a unit).\n    --  Generate_Warnings is set to False to suppress warning messages about\n@@ -194,6 +198,11 @@ package body Sem_Elab is\n    --  procedure (since the referenced subprogram may be called later\n    --  indirectly). Flag In_Init_Proc should be set whenever the current\n    --  context is a type init proc.\n+   --\n+   --  Note: this might better be called Check_A_Reference to recognize the\n+   --  variable case for SPARK, but we prefer to retain the historical name\n+   --  since in practice this is mostly about checking calls for the possible\n+   --  occurrence of an access-before-elaboration exception.\n \n    procedure Check_Bad_Instantiation (N : Node_Id);\n    --  N is a node for an instantiation (if called with any other node kind,\n@@ -287,6 +296,9 @@ package body Sem_Elab is\n    --  this is a call to a protected subprogram, the entity is a selected\n    --  component. The callable entity may be absent, in which case Empty is\n    --  returned. This happens with non-analyzed calls in nested generics.\n+   --\n+   --  If SPARK_Mode is On, then N can also be a reference to an E_Variable\n+   --  entity, in which case, the value returned is simply this entity.\n \n    procedure Set_Elaboration_Constraint\n     (Call : Node_Id;\n@@ -601,45 +613,60 @@ package body Sem_Elab is\n          return;\n       end if;\n \n-      --  Go to parent for derived subprogram, or to original subprogram in the\n-      --  case of a renaming (Alias covers both these cases).\n-\n       Ent := E;\n-      loop\n-         if (Suppress_Elaboration_Warnings (Ent)\n-              or else Elaboration_Checks_Suppressed (Ent))\n-           and then (Inst_Case or else No (Alias (Ent)))\n-         then\n-            return;\n-         end if;\n \n-         --  Nothing to do for imported entities\n+      --  For a variable reference, just set Body_Acts_As_Spec to False\n \n-         if Is_Imported (Ent) then\n-            return;\n-         end if;\n+      if Nkind (N) in N_Has_Entity\n+        and then Present (Entity (N))\n+        and then Ekind (Entity (N)) = E_Variable\n+      then\n+         Body_Acts_As_Spec := False;\n \n-         exit when Inst_Case or else No (Alias (Ent));\n-         Ent := Alias (Ent);\n-      end loop;\n+      --  Additional checks for all other cases\n \n-      Decl := Unit_Declaration_Node (Ent);\n+      else\n+         --  Go to parent for derived subprogram, or to original subprogram in\n+         --  the case of a renaming (Alias covers both these cases).\n \n-      if Nkind (Decl) = N_Subprogram_Body then\n-         Body_Acts_As_Spec := True;\n+         loop\n+            if (Suppress_Elaboration_Warnings (Ent)\n+                or else Elaboration_Checks_Suppressed (Ent))\n+              and then (Inst_Case or else No (Alias (Ent)))\n+            then\n+               return;\n+            end if;\n \n-      elsif Nkind_In (Decl, N_Subprogram_Declaration, N_Subprogram_Body_Stub)\n-        or else Inst_Case\n-      then\n-         Body_Acts_As_Spec := False;\n+            --  Nothing to do for imported entities\n \n-      --  If we have none of an instantiation, subprogram body or subprogram\n-      --  declaration, then it is not a case that we want to check. (One case\n-      --  is a call to a generic formal subprogram, where we do not want the\n-      --  check in the template).\n+            if Is_Imported (Ent) then\n+               return;\n+            end if;\n \n-      else\n-         return;\n+            exit when Inst_Case or else No (Alias (Ent));\n+            Ent := Alias (Ent);\n+         end loop;\n+\n+         Decl := Unit_Declaration_Node (Ent);\n+\n+         if Nkind (Decl) = N_Subprogram_Body then\n+            Body_Acts_As_Spec := True;\n+\n+         elsif Nkind_In (Decl, N_Subprogram_Declaration,\n+                               N_Subprogram_Body_Stub)\n+           or else Inst_Case\n+         then\n+            Body_Acts_As_Spec := False;\n+\n+         --  If we have none of an instantiation, subprogram body or subprogram\n+         --  declaration, or in the SPARK case, a variable reference, then\n+         --  it is not a case that we want to check. (One case is a call to a\n+         --  generic formal subprogram, where we do not want the check in the\n+         --  template).\n+\n+         else\n+            return;\n+         end if;\n       end if;\n \n       E_Scope := Ent;\n@@ -941,6 +968,16 @@ package body Sem_Elab is\n                Elab_Warning\n                  (\"\", \"info: access to & during elaboration?$?\", Ent);\n \n+            --  Variable reference in SPARK mode\n+\n+            elsif SPARK_Mode = On\n+              and then Nkind (N) in N_Has_Entity\n+              and then Present (Entity (N))\n+              and then Ekind (Entity (N)) = E_Variable\n+            then\n+               Error_Msg_NE\n+                 (\"reference to & during elaboration in SPARK\", N, Ent);\n+\n             --  Subprogram call case\n \n             else\n@@ -1207,9 +1244,9 @@ package body Sem_Elab is\n       P   : Node_Id;\n \n    begin\n-      --  If the call does not come from the main unit, there is nothing to\n-      --  check. Elaboration call from units in the context of the main unit\n-      --  will lead to semantic dependencies when those units are compiled.\n+      --  If the reference is not in the main unit, there is nothing to check.\n+      --  Elaboration call from units in the context of the main unit will lead\n+      --  to semantic dependencies when those units are compiled.\n \n       if not In_Extended_Main_Code_Unit (N) then\n          return;\n@@ -1222,15 +1259,22 @@ package body Sem_Elab is\n       then\n          Check_Restriction (No_Entry_Calls_In_Elaboration_Code, N);\n \n-      --  Nothing to do if this is not a call or attribute reference (happens\n+      --  Nothing to do if this is not an expected type of reference (happens\n       --  in some error conditions, and in some cases where rewriting occurs).\n \n       elsif Nkind (N) not in N_Subprogram_Call\n         and then Nkind (N) /= N_Attribute_Reference\n+        and then (SPARK_Mode /= On\n+                    or else Nkind (N) not in N_Has_Entity\n+                    or else No (Entity (N))\n+                    or else Ekind (Entity (N)) /= E_Variable)\n       then\n          return;\n \n-      --  Nothing to do if this is a call already rewritten for elab checking\n+      --  Nothing to do if this is a call already rewritten for elab checking.\n+      --  Such calls appear as the targets of If_Expressions.\n+\n+      --  This check MUST be wrong, it catches far too much\n \n       elsif Nkind (Parent (N)) = N_If_Expression then\n          return;\n@@ -1260,17 +1304,18 @@ package body Sem_Elab is\n          return;\n       end if;\n \n-      --  Here we have a call at elaboration time which must be checked\n+      --  Here we have a reference at elaboration time which must be checked\n \n       if Debug_Flag_LL then\n-         Write_Str (\"  Check_Elab_Call: \");\n+         Write_Str (\"  Check_Elab_Ref: \");\n \n          if Nkind (N) = N_Attribute_Reference then\n             if not Is_Entity_Name (Prefix (N)) then\n                Write_Str (\"<<not entity name>>\");\n             else\n                Write_Name (Chars (Entity (Prefix (N))));\n             end if;\n+\n             Write_Str (\"'Access\");\n \n          elsif No (Name (N)) or else not Is_Entity_Name (Name (N)) then\n@@ -1280,20 +1325,21 @@ package body Sem_Elab is\n             Write_Name (Chars (Entity (Name (N))));\n          end if;\n \n-         Write_Str (\"  call at \");\n+         Write_Str (\"  reference at \");\n          Write_Location (Sloc (N));\n          Write_Eol;\n       end if;\n \n       --  Climb up the tree to make sure we are not inside default expression\n       --  of a parameter specification or a record component, since in both\n-      --  these cases, we will be doing the actual call later, not now, and it\n-      --  is at the time of the actual call (statically speaking) that we must\n-      --  do our static check, not at the time of its initial analysis).\n+      --  these cases, we will be doing the actual reference later, not now,\n+      --  and it is at the time of the actual reference (statically speaking)\n+      --  that we must do our static check, not at the time of its initial\n+      --  analysis).\n \n-      --  However, we have to check calls within component definitions (e.g.\n-      --  a function call that determines an array component bound), so we\n-      --  terminate the loop in that case.\n+      --  However, we have to check references within component definitions\n+      --  (e.g. a function call that determines an array component bound),\n+      --  so we terminate the loop in that case.\n \n       P := Parent (N);\n       while Present (P) loop\n@@ -1302,7 +1348,7 @@ package body Sem_Elab is\n          then\n             return;\n \n-         --  The call occurs within the constraint of a component,\n+         --  The reference occurs within the constraint of a component,\n          --  so it must be checked.\n \n          elsif Nkind (P) = N_Component_Definition then\n@@ -1333,7 +1379,7 @@ package body Sem_Elab is\n \n          if From_Elab_Code then\n \n-            --  Complain if call that comes from source in preelaborated unit\n+            --  Complain if ref that comes from source in preelaborated unit\n             --  and we are not inside a subprogram (i.e. we are in elab code).\n \n             if Comes_From_Source (N)\n@@ -1415,8 +1461,8 @@ package body Sem_Elab is\n \n                      --  We are not in elaboration code, but we are doing\n                      --  dynamic elaboration checks, in this case, we still\n-                     --  need to do the call, since the subprogram we are in\n-                     --  could be called from another unit, also in dynamic\n+                     --  need to do the reference, since the subprogram we are\n+                     --  in could be called from another unit, also in dynamic\n                      --  elaboration check mode, at elaboration time.\n \n                      elsif Dynamic_Elaboration_Checks then\n@@ -1482,23 +1528,23 @@ package body Sem_Elab is\n          end if;\n       end loop;\n \n-      --  See if we need to analyze this call. We analyze it if either of\n+      --  See if we need to analyze this reference. We analyze it if either of\n       --  the following conditions is met:\n \n       --    It is an inner level call (since in this case it was triggered\n       --    by an outer level call from elaboration code), but only if the\n       --    call is within the scope of the original outer level call.\n \n-      --    It is an outer level call from elaboration code, or the called\n-      --    entity is in the same elaboration scope.\n+      --    It is an outer level reference from elaboration code, or a call to\n+      --    an entity is in the same elaboration scope.\n \n       --  And in these cases, we will check both inter-unit calls and\n       --  intra-unit (within a single unit) calls.\n \n       C_Scope := Current_Scope;\n \n-      --  If not outer level call, then we follow it if it is within the\n-      --  original scope of the outer call.\n+      --  If not outer level reference, then we follow it if it is within the\n+      --  original scope of the outer reference.\n \n       if Present (Outer_Scope)\n         and then Within (Scope (Ent), Outer_Scope)\n@@ -2088,6 +2134,17 @@ package body Sem_Elab is\n             Check_Elab_Call (N, Outer_Scope);\n             return OK;\n \n+         --  In SPARK mode, if we have an entity reference to a variable, then\n+         --  check it. For now we consider any reference.\n+\n+         elsif SPARK_Mode = On\n+           and then Nkind (N) in N_Has_Entity\n+           and then Present (Entity (N))\n+           and then Ekind (Entity (N)) = E_Variable\n+         then\n+            Check_Elab_Call (N, Outer_Scope);\n+            return OK;\n+\n          --  If we have a generic instantiation, check it\n \n          elsif Nkind (N) in N_Generic_Instantiation then\n@@ -2760,6 +2817,13 @@ package body Sem_Elab is\n       Nam : Node_Id;\n \n    begin\n+      if Nkind (N) in N_Has_Entity\n+        and then Present (Entity (N))\n+        and then Ekind (Entity (N)) = E_Variable\n+      then\n+         return Entity (N);\n+      end if;\n+\n       if Nkind (N) = N_Attribute_Reference then\n          Nam := Prefix (N);\n       else"}, {"sha": "49ea85ec904c444394c5aba31fa707066de17840", "filename": "gcc/ada/sem_elab.ads", "status": "modified", "additions": 57, "deletions": 41, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de4899bb19823f4865b060823eab2bdeba9c6fee/gcc%2Fada%2Fsem_elab.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de4899bb19823f4865b060823eab2bdeba9c6fee/gcc%2Fada%2Fsem_elab.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.ads?ref=de4899bb19823f4865b060823eab2bdeba9c6fee", "patch": "@@ -35,41 +35,48 @@ package Sem_Elab is\n    -- Description of Approach --\n    -----------------------------\n \n-   --  Every non-static call that is encountered by Sem_Res results in\n-   --  a call to Check_Elab_Call, with N being the call node, and Outer\n-   --  set to its default value of True.\n-\n-   --  The goal of Check_Elab_Call is to determine whether or not the\n-   --  call in question can generate an access before elaboration\n-   --  error (raising Program_Error) either by directly calling a\n-   --  subprogram whose body has not yet been elaborated, or indirectly,\n-   --  by calling a subprogram whose body has been elaborated, but which\n-   --  contains a call to such a subprogram.\n-\n-   --  The only calls that we need to look at at the outer level are\n-   --  calls that occur in elaboration code. There are two cases. The\n-   --  call can be at the outer level of elaboration code, or it can\n+   --  Every non-static call that is encountered by Sem_Res results in a call\n+   --  to Check_Elab_Call, with N being the call node, and Outer set to its\n+   --  default value of True. In addition X'Access is treated like a call\n+   --  for the access-to-procedure case, and in SPARK mode only we also\n+   --  check variable references.\n+\n+   --  The goal of Check_Elab_Call is to determine whether or not the reference\n+   --  in question can generate an access before elaboration error (raising\n+   --  Program_Error) either by directly calling a subprogram whose body\n+   --  has not yet been elaborated, or indirectly, by calling a subprogram\n+   --  whose body has been elaborated, but which contains a call to such a\n+   --  subprogram.\n+\n+   --  In addition, in SPARK mode, we are checking for a variable reference in\n+   --  another package, which requires an explicit Elaborate_All pragma.\n+\n+   --  The only references that we need to look at at the outer level are\n+   --  references that occur in elaboration code. There are two cases. The\n+   --  reference can be at the outer level of elaboration code, or it can\n    --  be within another unit, e.g. the elaboration code of a subprogram.\n \n-   --  In the case of an elaboration call at the outer level, we must\n-   --  trace all calls to outer level routines either within the current\n-   --  unit or to other units that are with'ed. For calls within the\n-   --  current unit, we can determine if the body has been elaborated\n-   --  or not, and if it has not, then a warning is generated.\n-\n-   --  Note that there are two subcases. If the original call directly\n-   --  calls a subprogram whose body has not been elaborated, then we\n-   --  know that an ABE will take place, and we replace the call by\n-   --  a raise of Program_Error. If the call is indirect, then we don't\n-   --  know that the PE will be raised, since the call might be guarded\n-   --  by a conditional. In this case we set Do_Elab_Check on the call\n-   --  so that a dynamic check is generated, and output a warning.\n-\n-   --  For calls to a subprogram in a with'ed unit, we require that\n-   --  a pragma Elaborate_All or pragma Elaborate be present, or that\n-   --  the referenced unit have a pragma Preelaborate, pragma Pure, or\n-   --  pragma Elaborate_Body. If none of these conditions is met, then\n-   --  a warning is generated that a pragma Elaborate_All may be needed.\n+   --  In the case of an elaboration call at the outer level, we must trace\n+   --  all calls to outer level routines either within the current unit or to\n+   --  other units that are with'ed. For calls within the current unit, we can\n+   --  determine if the body has been elaborated or not, and if it has not,\n+   --  then a warning is generated.\n+\n+   --  Note that there are two subcases. If the original call directly calls a\n+   --  subprogram whose body has not been elaborated, then we know that an ABE\n+   --  will take place, and we replace the call by a raise of Program_Error.\n+   --  If the call is indirect, then we don't know that the PE will be raised,\n+   --  since the call might be guarded by a conditional. In this case we set\n+   --  Do_Elab_Check on the call so that a dynamic check is generated, and\n+   --  output a warning.\n+\n+   --  For calls to a subprogram in a with'ed unit or a 'Access or variable\n+   --  refernece (SPARK mode case), we require that a pragma Elaborate_All\n+   --  or pragma Elaborate be present, or that the referenced unit have a\n+   --  pragma Preelaborate, pragma Pure, or pragma Elaborate_Body. If none\n+   --  of these conditions is met, then a warning is generated that a pragma\n+   --  Elaborate_All may be needed (error in the SPARK case), or an implicit\n+   --  pragma is generated.\n \n    --  For the case of an elaboration call at some inner level, we are\n    --  interested in tracing only calls to subprograms at the same level,\n@@ -86,9 +93,8 @@ package Sem_Elab is\n    --  Elaborate on a with'ed unit guarantees that subprograms within the\n    --  unit can be called without causing an ABE. This is not in fact the\n    --  case since pragma Elaborate does not guarantee the transitive\n-   --  coverage guaranteed by Elaborate_All. However, we leave this issue\n-   --  up to the binder, which has generates warnings if there are possible\n-   --  problems in the use of pragma Elaborate.\n+   --  coverage guaranteed by Elaborate_All. However, we decide to trust\n+   --  the user in this case.\n \n    --------------------------------------\n    -- Instantiation Elaboration Errors --\n@@ -124,11 +130,21 @@ package Sem_Elab is\n       In_Init_Proc : Boolean   := False);\n    --  Check a call for possible elaboration problems. The node N is either an\n    --  N_Function_Call or N_Procedure_Call_Statement node or an access\n-   --  attribute reference whose prefix is a subprogram. The Outer_Scope\n-   --  argument indicates whether this is an outer level call from Sem_Res\n-   --  (Outer_Scope set to Empty), or an internal recursive call (Outer_Scope\n-   --  set to entity of outermost call, see body). Flag In_Init_Proc should be\n-   --  set whenever the current context is a type init proc.\n+   --  attribute reference whose prefix is a subprogram.\n+   --\n+   --  If SPARK_Mode is On, then N can also be a variablr reference, since\n+   --  SPARK requires the use of Elaborate_All for references to variables\n+   --  in other packages.\n+\n+   --  The Outer_Scope argument indicates whether this is an outer level\n+   --  call from Sem_Res (Outer_Scope set to Empty), or an internal recursive\n+   --  call (Outer_Scope set to entity of outermost call, see body). The flag\n+   --  In_Init_Proc should be set whenever the current context is a type\n+   --  init proc.\n+\n+   --  Note: this might better be called Check_Elab_Reference (to recognize\n+   --  the SPARK case), but we prefer to keep the original name, since this\n+   --  is primarily used for checking for calls that could generate an ABE).\n \n    procedure Check_Elab_Calls;\n    --  Not all the processing for Check_Elab_Call can be done at the time"}, {"sha": "8b0f6585f882bdc80207e0758a25068a7bb8a396", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de4899bb19823f4865b060823eab2bdeba9c6fee/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de4899bb19823f4865b060823eab2bdeba9c6fee/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=de4899bb19823f4865b060823eab2bdeba9c6fee", "patch": "@@ -7172,8 +7172,8 @@ package body Sem_Res is\n       if SPARK_Mode = On\n         and then Is_Object (E)\n         and then Is_Effectively_Volatile (E)\n-        and then\n-          (Async_Writers_Enabled (E) or else Effective_Reads_Enabled (E))\n+        and then (Async_Writers_Enabled (E)\n+                   or else Effective_Reads_Enabled (E))\n         and then Comes_From_Source (N)\n       then\n          --  The effectively volatile objects appears in a \"non-interfering\n@@ -7197,6 +7197,12 @@ package body Sem_Res is\n       if Is_Ghost_Entity (E) and then Comes_From_Source (N) then\n          Check_Ghost_Context (E, N);\n       end if;\n+\n+      --  In SPARK mode, need to check possible elaboration issues\n+\n+      if SPARK_Mode = On and then Ekind (E) = E_Variable then\n+         Check_Elab_Call (N);\n+      end if;\n    end Resolve_Entity_Name;\n \n    -------------------"}]}